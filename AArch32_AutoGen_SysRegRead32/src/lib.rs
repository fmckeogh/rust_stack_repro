#![no_std]
#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_doc_comments)]
#![allow(non_upper_case_globals)]
//! BOREALIS GENERATED FILE
extern crate alloc;
use ICH_LR_SysRegRead32_aff6b82779d5a019::*;
use PMEVCNTR_SysRegRead32_7f423837889a1eb7::*;
use ICH_LR_SysRegRead32_ca0e018c3a31cc4a::*;
use PMEVTYPER_SysRegRead32_b74d04d561403857::*;
use DBGDTRRXext_SysRegRead32_4782be13f891eb2e::*;
use ICC_MSRE_SysRegRead32_79a8be5256989c32::*;
use ICH_LR_SysRegRead32_3bf5b46e983d4c12::*;
use HSTR_SysRegRead32_1f7e6811bde077a5::*;
use DBGWCR_SysRegRead32_3b1b0be7aff03388::*;
use HCR2_SysRegRead32_f7ed44285bae255b::*;
use PMEVTYPER_SysRegRead32_ee465be2d00a40c6::*;
use CNTFRQ_SysRegRead32_4d7a0faa14f3d1f9::*;
use TCMTR_SysRegRead32_88195aa504d1c43a::*;
use DBGDEVID2_SysRegRead32_6baefcc664f89312::*;
use PMEVTYPER_SysRegRead32_3dc043fab8866695::*;
use AIDR_SysRegRead32_ce556bd47a2bd19b::*;
use DBGWCR_SysRegRead32_34b30f3cf3218c16::*;
use ICC_IAR0_SysRegRead32_22d846d8001a81c5::*;
use HACR_SysRegRead32_a717d701accd9575::*;
use ID_DFR0_SysRegRead32_cc2c637f50f14510::*;
use ISR_SysRegRead32_6db4255755bcf0b1::*;
use PMEVCNTR_SysRegRead32_a0e4f3bc8390131d::*;
use AIFSR_SysRegRead32_dcd7a0d08b788988::*;
use ICH_AP1R_SysRegRead32_21b1b518e28be46b::*;
use ADFSR_SysRegRead32_12834f15645083f8::*;
use ID_ISAR2_SysRegRead32_24153ecb491475a1::*;
use DBGBCR_SysRegRead32_f6f0a6ec5a19d902::*;
use AMEVTYPER1_SysRegRead32_6862bf1fd0c624fa::*;
use AMUSERENR_SysRegRead32_a8f18bf4f7170234::*;
use HADFSR_SysRegRead32_c586b2ce1fe8150f::*;
use CSSELR_SysRegRead32_b9908a214e4391b4::*;
use AMCGCR_SysRegRead32_ec0083efd88e8df5::*;
use DBGWVR_SysRegRead32_4f5bca529a325f7f::*;
use ICV_AP0R_SysRegRead32_30ba9fd61ae1e604::*;
use DBGWCR_SysRegRead32_696fee9dbbdf30bb::*;
use ICH_LRC_SysRegRead32_1fc599a8419d7830::*;
use PMEVTYPER_SysRegRead32_9a798dcf0daf95cb::*;
use DBGBCR_SysRegRead32_cdd1fd850dc45db5::*;
use DBGBCR_SysRegRead32_cbd47314947043c8::*;
use ID_PFR1_SysRegRead32_699454254ae0abbb::*;
use DBGWVR_SysRegRead32_f5ed12ff92151086::*;
use DBGWVR_SysRegRead32_00161ecd371e1b48::*;
use DBGBXVR_SysRegRead32_9a88c64f6ef204ae::*;
use PMEVCNTR_SysRegRead32_029a264e693ebe08::*;
use TRFCR_SysRegRead32_4539d9acce538415::*;
use AMEVTYPER1_SysRegRead32_56620f65cf2520b9::*;
use DBGBVR_SysRegRead32_c4752bdaff15ec68::*;
use CNTHCTL_SysRegRead32_36df328680cb805f::*;
use DBGDEVID1_SysRegRead32_faeb62347ce88c7a::*;
use HACTLR2_SysRegRead32_0445e99237541ba9::*;
use PMEVTYPER_SysRegRead32_b777a7113ecfbff9::*;
use AMEVTYPER1_SysRegRead32_a5bece13ef847a3b::*;
use DBGCLAIMCLR_SysRegRead32_42a543613e49cb33::*;
use ICV_AP1R_SysRegRead32_97b8eb46fd54eb2b::*;
use PMEVTYPER_SysRegRead32_e8862be86d9568ea::*;
use CCSIDR2_SysRegRead32_b747ebd0fcc6df4e::*;
use DBGBVR_SysRegRead32_08fe9e5e419581ae::*;
use DBGBXVR_SysRegRead32_7511d8f154b2cfe2::*;
use AMEVTYPER1_SysRegRead32_e5dbca925a693d3a::*;
use ICC_HPPIR0_SysRegRead32_b32431f23ec6243a::*;
use CNTHP_TVAL_SysRegRead32_fdd1a67f3e306983::*;
use DBGWCR_SysRegRead32_427272e014730b50::*;
use AArch32_UnallocatedSysRegAccess::*;
use DBGWVR_SysRegRead32_a8d1c2ea29be76f1::*;
use TPIDRURW_SysRegRead32_844b54dbacb876a1::*;
use PMEVCNTR_SysRegRead32_6b342829d2da8112::*;
use DBGBCR_SysRegRead32_4aa006511c22539c::*;
use DBGWVR_SysRegRead32_672b3a4673cc16b1::*;
use DBGBXVR_SysRegRead32_dac7cb34b3ce5d73::*;
use PMEVTYPER_SysRegRead32_bfb617825f6df35a::*;
use DBGBVR_SysRegRead32_4a2928b59ff2bd88::*;
use HDFAR_SysRegRead32_b442fa1081ced0da::*;
use ICC_MGRPEN1_SysRegRead32_92bbab53b6030359::*;
use DSPSR_SysRegRead32_b8ab5544c94609ec::*;
use AMEVTYPER1_SysRegRead32_b4ee1ae1a6a9e5fe::*;
use HTPIDR_SysRegRead32_882efba325cc7f8f::*;
use DBGBXVR_SysRegRead32_8e4aad430b2ecf98::*;
use DBGBVR_SysRegRead32_1730a99ffdcdb940::*;
use PMEVCNTR_SysRegRead32_396f7b80977acfd5::*;
use DFSR_SysRegRead32_094c65de67978ba7::*;
use ICV_RPR_SysRegRead32_ce7e7d8c013c544d::*;
use PMEVCNTR_SysRegRead32_6a5d074d2473e341::*;
use DBGWCR_SysRegRead32_f40826807efdc23f::*;
use IFAR_SysRegRead32_22cba1cec07771af::*;
use DBGDSCRint_SysRegRead32_4d6240b644e5e8d8::*;
use ICH_LR_SysRegRead32_8e77adbc9c8c8d7d::*;
use ICV_AP1R_SysRegRead32_f50b3adcd6cb4d7f::*;
use PMCCNTR_SysRegRead32_5914763424cd4baf::*;
use AMEVTYPER1_SysRegRead32_ecafc26f65f1dda2::*;
use AMEVTYPER0_SysRegRead32_3d4ae79d0a2a83f7::*;
use JIDR_SysRegRead32_f362dc25ffe4f377::*;
use DLR_SysRegRead32_8fb9614c85c3b992::*;
use DBGBXVR_SysRegRead32_718e496a0f71d413::*;
use DBGDSAR_SysRegRead32_94ff484a75802dcb::*;
use PMCR_SysRegRead32_fb694f2a3eabe8b5::*;
use PMOVSSET_SysRegRead32_c13d421fe8504cc2::*;
use ICH_MISR_SysRegRead32_b1b3df82fdb149c6::*;
use AMEVTYPER1_SysRegRead32_3d5ee14ab14e0600::*;
use DBGBXVR_SysRegRead32_7ae84360e0b64934::*;
use DBGBVR_SysRegRead32_3127ee8e7174eb76::*;
use PMEVTYPER_SysRegRead32_33e8370847f18109::*;
use PMUSERENR_SysRegRead32_a6257daec876c857::*;
use AMAIR0_SysRegRead32_9c3a882cb83d441e::*;
use PMEVCNTR_SysRegRead32_63ff5bc2709c8d46::*;
use PMEVTYPER_SysRegRead32_45af701dced58b54::*;
use ID_PFR2_SysRegRead32_d658419137606f13::*;
use ICH_LR_SysRegRead32_3d583fbb8aa5513b::*;
use ID_AFR0_SysRegRead32_49547d26babbff09::*;
use DBGDTRTXext_SysRegRead32_dbe218a3250d179f::*;
use ICH_LRC_SysRegRead32_376ab6d5a4721697::*;
use AMEVTYPER1_SysRegRead32_727db649d7fd62f8::*;
use DBGOSLSR_SysRegRead32_7c8a1f5e56c0fe64::*;
use PMEVTYPER_SysRegRead32_011983e256b06e5a::*;
use DBGWCR_SysRegRead32_c04d3d89801ab85d::*;
use DBGBXVR_SysRegRead32_f467d6fedc917b46::*;
use PMEVCNTR_SysRegRead32_e863a7e57380d153::*;
use DBGWVR_SysRegRead32_2e5f3331ba566316::*;
use DBGBXVR_SysRegRead32_e9303c37358e3794::*;
use ERXMISC5_SysRegRead32_e7e0b0e38858a927::*;
use HIFAR_SysRegRead32_97075d5570b400a8::*;
use ICH_LRC_SysRegRead32_c7c19edd6493b5c7::*;
use HMAIR0_SysRegRead32_f157e09e6f0e50a5::*;
use DBGBVR_SysRegRead32_3b08f67b830efeb5::*;
use VDISR_SysRegRead32_1bd7b149463ed2f1::*;
use PMCNTENSET_SysRegRead32_2d54f3b38c0729f6::*;
use PMEVCNTR_SysRegRead32_567f48afcd553f0b::*;
use HMAIR1_SysRegRead32_fd5c958c2380e7ae::*;
use HSCTLR_SysRegRead32_7d1999deb1c478b9::*;
use CNTHVS_CTL_SysRegRead32_a44e5d4ed8fbfe64::*;
use PMEVCNTR_SysRegRead32_acccf1406f935146::*;
use ERRIDR_SysRegRead32_98e51b40bf051290::*;
use HVBAR_SysRegRead32_d6c8aecebbe5fd70::*;
use PMMIR_SysRegRead32_39e2ebac78343651::*;
use ICV_IGRPEN0_SysRegRead32_762db4bb97023cca::*;
use PMEVCNTR_SysRegRead32_1560b599f2aebd5f::*;
use ERXSTATUS_SysRegRead32_5466a91990979d70::*;
use DBGOSDLR_SysRegRead32_c1e6447a93f7efb4::*;
use ICH_AP0R_SysRegRead32_941887291ce9d9ce::*;
use CPACR_SysRegRead32_3e95a711394f5115::*;
use ICH_AP0R_SysRegRead32_f7de8d51fc141ec6::*;
use DBGWVR_SysRegRead32_0f5b4c975d3928f0::*;
use ERXCTLR_SysRegRead32_223464c9a84e4bc3::*;
use AMEVTYPER0_SysRegRead32_2e79e456f9d1dcd3::*;
use ICH_LRC_SysRegRead32_ff6694005f1d0b3b::*;
use ICH_LRC_SysRegRead32_ebf1ecd69e0bcfb2::*;
use HTCR_SysRegRead32_ad0d0f0fabd96a9f::*;
use PMEVCNTR_SysRegRead32_45099baba0e3c6c8::*;
use ICH_LRC_SysRegRead32_7819c0333582e456::*;
use CNTV_TVAL_SysRegRead32_ac1a47c2d11f8dd9::*;
use DBGBXVR_SysRegRead32_745a1f5c08c2c352::*;
use PMCEID0_SysRegRead32_827b64f588d9ff2d::*;
use DBGAUTHSTATUS_SysRegRead32_e99aa927d23f6bfc::*;
use DBGBVR_SysRegRead32_00f589dd9b6e498d::*;
use ICV_AP0R_SysRegRead32_dc4d5081c52e9718::*;
use ID_ISAR5_SysRegRead32_32e7eeb4ddf57791::*;
use ICH_VMCR_SysRegRead32_c4afb8cb8e0d0a5d::*;
use PMEVTYPER_SysRegRead32_787de500d1f2ae74::*;
use ICH_AP1R_SysRegRead32_893d03c9b3bc367a::*;
use DBGBVR_SysRegRead32_c036021238cbadaa::*;
use AMEVTYPER0_SysRegRead32_2bb2f6721c44cef6::*;
use ICH_LRC_SysRegRead32_604585b24b60fdae::*;
use PMEVTYPER_SysRegRead32_cee8110828f1d34e::*;
use DBGWCR_SysRegRead32_fba46a7399a2c310::*;
use ERXCTLR2_SysRegRead32_538545d1d2bef52f::*;
use ICH_LRC_SysRegRead32_5e3a0d745c54eaf7::*;
use PMOVSR_SysRegRead32_3a98253be39f82fc::*;
use ICH_LR_SysRegRead32_1acb03f084987252::*;
use PMEVTYPER_SysRegRead32_b14a395988483b96::*;
use HPFAR_SysRegRead32_985da2a8b12c2ec3::*;
use PMEVTYPER_SysRegRead32_5a6097f662a615bc::*;
use TTBCR2_SysRegRead32_9005164b21d17bb0::*;
use TTBR1_SysRegRead32_bbb7c8fdac68a224::*;
use DBGWVR_SysRegRead32_da9f18e2f273c366::*;
use DBGBXVR_SysRegRead32_e8fd3bc58d8acce2::*;
use PMXEVTYPER_SysRegRead32_7d423ea169145383::*;
use ID_ISAR4_SysRegRead32_851598e56793628d::*;
use AMEVTYPER1_SysRegRead32_72835fc6dfc4b11f::*;
use ERXMISC4_SysRegRead32_6139ba68e2078794::*;
use HAMAIR1_SysRegRead32_b4da9627c11c58d9::*;
use NSACR_SysRegRead32_a9b2f143c1a6ce93::*;
use PMEVTYPER_SysRegRead32_2680120d4a51efdc::*;
use PMEVCNTR_SysRegRead32_42630578733f5de1::*;
use HDCR_SysRegRead32_ca37580e50123c00::*;
use PMEVCNTR_SysRegRead32_039d4c0d22de13a2::*;
use PMEVTYPER_SysRegRead32_b52dcbee696e133d::*;
use PMEVTYPER_SysRegRead32_e8227d66c6f9da2f::*;
use ICH_LR_SysRegRead32_b53ec5837b358bc1::*;
use RMR_SysRegRead32_43cf65be6b4153a2::*;
use ICH_LR_SysRegRead32_9b173de940ca1870::*;
use CCSIDR_SysRegRead32_4e417948cc9050d5::*;
use JMCR_SysRegRead32_f5fe518171c35ee0::*;
use PMEVTYPER_SysRegRead32_4afbf88ec8f5d079::*;
use ICC_PMR_SysRegRead32_aa604b328cea6616::*;
use ICH_AP1R_SysRegRead32_19b0a11aa0aeb1f4::*;
use PMSELR_SysRegRead32_cbb0200049a096ed::*;
use ICV_AP0R_SysRegRead32_c3c1719656dd9c14::*;
use DBGBVR_SysRegRead32_54fa7eb1a8a086d2::*;
use DBGBCR_SysRegRead32_216d13962e754b99::*;
use ICV_AP1R_SysRegRead32_c631f0bb4000bb22::*;
use PMCNTENCLR_SysRegRead32_fae3650c5f5d677d::*;
use ID_PFR0_SysRegRead32_aa91a2f0748f31d4::*;
use AMCNTENCLR1_SysRegRead32_d9e05aee283dea2c::*;
use PMEVTYPER_SysRegRead32_ade15d0dc858c933::*;
use IFSR_SysRegRead32_20bacf70303447cc::*;
use ICH_LR_SysRegRead32_223cf2e0fdc1ff05::*;
use ICH_LR_SysRegRead32_3dfad36dd01cdeec::*;
use PMEVCNTR_SysRegRead32_a6f4d7c9818fe27f::*;
use DBGWCR_SysRegRead32_862efdc01d71fc1c::*;
use DBGBXVR_SysRegRead32_78ef58571ab2de22::*;
use AMCFGR_SysRegRead32_f4b1155615a324f5::*;
use TPIDRPRW_SysRegRead32_2042d633efa21064::*;
use ID_MMFR4_SysRegRead32_8caa2bb66e738b87::*;
use DBGWCR_SysRegRead32_c5e0186238203543::*;
use ICC_BPR0_SysRegRead32_7c3bac42de4de5ac::*;
use ICH_LRC_SysRegRead32_ede8f5720388c87c::*;
use ACTLR2_SysRegRead32_b5235ae9298d37ab::*;
use ICC_HSRE_SysRegRead32_0e6b0f816b017dd6::*;
use VTCR_SysRegRead32_23b906196b602c93::*;
use ICC_BPR1_SysRegRead32_afd3e126a3be69bd::*;
use DBGBXVR_SysRegRead32_52c85c2c5daef517::*;
use ERRSELR_SysRegRead32_89386228f05f3e86::*;
use DBGBVR_SysRegRead32_aeb056e353dc1a63::*;
use TTBR0_SysRegRead32_ba6eb6544c3c44a1::*;
use AMEVTYPER1_SysRegRead32_d76669b6678fb9d9::*;
use DBGBCR_SysRegRead32_2a19913e0ff50654::*;
use PMEVCNTR_SysRegRead32_f577cb392ba87833::*;
use ERXFR2_SysRegRead32_2ed16754dcca71f1::*;
use DBGBCR_SysRegRead32_db1b198c49f933c0::*;
use DBGWVR_SysRegRead32_b4df3a7002c9f7a0::*;
use DBGBVR_SysRegRead32_82067dc9734a6b24::*;
use PMEVCNTR_SysRegRead32_ab42fc938eac6b81::*;
use DBGWCR_SysRegRead32_c11448c554efe1b1::*;
use DBGWCR_SysRegRead32_60f3efc31648e354::*;
use PMEVTYPER_SysRegRead32_2a2c31ce2d7ed27e::*;
use PMCEID2_SysRegRead32_68a39928b2956924::*;
use SCR_SysRegRead32_7742164cbe24da83::*;
use ICH_LRC_SysRegRead32_2d5fdc0c0df5489a::*;
use PMEVTYPER_SysRegRead32_019fd9c590c5493b::*;
use DBGBCR_SysRegRead32_01c2798f5fc44bfa::*;
use ICC_MCTLR_SysRegRead32_f1e0f70708724584::*;
use DBGWCR_SysRegRead32_a166e9fb14e381a7::*;
use DBGDCCINT_SysRegRead32_ba602311e159b54c::*;
use HAIFSR_SysRegRead32_6fddec5e27f03691::*;
use HRMR_SysRegRead32_ce0678ac4cae9992::*;
use ICV_IGRPEN1_SysRegRead32_9335bbfc906f43aa::*;
use ERXMISC2_SysRegRead32_17926cb7ab87a983::*;
use ICH_LRC_SysRegRead32_2f30eacc54c36948::*;
use CONTEXTIDR_SysRegRead32_a8d33c511e223d46::*;
use DBGDEVID_SysRegRead32_66290830e754b76a::*;
use CNTKCTL_SysRegRead32_9166ed3878001f60::*;
use PMEVCNTR_SysRegRead32_1774c818fab12807::*;
use VMPIDR_SysRegRead32_e5aa49e29a7b94ba::*;
use DBGPRCR_SysRegRead32_ff2c6b0471b55490::*;
use DBGBVR_SysRegRead32_731a4ca5463f9ac4::*;
use ICC_SRE_SysRegRead32_4fd5ef8b1be9c965::*;
use DBGVCR_SysRegRead32_19db55a72a941c5f::*;
use VMPIDR_SysRegRead32_2f5b95225c646973::*;
use DBGBVR_SysRegRead32_0d7192e87273fee3::*;
use PMEVTYPER_SysRegRead32_34d3c9683f50305a::*;
use PMEVTYPER_SysRegRead32_a724b3fb2f78856f::*;
use ID_MMFR3_SysRegRead32_e386d40c006b0b90::*;
use DBGOSECCR_SysRegRead32_391dd35ddd37f699::*;
use DBGBCR_SysRegRead32_524a8653177fde8f::*;
use CNTHP_TVAL_SysRegRead32_ea212b21a99af571::*;
use ICH_LRC_SysRegRead32_fa7f4e2cc52b6a12::*;
use PMEVCNTR_SysRegRead32_01bab0512200ef97::*;
use AMEVTYPER0_SysRegRead32_d72cb28d75eca03e::*;
use DACR_SysRegRead32_a5e223b70013760e::*;
use HACTLR_SysRegRead32_2bf8282054123267::*;
use CNTHP_CTL_SysRegRead32_5ea09b260a579171::*;
use ID_ISAR1_SysRegRead32_2151a78ccf12fa49::*;
use TLBTR_SysRegRead32_2cb899c86cc4ff56::*;
use DBGDIDR_SysRegRead32_8ee636612218bdd3::*;
use DBGBCR_SysRegRead32_e0d675a59f2b5c3e::*;
use ICV_AP1R_SysRegRead32_06c655ca9c8e2c1e::*;
use PMEVCNTR_SysRegRead32_83a06d357cd23a85::*;
use DBGBXVR_SysRegRead32_4c6fa7f444c624cb::*;
use AMCNTENSET0_SysRegRead32_941308a2fea42e28::*;
use DBGWCR_SysRegRead32_c49e6cc415f000b3::*;
use ID_ISAR6_SysRegRead32_b87615d75481dd47::*;
use PMEVCNTR_SysRegRead32_07d83a1ba6647217::*;
use AMEVTYPER1_SysRegRead32_3704564c9ad105a9::*;
use DBGBXVR_SysRegRead32_56d437c5026e56e6::*;
use PMCEID1_SysRegRead32_dc9c0fe15ac731b4::*;
use DBGBVR_SysRegRead32_4b2492f939b2d68d::*;
use CTR_SysRegRead32_99a8e042837c333b::*;
use PMEVTYPER_SysRegRead32_345e68f734e8d287::*;
use ID_ISAR0_SysRegRead32_bb26ec35196a236d::*;
use PMXEVCNTR_SysRegRead32_3357c1d37107c40d::*;
use SDCR_SysRegRead32_c381e11131eb8dc4::*;
use DBGBXVR_SysRegRead32_fa2068509c645345::*;
use PMEVTYPER_SysRegRead32_2d5128aa6d782f92::*;
use PMEVCNTR_SysRegRead32_d5dc3b561b7d1a1d::*;
use DBGDSCRext_SysRegRead32_bbe7b972eea0caec::*;
use ID_DFR1_SysRegRead32_a7aac5df14f5281e::*;
use PMEVTYPER_SysRegRead32_cad120e9f2cb9ca7::*;
use HSR_SysRegRead32_8b698f9bb5858477::*;
use ICH_LR_SysRegRead32_7cf030ba66b1e3f5::*;
use ID_ISAR3_SysRegRead32_417ae56f4d3a61c8::*;
use ERXMISC6_SysRegRead32_9abf31f5358e2067::*;
use DFAR_SysRegRead32_24eaaed98bd8c8b9::*;
use ICH_LR_SysRegRead32_074065db8610395b::*;
use ACTLR_SysRegRead32_6cec3685fb7200c1::*;
use PMEVTYPER_SysRegRead32_d18be2a53d09e4e3::*;
use ICH_LRC_SysRegRead32_792ff81aa718ff76::*;
use VPIDR_SysRegRead32_4e4cbaa7ba154382::*;
use AMCR_SysRegRead32_3740e4968cc5855a::*;
use AMEVTYPER1_SysRegRead32_aefd3ad06352acdf::*;
use PMEVCNTR_SysRegRead32_4e38caf85e50badb::*;
use PMEVCNTR_SysRegRead32_70f084c8c157c7b4::*;
use PMINTENCLR_SysRegRead32_f6b2fae1205a00f6::*;
use PMEVCNTR_SysRegRead32_707b33e723e1c43a::*;
use DBGWCR_SysRegRead32_2c8e3f6807d0cbe3::*;
use PRRR_SysRegRead32_4a556a683141be75::*;
use DISR_SysRegRead32_9f42ad0cc10a5f19::*;
use DBGBVR_SysRegRead32_7547e126cd447504::*;
use ICH_LRC_SysRegRead32_9d34a1da3a3d8af6::*;
use AMEVTYPER1_SysRegRead32_3f1d2f749c9eacac::*;
use ICH_LRC_SysRegRead32_a29c320b6a841a2d::*;
use AMAIR1_SysRegRead32_abbf588378c53393::*;
use PMCCFILTR_SysRegRead32_1da10de344b09eac::*;
use PMEVCNTR_SysRegRead32_3cff703cf4dc4c8d::*;
use ICH_LR_SysRegRead32_1d761f8769ecc810::*;
use FCSEIDR_SysRegRead32_cb9b2f57b39997f9::*;
use SDER_SysRegRead32_0b9374021ce6ef0e::*;
use HTRFCR_SysRegRead32_b1ffee03b0b71c5a::*;
use DBGWCR_SysRegRead32_fa67eb6a8f2349c1::*;
use DBGWVR_SysRegRead32_4bb9af81a75faa61::*;
use ERXMISC7_SysRegRead32_99b78145ea2ea108::*;
use PMINTENSET_SysRegRead32_44a5f589c4b56eb5::*;
use DBGBCR_SysRegRead32_5711831aec3ae94d::*;
use DBGBVR_SysRegRead32_7ba934859e2de1ac::*;
use ICC_IAR1_SysRegRead32_8d514dfe4b6957fe::*;
use ICH_ELRSR_SysRegRead32_1d9d4e5a379e315c::*;
use ICV_AP0R_SysRegRead32_72af30ac5c792211::*;
use ERXMISC1_SysRegRead32_24c39414a2e1d0b1::*;
use ICV_HPPIR1_SysRegRead32_b45bf9d6297cda27::*;
use ICH_LR_SysRegRead32_91b224d16fef9888::*;
use PAR_SysRegRead32_6e09f827d9ae2cf7::*;
use ICH_LR_SysRegRead32_45c00df4516639fa::*;
use PMEVCNTR_SysRegRead32_896d408c19840560::*;
use DBGBCR_SysRegRead32_8fb0687c13a9ae99::*;
use DBGWVR_SysRegRead32_7cd7645018d2576e::*;
use ID_MMFR2_SysRegRead32_9a2dcb4cb3946cb0::*;
use TPIDRURO_SysRegRead32_331a0b9503da6305::*;
use JOSCR_SysRegRead32_64dbf044d539336d::*;
use HCR_SysRegRead32_9baa0bb29521adc6::*;
use PMEVCNTR_SysRegRead32_ae92cdab2a8b2c18::*;
use DBGWVR_SysRegRead32_de66eaaa5ee8659b::*;
use TTBCR_SysRegRead32_254407681da2385f::*;
use PMEVTYPER_SysRegRead32_b68c85bd6c592527::*;
use DBGCLAIMSET_SysRegRead32_06784b0343d7d2f1::*;
use AMEVTYPER1_SysRegRead32_bc839289c9bacd64::*;
use AMEVTYPER1_SysRegRead32_5da5d2022384b9e4::*;
use DBGWVR_SysRegRead32_9fd65afd85a62538::*;
use VDFSR_SysRegRead32_0530b84beb618cd2::*;
use PMEVTYPER_SysRegRead32_70d9e1901968a9f9::*;
use DBGWCR_SysRegRead32_e262457611dfe741::*;
use DBGBXVR_SysRegRead32_1c27a604d2b4f32b::*;
use ID_MMFR0_SysRegRead32_80f3ab2fd79cbbab::*;
use AMCNTENCLR0_SysRegRead32_4cd517564ca44d4e::*;
use ERXFR_SysRegRead32_38334a5a99e8eedf::*;
use PMEVTYPER_SysRegRead32_8e1055d5eee8d8d8::*;
use ICH_EISR_SysRegRead32_6c8baaadbfc73196::*;
use DBGWVR_SysRegRead32_6a1d08c571006557::*;
use DBGBCR_SysRegRead32_4c18d60e0902660d::*;
use REVIDR_SysRegRead32_423676c78008247b::*;
use DBGDTRRXint_SysRegRead32_ce20085c05aae144::*;
use HAMAIR0_SysRegRead32_377efb316c773bdf::*;
use DBGWFAR_SysRegRead32_eb3aaa02963f85c2::*;
use ICH_AP0R_SysRegRead32_fa5d134ae7836c23::*;
use AMCNTENSET1_SysRegRead32_7b7457f3c7ff281b::*;
use MIDR_SysRegRead32_54aebb004f1db6c9::*;
use ICH_LR_SysRegRead32_1d190d8da488b71c::*;
use NMRR_SysRegRead32_f8e132fd5a9e9c17::*;
use ERXMISC3_SysRegRead32_2387d2346ca52482::*;
use ERXMISC0_SysRegRead32_945d1e7792b59484::*;
use PMCEID3_SysRegRead32_2032ab5473c7b6ab::*;
use ICV_CTLR_SysRegRead32_084685ae7c38b87e::*;
use DBGBCR_SysRegRead32_0c66b90b6558a3cb::*;
use PMEVTYPER_SysRegRead32_0ba0c427729d1f96::*;
use PMEVCNTR_SysRegRead32_138cd582631ad0fb::*;
use ID_MMFR1_SysRegRead32_1bde596fb100a5b5::*;
use DBGBCR_SysRegRead32_afe89ec5412ea81e::*;
use SCTLR_SysRegRead32_e01eef2d08d9809d::*;
use CNTHPS_CTL_SysRegRead32_a99d410e49082e9f::*;
use DBGWVR_SysRegRead32_c6ca5289ed10ec19::*;
use HCPTR_SysRegRead32_36b5e5e38803084d::*;
use ICH_VTR_SysRegRead32_1187208e70ad69e9::*;
use CLIDR_SysRegRead32_1324f310591d527a::*;
use DBGDRAR_SysRegRead32_421a9884bf20a229::*;
use VBAR_SysRegRead32_cbb282dd5c9d55ce::*;
use ERXADDR_SysRegRead32_ca0ccd8f0f00724b::*;
use DBGBCR_SysRegRead32_2c7e30fbae6d4b48::*;
use ICH_AP0R_SysRegRead32_8a9ae74c0d05c4d8::*;
use MVBAR_SysRegRead32_248e7559e6798c99::*;
use ICH_AP1R_SysRegRead32_0df0cbf9f8197fd3::*;
use DBGWVR_SysRegRead32_328f6a9c09b12c20::*;
use PMEVCNTR_SysRegRead32_7153d356d6a0fa3b::*;
use ID_MMFR5_SysRegRead32_e1f37b0c1fecac4d::*;
use PMEVCNTR_SysRegRead32_009022738d54bbb6::*;
use ERXADDR2_SysRegRead32_ee8844bbda44b8b3::*;
use ICH_HCR_SysRegRead32_49d2eca523adf51c::*;
use ICH_LRC_SysRegRead32_ce80e380eb49f8f4::*;
use AMEVTYPER1_SysRegRead32_30353b694529c623::*;
use DSPSR2_SysRegRead32_6da9b04f72c6c3f2::*;
use common::*;
pub fn AArch32_AutoGen_SysRegRead32<T: Tracer>(
    state: &mut State,
    tracer: &T,
    el: u8,
    coproc: u8,
    opc1: u8,
    CRn: u8,
    opc2: u8,
    CRm: u8,
    t: i128,
) -> () {
    #[derive(Default)]
    struct FunctionState {
        gs_118264: bool,
        gs_118551: bool,
        gs_119023: bool,
        gs_118753: bool,
        gs_118378: bool,
        gs_118290: bool,
        gs_117743: bool,
        gs_118607: bool,
        gs_118250: bool,
        gs_118137: bool,
        gs_119025: bool,
        gs_118783: bool,
        gs_117911: bool,
        gs_118416: bool,
        gs_117900: bool,
        gs_117663: bool,
        gs_119061: bool,
        gs_117871: bool,
        gs_118754: bool,
        gs_118866: bool,
        gs_117848: bool,
        gs_119139: bool,
        gs_117896: bool,
        gs_118619: bool,
        gs_118784: bool,
        gs_118382: bool,
        gs_118845: bool,
        gs_117888: bool,
        gs_118802: bool,
        gs_118387: bool,
        gs_118723: bool,
        gs_117820: bool,
        gs_118516: bool,
        gs_118189: bool,
        gs_117985: bool,
        gs_118045: bool,
        gs_118673: bool,
        gs_118415: bool,
        gs_117926: bool,
        gs_118882: bool,
        gs_118757: bool,
        gs_118648: bool,
        gs_118010: bool,
        gs_117705: bool,
        gs_118027: bool,
        gs_118408: bool,
        gs_118796: bool,
        gs_118276: bool,
        gs_119117: bool,
        gs_118943: bool,
        gs_118054: bool,
        gs_118508: bool,
        gs_118409: bool,
        gs_118007: bool,
        gs_118501: bool,
        gs_118523: bool,
        gs_118293: bool,
        gs_117715: bool,
        gs_118384: bool,
        gs_118909: bool,
        gs_118155: bool,
        gs_118374: bool,
        gs_118453: bool,
        gs_117765: bool,
        gs_118688: bool,
        gs_118243: bool,
        gs_118646: bool,
        gs_118571: bool,
        gs_118161: bool,
        gs_117957: bool,
        gs_118873: bool,
        gs_118112: bool,
        gs_118274: bool,
        gs_118667: bool,
        gs_117830: bool,
        gs_117717: bool,
        gs_117988: bool,
        gs_118809: bool,
        gs_118701: bool,
        gs_117603: bool,
        gs_117702: bool,
        gs_118776: bool,
        gs_117679: bool,
        gs_118211: bool,
        gs_117937: bool,
        gs_118132: bool,
        gs_119035: bool,
        gs_118780: bool,
        gs_117994: bool,
        gs_118128: bool,
        gs_117709: bool,
        gs_118591: bool,
        gs_118495: bool,
        gs_118871: bool,
        gs_118762: bool,
        gs_117984: bool,
        gs_117846: bool,
        gs_118735: bool,
        gs_118599: bool,
        gs_118284: bool,
        gs_118375: bool,
        gs_118489: bool,
        gs_117834: bool,
        gs_118913: bool,
        gs_118594: bool,
        gs_117589: bool,
        gs_118042: bool,
        gs_117721: bool,
        gs_118103: bool,
        gs_117720: bool,
        gs_118920: bool,
        gs_119040: bool,
        gs_117700: bool,
        gs_118691: bool,
        gs_117986: bool,
        gs_118386: bool,
        gs_118194: bool,
        gs_118744: bool,
        gs_117903: bool,
        gs_119073: bool,
        gs_117561: bool,
        gs_117610: bool,
        gs_118230: bool,
        gs_118821: bool,
        gs_118423: bool,
        gs_118396: bool,
        gs_117880: bool,
        gs_118620: bool,
        gs_118273: bool,
        gs_118043: bool,
        gs_118496: bool,
        gs_118912: bool,
        gs_117672: bool,
        gs_117932: bool,
        gs_118829: bool,
        gs_118669: bool,
        gs_118867: bool,
        gs_119075: bool,
        gs_119087: bool,
        gs_118647: bool,
        gs_119110: bool,
        gs_118512: bool,
        gs_118092: bool,
        gs_119037: bool,
        gs_119084: bool,
        gs_118720: bool,
        gs_118868: bool,
        gs_118910: bool,
        gs_117627: bool,
        gs_118430: bool,
        gs_118334: bool,
        gs_118603: bool,
        gs_117870: bool,
        gs_118176: bool,
        gs_118019: bool,
        gs_118214: bool,
        gs_118782: bool,
        gs_118839: bool,
        gs_118433: bool,
        gs_118196: bool,
        gs_118908: bool,
        gs_118095: bool,
        gs_118288: bool,
        gs_119105: bool,
        gs_117904: bool,
        gs_118680: bool,
        gs_119006: bool,
        gs_119152: bool,
        gs_119042: bool,
        gs_118978: bool,
        gs_118078: bool,
        gs_118675: bool,
        gs_118040: bool,
        gs_119051: bool,
        gs_118332: bool,
        gs_118595: bool,
        gs_117910: bool,
        gs_117687: bool,
        gs_118022: bool,
        gs_117607: bool,
        gs_118266: bool,
        gs_119071: bool,
        gs_118862: bool,
        gs_117779: bool,
        gs_118863: bool,
        gs_117719: bool,
        gs_119070: bool,
        gs_117657: bool,
        gs_118567: bool,
        gs_119003: bool,
        gs_117650: bool,
        gs_118074: bool,
        gs_118075: bool,
        gs_119128: bool,
        gs_117641: bool,
        gs_118265: bool,
        gs_118047: bool,
        gs_118661: bool,
        gs_118790: bool,
        gs_118643: bool,
        gs_119114: bool,
        gs_119020: bool,
        gs_118077: bool,
        gs_119017: bool,
        gs_117792: bool,
        gs_118698: bool,
        gs_118076: bool,
        gs_118289: bool,
        gs_118407: bool,
        gs_119014: bool,
        gs_119158: bool,
        gs_117674: bool,
        gs_118380: bool,
        gs_118037: bool,
        gs_118810: bool,
        gs_119095: bool,
        gs_118399: bool,
        gs_119031: bool,
        gs_118484: bool,
        gs_118679: bool,
        gs_118253: bool,
        gs_117987: bool,
        gs_117787: bool,
        gs_119155: bool,
        gs_118884: bool,
        gs_118640: bool,
        gs_118001: bool,
        gs_117959: bool,
        gs_118747: bool,
        gs_118344: bool,
        gs_117659: bool,
        gs_118363: bool,
        gs_118255: bool,
        gs_118830: bool,
        gs_118692: bool,
        gs_118121: bool,
        gs_117584: bool,
        gs_117797: bool,
        gs_118572: bool,
        gs_118721: bool,
        gs_118438: bool,
        gs_119116: bool,
        gs_117556: bool,
        gs_118114: bool,
        gs_117925: bool,
        gs_117852: bool,
        gs_118660: bool,
        gs_117831: bool,
        gs_118311: bool,
        gs_117633: bool,
        gs_118304: bool,
        gs_117788: bool,
        gs_118834: bool,
        gs_119009: bool,
        gs_118383: bool,
        gs_118169: bool,
        gs_117628: bool,
        gs_118761: bool,
        gs_118969: bool,
        gs_118623: bool,
        gs_118936: bool,
        gs_118016: bool,
        gs_118008: bool,
        gs_118159: bool,
        gs_117652: bool,
        gs_117859: bool,
        gs_118229: bool,
        gs_118324: bool,
        gs_117587: bool,
        gs_118589: bool,
        gs_118456: bool,
        gs_117563: bool,
        gs_118435: bool,
        gs_118093: bool,
        gs_118626: bool,
        gs_117801: bool,
        gs_117980: bool,
        gs_118002: bool,
        gs_118668: bool,
        gs_118892: bool,
        gs_117759: bool,
        gs_117752: bool,
        gs_118860: bool,
        gs_119067: bool,
        gs_118239: bool,
        gs_118083: bool,
        gs_119063: bool,
        gs_118237: bool,
        gs_118051: bool,
        gs_118710: bool,
        gs_118683: bool,
        gs_117935: bool,
        gs_118178: bool,
        gs_118349: bool,
        gs_119167: bool,
        gs_118973: bool,
        gs_118203: bool,
        gs_118271: bool,
        gs_119028: bool,
        gs_118345: bool,
        gs_119098: bool,
        gs_117696: bool,
        gs_117802: bool,
        gs_118198: bool,
        gs_117649: bool,
        gs_118340: bool,
        gs_117737: bool,
        gs_118511: bool,
        gs_118406: bool,
        gs_119115: bool,
        gs_117670: bool,
        gs_118464: bool,
        gs_117774: bool,
        gs_118596: bool,
        gs_118200: bool,
        gs_118147: bool,
        gs_117693: bool,
        gs_118759: bool,
        gs_119146: bool,
        gs_118219: bool,
        gs_119077: bool,
        gs_118046: bool,
        gs_118307: bool,
        gs_117960: bool,
        gs_118297: bool,
        gs_118895: bool,
        gs_118815: bool,
        gs_118182: bool,
        gs_118173: bool,
        gs_117825: bool,
        gs_119081: bool,
        gs_117758: bool,
        gs_118982: bool,
        gs_117697: bool,
        gs_118272: bool,
        gs_118574: bool,
        gs_118737: bool,
        gs_118497: bool,
        gs_118531: bool,
        gs_118808: bool,
        gs_117636: bool,
        gs_118347: bool,
        gs_117550: bool,
        gs_118498: bool,
        gs_118269: bool,
        gs_117812: bool,
        gs_118411: bool,
        gs_119126: bool,
        gs_117686: bool,
        gs_118787: bool,
        gs_118154: bool,
        gs_119019: bool,
        gs_119076: bool,
        gs_119034: bool,
        gs_118004: bool,
        gs_117678: bool,
        gs_118699: bool,
        gs_118560: bool,
        gs_118946: bool,
        gs_117769: bool,
        gs_118377: bool,
        gs_118529: bool,
        gs_117872: bool,
        gs_118715: bool,
        gs_118405: bool,
        gs_117832: bool,
        gs_118774: bool,
        gs_118899: bool,
        gs_117682: bool,
        gs_118504: bool,
        gs_118639: bool,
        gs_118166: bool,
        gs_117619: bool,
        gs_118597: bool,
        gs_118889: bool,
        gs_117727: bool,
        gs_117580: bool,
        gs_118575: bool,
        gs_118365: bool,
        gs_118689: bool,
        gs_118612: bool,
        gs_118461: bool,
        gs_118632: bool,
        gs_118071: bool,
        gs_119083: bool,
        gs_118840: bool,
        gs_117573: bool,
        gs_119160: bool,
        gs_118491: bool,
        gs_117914: bool,
        gs_118476: bool,
        gs_118031: bool,
        gs_118333: bool,
        gs_117863: bool,
        gs_118706: bool,
        gs_119074: bool,
        gs_118065: bool,
        gs_117570: bool,
        gs_119038: bool,
        gs_117710: bool,
        gs_117738: bool,
        gs_118185: bool,
        gs_117660: bool,
        gs_118299: bool,
        gs_117839: bool,
        gs_118877: bool,
        gs_118980: bool,
        gs_117889: bool,
        gs_119122: bool,
        gs_118716: bool,
        gs_118360: bool,
        gs_118798: bool,
        gs_118588: bool,
        gs_117691: bool,
        gs_117775: bool,
        gs_118295: bool,
        gs_119001: bool,
        gs_118035: bool,
        gs_117879: bool,
        gs_118468: bool,
        gs_118864: bool,
        gs_118397: bool,
        gs_118321: bool,
        gs_118890: bool,
        gs_118593: bool,
        gs_117591: bool,
        gs_118702: bool,
        gs_118549: bool,
        gs_117776: bool,
        gs_117990: bool,
        gs_119156: bool,
        gs_118847: bool,
        gs_118245: bool,
        gs_117771: bool,
        gs_118541: bool,
        gs_118058: bool,
        gs_118963: bool,
        gs_118109: bool,
        gs_118676: bool,
        gs_119060: bool,
        gs_118786: bool,
        gs_118633: bool,
        gs_118558: bool,
        gs_118257: bool,
        gs_118557: bool,
        gs_118911: bool,
        gs_118097: bool,
        gs_119135: bool,
        gs_118389: bool,
        gs_118136: bool,
        gs_118799: bool,
        gs_117851: bool,
        gs_118587: bool,
        gs_118855: bool,
        gs_118486: bool,
        gs_118903: bool,
        gs_117597: bool,
        gs_118585: bool,
        gs_118232: bool,
        gs_118947: bool,
        gs_119151: bool,
        gs_117876: bool,
        gs_117662: bool,
        gs_119010: bool,
        gs_117963: bool,
        gs_118817: bool,
        gs_118221: bool,
        gs_117564: bool,
        gs_117909: bool,
        gs_118479: bool,
        gs_118687: bool,
        gs_118985: bool,
        gs_117701: bool,
        gs_118034: bool,
        gs_117683: bool,
        gs_118577: bool,
        gs_118335: bool,
        gs_118030: bool,
        gs_118605: bool,
        gs_119149: bool,
        gs_118052: bool,
        gs_118107: bool,
        gs_117622: bool,
        gs_118800: bool,
        gs_118876: bool,
        gs_118009: bool,
        gs_117906: bool,
        gs_118803: bool,
        gs_118695: bool,
        gs_118861: bool,
        gs_117875: bool,
        gs_118926: bool,
        gs_118412: bool,
        gs_118937: bool,
        gs_117907: bool,
        gs_118062: bool,
        gs_117750: bool,
        gs_117786: bool,
        gs_117806: bool,
        gs_117808: bool,
        gs_117753: bool,
        gs_118924: bool,
        gs_117992: bool,
        gs_118038: bool,
        gs_118087: bool,
        gs_118878: bool,
        gs_118066: bool,
        gs_118381: bool,
        gs_118388: bool,
        gs_117952: bool,
        gs_118806: bool,
        gs_118555: bool,
        gs_117762: bool,
        gs_118842: bool,
        gs_118824: bool,
        gs_117840: bool,
        gs_118807: bool,
        gs_118988: bool,
        gs_119161: bool,
        gs_117600: bool,
        gs_117822: bool,
        gs_118993: bool,
        gs_119005: bool,
        gs_117768: bool,
        gs_117866: bool,
        gs_118296: bool,
        gs_118992: bool,
        gs_118364: bool,
        gs_117920: bool,
        gs_117968: bool,
        gs_118756: bool,
        gs_118371: bool,
        gs_118268: bool,
        gs_118287: bool,
        gs_118259: bool,
        gs_117557: bool,
        gs_118060: bool,
        gs_118291: bool,
        gs_118120: bool,
        gs_118998: bool,
        gs_117793: bool,
        gs_117795: bool,
        gs_118540: bool,
        gs_118994: bool,
        gs_117635: bool,
        gs_118294: bool,
        gs_118719: bool,
        gs_117953: bool,
        gs_118247: bool,
        gs_118956: bool,
        gs_117575: bool,
        gs_118402: bool,
        gs_118426: bool,
        gs_117939: bool,
        gs_117568: bool,
        gs_118893: bool,
        gs_118975: bool,
        gs_118447: bool,
        gs_118965: bool,
        gs_117936: bool,
        gs_117655: bool,
        gs_118500: bool,
        gs_118116: bool,
        gs_118644: bool,
        gs_118638: bool,
        gs_119111: bool,
        gs_119113: bool,
        gs_117892: bool,
        gs_119112: bool,
        gs_117844: bool,
        gs_118357: bool,
        gs_118044: bool,
        gs_119036: bool,
        gs_118731: bool,
        gs_118713: bool,
        gs_118728: bool,
        gs_117592: bool,
        gs_118246: bool,
        gs_118466: bool,
        gs_118322: bool,
        gs_119049: bool,
        gs_119044: bool,
        gs_118209: bool,
        gs_118441: bool,
        gs_118635: bool,
        gs_118298: bool,
        gs_118559: bool,
        gs_118530: bool,
        gs_117595: bool,
        gs_118102: bool,
        gs_118462: bool,
        gs_117680: bool,
        gs_117579: bool,
        gs_117921: bool,
        gs_118108: bool,
        gs_118509: bool,
        gs_118649: bool,
        gs_117790: bool,
        gs_117799: bool,
        gs_118771: bool,
        gs_118187: bool,
        gs_118576: bool,
        gs_118041: bool,
        gs_118368: bool,
        gs_117783: bool,
        gs_118841: bool,
        gs_117951: bool,
        gs_118348: bool,
        gs_119141: bool,
        gs_118064: bool,
        gs_117605: bool,
        gs_118989: bool,
        gs_118171: bool,
        gs_117940: bool,
        gs_117928: bool,
        gs_118528: bool,
        gs_118535: bool,
        gs_119041: bool,
        gs_117661: bool,
        gs_118966: bool,
        gs_118063: bool,
        gs_118566: bool,
        gs_118180: bool,
        gs_119057: bool,
        gs_118226: bool,
        gs_117616: bool,
        gs_118401: bool,
        gs_118139: bool,
        gs_118122: bool,
        gs_118315: bool,
        gs_117703: bool,
        gs_118012: bool,
        gs_117838: bool,
        gs_118945: bool,
        gs_117669: bool,
        gs_118279: bool,
        gs_117874: bool,
        gs_118419: bool,
        gs_118844: bool,
        gs_118135: bool,
        gs_118428: bool,
        gs_118153: bool,
        gs_118838: bool,
        gs_118444: bool,
        gs_118665: bool,
        gs_119137: bool,
        gs_118534: bool,
        gs_119093: bool,
        gs_118678: bool,
        gs_117673: bool,
        gs_117898: bool,
        gs_119000: bool,
        gs_118835: bool,
        gs_117654: bool,
        gs_118475: bool,
        gs_118659: bool,
        gs_118836: bool,
        gs_118450: bool,
        gs_118403: bool,
        gs_118067: bool,
        gs_117571: bool,
        gs_118568: bool,
        gs_118900: bool,
        gs_118625: bool,
        gs_118601: bool,
        gs_118228: bool,
        gs_117554: bool,
        gs_118977: bool,
        gs_118270: bool,
        gs_118053: bool,
        gs_118533: bool,
        gs_118758: bool,
        gs_118536: bool,
        gs_118195: bool,
        gs_118818: bool,
        gs_118100: bool,
        gs_118404: bool,
        gs_118055: bool,
        gs_118339: bool,
        gs_118850: bool,
        gs_117817: bool,
        gs_118970: bool,
        gs_118778: bool,
        gs_117728: bool,
        gs_118205: bool,
        gs_117631: bool,
        gs_118730: bool,
        gs_118748: bool,
        gs_118457: bool,
        gs_118119: bool,
        gs_118832: bool,
        gs_119166: bool,
        gs_118029: bool,
        gs_118499: bool,
        gs_117770: bool,
        gs_118024: bool,
        gs_117860: bool,
        gs_119079: bool,
        gs_118127: bool,
        gs_118972: bool,
        gs_118216: bool,
        gs_117800: bool,
        gs_118175: bool,
        gs_118207: bool,
        gs_117560: bool,
        gs_118941: bool,
        gs_118967: bool,
        gs_118616: bool,
        gs_117646: bool,
        gs_117816: bool,
        gs_119064: bool,
        gs_119053: bool,
        gs_117623: bool,
        gs_117613: bool,
        gs_117894: bool,
        gs_118490: bool,
        gs_118338: bool,
        gs_117873: bool,
        gs_118600: bool,
        gs_117642: bool,
        gs_118080: bool,
        gs_118579: bool,
        gs_117993: bool,
        gs_118152: bool,
        gs_118480: bool,
        gs_117552: bool,
        gs_117707: bool,
        gs_118049: bool,
        gs_119127: bool,
        gs_118519: bool,
        gs_118684: bool,
        gs_118631: bool,
        gs_119132: bool,
        gs_118894: bool,
        gs_118150: bool,
        gs_118624: bool,
        gs_117819: bool,
        gs_118521: bool,
        gs_118896: bool,
        gs_118392: bool,
        gs_118738: bool,
        gs_118805: bool,
        gs_118655: bool,
        gs_117857: bool,
        gs_118961: bool,
        gs_117916: bool,
        gs_118522: bool,
        gs_118507: bool,
        gs_118537: bool,
        gs_118938: bool,
        gs_118544: bool,
        gs_118256: bool,
        gs_118199: bool,
        gs_117933: bool,
        gs_118141: bool,
        gs_118724: bool,
        gs_118891: bool,
        gs_118922: bool,
        gs_117912: bool,
        gs_118915: bool,
        gs_119094: bool,
        gs_118651: bool,
        gs_118741: bool,
        gs_117742: bool,
        gs_118197: bool,
        gs_118292: bool,
        gs_117625: bool,
        gs_117791: bool,
        gs_118323: bool,
        gs_118630: bool,
        gs_117555: bool,
        gs_117782: bool,
        gs_117718: bool,
        gs_117601: bool,
        gs_119106: bool,
        gs_117856: bool,
        gs_117766: bool,
        gs_117666: bool,
        gs_118278: bool,
        gs_117585: bool,
        gs_118729: bool,
        gs_118143: bool,
        gs_118440: bool,
        gs_118474: bool,
        gs_118794: bool,
        gs_117606: bool,
        gs_118355: bool,
        gs_118671: bool,
        gs_117946: bool,
        gs_118398: bool,
        gs_118545: bool,
        gs_118212: bool,
        gs_118902: bool,
        gs_118564: bool,
        gs_117784: bool,
        gs_118015: bool,
        gs_117918: bool,
        gs_117941: bool,
        gs_117999: bool,
        gs_118641: bool,
        gs_117583: bool,
        gs_118258: bool,
        gs_118305: bool,
        gs_117905: bool,
        gs_117725: bool,
        gs_118711: bool,
        gs_118400: bool,
        gs_118785: bool,
        gs_117824: bool,
        gs_118460: bool,
        gs_117833: bool,
        gs_117618: bool,
        gs_118085: bool,
        gs_117590: bool,
        gs_118637: bool,
        gs_118962: bool,
        gs_119065: bool,
        gs_117755: bool,
        gs_119147: bool,
        gs_118906: bool,
        gs_119047: bool,
        gs_117922: bool,
        gs_118664: bool,
        gs_118192: bool,
        gs_118634: bool,
        gs_117810: bool,
        gs_119090: bool,
        gs_118325: bool,
        gs_118234: bool,
        gs_118013: bool,
        gs_117826: bool,
        gs_118653: bool,
        gs_119109: bool,
        gs_118236: bool,
        gs_118944: bool,
        gs_118310: bool,
        gs_118351: bool,
        gs_118309: bool,
        gs_118410: bool,
        gs_117976: bool,
        gs_118210: bool,
        gs_119134: bool,
        gs_117593: bool,
        gs_119048: bool,
        gs_118734: bool,
        gs_118917: bool,
        gs_118133: bool,
        gs_118434: bool,
        gs_118190: bool,
        gs_117562: bool,
        gs_119097: bool,
        gs_118458: bool,
        gs_118283: bool,
        gs_118610: bool,
        gs_118177: bool,
        gs_118181: bool,
        gs_118569: bool,
        gs_117684: bool,
        gs_118515: bool,
        gs_117599: bool,
        gs_117576: bool,
        gs_117809: bool,
        gs_118422: bool,
        gs_117558: bool,
        gs_119021: bool,
        gs_118145: bool,
        gs_119008: bool,
        gs_119029: bool,
        gs_118700: bool,
        gs_118443: bool,
        gs_117983: bool,
        gs_118130: bool,
        gs_117643: bool,
        gs_118165: bool,
        gs_117811: bool,
        gs_117676: bool,
        gs_118524: bool,
        gs_118663: bool,
        gs_117629: bool,
        gs_118129: bool,
        gs_117958: bool,
        gs_118370: bool,
        gs_118933: bool,
        gs_117617: bool,
        gs_117883: bool,
        gs_118354: bool,
        gs_118602: bool,
        gs_118995: bool,
        gs_118502: bool,
        gs_118227: bool,
        gs_118526: bool,
        gs_117553: bool,
        gs_118471: bool,
        gs_119107: bool,
        gs_118636: bool,
        gs_119143: bool,
        gs_119069: bool,
        gs_117885: bool,
        gs_118473: bool,
        gs_118656: bool,
        gs_119026: bool,
        gs_119120: bool,
        gs_117934: bool,
        gs_119066: bool,
        gs_118563: bool,
        gs_119099: bool,
        gs_118483: bool,
        gs_118611: bool,
        gs_118420: bool,
        gs_118101: bool,
        gs_118552: bool,
        gs_118341: bool,
        gs_118584: bool,
        gs_118627: bool,
        gs_118801: bool,
        gs_117881: bool,
        gs_117785: bool,
        gs_117847: bool,
        gs_119123: bool,
        gs_118958: bool,
        gs_118094: bool,
        gs_118090: bool,
        gs_118252: bool,
        gs_118303: bool,
        gs_118385: bool,
        gs_117813: bool,
        gs_118224: bool,
        gs_118117: bool,
        gs_118693: bool,
        gs_119059: bool,
        gs_118144: bool,
        gs_119055: bool,
        gs_118327: bool,
        gs_118562: bool,
        gs_118658: bool,
        gs_118302: bool,
        gs_118764: bool,
        gs_118981: bool,
        gs_117964: bool,
        gs_117843: bool,
        gs_118542: bool,
        gs_118314: bool,
        gs_118870: bool,
        gs_118431: bool,
        gs_118164: bool,
        gs_117902: bool,
        gs_117772: bool,
        gs_118069: bool,
        gs_118148: bool,
        gs_118923: bool,
        gs_119100: bool,
        gs_117827: bool,
        gs_118613: bool,
        gs_118704: bool,
        gs_117751: bool,
        gs_118352: bool,
        gs_118773: bool,
        gs_117975: bool,
        gs_117763: bool,
        gs_118722: bool,
        gs_118183: bool,
        gs_118414: bool,
        gs_118996: bool,
        gs_118662: bool,
        gs_117724: bool,
        gs_118086: bool,
        gs_118318: bool,
        gs_118418: bool,
        gs_118105: bool,
        gs_118505: bool,
        gs_118463: bool,
        gs_118919: bool,
        gs_117692: bool,
        gs_117548: bool,
        gs_118769: bool,
        gs_119043: bool,
        gs_119052: bool,
        gs_119046: bool,
        gs_117734: bool,
        gs_117574: bool,
        gs_118251: bool,
        gs_119004: bool,
        gs_117945: bool,
        gs_118285: bool,
        gs_117594: bool,
        gs_117890: bool,
        gs_117915: bool,
        gs_118513: bool,
        gs_118781: bool,
        gs_117726: bool,
        gs_119125: bool,
        gs_117882: bool,
        gs_118482: bool,
        gs_118760: bool,
        gs_118249: bool,
        gs_118369: bool,
        gs_119085: bool,
        gs_117878: bool,
        gs_118493: bool,
        gs_118875: bool,
        gs_118968: bool,
        gs_118238: bool,
        gs_118907: bool,
        gs_117962: bool,
        gs_118330: bool,
        gs_117714: bool,
        gs_118686: bool,
        gs_118282: bool,
        gs_117741: bool,
        gs_117621: bool,
        gs_117865: bool,
        gs_118358: bool,
        gs_117586: bool,
        gs_118940: bool,
        gs_118277: bool,
        gs_118359: bool,
        gs_117630: bool,
        gs_118547: bool,
        gs_117798: bool,
        gs_118791: bool,
        gs_118445: bool,
        gs_118026: bool,
        gs_118070: bool,
        gs_118096: bool,
        gs_119058: bool,
        gs_117549: bool,
        gs_117745: bool,
        gs_117723: bool,
        gs_119154: bool,
        gs_118170: bool,
        gs_118901: bool,
        gs_118959: bool,
        gs_117671: bool,
        gs_118481: bool,
        gs_118465: bool,
        gs_119027: bool,
        gs_118417: bool,
        gs_119163: bool,
        gs_118167: bool,
        gs_118879: bool,
        gs_118235: bool,
        gs_117858: bool,
        gs_117805: bool,
        gs_117956: bool,
        gs_118957: bool,
        gs_118160: bool,
        gs_117578: bool,
        gs_117612: bool,
        gs_118033: bool,
        gs_119091: bool,
        gs_117675: bool,
        gs_117773: bool,
        gs_118827: bool,
        gs_118157: bool,
        gs_117566: bool,
        gs_119119: bool,
        gs_117949: bool,
        gs_118514: bool,
        gs_119124: bool,
        gs_118592: bool,
        gs_118823: bool,
        gs_118343: bool,
        gs_118971: bool,
        gs_118682: bool,
        gs_117733: bool,
        gs_118376: bool,
        gs_117732: bool,
        gs_118825: bool,
        gs_117850: bool,
        gs_118179: bool,
        gs_117746: bool,
        gs_117740: bool,
        gs_118548: bool,
        gs_118006: bool,
        gs_118770: bool,
        gs_118202: bool,
        gs_117789: bool,
        gs_118025: bool,
        gs_118023: bool,
        gs_117747: bool,
        gs_118451: bool,
        gs_117982: bool,
        gs_118215: bool,
        gs_118395: bool,
        gs_118242: bool,
        gs_118472: bool,
        gs_117588: bool,
        gs_118452: bool,
        gs_118779: bool,
        gs_119002: bool,
        gs_117582: bool,
        gs_118487: bool,
        gs_117974: bool,
        gs_119142: bool,
        gs_117804: bool,
        gs_118645: bool,
        gs_117942: bool,
        gs_118927: bool,
        gs_118518: bool,
        gs_119011: bool,
        gs_118983: bool,
        gs_118672: bool,
        gs_119130: bool,
        gs_117895: bool,
        gs_117668: bool,
        gs_118987: bool,
        gs_118021: bool,
        gs_118726: bool,
        gs_118674: bool,
        gs_118213: bool,
        gs_117967: bool,
        gs_118267: bool,
        gs_118254: bool,
        gs_118300: bool,
        gs_118986: bool,
        gs_118615: bool,
        gs_117648: bool,
        gs_118570: bool,
        gs_118573: bool,
        gs_118439: bool,
        gs_118960: bool,
        gs_118320: bool,
        gs_118448: bool,
        gs_117706: bool,
        gs_119080: bool,
        gs_117837: bool,
        gs_118000: bool,
        gs_118326: bool,
        gs_118390: bool,
        gs_118520: bool,
        gs_118494: bool,
        gs_118822: bool,
        gs_117722: bool,
        gs_118869: bool,
        gs_117972: bool,
        gs_117841: bool,
        gs_118739: bool,
        gs_117966: bool,
        gs_118068: bool,
        gs_117581: bool,
        gs_118622: bool,
        gs_118470: bool,
        gs_117948: bool,
        gs_117656: bool,
        gs_117681: bool,
        gs_118424: bool,
        gs_118652: bool,
        gs_118932: bool,
        gs_118654: bool,
        gs_117713: bool,
        gs_118733: bool,
        gs_117689: bool,
        gs_118123: bool,
        gs_118059: bool,
        gs_117598: bool,
        gs_117970: bool,
        gs_119164: bool,
        gs_118586: bool,
        gs_117704: bool,
        gs_117711: bool,
        gs_118628: bool,
        gs_118831: bool,
        gs_118373: bool,
        gs_117908: bool,
        gs_117807: bool,
        gs_118124: bool,
        gs_117884: bool,
        gs_118217: bool,
        gs_119150: bool,
        gs_118011: bool,
        gs_117943: bool,
        gs_118316: bool,
        gs_117855: bool,
        gs_117664: bool,
        gs_118125: bool,
        gs_117927: bool,
        gs_117608: bool,
        gs_118580: bool,
        gs_118990: bool,
        gs_117764: bool,
        gs_118005: bool,
        gs_118191: bool,
        gs_117730: bool,
        gs_118746: bool,
        gs_118543: bool,
        gs_119140: bool,
        gs_118220: bool,
        gs_117977: bool,
        gs_119101: bool,
        gs_117729: bool,
        gs_117695: bool,
        gs_117749: bool,
        gs_117624: bool,
        gs_118138: bool,
        gs_118795: bool,
        gs_118991: bool,
        gs_118072: bool,
        gs_118429: bool,
        gs_118413: bool,
        gs_117814: bool,
        gs_117845: bool,
        gs_118905: bool,
        gs_119138: bool,
        gs_118082: bool,
        gs_117559: bool,
        gs_118883: bool,
        gs_118329: bool,
        gs_119082: bool,
        gs_118346: bool,
        gs_117572: bool,
        gs_118222: bool,
        gs_118690: bool,
        gs_117849: bool,
        gs_118503: bool,
        gs_118881: bool,
        gs_117716: bool,
        gs_118752: bool,
        gs_118275: bool,
        gs_118617: bool,
        gs_117998: bool,
        gs_118694: bool,
        gs_118853: bool,
        gs_118935: bool,
        gs_118681: bool,
        gs_118061: bool,
        gs_118342: bool,
        gs_118604: bool,
        gs_118048: bool,
        gs_118819: bool,
        gs_117781: bool,
        gs_119072: bool,
        gs_118469: bool,
        gs_118934: bool,
        gs_117604: bool,
        gs_118421: bool,
        gs_118775: bool,
        gs_118356: bool,
        gs_118510: bool,
        gs_118336: bool,
        gs_118556: bool,
        gs_117854: bool,
        gs_118843: bool,
        gs_118455: bool,
        gs_118904: bool,
        gs_118705: bool,
        gs_117694: bool,
        gs_118670: bool,
        gs_117867: bool,
        gs_118581: bool,
        gs_118118: bool,
        gs_117944: bool,
        gs_117754: bool,
        gs_117931: bool,
        gs_117979: bool,
        gs_119165: bool,
        gs_118427: bool,
        gs_118201: bool,
        gs_118550: bool,
        gs_118999: bool,
        gs_118134: bool,
        gs_118162: bool,
        gs_118942: bool,
        gs_117842: bool,
        gs_117913: bool,
        gs_117973: bool,
        gs_118629: bool,
        gs_118650: bool,
        gs_117756: bool,
        gs_119144: bool,
        gs_117609: bool,
        gs_118261: bool,
        gs_118954: bool,
        gs_117748: bool,
        gs_117640: bool,
        gs_118353: bool,
        gs_118262: bool,
        gs_118032: bool,
        gs_117614: bool,
        gs_117665: bool,
        gs_118156: bool,
        gs_117645: bool,
        gs_118218: bool,
        gs_117638: bool,
        gs_117735: bool,
        gs_118857: bool,
        gs_117708: bool,
        gs_118955: bool,
        gs_118281: bool,
        gs_118707: bool,
        gs_118677: bool,
        gs_117739: bool,
        gs_119148: bool,
        gs_118163: bool,
        gs_118350: bool,
        gs_118017: bool,
        gs_118425: bool,
        gs_118158: bool,
        gs_119145: bool,
        gs_118312: bool,
        gs_119089: bool,
        gs_117567: bool,
        gs_118459: bool,
        gs_117997: bool,
        gs_117981: bool,
        gs_117853: bool,
        gs_118146: bool,
        gs_118811: bool,
        gs_118765: bool,
        gs_118361: bool,
        gs_117897: bool,
        gs_119062: bool,
        gs_118725: bool,
        gs_119121: bool,
        gs_117869: bool,
        gs_118618: bool,
        gs_118763: bool,
        gs_118714: bool,
        gs_118598: bool,
        gs_118306: bool,
        gs_118056: bool,
        gs_119118: bool,
        gs_118088: bool,
        gs_118206: bool,
        gs_117954: bool,
        gs_118308: bool,
        gs_118391: bool,
        gs_118188: bool,
        gs_118367: bool,
        gs_118916: bool,
        gs_118833: bool,
        gs_118874: bool,
        gs_118964: bool,
        gs_117835: bool,
        gs_118930: bool,
        gs_118039: bool,
        gs_117818: bool,
        gs_118073: bool,
        gs_117899: bool,
        gs_118539: bool,
        gs_118685: bool,
        gs_117688: bool,
        gs_118394: bool,
        gs_118777: bool,
        gs_118797: bool,
        gs_117877: bool,
        gs_118057: bool,
        gs_118888: bool,
        gs_118554: bool,
        gs_118244: bool,
        gs_118697: bool,
        gs_118223: bool,
        gs_118921: bool,
        gs_118104: bool,
        gs_118231: bool,
        gs_118233: bool,
        gs_118506: bool,
        gs_119136: bool,
        gs_118565: bool,
        gs_118003: bool,
        gs_117644: bool,
        gs_118814: bool,
        gs_117989: bool,
        gs_118081: bool,
        gs_119129: bool,
        gs_118859: bool,
        gs_119102: bool,
        gs_117626: bool,
        gs_118393: bool,
        gs_118820: bool,
        gs_118666: bool,
        gs_117924: bool,
        gs_118248: bool,
        gs_118793: bool,
        gs_118897: bool,
        gs_118331: bool,
        gs_117862: bool,
        gs_118172: bool,
        gs_118614: bool,
        gs_117891: bool,
        gs_118317: bool,
        gs_119030: bool,
        gs_118110: bool,
        gs_118743: bool,
        gs_117887: bool,
        gs_117955: bool,
        gs_118751: bool,
        gs_118767: bool,
        gs_117615: bool,
        gs_118111: bool,
        gs_117965: bool,
        gs_117577: bool,
        gs_118313: bool,
        gs_118583: bool,
        gs_118642: bool,
        gs_117757: bool,
        gs_118984: bool,
        gs_118949: bool,
        gs_118768: bool,
        gs_118851: bool,
        gs_118925: bool,
        gs_118974: bool,
        gs_117632: bool,
        gs_118696: bool,
        gs_118788: bool,
        gs_119068: bool,
        gs_117864: bool,
        gs_117930: bool,
        gs_118454: bool,
        gs_119157: bool,
        gs_118898: bool,
        gs_118372: bool,
        gs_117639: bool,
        gs_117551: bool,
        gs_117596: bool,
        gs_118606: bool,
        gs_118079: bool,
        gs_118804: bool,
        gs_119015: bool,
        gs_118792: bool,
        gs_118929: bool,
        gs_119078: bool,
        gs_117685: bool,
        gs_117938: bool,
        gs_117919: bool,
        gs_117731: bool,
        gs_117996: bool,
        gs_119016: bool,
        gs_118885: bool,
        gs_118286: bool,
        gs_117823: bool,
        gs_118837: bool,
        gs_118208: bool,
        gs_118953: bool,
        gs_119012: bool,
        gs_118319: bool,
        gs_117698: bool,
        gs_118828: bool,
        gs_118952: bool,
        gs_118106: bool,
        gs_118240: bool,
        gs_117969: bool,
        gs_118115: bool,
        gs_117836: bool,
        gs_118379: bool,
        gs_118742: bool,
        gs_117565: bool,
        gs_119056: bool,
        gs_117712: bool,
        gs_118014: bool,
        gs_117829: bool,
        gs_118488: bool,
        gs_118442: bool,
        gs_118717: bool,
        gs_117901: bool,
        gs_117761: bool,
        gs_118036: bool,
        gs_119133: bool,
        gs_118151: bool,
        gs_118749: bool,
        gs_118140: bool,
        gs_118856: bool,
        gs_117995: bool,
        gs_119013: bool,
        gs_119104: bool,
        gs_117760: bool,
        gs_117893: bool,
        gs_118478: bool,
        gs_118789: bool,
        gs_117658: bool,
        gs_118918: bool,
        gs_118225: bool,
        gs_118186: bool,
        gs_117828: bool,
        gs_117950: bool,
        gs_118446: bool,
        gs_118951: bool,
        gs_118732: bool,
        gs_117736: bool,
        gs_118050: bool,
        gs_117699: bool,
        gs_118727: bool,
        gs_118621: bool,
        gs_117653: bool,
        gs_117803: bool,
        gs_117947: bool,
        gs_118525: bool,
        gs_118485: bool,
        gs_119153: bool,
        gs_118826: bool,
        gs_117777: bool,
        gs_118813: bool,
        gs_119045: bool,
        gs_117971: bool,
        gs_118886: bool,
        gs_119054: bool,
        gs_119039: bool,
        gs_118091: bool,
        gs_118204: bool,
        gs_117637: bool,
        gs_118561: bool,
        gs_118028: bool,
        gs_118846: bool,
        gs_118939: bool,
        gs_117569: bool,
        gs_118816: bool,
        gs_118848: bool,
        gs_118241: bool,
        gs_117929: bool,
        gs_118772: bool,
        gs_119024: bool,
        gs_118366: bool,
        gs_118098: bool,
        gs_118745: bool,
        gs_117611: bool,
        gs_118709: bool,
        gs_117868: bool,
        gs_117961: bool,
        gs_118608: bool,
        gs_118865: bool,
        gs_118578: bool,
        gs_117886: bool,
        gs_117796: bool,
        gs_119022: bool,
        gs_118142: bool,
        gs_118168: bool,
        gs_117651: bool,
        gs_118174: bool,
        gs_118740: bool,
        gs_118546: bool,
        gs_117667: bool,
        gs_118337: bool,
        gs_119033: bool,
        gs_119131: bool,
        gs_118527: bool,
        gs_118914: bool,
        gs_119088: bool,
        gs_118467: bool,
        gs_117602: bool,
        gs_118755: bool,
        gs_118852: bool,
        gs_118184: bool,
        gs_118979: bool,
        gs_118149: bool,
        gs_118362: bool,
        gs_118263: bool,
        gs_118432: bool,
        gs_118948: bool,
        gs_118950: bool,
        gs_118089: bool,
        gs_118928: bool,
        gs_118997: bool,
        gs_117690: bool,
        gs_118854: bool,
        gs_118193: bool,
        gs_119103: bool,
        gs_118766: bool,
        gs_118718: bool,
        gs_117780: bool,
        gs_117821: bool,
        gs_117647: bool,
        gs_118858: bool,
        gs_118976: bool,
        gs_119108: bool,
        gs_118492: bool,
        gs_118657: bool,
        gs_117794: bool,
        gs_118553: bool,
        gs_117815: bool,
        gs_117620: bool,
        gs_117923: bool,
        gs_118126: bool,
        gs_119018: bool,
        gs_119096: bool,
        gs_117917: bool,
        gs_117744: bool,
        gs_118131: bool,
        gs_118931: bool,
        gs_119007: bool,
        gs_118477: bool,
        gs_117978: bool,
        gs_119092: bool,
        gs_117677: bool,
        gs_118582: bool,
        gs_118084: bool,
        gs_119162: bool,
        gs_118812: bool,
        gs_118590: bool,
        gs_119032: bool,
        gs_119086: bool,
        gs_118880: bool,
        gs_118437: bool,
        gs_118887: bool,
        gs_118280: bool,
        gs_118736: bool,
        gs_118018: bool,
        gs_118099: bool,
        gs_118712: bool,
        gs_118532: bool,
        gs_118538: bool,
        gs_118609: bool,
        gs_117767: bool,
        gs_117634: bool,
        gs_118260: bool,
        gs_118328: bool,
        gs_118517: bool,
        gs_118449: bool,
        gs_119050: bool,
        gs_118708: bool,
        gs_118872: bool,
        gs_117991: bool,
        gs_118301: bool,
        gs_118436: bool,
        gs_118020: bool,
        gs_118750: bool,
        gs_118703: bool,
        gs_117861: bool,
        gs_119159: bool,
        gs_118849: bool,
        gs_118113: bool,
        gs_117778: bool,
        el: u8,
        coproc: u8,
        opc1: u8,
        CRn: u8,
        opc2: u8,
        CRm: u8,
        t: i128,
    }
    let fn_state = FunctionState {
        el,
        coproc,
        opc1,
        CRn,
        opc2,
        CRm,
        t,
        ..Default::default()
    };
    return block_0(state, tracer, fn_state);
    fn block_0<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_0_0: read-var CRm:u8
        let s_0_0: u8 = fn_state.CRm;
        // D s_0_1: cast zx s_0_0 -> bv
        let s_0_1: Bits = Bits::new(s_0_0 as u128, 4u16);
        // C s_0_2: const #0u : u8
        let s_0_2: u8 = 0;
        // C s_0_3: cast zx s_0_2 -> bv
        let s_0_3: Bits = Bits::new(s_0_2 as u128, 4u16);
        // D s_0_4: cmp-eq s_0_1 s_0_3
        let s_0_4: bool = ((s_0_1) == (s_0_3));
        // N s_0_5: branch s_0_4 b5670 b1
        if s_0_4 {
            return block_5670(state, tracer, fn_state);
        } else {
            return block_1(state, tracer, fn_state);
        };
    }
    fn block_1<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1_0: const #0u : u8
        let s_1_0: bool = false;
        // D s_1_1: write-var gs#117548 <= s_1_0
        fn_state.gs_117548 = s_1_0;
        // N s_1_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_2<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2_0: read-var gs#117548:u8
        let s_2_0: bool = fn_state.gs_117548;
        // N s_2_1: branch s_2_0 b5669 b3
        if s_2_0 {
            return block_5669(state, tracer, fn_state);
        } else {
            return block_3(state, tracer, fn_state);
        };
    }
    fn block_3<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3_0: const #0u : u8
        let s_3_0: bool = false;
        // D s_3_1: write-var gs#117549 <= s_3_0
        fn_state.gs_117549 = s_3_0;
        // N s_3_2: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_4<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4_0: read-var gs#117549:u8
        let s_4_0: bool = fn_state.gs_117549;
        // N s_4_1: branch s_4_0 b5668 b5
        if s_4_0 {
            return block_5668(state, tracer, fn_state);
        } else {
            return block_5(state, tracer, fn_state);
        };
    }
    fn block_5<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_5_0: const #0u : u8
        let s_5_0: bool = false;
        // D s_5_1: write-var gs#117550 <= s_5_0
        fn_state.gs_117550 = s_5_0;
        // N s_5_2: jump b6
        return block_6(state, tracer, fn_state);
    }
    fn block_6<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_6_0: read-var gs#117550:u8
        let s_6_0: bool = fn_state.gs_117550;
        // N s_6_1: branch s_6_0 b5667 b7
        if s_6_0 {
            return block_5667(state, tracer, fn_state);
        } else {
            return block_7(state, tracer, fn_state);
        };
    }
    fn block_7<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_7_0: const #0u : u8
        let s_7_0: bool = false;
        // D s_7_1: write-var gs#117551 <= s_7_0
        fn_state.gs_117551 = s_7_0;
        // N s_7_2: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_8<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_8_0: read-var gs#117551:u8
        let s_8_0: bool = fn_state.gs_117551;
        // N s_8_1: branch s_8_0 b5666 b9
        if s_8_0 {
            return block_5666(state, tracer, fn_state);
        } else {
            return block_9(state, tracer, fn_state);
        };
    }
    fn block_9<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_9_0: read-var CRm:u8
        let s_9_0: u8 = fn_state.CRm;
        // D s_9_1: cast zx s_9_0 -> bv
        let s_9_1: Bits = Bits::new(s_9_0 as u128, 4u16);
        // C s_9_2: const #4u : u8
        let s_9_2: u8 = 4;
        // C s_9_3: cast zx s_9_2 -> bv
        let s_9_3: Bits = Bits::new(s_9_2 as u128, 4u16);
        // D s_9_4: cmp-eq s_9_1 s_9_3
        let s_9_4: bool = ((s_9_1) == (s_9_3));
        // N s_9_5: branch s_9_4 b5665 b10
        if s_9_4 {
            return block_5665(state, tracer, fn_state);
        } else {
            return block_10(state, tracer, fn_state);
        };
    }
    fn block_10<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_10_0: const #0u : u8
        let s_10_0: bool = false;
        // D s_10_1: write-var gs#117552 <= s_10_0
        fn_state.gs_117552 = s_10_0;
        // N s_10_2: jump b11
        return block_11(state, tracer, fn_state);
    }
    fn block_11<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_11_0: read-var gs#117552:u8
        let s_11_0: bool = fn_state.gs_117552;
        // N s_11_1: branch s_11_0 b5664 b12
        if s_11_0 {
            return block_5664(state, tracer, fn_state);
        } else {
            return block_12(state, tracer, fn_state);
        };
    }
    fn block_12<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_12_0: const #0u : u8
        let s_12_0: bool = false;
        // D s_12_1: write-var gs#117553 <= s_12_0
        fn_state.gs_117553 = s_12_0;
        // N s_12_2: jump b13
        return block_13(state, tracer, fn_state);
    }
    fn block_13<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_13_0: read-var gs#117553:u8
        let s_13_0: bool = fn_state.gs_117553;
        // N s_13_1: branch s_13_0 b5663 b14
        if s_13_0 {
            return block_5663(state, tracer, fn_state);
        } else {
            return block_14(state, tracer, fn_state);
        };
    }
    fn block_14<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_14_0: const #0u : u8
        let s_14_0: bool = false;
        // D s_14_1: write-var gs#117554 <= s_14_0
        fn_state.gs_117554 = s_14_0;
        // N s_14_2: jump b15
        return block_15(state, tracer, fn_state);
    }
    fn block_15<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_15_0: read-var gs#117554:u8
        let s_15_0: bool = fn_state.gs_117554;
        // N s_15_1: branch s_15_0 b5662 b16
        if s_15_0 {
            return block_5662(state, tracer, fn_state);
        } else {
            return block_16(state, tracer, fn_state);
        };
    }
    fn block_16<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_16_0: const #0u : u8
        let s_16_0: bool = false;
        // D s_16_1: write-var gs#117555 <= s_16_0
        fn_state.gs_117555 = s_16_0;
        // N s_16_2: jump b17
        return block_17(state, tracer, fn_state);
    }
    fn block_17<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_17_0: read-var gs#117555:u8
        let s_17_0: bool = fn_state.gs_117555;
        // N s_17_1: branch s_17_0 b5661 b18
        if s_17_0 {
            return block_5661(state, tracer, fn_state);
        } else {
            return block_18(state, tracer, fn_state);
        };
    }
    fn block_18<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_18_0: read-var CRm:u8
        let s_18_0: u8 = fn_state.CRm;
        // D s_18_1: cast zx s_18_0 -> bv
        let s_18_1: Bits = Bits::new(s_18_0 as u128, 4u16);
        // C s_18_2: const #13u : u8
        let s_18_2: u8 = 13;
        // C s_18_3: cast zx s_18_2 -> bv
        let s_18_3: Bits = Bits::new(s_18_2 as u128, 4u16);
        // D s_18_4: cmp-eq s_18_1 s_18_3
        let s_18_4: bool = ((s_18_1) == (s_18_3));
        // N s_18_5: branch s_18_4 b5660 b19
        if s_18_4 {
            return block_5660(state, tracer, fn_state);
        } else {
            return block_19(state, tracer, fn_state);
        };
    }
    fn block_19<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_19_0: const #0u : u8
        let s_19_0: bool = false;
        // D s_19_1: write-var gs#117556 <= s_19_0
        fn_state.gs_117556 = s_19_0;
        // N s_19_2: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_20<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_20_0: read-var gs#117556:u8
        let s_20_0: bool = fn_state.gs_117556;
        // N s_20_1: branch s_20_0 b5659 b21
        if s_20_0 {
            return block_5659(state, tracer, fn_state);
        } else {
            return block_21(state, tracer, fn_state);
        };
    }
    fn block_21<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_21_0: const #0u : u8
        let s_21_0: bool = false;
        // D s_21_1: write-var gs#117557 <= s_21_0
        fn_state.gs_117557 = s_21_0;
        // N s_21_2: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_22<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_22_0: read-var gs#117557:u8
        let s_22_0: bool = fn_state.gs_117557;
        // N s_22_1: branch s_22_0 b5658 b23
        if s_22_0 {
            return block_5658(state, tracer, fn_state);
        } else {
            return block_23(state, tracer, fn_state);
        };
    }
    fn block_23<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_23_0: const #0u : u8
        let s_23_0: bool = false;
        // D s_23_1: write-var gs#117558 <= s_23_0
        fn_state.gs_117558 = s_23_0;
        // N s_23_2: jump b24
        return block_24(state, tracer, fn_state);
    }
    fn block_24<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_24_0: read-var gs#117558:u8
        let s_24_0: bool = fn_state.gs_117558;
        // N s_24_1: branch s_24_0 b5657 b25
        if s_24_0 {
            return block_5657(state, tracer, fn_state);
        } else {
            return block_25(state, tracer, fn_state);
        };
    }
    fn block_25<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_25_0: const #0u : u8
        let s_25_0: bool = false;
        // D s_25_1: write-var gs#117559 <= s_25_0
        fn_state.gs_117559 = s_25_0;
        // N s_25_2: jump b26
        return block_26(state, tracer, fn_state);
    }
    fn block_26<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_26_0: read-var gs#117559:u8
        let s_26_0: bool = fn_state.gs_117559;
        // N s_26_1: branch s_26_0 b5656 b27
        if s_26_0 {
            return block_5656(state, tracer, fn_state);
        } else {
            return block_27(state, tracer, fn_state);
        };
    }
    fn block_27<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_27_0: read-var CRm:u8
        let s_27_0: u8 = fn_state.CRm;
        // D s_27_1: cast zx s_27_0 -> bv
        let s_27_1: Bits = Bits::new(s_27_0 as u128, 4u16);
        // C s_27_2: const #0u : u8
        let s_27_2: u8 = 0;
        // C s_27_3: cast zx s_27_2 -> bv
        let s_27_3: Bits = Bits::new(s_27_2 as u128, 4u16);
        // D s_27_4: cmp-eq s_27_1 s_27_3
        let s_27_4: bool = ((s_27_1) == (s_27_3));
        // N s_27_5: branch s_27_4 b5655 b28
        if s_27_4 {
            return block_5655(state, tracer, fn_state);
        } else {
            return block_28(state, tracer, fn_state);
        };
    }
    fn block_28<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_28_0: const #0u : u8
        let s_28_0: bool = false;
        // D s_28_1: write-var gs#117560 <= s_28_0
        fn_state.gs_117560 = s_28_0;
        // N s_28_2: jump b29
        return block_29(state, tracer, fn_state);
    }
    fn block_29<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_29_0: read-var gs#117560:u8
        let s_29_0: bool = fn_state.gs_117560;
        // N s_29_1: branch s_29_0 b5654 b30
        if s_29_0 {
            return block_5654(state, tracer, fn_state);
        } else {
            return block_30(state, tracer, fn_state);
        };
    }
    fn block_30<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_30_0: const #0u : u8
        let s_30_0: bool = false;
        // D s_30_1: write-var gs#117561 <= s_30_0
        fn_state.gs_117561 = s_30_0;
        // N s_30_2: jump b31
        return block_31(state, tracer, fn_state);
    }
    fn block_31<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_31_0: read-var gs#117561:u8
        let s_31_0: bool = fn_state.gs_117561;
        // N s_31_1: branch s_31_0 b5653 b32
        if s_31_0 {
            return block_5653(state, tracer, fn_state);
        } else {
            return block_32(state, tracer, fn_state);
        };
    }
    fn block_32<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_32_0: const #0u : u8
        let s_32_0: bool = false;
        // D s_32_1: write-var gs#117562 <= s_32_0
        fn_state.gs_117562 = s_32_0;
        // N s_32_2: jump b33
        return block_33(state, tracer, fn_state);
    }
    fn block_33<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_33_0: read-var gs#117562:u8
        let s_33_0: bool = fn_state.gs_117562;
        // N s_33_1: branch s_33_0 b5652 b34
        if s_33_0 {
            return block_5652(state, tracer, fn_state);
        } else {
            return block_34(state, tracer, fn_state);
        };
    }
    fn block_34<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_34_0: const #0u : u8
        let s_34_0: bool = false;
        // D s_34_1: write-var gs#117563 <= s_34_0
        fn_state.gs_117563 = s_34_0;
        // N s_34_2: jump b35
        return block_35(state, tracer, fn_state);
    }
    fn block_35<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_35_0: read-var gs#117563:u8
        let s_35_0: bool = fn_state.gs_117563;
        // N s_35_1: branch s_35_0 b5651 b36
        if s_35_0 {
            return block_5651(state, tracer, fn_state);
        } else {
            return block_36(state, tracer, fn_state);
        };
    }
    fn block_36<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_36_0: read-var CRm:u8
        let s_36_0: u8 = fn_state.CRm;
        // D s_36_1: cast zx s_36_0 -> bv
        let s_36_1: Bits = Bits::new(s_36_0 as u128, 4u16);
        // C s_36_2: const #0u : u8
        let s_36_2: u8 = 0;
        // C s_36_3: cast zx s_36_2 -> bv
        let s_36_3: Bits = Bits::new(s_36_2 as u128, 4u16);
        // D s_36_4: cmp-eq s_36_1 s_36_3
        let s_36_4: bool = ((s_36_1) == (s_36_3));
        // N s_36_5: branch s_36_4 b5650 b37
        if s_36_4 {
            return block_5650(state, tracer, fn_state);
        } else {
            return block_37(state, tracer, fn_state);
        };
    }
    fn block_37<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_37_0: const #0u : u8
        let s_37_0: bool = false;
        // D s_37_1: write-var gs#117564 <= s_37_0
        fn_state.gs_117564 = s_37_0;
        // N s_37_2: jump b38
        return block_38(state, tracer, fn_state);
    }
    fn block_38<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_38_0: read-var gs#117564:u8
        let s_38_0: bool = fn_state.gs_117564;
        // N s_38_1: branch s_38_0 b5649 b39
        if s_38_0 {
            return block_5649(state, tracer, fn_state);
        } else {
            return block_39(state, tracer, fn_state);
        };
    }
    fn block_39<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_39_0: const #0u : u8
        let s_39_0: bool = false;
        // D s_39_1: write-var gs#117565 <= s_39_0
        fn_state.gs_117565 = s_39_0;
        // N s_39_2: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_40<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_40_0: read-var gs#117565:u8
        let s_40_0: bool = fn_state.gs_117565;
        // N s_40_1: branch s_40_0 b5648 b41
        if s_40_0 {
            return block_5648(state, tracer, fn_state);
        } else {
            return block_41(state, tracer, fn_state);
        };
    }
    fn block_41<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_41_0: const #0u : u8
        let s_41_0: bool = false;
        // D s_41_1: write-var gs#117566 <= s_41_0
        fn_state.gs_117566 = s_41_0;
        // N s_41_2: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_42<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_42_0: read-var gs#117566:u8
        let s_42_0: bool = fn_state.gs_117566;
        // N s_42_1: branch s_42_0 b5647 b43
        if s_42_0 {
            return block_5647(state, tracer, fn_state);
        } else {
            return block_43(state, tracer, fn_state);
        };
    }
    fn block_43<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_43_0: const #0u : u8
        let s_43_0: bool = false;
        // D s_43_1: write-var gs#117567 <= s_43_0
        fn_state.gs_117567 = s_43_0;
        // N s_43_2: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_44<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_44_0: read-var gs#117567:u8
        let s_44_0: bool = fn_state.gs_117567;
        // N s_44_1: branch s_44_0 b5646 b45
        if s_44_0 {
            return block_5646(state, tracer, fn_state);
        } else {
            return block_45(state, tracer, fn_state);
        };
    }
    fn block_45<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_45_0: read-var CRm:u8
        let s_45_0: u8 = fn_state.CRm;
        // D s_45_1: cast zx s_45_0 -> bv
        let s_45_1: Bits = Bits::new(s_45_0 as u128, 4u16);
        // C s_45_2: const #0u : u8
        let s_45_2: u8 = 0;
        // C s_45_3: cast zx s_45_2 -> bv
        let s_45_3: Bits = Bits::new(s_45_2 as u128, 4u16);
        // D s_45_4: cmp-eq s_45_1 s_45_3
        let s_45_4: bool = ((s_45_1) == (s_45_3));
        // N s_45_5: branch s_45_4 b5645 b46
        if s_45_4 {
            return block_5645(state, tracer, fn_state);
        } else {
            return block_46(state, tracer, fn_state);
        };
    }
    fn block_46<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_46_0: const #0u : u8
        let s_46_0: bool = false;
        // D s_46_1: write-var gs#117568 <= s_46_0
        fn_state.gs_117568 = s_46_0;
        // N s_46_2: jump b47
        return block_47(state, tracer, fn_state);
    }
    fn block_47<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_47_0: read-var gs#117568:u8
        let s_47_0: bool = fn_state.gs_117568;
        // N s_47_1: branch s_47_0 b5644 b48
        if s_47_0 {
            return block_5644(state, tracer, fn_state);
        } else {
            return block_48(state, tracer, fn_state);
        };
    }
    fn block_48<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_48_0: const #0u : u8
        let s_48_0: bool = false;
        // D s_48_1: write-var gs#117569 <= s_48_0
        fn_state.gs_117569 = s_48_0;
        // N s_48_2: jump b49
        return block_49(state, tracer, fn_state);
    }
    fn block_49<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_49_0: read-var gs#117569:u8
        let s_49_0: bool = fn_state.gs_117569;
        // N s_49_1: branch s_49_0 b5643 b50
        if s_49_0 {
            return block_5643(state, tracer, fn_state);
        } else {
            return block_50(state, tracer, fn_state);
        };
    }
    fn block_50<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_50_0: const #0u : u8
        let s_50_0: bool = false;
        // D s_50_1: write-var gs#117570 <= s_50_0
        fn_state.gs_117570 = s_50_0;
        // N s_50_2: jump b51
        return block_51(state, tracer, fn_state);
    }
    fn block_51<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_51_0: read-var gs#117570:u8
        let s_51_0: bool = fn_state.gs_117570;
        // N s_51_1: branch s_51_0 b5642 b52
        if s_51_0 {
            return block_5642(state, tracer, fn_state);
        } else {
            return block_52(state, tracer, fn_state);
        };
    }
    fn block_52<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_52_0: const #0u : u8
        let s_52_0: bool = false;
        // D s_52_1: write-var gs#117571 <= s_52_0
        fn_state.gs_117571 = s_52_0;
        // N s_52_2: jump b53
        return block_53(state, tracer, fn_state);
    }
    fn block_53<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_53_0: read-var gs#117571:u8
        let s_53_0: bool = fn_state.gs_117571;
        // N s_53_1: branch s_53_0 b5641 b54
        if s_53_0 {
            return block_5641(state, tracer, fn_state);
        } else {
            return block_54(state, tracer, fn_state);
        };
    }
    fn block_54<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_54_0: read-var CRm:u8
        let s_54_0: u8 = fn_state.CRm;
        // D s_54_1: cast zx s_54_0 -> bv
        let s_54_1: Bits = Bits::new(s_54_0 as u128, 4u16);
        // C s_54_2: const #0u : u8
        let s_54_2: u8 = 0;
        // C s_54_3: cast zx s_54_2 -> bv
        let s_54_3: Bits = Bits::new(s_54_2 as u128, 4u16);
        // D s_54_4: cmp-eq s_54_1 s_54_3
        let s_54_4: bool = ((s_54_1) == (s_54_3));
        // N s_54_5: branch s_54_4 b5640 b55
        if s_54_4 {
            return block_5640(state, tracer, fn_state);
        } else {
            return block_55(state, tracer, fn_state);
        };
    }
    fn block_55<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_55_0: const #0u : u8
        let s_55_0: bool = false;
        // D s_55_1: write-var gs#117572 <= s_55_0
        fn_state.gs_117572 = s_55_0;
        // N s_55_2: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_56<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_56_0: read-var gs#117572:u8
        let s_56_0: bool = fn_state.gs_117572;
        // N s_56_1: branch s_56_0 b5639 b57
        if s_56_0 {
            return block_5639(state, tracer, fn_state);
        } else {
            return block_57(state, tracer, fn_state);
        };
    }
    fn block_57<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_57_0: const #0u : u8
        let s_57_0: bool = false;
        // D s_57_1: write-var gs#117573 <= s_57_0
        fn_state.gs_117573 = s_57_0;
        // N s_57_2: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_58<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_58_0: read-var gs#117573:u8
        let s_58_0: bool = fn_state.gs_117573;
        // N s_58_1: branch s_58_0 b5638 b59
        if s_58_0 {
            return block_5638(state, tracer, fn_state);
        } else {
            return block_59(state, tracer, fn_state);
        };
    }
    fn block_59<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_59_0: const #0u : u8
        let s_59_0: bool = false;
        // D s_59_1: write-var gs#117574 <= s_59_0
        fn_state.gs_117574 = s_59_0;
        // N s_59_2: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_60<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_60_0: read-var gs#117574:u8
        let s_60_0: bool = fn_state.gs_117574;
        // N s_60_1: branch s_60_0 b5637 b61
        if s_60_0 {
            return block_5637(state, tracer, fn_state);
        } else {
            return block_61(state, tracer, fn_state);
        };
    }
    fn block_61<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_61_0: const #0u : u8
        let s_61_0: bool = false;
        // D s_61_1: write-var gs#117575 <= s_61_0
        fn_state.gs_117575 = s_61_0;
        // N s_61_2: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_62<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_62_0: read-var gs#117575:u8
        let s_62_0: bool = fn_state.gs_117575;
        // N s_62_1: branch s_62_0 b5636 b63
        if s_62_0 {
            return block_5636(state, tracer, fn_state);
        } else {
            return block_63(state, tracer, fn_state);
        };
    }
    fn block_63<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_63_0: read-var CRm:u8
        let s_63_0: u8 = fn_state.CRm;
        // D s_63_1: cast zx s_63_0 -> bv
        let s_63_1: Bits = Bits::new(s_63_0 as u128, 4u16);
        // C s_63_2: const #13u : u8
        let s_63_2: u8 = 13;
        // C s_63_3: cast zx s_63_2 -> bv
        let s_63_3: Bits = Bits::new(s_63_2 as u128, 4u16);
        // D s_63_4: cmp-eq s_63_1 s_63_3
        let s_63_4: bool = ((s_63_1) == (s_63_3));
        // N s_63_5: branch s_63_4 b5635 b64
        if s_63_4 {
            return block_5635(state, tracer, fn_state);
        } else {
            return block_64(state, tracer, fn_state);
        };
    }
    fn block_64<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_64_0: const #0u : u8
        let s_64_0: bool = false;
        // D s_64_1: write-var gs#117576 <= s_64_0
        fn_state.gs_117576 = s_64_0;
        // N s_64_2: jump b65
        return block_65(state, tracer, fn_state);
    }
    fn block_65<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_65_0: read-var gs#117576:u8
        let s_65_0: bool = fn_state.gs_117576;
        // N s_65_1: branch s_65_0 b5634 b66
        if s_65_0 {
            return block_5634(state, tracer, fn_state);
        } else {
            return block_66(state, tracer, fn_state);
        };
    }
    fn block_66<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_66_0: const #0u : u8
        let s_66_0: bool = false;
        // D s_66_1: write-var gs#117577 <= s_66_0
        fn_state.gs_117577 = s_66_0;
        // N s_66_2: jump b67
        return block_67(state, tracer, fn_state);
    }
    fn block_67<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_67_0: read-var gs#117577:u8
        let s_67_0: bool = fn_state.gs_117577;
        // N s_67_1: branch s_67_0 b5633 b68
        if s_67_0 {
            return block_5633(state, tracer, fn_state);
        } else {
            return block_68(state, tracer, fn_state);
        };
    }
    fn block_68<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_68_0: const #0u : u8
        let s_68_0: bool = false;
        // D s_68_1: write-var gs#117578 <= s_68_0
        fn_state.gs_117578 = s_68_0;
        // N s_68_2: jump b69
        return block_69(state, tracer, fn_state);
    }
    fn block_69<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_69_0: read-var gs#117578:u8
        let s_69_0: bool = fn_state.gs_117578;
        // N s_69_1: branch s_69_0 b5632 b70
        if s_69_0 {
            return block_5632(state, tracer, fn_state);
        } else {
            return block_70(state, tracer, fn_state);
        };
    }
    fn block_70<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_70_0: const #0u : u8
        let s_70_0: bool = false;
        // D s_70_1: write-var gs#117579 <= s_70_0
        fn_state.gs_117579 = s_70_0;
        // N s_70_2: jump b71
        return block_71(state, tracer, fn_state);
    }
    fn block_71<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_71_0: read-var gs#117579:u8
        let s_71_0: bool = fn_state.gs_117579;
        // N s_71_1: branch s_71_0 b5631 b72
        if s_71_0 {
            return block_5631(state, tracer, fn_state);
        } else {
            return block_72(state, tracer, fn_state);
        };
    }
    fn block_72<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_72_0: read-var CRm:u8
        let s_72_0: u8 = fn_state.CRm;
        // D s_72_1: cast zx s_72_0 -> bv
        let s_72_1: Bits = Bits::new(s_72_0 as u128, 4u16);
        // C s_72_2: const #1u : u8
        let s_72_2: u8 = 1;
        // C s_72_3: cast zx s_72_2 -> bv
        let s_72_3: Bits = Bits::new(s_72_2 as u128, 4u16);
        // D s_72_4: cmp-eq s_72_1 s_72_3
        let s_72_4: bool = ((s_72_1) == (s_72_3));
        // N s_72_5: branch s_72_4 b5630 b73
        if s_72_4 {
            return block_5630(state, tracer, fn_state);
        } else {
            return block_73(state, tracer, fn_state);
        };
    }
    fn block_73<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_73_0: const #0u : u8
        let s_73_0: bool = false;
        // D s_73_1: write-var gs#117580 <= s_73_0
        fn_state.gs_117580 = s_73_0;
        // N s_73_2: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_74<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_74_0: read-var gs#117580:u8
        let s_74_0: bool = fn_state.gs_117580;
        // N s_74_1: branch s_74_0 b5629 b75
        if s_74_0 {
            return block_5629(state, tracer, fn_state);
        } else {
            return block_75(state, tracer, fn_state);
        };
    }
    fn block_75<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_75_0: const #0u : u8
        let s_75_0: bool = false;
        // D s_75_1: write-var gs#117581 <= s_75_0
        fn_state.gs_117581 = s_75_0;
        // N s_75_2: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_76<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_76_0: read-var gs#117581:u8
        let s_76_0: bool = fn_state.gs_117581;
        // N s_76_1: branch s_76_0 b5628 b77
        if s_76_0 {
            return block_5628(state, tracer, fn_state);
        } else {
            return block_77(state, tracer, fn_state);
        };
    }
    fn block_77<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_77_0: const #0u : u8
        let s_77_0: bool = false;
        // D s_77_1: write-var gs#117582 <= s_77_0
        fn_state.gs_117582 = s_77_0;
        // N s_77_2: jump b78
        return block_78(state, tracer, fn_state);
    }
    fn block_78<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_78_0: read-var gs#117582:u8
        let s_78_0: bool = fn_state.gs_117582;
        // N s_78_1: branch s_78_0 b5627 b79
        if s_78_0 {
            return block_5627(state, tracer, fn_state);
        } else {
            return block_79(state, tracer, fn_state);
        };
    }
    fn block_79<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_79_0: const #0u : u8
        let s_79_0: bool = false;
        // D s_79_1: write-var gs#117583 <= s_79_0
        fn_state.gs_117583 = s_79_0;
        // N s_79_2: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_80<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_80_0: read-var gs#117583:u8
        let s_80_0: bool = fn_state.gs_117583;
        // N s_80_1: branch s_80_0 b5626 b81
        if s_80_0 {
            return block_5626(state, tracer, fn_state);
        } else {
            return block_81(state, tracer, fn_state);
        };
    }
    fn block_81<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_81_0: read-var CRm:u8
        let s_81_0: u8 = fn_state.CRm;
        // D s_81_1: cast zx s_81_0 -> bv
        let s_81_1: Bits = Bits::new(s_81_0 as u128, 4u16);
        // C s_81_2: const #3u : u8
        let s_81_2: u8 = 3;
        // C s_81_3: cast zx s_81_2 -> bv
        let s_81_3: Bits = Bits::new(s_81_2 as u128, 4u16);
        // D s_81_4: cmp-eq s_81_1 s_81_3
        let s_81_4: bool = ((s_81_1) == (s_81_3));
        // N s_81_5: branch s_81_4 b5625 b82
        if s_81_4 {
            return block_5625(state, tracer, fn_state);
        } else {
            return block_82(state, tracer, fn_state);
        };
    }
    fn block_82<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_82_0: const #0u : u8
        let s_82_0: bool = false;
        // D s_82_1: write-var gs#117584 <= s_82_0
        fn_state.gs_117584 = s_82_0;
        // N s_82_2: jump b83
        return block_83(state, tracer, fn_state);
    }
    fn block_83<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_83_0: read-var gs#117584:u8
        let s_83_0: bool = fn_state.gs_117584;
        // N s_83_1: branch s_83_0 b5624 b84
        if s_83_0 {
            return block_5624(state, tracer, fn_state);
        } else {
            return block_84(state, tracer, fn_state);
        };
    }
    fn block_84<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_84_0: const #0u : u8
        let s_84_0: bool = false;
        // D s_84_1: write-var gs#117585 <= s_84_0
        fn_state.gs_117585 = s_84_0;
        // N s_84_2: jump b85
        return block_85(state, tracer, fn_state);
    }
    fn block_85<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_85_0: read-var gs#117585:u8
        let s_85_0: bool = fn_state.gs_117585;
        // N s_85_1: branch s_85_0 b5623 b86
        if s_85_0 {
            return block_5623(state, tracer, fn_state);
        } else {
            return block_86(state, tracer, fn_state);
        };
    }
    fn block_86<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_86_0: const #0u : u8
        let s_86_0: bool = false;
        // D s_86_1: write-var gs#117586 <= s_86_0
        fn_state.gs_117586 = s_86_0;
        // N s_86_2: jump b87
        return block_87(state, tracer, fn_state);
    }
    fn block_87<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_87_0: read-var gs#117586:u8
        let s_87_0: bool = fn_state.gs_117586;
        // N s_87_1: branch s_87_0 b5622 b88
        if s_87_0 {
            return block_5622(state, tracer, fn_state);
        } else {
            return block_88(state, tracer, fn_state);
        };
    }
    fn block_88<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_88_0: const #0u : u8
        let s_88_0: bool = false;
        // D s_88_1: write-var gs#117587 <= s_88_0
        fn_state.gs_117587 = s_88_0;
        // N s_88_2: jump b89
        return block_89(state, tracer, fn_state);
    }
    fn block_89<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_89_0: read-var gs#117587:u8
        let s_89_0: bool = fn_state.gs_117587;
        // N s_89_1: branch s_89_0 b5621 b90
        if s_89_0 {
            return block_5621(state, tracer, fn_state);
        } else {
            return block_90(state, tracer, fn_state);
        };
    }
    fn block_90<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_90_0: read-var CRm:u8
        let s_90_0: u8 = fn_state.CRm;
        // D s_90_1: cast zx s_90_0 -> bv
        let s_90_1: Bits = Bits::new(s_90_0 as u128, 4u16);
        // C s_90_2: const #11u : u8
        let s_90_2: u8 = 11;
        // C s_90_3: cast zx s_90_2 -> bv
        let s_90_3: Bits = Bits::new(s_90_2 as u128, 4u16);
        // D s_90_4: cmp-eq s_90_1 s_90_3
        let s_90_4: bool = ((s_90_1) == (s_90_3));
        // N s_90_5: branch s_90_4 b5620 b91
        if s_90_4 {
            return block_5620(state, tracer, fn_state);
        } else {
            return block_91(state, tracer, fn_state);
        };
    }
    fn block_91<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_91_0: const #0u : u8
        let s_91_0: bool = false;
        // D s_91_1: write-var gs#117588 <= s_91_0
        fn_state.gs_117588 = s_91_0;
        // N s_91_2: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_92<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_92_0: read-var gs#117588:u8
        let s_92_0: bool = fn_state.gs_117588;
        // N s_92_1: branch s_92_0 b5619 b93
        if s_92_0 {
            return block_5619(state, tracer, fn_state);
        } else {
            return block_93(state, tracer, fn_state);
        };
    }
    fn block_93<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_93_0: const #0u : u8
        let s_93_0: bool = false;
        // D s_93_1: write-var gs#117589 <= s_93_0
        fn_state.gs_117589 = s_93_0;
        // N s_93_2: jump b94
        return block_94(state, tracer, fn_state);
    }
    fn block_94<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_94_0: read-var gs#117589:u8
        let s_94_0: bool = fn_state.gs_117589;
        // N s_94_1: branch s_94_0 b5618 b95
        if s_94_0 {
            return block_5618(state, tracer, fn_state);
        } else {
            return block_95(state, tracer, fn_state);
        };
    }
    fn block_95<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_95_0: const #0u : u8
        let s_95_0: bool = false;
        // D s_95_1: write-var gs#117590 <= s_95_0
        fn_state.gs_117590 = s_95_0;
        // N s_95_2: jump b96
        return block_96(state, tracer, fn_state);
    }
    fn block_96<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_96_0: read-var gs#117590:u8
        let s_96_0: bool = fn_state.gs_117590;
        // N s_96_1: branch s_96_0 b5617 b97
        if s_96_0 {
            return block_5617(state, tracer, fn_state);
        } else {
            return block_97(state, tracer, fn_state);
        };
    }
    fn block_97<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_97_0: const #0u : u8
        let s_97_0: bool = false;
        // D s_97_1: write-var gs#117591 <= s_97_0
        fn_state.gs_117591 = s_97_0;
        // N s_97_2: jump b98
        return block_98(state, tracer, fn_state);
    }
    fn block_98<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_98_0: read-var gs#117591:u8
        let s_98_0: bool = fn_state.gs_117591;
        // N s_98_1: branch s_98_0 b5616 b99
        if s_98_0 {
            return block_5616(state, tracer, fn_state);
        } else {
            return block_99(state, tracer, fn_state);
        };
    }
    fn block_99<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_99_0: read-var CRm:u8
        let s_99_0: u8 = fn_state.CRm;
        // D s_99_1: cast zx s_99_0 -> bv
        let s_99_1: Bits = Bits::new(s_99_0 as u128, 4u16);
        // C s_99_2: const #12u : u8
        let s_99_2: u8 = 12;
        // C s_99_3: cast zx s_99_2 -> bv
        let s_99_3: Bits = Bits::new(s_99_2 as u128, 4u16);
        // D s_99_4: cmp-eq s_99_1 s_99_3
        let s_99_4: bool = ((s_99_1) == (s_99_3));
        // N s_99_5: branch s_99_4 b5615 b100
        if s_99_4 {
            return block_5615(state, tracer, fn_state);
        } else {
            return block_100(state, tracer, fn_state);
        };
    }
    fn block_100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_100_0: const #0u : u8
        let s_100_0: bool = false;
        // D s_100_1: write-var gs#117592 <= s_100_0
        fn_state.gs_117592 = s_100_0;
        // N s_100_2: jump b101
        return block_101(state, tracer, fn_state);
    }
    fn block_101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_101_0: read-var gs#117592:u8
        let s_101_0: bool = fn_state.gs_117592;
        // N s_101_1: branch s_101_0 b5614 b102
        if s_101_0 {
            return block_5614(state, tracer, fn_state);
        } else {
            return block_102(state, tracer, fn_state);
        };
    }
    fn block_102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_102_0: const #0u : u8
        let s_102_0: bool = false;
        // D s_102_1: write-var gs#117593 <= s_102_0
        fn_state.gs_117593 = s_102_0;
        // N s_102_2: jump b103
        return block_103(state, tracer, fn_state);
    }
    fn block_103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_103_0: read-var gs#117593:u8
        let s_103_0: bool = fn_state.gs_117593;
        // N s_103_1: branch s_103_0 b5613 b104
        if s_103_0 {
            return block_5613(state, tracer, fn_state);
        } else {
            return block_104(state, tracer, fn_state);
        };
    }
    fn block_104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_104_0: const #0u : u8
        let s_104_0: bool = false;
        // D s_104_1: write-var gs#117594 <= s_104_0
        fn_state.gs_117594 = s_104_0;
        // N s_104_2: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_105_0: read-var gs#117594:u8
        let s_105_0: bool = fn_state.gs_117594;
        // N s_105_1: branch s_105_0 b5612 b106
        if s_105_0 {
            return block_5612(state, tracer, fn_state);
        } else {
            return block_106(state, tracer, fn_state);
        };
    }
    fn block_106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_106_0: const #0u : u8
        let s_106_0: bool = false;
        // D s_106_1: write-var gs#117595 <= s_106_0
        fn_state.gs_117595 = s_106_0;
        // N s_106_2: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_107_0: read-var gs#117595:u8
        let s_107_0: bool = fn_state.gs_117595;
        // N s_107_1: branch s_107_0 b5611 b108
        if s_107_0 {
            return block_5611(state, tracer, fn_state);
        } else {
            return block_108(state, tracer, fn_state);
        };
    }
    fn block_108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_108_0: read-var CRm:u8
        let s_108_0: u8 = fn_state.CRm;
        // D s_108_1: cast zx s_108_0 -> bv
        let s_108_1: Bits = Bits::new(s_108_0 as u128, 4u16);
        // C s_108_2: const #1u : u8
        let s_108_2: u8 = 1;
        // C s_108_3: cast zx s_108_2 -> bv
        let s_108_3: Bits = Bits::new(s_108_2 as u128, 4u16);
        // D s_108_4: cmp-eq s_108_1 s_108_3
        let s_108_4: bool = ((s_108_1) == (s_108_3));
        // N s_108_5: branch s_108_4 b5610 b109
        if s_108_4 {
            return block_5610(state, tracer, fn_state);
        } else {
            return block_109(state, tracer, fn_state);
        };
    }
    fn block_109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_109_0: const #0u : u8
        let s_109_0: bool = false;
        // D s_109_1: write-var gs#117596 <= s_109_0
        fn_state.gs_117596 = s_109_0;
        // N s_109_2: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_110_0: read-var gs#117596:u8
        let s_110_0: bool = fn_state.gs_117596;
        // N s_110_1: branch s_110_0 b5609 b111
        if s_110_0 {
            return block_5609(state, tracer, fn_state);
        } else {
            return block_111(state, tracer, fn_state);
        };
    }
    fn block_111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_111_0: const #0u : u8
        let s_111_0: bool = false;
        // D s_111_1: write-var gs#117597 <= s_111_0
        fn_state.gs_117597 = s_111_0;
        // N s_111_2: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_112_0: read-var gs#117597:u8
        let s_112_0: bool = fn_state.gs_117597;
        // N s_112_1: branch s_112_0 b5608 b113
        if s_112_0 {
            return block_5608(state, tracer, fn_state);
        } else {
            return block_113(state, tracer, fn_state);
        };
    }
    fn block_113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_113_0: const #0u : u8
        let s_113_0: bool = false;
        // D s_113_1: write-var gs#117598 <= s_113_0
        fn_state.gs_117598 = s_113_0;
        // N s_113_2: jump b114
        return block_114(state, tracer, fn_state);
    }
    fn block_114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_114_0: read-var gs#117598:u8
        let s_114_0: bool = fn_state.gs_117598;
        // N s_114_1: branch s_114_0 b5607 b115
        if s_114_0 {
            return block_5607(state, tracer, fn_state);
        } else {
            return block_115(state, tracer, fn_state);
        };
    }
    fn block_115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_115_0: const #0u : u8
        let s_115_0: bool = false;
        // D s_115_1: write-var gs#117599 <= s_115_0
        fn_state.gs_117599 = s_115_0;
        // N s_115_2: jump b116
        return block_116(state, tracer, fn_state);
    }
    fn block_116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_116_0: read-var gs#117599:u8
        let s_116_0: bool = fn_state.gs_117599;
        // N s_116_1: branch s_116_0 b5606 b117
        if s_116_0 {
            return block_5606(state, tracer, fn_state);
        } else {
            return block_117(state, tracer, fn_state);
        };
    }
    fn block_117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_117_0: read-var CRm:u8
        let s_117_0: u8 = fn_state.CRm;
        // D s_117_1: cast zx s_117_0 -> bv
        let s_117_1: Bits = Bits::new(s_117_0 as u128, 4u16);
        // C s_117_2: const #0u : u8
        let s_117_2: u8 = 0;
        // C s_117_3: cast zx s_117_2 -> bv
        let s_117_3: Bits = Bits::new(s_117_2 as u128, 4u16);
        // D s_117_4: cmp-eq s_117_1 s_117_3
        let s_117_4: bool = ((s_117_1) == (s_117_3));
        // N s_117_5: branch s_117_4 b5605 b118
        if s_117_4 {
            return block_5605(state, tracer, fn_state);
        } else {
            return block_118(state, tracer, fn_state);
        };
    }
    fn block_118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_118_0: const #0u : u8
        let s_118_0: bool = false;
        // D s_118_1: write-var gs#117600 <= s_118_0
        fn_state.gs_117600 = s_118_0;
        // N s_118_2: jump b119
        return block_119(state, tracer, fn_state);
    }
    fn block_119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_119_0: read-var gs#117600:u8
        let s_119_0: bool = fn_state.gs_117600;
        // N s_119_1: branch s_119_0 b5604 b120
        if s_119_0 {
            return block_5604(state, tracer, fn_state);
        } else {
            return block_120(state, tracer, fn_state);
        };
    }
    fn block_120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_120_0: const #0u : u8
        let s_120_0: bool = false;
        // D s_120_1: write-var gs#117601 <= s_120_0
        fn_state.gs_117601 = s_120_0;
        // N s_120_2: jump b121
        return block_121(state, tracer, fn_state);
    }
    fn block_121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_121_0: read-var gs#117601:u8
        let s_121_0: bool = fn_state.gs_117601;
        // N s_121_1: branch s_121_0 b5603 b122
        if s_121_0 {
            return block_5603(state, tracer, fn_state);
        } else {
            return block_122(state, tracer, fn_state);
        };
    }
    fn block_122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_122_0: const #0u : u8
        let s_122_0: bool = false;
        // D s_122_1: write-var gs#117602 <= s_122_0
        fn_state.gs_117602 = s_122_0;
        // N s_122_2: jump b123
        return block_123(state, tracer, fn_state);
    }
    fn block_123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_123_0: read-var gs#117602:u8
        let s_123_0: bool = fn_state.gs_117602;
        // N s_123_1: branch s_123_0 b5602 b124
        if s_123_0 {
            return block_5602(state, tracer, fn_state);
        } else {
            return block_124(state, tracer, fn_state);
        };
    }
    fn block_124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_124_0: const #0u : u8
        let s_124_0: bool = false;
        // D s_124_1: write-var gs#117603 <= s_124_0
        fn_state.gs_117603 = s_124_0;
        // N s_124_2: jump b125
        return block_125(state, tracer, fn_state);
    }
    fn block_125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_125_0: read-var gs#117603:u8
        let s_125_0: bool = fn_state.gs_117603;
        // N s_125_1: branch s_125_0 b5601 b126
        if s_125_0 {
            return block_5601(state, tracer, fn_state);
        } else {
            return block_126(state, tracer, fn_state);
        };
    }
    fn block_126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_126_0: read-var CRm:u8
        let s_126_0: u8 = fn_state.CRm;
        // D s_126_1: cast zx s_126_0 -> bv
        let s_126_1: Bits = Bits::new(s_126_0 as u128, 4u16);
        // C s_126_2: const #1u : u8
        let s_126_2: u8 = 1;
        // C s_126_3: cast zx s_126_2 -> bv
        let s_126_3: Bits = Bits::new(s_126_2 as u128, 4u16);
        // D s_126_4: cmp-eq s_126_1 s_126_3
        let s_126_4: bool = ((s_126_1) == (s_126_3));
        // N s_126_5: branch s_126_4 b5600 b127
        if s_126_4 {
            return block_5600(state, tracer, fn_state);
        } else {
            return block_127(state, tracer, fn_state);
        };
    }
    fn block_127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_127_0: const #0u : u8
        let s_127_0: bool = false;
        // D s_127_1: write-var gs#117604 <= s_127_0
        fn_state.gs_117604 = s_127_0;
        // N s_127_2: jump b128
        return block_128(state, tracer, fn_state);
    }
    fn block_128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_128_0: read-var gs#117604:u8
        let s_128_0: bool = fn_state.gs_117604;
        // N s_128_1: branch s_128_0 b5599 b129
        if s_128_0 {
            return block_5599(state, tracer, fn_state);
        } else {
            return block_129(state, tracer, fn_state);
        };
    }
    fn block_129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_129_0: const #0u : u8
        let s_129_0: bool = false;
        // D s_129_1: write-var gs#117605 <= s_129_0
        fn_state.gs_117605 = s_129_0;
        // N s_129_2: jump b130
        return block_130(state, tracer, fn_state);
    }
    fn block_130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_130_0: read-var gs#117605:u8
        let s_130_0: bool = fn_state.gs_117605;
        // N s_130_1: branch s_130_0 b5598 b131
        if s_130_0 {
            return block_5598(state, tracer, fn_state);
        } else {
            return block_131(state, tracer, fn_state);
        };
    }
    fn block_131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_131_0: const #0u : u8
        let s_131_0: bool = false;
        // D s_131_1: write-var gs#117606 <= s_131_0
        fn_state.gs_117606 = s_131_0;
        // N s_131_2: jump b132
        return block_132(state, tracer, fn_state);
    }
    fn block_132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_132_0: read-var gs#117606:u8
        let s_132_0: bool = fn_state.gs_117606;
        // N s_132_1: branch s_132_0 b5597 b133
        if s_132_0 {
            return block_5597(state, tracer, fn_state);
        } else {
            return block_133(state, tracer, fn_state);
        };
    }
    fn block_133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_133_0: const #0u : u8
        let s_133_0: bool = false;
        // D s_133_1: write-var gs#117607 <= s_133_0
        fn_state.gs_117607 = s_133_0;
        // N s_133_2: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_134_0: read-var gs#117607:u8
        let s_134_0: bool = fn_state.gs_117607;
        // N s_134_1: branch s_134_0 b5596 b135
        if s_134_0 {
            return block_5596(state, tracer, fn_state);
        } else {
            return block_135(state, tracer, fn_state);
        };
    }
    fn block_135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_135_0: read-var CRm:u8
        let s_135_0: u8 = fn_state.CRm;
        // D s_135_1: cast zx s_135_0 -> bv
        let s_135_1: Bits = Bits::new(s_135_0 as u128, 4u16);
        // C s_135_2: const #0u : u8
        let s_135_2: u8 = 0;
        // C s_135_3: cast zx s_135_2 -> bv
        let s_135_3: Bits = Bits::new(s_135_2 as u128, 4u16);
        // D s_135_4: cmp-eq s_135_1 s_135_3
        let s_135_4: bool = ((s_135_1) == (s_135_3));
        // N s_135_5: branch s_135_4 b5595 b136
        if s_135_4 {
            return block_5595(state, tracer, fn_state);
        } else {
            return block_136(state, tracer, fn_state);
        };
    }
    fn block_136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_136_0: const #0u : u8
        let s_136_0: bool = false;
        // D s_136_1: write-var gs#117608 <= s_136_0
        fn_state.gs_117608 = s_136_0;
        // N s_136_2: jump b137
        return block_137(state, tracer, fn_state);
    }
    fn block_137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_137_0: read-var gs#117608:u8
        let s_137_0: bool = fn_state.gs_117608;
        // N s_137_1: branch s_137_0 b5594 b138
        if s_137_0 {
            return block_5594(state, tracer, fn_state);
        } else {
            return block_138(state, tracer, fn_state);
        };
    }
    fn block_138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_138_0: const #0u : u8
        let s_138_0: bool = false;
        // D s_138_1: write-var gs#117609 <= s_138_0
        fn_state.gs_117609 = s_138_0;
        // N s_138_2: jump b139
        return block_139(state, tracer, fn_state);
    }
    fn block_139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_139_0: read-var gs#117609:u8
        let s_139_0: bool = fn_state.gs_117609;
        // N s_139_1: branch s_139_0 b5593 b140
        if s_139_0 {
            return block_5593(state, tracer, fn_state);
        } else {
            return block_140(state, tracer, fn_state);
        };
    }
    fn block_140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_140_0: const #0u : u8
        let s_140_0: bool = false;
        // D s_140_1: write-var gs#117610 <= s_140_0
        fn_state.gs_117610 = s_140_0;
        // N s_140_2: jump b141
        return block_141(state, tracer, fn_state);
    }
    fn block_141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_141_0: read-var gs#117610:u8
        let s_141_0: bool = fn_state.gs_117610;
        // N s_141_1: branch s_141_0 b5592 b142
        if s_141_0 {
            return block_5592(state, tracer, fn_state);
        } else {
            return block_142(state, tracer, fn_state);
        };
    }
    fn block_142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_142_0: const #0u : u8
        let s_142_0: bool = false;
        // D s_142_1: write-var gs#117611 <= s_142_0
        fn_state.gs_117611 = s_142_0;
        // N s_142_2: jump b143
        return block_143(state, tracer, fn_state);
    }
    fn block_143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_143_0: read-var gs#117611:u8
        let s_143_0: bool = fn_state.gs_117611;
        // N s_143_1: branch s_143_0 b5591 b144
        if s_143_0 {
            return block_5591(state, tracer, fn_state);
        } else {
            return block_144(state, tracer, fn_state);
        };
    }
    fn block_144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_144_0: read-var CRm:u8
        let s_144_0: u8 = fn_state.CRm;
        // D s_144_1: cast zx s_144_0 -> bv
        let s_144_1: Bits = Bits::new(s_144_0 as u128, 4u16);
        // C s_144_2: const #1u : u8
        let s_144_2: u8 = 1;
        // C s_144_3: cast zx s_144_2 -> bv
        let s_144_3: Bits = Bits::new(s_144_2 as u128, 4u16);
        // D s_144_4: cmp-eq s_144_1 s_144_3
        let s_144_4: bool = ((s_144_1) == (s_144_3));
        // N s_144_5: branch s_144_4 b5590 b145
        if s_144_4 {
            return block_5590(state, tracer, fn_state);
        } else {
            return block_145(state, tracer, fn_state);
        };
    }
    fn block_145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_145_0: const #0u : u8
        let s_145_0: bool = false;
        // D s_145_1: write-var gs#117612 <= s_145_0
        fn_state.gs_117612 = s_145_0;
        // N s_145_2: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_146_0: read-var gs#117612:u8
        let s_146_0: bool = fn_state.gs_117612;
        // N s_146_1: branch s_146_0 b5589 b147
        if s_146_0 {
            return block_5589(state, tracer, fn_state);
        } else {
            return block_147(state, tracer, fn_state);
        };
    }
    fn block_147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_147_0: const #0u : u8
        let s_147_0: bool = false;
        // D s_147_1: write-var gs#117613 <= s_147_0
        fn_state.gs_117613 = s_147_0;
        // N s_147_2: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_148_0: read-var gs#117613:u8
        let s_148_0: bool = fn_state.gs_117613;
        // N s_148_1: branch s_148_0 b5588 b149
        if s_148_0 {
            return block_5588(state, tracer, fn_state);
        } else {
            return block_149(state, tracer, fn_state);
        };
    }
    fn block_149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_149_0: const #0u : u8
        let s_149_0: bool = false;
        // D s_149_1: write-var gs#117614 <= s_149_0
        fn_state.gs_117614 = s_149_0;
        // N s_149_2: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_150_0: read-var gs#117614:u8
        let s_150_0: bool = fn_state.gs_117614;
        // N s_150_1: branch s_150_0 b5587 b151
        if s_150_0 {
            return block_5587(state, tracer, fn_state);
        } else {
            return block_151(state, tracer, fn_state);
        };
    }
    fn block_151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_151_0: const #0u : u8
        let s_151_0: bool = false;
        // D s_151_1: write-var gs#117615 <= s_151_0
        fn_state.gs_117615 = s_151_0;
        // N s_151_2: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_152_0: read-var gs#117615:u8
        let s_152_0: bool = fn_state.gs_117615;
        // N s_152_1: branch s_152_0 b5586 b153
        if s_152_0 {
            return block_5586(state, tracer, fn_state);
        } else {
            return block_153(state, tracer, fn_state);
        };
    }
    fn block_153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_153_0: read-var CRm:u8
        let s_153_0: u8 = fn_state.CRm;
        // D s_153_1: cast zx s_153_0 -> bv
        let s_153_1: Bits = Bits::new(s_153_0 as u128, 4u16);
        // C s_153_2: const #0u : u8
        let s_153_2: u8 = 0;
        // C s_153_3: cast zx s_153_2 -> bv
        let s_153_3: Bits = Bits::new(s_153_2 as u128, 4u16);
        // D s_153_4: cmp-eq s_153_1 s_153_3
        let s_153_4: bool = ((s_153_1) == (s_153_3));
        // N s_153_5: branch s_153_4 b5585 b154
        if s_153_4 {
            return block_5585(state, tracer, fn_state);
        } else {
            return block_154(state, tracer, fn_state);
        };
    }
    fn block_154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_154_0: const #0u : u8
        let s_154_0: bool = false;
        // D s_154_1: write-var gs#117616 <= s_154_0
        fn_state.gs_117616 = s_154_0;
        // N s_154_2: jump b155
        return block_155(state, tracer, fn_state);
    }
    fn block_155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_155_0: read-var gs#117616:u8
        let s_155_0: bool = fn_state.gs_117616;
        // N s_155_1: branch s_155_0 b5584 b156
        if s_155_0 {
            return block_5584(state, tracer, fn_state);
        } else {
            return block_156(state, tracer, fn_state);
        };
    }
    fn block_156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_156_0: const #0u : u8
        let s_156_0: bool = false;
        // D s_156_1: write-var gs#117617 <= s_156_0
        fn_state.gs_117617 = s_156_0;
        // N s_156_2: jump b157
        return block_157(state, tracer, fn_state);
    }
    fn block_157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_157_0: read-var gs#117617:u8
        let s_157_0: bool = fn_state.gs_117617;
        // N s_157_1: branch s_157_0 b5583 b158
        if s_157_0 {
            return block_5583(state, tracer, fn_state);
        } else {
            return block_158(state, tracer, fn_state);
        };
    }
    fn block_158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_158_0: const #0u : u8
        let s_158_0: bool = false;
        // D s_158_1: write-var gs#117618 <= s_158_0
        fn_state.gs_117618 = s_158_0;
        // N s_158_2: jump b159
        return block_159(state, tracer, fn_state);
    }
    fn block_159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_159_0: read-var gs#117618:u8
        let s_159_0: bool = fn_state.gs_117618;
        // N s_159_1: branch s_159_0 b5582 b160
        if s_159_0 {
            return block_5582(state, tracer, fn_state);
        } else {
            return block_160(state, tracer, fn_state);
        };
    }
    fn block_160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_160_0: const #0u : u8
        let s_160_0: bool = false;
        // D s_160_1: write-var gs#117619 <= s_160_0
        fn_state.gs_117619 = s_160_0;
        // N s_160_2: jump b161
        return block_161(state, tracer, fn_state);
    }
    fn block_161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_161_0: read-var gs#117619:u8
        let s_161_0: bool = fn_state.gs_117619;
        // N s_161_1: branch s_161_0 b5581 b162
        if s_161_0 {
            return block_5581(state, tracer, fn_state);
        } else {
            return block_162(state, tracer, fn_state);
        };
    }
    fn block_162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_162_0: read-var CRm:u8
        let s_162_0: u8 = fn_state.CRm;
        // D s_162_1: cast zx s_162_0 -> bv
        let s_162_1: Bits = Bits::new(s_162_0 as u128, 4u16);
        // C s_162_2: const #1u : u8
        let s_162_2: u8 = 1;
        // C s_162_3: cast zx s_162_2 -> bv
        let s_162_3: Bits = Bits::new(s_162_2 as u128, 4u16);
        // D s_162_4: cmp-eq s_162_1 s_162_3
        let s_162_4: bool = ((s_162_1) == (s_162_3));
        // N s_162_5: branch s_162_4 b5580 b163
        if s_162_4 {
            return block_5580(state, tracer, fn_state);
        } else {
            return block_163(state, tracer, fn_state);
        };
    }
    fn block_163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_163_0: const #0u : u8
        let s_163_0: bool = false;
        // D s_163_1: write-var gs#117620 <= s_163_0
        fn_state.gs_117620 = s_163_0;
        // N s_163_2: jump b164
        return block_164(state, tracer, fn_state);
    }
    fn block_164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_164_0: read-var gs#117620:u8
        let s_164_0: bool = fn_state.gs_117620;
        // N s_164_1: branch s_164_0 b5579 b165
        if s_164_0 {
            return block_5579(state, tracer, fn_state);
        } else {
            return block_165(state, tracer, fn_state);
        };
    }
    fn block_165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_165_0: const #0u : u8
        let s_165_0: bool = false;
        // D s_165_1: write-var gs#117621 <= s_165_0
        fn_state.gs_117621 = s_165_0;
        // N s_165_2: jump b166
        return block_166(state, tracer, fn_state);
    }
    fn block_166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_166_0: read-var gs#117621:u8
        let s_166_0: bool = fn_state.gs_117621;
        // N s_166_1: branch s_166_0 b5578 b167
        if s_166_0 {
            return block_5578(state, tracer, fn_state);
        } else {
            return block_167(state, tracer, fn_state);
        };
    }
    fn block_167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_167_0: const #0u : u8
        let s_167_0: bool = false;
        // D s_167_1: write-var gs#117622 <= s_167_0
        fn_state.gs_117622 = s_167_0;
        // N s_167_2: jump b168
        return block_168(state, tracer, fn_state);
    }
    fn block_168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_168_0: read-var gs#117622:u8
        let s_168_0: bool = fn_state.gs_117622;
        // N s_168_1: branch s_168_0 b5577 b169
        if s_168_0 {
            return block_5577(state, tracer, fn_state);
        } else {
            return block_169(state, tracer, fn_state);
        };
    }
    fn block_169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_169_0: const #0u : u8
        let s_169_0: bool = false;
        // D s_169_1: write-var gs#117623 <= s_169_0
        fn_state.gs_117623 = s_169_0;
        // N s_169_2: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_170_0: read-var gs#117623:u8
        let s_170_0: bool = fn_state.gs_117623;
        // N s_170_1: branch s_170_0 b5576 b171
        if s_170_0 {
            return block_5576(state, tracer, fn_state);
        } else {
            return block_171(state, tracer, fn_state);
        };
    }
    fn block_171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_171_0: read-var CRm:u8
        let s_171_0: u8 = fn_state.CRm;
        // D s_171_1: cast zx s_171_0 -> bv
        let s_171_1: Bits = Bits::new(s_171_0 as u128, 4u16);
        // C s_171_2: const #12u : u8
        let s_171_2: u8 = 12;
        // C s_171_3: cast zx s_171_2 -> bv
        let s_171_3: Bits = Bits::new(s_171_2 as u128, 4u16);
        // D s_171_4: cmp-eq s_171_1 s_171_3
        let s_171_4: bool = ((s_171_1) == (s_171_3));
        // N s_171_5: branch s_171_4 b5575 b172
        if s_171_4 {
            return block_5575(state, tracer, fn_state);
        } else {
            return block_172(state, tracer, fn_state);
        };
    }
    fn block_172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_172_0: const #0u : u8
        let s_172_0: bool = false;
        // D s_172_1: write-var gs#117624 <= s_172_0
        fn_state.gs_117624 = s_172_0;
        // N s_172_2: jump b173
        return block_173(state, tracer, fn_state);
    }
    fn block_173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_173_0: read-var gs#117624:u8
        let s_173_0: bool = fn_state.gs_117624;
        // N s_173_1: branch s_173_0 b5574 b174
        if s_173_0 {
            return block_5574(state, tracer, fn_state);
        } else {
            return block_174(state, tracer, fn_state);
        };
    }
    fn block_174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_174_0: const #0u : u8
        let s_174_0: bool = false;
        // D s_174_1: write-var gs#117625 <= s_174_0
        fn_state.gs_117625 = s_174_0;
        // N s_174_2: jump b175
        return block_175(state, tracer, fn_state);
    }
    fn block_175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_175_0: read-var gs#117625:u8
        let s_175_0: bool = fn_state.gs_117625;
        // N s_175_1: branch s_175_0 b5573 b176
        if s_175_0 {
            return block_5573(state, tracer, fn_state);
        } else {
            return block_176(state, tracer, fn_state);
        };
    }
    fn block_176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_176_0: const #0u : u8
        let s_176_0: bool = false;
        // D s_176_1: write-var gs#117626 <= s_176_0
        fn_state.gs_117626 = s_176_0;
        // N s_176_2: jump b177
        return block_177(state, tracer, fn_state);
    }
    fn block_177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_177_0: read-var gs#117626:u8
        let s_177_0: bool = fn_state.gs_117626;
        // N s_177_1: branch s_177_0 b5572 b178
        if s_177_0 {
            return block_5572(state, tracer, fn_state);
        } else {
            return block_178(state, tracer, fn_state);
        };
    }
    fn block_178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_178_0: const #0u : u8
        let s_178_0: bool = false;
        // D s_178_1: write-var gs#117627 <= s_178_0
        fn_state.gs_117627 = s_178_0;
        // N s_178_2: jump b179
        return block_179(state, tracer, fn_state);
    }
    fn block_179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_179_0: read-var gs#117627:u8
        let s_179_0: bool = fn_state.gs_117627;
        // N s_179_1: branch s_179_0 b5571 b180
        if s_179_0 {
            return block_5571(state, tracer, fn_state);
        } else {
            return block_180(state, tracer, fn_state);
        };
    }
    fn block_180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_180_0: read-var CRm:u8
        let s_180_0: u8 = fn_state.CRm;
        // D s_180_1: cast zx s_180_0 -> bv
        let s_180_1: Bits = Bits::new(s_180_0 as u128, 4u16);
        // C s_180_2: const #12u : u8
        let s_180_2: u8 = 12;
        // C s_180_3: cast zx s_180_2 -> bv
        let s_180_3: Bits = Bits::new(s_180_2 as u128, 4u16);
        // D s_180_4: cmp-eq s_180_1 s_180_3
        let s_180_4: bool = ((s_180_1) == (s_180_3));
        // N s_180_5: branch s_180_4 b5570 b181
        if s_180_4 {
            return block_5570(state, tracer, fn_state);
        } else {
            return block_181(state, tracer, fn_state);
        };
    }
    fn block_181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_181_0: const #0u : u8
        let s_181_0: bool = false;
        // D s_181_1: write-var gs#117628 <= s_181_0
        fn_state.gs_117628 = s_181_0;
        // N s_181_2: jump b182
        return block_182(state, tracer, fn_state);
    }
    fn block_182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_182_0: read-var gs#117628:u8
        let s_182_0: bool = fn_state.gs_117628;
        // N s_182_1: branch s_182_0 b5569 b183
        if s_182_0 {
            return block_5569(state, tracer, fn_state);
        } else {
            return block_183(state, tracer, fn_state);
        };
    }
    fn block_183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_183_0: const #0u : u8
        let s_183_0: bool = false;
        // D s_183_1: write-var gs#117629 <= s_183_0
        fn_state.gs_117629 = s_183_0;
        // N s_183_2: jump b184
        return block_184(state, tracer, fn_state);
    }
    fn block_184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_184_0: read-var gs#117629:u8
        let s_184_0: bool = fn_state.gs_117629;
        // N s_184_1: branch s_184_0 b5568 b185
        if s_184_0 {
            return block_5568(state, tracer, fn_state);
        } else {
            return block_185(state, tracer, fn_state);
        };
    }
    fn block_185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_185_0: const #0u : u8
        let s_185_0: bool = false;
        // D s_185_1: write-var gs#117630 <= s_185_0
        fn_state.gs_117630 = s_185_0;
        // N s_185_2: jump b186
        return block_186(state, tracer, fn_state);
    }
    fn block_186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_186_0: read-var gs#117630:u8
        let s_186_0: bool = fn_state.gs_117630;
        // N s_186_1: branch s_186_0 b5567 b187
        if s_186_0 {
            return block_5567(state, tracer, fn_state);
        } else {
            return block_187(state, tracer, fn_state);
        };
    }
    fn block_187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_187_0: const #0u : u8
        let s_187_0: bool = false;
        // D s_187_1: write-var gs#117631 <= s_187_0
        fn_state.gs_117631 = s_187_0;
        // N s_187_2: jump b188
        return block_188(state, tracer, fn_state);
    }
    fn block_188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_188_0: read-var gs#117631:u8
        let s_188_0: bool = fn_state.gs_117631;
        // N s_188_1: branch s_188_0 b5566 b189
        if s_188_0 {
            return block_5566(state, tracer, fn_state);
        } else {
            return block_189(state, tracer, fn_state);
        };
    }
    fn block_189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_189_0: read-var CRm:u8
        let s_189_0: u8 = fn_state.CRm;
        // D s_189_1: cast zx s_189_0 -> bv
        let s_189_1: Bits = Bits::new(s_189_0 as u128, 4u16);
        // C s_189_2: const #0u : u8
        let s_189_2: u8 = 0;
        // C s_189_3: cast zx s_189_2 -> bv
        let s_189_3: Bits = Bits::new(s_189_2 as u128, 4u16);
        // D s_189_4: cmp-eq s_189_1 s_189_3
        let s_189_4: bool = ((s_189_1) == (s_189_3));
        // N s_189_5: branch s_189_4 b5565 b190
        if s_189_4 {
            return block_5565(state, tracer, fn_state);
        } else {
            return block_190(state, tracer, fn_state);
        };
    }
    fn block_190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_190_0: const #0u : u8
        let s_190_0: bool = false;
        // D s_190_1: write-var gs#117632 <= s_190_0
        fn_state.gs_117632 = s_190_0;
        // N s_190_2: jump b191
        return block_191(state, tracer, fn_state);
    }
    fn block_191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_191_0: read-var gs#117632:u8
        let s_191_0: bool = fn_state.gs_117632;
        // N s_191_1: branch s_191_0 b5564 b192
        if s_191_0 {
            return block_5564(state, tracer, fn_state);
        } else {
            return block_192(state, tracer, fn_state);
        };
    }
    fn block_192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_192_0: const #0u : u8
        let s_192_0: bool = false;
        // D s_192_1: write-var gs#117633 <= s_192_0
        fn_state.gs_117633 = s_192_0;
        // N s_192_2: jump b193
        return block_193(state, tracer, fn_state);
    }
    fn block_193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_193_0: read-var gs#117633:u8
        let s_193_0: bool = fn_state.gs_117633;
        // N s_193_1: branch s_193_0 b5563 b194
        if s_193_0 {
            return block_5563(state, tracer, fn_state);
        } else {
            return block_194(state, tracer, fn_state);
        };
    }
    fn block_194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_194_0: const #0u : u8
        let s_194_0: bool = false;
        // D s_194_1: write-var gs#117634 <= s_194_0
        fn_state.gs_117634 = s_194_0;
        // N s_194_2: jump b195
        return block_195(state, tracer, fn_state);
    }
    fn block_195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_195_0: read-var gs#117634:u8
        let s_195_0: bool = fn_state.gs_117634;
        // N s_195_1: branch s_195_0 b5562 b196
        if s_195_0 {
            return block_5562(state, tracer, fn_state);
        } else {
            return block_196(state, tracer, fn_state);
        };
    }
    fn block_196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_196_0: const #0u : u8
        let s_196_0: bool = false;
        // D s_196_1: write-var gs#117635 <= s_196_0
        fn_state.gs_117635 = s_196_0;
        // N s_196_2: jump b197
        return block_197(state, tracer, fn_state);
    }
    fn block_197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_197_0: read-var gs#117635:u8
        let s_197_0: bool = fn_state.gs_117635;
        // N s_197_1: branch s_197_0 b5561 b198
        if s_197_0 {
            return block_5561(state, tracer, fn_state);
        } else {
            return block_198(state, tracer, fn_state);
        };
    }
    fn block_198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_198_0: read-var CRm:u8
        let s_198_0: u8 = fn_state.CRm;
        // D s_198_1: cast zx s_198_0 -> bv
        let s_198_1: Bits = Bits::new(s_198_0 as u128, 4u16);
        // C s_198_2: const #14u : u8
        let s_198_2: u8 = 14;
        // C s_198_3: cast zx s_198_2 -> bv
        let s_198_3: Bits = Bits::new(s_198_2 as u128, 4u16);
        // D s_198_4: cmp-eq s_198_1 s_198_3
        let s_198_4: bool = ((s_198_1) == (s_198_3));
        // N s_198_5: branch s_198_4 b5560 b199
        if s_198_4 {
            return block_5560(state, tracer, fn_state);
        } else {
            return block_199(state, tracer, fn_state);
        };
    }
    fn block_199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_199_0: const #0u : u8
        let s_199_0: bool = false;
        // D s_199_1: write-var gs#117636 <= s_199_0
        fn_state.gs_117636 = s_199_0;
        // N s_199_2: jump b200
        return block_200(state, tracer, fn_state);
    }
    fn block_200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_200_0: read-var gs#117636:u8
        let s_200_0: bool = fn_state.gs_117636;
        // N s_200_1: branch s_200_0 b5559 b201
        if s_200_0 {
            return block_5559(state, tracer, fn_state);
        } else {
            return block_201(state, tracer, fn_state);
        };
    }
    fn block_201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_201_0: const #0u : u8
        let s_201_0: bool = false;
        // D s_201_1: write-var gs#117637 <= s_201_0
        fn_state.gs_117637 = s_201_0;
        // N s_201_2: jump b202
        return block_202(state, tracer, fn_state);
    }
    fn block_202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_202_0: read-var gs#117637:u8
        let s_202_0: bool = fn_state.gs_117637;
        // N s_202_1: branch s_202_0 b5558 b203
        if s_202_0 {
            return block_5558(state, tracer, fn_state);
        } else {
            return block_203(state, tracer, fn_state);
        };
    }
    fn block_203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_203_0: const #0u : u8
        let s_203_0: bool = false;
        // D s_203_1: write-var gs#117638 <= s_203_0
        fn_state.gs_117638 = s_203_0;
        // N s_203_2: jump b204
        return block_204(state, tracer, fn_state);
    }
    fn block_204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_204_0: read-var gs#117638:u8
        let s_204_0: bool = fn_state.gs_117638;
        // N s_204_1: branch s_204_0 b5557 b205
        if s_204_0 {
            return block_5557(state, tracer, fn_state);
        } else {
            return block_205(state, tracer, fn_state);
        };
    }
    fn block_205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_205_0: const #0u : u8
        let s_205_0: bool = false;
        // D s_205_1: write-var gs#117639 <= s_205_0
        fn_state.gs_117639 = s_205_0;
        // N s_205_2: jump b206
        return block_206(state, tracer, fn_state);
    }
    fn block_206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_206_0: read-var gs#117639:u8
        let s_206_0: bool = fn_state.gs_117639;
        // N s_206_1: branch s_206_0 b5556 b207
        if s_206_0 {
            return block_5556(state, tracer, fn_state);
        } else {
            return block_207(state, tracer, fn_state);
        };
    }
    fn block_207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_207_0: read-var CRm:u8
        let s_207_0: u8 = fn_state.CRm;
        // D s_207_1: cast zx s_207_0 -> bv
        let s_207_1: Bits = Bits::new(s_207_0 as u128, 4u16);
        // C s_207_2: const #2u : u8
        let s_207_2: u8 = 2;
        // C s_207_3: cast zx s_207_2 -> bv
        let s_207_3: Bits = Bits::new(s_207_2 as u128, 4u16);
        // D s_207_4: cmp-eq s_207_1 s_207_3
        let s_207_4: bool = ((s_207_1) == (s_207_3));
        // N s_207_5: branch s_207_4 b5555 b208
        if s_207_4 {
            return block_5555(state, tracer, fn_state);
        } else {
            return block_208(state, tracer, fn_state);
        };
    }
    fn block_208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_208_0: const #0u : u8
        let s_208_0: bool = false;
        // D s_208_1: write-var gs#117640 <= s_208_0
        fn_state.gs_117640 = s_208_0;
        // N s_208_2: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_209_0: read-var gs#117640:u8
        let s_209_0: bool = fn_state.gs_117640;
        // N s_209_1: branch s_209_0 b5554 b210
        if s_209_0 {
            return block_5554(state, tracer, fn_state);
        } else {
            return block_210(state, tracer, fn_state);
        };
    }
    fn block_210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_210_0: const #0u : u8
        let s_210_0: bool = false;
        // D s_210_1: write-var gs#117641 <= s_210_0
        fn_state.gs_117641 = s_210_0;
        // N s_210_2: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_211_0: read-var gs#117641:u8
        let s_211_0: bool = fn_state.gs_117641;
        // N s_211_1: branch s_211_0 b5553 b212
        if s_211_0 {
            return block_5553(state, tracer, fn_state);
        } else {
            return block_212(state, tracer, fn_state);
        };
    }
    fn block_212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_212_0: const #0u : u8
        let s_212_0: bool = false;
        // D s_212_1: write-var gs#117642 <= s_212_0
        fn_state.gs_117642 = s_212_0;
        // N s_212_2: jump b213
        return block_213(state, tracer, fn_state);
    }
    fn block_213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_213_0: read-var gs#117642:u8
        let s_213_0: bool = fn_state.gs_117642;
        // N s_213_1: branch s_213_0 b5552 b214
        if s_213_0 {
            return block_5552(state, tracer, fn_state);
        } else {
            return block_214(state, tracer, fn_state);
        };
    }
    fn block_214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_214_0: const #0u : u8
        let s_214_0: bool = false;
        // D s_214_1: write-var gs#117643 <= s_214_0
        fn_state.gs_117643 = s_214_0;
        // N s_214_2: jump b215
        return block_215(state, tracer, fn_state);
    }
    fn block_215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_215_0: read-var gs#117643:u8
        let s_215_0: bool = fn_state.gs_117643;
        // N s_215_1: branch s_215_0 b5551 b216
        if s_215_0 {
            return block_5551(state, tracer, fn_state);
        } else {
            return block_216(state, tracer, fn_state);
        };
    }
    fn block_216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_216_0: read-var CRm:u8
        let s_216_0: u8 = fn_state.CRm;
        // D s_216_1: cast zx s_216_0 -> bv
        let s_216_1: Bits = Bits::new(s_216_0 as u128, 4u16);
        // C s_216_2: const #15u : u8
        let s_216_2: u8 = 15;
        // C s_216_3: cast zx s_216_2 -> bv
        let s_216_3: Bits = Bits::new(s_216_2 as u128, 4u16);
        // D s_216_4: cmp-eq s_216_1 s_216_3
        let s_216_4: bool = ((s_216_1) == (s_216_3));
        // N s_216_5: branch s_216_4 b5550 b217
        if s_216_4 {
            return block_5550(state, tracer, fn_state);
        } else {
            return block_217(state, tracer, fn_state);
        };
    }
    fn block_217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_217_0: const #0u : u8
        let s_217_0: bool = false;
        // D s_217_1: write-var gs#117644 <= s_217_0
        fn_state.gs_117644 = s_217_0;
        // N s_217_2: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_218_0: read-var gs#117644:u8
        let s_218_0: bool = fn_state.gs_117644;
        // N s_218_1: branch s_218_0 b5549 b219
        if s_218_0 {
            return block_5549(state, tracer, fn_state);
        } else {
            return block_219(state, tracer, fn_state);
        };
    }
    fn block_219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_219_0: const #0u : u8
        let s_219_0: bool = false;
        // D s_219_1: write-var gs#117645 <= s_219_0
        fn_state.gs_117645 = s_219_0;
        // N s_219_2: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_220_0: read-var gs#117645:u8
        let s_220_0: bool = fn_state.gs_117645;
        // N s_220_1: branch s_220_0 b5548 b221
        if s_220_0 {
            return block_5548(state, tracer, fn_state);
        } else {
            return block_221(state, tracer, fn_state);
        };
    }
    fn block_221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_221_0: const #0u : u8
        let s_221_0: bool = false;
        // D s_221_1: write-var gs#117646 <= s_221_0
        fn_state.gs_117646 = s_221_0;
        // N s_221_2: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_222_0: read-var gs#117646:u8
        let s_222_0: bool = fn_state.gs_117646;
        // N s_222_1: branch s_222_0 b5547 b223
        if s_222_0 {
            return block_5547(state, tracer, fn_state);
        } else {
            return block_223(state, tracer, fn_state);
        };
    }
    fn block_223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_223_0: const #0u : u8
        let s_223_0: bool = false;
        // D s_223_1: write-var gs#117647 <= s_223_0
        fn_state.gs_117647 = s_223_0;
        // N s_223_2: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_224_0: read-var gs#117647:u8
        let s_224_0: bool = fn_state.gs_117647;
        // N s_224_1: branch s_224_0 b5546 b225
        if s_224_0 {
            return block_5546(state, tracer, fn_state);
        } else {
            return block_225(state, tracer, fn_state);
        };
    }
    fn block_225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_225_0: read-var CRm:u8
        let s_225_0: u8 = fn_state.CRm;
        // D s_225_1: cast zx s_225_0 -> bv
        let s_225_1: Bits = Bits::new(s_225_0 as u128, 4u16);
        // C s_225_2: const #14u : u8
        let s_225_2: u8 = 14;
        // C s_225_3: cast zx s_225_2 -> bv
        let s_225_3: Bits = Bits::new(s_225_2 as u128, 4u16);
        // D s_225_4: cmp-eq s_225_1 s_225_3
        let s_225_4: bool = ((s_225_1) == (s_225_3));
        // N s_225_5: branch s_225_4 b5545 b226
        if s_225_4 {
            return block_5545(state, tracer, fn_state);
        } else {
            return block_226(state, tracer, fn_state);
        };
    }
    fn block_226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_226_0: const #0u : u8
        let s_226_0: bool = false;
        // D s_226_1: write-var gs#117648 <= s_226_0
        fn_state.gs_117648 = s_226_0;
        // N s_226_2: jump b227
        return block_227(state, tracer, fn_state);
    }
    fn block_227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_227_0: read-var gs#117648:u8
        let s_227_0: bool = fn_state.gs_117648;
        // N s_227_1: branch s_227_0 b5544 b228
        if s_227_0 {
            return block_5544(state, tracer, fn_state);
        } else {
            return block_228(state, tracer, fn_state);
        };
    }
    fn block_228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_228_0: const #0u : u8
        let s_228_0: bool = false;
        // D s_228_1: write-var gs#117649 <= s_228_0
        fn_state.gs_117649 = s_228_0;
        // N s_228_2: jump b229
        return block_229(state, tracer, fn_state);
    }
    fn block_229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_229_0: read-var gs#117649:u8
        let s_229_0: bool = fn_state.gs_117649;
        // N s_229_1: branch s_229_0 b5543 b230
        if s_229_0 {
            return block_5543(state, tracer, fn_state);
        } else {
            return block_230(state, tracer, fn_state);
        };
    }
    fn block_230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_230_0: const #0u : u8
        let s_230_0: bool = false;
        // D s_230_1: write-var gs#117650 <= s_230_0
        fn_state.gs_117650 = s_230_0;
        // N s_230_2: jump b231
        return block_231(state, tracer, fn_state);
    }
    fn block_231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_231_0: read-var gs#117650:u8
        let s_231_0: bool = fn_state.gs_117650;
        // N s_231_1: branch s_231_0 b5542 b232
        if s_231_0 {
            return block_5542(state, tracer, fn_state);
        } else {
            return block_232(state, tracer, fn_state);
        };
    }
    fn block_232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_232_0: const #0u : u8
        let s_232_0: bool = false;
        // D s_232_1: write-var gs#117651 <= s_232_0
        fn_state.gs_117651 = s_232_0;
        // N s_232_2: jump b233
        return block_233(state, tracer, fn_state);
    }
    fn block_233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_233_0: read-var gs#117651:u8
        let s_233_0: bool = fn_state.gs_117651;
        // N s_233_1: branch s_233_0 b5541 b234
        if s_233_0 {
            return block_5541(state, tracer, fn_state);
        } else {
            return block_234(state, tracer, fn_state);
        };
    }
    fn block_234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_234_0: read-var CRm:u8
        let s_234_0: u8 = fn_state.CRm;
        // D s_234_1: cast zx s_234_0 -> bv
        let s_234_1: Bits = Bits::new(s_234_0 as u128, 4u16);
        // C s_234_2: const #13u : u8
        let s_234_2: u8 = 13;
        // C s_234_3: cast zx s_234_2 -> bv
        let s_234_3: Bits = Bits::new(s_234_2 as u128, 4u16);
        // D s_234_4: cmp-eq s_234_1 s_234_3
        let s_234_4: bool = ((s_234_1) == (s_234_3));
        // N s_234_5: branch s_234_4 b5540 b235
        if s_234_4 {
            return block_5540(state, tracer, fn_state);
        } else {
            return block_235(state, tracer, fn_state);
        };
    }
    fn block_235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_235_0: const #0u : u8
        let s_235_0: bool = false;
        // D s_235_1: write-var gs#117652 <= s_235_0
        fn_state.gs_117652 = s_235_0;
        // N s_235_2: jump b236
        return block_236(state, tracer, fn_state);
    }
    fn block_236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_236_0: read-var gs#117652:u8
        let s_236_0: bool = fn_state.gs_117652;
        // N s_236_1: branch s_236_0 b5539 b237
        if s_236_0 {
            return block_5539(state, tracer, fn_state);
        } else {
            return block_237(state, tracer, fn_state);
        };
    }
    fn block_237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_237_0: const #0u : u8
        let s_237_0: bool = false;
        // D s_237_1: write-var gs#117653 <= s_237_0
        fn_state.gs_117653 = s_237_0;
        // N s_237_2: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_238_0: read-var gs#117653:u8
        let s_238_0: bool = fn_state.gs_117653;
        // N s_238_1: branch s_238_0 b5538 b239
        if s_238_0 {
            return block_5538(state, tracer, fn_state);
        } else {
            return block_239(state, tracer, fn_state);
        };
    }
    fn block_239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_239_0: const #0u : u8
        let s_239_0: bool = false;
        // D s_239_1: write-var gs#117654 <= s_239_0
        fn_state.gs_117654 = s_239_0;
        // N s_239_2: jump b240
        return block_240(state, tracer, fn_state);
    }
    fn block_240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_240_0: read-var gs#117654:u8
        let s_240_0: bool = fn_state.gs_117654;
        // N s_240_1: branch s_240_0 b5537 b241
        if s_240_0 {
            return block_5537(state, tracer, fn_state);
        } else {
            return block_241(state, tracer, fn_state);
        };
    }
    fn block_241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_241_0: const #0u : u8
        let s_241_0: bool = false;
        // D s_241_1: write-var gs#117655 <= s_241_0
        fn_state.gs_117655 = s_241_0;
        // N s_241_2: jump b242
        return block_242(state, tracer, fn_state);
    }
    fn block_242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_242_0: read-var gs#117655:u8
        let s_242_0: bool = fn_state.gs_117655;
        // N s_242_1: branch s_242_0 b5536 b243
        if s_242_0 {
            return block_5536(state, tracer, fn_state);
        } else {
            return block_243(state, tracer, fn_state);
        };
    }
    fn block_243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_243_0: read-var CRm:u8
        let s_243_0: u8 = fn_state.CRm;
        // D s_243_1: cast zx s_243_0 -> bv
        let s_243_1: Bits = Bits::new(s_243_0 as u128, 4u16);
        // C s_243_2: const #12u : u8
        let s_243_2: u8 = 12;
        // C s_243_3: cast zx s_243_2 -> bv
        let s_243_3: Bits = Bits::new(s_243_2 as u128, 4u16);
        // D s_243_4: cmp-eq s_243_1 s_243_3
        let s_243_4: bool = ((s_243_1) == (s_243_3));
        // N s_243_5: branch s_243_4 b5535 b244
        if s_243_4 {
            return block_5535(state, tracer, fn_state);
        } else {
            return block_244(state, tracer, fn_state);
        };
    }
    fn block_244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_244_0: const #0u : u8
        let s_244_0: bool = false;
        // D s_244_1: write-var gs#117656 <= s_244_0
        fn_state.gs_117656 = s_244_0;
        // N s_244_2: jump b245
        return block_245(state, tracer, fn_state);
    }
    fn block_245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_245_0: read-var gs#117656:u8
        let s_245_0: bool = fn_state.gs_117656;
        // N s_245_1: branch s_245_0 b5534 b246
        if s_245_0 {
            return block_5534(state, tracer, fn_state);
        } else {
            return block_246(state, tracer, fn_state);
        };
    }
    fn block_246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_246_0: const #0u : u8
        let s_246_0: bool = false;
        // D s_246_1: write-var gs#117657 <= s_246_0
        fn_state.gs_117657 = s_246_0;
        // N s_246_2: jump b247
        return block_247(state, tracer, fn_state);
    }
    fn block_247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_247_0: read-var gs#117657:u8
        let s_247_0: bool = fn_state.gs_117657;
        // N s_247_1: branch s_247_0 b5533 b248
        if s_247_0 {
            return block_5533(state, tracer, fn_state);
        } else {
            return block_248(state, tracer, fn_state);
        };
    }
    fn block_248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_248_0: const #0u : u8
        let s_248_0: bool = false;
        // D s_248_1: write-var gs#117658 <= s_248_0
        fn_state.gs_117658 = s_248_0;
        // N s_248_2: jump b249
        return block_249(state, tracer, fn_state);
    }
    fn block_249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_249_0: read-var gs#117658:u8
        let s_249_0: bool = fn_state.gs_117658;
        // N s_249_1: branch s_249_0 b5532 b250
        if s_249_0 {
            return block_5532(state, tracer, fn_state);
        } else {
            return block_250(state, tracer, fn_state);
        };
    }
    fn block_250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_250_0: const #0u : u8
        let s_250_0: bool = false;
        // D s_250_1: write-var gs#117659 <= s_250_0
        fn_state.gs_117659 = s_250_0;
        // N s_250_2: jump b251
        return block_251(state, tracer, fn_state);
    }
    fn block_251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_251_0: read-var gs#117659:u8
        let s_251_0: bool = fn_state.gs_117659;
        // N s_251_1: branch s_251_0 b5531 b252
        if s_251_0 {
            return block_5531(state, tracer, fn_state);
        } else {
            return block_252(state, tracer, fn_state);
        };
    }
    fn block_252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_252_0: read-var CRm:u8
        let s_252_0: u8 = fn_state.CRm;
        // D s_252_1: cast zx s_252_0 -> bv
        let s_252_1: Bits = Bits::new(s_252_0 as u128, 4u16);
        // C s_252_2: const #11u : u8
        let s_252_2: u8 = 11;
        // C s_252_3: cast zx s_252_2 -> bv
        let s_252_3: Bits = Bits::new(s_252_2 as u128, 4u16);
        // D s_252_4: cmp-eq s_252_1 s_252_3
        let s_252_4: bool = ((s_252_1) == (s_252_3));
        // N s_252_5: branch s_252_4 b5530 b253
        if s_252_4 {
            return block_5530(state, tracer, fn_state);
        } else {
            return block_253(state, tracer, fn_state);
        };
    }
    fn block_253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_253_0: const #0u : u8
        let s_253_0: bool = false;
        // D s_253_1: write-var gs#117660 <= s_253_0
        fn_state.gs_117660 = s_253_0;
        // N s_253_2: jump b254
        return block_254(state, tracer, fn_state);
    }
    fn block_254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_254_0: read-var gs#117660:u8
        let s_254_0: bool = fn_state.gs_117660;
        // N s_254_1: branch s_254_0 b5529 b255
        if s_254_0 {
            return block_5529(state, tracer, fn_state);
        } else {
            return block_255(state, tracer, fn_state);
        };
    }
    fn block_255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_255_0: const #0u : u8
        let s_255_0: bool = false;
        // D s_255_1: write-var gs#117661 <= s_255_0
        fn_state.gs_117661 = s_255_0;
        // N s_255_2: jump b256
        return block_256(state, tracer, fn_state);
    }
    fn block_256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_256_0: read-var gs#117661:u8
        let s_256_0: bool = fn_state.gs_117661;
        // N s_256_1: branch s_256_0 b5528 b257
        if s_256_0 {
            return block_5528(state, tracer, fn_state);
        } else {
            return block_257(state, tracer, fn_state);
        };
    }
    fn block_257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_257_0: const #0u : u8
        let s_257_0: bool = false;
        // D s_257_1: write-var gs#117662 <= s_257_0
        fn_state.gs_117662 = s_257_0;
        // N s_257_2: jump b258
        return block_258(state, tracer, fn_state);
    }
    fn block_258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_258_0: read-var gs#117662:u8
        let s_258_0: bool = fn_state.gs_117662;
        // N s_258_1: branch s_258_0 b5527 b259
        if s_258_0 {
            return block_5527(state, tracer, fn_state);
        } else {
            return block_259(state, tracer, fn_state);
        };
    }
    fn block_259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_259_0: const #0u : u8
        let s_259_0: bool = false;
        // D s_259_1: write-var gs#117663 <= s_259_0
        fn_state.gs_117663 = s_259_0;
        // N s_259_2: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_260_0: read-var gs#117663:u8
        let s_260_0: bool = fn_state.gs_117663;
        // N s_260_1: branch s_260_0 b5526 b261
        if s_260_0 {
            return block_5526(state, tracer, fn_state);
        } else {
            return block_261(state, tracer, fn_state);
        };
    }
    fn block_261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_261_0: read-var CRm:u8
        let s_261_0: u8 = fn_state.CRm;
        // D s_261_1: cast zx s_261_0 -> bv
        let s_261_1: Bits = Bits::new(s_261_0 as u128, 4u16);
        // C s_261_2: const #10u : u8
        let s_261_2: u8 = 10;
        // C s_261_3: cast zx s_261_2 -> bv
        let s_261_3: Bits = Bits::new(s_261_2 as u128, 4u16);
        // D s_261_4: cmp-eq s_261_1 s_261_3
        let s_261_4: bool = ((s_261_1) == (s_261_3));
        // N s_261_5: branch s_261_4 b5525 b262
        if s_261_4 {
            return block_5525(state, tracer, fn_state);
        } else {
            return block_262(state, tracer, fn_state);
        };
    }
    fn block_262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_262_0: const #0u : u8
        let s_262_0: bool = false;
        // D s_262_1: write-var gs#117664 <= s_262_0
        fn_state.gs_117664 = s_262_0;
        // N s_262_2: jump b263
        return block_263(state, tracer, fn_state);
    }
    fn block_263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_263_0: read-var gs#117664:u8
        let s_263_0: bool = fn_state.gs_117664;
        // N s_263_1: branch s_263_0 b5524 b264
        if s_263_0 {
            return block_5524(state, tracer, fn_state);
        } else {
            return block_264(state, tracer, fn_state);
        };
    }
    fn block_264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_264_0: const #0u : u8
        let s_264_0: bool = false;
        // D s_264_1: write-var gs#117665 <= s_264_0
        fn_state.gs_117665 = s_264_0;
        // N s_264_2: jump b265
        return block_265(state, tracer, fn_state);
    }
    fn block_265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_265_0: read-var gs#117665:u8
        let s_265_0: bool = fn_state.gs_117665;
        // N s_265_1: branch s_265_0 b5523 b266
        if s_265_0 {
            return block_5523(state, tracer, fn_state);
        } else {
            return block_266(state, tracer, fn_state);
        };
    }
    fn block_266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_266_0: const #0u : u8
        let s_266_0: bool = false;
        // D s_266_1: write-var gs#117666 <= s_266_0
        fn_state.gs_117666 = s_266_0;
        // N s_266_2: jump b267
        return block_267(state, tracer, fn_state);
    }
    fn block_267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_267_0: read-var gs#117666:u8
        let s_267_0: bool = fn_state.gs_117666;
        // N s_267_1: branch s_267_0 b5522 b268
        if s_267_0 {
            return block_5522(state, tracer, fn_state);
        } else {
            return block_268(state, tracer, fn_state);
        };
    }
    fn block_268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_268_0: const #0u : u8
        let s_268_0: bool = false;
        // D s_268_1: write-var gs#117667 <= s_268_0
        fn_state.gs_117667 = s_268_0;
        // N s_268_2: jump b269
        return block_269(state, tracer, fn_state);
    }
    fn block_269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_269_0: read-var gs#117667:u8
        let s_269_0: bool = fn_state.gs_117667;
        // N s_269_1: branch s_269_0 b5521 b270
        if s_269_0 {
            return block_5521(state, tracer, fn_state);
        } else {
            return block_270(state, tracer, fn_state);
        };
    }
    fn block_270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_270_0: read-var CRm:u8
        let s_270_0: u8 = fn_state.CRm;
        // D s_270_1: cast zx s_270_0 -> bv
        let s_270_1: Bits = Bits::new(s_270_0 as u128, 4u16);
        // C s_270_2: const #9u : u8
        let s_270_2: u8 = 9;
        // C s_270_3: cast zx s_270_2 -> bv
        let s_270_3: Bits = Bits::new(s_270_2 as u128, 4u16);
        // D s_270_4: cmp-eq s_270_1 s_270_3
        let s_270_4: bool = ((s_270_1) == (s_270_3));
        // N s_270_5: branch s_270_4 b5520 b271
        if s_270_4 {
            return block_5520(state, tracer, fn_state);
        } else {
            return block_271(state, tracer, fn_state);
        };
    }
    fn block_271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_271_0: const #0u : u8
        let s_271_0: bool = false;
        // D s_271_1: write-var gs#117668 <= s_271_0
        fn_state.gs_117668 = s_271_0;
        // N s_271_2: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_272_0: read-var gs#117668:u8
        let s_272_0: bool = fn_state.gs_117668;
        // N s_272_1: branch s_272_0 b5519 b273
        if s_272_0 {
            return block_5519(state, tracer, fn_state);
        } else {
            return block_273(state, tracer, fn_state);
        };
    }
    fn block_273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_273_0: const #0u : u8
        let s_273_0: bool = false;
        // D s_273_1: write-var gs#117669 <= s_273_0
        fn_state.gs_117669 = s_273_0;
        // N s_273_2: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_274_0: read-var gs#117669:u8
        let s_274_0: bool = fn_state.gs_117669;
        // N s_274_1: branch s_274_0 b5518 b275
        if s_274_0 {
            return block_5518(state, tracer, fn_state);
        } else {
            return block_275(state, tracer, fn_state);
        };
    }
    fn block_275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_275_0: const #0u : u8
        let s_275_0: bool = false;
        // D s_275_1: write-var gs#117670 <= s_275_0
        fn_state.gs_117670 = s_275_0;
        // N s_275_2: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_276_0: read-var gs#117670:u8
        let s_276_0: bool = fn_state.gs_117670;
        // N s_276_1: branch s_276_0 b5517 b277
        if s_276_0 {
            return block_5517(state, tracer, fn_state);
        } else {
            return block_277(state, tracer, fn_state);
        };
    }
    fn block_277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_277_0: const #0u : u8
        let s_277_0: bool = false;
        // D s_277_1: write-var gs#117671 <= s_277_0
        fn_state.gs_117671 = s_277_0;
        // N s_277_2: jump b278
        return block_278(state, tracer, fn_state);
    }
    fn block_278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_278_0: read-var gs#117671:u8
        let s_278_0: bool = fn_state.gs_117671;
        // N s_278_1: branch s_278_0 b5516 b279
        if s_278_0 {
            return block_5516(state, tracer, fn_state);
        } else {
            return block_279(state, tracer, fn_state);
        };
    }
    fn block_279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_279_0: read-var CRm:u8
        let s_279_0: u8 = fn_state.CRm;
        // D s_279_1: cast zx s_279_0 -> bv
        let s_279_1: Bits = Bits::new(s_279_0 as u128, 4u16);
        // C s_279_2: const #8u : u8
        let s_279_2: u8 = 8;
        // C s_279_3: cast zx s_279_2 -> bv
        let s_279_3: Bits = Bits::new(s_279_2 as u128, 4u16);
        // D s_279_4: cmp-eq s_279_1 s_279_3
        let s_279_4: bool = ((s_279_1) == (s_279_3));
        // N s_279_5: branch s_279_4 b5515 b280
        if s_279_4 {
            return block_5515(state, tracer, fn_state);
        } else {
            return block_280(state, tracer, fn_state);
        };
    }
    fn block_280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_280_0: const #0u : u8
        let s_280_0: bool = false;
        // D s_280_1: write-var gs#117672 <= s_280_0
        fn_state.gs_117672 = s_280_0;
        // N s_280_2: jump b281
        return block_281(state, tracer, fn_state);
    }
    fn block_281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_281_0: read-var gs#117672:u8
        let s_281_0: bool = fn_state.gs_117672;
        // N s_281_1: branch s_281_0 b5514 b282
        if s_281_0 {
            return block_5514(state, tracer, fn_state);
        } else {
            return block_282(state, tracer, fn_state);
        };
    }
    fn block_282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_282_0: const #0u : u8
        let s_282_0: bool = false;
        // D s_282_1: write-var gs#117673 <= s_282_0
        fn_state.gs_117673 = s_282_0;
        // N s_282_2: jump b283
        return block_283(state, tracer, fn_state);
    }
    fn block_283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_283_0: read-var gs#117673:u8
        let s_283_0: bool = fn_state.gs_117673;
        // N s_283_1: branch s_283_0 b5513 b284
        if s_283_0 {
            return block_5513(state, tracer, fn_state);
        } else {
            return block_284(state, tracer, fn_state);
        };
    }
    fn block_284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_284_0: const #0u : u8
        let s_284_0: bool = false;
        // D s_284_1: write-var gs#117674 <= s_284_0
        fn_state.gs_117674 = s_284_0;
        // N s_284_2: jump b285
        return block_285(state, tracer, fn_state);
    }
    fn block_285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_285_0: read-var gs#117674:u8
        let s_285_0: bool = fn_state.gs_117674;
        // N s_285_1: branch s_285_0 b5512 b286
        if s_285_0 {
            return block_5512(state, tracer, fn_state);
        } else {
            return block_286(state, tracer, fn_state);
        };
    }
    fn block_286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_286_0: const #0u : u8
        let s_286_0: bool = false;
        // D s_286_1: write-var gs#117675 <= s_286_0
        fn_state.gs_117675 = s_286_0;
        // N s_286_2: jump b287
        return block_287(state, tracer, fn_state);
    }
    fn block_287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_287_0: read-var gs#117675:u8
        let s_287_0: bool = fn_state.gs_117675;
        // N s_287_1: branch s_287_0 b5511 b288
        if s_287_0 {
            return block_5511(state, tracer, fn_state);
        } else {
            return block_288(state, tracer, fn_state);
        };
    }
    fn block_288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_288_0: read-var CRm:u8
        let s_288_0: u8 = fn_state.CRm;
        // D s_288_1: cast zx s_288_0 -> bv
        let s_288_1: Bits = Bits::new(s_288_0 as u128, 4u16);
        // C s_288_2: const #7u : u8
        let s_288_2: u8 = 7;
        // C s_288_3: cast zx s_288_2 -> bv
        let s_288_3: Bits = Bits::new(s_288_2 as u128, 4u16);
        // D s_288_4: cmp-eq s_288_1 s_288_3
        let s_288_4: bool = ((s_288_1) == (s_288_3));
        // N s_288_5: branch s_288_4 b5510 b289
        if s_288_4 {
            return block_5510(state, tracer, fn_state);
        } else {
            return block_289(state, tracer, fn_state);
        };
    }
    fn block_289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_289_0: const #0u : u8
        let s_289_0: bool = false;
        // D s_289_1: write-var gs#117676 <= s_289_0
        fn_state.gs_117676 = s_289_0;
        // N s_289_2: jump b290
        return block_290(state, tracer, fn_state);
    }
    fn block_290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_290_0: read-var gs#117676:u8
        let s_290_0: bool = fn_state.gs_117676;
        // N s_290_1: branch s_290_0 b5509 b291
        if s_290_0 {
            return block_5509(state, tracer, fn_state);
        } else {
            return block_291(state, tracer, fn_state);
        };
    }
    fn block_291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_291_0: const #0u : u8
        let s_291_0: bool = false;
        // D s_291_1: write-var gs#117677 <= s_291_0
        fn_state.gs_117677 = s_291_0;
        // N s_291_2: jump b292
        return block_292(state, tracer, fn_state);
    }
    fn block_292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_292_0: read-var gs#117677:u8
        let s_292_0: bool = fn_state.gs_117677;
        // N s_292_1: branch s_292_0 b5508 b293
        if s_292_0 {
            return block_5508(state, tracer, fn_state);
        } else {
            return block_293(state, tracer, fn_state);
        };
    }
    fn block_293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_293_0: const #0u : u8
        let s_293_0: bool = false;
        // D s_293_1: write-var gs#117678 <= s_293_0
        fn_state.gs_117678 = s_293_0;
        // N s_293_2: jump b294
        return block_294(state, tracer, fn_state);
    }
    fn block_294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_294_0: read-var gs#117678:u8
        let s_294_0: bool = fn_state.gs_117678;
        // N s_294_1: branch s_294_0 b5507 b295
        if s_294_0 {
            return block_5507(state, tracer, fn_state);
        } else {
            return block_295(state, tracer, fn_state);
        };
    }
    fn block_295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_295_0: const #0u : u8
        let s_295_0: bool = false;
        // D s_295_1: write-var gs#117679 <= s_295_0
        fn_state.gs_117679 = s_295_0;
        // N s_295_2: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_296_0: read-var gs#117679:u8
        let s_296_0: bool = fn_state.gs_117679;
        // N s_296_1: branch s_296_0 b5506 b297
        if s_296_0 {
            return block_5506(state, tracer, fn_state);
        } else {
            return block_297(state, tracer, fn_state);
        };
    }
    fn block_297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_297_0: read-var CRm:u8
        let s_297_0: u8 = fn_state.CRm;
        // D s_297_1: cast zx s_297_0 -> bv
        let s_297_1: Bits = Bits::new(s_297_0 as u128, 4u16);
        // C s_297_2: const #6u : u8
        let s_297_2: u8 = 6;
        // C s_297_3: cast zx s_297_2 -> bv
        let s_297_3: Bits = Bits::new(s_297_2 as u128, 4u16);
        // D s_297_4: cmp-eq s_297_1 s_297_3
        let s_297_4: bool = ((s_297_1) == (s_297_3));
        // N s_297_5: branch s_297_4 b5505 b298
        if s_297_4 {
            return block_5505(state, tracer, fn_state);
        } else {
            return block_298(state, tracer, fn_state);
        };
    }
    fn block_298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_298_0: const #0u : u8
        let s_298_0: bool = false;
        // D s_298_1: write-var gs#117680 <= s_298_0
        fn_state.gs_117680 = s_298_0;
        // N s_298_2: jump b299
        return block_299(state, tracer, fn_state);
    }
    fn block_299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_299_0: read-var gs#117680:u8
        let s_299_0: bool = fn_state.gs_117680;
        // N s_299_1: branch s_299_0 b5504 b300
        if s_299_0 {
            return block_5504(state, tracer, fn_state);
        } else {
            return block_300(state, tracer, fn_state);
        };
    }
    fn block_300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_300_0: const #0u : u8
        let s_300_0: bool = false;
        // D s_300_1: write-var gs#117681 <= s_300_0
        fn_state.gs_117681 = s_300_0;
        // N s_300_2: jump b301
        return block_301(state, tracer, fn_state);
    }
    fn block_301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_301_0: read-var gs#117681:u8
        let s_301_0: bool = fn_state.gs_117681;
        // N s_301_1: branch s_301_0 b5503 b302
        if s_301_0 {
            return block_5503(state, tracer, fn_state);
        } else {
            return block_302(state, tracer, fn_state);
        };
    }
    fn block_302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_302_0: const #0u : u8
        let s_302_0: bool = false;
        // D s_302_1: write-var gs#117682 <= s_302_0
        fn_state.gs_117682 = s_302_0;
        // N s_302_2: jump b303
        return block_303(state, tracer, fn_state);
    }
    fn block_303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_303_0: read-var gs#117682:u8
        let s_303_0: bool = fn_state.gs_117682;
        // N s_303_1: branch s_303_0 b5502 b304
        if s_303_0 {
            return block_5502(state, tracer, fn_state);
        } else {
            return block_304(state, tracer, fn_state);
        };
    }
    fn block_304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_304_0: const #0u : u8
        let s_304_0: bool = false;
        // D s_304_1: write-var gs#117683 <= s_304_0
        fn_state.gs_117683 = s_304_0;
        // N s_304_2: jump b305
        return block_305(state, tracer, fn_state);
    }
    fn block_305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_305_0: read-var gs#117683:u8
        let s_305_0: bool = fn_state.gs_117683;
        // N s_305_1: branch s_305_0 b5501 b306
        if s_305_0 {
            return block_5501(state, tracer, fn_state);
        } else {
            return block_306(state, tracer, fn_state);
        };
    }
    fn block_306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_306_0: read-var CRm:u8
        let s_306_0: u8 = fn_state.CRm;
        // D s_306_1: cast zx s_306_0 -> bv
        let s_306_1: Bits = Bits::new(s_306_0 as u128, 4u16);
        // C s_306_2: const #5u : u8
        let s_306_2: u8 = 5;
        // C s_306_3: cast zx s_306_2 -> bv
        let s_306_3: Bits = Bits::new(s_306_2 as u128, 4u16);
        // D s_306_4: cmp-eq s_306_1 s_306_3
        let s_306_4: bool = ((s_306_1) == (s_306_3));
        // N s_306_5: branch s_306_4 b5500 b307
        if s_306_4 {
            return block_5500(state, tracer, fn_state);
        } else {
            return block_307(state, tracer, fn_state);
        };
    }
    fn block_307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_307_0: const #0u : u8
        let s_307_0: bool = false;
        // D s_307_1: write-var gs#117684 <= s_307_0
        fn_state.gs_117684 = s_307_0;
        // N s_307_2: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_308_0: read-var gs#117684:u8
        let s_308_0: bool = fn_state.gs_117684;
        // N s_308_1: branch s_308_0 b5499 b309
        if s_308_0 {
            return block_5499(state, tracer, fn_state);
        } else {
            return block_309(state, tracer, fn_state);
        };
    }
    fn block_309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_309_0: const #0u : u8
        let s_309_0: bool = false;
        // D s_309_1: write-var gs#117685 <= s_309_0
        fn_state.gs_117685 = s_309_0;
        // N s_309_2: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_310_0: read-var gs#117685:u8
        let s_310_0: bool = fn_state.gs_117685;
        // N s_310_1: branch s_310_0 b5498 b311
        if s_310_0 {
            return block_5498(state, tracer, fn_state);
        } else {
            return block_311(state, tracer, fn_state);
        };
    }
    fn block_311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_311_0: const #0u : u8
        let s_311_0: bool = false;
        // D s_311_1: write-var gs#117686 <= s_311_0
        fn_state.gs_117686 = s_311_0;
        // N s_311_2: jump b312
        return block_312(state, tracer, fn_state);
    }
    fn block_312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_312_0: read-var gs#117686:u8
        let s_312_0: bool = fn_state.gs_117686;
        // N s_312_1: branch s_312_0 b5497 b313
        if s_312_0 {
            return block_5497(state, tracer, fn_state);
        } else {
            return block_313(state, tracer, fn_state);
        };
    }
    fn block_313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_313_0: const #0u : u8
        let s_313_0: bool = false;
        // D s_313_1: write-var gs#117687 <= s_313_0
        fn_state.gs_117687 = s_313_0;
        // N s_313_2: jump b314
        return block_314(state, tracer, fn_state);
    }
    fn block_314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_314_0: read-var gs#117687:u8
        let s_314_0: bool = fn_state.gs_117687;
        // N s_314_1: branch s_314_0 b5496 b315
        if s_314_0 {
            return block_5496(state, tracer, fn_state);
        } else {
            return block_315(state, tracer, fn_state);
        };
    }
    fn block_315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_315_0: read-var CRm:u8
        let s_315_0: u8 = fn_state.CRm;
        // D s_315_1: cast zx s_315_0 -> bv
        let s_315_1: Bits = Bits::new(s_315_0 as u128, 4u16);
        // C s_315_2: const #4u : u8
        let s_315_2: u8 = 4;
        // C s_315_3: cast zx s_315_2 -> bv
        let s_315_3: Bits = Bits::new(s_315_2 as u128, 4u16);
        // D s_315_4: cmp-eq s_315_1 s_315_3
        let s_315_4: bool = ((s_315_1) == (s_315_3));
        // N s_315_5: branch s_315_4 b5495 b316
        if s_315_4 {
            return block_5495(state, tracer, fn_state);
        } else {
            return block_316(state, tracer, fn_state);
        };
    }
    fn block_316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_316_0: const #0u : u8
        let s_316_0: bool = false;
        // D s_316_1: write-var gs#117688 <= s_316_0
        fn_state.gs_117688 = s_316_0;
        // N s_316_2: jump b317
        return block_317(state, tracer, fn_state);
    }
    fn block_317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_317_0: read-var gs#117688:u8
        let s_317_0: bool = fn_state.gs_117688;
        // N s_317_1: branch s_317_0 b5494 b318
        if s_317_0 {
            return block_5494(state, tracer, fn_state);
        } else {
            return block_318(state, tracer, fn_state);
        };
    }
    fn block_318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_318_0: const #0u : u8
        let s_318_0: bool = false;
        // D s_318_1: write-var gs#117689 <= s_318_0
        fn_state.gs_117689 = s_318_0;
        // N s_318_2: jump b319
        return block_319(state, tracer, fn_state);
    }
    fn block_319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_319_0: read-var gs#117689:u8
        let s_319_0: bool = fn_state.gs_117689;
        // N s_319_1: branch s_319_0 b5493 b320
        if s_319_0 {
            return block_5493(state, tracer, fn_state);
        } else {
            return block_320(state, tracer, fn_state);
        };
    }
    fn block_320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_320_0: const #0u : u8
        let s_320_0: bool = false;
        // D s_320_1: write-var gs#117690 <= s_320_0
        fn_state.gs_117690 = s_320_0;
        // N s_320_2: jump b321
        return block_321(state, tracer, fn_state);
    }
    fn block_321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_321_0: read-var gs#117690:u8
        let s_321_0: bool = fn_state.gs_117690;
        // N s_321_1: branch s_321_0 b5492 b322
        if s_321_0 {
            return block_5492(state, tracer, fn_state);
        } else {
            return block_322(state, tracer, fn_state);
        };
    }
    fn block_322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_322_0: const #0u : u8
        let s_322_0: bool = false;
        // D s_322_1: write-var gs#117691 <= s_322_0
        fn_state.gs_117691 = s_322_0;
        // N s_322_2: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_323_0: read-var gs#117691:u8
        let s_323_0: bool = fn_state.gs_117691;
        // N s_323_1: branch s_323_0 b5491 b324
        if s_323_0 {
            return block_5491(state, tracer, fn_state);
        } else {
            return block_324(state, tracer, fn_state);
        };
    }
    fn block_324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_324_0: read-var CRm:u8
        let s_324_0: u8 = fn_state.CRm;
        // D s_324_1: cast zx s_324_0 -> bv
        let s_324_1: Bits = Bits::new(s_324_0 as u128, 4u16);
        // C s_324_2: const #3u : u8
        let s_324_2: u8 = 3;
        // C s_324_3: cast zx s_324_2 -> bv
        let s_324_3: Bits = Bits::new(s_324_2 as u128, 4u16);
        // D s_324_4: cmp-eq s_324_1 s_324_3
        let s_324_4: bool = ((s_324_1) == (s_324_3));
        // N s_324_5: branch s_324_4 b5490 b325
        if s_324_4 {
            return block_5490(state, tracer, fn_state);
        } else {
            return block_325(state, tracer, fn_state);
        };
    }
    fn block_325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_325_0: const #0u : u8
        let s_325_0: bool = false;
        // D s_325_1: write-var gs#117692 <= s_325_0
        fn_state.gs_117692 = s_325_0;
        // N s_325_2: jump b326
        return block_326(state, tracer, fn_state);
    }
    fn block_326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_326_0: read-var gs#117692:u8
        let s_326_0: bool = fn_state.gs_117692;
        // N s_326_1: branch s_326_0 b5489 b327
        if s_326_0 {
            return block_5489(state, tracer, fn_state);
        } else {
            return block_327(state, tracer, fn_state);
        };
    }
    fn block_327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_327_0: const #0u : u8
        let s_327_0: bool = false;
        // D s_327_1: write-var gs#117693 <= s_327_0
        fn_state.gs_117693 = s_327_0;
        // N s_327_2: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_328_0: read-var gs#117693:u8
        let s_328_0: bool = fn_state.gs_117693;
        // N s_328_1: branch s_328_0 b5488 b329
        if s_328_0 {
            return block_5488(state, tracer, fn_state);
        } else {
            return block_329(state, tracer, fn_state);
        };
    }
    fn block_329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_329_0: const #0u : u8
        let s_329_0: bool = false;
        // D s_329_1: write-var gs#117694 <= s_329_0
        fn_state.gs_117694 = s_329_0;
        // N s_329_2: jump b330
        return block_330(state, tracer, fn_state);
    }
    fn block_330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_330_0: read-var gs#117694:u8
        let s_330_0: bool = fn_state.gs_117694;
        // N s_330_1: branch s_330_0 b5487 b331
        if s_330_0 {
            return block_5487(state, tracer, fn_state);
        } else {
            return block_331(state, tracer, fn_state);
        };
    }
    fn block_331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_331_0: const #0u : u8
        let s_331_0: bool = false;
        // D s_331_1: write-var gs#117695 <= s_331_0
        fn_state.gs_117695 = s_331_0;
        // N s_331_2: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_332_0: read-var gs#117695:u8
        let s_332_0: bool = fn_state.gs_117695;
        // N s_332_1: branch s_332_0 b5486 b333
        if s_332_0 {
            return block_5486(state, tracer, fn_state);
        } else {
            return block_333(state, tracer, fn_state);
        };
    }
    fn block_333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_333_0: read-var CRm:u8
        let s_333_0: u8 = fn_state.CRm;
        // D s_333_1: cast zx s_333_0 -> bv
        let s_333_1: Bits = Bits::new(s_333_0 as u128, 4u16);
        // C s_333_2: const #2u : u8
        let s_333_2: u8 = 2;
        // C s_333_3: cast zx s_333_2 -> bv
        let s_333_3: Bits = Bits::new(s_333_2 as u128, 4u16);
        // D s_333_4: cmp-eq s_333_1 s_333_3
        let s_333_4: bool = ((s_333_1) == (s_333_3));
        // N s_333_5: branch s_333_4 b5485 b334
        if s_333_4 {
            return block_5485(state, tracer, fn_state);
        } else {
            return block_334(state, tracer, fn_state);
        };
    }
    fn block_334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_334_0: const #0u : u8
        let s_334_0: bool = false;
        // D s_334_1: write-var gs#117696 <= s_334_0
        fn_state.gs_117696 = s_334_0;
        // N s_334_2: jump b335
        return block_335(state, tracer, fn_state);
    }
    fn block_335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_335_0: read-var gs#117696:u8
        let s_335_0: bool = fn_state.gs_117696;
        // N s_335_1: branch s_335_0 b5484 b336
        if s_335_0 {
            return block_5484(state, tracer, fn_state);
        } else {
            return block_336(state, tracer, fn_state);
        };
    }
    fn block_336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_336_0: const #0u : u8
        let s_336_0: bool = false;
        // D s_336_1: write-var gs#117697 <= s_336_0
        fn_state.gs_117697 = s_336_0;
        // N s_336_2: jump b337
        return block_337(state, tracer, fn_state);
    }
    fn block_337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_337_0: read-var gs#117697:u8
        let s_337_0: bool = fn_state.gs_117697;
        // N s_337_1: branch s_337_0 b5483 b338
        if s_337_0 {
            return block_5483(state, tracer, fn_state);
        } else {
            return block_338(state, tracer, fn_state);
        };
    }
    fn block_338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_338_0: const #0u : u8
        let s_338_0: bool = false;
        // D s_338_1: write-var gs#117698 <= s_338_0
        fn_state.gs_117698 = s_338_0;
        // N s_338_2: jump b339
        return block_339(state, tracer, fn_state);
    }
    fn block_339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_339_0: read-var gs#117698:u8
        let s_339_0: bool = fn_state.gs_117698;
        // N s_339_1: branch s_339_0 b5482 b340
        if s_339_0 {
            return block_5482(state, tracer, fn_state);
        } else {
            return block_340(state, tracer, fn_state);
        };
    }
    fn block_340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_340_0: const #0u : u8
        let s_340_0: bool = false;
        // D s_340_1: write-var gs#117699 <= s_340_0
        fn_state.gs_117699 = s_340_0;
        // N s_340_2: jump b341
        return block_341(state, tracer, fn_state);
    }
    fn block_341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_341_0: read-var gs#117699:u8
        let s_341_0: bool = fn_state.gs_117699;
        // N s_341_1: branch s_341_0 b5481 b342
        if s_341_0 {
            return block_5481(state, tracer, fn_state);
        } else {
            return block_342(state, tracer, fn_state);
        };
    }
    fn block_342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_342_0: read-var CRm:u8
        let s_342_0: u8 = fn_state.CRm;
        // D s_342_1: cast zx s_342_0 -> bv
        let s_342_1: Bits = Bits::new(s_342_0 as u128, 4u16);
        // C s_342_2: const #1u : u8
        let s_342_2: u8 = 1;
        // C s_342_3: cast zx s_342_2 -> bv
        let s_342_3: Bits = Bits::new(s_342_2 as u128, 4u16);
        // D s_342_4: cmp-eq s_342_1 s_342_3
        let s_342_4: bool = ((s_342_1) == (s_342_3));
        // N s_342_5: branch s_342_4 b5480 b343
        if s_342_4 {
            return block_5480(state, tracer, fn_state);
        } else {
            return block_343(state, tracer, fn_state);
        };
    }
    fn block_343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_343_0: const #0u : u8
        let s_343_0: bool = false;
        // D s_343_1: write-var gs#117700 <= s_343_0
        fn_state.gs_117700 = s_343_0;
        // N s_343_2: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_344_0: read-var gs#117700:u8
        let s_344_0: bool = fn_state.gs_117700;
        // N s_344_1: branch s_344_0 b5479 b345
        if s_344_0 {
            return block_5479(state, tracer, fn_state);
        } else {
            return block_345(state, tracer, fn_state);
        };
    }
    fn block_345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_345_0: const #0u : u8
        let s_345_0: bool = false;
        // D s_345_1: write-var gs#117701 <= s_345_0
        fn_state.gs_117701 = s_345_0;
        // N s_345_2: jump b346
        return block_346(state, tracer, fn_state);
    }
    fn block_346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_346_0: read-var gs#117701:u8
        let s_346_0: bool = fn_state.gs_117701;
        // N s_346_1: branch s_346_0 b5478 b347
        if s_346_0 {
            return block_5478(state, tracer, fn_state);
        } else {
            return block_347(state, tracer, fn_state);
        };
    }
    fn block_347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_347_0: const #0u : u8
        let s_347_0: bool = false;
        // D s_347_1: write-var gs#117702 <= s_347_0
        fn_state.gs_117702 = s_347_0;
        // N s_347_2: jump b348
        return block_348(state, tracer, fn_state);
    }
    fn block_348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_348_0: read-var gs#117702:u8
        let s_348_0: bool = fn_state.gs_117702;
        // N s_348_1: branch s_348_0 b5477 b349
        if s_348_0 {
            return block_5477(state, tracer, fn_state);
        } else {
            return block_349(state, tracer, fn_state);
        };
    }
    fn block_349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_349_0: const #0u : u8
        let s_349_0: bool = false;
        // D s_349_1: write-var gs#117703 <= s_349_0
        fn_state.gs_117703 = s_349_0;
        // N s_349_2: jump b350
        return block_350(state, tracer, fn_state);
    }
    fn block_350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_350_0: read-var gs#117703:u8
        let s_350_0: bool = fn_state.gs_117703;
        // N s_350_1: branch s_350_0 b5476 b351
        if s_350_0 {
            return block_5476(state, tracer, fn_state);
        } else {
            return block_351(state, tracer, fn_state);
        };
    }
    fn block_351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_351_0: read-var CRm:u8
        let s_351_0: u8 = fn_state.CRm;
        // D s_351_1: cast zx s_351_0 -> bv
        let s_351_1: Bits = Bits::new(s_351_0 as u128, 4u16);
        // C s_351_2: const #0u : u8
        let s_351_2: u8 = 0;
        // C s_351_3: cast zx s_351_2 -> bv
        let s_351_3: Bits = Bits::new(s_351_2 as u128, 4u16);
        // D s_351_4: cmp-eq s_351_1 s_351_3
        let s_351_4: bool = ((s_351_1) == (s_351_3));
        // N s_351_5: branch s_351_4 b5475 b352
        if s_351_4 {
            return block_5475(state, tracer, fn_state);
        } else {
            return block_352(state, tracer, fn_state);
        };
    }
    fn block_352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_352_0: const #0u : u8
        let s_352_0: bool = false;
        // D s_352_1: write-var gs#117704 <= s_352_0
        fn_state.gs_117704 = s_352_0;
        // N s_352_2: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_353_0: read-var gs#117704:u8
        let s_353_0: bool = fn_state.gs_117704;
        // N s_353_1: branch s_353_0 b5474 b354
        if s_353_0 {
            return block_5474(state, tracer, fn_state);
        } else {
            return block_354(state, tracer, fn_state);
        };
    }
    fn block_354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_354_0: const #0u : u8
        let s_354_0: bool = false;
        // D s_354_1: write-var gs#117705 <= s_354_0
        fn_state.gs_117705 = s_354_0;
        // N s_354_2: jump b355
        return block_355(state, tracer, fn_state);
    }
    fn block_355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_355_0: read-var gs#117705:u8
        let s_355_0: bool = fn_state.gs_117705;
        // N s_355_1: branch s_355_0 b5473 b356
        if s_355_0 {
            return block_5473(state, tracer, fn_state);
        } else {
            return block_356(state, tracer, fn_state);
        };
    }
    fn block_356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_356_0: const #0u : u8
        let s_356_0: bool = false;
        // D s_356_1: write-var gs#117706 <= s_356_0
        fn_state.gs_117706 = s_356_0;
        // N s_356_2: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_357_0: read-var gs#117706:u8
        let s_357_0: bool = fn_state.gs_117706;
        // N s_357_1: branch s_357_0 b5472 b358
        if s_357_0 {
            return block_5472(state, tracer, fn_state);
        } else {
            return block_358(state, tracer, fn_state);
        };
    }
    fn block_358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_358_0: const #0u : u8
        let s_358_0: bool = false;
        // D s_358_1: write-var gs#117707 <= s_358_0
        fn_state.gs_117707 = s_358_0;
        // N s_358_2: jump b359
        return block_359(state, tracer, fn_state);
    }
    fn block_359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_359_0: read-var gs#117707:u8
        let s_359_0: bool = fn_state.gs_117707;
        // N s_359_1: branch s_359_0 b5471 b360
        if s_359_0 {
            return block_5471(state, tracer, fn_state);
        } else {
            return block_360(state, tracer, fn_state);
        };
    }
    fn block_360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_360_0: read-var CRm:u8
        let s_360_0: u8 = fn_state.CRm;
        // D s_360_1: cast zx s_360_0 -> bv
        let s_360_1: Bits = Bits::new(s_360_0 as u128, 4u16);
        // C s_360_2: const #12u : u8
        let s_360_2: u8 = 12;
        // C s_360_3: cast zx s_360_2 -> bv
        let s_360_3: Bits = Bits::new(s_360_2 as u128, 4u16);
        // D s_360_4: cmp-eq s_360_1 s_360_3
        let s_360_4: bool = ((s_360_1) == (s_360_3));
        // N s_360_5: branch s_360_4 b5470 b361
        if s_360_4 {
            return block_5470(state, tracer, fn_state);
        } else {
            return block_361(state, tracer, fn_state);
        };
    }
    fn block_361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_361_0: const #0u : u8
        let s_361_0: bool = false;
        // D s_361_1: write-var gs#117708 <= s_361_0
        fn_state.gs_117708 = s_361_0;
        // N s_361_2: jump b362
        return block_362(state, tracer, fn_state);
    }
    fn block_362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_362_0: read-var gs#117708:u8
        let s_362_0: bool = fn_state.gs_117708;
        // N s_362_1: branch s_362_0 b5469 b363
        if s_362_0 {
            return block_5469(state, tracer, fn_state);
        } else {
            return block_363(state, tracer, fn_state);
        };
    }
    fn block_363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_363_0: const #0u : u8
        let s_363_0: bool = false;
        // D s_363_1: write-var gs#117709 <= s_363_0
        fn_state.gs_117709 = s_363_0;
        // N s_363_2: jump b364
        return block_364(state, tracer, fn_state);
    }
    fn block_364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_364_0: read-var gs#117709:u8
        let s_364_0: bool = fn_state.gs_117709;
        // N s_364_1: branch s_364_0 b5468 b365
        if s_364_0 {
            return block_5468(state, tracer, fn_state);
        } else {
            return block_365(state, tracer, fn_state);
        };
    }
    fn block_365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_365_0: const #0u : u8
        let s_365_0: bool = false;
        // D s_365_1: write-var gs#117710 <= s_365_0
        fn_state.gs_117710 = s_365_0;
        // N s_365_2: jump b366
        return block_366(state, tracer, fn_state);
    }
    fn block_366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_366_0: read-var gs#117710:u8
        let s_366_0: bool = fn_state.gs_117710;
        // N s_366_1: branch s_366_0 b5467 b367
        if s_366_0 {
            return block_5467(state, tracer, fn_state);
        } else {
            return block_367(state, tracer, fn_state);
        };
    }
    fn block_367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_367_0: const #0u : u8
        let s_367_0: bool = false;
        // D s_367_1: write-var gs#117711 <= s_367_0
        fn_state.gs_117711 = s_367_0;
        // N s_367_2: jump b368
        return block_368(state, tracer, fn_state);
    }
    fn block_368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_368_0: read-var gs#117711:u8
        let s_368_0: bool = fn_state.gs_117711;
        // N s_368_1: branch s_368_0 b5466 b369
        if s_368_0 {
            return block_5466(state, tracer, fn_state);
        } else {
            return block_369(state, tracer, fn_state);
        };
    }
    fn block_369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_369_0: read-var CRm:u8
        let s_369_0: u8 = fn_state.CRm;
        // D s_369_1: cast zx s_369_0 -> bv
        let s_369_1: Bits = Bits::new(s_369_0 as u128, 4u16);
        // C s_369_2: const #14u : u8
        let s_369_2: u8 = 14;
        // C s_369_3: cast zx s_369_2 -> bv
        let s_369_3: Bits = Bits::new(s_369_2 as u128, 4u16);
        // D s_369_4: cmp-eq s_369_1 s_369_3
        let s_369_4: bool = ((s_369_1) == (s_369_3));
        // N s_369_5: branch s_369_4 b5465 b370
        if s_369_4 {
            return block_5465(state, tracer, fn_state);
        } else {
            return block_370(state, tracer, fn_state);
        };
    }
    fn block_370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_370_0: const #0u : u8
        let s_370_0: bool = false;
        // D s_370_1: write-var gs#117712 <= s_370_0
        fn_state.gs_117712 = s_370_0;
        // N s_370_2: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_371_0: read-var gs#117712:u8
        let s_371_0: bool = fn_state.gs_117712;
        // N s_371_1: branch s_371_0 b5464 b372
        if s_371_0 {
            return block_5464(state, tracer, fn_state);
        } else {
            return block_372(state, tracer, fn_state);
        };
    }
    fn block_372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_372_0: const #0u : u8
        let s_372_0: bool = false;
        // D s_372_1: write-var gs#117713 <= s_372_0
        fn_state.gs_117713 = s_372_0;
        // N s_372_2: jump b373
        return block_373(state, tracer, fn_state);
    }
    fn block_373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_373_0: read-var gs#117713:u8
        let s_373_0: bool = fn_state.gs_117713;
        // N s_373_1: branch s_373_0 b5463 b374
        if s_373_0 {
            return block_5463(state, tracer, fn_state);
        } else {
            return block_374(state, tracer, fn_state);
        };
    }
    fn block_374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_374_0: const #0u : u8
        let s_374_0: bool = false;
        // D s_374_1: write-var gs#117714 <= s_374_0
        fn_state.gs_117714 = s_374_0;
        // N s_374_2: jump b375
        return block_375(state, tracer, fn_state);
    }
    fn block_375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_375_0: read-var gs#117714:u8
        let s_375_0: bool = fn_state.gs_117714;
        // N s_375_1: branch s_375_0 b5462 b376
        if s_375_0 {
            return block_5462(state, tracer, fn_state);
        } else {
            return block_376(state, tracer, fn_state);
        };
    }
    fn block_376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_376_0: const #0u : u8
        let s_376_0: bool = false;
        // D s_376_1: write-var gs#117715 <= s_376_0
        fn_state.gs_117715 = s_376_0;
        // N s_376_2: jump b377
        return block_377(state, tracer, fn_state);
    }
    fn block_377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_377_0: read-var gs#117715:u8
        let s_377_0: bool = fn_state.gs_117715;
        // N s_377_1: branch s_377_0 b5461 b378
        if s_377_0 {
            return block_5461(state, tracer, fn_state);
        } else {
            return block_378(state, tracer, fn_state);
        };
    }
    fn block_378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_378_0: read-var CRm:u8
        let s_378_0: u8 = fn_state.CRm;
        // D s_378_1: cast zx s_378_0 -> bv
        let s_378_1: Bits = Bits::new(s_378_0 as u128, 4u16);
        // C s_378_2: const #8u : u8
        let s_378_2: u8 = 8;
        // C s_378_3: cast zx s_378_2 -> bv
        let s_378_3: Bits = Bits::new(s_378_2 as u128, 4u16);
        // D s_378_4: cmp-eq s_378_1 s_378_3
        let s_378_4: bool = ((s_378_1) == (s_378_3));
        // N s_378_5: branch s_378_4 b5460 b379
        if s_378_4 {
            return block_5460(state, tracer, fn_state);
        } else {
            return block_379(state, tracer, fn_state);
        };
    }
    fn block_379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_379_0: const #0u : u8
        let s_379_0: bool = false;
        // D s_379_1: write-var gs#117716 <= s_379_0
        fn_state.gs_117716 = s_379_0;
        // N s_379_2: jump b380
        return block_380(state, tracer, fn_state);
    }
    fn block_380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_380_0: read-var gs#117716:u8
        let s_380_0: bool = fn_state.gs_117716;
        // N s_380_1: branch s_380_0 b5459 b381
        if s_380_0 {
            return block_5459(state, tracer, fn_state);
        } else {
            return block_381(state, tracer, fn_state);
        };
    }
    fn block_381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_381_0: const #0u : u8
        let s_381_0: bool = false;
        // D s_381_1: write-var gs#117717 <= s_381_0
        fn_state.gs_117717 = s_381_0;
        // N s_381_2: jump b382
        return block_382(state, tracer, fn_state);
    }
    fn block_382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_382_0: read-var gs#117717:u8
        let s_382_0: bool = fn_state.gs_117717;
        // N s_382_1: branch s_382_0 b5458 b383
        if s_382_0 {
            return block_5458(state, tracer, fn_state);
        } else {
            return block_383(state, tracer, fn_state);
        };
    }
    fn block_383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_383_0: const #0u : u8
        let s_383_0: bool = false;
        // D s_383_1: write-var gs#117718 <= s_383_0
        fn_state.gs_117718 = s_383_0;
        // N s_383_2: jump b384
        return block_384(state, tracer, fn_state);
    }
    fn block_384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_384_0: read-var gs#117718:u8
        let s_384_0: bool = fn_state.gs_117718;
        // N s_384_1: branch s_384_0 b5457 b385
        if s_384_0 {
            return block_5457(state, tracer, fn_state);
        } else {
            return block_385(state, tracer, fn_state);
        };
    }
    fn block_385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_385_0: const #0u : u8
        let s_385_0: bool = false;
        // D s_385_1: write-var gs#117719 <= s_385_0
        fn_state.gs_117719 = s_385_0;
        // N s_385_2: jump b386
        return block_386(state, tracer, fn_state);
    }
    fn block_386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_386_0: read-var gs#117719:u8
        let s_386_0: bool = fn_state.gs_117719;
        // N s_386_1: branch s_386_0 b5456 b387
        if s_386_0 {
            return block_5456(state, tracer, fn_state);
        } else {
            return block_387(state, tracer, fn_state);
        };
    }
    fn block_387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_387_0: read-var CRm:u8
        let s_387_0: u8 = fn_state.CRm;
        // D s_387_1: cast zx s_387_0 -> bv
        let s_387_1: Bits = Bits::new(s_387_0 as u128, 4u16);
        // C s_387_2: const #12u : u8
        let s_387_2: u8 = 12;
        // C s_387_3: cast zx s_387_2 -> bv
        let s_387_3: Bits = Bits::new(s_387_2 as u128, 4u16);
        // D s_387_4: cmp-eq s_387_1 s_387_3
        let s_387_4: bool = ((s_387_1) == (s_387_3));
        // N s_387_5: branch s_387_4 b5455 b388
        if s_387_4 {
            return block_5455(state, tracer, fn_state);
        } else {
            return block_388(state, tracer, fn_state);
        };
    }
    fn block_388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_388_0: const #0u : u8
        let s_388_0: bool = false;
        // D s_388_1: write-var gs#117720 <= s_388_0
        fn_state.gs_117720 = s_388_0;
        // N s_388_2: jump b389
        return block_389(state, tracer, fn_state);
    }
    fn block_389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_389_0: read-var gs#117720:u8
        let s_389_0: bool = fn_state.gs_117720;
        // N s_389_1: branch s_389_0 b5454 b390
        if s_389_0 {
            return block_5454(state, tracer, fn_state);
        } else {
            return block_390(state, tracer, fn_state);
        };
    }
    fn block_390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_390_0: const #0u : u8
        let s_390_0: bool = false;
        // D s_390_1: write-var gs#117721 <= s_390_0
        fn_state.gs_117721 = s_390_0;
        // N s_390_2: jump b391
        return block_391(state, tracer, fn_state);
    }
    fn block_391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_391_0: read-var gs#117721:u8
        let s_391_0: bool = fn_state.gs_117721;
        // N s_391_1: branch s_391_0 b5453 b392
        if s_391_0 {
            return block_5453(state, tracer, fn_state);
        } else {
            return block_392(state, tracer, fn_state);
        };
    }
    fn block_392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_392_0: const #0u : u8
        let s_392_0: bool = false;
        // D s_392_1: write-var gs#117722 <= s_392_0
        fn_state.gs_117722 = s_392_0;
        // N s_392_2: jump b393
        return block_393(state, tracer, fn_state);
    }
    fn block_393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_393_0: read-var gs#117722:u8
        let s_393_0: bool = fn_state.gs_117722;
        // N s_393_1: branch s_393_0 b5452 b394
        if s_393_0 {
            return block_5452(state, tracer, fn_state);
        } else {
            return block_394(state, tracer, fn_state);
        };
    }
    fn block_394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_394_0: const #0u : u8
        let s_394_0: bool = false;
        // D s_394_1: write-var gs#117723 <= s_394_0
        fn_state.gs_117723 = s_394_0;
        // N s_394_2: jump b395
        return block_395(state, tracer, fn_state);
    }
    fn block_395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_395_0: read-var gs#117723:u8
        let s_395_0: bool = fn_state.gs_117723;
        // N s_395_1: branch s_395_0 b5451 b396
        if s_395_0 {
            return block_5451(state, tracer, fn_state);
        } else {
            return block_396(state, tracer, fn_state);
        };
    }
    fn block_396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_396_0: read-var CRm:u8
        let s_396_0: u8 = fn_state.CRm;
        // D s_396_1: cast zx s_396_0 -> bv
        let s_396_1: Bits = Bits::new(s_396_0 as u128, 4u16);
        // C s_396_2: const #12u : u8
        let s_396_2: u8 = 12;
        // C s_396_3: cast zx s_396_2 -> bv
        let s_396_3: Bits = Bits::new(s_396_2 as u128, 4u16);
        // D s_396_4: cmp-eq s_396_1 s_396_3
        let s_396_4: bool = ((s_396_1) == (s_396_3));
        // N s_396_5: branch s_396_4 b5450 b397
        if s_396_4 {
            return block_5450(state, tracer, fn_state);
        } else {
            return block_397(state, tracer, fn_state);
        };
    }
    fn block_397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_397_0: const #0u : u8
        let s_397_0: bool = false;
        // D s_397_1: write-var gs#117724 <= s_397_0
        fn_state.gs_117724 = s_397_0;
        // N s_397_2: jump b398
        return block_398(state, tracer, fn_state);
    }
    fn block_398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_398_0: read-var gs#117724:u8
        let s_398_0: bool = fn_state.gs_117724;
        // N s_398_1: branch s_398_0 b5449 b399
        if s_398_0 {
            return block_5449(state, tracer, fn_state);
        } else {
            return block_399(state, tracer, fn_state);
        };
    }
    fn block_399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_399_0: const #0u : u8
        let s_399_0: bool = false;
        // D s_399_1: write-var gs#117725 <= s_399_0
        fn_state.gs_117725 = s_399_0;
        // N s_399_2: jump b400
        return block_400(state, tracer, fn_state);
    }
    fn block_400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_400_0: read-var gs#117725:u8
        let s_400_0: bool = fn_state.gs_117725;
        // N s_400_1: branch s_400_0 b5448 b401
        if s_400_0 {
            return block_5448(state, tracer, fn_state);
        } else {
            return block_401(state, tracer, fn_state);
        };
    }
    fn block_401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_401_0: const #0u : u8
        let s_401_0: bool = false;
        // D s_401_1: write-var gs#117726 <= s_401_0
        fn_state.gs_117726 = s_401_0;
        // N s_401_2: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_402_0: read-var gs#117726:u8
        let s_402_0: bool = fn_state.gs_117726;
        // N s_402_1: branch s_402_0 b5447 b403
        if s_402_0 {
            return block_5447(state, tracer, fn_state);
        } else {
            return block_403(state, tracer, fn_state);
        };
    }
    fn block_403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_403_0: const #0u : u8
        let s_403_0: bool = false;
        // D s_403_1: write-var gs#117727 <= s_403_0
        fn_state.gs_117727 = s_403_0;
        // N s_403_2: jump b404
        return block_404(state, tracer, fn_state);
    }
    fn block_404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_404_0: read-var gs#117727:u8
        let s_404_0: bool = fn_state.gs_117727;
        // N s_404_1: branch s_404_0 b5446 b405
        if s_404_0 {
            return block_5446(state, tracer, fn_state);
        } else {
            return block_405(state, tracer, fn_state);
        };
    }
    fn block_405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_405_0: read-var CRm:u8
        let s_405_0: u8 = fn_state.CRm;
        // D s_405_1: cast zx s_405_0 -> bv
        let s_405_1: Bits = Bits::new(s_405_0 as u128, 4u16);
        // C s_405_2: const #1u : u8
        let s_405_2: u8 = 1;
        // C s_405_3: cast zx s_405_2 -> bv
        let s_405_3: Bits = Bits::new(s_405_2 as u128, 4u16);
        // D s_405_4: cmp-eq s_405_1 s_405_3
        let s_405_4: bool = ((s_405_1) == (s_405_3));
        // N s_405_5: branch s_405_4 b5445 b406
        if s_405_4 {
            return block_5445(state, tracer, fn_state);
        } else {
            return block_406(state, tracer, fn_state);
        };
    }
    fn block_406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_406_0: const #0u : u8
        let s_406_0: bool = false;
        // D s_406_1: write-var gs#117728 <= s_406_0
        fn_state.gs_117728 = s_406_0;
        // N s_406_2: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_407_0: read-var gs#117728:u8
        let s_407_0: bool = fn_state.gs_117728;
        // N s_407_1: branch s_407_0 b5444 b408
        if s_407_0 {
            return block_5444(state, tracer, fn_state);
        } else {
            return block_408(state, tracer, fn_state);
        };
    }
    fn block_408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_408_0: const #0u : u8
        let s_408_0: bool = false;
        // D s_408_1: write-var gs#117729 <= s_408_0
        fn_state.gs_117729 = s_408_0;
        // N s_408_2: jump b409
        return block_409(state, tracer, fn_state);
    }
    fn block_409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_409_0: read-var gs#117729:u8
        let s_409_0: bool = fn_state.gs_117729;
        // N s_409_1: branch s_409_0 b5443 b410
        if s_409_0 {
            return block_5443(state, tracer, fn_state);
        } else {
            return block_410(state, tracer, fn_state);
        };
    }
    fn block_410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_410_0: const #0u : u8
        let s_410_0: bool = false;
        // D s_410_1: write-var gs#117730 <= s_410_0
        fn_state.gs_117730 = s_410_0;
        // N s_410_2: jump b411
        return block_411(state, tracer, fn_state);
    }
    fn block_411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_411_0: read-var gs#117730:u8
        let s_411_0: bool = fn_state.gs_117730;
        // N s_411_1: branch s_411_0 b5442 b412
        if s_411_0 {
            return block_5442(state, tracer, fn_state);
        } else {
            return block_412(state, tracer, fn_state);
        };
    }
    fn block_412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_412_0: const #0u : u8
        let s_412_0: bool = false;
        // D s_412_1: write-var gs#117731 <= s_412_0
        fn_state.gs_117731 = s_412_0;
        // N s_412_2: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_413_0: read-var gs#117731:u8
        let s_413_0: bool = fn_state.gs_117731;
        // N s_413_1: branch s_413_0 b5441 b414
        if s_413_0 {
            return block_5441(state, tracer, fn_state);
        } else {
            return block_414(state, tracer, fn_state);
        };
    }
    fn block_414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_414_0: read-var CRm:u8
        let s_414_0: u8 = fn_state.CRm;
        // D s_414_1: cast zx s_414_0 -> bv
        let s_414_1: Bits = Bits::new(s_414_0 as u128, 4u16);
        // C s_414_2: const #2u : u8
        let s_414_2: u8 = 2;
        // C s_414_3: cast zx s_414_2 -> bv
        let s_414_3: Bits = Bits::new(s_414_2 as u128, 4u16);
        // D s_414_4: cmp-eq s_414_1 s_414_3
        let s_414_4: bool = ((s_414_1) == (s_414_3));
        // N s_414_5: branch s_414_4 b5440 b415
        if s_414_4 {
            return block_5440(state, tracer, fn_state);
        } else {
            return block_415(state, tracer, fn_state);
        };
    }
    fn block_415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_415_0: const #0u : u8
        let s_415_0: bool = false;
        // D s_415_1: write-var gs#117732 <= s_415_0
        fn_state.gs_117732 = s_415_0;
        // N s_415_2: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_416_0: read-var gs#117732:u8
        let s_416_0: bool = fn_state.gs_117732;
        // N s_416_1: branch s_416_0 b5439 b417
        if s_416_0 {
            return block_5439(state, tracer, fn_state);
        } else {
            return block_417(state, tracer, fn_state);
        };
    }
    fn block_417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_417_0: const #0u : u8
        let s_417_0: bool = false;
        // D s_417_1: write-var gs#117733 <= s_417_0
        fn_state.gs_117733 = s_417_0;
        // N s_417_2: jump b418
        return block_418(state, tracer, fn_state);
    }
    fn block_418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_418_0: read-var gs#117733:u8
        let s_418_0: bool = fn_state.gs_117733;
        // N s_418_1: branch s_418_0 b5438 b419
        if s_418_0 {
            return block_5438(state, tracer, fn_state);
        } else {
            return block_419(state, tracer, fn_state);
        };
    }
    fn block_419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_419_0: const #0u : u8
        let s_419_0: bool = false;
        // D s_419_1: write-var gs#117734 <= s_419_0
        fn_state.gs_117734 = s_419_0;
        // N s_419_2: jump b420
        return block_420(state, tracer, fn_state);
    }
    fn block_420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_420_0: read-var gs#117734:u8
        let s_420_0: bool = fn_state.gs_117734;
        // N s_420_1: branch s_420_0 b5437 b421
        if s_420_0 {
            return block_5437(state, tracer, fn_state);
        } else {
            return block_421(state, tracer, fn_state);
        };
    }
    fn block_421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_421_0: const #0u : u8
        let s_421_0: bool = false;
        // D s_421_1: write-var gs#117735 <= s_421_0
        fn_state.gs_117735 = s_421_0;
        // N s_421_2: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_422_0: read-var gs#117735:u8
        let s_422_0: bool = fn_state.gs_117735;
        // N s_422_1: branch s_422_0 b5436 b423
        if s_422_0 {
            return block_5436(state, tracer, fn_state);
        } else {
            return block_423(state, tracer, fn_state);
        };
    }
    fn block_423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_423_0: read-var CRm:u8
        let s_423_0: u8 = fn_state.CRm;
        // D s_423_1: cast zx s_423_0 -> bv
        let s_423_1: Bits = Bits::new(s_423_0 as u128, 4u16);
        // C s_423_2: const #12u : u8
        let s_423_2: u8 = 12;
        // C s_423_3: cast zx s_423_2 -> bv
        let s_423_3: Bits = Bits::new(s_423_2 as u128, 4u16);
        // D s_423_4: cmp-eq s_423_1 s_423_3
        let s_423_4: bool = ((s_423_1) == (s_423_3));
        // N s_423_5: branch s_423_4 b5435 b424
        if s_423_4 {
            return block_5435(state, tracer, fn_state);
        } else {
            return block_424(state, tracer, fn_state);
        };
    }
    fn block_424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_424_0: const #0u : u8
        let s_424_0: bool = false;
        // D s_424_1: write-var gs#117736 <= s_424_0
        fn_state.gs_117736 = s_424_0;
        // N s_424_2: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_425_0: read-var gs#117736:u8
        let s_425_0: bool = fn_state.gs_117736;
        // N s_425_1: branch s_425_0 b5434 b426
        if s_425_0 {
            return block_5434(state, tracer, fn_state);
        } else {
            return block_426(state, tracer, fn_state);
        };
    }
    fn block_426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_426_0: const #0u : u8
        let s_426_0: bool = false;
        // D s_426_1: write-var gs#117737 <= s_426_0
        fn_state.gs_117737 = s_426_0;
        // N s_426_2: jump b427
        return block_427(state, tracer, fn_state);
    }
    fn block_427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_427_0: read-var gs#117737:u8
        let s_427_0: bool = fn_state.gs_117737;
        // N s_427_1: branch s_427_0 b5433 b428
        if s_427_0 {
            return block_5433(state, tracer, fn_state);
        } else {
            return block_428(state, tracer, fn_state);
        };
    }
    fn block_428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_428_0: const #0u : u8
        let s_428_0: bool = false;
        // D s_428_1: write-var gs#117738 <= s_428_0
        fn_state.gs_117738 = s_428_0;
        // N s_428_2: jump b429
        return block_429(state, tracer, fn_state);
    }
    fn block_429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_429_0: read-var gs#117738:u8
        let s_429_0: bool = fn_state.gs_117738;
        // N s_429_1: branch s_429_0 b5432 b430
        if s_429_0 {
            return block_5432(state, tracer, fn_state);
        } else {
            return block_430(state, tracer, fn_state);
        };
    }
    fn block_430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_430_0: const #0u : u8
        let s_430_0: bool = false;
        // D s_430_1: write-var gs#117739 <= s_430_0
        fn_state.gs_117739 = s_430_0;
        // N s_430_2: jump b431
        return block_431(state, tracer, fn_state);
    }
    fn block_431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_431_0: read-var gs#117739:u8
        let s_431_0: bool = fn_state.gs_117739;
        // N s_431_1: branch s_431_0 b5431 b432
        if s_431_0 {
            return block_5431(state, tracer, fn_state);
        } else {
            return block_432(state, tracer, fn_state);
        };
    }
    fn block_432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_432_0: read-var CRm:u8
        let s_432_0: u8 = fn_state.CRm;
        // D s_432_1: cast zx s_432_0 -> bv
        let s_432_1: Bits = Bits::new(s_432_0 as u128, 4u16);
        // C s_432_2: const #12u : u8
        let s_432_2: u8 = 12;
        // C s_432_3: cast zx s_432_2 -> bv
        let s_432_3: Bits = Bits::new(s_432_2 as u128, 4u16);
        // D s_432_4: cmp-eq s_432_1 s_432_3
        let s_432_4: bool = ((s_432_1) == (s_432_3));
        // N s_432_5: branch s_432_4 b5430 b433
        if s_432_4 {
            return block_5430(state, tracer, fn_state);
        } else {
            return block_433(state, tracer, fn_state);
        };
    }
    fn block_433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_433_0: const #0u : u8
        let s_433_0: bool = false;
        // D s_433_1: write-var gs#117740 <= s_433_0
        fn_state.gs_117740 = s_433_0;
        // N s_433_2: jump b434
        return block_434(state, tracer, fn_state);
    }
    fn block_434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_434_0: read-var gs#117740:u8
        let s_434_0: bool = fn_state.gs_117740;
        // N s_434_1: branch s_434_0 b5429 b435
        if s_434_0 {
            return block_5429(state, tracer, fn_state);
        } else {
            return block_435(state, tracer, fn_state);
        };
    }
    fn block_435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_435_0: const #0u : u8
        let s_435_0: bool = false;
        // D s_435_1: write-var gs#117741 <= s_435_0
        fn_state.gs_117741 = s_435_0;
        // N s_435_2: jump b436
        return block_436(state, tracer, fn_state);
    }
    fn block_436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_436_0: read-var gs#117741:u8
        let s_436_0: bool = fn_state.gs_117741;
        // N s_436_1: branch s_436_0 b5428 b437
        if s_436_0 {
            return block_5428(state, tracer, fn_state);
        } else {
            return block_437(state, tracer, fn_state);
        };
    }
    fn block_437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_437_0: const #0u : u8
        let s_437_0: bool = false;
        // D s_437_1: write-var gs#117742 <= s_437_0
        fn_state.gs_117742 = s_437_0;
        // N s_437_2: jump b438
        return block_438(state, tracer, fn_state);
    }
    fn block_438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_438_0: read-var gs#117742:u8
        let s_438_0: bool = fn_state.gs_117742;
        // N s_438_1: branch s_438_0 b5427 b439
        if s_438_0 {
            return block_5427(state, tracer, fn_state);
        } else {
            return block_439(state, tracer, fn_state);
        };
    }
    fn block_439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_439_0: const #0u : u8
        let s_439_0: bool = false;
        // D s_439_1: write-var gs#117743 <= s_439_0
        fn_state.gs_117743 = s_439_0;
        // N s_439_2: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_440_0: read-var gs#117743:u8
        let s_440_0: bool = fn_state.gs_117743;
        // N s_440_1: branch s_440_0 b5426 b441
        if s_440_0 {
            return block_5426(state, tracer, fn_state);
        } else {
            return block_441(state, tracer, fn_state);
        };
    }
    fn block_441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_441_0: read-var CRm:u8
        let s_441_0: u8 = fn_state.CRm;
        // D s_441_1: cast zx s_441_0 -> bv
        let s_441_1: Bits = Bits::new(s_441_0 as u128, 4u16);
        // C s_441_2: const #2u : u8
        let s_441_2: u8 = 2;
        // C s_441_3: cast zx s_441_2 -> bv
        let s_441_3: Bits = Bits::new(s_441_2 as u128, 4u16);
        // D s_441_4: cmp-eq s_441_1 s_441_3
        let s_441_4: bool = ((s_441_1) == (s_441_3));
        // N s_441_5: branch s_441_4 b5425 b442
        if s_441_4 {
            return block_5425(state, tracer, fn_state);
        } else {
            return block_442(state, tracer, fn_state);
        };
    }
    fn block_442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_442_0: const #0u : u8
        let s_442_0: bool = false;
        // D s_442_1: write-var gs#117744 <= s_442_0
        fn_state.gs_117744 = s_442_0;
        // N s_442_2: jump b443
        return block_443(state, tracer, fn_state);
    }
    fn block_443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_443_0: read-var gs#117744:u8
        let s_443_0: bool = fn_state.gs_117744;
        // N s_443_1: branch s_443_0 b5424 b444
        if s_443_0 {
            return block_5424(state, tracer, fn_state);
        } else {
            return block_444(state, tracer, fn_state);
        };
    }
    fn block_444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_444_0: const #0u : u8
        let s_444_0: bool = false;
        // D s_444_1: write-var gs#117745 <= s_444_0
        fn_state.gs_117745 = s_444_0;
        // N s_444_2: jump b445
        return block_445(state, tracer, fn_state);
    }
    fn block_445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_445_0: read-var gs#117745:u8
        let s_445_0: bool = fn_state.gs_117745;
        // N s_445_1: branch s_445_0 b5423 b446
        if s_445_0 {
            return block_5423(state, tracer, fn_state);
        } else {
            return block_446(state, tracer, fn_state);
        };
    }
    fn block_446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_446_0: const #0u : u8
        let s_446_0: bool = false;
        // D s_446_1: write-var gs#117746 <= s_446_0
        fn_state.gs_117746 = s_446_0;
        // N s_446_2: jump b447
        return block_447(state, tracer, fn_state);
    }
    fn block_447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_447_0: read-var gs#117746:u8
        let s_447_0: bool = fn_state.gs_117746;
        // N s_447_1: branch s_447_0 b5422 b448
        if s_447_0 {
            return block_5422(state, tracer, fn_state);
        } else {
            return block_448(state, tracer, fn_state);
        };
    }
    fn block_448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_448_0: const #0u : u8
        let s_448_0: bool = false;
        // D s_448_1: write-var gs#117747 <= s_448_0
        fn_state.gs_117747 = s_448_0;
        // N s_448_2: jump b449
        return block_449(state, tracer, fn_state);
    }
    fn block_449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_449_0: read-var gs#117747:u8
        let s_449_0: bool = fn_state.gs_117747;
        // N s_449_1: branch s_449_0 b5421 b450
        if s_449_0 {
            return block_5421(state, tracer, fn_state);
        } else {
            return block_450(state, tracer, fn_state);
        };
    }
    fn block_450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_450_0: read-var CRm:u8
        let s_450_0: u8 = fn_state.CRm;
        // D s_450_1: cast zx s_450_0 -> bv
        let s_450_1: Bits = Bits::new(s_450_0 as u128, 4u16);
        // C s_450_2: const #2u : u8
        let s_450_2: u8 = 2;
        // C s_450_3: cast zx s_450_2 -> bv
        let s_450_3: Bits = Bits::new(s_450_2 as u128, 4u16);
        // D s_450_4: cmp-eq s_450_1 s_450_3
        let s_450_4: bool = ((s_450_1) == (s_450_3));
        // N s_450_5: branch s_450_4 b5420 b451
        if s_450_4 {
            return block_5420(state, tracer, fn_state);
        } else {
            return block_451(state, tracer, fn_state);
        };
    }
    fn block_451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_451_0: const #0u : u8
        let s_451_0: bool = false;
        // D s_451_1: write-var gs#117748 <= s_451_0
        fn_state.gs_117748 = s_451_0;
        // N s_451_2: jump b452
        return block_452(state, tracer, fn_state);
    }
    fn block_452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_452_0: read-var gs#117748:u8
        let s_452_0: bool = fn_state.gs_117748;
        // N s_452_1: branch s_452_0 b5419 b453
        if s_452_0 {
            return block_5419(state, tracer, fn_state);
        } else {
            return block_453(state, tracer, fn_state);
        };
    }
    fn block_453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_453_0: const #0u : u8
        let s_453_0: bool = false;
        // D s_453_1: write-var gs#117749 <= s_453_0
        fn_state.gs_117749 = s_453_0;
        // N s_453_2: jump b454
        return block_454(state, tracer, fn_state);
    }
    fn block_454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_454_0: read-var gs#117749:u8
        let s_454_0: bool = fn_state.gs_117749;
        // N s_454_1: branch s_454_0 b5418 b455
        if s_454_0 {
            return block_5418(state, tracer, fn_state);
        } else {
            return block_455(state, tracer, fn_state);
        };
    }
    fn block_455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_455_0: const #0u : u8
        let s_455_0: bool = false;
        // D s_455_1: write-var gs#117750 <= s_455_0
        fn_state.gs_117750 = s_455_0;
        // N s_455_2: jump b456
        return block_456(state, tracer, fn_state);
    }
    fn block_456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_456_0: read-var gs#117750:u8
        let s_456_0: bool = fn_state.gs_117750;
        // N s_456_1: branch s_456_0 b5417 b457
        if s_456_0 {
            return block_5417(state, tracer, fn_state);
        } else {
            return block_457(state, tracer, fn_state);
        };
    }
    fn block_457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_457_0: const #0u : u8
        let s_457_0: bool = false;
        // D s_457_1: write-var gs#117751 <= s_457_0
        fn_state.gs_117751 = s_457_0;
        // N s_457_2: jump b458
        return block_458(state, tracer, fn_state);
    }
    fn block_458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_458_0: read-var gs#117751:u8
        let s_458_0: bool = fn_state.gs_117751;
        // N s_458_1: branch s_458_0 b5416 b459
        if s_458_0 {
            return block_5416(state, tracer, fn_state);
        } else {
            return block_459(state, tracer, fn_state);
        };
    }
    fn block_459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_459_0: read-var CRm:u8
        let s_459_0: u8 = fn_state.CRm;
        // D s_459_1: cast zx s_459_0 -> bv
        let s_459_1: Bits = Bits::new(s_459_0 as u128, 4u16);
        // C s_459_2: const #15u : u8
        let s_459_2: u8 = 15;
        // C s_459_3: cast zx s_459_2 -> bv
        let s_459_3: Bits = Bits::new(s_459_2 as u128, 4u16);
        // D s_459_4: cmp-eq s_459_1 s_459_3
        let s_459_4: bool = ((s_459_1) == (s_459_3));
        // N s_459_5: branch s_459_4 b5415 b460
        if s_459_4 {
            return block_5415(state, tracer, fn_state);
        } else {
            return block_460(state, tracer, fn_state);
        };
    }
    fn block_460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_460_0: const #0u : u8
        let s_460_0: bool = false;
        // D s_460_1: write-var gs#117752 <= s_460_0
        fn_state.gs_117752 = s_460_0;
        // N s_460_2: jump b461
        return block_461(state, tracer, fn_state);
    }
    fn block_461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_461_0: read-var gs#117752:u8
        let s_461_0: bool = fn_state.gs_117752;
        // N s_461_1: branch s_461_0 b5414 b462
        if s_461_0 {
            return block_5414(state, tracer, fn_state);
        } else {
            return block_462(state, tracer, fn_state);
        };
    }
    fn block_462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_462_0: const #0u : u8
        let s_462_0: bool = false;
        // D s_462_1: write-var gs#117753 <= s_462_0
        fn_state.gs_117753 = s_462_0;
        // N s_462_2: jump b463
        return block_463(state, tracer, fn_state);
    }
    fn block_463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_463_0: read-var gs#117753:u8
        let s_463_0: bool = fn_state.gs_117753;
        // N s_463_1: branch s_463_0 b5413 b464
        if s_463_0 {
            return block_5413(state, tracer, fn_state);
        } else {
            return block_464(state, tracer, fn_state);
        };
    }
    fn block_464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_464_0: const #0u : u8
        let s_464_0: bool = false;
        // D s_464_1: write-var gs#117754 <= s_464_0
        fn_state.gs_117754 = s_464_0;
        // N s_464_2: jump b465
        return block_465(state, tracer, fn_state);
    }
    fn block_465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_465_0: read-var gs#117754:u8
        let s_465_0: bool = fn_state.gs_117754;
        // N s_465_1: branch s_465_0 b5412 b466
        if s_465_0 {
            return block_5412(state, tracer, fn_state);
        } else {
            return block_466(state, tracer, fn_state);
        };
    }
    fn block_466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_466_0: const #0u : u8
        let s_466_0: bool = false;
        // D s_466_1: write-var gs#117755 <= s_466_0
        fn_state.gs_117755 = s_466_0;
        // N s_466_2: jump b467
        return block_467(state, tracer, fn_state);
    }
    fn block_467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_467_0: read-var gs#117755:u8
        let s_467_0: bool = fn_state.gs_117755;
        // N s_467_1: branch s_467_0 b5411 b468
        if s_467_0 {
            return block_5411(state, tracer, fn_state);
        } else {
            return block_468(state, tracer, fn_state);
        };
    }
    fn block_468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_468_0: read-var CRm:u8
        let s_468_0: u8 = fn_state.CRm;
        // D s_468_1: cast zx s_468_0 -> bv
        let s_468_1: Bits = Bits::new(s_468_0 as u128, 4u16);
        // C s_468_2: const #14u : u8
        let s_468_2: u8 = 14;
        // C s_468_3: cast zx s_468_2 -> bv
        let s_468_3: Bits = Bits::new(s_468_2 as u128, 4u16);
        // D s_468_4: cmp-eq s_468_1 s_468_3
        let s_468_4: bool = ((s_468_1) == (s_468_3));
        // N s_468_5: branch s_468_4 b5410 b469
        if s_468_4 {
            return block_5410(state, tracer, fn_state);
        } else {
            return block_469(state, tracer, fn_state);
        };
    }
    fn block_469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_469_0: const #0u : u8
        let s_469_0: bool = false;
        // D s_469_1: write-var gs#117756 <= s_469_0
        fn_state.gs_117756 = s_469_0;
        // N s_469_2: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_470_0: read-var gs#117756:u8
        let s_470_0: bool = fn_state.gs_117756;
        // N s_470_1: branch s_470_0 b5409 b471
        if s_470_0 {
            return block_5409(state, tracer, fn_state);
        } else {
            return block_471(state, tracer, fn_state);
        };
    }
    fn block_471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_471_0: const #0u : u8
        let s_471_0: bool = false;
        // D s_471_1: write-var gs#117757 <= s_471_0
        fn_state.gs_117757 = s_471_0;
        // N s_471_2: jump b472
        return block_472(state, tracer, fn_state);
    }
    fn block_472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_472_0: read-var gs#117757:u8
        let s_472_0: bool = fn_state.gs_117757;
        // N s_472_1: branch s_472_0 b5408 b473
        if s_472_0 {
            return block_5408(state, tracer, fn_state);
        } else {
            return block_473(state, tracer, fn_state);
        };
    }
    fn block_473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_473_0: const #0u : u8
        let s_473_0: bool = false;
        // D s_473_1: write-var gs#117758 <= s_473_0
        fn_state.gs_117758 = s_473_0;
        // N s_473_2: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_474_0: read-var gs#117758:u8
        let s_474_0: bool = fn_state.gs_117758;
        // N s_474_1: branch s_474_0 b5407 b475
        if s_474_0 {
            return block_5407(state, tracer, fn_state);
        } else {
            return block_475(state, tracer, fn_state);
        };
    }
    fn block_475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_475_0: const #0u : u8
        let s_475_0: bool = false;
        // D s_475_1: write-var gs#117759 <= s_475_0
        fn_state.gs_117759 = s_475_0;
        // N s_475_2: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_476_0: read-var gs#117759:u8
        let s_476_0: bool = fn_state.gs_117759;
        // N s_476_1: branch s_476_0 b5406 b477
        if s_476_0 {
            return block_5406(state, tracer, fn_state);
        } else {
            return block_477(state, tracer, fn_state);
        };
    }
    fn block_477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_477_0: read-var CRm:u8
        let s_477_0: u8 = fn_state.CRm;
        // D s_477_1: cast zx s_477_0 -> bv
        let s_477_1: Bits = Bits::new(s_477_0 as u128, 4u16);
        // C s_477_2: const #13u : u8
        let s_477_2: u8 = 13;
        // C s_477_3: cast zx s_477_2 -> bv
        let s_477_3: Bits = Bits::new(s_477_2 as u128, 4u16);
        // D s_477_4: cmp-eq s_477_1 s_477_3
        let s_477_4: bool = ((s_477_1) == (s_477_3));
        // N s_477_5: branch s_477_4 b5405 b478
        if s_477_4 {
            return block_5405(state, tracer, fn_state);
        } else {
            return block_478(state, tracer, fn_state);
        };
    }
    fn block_478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_478_0: const #0u : u8
        let s_478_0: bool = false;
        // D s_478_1: write-var gs#117760 <= s_478_0
        fn_state.gs_117760 = s_478_0;
        // N s_478_2: jump b479
        return block_479(state, tracer, fn_state);
    }
    fn block_479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_479_0: read-var gs#117760:u8
        let s_479_0: bool = fn_state.gs_117760;
        // N s_479_1: branch s_479_0 b5404 b480
        if s_479_0 {
            return block_5404(state, tracer, fn_state);
        } else {
            return block_480(state, tracer, fn_state);
        };
    }
    fn block_480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_480_0: const #0u : u8
        let s_480_0: bool = false;
        // D s_480_1: write-var gs#117761 <= s_480_0
        fn_state.gs_117761 = s_480_0;
        // N s_480_2: jump b481
        return block_481(state, tracer, fn_state);
    }
    fn block_481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_481_0: read-var gs#117761:u8
        let s_481_0: bool = fn_state.gs_117761;
        // N s_481_1: branch s_481_0 b5403 b482
        if s_481_0 {
            return block_5403(state, tracer, fn_state);
        } else {
            return block_482(state, tracer, fn_state);
        };
    }
    fn block_482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_482_0: const #0u : u8
        let s_482_0: bool = false;
        // D s_482_1: write-var gs#117762 <= s_482_0
        fn_state.gs_117762 = s_482_0;
        // N s_482_2: jump b483
        return block_483(state, tracer, fn_state);
    }
    fn block_483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_483_0: read-var gs#117762:u8
        let s_483_0: bool = fn_state.gs_117762;
        // N s_483_1: branch s_483_0 b5402 b484
        if s_483_0 {
            return block_5402(state, tracer, fn_state);
        } else {
            return block_484(state, tracer, fn_state);
        };
    }
    fn block_484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_484_0: const #0u : u8
        let s_484_0: bool = false;
        // D s_484_1: write-var gs#117763 <= s_484_0
        fn_state.gs_117763 = s_484_0;
        // N s_484_2: jump b485
        return block_485(state, tracer, fn_state);
    }
    fn block_485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_485_0: read-var gs#117763:u8
        let s_485_0: bool = fn_state.gs_117763;
        // N s_485_1: branch s_485_0 b5401 b486
        if s_485_0 {
            return block_5401(state, tracer, fn_state);
        } else {
            return block_486(state, tracer, fn_state);
        };
    }
    fn block_486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_486_0: read-var CRm:u8
        let s_486_0: u8 = fn_state.CRm;
        // D s_486_1: cast zx s_486_0 -> bv
        let s_486_1: Bits = Bits::new(s_486_0 as u128, 4u16);
        // C s_486_2: const #12u : u8
        let s_486_2: u8 = 12;
        // C s_486_3: cast zx s_486_2 -> bv
        let s_486_3: Bits = Bits::new(s_486_2 as u128, 4u16);
        // D s_486_4: cmp-eq s_486_1 s_486_3
        let s_486_4: bool = ((s_486_1) == (s_486_3));
        // N s_486_5: branch s_486_4 b5400 b487
        if s_486_4 {
            return block_5400(state, tracer, fn_state);
        } else {
            return block_487(state, tracer, fn_state);
        };
    }
    fn block_487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_487_0: const #0u : u8
        let s_487_0: bool = false;
        // D s_487_1: write-var gs#117764 <= s_487_0
        fn_state.gs_117764 = s_487_0;
        // N s_487_2: jump b488
        return block_488(state, tracer, fn_state);
    }
    fn block_488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_488_0: read-var gs#117764:u8
        let s_488_0: bool = fn_state.gs_117764;
        // N s_488_1: branch s_488_0 b5399 b489
        if s_488_0 {
            return block_5399(state, tracer, fn_state);
        } else {
            return block_489(state, tracer, fn_state);
        };
    }
    fn block_489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_489_0: const #0u : u8
        let s_489_0: bool = false;
        // D s_489_1: write-var gs#117765 <= s_489_0
        fn_state.gs_117765 = s_489_0;
        // N s_489_2: jump b490
        return block_490(state, tracer, fn_state);
    }
    fn block_490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_490_0: read-var gs#117765:u8
        let s_490_0: bool = fn_state.gs_117765;
        // N s_490_1: branch s_490_0 b5398 b491
        if s_490_0 {
            return block_5398(state, tracer, fn_state);
        } else {
            return block_491(state, tracer, fn_state);
        };
    }
    fn block_491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_491_0: const #0u : u8
        let s_491_0: bool = false;
        // D s_491_1: write-var gs#117766 <= s_491_0
        fn_state.gs_117766 = s_491_0;
        // N s_491_2: jump b492
        return block_492(state, tracer, fn_state);
    }
    fn block_492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_492_0: read-var gs#117766:u8
        let s_492_0: bool = fn_state.gs_117766;
        // N s_492_1: branch s_492_0 b5397 b493
        if s_492_0 {
            return block_5397(state, tracer, fn_state);
        } else {
            return block_493(state, tracer, fn_state);
        };
    }
    fn block_493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_493_0: const #0u : u8
        let s_493_0: bool = false;
        // D s_493_1: write-var gs#117767 <= s_493_0
        fn_state.gs_117767 = s_493_0;
        // N s_493_2: jump b494
        return block_494(state, tracer, fn_state);
    }
    fn block_494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_494_0: read-var gs#117767:u8
        let s_494_0: bool = fn_state.gs_117767;
        // N s_494_1: branch s_494_0 b5396 b495
        if s_494_0 {
            return block_5396(state, tracer, fn_state);
        } else {
            return block_495(state, tracer, fn_state);
        };
    }
    fn block_495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_495_0: read-var CRm:u8
        let s_495_0: u8 = fn_state.CRm;
        // D s_495_1: cast zx s_495_0 -> bv
        let s_495_1: Bits = Bits::new(s_495_0 as u128, 4u16);
        // C s_495_2: const #11u : u8
        let s_495_2: u8 = 11;
        // C s_495_3: cast zx s_495_2 -> bv
        let s_495_3: Bits = Bits::new(s_495_2 as u128, 4u16);
        // D s_495_4: cmp-eq s_495_1 s_495_3
        let s_495_4: bool = ((s_495_1) == (s_495_3));
        // N s_495_5: branch s_495_4 b5395 b496
        if s_495_4 {
            return block_5395(state, tracer, fn_state);
        } else {
            return block_496(state, tracer, fn_state);
        };
    }
    fn block_496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_496_0: const #0u : u8
        let s_496_0: bool = false;
        // D s_496_1: write-var gs#117768 <= s_496_0
        fn_state.gs_117768 = s_496_0;
        // N s_496_2: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_497_0: read-var gs#117768:u8
        let s_497_0: bool = fn_state.gs_117768;
        // N s_497_1: branch s_497_0 b5394 b498
        if s_497_0 {
            return block_5394(state, tracer, fn_state);
        } else {
            return block_498(state, tracer, fn_state);
        };
    }
    fn block_498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_498_0: const #0u : u8
        let s_498_0: bool = false;
        // D s_498_1: write-var gs#117769 <= s_498_0
        fn_state.gs_117769 = s_498_0;
        // N s_498_2: jump b499
        return block_499(state, tracer, fn_state);
    }
    fn block_499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_499_0: read-var gs#117769:u8
        let s_499_0: bool = fn_state.gs_117769;
        // N s_499_1: branch s_499_0 b5393 b500
        if s_499_0 {
            return block_5393(state, tracer, fn_state);
        } else {
            return block_500(state, tracer, fn_state);
        };
    }
    fn block_500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_500_0: const #0u : u8
        let s_500_0: bool = false;
        // D s_500_1: write-var gs#117770 <= s_500_0
        fn_state.gs_117770 = s_500_0;
        // N s_500_2: jump b501
        return block_501(state, tracer, fn_state);
    }
    fn block_501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_501_0: read-var gs#117770:u8
        let s_501_0: bool = fn_state.gs_117770;
        // N s_501_1: branch s_501_0 b5392 b502
        if s_501_0 {
            return block_5392(state, tracer, fn_state);
        } else {
            return block_502(state, tracer, fn_state);
        };
    }
    fn block_502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_502_0: const #0u : u8
        let s_502_0: bool = false;
        // D s_502_1: write-var gs#117771 <= s_502_0
        fn_state.gs_117771 = s_502_0;
        // N s_502_2: jump b503
        return block_503(state, tracer, fn_state);
    }
    fn block_503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_503_0: read-var gs#117771:u8
        let s_503_0: bool = fn_state.gs_117771;
        // N s_503_1: branch s_503_0 b5391 b504
        if s_503_0 {
            return block_5391(state, tracer, fn_state);
        } else {
            return block_504(state, tracer, fn_state);
        };
    }
    fn block_504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_504_0: read-var CRm:u8
        let s_504_0: u8 = fn_state.CRm;
        // D s_504_1: cast zx s_504_0 -> bv
        let s_504_1: Bits = Bits::new(s_504_0 as u128, 4u16);
        // C s_504_2: const #10u : u8
        let s_504_2: u8 = 10;
        // C s_504_3: cast zx s_504_2 -> bv
        let s_504_3: Bits = Bits::new(s_504_2 as u128, 4u16);
        // D s_504_4: cmp-eq s_504_1 s_504_3
        let s_504_4: bool = ((s_504_1) == (s_504_3));
        // N s_504_5: branch s_504_4 b5390 b505
        if s_504_4 {
            return block_5390(state, tracer, fn_state);
        } else {
            return block_505(state, tracer, fn_state);
        };
    }
    fn block_505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_505_0: const #0u : u8
        let s_505_0: bool = false;
        // D s_505_1: write-var gs#117772 <= s_505_0
        fn_state.gs_117772 = s_505_0;
        // N s_505_2: jump b506
        return block_506(state, tracer, fn_state);
    }
    fn block_506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_506_0: read-var gs#117772:u8
        let s_506_0: bool = fn_state.gs_117772;
        // N s_506_1: branch s_506_0 b5389 b507
        if s_506_0 {
            return block_5389(state, tracer, fn_state);
        } else {
            return block_507(state, tracer, fn_state);
        };
    }
    fn block_507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_507_0: const #0u : u8
        let s_507_0: bool = false;
        // D s_507_1: write-var gs#117773 <= s_507_0
        fn_state.gs_117773 = s_507_0;
        // N s_507_2: jump b508
        return block_508(state, tracer, fn_state);
    }
    fn block_508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_508_0: read-var gs#117773:u8
        let s_508_0: bool = fn_state.gs_117773;
        // N s_508_1: branch s_508_0 b5388 b509
        if s_508_0 {
            return block_5388(state, tracer, fn_state);
        } else {
            return block_509(state, tracer, fn_state);
        };
    }
    fn block_509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_509_0: const #0u : u8
        let s_509_0: bool = false;
        // D s_509_1: write-var gs#117774 <= s_509_0
        fn_state.gs_117774 = s_509_0;
        // N s_509_2: jump b510
        return block_510(state, tracer, fn_state);
    }
    fn block_510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_510_0: read-var gs#117774:u8
        let s_510_0: bool = fn_state.gs_117774;
        // N s_510_1: branch s_510_0 b5387 b511
        if s_510_0 {
            return block_5387(state, tracer, fn_state);
        } else {
            return block_511(state, tracer, fn_state);
        };
    }
    fn block_511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_511_0: const #0u : u8
        let s_511_0: bool = false;
        // D s_511_1: write-var gs#117775 <= s_511_0
        fn_state.gs_117775 = s_511_0;
        // N s_511_2: jump b512
        return block_512(state, tracer, fn_state);
    }
    fn block_512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_512_0: read-var gs#117775:u8
        let s_512_0: bool = fn_state.gs_117775;
        // N s_512_1: branch s_512_0 b5386 b513
        if s_512_0 {
            return block_5386(state, tracer, fn_state);
        } else {
            return block_513(state, tracer, fn_state);
        };
    }
    fn block_513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_513_0: read-var CRm:u8
        let s_513_0: u8 = fn_state.CRm;
        // D s_513_1: cast zx s_513_0 -> bv
        let s_513_1: Bits = Bits::new(s_513_0 as u128, 4u16);
        // C s_513_2: const #9u : u8
        let s_513_2: u8 = 9;
        // C s_513_3: cast zx s_513_2 -> bv
        let s_513_3: Bits = Bits::new(s_513_2 as u128, 4u16);
        // D s_513_4: cmp-eq s_513_1 s_513_3
        let s_513_4: bool = ((s_513_1) == (s_513_3));
        // N s_513_5: branch s_513_4 b5385 b514
        if s_513_4 {
            return block_5385(state, tracer, fn_state);
        } else {
            return block_514(state, tracer, fn_state);
        };
    }
    fn block_514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_514_0: const #0u : u8
        let s_514_0: bool = false;
        // D s_514_1: write-var gs#117776 <= s_514_0
        fn_state.gs_117776 = s_514_0;
        // N s_514_2: jump b515
        return block_515(state, tracer, fn_state);
    }
    fn block_515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_515_0: read-var gs#117776:u8
        let s_515_0: bool = fn_state.gs_117776;
        // N s_515_1: branch s_515_0 b5384 b516
        if s_515_0 {
            return block_5384(state, tracer, fn_state);
        } else {
            return block_516(state, tracer, fn_state);
        };
    }
    fn block_516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_516_0: const #0u : u8
        let s_516_0: bool = false;
        // D s_516_1: write-var gs#117777 <= s_516_0
        fn_state.gs_117777 = s_516_0;
        // N s_516_2: jump b517
        return block_517(state, tracer, fn_state);
    }
    fn block_517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_517_0: read-var gs#117777:u8
        let s_517_0: bool = fn_state.gs_117777;
        // N s_517_1: branch s_517_0 b5383 b518
        if s_517_0 {
            return block_5383(state, tracer, fn_state);
        } else {
            return block_518(state, tracer, fn_state);
        };
    }
    fn block_518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_518_0: const #0u : u8
        let s_518_0: bool = false;
        // D s_518_1: write-var gs#117778 <= s_518_0
        fn_state.gs_117778 = s_518_0;
        // N s_518_2: jump b519
        return block_519(state, tracer, fn_state);
    }
    fn block_519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_519_0: read-var gs#117778:u8
        let s_519_0: bool = fn_state.gs_117778;
        // N s_519_1: branch s_519_0 b5382 b520
        if s_519_0 {
            return block_5382(state, tracer, fn_state);
        } else {
            return block_520(state, tracer, fn_state);
        };
    }
    fn block_520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_520_0: const #0u : u8
        let s_520_0: bool = false;
        // D s_520_1: write-var gs#117779 <= s_520_0
        fn_state.gs_117779 = s_520_0;
        // N s_520_2: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_521_0: read-var gs#117779:u8
        let s_521_0: bool = fn_state.gs_117779;
        // N s_521_1: branch s_521_0 b5381 b522
        if s_521_0 {
            return block_5381(state, tracer, fn_state);
        } else {
            return block_522(state, tracer, fn_state);
        };
    }
    fn block_522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_522_0: read-var CRm:u8
        let s_522_0: u8 = fn_state.CRm;
        // D s_522_1: cast zx s_522_0 -> bv
        let s_522_1: Bits = Bits::new(s_522_0 as u128, 4u16);
        // C s_522_2: const #8u : u8
        let s_522_2: u8 = 8;
        // C s_522_3: cast zx s_522_2 -> bv
        let s_522_3: Bits = Bits::new(s_522_2 as u128, 4u16);
        // D s_522_4: cmp-eq s_522_1 s_522_3
        let s_522_4: bool = ((s_522_1) == (s_522_3));
        // N s_522_5: branch s_522_4 b5380 b523
        if s_522_4 {
            return block_5380(state, tracer, fn_state);
        } else {
            return block_523(state, tracer, fn_state);
        };
    }
    fn block_523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_523_0: const #0u : u8
        let s_523_0: bool = false;
        // D s_523_1: write-var gs#117780 <= s_523_0
        fn_state.gs_117780 = s_523_0;
        // N s_523_2: jump b524
        return block_524(state, tracer, fn_state);
    }
    fn block_524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_524_0: read-var gs#117780:u8
        let s_524_0: bool = fn_state.gs_117780;
        // N s_524_1: branch s_524_0 b5379 b525
        if s_524_0 {
            return block_5379(state, tracer, fn_state);
        } else {
            return block_525(state, tracer, fn_state);
        };
    }
    fn block_525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_525_0: const #0u : u8
        let s_525_0: bool = false;
        // D s_525_1: write-var gs#117781 <= s_525_0
        fn_state.gs_117781 = s_525_0;
        // N s_525_2: jump b526
        return block_526(state, tracer, fn_state);
    }
    fn block_526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_526_0: read-var gs#117781:u8
        let s_526_0: bool = fn_state.gs_117781;
        // N s_526_1: branch s_526_0 b5378 b527
        if s_526_0 {
            return block_5378(state, tracer, fn_state);
        } else {
            return block_527(state, tracer, fn_state);
        };
    }
    fn block_527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_527_0: const #0u : u8
        let s_527_0: bool = false;
        // D s_527_1: write-var gs#117782 <= s_527_0
        fn_state.gs_117782 = s_527_0;
        // N s_527_2: jump b528
        return block_528(state, tracer, fn_state);
    }
    fn block_528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_528_0: read-var gs#117782:u8
        let s_528_0: bool = fn_state.gs_117782;
        // N s_528_1: branch s_528_0 b5377 b529
        if s_528_0 {
            return block_5377(state, tracer, fn_state);
        } else {
            return block_529(state, tracer, fn_state);
        };
    }
    fn block_529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_529_0: const #0u : u8
        let s_529_0: bool = false;
        // D s_529_1: write-var gs#117783 <= s_529_0
        fn_state.gs_117783 = s_529_0;
        // N s_529_2: jump b530
        return block_530(state, tracer, fn_state);
    }
    fn block_530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_530_0: read-var gs#117783:u8
        let s_530_0: bool = fn_state.gs_117783;
        // N s_530_1: branch s_530_0 b5376 b531
        if s_530_0 {
            return block_5376(state, tracer, fn_state);
        } else {
            return block_531(state, tracer, fn_state);
        };
    }
    fn block_531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_531_0: read-var CRm:u8
        let s_531_0: u8 = fn_state.CRm;
        // D s_531_1: cast zx s_531_0 -> bv
        let s_531_1: Bits = Bits::new(s_531_0 as u128, 4u16);
        // C s_531_2: const #7u : u8
        let s_531_2: u8 = 7;
        // C s_531_3: cast zx s_531_2 -> bv
        let s_531_3: Bits = Bits::new(s_531_2 as u128, 4u16);
        // D s_531_4: cmp-eq s_531_1 s_531_3
        let s_531_4: bool = ((s_531_1) == (s_531_3));
        // N s_531_5: branch s_531_4 b5375 b532
        if s_531_4 {
            return block_5375(state, tracer, fn_state);
        } else {
            return block_532(state, tracer, fn_state);
        };
    }
    fn block_532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_532_0: const #0u : u8
        let s_532_0: bool = false;
        // D s_532_1: write-var gs#117784 <= s_532_0
        fn_state.gs_117784 = s_532_0;
        // N s_532_2: jump b533
        return block_533(state, tracer, fn_state);
    }
    fn block_533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_533_0: read-var gs#117784:u8
        let s_533_0: bool = fn_state.gs_117784;
        // N s_533_1: branch s_533_0 b5374 b534
        if s_533_0 {
            return block_5374(state, tracer, fn_state);
        } else {
            return block_534(state, tracer, fn_state);
        };
    }
    fn block_534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_534_0: const #0u : u8
        let s_534_0: bool = false;
        // D s_534_1: write-var gs#117785 <= s_534_0
        fn_state.gs_117785 = s_534_0;
        // N s_534_2: jump b535
        return block_535(state, tracer, fn_state);
    }
    fn block_535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_535_0: read-var gs#117785:u8
        let s_535_0: bool = fn_state.gs_117785;
        // N s_535_1: branch s_535_0 b5373 b536
        if s_535_0 {
            return block_5373(state, tracer, fn_state);
        } else {
            return block_536(state, tracer, fn_state);
        };
    }
    fn block_536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_536_0: const #0u : u8
        let s_536_0: bool = false;
        // D s_536_1: write-var gs#117786 <= s_536_0
        fn_state.gs_117786 = s_536_0;
        // N s_536_2: jump b537
        return block_537(state, tracer, fn_state);
    }
    fn block_537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_537_0: read-var gs#117786:u8
        let s_537_0: bool = fn_state.gs_117786;
        // N s_537_1: branch s_537_0 b5372 b538
        if s_537_0 {
            return block_5372(state, tracer, fn_state);
        } else {
            return block_538(state, tracer, fn_state);
        };
    }
    fn block_538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_538_0: const #0u : u8
        let s_538_0: bool = false;
        // D s_538_1: write-var gs#117787 <= s_538_0
        fn_state.gs_117787 = s_538_0;
        // N s_538_2: jump b539
        return block_539(state, tracer, fn_state);
    }
    fn block_539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_539_0: read-var gs#117787:u8
        let s_539_0: bool = fn_state.gs_117787;
        // N s_539_1: branch s_539_0 b5371 b540
        if s_539_0 {
            return block_5371(state, tracer, fn_state);
        } else {
            return block_540(state, tracer, fn_state);
        };
    }
    fn block_540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_540_0: read-var CRm:u8
        let s_540_0: u8 = fn_state.CRm;
        // D s_540_1: cast zx s_540_0 -> bv
        let s_540_1: Bits = Bits::new(s_540_0 as u128, 4u16);
        // C s_540_2: const #6u : u8
        let s_540_2: u8 = 6;
        // C s_540_3: cast zx s_540_2 -> bv
        let s_540_3: Bits = Bits::new(s_540_2 as u128, 4u16);
        // D s_540_4: cmp-eq s_540_1 s_540_3
        let s_540_4: bool = ((s_540_1) == (s_540_3));
        // N s_540_5: branch s_540_4 b5370 b541
        if s_540_4 {
            return block_5370(state, tracer, fn_state);
        } else {
            return block_541(state, tracer, fn_state);
        };
    }
    fn block_541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_541_0: const #0u : u8
        let s_541_0: bool = false;
        // D s_541_1: write-var gs#117788 <= s_541_0
        fn_state.gs_117788 = s_541_0;
        // N s_541_2: jump b542
        return block_542(state, tracer, fn_state);
    }
    fn block_542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_542_0: read-var gs#117788:u8
        let s_542_0: bool = fn_state.gs_117788;
        // N s_542_1: branch s_542_0 b5369 b543
        if s_542_0 {
            return block_5369(state, tracer, fn_state);
        } else {
            return block_543(state, tracer, fn_state);
        };
    }
    fn block_543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_543_0: const #0u : u8
        let s_543_0: bool = false;
        // D s_543_1: write-var gs#117789 <= s_543_0
        fn_state.gs_117789 = s_543_0;
        // N s_543_2: jump b544
        return block_544(state, tracer, fn_state);
    }
    fn block_544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_544_0: read-var gs#117789:u8
        let s_544_0: bool = fn_state.gs_117789;
        // N s_544_1: branch s_544_0 b5368 b545
        if s_544_0 {
            return block_5368(state, tracer, fn_state);
        } else {
            return block_545(state, tracer, fn_state);
        };
    }
    fn block_545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_545_0: const #0u : u8
        let s_545_0: bool = false;
        // D s_545_1: write-var gs#117790 <= s_545_0
        fn_state.gs_117790 = s_545_0;
        // N s_545_2: jump b546
        return block_546(state, tracer, fn_state);
    }
    fn block_546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_546_0: read-var gs#117790:u8
        let s_546_0: bool = fn_state.gs_117790;
        // N s_546_1: branch s_546_0 b5367 b547
        if s_546_0 {
            return block_5367(state, tracer, fn_state);
        } else {
            return block_547(state, tracer, fn_state);
        };
    }
    fn block_547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_547_0: const #0u : u8
        let s_547_0: bool = false;
        // D s_547_1: write-var gs#117791 <= s_547_0
        fn_state.gs_117791 = s_547_0;
        // N s_547_2: jump b548
        return block_548(state, tracer, fn_state);
    }
    fn block_548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_548_0: read-var gs#117791:u8
        let s_548_0: bool = fn_state.gs_117791;
        // N s_548_1: branch s_548_0 b5366 b549
        if s_548_0 {
            return block_5366(state, tracer, fn_state);
        } else {
            return block_549(state, tracer, fn_state);
        };
    }
    fn block_549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_549_0: read-var CRm:u8
        let s_549_0: u8 = fn_state.CRm;
        // D s_549_1: cast zx s_549_0 -> bv
        let s_549_1: Bits = Bits::new(s_549_0 as u128, 4u16);
        // C s_549_2: const #5u : u8
        let s_549_2: u8 = 5;
        // C s_549_3: cast zx s_549_2 -> bv
        let s_549_3: Bits = Bits::new(s_549_2 as u128, 4u16);
        // D s_549_4: cmp-eq s_549_1 s_549_3
        let s_549_4: bool = ((s_549_1) == (s_549_3));
        // N s_549_5: branch s_549_4 b5365 b550
        if s_549_4 {
            return block_5365(state, tracer, fn_state);
        } else {
            return block_550(state, tracer, fn_state);
        };
    }
    fn block_550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_550_0: const #0u : u8
        let s_550_0: bool = false;
        // D s_550_1: write-var gs#117792 <= s_550_0
        fn_state.gs_117792 = s_550_0;
        // N s_550_2: jump b551
        return block_551(state, tracer, fn_state);
    }
    fn block_551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_551_0: read-var gs#117792:u8
        let s_551_0: bool = fn_state.gs_117792;
        // N s_551_1: branch s_551_0 b5364 b552
        if s_551_0 {
            return block_5364(state, tracer, fn_state);
        } else {
            return block_552(state, tracer, fn_state);
        };
    }
    fn block_552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_552_0: const #0u : u8
        let s_552_0: bool = false;
        // D s_552_1: write-var gs#117793 <= s_552_0
        fn_state.gs_117793 = s_552_0;
        // N s_552_2: jump b553
        return block_553(state, tracer, fn_state);
    }
    fn block_553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_553_0: read-var gs#117793:u8
        let s_553_0: bool = fn_state.gs_117793;
        // N s_553_1: branch s_553_0 b5363 b554
        if s_553_0 {
            return block_5363(state, tracer, fn_state);
        } else {
            return block_554(state, tracer, fn_state);
        };
    }
    fn block_554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_554_0: const #0u : u8
        let s_554_0: bool = false;
        // D s_554_1: write-var gs#117794 <= s_554_0
        fn_state.gs_117794 = s_554_0;
        // N s_554_2: jump b555
        return block_555(state, tracer, fn_state);
    }
    fn block_555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_555_0: read-var gs#117794:u8
        let s_555_0: bool = fn_state.gs_117794;
        // N s_555_1: branch s_555_0 b5362 b556
        if s_555_0 {
            return block_5362(state, tracer, fn_state);
        } else {
            return block_556(state, tracer, fn_state);
        };
    }
    fn block_556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_556_0: const #0u : u8
        let s_556_0: bool = false;
        // D s_556_1: write-var gs#117795 <= s_556_0
        fn_state.gs_117795 = s_556_0;
        // N s_556_2: jump b557
        return block_557(state, tracer, fn_state);
    }
    fn block_557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_557_0: read-var gs#117795:u8
        let s_557_0: bool = fn_state.gs_117795;
        // N s_557_1: branch s_557_0 b5361 b558
        if s_557_0 {
            return block_5361(state, tracer, fn_state);
        } else {
            return block_558(state, tracer, fn_state);
        };
    }
    fn block_558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_558_0: read-var CRm:u8
        let s_558_0: u8 = fn_state.CRm;
        // D s_558_1: cast zx s_558_0 -> bv
        let s_558_1: Bits = Bits::new(s_558_0 as u128, 4u16);
        // C s_558_2: const #4u : u8
        let s_558_2: u8 = 4;
        // C s_558_3: cast zx s_558_2 -> bv
        let s_558_3: Bits = Bits::new(s_558_2 as u128, 4u16);
        // D s_558_4: cmp-eq s_558_1 s_558_3
        let s_558_4: bool = ((s_558_1) == (s_558_3));
        // N s_558_5: branch s_558_4 b5360 b559
        if s_558_4 {
            return block_5360(state, tracer, fn_state);
        } else {
            return block_559(state, tracer, fn_state);
        };
    }
    fn block_559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_559_0: const #0u : u8
        let s_559_0: bool = false;
        // D s_559_1: write-var gs#117796 <= s_559_0
        fn_state.gs_117796 = s_559_0;
        // N s_559_2: jump b560
        return block_560(state, tracer, fn_state);
    }
    fn block_560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_560_0: read-var gs#117796:u8
        let s_560_0: bool = fn_state.gs_117796;
        // N s_560_1: branch s_560_0 b5359 b561
        if s_560_0 {
            return block_5359(state, tracer, fn_state);
        } else {
            return block_561(state, tracer, fn_state);
        };
    }
    fn block_561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_561_0: const #0u : u8
        let s_561_0: bool = false;
        // D s_561_1: write-var gs#117797 <= s_561_0
        fn_state.gs_117797 = s_561_0;
        // N s_561_2: jump b562
        return block_562(state, tracer, fn_state);
    }
    fn block_562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_562_0: read-var gs#117797:u8
        let s_562_0: bool = fn_state.gs_117797;
        // N s_562_1: branch s_562_0 b5358 b563
        if s_562_0 {
            return block_5358(state, tracer, fn_state);
        } else {
            return block_563(state, tracer, fn_state);
        };
    }
    fn block_563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_563_0: const #0u : u8
        let s_563_0: bool = false;
        // D s_563_1: write-var gs#117798 <= s_563_0
        fn_state.gs_117798 = s_563_0;
        // N s_563_2: jump b564
        return block_564(state, tracer, fn_state);
    }
    fn block_564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_564_0: read-var gs#117798:u8
        let s_564_0: bool = fn_state.gs_117798;
        // N s_564_1: branch s_564_0 b5357 b565
        if s_564_0 {
            return block_5357(state, tracer, fn_state);
        } else {
            return block_565(state, tracer, fn_state);
        };
    }
    fn block_565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_565_0: const #0u : u8
        let s_565_0: bool = false;
        // D s_565_1: write-var gs#117799 <= s_565_0
        fn_state.gs_117799 = s_565_0;
        // N s_565_2: jump b566
        return block_566(state, tracer, fn_state);
    }
    fn block_566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_566_0: read-var gs#117799:u8
        let s_566_0: bool = fn_state.gs_117799;
        // N s_566_1: branch s_566_0 b5356 b567
        if s_566_0 {
            return block_5356(state, tracer, fn_state);
        } else {
            return block_567(state, tracer, fn_state);
        };
    }
    fn block_567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_567_0: read-var CRm:u8
        let s_567_0: u8 = fn_state.CRm;
        // D s_567_1: cast zx s_567_0 -> bv
        let s_567_1: Bits = Bits::new(s_567_0 as u128, 4u16);
        // C s_567_2: const #3u : u8
        let s_567_2: u8 = 3;
        // C s_567_3: cast zx s_567_2 -> bv
        let s_567_3: Bits = Bits::new(s_567_2 as u128, 4u16);
        // D s_567_4: cmp-eq s_567_1 s_567_3
        let s_567_4: bool = ((s_567_1) == (s_567_3));
        // N s_567_5: branch s_567_4 b5355 b568
        if s_567_4 {
            return block_5355(state, tracer, fn_state);
        } else {
            return block_568(state, tracer, fn_state);
        };
    }
    fn block_568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_568_0: const #0u : u8
        let s_568_0: bool = false;
        // D s_568_1: write-var gs#117800 <= s_568_0
        fn_state.gs_117800 = s_568_0;
        // N s_568_2: jump b569
        return block_569(state, tracer, fn_state);
    }
    fn block_569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_569_0: read-var gs#117800:u8
        let s_569_0: bool = fn_state.gs_117800;
        // N s_569_1: branch s_569_0 b5354 b570
        if s_569_0 {
            return block_5354(state, tracer, fn_state);
        } else {
            return block_570(state, tracer, fn_state);
        };
    }
    fn block_570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_570_0: const #0u : u8
        let s_570_0: bool = false;
        // D s_570_1: write-var gs#117801 <= s_570_0
        fn_state.gs_117801 = s_570_0;
        // N s_570_2: jump b571
        return block_571(state, tracer, fn_state);
    }
    fn block_571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_571_0: read-var gs#117801:u8
        let s_571_0: bool = fn_state.gs_117801;
        // N s_571_1: branch s_571_0 b5353 b572
        if s_571_0 {
            return block_5353(state, tracer, fn_state);
        } else {
            return block_572(state, tracer, fn_state);
        };
    }
    fn block_572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_572_0: const #0u : u8
        let s_572_0: bool = false;
        // D s_572_1: write-var gs#117802 <= s_572_0
        fn_state.gs_117802 = s_572_0;
        // N s_572_2: jump b573
        return block_573(state, tracer, fn_state);
    }
    fn block_573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_573_0: read-var gs#117802:u8
        let s_573_0: bool = fn_state.gs_117802;
        // N s_573_1: branch s_573_0 b5352 b574
        if s_573_0 {
            return block_5352(state, tracer, fn_state);
        } else {
            return block_574(state, tracer, fn_state);
        };
    }
    fn block_574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_574_0: const #0u : u8
        let s_574_0: bool = false;
        // D s_574_1: write-var gs#117803 <= s_574_0
        fn_state.gs_117803 = s_574_0;
        // N s_574_2: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_575_0: read-var gs#117803:u8
        let s_575_0: bool = fn_state.gs_117803;
        // N s_575_1: branch s_575_0 b5351 b576
        if s_575_0 {
            return block_5351(state, tracer, fn_state);
        } else {
            return block_576(state, tracer, fn_state);
        };
    }
    fn block_576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_576_0: read-var CRm:u8
        let s_576_0: u8 = fn_state.CRm;
        // D s_576_1: cast zx s_576_0 -> bv
        let s_576_1: Bits = Bits::new(s_576_0 as u128, 4u16);
        // C s_576_2: const #2u : u8
        let s_576_2: u8 = 2;
        // C s_576_3: cast zx s_576_2 -> bv
        let s_576_3: Bits = Bits::new(s_576_2 as u128, 4u16);
        // D s_576_4: cmp-eq s_576_1 s_576_3
        let s_576_4: bool = ((s_576_1) == (s_576_3));
        // N s_576_5: branch s_576_4 b5350 b577
        if s_576_4 {
            return block_5350(state, tracer, fn_state);
        } else {
            return block_577(state, tracer, fn_state);
        };
    }
    fn block_577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_577_0: const #0u : u8
        let s_577_0: bool = false;
        // D s_577_1: write-var gs#117804 <= s_577_0
        fn_state.gs_117804 = s_577_0;
        // N s_577_2: jump b578
        return block_578(state, tracer, fn_state);
    }
    fn block_578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_578_0: read-var gs#117804:u8
        let s_578_0: bool = fn_state.gs_117804;
        // N s_578_1: branch s_578_0 b5349 b579
        if s_578_0 {
            return block_5349(state, tracer, fn_state);
        } else {
            return block_579(state, tracer, fn_state);
        };
    }
    fn block_579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_579_0: const #0u : u8
        let s_579_0: bool = false;
        // D s_579_1: write-var gs#117805 <= s_579_0
        fn_state.gs_117805 = s_579_0;
        // N s_579_2: jump b580
        return block_580(state, tracer, fn_state);
    }
    fn block_580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_580_0: read-var gs#117805:u8
        let s_580_0: bool = fn_state.gs_117805;
        // N s_580_1: branch s_580_0 b5348 b581
        if s_580_0 {
            return block_5348(state, tracer, fn_state);
        } else {
            return block_581(state, tracer, fn_state);
        };
    }
    fn block_581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_581_0: const #0u : u8
        let s_581_0: bool = false;
        // D s_581_1: write-var gs#117806 <= s_581_0
        fn_state.gs_117806 = s_581_0;
        // N s_581_2: jump b582
        return block_582(state, tracer, fn_state);
    }
    fn block_582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_582_0: read-var gs#117806:u8
        let s_582_0: bool = fn_state.gs_117806;
        // N s_582_1: branch s_582_0 b5347 b583
        if s_582_0 {
            return block_5347(state, tracer, fn_state);
        } else {
            return block_583(state, tracer, fn_state);
        };
    }
    fn block_583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_583_0: const #0u : u8
        let s_583_0: bool = false;
        // D s_583_1: write-var gs#117807 <= s_583_0
        fn_state.gs_117807 = s_583_0;
        // N s_583_2: jump b584
        return block_584(state, tracer, fn_state);
    }
    fn block_584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_584_0: read-var gs#117807:u8
        let s_584_0: bool = fn_state.gs_117807;
        // N s_584_1: branch s_584_0 b5346 b585
        if s_584_0 {
            return block_5346(state, tracer, fn_state);
        } else {
            return block_585(state, tracer, fn_state);
        };
    }
    fn block_585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_585_0: read-var CRm:u8
        let s_585_0: u8 = fn_state.CRm;
        // D s_585_1: cast zx s_585_0 -> bv
        let s_585_1: Bits = Bits::new(s_585_0 as u128, 4u16);
        // C s_585_2: const #1u : u8
        let s_585_2: u8 = 1;
        // C s_585_3: cast zx s_585_2 -> bv
        let s_585_3: Bits = Bits::new(s_585_2 as u128, 4u16);
        // D s_585_4: cmp-eq s_585_1 s_585_3
        let s_585_4: bool = ((s_585_1) == (s_585_3));
        // N s_585_5: branch s_585_4 b5345 b586
        if s_585_4 {
            return block_5345(state, tracer, fn_state);
        } else {
            return block_586(state, tracer, fn_state);
        };
    }
    fn block_586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_586_0: const #0u : u8
        let s_586_0: bool = false;
        // D s_586_1: write-var gs#117808 <= s_586_0
        fn_state.gs_117808 = s_586_0;
        // N s_586_2: jump b587
        return block_587(state, tracer, fn_state);
    }
    fn block_587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_587_0: read-var gs#117808:u8
        let s_587_0: bool = fn_state.gs_117808;
        // N s_587_1: branch s_587_0 b5344 b588
        if s_587_0 {
            return block_5344(state, tracer, fn_state);
        } else {
            return block_588(state, tracer, fn_state);
        };
    }
    fn block_588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_588_0: const #0u : u8
        let s_588_0: bool = false;
        // D s_588_1: write-var gs#117809 <= s_588_0
        fn_state.gs_117809 = s_588_0;
        // N s_588_2: jump b589
        return block_589(state, tracer, fn_state);
    }
    fn block_589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_589_0: read-var gs#117809:u8
        let s_589_0: bool = fn_state.gs_117809;
        // N s_589_1: branch s_589_0 b5343 b590
        if s_589_0 {
            return block_5343(state, tracer, fn_state);
        } else {
            return block_590(state, tracer, fn_state);
        };
    }
    fn block_590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_590_0: const #0u : u8
        let s_590_0: bool = false;
        // D s_590_1: write-var gs#117810 <= s_590_0
        fn_state.gs_117810 = s_590_0;
        // N s_590_2: jump b591
        return block_591(state, tracer, fn_state);
    }
    fn block_591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_591_0: read-var gs#117810:u8
        let s_591_0: bool = fn_state.gs_117810;
        // N s_591_1: branch s_591_0 b5342 b592
        if s_591_0 {
            return block_5342(state, tracer, fn_state);
        } else {
            return block_592(state, tracer, fn_state);
        };
    }
    fn block_592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_592_0: const #0u : u8
        let s_592_0: bool = false;
        // D s_592_1: write-var gs#117811 <= s_592_0
        fn_state.gs_117811 = s_592_0;
        // N s_592_2: jump b593
        return block_593(state, tracer, fn_state);
    }
    fn block_593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_593_0: read-var gs#117811:u8
        let s_593_0: bool = fn_state.gs_117811;
        // N s_593_1: branch s_593_0 b5341 b594
        if s_593_0 {
            return block_5341(state, tracer, fn_state);
        } else {
            return block_594(state, tracer, fn_state);
        };
    }
    fn block_594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_594_0: read-var CRm:u8
        let s_594_0: u8 = fn_state.CRm;
        // D s_594_1: cast zx s_594_0 -> bv
        let s_594_1: Bits = Bits::new(s_594_0 as u128, 4u16);
        // C s_594_2: const #0u : u8
        let s_594_2: u8 = 0;
        // C s_594_3: cast zx s_594_2 -> bv
        let s_594_3: Bits = Bits::new(s_594_2 as u128, 4u16);
        // D s_594_4: cmp-eq s_594_1 s_594_3
        let s_594_4: bool = ((s_594_1) == (s_594_3));
        // N s_594_5: branch s_594_4 b5340 b595
        if s_594_4 {
            return block_5340(state, tracer, fn_state);
        } else {
            return block_595(state, tracer, fn_state);
        };
    }
    fn block_595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_595_0: const #0u : u8
        let s_595_0: bool = false;
        // D s_595_1: write-var gs#117812 <= s_595_0
        fn_state.gs_117812 = s_595_0;
        // N s_595_2: jump b596
        return block_596(state, tracer, fn_state);
    }
    fn block_596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_596_0: read-var gs#117812:u8
        let s_596_0: bool = fn_state.gs_117812;
        // N s_596_1: branch s_596_0 b5339 b597
        if s_596_0 {
            return block_5339(state, tracer, fn_state);
        } else {
            return block_597(state, tracer, fn_state);
        };
    }
    fn block_597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_597_0: const #0u : u8
        let s_597_0: bool = false;
        // D s_597_1: write-var gs#117813 <= s_597_0
        fn_state.gs_117813 = s_597_0;
        // N s_597_2: jump b598
        return block_598(state, tracer, fn_state);
    }
    fn block_598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_598_0: read-var gs#117813:u8
        let s_598_0: bool = fn_state.gs_117813;
        // N s_598_1: branch s_598_0 b5338 b599
        if s_598_0 {
            return block_5338(state, tracer, fn_state);
        } else {
            return block_599(state, tracer, fn_state);
        };
    }
    fn block_599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_599_0: const #0u : u8
        let s_599_0: bool = false;
        // D s_599_1: write-var gs#117814 <= s_599_0
        fn_state.gs_117814 = s_599_0;
        // N s_599_2: jump b600
        return block_600(state, tracer, fn_state);
    }
    fn block_600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_600_0: read-var gs#117814:u8
        let s_600_0: bool = fn_state.gs_117814;
        // N s_600_1: branch s_600_0 b5337 b601
        if s_600_0 {
            return block_5337(state, tracer, fn_state);
        } else {
            return block_601(state, tracer, fn_state);
        };
    }
    fn block_601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_601_0: const #0u : u8
        let s_601_0: bool = false;
        // D s_601_1: write-var gs#117815 <= s_601_0
        fn_state.gs_117815 = s_601_0;
        // N s_601_2: jump b602
        return block_602(state, tracer, fn_state);
    }
    fn block_602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_602_0: read-var gs#117815:u8
        let s_602_0: bool = fn_state.gs_117815;
        // N s_602_1: branch s_602_0 b5336 b603
        if s_602_0 {
            return block_5336(state, tracer, fn_state);
        } else {
            return block_603(state, tracer, fn_state);
        };
    }
    fn block_603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_603_0: read-var CRm:u8
        let s_603_0: u8 = fn_state.CRm;
        // D s_603_1: cast zx s_603_0 -> bv
        let s_603_1: Bits = Bits::new(s_603_0 as u128, 4u16);
        // C s_603_2: const #2u : u8
        let s_603_2: u8 = 2;
        // C s_603_3: cast zx s_603_2 -> bv
        let s_603_3: Bits = Bits::new(s_603_2 as u128, 4u16);
        // D s_603_4: cmp-eq s_603_1 s_603_3
        let s_603_4: bool = ((s_603_1) == (s_603_3));
        // N s_603_5: branch s_603_4 b5335 b604
        if s_603_4 {
            return block_5335(state, tracer, fn_state);
        } else {
            return block_604(state, tracer, fn_state);
        };
    }
    fn block_604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_604_0: const #0u : u8
        let s_604_0: bool = false;
        // D s_604_1: write-var gs#117816 <= s_604_0
        fn_state.gs_117816 = s_604_0;
        // N s_604_2: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_605_0: read-var gs#117816:u8
        let s_605_0: bool = fn_state.gs_117816;
        // N s_605_1: branch s_605_0 b5334 b606
        if s_605_0 {
            return block_5334(state, tracer, fn_state);
        } else {
            return block_606(state, tracer, fn_state);
        };
    }
    fn block_606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_606_0: const #0u : u8
        let s_606_0: bool = false;
        // D s_606_1: write-var gs#117817 <= s_606_0
        fn_state.gs_117817 = s_606_0;
        // N s_606_2: jump b607
        return block_607(state, tracer, fn_state);
    }
    fn block_607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_607_0: read-var gs#117817:u8
        let s_607_0: bool = fn_state.gs_117817;
        // N s_607_1: branch s_607_0 b5333 b608
        if s_607_0 {
            return block_5333(state, tracer, fn_state);
        } else {
            return block_608(state, tracer, fn_state);
        };
    }
    fn block_608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_608_0: const #0u : u8
        let s_608_0: bool = false;
        // D s_608_1: write-var gs#117818 <= s_608_0
        fn_state.gs_117818 = s_608_0;
        // N s_608_2: jump b609
        return block_609(state, tracer, fn_state);
    }
    fn block_609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_609_0: read-var gs#117818:u8
        let s_609_0: bool = fn_state.gs_117818;
        // N s_609_1: branch s_609_0 b5332 b610
        if s_609_0 {
            return block_5332(state, tracer, fn_state);
        } else {
            return block_610(state, tracer, fn_state);
        };
    }
    fn block_610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_610_0: const #0u : u8
        let s_610_0: bool = false;
        // D s_610_1: write-var gs#117819 <= s_610_0
        fn_state.gs_117819 = s_610_0;
        // N s_610_2: jump b611
        return block_611(state, tracer, fn_state);
    }
    fn block_611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_611_0: read-var gs#117819:u8
        let s_611_0: bool = fn_state.gs_117819;
        // N s_611_1: branch s_611_0 b5331 b612
        if s_611_0 {
            return block_5331(state, tracer, fn_state);
        } else {
            return block_612(state, tracer, fn_state);
        };
    }
    fn block_612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_612_0: read-var CRm:u8
        let s_612_0: u8 = fn_state.CRm;
        // D s_612_1: cast zx s_612_0 -> bv
        let s_612_1: Bits = Bits::new(s_612_0 as u128, 4u16);
        // C s_612_2: const #0u : u8
        let s_612_2: u8 = 0;
        // C s_612_3: cast zx s_612_2 -> bv
        let s_612_3: Bits = Bits::new(s_612_2 as u128, 4u16);
        // D s_612_4: cmp-eq s_612_1 s_612_3
        let s_612_4: bool = ((s_612_1) == (s_612_3));
        // N s_612_5: branch s_612_4 b5330 b613
        if s_612_4 {
            return block_5330(state, tracer, fn_state);
        } else {
            return block_613(state, tracer, fn_state);
        };
    }
    fn block_613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_613_0: const #0u : u8
        let s_613_0: bool = false;
        // D s_613_1: write-var gs#117820 <= s_613_0
        fn_state.gs_117820 = s_613_0;
        // N s_613_2: jump b614
        return block_614(state, tracer, fn_state);
    }
    fn block_614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_614_0: read-var gs#117820:u8
        let s_614_0: bool = fn_state.gs_117820;
        // N s_614_1: branch s_614_0 b5329 b615
        if s_614_0 {
            return block_5329(state, tracer, fn_state);
        } else {
            return block_615(state, tracer, fn_state);
        };
    }
    fn block_615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_615_0: const #0u : u8
        let s_615_0: bool = false;
        // D s_615_1: write-var gs#117821 <= s_615_0
        fn_state.gs_117821 = s_615_0;
        // N s_615_2: jump b616
        return block_616(state, tracer, fn_state);
    }
    fn block_616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_616_0: read-var gs#117821:u8
        let s_616_0: bool = fn_state.gs_117821;
        // N s_616_1: branch s_616_0 b5328 b617
        if s_616_0 {
            return block_5328(state, tracer, fn_state);
        } else {
            return block_617(state, tracer, fn_state);
        };
    }
    fn block_617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_617_0: const #0u : u8
        let s_617_0: bool = false;
        // D s_617_1: write-var gs#117822 <= s_617_0
        fn_state.gs_117822 = s_617_0;
        // N s_617_2: jump b618
        return block_618(state, tracer, fn_state);
    }
    fn block_618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_618_0: read-var gs#117822:u8
        let s_618_0: bool = fn_state.gs_117822;
        // N s_618_1: branch s_618_0 b5327 b619
        if s_618_0 {
            return block_5327(state, tracer, fn_state);
        } else {
            return block_619(state, tracer, fn_state);
        };
    }
    fn block_619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_619_0: const #0u : u8
        let s_619_0: bool = false;
        // D s_619_1: write-var gs#117823 <= s_619_0
        fn_state.gs_117823 = s_619_0;
        // N s_619_2: jump b620
        return block_620(state, tracer, fn_state);
    }
    fn block_620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_620_0: read-var gs#117823:u8
        let s_620_0: bool = fn_state.gs_117823;
        // N s_620_1: branch s_620_0 b5326 b621
        if s_620_0 {
            return block_5326(state, tracer, fn_state);
        } else {
            return block_621(state, tracer, fn_state);
        };
    }
    fn block_621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_621_0: read-var CRm:u8
        let s_621_0: u8 = fn_state.CRm;
        // D s_621_1: cast zx s_621_0 -> bv
        let s_621_1: Bits = Bits::new(s_621_0 as u128, 4u16);
        // C s_621_2: const #0u : u8
        let s_621_2: u8 = 0;
        // C s_621_3: cast zx s_621_2 -> bv
        let s_621_3: Bits = Bits::new(s_621_2 as u128, 4u16);
        // D s_621_4: cmp-eq s_621_1 s_621_3
        let s_621_4: bool = ((s_621_1) == (s_621_3));
        // N s_621_5: branch s_621_4 b5325 b622
        if s_621_4 {
            return block_5325(state, tracer, fn_state);
        } else {
            return block_622(state, tracer, fn_state);
        };
    }
    fn block_622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_622_0: const #0u : u8
        let s_622_0: bool = false;
        // D s_622_1: write-var gs#117824 <= s_622_0
        fn_state.gs_117824 = s_622_0;
        // N s_622_2: jump b623
        return block_623(state, tracer, fn_state);
    }
    fn block_623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_623_0: read-var gs#117824:u8
        let s_623_0: bool = fn_state.gs_117824;
        // N s_623_1: branch s_623_0 b5324 b624
        if s_623_0 {
            return block_5324(state, tracer, fn_state);
        } else {
            return block_624(state, tracer, fn_state);
        };
    }
    fn block_624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_624_0: const #0u : u8
        let s_624_0: bool = false;
        // D s_624_1: write-var gs#117825 <= s_624_0
        fn_state.gs_117825 = s_624_0;
        // N s_624_2: jump b625
        return block_625(state, tracer, fn_state);
    }
    fn block_625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_625_0: read-var gs#117825:u8
        let s_625_0: bool = fn_state.gs_117825;
        // N s_625_1: branch s_625_0 b5323 b626
        if s_625_0 {
            return block_5323(state, tracer, fn_state);
        } else {
            return block_626(state, tracer, fn_state);
        };
    }
    fn block_626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_626_0: const #0u : u8
        let s_626_0: bool = false;
        // D s_626_1: write-var gs#117826 <= s_626_0
        fn_state.gs_117826 = s_626_0;
        // N s_626_2: jump b627
        return block_627(state, tracer, fn_state);
    }
    fn block_627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_627_0: read-var gs#117826:u8
        let s_627_0: bool = fn_state.gs_117826;
        // N s_627_1: branch s_627_0 b5322 b628
        if s_627_0 {
            return block_5322(state, tracer, fn_state);
        } else {
            return block_628(state, tracer, fn_state);
        };
    }
    fn block_628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_628_0: const #0u : u8
        let s_628_0: bool = false;
        // D s_628_1: write-var gs#117827 <= s_628_0
        fn_state.gs_117827 = s_628_0;
        // N s_628_2: jump b629
        return block_629(state, tracer, fn_state);
    }
    fn block_629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_629_0: read-var gs#117827:u8
        let s_629_0: bool = fn_state.gs_117827;
        // N s_629_1: branch s_629_0 b5321 b630
        if s_629_0 {
            return block_5321(state, tracer, fn_state);
        } else {
            return block_630(state, tracer, fn_state);
        };
    }
    fn block_630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_630_0: read-var CRm:u8
        let s_630_0: u8 = fn_state.CRm;
        // D s_630_1: cast zx s_630_0 -> bv
        let s_630_1: Bits = Bits::new(s_630_0 as u128, 4u16);
        // C s_630_2: const #3u : u8
        let s_630_2: u8 = 3;
        // C s_630_3: cast zx s_630_2 -> bv
        let s_630_3: Bits = Bits::new(s_630_2 as u128, 4u16);
        // D s_630_4: cmp-eq s_630_1 s_630_3
        let s_630_4: bool = ((s_630_1) == (s_630_3));
        // N s_630_5: branch s_630_4 b5320 b631
        if s_630_4 {
            return block_5320(state, tracer, fn_state);
        } else {
            return block_631(state, tracer, fn_state);
        };
    }
    fn block_631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_631_0: const #0u : u8
        let s_631_0: bool = false;
        // D s_631_1: write-var gs#117828 <= s_631_0
        fn_state.gs_117828 = s_631_0;
        // N s_631_2: jump b632
        return block_632(state, tracer, fn_state);
    }
    fn block_632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_632_0: read-var gs#117828:u8
        let s_632_0: bool = fn_state.gs_117828;
        // N s_632_1: branch s_632_0 b5319 b633
        if s_632_0 {
            return block_5319(state, tracer, fn_state);
        } else {
            return block_633(state, tracer, fn_state);
        };
    }
    fn block_633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_633_0: const #0u : u8
        let s_633_0: bool = false;
        // D s_633_1: write-var gs#117829 <= s_633_0
        fn_state.gs_117829 = s_633_0;
        // N s_633_2: jump b634
        return block_634(state, tracer, fn_state);
    }
    fn block_634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_634_0: read-var gs#117829:u8
        let s_634_0: bool = fn_state.gs_117829;
        // N s_634_1: branch s_634_0 b5318 b635
        if s_634_0 {
            return block_5318(state, tracer, fn_state);
        } else {
            return block_635(state, tracer, fn_state);
        };
    }
    fn block_635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_635_0: const #0u : u8
        let s_635_0: bool = false;
        // D s_635_1: write-var gs#117830 <= s_635_0
        fn_state.gs_117830 = s_635_0;
        // N s_635_2: jump b636
        return block_636(state, tracer, fn_state);
    }
    fn block_636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_636_0: read-var gs#117830:u8
        let s_636_0: bool = fn_state.gs_117830;
        // N s_636_1: branch s_636_0 b5317 b637
        if s_636_0 {
            return block_5317(state, tracer, fn_state);
        } else {
            return block_637(state, tracer, fn_state);
        };
    }
    fn block_637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_637_0: const #0u : u8
        let s_637_0: bool = false;
        // D s_637_1: write-var gs#117831 <= s_637_0
        fn_state.gs_117831 = s_637_0;
        // N s_637_2: jump b638
        return block_638(state, tracer, fn_state);
    }
    fn block_638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_638_0: read-var gs#117831:u8
        let s_638_0: bool = fn_state.gs_117831;
        // N s_638_1: branch s_638_0 b5316 b639
        if s_638_0 {
            return block_5316(state, tracer, fn_state);
        } else {
            return block_639(state, tracer, fn_state);
        };
    }
    fn block_639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_639_0: read-var CRm:u8
        let s_639_0: u8 = fn_state.CRm;
        // D s_639_1: cast zx s_639_0 -> bv
        let s_639_1: Bits = Bits::new(s_639_0 as u128, 4u16);
        // C s_639_2: const #9u : u8
        let s_639_2: u8 = 9;
        // C s_639_3: cast zx s_639_2 -> bv
        let s_639_3: Bits = Bits::new(s_639_2 as u128, 4u16);
        // D s_639_4: cmp-eq s_639_1 s_639_3
        let s_639_4: bool = ((s_639_1) == (s_639_3));
        // N s_639_5: branch s_639_4 b5315 b640
        if s_639_4 {
            return block_5315(state, tracer, fn_state);
        } else {
            return block_640(state, tracer, fn_state);
        };
    }
    fn block_640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_640_0: const #0u : u8
        let s_640_0: bool = false;
        // D s_640_1: write-var gs#117832 <= s_640_0
        fn_state.gs_117832 = s_640_0;
        // N s_640_2: jump b641
        return block_641(state, tracer, fn_state);
    }
    fn block_641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_641_0: read-var gs#117832:u8
        let s_641_0: bool = fn_state.gs_117832;
        // N s_641_1: branch s_641_0 b5314 b642
        if s_641_0 {
            return block_5314(state, tracer, fn_state);
        } else {
            return block_642(state, tracer, fn_state);
        };
    }
    fn block_642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_642_0: const #0u : u8
        let s_642_0: bool = false;
        // D s_642_1: write-var gs#117833 <= s_642_0
        fn_state.gs_117833 = s_642_0;
        // N s_642_2: jump b643
        return block_643(state, tracer, fn_state);
    }
    fn block_643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_643_0: read-var gs#117833:u8
        let s_643_0: bool = fn_state.gs_117833;
        // N s_643_1: branch s_643_0 b5313 b644
        if s_643_0 {
            return block_5313(state, tracer, fn_state);
        } else {
            return block_644(state, tracer, fn_state);
        };
    }
    fn block_644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_644_0: const #0u : u8
        let s_644_0: bool = false;
        // D s_644_1: write-var gs#117834 <= s_644_0
        fn_state.gs_117834 = s_644_0;
        // N s_644_2: jump b645
        return block_645(state, tracer, fn_state);
    }
    fn block_645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_645_0: read-var gs#117834:u8
        let s_645_0: bool = fn_state.gs_117834;
        // N s_645_1: branch s_645_0 b5312 b646
        if s_645_0 {
            return block_5312(state, tracer, fn_state);
        } else {
            return block_646(state, tracer, fn_state);
        };
    }
    fn block_646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_646_0: const #0u : u8
        let s_646_0: bool = false;
        // D s_646_1: write-var gs#117835 <= s_646_0
        fn_state.gs_117835 = s_646_0;
        // N s_646_2: jump b647
        return block_647(state, tracer, fn_state);
    }
    fn block_647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_647_0: read-var gs#117835:u8
        let s_647_0: bool = fn_state.gs_117835;
        // N s_647_1: branch s_647_0 b5311 b648
        if s_647_0 {
            return block_5311(state, tracer, fn_state);
        } else {
            return block_648(state, tracer, fn_state);
        };
    }
    fn block_648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_648_0: read-var CRm:u8
        let s_648_0: u8 = fn_state.CRm;
        // D s_648_1: cast zx s_648_0 -> bv
        let s_648_1: Bits = Bits::new(s_648_0 as u128, 4u16);
        // C s_648_2: const #0u : u8
        let s_648_2: u8 = 0;
        // C s_648_3: cast zx s_648_2 -> bv
        let s_648_3: Bits = Bits::new(s_648_2 as u128, 4u16);
        // D s_648_4: cmp-eq s_648_1 s_648_3
        let s_648_4: bool = ((s_648_1) == (s_648_3));
        // N s_648_5: branch s_648_4 b5310 b649
        if s_648_4 {
            return block_5310(state, tracer, fn_state);
        } else {
            return block_649(state, tracer, fn_state);
        };
    }
    fn block_649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_649_0: const #0u : u8
        let s_649_0: bool = false;
        // D s_649_1: write-var gs#117836 <= s_649_0
        fn_state.gs_117836 = s_649_0;
        // N s_649_2: jump b650
        return block_650(state, tracer, fn_state);
    }
    fn block_650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_650_0: read-var gs#117836:u8
        let s_650_0: bool = fn_state.gs_117836;
        // N s_650_1: branch s_650_0 b5309 b651
        if s_650_0 {
            return block_5309(state, tracer, fn_state);
        } else {
            return block_651(state, tracer, fn_state);
        };
    }
    fn block_651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_651_0: const #0u : u8
        let s_651_0: bool = false;
        // D s_651_1: write-var gs#117837 <= s_651_0
        fn_state.gs_117837 = s_651_0;
        // N s_651_2: jump b652
        return block_652(state, tracer, fn_state);
    }
    fn block_652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_652_0: read-var gs#117837:u8
        let s_652_0: bool = fn_state.gs_117837;
        // N s_652_1: branch s_652_0 b5308 b653
        if s_652_0 {
            return block_5308(state, tracer, fn_state);
        } else {
            return block_653(state, tracer, fn_state);
        };
    }
    fn block_653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_653_0: const #0u : u8
        let s_653_0: bool = false;
        // D s_653_1: write-var gs#117838 <= s_653_0
        fn_state.gs_117838 = s_653_0;
        // N s_653_2: jump b654
        return block_654(state, tracer, fn_state);
    }
    fn block_654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_654_0: read-var gs#117838:u8
        let s_654_0: bool = fn_state.gs_117838;
        // N s_654_1: branch s_654_0 b5307 b655
        if s_654_0 {
            return block_5307(state, tracer, fn_state);
        } else {
            return block_655(state, tracer, fn_state);
        };
    }
    fn block_655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_655_0: const #0u : u8
        let s_655_0: bool = false;
        // D s_655_1: write-var gs#117839 <= s_655_0
        fn_state.gs_117839 = s_655_0;
        // N s_655_2: jump b656
        return block_656(state, tracer, fn_state);
    }
    fn block_656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_656_0: read-var gs#117839:u8
        let s_656_0: bool = fn_state.gs_117839;
        // N s_656_1: branch s_656_0 b5306 b657
        if s_656_0 {
            return block_5306(state, tracer, fn_state);
        } else {
            return block_657(state, tracer, fn_state);
        };
    }
    fn block_657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_657_0: read-var CRm:u8
        let s_657_0: u8 = fn_state.CRm;
        // D s_657_1: cast zx s_657_0 -> bv
        let s_657_1: Bits = Bits::new(s_657_0 as u128, 4u16);
        // C s_657_2: const #15u : u8
        let s_657_2: u8 = 15;
        // C s_657_3: cast zx s_657_2 -> bv
        let s_657_3: Bits = Bits::new(s_657_2 as u128, 4u16);
        // D s_657_4: cmp-eq s_657_1 s_657_3
        let s_657_4: bool = ((s_657_1) == (s_657_3));
        // N s_657_5: branch s_657_4 b5305 b658
        if s_657_4 {
            return block_5305(state, tracer, fn_state);
        } else {
            return block_658(state, tracer, fn_state);
        };
    }
    fn block_658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_658_0: const #0u : u8
        let s_658_0: bool = false;
        // D s_658_1: write-var gs#117840 <= s_658_0
        fn_state.gs_117840 = s_658_0;
        // N s_658_2: jump b659
        return block_659(state, tracer, fn_state);
    }
    fn block_659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_659_0: read-var gs#117840:u8
        let s_659_0: bool = fn_state.gs_117840;
        // N s_659_1: branch s_659_0 b5304 b660
        if s_659_0 {
            return block_5304(state, tracer, fn_state);
        } else {
            return block_660(state, tracer, fn_state);
        };
    }
    fn block_660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_660_0: const #0u : u8
        let s_660_0: bool = false;
        // D s_660_1: write-var gs#117841 <= s_660_0
        fn_state.gs_117841 = s_660_0;
        // N s_660_2: jump b661
        return block_661(state, tracer, fn_state);
    }
    fn block_661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_661_0: read-var gs#117841:u8
        let s_661_0: bool = fn_state.gs_117841;
        // N s_661_1: branch s_661_0 b5303 b662
        if s_661_0 {
            return block_5303(state, tracer, fn_state);
        } else {
            return block_662(state, tracer, fn_state);
        };
    }
    fn block_662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_662_0: const #0u : u8
        let s_662_0: bool = false;
        // D s_662_1: write-var gs#117842 <= s_662_0
        fn_state.gs_117842 = s_662_0;
        // N s_662_2: jump b663
        return block_663(state, tracer, fn_state);
    }
    fn block_663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_663_0: read-var gs#117842:u8
        let s_663_0: bool = fn_state.gs_117842;
        // N s_663_1: branch s_663_0 b5302 b664
        if s_663_0 {
            return block_5302(state, tracer, fn_state);
        } else {
            return block_664(state, tracer, fn_state);
        };
    }
    fn block_664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_664_0: const #0u : u8
        let s_664_0: bool = false;
        // D s_664_1: write-var gs#117843 <= s_664_0
        fn_state.gs_117843 = s_664_0;
        // N s_664_2: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_665_0: read-var gs#117843:u8
        let s_665_0: bool = fn_state.gs_117843;
        // N s_665_1: branch s_665_0 b5301 b666
        if s_665_0 {
            return block_5301(state, tracer, fn_state);
        } else {
            return block_666(state, tracer, fn_state);
        };
    }
    fn block_666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_666_0: read-var CRm:u8
        let s_666_0: u8 = fn_state.CRm;
        // D s_666_1: cast zx s_666_0 -> bv
        let s_666_1: Bits = Bits::new(s_666_0 as u128, 4u16);
        // C s_666_2: const #14u : u8
        let s_666_2: u8 = 14;
        // C s_666_3: cast zx s_666_2 -> bv
        let s_666_3: Bits = Bits::new(s_666_2 as u128, 4u16);
        // D s_666_4: cmp-eq s_666_1 s_666_3
        let s_666_4: bool = ((s_666_1) == (s_666_3));
        // N s_666_5: branch s_666_4 b5300 b667
        if s_666_4 {
            return block_5300(state, tracer, fn_state);
        } else {
            return block_667(state, tracer, fn_state);
        };
    }
    fn block_667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_667_0: const #0u : u8
        let s_667_0: bool = false;
        // D s_667_1: write-var gs#117844 <= s_667_0
        fn_state.gs_117844 = s_667_0;
        // N s_667_2: jump b668
        return block_668(state, tracer, fn_state);
    }
    fn block_668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_668_0: read-var gs#117844:u8
        let s_668_0: bool = fn_state.gs_117844;
        // N s_668_1: branch s_668_0 b5299 b669
        if s_668_0 {
            return block_5299(state, tracer, fn_state);
        } else {
            return block_669(state, tracer, fn_state);
        };
    }
    fn block_669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_669_0: const #0u : u8
        let s_669_0: bool = false;
        // D s_669_1: write-var gs#117845 <= s_669_0
        fn_state.gs_117845 = s_669_0;
        // N s_669_2: jump b670
        return block_670(state, tracer, fn_state);
    }
    fn block_670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_670_0: read-var gs#117845:u8
        let s_670_0: bool = fn_state.gs_117845;
        // N s_670_1: branch s_670_0 b5298 b671
        if s_670_0 {
            return block_5298(state, tracer, fn_state);
        } else {
            return block_671(state, tracer, fn_state);
        };
    }
    fn block_671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_671_0: const #0u : u8
        let s_671_0: bool = false;
        // D s_671_1: write-var gs#117846 <= s_671_0
        fn_state.gs_117846 = s_671_0;
        // N s_671_2: jump b672
        return block_672(state, tracer, fn_state);
    }
    fn block_672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_672_0: read-var gs#117846:u8
        let s_672_0: bool = fn_state.gs_117846;
        // N s_672_1: branch s_672_0 b5297 b673
        if s_672_0 {
            return block_5297(state, tracer, fn_state);
        } else {
            return block_673(state, tracer, fn_state);
        };
    }
    fn block_673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_673_0: const #0u : u8
        let s_673_0: bool = false;
        // D s_673_1: write-var gs#117847 <= s_673_0
        fn_state.gs_117847 = s_673_0;
        // N s_673_2: jump b674
        return block_674(state, tracer, fn_state);
    }
    fn block_674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_674_0: read-var gs#117847:u8
        let s_674_0: bool = fn_state.gs_117847;
        // N s_674_1: branch s_674_0 b5296 b675
        if s_674_0 {
            return block_5296(state, tracer, fn_state);
        } else {
            return block_675(state, tracer, fn_state);
        };
    }
    fn block_675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_675_0: read-var CRm:u8
        let s_675_0: u8 = fn_state.CRm;
        // D s_675_1: cast zx s_675_0 -> bv
        let s_675_1: Bits = Bits::new(s_675_0 as u128, 4u16);
        // C s_675_2: const #13u : u8
        let s_675_2: u8 = 13;
        // C s_675_3: cast zx s_675_2 -> bv
        let s_675_3: Bits = Bits::new(s_675_2 as u128, 4u16);
        // D s_675_4: cmp-eq s_675_1 s_675_3
        let s_675_4: bool = ((s_675_1) == (s_675_3));
        // N s_675_5: branch s_675_4 b5295 b676
        if s_675_4 {
            return block_5295(state, tracer, fn_state);
        } else {
            return block_676(state, tracer, fn_state);
        };
    }
    fn block_676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_676_0: const #0u : u8
        let s_676_0: bool = false;
        // D s_676_1: write-var gs#117848 <= s_676_0
        fn_state.gs_117848 = s_676_0;
        // N s_676_2: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_677_0: read-var gs#117848:u8
        let s_677_0: bool = fn_state.gs_117848;
        // N s_677_1: branch s_677_0 b5294 b678
        if s_677_0 {
            return block_5294(state, tracer, fn_state);
        } else {
            return block_678(state, tracer, fn_state);
        };
    }
    fn block_678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_678_0: const #0u : u8
        let s_678_0: bool = false;
        // D s_678_1: write-var gs#117849 <= s_678_0
        fn_state.gs_117849 = s_678_0;
        // N s_678_2: jump b679
        return block_679(state, tracer, fn_state);
    }
    fn block_679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_679_0: read-var gs#117849:u8
        let s_679_0: bool = fn_state.gs_117849;
        // N s_679_1: branch s_679_0 b5293 b680
        if s_679_0 {
            return block_5293(state, tracer, fn_state);
        } else {
            return block_680(state, tracer, fn_state);
        };
    }
    fn block_680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_680_0: const #0u : u8
        let s_680_0: bool = false;
        // D s_680_1: write-var gs#117850 <= s_680_0
        fn_state.gs_117850 = s_680_0;
        // N s_680_2: jump b681
        return block_681(state, tracer, fn_state);
    }
    fn block_681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_681_0: read-var gs#117850:u8
        let s_681_0: bool = fn_state.gs_117850;
        // N s_681_1: branch s_681_0 b5292 b682
        if s_681_0 {
            return block_5292(state, tracer, fn_state);
        } else {
            return block_682(state, tracer, fn_state);
        };
    }
    fn block_682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_682_0: const #0u : u8
        let s_682_0: bool = false;
        // D s_682_1: write-var gs#117851 <= s_682_0
        fn_state.gs_117851 = s_682_0;
        // N s_682_2: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_683_0: read-var gs#117851:u8
        let s_683_0: bool = fn_state.gs_117851;
        // N s_683_1: branch s_683_0 b5291 b684
        if s_683_0 {
            return block_5291(state, tracer, fn_state);
        } else {
            return block_684(state, tracer, fn_state);
        };
    }
    fn block_684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_684_0: read-var CRm:u8
        let s_684_0: u8 = fn_state.CRm;
        // D s_684_1: cast zx s_684_0 -> bv
        let s_684_1: Bits = Bits::new(s_684_0 as u128, 4u16);
        // C s_684_2: const #12u : u8
        let s_684_2: u8 = 12;
        // C s_684_3: cast zx s_684_2 -> bv
        let s_684_3: Bits = Bits::new(s_684_2 as u128, 4u16);
        // D s_684_4: cmp-eq s_684_1 s_684_3
        let s_684_4: bool = ((s_684_1) == (s_684_3));
        // N s_684_5: branch s_684_4 b5290 b685
        if s_684_4 {
            return block_5290(state, tracer, fn_state);
        } else {
            return block_685(state, tracer, fn_state);
        };
    }
    fn block_685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_685_0: const #0u : u8
        let s_685_0: bool = false;
        // D s_685_1: write-var gs#117852 <= s_685_0
        fn_state.gs_117852 = s_685_0;
        // N s_685_2: jump b686
        return block_686(state, tracer, fn_state);
    }
    fn block_686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_686_0: read-var gs#117852:u8
        let s_686_0: bool = fn_state.gs_117852;
        // N s_686_1: branch s_686_0 b5289 b687
        if s_686_0 {
            return block_5289(state, tracer, fn_state);
        } else {
            return block_687(state, tracer, fn_state);
        };
    }
    fn block_687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_687_0: const #0u : u8
        let s_687_0: bool = false;
        // D s_687_1: write-var gs#117853 <= s_687_0
        fn_state.gs_117853 = s_687_0;
        // N s_687_2: jump b688
        return block_688(state, tracer, fn_state);
    }
    fn block_688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_688_0: read-var gs#117853:u8
        let s_688_0: bool = fn_state.gs_117853;
        // N s_688_1: branch s_688_0 b5288 b689
        if s_688_0 {
            return block_5288(state, tracer, fn_state);
        } else {
            return block_689(state, tracer, fn_state);
        };
    }
    fn block_689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_689_0: const #0u : u8
        let s_689_0: bool = false;
        // D s_689_1: write-var gs#117854 <= s_689_0
        fn_state.gs_117854 = s_689_0;
        // N s_689_2: jump b690
        return block_690(state, tracer, fn_state);
    }
    fn block_690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_690_0: read-var gs#117854:u8
        let s_690_0: bool = fn_state.gs_117854;
        // N s_690_1: branch s_690_0 b5287 b691
        if s_690_0 {
            return block_5287(state, tracer, fn_state);
        } else {
            return block_691(state, tracer, fn_state);
        };
    }
    fn block_691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_691_0: const #0u : u8
        let s_691_0: bool = false;
        // D s_691_1: write-var gs#117855 <= s_691_0
        fn_state.gs_117855 = s_691_0;
        // N s_691_2: jump b692
        return block_692(state, tracer, fn_state);
    }
    fn block_692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_692_0: read-var gs#117855:u8
        let s_692_0: bool = fn_state.gs_117855;
        // N s_692_1: branch s_692_0 b5286 b693
        if s_692_0 {
            return block_5286(state, tracer, fn_state);
        } else {
            return block_693(state, tracer, fn_state);
        };
    }
    fn block_693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_693_0: read-var CRm:u8
        let s_693_0: u8 = fn_state.CRm;
        // D s_693_1: cast zx s_693_0 -> bv
        let s_693_1: Bits = Bits::new(s_693_0 as u128, 4u16);
        // C s_693_2: const #11u : u8
        let s_693_2: u8 = 11;
        // C s_693_3: cast zx s_693_2 -> bv
        let s_693_3: Bits = Bits::new(s_693_2 as u128, 4u16);
        // D s_693_4: cmp-eq s_693_1 s_693_3
        let s_693_4: bool = ((s_693_1) == (s_693_3));
        // N s_693_5: branch s_693_4 b5285 b694
        if s_693_4 {
            return block_5285(state, tracer, fn_state);
        } else {
            return block_694(state, tracer, fn_state);
        };
    }
    fn block_694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_694_0: const #0u : u8
        let s_694_0: bool = false;
        // D s_694_1: write-var gs#117856 <= s_694_0
        fn_state.gs_117856 = s_694_0;
        // N s_694_2: jump b695
        return block_695(state, tracer, fn_state);
    }
    fn block_695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_695_0: read-var gs#117856:u8
        let s_695_0: bool = fn_state.gs_117856;
        // N s_695_1: branch s_695_0 b5284 b696
        if s_695_0 {
            return block_5284(state, tracer, fn_state);
        } else {
            return block_696(state, tracer, fn_state);
        };
    }
    fn block_696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_696_0: const #0u : u8
        let s_696_0: bool = false;
        // D s_696_1: write-var gs#117857 <= s_696_0
        fn_state.gs_117857 = s_696_0;
        // N s_696_2: jump b697
        return block_697(state, tracer, fn_state);
    }
    fn block_697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_697_0: read-var gs#117857:u8
        let s_697_0: bool = fn_state.gs_117857;
        // N s_697_1: branch s_697_0 b5283 b698
        if s_697_0 {
            return block_5283(state, tracer, fn_state);
        } else {
            return block_698(state, tracer, fn_state);
        };
    }
    fn block_698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_698_0: const #0u : u8
        let s_698_0: bool = false;
        // D s_698_1: write-var gs#117858 <= s_698_0
        fn_state.gs_117858 = s_698_0;
        // N s_698_2: jump b699
        return block_699(state, tracer, fn_state);
    }
    fn block_699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_699_0: read-var gs#117858:u8
        let s_699_0: bool = fn_state.gs_117858;
        // N s_699_1: branch s_699_0 b5282 b700
        if s_699_0 {
            return block_5282(state, tracer, fn_state);
        } else {
            return block_700(state, tracer, fn_state);
        };
    }
    fn block_700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_700_0: const #0u : u8
        let s_700_0: bool = false;
        // D s_700_1: write-var gs#117859 <= s_700_0
        fn_state.gs_117859 = s_700_0;
        // N s_700_2: jump b701
        return block_701(state, tracer, fn_state);
    }
    fn block_701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_701_0: read-var gs#117859:u8
        let s_701_0: bool = fn_state.gs_117859;
        // N s_701_1: branch s_701_0 b5281 b702
        if s_701_0 {
            return block_5281(state, tracer, fn_state);
        } else {
            return block_702(state, tracer, fn_state);
        };
    }
    fn block_702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_702_0: read-var CRm:u8
        let s_702_0: u8 = fn_state.CRm;
        // D s_702_1: cast zx s_702_0 -> bv
        let s_702_1: Bits = Bits::new(s_702_0 as u128, 4u16);
        // C s_702_2: const #10u : u8
        let s_702_2: u8 = 10;
        // C s_702_3: cast zx s_702_2 -> bv
        let s_702_3: Bits = Bits::new(s_702_2 as u128, 4u16);
        // D s_702_4: cmp-eq s_702_1 s_702_3
        let s_702_4: bool = ((s_702_1) == (s_702_3));
        // N s_702_5: branch s_702_4 b5280 b703
        if s_702_4 {
            return block_5280(state, tracer, fn_state);
        } else {
            return block_703(state, tracer, fn_state);
        };
    }
    fn block_703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_703_0: const #0u : u8
        let s_703_0: bool = false;
        // D s_703_1: write-var gs#117860 <= s_703_0
        fn_state.gs_117860 = s_703_0;
        // N s_703_2: jump b704
        return block_704(state, tracer, fn_state);
    }
    fn block_704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_704_0: read-var gs#117860:u8
        let s_704_0: bool = fn_state.gs_117860;
        // N s_704_1: branch s_704_0 b5279 b705
        if s_704_0 {
            return block_5279(state, tracer, fn_state);
        } else {
            return block_705(state, tracer, fn_state);
        };
    }
    fn block_705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_705_0: const #0u : u8
        let s_705_0: bool = false;
        // D s_705_1: write-var gs#117861 <= s_705_0
        fn_state.gs_117861 = s_705_0;
        // N s_705_2: jump b706
        return block_706(state, tracer, fn_state);
    }
    fn block_706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_706_0: read-var gs#117861:u8
        let s_706_0: bool = fn_state.gs_117861;
        // N s_706_1: branch s_706_0 b5278 b707
        if s_706_0 {
            return block_5278(state, tracer, fn_state);
        } else {
            return block_707(state, tracer, fn_state);
        };
    }
    fn block_707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_707_0: const #0u : u8
        let s_707_0: bool = false;
        // D s_707_1: write-var gs#117862 <= s_707_0
        fn_state.gs_117862 = s_707_0;
        // N s_707_2: jump b708
        return block_708(state, tracer, fn_state);
    }
    fn block_708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_708_0: read-var gs#117862:u8
        let s_708_0: bool = fn_state.gs_117862;
        // N s_708_1: branch s_708_0 b5277 b709
        if s_708_0 {
            return block_5277(state, tracer, fn_state);
        } else {
            return block_709(state, tracer, fn_state);
        };
    }
    fn block_709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_709_0: const #0u : u8
        let s_709_0: bool = false;
        // D s_709_1: write-var gs#117863 <= s_709_0
        fn_state.gs_117863 = s_709_0;
        // N s_709_2: jump b710
        return block_710(state, tracer, fn_state);
    }
    fn block_710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_710_0: read-var gs#117863:u8
        let s_710_0: bool = fn_state.gs_117863;
        // N s_710_1: branch s_710_0 b5276 b711
        if s_710_0 {
            return block_5276(state, tracer, fn_state);
        } else {
            return block_711(state, tracer, fn_state);
        };
    }
    fn block_711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_711_0: read-var CRm:u8
        let s_711_0: u8 = fn_state.CRm;
        // D s_711_1: cast zx s_711_0 -> bv
        let s_711_1: Bits = Bits::new(s_711_0 as u128, 4u16);
        // C s_711_2: const #9u : u8
        let s_711_2: u8 = 9;
        // C s_711_3: cast zx s_711_2 -> bv
        let s_711_3: Bits = Bits::new(s_711_2 as u128, 4u16);
        // D s_711_4: cmp-eq s_711_1 s_711_3
        let s_711_4: bool = ((s_711_1) == (s_711_3));
        // N s_711_5: branch s_711_4 b5275 b712
        if s_711_4 {
            return block_5275(state, tracer, fn_state);
        } else {
            return block_712(state, tracer, fn_state);
        };
    }
    fn block_712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_712_0: const #0u : u8
        let s_712_0: bool = false;
        // D s_712_1: write-var gs#117864 <= s_712_0
        fn_state.gs_117864 = s_712_0;
        // N s_712_2: jump b713
        return block_713(state, tracer, fn_state);
    }
    fn block_713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_713_0: read-var gs#117864:u8
        let s_713_0: bool = fn_state.gs_117864;
        // N s_713_1: branch s_713_0 b5274 b714
        if s_713_0 {
            return block_5274(state, tracer, fn_state);
        } else {
            return block_714(state, tracer, fn_state);
        };
    }
    fn block_714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_714_0: const #0u : u8
        let s_714_0: bool = false;
        // D s_714_1: write-var gs#117865 <= s_714_0
        fn_state.gs_117865 = s_714_0;
        // N s_714_2: jump b715
        return block_715(state, tracer, fn_state);
    }
    fn block_715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_715_0: read-var gs#117865:u8
        let s_715_0: bool = fn_state.gs_117865;
        // N s_715_1: branch s_715_0 b5273 b716
        if s_715_0 {
            return block_5273(state, tracer, fn_state);
        } else {
            return block_716(state, tracer, fn_state);
        };
    }
    fn block_716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_716_0: const #0u : u8
        let s_716_0: bool = false;
        // D s_716_1: write-var gs#117866 <= s_716_0
        fn_state.gs_117866 = s_716_0;
        // N s_716_2: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_717_0: read-var gs#117866:u8
        let s_717_0: bool = fn_state.gs_117866;
        // N s_717_1: branch s_717_0 b5272 b718
        if s_717_0 {
            return block_5272(state, tracer, fn_state);
        } else {
            return block_718(state, tracer, fn_state);
        };
    }
    fn block_718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_718_0: const #0u : u8
        let s_718_0: bool = false;
        // D s_718_1: write-var gs#117867 <= s_718_0
        fn_state.gs_117867 = s_718_0;
        // N s_718_2: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_719_0: read-var gs#117867:u8
        let s_719_0: bool = fn_state.gs_117867;
        // N s_719_1: branch s_719_0 b5271 b720
        if s_719_0 {
            return block_5271(state, tracer, fn_state);
        } else {
            return block_720(state, tracer, fn_state);
        };
    }
    fn block_720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_720_0: read-var CRm:u8
        let s_720_0: u8 = fn_state.CRm;
        // D s_720_1: cast zx s_720_0 -> bv
        let s_720_1: Bits = Bits::new(s_720_0 as u128, 4u16);
        // C s_720_2: const #8u : u8
        let s_720_2: u8 = 8;
        // C s_720_3: cast zx s_720_2 -> bv
        let s_720_3: Bits = Bits::new(s_720_2 as u128, 4u16);
        // D s_720_4: cmp-eq s_720_1 s_720_3
        let s_720_4: bool = ((s_720_1) == (s_720_3));
        // N s_720_5: branch s_720_4 b5270 b721
        if s_720_4 {
            return block_5270(state, tracer, fn_state);
        } else {
            return block_721(state, tracer, fn_state);
        };
    }
    fn block_721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_721_0: const #0u : u8
        let s_721_0: bool = false;
        // D s_721_1: write-var gs#117868 <= s_721_0
        fn_state.gs_117868 = s_721_0;
        // N s_721_2: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_722_0: read-var gs#117868:u8
        let s_722_0: bool = fn_state.gs_117868;
        // N s_722_1: branch s_722_0 b5269 b723
        if s_722_0 {
            return block_5269(state, tracer, fn_state);
        } else {
            return block_723(state, tracer, fn_state);
        };
    }
    fn block_723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_723_0: const #0u : u8
        let s_723_0: bool = false;
        // D s_723_1: write-var gs#117869 <= s_723_0
        fn_state.gs_117869 = s_723_0;
        // N s_723_2: jump b724
        return block_724(state, tracer, fn_state);
    }
    fn block_724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_724_0: read-var gs#117869:u8
        let s_724_0: bool = fn_state.gs_117869;
        // N s_724_1: branch s_724_0 b5268 b725
        if s_724_0 {
            return block_5268(state, tracer, fn_state);
        } else {
            return block_725(state, tracer, fn_state);
        };
    }
    fn block_725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_725_0: const #0u : u8
        let s_725_0: bool = false;
        // D s_725_1: write-var gs#117870 <= s_725_0
        fn_state.gs_117870 = s_725_0;
        // N s_725_2: jump b726
        return block_726(state, tracer, fn_state);
    }
    fn block_726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_726_0: read-var gs#117870:u8
        let s_726_0: bool = fn_state.gs_117870;
        // N s_726_1: branch s_726_0 b5267 b727
        if s_726_0 {
            return block_5267(state, tracer, fn_state);
        } else {
            return block_727(state, tracer, fn_state);
        };
    }
    fn block_727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_727_0: const #0u : u8
        let s_727_0: bool = false;
        // D s_727_1: write-var gs#117871 <= s_727_0
        fn_state.gs_117871 = s_727_0;
        // N s_727_2: jump b728
        return block_728(state, tracer, fn_state);
    }
    fn block_728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_728_0: read-var gs#117871:u8
        let s_728_0: bool = fn_state.gs_117871;
        // N s_728_1: branch s_728_0 b5266 b729
        if s_728_0 {
            return block_5266(state, tracer, fn_state);
        } else {
            return block_729(state, tracer, fn_state);
        };
    }
    fn block_729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_729_0: read-var CRm:u8
        let s_729_0: u8 = fn_state.CRm;
        // D s_729_1: cast zx s_729_0 -> bv
        let s_729_1: Bits = Bits::new(s_729_0 as u128, 4u16);
        // C s_729_2: const #7u : u8
        let s_729_2: u8 = 7;
        // C s_729_3: cast zx s_729_2 -> bv
        let s_729_3: Bits = Bits::new(s_729_2 as u128, 4u16);
        // D s_729_4: cmp-eq s_729_1 s_729_3
        let s_729_4: bool = ((s_729_1) == (s_729_3));
        // N s_729_5: branch s_729_4 b5265 b730
        if s_729_4 {
            return block_5265(state, tracer, fn_state);
        } else {
            return block_730(state, tracer, fn_state);
        };
    }
    fn block_730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_730_0: const #0u : u8
        let s_730_0: bool = false;
        // D s_730_1: write-var gs#117872 <= s_730_0
        fn_state.gs_117872 = s_730_0;
        // N s_730_2: jump b731
        return block_731(state, tracer, fn_state);
    }
    fn block_731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_731_0: read-var gs#117872:u8
        let s_731_0: bool = fn_state.gs_117872;
        // N s_731_1: branch s_731_0 b5264 b732
        if s_731_0 {
            return block_5264(state, tracer, fn_state);
        } else {
            return block_732(state, tracer, fn_state);
        };
    }
    fn block_732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_732_0: const #0u : u8
        let s_732_0: bool = false;
        // D s_732_1: write-var gs#117873 <= s_732_0
        fn_state.gs_117873 = s_732_0;
        // N s_732_2: jump b733
        return block_733(state, tracer, fn_state);
    }
    fn block_733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_733_0: read-var gs#117873:u8
        let s_733_0: bool = fn_state.gs_117873;
        // N s_733_1: branch s_733_0 b5263 b734
        if s_733_0 {
            return block_5263(state, tracer, fn_state);
        } else {
            return block_734(state, tracer, fn_state);
        };
    }
    fn block_734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_734_0: const #0u : u8
        let s_734_0: bool = false;
        // D s_734_1: write-var gs#117874 <= s_734_0
        fn_state.gs_117874 = s_734_0;
        // N s_734_2: jump b735
        return block_735(state, tracer, fn_state);
    }
    fn block_735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_735_0: read-var gs#117874:u8
        let s_735_0: bool = fn_state.gs_117874;
        // N s_735_1: branch s_735_0 b5262 b736
        if s_735_0 {
            return block_5262(state, tracer, fn_state);
        } else {
            return block_736(state, tracer, fn_state);
        };
    }
    fn block_736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_736_0: const #0u : u8
        let s_736_0: bool = false;
        // D s_736_1: write-var gs#117875 <= s_736_0
        fn_state.gs_117875 = s_736_0;
        // N s_736_2: jump b737
        return block_737(state, tracer, fn_state);
    }
    fn block_737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_737_0: read-var gs#117875:u8
        let s_737_0: bool = fn_state.gs_117875;
        // N s_737_1: branch s_737_0 b5261 b738
        if s_737_0 {
            return block_5261(state, tracer, fn_state);
        } else {
            return block_738(state, tracer, fn_state);
        };
    }
    fn block_738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_738_0: read-var CRm:u8
        let s_738_0: u8 = fn_state.CRm;
        // D s_738_1: cast zx s_738_0 -> bv
        let s_738_1: Bits = Bits::new(s_738_0 as u128, 4u16);
        // C s_738_2: const #6u : u8
        let s_738_2: u8 = 6;
        // C s_738_3: cast zx s_738_2 -> bv
        let s_738_3: Bits = Bits::new(s_738_2 as u128, 4u16);
        // D s_738_4: cmp-eq s_738_1 s_738_3
        let s_738_4: bool = ((s_738_1) == (s_738_3));
        // N s_738_5: branch s_738_4 b5260 b739
        if s_738_4 {
            return block_5260(state, tracer, fn_state);
        } else {
            return block_739(state, tracer, fn_state);
        };
    }
    fn block_739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_739_0: const #0u : u8
        let s_739_0: bool = false;
        // D s_739_1: write-var gs#117876 <= s_739_0
        fn_state.gs_117876 = s_739_0;
        // N s_739_2: jump b740
        return block_740(state, tracer, fn_state);
    }
    fn block_740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_740_0: read-var gs#117876:u8
        let s_740_0: bool = fn_state.gs_117876;
        // N s_740_1: branch s_740_0 b5259 b741
        if s_740_0 {
            return block_5259(state, tracer, fn_state);
        } else {
            return block_741(state, tracer, fn_state);
        };
    }
    fn block_741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_741_0: const #0u : u8
        let s_741_0: bool = false;
        // D s_741_1: write-var gs#117877 <= s_741_0
        fn_state.gs_117877 = s_741_0;
        // N s_741_2: jump b742
        return block_742(state, tracer, fn_state);
    }
    fn block_742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_742_0: read-var gs#117877:u8
        let s_742_0: bool = fn_state.gs_117877;
        // N s_742_1: branch s_742_0 b5258 b743
        if s_742_0 {
            return block_5258(state, tracer, fn_state);
        } else {
            return block_743(state, tracer, fn_state);
        };
    }
    fn block_743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_743_0: const #0u : u8
        let s_743_0: bool = false;
        // D s_743_1: write-var gs#117878 <= s_743_0
        fn_state.gs_117878 = s_743_0;
        // N s_743_2: jump b744
        return block_744(state, tracer, fn_state);
    }
    fn block_744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_744_0: read-var gs#117878:u8
        let s_744_0: bool = fn_state.gs_117878;
        // N s_744_1: branch s_744_0 b5257 b745
        if s_744_0 {
            return block_5257(state, tracer, fn_state);
        } else {
            return block_745(state, tracer, fn_state);
        };
    }
    fn block_745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_745_0: const #0u : u8
        let s_745_0: bool = false;
        // D s_745_1: write-var gs#117879 <= s_745_0
        fn_state.gs_117879 = s_745_0;
        // N s_745_2: jump b746
        return block_746(state, tracer, fn_state);
    }
    fn block_746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_746_0: read-var gs#117879:u8
        let s_746_0: bool = fn_state.gs_117879;
        // N s_746_1: branch s_746_0 b5256 b747
        if s_746_0 {
            return block_5256(state, tracer, fn_state);
        } else {
            return block_747(state, tracer, fn_state);
        };
    }
    fn block_747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_747_0: read-var CRm:u8
        let s_747_0: u8 = fn_state.CRm;
        // D s_747_1: cast zx s_747_0 -> bv
        let s_747_1: Bits = Bits::new(s_747_0 as u128, 4u16);
        // C s_747_2: const #5u : u8
        let s_747_2: u8 = 5;
        // C s_747_3: cast zx s_747_2 -> bv
        let s_747_3: Bits = Bits::new(s_747_2 as u128, 4u16);
        // D s_747_4: cmp-eq s_747_1 s_747_3
        let s_747_4: bool = ((s_747_1) == (s_747_3));
        // N s_747_5: branch s_747_4 b5255 b748
        if s_747_4 {
            return block_5255(state, tracer, fn_state);
        } else {
            return block_748(state, tracer, fn_state);
        };
    }
    fn block_748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_748_0: const #0u : u8
        let s_748_0: bool = false;
        // D s_748_1: write-var gs#117880 <= s_748_0
        fn_state.gs_117880 = s_748_0;
        // N s_748_2: jump b749
        return block_749(state, tracer, fn_state);
    }
    fn block_749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_749_0: read-var gs#117880:u8
        let s_749_0: bool = fn_state.gs_117880;
        // N s_749_1: branch s_749_0 b5254 b750
        if s_749_0 {
            return block_5254(state, tracer, fn_state);
        } else {
            return block_750(state, tracer, fn_state);
        };
    }
    fn block_750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_750_0: const #0u : u8
        let s_750_0: bool = false;
        // D s_750_1: write-var gs#117881 <= s_750_0
        fn_state.gs_117881 = s_750_0;
        // N s_750_2: jump b751
        return block_751(state, tracer, fn_state);
    }
    fn block_751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_751_0: read-var gs#117881:u8
        let s_751_0: bool = fn_state.gs_117881;
        // N s_751_1: branch s_751_0 b5253 b752
        if s_751_0 {
            return block_5253(state, tracer, fn_state);
        } else {
            return block_752(state, tracer, fn_state);
        };
    }
    fn block_752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_752_0: const #0u : u8
        let s_752_0: bool = false;
        // D s_752_1: write-var gs#117882 <= s_752_0
        fn_state.gs_117882 = s_752_0;
        // N s_752_2: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_753_0: read-var gs#117882:u8
        let s_753_0: bool = fn_state.gs_117882;
        // N s_753_1: branch s_753_0 b5252 b754
        if s_753_0 {
            return block_5252(state, tracer, fn_state);
        } else {
            return block_754(state, tracer, fn_state);
        };
    }
    fn block_754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_754_0: const #0u : u8
        let s_754_0: bool = false;
        // D s_754_1: write-var gs#117883 <= s_754_0
        fn_state.gs_117883 = s_754_0;
        // N s_754_2: jump b755
        return block_755(state, tracer, fn_state);
    }
    fn block_755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_755_0: read-var gs#117883:u8
        let s_755_0: bool = fn_state.gs_117883;
        // N s_755_1: branch s_755_0 b5251 b756
        if s_755_0 {
            return block_5251(state, tracer, fn_state);
        } else {
            return block_756(state, tracer, fn_state);
        };
    }
    fn block_756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_756_0: read-var CRm:u8
        let s_756_0: u8 = fn_state.CRm;
        // D s_756_1: cast zx s_756_0 -> bv
        let s_756_1: Bits = Bits::new(s_756_0 as u128, 4u16);
        // C s_756_2: const #4u : u8
        let s_756_2: u8 = 4;
        // C s_756_3: cast zx s_756_2 -> bv
        let s_756_3: Bits = Bits::new(s_756_2 as u128, 4u16);
        // D s_756_4: cmp-eq s_756_1 s_756_3
        let s_756_4: bool = ((s_756_1) == (s_756_3));
        // N s_756_5: branch s_756_4 b5250 b757
        if s_756_4 {
            return block_5250(state, tracer, fn_state);
        } else {
            return block_757(state, tracer, fn_state);
        };
    }
    fn block_757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_757_0: const #0u : u8
        let s_757_0: bool = false;
        // D s_757_1: write-var gs#117884 <= s_757_0
        fn_state.gs_117884 = s_757_0;
        // N s_757_2: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_758_0: read-var gs#117884:u8
        let s_758_0: bool = fn_state.gs_117884;
        // N s_758_1: branch s_758_0 b5249 b759
        if s_758_0 {
            return block_5249(state, tracer, fn_state);
        } else {
            return block_759(state, tracer, fn_state);
        };
    }
    fn block_759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_759_0: const #0u : u8
        let s_759_0: bool = false;
        // D s_759_1: write-var gs#117885 <= s_759_0
        fn_state.gs_117885 = s_759_0;
        // N s_759_2: jump b760
        return block_760(state, tracer, fn_state);
    }
    fn block_760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_760_0: read-var gs#117885:u8
        let s_760_0: bool = fn_state.gs_117885;
        // N s_760_1: branch s_760_0 b5248 b761
        if s_760_0 {
            return block_5248(state, tracer, fn_state);
        } else {
            return block_761(state, tracer, fn_state);
        };
    }
    fn block_761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_761_0: const #0u : u8
        let s_761_0: bool = false;
        // D s_761_1: write-var gs#117886 <= s_761_0
        fn_state.gs_117886 = s_761_0;
        // N s_761_2: jump b762
        return block_762(state, tracer, fn_state);
    }
    fn block_762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_762_0: read-var gs#117886:u8
        let s_762_0: bool = fn_state.gs_117886;
        // N s_762_1: branch s_762_0 b5247 b763
        if s_762_0 {
            return block_5247(state, tracer, fn_state);
        } else {
            return block_763(state, tracer, fn_state);
        };
    }
    fn block_763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_763_0: const #0u : u8
        let s_763_0: bool = false;
        // D s_763_1: write-var gs#117887 <= s_763_0
        fn_state.gs_117887 = s_763_0;
        // N s_763_2: jump b764
        return block_764(state, tracer, fn_state);
    }
    fn block_764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_764_0: read-var gs#117887:u8
        let s_764_0: bool = fn_state.gs_117887;
        // N s_764_1: branch s_764_0 b5246 b765
        if s_764_0 {
            return block_5246(state, tracer, fn_state);
        } else {
            return block_765(state, tracer, fn_state);
        };
    }
    fn block_765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_765_0: read-var CRm:u8
        let s_765_0: u8 = fn_state.CRm;
        // D s_765_1: cast zx s_765_0 -> bv
        let s_765_1: Bits = Bits::new(s_765_0 as u128, 4u16);
        // C s_765_2: const #3u : u8
        let s_765_2: u8 = 3;
        // C s_765_3: cast zx s_765_2 -> bv
        let s_765_3: Bits = Bits::new(s_765_2 as u128, 4u16);
        // D s_765_4: cmp-eq s_765_1 s_765_3
        let s_765_4: bool = ((s_765_1) == (s_765_3));
        // N s_765_5: branch s_765_4 b5245 b766
        if s_765_4 {
            return block_5245(state, tracer, fn_state);
        } else {
            return block_766(state, tracer, fn_state);
        };
    }
    fn block_766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_766_0: const #0u : u8
        let s_766_0: bool = false;
        // D s_766_1: write-var gs#117888 <= s_766_0
        fn_state.gs_117888 = s_766_0;
        // N s_766_2: jump b767
        return block_767(state, tracer, fn_state);
    }
    fn block_767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_767_0: read-var gs#117888:u8
        let s_767_0: bool = fn_state.gs_117888;
        // N s_767_1: branch s_767_0 b5244 b768
        if s_767_0 {
            return block_5244(state, tracer, fn_state);
        } else {
            return block_768(state, tracer, fn_state);
        };
    }
    fn block_768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_768_0: const #0u : u8
        let s_768_0: bool = false;
        // D s_768_1: write-var gs#117889 <= s_768_0
        fn_state.gs_117889 = s_768_0;
        // N s_768_2: jump b769
        return block_769(state, tracer, fn_state);
    }
    fn block_769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_769_0: read-var gs#117889:u8
        let s_769_0: bool = fn_state.gs_117889;
        // N s_769_1: branch s_769_0 b5243 b770
        if s_769_0 {
            return block_5243(state, tracer, fn_state);
        } else {
            return block_770(state, tracer, fn_state);
        };
    }
    fn block_770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_770_0: const #0u : u8
        let s_770_0: bool = false;
        // D s_770_1: write-var gs#117890 <= s_770_0
        fn_state.gs_117890 = s_770_0;
        // N s_770_2: jump b771
        return block_771(state, tracer, fn_state);
    }
    fn block_771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_771_0: read-var gs#117890:u8
        let s_771_0: bool = fn_state.gs_117890;
        // N s_771_1: branch s_771_0 b5242 b772
        if s_771_0 {
            return block_5242(state, tracer, fn_state);
        } else {
            return block_772(state, tracer, fn_state);
        };
    }
    fn block_772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_772_0: const #0u : u8
        let s_772_0: bool = false;
        // D s_772_1: write-var gs#117891 <= s_772_0
        fn_state.gs_117891 = s_772_0;
        // N s_772_2: jump b773
        return block_773(state, tracer, fn_state);
    }
    fn block_773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_773_0: read-var gs#117891:u8
        let s_773_0: bool = fn_state.gs_117891;
        // N s_773_1: branch s_773_0 b5241 b774
        if s_773_0 {
            return block_5241(state, tracer, fn_state);
        } else {
            return block_774(state, tracer, fn_state);
        };
    }
    fn block_774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_774_0: read-var CRm:u8
        let s_774_0: u8 = fn_state.CRm;
        // D s_774_1: cast zx s_774_0 -> bv
        let s_774_1: Bits = Bits::new(s_774_0 as u128, 4u16);
        // C s_774_2: const #2u : u8
        let s_774_2: u8 = 2;
        // C s_774_3: cast zx s_774_2 -> bv
        let s_774_3: Bits = Bits::new(s_774_2 as u128, 4u16);
        // D s_774_4: cmp-eq s_774_1 s_774_3
        let s_774_4: bool = ((s_774_1) == (s_774_3));
        // N s_774_5: branch s_774_4 b5240 b775
        if s_774_4 {
            return block_5240(state, tracer, fn_state);
        } else {
            return block_775(state, tracer, fn_state);
        };
    }
    fn block_775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_775_0: const #0u : u8
        let s_775_0: bool = false;
        // D s_775_1: write-var gs#117892 <= s_775_0
        fn_state.gs_117892 = s_775_0;
        // N s_775_2: jump b776
        return block_776(state, tracer, fn_state);
    }
    fn block_776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_776_0: read-var gs#117892:u8
        let s_776_0: bool = fn_state.gs_117892;
        // N s_776_1: branch s_776_0 b5239 b777
        if s_776_0 {
            return block_5239(state, tracer, fn_state);
        } else {
            return block_777(state, tracer, fn_state);
        };
    }
    fn block_777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_777_0: const #0u : u8
        let s_777_0: bool = false;
        // D s_777_1: write-var gs#117893 <= s_777_0
        fn_state.gs_117893 = s_777_0;
        // N s_777_2: jump b778
        return block_778(state, tracer, fn_state);
    }
    fn block_778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_778_0: read-var gs#117893:u8
        let s_778_0: bool = fn_state.gs_117893;
        // N s_778_1: branch s_778_0 b5238 b779
        if s_778_0 {
            return block_5238(state, tracer, fn_state);
        } else {
            return block_779(state, tracer, fn_state);
        };
    }
    fn block_779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_779_0: const #0u : u8
        let s_779_0: bool = false;
        // D s_779_1: write-var gs#117894 <= s_779_0
        fn_state.gs_117894 = s_779_0;
        // N s_779_2: jump b780
        return block_780(state, tracer, fn_state);
    }
    fn block_780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_780_0: read-var gs#117894:u8
        let s_780_0: bool = fn_state.gs_117894;
        // N s_780_1: branch s_780_0 b5237 b781
        if s_780_0 {
            return block_5237(state, tracer, fn_state);
        } else {
            return block_781(state, tracer, fn_state);
        };
    }
    fn block_781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_781_0: const #0u : u8
        let s_781_0: bool = false;
        // D s_781_1: write-var gs#117895 <= s_781_0
        fn_state.gs_117895 = s_781_0;
        // N s_781_2: jump b782
        return block_782(state, tracer, fn_state);
    }
    fn block_782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_782_0: read-var gs#117895:u8
        let s_782_0: bool = fn_state.gs_117895;
        // N s_782_1: branch s_782_0 b5236 b783
        if s_782_0 {
            return block_5236(state, tracer, fn_state);
        } else {
            return block_783(state, tracer, fn_state);
        };
    }
    fn block_783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_783_0: read-var CRm:u8
        let s_783_0: u8 = fn_state.CRm;
        // D s_783_1: cast zx s_783_0 -> bv
        let s_783_1: Bits = Bits::new(s_783_0 as u128, 4u16);
        // C s_783_2: const #1u : u8
        let s_783_2: u8 = 1;
        // C s_783_3: cast zx s_783_2 -> bv
        let s_783_3: Bits = Bits::new(s_783_2 as u128, 4u16);
        // D s_783_4: cmp-eq s_783_1 s_783_3
        let s_783_4: bool = ((s_783_1) == (s_783_3));
        // N s_783_5: branch s_783_4 b5235 b784
        if s_783_4 {
            return block_5235(state, tracer, fn_state);
        } else {
            return block_784(state, tracer, fn_state);
        };
    }
    fn block_784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_784_0: const #0u : u8
        let s_784_0: bool = false;
        // D s_784_1: write-var gs#117896 <= s_784_0
        fn_state.gs_117896 = s_784_0;
        // N s_784_2: jump b785
        return block_785(state, tracer, fn_state);
    }
    fn block_785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_785_0: read-var gs#117896:u8
        let s_785_0: bool = fn_state.gs_117896;
        // N s_785_1: branch s_785_0 b5234 b786
        if s_785_0 {
            return block_5234(state, tracer, fn_state);
        } else {
            return block_786(state, tracer, fn_state);
        };
    }
    fn block_786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_786_0: const #0u : u8
        let s_786_0: bool = false;
        // D s_786_1: write-var gs#117897 <= s_786_0
        fn_state.gs_117897 = s_786_0;
        // N s_786_2: jump b787
        return block_787(state, tracer, fn_state);
    }
    fn block_787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_787_0: read-var gs#117897:u8
        let s_787_0: bool = fn_state.gs_117897;
        // N s_787_1: branch s_787_0 b5233 b788
        if s_787_0 {
            return block_5233(state, tracer, fn_state);
        } else {
            return block_788(state, tracer, fn_state);
        };
    }
    fn block_788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_788_0: const #0u : u8
        let s_788_0: bool = false;
        // D s_788_1: write-var gs#117898 <= s_788_0
        fn_state.gs_117898 = s_788_0;
        // N s_788_2: jump b789
        return block_789(state, tracer, fn_state);
    }
    fn block_789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_789_0: read-var gs#117898:u8
        let s_789_0: bool = fn_state.gs_117898;
        // N s_789_1: branch s_789_0 b5232 b790
        if s_789_0 {
            return block_5232(state, tracer, fn_state);
        } else {
            return block_790(state, tracer, fn_state);
        };
    }
    fn block_790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_790_0: const #0u : u8
        let s_790_0: bool = false;
        // D s_790_1: write-var gs#117899 <= s_790_0
        fn_state.gs_117899 = s_790_0;
        // N s_790_2: jump b791
        return block_791(state, tracer, fn_state);
    }
    fn block_791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_791_0: read-var gs#117899:u8
        let s_791_0: bool = fn_state.gs_117899;
        // N s_791_1: branch s_791_0 b5231 b792
        if s_791_0 {
            return block_5231(state, tracer, fn_state);
        } else {
            return block_792(state, tracer, fn_state);
        };
    }
    fn block_792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_792_0: read-var CRm:u8
        let s_792_0: u8 = fn_state.CRm;
        // D s_792_1: cast zx s_792_0 -> bv
        let s_792_1: Bits = Bits::new(s_792_0 as u128, 4u16);
        // C s_792_2: const #0u : u8
        let s_792_2: u8 = 0;
        // C s_792_3: cast zx s_792_2 -> bv
        let s_792_3: Bits = Bits::new(s_792_2 as u128, 4u16);
        // D s_792_4: cmp-eq s_792_1 s_792_3
        let s_792_4: bool = ((s_792_1) == (s_792_3));
        // N s_792_5: branch s_792_4 b5230 b793
        if s_792_4 {
            return block_5230(state, tracer, fn_state);
        } else {
            return block_793(state, tracer, fn_state);
        };
    }
    fn block_793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_793_0: const #0u : u8
        let s_793_0: bool = false;
        // D s_793_1: write-var gs#117900 <= s_793_0
        fn_state.gs_117900 = s_793_0;
        // N s_793_2: jump b794
        return block_794(state, tracer, fn_state);
    }
    fn block_794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_794_0: read-var gs#117900:u8
        let s_794_0: bool = fn_state.gs_117900;
        // N s_794_1: branch s_794_0 b5229 b795
        if s_794_0 {
            return block_5229(state, tracer, fn_state);
        } else {
            return block_795(state, tracer, fn_state);
        };
    }
    fn block_795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_795_0: const #0u : u8
        let s_795_0: bool = false;
        // D s_795_1: write-var gs#117901 <= s_795_0
        fn_state.gs_117901 = s_795_0;
        // N s_795_2: jump b796
        return block_796(state, tracer, fn_state);
    }
    fn block_796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_796_0: read-var gs#117901:u8
        let s_796_0: bool = fn_state.gs_117901;
        // N s_796_1: branch s_796_0 b5228 b797
        if s_796_0 {
            return block_5228(state, tracer, fn_state);
        } else {
            return block_797(state, tracer, fn_state);
        };
    }
    fn block_797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_797_0: const #0u : u8
        let s_797_0: bool = false;
        // D s_797_1: write-var gs#117902 <= s_797_0
        fn_state.gs_117902 = s_797_0;
        // N s_797_2: jump b798
        return block_798(state, tracer, fn_state);
    }
    fn block_798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_798_0: read-var gs#117902:u8
        let s_798_0: bool = fn_state.gs_117902;
        // N s_798_1: branch s_798_0 b5227 b799
        if s_798_0 {
            return block_5227(state, tracer, fn_state);
        } else {
            return block_799(state, tracer, fn_state);
        };
    }
    fn block_799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_799_0: const #0u : u8
        let s_799_0: bool = false;
        // D s_799_1: write-var gs#117903 <= s_799_0
        fn_state.gs_117903 = s_799_0;
        // N s_799_2: jump b800
        return block_800(state, tracer, fn_state);
    }
    fn block_800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_800_0: read-var gs#117903:u8
        let s_800_0: bool = fn_state.gs_117903;
        // N s_800_1: branch s_800_0 b5226 b801
        if s_800_0 {
            return block_5226(state, tracer, fn_state);
        } else {
            return block_801(state, tracer, fn_state);
        };
    }
    fn block_801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_801_0: read-var CRm:u8
        let s_801_0: u8 = fn_state.CRm;
        // D s_801_1: cast zx s_801_0 -> bv
        let s_801_1: Bits = Bits::new(s_801_0 as u128, 4u16);
        // C s_801_2: const #12u : u8
        let s_801_2: u8 = 12;
        // C s_801_3: cast zx s_801_2 -> bv
        let s_801_3: Bits = Bits::new(s_801_2 as u128, 4u16);
        // D s_801_4: cmp-eq s_801_1 s_801_3
        let s_801_4: bool = ((s_801_1) == (s_801_3));
        // N s_801_5: branch s_801_4 b5225 b802
        if s_801_4 {
            return block_5225(state, tracer, fn_state);
        } else {
            return block_802(state, tracer, fn_state);
        };
    }
    fn block_802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_802_0: const #0u : u8
        let s_802_0: bool = false;
        // D s_802_1: write-var gs#117904 <= s_802_0
        fn_state.gs_117904 = s_802_0;
        // N s_802_2: jump b803
        return block_803(state, tracer, fn_state);
    }
    fn block_803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_803_0: read-var gs#117904:u8
        let s_803_0: bool = fn_state.gs_117904;
        // N s_803_1: branch s_803_0 b5224 b804
        if s_803_0 {
            return block_5224(state, tracer, fn_state);
        } else {
            return block_804(state, tracer, fn_state);
        };
    }
    fn block_804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_804_0: const #0u : u8
        let s_804_0: bool = false;
        // D s_804_1: write-var gs#117905 <= s_804_0
        fn_state.gs_117905 = s_804_0;
        // N s_804_2: jump b805
        return block_805(state, tracer, fn_state);
    }
    fn block_805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_805_0: read-var gs#117905:u8
        let s_805_0: bool = fn_state.gs_117905;
        // N s_805_1: branch s_805_0 b5223 b806
        if s_805_0 {
            return block_5223(state, tracer, fn_state);
        } else {
            return block_806(state, tracer, fn_state);
        };
    }
    fn block_806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_806_0: const #0u : u8
        let s_806_0: bool = false;
        // D s_806_1: write-var gs#117906 <= s_806_0
        fn_state.gs_117906 = s_806_0;
        // N s_806_2: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_807_0: read-var gs#117906:u8
        let s_807_0: bool = fn_state.gs_117906;
        // N s_807_1: branch s_807_0 b5222 b808
        if s_807_0 {
            return block_5222(state, tracer, fn_state);
        } else {
            return block_808(state, tracer, fn_state);
        };
    }
    fn block_808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_808_0: const #0u : u8
        let s_808_0: bool = false;
        // D s_808_1: write-var gs#117907 <= s_808_0
        fn_state.gs_117907 = s_808_0;
        // N s_808_2: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_809_0: read-var gs#117907:u8
        let s_809_0: bool = fn_state.gs_117907;
        // N s_809_1: branch s_809_0 b5221 b810
        if s_809_0 {
            return block_5221(state, tracer, fn_state);
        } else {
            return block_810(state, tracer, fn_state);
        };
    }
    fn block_810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_810_0: read-var CRm:u8
        let s_810_0: u8 = fn_state.CRm;
        // D s_810_1: cast zx s_810_0 -> bv
        let s_810_1: Bits = Bits::new(s_810_0 as u128, 4u16);
        // C s_810_2: const #3u : u8
        let s_810_2: u8 = 3;
        // C s_810_3: cast zx s_810_2 -> bv
        let s_810_3: Bits = Bits::new(s_810_2 as u128, 4u16);
        // D s_810_4: cmp-eq s_810_1 s_810_3
        let s_810_4: bool = ((s_810_1) == (s_810_3));
        // N s_810_5: branch s_810_4 b5220 b811
        if s_810_4 {
            return block_5220(state, tracer, fn_state);
        } else {
            return block_811(state, tracer, fn_state);
        };
    }
    fn block_811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_811_0: const #0u : u8
        let s_811_0: bool = false;
        // D s_811_1: write-var gs#117908 <= s_811_0
        fn_state.gs_117908 = s_811_0;
        // N s_811_2: jump b812
        return block_812(state, tracer, fn_state);
    }
    fn block_812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_812_0: read-var gs#117908:u8
        let s_812_0: bool = fn_state.gs_117908;
        // N s_812_1: branch s_812_0 b5219 b813
        if s_812_0 {
            return block_5219(state, tracer, fn_state);
        } else {
            return block_813(state, tracer, fn_state);
        };
    }
    fn block_813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_813_0: const #0u : u8
        let s_813_0: bool = false;
        // D s_813_1: write-var gs#117909 <= s_813_0
        fn_state.gs_117909 = s_813_0;
        // N s_813_2: jump b814
        return block_814(state, tracer, fn_state);
    }
    fn block_814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_814_0: read-var gs#117909:u8
        let s_814_0: bool = fn_state.gs_117909;
        // N s_814_1: branch s_814_0 b5218 b815
        if s_814_0 {
            return block_5218(state, tracer, fn_state);
        } else {
            return block_815(state, tracer, fn_state);
        };
    }
    fn block_815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_815_0: const #0u : u8
        let s_815_0: bool = false;
        // D s_815_1: write-var gs#117910 <= s_815_0
        fn_state.gs_117910 = s_815_0;
        // N s_815_2: jump b816
        return block_816(state, tracer, fn_state);
    }
    fn block_816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_816_0: read-var gs#117910:u8
        let s_816_0: bool = fn_state.gs_117910;
        // N s_816_1: branch s_816_0 b5217 b817
        if s_816_0 {
            return block_5217(state, tracer, fn_state);
        } else {
            return block_817(state, tracer, fn_state);
        };
    }
    fn block_817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_817_0: const #0u : u8
        let s_817_0: bool = false;
        // D s_817_1: write-var gs#117911 <= s_817_0
        fn_state.gs_117911 = s_817_0;
        // N s_817_2: jump b818
        return block_818(state, tracer, fn_state);
    }
    fn block_818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_818_0: read-var gs#117911:u8
        let s_818_0: bool = fn_state.gs_117911;
        // N s_818_1: branch s_818_0 b5216 b819
        if s_818_0 {
            return block_5216(state, tracer, fn_state);
        } else {
            return block_819(state, tracer, fn_state);
        };
    }
    fn block_819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_819_0: read-var CRm:u8
        let s_819_0: u8 = fn_state.CRm;
        // D s_819_1: cast zx s_819_0 -> bv
        let s_819_1: Bits = Bits::new(s_819_0 as u128, 4u16);
        // C s_819_2: const #8u : u8
        let s_819_2: u8 = 8;
        // C s_819_3: cast zx s_819_2 -> bv
        let s_819_3: Bits = Bits::new(s_819_2 as u128, 4u16);
        // D s_819_4: cmp-eq s_819_1 s_819_3
        let s_819_4: bool = ((s_819_1) == (s_819_3));
        // N s_819_5: branch s_819_4 b5215 b820
        if s_819_4 {
            return block_5215(state, tracer, fn_state);
        } else {
            return block_820(state, tracer, fn_state);
        };
    }
    fn block_820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_820_0: const #0u : u8
        let s_820_0: bool = false;
        // D s_820_1: write-var gs#117912 <= s_820_0
        fn_state.gs_117912 = s_820_0;
        // N s_820_2: jump b821
        return block_821(state, tracer, fn_state);
    }
    fn block_821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_821_0: read-var gs#117912:u8
        let s_821_0: bool = fn_state.gs_117912;
        // N s_821_1: branch s_821_0 b5214 b822
        if s_821_0 {
            return block_5214(state, tracer, fn_state);
        } else {
            return block_822(state, tracer, fn_state);
        };
    }
    fn block_822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_822_0: const #0u : u8
        let s_822_0: bool = false;
        // D s_822_1: write-var gs#117913 <= s_822_0
        fn_state.gs_117913 = s_822_0;
        // N s_822_2: jump b823
        return block_823(state, tracer, fn_state);
    }
    fn block_823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_823_0: read-var gs#117913:u8
        let s_823_0: bool = fn_state.gs_117913;
        // N s_823_1: branch s_823_0 b5213 b824
        if s_823_0 {
            return block_5213(state, tracer, fn_state);
        } else {
            return block_824(state, tracer, fn_state);
        };
    }
    fn block_824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_824_0: const #0u : u8
        let s_824_0: bool = false;
        // D s_824_1: write-var gs#117914 <= s_824_0
        fn_state.gs_117914 = s_824_0;
        // N s_824_2: jump b825
        return block_825(state, tracer, fn_state);
    }
    fn block_825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_825_0: read-var gs#117914:u8
        let s_825_0: bool = fn_state.gs_117914;
        // N s_825_1: branch s_825_0 b5212 b826
        if s_825_0 {
            return block_5212(state, tracer, fn_state);
        } else {
            return block_826(state, tracer, fn_state);
        };
    }
    fn block_826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_826_0: const #0u : u8
        let s_826_0: bool = false;
        // D s_826_1: write-var gs#117915 <= s_826_0
        fn_state.gs_117915 = s_826_0;
        // N s_826_2: jump b827
        return block_827(state, tracer, fn_state);
    }
    fn block_827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_827_0: read-var gs#117915:u8
        let s_827_0: bool = fn_state.gs_117915;
        // N s_827_1: branch s_827_0 b5211 b828
        if s_827_0 {
            return block_5211(state, tracer, fn_state);
        } else {
            return block_828(state, tracer, fn_state);
        };
    }
    fn block_828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_828_0: read-var CRm:u8
        let s_828_0: u8 = fn_state.CRm;
        // D s_828_1: cast zx s_828_0 -> bv
        let s_828_1: Bits = Bits::new(s_828_0 as u128, 4u16);
        // C s_828_2: const #8u : u8
        let s_828_2: u8 = 8;
        // C s_828_3: cast zx s_828_2 -> bv
        let s_828_3: Bits = Bits::new(s_828_2 as u128, 4u16);
        // D s_828_4: cmp-eq s_828_1 s_828_3
        let s_828_4: bool = ((s_828_1) == (s_828_3));
        // N s_828_5: branch s_828_4 b5210 b829
        if s_828_4 {
            return block_5210(state, tracer, fn_state);
        } else {
            return block_829(state, tracer, fn_state);
        };
    }
    fn block_829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_829_0: const #0u : u8
        let s_829_0: bool = false;
        // D s_829_1: write-var gs#117916 <= s_829_0
        fn_state.gs_117916 = s_829_0;
        // N s_829_2: jump b830
        return block_830(state, tracer, fn_state);
    }
    fn block_830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_830_0: read-var gs#117916:u8
        let s_830_0: bool = fn_state.gs_117916;
        // N s_830_1: branch s_830_0 b5209 b831
        if s_830_0 {
            return block_5209(state, tracer, fn_state);
        } else {
            return block_831(state, tracer, fn_state);
        };
    }
    fn block_831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_831_0: const #0u : u8
        let s_831_0: bool = false;
        // D s_831_1: write-var gs#117917 <= s_831_0
        fn_state.gs_117917 = s_831_0;
        // N s_831_2: jump b832
        return block_832(state, tracer, fn_state);
    }
    fn block_832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_832_0: read-var gs#117917:u8
        let s_832_0: bool = fn_state.gs_117917;
        // N s_832_1: branch s_832_0 b5208 b833
        if s_832_0 {
            return block_5208(state, tracer, fn_state);
        } else {
            return block_833(state, tracer, fn_state);
        };
    }
    fn block_833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_833_0: const #0u : u8
        let s_833_0: bool = false;
        // D s_833_1: write-var gs#117918 <= s_833_0
        fn_state.gs_117918 = s_833_0;
        // N s_833_2: jump b834
        return block_834(state, tracer, fn_state);
    }
    fn block_834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_834_0: read-var gs#117918:u8
        let s_834_0: bool = fn_state.gs_117918;
        // N s_834_1: branch s_834_0 b5207 b835
        if s_834_0 {
            return block_5207(state, tracer, fn_state);
        } else {
            return block_835(state, tracer, fn_state);
        };
    }
    fn block_835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_835_0: const #0u : u8
        let s_835_0: bool = false;
        // D s_835_1: write-var gs#117919 <= s_835_0
        fn_state.gs_117919 = s_835_0;
        // N s_835_2: jump b836
        return block_836(state, tracer, fn_state);
    }
    fn block_836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_836_0: read-var gs#117919:u8
        let s_836_0: bool = fn_state.gs_117919;
        // N s_836_1: branch s_836_0 b5206 b837
        if s_836_0 {
            return block_5206(state, tracer, fn_state);
        } else {
            return block_837(state, tracer, fn_state);
        };
    }
    fn block_837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_837_0: read-var CRm:u8
        let s_837_0: u8 = fn_state.CRm;
        // D s_837_1: cast zx s_837_0 -> bv
        let s_837_1: Bits = Bits::new(s_837_0 as u128, 4u16);
        // C s_837_2: const #8u : u8
        let s_837_2: u8 = 8;
        // C s_837_3: cast zx s_837_2 -> bv
        let s_837_3: Bits = Bits::new(s_837_2 as u128, 4u16);
        // D s_837_4: cmp-eq s_837_1 s_837_3
        let s_837_4: bool = ((s_837_1) == (s_837_3));
        // N s_837_5: branch s_837_4 b5205 b838
        if s_837_4 {
            return block_5205(state, tracer, fn_state);
        } else {
            return block_838(state, tracer, fn_state);
        };
    }
    fn block_838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_838_0: const #0u : u8
        let s_838_0: bool = false;
        // D s_838_1: write-var gs#117920 <= s_838_0
        fn_state.gs_117920 = s_838_0;
        // N s_838_2: jump b839
        return block_839(state, tracer, fn_state);
    }
    fn block_839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_839_0: read-var gs#117920:u8
        let s_839_0: bool = fn_state.gs_117920;
        // N s_839_1: branch s_839_0 b5204 b840
        if s_839_0 {
            return block_5204(state, tracer, fn_state);
        } else {
            return block_840(state, tracer, fn_state);
        };
    }
    fn block_840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_840_0: const #0u : u8
        let s_840_0: bool = false;
        // D s_840_1: write-var gs#117921 <= s_840_0
        fn_state.gs_117921 = s_840_0;
        // N s_840_2: jump b841
        return block_841(state, tracer, fn_state);
    }
    fn block_841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_841_0: read-var gs#117921:u8
        let s_841_0: bool = fn_state.gs_117921;
        // N s_841_1: branch s_841_0 b5203 b842
        if s_841_0 {
            return block_5203(state, tracer, fn_state);
        } else {
            return block_842(state, tracer, fn_state);
        };
    }
    fn block_842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_842_0: const #0u : u8
        let s_842_0: bool = false;
        // D s_842_1: write-var gs#117922 <= s_842_0
        fn_state.gs_117922 = s_842_0;
        // N s_842_2: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_843_0: read-var gs#117922:u8
        let s_843_0: bool = fn_state.gs_117922;
        // N s_843_1: branch s_843_0 b5202 b844
        if s_843_0 {
            return block_5202(state, tracer, fn_state);
        } else {
            return block_844(state, tracer, fn_state);
        };
    }
    fn block_844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_844_0: const #0u : u8
        let s_844_0: bool = false;
        // D s_844_1: write-var gs#117923 <= s_844_0
        fn_state.gs_117923 = s_844_0;
        // N s_844_2: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_845_0: read-var gs#117923:u8
        let s_845_0: bool = fn_state.gs_117923;
        // N s_845_1: branch s_845_0 b5201 b846
        if s_845_0 {
            return block_5201(state, tracer, fn_state);
        } else {
            return block_846(state, tracer, fn_state);
        };
    }
    fn block_846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_846_0: read-var CRm:u8
        let s_846_0: u8 = fn_state.CRm;
        // D s_846_1: cast zx s_846_0 -> bv
        let s_846_1: Bits = Bits::new(s_846_0 as u128, 4u16);
        // C s_846_2: const #8u : u8
        let s_846_2: u8 = 8;
        // C s_846_3: cast zx s_846_2 -> bv
        let s_846_3: Bits = Bits::new(s_846_2 as u128, 4u16);
        // D s_846_4: cmp-eq s_846_1 s_846_3
        let s_846_4: bool = ((s_846_1) == (s_846_3));
        // N s_846_5: branch s_846_4 b5200 b847
        if s_846_4 {
            return block_5200(state, tracer, fn_state);
        } else {
            return block_847(state, tracer, fn_state);
        };
    }
    fn block_847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_847_0: const #0u : u8
        let s_847_0: bool = false;
        // D s_847_1: write-var gs#117924 <= s_847_0
        fn_state.gs_117924 = s_847_0;
        // N s_847_2: jump b848
        return block_848(state, tracer, fn_state);
    }
    fn block_848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_848_0: read-var gs#117924:u8
        let s_848_0: bool = fn_state.gs_117924;
        // N s_848_1: branch s_848_0 b5199 b849
        if s_848_0 {
            return block_5199(state, tracer, fn_state);
        } else {
            return block_849(state, tracer, fn_state);
        };
    }
    fn block_849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_849_0: const #0u : u8
        let s_849_0: bool = false;
        // D s_849_1: write-var gs#117925 <= s_849_0
        fn_state.gs_117925 = s_849_0;
        // N s_849_2: jump b850
        return block_850(state, tracer, fn_state);
    }
    fn block_850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_850_0: read-var gs#117925:u8
        let s_850_0: bool = fn_state.gs_117925;
        // N s_850_1: branch s_850_0 b5198 b851
        if s_850_0 {
            return block_5198(state, tracer, fn_state);
        } else {
            return block_851(state, tracer, fn_state);
        };
    }
    fn block_851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_851_0: const #0u : u8
        let s_851_0: bool = false;
        // D s_851_1: write-var gs#117926 <= s_851_0
        fn_state.gs_117926 = s_851_0;
        // N s_851_2: jump b852
        return block_852(state, tracer, fn_state);
    }
    fn block_852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_852_0: read-var gs#117926:u8
        let s_852_0: bool = fn_state.gs_117926;
        // N s_852_1: branch s_852_0 b5197 b853
        if s_852_0 {
            return block_5197(state, tracer, fn_state);
        } else {
            return block_853(state, tracer, fn_state);
        };
    }
    fn block_853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_853_0: const #0u : u8
        let s_853_0: bool = false;
        // D s_853_1: write-var gs#117927 <= s_853_0
        fn_state.gs_117927 = s_853_0;
        // N s_853_2: jump b854
        return block_854(state, tracer, fn_state);
    }
    fn block_854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_854_0: read-var gs#117927:u8
        let s_854_0: bool = fn_state.gs_117927;
        // N s_854_1: branch s_854_0 b5196 b855
        if s_854_0 {
            return block_5196(state, tracer, fn_state);
        } else {
            return block_855(state, tracer, fn_state);
        };
    }
    fn block_855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_855_0: read-var CRm:u8
        let s_855_0: u8 = fn_state.CRm;
        // D s_855_1: cast zx s_855_0 -> bv
        let s_855_1: Bits = Bits::new(s_855_0 as u128, 4u16);
        // C s_855_2: const #0u : u8
        let s_855_2: u8 = 0;
        // C s_855_3: cast zx s_855_2 -> bv
        let s_855_3: Bits = Bits::new(s_855_2 as u128, 4u16);
        // D s_855_4: cmp-eq s_855_1 s_855_3
        let s_855_4: bool = ((s_855_1) == (s_855_3));
        // N s_855_5: branch s_855_4 b5195 b856
        if s_855_4 {
            return block_5195(state, tracer, fn_state);
        } else {
            return block_856(state, tracer, fn_state);
        };
    }
    fn block_856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_856_0: const #0u : u8
        let s_856_0: bool = false;
        // D s_856_1: write-var gs#117928 <= s_856_0
        fn_state.gs_117928 = s_856_0;
        // N s_856_2: jump b857
        return block_857(state, tracer, fn_state);
    }
    fn block_857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_857_0: read-var gs#117928:u8
        let s_857_0: bool = fn_state.gs_117928;
        // N s_857_1: branch s_857_0 b5194 b858
        if s_857_0 {
            return block_5194(state, tracer, fn_state);
        } else {
            return block_858(state, tracer, fn_state);
        };
    }
    fn block_858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_858_0: const #0u : u8
        let s_858_0: bool = false;
        // D s_858_1: write-var gs#117929 <= s_858_0
        fn_state.gs_117929 = s_858_0;
        // N s_858_2: jump b859
        return block_859(state, tracer, fn_state);
    }
    fn block_859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_859_0: read-var gs#117929:u8
        let s_859_0: bool = fn_state.gs_117929;
        // N s_859_1: branch s_859_0 b5193 b860
        if s_859_0 {
            return block_5193(state, tracer, fn_state);
        } else {
            return block_860(state, tracer, fn_state);
        };
    }
    fn block_860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_860_0: const #0u : u8
        let s_860_0: bool = false;
        // D s_860_1: write-var gs#117930 <= s_860_0
        fn_state.gs_117930 = s_860_0;
        // N s_860_2: jump b861
        return block_861(state, tracer, fn_state);
    }
    fn block_861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_861_0: read-var gs#117930:u8
        let s_861_0: bool = fn_state.gs_117930;
        // N s_861_1: branch s_861_0 b5192 b862
        if s_861_0 {
            return block_5192(state, tracer, fn_state);
        } else {
            return block_862(state, tracer, fn_state);
        };
    }
    fn block_862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_862_0: const #0u : u8
        let s_862_0: bool = false;
        // D s_862_1: write-var gs#117931 <= s_862_0
        fn_state.gs_117931 = s_862_0;
        // N s_862_2: jump b863
        return block_863(state, tracer, fn_state);
    }
    fn block_863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_863_0: read-var gs#117931:u8
        let s_863_0: bool = fn_state.gs_117931;
        // N s_863_1: branch s_863_0 b5191 b864
        if s_863_0 {
            return block_5191(state, tracer, fn_state);
        } else {
            return block_864(state, tracer, fn_state);
        };
    }
    fn block_864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_864_0: read-var CRm:u8
        let s_864_0: u8 = fn_state.CRm;
        // D s_864_1: cast zx s_864_0 -> bv
        let s_864_1: Bits = Bits::new(s_864_0 as u128, 4u16);
        // C s_864_2: const #1u : u8
        let s_864_2: u8 = 1;
        // C s_864_3: cast zx s_864_2 -> bv
        let s_864_3: Bits = Bits::new(s_864_2 as u128, 4u16);
        // D s_864_4: cmp-eq s_864_1 s_864_3
        let s_864_4: bool = ((s_864_1) == (s_864_3));
        // N s_864_5: branch s_864_4 b5190 b865
        if s_864_4 {
            return block_5190(state, tracer, fn_state);
        } else {
            return block_865(state, tracer, fn_state);
        };
    }
    fn block_865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_865_0: const #0u : u8
        let s_865_0: bool = false;
        // D s_865_1: write-var gs#117932 <= s_865_0
        fn_state.gs_117932 = s_865_0;
        // N s_865_2: jump b866
        return block_866(state, tracer, fn_state);
    }
    fn block_866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_866_0: read-var gs#117932:u8
        let s_866_0: bool = fn_state.gs_117932;
        // N s_866_1: branch s_866_0 b5189 b867
        if s_866_0 {
            return block_5189(state, tracer, fn_state);
        } else {
            return block_867(state, tracer, fn_state);
        };
    }
    fn block_867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_867_0: const #0u : u8
        let s_867_0: bool = false;
        // D s_867_1: write-var gs#117933 <= s_867_0
        fn_state.gs_117933 = s_867_0;
        // N s_867_2: jump b868
        return block_868(state, tracer, fn_state);
    }
    fn block_868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_868_0: read-var gs#117933:u8
        let s_868_0: bool = fn_state.gs_117933;
        // N s_868_1: branch s_868_0 b5188 b869
        if s_868_0 {
            return block_5188(state, tracer, fn_state);
        } else {
            return block_869(state, tracer, fn_state);
        };
    }
    fn block_869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_869_0: const #0u : u8
        let s_869_0: bool = false;
        // D s_869_1: write-var gs#117934 <= s_869_0
        fn_state.gs_117934 = s_869_0;
        // N s_869_2: jump b870
        return block_870(state, tracer, fn_state);
    }
    fn block_870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_870_0: read-var gs#117934:u8
        let s_870_0: bool = fn_state.gs_117934;
        // N s_870_1: branch s_870_0 b5187 b871
        if s_870_0 {
            return block_5187(state, tracer, fn_state);
        } else {
            return block_871(state, tracer, fn_state);
        };
    }
    fn block_871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_871_0: const #0u : u8
        let s_871_0: bool = false;
        // D s_871_1: write-var gs#117935 <= s_871_0
        fn_state.gs_117935 = s_871_0;
        // N s_871_2: jump b872
        return block_872(state, tracer, fn_state);
    }
    fn block_872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_872_0: read-var gs#117935:u8
        let s_872_0: bool = fn_state.gs_117935;
        // N s_872_1: branch s_872_0 b5186 b873
        if s_872_0 {
            return block_5186(state, tracer, fn_state);
        } else {
            return block_873(state, tracer, fn_state);
        };
    }
    fn block_873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_873_0: read-var CRm:u8
        let s_873_0: u8 = fn_state.CRm;
        // D s_873_1: cast zx s_873_0 -> bv
        let s_873_1: Bits = Bits::new(s_873_0 as u128, 4u16);
        // C s_873_2: const #3u : u8
        let s_873_2: u8 = 3;
        // C s_873_3: cast zx s_873_2 -> bv
        let s_873_3: Bits = Bits::new(s_873_2 as u128, 4u16);
        // D s_873_4: cmp-eq s_873_1 s_873_3
        let s_873_4: bool = ((s_873_1) == (s_873_3));
        // N s_873_5: branch s_873_4 b5185 b874
        if s_873_4 {
            return block_5185(state, tracer, fn_state);
        } else {
            return block_874(state, tracer, fn_state);
        };
    }
    fn block_874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_874_0: const #0u : u8
        let s_874_0: bool = false;
        // D s_874_1: write-var gs#117936 <= s_874_0
        fn_state.gs_117936 = s_874_0;
        // N s_874_2: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_875_0: read-var gs#117936:u8
        let s_875_0: bool = fn_state.gs_117936;
        // N s_875_1: branch s_875_0 b5184 b876
        if s_875_0 {
            return block_5184(state, tracer, fn_state);
        } else {
            return block_876(state, tracer, fn_state);
        };
    }
    fn block_876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_876_0: const #0u : u8
        let s_876_0: bool = false;
        // D s_876_1: write-var gs#117937 <= s_876_0
        fn_state.gs_117937 = s_876_0;
        // N s_876_2: jump b877
        return block_877(state, tracer, fn_state);
    }
    fn block_877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_877_0: read-var gs#117937:u8
        let s_877_0: bool = fn_state.gs_117937;
        // N s_877_1: branch s_877_0 b5183 b878
        if s_877_0 {
            return block_5183(state, tracer, fn_state);
        } else {
            return block_878(state, tracer, fn_state);
        };
    }
    fn block_878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_878_0: const #0u : u8
        let s_878_0: bool = false;
        // D s_878_1: write-var gs#117938 <= s_878_0
        fn_state.gs_117938 = s_878_0;
        // N s_878_2: jump b879
        return block_879(state, tracer, fn_state);
    }
    fn block_879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_879_0: read-var gs#117938:u8
        let s_879_0: bool = fn_state.gs_117938;
        // N s_879_1: branch s_879_0 b5182 b880
        if s_879_0 {
            return block_5182(state, tracer, fn_state);
        } else {
            return block_880(state, tracer, fn_state);
        };
    }
    fn block_880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_880_0: const #0u : u8
        let s_880_0: bool = false;
        // D s_880_1: write-var gs#117939 <= s_880_0
        fn_state.gs_117939 = s_880_0;
        // N s_880_2: jump b881
        return block_881(state, tracer, fn_state);
    }
    fn block_881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_881_0: read-var gs#117939:u8
        let s_881_0: bool = fn_state.gs_117939;
        // N s_881_1: branch s_881_0 b5181 b882
        if s_881_0 {
            return block_5181(state, tracer, fn_state);
        } else {
            return block_882(state, tracer, fn_state);
        };
    }
    fn block_882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_882_0: read-var CRm:u8
        let s_882_0: u8 = fn_state.CRm;
        // D s_882_1: cast zx s_882_0 -> bv
        let s_882_1: Bits = Bits::new(s_882_0 as u128, 4u16);
        // C s_882_2: const #2u : u8
        let s_882_2: u8 = 2;
        // C s_882_3: cast zx s_882_2 -> bv
        let s_882_3: Bits = Bits::new(s_882_2 as u128, 4u16);
        // D s_882_4: cmp-eq s_882_1 s_882_3
        let s_882_4: bool = ((s_882_1) == (s_882_3));
        // N s_882_5: branch s_882_4 b5180 b883
        if s_882_4 {
            return block_5180(state, tracer, fn_state);
        } else {
            return block_883(state, tracer, fn_state);
        };
    }
    fn block_883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_883_0: const #0u : u8
        let s_883_0: bool = false;
        // D s_883_1: write-var gs#117940 <= s_883_0
        fn_state.gs_117940 = s_883_0;
        // N s_883_2: jump b884
        return block_884(state, tracer, fn_state);
    }
    fn block_884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_884_0: read-var gs#117940:u8
        let s_884_0: bool = fn_state.gs_117940;
        // N s_884_1: branch s_884_0 b5179 b885
        if s_884_0 {
            return block_5179(state, tracer, fn_state);
        } else {
            return block_885(state, tracer, fn_state);
        };
    }
    fn block_885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_885_0: const #0u : u8
        let s_885_0: bool = false;
        // D s_885_1: write-var gs#117941 <= s_885_0
        fn_state.gs_117941 = s_885_0;
        // N s_885_2: jump b886
        return block_886(state, tracer, fn_state);
    }
    fn block_886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_886_0: read-var gs#117941:u8
        let s_886_0: bool = fn_state.gs_117941;
        // N s_886_1: branch s_886_0 b5178 b887
        if s_886_0 {
            return block_5178(state, tracer, fn_state);
        } else {
            return block_887(state, tracer, fn_state);
        };
    }
    fn block_887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_887_0: const #0u : u8
        let s_887_0: bool = false;
        // D s_887_1: write-var gs#117942 <= s_887_0
        fn_state.gs_117942 = s_887_0;
        // N s_887_2: jump b888
        return block_888(state, tracer, fn_state);
    }
    fn block_888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_888_0: read-var gs#117942:u8
        let s_888_0: bool = fn_state.gs_117942;
        // N s_888_1: branch s_888_0 b5177 b889
        if s_888_0 {
            return block_5177(state, tracer, fn_state);
        } else {
            return block_889(state, tracer, fn_state);
        };
    }
    fn block_889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_889_0: const #0u : u8
        let s_889_0: bool = false;
        // D s_889_1: write-var gs#117943 <= s_889_0
        fn_state.gs_117943 = s_889_0;
        // N s_889_2: jump b890
        return block_890(state, tracer, fn_state);
    }
    fn block_890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_890_0: read-var gs#117943:u8
        let s_890_0: bool = fn_state.gs_117943;
        // N s_890_1: branch s_890_0 b5176 b891
        if s_890_0 {
            return block_5176(state, tracer, fn_state);
        } else {
            return block_891(state, tracer, fn_state);
        };
    }
    fn block_891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_891_0: read-var CRm:u8
        let s_891_0: u8 = fn_state.CRm;
        // D s_891_1: cast zx s_891_0 -> bv
        let s_891_1: Bits = Bits::new(s_891_0 as u128, 4u16);
        // C s_891_2: const #0u : u8
        let s_891_2: u8 = 0;
        // C s_891_3: cast zx s_891_2 -> bv
        let s_891_3: Bits = Bits::new(s_891_2 as u128, 4u16);
        // D s_891_4: cmp-eq s_891_1 s_891_3
        let s_891_4: bool = ((s_891_1) == (s_891_3));
        // N s_891_5: branch s_891_4 b5175 b892
        if s_891_4 {
            return block_5175(state, tracer, fn_state);
        } else {
            return block_892(state, tracer, fn_state);
        };
    }
    fn block_892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_892_0: const #0u : u8
        let s_892_0: bool = false;
        // D s_892_1: write-var gs#117944 <= s_892_0
        fn_state.gs_117944 = s_892_0;
        // N s_892_2: jump b893
        return block_893(state, tracer, fn_state);
    }
    fn block_893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_893_0: read-var gs#117944:u8
        let s_893_0: bool = fn_state.gs_117944;
        // N s_893_1: branch s_893_0 b5174 b894
        if s_893_0 {
            return block_5174(state, tracer, fn_state);
        } else {
            return block_894(state, tracer, fn_state);
        };
    }
    fn block_894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_894_0: const #0u : u8
        let s_894_0: bool = false;
        // D s_894_1: write-var gs#117945 <= s_894_0
        fn_state.gs_117945 = s_894_0;
        // N s_894_2: jump b895
        return block_895(state, tracer, fn_state);
    }
    fn block_895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_895_0: read-var gs#117945:u8
        let s_895_0: bool = fn_state.gs_117945;
        // N s_895_1: branch s_895_0 b5173 b896
        if s_895_0 {
            return block_5173(state, tracer, fn_state);
        } else {
            return block_896(state, tracer, fn_state);
        };
    }
    fn block_896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_896_0: const #0u : u8
        let s_896_0: bool = false;
        // D s_896_1: write-var gs#117946 <= s_896_0
        fn_state.gs_117946 = s_896_0;
        // N s_896_2: jump b897
        return block_897(state, tracer, fn_state);
    }
    fn block_897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_897_0: read-var gs#117946:u8
        let s_897_0: bool = fn_state.gs_117946;
        // N s_897_1: branch s_897_0 b5172 b898
        if s_897_0 {
            return block_5172(state, tracer, fn_state);
        } else {
            return block_898(state, tracer, fn_state);
        };
    }
    fn block_898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_898_0: const #0u : u8
        let s_898_0: bool = false;
        // D s_898_1: write-var gs#117947 <= s_898_0
        fn_state.gs_117947 = s_898_0;
        // N s_898_2: jump b899
        return block_899(state, tracer, fn_state);
    }
    fn block_899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_899_0: read-var gs#117947:u8
        let s_899_0: bool = fn_state.gs_117947;
        // N s_899_1: branch s_899_0 b5171 b900
        if s_899_0 {
            return block_5171(state, tracer, fn_state);
        } else {
            return block_900(state, tracer, fn_state);
        };
    }
    fn block_900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_900_0: read-var CRm:u8
        let s_900_0: u8 = fn_state.CRm;
        // D s_900_1: cast zx s_900_0 -> bv
        let s_900_1: Bits = Bits::new(s_900_0 as u128, 4u16);
        // C s_900_2: const #11u : u8
        let s_900_2: u8 = 11;
        // C s_900_3: cast zx s_900_2 -> bv
        let s_900_3: Bits = Bits::new(s_900_2 as u128, 4u16);
        // D s_900_4: cmp-eq s_900_1 s_900_3
        let s_900_4: bool = ((s_900_1) == (s_900_3));
        // N s_900_5: branch s_900_4 b5170 b901
        if s_900_4 {
            return block_5170(state, tracer, fn_state);
        } else {
            return block_901(state, tracer, fn_state);
        };
    }
    fn block_901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_901_0: const #0u : u8
        let s_901_0: bool = false;
        // D s_901_1: write-var gs#117948 <= s_901_0
        fn_state.gs_117948 = s_901_0;
        // N s_901_2: jump b902
        return block_902(state, tracer, fn_state);
    }
    fn block_902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_902_0: read-var gs#117948:u8
        let s_902_0: bool = fn_state.gs_117948;
        // N s_902_1: branch s_902_0 b5169 b903
        if s_902_0 {
            return block_5169(state, tracer, fn_state);
        } else {
            return block_903(state, tracer, fn_state);
        };
    }
    fn block_903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_903_0: const #0u : u8
        let s_903_0: bool = false;
        // D s_903_1: write-var gs#117949 <= s_903_0
        fn_state.gs_117949 = s_903_0;
        // N s_903_2: jump b904
        return block_904(state, tracer, fn_state);
    }
    fn block_904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_904_0: read-var gs#117949:u8
        let s_904_0: bool = fn_state.gs_117949;
        // N s_904_1: branch s_904_0 b5168 b905
        if s_904_0 {
            return block_5168(state, tracer, fn_state);
        } else {
            return block_905(state, tracer, fn_state);
        };
    }
    fn block_905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_905_0: const #0u : u8
        let s_905_0: bool = false;
        // D s_905_1: write-var gs#117950 <= s_905_0
        fn_state.gs_117950 = s_905_0;
        // N s_905_2: jump b906
        return block_906(state, tracer, fn_state);
    }
    fn block_906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_906_0: read-var gs#117950:u8
        let s_906_0: bool = fn_state.gs_117950;
        // N s_906_1: branch s_906_0 b5167 b907
        if s_906_0 {
            return block_5167(state, tracer, fn_state);
        } else {
            return block_907(state, tracer, fn_state);
        };
    }
    fn block_907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_907_0: const #0u : u8
        let s_907_0: bool = false;
        // D s_907_1: write-var gs#117951 <= s_907_0
        fn_state.gs_117951 = s_907_0;
        // N s_907_2: jump b908
        return block_908(state, tracer, fn_state);
    }
    fn block_908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_908_0: read-var gs#117951:u8
        let s_908_0: bool = fn_state.gs_117951;
        // N s_908_1: branch s_908_0 b5166 b909
        if s_908_0 {
            return block_5166(state, tracer, fn_state);
        } else {
            return block_909(state, tracer, fn_state);
        };
    }
    fn block_909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_909_0: read-var CRm:u8
        let s_909_0: u8 = fn_state.CRm;
        // D s_909_1: cast zx s_909_0 -> bv
        let s_909_1: Bits = Bits::new(s_909_0 as u128, 4u16);
        // C s_909_2: const #0u : u8
        let s_909_2: u8 = 0;
        // C s_909_3: cast zx s_909_2 -> bv
        let s_909_3: Bits = Bits::new(s_909_2 as u128, 4u16);
        // D s_909_4: cmp-eq s_909_1 s_909_3
        let s_909_4: bool = ((s_909_1) == (s_909_3));
        // N s_909_5: branch s_909_4 b5165 b910
        if s_909_4 {
            return block_5165(state, tracer, fn_state);
        } else {
            return block_910(state, tracer, fn_state);
        };
    }
    fn block_910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_910_0: const #0u : u8
        let s_910_0: bool = false;
        // D s_910_1: write-var gs#117952 <= s_910_0
        fn_state.gs_117952 = s_910_0;
        // N s_910_2: jump b911
        return block_911(state, tracer, fn_state);
    }
    fn block_911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_911_0: read-var gs#117952:u8
        let s_911_0: bool = fn_state.gs_117952;
        // N s_911_1: branch s_911_0 b5164 b912
        if s_911_0 {
            return block_5164(state, tracer, fn_state);
        } else {
            return block_912(state, tracer, fn_state);
        };
    }
    fn block_912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_912_0: const #0u : u8
        let s_912_0: bool = false;
        // D s_912_1: write-var gs#117953 <= s_912_0
        fn_state.gs_117953 = s_912_0;
        // N s_912_2: jump b913
        return block_913(state, tracer, fn_state);
    }
    fn block_913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_913_0: read-var gs#117953:u8
        let s_913_0: bool = fn_state.gs_117953;
        // N s_913_1: branch s_913_0 b5163 b914
        if s_913_0 {
            return block_5163(state, tracer, fn_state);
        } else {
            return block_914(state, tracer, fn_state);
        };
    }
    fn block_914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_914_0: const #0u : u8
        let s_914_0: bool = false;
        // D s_914_1: write-var gs#117954 <= s_914_0
        fn_state.gs_117954 = s_914_0;
        // N s_914_2: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_915_0: read-var gs#117954:u8
        let s_915_0: bool = fn_state.gs_117954;
        // N s_915_1: branch s_915_0 b5162 b916
        if s_915_0 {
            return block_5162(state, tracer, fn_state);
        } else {
            return block_916(state, tracer, fn_state);
        };
    }
    fn block_916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_916_0: const #0u : u8
        let s_916_0: bool = false;
        // D s_916_1: write-var gs#117955 <= s_916_0
        fn_state.gs_117955 = s_916_0;
        // N s_916_2: jump b917
        return block_917(state, tracer, fn_state);
    }
    fn block_917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_917_0: read-var gs#117955:u8
        let s_917_0: bool = fn_state.gs_117955;
        // N s_917_1: branch s_917_0 b5161 b918
        if s_917_0 {
            return block_5161(state, tracer, fn_state);
        } else {
            return block_918(state, tracer, fn_state);
        };
    }
    fn block_918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_918_0: read-var CRm:u8
        let s_918_0: u8 = fn_state.CRm;
        // D s_918_1: cast zx s_918_0 -> bv
        let s_918_1: Bits = Bits::new(s_918_0 as u128, 4u16);
        // C s_918_2: const #0u : u8
        let s_918_2: u8 = 0;
        // C s_918_3: cast zx s_918_2 -> bv
        let s_918_3: Bits = Bits::new(s_918_2 as u128, 4u16);
        // D s_918_4: cmp-eq s_918_1 s_918_3
        let s_918_4: bool = ((s_918_1) == (s_918_3));
        // N s_918_5: branch s_918_4 b5160 b919
        if s_918_4 {
            return block_5160(state, tracer, fn_state);
        } else {
            return block_919(state, tracer, fn_state);
        };
    }
    fn block_919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_919_0: const #0u : u8
        let s_919_0: bool = false;
        // D s_919_1: write-var gs#117956 <= s_919_0
        fn_state.gs_117956 = s_919_0;
        // N s_919_2: jump b920
        return block_920(state, tracer, fn_state);
    }
    fn block_920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_920_0: read-var gs#117956:u8
        let s_920_0: bool = fn_state.gs_117956;
        // N s_920_1: branch s_920_0 b5159 b921
        if s_920_0 {
            return block_5159(state, tracer, fn_state);
        } else {
            return block_921(state, tracer, fn_state);
        };
    }
    fn block_921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_921_0: const #0u : u8
        let s_921_0: bool = false;
        // D s_921_1: write-var gs#117957 <= s_921_0
        fn_state.gs_117957 = s_921_0;
        // N s_921_2: jump b922
        return block_922(state, tracer, fn_state);
    }
    fn block_922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_922_0: read-var gs#117957:u8
        let s_922_0: bool = fn_state.gs_117957;
        // N s_922_1: branch s_922_0 b5158 b923
        if s_922_0 {
            return block_5158(state, tracer, fn_state);
        } else {
            return block_923(state, tracer, fn_state);
        };
    }
    fn block_923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_923_0: const #0u : u8
        let s_923_0: bool = false;
        // D s_923_1: write-var gs#117958 <= s_923_0
        fn_state.gs_117958 = s_923_0;
        // N s_923_2: jump b924
        return block_924(state, tracer, fn_state);
    }
    fn block_924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_924_0: read-var gs#117958:u8
        let s_924_0: bool = fn_state.gs_117958;
        // N s_924_1: branch s_924_0 b5157 b925
        if s_924_0 {
            return block_5157(state, tracer, fn_state);
        } else {
            return block_925(state, tracer, fn_state);
        };
    }
    fn block_925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_925_0: const #0u : u8
        let s_925_0: bool = false;
        // D s_925_1: write-var gs#117959 <= s_925_0
        fn_state.gs_117959 = s_925_0;
        // N s_925_2: jump b926
        return block_926(state, tracer, fn_state);
    }
    fn block_926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_926_0: read-var gs#117959:u8
        let s_926_0: bool = fn_state.gs_117959;
        // N s_926_1: branch s_926_0 b5156 b927
        if s_926_0 {
            return block_5156(state, tracer, fn_state);
        } else {
            return block_927(state, tracer, fn_state);
        };
    }
    fn block_927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_927_0: read-var CRm:u8
        let s_927_0: u8 = fn_state.CRm;
        // D s_927_1: cast zx s_927_0 -> bv
        let s_927_1: Bits = Bits::new(s_927_0 as u128, 4u16);
        // C s_927_2: const #12u : u8
        let s_927_2: u8 = 12;
        // C s_927_3: cast zx s_927_2 -> bv
        let s_927_3: Bits = Bits::new(s_927_2 as u128, 4u16);
        // D s_927_4: cmp-eq s_927_1 s_927_3
        let s_927_4: bool = ((s_927_1) == (s_927_3));
        // N s_927_5: branch s_927_4 b5155 b928
        if s_927_4 {
            return block_5155(state, tracer, fn_state);
        } else {
            return block_928(state, tracer, fn_state);
        };
    }
    fn block_928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_928_0: const #0u : u8
        let s_928_0: bool = false;
        // D s_928_1: write-var gs#117960 <= s_928_0
        fn_state.gs_117960 = s_928_0;
        // N s_928_2: jump b929
        return block_929(state, tracer, fn_state);
    }
    fn block_929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_929_0: read-var gs#117960:u8
        let s_929_0: bool = fn_state.gs_117960;
        // N s_929_1: branch s_929_0 b5154 b930
        if s_929_0 {
            return block_5154(state, tracer, fn_state);
        } else {
            return block_930(state, tracer, fn_state);
        };
    }
    fn block_930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_930_0: const #0u : u8
        let s_930_0: bool = false;
        // D s_930_1: write-var gs#117961 <= s_930_0
        fn_state.gs_117961 = s_930_0;
        // N s_930_2: jump b931
        return block_931(state, tracer, fn_state);
    }
    fn block_931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_931_0: read-var gs#117961:u8
        let s_931_0: bool = fn_state.gs_117961;
        // N s_931_1: branch s_931_0 b5153 b932
        if s_931_0 {
            return block_5153(state, tracer, fn_state);
        } else {
            return block_932(state, tracer, fn_state);
        };
    }
    fn block_932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_932_0: const #0u : u8
        let s_932_0: bool = false;
        // D s_932_1: write-var gs#117962 <= s_932_0
        fn_state.gs_117962 = s_932_0;
        // N s_932_2: jump b933
        return block_933(state, tracer, fn_state);
    }
    fn block_933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_933_0: read-var gs#117962:u8
        let s_933_0: bool = fn_state.gs_117962;
        // N s_933_1: branch s_933_0 b5152 b934
        if s_933_0 {
            return block_5152(state, tracer, fn_state);
        } else {
            return block_934(state, tracer, fn_state);
        };
    }
    fn block_934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_934_0: const #0u : u8
        let s_934_0: bool = false;
        // D s_934_1: write-var gs#117963 <= s_934_0
        fn_state.gs_117963 = s_934_0;
        // N s_934_2: jump b935
        return block_935(state, tracer, fn_state);
    }
    fn block_935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_935_0: read-var gs#117963:u8
        let s_935_0: bool = fn_state.gs_117963;
        // N s_935_1: branch s_935_0 b5151 b936
        if s_935_0 {
            return block_5151(state, tracer, fn_state);
        } else {
            return block_936(state, tracer, fn_state);
        };
    }
    fn block_936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_936_0: read-var CRm:u8
        let s_936_0: u8 = fn_state.CRm;
        // D s_936_1: cast zx s_936_0 -> bv
        let s_936_1: Bits = Bits::new(s_936_0 as u128, 4u16);
        // C s_936_2: const #15u : u8
        let s_936_2: u8 = 15;
        // C s_936_3: cast zx s_936_2 -> bv
        let s_936_3: Bits = Bits::new(s_936_2 as u128, 4u16);
        // D s_936_4: cmp-eq s_936_1 s_936_3
        let s_936_4: bool = ((s_936_1) == (s_936_3));
        // N s_936_5: branch s_936_4 b5150 b937
        if s_936_4 {
            return block_5150(state, tracer, fn_state);
        } else {
            return block_937(state, tracer, fn_state);
        };
    }
    fn block_937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_937_0: const #0u : u8
        let s_937_0: bool = false;
        // D s_937_1: write-var gs#117964 <= s_937_0
        fn_state.gs_117964 = s_937_0;
        // N s_937_2: jump b938
        return block_938(state, tracer, fn_state);
    }
    fn block_938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_938_0: read-var gs#117964:u8
        let s_938_0: bool = fn_state.gs_117964;
        // N s_938_1: branch s_938_0 b5149 b939
        if s_938_0 {
            return block_5149(state, tracer, fn_state);
        } else {
            return block_939(state, tracer, fn_state);
        };
    }
    fn block_939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_939_0: const #0u : u8
        let s_939_0: bool = false;
        // D s_939_1: write-var gs#117965 <= s_939_0
        fn_state.gs_117965 = s_939_0;
        // N s_939_2: jump b940
        return block_940(state, tracer, fn_state);
    }
    fn block_940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_940_0: read-var gs#117965:u8
        let s_940_0: bool = fn_state.gs_117965;
        // N s_940_1: branch s_940_0 b5148 b941
        if s_940_0 {
            return block_5148(state, tracer, fn_state);
        } else {
            return block_941(state, tracer, fn_state);
        };
    }
    fn block_941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_941_0: const #0u : u8
        let s_941_0: bool = false;
        // D s_941_1: write-var gs#117966 <= s_941_0
        fn_state.gs_117966 = s_941_0;
        // N s_941_2: jump b942
        return block_942(state, tracer, fn_state);
    }
    fn block_942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_942_0: read-var gs#117966:u8
        let s_942_0: bool = fn_state.gs_117966;
        // N s_942_1: branch s_942_0 b5147 b943
        if s_942_0 {
            return block_5147(state, tracer, fn_state);
        } else {
            return block_943(state, tracer, fn_state);
        };
    }
    fn block_943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_943_0: const #0u : u8
        let s_943_0: bool = false;
        // D s_943_1: write-var gs#117967 <= s_943_0
        fn_state.gs_117967 = s_943_0;
        // N s_943_2: jump b944
        return block_944(state, tracer, fn_state);
    }
    fn block_944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_944_0: read-var gs#117967:u8
        let s_944_0: bool = fn_state.gs_117967;
        // N s_944_1: branch s_944_0 b5146 b945
        if s_944_0 {
            return block_5146(state, tracer, fn_state);
        } else {
            return block_945(state, tracer, fn_state);
        };
    }
    fn block_945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_945_0: read-var CRm:u8
        let s_945_0: u8 = fn_state.CRm;
        // D s_945_1: cast zx s_945_0 -> bv
        let s_945_1: Bits = Bits::new(s_945_0 as u128, 4u16);
        // C s_945_2: const #14u : u8
        let s_945_2: u8 = 14;
        // C s_945_3: cast zx s_945_2 -> bv
        let s_945_3: Bits = Bits::new(s_945_2 as u128, 4u16);
        // D s_945_4: cmp-eq s_945_1 s_945_3
        let s_945_4: bool = ((s_945_1) == (s_945_3));
        // N s_945_5: branch s_945_4 b5145 b946
        if s_945_4 {
            return block_5145(state, tracer, fn_state);
        } else {
            return block_946(state, tracer, fn_state);
        };
    }
    fn block_946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_946_0: const #0u : u8
        let s_946_0: bool = false;
        // D s_946_1: write-var gs#117968 <= s_946_0
        fn_state.gs_117968 = s_946_0;
        // N s_946_2: jump b947
        return block_947(state, tracer, fn_state);
    }
    fn block_947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_947_0: read-var gs#117968:u8
        let s_947_0: bool = fn_state.gs_117968;
        // N s_947_1: branch s_947_0 b5144 b948
        if s_947_0 {
            return block_5144(state, tracer, fn_state);
        } else {
            return block_948(state, tracer, fn_state);
        };
    }
    fn block_948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_948_0: const #0u : u8
        let s_948_0: bool = false;
        // D s_948_1: write-var gs#117969 <= s_948_0
        fn_state.gs_117969 = s_948_0;
        // N s_948_2: jump b949
        return block_949(state, tracer, fn_state);
    }
    fn block_949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_949_0: read-var gs#117969:u8
        let s_949_0: bool = fn_state.gs_117969;
        // N s_949_1: branch s_949_0 b5143 b950
        if s_949_0 {
            return block_5143(state, tracer, fn_state);
        } else {
            return block_950(state, tracer, fn_state);
        };
    }
    fn block_950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_950_0: const #0u : u8
        let s_950_0: bool = false;
        // D s_950_1: write-var gs#117970 <= s_950_0
        fn_state.gs_117970 = s_950_0;
        // N s_950_2: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_951_0: read-var gs#117970:u8
        let s_951_0: bool = fn_state.gs_117970;
        // N s_951_1: branch s_951_0 b5142 b952
        if s_951_0 {
            return block_5142(state, tracer, fn_state);
        } else {
            return block_952(state, tracer, fn_state);
        };
    }
    fn block_952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_952_0: const #0u : u8
        let s_952_0: bool = false;
        // D s_952_1: write-var gs#117971 <= s_952_0
        fn_state.gs_117971 = s_952_0;
        // N s_952_2: jump b953
        return block_953(state, tracer, fn_state);
    }
    fn block_953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_953_0: read-var gs#117971:u8
        let s_953_0: bool = fn_state.gs_117971;
        // N s_953_1: branch s_953_0 b5141 b954
        if s_953_0 {
            return block_5141(state, tracer, fn_state);
        } else {
            return block_954(state, tracer, fn_state);
        };
    }
    fn block_954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_954_0: read-var CRm:u8
        let s_954_0: u8 = fn_state.CRm;
        // D s_954_1: cast zx s_954_0 -> bv
        let s_954_1: Bits = Bits::new(s_954_0 as u128, 4u16);
        // C s_954_2: const #13u : u8
        let s_954_2: u8 = 13;
        // C s_954_3: cast zx s_954_2 -> bv
        let s_954_3: Bits = Bits::new(s_954_2 as u128, 4u16);
        // D s_954_4: cmp-eq s_954_1 s_954_3
        let s_954_4: bool = ((s_954_1) == (s_954_3));
        // N s_954_5: branch s_954_4 b5140 b955
        if s_954_4 {
            return block_5140(state, tracer, fn_state);
        } else {
            return block_955(state, tracer, fn_state);
        };
    }
    fn block_955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_955_0: const #0u : u8
        let s_955_0: bool = false;
        // D s_955_1: write-var gs#117972 <= s_955_0
        fn_state.gs_117972 = s_955_0;
        // N s_955_2: jump b956
        return block_956(state, tracer, fn_state);
    }
    fn block_956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_956_0: read-var gs#117972:u8
        let s_956_0: bool = fn_state.gs_117972;
        // N s_956_1: branch s_956_0 b5139 b957
        if s_956_0 {
            return block_5139(state, tracer, fn_state);
        } else {
            return block_957(state, tracer, fn_state);
        };
    }
    fn block_957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_957_0: const #0u : u8
        let s_957_0: bool = false;
        // D s_957_1: write-var gs#117973 <= s_957_0
        fn_state.gs_117973 = s_957_0;
        // N s_957_2: jump b958
        return block_958(state, tracer, fn_state);
    }
    fn block_958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_958_0: read-var gs#117973:u8
        let s_958_0: bool = fn_state.gs_117973;
        // N s_958_1: branch s_958_0 b5138 b959
        if s_958_0 {
            return block_5138(state, tracer, fn_state);
        } else {
            return block_959(state, tracer, fn_state);
        };
    }
    fn block_959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_959_0: const #0u : u8
        let s_959_0: bool = false;
        // D s_959_1: write-var gs#117974 <= s_959_0
        fn_state.gs_117974 = s_959_0;
        // N s_959_2: jump b960
        return block_960(state, tracer, fn_state);
    }
    fn block_960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_960_0: read-var gs#117974:u8
        let s_960_0: bool = fn_state.gs_117974;
        // N s_960_1: branch s_960_0 b5137 b961
        if s_960_0 {
            return block_5137(state, tracer, fn_state);
        } else {
            return block_961(state, tracer, fn_state);
        };
    }
    fn block_961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_961_0: const #0u : u8
        let s_961_0: bool = false;
        // D s_961_1: write-var gs#117975 <= s_961_0
        fn_state.gs_117975 = s_961_0;
        // N s_961_2: jump b962
        return block_962(state, tracer, fn_state);
    }
    fn block_962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_962_0: read-var gs#117975:u8
        let s_962_0: bool = fn_state.gs_117975;
        // N s_962_1: branch s_962_0 b5136 b963
        if s_962_0 {
            return block_5136(state, tracer, fn_state);
        } else {
            return block_963(state, tracer, fn_state);
        };
    }
    fn block_963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_963_0: read-var CRm:u8
        let s_963_0: u8 = fn_state.CRm;
        // D s_963_1: cast zx s_963_0 -> bv
        let s_963_1: Bits = Bits::new(s_963_0 as u128, 4u16);
        // C s_963_2: const #12u : u8
        let s_963_2: u8 = 12;
        // C s_963_3: cast zx s_963_2 -> bv
        let s_963_3: Bits = Bits::new(s_963_2 as u128, 4u16);
        // D s_963_4: cmp-eq s_963_1 s_963_3
        let s_963_4: bool = ((s_963_1) == (s_963_3));
        // N s_963_5: branch s_963_4 b5135 b964
        if s_963_4 {
            return block_5135(state, tracer, fn_state);
        } else {
            return block_964(state, tracer, fn_state);
        };
    }
    fn block_964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_964_0: const #0u : u8
        let s_964_0: bool = false;
        // D s_964_1: write-var gs#117976 <= s_964_0
        fn_state.gs_117976 = s_964_0;
        // N s_964_2: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_965_0: read-var gs#117976:u8
        let s_965_0: bool = fn_state.gs_117976;
        // N s_965_1: branch s_965_0 b5134 b966
        if s_965_0 {
            return block_5134(state, tracer, fn_state);
        } else {
            return block_966(state, tracer, fn_state);
        };
    }
    fn block_966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_966_0: const #0u : u8
        let s_966_0: bool = false;
        // D s_966_1: write-var gs#117977 <= s_966_0
        fn_state.gs_117977 = s_966_0;
        // N s_966_2: jump b967
        return block_967(state, tracer, fn_state);
    }
    fn block_967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_967_0: read-var gs#117977:u8
        let s_967_0: bool = fn_state.gs_117977;
        // N s_967_1: branch s_967_0 b5133 b968
        if s_967_0 {
            return block_5133(state, tracer, fn_state);
        } else {
            return block_968(state, tracer, fn_state);
        };
    }
    fn block_968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_968_0: const #0u : u8
        let s_968_0: bool = false;
        // D s_968_1: write-var gs#117978 <= s_968_0
        fn_state.gs_117978 = s_968_0;
        // N s_968_2: jump b969
        return block_969(state, tracer, fn_state);
    }
    fn block_969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_969_0: read-var gs#117978:u8
        let s_969_0: bool = fn_state.gs_117978;
        // N s_969_1: branch s_969_0 b5132 b970
        if s_969_0 {
            return block_5132(state, tracer, fn_state);
        } else {
            return block_970(state, tracer, fn_state);
        };
    }
    fn block_970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_970_0: const #0u : u8
        let s_970_0: bool = false;
        // D s_970_1: write-var gs#117979 <= s_970_0
        fn_state.gs_117979 = s_970_0;
        // N s_970_2: jump b971
        return block_971(state, tracer, fn_state);
    }
    fn block_971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_971_0: read-var gs#117979:u8
        let s_971_0: bool = fn_state.gs_117979;
        // N s_971_1: branch s_971_0 b5131 b972
        if s_971_0 {
            return block_5131(state, tracer, fn_state);
        } else {
            return block_972(state, tracer, fn_state);
        };
    }
    fn block_972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_972_0: read-var CRm:u8
        let s_972_0: u8 = fn_state.CRm;
        // D s_972_1: cast zx s_972_0 -> bv
        let s_972_1: Bits = Bits::new(s_972_0 as u128, 4u16);
        // C s_972_2: const #11u : u8
        let s_972_2: u8 = 11;
        // C s_972_3: cast zx s_972_2 -> bv
        let s_972_3: Bits = Bits::new(s_972_2 as u128, 4u16);
        // D s_972_4: cmp-eq s_972_1 s_972_3
        let s_972_4: bool = ((s_972_1) == (s_972_3));
        // N s_972_5: branch s_972_4 b5130 b973
        if s_972_4 {
            return block_5130(state, tracer, fn_state);
        } else {
            return block_973(state, tracer, fn_state);
        };
    }
    fn block_973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_973_0: const #0u : u8
        let s_973_0: bool = false;
        // D s_973_1: write-var gs#117980 <= s_973_0
        fn_state.gs_117980 = s_973_0;
        // N s_973_2: jump b974
        return block_974(state, tracer, fn_state);
    }
    fn block_974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_974_0: read-var gs#117980:u8
        let s_974_0: bool = fn_state.gs_117980;
        // N s_974_1: branch s_974_0 b5129 b975
        if s_974_0 {
            return block_5129(state, tracer, fn_state);
        } else {
            return block_975(state, tracer, fn_state);
        };
    }
    fn block_975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_975_0: const #0u : u8
        let s_975_0: bool = false;
        // D s_975_1: write-var gs#117981 <= s_975_0
        fn_state.gs_117981 = s_975_0;
        // N s_975_2: jump b976
        return block_976(state, tracer, fn_state);
    }
    fn block_976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_976_0: read-var gs#117981:u8
        let s_976_0: bool = fn_state.gs_117981;
        // N s_976_1: branch s_976_0 b5128 b977
        if s_976_0 {
            return block_5128(state, tracer, fn_state);
        } else {
            return block_977(state, tracer, fn_state);
        };
    }
    fn block_977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_977_0: const #0u : u8
        let s_977_0: bool = false;
        // D s_977_1: write-var gs#117982 <= s_977_0
        fn_state.gs_117982 = s_977_0;
        // N s_977_2: jump b978
        return block_978(state, tracer, fn_state);
    }
    fn block_978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_978_0: read-var gs#117982:u8
        let s_978_0: bool = fn_state.gs_117982;
        // N s_978_1: branch s_978_0 b5127 b979
        if s_978_0 {
            return block_5127(state, tracer, fn_state);
        } else {
            return block_979(state, tracer, fn_state);
        };
    }
    fn block_979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_979_0: const #0u : u8
        let s_979_0: bool = false;
        // D s_979_1: write-var gs#117983 <= s_979_0
        fn_state.gs_117983 = s_979_0;
        // N s_979_2: jump b980
        return block_980(state, tracer, fn_state);
    }
    fn block_980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_980_0: read-var gs#117983:u8
        let s_980_0: bool = fn_state.gs_117983;
        // N s_980_1: branch s_980_0 b5126 b981
        if s_980_0 {
            return block_5126(state, tracer, fn_state);
        } else {
            return block_981(state, tracer, fn_state);
        };
    }
    fn block_981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_981_0: read-var CRm:u8
        let s_981_0: u8 = fn_state.CRm;
        // D s_981_1: cast zx s_981_0 -> bv
        let s_981_1: Bits = Bits::new(s_981_0 as u128, 4u16);
        // C s_981_2: const #10u : u8
        let s_981_2: u8 = 10;
        // C s_981_3: cast zx s_981_2 -> bv
        let s_981_3: Bits = Bits::new(s_981_2 as u128, 4u16);
        // D s_981_4: cmp-eq s_981_1 s_981_3
        let s_981_4: bool = ((s_981_1) == (s_981_3));
        // N s_981_5: branch s_981_4 b5125 b982
        if s_981_4 {
            return block_5125(state, tracer, fn_state);
        } else {
            return block_982(state, tracer, fn_state);
        };
    }
    fn block_982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_982_0: const #0u : u8
        let s_982_0: bool = false;
        // D s_982_1: write-var gs#117984 <= s_982_0
        fn_state.gs_117984 = s_982_0;
        // N s_982_2: jump b983
        return block_983(state, tracer, fn_state);
    }
    fn block_983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_983_0: read-var gs#117984:u8
        let s_983_0: bool = fn_state.gs_117984;
        // N s_983_1: branch s_983_0 b5124 b984
        if s_983_0 {
            return block_5124(state, tracer, fn_state);
        } else {
            return block_984(state, tracer, fn_state);
        };
    }
    fn block_984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_984_0: const #0u : u8
        let s_984_0: bool = false;
        // D s_984_1: write-var gs#117985 <= s_984_0
        fn_state.gs_117985 = s_984_0;
        // N s_984_2: jump b985
        return block_985(state, tracer, fn_state);
    }
    fn block_985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_985_0: read-var gs#117985:u8
        let s_985_0: bool = fn_state.gs_117985;
        // N s_985_1: branch s_985_0 b5123 b986
        if s_985_0 {
            return block_5123(state, tracer, fn_state);
        } else {
            return block_986(state, tracer, fn_state);
        };
    }
    fn block_986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_986_0: const #0u : u8
        let s_986_0: bool = false;
        // D s_986_1: write-var gs#117986 <= s_986_0
        fn_state.gs_117986 = s_986_0;
        // N s_986_2: jump b987
        return block_987(state, tracer, fn_state);
    }
    fn block_987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_987_0: read-var gs#117986:u8
        let s_987_0: bool = fn_state.gs_117986;
        // N s_987_1: branch s_987_0 b5122 b988
        if s_987_0 {
            return block_5122(state, tracer, fn_state);
        } else {
            return block_988(state, tracer, fn_state);
        };
    }
    fn block_988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_988_0: const #0u : u8
        let s_988_0: bool = false;
        // D s_988_1: write-var gs#117987 <= s_988_0
        fn_state.gs_117987 = s_988_0;
        // N s_988_2: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_989_0: read-var gs#117987:u8
        let s_989_0: bool = fn_state.gs_117987;
        // N s_989_1: branch s_989_0 b5121 b990
        if s_989_0 {
            return block_5121(state, tracer, fn_state);
        } else {
            return block_990(state, tracer, fn_state);
        };
    }
    fn block_990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_990_0: read-var CRm:u8
        let s_990_0: u8 = fn_state.CRm;
        // D s_990_1: cast zx s_990_0 -> bv
        let s_990_1: Bits = Bits::new(s_990_0 as u128, 4u16);
        // C s_990_2: const #9u : u8
        let s_990_2: u8 = 9;
        // C s_990_3: cast zx s_990_2 -> bv
        let s_990_3: Bits = Bits::new(s_990_2 as u128, 4u16);
        // D s_990_4: cmp-eq s_990_1 s_990_3
        let s_990_4: bool = ((s_990_1) == (s_990_3));
        // N s_990_5: branch s_990_4 b5120 b991
        if s_990_4 {
            return block_5120(state, tracer, fn_state);
        } else {
            return block_991(state, tracer, fn_state);
        };
    }
    fn block_991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_991_0: const #0u : u8
        let s_991_0: bool = false;
        // D s_991_1: write-var gs#117988 <= s_991_0
        fn_state.gs_117988 = s_991_0;
        // N s_991_2: jump b992
        return block_992(state, tracer, fn_state);
    }
    fn block_992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_992_0: read-var gs#117988:u8
        let s_992_0: bool = fn_state.gs_117988;
        // N s_992_1: branch s_992_0 b5119 b993
        if s_992_0 {
            return block_5119(state, tracer, fn_state);
        } else {
            return block_993(state, tracer, fn_state);
        };
    }
    fn block_993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_993_0: const #0u : u8
        let s_993_0: bool = false;
        // D s_993_1: write-var gs#117989 <= s_993_0
        fn_state.gs_117989 = s_993_0;
        // N s_993_2: jump b994
        return block_994(state, tracer, fn_state);
    }
    fn block_994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_994_0: read-var gs#117989:u8
        let s_994_0: bool = fn_state.gs_117989;
        // N s_994_1: branch s_994_0 b5118 b995
        if s_994_0 {
            return block_5118(state, tracer, fn_state);
        } else {
            return block_995(state, tracer, fn_state);
        };
    }
    fn block_995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_995_0: const #0u : u8
        let s_995_0: bool = false;
        // D s_995_1: write-var gs#117990 <= s_995_0
        fn_state.gs_117990 = s_995_0;
        // N s_995_2: jump b996
        return block_996(state, tracer, fn_state);
    }
    fn block_996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_996_0: read-var gs#117990:u8
        let s_996_0: bool = fn_state.gs_117990;
        // N s_996_1: branch s_996_0 b5117 b997
        if s_996_0 {
            return block_5117(state, tracer, fn_state);
        } else {
            return block_997(state, tracer, fn_state);
        };
    }
    fn block_997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_997_0: const #0u : u8
        let s_997_0: bool = false;
        // D s_997_1: write-var gs#117991 <= s_997_0
        fn_state.gs_117991 = s_997_0;
        // N s_997_2: jump b998
        return block_998(state, tracer, fn_state);
    }
    fn block_998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_998_0: read-var gs#117991:u8
        let s_998_0: bool = fn_state.gs_117991;
        // N s_998_1: branch s_998_0 b5116 b999
        if s_998_0 {
            return block_5116(state, tracer, fn_state);
        } else {
            return block_999(state, tracer, fn_state);
        };
    }
    fn block_999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_999_0: read-var CRm:u8
        let s_999_0: u8 = fn_state.CRm;
        // D s_999_1: cast zx s_999_0 -> bv
        let s_999_1: Bits = Bits::new(s_999_0 as u128, 4u16);
        // C s_999_2: const #8u : u8
        let s_999_2: u8 = 8;
        // C s_999_3: cast zx s_999_2 -> bv
        let s_999_3: Bits = Bits::new(s_999_2 as u128, 4u16);
        // D s_999_4: cmp-eq s_999_1 s_999_3
        let s_999_4: bool = ((s_999_1) == (s_999_3));
        // N s_999_5: branch s_999_4 b5115 b1000
        if s_999_4 {
            return block_5115(state, tracer, fn_state);
        } else {
            return block_1000(state, tracer, fn_state);
        };
    }
    fn block_1000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1000_0: const #0u : u8
        let s_1000_0: bool = false;
        // D s_1000_1: write-var gs#117992 <= s_1000_0
        fn_state.gs_117992 = s_1000_0;
        // N s_1000_2: jump b1001
        return block_1001(state, tracer, fn_state);
    }
    fn block_1001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1001_0: read-var gs#117992:u8
        let s_1001_0: bool = fn_state.gs_117992;
        // N s_1001_1: branch s_1001_0 b5114 b1002
        if s_1001_0 {
            return block_5114(state, tracer, fn_state);
        } else {
            return block_1002(state, tracer, fn_state);
        };
    }
    fn block_1002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1002_0: const #0u : u8
        let s_1002_0: bool = false;
        // D s_1002_1: write-var gs#117993 <= s_1002_0
        fn_state.gs_117993 = s_1002_0;
        // N s_1002_2: jump b1003
        return block_1003(state, tracer, fn_state);
    }
    fn block_1003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1003_0: read-var gs#117993:u8
        let s_1003_0: bool = fn_state.gs_117993;
        // N s_1003_1: branch s_1003_0 b5113 b1004
        if s_1003_0 {
            return block_5113(state, tracer, fn_state);
        } else {
            return block_1004(state, tracer, fn_state);
        };
    }
    fn block_1004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1004_0: const #0u : u8
        let s_1004_0: bool = false;
        // D s_1004_1: write-var gs#117994 <= s_1004_0
        fn_state.gs_117994 = s_1004_0;
        // N s_1004_2: jump b1005
        return block_1005(state, tracer, fn_state);
    }
    fn block_1005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1005_0: read-var gs#117994:u8
        let s_1005_0: bool = fn_state.gs_117994;
        // N s_1005_1: branch s_1005_0 b5112 b1006
        if s_1005_0 {
            return block_5112(state, tracer, fn_state);
        } else {
            return block_1006(state, tracer, fn_state);
        };
    }
    fn block_1006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1006_0: const #0u : u8
        let s_1006_0: bool = false;
        // D s_1006_1: write-var gs#117995 <= s_1006_0
        fn_state.gs_117995 = s_1006_0;
        // N s_1006_2: jump b1007
        return block_1007(state, tracer, fn_state);
    }
    fn block_1007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1007_0: read-var gs#117995:u8
        let s_1007_0: bool = fn_state.gs_117995;
        // N s_1007_1: branch s_1007_0 b5111 b1008
        if s_1007_0 {
            return block_5111(state, tracer, fn_state);
        } else {
            return block_1008(state, tracer, fn_state);
        };
    }
    fn block_1008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1008_0: read-var CRm:u8
        let s_1008_0: u8 = fn_state.CRm;
        // D s_1008_1: cast zx s_1008_0 -> bv
        let s_1008_1: Bits = Bits::new(s_1008_0 as u128, 4u16);
        // C s_1008_2: const #7u : u8
        let s_1008_2: u8 = 7;
        // C s_1008_3: cast zx s_1008_2 -> bv
        let s_1008_3: Bits = Bits::new(s_1008_2 as u128, 4u16);
        // D s_1008_4: cmp-eq s_1008_1 s_1008_3
        let s_1008_4: bool = ((s_1008_1) == (s_1008_3));
        // N s_1008_5: branch s_1008_4 b5110 b1009
        if s_1008_4 {
            return block_5110(state, tracer, fn_state);
        } else {
            return block_1009(state, tracer, fn_state);
        };
    }
    fn block_1009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1009_0: const #0u : u8
        let s_1009_0: bool = false;
        // D s_1009_1: write-var gs#117996 <= s_1009_0
        fn_state.gs_117996 = s_1009_0;
        // N s_1009_2: jump b1010
        return block_1010(state, tracer, fn_state);
    }
    fn block_1010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1010_0: read-var gs#117996:u8
        let s_1010_0: bool = fn_state.gs_117996;
        // N s_1010_1: branch s_1010_0 b5109 b1011
        if s_1010_0 {
            return block_5109(state, tracer, fn_state);
        } else {
            return block_1011(state, tracer, fn_state);
        };
    }
    fn block_1011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1011_0: const #0u : u8
        let s_1011_0: bool = false;
        // D s_1011_1: write-var gs#117997 <= s_1011_0
        fn_state.gs_117997 = s_1011_0;
        // N s_1011_2: jump b1012
        return block_1012(state, tracer, fn_state);
    }
    fn block_1012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1012_0: read-var gs#117997:u8
        let s_1012_0: bool = fn_state.gs_117997;
        // N s_1012_1: branch s_1012_0 b5108 b1013
        if s_1012_0 {
            return block_5108(state, tracer, fn_state);
        } else {
            return block_1013(state, tracer, fn_state);
        };
    }
    fn block_1013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1013_0: const #0u : u8
        let s_1013_0: bool = false;
        // D s_1013_1: write-var gs#117998 <= s_1013_0
        fn_state.gs_117998 = s_1013_0;
        // N s_1013_2: jump b1014
        return block_1014(state, tracer, fn_state);
    }
    fn block_1014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1014_0: read-var gs#117998:u8
        let s_1014_0: bool = fn_state.gs_117998;
        // N s_1014_1: branch s_1014_0 b5107 b1015
        if s_1014_0 {
            return block_5107(state, tracer, fn_state);
        } else {
            return block_1015(state, tracer, fn_state);
        };
    }
    fn block_1015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1015_0: const #0u : u8
        let s_1015_0: bool = false;
        // D s_1015_1: write-var gs#117999 <= s_1015_0
        fn_state.gs_117999 = s_1015_0;
        // N s_1015_2: jump b1016
        return block_1016(state, tracer, fn_state);
    }
    fn block_1016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1016_0: read-var gs#117999:u8
        let s_1016_0: bool = fn_state.gs_117999;
        // N s_1016_1: branch s_1016_0 b5106 b1017
        if s_1016_0 {
            return block_5106(state, tracer, fn_state);
        } else {
            return block_1017(state, tracer, fn_state);
        };
    }
    fn block_1017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1017_0: read-var CRm:u8
        let s_1017_0: u8 = fn_state.CRm;
        // D s_1017_1: cast zx s_1017_0 -> bv
        let s_1017_1: Bits = Bits::new(s_1017_0 as u128, 4u16);
        // C s_1017_2: const #6u : u8
        let s_1017_2: u8 = 6;
        // C s_1017_3: cast zx s_1017_2 -> bv
        let s_1017_3: Bits = Bits::new(s_1017_2 as u128, 4u16);
        // D s_1017_4: cmp-eq s_1017_1 s_1017_3
        let s_1017_4: bool = ((s_1017_1) == (s_1017_3));
        // N s_1017_5: branch s_1017_4 b5105 b1018
        if s_1017_4 {
            return block_5105(state, tracer, fn_state);
        } else {
            return block_1018(state, tracer, fn_state);
        };
    }
    fn block_1018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1018_0: const #0u : u8
        let s_1018_0: bool = false;
        // D s_1018_1: write-var gs#118000 <= s_1018_0
        fn_state.gs_118000 = s_1018_0;
        // N s_1018_2: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1019_0: read-var gs#118000:u8
        let s_1019_0: bool = fn_state.gs_118000;
        // N s_1019_1: branch s_1019_0 b5104 b1020
        if s_1019_0 {
            return block_5104(state, tracer, fn_state);
        } else {
            return block_1020(state, tracer, fn_state);
        };
    }
    fn block_1020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1020_0: const #0u : u8
        let s_1020_0: bool = false;
        // D s_1020_1: write-var gs#118001 <= s_1020_0
        fn_state.gs_118001 = s_1020_0;
        // N s_1020_2: jump b1021
        return block_1021(state, tracer, fn_state);
    }
    fn block_1021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1021_0: read-var gs#118001:u8
        let s_1021_0: bool = fn_state.gs_118001;
        // N s_1021_1: branch s_1021_0 b5103 b1022
        if s_1021_0 {
            return block_5103(state, tracer, fn_state);
        } else {
            return block_1022(state, tracer, fn_state);
        };
    }
    fn block_1022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1022_0: const #0u : u8
        let s_1022_0: bool = false;
        // D s_1022_1: write-var gs#118002 <= s_1022_0
        fn_state.gs_118002 = s_1022_0;
        // N s_1022_2: jump b1023
        return block_1023(state, tracer, fn_state);
    }
    fn block_1023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1023_0: read-var gs#118002:u8
        let s_1023_0: bool = fn_state.gs_118002;
        // N s_1023_1: branch s_1023_0 b5102 b1024
        if s_1023_0 {
            return block_5102(state, tracer, fn_state);
        } else {
            return block_1024(state, tracer, fn_state);
        };
    }
    fn block_1024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1024_0: const #0u : u8
        let s_1024_0: bool = false;
        // D s_1024_1: write-var gs#118003 <= s_1024_0
        fn_state.gs_118003 = s_1024_0;
        // N s_1024_2: jump b1025
        return block_1025(state, tracer, fn_state);
    }
    fn block_1025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1025_0: read-var gs#118003:u8
        let s_1025_0: bool = fn_state.gs_118003;
        // N s_1025_1: branch s_1025_0 b5101 b1026
        if s_1025_0 {
            return block_5101(state, tracer, fn_state);
        } else {
            return block_1026(state, tracer, fn_state);
        };
    }
    fn block_1026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1026_0: read-var CRm:u8
        let s_1026_0: u8 = fn_state.CRm;
        // D s_1026_1: cast zx s_1026_0 -> bv
        let s_1026_1: Bits = Bits::new(s_1026_0 as u128, 4u16);
        // C s_1026_2: const #5u : u8
        let s_1026_2: u8 = 5;
        // C s_1026_3: cast zx s_1026_2 -> bv
        let s_1026_3: Bits = Bits::new(s_1026_2 as u128, 4u16);
        // D s_1026_4: cmp-eq s_1026_1 s_1026_3
        let s_1026_4: bool = ((s_1026_1) == (s_1026_3));
        // N s_1026_5: branch s_1026_4 b5100 b1027
        if s_1026_4 {
            return block_5100(state, tracer, fn_state);
        } else {
            return block_1027(state, tracer, fn_state);
        };
    }
    fn block_1027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1027_0: const #0u : u8
        let s_1027_0: bool = false;
        // D s_1027_1: write-var gs#118004 <= s_1027_0
        fn_state.gs_118004 = s_1027_0;
        // N s_1027_2: jump b1028
        return block_1028(state, tracer, fn_state);
    }
    fn block_1028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1028_0: read-var gs#118004:u8
        let s_1028_0: bool = fn_state.gs_118004;
        // N s_1028_1: branch s_1028_0 b5099 b1029
        if s_1028_0 {
            return block_5099(state, tracer, fn_state);
        } else {
            return block_1029(state, tracer, fn_state);
        };
    }
    fn block_1029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1029_0: const #0u : u8
        let s_1029_0: bool = false;
        // D s_1029_1: write-var gs#118005 <= s_1029_0
        fn_state.gs_118005 = s_1029_0;
        // N s_1029_2: jump b1030
        return block_1030(state, tracer, fn_state);
    }
    fn block_1030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1030_0: read-var gs#118005:u8
        let s_1030_0: bool = fn_state.gs_118005;
        // N s_1030_1: branch s_1030_0 b5098 b1031
        if s_1030_0 {
            return block_5098(state, tracer, fn_state);
        } else {
            return block_1031(state, tracer, fn_state);
        };
    }
    fn block_1031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1031_0: const #0u : u8
        let s_1031_0: bool = false;
        // D s_1031_1: write-var gs#118006 <= s_1031_0
        fn_state.gs_118006 = s_1031_0;
        // N s_1031_2: jump b1032
        return block_1032(state, tracer, fn_state);
    }
    fn block_1032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1032_0: read-var gs#118006:u8
        let s_1032_0: bool = fn_state.gs_118006;
        // N s_1032_1: branch s_1032_0 b5097 b1033
        if s_1032_0 {
            return block_5097(state, tracer, fn_state);
        } else {
            return block_1033(state, tracer, fn_state);
        };
    }
    fn block_1033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1033_0: const #0u : u8
        let s_1033_0: bool = false;
        // D s_1033_1: write-var gs#118007 <= s_1033_0
        fn_state.gs_118007 = s_1033_0;
        // N s_1033_2: jump b1034
        return block_1034(state, tracer, fn_state);
    }
    fn block_1034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1034_0: read-var gs#118007:u8
        let s_1034_0: bool = fn_state.gs_118007;
        // N s_1034_1: branch s_1034_0 b5096 b1035
        if s_1034_0 {
            return block_5096(state, tracer, fn_state);
        } else {
            return block_1035(state, tracer, fn_state);
        };
    }
    fn block_1035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1035_0: read-var CRm:u8
        let s_1035_0: u8 = fn_state.CRm;
        // D s_1035_1: cast zx s_1035_0 -> bv
        let s_1035_1: Bits = Bits::new(s_1035_0 as u128, 4u16);
        // C s_1035_2: const #4u : u8
        let s_1035_2: u8 = 4;
        // C s_1035_3: cast zx s_1035_2 -> bv
        let s_1035_3: Bits = Bits::new(s_1035_2 as u128, 4u16);
        // D s_1035_4: cmp-eq s_1035_1 s_1035_3
        let s_1035_4: bool = ((s_1035_1) == (s_1035_3));
        // N s_1035_5: branch s_1035_4 b5095 b1036
        if s_1035_4 {
            return block_5095(state, tracer, fn_state);
        } else {
            return block_1036(state, tracer, fn_state);
        };
    }
    fn block_1036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1036_0: const #0u : u8
        let s_1036_0: bool = false;
        // D s_1036_1: write-var gs#118008 <= s_1036_0
        fn_state.gs_118008 = s_1036_0;
        // N s_1036_2: jump b1037
        return block_1037(state, tracer, fn_state);
    }
    fn block_1037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1037_0: read-var gs#118008:u8
        let s_1037_0: bool = fn_state.gs_118008;
        // N s_1037_1: branch s_1037_0 b5094 b1038
        if s_1037_0 {
            return block_5094(state, tracer, fn_state);
        } else {
            return block_1038(state, tracer, fn_state);
        };
    }
    fn block_1038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1038_0: const #0u : u8
        let s_1038_0: bool = false;
        // D s_1038_1: write-var gs#118009 <= s_1038_0
        fn_state.gs_118009 = s_1038_0;
        // N s_1038_2: jump b1039
        return block_1039(state, tracer, fn_state);
    }
    fn block_1039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1039_0: read-var gs#118009:u8
        let s_1039_0: bool = fn_state.gs_118009;
        // N s_1039_1: branch s_1039_0 b5093 b1040
        if s_1039_0 {
            return block_5093(state, tracer, fn_state);
        } else {
            return block_1040(state, tracer, fn_state);
        };
    }
    fn block_1040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1040_0: const #0u : u8
        let s_1040_0: bool = false;
        // D s_1040_1: write-var gs#118010 <= s_1040_0
        fn_state.gs_118010 = s_1040_0;
        // N s_1040_2: jump b1041
        return block_1041(state, tracer, fn_state);
    }
    fn block_1041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1041_0: read-var gs#118010:u8
        let s_1041_0: bool = fn_state.gs_118010;
        // N s_1041_1: branch s_1041_0 b5092 b1042
        if s_1041_0 {
            return block_5092(state, tracer, fn_state);
        } else {
            return block_1042(state, tracer, fn_state);
        };
    }
    fn block_1042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1042_0: const #0u : u8
        let s_1042_0: bool = false;
        // D s_1042_1: write-var gs#118011 <= s_1042_0
        fn_state.gs_118011 = s_1042_0;
        // N s_1042_2: jump b1043
        return block_1043(state, tracer, fn_state);
    }
    fn block_1043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1043_0: read-var gs#118011:u8
        let s_1043_0: bool = fn_state.gs_118011;
        // N s_1043_1: branch s_1043_0 b5091 b1044
        if s_1043_0 {
            return block_5091(state, tracer, fn_state);
        } else {
            return block_1044(state, tracer, fn_state);
        };
    }
    fn block_1044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1044_0: read-var CRm:u8
        let s_1044_0: u8 = fn_state.CRm;
        // D s_1044_1: cast zx s_1044_0 -> bv
        let s_1044_1: Bits = Bits::new(s_1044_0 as u128, 4u16);
        // C s_1044_2: const #3u : u8
        let s_1044_2: u8 = 3;
        // C s_1044_3: cast zx s_1044_2 -> bv
        let s_1044_3: Bits = Bits::new(s_1044_2 as u128, 4u16);
        // D s_1044_4: cmp-eq s_1044_1 s_1044_3
        let s_1044_4: bool = ((s_1044_1) == (s_1044_3));
        // N s_1044_5: branch s_1044_4 b5090 b1045
        if s_1044_4 {
            return block_5090(state, tracer, fn_state);
        } else {
            return block_1045(state, tracer, fn_state);
        };
    }
    fn block_1045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1045_0: const #0u : u8
        let s_1045_0: bool = false;
        // D s_1045_1: write-var gs#118012 <= s_1045_0
        fn_state.gs_118012 = s_1045_0;
        // N s_1045_2: jump b1046
        return block_1046(state, tracer, fn_state);
    }
    fn block_1046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1046_0: read-var gs#118012:u8
        let s_1046_0: bool = fn_state.gs_118012;
        // N s_1046_1: branch s_1046_0 b5089 b1047
        if s_1046_0 {
            return block_5089(state, tracer, fn_state);
        } else {
            return block_1047(state, tracer, fn_state);
        };
    }
    fn block_1047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1047_0: const #0u : u8
        let s_1047_0: bool = false;
        // D s_1047_1: write-var gs#118013 <= s_1047_0
        fn_state.gs_118013 = s_1047_0;
        // N s_1047_2: jump b1048
        return block_1048(state, tracer, fn_state);
    }
    fn block_1048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1048_0: read-var gs#118013:u8
        let s_1048_0: bool = fn_state.gs_118013;
        // N s_1048_1: branch s_1048_0 b5088 b1049
        if s_1048_0 {
            return block_5088(state, tracer, fn_state);
        } else {
            return block_1049(state, tracer, fn_state);
        };
    }
    fn block_1049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1049_0: const #0u : u8
        let s_1049_0: bool = false;
        // D s_1049_1: write-var gs#118014 <= s_1049_0
        fn_state.gs_118014 = s_1049_0;
        // N s_1049_2: jump b1050
        return block_1050(state, tracer, fn_state);
    }
    fn block_1050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1050_0: read-var gs#118014:u8
        let s_1050_0: bool = fn_state.gs_118014;
        // N s_1050_1: branch s_1050_0 b5087 b1051
        if s_1050_0 {
            return block_5087(state, tracer, fn_state);
        } else {
            return block_1051(state, tracer, fn_state);
        };
    }
    fn block_1051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1051_0: const #0u : u8
        let s_1051_0: bool = false;
        // D s_1051_1: write-var gs#118015 <= s_1051_0
        fn_state.gs_118015 = s_1051_0;
        // N s_1051_2: jump b1052
        return block_1052(state, tracer, fn_state);
    }
    fn block_1052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1052_0: read-var gs#118015:u8
        let s_1052_0: bool = fn_state.gs_118015;
        // N s_1052_1: branch s_1052_0 b5086 b1053
        if s_1052_0 {
            return block_5086(state, tracer, fn_state);
        } else {
            return block_1053(state, tracer, fn_state);
        };
    }
    fn block_1053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1053_0: read-var CRm:u8
        let s_1053_0: u8 = fn_state.CRm;
        // D s_1053_1: cast zx s_1053_0 -> bv
        let s_1053_1: Bits = Bits::new(s_1053_0 as u128, 4u16);
        // C s_1053_2: const #2u : u8
        let s_1053_2: u8 = 2;
        // C s_1053_3: cast zx s_1053_2 -> bv
        let s_1053_3: Bits = Bits::new(s_1053_2 as u128, 4u16);
        // D s_1053_4: cmp-eq s_1053_1 s_1053_3
        let s_1053_4: bool = ((s_1053_1) == (s_1053_3));
        // N s_1053_5: branch s_1053_4 b5085 b1054
        if s_1053_4 {
            return block_5085(state, tracer, fn_state);
        } else {
            return block_1054(state, tracer, fn_state);
        };
    }
    fn block_1054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1054_0: const #0u : u8
        let s_1054_0: bool = false;
        // D s_1054_1: write-var gs#118016 <= s_1054_0
        fn_state.gs_118016 = s_1054_0;
        // N s_1054_2: jump b1055
        return block_1055(state, tracer, fn_state);
    }
    fn block_1055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1055_0: read-var gs#118016:u8
        let s_1055_0: bool = fn_state.gs_118016;
        // N s_1055_1: branch s_1055_0 b5084 b1056
        if s_1055_0 {
            return block_5084(state, tracer, fn_state);
        } else {
            return block_1056(state, tracer, fn_state);
        };
    }
    fn block_1056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1056_0: const #0u : u8
        let s_1056_0: bool = false;
        // D s_1056_1: write-var gs#118017 <= s_1056_0
        fn_state.gs_118017 = s_1056_0;
        // N s_1056_2: jump b1057
        return block_1057(state, tracer, fn_state);
    }
    fn block_1057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1057_0: read-var gs#118017:u8
        let s_1057_0: bool = fn_state.gs_118017;
        // N s_1057_1: branch s_1057_0 b5083 b1058
        if s_1057_0 {
            return block_5083(state, tracer, fn_state);
        } else {
            return block_1058(state, tracer, fn_state);
        };
    }
    fn block_1058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1058_0: const #0u : u8
        let s_1058_0: bool = false;
        // D s_1058_1: write-var gs#118018 <= s_1058_0
        fn_state.gs_118018 = s_1058_0;
        // N s_1058_2: jump b1059
        return block_1059(state, tracer, fn_state);
    }
    fn block_1059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1059_0: read-var gs#118018:u8
        let s_1059_0: bool = fn_state.gs_118018;
        // N s_1059_1: branch s_1059_0 b5082 b1060
        if s_1059_0 {
            return block_5082(state, tracer, fn_state);
        } else {
            return block_1060(state, tracer, fn_state);
        };
    }
    fn block_1060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1060_0: const #0u : u8
        let s_1060_0: bool = false;
        // D s_1060_1: write-var gs#118019 <= s_1060_0
        fn_state.gs_118019 = s_1060_0;
        // N s_1060_2: jump b1061
        return block_1061(state, tracer, fn_state);
    }
    fn block_1061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1061_0: read-var gs#118019:u8
        let s_1061_0: bool = fn_state.gs_118019;
        // N s_1061_1: branch s_1061_0 b5081 b1062
        if s_1061_0 {
            return block_5081(state, tracer, fn_state);
        } else {
            return block_1062(state, tracer, fn_state);
        };
    }
    fn block_1062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1062_0: read-var CRm:u8
        let s_1062_0: u8 = fn_state.CRm;
        // D s_1062_1: cast zx s_1062_0 -> bv
        let s_1062_1: Bits = Bits::new(s_1062_0 as u128, 4u16);
        // C s_1062_2: const #1u : u8
        let s_1062_2: u8 = 1;
        // C s_1062_3: cast zx s_1062_2 -> bv
        let s_1062_3: Bits = Bits::new(s_1062_2 as u128, 4u16);
        // D s_1062_4: cmp-eq s_1062_1 s_1062_3
        let s_1062_4: bool = ((s_1062_1) == (s_1062_3));
        // N s_1062_5: branch s_1062_4 b5080 b1063
        if s_1062_4 {
            return block_5080(state, tracer, fn_state);
        } else {
            return block_1063(state, tracer, fn_state);
        };
    }
    fn block_1063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1063_0: const #0u : u8
        let s_1063_0: bool = false;
        // D s_1063_1: write-var gs#118020 <= s_1063_0
        fn_state.gs_118020 = s_1063_0;
        // N s_1063_2: jump b1064
        return block_1064(state, tracer, fn_state);
    }
    fn block_1064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1064_0: read-var gs#118020:u8
        let s_1064_0: bool = fn_state.gs_118020;
        // N s_1064_1: branch s_1064_0 b5079 b1065
        if s_1064_0 {
            return block_5079(state, tracer, fn_state);
        } else {
            return block_1065(state, tracer, fn_state);
        };
    }
    fn block_1065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1065_0: const #0u : u8
        let s_1065_0: bool = false;
        // D s_1065_1: write-var gs#118021 <= s_1065_0
        fn_state.gs_118021 = s_1065_0;
        // N s_1065_2: jump b1066
        return block_1066(state, tracer, fn_state);
    }
    fn block_1066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1066_0: read-var gs#118021:u8
        let s_1066_0: bool = fn_state.gs_118021;
        // N s_1066_1: branch s_1066_0 b5078 b1067
        if s_1066_0 {
            return block_5078(state, tracer, fn_state);
        } else {
            return block_1067(state, tracer, fn_state);
        };
    }
    fn block_1067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1067_0: const #0u : u8
        let s_1067_0: bool = false;
        // D s_1067_1: write-var gs#118022 <= s_1067_0
        fn_state.gs_118022 = s_1067_0;
        // N s_1067_2: jump b1068
        return block_1068(state, tracer, fn_state);
    }
    fn block_1068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1068_0: read-var gs#118022:u8
        let s_1068_0: bool = fn_state.gs_118022;
        // N s_1068_1: branch s_1068_0 b5077 b1069
        if s_1068_0 {
            return block_5077(state, tracer, fn_state);
        } else {
            return block_1069(state, tracer, fn_state);
        };
    }
    fn block_1069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1069_0: const #0u : u8
        let s_1069_0: bool = false;
        // D s_1069_1: write-var gs#118023 <= s_1069_0
        fn_state.gs_118023 = s_1069_0;
        // N s_1069_2: jump b1070
        return block_1070(state, tracer, fn_state);
    }
    fn block_1070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1070_0: read-var gs#118023:u8
        let s_1070_0: bool = fn_state.gs_118023;
        // N s_1070_1: branch s_1070_0 b5076 b1071
        if s_1070_0 {
            return block_5076(state, tracer, fn_state);
        } else {
            return block_1071(state, tracer, fn_state);
        };
    }
    fn block_1071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1071_0: read-var CRm:u8
        let s_1071_0: u8 = fn_state.CRm;
        // D s_1071_1: cast zx s_1071_0 -> bv
        let s_1071_1: Bits = Bits::new(s_1071_0 as u128, 4u16);
        // C s_1071_2: const #0u : u8
        let s_1071_2: u8 = 0;
        // C s_1071_3: cast zx s_1071_2 -> bv
        let s_1071_3: Bits = Bits::new(s_1071_2 as u128, 4u16);
        // D s_1071_4: cmp-eq s_1071_1 s_1071_3
        let s_1071_4: bool = ((s_1071_1) == (s_1071_3));
        // N s_1071_5: branch s_1071_4 b5075 b1072
        if s_1071_4 {
            return block_5075(state, tracer, fn_state);
        } else {
            return block_1072(state, tracer, fn_state);
        };
    }
    fn block_1072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1072_0: const #0u : u8
        let s_1072_0: bool = false;
        // D s_1072_1: write-var gs#118024 <= s_1072_0
        fn_state.gs_118024 = s_1072_0;
        // N s_1072_2: jump b1073
        return block_1073(state, tracer, fn_state);
    }
    fn block_1073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1073_0: read-var gs#118024:u8
        let s_1073_0: bool = fn_state.gs_118024;
        // N s_1073_1: branch s_1073_0 b5074 b1074
        if s_1073_0 {
            return block_5074(state, tracer, fn_state);
        } else {
            return block_1074(state, tracer, fn_state);
        };
    }
    fn block_1074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1074_0: const #0u : u8
        let s_1074_0: bool = false;
        // D s_1074_1: write-var gs#118025 <= s_1074_0
        fn_state.gs_118025 = s_1074_0;
        // N s_1074_2: jump b1075
        return block_1075(state, tracer, fn_state);
    }
    fn block_1075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1075_0: read-var gs#118025:u8
        let s_1075_0: bool = fn_state.gs_118025;
        // N s_1075_1: branch s_1075_0 b5073 b1076
        if s_1075_0 {
            return block_5073(state, tracer, fn_state);
        } else {
            return block_1076(state, tracer, fn_state);
        };
    }
    fn block_1076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1076_0: const #0u : u8
        let s_1076_0: bool = false;
        // D s_1076_1: write-var gs#118026 <= s_1076_0
        fn_state.gs_118026 = s_1076_0;
        // N s_1076_2: jump b1077
        return block_1077(state, tracer, fn_state);
    }
    fn block_1077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1077_0: read-var gs#118026:u8
        let s_1077_0: bool = fn_state.gs_118026;
        // N s_1077_1: branch s_1077_0 b5072 b1078
        if s_1077_0 {
            return block_5072(state, tracer, fn_state);
        } else {
            return block_1078(state, tracer, fn_state);
        };
    }
    fn block_1078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1078_0: const #0u : u8
        let s_1078_0: bool = false;
        // D s_1078_1: write-var gs#118027 <= s_1078_0
        fn_state.gs_118027 = s_1078_0;
        // N s_1078_2: jump b1079
        return block_1079(state, tracer, fn_state);
    }
    fn block_1079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1079_0: read-var gs#118027:u8
        let s_1079_0: bool = fn_state.gs_118027;
        // N s_1079_1: branch s_1079_0 b5071 b1080
        if s_1079_0 {
            return block_5071(state, tracer, fn_state);
        } else {
            return block_1080(state, tracer, fn_state);
        };
    }
    fn block_1080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1080_0: read-var CRm:u8
        let s_1080_0: u8 = fn_state.CRm;
        // D s_1080_1: cast zx s_1080_0 -> bv
        let s_1080_1: Bits = Bits::new(s_1080_0 as u128, 4u16);
        // C s_1080_2: const #11u : u8
        let s_1080_2: u8 = 11;
        // C s_1080_3: cast zx s_1080_2 -> bv
        let s_1080_3: Bits = Bits::new(s_1080_2 as u128, 4u16);
        // D s_1080_4: cmp-eq s_1080_1 s_1080_3
        let s_1080_4: bool = ((s_1080_1) == (s_1080_3));
        // N s_1080_5: branch s_1080_4 b5070 b1081
        if s_1080_4 {
            return block_5070(state, tracer, fn_state);
        } else {
            return block_1081(state, tracer, fn_state);
        };
    }
    fn block_1081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1081_0: const #0u : u8
        let s_1081_0: bool = false;
        // D s_1081_1: write-var gs#118028 <= s_1081_0
        fn_state.gs_118028 = s_1081_0;
        // N s_1081_2: jump b1082
        return block_1082(state, tracer, fn_state);
    }
    fn block_1082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1082_0: read-var gs#118028:u8
        let s_1082_0: bool = fn_state.gs_118028;
        // N s_1082_1: branch s_1082_0 b5069 b1083
        if s_1082_0 {
            return block_5069(state, tracer, fn_state);
        } else {
            return block_1083(state, tracer, fn_state);
        };
    }
    fn block_1083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1083_0: const #0u : u8
        let s_1083_0: bool = false;
        // D s_1083_1: write-var gs#118029 <= s_1083_0
        fn_state.gs_118029 = s_1083_0;
        // N s_1083_2: jump b1084
        return block_1084(state, tracer, fn_state);
    }
    fn block_1084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1084_0: read-var gs#118029:u8
        let s_1084_0: bool = fn_state.gs_118029;
        // N s_1084_1: branch s_1084_0 b5068 b1085
        if s_1084_0 {
            return block_5068(state, tracer, fn_state);
        } else {
            return block_1085(state, tracer, fn_state);
        };
    }
    fn block_1085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1085_0: const #0u : u8
        let s_1085_0: bool = false;
        // D s_1085_1: write-var gs#118030 <= s_1085_0
        fn_state.gs_118030 = s_1085_0;
        // N s_1085_2: jump b1086
        return block_1086(state, tracer, fn_state);
    }
    fn block_1086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1086_0: read-var gs#118030:u8
        let s_1086_0: bool = fn_state.gs_118030;
        // N s_1086_1: branch s_1086_0 b5067 b1087
        if s_1086_0 {
            return block_5067(state, tracer, fn_state);
        } else {
            return block_1087(state, tracer, fn_state);
        };
    }
    fn block_1087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1087_0: const #0u : u8
        let s_1087_0: bool = false;
        // D s_1087_1: write-var gs#118031 <= s_1087_0
        fn_state.gs_118031 = s_1087_0;
        // N s_1087_2: jump b1088
        return block_1088(state, tracer, fn_state);
    }
    fn block_1088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1088_0: read-var gs#118031:u8
        let s_1088_0: bool = fn_state.gs_118031;
        // N s_1088_1: branch s_1088_0 b5066 b1089
        if s_1088_0 {
            return block_5066(state, tracer, fn_state);
        } else {
            return block_1089(state, tracer, fn_state);
        };
    }
    fn block_1089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1089_0: read-var CRm:u8
        let s_1089_0: u8 = fn_state.CRm;
        // D s_1089_1: cast zx s_1089_0 -> bv
        let s_1089_1: Bits = Bits::new(s_1089_0 as u128, 4u16);
        // C s_1089_2: const #1u : u8
        let s_1089_2: u8 = 1;
        // C s_1089_3: cast zx s_1089_2 -> bv
        let s_1089_3: Bits = Bits::new(s_1089_2 as u128, 4u16);
        // D s_1089_4: cmp-eq s_1089_1 s_1089_3
        let s_1089_4: bool = ((s_1089_1) == (s_1089_3));
        // N s_1089_5: branch s_1089_4 b5065 b1090
        if s_1089_4 {
            return block_5065(state, tracer, fn_state);
        } else {
            return block_1090(state, tracer, fn_state);
        };
    }
    fn block_1090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1090_0: const #0u : u8
        let s_1090_0: bool = false;
        // D s_1090_1: write-var gs#118032 <= s_1090_0
        fn_state.gs_118032 = s_1090_0;
        // N s_1090_2: jump b1091
        return block_1091(state, tracer, fn_state);
    }
    fn block_1091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1091_0: read-var gs#118032:u8
        let s_1091_0: bool = fn_state.gs_118032;
        // N s_1091_1: branch s_1091_0 b5064 b1092
        if s_1091_0 {
            return block_5064(state, tracer, fn_state);
        } else {
            return block_1092(state, tracer, fn_state);
        };
    }
    fn block_1092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1092_0: const #0u : u8
        let s_1092_0: bool = false;
        // D s_1092_1: write-var gs#118033 <= s_1092_0
        fn_state.gs_118033 = s_1092_0;
        // N s_1092_2: jump b1093
        return block_1093(state, tracer, fn_state);
    }
    fn block_1093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1093_0: read-var gs#118033:u8
        let s_1093_0: bool = fn_state.gs_118033;
        // N s_1093_1: branch s_1093_0 b5063 b1094
        if s_1093_0 {
            return block_5063(state, tracer, fn_state);
        } else {
            return block_1094(state, tracer, fn_state);
        };
    }
    fn block_1094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1094_0: const #0u : u8
        let s_1094_0: bool = false;
        // D s_1094_1: write-var gs#118034 <= s_1094_0
        fn_state.gs_118034 = s_1094_0;
        // N s_1094_2: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_1095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1095_0: read-var gs#118034:u8
        let s_1095_0: bool = fn_state.gs_118034;
        // N s_1095_1: branch s_1095_0 b5062 b1096
        if s_1095_0 {
            return block_5062(state, tracer, fn_state);
        } else {
            return block_1096(state, tracer, fn_state);
        };
    }
    fn block_1096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1096_0: const #0u : u8
        let s_1096_0: bool = false;
        // D s_1096_1: write-var gs#118035 <= s_1096_0
        fn_state.gs_118035 = s_1096_0;
        // N s_1096_2: jump b1097
        return block_1097(state, tracer, fn_state);
    }
    fn block_1097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1097_0: read-var gs#118035:u8
        let s_1097_0: bool = fn_state.gs_118035;
        // N s_1097_1: branch s_1097_0 b5061 b1098
        if s_1097_0 {
            return block_5061(state, tracer, fn_state);
        } else {
            return block_1098(state, tracer, fn_state);
        };
    }
    fn block_1098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1098_0: read-var CRm:u8
        let s_1098_0: u8 = fn_state.CRm;
        // D s_1098_1: cast zx s_1098_0 -> bv
        let s_1098_1: Bits = Bits::new(s_1098_0 as u128, 4u16);
        // C s_1098_2: const #12u : u8
        let s_1098_2: u8 = 12;
        // C s_1098_3: cast zx s_1098_2 -> bv
        let s_1098_3: Bits = Bits::new(s_1098_2 as u128, 4u16);
        // D s_1098_4: cmp-eq s_1098_1 s_1098_3
        let s_1098_4: bool = ((s_1098_1) == (s_1098_3));
        // N s_1098_5: branch s_1098_4 b5060 b1099
        if s_1098_4 {
            return block_5060(state, tracer, fn_state);
        } else {
            return block_1099(state, tracer, fn_state);
        };
    }
    fn block_1099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1099_0: const #0u : u8
        let s_1099_0: bool = false;
        // D s_1099_1: write-var gs#118036 <= s_1099_0
        fn_state.gs_118036 = s_1099_0;
        // N s_1099_2: jump b1100
        return block_1100(state, tracer, fn_state);
    }
    fn block_1100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1100_0: read-var gs#118036:u8
        let s_1100_0: bool = fn_state.gs_118036;
        // N s_1100_1: branch s_1100_0 b5059 b1101
        if s_1100_0 {
            return block_5059(state, tracer, fn_state);
        } else {
            return block_1101(state, tracer, fn_state);
        };
    }
    fn block_1101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1101_0: const #0u : u8
        let s_1101_0: bool = false;
        // D s_1101_1: write-var gs#118037 <= s_1101_0
        fn_state.gs_118037 = s_1101_0;
        // N s_1101_2: jump b1102
        return block_1102(state, tracer, fn_state);
    }
    fn block_1102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1102_0: read-var gs#118037:u8
        let s_1102_0: bool = fn_state.gs_118037;
        // N s_1102_1: branch s_1102_0 b5058 b1103
        if s_1102_0 {
            return block_5058(state, tracer, fn_state);
        } else {
            return block_1103(state, tracer, fn_state);
        };
    }
    fn block_1103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1103_0: const #0u : u8
        let s_1103_0: bool = false;
        // D s_1103_1: write-var gs#118038 <= s_1103_0
        fn_state.gs_118038 = s_1103_0;
        // N s_1103_2: jump b1104
        return block_1104(state, tracer, fn_state);
    }
    fn block_1104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1104_0: read-var gs#118038:u8
        let s_1104_0: bool = fn_state.gs_118038;
        // N s_1104_1: branch s_1104_0 b5057 b1105
        if s_1104_0 {
            return block_5057(state, tracer, fn_state);
        } else {
            return block_1105(state, tracer, fn_state);
        };
    }
    fn block_1105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1105_0: const #0u : u8
        let s_1105_0: bool = false;
        // D s_1105_1: write-var gs#118039 <= s_1105_0
        fn_state.gs_118039 = s_1105_0;
        // N s_1105_2: jump b1106
        return block_1106(state, tracer, fn_state);
    }
    fn block_1106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1106_0: read-var gs#118039:u8
        let s_1106_0: bool = fn_state.gs_118039;
        // N s_1106_1: branch s_1106_0 b5056 b1107
        if s_1106_0 {
            return block_5056(state, tracer, fn_state);
        } else {
            return block_1107(state, tracer, fn_state);
        };
    }
    fn block_1107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1107_0: read-var CRm:u8
        let s_1107_0: u8 = fn_state.CRm;
        // D s_1107_1: cast zx s_1107_0 -> bv
        let s_1107_1: Bits = Bits::new(s_1107_0 as u128, 4u16);
        // C s_1107_2: const #13u : u8
        let s_1107_2: u8 = 13;
        // C s_1107_3: cast zx s_1107_2 -> bv
        let s_1107_3: Bits = Bits::new(s_1107_2 as u128, 4u16);
        // D s_1107_4: cmp-eq s_1107_1 s_1107_3
        let s_1107_4: bool = ((s_1107_1) == (s_1107_3));
        // N s_1107_5: branch s_1107_4 b5055 b1108
        if s_1107_4 {
            return block_5055(state, tracer, fn_state);
        } else {
            return block_1108(state, tracer, fn_state);
        };
    }
    fn block_1108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1108_0: const #0u : u8
        let s_1108_0: bool = false;
        // D s_1108_1: write-var gs#118040 <= s_1108_0
        fn_state.gs_118040 = s_1108_0;
        // N s_1108_2: jump b1109
        return block_1109(state, tracer, fn_state);
    }
    fn block_1109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1109_0: read-var gs#118040:u8
        let s_1109_0: bool = fn_state.gs_118040;
        // N s_1109_1: branch s_1109_0 b5054 b1110
        if s_1109_0 {
            return block_5054(state, tracer, fn_state);
        } else {
            return block_1110(state, tracer, fn_state);
        };
    }
    fn block_1110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1110_0: const #0u : u8
        let s_1110_0: bool = false;
        // D s_1110_1: write-var gs#118041 <= s_1110_0
        fn_state.gs_118041 = s_1110_0;
        // N s_1110_2: jump b1111
        return block_1111(state, tracer, fn_state);
    }
    fn block_1111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1111_0: read-var gs#118041:u8
        let s_1111_0: bool = fn_state.gs_118041;
        // N s_1111_1: branch s_1111_0 b5053 b1112
        if s_1111_0 {
            return block_5053(state, tracer, fn_state);
        } else {
            return block_1112(state, tracer, fn_state);
        };
    }
    fn block_1112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1112_0: const #0u : u8
        let s_1112_0: bool = false;
        // D s_1112_1: write-var gs#118042 <= s_1112_0
        fn_state.gs_118042 = s_1112_0;
        // N s_1112_2: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_1113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1113_0: read-var gs#118042:u8
        let s_1113_0: bool = fn_state.gs_118042;
        // N s_1113_1: branch s_1113_0 b5052 b1114
        if s_1113_0 {
            return block_5052(state, tracer, fn_state);
        } else {
            return block_1114(state, tracer, fn_state);
        };
    }
    fn block_1114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1114_0: const #0u : u8
        let s_1114_0: bool = false;
        // D s_1114_1: write-var gs#118043 <= s_1114_0
        fn_state.gs_118043 = s_1114_0;
        // N s_1114_2: jump b1115
        return block_1115(state, tracer, fn_state);
    }
    fn block_1115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1115_0: read-var gs#118043:u8
        let s_1115_0: bool = fn_state.gs_118043;
        // N s_1115_1: branch s_1115_0 b5051 b1116
        if s_1115_0 {
            return block_5051(state, tracer, fn_state);
        } else {
            return block_1116(state, tracer, fn_state);
        };
    }
    fn block_1116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1116_0: read-var CRm:u8
        let s_1116_0: u8 = fn_state.CRm;
        // D s_1116_1: cast zx s_1116_0 -> bv
        let s_1116_1: Bits = Bits::new(s_1116_0 as u128, 4u16);
        // C s_1116_2: const #11u : u8
        let s_1116_2: u8 = 11;
        // C s_1116_3: cast zx s_1116_2 -> bv
        let s_1116_3: Bits = Bits::new(s_1116_2 as u128, 4u16);
        // D s_1116_4: cmp-eq s_1116_1 s_1116_3
        let s_1116_4: bool = ((s_1116_1) == (s_1116_3));
        // N s_1116_5: branch s_1116_4 b5050 b1117
        if s_1116_4 {
            return block_5050(state, tracer, fn_state);
        } else {
            return block_1117(state, tracer, fn_state);
        };
    }
    fn block_1117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1117_0: const #0u : u8
        let s_1117_0: bool = false;
        // D s_1117_1: write-var gs#118044 <= s_1117_0
        fn_state.gs_118044 = s_1117_0;
        // N s_1117_2: jump b1118
        return block_1118(state, tracer, fn_state);
    }
    fn block_1118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1118_0: read-var gs#118044:u8
        let s_1118_0: bool = fn_state.gs_118044;
        // N s_1118_1: branch s_1118_0 b5049 b1119
        if s_1118_0 {
            return block_5049(state, tracer, fn_state);
        } else {
            return block_1119(state, tracer, fn_state);
        };
    }
    fn block_1119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1119_0: const #0u : u8
        let s_1119_0: bool = false;
        // D s_1119_1: write-var gs#118045 <= s_1119_0
        fn_state.gs_118045 = s_1119_0;
        // N s_1119_2: jump b1120
        return block_1120(state, tracer, fn_state);
    }
    fn block_1120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1120_0: read-var gs#118045:u8
        let s_1120_0: bool = fn_state.gs_118045;
        // N s_1120_1: branch s_1120_0 b5048 b1121
        if s_1120_0 {
            return block_5048(state, tracer, fn_state);
        } else {
            return block_1121(state, tracer, fn_state);
        };
    }
    fn block_1121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1121_0: const #0u : u8
        let s_1121_0: bool = false;
        // D s_1121_1: write-var gs#118046 <= s_1121_0
        fn_state.gs_118046 = s_1121_0;
        // N s_1121_2: jump b1122
        return block_1122(state, tracer, fn_state);
    }
    fn block_1122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1122_0: read-var gs#118046:u8
        let s_1122_0: bool = fn_state.gs_118046;
        // N s_1122_1: branch s_1122_0 b5047 b1123
        if s_1122_0 {
            return block_5047(state, tracer, fn_state);
        } else {
            return block_1123(state, tracer, fn_state);
        };
    }
    fn block_1123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1123_0: const #0u : u8
        let s_1123_0: bool = false;
        // D s_1123_1: write-var gs#118047 <= s_1123_0
        fn_state.gs_118047 = s_1123_0;
        // N s_1123_2: jump b1124
        return block_1124(state, tracer, fn_state);
    }
    fn block_1124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1124_0: read-var gs#118047:u8
        let s_1124_0: bool = fn_state.gs_118047;
        // N s_1124_1: branch s_1124_0 b5046 b1125
        if s_1124_0 {
            return block_5046(state, tracer, fn_state);
        } else {
            return block_1125(state, tracer, fn_state);
        };
    }
    fn block_1125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1125_0: read-var CRm:u8
        let s_1125_0: u8 = fn_state.CRm;
        // D s_1125_1: cast zx s_1125_0 -> bv
        let s_1125_1: Bits = Bits::new(s_1125_0 as u128, 4u16);
        // C s_1125_2: const #0u : u8
        let s_1125_2: u8 = 0;
        // C s_1125_3: cast zx s_1125_2 -> bv
        let s_1125_3: Bits = Bits::new(s_1125_2 as u128, 4u16);
        // D s_1125_4: cmp-eq s_1125_1 s_1125_3
        let s_1125_4: bool = ((s_1125_1) == (s_1125_3));
        // N s_1125_5: branch s_1125_4 b5045 b1126
        if s_1125_4 {
            return block_5045(state, tracer, fn_state);
        } else {
            return block_1126(state, tracer, fn_state);
        };
    }
    fn block_1126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1126_0: const #0u : u8
        let s_1126_0: bool = false;
        // D s_1126_1: write-var gs#118048 <= s_1126_0
        fn_state.gs_118048 = s_1126_0;
        // N s_1126_2: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_1127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1127_0: read-var gs#118048:u8
        let s_1127_0: bool = fn_state.gs_118048;
        // N s_1127_1: branch s_1127_0 b5044 b1128
        if s_1127_0 {
            return block_5044(state, tracer, fn_state);
        } else {
            return block_1128(state, tracer, fn_state);
        };
    }
    fn block_1128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1128_0: const #0u : u8
        let s_1128_0: bool = false;
        // D s_1128_1: write-var gs#118049 <= s_1128_0
        fn_state.gs_118049 = s_1128_0;
        // N s_1128_2: jump b1129
        return block_1129(state, tracer, fn_state);
    }
    fn block_1129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1129_0: read-var gs#118049:u8
        let s_1129_0: bool = fn_state.gs_118049;
        // N s_1129_1: branch s_1129_0 b5043 b1130
        if s_1129_0 {
            return block_5043(state, tracer, fn_state);
        } else {
            return block_1130(state, tracer, fn_state);
        };
    }
    fn block_1130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1130_0: const #0u : u8
        let s_1130_0: bool = false;
        // D s_1130_1: write-var gs#118050 <= s_1130_0
        fn_state.gs_118050 = s_1130_0;
        // N s_1130_2: jump b1131
        return block_1131(state, tracer, fn_state);
    }
    fn block_1131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1131_0: read-var gs#118050:u8
        let s_1131_0: bool = fn_state.gs_118050;
        // N s_1131_1: branch s_1131_0 b5042 b1132
        if s_1131_0 {
            return block_5042(state, tracer, fn_state);
        } else {
            return block_1132(state, tracer, fn_state);
        };
    }
    fn block_1132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1132_0: const #0u : u8
        let s_1132_0: bool = false;
        // D s_1132_1: write-var gs#118051 <= s_1132_0
        fn_state.gs_118051 = s_1132_0;
        // N s_1132_2: jump b1133
        return block_1133(state, tracer, fn_state);
    }
    fn block_1133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1133_0: read-var gs#118051:u8
        let s_1133_0: bool = fn_state.gs_118051;
        // N s_1133_1: branch s_1133_0 b5041 b1134
        if s_1133_0 {
            return block_5041(state, tracer, fn_state);
        } else {
            return block_1134(state, tracer, fn_state);
        };
    }
    fn block_1134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1134_0: read-var CRm:u8
        let s_1134_0: u8 = fn_state.CRm;
        // D s_1134_1: cast zx s_1134_0 -> bv
        let s_1134_1: Bits = Bits::new(s_1134_0 as u128, 4u16);
        // C s_1134_2: const #2u : u8
        let s_1134_2: u8 = 2;
        // C s_1134_3: cast zx s_1134_2 -> bv
        let s_1134_3: Bits = Bits::new(s_1134_2 as u128, 4u16);
        // D s_1134_4: cmp-eq s_1134_1 s_1134_3
        let s_1134_4: bool = ((s_1134_1) == (s_1134_3));
        // N s_1134_5: branch s_1134_4 b5040 b1135
        if s_1134_4 {
            return block_5040(state, tracer, fn_state);
        } else {
            return block_1135(state, tracer, fn_state);
        };
    }
    fn block_1135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1135_0: const #0u : u8
        let s_1135_0: bool = false;
        // D s_1135_1: write-var gs#118052 <= s_1135_0
        fn_state.gs_118052 = s_1135_0;
        // N s_1135_2: jump b1136
        return block_1136(state, tracer, fn_state);
    }
    fn block_1136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1136_0: read-var gs#118052:u8
        let s_1136_0: bool = fn_state.gs_118052;
        // N s_1136_1: branch s_1136_0 b5039 b1137
        if s_1136_0 {
            return block_5039(state, tracer, fn_state);
        } else {
            return block_1137(state, tracer, fn_state);
        };
    }
    fn block_1137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1137_0: const #0u : u8
        let s_1137_0: bool = false;
        // D s_1137_1: write-var gs#118053 <= s_1137_0
        fn_state.gs_118053 = s_1137_0;
        // N s_1137_2: jump b1138
        return block_1138(state, tracer, fn_state);
    }
    fn block_1138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1138_0: read-var gs#118053:u8
        let s_1138_0: bool = fn_state.gs_118053;
        // N s_1138_1: branch s_1138_0 b5038 b1139
        if s_1138_0 {
            return block_5038(state, tracer, fn_state);
        } else {
            return block_1139(state, tracer, fn_state);
        };
    }
    fn block_1139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1139_0: const #0u : u8
        let s_1139_0: bool = false;
        // D s_1139_1: write-var gs#118054 <= s_1139_0
        fn_state.gs_118054 = s_1139_0;
        // N s_1139_2: jump b1140
        return block_1140(state, tracer, fn_state);
    }
    fn block_1140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1140_0: read-var gs#118054:u8
        let s_1140_0: bool = fn_state.gs_118054;
        // N s_1140_1: branch s_1140_0 b5037 b1141
        if s_1140_0 {
            return block_5037(state, tracer, fn_state);
        } else {
            return block_1141(state, tracer, fn_state);
        };
    }
    fn block_1141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1141_0: const #0u : u8
        let s_1141_0: bool = false;
        // D s_1141_1: write-var gs#118055 <= s_1141_0
        fn_state.gs_118055 = s_1141_0;
        // N s_1141_2: jump b1142
        return block_1142(state, tracer, fn_state);
    }
    fn block_1142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1142_0: read-var gs#118055:u8
        let s_1142_0: bool = fn_state.gs_118055;
        // N s_1142_1: branch s_1142_0 b5036 b1143
        if s_1142_0 {
            return block_5036(state, tracer, fn_state);
        } else {
            return block_1143(state, tracer, fn_state);
        };
    }
    fn block_1143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1143_0: read-var CRm:u8
        let s_1143_0: u8 = fn_state.CRm;
        // D s_1143_1: cast zx s_1143_0 -> bv
        let s_1143_1: Bits = Bits::new(s_1143_0 as u128, 4u16);
        // C s_1143_2: const #14u : u8
        let s_1143_2: u8 = 14;
        // C s_1143_3: cast zx s_1143_2 -> bv
        let s_1143_3: Bits = Bits::new(s_1143_2 as u128, 4u16);
        // D s_1143_4: cmp-eq s_1143_1 s_1143_3
        let s_1143_4: bool = ((s_1143_1) == (s_1143_3));
        // N s_1143_5: branch s_1143_4 b5035 b1144
        if s_1143_4 {
            return block_5035(state, tracer, fn_state);
        } else {
            return block_1144(state, tracer, fn_state);
        };
    }
    fn block_1144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1144_0: const #0u : u8
        let s_1144_0: bool = false;
        // D s_1144_1: write-var gs#118056 <= s_1144_0
        fn_state.gs_118056 = s_1144_0;
        // N s_1144_2: jump b1145
        return block_1145(state, tracer, fn_state);
    }
    fn block_1145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1145_0: read-var gs#118056:u8
        let s_1145_0: bool = fn_state.gs_118056;
        // N s_1145_1: branch s_1145_0 b5034 b1146
        if s_1145_0 {
            return block_5034(state, tracer, fn_state);
        } else {
            return block_1146(state, tracer, fn_state);
        };
    }
    fn block_1146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1146_0: const #0u : u8
        let s_1146_0: bool = false;
        // D s_1146_1: write-var gs#118057 <= s_1146_0
        fn_state.gs_118057 = s_1146_0;
        // N s_1146_2: jump b1147
        return block_1147(state, tracer, fn_state);
    }
    fn block_1147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1147_0: read-var gs#118057:u8
        let s_1147_0: bool = fn_state.gs_118057;
        // N s_1147_1: branch s_1147_0 b5033 b1148
        if s_1147_0 {
            return block_5033(state, tracer, fn_state);
        } else {
            return block_1148(state, tracer, fn_state);
        };
    }
    fn block_1148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1148_0: const #0u : u8
        let s_1148_0: bool = false;
        // D s_1148_1: write-var gs#118058 <= s_1148_0
        fn_state.gs_118058 = s_1148_0;
        // N s_1148_2: jump b1149
        return block_1149(state, tracer, fn_state);
    }
    fn block_1149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1149_0: read-var gs#118058:u8
        let s_1149_0: bool = fn_state.gs_118058;
        // N s_1149_1: branch s_1149_0 b5032 b1150
        if s_1149_0 {
            return block_5032(state, tracer, fn_state);
        } else {
            return block_1150(state, tracer, fn_state);
        };
    }
    fn block_1150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1150_0: const #0u : u8
        let s_1150_0: bool = false;
        // D s_1150_1: write-var gs#118059 <= s_1150_0
        fn_state.gs_118059 = s_1150_0;
        // N s_1150_2: jump b1151
        return block_1151(state, tracer, fn_state);
    }
    fn block_1151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1151_0: read-var gs#118059:u8
        let s_1151_0: bool = fn_state.gs_118059;
        // N s_1151_1: branch s_1151_0 b5031 b1152
        if s_1151_0 {
            return block_5031(state, tracer, fn_state);
        } else {
            return block_1152(state, tracer, fn_state);
        };
    }
    fn block_1152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1152_0: read-var CRm:u8
        let s_1152_0: u8 = fn_state.CRm;
        // D s_1152_1: cast zx s_1152_0 -> bv
        let s_1152_1: Bits = Bits::new(s_1152_0 as u128, 4u16);
        // C s_1152_2: const #4u : u8
        let s_1152_2: u8 = 4;
        // C s_1152_3: cast zx s_1152_2 -> bv
        let s_1152_3: Bits = Bits::new(s_1152_2 as u128, 4u16);
        // D s_1152_4: cmp-eq s_1152_1 s_1152_3
        let s_1152_4: bool = ((s_1152_1) == (s_1152_3));
        // N s_1152_5: branch s_1152_4 b5030 b1153
        if s_1152_4 {
            return block_5030(state, tracer, fn_state);
        } else {
            return block_1153(state, tracer, fn_state);
        };
    }
    fn block_1153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1153_0: const #0u : u8
        let s_1153_0: bool = false;
        // D s_1153_1: write-var gs#118060 <= s_1153_0
        fn_state.gs_118060 = s_1153_0;
        // N s_1153_2: jump b1154
        return block_1154(state, tracer, fn_state);
    }
    fn block_1154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1154_0: read-var gs#118060:u8
        let s_1154_0: bool = fn_state.gs_118060;
        // N s_1154_1: branch s_1154_0 b5029 b1155
        if s_1154_0 {
            return block_5029(state, tracer, fn_state);
        } else {
            return block_1155(state, tracer, fn_state);
        };
    }
    fn block_1155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1155_0: const #0u : u8
        let s_1155_0: bool = false;
        // D s_1155_1: write-var gs#118061 <= s_1155_0
        fn_state.gs_118061 = s_1155_0;
        // N s_1155_2: jump b1156
        return block_1156(state, tracer, fn_state);
    }
    fn block_1156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1156_0: read-var gs#118061:u8
        let s_1156_0: bool = fn_state.gs_118061;
        // N s_1156_1: branch s_1156_0 b5028 b1157
        if s_1156_0 {
            return block_5028(state, tracer, fn_state);
        } else {
            return block_1157(state, tracer, fn_state);
        };
    }
    fn block_1157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1157_0: const #0u : u8
        let s_1157_0: bool = false;
        // D s_1157_1: write-var gs#118062 <= s_1157_0
        fn_state.gs_118062 = s_1157_0;
        // N s_1157_2: jump b1158
        return block_1158(state, tracer, fn_state);
    }
    fn block_1158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1158_0: read-var gs#118062:u8
        let s_1158_0: bool = fn_state.gs_118062;
        // N s_1158_1: branch s_1158_0 b5027 b1159
        if s_1158_0 {
            return block_5027(state, tracer, fn_state);
        } else {
            return block_1159(state, tracer, fn_state);
        };
    }
    fn block_1159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1159_0: const #0u : u8
        let s_1159_0: bool = false;
        // D s_1159_1: write-var gs#118063 <= s_1159_0
        fn_state.gs_118063 = s_1159_0;
        // N s_1159_2: jump b1160
        return block_1160(state, tracer, fn_state);
    }
    fn block_1160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1160_0: read-var gs#118063:u8
        let s_1160_0: bool = fn_state.gs_118063;
        // N s_1160_1: branch s_1160_0 b5026 b1161
        if s_1160_0 {
            return block_5026(state, tracer, fn_state);
        } else {
            return block_1161(state, tracer, fn_state);
        };
    }
    fn block_1161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1161_0: read-var CRm:u8
        let s_1161_0: u8 = fn_state.CRm;
        // D s_1161_1: cast zx s_1161_0 -> bv
        let s_1161_1: Bits = Bits::new(s_1161_0 as u128, 4u16);
        // C s_1161_2: const #1u : u8
        let s_1161_2: u8 = 1;
        // C s_1161_3: cast zx s_1161_2 -> bv
        let s_1161_3: Bits = Bits::new(s_1161_2 as u128, 4u16);
        // D s_1161_4: cmp-eq s_1161_1 s_1161_3
        let s_1161_4: bool = ((s_1161_1) == (s_1161_3));
        // N s_1161_5: branch s_1161_4 b5025 b1162
        if s_1161_4 {
            return block_5025(state, tracer, fn_state);
        } else {
            return block_1162(state, tracer, fn_state);
        };
    }
    fn block_1162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1162_0: const #0u : u8
        let s_1162_0: bool = false;
        // D s_1162_1: write-var gs#118064 <= s_1162_0
        fn_state.gs_118064 = s_1162_0;
        // N s_1162_2: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_1163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1163_0: read-var gs#118064:u8
        let s_1163_0: bool = fn_state.gs_118064;
        // N s_1163_1: branch s_1163_0 b5024 b1164
        if s_1163_0 {
            return block_5024(state, tracer, fn_state);
        } else {
            return block_1164(state, tracer, fn_state);
        };
    }
    fn block_1164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1164_0: const #0u : u8
        let s_1164_0: bool = false;
        // D s_1164_1: write-var gs#118065 <= s_1164_0
        fn_state.gs_118065 = s_1164_0;
        // N s_1164_2: jump b1165
        return block_1165(state, tracer, fn_state);
    }
    fn block_1165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1165_0: read-var gs#118065:u8
        let s_1165_0: bool = fn_state.gs_118065;
        // N s_1165_1: branch s_1165_0 b5023 b1166
        if s_1165_0 {
            return block_5023(state, tracer, fn_state);
        } else {
            return block_1166(state, tracer, fn_state);
        };
    }
    fn block_1166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1166_0: const #0u : u8
        let s_1166_0: bool = false;
        // D s_1166_1: write-var gs#118066 <= s_1166_0
        fn_state.gs_118066 = s_1166_0;
        // N s_1166_2: jump b1167
        return block_1167(state, tracer, fn_state);
    }
    fn block_1167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1167_0: read-var gs#118066:u8
        let s_1167_0: bool = fn_state.gs_118066;
        // N s_1167_1: branch s_1167_0 b5022 b1168
        if s_1167_0 {
            return block_5022(state, tracer, fn_state);
        } else {
            return block_1168(state, tracer, fn_state);
        };
    }
    fn block_1168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1168_0: const #0u : u8
        let s_1168_0: bool = false;
        // D s_1168_1: write-var gs#118067 <= s_1168_0
        fn_state.gs_118067 = s_1168_0;
        // N s_1168_2: jump b1169
        return block_1169(state, tracer, fn_state);
    }
    fn block_1169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1169_0: read-var gs#118067:u8
        let s_1169_0: bool = fn_state.gs_118067;
        // N s_1169_1: branch s_1169_0 b5021 b1170
        if s_1169_0 {
            return block_5021(state, tracer, fn_state);
        } else {
            return block_1170(state, tracer, fn_state);
        };
    }
    fn block_1170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1170_0: read-var CRm:u8
        let s_1170_0: u8 = fn_state.CRm;
        // D s_1170_1: cast zx s_1170_0 -> bv
        let s_1170_1: Bits = Bits::new(s_1170_0 as u128, 4u16);
        // C s_1170_2: const #2u : u8
        let s_1170_2: u8 = 2;
        // C s_1170_3: cast zx s_1170_2 -> bv
        let s_1170_3: Bits = Bits::new(s_1170_2 as u128, 4u16);
        // D s_1170_4: cmp-eq s_1170_1 s_1170_3
        let s_1170_4: bool = ((s_1170_1) == (s_1170_3));
        // N s_1170_5: branch s_1170_4 b5020 b1171
        if s_1170_4 {
            return block_5020(state, tracer, fn_state);
        } else {
            return block_1171(state, tracer, fn_state);
        };
    }
    fn block_1171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1171_0: const #0u : u8
        let s_1171_0: bool = false;
        // D s_1171_1: write-var gs#118068 <= s_1171_0
        fn_state.gs_118068 = s_1171_0;
        // N s_1171_2: jump b1172
        return block_1172(state, tracer, fn_state);
    }
    fn block_1172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1172_0: read-var gs#118068:u8
        let s_1172_0: bool = fn_state.gs_118068;
        // N s_1172_1: branch s_1172_0 b5019 b1173
        if s_1172_0 {
            return block_5019(state, tracer, fn_state);
        } else {
            return block_1173(state, tracer, fn_state);
        };
    }
    fn block_1173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1173_0: const #0u : u8
        let s_1173_0: bool = false;
        // D s_1173_1: write-var gs#118069 <= s_1173_0
        fn_state.gs_118069 = s_1173_0;
        // N s_1173_2: jump b1174
        return block_1174(state, tracer, fn_state);
    }
    fn block_1174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1174_0: read-var gs#118069:u8
        let s_1174_0: bool = fn_state.gs_118069;
        // N s_1174_1: branch s_1174_0 b5018 b1175
        if s_1174_0 {
            return block_5018(state, tracer, fn_state);
        } else {
            return block_1175(state, tracer, fn_state);
        };
    }
    fn block_1175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1175_0: const #0u : u8
        let s_1175_0: bool = false;
        // D s_1175_1: write-var gs#118070 <= s_1175_0
        fn_state.gs_118070 = s_1175_0;
        // N s_1175_2: jump b1176
        return block_1176(state, tracer, fn_state);
    }
    fn block_1176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1176_0: read-var gs#118070:u8
        let s_1176_0: bool = fn_state.gs_118070;
        // N s_1176_1: branch s_1176_0 b5017 b1177
        if s_1176_0 {
            return block_5017(state, tracer, fn_state);
        } else {
            return block_1177(state, tracer, fn_state);
        };
    }
    fn block_1177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1177_0: const #0u : u8
        let s_1177_0: bool = false;
        // D s_1177_1: write-var gs#118071 <= s_1177_0
        fn_state.gs_118071 = s_1177_0;
        // N s_1177_2: jump b1178
        return block_1178(state, tracer, fn_state);
    }
    fn block_1178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1178_0: read-var gs#118071:u8
        let s_1178_0: bool = fn_state.gs_118071;
        // N s_1178_1: branch s_1178_0 b5016 b1179
        if s_1178_0 {
            return block_5016(state, tracer, fn_state);
        } else {
            return block_1179(state, tracer, fn_state);
        };
    }
    fn block_1179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1179_0: read-var CRm:u8
        let s_1179_0: u8 = fn_state.CRm;
        // D s_1179_1: cast zx s_1179_0 -> bv
        let s_1179_1: Bits = Bits::new(s_1179_0 as u128, 4u16);
        // C s_1179_2: const #0u : u8
        let s_1179_2: u8 = 0;
        // C s_1179_3: cast zx s_1179_2 -> bv
        let s_1179_3: Bits = Bits::new(s_1179_2 as u128, 4u16);
        // D s_1179_4: cmp-eq s_1179_1 s_1179_3
        let s_1179_4: bool = ((s_1179_1) == (s_1179_3));
        // N s_1179_5: branch s_1179_4 b5015 b1180
        if s_1179_4 {
            return block_5015(state, tracer, fn_state);
        } else {
            return block_1180(state, tracer, fn_state);
        };
    }
    fn block_1180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1180_0: const #0u : u8
        let s_1180_0: bool = false;
        // D s_1180_1: write-var gs#118072 <= s_1180_0
        fn_state.gs_118072 = s_1180_0;
        // N s_1180_2: jump b1181
        return block_1181(state, tracer, fn_state);
    }
    fn block_1181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1181_0: read-var gs#118072:u8
        let s_1181_0: bool = fn_state.gs_118072;
        // N s_1181_1: branch s_1181_0 b5014 b1182
        if s_1181_0 {
            return block_5014(state, tracer, fn_state);
        } else {
            return block_1182(state, tracer, fn_state);
        };
    }
    fn block_1182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1182_0: const #0u : u8
        let s_1182_0: bool = false;
        // D s_1182_1: write-var gs#118073 <= s_1182_0
        fn_state.gs_118073 = s_1182_0;
        // N s_1182_2: jump b1183
        return block_1183(state, tracer, fn_state);
    }
    fn block_1183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1183_0: read-var gs#118073:u8
        let s_1183_0: bool = fn_state.gs_118073;
        // N s_1183_1: branch s_1183_0 b5013 b1184
        if s_1183_0 {
            return block_5013(state, tracer, fn_state);
        } else {
            return block_1184(state, tracer, fn_state);
        };
    }
    fn block_1184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1184_0: const #0u : u8
        let s_1184_0: bool = false;
        // D s_1184_1: write-var gs#118074 <= s_1184_0
        fn_state.gs_118074 = s_1184_0;
        // N s_1184_2: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_1185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1185_0: read-var gs#118074:u8
        let s_1185_0: bool = fn_state.gs_118074;
        // N s_1185_1: branch s_1185_0 b5012 b1186
        if s_1185_0 {
            return block_5012(state, tracer, fn_state);
        } else {
            return block_1186(state, tracer, fn_state);
        };
    }
    fn block_1186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1186_0: const #0u : u8
        let s_1186_0: bool = false;
        // D s_1186_1: write-var gs#118075 <= s_1186_0
        fn_state.gs_118075 = s_1186_0;
        // N s_1186_2: jump b1187
        return block_1187(state, tracer, fn_state);
    }
    fn block_1187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1187_0: read-var gs#118075:u8
        let s_1187_0: bool = fn_state.gs_118075;
        // N s_1187_1: branch s_1187_0 b5011 b1188
        if s_1187_0 {
            return block_5011(state, tracer, fn_state);
        } else {
            return block_1188(state, tracer, fn_state);
        };
    }
    fn block_1188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1188_0: read-var CRm:u8
        let s_1188_0: u8 = fn_state.CRm;
        // D s_1188_1: cast zx s_1188_0 -> bv
        let s_1188_1: Bits = Bits::new(s_1188_0 as u128, 4u16);
        // C s_1188_2: const #8u : u8
        let s_1188_2: u8 = 8;
        // C s_1188_3: cast zx s_1188_2 -> bv
        let s_1188_3: Bits = Bits::new(s_1188_2 as u128, 4u16);
        // D s_1188_4: cmp-eq s_1188_1 s_1188_3
        let s_1188_4: bool = ((s_1188_1) == (s_1188_3));
        // N s_1188_5: branch s_1188_4 b5010 b1189
        if s_1188_4 {
            return block_5010(state, tracer, fn_state);
        } else {
            return block_1189(state, tracer, fn_state);
        };
    }
    fn block_1189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1189_0: const #0u : u8
        let s_1189_0: bool = false;
        // D s_1189_1: write-var gs#118076 <= s_1189_0
        fn_state.gs_118076 = s_1189_0;
        // N s_1189_2: jump b1190
        return block_1190(state, tracer, fn_state);
    }
    fn block_1190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1190_0: read-var gs#118076:u8
        let s_1190_0: bool = fn_state.gs_118076;
        // N s_1190_1: branch s_1190_0 b5009 b1191
        if s_1190_0 {
            return block_5009(state, tracer, fn_state);
        } else {
            return block_1191(state, tracer, fn_state);
        };
    }
    fn block_1191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1191_0: const #0u : u8
        let s_1191_0: bool = false;
        // D s_1191_1: write-var gs#118077 <= s_1191_0
        fn_state.gs_118077 = s_1191_0;
        // N s_1191_2: jump b1192
        return block_1192(state, tracer, fn_state);
    }
    fn block_1192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1192_0: read-var gs#118077:u8
        let s_1192_0: bool = fn_state.gs_118077;
        // N s_1192_1: branch s_1192_0 b5008 b1193
        if s_1192_0 {
            return block_5008(state, tracer, fn_state);
        } else {
            return block_1193(state, tracer, fn_state);
        };
    }
    fn block_1193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1193_0: const #0u : u8
        let s_1193_0: bool = false;
        // D s_1193_1: write-var gs#118078 <= s_1193_0
        fn_state.gs_118078 = s_1193_0;
        // N s_1193_2: jump b1194
        return block_1194(state, tracer, fn_state);
    }
    fn block_1194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1194_0: read-var gs#118078:u8
        let s_1194_0: bool = fn_state.gs_118078;
        // N s_1194_1: branch s_1194_0 b5007 b1195
        if s_1194_0 {
            return block_5007(state, tracer, fn_state);
        } else {
            return block_1195(state, tracer, fn_state);
        };
    }
    fn block_1195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1195_0: const #0u : u8
        let s_1195_0: bool = false;
        // D s_1195_1: write-var gs#118079 <= s_1195_0
        fn_state.gs_118079 = s_1195_0;
        // N s_1195_2: jump b1196
        return block_1196(state, tracer, fn_state);
    }
    fn block_1196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1196_0: read-var gs#118079:u8
        let s_1196_0: bool = fn_state.gs_118079;
        // N s_1196_1: branch s_1196_0 b5006 b1197
        if s_1196_0 {
            return block_5006(state, tracer, fn_state);
        } else {
            return block_1197(state, tracer, fn_state);
        };
    }
    fn block_1197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1197_0: read-var CRm:u8
        let s_1197_0: u8 = fn_state.CRm;
        // D s_1197_1: cast zx s_1197_0 -> bv
        let s_1197_1: Bits = Bits::new(s_1197_0 as u128, 4u16);
        // C s_1197_2: const #9u : u8
        let s_1197_2: u8 = 9;
        // C s_1197_3: cast zx s_1197_2 -> bv
        let s_1197_3: Bits = Bits::new(s_1197_2 as u128, 4u16);
        // D s_1197_4: cmp-eq s_1197_1 s_1197_3
        let s_1197_4: bool = ((s_1197_1) == (s_1197_3));
        // N s_1197_5: branch s_1197_4 b5005 b1198
        if s_1197_4 {
            return block_5005(state, tracer, fn_state);
        } else {
            return block_1198(state, tracer, fn_state);
        };
    }
    fn block_1198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1198_0: const #0u : u8
        let s_1198_0: bool = false;
        // D s_1198_1: write-var gs#118080 <= s_1198_0
        fn_state.gs_118080 = s_1198_0;
        // N s_1198_2: jump b1199
        return block_1199(state, tracer, fn_state);
    }
    fn block_1199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1199_0: read-var gs#118080:u8
        let s_1199_0: bool = fn_state.gs_118080;
        // N s_1199_1: branch s_1199_0 b5004 b1200
        if s_1199_0 {
            return block_5004(state, tracer, fn_state);
        } else {
            return block_1200(state, tracer, fn_state);
        };
    }
    fn block_1200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1200_0: const #0u : u8
        let s_1200_0: bool = false;
        // D s_1200_1: write-var gs#118081 <= s_1200_0
        fn_state.gs_118081 = s_1200_0;
        // N s_1200_2: jump b1201
        return block_1201(state, tracer, fn_state);
    }
    fn block_1201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1201_0: read-var gs#118081:u8
        let s_1201_0: bool = fn_state.gs_118081;
        // N s_1201_1: branch s_1201_0 b5003 b1202
        if s_1201_0 {
            return block_5003(state, tracer, fn_state);
        } else {
            return block_1202(state, tracer, fn_state);
        };
    }
    fn block_1202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1202_0: const #0u : u8
        let s_1202_0: bool = false;
        // D s_1202_1: write-var gs#118082 <= s_1202_0
        fn_state.gs_118082 = s_1202_0;
        // N s_1202_2: jump b1203
        return block_1203(state, tracer, fn_state);
    }
    fn block_1203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1203_0: read-var gs#118082:u8
        let s_1203_0: bool = fn_state.gs_118082;
        // N s_1203_1: branch s_1203_0 b5002 b1204
        if s_1203_0 {
            return block_5002(state, tracer, fn_state);
        } else {
            return block_1204(state, tracer, fn_state);
        };
    }
    fn block_1204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1204_0: const #0u : u8
        let s_1204_0: bool = false;
        // D s_1204_1: write-var gs#118083 <= s_1204_0
        fn_state.gs_118083 = s_1204_0;
        // N s_1204_2: jump b1205
        return block_1205(state, tracer, fn_state);
    }
    fn block_1205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1205_0: read-var gs#118083:u8
        let s_1205_0: bool = fn_state.gs_118083;
        // N s_1205_1: branch s_1205_0 b5001 b1206
        if s_1205_0 {
            return block_5001(state, tracer, fn_state);
        } else {
            return block_1206(state, tracer, fn_state);
        };
    }
    fn block_1206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1206_0: read-var CRm:u8
        let s_1206_0: u8 = fn_state.CRm;
        // D s_1206_1: cast zx s_1206_0 -> bv
        let s_1206_1: Bits = Bits::new(s_1206_0 as u128, 4u16);
        // C s_1206_2: const #9u : u8
        let s_1206_2: u8 = 9;
        // C s_1206_3: cast zx s_1206_2 -> bv
        let s_1206_3: Bits = Bits::new(s_1206_2 as u128, 4u16);
        // D s_1206_4: cmp-eq s_1206_1 s_1206_3
        let s_1206_4: bool = ((s_1206_1) == (s_1206_3));
        // N s_1206_5: branch s_1206_4 b5000 b1207
        if s_1206_4 {
            return block_5000(state, tracer, fn_state);
        } else {
            return block_1207(state, tracer, fn_state);
        };
    }
    fn block_1207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1207_0: const #0u : u8
        let s_1207_0: bool = false;
        // D s_1207_1: write-var gs#118084 <= s_1207_0
        fn_state.gs_118084 = s_1207_0;
        // N s_1207_2: jump b1208
        return block_1208(state, tracer, fn_state);
    }
    fn block_1208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1208_0: read-var gs#118084:u8
        let s_1208_0: bool = fn_state.gs_118084;
        // N s_1208_1: branch s_1208_0 b4999 b1209
        if s_1208_0 {
            return block_4999(state, tracer, fn_state);
        } else {
            return block_1209(state, tracer, fn_state);
        };
    }
    fn block_1209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1209_0: const #0u : u8
        let s_1209_0: bool = false;
        // D s_1209_1: write-var gs#118085 <= s_1209_0
        fn_state.gs_118085 = s_1209_0;
        // N s_1209_2: jump b1210
        return block_1210(state, tracer, fn_state);
    }
    fn block_1210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1210_0: read-var gs#118085:u8
        let s_1210_0: bool = fn_state.gs_118085;
        // N s_1210_1: branch s_1210_0 b4998 b1211
        if s_1210_0 {
            return block_4998(state, tracer, fn_state);
        } else {
            return block_1211(state, tracer, fn_state);
        };
    }
    fn block_1211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1211_0: const #0u : u8
        let s_1211_0: bool = false;
        // D s_1211_1: write-var gs#118086 <= s_1211_0
        fn_state.gs_118086 = s_1211_0;
        // N s_1211_2: jump b1212
        return block_1212(state, tracer, fn_state);
    }
    fn block_1212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1212_0: read-var gs#118086:u8
        let s_1212_0: bool = fn_state.gs_118086;
        // N s_1212_1: branch s_1212_0 b4997 b1213
        if s_1212_0 {
            return block_4997(state, tracer, fn_state);
        } else {
            return block_1213(state, tracer, fn_state);
        };
    }
    fn block_1213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1213_0: const #0u : u8
        let s_1213_0: bool = false;
        // D s_1213_1: write-var gs#118087 <= s_1213_0
        fn_state.gs_118087 = s_1213_0;
        // N s_1213_2: jump b1214
        return block_1214(state, tracer, fn_state);
    }
    fn block_1214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1214_0: read-var gs#118087:u8
        let s_1214_0: bool = fn_state.gs_118087;
        // N s_1214_1: branch s_1214_0 b4996 b1215
        if s_1214_0 {
            return block_4996(state, tracer, fn_state);
        } else {
            return block_1215(state, tracer, fn_state);
        };
    }
    fn block_1215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1215_0: read-var CRm:u8
        let s_1215_0: u8 = fn_state.CRm;
        // D s_1215_1: cast zx s_1215_0 -> bv
        let s_1215_1: Bits = Bits::new(s_1215_0 as u128, 4u16);
        // C s_1215_2: const #9u : u8
        let s_1215_2: u8 = 9;
        // C s_1215_3: cast zx s_1215_2 -> bv
        let s_1215_3: Bits = Bits::new(s_1215_2 as u128, 4u16);
        // D s_1215_4: cmp-eq s_1215_1 s_1215_3
        let s_1215_4: bool = ((s_1215_1) == (s_1215_3));
        // N s_1215_5: branch s_1215_4 b4995 b1216
        if s_1215_4 {
            return block_4995(state, tracer, fn_state);
        } else {
            return block_1216(state, tracer, fn_state);
        };
    }
    fn block_1216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1216_0: const #0u : u8
        let s_1216_0: bool = false;
        // D s_1216_1: write-var gs#118088 <= s_1216_0
        fn_state.gs_118088 = s_1216_0;
        // N s_1216_2: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_1217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1217_0: read-var gs#118088:u8
        let s_1217_0: bool = fn_state.gs_118088;
        // N s_1217_1: branch s_1217_0 b4994 b1218
        if s_1217_0 {
            return block_4994(state, tracer, fn_state);
        } else {
            return block_1218(state, tracer, fn_state);
        };
    }
    fn block_1218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1218_0: const #0u : u8
        let s_1218_0: bool = false;
        // D s_1218_1: write-var gs#118089 <= s_1218_0
        fn_state.gs_118089 = s_1218_0;
        // N s_1218_2: jump b1219
        return block_1219(state, tracer, fn_state);
    }
    fn block_1219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1219_0: read-var gs#118089:u8
        let s_1219_0: bool = fn_state.gs_118089;
        // N s_1219_1: branch s_1219_0 b4993 b1220
        if s_1219_0 {
            return block_4993(state, tracer, fn_state);
        } else {
            return block_1220(state, tracer, fn_state);
        };
    }
    fn block_1220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1220_0: const #0u : u8
        let s_1220_0: bool = false;
        // D s_1220_1: write-var gs#118090 <= s_1220_0
        fn_state.gs_118090 = s_1220_0;
        // N s_1220_2: jump b1221
        return block_1221(state, tracer, fn_state);
    }
    fn block_1221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1221_0: read-var gs#118090:u8
        let s_1221_0: bool = fn_state.gs_118090;
        // N s_1221_1: branch s_1221_0 b4992 b1222
        if s_1221_0 {
            return block_4992(state, tracer, fn_state);
        } else {
            return block_1222(state, tracer, fn_state);
        };
    }
    fn block_1222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1222_0: const #0u : u8
        let s_1222_0: bool = false;
        // D s_1222_1: write-var gs#118091 <= s_1222_0
        fn_state.gs_118091 = s_1222_0;
        // N s_1222_2: jump b1223
        return block_1223(state, tracer, fn_state);
    }
    fn block_1223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1223_0: read-var gs#118091:u8
        let s_1223_0: bool = fn_state.gs_118091;
        // N s_1223_1: branch s_1223_0 b4991 b1224
        if s_1223_0 {
            return block_4991(state, tracer, fn_state);
        } else {
            return block_1224(state, tracer, fn_state);
        };
    }
    fn block_1224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1224_0: read-var CRm:u8
        let s_1224_0: u8 = fn_state.CRm;
        // D s_1224_1: cast zx s_1224_0 -> bv
        let s_1224_1: Bits = Bits::new(s_1224_0 as u128, 4u16);
        // C s_1224_2: const #9u : u8
        let s_1224_2: u8 = 9;
        // C s_1224_3: cast zx s_1224_2 -> bv
        let s_1224_3: Bits = Bits::new(s_1224_2 as u128, 4u16);
        // D s_1224_4: cmp-eq s_1224_1 s_1224_3
        let s_1224_4: bool = ((s_1224_1) == (s_1224_3));
        // N s_1224_5: branch s_1224_4 b4990 b1225
        if s_1224_4 {
            return block_4990(state, tracer, fn_state);
        } else {
            return block_1225(state, tracer, fn_state);
        };
    }
    fn block_1225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1225_0: const #0u : u8
        let s_1225_0: bool = false;
        // D s_1225_1: write-var gs#118092 <= s_1225_0
        fn_state.gs_118092 = s_1225_0;
        // N s_1225_2: jump b1226
        return block_1226(state, tracer, fn_state);
    }
    fn block_1226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1226_0: read-var gs#118092:u8
        let s_1226_0: bool = fn_state.gs_118092;
        // N s_1226_1: branch s_1226_0 b4989 b1227
        if s_1226_0 {
            return block_4989(state, tracer, fn_state);
        } else {
            return block_1227(state, tracer, fn_state);
        };
    }
    fn block_1227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1227_0: const #0u : u8
        let s_1227_0: bool = false;
        // D s_1227_1: write-var gs#118093 <= s_1227_0
        fn_state.gs_118093 = s_1227_0;
        // N s_1227_2: jump b1228
        return block_1228(state, tracer, fn_state);
    }
    fn block_1228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1228_0: read-var gs#118093:u8
        let s_1228_0: bool = fn_state.gs_118093;
        // N s_1228_1: branch s_1228_0 b4988 b1229
        if s_1228_0 {
            return block_4988(state, tracer, fn_state);
        } else {
            return block_1229(state, tracer, fn_state);
        };
    }
    fn block_1229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1229_0: const #0u : u8
        let s_1229_0: bool = false;
        // D s_1229_1: write-var gs#118094 <= s_1229_0
        fn_state.gs_118094 = s_1229_0;
        // N s_1229_2: jump b1230
        return block_1230(state, tracer, fn_state);
    }
    fn block_1230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1230_0: read-var gs#118094:u8
        let s_1230_0: bool = fn_state.gs_118094;
        // N s_1230_1: branch s_1230_0 b4987 b1231
        if s_1230_0 {
            return block_4987(state, tracer, fn_state);
        } else {
            return block_1231(state, tracer, fn_state);
        };
    }
    fn block_1231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1231_0: const #0u : u8
        let s_1231_0: bool = false;
        // D s_1231_1: write-var gs#118095 <= s_1231_0
        fn_state.gs_118095 = s_1231_0;
        // N s_1231_2: jump b1232
        return block_1232(state, tracer, fn_state);
    }
    fn block_1232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1232_0: read-var gs#118095:u8
        let s_1232_0: bool = fn_state.gs_118095;
        // N s_1232_1: branch s_1232_0 b4986 b1233
        if s_1232_0 {
            return block_4986(state, tracer, fn_state);
        } else {
            return block_1233(state, tracer, fn_state);
        };
    }
    fn block_1233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1233_0: read-var CRm:u8
        let s_1233_0: u8 = fn_state.CRm;
        // D s_1233_1: cast zx s_1233_0 -> bv
        let s_1233_1: Bits = Bits::new(s_1233_0 as u128, 4u16);
        // C s_1233_2: const #1u : u8
        let s_1233_2: u8 = 1;
        // C s_1233_3: cast zx s_1233_2 -> bv
        let s_1233_3: Bits = Bits::new(s_1233_2 as u128, 4u16);
        // D s_1233_4: cmp-eq s_1233_1 s_1233_3
        let s_1233_4: bool = ((s_1233_1) == (s_1233_3));
        // N s_1233_5: branch s_1233_4 b4985 b1234
        if s_1233_4 {
            return block_4985(state, tracer, fn_state);
        } else {
            return block_1234(state, tracer, fn_state);
        };
    }
    fn block_1234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1234_0: const #0u : u8
        let s_1234_0: bool = false;
        // D s_1234_1: write-var gs#118096 <= s_1234_0
        fn_state.gs_118096 = s_1234_0;
        // N s_1234_2: jump b1235
        return block_1235(state, tracer, fn_state);
    }
    fn block_1235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1235_0: read-var gs#118096:u8
        let s_1235_0: bool = fn_state.gs_118096;
        // N s_1235_1: branch s_1235_0 b4984 b1236
        if s_1235_0 {
            return block_4984(state, tracer, fn_state);
        } else {
            return block_1236(state, tracer, fn_state);
        };
    }
    fn block_1236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1236_0: const #0u : u8
        let s_1236_0: bool = false;
        // D s_1236_1: write-var gs#118097 <= s_1236_0
        fn_state.gs_118097 = s_1236_0;
        // N s_1236_2: jump b1237
        return block_1237(state, tracer, fn_state);
    }
    fn block_1237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1237_0: read-var gs#118097:u8
        let s_1237_0: bool = fn_state.gs_118097;
        // N s_1237_1: branch s_1237_0 b4983 b1238
        if s_1237_0 {
            return block_4983(state, tracer, fn_state);
        } else {
            return block_1238(state, tracer, fn_state);
        };
    }
    fn block_1238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1238_0: const #0u : u8
        let s_1238_0: bool = false;
        // D s_1238_1: write-var gs#118098 <= s_1238_0
        fn_state.gs_118098 = s_1238_0;
        // N s_1238_2: jump b1239
        return block_1239(state, tracer, fn_state);
    }
    fn block_1239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1239_0: read-var gs#118098:u8
        let s_1239_0: bool = fn_state.gs_118098;
        // N s_1239_1: branch s_1239_0 b4982 b1240
        if s_1239_0 {
            return block_4982(state, tracer, fn_state);
        } else {
            return block_1240(state, tracer, fn_state);
        };
    }
    fn block_1240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1240_0: const #0u : u8
        let s_1240_0: bool = false;
        // D s_1240_1: write-var gs#118099 <= s_1240_0
        fn_state.gs_118099 = s_1240_0;
        // N s_1240_2: jump b1241
        return block_1241(state, tracer, fn_state);
    }
    fn block_1241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1241_0: read-var gs#118099:u8
        let s_1241_0: bool = fn_state.gs_118099;
        // N s_1241_1: branch s_1241_0 b4981 b1242
        if s_1241_0 {
            return block_4981(state, tracer, fn_state);
        } else {
            return block_1242(state, tracer, fn_state);
        };
    }
    fn block_1242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1242_0: read-var CRm:u8
        let s_1242_0: u8 = fn_state.CRm;
        // D s_1242_1: cast zx s_1242_0 -> bv
        let s_1242_1: Bits = Bits::new(s_1242_0 as u128, 4u16);
        // C s_1242_2: const #1u : u8
        let s_1242_2: u8 = 1;
        // C s_1242_3: cast zx s_1242_2 -> bv
        let s_1242_3: Bits = Bits::new(s_1242_2 as u128, 4u16);
        // D s_1242_4: cmp-eq s_1242_1 s_1242_3
        let s_1242_4: bool = ((s_1242_1) == (s_1242_3));
        // N s_1242_5: branch s_1242_4 b4980 b1243
        if s_1242_4 {
            return block_4980(state, tracer, fn_state);
        } else {
            return block_1243(state, tracer, fn_state);
        };
    }
    fn block_1243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1243_0: const #0u : u8
        let s_1243_0: bool = false;
        // D s_1243_1: write-var gs#118100 <= s_1243_0
        fn_state.gs_118100 = s_1243_0;
        // N s_1243_2: jump b1244
        return block_1244(state, tracer, fn_state);
    }
    fn block_1244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1244_0: read-var gs#118100:u8
        let s_1244_0: bool = fn_state.gs_118100;
        // N s_1244_1: branch s_1244_0 b4979 b1245
        if s_1244_0 {
            return block_4979(state, tracer, fn_state);
        } else {
            return block_1245(state, tracer, fn_state);
        };
    }
    fn block_1245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1245_0: const #0u : u8
        let s_1245_0: bool = false;
        // D s_1245_1: write-var gs#118101 <= s_1245_0
        fn_state.gs_118101 = s_1245_0;
        // N s_1245_2: jump b1246
        return block_1246(state, tracer, fn_state);
    }
    fn block_1246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1246_0: read-var gs#118101:u8
        let s_1246_0: bool = fn_state.gs_118101;
        // N s_1246_1: branch s_1246_0 b4978 b1247
        if s_1246_0 {
            return block_4978(state, tracer, fn_state);
        } else {
            return block_1247(state, tracer, fn_state);
        };
    }
    fn block_1247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1247_0: const #0u : u8
        let s_1247_0: bool = false;
        // D s_1247_1: write-var gs#118102 <= s_1247_0
        fn_state.gs_118102 = s_1247_0;
        // N s_1247_2: jump b1248
        return block_1248(state, tracer, fn_state);
    }
    fn block_1248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1248_0: read-var gs#118102:u8
        let s_1248_0: bool = fn_state.gs_118102;
        // N s_1248_1: branch s_1248_0 b4977 b1249
        if s_1248_0 {
            return block_4977(state, tracer, fn_state);
        } else {
            return block_1249(state, tracer, fn_state);
        };
    }
    fn block_1249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1249_0: const #0u : u8
        let s_1249_0: bool = false;
        // D s_1249_1: write-var gs#118103 <= s_1249_0
        fn_state.gs_118103 = s_1249_0;
        // N s_1249_2: jump b1250
        return block_1250(state, tracer, fn_state);
    }
    fn block_1250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1250_0: read-var gs#118103:u8
        let s_1250_0: bool = fn_state.gs_118103;
        // N s_1250_1: branch s_1250_0 b4976 b1251
        if s_1250_0 {
            return block_4976(state, tracer, fn_state);
        } else {
            return block_1251(state, tracer, fn_state);
        };
    }
    fn block_1251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1251_0: read-var CRm:u8
        let s_1251_0: u8 = fn_state.CRm;
        // D s_1251_1: cast zx s_1251_0 -> bv
        let s_1251_1: Bits = Bits::new(s_1251_0 as u128, 4u16);
        // C s_1251_2: const #7u : u8
        let s_1251_2: u8 = 7;
        // C s_1251_3: cast zx s_1251_2 -> bv
        let s_1251_3: Bits = Bits::new(s_1251_2 as u128, 4u16);
        // D s_1251_4: cmp-eq s_1251_1 s_1251_3
        let s_1251_4: bool = ((s_1251_1) == (s_1251_3));
        // N s_1251_5: branch s_1251_4 b4975 b1252
        if s_1251_4 {
            return block_4975(state, tracer, fn_state);
        } else {
            return block_1252(state, tracer, fn_state);
        };
    }
    fn block_1252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1252_0: const #0u : u8
        let s_1252_0: bool = false;
        // D s_1252_1: write-var gs#118104 <= s_1252_0
        fn_state.gs_118104 = s_1252_0;
        // N s_1252_2: jump b1253
        return block_1253(state, tracer, fn_state);
    }
    fn block_1253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1253_0: read-var gs#118104:u8
        let s_1253_0: bool = fn_state.gs_118104;
        // N s_1253_1: branch s_1253_0 b4974 b1254
        if s_1253_0 {
            return block_4974(state, tracer, fn_state);
        } else {
            return block_1254(state, tracer, fn_state);
        };
    }
    fn block_1254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1254_0: const #0u : u8
        let s_1254_0: bool = false;
        // D s_1254_1: write-var gs#118105 <= s_1254_0
        fn_state.gs_118105 = s_1254_0;
        // N s_1254_2: jump b1255
        return block_1255(state, tracer, fn_state);
    }
    fn block_1255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1255_0: read-var gs#118105:u8
        let s_1255_0: bool = fn_state.gs_118105;
        // N s_1255_1: branch s_1255_0 b4973 b1256
        if s_1255_0 {
            return block_4973(state, tracer, fn_state);
        } else {
            return block_1256(state, tracer, fn_state);
        };
    }
    fn block_1256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1256_0: const #0u : u8
        let s_1256_0: bool = false;
        // D s_1256_1: write-var gs#118106 <= s_1256_0
        fn_state.gs_118106 = s_1256_0;
        // N s_1256_2: jump b1257
        return block_1257(state, tracer, fn_state);
    }
    fn block_1257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1257_0: read-var gs#118106:u8
        let s_1257_0: bool = fn_state.gs_118106;
        // N s_1257_1: branch s_1257_0 b4972 b1258
        if s_1257_0 {
            return block_4972(state, tracer, fn_state);
        } else {
            return block_1258(state, tracer, fn_state);
        };
    }
    fn block_1258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1258_0: const #0u : u8
        let s_1258_0: bool = false;
        // D s_1258_1: write-var gs#118107 <= s_1258_0
        fn_state.gs_118107 = s_1258_0;
        // N s_1258_2: jump b1259
        return block_1259(state, tracer, fn_state);
    }
    fn block_1259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1259_0: read-var gs#118107:u8
        let s_1259_0: bool = fn_state.gs_118107;
        // N s_1259_1: branch s_1259_0 b4971 b1260
        if s_1259_0 {
            return block_4971(state, tracer, fn_state);
        } else {
            return block_1260(state, tracer, fn_state);
        };
    }
    fn block_1260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1260_0: read-var CRm:u8
        let s_1260_0: u8 = fn_state.CRm;
        // D s_1260_1: cast zx s_1260_0 -> bv
        let s_1260_1: Bits = Bits::new(s_1260_0 as u128, 4u16);
        // C s_1260_2: const #0u : u8
        let s_1260_2: u8 = 0;
        // C s_1260_3: cast zx s_1260_2 -> bv
        let s_1260_3: Bits = Bits::new(s_1260_2 as u128, 4u16);
        // D s_1260_4: cmp-eq s_1260_1 s_1260_3
        let s_1260_4: bool = ((s_1260_1) == (s_1260_3));
        // N s_1260_5: branch s_1260_4 b4970 b1261
        if s_1260_4 {
            return block_4970(state, tracer, fn_state);
        } else {
            return block_1261(state, tracer, fn_state);
        };
    }
    fn block_1261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1261_0: const #0u : u8
        let s_1261_0: bool = false;
        // D s_1261_1: write-var gs#118108 <= s_1261_0
        fn_state.gs_118108 = s_1261_0;
        // N s_1261_2: jump b1262
        return block_1262(state, tracer, fn_state);
    }
    fn block_1262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1262_0: read-var gs#118108:u8
        let s_1262_0: bool = fn_state.gs_118108;
        // N s_1262_1: branch s_1262_0 b4969 b1263
        if s_1262_0 {
            return block_4969(state, tracer, fn_state);
        } else {
            return block_1263(state, tracer, fn_state);
        };
    }
    fn block_1263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1263_0: const #0u : u8
        let s_1263_0: bool = false;
        // D s_1263_1: write-var gs#118109 <= s_1263_0
        fn_state.gs_118109 = s_1263_0;
        // N s_1263_2: jump b1264
        return block_1264(state, tracer, fn_state);
    }
    fn block_1264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1264_0: read-var gs#118109:u8
        let s_1264_0: bool = fn_state.gs_118109;
        // N s_1264_1: branch s_1264_0 b4968 b1265
        if s_1264_0 {
            return block_4968(state, tracer, fn_state);
        } else {
            return block_1265(state, tracer, fn_state);
        };
    }
    fn block_1265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1265_0: const #0u : u8
        let s_1265_0: bool = false;
        // D s_1265_1: write-var gs#118110 <= s_1265_0
        fn_state.gs_118110 = s_1265_0;
        // N s_1265_2: jump b1266
        return block_1266(state, tracer, fn_state);
    }
    fn block_1266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1266_0: read-var gs#118110:u8
        let s_1266_0: bool = fn_state.gs_118110;
        // N s_1266_1: branch s_1266_0 b4967 b1267
        if s_1266_0 {
            return block_4967(state, tracer, fn_state);
        } else {
            return block_1267(state, tracer, fn_state);
        };
    }
    fn block_1267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1267_0: const #0u : u8
        let s_1267_0: bool = false;
        // D s_1267_1: write-var gs#118111 <= s_1267_0
        fn_state.gs_118111 = s_1267_0;
        // N s_1267_2: jump b1268
        return block_1268(state, tracer, fn_state);
    }
    fn block_1268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1268_0: read-var gs#118111:u8
        let s_1268_0: bool = fn_state.gs_118111;
        // N s_1268_1: branch s_1268_0 b4966 b1269
        if s_1268_0 {
            return block_4966(state, tracer, fn_state);
        } else {
            return block_1269(state, tracer, fn_state);
        };
    }
    fn block_1269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1269_0: read-var CRm:u8
        let s_1269_0: u8 = fn_state.CRm;
        // D s_1269_1: cast zx s_1269_0 -> bv
        let s_1269_1: Bits = Bits::new(s_1269_0 as u128, 4u16);
        // C s_1269_2: const #1u : u8
        let s_1269_2: u8 = 1;
        // C s_1269_3: cast zx s_1269_2 -> bv
        let s_1269_3: Bits = Bits::new(s_1269_2 as u128, 4u16);
        // D s_1269_4: cmp-eq s_1269_1 s_1269_3
        let s_1269_4: bool = ((s_1269_1) == (s_1269_3));
        // N s_1269_5: branch s_1269_4 b4965 b1270
        if s_1269_4 {
            return block_4965(state, tracer, fn_state);
        } else {
            return block_1270(state, tracer, fn_state);
        };
    }
    fn block_1270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1270_0: const #0u : u8
        let s_1270_0: bool = false;
        // D s_1270_1: write-var gs#118112 <= s_1270_0
        fn_state.gs_118112 = s_1270_0;
        // N s_1270_2: jump b1271
        return block_1271(state, tracer, fn_state);
    }
    fn block_1271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1271_0: read-var gs#118112:u8
        let s_1271_0: bool = fn_state.gs_118112;
        // N s_1271_1: branch s_1271_0 b4964 b1272
        if s_1271_0 {
            return block_4964(state, tracer, fn_state);
        } else {
            return block_1272(state, tracer, fn_state);
        };
    }
    fn block_1272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1272_0: const #0u : u8
        let s_1272_0: bool = false;
        // D s_1272_1: write-var gs#118113 <= s_1272_0
        fn_state.gs_118113 = s_1272_0;
        // N s_1272_2: jump b1273
        return block_1273(state, tracer, fn_state);
    }
    fn block_1273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1273_0: read-var gs#118113:u8
        let s_1273_0: bool = fn_state.gs_118113;
        // N s_1273_1: branch s_1273_0 b4963 b1274
        if s_1273_0 {
            return block_4963(state, tracer, fn_state);
        } else {
            return block_1274(state, tracer, fn_state);
        };
    }
    fn block_1274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1274_0: const #0u : u8
        let s_1274_0: bool = false;
        // D s_1274_1: write-var gs#118114 <= s_1274_0
        fn_state.gs_118114 = s_1274_0;
        // N s_1274_2: jump b1275
        return block_1275(state, tracer, fn_state);
    }
    fn block_1275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1275_0: read-var gs#118114:u8
        let s_1275_0: bool = fn_state.gs_118114;
        // N s_1275_1: branch s_1275_0 b4962 b1276
        if s_1275_0 {
            return block_4962(state, tracer, fn_state);
        } else {
            return block_1276(state, tracer, fn_state);
        };
    }
    fn block_1276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1276_0: const #0u : u8
        let s_1276_0: bool = false;
        // D s_1276_1: write-var gs#118115 <= s_1276_0
        fn_state.gs_118115 = s_1276_0;
        // N s_1276_2: jump b1277
        return block_1277(state, tracer, fn_state);
    }
    fn block_1277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1277_0: read-var gs#118115:u8
        let s_1277_0: bool = fn_state.gs_118115;
        // N s_1277_1: branch s_1277_0 b4961 b1278
        if s_1277_0 {
            return block_4961(state, tracer, fn_state);
        } else {
            return block_1278(state, tracer, fn_state);
        };
    }
    fn block_1278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1278_0: read-var CRm:u8
        let s_1278_0: u8 = fn_state.CRm;
        // D s_1278_1: cast zx s_1278_0 -> bv
        let s_1278_1: Bits = Bits::new(s_1278_0 as u128, 4u16);
        // C s_1278_2: const #12u : u8
        let s_1278_2: u8 = 12;
        // C s_1278_3: cast zx s_1278_2 -> bv
        let s_1278_3: Bits = Bits::new(s_1278_2 as u128, 4u16);
        // D s_1278_4: cmp-eq s_1278_1 s_1278_3
        let s_1278_4: bool = ((s_1278_1) == (s_1278_3));
        // N s_1278_5: branch s_1278_4 b4960 b1279
        if s_1278_4 {
            return block_4960(state, tracer, fn_state);
        } else {
            return block_1279(state, tracer, fn_state);
        };
    }
    fn block_1279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1279_0: const #0u : u8
        let s_1279_0: bool = false;
        // D s_1279_1: write-var gs#118116 <= s_1279_0
        fn_state.gs_118116 = s_1279_0;
        // N s_1279_2: jump b1280
        return block_1280(state, tracer, fn_state);
    }
    fn block_1280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1280_0: read-var gs#118116:u8
        let s_1280_0: bool = fn_state.gs_118116;
        // N s_1280_1: branch s_1280_0 b4959 b1281
        if s_1280_0 {
            return block_4959(state, tracer, fn_state);
        } else {
            return block_1281(state, tracer, fn_state);
        };
    }
    fn block_1281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1281_0: const #0u : u8
        let s_1281_0: bool = false;
        // D s_1281_1: write-var gs#118117 <= s_1281_0
        fn_state.gs_118117 = s_1281_0;
        // N s_1281_2: jump b1282
        return block_1282(state, tracer, fn_state);
    }
    fn block_1282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1282_0: read-var gs#118117:u8
        let s_1282_0: bool = fn_state.gs_118117;
        // N s_1282_1: branch s_1282_0 b4958 b1283
        if s_1282_0 {
            return block_4958(state, tracer, fn_state);
        } else {
            return block_1283(state, tracer, fn_state);
        };
    }
    fn block_1283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1283_0: const #0u : u8
        let s_1283_0: bool = false;
        // D s_1283_1: write-var gs#118118 <= s_1283_0
        fn_state.gs_118118 = s_1283_0;
        // N s_1283_2: jump b1284
        return block_1284(state, tracer, fn_state);
    }
    fn block_1284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1284_0: read-var gs#118118:u8
        let s_1284_0: bool = fn_state.gs_118118;
        // N s_1284_1: branch s_1284_0 b4957 b1285
        if s_1284_0 {
            return block_4957(state, tracer, fn_state);
        } else {
            return block_1285(state, tracer, fn_state);
        };
    }
    fn block_1285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1285_0: const #0u : u8
        let s_1285_0: bool = false;
        // D s_1285_1: write-var gs#118119 <= s_1285_0
        fn_state.gs_118119 = s_1285_0;
        // N s_1285_2: jump b1286
        return block_1286(state, tracer, fn_state);
    }
    fn block_1286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1286_0: read-var gs#118119:u8
        let s_1286_0: bool = fn_state.gs_118119;
        // N s_1286_1: branch s_1286_0 b4956 b1287
        if s_1286_0 {
            return block_4956(state, tracer, fn_state);
        } else {
            return block_1287(state, tracer, fn_state);
        };
    }
    fn block_1287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1287_0: read-var CRm:u8
        let s_1287_0: u8 = fn_state.CRm;
        // D s_1287_1: cast zx s_1287_0 -> bv
        let s_1287_1: Bits = Bits::new(s_1287_0 as u128, 4u16);
        // C s_1287_2: const #14u : u8
        let s_1287_2: u8 = 14;
        // C s_1287_3: cast zx s_1287_2 -> bv
        let s_1287_3: Bits = Bits::new(s_1287_2 as u128, 4u16);
        // D s_1287_4: cmp-eq s_1287_1 s_1287_3
        let s_1287_4: bool = ((s_1287_1) == (s_1287_3));
        // N s_1287_5: branch s_1287_4 b4955 b1288
        if s_1287_4 {
            return block_4955(state, tracer, fn_state);
        } else {
            return block_1288(state, tracer, fn_state);
        };
    }
    fn block_1288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1288_0: const #0u : u8
        let s_1288_0: bool = false;
        // D s_1288_1: write-var gs#118120 <= s_1288_0
        fn_state.gs_118120 = s_1288_0;
        // N s_1288_2: jump b1289
        return block_1289(state, tracer, fn_state);
    }
    fn block_1289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1289_0: read-var gs#118120:u8
        let s_1289_0: bool = fn_state.gs_118120;
        // N s_1289_1: branch s_1289_0 b4954 b1290
        if s_1289_0 {
            return block_4954(state, tracer, fn_state);
        } else {
            return block_1290(state, tracer, fn_state);
        };
    }
    fn block_1290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1290_0: const #0u : u8
        let s_1290_0: bool = false;
        // D s_1290_1: write-var gs#118121 <= s_1290_0
        fn_state.gs_118121 = s_1290_0;
        // N s_1290_2: jump b1291
        return block_1291(state, tracer, fn_state);
    }
    fn block_1291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1291_0: read-var gs#118121:u8
        let s_1291_0: bool = fn_state.gs_118121;
        // N s_1291_1: branch s_1291_0 b4953 b1292
        if s_1291_0 {
            return block_4953(state, tracer, fn_state);
        } else {
            return block_1292(state, tracer, fn_state);
        };
    }
    fn block_1292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1292_0: const #0u : u8
        let s_1292_0: bool = false;
        // D s_1292_1: write-var gs#118122 <= s_1292_0
        fn_state.gs_118122 = s_1292_0;
        // N s_1292_2: jump b1293
        return block_1293(state, tracer, fn_state);
    }
    fn block_1293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1293_0: read-var gs#118122:u8
        let s_1293_0: bool = fn_state.gs_118122;
        // N s_1293_1: branch s_1293_0 b4952 b1294
        if s_1293_0 {
            return block_4952(state, tracer, fn_state);
        } else {
            return block_1294(state, tracer, fn_state);
        };
    }
    fn block_1294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1294_0: const #0u : u8
        let s_1294_0: bool = false;
        // D s_1294_1: write-var gs#118123 <= s_1294_0
        fn_state.gs_118123 = s_1294_0;
        // N s_1294_2: jump b1295
        return block_1295(state, tracer, fn_state);
    }
    fn block_1295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1295_0: read-var gs#118123:u8
        let s_1295_0: bool = fn_state.gs_118123;
        // N s_1295_1: branch s_1295_0 b4951 b1296
        if s_1295_0 {
            return block_4951(state, tracer, fn_state);
        } else {
            return block_1296(state, tracer, fn_state);
        };
    }
    fn block_1296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1296_0: read-var CRm:u8
        let s_1296_0: u8 = fn_state.CRm;
        // D s_1296_1: cast zx s_1296_0 -> bv
        let s_1296_1: Bits = Bits::new(s_1296_0 as u128, 4u16);
        // C s_1296_2: const #0u : u8
        let s_1296_2: u8 = 0;
        // C s_1296_3: cast zx s_1296_2 -> bv
        let s_1296_3: Bits = Bits::new(s_1296_2 as u128, 4u16);
        // D s_1296_4: cmp-eq s_1296_1 s_1296_3
        let s_1296_4: bool = ((s_1296_1) == (s_1296_3));
        // N s_1296_5: branch s_1296_4 b4950 b1297
        if s_1296_4 {
            return block_4950(state, tracer, fn_state);
        } else {
            return block_1297(state, tracer, fn_state);
        };
    }
    fn block_1297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1297_0: const #0u : u8
        let s_1297_0: bool = false;
        // D s_1297_1: write-var gs#118124 <= s_1297_0
        fn_state.gs_118124 = s_1297_0;
        // N s_1297_2: jump b1298
        return block_1298(state, tracer, fn_state);
    }
    fn block_1298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1298_0: read-var gs#118124:u8
        let s_1298_0: bool = fn_state.gs_118124;
        // N s_1298_1: branch s_1298_0 b4949 b1299
        if s_1298_0 {
            return block_4949(state, tracer, fn_state);
        } else {
            return block_1299(state, tracer, fn_state);
        };
    }
    fn block_1299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1299_0: const #0u : u8
        let s_1299_0: bool = false;
        // D s_1299_1: write-var gs#118125 <= s_1299_0
        fn_state.gs_118125 = s_1299_0;
        // N s_1299_2: jump b1300
        return block_1300(state, tracer, fn_state);
    }
    fn block_1300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1300_0: read-var gs#118125:u8
        let s_1300_0: bool = fn_state.gs_118125;
        // N s_1300_1: branch s_1300_0 b4948 b1301
        if s_1300_0 {
            return block_4948(state, tracer, fn_state);
        } else {
            return block_1301(state, tracer, fn_state);
        };
    }
    fn block_1301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1301_0: const #0u : u8
        let s_1301_0: bool = false;
        // D s_1301_1: write-var gs#118126 <= s_1301_0
        fn_state.gs_118126 = s_1301_0;
        // N s_1301_2: jump b1302
        return block_1302(state, tracer, fn_state);
    }
    fn block_1302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1302_0: read-var gs#118126:u8
        let s_1302_0: bool = fn_state.gs_118126;
        // N s_1302_1: branch s_1302_0 b4947 b1303
        if s_1302_0 {
            return block_4947(state, tracer, fn_state);
        } else {
            return block_1303(state, tracer, fn_state);
        };
    }
    fn block_1303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1303_0: const #0u : u8
        let s_1303_0: bool = false;
        // D s_1303_1: write-var gs#118127 <= s_1303_0
        fn_state.gs_118127 = s_1303_0;
        // N s_1303_2: jump b1304
        return block_1304(state, tracer, fn_state);
    }
    fn block_1304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1304_0: read-var gs#118127:u8
        let s_1304_0: bool = fn_state.gs_118127;
        // N s_1304_1: branch s_1304_0 b4946 b1305
        if s_1304_0 {
            return block_4946(state, tracer, fn_state);
        } else {
            return block_1305(state, tracer, fn_state);
        };
    }
    fn block_1305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1305_0: read-var CRm:u8
        let s_1305_0: u8 = fn_state.CRm;
        // D s_1305_1: cast zx s_1305_0 -> bv
        let s_1305_1: Bits = Bits::new(s_1305_0 as u128, 4u16);
        // C s_1305_2: const #0u : u8
        let s_1305_2: u8 = 0;
        // C s_1305_3: cast zx s_1305_2 -> bv
        let s_1305_3: Bits = Bits::new(s_1305_2 as u128, 4u16);
        // D s_1305_4: cmp-eq s_1305_1 s_1305_3
        let s_1305_4: bool = ((s_1305_1) == (s_1305_3));
        // N s_1305_5: branch s_1305_4 b4945 b1306
        if s_1305_4 {
            return block_4945(state, tracer, fn_state);
        } else {
            return block_1306(state, tracer, fn_state);
        };
    }
    fn block_1306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1306_0: const #0u : u8
        let s_1306_0: bool = false;
        // D s_1306_1: write-var gs#118128 <= s_1306_0
        fn_state.gs_118128 = s_1306_0;
        // N s_1306_2: jump b1307
        return block_1307(state, tracer, fn_state);
    }
    fn block_1307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1307_0: read-var gs#118128:u8
        let s_1307_0: bool = fn_state.gs_118128;
        // N s_1307_1: branch s_1307_0 b4944 b1308
        if s_1307_0 {
            return block_4944(state, tracer, fn_state);
        } else {
            return block_1308(state, tracer, fn_state);
        };
    }
    fn block_1308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1308_0: const #0u : u8
        let s_1308_0: bool = false;
        // D s_1308_1: write-var gs#118129 <= s_1308_0
        fn_state.gs_118129 = s_1308_0;
        // N s_1308_2: jump b1309
        return block_1309(state, tracer, fn_state);
    }
    fn block_1309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1309_0: read-var gs#118129:u8
        let s_1309_0: bool = fn_state.gs_118129;
        // N s_1309_1: branch s_1309_0 b4943 b1310
        if s_1309_0 {
            return block_4943(state, tracer, fn_state);
        } else {
            return block_1310(state, tracer, fn_state);
        };
    }
    fn block_1310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1310_0: const #0u : u8
        let s_1310_0: bool = false;
        // D s_1310_1: write-var gs#118130 <= s_1310_0
        fn_state.gs_118130 = s_1310_0;
        // N s_1310_2: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_1311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1311_0: read-var gs#118130:u8
        let s_1311_0: bool = fn_state.gs_118130;
        // N s_1311_1: branch s_1311_0 b4942 b1312
        if s_1311_0 {
            return block_4942(state, tracer, fn_state);
        } else {
            return block_1312(state, tracer, fn_state);
        };
    }
    fn block_1312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1312_0: const #0u : u8
        let s_1312_0: bool = false;
        // D s_1312_1: write-var gs#118131 <= s_1312_0
        fn_state.gs_118131 = s_1312_0;
        // N s_1312_2: jump b1313
        return block_1313(state, tracer, fn_state);
    }
    fn block_1313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1313_0: read-var gs#118131:u8
        let s_1313_0: bool = fn_state.gs_118131;
        // N s_1313_1: branch s_1313_0 b4941 b1314
        if s_1313_0 {
            return block_4941(state, tracer, fn_state);
        } else {
            return block_1314(state, tracer, fn_state);
        };
    }
    fn block_1314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1314_0: read-var CRm:u8
        let s_1314_0: u8 = fn_state.CRm;
        // D s_1314_1: cast zx s_1314_0 -> bv
        let s_1314_1: Bits = Bits::new(s_1314_0 as u128, 4u16);
        // C s_1314_2: const #0u : u8
        let s_1314_2: u8 = 0;
        // C s_1314_3: cast zx s_1314_2 -> bv
        let s_1314_3: Bits = Bits::new(s_1314_2 as u128, 4u16);
        // D s_1314_4: cmp-eq s_1314_1 s_1314_3
        let s_1314_4: bool = ((s_1314_1) == (s_1314_3));
        // N s_1314_5: branch s_1314_4 b4940 b1315
        if s_1314_4 {
            return block_4940(state, tracer, fn_state);
        } else {
            return block_1315(state, tracer, fn_state);
        };
    }
    fn block_1315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1315_0: const #0u : u8
        let s_1315_0: bool = false;
        // D s_1315_1: write-var gs#118132 <= s_1315_0
        fn_state.gs_118132 = s_1315_0;
        // N s_1315_2: jump b1316
        return block_1316(state, tracer, fn_state);
    }
    fn block_1316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1316_0: read-var gs#118132:u8
        let s_1316_0: bool = fn_state.gs_118132;
        // N s_1316_1: branch s_1316_0 b4939 b1317
        if s_1316_0 {
            return block_4939(state, tracer, fn_state);
        } else {
            return block_1317(state, tracer, fn_state);
        };
    }
    fn block_1317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1317_0: const #0u : u8
        let s_1317_0: bool = false;
        // D s_1317_1: write-var gs#118133 <= s_1317_0
        fn_state.gs_118133 = s_1317_0;
        // N s_1317_2: jump b1318
        return block_1318(state, tracer, fn_state);
    }
    fn block_1318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1318_0: read-var gs#118133:u8
        let s_1318_0: bool = fn_state.gs_118133;
        // N s_1318_1: branch s_1318_0 b4938 b1319
        if s_1318_0 {
            return block_4938(state, tracer, fn_state);
        } else {
            return block_1319(state, tracer, fn_state);
        };
    }
    fn block_1319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1319_0: const #0u : u8
        let s_1319_0: bool = false;
        // D s_1319_1: write-var gs#118134 <= s_1319_0
        fn_state.gs_118134 = s_1319_0;
        // N s_1319_2: jump b1320
        return block_1320(state, tracer, fn_state);
    }
    fn block_1320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1320_0: read-var gs#118134:u8
        let s_1320_0: bool = fn_state.gs_118134;
        // N s_1320_1: branch s_1320_0 b4937 b1321
        if s_1320_0 {
            return block_4937(state, tracer, fn_state);
        } else {
            return block_1321(state, tracer, fn_state);
        };
    }
    fn block_1321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1321_0: const #0u : u8
        let s_1321_0: bool = false;
        // D s_1321_1: write-var gs#118135 <= s_1321_0
        fn_state.gs_118135 = s_1321_0;
        // N s_1321_2: jump b1322
        return block_1322(state, tracer, fn_state);
    }
    fn block_1322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1322_0: read-var gs#118135:u8
        let s_1322_0: bool = fn_state.gs_118135;
        // N s_1322_1: branch s_1322_0 b4936 b1323
        if s_1322_0 {
            return block_4936(state, tracer, fn_state);
        } else {
            return block_1323(state, tracer, fn_state);
        };
    }
    fn block_1323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1323_0: read-var CRm:u8
        let s_1323_0: u8 = fn_state.CRm;
        // D s_1323_1: cast zx s_1323_0 -> bv
        let s_1323_1: Bits = Bits::new(s_1323_0 as u128, 4u16);
        // C s_1323_2: const #5u : u8
        let s_1323_2: u8 = 5;
        // C s_1323_3: cast zx s_1323_2 -> bv
        let s_1323_3: Bits = Bits::new(s_1323_2 as u128, 4u16);
        // D s_1323_4: cmp-eq s_1323_1 s_1323_3
        let s_1323_4: bool = ((s_1323_1) == (s_1323_3));
        // N s_1323_5: branch s_1323_4 b4935 b1324
        if s_1323_4 {
            return block_4935(state, tracer, fn_state);
        } else {
            return block_1324(state, tracer, fn_state);
        };
    }
    fn block_1324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1324_0: const #0u : u8
        let s_1324_0: bool = false;
        // D s_1324_1: write-var gs#118136 <= s_1324_0
        fn_state.gs_118136 = s_1324_0;
        // N s_1324_2: jump b1325
        return block_1325(state, tracer, fn_state);
    }
    fn block_1325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1325_0: read-var gs#118136:u8
        let s_1325_0: bool = fn_state.gs_118136;
        // N s_1325_1: branch s_1325_0 b4934 b1326
        if s_1325_0 {
            return block_4934(state, tracer, fn_state);
        } else {
            return block_1326(state, tracer, fn_state);
        };
    }
    fn block_1326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1326_0: const #0u : u8
        let s_1326_0: bool = false;
        // D s_1326_1: write-var gs#118137 <= s_1326_0
        fn_state.gs_118137 = s_1326_0;
        // N s_1326_2: jump b1327
        return block_1327(state, tracer, fn_state);
    }
    fn block_1327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1327_0: read-var gs#118137:u8
        let s_1327_0: bool = fn_state.gs_118137;
        // N s_1327_1: branch s_1327_0 b4933 b1328
        if s_1327_0 {
            return block_4933(state, tracer, fn_state);
        } else {
            return block_1328(state, tracer, fn_state);
        };
    }
    fn block_1328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1328_0: const #0u : u8
        let s_1328_0: bool = false;
        // D s_1328_1: write-var gs#118138 <= s_1328_0
        fn_state.gs_118138 = s_1328_0;
        // N s_1328_2: jump b1329
        return block_1329(state, tracer, fn_state);
    }
    fn block_1329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1329_0: read-var gs#118138:u8
        let s_1329_0: bool = fn_state.gs_118138;
        // N s_1329_1: branch s_1329_0 b4932 b1330
        if s_1329_0 {
            return block_4932(state, tracer, fn_state);
        } else {
            return block_1330(state, tracer, fn_state);
        };
    }
    fn block_1330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1330_0: const #0u : u8
        let s_1330_0: bool = false;
        // D s_1330_1: write-var gs#118139 <= s_1330_0
        fn_state.gs_118139 = s_1330_0;
        // N s_1330_2: jump b1331
        return block_1331(state, tracer, fn_state);
    }
    fn block_1331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1331_0: read-var gs#118139:u8
        let s_1331_0: bool = fn_state.gs_118139;
        // N s_1331_1: branch s_1331_0 b4931 b1332
        if s_1331_0 {
            return block_4931(state, tracer, fn_state);
        } else {
            return block_1332(state, tracer, fn_state);
        };
    }
    fn block_1332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1332_0: read-var CRm:u8
        let s_1332_0: u8 = fn_state.CRm;
        // D s_1332_1: cast zx s_1332_0 -> bv
        let s_1332_1: Bits = Bits::new(s_1332_0 as u128, 4u16);
        // C s_1332_2: const #1u : u8
        let s_1332_2: u8 = 1;
        // C s_1332_3: cast zx s_1332_2 -> bv
        let s_1332_3: Bits = Bits::new(s_1332_2 as u128, 4u16);
        // D s_1332_4: cmp-eq s_1332_1 s_1332_3
        let s_1332_4: bool = ((s_1332_1) == (s_1332_3));
        // N s_1332_5: branch s_1332_4 b4930 b1333
        if s_1332_4 {
            return block_4930(state, tracer, fn_state);
        } else {
            return block_1333(state, tracer, fn_state);
        };
    }
    fn block_1333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1333_0: const #0u : u8
        let s_1333_0: bool = false;
        // D s_1333_1: write-var gs#118140 <= s_1333_0
        fn_state.gs_118140 = s_1333_0;
        // N s_1333_2: jump b1334
        return block_1334(state, tracer, fn_state);
    }
    fn block_1334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1334_0: read-var gs#118140:u8
        let s_1334_0: bool = fn_state.gs_118140;
        // N s_1334_1: branch s_1334_0 b4929 b1335
        if s_1334_0 {
            return block_4929(state, tracer, fn_state);
        } else {
            return block_1335(state, tracer, fn_state);
        };
    }
    fn block_1335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1335_0: const #0u : u8
        let s_1335_0: bool = false;
        // D s_1335_1: write-var gs#118141 <= s_1335_0
        fn_state.gs_118141 = s_1335_0;
        // N s_1335_2: jump b1336
        return block_1336(state, tracer, fn_state);
    }
    fn block_1336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1336_0: read-var gs#118141:u8
        let s_1336_0: bool = fn_state.gs_118141;
        // N s_1336_1: branch s_1336_0 b4928 b1337
        if s_1336_0 {
            return block_4928(state, tracer, fn_state);
        } else {
            return block_1337(state, tracer, fn_state);
        };
    }
    fn block_1337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1337_0: const #0u : u8
        let s_1337_0: bool = false;
        // D s_1337_1: write-var gs#118142 <= s_1337_0
        fn_state.gs_118142 = s_1337_0;
        // N s_1337_2: jump b1338
        return block_1338(state, tracer, fn_state);
    }
    fn block_1338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1338_0: read-var gs#118142:u8
        let s_1338_0: bool = fn_state.gs_118142;
        // N s_1338_1: branch s_1338_0 b4927 b1339
        if s_1338_0 {
            return block_4927(state, tracer, fn_state);
        } else {
            return block_1339(state, tracer, fn_state);
        };
    }
    fn block_1339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1339_0: const #0u : u8
        let s_1339_0: bool = false;
        // D s_1339_1: write-var gs#118143 <= s_1339_0
        fn_state.gs_118143 = s_1339_0;
        // N s_1339_2: jump b1340
        return block_1340(state, tracer, fn_state);
    }
    fn block_1340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1340_0: read-var gs#118143:u8
        let s_1340_0: bool = fn_state.gs_118143;
        // N s_1340_1: branch s_1340_0 b4926 b1341
        if s_1340_0 {
            return block_4926(state, tracer, fn_state);
        } else {
            return block_1341(state, tracer, fn_state);
        };
    }
    fn block_1341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1341_0: read-var CRm:u8
        let s_1341_0: u8 = fn_state.CRm;
        // D s_1341_1: cast zx s_1341_0 -> bv
        let s_1341_1: Bits = Bits::new(s_1341_0 as u128, 4u16);
        // C s_1341_2: const #12u : u8
        let s_1341_2: u8 = 12;
        // C s_1341_3: cast zx s_1341_2 -> bv
        let s_1341_3: Bits = Bits::new(s_1341_2 as u128, 4u16);
        // D s_1341_4: cmp-eq s_1341_1 s_1341_3
        let s_1341_4: bool = ((s_1341_1) == (s_1341_3));
        // N s_1341_5: branch s_1341_4 b4925 b1342
        if s_1341_4 {
            return block_4925(state, tracer, fn_state);
        } else {
            return block_1342(state, tracer, fn_state);
        };
    }
    fn block_1342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1342_0: const #0u : u8
        let s_1342_0: bool = false;
        // D s_1342_1: write-var gs#118144 <= s_1342_0
        fn_state.gs_118144 = s_1342_0;
        // N s_1342_2: jump b1343
        return block_1343(state, tracer, fn_state);
    }
    fn block_1343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1343_0: read-var gs#118144:u8
        let s_1343_0: bool = fn_state.gs_118144;
        // N s_1343_1: branch s_1343_0 b4924 b1344
        if s_1343_0 {
            return block_4924(state, tracer, fn_state);
        } else {
            return block_1344(state, tracer, fn_state);
        };
    }
    fn block_1344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1344_0: const #0u : u8
        let s_1344_0: bool = false;
        // D s_1344_1: write-var gs#118145 <= s_1344_0
        fn_state.gs_118145 = s_1344_0;
        // N s_1344_2: jump b1345
        return block_1345(state, tracer, fn_state);
    }
    fn block_1345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1345_0: read-var gs#118145:u8
        let s_1345_0: bool = fn_state.gs_118145;
        // N s_1345_1: branch s_1345_0 b4923 b1346
        if s_1345_0 {
            return block_4923(state, tracer, fn_state);
        } else {
            return block_1346(state, tracer, fn_state);
        };
    }
    fn block_1346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1346_0: const #0u : u8
        let s_1346_0: bool = false;
        // D s_1346_1: write-var gs#118146 <= s_1346_0
        fn_state.gs_118146 = s_1346_0;
        // N s_1346_2: jump b1347
        return block_1347(state, tracer, fn_state);
    }
    fn block_1347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1347_0: read-var gs#118146:u8
        let s_1347_0: bool = fn_state.gs_118146;
        // N s_1347_1: branch s_1347_0 b4922 b1348
        if s_1347_0 {
            return block_4922(state, tracer, fn_state);
        } else {
            return block_1348(state, tracer, fn_state);
        };
    }
    fn block_1348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1348_0: const #0u : u8
        let s_1348_0: bool = false;
        // D s_1348_1: write-var gs#118147 <= s_1348_0
        fn_state.gs_118147 = s_1348_0;
        // N s_1348_2: jump b1349
        return block_1349(state, tracer, fn_state);
    }
    fn block_1349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1349_0: read-var gs#118147:u8
        let s_1349_0: bool = fn_state.gs_118147;
        // N s_1349_1: branch s_1349_0 b4921 b1350
        if s_1349_0 {
            return block_4921(state, tracer, fn_state);
        } else {
            return block_1350(state, tracer, fn_state);
        };
    }
    fn block_1350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1350_0: read-var CRm:u8
        let s_1350_0: u8 = fn_state.CRm;
        // D s_1350_1: cast zx s_1350_0 -> bv
        let s_1350_1: Bits = Bits::new(s_1350_0 as u128, 4u16);
        // C s_1350_2: const #12u : u8
        let s_1350_2: u8 = 12;
        // C s_1350_3: cast zx s_1350_2 -> bv
        let s_1350_3: Bits = Bits::new(s_1350_2 as u128, 4u16);
        // D s_1350_4: cmp-eq s_1350_1 s_1350_3
        let s_1350_4: bool = ((s_1350_1) == (s_1350_3));
        // N s_1350_5: branch s_1350_4 b4920 b1351
        if s_1350_4 {
            return block_4920(state, tracer, fn_state);
        } else {
            return block_1351(state, tracer, fn_state);
        };
    }
    fn block_1351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1351_0: const #0u : u8
        let s_1351_0: bool = false;
        // D s_1351_1: write-var gs#118148 <= s_1351_0
        fn_state.gs_118148 = s_1351_0;
        // N s_1351_2: jump b1352
        return block_1352(state, tracer, fn_state);
    }
    fn block_1352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1352_0: read-var gs#118148:u8
        let s_1352_0: bool = fn_state.gs_118148;
        // N s_1352_1: branch s_1352_0 b4919 b1353
        if s_1352_0 {
            return block_4919(state, tracer, fn_state);
        } else {
            return block_1353(state, tracer, fn_state);
        };
    }
    fn block_1353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1353_0: const #0u : u8
        let s_1353_0: bool = false;
        // D s_1353_1: write-var gs#118149 <= s_1353_0
        fn_state.gs_118149 = s_1353_0;
        // N s_1353_2: jump b1354
        return block_1354(state, tracer, fn_state);
    }
    fn block_1354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1354_0: read-var gs#118149:u8
        let s_1354_0: bool = fn_state.gs_118149;
        // N s_1354_1: branch s_1354_0 b4918 b1355
        if s_1354_0 {
            return block_4918(state, tracer, fn_state);
        } else {
            return block_1355(state, tracer, fn_state);
        };
    }
    fn block_1355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1355_0: const #0u : u8
        let s_1355_0: bool = false;
        // D s_1355_1: write-var gs#118150 <= s_1355_0
        fn_state.gs_118150 = s_1355_0;
        // N s_1355_2: jump b1356
        return block_1356(state, tracer, fn_state);
    }
    fn block_1356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1356_0: read-var gs#118150:u8
        let s_1356_0: bool = fn_state.gs_118150;
        // N s_1356_1: branch s_1356_0 b4917 b1357
        if s_1356_0 {
            return block_4917(state, tracer, fn_state);
        } else {
            return block_1357(state, tracer, fn_state);
        };
    }
    fn block_1357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1357_0: const #0u : u8
        let s_1357_0: bool = false;
        // D s_1357_1: write-var gs#118151 <= s_1357_0
        fn_state.gs_118151 = s_1357_0;
        // N s_1357_2: jump b1358
        return block_1358(state, tracer, fn_state);
    }
    fn block_1358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1358_0: read-var gs#118151:u8
        let s_1358_0: bool = fn_state.gs_118151;
        // N s_1358_1: branch s_1358_0 b4916 b1359
        if s_1358_0 {
            return block_4916(state, tracer, fn_state);
        } else {
            return block_1359(state, tracer, fn_state);
        };
    }
    fn block_1359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1359_0: read-var CRm:u8
        let s_1359_0: u8 = fn_state.CRm;
        // D s_1359_1: cast zx s_1359_0 -> bv
        let s_1359_1: Bits = Bits::new(s_1359_0 as u128, 4u16);
        // C s_1359_2: const #1u : u8
        let s_1359_2: u8 = 1;
        // C s_1359_3: cast zx s_1359_2 -> bv
        let s_1359_3: Bits = Bits::new(s_1359_2 as u128, 4u16);
        // D s_1359_4: cmp-eq s_1359_1 s_1359_3
        let s_1359_4: bool = ((s_1359_1) == (s_1359_3));
        // N s_1359_5: branch s_1359_4 b4915 b1360
        if s_1359_4 {
            return block_4915(state, tracer, fn_state);
        } else {
            return block_1360(state, tracer, fn_state);
        };
    }
    fn block_1360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1360_0: const #0u : u8
        let s_1360_0: bool = false;
        // D s_1360_1: write-var gs#118152 <= s_1360_0
        fn_state.gs_118152 = s_1360_0;
        // N s_1360_2: jump b1361
        return block_1361(state, tracer, fn_state);
    }
    fn block_1361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1361_0: read-var gs#118152:u8
        let s_1361_0: bool = fn_state.gs_118152;
        // N s_1361_1: branch s_1361_0 b4914 b1362
        if s_1361_0 {
            return block_4914(state, tracer, fn_state);
        } else {
            return block_1362(state, tracer, fn_state);
        };
    }
    fn block_1362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1362_0: const #0u : u8
        let s_1362_0: bool = false;
        // D s_1362_1: write-var gs#118153 <= s_1362_0
        fn_state.gs_118153 = s_1362_0;
        // N s_1362_2: jump b1363
        return block_1363(state, tracer, fn_state);
    }
    fn block_1363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1363_0: read-var gs#118153:u8
        let s_1363_0: bool = fn_state.gs_118153;
        // N s_1363_1: branch s_1363_0 b4913 b1364
        if s_1363_0 {
            return block_4913(state, tracer, fn_state);
        } else {
            return block_1364(state, tracer, fn_state);
        };
    }
    fn block_1364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1364_0: const #0u : u8
        let s_1364_0: bool = false;
        // D s_1364_1: write-var gs#118154 <= s_1364_0
        fn_state.gs_118154 = s_1364_0;
        // N s_1364_2: jump b1365
        return block_1365(state, tracer, fn_state);
    }
    fn block_1365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1365_0: read-var gs#118154:u8
        let s_1365_0: bool = fn_state.gs_118154;
        // N s_1365_1: branch s_1365_0 b4912 b1366
        if s_1365_0 {
            return block_4912(state, tracer, fn_state);
        } else {
            return block_1366(state, tracer, fn_state);
        };
    }
    fn block_1366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1366_0: const #0u : u8
        let s_1366_0: bool = false;
        // D s_1366_1: write-var gs#118155 <= s_1366_0
        fn_state.gs_118155 = s_1366_0;
        // N s_1366_2: jump b1367
        return block_1367(state, tracer, fn_state);
    }
    fn block_1367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1367_0: read-var gs#118155:u8
        let s_1367_0: bool = fn_state.gs_118155;
        // N s_1367_1: branch s_1367_0 b4911 b1368
        if s_1367_0 {
            return block_4911(state, tracer, fn_state);
        } else {
            return block_1368(state, tracer, fn_state);
        };
    }
    fn block_1368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1368_0: read-var CRm:u8
        let s_1368_0: u8 = fn_state.CRm;
        // D s_1368_1: cast zx s_1368_0 -> bv
        let s_1368_1: Bits = Bits::new(s_1368_0 as u128, 4u16);
        // C s_1368_2: const #8u : u8
        let s_1368_2: u8 = 8;
        // C s_1368_3: cast zx s_1368_2 -> bv
        let s_1368_3: Bits = Bits::new(s_1368_2 as u128, 4u16);
        // D s_1368_4: cmp-eq s_1368_1 s_1368_3
        let s_1368_4: bool = ((s_1368_1) == (s_1368_3));
        // N s_1368_5: branch s_1368_4 b4910 b1369
        if s_1368_4 {
            return block_4910(state, tracer, fn_state);
        } else {
            return block_1369(state, tracer, fn_state);
        };
    }
    fn block_1369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1369_0: const #0u : u8
        let s_1369_0: bool = false;
        // D s_1369_1: write-var gs#118156 <= s_1369_0
        fn_state.gs_118156 = s_1369_0;
        // N s_1369_2: jump b1370
        return block_1370(state, tracer, fn_state);
    }
    fn block_1370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1370_0: read-var gs#118156:u8
        let s_1370_0: bool = fn_state.gs_118156;
        // N s_1370_1: branch s_1370_0 b4909 b1371
        if s_1370_0 {
            return block_4909(state, tracer, fn_state);
        } else {
            return block_1371(state, tracer, fn_state);
        };
    }
    fn block_1371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1371_0: const #0u : u8
        let s_1371_0: bool = false;
        // D s_1371_1: write-var gs#118157 <= s_1371_0
        fn_state.gs_118157 = s_1371_0;
        // N s_1371_2: jump b1372
        return block_1372(state, tracer, fn_state);
    }
    fn block_1372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1372_0: read-var gs#118157:u8
        let s_1372_0: bool = fn_state.gs_118157;
        // N s_1372_1: branch s_1372_0 b4908 b1373
        if s_1372_0 {
            return block_4908(state, tracer, fn_state);
        } else {
            return block_1373(state, tracer, fn_state);
        };
    }
    fn block_1373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1373_0: const #0u : u8
        let s_1373_0: bool = false;
        // D s_1373_1: write-var gs#118158 <= s_1373_0
        fn_state.gs_118158 = s_1373_0;
        // N s_1373_2: jump b1374
        return block_1374(state, tracer, fn_state);
    }
    fn block_1374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1374_0: read-var gs#118158:u8
        let s_1374_0: bool = fn_state.gs_118158;
        // N s_1374_1: branch s_1374_0 b4907 b1375
        if s_1374_0 {
            return block_4907(state, tracer, fn_state);
        } else {
            return block_1375(state, tracer, fn_state);
        };
    }
    fn block_1375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1375_0: const #0u : u8
        let s_1375_0: bool = false;
        // D s_1375_1: write-var gs#118159 <= s_1375_0
        fn_state.gs_118159 = s_1375_0;
        // N s_1375_2: jump b1376
        return block_1376(state, tracer, fn_state);
    }
    fn block_1376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1376_0: read-var gs#118159:u8
        let s_1376_0: bool = fn_state.gs_118159;
        // N s_1376_1: branch s_1376_0 b4906 b1377
        if s_1376_0 {
            return block_4906(state, tracer, fn_state);
        } else {
            return block_1377(state, tracer, fn_state);
        };
    }
    fn block_1377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1377_0: read-var CRm:u8
        let s_1377_0: u8 = fn_state.CRm;
        // D s_1377_1: cast zx s_1377_0 -> bv
        let s_1377_1: Bits = Bits::new(s_1377_0 as u128, 4u16);
        // C s_1377_2: const #2u : u8
        let s_1377_2: u8 = 2;
        // C s_1377_3: cast zx s_1377_2 -> bv
        let s_1377_3: Bits = Bits::new(s_1377_2 as u128, 4u16);
        // D s_1377_4: cmp-eq s_1377_1 s_1377_3
        let s_1377_4: bool = ((s_1377_1) == (s_1377_3));
        // N s_1377_5: branch s_1377_4 b4905 b1378
        if s_1377_4 {
            return block_4905(state, tracer, fn_state);
        } else {
            return block_1378(state, tracer, fn_state);
        };
    }
    fn block_1378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1378_0: const #0u : u8
        let s_1378_0: bool = false;
        // D s_1378_1: write-var gs#118160 <= s_1378_0
        fn_state.gs_118160 = s_1378_0;
        // N s_1378_2: jump b1379
        return block_1379(state, tracer, fn_state);
    }
    fn block_1379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1379_0: read-var gs#118160:u8
        let s_1379_0: bool = fn_state.gs_118160;
        // N s_1379_1: branch s_1379_0 b4904 b1380
        if s_1379_0 {
            return block_4904(state, tracer, fn_state);
        } else {
            return block_1380(state, tracer, fn_state);
        };
    }
    fn block_1380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1380_0: const #0u : u8
        let s_1380_0: bool = false;
        // D s_1380_1: write-var gs#118161 <= s_1380_0
        fn_state.gs_118161 = s_1380_0;
        // N s_1380_2: jump b1381
        return block_1381(state, tracer, fn_state);
    }
    fn block_1381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1381_0: read-var gs#118161:u8
        let s_1381_0: bool = fn_state.gs_118161;
        // N s_1381_1: branch s_1381_0 b4903 b1382
        if s_1381_0 {
            return block_4903(state, tracer, fn_state);
        } else {
            return block_1382(state, tracer, fn_state);
        };
    }
    fn block_1382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1382_0: const #0u : u8
        let s_1382_0: bool = false;
        // D s_1382_1: write-var gs#118162 <= s_1382_0
        fn_state.gs_118162 = s_1382_0;
        // N s_1382_2: jump b1383
        return block_1383(state, tracer, fn_state);
    }
    fn block_1383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1383_0: read-var gs#118162:u8
        let s_1383_0: bool = fn_state.gs_118162;
        // N s_1383_1: branch s_1383_0 b4902 b1384
        if s_1383_0 {
            return block_4902(state, tracer, fn_state);
        } else {
            return block_1384(state, tracer, fn_state);
        };
    }
    fn block_1384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1384_0: const #0u : u8
        let s_1384_0: bool = false;
        // D s_1384_1: write-var gs#118163 <= s_1384_0
        fn_state.gs_118163 = s_1384_0;
        // N s_1384_2: jump b1385
        return block_1385(state, tracer, fn_state);
    }
    fn block_1385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1385_0: read-var gs#118163:u8
        let s_1385_0: bool = fn_state.gs_118163;
        // N s_1385_1: branch s_1385_0 b4901 b1386
        if s_1385_0 {
            return block_4901(state, tracer, fn_state);
        } else {
            return block_1386(state, tracer, fn_state);
        };
    }
    fn block_1386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1386_0: read-var CRm:u8
        let s_1386_0: u8 = fn_state.CRm;
        // D s_1386_1: cast zx s_1386_0 -> bv
        let s_1386_1: Bits = Bits::new(s_1386_0 as u128, 4u16);
        // C s_1386_2: const #0u : u8
        let s_1386_2: u8 = 0;
        // C s_1386_3: cast zx s_1386_2 -> bv
        let s_1386_3: Bits = Bits::new(s_1386_2 as u128, 4u16);
        // D s_1386_4: cmp-eq s_1386_1 s_1386_3
        let s_1386_4: bool = ((s_1386_1) == (s_1386_3));
        // N s_1386_5: branch s_1386_4 b4900 b1387
        if s_1386_4 {
            return block_4900(state, tracer, fn_state);
        } else {
            return block_1387(state, tracer, fn_state);
        };
    }
    fn block_1387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1387_0: const #0u : u8
        let s_1387_0: bool = false;
        // D s_1387_1: write-var gs#118164 <= s_1387_0
        fn_state.gs_118164 = s_1387_0;
        // N s_1387_2: jump b1388
        return block_1388(state, tracer, fn_state);
    }
    fn block_1388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1388_0: read-var gs#118164:u8
        let s_1388_0: bool = fn_state.gs_118164;
        // N s_1388_1: branch s_1388_0 b4899 b1389
        if s_1388_0 {
            return block_4899(state, tracer, fn_state);
        } else {
            return block_1389(state, tracer, fn_state);
        };
    }
    fn block_1389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1389_0: const #0u : u8
        let s_1389_0: bool = false;
        // D s_1389_1: write-var gs#118165 <= s_1389_0
        fn_state.gs_118165 = s_1389_0;
        // N s_1389_2: jump b1390
        return block_1390(state, tracer, fn_state);
    }
    fn block_1390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1390_0: read-var gs#118165:u8
        let s_1390_0: bool = fn_state.gs_118165;
        // N s_1390_1: branch s_1390_0 b4898 b1391
        if s_1390_0 {
            return block_4898(state, tracer, fn_state);
        } else {
            return block_1391(state, tracer, fn_state);
        };
    }
    fn block_1391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1391_0: const #0u : u8
        let s_1391_0: bool = false;
        // D s_1391_1: write-var gs#118166 <= s_1391_0
        fn_state.gs_118166 = s_1391_0;
        // N s_1391_2: jump b1392
        return block_1392(state, tracer, fn_state);
    }
    fn block_1392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1392_0: read-var gs#118166:u8
        let s_1392_0: bool = fn_state.gs_118166;
        // N s_1392_1: branch s_1392_0 b4897 b1393
        if s_1392_0 {
            return block_4897(state, tracer, fn_state);
        } else {
            return block_1393(state, tracer, fn_state);
        };
    }
    fn block_1393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1393_0: const #0u : u8
        let s_1393_0: bool = false;
        // D s_1393_1: write-var gs#118167 <= s_1393_0
        fn_state.gs_118167 = s_1393_0;
        // N s_1393_2: jump b1394
        return block_1394(state, tracer, fn_state);
    }
    fn block_1394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1394_0: read-var gs#118167:u8
        let s_1394_0: bool = fn_state.gs_118167;
        // N s_1394_1: branch s_1394_0 b4896 b1395
        if s_1394_0 {
            return block_4896(state, tracer, fn_state);
        } else {
            return block_1395(state, tracer, fn_state);
        };
    }
    fn block_1395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1395_0: read-var CRm:u8
        let s_1395_0: u8 = fn_state.CRm;
        // D s_1395_1: cast zx s_1395_0 -> bv
        let s_1395_1: Bits = Bits::new(s_1395_0 as u128, 4u16);
        // C s_1395_2: const #11u : u8
        let s_1395_2: u8 = 11;
        // C s_1395_3: cast zx s_1395_2 -> bv
        let s_1395_3: Bits = Bits::new(s_1395_2 as u128, 4u16);
        // D s_1395_4: cmp-eq s_1395_1 s_1395_3
        let s_1395_4: bool = ((s_1395_1) == (s_1395_3));
        // N s_1395_5: branch s_1395_4 b4895 b1396
        if s_1395_4 {
            return block_4895(state, tracer, fn_state);
        } else {
            return block_1396(state, tracer, fn_state);
        };
    }
    fn block_1396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1396_0: const #0u : u8
        let s_1396_0: bool = false;
        // D s_1396_1: write-var gs#118168 <= s_1396_0
        fn_state.gs_118168 = s_1396_0;
        // N s_1396_2: jump b1397
        return block_1397(state, tracer, fn_state);
    }
    fn block_1397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1397_0: read-var gs#118168:u8
        let s_1397_0: bool = fn_state.gs_118168;
        // N s_1397_1: branch s_1397_0 b4894 b1398
        if s_1397_0 {
            return block_4894(state, tracer, fn_state);
        } else {
            return block_1398(state, tracer, fn_state);
        };
    }
    fn block_1398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1398_0: const #0u : u8
        let s_1398_0: bool = false;
        // D s_1398_1: write-var gs#118169 <= s_1398_0
        fn_state.gs_118169 = s_1398_0;
        // N s_1398_2: jump b1399
        return block_1399(state, tracer, fn_state);
    }
    fn block_1399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1399_0: read-var gs#118169:u8
        let s_1399_0: bool = fn_state.gs_118169;
        // N s_1399_1: branch s_1399_0 b4893 b1400
        if s_1399_0 {
            return block_4893(state, tracer, fn_state);
        } else {
            return block_1400(state, tracer, fn_state);
        };
    }
    fn block_1400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1400_0: const #0u : u8
        let s_1400_0: bool = false;
        // D s_1400_1: write-var gs#118170 <= s_1400_0
        fn_state.gs_118170 = s_1400_0;
        // N s_1400_2: jump b1401
        return block_1401(state, tracer, fn_state);
    }
    fn block_1401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1401_0: read-var gs#118170:u8
        let s_1401_0: bool = fn_state.gs_118170;
        // N s_1401_1: branch s_1401_0 b4892 b1402
        if s_1401_0 {
            return block_4892(state, tracer, fn_state);
        } else {
            return block_1402(state, tracer, fn_state);
        };
    }
    fn block_1402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1402_0: const #0u : u8
        let s_1402_0: bool = false;
        // D s_1402_1: write-var gs#118171 <= s_1402_0
        fn_state.gs_118171 = s_1402_0;
        // N s_1402_2: jump b1403
        return block_1403(state, tracer, fn_state);
    }
    fn block_1403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1403_0: read-var gs#118171:u8
        let s_1403_0: bool = fn_state.gs_118171;
        // N s_1403_1: branch s_1403_0 b4891 b1404
        if s_1403_0 {
            return block_4891(state, tracer, fn_state);
        } else {
            return block_1404(state, tracer, fn_state);
        };
    }
    fn block_1404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1404_0: read-var CRm:u8
        let s_1404_0: u8 = fn_state.CRm;
        // D s_1404_1: cast zx s_1404_0 -> bv
        let s_1404_1: Bits = Bits::new(s_1404_0 as u128, 4u16);
        // C s_1404_2: const #11u : u8
        let s_1404_2: u8 = 11;
        // C s_1404_3: cast zx s_1404_2 -> bv
        let s_1404_3: Bits = Bits::new(s_1404_2 as u128, 4u16);
        // D s_1404_4: cmp-eq s_1404_1 s_1404_3
        let s_1404_4: bool = ((s_1404_1) == (s_1404_3));
        // N s_1404_5: branch s_1404_4 b4890 b1405
        if s_1404_4 {
            return block_4890(state, tracer, fn_state);
        } else {
            return block_1405(state, tracer, fn_state);
        };
    }
    fn block_1405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1405_0: const #0u : u8
        let s_1405_0: bool = false;
        // D s_1405_1: write-var gs#118172 <= s_1405_0
        fn_state.gs_118172 = s_1405_0;
        // N s_1405_2: jump b1406
        return block_1406(state, tracer, fn_state);
    }
    fn block_1406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1406_0: read-var gs#118172:u8
        let s_1406_0: bool = fn_state.gs_118172;
        // N s_1406_1: branch s_1406_0 b4889 b1407
        if s_1406_0 {
            return block_4889(state, tracer, fn_state);
        } else {
            return block_1407(state, tracer, fn_state);
        };
    }
    fn block_1407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1407_0: const #0u : u8
        let s_1407_0: bool = false;
        // D s_1407_1: write-var gs#118173 <= s_1407_0
        fn_state.gs_118173 = s_1407_0;
        // N s_1407_2: jump b1408
        return block_1408(state, tracer, fn_state);
    }
    fn block_1408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1408_0: read-var gs#118173:u8
        let s_1408_0: bool = fn_state.gs_118173;
        // N s_1408_1: branch s_1408_0 b4888 b1409
        if s_1408_0 {
            return block_4888(state, tracer, fn_state);
        } else {
            return block_1409(state, tracer, fn_state);
        };
    }
    fn block_1409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1409_0: const #0u : u8
        let s_1409_0: bool = false;
        // D s_1409_1: write-var gs#118174 <= s_1409_0
        fn_state.gs_118174 = s_1409_0;
        // N s_1409_2: jump b1410
        return block_1410(state, tracer, fn_state);
    }
    fn block_1410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1410_0: read-var gs#118174:u8
        let s_1410_0: bool = fn_state.gs_118174;
        // N s_1410_1: branch s_1410_0 b4887 b1411
        if s_1410_0 {
            return block_4887(state, tracer, fn_state);
        } else {
            return block_1411(state, tracer, fn_state);
        };
    }
    fn block_1411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1411_0: const #0u : u8
        let s_1411_0: bool = false;
        // D s_1411_1: write-var gs#118175 <= s_1411_0
        fn_state.gs_118175 = s_1411_0;
        // N s_1411_2: jump b1412
        return block_1412(state, tracer, fn_state);
    }
    fn block_1412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1412_0: read-var gs#118175:u8
        let s_1412_0: bool = fn_state.gs_118175;
        // N s_1412_1: branch s_1412_0 b4886 b1413
        if s_1412_0 {
            return block_4886(state, tracer, fn_state);
        } else {
            return block_1413(state, tracer, fn_state);
        };
    }
    fn block_1413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1413_0: read-var CRm:u8
        let s_1413_0: u8 = fn_state.CRm;
        // D s_1413_1: cast zx s_1413_0 -> bv
        let s_1413_1: Bits = Bits::new(s_1413_0 as u128, 4u16);
        // C s_1413_2: const #11u : u8
        let s_1413_2: u8 = 11;
        // C s_1413_3: cast zx s_1413_2 -> bv
        let s_1413_3: Bits = Bits::new(s_1413_2 as u128, 4u16);
        // D s_1413_4: cmp-eq s_1413_1 s_1413_3
        let s_1413_4: bool = ((s_1413_1) == (s_1413_3));
        // N s_1413_5: branch s_1413_4 b4885 b1414
        if s_1413_4 {
            return block_4885(state, tracer, fn_state);
        } else {
            return block_1414(state, tracer, fn_state);
        };
    }
    fn block_1414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1414_0: const #0u : u8
        let s_1414_0: bool = false;
        // D s_1414_1: write-var gs#118176 <= s_1414_0
        fn_state.gs_118176 = s_1414_0;
        // N s_1414_2: jump b1415
        return block_1415(state, tracer, fn_state);
    }
    fn block_1415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1415_0: read-var gs#118176:u8
        let s_1415_0: bool = fn_state.gs_118176;
        // N s_1415_1: branch s_1415_0 b4884 b1416
        if s_1415_0 {
            return block_4884(state, tracer, fn_state);
        } else {
            return block_1416(state, tracer, fn_state);
        };
    }
    fn block_1416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1416_0: const #0u : u8
        let s_1416_0: bool = false;
        // D s_1416_1: write-var gs#118177 <= s_1416_0
        fn_state.gs_118177 = s_1416_0;
        // N s_1416_2: jump b1417
        return block_1417(state, tracer, fn_state);
    }
    fn block_1417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1417_0: read-var gs#118177:u8
        let s_1417_0: bool = fn_state.gs_118177;
        // N s_1417_1: branch s_1417_0 b4883 b1418
        if s_1417_0 {
            return block_4883(state, tracer, fn_state);
        } else {
            return block_1418(state, tracer, fn_state);
        };
    }
    fn block_1418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1418_0: const #0u : u8
        let s_1418_0: bool = false;
        // D s_1418_1: write-var gs#118178 <= s_1418_0
        fn_state.gs_118178 = s_1418_0;
        // N s_1418_2: jump b1419
        return block_1419(state, tracer, fn_state);
    }
    fn block_1419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1419_0: read-var gs#118178:u8
        let s_1419_0: bool = fn_state.gs_118178;
        // N s_1419_1: branch s_1419_0 b4882 b1420
        if s_1419_0 {
            return block_4882(state, tracer, fn_state);
        } else {
            return block_1420(state, tracer, fn_state);
        };
    }
    fn block_1420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1420_0: const #0u : u8
        let s_1420_0: bool = false;
        // D s_1420_1: write-var gs#118179 <= s_1420_0
        fn_state.gs_118179 = s_1420_0;
        // N s_1420_2: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_1421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1421_0: read-var gs#118179:u8
        let s_1421_0: bool = fn_state.gs_118179;
        // N s_1421_1: branch s_1421_0 b4881 b1422
        if s_1421_0 {
            return block_4881(state, tracer, fn_state);
        } else {
            return block_1422(state, tracer, fn_state);
        };
    }
    fn block_1422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1422_0: read-var CRm:u8
        let s_1422_0: u8 = fn_state.CRm;
        // D s_1422_1: cast zx s_1422_0 -> bv
        let s_1422_1: Bits = Bits::new(s_1422_0 as u128, 4u16);
        // C s_1422_2: const #11u : u8
        let s_1422_2: u8 = 11;
        // C s_1422_3: cast zx s_1422_2 -> bv
        let s_1422_3: Bits = Bits::new(s_1422_2 as u128, 4u16);
        // D s_1422_4: cmp-eq s_1422_1 s_1422_3
        let s_1422_4: bool = ((s_1422_1) == (s_1422_3));
        // N s_1422_5: branch s_1422_4 b4880 b1423
        if s_1422_4 {
            return block_4880(state, tracer, fn_state);
        } else {
            return block_1423(state, tracer, fn_state);
        };
    }
    fn block_1423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1423_0: const #0u : u8
        let s_1423_0: bool = false;
        // D s_1423_1: write-var gs#118180 <= s_1423_0
        fn_state.gs_118180 = s_1423_0;
        // N s_1423_2: jump b1424
        return block_1424(state, tracer, fn_state);
    }
    fn block_1424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1424_0: read-var gs#118180:u8
        let s_1424_0: bool = fn_state.gs_118180;
        // N s_1424_1: branch s_1424_0 b4879 b1425
        if s_1424_0 {
            return block_4879(state, tracer, fn_state);
        } else {
            return block_1425(state, tracer, fn_state);
        };
    }
    fn block_1425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1425_0: const #0u : u8
        let s_1425_0: bool = false;
        // D s_1425_1: write-var gs#118181 <= s_1425_0
        fn_state.gs_118181 = s_1425_0;
        // N s_1425_2: jump b1426
        return block_1426(state, tracer, fn_state);
    }
    fn block_1426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1426_0: read-var gs#118181:u8
        let s_1426_0: bool = fn_state.gs_118181;
        // N s_1426_1: branch s_1426_0 b4878 b1427
        if s_1426_0 {
            return block_4878(state, tracer, fn_state);
        } else {
            return block_1427(state, tracer, fn_state);
        };
    }
    fn block_1427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1427_0: const #0u : u8
        let s_1427_0: bool = false;
        // D s_1427_1: write-var gs#118182 <= s_1427_0
        fn_state.gs_118182 = s_1427_0;
        // N s_1427_2: jump b1428
        return block_1428(state, tracer, fn_state);
    }
    fn block_1428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1428_0: read-var gs#118182:u8
        let s_1428_0: bool = fn_state.gs_118182;
        // N s_1428_1: branch s_1428_0 b4877 b1429
        if s_1428_0 {
            return block_4877(state, tracer, fn_state);
        } else {
            return block_1429(state, tracer, fn_state);
        };
    }
    fn block_1429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1429_0: const #0u : u8
        let s_1429_0: bool = false;
        // D s_1429_1: write-var gs#118183 <= s_1429_0
        fn_state.gs_118183 = s_1429_0;
        // N s_1429_2: jump b1430
        return block_1430(state, tracer, fn_state);
    }
    fn block_1430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1430_0: read-var gs#118183:u8
        let s_1430_0: bool = fn_state.gs_118183;
        // N s_1430_1: branch s_1430_0 b4876 b1431
        if s_1430_0 {
            return block_4876(state, tracer, fn_state);
        } else {
            return block_1431(state, tracer, fn_state);
        };
    }
    fn block_1431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1431_0: read-var CRm:u8
        let s_1431_0: u8 = fn_state.CRm;
        // D s_1431_1: cast zx s_1431_0 -> bv
        let s_1431_1: Bits = Bits::new(s_1431_0 as u128, 4u16);
        // C s_1431_2: const #11u : u8
        let s_1431_2: u8 = 11;
        // C s_1431_3: cast zx s_1431_2 -> bv
        let s_1431_3: Bits = Bits::new(s_1431_2 as u128, 4u16);
        // D s_1431_4: cmp-eq s_1431_1 s_1431_3
        let s_1431_4: bool = ((s_1431_1) == (s_1431_3));
        // N s_1431_5: branch s_1431_4 b4875 b1432
        if s_1431_4 {
            return block_4875(state, tracer, fn_state);
        } else {
            return block_1432(state, tracer, fn_state);
        };
    }
    fn block_1432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1432_0: const #0u : u8
        let s_1432_0: bool = false;
        // D s_1432_1: write-var gs#118184 <= s_1432_0
        fn_state.gs_118184 = s_1432_0;
        // N s_1432_2: jump b1433
        return block_1433(state, tracer, fn_state);
    }
    fn block_1433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1433_0: read-var gs#118184:u8
        let s_1433_0: bool = fn_state.gs_118184;
        // N s_1433_1: branch s_1433_0 b4874 b1434
        if s_1433_0 {
            return block_4874(state, tracer, fn_state);
        } else {
            return block_1434(state, tracer, fn_state);
        };
    }
    fn block_1434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1434_0: const #0u : u8
        let s_1434_0: bool = false;
        // D s_1434_1: write-var gs#118185 <= s_1434_0
        fn_state.gs_118185 = s_1434_0;
        // N s_1434_2: jump b1435
        return block_1435(state, tracer, fn_state);
    }
    fn block_1435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1435_0: read-var gs#118185:u8
        let s_1435_0: bool = fn_state.gs_118185;
        // N s_1435_1: branch s_1435_0 b4873 b1436
        if s_1435_0 {
            return block_4873(state, tracer, fn_state);
        } else {
            return block_1436(state, tracer, fn_state);
        };
    }
    fn block_1436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1436_0: const #0u : u8
        let s_1436_0: bool = false;
        // D s_1436_1: write-var gs#118186 <= s_1436_0
        fn_state.gs_118186 = s_1436_0;
        // N s_1436_2: jump b1437
        return block_1437(state, tracer, fn_state);
    }
    fn block_1437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1437_0: read-var gs#118186:u8
        let s_1437_0: bool = fn_state.gs_118186;
        // N s_1437_1: branch s_1437_0 b4872 b1438
        if s_1437_0 {
            return block_4872(state, tracer, fn_state);
        } else {
            return block_1438(state, tracer, fn_state);
        };
    }
    fn block_1438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1438_0: const #0u : u8
        let s_1438_0: bool = false;
        // D s_1438_1: write-var gs#118187 <= s_1438_0
        fn_state.gs_118187 = s_1438_0;
        // N s_1438_2: jump b1439
        return block_1439(state, tracer, fn_state);
    }
    fn block_1439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1439_0: read-var gs#118187:u8
        let s_1439_0: bool = fn_state.gs_118187;
        // N s_1439_1: branch s_1439_0 b4871 b1440
        if s_1439_0 {
            return block_4871(state, tracer, fn_state);
        } else {
            return block_1440(state, tracer, fn_state);
        };
    }
    fn block_1440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1440_0: read-var CRm:u8
        let s_1440_0: u8 = fn_state.CRm;
        // D s_1440_1: cast zx s_1440_0 -> bv
        let s_1440_1: Bits = Bits::new(s_1440_0 as u128, 4u16);
        // C s_1440_2: const #11u : u8
        let s_1440_2: u8 = 11;
        // C s_1440_3: cast zx s_1440_2 -> bv
        let s_1440_3: Bits = Bits::new(s_1440_2 as u128, 4u16);
        // D s_1440_4: cmp-eq s_1440_1 s_1440_3
        let s_1440_4: bool = ((s_1440_1) == (s_1440_3));
        // N s_1440_5: branch s_1440_4 b4870 b1441
        if s_1440_4 {
            return block_4870(state, tracer, fn_state);
        } else {
            return block_1441(state, tracer, fn_state);
        };
    }
    fn block_1441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1441_0: const #0u : u8
        let s_1441_0: bool = false;
        // D s_1441_1: write-var gs#118188 <= s_1441_0
        fn_state.gs_118188 = s_1441_0;
        // N s_1441_2: jump b1442
        return block_1442(state, tracer, fn_state);
    }
    fn block_1442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1442_0: read-var gs#118188:u8
        let s_1442_0: bool = fn_state.gs_118188;
        // N s_1442_1: branch s_1442_0 b4869 b1443
        if s_1442_0 {
            return block_4869(state, tracer, fn_state);
        } else {
            return block_1443(state, tracer, fn_state);
        };
    }
    fn block_1443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1443_0: const #0u : u8
        let s_1443_0: bool = false;
        // D s_1443_1: write-var gs#118189 <= s_1443_0
        fn_state.gs_118189 = s_1443_0;
        // N s_1443_2: jump b1444
        return block_1444(state, tracer, fn_state);
    }
    fn block_1444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1444_0: read-var gs#118189:u8
        let s_1444_0: bool = fn_state.gs_118189;
        // N s_1444_1: branch s_1444_0 b4868 b1445
        if s_1444_0 {
            return block_4868(state, tracer, fn_state);
        } else {
            return block_1445(state, tracer, fn_state);
        };
    }
    fn block_1445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1445_0: const #0u : u8
        let s_1445_0: bool = false;
        // D s_1445_1: write-var gs#118190 <= s_1445_0
        fn_state.gs_118190 = s_1445_0;
        // N s_1445_2: jump b1446
        return block_1446(state, tracer, fn_state);
    }
    fn block_1446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1446_0: read-var gs#118190:u8
        let s_1446_0: bool = fn_state.gs_118190;
        // N s_1446_1: branch s_1446_0 b4867 b1447
        if s_1446_0 {
            return block_4867(state, tracer, fn_state);
        } else {
            return block_1447(state, tracer, fn_state);
        };
    }
    fn block_1447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1447_0: const #0u : u8
        let s_1447_0: bool = false;
        // D s_1447_1: write-var gs#118191 <= s_1447_0
        fn_state.gs_118191 = s_1447_0;
        // N s_1447_2: jump b1448
        return block_1448(state, tracer, fn_state);
    }
    fn block_1448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1448_0: read-var gs#118191:u8
        let s_1448_0: bool = fn_state.gs_118191;
        // N s_1448_1: branch s_1448_0 b4866 b1449
        if s_1448_0 {
            return block_4866(state, tracer, fn_state);
        } else {
            return block_1449(state, tracer, fn_state);
        };
    }
    fn block_1449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1449_0: read-var CRm:u8
        let s_1449_0: u8 = fn_state.CRm;
        // D s_1449_1: cast zx s_1449_0 -> bv
        let s_1449_1: Bits = Bits::new(s_1449_0 as u128, 4u16);
        // C s_1449_2: const #11u : u8
        let s_1449_2: u8 = 11;
        // C s_1449_3: cast zx s_1449_2 -> bv
        let s_1449_3: Bits = Bits::new(s_1449_2 as u128, 4u16);
        // D s_1449_4: cmp-eq s_1449_1 s_1449_3
        let s_1449_4: bool = ((s_1449_1) == (s_1449_3));
        // N s_1449_5: branch s_1449_4 b4865 b1450
        if s_1449_4 {
            return block_4865(state, tracer, fn_state);
        } else {
            return block_1450(state, tracer, fn_state);
        };
    }
    fn block_1450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1450_0: const #0u : u8
        let s_1450_0: bool = false;
        // D s_1450_1: write-var gs#118192 <= s_1450_0
        fn_state.gs_118192 = s_1450_0;
        // N s_1450_2: jump b1451
        return block_1451(state, tracer, fn_state);
    }
    fn block_1451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1451_0: read-var gs#118192:u8
        let s_1451_0: bool = fn_state.gs_118192;
        // N s_1451_1: branch s_1451_0 b4864 b1452
        if s_1451_0 {
            return block_4864(state, tracer, fn_state);
        } else {
            return block_1452(state, tracer, fn_state);
        };
    }
    fn block_1452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1452_0: const #0u : u8
        let s_1452_0: bool = false;
        // D s_1452_1: write-var gs#118193 <= s_1452_0
        fn_state.gs_118193 = s_1452_0;
        // N s_1452_2: jump b1453
        return block_1453(state, tracer, fn_state);
    }
    fn block_1453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1453_0: read-var gs#118193:u8
        let s_1453_0: bool = fn_state.gs_118193;
        // N s_1453_1: branch s_1453_0 b4863 b1454
        if s_1453_0 {
            return block_4863(state, tracer, fn_state);
        } else {
            return block_1454(state, tracer, fn_state);
        };
    }
    fn block_1454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1454_0: const #0u : u8
        let s_1454_0: bool = false;
        // D s_1454_1: write-var gs#118194 <= s_1454_0
        fn_state.gs_118194 = s_1454_0;
        // N s_1454_2: jump b1455
        return block_1455(state, tracer, fn_state);
    }
    fn block_1455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1455_0: read-var gs#118194:u8
        let s_1455_0: bool = fn_state.gs_118194;
        // N s_1455_1: branch s_1455_0 b4862 b1456
        if s_1455_0 {
            return block_4862(state, tracer, fn_state);
        } else {
            return block_1456(state, tracer, fn_state);
        };
    }
    fn block_1456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1456_0: const #0u : u8
        let s_1456_0: bool = false;
        // D s_1456_1: write-var gs#118195 <= s_1456_0
        fn_state.gs_118195 = s_1456_0;
        // N s_1456_2: jump b1457
        return block_1457(state, tracer, fn_state);
    }
    fn block_1457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1457_0: read-var gs#118195:u8
        let s_1457_0: bool = fn_state.gs_118195;
        // N s_1457_1: branch s_1457_0 b4861 b1458
        if s_1457_0 {
            return block_4861(state, tracer, fn_state);
        } else {
            return block_1458(state, tracer, fn_state);
        };
    }
    fn block_1458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1458_0: read-var CRm:u8
        let s_1458_0: u8 = fn_state.CRm;
        // D s_1458_1: cast zx s_1458_0 -> bv
        let s_1458_1: Bits = Bits::new(s_1458_0 as u128, 4u16);
        // C s_1458_2: const #10u : u8
        let s_1458_2: u8 = 10;
        // C s_1458_3: cast zx s_1458_2 -> bv
        let s_1458_3: Bits = Bits::new(s_1458_2 as u128, 4u16);
        // D s_1458_4: cmp-eq s_1458_1 s_1458_3
        let s_1458_4: bool = ((s_1458_1) == (s_1458_3));
        // N s_1458_5: branch s_1458_4 b4860 b1459
        if s_1458_4 {
            return block_4860(state, tracer, fn_state);
        } else {
            return block_1459(state, tracer, fn_state);
        };
    }
    fn block_1459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1459_0: const #0u : u8
        let s_1459_0: bool = false;
        // D s_1459_1: write-var gs#118196 <= s_1459_0
        fn_state.gs_118196 = s_1459_0;
        // N s_1459_2: jump b1460
        return block_1460(state, tracer, fn_state);
    }
    fn block_1460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1460_0: read-var gs#118196:u8
        let s_1460_0: bool = fn_state.gs_118196;
        // N s_1460_1: branch s_1460_0 b4859 b1461
        if s_1460_0 {
            return block_4859(state, tracer, fn_state);
        } else {
            return block_1461(state, tracer, fn_state);
        };
    }
    fn block_1461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1461_0: const #0u : u8
        let s_1461_0: bool = false;
        // D s_1461_1: write-var gs#118197 <= s_1461_0
        fn_state.gs_118197 = s_1461_0;
        // N s_1461_2: jump b1462
        return block_1462(state, tracer, fn_state);
    }
    fn block_1462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1462_0: read-var gs#118197:u8
        let s_1462_0: bool = fn_state.gs_118197;
        // N s_1462_1: branch s_1462_0 b4858 b1463
        if s_1462_0 {
            return block_4858(state, tracer, fn_state);
        } else {
            return block_1463(state, tracer, fn_state);
        };
    }
    fn block_1463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1463_0: const #0u : u8
        let s_1463_0: bool = false;
        // D s_1463_1: write-var gs#118198 <= s_1463_0
        fn_state.gs_118198 = s_1463_0;
        // N s_1463_2: jump b1464
        return block_1464(state, tracer, fn_state);
    }
    fn block_1464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1464_0: read-var gs#118198:u8
        let s_1464_0: bool = fn_state.gs_118198;
        // N s_1464_1: branch s_1464_0 b4857 b1465
        if s_1464_0 {
            return block_4857(state, tracer, fn_state);
        } else {
            return block_1465(state, tracer, fn_state);
        };
    }
    fn block_1465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1465_0: const #0u : u8
        let s_1465_0: bool = false;
        // D s_1465_1: write-var gs#118199 <= s_1465_0
        fn_state.gs_118199 = s_1465_0;
        // N s_1465_2: jump b1466
        return block_1466(state, tracer, fn_state);
    }
    fn block_1466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1466_0: read-var gs#118199:u8
        let s_1466_0: bool = fn_state.gs_118199;
        // N s_1466_1: branch s_1466_0 b4856 b1467
        if s_1466_0 {
            return block_4856(state, tracer, fn_state);
        } else {
            return block_1467(state, tracer, fn_state);
        };
    }
    fn block_1467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1467_0: read-var CRm:u8
        let s_1467_0: u8 = fn_state.CRm;
        // D s_1467_1: cast zx s_1467_0 -> bv
        let s_1467_1: Bits = Bits::new(s_1467_0 as u128, 4u16);
        // C s_1467_2: const #10u : u8
        let s_1467_2: u8 = 10;
        // C s_1467_3: cast zx s_1467_2 -> bv
        let s_1467_3: Bits = Bits::new(s_1467_2 as u128, 4u16);
        // D s_1467_4: cmp-eq s_1467_1 s_1467_3
        let s_1467_4: bool = ((s_1467_1) == (s_1467_3));
        // N s_1467_5: branch s_1467_4 b4855 b1468
        if s_1467_4 {
            return block_4855(state, tracer, fn_state);
        } else {
            return block_1468(state, tracer, fn_state);
        };
    }
    fn block_1468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1468_0: const #0u : u8
        let s_1468_0: bool = false;
        // D s_1468_1: write-var gs#118200 <= s_1468_0
        fn_state.gs_118200 = s_1468_0;
        // N s_1468_2: jump b1469
        return block_1469(state, tracer, fn_state);
    }
    fn block_1469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1469_0: read-var gs#118200:u8
        let s_1469_0: bool = fn_state.gs_118200;
        // N s_1469_1: branch s_1469_0 b4854 b1470
        if s_1469_0 {
            return block_4854(state, tracer, fn_state);
        } else {
            return block_1470(state, tracer, fn_state);
        };
    }
    fn block_1470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1470_0: const #0u : u8
        let s_1470_0: bool = false;
        // D s_1470_1: write-var gs#118201 <= s_1470_0
        fn_state.gs_118201 = s_1470_0;
        // N s_1470_2: jump b1471
        return block_1471(state, tracer, fn_state);
    }
    fn block_1471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1471_0: read-var gs#118201:u8
        let s_1471_0: bool = fn_state.gs_118201;
        // N s_1471_1: branch s_1471_0 b4853 b1472
        if s_1471_0 {
            return block_4853(state, tracer, fn_state);
        } else {
            return block_1472(state, tracer, fn_state);
        };
    }
    fn block_1472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1472_0: const #0u : u8
        let s_1472_0: bool = false;
        // D s_1472_1: write-var gs#118202 <= s_1472_0
        fn_state.gs_118202 = s_1472_0;
        // N s_1472_2: jump b1473
        return block_1473(state, tracer, fn_state);
    }
    fn block_1473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1473_0: read-var gs#118202:u8
        let s_1473_0: bool = fn_state.gs_118202;
        // N s_1473_1: branch s_1473_0 b4852 b1474
        if s_1473_0 {
            return block_4852(state, tracer, fn_state);
        } else {
            return block_1474(state, tracer, fn_state);
        };
    }
    fn block_1474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1474_0: const #0u : u8
        let s_1474_0: bool = false;
        // D s_1474_1: write-var gs#118203 <= s_1474_0
        fn_state.gs_118203 = s_1474_0;
        // N s_1474_2: jump b1475
        return block_1475(state, tracer, fn_state);
    }
    fn block_1475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1475_0: read-var gs#118203:u8
        let s_1475_0: bool = fn_state.gs_118203;
        // N s_1475_1: branch s_1475_0 b4851 b1476
        if s_1475_0 {
            return block_4851(state, tracer, fn_state);
        } else {
            return block_1476(state, tracer, fn_state);
        };
    }
    fn block_1476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1476_0: read-var CRm:u8
        let s_1476_0: u8 = fn_state.CRm;
        // D s_1476_1: cast zx s_1476_0 -> bv
        let s_1476_1: Bits = Bits::new(s_1476_0 as u128, 4u16);
        // C s_1476_2: const #10u : u8
        let s_1476_2: u8 = 10;
        // C s_1476_3: cast zx s_1476_2 -> bv
        let s_1476_3: Bits = Bits::new(s_1476_2 as u128, 4u16);
        // D s_1476_4: cmp-eq s_1476_1 s_1476_3
        let s_1476_4: bool = ((s_1476_1) == (s_1476_3));
        // N s_1476_5: branch s_1476_4 b4850 b1477
        if s_1476_4 {
            return block_4850(state, tracer, fn_state);
        } else {
            return block_1477(state, tracer, fn_state);
        };
    }
    fn block_1477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1477_0: const #0u : u8
        let s_1477_0: bool = false;
        // D s_1477_1: write-var gs#118204 <= s_1477_0
        fn_state.gs_118204 = s_1477_0;
        // N s_1477_2: jump b1478
        return block_1478(state, tracer, fn_state);
    }
    fn block_1478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1478_0: read-var gs#118204:u8
        let s_1478_0: bool = fn_state.gs_118204;
        // N s_1478_1: branch s_1478_0 b4849 b1479
        if s_1478_0 {
            return block_4849(state, tracer, fn_state);
        } else {
            return block_1479(state, tracer, fn_state);
        };
    }
    fn block_1479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1479_0: const #0u : u8
        let s_1479_0: bool = false;
        // D s_1479_1: write-var gs#118205 <= s_1479_0
        fn_state.gs_118205 = s_1479_0;
        // N s_1479_2: jump b1480
        return block_1480(state, tracer, fn_state);
    }
    fn block_1480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1480_0: read-var gs#118205:u8
        let s_1480_0: bool = fn_state.gs_118205;
        // N s_1480_1: branch s_1480_0 b4848 b1481
        if s_1480_0 {
            return block_4848(state, tracer, fn_state);
        } else {
            return block_1481(state, tracer, fn_state);
        };
    }
    fn block_1481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1481_0: const #0u : u8
        let s_1481_0: bool = false;
        // D s_1481_1: write-var gs#118206 <= s_1481_0
        fn_state.gs_118206 = s_1481_0;
        // N s_1481_2: jump b1482
        return block_1482(state, tracer, fn_state);
    }
    fn block_1482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1482_0: read-var gs#118206:u8
        let s_1482_0: bool = fn_state.gs_118206;
        // N s_1482_1: branch s_1482_0 b4847 b1483
        if s_1482_0 {
            return block_4847(state, tracer, fn_state);
        } else {
            return block_1483(state, tracer, fn_state);
        };
    }
    fn block_1483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1483_0: const #0u : u8
        let s_1483_0: bool = false;
        // D s_1483_1: write-var gs#118207 <= s_1483_0
        fn_state.gs_118207 = s_1483_0;
        // N s_1483_2: jump b1484
        return block_1484(state, tracer, fn_state);
    }
    fn block_1484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1484_0: read-var gs#118207:u8
        let s_1484_0: bool = fn_state.gs_118207;
        // N s_1484_1: branch s_1484_0 b4846 b1485
        if s_1484_0 {
            return block_4846(state, tracer, fn_state);
        } else {
            return block_1485(state, tracer, fn_state);
        };
    }
    fn block_1485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1485_0: read-var CRm:u8
        let s_1485_0: u8 = fn_state.CRm;
        // D s_1485_1: cast zx s_1485_0 -> bv
        let s_1485_1: Bits = Bits::new(s_1485_0 as u128, 4u16);
        // C s_1485_2: const #10u : u8
        let s_1485_2: u8 = 10;
        // C s_1485_3: cast zx s_1485_2 -> bv
        let s_1485_3: Bits = Bits::new(s_1485_2 as u128, 4u16);
        // D s_1485_4: cmp-eq s_1485_1 s_1485_3
        let s_1485_4: bool = ((s_1485_1) == (s_1485_3));
        // N s_1485_5: branch s_1485_4 b4845 b1486
        if s_1485_4 {
            return block_4845(state, tracer, fn_state);
        } else {
            return block_1486(state, tracer, fn_state);
        };
    }
    fn block_1486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1486_0: const #0u : u8
        let s_1486_0: bool = false;
        // D s_1486_1: write-var gs#118208 <= s_1486_0
        fn_state.gs_118208 = s_1486_0;
        // N s_1486_2: jump b1487
        return block_1487(state, tracer, fn_state);
    }
    fn block_1487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1487_0: read-var gs#118208:u8
        let s_1487_0: bool = fn_state.gs_118208;
        // N s_1487_1: branch s_1487_0 b4844 b1488
        if s_1487_0 {
            return block_4844(state, tracer, fn_state);
        } else {
            return block_1488(state, tracer, fn_state);
        };
    }
    fn block_1488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1488_0: const #0u : u8
        let s_1488_0: bool = false;
        // D s_1488_1: write-var gs#118209 <= s_1488_0
        fn_state.gs_118209 = s_1488_0;
        // N s_1488_2: jump b1489
        return block_1489(state, tracer, fn_state);
    }
    fn block_1489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1489_0: read-var gs#118209:u8
        let s_1489_0: bool = fn_state.gs_118209;
        // N s_1489_1: branch s_1489_0 b4843 b1490
        if s_1489_0 {
            return block_4843(state, tracer, fn_state);
        } else {
            return block_1490(state, tracer, fn_state);
        };
    }
    fn block_1490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1490_0: const #0u : u8
        let s_1490_0: bool = false;
        // D s_1490_1: write-var gs#118210 <= s_1490_0
        fn_state.gs_118210 = s_1490_0;
        // N s_1490_2: jump b1491
        return block_1491(state, tracer, fn_state);
    }
    fn block_1491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1491_0: read-var gs#118210:u8
        let s_1491_0: bool = fn_state.gs_118210;
        // N s_1491_1: branch s_1491_0 b4842 b1492
        if s_1491_0 {
            return block_4842(state, tracer, fn_state);
        } else {
            return block_1492(state, tracer, fn_state);
        };
    }
    fn block_1492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1492_0: const #0u : u8
        let s_1492_0: bool = false;
        // D s_1492_1: write-var gs#118211 <= s_1492_0
        fn_state.gs_118211 = s_1492_0;
        // N s_1492_2: jump b1493
        return block_1493(state, tracer, fn_state);
    }
    fn block_1493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1493_0: read-var gs#118211:u8
        let s_1493_0: bool = fn_state.gs_118211;
        // N s_1493_1: branch s_1493_0 b4841 b1494
        if s_1493_0 {
            return block_4841(state, tracer, fn_state);
        } else {
            return block_1494(state, tracer, fn_state);
        };
    }
    fn block_1494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1494_0: read-var CRm:u8
        let s_1494_0: u8 = fn_state.CRm;
        // D s_1494_1: cast zx s_1494_0 -> bv
        let s_1494_1: Bits = Bits::new(s_1494_0 as u128, 4u16);
        // C s_1494_2: const #10u : u8
        let s_1494_2: u8 = 10;
        // C s_1494_3: cast zx s_1494_2 -> bv
        let s_1494_3: Bits = Bits::new(s_1494_2 as u128, 4u16);
        // D s_1494_4: cmp-eq s_1494_1 s_1494_3
        let s_1494_4: bool = ((s_1494_1) == (s_1494_3));
        // N s_1494_5: branch s_1494_4 b4840 b1495
        if s_1494_4 {
            return block_4840(state, tracer, fn_state);
        } else {
            return block_1495(state, tracer, fn_state);
        };
    }
    fn block_1495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1495_0: const #0u : u8
        let s_1495_0: bool = false;
        // D s_1495_1: write-var gs#118212 <= s_1495_0
        fn_state.gs_118212 = s_1495_0;
        // N s_1495_2: jump b1496
        return block_1496(state, tracer, fn_state);
    }
    fn block_1496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1496_0: read-var gs#118212:u8
        let s_1496_0: bool = fn_state.gs_118212;
        // N s_1496_1: branch s_1496_0 b4839 b1497
        if s_1496_0 {
            return block_4839(state, tracer, fn_state);
        } else {
            return block_1497(state, tracer, fn_state);
        };
    }
    fn block_1497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1497_0: const #0u : u8
        let s_1497_0: bool = false;
        // D s_1497_1: write-var gs#118213 <= s_1497_0
        fn_state.gs_118213 = s_1497_0;
        // N s_1497_2: jump b1498
        return block_1498(state, tracer, fn_state);
    }
    fn block_1498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1498_0: read-var gs#118213:u8
        let s_1498_0: bool = fn_state.gs_118213;
        // N s_1498_1: branch s_1498_0 b4838 b1499
        if s_1498_0 {
            return block_4838(state, tracer, fn_state);
        } else {
            return block_1499(state, tracer, fn_state);
        };
    }
    fn block_1499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1499_0: const #0u : u8
        let s_1499_0: bool = false;
        // D s_1499_1: write-var gs#118214 <= s_1499_0
        fn_state.gs_118214 = s_1499_0;
        // N s_1499_2: jump b1500
        return block_1500(state, tracer, fn_state);
    }
    fn block_1500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1500_0: read-var gs#118214:u8
        let s_1500_0: bool = fn_state.gs_118214;
        // N s_1500_1: branch s_1500_0 b4837 b1501
        if s_1500_0 {
            return block_4837(state, tracer, fn_state);
        } else {
            return block_1501(state, tracer, fn_state);
        };
    }
    fn block_1501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1501_0: const #0u : u8
        let s_1501_0: bool = false;
        // D s_1501_1: write-var gs#118215 <= s_1501_0
        fn_state.gs_118215 = s_1501_0;
        // N s_1501_2: jump b1502
        return block_1502(state, tracer, fn_state);
    }
    fn block_1502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1502_0: read-var gs#118215:u8
        let s_1502_0: bool = fn_state.gs_118215;
        // N s_1502_1: branch s_1502_0 b4836 b1503
        if s_1502_0 {
            return block_4836(state, tracer, fn_state);
        } else {
            return block_1503(state, tracer, fn_state);
        };
    }
    fn block_1503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1503_0: read-var CRm:u8
        let s_1503_0: u8 = fn_state.CRm;
        // D s_1503_1: cast zx s_1503_0 -> bv
        let s_1503_1: Bits = Bits::new(s_1503_0 as u128, 4u16);
        // C s_1503_2: const #10u : u8
        let s_1503_2: u8 = 10;
        // C s_1503_3: cast zx s_1503_2 -> bv
        let s_1503_3: Bits = Bits::new(s_1503_2 as u128, 4u16);
        // D s_1503_4: cmp-eq s_1503_1 s_1503_3
        let s_1503_4: bool = ((s_1503_1) == (s_1503_3));
        // N s_1503_5: branch s_1503_4 b4835 b1504
        if s_1503_4 {
            return block_4835(state, tracer, fn_state);
        } else {
            return block_1504(state, tracer, fn_state);
        };
    }
    fn block_1504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1504_0: const #0u : u8
        let s_1504_0: bool = false;
        // D s_1504_1: write-var gs#118216 <= s_1504_0
        fn_state.gs_118216 = s_1504_0;
        // N s_1504_2: jump b1505
        return block_1505(state, tracer, fn_state);
    }
    fn block_1505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1505_0: read-var gs#118216:u8
        let s_1505_0: bool = fn_state.gs_118216;
        // N s_1505_1: branch s_1505_0 b4834 b1506
        if s_1505_0 {
            return block_4834(state, tracer, fn_state);
        } else {
            return block_1506(state, tracer, fn_state);
        };
    }
    fn block_1506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1506_0: const #0u : u8
        let s_1506_0: bool = false;
        // D s_1506_1: write-var gs#118217 <= s_1506_0
        fn_state.gs_118217 = s_1506_0;
        // N s_1506_2: jump b1507
        return block_1507(state, tracer, fn_state);
    }
    fn block_1507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1507_0: read-var gs#118217:u8
        let s_1507_0: bool = fn_state.gs_118217;
        // N s_1507_1: branch s_1507_0 b4833 b1508
        if s_1507_0 {
            return block_4833(state, tracer, fn_state);
        } else {
            return block_1508(state, tracer, fn_state);
        };
    }
    fn block_1508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1508_0: const #0u : u8
        let s_1508_0: bool = false;
        // D s_1508_1: write-var gs#118218 <= s_1508_0
        fn_state.gs_118218 = s_1508_0;
        // N s_1508_2: jump b1509
        return block_1509(state, tracer, fn_state);
    }
    fn block_1509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1509_0: read-var gs#118218:u8
        let s_1509_0: bool = fn_state.gs_118218;
        // N s_1509_1: branch s_1509_0 b4832 b1510
        if s_1509_0 {
            return block_4832(state, tracer, fn_state);
        } else {
            return block_1510(state, tracer, fn_state);
        };
    }
    fn block_1510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1510_0: const #0u : u8
        let s_1510_0: bool = false;
        // D s_1510_1: write-var gs#118219 <= s_1510_0
        fn_state.gs_118219 = s_1510_0;
        // N s_1510_2: jump b1511
        return block_1511(state, tracer, fn_state);
    }
    fn block_1511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1511_0: read-var gs#118219:u8
        let s_1511_0: bool = fn_state.gs_118219;
        // N s_1511_1: branch s_1511_0 b4831 b1512
        if s_1511_0 {
            return block_4831(state, tracer, fn_state);
        } else {
            return block_1512(state, tracer, fn_state);
        };
    }
    fn block_1512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1512_0: read-var CRm:u8
        let s_1512_0: u8 = fn_state.CRm;
        // D s_1512_1: cast zx s_1512_0 -> bv
        let s_1512_1: Bits = Bits::new(s_1512_0 as u128, 4u16);
        // C s_1512_2: const #10u : u8
        let s_1512_2: u8 = 10;
        // C s_1512_3: cast zx s_1512_2 -> bv
        let s_1512_3: Bits = Bits::new(s_1512_2 as u128, 4u16);
        // D s_1512_4: cmp-eq s_1512_1 s_1512_3
        let s_1512_4: bool = ((s_1512_1) == (s_1512_3));
        // N s_1512_5: branch s_1512_4 b4830 b1513
        if s_1512_4 {
            return block_4830(state, tracer, fn_state);
        } else {
            return block_1513(state, tracer, fn_state);
        };
    }
    fn block_1513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1513_0: const #0u : u8
        let s_1513_0: bool = false;
        // D s_1513_1: write-var gs#118220 <= s_1513_0
        fn_state.gs_118220 = s_1513_0;
        // N s_1513_2: jump b1514
        return block_1514(state, tracer, fn_state);
    }
    fn block_1514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1514_0: read-var gs#118220:u8
        let s_1514_0: bool = fn_state.gs_118220;
        // N s_1514_1: branch s_1514_0 b4829 b1515
        if s_1514_0 {
            return block_4829(state, tracer, fn_state);
        } else {
            return block_1515(state, tracer, fn_state);
        };
    }
    fn block_1515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1515_0: const #0u : u8
        let s_1515_0: bool = false;
        // D s_1515_1: write-var gs#118221 <= s_1515_0
        fn_state.gs_118221 = s_1515_0;
        // N s_1515_2: jump b1516
        return block_1516(state, tracer, fn_state);
    }
    fn block_1516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1516_0: read-var gs#118221:u8
        let s_1516_0: bool = fn_state.gs_118221;
        // N s_1516_1: branch s_1516_0 b4828 b1517
        if s_1516_0 {
            return block_4828(state, tracer, fn_state);
        } else {
            return block_1517(state, tracer, fn_state);
        };
    }
    fn block_1517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1517_0: const #0u : u8
        let s_1517_0: bool = false;
        // D s_1517_1: write-var gs#118222 <= s_1517_0
        fn_state.gs_118222 = s_1517_0;
        // N s_1517_2: jump b1518
        return block_1518(state, tracer, fn_state);
    }
    fn block_1518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1518_0: read-var gs#118222:u8
        let s_1518_0: bool = fn_state.gs_118222;
        // N s_1518_1: branch s_1518_0 b4827 b1519
        if s_1518_0 {
            return block_4827(state, tracer, fn_state);
        } else {
            return block_1519(state, tracer, fn_state);
        };
    }
    fn block_1519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1519_0: const #0u : u8
        let s_1519_0: bool = false;
        // D s_1519_1: write-var gs#118223 <= s_1519_0
        fn_state.gs_118223 = s_1519_0;
        // N s_1519_2: jump b1520
        return block_1520(state, tracer, fn_state);
    }
    fn block_1520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1520_0: read-var gs#118223:u8
        let s_1520_0: bool = fn_state.gs_118223;
        // N s_1520_1: branch s_1520_0 b4826 b1521
        if s_1520_0 {
            return block_4826(state, tracer, fn_state);
        } else {
            return block_1521(state, tracer, fn_state);
        };
    }
    fn block_1521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1521_0: read-var CRm:u8
        let s_1521_0: u8 = fn_state.CRm;
        // D s_1521_1: cast zx s_1521_0 -> bv
        let s_1521_1: Bits = Bits::new(s_1521_0 as u128, 4u16);
        // C s_1521_2: const #10u : u8
        let s_1521_2: u8 = 10;
        // C s_1521_3: cast zx s_1521_2 -> bv
        let s_1521_3: Bits = Bits::new(s_1521_2 as u128, 4u16);
        // D s_1521_4: cmp-eq s_1521_1 s_1521_3
        let s_1521_4: bool = ((s_1521_1) == (s_1521_3));
        // N s_1521_5: branch s_1521_4 b4825 b1522
        if s_1521_4 {
            return block_4825(state, tracer, fn_state);
        } else {
            return block_1522(state, tracer, fn_state);
        };
    }
    fn block_1522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1522_0: const #0u : u8
        let s_1522_0: bool = false;
        // D s_1522_1: write-var gs#118224 <= s_1522_0
        fn_state.gs_118224 = s_1522_0;
        // N s_1522_2: jump b1523
        return block_1523(state, tracer, fn_state);
    }
    fn block_1523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1523_0: read-var gs#118224:u8
        let s_1523_0: bool = fn_state.gs_118224;
        // N s_1523_1: branch s_1523_0 b4824 b1524
        if s_1523_0 {
            return block_4824(state, tracer, fn_state);
        } else {
            return block_1524(state, tracer, fn_state);
        };
    }
    fn block_1524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1524_0: const #0u : u8
        let s_1524_0: bool = false;
        // D s_1524_1: write-var gs#118225 <= s_1524_0
        fn_state.gs_118225 = s_1524_0;
        // N s_1524_2: jump b1525
        return block_1525(state, tracer, fn_state);
    }
    fn block_1525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1525_0: read-var gs#118225:u8
        let s_1525_0: bool = fn_state.gs_118225;
        // N s_1525_1: branch s_1525_0 b4823 b1526
        if s_1525_0 {
            return block_4823(state, tracer, fn_state);
        } else {
            return block_1526(state, tracer, fn_state);
        };
    }
    fn block_1526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1526_0: const #0u : u8
        let s_1526_0: bool = false;
        // D s_1526_1: write-var gs#118226 <= s_1526_0
        fn_state.gs_118226 = s_1526_0;
        // N s_1526_2: jump b1527
        return block_1527(state, tracer, fn_state);
    }
    fn block_1527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1527_0: read-var gs#118226:u8
        let s_1527_0: bool = fn_state.gs_118226;
        // N s_1527_1: branch s_1527_0 b4822 b1528
        if s_1527_0 {
            return block_4822(state, tracer, fn_state);
        } else {
            return block_1528(state, tracer, fn_state);
        };
    }
    fn block_1528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1528_0: const #0u : u8
        let s_1528_0: bool = false;
        // D s_1528_1: write-var gs#118227 <= s_1528_0
        fn_state.gs_118227 = s_1528_0;
        // N s_1528_2: jump b1529
        return block_1529(state, tracer, fn_state);
    }
    fn block_1529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1529_0: read-var gs#118227:u8
        let s_1529_0: bool = fn_state.gs_118227;
        // N s_1529_1: branch s_1529_0 b4821 b1530
        if s_1529_0 {
            return block_4821(state, tracer, fn_state);
        } else {
            return block_1530(state, tracer, fn_state);
        };
    }
    fn block_1530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1530_0: read-var CRm:u8
        let s_1530_0: u8 = fn_state.CRm;
        // D s_1530_1: cast zx s_1530_0 -> bv
        let s_1530_1: Bits = Bits::new(s_1530_0 as u128, 4u16);
        // C s_1530_2: const #9u : u8
        let s_1530_2: u8 = 9;
        // C s_1530_3: cast zx s_1530_2 -> bv
        let s_1530_3: Bits = Bits::new(s_1530_2 as u128, 4u16);
        // D s_1530_4: cmp-eq s_1530_1 s_1530_3
        let s_1530_4: bool = ((s_1530_1) == (s_1530_3));
        // N s_1530_5: branch s_1530_4 b4820 b1531
        if s_1530_4 {
            return block_4820(state, tracer, fn_state);
        } else {
            return block_1531(state, tracer, fn_state);
        };
    }
    fn block_1531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1531_0: const #0u : u8
        let s_1531_0: bool = false;
        // D s_1531_1: write-var gs#118228 <= s_1531_0
        fn_state.gs_118228 = s_1531_0;
        // N s_1531_2: jump b1532
        return block_1532(state, tracer, fn_state);
    }
    fn block_1532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1532_0: read-var gs#118228:u8
        let s_1532_0: bool = fn_state.gs_118228;
        // N s_1532_1: branch s_1532_0 b4819 b1533
        if s_1532_0 {
            return block_4819(state, tracer, fn_state);
        } else {
            return block_1533(state, tracer, fn_state);
        };
    }
    fn block_1533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1533_0: const #0u : u8
        let s_1533_0: bool = false;
        // D s_1533_1: write-var gs#118229 <= s_1533_0
        fn_state.gs_118229 = s_1533_0;
        // N s_1533_2: jump b1534
        return block_1534(state, tracer, fn_state);
    }
    fn block_1534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1534_0: read-var gs#118229:u8
        let s_1534_0: bool = fn_state.gs_118229;
        // N s_1534_1: branch s_1534_0 b4818 b1535
        if s_1534_0 {
            return block_4818(state, tracer, fn_state);
        } else {
            return block_1535(state, tracer, fn_state);
        };
    }
    fn block_1535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1535_0: const #0u : u8
        let s_1535_0: bool = false;
        // D s_1535_1: write-var gs#118230 <= s_1535_0
        fn_state.gs_118230 = s_1535_0;
        // N s_1535_2: jump b1536
        return block_1536(state, tracer, fn_state);
    }
    fn block_1536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1536_0: read-var gs#118230:u8
        let s_1536_0: bool = fn_state.gs_118230;
        // N s_1536_1: branch s_1536_0 b4817 b1537
        if s_1536_0 {
            return block_4817(state, tracer, fn_state);
        } else {
            return block_1537(state, tracer, fn_state);
        };
    }
    fn block_1537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1537_0: const #0u : u8
        let s_1537_0: bool = false;
        // D s_1537_1: write-var gs#118231 <= s_1537_0
        fn_state.gs_118231 = s_1537_0;
        // N s_1537_2: jump b1538
        return block_1538(state, tracer, fn_state);
    }
    fn block_1538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1538_0: read-var gs#118231:u8
        let s_1538_0: bool = fn_state.gs_118231;
        // N s_1538_1: branch s_1538_0 b4816 b1539
        if s_1538_0 {
            return block_4816(state, tracer, fn_state);
        } else {
            return block_1539(state, tracer, fn_state);
        };
    }
    fn block_1539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1539_0: read-var CRm:u8
        let s_1539_0: u8 = fn_state.CRm;
        // D s_1539_1: cast zx s_1539_0 -> bv
        let s_1539_1: Bits = Bits::new(s_1539_0 as u128, 4u16);
        // C s_1539_2: const #9u : u8
        let s_1539_2: u8 = 9;
        // C s_1539_3: cast zx s_1539_2 -> bv
        let s_1539_3: Bits = Bits::new(s_1539_2 as u128, 4u16);
        // D s_1539_4: cmp-eq s_1539_1 s_1539_3
        let s_1539_4: bool = ((s_1539_1) == (s_1539_3));
        // N s_1539_5: branch s_1539_4 b4815 b1540
        if s_1539_4 {
            return block_4815(state, tracer, fn_state);
        } else {
            return block_1540(state, tracer, fn_state);
        };
    }
    fn block_1540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1540_0: const #0u : u8
        let s_1540_0: bool = false;
        // D s_1540_1: write-var gs#118232 <= s_1540_0
        fn_state.gs_118232 = s_1540_0;
        // N s_1540_2: jump b1541
        return block_1541(state, tracer, fn_state);
    }
    fn block_1541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1541_0: read-var gs#118232:u8
        let s_1541_0: bool = fn_state.gs_118232;
        // N s_1541_1: branch s_1541_0 b4814 b1542
        if s_1541_0 {
            return block_4814(state, tracer, fn_state);
        } else {
            return block_1542(state, tracer, fn_state);
        };
    }
    fn block_1542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1542_0: const #0u : u8
        let s_1542_0: bool = false;
        // D s_1542_1: write-var gs#118233 <= s_1542_0
        fn_state.gs_118233 = s_1542_0;
        // N s_1542_2: jump b1543
        return block_1543(state, tracer, fn_state);
    }
    fn block_1543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1543_0: read-var gs#118233:u8
        let s_1543_0: bool = fn_state.gs_118233;
        // N s_1543_1: branch s_1543_0 b4813 b1544
        if s_1543_0 {
            return block_4813(state, tracer, fn_state);
        } else {
            return block_1544(state, tracer, fn_state);
        };
    }
    fn block_1544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1544_0: const #0u : u8
        let s_1544_0: bool = false;
        // D s_1544_1: write-var gs#118234 <= s_1544_0
        fn_state.gs_118234 = s_1544_0;
        // N s_1544_2: jump b1545
        return block_1545(state, tracer, fn_state);
    }
    fn block_1545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1545_0: read-var gs#118234:u8
        let s_1545_0: bool = fn_state.gs_118234;
        // N s_1545_1: branch s_1545_0 b4812 b1546
        if s_1545_0 {
            return block_4812(state, tracer, fn_state);
        } else {
            return block_1546(state, tracer, fn_state);
        };
    }
    fn block_1546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1546_0: const #0u : u8
        let s_1546_0: bool = false;
        // D s_1546_1: write-var gs#118235 <= s_1546_0
        fn_state.gs_118235 = s_1546_0;
        // N s_1546_2: jump b1547
        return block_1547(state, tracer, fn_state);
    }
    fn block_1547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1547_0: read-var gs#118235:u8
        let s_1547_0: bool = fn_state.gs_118235;
        // N s_1547_1: branch s_1547_0 b4811 b1548
        if s_1547_0 {
            return block_4811(state, tracer, fn_state);
        } else {
            return block_1548(state, tracer, fn_state);
        };
    }
    fn block_1548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1548_0: read-var CRm:u8
        let s_1548_0: u8 = fn_state.CRm;
        // D s_1548_1: cast zx s_1548_0 -> bv
        let s_1548_1: Bits = Bits::new(s_1548_0 as u128, 4u16);
        // C s_1548_2: const #9u : u8
        let s_1548_2: u8 = 9;
        // C s_1548_3: cast zx s_1548_2 -> bv
        let s_1548_3: Bits = Bits::new(s_1548_2 as u128, 4u16);
        // D s_1548_4: cmp-eq s_1548_1 s_1548_3
        let s_1548_4: bool = ((s_1548_1) == (s_1548_3));
        // N s_1548_5: branch s_1548_4 b4810 b1549
        if s_1548_4 {
            return block_4810(state, tracer, fn_state);
        } else {
            return block_1549(state, tracer, fn_state);
        };
    }
    fn block_1549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1549_0: const #0u : u8
        let s_1549_0: bool = false;
        // D s_1549_1: write-var gs#118236 <= s_1549_0
        fn_state.gs_118236 = s_1549_0;
        // N s_1549_2: jump b1550
        return block_1550(state, tracer, fn_state);
    }
    fn block_1550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1550_0: read-var gs#118236:u8
        let s_1550_0: bool = fn_state.gs_118236;
        // N s_1550_1: branch s_1550_0 b4809 b1551
        if s_1550_0 {
            return block_4809(state, tracer, fn_state);
        } else {
            return block_1551(state, tracer, fn_state);
        };
    }
    fn block_1551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1551_0: const #0u : u8
        let s_1551_0: bool = false;
        // D s_1551_1: write-var gs#118237 <= s_1551_0
        fn_state.gs_118237 = s_1551_0;
        // N s_1551_2: jump b1552
        return block_1552(state, tracer, fn_state);
    }
    fn block_1552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1552_0: read-var gs#118237:u8
        let s_1552_0: bool = fn_state.gs_118237;
        // N s_1552_1: branch s_1552_0 b4808 b1553
        if s_1552_0 {
            return block_4808(state, tracer, fn_state);
        } else {
            return block_1553(state, tracer, fn_state);
        };
    }
    fn block_1553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1553_0: const #0u : u8
        let s_1553_0: bool = false;
        // D s_1553_1: write-var gs#118238 <= s_1553_0
        fn_state.gs_118238 = s_1553_0;
        // N s_1553_2: jump b1554
        return block_1554(state, tracer, fn_state);
    }
    fn block_1554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1554_0: read-var gs#118238:u8
        let s_1554_0: bool = fn_state.gs_118238;
        // N s_1554_1: branch s_1554_0 b4807 b1555
        if s_1554_0 {
            return block_4807(state, tracer, fn_state);
        } else {
            return block_1555(state, tracer, fn_state);
        };
    }
    fn block_1555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1555_0: const #0u : u8
        let s_1555_0: bool = false;
        // D s_1555_1: write-var gs#118239 <= s_1555_0
        fn_state.gs_118239 = s_1555_0;
        // N s_1555_2: jump b1556
        return block_1556(state, tracer, fn_state);
    }
    fn block_1556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1556_0: read-var gs#118239:u8
        let s_1556_0: bool = fn_state.gs_118239;
        // N s_1556_1: branch s_1556_0 b4806 b1557
        if s_1556_0 {
            return block_4806(state, tracer, fn_state);
        } else {
            return block_1557(state, tracer, fn_state);
        };
    }
    fn block_1557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1557_0: read-var CRm:u8
        let s_1557_0: u8 = fn_state.CRm;
        // D s_1557_1: cast zx s_1557_0 -> bv
        let s_1557_1: Bits = Bits::new(s_1557_0 as u128, 4u16);
        // C s_1557_2: const #9u : u8
        let s_1557_2: u8 = 9;
        // C s_1557_3: cast zx s_1557_2 -> bv
        let s_1557_3: Bits = Bits::new(s_1557_2 as u128, 4u16);
        // D s_1557_4: cmp-eq s_1557_1 s_1557_3
        let s_1557_4: bool = ((s_1557_1) == (s_1557_3));
        // N s_1557_5: branch s_1557_4 b4805 b1558
        if s_1557_4 {
            return block_4805(state, tracer, fn_state);
        } else {
            return block_1558(state, tracer, fn_state);
        };
    }
    fn block_1558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1558_0: const #0u : u8
        let s_1558_0: bool = false;
        // D s_1558_1: write-var gs#118240 <= s_1558_0
        fn_state.gs_118240 = s_1558_0;
        // N s_1558_2: jump b1559
        return block_1559(state, tracer, fn_state);
    }
    fn block_1559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1559_0: read-var gs#118240:u8
        let s_1559_0: bool = fn_state.gs_118240;
        // N s_1559_1: branch s_1559_0 b4804 b1560
        if s_1559_0 {
            return block_4804(state, tracer, fn_state);
        } else {
            return block_1560(state, tracer, fn_state);
        };
    }
    fn block_1560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1560_0: const #0u : u8
        let s_1560_0: bool = false;
        // D s_1560_1: write-var gs#118241 <= s_1560_0
        fn_state.gs_118241 = s_1560_0;
        // N s_1560_2: jump b1561
        return block_1561(state, tracer, fn_state);
    }
    fn block_1561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1561_0: read-var gs#118241:u8
        let s_1561_0: bool = fn_state.gs_118241;
        // N s_1561_1: branch s_1561_0 b4803 b1562
        if s_1561_0 {
            return block_4803(state, tracer, fn_state);
        } else {
            return block_1562(state, tracer, fn_state);
        };
    }
    fn block_1562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1562_0: const #0u : u8
        let s_1562_0: bool = false;
        // D s_1562_1: write-var gs#118242 <= s_1562_0
        fn_state.gs_118242 = s_1562_0;
        // N s_1562_2: jump b1563
        return block_1563(state, tracer, fn_state);
    }
    fn block_1563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1563_0: read-var gs#118242:u8
        let s_1563_0: bool = fn_state.gs_118242;
        // N s_1563_1: branch s_1563_0 b4802 b1564
        if s_1563_0 {
            return block_4802(state, tracer, fn_state);
        } else {
            return block_1564(state, tracer, fn_state);
        };
    }
    fn block_1564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1564_0: const #0u : u8
        let s_1564_0: bool = false;
        // D s_1564_1: write-var gs#118243 <= s_1564_0
        fn_state.gs_118243 = s_1564_0;
        // N s_1564_2: jump b1565
        return block_1565(state, tracer, fn_state);
    }
    fn block_1565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1565_0: read-var gs#118243:u8
        let s_1565_0: bool = fn_state.gs_118243;
        // N s_1565_1: branch s_1565_0 b4801 b1566
        if s_1565_0 {
            return block_4801(state, tracer, fn_state);
        } else {
            return block_1566(state, tracer, fn_state);
        };
    }
    fn block_1566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1566_0: read-var CRm:u8
        let s_1566_0: u8 = fn_state.CRm;
        // D s_1566_1: cast zx s_1566_0 -> bv
        let s_1566_1: Bits = Bits::new(s_1566_0 as u128, 4u16);
        // C s_1566_2: const #9u : u8
        let s_1566_2: u8 = 9;
        // C s_1566_3: cast zx s_1566_2 -> bv
        let s_1566_3: Bits = Bits::new(s_1566_2 as u128, 4u16);
        // D s_1566_4: cmp-eq s_1566_1 s_1566_3
        let s_1566_4: bool = ((s_1566_1) == (s_1566_3));
        // N s_1566_5: branch s_1566_4 b4800 b1567
        if s_1566_4 {
            return block_4800(state, tracer, fn_state);
        } else {
            return block_1567(state, tracer, fn_state);
        };
    }
    fn block_1567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1567_0: const #0u : u8
        let s_1567_0: bool = false;
        // D s_1567_1: write-var gs#118244 <= s_1567_0
        fn_state.gs_118244 = s_1567_0;
        // N s_1567_2: jump b1568
        return block_1568(state, tracer, fn_state);
    }
    fn block_1568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1568_0: read-var gs#118244:u8
        let s_1568_0: bool = fn_state.gs_118244;
        // N s_1568_1: branch s_1568_0 b4799 b1569
        if s_1568_0 {
            return block_4799(state, tracer, fn_state);
        } else {
            return block_1569(state, tracer, fn_state);
        };
    }
    fn block_1569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1569_0: const #0u : u8
        let s_1569_0: bool = false;
        // D s_1569_1: write-var gs#118245 <= s_1569_0
        fn_state.gs_118245 = s_1569_0;
        // N s_1569_2: jump b1570
        return block_1570(state, tracer, fn_state);
    }
    fn block_1570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1570_0: read-var gs#118245:u8
        let s_1570_0: bool = fn_state.gs_118245;
        // N s_1570_1: branch s_1570_0 b4798 b1571
        if s_1570_0 {
            return block_4798(state, tracer, fn_state);
        } else {
            return block_1571(state, tracer, fn_state);
        };
    }
    fn block_1571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1571_0: const #0u : u8
        let s_1571_0: bool = false;
        // D s_1571_1: write-var gs#118246 <= s_1571_0
        fn_state.gs_118246 = s_1571_0;
        // N s_1571_2: jump b1572
        return block_1572(state, tracer, fn_state);
    }
    fn block_1572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1572_0: read-var gs#118246:u8
        let s_1572_0: bool = fn_state.gs_118246;
        // N s_1572_1: branch s_1572_0 b4797 b1573
        if s_1572_0 {
            return block_4797(state, tracer, fn_state);
        } else {
            return block_1573(state, tracer, fn_state);
        };
    }
    fn block_1573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1573_0: const #0u : u8
        let s_1573_0: bool = false;
        // D s_1573_1: write-var gs#118247 <= s_1573_0
        fn_state.gs_118247 = s_1573_0;
        // N s_1573_2: jump b1574
        return block_1574(state, tracer, fn_state);
    }
    fn block_1574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1574_0: read-var gs#118247:u8
        let s_1574_0: bool = fn_state.gs_118247;
        // N s_1574_1: branch s_1574_0 b4796 b1575
        if s_1574_0 {
            return block_4796(state, tracer, fn_state);
        } else {
            return block_1575(state, tracer, fn_state);
        };
    }
    fn block_1575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1575_0: read-var CRm:u8
        let s_1575_0: u8 = fn_state.CRm;
        // D s_1575_1: cast zx s_1575_0 -> bv
        let s_1575_1: Bits = Bits::new(s_1575_0 as u128, 4u16);
        // C s_1575_2: const #9u : u8
        let s_1575_2: u8 = 9;
        // C s_1575_3: cast zx s_1575_2 -> bv
        let s_1575_3: Bits = Bits::new(s_1575_2 as u128, 4u16);
        // D s_1575_4: cmp-eq s_1575_1 s_1575_3
        let s_1575_4: bool = ((s_1575_1) == (s_1575_3));
        // N s_1575_5: branch s_1575_4 b4795 b1576
        if s_1575_4 {
            return block_4795(state, tracer, fn_state);
        } else {
            return block_1576(state, tracer, fn_state);
        };
    }
    fn block_1576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1576_0: const #0u : u8
        let s_1576_0: bool = false;
        // D s_1576_1: write-var gs#118248 <= s_1576_0
        fn_state.gs_118248 = s_1576_0;
        // N s_1576_2: jump b1577
        return block_1577(state, tracer, fn_state);
    }
    fn block_1577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1577_0: read-var gs#118248:u8
        let s_1577_0: bool = fn_state.gs_118248;
        // N s_1577_1: branch s_1577_0 b4794 b1578
        if s_1577_0 {
            return block_4794(state, tracer, fn_state);
        } else {
            return block_1578(state, tracer, fn_state);
        };
    }
    fn block_1578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1578_0: const #0u : u8
        let s_1578_0: bool = false;
        // D s_1578_1: write-var gs#118249 <= s_1578_0
        fn_state.gs_118249 = s_1578_0;
        // N s_1578_2: jump b1579
        return block_1579(state, tracer, fn_state);
    }
    fn block_1579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1579_0: read-var gs#118249:u8
        let s_1579_0: bool = fn_state.gs_118249;
        // N s_1579_1: branch s_1579_0 b4793 b1580
        if s_1579_0 {
            return block_4793(state, tracer, fn_state);
        } else {
            return block_1580(state, tracer, fn_state);
        };
    }
    fn block_1580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1580_0: const #0u : u8
        let s_1580_0: bool = false;
        // D s_1580_1: write-var gs#118250 <= s_1580_0
        fn_state.gs_118250 = s_1580_0;
        // N s_1580_2: jump b1581
        return block_1581(state, tracer, fn_state);
    }
    fn block_1581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1581_0: read-var gs#118250:u8
        let s_1581_0: bool = fn_state.gs_118250;
        // N s_1581_1: branch s_1581_0 b4792 b1582
        if s_1581_0 {
            return block_4792(state, tracer, fn_state);
        } else {
            return block_1582(state, tracer, fn_state);
        };
    }
    fn block_1582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1582_0: const #0u : u8
        let s_1582_0: bool = false;
        // D s_1582_1: write-var gs#118251 <= s_1582_0
        fn_state.gs_118251 = s_1582_0;
        // N s_1582_2: jump b1583
        return block_1583(state, tracer, fn_state);
    }
    fn block_1583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1583_0: read-var gs#118251:u8
        let s_1583_0: bool = fn_state.gs_118251;
        // N s_1583_1: branch s_1583_0 b4791 b1584
        if s_1583_0 {
            return block_4791(state, tracer, fn_state);
        } else {
            return block_1584(state, tracer, fn_state);
        };
    }
    fn block_1584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1584_0: read-var CRm:u8
        let s_1584_0: u8 = fn_state.CRm;
        // D s_1584_1: cast zx s_1584_0 -> bv
        let s_1584_1: Bits = Bits::new(s_1584_0 as u128, 4u16);
        // C s_1584_2: const #9u : u8
        let s_1584_2: u8 = 9;
        // C s_1584_3: cast zx s_1584_2 -> bv
        let s_1584_3: Bits = Bits::new(s_1584_2 as u128, 4u16);
        // D s_1584_4: cmp-eq s_1584_1 s_1584_3
        let s_1584_4: bool = ((s_1584_1) == (s_1584_3));
        // N s_1584_5: branch s_1584_4 b4790 b1585
        if s_1584_4 {
            return block_4790(state, tracer, fn_state);
        } else {
            return block_1585(state, tracer, fn_state);
        };
    }
    fn block_1585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1585_0: const #0u : u8
        let s_1585_0: bool = false;
        // D s_1585_1: write-var gs#118252 <= s_1585_0
        fn_state.gs_118252 = s_1585_0;
        // N s_1585_2: jump b1586
        return block_1586(state, tracer, fn_state);
    }
    fn block_1586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1586_0: read-var gs#118252:u8
        let s_1586_0: bool = fn_state.gs_118252;
        // N s_1586_1: branch s_1586_0 b4789 b1587
        if s_1586_0 {
            return block_4789(state, tracer, fn_state);
        } else {
            return block_1587(state, tracer, fn_state);
        };
    }
    fn block_1587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1587_0: const #0u : u8
        let s_1587_0: bool = false;
        // D s_1587_1: write-var gs#118253 <= s_1587_0
        fn_state.gs_118253 = s_1587_0;
        // N s_1587_2: jump b1588
        return block_1588(state, tracer, fn_state);
    }
    fn block_1588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1588_0: read-var gs#118253:u8
        let s_1588_0: bool = fn_state.gs_118253;
        // N s_1588_1: branch s_1588_0 b4788 b1589
        if s_1588_0 {
            return block_4788(state, tracer, fn_state);
        } else {
            return block_1589(state, tracer, fn_state);
        };
    }
    fn block_1589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1589_0: const #0u : u8
        let s_1589_0: bool = false;
        // D s_1589_1: write-var gs#118254 <= s_1589_0
        fn_state.gs_118254 = s_1589_0;
        // N s_1589_2: jump b1590
        return block_1590(state, tracer, fn_state);
    }
    fn block_1590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1590_0: read-var gs#118254:u8
        let s_1590_0: bool = fn_state.gs_118254;
        // N s_1590_1: branch s_1590_0 b4787 b1591
        if s_1590_0 {
            return block_4787(state, tracer, fn_state);
        } else {
            return block_1591(state, tracer, fn_state);
        };
    }
    fn block_1591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1591_0: const #0u : u8
        let s_1591_0: bool = false;
        // D s_1591_1: write-var gs#118255 <= s_1591_0
        fn_state.gs_118255 = s_1591_0;
        // N s_1591_2: jump b1592
        return block_1592(state, tracer, fn_state);
    }
    fn block_1592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1592_0: read-var gs#118255:u8
        let s_1592_0: bool = fn_state.gs_118255;
        // N s_1592_1: branch s_1592_0 b4786 b1593
        if s_1592_0 {
            return block_4786(state, tracer, fn_state);
        } else {
            return block_1593(state, tracer, fn_state);
        };
    }
    fn block_1593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1593_0: read-var CRm:u8
        let s_1593_0: u8 = fn_state.CRm;
        // D s_1593_1: cast zx s_1593_0 -> bv
        let s_1593_1: Bits = Bits::new(s_1593_0 as u128, 4u16);
        // C s_1593_2: const #9u : u8
        let s_1593_2: u8 = 9;
        // C s_1593_3: cast zx s_1593_2 -> bv
        let s_1593_3: Bits = Bits::new(s_1593_2 as u128, 4u16);
        // D s_1593_4: cmp-eq s_1593_1 s_1593_3
        let s_1593_4: bool = ((s_1593_1) == (s_1593_3));
        // N s_1593_5: branch s_1593_4 b4785 b1594
        if s_1593_4 {
            return block_4785(state, tracer, fn_state);
        } else {
            return block_1594(state, tracer, fn_state);
        };
    }
    fn block_1594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1594_0: const #0u : u8
        let s_1594_0: bool = false;
        // D s_1594_1: write-var gs#118256 <= s_1594_0
        fn_state.gs_118256 = s_1594_0;
        // N s_1594_2: jump b1595
        return block_1595(state, tracer, fn_state);
    }
    fn block_1595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1595_0: read-var gs#118256:u8
        let s_1595_0: bool = fn_state.gs_118256;
        // N s_1595_1: branch s_1595_0 b4784 b1596
        if s_1595_0 {
            return block_4784(state, tracer, fn_state);
        } else {
            return block_1596(state, tracer, fn_state);
        };
    }
    fn block_1596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1596_0: const #0u : u8
        let s_1596_0: bool = false;
        // D s_1596_1: write-var gs#118257 <= s_1596_0
        fn_state.gs_118257 = s_1596_0;
        // N s_1596_2: jump b1597
        return block_1597(state, tracer, fn_state);
    }
    fn block_1597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1597_0: read-var gs#118257:u8
        let s_1597_0: bool = fn_state.gs_118257;
        // N s_1597_1: branch s_1597_0 b4783 b1598
        if s_1597_0 {
            return block_4783(state, tracer, fn_state);
        } else {
            return block_1598(state, tracer, fn_state);
        };
    }
    fn block_1598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1598_0: const #0u : u8
        let s_1598_0: bool = false;
        // D s_1598_1: write-var gs#118258 <= s_1598_0
        fn_state.gs_118258 = s_1598_0;
        // N s_1598_2: jump b1599
        return block_1599(state, tracer, fn_state);
    }
    fn block_1599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1599_0: read-var gs#118258:u8
        let s_1599_0: bool = fn_state.gs_118258;
        // N s_1599_1: branch s_1599_0 b4782 b1600
        if s_1599_0 {
            return block_4782(state, tracer, fn_state);
        } else {
            return block_1600(state, tracer, fn_state);
        };
    }
    fn block_1600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1600_0: const #0u : u8
        let s_1600_0: bool = false;
        // D s_1600_1: write-var gs#118259 <= s_1600_0
        fn_state.gs_118259 = s_1600_0;
        // N s_1600_2: jump b1601
        return block_1601(state, tracer, fn_state);
    }
    fn block_1601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1601_0: read-var gs#118259:u8
        let s_1601_0: bool = fn_state.gs_118259;
        // N s_1601_1: branch s_1601_0 b4781 b1602
        if s_1601_0 {
            return block_4781(state, tracer, fn_state);
        } else {
            return block_1602(state, tracer, fn_state);
        };
    }
    fn block_1602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1602_0: read-var CRm:u8
        let s_1602_0: u8 = fn_state.CRm;
        // D s_1602_1: cast zx s_1602_0 -> bv
        let s_1602_1: Bits = Bits::new(s_1602_0 as u128, 4u16);
        // C s_1602_2: const #8u : u8
        let s_1602_2: u8 = 8;
        // C s_1602_3: cast zx s_1602_2 -> bv
        let s_1602_3: Bits = Bits::new(s_1602_2 as u128, 4u16);
        // D s_1602_4: cmp-eq s_1602_1 s_1602_3
        let s_1602_4: bool = ((s_1602_1) == (s_1602_3));
        // N s_1602_5: branch s_1602_4 b4780 b1603
        if s_1602_4 {
            return block_4780(state, tracer, fn_state);
        } else {
            return block_1603(state, tracer, fn_state);
        };
    }
    fn block_1603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1603_0: const #0u : u8
        let s_1603_0: bool = false;
        // D s_1603_1: write-var gs#118260 <= s_1603_0
        fn_state.gs_118260 = s_1603_0;
        // N s_1603_2: jump b1604
        return block_1604(state, tracer, fn_state);
    }
    fn block_1604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1604_0: read-var gs#118260:u8
        let s_1604_0: bool = fn_state.gs_118260;
        // N s_1604_1: branch s_1604_0 b4779 b1605
        if s_1604_0 {
            return block_4779(state, tracer, fn_state);
        } else {
            return block_1605(state, tracer, fn_state);
        };
    }
    fn block_1605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1605_0: const #0u : u8
        let s_1605_0: bool = false;
        // D s_1605_1: write-var gs#118261 <= s_1605_0
        fn_state.gs_118261 = s_1605_0;
        // N s_1605_2: jump b1606
        return block_1606(state, tracer, fn_state);
    }
    fn block_1606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1606_0: read-var gs#118261:u8
        let s_1606_0: bool = fn_state.gs_118261;
        // N s_1606_1: branch s_1606_0 b4778 b1607
        if s_1606_0 {
            return block_4778(state, tracer, fn_state);
        } else {
            return block_1607(state, tracer, fn_state);
        };
    }
    fn block_1607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1607_0: const #0u : u8
        let s_1607_0: bool = false;
        // D s_1607_1: write-var gs#118262 <= s_1607_0
        fn_state.gs_118262 = s_1607_0;
        // N s_1607_2: jump b1608
        return block_1608(state, tracer, fn_state);
    }
    fn block_1608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1608_0: read-var gs#118262:u8
        let s_1608_0: bool = fn_state.gs_118262;
        // N s_1608_1: branch s_1608_0 b4777 b1609
        if s_1608_0 {
            return block_4777(state, tracer, fn_state);
        } else {
            return block_1609(state, tracer, fn_state);
        };
    }
    fn block_1609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1609_0: const #0u : u8
        let s_1609_0: bool = false;
        // D s_1609_1: write-var gs#118263 <= s_1609_0
        fn_state.gs_118263 = s_1609_0;
        // N s_1609_2: jump b1610
        return block_1610(state, tracer, fn_state);
    }
    fn block_1610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1610_0: read-var gs#118263:u8
        let s_1610_0: bool = fn_state.gs_118263;
        // N s_1610_1: branch s_1610_0 b4776 b1611
        if s_1610_0 {
            return block_4776(state, tracer, fn_state);
        } else {
            return block_1611(state, tracer, fn_state);
        };
    }
    fn block_1611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1611_0: read-var CRm:u8
        let s_1611_0: u8 = fn_state.CRm;
        // D s_1611_1: cast zx s_1611_0 -> bv
        let s_1611_1: Bits = Bits::new(s_1611_0 as u128, 4u16);
        // C s_1611_2: const #8u : u8
        let s_1611_2: u8 = 8;
        // C s_1611_3: cast zx s_1611_2 -> bv
        let s_1611_3: Bits = Bits::new(s_1611_2 as u128, 4u16);
        // D s_1611_4: cmp-eq s_1611_1 s_1611_3
        let s_1611_4: bool = ((s_1611_1) == (s_1611_3));
        // N s_1611_5: branch s_1611_4 b4775 b1612
        if s_1611_4 {
            return block_4775(state, tracer, fn_state);
        } else {
            return block_1612(state, tracer, fn_state);
        };
    }
    fn block_1612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1612_0: const #0u : u8
        let s_1612_0: bool = false;
        // D s_1612_1: write-var gs#118264 <= s_1612_0
        fn_state.gs_118264 = s_1612_0;
        // N s_1612_2: jump b1613
        return block_1613(state, tracer, fn_state);
    }
    fn block_1613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1613_0: read-var gs#118264:u8
        let s_1613_0: bool = fn_state.gs_118264;
        // N s_1613_1: branch s_1613_0 b4774 b1614
        if s_1613_0 {
            return block_4774(state, tracer, fn_state);
        } else {
            return block_1614(state, tracer, fn_state);
        };
    }
    fn block_1614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1614_0: const #0u : u8
        let s_1614_0: bool = false;
        // D s_1614_1: write-var gs#118265 <= s_1614_0
        fn_state.gs_118265 = s_1614_0;
        // N s_1614_2: jump b1615
        return block_1615(state, tracer, fn_state);
    }
    fn block_1615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1615_0: read-var gs#118265:u8
        let s_1615_0: bool = fn_state.gs_118265;
        // N s_1615_1: branch s_1615_0 b4773 b1616
        if s_1615_0 {
            return block_4773(state, tracer, fn_state);
        } else {
            return block_1616(state, tracer, fn_state);
        };
    }
    fn block_1616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1616_0: const #0u : u8
        let s_1616_0: bool = false;
        // D s_1616_1: write-var gs#118266 <= s_1616_0
        fn_state.gs_118266 = s_1616_0;
        // N s_1616_2: jump b1617
        return block_1617(state, tracer, fn_state);
    }
    fn block_1617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1617_0: read-var gs#118266:u8
        let s_1617_0: bool = fn_state.gs_118266;
        // N s_1617_1: branch s_1617_0 b4772 b1618
        if s_1617_0 {
            return block_4772(state, tracer, fn_state);
        } else {
            return block_1618(state, tracer, fn_state);
        };
    }
    fn block_1618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1618_0: const #0u : u8
        let s_1618_0: bool = false;
        // D s_1618_1: write-var gs#118267 <= s_1618_0
        fn_state.gs_118267 = s_1618_0;
        // N s_1618_2: jump b1619
        return block_1619(state, tracer, fn_state);
    }
    fn block_1619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1619_0: read-var gs#118267:u8
        let s_1619_0: bool = fn_state.gs_118267;
        // N s_1619_1: branch s_1619_0 b4771 b1620
        if s_1619_0 {
            return block_4771(state, tracer, fn_state);
        } else {
            return block_1620(state, tracer, fn_state);
        };
    }
    fn block_1620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1620_0: read-var CRm:u8
        let s_1620_0: u8 = fn_state.CRm;
        // D s_1620_1: cast zx s_1620_0 -> bv
        let s_1620_1: Bits = Bits::new(s_1620_0 as u128, 4u16);
        // C s_1620_2: const #8u : u8
        let s_1620_2: u8 = 8;
        // C s_1620_3: cast zx s_1620_2 -> bv
        let s_1620_3: Bits = Bits::new(s_1620_2 as u128, 4u16);
        // D s_1620_4: cmp-eq s_1620_1 s_1620_3
        let s_1620_4: bool = ((s_1620_1) == (s_1620_3));
        // N s_1620_5: branch s_1620_4 b4770 b1621
        if s_1620_4 {
            return block_4770(state, tracer, fn_state);
        } else {
            return block_1621(state, tracer, fn_state);
        };
    }
    fn block_1621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1621_0: const #0u : u8
        let s_1621_0: bool = false;
        // D s_1621_1: write-var gs#118268 <= s_1621_0
        fn_state.gs_118268 = s_1621_0;
        // N s_1621_2: jump b1622
        return block_1622(state, tracer, fn_state);
    }
    fn block_1622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1622_0: read-var gs#118268:u8
        let s_1622_0: bool = fn_state.gs_118268;
        // N s_1622_1: branch s_1622_0 b4769 b1623
        if s_1622_0 {
            return block_4769(state, tracer, fn_state);
        } else {
            return block_1623(state, tracer, fn_state);
        };
    }
    fn block_1623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1623_0: const #0u : u8
        let s_1623_0: bool = false;
        // D s_1623_1: write-var gs#118269 <= s_1623_0
        fn_state.gs_118269 = s_1623_0;
        // N s_1623_2: jump b1624
        return block_1624(state, tracer, fn_state);
    }
    fn block_1624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1624_0: read-var gs#118269:u8
        let s_1624_0: bool = fn_state.gs_118269;
        // N s_1624_1: branch s_1624_0 b4768 b1625
        if s_1624_0 {
            return block_4768(state, tracer, fn_state);
        } else {
            return block_1625(state, tracer, fn_state);
        };
    }
    fn block_1625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1625_0: const #0u : u8
        let s_1625_0: bool = false;
        // D s_1625_1: write-var gs#118270 <= s_1625_0
        fn_state.gs_118270 = s_1625_0;
        // N s_1625_2: jump b1626
        return block_1626(state, tracer, fn_state);
    }
    fn block_1626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1626_0: read-var gs#118270:u8
        let s_1626_0: bool = fn_state.gs_118270;
        // N s_1626_1: branch s_1626_0 b4767 b1627
        if s_1626_0 {
            return block_4767(state, tracer, fn_state);
        } else {
            return block_1627(state, tracer, fn_state);
        };
    }
    fn block_1627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1627_0: const #0u : u8
        let s_1627_0: bool = false;
        // D s_1627_1: write-var gs#118271 <= s_1627_0
        fn_state.gs_118271 = s_1627_0;
        // N s_1627_2: jump b1628
        return block_1628(state, tracer, fn_state);
    }
    fn block_1628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1628_0: read-var gs#118271:u8
        let s_1628_0: bool = fn_state.gs_118271;
        // N s_1628_1: branch s_1628_0 b4766 b1629
        if s_1628_0 {
            return block_4766(state, tracer, fn_state);
        } else {
            return block_1629(state, tracer, fn_state);
        };
    }
    fn block_1629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1629_0: read-var CRm:u8
        let s_1629_0: u8 = fn_state.CRm;
        // D s_1629_1: cast zx s_1629_0 -> bv
        let s_1629_1: Bits = Bits::new(s_1629_0 as u128, 4u16);
        // C s_1629_2: const #8u : u8
        let s_1629_2: u8 = 8;
        // C s_1629_3: cast zx s_1629_2 -> bv
        let s_1629_3: Bits = Bits::new(s_1629_2 as u128, 4u16);
        // D s_1629_4: cmp-eq s_1629_1 s_1629_3
        let s_1629_4: bool = ((s_1629_1) == (s_1629_3));
        // N s_1629_5: branch s_1629_4 b4765 b1630
        if s_1629_4 {
            return block_4765(state, tracer, fn_state);
        } else {
            return block_1630(state, tracer, fn_state);
        };
    }
    fn block_1630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1630_0: const #0u : u8
        let s_1630_0: bool = false;
        // D s_1630_1: write-var gs#118272 <= s_1630_0
        fn_state.gs_118272 = s_1630_0;
        // N s_1630_2: jump b1631
        return block_1631(state, tracer, fn_state);
    }
    fn block_1631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1631_0: read-var gs#118272:u8
        let s_1631_0: bool = fn_state.gs_118272;
        // N s_1631_1: branch s_1631_0 b4764 b1632
        if s_1631_0 {
            return block_4764(state, tracer, fn_state);
        } else {
            return block_1632(state, tracer, fn_state);
        };
    }
    fn block_1632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1632_0: const #0u : u8
        let s_1632_0: bool = false;
        // D s_1632_1: write-var gs#118273 <= s_1632_0
        fn_state.gs_118273 = s_1632_0;
        // N s_1632_2: jump b1633
        return block_1633(state, tracer, fn_state);
    }
    fn block_1633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1633_0: read-var gs#118273:u8
        let s_1633_0: bool = fn_state.gs_118273;
        // N s_1633_1: branch s_1633_0 b4763 b1634
        if s_1633_0 {
            return block_4763(state, tracer, fn_state);
        } else {
            return block_1634(state, tracer, fn_state);
        };
    }
    fn block_1634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1634_0: const #0u : u8
        let s_1634_0: bool = false;
        // D s_1634_1: write-var gs#118274 <= s_1634_0
        fn_state.gs_118274 = s_1634_0;
        // N s_1634_2: jump b1635
        return block_1635(state, tracer, fn_state);
    }
    fn block_1635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1635_0: read-var gs#118274:u8
        let s_1635_0: bool = fn_state.gs_118274;
        // N s_1635_1: branch s_1635_0 b4762 b1636
        if s_1635_0 {
            return block_4762(state, tracer, fn_state);
        } else {
            return block_1636(state, tracer, fn_state);
        };
    }
    fn block_1636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1636_0: const #0u : u8
        let s_1636_0: bool = false;
        // D s_1636_1: write-var gs#118275 <= s_1636_0
        fn_state.gs_118275 = s_1636_0;
        // N s_1636_2: jump b1637
        return block_1637(state, tracer, fn_state);
    }
    fn block_1637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1637_0: read-var gs#118275:u8
        let s_1637_0: bool = fn_state.gs_118275;
        // N s_1637_1: branch s_1637_0 b4761 b1638
        if s_1637_0 {
            return block_4761(state, tracer, fn_state);
        } else {
            return block_1638(state, tracer, fn_state);
        };
    }
    fn block_1638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1638_0: read-var CRm:u8
        let s_1638_0: u8 = fn_state.CRm;
        // D s_1638_1: cast zx s_1638_0 -> bv
        let s_1638_1: Bits = Bits::new(s_1638_0 as u128, 4u16);
        // C s_1638_2: const #8u : u8
        let s_1638_2: u8 = 8;
        // C s_1638_3: cast zx s_1638_2 -> bv
        let s_1638_3: Bits = Bits::new(s_1638_2 as u128, 4u16);
        // D s_1638_4: cmp-eq s_1638_1 s_1638_3
        let s_1638_4: bool = ((s_1638_1) == (s_1638_3));
        // N s_1638_5: branch s_1638_4 b4760 b1639
        if s_1638_4 {
            return block_4760(state, tracer, fn_state);
        } else {
            return block_1639(state, tracer, fn_state);
        };
    }
    fn block_1639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1639_0: const #0u : u8
        let s_1639_0: bool = false;
        // D s_1639_1: write-var gs#118276 <= s_1639_0
        fn_state.gs_118276 = s_1639_0;
        // N s_1639_2: jump b1640
        return block_1640(state, tracer, fn_state);
    }
    fn block_1640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1640_0: read-var gs#118276:u8
        let s_1640_0: bool = fn_state.gs_118276;
        // N s_1640_1: branch s_1640_0 b4759 b1641
        if s_1640_0 {
            return block_4759(state, tracer, fn_state);
        } else {
            return block_1641(state, tracer, fn_state);
        };
    }
    fn block_1641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1641_0: const #0u : u8
        let s_1641_0: bool = false;
        // D s_1641_1: write-var gs#118277 <= s_1641_0
        fn_state.gs_118277 = s_1641_0;
        // N s_1641_2: jump b1642
        return block_1642(state, tracer, fn_state);
    }
    fn block_1642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1642_0: read-var gs#118277:u8
        let s_1642_0: bool = fn_state.gs_118277;
        // N s_1642_1: branch s_1642_0 b4758 b1643
        if s_1642_0 {
            return block_4758(state, tracer, fn_state);
        } else {
            return block_1643(state, tracer, fn_state);
        };
    }
    fn block_1643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1643_0: const #0u : u8
        let s_1643_0: bool = false;
        // D s_1643_1: write-var gs#118278 <= s_1643_0
        fn_state.gs_118278 = s_1643_0;
        // N s_1643_2: jump b1644
        return block_1644(state, tracer, fn_state);
    }
    fn block_1644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1644_0: read-var gs#118278:u8
        let s_1644_0: bool = fn_state.gs_118278;
        // N s_1644_1: branch s_1644_0 b4757 b1645
        if s_1644_0 {
            return block_4757(state, tracer, fn_state);
        } else {
            return block_1645(state, tracer, fn_state);
        };
    }
    fn block_1645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1645_0: const #0u : u8
        let s_1645_0: bool = false;
        // D s_1645_1: write-var gs#118279 <= s_1645_0
        fn_state.gs_118279 = s_1645_0;
        // N s_1645_2: jump b1646
        return block_1646(state, tracer, fn_state);
    }
    fn block_1646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1646_0: read-var gs#118279:u8
        let s_1646_0: bool = fn_state.gs_118279;
        // N s_1646_1: branch s_1646_0 b4756 b1647
        if s_1646_0 {
            return block_4756(state, tracer, fn_state);
        } else {
            return block_1647(state, tracer, fn_state);
        };
    }
    fn block_1647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1647_0: read-var CRm:u8
        let s_1647_0: u8 = fn_state.CRm;
        // D s_1647_1: cast zx s_1647_0 -> bv
        let s_1647_1: Bits = Bits::new(s_1647_0 as u128, 4u16);
        // C s_1647_2: const #8u : u8
        let s_1647_2: u8 = 8;
        // C s_1647_3: cast zx s_1647_2 -> bv
        let s_1647_3: Bits = Bits::new(s_1647_2 as u128, 4u16);
        // D s_1647_4: cmp-eq s_1647_1 s_1647_3
        let s_1647_4: bool = ((s_1647_1) == (s_1647_3));
        // N s_1647_5: branch s_1647_4 b4755 b1648
        if s_1647_4 {
            return block_4755(state, tracer, fn_state);
        } else {
            return block_1648(state, tracer, fn_state);
        };
    }
    fn block_1648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1648_0: const #0u : u8
        let s_1648_0: bool = false;
        // D s_1648_1: write-var gs#118280 <= s_1648_0
        fn_state.gs_118280 = s_1648_0;
        // N s_1648_2: jump b1649
        return block_1649(state, tracer, fn_state);
    }
    fn block_1649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1649_0: read-var gs#118280:u8
        let s_1649_0: bool = fn_state.gs_118280;
        // N s_1649_1: branch s_1649_0 b4754 b1650
        if s_1649_0 {
            return block_4754(state, tracer, fn_state);
        } else {
            return block_1650(state, tracer, fn_state);
        };
    }
    fn block_1650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1650_0: const #0u : u8
        let s_1650_0: bool = false;
        // D s_1650_1: write-var gs#118281 <= s_1650_0
        fn_state.gs_118281 = s_1650_0;
        // N s_1650_2: jump b1651
        return block_1651(state, tracer, fn_state);
    }
    fn block_1651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1651_0: read-var gs#118281:u8
        let s_1651_0: bool = fn_state.gs_118281;
        // N s_1651_1: branch s_1651_0 b4753 b1652
        if s_1651_0 {
            return block_4753(state, tracer, fn_state);
        } else {
            return block_1652(state, tracer, fn_state);
        };
    }
    fn block_1652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1652_0: const #0u : u8
        let s_1652_0: bool = false;
        // D s_1652_1: write-var gs#118282 <= s_1652_0
        fn_state.gs_118282 = s_1652_0;
        // N s_1652_2: jump b1653
        return block_1653(state, tracer, fn_state);
    }
    fn block_1653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1653_0: read-var gs#118282:u8
        let s_1653_0: bool = fn_state.gs_118282;
        // N s_1653_1: branch s_1653_0 b4752 b1654
        if s_1653_0 {
            return block_4752(state, tracer, fn_state);
        } else {
            return block_1654(state, tracer, fn_state);
        };
    }
    fn block_1654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1654_0: const #0u : u8
        let s_1654_0: bool = false;
        // D s_1654_1: write-var gs#118283 <= s_1654_0
        fn_state.gs_118283 = s_1654_0;
        // N s_1654_2: jump b1655
        return block_1655(state, tracer, fn_state);
    }
    fn block_1655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1655_0: read-var gs#118283:u8
        let s_1655_0: bool = fn_state.gs_118283;
        // N s_1655_1: branch s_1655_0 b4751 b1656
        if s_1655_0 {
            return block_4751(state, tracer, fn_state);
        } else {
            return block_1656(state, tracer, fn_state);
        };
    }
    fn block_1656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1656_0: read-var CRm:u8
        let s_1656_0: u8 = fn_state.CRm;
        // D s_1656_1: cast zx s_1656_0 -> bv
        let s_1656_1: Bits = Bits::new(s_1656_0 as u128, 4u16);
        // C s_1656_2: const #8u : u8
        let s_1656_2: u8 = 8;
        // C s_1656_3: cast zx s_1656_2 -> bv
        let s_1656_3: Bits = Bits::new(s_1656_2 as u128, 4u16);
        // D s_1656_4: cmp-eq s_1656_1 s_1656_3
        let s_1656_4: bool = ((s_1656_1) == (s_1656_3));
        // N s_1656_5: branch s_1656_4 b4750 b1657
        if s_1656_4 {
            return block_4750(state, tracer, fn_state);
        } else {
            return block_1657(state, tracer, fn_state);
        };
    }
    fn block_1657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1657_0: const #0u : u8
        let s_1657_0: bool = false;
        // D s_1657_1: write-var gs#118284 <= s_1657_0
        fn_state.gs_118284 = s_1657_0;
        // N s_1657_2: jump b1658
        return block_1658(state, tracer, fn_state);
    }
    fn block_1658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1658_0: read-var gs#118284:u8
        let s_1658_0: bool = fn_state.gs_118284;
        // N s_1658_1: branch s_1658_0 b4749 b1659
        if s_1658_0 {
            return block_4749(state, tracer, fn_state);
        } else {
            return block_1659(state, tracer, fn_state);
        };
    }
    fn block_1659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1659_0: const #0u : u8
        let s_1659_0: bool = false;
        // D s_1659_1: write-var gs#118285 <= s_1659_0
        fn_state.gs_118285 = s_1659_0;
        // N s_1659_2: jump b1660
        return block_1660(state, tracer, fn_state);
    }
    fn block_1660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1660_0: read-var gs#118285:u8
        let s_1660_0: bool = fn_state.gs_118285;
        // N s_1660_1: branch s_1660_0 b4748 b1661
        if s_1660_0 {
            return block_4748(state, tracer, fn_state);
        } else {
            return block_1661(state, tracer, fn_state);
        };
    }
    fn block_1661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1661_0: const #0u : u8
        let s_1661_0: bool = false;
        // D s_1661_1: write-var gs#118286 <= s_1661_0
        fn_state.gs_118286 = s_1661_0;
        // N s_1661_2: jump b1662
        return block_1662(state, tracer, fn_state);
    }
    fn block_1662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1662_0: read-var gs#118286:u8
        let s_1662_0: bool = fn_state.gs_118286;
        // N s_1662_1: branch s_1662_0 b4747 b1663
        if s_1662_0 {
            return block_4747(state, tracer, fn_state);
        } else {
            return block_1663(state, tracer, fn_state);
        };
    }
    fn block_1663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1663_0: const #0u : u8
        let s_1663_0: bool = false;
        // D s_1663_1: write-var gs#118287 <= s_1663_0
        fn_state.gs_118287 = s_1663_0;
        // N s_1663_2: jump b1664
        return block_1664(state, tracer, fn_state);
    }
    fn block_1664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1664_0: read-var gs#118287:u8
        let s_1664_0: bool = fn_state.gs_118287;
        // N s_1664_1: branch s_1664_0 b4746 b1665
        if s_1664_0 {
            return block_4746(state, tracer, fn_state);
        } else {
            return block_1665(state, tracer, fn_state);
        };
    }
    fn block_1665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1665_0: read-var CRm:u8
        let s_1665_0: u8 = fn_state.CRm;
        // D s_1665_1: cast zx s_1665_0 -> bv
        let s_1665_1: Bits = Bits::new(s_1665_0 as u128, 4u16);
        // C s_1665_2: const #8u : u8
        let s_1665_2: u8 = 8;
        // C s_1665_3: cast zx s_1665_2 -> bv
        let s_1665_3: Bits = Bits::new(s_1665_2 as u128, 4u16);
        // D s_1665_4: cmp-eq s_1665_1 s_1665_3
        let s_1665_4: bool = ((s_1665_1) == (s_1665_3));
        // N s_1665_5: branch s_1665_4 b4745 b1666
        if s_1665_4 {
            return block_4745(state, tracer, fn_state);
        } else {
            return block_1666(state, tracer, fn_state);
        };
    }
    fn block_1666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1666_0: const #0u : u8
        let s_1666_0: bool = false;
        // D s_1666_1: write-var gs#118288 <= s_1666_0
        fn_state.gs_118288 = s_1666_0;
        // N s_1666_2: jump b1667
        return block_1667(state, tracer, fn_state);
    }
    fn block_1667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1667_0: read-var gs#118288:u8
        let s_1667_0: bool = fn_state.gs_118288;
        // N s_1667_1: branch s_1667_0 b4744 b1668
        if s_1667_0 {
            return block_4744(state, tracer, fn_state);
        } else {
            return block_1668(state, tracer, fn_state);
        };
    }
    fn block_1668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1668_0: const #0u : u8
        let s_1668_0: bool = false;
        // D s_1668_1: write-var gs#118289 <= s_1668_0
        fn_state.gs_118289 = s_1668_0;
        // N s_1668_2: jump b1669
        return block_1669(state, tracer, fn_state);
    }
    fn block_1669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1669_0: read-var gs#118289:u8
        let s_1669_0: bool = fn_state.gs_118289;
        // N s_1669_1: branch s_1669_0 b4743 b1670
        if s_1669_0 {
            return block_4743(state, tracer, fn_state);
        } else {
            return block_1670(state, tracer, fn_state);
        };
    }
    fn block_1670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1670_0: const #0u : u8
        let s_1670_0: bool = false;
        // D s_1670_1: write-var gs#118290 <= s_1670_0
        fn_state.gs_118290 = s_1670_0;
        // N s_1670_2: jump b1671
        return block_1671(state, tracer, fn_state);
    }
    fn block_1671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1671_0: read-var gs#118290:u8
        let s_1671_0: bool = fn_state.gs_118290;
        // N s_1671_1: branch s_1671_0 b4742 b1672
        if s_1671_0 {
            return block_4742(state, tracer, fn_state);
        } else {
            return block_1672(state, tracer, fn_state);
        };
    }
    fn block_1672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1672_0: const #0u : u8
        let s_1672_0: bool = false;
        // D s_1672_1: write-var gs#118291 <= s_1672_0
        fn_state.gs_118291 = s_1672_0;
        // N s_1672_2: jump b1673
        return block_1673(state, tracer, fn_state);
    }
    fn block_1673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1673_0: read-var gs#118291:u8
        let s_1673_0: bool = fn_state.gs_118291;
        // N s_1673_1: branch s_1673_0 b4741 b1674
        if s_1673_0 {
            return block_4741(state, tracer, fn_state);
        } else {
            return block_1674(state, tracer, fn_state);
        };
    }
    fn block_1674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1674_0: read-var CRm:u8
        let s_1674_0: u8 = fn_state.CRm;
        // D s_1674_1: cast zx s_1674_0 -> bv
        let s_1674_1: Bits = Bits::new(s_1674_0 as u128, 4u16);
        // C s_1674_2: const #3u : u8
        let s_1674_2: u8 = 3;
        // C s_1674_3: cast zx s_1674_2 -> bv
        let s_1674_3: Bits = Bits::new(s_1674_2 as u128, 4u16);
        // D s_1674_4: cmp-eq s_1674_1 s_1674_3
        let s_1674_4: bool = ((s_1674_1) == (s_1674_3));
        // N s_1674_5: branch s_1674_4 b4740 b1675
        if s_1674_4 {
            return block_4740(state, tracer, fn_state);
        } else {
            return block_1675(state, tracer, fn_state);
        };
    }
    fn block_1675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1675_0: const #0u : u8
        let s_1675_0: bool = false;
        // D s_1675_1: write-var gs#118292 <= s_1675_0
        fn_state.gs_118292 = s_1675_0;
        // N s_1675_2: jump b1676
        return block_1676(state, tracer, fn_state);
    }
    fn block_1676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1676_0: read-var gs#118292:u8
        let s_1676_0: bool = fn_state.gs_118292;
        // N s_1676_1: branch s_1676_0 b4739 b1677
        if s_1676_0 {
            return block_4739(state, tracer, fn_state);
        } else {
            return block_1677(state, tracer, fn_state);
        };
    }
    fn block_1677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1677_0: const #0u : u8
        let s_1677_0: bool = false;
        // D s_1677_1: write-var gs#118293 <= s_1677_0
        fn_state.gs_118293 = s_1677_0;
        // N s_1677_2: jump b1678
        return block_1678(state, tracer, fn_state);
    }
    fn block_1678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1678_0: read-var gs#118293:u8
        let s_1678_0: bool = fn_state.gs_118293;
        // N s_1678_1: branch s_1678_0 b4738 b1679
        if s_1678_0 {
            return block_4738(state, tracer, fn_state);
        } else {
            return block_1679(state, tracer, fn_state);
        };
    }
    fn block_1679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1679_0: const #0u : u8
        let s_1679_0: bool = false;
        // D s_1679_1: write-var gs#118294 <= s_1679_0
        fn_state.gs_118294 = s_1679_0;
        // N s_1679_2: jump b1680
        return block_1680(state, tracer, fn_state);
    }
    fn block_1680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1680_0: read-var gs#118294:u8
        let s_1680_0: bool = fn_state.gs_118294;
        // N s_1680_1: branch s_1680_0 b4737 b1681
        if s_1680_0 {
            return block_4737(state, tracer, fn_state);
        } else {
            return block_1681(state, tracer, fn_state);
        };
    }
    fn block_1681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1681_0: const #0u : u8
        let s_1681_0: bool = false;
        // D s_1681_1: write-var gs#118295 <= s_1681_0
        fn_state.gs_118295 = s_1681_0;
        // N s_1681_2: jump b1682
        return block_1682(state, tracer, fn_state);
    }
    fn block_1682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1682_0: read-var gs#118295:u8
        let s_1682_0: bool = fn_state.gs_118295;
        // N s_1682_1: branch s_1682_0 b4736 b1683
        if s_1682_0 {
            return block_4736(state, tracer, fn_state);
        } else {
            return block_1683(state, tracer, fn_state);
        };
    }
    fn block_1683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1683_0: read-var CRm:u8
        let s_1683_0: u8 = fn_state.CRm;
        // D s_1683_1: cast zx s_1683_0 -> bv
        let s_1683_1: Bits = Bits::new(s_1683_0 as u128, 4u16);
        // C s_1683_2: const #0u : u8
        let s_1683_2: u8 = 0;
        // C s_1683_3: cast zx s_1683_2 -> bv
        let s_1683_3: Bits = Bits::new(s_1683_2 as u128, 4u16);
        // D s_1683_4: cmp-eq s_1683_1 s_1683_3
        let s_1683_4: bool = ((s_1683_1) == (s_1683_3));
        // N s_1683_5: branch s_1683_4 b4735 b1684
        if s_1683_4 {
            return block_4735(state, tracer, fn_state);
        } else {
            return block_1684(state, tracer, fn_state);
        };
    }
    fn block_1684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1684_0: const #0u : u8
        let s_1684_0: bool = false;
        // D s_1684_1: write-var gs#118296 <= s_1684_0
        fn_state.gs_118296 = s_1684_0;
        // N s_1684_2: jump b1685
        return block_1685(state, tracer, fn_state);
    }
    fn block_1685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1685_0: read-var gs#118296:u8
        let s_1685_0: bool = fn_state.gs_118296;
        // N s_1685_1: branch s_1685_0 b4734 b1686
        if s_1685_0 {
            return block_4734(state, tracer, fn_state);
        } else {
            return block_1686(state, tracer, fn_state);
        };
    }
    fn block_1686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1686_0: const #0u : u8
        let s_1686_0: bool = false;
        // D s_1686_1: write-var gs#118297 <= s_1686_0
        fn_state.gs_118297 = s_1686_0;
        // N s_1686_2: jump b1687
        return block_1687(state, tracer, fn_state);
    }
    fn block_1687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1687_0: read-var gs#118297:u8
        let s_1687_0: bool = fn_state.gs_118297;
        // N s_1687_1: branch s_1687_0 b4733 b1688
        if s_1687_0 {
            return block_4733(state, tracer, fn_state);
        } else {
            return block_1688(state, tracer, fn_state);
        };
    }
    fn block_1688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1688_0: const #0u : u8
        let s_1688_0: bool = false;
        // D s_1688_1: write-var gs#118298 <= s_1688_0
        fn_state.gs_118298 = s_1688_0;
        // N s_1688_2: jump b1689
        return block_1689(state, tracer, fn_state);
    }
    fn block_1689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1689_0: read-var gs#118298:u8
        let s_1689_0: bool = fn_state.gs_118298;
        // N s_1689_1: branch s_1689_0 b4732 b1690
        if s_1689_0 {
            return block_4732(state, tracer, fn_state);
        } else {
            return block_1690(state, tracer, fn_state);
        };
    }
    fn block_1690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1690_0: const #0u : u8
        let s_1690_0: bool = false;
        // D s_1690_1: write-var gs#118299 <= s_1690_0
        fn_state.gs_118299 = s_1690_0;
        // N s_1690_2: jump b1691
        return block_1691(state, tracer, fn_state);
    }
    fn block_1691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1691_0: read-var gs#118299:u8
        let s_1691_0: bool = fn_state.gs_118299;
        // N s_1691_1: branch s_1691_0 b4731 b1692
        if s_1691_0 {
            return block_4731(state, tracer, fn_state);
        } else {
            return block_1692(state, tracer, fn_state);
        };
    }
    fn block_1692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1692_0: read-var CRm:u8
        let s_1692_0: u8 = fn_state.CRm;
        // D s_1692_1: cast zx s_1692_0 -> bv
        let s_1692_1: Bits = Bits::new(s_1692_0 as u128, 4u16);
        // C s_1692_2: const #0u : u8
        let s_1692_2: u8 = 0;
        // C s_1692_3: cast zx s_1692_2 -> bv
        let s_1692_3: Bits = Bits::new(s_1692_2 as u128, 4u16);
        // D s_1692_4: cmp-eq s_1692_1 s_1692_3
        let s_1692_4: bool = ((s_1692_1) == (s_1692_3));
        // N s_1692_5: branch s_1692_4 b4730 b1693
        if s_1692_4 {
            return block_4730(state, tracer, fn_state);
        } else {
            return block_1693(state, tracer, fn_state);
        };
    }
    fn block_1693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1693_0: const #0u : u8
        let s_1693_0: bool = false;
        // D s_1693_1: write-var gs#118300 <= s_1693_0
        fn_state.gs_118300 = s_1693_0;
        // N s_1693_2: jump b1694
        return block_1694(state, tracer, fn_state);
    }
    fn block_1694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1694_0: read-var gs#118300:u8
        let s_1694_0: bool = fn_state.gs_118300;
        // N s_1694_1: branch s_1694_0 b4729 b1695
        if s_1694_0 {
            return block_4729(state, tracer, fn_state);
        } else {
            return block_1695(state, tracer, fn_state);
        };
    }
    fn block_1695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1695_0: const #0u : u8
        let s_1695_0: bool = false;
        // D s_1695_1: write-var gs#118301 <= s_1695_0
        fn_state.gs_118301 = s_1695_0;
        // N s_1695_2: jump b1696
        return block_1696(state, tracer, fn_state);
    }
    fn block_1696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1696_0: read-var gs#118301:u8
        let s_1696_0: bool = fn_state.gs_118301;
        // N s_1696_1: branch s_1696_0 b4728 b1697
        if s_1696_0 {
            return block_4728(state, tracer, fn_state);
        } else {
            return block_1697(state, tracer, fn_state);
        };
    }
    fn block_1697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1697_0: const #0u : u8
        let s_1697_0: bool = false;
        // D s_1697_1: write-var gs#118302 <= s_1697_0
        fn_state.gs_118302 = s_1697_0;
        // N s_1697_2: jump b1698
        return block_1698(state, tracer, fn_state);
    }
    fn block_1698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1698_0: read-var gs#118302:u8
        let s_1698_0: bool = fn_state.gs_118302;
        // N s_1698_1: branch s_1698_0 b4727 b1699
        if s_1698_0 {
            return block_4727(state, tracer, fn_state);
        } else {
            return block_1699(state, tracer, fn_state);
        };
    }
    fn block_1699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1699_0: const #0u : u8
        let s_1699_0: bool = false;
        // D s_1699_1: write-var gs#118303 <= s_1699_0
        fn_state.gs_118303 = s_1699_0;
        // N s_1699_2: jump b1700
        return block_1700(state, tracer, fn_state);
    }
    fn block_1700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1700_0: read-var gs#118303:u8
        let s_1700_0: bool = fn_state.gs_118303;
        // N s_1700_1: branch s_1700_0 b4726 b1701
        if s_1700_0 {
            return block_4726(state, tracer, fn_state);
        } else {
            return block_1701(state, tracer, fn_state);
        };
    }
    fn block_1701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1701_0: read-var CRm:u8
        let s_1701_0: u8 = fn_state.CRm;
        // D s_1701_1: cast zx s_1701_0 -> bv
        let s_1701_1: Bits = Bits::new(s_1701_0 as u128, 4u16);
        // C s_1701_2: const #3u : u8
        let s_1701_2: u8 = 3;
        // C s_1701_3: cast zx s_1701_2 -> bv
        let s_1701_3: Bits = Bits::new(s_1701_2 as u128, 4u16);
        // D s_1701_4: cmp-eq s_1701_1 s_1701_3
        let s_1701_4: bool = ((s_1701_1) == (s_1701_3));
        // N s_1701_5: branch s_1701_4 b4725 b1702
        if s_1701_4 {
            return block_4725(state, tracer, fn_state);
        } else {
            return block_1702(state, tracer, fn_state);
        };
    }
    fn block_1702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1702_0: const #0u : u8
        let s_1702_0: bool = false;
        // D s_1702_1: write-var gs#118304 <= s_1702_0
        fn_state.gs_118304 = s_1702_0;
        // N s_1702_2: jump b1703
        return block_1703(state, tracer, fn_state);
    }
    fn block_1703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1703_0: read-var gs#118304:u8
        let s_1703_0: bool = fn_state.gs_118304;
        // N s_1703_1: branch s_1703_0 b4724 b1704
        if s_1703_0 {
            return block_4724(state, tracer, fn_state);
        } else {
            return block_1704(state, tracer, fn_state);
        };
    }
    fn block_1704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1704_0: const #0u : u8
        let s_1704_0: bool = false;
        // D s_1704_1: write-var gs#118305 <= s_1704_0
        fn_state.gs_118305 = s_1704_0;
        // N s_1704_2: jump b1705
        return block_1705(state, tracer, fn_state);
    }
    fn block_1705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1705_0: read-var gs#118305:u8
        let s_1705_0: bool = fn_state.gs_118305;
        // N s_1705_1: branch s_1705_0 b4723 b1706
        if s_1705_0 {
            return block_4723(state, tracer, fn_state);
        } else {
            return block_1706(state, tracer, fn_state);
        };
    }
    fn block_1706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1706_0: const #0u : u8
        let s_1706_0: bool = false;
        // D s_1706_1: write-var gs#118306 <= s_1706_0
        fn_state.gs_118306 = s_1706_0;
        // N s_1706_2: jump b1707
        return block_1707(state, tracer, fn_state);
    }
    fn block_1707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1707_0: read-var gs#118306:u8
        let s_1707_0: bool = fn_state.gs_118306;
        // N s_1707_1: branch s_1707_0 b4722 b1708
        if s_1707_0 {
            return block_4722(state, tracer, fn_state);
        } else {
            return block_1708(state, tracer, fn_state);
        };
    }
    fn block_1708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1708_0: const #0u : u8
        let s_1708_0: bool = false;
        // D s_1708_1: write-var gs#118307 <= s_1708_0
        fn_state.gs_118307 = s_1708_0;
        // N s_1708_2: jump b1709
        return block_1709(state, tracer, fn_state);
    }
    fn block_1709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1709_0: read-var gs#118307:u8
        let s_1709_0: bool = fn_state.gs_118307;
        // N s_1709_1: branch s_1709_0 b4721 b1710
        if s_1709_0 {
            return block_4721(state, tracer, fn_state);
        } else {
            return block_1710(state, tracer, fn_state);
        };
    }
    fn block_1710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1710_0: read-var CRm:u8
        let s_1710_0: u8 = fn_state.CRm;
        // D s_1710_1: cast zx s_1710_0 -> bv
        let s_1710_1: Bits = Bits::new(s_1710_0 as u128, 4u16);
        // C s_1710_2: const #1u : u8
        let s_1710_2: u8 = 1;
        // C s_1710_3: cast zx s_1710_2 -> bv
        let s_1710_3: Bits = Bits::new(s_1710_2 as u128, 4u16);
        // D s_1710_4: cmp-eq s_1710_1 s_1710_3
        let s_1710_4: bool = ((s_1710_1) == (s_1710_3));
        // N s_1710_5: branch s_1710_4 b4720 b1711
        if s_1710_4 {
            return block_4720(state, tracer, fn_state);
        } else {
            return block_1711(state, tracer, fn_state);
        };
    }
    fn block_1711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1711_0: const #0u : u8
        let s_1711_0: bool = false;
        // D s_1711_1: write-var gs#118308 <= s_1711_0
        fn_state.gs_118308 = s_1711_0;
        // N s_1711_2: jump b1712
        return block_1712(state, tracer, fn_state);
    }
    fn block_1712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1712_0: read-var gs#118308:u8
        let s_1712_0: bool = fn_state.gs_118308;
        // N s_1712_1: branch s_1712_0 b4719 b1713
        if s_1712_0 {
            return block_4719(state, tracer, fn_state);
        } else {
            return block_1713(state, tracer, fn_state);
        };
    }
    fn block_1713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1713_0: const #0u : u8
        let s_1713_0: bool = false;
        // D s_1713_1: write-var gs#118309 <= s_1713_0
        fn_state.gs_118309 = s_1713_0;
        // N s_1713_2: jump b1714
        return block_1714(state, tracer, fn_state);
    }
    fn block_1714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1714_0: read-var gs#118309:u8
        let s_1714_0: bool = fn_state.gs_118309;
        // N s_1714_1: branch s_1714_0 b4718 b1715
        if s_1714_0 {
            return block_4718(state, tracer, fn_state);
        } else {
            return block_1715(state, tracer, fn_state);
        };
    }
    fn block_1715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1715_0: const #0u : u8
        let s_1715_0: bool = false;
        // D s_1715_1: write-var gs#118310 <= s_1715_0
        fn_state.gs_118310 = s_1715_0;
        // N s_1715_2: jump b1716
        return block_1716(state, tracer, fn_state);
    }
    fn block_1716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1716_0: read-var gs#118310:u8
        let s_1716_0: bool = fn_state.gs_118310;
        // N s_1716_1: branch s_1716_0 b4717 b1717
        if s_1716_0 {
            return block_4717(state, tracer, fn_state);
        } else {
            return block_1717(state, tracer, fn_state);
        };
    }
    fn block_1717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1717_0: const #0u : u8
        let s_1717_0: bool = false;
        // D s_1717_1: write-var gs#118311 <= s_1717_0
        fn_state.gs_118311 = s_1717_0;
        // N s_1717_2: jump b1718
        return block_1718(state, tracer, fn_state);
    }
    fn block_1718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1718_0: read-var gs#118311:u8
        let s_1718_0: bool = fn_state.gs_118311;
        // N s_1718_1: branch s_1718_0 b4716 b1719
        if s_1718_0 {
            return block_4716(state, tracer, fn_state);
        } else {
            return block_1719(state, tracer, fn_state);
        };
    }
    fn block_1719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1719_0: read-var CRm:u8
        let s_1719_0: u8 = fn_state.CRm;
        // D s_1719_1: cast zx s_1719_0 -> bv
        let s_1719_1: Bits = Bits::new(s_1719_0 as u128, 4u16);
        // C s_1719_2: const #1u : u8
        let s_1719_2: u8 = 1;
        // C s_1719_3: cast zx s_1719_2 -> bv
        let s_1719_3: Bits = Bits::new(s_1719_2 as u128, 4u16);
        // D s_1719_4: cmp-eq s_1719_1 s_1719_3
        let s_1719_4: bool = ((s_1719_1) == (s_1719_3));
        // N s_1719_5: branch s_1719_4 b4715 b1720
        if s_1719_4 {
            return block_4715(state, tracer, fn_state);
        } else {
            return block_1720(state, tracer, fn_state);
        };
    }
    fn block_1720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1720_0: const #0u : u8
        let s_1720_0: bool = false;
        // D s_1720_1: write-var gs#118312 <= s_1720_0
        fn_state.gs_118312 = s_1720_0;
        // N s_1720_2: jump b1721
        return block_1721(state, tracer, fn_state);
    }
    fn block_1721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1721_0: read-var gs#118312:u8
        let s_1721_0: bool = fn_state.gs_118312;
        // N s_1721_1: branch s_1721_0 b4714 b1722
        if s_1721_0 {
            return block_4714(state, tracer, fn_state);
        } else {
            return block_1722(state, tracer, fn_state);
        };
    }
    fn block_1722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1722_0: const #0u : u8
        let s_1722_0: bool = false;
        // D s_1722_1: write-var gs#118313 <= s_1722_0
        fn_state.gs_118313 = s_1722_0;
        // N s_1722_2: jump b1723
        return block_1723(state, tracer, fn_state);
    }
    fn block_1723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1723_0: read-var gs#118313:u8
        let s_1723_0: bool = fn_state.gs_118313;
        // N s_1723_1: branch s_1723_0 b4713 b1724
        if s_1723_0 {
            return block_4713(state, tracer, fn_state);
        } else {
            return block_1724(state, tracer, fn_state);
        };
    }
    fn block_1724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1724_0: const #0u : u8
        let s_1724_0: bool = false;
        // D s_1724_1: write-var gs#118314 <= s_1724_0
        fn_state.gs_118314 = s_1724_0;
        // N s_1724_2: jump b1725
        return block_1725(state, tracer, fn_state);
    }
    fn block_1725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1725_0: read-var gs#118314:u8
        let s_1725_0: bool = fn_state.gs_118314;
        // N s_1725_1: branch s_1725_0 b4712 b1726
        if s_1725_0 {
            return block_4712(state, tracer, fn_state);
        } else {
            return block_1726(state, tracer, fn_state);
        };
    }
    fn block_1726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1726_0: const #0u : u8
        let s_1726_0: bool = false;
        // D s_1726_1: write-var gs#118315 <= s_1726_0
        fn_state.gs_118315 = s_1726_0;
        // N s_1726_2: jump b1727
        return block_1727(state, tracer, fn_state);
    }
    fn block_1727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1727_0: read-var gs#118315:u8
        let s_1727_0: bool = fn_state.gs_118315;
        // N s_1727_1: branch s_1727_0 b4711 b1728
        if s_1727_0 {
            return block_4711(state, tracer, fn_state);
        } else {
            return block_1728(state, tracer, fn_state);
        };
    }
    fn block_1728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1728_0: read-var CRm:u8
        let s_1728_0: u8 = fn_state.CRm;
        // D s_1728_1: cast zx s_1728_0 -> bv
        let s_1728_1: Bits = Bits::new(s_1728_0 as u128, 4u16);
        // C s_1728_2: const #9u : u8
        let s_1728_2: u8 = 9;
        // C s_1728_3: cast zx s_1728_2 -> bv
        let s_1728_3: Bits = Bits::new(s_1728_2 as u128, 4u16);
        // D s_1728_4: cmp-eq s_1728_1 s_1728_3
        let s_1728_4: bool = ((s_1728_1) == (s_1728_3));
        // N s_1728_5: branch s_1728_4 b4710 b1729
        if s_1728_4 {
            return block_4710(state, tracer, fn_state);
        } else {
            return block_1729(state, tracer, fn_state);
        };
    }
    fn block_1729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1729_0: const #0u : u8
        let s_1729_0: bool = false;
        // D s_1729_1: write-var gs#118316 <= s_1729_0
        fn_state.gs_118316 = s_1729_0;
        // N s_1729_2: jump b1730
        return block_1730(state, tracer, fn_state);
    }
    fn block_1730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1730_0: read-var gs#118316:u8
        let s_1730_0: bool = fn_state.gs_118316;
        // N s_1730_1: branch s_1730_0 b4709 b1731
        if s_1730_0 {
            return block_4709(state, tracer, fn_state);
        } else {
            return block_1731(state, tracer, fn_state);
        };
    }
    fn block_1731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1731_0: const #0u : u8
        let s_1731_0: bool = false;
        // D s_1731_1: write-var gs#118317 <= s_1731_0
        fn_state.gs_118317 = s_1731_0;
        // N s_1731_2: jump b1732
        return block_1732(state, tracer, fn_state);
    }
    fn block_1732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1732_0: read-var gs#118317:u8
        let s_1732_0: bool = fn_state.gs_118317;
        // N s_1732_1: branch s_1732_0 b4708 b1733
        if s_1732_0 {
            return block_4708(state, tracer, fn_state);
        } else {
            return block_1733(state, tracer, fn_state);
        };
    }
    fn block_1733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1733_0: const #0u : u8
        let s_1733_0: bool = false;
        // D s_1733_1: write-var gs#118318 <= s_1733_0
        fn_state.gs_118318 = s_1733_0;
        // N s_1733_2: jump b1734
        return block_1734(state, tracer, fn_state);
    }
    fn block_1734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1734_0: read-var gs#118318:u8
        let s_1734_0: bool = fn_state.gs_118318;
        // N s_1734_1: branch s_1734_0 b4707 b1735
        if s_1734_0 {
            return block_4707(state, tracer, fn_state);
        } else {
            return block_1735(state, tracer, fn_state);
        };
    }
    fn block_1735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1735_0: const #0u : u8
        let s_1735_0: bool = false;
        // D s_1735_1: write-var gs#118319 <= s_1735_0
        fn_state.gs_118319 = s_1735_0;
        // N s_1735_2: jump b1736
        return block_1736(state, tracer, fn_state);
    }
    fn block_1736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1736_0: read-var gs#118319:u8
        let s_1736_0: bool = fn_state.gs_118319;
        // N s_1736_1: branch s_1736_0 b4706 b1737
        if s_1736_0 {
            return block_4706(state, tracer, fn_state);
        } else {
            return block_1737(state, tracer, fn_state);
        };
    }
    fn block_1737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1737_0: read-var CRm:u8
        let s_1737_0: u8 = fn_state.CRm;
        // D s_1737_1: cast zx s_1737_0 -> bv
        let s_1737_1: Bits = Bits::new(s_1737_0 as u128, 4u16);
        // C s_1737_2: const #9u : u8
        let s_1737_2: u8 = 9;
        // C s_1737_3: cast zx s_1737_2 -> bv
        let s_1737_3: Bits = Bits::new(s_1737_2 as u128, 4u16);
        // D s_1737_4: cmp-eq s_1737_1 s_1737_3
        let s_1737_4: bool = ((s_1737_1) == (s_1737_3));
        // N s_1737_5: branch s_1737_4 b4705 b1738
        if s_1737_4 {
            return block_4705(state, tracer, fn_state);
        } else {
            return block_1738(state, tracer, fn_state);
        };
    }
    fn block_1738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1738_0: const #0u : u8
        let s_1738_0: bool = false;
        // D s_1738_1: write-var gs#118320 <= s_1738_0
        fn_state.gs_118320 = s_1738_0;
        // N s_1738_2: jump b1739
        return block_1739(state, tracer, fn_state);
    }
    fn block_1739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1739_0: read-var gs#118320:u8
        let s_1739_0: bool = fn_state.gs_118320;
        // N s_1739_1: branch s_1739_0 b4704 b1740
        if s_1739_0 {
            return block_4704(state, tracer, fn_state);
        } else {
            return block_1740(state, tracer, fn_state);
        };
    }
    fn block_1740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1740_0: const #0u : u8
        let s_1740_0: bool = false;
        // D s_1740_1: write-var gs#118321 <= s_1740_0
        fn_state.gs_118321 = s_1740_0;
        // N s_1740_2: jump b1741
        return block_1741(state, tracer, fn_state);
    }
    fn block_1741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1741_0: read-var gs#118321:u8
        let s_1741_0: bool = fn_state.gs_118321;
        // N s_1741_1: branch s_1741_0 b4703 b1742
        if s_1741_0 {
            return block_4703(state, tracer, fn_state);
        } else {
            return block_1742(state, tracer, fn_state);
        };
    }
    fn block_1742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1742_0: const #0u : u8
        let s_1742_0: bool = false;
        // D s_1742_1: write-var gs#118322 <= s_1742_0
        fn_state.gs_118322 = s_1742_0;
        // N s_1742_2: jump b1743
        return block_1743(state, tracer, fn_state);
    }
    fn block_1743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1743_0: read-var gs#118322:u8
        let s_1743_0: bool = fn_state.gs_118322;
        // N s_1743_1: branch s_1743_0 b4702 b1744
        if s_1743_0 {
            return block_4702(state, tracer, fn_state);
        } else {
            return block_1744(state, tracer, fn_state);
        };
    }
    fn block_1744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1744_0: const #0u : u8
        let s_1744_0: bool = false;
        // D s_1744_1: write-var gs#118323 <= s_1744_0
        fn_state.gs_118323 = s_1744_0;
        // N s_1744_2: jump b1745
        return block_1745(state, tracer, fn_state);
    }
    fn block_1745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1745_0: read-var gs#118323:u8
        let s_1745_0: bool = fn_state.gs_118323;
        // N s_1745_1: branch s_1745_0 b4701 b1746
        if s_1745_0 {
            return block_4701(state, tracer, fn_state);
        } else {
            return block_1746(state, tracer, fn_state);
        };
    }
    fn block_1746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1746_0: read-var CRm:u8
        let s_1746_0: u8 = fn_state.CRm;
        // D s_1746_1: cast zx s_1746_0 -> bv
        let s_1746_1: Bits = Bits::new(s_1746_0 as u128, 4u16);
        // C s_1746_2: const #9u : u8
        let s_1746_2: u8 = 9;
        // C s_1746_3: cast zx s_1746_2 -> bv
        let s_1746_3: Bits = Bits::new(s_1746_2 as u128, 4u16);
        // D s_1746_4: cmp-eq s_1746_1 s_1746_3
        let s_1746_4: bool = ((s_1746_1) == (s_1746_3));
        // N s_1746_5: branch s_1746_4 b4700 b1747
        if s_1746_4 {
            return block_4700(state, tracer, fn_state);
        } else {
            return block_1747(state, tracer, fn_state);
        };
    }
    fn block_1747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1747_0: const #0u : u8
        let s_1747_0: bool = false;
        // D s_1747_1: write-var gs#118324 <= s_1747_0
        fn_state.gs_118324 = s_1747_0;
        // N s_1747_2: jump b1748
        return block_1748(state, tracer, fn_state);
    }
    fn block_1748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1748_0: read-var gs#118324:u8
        let s_1748_0: bool = fn_state.gs_118324;
        // N s_1748_1: branch s_1748_0 b4699 b1749
        if s_1748_0 {
            return block_4699(state, tracer, fn_state);
        } else {
            return block_1749(state, tracer, fn_state);
        };
    }
    fn block_1749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1749_0: const #0u : u8
        let s_1749_0: bool = false;
        // D s_1749_1: write-var gs#118325 <= s_1749_0
        fn_state.gs_118325 = s_1749_0;
        // N s_1749_2: jump b1750
        return block_1750(state, tracer, fn_state);
    }
    fn block_1750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1750_0: read-var gs#118325:u8
        let s_1750_0: bool = fn_state.gs_118325;
        // N s_1750_1: branch s_1750_0 b4698 b1751
        if s_1750_0 {
            return block_4698(state, tracer, fn_state);
        } else {
            return block_1751(state, tracer, fn_state);
        };
    }
    fn block_1751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1751_0: const #0u : u8
        let s_1751_0: bool = false;
        // D s_1751_1: write-var gs#118326 <= s_1751_0
        fn_state.gs_118326 = s_1751_0;
        // N s_1751_2: jump b1752
        return block_1752(state, tracer, fn_state);
    }
    fn block_1752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1752_0: read-var gs#118326:u8
        let s_1752_0: bool = fn_state.gs_118326;
        // N s_1752_1: branch s_1752_0 b4697 b1753
        if s_1752_0 {
            return block_4697(state, tracer, fn_state);
        } else {
            return block_1753(state, tracer, fn_state);
        };
    }
    fn block_1753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1753_0: const #0u : u8
        let s_1753_0: bool = false;
        // D s_1753_1: write-var gs#118327 <= s_1753_0
        fn_state.gs_118327 = s_1753_0;
        // N s_1753_2: jump b1754
        return block_1754(state, tracer, fn_state);
    }
    fn block_1754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1754_0: read-var gs#118327:u8
        let s_1754_0: bool = fn_state.gs_118327;
        // N s_1754_1: branch s_1754_0 b4696 b1755
        if s_1754_0 {
            return block_4696(state, tracer, fn_state);
        } else {
            return block_1755(state, tracer, fn_state);
        };
    }
    fn block_1755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1755_0: read-var CRm:u8
        let s_1755_0: u8 = fn_state.CRm;
        // D s_1755_1: cast zx s_1755_0 -> bv
        let s_1755_1: Bits = Bits::new(s_1755_0 as u128, 4u16);
        // C s_1755_2: const #9u : u8
        let s_1755_2: u8 = 9;
        // C s_1755_3: cast zx s_1755_2 -> bv
        let s_1755_3: Bits = Bits::new(s_1755_2 as u128, 4u16);
        // D s_1755_4: cmp-eq s_1755_1 s_1755_3
        let s_1755_4: bool = ((s_1755_1) == (s_1755_3));
        // N s_1755_5: branch s_1755_4 b4695 b1756
        if s_1755_4 {
            return block_4695(state, tracer, fn_state);
        } else {
            return block_1756(state, tracer, fn_state);
        };
    }
    fn block_1756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1756_0: const #0u : u8
        let s_1756_0: bool = false;
        // D s_1756_1: write-var gs#118328 <= s_1756_0
        fn_state.gs_118328 = s_1756_0;
        // N s_1756_2: jump b1757
        return block_1757(state, tracer, fn_state);
    }
    fn block_1757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1757_0: read-var gs#118328:u8
        let s_1757_0: bool = fn_state.gs_118328;
        // N s_1757_1: branch s_1757_0 b4694 b1758
        if s_1757_0 {
            return block_4694(state, tracer, fn_state);
        } else {
            return block_1758(state, tracer, fn_state);
        };
    }
    fn block_1758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1758_0: const #0u : u8
        let s_1758_0: bool = false;
        // D s_1758_1: write-var gs#118329 <= s_1758_0
        fn_state.gs_118329 = s_1758_0;
        // N s_1758_2: jump b1759
        return block_1759(state, tracer, fn_state);
    }
    fn block_1759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1759_0: read-var gs#118329:u8
        let s_1759_0: bool = fn_state.gs_118329;
        // N s_1759_1: branch s_1759_0 b4693 b1760
        if s_1759_0 {
            return block_4693(state, tracer, fn_state);
        } else {
            return block_1760(state, tracer, fn_state);
        };
    }
    fn block_1760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1760_0: const #0u : u8
        let s_1760_0: bool = false;
        // D s_1760_1: write-var gs#118330 <= s_1760_0
        fn_state.gs_118330 = s_1760_0;
        // N s_1760_2: jump b1761
        return block_1761(state, tracer, fn_state);
    }
    fn block_1761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1761_0: read-var gs#118330:u8
        let s_1761_0: bool = fn_state.gs_118330;
        // N s_1761_1: branch s_1761_0 b4692 b1762
        if s_1761_0 {
            return block_4692(state, tracer, fn_state);
        } else {
            return block_1762(state, tracer, fn_state);
        };
    }
    fn block_1762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1762_0: const #0u : u8
        let s_1762_0: bool = false;
        // D s_1762_1: write-var gs#118331 <= s_1762_0
        fn_state.gs_118331 = s_1762_0;
        // N s_1762_2: jump b1763
        return block_1763(state, tracer, fn_state);
    }
    fn block_1763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1763_0: read-var gs#118331:u8
        let s_1763_0: bool = fn_state.gs_118331;
        // N s_1763_1: branch s_1763_0 b4691 b1764
        if s_1763_0 {
            return block_4691(state, tracer, fn_state);
        } else {
            return block_1764(state, tracer, fn_state);
        };
    }
    fn block_1764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1764_0: read-var CRm:u8
        let s_1764_0: u8 = fn_state.CRm;
        // D s_1764_1: cast zx s_1764_0 -> bv
        let s_1764_1: Bits = Bits::new(s_1764_0 as u128, 4u16);
        // C s_1764_2: const #1u : u8
        let s_1764_2: u8 = 1;
        // C s_1764_3: cast zx s_1764_2 -> bv
        let s_1764_3: Bits = Bits::new(s_1764_2 as u128, 4u16);
        // D s_1764_4: cmp-eq s_1764_1 s_1764_3
        let s_1764_4: bool = ((s_1764_1) == (s_1764_3));
        // N s_1764_5: branch s_1764_4 b4690 b1765
        if s_1764_4 {
            return block_4690(state, tracer, fn_state);
        } else {
            return block_1765(state, tracer, fn_state);
        };
    }
    fn block_1765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1765_0: const #0u : u8
        let s_1765_0: bool = false;
        // D s_1765_1: write-var gs#118332 <= s_1765_0
        fn_state.gs_118332 = s_1765_0;
        // N s_1765_2: jump b1766
        return block_1766(state, tracer, fn_state);
    }
    fn block_1766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1766_0: read-var gs#118332:u8
        let s_1766_0: bool = fn_state.gs_118332;
        // N s_1766_1: branch s_1766_0 b4689 b1767
        if s_1766_0 {
            return block_4689(state, tracer, fn_state);
        } else {
            return block_1767(state, tracer, fn_state);
        };
    }
    fn block_1767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1767_0: const #0u : u8
        let s_1767_0: bool = false;
        // D s_1767_1: write-var gs#118333 <= s_1767_0
        fn_state.gs_118333 = s_1767_0;
        // N s_1767_2: jump b1768
        return block_1768(state, tracer, fn_state);
    }
    fn block_1768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1768_0: read-var gs#118333:u8
        let s_1768_0: bool = fn_state.gs_118333;
        // N s_1768_1: branch s_1768_0 b4688 b1769
        if s_1768_0 {
            return block_4688(state, tracer, fn_state);
        } else {
            return block_1769(state, tracer, fn_state);
        };
    }
    fn block_1769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1769_0: const #0u : u8
        let s_1769_0: bool = false;
        // D s_1769_1: write-var gs#118334 <= s_1769_0
        fn_state.gs_118334 = s_1769_0;
        // N s_1769_2: jump b1770
        return block_1770(state, tracer, fn_state);
    }
    fn block_1770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1770_0: read-var gs#118334:u8
        let s_1770_0: bool = fn_state.gs_118334;
        // N s_1770_1: branch s_1770_0 b4687 b1771
        if s_1770_0 {
            return block_4687(state, tracer, fn_state);
        } else {
            return block_1771(state, tracer, fn_state);
        };
    }
    fn block_1771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1771_0: const #0u : u8
        let s_1771_0: bool = false;
        // D s_1771_1: write-var gs#118335 <= s_1771_0
        fn_state.gs_118335 = s_1771_0;
        // N s_1771_2: jump b1772
        return block_1772(state, tracer, fn_state);
    }
    fn block_1772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1772_0: read-var gs#118335:u8
        let s_1772_0: bool = fn_state.gs_118335;
        // N s_1772_1: branch s_1772_0 b4686 b1773
        if s_1772_0 {
            return block_4686(state, tracer, fn_state);
        } else {
            return block_1773(state, tracer, fn_state);
        };
    }
    fn block_1773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1773_0: read-var CRm:u8
        let s_1773_0: u8 = fn_state.CRm;
        // D s_1773_1: cast zx s_1773_0 -> bv
        let s_1773_1: Bits = Bits::new(s_1773_0 as u128, 4u16);
        // C s_1773_2: const #11u : u8
        let s_1773_2: u8 = 11;
        // C s_1773_3: cast zx s_1773_2 -> bv
        let s_1773_3: Bits = Bits::new(s_1773_2 as u128, 4u16);
        // D s_1773_4: cmp-eq s_1773_1 s_1773_3
        let s_1773_4: bool = ((s_1773_1) == (s_1773_3));
        // N s_1773_5: branch s_1773_4 b4685 b1774
        if s_1773_4 {
            return block_4685(state, tracer, fn_state);
        } else {
            return block_1774(state, tracer, fn_state);
        };
    }
    fn block_1774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1774_0: const #0u : u8
        let s_1774_0: bool = false;
        // D s_1774_1: write-var gs#118336 <= s_1774_0
        fn_state.gs_118336 = s_1774_0;
        // N s_1774_2: jump b1775
        return block_1775(state, tracer, fn_state);
    }
    fn block_1775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1775_0: read-var gs#118336:u8
        let s_1775_0: bool = fn_state.gs_118336;
        // N s_1775_1: branch s_1775_0 b4684 b1776
        if s_1775_0 {
            return block_4684(state, tracer, fn_state);
        } else {
            return block_1776(state, tracer, fn_state);
        };
    }
    fn block_1776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1776_0: const #0u : u8
        let s_1776_0: bool = false;
        // D s_1776_1: write-var gs#118337 <= s_1776_0
        fn_state.gs_118337 = s_1776_0;
        // N s_1776_2: jump b1777
        return block_1777(state, tracer, fn_state);
    }
    fn block_1777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1777_0: read-var gs#118337:u8
        let s_1777_0: bool = fn_state.gs_118337;
        // N s_1777_1: branch s_1777_0 b4683 b1778
        if s_1777_0 {
            return block_4683(state, tracer, fn_state);
        } else {
            return block_1778(state, tracer, fn_state);
        };
    }
    fn block_1778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1778_0: const #0u : u8
        let s_1778_0: bool = false;
        // D s_1778_1: write-var gs#118338 <= s_1778_0
        fn_state.gs_118338 = s_1778_0;
        // N s_1778_2: jump b1779
        return block_1779(state, tracer, fn_state);
    }
    fn block_1779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1779_0: read-var gs#118338:u8
        let s_1779_0: bool = fn_state.gs_118338;
        // N s_1779_1: branch s_1779_0 b4682 b1780
        if s_1779_0 {
            return block_4682(state, tracer, fn_state);
        } else {
            return block_1780(state, tracer, fn_state);
        };
    }
    fn block_1780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1780_0: const #0u : u8
        let s_1780_0: bool = false;
        // D s_1780_1: write-var gs#118339 <= s_1780_0
        fn_state.gs_118339 = s_1780_0;
        // N s_1780_2: jump b1781
        return block_1781(state, tracer, fn_state);
    }
    fn block_1781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1781_0: read-var gs#118339:u8
        let s_1781_0: bool = fn_state.gs_118339;
        // N s_1781_1: branch s_1781_0 b4681 b1782
        if s_1781_0 {
            return block_4681(state, tracer, fn_state);
        } else {
            return block_1782(state, tracer, fn_state);
        };
    }
    fn block_1782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1782_0: read-var CRm:u8
        let s_1782_0: u8 = fn_state.CRm;
        // D s_1782_1: cast zx s_1782_0 -> bv
        let s_1782_1: Bits = Bits::new(s_1782_0 as u128, 4u16);
        // C s_1782_2: const #3u : u8
        let s_1782_2: u8 = 3;
        // C s_1782_3: cast zx s_1782_2 -> bv
        let s_1782_3: Bits = Bits::new(s_1782_2 as u128, 4u16);
        // D s_1782_4: cmp-eq s_1782_1 s_1782_3
        let s_1782_4: bool = ((s_1782_1) == (s_1782_3));
        // N s_1782_5: branch s_1782_4 b4680 b1783
        if s_1782_4 {
            return block_4680(state, tracer, fn_state);
        } else {
            return block_1783(state, tracer, fn_state);
        };
    }
    fn block_1783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1783_0: const #0u : u8
        let s_1783_0: bool = false;
        // D s_1783_1: write-var gs#118340 <= s_1783_0
        fn_state.gs_118340 = s_1783_0;
        // N s_1783_2: jump b1784
        return block_1784(state, tracer, fn_state);
    }
    fn block_1784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1784_0: read-var gs#118340:u8
        let s_1784_0: bool = fn_state.gs_118340;
        // N s_1784_1: branch s_1784_0 b4679 b1785
        if s_1784_0 {
            return block_4679(state, tracer, fn_state);
        } else {
            return block_1785(state, tracer, fn_state);
        };
    }
    fn block_1785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1785_0: const #0u : u8
        let s_1785_0: bool = false;
        // D s_1785_1: write-var gs#118341 <= s_1785_0
        fn_state.gs_118341 = s_1785_0;
        // N s_1785_2: jump b1786
        return block_1786(state, tracer, fn_state);
    }
    fn block_1786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1786_0: read-var gs#118341:u8
        let s_1786_0: bool = fn_state.gs_118341;
        // N s_1786_1: branch s_1786_0 b4678 b1787
        if s_1786_0 {
            return block_4678(state, tracer, fn_state);
        } else {
            return block_1787(state, tracer, fn_state);
        };
    }
    fn block_1787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1787_0: const #0u : u8
        let s_1787_0: bool = false;
        // D s_1787_1: write-var gs#118342 <= s_1787_0
        fn_state.gs_118342 = s_1787_0;
        // N s_1787_2: jump b1788
        return block_1788(state, tracer, fn_state);
    }
    fn block_1788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1788_0: read-var gs#118342:u8
        let s_1788_0: bool = fn_state.gs_118342;
        // N s_1788_1: branch s_1788_0 b4677 b1789
        if s_1788_0 {
            return block_4677(state, tracer, fn_state);
        } else {
            return block_1789(state, tracer, fn_state);
        };
    }
    fn block_1789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1789_0: const #0u : u8
        let s_1789_0: bool = false;
        // D s_1789_1: write-var gs#118343 <= s_1789_0
        fn_state.gs_118343 = s_1789_0;
        // N s_1789_2: jump b1790
        return block_1790(state, tracer, fn_state);
    }
    fn block_1790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1790_0: read-var gs#118343:u8
        let s_1790_0: bool = fn_state.gs_118343;
        // N s_1790_1: branch s_1790_0 b4676 b1791
        if s_1790_0 {
            return block_4676(state, tracer, fn_state);
        } else {
            return block_1791(state, tracer, fn_state);
        };
    }
    fn block_1791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1791_0: read-var CRm:u8
        let s_1791_0: u8 = fn_state.CRm;
        // D s_1791_1: cast zx s_1791_0 -> bv
        let s_1791_1: Bits = Bits::new(s_1791_0 as u128, 4u16);
        // C s_1791_2: const #1u : u8
        let s_1791_2: u8 = 1;
        // C s_1791_3: cast zx s_1791_2 -> bv
        let s_1791_3: Bits = Bits::new(s_1791_2 as u128, 4u16);
        // D s_1791_4: cmp-eq s_1791_1 s_1791_3
        let s_1791_4: bool = ((s_1791_1) == (s_1791_3));
        // N s_1791_5: branch s_1791_4 b4675 b1792
        if s_1791_4 {
            return block_4675(state, tracer, fn_state);
        } else {
            return block_1792(state, tracer, fn_state);
        };
    }
    fn block_1792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1792_0: const #0u : u8
        let s_1792_0: bool = false;
        // D s_1792_1: write-var gs#118344 <= s_1792_0
        fn_state.gs_118344 = s_1792_0;
        // N s_1792_2: jump b1793
        return block_1793(state, tracer, fn_state);
    }
    fn block_1793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1793_0: read-var gs#118344:u8
        let s_1793_0: bool = fn_state.gs_118344;
        // N s_1793_1: branch s_1793_0 b4674 b1794
        if s_1793_0 {
            return block_4674(state, tracer, fn_state);
        } else {
            return block_1794(state, tracer, fn_state);
        };
    }
    fn block_1794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1794_0: const #0u : u8
        let s_1794_0: bool = false;
        // D s_1794_1: write-var gs#118345 <= s_1794_0
        fn_state.gs_118345 = s_1794_0;
        // N s_1794_2: jump b1795
        return block_1795(state, tracer, fn_state);
    }
    fn block_1795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1795_0: read-var gs#118345:u8
        let s_1795_0: bool = fn_state.gs_118345;
        // N s_1795_1: branch s_1795_0 b4673 b1796
        if s_1795_0 {
            return block_4673(state, tracer, fn_state);
        } else {
            return block_1796(state, tracer, fn_state);
        };
    }
    fn block_1796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1796_0: const #0u : u8
        let s_1796_0: bool = false;
        // D s_1796_1: write-var gs#118346 <= s_1796_0
        fn_state.gs_118346 = s_1796_0;
        // N s_1796_2: jump b1797
        return block_1797(state, tracer, fn_state);
    }
    fn block_1797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1797_0: read-var gs#118346:u8
        let s_1797_0: bool = fn_state.gs_118346;
        // N s_1797_1: branch s_1797_0 b4672 b1798
        if s_1797_0 {
            return block_4672(state, tracer, fn_state);
        } else {
            return block_1798(state, tracer, fn_state);
        };
    }
    fn block_1798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1798_0: const #0u : u8
        let s_1798_0: bool = false;
        // D s_1798_1: write-var gs#118347 <= s_1798_0
        fn_state.gs_118347 = s_1798_0;
        // N s_1798_2: jump b1799
        return block_1799(state, tracer, fn_state);
    }
    fn block_1799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1799_0: read-var gs#118347:u8
        let s_1799_0: bool = fn_state.gs_118347;
        // N s_1799_1: branch s_1799_0 b4671 b1800
        if s_1799_0 {
            return block_4671(state, tracer, fn_state);
        } else {
            return block_1800(state, tracer, fn_state);
        };
    }
    fn block_1800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1800_0: read-var CRm:u8
        let s_1800_0: u8 = fn_state.CRm;
        // D s_1800_1: cast zx s_1800_0 -> bv
        let s_1800_1: Bits = Bits::new(s_1800_0 as u128, 4u16);
        // C s_1800_2: const #3u : u8
        let s_1800_2: u8 = 3;
        // C s_1800_3: cast zx s_1800_2 -> bv
        let s_1800_3: Bits = Bits::new(s_1800_2 as u128, 4u16);
        // D s_1800_4: cmp-eq s_1800_1 s_1800_3
        let s_1800_4: bool = ((s_1800_1) == (s_1800_3));
        // N s_1800_5: branch s_1800_4 b4670 b1801
        if s_1800_4 {
            return block_4670(state, tracer, fn_state);
        } else {
            return block_1801(state, tracer, fn_state);
        };
    }
    fn block_1801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1801_0: const #0u : u8
        let s_1801_0: bool = false;
        // D s_1801_1: write-var gs#118348 <= s_1801_0
        fn_state.gs_118348 = s_1801_0;
        // N s_1801_2: jump b1802
        return block_1802(state, tracer, fn_state);
    }
    fn block_1802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1802_0: read-var gs#118348:u8
        let s_1802_0: bool = fn_state.gs_118348;
        // N s_1802_1: branch s_1802_0 b4669 b1803
        if s_1802_0 {
            return block_4669(state, tracer, fn_state);
        } else {
            return block_1803(state, tracer, fn_state);
        };
    }
    fn block_1803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1803_0: const #0u : u8
        let s_1803_0: bool = false;
        // D s_1803_1: write-var gs#118349 <= s_1803_0
        fn_state.gs_118349 = s_1803_0;
        // N s_1803_2: jump b1804
        return block_1804(state, tracer, fn_state);
    }
    fn block_1804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1804_0: read-var gs#118349:u8
        let s_1804_0: bool = fn_state.gs_118349;
        // N s_1804_1: branch s_1804_0 b4668 b1805
        if s_1804_0 {
            return block_4668(state, tracer, fn_state);
        } else {
            return block_1805(state, tracer, fn_state);
        };
    }
    fn block_1805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1805_0: const #0u : u8
        let s_1805_0: bool = false;
        // D s_1805_1: write-var gs#118350 <= s_1805_0
        fn_state.gs_118350 = s_1805_0;
        // N s_1805_2: jump b1806
        return block_1806(state, tracer, fn_state);
    }
    fn block_1806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1806_0: read-var gs#118350:u8
        let s_1806_0: bool = fn_state.gs_118350;
        // N s_1806_1: branch s_1806_0 b4667 b1807
        if s_1806_0 {
            return block_4667(state, tracer, fn_state);
        } else {
            return block_1807(state, tracer, fn_state);
        };
    }
    fn block_1807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1807_0: const #0u : u8
        let s_1807_0: bool = false;
        // D s_1807_1: write-var gs#118351 <= s_1807_0
        fn_state.gs_118351 = s_1807_0;
        // N s_1807_2: jump b1808
        return block_1808(state, tracer, fn_state);
    }
    fn block_1808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1808_0: read-var gs#118351:u8
        let s_1808_0: bool = fn_state.gs_118351;
        // N s_1808_1: branch s_1808_0 b4666 b1809
        if s_1808_0 {
            return block_4666(state, tracer, fn_state);
        } else {
            return block_1809(state, tracer, fn_state);
        };
    }
    fn block_1809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1809_0: read-var CRm:u8
        let s_1809_0: u8 = fn_state.CRm;
        // D s_1809_1: cast zx s_1809_0 -> bv
        let s_1809_1: Bits = Bits::new(s_1809_0 as u128, 4u16);
        // C s_1809_2: const #9u : u8
        let s_1809_2: u8 = 9;
        // C s_1809_3: cast zx s_1809_2 -> bv
        let s_1809_3: Bits = Bits::new(s_1809_2 as u128, 4u16);
        // D s_1809_4: cmp-eq s_1809_1 s_1809_3
        let s_1809_4: bool = ((s_1809_1) == (s_1809_3));
        // N s_1809_5: branch s_1809_4 b4665 b1810
        if s_1809_4 {
            return block_4665(state, tracer, fn_state);
        } else {
            return block_1810(state, tracer, fn_state);
        };
    }
    fn block_1810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1810_0: const #0u : u8
        let s_1810_0: bool = false;
        // D s_1810_1: write-var gs#118352 <= s_1810_0
        fn_state.gs_118352 = s_1810_0;
        // N s_1810_2: jump b1811
        return block_1811(state, tracer, fn_state);
    }
    fn block_1811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1811_0: read-var gs#118352:u8
        let s_1811_0: bool = fn_state.gs_118352;
        // N s_1811_1: branch s_1811_0 b4664 b1812
        if s_1811_0 {
            return block_4664(state, tracer, fn_state);
        } else {
            return block_1812(state, tracer, fn_state);
        };
    }
    fn block_1812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1812_0: const #0u : u8
        let s_1812_0: bool = false;
        // D s_1812_1: write-var gs#118353 <= s_1812_0
        fn_state.gs_118353 = s_1812_0;
        // N s_1812_2: jump b1813
        return block_1813(state, tracer, fn_state);
    }
    fn block_1813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1813_0: read-var gs#118353:u8
        let s_1813_0: bool = fn_state.gs_118353;
        // N s_1813_1: branch s_1813_0 b4663 b1814
        if s_1813_0 {
            return block_4663(state, tracer, fn_state);
        } else {
            return block_1814(state, tracer, fn_state);
        };
    }
    fn block_1814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1814_0: const #0u : u8
        let s_1814_0: bool = false;
        // D s_1814_1: write-var gs#118354 <= s_1814_0
        fn_state.gs_118354 = s_1814_0;
        // N s_1814_2: jump b1815
        return block_1815(state, tracer, fn_state);
    }
    fn block_1815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1815_0: read-var gs#118354:u8
        let s_1815_0: bool = fn_state.gs_118354;
        // N s_1815_1: branch s_1815_0 b4662 b1816
        if s_1815_0 {
            return block_4662(state, tracer, fn_state);
        } else {
            return block_1816(state, tracer, fn_state);
        };
    }
    fn block_1816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1816_0: const #0u : u8
        let s_1816_0: bool = false;
        // D s_1816_1: write-var gs#118355 <= s_1816_0
        fn_state.gs_118355 = s_1816_0;
        // N s_1816_2: jump b1817
        return block_1817(state, tracer, fn_state);
    }
    fn block_1817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1817_0: read-var gs#118355:u8
        let s_1817_0: bool = fn_state.gs_118355;
        // N s_1817_1: branch s_1817_0 b4661 b1818
        if s_1817_0 {
            return block_4661(state, tracer, fn_state);
        } else {
            return block_1818(state, tracer, fn_state);
        };
    }
    fn block_1818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1818_0: read-var CRm:u8
        let s_1818_0: u8 = fn_state.CRm;
        // D s_1818_1: cast zx s_1818_0 -> bv
        let s_1818_1: Bits = Bits::new(s_1818_0 as u128, 4u16);
        // C s_1818_2: const #15u : u8
        let s_1818_2: u8 = 15;
        // C s_1818_3: cast zx s_1818_2 -> bv
        let s_1818_3: Bits = Bits::new(s_1818_2 as u128, 4u16);
        // D s_1818_4: cmp-eq s_1818_1 s_1818_3
        let s_1818_4: bool = ((s_1818_1) == (s_1818_3));
        // N s_1818_5: branch s_1818_4 b4660 b1819
        if s_1818_4 {
            return block_4660(state, tracer, fn_state);
        } else {
            return block_1819(state, tracer, fn_state);
        };
    }
    fn block_1819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1819_0: const #0u : u8
        let s_1819_0: bool = false;
        // D s_1819_1: write-var gs#118356 <= s_1819_0
        fn_state.gs_118356 = s_1819_0;
        // N s_1819_2: jump b1820
        return block_1820(state, tracer, fn_state);
    }
    fn block_1820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1820_0: read-var gs#118356:u8
        let s_1820_0: bool = fn_state.gs_118356;
        // N s_1820_1: branch s_1820_0 b4659 b1821
        if s_1820_0 {
            return block_4659(state, tracer, fn_state);
        } else {
            return block_1821(state, tracer, fn_state);
        };
    }
    fn block_1821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1821_0: const #0u : u8
        let s_1821_0: bool = false;
        // D s_1821_1: write-var gs#118357 <= s_1821_0
        fn_state.gs_118357 = s_1821_0;
        // N s_1821_2: jump b1822
        return block_1822(state, tracer, fn_state);
    }
    fn block_1822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1822_0: read-var gs#118357:u8
        let s_1822_0: bool = fn_state.gs_118357;
        // N s_1822_1: branch s_1822_0 b4658 b1823
        if s_1822_0 {
            return block_4658(state, tracer, fn_state);
        } else {
            return block_1823(state, tracer, fn_state);
        };
    }
    fn block_1823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1823_0: const #0u : u8
        let s_1823_0: bool = false;
        // D s_1823_1: write-var gs#118358 <= s_1823_0
        fn_state.gs_118358 = s_1823_0;
        // N s_1823_2: jump b1824
        return block_1824(state, tracer, fn_state);
    }
    fn block_1824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1824_0: read-var gs#118358:u8
        let s_1824_0: bool = fn_state.gs_118358;
        // N s_1824_1: branch s_1824_0 b4657 b1825
        if s_1824_0 {
            return block_4657(state, tracer, fn_state);
        } else {
            return block_1825(state, tracer, fn_state);
        };
    }
    fn block_1825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1825_0: const #0u : u8
        let s_1825_0: bool = false;
        // D s_1825_1: write-var gs#118359 <= s_1825_0
        fn_state.gs_118359 = s_1825_0;
        // N s_1825_2: jump b1826
        return block_1826(state, tracer, fn_state);
    }
    fn block_1826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1826_0: read-var gs#118359:u8
        let s_1826_0: bool = fn_state.gs_118359;
        // N s_1826_1: branch s_1826_0 b4656 b1827
        if s_1826_0 {
            return block_4656(state, tracer, fn_state);
        } else {
            return block_1827(state, tracer, fn_state);
        };
    }
    fn block_1827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1827_0: read-var CRm:u8
        let s_1827_0: u8 = fn_state.CRm;
        // D s_1827_1: cast zx s_1827_0 -> bv
        let s_1827_1: Bits = Bits::new(s_1827_0 as u128, 4u16);
        // C s_1827_2: const #8u : u8
        let s_1827_2: u8 = 8;
        // C s_1827_3: cast zx s_1827_2 -> bv
        let s_1827_3: Bits = Bits::new(s_1827_2 as u128, 4u16);
        // D s_1827_4: cmp-eq s_1827_1 s_1827_3
        let s_1827_4: bool = ((s_1827_1) == (s_1827_3));
        // N s_1827_5: branch s_1827_4 b4655 b1828
        if s_1827_4 {
            return block_4655(state, tracer, fn_state);
        } else {
            return block_1828(state, tracer, fn_state);
        };
    }
    fn block_1828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1828_0: const #0u : u8
        let s_1828_0: bool = false;
        // D s_1828_1: write-var gs#118360 <= s_1828_0
        fn_state.gs_118360 = s_1828_0;
        // N s_1828_2: jump b1829
        return block_1829(state, tracer, fn_state);
    }
    fn block_1829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1829_0: read-var gs#118360:u8
        let s_1829_0: bool = fn_state.gs_118360;
        // N s_1829_1: branch s_1829_0 b4654 b1830
        if s_1829_0 {
            return block_4654(state, tracer, fn_state);
        } else {
            return block_1830(state, tracer, fn_state);
        };
    }
    fn block_1830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1830_0: const #0u : u8
        let s_1830_0: bool = false;
        // D s_1830_1: write-var gs#118361 <= s_1830_0
        fn_state.gs_118361 = s_1830_0;
        // N s_1830_2: jump b1831
        return block_1831(state, tracer, fn_state);
    }
    fn block_1831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1831_0: read-var gs#118361:u8
        let s_1831_0: bool = fn_state.gs_118361;
        // N s_1831_1: branch s_1831_0 b4653 b1832
        if s_1831_0 {
            return block_4653(state, tracer, fn_state);
        } else {
            return block_1832(state, tracer, fn_state);
        };
    }
    fn block_1832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1832_0: const #0u : u8
        let s_1832_0: bool = false;
        // D s_1832_1: write-var gs#118362 <= s_1832_0
        fn_state.gs_118362 = s_1832_0;
        // N s_1832_2: jump b1833
        return block_1833(state, tracer, fn_state);
    }
    fn block_1833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1833_0: read-var gs#118362:u8
        let s_1833_0: bool = fn_state.gs_118362;
        // N s_1833_1: branch s_1833_0 b4652 b1834
        if s_1833_0 {
            return block_4652(state, tracer, fn_state);
        } else {
            return block_1834(state, tracer, fn_state);
        };
    }
    fn block_1834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1834_0: const #0u : u8
        let s_1834_0: bool = false;
        // D s_1834_1: write-var gs#118363 <= s_1834_0
        fn_state.gs_118363 = s_1834_0;
        // N s_1834_2: jump b1835
        return block_1835(state, tracer, fn_state);
    }
    fn block_1835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1835_0: read-var gs#118363:u8
        let s_1835_0: bool = fn_state.gs_118363;
        // N s_1835_1: branch s_1835_0 b4651 b1836
        if s_1835_0 {
            return block_4651(state, tracer, fn_state);
        } else {
            return block_1836(state, tracer, fn_state);
        };
    }
    fn block_1836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1836_0: read-var CRm:u8
        let s_1836_0: u8 = fn_state.CRm;
        // D s_1836_1: cast zx s_1836_0 -> bv
        let s_1836_1: Bits = Bits::new(s_1836_0 as u128, 4u16);
        // C s_1836_2: const #8u : u8
        let s_1836_2: u8 = 8;
        // C s_1836_3: cast zx s_1836_2 -> bv
        let s_1836_3: Bits = Bits::new(s_1836_2 as u128, 4u16);
        // D s_1836_4: cmp-eq s_1836_1 s_1836_3
        let s_1836_4: bool = ((s_1836_1) == (s_1836_3));
        // N s_1836_5: branch s_1836_4 b4650 b1837
        if s_1836_4 {
            return block_4650(state, tracer, fn_state);
        } else {
            return block_1837(state, tracer, fn_state);
        };
    }
    fn block_1837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1837_0: const #0u : u8
        let s_1837_0: bool = false;
        // D s_1837_1: write-var gs#118364 <= s_1837_0
        fn_state.gs_118364 = s_1837_0;
        // N s_1837_2: jump b1838
        return block_1838(state, tracer, fn_state);
    }
    fn block_1838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1838_0: read-var gs#118364:u8
        let s_1838_0: bool = fn_state.gs_118364;
        // N s_1838_1: branch s_1838_0 b4649 b1839
        if s_1838_0 {
            return block_4649(state, tracer, fn_state);
        } else {
            return block_1839(state, tracer, fn_state);
        };
    }
    fn block_1839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1839_0: const #0u : u8
        let s_1839_0: bool = false;
        // D s_1839_1: write-var gs#118365 <= s_1839_0
        fn_state.gs_118365 = s_1839_0;
        // N s_1839_2: jump b1840
        return block_1840(state, tracer, fn_state);
    }
    fn block_1840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1840_0: read-var gs#118365:u8
        let s_1840_0: bool = fn_state.gs_118365;
        // N s_1840_1: branch s_1840_0 b4648 b1841
        if s_1840_0 {
            return block_4648(state, tracer, fn_state);
        } else {
            return block_1841(state, tracer, fn_state);
        };
    }
    fn block_1841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1841_0: const #0u : u8
        let s_1841_0: bool = false;
        // D s_1841_1: write-var gs#118366 <= s_1841_0
        fn_state.gs_118366 = s_1841_0;
        // N s_1841_2: jump b1842
        return block_1842(state, tracer, fn_state);
    }
    fn block_1842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1842_0: read-var gs#118366:u8
        let s_1842_0: bool = fn_state.gs_118366;
        // N s_1842_1: branch s_1842_0 b4647 b1843
        if s_1842_0 {
            return block_4647(state, tracer, fn_state);
        } else {
            return block_1843(state, tracer, fn_state);
        };
    }
    fn block_1843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1843_0: const #0u : u8
        let s_1843_0: bool = false;
        // D s_1843_1: write-var gs#118367 <= s_1843_0
        fn_state.gs_118367 = s_1843_0;
        // N s_1843_2: jump b1844
        return block_1844(state, tracer, fn_state);
    }
    fn block_1844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1844_0: read-var gs#118367:u8
        let s_1844_0: bool = fn_state.gs_118367;
        // N s_1844_1: branch s_1844_0 b4646 b1845
        if s_1844_0 {
            return block_4646(state, tracer, fn_state);
        } else {
            return block_1845(state, tracer, fn_state);
        };
    }
    fn block_1845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1845_0: read-var CRm:u8
        let s_1845_0: u8 = fn_state.CRm;
        // D s_1845_1: cast zx s_1845_0 -> bv
        let s_1845_1: Bits = Bits::new(s_1845_0 as u128, 4u16);
        // C s_1845_2: const #8u : u8
        let s_1845_2: u8 = 8;
        // C s_1845_3: cast zx s_1845_2 -> bv
        let s_1845_3: Bits = Bits::new(s_1845_2 as u128, 4u16);
        // D s_1845_4: cmp-eq s_1845_1 s_1845_3
        let s_1845_4: bool = ((s_1845_1) == (s_1845_3));
        // N s_1845_5: branch s_1845_4 b4645 b1846
        if s_1845_4 {
            return block_4645(state, tracer, fn_state);
        } else {
            return block_1846(state, tracer, fn_state);
        };
    }
    fn block_1846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1846_0: const #0u : u8
        let s_1846_0: bool = false;
        // D s_1846_1: write-var gs#118368 <= s_1846_0
        fn_state.gs_118368 = s_1846_0;
        // N s_1846_2: jump b1847
        return block_1847(state, tracer, fn_state);
    }
    fn block_1847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1847_0: read-var gs#118368:u8
        let s_1847_0: bool = fn_state.gs_118368;
        // N s_1847_1: branch s_1847_0 b4644 b1848
        if s_1847_0 {
            return block_4644(state, tracer, fn_state);
        } else {
            return block_1848(state, tracer, fn_state);
        };
    }
    fn block_1848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1848_0: const #0u : u8
        let s_1848_0: bool = false;
        // D s_1848_1: write-var gs#118369 <= s_1848_0
        fn_state.gs_118369 = s_1848_0;
        // N s_1848_2: jump b1849
        return block_1849(state, tracer, fn_state);
    }
    fn block_1849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1849_0: read-var gs#118369:u8
        let s_1849_0: bool = fn_state.gs_118369;
        // N s_1849_1: branch s_1849_0 b4643 b1850
        if s_1849_0 {
            return block_4643(state, tracer, fn_state);
        } else {
            return block_1850(state, tracer, fn_state);
        };
    }
    fn block_1850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1850_0: const #0u : u8
        let s_1850_0: bool = false;
        // D s_1850_1: write-var gs#118370 <= s_1850_0
        fn_state.gs_118370 = s_1850_0;
        // N s_1850_2: jump b1851
        return block_1851(state, tracer, fn_state);
    }
    fn block_1851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1851_0: read-var gs#118370:u8
        let s_1851_0: bool = fn_state.gs_118370;
        // N s_1851_1: branch s_1851_0 b4642 b1852
        if s_1851_0 {
            return block_4642(state, tracer, fn_state);
        } else {
            return block_1852(state, tracer, fn_state);
        };
    }
    fn block_1852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1852_0: const #0u : u8
        let s_1852_0: bool = false;
        // D s_1852_1: write-var gs#118371 <= s_1852_0
        fn_state.gs_118371 = s_1852_0;
        // N s_1852_2: jump b1853
        return block_1853(state, tracer, fn_state);
    }
    fn block_1853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1853_0: read-var gs#118371:u8
        let s_1853_0: bool = fn_state.gs_118371;
        // N s_1853_1: branch s_1853_0 b4641 b1854
        if s_1853_0 {
            return block_4641(state, tracer, fn_state);
        } else {
            return block_1854(state, tracer, fn_state);
        };
    }
    fn block_1854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1854_0: read-var CRm:u8
        let s_1854_0: u8 = fn_state.CRm;
        // D s_1854_1: cast zx s_1854_0 -> bv
        let s_1854_1: Bits = Bits::new(s_1854_0 as u128, 4u16);
        // C s_1854_2: const #8u : u8
        let s_1854_2: u8 = 8;
        // C s_1854_3: cast zx s_1854_2 -> bv
        let s_1854_3: Bits = Bits::new(s_1854_2 as u128, 4u16);
        // D s_1854_4: cmp-eq s_1854_1 s_1854_3
        let s_1854_4: bool = ((s_1854_1) == (s_1854_3));
        // N s_1854_5: branch s_1854_4 b4640 b1855
        if s_1854_4 {
            return block_4640(state, tracer, fn_state);
        } else {
            return block_1855(state, tracer, fn_state);
        };
    }
    fn block_1855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1855_0: const #0u : u8
        let s_1855_0: bool = false;
        // D s_1855_1: write-var gs#118372 <= s_1855_0
        fn_state.gs_118372 = s_1855_0;
        // N s_1855_2: jump b1856
        return block_1856(state, tracer, fn_state);
    }
    fn block_1856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1856_0: read-var gs#118372:u8
        let s_1856_0: bool = fn_state.gs_118372;
        // N s_1856_1: branch s_1856_0 b4639 b1857
        if s_1856_0 {
            return block_4639(state, tracer, fn_state);
        } else {
            return block_1857(state, tracer, fn_state);
        };
    }
    fn block_1857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1857_0: const #0u : u8
        let s_1857_0: bool = false;
        // D s_1857_1: write-var gs#118373 <= s_1857_0
        fn_state.gs_118373 = s_1857_0;
        // N s_1857_2: jump b1858
        return block_1858(state, tracer, fn_state);
    }
    fn block_1858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1858_0: read-var gs#118373:u8
        let s_1858_0: bool = fn_state.gs_118373;
        // N s_1858_1: branch s_1858_0 b4638 b1859
        if s_1858_0 {
            return block_4638(state, tracer, fn_state);
        } else {
            return block_1859(state, tracer, fn_state);
        };
    }
    fn block_1859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1859_0: const #0u : u8
        let s_1859_0: bool = false;
        // D s_1859_1: write-var gs#118374 <= s_1859_0
        fn_state.gs_118374 = s_1859_0;
        // N s_1859_2: jump b1860
        return block_1860(state, tracer, fn_state);
    }
    fn block_1860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1860_0: read-var gs#118374:u8
        let s_1860_0: bool = fn_state.gs_118374;
        // N s_1860_1: branch s_1860_0 b4637 b1861
        if s_1860_0 {
            return block_4637(state, tracer, fn_state);
        } else {
            return block_1861(state, tracer, fn_state);
        };
    }
    fn block_1861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1861_0: const #0u : u8
        let s_1861_0: bool = false;
        // D s_1861_1: write-var gs#118375 <= s_1861_0
        fn_state.gs_118375 = s_1861_0;
        // N s_1861_2: jump b1862
        return block_1862(state, tracer, fn_state);
    }
    fn block_1862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1862_0: read-var gs#118375:u8
        let s_1862_0: bool = fn_state.gs_118375;
        // N s_1862_1: branch s_1862_0 b4636 b1863
        if s_1862_0 {
            return block_4636(state, tracer, fn_state);
        } else {
            return block_1863(state, tracer, fn_state);
        };
    }
    fn block_1863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1863_0: read-var CRm:u8
        let s_1863_0: u8 = fn_state.CRm;
        // D s_1863_1: cast zx s_1863_0 -> bv
        let s_1863_1: Bits = Bits::new(s_1863_0 as u128, 4u16);
        // C s_1863_2: const #2u : u8
        let s_1863_2: u8 = 2;
        // C s_1863_3: cast zx s_1863_2 -> bv
        let s_1863_3: Bits = Bits::new(s_1863_2 as u128, 4u16);
        // D s_1863_4: cmp-eq s_1863_1 s_1863_3
        let s_1863_4: bool = ((s_1863_1) == (s_1863_3));
        // N s_1863_5: branch s_1863_4 b4635 b1864
        if s_1863_4 {
            return block_4635(state, tracer, fn_state);
        } else {
            return block_1864(state, tracer, fn_state);
        };
    }
    fn block_1864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1864_0: const #0u : u8
        let s_1864_0: bool = false;
        // D s_1864_1: write-var gs#118376 <= s_1864_0
        fn_state.gs_118376 = s_1864_0;
        // N s_1864_2: jump b1865
        return block_1865(state, tracer, fn_state);
    }
    fn block_1865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1865_0: read-var gs#118376:u8
        let s_1865_0: bool = fn_state.gs_118376;
        // N s_1865_1: branch s_1865_0 b4634 b1866
        if s_1865_0 {
            return block_4634(state, tracer, fn_state);
        } else {
            return block_1866(state, tracer, fn_state);
        };
    }
    fn block_1866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1866_0: const #0u : u8
        let s_1866_0: bool = false;
        // D s_1866_1: write-var gs#118377 <= s_1866_0
        fn_state.gs_118377 = s_1866_0;
        // N s_1866_2: jump b1867
        return block_1867(state, tracer, fn_state);
    }
    fn block_1867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1867_0: read-var gs#118377:u8
        let s_1867_0: bool = fn_state.gs_118377;
        // N s_1867_1: branch s_1867_0 b4633 b1868
        if s_1867_0 {
            return block_4633(state, tracer, fn_state);
        } else {
            return block_1868(state, tracer, fn_state);
        };
    }
    fn block_1868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1868_0: const #0u : u8
        let s_1868_0: bool = false;
        // D s_1868_1: write-var gs#118378 <= s_1868_0
        fn_state.gs_118378 = s_1868_0;
        // N s_1868_2: jump b1869
        return block_1869(state, tracer, fn_state);
    }
    fn block_1869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1869_0: read-var gs#118378:u8
        let s_1869_0: bool = fn_state.gs_118378;
        // N s_1869_1: branch s_1869_0 b4632 b1870
        if s_1869_0 {
            return block_4632(state, tracer, fn_state);
        } else {
            return block_1870(state, tracer, fn_state);
        };
    }
    fn block_1870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1870_0: const #0u : u8
        let s_1870_0: bool = false;
        // D s_1870_1: write-var gs#118379 <= s_1870_0
        fn_state.gs_118379 = s_1870_0;
        // N s_1870_2: jump b1871
        return block_1871(state, tracer, fn_state);
    }
    fn block_1871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1871_0: read-var gs#118379:u8
        let s_1871_0: bool = fn_state.gs_118379;
        // N s_1871_1: branch s_1871_0 b4631 b1872
        if s_1871_0 {
            return block_4631(state, tracer, fn_state);
        } else {
            return block_1872(state, tracer, fn_state);
        };
    }
    fn block_1872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1872_0: read-var CRm:u8
        let s_1872_0: u8 = fn_state.CRm;
        // D s_1872_1: cast zx s_1872_0 -> bv
        let s_1872_1: Bits = Bits::new(s_1872_0 as u128, 4u16);
        // C s_1872_2: const #0u : u8
        let s_1872_2: u8 = 0;
        // C s_1872_3: cast zx s_1872_2 -> bv
        let s_1872_3: Bits = Bits::new(s_1872_2 as u128, 4u16);
        // D s_1872_4: cmp-eq s_1872_1 s_1872_3
        let s_1872_4: bool = ((s_1872_1) == (s_1872_3));
        // N s_1872_5: branch s_1872_4 b4630 b1873
        if s_1872_4 {
            return block_4630(state, tracer, fn_state);
        } else {
            return block_1873(state, tracer, fn_state);
        };
    }
    fn block_1873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1873_0: const #0u : u8
        let s_1873_0: bool = false;
        // D s_1873_1: write-var gs#118380 <= s_1873_0
        fn_state.gs_118380 = s_1873_0;
        // N s_1873_2: jump b1874
        return block_1874(state, tracer, fn_state);
    }
    fn block_1874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1874_0: read-var gs#118380:u8
        let s_1874_0: bool = fn_state.gs_118380;
        // N s_1874_1: branch s_1874_0 b4629 b1875
        if s_1874_0 {
            return block_4629(state, tracer, fn_state);
        } else {
            return block_1875(state, tracer, fn_state);
        };
    }
    fn block_1875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1875_0: const #0u : u8
        let s_1875_0: bool = false;
        // D s_1875_1: write-var gs#118381 <= s_1875_0
        fn_state.gs_118381 = s_1875_0;
        // N s_1875_2: jump b1876
        return block_1876(state, tracer, fn_state);
    }
    fn block_1876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1876_0: read-var gs#118381:u8
        let s_1876_0: bool = fn_state.gs_118381;
        // N s_1876_1: branch s_1876_0 b4628 b1877
        if s_1876_0 {
            return block_4628(state, tracer, fn_state);
        } else {
            return block_1877(state, tracer, fn_state);
        };
    }
    fn block_1877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1877_0: const #0u : u8
        let s_1877_0: bool = false;
        // D s_1877_1: write-var gs#118382 <= s_1877_0
        fn_state.gs_118382 = s_1877_0;
        // N s_1877_2: jump b1878
        return block_1878(state, tracer, fn_state);
    }
    fn block_1878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1878_0: read-var gs#118382:u8
        let s_1878_0: bool = fn_state.gs_118382;
        // N s_1878_1: branch s_1878_0 b4627 b1879
        if s_1878_0 {
            return block_4627(state, tracer, fn_state);
        } else {
            return block_1879(state, tracer, fn_state);
        };
    }
    fn block_1879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1879_0: const #0u : u8
        let s_1879_0: bool = false;
        // D s_1879_1: write-var gs#118383 <= s_1879_0
        fn_state.gs_118383 = s_1879_0;
        // N s_1879_2: jump b1880
        return block_1880(state, tracer, fn_state);
    }
    fn block_1880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1880_0: read-var gs#118383:u8
        let s_1880_0: bool = fn_state.gs_118383;
        // N s_1880_1: branch s_1880_0 b4626 b1881
        if s_1880_0 {
            return block_4626(state, tracer, fn_state);
        } else {
            return block_1881(state, tracer, fn_state);
        };
    }
    fn block_1881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1881_0: read-var CRm:u8
        let s_1881_0: u8 = fn_state.CRm;
        // D s_1881_1: cast zx s_1881_0 -> bv
        let s_1881_1: Bits = Bits::new(s_1881_0 as u128, 4u16);
        // C s_1881_2: const #0u : u8
        let s_1881_2: u8 = 0;
        // C s_1881_3: cast zx s_1881_2 -> bv
        let s_1881_3: Bits = Bits::new(s_1881_2 as u128, 4u16);
        // D s_1881_4: cmp-eq s_1881_1 s_1881_3
        let s_1881_4: bool = ((s_1881_1) == (s_1881_3));
        // N s_1881_5: branch s_1881_4 b4625 b1882
        if s_1881_4 {
            return block_4625(state, tracer, fn_state);
        } else {
            return block_1882(state, tracer, fn_state);
        };
    }
    fn block_1882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1882_0: const #0u : u8
        let s_1882_0: bool = false;
        // D s_1882_1: write-var gs#118384 <= s_1882_0
        fn_state.gs_118384 = s_1882_0;
        // N s_1882_2: jump b1883
        return block_1883(state, tracer, fn_state);
    }
    fn block_1883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1883_0: read-var gs#118384:u8
        let s_1883_0: bool = fn_state.gs_118384;
        // N s_1883_1: branch s_1883_0 b4624 b1884
        if s_1883_0 {
            return block_4624(state, tracer, fn_state);
        } else {
            return block_1884(state, tracer, fn_state);
        };
    }
    fn block_1884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1884_0: const #0u : u8
        let s_1884_0: bool = false;
        // D s_1884_1: write-var gs#118385 <= s_1884_0
        fn_state.gs_118385 = s_1884_0;
        // N s_1884_2: jump b1885
        return block_1885(state, tracer, fn_state);
    }
    fn block_1885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1885_0: read-var gs#118385:u8
        let s_1885_0: bool = fn_state.gs_118385;
        // N s_1885_1: branch s_1885_0 b4623 b1886
        if s_1885_0 {
            return block_4623(state, tracer, fn_state);
        } else {
            return block_1886(state, tracer, fn_state);
        };
    }
    fn block_1886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1886_0: const #0u : u8
        let s_1886_0: bool = false;
        // D s_1886_1: write-var gs#118386 <= s_1886_0
        fn_state.gs_118386 = s_1886_0;
        // N s_1886_2: jump b1887
        return block_1887(state, tracer, fn_state);
    }
    fn block_1887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1887_0: read-var gs#118386:u8
        let s_1887_0: bool = fn_state.gs_118386;
        // N s_1887_1: branch s_1887_0 b4622 b1888
        if s_1887_0 {
            return block_4622(state, tracer, fn_state);
        } else {
            return block_1888(state, tracer, fn_state);
        };
    }
    fn block_1888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1888_0: const #0u : u8
        let s_1888_0: bool = false;
        // D s_1888_1: write-var gs#118387 <= s_1888_0
        fn_state.gs_118387 = s_1888_0;
        // N s_1888_2: jump b1889
        return block_1889(state, tracer, fn_state);
    }
    fn block_1889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1889_0: read-var gs#118387:u8
        let s_1889_0: bool = fn_state.gs_118387;
        // N s_1889_1: branch s_1889_0 b4621 b1890
        if s_1889_0 {
            return block_4621(state, tracer, fn_state);
        } else {
            return block_1890(state, tracer, fn_state);
        };
    }
    fn block_1890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1890_0: read-var CRm:u8
        let s_1890_0: u8 = fn_state.CRm;
        // D s_1890_1: cast zx s_1890_0 -> bv
        let s_1890_1: Bits = Bits::new(s_1890_0 as u128, 4u16);
        // C s_1890_2: const #6u : u8
        let s_1890_2: u8 = 6;
        // C s_1890_3: cast zx s_1890_2 -> bv
        let s_1890_3: Bits = Bits::new(s_1890_2 as u128, 4u16);
        // D s_1890_4: cmp-eq s_1890_1 s_1890_3
        let s_1890_4: bool = ((s_1890_1) == (s_1890_3));
        // N s_1890_5: branch s_1890_4 b4620 b1891
        if s_1890_4 {
            return block_4620(state, tracer, fn_state);
        } else {
            return block_1891(state, tracer, fn_state);
        };
    }
    fn block_1891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1891_0: const #0u : u8
        let s_1891_0: bool = false;
        // D s_1891_1: write-var gs#118388 <= s_1891_0
        fn_state.gs_118388 = s_1891_0;
        // N s_1891_2: jump b1892
        return block_1892(state, tracer, fn_state);
    }
    fn block_1892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1892_0: read-var gs#118388:u8
        let s_1892_0: bool = fn_state.gs_118388;
        // N s_1892_1: branch s_1892_0 b4619 b1893
        if s_1892_0 {
            return block_4619(state, tracer, fn_state);
        } else {
            return block_1893(state, tracer, fn_state);
        };
    }
    fn block_1893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1893_0: const #0u : u8
        let s_1893_0: bool = false;
        // D s_1893_1: write-var gs#118389 <= s_1893_0
        fn_state.gs_118389 = s_1893_0;
        // N s_1893_2: jump b1894
        return block_1894(state, tracer, fn_state);
    }
    fn block_1894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1894_0: read-var gs#118389:u8
        let s_1894_0: bool = fn_state.gs_118389;
        // N s_1894_1: branch s_1894_0 b4618 b1895
        if s_1894_0 {
            return block_4618(state, tracer, fn_state);
        } else {
            return block_1895(state, tracer, fn_state);
        };
    }
    fn block_1895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1895_0: const #0u : u8
        let s_1895_0: bool = false;
        // D s_1895_1: write-var gs#118390 <= s_1895_0
        fn_state.gs_118390 = s_1895_0;
        // N s_1895_2: jump b1896
        return block_1896(state, tracer, fn_state);
    }
    fn block_1896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1896_0: read-var gs#118390:u8
        let s_1896_0: bool = fn_state.gs_118390;
        // N s_1896_1: branch s_1896_0 b4617 b1897
        if s_1896_0 {
            return block_4617(state, tracer, fn_state);
        } else {
            return block_1897(state, tracer, fn_state);
        };
    }
    fn block_1897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1897_0: const #0u : u8
        let s_1897_0: bool = false;
        // D s_1897_1: write-var gs#118391 <= s_1897_0
        fn_state.gs_118391 = s_1897_0;
        // N s_1897_2: jump b1898
        return block_1898(state, tracer, fn_state);
    }
    fn block_1898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1898_0: read-var gs#118391:u8
        let s_1898_0: bool = fn_state.gs_118391;
        // N s_1898_1: branch s_1898_0 b4616 b1899
        if s_1898_0 {
            return block_4616(state, tracer, fn_state);
        } else {
            return block_1899(state, tracer, fn_state);
        };
    }
    fn block_1899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1899_0: read-var CRm:u8
        let s_1899_0: u8 = fn_state.CRm;
        // D s_1899_1: cast zx s_1899_0 -> bv
        let s_1899_1: Bits = Bits::new(s_1899_0 as u128, 4u16);
        // C s_1899_2: const #1u : u8
        let s_1899_2: u8 = 1;
        // C s_1899_3: cast zx s_1899_2 -> bv
        let s_1899_3: Bits = Bits::new(s_1899_2 as u128, 4u16);
        // D s_1899_4: cmp-eq s_1899_1 s_1899_3
        let s_1899_4: bool = ((s_1899_1) == (s_1899_3));
        // N s_1899_5: branch s_1899_4 b4615 b1900
        if s_1899_4 {
            return block_4615(state, tracer, fn_state);
        } else {
            return block_1900(state, tracer, fn_state);
        };
    }
    fn block_1900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1900_0: const #0u : u8
        let s_1900_0: bool = false;
        // D s_1900_1: write-var gs#118392 <= s_1900_0
        fn_state.gs_118392 = s_1900_0;
        // N s_1900_2: jump b1901
        return block_1901(state, tracer, fn_state);
    }
    fn block_1901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1901_0: read-var gs#118392:u8
        let s_1901_0: bool = fn_state.gs_118392;
        // N s_1901_1: branch s_1901_0 b4614 b1902
        if s_1901_0 {
            return block_4614(state, tracer, fn_state);
        } else {
            return block_1902(state, tracer, fn_state);
        };
    }
    fn block_1902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1902_0: const #0u : u8
        let s_1902_0: bool = false;
        // D s_1902_1: write-var gs#118393 <= s_1902_0
        fn_state.gs_118393 = s_1902_0;
        // N s_1902_2: jump b1903
        return block_1903(state, tracer, fn_state);
    }
    fn block_1903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1903_0: read-var gs#118393:u8
        let s_1903_0: bool = fn_state.gs_118393;
        // N s_1903_1: branch s_1903_0 b4613 b1904
        if s_1903_0 {
            return block_4613(state, tracer, fn_state);
        } else {
            return block_1904(state, tracer, fn_state);
        };
    }
    fn block_1904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1904_0: const #0u : u8
        let s_1904_0: bool = false;
        // D s_1904_1: write-var gs#118394 <= s_1904_0
        fn_state.gs_118394 = s_1904_0;
        // N s_1904_2: jump b1905
        return block_1905(state, tracer, fn_state);
    }
    fn block_1905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1905_0: read-var gs#118394:u8
        let s_1905_0: bool = fn_state.gs_118394;
        // N s_1905_1: branch s_1905_0 b4612 b1906
        if s_1905_0 {
            return block_4612(state, tracer, fn_state);
        } else {
            return block_1906(state, tracer, fn_state);
        };
    }
    fn block_1906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1906_0: const #0u : u8
        let s_1906_0: bool = false;
        // D s_1906_1: write-var gs#118395 <= s_1906_0
        fn_state.gs_118395 = s_1906_0;
        // N s_1906_2: jump b1907
        return block_1907(state, tracer, fn_state);
    }
    fn block_1907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1907_0: read-var gs#118395:u8
        let s_1907_0: bool = fn_state.gs_118395;
        // N s_1907_1: branch s_1907_0 b4611 b1908
        if s_1907_0 {
            return block_4611(state, tracer, fn_state);
        } else {
            return block_1908(state, tracer, fn_state);
        };
    }
    fn block_1908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1908_0: read-var CRm:u8
        let s_1908_0: u8 = fn_state.CRm;
        // D s_1908_1: cast zx s_1908_0 -> bv
        let s_1908_1: Bits = Bits::new(s_1908_0 as u128, 4u16);
        // C s_1908_2: const #11u : u8
        let s_1908_2: u8 = 11;
        // C s_1908_3: cast zx s_1908_2 -> bv
        let s_1908_3: Bits = Bits::new(s_1908_2 as u128, 4u16);
        // D s_1908_4: cmp-eq s_1908_1 s_1908_3
        let s_1908_4: bool = ((s_1908_1) == (s_1908_3));
        // N s_1908_5: branch s_1908_4 b4610 b1909
        if s_1908_4 {
            return block_4610(state, tracer, fn_state);
        } else {
            return block_1909(state, tracer, fn_state);
        };
    }
    fn block_1909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1909_0: const #0u : u8
        let s_1909_0: bool = false;
        // D s_1909_1: write-var gs#118396 <= s_1909_0
        fn_state.gs_118396 = s_1909_0;
        // N s_1909_2: jump b1910
        return block_1910(state, tracer, fn_state);
    }
    fn block_1910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1910_0: read-var gs#118396:u8
        let s_1910_0: bool = fn_state.gs_118396;
        // N s_1910_1: branch s_1910_0 b4609 b1911
        if s_1910_0 {
            return block_4609(state, tracer, fn_state);
        } else {
            return block_1911(state, tracer, fn_state);
        };
    }
    fn block_1911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1911_0: const #0u : u8
        let s_1911_0: bool = false;
        // D s_1911_1: write-var gs#118397 <= s_1911_0
        fn_state.gs_118397 = s_1911_0;
        // N s_1911_2: jump b1912
        return block_1912(state, tracer, fn_state);
    }
    fn block_1912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1912_0: read-var gs#118397:u8
        let s_1912_0: bool = fn_state.gs_118397;
        // N s_1912_1: branch s_1912_0 b4608 b1913
        if s_1912_0 {
            return block_4608(state, tracer, fn_state);
        } else {
            return block_1913(state, tracer, fn_state);
        };
    }
    fn block_1913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1913_0: const #0u : u8
        let s_1913_0: bool = false;
        // D s_1913_1: write-var gs#118398 <= s_1913_0
        fn_state.gs_118398 = s_1913_0;
        // N s_1913_2: jump b1914
        return block_1914(state, tracer, fn_state);
    }
    fn block_1914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1914_0: read-var gs#118398:u8
        let s_1914_0: bool = fn_state.gs_118398;
        // N s_1914_1: branch s_1914_0 b4607 b1915
        if s_1914_0 {
            return block_4607(state, tracer, fn_state);
        } else {
            return block_1915(state, tracer, fn_state);
        };
    }
    fn block_1915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1915_0: const #0u : u8
        let s_1915_0: bool = false;
        // D s_1915_1: write-var gs#118399 <= s_1915_0
        fn_state.gs_118399 = s_1915_0;
        // N s_1915_2: jump b1916
        return block_1916(state, tracer, fn_state);
    }
    fn block_1916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1916_0: read-var gs#118399:u8
        let s_1916_0: bool = fn_state.gs_118399;
        // N s_1916_1: branch s_1916_0 b4606 b1917
        if s_1916_0 {
            return block_4606(state, tracer, fn_state);
        } else {
            return block_1917(state, tracer, fn_state);
        };
    }
    fn block_1917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1917_0: read-var CRm:u8
        let s_1917_0: u8 = fn_state.CRm;
        // D s_1917_1: cast zx s_1917_0 -> bv
        let s_1917_1: Bits = Bits::new(s_1917_0 as u128, 4u16);
        // C s_1917_2: const #0u : u8
        let s_1917_2: u8 = 0;
        // C s_1917_3: cast zx s_1917_2 -> bv
        let s_1917_3: Bits = Bits::new(s_1917_2 as u128, 4u16);
        // D s_1917_4: cmp-eq s_1917_1 s_1917_3
        let s_1917_4: bool = ((s_1917_1) == (s_1917_3));
        // N s_1917_5: branch s_1917_4 b4605 b1918
        if s_1917_4 {
            return block_4605(state, tracer, fn_state);
        } else {
            return block_1918(state, tracer, fn_state);
        };
    }
    fn block_1918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1918_0: const #0u : u8
        let s_1918_0: bool = false;
        // D s_1918_1: write-var gs#118400 <= s_1918_0
        fn_state.gs_118400 = s_1918_0;
        // N s_1918_2: jump b1919
        return block_1919(state, tracer, fn_state);
    }
    fn block_1919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1919_0: read-var gs#118400:u8
        let s_1919_0: bool = fn_state.gs_118400;
        // N s_1919_1: branch s_1919_0 b4604 b1920
        if s_1919_0 {
            return block_4604(state, tracer, fn_state);
        } else {
            return block_1920(state, tracer, fn_state);
        };
    }
    fn block_1920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1920_0: const #0u : u8
        let s_1920_0: bool = false;
        // D s_1920_1: write-var gs#118401 <= s_1920_0
        fn_state.gs_118401 = s_1920_0;
        // N s_1920_2: jump b1921
        return block_1921(state, tracer, fn_state);
    }
    fn block_1921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1921_0: read-var gs#118401:u8
        let s_1921_0: bool = fn_state.gs_118401;
        // N s_1921_1: branch s_1921_0 b4603 b1922
        if s_1921_0 {
            return block_4603(state, tracer, fn_state);
        } else {
            return block_1922(state, tracer, fn_state);
        };
    }
    fn block_1922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1922_0: const #0u : u8
        let s_1922_0: bool = false;
        // D s_1922_1: write-var gs#118402 <= s_1922_0
        fn_state.gs_118402 = s_1922_0;
        // N s_1922_2: jump b1923
        return block_1923(state, tracer, fn_state);
    }
    fn block_1923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1923_0: read-var gs#118402:u8
        let s_1923_0: bool = fn_state.gs_118402;
        // N s_1923_1: branch s_1923_0 b4602 b1924
        if s_1923_0 {
            return block_4602(state, tracer, fn_state);
        } else {
            return block_1924(state, tracer, fn_state);
        };
    }
    fn block_1924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1924_0: const #0u : u8
        let s_1924_0: bool = false;
        // D s_1924_1: write-var gs#118403 <= s_1924_0
        fn_state.gs_118403 = s_1924_0;
        // N s_1924_2: jump b1925
        return block_1925(state, tracer, fn_state);
    }
    fn block_1925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1925_0: read-var gs#118403:u8
        let s_1925_0: bool = fn_state.gs_118403;
        // N s_1925_1: branch s_1925_0 b4601 b1926
        if s_1925_0 {
            return block_4601(state, tracer, fn_state);
        } else {
            return block_1926(state, tracer, fn_state);
        };
    }
    fn block_1926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1926_0: read-var CRm:u8
        let s_1926_0: u8 = fn_state.CRm;
        // D s_1926_1: cast zx s_1926_0 -> bv
        let s_1926_1: Bits = Bits::new(s_1926_0 as u128, 4u16);
        // C s_1926_2: const #2u : u8
        let s_1926_2: u8 = 2;
        // C s_1926_3: cast zx s_1926_2 -> bv
        let s_1926_3: Bits = Bits::new(s_1926_2 as u128, 4u16);
        // D s_1926_4: cmp-eq s_1926_1 s_1926_3
        let s_1926_4: bool = ((s_1926_1) == (s_1926_3));
        // N s_1926_5: branch s_1926_4 b4600 b1927
        if s_1926_4 {
            return block_4600(state, tracer, fn_state);
        } else {
            return block_1927(state, tracer, fn_state);
        };
    }
    fn block_1927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1927_0: const #0u : u8
        let s_1927_0: bool = false;
        // D s_1927_1: write-var gs#118404 <= s_1927_0
        fn_state.gs_118404 = s_1927_0;
        // N s_1927_2: jump b1928
        return block_1928(state, tracer, fn_state);
    }
    fn block_1928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1928_0: read-var gs#118404:u8
        let s_1928_0: bool = fn_state.gs_118404;
        // N s_1928_1: branch s_1928_0 b4599 b1929
        if s_1928_0 {
            return block_4599(state, tracer, fn_state);
        } else {
            return block_1929(state, tracer, fn_state);
        };
    }
    fn block_1929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1929_0: const #0u : u8
        let s_1929_0: bool = false;
        // D s_1929_1: write-var gs#118405 <= s_1929_0
        fn_state.gs_118405 = s_1929_0;
        // N s_1929_2: jump b1930
        return block_1930(state, tracer, fn_state);
    }
    fn block_1930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1930_0: read-var gs#118405:u8
        let s_1930_0: bool = fn_state.gs_118405;
        // N s_1930_1: branch s_1930_0 b4598 b1931
        if s_1930_0 {
            return block_4598(state, tracer, fn_state);
        } else {
            return block_1931(state, tracer, fn_state);
        };
    }
    fn block_1931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1931_0: const #0u : u8
        let s_1931_0: bool = false;
        // D s_1931_1: write-var gs#118406 <= s_1931_0
        fn_state.gs_118406 = s_1931_0;
        // N s_1931_2: jump b1932
        return block_1932(state, tracer, fn_state);
    }
    fn block_1932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1932_0: read-var gs#118406:u8
        let s_1932_0: bool = fn_state.gs_118406;
        // N s_1932_1: branch s_1932_0 b4597 b1933
        if s_1932_0 {
            return block_4597(state, tracer, fn_state);
        } else {
            return block_1933(state, tracer, fn_state);
        };
    }
    fn block_1933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1933_0: const #0u : u8
        let s_1933_0: bool = false;
        // D s_1933_1: write-var gs#118407 <= s_1933_0
        fn_state.gs_118407 = s_1933_0;
        // N s_1933_2: jump b1934
        return block_1934(state, tracer, fn_state);
    }
    fn block_1934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1934_0: read-var gs#118407:u8
        let s_1934_0: bool = fn_state.gs_118407;
        // N s_1934_1: branch s_1934_0 b4596 b1935
        if s_1934_0 {
            return block_4596(state, tracer, fn_state);
        } else {
            return block_1935(state, tracer, fn_state);
        };
    }
    fn block_1935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1935_0: read-var CRm:u8
        let s_1935_0: u8 = fn_state.CRm;
        // D s_1935_1: cast zx s_1935_0 -> bv
        let s_1935_1: Bits = Bits::new(s_1935_0 as u128, 4u16);
        // C s_1935_2: const #14u : u8
        let s_1935_2: u8 = 14;
        // C s_1935_3: cast zx s_1935_2 -> bv
        let s_1935_3: Bits = Bits::new(s_1935_2 as u128, 4u16);
        // D s_1935_4: cmp-eq s_1935_1 s_1935_3
        let s_1935_4: bool = ((s_1935_1) == (s_1935_3));
        // N s_1935_5: branch s_1935_4 b4595 b1936
        if s_1935_4 {
            return block_4595(state, tracer, fn_state);
        } else {
            return block_1936(state, tracer, fn_state);
        };
    }
    fn block_1936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1936_0: const #0u : u8
        let s_1936_0: bool = false;
        // D s_1936_1: write-var gs#118408 <= s_1936_0
        fn_state.gs_118408 = s_1936_0;
        // N s_1936_2: jump b1937
        return block_1937(state, tracer, fn_state);
    }
    fn block_1937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1937_0: read-var gs#118408:u8
        let s_1937_0: bool = fn_state.gs_118408;
        // N s_1937_1: branch s_1937_0 b4594 b1938
        if s_1937_0 {
            return block_4594(state, tracer, fn_state);
        } else {
            return block_1938(state, tracer, fn_state);
        };
    }
    fn block_1938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1938_0: const #0u : u8
        let s_1938_0: bool = false;
        // D s_1938_1: write-var gs#118409 <= s_1938_0
        fn_state.gs_118409 = s_1938_0;
        // N s_1938_2: jump b1939
        return block_1939(state, tracer, fn_state);
    }
    fn block_1939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1939_0: read-var gs#118409:u8
        let s_1939_0: bool = fn_state.gs_118409;
        // N s_1939_1: branch s_1939_0 b4593 b1940
        if s_1939_0 {
            return block_4593(state, tracer, fn_state);
        } else {
            return block_1940(state, tracer, fn_state);
        };
    }
    fn block_1940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1940_0: const #0u : u8
        let s_1940_0: bool = false;
        // D s_1940_1: write-var gs#118410 <= s_1940_0
        fn_state.gs_118410 = s_1940_0;
        // N s_1940_2: jump b1941
        return block_1941(state, tracer, fn_state);
    }
    fn block_1941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1941_0: read-var gs#118410:u8
        let s_1941_0: bool = fn_state.gs_118410;
        // N s_1941_1: branch s_1941_0 b4592 b1942
        if s_1941_0 {
            return block_4592(state, tracer, fn_state);
        } else {
            return block_1942(state, tracer, fn_state);
        };
    }
    fn block_1942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1942_0: const #0u : u8
        let s_1942_0: bool = false;
        // D s_1942_1: write-var gs#118411 <= s_1942_0
        fn_state.gs_118411 = s_1942_0;
        // N s_1942_2: jump b1943
        return block_1943(state, tracer, fn_state);
    }
    fn block_1943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1943_0: read-var gs#118411:u8
        let s_1943_0: bool = fn_state.gs_118411;
        // N s_1943_1: branch s_1943_0 b4591 b1944
        if s_1943_0 {
            return block_4591(state, tracer, fn_state);
        } else {
            return block_1944(state, tracer, fn_state);
        };
    }
    fn block_1944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1944_0: read-var CRm:u8
        let s_1944_0: u8 = fn_state.CRm;
        // D s_1944_1: cast zx s_1944_0 -> bv
        let s_1944_1: Bits = Bits::new(s_1944_0 as u128, 4u16);
        // C s_1944_2: const #8u : u8
        let s_1944_2: u8 = 8;
        // C s_1944_3: cast zx s_1944_2 -> bv
        let s_1944_3: Bits = Bits::new(s_1944_2 as u128, 4u16);
        // D s_1944_4: cmp-eq s_1944_1 s_1944_3
        let s_1944_4: bool = ((s_1944_1) == (s_1944_3));
        // N s_1944_5: branch s_1944_4 b4590 b1945
        if s_1944_4 {
            return block_4590(state, tracer, fn_state);
        } else {
            return block_1945(state, tracer, fn_state);
        };
    }
    fn block_1945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1945_0: const #0u : u8
        let s_1945_0: bool = false;
        // D s_1945_1: write-var gs#118412 <= s_1945_0
        fn_state.gs_118412 = s_1945_0;
        // N s_1945_2: jump b1946
        return block_1946(state, tracer, fn_state);
    }
    fn block_1946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1946_0: read-var gs#118412:u8
        let s_1946_0: bool = fn_state.gs_118412;
        // N s_1946_1: branch s_1946_0 b4589 b1947
        if s_1946_0 {
            return block_4589(state, tracer, fn_state);
        } else {
            return block_1947(state, tracer, fn_state);
        };
    }
    fn block_1947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1947_0: const #0u : u8
        let s_1947_0: bool = false;
        // D s_1947_1: write-var gs#118413 <= s_1947_0
        fn_state.gs_118413 = s_1947_0;
        // N s_1947_2: jump b1948
        return block_1948(state, tracer, fn_state);
    }
    fn block_1948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1948_0: read-var gs#118413:u8
        let s_1948_0: bool = fn_state.gs_118413;
        // N s_1948_1: branch s_1948_0 b4588 b1949
        if s_1948_0 {
            return block_4588(state, tracer, fn_state);
        } else {
            return block_1949(state, tracer, fn_state);
        };
    }
    fn block_1949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1949_0: const #0u : u8
        let s_1949_0: bool = false;
        // D s_1949_1: write-var gs#118414 <= s_1949_0
        fn_state.gs_118414 = s_1949_0;
        // N s_1949_2: jump b1950
        return block_1950(state, tracer, fn_state);
    }
    fn block_1950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1950_0: read-var gs#118414:u8
        let s_1950_0: bool = fn_state.gs_118414;
        // N s_1950_1: branch s_1950_0 b4587 b1951
        if s_1950_0 {
            return block_4587(state, tracer, fn_state);
        } else {
            return block_1951(state, tracer, fn_state);
        };
    }
    fn block_1951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1951_0: const #0u : u8
        let s_1951_0: bool = false;
        // D s_1951_1: write-var gs#118415 <= s_1951_0
        fn_state.gs_118415 = s_1951_0;
        // N s_1951_2: jump b1952
        return block_1952(state, tracer, fn_state);
    }
    fn block_1952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1952_0: read-var gs#118415:u8
        let s_1952_0: bool = fn_state.gs_118415;
        // N s_1952_1: branch s_1952_0 b4586 b1953
        if s_1952_0 {
            return block_4586(state, tracer, fn_state);
        } else {
            return block_1953(state, tracer, fn_state);
        };
    }
    fn block_1953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1953_0: read-var CRm:u8
        let s_1953_0: u8 = fn_state.CRm;
        // D s_1953_1: cast zx s_1953_0 -> bv
        let s_1953_1: Bits = Bits::new(s_1953_0 as u128, 4u16);
        // C s_1953_2: const #0u : u8
        let s_1953_2: u8 = 0;
        // C s_1953_3: cast zx s_1953_2 -> bv
        let s_1953_3: Bits = Bits::new(s_1953_2 as u128, 4u16);
        // D s_1953_4: cmp-eq s_1953_1 s_1953_3
        let s_1953_4: bool = ((s_1953_1) == (s_1953_3));
        // N s_1953_5: branch s_1953_4 b4585 b1954
        if s_1953_4 {
            return block_4585(state, tracer, fn_state);
        } else {
            return block_1954(state, tracer, fn_state);
        };
    }
    fn block_1954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1954_0: const #0u : u8
        let s_1954_0: bool = false;
        // D s_1954_1: write-var gs#118416 <= s_1954_0
        fn_state.gs_118416 = s_1954_0;
        // N s_1954_2: jump b1955
        return block_1955(state, tracer, fn_state);
    }
    fn block_1955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1955_0: read-var gs#118416:u8
        let s_1955_0: bool = fn_state.gs_118416;
        // N s_1955_1: branch s_1955_0 b4584 b1956
        if s_1955_0 {
            return block_4584(state, tracer, fn_state);
        } else {
            return block_1956(state, tracer, fn_state);
        };
    }
    fn block_1956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1956_0: const #0u : u8
        let s_1956_0: bool = false;
        // D s_1956_1: write-var gs#118417 <= s_1956_0
        fn_state.gs_118417 = s_1956_0;
        // N s_1956_2: jump b1957
        return block_1957(state, tracer, fn_state);
    }
    fn block_1957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1957_0: read-var gs#118417:u8
        let s_1957_0: bool = fn_state.gs_118417;
        // N s_1957_1: branch s_1957_0 b4583 b1958
        if s_1957_0 {
            return block_4583(state, tracer, fn_state);
        } else {
            return block_1958(state, tracer, fn_state);
        };
    }
    fn block_1958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1958_0: const #0u : u8
        let s_1958_0: bool = false;
        // D s_1958_1: write-var gs#118418 <= s_1958_0
        fn_state.gs_118418 = s_1958_0;
        // N s_1958_2: jump b1959
        return block_1959(state, tracer, fn_state);
    }
    fn block_1959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1959_0: read-var gs#118418:u8
        let s_1959_0: bool = fn_state.gs_118418;
        // N s_1959_1: branch s_1959_0 b4582 b1960
        if s_1959_0 {
            return block_4582(state, tracer, fn_state);
        } else {
            return block_1960(state, tracer, fn_state);
        };
    }
    fn block_1960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1960_0: const #0u : u8
        let s_1960_0: bool = false;
        // D s_1960_1: write-var gs#118419 <= s_1960_0
        fn_state.gs_118419 = s_1960_0;
        // N s_1960_2: jump b1961
        return block_1961(state, tracer, fn_state);
    }
    fn block_1961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1961_0: read-var gs#118419:u8
        let s_1961_0: bool = fn_state.gs_118419;
        // N s_1961_1: branch s_1961_0 b4581 b1962
        if s_1961_0 {
            return block_4581(state, tracer, fn_state);
        } else {
            return block_1962(state, tracer, fn_state);
        };
    }
    fn block_1962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1962_0: read-var CRm:u8
        let s_1962_0: u8 = fn_state.CRm;
        // D s_1962_1: cast zx s_1962_0 -> bv
        let s_1962_1: Bits = Bits::new(s_1962_0 as u128, 4u16);
        // C s_1962_2: const #2u : u8
        let s_1962_2: u8 = 2;
        // C s_1962_3: cast zx s_1962_2 -> bv
        let s_1962_3: Bits = Bits::new(s_1962_2 as u128, 4u16);
        // D s_1962_4: cmp-eq s_1962_1 s_1962_3
        let s_1962_4: bool = ((s_1962_1) == (s_1962_3));
        // N s_1962_5: branch s_1962_4 b4580 b1963
        if s_1962_4 {
            return block_4580(state, tracer, fn_state);
        } else {
            return block_1963(state, tracer, fn_state);
        };
    }
    fn block_1963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1963_0: const #0u : u8
        let s_1963_0: bool = false;
        // D s_1963_1: write-var gs#118420 <= s_1963_0
        fn_state.gs_118420 = s_1963_0;
        // N s_1963_2: jump b1964
        return block_1964(state, tracer, fn_state);
    }
    fn block_1964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1964_0: read-var gs#118420:u8
        let s_1964_0: bool = fn_state.gs_118420;
        // N s_1964_1: branch s_1964_0 b4579 b1965
        if s_1964_0 {
            return block_4579(state, tracer, fn_state);
        } else {
            return block_1965(state, tracer, fn_state);
        };
    }
    fn block_1965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1965_0: const #0u : u8
        let s_1965_0: bool = false;
        // D s_1965_1: write-var gs#118421 <= s_1965_0
        fn_state.gs_118421 = s_1965_0;
        // N s_1965_2: jump b1966
        return block_1966(state, tracer, fn_state);
    }
    fn block_1966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1966_0: read-var gs#118421:u8
        let s_1966_0: bool = fn_state.gs_118421;
        // N s_1966_1: branch s_1966_0 b4578 b1967
        if s_1966_0 {
            return block_4578(state, tracer, fn_state);
        } else {
            return block_1967(state, tracer, fn_state);
        };
    }
    fn block_1967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1967_0: const #0u : u8
        let s_1967_0: bool = false;
        // D s_1967_1: write-var gs#118422 <= s_1967_0
        fn_state.gs_118422 = s_1967_0;
        // N s_1967_2: jump b1968
        return block_1968(state, tracer, fn_state);
    }
    fn block_1968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1968_0: read-var gs#118422:u8
        let s_1968_0: bool = fn_state.gs_118422;
        // N s_1968_1: branch s_1968_0 b4577 b1969
        if s_1968_0 {
            return block_4577(state, tracer, fn_state);
        } else {
            return block_1969(state, tracer, fn_state);
        };
    }
    fn block_1969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1969_0: const #0u : u8
        let s_1969_0: bool = false;
        // D s_1969_1: write-var gs#118423 <= s_1969_0
        fn_state.gs_118423 = s_1969_0;
        // N s_1969_2: jump b1970
        return block_1970(state, tracer, fn_state);
    }
    fn block_1970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1970_0: read-var gs#118423:u8
        let s_1970_0: bool = fn_state.gs_118423;
        // N s_1970_1: branch s_1970_0 b4576 b1971
        if s_1970_0 {
            return block_4576(state, tracer, fn_state);
        } else {
            return block_1971(state, tracer, fn_state);
        };
    }
    fn block_1971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1971_0: read-var CRm:u8
        let s_1971_0: u8 = fn_state.CRm;
        // D s_1971_1: cast zx s_1971_0 -> bv
        let s_1971_1: Bits = Bits::new(s_1971_0 as u128, 4u16);
        // C s_1971_2: const #14u : u8
        let s_1971_2: u8 = 14;
        // C s_1971_3: cast zx s_1971_2 -> bv
        let s_1971_3: Bits = Bits::new(s_1971_2 as u128, 4u16);
        // D s_1971_4: cmp-eq s_1971_1 s_1971_3
        let s_1971_4: bool = ((s_1971_1) == (s_1971_3));
        // N s_1971_5: branch s_1971_4 b4575 b1972
        if s_1971_4 {
            return block_4575(state, tracer, fn_state);
        } else {
            return block_1972(state, tracer, fn_state);
        };
    }
    fn block_1972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1972_0: const #0u : u8
        let s_1972_0: bool = false;
        // D s_1972_1: write-var gs#118424 <= s_1972_0
        fn_state.gs_118424 = s_1972_0;
        // N s_1972_2: jump b1973
        return block_1973(state, tracer, fn_state);
    }
    fn block_1973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1973_0: read-var gs#118424:u8
        let s_1973_0: bool = fn_state.gs_118424;
        // N s_1973_1: branch s_1973_0 b4574 b1974
        if s_1973_0 {
            return block_4574(state, tracer, fn_state);
        } else {
            return block_1974(state, tracer, fn_state);
        };
    }
    fn block_1974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1974_0: const #0u : u8
        let s_1974_0: bool = false;
        // D s_1974_1: write-var gs#118425 <= s_1974_0
        fn_state.gs_118425 = s_1974_0;
        // N s_1974_2: jump b1975
        return block_1975(state, tracer, fn_state);
    }
    fn block_1975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1975_0: read-var gs#118425:u8
        let s_1975_0: bool = fn_state.gs_118425;
        // N s_1975_1: branch s_1975_0 b4573 b1976
        if s_1975_0 {
            return block_4573(state, tracer, fn_state);
        } else {
            return block_1976(state, tracer, fn_state);
        };
    }
    fn block_1976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1976_0: const #0u : u8
        let s_1976_0: bool = false;
        // D s_1976_1: write-var gs#118426 <= s_1976_0
        fn_state.gs_118426 = s_1976_0;
        // N s_1976_2: jump b1977
        return block_1977(state, tracer, fn_state);
    }
    fn block_1977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1977_0: read-var gs#118426:u8
        let s_1977_0: bool = fn_state.gs_118426;
        // N s_1977_1: branch s_1977_0 b4572 b1978
        if s_1977_0 {
            return block_4572(state, tracer, fn_state);
        } else {
            return block_1978(state, tracer, fn_state);
        };
    }
    fn block_1978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1978_0: const #0u : u8
        let s_1978_0: bool = false;
        // D s_1978_1: write-var gs#118427 <= s_1978_0
        fn_state.gs_118427 = s_1978_0;
        // N s_1978_2: jump b1979
        return block_1979(state, tracer, fn_state);
    }
    fn block_1979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1979_0: read-var gs#118427:u8
        let s_1979_0: bool = fn_state.gs_118427;
        // N s_1979_1: branch s_1979_0 b4571 b1980
        if s_1979_0 {
            return block_4571(state, tracer, fn_state);
        } else {
            return block_1980(state, tracer, fn_state);
        };
    }
    fn block_1980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1980_0: read-var CRm:u8
        let s_1980_0: u8 = fn_state.CRm;
        // D s_1980_1: cast zx s_1980_0 -> bv
        let s_1980_1: Bits = Bits::new(s_1980_0 as u128, 4u16);
        // C s_1980_2: const #2u : u8
        let s_1980_2: u8 = 2;
        // C s_1980_3: cast zx s_1980_2 -> bv
        let s_1980_3: Bits = Bits::new(s_1980_2 as u128, 4u16);
        // D s_1980_4: cmp-eq s_1980_1 s_1980_3
        let s_1980_4: bool = ((s_1980_1) == (s_1980_3));
        // N s_1980_5: branch s_1980_4 b4570 b1981
        if s_1980_4 {
            return block_4570(state, tracer, fn_state);
        } else {
            return block_1981(state, tracer, fn_state);
        };
    }
    fn block_1981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1981_0: const #0u : u8
        let s_1981_0: bool = false;
        // D s_1981_1: write-var gs#118428 <= s_1981_0
        fn_state.gs_118428 = s_1981_0;
        // N s_1981_2: jump b1982
        return block_1982(state, tracer, fn_state);
    }
    fn block_1982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1982_0: read-var gs#118428:u8
        let s_1982_0: bool = fn_state.gs_118428;
        // N s_1982_1: branch s_1982_0 b4569 b1983
        if s_1982_0 {
            return block_4569(state, tracer, fn_state);
        } else {
            return block_1983(state, tracer, fn_state);
        };
    }
    fn block_1983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1983_0: const #0u : u8
        let s_1983_0: bool = false;
        // D s_1983_1: write-var gs#118429 <= s_1983_0
        fn_state.gs_118429 = s_1983_0;
        // N s_1983_2: jump b1984
        return block_1984(state, tracer, fn_state);
    }
    fn block_1984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1984_0: read-var gs#118429:u8
        let s_1984_0: bool = fn_state.gs_118429;
        // N s_1984_1: branch s_1984_0 b4568 b1985
        if s_1984_0 {
            return block_4568(state, tracer, fn_state);
        } else {
            return block_1985(state, tracer, fn_state);
        };
    }
    fn block_1985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1985_0: const #0u : u8
        let s_1985_0: bool = false;
        // D s_1985_1: write-var gs#118430 <= s_1985_0
        fn_state.gs_118430 = s_1985_0;
        // N s_1985_2: jump b1986
        return block_1986(state, tracer, fn_state);
    }
    fn block_1986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1986_0: read-var gs#118430:u8
        let s_1986_0: bool = fn_state.gs_118430;
        // N s_1986_1: branch s_1986_0 b4567 b1987
        if s_1986_0 {
            return block_4567(state, tracer, fn_state);
        } else {
            return block_1987(state, tracer, fn_state);
        };
    }
    fn block_1987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1987_0: const #0u : u8
        let s_1987_0: bool = false;
        // D s_1987_1: write-var gs#118431 <= s_1987_0
        fn_state.gs_118431 = s_1987_0;
        // N s_1987_2: jump b1988
        return block_1988(state, tracer, fn_state);
    }
    fn block_1988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1988_0: read-var gs#118431:u8
        let s_1988_0: bool = fn_state.gs_118431;
        // N s_1988_1: branch s_1988_0 b4566 b1989
        if s_1988_0 {
            return block_4566(state, tracer, fn_state);
        } else {
            return block_1989(state, tracer, fn_state);
        };
    }
    fn block_1989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1989_0: read-var CRm:u8
        let s_1989_0: u8 = fn_state.CRm;
        // D s_1989_1: cast zx s_1989_0 -> bv
        let s_1989_1: Bits = Bits::new(s_1989_0 as u128, 4u16);
        // C s_1989_2: const #0u : u8
        let s_1989_2: u8 = 0;
        // C s_1989_3: cast zx s_1989_2 -> bv
        let s_1989_3: Bits = Bits::new(s_1989_2 as u128, 4u16);
        // D s_1989_4: cmp-eq s_1989_1 s_1989_3
        let s_1989_4: bool = ((s_1989_1) == (s_1989_3));
        // N s_1989_5: branch s_1989_4 b4565 b1990
        if s_1989_4 {
            return block_4565(state, tracer, fn_state);
        } else {
            return block_1990(state, tracer, fn_state);
        };
    }
    fn block_1990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1990_0: const #0u : u8
        let s_1990_0: bool = false;
        // D s_1990_1: write-var gs#118432 <= s_1990_0
        fn_state.gs_118432 = s_1990_0;
        // N s_1990_2: jump b1991
        return block_1991(state, tracer, fn_state);
    }
    fn block_1991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1991_0: read-var gs#118432:u8
        let s_1991_0: bool = fn_state.gs_118432;
        // N s_1991_1: branch s_1991_0 b4564 b1992
        if s_1991_0 {
            return block_4564(state, tracer, fn_state);
        } else {
            return block_1992(state, tracer, fn_state);
        };
    }
    fn block_1992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1992_0: const #0u : u8
        let s_1992_0: bool = false;
        // D s_1992_1: write-var gs#118433 <= s_1992_0
        fn_state.gs_118433 = s_1992_0;
        // N s_1992_2: jump b1993
        return block_1993(state, tracer, fn_state);
    }
    fn block_1993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1993_0: read-var gs#118433:u8
        let s_1993_0: bool = fn_state.gs_118433;
        // N s_1993_1: branch s_1993_0 b4563 b1994
        if s_1993_0 {
            return block_4563(state, tracer, fn_state);
        } else {
            return block_1994(state, tracer, fn_state);
        };
    }
    fn block_1994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1994_0: const #0u : u8
        let s_1994_0: bool = false;
        // D s_1994_1: write-var gs#118434 <= s_1994_0
        fn_state.gs_118434 = s_1994_0;
        // N s_1994_2: jump b1995
        return block_1995(state, tracer, fn_state);
    }
    fn block_1995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1995_0: read-var gs#118434:u8
        let s_1995_0: bool = fn_state.gs_118434;
        // N s_1995_1: branch s_1995_0 b4562 b1996
        if s_1995_0 {
            return block_4562(state, tracer, fn_state);
        } else {
            return block_1996(state, tracer, fn_state);
        };
    }
    fn block_1996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1996_0: const #0u : u8
        let s_1996_0: bool = false;
        // D s_1996_1: write-var gs#118435 <= s_1996_0
        fn_state.gs_118435 = s_1996_0;
        // N s_1996_2: jump b1997
        return block_1997(state, tracer, fn_state);
    }
    fn block_1997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1997_0: read-var gs#118435:u8
        let s_1997_0: bool = fn_state.gs_118435;
        // N s_1997_1: branch s_1997_0 b4561 b1998
        if s_1997_0 {
            return block_4561(state, tracer, fn_state);
        } else {
            return block_1998(state, tracer, fn_state);
        };
    }
    fn block_1998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1998_0: read-var CRm:u8
        let s_1998_0: u8 = fn_state.CRm;
        // D s_1998_1: cast zx s_1998_0 -> bv
        let s_1998_1: Bits = Bits::new(s_1998_0 as u128, 4u16);
        // C s_1998_2: const #3u : u8
        let s_1998_2: u8 = 3;
        // C s_1998_3: cast zx s_1998_2 -> bv
        let s_1998_3: Bits = Bits::new(s_1998_2 as u128, 4u16);
        // D s_1998_4: cmp-eq s_1998_1 s_1998_3
        let s_1998_4: bool = ((s_1998_1) == (s_1998_3));
        // N s_1998_5: branch s_1998_4 b4560 b1999
        if s_1998_4 {
            return block_4560(state, tracer, fn_state);
        } else {
            return block_1999(state, tracer, fn_state);
        };
    }
    fn block_1999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1999_0: const #0u : u8
        let s_1999_0: bool = false;
        // D s_1999_1: write-var gs#118436 <= s_1999_0
        fn_state.gs_118436 = s_1999_0;
        // N s_1999_2: jump b2000
        return block_2000(state, tracer, fn_state);
    }
    fn block_2000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2000_0: read-var gs#118436:u8
        let s_2000_0: bool = fn_state.gs_118436;
        // N s_2000_1: branch s_2000_0 b4559 b2001
        if s_2000_0 {
            return block_4559(state, tracer, fn_state);
        } else {
            return block_2001(state, tracer, fn_state);
        };
    }
    fn block_2001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2001_0: const #0u : u8
        let s_2001_0: bool = false;
        // D s_2001_1: write-var gs#118437 <= s_2001_0
        fn_state.gs_118437 = s_2001_0;
        // N s_2001_2: jump b2002
        return block_2002(state, tracer, fn_state);
    }
    fn block_2002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2002_0: read-var gs#118437:u8
        let s_2002_0: bool = fn_state.gs_118437;
        // N s_2002_1: branch s_2002_0 b4558 b2003
        if s_2002_0 {
            return block_4558(state, tracer, fn_state);
        } else {
            return block_2003(state, tracer, fn_state);
        };
    }
    fn block_2003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2003_0: const #0u : u8
        let s_2003_0: bool = false;
        // D s_2003_1: write-var gs#118438 <= s_2003_0
        fn_state.gs_118438 = s_2003_0;
        // N s_2003_2: jump b2004
        return block_2004(state, tracer, fn_state);
    }
    fn block_2004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2004_0: read-var gs#118438:u8
        let s_2004_0: bool = fn_state.gs_118438;
        // N s_2004_1: branch s_2004_0 b4557 b2005
        if s_2004_0 {
            return block_4557(state, tracer, fn_state);
        } else {
            return block_2005(state, tracer, fn_state);
        };
    }
    fn block_2005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2005_0: const #0u : u8
        let s_2005_0: bool = false;
        // D s_2005_1: write-var gs#118439 <= s_2005_0
        fn_state.gs_118439 = s_2005_0;
        // N s_2005_2: jump b2006
        return block_2006(state, tracer, fn_state);
    }
    fn block_2006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2006_0: read-var gs#118439:u8
        let s_2006_0: bool = fn_state.gs_118439;
        // N s_2006_1: branch s_2006_0 b4556 b2007
        if s_2006_0 {
            return block_4556(state, tracer, fn_state);
        } else {
            return block_2007(state, tracer, fn_state);
        };
    }
    fn block_2007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2007_0: read-var CRm:u8
        let s_2007_0: u8 = fn_state.CRm;
        // D s_2007_1: cast zx s_2007_0 -> bv
        let s_2007_1: Bits = Bits::new(s_2007_0 as u128, 4u16);
        // C s_2007_2: const #13u : u8
        let s_2007_2: u8 = 13;
        // C s_2007_3: cast zx s_2007_2 -> bv
        let s_2007_3: Bits = Bits::new(s_2007_2 as u128, 4u16);
        // D s_2007_4: cmp-eq s_2007_1 s_2007_3
        let s_2007_4: bool = ((s_2007_1) == (s_2007_3));
        // N s_2007_5: branch s_2007_4 b4555 b2008
        if s_2007_4 {
            return block_4555(state, tracer, fn_state);
        } else {
            return block_2008(state, tracer, fn_state);
        };
    }
    fn block_2008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2008_0: const #0u : u8
        let s_2008_0: bool = false;
        // D s_2008_1: write-var gs#118440 <= s_2008_0
        fn_state.gs_118440 = s_2008_0;
        // N s_2008_2: jump b2009
        return block_2009(state, tracer, fn_state);
    }
    fn block_2009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2009_0: read-var gs#118440:u8
        let s_2009_0: bool = fn_state.gs_118440;
        // N s_2009_1: branch s_2009_0 b4554 b2010
        if s_2009_0 {
            return block_4554(state, tracer, fn_state);
        } else {
            return block_2010(state, tracer, fn_state);
        };
    }
    fn block_2010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2010_0: const #0u : u8
        let s_2010_0: bool = false;
        // D s_2010_1: write-var gs#118441 <= s_2010_0
        fn_state.gs_118441 = s_2010_0;
        // N s_2010_2: jump b2011
        return block_2011(state, tracer, fn_state);
    }
    fn block_2011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2011_0: read-var gs#118441:u8
        let s_2011_0: bool = fn_state.gs_118441;
        // N s_2011_1: branch s_2011_0 b4553 b2012
        if s_2011_0 {
            return block_4553(state, tracer, fn_state);
        } else {
            return block_2012(state, tracer, fn_state);
        };
    }
    fn block_2012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2012_0: const #0u : u8
        let s_2012_0: bool = false;
        // D s_2012_1: write-var gs#118442 <= s_2012_0
        fn_state.gs_118442 = s_2012_0;
        // N s_2012_2: jump b2013
        return block_2013(state, tracer, fn_state);
    }
    fn block_2013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2013_0: read-var gs#118442:u8
        let s_2013_0: bool = fn_state.gs_118442;
        // N s_2013_1: branch s_2013_0 b4552 b2014
        if s_2013_0 {
            return block_4552(state, tracer, fn_state);
        } else {
            return block_2014(state, tracer, fn_state);
        };
    }
    fn block_2014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2014_0: const #0u : u8
        let s_2014_0: bool = false;
        // D s_2014_1: write-var gs#118443 <= s_2014_0
        fn_state.gs_118443 = s_2014_0;
        // N s_2014_2: jump b2015
        return block_2015(state, tracer, fn_state);
    }
    fn block_2015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2015_0: read-var gs#118443:u8
        let s_2015_0: bool = fn_state.gs_118443;
        // N s_2015_1: branch s_2015_0 b4551 b2016
        if s_2015_0 {
            return block_4551(state, tracer, fn_state);
        } else {
            return block_2016(state, tracer, fn_state);
        };
    }
    fn block_2016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2016_0: read-var CRm:u8
        let s_2016_0: u8 = fn_state.CRm;
        // D s_2016_1: cast zx s_2016_0 -> bv
        let s_2016_1: Bits = Bits::new(s_2016_0 as u128, 4u16);
        // C s_2016_2: const #13u : u8
        let s_2016_2: u8 = 13;
        // C s_2016_3: cast zx s_2016_2 -> bv
        let s_2016_3: Bits = Bits::new(s_2016_2 as u128, 4u16);
        // D s_2016_4: cmp-eq s_2016_1 s_2016_3
        let s_2016_4: bool = ((s_2016_1) == (s_2016_3));
        // N s_2016_5: branch s_2016_4 b4550 b2017
        if s_2016_4 {
            return block_4550(state, tracer, fn_state);
        } else {
            return block_2017(state, tracer, fn_state);
        };
    }
    fn block_2017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2017_0: const #0u : u8
        let s_2017_0: bool = false;
        // D s_2017_1: write-var gs#118444 <= s_2017_0
        fn_state.gs_118444 = s_2017_0;
        // N s_2017_2: jump b2018
        return block_2018(state, tracer, fn_state);
    }
    fn block_2018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2018_0: read-var gs#118444:u8
        let s_2018_0: bool = fn_state.gs_118444;
        // N s_2018_1: branch s_2018_0 b4549 b2019
        if s_2018_0 {
            return block_4549(state, tracer, fn_state);
        } else {
            return block_2019(state, tracer, fn_state);
        };
    }
    fn block_2019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2019_0: const #0u : u8
        let s_2019_0: bool = false;
        // D s_2019_1: write-var gs#118445 <= s_2019_0
        fn_state.gs_118445 = s_2019_0;
        // N s_2019_2: jump b2020
        return block_2020(state, tracer, fn_state);
    }
    fn block_2020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2020_0: read-var gs#118445:u8
        let s_2020_0: bool = fn_state.gs_118445;
        // N s_2020_1: branch s_2020_0 b4548 b2021
        if s_2020_0 {
            return block_4548(state, tracer, fn_state);
        } else {
            return block_2021(state, tracer, fn_state);
        };
    }
    fn block_2021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2021_0: const #0u : u8
        let s_2021_0: bool = false;
        // D s_2021_1: write-var gs#118446 <= s_2021_0
        fn_state.gs_118446 = s_2021_0;
        // N s_2021_2: jump b2022
        return block_2022(state, tracer, fn_state);
    }
    fn block_2022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2022_0: read-var gs#118446:u8
        let s_2022_0: bool = fn_state.gs_118446;
        // N s_2022_1: branch s_2022_0 b4547 b2023
        if s_2022_0 {
            return block_4547(state, tracer, fn_state);
        } else {
            return block_2023(state, tracer, fn_state);
        };
    }
    fn block_2023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2023_0: const #0u : u8
        let s_2023_0: bool = false;
        // D s_2023_1: write-var gs#118447 <= s_2023_0
        fn_state.gs_118447 = s_2023_0;
        // N s_2023_2: jump b2024
        return block_2024(state, tracer, fn_state);
    }
    fn block_2024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2024_0: read-var gs#118447:u8
        let s_2024_0: bool = fn_state.gs_118447;
        // N s_2024_1: branch s_2024_0 b4546 b2025
        if s_2024_0 {
            return block_4546(state, tracer, fn_state);
        } else {
            return block_2025(state, tracer, fn_state);
        };
    }
    fn block_2025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2025_0: read-var CRm:u8
        let s_2025_0: u8 = fn_state.CRm;
        // D s_2025_1: cast zx s_2025_0 -> bv
        let s_2025_1: Bits = Bits::new(s_2025_0 as u128, 4u16);
        // C s_2025_2: const #13u : u8
        let s_2025_2: u8 = 13;
        // C s_2025_3: cast zx s_2025_2 -> bv
        let s_2025_3: Bits = Bits::new(s_2025_2 as u128, 4u16);
        // D s_2025_4: cmp-eq s_2025_1 s_2025_3
        let s_2025_4: bool = ((s_2025_1) == (s_2025_3));
        // N s_2025_5: branch s_2025_4 b4545 b2026
        if s_2025_4 {
            return block_4545(state, tracer, fn_state);
        } else {
            return block_2026(state, tracer, fn_state);
        };
    }
    fn block_2026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2026_0: const #0u : u8
        let s_2026_0: bool = false;
        // D s_2026_1: write-var gs#118448 <= s_2026_0
        fn_state.gs_118448 = s_2026_0;
        // N s_2026_2: jump b2027
        return block_2027(state, tracer, fn_state);
    }
    fn block_2027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2027_0: read-var gs#118448:u8
        let s_2027_0: bool = fn_state.gs_118448;
        // N s_2027_1: branch s_2027_0 b4544 b2028
        if s_2027_0 {
            return block_4544(state, tracer, fn_state);
        } else {
            return block_2028(state, tracer, fn_state);
        };
    }
    fn block_2028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2028_0: const #0u : u8
        let s_2028_0: bool = false;
        // D s_2028_1: write-var gs#118449 <= s_2028_0
        fn_state.gs_118449 = s_2028_0;
        // N s_2028_2: jump b2029
        return block_2029(state, tracer, fn_state);
    }
    fn block_2029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2029_0: read-var gs#118449:u8
        let s_2029_0: bool = fn_state.gs_118449;
        // N s_2029_1: branch s_2029_0 b4543 b2030
        if s_2029_0 {
            return block_4543(state, tracer, fn_state);
        } else {
            return block_2030(state, tracer, fn_state);
        };
    }
    fn block_2030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2030_0: const #0u : u8
        let s_2030_0: bool = false;
        // D s_2030_1: write-var gs#118450 <= s_2030_0
        fn_state.gs_118450 = s_2030_0;
        // N s_2030_2: jump b2031
        return block_2031(state, tracer, fn_state);
    }
    fn block_2031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2031_0: read-var gs#118450:u8
        let s_2031_0: bool = fn_state.gs_118450;
        // N s_2031_1: branch s_2031_0 b4542 b2032
        if s_2031_0 {
            return block_4542(state, tracer, fn_state);
        } else {
            return block_2032(state, tracer, fn_state);
        };
    }
    fn block_2032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2032_0: const #0u : u8
        let s_2032_0: bool = false;
        // D s_2032_1: write-var gs#118451 <= s_2032_0
        fn_state.gs_118451 = s_2032_0;
        // N s_2032_2: jump b2033
        return block_2033(state, tracer, fn_state);
    }
    fn block_2033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2033_0: read-var gs#118451:u8
        let s_2033_0: bool = fn_state.gs_118451;
        // N s_2033_1: branch s_2033_0 b4541 b2034
        if s_2033_0 {
            return block_4541(state, tracer, fn_state);
        } else {
            return block_2034(state, tracer, fn_state);
        };
    }
    fn block_2034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2034_0: read-var CRm:u8
        let s_2034_0: u8 = fn_state.CRm;
        // D s_2034_1: cast zx s_2034_0 -> bv
        let s_2034_1: Bits = Bits::new(s_2034_0 as u128, 4u16);
        // C s_2034_2: const #13u : u8
        let s_2034_2: u8 = 13;
        // C s_2034_3: cast zx s_2034_2 -> bv
        let s_2034_3: Bits = Bits::new(s_2034_2 as u128, 4u16);
        // D s_2034_4: cmp-eq s_2034_1 s_2034_3
        let s_2034_4: bool = ((s_2034_1) == (s_2034_3));
        // N s_2034_5: branch s_2034_4 b4540 b2035
        if s_2034_4 {
            return block_4540(state, tracer, fn_state);
        } else {
            return block_2035(state, tracer, fn_state);
        };
    }
    fn block_2035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2035_0: const #0u : u8
        let s_2035_0: bool = false;
        // D s_2035_1: write-var gs#118452 <= s_2035_0
        fn_state.gs_118452 = s_2035_0;
        // N s_2035_2: jump b2036
        return block_2036(state, tracer, fn_state);
    }
    fn block_2036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2036_0: read-var gs#118452:u8
        let s_2036_0: bool = fn_state.gs_118452;
        // N s_2036_1: branch s_2036_0 b4539 b2037
        if s_2036_0 {
            return block_4539(state, tracer, fn_state);
        } else {
            return block_2037(state, tracer, fn_state);
        };
    }
    fn block_2037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2037_0: const #0u : u8
        let s_2037_0: bool = false;
        // D s_2037_1: write-var gs#118453 <= s_2037_0
        fn_state.gs_118453 = s_2037_0;
        // N s_2037_2: jump b2038
        return block_2038(state, tracer, fn_state);
    }
    fn block_2038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2038_0: read-var gs#118453:u8
        let s_2038_0: bool = fn_state.gs_118453;
        // N s_2038_1: branch s_2038_0 b4538 b2039
        if s_2038_0 {
            return block_4538(state, tracer, fn_state);
        } else {
            return block_2039(state, tracer, fn_state);
        };
    }
    fn block_2039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2039_0: const #0u : u8
        let s_2039_0: bool = false;
        // D s_2039_1: write-var gs#118454 <= s_2039_0
        fn_state.gs_118454 = s_2039_0;
        // N s_2039_2: jump b2040
        return block_2040(state, tracer, fn_state);
    }
    fn block_2040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2040_0: read-var gs#118454:u8
        let s_2040_0: bool = fn_state.gs_118454;
        // N s_2040_1: branch s_2040_0 b4537 b2041
        if s_2040_0 {
            return block_4537(state, tracer, fn_state);
        } else {
            return block_2041(state, tracer, fn_state);
        };
    }
    fn block_2041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2041_0: const #0u : u8
        let s_2041_0: bool = false;
        // D s_2041_1: write-var gs#118455 <= s_2041_0
        fn_state.gs_118455 = s_2041_0;
        // N s_2041_2: jump b2042
        return block_2042(state, tracer, fn_state);
    }
    fn block_2042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2042_0: read-var gs#118455:u8
        let s_2042_0: bool = fn_state.gs_118455;
        // N s_2042_1: branch s_2042_0 b4536 b2043
        if s_2042_0 {
            return block_4536(state, tracer, fn_state);
        } else {
            return block_2043(state, tracer, fn_state);
        };
    }
    fn block_2043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2043_0: read-var CRm:u8
        let s_2043_0: u8 = fn_state.CRm;
        // D s_2043_1: cast zx s_2043_0 -> bv
        let s_2043_1: Bits = Bits::new(s_2043_0 as u128, 4u16);
        // C s_2043_2: const #13u : u8
        let s_2043_2: u8 = 13;
        // C s_2043_3: cast zx s_2043_2 -> bv
        let s_2043_3: Bits = Bits::new(s_2043_2 as u128, 4u16);
        // D s_2043_4: cmp-eq s_2043_1 s_2043_3
        let s_2043_4: bool = ((s_2043_1) == (s_2043_3));
        // N s_2043_5: branch s_2043_4 b4535 b2044
        if s_2043_4 {
            return block_4535(state, tracer, fn_state);
        } else {
            return block_2044(state, tracer, fn_state);
        };
    }
    fn block_2044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2044_0: const #0u : u8
        let s_2044_0: bool = false;
        // D s_2044_1: write-var gs#118456 <= s_2044_0
        fn_state.gs_118456 = s_2044_0;
        // N s_2044_2: jump b2045
        return block_2045(state, tracer, fn_state);
    }
    fn block_2045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2045_0: read-var gs#118456:u8
        let s_2045_0: bool = fn_state.gs_118456;
        // N s_2045_1: branch s_2045_0 b4534 b2046
        if s_2045_0 {
            return block_4534(state, tracer, fn_state);
        } else {
            return block_2046(state, tracer, fn_state);
        };
    }
    fn block_2046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2046_0: const #0u : u8
        let s_2046_0: bool = false;
        // D s_2046_1: write-var gs#118457 <= s_2046_0
        fn_state.gs_118457 = s_2046_0;
        // N s_2046_2: jump b2047
        return block_2047(state, tracer, fn_state);
    }
    fn block_2047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2047_0: read-var gs#118457:u8
        let s_2047_0: bool = fn_state.gs_118457;
        // N s_2047_1: branch s_2047_0 b4533 b2048
        if s_2047_0 {
            return block_4533(state, tracer, fn_state);
        } else {
            return block_2048(state, tracer, fn_state);
        };
    }
    fn block_2048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2048_0: const #0u : u8
        let s_2048_0: bool = false;
        // D s_2048_1: write-var gs#118458 <= s_2048_0
        fn_state.gs_118458 = s_2048_0;
        // N s_2048_2: jump b2049
        return block_2049(state, tracer, fn_state);
    }
    fn block_2049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2049_0: read-var gs#118458:u8
        let s_2049_0: bool = fn_state.gs_118458;
        // N s_2049_1: branch s_2049_0 b4532 b2050
        if s_2049_0 {
            return block_4532(state, tracer, fn_state);
        } else {
            return block_2050(state, tracer, fn_state);
        };
    }
    fn block_2050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2050_0: const #0u : u8
        let s_2050_0: bool = false;
        // D s_2050_1: write-var gs#118459 <= s_2050_0
        fn_state.gs_118459 = s_2050_0;
        // N s_2050_2: jump b2051
        return block_2051(state, tracer, fn_state);
    }
    fn block_2051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2051_0: read-var gs#118459:u8
        let s_2051_0: bool = fn_state.gs_118459;
        // N s_2051_1: branch s_2051_0 b4531 b2052
        if s_2051_0 {
            return block_4531(state, tracer, fn_state);
        } else {
            return block_2052(state, tracer, fn_state);
        };
    }
    fn block_2052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2052_0: read-var CRm:u8
        let s_2052_0: u8 = fn_state.CRm;
        // D s_2052_1: cast zx s_2052_0 -> bv
        let s_2052_1: Bits = Bits::new(s_2052_0 as u128, 4u16);
        // C s_2052_2: const #13u : u8
        let s_2052_2: u8 = 13;
        // C s_2052_3: cast zx s_2052_2 -> bv
        let s_2052_3: Bits = Bits::new(s_2052_2 as u128, 4u16);
        // D s_2052_4: cmp-eq s_2052_1 s_2052_3
        let s_2052_4: bool = ((s_2052_1) == (s_2052_3));
        // N s_2052_5: branch s_2052_4 b4530 b2053
        if s_2052_4 {
            return block_4530(state, tracer, fn_state);
        } else {
            return block_2053(state, tracer, fn_state);
        };
    }
    fn block_2053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2053_0: const #0u : u8
        let s_2053_0: bool = false;
        // D s_2053_1: write-var gs#118460 <= s_2053_0
        fn_state.gs_118460 = s_2053_0;
        // N s_2053_2: jump b2054
        return block_2054(state, tracer, fn_state);
    }
    fn block_2054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2054_0: read-var gs#118460:u8
        let s_2054_0: bool = fn_state.gs_118460;
        // N s_2054_1: branch s_2054_0 b4529 b2055
        if s_2054_0 {
            return block_4529(state, tracer, fn_state);
        } else {
            return block_2055(state, tracer, fn_state);
        };
    }
    fn block_2055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2055_0: const #0u : u8
        let s_2055_0: bool = false;
        // D s_2055_1: write-var gs#118461 <= s_2055_0
        fn_state.gs_118461 = s_2055_0;
        // N s_2055_2: jump b2056
        return block_2056(state, tracer, fn_state);
    }
    fn block_2056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2056_0: read-var gs#118461:u8
        let s_2056_0: bool = fn_state.gs_118461;
        // N s_2056_1: branch s_2056_0 b4528 b2057
        if s_2056_0 {
            return block_4528(state, tracer, fn_state);
        } else {
            return block_2057(state, tracer, fn_state);
        };
    }
    fn block_2057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2057_0: const #0u : u8
        let s_2057_0: bool = false;
        // D s_2057_1: write-var gs#118462 <= s_2057_0
        fn_state.gs_118462 = s_2057_0;
        // N s_2057_2: jump b2058
        return block_2058(state, tracer, fn_state);
    }
    fn block_2058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2058_0: read-var gs#118462:u8
        let s_2058_0: bool = fn_state.gs_118462;
        // N s_2058_1: branch s_2058_0 b4527 b2059
        if s_2058_0 {
            return block_4527(state, tracer, fn_state);
        } else {
            return block_2059(state, tracer, fn_state);
        };
    }
    fn block_2059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2059_0: const #0u : u8
        let s_2059_0: bool = false;
        // D s_2059_1: write-var gs#118463 <= s_2059_0
        fn_state.gs_118463 = s_2059_0;
        // N s_2059_2: jump b2060
        return block_2060(state, tracer, fn_state);
    }
    fn block_2060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2060_0: read-var gs#118463:u8
        let s_2060_0: bool = fn_state.gs_118463;
        // N s_2060_1: branch s_2060_0 b4526 b2061
        if s_2060_0 {
            return block_4526(state, tracer, fn_state);
        } else {
            return block_2061(state, tracer, fn_state);
        };
    }
    fn block_2061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2061_0: read-var CRm:u8
        let s_2061_0: u8 = fn_state.CRm;
        // D s_2061_1: cast zx s_2061_0 -> bv
        let s_2061_1: Bits = Bits::new(s_2061_0 as u128, 4u16);
        // C s_2061_2: const #13u : u8
        let s_2061_2: u8 = 13;
        // C s_2061_3: cast zx s_2061_2 -> bv
        let s_2061_3: Bits = Bits::new(s_2061_2 as u128, 4u16);
        // D s_2061_4: cmp-eq s_2061_1 s_2061_3
        let s_2061_4: bool = ((s_2061_1) == (s_2061_3));
        // N s_2061_5: branch s_2061_4 b4525 b2062
        if s_2061_4 {
            return block_4525(state, tracer, fn_state);
        } else {
            return block_2062(state, tracer, fn_state);
        };
    }
    fn block_2062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2062_0: const #0u : u8
        let s_2062_0: bool = false;
        // D s_2062_1: write-var gs#118464 <= s_2062_0
        fn_state.gs_118464 = s_2062_0;
        // N s_2062_2: jump b2063
        return block_2063(state, tracer, fn_state);
    }
    fn block_2063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2063_0: read-var gs#118464:u8
        let s_2063_0: bool = fn_state.gs_118464;
        // N s_2063_1: branch s_2063_0 b4524 b2064
        if s_2063_0 {
            return block_4524(state, tracer, fn_state);
        } else {
            return block_2064(state, tracer, fn_state);
        };
    }
    fn block_2064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2064_0: const #0u : u8
        let s_2064_0: bool = false;
        // D s_2064_1: write-var gs#118465 <= s_2064_0
        fn_state.gs_118465 = s_2064_0;
        // N s_2064_2: jump b2065
        return block_2065(state, tracer, fn_state);
    }
    fn block_2065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2065_0: read-var gs#118465:u8
        let s_2065_0: bool = fn_state.gs_118465;
        // N s_2065_1: branch s_2065_0 b4523 b2066
        if s_2065_0 {
            return block_4523(state, tracer, fn_state);
        } else {
            return block_2066(state, tracer, fn_state);
        };
    }
    fn block_2066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2066_0: const #0u : u8
        let s_2066_0: bool = false;
        // D s_2066_1: write-var gs#118466 <= s_2066_0
        fn_state.gs_118466 = s_2066_0;
        // N s_2066_2: jump b2067
        return block_2067(state, tracer, fn_state);
    }
    fn block_2067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2067_0: read-var gs#118466:u8
        let s_2067_0: bool = fn_state.gs_118466;
        // N s_2067_1: branch s_2067_0 b4522 b2068
        if s_2067_0 {
            return block_4522(state, tracer, fn_state);
        } else {
            return block_2068(state, tracer, fn_state);
        };
    }
    fn block_2068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2068_0: const #0u : u8
        let s_2068_0: bool = false;
        // D s_2068_1: write-var gs#118467 <= s_2068_0
        fn_state.gs_118467 = s_2068_0;
        // N s_2068_2: jump b2069
        return block_2069(state, tracer, fn_state);
    }
    fn block_2069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2069_0: read-var gs#118467:u8
        let s_2069_0: bool = fn_state.gs_118467;
        // N s_2069_1: branch s_2069_0 b4521 b2070
        if s_2069_0 {
            return block_4521(state, tracer, fn_state);
        } else {
            return block_2070(state, tracer, fn_state);
        };
    }
    fn block_2070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2070_0: read-var CRm:u8
        let s_2070_0: u8 = fn_state.CRm;
        // D s_2070_1: cast zx s_2070_0 -> bv
        let s_2070_1: Bits = Bits::new(s_2070_0 as u128, 4u16);
        // C s_2070_2: const #13u : u8
        let s_2070_2: u8 = 13;
        // C s_2070_3: cast zx s_2070_2 -> bv
        let s_2070_3: Bits = Bits::new(s_2070_2 as u128, 4u16);
        // D s_2070_4: cmp-eq s_2070_1 s_2070_3
        let s_2070_4: bool = ((s_2070_1) == (s_2070_3));
        // N s_2070_5: branch s_2070_4 b4520 b2071
        if s_2070_4 {
            return block_4520(state, tracer, fn_state);
        } else {
            return block_2071(state, tracer, fn_state);
        };
    }
    fn block_2071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2071_0: const #0u : u8
        let s_2071_0: bool = false;
        // D s_2071_1: write-var gs#118468 <= s_2071_0
        fn_state.gs_118468 = s_2071_0;
        // N s_2071_2: jump b2072
        return block_2072(state, tracer, fn_state);
    }
    fn block_2072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2072_0: read-var gs#118468:u8
        let s_2072_0: bool = fn_state.gs_118468;
        // N s_2072_1: branch s_2072_0 b4519 b2073
        if s_2072_0 {
            return block_4519(state, tracer, fn_state);
        } else {
            return block_2073(state, tracer, fn_state);
        };
    }
    fn block_2073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2073_0: const #0u : u8
        let s_2073_0: bool = false;
        // D s_2073_1: write-var gs#118469 <= s_2073_0
        fn_state.gs_118469 = s_2073_0;
        // N s_2073_2: jump b2074
        return block_2074(state, tracer, fn_state);
    }
    fn block_2074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2074_0: read-var gs#118469:u8
        let s_2074_0: bool = fn_state.gs_118469;
        // N s_2074_1: branch s_2074_0 b4518 b2075
        if s_2074_0 {
            return block_4518(state, tracer, fn_state);
        } else {
            return block_2075(state, tracer, fn_state);
        };
    }
    fn block_2075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2075_0: const #0u : u8
        let s_2075_0: bool = false;
        // D s_2075_1: write-var gs#118470 <= s_2075_0
        fn_state.gs_118470 = s_2075_0;
        // N s_2075_2: jump b2076
        return block_2076(state, tracer, fn_state);
    }
    fn block_2076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2076_0: read-var gs#118470:u8
        let s_2076_0: bool = fn_state.gs_118470;
        // N s_2076_1: branch s_2076_0 b4517 b2077
        if s_2076_0 {
            return block_4517(state, tracer, fn_state);
        } else {
            return block_2077(state, tracer, fn_state);
        };
    }
    fn block_2077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2077_0: const #0u : u8
        let s_2077_0: bool = false;
        // D s_2077_1: write-var gs#118471 <= s_2077_0
        fn_state.gs_118471 = s_2077_0;
        // N s_2077_2: jump b2078
        return block_2078(state, tracer, fn_state);
    }
    fn block_2078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2078_0: read-var gs#118471:u8
        let s_2078_0: bool = fn_state.gs_118471;
        // N s_2078_1: branch s_2078_0 b4516 b2079
        if s_2078_0 {
            return block_4516(state, tracer, fn_state);
        } else {
            return block_2079(state, tracer, fn_state);
        };
    }
    fn block_2079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2079_0: read-var CRm:u8
        let s_2079_0: u8 = fn_state.CRm;
        // D s_2079_1: cast zx s_2079_0 -> bv
        let s_2079_1: Bits = Bits::new(s_2079_0 as u128, 4u16);
        // C s_2079_2: const #12u : u8
        let s_2079_2: u8 = 12;
        // C s_2079_3: cast zx s_2079_2 -> bv
        let s_2079_3: Bits = Bits::new(s_2079_2 as u128, 4u16);
        // D s_2079_4: cmp-eq s_2079_1 s_2079_3
        let s_2079_4: bool = ((s_2079_1) == (s_2079_3));
        // N s_2079_5: branch s_2079_4 b4515 b2080
        if s_2079_4 {
            return block_4515(state, tracer, fn_state);
        } else {
            return block_2080(state, tracer, fn_state);
        };
    }
    fn block_2080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2080_0: const #0u : u8
        let s_2080_0: bool = false;
        // D s_2080_1: write-var gs#118472 <= s_2080_0
        fn_state.gs_118472 = s_2080_0;
        // N s_2080_2: jump b2081
        return block_2081(state, tracer, fn_state);
    }
    fn block_2081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2081_0: read-var gs#118472:u8
        let s_2081_0: bool = fn_state.gs_118472;
        // N s_2081_1: branch s_2081_0 b4514 b2082
        if s_2081_0 {
            return block_4514(state, tracer, fn_state);
        } else {
            return block_2082(state, tracer, fn_state);
        };
    }
    fn block_2082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2082_0: const #0u : u8
        let s_2082_0: bool = false;
        // D s_2082_1: write-var gs#118473 <= s_2082_0
        fn_state.gs_118473 = s_2082_0;
        // N s_2082_2: jump b2083
        return block_2083(state, tracer, fn_state);
    }
    fn block_2083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2083_0: read-var gs#118473:u8
        let s_2083_0: bool = fn_state.gs_118473;
        // N s_2083_1: branch s_2083_0 b4513 b2084
        if s_2083_0 {
            return block_4513(state, tracer, fn_state);
        } else {
            return block_2084(state, tracer, fn_state);
        };
    }
    fn block_2084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2084_0: const #0u : u8
        let s_2084_0: bool = false;
        // D s_2084_1: write-var gs#118474 <= s_2084_0
        fn_state.gs_118474 = s_2084_0;
        // N s_2084_2: jump b2085
        return block_2085(state, tracer, fn_state);
    }
    fn block_2085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2085_0: read-var gs#118474:u8
        let s_2085_0: bool = fn_state.gs_118474;
        // N s_2085_1: branch s_2085_0 b4512 b2086
        if s_2085_0 {
            return block_4512(state, tracer, fn_state);
        } else {
            return block_2086(state, tracer, fn_state);
        };
    }
    fn block_2086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2086_0: const #0u : u8
        let s_2086_0: bool = false;
        // D s_2086_1: write-var gs#118475 <= s_2086_0
        fn_state.gs_118475 = s_2086_0;
        // N s_2086_2: jump b2087
        return block_2087(state, tracer, fn_state);
    }
    fn block_2087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2087_0: read-var gs#118475:u8
        let s_2087_0: bool = fn_state.gs_118475;
        // N s_2087_1: branch s_2087_0 b4511 b2088
        if s_2087_0 {
            return block_4511(state, tracer, fn_state);
        } else {
            return block_2088(state, tracer, fn_state);
        };
    }
    fn block_2088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2088_0: read-var CRm:u8
        let s_2088_0: u8 = fn_state.CRm;
        // D s_2088_1: cast zx s_2088_0 -> bv
        let s_2088_1: Bits = Bits::new(s_2088_0 as u128, 4u16);
        // C s_2088_2: const #12u : u8
        let s_2088_2: u8 = 12;
        // C s_2088_3: cast zx s_2088_2 -> bv
        let s_2088_3: Bits = Bits::new(s_2088_2 as u128, 4u16);
        // D s_2088_4: cmp-eq s_2088_1 s_2088_3
        let s_2088_4: bool = ((s_2088_1) == (s_2088_3));
        // N s_2088_5: branch s_2088_4 b4510 b2089
        if s_2088_4 {
            return block_4510(state, tracer, fn_state);
        } else {
            return block_2089(state, tracer, fn_state);
        };
    }
    fn block_2089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2089_0: const #0u : u8
        let s_2089_0: bool = false;
        // D s_2089_1: write-var gs#118476 <= s_2089_0
        fn_state.gs_118476 = s_2089_0;
        // N s_2089_2: jump b2090
        return block_2090(state, tracer, fn_state);
    }
    fn block_2090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2090_0: read-var gs#118476:u8
        let s_2090_0: bool = fn_state.gs_118476;
        // N s_2090_1: branch s_2090_0 b4509 b2091
        if s_2090_0 {
            return block_4509(state, tracer, fn_state);
        } else {
            return block_2091(state, tracer, fn_state);
        };
    }
    fn block_2091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2091_0: const #0u : u8
        let s_2091_0: bool = false;
        // D s_2091_1: write-var gs#118477 <= s_2091_0
        fn_state.gs_118477 = s_2091_0;
        // N s_2091_2: jump b2092
        return block_2092(state, tracer, fn_state);
    }
    fn block_2092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2092_0: read-var gs#118477:u8
        let s_2092_0: bool = fn_state.gs_118477;
        // N s_2092_1: branch s_2092_0 b4508 b2093
        if s_2092_0 {
            return block_4508(state, tracer, fn_state);
        } else {
            return block_2093(state, tracer, fn_state);
        };
    }
    fn block_2093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2093_0: const #0u : u8
        let s_2093_0: bool = false;
        // D s_2093_1: write-var gs#118478 <= s_2093_0
        fn_state.gs_118478 = s_2093_0;
        // N s_2093_2: jump b2094
        return block_2094(state, tracer, fn_state);
    }
    fn block_2094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2094_0: read-var gs#118478:u8
        let s_2094_0: bool = fn_state.gs_118478;
        // N s_2094_1: branch s_2094_0 b4507 b2095
        if s_2094_0 {
            return block_4507(state, tracer, fn_state);
        } else {
            return block_2095(state, tracer, fn_state);
        };
    }
    fn block_2095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2095_0: const #0u : u8
        let s_2095_0: bool = false;
        // D s_2095_1: write-var gs#118479 <= s_2095_0
        fn_state.gs_118479 = s_2095_0;
        // N s_2095_2: jump b2096
        return block_2096(state, tracer, fn_state);
    }
    fn block_2096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2096_0: read-var gs#118479:u8
        let s_2096_0: bool = fn_state.gs_118479;
        // N s_2096_1: branch s_2096_0 b4506 b2097
        if s_2096_0 {
            return block_4506(state, tracer, fn_state);
        } else {
            return block_2097(state, tracer, fn_state);
        };
    }
    fn block_2097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2097_0: read-var CRm:u8
        let s_2097_0: u8 = fn_state.CRm;
        // D s_2097_1: cast zx s_2097_0 -> bv
        let s_2097_1: Bits = Bits::new(s_2097_0 as u128, 4u16);
        // C s_2097_2: const #12u : u8
        let s_2097_2: u8 = 12;
        // C s_2097_3: cast zx s_2097_2 -> bv
        let s_2097_3: Bits = Bits::new(s_2097_2 as u128, 4u16);
        // D s_2097_4: cmp-eq s_2097_1 s_2097_3
        let s_2097_4: bool = ((s_2097_1) == (s_2097_3));
        // N s_2097_5: branch s_2097_4 b4505 b2098
        if s_2097_4 {
            return block_4505(state, tracer, fn_state);
        } else {
            return block_2098(state, tracer, fn_state);
        };
    }
    fn block_2098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2098_0: const #0u : u8
        let s_2098_0: bool = false;
        // D s_2098_1: write-var gs#118480 <= s_2098_0
        fn_state.gs_118480 = s_2098_0;
        // N s_2098_2: jump b2099
        return block_2099(state, tracer, fn_state);
    }
    fn block_2099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2099_0: read-var gs#118480:u8
        let s_2099_0: bool = fn_state.gs_118480;
        // N s_2099_1: branch s_2099_0 b4504 b2100
        if s_2099_0 {
            return block_4504(state, tracer, fn_state);
        } else {
            return block_2100(state, tracer, fn_state);
        };
    }
    fn block_2100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2100_0: const #0u : u8
        let s_2100_0: bool = false;
        // D s_2100_1: write-var gs#118481 <= s_2100_0
        fn_state.gs_118481 = s_2100_0;
        // N s_2100_2: jump b2101
        return block_2101(state, tracer, fn_state);
    }
    fn block_2101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2101_0: read-var gs#118481:u8
        let s_2101_0: bool = fn_state.gs_118481;
        // N s_2101_1: branch s_2101_0 b4503 b2102
        if s_2101_0 {
            return block_4503(state, tracer, fn_state);
        } else {
            return block_2102(state, tracer, fn_state);
        };
    }
    fn block_2102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2102_0: const #0u : u8
        let s_2102_0: bool = false;
        // D s_2102_1: write-var gs#118482 <= s_2102_0
        fn_state.gs_118482 = s_2102_0;
        // N s_2102_2: jump b2103
        return block_2103(state, tracer, fn_state);
    }
    fn block_2103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2103_0: read-var gs#118482:u8
        let s_2103_0: bool = fn_state.gs_118482;
        // N s_2103_1: branch s_2103_0 b4502 b2104
        if s_2103_0 {
            return block_4502(state, tracer, fn_state);
        } else {
            return block_2104(state, tracer, fn_state);
        };
    }
    fn block_2104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2104_0: const #0u : u8
        let s_2104_0: bool = false;
        // D s_2104_1: write-var gs#118483 <= s_2104_0
        fn_state.gs_118483 = s_2104_0;
        // N s_2104_2: jump b2105
        return block_2105(state, tracer, fn_state);
    }
    fn block_2105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2105_0: read-var gs#118483:u8
        let s_2105_0: bool = fn_state.gs_118483;
        // N s_2105_1: branch s_2105_0 b4501 b2106
        if s_2105_0 {
            return block_4501(state, tracer, fn_state);
        } else {
            return block_2106(state, tracer, fn_state);
        };
    }
    fn block_2106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2106_0: read-var CRm:u8
        let s_2106_0: u8 = fn_state.CRm;
        // D s_2106_1: cast zx s_2106_0 -> bv
        let s_2106_1: Bits = Bits::new(s_2106_0 as u128, 4u16);
        // C s_2106_2: const #12u : u8
        let s_2106_2: u8 = 12;
        // C s_2106_3: cast zx s_2106_2 -> bv
        let s_2106_3: Bits = Bits::new(s_2106_2 as u128, 4u16);
        // D s_2106_4: cmp-eq s_2106_1 s_2106_3
        let s_2106_4: bool = ((s_2106_1) == (s_2106_3));
        // N s_2106_5: branch s_2106_4 b4500 b2107
        if s_2106_4 {
            return block_4500(state, tracer, fn_state);
        } else {
            return block_2107(state, tracer, fn_state);
        };
    }
    fn block_2107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2107_0: const #0u : u8
        let s_2107_0: bool = false;
        // D s_2107_1: write-var gs#118484 <= s_2107_0
        fn_state.gs_118484 = s_2107_0;
        // N s_2107_2: jump b2108
        return block_2108(state, tracer, fn_state);
    }
    fn block_2108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2108_0: read-var gs#118484:u8
        let s_2108_0: bool = fn_state.gs_118484;
        // N s_2108_1: branch s_2108_0 b4499 b2109
        if s_2108_0 {
            return block_4499(state, tracer, fn_state);
        } else {
            return block_2109(state, tracer, fn_state);
        };
    }
    fn block_2109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2109_0: const #0u : u8
        let s_2109_0: bool = false;
        // D s_2109_1: write-var gs#118485 <= s_2109_0
        fn_state.gs_118485 = s_2109_0;
        // N s_2109_2: jump b2110
        return block_2110(state, tracer, fn_state);
    }
    fn block_2110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2110_0: read-var gs#118485:u8
        let s_2110_0: bool = fn_state.gs_118485;
        // N s_2110_1: branch s_2110_0 b4498 b2111
        if s_2110_0 {
            return block_4498(state, tracer, fn_state);
        } else {
            return block_2111(state, tracer, fn_state);
        };
    }
    fn block_2111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2111_0: const #0u : u8
        let s_2111_0: bool = false;
        // D s_2111_1: write-var gs#118486 <= s_2111_0
        fn_state.gs_118486 = s_2111_0;
        // N s_2111_2: jump b2112
        return block_2112(state, tracer, fn_state);
    }
    fn block_2112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2112_0: read-var gs#118486:u8
        let s_2112_0: bool = fn_state.gs_118486;
        // N s_2112_1: branch s_2112_0 b4497 b2113
        if s_2112_0 {
            return block_4497(state, tracer, fn_state);
        } else {
            return block_2113(state, tracer, fn_state);
        };
    }
    fn block_2113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2113_0: const #0u : u8
        let s_2113_0: bool = false;
        // D s_2113_1: write-var gs#118487 <= s_2113_0
        fn_state.gs_118487 = s_2113_0;
        // N s_2113_2: jump b2114
        return block_2114(state, tracer, fn_state);
    }
    fn block_2114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2114_0: read-var gs#118487:u8
        let s_2114_0: bool = fn_state.gs_118487;
        // N s_2114_1: branch s_2114_0 b4496 b2115
        if s_2114_0 {
            return block_4496(state, tracer, fn_state);
        } else {
            return block_2115(state, tracer, fn_state);
        };
    }
    fn block_2115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2115_0: read-var CRm:u8
        let s_2115_0: u8 = fn_state.CRm;
        // D s_2115_1: cast zx s_2115_0 -> bv
        let s_2115_1: Bits = Bits::new(s_2115_0 as u128, 4u16);
        // C s_2115_2: const #12u : u8
        let s_2115_2: u8 = 12;
        // C s_2115_3: cast zx s_2115_2 -> bv
        let s_2115_3: Bits = Bits::new(s_2115_2 as u128, 4u16);
        // D s_2115_4: cmp-eq s_2115_1 s_2115_3
        let s_2115_4: bool = ((s_2115_1) == (s_2115_3));
        // N s_2115_5: branch s_2115_4 b4495 b2116
        if s_2115_4 {
            return block_4495(state, tracer, fn_state);
        } else {
            return block_2116(state, tracer, fn_state);
        };
    }
    fn block_2116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2116_0: const #0u : u8
        let s_2116_0: bool = false;
        // D s_2116_1: write-var gs#118488 <= s_2116_0
        fn_state.gs_118488 = s_2116_0;
        // N s_2116_2: jump b2117
        return block_2117(state, tracer, fn_state);
    }
    fn block_2117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2117_0: read-var gs#118488:u8
        let s_2117_0: bool = fn_state.gs_118488;
        // N s_2117_1: branch s_2117_0 b4494 b2118
        if s_2117_0 {
            return block_4494(state, tracer, fn_state);
        } else {
            return block_2118(state, tracer, fn_state);
        };
    }
    fn block_2118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2118_0: const #0u : u8
        let s_2118_0: bool = false;
        // D s_2118_1: write-var gs#118489 <= s_2118_0
        fn_state.gs_118489 = s_2118_0;
        // N s_2118_2: jump b2119
        return block_2119(state, tracer, fn_state);
    }
    fn block_2119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2119_0: read-var gs#118489:u8
        let s_2119_0: bool = fn_state.gs_118489;
        // N s_2119_1: branch s_2119_0 b4493 b2120
        if s_2119_0 {
            return block_4493(state, tracer, fn_state);
        } else {
            return block_2120(state, tracer, fn_state);
        };
    }
    fn block_2120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2120_0: const #0u : u8
        let s_2120_0: bool = false;
        // D s_2120_1: write-var gs#118490 <= s_2120_0
        fn_state.gs_118490 = s_2120_0;
        // N s_2120_2: jump b2121
        return block_2121(state, tracer, fn_state);
    }
    fn block_2121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2121_0: read-var gs#118490:u8
        let s_2121_0: bool = fn_state.gs_118490;
        // N s_2121_1: branch s_2121_0 b4492 b2122
        if s_2121_0 {
            return block_4492(state, tracer, fn_state);
        } else {
            return block_2122(state, tracer, fn_state);
        };
    }
    fn block_2122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2122_0: const #0u : u8
        let s_2122_0: bool = false;
        // D s_2122_1: write-var gs#118491 <= s_2122_0
        fn_state.gs_118491 = s_2122_0;
        // N s_2122_2: jump b2123
        return block_2123(state, tracer, fn_state);
    }
    fn block_2123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2123_0: read-var gs#118491:u8
        let s_2123_0: bool = fn_state.gs_118491;
        // N s_2123_1: branch s_2123_0 b4491 b2124
        if s_2123_0 {
            return block_4491(state, tracer, fn_state);
        } else {
            return block_2124(state, tracer, fn_state);
        };
    }
    fn block_2124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2124_0: read-var CRm:u8
        let s_2124_0: u8 = fn_state.CRm;
        // D s_2124_1: cast zx s_2124_0 -> bv
        let s_2124_1: Bits = Bits::new(s_2124_0 as u128, 4u16);
        // C s_2124_2: const #12u : u8
        let s_2124_2: u8 = 12;
        // C s_2124_3: cast zx s_2124_2 -> bv
        let s_2124_3: Bits = Bits::new(s_2124_2 as u128, 4u16);
        // D s_2124_4: cmp-eq s_2124_1 s_2124_3
        let s_2124_4: bool = ((s_2124_1) == (s_2124_3));
        // N s_2124_5: branch s_2124_4 b4490 b2125
        if s_2124_4 {
            return block_4490(state, tracer, fn_state);
        } else {
            return block_2125(state, tracer, fn_state);
        };
    }
    fn block_2125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2125_0: const #0u : u8
        let s_2125_0: bool = false;
        // D s_2125_1: write-var gs#118492 <= s_2125_0
        fn_state.gs_118492 = s_2125_0;
        // N s_2125_2: jump b2126
        return block_2126(state, tracer, fn_state);
    }
    fn block_2126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2126_0: read-var gs#118492:u8
        let s_2126_0: bool = fn_state.gs_118492;
        // N s_2126_1: branch s_2126_0 b4489 b2127
        if s_2126_0 {
            return block_4489(state, tracer, fn_state);
        } else {
            return block_2127(state, tracer, fn_state);
        };
    }
    fn block_2127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2127_0: const #0u : u8
        let s_2127_0: bool = false;
        // D s_2127_1: write-var gs#118493 <= s_2127_0
        fn_state.gs_118493 = s_2127_0;
        // N s_2127_2: jump b2128
        return block_2128(state, tracer, fn_state);
    }
    fn block_2128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2128_0: read-var gs#118493:u8
        let s_2128_0: bool = fn_state.gs_118493;
        // N s_2128_1: branch s_2128_0 b4488 b2129
        if s_2128_0 {
            return block_4488(state, tracer, fn_state);
        } else {
            return block_2129(state, tracer, fn_state);
        };
    }
    fn block_2129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2129_0: const #0u : u8
        let s_2129_0: bool = false;
        // D s_2129_1: write-var gs#118494 <= s_2129_0
        fn_state.gs_118494 = s_2129_0;
        // N s_2129_2: jump b2130
        return block_2130(state, tracer, fn_state);
    }
    fn block_2130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2130_0: read-var gs#118494:u8
        let s_2130_0: bool = fn_state.gs_118494;
        // N s_2130_1: branch s_2130_0 b4487 b2131
        if s_2130_0 {
            return block_4487(state, tracer, fn_state);
        } else {
            return block_2131(state, tracer, fn_state);
        };
    }
    fn block_2131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2131_0: const #0u : u8
        let s_2131_0: bool = false;
        // D s_2131_1: write-var gs#118495 <= s_2131_0
        fn_state.gs_118495 = s_2131_0;
        // N s_2131_2: jump b2132
        return block_2132(state, tracer, fn_state);
    }
    fn block_2132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2132_0: read-var gs#118495:u8
        let s_2132_0: bool = fn_state.gs_118495;
        // N s_2132_1: branch s_2132_0 b4486 b2133
        if s_2132_0 {
            return block_4486(state, tracer, fn_state);
        } else {
            return block_2133(state, tracer, fn_state);
        };
    }
    fn block_2133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2133_0: read-var CRm:u8
        let s_2133_0: u8 = fn_state.CRm;
        // D s_2133_1: cast zx s_2133_0 -> bv
        let s_2133_1: Bits = Bits::new(s_2133_0 as u128, 4u16);
        // C s_2133_2: const #12u : u8
        let s_2133_2: u8 = 12;
        // C s_2133_3: cast zx s_2133_2 -> bv
        let s_2133_3: Bits = Bits::new(s_2133_2 as u128, 4u16);
        // D s_2133_4: cmp-eq s_2133_1 s_2133_3
        let s_2133_4: bool = ((s_2133_1) == (s_2133_3));
        // N s_2133_5: branch s_2133_4 b4485 b2134
        if s_2133_4 {
            return block_4485(state, tracer, fn_state);
        } else {
            return block_2134(state, tracer, fn_state);
        };
    }
    fn block_2134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2134_0: const #0u : u8
        let s_2134_0: bool = false;
        // D s_2134_1: write-var gs#118496 <= s_2134_0
        fn_state.gs_118496 = s_2134_0;
        // N s_2134_2: jump b2135
        return block_2135(state, tracer, fn_state);
    }
    fn block_2135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2135_0: read-var gs#118496:u8
        let s_2135_0: bool = fn_state.gs_118496;
        // N s_2135_1: branch s_2135_0 b4484 b2136
        if s_2135_0 {
            return block_4484(state, tracer, fn_state);
        } else {
            return block_2136(state, tracer, fn_state);
        };
    }
    fn block_2136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2136_0: const #0u : u8
        let s_2136_0: bool = false;
        // D s_2136_1: write-var gs#118497 <= s_2136_0
        fn_state.gs_118497 = s_2136_0;
        // N s_2136_2: jump b2137
        return block_2137(state, tracer, fn_state);
    }
    fn block_2137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2137_0: read-var gs#118497:u8
        let s_2137_0: bool = fn_state.gs_118497;
        // N s_2137_1: branch s_2137_0 b4483 b2138
        if s_2137_0 {
            return block_4483(state, tracer, fn_state);
        } else {
            return block_2138(state, tracer, fn_state);
        };
    }
    fn block_2138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2138_0: const #0u : u8
        let s_2138_0: bool = false;
        // D s_2138_1: write-var gs#118498 <= s_2138_0
        fn_state.gs_118498 = s_2138_0;
        // N s_2138_2: jump b2139
        return block_2139(state, tracer, fn_state);
    }
    fn block_2139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2139_0: read-var gs#118498:u8
        let s_2139_0: bool = fn_state.gs_118498;
        // N s_2139_1: branch s_2139_0 b4482 b2140
        if s_2139_0 {
            return block_4482(state, tracer, fn_state);
        } else {
            return block_2140(state, tracer, fn_state);
        };
    }
    fn block_2140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2140_0: const #0u : u8
        let s_2140_0: bool = false;
        // D s_2140_1: write-var gs#118499 <= s_2140_0
        fn_state.gs_118499 = s_2140_0;
        // N s_2140_2: jump b2141
        return block_2141(state, tracer, fn_state);
    }
    fn block_2141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2141_0: read-var gs#118499:u8
        let s_2141_0: bool = fn_state.gs_118499;
        // N s_2141_1: branch s_2141_0 b4481 b2142
        if s_2141_0 {
            return block_4481(state, tracer, fn_state);
        } else {
            return block_2142(state, tracer, fn_state);
        };
    }
    fn block_2142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2142_0: read-var CRm:u8
        let s_2142_0: u8 = fn_state.CRm;
        // D s_2142_1: cast zx s_2142_0 -> bv
        let s_2142_1: Bits = Bits::new(s_2142_0 as u128, 4u16);
        // C s_2142_2: const #12u : u8
        let s_2142_2: u8 = 12;
        // C s_2142_3: cast zx s_2142_2 -> bv
        let s_2142_3: Bits = Bits::new(s_2142_2 as u128, 4u16);
        // D s_2142_4: cmp-eq s_2142_1 s_2142_3
        let s_2142_4: bool = ((s_2142_1) == (s_2142_3));
        // N s_2142_5: branch s_2142_4 b4480 b2143
        if s_2142_4 {
            return block_4480(state, tracer, fn_state);
        } else {
            return block_2143(state, tracer, fn_state);
        };
    }
    fn block_2143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2143_0: const #0u : u8
        let s_2143_0: bool = false;
        // D s_2143_1: write-var gs#118500 <= s_2143_0
        fn_state.gs_118500 = s_2143_0;
        // N s_2143_2: jump b2144
        return block_2144(state, tracer, fn_state);
    }
    fn block_2144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2144_0: read-var gs#118500:u8
        let s_2144_0: bool = fn_state.gs_118500;
        // N s_2144_1: branch s_2144_0 b4479 b2145
        if s_2144_0 {
            return block_4479(state, tracer, fn_state);
        } else {
            return block_2145(state, tracer, fn_state);
        };
    }
    fn block_2145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2145_0: const #0u : u8
        let s_2145_0: bool = false;
        // D s_2145_1: write-var gs#118501 <= s_2145_0
        fn_state.gs_118501 = s_2145_0;
        // N s_2145_2: jump b2146
        return block_2146(state, tracer, fn_state);
    }
    fn block_2146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2146_0: read-var gs#118501:u8
        let s_2146_0: bool = fn_state.gs_118501;
        // N s_2146_1: branch s_2146_0 b4478 b2147
        if s_2146_0 {
            return block_4478(state, tracer, fn_state);
        } else {
            return block_2147(state, tracer, fn_state);
        };
    }
    fn block_2147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2147_0: const #0u : u8
        let s_2147_0: bool = false;
        // D s_2147_1: write-var gs#118502 <= s_2147_0
        fn_state.gs_118502 = s_2147_0;
        // N s_2147_2: jump b2148
        return block_2148(state, tracer, fn_state);
    }
    fn block_2148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2148_0: read-var gs#118502:u8
        let s_2148_0: bool = fn_state.gs_118502;
        // N s_2148_1: branch s_2148_0 b4477 b2149
        if s_2148_0 {
            return block_4477(state, tracer, fn_state);
        } else {
            return block_2149(state, tracer, fn_state);
        };
    }
    fn block_2149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2149_0: const #0u : u8
        let s_2149_0: bool = false;
        // D s_2149_1: write-var gs#118503 <= s_2149_0
        fn_state.gs_118503 = s_2149_0;
        // N s_2149_2: jump b2150
        return block_2150(state, tracer, fn_state);
    }
    fn block_2150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2150_0: read-var gs#118503:u8
        let s_2150_0: bool = fn_state.gs_118503;
        // N s_2150_1: branch s_2150_0 b4476 b2151
        if s_2150_0 {
            return block_4476(state, tracer, fn_state);
        } else {
            return block_2151(state, tracer, fn_state);
        };
    }
    fn block_2151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2151_0: read-var CRm:u8
        let s_2151_0: u8 = fn_state.CRm;
        // D s_2151_1: cast zx s_2151_0 -> bv
        let s_2151_1: Bits = Bits::new(s_2151_0 as u128, 4u16);
        // C s_2151_2: const #1u : u8
        let s_2151_2: u8 = 1;
        // C s_2151_3: cast zx s_2151_2 -> bv
        let s_2151_3: Bits = Bits::new(s_2151_2 as u128, 4u16);
        // D s_2151_4: cmp-eq s_2151_1 s_2151_3
        let s_2151_4: bool = ((s_2151_1) == (s_2151_3));
        // N s_2151_5: branch s_2151_4 b4475 b2152
        if s_2151_4 {
            return block_4475(state, tracer, fn_state);
        } else {
            return block_2152(state, tracer, fn_state);
        };
    }
    fn block_2152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2152_0: const #0u : u8
        let s_2152_0: bool = false;
        // D s_2152_1: write-var gs#118504 <= s_2152_0
        fn_state.gs_118504 = s_2152_0;
        // N s_2152_2: jump b2153
        return block_2153(state, tracer, fn_state);
    }
    fn block_2153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2153_0: read-var gs#118504:u8
        let s_2153_0: bool = fn_state.gs_118504;
        // N s_2153_1: branch s_2153_0 b4474 b2154
        if s_2153_0 {
            return block_4474(state, tracer, fn_state);
        } else {
            return block_2154(state, tracer, fn_state);
        };
    }
    fn block_2154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2154_0: const #0u : u8
        let s_2154_0: bool = false;
        // D s_2154_1: write-var gs#118505 <= s_2154_0
        fn_state.gs_118505 = s_2154_0;
        // N s_2154_2: jump b2155
        return block_2155(state, tracer, fn_state);
    }
    fn block_2155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2155_0: read-var gs#118505:u8
        let s_2155_0: bool = fn_state.gs_118505;
        // N s_2155_1: branch s_2155_0 b4473 b2156
        if s_2155_0 {
            return block_4473(state, tracer, fn_state);
        } else {
            return block_2156(state, tracer, fn_state);
        };
    }
    fn block_2156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2156_0: const #0u : u8
        let s_2156_0: bool = false;
        // D s_2156_1: write-var gs#118506 <= s_2156_0
        fn_state.gs_118506 = s_2156_0;
        // N s_2156_2: jump b2157
        return block_2157(state, tracer, fn_state);
    }
    fn block_2157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2157_0: read-var gs#118506:u8
        let s_2157_0: bool = fn_state.gs_118506;
        // N s_2157_1: branch s_2157_0 b4472 b2158
        if s_2157_0 {
            return block_4472(state, tracer, fn_state);
        } else {
            return block_2158(state, tracer, fn_state);
        };
    }
    fn block_2158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2158_0: const #0u : u8
        let s_2158_0: bool = false;
        // D s_2158_1: write-var gs#118507 <= s_2158_0
        fn_state.gs_118507 = s_2158_0;
        // N s_2158_2: jump b2159
        return block_2159(state, tracer, fn_state);
    }
    fn block_2159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2159_0: read-var gs#118507:u8
        let s_2159_0: bool = fn_state.gs_118507;
        // N s_2159_1: branch s_2159_0 b4471 b2160
        if s_2159_0 {
            return block_4471(state, tracer, fn_state);
        } else {
            return block_2160(state, tracer, fn_state);
        };
    }
    fn block_2160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2160_0: read-var CRm:u8
        let s_2160_0: u8 = fn_state.CRm;
        // D s_2160_1: cast zx s_2160_0 -> bv
        let s_2160_1: Bits = Bits::new(s_2160_0 as u128, 4u16);
        // C s_2160_2: const #0u : u8
        let s_2160_2: u8 = 0;
        // C s_2160_3: cast zx s_2160_2 -> bv
        let s_2160_3: Bits = Bits::new(s_2160_2 as u128, 4u16);
        // D s_2160_4: cmp-eq s_2160_1 s_2160_3
        let s_2160_4: bool = ((s_2160_1) == (s_2160_3));
        // N s_2160_5: branch s_2160_4 b4470 b2161
        if s_2160_4 {
            return block_4470(state, tracer, fn_state);
        } else {
            return block_2161(state, tracer, fn_state);
        };
    }
    fn block_2161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2161_0: const #0u : u8
        let s_2161_0: bool = false;
        // D s_2161_1: write-var gs#118508 <= s_2161_0
        fn_state.gs_118508 = s_2161_0;
        // N s_2161_2: jump b2162
        return block_2162(state, tracer, fn_state);
    }
    fn block_2162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2162_0: read-var gs#118508:u8
        let s_2162_0: bool = fn_state.gs_118508;
        // N s_2162_1: branch s_2162_0 b4469 b2163
        if s_2162_0 {
            return block_4469(state, tracer, fn_state);
        } else {
            return block_2163(state, tracer, fn_state);
        };
    }
    fn block_2163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2163_0: const #0u : u8
        let s_2163_0: bool = false;
        // D s_2163_1: write-var gs#118509 <= s_2163_0
        fn_state.gs_118509 = s_2163_0;
        // N s_2163_2: jump b2164
        return block_2164(state, tracer, fn_state);
    }
    fn block_2164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2164_0: read-var gs#118509:u8
        let s_2164_0: bool = fn_state.gs_118509;
        // N s_2164_1: branch s_2164_0 b4468 b2165
        if s_2164_0 {
            return block_4468(state, tracer, fn_state);
        } else {
            return block_2165(state, tracer, fn_state);
        };
    }
    fn block_2165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2165_0: const #0u : u8
        let s_2165_0: bool = false;
        // D s_2165_1: write-var gs#118510 <= s_2165_0
        fn_state.gs_118510 = s_2165_0;
        // N s_2165_2: jump b2166
        return block_2166(state, tracer, fn_state);
    }
    fn block_2166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2166_0: read-var gs#118510:u8
        let s_2166_0: bool = fn_state.gs_118510;
        // N s_2166_1: branch s_2166_0 b4467 b2167
        if s_2166_0 {
            return block_4467(state, tracer, fn_state);
        } else {
            return block_2167(state, tracer, fn_state);
        };
    }
    fn block_2167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2167_0: const #0u : u8
        let s_2167_0: bool = false;
        // D s_2167_1: write-var gs#118511 <= s_2167_0
        fn_state.gs_118511 = s_2167_0;
        // N s_2167_2: jump b2168
        return block_2168(state, tracer, fn_state);
    }
    fn block_2168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2168_0: read-var gs#118511:u8
        let s_2168_0: bool = fn_state.gs_118511;
        // N s_2168_1: branch s_2168_0 b4466 b2169
        if s_2168_0 {
            return block_4466(state, tracer, fn_state);
        } else {
            return block_2169(state, tracer, fn_state);
        };
    }
    fn block_2169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2169_0: read-var CRm:u8
        let s_2169_0: u8 = fn_state.CRm;
        // D s_2169_1: cast zx s_2169_0 -> bv
        let s_2169_1: Bits = Bits::new(s_2169_0 as u128, 4u16);
        // C s_2169_2: const #1u : u8
        let s_2169_2: u8 = 1;
        // C s_2169_3: cast zx s_2169_2 -> bv
        let s_2169_3: Bits = Bits::new(s_2169_2 as u128, 4u16);
        // D s_2169_4: cmp-eq s_2169_1 s_2169_3
        let s_2169_4: bool = ((s_2169_1) == (s_2169_3));
        // N s_2169_5: branch s_2169_4 b4465 b2170
        if s_2169_4 {
            return block_4465(state, tracer, fn_state);
        } else {
            return block_2170(state, tracer, fn_state);
        };
    }
    fn block_2170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2170_0: const #0u : u8
        let s_2170_0: bool = false;
        // D s_2170_1: write-var gs#118512 <= s_2170_0
        fn_state.gs_118512 = s_2170_0;
        // N s_2170_2: jump b2171
        return block_2171(state, tracer, fn_state);
    }
    fn block_2171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2171_0: read-var gs#118512:u8
        let s_2171_0: bool = fn_state.gs_118512;
        // N s_2171_1: branch s_2171_0 b4464 b2172
        if s_2171_0 {
            return block_4464(state, tracer, fn_state);
        } else {
            return block_2172(state, tracer, fn_state);
        };
    }
    fn block_2172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2172_0: const #0u : u8
        let s_2172_0: bool = false;
        // D s_2172_1: write-var gs#118513 <= s_2172_0
        fn_state.gs_118513 = s_2172_0;
        // N s_2172_2: jump b2173
        return block_2173(state, tracer, fn_state);
    }
    fn block_2173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2173_0: read-var gs#118513:u8
        let s_2173_0: bool = fn_state.gs_118513;
        // N s_2173_1: branch s_2173_0 b4463 b2174
        if s_2173_0 {
            return block_4463(state, tracer, fn_state);
        } else {
            return block_2174(state, tracer, fn_state);
        };
    }
    fn block_2174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2174_0: const #0u : u8
        let s_2174_0: bool = false;
        // D s_2174_1: write-var gs#118514 <= s_2174_0
        fn_state.gs_118514 = s_2174_0;
        // N s_2174_2: jump b2175
        return block_2175(state, tracer, fn_state);
    }
    fn block_2175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2175_0: read-var gs#118514:u8
        let s_2175_0: bool = fn_state.gs_118514;
        // N s_2175_1: branch s_2175_0 b4462 b2176
        if s_2175_0 {
            return block_4462(state, tracer, fn_state);
        } else {
            return block_2176(state, tracer, fn_state);
        };
    }
    fn block_2176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2176_0: const #0u : u8
        let s_2176_0: bool = false;
        // D s_2176_1: write-var gs#118515 <= s_2176_0
        fn_state.gs_118515 = s_2176_0;
        // N s_2176_2: jump b2177
        return block_2177(state, tracer, fn_state);
    }
    fn block_2177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2177_0: read-var gs#118515:u8
        let s_2177_0: bool = fn_state.gs_118515;
        // N s_2177_1: branch s_2177_0 b4461 b2178
        if s_2177_0 {
            return block_4461(state, tracer, fn_state);
        } else {
            return block_2178(state, tracer, fn_state);
        };
    }
    fn block_2178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2178_0: read-var CRm:u8
        let s_2178_0: u8 = fn_state.CRm;
        // D s_2178_1: cast zx s_2178_0 -> bv
        let s_2178_1: Bits = Bits::new(s_2178_0 as u128, 4u16);
        // C s_2178_2: const #14u : u8
        let s_2178_2: u8 = 14;
        // C s_2178_3: cast zx s_2178_2 -> bv
        let s_2178_3: Bits = Bits::new(s_2178_2 as u128, 4u16);
        // D s_2178_4: cmp-eq s_2178_1 s_2178_3
        let s_2178_4: bool = ((s_2178_1) == (s_2178_3));
        // N s_2178_5: branch s_2178_4 b4460 b2179
        if s_2178_4 {
            return block_4460(state, tracer, fn_state);
        } else {
            return block_2179(state, tracer, fn_state);
        };
    }
    fn block_2179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2179_0: const #0u : u8
        let s_2179_0: bool = false;
        // D s_2179_1: write-var gs#118516 <= s_2179_0
        fn_state.gs_118516 = s_2179_0;
        // N s_2179_2: jump b2180
        return block_2180(state, tracer, fn_state);
    }
    fn block_2180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2180_0: read-var gs#118516:u8
        let s_2180_0: bool = fn_state.gs_118516;
        // N s_2180_1: branch s_2180_0 b4459 b2181
        if s_2180_0 {
            return block_4459(state, tracer, fn_state);
        } else {
            return block_2181(state, tracer, fn_state);
        };
    }
    fn block_2181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2181_0: const #0u : u8
        let s_2181_0: bool = false;
        // D s_2181_1: write-var gs#118517 <= s_2181_0
        fn_state.gs_118517 = s_2181_0;
        // N s_2181_2: jump b2182
        return block_2182(state, tracer, fn_state);
    }
    fn block_2182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2182_0: read-var gs#118517:u8
        let s_2182_0: bool = fn_state.gs_118517;
        // N s_2182_1: branch s_2182_0 b4458 b2183
        if s_2182_0 {
            return block_4458(state, tracer, fn_state);
        } else {
            return block_2183(state, tracer, fn_state);
        };
    }
    fn block_2183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2183_0: const #0u : u8
        let s_2183_0: bool = false;
        // D s_2183_1: write-var gs#118518 <= s_2183_0
        fn_state.gs_118518 = s_2183_0;
        // N s_2183_2: jump b2184
        return block_2184(state, tracer, fn_state);
    }
    fn block_2184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2184_0: read-var gs#118518:u8
        let s_2184_0: bool = fn_state.gs_118518;
        // N s_2184_1: branch s_2184_0 b4457 b2185
        if s_2184_0 {
            return block_4457(state, tracer, fn_state);
        } else {
            return block_2185(state, tracer, fn_state);
        };
    }
    fn block_2185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2185_0: const #0u : u8
        let s_2185_0: bool = false;
        // D s_2185_1: write-var gs#118519 <= s_2185_0
        fn_state.gs_118519 = s_2185_0;
        // N s_2185_2: jump b2186
        return block_2186(state, tracer, fn_state);
    }
    fn block_2186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2186_0: read-var gs#118519:u8
        let s_2186_0: bool = fn_state.gs_118519;
        // N s_2186_1: branch s_2186_0 b4456 b2187
        if s_2186_0 {
            return block_4456(state, tracer, fn_state);
        } else {
            return block_2187(state, tracer, fn_state);
        };
    }
    fn block_2187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2187_0: read-var CRm:u8
        let s_2187_0: u8 = fn_state.CRm;
        // D s_2187_1: cast zx s_2187_0 -> bv
        let s_2187_1: Bits = Bits::new(s_2187_0 as u128, 4u16);
        // C s_2187_2: const #15u : u8
        let s_2187_2: u8 = 15;
        // C s_2187_3: cast zx s_2187_2 -> bv
        let s_2187_3: Bits = Bits::new(s_2187_2 as u128, 4u16);
        // D s_2187_4: cmp-eq s_2187_1 s_2187_3
        let s_2187_4: bool = ((s_2187_1) == (s_2187_3));
        // N s_2187_5: branch s_2187_4 b4455 b2188
        if s_2187_4 {
            return block_4455(state, tracer, fn_state);
        } else {
            return block_2188(state, tracer, fn_state);
        };
    }
    fn block_2188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2188_0: const #0u : u8
        let s_2188_0: bool = false;
        // D s_2188_1: write-var gs#118520 <= s_2188_0
        fn_state.gs_118520 = s_2188_0;
        // N s_2188_2: jump b2189
        return block_2189(state, tracer, fn_state);
    }
    fn block_2189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2189_0: read-var gs#118520:u8
        let s_2189_0: bool = fn_state.gs_118520;
        // N s_2189_1: branch s_2189_0 b4454 b2190
        if s_2189_0 {
            return block_4454(state, tracer, fn_state);
        } else {
            return block_2190(state, tracer, fn_state);
        };
    }
    fn block_2190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2190_0: const #0u : u8
        let s_2190_0: bool = false;
        // D s_2190_1: write-var gs#118521 <= s_2190_0
        fn_state.gs_118521 = s_2190_0;
        // N s_2190_2: jump b2191
        return block_2191(state, tracer, fn_state);
    }
    fn block_2191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2191_0: read-var gs#118521:u8
        let s_2191_0: bool = fn_state.gs_118521;
        // N s_2191_1: branch s_2191_0 b4453 b2192
        if s_2191_0 {
            return block_4453(state, tracer, fn_state);
        } else {
            return block_2192(state, tracer, fn_state);
        };
    }
    fn block_2192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2192_0: const #0u : u8
        let s_2192_0: bool = false;
        // D s_2192_1: write-var gs#118522 <= s_2192_0
        fn_state.gs_118522 = s_2192_0;
        // N s_2192_2: jump b2193
        return block_2193(state, tracer, fn_state);
    }
    fn block_2193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2193_0: read-var gs#118522:u8
        let s_2193_0: bool = fn_state.gs_118522;
        // N s_2193_1: branch s_2193_0 b4452 b2194
        if s_2193_0 {
            return block_4452(state, tracer, fn_state);
        } else {
            return block_2194(state, tracer, fn_state);
        };
    }
    fn block_2194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2194_0: const #0u : u8
        let s_2194_0: bool = false;
        // D s_2194_1: write-var gs#118523 <= s_2194_0
        fn_state.gs_118523 = s_2194_0;
        // N s_2194_2: jump b2195
        return block_2195(state, tracer, fn_state);
    }
    fn block_2195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2195_0: read-var gs#118523:u8
        let s_2195_0: bool = fn_state.gs_118523;
        // N s_2195_1: branch s_2195_0 b4451 b2196
        if s_2195_0 {
            return block_4451(state, tracer, fn_state);
        } else {
            return block_2196(state, tracer, fn_state);
        };
    }
    fn block_2196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2196_0: read-var CRm:u8
        let s_2196_0: u8 = fn_state.CRm;
        // D s_2196_1: cast zx s_2196_0 -> bv
        let s_2196_1: Bits = Bits::new(s_2196_0 as u128, 4u16);
        // C s_2196_2: const #14u : u8
        let s_2196_2: u8 = 14;
        // C s_2196_3: cast zx s_2196_2 -> bv
        let s_2196_3: Bits = Bits::new(s_2196_2 as u128, 4u16);
        // D s_2196_4: cmp-eq s_2196_1 s_2196_3
        let s_2196_4: bool = ((s_2196_1) == (s_2196_3));
        // N s_2196_5: branch s_2196_4 b4450 b2197
        if s_2196_4 {
            return block_4450(state, tracer, fn_state);
        } else {
            return block_2197(state, tracer, fn_state);
        };
    }
    fn block_2197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2197_0: const #0u : u8
        let s_2197_0: bool = false;
        // D s_2197_1: write-var gs#118524 <= s_2197_0
        fn_state.gs_118524 = s_2197_0;
        // N s_2197_2: jump b2198
        return block_2198(state, tracer, fn_state);
    }
    fn block_2198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2198_0: read-var gs#118524:u8
        let s_2198_0: bool = fn_state.gs_118524;
        // N s_2198_1: branch s_2198_0 b4449 b2199
        if s_2198_0 {
            return block_4449(state, tracer, fn_state);
        } else {
            return block_2199(state, tracer, fn_state);
        };
    }
    fn block_2199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2199_0: const #0u : u8
        let s_2199_0: bool = false;
        // D s_2199_1: write-var gs#118525 <= s_2199_0
        fn_state.gs_118525 = s_2199_0;
        // N s_2199_2: jump b2200
        return block_2200(state, tracer, fn_state);
    }
    fn block_2200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2200_0: read-var gs#118525:u8
        let s_2200_0: bool = fn_state.gs_118525;
        // N s_2200_1: branch s_2200_0 b4448 b2201
        if s_2200_0 {
            return block_4448(state, tracer, fn_state);
        } else {
            return block_2201(state, tracer, fn_state);
        };
    }
    fn block_2201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2201_0: const #0u : u8
        let s_2201_0: bool = false;
        // D s_2201_1: write-var gs#118526 <= s_2201_0
        fn_state.gs_118526 = s_2201_0;
        // N s_2201_2: jump b2202
        return block_2202(state, tracer, fn_state);
    }
    fn block_2202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2202_0: read-var gs#118526:u8
        let s_2202_0: bool = fn_state.gs_118526;
        // N s_2202_1: branch s_2202_0 b4447 b2203
        if s_2202_0 {
            return block_4447(state, tracer, fn_state);
        } else {
            return block_2203(state, tracer, fn_state);
        };
    }
    fn block_2203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2203_0: const #0u : u8
        let s_2203_0: bool = false;
        // D s_2203_1: write-var gs#118527 <= s_2203_0
        fn_state.gs_118527 = s_2203_0;
        // N s_2203_2: jump b2204
        return block_2204(state, tracer, fn_state);
    }
    fn block_2204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2204_0: read-var gs#118527:u8
        let s_2204_0: bool = fn_state.gs_118527;
        // N s_2204_1: branch s_2204_0 b4446 b2205
        if s_2204_0 {
            return block_4446(state, tracer, fn_state);
        } else {
            return block_2205(state, tracer, fn_state);
        };
    }
    fn block_2205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2205_0: read-var CRm:u8
        let s_2205_0: u8 = fn_state.CRm;
        // D s_2205_1: cast zx s_2205_0 -> bv
        let s_2205_1: Bits = Bits::new(s_2205_0 as u128, 4u16);
        // C s_2205_2: const #13u : u8
        let s_2205_2: u8 = 13;
        // C s_2205_3: cast zx s_2205_2 -> bv
        let s_2205_3: Bits = Bits::new(s_2205_2 as u128, 4u16);
        // D s_2205_4: cmp-eq s_2205_1 s_2205_3
        let s_2205_4: bool = ((s_2205_1) == (s_2205_3));
        // N s_2205_5: branch s_2205_4 b4445 b2206
        if s_2205_4 {
            return block_4445(state, tracer, fn_state);
        } else {
            return block_2206(state, tracer, fn_state);
        };
    }
    fn block_2206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2206_0: const #0u : u8
        let s_2206_0: bool = false;
        // D s_2206_1: write-var gs#118528 <= s_2206_0
        fn_state.gs_118528 = s_2206_0;
        // N s_2206_2: jump b2207
        return block_2207(state, tracer, fn_state);
    }
    fn block_2207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2207_0: read-var gs#118528:u8
        let s_2207_0: bool = fn_state.gs_118528;
        // N s_2207_1: branch s_2207_0 b4444 b2208
        if s_2207_0 {
            return block_4444(state, tracer, fn_state);
        } else {
            return block_2208(state, tracer, fn_state);
        };
    }
    fn block_2208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2208_0: const #0u : u8
        let s_2208_0: bool = false;
        // D s_2208_1: write-var gs#118529 <= s_2208_0
        fn_state.gs_118529 = s_2208_0;
        // N s_2208_2: jump b2209
        return block_2209(state, tracer, fn_state);
    }
    fn block_2209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2209_0: read-var gs#118529:u8
        let s_2209_0: bool = fn_state.gs_118529;
        // N s_2209_1: branch s_2209_0 b4443 b2210
        if s_2209_0 {
            return block_4443(state, tracer, fn_state);
        } else {
            return block_2210(state, tracer, fn_state);
        };
    }
    fn block_2210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2210_0: const #0u : u8
        let s_2210_0: bool = false;
        // D s_2210_1: write-var gs#118530 <= s_2210_0
        fn_state.gs_118530 = s_2210_0;
        // N s_2210_2: jump b2211
        return block_2211(state, tracer, fn_state);
    }
    fn block_2211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2211_0: read-var gs#118530:u8
        let s_2211_0: bool = fn_state.gs_118530;
        // N s_2211_1: branch s_2211_0 b4442 b2212
        if s_2211_0 {
            return block_4442(state, tracer, fn_state);
        } else {
            return block_2212(state, tracer, fn_state);
        };
    }
    fn block_2212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2212_0: const #0u : u8
        let s_2212_0: bool = false;
        // D s_2212_1: write-var gs#118531 <= s_2212_0
        fn_state.gs_118531 = s_2212_0;
        // N s_2212_2: jump b2213
        return block_2213(state, tracer, fn_state);
    }
    fn block_2213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2213_0: read-var gs#118531:u8
        let s_2213_0: bool = fn_state.gs_118531;
        // N s_2213_1: branch s_2213_0 b4441 b2214
        if s_2213_0 {
            return block_4441(state, tracer, fn_state);
        } else {
            return block_2214(state, tracer, fn_state);
        };
    }
    fn block_2214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2214_0: read-var CRm:u8
        let s_2214_0: u8 = fn_state.CRm;
        // D s_2214_1: cast zx s_2214_0 -> bv
        let s_2214_1: Bits = Bits::new(s_2214_0 as u128, 4u16);
        // C s_2214_2: const #12u : u8
        let s_2214_2: u8 = 12;
        // C s_2214_3: cast zx s_2214_2 -> bv
        let s_2214_3: Bits = Bits::new(s_2214_2 as u128, 4u16);
        // D s_2214_4: cmp-eq s_2214_1 s_2214_3
        let s_2214_4: bool = ((s_2214_1) == (s_2214_3));
        // N s_2214_5: branch s_2214_4 b4440 b2215
        if s_2214_4 {
            return block_4440(state, tracer, fn_state);
        } else {
            return block_2215(state, tracer, fn_state);
        };
    }
    fn block_2215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2215_0: const #0u : u8
        let s_2215_0: bool = false;
        // D s_2215_1: write-var gs#118532 <= s_2215_0
        fn_state.gs_118532 = s_2215_0;
        // N s_2215_2: jump b2216
        return block_2216(state, tracer, fn_state);
    }
    fn block_2216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2216_0: read-var gs#118532:u8
        let s_2216_0: bool = fn_state.gs_118532;
        // N s_2216_1: branch s_2216_0 b4439 b2217
        if s_2216_0 {
            return block_4439(state, tracer, fn_state);
        } else {
            return block_2217(state, tracer, fn_state);
        };
    }
    fn block_2217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2217_0: const #0u : u8
        let s_2217_0: bool = false;
        // D s_2217_1: write-var gs#118533 <= s_2217_0
        fn_state.gs_118533 = s_2217_0;
        // N s_2217_2: jump b2218
        return block_2218(state, tracer, fn_state);
    }
    fn block_2218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2218_0: read-var gs#118533:u8
        let s_2218_0: bool = fn_state.gs_118533;
        // N s_2218_1: branch s_2218_0 b4438 b2219
        if s_2218_0 {
            return block_4438(state, tracer, fn_state);
        } else {
            return block_2219(state, tracer, fn_state);
        };
    }
    fn block_2219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2219_0: const #0u : u8
        let s_2219_0: bool = false;
        // D s_2219_1: write-var gs#118534 <= s_2219_0
        fn_state.gs_118534 = s_2219_0;
        // N s_2219_2: jump b2220
        return block_2220(state, tracer, fn_state);
    }
    fn block_2220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2220_0: read-var gs#118534:u8
        let s_2220_0: bool = fn_state.gs_118534;
        // N s_2220_1: branch s_2220_0 b4437 b2221
        if s_2220_0 {
            return block_4437(state, tracer, fn_state);
        } else {
            return block_2221(state, tracer, fn_state);
        };
    }
    fn block_2221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2221_0: const #0u : u8
        let s_2221_0: bool = false;
        // D s_2221_1: write-var gs#118535 <= s_2221_0
        fn_state.gs_118535 = s_2221_0;
        // N s_2221_2: jump b2222
        return block_2222(state, tracer, fn_state);
    }
    fn block_2222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2222_0: read-var gs#118535:u8
        let s_2222_0: bool = fn_state.gs_118535;
        // N s_2222_1: branch s_2222_0 b4436 b2223
        if s_2222_0 {
            return block_4436(state, tracer, fn_state);
        } else {
            return block_2223(state, tracer, fn_state);
        };
    }
    fn block_2223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2223_0: read-var CRm:u8
        let s_2223_0: u8 = fn_state.CRm;
        // D s_2223_1: cast zx s_2223_0 -> bv
        let s_2223_1: Bits = Bits::new(s_2223_0 as u128, 4u16);
        // C s_2223_2: const #11u : u8
        let s_2223_2: u8 = 11;
        // C s_2223_3: cast zx s_2223_2 -> bv
        let s_2223_3: Bits = Bits::new(s_2223_2 as u128, 4u16);
        // D s_2223_4: cmp-eq s_2223_1 s_2223_3
        let s_2223_4: bool = ((s_2223_1) == (s_2223_3));
        // N s_2223_5: branch s_2223_4 b4435 b2224
        if s_2223_4 {
            return block_4435(state, tracer, fn_state);
        } else {
            return block_2224(state, tracer, fn_state);
        };
    }
    fn block_2224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2224_0: const #0u : u8
        let s_2224_0: bool = false;
        // D s_2224_1: write-var gs#118536 <= s_2224_0
        fn_state.gs_118536 = s_2224_0;
        // N s_2224_2: jump b2225
        return block_2225(state, tracer, fn_state);
    }
    fn block_2225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2225_0: read-var gs#118536:u8
        let s_2225_0: bool = fn_state.gs_118536;
        // N s_2225_1: branch s_2225_0 b4434 b2226
        if s_2225_0 {
            return block_4434(state, tracer, fn_state);
        } else {
            return block_2226(state, tracer, fn_state);
        };
    }
    fn block_2226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2226_0: const #0u : u8
        let s_2226_0: bool = false;
        // D s_2226_1: write-var gs#118537 <= s_2226_0
        fn_state.gs_118537 = s_2226_0;
        // N s_2226_2: jump b2227
        return block_2227(state, tracer, fn_state);
    }
    fn block_2227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2227_0: read-var gs#118537:u8
        let s_2227_0: bool = fn_state.gs_118537;
        // N s_2227_1: branch s_2227_0 b4433 b2228
        if s_2227_0 {
            return block_4433(state, tracer, fn_state);
        } else {
            return block_2228(state, tracer, fn_state);
        };
    }
    fn block_2228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2228_0: const #0u : u8
        let s_2228_0: bool = false;
        // D s_2228_1: write-var gs#118538 <= s_2228_0
        fn_state.gs_118538 = s_2228_0;
        // N s_2228_2: jump b2229
        return block_2229(state, tracer, fn_state);
    }
    fn block_2229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2229_0: read-var gs#118538:u8
        let s_2229_0: bool = fn_state.gs_118538;
        // N s_2229_1: branch s_2229_0 b4432 b2230
        if s_2229_0 {
            return block_4432(state, tracer, fn_state);
        } else {
            return block_2230(state, tracer, fn_state);
        };
    }
    fn block_2230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2230_0: const #0u : u8
        let s_2230_0: bool = false;
        // D s_2230_1: write-var gs#118539 <= s_2230_0
        fn_state.gs_118539 = s_2230_0;
        // N s_2230_2: jump b2231
        return block_2231(state, tracer, fn_state);
    }
    fn block_2231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2231_0: read-var gs#118539:u8
        let s_2231_0: bool = fn_state.gs_118539;
        // N s_2231_1: branch s_2231_0 b4431 b2232
        if s_2231_0 {
            return block_4431(state, tracer, fn_state);
        } else {
            return block_2232(state, tracer, fn_state);
        };
    }
    fn block_2232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2232_0: read-var CRm:u8
        let s_2232_0: u8 = fn_state.CRm;
        // D s_2232_1: cast zx s_2232_0 -> bv
        let s_2232_1: Bits = Bits::new(s_2232_0 as u128, 4u16);
        // C s_2232_2: const #10u : u8
        let s_2232_2: u8 = 10;
        // C s_2232_3: cast zx s_2232_2 -> bv
        let s_2232_3: Bits = Bits::new(s_2232_2 as u128, 4u16);
        // D s_2232_4: cmp-eq s_2232_1 s_2232_3
        let s_2232_4: bool = ((s_2232_1) == (s_2232_3));
        // N s_2232_5: branch s_2232_4 b4430 b2233
        if s_2232_4 {
            return block_4430(state, tracer, fn_state);
        } else {
            return block_2233(state, tracer, fn_state);
        };
    }
    fn block_2233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2233_0: const #0u : u8
        let s_2233_0: bool = false;
        // D s_2233_1: write-var gs#118540 <= s_2233_0
        fn_state.gs_118540 = s_2233_0;
        // N s_2233_2: jump b2234
        return block_2234(state, tracer, fn_state);
    }
    fn block_2234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2234_0: read-var gs#118540:u8
        let s_2234_0: bool = fn_state.gs_118540;
        // N s_2234_1: branch s_2234_0 b4429 b2235
        if s_2234_0 {
            return block_4429(state, tracer, fn_state);
        } else {
            return block_2235(state, tracer, fn_state);
        };
    }
    fn block_2235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2235_0: const #0u : u8
        let s_2235_0: bool = false;
        // D s_2235_1: write-var gs#118541 <= s_2235_0
        fn_state.gs_118541 = s_2235_0;
        // N s_2235_2: jump b2236
        return block_2236(state, tracer, fn_state);
    }
    fn block_2236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2236_0: read-var gs#118541:u8
        let s_2236_0: bool = fn_state.gs_118541;
        // N s_2236_1: branch s_2236_0 b4428 b2237
        if s_2236_0 {
            return block_4428(state, tracer, fn_state);
        } else {
            return block_2237(state, tracer, fn_state);
        };
    }
    fn block_2237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2237_0: const #0u : u8
        let s_2237_0: bool = false;
        // D s_2237_1: write-var gs#118542 <= s_2237_0
        fn_state.gs_118542 = s_2237_0;
        // N s_2237_2: jump b2238
        return block_2238(state, tracer, fn_state);
    }
    fn block_2238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2238_0: read-var gs#118542:u8
        let s_2238_0: bool = fn_state.gs_118542;
        // N s_2238_1: branch s_2238_0 b4427 b2239
        if s_2238_0 {
            return block_4427(state, tracer, fn_state);
        } else {
            return block_2239(state, tracer, fn_state);
        };
    }
    fn block_2239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2239_0: const #0u : u8
        let s_2239_0: bool = false;
        // D s_2239_1: write-var gs#118543 <= s_2239_0
        fn_state.gs_118543 = s_2239_0;
        // N s_2239_2: jump b2240
        return block_2240(state, tracer, fn_state);
    }
    fn block_2240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2240_0: read-var gs#118543:u8
        let s_2240_0: bool = fn_state.gs_118543;
        // N s_2240_1: branch s_2240_0 b4426 b2241
        if s_2240_0 {
            return block_4426(state, tracer, fn_state);
        } else {
            return block_2241(state, tracer, fn_state);
        };
    }
    fn block_2241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2241_0: read-var CRm:u8
        let s_2241_0: u8 = fn_state.CRm;
        // D s_2241_1: cast zx s_2241_0 -> bv
        let s_2241_1: Bits = Bits::new(s_2241_0 as u128, 4u16);
        // C s_2241_2: const #9u : u8
        let s_2241_2: u8 = 9;
        // C s_2241_3: cast zx s_2241_2 -> bv
        let s_2241_3: Bits = Bits::new(s_2241_2 as u128, 4u16);
        // D s_2241_4: cmp-eq s_2241_1 s_2241_3
        let s_2241_4: bool = ((s_2241_1) == (s_2241_3));
        // N s_2241_5: branch s_2241_4 b4425 b2242
        if s_2241_4 {
            return block_4425(state, tracer, fn_state);
        } else {
            return block_2242(state, tracer, fn_state);
        };
    }
    fn block_2242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2242_0: const #0u : u8
        let s_2242_0: bool = false;
        // D s_2242_1: write-var gs#118544 <= s_2242_0
        fn_state.gs_118544 = s_2242_0;
        // N s_2242_2: jump b2243
        return block_2243(state, tracer, fn_state);
    }
    fn block_2243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2243_0: read-var gs#118544:u8
        let s_2243_0: bool = fn_state.gs_118544;
        // N s_2243_1: branch s_2243_0 b4424 b2244
        if s_2243_0 {
            return block_4424(state, tracer, fn_state);
        } else {
            return block_2244(state, tracer, fn_state);
        };
    }
    fn block_2244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2244_0: const #0u : u8
        let s_2244_0: bool = false;
        // D s_2244_1: write-var gs#118545 <= s_2244_0
        fn_state.gs_118545 = s_2244_0;
        // N s_2244_2: jump b2245
        return block_2245(state, tracer, fn_state);
    }
    fn block_2245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2245_0: read-var gs#118545:u8
        let s_2245_0: bool = fn_state.gs_118545;
        // N s_2245_1: branch s_2245_0 b4423 b2246
        if s_2245_0 {
            return block_4423(state, tracer, fn_state);
        } else {
            return block_2246(state, tracer, fn_state);
        };
    }
    fn block_2246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2246_0: const #0u : u8
        let s_2246_0: bool = false;
        // D s_2246_1: write-var gs#118546 <= s_2246_0
        fn_state.gs_118546 = s_2246_0;
        // N s_2246_2: jump b2247
        return block_2247(state, tracer, fn_state);
    }
    fn block_2247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2247_0: read-var gs#118546:u8
        let s_2247_0: bool = fn_state.gs_118546;
        // N s_2247_1: branch s_2247_0 b4422 b2248
        if s_2247_0 {
            return block_4422(state, tracer, fn_state);
        } else {
            return block_2248(state, tracer, fn_state);
        };
    }
    fn block_2248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2248_0: const #0u : u8
        let s_2248_0: bool = false;
        // D s_2248_1: write-var gs#118547 <= s_2248_0
        fn_state.gs_118547 = s_2248_0;
        // N s_2248_2: jump b2249
        return block_2249(state, tracer, fn_state);
    }
    fn block_2249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2249_0: read-var gs#118547:u8
        let s_2249_0: bool = fn_state.gs_118547;
        // N s_2249_1: branch s_2249_0 b4421 b2250
        if s_2249_0 {
            return block_4421(state, tracer, fn_state);
        } else {
            return block_2250(state, tracer, fn_state);
        };
    }
    fn block_2250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2250_0: read-var CRm:u8
        let s_2250_0: u8 = fn_state.CRm;
        // D s_2250_1: cast zx s_2250_0 -> bv
        let s_2250_1: Bits = Bits::new(s_2250_0 as u128, 4u16);
        // C s_2250_2: const #8u : u8
        let s_2250_2: u8 = 8;
        // C s_2250_3: cast zx s_2250_2 -> bv
        let s_2250_3: Bits = Bits::new(s_2250_2 as u128, 4u16);
        // D s_2250_4: cmp-eq s_2250_1 s_2250_3
        let s_2250_4: bool = ((s_2250_1) == (s_2250_3));
        // N s_2250_5: branch s_2250_4 b4420 b2251
        if s_2250_4 {
            return block_4420(state, tracer, fn_state);
        } else {
            return block_2251(state, tracer, fn_state);
        };
    }
    fn block_2251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2251_0: const #0u : u8
        let s_2251_0: bool = false;
        // D s_2251_1: write-var gs#118548 <= s_2251_0
        fn_state.gs_118548 = s_2251_0;
        // N s_2251_2: jump b2252
        return block_2252(state, tracer, fn_state);
    }
    fn block_2252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2252_0: read-var gs#118548:u8
        let s_2252_0: bool = fn_state.gs_118548;
        // N s_2252_1: branch s_2252_0 b4419 b2253
        if s_2252_0 {
            return block_4419(state, tracer, fn_state);
        } else {
            return block_2253(state, tracer, fn_state);
        };
    }
    fn block_2253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2253_0: const #0u : u8
        let s_2253_0: bool = false;
        // D s_2253_1: write-var gs#118549 <= s_2253_0
        fn_state.gs_118549 = s_2253_0;
        // N s_2253_2: jump b2254
        return block_2254(state, tracer, fn_state);
    }
    fn block_2254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2254_0: read-var gs#118549:u8
        let s_2254_0: bool = fn_state.gs_118549;
        // N s_2254_1: branch s_2254_0 b4418 b2255
        if s_2254_0 {
            return block_4418(state, tracer, fn_state);
        } else {
            return block_2255(state, tracer, fn_state);
        };
    }
    fn block_2255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2255_0: const #0u : u8
        let s_2255_0: bool = false;
        // D s_2255_1: write-var gs#118550 <= s_2255_0
        fn_state.gs_118550 = s_2255_0;
        // N s_2255_2: jump b2256
        return block_2256(state, tracer, fn_state);
    }
    fn block_2256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2256_0: read-var gs#118550:u8
        let s_2256_0: bool = fn_state.gs_118550;
        // N s_2256_1: branch s_2256_0 b4417 b2257
        if s_2256_0 {
            return block_4417(state, tracer, fn_state);
        } else {
            return block_2257(state, tracer, fn_state);
        };
    }
    fn block_2257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2257_0: const #0u : u8
        let s_2257_0: bool = false;
        // D s_2257_1: write-var gs#118551 <= s_2257_0
        fn_state.gs_118551 = s_2257_0;
        // N s_2257_2: jump b2258
        return block_2258(state, tracer, fn_state);
    }
    fn block_2258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2258_0: read-var gs#118551:u8
        let s_2258_0: bool = fn_state.gs_118551;
        // N s_2258_1: branch s_2258_0 b4416 b2259
        if s_2258_0 {
            return block_4416(state, tracer, fn_state);
        } else {
            return block_2259(state, tracer, fn_state);
        };
    }
    fn block_2259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2259_0: read-var CRm:u8
        let s_2259_0: u8 = fn_state.CRm;
        // D s_2259_1: cast zx s_2259_0 -> bv
        let s_2259_1: Bits = Bits::new(s_2259_0 as u128, 4u16);
        // C s_2259_2: const #7u : u8
        let s_2259_2: u8 = 7;
        // C s_2259_3: cast zx s_2259_2 -> bv
        let s_2259_3: Bits = Bits::new(s_2259_2 as u128, 4u16);
        // D s_2259_4: cmp-eq s_2259_1 s_2259_3
        let s_2259_4: bool = ((s_2259_1) == (s_2259_3));
        // N s_2259_5: branch s_2259_4 b4415 b2260
        if s_2259_4 {
            return block_4415(state, tracer, fn_state);
        } else {
            return block_2260(state, tracer, fn_state);
        };
    }
    fn block_2260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2260_0: const #0u : u8
        let s_2260_0: bool = false;
        // D s_2260_1: write-var gs#118552 <= s_2260_0
        fn_state.gs_118552 = s_2260_0;
        // N s_2260_2: jump b2261
        return block_2261(state, tracer, fn_state);
    }
    fn block_2261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2261_0: read-var gs#118552:u8
        let s_2261_0: bool = fn_state.gs_118552;
        // N s_2261_1: branch s_2261_0 b4414 b2262
        if s_2261_0 {
            return block_4414(state, tracer, fn_state);
        } else {
            return block_2262(state, tracer, fn_state);
        };
    }
    fn block_2262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2262_0: const #0u : u8
        let s_2262_0: bool = false;
        // D s_2262_1: write-var gs#118553 <= s_2262_0
        fn_state.gs_118553 = s_2262_0;
        // N s_2262_2: jump b2263
        return block_2263(state, tracer, fn_state);
    }
    fn block_2263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2263_0: read-var gs#118553:u8
        let s_2263_0: bool = fn_state.gs_118553;
        // N s_2263_1: branch s_2263_0 b4413 b2264
        if s_2263_0 {
            return block_4413(state, tracer, fn_state);
        } else {
            return block_2264(state, tracer, fn_state);
        };
    }
    fn block_2264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2264_0: const #0u : u8
        let s_2264_0: bool = false;
        // D s_2264_1: write-var gs#118554 <= s_2264_0
        fn_state.gs_118554 = s_2264_0;
        // N s_2264_2: jump b2265
        return block_2265(state, tracer, fn_state);
    }
    fn block_2265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2265_0: read-var gs#118554:u8
        let s_2265_0: bool = fn_state.gs_118554;
        // N s_2265_1: branch s_2265_0 b4412 b2266
        if s_2265_0 {
            return block_4412(state, tracer, fn_state);
        } else {
            return block_2266(state, tracer, fn_state);
        };
    }
    fn block_2266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2266_0: const #0u : u8
        let s_2266_0: bool = false;
        // D s_2266_1: write-var gs#118555 <= s_2266_0
        fn_state.gs_118555 = s_2266_0;
        // N s_2266_2: jump b2267
        return block_2267(state, tracer, fn_state);
    }
    fn block_2267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2267_0: read-var gs#118555:u8
        let s_2267_0: bool = fn_state.gs_118555;
        // N s_2267_1: branch s_2267_0 b4411 b2268
        if s_2267_0 {
            return block_4411(state, tracer, fn_state);
        } else {
            return block_2268(state, tracer, fn_state);
        };
    }
    fn block_2268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2268_0: read-var CRm:u8
        let s_2268_0: u8 = fn_state.CRm;
        // D s_2268_1: cast zx s_2268_0 -> bv
        let s_2268_1: Bits = Bits::new(s_2268_0 as u128, 4u16);
        // C s_2268_2: const #6u : u8
        let s_2268_2: u8 = 6;
        // C s_2268_3: cast zx s_2268_2 -> bv
        let s_2268_3: Bits = Bits::new(s_2268_2 as u128, 4u16);
        // D s_2268_4: cmp-eq s_2268_1 s_2268_3
        let s_2268_4: bool = ((s_2268_1) == (s_2268_3));
        // N s_2268_5: branch s_2268_4 b4410 b2269
        if s_2268_4 {
            return block_4410(state, tracer, fn_state);
        } else {
            return block_2269(state, tracer, fn_state);
        };
    }
    fn block_2269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2269_0: const #0u : u8
        let s_2269_0: bool = false;
        // D s_2269_1: write-var gs#118556 <= s_2269_0
        fn_state.gs_118556 = s_2269_0;
        // N s_2269_2: jump b2270
        return block_2270(state, tracer, fn_state);
    }
    fn block_2270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2270_0: read-var gs#118556:u8
        let s_2270_0: bool = fn_state.gs_118556;
        // N s_2270_1: branch s_2270_0 b4409 b2271
        if s_2270_0 {
            return block_4409(state, tracer, fn_state);
        } else {
            return block_2271(state, tracer, fn_state);
        };
    }
    fn block_2271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2271_0: const #0u : u8
        let s_2271_0: bool = false;
        // D s_2271_1: write-var gs#118557 <= s_2271_0
        fn_state.gs_118557 = s_2271_0;
        // N s_2271_2: jump b2272
        return block_2272(state, tracer, fn_state);
    }
    fn block_2272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2272_0: read-var gs#118557:u8
        let s_2272_0: bool = fn_state.gs_118557;
        // N s_2272_1: branch s_2272_0 b4408 b2273
        if s_2272_0 {
            return block_4408(state, tracer, fn_state);
        } else {
            return block_2273(state, tracer, fn_state);
        };
    }
    fn block_2273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2273_0: const #0u : u8
        let s_2273_0: bool = false;
        // D s_2273_1: write-var gs#118558 <= s_2273_0
        fn_state.gs_118558 = s_2273_0;
        // N s_2273_2: jump b2274
        return block_2274(state, tracer, fn_state);
    }
    fn block_2274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2274_0: read-var gs#118558:u8
        let s_2274_0: bool = fn_state.gs_118558;
        // N s_2274_1: branch s_2274_0 b4407 b2275
        if s_2274_0 {
            return block_4407(state, tracer, fn_state);
        } else {
            return block_2275(state, tracer, fn_state);
        };
    }
    fn block_2275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2275_0: const #0u : u8
        let s_2275_0: bool = false;
        // D s_2275_1: write-var gs#118559 <= s_2275_0
        fn_state.gs_118559 = s_2275_0;
        // N s_2275_2: jump b2276
        return block_2276(state, tracer, fn_state);
    }
    fn block_2276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2276_0: read-var gs#118559:u8
        let s_2276_0: bool = fn_state.gs_118559;
        // N s_2276_1: branch s_2276_0 b4406 b2277
        if s_2276_0 {
            return block_4406(state, tracer, fn_state);
        } else {
            return block_2277(state, tracer, fn_state);
        };
    }
    fn block_2277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2277_0: read-var CRm:u8
        let s_2277_0: u8 = fn_state.CRm;
        // D s_2277_1: cast zx s_2277_0 -> bv
        let s_2277_1: Bits = Bits::new(s_2277_0 as u128, 4u16);
        // C s_2277_2: const #5u : u8
        let s_2277_2: u8 = 5;
        // C s_2277_3: cast zx s_2277_2 -> bv
        let s_2277_3: Bits = Bits::new(s_2277_2 as u128, 4u16);
        // D s_2277_4: cmp-eq s_2277_1 s_2277_3
        let s_2277_4: bool = ((s_2277_1) == (s_2277_3));
        // N s_2277_5: branch s_2277_4 b4405 b2278
        if s_2277_4 {
            return block_4405(state, tracer, fn_state);
        } else {
            return block_2278(state, tracer, fn_state);
        };
    }
    fn block_2278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2278_0: const #0u : u8
        let s_2278_0: bool = false;
        // D s_2278_1: write-var gs#118560 <= s_2278_0
        fn_state.gs_118560 = s_2278_0;
        // N s_2278_2: jump b2279
        return block_2279(state, tracer, fn_state);
    }
    fn block_2279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2279_0: read-var gs#118560:u8
        let s_2279_0: bool = fn_state.gs_118560;
        // N s_2279_1: branch s_2279_0 b4404 b2280
        if s_2279_0 {
            return block_4404(state, tracer, fn_state);
        } else {
            return block_2280(state, tracer, fn_state);
        };
    }
    fn block_2280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2280_0: const #0u : u8
        let s_2280_0: bool = false;
        // D s_2280_1: write-var gs#118561 <= s_2280_0
        fn_state.gs_118561 = s_2280_0;
        // N s_2280_2: jump b2281
        return block_2281(state, tracer, fn_state);
    }
    fn block_2281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2281_0: read-var gs#118561:u8
        let s_2281_0: bool = fn_state.gs_118561;
        // N s_2281_1: branch s_2281_0 b4403 b2282
        if s_2281_0 {
            return block_4403(state, tracer, fn_state);
        } else {
            return block_2282(state, tracer, fn_state);
        };
    }
    fn block_2282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2282_0: const #0u : u8
        let s_2282_0: bool = false;
        // D s_2282_1: write-var gs#118562 <= s_2282_0
        fn_state.gs_118562 = s_2282_0;
        // N s_2282_2: jump b2283
        return block_2283(state, tracer, fn_state);
    }
    fn block_2283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2283_0: read-var gs#118562:u8
        let s_2283_0: bool = fn_state.gs_118562;
        // N s_2283_1: branch s_2283_0 b4402 b2284
        if s_2283_0 {
            return block_4402(state, tracer, fn_state);
        } else {
            return block_2284(state, tracer, fn_state);
        };
    }
    fn block_2284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2284_0: const #0u : u8
        let s_2284_0: bool = false;
        // D s_2284_1: write-var gs#118563 <= s_2284_0
        fn_state.gs_118563 = s_2284_0;
        // N s_2284_2: jump b2285
        return block_2285(state, tracer, fn_state);
    }
    fn block_2285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2285_0: read-var gs#118563:u8
        let s_2285_0: bool = fn_state.gs_118563;
        // N s_2285_1: branch s_2285_0 b4401 b2286
        if s_2285_0 {
            return block_4401(state, tracer, fn_state);
        } else {
            return block_2286(state, tracer, fn_state);
        };
    }
    fn block_2286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2286_0: read-var CRm:u8
        let s_2286_0: u8 = fn_state.CRm;
        // D s_2286_1: cast zx s_2286_0 -> bv
        let s_2286_1: Bits = Bits::new(s_2286_0 as u128, 4u16);
        // C s_2286_2: const #4u : u8
        let s_2286_2: u8 = 4;
        // C s_2286_3: cast zx s_2286_2 -> bv
        let s_2286_3: Bits = Bits::new(s_2286_2 as u128, 4u16);
        // D s_2286_4: cmp-eq s_2286_1 s_2286_3
        let s_2286_4: bool = ((s_2286_1) == (s_2286_3));
        // N s_2286_5: branch s_2286_4 b4400 b2287
        if s_2286_4 {
            return block_4400(state, tracer, fn_state);
        } else {
            return block_2287(state, tracer, fn_state);
        };
    }
    fn block_2287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2287_0: const #0u : u8
        let s_2287_0: bool = false;
        // D s_2287_1: write-var gs#118564 <= s_2287_0
        fn_state.gs_118564 = s_2287_0;
        // N s_2287_2: jump b2288
        return block_2288(state, tracer, fn_state);
    }
    fn block_2288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2288_0: read-var gs#118564:u8
        let s_2288_0: bool = fn_state.gs_118564;
        // N s_2288_1: branch s_2288_0 b4399 b2289
        if s_2288_0 {
            return block_4399(state, tracer, fn_state);
        } else {
            return block_2289(state, tracer, fn_state);
        };
    }
    fn block_2289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2289_0: const #0u : u8
        let s_2289_0: bool = false;
        // D s_2289_1: write-var gs#118565 <= s_2289_0
        fn_state.gs_118565 = s_2289_0;
        // N s_2289_2: jump b2290
        return block_2290(state, tracer, fn_state);
    }
    fn block_2290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2290_0: read-var gs#118565:u8
        let s_2290_0: bool = fn_state.gs_118565;
        // N s_2290_1: branch s_2290_0 b4398 b2291
        if s_2290_0 {
            return block_4398(state, tracer, fn_state);
        } else {
            return block_2291(state, tracer, fn_state);
        };
    }
    fn block_2291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2291_0: const #0u : u8
        let s_2291_0: bool = false;
        // D s_2291_1: write-var gs#118566 <= s_2291_0
        fn_state.gs_118566 = s_2291_0;
        // N s_2291_2: jump b2292
        return block_2292(state, tracer, fn_state);
    }
    fn block_2292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2292_0: read-var gs#118566:u8
        let s_2292_0: bool = fn_state.gs_118566;
        // N s_2292_1: branch s_2292_0 b4397 b2293
        if s_2292_0 {
            return block_4397(state, tracer, fn_state);
        } else {
            return block_2293(state, tracer, fn_state);
        };
    }
    fn block_2293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2293_0: const #0u : u8
        let s_2293_0: bool = false;
        // D s_2293_1: write-var gs#118567 <= s_2293_0
        fn_state.gs_118567 = s_2293_0;
        // N s_2293_2: jump b2294
        return block_2294(state, tracer, fn_state);
    }
    fn block_2294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2294_0: read-var gs#118567:u8
        let s_2294_0: bool = fn_state.gs_118567;
        // N s_2294_1: branch s_2294_0 b4396 b2295
        if s_2294_0 {
            return block_4396(state, tracer, fn_state);
        } else {
            return block_2295(state, tracer, fn_state);
        };
    }
    fn block_2295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2295_0: read-var CRm:u8
        let s_2295_0: u8 = fn_state.CRm;
        // D s_2295_1: cast zx s_2295_0 -> bv
        let s_2295_1: Bits = Bits::new(s_2295_0 as u128, 4u16);
        // C s_2295_2: const #3u : u8
        let s_2295_2: u8 = 3;
        // C s_2295_3: cast zx s_2295_2 -> bv
        let s_2295_3: Bits = Bits::new(s_2295_2 as u128, 4u16);
        // D s_2295_4: cmp-eq s_2295_1 s_2295_3
        let s_2295_4: bool = ((s_2295_1) == (s_2295_3));
        // N s_2295_5: branch s_2295_4 b4395 b2296
        if s_2295_4 {
            return block_4395(state, tracer, fn_state);
        } else {
            return block_2296(state, tracer, fn_state);
        };
    }
    fn block_2296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2296_0: const #0u : u8
        let s_2296_0: bool = false;
        // D s_2296_1: write-var gs#118568 <= s_2296_0
        fn_state.gs_118568 = s_2296_0;
        // N s_2296_2: jump b2297
        return block_2297(state, tracer, fn_state);
    }
    fn block_2297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2297_0: read-var gs#118568:u8
        let s_2297_0: bool = fn_state.gs_118568;
        // N s_2297_1: branch s_2297_0 b4394 b2298
        if s_2297_0 {
            return block_4394(state, tracer, fn_state);
        } else {
            return block_2298(state, tracer, fn_state);
        };
    }
    fn block_2298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2298_0: const #0u : u8
        let s_2298_0: bool = false;
        // D s_2298_1: write-var gs#118569 <= s_2298_0
        fn_state.gs_118569 = s_2298_0;
        // N s_2298_2: jump b2299
        return block_2299(state, tracer, fn_state);
    }
    fn block_2299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2299_0: read-var gs#118569:u8
        let s_2299_0: bool = fn_state.gs_118569;
        // N s_2299_1: branch s_2299_0 b4393 b2300
        if s_2299_0 {
            return block_4393(state, tracer, fn_state);
        } else {
            return block_2300(state, tracer, fn_state);
        };
    }
    fn block_2300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2300_0: const #0u : u8
        let s_2300_0: bool = false;
        // D s_2300_1: write-var gs#118570 <= s_2300_0
        fn_state.gs_118570 = s_2300_0;
        // N s_2300_2: jump b2301
        return block_2301(state, tracer, fn_state);
    }
    fn block_2301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2301_0: read-var gs#118570:u8
        let s_2301_0: bool = fn_state.gs_118570;
        // N s_2301_1: branch s_2301_0 b4392 b2302
        if s_2301_0 {
            return block_4392(state, tracer, fn_state);
        } else {
            return block_2302(state, tracer, fn_state);
        };
    }
    fn block_2302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2302_0: const #0u : u8
        let s_2302_0: bool = false;
        // D s_2302_1: write-var gs#118571 <= s_2302_0
        fn_state.gs_118571 = s_2302_0;
        // N s_2302_2: jump b2303
        return block_2303(state, tracer, fn_state);
    }
    fn block_2303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2303_0: read-var gs#118571:u8
        let s_2303_0: bool = fn_state.gs_118571;
        // N s_2303_1: branch s_2303_0 b4391 b2304
        if s_2303_0 {
            return block_4391(state, tracer, fn_state);
        } else {
            return block_2304(state, tracer, fn_state);
        };
    }
    fn block_2304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2304_0: read-var CRm:u8
        let s_2304_0: u8 = fn_state.CRm;
        // D s_2304_1: cast zx s_2304_0 -> bv
        let s_2304_1: Bits = Bits::new(s_2304_0 as u128, 4u16);
        // C s_2304_2: const #2u : u8
        let s_2304_2: u8 = 2;
        // C s_2304_3: cast zx s_2304_2 -> bv
        let s_2304_3: Bits = Bits::new(s_2304_2 as u128, 4u16);
        // D s_2304_4: cmp-eq s_2304_1 s_2304_3
        let s_2304_4: bool = ((s_2304_1) == (s_2304_3));
        // N s_2304_5: branch s_2304_4 b4390 b2305
        if s_2304_4 {
            return block_4390(state, tracer, fn_state);
        } else {
            return block_2305(state, tracer, fn_state);
        };
    }
    fn block_2305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2305_0: const #0u : u8
        let s_2305_0: bool = false;
        // D s_2305_1: write-var gs#118572 <= s_2305_0
        fn_state.gs_118572 = s_2305_0;
        // N s_2305_2: jump b2306
        return block_2306(state, tracer, fn_state);
    }
    fn block_2306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2306_0: read-var gs#118572:u8
        let s_2306_0: bool = fn_state.gs_118572;
        // N s_2306_1: branch s_2306_0 b4389 b2307
        if s_2306_0 {
            return block_4389(state, tracer, fn_state);
        } else {
            return block_2307(state, tracer, fn_state);
        };
    }
    fn block_2307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2307_0: const #0u : u8
        let s_2307_0: bool = false;
        // D s_2307_1: write-var gs#118573 <= s_2307_0
        fn_state.gs_118573 = s_2307_0;
        // N s_2307_2: jump b2308
        return block_2308(state, tracer, fn_state);
    }
    fn block_2308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2308_0: read-var gs#118573:u8
        let s_2308_0: bool = fn_state.gs_118573;
        // N s_2308_1: branch s_2308_0 b4388 b2309
        if s_2308_0 {
            return block_4388(state, tracer, fn_state);
        } else {
            return block_2309(state, tracer, fn_state);
        };
    }
    fn block_2309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2309_0: const #0u : u8
        let s_2309_0: bool = false;
        // D s_2309_1: write-var gs#118574 <= s_2309_0
        fn_state.gs_118574 = s_2309_0;
        // N s_2309_2: jump b2310
        return block_2310(state, tracer, fn_state);
    }
    fn block_2310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2310_0: read-var gs#118574:u8
        let s_2310_0: bool = fn_state.gs_118574;
        // N s_2310_1: branch s_2310_0 b4387 b2311
        if s_2310_0 {
            return block_4387(state, tracer, fn_state);
        } else {
            return block_2311(state, tracer, fn_state);
        };
    }
    fn block_2311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2311_0: const #0u : u8
        let s_2311_0: bool = false;
        // D s_2311_1: write-var gs#118575 <= s_2311_0
        fn_state.gs_118575 = s_2311_0;
        // N s_2311_2: jump b2312
        return block_2312(state, tracer, fn_state);
    }
    fn block_2312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2312_0: read-var gs#118575:u8
        let s_2312_0: bool = fn_state.gs_118575;
        // N s_2312_1: branch s_2312_0 b4386 b2313
        if s_2312_0 {
            return block_4386(state, tracer, fn_state);
        } else {
            return block_2313(state, tracer, fn_state);
        };
    }
    fn block_2313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2313_0: read-var CRm:u8
        let s_2313_0: u8 = fn_state.CRm;
        // D s_2313_1: cast zx s_2313_0 -> bv
        let s_2313_1: Bits = Bits::new(s_2313_0 as u128, 4u16);
        // C s_2313_2: const #1u : u8
        let s_2313_2: u8 = 1;
        // C s_2313_3: cast zx s_2313_2 -> bv
        let s_2313_3: Bits = Bits::new(s_2313_2 as u128, 4u16);
        // D s_2313_4: cmp-eq s_2313_1 s_2313_3
        let s_2313_4: bool = ((s_2313_1) == (s_2313_3));
        // N s_2313_5: branch s_2313_4 b4385 b2314
        if s_2313_4 {
            return block_4385(state, tracer, fn_state);
        } else {
            return block_2314(state, tracer, fn_state);
        };
    }
    fn block_2314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2314_0: const #0u : u8
        let s_2314_0: bool = false;
        // D s_2314_1: write-var gs#118576 <= s_2314_0
        fn_state.gs_118576 = s_2314_0;
        // N s_2314_2: jump b2315
        return block_2315(state, tracer, fn_state);
    }
    fn block_2315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2315_0: read-var gs#118576:u8
        let s_2315_0: bool = fn_state.gs_118576;
        // N s_2315_1: branch s_2315_0 b4384 b2316
        if s_2315_0 {
            return block_4384(state, tracer, fn_state);
        } else {
            return block_2316(state, tracer, fn_state);
        };
    }
    fn block_2316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2316_0: const #0u : u8
        let s_2316_0: bool = false;
        // D s_2316_1: write-var gs#118577 <= s_2316_0
        fn_state.gs_118577 = s_2316_0;
        // N s_2316_2: jump b2317
        return block_2317(state, tracer, fn_state);
    }
    fn block_2317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2317_0: read-var gs#118577:u8
        let s_2317_0: bool = fn_state.gs_118577;
        // N s_2317_1: branch s_2317_0 b4383 b2318
        if s_2317_0 {
            return block_4383(state, tracer, fn_state);
        } else {
            return block_2318(state, tracer, fn_state);
        };
    }
    fn block_2318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2318_0: const #0u : u8
        let s_2318_0: bool = false;
        // D s_2318_1: write-var gs#118578 <= s_2318_0
        fn_state.gs_118578 = s_2318_0;
        // N s_2318_2: jump b2319
        return block_2319(state, tracer, fn_state);
    }
    fn block_2319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2319_0: read-var gs#118578:u8
        let s_2319_0: bool = fn_state.gs_118578;
        // N s_2319_1: branch s_2319_0 b4382 b2320
        if s_2319_0 {
            return block_4382(state, tracer, fn_state);
        } else {
            return block_2320(state, tracer, fn_state);
        };
    }
    fn block_2320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2320_0: const #0u : u8
        let s_2320_0: bool = false;
        // D s_2320_1: write-var gs#118579 <= s_2320_0
        fn_state.gs_118579 = s_2320_0;
        // N s_2320_2: jump b2321
        return block_2321(state, tracer, fn_state);
    }
    fn block_2321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2321_0: read-var gs#118579:u8
        let s_2321_0: bool = fn_state.gs_118579;
        // N s_2321_1: branch s_2321_0 b4381 b2322
        if s_2321_0 {
            return block_4381(state, tracer, fn_state);
        } else {
            return block_2322(state, tracer, fn_state);
        };
    }
    fn block_2322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2322_0: read-var CRm:u8
        let s_2322_0: u8 = fn_state.CRm;
        // D s_2322_1: cast zx s_2322_0 -> bv
        let s_2322_1: Bits = Bits::new(s_2322_0 as u128, 4u16);
        // C s_2322_2: const #0u : u8
        let s_2322_2: u8 = 0;
        // C s_2322_3: cast zx s_2322_2 -> bv
        let s_2322_3: Bits = Bits::new(s_2322_2 as u128, 4u16);
        // D s_2322_4: cmp-eq s_2322_1 s_2322_3
        let s_2322_4: bool = ((s_2322_1) == (s_2322_3));
        // N s_2322_5: branch s_2322_4 b4380 b2323
        if s_2322_4 {
            return block_4380(state, tracer, fn_state);
        } else {
            return block_2323(state, tracer, fn_state);
        };
    }
    fn block_2323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2323_0: const #0u : u8
        let s_2323_0: bool = false;
        // D s_2323_1: write-var gs#118580 <= s_2323_0
        fn_state.gs_118580 = s_2323_0;
        // N s_2323_2: jump b2324
        return block_2324(state, tracer, fn_state);
    }
    fn block_2324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2324_0: read-var gs#118580:u8
        let s_2324_0: bool = fn_state.gs_118580;
        // N s_2324_1: branch s_2324_0 b4379 b2325
        if s_2324_0 {
            return block_4379(state, tracer, fn_state);
        } else {
            return block_2325(state, tracer, fn_state);
        };
    }
    fn block_2325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2325_0: const #0u : u8
        let s_2325_0: bool = false;
        // D s_2325_1: write-var gs#118581 <= s_2325_0
        fn_state.gs_118581 = s_2325_0;
        // N s_2325_2: jump b2326
        return block_2326(state, tracer, fn_state);
    }
    fn block_2326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2326_0: read-var gs#118581:u8
        let s_2326_0: bool = fn_state.gs_118581;
        // N s_2326_1: branch s_2326_0 b4378 b2327
        if s_2326_0 {
            return block_4378(state, tracer, fn_state);
        } else {
            return block_2327(state, tracer, fn_state);
        };
    }
    fn block_2327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2327_0: const #0u : u8
        let s_2327_0: bool = false;
        // D s_2327_1: write-var gs#118582 <= s_2327_0
        fn_state.gs_118582 = s_2327_0;
        // N s_2327_2: jump b2328
        return block_2328(state, tracer, fn_state);
    }
    fn block_2328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2328_0: read-var gs#118582:u8
        let s_2328_0: bool = fn_state.gs_118582;
        // N s_2328_1: branch s_2328_0 b4377 b2329
        if s_2328_0 {
            return block_4377(state, tracer, fn_state);
        } else {
            return block_2329(state, tracer, fn_state);
        };
    }
    fn block_2329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2329_0: const #0u : u8
        let s_2329_0: bool = false;
        // D s_2329_1: write-var gs#118583 <= s_2329_0
        fn_state.gs_118583 = s_2329_0;
        // N s_2329_2: jump b2330
        return block_2330(state, tracer, fn_state);
    }
    fn block_2330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2330_0: read-var gs#118583:u8
        let s_2330_0: bool = fn_state.gs_118583;
        // N s_2330_1: branch s_2330_0 b4376 b2331
        if s_2330_0 {
            return block_4376(state, tracer, fn_state);
        } else {
            return block_2331(state, tracer, fn_state);
        };
    }
    fn block_2331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2331_0: read-var CRm:u8
        let s_2331_0: u8 = fn_state.CRm;
        // D s_2331_1: cast zx s_2331_0 -> bv
        let s_2331_1: Bits = Bits::new(s_2331_0 as u128, 4u16);
        // C s_2331_2: const #6u : u8
        let s_2331_2: u8 = 6;
        // C s_2331_3: cast zx s_2331_2 -> bv
        let s_2331_3: Bits = Bits::new(s_2331_2 as u128, 4u16);
        // D s_2331_4: cmp-eq s_2331_1 s_2331_3
        let s_2331_4: bool = ((s_2331_1) == (s_2331_3));
        // N s_2331_5: branch s_2331_4 b4375 b2332
        if s_2331_4 {
            return block_4375(state, tracer, fn_state);
        } else {
            return block_2332(state, tracer, fn_state);
        };
    }
    fn block_2332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2332_0: const #0u : u8
        let s_2332_0: bool = false;
        // D s_2332_1: write-var gs#118584 <= s_2332_0
        fn_state.gs_118584 = s_2332_0;
        // N s_2332_2: jump b2333
        return block_2333(state, tracer, fn_state);
    }
    fn block_2333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2333_0: read-var gs#118584:u8
        let s_2333_0: bool = fn_state.gs_118584;
        // N s_2333_1: branch s_2333_0 b4374 b2334
        if s_2333_0 {
            return block_4374(state, tracer, fn_state);
        } else {
            return block_2334(state, tracer, fn_state);
        };
    }
    fn block_2334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2334_0: const #0u : u8
        let s_2334_0: bool = false;
        // D s_2334_1: write-var gs#118585 <= s_2334_0
        fn_state.gs_118585 = s_2334_0;
        // N s_2334_2: jump b2335
        return block_2335(state, tracer, fn_state);
    }
    fn block_2335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2335_0: read-var gs#118585:u8
        let s_2335_0: bool = fn_state.gs_118585;
        // N s_2335_1: branch s_2335_0 b4373 b2336
        if s_2335_0 {
            return block_4373(state, tracer, fn_state);
        } else {
            return block_2336(state, tracer, fn_state);
        };
    }
    fn block_2336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2336_0: const #0u : u8
        let s_2336_0: bool = false;
        // D s_2336_1: write-var gs#118586 <= s_2336_0
        fn_state.gs_118586 = s_2336_0;
        // N s_2336_2: jump b2337
        return block_2337(state, tracer, fn_state);
    }
    fn block_2337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2337_0: read-var gs#118586:u8
        let s_2337_0: bool = fn_state.gs_118586;
        // N s_2337_1: branch s_2337_0 b4372 b2338
        if s_2337_0 {
            return block_4372(state, tracer, fn_state);
        } else {
            return block_2338(state, tracer, fn_state);
        };
    }
    fn block_2338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2338_0: const #0u : u8
        let s_2338_0: bool = false;
        // D s_2338_1: write-var gs#118587 <= s_2338_0
        fn_state.gs_118587 = s_2338_0;
        // N s_2338_2: jump b2339
        return block_2339(state, tracer, fn_state);
    }
    fn block_2339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2339_0: read-var gs#118587:u8
        let s_2339_0: bool = fn_state.gs_118587;
        // N s_2339_1: branch s_2339_0 b4371 b2340
        if s_2339_0 {
            return block_4371(state, tracer, fn_state);
        } else {
            return block_2340(state, tracer, fn_state);
        };
    }
    fn block_2340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2340_0: read-var CRm:u8
        let s_2340_0: u8 = fn_state.CRm;
        // D s_2340_1: cast zx s_2340_0 -> bv
        let s_2340_1: Bits = Bits::new(s_2340_0 as u128, 4u16);
        // C s_2340_2: const #0u : u8
        let s_2340_2: u8 = 0;
        // C s_2340_3: cast zx s_2340_2 -> bv
        let s_2340_3: Bits = Bits::new(s_2340_2 as u128, 4u16);
        // D s_2340_4: cmp-eq s_2340_1 s_2340_3
        let s_2340_4: bool = ((s_2340_1) == (s_2340_3));
        // N s_2340_5: branch s_2340_4 b4370 b2341
        if s_2340_4 {
            return block_4370(state, tracer, fn_state);
        } else {
            return block_2341(state, tracer, fn_state);
        };
    }
    fn block_2341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2341_0: const #0u : u8
        let s_2341_0: bool = false;
        // D s_2341_1: write-var gs#118588 <= s_2341_0
        fn_state.gs_118588 = s_2341_0;
        // N s_2341_2: jump b2342
        return block_2342(state, tracer, fn_state);
    }
    fn block_2342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2342_0: read-var gs#118588:u8
        let s_2342_0: bool = fn_state.gs_118588;
        // N s_2342_1: branch s_2342_0 b4369 b2343
        if s_2342_0 {
            return block_4369(state, tracer, fn_state);
        } else {
            return block_2343(state, tracer, fn_state);
        };
    }
    fn block_2343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2343_0: const #0u : u8
        let s_2343_0: bool = false;
        // D s_2343_1: write-var gs#118589 <= s_2343_0
        fn_state.gs_118589 = s_2343_0;
        // N s_2343_2: jump b2344
        return block_2344(state, tracer, fn_state);
    }
    fn block_2344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2344_0: read-var gs#118589:u8
        let s_2344_0: bool = fn_state.gs_118589;
        // N s_2344_1: branch s_2344_0 b4368 b2345
        if s_2344_0 {
            return block_4368(state, tracer, fn_state);
        } else {
            return block_2345(state, tracer, fn_state);
        };
    }
    fn block_2345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2345_0: const #0u : u8
        let s_2345_0: bool = false;
        // D s_2345_1: write-var gs#118590 <= s_2345_0
        fn_state.gs_118590 = s_2345_0;
        // N s_2345_2: jump b2346
        return block_2346(state, tracer, fn_state);
    }
    fn block_2346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2346_0: read-var gs#118590:u8
        let s_2346_0: bool = fn_state.gs_118590;
        // N s_2346_1: branch s_2346_0 b4367 b2347
        if s_2346_0 {
            return block_4367(state, tracer, fn_state);
        } else {
            return block_2347(state, tracer, fn_state);
        };
    }
    fn block_2347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2347_0: const #0u : u8
        let s_2347_0: bool = false;
        // D s_2347_1: write-var gs#118591 <= s_2347_0
        fn_state.gs_118591 = s_2347_0;
        // N s_2347_2: jump b2348
        return block_2348(state, tracer, fn_state);
    }
    fn block_2348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2348_0: read-var gs#118591:u8
        let s_2348_0: bool = fn_state.gs_118591;
        // N s_2348_1: branch s_2348_0 b4366 b2349
        if s_2348_0 {
            return block_4366(state, tracer, fn_state);
        } else {
            return block_2349(state, tracer, fn_state);
        };
    }
    fn block_2349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2349_0: read-var CRm:u8
        let s_2349_0: u8 = fn_state.CRm;
        // D s_2349_1: cast zx s_2349_0 -> bv
        let s_2349_1: Bits = Bits::new(s_2349_0 as u128, 4u16);
        // C s_2349_2: const #2u : u8
        let s_2349_2: u8 = 2;
        // C s_2349_3: cast zx s_2349_2 -> bv
        let s_2349_3: Bits = Bits::new(s_2349_2 as u128, 4u16);
        // D s_2349_4: cmp-eq s_2349_1 s_2349_3
        let s_2349_4: bool = ((s_2349_1) == (s_2349_3));
        // N s_2349_5: branch s_2349_4 b4365 b2350
        if s_2349_4 {
            return block_4365(state, tracer, fn_state);
        } else {
            return block_2350(state, tracer, fn_state);
        };
    }
    fn block_2350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2350_0: const #0u : u8
        let s_2350_0: bool = false;
        // D s_2350_1: write-var gs#118592 <= s_2350_0
        fn_state.gs_118592 = s_2350_0;
        // N s_2350_2: jump b2351
        return block_2351(state, tracer, fn_state);
    }
    fn block_2351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2351_0: read-var gs#118592:u8
        let s_2351_0: bool = fn_state.gs_118592;
        // N s_2351_1: branch s_2351_0 b4364 b2352
        if s_2351_0 {
            return block_4364(state, tracer, fn_state);
        } else {
            return block_2352(state, tracer, fn_state);
        };
    }
    fn block_2352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2352_0: const #0u : u8
        let s_2352_0: bool = false;
        // D s_2352_1: write-var gs#118593 <= s_2352_0
        fn_state.gs_118593 = s_2352_0;
        // N s_2352_2: jump b2353
        return block_2353(state, tracer, fn_state);
    }
    fn block_2353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2353_0: read-var gs#118593:u8
        let s_2353_0: bool = fn_state.gs_118593;
        // N s_2353_1: branch s_2353_0 b4363 b2354
        if s_2353_0 {
            return block_4363(state, tracer, fn_state);
        } else {
            return block_2354(state, tracer, fn_state);
        };
    }
    fn block_2354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2354_0: const #0u : u8
        let s_2354_0: bool = false;
        // D s_2354_1: write-var gs#118594 <= s_2354_0
        fn_state.gs_118594 = s_2354_0;
        // N s_2354_2: jump b2355
        return block_2355(state, tracer, fn_state);
    }
    fn block_2355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2355_0: read-var gs#118594:u8
        let s_2355_0: bool = fn_state.gs_118594;
        // N s_2355_1: branch s_2355_0 b4362 b2356
        if s_2355_0 {
            return block_4362(state, tracer, fn_state);
        } else {
            return block_2356(state, tracer, fn_state);
        };
    }
    fn block_2356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2356_0: const #0u : u8
        let s_2356_0: bool = false;
        // D s_2356_1: write-var gs#118595 <= s_2356_0
        fn_state.gs_118595 = s_2356_0;
        // N s_2356_2: jump b2357
        return block_2357(state, tracer, fn_state);
    }
    fn block_2357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2357_0: read-var gs#118595:u8
        let s_2357_0: bool = fn_state.gs_118595;
        // N s_2357_1: branch s_2357_0 b4361 b2358
        if s_2357_0 {
            return block_4361(state, tracer, fn_state);
        } else {
            return block_2358(state, tracer, fn_state);
        };
    }
    fn block_2358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2358_0: read-var CRm:u8
        let s_2358_0: u8 = fn_state.CRm;
        // D s_2358_1: cast zx s_2358_0 -> bv
        let s_2358_1: Bits = Bits::new(s_2358_0 as u128, 4u16);
        // C s_2358_2: const #1u : u8
        let s_2358_2: u8 = 1;
        // C s_2358_3: cast zx s_2358_2 -> bv
        let s_2358_3: Bits = Bits::new(s_2358_2 as u128, 4u16);
        // D s_2358_4: cmp-eq s_2358_1 s_2358_3
        let s_2358_4: bool = ((s_2358_1) == (s_2358_3));
        // N s_2358_5: branch s_2358_4 b4360 b2359
        if s_2358_4 {
            return block_4360(state, tracer, fn_state);
        } else {
            return block_2359(state, tracer, fn_state);
        };
    }
    fn block_2359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2359_0: const #0u : u8
        let s_2359_0: bool = false;
        // D s_2359_1: write-var gs#118596 <= s_2359_0
        fn_state.gs_118596 = s_2359_0;
        // N s_2359_2: jump b2360
        return block_2360(state, tracer, fn_state);
    }
    fn block_2360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2360_0: read-var gs#118596:u8
        let s_2360_0: bool = fn_state.gs_118596;
        // N s_2360_1: branch s_2360_0 b4359 b2361
        if s_2360_0 {
            return block_4359(state, tracer, fn_state);
        } else {
            return block_2361(state, tracer, fn_state);
        };
    }
    fn block_2361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2361_0: const #0u : u8
        let s_2361_0: bool = false;
        // D s_2361_1: write-var gs#118597 <= s_2361_0
        fn_state.gs_118597 = s_2361_0;
        // N s_2361_2: jump b2362
        return block_2362(state, tracer, fn_state);
    }
    fn block_2362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2362_0: read-var gs#118597:u8
        let s_2362_0: bool = fn_state.gs_118597;
        // N s_2362_1: branch s_2362_0 b4358 b2363
        if s_2362_0 {
            return block_4358(state, tracer, fn_state);
        } else {
            return block_2363(state, tracer, fn_state);
        };
    }
    fn block_2363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2363_0: const #0u : u8
        let s_2363_0: bool = false;
        // D s_2363_1: write-var gs#118598 <= s_2363_0
        fn_state.gs_118598 = s_2363_0;
        // N s_2363_2: jump b2364
        return block_2364(state, tracer, fn_state);
    }
    fn block_2364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2364_0: read-var gs#118598:u8
        let s_2364_0: bool = fn_state.gs_118598;
        // N s_2364_1: branch s_2364_0 b4357 b2365
        if s_2364_0 {
            return block_4357(state, tracer, fn_state);
        } else {
            return block_2365(state, tracer, fn_state);
        };
    }
    fn block_2365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2365_0: const #0u : u8
        let s_2365_0: bool = false;
        // D s_2365_1: write-var gs#118599 <= s_2365_0
        fn_state.gs_118599 = s_2365_0;
        // N s_2365_2: jump b2366
        return block_2366(state, tracer, fn_state);
    }
    fn block_2366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2366_0: read-var gs#118599:u8
        let s_2366_0: bool = fn_state.gs_118599;
        // N s_2366_1: branch s_2366_0 b4356 b2367
        if s_2366_0 {
            return block_4356(state, tracer, fn_state);
        } else {
            return block_2367(state, tracer, fn_state);
        };
    }
    fn block_2367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2367_0: read-var CRm:u8
        let s_2367_0: u8 = fn_state.CRm;
        // D s_2367_1: cast zx s_2367_0 -> bv
        let s_2367_1: Bits = Bits::new(s_2367_0 as u128, 4u16);
        // C s_2367_2: const #12u : u8
        let s_2367_2: u8 = 12;
        // C s_2367_3: cast zx s_2367_2 -> bv
        let s_2367_3: Bits = Bits::new(s_2367_2 as u128, 4u16);
        // D s_2367_4: cmp-eq s_2367_1 s_2367_3
        let s_2367_4: bool = ((s_2367_1) == (s_2367_3));
        // N s_2367_5: branch s_2367_4 b4355 b2368
        if s_2367_4 {
            return block_4355(state, tracer, fn_state);
        } else {
            return block_2368(state, tracer, fn_state);
        };
    }
    fn block_2368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2368_0: const #0u : u8
        let s_2368_0: bool = false;
        // D s_2368_1: write-var gs#118600 <= s_2368_0
        fn_state.gs_118600 = s_2368_0;
        // N s_2368_2: jump b2369
        return block_2369(state, tracer, fn_state);
    }
    fn block_2369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2369_0: read-var gs#118600:u8
        let s_2369_0: bool = fn_state.gs_118600;
        // N s_2369_1: branch s_2369_0 b4354 b2370
        if s_2369_0 {
            return block_4354(state, tracer, fn_state);
        } else {
            return block_2370(state, tracer, fn_state);
        };
    }
    fn block_2370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2370_0: const #0u : u8
        let s_2370_0: bool = false;
        // D s_2370_1: write-var gs#118601 <= s_2370_0
        fn_state.gs_118601 = s_2370_0;
        // N s_2370_2: jump b2371
        return block_2371(state, tracer, fn_state);
    }
    fn block_2371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2371_0: read-var gs#118601:u8
        let s_2371_0: bool = fn_state.gs_118601;
        // N s_2371_1: branch s_2371_0 b4353 b2372
        if s_2371_0 {
            return block_4353(state, tracer, fn_state);
        } else {
            return block_2372(state, tracer, fn_state);
        };
    }
    fn block_2372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2372_0: const #0u : u8
        let s_2372_0: bool = false;
        // D s_2372_1: write-var gs#118602 <= s_2372_0
        fn_state.gs_118602 = s_2372_0;
        // N s_2372_2: jump b2373
        return block_2373(state, tracer, fn_state);
    }
    fn block_2373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2373_0: read-var gs#118602:u8
        let s_2373_0: bool = fn_state.gs_118602;
        // N s_2373_1: branch s_2373_0 b4352 b2374
        if s_2373_0 {
            return block_4352(state, tracer, fn_state);
        } else {
            return block_2374(state, tracer, fn_state);
        };
    }
    fn block_2374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2374_0: const #0u : u8
        let s_2374_0: bool = false;
        // D s_2374_1: write-var gs#118603 <= s_2374_0
        fn_state.gs_118603 = s_2374_0;
        // N s_2374_2: jump b2375
        return block_2375(state, tracer, fn_state);
    }
    fn block_2375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2375_0: read-var gs#118603:u8
        let s_2375_0: bool = fn_state.gs_118603;
        // N s_2375_1: branch s_2375_0 b4351 b2376
        if s_2375_0 {
            return block_4351(state, tracer, fn_state);
        } else {
            return block_2376(state, tracer, fn_state);
        };
    }
    fn block_2376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2376_0: read-var CRm:u8
        let s_2376_0: u8 = fn_state.CRm;
        // D s_2376_1: cast zx s_2376_0 -> bv
        let s_2376_1: Bits = Bits::new(s_2376_0 as u128, 4u16);
        // C s_2376_2: const #0u : u8
        let s_2376_2: u8 = 0;
        // C s_2376_3: cast zx s_2376_2 -> bv
        let s_2376_3: Bits = Bits::new(s_2376_2 as u128, 4u16);
        // D s_2376_4: cmp-eq s_2376_1 s_2376_3
        let s_2376_4: bool = ((s_2376_1) == (s_2376_3));
        // N s_2376_5: branch s_2376_4 b4350 b2377
        if s_2376_4 {
            return block_4350(state, tracer, fn_state);
        } else {
            return block_2377(state, tracer, fn_state);
        };
    }
    fn block_2377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2377_0: const #0u : u8
        let s_2377_0: bool = false;
        // D s_2377_1: write-var gs#118604 <= s_2377_0
        fn_state.gs_118604 = s_2377_0;
        // N s_2377_2: jump b2378
        return block_2378(state, tracer, fn_state);
    }
    fn block_2378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2378_0: read-var gs#118604:u8
        let s_2378_0: bool = fn_state.gs_118604;
        // N s_2378_1: branch s_2378_0 b4349 b2379
        if s_2378_0 {
            return block_4349(state, tracer, fn_state);
        } else {
            return block_2379(state, tracer, fn_state);
        };
    }
    fn block_2379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2379_0: const #0u : u8
        let s_2379_0: bool = false;
        // D s_2379_1: write-var gs#118605 <= s_2379_0
        fn_state.gs_118605 = s_2379_0;
        // N s_2379_2: jump b2380
        return block_2380(state, tracer, fn_state);
    }
    fn block_2380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2380_0: read-var gs#118605:u8
        let s_2380_0: bool = fn_state.gs_118605;
        // N s_2380_1: branch s_2380_0 b4348 b2381
        if s_2380_0 {
            return block_4348(state, tracer, fn_state);
        } else {
            return block_2381(state, tracer, fn_state);
        };
    }
    fn block_2381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2381_0: const #0u : u8
        let s_2381_0: bool = false;
        // D s_2381_1: write-var gs#118606 <= s_2381_0
        fn_state.gs_118606 = s_2381_0;
        // N s_2381_2: jump b2382
        return block_2382(state, tracer, fn_state);
    }
    fn block_2382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2382_0: read-var gs#118606:u8
        let s_2382_0: bool = fn_state.gs_118606;
        // N s_2382_1: branch s_2382_0 b4347 b2383
        if s_2382_0 {
            return block_4347(state, tracer, fn_state);
        } else {
            return block_2383(state, tracer, fn_state);
        };
    }
    fn block_2383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2383_0: const #0u : u8
        let s_2383_0: bool = false;
        // D s_2383_1: write-var gs#118607 <= s_2383_0
        fn_state.gs_118607 = s_2383_0;
        // N s_2383_2: jump b2384
        return block_2384(state, tracer, fn_state);
    }
    fn block_2384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2384_0: read-var gs#118607:u8
        let s_2384_0: bool = fn_state.gs_118607;
        // N s_2384_1: branch s_2384_0 b4346 b2385
        if s_2384_0 {
            return block_4346(state, tracer, fn_state);
        } else {
            return block_2385(state, tracer, fn_state);
        };
    }
    fn block_2385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2385_0: read-var CRm:u8
        let s_2385_0: u8 = fn_state.CRm;
        // D s_2385_1: cast zx s_2385_0 -> bv
        let s_2385_1: Bits = Bits::new(s_2385_0 as u128, 4u16);
        // C s_2385_2: const #0u : u8
        let s_2385_2: u8 = 0;
        // C s_2385_3: cast zx s_2385_2 -> bv
        let s_2385_3: Bits = Bits::new(s_2385_2 as u128, 4u16);
        // D s_2385_4: cmp-eq s_2385_1 s_2385_3
        let s_2385_4: bool = ((s_2385_1) == (s_2385_3));
        // N s_2385_5: branch s_2385_4 b4345 b2386
        if s_2385_4 {
            return block_4345(state, tracer, fn_state);
        } else {
            return block_2386(state, tracer, fn_state);
        };
    }
    fn block_2386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2386_0: const #0u : u8
        let s_2386_0: bool = false;
        // D s_2386_1: write-var gs#118608 <= s_2386_0
        fn_state.gs_118608 = s_2386_0;
        // N s_2386_2: jump b2387
        return block_2387(state, tracer, fn_state);
    }
    fn block_2387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2387_0: read-var gs#118608:u8
        let s_2387_0: bool = fn_state.gs_118608;
        // N s_2387_1: branch s_2387_0 b4344 b2388
        if s_2387_0 {
            return block_4344(state, tracer, fn_state);
        } else {
            return block_2388(state, tracer, fn_state);
        };
    }
    fn block_2388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2388_0: const #0u : u8
        let s_2388_0: bool = false;
        // D s_2388_1: write-var gs#118609 <= s_2388_0
        fn_state.gs_118609 = s_2388_0;
        // N s_2388_2: jump b2389
        return block_2389(state, tracer, fn_state);
    }
    fn block_2389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2389_0: read-var gs#118609:u8
        let s_2389_0: bool = fn_state.gs_118609;
        // N s_2389_1: branch s_2389_0 b4343 b2390
        if s_2389_0 {
            return block_4343(state, tracer, fn_state);
        } else {
            return block_2390(state, tracer, fn_state);
        };
    }
    fn block_2390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2390_0: const #0u : u8
        let s_2390_0: bool = false;
        // D s_2390_1: write-var gs#118610 <= s_2390_0
        fn_state.gs_118610 = s_2390_0;
        // N s_2390_2: jump b2391
        return block_2391(state, tracer, fn_state);
    }
    fn block_2391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2391_0: read-var gs#118610:u8
        let s_2391_0: bool = fn_state.gs_118610;
        // N s_2391_1: branch s_2391_0 b4342 b2392
        if s_2391_0 {
            return block_4342(state, tracer, fn_state);
        } else {
            return block_2392(state, tracer, fn_state);
        };
    }
    fn block_2392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2392_0: const #0u : u8
        let s_2392_0: bool = false;
        // D s_2392_1: write-var gs#118611 <= s_2392_0
        fn_state.gs_118611 = s_2392_0;
        // N s_2392_2: jump b2393
        return block_2393(state, tracer, fn_state);
    }
    fn block_2393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2393_0: read-var gs#118611:u8
        let s_2393_0: bool = fn_state.gs_118611;
        // N s_2393_1: branch s_2393_0 b4341 b2394
        if s_2393_0 {
            return block_4341(state, tracer, fn_state);
        } else {
            return block_2394(state, tracer, fn_state);
        };
    }
    fn block_2394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2394_0: read-var CRm:u8
        let s_2394_0: u8 = fn_state.CRm;
        // D s_2394_1: cast zx s_2394_0 -> bv
        let s_2394_1: Bits = Bits::new(s_2394_0 as u128, 4u16);
        // C s_2394_2: const #14u : u8
        let s_2394_2: u8 = 14;
        // C s_2394_3: cast zx s_2394_2 -> bv
        let s_2394_3: Bits = Bits::new(s_2394_2 as u128, 4u16);
        // D s_2394_4: cmp-eq s_2394_1 s_2394_3
        let s_2394_4: bool = ((s_2394_1) == (s_2394_3));
        // N s_2394_5: branch s_2394_4 b4340 b2395
        if s_2394_4 {
            return block_4340(state, tracer, fn_state);
        } else {
            return block_2395(state, tracer, fn_state);
        };
    }
    fn block_2395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2395_0: const #0u : u8
        let s_2395_0: bool = false;
        // D s_2395_1: write-var gs#118612 <= s_2395_0
        fn_state.gs_118612 = s_2395_0;
        // N s_2395_2: jump b2396
        return block_2396(state, tracer, fn_state);
    }
    fn block_2396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2396_0: read-var gs#118612:u8
        let s_2396_0: bool = fn_state.gs_118612;
        // N s_2396_1: branch s_2396_0 b4339 b2397
        if s_2396_0 {
            return block_4339(state, tracer, fn_state);
        } else {
            return block_2397(state, tracer, fn_state);
        };
    }
    fn block_2397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2397_0: const #0u : u8
        let s_2397_0: bool = false;
        // D s_2397_1: write-var gs#118613 <= s_2397_0
        fn_state.gs_118613 = s_2397_0;
        // N s_2397_2: jump b2398
        return block_2398(state, tracer, fn_state);
    }
    fn block_2398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2398_0: read-var gs#118613:u8
        let s_2398_0: bool = fn_state.gs_118613;
        // N s_2398_1: branch s_2398_0 b4338 b2399
        if s_2398_0 {
            return block_4338(state, tracer, fn_state);
        } else {
            return block_2399(state, tracer, fn_state);
        };
    }
    fn block_2399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2399_0: const #0u : u8
        let s_2399_0: bool = false;
        // D s_2399_1: write-var gs#118614 <= s_2399_0
        fn_state.gs_118614 = s_2399_0;
        // N s_2399_2: jump b2400
        return block_2400(state, tracer, fn_state);
    }
    fn block_2400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2400_0: read-var gs#118614:u8
        let s_2400_0: bool = fn_state.gs_118614;
        // N s_2400_1: branch s_2400_0 b4337 b2401
        if s_2400_0 {
            return block_4337(state, tracer, fn_state);
        } else {
            return block_2401(state, tracer, fn_state);
        };
    }
    fn block_2401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2401_0: const #0u : u8
        let s_2401_0: bool = false;
        // D s_2401_1: write-var gs#118615 <= s_2401_0
        fn_state.gs_118615 = s_2401_0;
        // N s_2401_2: jump b2402
        return block_2402(state, tracer, fn_state);
    }
    fn block_2402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2402_0: read-var gs#118615:u8
        let s_2402_0: bool = fn_state.gs_118615;
        // N s_2402_1: branch s_2402_0 b4336 b2403
        if s_2402_0 {
            return block_4336(state, tracer, fn_state);
        } else {
            return block_2403(state, tracer, fn_state);
        };
    }
    fn block_2403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2403_0: read-var CRm:u8
        let s_2403_0: u8 = fn_state.CRm;
        // D s_2403_1: cast zx s_2403_0 -> bv
        let s_2403_1: Bits = Bits::new(s_2403_0 as u128, 4u16);
        // C s_2403_2: const #2u : u8
        let s_2403_2: u8 = 2;
        // C s_2403_3: cast zx s_2403_2 -> bv
        let s_2403_3: Bits = Bits::new(s_2403_2 as u128, 4u16);
        // D s_2403_4: cmp-eq s_2403_1 s_2403_3
        let s_2403_4: bool = ((s_2403_1) == (s_2403_3));
        // N s_2403_5: branch s_2403_4 b4335 b2404
        if s_2403_4 {
            return block_4335(state, tracer, fn_state);
        } else {
            return block_2404(state, tracer, fn_state);
        };
    }
    fn block_2404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2404_0: const #0u : u8
        let s_2404_0: bool = false;
        // D s_2404_1: write-var gs#118616 <= s_2404_0
        fn_state.gs_118616 = s_2404_0;
        // N s_2404_2: jump b2405
        return block_2405(state, tracer, fn_state);
    }
    fn block_2405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2405_0: read-var gs#118616:u8
        let s_2405_0: bool = fn_state.gs_118616;
        // N s_2405_1: branch s_2405_0 b4334 b2406
        if s_2405_0 {
            return block_4334(state, tracer, fn_state);
        } else {
            return block_2406(state, tracer, fn_state);
        };
    }
    fn block_2406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2406_0: const #0u : u8
        let s_2406_0: bool = false;
        // D s_2406_1: write-var gs#118617 <= s_2406_0
        fn_state.gs_118617 = s_2406_0;
        // N s_2406_2: jump b2407
        return block_2407(state, tracer, fn_state);
    }
    fn block_2407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2407_0: read-var gs#118617:u8
        let s_2407_0: bool = fn_state.gs_118617;
        // N s_2407_1: branch s_2407_0 b4333 b2408
        if s_2407_0 {
            return block_4333(state, tracer, fn_state);
        } else {
            return block_2408(state, tracer, fn_state);
        };
    }
    fn block_2408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2408_0: const #0u : u8
        let s_2408_0: bool = false;
        // D s_2408_1: write-var gs#118618 <= s_2408_0
        fn_state.gs_118618 = s_2408_0;
        // N s_2408_2: jump b2409
        return block_2409(state, tracer, fn_state);
    }
    fn block_2409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2409_0: read-var gs#118618:u8
        let s_2409_0: bool = fn_state.gs_118618;
        // N s_2409_1: branch s_2409_0 b4332 b2410
        if s_2409_0 {
            return block_4332(state, tracer, fn_state);
        } else {
            return block_2410(state, tracer, fn_state);
        };
    }
    fn block_2410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2410_0: const #0u : u8
        let s_2410_0: bool = false;
        // D s_2410_1: write-var gs#118619 <= s_2410_0
        fn_state.gs_118619 = s_2410_0;
        // N s_2410_2: jump b2411
        return block_2411(state, tracer, fn_state);
    }
    fn block_2411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2411_0: read-var gs#118619:u8
        let s_2411_0: bool = fn_state.gs_118619;
        // N s_2411_1: branch s_2411_0 b4331 b2412
        if s_2411_0 {
            return block_4331(state, tracer, fn_state);
        } else {
            return block_2412(state, tracer, fn_state);
        };
    }
    fn block_2412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2412_0: read-var CRm:u8
        let s_2412_0: u8 = fn_state.CRm;
        // D s_2412_1: cast zx s_2412_0 -> bv
        let s_2412_1: Bits = Bits::new(s_2412_0 as u128, 4u16);
        // C s_2412_2: const #0u : u8
        let s_2412_2: u8 = 0;
        // C s_2412_3: cast zx s_2412_2 -> bv
        let s_2412_3: Bits = Bits::new(s_2412_2 as u128, 4u16);
        // D s_2412_4: cmp-eq s_2412_1 s_2412_3
        let s_2412_4: bool = ((s_2412_1) == (s_2412_3));
        // N s_2412_5: branch s_2412_4 b4330 b2413
        if s_2412_4 {
            return block_4330(state, tracer, fn_state);
        } else {
            return block_2413(state, tracer, fn_state);
        };
    }
    fn block_2413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2413_0: const #0u : u8
        let s_2413_0: bool = false;
        // D s_2413_1: write-var gs#118620 <= s_2413_0
        fn_state.gs_118620 = s_2413_0;
        // N s_2413_2: jump b2414
        return block_2414(state, tracer, fn_state);
    }
    fn block_2414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2414_0: read-var gs#118620:u8
        let s_2414_0: bool = fn_state.gs_118620;
        // N s_2414_1: branch s_2414_0 b4329 b2415
        if s_2414_0 {
            return block_4329(state, tracer, fn_state);
        } else {
            return block_2415(state, tracer, fn_state);
        };
    }
    fn block_2415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2415_0: const #0u : u8
        let s_2415_0: bool = false;
        // D s_2415_1: write-var gs#118621 <= s_2415_0
        fn_state.gs_118621 = s_2415_0;
        // N s_2415_2: jump b2416
        return block_2416(state, tracer, fn_state);
    }
    fn block_2416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2416_0: read-var gs#118621:u8
        let s_2416_0: bool = fn_state.gs_118621;
        // N s_2416_1: branch s_2416_0 b4328 b2417
        if s_2416_0 {
            return block_4328(state, tracer, fn_state);
        } else {
            return block_2417(state, tracer, fn_state);
        };
    }
    fn block_2417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2417_0: const #0u : u8
        let s_2417_0: bool = false;
        // D s_2417_1: write-var gs#118622 <= s_2417_0
        fn_state.gs_118622 = s_2417_0;
        // N s_2417_2: jump b2418
        return block_2418(state, tracer, fn_state);
    }
    fn block_2418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2418_0: read-var gs#118622:u8
        let s_2418_0: bool = fn_state.gs_118622;
        // N s_2418_1: branch s_2418_0 b4327 b2419
        if s_2418_0 {
            return block_4327(state, tracer, fn_state);
        } else {
            return block_2419(state, tracer, fn_state);
        };
    }
    fn block_2419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2419_0: const #0u : u8
        let s_2419_0: bool = false;
        // D s_2419_1: write-var gs#118623 <= s_2419_0
        fn_state.gs_118623 = s_2419_0;
        // N s_2419_2: jump b2420
        return block_2420(state, tracer, fn_state);
    }
    fn block_2420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2420_0: read-var gs#118623:u8
        let s_2420_0: bool = fn_state.gs_118623;
        // N s_2420_1: branch s_2420_0 b4326 b2421
        if s_2420_0 {
            return block_4326(state, tracer, fn_state);
        } else {
            return block_2421(state, tracer, fn_state);
        };
    }
    fn block_2421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2421_0: read-var CRm:u8
        let s_2421_0: u8 = fn_state.CRm;
        // D s_2421_1: cast zx s_2421_0 -> bv
        let s_2421_1: Bits = Bits::new(s_2421_0 as u128, 4u16);
        // C s_2421_2: const #6u : u8
        let s_2421_2: u8 = 6;
        // C s_2421_3: cast zx s_2421_2 -> bv
        let s_2421_3: Bits = Bits::new(s_2421_2 as u128, 4u16);
        // D s_2421_4: cmp-eq s_2421_1 s_2421_3
        let s_2421_4: bool = ((s_2421_1) == (s_2421_3));
        // N s_2421_5: branch s_2421_4 b4325 b2422
        if s_2421_4 {
            return block_4325(state, tracer, fn_state);
        } else {
            return block_2422(state, tracer, fn_state);
        };
    }
    fn block_2422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2422_0: const #0u : u8
        let s_2422_0: bool = false;
        // D s_2422_1: write-var gs#118624 <= s_2422_0
        fn_state.gs_118624 = s_2422_0;
        // N s_2422_2: jump b2423
        return block_2423(state, tracer, fn_state);
    }
    fn block_2423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2423_0: read-var gs#118624:u8
        let s_2423_0: bool = fn_state.gs_118624;
        // N s_2423_1: branch s_2423_0 b4324 b2424
        if s_2423_0 {
            return block_4324(state, tracer, fn_state);
        } else {
            return block_2424(state, tracer, fn_state);
        };
    }
    fn block_2424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2424_0: const #0u : u8
        let s_2424_0: bool = false;
        // D s_2424_1: write-var gs#118625 <= s_2424_0
        fn_state.gs_118625 = s_2424_0;
        // N s_2424_2: jump b2425
        return block_2425(state, tracer, fn_state);
    }
    fn block_2425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2425_0: read-var gs#118625:u8
        let s_2425_0: bool = fn_state.gs_118625;
        // N s_2425_1: branch s_2425_0 b4323 b2426
        if s_2425_0 {
            return block_4323(state, tracer, fn_state);
        } else {
            return block_2426(state, tracer, fn_state);
        };
    }
    fn block_2426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2426_0: const #0u : u8
        let s_2426_0: bool = false;
        // D s_2426_1: write-var gs#118626 <= s_2426_0
        fn_state.gs_118626 = s_2426_0;
        // N s_2426_2: jump b2427
        return block_2427(state, tracer, fn_state);
    }
    fn block_2427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2427_0: read-var gs#118626:u8
        let s_2427_0: bool = fn_state.gs_118626;
        // N s_2427_1: branch s_2427_0 b4322 b2428
        if s_2427_0 {
            return block_4322(state, tracer, fn_state);
        } else {
            return block_2428(state, tracer, fn_state);
        };
    }
    fn block_2428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2428_0: const #0u : u8
        let s_2428_0: bool = false;
        // D s_2428_1: write-var gs#118627 <= s_2428_0
        fn_state.gs_118627 = s_2428_0;
        // N s_2428_2: jump b2429
        return block_2429(state, tracer, fn_state);
    }
    fn block_2429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2429_0: read-var gs#118627:u8
        let s_2429_0: bool = fn_state.gs_118627;
        // N s_2429_1: branch s_2429_0 b4321 b2430
        if s_2429_0 {
            return block_4321(state, tracer, fn_state);
        } else {
            return block_2430(state, tracer, fn_state);
        };
    }
    fn block_2430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2430_0: read-var CRm:u8
        let s_2430_0: u8 = fn_state.CRm;
        // D s_2430_1: cast zx s_2430_0 -> bv
        let s_2430_1: Bits = Bits::new(s_2430_0 as u128, 4u16);
        // C s_2430_2: const #0u : u8
        let s_2430_2: u8 = 0;
        // C s_2430_3: cast zx s_2430_2 -> bv
        let s_2430_3: Bits = Bits::new(s_2430_2 as u128, 4u16);
        // D s_2430_4: cmp-eq s_2430_1 s_2430_3
        let s_2430_4: bool = ((s_2430_1) == (s_2430_3));
        // N s_2430_5: branch s_2430_4 b4320 b2431
        if s_2430_4 {
            return block_4320(state, tracer, fn_state);
        } else {
            return block_2431(state, tracer, fn_state);
        };
    }
    fn block_2431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2431_0: const #0u : u8
        let s_2431_0: bool = false;
        // D s_2431_1: write-var gs#118628 <= s_2431_0
        fn_state.gs_118628 = s_2431_0;
        // N s_2431_2: jump b2432
        return block_2432(state, tracer, fn_state);
    }
    fn block_2432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2432_0: read-var gs#118628:u8
        let s_2432_0: bool = fn_state.gs_118628;
        // N s_2432_1: branch s_2432_0 b4319 b2433
        if s_2432_0 {
            return block_4319(state, tracer, fn_state);
        } else {
            return block_2433(state, tracer, fn_state);
        };
    }
    fn block_2433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2433_0: const #0u : u8
        let s_2433_0: bool = false;
        // D s_2433_1: write-var gs#118629 <= s_2433_0
        fn_state.gs_118629 = s_2433_0;
        // N s_2433_2: jump b2434
        return block_2434(state, tracer, fn_state);
    }
    fn block_2434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2434_0: read-var gs#118629:u8
        let s_2434_0: bool = fn_state.gs_118629;
        // N s_2434_1: branch s_2434_0 b4318 b2435
        if s_2434_0 {
            return block_4318(state, tracer, fn_state);
        } else {
            return block_2435(state, tracer, fn_state);
        };
    }
    fn block_2435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2435_0: const #0u : u8
        let s_2435_0: bool = false;
        // D s_2435_1: write-var gs#118630 <= s_2435_0
        fn_state.gs_118630 = s_2435_0;
        // N s_2435_2: jump b2436
        return block_2436(state, tracer, fn_state);
    }
    fn block_2436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2436_0: read-var gs#118630:u8
        let s_2436_0: bool = fn_state.gs_118630;
        // N s_2436_1: branch s_2436_0 b4317 b2437
        if s_2436_0 {
            return block_4317(state, tracer, fn_state);
        } else {
            return block_2437(state, tracer, fn_state);
        };
    }
    fn block_2437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2437_0: const #0u : u8
        let s_2437_0: bool = false;
        // D s_2437_1: write-var gs#118631 <= s_2437_0
        fn_state.gs_118631 = s_2437_0;
        // N s_2437_2: jump b2438
        return block_2438(state, tracer, fn_state);
    }
    fn block_2438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2438_0: read-var gs#118631:u8
        let s_2438_0: bool = fn_state.gs_118631;
        // N s_2438_1: branch s_2438_0 b4316 b2439
        if s_2438_0 {
            return block_4316(state, tracer, fn_state);
        } else {
            return block_2439(state, tracer, fn_state);
        };
    }
    fn block_2439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2439_0: read-var CRm:u8
        let s_2439_0: u8 = fn_state.CRm;
        // D s_2439_1: cast zx s_2439_0 -> bv
        let s_2439_1: Bits = Bits::new(s_2439_0 as u128, 4u16);
        // C s_2439_2: const #0u : u8
        let s_2439_2: u8 = 0;
        // C s_2439_3: cast zx s_2439_2 -> bv
        let s_2439_3: Bits = Bits::new(s_2439_2 as u128, 4u16);
        // D s_2439_4: cmp-eq s_2439_1 s_2439_3
        let s_2439_4: bool = ((s_2439_1) == (s_2439_3));
        // N s_2439_5: branch s_2439_4 b4315 b2440
        if s_2439_4 {
            return block_4315(state, tracer, fn_state);
        } else {
            return block_2440(state, tracer, fn_state);
        };
    }
    fn block_2440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2440_0: const #0u : u8
        let s_2440_0: bool = false;
        // D s_2440_1: write-var gs#118632 <= s_2440_0
        fn_state.gs_118632 = s_2440_0;
        // N s_2440_2: jump b2441
        return block_2441(state, tracer, fn_state);
    }
    fn block_2441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2441_0: read-var gs#118632:u8
        let s_2441_0: bool = fn_state.gs_118632;
        // N s_2441_1: branch s_2441_0 b4314 b2442
        if s_2441_0 {
            return block_4314(state, tracer, fn_state);
        } else {
            return block_2442(state, tracer, fn_state);
        };
    }
    fn block_2442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2442_0: const #0u : u8
        let s_2442_0: bool = false;
        // D s_2442_1: write-var gs#118633 <= s_2442_0
        fn_state.gs_118633 = s_2442_0;
        // N s_2442_2: jump b2443
        return block_2443(state, tracer, fn_state);
    }
    fn block_2443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2443_0: read-var gs#118633:u8
        let s_2443_0: bool = fn_state.gs_118633;
        // N s_2443_1: branch s_2443_0 b4313 b2444
        if s_2443_0 {
            return block_4313(state, tracer, fn_state);
        } else {
            return block_2444(state, tracer, fn_state);
        };
    }
    fn block_2444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2444_0: const #0u : u8
        let s_2444_0: bool = false;
        // D s_2444_1: write-var gs#118634 <= s_2444_0
        fn_state.gs_118634 = s_2444_0;
        // N s_2444_2: jump b2445
        return block_2445(state, tracer, fn_state);
    }
    fn block_2445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2445_0: read-var gs#118634:u8
        let s_2445_0: bool = fn_state.gs_118634;
        // N s_2445_1: branch s_2445_0 b4312 b2446
        if s_2445_0 {
            return block_4312(state, tracer, fn_state);
        } else {
            return block_2446(state, tracer, fn_state);
        };
    }
    fn block_2446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2446_0: const #0u : u8
        let s_2446_0: bool = false;
        // D s_2446_1: write-var gs#118635 <= s_2446_0
        fn_state.gs_118635 = s_2446_0;
        // N s_2446_2: jump b2447
        return block_2447(state, tracer, fn_state);
    }
    fn block_2447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2447_0: read-var gs#118635:u8
        let s_2447_0: bool = fn_state.gs_118635;
        // N s_2447_1: branch s_2447_0 b4311 b2448
        if s_2447_0 {
            return block_4311(state, tracer, fn_state);
        } else {
            return block_2448(state, tracer, fn_state);
        };
    }
    fn block_2448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2448_0: read-var CRm:u8
        let s_2448_0: u8 = fn_state.CRm;
        // D s_2448_1: cast zx s_2448_0 -> bv
        let s_2448_1: Bits = Bits::new(s_2448_0 as u128, 4u16);
        // C s_2448_2: const #11u : u8
        let s_2448_2: u8 = 11;
        // C s_2448_3: cast zx s_2448_2 -> bv
        let s_2448_3: Bits = Bits::new(s_2448_2 as u128, 4u16);
        // D s_2448_4: cmp-eq s_2448_1 s_2448_3
        let s_2448_4: bool = ((s_2448_1) == (s_2448_3));
        // N s_2448_5: branch s_2448_4 b4310 b2449
        if s_2448_4 {
            return block_4310(state, tracer, fn_state);
        } else {
            return block_2449(state, tracer, fn_state);
        };
    }
    fn block_2449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2449_0: const #0u : u8
        let s_2449_0: bool = false;
        // D s_2449_1: write-var gs#118636 <= s_2449_0
        fn_state.gs_118636 = s_2449_0;
        // N s_2449_2: jump b2450
        return block_2450(state, tracer, fn_state);
    }
    fn block_2450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2450_0: read-var gs#118636:u8
        let s_2450_0: bool = fn_state.gs_118636;
        // N s_2450_1: branch s_2450_0 b4309 b2451
        if s_2450_0 {
            return block_4309(state, tracer, fn_state);
        } else {
            return block_2451(state, tracer, fn_state);
        };
    }
    fn block_2451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2451_0: const #0u : u8
        let s_2451_0: bool = false;
        // D s_2451_1: write-var gs#118637 <= s_2451_0
        fn_state.gs_118637 = s_2451_0;
        // N s_2451_2: jump b2452
        return block_2452(state, tracer, fn_state);
    }
    fn block_2452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2452_0: read-var gs#118637:u8
        let s_2452_0: bool = fn_state.gs_118637;
        // N s_2452_1: branch s_2452_0 b4308 b2453
        if s_2452_0 {
            return block_4308(state, tracer, fn_state);
        } else {
            return block_2453(state, tracer, fn_state);
        };
    }
    fn block_2453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2453_0: const #0u : u8
        let s_2453_0: bool = false;
        // D s_2453_1: write-var gs#118638 <= s_2453_0
        fn_state.gs_118638 = s_2453_0;
        // N s_2453_2: jump b2454
        return block_2454(state, tracer, fn_state);
    }
    fn block_2454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2454_0: read-var gs#118638:u8
        let s_2454_0: bool = fn_state.gs_118638;
        // N s_2454_1: branch s_2454_0 b4307 b2455
        if s_2454_0 {
            return block_4307(state, tracer, fn_state);
        } else {
            return block_2455(state, tracer, fn_state);
        };
    }
    fn block_2455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2455_0: const #0u : u8
        let s_2455_0: bool = false;
        // D s_2455_1: write-var gs#118639 <= s_2455_0
        fn_state.gs_118639 = s_2455_0;
        // N s_2455_2: jump b2456
        return block_2456(state, tracer, fn_state);
    }
    fn block_2456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2456_0: read-var gs#118639:u8
        let s_2456_0: bool = fn_state.gs_118639;
        // N s_2456_1: branch s_2456_0 b4306 b2457
        if s_2456_0 {
            return block_4306(state, tracer, fn_state);
        } else {
            return block_2457(state, tracer, fn_state);
        };
    }
    fn block_2457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2457_0: read-var CRm:u8
        let s_2457_0: u8 = fn_state.CRm;
        // D s_2457_1: cast zx s_2457_0 -> bv
        let s_2457_1: Bits = Bits::new(s_2457_0 as u128, 4u16);
        // C s_2457_2: const #0u : u8
        let s_2457_2: u8 = 0;
        // C s_2457_3: cast zx s_2457_2 -> bv
        let s_2457_3: Bits = Bits::new(s_2457_2 as u128, 4u16);
        // D s_2457_4: cmp-eq s_2457_1 s_2457_3
        let s_2457_4: bool = ((s_2457_1) == (s_2457_3));
        // N s_2457_5: branch s_2457_4 b4305 b2458
        if s_2457_4 {
            return block_4305(state, tracer, fn_state);
        } else {
            return block_2458(state, tracer, fn_state);
        };
    }
    fn block_2458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2458_0: const #0u : u8
        let s_2458_0: bool = false;
        // D s_2458_1: write-var gs#118640 <= s_2458_0
        fn_state.gs_118640 = s_2458_0;
        // N s_2458_2: jump b2459
        return block_2459(state, tracer, fn_state);
    }
    fn block_2459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2459_0: read-var gs#118640:u8
        let s_2459_0: bool = fn_state.gs_118640;
        // N s_2459_1: branch s_2459_0 b4304 b2460
        if s_2459_0 {
            return block_4304(state, tracer, fn_state);
        } else {
            return block_2460(state, tracer, fn_state);
        };
    }
    fn block_2460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2460_0: const #0u : u8
        let s_2460_0: bool = false;
        // D s_2460_1: write-var gs#118641 <= s_2460_0
        fn_state.gs_118641 = s_2460_0;
        // N s_2460_2: jump b2461
        return block_2461(state, tracer, fn_state);
    }
    fn block_2461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2461_0: read-var gs#118641:u8
        let s_2461_0: bool = fn_state.gs_118641;
        // N s_2461_1: branch s_2461_0 b4303 b2462
        if s_2461_0 {
            return block_4303(state, tracer, fn_state);
        } else {
            return block_2462(state, tracer, fn_state);
        };
    }
    fn block_2462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2462_0: const #0u : u8
        let s_2462_0: bool = false;
        // D s_2462_1: write-var gs#118642 <= s_2462_0
        fn_state.gs_118642 = s_2462_0;
        // N s_2462_2: jump b2463
        return block_2463(state, tracer, fn_state);
    }
    fn block_2463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2463_0: read-var gs#118642:u8
        let s_2463_0: bool = fn_state.gs_118642;
        // N s_2463_1: branch s_2463_0 b4302 b2464
        if s_2463_0 {
            return block_4302(state, tracer, fn_state);
        } else {
            return block_2464(state, tracer, fn_state);
        };
    }
    fn block_2464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2464_0: const #0u : u8
        let s_2464_0: bool = false;
        // D s_2464_1: write-var gs#118643 <= s_2464_0
        fn_state.gs_118643 = s_2464_0;
        // N s_2464_2: jump b2465
        return block_2465(state, tracer, fn_state);
    }
    fn block_2465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2465_0: read-var gs#118643:u8
        let s_2465_0: bool = fn_state.gs_118643;
        // N s_2465_1: branch s_2465_0 b4301 b2466
        if s_2465_0 {
            return block_4301(state, tracer, fn_state);
        } else {
            return block_2466(state, tracer, fn_state);
        };
    }
    fn block_2466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2466_0: read-var CRm:u8
        let s_2466_0: u8 = fn_state.CRm;
        // D s_2466_1: cast zx s_2466_0 -> bv
        let s_2466_1: Bits = Bits::new(s_2466_0 as u128, 4u16);
        // C s_2466_2: const #0u : u8
        let s_2466_2: u8 = 0;
        // C s_2466_3: cast zx s_2466_2 -> bv
        let s_2466_3: Bits = Bits::new(s_2466_2 as u128, 4u16);
        // D s_2466_4: cmp-eq s_2466_1 s_2466_3
        let s_2466_4: bool = ((s_2466_1) == (s_2466_3));
        // N s_2466_5: branch s_2466_4 b4300 b2467
        if s_2466_4 {
            return block_4300(state, tracer, fn_state);
        } else {
            return block_2467(state, tracer, fn_state);
        };
    }
    fn block_2467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2467_0: const #0u : u8
        let s_2467_0: bool = false;
        // D s_2467_1: write-var gs#118644 <= s_2467_0
        fn_state.gs_118644 = s_2467_0;
        // N s_2467_2: jump b2468
        return block_2468(state, tracer, fn_state);
    }
    fn block_2468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2468_0: read-var gs#118644:u8
        let s_2468_0: bool = fn_state.gs_118644;
        // N s_2468_1: branch s_2468_0 b4299 b2469
        if s_2468_0 {
            return block_4299(state, tracer, fn_state);
        } else {
            return block_2469(state, tracer, fn_state);
        };
    }
    fn block_2469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2469_0: const #0u : u8
        let s_2469_0: bool = false;
        // D s_2469_1: write-var gs#118645 <= s_2469_0
        fn_state.gs_118645 = s_2469_0;
        // N s_2469_2: jump b2470
        return block_2470(state, tracer, fn_state);
    }
    fn block_2470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2470_0: read-var gs#118645:u8
        let s_2470_0: bool = fn_state.gs_118645;
        // N s_2470_1: branch s_2470_0 b4298 b2471
        if s_2470_0 {
            return block_4298(state, tracer, fn_state);
        } else {
            return block_2471(state, tracer, fn_state);
        };
    }
    fn block_2471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2471_0: const #0u : u8
        let s_2471_0: bool = false;
        // D s_2471_1: write-var gs#118646 <= s_2471_0
        fn_state.gs_118646 = s_2471_0;
        // N s_2471_2: jump b2472
        return block_2472(state, tracer, fn_state);
    }
    fn block_2472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2472_0: read-var gs#118646:u8
        let s_2472_0: bool = fn_state.gs_118646;
        // N s_2472_1: branch s_2472_0 b4297 b2473
        if s_2472_0 {
            return block_4297(state, tracer, fn_state);
        } else {
            return block_2473(state, tracer, fn_state);
        };
    }
    fn block_2473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2473_0: const #0u : u8
        let s_2473_0: bool = false;
        // D s_2473_1: write-var gs#118647 <= s_2473_0
        fn_state.gs_118647 = s_2473_0;
        // N s_2473_2: jump b2474
        return block_2474(state, tracer, fn_state);
    }
    fn block_2474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2474_0: read-var gs#118647:u8
        let s_2474_0: bool = fn_state.gs_118647;
        // N s_2474_1: branch s_2474_0 b4296 b2475
        if s_2474_0 {
            return block_4296(state, tracer, fn_state);
        } else {
            return block_2475(state, tracer, fn_state);
        };
    }
    fn block_2475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2475_0: read-var CRm:u8
        let s_2475_0: u8 = fn_state.CRm;
        // D s_2475_1: cast zx s_2475_0 -> bv
        let s_2475_1: Bits = Bits::new(s_2475_0 as u128, 4u16);
        // C s_2475_2: const #1u : u8
        let s_2475_2: u8 = 1;
        // C s_2475_3: cast zx s_2475_2 -> bv
        let s_2475_3: Bits = Bits::new(s_2475_2 as u128, 4u16);
        // D s_2475_4: cmp-eq s_2475_1 s_2475_3
        let s_2475_4: bool = ((s_2475_1) == (s_2475_3));
        // N s_2475_5: branch s_2475_4 b4295 b2476
        if s_2475_4 {
            return block_4295(state, tracer, fn_state);
        } else {
            return block_2476(state, tracer, fn_state);
        };
    }
    fn block_2476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2476_0: const #0u : u8
        let s_2476_0: bool = false;
        // D s_2476_1: write-var gs#118648 <= s_2476_0
        fn_state.gs_118648 = s_2476_0;
        // N s_2476_2: jump b2477
        return block_2477(state, tracer, fn_state);
    }
    fn block_2477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2477_0: read-var gs#118648:u8
        let s_2477_0: bool = fn_state.gs_118648;
        // N s_2477_1: branch s_2477_0 b4294 b2478
        if s_2477_0 {
            return block_4294(state, tracer, fn_state);
        } else {
            return block_2478(state, tracer, fn_state);
        };
    }
    fn block_2478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2478_0: const #0u : u8
        let s_2478_0: bool = false;
        // D s_2478_1: write-var gs#118649 <= s_2478_0
        fn_state.gs_118649 = s_2478_0;
        // N s_2478_2: jump b2479
        return block_2479(state, tracer, fn_state);
    }
    fn block_2479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2479_0: read-var gs#118649:u8
        let s_2479_0: bool = fn_state.gs_118649;
        // N s_2479_1: branch s_2479_0 b4293 b2480
        if s_2479_0 {
            return block_4293(state, tracer, fn_state);
        } else {
            return block_2480(state, tracer, fn_state);
        };
    }
    fn block_2480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2480_0: const #0u : u8
        let s_2480_0: bool = false;
        // D s_2480_1: write-var gs#118650 <= s_2480_0
        fn_state.gs_118650 = s_2480_0;
        // N s_2480_2: jump b2481
        return block_2481(state, tracer, fn_state);
    }
    fn block_2481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2481_0: read-var gs#118650:u8
        let s_2481_0: bool = fn_state.gs_118650;
        // N s_2481_1: branch s_2481_0 b4292 b2482
        if s_2481_0 {
            return block_4292(state, tracer, fn_state);
        } else {
            return block_2482(state, tracer, fn_state);
        };
    }
    fn block_2482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2482_0: const #0u : u8
        let s_2482_0: bool = false;
        // D s_2482_1: write-var gs#118651 <= s_2482_0
        fn_state.gs_118651 = s_2482_0;
        // N s_2482_2: jump b2483
        return block_2483(state, tracer, fn_state);
    }
    fn block_2483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2483_0: read-var gs#118651:u8
        let s_2483_0: bool = fn_state.gs_118651;
        // N s_2483_1: branch s_2483_0 b4291 b2484
        if s_2483_0 {
            return block_4291(state, tracer, fn_state);
        } else {
            return block_2484(state, tracer, fn_state);
        };
    }
    fn block_2484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2484_0: read-var CRm:u8
        let s_2484_0: u8 = fn_state.CRm;
        // D s_2484_1: cast zx s_2484_0 -> bv
        let s_2484_1: Bits = Bits::new(s_2484_0 as u128, 4u16);
        // C s_2484_2: const #3u : u8
        let s_2484_2: u8 = 3;
        // C s_2484_3: cast zx s_2484_2 -> bv
        let s_2484_3: Bits = Bits::new(s_2484_2 as u128, 4u16);
        // D s_2484_4: cmp-eq s_2484_1 s_2484_3
        let s_2484_4: bool = ((s_2484_1) == (s_2484_3));
        // N s_2484_5: branch s_2484_4 b4290 b2485
        if s_2484_4 {
            return block_4290(state, tracer, fn_state);
        } else {
            return block_2485(state, tracer, fn_state);
        };
    }
    fn block_2485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2485_0: const #0u : u8
        let s_2485_0: bool = false;
        // D s_2485_1: write-var gs#118652 <= s_2485_0
        fn_state.gs_118652 = s_2485_0;
        // N s_2485_2: jump b2486
        return block_2486(state, tracer, fn_state);
    }
    fn block_2486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2486_0: read-var gs#118652:u8
        let s_2486_0: bool = fn_state.gs_118652;
        // N s_2486_1: branch s_2486_0 b4289 b2487
        if s_2486_0 {
            return block_4289(state, tracer, fn_state);
        } else {
            return block_2487(state, tracer, fn_state);
        };
    }
    fn block_2487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2487_0: const #0u : u8
        let s_2487_0: bool = false;
        // D s_2487_1: write-var gs#118653 <= s_2487_0
        fn_state.gs_118653 = s_2487_0;
        // N s_2487_2: jump b2488
        return block_2488(state, tracer, fn_state);
    }
    fn block_2488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2488_0: read-var gs#118653:u8
        let s_2488_0: bool = fn_state.gs_118653;
        // N s_2488_1: branch s_2488_0 b4288 b2489
        if s_2488_0 {
            return block_4288(state, tracer, fn_state);
        } else {
            return block_2489(state, tracer, fn_state);
        };
    }
    fn block_2489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2489_0: const #0u : u8
        let s_2489_0: bool = false;
        // D s_2489_1: write-var gs#118654 <= s_2489_0
        fn_state.gs_118654 = s_2489_0;
        // N s_2489_2: jump b2490
        return block_2490(state, tracer, fn_state);
    }
    fn block_2490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2490_0: read-var gs#118654:u8
        let s_2490_0: bool = fn_state.gs_118654;
        // N s_2490_1: branch s_2490_0 b4287 b2491
        if s_2490_0 {
            return block_4287(state, tracer, fn_state);
        } else {
            return block_2491(state, tracer, fn_state);
        };
    }
    fn block_2491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2491_0: const #0u : u8
        let s_2491_0: bool = false;
        // D s_2491_1: write-var gs#118655 <= s_2491_0
        fn_state.gs_118655 = s_2491_0;
        // N s_2491_2: jump b2492
        return block_2492(state, tracer, fn_state);
    }
    fn block_2492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2492_0: read-var gs#118655:u8
        let s_2492_0: bool = fn_state.gs_118655;
        // N s_2492_1: branch s_2492_0 b4286 b2493
        if s_2492_0 {
            return block_4286(state, tracer, fn_state);
        } else {
            return block_2493(state, tracer, fn_state);
        };
    }
    fn block_2493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2493_0: read-var CRm:u8
        let s_2493_0: u8 = fn_state.CRm;
        // D s_2493_1: cast zx s_2493_0 -> bv
        let s_2493_1: Bits = Bits::new(s_2493_0 as u128, 4u16);
        // C s_2493_2: const #1u : u8
        let s_2493_2: u8 = 1;
        // C s_2493_3: cast zx s_2493_2 -> bv
        let s_2493_3: Bits = Bits::new(s_2493_2 as u128, 4u16);
        // D s_2493_4: cmp-eq s_2493_1 s_2493_3
        let s_2493_4: bool = ((s_2493_1) == (s_2493_3));
        // N s_2493_5: branch s_2493_4 b4285 b2494
        if s_2493_4 {
            return block_4285(state, tracer, fn_state);
        } else {
            return block_2494(state, tracer, fn_state);
        };
    }
    fn block_2494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2494_0: const #0u : u8
        let s_2494_0: bool = false;
        // D s_2494_1: write-var gs#118656 <= s_2494_0
        fn_state.gs_118656 = s_2494_0;
        // N s_2494_2: jump b2495
        return block_2495(state, tracer, fn_state);
    }
    fn block_2495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2495_0: read-var gs#118656:u8
        let s_2495_0: bool = fn_state.gs_118656;
        // N s_2495_1: branch s_2495_0 b4284 b2496
        if s_2495_0 {
            return block_4284(state, tracer, fn_state);
        } else {
            return block_2496(state, tracer, fn_state);
        };
    }
    fn block_2496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2496_0: const #0u : u8
        let s_2496_0: bool = false;
        // D s_2496_1: write-var gs#118657 <= s_2496_0
        fn_state.gs_118657 = s_2496_0;
        // N s_2496_2: jump b2497
        return block_2497(state, tracer, fn_state);
    }
    fn block_2497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2497_0: read-var gs#118657:u8
        let s_2497_0: bool = fn_state.gs_118657;
        // N s_2497_1: branch s_2497_0 b4283 b2498
        if s_2497_0 {
            return block_4283(state, tracer, fn_state);
        } else {
            return block_2498(state, tracer, fn_state);
        };
    }
    fn block_2498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2498_0: const #0u : u8
        let s_2498_0: bool = false;
        // D s_2498_1: write-var gs#118658 <= s_2498_0
        fn_state.gs_118658 = s_2498_0;
        // N s_2498_2: jump b2499
        return block_2499(state, tracer, fn_state);
    }
    fn block_2499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2499_0: read-var gs#118658:u8
        let s_2499_0: bool = fn_state.gs_118658;
        // N s_2499_1: branch s_2499_0 b4282 b2500
        if s_2499_0 {
            return block_4282(state, tracer, fn_state);
        } else {
            return block_2500(state, tracer, fn_state);
        };
    }
    fn block_2500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2500_0: const #0u : u8
        let s_2500_0: bool = false;
        // D s_2500_1: write-var gs#118659 <= s_2500_0
        fn_state.gs_118659 = s_2500_0;
        // N s_2500_2: jump b2501
        return block_2501(state, tracer, fn_state);
    }
    fn block_2501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2501_0: read-var gs#118659:u8
        let s_2501_0: bool = fn_state.gs_118659;
        // N s_2501_1: branch s_2501_0 b4281 b2502
        if s_2501_0 {
            return block_4281(state, tracer, fn_state);
        } else {
            return block_2502(state, tracer, fn_state);
        };
    }
    fn block_2502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2502_0: read-var CRm:u8
        let s_2502_0: u8 = fn_state.CRm;
        // D s_2502_1: cast zx s_2502_0 -> bv
        let s_2502_1: Bits = Bits::new(s_2502_0 as u128, 4u16);
        // C s_2502_2: const #1u : u8
        let s_2502_2: u8 = 1;
        // C s_2502_3: cast zx s_2502_2 -> bv
        let s_2502_3: Bits = Bits::new(s_2502_2 as u128, 4u16);
        // D s_2502_4: cmp-eq s_2502_1 s_2502_3
        let s_2502_4: bool = ((s_2502_1) == (s_2502_3));
        // N s_2502_5: branch s_2502_4 b4280 b2503
        if s_2502_4 {
            return block_4280(state, tracer, fn_state);
        } else {
            return block_2503(state, tracer, fn_state);
        };
    }
    fn block_2503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2503_0: const #0u : u8
        let s_2503_0: bool = false;
        // D s_2503_1: write-var gs#118660 <= s_2503_0
        fn_state.gs_118660 = s_2503_0;
        // N s_2503_2: jump b2504
        return block_2504(state, tracer, fn_state);
    }
    fn block_2504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2504_0: read-var gs#118660:u8
        let s_2504_0: bool = fn_state.gs_118660;
        // N s_2504_1: branch s_2504_0 b4279 b2505
        if s_2504_0 {
            return block_4279(state, tracer, fn_state);
        } else {
            return block_2505(state, tracer, fn_state);
        };
    }
    fn block_2505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2505_0: const #0u : u8
        let s_2505_0: bool = false;
        // D s_2505_1: write-var gs#118661 <= s_2505_0
        fn_state.gs_118661 = s_2505_0;
        // N s_2505_2: jump b2506
        return block_2506(state, tracer, fn_state);
    }
    fn block_2506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2506_0: read-var gs#118661:u8
        let s_2506_0: bool = fn_state.gs_118661;
        // N s_2506_1: branch s_2506_0 b4278 b2507
        if s_2506_0 {
            return block_4278(state, tracer, fn_state);
        } else {
            return block_2507(state, tracer, fn_state);
        };
    }
    fn block_2507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2507_0: const #0u : u8
        let s_2507_0: bool = false;
        // D s_2507_1: write-var gs#118662 <= s_2507_0
        fn_state.gs_118662 = s_2507_0;
        // N s_2507_2: jump b2508
        return block_2508(state, tracer, fn_state);
    }
    fn block_2508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2508_0: read-var gs#118662:u8
        let s_2508_0: bool = fn_state.gs_118662;
        // N s_2508_1: branch s_2508_0 b4277 b2509
        if s_2508_0 {
            return block_4277(state, tracer, fn_state);
        } else {
            return block_2509(state, tracer, fn_state);
        };
    }
    fn block_2509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2509_0: const #0u : u8
        let s_2509_0: bool = false;
        // D s_2509_1: write-var gs#118663 <= s_2509_0
        fn_state.gs_118663 = s_2509_0;
        // N s_2509_2: jump b2510
        return block_2510(state, tracer, fn_state);
    }
    fn block_2510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2510_0: read-var gs#118663:u8
        let s_2510_0: bool = fn_state.gs_118663;
        // N s_2510_1: branch s_2510_0 b4276 b2511
        if s_2510_0 {
            return block_4276(state, tracer, fn_state);
        } else {
            return block_2511(state, tracer, fn_state);
        };
    }
    fn block_2511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2511_0: read-var CRm:u8
        let s_2511_0: u8 = fn_state.CRm;
        // D s_2511_1: cast zx s_2511_0 -> bv
        let s_2511_1: Bits = Bits::new(s_2511_0 as u128, 4u16);
        // C s_2511_2: const #0u : u8
        let s_2511_2: u8 = 0;
        // C s_2511_3: cast zx s_2511_2 -> bv
        let s_2511_3: Bits = Bits::new(s_2511_2 as u128, 4u16);
        // D s_2511_4: cmp-eq s_2511_1 s_2511_3
        let s_2511_4: bool = ((s_2511_1) == (s_2511_3));
        // N s_2511_5: branch s_2511_4 b4275 b2512
        if s_2511_4 {
            return block_4275(state, tracer, fn_state);
        } else {
            return block_2512(state, tracer, fn_state);
        };
    }
    fn block_2512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2512_0: const #0u : u8
        let s_2512_0: bool = false;
        // D s_2512_1: write-var gs#118664 <= s_2512_0
        fn_state.gs_118664 = s_2512_0;
        // N s_2512_2: jump b2513
        return block_2513(state, tracer, fn_state);
    }
    fn block_2513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2513_0: read-var gs#118664:u8
        let s_2513_0: bool = fn_state.gs_118664;
        // N s_2513_1: branch s_2513_0 b4274 b2514
        if s_2513_0 {
            return block_4274(state, tracer, fn_state);
        } else {
            return block_2514(state, tracer, fn_state);
        };
    }
    fn block_2514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2514_0: const #0u : u8
        let s_2514_0: bool = false;
        // D s_2514_1: write-var gs#118665 <= s_2514_0
        fn_state.gs_118665 = s_2514_0;
        // N s_2514_2: jump b2515
        return block_2515(state, tracer, fn_state);
    }
    fn block_2515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2515_0: read-var gs#118665:u8
        let s_2515_0: bool = fn_state.gs_118665;
        // N s_2515_1: branch s_2515_0 b4273 b2516
        if s_2515_0 {
            return block_4273(state, tracer, fn_state);
        } else {
            return block_2516(state, tracer, fn_state);
        };
    }
    fn block_2516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2516_0: const #0u : u8
        let s_2516_0: bool = false;
        // D s_2516_1: write-var gs#118666 <= s_2516_0
        fn_state.gs_118666 = s_2516_0;
        // N s_2516_2: jump b2517
        return block_2517(state, tracer, fn_state);
    }
    fn block_2517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2517_0: read-var gs#118666:u8
        let s_2517_0: bool = fn_state.gs_118666;
        // N s_2517_1: branch s_2517_0 b4272 b2518
        if s_2517_0 {
            return block_4272(state, tracer, fn_state);
        } else {
            return block_2518(state, tracer, fn_state);
        };
    }
    fn block_2518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2518_0: const #0u : u8
        let s_2518_0: bool = false;
        // D s_2518_1: write-var gs#118667 <= s_2518_0
        fn_state.gs_118667 = s_2518_0;
        // N s_2518_2: jump b2519
        return block_2519(state, tracer, fn_state);
    }
    fn block_2519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2519_0: read-var gs#118667:u8
        let s_2519_0: bool = fn_state.gs_118667;
        // N s_2519_1: branch s_2519_0 b4271 b2520
        if s_2519_0 {
            return block_4271(state, tracer, fn_state);
        } else {
            return block_2520(state, tracer, fn_state);
        };
    }
    fn block_2520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2520_0: read-var CRm:u8
        let s_2520_0: u8 = fn_state.CRm;
        // D s_2520_1: cast zx s_2520_0 -> bv
        let s_2520_1: Bits = Bits::new(s_2520_0 as u128, 4u16);
        // C s_2520_2: const #1u : u8
        let s_2520_2: u8 = 1;
        // C s_2520_3: cast zx s_2520_2 -> bv
        let s_2520_3: Bits = Bits::new(s_2520_2 as u128, 4u16);
        // D s_2520_4: cmp-eq s_2520_1 s_2520_3
        let s_2520_4: bool = ((s_2520_1) == (s_2520_3));
        // N s_2520_5: branch s_2520_4 b4270 b2521
        if s_2520_4 {
            return block_4270(state, tracer, fn_state);
        } else {
            return block_2521(state, tracer, fn_state);
        };
    }
    fn block_2521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2521_0: const #0u : u8
        let s_2521_0: bool = false;
        // D s_2521_1: write-var gs#118668 <= s_2521_0
        fn_state.gs_118668 = s_2521_0;
        // N s_2521_2: jump b2522
        return block_2522(state, tracer, fn_state);
    }
    fn block_2522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2522_0: read-var gs#118668:u8
        let s_2522_0: bool = fn_state.gs_118668;
        // N s_2522_1: branch s_2522_0 b4269 b2523
        if s_2522_0 {
            return block_4269(state, tracer, fn_state);
        } else {
            return block_2523(state, tracer, fn_state);
        };
    }
    fn block_2523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2523_0: const #0u : u8
        let s_2523_0: bool = false;
        // D s_2523_1: write-var gs#118669 <= s_2523_0
        fn_state.gs_118669 = s_2523_0;
        // N s_2523_2: jump b2524
        return block_2524(state, tracer, fn_state);
    }
    fn block_2524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2524_0: read-var gs#118669:u8
        let s_2524_0: bool = fn_state.gs_118669;
        // N s_2524_1: branch s_2524_0 b4268 b2525
        if s_2524_0 {
            return block_4268(state, tracer, fn_state);
        } else {
            return block_2525(state, tracer, fn_state);
        };
    }
    fn block_2525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2525_0: const #0u : u8
        let s_2525_0: bool = false;
        // D s_2525_1: write-var gs#118670 <= s_2525_0
        fn_state.gs_118670 = s_2525_0;
        // N s_2525_2: jump b2526
        return block_2526(state, tracer, fn_state);
    }
    fn block_2526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2526_0: read-var gs#118670:u8
        let s_2526_0: bool = fn_state.gs_118670;
        // N s_2526_1: branch s_2526_0 b4267 b2527
        if s_2526_0 {
            return block_4267(state, tracer, fn_state);
        } else {
            return block_2527(state, tracer, fn_state);
        };
    }
    fn block_2527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2527_0: const #0u : u8
        let s_2527_0: bool = false;
        // D s_2527_1: write-var gs#118671 <= s_2527_0
        fn_state.gs_118671 = s_2527_0;
        // N s_2527_2: jump b2528
        return block_2528(state, tracer, fn_state);
    }
    fn block_2528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2528_0: read-var gs#118671:u8
        let s_2528_0: bool = fn_state.gs_118671;
        // N s_2528_1: branch s_2528_0 b4266 b2529
        if s_2528_0 {
            return block_4266(state, tracer, fn_state);
        } else {
            return block_2529(state, tracer, fn_state);
        };
    }
    fn block_2529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2529_0: read-var CRm:u8
        let s_2529_0: u8 = fn_state.CRm;
        // D s_2529_1: cast zx s_2529_0 -> bv
        let s_2529_1: Bits = Bits::new(s_2529_0 as u128, 4u16);
        // C s_2529_2: const #1u : u8
        let s_2529_2: u8 = 1;
        // C s_2529_3: cast zx s_2529_2 -> bv
        let s_2529_3: Bits = Bits::new(s_2529_2 as u128, 4u16);
        // D s_2529_4: cmp-eq s_2529_1 s_2529_3
        let s_2529_4: bool = ((s_2529_1) == (s_2529_3));
        // N s_2529_5: branch s_2529_4 b4265 b2530
        if s_2529_4 {
            return block_4265(state, tracer, fn_state);
        } else {
            return block_2530(state, tracer, fn_state);
        };
    }
    fn block_2530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2530_0: const #0u : u8
        let s_2530_0: bool = false;
        // D s_2530_1: write-var gs#118672 <= s_2530_0
        fn_state.gs_118672 = s_2530_0;
        // N s_2530_2: jump b2531
        return block_2531(state, tracer, fn_state);
    }
    fn block_2531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2531_0: read-var gs#118672:u8
        let s_2531_0: bool = fn_state.gs_118672;
        // N s_2531_1: branch s_2531_0 b4264 b2532
        if s_2531_0 {
            return block_4264(state, tracer, fn_state);
        } else {
            return block_2532(state, tracer, fn_state);
        };
    }
    fn block_2532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2532_0: const #0u : u8
        let s_2532_0: bool = false;
        // D s_2532_1: write-var gs#118673 <= s_2532_0
        fn_state.gs_118673 = s_2532_0;
        // N s_2532_2: jump b2533
        return block_2533(state, tracer, fn_state);
    }
    fn block_2533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2533_0: read-var gs#118673:u8
        let s_2533_0: bool = fn_state.gs_118673;
        // N s_2533_1: branch s_2533_0 b4263 b2534
        if s_2533_0 {
            return block_4263(state, tracer, fn_state);
        } else {
            return block_2534(state, tracer, fn_state);
        };
    }
    fn block_2534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2534_0: const #0u : u8
        let s_2534_0: bool = false;
        // D s_2534_1: write-var gs#118674 <= s_2534_0
        fn_state.gs_118674 = s_2534_0;
        // N s_2534_2: jump b2535
        return block_2535(state, tracer, fn_state);
    }
    fn block_2535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2535_0: read-var gs#118674:u8
        let s_2535_0: bool = fn_state.gs_118674;
        // N s_2535_1: branch s_2535_0 b4262 b2536
        if s_2535_0 {
            return block_4262(state, tracer, fn_state);
        } else {
            return block_2536(state, tracer, fn_state);
        };
    }
    fn block_2536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2536_0: const #0u : u8
        let s_2536_0: bool = false;
        // D s_2536_1: write-var gs#118675 <= s_2536_0
        fn_state.gs_118675 = s_2536_0;
        // N s_2536_2: jump b2537
        return block_2537(state, tracer, fn_state);
    }
    fn block_2537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2537_0: read-var gs#118675:u8
        let s_2537_0: bool = fn_state.gs_118675;
        // N s_2537_1: branch s_2537_0 b4261 b2538
        if s_2537_0 {
            return block_4261(state, tracer, fn_state);
        } else {
            return block_2538(state, tracer, fn_state);
        };
    }
    fn block_2538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2538_0: read-var CRm:u8
        let s_2538_0: u8 = fn_state.CRm;
        // D s_2538_1: cast zx s_2538_0 -> bv
        let s_2538_1: Bits = Bits::new(s_2538_0 as u128, 4u16);
        // C s_2538_2: const #2u : u8
        let s_2538_2: u8 = 2;
        // C s_2538_3: cast zx s_2538_2 -> bv
        let s_2538_3: Bits = Bits::new(s_2538_2 as u128, 4u16);
        // D s_2538_4: cmp-eq s_2538_1 s_2538_3
        let s_2538_4: bool = ((s_2538_1) == (s_2538_3));
        // N s_2538_5: branch s_2538_4 b4260 b2539
        if s_2538_4 {
            return block_4260(state, tracer, fn_state);
        } else {
            return block_2539(state, tracer, fn_state);
        };
    }
    fn block_2539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2539_0: const #0u : u8
        let s_2539_0: bool = false;
        // D s_2539_1: write-var gs#118676 <= s_2539_0
        fn_state.gs_118676 = s_2539_0;
        // N s_2539_2: jump b2540
        return block_2540(state, tracer, fn_state);
    }
    fn block_2540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2540_0: read-var gs#118676:u8
        let s_2540_0: bool = fn_state.gs_118676;
        // N s_2540_1: branch s_2540_0 b4259 b2541
        if s_2540_0 {
            return block_4259(state, tracer, fn_state);
        } else {
            return block_2541(state, tracer, fn_state);
        };
    }
    fn block_2541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2541_0: const #0u : u8
        let s_2541_0: bool = false;
        // D s_2541_1: write-var gs#118677 <= s_2541_0
        fn_state.gs_118677 = s_2541_0;
        // N s_2541_2: jump b2542
        return block_2542(state, tracer, fn_state);
    }
    fn block_2542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2542_0: read-var gs#118677:u8
        let s_2542_0: bool = fn_state.gs_118677;
        // N s_2542_1: branch s_2542_0 b4258 b2543
        if s_2542_0 {
            return block_4258(state, tracer, fn_state);
        } else {
            return block_2543(state, tracer, fn_state);
        };
    }
    fn block_2543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2543_0: const #0u : u8
        let s_2543_0: bool = false;
        // D s_2543_1: write-var gs#118678 <= s_2543_0
        fn_state.gs_118678 = s_2543_0;
        // N s_2543_2: jump b2544
        return block_2544(state, tracer, fn_state);
    }
    fn block_2544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2544_0: read-var gs#118678:u8
        let s_2544_0: bool = fn_state.gs_118678;
        // N s_2544_1: branch s_2544_0 b4257 b2545
        if s_2544_0 {
            return block_4257(state, tracer, fn_state);
        } else {
            return block_2545(state, tracer, fn_state);
        };
    }
    fn block_2545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2545_0: const #0u : u8
        let s_2545_0: bool = false;
        // D s_2545_1: write-var gs#118679 <= s_2545_0
        fn_state.gs_118679 = s_2545_0;
        // N s_2545_2: jump b2546
        return block_2546(state, tracer, fn_state);
    }
    fn block_2546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2546_0: read-var gs#118679:u8
        let s_2546_0: bool = fn_state.gs_118679;
        // N s_2546_1: branch s_2546_0 b4256 b2547
        if s_2546_0 {
            return block_4256(state, tracer, fn_state);
        } else {
            return block_2547(state, tracer, fn_state);
        };
    }
    fn block_2547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2547_0: read-var CRm:u8
        let s_2547_0: u8 = fn_state.CRm;
        // D s_2547_1: cast zx s_2547_0 -> bv
        let s_2547_1: Bits = Bits::new(s_2547_0 as u128, 4u16);
        // C s_2547_2: const #2u : u8
        let s_2547_2: u8 = 2;
        // C s_2547_3: cast zx s_2547_2 -> bv
        let s_2547_3: Bits = Bits::new(s_2547_2 as u128, 4u16);
        // D s_2547_4: cmp-eq s_2547_1 s_2547_3
        let s_2547_4: bool = ((s_2547_1) == (s_2547_3));
        // N s_2547_5: branch s_2547_4 b4255 b2548
        if s_2547_4 {
            return block_4255(state, tracer, fn_state);
        } else {
            return block_2548(state, tracer, fn_state);
        };
    }
    fn block_2548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2548_0: const #0u : u8
        let s_2548_0: bool = false;
        // D s_2548_1: write-var gs#118680 <= s_2548_0
        fn_state.gs_118680 = s_2548_0;
        // N s_2548_2: jump b2549
        return block_2549(state, tracer, fn_state);
    }
    fn block_2549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2549_0: read-var gs#118680:u8
        let s_2549_0: bool = fn_state.gs_118680;
        // N s_2549_1: branch s_2549_0 b4254 b2550
        if s_2549_0 {
            return block_4254(state, tracer, fn_state);
        } else {
            return block_2550(state, tracer, fn_state);
        };
    }
    fn block_2550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2550_0: const #0u : u8
        let s_2550_0: bool = false;
        // D s_2550_1: write-var gs#118681 <= s_2550_0
        fn_state.gs_118681 = s_2550_0;
        // N s_2550_2: jump b2551
        return block_2551(state, tracer, fn_state);
    }
    fn block_2551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2551_0: read-var gs#118681:u8
        let s_2551_0: bool = fn_state.gs_118681;
        // N s_2551_1: branch s_2551_0 b4253 b2552
        if s_2551_0 {
            return block_4253(state, tracer, fn_state);
        } else {
            return block_2552(state, tracer, fn_state);
        };
    }
    fn block_2552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2552_0: const #0u : u8
        let s_2552_0: bool = false;
        // D s_2552_1: write-var gs#118682 <= s_2552_0
        fn_state.gs_118682 = s_2552_0;
        // N s_2552_2: jump b2553
        return block_2553(state, tracer, fn_state);
    }
    fn block_2553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2553_0: read-var gs#118682:u8
        let s_2553_0: bool = fn_state.gs_118682;
        // N s_2553_1: branch s_2553_0 b4252 b2554
        if s_2553_0 {
            return block_4252(state, tracer, fn_state);
        } else {
            return block_2554(state, tracer, fn_state);
        };
    }
    fn block_2554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2554_0: const #0u : u8
        let s_2554_0: bool = false;
        // D s_2554_1: write-var gs#118683 <= s_2554_0
        fn_state.gs_118683 = s_2554_0;
        // N s_2554_2: jump b2555
        return block_2555(state, tracer, fn_state);
    }
    fn block_2555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2555_0: read-var gs#118683:u8
        let s_2555_0: bool = fn_state.gs_118683;
        // N s_2555_1: branch s_2555_0 b4251 b2556
        if s_2555_0 {
            return block_4251(state, tracer, fn_state);
        } else {
            return block_2556(state, tracer, fn_state);
        };
    }
    fn block_2556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2556_0: read-var CRm:u8
        let s_2556_0: u8 = fn_state.CRm;
        // D s_2556_1: cast zx s_2556_0 -> bv
        let s_2556_1: Bits = Bits::new(s_2556_0 as u128, 4u16);
        // C s_2556_2: const #0u : u8
        let s_2556_2: u8 = 0;
        // C s_2556_3: cast zx s_2556_2 -> bv
        let s_2556_3: Bits = Bits::new(s_2556_2 as u128, 4u16);
        // D s_2556_4: cmp-eq s_2556_1 s_2556_3
        let s_2556_4: bool = ((s_2556_1) == (s_2556_3));
        // N s_2556_5: branch s_2556_4 b4250 b2557
        if s_2556_4 {
            return block_4250(state, tracer, fn_state);
        } else {
            return block_2557(state, tracer, fn_state);
        };
    }
    fn block_2557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2557_0: const #0u : u8
        let s_2557_0: bool = false;
        // D s_2557_1: write-var gs#118684 <= s_2557_0
        fn_state.gs_118684 = s_2557_0;
        // N s_2557_2: jump b2558
        return block_2558(state, tracer, fn_state);
    }
    fn block_2558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2558_0: read-var gs#118684:u8
        let s_2558_0: bool = fn_state.gs_118684;
        // N s_2558_1: branch s_2558_0 b4249 b2559
        if s_2558_0 {
            return block_4249(state, tracer, fn_state);
        } else {
            return block_2559(state, tracer, fn_state);
        };
    }
    fn block_2559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2559_0: const #0u : u8
        let s_2559_0: bool = false;
        // D s_2559_1: write-var gs#118685 <= s_2559_0
        fn_state.gs_118685 = s_2559_0;
        // N s_2559_2: jump b2560
        return block_2560(state, tracer, fn_state);
    }
    fn block_2560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2560_0: read-var gs#118685:u8
        let s_2560_0: bool = fn_state.gs_118685;
        // N s_2560_1: branch s_2560_0 b4248 b2561
        if s_2560_0 {
            return block_4248(state, tracer, fn_state);
        } else {
            return block_2561(state, tracer, fn_state);
        };
    }
    fn block_2561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2561_0: const #0u : u8
        let s_2561_0: bool = false;
        // D s_2561_1: write-var gs#118686 <= s_2561_0
        fn_state.gs_118686 = s_2561_0;
        // N s_2561_2: jump b2562
        return block_2562(state, tracer, fn_state);
    }
    fn block_2562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2562_0: read-var gs#118686:u8
        let s_2562_0: bool = fn_state.gs_118686;
        // N s_2562_1: branch s_2562_0 b4247 b2563
        if s_2562_0 {
            return block_4247(state, tracer, fn_state);
        } else {
            return block_2563(state, tracer, fn_state);
        };
    }
    fn block_2563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2563_0: const #0u : u8
        let s_2563_0: bool = false;
        // D s_2563_1: write-var gs#118687 <= s_2563_0
        fn_state.gs_118687 = s_2563_0;
        // N s_2563_2: jump b2564
        return block_2564(state, tracer, fn_state);
    }
    fn block_2564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2564_0: read-var gs#118687:u8
        let s_2564_0: bool = fn_state.gs_118687;
        // N s_2564_1: branch s_2564_0 b4246 b2565
        if s_2564_0 {
            return block_4246(state, tracer, fn_state);
        } else {
            return block_2565(state, tracer, fn_state);
        };
    }
    fn block_2565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2565_0: read-var CRm:u8
        let s_2565_0: u8 = fn_state.CRm;
        // D s_2565_1: cast zx s_2565_0 -> bv
        let s_2565_1: Bits = Bits::new(s_2565_0 as u128, 4u16);
        // C s_2565_2: const #0u : u8
        let s_2565_2: u8 = 0;
        // C s_2565_3: cast zx s_2565_2 -> bv
        let s_2565_3: Bits = Bits::new(s_2565_2 as u128, 4u16);
        // D s_2565_4: cmp-eq s_2565_1 s_2565_3
        let s_2565_4: bool = ((s_2565_1) == (s_2565_3));
        // N s_2565_5: branch s_2565_4 b4245 b2566
        if s_2565_4 {
            return block_4245(state, tracer, fn_state);
        } else {
            return block_2566(state, tracer, fn_state);
        };
    }
    fn block_2566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2566_0: const #0u : u8
        let s_2566_0: bool = false;
        // D s_2566_1: write-var gs#118688 <= s_2566_0
        fn_state.gs_118688 = s_2566_0;
        // N s_2566_2: jump b2567
        return block_2567(state, tracer, fn_state);
    }
    fn block_2567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2567_0: read-var gs#118688:u8
        let s_2567_0: bool = fn_state.gs_118688;
        // N s_2567_1: branch s_2567_0 b4244 b2568
        if s_2567_0 {
            return block_4244(state, tracer, fn_state);
        } else {
            return block_2568(state, tracer, fn_state);
        };
    }
    fn block_2568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2568_0: const #0u : u8
        let s_2568_0: bool = false;
        // D s_2568_1: write-var gs#118689 <= s_2568_0
        fn_state.gs_118689 = s_2568_0;
        // N s_2568_2: jump b2569
        return block_2569(state, tracer, fn_state);
    }
    fn block_2569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2569_0: read-var gs#118689:u8
        let s_2569_0: bool = fn_state.gs_118689;
        // N s_2569_1: branch s_2569_0 b4243 b2570
        if s_2569_0 {
            return block_4243(state, tracer, fn_state);
        } else {
            return block_2570(state, tracer, fn_state);
        };
    }
    fn block_2570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2570_0: const #0u : u8
        let s_2570_0: bool = false;
        // D s_2570_1: write-var gs#118690 <= s_2570_0
        fn_state.gs_118690 = s_2570_0;
        // N s_2570_2: jump b2571
        return block_2571(state, tracer, fn_state);
    }
    fn block_2571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2571_0: read-var gs#118690:u8
        let s_2571_0: bool = fn_state.gs_118690;
        // N s_2571_1: branch s_2571_0 b4242 b2572
        if s_2571_0 {
            return block_4242(state, tracer, fn_state);
        } else {
            return block_2572(state, tracer, fn_state);
        };
    }
    fn block_2572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2572_0: const #0u : u8
        let s_2572_0: bool = false;
        // D s_2572_1: write-var gs#118691 <= s_2572_0
        fn_state.gs_118691 = s_2572_0;
        // N s_2572_2: jump b2573
        return block_2573(state, tracer, fn_state);
    }
    fn block_2573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2573_0: read-var gs#118691:u8
        let s_2573_0: bool = fn_state.gs_118691;
        // N s_2573_1: branch s_2573_0 b4241 b2574
        if s_2573_0 {
            return block_4241(state, tracer, fn_state);
        } else {
            return block_2574(state, tracer, fn_state);
        };
    }
    fn block_2574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2574_0: read-var CRm:u8
        let s_2574_0: u8 = fn_state.CRm;
        // D s_2574_1: cast zx s_2574_0 -> bv
        let s_2574_1: Bits = Bits::new(s_2574_0 as u128, 4u16);
        // C s_2574_2: const #0u : u8
        let s_2574_2: u8 = 0;
        // C s_2574_3: cast zx s_2574_2 -> bv
        let s_2574_3: Bits = Bits::new(s_2574_2 as u128, 4u16);
        // D s_2574_4: cmp-eq s_2574_1 s_2574_3
        let s_2574_4: bool = ((s_2574_1) == (s_2574_3));
        // N s_2574_5: branch s_2574_4 b4240 b2575
        if s_2574_4 {
            return block_4240(state, tracer, fn_state);
        } else {
            return block_2575(state, tracer, fn_state);
        };
    }
    fn block_2575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2575_0: const #0u : u8
        let s_2575_0: bool = false;
        // D s_2575_1: write-var gs#118692 <= s_2575_0
        fn_state.gs_118692 = s_2575_0;
        // N s_2575_2: jump b2576
        return block_2576(state, tracer, fn_state);
    }
    fn block_2576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2576_0: read-var gs#118692:u8
        let s_2576_0: bool = fn_state.gs_118692;
        // N s_2576_1: branch s_2576_0 b4239 b2577
        if s_2576_0 {
            return block_4239(state, tracer, fn_state);
        } else {
            return block_2577(state, tracer, fn_state);
        };
    }
    fn block_2577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2577_0: const #0u : u8
        let s_2577_0: bool = false;
        // D s_2577_1: write-var gs#118693 <= s_2577_0
        fn_state.gs_118693 = s_2577_0;
        // N s_2577_2: jump b2578
        return block_2578(state, tracer, fn_state);
    }
    fn block_2578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2578_0: read-var gs#118693:u8
        let s_2578_0: bool = fn_state.gs_118693;
        // N s_2578_1: branch s_2578_0 b4238 b2579
        if s_2578_0 {
            return block_4238(state, tracer, fn_state);
        } else {
            return block_2579(state, tracer, fn_state);
        };
    }
    fn block_2579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2579_0: const #0u : u8
        let s_2579_0: bool = false;
        // D s_2579_1: write-var gs#118694 <= s_2579_0
        fn_state.gs_118694 = s_2579_0;
        // N s_2579_2: jump b2580
        return block_2580(state, tracer, fn_state);
    }
    fn block_2580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2580_0: read-var gs#118694:u8
        let s_2580_0: bool = fn_state.gs_118694;
        // N s_2580_1: branch s_2580_0 b4237 b2581
        if s_2580_0 {
            return block_4237(state, tracer, fn_state);
        } else {
            return block_2581(state, tracer, fn_state);
        };
    }
    fn block_2581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2581_0: const #0u : u8
        let s_2581_0: bool = false;
        // D s_2581_1: write-var gs#118695 <= s_2581_0
        fn_state.gs_118695 = s_2581_0;
        // N s_2581_2: jump b2582
        return block_2582(state, tracer, fn_state);
    }
    fn block_2582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2582_0: read-var gs#118695:u8
        let s_2582_0: bool = fn_state.gs_118695;
        // N s_2582_1: branch s_2582_0 b4236 b2583
        if s_2582_0 {
            return block_4236(state, tracer, fn_state);
        } else {
            return block_2583(state, tracer, fn_state);
        };
    }
    fn block_2583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2583_0: read-var CRm:u8
        let s_2583_0: u8 = fn_state.CRm;
        // D s_2583_1: cast zx s_2583_0 -> bv
        let s_2583_1: Bits = Bits::new(s_2583_0 as u128, 4u16);
        // C s_2583_2: const #0u : u8
        let s_2583_2: u8 = 0;
        // C s_2583_3: cast zx s_2583_2 -> bv
        let s_2583_3: Bits = Bits::new(s_2583_2 as u128, 4u16);
        // D s_2583_4: cmp-eq s_2583_1 s_2583_3
        let s_2583_4: bool = ((s_2583_1) == (s_2583_3));
        // N s_2583_5: branch s_2583_4 b4235 b2584
        if s_2583_4 {
            return block_4235(state, tracer, fn_state);
        } else {
            return block_2584(state, tracer, fn_state);
        };
    }
    fn block_2584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2584_0: const #0u : u8
        let s_2584_0: bool = false;
        // D s_2584_1: write-var gs#118696 <= s_2584_0
        fn_state.gs_118696 = s_2584_0;
        // N s_2584_2: jump b2585
        return block_2585(state, tracer, fn_state);
    }
    fn block_2585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2585_0: read-var gs#118696:u8
        let s_2585_0: bool = fn_state.gs_118696;
        // N s_2585_1: branch s_2585_0 b4234 b2586
        if s_2585_0 {
            return block_4234(state, tracer, fn_state);
        } else {
            return block_2586(state, tracer, fn_state);
        };
    }
    fn block_2586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2586_0: const #0u : u8
        let s_2586_0: bool = false;
        // D s_2586_1: write-var gs#118697 <= s_2586_0
        fn_state.gs_118697 = s_2586_0;
        // N s_2586_2: jump b2587
        return block_2587(state, tracer, fn_state);
    }
    fn block_2587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2587_0: read-var gs#118697:u8
        let s_2587_0: bool = fn_state.gs_118697;
        // N s_2587_1: branch s_2587_0 b4233 b2588
        if s_2587_0 {
            return block_4233(state, tracer, fn_state);
        } else {
            return block_2588(state, tracer, fn_state);
        };
    }
    fn block_2588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2588_0: const #0u : u8
        let s_2588_0: bool = false;
        // D s_2588_1: write-var gs#118698 <= s_2588_0
        fn_state.gs_118698 = s_2588_0;
        // N s_2588_2: jump b2589
        return block_2589(state, tracer, fn_state);
    }
    fn block_2589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2589_0: read-var gs#118698:u8
        let s_2589_0: bool = fn_state.gs_118698;
        // N s_2589_1: branch s_2589_0 b4232 b2590
        if s_2589_0 {
            return block_4232(state, tracer, fn_state);
        } else {
            return block_2590(state, tracer, fn_state);
        };
    }
    fn block_2590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2590_0: const #0u : u8
        let s_2590_0: bool = false;
        // D s_2590_1: write-var gs#118699 <= s_2590_0
        fn_state.gs_118699 = s_2590_0;
        // N s_2590_2: jump b2591
        return block_2591(state, tracer, fn_state);
    }
    fn block_2591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2591_0: read-var gs#118699:u8
        let s_2591_0: bool = fn_state.gs_118699;
        // N s_2591_1: branch s_2591_0 b4231 b2592
        if s_2591_0 {
            return block_4231(state, tracer, fn_state);
        } else {
            return block_2592(state, tracer, fn_state);
        };
    }
    fn block_2592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2592_0: read-var CRm:u8
        let s_2592_0: u8 = fn_state.CRm;
        // D s_2592_1: cast zx s_2592_0 -> bv
        let s_2592_1: Bits = Bits::new(s_2592_0 as u128, 4u16);
        // C s_2592_2: const #0u : u8
        let s_2592_2: u8 = 0;
        // C s_2592_3: cast zx s_2592_2 -> bv
        let s_2592_3: Bits = Bits::new(s_2592_2 as u128, 4u16);
        // D s_2592_4: cmp-eq s_2592_1 s_2592_3
        let s_2592_4: bool = ((s_2592_1) == (s_2592_3));
        // N s_2592_5: branch s_2592_4 b4230 b2593
        if s_2592_4 {
            return block_4230(state, tracer, fn_state);
        } else {
            return block_2593(state, tracer, fn_state);
        };
    }
    fn block_2593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2593_0: const #0u : u8
        let s_2593_0: bool = false;
        // D s_2593_1: write-var gs#118700 <= s_2593_0
        fn_state.gs_118700 = s_2593_0;
        // N s_2593_2: jump b2594
        return block_2594(state, tracer, fn_state);
    }
    fn block_2594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2594_0: read-var gs#118700:u8
        let s_2594_0: bool = fn_state.gs_118700;
        // N s_2594_1: branch s_2594_0 b4229 b2595
        if s_2594_0 {
            return block_4229(state, tracer, fn_state);
        } else {
            return block_2595(state, tracer, fn_state);
        };
    }
    fn block_2595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2595_0: const #0u : u8
        let s_2595_0: bool = false;
        // D s_2595_1: write-var gs#118701 <= s_2595_0
        fn_state.gs_118701 = s_2595_0;
        // N s_2595_2: jump b2596
        return block_2596(state, tracer, fn_state);
    }
    fn block_2596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2596_0: read-var gs#118701:u8
        let s_2596_0: bool = fn_state.gs_118701;
        // N s_2596_1: branch s_2596_0 b4228 b2597
        if s_2596_0 {
            return block_4228(state, tracer, fn_state);
        } else {
            return block_2597(state, tracer, fn_state);
        };
    }
    fn block_2597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2597_0: const #0u : u8
        let s_2597_0: bool = false;
        // D s_2597_1: write-var gs#118702 <= s_2597_0
        fn_state.gs_118702 = s_2597_0;
        // N s_2597_2: jump b2598
        return block_2598(state, tracer, fn_state);
    }
    fn block_2598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2598_0: read-var gs#118702:u8
        let s_2598_0: bool = fn_state.gs_118702;
        // N s_2598_1: branch s_2598_0 b4227 b2599
        if s_2598_0 {
            return block_4227(state, tracer, fn_state);
        } else {
            return block_2599(state, tracer, fn_state);
        };
    }
    fn block_2599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2599_0: const #0u : u8
        let s_2599_0: bool = false;
        // D s_2599_1: write-var gs#118703 <= s_2599_0
        fn_state.gs_118703 = s_2599_0;
        // N s_2599_2: jump b2600
        return block_2600(state, tracer, fn_state);
    }
    fn block_2600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2600_0: read-var gs#118703:u8
        let s_2600_0: bool = fn_state.gs_118703;
        // N s_2600_1: branch s_2600_0 b4226 b2601
        if s_2600_0 {
            return block_4226(state, tracer, fn_state);
        } else {
            return block_2601(state, tracer, fn_state);
        };
    }
    fn block_2601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2601_0: read-var CRm:u8
        let s_2601_0: u8 = fn_state.CRm;
        // D s_2601_1: cast zx s_2601_0 -> bv
        let s_2601_1: Bits = Bits::new(s_2601_0 as u128, 4u16);
        // C s_2601_2: const #0u : u8
        let s_2601_2: u8 = 0;
        // C s_2601_3: cast zx s_2601_2 -> bv
        let s_2601_3: Bits = Bits::new(s_2601_2 as u128, 4u16);
        // D s_2601_4: cmp-eq s_2601_1 s_2601_3
        let s_2601_4: bool = ((s_2601_1) == (s_2601_3));
        // N s_2601_5: branch s_2601_4 b4225 b2602
        if s_2601_4 {
            return block_4225(state, tracer, fn_state);
        } else {
            return block_2602(state, tracer, fn_state);
        };
    }
    fn block_2602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2602_0: const #0u : u8
        let s_2602_0: bool = false;
        // D s_2602_1: write-var gs#118704 <= s_2602_0
        fn_state.gs_118704 = s_2602_0;
        // N s_2602_2: jump b2603
        return block_2603(state, tracer, fn_state);
    }
    fn block_2603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2603_0: read-var gs#118704:u8
        let s_2603_0: bool = fn_state.gs_118704;
        // N s_2603_1: branch s_2603_0 b4224 b2604
        if s_2603_0 {
            return block_4224(state, tracer, fn_state);
        } else {
            return block_2604(state, tracer, fn_state);
        };
    }
    fn block_2604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2604_0: const #0u : u8
        let s_2604_0: bool = false;
        // D s_2604_1: write-var gs#118705 <= s_2604_0
        fn_state.gs_118705 = s_2604_0;
        // N s_2604_2: jump b2605
        return block_2605(state, tracer, fn_state);
    }
    fn block_2605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2605_0: read-var gs#118705:u8
        let s_2605_0: bool = fn_state.gs_118705;
        // N s_2605_1: branch s_2605_0 b4223 b2606
        if s_2605_0 {
            return block_4223(state, tracer, fn_state);
        } else {
            return block_2606(state, tracer, fn_state);
        };
    }
    fn block_2606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2606_0: const #0u : u8
        let s_2606_0: bool = false;
        // D s_2606_1: write-var gs#118706 <= s_2606_0
        fn_state.gs_118706 = s_2606_0;
        // N s_2606_2: jump b2607
        return block_2607(state, tracer, fn_state);
    }
    fn block_2607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2607_0: read-var gs#118706:u8
        let s_2607_0: bool = fn_state.gs_118706;
        // N s_2607_1: branch s_2607_0 b4222 b2608
        if s_2607_0 {
            return block_4222(state, tracer, fn_state);
        } else {
            return block_2608(state, tracer, fn_state);
        };
    }
    fn block_2608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2608_0: const #0u : u8
        let s_2608_0: bool = false;
        // D s_2608_1: write-var gs#118707 <= s_2608_0
        fn_state.gs_118707 = s_2608_0;
        // N s_2608_2: jump b2609
        return block_2609(state, tracer, fn_state);
    }
    fn block_2609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2609_0: read-var gs#118707:u8
        let s_2609_0: bool = fn_state.gs_118707;
        // N s_2609_1: branch s_2609_0 b4221 b2610
        if s_2609_0 {
            return block_4221(state, tracer, fn_state);
        } else {
            return block_2610(state, tracer, fn_state);
        };
    }
    fn block_2610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2610_0: read-var CRm:u8
        let s_2610_0: u8 = fn_state.CRm;
        // D s_2610_1: cast zx s_2610_0 -> bv
        let s_2610_1: Bits = Bits::new(s_2610_0 as u128, 4u16);
        // C s_2610_2: const #2u : u8
        let s_2610_2: u8 = 2;
        // C s_2610_3: cast zx s_2610_2 -> bv
        let s_2610_3: Bits = Bits::new(s_2610_2 as u128, 4u16);
        // D s_2610_4: cmp-eq s_2610_1 s_2610_3
        let s_2610_4: bool = ((s_2610_1) == (s_2610_3));
        // N s_2610_5: branch s_2610_4 b4220 b2611
        if s_2610_4 {
            return block_4220(state, tracer, fn_state);
        } else {
            return block_2611(state, tracer, fn_state);
        };
    }
    fn block_2611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2611_0: const #0u : u8
        let s_2611_0: bool = false;
        // D s_2611_1: write-var gs#118708 <= s_2611_0
        fn_state.gs_118708 = s_2611_0;
        // N s_2611_2: jump b2612
        return block_2612(state, tracer, fn_state);
    }
    fn block_2612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2612_0: read-var gs#118708:u8
        let s_2612_0: bool = fn_state.gs_118708;
        // N s_2612_1: branch s_2612_0 b4219 b2613
        if s_2612_0 {
            return block_4219(state, tracer, fn_state);
        } else {
            return block_2613(state, tracer, fn_state);
        };
    }
    fn block_2613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2613_0: const #0u : u8
        let s_2613_0: bool = false;
        // D s_2613_1: write-var gs#118709 <= s_2613_0
        fn_state.gs_118709 = s_2613_0;
        // N s_2613_2: jump b2614
        return block_2614(state, tracer, fn_state);
    }
    fn block_2614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2614_0: read-var gs#118709:u8
        let s_2614_0: bool = fn_state.gs_118709;
        // N s_2614_1: branch s_2614_0 b4218 b2615
        if s_2614_0 {
            return block_4218(state, tracer, fn_state);
        } else {
            return block_2615(state, tracer, fn_state);
        };
    }
    fn block_2615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2615_0: const #0u : u8
        let s_2615_0: bool = false;
        // D s_2615_1: write-var gs#118710 <= s_2615_0
        fn_state.gs_118710 = s_2615_0;
        // N s_2615_2: jump b2616
        return block_2616(state, tracer, fn_state);
    }
    fn block_2616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2616_0: read-var gs#118710:u8
        let s_2616_0: bool = fn_state.gs_118710;
        // N s_2616_1: branch s_2616_0 b4217 b2617
        if s_2616_0 {
            return block_4217(state, tracer, fn_state);
        } else {
            return block_2617(state, tracer, fn_state);
        };
    }
    fn block_2617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2617_0: const #0u : u8
        let s_2617_0: bool = false;
        // D s_2617_1: write-var gs#118711 <= s_2617_0
        fn_state.gs_118711 = s_2617_0;
        // N s_2617_2: jump b2618
        return block_2618(state, tracer, fn_state);
    }
    fn block_2618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2618_0: read-var gs#118711:u8
        let s_2618_0: bool = fn_state.gs_118711;
        // N s_2618_1: branch s_2618_0 b4216 b2619
        if s_2618_0 {
            return block_4216(state, tracer, fn_state);
        } else {
            return block_2619(state, tracer, fn_state);
        };
    }
    fn block_2619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2619_0: read-var CRm:u8
        let s_2619_0: u8 = fn_state.CRm;
        // D s_2619_1: cast zx s_2619_0 -> bv
        let s_2619_1: Bits = Bits::new(s_2619_0 as u128, 4u16);
        // C s_2619_2: const #5u : u8
        let s_2619_2: u8 = 5;
        // C s_2619_3: cast zx s_2619_2 -> bv
        let s_2619_3: Bits = Bits::new(s_2619_2 as u128, 4u16);
        // D s_2619_4: cmp-eq s_2619_1 s_2619_3
        let s_2619_4: bool = ((s_2619_1) == (s_2619_3));
        // N s_2619_5: branch s_2619_4 b4215 b2620
        if s_2619_4 {
            return block_4215(state, tracer, fn_state);
        } else {
            return block_2620(state, tracer, fn_state);
        };
    }
    fn block_2620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2620_0: const #0u : u8
        let s_2620_0: bool = false;
        // D s_2620_1: write-var gs#118712 <= s_2620_0
        fn_state.gs_118712 = s_2620_0;
        // N s_2620_2: jump b2621
        return block_2621(state, tracer, fn_state);
    }
    fn block_2621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2621_0: read-var gs#118712:u8
        let s_2621_0: bool = fn_state.gs_118712;
        // N s_2621_1: branch s_2621_0 b4214 b2622
        if s_2621_0 {
            return block_4214(state, tracer, fn_state);
        } else {
            return block_2622(state, tracer, fn_state);
        };
    }
    fn block_2622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2622_0: const #0u : u8
        let s_2622_0: bool = false;
        // D s_2622_1: write-var gs#118713 <= s_2622_0
        fn_state.gs_118713 = s_2622_0;
        // N s_2622_2: jump b2623
        return block_2623(state, tracer, fn_state);
    }
    fn block_2623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2623_0: read-var gs#118713:u8
        let s_2623_0: bool = fn_state.gs_118713;
        // N s_2623_1: branch s_2623_0 b4213 b2624
        if s_2623_0 {
            return block_4213(state, tracer, fn_state);
        } else {
            return block_2624(state, tracer, fn_state);
        };
    }
    fn block_2624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2624_0: const #0u : u8
        let s_2624_0: bool = false;
        // D s_2624_1: write-var gs#118714 <= s_2624_0
        fn_state.gs_118714 = s_2624_0;
        // N s_2624_2: jump b2625
        return block_2625(state, tracer, fn_state);
    }
    fn block_2625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2625_0: read-var gs#118714:u8
        let s_2625_0: bool = fn_state.gs_118714;
        // N s_2625_1: branch s_2625_0 b4212 b2626
        if s_2625_0 {
            return block_4212(state, tracer, fn_state);
        } else {
            return block_2626(state, tracer, fn_state);
        };
    }
    fn block_2626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2626_0: const #0u : u8
        let s_2626_0: bool = false;
        // D s_2626_1: write-var gs#118715 <= s_2626_0
        fn_state.gs_118715 = s_2626_0;
        // N s_2626_2: jump b2627
        return block_2627(state, tracer, fn_state);
    }
    fn block_2627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2627_0: read-var gs#118715:u8
        let s_2627_0: bool = fn_state.gs_118715;
        // N s_2627_1: branch s_2627_0 b4211 b2628
        if s_2627_0 {
            return block_4211(state, tracer, fn_state);
        } else {
            return block_2628(state, tracer, fn_state);
        };
    }
    fn block_2628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2628_0: read-var CRm:u8
        let s_2628_0: u8 = fn_state.CRm;
        // D s_2628_1: cast zx s_2628_0 -> bv
        let s_2628_1: Bits = Bits::new(s_2628_0 as u128, 4u16);
        // C s_2628_2: const #0u : u8
        let s_2628_2: u8 = 0;
        // C s_2628_3: cast zx s_2628_2 -> bv
        let s_2628_3: Bits = Bits::new(s_2628_2 as u128, 4u16);
        // D s_2628_4: cmp-eq s_2628_1 s_2628_3
        let s_2628_4: bool = ((s_2628_1) == (s_2628_3));
        // N s_2628_5: branch s_2628_4 b4210 b2629
        if s_2628_4 {
            return block_4210(state, tracer, fn_state);
        } else {
            return block_2629(state, tracer, fn_state);
        };
    }
    fn block_2629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2629_0: const #0u : u8
        let s_2629_0: bool = false;
        // D s_2629_1: write-var gs#118716 <= s_2629_0
        fn_state.gs_118716 = s_2629_0;
        // N s_2629_2: jump b2630
        return block_2630(state, tracer, fn_state);
    }
    fn block_2630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2630_0: read-var gs#118716:u8
        let s_2630_0: bool = fn_state.gs_118716;
        // N s_2630_1: branch s_2630_0 b4209 b2631
        if s_2630_0 {
            return block_4209(state, tracer, fn_state);
        } else {
            return block_2631(state, tracer, fn_state);
        };
    }
    fn block_2631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2631_0: const #0u : u8
        let s_2631_0: bool = false;
        // D s_2631_1: write-var gs#118717 <= s_2631_0
        fn_state.gs_118717 = s_2631_0;
        // N s_2631_2: jump b2632
        return block_2632(state, tracer, fn_state);
    }
    fn block_2632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2632_0: read-var gs#118717:u8
        let s_2632_0: bool = fn_state.gs_118717;
        // N s_2632_1: branch s_2632_0 b4208 b2633
        if s_2632_0 {
            return block_4208(state, tracer, fn_state);
        } else {
            return block_2633(state, tracer, fn_state);
        };
    }
    fn block_2633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2633_0: const #0u : u8
        let s_2633_0: bool = false;
        // D s_2633_1: write-var gs#118718 <= s_2633_0
        fn_state.gs_118718 = s_2633_0;
        // N s_2633_2: jump b2634
        return block_2634(state, tracer, fn_state);
    }
    fn block_2634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2634_0: read-var gs#118718:u8
        let s_2634_0: bool = fn_state.gs_118718;
        // N s_2634_1: branch s_2634_0 b4207 b2635
        if s_2634_0 {
            return block_4207(state, tracer, fn_state);
        } else {
            return block_2635(state, tracer, fn_state);
        };
    }
    fn block_2635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2635_0: const #0u : u8
        let s_2635_0: bool = false;
        // D s_2635_1: write-var gs#118719 <= s_2635_0
        fn_state.gs_118719 = s_2635_0;
        // N s_2635_2: jump b2636
        return block_2636(state, tracer, fn_state);
    }
    fn block_2636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2636_0: read-var gs#118719:u8
        let s_2636_0: bool = fn_state.gs_118719;
        // N s_2636_1: branch s_2636_0 b4206 b2637
        if s_2636_0 {
            return block_4206(state, tracer, fn_state);
        } else {
            return block_2637(state, tracer, fn_state);
        };
    }
    fn block_2637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2637_0: read-var CRm:u8
        let s_2637_0: u8 = fn_state.CRm;
        // D s_2637_1: cast zx s_2637_0 -> bv
        let s_2637_1: Bits = Bits::new(s_2637_0 as u128, 4u16);
        // C s_2637_2: const #15u : u8
        let s_2637_2: u8 = 15;
        // C s_2637_3: cast zx s_2637_2 -> bv
        let s_2637_3: Bits = Bits::new(s_2637_2 as u128, 4u16);
        // D s_2637_4: cmp-eq s_2637_1 s_2637_3
        let s_2637_4: bool = ((s_2637_1) == (s_2637_3));
        // N s_2637_5: branch s_2637_4 b4205 b2638
        if s_2637_4 {
            return block_4205(state, tracer, fn_state);
        } else {
            return block_2638(state, tracer, fn_state);
        };
    }
    fn block_2638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2638_0: const #0u : u8
        let s_2638_0: bool = false;
        // D s_2638_1: write-var gs#118720 <= s_2638_0
        fn_state.gs_118720 = s_2638_0;
        // N s_2638_2: jump b2639
        return block_2639(state, tracer, fn_state);
    }
    fn block_2639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2639_0: read-var gs#118720:u8
        let s_2639_0: bool = fn_state.gs_118720;
        // N s_2639_1: branch s_2639_0 b4204 b2640
        if s_2639_0 {
            return block_4204(state, tracer, fn_state);
        } else {
            return block_2640(state, tracer, fn_state);
        };
    }
    fn block_2640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2640_0: const #0u : u8
        let s_2640_0: bool = false;
        // D s_2640_1: write-var gs#118721 <= s_2640_0
        fn_state.gs_118721 = s_2640_0;
        // N s_2640_2: jump b2641
        return block_2641(state, tracer, fn_state);
    }
    fn block_2641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2641_0: read-var gs#118721:u8
        let s_2641_0: bool = fn_state.gs_118721;
        // N s_2641_1: branch s_2641_0 b4203 b2642
        if s_2641_0 {
            return block_4203(state, tracer, fn_state);
        } else {
            return block_2642(state, tracer, fn_state);
        };
    }
    fn block_2642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2642_0: const #0u : u8
        let s_2642_0: bool = false;
        // D s_2642_1: write-var gs#118722 <= s_2642_0
        fn_state.gs_118722 = s_2642_0;
        // N s_2642_2: jump b2643
        return block_2643(state, tracer, fn_state);
    }
    fn block_2643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2643_0: read-var gs#118722:u8
        let s_2643_0: bool = fn_state.gs_118722;
        // N s_2643_1: branch s_2643_0 b4202 b2644
        if s_2643_0 {
            return block_4202(state, tracer, fn_state);
        } else {
            return block_2644(state, tracer, fn_state);
        };
    }
    fn block_2644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2644_0: const #0u : u8
        let s_2644_0: bool = false;
        // D s_2644_1: write-var gs#118723 <= s_2644_0
        fn_state.gs_118723 = s_2644_0;
        // N s_2644_2: jump b2645
        return block_2645(state, tracer, fn_state);
    }
    fn block_2645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2645_0: read-var gs#118723:u8
        let s_2645_0: bool = fn_state.gs_118723;
        // N s_2645_1: branch s_2645_0 b4201 b2646
        if s_2645_0 {
            return block_4201(state, tracer, fn_state);
        } else {
            return block_2646(state, tracer, fn_state);
        };
    }
    fn block_2646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2646_0: read-var CRm:u8
        let s_2646_0: u8 = fn_state.CRm;
        // D s_2646_1: cast zx s_2646_0 -> bv
        let s_2646_1: Bits = Bits::new(s_2646_0 as u128, 4u16);
        // C s_2646_2: const #15u : u8
        let s_2646_2: u8 = 15;
        // C s_2646_3: cast zx s_2646_2 -> bv
        let s_2646_3: Bits = Bits::new(s_2646_2 as u128, 4u16);
        // D s_2646_4: cmp-eq s_2646_1 s_2646_3
        let s_2646_4: bool = ((s_2646_1) == (s_2646_3));
        // N s_2646_5: branch s_2646_4 b4200 b2647
        if s_2646_4 {
            return block_4200(state, tracer, fn_state);
        } else {
            return block_2647(state, tracer, fn_state);
        };
    }
    fn block_2647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2647_0: const #0u : u8
        let s_2647_0: bool = false;
        // D s_2647_1: write-var gs#118724 <= s_2647_0
        fn_state.gs_118724 = s_2647_0;
        // N s_2647_2: jump b2648
        return block_2648(state, tracer, fn_state);
    }
    fn block_2648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2648_0: read-var gs#118724:u8
        let s_2648_0: bool = fn_state.gs_118724;
        // N s_2648_1: branch s_2648_0 b4199 b2649
        if s_2648_0 {
            return block_4199(state, tracer, fn_state);
        } else {
            return block_2649(state, tracer, fn_state);
        };
    }
    fn block_2649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2649_0: const #0u : u8
        let s_2649_0: bool = false;
        // D s_2649_1: write-var gs#118725 <= s_2649_0
        fn_state.gs_118725 = s_2649_0;
        // N s_2649_2: jump b2650
        return block_2650(state, tracer, fn_state);
    }
    fn block_2650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2650_0: read-var gs#118725:u8
        let s_2650_0: bool = fn_state.gs_118725;
        // N s_2650_1: branch s_2650_0 b4198 b2651
        if s_2650_0 {
            return block_4198(state, tracer, fn_state);
        } else {
            return block_2651(state, tracer, fn_state);
        };
    }
    fn block_2651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2651_0: const #0u : u8
        let s_2651_0: bool = false;
        // D s_2651_1: write-var gs#118726 <= s_2651_0
        fn_state.gs_118726 = s_2651_0;
        // N s_2651_2: jump b2652
        return block_2652(state, tracer, fn_state);
    }
    fn block_2652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2652_0: read-var gs#118726:u8
        let s_2652_0: bool = fn_state.gs_118726;
        // N s_2652_1: branch s_2652_0 b4197 b2653
        if s_2652_0 {
            return block_4197(state, tracer, fn_state);
        } else {
            return block_2653(state, tracer, fn_state);
        };
    }
    fn block_2653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2653_0: const #0u : u8
        let s_2653_0: bool = false;
        // D s_2653_1: write-var gs#118727 <= s_2653_0
        fn_state.gs_118727 = s_2653_0;
        // N s_2653_2: jump b2654
        return block_2654(state, tracer, fn_state);
    }
    fn block_2654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2654_0: read-var gs#118727:u8
        let s_2654_0: bool = fn_state.gs_118727;
        // N s_2654_1: branch s_2654_0 b4196 b2655
        if s_2654_0 {
            return block_4196(state, tracer, fn_state);
        } else {
            return block_2655(state, tracer, fn_state);
        };
    }
    fn block_2655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2655_0: read-var CRm:u8
        let s_2655_0: u8 = fn_state.CRm;
        // D s_2655_1: cast zx s_2655_0 -> bv
        let s_2655_1: Bits = Bits::new(s_2655_0 as u128, 4u16);
        // C s_2655_2: const #15u : u8
        let s_2655_2: u8 = 15;
        // C s_2655_3: cast zx s_2655_2 -> bv
        let s_2655_3: Bits = Bits::new(s_2655_2 as u128, 4u16);
        // D s_2655_4: cmp-eq s_2655_1 s_2655_3
        let s_2655_4: bool = ((s_2655_1) == (s_2655_3));
        // N s_2655_5: branch s_2655_4 b4195 b2656
        if s_2655_4 {
            return block_4195(state, tracer, fn_state);
        } else {
            return block_2656(state, tracer, fn_state);
        };
    }
    fn block_2656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2656_0: const #0u : u8
        let s_2656_0: bool = false;
        // D s_2656_1: write-var gs#118728 <= s_2656_0
        fn_state.gs_118728 = s_2656_0;
        // N s_2656_2: jump b2657
        return block_2657(state, tracer, fn_state);
    }
    fn block_2657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2657_0: read-var gs#118728:u8
        let s_2657_0: bool = fn_state.gs_118728;
        // N s_2657_1: branch s_2657_0 b4194 b2658
        if s_2657_0 {
            return block_4194(state, tracer, fn_state);
        } else {
            return block_2658(state, tracer, fn_state);
        };
    }
    fn block_2658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2658_0: const #0u : u8
        let s_2658_0: bool = false;
        // D s_2658_1: write-var gs#118729 <= s_2658_0
        fn_state.gs_118729 = s_2658_0;
        // N s_2658_2: jump b2659
        return block_2659(state, tracer, fn_state);
    }
    fn block_2659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2659_0: read-var gs#118729:u8
        let s_2659_0: bool = fn_state.gs_118729;
        // N s_2659_1: branch s_2659_0 b4193 b2660
        if s_2659_0 {
            return block_4193(state, tracer, fn_state);
        } else {
            return block_2660(state, tracer, fn_state);
        };
    }
    fn block_2660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2660_0: const #0u : u8
        let s_2660_0: bool = false;
        // D s_2660_1: write-var gs#118730 <= s_2660_0
        fn_state.gs_118730 = s_2660_0;
        // N s_2660_2: jump b2661
        return block_2661(state, tracer, fn_state);
    }
    fn block_2661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2661_0: read-var gs#118730:u8
        let s_2661_0: bool = fn_state.gs_118730;
        // N s_2661_1: branch s_2661_0 b4192 b2662
        if s_2661_0 {
            return block_4192(state, tracer, fn_state);
        } else {
            return block_2662(state, tracer, fn_state);
        };
    }
    fn block_2662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2662_0: const #0u : u8
        let s_2662_0: bool = false;
        // D s_2662_1: write-var gs#118731 <= s_2662_0
        fn_state.gs_118731 = s_2662_0;
        // N s_2662_2: jump b2663
        return block_2663(state, tracer, fn_state);
    }
    fn block_2663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2663_0: read-var gs#118731:u8
        let s_2663_0: bool = fn_state.gs_118731;
        // N s_2663_1: branch s_2663_0 b4191 b2664
        if s_2663_0 {
            return block_4191(state, tracer, fn_state);
        } else {
            return block_2664(state, tracer, fn_state);
        };
    }
    fn block_2664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2664_0: read-var CRm:u8
        let s_2664_0: u8 = fn_state.CRm;
        // D s_2664_1: cast zx s_2664_0 -> bv
        let s_2664_1: Bits = Bits::new(s_2664_0 as u128, 4u16);
        // C s_2664_2: const #15u : u8
        let s_2664_2: u8 = 15;
        // C s_2664_3: cast zx s_2664_2 -> bv
        let s_2664_3: Bits = Bits::new(s_2664_2 as u128, 4u16);
        // D s_2664_4: cmp-eq s_2664_1 s_2664_3
        let s_2664_4: bool = ((s_2664_1) == (s_2664_3));
        // N s_2664_5: branch s_2664_4 b4190 b2665
        if s_2664_4 {
            return block_4190(state, tracer, fn_state);
        } else {
            return block_2665(state, tracer, fn_state);
        };
    }
    fn block_2665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2665_0: const #0u : u8
        let s_2665_0: bool = false;
        // D s_2665_1: write-var gs#118732 <= s_2665_0
        fn_state.gs_118732 = s_2665_0;
        // N s_2665_2: jump b2666
        return block_2666(state, tracer, fn_state);
    }
    fn block_2666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2666_0: read-var gs#118732:u8
        let s_2666_0: bool = fn_state.gs_118732;
        // N s_2666_1: branch s_2666_0 b4189 b2667
        if s_2666_0 {
            return block_4189(state, tracer, fn_state);
        } else {
            return block_2667(state, tracer, fn_state);
        };
    }
    fn block_2667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2667_0: const #0u : u8
        let s_2667_0: bool = false;
        // D s_2667_1: write-var gs#118733 <= s_2667_0
        fn_state.gs_118733 = s_2667_0;
        // N s_2667_2: jump b2668
        return block_2668(state, tracer, fn_state);
    }
    fn block_2668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2668_0: read-var gs#118733:u8
        let s_2668_0: bool = fn_state.gs_118733;
        // N s_2668_1: branch s_2668_0 b4188 b2669
        if s_2668_0 {
            return block_4188(state, tracer, fn_state);
        } else {
            return block_2669(state, tracer, fn_state);
        };
    }
    fn block_2669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2669_0: const #0u : u8
        let s_2669_0: bool = false;
        // D s_2669_1: write-var gs#118734 <= s_2669_0
        fn_state.gs_118734 = s_2669_0;
        // N s_2669_2: jump b2670
        return block_2670(state, tracer, fn_state);
    }
    fn block_2670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2670_0: read-var gs#118734:u8
        let s_2670_0: bool = fn_state.gs_118734;
        // N s_2670_1: branch s_2670_0 b4187 b2671
        if s_2670_0 {
            return block_4187(state, tracer, fn_state);
        } else {
            return block_2671(state, tracer, fn_state);
        };
    }
    fn block_2671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2671_0: const #0u : u8
        let s_2671_0: bool = false;
        // D s_2671_1: write-var gs#118735 <= s_2671_0
        fn_state.gs_118735 = s_2671_0;
        // N s_2671_2: jump b2672
        return block_2672(state, tracer, fn_state);
    }
    fn block_2672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2672_0: read-var gs#118735:u8
        let s_2672_0: bool = fn_state.gs_118735;
        // N s_2672_1: branch s_2672_0 b4186 b2673
        if s_2672_0 {
            return block_4186(state, tracer, fn_state);
        } else {
            return block_2673(state, tracer, fn_state);
        };
    }
    fn block_2673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2673_0: read-var CRm:u8
        let s_2673_0: u8 = fn_state.CRm;
        // D s_2673_1: cast zx s_2673_0 -> bv
        let s_2673_1: Bits = Bits::new(s_2673_0 as u128, 4u16);
        // C s_2673_2: const #15u : u8
        let s_2673_2: u8 = 15;
        // C s_2673_3: cast zx s_2673_2 -> bv
        let s_2673_3: Bits = Bits::new(s_2673_2 as u128, 4u16);
        // D s_2673_4: cmp-eq s_2673_1 s_2673_3
        let s_2673_4: bool = ((s_2673_1) == (s_2673_3));
        // N s_2673_5: branch s_2673_4 b4185 b2674
        if s_2673_4 {
            return block_4185(state, tracer, fn_state);
        } else {
            return block_2674(state, tracer, fn_state);
        };
    }
    fn block_2674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2674_0: const #0u : u8
        let s_2674_0: bool = false;
        // D s_2674_1: write-var gs#118736 <= s_2674_0
        fn_state.gs_118736 = s_2674_0;
        // N s_2674_2: jump b2675
        return block_2675(state, tracer, fn_state);
    }
    fn block_2675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2675_0: read-var gs#118736:u8
        let s_2675_0: bool = fn_state.gs_118736;
        // N s_2675_1: branch s_2675_0 b4184 b2676
        if s_2675_0 {
            return block_4184(state, tracer, fn_state);
        } else {
            return block_2676(state, tracer, fn_state);
        };
    }
    fn block_2676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2676_0: const #0u : u8
        let s_2676_0: bool = false;
        // D s_2676_1: write-var gs#118737 <= s_2676_0
        fn_state.gs_118737 = s_2676_0;
        // N s_2676_2: jump b2677
        return block_2677(state, tracer, fn_state);
    }
    fn block_2677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2677_0: read-var gs#118737:u8
        let s_2677_0: bool = fn_state.gs_118737;
        // N s_2677_1: branch s_2677_0 b4183 b2678
        if s_2677_0 {
            return block_4183(state, tracer, fn_state);
        } else {
            return block_2678(state, tracer, fn_state);
        };
    }
    fn block_2678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2678_0: const #0u : u8
        let s_2678_0: bool = false;
        // D s_2678_1: write-var gs#118738 <= s_2678_0
        fn_state.gs_118738 = s_2678_0;
        // N s_2678_2: jump b2679
        return block_2679(state, tracer, fn_state);
    }
    fn block_2679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2679_0: read-var gs#118738:u8
        let s_2679_0: bool = fn_state.gs_118738;
        // N s_2679_1: branch s_2679_0 b4182 b2680
        if s_2679_0 {
            return block_4182(state, tracer, fn_state);
        } else {
            return block_2680(state, tracer, fn_state);
        };
    }
    fn block_2680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2680_0: const #0u : u8
        let s_2680_0: bool = false;
        // D s_2680_1: write-var gs#118739 <= s_2680_0
        fn_state.gs_118739 = s_2680_0;
        // N s_2680_2: jump b2681
        return block_2681(state, tracer, fn_state);
    }
    fn block_2681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2681_0: read-var gs#118739:u8
        let s_2681_0: bool = fn_state.gs_118739;
        // N s_2681_1: branch s_2681_0 b4181 b2682
        if s_2681_0 {
            return block_4181(state, tracer, fn_state);
        } else {
            return block_2682(state, tracer, fn_state);
        };
    }
    fn block_2682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2682_0: read-var CRm:u8
        let s_2682_0: u8 = fn_state.CRm;
        // D s_2682_1: cast zx s_2682_0 -> bv
        let s_2682_1: Bits = Bits::new(s_2682_0 as u128, 4u16);
        // C s_2682_2: const #15u : u8
        let s_2682_2: u8 = 15;
        // C s_2682_3: cast zx s_2682_2 -> bv
        let s_2682_3: Bits = Bits::new(s_2682_2 as u128, 4u16);
        // D s_2682_4: cmp-eq s_2682_1 s_2682_3
        let s_2682_4: bool = ((s_2682_1) == (s_2682_3));
        // N s_2682_5: branch s_2682_4 b4180 b2683
        if s_2682_4 {
            return block_4180(state, tracer, fn_state);
        } else {
            return block_2683(state, tracer, fn_state);
        };
    }
    fn block_2683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2683_0: const #0u : u8
        let s_2683_0: bool = false;
        // D s_2683_1: write-var gs#118740 <= s_2683_0
        fn_state.gs_118740 = s_2683_0;
        // N s_2683_2: jump b2684
        return block_2684(state, tracer, fn_state);
    }
    fn block_2684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2684_0: read-var gs#118740:u8
        let s_2684_0: bool = fn_state.gs_118740;
        // N s_2684_1: branch s_2684_0 b4179 b2685
        if s_2684_0 {
            return block_4179(state, tracer, fn_state);
        } else {
            return block_2685(state, tracer, fn_state);
        };
    }
    fn block_2685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2685_0: const #0u : u8
        let s_2685_0: bool = false;
        // D s_2685_1: write-var gs#118741 <= s_2685_0
        fn_state.gs_118741 = s_2685_0;
        // N s_2685_2: jump b2686
        return block_2686(state, tracer, fn_state);
    }
    fn block_2686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2686_0: read-var gs#118741:u8
        let s_2686_0: bool = fn_state.gs_118741;
        // N s_2686_1: branch s_2686_0 b4178 b2687
        if s_2686_0 {
            return block_4178(state, tracer, fn_state);
        } else {
            return block_2687(state, tracer, fn_state);
        };
    }
    fn block_2687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2687_0: const #0u : u8
        let s_2687_0: bool = false;
        // D s_2687_1: write-var gs#118742 <= s_2687_0
        fn_state.gs_118742 = s_2687_0;
        // N s_2687_2: jump b2688
        return block_2688(state, tracer, fn_state);
    }
    fn block_2688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2688_0: read-var gs#118742:u8
        let s_2688_0: bool = fn_state.gs_118742;
        // N s_2688_1: branch s_2688_0 b4177 b2689
        if s_2688_0 {
            return block_4177(state, tracer, fn_state);
        } else {
            return block_2689(state, tracer, fn_state);
        };
    }
    fn block_2689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2689_0: const #0u : u8
        let s_2689_0: bool = false;
        // D s_2689_1: write-var gs#118743 <= s_2689_0
        fn_state.gs_118743 = s_2689_0;
        // N s_2689_2: jump b2690
        return block_2690(state, tracer, fn_state);
    }
    fn block_2690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2690_0: read-var gs#118743:u8
        let s_2690_0: bool = fn_state.gs_118743;
        // N s_2690_1: branch s_2690_0 b4176 b2691
        if s_2690_0 {
            return block_4176(state, tracer, fn_state);
        } else {
            return block_2691(state, tracer, fn_state);
        };
    }
    fn block_2691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2691_0: read-var CRm:u8
        let s_2691_0: u8 = fn_state.CRm;
        // D s_2691_1: cast zx s_2691_0 -> bv
        let s_2691_1: Bits = Bits::new(s_2691_0 as u128, 4u16);
        // C s_2691_2: const #15u : u8
        let s_2691_2: u8 = 15;
        // C s_2691_3: cast zx s_2691_2 -> bv
        let s_2691_3: Bits = Bits::new(s_2691_2 as u128, 4u16);
        // D s_2691_4: cmp-eq s_2691_1 s_2691_3
        let s_2691_4: bool = ((s_2691_1) == (s_2691_3));
        // N s_2691_5: branch s_2691_4 b4175 b2692
        if s_2691_4 {
            return block_4175(state, tracer, fn_state);
        } else {
            return block_2692(state, tracer, fn_state);
        };
    }
    fn block_2692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2692_0: const #0u : u8
        let s_2692_0: bool = false;
        // D s_2692_1: write-var gs#118744 <= s_2692_0
        fn_state.gs_118744 = s_2692_0;
        // N s_2692_2: jump b2693
        return block_2693(state, tracer, fn_state);
    }
    fn block_2693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2693_0: read-var gs#118744:u8
        let s_2693_0: bool = fn_state.gs_118744;
        // N s_2693_1: branch s_2693_0 b4174 b2694
        if s_2693_0 {
            return block_4174(state, tracer, fn_state);
        } else {
            return block_2694(state, tracer, fn_state);
        };
    }
    fn block_2694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2694_0: const #0u : u8
        let s_2694_0: bool = false;
        // D s_2694_1: write-var gs#118745 <= s_2694_0
        fn_state.gs_118745 = s_2694_0;
        // N s_2694_2: jump b2695
        return block_2695(state, tracer, fn_state);
    }
    fn block_2695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2695_0: read-var gs#118745:u8
        let s_2695_0: bool = fn_state.gs_118745;
        // N s_2695_1: branch s_2695_0 b4173 b2696
        if s_2695_0 {
            return block_4173(state, tracer, fn_state);
        } else {
            return block_2696(state, tracer, fn_state);
        };
    }
    fn block_2696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2696_0: const #0u : u8
        let s_2696_0: bool = false;
        // D s_2696_1: write-var gs#118746 <= s_2696_0
        fn_state.gs_118746 = s_2696_0;
        // N s_2696_2: jump b2697
        return block_2697(state, tracer, fn_state);
    }
    fn block_2697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2697_0: read-var gs#118746:u8
        let s_2697_0: bool = fn_state.gs_118746;
        // N s_2697_1: branch s_2697_0 b4172 b2698
        if s_2697_0 {
            return block_4172(state, tracer, fn_state);
        } else {
            return block_2698(state, tracer, fn_state);
        };
    }
    fn block_2698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2698_0: const #0u : u8
        let s_2698_0: bool = false;
        // D s_2698_1: write-var gs#118747 <= s_2698_0
        fn_state.gs_118747 = s_2698_0;
        // N s_2698_2: jump b2699
        return block_2699(state, tracer, fn_state);
    }
    fn block_2699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2699_0: read-var gs#118747:u8
        let s_2699_0: bool = fn_state.gs_118747;
        // N s_2699_1: branch s_2699_0 b4171 b2700
        if s_2699_0 {
            return block_4171(state, tracer, fn_state);
        } else {
            return block_2700(state, tracer, fn_state);
        };
    }
    fn block_2700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2700_0: read-var CRm:u8
        let s_2700_0: u8 = fn_state.CRm;
        // D s_2700_1: cast zx s_2700_0 -> bv
        let s_2700_1: Bits = Bits::new(s_2700_0 as u128, 4u16);
        // C s_2700_2: const #14u : u8
        let s_2700_2: u8 = 14;
        // C s_2700_3: cast zx s_2700_2 -> bv
        let s_2700_3: Bits = Bits::new(s_2700_2 as u128, 4u16);
        // D s_2700_4: cmp-eq s_2700_1 s_2700_3
        let s_2700_4: bool = ((s_2700_1) == (s_2700_3));
        // N s_2700_5: branch s_2700_4 b4170 b2701
        if s_2700_4 {
            return block_4170(state, tracer, fn_state);
        } else {
            return block_2701(state, tracer, fn_state);
        };
    }
    fn block_2701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2701_0: const #0u : u8
        let s_2701_0: bool = false;
        // D s_2701_1: write-var gs#118748 <= s_2701_0
        fn_state.gs_118748 = s_2701_0;
        // N s_2701_2: jump b2702
        return block_2702(state, tracer, fn_state);
    }
    fn block_2702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2702_0: read-var gs#118748:u8
        let s_2702_0: bool = fn_state.gs_118748;
        // N s_2702_1: branch s_2702_0 b4169 b2703
        if s_2702_0 {
            return block_4169(state, tracer, fn_state);
        } else {
            return block_2703(state, tracer, fn_state);
        };
    }
    fn block_2703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2703_0: const #0u : u8
        let s_2703_0: bool = false;
        // D s_2703_1: write-var gs#118749 <= s_2703_0
        fn_state.gs_118749 = s_2703_0;
        // N s_2703_2: jump b2704
        return block_2704(state, tracer, fn_state);
    }
    fn block_2704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2704_0: read-var gs#118749:u8
        let s_2704_0: bool = fn_state.gs_118749;
        // N s_2704_1: branch s_2704_0 b4168 b2705
        if s_2704_0 {
            return block_4168(state, tracer, fn_state);
        } else {
            return block_2705(state, tracer, fn_state);
        };
    }
    fn block_2705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2705_0: const #0u : u8
        let s_2705_0: bool = false;
        // D s_2705_1: write-var gs#118750 <= s_2705_0
        fn_state.gs_118750 = s_2705_0;
        // N s_2705_2: jump b2706
        return block_2706(state, tracer, fn_state);
    }
    fn block_2706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2706_0: read-var gs#118750:u8
        let s_2706_0: bool = fn_state.gs_118750;
        // N s_2706_1: branch s_2706_0 b4167 b2707
        if s_2706_0 {
            return block_4167(state, tracer, fn_state);
        } else {
            return block_2707(state, tracer, fn_state);
        };
    }
    fn block_2707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2707_0: const #0u : u8
        let s_2707_0: bool = false;
        // D s_2707_1: write-var gs#118751 <= s_2707_0
        fn_state.gs_118751 = s_2707_0;
        // N s_2707_2: jump b2708
        return block_2708(state, tracer, fn_state);
    }
    fn block_2708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2708_0: read-var gs#118751:u8
        let s_2708_0: bool = fn_state.gs_118751;
        // N s_2708_1: branch s_2708_0 b4166 b2709
        if s_2708_0 {
            return block_4166(state, tracer, fn_state);
        } else {
            return block_2709(state, tracer, fn_state);
        };
    }
    fn block_2709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2709_0: read-var CRm:u8
        let s_2709_0: u8 = fn_state.CRm;
        // D s_2709_1: cast zx s_2709_0 -> bv
        let s_2709_1: Bits = Bits::new(s_2709_0 as u128, 4u16);
        // C s_2709_2: const #14u : u8
        let s_2709_2: u8 = 14;
        // C s_2709_3: cast zx s_2709_2 -> bv
        let s_2709_3: Bits = Bits::new(s_2709_2 as u128, 4u16);
        // D s_2709_4: cmp-eq s_2709_1 s_2709_3
        let s_2709_4: bool = ((s_2709_1) == (s_2709_3));
        // N s_2709_5: branch s_2709_4 b4165 b2710
        if s_2709_4 {
            return block_4165(state, tracer, fn_state);
        } else {
            return block_2710(state, tracer, fn_state);
        };
    }
    fn block_2710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2710_0: const #0u : u8
        let s_2710_0: bool = false;
        // D s_2710_1: write-var gs#118752 <= s_2710_0
        fn_state.gs_118752 = s_2710_0;
        // N s_2710_2: jump b2711
        return block_2711(state, tracer, fn_state);
    }
    fn block_2711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2711_0: read-var gs#118752:u8
        let s_2711_0: bool = fn_state.gs_118752;
        // N s_2711_1: branch s_2711_0 b4164 b2712
        if s_2711_0 {
            return block_4164(state, tracer, fn_state);
        } else {
            return block_2712(state, tracer, fn_state);
        };
    }
    fn block_2712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2712_0: const #0u : u8
        let s_2712_0: bool = false;
        // D s_2712_1: write-var gs#118753 <= s_2712_0
        fn_state.gs_118753 = s_2712_0;
        // N s_2712_2: jump b2713
        return block_2713(state, tracer, fn_state);
    }
    fn block_2713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2713_0: read-var gs#118753:u8
        let s_2713_0: bool = fn_state.gs_118753;
        // N s_2713_1: branch s_2713_0 b4163 b2714
        if s_2713_0 {
            return block_4163(state, tracer, fn_state);
        } else {
            return block_2714(state, tracer, fn_state);
        };
    }
    fn block_2714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2714_0: const #0u : u8
        let s_2714_0: bool = false;
        // D s_2714_1: write-var gs#118754 <= s_2714_0
        fn_state.gs_118754 = s_2714_0;
        // N s_2714_2: jump b2715
        return block_2715(state, tracer, fn_state);
    }
    fn block_2715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2715_0: read-var gs#118754:u8
        let s_2715_0: bool = fn_state.gs_118754;
        // N s_2715_1: branch s_2715_0 b4162 b2716
        if s_2715_0 {
            return block_4162(state, tracer, fn_state);
        } else {
            return block_2716(state, tracer, fn_state);
        };
    }
    fn block_2716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2716_0: const #0u : u8
        let s_2716_0: bool = false;
        // D s_2716_1: write-var gs#118755 <= s_2716_0
        fn_state.gs_118755 = s_2716_0;
        // N s_2716_2: jump b2717
        return block_2717(state, tracer, fn_state);
    }
    fn block_2717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2717_0: read-var gs#118755:u8
        let s_2717_0: bool = fn_state.gs_118755;
        // N s_2717_1: branch s_2717_0 b4161 b2718
        if s_2717_0 {
            return block_4161(state, tracer, fn_state);
        } else {
            return block_2718(state, tracer, fn_state);
        };
    }
    fn block_2718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2718_0: read-var CRm:u8
        let s_2718_0: u8 = fn_state.CRm;
        // D s_2718_1: cast zx s_2718_0 -> bv
        let s_2718_1: Bits = Bits::new(s_2718_0 as u128, 4u16);
        // C s_2718_2: const #14u : u8
        let s_2718_2: u8 = 14;
        // C s_2718_3: cast zx s_2718_2 -> bv
        let s_2718_3: Bits = Bits::new(s_2718_2 as u128, 4u16);
        // D s_2718_4: cmp-eq s_2718_1 s_2718_3
        let s_2718_4: bool = ((s_2718_1) == (s_2718_3));
        // N s_2718_5: branch s_2718_4 b4160 b2719
        if s_2718_4 {
            return block_4160(state, tracer, fn_state);
        } else {
            return block_2719(state, tracer, fn_state);
        };
    }
    fn block_2719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2719_0: const #0u : u8
        let s_2719_0: bool = false;
        // D s_2719_1: write-var gs#118756 <= s_2719_0
        fn_state.gs_118756 = s_2719_0;
        // N s_2719_2: jump b2720
        return block_2720(state, tracer, fn_state);
    }
    fn block_2720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2720_0: read-var gs#118756:u8
        let s_2720_0: bool = fn_state.gs_118756;
        // N s_2720_1: branch s_2720_0 b4159 b2721
        if s_2720_0 {
            return block_4159(state, tracer, fn_state);
        } else {
            return block_2721(state, tracer, fn_state);
        };
    }
    fn block_2721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2721_0: const #0u : u8
        let s_2721_0: bool = false;
        // D s_2721_1: write-var gs#118757 <= s_2721_0
        fn_state.gs_118757 = s_2721_0;
        // N s_2721_2: jump b2722
        return block_2722(state, tracer, fn_state);
    }
    fn block_2722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2722_0: read-var gs#118757:u8
        let s_2722_0: bool = fn_state.gs_118757;
        // N s_2722_1: branch s_2722_0 b4158 b2723
        if s_2722_0 {
            return block_4158(state, tracer, fn_state);
        } else {
            return block_2723(state, tracer, fn_state);
        };
    }
    fn block_2723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2723_0: const #0u : u8
        let s_2723_0: bool = false;
        // D s_2723_1: write-var gs#118758 <= s_2723_0
        fn_state.gs_118758 = s_2723_0;
        // N s_2723_2: jump b2724
        return block_2724(state, tracer, fn_state);
    }
    fn block_2724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2724_0: read-var gs#118758:u8
        let s_2724_0: bool = fn_state.gs_118758;
        // N s_2724_1: branch s_2724_0 b4157 b2725
        if s_2724_0 {
            return block_4157(state, tracer, fn_state);
        } else {
            return block_2725(state, tracer, fn_state);
        };
    }
    fn block_2725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2725_0: const #0u : u8
        let s_2725_0: bool = false;
        // D s_2725_1: write-var gs#118759 <= s_2725_0
        fn_state.gs_118759 = s_2725_0;
        // N s_2725_2: jump b2726
        return block_2726(state, tracer, fn_state);
    }
    fn block_2726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2726_0: read-var gs#118759:u8
        let s_2726_0: bool = fn_state.gs_118759;
        // N s_2726_1: branch s_2726_0 b4156 b2727
        if s_2726_0 {
            return block_4156(state, tracer, fn_state);
        } else {
            return block_2727(state, tracer, fn_state);
        };
    }
    fn block_2727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2727_0: read-var CRm:u8
        let s_2727_0: u8 = fn_state.CRm;
        // D s_2727_1: cast zx s_2727_0 -> bv
        let s_2727_1: Bits = Bits::new(s_2727_0 as u128, 4u16);
        // C s_2727_2: const #14u : u8
        let s_2727_2: u8 = 14;
        // C s_2727_3: cast zx s_2727_2 -> bv
        let s_2727_3: Bits = Bits::new(s_2727_2 as u128, 4u16);
        // D s_2727_4: cmp-eq s_2727_1 s_2727_3
        let s_2727_4: bool = ((s_2727_1) == (s_2727_3));
        // N s_2727_5: branch s_2727_4 b4155 b2728
        if s_2727_4 {
            return block_4155(state, tracer, fn_state);
        } else {
            return block_2728(state, tracer, fn_state);
        };
    }
    fn block_2728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2728_0: const #0u : u8
        let s_2728_0: bool = false;
        // D s_2728_1: write-var gs#118760 <= s_2728_0
        fn_state.gs_118760 = s_2728_0;
        // N s_2728_2: jump b2729
        return block_2729(state, tracer, fn_state);
    }
    fn block_2729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2729_0: read-var gs#118760:u8
        let s_2729_0: bool = fn_state.gs_118760;
        // N s_2729_1: branch s_2729_0 b4154 b2730
        if s_2729_0 {
            return block_4154(state, tracer, fn_state);
        } else {
            return block_2730(state, tracer, fn_state);
        };
    }
    fn block_2730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2730_0: const #0u : u8
        let s_2730_0: bool = false;
        // D s_2730_1: write-var gs#118761 <= s_2730_0
        fn_state.gs_118761 = s_2730_0;
        // N s_2730_2: jump b2731
        return block_2731(state, tracer, fn_state);
    }
    fn block_2731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2731_0: read-var gs#118761:u8
        let s_2731_0: bool = fn_state.gs_118761;
        // N s_2731_1: branch s_2731_0 b4153 b2732
        if s_2731_0 {
            return block_4153(state, tracer, fn_state);
        } else {
            return block_2732(state, tracer, fn_state);
        };
    }
    fn block_2732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2732_0: const #0u : u8
        let s_2732_0: bool = false;
        // D s_2732_1: write-var gs#118762 <= s_2732_0
        fn_state.gs_118762 = s_2732_0;
        // N s_2732_2: jump b2733
        return block_2733(state, tracer, fn_state);
    }
    fn block_2733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2733_0: read-var gs#118762:u8
        let s_2733_0: bool = fn_state.gs_118762;
        // N s_2733_1: branch s_2733_0 b4152 b2734
        if s_2733_0 {
            return block_4152(state, tracer, fn_state);
        } else {
            return block_2734(state, tracer, fn_state);
        };
    }
    fn block_2734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2734_0: const #0u : u8
        let s_2734_0: bool = false;
        // D s_2734_1: write-var gs#118763 <= s_2734_0
        fn_state.gs_118763 = s_2734_0;
        // N s_2734_2: jump b2735
        return block_2735(state, tracer, fn_state);
    }
    fn block_2735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2735_0: read-var gs#118763:u8
        let s_2735_0: bool = fn_state.gs_118763;
        // N s_2735_1: branch s_2735_0 b4151 b2736
        if s_2735_0 {
            return block_4151(state, tracer, fn_state);
        } else {
            return block_2736(state, tracer, fn_state);
        };
    }
    fn block_2736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2736_0: read-var CRm:u8
        let s_2736_0: u8 = fn_state.CRm;
        // D s_2736_1: cast zx s_2736_0 -> bv
        let s_2736_1: Bits = Bits::new(s_2736_0 as u128, 4u16);
        // C s_2736_2: const #14u : u8
        let s_2736_2: u8 = 14;
        // C s_2736_3: cast zx s_2736_2 -> bv
        let s_2736_3: Bits = Bits::new(s_2736_2 as u128, 4u16);
        // D s_2736_4: cmp-eq s_2736_1 s_2736_3
        let s_2736_4: bool = ((s_2736_1) == (s_2736_3));
        // N s_2736_5: branch s_2736_4 b4150 b2737
        if s_2736_4 {
            return block_4150(state, tracer, fn_state);
        } else {
            return block_2737(state, tracer, fn_state);
        };
    }
    fn block_2737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2737_0: const #0u : u8
        let s_2737_0: bool = false;
        // D s_2737_1: write-var gs#118764 <= s_2737_0
        fn_state.gs_118764 = s_2737_0;
        // N s_2737_2: jump b2738
        return block_2738(state, tracer, fn_state);
    }
    fn block_2738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2738_0: read-var gs#118764:u8
        let s_2738_0: bool = fn_state.gs_118764;
        // N s_2738_1: branch s_2738_0 b4149 b2739
        if s_2738_0 {
            return block_4149(state, tracer, fn_state);
        } else {
            return block_2739(state, tracer, fn_state);
        };
    }
    fn block_2739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2739_0: const #0u : u8
        let s_2739_0: bool = false;
        // D s_2739_1: write-var gs#118765 <= s_2739_0
        fn_state.gs_118765 = s_2739_0;
        // N s_2739_2: jump b2740
        return block_2740(state, tracer, fn_state);
    }
    fn block_2740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2740_0: read-var gs#118765:u8
        let s_2740_0: bool = fn_state.gs_118765;
        // N s_2740_1: branch s_2740_0 b4148 b2741
        if s_2740_0 {
            return block_4148(state, tracer, fn_state);
        } else {
            return block_2741(state, tracer, fn_state);
        };
    }
    fn block_2741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2741_0: const #0u : u8
        let s_2741_0: bool = false;
        // D s_2741_1: write-var gs#118766 <= s_2741_0
        fn_state.gs_118766 = s_2741_0;
        // N s_2741_2: jump b2742
        return block_2742(state, tracer, fn_state);
    }
    fn block_2742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2742_0: read-var gs#118766:u8
        let s_2742_0: bool = fn_state.gs_118766;
        // N s_2742_1: branch s_2742_0 b4147 b2743
        if s_2742_0 {
            return block_4147(state, tracer, fn_state);
        } else {
            return block_2743(state, tracer, fn_state);
        };
    }
    fn block_2743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2743_0: const #0u : u8
        let s_2743_0: bool = false;
        // D s_2743_1: write-var gs#118767 <= s_2743_0
        fn_state.gs_118767 = s_2743_0;
        // N s_2743_2: jump b2744
        return block_2744(state, tracer, fn_state);
    }
    fn block_2744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2744_0: read-var gs#118767:u8
        let s_2744_0: bool = fn_state.gs_118767;
        // N s_2744_1: branch s_2744_0 b4146 b2745
        if s_2744_0 {
            return block_4146(state, tracer, fn_state);
        } else {
            return block_2745(state, tracer, fn_state);
        };
    }
    fn block_2745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2745_0: read-var CRm:u8
        let s_2745_0: u8 = fn_state.CRm;
        // D s_2745_1: cast zx s_2745_0 -> bv
        let s_2745_1: Bits = Bits::new(s_2745_0 as u128, 4u16);
        // C s_2745_2: const #14u : u8
        let s_2745_2: u8 = 14;
        // C s_2745_3: cast zx s_2745_2 -> bv
        let s_2745_3: Bits = Bits::new(s_2745_2 as u128, 4u16);
        // D s_2745_4: cmp-eq s_2745_1 s_2745_3
        let s_2745_4: bool = ((s_2745_1) == (s_2745_3));
        // N s_2745_5: branch s_2745_4 b4145 b2746
        if s_2745_4 {
            return block_4145(state, tracer, fn_state);
        } else {
            return block_2746(state, tracer, fn_state);
        };
    }
    fn block_2746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2746_0: const #0u : u8
        let s_2746_0: bool = false;
        // D s_2746_1: write-var gs#118768 <= s_2746_0
        fn_state.gs_118768 = s_2746_0;
        // N s_2746_2: jump b2747
        return block_2747(state, tracer, fn_state);
    }
    fn block_2747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2747_0: read-var gs#118768:u8
        let s_2747_0: bool = fn_state.gs_118768;
        // N s_2747_1: branch s_2747_0 b4144 b2748
        if s_2747_0 {
            return block_4144(state, tracer, fn_state);
        } else {
            return block_2748(state, tracer, fn_state);
        };
    }
    fn block_2748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2748_0: const #0u : u8
        let s_2748_0: bool = false;
        // D s_2748_1: write-var gs#118769 <= s_2748_0
        fn_state.gs_118769 = s_2748_0;
        // N s_2748_2: jump b2749
        return block_2749(state, tracer, fn_state);
    }
    fn block_2749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2749_0: read-var gs#118769:u8
        let s_2749_0: bool = fn_state.gs_118769;
        // N s_2749_1: branch s_2749_0 b4143 b2750
        if s_2749_0 {
            return block_4143(state, tracer, fn_state);
        } else {
            return block_2750(state, tracer, fn_state);
        };
    }
    fn block_2750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2750_0: const #0u : u8
        let s_2750_0: bool = false;
        // D s_2750_1: write-var gs#118770 <= s_2750_0
        fn_state.gs_118770 = s_2750_0;
        // N s_2750_2: jump b2751
        return block_2751(state, tracer, fn_state);
    }
    fn block_2751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2751_0: read-var gs#118770:u8
        let s_2751_0: bool = fn_state.gs_118770;
        // N s_2751_1: branch s_2751_0 b4142 b2752
        if s_2751_0 {
            return block_4142(state, tracer, fn_state);
        } else {
            return block_2752(state, tracer, fn_state);
        };
    }
    fn block_2752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2752_0: const #0u : u8
        let s_2752_0: bool = false;
        // D s_2752_1: write-var gs#118771 <= s_2752_0
        fn_state.gs_118771 = s_2752_0;
        // N s_2752_2: jump b2753
        return block_2753(state, tracer, fn_state);
    }
    fn block_2753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2753_0: read-var gs#118771:u8
        let s_2753_0: bool = fn_state.gs_118771;
        // N s_2753_1: branch s_2753_0 b4141 b2754
        if s_2753_0 {
            return block_4141(state, tracer, fn_state);
        } else {
            return block_2754(state, tracer, fn_state);
        };
    }
    fn block_2754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2754_0: read-var CRm:u8
        let s_2754_0: u8 = fn_state.CRm;
        // D s_2754_1: cast zx s_2754_0 -> bv
        let s_2754_1: Bits = Bits::new(s_2754_0 as u128, 4u16);
        // C s_2754_2: const #14u : u8
        let s_2754_2: u8 = 14;
        // C s_2754_3: cast zx s_2754_2 -> bv
        let s_2754_3: Bits = Bits::new(s_2754_2 as u128, 4u16);
        // D s_2754_4: cmp-eq s_2754_1 s_2754_3
        let s_2754_4: bool = ((s_2754_1) == (s_2754_3));
        // N s_2754_5: branch s_2754_4 b4140 b2755
        if s_2754_4 {
            return block_4140(state, tracer, fn_state);
        } else {
            return block_2755(state, tracer, fn_state);
        };
    }
    fn block_2755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2755_0: const #0u : u8
        let s_2755_0: bool = false;
        // D s_2755_1: write-var gs#118772 <= s_2755_0
        fn_state.gs_118772 = s_2755_0;
        // N s_2755_2: jump b2756
        return block_2756(state, tracer, fn_state);
    }
    fn block_2756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2756_0: read-var gs#118772:u8
        let s_2756_0: bool = fn_state.gs_118772;
        // N s_2756_1: branch s_2756_0 b4139 b2757
        if s_2756_0 {
            return block_4139(state, tracer, fn_state);
        } else {
            return block_2757(state, tracer, fn_state);
        };
    }
    fn block_2757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2757_0: const #0u : u8
        let s_2757_0: bool = false;
        // D s_2757_1: write-var gs#118773 <= s_2757_0
        fn_state.gs_118773 = s_2757_0;
        // N s_2757_2: jump b2758
        return block_2758(state, tracer, fn_state);
    }
    fn block_2758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2758_0: read-var gs#118773:u8
        let s_2758_0: bool = fn_state.gs_118773;
        // N s_2758_1: branch s_2758_0 b4138 b2759
        if s_2758_0 {
            return block_4138(state, tracer, fn_state);
        } else {
            return block_2759(state, tracer, fn_state);
        };
    }
    fn block_2759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2759_0: const #0u : u8
        let s_2759_0: bool = false;
        // D s_2759_1: write-var gs#118774 <= s_2759_0
        fn_state.gs_118774 = s_2759_0;
        // N s_2759_2: jump b2760
        return block_2760(state, tracer, fn_state);
    }
    fn block_2760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2760_0: read-var gs#118774:u8
        let s_2760_0: bool = fn_state.gs_118774;
        // N s_2760_1: branch s_2760_0 b4137 b2761
        if s_2760_0 {
            return block_4137(state, tracer, fn_state);
        } else {
            return block_2761(state, tracer, fn_state);
        };
    }
    fn block_2761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2761_0: const #0u : u8
        let s_2761_0: bool = false;
        // D s_2761_1: write-var gs#118775 <= s_2761_0
        fn_state.gs_118775 = s_2761_0;
        // N s_2761_2: jump b2762
        return block_2762(state, tracer, fn_state);
    }
    fn block_2762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2762_0: read-var gs#118775:u8
        let s_2762_0: bool = fn_state.gs_118775;
        // N s_2762_1: branch s_2762_0 b4136 b2763
        if s_2762_0 {
            return block_4136(state, tracer, fn_state);
        } else {
            return block_2763(state, tracer, fn_state);
        };
    }
    fn block_2763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2763_0: read-var CRm:u8
        let s_2763_0: u8 = fn_state.CRm;
        // D s_2763_1: cast zx s_2763_0 -> bv
        let s_2763_1: Bits = Bits::new(s_2763_0 as u128, 4u16);
        // C s_2763_2: const #14u : u8
        let s_2763_2: u8 = 14;
        // C s_2763_3: cast zx s_2763_2 -> bv
        let s_2763_3: Bits = Bits::new(s_2763_2 as u128, 4u16);
        // D s_2763_4: cmp-eq s_2763_1 s_2763_3
        let s_2763_4: bool = ((s_2763_1) == (s_2763_3));
        // N s_2763_5: branch s_2763_4 b4135 b2764
        if s_2763_4 {
            return block_4135(state, tracer, fn_state);
        } else {
            return block_2764(state, tracer, fn_state);
        };
    }
    fn block_2764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2764_0: const #0u : u8
        let s_2764_0: bool = false;
        // D s_2764_1: write-var gs#118776 <= s_2764_0
        fn_state.gs_118776 = s_2764_0;
        // N s_2764_2: jump b2765
        return block_2765(state, tracer, fn_state);
    }
    fn block_2765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2765_0: read-var gs#118776:u8
        let s_2765_0: bool = fn_state.gs_118776;
        // N s_2765_1: branch s_2765_0 b4134 b2766
        if s_2765_0 {
            return block_4134(state, tracer, fn_state);
        } else {
            return block_2766(state, tracer, fn_state);
        };
    }
    fn block_2766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2766_0: const #0u : u8
        let s_2766_0: bool = false;
        // D s_2766_1: write-var gs#118777 <= s_2766_0
        fn_state.gs_118777 = s_2766_0;
        // N s_2766_2: jump b2767
        return block_2767(state, tracer, fn_state);
    }
    fn block_2767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2767_0: read-var gs#118777:u8
        let s_2767_0: bool = fn_state.gs_118777;
        // N s_2767_1: branch s_2767_0 b4133 b2768
        if s_2767_0 {
            return block_4133(state, tracer, fn_state);
        } else {
            return block_2768(state, tracer, fn_state);
        };
    }
    fn block_2768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2768_0: const #0u : u8
        let s_2768_0: bool = false;
        // D s_2768_1: write-var gs#118778 <= s_2768_0
        fn_state.gs_118778 = s_2768_0;
        // N s_2768_2: jump b2769
        return block_2769(state, tracer, fn_state);
    }
    fn block_2769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2769_0: read-var gs#118778:u8
        let s_2769_0: bool = fn_state.gs_118778;
        // N s_2769_1: branch s_2769_0 b4132 b2770
        if s_2769_0 {
            return block_4132(state, tracer, fn_state);
        } else {
            return block_2770(state, tracer, fn_state);
        };
    }
    fn block_2770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2770_0: const #0u : u8
        let s_2770_0: bool = false;
        // D s_2770_1: write-var gs#118779 <= s_2770_0
        fn_state.gs_118779 = s_2770_0;
        // N s_2770_2: jump b2771
        return block_2771(state, tracer, fn_state);
    }
    fn block_2771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2771_0: read-var gs#118779:u8
        let s_2771_0: bool = fn_state.gs_118779;
        // N s_2771_1: branch s_2771_0 b4131 b2772
        if s_2771_0 {
            return block_4131(state, tracer, fn_state);
        } else {
            return block_2772(state, tracer, fn_state);
        };
    }
    fn block_2772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2772_0: read-var CRm:u8
        let s_2772_0: u8 = fn_state.CRm;
        // D s_2772_1: cast zx s_2772_0 -> bv
        let s_2772_1: Bits = Bits::new(s_2772_0 as u128, 4u16);
        // C s_2772_2: const #13u : u8
        let s_2772_2: u8 = 13;
        // C s_2772_3: cast zx s_2772_2 -> bv
        let s_2772_3: Bits = Bits::new(s_2772_2 as u128, 4u16);
        // D s_2772_4: cmp-eq s_2772_1 s_2772_3
        let s_2772_4: bool = ((s_2772_1) == (s_2772_3));
        // N s_2772_5: branch s_2772_4 b4130 b2773
        if s_2772_4 {
            return block_4130(state, tracer, fn_state);
        } else {
            return block_2773(state, tracer, fn_state);
        };
    }
    fn block_2773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2773_0: const #0u : u8
        let s_2773_0: bool = false;
        // D s_2773_1: write-var gs#118780 <= s_2773_0
        fn_state.gs_118780 = s_2773_0;
        // N s_2773_2: jump b2774
        return block_2774(state, tracer, fn_state);
    }
    fn block_2774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2774_0: read-var gs#118780:u8
        let s_2774_0: bool = fn_state.gs_118780;
        // N s_2774_1: branch s_2774_0 b4129 b2775
        if s_2774_0 {
            return block_4129(state, tracer, fn_state);
        } else {
            return block_2775(state, tracer, fn_state);
        };
    }
    fn block_2775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2775_0: const #0u : u8
        let s_2775_0: bool = false;
        // D s_2775_1: write-var gs#118781 <= s_2775_0
        fn_state.gs_118781 = s_2775_0;
        // N s_2775_2: jump b2776
        return block_2776(state, tracer, fn_state);
    }
    fn block_2776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2776_0: read-var gs#118781:u8
        let s_2776_0: bool = fn_state.gs_118781;
        // N s_2776_1: branch s_2776_0 b4128 b2777
        if s_2776_0 {
            return block_4128(state, tracer, fn_state);
        } else {
            return block_2777(state, tracer, fn_state);
        };
    }
    fn block_2777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2777_0: const #0u : u8
        let s_2777_0: bool = false;
        // D s_2777_1: write-var gs#118782 <= s_2777_0
        fn_state.gs_118782 = s_2777_0;
        // N s_2777_2: jump b2778
        return block_2778(state, tracer, fn_state);
    }
    fn block_2778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2778_0: read-var gs#118782:u8
        let s_2778_0: bool = fn_state.gs_118782;
        // N s_2778_1: branch s_2778_0 b4127 b2779
        if s_2778_0 {
            return block_4127(state, tracer, fn_state);
        } else {
            return block_2779(state, tracer, fn_state);
        };
    }
    fn block_2779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2779_0: const #0u : u8
        let s_2779_0: bool = false;
        // D s_2779_1: write-var gs#118783 <= s_2779_0
        fn_state.gs_118783 = s_2779_0;
        // N s_2779_2: jump b2780
        return block_2780(state, tracer, fn_state);
    }
    fn block_2780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2780_0: read-var gs#118783:u8
        let s_2780_0: bool = fn_state.gs_118783;
        // N s_2780_1: branch s_2780_0 b4126 b2781
        if s_2780_0 {
            return block_4126(state, tracer, fn_state);
        } else {
            return block_2781(state, tracer, fn_state);
        };
    }
    fn block_2781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2781_0: read-var CRm:u8
        let s_2781_0: u8 = fn_state.CRm;
        // D s_2781_1: cast zx s_2781_0 -> bv
        let s_2781_1: Bits = Bits::new(s_2781_0 as u128, 4u16);
        // C s_2781_2: const #13u : u8
        let s_2781_2: u8 = 13;
        // C s_2781_3: cast zx s_2781_2 -> bv
        let s_2781_3: Bits = Bits::new(s_2781_2 as u128, 4u16);
        // D s_2781_4: cmp-eq s_2781_1 s_2781_3
        let s_2781_4: bool = ((s_2781_1) == (s_2781_3));
        // N s_2781_5: branch s_2781_4 b4125 b2782
        if s_2781_4 {
            return block_4125(state, tracer, fn_state);
        } else {
            return block_2782(state, tracer, fn_state);
        };
    }
    fn block_2782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2782_0: const #0u : u8
        let s_2782_0: bool = false;
        // D s_2782_1: write-var gs#118784 <= s_2782_0
        fn_state.gs_118784 = s_2782_0;
        // N s_2782_2: jump b2783
        return block_2783(state, tracer, fn_state);
    }
    fn block_2783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2783_0: read-var gs#118784:u8
        let s_2783_0: bool = fn_state.gs_118784;
        // N s_2783_1: branch s_2783_0 b4124 b2784
        if s_2783_0 {
            return block_4124(state, tracer, fn_state);
        } else {
            return block_2784(state, tracer, fn_state);
        };
    }
    fn block_2784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2784_0: const #0u : u8
        let s_2784_0: bool = false;
        // D s_2784_1: write-var gs#118785 <= s_2784_0
        fn_state.gs_118785 = s_2784_0;
        // N s_2784_2: jump b2785
        return block_2785(state, tracer, fn_state);
    }
    fn block_2785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2785_0: read-var gs#118785:u8
        let s_2785_0: bool = fn_state.gs_118785;
        // N s_2785_1: branch s_2785_0 b4123 b2786
        if s_2785_0 {
            return block_4123(state, tracer, fn_state);
        } else {
            return block_2786(state, tracer, fn_state);
        };
    }
    fn block_2786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2786_0: const #0u : u8
        let s_2786_0: bool = false;
        // D s_2786_1: write-var gs#118786 <= s_2786_0
        fn_state.gs_118786 = s_2786_0;
        // N s_2786_2: jump b2787
        return block_2787(state, tracer, fn_state);
    }
    fn block_2787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2787_0: read-var gs#118786:u8
        let s_2787_0: bool = fn_state.gs_118786;
        // N s_2787_1: branch s_2787_0 b4122 b2788
        if s_2787_0 {
            return block_4122(state, tracer, fn_state);
        } else {
            return block_2788(state, tracer, fn_state);
        };
    }
    fn block_2788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2788_0: const #0u : u8
        let s_2788_0: bool = false;
        // D s_2788_1: write-var gs#118787 <= s_2788_0
        fn_state.gs_118787 = s_2788_0;
        // N s_2788_2: jump b2789
        return block_2789(state, tracer, fn_state);
    }
    fn block_2789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2789_0: read-var gs#118787:u8
        let s_2789_0: bool = fn_state.gs_118787;
        // N s_2789_1: branch s_2789_0 b4121 b2790
        if s_2789_0 {
            return block_4121(state, tracer, fn_state);
        } else {
            return block_2790(state, tracer, fn_state);
        };
    }
    fn block_2790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2790_0: read-var CRm:u8
        let s_2790_0: u8 = fn_state.CRm;
        // D s_2790_1: cast zx s_2790_0 -> bv
        let s_2790_1: Bits = Bits::new(s_2790_0 as u128, 4u16);
        // C s_2790_2: const #13u : u8
        let s_2790_2: u8 = 13;
        // C s_2790_3: cast zx s_2790_2 -> bv
        let s_2790_3: Bits = Bits::new(s_2790_2 as u128, 4u16);
        // D s_2790_4: cmp-eq s_2790_1 s_2790_3
        let s_2790_4: bool = ((s_2790_1) == (s_2790_3));
        // N s_2790_5: branch s_2790_4 b4120 b2791
        if s_2790_4 {
            return block_4120(state, tracer, fn_state);
        } else {
            return block_2791(state, tracer, fn_state);
        };
    }
    fn block_2791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2791_0: const #0u : u8
        let s_2791_0: bool = false;
        // D s_2791_1: write-var gs#118788 <= s_2791_0
        fn_state.gs_118788 = s_2791_0;
        // N s_2791_2: jump b2792
        return block_2792(state, tracer, fn_state);
    }
    fn block_2792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2792_0: read-var gs#118788:u8
        let s_2792_0: bool = fn_state.gs_118788;
        // N s_2792_1: branch s_2792_0 b4119 b2793
        if s_2792_0 {
            return block_4119(state, tracer, fn_state);
        } else {
            return block_2793(state, tracer, fn_state);
        };
    }
    fn block_2793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2793_0: const #0u : u8
        let s_2793_0: bool = false;
        // D s_2793_1: write-var gs#118789 <= s_2793_0
        fn_state.gs_118789 = s_2793_0;
        // N s_2793_2: jump b2794
        return block_2794(state, tracer, fn_state);
    }
    fn block_2794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2794_0: read-var gs#118789:u8
        let s_2794_0: bool = fn_state.gs_118789;
        // N s_2794_1: branch s_2794_0 b4118 b2795
        if s_2794_0 {
            return block_4118(state, tracer, fn_state);
        } else {
            return block_2795(state, tracer, fn_state);
        };
    }
    fn block_2795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2795_0: const #0u : u8
        let s_2795_0: bool = false;
        // D s_2795_1: write-var gs#118790 <= s_2795_0
        fn_state.gs_118790 = s_2795_0;
        // N s_2795_2: jump b2796
        return block_2796(state, tracer, fn_state);
    }
    fn block_2796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2796_0: read-var gs#118790:u8
        let s_2796_0: bool = fn_state.gs_118790;
        // N s_2796_1: branch s_2796_0 b4117 b2797
        if s_2796_0 {
            return block_4117(state, tracer, fn_state);
        } else {
            return block_2797(state, tracer, fn_state);
        };
    }
    fn block_2797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2797_0: const #0u : u8
        let s_2797_0: bool = false;
        // D s_2797_1: write-var gs#118791 <= s_2797_0
        fn_state.gs_118791 = s_2797_0;
        // N s_2797_2: jump b2798
        return block_2798(state, tracer, fn_state);
    }
    fn block_2798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2798_0: read-var gs#118791:u8
        let s_2798_0: bool = fn_state.gs_118791;
        // N s_2798_1: branch s_2798_0 b4116 b2799
        if s_2798_0 {
            return block_4116(state, tracer, fn_state);
        } else {
            return block_2799(state, tracer, fn_state);
        };
    }
    fn block_2799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2799_0: read-var CRm:u8
        let s_2799_0: u8 = fn_state.CRm;
        // D s_2799_1: cast zx s_2799_0 -> bv
        let s_2799_1: Bits = Bits::new(s_2799_0 as u128, 4u16);
        // C s_2799_2: const #13u : u8
        let s_2799_2: u8 = 13;
        // C s_2799_3: cast zx s_2799_2 -> bv
        let s_2799_3: Bits = Bits::new(s_2799_2 as u128, 4u16);
        // D s_2799_4: cmp-eq s_2799_1 s_2799_3
        let s_2799_4: bool = ((s_2799_1) == (s_2799_3));
        // N s_2799_5: branch s_2799_4 b4115 b2800
        if s_2799_4 {
            return block_4115(state, tracer, fn_state);
        } else {
            return block_2800(state, tracer, fn_state);
        };
    }
    fn block_2800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2800_0: const #0u : u8
        let s_2800_0: bool = false;
        // D s_2800_1: write-var gs#118792 <= s_2800_0
        fn_state.gs_118792 = s_2800_0;
        // N s_2800_2: jump b2801
        return block_2801(state, tracer, fn_state);
    }
    fn block_2801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2801_0: read-var gs#118792:u8
        let s_2801_0: bool = fn_state.gs_118792;
        // N s_2801_1: branch s_2801_0 b4114 b2802
        if s_2801_0 {
            return block_4114(state, tracer, fn_state);
        } else {
            return block_2802(state, tracer, fn_state);
        };
    }
    fn block_2802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2802_0: const #0u : u8
        let s_2802_0: bool = false;
        // D s_2802_1: write-var gs#118793 <= s_2802_0
        fn_state.gs_118793 = s_2802_0;
        // N s_2802_2: jump b2803
        return block_2803(state, tracer, fn_state);
    }
    fn block_2803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2803_0: read-var gs#118793:u8
        let s_2803_0: bool = fn_state.gs_118793;
        // N s_2803_1: branch s_2803_0 b4113 b2804
        if s_2803_0 {
            return block_4113(state, tracer, fn_state);
        } else {
            return block_2804(state, tracer, fn_state);
        };
    }
    fn block_2804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2804_0: const #0u : u8
        let s_2804_0: bool = false;
        // D s_2804_1: write-var gs#118794 <= s_2804_0
        fn_state.gs_118794 = s_2804_0;
        // N s_2804_2: jump b2805
        return block_2805(state, tracer, fn_state);
    }
    fn block_2805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2805_0: read-var gs#118794:u8
        let s_2805_0: bool = fn_state.gs_118794;
        // N s_2805_1: branch s_2805_0 b4112 b2806
        if s_2805_0 {
            return block_4112(state, tracer, fn_state);
        } else {
            return block_2806(state, tracer, fn_state);
        };
    }
    fn block_2806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2806_0: const #0u : u8
        let s_2806_0: bool = false;
        // D s_2806_1: write-var gs#118795 <= s_2806_0
        fn_state.gs_118795 = s_2806_0;
        // N s_2806_2: jump b2807
        return block_2807(state, tracer, fn_state);
    }
    fn block_2807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2807_0: read-var gs#118795:u8
        let s_2807_0: bool = fn_state.gs_118795;
        // N s_2807_1: branch s_2807_0 b4111 b2808
        if s_2807_0 {
            return block_4111(state, tracer, fn_state);
        } else {
            return block_2808(state, tracer, fn_state);
        };
    }
    fn block_2808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2808_0: read-var CRm:u8
        let s_2808_0: u8 = fn_state.CRm;
        // D s_2808_1: cast zx s_2808_0 -> bv
        let s_2808_1: Bits = Bits::new(s_2808_0 as u128, 4u16);
        // C s_2808_2: const #13u : u8
        let s_2808_2: u8 = 13;
        // C s_2808_3: cast zx s_2808_2 -> bv
        let s_2808_3: Bits = Bits::new(s_2808_2 as u128, 4u16);
        // D s_2808_4: cmp-eq s_2808_1 s_2808_3
        let s_2808_4: bool = ((s_2808_1) == (s_2808_3));
        // N s_2808_5: branch s_2808_4 b4110 b2809
        if s_2808_4 {
            return block_4110(state, tracer, fn_state);
        } else {
            return block_2809(state, tracer, fn_state);
        };
    }
    fn block_2809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2809_0: const #0u : u8
        let s_2809_0: bool = false;
        // D s_2809_1: write-var gs#118796 <= s_2809_0
        fn_state.gs_118796 = s_2809_0;
        // N s_2809_2: jump b2810
        return block_2810(state, tracer, fn_state);
    }
    fn block_2810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2810_0: read-var gs#118796:u8
        let s_2810_0: bool = fn_state.gs_118796;
        // N s_2810_1: branch s_2810_0 b4109 b2811
        if s_2810_0 {
            return block_4109(state, tracer, fn_state);
        } else {
            return block_2811(state, tracer, fn_state);
        };
    }
    fn block_2811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2811_0: const #0u : u8
        let s_2811_0: bool = false;
        // D s_2811_1: write-var gs#118797 <= s_2811_0
        fn_state.gs_118797 = s_2811_0;
        // N s_2811_2: jump b2812
        return block_2812(state, tracer, fn_state);
    }
    fn block_2812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2812_0: read-var gs#118797:u8
        let s_2812_0: bool = fn_state.gs_118797;
        // N s_2812_1: branch s_2812_0 b4108 b2813
        if s_2812_0 {
            return block_4108(state, tracer, fn_state);
        } else {
            return block_2813(state, tracer, fn_state);
        };
    }
    fn block_2813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2813_0: const #0u : u8
        let s_2813_0: bool = false;
        // D s_2813_1: write-var gs#118798 <= s_2813_0
        fn_state.gs_118798 = s_2813_0;
        // N s_2813_2: jump b2814
        return block_2814(state, tracer, fn_state);
    }
    fn block_2814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2814_0: read-var gs#118798:u8
        let s_2814_0: bool = fn_state.gs_118798;
        // N s_2814_1: branch s_2814_0 b4107 b2815
        if s_2814_0 {
            return block_4107(state, tracer, fn_state);
        } else {
            return block_2815(state, tracer, fn_state);
        };
    }
    fn block_2815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2815_0: const #0u : u8
        let s_2815_0: bool = false;
        // D s_2815_1: write-var gs#118799 <= s_2815_0
        fn_state.gs_118799 = s_2815_0;
        // N s_2815_2: jump b2816
        return block_2816(state, tracer, fn_state);
    }
    fn block_2816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2816_0: read-var gs#118799:u8
        let s_2816_0: bool = fn_state.gs_118799;
        // N s_2816_1: branch s_2816_0 b4106 b2817
        if s_2816_0 {
            return block_4106(state, tracer, fn_state);
        } else {
            return block_2817(state, tracer, fn_state);
        };
    }
    fn block_2817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2817_0: read-var CRm:u8
        let s_2817_0: u8 = fn_state.CRm;
        // D s_2817_1: cast zx s_2817_0 -> bv
        let s_2817_1: Bits = Bits::new(s_2817_0 as u128, 4u16);
        // C s_2817_2: const #13u : u8
        let s_2817_2: u8 = 13;
        // C s_2817_3: cast zx s_2817_2 -> bv
        let s_2817_3: Bits = Bits::new(s_2817_2 as u128, 4u16);
        // D s_2817_4: cmp-eq s_2817_1 s_2817_3
        let s_2817_4: bool = ((s_2817_1) == (s_2817_3));
        // N s_2817_5: branch s_2817_4 b4105 b2818
        if s_2817_4 {
            return block_4105(state, tracer, fn_state);
        } else {
            return block_2818(state, tracer, fn_state);
        };
    }
    fn block_2818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2818_0: const #0u : u8
        let s_2818_0: bool = false;
        // D s_2818_1: write-var gs#118800 <= s_2818_0
        fn_state.gs_118800 = s_2818_0;
        // N s_2818_2: jump b2819
        return block_2819(state, tracer, fn_state);
    }
    fn block_2819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2819_0: read-var gs#118800:u8
        let s_2819_0: bool = fn_state.gs_118800;
        // N s_2819_1: branch s_2819_0 b4104 b2820
        if s_2819_0 {
            return block_4104(state, tracer, fn_state);
        } else {
            return block_2820(state, tracer, fn_state);
        };
    }
    fn block_2820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2820_0: const #0u : u8
        let s_2820_0: bool = false;
        // D s_2820_1: write-var gs#118801 <= s_2820_0
        fn_state.gs_118801 = s_2820_0;
        // N s_2820_2: jump b2821
        return block_2821(state, tracer, fn_state);
    }
    fn block_2821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2821_0: read-var gs#118801:u8
        let s_2821_0: bool = fn_state.gs_118801;
        // N s_2821_1: branch s_2821_0 b4103 b2822
        if s_2821_0 {
            return block_4103(state, tracer, fn_state);
        } else {
            return block_2822(state, tracer, fn_state);
        };
    }
    fn block_2822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2822_0: const #0u : u8
        let s_2822_0: bool = false;
        // D s_2822_1: write-var gs#118802 <= s_2822_0
        fn_state.gs_118802 = s_2822_0;
        // N s_2822_2: jump b2823
        return block_2823(state, tracer, fn_state);
    }
    fn block_2823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2823_0: read-var gs#118802:u8
        let s_2823_0: bool = fn_state.gs_118802;
        // N s_2823_1: branch s_2823_0 b4102 b2824
        if s_2823_0 {
            return block_4102(state, tracer, fn_state);
        } else {
            return block_2824(state, tracer, fn_state);
        };
    }
    fn block_2824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2824_0: const #0u : u8
        let s_2824_0: bool = false;
        // D s_2824_1: write-var gs#118803 <= s_2824_0
        fn_state.gs_118803 = s_2824_0;
        // N s_2824_2: jump b2825
        return block_2825(state, tracer, fn_state);
    }
    fn block_2825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2825_0: read-var gs#118803:u8
        let s_2825_0: bool = fn_state.gs_118803;
        // N s_2825_1: branch s_2825_0 b4101 b2826
        if s_2825_0 {
            return block_4101(state, tracer, fn_state);
        } else {
            return block_2826(state, tracer, fn_state);
        };
    }
    fn block_2826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2826_0: read-var CRm:u8
        let s_2826_0: u8 = fn_state.CRm;
        // D s_2826_1: cast zx s_2826_0 -> bv
        let s_2826_1: Bits = Bits::new(s_2826_0 as u128, 4u16);
        // C s_2826_2: const #13u : u8
        let s_2826_2: u8 = 13;
        // C s_2826_3: cast zx s_2826_2 -> bv
        let s_2826_3: Bits = Bits::new(s_2826_2 as u128, 4u16);
        // D s_2826_4: cmp-eq s_2826_1 s_2826_3
        let s_2826_4: bool = ((s_2826_1) == (s_2826_3));
        // N s_2826_5: branch s_2826_4 b4100 b2827
        if s_2826_4 {
            return block_4100(state, tracer, fn_state);
        } else {
            return block_2827(state, tracer, fn_state);
        };
    }
    fn block_2827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2827_0: const #0u : u8
        let s_2827_0: bool = false;
        // D s_2827_1: write-var gs#118804 <= s_2827_0
        fn_state.gs_118804 = s_2827_0;
        // N s_2827_2: jump b2828
        return block_2828(state, tracer, fn_state);
    }
    fn block_2828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2828_0: read-var gs#118804:u8
        let s_2828_0: bool = fn_state.gs_118804;
        // N s_2828_1: branch s_2828_0 b4099 b2829
        if s_2828_0 {
            return block_4099(state, tracer, fn_state);
        } else {
            return block_2829(state, tracer, fn_state);
        };
    }
    fn block_2829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2829_0: const #0u : u8
        let s_2829_0: bool = false;
        // D s_2829_1: write-var gs#118805 <= s_2829_0
        fn_state.gs_118805 = s_2829_0;
        // N s_2829_2: jump b2830
        return block_2830(state, tracer, fn_state);
    }
    fn block_2830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2830_0: read-var gs#118805:u8
        let s_2830_0: bool = fn_state.gs_118805;
        // N s_2830_1: branch s_2830_0 b4098 b2831
        if s_2830_0 {
            return block_4098(state, tracer, fn_state);
        } else {
            return block_2831(state, tracer, fn_state);
        };
    }
    fn block_2831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2831_0: const #0u : u8
        let s_2831_0: bool = false;
        // D s_2831_1: write-var gs#118806 <= s_2831_0
        fn_state.gs_118806 = s_2831_0;
        // N s_2831_2: jump b2832
        return block_2832(state, tracer, fn_state);
    }
    fn block_2832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2832_0: read-var gs#118806:u8
        let s_2832_0: bool = fn_state.gs_118806;
        // N s_2832_1: branch s_2832_0 b4097 b2833
        if s_2832_0 {
            return block_4097(state, tracer, fn_state);
        } else {
            return block_2833(state, tracer, fn_state);
        };
    }
    fn block_2833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2833_0: const #0u : u8
        let s_2833_0: bool = false;
        // D s_2833_1: write-var gs#118807 <= s_2833_0
        fn_state.gs_118807 = s_2833_0;
        // N s_2833_2: jump b2834
        return block_2834(state, tracer, fn_state);
    }
    fn block_2834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2834_0: read-var gs#118807:u8
        let s_2834_0: bool = fn_state.gs_118807;
        // N s_2834_1: branch s_2834_0 b4096 b2835
        if s_2834_0 {
            return block_4096(state, tracer, fn_state);
        } else {
            return block_2835(state, tracer, fn_state);
        };
    }
    fn block_2835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2835_0: read-var CRm:u8
        let s_2835_0: u8 = fn_state.CRm;
        // D s_2835_1: cast zx s_2835_0 -> bv
        let s_2835_1: Bits = Bits::new(s_2835_0 as u128, 4u16);
        // C s_2835_2: const #13u : u8
        let s_2835_2: u8 = 13;
        // C s_2835_3: cast zx s_2835_2 -> bv
        let s_2835_3: Bits = Bits::new(s_2835_2 as u128, 4u16);
        // D s_2835_4: cmp-eq s_2835_1 s_2835_3
        let s_2835_4: bool = ((s_2835_1) == (s_2835_3));
        // N s_2835_5: branch s_2835_4 b4095 b2836
        if s_2835_4 {
            return block_4095(state, tracer, fn_state);
        } else {
            return block_2836(state, tracer, fn_state);
        };
    }
    fn block_2836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2836_0: const #0u : u8
        let s_2836_0: bool = false;
        // D s_2836_1: write-var gs#118808 <= s_2836_0
        fn_state.gs_118808 = s_2836_0;
        // N s_2836_2: jump b2837
        return block_2837(state, tracer, fn_state);
    }
    fn block_2837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2837_0: read-var gs#118808:u8
        let s_2837_0: bool = fn_state.gs_118808;
        // N s_2837_1: branch s_2837_0 b4094 b2838
        if s_2837_0 {
            return block_4094(state, tracer, fn_state);
        } else {
            return block_2838(state, tracer, fn_state);
        };
    }
    fn block_2838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2838_0: const #0u : u8
        let s_2838_0: bool = false;
        // D s_2838_1: write-var gs#118809 <= s_2838_0
        fn_state.gs_118809 = s_2838_0;
        // N s_2838_2: jump b2839
        return block_2839(state, tracer, fn_state);
    }
    fn block_2839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2839_0: read-var gs#118809:u8
        let s_2839_0: bool = fn_state.gs_118809;
        // N s_2839_1: branch s_2839_0 b4093 b2840
        if s_2839_0 {
            return block_4093(state, tracer, fn_state);
        } else {
            return block_2840(state, tracer, fn_state);
        };
    }
    fn block_2840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2840_0: const #0u : u8
        let s_2840_0: bool = false;
        // D s_2840_1: write-var gs#118810 <= s_2840_0
        fn_state.gs_118810 = s_2840_0;
        // N s_2840_2: jump b2841
        return block_2841(state, tracer, fn_state);
    }
    fn block_2841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2841_0: read-var gs#118810:u8
        let s_2841_0: bool = fn_state.gs_118810;
        // N s_2841_1: branch s_2841_0 b4092 b2842
        if s_2841_0 {
            return block_4092(state, tracer, fn_state);
        } else {
            return block_2842(state, tracer, fn_state);
        };
    }
    fn block_2842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2842_0: const #0u : u8
        let s_2842_0: bool = false;
        // D s_2842_1: write-var gs#118811 <= s_2842_0
        fn_state.gs_118811 = s_2842_0;
        // N s_2842_2: jump b2843
        return block_2843(state, tracer, fn_state);
    }
    fn block_2843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2843_0: read-var gs#118811:u8
        let s_2843_0: bool = fn_state.gs_118811;
        // N s_2843_1: branch s_2843_0 b4091 b2844
        if s_2843_0 {
            return block_4091(state, tracer, fn_state);
        } else {
            return block_2844(state, tracer, fn_state);
        };
    }
    fn block_2844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2844_0: read-var CRm:u8
        let s_2844_0: u8 = fn_state.CRm;
        // D s_2844_1: cast zx s_2844_0 -> bv
        let s_2844_1: Bits = Bits::new(s_2844_0 as u128, 4u16);
        // C s_2844_2: const #12u : u8
        let s_2844_2: u8 = 12;
        // C s_2844_3: cast zx s_2844_2 -> bv
        let s_2844_3: Bits = Bits::new(s_2844_2 as u128, 4u16);
        // D s_2844_4: cmp-eq s_2844_1 s_2844_3
        let s_2844_4: bool = ((s_2844_1) == (s_2844_3));
        // N s_2844_5: branch s_2844_4 b4090 b2845
        if s_2844_4 {
            return block_4090(state, tracer, fn_state);
        } else {
            return block_2845(state, tracer, fn_state);
        };
    }
    fn block_2845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2845_0: const #0u : u8
        let s_2845_0: bool = false;
        // D s_2845_1: write-var gs#118812 <= s_2845_0
        fn_state.gs_118812 = s_2845_0;
        // N s_2845_2: jump b2846
        return block_2846(state, tracer, fn_state);
    }
    fn block_2846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2846_0: read-var gs#118812:u8
        let s_2846_0: bool = fn_state.gs_118812;
        // N s_2846_1: branch s_2846_0 b4089 b2847
        if s_2846_0 {
            return block_4089(state, tracer, fn_state);
        } else {
            return block_2847(state, tracer, fn_state);
        };
    }
    fn block_2847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2847_0: const #0u : u8
        let s_2847_0: bool = false;
        // D s_2847_1: write-var gs#118813 <= s_2847_0
        fn_state.gs_118813 = s_2847_0;
        // N s_2847_2: jump b2848
        return block_2848(state, tracer, fn_state);
    }
    fn block_2848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2848_0: read-var gs#118813:u8
        let s_2848_0: bool = fn_state.gs_118813;
        // N s_2848_1: branch s_2848_0 b4088 b2849
        if s_2848_0 {
            return block_4088(state, tracer, fn_state);
        } else {
            return block_2849(state, tracer, fn_state);
        };
    }
    fn block_2849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2849_0: const #0u : u8
        let s_2849_0: bool = false;
        // D s_2849_1: write-var gs#118814 <= s_2849_0
        fn_state.gs_118814 = s_2849_0;
        // N s_2849_2: jump b2850
        return block_2850(state, tracer, fn_state);
    }
    fn block_2850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2850_0: read-var gs#118814:u8
        let s_2850_0: bool = fn_state.gs_118814;
        // N s_2850_1: branch s_2850_0 b4087 b2851
        if s_2850_0 {
            return block_4087(state, tracer, fn_state);
        } else {
            return block_2851(state, tracer, fn_state);
        };
    }
    fn block_2851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2851_0: const #0u : u8
        let s_2851_0: bool = false;
        // D s_2851_1: write-var gs#118815 <= s_2851_0
        fn_state.gs_118815 = s_2851_0;
        // N s_2851_2: jump b2852
        return block_2852(state, tracer, fn_state);
    }
    fn block_2852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2852_0: read-var gs#118815:u8
        let s_2852_0: bool = fn_state.gs_118815;
        // N s_2852_1: branch s_2852_0 b4086 b2853
        if s_2852_0 {
            return block_4086(state, tracer, fn_state);
        } else {
            return block_2853(state, tracer, fn_state);
        };
    }
    fn block_2853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2853_0: read-var CRm:u8
        let s_2853_0: u8 = fn_state.CRm;
        // D s_2853_1: cast zx s_2853_0 -> bv
        let s_2853_1: Bits = Bits::new(s_2853_0 as u128, 4u16);
        // C s_2853_2: const #12u : u8
        let s_2853_2: u8 = 12;
        // C s_2853_3: cast zx s_2853_2 -> bv
        let s_2853_3: Bits = Bits::new(s_2853_2 as u128, 4u16);
        // D s_2853_4: cmp-eq s_2853_1 s_2853_3
        let s_2853_4: bool = ((s_2853_1) == (s_2853_3));
        // N s_2853_5: branch s_2853_4 b4085 b2854
        if s_2853_4 {
            return block_4085(state, tracer, fn_state);
        } else {
            return block_2854(state, tracer, fn_state);
        };
    }
    fn block_2854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2854_0: const #0u : u8
        let s_2854_0: bool = false;
        // D s_2854_1: write-var gs#118816 <= s_2854_0
        fn_state.gs_118816 = s_2854_0;
        // N s_2854_2: jump b2855
        return block_2855(state, tracer, fn_state);
    }
    fn block_2855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2855_0: read-var gs#118816:u8
        let s_2855_0: bool = fn_state.gs_118816;
        // N s_2855_1: branch s_2855_0 b4084 b2856
        if s_2855_0 {
            return block_4084(state, tracer, fn_state);
        } else {
            return block_2856(state, tracer, fn_state);
        };
    }
    fn block_2856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2856_0: const #0u : u8
        let s_2856_0: bool = false;
        // D s_2856_1: write-var gs#118817 <= s_2856_0
        fn_state.gs_118817 = s_2856_0;
        // N s_2856_2: jump b2857
        return block_2857(state, tracer, fn_state);
    }
    fn block_2857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2857_0: read-var gs#118817:u8
        let s_2857_0: bool = fn_state.gs_118817;
        // N s_2857_1: branch s_2857_0 b4083 b2858
        if s_2857_0 {
            return block_4083(state, tracer, fn_state);
        } else {
            return block_2858(state, tracer, fn_state);
        };
    }
    fn block_2858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2858_0: const #0u : u8
        let s_2858_0: bool = false;
        // D s_2858_1: write-var gs#118818 <= s_2858_0
        fn_state.gs_118818 = s_2858_0;
        // N s_2858_2: jump b2859
        return block_2859(state, tracer, fn_state);
    }
    fn block_2859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2859_0: read-var gs#118818:u8
        let s_2859_0: bool = fn_state.gs_118818;
        // N s_2859_1: branch s_2859_0 b4082 b2860
        if s_2859_0 {
            return block_4082(state, tracer, fn_state);
        } else {
            return block_2860(state, tracer, fn_state);
        };
    }
    fn block_2860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2860_0: const #0u : u8
        let s_2860_0: bool = false;
        // D s_2860_1: write-var gs#118819 <= s_2860_0
        fn_state.gs_118819 = s_2860_0;
        // N s_2860_2: jump b2861
        return block_2861(state, tracer, fn_state);
    }
    fn block_2861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2861_0: read-var gs#118819:u8
        let s_2861_0: bool = fn_state.gs_118819;
        // N s_2861_1: branch s_2861_0 b4081 b2862
        if s_2861_0 {
            return block_4081(state, tracer, fn_state);
        } else {
            return block_2862(state, tracer, fn_state);
        };
    }
    fn block_2862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2862_0: read-var CRm:u8
        let s_2862_0: u8 = fn_state.CRm;
        // D s_2862_1: cast zx s_2862_0 -> bv
        let s_2862_1: Bits = Bits::new(s_2862_0 as u128, 4u16);
        // C s_2862_2: const #12u : u8
        let s_2862_2: u8 = 12;
        // C s_2862_3: cast zx s_2862_2 -> bv
        let s_2862_3: Bits = Bits::new(s_2862_2 as u128, 4u16);
        // D s_2862_4: cmp-eq s_2862_1 s_2862_3
        let s_2862_4: bool = ((s_2862_1) == (s_2862_3));
        // N s_2862_5: branch s_2862_4 b4080 b2863
        if s_2862_4 {
            return block_4080(state, tracer, fn_state);
        } else {
            return block_2863(state, tracer, fn_state);
        };
    }
    fn block_2863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2863_0: const #0u : u8
        let s_2863_0: bool = false;
        // D s_2863_1: write-var gs#118820 <= s_2863_0
        fn_state.gs_118820 = s_2863_0;
        // N s_2863_2: jump b2864
        return block_2864(state, tracer, fn_state);
    }
    fn block_2864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2864_0: read-var gs#118820:u8
        let s_2864_0: bool = fn_state.gs_118820;
        // N s_2864_1: branch s_2864_0 b4079 b2865
        if s_2864_0 {
            return block_4079(state, tracer, fn_state);
        } else {
            return block_2865(state, tracer, fn_state);
        };
    }
    fn block_2865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2865_0: const #0u : u8
        let s_2865_0: bool = false;
        // D s_2865_1: write-var gs#118821 <= s_2865_0
        fn_state.gs_118821 = s_2865_0;
        // N s_2865_2: jump b2866
        return block_2866(state, tracer, fn_state);
    }
    fn block_2866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2866_0: read-var gs#118821:u8
        let s_2866_0: bool = fn_state.gs_118821;
        // N s_2866_1: branch s_2866_0 b4078 b2867
        if s_2866_0 {
            return block_4078(state, tracer, fn_state);
        } else {
            return block_2867(state, tracer, fn_state);
        };
    }
    fn block_2867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2867_0: const #0u : u8
        let s_2867_0: bool = false;
        // D s_2867_1: write-var gs#118822 <= s_2867_0
        fn_state.gs_118822 = s_2867_0;
        // N s_2867_2: jump b2868
        return block_2868(state, tracer, fn_state);
    }
    fn block_2868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2868_0: read-var gs#118822:u8
        let s_2868_0: bool = fn_state.gs_118822;
        // N s_2868_1: branch s_2868_0 b4077 b2869
        if s_2868_0 {
            return block_4077(state, tracer, fn_state);
        } else {
            return block_2869(state, tracer, fn_state);
        };
    }
    fn block_2869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2869_0: const #0u : u8
        let s_2869_0: bool = false;
        // D s_2869_1: write-var gs#118823 <= s_2869_0
        fn_state.gs_118823 = s_2869_0;
        // N s_2869_2: jump b2870
        return block_2870(state, tracer, fn_state);
    }
    fn block_2870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2870_0: read-var gs#118823:u8
        let s_2870_0: bool = fn_state.gs_118823;
        // N s_2870_1: branch s_2870_0 b4076 b2871
        if s_2870_0 {
            return block_4076(state, tracer, fn_state);
        } else {
            return block_2871(state, tracer, fn_state);
        };
    }
    fn block_2871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2871_0: read-var CRm:u8
        let s_2871_0: u8 = fn_state.CRm;
        // D s_2871_1: cast zx s_2871_0 -> bv
        let s_2871_1: Bits = Bits::new(s_2871_0 as u128, 4u16);
        // C s_2871_2: const #12u : u8
        let s_2871_2: u8 = 12;
        // C s_2871_3: cast zx s_2871_2 -> bv
        let s_2871_3: Bits = Bits::new(s_2871_2 as u128, 4u16);
        // D s_2871_4: cmp-eq s_2871_1 s_2871_3
        let s_2871_4: bool = ((s_2871_1) == (s_2871_3));
        // N s_2871_5: branch s_2871_4 b4075 b2872
        if s_2871_4 {
            return block_4075(state, tracer, fn_state);
        } else {
            return block_2872(state, tracer, fn_state);
        };
    }
    fn block_2872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2872_0: const #0u : u8
        let s_2872_0: bool = false;
        // D s_2872_1: write-var gs#118824 <= s_2872_0
        fn_state.gs_118824 = s_2872_0;
        // N s_2872_2: jump b2873
        return block_2873(state, tracer, fn_state);
    }
    fn block_2873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2873_0: read-var gs#118824:u8
        let s_2873_0: bool = fn_state.gs_118824;
        // N s_2873_1: branch s_2873_0 b4074 b2874
        if s_2873_0 {
            return block_4074(state, tracer, fn_state);
        } else {
            return block_2874(state, tracer, fn_state);
        };
    }
    fn block_2874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2874_0: const #0u : u8
        let s_2874_0: bool = false;
        // D s_2874_1: write-var gs#118825 <= s_2874_0
        fn_state.gs_118825 = s_2874_0;
        // N s_2874_2: jump b2875
        return block_2875(state, tracer, fn_state);
    }
    fn block_2875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2875_0: read-var gs#118825:u8
        let s_2875_0: bool = fn_state.gs_118825;
        // N s_2875_1: branch s_2875_0 b4073 b2876
        if s_2875_0 {
            return block_4073(state, tracer, fn_state);
        } else {
            return block_2876(state, tracer, fn_state);
        };
    }
    fn block_2876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2876_0: const #0u : u8
        let s_2876_0: bool = false;
        // D s_2876_1: write-var gs#118826 <= s_2876_0
        fn_state.gs_118826 = s_2876_0;
        // N s_2876_2: jump b2877
        return block_2877(state, tracer, fn_state);
    }
    fn block_2877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2877_0: read-var gs#118826:u8
        let s_2877_0: bool = fn_state.gs_118826;
        // N s_2877_1: branch s_2877_0 b4072 b2878
        if s_2877_0 {
            return block_4072(state, tracer, fn_state);
        } else {
            return block_2878(state, tracer, fn_state);
        };
    }
    fn block_2878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2878_0: const #0u : u8
        let s_2878_0: bool = false;
        // D s_2878_1: write-var gs#118827 <= s_2878_0
        fn_state.gs_118827 = s_2878_0;
        // N s_2878_2: jump b2879
        return block_2879(state, tracer, fn_state);
    }
    fn block_2879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2879_0: read-var gs#118827:u8
        let s_2879_0: bool = fn_state.gs_118827;
        // N s_2879_1: branch s_2879_0 b4071 b2880
        if s_2879_0 {
            return block_4071(state, tracer, fn_state);
        } else {
            return block_2880(state, tracer, fn_state);
        };
    }
    fn block_2880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2880_0: read-var CRm:u8
        let s_2880_0: u8 = fn_state.CRm;
        // D s_2880_1: cast zx s_2880_0 -> bv
        let s_2880_1: Bits = Bits::new(s_2880_0 as u128, 4u16);
        // C s_2880_2: const #12u : u8
        let s_2880_2: u8 = 12;
        // C s_2880_3: cast zx s_2880_2 -> bv
        let s_2880_3: Bits = Bits::new(s_2880_2 as u128, 4u16);
        // D s_2880_4: cmp-eq s_2880_1 s_2880_3
        let s_2880_4: bool = ((s_2880_1) == (s_2880_3));
        // N s_2880_5: branch s_2880_4 b4070 b2881
        if s_2880_4 {
            return block_4070(state, tracer, fn_state);
        } else {
            return block_2881(state, tracer, fn_state);
        };
    }
    fn block_2881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2881_0: const #0u : u8
        let s_2881_0: bool = false;
        // D s_2881_1: write-var gs#118828 <= s_2881_0
        fn_state.gs_118828 = s_2881_0;
        // N s_2881_2: jump b2882
        return block_2882(state, tracer, fn_state);
    }
    fn block_2882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2882_0: read-var gs#118828:u8
        let s_2882_0: bool = fn_state.gs_118828;
        // N s_2882_1: branch s_2882_0 b4069 b2883
        if s_2882_0 {
            return block_4069(state, tracer, fn_state);
        } else {
            return block_2883(state, tracer, fn_state);
        };
    }
    fn block_2883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2883_0: const #0u : u8
        let s_2883_0: bool = false;
        // D s_2883_1: write-var gs#118829 <= s_2883_0
        fn_state.gs_118829 = s_2883_0;
        // N s_2883_2: jump b2884
        return block_2884(state, tracer, fn_state);
    }
    fn block_2884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2884_0: read-var gs#118829:u8
        let s_2884_0: bool = fn_state.gs_118829;
        // N s_2884_1: branch s_2884_0 b4068 b2885
        if s_2884_0 {
            return block_4068(state, tracer, fn_state);
        } else {
            return block_2885(state, tracer, fn_state);
        };
    }
    fn block_2885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2885_0: const #0u : u8
        let s_2885_0: bool = false;
        // D s_2885_1: write-var gs#118830 <= s_2885_0
        fn_state.gs_118830 = s_2885_0;
        // N s_2885_2: jump b2886
        return block_2886(state, tracer, fn_state);
    }
    fn block_2886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2886_0: read-var gs#118830:u8
        let s_2886_0: bool = fn_state.gs_118830;
        // N s_2886_1: branch s_2886_0 b4067 b2887
        if s_2886_0 {
            return block_4067(state, tracer, fn_state);
        } else {
            return block_2887(state, tracer, fn_state);
        };
    }
    fn block_2887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2887_0: const #0u : u8
        let s_2887_0: bool = false;
        // D s_2887_1: write-var gs#118831 <= s_2887_0
        fn_state.gs_118831 = s_2887_0;
        // N s_2887_2: jump b2888
        return block_2888(state, tracer, fn_state);
    }
    fn block_2888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2888_0: read-var gs#118831:u8
        let s_2888_0: bool = fn_state.gs_118831;
        // N s_2888_1: branch s_2888_0 b4066 b2889
        if s_2888_0 {
            return block_4066(state, tracer, fn_state);
        } else {
            return block_2889(state, tracer, fn_state);
        };
    }
    fn block_2889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2889_0: read-var CRm:u8
        let s_2889_0: u8 = fn_state.CRm;
        // D s_2889_1: cast zx s_2889_0 -> bv
        let s_2889_1: Bits = Bits::new(s_2889_0 as u128, 4u16);
        // C s_2889_2: const #12u : u8
        let s_2889_2: u8 = 12;
        // C s_2889_3: cast zx s_2889_2 -> bv
        let s_2889_3: Bits = Bits::new(s_2889_2 as u128, 4u16);
        // D s_2889_4: cmp-eq s_2889_1 s_2889_3
        let s_2889_4: bool = ((s_2889_1) == (s_2889_3));
        // N s_2889_5: branch s_2889_4 b4065 b2890
        if s_2889_4 {
            return block_4065(state, tracer, fn_state);
        } else {
            return block_2890(state, tracer, fn_state);
        };
    }
    fn block_2890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2890_0: const #0u : u8
        let s_2890_0: bool = false;
        // D s_2890_1: write-var gs#118832 <= s_2890_0
        fn_state.gs_118832 = s_2890_0;
        // N s_2890_2: jump b2891
        return block_2891(state, tracer, fn_state);
    }
    fn block_2891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2891_0: read-var gs#118832:u8
        let s_2891_0: bool = fn_state.gs_118832;
        // N s_2891_1: branch s_2891_0 b4064 b2892
        if s_2891_0 {
            return block_4064(state, tracer, fn_state);
        } else {
            return block_2892(state, tracer, fn_state);
        };
    }
    fn block_2892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2892_0: const #0u : u8
        let s_2892_0: bool = false;
        // D s_2892_1: write-var gs#118833 <= s_2892_0
        fn_state.gs_118833 = s_2892_0;
        // N s_2892_2: jump b2893
        return block_2893(state, tracer, fn_state);
    }
    fn block_2893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2893_0: read-var gs#118833:u8
        let s_2893_0: bool = fn_state.gs_118833;
        // N s_2893_1: branch s_2893_0 b4063 b2894
        if s_2893_0 {
            return block_4063(state, tracer, fn_state);
        } else {
            return block_2894(state, tracer, fn_state);
        };
    }
    fn block_2894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2894_0: const #0u : u8
        let s_2894_0: bool = false;
        // D s_2894_1: write-var gs#118834 <= s_2894_0
        fn_state.gs_118834 = s_2894_0;
        // N s_2894_2: jump b2895
        return block_2895(state, tracer, fn_state);
    }
    fn block_2895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2895_0: read-var gs#118834:u8
        let s_2895_0: bool = fn_state.gs_118834;
        // N s_2895_1: branch s_2895_0 b4062 b2896
        if s_2895_0 {
            return block_4062(state, tracer, fn_state);
        } else {
            return block_2896(state, tracer, fn_state);
        };
    }
    fn block_2896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2896_0: const #0u : u8
        let s_2896_0: bool = false;
        // D s_2896_1: write-var gs#118835 <= s_2896_0
        fn_state.gs_118835 = s_2896_0;
        // N s_2896_2: jump b2897
        return block_2897(state, tracer, fn_state);
    }
    fn block_2897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2897_0: read-var gs#118835:u8
        let s_2897_0: bool = fn_state.gs_118835;
        // N s_2897_1: branch s_2897_0 b4061 b2898
        if s_2897_0 {
            return block_4061(state, tracer, fn_state);
        } else {
            return block_2898(state, tracer, fn_state);
        };
    }
    fn block_2898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2898_0: read-var CRm:u8
        let s_2898_0: u8 = fn_state.CRm;
        // D s_2898_1: cast zx s_2898_0 -> bv
        let s_2898_1: Bits = Bits::new(s_2898_0 as u128, 4u16);
        // C s_2898_2: const #12u : u8
        let s_2898_2: u8 = 12;
        // C s_2898_3: cast zx s_2898_2 -> bv
        let s_2898_3: Bits = Bits::new(s_2898_2 as u128, 4u16);
        // D s_2898_4: cmp-eq s_2898_1 s_2898_3
        let s_2898_4: bool = ((s_2898_1) == (s_2898_3));
        // N s_2898_5: branch s_2898_4 b4060 b2899
        if s_2898_4 {
            return block_4060(state, tracer, fn_state);
        } else {
            return block_2899(state, tracer, fn_state);
        };
    }
    fn block_2899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2899_0: const #0u : u8
        let s_2899_0: bool = false;
        // D s_2899_1: write-var gs#118836 <= s_2899_0
        fn_state.gs_118836 = s_2899_0;
        // N s_2899_2: jump b2900
        return block_2900(state, tracer, fn_state);
    }
    fn block_2900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2900_0: read-var gs#118836:u8
        let s_2900_0: bool = fn_state.gs_118836;
        // N s_2900_1: branch s_2900_0 b4059 b2901
        if s_2900_0 {
            return block_4059(state, tracer, fn_state);
        } else {
            return block_2901(state, tracer, fn_state);
        };
    }
    fn block_2901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2901_0: const #0u : u8
        let s_2901_0: bool = false;
        // D s_2901_1: write-var gs#118837 <= s_2901_0
        fn_state.gs_118837 = s_2901_0;
        // N s_2901_2: jump b2902
        return block_2902(state, tracer, fn_state);
    }
    fn block_2902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2902_0: read-var gs#118837:u8
        let s_2902_0: bool = fn_state.gs_118837;
        // N s_2902_1: branch s_2902_0 b4058 b2903
        if s_2902_0 {
            return block_4058(state, tracer, fn_state);
        } else {
            return block_2903(state, tracer, fn_state);
        };
    }
    fn block_2903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2903_0: const #0u : u8
        let s_2903_0: bool = false;
        // D s_2903_1: write-var gs#118838 <= s_2903_0
        fn_state.gs_118838 = s_2903_0;
        // N s_2903_2: jump b2904
        return block_2904(state, tracer, fn_state);
    }
    fn block_2904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2904_0: read-var gs#118838:u8
        let s_2904_0: bool = fn_state.gs_118838;
        // N s_2904_1: branch s_2904_0 b4057 b2905
        if s_2904_0 {
            return block_4057(state, tracer, fn_state);
        } else {
            return block_2905(state, tracer, fn_state);
        };
    }
    fn block_2905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2905_0: const #0u : u8
        let s_2905_0: bool = false;
        // D s_2905_1: write-var gs#118839 <= s_2905_0
        fn_state.gs_118839 = s_2905_0;
        // N s_2905_2: jump b2906
        return block_2906(state, tracer, fn_state);
    }
    fn block_2906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2906_0: read-var gs#118839:u8
        let s_2906_0: bool = fn_state.gs_118839;
        // N s_2906_1: branch s_2906_0 b4056 b2907
        if s_2906_0 {
            return block_4056(state, tracer, fn_state);
        } else {
            return block_2907(state, tracer, fn_state);
        };
    }
    fn block_2907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2907_0: read-var CRm:u8
        let s_2907_0: u8 = fn_state.CRm;
        // D s_2907_1: cast zx s_2907_0 -> bv
        let s_2907_1: Bits = Bits::new(s_2907_0 as u128, 4u16);
        // C s_2907_2: const #12u : u8
        let s_2907_2: u8 = 12;
        // C s_2907_3: cast zx s_2907_2 -> bv
        let s_2907_3: Bits = Bits::new(s_2907_2 as u128, 4u16);
        // D s_2907_4: cmp-eq s_2907_1 s_2907_3
        let s_2907_4: bool = ((s_2907_1) == (s_2907_3));
        // N s_2907_5: branch s_2907_4 b4055 b2908
        if s_2907_4 {
            return block_4055(state, tracer, fn_state);
        } else {
            return block_2908(state, tracer, fn_state);
        };
    }
    fn block_2908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2908_0: const #0u : u8
        let s_2908_0: bool = false;
        // D s_2908_1: write-var gs#118840 <= s_2908_0
        fn_state.gs_118840 = s_2908_0;
        // N s_2908_2: jump b2909
        return block_2909(state, tracer, fn_state);
    }
    fn block_2909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2909_0: read-var gs#118840:u8
        let s_2909_0: bool = fn_state.gs_118840;
        // N s_2909_1: branch s_2909_0 b4054 b2910
        if s_2909_0 {
            return block_4054(state, tracer, fn_state);
        } else {
            return block_2910(state, tracer, fn_state);
        };
    }
    fn block_2910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2910_0: const #0u : u8
        let s_2910_0: bool = false;
        // D s_2910_1: write-var gs#118841 <= s_2910_0
        fn_state.gs_118841 = s_2910_0;
        // N s_2910_2: jump b2911
        return block_2911(state, tracer, fn_state);
    }
    fn block_2911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2911_0: read-var gs#118841:u8
        let s_2911_0: bool = fn_state.gs_118841;
        // N s_2911_1: branch s_2911_0 b4053 b2912
        if s_2911_0 {
            return block_4053(state, tracer, fn_state);
        } else {
            return block_2912(state, tracer, fn_state);
        };
    }
    fn block_2912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2912_0: const #0u : u8
        let s_2912_0: bool = false;
        // D s_2912_1: write-var gs#118842 <= s_2912_0
        fn_state.gs_118842 = s_2912_0;
        // N s_2912_2: jump b2913
        return block_2913(state, tracer, fn_state);
    }
    fn block_2913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2913_0: read-var gs#118842:u8
        let s_2913_0: bool = fn_state.gs_118842;
        // N s_2913_1: branch s_2913_0 b4052 b2914
        if s_2913_0 {
            return block_4052(state, tracer, fn_state);
        } else {
            return block_2914(state, tracer, fn_state);
        };
    }
    fn block_2914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2914_0: const #0u : u8
        let s_2914_0: bool = false;
        // D s_2914_1: write-var gs#118843 <= s_2914_0
        fn_state.gs_118843 = s_2914_0;
        // N s_2914_2: jump b2915
        return block_2915(state, tracer, fn_state);
    }
    fn block_2915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2915_0: read-var gs#118843:u8
        let s_2915_0: bool = fn_state.gs_118843;
        // N s_2915_1: branch s_2915_0 b4051 b2916
        if s_2915_0 {
            return block_4051(state, tracer, fn_state);
        } else {
            return block_2916(state, tracer, fn_state);
        };
    }
    fn block_2916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2916_0: read-var CRm:u8
        let s_2916_0: u8 = fn_state.CRm;
        // D s_2916_1: cast zx s_2916_0 -> bv
        let s_2916_1: Bits = Bits::new(s_2916_0 as u128, 4u16);
        // C s_2916_2: const #0u : u8
        let s_2916_2: u8 = 0;
        // C s_2916_3: cast zx s_2916_2 -> bv
        let s_2916_3: Bits = Bits::new(s_2916_2 as u128, 4u16);
        // D s_2916_4: cmp-eq s_2916_1 s_2916_3
        let s_2916_4: bool = ((s_2916_1) == (s_2916_3));
        // N s_2916_5: branch s_2916_4 b4050 b2917
        if s_2916_4 {
            return block_4050(state, tracer, fn_state);
        } else {
            return block_2917(state, tracer, fn_state);
        };
    }
    fn block_2917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2917_0: const #0u : u8
        let s_2917_0: bool = false;
        // D s_2917_1: write-var gs#118844 <= s_2917_0
        fn_state.gs_118844 = s_2917_0;
        // N s_2917_2: jump b2918
        return block_2918(state, tracer, fn_state);
    }
    fn block_2918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2918_0: read-var gs#118844:u8
        let s_2918_0: bool = fn_state.gs_118844;
        // N s_2918_1: branch s_2918_0 b4049 b2919
        if s_2918_0 {
            return block_4049(state, tracer, fn_state);
        } else {
            return block_2919(state, tracer, fn_state);
        };
    }
    fn block_2919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2919_0: const #0u : u8
        let s_2919_0: bool = false;
        // D s_2919_1: write-var gs#118845 <= s_2919_0
        fn_state.gs_118845 = s_2919_0;
        // N s_2919_2: jump b2920
        return block_2920(state, tracer, fn_state);
    }
    fn block_2920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2920_0: read-var gs#118845:u8
        let s_2920_0: bool = fn_state.gs_118845;
        // N s_2920_1: branch s_2920_0 b4048 b2921
        if s_2920_0 {
            return block_4048(state, tracer, fn_state);
        } else {
            return block_2921(state, tracer, fn_state);
        };
    }
    fn block_2921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2921_0: const #0u : u8
        let s_2921_0: bool = false;
        // D s_2921_1: write-var gs#118846 <= s_2921_0
        fn_state.gs_118846 = s_2921_0;
        // N s_2921_2: jump b2922
        return block_2922(state, tracer, fn_state);
    }
    fn block_2922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2922_0: read-var gs#118846:u8
        let s_2922_0: bool = fn_state.gs_118846;
        // N s_2922_1: branch s_2922_0 b4047 b2923
        if s_2922_0 {
            return block_4047(state, tracer, fn_state);
        } else {
            return block_2923(state, tracer, fn_state);
        };
    }
    fn block_2923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2923_0: const #0u : u8
        let s_2923_0: bool = false;
        // D s_2923_1: write-var gs#118847 <= s_2923_0
        fn_state.gs_118847 = s_2923_0;
        // N s_2923_2: jump b2924
        return block_2924(state, tracer, fn_state);
    }
    fn block_2924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2924_0: read-var gs#118847:u8
        let s_2924_0: bool = fn_state.gs_118847;
        // N s_2924_1: branch s_2924_0 b4046 b2925
        if s_2924_0 {
            return block_4046(state, tracer, fn_state);
        } else {
            return block_2925(state, tracer, fn_state);
        };
    }
    fn block_2925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2925_0: read-var CRm:u8
        let s_2925_0: u8 = fn_state.CRm;
        // D s_2925_1: cast zx s_2925_0 -> bv
        let s_2925_1: Bits = Bits::new(s_2925_0 as u128, 4u16);
        // C s_2925_2: const #0u : u8
        let s_2925_2: u8 = 0;
        // C s_2925_3: cast zx s_2925_2 -> bv
        let s_2925_3: Bits = Bits::new(s_2925_2 as u128, 4u16);
        // D s_2925_4: cmp-eq s_2925_1 s_2925_3
        let s_2925_4: bool = ((s_2925_1) == (s_2925_3));
        // N s_2925_5: branch s_2925_4 b4045 b2926
        if s_2925_4 {
            return block_4045(state, tracer, fn_state);
        } else {
            return block_2926(state, tracer, fn_state);
        };
    }
    fn block_2926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2926_0: const #0u : u8
        let s_2926_0: bool = false;
        // D s_2926_1: write-var gs#118848 <= s_2926_0
        fn_state.gs_118848 = s_2926_0;
        // N s_2926_2: jump b2927
        return block_2927(state, tracer, fn_state);
    }
    fn block_2927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2927_0: read-var gs#118848:u8
        let s_2927_0: bool = fn_state.gs_118848;
        // N s_2927_1: branch s_2927_0 b4044 b2928
        if s_2927_0 {
            return block_4044(state, tracer, fn_state);
        } else {
            return block_2928(state, tracer, fn_state);
        };
    }
    fn block_2928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2928_0: const #0u : u8
        let s_2928_0: bool = false;
        // D s_2928_1: write-var gs#118849 <= s_2928_0
        fn_state.gs_118849 = s_2928_0;
        // N s_2928_2: jump b2929
        return block_2929(state, tracer, fn_state);
    }
    fn block_2929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2929_0: read-var gs#118849:u8
        let s_2929_0: bool = fn_state.gs_118849;
        // N s_2929_1: branch s_2929_0 b4043 b2930
        if s_2929_0 {
            return block_4043(state, tracer, fn_state);
        } else {
            return block_2930(state, tracer, fn_state);
        };
    }
    fn block_2930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2930_0: const #0u : u8
        let s_2930_0: bool = false;
        // D s_2930_1: write-var gs#118850 <= s_2930_0
        fn_state.gs_118850 = s_2930_0;
        // N s_2930_2: jump b2931
        return block_2931(state, tracer, fn_state);
    }
    fn block_2931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2931_0: read-var gs#118850:u8
        let s_2931_0: bool = fn_state.gs_118850;
        // N s_2931_1: branch s_2931_0 b4042 b2932
        if s_2931_0 {
            return block_4042(state, tracer, fn_state);
        } else {
            return block_2932(state, tracer, fn_state);
        };
    }
    fn block_2932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2932_0: const #0u : u8
        let s_2932_0: bool = false;
        // D s_2932_1: write-var gs#118851 <= s_2932_0
        fn_state.gs_118851 = s_2932_0;
        // N s_2932_2: jump b2933
        return block_2933(state, tracer, fn_state);
    }
    fn block_2933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2933_0: read-var gs#118851:u8
        let s_2933_0: bool = fn_state.gs_118851;
        // N s_2933_1: branch s_2933_0 b4041 b2934
        if s_2933_0 {
            return block_4041(state, tracer, fn_state);
        } else {
            return block_2934(state, tracer, fn_state);
        };
    }
    fn block_2934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2934_0: read-var CRm:u8
        let s_2934_0: u8 = fn_state.CRm;
        // D s_2934_1: cast zx s_2934_0 -> bv
        let s_2934_1: Bits = Bits::new(s_2934_0 as u128, 4u16);
        // C s_2934_2: const #0u : u8
        let s_2934_2: u8 = 0;
        // C s_2934_3: cast zx s_2934_2 -> bv
        let s_2934_3: Bits = Bits::new(s_2934_2 as u128, 4u16);
        // D s_2934_4: cmp-eq s_2934_1 s_2934_3
        let s_2934_4: bool = ((s_2934_1) == (s_2934_3));
        // N s_2934_5: branch s_2934_4 b4040 b2935
        if s_2934_4 {
            return block_4040(state, tracer, fn_state);
        } else {
            return block_2935(state, tracer, fn_state);
        };
    }
    fn block_2935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2935_0: const #0u : u8
        let s_2935_0: bool = false;
        // D s_2935_1: write-var gs#118852 <= s_2935_0
        fn_state.gs_118852 = s_2935_0;
        // N s_2935_2: jump b2936
        return block_2936(state, tracer, fn_state);
    }
    fn block_2936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2936_0: read-var gs#118852:u8
        let s_2936_0: bool = fn_state.gs_118852;
        // N s_2936_1: branch s_2936_0 b4039 b2937
        if s_2936_0 {
            return block_4039(state, tracer, fn_state);
        } else {
            return block_2937(state, tracer, fn_state);
        };
    }
    fn block_2937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2937_0: const #0u : u8
        let s_2937_0: bool = false;
        // D s_2937_1: write-var gs#118853 <= s_2937_0
        fn_state.gs_118853 = s_2937_0;
        // N s_2937_2: jump b2938
        return block_2938(state, tracer, fn_state);
    }
    fn block_2938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2938_0: read-var gs#118853:u8
        let s_2938_0: bool = fn_state.gs_118853;
        // N s_2938_1: branch s_2938_0 b4038 b2939
        if s_2938_0 {
            return block_4038(state, tracer, fn_state);
        } else {
            return block_2939(state, tracer, fn_state);
        };
    }
    fn block_2939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2939_0: const #0u : u8
        let s_2939_0: bool = false;
        // D s_2939_1: write-var gs#118854 <= s_2939_0
        fn_state.gs_118854 = s_2939_0;
        // N s_2939_2: jump b2940
        return block_2940(state, tracer, fn_state);
    }
    fn block_2940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2940_0: read-var gs#118854:u8
        let s_2940_0: bool = fn_state.gs_118854;
        // N s_2940_1: branch s_2940_0 b4037 b2941
        if s_2940_0 {
            return block_4037(state, tracer, fn_state);
        } else {
            return block_2941(state, tracer, fn_state);
        };
    }
    fn block_2941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2941_0: const #0u : u8
        let s_2941_0: bool = false;
        // D s_2941_1: write-var gs#118855 <= s_2941_0
        fn_state.gs_118855 = s_2941_0;
        // N s_2941_2: jump b2942
        return block_2942(state, tracer, fn_state);
    }
    fn block_2942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2942_0: read-var gs#118855:u8
        let s_2942_0: bool = fn_state.gs_118855;
        // N s_2942_1: branch s_2942_0 b4036 b2943
        if s_2942_0 {
            return block_4036(state, tracer, fn_state);
        } else {
            return block_2943(state, tracer, fn_state);
        };
    }
    fn block_2943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2943_0: read-var CRm:u8
        let s_2943_0: u8 = fn_state.CRm;
        // D s_2943_1: cast zx s_2943_0 -> bv
        let s_2943_1: Bits = Bits::new(s_2943_0 as u128, 4u16);
        // C s_2943_2: const #12u : u8
        let s_2943_2: u8 = 12;
        // C s_2943_3: cast zx s_2943_2 -> bv
        let s_2943_3: Bits = Bits::new(s_2943_2 as u128, 4u16);
        // D s_2943_4: cmp-eq s_2943_1 s_2943_3
        let s_2943_4: bool = ((s_2943_1) == (s_2943_3));
        // N s_2943_5: branch s_2943_4 b4035 b2944
        if s_2943_4 {
            return block_4035(state, tracer, fn_state);
        } else {
            return block_2944(state, tracer, fn_state);
        };
    }
    fn block_2944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2944_0: const #0u : u8
        let s_2944_0: bool = false;
        // D s_2944_1: write-var gs#118856 <= s_2944_0
        fn_state.gs_118856 = s_2944_0;
        // N s_2944_2: jump b2945
        return block_2945(state, tracer, fn_state);
    }
    fn block_2945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2945_0: read-var gs#118856:u8
        let s_2945_0: bool = fn_state.gs_118856;
        // N s_2945_1: branch s_2945_0 b4034 b2946
        if s_2945_0 {
            return block_4034(state, tracer, fn_state);
        } else {
            return block_2946(state, tracer, fn_state);
        };
    }
    fn block_2946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2946_0: const #0u : u8
        let s_2946_0: bool = false;
        // D s_2946_1: write-var gs#118857 <= s_2946_0
        fn_state.gs_118857 = s_2946_0;
        // N s_2946_2: jump b2947
        return block_2947(state, tracer, fn_state);
    }
    fn block_2947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2947_0: read-var gs#118857:u8
        let s_2947_0: bool = fn_state.gs_118857;
        // N s_2947_1: branch s_2947_0 b4033 b2948
        if s_2947_0 {
            return block_4033(state, tracer, fn_state);
        } else {
            return block_2948(state, tracer, fn_state);
        };
    }
    fn block_2948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2948_0: const #0u : u8
        let s_2948_0: bool = false;
        // D s_2948_1: write-var gs#118858 <= s_2948_0
        fn_state.gs_118858 = s_2948_0;
        // N s_2948_2: jump b2949
        return block_2949(state, tracer, fn_state);
    }
    fn block_2949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2949_0: read-var gs#118858:u8
        let s_2949_0: bool = fn_state.gs_118858;
        // N s_2949_1: branch s_2949_0 b4032 b2950
        if s_2949_0 {
            return block_4032(state, tracer, fn_state);
        } else {
            return block_2950(state, tracer, fn_state);
        };
    }
    fn block_2950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2950_0: const #0u : u8
        let s_2950_0: bool = false;
        // D s_2950_1: write-var gs#118859 <= s_2950_0
        fn_state.gs_118859 = s_2950_0;
        // N s_2950_2: jump b2951
        return block_2951(state, tracer, fn_state);
    }
    fn block_2951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2951_0: read-var gs#118859:u8
        let s_2951_0: bool = fn_state.gs_118859;
        // N s_2951_1: branch s_2951_0 b4031 b2952
        if s_2951_0 {
            return block_4031(state, tracer, fn_state);
        } else {
            return block_2952(state, tracer, fn_state);
        };
    }
    fn block_2952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2952_0: read-var CRm:u8
        let s_2952_0: u8 = fn_state.CRm;
        // D s_2952_1: cast zx s_2952_0 -> bv
        let s_2952_1: Bits = Bits::new(s_2952_0 as u128, 4u16);
        // C s_2952_2: const #2u : u8
        let s_2952_2: u8 = 2;
        // C s_2952_3: cast zx s_2952_2 -> bv
        let s_2952_3: Bits = Bits::new(s_2952_2 as u128, 4u16);
        // D s_2952_4: cmp-eq s_2952_1 s_2952_3
        let s_2952_4: bool = ((s_2952_1) == (s_2952_3));
        // N s_2952_5: branch s_2952_4 b4030 b2953
        if s_2952_4 {
            return block_4030(state, tracer, fn_state);
        } else {
            return block_2953(state, tracer, fn_state);
        };
    }
    fn block_2953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2953_0: const #0u : u8
        let s_2953_0: bool = false;
        // D s_2953_1: write-var gs#118860 <= s_2953_0
        fn_state.gs_118860 = s_2953_0;
        // N s_2953_2: jump b2954
        return block_2954(state, tracer, fn_state);
    }
    fn block_2954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2954_0: read-var gs#118860:u8
        let s_2954_0: bool = fn_state.gs_118860;
        // N s_2954_1: branch s_2954_0 b4029 b2955
        if s_2954_0 {
            return block_4029(state, tracer, fn_state);
        } else {
            return block_2955(state, tracer, fn_state);
        };
    }
    fn block_2955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2955_0: const #0u : u8
        let s_2955_0: bool = false;
        // D s_2955_1: write-var gs#118861 <= s_2955_0
        fn_state.gs_118861 = s_2955_0;
        // N s_2955_2: jump b2956
        return block_2956(state, tracer, fn_state);
    }
    fn block_2956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2956_0: read-var gs#118861:u8
        let s_2956_0: bool = fn_state.gs_118861;
        // N s_2956_1: branch s_2956_0 b4028 b2957
        if s_2956_0 {
            return block_4028(state, tracer, fn_state);
        } else {
            return block_2957(state, tracer, fn_state);
        };
    }
    fn block_2957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2957_0: const #0u : u8
        let s_2957_0: bool = false;
        // D s_2957_1: write-var gs#118862 <= s_2957_0
        fn_state.gs_118862 = s_2957_0;
        // N s_2957_2: jump b2958
        return block_2958(state, tracer, fn_state);
    }
    fn block_2958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2958_0: read-var gs#118862:u8
        let s_2958_0: bool = fn_state.gs_118862;
        // N s_2958_1: branch s_2958_0 b4027 b2959
        if s_2958_0 {
            return block_4027(state, tracer, fn_state);
        } else {
            return block_2959(state, tracer, fn_state);
        };
    }
    fn block_2959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2959_0: const #0u : u8
        let s_2959_0: bool = false;
        // D s_2959_1: write-var gs#118863 <= s_2959_0
        fn_state.gs_118863 = s_2959_0;
        // N s_2959_2: jump b2960
        return block_2960(state, tracer, fn_state);
    }
    fn block_2960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2960_0: read-var gs#118863:u8
        let s_2960_0: bool = fn_state.gs_118863;
        // N s_2960_1: branch s_2960_0 b4026 b2961
        if s_2960_0 {
            return block_4026(state, tracer, fn_state);
        } else {
            return block_2961(state, tracer, fn_state);
        };
    }
    fn block_2961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2961_0: read-var CRm:u8
        let s_2961_0: u8 = fn_state.CRm;
        // D s_2961_1: cast zx s_2961_0 -> bv
        let s_2961_1: Bits = Bits::new(s_2961_0 as u128, 4u16);
        // C s_2961_2: const #1u : u8
        let s_2961_2: u8 = 1;
        // C s_2961_3: cast zx s_2961_2 -> bv
        let s_2961_3: Bits = Bits::new(s_2961_2 as u128, 4u16);
        // D s_2961_4: cmp-eq s_2961_1 s_2961_3
        let s_2961_4: bool = ((s_2961_1) == (s_2961_3));
        // N s_2961_5: branch s_2961_4 b4025 b2962
        if s_2961_4 {
            return block_4025(state, tracer, fn_state);
        } else {
            return block_2962(state, tracer, fn_state);
        };
    }
    fn block_2962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2962_0: const #0u : u8
        let s_2962_0: bool = false;
        // D s_2962_1: write-var gs#118864 <= s_2962_0
        fn_state.gs_118864 = s_2962_0;
        // N s_2962_2: jump b2963
        return block_2963(state, tracer, fn_state);
    }
    fn block_2963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2963_0: read-var gs#118864:u8
        let s_2963_0: bool = fn_state.gs_118864;
        // N s_2963_1: branch s_2963_0 b4024 b2964
        if s_2963_0 {
            return block_4024(state, tracer, fn_state);
        } else {
            return block_2964(state, tracer, fn_state);
        };
    }
    fn block_2964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2964_0: const #0u : u8
        let s_2964_0: bool = false;
        // D s_2964_1: write-var gs#118865 <= s_2964_0
        fn_state.gs_118865 = s_2964_0;
        // N s_2964_2: jump b2965
        return block_2965(state, tracer, fn_state);
    }
    fn block_2965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2965_0: read-var gs#118865:u8
        let s_2965_0: bool = fn_state.gs_118865;
        // N s_2965_1: branch s_2965_0 b4023 b2966
        if s_2965_0 {
            return block_4023(state, tracer, fn_state);
        } else {
            return block_2966(state, tracer, fn_state);
        };
    }
    fn block_2966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2966_0: const #0u : u8
        let s_2966_0: bool = false;
        // D s_2966_1: write-var gs#118866 <= s_2966_0
        fn_state.gs_118866 = s_2966_0;
        // N s_2966_2: jump b2967
        return block_2967(state, tracer, fn_state);
    }
    fn block_2967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2967_0: read-var gs#118866:u8
        let s_2967_0: bool = fn_state.gs_118866;
        // N s_2967_1: branch s_2967_0 b4022 b2968
        if s_2967_0 {
            return block_4022(state, tracer, fn_state);
        } else {
            return block_2968(state, tracer, fn_state);
        };
    }
    fn block_2968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2968_0: const #0u : u8
        let s_2968_0: bool = false;
        // D s_2968_1: write-var gs#118867 <= s_2968_0
        fn_state.gs_118867 = s_2968_0;
        // N s_2968_2: jump b2969
        return block_2969(state, tracer, fn_state);
    }
    fn block_2969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2969_0: read-var gs#118867:u8
        let s_2969_0: bool = fn_state.gs_118867;
        // N s_2969_1: branch s_2969_0 b4021 b2970
        if s_2969_0 {
            return block_4021(state, tracer, fn_state);
        } else {
            return block_2970(state, tracer, fn_state);
        };
    }
    fn block_2970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2970_0: read-var CRm:u8
        let s_2970_0: u8 = fn_state.CRm;
        // D s_2970_1: cast zx s_2970_0 -> bv
        let s_2970_1: Bits = Bits::new(s_2970_0 as u128, 4u16);
        // C s_2970_2: const #2u : u8
        let s_2970_2: u8 = 2;
        // C s_2970_3: cast zx s_2970_2 -> bv
        let s_2970_3: Bits = Bits::new(s_2970_2 as u128, 4u16);
        // D s_2970_4: cmp-eq s_2970_1 s_2970_3
        let s_2970_4: bool = ((s_2970_1) == (s_2970_3));
        // N s_2970_5: branch s_2970_4 b4020 b2971
        if s_2970_4 {
            return block_4020(state, tracer, fn_state);
        } else {
            return block_2971(state, tracer, fn_state);
        };
    }
    fn block_2971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2971_0: const #0u : u8
        let s_2971_0: bool = false;
        // D s_2971_1: write-var gs#118868 <= s_2971_0
        fn_state.gs_118868 = s_2971_0;
        // N s_2971_2: jump b2972
        return block_2972(state, tracer, fn_state);
    }
    fn block_2972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2972_0: read-var gs#118868:u8
        let s_2972_0: bool = fn_state.gs_118868;
        // N s_2972_1: branch s_2972_0 b4019 b2973
        if s_2972_0 {
            return block_4019(state, tracer, fn_state);
        } else {
            return block_2973(state, tracer, fn_state);
        };
    }
    fn block_2973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2973_0: const #0u : u8
        let s_2973_0: bool = false;
        // D s_2973_1: write-var gs#118869 <= s_2973_0
        fn_state.gs_118869 = s_2973_0;
        // N s_2973_2: jump b2974
        return block_2974(state, tracer, fn_state);
    }
    fn block_2974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2974_0: read-var gs#118869:u8
        let s_2974_0: bool = fn_state.gs_118869;
        // N s_2974_1: branch s_2974_0 b4018 b2975
        if s_2974_0 {
            return block_4018(state, tracer, fn_state);
        } else {
            return block_2975(state, tracer, fn_state);
        };
    }
    fn block_2975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2975_0: const #0u : u8
        let s_2975_0: bool = false;
        // D s_2975_1: write-var gs#118870 <= s_2975_0
        fn_state.gs_118870 = s_2975_0;
        // N s_2975_2: jump b2976
        return block_2976(state, tracer, fn_state);
    }
    fn block_2976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2976_0: read-var gs#118870:u8
        let s_2976_0: bool = fn_state.gs_118870;
        // N s_2976_1: branch s_2976_0 b4017 b2977
        if s_2976_0 {
            return block_4017(state, tracer, fn_state);
        } else {
            return block_2977(state, tracer, fn_state);
        };
    }
    fn block_2977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2977_0: const #0u : u8
        let s_2977_0: bool = false;
        // D s_2977_1: write-var gs#118871 <= s_2977_0
        fn_state.gs_118871 = s_2977_0;
        // N s_2977_2: jump b2978
        return block_2978(state, tracer, fn_state);
    }
    fn block_2978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2978_0: read-var gs#118871:u8
        let s_2978_0: bool = fn_state.gs_118871;
        // N s_2978_1: branch s_2978_0 b4016 b2979
        if s_2978_0 {
            return block_4016(state, tracer, fn_state);
        } else {
            return block_2979(state, tracer, fn_state);
        };
    }
    fn block_2979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2979_0: read-var CRm:u8
        let s_2979_0: u8 = fn_state.CRm;
        // D s_2979_1: cast zx s_2979_0 -> bv
        let s_2979_1: Bits = Bits::new(s_2979_0 as u128, 4u16);
        // C s_2979_2: const #2u : u8
        let s_2979_2: u8 = 2;
        // C s_2979_3: cast zx s_2979_2 -> bv
        let s_2979_3: Bits = Bits::new(s_2979_2 as u128, 4u16);
        // D s_2979_4: cmp-eq s_2979_1 s_2979_3
        let s_2979_4: bool = ((s_2979_1) == (s_2979_3));
        // N s_2979_5: branch s_2979_4 b4015 b2980
        if s_2979_4 {
            return block_4015(state, tracer, fn_state);
        } else {
            return block_2980(state, tracer, fn_state);
        };
    }
    fn block_2980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2980_0: const #0u : u8
        let s_2980_0: bool = false;
        // D s_2980_1: write-var gs#118872 <= s_2980_0
        fn_state.gs_118872 = s_2980_0;
        // N s_2980_2: jump b2981
        return block_2981(state, tracer, fn_state);
    }
    fn block_2981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2981_0: read-var gs#118872:u8
        let s_2981_0: bool = fn_state.gs_118872;
        // N s_2981_1: branch s_2981_0 b4014 b2982
        if s_2981_0 {
            return block_4014(state, tracer, fn_state);
        } else {
            return block_2982(state, tracer, fn_state);
        };
    }
    fn block_2982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2982_0: const #0u : u8
        let s_2982_0: bool = false;
        // D s_2982_1: write-var gs#118873 <= s_2982_0
        fn_state.gs_118873 = s_2982_0;
        // N s_2982_2: jump b2983
        return block_2983(state, tracer, fn_state);
    }
    fn block_2983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2983_0: read-var gs#118873:u8
        let s_2983_0: bool = fn_state.gs_118873;
        // N s_2983_1: branch s_2983_0 b4013 b2984
        if s_2983_0 {
            return block_4013(state, tracer, fn_state);
        } else {
            return block_2984(state, tracer, fn_state);
        };
    }
    fn block_2984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2984_0: const #0u : u8
        let s_2984_0: bool = false;
        // D s_2984_1: write-var gs#118874 <= s_2984_0
        fn_state.gs_118874 = s_2984_0;
        // N s_2984_2: jump b2985
        return block_2985(state, tracer, fn_state);
    }
    fn block_2985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2985_0: read-var gs#118874:u8
        let s_2985_0: bool = fn_state.gs_118874;
        // N s_2985_1: branch s_2985_0 b4012 b2986
        if s_2985_0 {
            return block_4012(state, tracer, fn_state);
        } else {
            return block_2986(state, tracer, fn_state);
        };
    }
    fn block_2986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2986_0: const #0u : u8
        let s_2986_0: bool = false;
        // D s_2986_1: write-var gs#118875 <= s_2986_0
        fn_state.gs_118875 = s_2986_0;
        // N s_2986_2: jump b2987
        return block_2987(state, tracer, fn_state);
    }
    fn block_2987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2987_0: read-var gs#118875:u8
        let s_2987_0: bool = fn_state.gs_118875;
        // N s_2987_1: branch s_2987_0 b4011 b2988
        if s_2987_0 {
            return block_4011(state, tracer, fn_state);
        } else {
            return block_2988(state, tracer, fn_state);
        };
    }
    fn block_2988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2988_0: read-var CRm:u8
        let s_2988_0: u8 = fn_state.CRm;
        // D s_2988_1: cast zx s_2988_0 -> bv
        let s_2988_1: Bits = Bits::new(s_2988_0 as u128, 4u16);
        // C s_2988_2: const #3u : u8
        let s_2988_2: u8 = 3;
        // C s_2988_3: cast zx s_2988_2 -> bv
        let s_2988_3: Bits = Bits::new(s_2988_2 as u128, 4u16);
        // D s_2988_4: cmp-eq s_2988_1 s_2988_3
        let s_2988_4: bool = ((s_2988_1) == (s_2988_3));
        // N s_2988_5: branch s_2988_4 b4010 b2989
        if s_2988_4 {
            return block_4010(state, tracer, fn_state);
        } else {
            return block_2989(state, tracer, fn_state);
        };
    }
    fn block_2989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2989_0: const #0u : u8
        let s_2989_0: bool = false;
        // D s_2989_1: write-var gs#118876 <= s_2989_0
        fn_state.gs_118876 = s_2989_0;
        // N s_2989_2: jump b2990
        return block_2990(state, tracer, fn_state);
    }
    fn block_2990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2990_0: read-var gs#118876:u8
        let s_2990_0: bool = fn_state.gs_118876;
        // N s_2990_1: branch s_2990_0 b4009 b2991
        if s_2990_0 {
            return block_4009(state, tracer, fn_state);
        } else {
            return block_2991(state, tracer, fn_state);
        };
    }
    fn block_2991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2991_0: const #0u : u8
        let s_2991_0: bool = false;
        // D s_2991_1: write-var gs#118877 <= s_2991_0
        fn_state.gs_118877 = s_2991_0;
        // N s_2991_2: jump b2992
        return block_2992(state, tracer, fn_state);
    }
    fn block_2992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2992_0: read-var gs#118877:u8
        let s_2992_0: bool = fn_state.gs_118877;
        // N s_2992_1: branch s_2992_0 b4008 b2993
        if s_2992_0 {
            return block_4008(state, tracer, fn_state);
        } else {
            return block_2993(state, tracer, fn_state);
        };
    }
    fn block_2993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2993_0: const #0u : u8
        let s_2993_0: bool = false;
        // D s_2993_1: write-var gs#118878 <= s_2993_0
        fn_state.gs_118878 = s_2993_0;
        // N s_2993_2: jump b2994
        return block_2994(state, tracer, fn_state);
    }
    fn block_2994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2994_0: read-var gs#118878:u8
        let s_2994_0: bool = fn_state.gs_118878;
        // N s_2994_1: branch s_2994_0 b4007 b2995
        if s_2994_0 {
            return block_4007(state, tracer, fn_state);
        } else {
            return block_2995(state, tracer, fn_state);
        };
    }
    fn block_2995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2995_0: const #0u : u8
        let s_2995_0: bool = false;
        // D s_2995_1: write-var gs#118879 <= s_2995_0
        fn_state.gs_118879 = s_2995_0;
        // N s_2995_2: jump b2996
        return block_2996(state, tracer, fn_state);
    }
    fn block_2996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2996_0: read-var gs#118879:u8
        let s_2996_0: bool = fn_state.gs_118879;
        // N s_2996_1: branch s_2996_0 b4006 b2997
        if s_2996_0 {
            return block_4006(state, tracer, fn_state);
        } else {
            return block_2997(state, tracer, fn_state);
        };
    }
    fn block_2997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2997_0: read-var CRm:u8
        let s_2997_0: u8 = fn_state.CRm;
        // D s_2997_1: cast zx s_2997_0 -> bv
        let s_2997_1: Bits = Bits::new(s_2997_0 as u128, 4u16);
        // C s_2997_2: const #0u : u8
        let s_2997_2: u8 = 0;
        // C s_2997_3: cast zx s_2997_2 -> bv
        let s_2997_3: Bits = Bits::new(s_2997_2 as u128, 4u16);
        // D s_2997_4: cmp-eq s_2997_1 s_2997_3
        let s_2997_4: bool = ((s_2997_1) == (s_2997_3));
        // N s_2997_5: branch s_2997_4 b4005 b2998
        if s_2997_4 {
            return block_4005(state, tracer, fn_state);
        } else {
            return block_2998(state, tracer, fn_state);
        };
    }
    fn block_2998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2998_0: const #0u : u8
        let s_2998_0: bool = false;
        // D s_2998_1: write-var gs#118880 <= s_2998_0
        fn_state.gs_118880 = s_2998_0;
        // N s_2998_2: jump b2999
        return block_2999(state, tracer, fn_state);
    }
    fn block_2999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2999_0: read-var gs#118880:u8
        let s_2999_0: bool = fn_state.gs_118880;
        // N s_2999_1: branch s_2999_0 b4004 b3000
        if s_2999_0 {
            return block_4004(state, tracer, fn_state);
        } else {
            return block_3000(state, tracer, fn_state);
        };
    }
    fn block_3000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3000_0: const #0u : u8
        let s_3000_0: bool = false;
        // D s_3000_1: write-var gs#118881 <= s_3000_0
        fn_state.gs_118881 = s_3000_0;
        // N s_3000_2: jump b3001
        return block_3001(state, tracer, fn_state);
    }
    fn block_3001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3001_0: read-var gs#118881:u8
        let s_3001_0: bool = fn_state.gs_118881;
        // N s_3001_1: branch s_3001_0 b4003 b3002
        if s_3001_0 {
            return block_4003(state, tracer, fn_state);
        } else {
            return block_3002(state, tracer, fn_state);
        };
    }
    fn block_3002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3002_0: const #0u : u8
        let s_3002_0: bool = false;
        // D s_3002_1: write-var gs#118882 <= s_3002_0
        fn_state.gs_118882 = s_3002_0;
        // N s_3002_2: jump b3003
        return block_3003(state, tracer, fn_state);
    }
    fn block_3003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3003_0: read-var gs#118882:u8
        let s_3003_0: bool = fn_state.gs_118882;
        // N s_3003_1: branch s_3003_0 b4002 b3004
        if s_3003_0 {
            return block_4002(state, tracer, fn_state);
        } else {
            return block_3004(state, tracer, fn_state);
        };
    }
    fn block_3004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3004_0: const #0u : u8
        let s_3004_0: bool = false;
        // D s_3004_1: write-var gs#118883 <= s_3004_0
        fn_state.gs_118883 = s_3004_0;
        // N s_3004_2: jump b3005
        return block_3005(state, tracer, fn_state);
    }
    fn block_3005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3005_0: read-var gs#118883:u8
        let s_3005_0: bool = fn_state.gs_118883;
        // N s_3005_1: branch s_3005_0 b4001 b3006
        if s_3005_0 {
            return block_4001(state, tracer, fn_state);
        } else {
            return block_3006(state, tracer, fn_state);
        };
    }
    fn block_3006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3006_0: read-var CRm:u8
        let s_3006_0: u8 = fn_state.CRm;
        // D s_3006_1: cast zx s_3006_0 -> bv
        let s_3006_1: Bits = Bits::new(s_3006_0 as u128, 4u16);
        // C s_3006_2: const #0u : u8
        let s_3006_2: u8 = 0;
        // C s_3006_3: cast zx s_3006_2 -> bv
        let s_3006_3: Bits = Bits::new(s_3006_2 as u128, 4u16);
        // D s_3006_4: cmp-eq s_3006_1 s_3006_3
        let s_3006_4: bool = ((s_3006_1) == (s_3006_3));
        // N s_3006_5: branch s_3006_4 b4000 b3007
        if s_3006_4 {
            return block_4000(state, tracer, fn_state);
        } else {
            return block_3007(state, tracer, fn_state);
        };
    }
    fn block_3007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3007_0: const #0u : u8
        let s_3007_0: bool = false;
        // D s_3007_1: write-var gs#118884 <= s_3007_0
        fn_state.gs_118884 = s_3007_0;
        // N s_3007_2: jump b3008
        return block_3008(state, tracer, fn_state);
    }
    fn block_3008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3008_0: read-var gs#118884:u8
        let s_3008_0: bool = fn_state.gs_118884;
        // N s_3008_1: branch s_3008_0 b3999 b3009
        if s_3008_0 {
            return block_3999(state, tracer, fn_state);
        } else {
            return block_3009(state, tracer, fn_state);
        };
    }
    fn block_3009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3009_0: const #0u : u8
        let s_3009_0: bool = false;
        // D s_3009_1: write-var gs#118885 <= s_3009_0
        fn_state.gs_118885 = s_3009_0;
        // N s_3009_2: jump b3010
        return block_3010(state, tracer, fn_state);
    }
    fn block_3010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3010_0: read-var gs#118885:u8
        let s_3010_0: bool = fn_state.gs_118885;
        // N s_3010_1: branch s_3010_0 b3998 b3011
        if s_3010_0 {
            return block_3998(state, tracer, fn_state);
        } else {
            return block_3011(state, tracer, fn_state);
        };
    }
    fn block_3011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3011_0: const #0u : u8
        let s_3011_0: bool = false;
        // D s_3011_1: write-var gs#118886 <= s_3011_0
        fn_state.gs_118886 = s_3011_0;
        // N s_3011_2: jump b3012
        return block_3012(state, tracer, fn_state);
    }
    fn block_3012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3012_0: read-var gs#118886:u8
        let s_3012_0: bool = fn_state.gs_118886;
        // N s_3012_1: branch s_3012_0 b3997 b3013
        if s_3012_0 {
            return block_3997(state, tracer, fn_state);
        } else {
            return block_3013(state, tracer, fn_state);
        };
    }
    fn block_3013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3013_0: const #0u : u8
        let s_3013_0: bool = false;
        // D s_3013_1: write-var gs#118887 <= s_3013_0
        fn_state.gs_118887 = s_3013_0;
        // N s_3013_2: jump b3014
        return block_3014(state, tracer, fn_state);
    }
    fn block_3014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3014_0: read-var gs#118887:u8
        let s_3014_0: bool = fn_state.gs_118887;
        // N s_3014_1: branch s_3014_0 b3996 b3015
        if s_3014_0 {
            return block_3996(state, tracer, fn_state);
        } else {
            return block_3015(state, tracer, fn_state);
        };
    }
    fn block_3015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3015_0: read-var CRm:u8
        let s_3015_0: u8 = fn_state.CRm;
        // D s_3015_1: cast zx s_3015_0 -> bv
        let s_3015_1: Bits = Bits::new(s_3015_0 as u128, 4u16);
        // C s_3015_2: const #15u : u8
        let s_3015_2: u8 = 15;
        // C s_3015_3: cast zx s_3015_2 -> bv
        let s_3015_3: Bits = Bits::new(s_3015_2 as u128, 4u16);
        // D s_3015_4: cmp-eq s_3015_1 s_3015_3
        let s_3015_4: bool = ((s_3015_1) == (s_3015_3));
        // N s_3015_5: branch s_3015_4 b3995 b3016
        if s_3015_4 {
            return block_3995(state, tracer, fn_state);
        } else {
            return block_3016(state, tracer, fn_state);
        };
    }
    fn block_3016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3016_0: const #0u : u8
        let s_3016_0: bool = false;
        // D s_3016_1: write-var gs#118888 <= s_3016_0
        fn_state.gs_118888 = s_3016_0;
        // N s_3016_2: jump b3017
        return block_3017(state, tracer, fn_state);
    }
    fn block_3017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3017_0: read-var gs#118888:u8
        let s_3017_0: bool = fn_state.gs_118888;
        // N s_3017_1: branch s_3017_0 b3994 b3018
        if s_3017_0 {
            return block_3994(state, tracer, fn_state);
        } else {
            return block_3018(state, tracer, fn_state);
        };
    }
    fn block_3018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3018_0: const #0u : u8
        let s_3018_0: bool = false;
        // D s_3018_1: write-var gs#118889 <= s_3018_0
        fn_state.gs_118889 = s_3018_0;
        // N s_3018_2: jump b3019
        return block_3019(state, tracer, fn_state);
    }
    fn block_3019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3019_0: read-var gs#118889:u8
        let s_3019_0: bool = fn_state.gs_118889;
        // N s_3019_1: branch s_3019_0 b3993 b3020
        if s_3019_0 {
            return block_3993(state, tracer, fn_state);
        } else {
            return block_3020(state, tracer, fn_state);
        };
    }
    fn block_3020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3020_0: const #0u : u8
        let s_3020_0: bool = false;
        // D s_3020_1: write-var gs#118890 <= s_3020_0
        fn_state.gs_118890 = s_3020_0;
        // N s_3020_2: jump b3021
        return block_3021(state, tracer, fn_state);
    }
    fn block_3021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3021_0: read-var gs#118890:u8
        let s_3021_0: bool = fn_state.gs_118890;
        // N s_3021_1: branch s_3021_0 b3992 b3022
        if s_3021_0 {
            return block_3992(state, tracer, fn_state);
        } else {
            return block_3022(state, tracer, fn_state);
        };
    }
    fn block_3022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3022_0: const #0u : u8
        let s_3022_0: bool = false;
        // D s_3022_1: write-var gs#118891 <= s_3022_0
        fn_state.gs_118891 = s_3022_0;
        // N s_3022_2: jump b3023
        return block_3023(state, tracer, fn_state);
    }
    fn block_3023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3023_0: read-var gs#118891:u8
        let s_3023_0: bool = fn_state.gs_118891;
        // N s_3023_1: branch s_3023_0 b3991 b3024
        if s_3023_0 {
            return block_3991(state, tracer, fn_state);
        } else {
            return block_3024(state, tracer, fn_state);
        };
    }
    fn block_3024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3024_0: read-var CRm:u8
        let s_3024_0: u8 = fn_state.CRm;
        // D s_3024_1: cast zx s_3024_0 -> bv
        let s_3024_1: Bits = Bits::new(s_3024_0 as u128, 4u16);
        // C s_3024_2: const #15u : u8
        let s_3024_2: u8 = 15;
        // C s_3024_3: cast zx s_3024_2 -> bv
        let s_3024_3: Bits = Bits::new(s_3024_2 as u128, 4u16);
        // D s_3024_4: cmp-eq s_3024_1 s_3024_3
        let s_3024_4: bool = ((s_3024_1) == (s_3024_3));
        // N s_3024_5: branch s_3024_4 b3990 b3025
        if s_3024_4 {
            return block_3990(state, tracer, fn_state);
        } else {
            return block_3025(state, tracer, fn_state);
        };
    }
    fn block_3025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3025_0: const #0u : u8
        let s_3025_0: bool = false;
        // D s_3025_1: write-var gs#118892 <= s_3025_0
        fn_state.gs_118892 = s_3025_0;
        // N s_3025_2: jump b3026
        return block_3026(state, tracer, fn_state);
    }
    fn block_3026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3026_0: read-var gs#118892:u8
        let s_3026_0: bool = fn_state.gs_118892;
        // N s_3026_1: branch s_3026_0 b3989 b3027
        if s_3026_0 {
            return block_3989(state, tracer, fn_state);
        } else {
            return block_3027(state, tracer, fn_state);
        };
    }
    fn block_3027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3027_0: const #0u : u8
        let s_3027_0: bool = false;
        // D s_3027_1: write-var gs#118893 <= s_3027_0
        fn_state.gs_118893 = s_3027_0;
        // N s_3027_2: jump b3028
        return block_3028(state, tracer, fn_state);
    }
    fn block_3028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3028_0: read-var gs#118893:u8
        let s_3028_0: bool = fn_state.gs_118893;
        // N s_3028_1: branch s_3028_0 b3988 b3029
        if s_3028_0 {
            return block_3988(state, tracer, fn_state);
        } else {
            return block_3029(state, tracer, fn_state);
        };
    }
    fn block_3029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3029_0: const #0u : u8
        let s_3029_0: bool = false;
        // D s_3029_1: write-var gs#118894 <= s_3029_0
        fn_state.gs_118894 = s_3029_0;
        // N s_3029_2: jump b3030
        return block_3030(state, tracer, fn_state);
    }
    fn block_3030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3030_0: read-var gs#118894:u8
        let s_3030_0: bool = fn_state.gs_118894;
        // N s_3030_1: branch s_3030_0 b3987 b3031
        if s_3030_0 {
            return block_3987(state, tracer, fn_state);
        } else {
            return block_3031(state, tracer, fn_state);
        };
    }
    fn block_3031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3031_0: const #0u : u8
        let s_3031_0: bool = false;
        // D s_3031_1: write-var gs#118895 <= s_3031_0
        fn_state.gs_118895 = s_3031_0;
        // N s_3031_2: jump b3032
        return block_3032(state, tracer, fn_state);
    }
    fn block_3032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3032_0: read-var gs#118895:u8
        let s_3032_0: bool = fn_state.gs_118895;
        // N s_3032_1: branch s_3032_0 b3986 b3033
        if s_3032_0 {
            return block_3986(state, tracer, fn_state);
        } else {
            return block_3033(state, tracer, fn_state);
        };
    }
    fn block_3033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3033_0: read-var CRm:u8
        let s_3033_0: u8 = fn_state.CRm;
        // D s_3033_1: cast zx s_3033_0 -> bv
        let s_3033_1: Bits = Bits::new(s_3033_0 as u128, 4u16);
        // C s_3033_2: const #15u : u8
        let s_3033_2: u8 = 15;
        // C s_3033_3: cast zx s_3033_2 -> bv
        let s_3033_3: Bits = Bits::new(s_3033_2 as u128, 4u16);
        // D s_3033_4: cmp-eq s_3033_1 s_3033_3
        let s_3033_4: bool = ((s_3033_1) == (s_3033_3));
        // N s_3033_5: branch s_3033_4 b3985 b3034
        if s_3033_4 {
            return block_3985(state, tracer, fn_state);
        } else {
            return block_3034(state, tracer, fn_state);
        };
    }
    fn block_3034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3034_0: const #0u : u8
        let s_3034_0: bool = false;
        // D s_3034_1: write-var gs#118896 <= s_3034_0
        fn_state.gs_118896 = s_3034_0;
        // N s_3034_2: jump b3035
        return block_3035(state, tracer, fn_state);
    }
    fn block_3035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3035_0: read-var gs#118896:u8
        let s_3035_0: bool = fn_state.gs_118896;
        // N s_3035_1: branch s_3035_0 b3984 b3036
        if s_3035_0 {
            return block_3984(state, tracer, fn_state);
        } else {
            return block_3036(state, tracer, fn_state);
        };
    }
    fn block_3036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3036_0: const #0u : u8
        let s_3036_0: bool = false;
        // D s_3036_1: write-var gs#118897 <= s_3036_0
        fn_state.gs_118897 = s_3036_0;
        // N s_3036_2: jump b3037
        return block_3037(state, tracer, fn_state);
    }
    fn block_3037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3037_0: read-var gs#118897:u8
        let s_3037_0: bool = fn_state.gs_118897;
        // N s_3037_1: branch s_3037_0 b3983 b3038
        if s_3037_0 {
            return block_3983(state, tracer, fn_state);
        } else {
            return block_3038(state, tracer, fn_state);
        };
    }
    fn block_3038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3038_0: const #0u : u8
        let s_3038_0: bool = false;
        // D s_3038_1: write-var gs#118898 <= s_3038_0
        fn_state.gs_118898 = s_3038_0;
        // N s_3038_2: jump b3039
        return block_3039(state, tracer, fn_state);
    }
    fn block_3039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3039_0: read-var gs#118898:u8
        let s_3039_0: bool = fn_state.gs_118898;
        // N s_3039_1: branch s_3039_0 b3982 b3040
        if s_3039_0 {
            return block_3982(state, tracer, fn_state);
        } else {
            return block_3040(state, tracer, fn_state);
        };
    }
    fn block_3040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3040_0: const #0u : u8
        let s_3040_0: bool = false;
        // D s_3040_1: write-var gs#118899 <= s_3040_0
        fn_state.gs_118899 = s_3040_0;
        // N s_3040_2: jump b3041
        return block_3041(state, tracer, fn_state);
    }
    fn block_3041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3041_0: read-var gs#118899:u8
        let s_3041_0: bool = fn_state.gs_118899;
        // N s_3041_1: branch s_3041_0 b3981 b3042
        if s_3041_0 {
            return block_3981(state, tracer, fn_state);
        } else {
            return block_3042(state, tracer, fn_state);
        };
    }
    fn block_3042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3042_0: read-var CRm:u8
        let s_3042_0: u8 = fn_state.CRm;
        // D s_3042_1: cast zx s_3042_0 -> bv
        let s_3042_1: Bits = Bits::new(s_3042_0 as u128, 4u16);
        // C s_3042_2: const #15u : u8
        let s_3042_2: u8 = 15;
        // C s_3042_3: cast zx s_3042_2 -> bv
        let s_3042_3: Bits = Bits::new(s_3042_2 as u128, 4u16);
        // D s_3042_4: cmp-eq s_3042_1 s_3042_3
        let s_3042_4: bool = ((s_3042_1) == (s_3042_3));
        // N s_3042_5: branch s_3042_4 b3980 b3043
        if s_3042_4 {
            return block_3980(state, tracer, fn_state);
        } else {
            return block_3043(state, tracer, fn_state);
        };
    }
    fn block_3043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3043_0: const #0u : u8
        let s_3043_0: bool = false;
        // D s_3043_1: write-var gs#118900 <= s_3043_0
        fn_state.gs_118900 = s_3043_0;
        // N s_3043_2: jump b3044
        return block_3044(state, tracer, fn_state);
    }
    fn block_3044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3044_0: read-var gs#118900:u8
        let s_3044_0: bool = fn_state.gs_118900;
        // N s_3044_1: branch s_3044_0 b3979 b3045
        if s_3044_0 {
            return block_3979(state, tracer, fn_state);
        } else {
            return block_3045(state, tracer, fn_state);
        };
    }
    fn block_3045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3045_0: const #0u : u8
        let s_3045_0: bool = false;
        // D s_3045_1: write-var gs#118901 <= s_3045_0
        fn_state.gs_118901 = s_3045_0;
        // N s_3045_2: jump b3046
        return block_3046(state, tracer, fn_state);
    }
    fn block_3046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3046_0: read-var gs#118901:u8
        let s_3046_0: bool = fn_state.gs_118901;
        // N s_3046_1: branch s_3046_0 b3978 b3047
        if s_3046_0 {
            return block_3978(state, tracer, fn_state);
        } else {
            return block_3047(state, tracer, fn_state);
        };
    }
    fn block_3047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3047_0: const #0u : u8
        let s_3047_0: bool = false;
        // D s_3047_1: write-var gs#118902 <= s_3047_0
        fn_state.gs_118902 = s_3047_0;
        // N s_3047_2: jump b3048
        return block_3048(state, tracer, fn_state);
    }
    fn block_3048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3048_0: read-var gs#118902:u8
        let s_3048_0: bool = fn_state.gs_118902;
        // N s_3048_1: branch s_3048_0 b3977 b3049
        if s_3048_0 {
            return block_3977(state, tracer, fn_state);
        } else {
            return block_3049(state, tracer, fn_state);
        };
    }
    fn block_3049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3049_0: const #0u : u8
        let s_3049_0: bool = false;
        // D s_3049_1: write-var gs#118903 <= s_3049_0
        fn_state.gs_118903 = s_3049_0;
        // N s_3049_2: jump b3050
        return block_3050(state, tracer, fn_state);
    }
    fn block_3050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3050_0: read-var gs#118903:u8
        let s_3050_0: bool = fn_state.gs_118903;
        // N s_3050_1: branch s_3050_0 b3976 b3051
        if s_3050_0 {
            return block_3976(state, tracer, fn_state);
        } else {
            return block_3051(state, tracer, fn_state);
        };
    }
    fn block_3051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3051_0: read-var CRm:u8
        let s_3051_0: u8 = fn_state.CRm;
        // D s_3051_1: cast zx s_3051_0 -> bv
        let s_3051_1: Bits = Bits::new(s_3051_0 as u128, 4u16);
        // C s_3051_2: const #15u : u8
        let s_3051_2: u8 = 15;
        // C s_3051_3: cast zx s_3051_2 -> bv
        let s_3051_3: Bits = Bits::new(s_3051_2 as u128, 4u16);
        // D s_3051_4: cmp-eq s_3051_1 s_3051_3
        let s_3051_4: bool = ((s_3051_1) == (s_3051_3));
        // N s_3051_5: branch s_3051_4 b3975 b3052
        if s_3051_4 {
            return block_3975(state, tracer, fn_state);
        } else {
            return block_3052(state, tracer, fn_state);
        };
    }
    fn block_3052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3052_0: const #0u : u8
        let s_3052_0: bool = false;
        // D s_3052_1: write-var gs#118904 <= s_3052_0
        fn_state.gs_118904 = s_3052_0;
        // N s_3052_2: jump b3053
        return block_3053(state, tracer, fn_state);
    }
    fn block_3053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3053_0: read-var gs#118904:u8
        let s_3053_0: bool = fn_state.gs_118904;
        // N s_3053_1: branch s_3053_0 b3974 b3054
        if s_3053_0 {
            return block_3974(state, tracer, fn_state);
        } else {
            return block_3054(state, tracer, fn_state);
        };
    }
    fn block_3054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3054_0: const #0u : u8
        let s_3054_0: bool = false;
        // D s_3054_1: write-var gs#118905 <= s_3054_0
        fn_state.gs_118905 = s_3054_0;
        // N s_3054_2: jump b3055
        return block_3055(state, tracer, fn_state);
    }
    fn block_3055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3055_0: read-var gs#118905:u8
        let s_3055_0: bool = fn_state.gs_118905;
        // N s_3055_1: branch s_3055_0 b3973 b3056
        if s_3055_0 {
            return block_3973(state, tracer, fn_state);
        } else {
            return block_3056(state, tracer, fn_state);
        };
    }
    fn block_3056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3056_0: const #0u : u8
        let s_3056_0: bool = false;
        // D s_3056_1: write-var gs#118906 <= s_3056_0
        fn_state.gs_118906 = s_3056_0;
        // N s_3056_2: jump b3057
        return block_3057(state, tracer, fn_state);
    }
    fn block_3057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3057_0: read-var gs#118906:u8
        let s_3057_0: bool = fn_state.gs_118906;
        // N s_3057_1: branch s_3057_0 b3972 b3058
        if s_3057_0 {
            return block_3972(state, tracer, fn_state);
        } else {
            return block_3058(state, tracer, fn_state);
        };
    }
    fn block_3058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3058_0: const #0u : u8
        let s_3058_0: bool = false;
        // D s_3058_1: write-var gs#118907 <= s_3058_0
        fn_state.gs_118907 = s_3058_0;
        // N s_3058_2: jump b3059
        return block_3059(state, tracer, fn_state);
    }
    fn block_3059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3059_0: read-var gs#118907:u8
        let s_3059_0: bool = fn_state.gs_118907;
        // N s_3059_1: branch s_3059_0 b3971 b3060
        if s_3059_0 {
            return block_3971(state, tracer, fn_state);
        } else {
            return block_3060(state, tracer, fn_state);
        };
    }
    fn block_3060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3060_0: read-var CRm:u8
        let s_3060_0: u8 = fn_state.CRm;
        // D s_3060_1: cast zx s_3060_0 -> bv
        let s_3060_1: Bits = Bits::new(s_3060_0 as u128, 4u16);
        // C s_3060_2: const #15u : u8
        let s_3060_2: u8 = 15;
        // C s_3060_3: cast zx s_3060_2 -> bv
        let s_3060_3: Bits = Bits::new(s_3060_2 as u128, 4u16);
        // D s_3060_4: cmp-eq s_3060_1 s_3060_3
        let s_3060_4: bool = ((s_3060_1) == (s_3060_3));
        // N s_3060_5: branch s_3060_4 b3970 b3061
        if s_3060_4 {
            return block_3970(state, tracer, fn_state);
        } else {
            return block_3061(state, tracer, fn_state);
        };
    }
    fn block_3061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3061_0: const #0u : u8
        let s_3061_0: bool = false;
        // D s_3061_1: write-var gs#118908 <= s_3061_0
        fn_state.gs_118908 = s_3061_0;
        // N s_3061_2: jump b3062
        return block_3062(state, tracer, fn_state);
    }
    fn block_3062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3062_0: read-var gs#118908:u8
        let s_3062_0: bool = fn_state.gs_118908;
        // N s_3062_1: branch s_3062_0 b3969 b3063
        if s_3062_0 {
            return block_3969(state, tracer, fn_state);
        } else {
            return block_3063(state, tracer, fn_state);
        };
    }
    fn block_3063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3063_0: const #0u : u8
        let s_3063_0: bool = false;
        // D s_3063_1: write-var gs#118909 <= s_3063_0
        fn_state.gs_118909 = s_3063_0;
        // N s_3063_2: jump b3064
        return block_3064(state, tracer, fn_state);
    }
    fn block_3064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3064_0: read-var gs#118909:u8
        let s_3064_0: bool = fn_state.gs_118909;
        // N s_3064_1: branch s_3064_0 b3968 b3065
        if s_3064_0 {
            return block_3968(state, tracer, fn_state);
        } else {
            return block_3065(state, tracer, fn_state);
        };
    }
    fn block_3065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3065_0: const #0u : u8
        let s_3065_0: bool = false;
        // D s_3065_1: write-var gs#118910 <= s_3065_0
        fn_state.gs_118910 = s_3065_0;
        // N s_3065_2: jump b3066
        return block_3066(state, tracer, fn_state);
    }
    fn block_3066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3066_0: read-var gs#118910:u8
        let s_3066_0: bool = fn_state.gs_118910;
        // N s_3066_1: branch s_3066_0 b3967 b3067
        if s_3066_0 {
            return block_3967(state, tracer, fn_state);
        } else {
            return block_3067(state, tracer, fn_state);
        };
    }
    fn block_3067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3067_0: const #0u : u8
        let s_3067_0: bool = false;
        // D s_3067_1: write-var gs#118911 <= s_3067_0
        fn_state.gs_118911 = s_3067_0;
        // N s_3067_2: jump b3068
        return block_3068(state, tracer, fn_state);
    }
    fn block_3068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3068_0: read-var gs#118911:u8
        let s_3068_0: bool = fn_state.gs_118911;
        // N s_3068_1: branch s_3068_0 b3966 b3069
        if s_3068_0 {
            return block_3966(state, tracer, fn_state);
        } else {
            return block_3069(state, tracer, fn_state);
        };
    }
    fn block_3069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3069_0: read-var CRm:u8
        let s_3069_0: u8 = fn_state.CRm;
        // D s_3069_1: cast zx s_3069_0 -> bv
        let s_3069_1: Bits = Bits::new(s_3069_0 as u128, 4u16);
        // C s_3069_2: const #15u : u8
        let s_3069_2: u8 = 15;
        // C s_3069_3: cast zx s_3069_2 -> bv
        let s_3069_3: Bits = Bits::new(s_3069_2 as u128, 4u16);
        // D s_3069_4: cmp-eq s_3069_1 s_3069_3
        let s_3069_4: bool = ((s_3069_1) == (s_3069_3));
        // N s_3069_5: branch s_3069_4 b3965 b3070
        if s_3069_4 {
            return block_3965(state, tracer, fn_state);
        } else {
            return block_3070(state, tracer, fn_state);
        };
    }
    fn block_3070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3070_0: const #0u : u8
        let s_3070_0: bool = false;
        // D s_3070_1: write-var gs#118912 <= s_3070_0
        fn_state.gs_118912 = s_3070_0;
        // N s_3070_2: jump b3071
        return block_3071(state, tracer, fn_state);
    }
    fn block_3071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3071_0: read-var gs#118912:u8
        let s_3071_0: bool = fn_state.gs_118912;
        // N s_3071_1: branch s_3071_0 b3964 b3072
        if s_3071_0 {
            return block_3964(state, tracer, fn_state);
        } else {
            return block_3072(state, tracer, fn_state);
        };
    }
    fn block_3072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3072_0: const #0u : u8
        let s_3072_0: bool = false;
        // D s_3072_1: write-var gs#118913 <= s_3072_0
        fn_state.gs_118913 = s_3072_0;
        // N s_3072_2: jump b3073
        return block_3073(state, tracer, fn_state);
    }
    fn block_3073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3073_0: read-var gs#118913:u8
        let s_3073_0: bool = fn_state.gs_118913;
        // N s_3073_1: branch s_3073_0 b3963 b3074
        if s_3073_0 {
            return block_3963(state, tracer, fn_state);
        } else {
            return block_3074(state, tracer, fn_state);
        };
    }
    fn block_3074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3074_0: const #0u : u8
        let s_3074_0: bool = false;
        // D s_3074_1: write-var gs#118914 <= s_3074_0
        fn_state.gs_118914 = s_3074_0;
        // N s_3074_2: jump b3075
        return block_3075(state, tracer, fn_state);
    }
    fn block_3075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3075_0: read-var gs#118914:u8
        let s_3075_0: bool = fn_state.gs_118914;
        // N s_3075_1: branch s_3075_0 b3962 b3076
        if s_3075_0 {
            return block_3962(state, tracer, fn_state);
        } else {
            return block_3076(state, tracer, fn_state);
        };
    }
    fn block_3076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3076_0: const #0u : u8
        let s_3076_0: bool = false;
        // D s_3076_1: write-var gs#118915 <= s_3076_0
        fn_state.gs_118915 = s_3076_0;
        // N s_3076_2: jump b3077
        return block_3077(state, tracer, fn_state);
    }
    fn block_3077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3077_0: read-var gs#118915:u8
        let s_3077_0: bool = fn_state.gs_118915;
        // N s_3077_1: branch s_3077_0 b3961 b3078
        if s_3077_0 {
            return block_3961(state, tracer, fn_state);
        } else {
            return block_3078(state, tracer, fn_state);
        };
    }
    fn block_3078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3078_0: read-var CRm:u8
        let s_3078_0: u8 = fn_state.CRm;
        // D s_3078_1: cast zx s_3078_0 -> bv
        let s_3078_1: Bits = Bits::new(s_3078_0 as u128, 4u16);
        // C s_3078_2: const #15u : u8
        let s_3078_2: u8 = 15;
        // C s_3078_3: cast zx s_3078_2 -> bv
        let s_3078_3: Bits = Bits::new(s_3078_2 as u128, 4u16);
        // D s_3078_4: cmp-eq s_3078_1 s_3078_3
        let s_3078_4: bool = ((s_3078_1) == (s_3078_3));
        // N s_3078_5: branch s_3078_4 b3960 b3079
        if s_3078_4 {
            return block_3960(state, tracer, fn_state);
        } else {
            return block_3079(state, tracer, fn_state);
        };
    }
    fn block_3079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3079_0: const #0u : u8
        let s_3079_0: bool = false;
        // D s_3079_1: write-var gs#118916 <= s_3079_0
        fn_state.gs_118916 = s_3079_0;
        // N s_3079_2: jump b3080
        return block_3080(state, tracer, fn_state);
    }
    fn block_3080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3080_0: read-var gs#118916:u8
        let s_3080_0: bool = fn_state.gs_118916;
        // N s_3080_1: branch s_3080_0 b3959 b3081
        if s_3080_0 {
            return block_3959(state, tracer, fn_state);
        } else {
            return block_3081(state, tracer, fn_state);
        };
    }
    fn block_3081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3081_0: const #0u : u8
        let s_3081_0: bool = false;
        // D s_3081_1: write-var gs#118917 <= s_3081_0
        fn_state.gs_118917 = s_3081_0;
        // N s_3081_2: jump b3082
        return block_3082(state, tracer, fn_state);
    }
    fn block_3082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3082_0: read-var gs#118917:u8
        let s_3082_0: bool = fn_state.gs_118917;
        // N s_3082_1: branch s_3082_0 b3958 b3083
        if s_3082_0 {
            return block_3958(state, tracer, fn_state);
        } else {
            return block_3083(state, tracer, fn_state);
        };
    }
    fn block_3083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3083_0: const #0u : u8
        let s_3083_0: bool = false;
        // D s_3083_1: write-var gs#118918 <= s_3083_0
        fn_state.gs_118918 = s_3083_0;
        // N s_3083_2: jump b3084
        return block_3084(state, tracer, fn_state);
    }
    fn block_3084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3084_0: read-var gs#118918:u8
        let s_3084_0: bool = fn_state.gs_118918;
        // N s_3084_1: branch s_3084_0 b3957 b3085
        if s_3084_0 {
            return block_3957(state, tracer, fn_state);
        } else {
            return block_3085(state, tracer, fn_state);
        };
    }
    fn block_3085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3085_0: const #0u : u8
        let s_3085_0: bool = false;
        // D s_3085_1: write-var gs#118919 <= s_3085_0
        fn_state.gs_118919 = s_3085_0;
        // N s_3085_2: jump b3086
        return block_3086(state, tracer, fn_state);
    }
    fn block_3086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3086_0: read-var gs#118919:u8
        let s_3086_0: bool = fn_state.gs_118919;
        // N s_3086_1: branch s_3086_0 b3956 b3087
        if s_3086_0 {
            return block_3956(state, tracer, fn_state);
        } else {
            return block_3087(state, tracer, fn_state);
        };
    }
    fn block_3087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3087_0: read-var CRm:u8
        let s_3087_0: u8 = fn_state.CRm;
        // D s_3087_1: cast zx s_3087_0 -> bv
        let s_3087_1: Bits = Bits::new(s_3087_0 as u128, 4u16);
        // C s_3087_2: const #14u : u8
        let s_3087_2: u8 = 14;
        // C s_3087_3: cast zx s_3087_2 -> bv
        let s_3087_3: Bits = Bits::new(s_3087_2 as u128, 4u16);
        // D s_3087_4: cmp-eq s_3087_1 s_3087_3
        let s_3087_4: bool = ((s_3087_1) == (s_3087_3));
        // N s_3087_5: branch s_3087_4 b3955 b3088
        if s_3087_4 {
            return block_3955(state, tracer, fn_state);
        } else {
            return block_3088(state, tracer, fn_state);
        };
    }
    fn block_3088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3088_0: const #0u : u8
        let s_3088_0: bool = false;
        // D s_3088_1: write-var gs#118920 <= s_3088_0
        fn_state.gs_118920 = s_3088_0;
        // N s_3088_2: jump b3089
        return block_3089(state, tracer, fn_state);
    }
    fn block_3089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3089_0: read-var gs#118920:u8
        let s_3089_0: bool = fn_state.gs_118920;
        // N s_3089_1: branch s_3089_0 b3954 b3090
        if s_3089_0 {
            return block_3954(state, tracer, fn_state);
        } else {
            return block_3090(state, tracer, fn_state);
        };
    }
    fn block_3090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3090_0: const #0u : u8
        let s_3090_0: bool = false;
        // D s_3090_1: write-var gs#118921 <= s_3090_0
        fn_state.gs_118921 = s_3090_0;
        // N s_3090_2: jump b3091
        return block_3091(state, tracer, fn_state);
    }
    fn block_3091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3091_0: read-var gs#118921:u8
        let s_3091_0: bool = fn_state.gs_118921;
        // N s_3091_1: branch s_3091_0 b3953 b3092
        if s_3091_0 {
            return block_3953(state, tracer, fn_state);
        } else {
            return block_3092(state, tracer, fn_state);
        };
    }
    fn block_3092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3092_0: const #0u : u8
        let s_3092_0: bool = false;
        // D s_3092_1: write-var gs#118922 <= s_3092_0
        fn_state.gs_118922 = s_3092_0;
        // N s_3092_2: jump b3093
        return block_3093(state, tracer, fn_state);
    }
    fn block_3093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3093_0: read-var gs#118922:u8
        let s_3093_0: bool = fn_state.gs_118922;
        // N s_3093_1: branch s_3093_0 b3952 b3094
        if s_3093_0 {
            return block_3952(state, tracer, fn_state);
        } else {
            return block_3094(state, tracer, fn_state);
        };
    }
    fn block_3094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3094_0: const #0u : u8
        let s_3094_0: bool = false;
        // D s_3094_1: write-var gs#118923 <= s_3094_0
        fn_state.gs_118923 = s_3094_0;
        // N s_3094_2: jump b3095
        return block_3095(state, tracer, fn_state);
    }
    fn block_3095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3095_0: read-var gs#118923:u8
        let s_3095_0: bool = fn_state.gs_118923;
        // N s_3095_1: branch s_3095_0 b3951 b3096
        if s_3095_0 {
            return block_3951(state, tracer, fn_state);
        } else {
            return block_3096(state, tracer, fn_state);
        };
    }
    fn block_3096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3096_0: read-var CRm:u8
        let s_3096_0: u8 = fn_state.CRm;
        // D s_3096_1: cast zx s_3096_0 -> bv
        let s_3096_1: Bits = Bits::new(s_3096_0 as u128, 4u16);
        // C s_3096_2: const #14u : u8
        let s_3096_2: u8 = 14;
        // C s_3096_3: cast zx s_3096_2 -> bv
        let s_3096_3: Bits = Bits::new(s_3096_2 as u128, 4u16);
        // D s_3096_4: cmp-eq s_3096_1 s_3096_3
        let s_3096_4: bool = ((s_3096_1) == (s_3096_3));
        // N s_3096_5: branch s_3096_4 b3950 b3097
        if s_3096_4 {
            return block_3950(state, tracer, fn_state);
        } else {
            return block_3097(state, tracer, fn_state);
        };
    }
    fn block_3097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3097_0: const #0u : u8
        let s_3097_0: bool = false;
        // D s_3097_1: write-var gs#118924 <= s_3097_0
        fn_state.gs_118924 = s_3097_0;
        // N s_3097_2: jump b3098
        return block_3098(state, tracer, fn_state);
    }
    fn block_3098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3098_0: read-var gs#118924:u8
        let s_3098_0: bool = fn_state.gs_118924;
        // N s_3098_1: branch s_3098_0 b3949 b3099
        if s_3098_0 {
            return block_3949(state, tracer, fn_state);
        } else {
            return block_3099(state, tracer, fn_state);
        };
    }
    fn block_3099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3099_0: const #0u : u8
        let s_3099_0: bool = false;
        // D s_3099_1: write-var gs#118925 <= s_3099_0
        fn_state.gs_118925 = s_3099_0;
        // N s_3099_2: jump b3100
        return block_3100(state, tracer, fn_state);
    }
    fn block_3100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3100_0: read-var gs#118925:u8
        let s_3100_0: bool = fn_state.gs_118925;
        // N s_3100_1: branch s_3100_0 b3948 b3101
        if s_3100_0 {
            return block_3948(state, tracer, fn_state);
        } else {
            return block_3101(state, tracer, fn_state);
        };
    }
    fn block_3101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3101_0: const #0u : u8
        let s_3101_0: bool = false;
        // D s_3101_1: write-var gs#118926 <= s_3101_0
        fn_state.gs_118926 = s_3101_0;
        // N s_3101_2: jump b3102
        return block_3102(state, tracer, fn_state);
    }
    fn block_3102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3102_0: read-var gs#118926:u8
        let s_3102_0: bool = fn_state.gs_118926;
        // N s_3102_1: branch s_3102_0 b3947 b3103
        if s_3102_0 {
            return block_3947(state, tracer, fn_state);
        } else {
            return block_3103(state, tracer, fn_state);
        };
    }
    fn block_3103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3103_0: const #0u : u8
        let s_3103_0: bool = false;
        // D s_3103_1: write-var gs#118927 <= s_3103_0
        fn_state.gs_118927 = s_3103_0;
        // N s_3103_2: jump b3104
        return block_3104(state, tracer, fn_state);
    }
    fn block_3104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3104_0: read-var gs#118927:u8
        let s_3104_0: bool = fn_state.gs_118927;
        // N s_3104_1: branch s_3104_0 b3946 b3105
        if s_3104_0 {
            return block_3946(state, tracer, fn_state);
        } else {
            return block_3105(state, tracer, fn_state);
        };
    }
    fn block_3105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3105_0: read-var CRm:u8
        let s_3105_0: u8 = fn_state.CRm;
        // D s_3105_1: cast zx s_3105_0 -> bv
        let s_3105_1: Bits = Bits::new(s_3105_0 as u128, 4u16);
        // C s_3105_2: const #14u : u8
        let s_3105_2: u8 = 14;
        // C s_3105_3: cast zx s_3105_2 -> bv
        let s_3105_3: Bits = Bits::new(s_3105_2 as u128, 4u16);
        // D s_3105_4: cmp-eq s_3105_1 s_3105_3
        let s_3105_4: bool = ((s_3105_1) == (s_3105_3));
        // N s_3105_5: branch s_3105_4 b3945 b3106
        if s_3105_4 {
            return block_3945(state, tracer, fn_state);
        } else {
            return block_3106(state, tracer, fn_state);
        };
    }
    fn block_3106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3106_0: const #0u : u8
        let s_3106_0: bool = false;
        // D s_3106_1: write-var gs#118928 <= s_3106_0
        fn_state.gs_118928 = s_3106_0;
        // N s_3106_2: jump b3107
        return block_3107(state, tracer, fn_state);
    }
    fn block_3107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3107_0: read-var gs#118928:u8
        let s_3107_0: bool = fn_state.gs_118928;
        // N s_3107_1: branch s_3107_0 b3944 b3108
        if s_3107_0 {
            return block_3944(state, tracer, fn_state);
        } else {
            return block_3108(state, tracer, fn_state);
        };
    }
    fn block_3108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3108_0: const #0u : u8
        let s_3108_0: bool = false;
        // D s_3108_1: write-var gs#118929 <= s_3108_0
        fn_state.gs_118929 = s_3108_0;
        // N s_3108_2: jump b3109
        return block_3109(state, tracer, fn_state);
    }
    fn block_3109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3109_0: read-var gs#118929:u8
        let s_3109_0: bool = fn_state.gs_118929;
        // N s_3109_1: branch s_3109_0 b3943 b3110
        if s_3109_0 {
            return block_3943(state, tracer, fn_state);
        } else {
            return block_3110(state, tracer, fn_state);
        };
    }
    fn block_3110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3110_0: const #0u : u8
        let s_3110_0: bool = false;
        // D s_3110_1: write-var gs#118930 <= s_3110_0
        fn_state.gs_118930 = s_3110_0;
        // N s_3110_2: jump b3111
        return block_3111(state, tracer, fn_state);
    }
    fn block_3111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3111_0: read-var gs#118930:u8
        let s_3111_0: bool = fn_state.gs_118930;
        // N s_3111_1: branch s_3111_0 b3942 b3112
        if s_3111_0 {
            return block_3942(state, tracer, fn_state);
        } else {
            return block_3112(state, tracer, fn_state);
        };
    }
    fn block_3112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3112_0: const #0u : u8
        let s_3112_0: bool = false;
        // D s_3112_1: write-var gs#118931 <= s_3112_0
        fn_state.gs_118931 = s_3112_0;
        // N s_3112_2: jump b3113
        return block_3113(state, tracer, fn_state);
    }
    fn block_3113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3113_0: read-var gs#118931:u8
        let s_3113_0: bool = fn_state.gs_118931;
        // N s_3113_1: branch s_3113_0 b3941 b3114
        if s_3113_0 {
            return block_3941(state, tracer, fn_state);
        } else {
            return block_3114(state, tracer, fn_state);
        };
    }
    fn block_3114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3114_0: read-var CRm:u8
        let s_3114_0: u8 = fn_state.CRm;
        // D s_3114_1: cast zx s_3114_0 -> bv
        let s_3114_1: Bits = Bits::new(s_3114_0 as u128, 4u16);
        // C s_3114_2: const #14u : u8
        let s_3114_2: u8 = 14;
        // C s_3114_3: cast zx s_3114_2 -> bv
        let s_3114_3: Bits = Bits::new(s_3114_2 as u128, 4u16);
        // D s_3114_4: cmp-eq s_3114_1 s_3114_3
        let s_3114_4: bool = ((s_3114_1) == (s_3114_3));
        // N s_3114_5: branch s_3114_4 b3940 b3115
        if s_3114_4 {
            return block_3940(state, tracer, fn_state);
        } else {
            return block_3115(state, tracer, fn_state);
        };
    }
    fn block_3115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3115_0: const #0u : u8
        let s_3115_0: bool = false;
        // D s_3115_1: write-var gs#118932 <= s_3115_0
        fn_state.gs_118932 = s_3115_0;
        // N s_3115_2: jump b3116
        return block_3116(state, tracer, fn_state);
    }
    fn block_3116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3116_0: read-var gs#118932:u8
        let s_3116_0: bool = fn_state.gs_118932;
        // N s_3116_1: branch s_3116_0 b3939 b3117
        if s_3116_0 {
            return block_3939(state, tracer, fn_state);
        } else {
            return block_3117(state, tracer, fn_state);
        };
    }
    fn block_3117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3117_0: const #0u : u8
        let s_3117_0: bool = false;
        // D s_3117_1: write-var gs#118933 <= s_3117_0
        fn_state.gs_118933 = s_3117_0;
        // N s_3117_2: jump b3118
        return block_3118(state, tracer, fn_state);
    }
    fn block_3118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3118_0: read-var gs#118933:u8
        let s_3118_0: bool = fn_state.gs_118933;
        // N s_3118_1: branch s_3118_0 b3938 b3119
        if s_3118_0 {
            return block_3938(state, tracer, fn_state);
        } else {
            return block_3119(state, tracer, fn_state);
        };
    }
    fn block_3119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3119_0: const #0u : u8
        let s_3119_0: bool = false;
        // D s_3119_1: write-var gs#118934 <= s_3119_0
        fn_state.gs_118934 = s_3119_0;
        // N s_3119_2: jump b3120
        return block_3120(state, tracer, fn_state);
    }
    fn block_3120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3120_0: read-var gs#118934:u8
        let s_3120_0: bool = fn_state.gs_118934;
        // N s_3120_1: branch s_3120_0 b3937 b3121
        if s_3120_0 {
            return block_3937(state, tracer, fn_state);
        } else {
            return block_3121(state, tracer, fn_state);
        };
    }
    fn block_3121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3121_0: const #0u : u8
        let s_3121_0: bool = false;
        // D s_3121_1: write-var gs#118935 <= s_3121_0
        fn_state.gs_118935 = s_3121_0;
        // N s_3121_2: jump b3122
        return block_3122(state, tracer, fn_state);
    }
    fn block_3122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3122_0: read-var gs#118935:u8
        let s_3122_0: bool = fn_state.gs_118935;
        // N s_3122_1: branch s_3122_0 b3936 b3123
        if s_3122_0 {
            return block_3936(state, tracer, fn_state);
        } else {
            return block_3123(state, tracer, fn_state);
        };
    }
    fn block_3123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3123_0: read-var CRm:u8
        let s_3123_0: u8 = fn_state.CRm;
        // D s_3123_1: cast zx s_3123_0 -> bv
        let s_3123_1: Bits = Bits::new(s_3123_0 as u128, 4u16);
        // C s_3123_2: const #14u : u8
        let s_3123_2: u8 = 14;
        // C s_3123_3: cast zx s_3123_2 -> bv
        let s_3123_3: Bits = Bits::new(s_3123_2 as u128, 4u16);
        // D s_3123_4: cmp-eq s_3123_1 s_3123_3
        let s_3123_4: bool = ((s_3123_1) == (s_3123_3));
        // N s_3123_5: branch s_3123_4 b3935 b3124
        if s_3123_4 {
            return block_3935(state, tracer, fn_state);
        } else {
            return block_3124(state, tracer, fn_state);
        };
    }
    fn block_3124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3124_0: const #0u : u8
        let s_3124_0: bool = false;
        // D s_3124_1: write-var gs#118936 <= s_3124_0
        fn_state.gs_118936 = s_3124_0;
        // N s_3124_2: jump b3125
        return block_3125(state, tracer, fn_state);
    }
    fn block_3125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3125_0: read-var gs#118936:u8
        let s_3125_0: bool = fn_state.gs_118936;
        // N s_3125_1: branch s_3125_0 b3934 b3126
        if s_3125_0 {
            return block_3934(state, tracer, fn_state);
        } else {
            return block_3126(state, tracer, fn_state);
        };
    }
    fn block_3126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3126_0: const #0u : u8
        let s_3126_0: bool = false;
        // D s_3126_1: write-var gs#118937 <= s_3126_0
        fn_state.gs_118937 = s_3126_0;
        // N s_3126_2: jump b3127
        return block_3127(state, tracer, fn_state);
    }
    fn block_3127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3127_0: read-var gs#118937:u8
        let s_3127_0: bool = fn_state.gs_118937;
        // N s_3127_1: branch s_3127_0 b3933 b3128
        if s_3127_0 {
            return block_3933(state, tracer, fn_state);
        } else {
            return block_3128(state, tracer, fn_state);
        };
    }
    fn block_3128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3128_0: const #0u : u8
        let s_3128_0: bool = false;
        // D s_3128_1: write-var gs#118938 <= s_3128_0
        fn_state.gs_118938 = s_3128_0;
        // N s_3128_2: jump b3129
        return block_3129(state, tracer, fn_state);
    }
    fn block_3129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3129_0: read-var gs#118938:u8
        let s_3129_0: bool = fn_state.gs_118938;
        // N s_3129_1: branch s_3129_0 b3932 b3130
        if s_3129_0 {
            return block_3932(state, tracer, fn_state);
        } else {
            return block_3130(state, tracer, fn_state);
        };
    }
    fn block_3130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3130_0: const #0u : u8
        let s_3130_0: bool = false;
        // D s_3130_1: write-var gs#118939 <= s_3130_0
        fn_state.gs_118939 = s_3130_0;
        // N s_3130_2: jump b3131
        return block_3131(state, tracer, fn_state);
    }
    fn block_3131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3131_0: read-var gs#118939:u8
        let s_3131_0: bool = fn_state.gs_118939;
        // N s_3131_1: branch s_3131_0 b3931 b3132
        if s_3131_0 {
            return block_3931(state, tracer, fn_state);
        } else {
            return block_3132(state, tracer, fn_state);
        };
    }
    fn block_3132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3132_0: read-var CRm:u8
        let s_3132_0: u8 = fn_state.CRm;
        // D s_3132_1: cast zx s_3132_0 -> bv
        let s_3132_1: Bits = Bits::new(s_3132_0 as u128, 4u16);
        // C s_3132_2: const #14u : u8
        let s_3132_2: u8 = 14;
        // C s_3132_3: cast zx s_3132_2 -> bv
        let s_3132_3: Bits = Bits::new(s_3132_2 as u128, 4u16);
        // D s_3132_4: cmp-eq s_3132_1 s_3132_3
        let s_3132_4: bool = ((s_3132_1) == (s_3132_3));
        // N s_3132_5: branch s_3132_4 b3930 b3133
        if s_3132_4 {
            return block_3930(state, tracer, fn_state);
        } else {
            return block_3133(state, tracer, fn_state);
        };
    }
    fn block_3133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3133_0: const #0u : u8
        let s_3133_0: bool = false;
        // D s_3133_1: write-var gs#118940 <= s_3133_0
        fn_state.gs_118940 = s_3133_0;
        // N s_3133_2: jump b3134
        return block_3134(state, tracer, fn_state);
    }
    fn block_3134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3134_0: read-var gs#118940:u8
        let s_3134_0: bool = fn_state.gs_118940;
        // N s_3134_1: branch s_3134_0 b3929 b3135
        if s_3134_0 {
            return block_3929(state, tracer, fn_state);
        } else {
            return block_3135(state, tracer, fn_state);
        };
    }
    fn block_3135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3135_0: const #0u : u8
        let s_3135_0: bool = false;
        // D s_3135_1: write-var gs#118941 <= s_3135_0
        fn_state.gs_118941 = s_3135_0;
        // N s_3135_2: jump b3136
        return block_3136(state, tracer, fn_state);
    }
    fn block_3136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3136_0: read-var gs#118941:u8
        let s_3136_0: bool = fn_state.gs_118941;
        // N s_3136_1: branch s_3136_0 b3928 b3137
        if s_3136_0 {
            return block_3928(state, tracer, fn_state);
        } else {
            return block_3137(state, tracer, fn_state);
        };
    }
    fn block_3137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3137_0: const #0u : u8
        let s_3137_0: bool = false;
        // D s_3137_1: write-var gs#118942 <= s_3137_0
        fn_state.gs_118942 = s_3137_0;
        // N s_3137_2: jump b3138
        return block_3138(state, tracer, fn_state);
    }
    fn block_3138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3138_0: read-var gs#118942:u8
        let s_3138_0: bool = fn_state.gs_118942;
        // N s_3138_1: branch s_3138_0 b3927 b3139
        if s_3138_0 {
            return block_3927(state, tracer, fn_state);
        } else {
            return block_3139(state, tracer, fn_state);
        };
    }
    fn block_3139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3139_0: const #0u : u8
        let s_3139_0: bool = false;
        // D s_3139_1: write-var gs#118943 <= s_3139_0
        fn_state.gs_118943 = s_3139_0;
        // N s_3139_2: jump b3140
        return block_3140(state, tracer, fn_state);
    }
    fn block_3140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3140_0: read-var gs#118943:u8
        let s_3140_0: bool = fn_state.gs_118943;
        // N s_3140_1: branch s_3140_0 b3926 b3141
        if s_3140_0 {
            return block_3926(state, tracer, fn_state);
        } else {
            return block_3141(state, tracer, fn_state);
        };
    }
    fn block_3141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3141_0: read-var CRm:u8
        let s_3141_0: u8 = fn_state.CRm;
        // D s_3141_1: cast zx s_3141_0 -> bv
        let s_3141_1: Bits = Bits::new(s_3141_0 as u128, 4u16);
        // C s_3141_2: const #14u : u8
        let s_3141_2: u8 = 14;
        // C s_3141_3: cast zx s_3141_2 -> bv
        let s_3141_3: Bits = Bits::new(s_3141_2 as u128, 4u16);
        // D s_3141_4: cmp-eq s_3141_1 s_3141_3
        let s_3141_4: bool = ((s_3141_1) == (s_3141_3));
        // N s_3141_5: branch s_3141_4 b3925 b3142
        if s_3141_4 {
            return block_3925(state, tracer, fn_state);
        } else {
            return block_3142(state, tracer, fn_state);
        };
    }
    fn block_3142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3142_0: const #0u : u8
        let s_3142_0: bool = false;
        // D s_3142_1: write-var gs#118944 <= s_3142_0
        fn_state.gs_118944 = s_3142_0;
        // N s_3142_2: jump b3143
        return block_3143(state, tracer, fn_state);
    }
    fn block_3143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3143_0: read-var gs#118944:u8
        let s_3143_0: bool = fn_state.gs_118944;
        // N s_3143_1: branch s_3143_0 b3924 b3144
        if s_3143_0 {
            return block_3924(state, tracer, fn_state);
        } else {
            return block_3144(state, tracer, fn_state);
        };
    }
    fn block_3144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3144_0: const #0u : u8
        let s_3144_0: bool = false;
        // D s_3144_1: write-var gs#118945 <= s_3144_0
        fn_state.gs_118945 = s_3144_0;
        // N s_3144_2: jump b3145
        return block_3145(state, tracer, fn_state);
    }
    fn block_3145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3145_0: read-var gs#118945:u8
        let s_3145_0: bool = fn_state.gs_118945;
        // N s_3145_1: branch s_3145_0 b3923 b3146
        if s_3145_0 {
            return block_3923(state, tracer, fn_state);
        } else {
            return block_3146(state, tracer, fn_state);
        };
    }
    fn block_3146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3146_0: const #0u : u8
        let s_3146_0: bool = false;
        // D s_3146_1: write-var gs#118946 <= s_3146_0
        fn_state.gs_118946 = s_3146_0;
        // N s_3146_2: jump b3147
        return block_3147(state, tracer, fn_state);
    }
    fn block_3147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3147_0: read-var gs#118946:u8
        let s_3147_0: bool = fn_state.gs_118946;
        // N s_3147_1: branch s_3147_0 b3922 b3148
        if s_3147_0 {
            return block_3922(state, tracer, fn_state);
        } else {
            return block_3148(state, tracer, fn_state);
        };
    }
    fn block_3148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3148_0: const #0u : u8
        let s_3148_0: bool = false;
        // D s_3148_1: write-var gs#118947 <= s_3148_0
        fn_state.gs_118947 = s_3148_0;
        // N s_3148_2: jump b3149
        return block_3149(state, tracer, fn_state);
    }
    fn block_3149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3149_0: read-var gs#118947:u8
        let s_3149_0: bool = fn_state.gs_118947;
        // N s_3149_1: branch s_3149_0 b3921 b3150
        if s_3149_0 {
            return block_3921(state, tracer, fn_state);
        } else {
            return block_3150(state, tracer, fn_state);
        };
    }
    fn block_3150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3150_0: read-var CRm:u8
        let s_3150_0: u8 = fn_state.CRm;
        // D s_3150_1: cast zx s_3150_0 -> bv
        let s_3150_1: Bits = Bits::new(s_3150_0 as u128, 4u16);
        // C s_3150_2: const #14u : u8
        let s_3150_2: u8 = 14;
        // C s_3150_3: cast zx s_3150_2 -> bv
        let s_3150_3: Bits = Bits::new(s_3150_2 as u128, 4u16);
        // D s_3150_4: cmp-eq s_3150_1 s_3150_3
        let s_3150_4: bool = ((s_3150_1) == (s_3150_3));
        // N s_3150_5: branch s_3150_4 b3920 b3151
        if s_3150_4 {
            return block_3920(state, tracer, fn_state);
        } else {
            return block_3151(state, tracer, fn_state);
        };
    }
    fn block_3151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3151_0: const #0u : u8
        let s_3151_0: bool = false;
        // D s_3151_1: write-var gs#118948 <= s_3151_0
        fn_state.gs_118948 = s_3151_0;
        // N s_3151_2: jump b3152
        return block_3152(state, tracer, fn_state);
    }
    fn block_3152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3152_0: read-var gs#118948:u8
        let s_3152_0: bool = fn_state.gs_118948;
        // N s_3152_1: branch s_3152_0 b3919 b3153
        if s_3152_0 {
            return block_3919(state, tracer, fn_state);
        } else {
            return block_3153(state, tracer, fn_state);
        };
    }
    fn block_3153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3153_0: const #0u : u8
        let s_3153_0: bool = false;
        // D s_3153_1: write-var gs#118949 <= s_3153_0
        fn_state.gs_118949 = s_3153_0;
        // N s_3153_2: jump b3154
        return block_3154(state, tracer, fn_state);
    }
    fn block_3154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3154_0: read-var gs#118949:u8
        let s_3154_0: bool = fn_state.gs_118949;
        // N s_3154_1: branch s_3154_0 b3918 b3155
        if s_3154_0 {
            return block_3918(state, tracer, fn_state);
        } else {
            return block_3155(state, tracer, fn_state);
        };
    }
    fn block_3155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3155_0: const #0u : u8
        let s_3155_0: bool = false;
        // D s_3155_1: write-var gs#118950 <= s_3155_0
        fn_state.gs_118950 = s_3155_0;
        // N s_3155_2: jump b3156
        return block_3156(state, tracer, fn_state);
    }
    fn block_3156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3156_0: read-var gs#118950:u8
        let s_3156_0: bool = fn_state.gs_118950;
        // N s_3156_1: branch s_3156_0 b3917 b3157
        if s_3156_0 {
            return block_3917(state, tracer, fn_state);
        } else {
            return block_3157(state, tracer, fn_state);
        };
    }
    fn block_3157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3157_0: const #0u : u8
        let s_3157_0: bool = false;
        // D s_3157_1: write-var gs#118951 <= s_3157_0
        fn_state.gs_118951 = s_3157_0;
        // N s_3157_2: jump b3158
        return block_3158(state, tracer, fn_state);
    }
    fn block_3158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3158_0: read-var gs#118951:u8
        let s_3158_0: bool = fn_state.gs_118951;
        // N s_3158_1: branch s_3158_0 b3916 b3159
        if s_3158_0 {
            return block_3916(state, tracer, fn_state);
        } else {
            return block_3159(state, tracer, fn_state);
        };
    }
    fn block_3159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3159_0: read-var CRm:u8
        let s_3159_0: u8 = fn_state.CRm;
        // D s_3159_1: cast zx s_3159_0 -> bv
        let s_3159_1: Bits = Bits::new(s_3159_0 as u128, 4u16);
        // C s_3159_2: const #5u : u8
        let s_3159_2: u8 = 5;
        // C s_3159_3: cast zx s_3159_2 -> bv
        let s_3159_3: Bits = Bits::new(s_3159_2 as u128, 4u16);
        // D s_3159_4: cmp-eq s_3159_1 s_3159_3
        let s_3159_4: bool = ((s_3159_1) == (s_3159_3));
        // N s_3159_5: branch s_3159_4 b3915 b3160
        if s_3159_4 {
            return block_3915(state, tracer, fn_state);
        } else {
            return block_3160(state, tracer, fn_state);
        };
    }
    fn block_3160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3160_0: const #0u : u8
        let s_3160_0: bool = false;
        // D s_3160_1: write-var gs#118952 <= s_3160_0
        fn_state.gs_118952 = s_3160_0;
        // N s_3160_2: jump b3161
        return block_3161(state, tracer, fn_state);
    }
    fn block_3161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3161_0: read-var gs#118952:u8
        let s_3161_0: bool = fn_state.gs_118952;
        // N s_3161_1: branch s_3161_0 b3914 b3162
        if s_3161_0 {
            return block_3914(state, tracer, fn_state);
        } else {
            return block_3162(state, tracer, fn_state);
        };
    }
    fn block_3162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3162_0: const #0u : u8
        let s_3162_0: bool = false;
        // D s_3162_1: write-var gs#118953 <= s_3162_0
        fn_state.gs_118953 = s_3162_0;
        // N s_3162_2: jump b3163
        return block_3163(state, tracer, fn_state);
    }
    fn block_3163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3163_0: read-var gs#118953:u8
        let s_3163_0: bool = fn_state.gs_118953;
        // N s_3163_1: branch s_3163_0 b3913 b3164
        if s_3163_0 {
            return block_3913(state, tracer, fn_state);
        } else {
            return block_3164(state, tracer, fn_state);
        };
    }
    fn block_3164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3164_0: const #0u : u8
        let s_3164_0: bool = false;
        // D s_3164_1: write-var gs#118954 <= s_3164_0
        fn_state.gs_118954 = s_3164_0;
        // N s_3164_2: jump b3165
        return block_3165(state, tracer, fn_state);
    }
    fn block_3165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3165_0: read-var gs#118954:u8
        let s_3165_0: bool = fn_state.gs_118954;
        // N s_3165_1: branch s_3165_0 b3912 b3166
        if s_3165_0 {
            return block_3912(state, tracer, fn_state);
        } else {
            return block_3166(state, tracer, fn_state);
        };
    }
    fn block_3166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3166_0: const #0u : u8
        let s_3166_0: bool = false;
        // D s_3166_1: write-var gs#118955 <= s_3166_0
        fn_state.gs_118955 = s_3166_0;
        // N s_3166_2: jump b3167
        return block_3167(state, tracer, fn_state);
    }
    fn block_3167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3167_0: read-var gs#118955:u8
        let s_3167_0: bool = fn_state.gs_118955;
        // N s_3167_1: branch s_3167_0 b3911 b3168
        if s_3167_0 {
            return block_3911(state, tracer, fn_state);
        } else {
            return block_3168(state, tracer, fn_state);
        };
    }
    fn block_3168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3168_0: read-var CRm:u8
        let s_3168_0: u8 = fn_state.CRm;
        // D s_3168_1: cast zx s_3168_0 -> bv
        let s_3168_1: Bits = Bits::new(s_3168_0 as u128, 4u16);
        // C s_3168_2: const #12u : u8
        let s_3168_2: u8 = 12;
        // C s_3168_3: cast zx s_3168_2 -> bv
        let s_3168_3: Bits = Bits::new(s_3168_2 as u128, 4u16);
        // D s_3168_4: cmp-eq s_3168_1 s_3168_3
        let s_3168_4: bool = ((s_3168_1) == (s_3168_3));
        // N s_3168_5: branch s_3168_4 b3910 b3169
        if s_3168_4 {
            return block_3910(state, tracer, fn_state);
        } else {
            return block_3169(state, tracer, fn_state);
        };
    }
    fn block_3169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3169_0: const #0u : u8
        let s_3169_0: bool = false;
        // D s_3169_1: write-var gs#118956 <= s_3169_0
        fn_state.gs_118956 = s_3169_0;
        // N s_3169_2: jump b3170
        return block_3170(state, tracer, fn_state);
    }
    fn block_3170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3170_0: read-var gs#118956:u8
        let s_3170_0: bool = fn_state.gs_118956;
        // N s_3170_1: branch s_3170_0 b3909 b3171
        if s_3170_0 {
            return block_3909(state, tracer, fn_state);
        } else {
            return block_3171(state, tracer, fn_state);
        };
    }
    fn block_3171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3171_0: const #0u : u8
        let s_3171_0: bool = false;
        // D s_3171_1: write-var gs#118957 <= s_3171_0
        fn_state.gs_118957 = s_3171_0;
        // N s_3171_2: jump b3172
        return block_3172(state, tracer, fn_state);
    }
    fn block_3172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3172_0: read-var gs#118957:u8
        let s_3172_0: bool = fn_state.gs_118957;
        // N s_3172_1: branch s_3172_0 b3908 b3173
        if s_3172_0 {
            return block_3908(state, tracer, fn_state);
        } else {
            return block_3173(state, tracer, fn_state);
        };
    }
    fn block_3173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3173_0: const #0u : u8
        let s_3173_0: bool = false;
        // D s_3173_1: write-var gs#118958 <= s_3173_0
        fn_state.gs_118958 = s_3173_0;
        // N s_3173_2: jump b3174
        return block_3174(state, tracer, fn_state);
    }
    fn block_3174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3174_0: read-var gs#118958:u8
        let s_3174_0: bool = fn_state.gs_118958;
        // N s_3174_1: branch s_3174_0 b3907 b3175
        if s_3174_0 {
            return block_3907(state, tracer, fn_state);
        } else {
            return block_3175(state, tracer, fn_state);
        };
    }
    fn block_3175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3175_0: const #0u : u8
        let s_3175_0: bool = false;
        // D s_3175_1: write-var gs#118959 <= s_3175_0
        fn_state.gs_118959 = s_3175_0;
        // N s_3175_2: jump b3176
        return block_3176(state, tracer, fn_state);
    }
    fn block_3176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3176_0: read-var gs#118959:u8
        let s_3176_0: bool = fn_state.gs_118959;
        // N s_3176_1: branch s_3176_0 b3906 b3177
        if s_3176_0 {
            return block_3906(state, tracer, fn_state);
        } else {
            return block_3177(state, tracer, fn_state);
        };
    }
    fn block_3177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3177_0: read-var CRm:u8
        let s_3177_0: u8 = fn_state.CRm;
        // D s_3177_1: cast zx s_3177_0 -> bv
        let s_3177_1: Bits = Bits::new(s_3177_0 as u128, 4u16);
        // C s_3177_2: const #3u : u8
        let s_3177_2: u8 = 3;
        // C s_3177_3: cast zx s_3177_2 -> bv
        let s_3177_3: Bits = Bits::new(s_3177_2 as u128, 4u16);
        // D s_3177_4: cmp-eq s_3177_1 s_3177_3
        let s_3177_4: bool = ((s_3177_1) == (s_3177_3));
        // N s_3177_5: branch s_3177_4 b3905 b3178
        if s_3177_4 {
            return block_3905(state, tracer, fn_state);
        } else {
            return block_3178(state, tracer, fn_state);
        };
    }
    fn block_3178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3178_0: const #0u : u8
        let s_3178_0: bool = false;
        // D s_3178_1: write-var gs#118960 <= s_3178_0
        fn_state.gs_118960 = s_3178_0;
        // N s_3178_2: jump b3179
        return block_3179(state, tracer, fn_state);
    }
    fn block_3179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3179_0: read-var gs#118960:u8
        let s_3179_0: bool = fn_state.gs_118960;
        // N s_3179_1: branch s_3179_0 b3904 b3180
        if s_3179_0 {
            return block_3904(state, tracer, fn_state);
        } else {
            return block_3180(state, tracer, fn_state);
        };
    }
    fn block_3180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3180_0: const #0u : u8
        let s_3180_0: bool = false;
        // D s_3180_1: write-var gs#118961 <= s_3180_0
        fn_state.gs_118961 = s_3180_0;
        // N s_3180_2: jump b3181
        return block_3181(state, tracer, fn_state);
    }
    fn block_3181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3181_0: read-var gs#118961:u8
        let s_3181_0: bool = fn_state.gs_118961;
        // N s_3181_1: branch s_3181_0 b3903 b3182
        if s_3181_0 {
            return block_3903(state, tracer, fn_state);
        } else {
            return block_3182(state, tracer, fn_state);
        };
    }
    fn block_3182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3182_0: const #0u : u8
        let s_3182_0: bool = false;
        // D s_3182_1: write-var gs#118962 <= s_3182_0
        fn_state.gs_118962 = s_3182_0;
        // N s_3182_2: jump b3183
        return block_3183(state, tracer, fn_state);
    }
    fn block_3183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3183_0: read-var gs#118962:u8
        let s_3183_0: bool = fn_state.gs_118962;
        // N s_3183_1: branch s_3183_0 b3902 b3184
        if s_3183_0 {
            return block_3902(state, tracer, fn_state);
        } else {
            return block_3184(state, tracer, fn_state);
        };
    }
    fn block_3184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3184_0: const #0u : u8
        let s_3184_0: bool = false;
        // D s_3184_1: write-var gs#118963 <= s_3184_0
        fn_state.gs_118963 = s_3184_0;
        // N s_3184_2: jump b3185
        return block_3185(state, tracer, fn_state);
    }
    fn block_3185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3185_0: read-var gs#118963:u8
        let s_3185_0: bool = fn_state.gs_118963;
        // N s_3185_1: branch s_3185_0 b3901 b3186
        if s_3185_0 {
            return block_3901(state, tracer, fn_state);
        } else {
            return block_3186(state, tracer, fn_state);
        };
    }
    fn block_3186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3186_0: read-var CRm:u8
        let s_3186_0: u8 = fn_state.CRm;
        // D s_3186_1: cast zx s_3186_0 -> bv
        let s_3186_1: Bits = Bits::new(s_3186_0 as u128, 4u16);
        // C s_3186_2: const #5u : u8
        let s_3186_2: u8 = 5;
        // C s_3186_3: cast zx s_3186_2 -> bv
        let s_3186_3: Bits = Bits::new(s_3186_2 as u128, 4u16);
        // D s_3186_4: cmp-eq s_3186_1 s_3186_3
        let s_3186_4: bool = ((s_3186_1) == (s_3186_3));
        // N s_3186_5: branch s_3186_4 b3900 b3187
        if s_3186_4 {
            return block_3900(state, tracer, fn_state);
        } else {
            return block_3187(state, tracer, fn_state);
        };
    }
    fn block_3187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3187_0: const #0u : u8
        let s_3187_0: bool = false;
        // D s_3187_1: write-var gs#118964 <= s_3187_0
        fn_state.gs_118964 = s_3187_0;
        // N s_3187_2: jump b3188
        return block_3188(state, tracer, fn_state);
    }
    fn block_3188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3188_0: read-var gs#118964:u8
        let s_3188_0: bool = fn_state.gs_118964;
        // N s_3188_1: branch s_3188_0 b3899 b3189
        if s_3188_0 {
            return block_3899(state, tracer, fn_state);
        } else {
            return block_3189(state, tracer, fn_state);
        };
    }
    fn block_3189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3189_0: const #0u : u8
        let s_3189_0: bool = false;
        // D s_3189_1: write-var gs#118965 <= s_3189_0
        fn_state.gs_118965 = s_3189_0;
        // N s_3189_2: jump b3190
        return block_3190(state, tracer, fn_state);
    }
    fn block_3190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3190_0: read-var gs#118965:u8
        let s_3190_0: bool = fn_state.gs_118965;
        // N s_3190_1: branch s_3190_0 b3898 b3191
        if s_3190_0 {
            return block_3898(state, tracer, fn_state);
        } else {
            return block_3191(state, tracer, fn_state);
        };
    }
    fn block_3191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3191_0: const #0u : u8
        let s_3191_0: bool = false;
        // D s_3191_1: write-var gs#118966 <= s_3191_0
        fn_state.gs_118966 = s_3191_0;
        // N s_3191_2: jump b3192
        return block_3192(state, tracer, fn_state);
    }
    fn block_3192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3192_0: read-var gs#118966:u8
        let s_3192_0: bool = fn_state.gs_118966;
        // N s_3192_1: branch s_3192_0 b3897 b3193
        if s_3192_0 {
            return block_3897(state, tracer, fn_state);
        } else {
            return block_3193(state, tracer, fn_state);
        };
    }
    fn block_3193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3193_0: const #0u : u8
        let s_3193_0: bool = false;
        // D s_3193_1: write-var gs#118967 <= s_3193_0
        fn_state.gs_118967 = s_3193_0;
        // N s_3193_2: jump b3194
        return block_3194(state, tracer, fn_state);
    }
    fn block_3194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3194_0: read-var gs#118967:u8
        let s_3194_0: bool = fn_state.gs_118967;
        // N s_3194_1: branch s_3194_0 b3896 b3195
        if s_3194_0 {
            return block_3896(state, tracer, fn_state);
        } else {
            return block_3195(state, tracer, fn_state);
        };
    }
    fn block_3195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3195_0: read-var CRm:u8
        let s_3195_0: u8 = fn_state.CRm;
        // D s_3195_1: cast zx s_3195_0 -> bv
        let s_3195_1: Bits = Bits::new(s_3195_0 as u128, 4u16);
        // C s_3195_2: const #2u : u8
        let s_3195_2: u8 = 2;
        // C s_3195_3: cast zx s_3195_2 -> bv
        let s_3195_3: Bits = Bits::new(s_3195_2 as u128, 4u16);
        // D s_3195_4: cmp-eq s_3195_1 s_3195_3
        let s_3195_4: bool = ((s_3195_1) == (s_3195_3));
        // N s_3195_5: branch s_3195_4 b3895 b3196
        if s_3195_4 {
            return block_3895(state, tracer, fn_state);
        } else {
            return block_3196(state, tracer, fn_state);
        };
    }
    fn block_3196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3196_0: const #0u : u8
        let s_3196_0: bool = false;
        // D s_3196_1: write-var gs#118968 <= s_3196_0
        fn_state.gs_118968 = s_3196_0;
        // N s_3196_2: jump b3197
        return block_3197(state, tracer, fn_state);
    }
    fn block_3197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3197_0: read-var gs#118968:u8
        let s_3197_0: bool = fn_state.gs_118968;
        // N s_3197_1: branch s_3197_0 b3894 b3198
        if s_3197_0 {
            return block_3894(state, tracer, fn_state);
        } else {
            return block_3198(state, tracer, fn_state);
        };
    }
    fn block_3198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3198_0: const #0u : u8
        let s_3198_0: bool = false;
        // D s_3198_1: write-var gs#118969 <= s_3198_0
        fn_state.gs_118969 = s_3198_0;
        // N s_3198_2: jump b3199
        return block_3199(state, tracer, fn_state);
    }
    fn block_3199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3199_0: read-var gs#118969:u8
        let s_3199_0: bool = fn_state.gs_118969;
        // N s_3199_1: branch s_3199_0 b3893 b3200
        if s_3199_0 {
            return block_3893(state, tracer, fn_state);
        } else {
            return block_3200(state, tracer, fn_state);
        };
    }
    fn block_3200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3200_0: const #0u : u8
        let s_3200_0: bool = false;
        // D s_3200_1: write-var gs#118970 <= s_3200_0
        fn_state.gs_118970 = s_3200_0;
        // N s_3200_2: jump b3201
        return block_3201(state, tracer, fn_state);
    }
    fn block_3201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3201_0: read-var gs#118970:u8
        let s_3201_0: bool = fn_state.gs_118970;
        // N s_3201_1: branch s_3201_0 b3892 b3202
        if s_3201_0 {
            return block_3892(state, tracer, fn_state);
        } else {
            return block_3202(state, tracer, fn_state);
        };
    }
    fn block_3202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3202_0: const #0u : u8
        let s_3202_0: bool = false;
        // D s_3202_1: write-var gs#118971 <= s_3202_0
        fn_state.gs_118971 = s_3202_0;
        // N s_3202_2: jump b3203
        return block_3203(state, tracer, fn_state);
    }
    fn block_3203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3203_0: read-var gs#118971:u8
        let s_3203_0: bool = fn_state.gs_118971;
        // N s_3203_1: branch s_3203_0 b3891 b3204
        if s_3203_0 {
            return block_3891(state, tracer, fn_state);
        } else {
            return block_3204(state, tracer, fn_state);
        };
    }
    fn block_3204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3204_0: read-var CRm:u8
        let s_3204_0: u8 = fn_state.CRm;
        // D s_3204_1: cast zx s_3204_0 -> bv
        let s_3204_1: Bits = Bits::new(s_3204_0 as u128, 4u16);
        // C s_3204_2: const #6u : u8
        let s_3204_2: u8 = 6;
        // C s_3204_3: cast zx s_3204_2 -> bv
        let s_3204_3: Bits = Bits::new(s_3204_2 as u128, 4u16);
        // D s_3204_4: cmp-eq s_3204_1 s_3204_3
        let s_3204_4: bool = ((s_3204_1) == (s_3204_3));
        // N s_3204_5: branch s_3204_4 b3890 b3205
        if s_3204_4 {
            return block_3890(state, tracer, fn_state);
        } else {
            return block_3205(state, tracer, fn_state);
        };
    }
    fn block_3205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3205_0: const #0u : u8
        let s_3205_0: bool = false;
        // D s_3205_1: write-var gs#118972 <= s_3205_0
        fn_state.gs_118972 = s_3205_0;
        // N s_3205_2: jump b3206
        return block_3206(state, tracer, fn_state);
    }
    fn block_3206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3206_0: read-var gs#118972:u8
        let s_3206_0: bool = fn_state.gs_118972;
        // N s_3206_1: branch s_3206_0 b3889 b3207
        if s_3206_0 {
            return block_3889(state, tracer, fn_state);
        } else {
            return block_3207(state, tracer, fn_state);
        };
    }
    fn block_3207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3207_0: const #0u : u8
        let s_3207_0: bool = false;
        // D s_3207_1: write-var gs#118973 <= s_3207_0
        fn_state.gs_118973 = s_3207_0;
        // N s_3207_2: jump b3208
        return block_3208(state, tracer, fn_state);
    }
    fn block_3208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3208_0: read-var gs#118973:u8
        let s_3208_0: bool = fn_state.gs_118973;
        // N s_3208_1: branch s_3208_0 b3888 b3209
        if s_3208_0 {
            return block_3888(state, tracer, fn_state);
        } else {
            return block_3209(state, tracer, fn_state);
        };
    }
    fn block_3209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3209_0: const #0u : u8
        let s_3209_0: bool = false;
        // D s_3209_1: write-var gs#118974 <= s_3209_0
        fn_state.gs_118974 = s_3209_0;
        // N s_3209_2: jump b3210
        return block_3210(state, tracer, fn_state);
    }
    fn block_3210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3210_0: read-var gs#118974:u8
        let s_3210_0: bool = fn_state.gs_118974;
        // N s_3210_1: branch s_3210_0 b3887 b3211
        if s_3210_0 {
            return block_3887(state, tracer, fn_state);
        } else {
            return block_3211(state, tracer, fn_state);
        };
    }
    fn block_3211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3211_0: const #0u : u8
        let s_3211_0: bool = false;
        // D s_3211_1: write-var gs#118975 <= s_3211_0
        fn_state.gs_118975 = s_3211_0;
        // N s_3211_2: jump b3212
        return block_3212(state, tracer, fn_state);
    }
    fn block_3212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3212_0: read-var gs#118975:u8
        let s_3212_0: bool = fn_state.gs_118975;
        // N s_3212_1: branch s_3212_0 b3886 b3213
        if s_3212_0 {
            return block_3886(state, tracer, fn_state);
        } else {
            return block_3213(state, tracer, fn_state);
        };
    }
    fn block_3213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3213_0: read-var CRm:u8
        let s_3213_0: u8 = fn_state.CRm;
        // D s_3213_1: cast zx s_3213_0 -> bv
        let s_3213_1: Bits = Bits::new(s_3213_0 as u128, 4u16);
        // C s_3213_2: const #6u : u8
        let s_3213_2: u8 = 6;
        // C s_3213_3: cast zx s_3213_2 -> bv
        let s_3213_3: Bits = Bits::new(s_3213_2 as u128, 4u16);
        // D s_3213_4: cmp-eq s_3213_1 s_3213_3
        let s_3213_4: bool = ((s_3213_1) == (s_3213_3));
        // N s_3213_5: branch s_3213_4 b3885 b3214
        if s_3213_4 {
            return block_3885(state, tracer, fn_state);
        } else {
            return block_3214(state, tracer, fn_state);
        };
    }
    fn block_3214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3214_0: const #0u : u8
        let s_3214_0: bool = false;
        // D s_3214_1: write-var gs#118976 <= s_3214_0
        fn_state.gs_118976 = s_3214_0;
        // N s_3214_2: jump b3215
        return block_3215(state, tracer, fn_state);
    }
    fn block_3215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3215_0: read-var gs#118976:u8
        let s_3215_0: bool = fn_state.gs_118976;
        // N s_3215_1: branch s_3215_0 b3884 b3216
        if s_3215_0 {
            return block_3884(state, tracer, fn_state);
        } else {
            return block_3216(state, tracer, fn_state);
        };
    }
    fn block_3216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3216_0: const #0u : u8
        let s_3216_0: bool = false;
        // D s_3216_1: write-var gs#118977 <= s_3216_0
        fn_state.gs_118977 = s_3216_0;
        // N s_3216_2: jump b3217
        return block_3217(state, tracer, fn_state);
    }
    fn block_3217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3217_0: read-var gs#118977:u8
        let s_3217_0: bool = fn_state.gs_118977;
        // N s_3217_1: branch s_3217_0 b3883 b3218
        if s_3217_0 {
            return block_3883(state, tracer, fn_state);
        } else {
            return block_3218(state, tracer, fn_state);
        };
    }
    fn block_3218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3218_0: const #0u : u8
        let s_3218_0: bool = false;
        // D s_3218_1: write-var gs#118978 <= s_3218_0
        fn_state.gs_118978 = s_3218_0;
        // N s_3218_2: jump b3219
        return block_3219(state, tracer, fn_state);
    }
    fn block_3219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3219_0: read-var gs#118978:u8
        let s_3219_0: bool = fn_state.gs_118978;
        // N s_3219_1: branch s_3219_0 b3882 b3220
        if s_3219_0 {
            return block_3882(state, tracer, fn_state);
        } else {
            return block_3220(state, tracer, fn_state);
        };
    }
    fn block_3220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3220_0: const #0u : u8
        let s_3220_0: bool = false;
        // D s_3220_1: write-var gs#118979 <= s_3220_0
        fn_state.gs_118979 = s_3220_0;
        // N s_3220_2: jump b3221
        return block_3221(state, tracer, fn_state);
    }
    fn block_3221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3221_0: read-var gs#118979:u8
        let s_3221_0: bool = fn_state.gs_118979;
        // N s_3221_1: branch s_3221_0 b3881 b3222
        if s_3221_0 {
            return block_3881(state, tracer, fn_state);
        } else {
            return block_3222(state, tracer, fn_state);
        };
    }
    fn block_3222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3222_0: read-var CRm:u8
        let s_3222_0: u8 = fn_state.CRm;
        // D s_3222_1: cast zx s_3222_0 -> bv
        let s_3222_1: Bits = Bits::new(s_3222_0 as u128, 4u16);
        // C s_3222_2: const #6u : u8
        let s_3222_2: u8 = 6;
        // C s_3222_3: cast zx s_3222_2 -> bv
        let s_3222_3: Bits = Bits::new(s_3222_2 as u128, 4u16);
        // D s_3222_4: cmp-eq s_3222_1 s_3222_3
        let s_3222_4: bool = ((s_3222_1) == (s_3222_3));
        // N s_3222_5: branch s_3222_4 b3880 b3223
        if s_3222_4 {
            return block_3880(state, tracer, fn_state);
        } else {
            return block_3223(state, tracer, fn_state);
        };
    }
    fn block_3223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3223_0: const #0u : u8
        let s_3223_0: bool = false;
        // D s_3223_1: write-var gs#118980 <= s_3223_0
        fn_state.gs_118980 = s_3223_0;
        // N s_3223_2: jump b3224
        return block_3224(state, tracer, fn_state);
    }
    fn block_3224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3224_0: read-var gs#118980:u8
        let s_3224_0: bool = fn_state.gs_118980;
        // N s_3224_1: branch s_3224_0 b3879 b3225
        if s_3224_0 {
            return block_3879(state, tracer, fn_state);
        } else {
            return block_3225(state, tracer, fn_state);
        };
    }
    fn block_3225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3225_0: const #0u : u8
        let s_3225_0: bool = false;
        // D s_3225_1: write-var gs#118981 <= s_3225_0
        fn_state.gs_118981 = s_3225_0;
        // N s_3225_2: jump b3226
        return block_3226(state, tracer, fn_state);
    }
    fn block_3226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3226_0: read-var gs#118981:u8
        let s_3226_0: bool = fn_state.gs_118981;
        // N s_3226_1: branch s_3226_0 b3878 b3227
        if s_3226_0 {
            return block_3878(state, tracer, fn_state);
        } else {
            return block_3227(state, tracer, fn_state);
        };
    }
    fn block_3227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3227_0: const #0u : u8
        let s_3227_0: bool = false;
        // D s_3227_1: write-var gs#118982 <= s_3227_0
        fn_state.gs_118982 = s_3227_0;
        // N s_3227_2: jump b3228
        return block_3228(state, tracer, fn_state);
    }
    fn block_3228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3228_0: read-var gs#118982:u8
        let s_3228_0: bool = fn_state.gs_118982;
        // N s_3228_1: branch s_3228_0 b3877 b3229
        if s_3228_0 {
            return block_3877(state, tracer, fn_state);
        } else {
            return block_3229(state, tracer, fn_state);
        };
    }
    fn block_3229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3229_0: const #0u : u8
        let s_3229_0: bool = false;
        // D s_3229_1: write-var gs#118983 <= s_3229_0
        fn_state.gs_118983 = s_3229_0;
        // N s_3229_2: jump b3230
        return block_3230(state, tracer, fn_state);
    }
    fn block_3230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3230_0: read-var gs#118983:u8
        let s_3230_0: bool = fn_state.gs_118983;
        // N s_3230_1: branch s_3230_0 b3876 b3231
        if s_3230_0 {
            return block_3876(state, tracer, fn_state);
        } else {
            return block_3231(state, tracer, fn_state);
        };
    }
    fn block_3231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3231_0: read-var CRm:u8
        let s_3231_0: u8 = fn_state.CRm;
        // D s_3231_1: cast zx s_3231_0 -> bv
        let s_3231_1: Bits = Bits::new(s_3231_0 as u128, 4u16);
        // C s_3231_2: const #6u : u8
        let s_3231_2: u8 = 6;
        // C s_3231_3: cast zx s_3231_2 -> bv
        let s_3231_3: Bits = Bits::new(s_3231_2 as u128, 4u16);
        // D s_3231_4: cmp-eq s_3231_1 s_3231_3
        let s_3231_4: bool = ((s_3231_1) == (s_3231_3));
        // N s_3231_5: branch s_3231_4 b3875 b3232
        if s_3231_4 {
            return block_3875(state, tracer, fn_state);
        } else {
            return block_3232(state, tracer, fn_state);
        };
    }
    fn block_3232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3232_0: const #0u : u8
        let s_3232_0: bool = false;
        // D s_3232_1: write-var gs#118984 <= s_3232_0
        fn_state.gs_118984 = s_3232_0;
        // N s_3232_2: jump b3233
        return block_3233(state, tracer, fn_state);
    }
    fn block_3233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3233_0: read-var gs#118984:u8
        let s_3233_0: bool = fn_state.gs_118984;
        // N s_3233_1: branch s_3233_0 b3874 b3234
        if s_3233_0 {
            return block_3874(state, tracer, fn_state);
        } else {
            return block_3234(state, tracer, fn_state);
        };
    }
    fn block_3234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3234_0: const #0u : u8
        let s_3234_0: bool = false;
        // D s_3234_1: write-var gs#118985 <= s_3234_0
        fn_state.gs_118985 = s_3234_0;
        // N s_3234_2: jump b3235
        return block_3235(state, tracer, fn_state);
    }
    fn block_3235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3235_0: read-var gs#118985:u8
        let s_3235_0: bool = fn_state.gs_118985;
        // N s_3235_1: branch s_3235_0 b3873 b3236
        if s_3235_0 {
            return block_3873(state, tracer, fn_state);
        } else {
            return block_3236(state, tracer, fn_state);
        };
    }
    fn block_3236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3236_0: const #0u : u8
        let s_3236_0: bool = false;
        // D s_3236_1: write-var gs#118986 <= s_3236_0
        fn_state.gs_118986 = s_3236_0;
        // N s_3236_2: jump b3237
        return block_3237(state, tracer, fn_state);
    }
    fn block_3237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3237_0: read-var gs#118986:u8
        let s_3237_0: bool = fn_state.gs_118986;
        // N s_3237_1: branch s_3237_0 b3872 b3238
        if s_3237_0 {
            return block_3872(state, tracer, fn_state);
        } else {
            return block_3238(state, tracer, fn_state);
        };
    }
    fn block_3238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3238_0: const #0u : u8
        let s_3238_0: bool = false;
        // D s_3238_1: write-var gs#118987 <= s_3238_0
        fn_state.gs_118987 = s_3238_0;
        // N s_3238_2: jump b3239
        return block_3239(state, tracer, fn_state);
    }
    fn block_3239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3239_0: read-var gs#118987:u8
        let s_3239_0: bool = fn_state.gs_118987;
        // N s_3239_1: branch s_3239_0 b3871 b3240
        if s_3239_0 {
            return block_3871(state, tracer, fn_state);
        } else {
            return block_3240(state, tracer, fn_state);
        };
    }
    fn block_3240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3240_0: read-var CRm:u8
        let s_3240_0: u8 = fn_state.CRm;
        // D s_3240_1: cast zx s_3240_0 -> bv
        let s_3240_1: Bits = Bits::new(s_3240_0 as u128, 4u16);
        // C s_3240_2: const #2u : u8
        let s_3240_2: u8 = 2;
        // C s_3240_3: cast zx s_3240_2 -> bv
        let s_3240_3: Bits = Bits::new(s_3240_2 as u128, 4u16);
        // D s_3240_4: cmp-eq s_3240_1 s_3240_3
        let s_3240_4: bool = ((s_3240_1) == (s_3240_3));
        // N s_3240_5: branch s_3240_4 b3870 b3241
        if s_3240_4 {
            return block_3870(state, tracer, fn_state);
        } else {
            return block_3241(state, tracer, fn_state);
        };
    }
    fn block_3241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3241_0: const #0u : u8
        let s_3241_0: bool = false;
        // D s_3241_1: write-var gs#118988 <= s_3241_0
        fn_state.gs_118988 = s_3241_0;
        // N s_3241_2: jump b3242
        return block_3242(state, tracer, fn_state);
    }
    fn block_3242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3242_0: read-var gs#118988:u8
        let s_3242_0: bool = fn_state.gs_118988;
        // N s_3242_1: branch s_3242_0 b3869 b3243
        if s_3242_0 {
            return block_3869(state, tracer, fn_state);
        } else {
            return block_3243(state, tracer, fn_state);
        };
    }
    fn block_3243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3243_0: const #0u : u8
        let s_3243_0: bool = false;
        // D s_3243_1: write-var gs#118989 <= s_3243_0
        fn_state.gs_118989 = s_3243_0;
        // N s_3243_2: jump b3244
        return block_3244(state, tracer, fn_state);
    }
    fn block_3244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3244_0: read-var gs#118989:u8
        let s_3244_0: bool = fn_state.gs_118989;
        // N s_3244_1: branch s_3244_0 b3868 b3245
        if s_3244_0 {
            return block_3868(state, tracer, fn_state);
        } else {
            return block_3245(state, tracer, fn_state);
        };
    }
    fn block_3245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3245_0: const #0u : u8
        let s_3245_0: bool = false;
        // D s_3245_1: write-var gs#118990 <= s_3245_0
        fn_state.gs_118990 = s_3245_0;
        // N s_3245_2: jump b3246
        return block_3246(state, tracer, fn_state);
    }
    fn block_3246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3246_0: read-var gs#118990:u8
        let s_3246_0: bool = fn_state.gs_118990;
        // N s_3246_1: branch s_3246_0 b3867 b3247
        if s_3246_0 {
            return block_3867(state, tracer, fn_state);
        } else {
            return block_3247(state, tracer, fn_state);
        };
    }
    fn block_3247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3247_0: const #0u : u8
        let s_3247_0: bool = false;
        // D s_3247_1: write-var gs#118991 <= s_3247_0
        fn_state.gs_118991 = s_3247_0;
        // N s_3247_2: jump b3248
        return block_3248(state, tracer, fn_state);
    }
    fn block_3248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3248_0: read-var gs#118991:u8
        let s_3248_0: bool = fn_state.gs_118991;
        // N s_3248_1: branch s_3248_0 b3866 b3249
        if s_3248_0 {
            return block_3866(state, tracer, fn_state);
        } else {
            return block_3249(state, tracer, fn_state);
        };
    }
    fn block_3249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3249_0: read-var CRm:u8
        let s_3249_0: u8 = fn_state.CRm;
        // D s_3249_1: cast zx s_3249_0 -> bv
        let s_3249_1: Bits = Bits::new(s_3249_0 as u128, 4u16);
        // C s_3249_2: const #15u : u8
        let s_3249_2: u8 = 15;
        // C s_3249_3: cast zx s_3249_2 -> bv
        let s_3249_3: Bits = Bits::new(s_3249_2 as u128, 4u16);
        // D s_3249_4: cmp-eq s_3249_1 s_3249_3
        let s_3249_4: bool = ((s_3249_1) == (s_3249_3));
        // N s_3249_5: branch s_3249_4 b3865 b3250
        if s_3249_4 {
            return block_3865(state, tracer, fn_state);
        } else {
            return block_3250(state, tracer, fn_state);
        };
    }
    fn block_3250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3250_0: const #0u : u8
        let s_3250_0: bool = false;
        // D s_3250_1: write-var gs#118992 <= s_3250_0
        fn_state.gs_118992 = s_3250_0;
        // N s_3250_2: jump b3251
        return block_3251(state, tracer, fn_state);
    }
    fn block_3251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3251_0: read-var gs#118992:u8
        let s_3251_0: bool = fn_state.gs_118992;
        // N s_3251_1: branch s_3251_0 b3864 b3252
        if s_3251_0 {
            return block_3864(state, tracer, fn_state);
        } else {
            return block_3252(state, tracer, fn_state);
        };
    }
    fn block_3252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3252_0: const #0u : u8
        let s_3252_0: bool = false;
        // D s_3252_1: write-var gs#118993 <= s_3252_0
        fn_state.gs_118993 = s_3252_0;
        // N s_3252_2: jump b3253
        return block_3253(state, tracer, fn_state);
    }
    fn block_3253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3253_0: read-var gs#118993:u8
        let s_3253_0: bool = fn_state.gs_118993;
        // N s_3253_1: branch s_3253_0 b3863 b3254
        if s_3253_0 {
            return block_3863(state, tracer, fn_state);
        } else {
            return block_3254(state, tracer, fn_state);
        };
    }
    fn block_3254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3254_0: const #0u : u8
        let s_3254_0: bool = false;
        // D s_3254_1: write-var gs#118994 <= s_3254_0
        fn_state.gs_118994 = s_3254_0;
        // N s_3254_2: jump b3255
        return block_3255(state, tracer, fn_state);
    }
    fn block_3255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3255_0: read-var gs#118994:u8
        let s_3255_0: bool = fn_state.gs_118994;
        // N s_3255_1: branch s_3255_0 b3862 b3256
        if s_3255_0 {
            return block_3862(state, tracer, fn_state);
        } else {
            return block_3256(state, tracer, fn_state);
        };
    }
    fn block_3256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3256_0: const #0u : u8
        let s_3256_0: bool = false;
        // D s_3256_1: write-var gs#118995 <= s_3256_0
        fn_state.gs_118995 = s_3256_0;
        // N s_3256_2: jump b3257
        return block_3257(state, tracer, fn_state);
    }
    fn block_3257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3257_0: read-var gs#118995:u8
        let s_3257_0: bool = fn_state.gs_118995;
        // N s_3257_1: branch s_3257_0 b3861 b3258
        if s_3257_0 {
            return block_3861(state, tracer, fn_state);
        } else {
            return block_3258(state, tracer, fn_state);
        };
    }
    fn block_3258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3258_0: read-var CRm:u8
        let s_3258_0: u8 = fn_state.CRm;
        // D s_3258_1: cast zx s_3258_0 -> bv
        let s_3258_1: Bits = Bits::new(s_3258_0 as u128, 4u16);
        // C s_3258_2: const #15u : u8
        let s_3258_2: u8 = 15;
        // C s_3258_3: cast zx s_3258_2 -> bv
        let s_3258_3: Bits = Bits::new(s_3258_2 as u128, 4u16);
        // D s_3258_4: cmp-eq s_3258_1 s_3258_3
        let s_3258_4: bool = ((s_3258_1) == (s_3258_3));
        // N s_3258_5: branch s_3258_4 b3860 b3259
        if s_3258_4 {
            return block_3860(state, tracer, fn_state);
        } else {
            return block_3259(state, tracer, fn_state);
        };
    }
    fn block_3259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3259_0: const #0u : u8
        let s_3259_0: bool = false;
        // D s_3259_1: write-var gs#118996 <= s_3259_0
        fn_state.gs_118996 = s_3259_0;
        // N s_3259_2: jump b3260
        return block_3260(state, tracer, fn_state);
    }
    fn block_3260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3260_0: read-var gs#118996:u8
        let s_3260_0: bool = fn_state.gs_118996;
        // N s_3260_1: branch s_3260_0 b3859 b3261
        if s_3260_0 {
            return block_3859(state, tracer, fn_state);
        } else {
            return block_3261(state, tracer, fn_state);
        };
    }
    fn block_3261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3261_0: const #0u : u8
        let s_3261_0: bool = false;
        // D s_3261_1: write-var gs#118997 <= s_3261_0
        fn_state.gs_118997 = s_3261_0;
        // N s_3261_2: jump b3262
        return block_3262(state, tracer, fn_state);
    }
    fn block_3262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3262_0: read-var gs#118997:u8
        let s_3262_0: bool = fn_state.gs_118997;
        // N s_3262_1: branch s_3262_0 b3858 b3263
        if s_3262_0 {
            return block_3858(state, tracer, fn_state);
        } else {
            return block_3263(state, tracer, fn_state);
        };
    }
    fn block_3263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3263_0: const #0u : u8
        let s_3263_0: bool = false;
        // D s_3263_1: write-var gs#118998 <= s_3263_0
        fn_state.gs_118998 = s_3263_0;
        // N s_3263_2: jump b3264
        return block_3264(state, tracer, fn_state);
    }
    fn block_3264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3264_0: read-var gs#118998:u8
        let s_3264_0: bool = fn_state.gs_118998;
        // N s_3264_1: branch s_3264_0 b3857 b3265
        if s_3264_0 {
            return block_3857(state, tracer, fn_state);
        } else {
            return block_3265(state, tracer, fn_state);
        };
    }
    fn block_3265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3265_0: const #0u : u8
        let s_3265_0: bool = false;
        // D s_3265_1: write-var gs#118999 <= s_3265_0
        fn_state.gs_118999 = s_3265_0;
        // N s_3265_2: jump b3266
        return block_3266(state, tracer, fn_state);
    }
    fn block_3266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3266_0: read-var gs#118999:u8
        let s_3266_0: bool = fn_state.gs_118999;
        // N s_3266_1: branch s_3266_0 b3856 b3267
        if s_3266_0 {
            return block_3856(state, tracer, fn_state);
        } else {
            return block_3267(state, tracer, fn_state);
        };
    }
    fn block_3267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3267_0: read-var CRm:u8
        let s_3267_0: u8 = fn_state.CRm;
        // D s_3267_1: cast zx s_3267_0 -> bv
        let s_3267_1: Bits = Bits::new(s_3267_0 as u128, 4u16);
        // C s_3267_2: const #15u : u8
        let s_3267_2: u8 = 15;
        // C s_3267_3: cast zx s_3267_2 -> bv
        let s_3267_3: Bits = Bits::new(s_3267_2 as u128, 4u16);
        // D s_3267_4: cmp-eq s_3267_1 s_3267_3
        let s_3267_4: bool = ((s_3267_1) == (s_3267_3));
        // N s_3267_5: branch s_3267_4 b3855 b3268
        if s_3267_4 {
            return block_3855(state, tracer, fn_state);
        } else {
            return block_3268(state, tracer, fn_state);
        };
    }
    fn block_3268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3268_0: const #0u : u8
        let s_3268_0: bool = false;
        // D s_3268_1: write-var gs#119000 <= s_3268_0
        fn_state.gs_119000 = s_3268_0;
        // N s_3268_2: jump b3269
        return block_3269(state, tracer, fn_state);
    }
    fn block_3269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3269_0: read-var gs#119000:u8
        let s_3269_0: bool = fn_state.gs_119000;
        // N s_3269_1: branch s_3269_0 b3854 b3270
        if s_3269_0 {
            return block_3854(state, tracer, fn_state);
        } else {
            return block_3270(state, tracer, fn_state);
        };
    }
    fn block_3270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3270_0: const #0u : u8
        let s_3270_0: bool = false;
        // D s_3270_1: write-var gs#119001 <= s_3270_0
        fn_state.gs_119001 = s_3270_0;
        // N s_3270_2: jump b3271
        return block_3271(state, tracer, fn_state);
    }
    fn block_3271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3271_0: read-var gs#119001:u8
        let s_3271_0: bool = fn_state.gs_119001;
        // N s_3271_1: branch s_3271_0 b3853 b3272
        if s_3271_0 {
            return block_3853(state, tracer, fn_state);
        } else {
            return block_3272(state, tracer, fn_state);
        };
    }
    fn block_3272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3272_0: const #0u : u8
        let s_3272_0: bool = false;
        // D s_3272_1: write-var gs#119002 <= s_3272_0
        fn_state.gs_119002 = s_3272_0;
        // N s_3272_2: jump b3273
        return block_3273(state, tracer, fn_state);
    }
    fn block_3273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3273_0: read-var gs#119002:u8
        let s_3273_0: bool = fn_state.gs_119002;
        // N s_3273_1: branch s_3273_0 b3852 b3274
        if s_3273_0 {
            return block_3852(state, tracer, fn_state);
        } else {
            return block_3274(state, tracer, fn_state);
        };
    }
    fn block_3274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3274_0: const #0u : u8
        let s_3274_0: bool = false;
        // D s_3274_1: write-var gs#119003 <= s_3274_0
        fn_state.gs_119003 = s_3274_0;
        // N s_3274_2: jump b3275
        return block_3275(state, tracer, fn_state);
    }
    fn block_3275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3275_0: read-var gs#119003:u8
        let s_3275_0: bool = fn_state.gs_119003;
        // N s_3275_1: branch s_3275_0 b3851 b3276
        if s_3275_0 {
            return block_3851(state, tracer, fn_state);
        } else {
            return block_3276(state, tracer, fn_state);
        };
    }
    fn block_3276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3276_0: read-var CRm:u8
        let s_3276_0: u8 = fn_state.CRm;
        // D s_3276_1: cast zx s_3276_0 -> bv
        let s_3276_1: Bits = Bits::new(s_3276_0 as u128, 4u16);
        // C s_3276_2: const #15u : u8
        let s_3276_2: u8 = 15;
        // C s_3276_3: cast zx s_3276_2 -> bv
        let s_3276_3: Bits = Bits::new(s_3276_2 as u128, 4u16);
        // D s_3276_4: cmp-eq s_3276_1 s_3276_3
        let s_3276_4: bool = ((s_3276_1) == (s_3276_3));
        // N s_3276_5: branch s_3276_4 b3850 b3277
        if s_3276_4 {
            return block_3850(state, tracer, fn_state);
        } else {
            return block_3277(state, tracer, fn_state);
        };
    }
    fn block_3277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3277_0: const #0u : u8
        let s_3277_0: bool = false;
        // D s_3277_1: write-var gs#119004 <= s_3277_0
        fn_state.gs_119004 = s_3277_0;
        // N s_3277_2: jump b3278
        return block_3278(state, tracer, fn_state);
    }
    fn block_3278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3278_0: read-var gs#119004:u8
        let s_3278_0: bool = fn_state.gs_119004;
        // N s_3278_1: branch s_3278_0 b3849 b3279
        if s_3278_0 {
            return block_3849(state, tracer, fn_state);
        } else {
            return block_3279(state, tracer, fn_state);
        };
    }
    fn block_3279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3279_0: const #0u : u8
        let s_3279_0: bool = false;
        // D s_3279_1: write-var gs#119005 <= s_3279_0
        fn_state.gs_119005 = s_3279_0;
        // N s_3279_2: jump b3280
        return block_3280(state, tracer, fn_state);
    }
    fn block_3280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3280_0: read-var gs#119005:u8
        let s_3280_0: bool = fn_state.gs_119005;
        // N s_3280_1: branch s_3280_0 b3848 b3281
        if s_3280_0 {
            return block_3848(state, tracer, fn_state);
        } else {
            return block_3281(state, tracer, fn_state);
        };
    }
    fn block_3281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3281_0: const #0u : u8
        let s_3281_0: bool = false;
        // D s_3281_1: write-var gs#119006 <= s_3281_0
        fn_state.gs_119006 = s_3281_0;
        // N s_3281_2: jump b3282
        return block_3282(state, tracer, fn_state);
    }
    fn block_3282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3282_0: read-var gs#119006:u8
        let s_3282_0: bool = fn_state.gs_119006;
        // N s_3282_1: branch s_3282_0 b3847 b3283
        if s_3282_0 {
            return block_3847(state, tracer, fn_state);
        } else {
            return block_3283(state, tracer, fn_state);
        };
    }
    fn block_3283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3283_0: const #0u : u8
        let s_3283_0: bool = false;
        // D s_3283_1: write-var gs#119007 <= s_3283_0
        fn_state.gs_119007 = s_3283_0;
        // N s_3283_2: jump b3284
        return block_3284(state, tracer, fn_state);
    }
    fn block_3284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3284_0: read-var gs#119007:u8
        let s_3284_0: bool = fn_state.gs_119007;
        // N s_3284_1: branch s_3284_0 b3846 b3285
        if s_3284_0 {
            return block_3846(state, tracer, fn_state);
        } else {
            return block_3285(state, tracer, fn_state);
        };
    }
    fn block_3285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3285_0: read-var CRm:u8
        let s_3285_0: u8 = fn_state.CRm;
        // D s_3285_1: cast zx s_3285_0 -> bv
        let s_3285_1: Bits = Bits::new(s_3285_0 as u128, 4u16);
        // C s_3285_2: const #15u : u8
        let s_3285_2: u8 = 15;
        // C s_3285_3: cast zx s_3285_2 -> bv
        let s_3285_3: Bits = Bits::new(s_3285_2 as u128, 4u16);
        // D s_3285_4: cmp-eq s_3285_1 s_3285_3
        let s_3285_4: bool = ((s_3285_1) == (s_3285_3));
        // N s_3285_5: branch s_3285_4 b3845 b3286
        if s_3285_4 {
            return block_3845(state, tracer, fn_state);
        } else {
            return block_3286(state, tracer, fn_state);
        };
    }
    fn block_3286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3286_0: const #0u : u8
        let s_3286_0: bool = false;
        // D s_3286_1: write-var gs#119008 <= s_3286_0
        fn_state.gs_119008 = s_3286_0;
        // N s_3286_2: jump b3287
        return block_3287(state, tracer, fn_state);
    }
    fn block_3287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3287_0: read-var gs#119008:u8
        let s_3287_0: bool = fn_state.gs_119008;
        // N s_3287_1: branch s_3287_0 b3844 b3288
        if s_3287_0 {
            return block_3844(state, tracer, fn_state);
        } else {
            return block_3288(state, tracer, fn_state);
        };
    }
    fn block_3288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3288_0: const #0u : u8
        let s_3288_0: bool = false;
        // D s_3288_1: write-var gs#119009 <= s_3288_0
        fn_state.gs_119009 = s_3288_0;
        // N s_3288_2: jump b3289
        return block_3289(state, tracer, fn_state);
    }
    fn block_3289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3289_0: read-var gs#119009:u8
        let s_3289_0: bool = fn_state.gs_119009;
        // N s_3289_1: branch s_3289_0 b3843 b3290
        if s_3289_0 {
            return block_3843(state, tracer, fn_state);
        } else {
            return block_3290(state, tracer, fn_state);
        };
    }
    fn block_3290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3290_0: const #0u : u8
        let s_3290_0: bool = false;
        // D s_3290_1: write-var gs#119010 <= s_3290_0
        fn_state.gs_119010 = s_3290_0;
        // N s_3290_2: jump b3291
        return block_3291(state, tracer, fn_state);
    }
    fn block_3291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3291_0: read-var gs#119010:u8
        let s_3291_0: bool = fn_state.gs_119010;
        // N s_3291_1: branch s_3291_0 b3842 b3292
        if s_3291_0 {
            return block_3842(state, tracer, fn_state);
        } else {
            return block_3292(state, tracer, fn_state);
        };
    }
    fn block_3292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3292_0: const #0u : u8
        let s_3292_0: bool = false;
        // D s_3292_1: write-var gs#119011 <= s_3292_0
        fn_state.gs_119011 = s_3292_0;
        // N s_3292_2: jump b3293
        return block_3293(state, tracer, fn_state);
    }
    fn block_3293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3293_0: read-var gs#119011:u8
        let s_3293_0: bool = fn_state.gs_119011;
        // N s_3293_1: branch s_3293_0 b3841 b3294
        if s_3293_0 {
            return block_3841(state, tracer, fn_state);
        } else {
            return block_3294(state, tracer, fn_state);
        };
    }
    fn block_3294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3294_0: read-var CRm:u8
        let s_3294_0: u8 = fn_state.CRm;
        // D s_3294_1: cast zx s_3294_0 -> bv
        let s_3294_1: Bits = Bits::new(s_3294_0 as u128, 4u16);
        // C s_3294_2: const #15u : u8
        let s_3294_2: u8 = 15;
        // C s_3294_3: cast zx s_3294_2 -> bv
        let s_3294_3: Bits = Bits::new(s_3294_2 as u128, 4u16);
        // D s_3294_4: cmp-eq s_3294_1 s_3294_3
        let s_3294_4: bool = ((s_3294_1) == (s_3294_3));
        // N s_3294_5: branch s_3294_4 b3840 b3295
        if s_3294_4 {
            return block_3840(state, tracer, fn_state);
        } else {
            return block_3295(state, tracer, fn_state);
        };
    }
    fn block_3295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3295_0: const #0u : u8
        let s_3295_0: bool = false;
        // D s_3295_1: write-var gs#119012 <= s_3295_0
        fn_state.gs_119012 = s_3295_0;
        // N s_3295_2: jump b3296
        return block_3296(state, tracer, fn_state);
    }
    fn block_3296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3296_0: read-var gs#119012:u8
        let s_3296_0: bool = fn_state.gs_119012;
        // N s_3296_1: branch s_3296_0 b3839 b3297
        if s_3296_0 {
            return block_3839(state, tracer, fn_state);
        } else {
            return block_3297(state, tracer, fn_state);
        };
    }
    fn block_3297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3297_0: const #0u : u8
        let s_3297_0: bool = false;
        // D s_3297_1: write-var gs#119013 <= s_3297_0
        fn_state.gs_119013 = s_3297_0;
        // N s_3297_2: jump b3298
        return block_3298(state, tracer, fn_state);
    }
    fn block_3298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3298_0: read-var gs#119013:u8
        let s_3298_0: bool = fn_state.gs_119013;
        // N s_3298_1: branch s_3298_0 b3838 b3299
        if s_3298_0 {
            return block_3838(state, tracer, fn_state);
        } else {
            return block_3299(state, tracer, fn_state);
        };
    }
    fn block_3299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3299_0: const #0u : u8
        let s_3299_0: bool = false;
        // D s_3299_1: write-var gs#119014 <= s_3299_0
        fn_state.gs_119014 = s_3299_0;
        // N s_3299_2: jump b3300
        return block_3300(state, tracer, fn_state);
    }
    fn block_3300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3300_0: read-var gs#119014:u8
        let s_3300_0: bool = fn_state.gs_119014;
        // N s_3300_1: branch s_3300_0 b3837 b3301
        if s_3300_0 {
            return block_3837(state, tracer, fn_state);
        } else {
            return block_3301(state, tracer, fn_state);
        };
    }
    fn block_3301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3301_0: const #0u : u8
        let s_3301_0: bool = false;
        // D s_3301_1: write-var gs#119015 <= s_3301_0
        fn_state.gs_119015 = s_3301_0;
        // N s_3301_2: jump b3302
        return block_3302(state, tracer, fn_state);
    }
    fn block_3302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3302_0: read-var gs#119015:u8
        let s_3302_0: bool = fn_state.gs_119015;
        // N s_3302_1: branch s_3302_0 b3836 b3303
        if s_3302_0 {
            return block_3836(state, tracer, fn_state);
        } else {
            return block_3303(state, tracer, fn_state);
        };
    }
    fn block_3303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3303_0: read-var CRm:u8
        let s_3303_0: u8 = fn_state.CRm;
        // D s_3303_1: cast zx s_3303_0 -> bv
        let s_3303_1: Bits = Bits::new(s_3303_0 as u128, 4u16);
        // C s_3303_2: const #15u : u8
        let s_3303_2: u8 = 15;
        // C s_3303_3: cast zx s_3303_2 -> bv
        let s_3303_3: Bits = Bits::new(s_3303_2 as u128, 4u16);
        // D s_3303_4: cmp-eq s_3303_1 s_3303_3
        let s_3303_4: bool = ((s_3303_1) == (s_3303_3));
        // N s_3303_5: branch s_3303_4 b3835 b3304
        if s_3303_4 {
            return block_3835(state, tracer, fn_state);
        } else {
            return block_3304(state, tracer, fn_state);
        };
    }
    fn block_3304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3304_0: const #0u : u8
        let s_3304_0: bool = false;
        // D s_3304_1: write-var gs#119016 <= s_3304_0
        fn_state.gs_119016 = s_3304_0;
        // N s_3304_2: jump b3305
        return block_3305(state, tracer, fn_state);
    }
    fn block_3305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3305_0: read-var gs#119016:u8
        let s_3305_0: bool = fn_state.gs_119016;
        // N s_3305_1: branch s_3305_0 b3834 b3306
        if s_3305_0 {
            return block_3834(state, tracer, fn_state);
        } else {
            return block_3306(state, tracer, fn_state);
        };
    }
    fn block_3306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3306_0: const #0u : u8
        let s_3306_0: bool = false;
        // D s_3306_1: write-var gs#119017 <= s_3306_0
        fn_state.gs_119017 = s_3306_0;
        // N s_3306_2: jump b3307
        return block_3307(state, tracer, fn_state);
    }
    fn block_3307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3307_0: read-var gs#119017:u8
        let s_3307_0: bool = fn_state.gs_119017;
        // N s_3307_1: branch s_3307_0 b3833 b3308
        if s_3307_0 {
            return block_3833(state, tracer, fn_state);
        } else {
            return block_3308(state, tracer, fn_state);
        };
    }
    fn block_3308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3308_0: const #0u : u8
        let s_3308_0: bool = false;
        // D s_3308_1: write-var gs#119018 <= s_3308_0
        fn_state.gs_119018 = s_3308_0;
        // N s_3308_2: jump b3309
        return block_3309(state, tracer, fn_state);
    }
    fn block_3309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3309_0: read-var gs#119018:u8
        let s_3309_0: bool = fn_state.gs_119018;
        // N s_3309_1: branch s_3309_0 b3832 b3310
        if s_3309_0 {
            return block_3832(state, tracer, fn_state);
        } else {
            return block_3310(state, tracer, fn_state);
        };
    }
    fn block_3310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3310_0: const #0u : u8
        let s_3310_0: bool = false;
        // D s_3310_1: write-var gs#119019 <= s_3310_0
        fn_state.gs_119019 = s_3310_0;
        // N s_3310_2: jump b3311
        return block_3311(state, tracer, fn_state);
    }
    fn block_3311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3311_0: read-var gs#119019:u8
        let s_3311_0: bool = fn_state.gs_119019;
        // N s_3311_1: branch s_3311_0 b3831 b3312
        if s_3311_0 {
            return block_3831(state, tracer, fn_state);
        } else {
            return block_3312(state, tracer, fn_state);
        };
    }
    fn block_3312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3312_0: read-var CRm:u8
        let s_3312_0: u8 = fn_state.CRm;
        // D s_3312_1: cast zx s_3312_0 -> bv
        let s_3312_1: Bits = Bits::new(s_3312_0 as u128, 4u16);
        // C s_3312_2: const #15u : u8
        let s_3312_2: u8 = 15;
        // C s_3312_3: cast zx s_3312_2 -> bv
        let s_3312_3: Bits = Bits::new(s_3312_2 as u128, 4u16);
        // D s_3312_4: cmp-eq s_3312_1 s_3312_3
        let s_3312_4: bool = ((s_3312_1) == (s_3312_3));
        // N s_3312_5: branch s_3312_4 b3830 b3313
        if s_3312_4 {
            return block_3830(state, tracer, fn_state);
        } else {
            return block_3313(state, tracer, fn_state);
        };
    }
    fn block_3313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3313_0: const #0u : u8
        let s_3313_0: bool = false;
        // D s_3313_1: write-var gs#119020 <= s_3313_0
        fn_state.gs_119020 = s_3313_0;
        // N s_3313_2: jump b3314
        return block_3314(state, tracer, fn_state);
    }
    fn block_3314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3314_0: read-var gs#119020:u8
        let s_3314_0: bool = fn_state.gs_119020;
        // N s_3314_1: branch s_3314_0 b3829 b3315
        if s_3314_0 {
            return block_3829(state, tracer, fn_state);
        } else {
            return block_3315(state, tracer, fn_state);
        };
    }
    fn block_3315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3315_0: const #0u : u8
        let s_3315_0: bool = false;
        // D s_3315_1: write-var gs#119021 <= s_3315_0
        fn_state.gs_119021 = s_3315_0;
        // N s_3315_2: jump b3316
        return block_3316(state, tracer, fn_state);
    }
    fn block_3316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3316_0: read-var gs#119021:u8
        let s_3316_0: bool = fn_state.gs_119021;
        // N s_3316_1: branch s_3316_0 b3828 b3317
        if s_3316_0 {
            return block_3828(state, tracer, fn_state);
        } else {
            return block_3317(state, tracer, fn_state);
        };
    }
    fn block_3317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3317_0: const #0u : u8
        let s_3317_0: bool = false;
        // D s_3317_1: write-var gs#119022 <= s_3317_0
        fn_state.gs_119022 = s_3317_0;
        // N s_3317_2: jump b3318
        return block_3318(state, tracer, fn_state);
    }
    fn block_3318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3318_0: read-var gs#119022:u8
        let s_3318_0: bool = fn_state.gs_119022;
        // N s_3318_1: branch s_3318_0 b3827 b3319
        if s_3318_0 {
            return block_3827(state, tracer, fn_state);
        } else {
            return block_3319(state, tracer, fn_state);
        };
    }
    fn block_3319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3319_0: const #0u : u8
        let s_3319_0: bool = false;
        // D s_3319_1: write-var gs#119023 <= s_3319_0
        fn_state.gs_119023 = s_3319_0;
        // N s_3319_2: jump b3320
        return block_3320(state, tracer, fn_state);
    }
    fn block_3320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3320_0: read-var gs#119023:u8
        let s_3320_0: bool = fn_state.gs_119023;
        // N s_3320_1: branch s_3320_0 b3826 b3321
        if s_3320_0 {
            return block_3826(state, tracer, fn_state);
        } else {
            return block_3321(state, tracer, fn_state);
        };
    }
    fn block_3321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3321_0: read-var CRm:u8
        let s_3321_0: u8 = fn_state.CRm;
        // D s_3321_1: cast zx s_3321_0 -> bv
        let s_3321_1: Bits = Bits::new(s_3321_0 as u128, 4u16);
        // C s_3321_2: const #14u : u8
        let s_3321_2: u8 = 14;
        // C s_3321_3: cast zx s_3321_2 -> bv
        let s_3321_3: Bits = Bits::new(s_3321_2 as u128, 4u16);
        // D s_3321_4: cmp-eq s_3321_1 s_3321_3
        let s_3321_4: bool = ((s_3321_1) == (s_3321_3));
        // N s_3321_5: branch s_3321_4 b3825 b3322
        if s_3321_4 {
            return block_3825(state, tracer, fn_state);
        } else {
            return block_3322(state, tracer, fn_state);
        };
    }
    fn block_3322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3322_0: const #0u : u8
        let s_3322_0: bool = false;
        // D s_3322_1: write-var gs#119024 <= s_3322_0
        fn_state.gs_119024 = s_3322_0;
        // N s_3322_2: jump b3323
        return block_3323(state, tracer, fn_state);
    }
    fn block_3323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3323_0: read-var gs#119024:u8
        let s_3323_0: bool = fn_state.gs_119024;
        // N s_3323_1: branch s_3323_0 b3824 b3324
        if s_3323_0 {
            return block_3824(state, tracer, fn_state);
        } else {
            return block_3324(state, tracer, fn_state);
        };
    }
    fn block_3324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3324_0: const #0u : u8
        let s_3324_0: bool = false;
        // D s_3324_1: write-var gs#119025 <= s_3324_0
        fn_state.gs_119025 = s_3324_0;
        // N s_3324_2: jump b3325
        return block_3325(state, tracer, fn_state);
    }
    fn block_3325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3325_0: read-var gs#119025:u8
        let s_3325_0: bool = fn_state.gs_119025;
        // N s_3325_1: branch s_3325_0 b3823 b3326
        if s_3325_0 {
            return block_3823(state, tracer, fn_state);
        } else {
            return block_3326(state, tracer, fn_state);
        };
    }
    fn block_3326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3326_0: const #0u : u8
        let s_3326_0: bool = false;
        // D s_3326_1: write-var gs#119026 <= s_3326_0
        fn_state.gs_119026 = s_3326_0;
        // N s_3326_2: jump b3327
        return block_3327(state, tracer, fn_state);
    }
    fn block_3327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3327_0: read-var gs#119026:u8
        let s_3327_0: bool = fn_state.gs_119026;
        // N s_3327_1: branch s_3327_0 b3822 b3328
        if s_3327_0 {
            return block_3822(state, tracer, fn_state);
        } else {
            return block_3328(state, tracer, fn_state);
        };
    }
    fn block_3328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3328_0: const #0u : u8
        let s_3328_0: bool = false;
        // D s_3328_1: write-var gs#119027 <= s_3328_0
        fn_state.gs_119027 = s_3328_0;
        // N s_3328_2: jump b3329
        return block_3329(state, tracer, fn_state);
    }
    fn block_3329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3329_0: read-var gs#119027:u8
        let s_3329_0: bool = fn_state.gs_119027;
        // N s_3329_1: branch s_3329_0 b3821 b3330
        if s_3329_0 {
            return block_3821(state, tracer, fn_state);
        } else {
            return block_3330(state, tracer, fn_state);
        };
    }
    fn block_3330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3330_0: read-var CRm:u8
        let s_3330_0: u8 = fn_state.CRm;
        // D s_3330_1: cast zx s_3330_0 -> bv
        let s_3330_1: Bits = Bits::new(s_3330_0 as u128, 4u16);
        // C s_3330_2: const #14u : u8
        let s_3330_2: u8 = 14;
        // C s_3330_3: cast zx s_3330_2 -> bv
        let s_3330_3: Bits = Bits::new(s_3330_2 as u128, 4u16);
        // D s_3330_4: cmp-eq s_3330_1 s_3330_3
        let s_3330_4: bool = ((s_3330_1) == (s_3330_3));
        // N s_3330_5: branch s_3330_4 b3820 b3331
        if s_3330_4 {
            return block_3820(state, tracer, fn_state);
        } else {
            return block_3331(state, tracer, fn_state);
        };
    }
    fn block_3331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3331_0: const #0u : u8
        let s_3331_0: bool = false;
        // D s_3331_1: write-var gs#119028 <= s_3331_0
        fn_state.gs_119028 = s_3331_0;
        // N s_3331_2: jump b3332
        return block_3332(state, tracer, fn_state);
    }
    fn block_3332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3332_0: read-var gs#119028:u8
        let s_3332_0: bool = fn_state.gs_119028;
        // N s_3332_1: branch s_3332_0 b3819 b3333
        if s_3332_0 {
            return block_3819(state, tracer, fn_state);
        } else {
            return block_3333(state, tracer, fn_state);
        };
    }
    fn block_3333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3333_0: const #0u : u8
        let s_3333_0: bool = false;
        // D s_3333_1: write-var gs#119029 <= s_3333_0
        fn_state.gs_119029 = s_3333_0;
        // N s_3333_2: jump b3334
        return block_3334(state, tracer, fn_state);
    }
    fn block_3334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3334_0: read-var gs#119029:u8
        let s_3334_0: bool = fn_state.gs_119029;
        // N s_3334_1: branch s_3334_0 b3818 b3335
        if s_3334_0 {
            return block_3818(state, tracer, fn_state);
        } else {
            return block_3335(state, tracer, fn_state);
        };
    }
    fn block_3335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3335_0: const #0u : u8
        let s_3335_0: bool = false;
        // D s_3335_1: write-var gs#119030 <= s_3335_0
        fn_state.gs_119030 = s_3335_0;
        // N s_3335_2: jump b3336
        return block_3336(state, tracer, fn_state);
    }
    fn block_3336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3336_0: read-var gs#119030:u8
        let s_3336_0: bool = fn_state.gs_119030;
        // N s_3336_1: branch s_3336_0 b3817 b3337
        if s_3336_0 {
            return block_3817(state, tracer, fn_state);
        } else {
            return block_3337(state, tracer, fn_state);
        };
    }
    fn block_3337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3337_0: const #0u : u8
        let s_3337_0: bool = false;
        // D s_3337_1: write-var gs#119031 <= s_3337_0
        fn_state.gs_119031 = s_3337_0;
        // N s_3337_2: jump b3338
        return block_3338(state, tracer, fn_state);
    }
    fn block_3338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3338_0: read-var gs#119031:u8
        let s_3338_0: bool = fn_state.gs_119031;
        // N s_3338_1: branch s_3338_0 b3816 b3339
        if s_3338_0 {
            return block_3816(state, tracer, fn_state);
        } else {
            return block_3339(state, tracer, fn_state);
        };
    }
    fn block_3339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3339_0: read-var CRm:u8
        let s_3339_0: u8 = fn_state.CRm;
        // D s_3339_1: cast zx s_3339_0 -> bv
        let s_3339_1: Bits = Bits::new(s_3339_0 as u128, 4u16);
        // C s_3339_2: const #14u : u8
        let s_3339_2: u8 = 14;
        // C s_3339_3: cast zx s_3339_2 -> bv
        let s_3339_3: Bits = Bits::new(s_3339_2 as u128, 4u16);
        // D s_3339_4: cmp-eq s_3339_1 s_3339_3
        let s_3339_4: bool = ((s_3339_1) == (s_3339_3));
        // N s_3339_5: branch s_3339_4 b3815 b3340
        if s_3339_4 {
            return block_3815(state, tracer, fn_state);
        } else {
            return block_3340(state, tracer, fn_state);
        };
    }
    fn block_3340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3340_0: const #0u : u8
        let s_3340_0: bool = false;
        // D s_3340_1: write-var gs#119032 <= s_3340_0
        fn_state.gs_119032 = s_3340_0;
        // N s_3340_2: jump b3341
        return block_3341(state, tracer, fn_state);
    }
    fn block_3341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3341_0: read-var gs#119032:u8
        let s_3341_0: bool = fn_state.gs_119032;
        // N s_3341_1: branch s_3341_0 b3814 b3342
        if s_3341_0 {
            return block_3814(state, tracer, fn_state);
        } else {
            return block_3342(state, tracer, fn_state);
        };
    }
    fn block_3342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3342_0: const #0u : u8
        let s_3342_0: bool = false;
        // D s_3342_1: write-var gs#119033 <= s_3342_0
        fn_state.gs_119033 = s_3342_0;
        // N s_3342_2: jump b3343
        return block_3343(state, tracer, fn_state);
    }
    fn block_3343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3343_0: read-var gs#119033:u8
        let s_3343_0: bool = fn_state.gs_119033;
        // N s_3343_1: branch s_3343_0 b3813 b3344
        if s_3343_0 {
            return block_3813(state, tracer, fn_state);
        } else {
            return block_3344(state, tracer, fn_state);
        };
    }
    fn block_3344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3344_0: const #0u : u8
        let s_3344_0: bool = false;
        // D s_3344_1: write-var gs#119034 <= s_3344_0
        fn_state.gs_119034 = s_3344_0;
        // N s_3344_2: jump b3345
        return block_3345(state, tracer, fn_state);
    }
    fn block_3345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3345_0: read-var gs#119034:u8
        let s_3345_0: bool = fn_state.gs_119034;
        // N s_3345_1: branch s_3345_0 b3812 b3346
        if s_3345_0 {
            return block_3812(state, tracer, fn_state);
        } else {
            return block_3346(state, tracer, fn_state);
        };
    }
    fn block_3346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3346_0: const #0u : u8
        let s_3346_0: bool = false;
        // D s_3346_1: write-var gs#119035 <= s_3346_0
        fn_state.gs_119035 = s_3346_0;
        // N s_3346_2: jump b3347
        return block_3347(state, tracer, fn_state);
    }
    fn block_3347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3347_0: read-var gs#119035:u8
        let s_3347_0: bool = fn_state.gs_119035;
        // N s_3347_1: branch s_3347_0 b3811 b3348
        if s_3347_0 {
            return block_3811(state, tracer, fn_state);
        } else {
            return block_3348(state, tracer, fn_state);
        };
    }
    fn block_3348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3348_0: read-var CRm:u8
        let s_3348_0: u8 = fn_state.CRm;
        // D s_3348_1: cast zx s_3348_0 -> bv
        let s_3348_1: Bits = Bits::new(s_3348_0 as u128, 4u16);
        // C s_3348_2: const #14u : u8
        let s_3348_2: u8 = 14;
        // C s_3348_3: cast zx s_3348_2 -> bv
        let s_3348_3: Bits = Bits::new(s_3348_2 as u128, 4u16);
        // D s_3348_4: cmp-eq s_3348_1 s_3348_3
        let s_3348_4: bool = ((s_3348_1) == (s_3348_3));
        // N s_3348_5: branch s_3348_4 b3810 b3349
        if s_3348_4 {
            return block_3810(state, tracer, fn_state);
        } else {
            return block_3349(state, tracer, fn_state);
        };
    }
    fn block_3349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3349_0: const #0u : u8
        let s_3349_0: bool = false;
        // D s_3349_1: write-var gs#119036 <= s_3349_0
        fn_state.gs_119036 = s_3349_0;
        // N s_3349_2: jump b3350
        return block_3350(state, tracer, fn_state);
    }
    fn block_3350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3350_0: read-var gs#119036:u8
        let s_3350_0: bool = fn_state.gs_119036;
        // N s_3350_1: branch s_3350_0 b3809 b3351
        if s_3350_0 {
            return block_3809(state, tracer, fn_state);
        } else {
            return block_3351(state, tracer, fn_state);
        };
    }
    fn block_3351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3351_0: const #0u : u8
        let s_3351_0: bool = false;
        // D s_3351_1: write-var gs#119037 <= s_3351_0
        fn_state.gs_119037 = s_3351_0;
        // N s_3351_2: jump b3352
        return block_3352(state, tracer, fn_state);
    }
    fn block_3352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3352_0: read-var gs#119037:u8
        let s_3352_0: bool = fn_state.gs_119037;
        // N s_3352_1: branch s_3352_0 b3808 b3353
        if s_3352_0 {
            return block_3808(state, tracer, fn_state);
        } else {
            return block_3353(state, tracer, fn_state);
        };
    }
    fn block_3353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3353_0: const #0u : u8
        let s_3353_0: bool = false;
        // D s_3353_1: write-var gs#119038 <= s_3353_0
        fn_state.gs_119038 = s_3353_0;
        // N s_3353_2: jump b3354
        return block_3354(state, tracer, fn_state);
    }
    fn block_3354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3354_0: read-var gs#119038:u8
        let s_3354_0: bool = fn_state.gs_119038;
        // N s_3354_1: branch s_3354_0 b3807 b3355
        if s_3354_0 {
            return block_3807(state, tracer, fn_state);
        } else {
            return block_3355(state, tracer, fn_state);
        };
    }
    fn block_3355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3355_0: const #0u : u8
        let s_3355_0: bool = false;
        // D s_3355_1: write-var gs#119039 <= s_3355_0
        fn_state.gs_119039 = s_3355_0;
        // N s_3355_2: jump b3356
        return block_3356(state, tracer, fn_state);
    }
    fn block_3356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3356_0: read-var gs#119039:u8
        let s_3356_0: bool = fn_state.gs_119039;
        // N s_3356_1: branch s_3356_0 b3806 b3357
        if s_3356_0 {
            return block_3806(state, tracer, fn_state);
        } else {
            return block_3357(state, tracer, fn_state);
        };
    }
    fn block_3357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3357_0: read-var CRm:u8
        let s_3357_0: u8 = fn_state.CRm;
        // D s_3357_1: cast zx s_3357_0 -> bv
        let s_3357_1: Bits = Bits::new(s_3357_0 as u128, 4u16);
        // C s_3357_2: const #14u : u8
        let s_3357_2: u8 = 14;
        // C s_3357_3: cast zx s_3357_2 -> bv
        let s_3357_3: Bits = Bits::new(s_3357_2 as u128, 4u16);
        // D s_3357_4: cmp-eq s_3357_1 s_3357_3
        let s_3357_4: bool = ((s_3357_1) == (s_3357_3));
        // N s_3357_5: branch s_3357_4 b3805 b3358
        if s_3357_4 {
            return block_3805(state, tracer, fn_state);
        } else {
            return block_3358(state, tracer, fn_state);
        };
    }
    fn block_3358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3358_0: const #0u : u8
        let s_3358_0: bool = false;
        // D s_3358_1: write-var gs#119040 <= s_3358_0
        fn_state.gs_119040 = s_3358_0;
        // N s_3358_2: jump b3359
        return block_3359(state, tracer, fn_state);
    }
    fn block_3359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3359_0: read-var gs#119040:u8
        let s_3359_0: bool = fn_state.gs_119040;
        // N s_3359_1: branch s_3359_0 b3804 b3360
        if s_3359_0 {
            return block_3804(state, tracer, fn_state);
        } else {
            return block_3360(state, tracer, fn_state);
        };
    }
    fn block_3360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3360_0: const #0u : u8
        let s_3360_0: bool = false;
        // D s_3360_1: write-var gs#119041 <= s_3360_0
        fn_state.gs_119041 = s_3360_0;
        // N s_3360_2: jump b3361
        return block_3361(state, tracer, fn_state);
    }
    fn block_3361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3361_0: read-var gs#119041:u8
        let s_3361_0: bool = fn_state.gs_119041;
        // N s_3361_1: branch s_3361_0 b3803 b3362
        if s_3361_0 {
            return block_3803(state, tracer, fn_state);
        } else {
            return block_3362(state, tracer, fn_state);
        };
    }
    fn block_3362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3362_0: const #0u : u8
        let s_3362_0: bool = false;
        // D s_3362_1: write-var gs#119042 <= s_3362_0
        fn_state.gs_119042 = s_3362_0;
        // N s_3362_2: jump b3363
        return block_3363(state, tracer, fn_state);
    }
    fn block_3363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3363_0: read-var gs#119042:u8
        let s_3363_0: bool = fn_state.gs_119042;
        // N s_3363_1: branch s_3363_0 b3802 b3364
        if s_3363_0 {
            return block_3802(state, tracer, fn_state);
        } else {
            return block_3364(state, tracer, fn_state);
        };
    }
    fn block_3364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3364_0: const #0u : u8
        let s_3364_0: bool = false;
        // D s_3364_1: write-var gs#119043 <= s_3364_0
        fn_state.gs_119043 = s_3364_0;
        // N s_3364_2: jump b3365
        return block_3365(state, tracer, fn_state);
    }
    fn block_3365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3365_0: read-var gs#119043:u8
        let s_3365_0: bool = fn_state.gs_119043;
        // N s_3365_1: branch s_3365_0 b3801 b3366
        if s_3365_0 {
            return block_3801(state, tracer, fn_state);
        } else {
            return block_3366(state, tracer, fn_state);
        };
    }
    fn block_3366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3366_0: read-var CRm:u8
        let s_3366_0: u8 = fn_state.CRm;
        // D s_3366_1: cast zx s_3366_0 -> bv
        let s_3366_1: Bits = Bits::new(s_3366_0 as u128, 4u16);
        // C s_3366_2: const #14u : u8
        let s_3366_2: u8 = 14;
        // C s_3366_3: cast zx s_3366_2 -> bv
        let s_3366_3: Bits = Bits::new(s_3366_2 as u128, 4u16);
        // D s_3366_4: cmp-eq s_3366_1 s_3366_3
        let s_3366_4: bool = ((s_3366_1) == (s_3366_3));
        // N s_3366_5: branch s_3366_4 b3800 b3367
        if s_3366_4 {
            return block_3800(state, tracer, fn_state);
        } else {
            return block_3367(state, tracer, fn_state);
        };
    }
    fn block_3367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3367_0: const #0u : u8
        let s_3367_0: bool = false;
        // D s_3367_1: write-var gs#119044 <= s_3367_0
        fn_state.gs_119044 = s_3367_0;
        // N s_3367_2: jump b3368
        return block_3368(state, tracer, fn_state);
    }
    fn block_3368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3368_0: read-var gs#119044:u8
        let s_3368_0: bool = fn_state.gs_119044;
        // N s_3368_1: branch s_3368_0 b3799 b3369
        if s_3368_0 {
            return block_3799(state, tracer, fn_state);
        } else {
            return block_3369(state, tracer, fn_state);
        };
    }
    fn block_3369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3369_0: const #0u : u8
        let s_3369_0: bool = false;
        // D s_3369_1: write-var gs#119045 <= s_3369_0
        fn_state.gs_119045 = s_3369_0;
        // N s_3369_2: jump b3370
        return block_3370(state, tracer, fn_state);
    }
    fn block_3370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3370_0: read-var gs#119045:u8
        let s_3370_0: bool = fn_state.gs_119045;
        // N s_3370_1: branch s_3370_0 b3798 b3371
        if s_3370_0 {
            return block_3798(state, tracer, fn_state);
        } else {
            return block_3371(state, tracer, fn_state);
        };
    }
    fn block_3371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3371_0: const #0u : u8
        let s_3371_0: bool = false;
        // D s_3371_1: write-var gs#119046 <= s_3371_0
        fn_state.gs_119046 = s_3371_0;
        // N s_3371_2: jump b3372
        return block_3372(state, tracer, fn_state);
    }
    fn block_3372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3372_0: read-var gs#119046:u8
        let s_3372_0: bool = fn_state.gs_119046;
        // N s_3372_1: branch s_3372_0 b3797 b3373
        if s_3372_0 {
            return block_3797(state, tracer, fn_state);
        } else {
            return block_3373(state, tracer, fn_state);
        };
    }
    fn block_3373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3373_0: const #0u : u8
        let s_3373_0: bool = false;
        // D s_3373_1: write-var gs#119047 <= s_3373_0
        fn_state.gs_119047 = s_3373_0;
        // N s_3373_2: jump b3374
        return block_3374(state, tracer, fn_state);
    }
    fn block_3374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3374_0: read-var gs#119047:u8
        let s_3374_0: bool = fn_state.gs_119047;
        // N s_3374_1: branch s_3374_0 b3796 b3375
        if s_3374_0 {
            return block_3796(state, tracer, fn_state);
        } else {
            return block_3375(state, tracer, fn_state);
        };
    }
    fn block_3375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3375_0: read-var CRm:u8
        let s_3375_0: u8 = fn_state.CRm;
        // D s_3375_1: cast zx s_3375_0 -> bv
        let s_3375_1: Bits = Bits::new(s_3375_0 as u128, 4u16);
        // C s_3375_2: const #14u : u8
        let s_3375_2: u8 = 14;
        // C s_3375_3: cast zx s_3375_2 -> bv
        let s_3375_3: Bits = Bits::new(s_3375_2 as u128, 4u16);
        // D s_3375_4: cmp-eq s_3375_1 s_3375_3
        let s_3375_4: bool = ((s_3375_1) == (s_3375_3));
        // N s_3375_5: branch s_3375_4 b3795 b3376
        if s_3375_4 {
            return block_3795(state, tracer, fn_state);
        } else {
            return block_3376(state, tracer, fn_state);
        };
    }
    fn block_3376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3376_0: const #0u : u8
        let s_3376_0: bool = false;
        // D s_3376_1: write-var gs#119048 <= s_3376_0
        fn_state.gs_119048 = s_3376_0;
        // N s_3376_2: jump b3377
        return block_3377(state, tracer, fn_state);
    }
    fn block_3377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3377_0: read-var gs#119048:u8
        let s_3377_0: bool = fn_state.gs_119048;
        // N s_3377_1: branch s_3377_0 b3794 b3378
        if s_3377_0 {
            return block_3794(state, tracer, fn_state);
        } else {
            return block_3378(state, tracer, fn_state);
        };
    }
    fn block_3378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3378_0: const #0u : u8
        let s_3378_0: bool = false;
        // D s_3378_1: write-var gs#119049 <= s_3378_0
        fn_state.gs_119049 = s_3378_0;
        // N s_3378_2: jump b3379
        return block_3379(state, tracer, fn_state);
    }
    fn block_3379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3379_0: read-var gs#119049:u8
        let s_3379_0: bool = fn_state.gs_119049;
        // N s_3379_1: branch s_3379_0 b3793 b3380
        if s_3379_0 {
            return block_3793(state, tracer, fn_state);
        } else {
            return block_3380(state, tracer, fn_state);
        };
    }
    fn block_3380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3380_0: const #0u : u8
        let s_3380_0: bool = false;
        // D s_3380_1: write-var gs#119050 <= s_3380_0
        fn_state.gs_119050 = s_3380_0;
        // N s_3380_2: jump b3381
        return block_3381(state, tracer, fn_state);
    }
    fn block_3381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3381_0: read-var gs#119050:u8
        let s_3381_0: bool = fn_state.gs_119050;
        // N s_3381_1: branch s_3381_0 b3792 b3382
        if s_3381_0 {
            return block_3792(state, tracer, fn_state);
        } else {
            return block_3382(state, tracer, fn_state);
        };
    }
    fn block_3382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3382_0: const #0u : u8
        let s_3382_0: bool = false;
        // D s_3382_1: write-var gs#119051 <= s_3382_0
        fn_state.gs_119051 = s_3382_0;
        // N s_3382_2: jump b3383
        return block_3383(state, tracer, fn_state);
    }
    fn block_3383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3383_0: read-var gs#119051:u8
        let s_3383_0: bool = fn_state.gs_119051;
        // N s_3383_1: branch s_3383_0 b3791 b3384
        if s_3383_0 {
            return block_3791(state, tracer, fn_state);
        } else {
            return block_3384(state, tracer, fn_state);
        };
    }
    fn block_3384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3384_0: read-var CRm:u8
        let s_3384_0: u8 = fn_state.CRm;
        // D s_3384_1: cast zx s_3384_0 -> bv
        let s_3384_1: Bits = Bits::new(s_3384_0 as u128, 4u16);
        // C s_3384_2: const #14u : u8
        let s_3384_2: u8 = 14;
        // C s_3384_3: cast zx s_3384_2 -> bv
        let s_3384_3: Bits = Bits::new(s_3384_2 as u128, 4u16);
        // D s_3384_4: cmp-eq s_3384_1 s_3384_3
        let s_3384_4: bool = ((s_3384_1) == (s_3384_3));
        // N s_3384_5: branch s_3384_4 b3790 b3385
        if s_3384_4 {
            return block_3790(state, tracer, fn_state);
        } else {
            return block_3385(state, tracer, fn_state);
        };
    }
    fn block_3385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3385_0: const #0u : u8
        let s_3385_0: bool = false;
        // D s_3385_1: write-var gs#119052 <= s_3385_0
        fn_state.gs_119052 = s_3385_0;
        // N s_3385_2: jump b3386
        return block_3386(state, tracer, fn_state);
    }
    fn block_3386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3386_0: read-var gs#119052:u8
        let s_3386_0: bool = fn_state.gs_119052;
        // N s_3386_1: branch s_3386_0 b3789 b3387
        if s_3386_0 {
            return block_3789(state, tracer, fn_state);
        } else {
            return block_3387(state, tracer, fn_state);
        };
    }
    fn block_3387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3387_0: const #0u : u8
        let s_3387_0: bool = false;
        // D s_3387_1: write-var gs#119053 <= s_3387_0
        fn_state.gs_119053 = s_3387_0;
        // N s_3387_2: jump b3388
        return block_3388(state, tracer, fn_state);
    }
    fn block_3388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3388_0: read-var gs#119053:u8
        let s_3388_0: bool = fn_state.gs_119053;
        // N s_3388_1: branch s_3388_0 b3788 b3389
        if s_3388_0 {
            return block_3788(state, tracer, fn_state);
        } else {
            return block_3389(state, tracer, fn_state);
        };
    }
    fn block_3389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3389_0: const #0u : u8
        let s_3389_0: bool = false;
        // D s_3389_1: write-var gs#119054 <= s_3389_0
        fn_state.gs_119054 = s_3389_0;
        // N s_3389_2: jump b3390
        return block_3390(state, tracer, fn_state);
    }
    fn block_3390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3390_0: read-var gs#119054:u8
        let s_3390_0: bool = fn_state.gs_119054;
        // N s_3390_1: branch s_3390_0 b3787 b3391
        if s_3390_0 {
            return block_3787(state, tracer, fn_state);
        } else {
            return block_3391(state, tracer, fn_state);
        };
    }
    fn block_3391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3391_0: const #0u : u8
        let s_3391_0: bool = false;
        // D s_3391_1: write-var gs#119055 <= s_3391_0
        fn_state.gs_119055 = s_3391_0;
        // N s_3391_2: jump b3392
        return block_3392(state, tracer, fn_state);
    }
    fn block_3392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3392_0: read-var gs#119055:u8
        let s_3392_0: bool = fn_state.gs_119055;
        // N s_3392_1: branch s_3392_0 b3786 b3393
        if s_3392_0 {
            return block_3786(state, tracer, fn_state);
        } else {
            return block_3393(state, tracer, fn_state);
        };
    }
    fn block_3393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3393_0: read-var CRm:u8
        let s_3393_0: u8 = fn_state.CRm;
        // D s_3393_1: cast zx s_3393_0 -> bv
        let s_3393_1: Bits = Bits::new(s_3393_0 as u128, 4u16);
        // C s_3393_2: const #2u : u8
        let s_3393_2: u8 = 2;
        // C s_3393_3: cast zx s_3393_2 -> bv
        let s_3393_3: Bits = Bits::new(s_3393_2 as u128, 4u16);
        // D s_3393_4: cmp-eq s_3393_1 s_3393_3
        let s_3393_4: bool = ((s_3393_1) == (s_3393_3));
        // N s_3393_5: branch s_3393_4 b3785 b3394
        if s_3393_4 {
            return block_3785(state, tracer, fn_state);
        } else {
            return block_3394(state, tracer, fn_state);
        };
    }
    fn block_3394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3394_0: const #0u : u8
        let s_3394_0: bool = false;
        // D s_3394_1: write-var gs#119056 <= s_3394_0
        fn_state.gs_119056 = s_3394_0;
        // N s_3394_2: jump b3395
        return block_3395(state, tracer, fn_state);
    }
    fn block_3395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3395_0: read-var gs#119056:u8
        let s_3395_0: bool = fn_state.gs_119056;
        // N s_3395_1: branch s_3395_0 b3784 b3396
        if s_3395_0 {
            return block_3784(state, tracer, fn_state);
        } else {
            return block_3396(state, tracer, fn_state);
        };
    }
    fn block_3396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3396_0: const #0u : u8
        let s_3396_0: bool = false;
        // D s_3396_1: write-var gs#119057 <= s_3396_0
        fn_state.gs_119057 = s_3396_0;
        // N s_3396_2: jump b3397
        return block_3397(state, tracer, fn_state);
    }
    fn block_3397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3397_0: read-var gs#119057:u8
        let s_3397_0: bool = fn_state.gs_119057;
        // N s_3397_1: branch s_3397_0 b3783 b3398
        if s_3397_0 {
            return block_3783(state, tracer, fn_state);
        } else {
            return block_3398(state, tracer, fn_state);
        };
    }
    fn block_3398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3398_0: const #0u : u8
        let s_3398_0: bool = false;
        // D s_3398_1: write-var gs#119058 <= s_3398_0
        fn_state.gs_119058 = s_3398_0;
        // N s_3398_2: jump b3399
        return block_3399(state, tracer, fn_state);
    }
    fn block_3399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3399_0: read-var gs#119058:u8
        let s_3399_0: bool = fn_state.gs_119058;
        // N s_3399_1: branch s_3399_0 b3782 b3400
        if s_3399_0 {
            return block_3782(state, tracer, fn_state);
        } else {
            return block_3400(state, tracer, fn_state);
        };
    }
    fn block_3400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3400_0: const #0u : u8
        let s_3400_0: bool = false;
        // D s_3400_1: write-var gs#119059 <= s_3400_0
        fn_state.gs_119059 = s_3400_0;
        // N s_3400_2: jump b3401
        return block_3401(state, tracer, fn_state);
    }
    fn block_3401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3401_0: read-var gs#119059:u8
        let s_3401_0: bool = fn_state.gs_119059;
        // N s_3401_1: branch s_3401_0 b3781 b3402
        if s_3401_0 {
            return block_3781(state, tracer, fn_state);
        } else {
            return block_3402(state, tracer, fn_state);
        };
    }
    fn block_3402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3402_0: read-var CRm:u8
        let s_3402_0: u8 = fn_state.CRm;
        // D s_3402_1: cast zx s_3402_0 -> bv
        let s_3402_1: Bits = Bits::new(s_3402_0 as u128, 4u16);
        // C s_3402_2: const #2u : u8
        let s_3402_2: u8 = 2;
        // C s_3402_3: cast zx s_3402_2 -> bv
        let s_3402_3: Bits = Bits::new(s_3402_2 as u128, 4u16);
        // D s_3402_4: cmp-eq s_3402_1 s_3402_3
        let s_3402_4: bool = ((s_3402_1) == (s_3402_3));
        // N s_3402_5: branch s_3402_4 b3780 b3403
        if s_3402_4 {
            return block_3780(state, tracer, fn_state);
        } else {
            return block_3403(state, tracer, fn_state);
        };
    }
    fn block_3403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3403_0: const #0u : u8
        let s_3403_0: bool = false;
        // D s_3403_1: write-var gs#119060 <= s_3403_0
        fn_state.gs_119060 = s_3403_0;
        // N s_3403_2: jump b3404
        return block_3404(state, tracer, fn_state);
    }
    fn block_3404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3404_0: read-var gs#119060:u8
        let s_3404_0: bool = fn_state.gs_119060;
        // N s_3404_1: branch s_3404_0 b3779 b3405
        if s_3404_0 {
            return block_3779(state, tracer, fn_state);
        } else {
            return block_3405(state, tracer, fn_state);
        };
    }
    fn block_3405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3405_0: const #0u : u8
        let s_3405_0: bool = false;
        // D s_3405_1: write-var gs#119061 <= s_3405_0
        fn_state.gs_119061 = s_3405_0;
        // N s_3405_2: jump b3406
        return block_3406(state, tracer, fn_state);
    }
    fn block_3406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3406_0: read-var gs#119061:u8
        let s_3406_0: bool = fn_state.gs_119061;
        // N s_3406_1: branch s_3406_0 b3778 b3407
        if s_3406_0 {
            return block_3778(state, tracer, fn_state);
        } else {
            return block_3407(state, tracer, fn_state);
        };
    }
    fn block_3407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3407_0: const #0u : u8
        let s_3407_0: bool = false;
        // D s_3407_1: write-var gs#119062 <= s_3407_0
        fn_state.gs_119062 = s_3407_0;
        // N s_3407_2: jump b3408
        return block_3408(state, tracer, fn_state);
    }
    fn block_3408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3408_0: read-var gs#119062:u8
        let s_3408_0: bool = fn_state.gs_119062;
        // N s_3408_1: branch s_3408_0 b3777 b3409
        if s_3408_0 {
            return block_3777(state, tracer, fn_state);
        } else {
            return block_3409(state, tracer, fn_state);
        };
    }
    fn block_3409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3409_0: const #0u : u8
        let s_3409_0: bool = false;
        // D s_3409_1: write-var gs#119063 <= s_3409_0
        fn_state.gs_119063 = s_3409_0;
        // N s_3409_2: jump b3410
        return block_3410(state, tracer, fn_state);
    }
    fn block_3410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3410_0: read-var gs#119063:u8
        let s_3410_0: bool = fn_state.gs_119063;
        // N s_3410_1: branch s_3410_0 b3776 b3411
        if s_3410_0 {
            return block_3776(state, tracer, fn_state);
        } else {
            return block_3411(state, tracer, fn_state);
        };
    }
    fn block_3411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3411_0: read-var CRm:u8
        let s_3411_0: u8 = fn_state.CRm;
        // D s_3411_1: cast zx s_3411_0 -> bv
        let s_3411_1: Bits = Bits::new(s_3411_0 as u128, 4u16);
        // C s_3411_2: const #3u : u8
        let s_3411_2: u8 = 3;
        // C s_3411_3: cast zx s_3411_2 -> bv
        let s_3411_3: Bits = Bits::new(s_3411_2 as u128, 4u16);
        // D s_3411_4: cmp-eq s_3411_1 s_3411_3
        let s_3411_4: bool = ((s_3411_1) == (s_3411_3));
        // N s_3411_5: branch s_3411_4 b3775 b3412
        if s_3411_4 {
            return block_3775(state, tracer, fn_state);
        } else {
            return block_3412(state, tracer, fn_state);
        };
    }
    fn block_3412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3412_0: const #0u : u8
        let s_3412_0: bool = false;
        // D s_3412_1: write-var gs#119064 <= s_3412_0
        fn_state.gs_119064 = s_3412_0;
        // N s_3412_2: jump b3413
        return block_3413(state, tracer, fn_state);
    }
    fn block_3413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3413_0: read-var gs#119064:u8
        let s_3413_0: bool = fn_state.gs_119064;
        // N s_3413_1: branch s_3413_0 b3774 b3414
        if s_3413_0 {
            return block_3774(state, tracer, fn_state);
        } else {
            return block_3414(state, tracer, fn_state);
        };
    }
    fn block_3414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3414_0: const #0u : u8
        let s_3414_0: bool = false;
        // D s_3414_1: write-var gs#119065 <= s_3414_0
        fn_state.gs_119065 = s_3414_0;
        // N s_3414_2: jump b3415
        return block_3415(state, tracer, fn_state);
    }
    fn block_3415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3415_0: read-var gs#119065:u8
        let s_3415_0: bool = fn_state.gs_119065;
        // N s_3415_1: branch s_3415_0 b3773 b3416
        if s_3415_0 {
            return block_3773(state, tracer, fn_state);
        } else {
            return block_3416(state, tracer, fn_state);
        };
    }
    fn block_3416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3416_0: const #0u : u8
        let s_3416_0: bool = false;
        // D s_3416_1: write-var gs#119066 <= s_3416_0
        fn_state.gs_119066 = s_3416_0;
        // N s_3416_2: jump b3417
        return block_3417(state, tracer, fn_state);
    }
    fn block_3417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3417_0: read-var gs#119066:u8
        let s_3417_0: bool = fn_state.gs_119066;
        // N s_3417_1: branch s_3417_0 b3772 b3418
        if s_3417_0 {
            return block_3772(state, tracer, fn_state);
        } else {
            return block_3418(state, tracer, fn_state);
        };
    }
    fn block_3418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3418_0: const #0u : u8
        let s_3418_0: bool = false;
        // D s_3418_1: write-var gs#119067 <= s_3418_0
        fn_state.gs_119067 = s_3418_0;
        // N s_3418_2: jump b3419
        return block_3419(state, tracer, fn_state);
    }
    fn block_3419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3419_0: read-var gs#119067:u8
        let s_3419_0: bool = fn_state.gs_119067;
        // N s_3419_1: branch s_3419_0 b3771 b3420
        if s_3419_0 {
            return block_3771(state, tracer, fn_state);
        } else {
            return block_3420(state, tracer, fn_state);
        };
    }
    fn block_3420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3420_0: read-var CRm:u8
        let s_3420_0: u8 = fn_state.CRm;
        // D s_3420_1: cast zx s_3420_0 -> bv
        let s_3420_1: Bits = Bits::new(s_3420_0 as u128, 4u16);
        // C s_3420_2: const #2u : u8
        let s_3420_2: u8 = 2;
        // C s_3420_3: cast zx s_3420_2 -> bv
        let s_3420_3: Bits = Bits::new(s_3420_2 as u128, 4u16);
        // D s_3420_4: cmp-eq s_3420_1 s_3420_3
        let s_3420_4: bool = ((s_3420_1) == (s_3420_3));
        // N s_3420_5: branch s_3420_4 b3770 b3421
        if s_3420_4 {
            return block_3770(state, tracer, fn_state);
        } else {
            return block_3421(state, tracer, fn_state);
        };
    }
    fn block_3421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3421_0: const #0u : u8
        let s_3421_0: bool = false;
        // D s_3421_1: write-var gs#119068 <= s_3421_0
        fn_state.gs_119068 = s_3421_0;
        // N s_3421_2: jump b3422
        return block_3422(state, tracer, fn_state);
    }
    fn block_3422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3422_0: read-var gs#119068:u8
        let s_3422_0: bool = fn_state.gs_119068;
        // N s_3422_1: branch s_3422_0 b3769 b3423
        if s_3422_0 {
            return block_3769(state, tracer, fn_state);
        } else {
            return block_3423(state, tracer, fn_state);
        };
    }
    fn block_3423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3423_0: const #0u : u8
        let s_3423_0: bool = false;
        // D s_3423_1: write-var gs#119069 <= s_3423_0
        fn_state.gs_119069 = s_3423_0;
        // N s_3423_2: jump b3424
        return block_3424(state, tracer, fn_state);
    }
    fn block_3424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3424_0: read-var gs#119069:u8
        let s_3424_0: bool = fn_state.gs_119069;
        // N s_3424_1: branch s_3424_0 b3768 b3425
        if s_3424_0 {
            return block_3768(state, tracer, fn_state);
        } else {
            return block_3425(state, tracer, fn_state);
        };
    }
    fn block_3425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3425_0: const #0u : u8
        let s_3425_0: bool = false;
        // D s_3425_1: write-var gs#119070 <= s_3425_0
        fn_state.gs_119070 = s_3425_0;
        // N s_3425_2: jump b3426
        return block_3426(state, tracer, fn_state);
    }
    fn block_3426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3426_0: read-var gs#119070:u8
        let s_3426_0: bool = fn_state.gs_119070;
        // N s_3426_1: branch s_3426_0 b3767 b3427
        if s_3426_0 {
            return block_3767(state, tracer, fn_state);
        } else {
            return block_3427(state, tracer, fn_state);
        };
    }
    fn block_3427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3427_0: const #0u : u8
        let s_3427_0: bool = false;
        // D s_3427_1: write-var gs#119071 <= s_3427_0
        fn_state.gs_119071 = s_3427_0;
        // N s_3427_2: jump b3428
        return block_3428(state, tracer, fn_state);
    }
    fn block_3428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3428_0: read-var gs#119071:u8
        let s_3428_0: bool = fn_state.gs_119071;
        // N s_3428_1: branch s_3428_0 b3766 b3429
        if s_3428_0 {
            return block_3766(state, tracer, fn_state);
        } else {
            return block_3429(state, tracer, fn_state);
        };
    }
    fn block_3429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3429_0: read-var CRm:u8
        let s_3429_0: u8 = fn_state.CRm;
        // D s_3429_1: cast zx s_3429_0 -> bv
        let s_3429_1: Bits = Bits::new(s_3429_0 as u128, 4u16);
        // C s_3429_2: const #2u : u8
        let s_3429_2: u8 = 2;
        // C s_3429_3: cast zx s_3429_2 -> bv
        let s_3429_3: Bits = Bits::new(s_3429_2 as u128, 4u16);
        // D s_3429_4: cmp-eq s_3429_1 s_3429_3
        let s_3429_4: bool = ((s_3429_1) == (s_3429_3));
        // N s_3429_5: branch s_3429_4 b3765 b3430
        if s_3429_4 {
            return block_3765(state, tracer, fn_state);
        } else {
            return block_3430(state, tracer, fn_state);
        };
    }
    fn block_3430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3430_0: const #0u : u8
        let s_3430_0: bool = false;
        // D s_3430_1: write-var gs#119072 <= s_3430_0
        fn_state.gs_119072 = s_3430_0;
        // N s_3430_2: jump b3431
        return block_3431(state, tracer, fn_state);
    }
    fn block_3431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3431_0: read-var gs#119072:u8
        let s_3431_0: bool = fn_state.gs_119072;
        // N s_3431_1: branch s_3431_0 b3764 b3432
        if s_3431_0 {
            return block_3764(state, tracer, fn_state);
        } else {
            return block_3432(state, tracer, fn_state);
        };
    }
    fn block_3432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3432_0: const #0u : u8
        let s_3432_0: bool = false;
        // D s_3432_1: write-var gs#119073 <= s_3432_0
        fn_state.gs_119073 = s_3432_0;
        // N s_3432_2: jump b3433
        return block_3433(state, tracer, fn_state);
    }
    fn block_3433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3433_0: read-var gs#119073:u8
        let s_3433_0: bool = fn_state.gs_119073;
        // N s_3433_1: branch s_3433_0 b3763 b3434
        if s_3433_0 {
            return block_3763(state, tracer, fn_state);
        } else {
            return block_3434(state, tracer, fn_state);
        };
    }
    fn block_3434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3434_0: const #0u : u8
        let s_3434_0: bool = false;
        // D s_3434_1: write-var gs#119074 <= s_3434_0
        fn_state.gs_119074 = s_3434_0;
        // N s_3434_2: jump b3435
        return block_3435(state, tracer, fn_state);
    }
    fn block_3435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3435_0: read-var gs#119074:u8
        let s_3435_0: bool = fn_state.gs_119074;
        // N s_3435_1: branch s_3435_0 b3762 b3436
        if s_3435_0 {
            return block_3762(state, tracer, fn_state);
        } else {
            return block_3436(state, tracer, fn_state);
        };
    }
    fn block_3436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3436_0: const #0u : u8
        let s_3436_0: bool = false;
        // D s_3436_1: write-var gs#119075 <= s_3436_0
        fn_state.gs_119075 = s_3436_0;
        // N s_3436_2: jump b3437
        return block_3437(state, tracer, fn_state);
    }
    fn block_3437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3437_0: read-var gs#119075:u8
        let s_3437_0: bool = fn_state.gs_119075;
        // N s_3437_1: branch s_3437_0 b3761 b3438
        if s_3437_0 {
            return block_3761(state, tracer, fn_state);
        } else {
            return block_3438(state, tracer, fn_state);
        };
    }
    fn block_3438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3438_0: read-var CRm:u8
        let s_3438_0: u8 = fn_state.CRm;
        // D s_3438_1: cast zx s_3438_0 -> bv
        let s_3438_1: Bits = Bits::new(s_3438_0 as u128, 4u16);
        // C s_3438_2: const #3u : u8
        let s_3438_2: u8 = 3;
        // C s_3438_3: cast zx s_3438_2 -> bv
        let s_3438_3: Bits = Bits::new(s_3438_2 as u128, 4u16);
        // D s_3438_4: cmp-eq s_3438_1 s_3438_3
        let s_3438_4: bool = ((s_3438_1) == (s_3438_3));
        // N s_3438_5: branch s_3438_4 b3760 b3439
        if s_3438_4 {
            return block_3760(state, tracer, fn_state);
        } else {
            return block_3439(state, tracer, fn_state);
        };
    }
    fn block_3439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3439_0: const #0u : u8
        let s_3439_0: bool = false;
        // D s_3439_1: write-var gs#119076 <= s_3439_0
        fn_state.gs_119076 = s_3439_0;
        // N s_3439_2: jump b3440
        return block_3440(state, tracer, fn_state);
    }
    fn block_3440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3440_0: read-var gs#119076:u8
        let s_3440_0: bool = fn_state.gs_119076;
        // N s_3440_1: branch s_3440_0 b3759 b3441
        if s_3440_0 {
            return block_3759(state, tracer, fn_state);
        } else {
            return block_3441(state, tracer, fn_state);
        };
    }
    fn block_3441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3441_0: const #0u : u8
        let s_3441_0: bool = false;
        // D s_3441_1: write-var gs#119077 <= s_3441_0
        fn_state.gs_119077 = s_3441_0;
        // N s_3441_2: jump b3442
        return block_3442(state, tracer, fn_state);
    }
    fn block_3442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3442_0: read-var gs#119077:u8
        let s_3442_0: bool = fn_state.gs_119077;
        // N s_3442_1: branch s_3442_0 b3758 b3443
        if s_3442_0 {
            return block_3758(state, tracer, fn_state);
        } else {
            return block_3443(state, tracer, fn_state);
        };
    }
    fn block_3443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3443_0: const #0u : u8
        let s_3443_0: bool = false;
        // D s_3443_1: write-var gs#119078 <= s_3443_0
        fn_state.gs_119078 = s_3443_0;
        // N s_3443_2: jump b3444
        return block_3444(state, tracer, fn_state);
    }
    fn block_3444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3444_0: read-var gs#119078:u8
        let s_3444_0: bool = fn_state.gs_119078;
        // N s_3444_1: branch s_3444_0 b3757 b3445
        if s_3444_0 {
            return block_3757(state, tracer, fn_state);
        } else {
            return block_3445(state, tracer, fn_state);
        };
    }
    fn block_3445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3445_0: const #0u : u8
        let s_3445_0: bool = false;
        // D s_3445_1: write-var gs#119079 <= s_3445_0
        fn_state.gs_119079 = s_3445_0;
        // N s_3445_2: jump b3446
        return block_3446(state, tracer, fn_state);
    }
    fn block_3446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3446_0: read-var gs#119079:u8
        let s_3446_0: bool = fn_state.gs_119079;
        // N s_3446_1: branch s_3446_0 b3756 b3447
        if s_3446_0 {
            return block_3756(state, tracer, fn_state);
        } else {
            return block_3447(state, tracer, fn_state);
        };
    }
    fn block_3447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3447_0: read-var CRm:u8
        let s_3447_0: u8 = fn_state.CRm;
        // D s_3447_1: cast zx s_3447_0 -> bv
        let s_3447_1: Bits = Bits::new(s_3447_0 as u128, 4u16);
        // C s_3447_2: const #2u : u8
        let s_3447_2: u8 = 2;
        // C s_3447_3: cast zx s_3447_2 -> bv
        let s_3447_3: Bits = Bits::new(s_3447_2 as u128, 4u16);
        // D s_3447_4: cmp-eq s_3447_1 s_3447_3
        let s_3447_4: bool = ((s_3447_1) == (s_3447_3));
        // N s_3447_5: branch s_3447_4 b3755 b3448
        if s_3447_4 {
            return block_3755(state, tracer, fn_state);
        } else {
            return block_3448(state, tracer, fn_state);
        };
    }
    fn block_3448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3448_0: const #0u : u8
        let s_3448_0: bool = false;
        // D s_3448_1: write-var gs#119080 <= s_3448_0
        fn_state.gs_119080 = s_3448_0;
        // N s_3448_2: jump b3449
        return block_3449(state, tracer, fn_state);
    }
    fn block_3449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3449_0: read-var gs#119080:u8
        let s_3449_0: bool = fn_state.gs_119080;
        // N s_3449_1: branch s_3449_0 b3754 b3450
        if s_3449_0 {
            return block_3754(state, tracer, fn_state);
        } else {
            return block_3450(state, tracer, fn_state);
        };
    }
    fn block_3450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3450_0: const #0u : u8
        let s_3450_0: bool = false;
        // D s_3450_1: write-var gs#119081 <= s_3450_0
        fn_state.gs_119081 = s_3450_0;
        // N s_3450_2: jump b3451
        return block_3451(state, tracer, fn_state);
    }
    fn block_3451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3451_0: read-var gs#119081:u8
        let s_3451_0: bool = fn_state.gs_119081;
        // N s_3451_1: branch s_3451_0 b3753 b3452
        if s_3451_0 {
            return block_3753(state, tracer, fn_state);
        } else {
            return block_3452(state, tracer, fn_state);
        };
    }
    fn block_3452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3452_0: const #0u : u8
        let s_3452_0: bool = false;
        // D s_3452_1: write-var gs#119082 <= s_3452_0
        fn_state.gs_119082 = s_3452_0;
        // N s_3452_2: jump b3453
        return block_3453(state, tracer, fn_state);
    }
    fn block_3453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3453_0: read-var gs#119082:u8
        let s_3453_0: bool = fn_state.gs_119082;
        // N s_3453_1: branch s_3453_0 b3752 b3454
        if s_3453_0 {
            return block_3752(state, tracer, fn_state);
        } else {
            return block_3454(state, tracer, fn_state);
        };
    }
    fn block_3454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3454_0: const #0u : u8
        let s_3454_0: bool = false;
        // D s_3454_1: write-var gs#119083 <= s_3454_0
        fn_state.gs_119083 = s_3454_0;
        // N s_3454_2: jump b3455
        return block_3455(state, tracer, fn_state);
    }
    fn block_3455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3455_0: read-var gs#119083:u8
        let s_3455_0: bool = fn_state.gs_119083;
        // N s_3455_1: branch s_3455_0 b3751 b3456
        if s_3455_0 {
            return block_3751(state, tracer, fn_state);
        } else {
            return block_3456(state, tracer, fn_state);
        };
    }
    fn block_3456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3456_0: read-var CRm:u8
        let s_3456_0: u8 = fn_state.CRm;
        // D s_3456_1: cast zx s_3456_0 -> bv
        let s_3456_1: Bits = Bits::new(s_3456_0 as u128, 4u16);
        // C s_3456_2: const #3u : u8
        let s_3456_2: u8 = 3;
        // C s_3456_3: cast zx s_3456_2 -> bv
        let s_3456_3: Bits = Bits::new(s_3456_2 as u128, 4u16);
        // D s_3456_4: cmp-eq s_3456_1 s_3456_3
        let s_3456_4: bool = ((s_3456_1) == (s_3456_3));
        // N s_3456_5: branch s_3456_4 b3750 b3457
        if s_3456_4 {
            return block_3750(state, tracer, fn_state);
        } else {
            return block_3457(state, tracer, fn_state);
        };
    }
    fn block_3457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3457_0: const #0u : u8
        let s_3457_0: bool = false;
        // D s_3457_1: write-var gs#119084 <= s_3457_0
        fn_state.gs_119084 = s_3457_0;
        // N s_3457_2: jump b3458
        return block_3458(state, tracer, fn_state);
    }
    fn block_3458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3458_0: read-var gs#119084:u8
        let s_3458_0: bool = fn_state.gs_119084;
        // N s_3458_1: branch s_3458_0 b3749 b3459
        if s_3458_0 {
            return block_3749(state, tracer, fn_state);
        } else {
            return block_3459(state, tracer, fn_state);
        };
    }
    fn block_3459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3459_0: const #0u : u8
        let s_3459_0: bool = false;
        // D s_3459_1: write-var gs#119085 <= s_3459_0
        fn_state.gs_119085 = s_3459_0;
        // N s_3459_2: jump b3460
        return block_3460(state, tracer, fn_state);
    }
    fn block_3460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3460_0: read-var gs#119085:u8
        let s_3460_0: bool = fn_state.gs_119085;
        // N s_3460_1: branch s_3460_0 b3748 b3461
        if s_3460_0 {
            return block_3748(state, tracer, fn_state);
        } else {
            return block_3461(state, tracer, fn_state);
        };
    }
    fn block_3461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3461_0: const #0u : u8
        let s_3461_0: bool = false;
        // D s_3461_1: write-var gs#119086 <= s_3461_0
        fn_state.gs_119086 = s_3461_0;
        // N s_3461_2: jump b3462
        return block_3462(state, tracer, fn_state);
    }
    fn block_3462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3462_0: read-var gs#119086:u8
        let s_3462_0: bool = fn_state.gs_119086;
        // N s_3462_1: branch s_3462_0 b3747 b3463
        if s_3462_0 {
            return block_3747(state, tracer, fn_state);
        } else {
            return block_3463(state, tracer, fn_state);
        };
    }
    fn block_3463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3463_0: const #0u : u8
        let s_3463_0: bool = false;
        // D s_3463_1: write-var gs#119087 <= s_3463_0
        fn_state.gs_119087 = s_3463_0;
        // N s_3463_2: jump b3464
        return block_3464(state, tracer, fn_state);
    }
    fn block_3464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3464_0: read-var gs#119087:u8
        let s_3464_0: bool = fn_state.gs_119087;
        // N s_3464_1: branch s_3464_0 b3746 b3465
        if s_3464_0 {
            return block_3746(state, tracer, fn_state);
        } else {
            return block_3465(state, tracer, fn_state);
        };
    }
    fn block_3465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3465_0: read-var CRm:u8
        let s_3465_0: u8 = fn_state.CRm;
        // D s_3465_1: cast zx s_3465_0 -> bv
        let s_3465_1: Bits = Bits::new(s_3465_0 as u128, 4u16);
        // C s_3465_2: const #4u : u8
        let s_3465_2: u8 = 4;
        // C s_3465_3: cast zx s_3465_2 -> bv
        let s_3465_3: Bits = Bits::new(s_3465_2 as u128, 4u16);
        // D s_3465_4: cmp-eq s_3465_1 s_3465_3
        let s_3465_4: bool = ((s_3465_1) == (s_3465_3));
        // N s_3465_5: branch s_3465_4 b3745 b3466
        if s_3465_4 {
            return block_3745(state, tracer, fn_state);
        } else {
            return block_3466(state, tracer, fn_state);
        };
    }
    fn block_3466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3466_0: const #0u : u8
        let s_3466_0: bool = false;
        // D s_3466_1: write-var gs#119088 <= s_3466_0
        fn_state.gs_119088 = s_3466_0;
        // N s_3466_2: jump b3467
        return block_3467(state, tracer, fn_state);
    }
    fn block_3467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3467_0: read-var gs#119088:u8
        let s_3467_0: bool = fn_state.gs_119088;
        // N s_3467_1: branch s_3467_0 b3744 b3468
        if s_3467_0 {
            return block_3744(state, tracer, fn_state);
        } else {
            return block_3468(state, tracer, fn_state);
        };
    }
    fn block_3468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3468_0: const #0u : u8
        let s_3468_0: bool = false;
        // D s_3468_1: write-var gs#119089 <= s_3468_0
        fn_state.gs_119089 = s_3468_0;
        // N s_3468_2: jump b3469
        return block_3469(state, tracer, fn_state);
    }
    fn block_3469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3469_0: read-var gs#119089:u8
        let s_3469_0: bool = fn_state.gs_119089;
        // N s_3469_1: branch s_3469_0 b3743 b3470
        if s_3469_0 {
            return block_3743(state, tracer, fn_state);
        } else {
            return block_3470(state, tracer, fn_state);
        };
    }
    fn block_3470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3470_0: const #0u : u8
        let s_3470_0: bool = false;
        // D s_3470_1: write-var gs#119090 <= s_3470_0
        fn_state.gs_119090 = s_3470_0;
        // N s_3470_2: jump b3471
        return block_3471(state, tracer, fn_state);
    }
    fn block_3471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3471_0: read-var gs#119090:u8
        let s_3471_0: bool = fn_state.gs_119090;
        // N s_3471_1: branch s_3471_0 b3742 b3472
        if s_3471_0 {
            return block_3742(state, tracer, fn_state);
        } else {
            return block_3472(state, tracer, fn_state);
        };
    }
    fn block_3472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3472_0: const #0u : u8
        let s_3472_0: bool = false;
        // D s_3472_1: write-var gs#119091 <= s_3472_0
        fn_state.gs_119091 = s_3472_0;
        // N s_3472_2: jump b3473
        return block_3473(state, tracer, fn_state);
    }
    fn block_3473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3473_0: read-var gs#119091:u8
        let s_3473_0: bool = fn_state.gs_119091;
        // N s_3473_1: branch s_3473_0 b3741 b3474
        if s_3473_0 {
            return block_3741(state, tracer, fn_state);
        } else {
            return block_3474(state, tracer, fn_state);
        };
    }
    fn block_3474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3474_0: read-var CRm:u8
        let s_3474_0: u8 = fn_state.CRm;
        // D s_3474_1: cast zx s_3474_0 -> bv
        let s_3474_1: Bits = Bits::new(s_3474_0 as u128, 4u16);
        // C s_3474_2: const #5u : u8
        let s_3474_2: u8 = 5;
        // C s_3474_3: cast zx s_3474_2 -> bv
        let s_3474_3: Bits = Bits::new(s_3474_2 as u128, 4u16);
        // D s_3474_4: cmp-eq s_3474_1 s_3474_3
        let s_3474_4: bool = ((s_3474_1) == (s_3474_3));
        // N s_3474_5: branch s_3474_4 b3740 b3475
        if s_3474_4 {
            return block_3740(state, tracer, fn_state);
        } else {
            return block_3475(state, tracer, fn_state);
        };
    }
    fn block_3475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3475_0: const #0u : u8
        let s_3475_0: bool = false;
        // D s_3475_1: write-var gs#119092 <= s_3475_0
        fn_state.gs_119092 = s_3475_0;
        // N s_3475_2: jump b3476
        return block_3476(state, tracer, fn_state);
    }
    fn block_3476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3476_0: read-var gs#119092:u8
        let s_3476_0: bool = fn_state.gs_119092;
        // N s_3476_1: branch s_3476_0 b3739 b3477
        if s_3476_0 {
            return block_3739(state, tracer, fn_state);
        } else {
            return block_3477(state, tracer, fn_state);
        };
    }
    fn block_3477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3477_0: const #0u : u8
        let s_3477_0: bool = false;
        // D s_3477_1: write-var gs#119093 <= s_3477_0
        fn_state.gs_119093 = s_3477_0;
        // N s_3477_2: jump b3478
        return block_3478(state, tracer, fn_state);
    }
    fn block_3478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3478_0: read-var gs#119093:u8
        let s_3478_0: bool = fn_state.gs_119093;
        // N s_3478_1: branch s_3478_0 b3738 b3479
        if s_3478_0 {
            return block_3738(state, tracer, fn_state);
        } else {
            return block_3479(state, tracer, fn_state);
        };
    }
    fn block_3479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3479_0: const #0u : u8
        let s_3479_0: bool = false;
        // D s_3479_1: write-var gs#119094 <= s_3479_0
        fn_state.gs_119094 = s_3479_0;
        // N s_3479_2: jump b3480
        return block_3480(state, tracer, fn_state);
    }
    fn block_3480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3480_0: read-var gs#119094:u8
        let s_3480_0: bool = fn_state.gs_119094;
        // N s_3480_1: branch s_3480_0 b3737 b3481
        if s_3480_0 {
            return block_3737(state, tracer, fn_state);
        } else {
            return block_3481(state, tracer, fn_state);
        };
    }
    fn block_3481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3481_0: const #0u : u8
        let s_3481_0: bool = false;
        // D s_3481_1: write-var gs#119095 <= s_3481_0
        fn_state.gs_119095 = s_3481_0;
        // N s_3481_2: jump b3482
        return block_3482(state, tracer, fn_state);
    }
    fn block_3482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3482_0: read-var gs#119095:u8
        let s_3482_0: bool = fn_state.gs_119095;
        // N s_3482_1: branch s_3482_0 b3736 b3483
        if s_3482_0 {
            return block_3736(state, tracer, fn_state);
        } else {
            return block_3483(state, tracer, fn_state);
        };
    }
    fn block_3483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3483_0: read-var CRm:u8
        let s_3483_0: u8 = fn_state.CRm;
        // D s_3483_1: cast zx s_3483_0 -> bv
        let s_3483_1: Bits = Bits::new(s_3483_0 as u128, 4u16);
        // C s_3483_2: const #4u : u8
        let s_3483_2: u8 = 4;
        // C s_3483_3: cast zx s_3483_2 -> bv
        let s_3483_3: Bits = Bits::new(s_3483_2 as u128, 4u16);
        // D s_3483_4: cmp-eq s_3483_1 s_3483_3
        let s_3483_4: bool = ((s_3483_1) == (s_3483_3));
        // N s_3483_5: branch s_3483_4 b3735 b3484
        if s_3483_4 {
            return block_3735(state, tracer, fn_state);
        } else {
            return block_3484(state, tracer, fn_state);
        };
    }
    fn block_3484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3484_0: const #0u : u8
        let s_3484_0: bool = false;
        // D s_3484_1: write-var gs#119096 <= s_3484_0
        fn_state.gs_119096 = s_3484_0;
        // N s_3484_2: jump b3485
        return block_3485(state, tracer, fn_state);
    }
    fn block_3485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3485_0: read-var gs#119096:u8
        let s_3485_0: bool = fn_state.gs_119096;
        // N s_3485_1: branch s_3485_0 b3734 b3486
        if s_3485_0 {
            return block_3734(state, tracer, fn_state);
        } else {
            return block_3486(state, tracer, fn_state);
        };
    }
    fn block_3486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3486_0: const #0u : u8
        let s_3486_0: bool = false;
        // D s_3486_1: write-var gs#119097 <= s_3486_0
        fn_state.gs_119097 = s_3486_0;
        // N s_3486_2: jump b3487
        return block_3487(state, tracer, fn_state);
    }
    fn block_3487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3487_0: read-var gs#119097:u8
        let s_3487_0: bool = fn_state.gs_119097;
        // N s_3487_1: branch s_3487_0 b3733 b3488
        if s_3487_0 {
            return block_3733(state, tracer, fn_state);
        } else {
            return block_3488(state, tracer, fn_state);
        };
    }
    fn block_3488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3488_0: const #0u : u8
        let s_3488_0: bool = false;
        // D s_3488_1: write-var gs#119098 <= s_3488_0
        fn_state.gs_119098 = s_3488_0;
        // N s_3488_2: jump b3489
        return block_3489(state, tracer, fn_state);
    }
    fn block_3489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3489_0: read-var gs#119098:u8
        let s_3489_0: bool = fn_state.gs_119098;
        // N s_3489_1: branch s_3489_0 b3732 b3490
        if s_3489_0 {
            return block_3732(state, tracer, fn_state);
        } else {
            return block_3490(state, tracer, fn_state);
        };
    }
    fn block_3490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3490_0: const #0u : u8
        let s_3490_0: bool = false;
        // D s_3490_1: write-var gs#119099 <= s_3490_0
        fn_state.gs_119099 = s_3490_0;
        // N s_3490_2: jump b3491
        return block_3491(state, tracer, fn_state);
    }
    fn block_3491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3491_0: read-var gs#119099:u8
        let s_3491_0: bool = fn_state.gs_119099;
        // N s_3491_1: branch s_3491_0 b3731 b3492
        if s_3491_0 {
            return block_3731(state, tracer, fn_state);
        } else {
            return block_3492(state, tracer, fn_state);
        };
    }
    fn block_3492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3492_0: read-var CRm:u8
        let s_3492_0: u8 = fn_state.CRm;
        // D s_3492_1: cast zx s_3492_0 -> bv
        let s_3492_1: Bits = Bits::new(s_3492_0 as u128, 4u16);
        // C s_3492_2: const #4u : u8
        let s_3492_2: u8 = 4;
        // C s_3492_3: cast zx s_3492_2 -> bv
        let s_3492_3: Bits = Bits::new(s_3492_2 as u128, 4u16);
        // D s_3492_4: cmp-eq s_3492_1 s_3492_3
        let s_3492_4: bool = ((s_3492_1) == (s_3492_3));
        // N s_3492_5: branch s_3492_4 b3730 b3493
        if s_3492_4 {
            return block_3730(state, tracer, fn_state);
        } else {
            return block_3493(state, tracer, fn_state);
        };
    }
    fn block_3493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3493_0: const #0u : u8
        let s_3493_0: bool = false;
        // D s_3493_1: write-var gs#119100 <= s_3493_0
        fn_state.gs_119100 = s_3493_0;
        // N s_3493_2: jump b3494
        return block_3494(state, tracer, fn_state);
    }
    fn block_3494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3494_0: read-var gs#119100:u8
        let s_3494_0: bool = fn_state.gs_119100;
        // N s_3494_1: branch s_3494_0 b3729 b3495
        if s_3494_0 {
            return block_3729(state, tracer, fn_state);
        } else {
            return block_3495(state, tracer, fn_state);
        };
    }
    fn block_3495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3495_0: const #0u : u8
        let s_3495_0: bool = false;
        // D s_3495_1: write-var gs#119101 <= s_3495_0
        fn_state.gs_119101 = s_3495_0;
        // N s_3495_2: jump b3496
        return block_3496(state, tracer, fn_state);
    }
    fn block_3496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3496_0: read-var gs#119101:u8
        let s_3496_0: bool = fn_state.gs_119101;
        // N s_3496_1: branch s_3496_0 b3728 b3497
        if s_3496_0 {
            return block_3728(state, tracer, fn_state);
        } else {
            return block_3497(state, tracer, fn_state);
        };
    }
    fn block_3497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3497_0: const #0u : u8
        let s_3497_0: bool = false;
        // D s_3497_1: write-var gs#119102 <= s_3497_0
        fn_state.gs_119102 = s_3497_0;
        // N s_3497_2: jump b3498
        return block_3498(state, tracer, fn_state);
    }
    fn block_3498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3498_0: read-var gs#119102:u8
        let s_3498_0: bool = fn_state.gs_119102;
        // N s_3498_1: branch s_3498_0 b3727 b3499
        if s_3498_0 {
            return block_3727(state, tracer, fn_state);
        } else {
            return block_3499(state, tracer, fn_state);
        };
    }
    fn block_3499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3499_0: const #0u : u8
        let s_3499_0: bool = false;
        // D s_3499_1: write-var gs#119103 <= s_3499_0
        fn_state.gs_119103 = s_3499_0;
        // N s_3499_2: jump b3500
        return block_3500(state, tracer, fn_state);
    }
    fn block_3500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3500_0: read-var gs#119103:u8
        let s_3500_0: bool = fn_state.gs_119103;
        // N s_3500_1: branch s_3500_0 b3726 b3501
        if s_3500_0 {
            return block_3726(state, tracer, fn_state);
        } else {
            return block_3501(state, tracer, fn_state);
        };
    }
    fn block_3501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3501_0: read-var CRm:u8
        let s_3501_0: u8 = fn_state.CRm;
        // D s_3501_1: cast zx s_3501_0 -> bv
        let s_3501_1: Bits = Bits::new(s_3501_0 as u128, 4u16);
        // C s_3501_2: const #5u : u8
        let s_3501_2: u8 = 5;
        // C s_3501_3: cast zx s_3501_2 -> bv
        let s_3501_3: Bits = Bits::new(s_3501_2 as u128, 4u16);
        // D s_3501_4: cmp-eq s_3501_1 s_3501_3
        let s_3501_4: bool = ((s_3501_1) == (s_3501_3));
        // N s_3501_5: branch s_3501_4 b3725 b3502
        if s_3501_4 {
            return block_3725(state, tracer, fn_state);
        } else {
            return block_3502(state, tracer, fn_state);
        };
    }
    fn block_3502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3502_0: const #0u : u8
        let s_3502_0: bool = false;
        // D s_3502_1: write-var gs#119104 <= s_3502_0
        fn_state.gs_119104 = s_3502_0;
        // N s_3502_2: jump b3503
        return block_3503(state, tracer, fn_state);
    }
    fn block_3503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3503_0: read-var gs#119104:u8
        let s_3503_0: bool = fn_state.gs_119104;
        // N s_3503_1: branch s_3503_0 b3724 b3504
        if s_3503_0 {
            return block_3724(state, tracer, fn_state);
        } else {
            return block_3504(state, tracer, fn_state);
        };
    }
    fn block_3504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3504_0: const #0u : u8
        let s_3504_0: bool = false;
        // D s_3504_1: write-var gs#119105 <= s_3504_0
        fn_state.gs_119105 = s_3504_0;
        // N s_3504_2: jump b3505
        return block_3505(state, tracer, fn_state);
    }
    fn block_3505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3505_0: read-var gs#119105:u8
        let s_3505_0: bool = fn_state.gs_119105;
        // N s_3505_1: branch s_3505_0 b3723 b3506
        if s_3505_0 {
            return block_3723(state, tracer, fn_state);
        } else {
            return block_3506(state, tracer, fn_state);
        };
    }
    fn block_3506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3506_0: const #0u : u8
        let s_3506_0: bool = false;
        // D s_3506_1: write-var gs#119106 <= s_3506_0
        fn_state.gs_119106 = s_3506_0;
        // N s_3506_2: jump b3507
        return block_3507(state, tracer, fn_state);
    }
    fn block_3507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3507_0: read-var gs#119106:u8
        let s_3507_0: bool = fn_state.gs_119106;
        // N s_3507_1: branch s_3507_0 b3722 b3508
        if s_3507_0 {
            return block_3722(state, tracer, fn_state);
        } else {
            return block_3508(state, tracer, fn_state);
        };
    }
    fn block_3508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3508_0: const #0u : u8
        let s_3508_0: bool = false;
        // D s_3508_1: write-var gs#119107 <= s_3508_0
        fn_state.gs_119107 = s_3508_0;
        // N s_3508_2: jump b3509
        return block_3509(state, tracer, fn_state);
    }
    fn block_3509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3509_0: read-var gs#119107:u8
        let s_3509_0: bool = fn_state.gs_119107;
        // N s_3509_1: branch s_3509_0 b3721 b3510
        if s_3509_0 {
            return block_3721(state, tracer, fn_state);
        } else {
            return block_3510(state, tracer, fn_state);
        };
    }
    fn block_3510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3510_0: read-var CRm:u8
        let s_3510_0: u8 = fn_state.CRm;
        // D s_3510_1: cast zx s_3510_0 -> bv
        let s_3510_1: Bits = Bits::new(s_3510_0 as u128, 4u16);
        // C s_3510_2: const #5u : u8
        let s_3510_2: u8 = 5;
        // C s_3510_3: cast zx s_3510_2 -> bv
        let s_3510_3: Bits = Bits::new(s_3510_2 as u128, 4u16);
        // D s_3510_4: cmp-eq s_3510_1 s_3510_3
        let s_3510_4: bool = ((s_3510_1) == (s_3510_3));
        // N s_3510_5: branch s_3510_4 b3720 b3511
        if s_3510_4 {
            return block_3720(state, tracer, fn_state);
        } else {
            return block_3511(state, tracer, fn_state);
        };
    }
    fn block_3511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3511_0: const #0u : u8
        let s_3511_0: bool = false;
        // D s_3511_1: write-var gs#119108 <= s_3511_0
        fn_state.gs_119108 = s_3511_0;
        // N s_3511_2: jump b3512
        return block_3512(state, tracer, fn_state);
    }
    fn block_3512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3512_0: read-var gs#119108:u8
        let s_3512_0: bool = fn_state.gs_119108;
        // N s_3512_1: branch s_3512_0 b3719 b3513
        if s_3512_0 {
            return block_3719(state, tracer, fn_state);
        } else {
            return block_3513(state, tracer, fn_state);
        };
    }
    fn block_3513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3513_0: const #0u : u8
        let s_3513_0: bool = false;
        // D s_3513_1: write-var gs#119109 <= s_3513_0
        fn_state.gs_119109 = s_3513_0;
        // N s_3513_2: jump b3514
        return block_3514(state, tracer, fn_state);
    }
    fn block_3514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3514_0: read-var gs#119109:u8
        let s_3514_0: bool = fn_state.gs_119109;
        // N s_3514_1: branch s_3514_0 b3718 b3515
        if s_3514_0 {
            return block_3718(state, tracer, fn_state);
        } else {
            return block_3515(state, tracer, fn_state);
        };
    }
    fn block_3515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3515_0: const #0u : u8
        let s_3515_0: bool = false;
        // D s_3515_1: write-var gs#119110 <= s_3515_0
        fn_state.gs_119110 = s_3515_0;
        // N s_3515_2: jump b3516
        return block_3516(state, tracer, fn_state);
    }
    fn block_3516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3516_0: read-var gs#119110:u8
        let s_3516_0: bool = fn_state.gs_119110;
        // N s_3516_1: branch s_3516_0 b3717 b3517
        if s_3516_0 {
            return block_3717(state, tracer, fn_state);
        } else {
            return block_3517(state, tracer, fn_state);
        };
    }
    fn block_3517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3517_0: const #0u : u8
        let s_3517_0: bool = false;
        // D s_3517_1: write-var gs#119111 <= s_3517_0
        fn_state.gs_119111 = s_3517_0;
        // N s_3517_2: jump b3518
        return block_3518(state, tracer, fn_state);
    }
    fn block_3518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3518_0: read-var gs#119111:u8
        let s_3518_0: bool = fn_state.gs_119111;
        // N s_3518_1: branch s_3518_0 b3716 b3519
        if s_3518_0 {
            return block_3716(state, tracer, fn_state);
        } else {
            return block_3519(state, tracer, fn_state);
        };
    }
    fn block_3519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3519_0: read-var CRm:u8
        let s_3519_0: u8 = fn_state.CRm;
        // D s_3519_1: cast zx s_3519_0 -> bv
        let s_3519_1: Bits = Bits::new(s_3519_0 as u128, 4u16);
        // C s_3519_2: const #3u : u8
        let s_3519_2: u8 = 3;
        // C s_3519_3: cast zx s_3519_2 -> bv
        let s_3519_3: Bits = Bits::new(s_3519_2 as u128, 4u16);
        // D s_3519_4: cmp-eq s_3519_1 s_3519_3
        let s_3519_4: bool = ((s_3519_1) == (s_3519_3));
        // N s_3519_5: branch s_3519_4 b3715 b3520
        if s_3519_4 {
            return block_3715(state, tracer, fn_state);
        } else {
            return block_3520(state, tracer, fn_state);
        };
    }
    fn block_3520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3520_0: const #0u : u8
        let s_3520_0: bool = false;
        // D s_3520_1: write-var gs#119112 <= s_3520_0
        fn_state.gs_119112 = s_3520_0;
        // N s_3520_2: jump b3521
        return block_3521(state, tracer, fn_state);
    }
    fn block_3521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3521_0: read-var gs#119112:u8
        let s_3521_0: bool = fn_state.gs_119112;
        // N s_3521_1: branch s_3521_0 b3714 b3522
        if s_3521_0 {
            return block_3714(state, tracer, fn_state);
        } else {
            return block_3522(state, tracer, fn_state);
        };
    }
    fn block_3522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3522_0: const #0u : u8
        let s_3522_0: bool = false;
        // D s_3522_1: write-var gs#119113 <= s_3522_0
        fn_state.gs_119113 = s_3522_0;
        // N s_3522_2: jump b3523
        return block_3523(state, tracer, fn_state);
    }
    fn block_3523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3523_0: read-var gs#119113:u8
        let s_3523_0: bool = fn_state.gs_119113;
        // N s_3523_1: branch s_3523_0 b3713 b3524
        if s_3523_0 {
            return block_3713(state, tracer, fn_state);
        } else {
            return block_3524(state, tracer, fn_state);
        };
    }
    fn block_3524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3524_0: const #0u : u8
        let s_3524_0: bool = false;
        // D s_3524_1: write-var gs#119114 <= s_3524_0
        fn_state.gs_119114 = s_3524_0;
        // N s_3524_2: jump b3525
        return block_3525(state, tracer, fn_state);
    }
    fn block_3525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3525_0: read-var gs#119114:u8
        let s_3525_0: bool = fn_state.gs_119114;
        // N s_3525_1: branch s_3525_0 b3712 b3526
        if s_3525_0 {
            return block_3712(state, tracer, fn_state);
        } else {
            return block_3526(state, tracer, fn_state);
        };
    }
    fn block_3526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3526_0: const #0u : u8
        let s_3526_0: bool = false;
        // D s_3526_1: write-var gs#119115 <= s_3526_0
        fn_state.gs_119115 = s_3526_0;
        // N s_3526_2: jump b3527
        return block_3527(state, tracer, fn_state);
    }
    fn block_3527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3527_0: read-var gs#119115:u8
        let s_3527_0: bool = fn_state.gs_119115;
        // N s_3527_1: branch s_3527_0 b3711 b3528
        if s_3527_0 {
            return block_3711(state, tracer, fn_state);
        } else {
            return block_3528(state, tracer, fn_state);
        };
    }
    fn block_3528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3528_0: read-var CRm:u8
        let s_3528_0: u8 = fn_state.CRm;
        // D s_3528_1: cast zx s_3528_0 -> bv
        let s_3528_1: Bits = Bits::new(s_3528_0 as u128, 4u16);
        // C s_3528_2: const #4u : u8
        let s_3528_2: u8 = 4;
        // C s_3528_3: cast zx s_3528_2 -> bv
        let s_3528_3: Bits = Bits::new(s_3528_2 as u128, 4u16);
        // D s_3528_4: cmp-eq s_3528_1 s_3528_3
        let s_3528_4: bool = ((s_3528_1) == (s_3528_3));
        // N s_3528_5: branch s_3528_4 b3710 b3529
        if s_3528_4 {
            return block_3710(state, tracer, fn_state);
        } else {
            return block_3529(state, tracer, fn_state);
        };
    }
    fn block_3529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3529_0: const #0u : u8
        let s_3529_0: bool = false;
        // D s_3529_1: write-var gs#119116 <= s_3529_0
        fn_state.gs_119116 = s_3529_0;
        // N s_3529_2: jump b3530
        return block_3530(state, tracer, fn_state);
    }
    fn block_3530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3530_0: read-var gs#119116:u8
        let s_3530_0: bool = fn_state.gs_119116;
        // N s_3530_1: branch s_3530_0 b3709 b3531
        if s_3530_0 {
            return block_3709(state, tracer, fn_state);
        } else {
            return block_3531(state, tracer, fn_state);
        };
    }
    fn block_3531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3531_0: const #0u : u8
        let s_3531_0: bool = false;
        // D s_3531_1: write-var gs#119117 <= s_3531_0
        fn_state.gs_119117 = s_3531_0;
        // N s_3531_2: jump b3532
        return block_3532(state, tracer, fn_state);
    }
    fn block_3532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3532_0: read-var gs#119117:u8
        let s_3532_0: bool = fn_state.gs_119117;
        // N s_3532_1: branch s_3532_0 b3708 b3533
        if s_3532_0 {
            return block_3708(state, tracer, fn_state);
        } else {
            return block_3533(state, tracer, fn_state);
        };
    }
    fn block_3533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3533_0: const #0u : u8
        let s_3533_0: bool = false;
        // D s_3533_1: write-var gs#119118 <= s_3533_0
        fn_state.gs_119118 = s_3533_0;
        // N s_3533_2: jump b3534
        return block_3534(state, tracer, fn_state);
    }
    fn block_3534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3534_0: read-var gs#119118:u8
        let s_3534_0: bool = fn_state.gs_119118;
        // N s_3534_1: branch s_3534_0 b3707 b3535
        if s_3534_0 {
            return block_3707(state, tracer, fn_state);
        } else {
            return block_3535(state, tracer, fn_state);
        };
    }
    fn block_3535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3535_0: const #0u : u8
        let s_3535_0: bool = false;
        // D s_3535_1: write-var gs#119119 <= s_3535_0
        fn_state.gs_119119 = s_3535_0;
        // N s_3535_2: jump b3536
        return block_3536(state, tracer, fn_state);
    }
    fn block_3536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3536_0: read-var gs#119119:u8
        let s_3536_0: bool = fn_state.gs_119119;
        // N s_3536_1: branch s_3536_0 b3706 b3537
        if s_3536_0 {
            return block_3706(state, tracer, fn_state);
        } else {
            return block_3537(state, tracer, fn_state);
        };
    }
    fn block_3537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3537_0: read-var CRm:u8
        let s_3537_0: u8 = fn_state.CRm;
        // D s_3537_1: cast zx s_3537_0 -> bv
        let s_3537_1: Bits = Bits::new(s_3537_0 as u128, 4u16);
        // C s_3537_2: const #1u : u8
        let s_3537_2: u8 = 1;
        // C s_3537_3: cast zx s_3537_2 -> bv
        let s_3537_3: Bits = Bits::new(s_3537_2 as u128, 4u16);
        // D s_3537_4: cmp-eq s_3537_1 s_3537_3
        let s_3537_4: bool = ((s_3537_1) == (s_3537_3));
        // N s_3537_5: branch s_3537_4 b3705 b3538
        if s_3537_4 {
            return block_3705(state, tracer, fn_state);
        } else {
            return block_3538(state, tracer, fn_state);
        };
    }
    fn block_3538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3538_0: const #0u : u8
        let s_3538_0: bool = false;
        // D s_3538_1: write-var gs#119120 <= s_3538_0
        fn_state.gs_119120 = s_3538_0;
        // N s_3538_2: jump b3539
        return block_3539(state, tracer, fn_state);
    }
    fn block_3539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3539_0: read-var gs#119120:u8
        let s_3539_0: bool = fn_state.gs_119120;
        // N s_3539_1: branch s_3539_0 b3704 b3540
        if s_3539_0 {
            return block_3704(state, tracer, fn_state);
        } else {
            return block_3540(state, tracer, fn_state);
        };
    }
    fn block_3540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3540_0: const #0u : u8
        let s_3540_0: bool = false;
        // D s_3540_1: write-var gs#119121 <= s_3540_0
        fn_state.gs_119121 = s_3540_0;
        // N s_3540_2: jump b3541
        return block_3541(state, tracer, fn_state);
    }
    fn block_3541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3541_0: read-var gs#119121:u8
        let s_3541_0: bool = fn_state.gs_119121;
        // N s_3541_1: branch s_3541_0 b3703 b3542
        if s_3541_0 {
            return block_3703(state, tracer, fn_state);
        } else {
            return block_3542(state, tracer, fn_state);
        };
    }
    fn block_3542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3542_0: const #0u : u8
        let s_3542_0: bool = false;
        // D s_3542_1: write-var gs#119122 <= s_3542_0
        fn_state.gs_119122 = s_3542_0;
        // N s_3542_2: jump b3543
        return block_3543(state, tracer, fn_state);
    }
    fn block_3543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3543_0: read-var gs#119122:u8
        let s_3543_0: bool = fn_state.gs_119122;
        // N s_3543_1: branch s_3543_0 b3702 b3544
        if s_3543_0 {
            return block_3702(state, tracer, fn_state);
        } else {
            return block_3544(state, tracer, fn_state);
        };
    }
    fn block_3544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3544_0: const #0u : u8
        let s_3544_0: bool = false;
        // D s_3544_1: write-var gs#119123 <= s_3544_0
        fn_state.gs_119123 = s_3544_0;
        // N s_3544_2: jump b3545
        return block_3545(state, tracer, fn_state);
    }
    fn block_3545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3545_0: read-var gs#119123:u8
        let s_3545_0: bool = fn_state.gs_119123;
        // N s_3545_1: branch s_3545_0 b3701 b3546
        if s_3545_0 {
            return block_3701(state, tracer, fn_state);
        } else {
            return block_3546(state, tracer, fn_state);
        };
    }
    fn block_3546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3546_0: read-var CRm:u8
        let s_3546_0: u8 = fn_state.CRm;
        // D s_3546_1: cast zx s_3546_0 -> bv
        let s_3546_1: Bits = Bits::new(s_3546_0 as u128, 4u16);
        // C s_3546_2: const #2u : u8
        let s_3546_2: u8 = 2;
        // C s_3546_3: cast zx s_3546_2 -> bv
        let s_3546_3: Bits = Bits::new(s_3546_2 as u128, 4u16);
        // D s_3546_4: cmp-eq s_3546_1 s_3546_3
        let s_3546_4: bool = ((s_3546_1) == (s_3546_3));
        // N s_3546_5: branch s_3546_4 b3700 b3547
        if s_3546_4 {
            return block_3700(state, tracer, fn_state);
        } else {
            return block_3547(state, tracer, fn_state);
        };
    }
    fn block_3547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3547_0: const #0u : u8
        let s_3547_0: bool = false;
        // D s_3547_1: write-var gs#119124 <= s_3547_0
        fn_state.gs_119124 = s_3547_0;
        // N s_3547_2: jump b3548
        return block_3548(state, tracer, fn_state);
    }
    fn block_3548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3548_0: read-var gs#119124:u8
        let s_3548_0: bool = fn_state.gs_119124;
        // N s_3548_1: branch s_3548_0 b3699 b3549
        if s_3548_0 {
            return block_3699(state, tracer, fn_state);
        } else {
            return block_3549(state, tracer, fn_state);
        };
    }
    fn block_3549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3549_0: const #0u : u8
        let s_3549_0: bool = false;
        // D s_3549_1: write-var gs#119125 <= s_3549_0
        fn_state.gs_119125 = s_3549_0;
        // N s_3549_2: jump b3550
        return block_3550(state, tracer, fn_state);
    }
    fn block_3550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3550_0: read-var gs#119125:u8
        let s_3550_0: bool = fn_state.gs_119125;
        // N s_3550_1: branch s_3550_0 b3698 b3551
        if s_3550_0 {
            return block_3698(state, tracer, fn_state);
        } else {
            return block_3551(state, tracer, fn_state);
        };
    }
    fn block_3551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3551_0: const #0u : u8
        let s_3551_0: bool = false;
        // D s_3551_1: write-var gs#119126 <= s_3551_0
        fn_state.gs_119126 = s_3551_0;
        // N s_3551_2: jump b3552
        return block_3552(state, tracer, fn_state);
    }
    fn block_3552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3552_0: read-var gs#119126:u8
        let s_3552_0: bool = fn_state.gs_119126;
        // N s_3552_1: branch s_3552_0 b3697 b3553
        if s_3552_0 {
            return block_3697(state, tracer, fn_state);
        } else {
            return block_3553(state, tracer, fn_state);
        };
    }
    fn block_3553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3553_0: const #0u : u8
        let s_3553_0: bool = false;
        // D s_3553_1: write-var gs#119127 <= s_3553_0
        fn_state.gs_119127 = s_3553_0;
        // N s_3553_2: jump b3554
        return block_3554(state, tracer, fn_state);
    }
    fn block_3554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3554_0: read-var gs#119127:u8
        let s_3554_0: bool = fn_state.gs_119127;
        // N s_3554_1: branch s_3554_0 b3696 b3555
        if s_3554_0 {
            return block_3696(state, tracer, fn_state);
        } else {
            return block_3555(state, tracer, fn_state);
        };
    }
    fn block_3555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3555_0: read-var CRm:u8
        let s_3555_0: u8 = fn_state.CRm;
        // D s_3555_1: cast zx s_3555_0 -> bv
        let s_3555_1: Bits = Bits::new(s_3555_0 as u128, 4u16);
        // C s_3555_2: const #5u : u8
        let s_3555_2: u8 = 5;
        // C s_3555_3: cast zx s_3555_2 -> bv
        let s_3555_3: Bits = Bits::new(s_3555_2 as u128, 4u16);
        // D s_3555_4: cmp-eq s_3555_1 s_3555_3
        let s_3555_4: bool = ((s_3555_1) == (s_3555_3));
        // N s_3555_5: branch s_3555_4 b3695 b3556
        if s_3555_4 {
            return block_3695(state, tracer, fn_state);
        } else {
            return block_3556(state, tracer, fn_state);
        };
    }
    fn block_3556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3556_0: const #0u : u8
        let s_3556_0: bool = false;
        // D s_3556_1: write-var gs#119128 <= s_3556_0
        fn_state.gs_119128 = s_3556_0;
        // N s_3556_2: jump b3557
        return block_3557(state, tracer, fn_state);
    }
    fn block_3557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3557_0: read-var gs#119128:u8
        let s_3557_0: bool = fn_state.gs_119128;
        // N s_3557_1: branch s_3557_0 b3694 b3558
        if s_3557_0 {
            return block_3694(state, tracer, fn_state);
        } else {
            return block_3558(state, tracer, fn_state);
        };
    }
    fn block_3558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3558_0: const #0u : u8
        let s_3558_0: bool = false;
        // D s_3558_1: write-var gs#119129 <= s_3558_0
        fn_state.gs_119129 = s_3558_0;
        // N s_3558_2: jump b3559
        return block_3559(state, tracer, fn_state);
    }
    fn block_3559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3559_0: read-var gs#119129:u8
        let s_3559_0: bool = fn_state.gs_119129;
        // N s_3559_1: branch s_3559_0 b3693 b3560
        if s_3559_0 {
            return block_3693(state, tracer, fn_state);
        } else {
            return block_3560(state, tracer, fn_state);
        };
    }
    fn block_3560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3560_0: const #0u : u8
        let s_3560_0: bool = false;
        // D s_3560_1: write-var gs#119130 <= s_3560_0
        fn_state.gs_119130 = s_3560_0;
        // N s_3560_2: jump b3561
        return block_3561(state, tracer, fn_state);
    }
    fn block_3561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3561_0: read-var gs#119130:u8
        let s_3561_0: bool = fn_state.gs_119130;
        // N s_3561_1: branch s_3561_0 b3692 b3562
        if s_3561_0 {
            return block_3692(state, tracer, fn_state);
        } else {
            return block_3562(state, tracer, fn_state);
        };
    }
    fn block_3562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3562_0: const #0u : u8
        let s_3562_0: bool = false;
        // D s_3562_1: write-var gs#119131 <= s_3562_0
        fn_state.gs_119131 = s_3562_0;
        // N s_3562_2: jump b3563
        return block_3563(state, tracer, fn_state);
    }
    fn block_3563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3563_0: read-var gs#119131:u8
        let s_3563_0: bool = fn_state.gs_119131;
        // N s_3563_1: branch s_3563_0 b3691 b3564
        if s_3563_0 {
            return block_3691(state, tracer, fn_state);
        } else {
            return block_3564(state, tracer, fn_state);
        };
    }
    fn block_3564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3564_0: read-var CRm:u8
        let s_3564_0: u8 = fn_state.CRm;
        // D s_3564_1: cast zx s_3564_0 -> bv
        let s_3564_1: Bits = Bits::new(s_3564_0 as u128, 4u16);
        // C s_3564_2: const #4u : u8
        let s_3564_2: u8 = 4;
        // C s_3564_3: cast zx s_3564_2 -> bv
        let s_3564_3: Bits = Bits::new(s_3564_2 as u128, 4u16);
        // D s_3564_4: cmp-eq s_3564_1 s_3564_3
        let s_3564_4: bool = ((s_3564_1) == (s_3564_3));
        // N s_3564_5: branch s_3564_4 b3690 b3565
        if s_3564_4 {
            return block_3690(state, tracer, fn_state);
        } else {
            return block_3565(state, tracer, fn_state);
        };
    }
    fn block_3565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3565_0: const #0u : u8
        let s_3565_0: bool = false;
        // D s_3565_1: write-var gs#119132 <= s_3565_0
        fn_state.gs_119132 = s_3565_0;
        // N s_3565_2: jump b3566
        return block_3566(state, tracer, fn_state);
    }
    fn block_3566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3566_0: read-var gs#119132:u8
        let s_3566_0: bool = fn_state.gs_119132;
        // N s_3566_1: branch s_3566_0 b3689 b3567
        if s_3566_0 {
            return block_3689(state, tracer, fn_state);
        } else {
            return block_3567(state, tracer, fn_state);
        };
    }
    fn block_3567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3567_0: const #0u : u8
        let s_3567_0: bool = false;
        // D s_3567_1: write-var gs#119133 <= s_3567_0
        fn_state.gs_119133 = s_3567_0;
        // N s_3567_2: jump b3568
        return block_3568(state, tracer, fn_state);
    }
    fn block_3568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3568_0: read-var gs#119133:u8
        let s_3568_0: bool = fn_state.gs_119133;
        // N s_3568_1: branch s_3568_0 b3688 b3569
        if s_3568_0 {
            return block_3688(state, tracer, fn_state);
        } else {
            return block_3569(state, tracer, fn_state);
        };
    }
    fn block_3569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3569_0: const #0u : u8
        let s_3569_0: bool = false;
        // D s_3569_1: write-var gs#119134 <= s_3569_0
        fn_state.gs_119134 = s_3569_0;
        // N s_3569_2: jump b3570
        return block_3570(state, tracer, fn_state);
    }
    fn block_3570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3570_0: read-var gs#119134:u8
        let s_3570_0: bool = fn_state.gs_119134;
        // N s_3570_1: branch s_3570_0 b3687 b3571
        if s_3570_0 {
            return block_3687(state, tracer, fn_state);
        } else {
            return block_3571(state, tracer, fn_state);
        };
    }
    fn block_3571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3571_0: const #0u : u8
        let s_3571_0: bool = false;
        // D s_3571_1: write-var gs#119135 <= s_3571_0
        fn_state.gs_119135 = s_3571_0;
        // N s_3571_2: jump b3572
        return block_3572(state, tracer, fn_state);
    }
    fn block_3572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3572_0: read-var gs#119135:u8
        let s_3572_0: bool = fn_state.gs_119135;
        // N s_3572_1: branch s_3572_0 b3686 b3573
        if s_3572_0 {
            return block_3686(state, tracer, fn_state);
        } else {
            return block_3573(state, tracer, fn_state);
        };
    }
    fn block_3573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3573_0: read-var CRm:u8
        let s_3573_0: u8 = fn_state.CRm;
        // D s_3573_1: cast zx s_3573_0 -> bv
        let s_3573_1: Bits = Bits::new(s_3573_0 as u128, 4u16);
        // C s_3573_2: const #5u : u8
        let s_3573_2: u8 = 5;
        // C s_3573_3: cast zx s_3573_2 -> bv
        let s_3573_3: Bits = Bits::new(s_3573_2 as u128, 4u16);
        // D s_3573_4: cmp-eq s_3573_1 s_3573_3
        let s_3573_4: bool = ((s_3573_1) == (s_3573_3));
        // N s_3573_5: branch s_3573_4 b3685 b3574
        if s_3573_4 {
            return block_3685(state, tracer, fn_state);
        } else {
            return block_3574(state, tracer, fn_state);
        };
    }
    fn block_3574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3574_0: const #0u : u8
        let s_3574_0: bool = false;
        // D s_3574_1: write-var gs#119136 <= s_3574_0
        fn_state.gs_119136 = s_3574_0;
        // N s_3574_2: jump b3575
        return block_3575(state, tracer, fn_state);
    }
    fn block_3575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3575_0: read-var gs#119136:u8
        let s_3575_0: bool = fn_state.gs_119136;
        // N s_3575_1: branch s_3575_0 b3684 b3576
        if s_3575_0 {
            return block_3684(state, tracer, fn_state);
        } else {
            return block_3576(state, tracer, fn_state);
        };
    }
    fn block_3576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3576_0: const #0u : u8
        let s_3576_0: bool = false;
        // D s_3576_1: write-var gs#119137 <= s_3576_0
        fn_state.gs_119137 = s_3576_0;
        // N s_3576_2: jump b3577
        return block_3577(state, tracer, fn_state);
    }
    fn block_3577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3577_0: read-var gs#119137:u8
        let s_3577_0: bool = fn_state.gs_119137;
        // N s_3577_1: branch s_3577_0 b3683 b3578
        if s_3577_0 {
            return block_3683(state, tracer, fn_state);
        } else {
            return block_3578(state, tracer, fn_state);
        };
    }
    fn block_3578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3578_0: const #0u : u8
        let s_3578_0: bool = false;
        // D s_3578_1: write-var gs#119138 <= s_3578_0
        fn_state.gs_119138 = s_3578_0;
        // N s_3578_2: jump b3579
        return block_3579(state, tracer, fn_state);
    }
    fn block_3579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3579_0: read-var gs#119138:u8
        let s_3579_0: bool = fn_state.gs_119138;
        // N s_3579_1: branch s_3579_0 b3682 b3580
        if s_3579_0 {
            return block_3682(state, tracer, fn_state);
        } else {
            return block_3580(state, tracer, fn_state);
        };
    }
    fn block_3580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3580_0: const #0u : u8
        let s_3580_0: bool = false;
        // D s_3580_1: write-var gs#119139 <= s_3580_0
        fn_state.gs_119139 = s_3580_0;
        // N s_3580_2: jump b3581
        return block_3581(state, tracer, fn_state);
    }
    fn block_3581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3581_0: read-var gs#119139:u8
        let s_3581_0: bool = fn_state.gs_119139;
        // N s_3581_1: branch s_3581_0 b3681 b3582
        if s_3581_0 {
            return block_3681(state, tracer, fn_state);
        } else {
            return block_3582(state, tracer, fn_state);
        };
    }
    fn block_3582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3582_0: read-var CRm:u8
        let s_3582_0: u8 = fn_state.CRm;
        // D s_3582_1: cast zx s_3582_0 -> bv
        let s_3582_1: Bits = Bits::new(s_3582_0 as u128, 4u16);
        // C s_3582_2: const #5u : u8
        let s_3582_2: u8 = 5;
        // C s_3582_3: cast zx s_3582_2 -> bv
        let s_3582_3: Bits = Bits::new(s_3582_2 as u128, 4u16);
        // D s_3582_4: cmp-eq s_3582_1 s_3582_3
        let s_3582_4: bool = ((s_3582_1) == (s_3582_3));
        // N s_3582_5: branch s_3582_4 b3680 b3583
        if s_3582_4 {
            return block_3680(state, tracer, fn_state);
        } else {
            return block_3583(state, tracer, fn_state);
        };
    }
    fn block_3583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3583_0: const #0u : u8
        let s_3583_0: bool = false;
        // D s_3583_1: write-var gs#119140 <= s_3583_0
        fn_state.gs_119140 = s_3583_0;
        // N s_3583_2: jump b3584
        return block_3584(state, tracer, fn_state);
    }
    fn block_3584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3584_0: read-var gs#119140:u8
        let s_3584_0: bool = fn_state.gs_119140;
        // N s_3584_1: branch s_3584_0 b3679 b3585
        if s_3584_0 {
            return block_3679(state, tracer, fn_state);
        } else {
            return block_3585(state, tracer, fn_state);
        };
    }
    fn block_3585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3585_0: const #0u : u8
        let s_3585_0: bool = false;
        // D s_3585_1: write-var gs#119141 <= s_3585_0
        fn_state.gs_119141 = s_3585_0;
        // N s_3585_2: jump b3586
        return block_3586(state, tracer, fn_state);
    }
    fn block_3586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3586_0: read-var gs#119141:u8
        let s_3586_0: bool = fn_state.gs_119141;
        // N s_3586_1: branch s_3586_0 b3678 b3587
        if s_3586_0 {
            return block_3678(state, tracer, fn_state);
        } else {
            return block_3587(state, tracer, fn_state);
        };
    }
    fn block_3587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3587_0: const #0u : u8
        let s_3587_0: bool = false;
        // D s_3587_1: write-var gs#119142 <= s_3587_0
        fn_state.gs_119142 = s_3587_0;
        // N s_3587_2: jump b3588
        return block_3588(state, tracer, fn_state);
    }
    fn block_3588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3588_0: read-var gs#119142:u8
        let s_3588_0: bool = fn_state.gs_119142;
        // N s_3588_1: branch s_3588_0 b3677 b3589
        if s_3588_0 {
            return block_3677(state, tracer, fn_state);
        } else {
            return block_3589(state, tracer, fn_state);
        };
    }
    fn block_3589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3589_0: const #0u : u8
        let s_3589_0: bool = false;
        // D s_3589_1: write-var gs#119143 <= s_3589_0
        fn_state.gs_119143 = s_3589_0;
        // N s_3589_2: jump b3590
        return block_3590(state, tracer, fn_state);
    }
    fn block_3590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3590_0: read-var gs#119143:u8
        let s_3590_0: bool = fn_state.gs_119143;
        // N s_3590_1: branch s_3590_0 b3676 b3591
        if s_3590_0 {
            return block_3676(state, tracer, fn_state);
        } else {
            return block_3591(state, tracer, fn_state);
        };
    }
    fn block_3591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3591_0: read-var CRm:u8
        let s_3591_0: u8 = fn_state.CRm;
        // D s_3591_1: cast zx s_3591_0 -> bv
        let s_3591_1: Bits = Bits::new(s_3591_0 as u128, 4u16);
        // C s_3591_2: const #4u : u8
        let s_3591_2: u8 = 4;
        // C s_3591_3: cast zx s_3591_2 -> bv
        let s_3591_3: Bits = Bits::new(s_3591_2 as u128, 4u16);
        // D s_3591_4: cmp-eq s_3591_1 s_3591_3
        let s_3591_4: bool = ((s_3591_1) == (s_3591_3));
        // N s_3591_5: branch s_3591_4 b3675 b3592
        if s_3591_4 {
            return block_3675(state, tracer, fn_state);
        } else {
            return block_3592(state, tracer, fn_state);
        };
    }
    fn block_3592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3592_0: const #0u : u8
        let s_3592_0: bool = false;
        // D s_3592_1: write-var gs#119144 <= s_3592_0
        fn_state.gs_119144 = s_3592_0;
        // N s_3592_2: jump b3593
        return block_3593(state, tracer, fn_state);
    }
    fn block_3593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3593_0: read-var gs#119144:u8
        let s_3593_0: bool = fn_state.gs_119144;
        // N s_3593_1: branch s_3593_0 b3674 b3594
        if s_3593_0 {
            return block_3674(state, tracer, fn_state);
        } else {
            return block_3594(state, tracer, fn_state);
        };
    }
    fn block_3594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3594_0: const #0u : u8
        let s_3594_0: bool = false;
        // D s_3594_1: write-var gs#119145 <= s_3594_0
        fn_state.gs_119145 = s_3594_0;
        // N s_3594_2: jump b3595
        return block_3595(state, tracer, fn_state);
    }
    fn block_3595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3595_0: read-var gs#119145:u8
        let s_3595_0: bool = fn_state.gs_119145;
        // N s_3595_1: branch s_3595_0 b3673 b3596
        if s_3595_0 {
            return block_3673(state, tracer, fn_state);
        } else {
            return block_3596(state, tracer, fn_state);
        };
    }
    fn block_3596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3596_0: const #0u : u8
        let s_3596_0: bool = false;
        // D s_3596_1: write-var gs#119146 <= s_3596_0
        fn_state.gs_119146 = s_3596_0;
        // N s_3596_2: jump b3597
        return block_3597(state, tracer, fn_state);
    }
    fn block_3597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3597_0: read-var gs#119146:u8
        let s_3597_0: bool = fn_state.gs_119146;
        // N s_3597_1: branch s_3597_0 b3672 b3598
        if s_3597_0 {
            return block_3672(state, tracer, fn_state);
        } else {
            return block_3598(state, tracer, fn_state);
        };
    }
    fn block_3598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3598_0: const #0u : u8
        let s_3598_0: bool = false;
        // D s_3598_1: write-var gs#119147 <= s_3598_0
        fn_state.gs_119147 = s_3598_0;
        // N s_3598_2: jump b3599
        return block_3599(state, tracer, fn_state);
    }
    fn block_3599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3599_0: read-var gs#119147:u8
        let s_3599_0: bool = fn_state.gs_119147;
        // N s_3599_1: branch s_3599_0 b3671 b3600
        if s_3599_0 {
            return block_3671(state, tracer, fn_state);
        } else {
            return block_3600(state, tracer, fn_state);
        };
    }
    fn block_3600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3600_0: read-var CRm:u8
        let s_3600_0: u8 = fn_state.CRm;
        // D s_3600_1: cast zx s_3600_0 -> bv
        let s_3600_1: Bits = Bits::new(s_3600_0 as u128, 4u16);
        // C s_3600_2: const #5u : u8
        let s_3600_2: u8 = 5;
        // C s_3600_3: cast zx s_3600_2 -> bv
        let s_3600_3: Bits = Bits::new(s_3600_2 as u128, 4u16);
        // D s_3600_4: cmp-eq s_3600_1 s_3600_3
        let s_3600_4: bool = ((s_3600_1) == (s_3600_3));
        // N s_3600_5: branch s_3600_4 b3670 b3601
        if s_3600_4 {
            return block_3670(state, tracer, fn_state);
        } else {
            return block_3601(state, tracer, fn_state);
        };
    }
    fn block_3601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3601_0: const #0u : u8
        let s_3601_0: bool = false;
        // D s_3601_1: write-var gs#119148 <= s_3601_0
        fn_state.gs_119148 = s_3601_0;
        // N s_3601_2: jump b3602
        return block_3602(state, tracer, fn_state);
    }
    fn block_3602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3602_0: read-var gs#119148:u8
        let s_3602_0: bool = fn_state.gs_119148;
        // N s_3602_1: branch s_3602_0 b3669 b3603
        if s_3602_0 {
            return block_3669(state, tracer, fn_state);
        } else {
            return block_3603(state, tracer, fn_state);
        };
    }
    fn block_3603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3603_0: const #0u : u8
        let s_3603_0: bool = false;
        // D s_3603_1: write-var gs#119149 <= s_3603_0
        fn_state.gs_119149 = s_3603_0;
        // N s_3603_2: jump b3604
        return block_3604(state, tracer, fn_state);
    }
    fn block_3604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3604_0: read-var gs#119149:u8
        let s_3604_0: bool = fn_state.gs_119149;
        // N s_3604_1: branch s_3604_0 b3668 b3605
        if s_3604_0 {
            return block_3668(state, tracer, fn_state);
        } else {
            return block_3605(state, tracer, fn_state);
        };
    }
    fn block_3605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3605_0: const #0u : u8
        let s_3605_0: bool = false;
        // D s_3605_1: write-var gs#119150 <= s_3605_0
        fn_state.gs_119150 = s_3605_0;
        // N s_3605_2: jump b3606
        return block_3606(state, tracer, fn_state);
    }
    fn block_3606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3606_0: read-var gs#119150:u8
        let s_3606_0: bool = fn_state.gs_119150;
        // N s_3606_1: branch s_3606_0 b3667 b3607
        if s_3606_0 {
            return block_3667(state, tracer, fn_state);
        } else {
            return block_3607(state, tracer, fn_state);
        };
    }
    fn block_3607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3607_0: const #0u : u8
        let s_3607_0: bool = false;
        // D s_3607_1: write-var gs#119151 <= s_3607_0
        fn_state.gs_119151 = s_3607_0;
        // N s_3607_2: jump b3608
        return block_3608(state, tracer, fn_state);
    }
    fn block_3608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3608_0: read-var gs#119151:u8
        let s_3608_0: bool = fn_state.gs_119151;
        // N s_3608_1: branch s_3608_0 b3666 b3609
        if s_3608_0 {
            return block_3666(state, tracer, fn_state);
        } else {
            return block_3609(state, tracer, fn_state);
        };
    }
    fn block_3609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3609_0: read-var CRm:u8
        let s_3609_0: u8 = fn_state.CRm;
        // D s_3609_1: cast zx s_3609_0 -> bv
        let s_3609_1: Bits = Bits::new(s_3609_0 as u128, 4u16);
        // C s_3609_2: const #5u : u8
        let s_3609_2: u8 = 5;
        // C s_3609_3: cast zx s_3609_2 -> bv
        let s_3609_3: Bits = Bits::new(s_3609_2 as u128, 4u16);
        // D s_3609_4: cmp-eq s_3609_1 s_3609_3
        let s_3609_4: bool = ((s_3609_1) == (s_3609_3));
        // N s_3609_5: branch s_3609_4 b3665 b3610
        if s_3609_4 {
            return block_3665(state, tracer, fn_state);
        } else {
            return block_3610(state, tracer, fn_state);
        };
    }
    fn block_3610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3610_0: const #0u : u8
        let s_3610_0: bool = false;
        // D s_3610_1: write-var gs#119152 <= s_3610_0
        fn_state.gs_119152 = s_3610_0;
        // N s_3610_2: jump b3611
        return block_3611(state, tracer, fn_state);
    }
    fn block_3611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3611_0: read-var gs#119152:u8
        let s_3611_0: bool = fn_state.gs_119152;
        // N s_3611_1: branch s_3611_0 b3664 b3612
        if s_3611_0 {
            return block_3664(state, tracer, fn_state);
        } else {
            return block_3612(state, tracer, fn_state);
        };
    }
    fn block_3612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3612_0: const #0u : u8
        let s_3612_0: bool = false;
        // D s_3612_1: write-var gs#119153 <= s_3612_0
        fn_state.gs_119153 = s_3612_0;
        // N s_3612_2: jump b3613
        return block_3613(state, tracer, fn_state);
    }
    fn block_3613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3613_0: read-var gs#119153:u8
        let s_3613_0: bool = fn_state.gs_119153;
        // N s_3613_1: branch s_3613_0 b3663 b3614
        if s_3613_0 {
            return block_3663(state, tracer, fn_state);
        } else {
            return block_3614(state, tracer, fn_state);
        };
    }
    fn block_3614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3614_0: const #0u : u8
        let s_3614_0: bool = false;
        // D s_3614_1: write-var gs#119154 <= s_3614_0
        fn_state.gs_119154 = s_3614_0;
        // N s_3614_2: jump b3615
        return block_3615(state, tracer, fn_state);
    }
    fn block_3615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3615_0: read-var gs#119154:u8
        let s_3615_0: bool = fn_state.gs_119154;
        // N s_3615_1: branch s_3615_0 b3662 b3616
        if s_3615_0 {
            return block_3662(state, tracer, fn_state);
        } else {
            return block_3616(state, tracer, fn_state);
        };
    }
    fn block_3616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3616_0: const #0u : u8
        let s_3616_0: bool = false;
        // D s_3616_1: write-var gs#119155 <= s_3616_0
        fn_state.gs_119155 = s_3616_0;
        // N s_3616_2: jump b3617
        return block_3617(state, tracer, fn_state);
    }
    fn block_3617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3617_0: read-var gs#119155:u8
        let s_3617_0: bool = fn_state.gs_119155;
        // N s_3617_1: branch s_3617_0 b3661 b3618
        if s_3617_0 {
            return block_3661(state, tracer, fn_state);
        } else {
            return block_3618(state, tracer, fn_state);
        };
    }
    fn block_3618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3618_0: read-var CRm:u8
        let s_3618_0: u8 = fn_state.CRm;
        // D s_3618_1: cast zx s_3618_0 -> bv
        let s_3618_1: Bits = Bits::new(s_3618_0 as u128, 4u16);
        // C s_3618_2: const #1u : u8
        let s_3618_2: u8 = 1;
        // C s_3618_3: cast zx s_3618_2 -> bv
        let s_3618_3: Bits = Bits::new(s_3618_2 as u128, 4u16);
        // D s_3618_4: cmp-eq s_3618_1 s_3618_3
        let s_3618_4: bool = ((s_3618_1) == (s_3618_3));
        // N s_3618_5: branch s_3618_4 b3660 b3619
        if s_3618_4 {
            return block_3660(state, tracer, fn_state);
        } else {
            return block_3619(state, tracer, fn_state);
        };
    }
    fn block_3619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3619_0: const #0u : u8
        let s_3619_0: bool = false;
        // D s_3619_1: write-var gs#119156 <= s_3619_0
        fn_state.gs_119156 = s_3619_0;
        // N s_3619_2: jump b3620
        return block_3620(state, tracer, fn_state);
    }
    fn block_3620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3620_0: read-var gs#119156:u8
        let s_3620_0: bool = fn_state.gs_119156;
        // N s_3620_1: branch s_3620_0 b3659 b3621
        if s_3620_0 {
            return block_3659(state, tracer, fn_state);
        } else {
            return block_3621(state, tracer, fn_state);
        };
    }
    fn block_3621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3621_0: const #0u : u8
        let s_3621_0: bool = false;
        // D s_3621_1: write-var gs#119157 <= s_3621_0
        fn_state.gs_119157 = s_3621_0;
        // N s_3621_2: jump b3622
        return block_3622(state, tracer, fn_state);
    }
    fn block_3622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3622_0: read-var gs#119157:u8
        let s_3622_0: bool = fn_state.gs_119157;
        // N s_3622_1: branch s_3622_0 b3658 b3623
        if s_3622_0 {
            return block_3658(state, tracer, fn_state);
        } else {
            return block_3623(state, tracer, fn_state);
        };
    }
    fn block_3623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3623_0: const #0u : u8
        let s_3623_0: bool = false;
        // D s_3623_1: write-var gs#119158 <= s_3623_0
        fn_state.gs_119158 = s_3623_0;
        // N s_3623_2: jump b3624
        return block_3624(state, tracer, fn_state);
    }
    fn block_3624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3624_0: read-var gs#119158:u8
        let s_3624_0: bool = fn_state.gs_119158;
        // N s_3624_1: branch s_3624_0 b3657 b3625
        if s_3624_0 {
            return block_3657(state, tracer, fn_state);
        } else {
            return block_3625(state, tracer, fn_state);
        };
    }
    fn block_3625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3625_0: const #0u : u8
        let s_3625_0: bool = false;
        // D s_3625_1: write-var gs#119159 <= s_3625_0
        fn_state.gs_119159 = s_3625_0;
        // N s_3625_2: jump b3626
        return block_3626(state, tracer, fn_state);
    }
    fn block_3626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3626_0: read-var gs#119159:u8
        let s_3626_0: bool = fn_state.gs_119159;
        // N s_3626_1: branch s_3626_0 b3656 b3627
        if s_3626_0 {
            return block_3656(state, tracer, fn_state);
        } else {
            return block_3627(state, tracer, fn_state);
        };
    }
    fn block_3627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3627_0: read-var CRm:u8
        let s_3627_0: u8 = fn_state.CRm;
        // D s_3627_1: cast zx s_3627_0 -> bv
        let s_3627_1: Bits = Bits::new(s_3627_0 as u128, 4u16);
        // C s_3627_2: const #4u : u8
        let s_3627_2: u8 = 4;
        // C s_3627_3: cast zx s_3627_2 -> bv
        let s_3627_3: Bits = Bits::new(s_3627_2 as u128, 4u16);
        // D s_3627_4: cmp-eq s_3627_1 s_3627_3
        let s_3627_4: bool = ((s_3627_1) == (s_3627_3));
        // N s_3627_5: branch s_3627_4 b3655 b3628
        if s_3627_4 {
            return block_3655(state, tracer, fn_state);
        } else {
            return block_3628(state, tracer, fn_state);
        };
    }
    fn block_3628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3628_0: const #0u : u8
        let s_3628_0: bool = false;
        // D s_3628_1: write-var gs#119160 <= s_3628_0
        fn_state.gs_119160 = s_3628_0;
        // N s_3628_2: jump b3629
        return block_3629(state, tracer, fn_state);
    }
    fn block_3629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3629_0: read-var gs#119160:u8
        let s_3629_0: bool = fn_state.gs_119160;
        // N s_3629_1: branch s_3629_0 b3654 b3630
        if s_3629_0 {
            return block_3654(state, tracer, fn_state);
        } else {
            return block_3630(state, tracer, fn_state);
        };
    }
    fn block_3630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3630_0: const #0u : u8
        let s_3630_0: bool = false;
        // D s_3630_1: write-var gs#119161 <= s_3630_0
        fn_state.gs_119161 = s_3630_0;
        // N s_3630_2: jump b3631
        return block_3631(state, tracer, fn_state);
    }
    fn block_3631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3631_0: read-var gs#119161:u8
        let s_3631_0: bool = fn_state.gs_119161;
        // N s_3631_1: branch s_3631_0 b3653 b3632
        if s_3631_0 {
            return block_3653(state, tracer, fn_state);
        } else {
            return block_3632(state, tracer, fn_state);
        };
    }
    fn block_3632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3632_0: const #0u : u8
        let s_3632_0: bool = false;
        // D s_3632_1: write-var gs#119162 <= s_3632_0
        fn_state.gs_119162 = s_3632_0;
        // N s_3632_2: jump b3633
        return block_3633(state, tracer, fn_state);
    }
    fn block_3633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3633_0: read-var gs#119162:u8
        let s_3633_0: bool = fn_state.gs_119162;
        // N s_3633_1: branch s_3633_0 b3652 b3634
        if s_3633_0 {
            return block_3652(state, tracer, fn_state);
        } else {
            return block_3634(state, tracer, fn_state);
        };
    }
    fn block_3634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3634_0: const #0u : u8
        let s_3634_0: bool = false;
        // D s_3634_1: write-var gs#119163 <= s_3634_0
        fn_state.gs_119163 = s_3634_0;
        // N s_3634_2: jump b3635
        return block_3635(state, tracer, fn_state);
    }
    fn block_3635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3635_0: read-var gs#119163:u8
        let s_3635_0: bool = fn_state.gs_119163;
        // N s_3635_1: branch s_3635_0 b3651 b3636
        if s_3635_0 {
            return block_3651(state, tracer, fn_state);
        } else {
            return block_3636(state, tracer, fn_state);
        };
    }
    fn block_3636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3636_0: read-var CRm:u8
        let s_3636_0: u8 = fn_state.CRm;
        // D s_3636_1: cast zx s_3636_0 -> bv
        let s_3636_1: Bits = Bits::new(s_3636_0 as u128, 4u16);
        // C s_3636_2: const #0u : u8
        let s_3636_2: u8 = 0;
        // C s_3636_3: cast zx s_3636_2 -> bv
        let s_3636_3: Bits = Bits::new(s_3636_2 as u128, 4u16);
        // D s_3636_4: cmp-eq s_3636_1 s_3636_3
        let s_3636_4: bool = ((s_3636_1) == (s_3636_3));
        // N s_3636_5: branch s_3636_4 b3650 b3637
        if s_3636_4 {
            return block_3650(state, tracer, fn_state);
        } else {
            return block_3637(state, tracer, fn_state);
        };
    }
    fn block_3637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3637_0: const #0u : u8
        let s_3637_0: bool = false;
        // D s_3637_1: write-var gs#119164 <= s_3637_0
        fn_state.gs_119164 = s_3637_0;
        // N s_3637_2: jump b3638
        return block_3638(state, tracer, fn_state);
    }
    fn block_3638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3638_0: read-var gs#119164:u8
        let s_3638_0: bool = fn_state.gs_119164;
        // N s_3638_1: branch s_3638_0 b3649 b3639
        if s_3638_0 {
            return block_3649(state, tracer, fn_state);
        } else {
            return block_3639(state, tracer, fn_state);
        };
    }
    fn block_3639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3639_0: const #0u : u8
        let s_3639_0: bool = false;
        // D s_3639_1: write-var gs#119165 <= s_3639_0
        fn_state.gs_119165 = s_3639_0;
        // N s_3639_2: jump b3640
        return block_3640(state, tracer, fn_state);
    }
    fn block_3640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3640_0: read-var gs#119165:u8
        let s_3640_0: bool = fn_state.gs_119165;
        // N s_3640_1: branch s_3640_0 b3648 b3641
        if s_3640_0 {
            return block_3648(state, tracer, fn_state);
        } else {
            return block_3641(state, tracer, fn_state);
        };
    }
    fn block_3641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3641_0: const #0u : u8
        let s_3641_0: bool = false;
        // D s_3641_1: write-var gs#119166 <= s_3641_0
        fn_state.gs_119166 = s_3641_0;
        // N s_3641_2: jump b3642
        return block_3642(state, tracer, fn_state);
    }
    fn block_3642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3642_0: read-var gs#119166:u8
        let s_3642_0: bool = fn_state.gs_119166;
        // N s_3642_1: branch s_3642_0 b3647 b3643
        if s_3642_0 {
            return block_3647(state, tracer, fn_state);
        } else {
            return block_3643(state, tracer, fn_state);
        };
    }
    fn block_3643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3643_0: const #0u : u8
        let s_3643_0: bool = false;
        // D s_3643_1: write-var gs#119167 <= s_3643_0
        fn_state.gs_119167 = s_3643_0;
        // N s_3643_2: jump b3644
        return block_3644(state, tracer, fn_state);
    }
    fn block_3644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3644_0: read-var gs#119167:u8
        let s_3644_0: bool = fn_state.gs_119167;
        // N s_3644_1: branch s_3644_0 b3646 b3645
        if s_3644_0 {
            return block_3646(state, tracer, fn_state);
        } else {
            return block_3645(state, tracer, fn_state);
        };
    }
    fn block_3645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3645_0: read-var coproc:u8
        let s_3645_0: u8 = fn_state.coproc;
        // D s_3645_1: read-var opc1:u8
        let s_3645_1: u8 = fn_state.opc1;
        // D s_3645_2: read-var CRn:u8
        let s_3645_2: u8 = fn_state.CRn;
        // D s_3645_3: read-var opc2:u8
        let s_3645_3: u8 = fn_state.opc2;
        // D s_3645_4: read-var CRm:u8
        let s_3645_4: u8 = fn_state.CRm;
        // C s_3645_5: const #1u : u8
        let s_3645_5: bool = true;
        // D s_3645_6: read-var t:i
        let s_3645_6: i128 = fn_state.t;
        // D s_3645_7: call AArch32_UnallocatedSysRegAccess(s_3645_0, s_3645_1, s_3645_2, s_3645_3, s_3645_4, s_3645_5, s_3645_6)
        let s_3645_7: () = AArch32_UnallocatedSysRegAccess(
            state,
            tracer,
            s_3645_0,
            s_3645_1,
            s_3645_2,
            s_3645_3,
            s_3645_4,
            s_3645_5,
            s_3645_6,
        );
        // N s_3645_8: return
        return;
    }
    fn block_3646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3646_0: read-var el:u8
        let s_3646_0: u8 = fn_state.el;
        // D s_3646_1: read-var coproc:u8
        let s_3646_1: u8 = fn_state.coproc;
        // D s_3646_2: read-var opc1:u8
        let s_3646_2: u8 = fn_state.opc1;
        // D s_3646_3: read-var CRn:u8
        let s_3646_3: u8 = fn_state.CRn;
        // D s_3646_4: read-var opc2:u8
        let s_3646_4: u8 = fn_state.opc2;
        // D s_3646_5: read-var CRm:u8
        let s_3646_5: u8 = fn_state.CRm;
        // D s_3646_6: read-var t:i
        let s_3646_6: i128 = fn_state.t;
        // D s_3646_7: call HACTLR2_SysRegRead32_0445e99237541ba9(s_3646_0, s_3646_1, s_3646_2, s_3646_3, s_3646_4, s_3646_5, s_3646_6)
        let s_3646_7: () = HACTLR2_SysRegRead32_0445e99237541ba9(
            state,
            tracer,
            s_3646_0,
            s_3646_1,
            s_3646_2,
            s_3646_3,
            s_3646_4,
            s_3646_5,
            s_3646_6,
        );
        // N s_3646_8: return
        return;
    }
    fn block_3647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3647_0: read-var opc2:u8
        let s_3647_0: u8 = fn_state.opc2;
        // D s_3647_1: cast zx s_3647_0 -> bv
        let s_3647_1: Bits = Bits::new(s_3647_0 as u128, 3u16);
        // C s_3647_2: const #3u : u8
        let s_3647_2: u8 = 3;
        // C s_3647_3: cast zx s_3647_2 -> bv
        let s_3647_3: Bits = Bits::new(s_3647_2 as u128, 3u16);
        // D s_3647_4: cmp-eq s_3647_1 s_3647_3
        let s_3647_4: bool = ((s_3647_1) == (s_3647_3));
        // D s_3647_5: write-var gs#119167 <= s_3647_4
        fn_state.gs_119167 = s_3647_4;
        // N s_3647_6: jump b3644
        return block_3644(state, tracer, fn_state);
    }
    fn block_3648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3648_0: read-var opc1:u8
        let s_3648_0: u8 = fn_state.opc1;
        // D s_3648_1: cast zx s_3648_0 -> bv
        let s_3648_1: Bits = Bits::new(s_3648_0 as u128, 3u16);
        // C s_3648_2: const #4u : u8
        let s_3648_2: u8 = 4;
        // C s_3648_3: cast zx s_3648_2 -> bv
        let s_3648_3: Bits = Bits::new(s_3648_2 as u128, 3u16);
        // D s_3648_4: cmp-eq s_3648_1 s_3648_3
        let s_3648_4: bool = ((s_3648_1) == (s_3648_3));
        // D s_3648_5: write-var gs#119166 <= s_3648_4
        fn_state.gs_119166 = s_3648_4;
        // N s_3648_6: jump b3642
        return block_3642(state, tracer, fn_state);
    }
    fn block_3649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3649_0: read-var coproc:u8
        let s_3649_0: u8 = fn_state.coproc;
        // D s_3649_1: cast zx s_3649_0 -> bv
        let s_3649_1: Bits = Bits::new(s_3649_0 as u128, 4u16);
        // C s_3649_2: const #15u : u8
        let s_3649_2: u8 = 15;
        // C s_3649_3: cast zx s_3649_2 -> bv
        let s_3649_3: Bits = Bits::new(s_3649_2 as u128, 4u16);
        // D s_3649_4: cmp-eq s_3649_1 s_3649_3
        let s_3649_4: bool = ((s_3649_1) == (s_3649_3));
        // D s_3649_5: write-var gs#119165 <= s_3649_4
        fn_state.gs_119165 = s_3649_4;
        // N s_3649_6: jump b3640
        return block_3640(state, tracer, fn_state);
    }
    fn block_3650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3650_0: read-var CRn:u8
        let s_3650_0: u8 = fn_state.CRn;
        // D s_3650_1: cast zx s_3650_0 -> bv
        let s_3650_1: Bits = Bits::new(s_3650_0 as u128, 4u16);
        // C s_3650_2: const #1u : u8
        let s_3650_2: u8 = 1;
        // C s_3650_3: cast zx s_3650_2 -> bv
        let s_3650_3: Bits = Bits::new(s_3650_2 as u128, 4u16);
        // D s_3650_4: cmp-eq s_3650_1 s_3650_3
        let s_3650_4: bool = ((s_3650_1) == (s_3650_3));
        // D s_3650_5: write-var gs#119164 <= s_3650_4
        fn_state.gs_119164 = s_3650_4;
        // N s_3650_6: jump b3638
        return block_3638(state, tracer, fn_state);
    }
    fn block_3651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3651_0: read-var el:u8
        let s_3651_0: u8 = fn_state.el;
        // D s_3651_1: read-var coproc:u8
        let s_3651_1: u8 = fn_state.coproc;
        // D s_3651_2: read-var opc1:u8
        let s_3651_2: u8 = fn_state.opc1;
        // D s_3651_3: read-var CRn:u8
        let s_3651_3: u8 = fn_state.CRn;
        // D s_3651_4: read-var opc2:u8
        let s_3651_4: u8 = fn_state.opc2;
        // D s_3651_5: read-var CRm:u8
        let s_3651_5: u8 = fn_state.CRm;
        // D s_3651_6: read-var t:i
        let s_3651_6: i128 = fn_state.t;
        // D s_3651_7: call ERXSTATUS_SysRegRead32_5466a91990979d70(s_3651_0, s_3651_1, s_3651_2, s_3651_3, s_3651_4, s_3651_5, s_3651_6)
        let s_3651_7: () = ERXSTATUS_SysRegRead32_5466a91990979d70(
            state,
            tracer,
            s_3651_0,
            s_3651_1,
            s_3651_2,
            s_3651_3,
            s_3651_4,
            s_3651_5,
            s_3651_6,
        );
        // N s_3651_8: return
        return;
    }
    fn block_3652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3652_0: read-var opc2:u8
        let s_3652_0: u8 = fn_state.opc2;
        // D s_3652_1: cast zx s_3652_0 -> bv
        let s_3652_1: Bits = Bits::new(s_3652_0 as u128, 3u16);
        // C s_3652_2: const #2u : u8
        let s_3652_2: u8 = 2;
        // C s_3652_3: cast zx s_3652_2 -> bv
        let s_3652_3: Bits = Bits::new(s_3652_2 as u128, 3u16);
        // D s_3652_4: cmp-eq s_3652_1 s_3652_3
        let s_3652_4: bool = ((s_3652_1) == (s_3652_3));
        // D s_3652_5: write-var gs#119163 <= s_3652_4
        fn_state.gs_119163 = s_3652_4;
        // N s_3652_6: jump b3635
        return block_3635(state, tracer, fn_state);
    }
    fn block_3653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3653_0: read-var opc1:u8
        let s_3653_0: u8 = fn_state.opc1;
        // D s_3653_1: cast zx s_3653_0 -> bv
        let s_3653_1: Bits = Bits::new(s_3653_0 as u128, 3u16);
        // C s_3653_2: const #0u : u8
        let s_3653_2: u8 = 0;
        // C s_3653_3: cast zx s_3653_2 -> bv
        let s_3653_3: Bits = Bits::new(s_3653_2 as u128, 3u16);
        // D s_3653_4: cmp-eq s_3653_1 s_3653_3
        let s_3653_4: bool = ((s_3653_1) == (s_3653_3));
        // D s_3653_5: write-var gs#119162 <= s_3653_4
        fn_state.gs_119162 = s_3653_4;
        // N s_3653_6: jump b3633
        return block_3633(state, tracer, fn_state);
    }
    fn block_3654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3654_0: read-var coproc:u8
        let s_3654_0: u8 = fn_state.coproc;
        // D s_3654_1: cast zx s_3654_0 -> bv
        let s_3654_1: Bits = Bits::new(s_3654_0 as u128, 4u16);
        // C s_3654_2: const #15u : u8
        let s_3654_2: u8 = 15;
        // C s_3654_3: cast zx s_3654_2 -> bv
        let s_3654_3: Bits = Bits::new(s_3654_2 as u128, 4u16);
        // D s_3654_4: cmp-eq s_3654_1 s_3654_3
        let s_3654_4: bool = ((s_3654_1) == (s_3654_3));
        // D s_3654_5: write-var gs#119161 <= s_3654_4
        fn_state.gs_119161 = s_3654_4;
        // N s_3654_6: jump b3631
        return block_3631(state, tracer, fn_state);
    }
    fn block_3655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3655_0: read-var CRn:u8
        let s_3655_0: u8 = fn_state.CRn;
        // D s_3655_1: cast zx s_3655_0 -> bv
        let s_3655_1: Bits = Bits::new(s_3655_0 as u128, 4u16);
        // C s_3655_2: const #5u : u8
        let s_3655_2: u8 = 5;
        // C s_3655_3: cast zx s_3655_2 -> bv
        let s_3655_3: Bits = Bits::new(s_3655_2 as u128, 4u16);
        // D s_3655_4: cmp-eq s_3655_1 s_3655_3
        let s_3655_4: bool = ((s_3655_1) == (s_3655_3));
        // D s_3655_5: write-var gs#119160 <= s_3655_4
        fn_state.gs_119160 = s_3655_4;
        // N s_3655_6: jump b3629
        return block_3629(state, tracer, fn_state);
    }
    fn block_3656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3656_0: read-var el:u8
        let s_3656_0: u8 = fn_state.el;
        // D s_3656_1: read-var coproc:u8
        let s_3656_1: u8 = fn_state.coproc;
        // D s_3656_2: read-var opc1:u8
        let s_3656_2: u8 = fn_state.opc1;
        // D s_3656_3: read-var CRn:u8
        let s_3656_3: u8 = fn_state.CRn;
        // D s_3656_4: read-var opc2:u8
        let s_3656_4: u8 = fn_state.opc2;
        // D s_3656_5: read-var CRm:u8
        let s_3656_5: u8 = fn_state.CRm;
        // D s_3656_6: read-var t:i
        let s_3656_6: i128 = fn_state.t;
        // D s_3656_7: call VDISR_SysRegRead32_1bd7b149463ed2f1(s_3656_0, s_3656_1, s_3656_2, s_3656_3, s_3656_4, s_3656_5, s_3656_6)
        let s_3656_7: () = VDISR_SysRegRead32_1bd7b149463ed2f1(
            state,
            tracer,
            s_3656_0,
            s_3656_1,
            s_3656_2,
            s_3656_3,
            s_3656_4,
            s_3656_5,
            s_3656_6,
        );
        // N s_3656_8: return
        return;
    }
    fn block_3657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3657_0: read-var opc2:u8
        let s_3657_0: u8 = fn_state.opc2;
        // D s_3657_1: cast zx s_3657_0 -> bv
        let s_3657_1: Bits = Bits::new(s_3657_0 as u128, 3u16);
        // C s_3657_2: const #1u : u8
        let s_3657_2: u8 = 1;
        // C s_3657_3: cast zx s_3657_2 -> bv
        let s_3657_3: Bits = Bits::new(s_3657_2 as u128, 3u16);
        // D s_3657_4: cmp-eq s_3657_1 s_3657_3
        let s_3657_4: bool = ((s_3657_1) == (s_3657_3));
        // D s_3657_5: write-var gs#119159 <= s_3657_4
        fn_state.gs_119159 = s_3657_4;
        // N s_3657_6: jump b3626
        return block_3626(state, tracer, fn_state);
    }
    fn block_3658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3658_0: read-var opc1:u8
        let s_3658_0: u8 = fn_state.opc1;
        // D s_3658_1: cast zx s_3658_0 -> bv
        let s_3658_1: Bits = Bits::new(s_3658_0 as u128, 3u16);
        // C s_3658_2: const #4u : u8
        let s_3658_2: u8 = 4;
        // C s_3658_3: cast zx s_3658_2 -> bv
        let s_3658_3: Bits = Bits::new(s_3658_2 as u128, 3u16);
        // D s_3658_4: cmp-eq s_3658_1 s_3658_3
        let s_3658_4: bool = ((s_3658_1) == (s_3658_3));
        // D s_3658_5: write-var gs#119158 <= s_3658_4
        fn_state.gs_119158 = s_3658_4;
        // N s_3658_6: jump b3624
        return block_3624(state, tracer, fn_state);
    }
    fn block_3659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3659_0: read-var coproc:u8
        let s_3659_0: u8 = fn_state.coproc;
        // D s_3659_1: cast zx s_3659_0 -> bv
        let s_3659_1: Bits = Bits::new(s_3659_0 as u128, 4u16);
        // C s_3659_2: const #15u : u8
        let s_3659_2: u8 = 15;
        // C s_3659_3: cast zx s_3659_2 -> bv
        let s_3659_3: Bits = Bits::new(s_3659_2 as u128, 4u16);
        // D s_3659_4: cmp-eq s_3659_1 s_3659_3
        let s_3659_4: bool = ((s_3659_1) == (s_3659_3));
        // D s_3659_5: write-var gs#119157 <= s_3659_4
        fn_state.gs_119157 = s_3659_4;
        // N s_3659_6: jump b3622
        return block_3622(state, tracer, fn_state);
    }
    fn block_3660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3660_0: read-var CRn:u8
        let s_3660_0: u8 = fn_state.CRn;
        // D s_3660_1: cast zx s_3660_0 -> bv
        let s_3660_1: Bits = Bits::new(s_3660_0 as u128, 4u16);
        // C s_3660_2: const #12u : u8
        let s_3660_2: u8 = 12;
        // C s_3660_3: cast zx s_3660_2 -> bv
        let s_3660_3: Bits = Bits::new(s_3660_2 as u128, 4u16);
        // D s_3660_4: cmp-eq s_3660_1 s_3660_3
        let s_3660_4: bool = ((s_3660_1) == (s_3660_3));
        // D s_3660_5: write-var gs#119156 <= s_3660_4
        fn_state.gs_119156 = s_3660_4;
        // N s_3660_6: jump b3620
        return block_3620(state, tracer, fn_state);
    }
    fn block_3661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3661_0: read-var el:u8
        let s_3661_0: u8 = fn_state.el;
        // D s_3661_1: read-var coproc:u8
        let s_3661_1: u8 = fn_state.coproc;
        // D s_3661_2: read-var opc1:u8
        let s_3661_2: u8 = fn_state.opc1;
        // D s_3661_3: read-var CRn:u8
        let s_3661_3: u8 = fn_state.CRn;
        // D s_3661_4: read-var opc2:u8
        let s_3661_4: u8 = fn_state.opc2;
        // D s_3661_5: read-var CRm:u8
        let s_3661_5: u8 = fn_state.CRm;
        // D s_3661_6: read-var t:i
        let s_3661_6: i128 = fn_state.t;
        // D s_3661_7: call ERXMISC3_SysRegRead32_2387d2346ca52482(s_3661_0, s_3661_1, s_3661_2, s_3661_3, s_3661_4, s_3661_5, s_3661_6)
        let s_3661_7: () = ERXMISC3_SysRegRead32_2387d2346ca52482(
            state,
            tracer,
            s_3661_0,
            s_3661_1,
            s_3661_2,
            s_3661_3,
            s_3661_4,
            s_3661_5,
            s_3661_6,
        );
        // N s_3661_8: return
        return;
    }
    fn block_3662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3662_0: read-var opc2:u8
        let s_3662_0: u8 = fn_state.opc2;
        // D s_3662_1: cast zx s_3662_0 -> bv
        let s_3662_1: Bits = Bits::new(s_3662_0 as u128, 3u16);
        // C s_3662_2: const #5u : u8
        let s_3662_2: u8 = 5;
        // C s_3662_3: cast zx s_3662_2 -> bv
        let s_3662_3: Bits = Bits::new(s_3662_2 as u128, 3u16);
        // D s_3662_4: cmp-eq s_3662_1 s_3662_3
        let s_3662_4: bool = ((s_3662_1) == (s_3662_3));
        // D s_3662_5: write-var gs#119155 <= s_3662_4
        fn_state.gs_119155 = s_3662_4;
        // N s_3662_6: jump b3617
        return block_3617(state, tracer, fn_state);
    }
    fn block_3663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3663_0: read-var opc1:u8
        let s_3663_0: u8 = fn_state.opc1;
        // D s_3663_1: cast zx s_3663_0 -> bv
        let s_3663_1: Bits = Bits::new(s_3663_0 as u128, 3u16);
        // C s_3663_2: const #0u : u8
        let s_3663_2: u8 = 0;
        // C s_3663_3: cast zx s_3663_2 -> bv
        let s_3663_3: Bits = Bits::new(s_3663_2 as u128, 3u16);
        // D s_3663_4: cmp-eq s_3663_1 s_3663_3
        let s_3663_4: bool = ((s_3663_1) == (s_3663_3));
        // D s_3663_5: write-var gs#119154 <= s_3663_4
        fn_state.gs_119154 = s_3663_4;
        // N s_3663_6: jump b3615
        return block_3615(state, tracer, fn_state);
    }
    fn block_3664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3664_0: read-var coproc:u8
        let s_3664_0: u8 = fn_state.coproc;
        // D s_3664_1: cast zx s_3664_0 -> bv
        let s_3664_1: Bits = Bits::new(s_3664_0 as u128, 4u16);
        // C s_3664_2: const #15u : u8
        let s_3664_2: u8 = 15;
        // C s_3664_3: cast zx s_3664_2 -> bv
        let s_3664_3: Bits = Bits::new(s_3664_2 as u128, 4u16);
        // D s_3664_4: cmp-eq s_3664_1 s_3664_3
        let s_3664_4: bool = ((s_3664_1) == (s_3664_3));
        // D s_3664_5: write-var gs#119153 <= s_3664_4
        fn_state.gs_119153 = s_3664_4;
        // N s_3664_6: jump b3613
        return block_3613(state, tracer, fn_state);
    }
    fn block_3665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3665_0: read-var CRn:u8
        let s_3665_0: u8 = fn_state.CRn;
        // D s_3665_1: cast zx s_3665_0 -> bv
        let s_3665_1: Bits = Bits::new(s_3665_0 as u128, 4u16);
        // C s_3665_2: const #5u : u8
        let s_3665_2: u8 = 5;
        // C s_3665_3: cast zx s_3665_2 -> bv
        let s_3665_3: Bits = Bits::new(s_3665_2 as u128, 4u16);
        // D s_3665_4: cmp-eq s_3665_1 s_3665_3
        let s_3665_4: bool = ((s_3665_1) == (s_3665_3));
        // D s_3665_5: write-var gs#119152 <= s_3665_4
        fn_state.gs_119152 = s_3665_4;
        // N s_3665_6: jump b3611
        return block_3611(state, tracer, fn_state);
    }
    fn block_3666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3666_0: read-var el:u8
        let s_3666_0: u8 = fn_state.el;
        // D s_3666_1: read-var coproc:u8
        let s_3666_1: u8 = fn_state.coproc;
        // D s_3666_2: read-var opc1:u8
        let s_3666_2: u8 = fn_state.opc1;
        // D s_3666_3: read-var CRn:u8
        let s_3666_3: u8 = fn_state.CRn;
        // D s_3666_4: read-var opc2:u8
        let s_3666_4: u8 = fn_state.opc2;
        // D s_3666_5: read-var CRm:u8
        let s_3666_5: u8 = fn_state.CRm;
        // D s_3666_6: read-var t:i
        let s_3666_6: i128 = fn_state.t;
        // D s_3666_7: call ERXMISC7_SysRegRead32_99b78145ea2ea108(s_3666_0, s_3666_1, s_3666_2, s_3666_3, s_3666_4, s_3666_5, s_3666_6)
        let s_3666_7: () = ERXMISC7_SysRegRead32_99b78145ea2ea108(
            state,
            tracer,
            s_3666_0,
            s_3666_1,
            s_3666_2,
            s_3666_3,
            s_3666_4,
            s_3666_5,
            s_3666_6,
        );
        // N s_3666_8: return
        return;
    }
    fn block_3667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3667_0: read-var opc2:u8
        let s_3667_0: u8 = fn_state.opc2;
        // D s_3667_1: cast zx s_3667_0 -> bv
        let s_3667_1: Bits = Bits::new(s_3667_0 as u128, 3u16);
        // C s_3667_2: const #7u : u8
        let s_3667_2: u8 = 7;
        // C s_3667_3: cast zx s_3667_2 -> bv
        let s_3667_3: Bits = Bits::new(s_3667_2 as u128, 3u16);
        // D s_3667_4: cmp-eq s_3667_1 s_3667_3
        let s_3667_4: bool = ((s_3667_1) == (s_3667_3));
        // D s_3667_5: write-var gs#119151 <= s_3667_4
        fn_state.gs_119151 = s_3667_4;
        // N s_3667_6: jump b3608
        return block_3608(state, tracer, fn_state);
    }
    fn block_3668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3668_0: read-var opc1:u8
        let s_3668_0: u8 = fn_state.opc1;
        // D s_3668_1: cast zx s_3668_0 -> bv
        let s_3668_1: Bits = Bits::new(s_3668_0 as u128, 3u16);
        // C s_3668_2: const #0u : u8
        let s_3668_2: u8 = 0;
        // C s_3668_3: cast zx s_3668_2 -> bv
        let s_3668_3: Bits = Bits::new(s_3668_2 as u128, 3u16);
        // D s_3668_4: cmp-eq s_3668_1 s_3668_3
        let s_3668_4: bool = ((s_3668_1) == (s_3668_3));
        // D s_3668_5: write-var gs#119150 <= s_3668_4
        fn_state.gs_119150 = s_3668_4;
        // N s_3668_6: jump b3606
        return block_3606(state, tracer, fn_state);
    }
    fn block_3669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3669_0: read-var coproc:u8
        let s_3669_0: u8 = fn_state.coproc;
        // D s_3669_1: cast zx s_3669_0 -> bv
        let s_3669_1: Bits = Bits::new(s_3669_0 as u128, 4u16);
        // C s_3669_2: const #15u : u8
        let s_3669_2: u8 = 15;
        // C s_3669_3: cast zx s_3669_2 -> bv
        let s_3669_3: Bits = Bits::new(s_3669_2 as u128, 4u16);
        // D s_3669_4: cmp-eq s_3669_1 s_3669_3
        let s_3669_4: bool = ((s_3669_1) == (s_3669_3));
        // D s_3669_5: write-var gs#119149 <= s_3669_4
        fn_state.gs_119149 = s_3669_4;
        // N s_3669_6: jump b3604
        return block_3604(state, tracer, fn_state);
    }
    fn block_3670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3670_0: read-var CRn:u8
        let s_3670_0: u8 = fn_state.CRn;
        // D s_3670_1: cast zx s_3670_0 -> bv
        let s_3670_1: Bits = Bits::new(s_3670_0 as u128, 4u16);
        // C s_3670_2: const #5u : u8
        let s_3670_2: u8 = 5;
        // C s_3670_3: cast zx s_3670_2 -> bv
        let s_3670_3: Bits = Bits::new(s_3670_2 as u128, 4u16);
        // D s_3670_4: cmp-eq s_3670_1 s_3670_3
        let s_3670_4: bool = ((s_3670_1) == (s_3670_3));
        // D s_3670_5: write-var gs#119148 <= s_3670_4
        fn_state.gs_119148 = s_3670_4;
        // N s_3670_6: jump b3602
        return block_3602(state, tracer, fn_state);
    }
    fn block_3671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3671_0: read-var el:u8
        let s_3671_0: u8 = fn_state.el;
        // D s_3671_1: read-var coproc:u8
        let s_3671_1: u8 = fn_state.coproc;
        // D s_3671_2: read-var opc1:u8
        let s_3671_2: u8 = fn_state.opc1;
        // D s_3671_3: read-var CRn:u8
        let s_3671_3: u8 = fn_state.CRn;
        // D s_3671_4: read-var opc2:u8
        let s_3671_4: u8 = fn_state.opc2;
        // D s_3671_5: read-var CRm:u8
        let s_3671_5: u8 = fn_state.CRm;
        // D s_3671_6: read-var t:i
        let s_3671_6: i128 = fn_state.t;
        // D s_3671_7: call ERXADDR2_SysRegRead32_ee8844bbda44b8b3(s_3671_0, s_3671_1, s_3671_2, s_3671_3, s_3671_4, s_3671_5, s_3671_6)
        let s_3671_7: () = ERXADDR2_SysRegRead32_ee8844bbda44b8b3(
            state,
            tracer,
            s_3671_0,
            s_3671_1,
            s_3671_2,
            s_3671_3,
            s_3671_4,
            s_3671_5,
            s_3671_6,
        );
        // N s_3671_8: return
        return;
    }
    fn block_3672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3672_0: read-var opc2:u8
        let s_3672_0: u8 = fn_state.opc2;
        // D s_3672_1: cast zx s_3672_0 -> bv
        let s_3672_1: Bits = Bits::new(s_3672_0 as u128, 3u16);
        // C s_3672_2: const #7u : u8
        let s_3672_2: u8 = 7;
        // C s_3672_3: cast zx s_3672_2 -> bv
        let s_3672_3: Bits = Bits::new(s_3672_2 as u128, 3u16);
        // D s_3672_4: cmp-eq s_3672_1 s_3672_3
        let s_3672_4: bool = ((s_3672_1) == (s_3672_3));
        // D s_3672_5: write-var gs#119147 <= s_3672_4
        fn_state.gs_119147 = s_3672_4;
        // N s_3672_6: jump b3599
        return block_3599(state, tracer, fn_state);
    }
    fn block_3673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3673_0: read-var opc1:u8
        let s_3673_0: u8 = fn_state.opc1;
        // D s_3673_1: cast zx s_3673_0 -> bv
        let s_3673_1: Bits = Bits::new(s_3673_0 as u128, 3u16);
        // C s_3673_2: const #0u : u8
        let s_3673_2: u8 = 0;
        // C s_3673_3: cast zx s_3673_2 -> bv
        let s_3673_3: Bits = Bits::new(s_3673_2 as u128, 3u16);
        // D s_3673_4: cmp-eq s_3673_1 s_3673_3
        let s_3673_4: bool = ((s_3673_1) == (s_3673_3));
        // D s_3673_5: write-var gs#119146 <= s_3673_4
        fn_state.gs_119146 = s_3673_4;
        // N s_3673_6: jump b3597
        return block_3597(state, tracer, fn_state);
    }
    fn block_3674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3674_0: read-var coproc:u8
        let s_3674_0: u8 = fn_state.coproc;
        // D s_3674_1: cast zx s_3674_0 -> bv
        let s_3674_1: Bits = Bits::new(s_3674_0 as u128, 4u16);
        // C s_3674_2: const #15u : u8
        let s_3674_2: u8 = 15;
        // C s_3674_3: cast zx s_3674_2 -> bv
        let s_3674_3: Bits = Bits::new(s_3674_2 as u128, 4u16);
        // D s_3674_4: cmp-eq s_3674_1 s_3674_3
        let s_3674_4: bool = ((s_3674_1) == (s_3674_3));
        // D s_3674_5: write-var gs#119145 <= s_3674_4
        fn_state.gs_119145 = s_3674_4;
        // N s_3674_6: jump b3595
        return block_3595(state, tracer, fn_state);
    }
    fn block_3675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3675_0: read-var CRn:u8
        let s_3675_0: u8 = fn_state.CRn;
        // D s_3675_1: cast zx s_3675_0 -> bv
        let s_3675_1: Bits = Bits::new(s_3675_0 as u128, 4u16);
        // C s_3675_2: const #5u : u8
        let s_3675_2: u8 = 5;
        // C s_3675_3: cast zx s_3675_2 -> bv
        let s_3675_3: Bits = Bits::new(s_3675_2 as u128, 4u16);
        // D s_3675_4: cmp-eq s_3675_1 s_3675_3
        let s_3675_4: bool = ((s_3675_1) == (s_3675_3));
        // D s_3675_5: write-var gs#119144 <= s_3675_4
        fn_state.gs_119144 = s_3675_4;
        // N s_3675_6: jump b3593
        return block_3593(state, tracer, fn_state);
    }
    fn block_3676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3676_0: read-var el:u8
        let s_3676_0: u8 = fn_state.el;
        // D s_3676_1: read-var coproc:u8
        let s_3676_1: u8 = fn_state.coproc;
        // D s_3676_2: read-var opc1:u8
        let s_3676_2: u8 = fn_state.opc1;
        // D s_3676_3: read-var CRn:u8
        let s_3676_3: u8 = fn_state.CRn;
        // D s_3676_4: read-var opc2:u8
        let s_3676_4: u8 = fn_state.opc2;
        // D s_3676_5: read-var CRm:u8
        let s_3676_5: u8 = fn_state.CRm;
        // D s_3676_6: read-var t:i
        let s_3676_6: i128 = fn_state.t;
        // D s_3676_7: call ERXMISC4_SysRegRead32_6139ba68e2078794(s_3676_0, s_3676_1, s_3676_2, s_3676_3, s_3676_4, s_3676_5, s_3676_6)
        let s_3676_7: () = ERXMISC4_SysRegRead32_6139ba68e2078794(
            state,
            tracer,
            s_3676_0,
            s_3676_1,
            s_3676_2,
            s_3676_3,
            s_3676_4,
            s_3676_5,
            s_3676_6,
        );
        // N s_3676_8: return
        return;
    }
    fn block_3677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3677_0: read-var opc2:u8
        let s_3677_0: u8 = fn_state.opc2;
        // D s_3677_1: cast zx s_3677_0 -> bv
        let s_3677_1: Bits = Bits::new(s_3677_0 as u128, 3u16);
        // C s_3677_2: const #2u : u8
        let s_3677_2: u8 = 2;
        // C s_3677_3: cast zx s_3677_2 -> bv
        let s_3677_3: Bits = Bits::new(s_3677_2 as u128, 3u16);
        // D s_3677_4: cmp-eq s_3677_1 s_3677_3
        let s_3677_4: bool = ((s_3677_1) == (s_3677_3));
        // D s_3677_5: write-var gs#119143 <= s_3677_4
        fn_state.gs_119143 = s_3677_4;
        // N s_3677_6: jump b3590
        return block_3590(state, tracer, fn_state);
    }
    fn block_3678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3678_0: read-var opc1:u8
        let s_3678_0: u8 = fn_state.opc1;
        // D s_3678_1: cast zx s_3678_0 -> bv
        let s_3678_1: Bits = Bits::new(s_3678_0 as u128, 3u16);
        // C s_3678_2: const #0u : u8
        let s_3678_2: u8 = 0;
        // C s_3678_3: cast zx s_3678_2 -> bv
        let s_3678_3: Bits = Bits::new(s_3678_2 as u128, 3u16);
        // D s_3678_4: cmp-eq s_3678_1 s_3678_3
        let s_3678_4: bool = ((s_3678_1) == (s_3678_3));
        // D s_3678_5: write-var gs#119142 <= s_3678_4
        fn_state.gs_119142 = s_3678_4;
        // N s_3678_6: jump b3588
        return block_3588(state, tracer, fn_state);
    }
    fn block_3679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3679_0: read-var coproc:u8
        let s_3679_0: u8 = fn_state.coproc;
        // D s_3679_1: cast zx s_3679_0 -> bv
        let s_3679_1: Bits = Bits::new(s_3679_0 as u128, 4u16);
        // C s_3679_2: const #15u : u8
        let s_3679_2: u8 = 15;
        // C s_3679_3: cast zx s_3679_2 -> bv
        let s_3679_3: Bits = Bits::new(s_3679_2 as u128, 4u16);
        // D s_3679_4: cmp-eq s_3679_1 s_3679_3
        let s_3679_4: bool = ((s_3679_1) == (s_3679_3));
        // D s_3679_5: write-var gs#119141 <= s_3679_4
        fn_state.gs_119141 = s_3679_4;
        // N s_3679_6: jump b3586
        return block_3586(state, tracer, fn_state);
    }
    fn block_3680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3680_0: read-var CRn:u8
        let s_3680_0: u8 = fn_state.CRn;
        // D s_3680_1: cast zx s_3680_0 -> bv
        let s_3680_1: Bits = Bits::new(s_3680_0 as u128, 4u16);
        // C s_3680_2: const #5u : u8
        let s_3680_2: u8 = 5;
        // C s_3680_3: cast zx s_3680_2 -> bv
        let s_3680_3: Bits = Bits::new(s_3680_2 as u128, 4u16);
        // D s_3680_4: cmp-eq s_3680_1 s_3680_3
        let s_3680_4: bool = ((s_3680_1) == (s_3680_3));
        // D s_3680_5: write-var gs#119140 <= s_3680_4
        fn_state.gs_119140 = s_3680_4;
        // N s_3680_6: jump b3584
        return block_3584(state, tracer, fn_state);
    }
    fn block_3681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3681_0: read-var el:u8
        let s_3681_0: u8 = fn_state.el;
        // D s_3681_1: read-var coproc:u8
        let s_3681_1: u8 = fn_state.coproc;
        // D s_3681_2: read-var opc1:u8
        let s_3681_2: u8 = fn_state.opc1;
        // D s_3681_3: read-var CRn:u8
        let s_3681_3: u8 = fn_state.CRn;
        // D s_3681_4: read-var opc2:u8
        let s_3681_4: u8 = fn_state.opc2;
        // D s_3681_5: read-var CRm:u8
        let s_3681_5: u8 = fn_state.CRm;
        // D s_3681_6: read-var t:i
        let s_3681_6: i128 = fn_state.t;
        // D s_3681_7: call ERXMISC6_SysRegRead32_9abf31f5358e2067(s_3681_0, s_3681_1, s_3681_2, s_3681_3, s_3681_4, s_3681_5, s_3681_6)
        let s_3681_7: () = ERXMISC6_SysRegRead32_9abf31f5358e2067(
            state,
            tracer,
            s_3681_0,
            s_3681_1,
            s_3681_2,
            s_3681_3,
            s_3681_4,
            s_3681_5,
            s_3681_6,
        );
        // N s_3681_8: return
        return;
    }
    fn block_3682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3682_0: read-var opc2:u8
        let s_3682_0: u8 = fn_state.opc2;
        // D s_3682_1: cast zx s_3682_0 -> bv
        let s_3682_1: Bits = Bits::new(s_3682_0 as u128, 3u16);
        // C s_3682_2: const #6u : u8
        let s_3682_2: u8 = 6;
        // C s_3682_3: cast zx s_3682_2 -> bv
        let s_3682_3: Bits = Bits::new(s_3682_2 as u128, 3u16);
        // D s_3682_4: cmp-eq s_3682_1 s_3682_3
        let s_3682_4: bool = ((s_3682_1) == (s_3682_3));
        // D s_3682_5: write-var gs#119139 <= s_3682_4
        fn_state.gs_119139 = s_3682_4;
        // N s_3682_6: jump b3581
        return block_3581(state, tracer, fn_state);
    }
    fn block_3683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3683_0: read-var opc1:u8
        let s_3683_0: u8 = fn_state.opc1;
        // D s_3683_1: cast zx s_3683_0 -> bv
        let s_3683_1: Bits = Bits::new(s_3683_0 as u128, 3u16);
        // C s_3683_2: const #0u : u8
        let s_3683_2: u8 = 0;
        // C s_3683_3: cast zx s_3683_2 -> bv
        let s_3683_3: Bits = Bits::new(s_3683_2 as u128, 3u16);
        // D s_3683_4: cmp-eq s_3683_1 s_3683_3
        let s_3683_4: bool = ((s_3683_1) == (s_3683_3));
        // D s_3683_5: write-var gs#119138 <= s_3683_4
        fn_state.gs_119138 = s_3683_4;
        // N s_3683_6: jump b3579
        return block_3579(state, tracer, fn_state);
    }
    fn block_3684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3684_0: read-var coproc:u8
        let s_3684_0: u8 = fn_state.coproc;
        // D s_3684_1: cast zx s_3684_0 -> bv
        let s_3684_1: Bits = Bits::new(s_3684_0 as u128, 4u16);
        // C s_3684_2: const #15u : u8
        let s_3684_2: u8 = 15;
        // C s_3684_3: cast zx s_3684_2 -> bv
        let s_3684_3: Bits = Bits::new(s_3684_2 as u128, 4u16);
        // D s_3684_4: cmp-eq s_3684_1 s_3684_3
        let s_3684_4: bool = ((s_3684_1) == (s_3684_3));
        // D s_3684_5: write-var gs#119137 <= s_3684_4
        fn_state.gs_119137 = s_3684_4;
        // N s_3684_6: jump b3577
        return block_3577(state, tracer, fn_state);
    }
    fn block_3685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3685_0: read-var CRn:u8
        let s_3685_0: u8 = fn_state.CRn;
        // D s_3685_1: cast zx s_3685_0 -> bv
        let s_3685_1: Bits = Bits::new(s_3685_0 as u128, 4u16);
        // C s_3685_2: const #5u : u8
        let s_3685_2: u8 = 5;
        // C s_3685_3: cast zx s_3685_2 -> bv
        let s_3685_3: Bits = Bits::new(s_3685_2 as u128, 4u16);
        // D s_3685_4: cmp-eq s_3685_1 s_3685_3
        let s_3685_4: bool = ((s_3685_1) == (s_3685_3));
        // D s_3685_5: write-var gs#119136 <= s_3685_4
        fn_state.gs_119136 = s_3685_4;
        // N s_3685_6: jump b3575
        return block_3575(state, tracer, fn_state);
    }
    fn block_3686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3686_0: read-var el:u8
        let s_3686_0: u8 = fn_state.el;
        // D s_3686_1: read-var coproc:u8
        let s_3686_1: u8 = fn_state.coproc;
        // D s_3686_2: read-var opc1:u8
        let s_3686_2: u8 = fn_state.opc1;
        // D s_3686_3: read-var CRn:u8
        let s_3686_3: u8 = fn_state.CRn;
        // D s_3686_4: read-var opc2:u8
        let s_3686_4: u8 = fn_state.opc2;
        // D s_3686_5: read-var CRm:u8
        let s_3686_5: u8 = fn_state.CRm;
        // D s_3686_6: read-var t:i
        let s_3686_6: i128 = fn_state.t;
        // D s_3686_7: call ERXCTLR_SysRegRead32_223464c9a84e4bc3(s_3686_0, s_3686_1, s_3686_2, s_3686_3, s_3686_4, s_3686_5, s_3686_6)
        let s_3686_7: () = ERXCTLR_SysRegRead32_223464c9a84e4bc3(
            state,
            tracer,
            s_3686_0,
            s_3686_1,
            s_3686_2,
            s_3686_3,
            s_3686_4,
            s_3686_5,
            s_3686_6,
        );
        // N s_3686_8: return
        return;
    }
    fn block_3687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3687_0: read-var opc2:u8
        let s_3687_0: u8 = fn_state.opc2;
        // D s_3687_1: cast zx s_3687_0 -> bv
        let s_3687_1: Bits = Bits::new(s_3687_0 as u128, 3u16);
        // C s_3687_2: const #1u : u8
        let s_3687_2: u8 = 1;
        // C s_3687_3: cast zx s_3687_2 -> bv
        let s_3687_3: Bits = Bits::new(s_3687_2 as u128, 3u16);
        // D s_3687_4: cmp-eq s_3687_1 s_3687_3
        let s_3687_4: bool = ((s_3687_1) == (s_3687_3));
        // D s_3687_5: write-var gs#119135 <= s_3687_4
        fn_state.gs_119135 = s_3687_4;
        // N s_3687_6: jump b3572
        return block_3572(state, tracer, fn_state);
    }
    fn block_3688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3688_0: read-var opc1:u8
        let s_3688_0: u8 = fn_state.opc1;
        // D s_3688_1: cast zx s_3688_0 -> bv
        let s_3688_1: Bits = Bits::new(s_3688_0 as u128, 3u16);
        // C s_3688_2: const #0u : u8
        let s_3688_2: u8 = 0;
        // C s_3688_3: cast zx s_3688_2 -> bv
        let s_3688_3: Bits = Bits::new(s_3688_2 as u128, 3u16);
        // D s_3688_4: cmp-eq s_3688_1 s_3688_3
        let s_3688_4: bool = ((s_3688_1) == (s_3688_3));
        // D s_3688_5: write-var gs#119134 <= s_3688_4
        fn_state.gs_119134 = s_3688_4;
        // N s_3688_6: jump b3570
        return block_3570(state, tracer, fn_state);
    }
    fn block_3689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3689_0: read-var coproc:u8
        let s_3689_0: u8 = fn_state.coproc;
        // D s_3689_1: cast zx s_3689_0 -> bv
        let s_3689_1: Bits = Bits::new(s_3689_0 as u128, 4u16);
        // C s_3689_2: const #15u : u8
        let s_3689_2: u8 = 15;
        // C s_3689_3: cast zx s_3689_2 -> bv
        let s_3689_3: Bits = Bits::new(s_3689_2 as u128, 4u16);
        // D s_3689_4: cmp-eq s_3689_1 s_3689_3
        let s_3689_4: bool = ((s_3689_1) == (s_3689_3));
        // D s_3689_5: write-var gs#119133 <= s_3689_4
        fn_state.gs_119133 = s_3689_4;
        // N s_3689_6: jump b3568
        return block_3568(state, tracer, fn_state);
    }
    fn block_3690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3690_0: read-var CRn:u8
        let s_3690_0: u8 = fn_state.CRn;
        // D s_3690_1: cast zx s_3690_0 -> bv
        let s_3690_1: Bits = Bits::new(s_3690_0 as u128, 4u16);
        // C s_3690_2: const #5u : u8
        let s_3690_2: u8 = 5;
        // C s_3690_3: cast zx s_3690_2 -> bv
        let s_3690_3: Bits = Bits::new(s_3690_2 as u128, 4u16);
        // D s_3690_4: cmp-eq s_3690_1 s_3690_3
        let s_3690_4: bool = ((s_3690_1) == (s_3690_3));
        // D s_3690_5: write-var gs#119132 <= s_3690_4
        fn_state.gs_119132 = s_3690_4;
        // N s_3690_6: jump b3566
        return block_3566(state, tracer, fn_state);
    }
    fn block_3691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3691_0: read-var el:u8
        let s_3691_0: u8 = fn_state.el;
        // D s_3691_1: read-var coproc:u8
        let s_3691_1: u8 = fn_state.coproc;
        // D s_3691_2: read-var opc1:u8
        let s_3691_2: u8 = fn_state.opc1;
        // D s_3691_3: read-var CRn:u8
        let s_3691_3: u8 = fn_state.CRn;
        // D s_3691_4: read-var opc2:u8
        let s_3691_4: u8 = fn_state.opc2;
        // D s_3691_5: read-var CRm:u8
        let s_3691_5: u8 = fn_state.CRm;
        // D s_3691_6: read-var t:i
        let s_3691_6: i128 = fn_state.t;
        // D s_3691_7: call ERXMISC1_SysRegRead32_24c39414a2e1d0b1(s_3691_0, s_3691_1, s_3691_2, s_3691_3, s_3691_4, s_3691_5, s_3691_6)
        let s_3691_7: () = ERXMISC1_SysRegRead32_24c39414a2e1d0b1(
            state,
            tracer,
            s_3691_0,
            s_3691_1,
            s_3691_2,
            s_3691_3,
            s_3691_4,
            s_3691_5,
            s_3691_6,
        );
        // N s_3691_8: return
        return;
    }
    fn block_3692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3692_0: read-var opc2:u8
        let s_3692_0: u8 = fn_state.opc2;
        // D s_3692_1: cast zx s_3692_0 -> bv
        let s_3692_1: Bits = Bits::new(s_3692_0 as u128, 3u16);
        // C s_3692_2: const #1u : u8
        let s_3692_2: u8 = 1;
        // C s_3692_3: cast zx s_3692_2 -> bv
        let s_3692_3: Bits = Bits::new(s_3692_2 as u128, 3u16);
        // D s_3692_4: cmp-eq s_3692_1 s_3692_3
        let s_3692_4: bool = ((s_3692_1) == (s_3692_3));
        // D s_3692_5: write-var gs#119131 <= s_3692_4
        fn_state.gs_119131 = s_3692_4;
        // N s_3692_6: jump b3563
        return block_3563(state, tracer, fn_state);
    }
    fn block_3693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3693_0: read-var opc1:u8
        let s_3693_0: u8 = fn_state.opc1;
        // D s_3693_1: cast zx s_3693_0 -> bv
        let s_3693_1: Bits = Bits::new(s_3693_0 as u128, 3u16);
        // C s_3693_2: const #0u : u8
        let s_3693_2: u8 = 0;
        // C s_3693_3: cast zx s_3693_2 -> bv
        let s_3693_3: Bits = Bits::new(s_3693_2 as u128, 3u16);
        // D s_3693_4: cmp-eq s_3693_1 s_3693_3
        let s_3693_4: bool = ((s_3693_1) == (s_3693_3));
        // D s_3693_5: write-var gs#119130 <= s_3693_4
        fn_state.gs_119130 = s_3693_4;
        // N s_3693_6: jump b3561
        return block_3561(state, tracer, fn_state);
    }
    fn block_3694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3694_0: read-var coproc:u8
        let s_3694_0: u8 = fn_state.coproc;
        // D s_3694_1: cast zx s_3694_0 -> bv
        let s_3694_1: Bits = Bits::new(s_3694_0 as u128, 4u16);
        // C s_3694_2: const #15u : u8
        let s_3694_2: u8 = 15;
        // C s_3694_3: cast zx s_3694_2 -> bv
        let s_3694_3: Bits = Bits::new(s_3694_2 as u128, 4u16);
        // D s_3694_4: cmp-eq s_3694_1 s_3694_3
        let s_3694_4: bool = ((s_3694_1) == (s_3694_3));
        // D s_3694_5: write-var gs#119129 <= s_3694_4
        fn_state.gs_119129 = s_3694_4;
        // N s_3694_6: jump b3559
        return block_3559(state, tracer, fn_state);
    }
    fn block_3695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3695_0: read-var CRn:u8
        let s_3695_0: u8 = fn_state.CRn;
        // D s_3695_1: cast zx s_3695_0 -> bv
        let s_3695_1: Bits = Bits::new(s_3695_0 as u128, 4u16);
        // C s_3695_2: const #5u : u8
        let s_3695_2: u8 = 5;
        // C s_3695_3: cast zx s_3695_2 -> bv
        let s_3695_3: Bits = Bits::new(s_3695_2 as u128, 4u16);
        // D s_3695_4: cmp-eq s_3695_1 s_3695_3
        let s_3695_4: bool = ((s_3695_1) == (s_3695_3));
        // D s_3695_5: write-var gs#119128 <= s_3695_4
        fn_state.gs_119128 = s_3695_4;
        // N s_3695_6: jump b3557
        return block_3557(state, tracer, fn_state);
    }
    fn block_3696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3696_0: read-var el:u8
        let s_3696_0: u8 = fn_state.el;
        // D s_3696_1: read-var coproc:u8
        let s_3696_1: u8 = fn_state.coproc;
        // D s_3696_2: read-var opc1:u8
        let s_3696_2: u8 = fn_state.opc1;
        // D s_3696_3: read-var CRn:u8
        let s_3696_3: u8 = fn_state.CRn;
        // D s_3696_4: read-var opc2:u8
        let s_3696_4: u8 = fn_state.opc2;
        // D s_3696_5: read-var CRm:u8
        let s_3696_5: u8 = fn_state.CRm;
        // D s_3696_6: read-var t:i
        let s_3696_6: i128 = fn_state.t;
        // D s_3696_7: call VDFSR_SysRegRead32_0530b84beb618cd2(s_3696_0, s_3696_1, s_3696_2, s_3696_3, s_3696_4, s_3696_5, s_3696_6)
        let s_3696_7: () = VDFSR_SysRegRead32_0530b84beb618cd2(
            state,
            tracer,
            s_3696_0,
            s_3696_1,
            s_3696_2,
            s_3696_3,
            s_3696_4,
            s_3696_5,
            s_3696_6,
        );
        // N s_3696_8: return
        return;
    }
    fn block_3697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3697_0: read-var opc2:u8
        let s_3697_0: u8 = fn_state.opc2;
        // D s_3697_1: cast zx s_3697_0 -> bv
        let s_3697_1: Bits = Bits::new(s_3697_0 as u128, 3u16);
        // C s_3697_2: const #3u : u8
        let s_3697_2: u8 = 3;
        // C s_3697_3: cast zx s_3697_2 -> bv
        let s_3697_3: Bits = Bits::new(s_3697_2 as u128, 3u16);
        // D s_3697_4: cmp-eq s_3697_1 s_3697_3
        let s_3697_4: bool = ((s_3697_1) == (s_3697_3));
        // D s_3697_5: write-var gs#119127 <= s_3697_4
        fn_state.gs_119127 = s_3697_4;
        // N s_3697_6: jump b3554
        return block_3554(state, tracer, fn_state);
    }
    fn block_3698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3698_0: read-var opc1:u8
        let s_3698_0: u8 = fn_state.opc1;
        // D s_3698_1: cast zx s_3698_0 -> bv
        let s_3698_1: Bits = Bits::new(s_3698_0 as u128, 3u16);
        // C s_3698_2: const #4u : u8
        let s_3698_2: u8 = 4;
        // C s_3698_3: cast zx s_3698_2 -> bv
        let s_3698_3: Bits = Bits::new(s_3698_2 as u128, 3u16);
        // D s_3698_4: cmp-eq s_3698_1 s_3698_3
        let s_3698_4: bool = ((s_3698_1) == (s_3698_3));
        // D s_3698_5: write-var gs#119126 <= s_3698_4
        fn_state.gs_119126 = s_3698_4;
        // N s_3698_6: jump b3552
        return block_3552(state, tracer, fn_state);
    }
    fn block_3699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3699_0: read-var coproc:u8
        let s_3699_0: u8 = fn_state.coproc;
        // D s_3699_1: cast zx s_3699_0 -> bv
        let s_3699_1: Bits = Bits::new(s_3699_0 as u128, 4u16);
        // C s_3699_2: const #15u : u8
        let s_3699_2: u8 = 15;
        // C s_3699_3: cast zx s_3699_2 -> bv
        let s_3699_3: Bits = Bits::new(s_3699_2 as u128, 4u16);
        // D s_3699_4: cmp-eq s_3699_1 s_3699_3
        let s_3699_4: bool = ((s_3699_1) == (s_3699_3));
        // D s_3699_5: write-var gs#119125 <= s_3699_4
        fn_state.gs_119125 = s_3699_4;
        // N s_3699_6: jump b3550
        return block_3550(state, tracer, fn_state);
    }
    fn block_3700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3700_0: read-var CRn:u8
        let s_3700_0: u8 = fn_state.CRn;
        // D s_3700_1: cast zx s_3700_0 -> bv
        let s_3700_1: Bits = Bits::new(s_3700_0 as u128, 4u16);
        // C s_3700_2: const #5u : u8
        let s_3700_2: u8 = 5;
        // C s_3700_3: cast zx s_3700_2 -> bv
        let s_3700_3: Bits = Bits::new(s_3700_2 as u128, 4u16);
        // D s_3700_4: cmp-eq s_3700_1 s_3700_3
        let s_3700_4: bool = ((s_3700_1) == (s_3700_3));
        // D s_3700_5: write-var gs#119124 <= s_3700_4
        fn_state.gs_119124 = s_3700_4;
        // N s_3700_6: jump b3548
        return block_3548(state, tracer, fn_state);
    }
    fn block_3701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3701_0: read-var el:u8
        let s_3701_0: u8 = fn_state.el;
        // D s_3701_1: read-var coproc:u8
        let s_3701_1: u8 = fn_state.coproc;
        // D s_3701_2: read-var opc1:u8
        let s_3701_2: u8 = fn_state.opc1;
        // D s_3701_3: read-var CRn:u8
        let s_3701_3: u8 = fn_state.CRn;
        // D s_3701_4: read-var opc2:u8
        let s_3701_4: u8 = fn_state.opc2;
        // D s_3701_5: read-var CRm:u8
        let s_3701_5: u8 = fn_state.CRm;
        // D s_3701_6: read-var t:i
        let s_3701_6: i128 = fn_state.t;
        // D s_3701_7: call DISR_SysRegRead32_9f42ad0cc10a5f19(s_3701_0, s_3701_1, s_3701_2, s_3701_3, s_3701_4, s_3701_5, s_3701_6)
        let s_3701_7: () = DISR_SysRegRead32_9f42ad0cc10a5f19(
            state,
            tracer,
            s_3701_0,
            s_3701_1,
            s_3701_2,
            s_3701_3,
            s_3701_4,
            s_3701_5,
            s_3701_6,
        );
        // N s_3701_8: return
        return;
    }
    fn block_3702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3702_0: read-var opc2:u8
        let s_3702_0: u8 = fn_state.opc2;
        // D s_3702_1: cast zx s_3702_0 -> bv
        let s_3702_1: Bits = Bits::new(s_3702_0 as u128, 3u16);
        // C s_3702_2: const #1u : u8
        let s_3702_2: u8 = 1;
        // C s_3702_3: cast zx s_3702_2 -> bv
        let s_3702_3: Bits = Bits::new(s_3702_2 as u128, 3u16);
        // D s_3702_4: cmp-eq s_3702_1 s_3702_3
        let s_3702_4: bool = ((s_3702_1) == (s_3702_3));
        // D s_3702_5: write-var gs#119123 <= s_3702_4
        fn_state.gs_119123 = s_3702_4;
        // N s_3702_6: jump b3545
        return block_3545(state, tracer, fn_state);
    }
    fn block_3703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3703_0: read-var opc1:u8
        let s_3703_0: u8 = fn_state.opc1;
        // D s_3703_1: cast zx s_3703_0 -> bv
        let s_3703_1: Bits = Bits::new(s_3703_0 as u128, 3u16);
        // C s_3703_2: const #0u : u8
        let s_3703_2: u8 = 0;
        // C s_3703_3: cast zx s_3703_2 -> bv
        let s_3703_3: Bits = Bits::new(s_3703_2 as u128, 3u16);
        // D s_3703_4: cmp-eq s_3703_1 s_3703_3
        let s_3703_4: bool = ((s_3703_1) == (s_3703_3));
        // D s_3703_5: write-var gs#119122 <= s_3703_4
        fn_state.gs_119122 = s_3703_4;
        // N s_3703_6: jump b3543
        return block_3543(state, tracer, fn_state);
    }
    fn block_3704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3704_0: read-var coproc:u8
        let s_3704_0: u8 = fn_state.coproc;
        // D s_3704_1: cast zx s_3704_0 -> bv
        let s_3704_1: Bits = Bits::new(s_3704_0 as u128, 4u16);
        // C s_3704_2: const #15u : u8
        let s_3704_2: u8 = 15;
        // C s_3704_3: cast zx s_3704_2 -> bv
        let s_3704_3: Bits = Bits::new(s_3704_2 as u128, 4u16);
        // D s_3704_4: cmp-eq s_3704_1 s_3704_3
        let s_3704_4: bool = ((s_3704_1) == (s_3704_3));
        // D s_3704_5: write-var gs#119121 <= s_3704_4
        fn_state.gs_119121 = s_3704_4;
        // N s_3704_6: jump b3541
        return block_3541(state, tracer, fn_state);
    }
    fn block_3705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3705_0: read-var CRn:u8
        let s_3705_0: u8 = fn_state.CRn;
        // D s_3705_1: cast zx s_3705_0 -> bv
        let s_3705_1: Bits = Bits::new(s_3705_0 as u128, 4u16);
        // C s_3705_2: const #12u : u8
        let s_3705_2: u8 = 12;
        // C s_3705_3: cast zx s_3705_2 -> bv
        let s_3705_3: Bits = Bits::new(s_3705_2 as u128, 4u16);
        // D s_3705_4: cmp-eq s_3705_1 s_3705_3
        let s_3705_4: bool = ((s_3705_1) == (s_3705_3));
        // D s_3705_5: write-var gs#119120 <= s_3705_4
        fn_state.gs_119120 = s_3705_4;
        // N s_3705_6: jump b3539
        return block_3539(state, tracer, fn_state);
    }
    fn block_3706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3706_0: read-var el:u8
        let s_3706_0: u8 = fn_state.el;
        // D s_3706_1: read-var coproc:u8
        let s_3706_1: u8 = fn_state.coproc;
        // D s_3706_2: read-var opc1:u8
        let s_3706_2: u8 = fn_state.opc1;
        // D s_3706_3: read-var CRn:u8
        let s_3706_3: u8 = fn_state.CRn;
        // D s_3706_4: read-var opc2:u8
        let s_3706_4: u8 = fn_state.opc2;
        // D s_3706_5: read-var CRm:u8
        let s_3706_5: u8 = fn_state.CRm;
        // D s_3706_6: read-var t:i
        let s_3706_6: i128 = fn_state.t;
        // D s_3706_7: call ERXCTLR2_SysRegRead32_538545d1d2bef52f(s_3706_0, s_3706_1, s_3706_2, s_3706_3, s_3706_4, s_3706_5, s_3706_6)
        let s_3706_7: () = ERXCTLR2_SysRegRead32_538545d1d2bef52f(
            state,
            tracer,
            s_3706_0,
            s_3706_1,
            s_3706_2,
            s_3706_3,
            s_3706_4,
            s_3706_5,
            s_3706_6,
        );
        // N s_3706_8: return
        return;
    }
    fn block_3707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3707_0: read-var opc2:u8
        let s_3707_0: u8 = fn_state.opc2;
        // D s_3707_1: cast zx s_3707_0 -> bv
        let s_3707_1: Bits = Bits::new(s_3707_0 as u128, 3u16);
        // C s_3707_2: const #5u : u8
        let s_3707_2: u8 = 5;
        // C s_3707_3: cast zx s_3707_2 -> bv
        let s_3707_3: Bits = Bits::new(s_3707_2 as u128, 3u16);
        // D s_3707_4: cmp-eq s_3707_1 s_3707_3
        let s_3707_4: bool = ((s_3707_1) == (s_3707_3));
        // D s_3707_5: write-var gs#119119 <= s_3707_4
        fn_state.gs_119119 = s_3707_4;
        // N s_3707_6: jump b3536
        return block_3536(state, tracer, fn_state);
    }
    fn block_3708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3708_0: read-var opc1:u8
        let s_3708_0: u8 = fn_state.opc1;
        // D s_3708_1: cast zx s_3708_0 -> bv
        let s_3708_1: Bits = Bits::new(s_3708_0 as u128, 3u16);
        // C s_3708_2: const #0u : u8
        let s_3708_2: u8 = 0;
        // C s_3708_3: cast zx s_3708_2 -> bv
        let s_3708_3: Bits = Bits::new(s_3708_2 as u128, 3u16);
        // D s_3708_4: cmp-eq s_3708_1 s_3708_3
        let s_3708_4: bool = ((s_3708_1) == (s_3708_3));
        // D s_3708_5: write-var gs#119118 <= s_3708_4
        fn_state.gs_119118 = s_3708_4;
        // N s_3708_6: jump b3534
        return block_3534(state, tracer, fn_state);
    }
    fn block_3709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3709_0: read-var coproc:u8
        let s_3709_0: u8 = fn_state.coproc;
        // D s_3709_1: cast zx s_3709_0 -> bv
        let s_3709_1: Bits = Bits::new(s_3709_0 as u128, 4u16);
        // C s_3709_2: const #15u : u8
        let s_3709_2: u8 = 15;
        // C s_3709_3: cast zx s_3709_2 -> bv
        let s_3709_3: Bits = Bits::new(s_3709_2 as u128, 4u16);
        // D s_3709_4: cmp-eq s_3709_1 s_3709_3
        let s_3709_4: bool = ((s_3709_1) == (s_3709_3));
        // D s_3709_5: write-var gs#119117 <= s_3709_4
        fn_state.gs_119117 = s_3709_4;
        // N s_3709_6: jump b3532
        return block_3532(state, tracer, fn_state);
    }
    fn block_3710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3710_0: read-var CRn:u8
        let s_3710_0: u8 = fn_state.CRn;
        // D s_3710_1: cast zx s_3710_0 -> bv
        let s_3710_1: Bits = Bits::new(s_3710_0 as u128, 4u16);
        // C s_3710_2: const #5u : u8
        let s_3710_2: u8 = 5;
        // C s_3710_3: cast zx s_3710_2 -> bv
        let s_3710_3: Bits = Bits::new(s_3710_2 as u128, 4u16);
        // D s_3710_4: cmp-eq s_3710_1 s_3710_3
        let s_3710_4: bool = ((s_3710_1) == (s_3710_3));
        // D s_3710_5: write-var gs#119116 <= s_3710_4
        fn_state.gs_119116 = s_3710_4;
        // N s_3710_6: jump b3530
        return block_3530(state, tracer, fn_state);
    }
    fn block_3711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3711_0: read-var el:u8
        let s_3711_0: u8 = fn_state.el;
        // D s_3711_1: read-var coproc:u8
        let s_3711_1: u8 = fn_state.coproc;
        // D s_3711_2: read-var opc1:u8
        let s_3711_2: u8 = fn_state.opc1;
        // D s_3711_3: read-var CRn:u8
        let s_3711_3: u8 = fn_state.CRn;
        // D s_3711_4: read-var opc2:u8
        let s_3711_4: u8 = fn_state.opc2;
        // D s_3711_5: read-var CRm:u8
        let s_3711_5: u8 = fn_state.CRm;
        // D s_3711_6: read-var t:i
        let s_3711_6: i128 = fn_state.t;
        // D s_3711_7: call ERRSELR_SysRegRead32_89386228f05f3e86(s_3711_0, s_3711_1, s_3711_2, s_3711_3, s_3711_4, s_3711_5, s_3711_6)
        let s_3711_7: () = ERRSELR_SysRegRead32_89386228f05f3e86(
            state,
            tracer,
            s_3711_0,
            s_3711_1,
            s_3711_2,
            s_3711_3,
            s_3711_4,
            s_3711_5,
            s_3711_6,
        );
        // N s_3711_8: return
        return;
    }
    fn block_3712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3712_0: read-var opc2:u8
        let s_3712_0: u8 = fn_state.opc2;
        // D s_3712_1: cast zx s_3712_0 -> bv
        let s_3712_1: Bits = Bits::new(s_3712_0 as u128, 3u16);
        // C s_3712_2: const #1u : u8
        let s_3712_2: u8 = 1;
        // C s_3712_3: cast zx s_3712_2 -> bv
        let s_3712_3: Bits = Bits::new(s_3712_2 as u128, 3u16);
        // D s_3712_4: cmp-eq s_3712_1 s_3712_3
        let s_3712_4: bool = ((s_3712_1) == (s_3712_3));
        // D s_3712_5: write-var gs#119115 <= s_3712_4
        fn_state.gs_119115 = s_3712_4;
        // N s_3712_6: jump b3527
        return block_3527(state, tracer, fn_state);
    }
    fn block_3713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3713_0: read-var opc1:u8
        let s_3713_0: u8 = fn_state.opc1;
        // D s_3713_1: cast zx s_3713_0 -> bv
        let s_3713_1: Bits = Bits::new(s_3713_0 as u128, 3u16);
        // C s_3713_2: const #0u : u8
        let s_3713_2: u8 = 0;
        // C s_3713_3: cast zx s_3713_2 -> bv
        let s_3713_3: Bits = Bits::new(s_3713_2 as u128, 3u16);
        // D s_3713_4: cmp-eq s_3713_1 s_3713_3
        let s_3713_4: bool = ((s_3713_1) == (s_3713_3));
        // D s_3713_5: write-var gs#119114 <= s_3713_4
        fn_state.gs_119114 = s_3713_4;
        // N s_3713_6: jump b3525
        return block_3525(state, tracer, fn_state);
    }
    fn block_3714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3714_0: read-var coproc:u8
        let s_3714_0: u8 = fn_state.coproc;
        // D s_3714_1: cast zx s_3714_0 -> bv
        let s_3714_1: Bits = Bits::new(s_3714_0 as u128, 4u16);
        // C s_3714_2: const #15u : u8
        let s_3714_2: u8 = 15;
        // C s_3714_3: cast zx s_3714_2 -> bv
        let s_3714_3: Bits = Bits::new(s_3714_2 as u128, 4u16);
        // D s_3714_4: cmp-eq s_3714_1 s_3714_3
        let s_3714_4: bool = ((s_3714_1) == (s_3714_3));
        // D s_3714_5: write-var gs#119113 <= s_3714_4
        fn_state.gs_119113 = s_3714_4;
        // N s_3714_6: jump b3523
        return block_3523(state, tracer, fn_state);
    }
    fn block_3715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3715_0: read-var CRn:u8
        let s_3715_0: u8 = fn_state.CRn;
        // D s_3715_1: cast zx s_3715_0 -> bv
        let s_3715_1: Bits = Bits::new(s_3715_0 as u128, 4u16);
        // C s_3715_2: const #5u : u8
        let s_3715_2: u8 = 5;
        // C s_3715_3: cast zx s_3715_2 -> bv
        let s_3715_3: Bits = Bits::new(s_3715_2 as u128, 4u16);
        // D s_3715_4: cmp-eq s_3715_1 s_3715_3
        let s_3715_4: bool = ((s_3715_1) == (s_3715_3));
        // D s_3715_5: write-var gs#119112 <= s_3715_4
        fn_state.gs_119112 = s_3715_4;
        // N s_3715_6: jump b3521
        return block_3521(state, tracer, fn_state);
    }
    fn block_3716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3716_0: read-var el:u8
        let s_3716_0: u8 = fn_state.el;
        // D s_3716_1: read-var coproc:u8
        let s_3716_1: u8 = fn_state.coproc;
        // D s_3716_2: read-var opc1:u8
        let s_3716_2: u8 = fn_state.opc1;
        // D s_3716_3: read-var CRn:u8
        let s_3716_3: u8 = fn_state.CRn;
        // D s_3716_4: read-var opc2:u8
        let s_3716_4: u8 = fn_state.opc2;
        // D s_3716_5: read-var CRm:u8
        let s_3716_5: u8 = fn_state.CRm;
        // D s_3716_6: read-var t:i
        let s_3716_6: i128 = fn_state.t;
        // D s_3716_7: call ERXMISC5_SysRegRead32_e7e0b0e38858a927(s_3716_0, s_3716_1, s_3716_2, s_3716_3, s_3716_4, s_3716_5, s_3716_6)
        let s_3716_7: () = ERXMISC5_SysRegRead32_e7e0b0e38858a927(
            state,
            tracer,
            s_3716_0,
            s_3716_1,
            s_3716_2,
            s_3716_3,
            s_3716_4,
            s_3716_5,
            s_3716_6,
        );
        // N s_3716_8: return
        return;
    }
    fn block_3717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3717_0: read-var opc2:u8
        let s_3717_0: u8 = fn_state.opc2;
        // D s_3717_1: cast zx s_3717_0 -> bv
        let s_3717_1: Bits = Bits::new(s_3717_0 as u128, 3u16);
        // C s_3717_2: const #3u : u8
        let s_3717_2: u8 = 3;
        // C s_3717_3: cast zx s_3717_2 -> bv
        let s_3717_3: Bits = Bits::new(s_3717_2 as u128, 3u16);
        // D s_3717_4: cmp-eq s_3717_1 s_3717_3
        let s_3717_4: bool = ((s_3717_1) == (s_3717_3));
        // D s_3717_5: write-var gs#119111 <= s_3717_4
        fn_state.gs_119111 = s_3717_4;
        // N s_3717_6: jump b3518
        return block_3518(state, tracer, fn_state);
    }
    fn block_3718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3718_0: read-var opc1:u8
        let s_3718_0: u8 = fn_state.opc1;
        // D s_3718_1: cast zx s_3718_0 -> bv
        let s_3718_1: Bits = Bits::new(s_3718_0 as u128, 3u16);
        // C s_3718_2: const #0u : u8
        let s_3718_2: u8 = 0;
        // C s_3718_3: cast zx s_3718_2 -> bv
        let s_3718_3: Bits = Bits::new(s_3718_2 as u128, 3u16);
        // D s_3718_4: cmp-eq s_3718_1 s_3718_3
        let s_3718_4: bool = ((s_3718_1) == (s_3718_3));
        // D s_3718_5: write-var gs#119110 <= s_3718_4
        fn_state.gs_119110 = s_3718_4;
        // N s_3718_6: jump b3516
        return block_3516(state, tracer, fn_state);
    }
    fn block_3719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3719_0: read-var coproc:u8
        let s_3719_0: u8 = fn_state.coproc;
        // D s_3719_1: cast zx s_3719_0 -> bv
        let s_3719_1: Bits = Bits::new(s_3719_0 as u128, 4u16);
        // C s_3719_2: const #15u : u8
        let s_3719_2: u8 = 15;
        // C s_3719_3: cast zx s_3719_2 -> bv
        let s_3719_3: Bits = Bits::new(s_3719_2 as u128, 4u16);
        // D s_3719_4: cmp-eq s_3719_1 s_3719_3
        let s_3719_4: bool = ((s_3719_1) == (s_3719_3));
        // D s_3719_5: write-var gs#119109 <= s_3719_4
        fn_state.gs_119109 = s_3719_4;
        // N s_3719_6: jump b3514
        return block_3514(state, tracer, fn_state);
    }
    fn block_3720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3720_0: read-var CRn:u8
        let s_3720_0: u8 = fn_state.CRn;
        // D s_3720_1: cast zx s_3720_0 -> bv
        let s_3720_1: Bits = Bits::new(s_3720_0 as u128, 4u16);
        // C s_3720_2: const #5u : u8
        let s_3720_2: u8 = 5;
        // C s_3720_3: cast zx s_3720_2 -> bv
        let s_3720_3: Bits = Bits::new(s_3720_2 as u128, 4u16);
        // D s_3720_4: cmp-eq s_3720_1 s_3720_3
        let s_3720_4: bool = ((s_3720_1) == (s_3720_3));
        // D s_3720_5: write-var gs#119108 <= s_3720_4
        fn_state.gs_119108 = s_3720_4;
        // N s_3720_6: jump b3512
        return block_3512(state, tracer, fn_state);
    }
    fn block_3721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3721_0: read-var el:u8
        let s_3721_0: u8 = fn_state.el;
        // D s_3721_1: read-var coproc:u8
        let s_3721_1: u8 = fn_state.coproc;
        // D s_3721_2: read-var opc1:u8
        let s_3721_2: u8 = fn_state.opc1;
        // D s_3721_3: read-var CRn:u8
        let s_3721_3: u8 = fn_state.CRn;
        // D s_3721_4: read-var opc2:u8
        let s_3721_4: u8 = fn_state.opc2;
        // D s_3721_5: read-var CRm:u8
        let s_3721_5: u8 = fn_state.CRm;
        // D s_3721_6: read-var t:i
        let s_3721_6: i128 = fn_state.t;
        // D s_3721_7: call ERXMISC0_SysRegRead32_945d1e7792b59484(s_3721_0, s_3721_1, s_3721_2, s_3721_3, s_3721_4, s_3721_5, s_3721_6)
        let s_3721_7: () = ERXMISC0_SysRegRead32_945d1e7792b59484(
            state,
            tracer,
            s_3721_0,
            s_3721_1,
            s_3721_2,
            s_3721_3,
            s_3721_4,
            s_3721_5,
            s_3721_6,
        );
        // N s_3721_8: return
        return;
    }
    fn block_3722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3722_0: read-var opc2:u8
        let s_3722_0: u8 = fn_state.opc2;
        // D s_3722_1: cast zx s_3722_0 -> bv
        let s_3722_1: Bits = Bits::new(s_3722_0 as u128, 3u16);
        // C s_3722_2: const #0u : u8
        let s_3722_2: u8 = 0;
        // C s_3722_3: cast zx s_3722_2 -> bv
        let s_3722_3: Bits = Bits::new(s_3722_2 as u128, 3u16);
        // D s_3722_4: cmp-eq s_3722_1 s_3722_3
        let s_3722_4: bool = ((s_3722_1) == (s_3722_3));
        // D s_3722_5: write-var gs#119107 <= s_3722_4
        fn_state.gs_119107 = s_3722_4;
        // N s_3722_6: jump b3509
        return block_3509(state, tracer, fn_state);
    }
    fn block_3723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3723_0: read-var opc1:u8
        let s_3723_0: u8 = fn_state.opc1;
        // D s_3723_1: cast zx s_3723_0 -> bv
        let s_3723_1: Bits = Bits::new(s_3723_0 as u128, 3u16);
        // C s_3723_2: const #0u : u8
        let s_3723_2: u8 = 0;
        // C s_3723_3: cast zx s_3723_2 -> bv
        let s_3723_3: Bits = Bits::new(s_3723_2 as u128, 3u16);
        // D s_3723_4: cmp-eq s_3723_1 s_3723_3
        let s_3723_4: bool = ((s_3723_1) == (s_3723_3));
        // D s_3723_5: write-var gs#119106 <= s_3723_4
        fn_state.gs_119106 = s_3723_4;
        // N s_3723_6: jump b3507
        return block_3507(state, tracer, fn_state);
    }
    fn block_3724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3724_0: read-var coproc:u8
        let s_3724_0: u8 = fn_state.coproc;
        // D s_3724_1: cast zx s_3724_0 -> bv
        let s_3724_1: Bits = Bits::new(s_3724_0 as u128, 4u16);
        // C s_3724_2: const #15u : u8
        let s_3724_2: u8 = 15;
        // C s_3724_3: cast zx s_3724_2 -> bv
        let s_3724_3: Bits = Bits::new(s_3724_2 as u128, 4u16);
        // D s_3724_4: cmp-eq s_3724_1 s_3724_3
        let s_3724_4: bool = ((s_3724_1) == (s_3724_3));
        // D s_3724_5: write-var gs#119105 <= s_3724_4
        fn_state.gs_119105 = s_3724_4;
        // N s_3724_6: jump b3505
        return block_3505(state, tracer, fn_state);
    }
    fn block_3725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3725_0: read-var CRn:u8
        let s_3725_0: u8 = fn_state.CRn;
        // D s_3725_1: cast zx s_3725_0 -> bv
        let s_3725_1: Bits = Bits::new(s_3725_0 as u128, 4u16);
        // C s_3725_2: const #5u : u8
        let s_3725_2: u8 = 5;
        // C s_3725_3: cast zx s_3725_2 -> bv
        let s_3725_3: Bits = Bits::new(s_3725_2 as u128, 4u16);
        // D s_3725_4: cmp-eq s_3725_1 s_3725_3
        let s_3725_4: bool = ((s_3725_1) == (s_3725_3));
        // D s_3725_5: write-var gs#119104 <= s_3725_4
        fn_state.gs_119104 = s_3725_4;
        // N s_3725_6: jump b3503
        return block_3503(state, tracer, fn_state);
    }
    fn block_3726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3726_0: read-var el:u8
        let s_3726_0: u8 = fn_state.el;
        // D s_3726_1: read-var coproc:u8
        let s_3726_1: u8 = fn_state.coproc;
        // D s_3726_2: read-var opc1:u8
        let s_3726_2: u8 = fn_state.opc1;
        // D s_3726_3: read-var CRn:u8
        let s_3726_3: u8 = fn_state.CRn;
        // D s_3726_4: read-var opc2:u8
        let s_3726_4: u8 = fn_state.opc2;
        // D s_3726_5: read-var CRm:u8
        let s_3726_5: u8 = fn_state.CRm;
        // D s_3726_6: read-var t:i
        let s_3726_6: i128 = fn_state.t;
        // D s_3726_7: call ERXADDR_SysRegRead32_ca0ccd8f0f00724b(s_3726_0, s_3726_1, s_3726_2, s_3726_3, s_3726_4, s_3726_5, s_3726_6)
        let s_3726_7: () = ERXADDR_SysRegRead32_ca0ccd8f0f00724b(
            state,
            tracer,
            s_3726_0,
            s_3726_1,
            s_3726_2,
            s_3726_3,
            s_3726_4,
            s_3726_5,
            s_3726_6,
        );
        // N s_3726_8: return
        return;
    }
    fn block_3727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3727_0: read-var opc2:u8
        let s_3727_0: u8 = fn_state.opc2;
        // D s_3727_1: cast zx s_3727_0 -> bv
        let s_3727_1: Bits = Bits::new(s_3727_0 as u128, 3u16);
        // C s_3727_2: const #3u : u8
        let s_3727_2: u8 = 3;
        // C s_3727_3: cast zx s_3727_2 -> bv
        let s_3727_3: Bits = Bits::new(s_3727_2 as u128, 3u16);
        // D s_3727_4: cmp-eq s_3727_1 s_3727_3
        let s_3727_4: bool = ((s_3727_1) == (s_3727_3));
        // D s_3727_5: write-var gs#119103 <= s_3727_4
        fn_state.gs_119103 = s_3727_4;
        // N s_3727_6: jump b3500
        return block_3500(state, tracer, fn_state);
    }
    fn block_3728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3728_0: read-var opc1:u8
        let s_3728_0: u8 = fn_state.opc1;
        // D s_3728_1: cast zx s_3728_0 -> bv
        let s_3728_1: Bits = Bits::new(s_3728_0 as u128, 3u16);
        // C s_3728_2: const #0u : u8
        let s_3728_2: u8 = 0;
        // C s_3728_3: cast zx s_3728_2 -> bv
        let s_3728_3: Bits = Bits::new(s_3728_2 as u128, 3u16);
        // D s_3728_4: cmp-eq s_3728_1 s_3728_3
        let s_3728_4: bool = ((s_3728_1) == (s_3728_3));
        // D s_3728_5: write-var gs#119102 <= s_3728_4
        fn_state.gs_119102 = s_3728_4;
        // N s_3728_6: jump b3498
        return block_3498(state, tracer, fn_state);
    }
    fn block_3729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3729_0: read-var coproc:u8
        let s_3729_0: u8 = fn_state.coproc;
        // D s_3729_1: cast zx s_3729_0 -> bv
        let s_3729_1: Bits = Bits::new(s_3729_0 as u128, 4u16);
        // C s_3729_2: const #15u : u8
        let s_3729_2: u8 = 15;
        // C s_3729_3: cast zx s_3729_2 -> bv
        let s_3729_3: Bits = Bits::new(s_3729_2 as u128, 4u16);
        // D s_3729_4: cmp-eq s_3729_1 s_3729_3
        let s_3729_4: bool = ((s_3729_1) == (s_3729_3));
        // D s_3729_5: write-var gs#119101 <= s_3729_4
        fn_state.gs_119101 = s_3729_4;
        // N s_3729_6: jump b3496
        return block_3496(state, tracer, fn_state);
    }
    fn block_3730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3730_0: read-var CRn:u8
        let s_3730_0: u8 = fn_state.CRn;
        // D s_3730_1: cast zx s_3730_0 -> bv
        let s_3730_1: Bits = Bits::new(s_3730_0 as u128, 4u16);
        // C s_3730_2: const #5u : u8
        let s_3730_2: u8 = 5;
        // C s_3730_3: cast zx s_3730_2 -> bv
        let s_3730_3: Bits = Bits::new(s_3730_2 as u128, 4u16);
        // D s_3730_4: cmp-eq s_3730_1 s_3730_3
        let s_3730_4: bool = ((s_3730_1) == (s_3730_3));
        // D s_3730_5: write-var gs#119100 <= s_3730_4
        fn_state.gs_119100 = s_3730_4;
        // N s_3730_6: jump b3494
        return block_3494(state, tracer, fn_state);
    }
    fn block_3731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3731_0: read-var el:u8
        let s_3731_0: u8 = fn_state.el;
        // D s_3731_1: read-var coproc:u8
        let s_3731_1: u8 = fn_state.coproc;
        // D s_3731_2: read-var opc1:u8
        let s_3731_2: u8 = fn_state.opc1;
        // D s_3731_3: read-var CRn:u8
        let s_3731_3: u8 = fn_state.CRn;
        // D s_3731_4: read-var opc2:u8
        let s_3731_4: u8 = fn_state.opc2;
        // D s_3731_5: read-var CRm:u8
        let s_3731_5: u8 = fn_state.CRm;
        // D s_3731_6: read-var t:i
        let s_3731_6: i128 = fn_state.t;
        // D s_3731_7: call ERXFR_SysRegRead32_38334a5a99e8eedf(s_3731_0, s_3731_1, s_3731_2, s_3731_3, s_3731_4, s_3731_5, s_3731_6)
        let s_3731_7: () = ERXFR_SysRegRead32_38334a5a99e8eedf(
            state,
            tracer,
            s_3731_0,
            s_3731_1,
            s_3731_2,
            s_3731_3,
            s_3731_4,
            s_3731_5,
            s_3731_6,
        );
        // N s_3731_8: return
        return;
    }
    fn block_3732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3732_0: read-var opc2:u8
        let s_3732_0: u8 = fn_state.opc2;
        // D s_3732_1: cast zx s_3732_0 -> bv
        let s_3732_1: Bits = Bits::new(s_3732_0 as u128, 3u16);
        // C s_3732_2: const #0u : u8
        let s_3732_2: u8 = 0;
        // C s_3732_3: cast zx s_3732_2 -> bv
        let s_3732_3: Bits = Bits::new(s_3732_2 as u128, 3u16);
        // D s_3732_4: cmp-eq s_3732_1 s_3732_3
        let s_3732_4: bool = ((s_3732_1) == (s_3732_3));
        // D s_3732_5: write-var gs#119099 <= s_3732_4
        fn_state.gs_119099 = s_3732_4;
        // N s_3732_6: jump b3491
        return block_3491(state, tracer, fn_state);
    }
    fn block_3733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3733_0: read-var opc1:u8
        let s_3733_0: u8 = fn_state.opc1;
        // D s_3733_1: cast zx s_3733_0 -> bv
        let s_3733_1: Bits = Bits::new(s_3733_0 as u128, 3u16);
        // C s_3733_2: const #0u : u8
        let s_3733_2: u8 = 0;
        // C s_3733_3: cast zx s_3733_2 -> bv
        let s_3733_3: Bits = Bits::new(s_3733_2 as u128, 3u16);
        // D s_3733_4: cmp-eq s_3733_1 s_3733_3
        let s_3733_4: bool = ((s_3733_1) == (s_3733_3));
        // D s_3733_5: write-var gs#119098 <= s_3733_4
        fn_state.gs_119098 = s_3733_4;
        // N s_3733_6: jump b3489
        return block_3489(state, tracer, fn_state);
    }
    fn block_3734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3734_0: read-var coproc:u8
        let s_3734_0: u8 = fn_state.coproc;
        // D s_3734_1: cast zx s_3734_0 -> bv
        let s_3734_1: Bits = Bits::new(s_3734_0 as u128, 4u16);
        // C s_3734_2: const #15u : u8
        let s_3734_2: u8 = 15;
        // C s_3734_3: cast zx s_3734_2 -> bv
        let s_3734_3: Bits = Bits::new(s_3734_2 as u128, 4u16);
        // D s_3734_4: cmp-eq s_3734_1 s_3734_3
        let s_3734_4: bool = ((s_3734_1) == (s_3734_3));
        // D s_3734_5: write-var gs#119097 <= s_3734_4
        fn_state.gs_119097 = s_3734_4;
        // N s_3734_6: jump b3487
        return block_3487(state, tracer, fn_state);
    }
    fn block_3735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3735_0: read-var CRn:u8
        let s_3735_0: u8 = fn_state.CRn;
        // D s_3735_1: cast zx s_3735_0 -> bv
        let s_3735_1: Bits = Bits::new(s_3735_0 as u128, 4u16);
        // C s_3735_2: const #5u : u8
        let s_3735_2: u8 = 5;
        // C s_3735_3: cast zx s_3735_2 -> bv
        let s_3735_3: Bits = Bits::new(s_3735_2 as u128, 4u16);
        // D s_3735_4: cmp-eq s_3735_1 s_3735_3
        let s_3735_4: bool = ((s_3735_1) == (s_3735_3));
        // D s_3735_5: write-var gs#119096 <= s_3735_4
        fn_state.gs_119096 = s_3735_4;
        // N s_3735_6: jump b3485
        return block_3485(state, tracer, fn_state);
    }
    fn block_3736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3736_0: read-var el:u8
        let s_3736_0: u8 = fn_state.el;
        // D s_3736_1: read-var coproc:u8
        let s_3736_1: u8 = fn_state.coproc;
        // D s_3736_2: read-var opc1:u8
        let s_3736_2: u8 = fn_state.opc1;
        // D s_3736_3: read-var CRn:u8
        let s_3736_3: u8 = fn_state.CRn;
        // D s_3736_4: read-var opc2:u8
        let s_3736_4: u8 = fn_state.opc2;
        // D s_3736_5: read-var CRm:u8
        let s_3736_5: u8 = fn_state.CRm;
        // D s_3736_6: read-var t:i
        let s_3736_6: i128 = fn_state.t;
        // D s_3736_7: call ERXMISC2_SysRegRead32_17926cb7ab87a983(s_3736_0, s_3736_1, s_3736_2, s_3736_3, s_3736_4, s_3736_5, s_3736_6)
        let s_3736_7: () = ERXMISC2_SysRegRead32_17926cb7ab87a983(
            state,
            tracer,
            s_3736_0,
            s_3736_1,
            s_3736_2,
            s_3736_3,
            s_3736_4,
            s_3736_5,
            s_3736_6,
        );
        // N s_3736_8: return
        return;
    }
    fn block_3737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3737_0: read-var opc2:u8
        let s_3737_0: u8 = fn_state.opc2;
        // D s_3737_1: cast zx s_3737_0 -> bv
        let s_3737_1: Bits = Bits::new(s_3737_0 as u128, 3u16);
        // C s_3737_2: const #4u : u8
        let s_3737_2: u8 = 4;
        // C s_3737_3: cast zx s_3737_2 -> bv
        let s_3737_3: Bits = Bits::new(s_3737_2 as u128, 3u16);
        // D s_3737_4: cmp-eq s_3737_1 s_3737_3
        let s_3737_4: bool = ((s_3737_1) == (s_3737_3));
        // D s_3737_5: write-var gs#119095 <= s_3737_4
        fn_state.gs_119095 = s_3737_4;
        // N s_3737_6: jump b3482
        return block_3482(state, tracer, fn_state);
    }
    fn block_3738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3738_0: read-var opc1:u8
        let s_3738_0: u8 = fn_state.opc1;
        // D s_3738_1: cast zx s_3738_0 -> bv
        let s_3738_1: Bits = Bits::new(s_3738_0 as u128, 3u16);
        // C s_3738_2: const #0u : u8
        let s_3738_2: u8 = 0;
        // C s_3738_3: cast zx s_3738_2 -> bv
        let s_3738_3: Bits = Bits::new(s_3738_2 as u128, 3u16);
        // D s_3738_4: cmp-eq s_3738_1 s_3738_3
        let s_3738_4: bool = ((s_3738_1) == (s_3738_3));
        // D s_3738_5: write-var gs#119094 <= s_3738_4
        fn_state.gs_119094 = s_3738_4;
        // N s_3738_6: jump b3480
        return block_3480(state, tracer, fn_state);
    }
    fn block_3739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3739_0: read-var coproc:u8
        let s_3739_0: u8 = fn_state.coproc;
        // D s_3739_1: cast zx s_3739_0 -> bv
        let s_3739_1: Bits = Bits::new(s_3739_0 as u128, 4u16);
        // C s_3739_2: const #15u : u8
        let s_3739_2: u8 = 15;
        // C s_3739_3: cast zx s_3739_2 -> bv
        let s_3739_3: Bits = Bits::new(s_3739_2 as u128, 4u16);
        // D s_3739_4: cmp-eq s_3739_1 s_3739_3
        let s_3739_4: bool = ((s_3739_1) == (s_3739_3));
        // D s_3739_5: write-var gs#119093 <= s_3739_4
        fn_state.gs_119093 = s_3739_4;
        // N s_3739_6: jump b3478
        return block_3478(state, tracer, fn_state);
    }
    fn block_3740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3740_0: read-var CRn:u8
        let s_3740_0: u8 = fn_state.CRn;
        // D s_3740_1: cast zx s_3740_0 -> bv
        let s_3740_1: Bits = Bits::new(s_3740_0 as u128, 4u16);
        // C s_3740_2: const #5u : u8
        let s_3740_2: u8 = 5;
        // C s_3740_3: cast zx s_3740_2 -> bv
        let s_3740_3: Bits = Bits::new(s_3740_2 as u128, 4u16);
        // D s_3740_4: cmp-eq s_3740_1 s_3740_3
        let s_3740_4: bool = ((s_3740_1) == (s_3740_3));
        // D s_3740_5: write-var gs#119092 <= s_3740_4
        fn_state.gs_119092 = s_3740_4;
        // N s_3740_6: jump b3476
        return block_3476(state, tracer, fn_state);
    }
    fn block_3741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3741_0: read-var el:u8
        let s_3741_0: u8 = fn_state.el;
        // D s_3741_1: read-var coproc:u8
        let s_3741_1: u8 = fn_state.coproc;
        // D s_3741_2: read-var opc1:u8
        let s_3741_2: u8 = fn_state.opc1;
        // D s_3741_3: read-var CRn:u8
        let s_3741_3: u8 = fn_state.CRn;
        // D s_3741_4: read-var opc2:u8
        let s_3741_4: u8 = fn_state.opc2;
        // D s_3741_5: read-var CRm:u8
        let s_3741_5: u8 = fn_state.CRm;
        // D s_3741_6: read-var t:i
        let s_3741_6: i128 = fn_state.t;
        // D s_3741_7: call ERXFR2_SysRegRead32_2ed16754dcca71f1(s_3741_0, s_3741_1, s_3741_2, s_3741_3, s_3741_4, s_3741_5, s_3741_6)
        let s_3741_7: () = ERXFR2_SysRegRead32_2ed16754dcca71f1(
            state,
            tracer,
            s_3741_0,
            s_3741_1,
            s_3741_2,
            s_3741_3,
            s_3741_4,
            s_3741_5,
            s_3741_6,
        );
        // N s_3741_8: return
        return;
    }
    fn block_3742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3742_0: read-var opc2:u8
        let s_3742_0: u8 = fn_state.opc2;
        // D s_3742_1: cast zx s_3742_0 -> bv
        let s_3742_1: Bits = Bits::new(s_3742_0 as u128, 3u16);
        // C s_3742_2: const #4u : u8
        let s_3742_2: u8 = 4;
        // C s_3742_3: cast zx s_3742_2 -> bv
        let s_3742_3: Bits = Bits::new(s_3742_2 as u128, 3u16);
        // D s_3742_4: cmp-eq s_3742_1 s_3742_3
        let s_3742_4: bool = ((s_3742_1) == (s_3742_3));
        // D s_3742_5: write-var gs#119091 <= s_3742_4
        fn_state.gs_119091 = s_3742_4;
        // N s_3742_6: jump b3473
        return block_3473(state, tracer, fn_state);
    }
    fn block_3743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3743_0: read-var opc1:u8
        let s_3743_0: u8 = fn_state.opc1;
        // D s_3743_1: cast zx s_3743_0 -> bv
        let s_3743_1: Bits = Bits::new(s_3743_0 as u128, 3u16);
        // C s_3743_2: const #0u : u8
        let s_3743_2: u8 = 0;
        // C s_3743_3: cast zx s_3743_2 -> bv
        let s_3743_3: Bits = Bits::new(s_3743_2 as u128, 3u16);
        // D s_3743_4: cmp-eq s_3743_1 s_3743_3
        let s_3743_4: bool = ((s_3743_1) == (s_3743_3));
        // D s_3743_5: write-var gs#119090 <= s_3743_4
        fn_state.gs_119090 = s_3743_4;
        // N s_3743_6: jump b3471
        return block_3471(state, tracer, fn_state);
    }
    fn block_3744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3744_0: read-var coproc:u8
        let s_3744_0: u8 = fn_state.coproc;
        // D s_3744_1: cast zx s_3744_0 -> bv
        let s_3744_1: Bits = Bits::new(s_3744_0 as u128, 4u16);
        // C s_3744_2: const #15u : u8
        let s_3744_2: u8 = 15;
        // C s_3744_3: cast zx s_3744_2 -> bv
        let s_3744_3: Bits = Bits::new(s_3744_2 as u128, 4u16);
        // D s_3744_4: cmp-eq s_3744_1 s_3744_3
        let s_3744_4: bool = ((s_3744_1) == (s_3744_3));
        // D s_3744_5: write-var gs#119089 <= s_3744_4
        fn_state.gs_119089 = s_3744_4;
        // N s_3744_6: jump b3469
        return block_3469(state, tracer, fn_state);
    }
    fn block_3745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3745_0: read-var CRn:u8
        let s_3745_0: u8 = fn_state.CRn;
        // D s_3745_1: cast zx s_3745_0 -> bv
        let s_3745_1: Bits = Bits::new(s_3745_0 as u128, 4u16);
        // C s_3745_2: const #5u : u8
        let s_3745_2: u8 = 5;
        // C s_3745_3: cast zx s_3745_2 -> bv
        let s_3745_3: Bits = Bits::new(s_3745_2 as u128, 4u16);
        // D s_3745_4: cmp-eq s_3745_1 s_3745_3
        let s_3745_4: bool = ((s_3745_1) == (s_3745_3));
        // D s_3745_5: write-var gs#119088 <= s_3745_4
        fn_state.gs_119088 = s_3745_4;
        // N s_3745_6: jump b3467
        return block_3467(state, tracer, fn_state);
    }
    fn block_3746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3746_0: read-var el:u8
        let s_3746_0: u8 = fn_state.el;
        // D s_3746_1: read-var coproc:u8
        let s_3746_1: u8 = fn_state.coproc;
        // D s_3746_2: read-var opc1:u8
        let s_3746_2: u8 = fn_state.opc1;
        // D s_3746_3: read-var CRn:u8
        let s_3746_3: u8 = fn_state.CRn;
        // D s_3746_4: read-var opc2:u8
        let s_3746_4: u8 = fn_state.opc2;
        // D s_3746_5: read-var CRm:u8
        let s_3746_5: u8 = fn_state.CRm;
        // D s_3746_6: read-var t:i
        let s_3746_6: i128 = fn_state.t;
        // D s_3746_7: call ERRIDR_SysRegRead32_98e51b40bf051290(s_3746_0, s_3746_1, s_3746_2, s_3746_3, s_3746_4, s_3746_5, s_3746_6)
        let s_3746_7: () = ERRIDR_SysRegRead32_98e51b40bf051290(
            state,
            tracer,
            s_3746_0,
            s_3746_1,
            s_3746_2,
            s_3746_3,
            s_3746_4,
            s_3746_5,
            s_3746_6,
        );
        // N s_3746_8: return
        return;
    }
    fn block_3747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3747_0: read-var opc2:u8
        let s_3747_0: u8 = fn_state.opc2;
        // D s_3747_1: cast zx s_3747_0 -> bv
        let s_3747_1: Bits = Bits::new(s_3747_0 as u128, 3u16);
        // C s_3747_2: const #0u : u8
        let s_3747_2: u8 = 0;
        // C s_3747_3: cast zx s_3747_2 -> bv
        let s_3747_3: Bits = Bits::new(s_3747_2 as u128, 3u16);
        // D s_3747_4: cmp-eq s_3747_1 s_3747_3
        let s_3747_4: bool = ((s_3747_1) == (s_3747_3));
        // D s_3747_5: write-var gs#119087 <= s_3747_4
        fn_state.gs_119087 = s_3747_4;
        // N s_3747_6: jump b3464
        return block_3464(state, tracer, fn_state);
    }
    fn block_3748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3748_0: read-var opc1:u8
        let s_3748_0: u8 = fn_state.opc1;
        // D s_3748_1: cast zx s_3748_0 -> bv
        let s_3748_1: Bits = Bits::new(s_3748_0 as u128, 3u16);
        // C s_3748_2: const #0u : u8
        let s_3748_2: u8 = 0;
        // C s_3748_3: cast zx s_3748_2 -> bv
        let s_3748_3: Bits = Bits::new(s_3748_2 as u128, 3u16);
        // D s_3748_4: cmp-eq s_3748_1 s_3748_3
        let s_3748_4: bool = ((s_3748_1) == (s_3748_3));
        // D s_3748_5: write-var gs#119086 <= s_3748_4
        fn_state.gs_119086 = s_3748_4;
        // N s_3748_6: jump b3462
        return block_3462(state, tracer, fn_state);
    }
    fn block_3749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3749_0: read-var coproc:u8
        let s_3749_0: u8 = fn_state.coproc;
        // D s_3749_1: cast zx s_3749_0 -> bv
        let s_3749_1: Bits = Bits::new(s_3749_0 as u128, 4u16);
        // C s_3749_2: const #15u : u8
        let s_3749_2: u8 = 15;
        // C s_3749_3: cast zx s_3749_2 -> bv
        let s_3749_3: Bits = Bits::new(s_3749_2 as u128, 4u16);
        // D s_3749_4: cmp-eq s_3749_1 s_3749_3
        let s_3749_4: bool = ((s_3749_1) == (s_3749_3));
        // D s_3749_5: write-var gs#119085 <= s_3749_4
        fn_state.gs_119085 = s_3749_4;
        // N s_3749_6: jump b3460
        return block_3460(state, tracer, fn_state);
    }
    fn block_3750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3750_0: read-var CRn:u8
        let s_3750_0: u8 = fn_state.CRn;
        // D s_3750_1: cast zx s_3750_0 -> bv
        let s_3750_1: Bits = Bits::new(s_3750_0 as u128, 4u16);
        // C s_3750_2: const #5u : u8
        let s_3750_2: u8 = 5;
        // C s_3750_3: cast zx s_3750_2 -> bv
        let s_3750_3: Bits = Bits::new(s_3750_2 as u128, 4u16);
        // D s_3750_4: cmp-eq s_3750_1 s_3750_3
        let s_3750_4: bool = ((s_3750_1) == (s_3750_3));
        // D s_3750_5: write-var gs#119084 <= s_3750_4
        fn_state.gs_119084 = s_3750_4;
        // N s_3750_6: jump b3458
        return block_3458(state, tracer, fn_state);
    }
    fn block_3751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3751_0: read-var el:u8
        let s_3751_0: u8 = fn_state.el;
        // D s_3751_1: read-var coproc:u8
        let s_3751_1: u8 = fn_state.coproc;
        // D s_3751_2: read-var opc1:u8
        let s_3751_2: u8 = fn_state.opc1;
        // D s_3751_3: read-var CRn:u8
        let s_3751_3: u8 = fn_state.CRn;
        // D s_3751_4: read-var opc2:u8
        let s_3751_4: u8 = fn_state.opc2;
        // D s_3751_5: read-var CRm:u8
        let s_3751_5: u8 = fn_state.CRm;
        // D s_3751_6: read-var t:i
        let s_3751_6: i128 = fn_state.t;
        // D s_3751_7: call AMCR_SysRegRead32_3740e4968cc5855a(s_3751_0, s_3751_1, s_3751_2, s_3751_3, s_3751_4, s_3751_5, s_3751_6)
        let s_3751_7: () = AMCR_SysRegRead32_3740e4968cc5855a(
            state,
            tracer,
            s_3751_0,
            s_3751_1,
            s_3751_2,
            s_3751_3,
            s_3751_4,
            s_3751_5,
            s_3751_6,
        );
        // N s_3751_8: return
        return;
    }
    fn block_3752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3752_0: read-var opc2:u8
        let s_3752_0: u8 = fn_state.opc2;
        // D s_3752_1: cast zx s_3752_0 -> bv
        let s_3752_1: Bits = Bits::new(s_3752_0 as u128, 3u16);
        // C s_3752_2: const #0u : u8
        let s_3752_2: u8 = 0;
        // C s_3752_3: cast zx s_3752_2 -> bv
        let s_3752_3: Bits = Bits::new(s_3752_2 as u128, 3u16);
        // D s_3752_4: cmp-eq s_3752_1 s_3752_3
        let s_3752_4: bool = ((s_3752_1) == (s_3752_3));
        // D s_3752_5: write-var gs#119083 <= s_3752_4
        fn_state.gs_119083 = s_3752_4;
        // N s_3752_6: jump b3455
        return block_3455(state, tracer, fn_state);
    }
    fn block_3753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3753_0: read-var opc1:u8
        let s_3753_0: u8 = fn_state.opc1;
        // D s_3753_1: cast zx s_3753_0 -> bv
        let s_3753_1: Bits = Bits::new(s_3753_0 as u128, 3u16);
        // C s_3753_2: const #0u : u8
        let s_3753_2: u8 = 0;
        // C s_3753_3: cast zx s_3753_2 -> bv
        let s_3753_3: Bits = Bits::new(s_3753_2 as u128, 3u16);
        // D s_3753_4: cmp-eq s_3753_1 s_3753_3
        let s_3753_4: bool = ((s_3753_1) == (s_3753_3));
        // D s_3753_5: write-var gs#119082 <= s_3753_4
        fn_state.gs_119082 = s_3753_4;
        // N s_3753_6: jump b3453
        return block_3453(state, tracer, fn_state);
    }
    fn block_3754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3754_0: read-var coproc:u8
        let s_3754_0: u8 = fn_state.coproc;
        // D s_3754_1: cast zx s_3754_0 -> bv
        let s_3754_1: Bits = Bits::new(s_3754_0 as u128, 4u16);
        // C s_3754_2: const #15u : u8
        let s_3754_2: u8 = 15;
        // C s_3754_3: cast zx s_3754_2 -> bv
        let s_3754_3: Bits = Bits::new(s_3754_2 as u128, 4u16);
        // D s_3754_4: cmp-eq s_3754_1 s_3754_3
        let s_3754_4: bool = ((s_3754_1) == (s_3754_3));
        // D s_3754_5: write-var gs#119081 <= s_3754_4
        fn_state.gs_119081 = s_3754_4;
        // N s_3754_6: jump b3451
        return block_3451(state, tracer, fn_state);
    }
    fn block_3755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3755_0: read-var CRn:u8
        let s_3755_0: u8 = fn_state.CRn;
        // D s_3755_1: cast zx s_3755_0 -> bv
        let s_3755_1: Bits = Bits::new(s_3755_0 as u128, 4u16);
        // C s_3755_2: const #13u : u8
        let s_3755_2: u8 = 13;
        // C s_3755_3: cast zx s_3755_2 -> bv
        let s_3755_3: Bits = Bits::new(s_3755_2 as u128, 4u16);
        // D s_3755_4: cmp-eq s_3755_1 s_3755_3
        let s_3755_4: bool = ((s_3755_1) == (s_3755_3));
        // D s_3755_5: write-var gs#119080 <= s_3755_4
        fn_state.gs_119080 = s_3755_4;
        // N s_3755_6: jump b3449
        return block_3449(state, tracer, fn_state);
    }
    fn block_3756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3756_0: read-var el:u8
        let s_3756_0: u8 = fn_state.el;
        // D s_3756_1: read-var coproc:u8
        let s_3756_1: u8 = fn_state.coproc;
        // D s_3756_2: read-var opc1:u8
        let s_3756_2: u8 = fn_state.opc1;
        // D s_3756_3: read-var CRn:u8
        let s_3756_3: u8 = fn_state.CRn;
        // D s_3756_4: read-var opc2:u8
        let s_3756_4: u8 = fn_state.opc2;
        // D s_3756_5: read-var CRm:u8
        let s_3756_5: u8 = fn_state.CRm;
        // D s_3756_6: read-var t:i
        let s_3756_6: i128 = fn_state.t;
        // D s_3756_7: call AMCNTENSET1_SysRegRead32_7b7457f3c7ff281b(s_3756_0, s_3756_1, s_3756_2, s_3756_3, s_3756_4, s_3756_5, s_3756_6)
        let s_3756_7: () = AMCNTENSET1_SysRegRead32_7b7457f3c7ff281b(
            state,
            tracer,
            s_3756_0,
            s_3756_1,
            s_3756_2,
            s_3756_3,
            s_3756_4,
            s_3756_5,
            s_3756_6,
        );
        // N s_3756_8: return
        return;
    }
    fn block_3757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3757_0: read-var opc2:u8
        let s_3757_0: u8 = fn_state.opc2;
        // D s_3757_1: cast zx s_3757_0 -> bv
        let s_3757_1: Bits = Bits::new(s_3757_0 as u128, 3u16);
        // C s_3757_2: const #1u : u8
        let s_3757_2: u8 = 1;
        // C s_3757_3: cast zx s_3757_2 -> bv
        let s_3757_3: Bits = Bits::new(s_3757_2 as u128, 3u16);
        // D s_3757_4: cmp-eq s_3757_1 s_3757_3
        let s_3757_4: bool = ((s_3757_1) == (s_3757_3));
        // D s_3757_5: write-var gs#119079 <= s_3757_4
        fn_state.gs_119079 = s_3757_4;
        // N s_3757_6: jump b3446
        return block_3446(state, tracer, fn_state);
    }
    fn block_3758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3758_0: read-var opc1:u8
        let s_3758_0: u8 = fn_state.opc1;
        // D s_3758_1: cast zx s_3758_0 -> bv
        let s_3758_1: Bits = Bits::new(s_3758_0 as u128, 3u16);
        // C s_3758_2: const #0u : u8
        let s_3758_2: u8 = 0;
        // C s_3758_3: cast zx s_3758_2 -> bv
        let s_3758_3: Bits = Bits::new(s_3758_2 as u128, 3u16);
        // D s_3758_4: cmp-eq s_3758_1 s_3758_3
        let s_3758_4: bool = ((s_3758_1) == (s_3758_3));
        // D s_3758_5: write-var gs#119078 <= s_3758_4
        fn_state.gs_119078 = s_3758_4;
        // N s_3758_6: jump b3444
        return block_3444(state, tracer, fn_state);
    }
    fn block_3759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3759_0: read-var coproc:u8
        let s_3759_0: u8 = fn_state.coproc;
        // D s_3759_1: cast zx s_3759_0 -> bv
        let s_3759_1: Bits = Bits::new(s_3759_0 as u128, 4u16);
        // C s_3759_2: const #15u : u8
        let s_3759_2: u8 = 15;
        // C s_3759_3: cast zx s_3759_2 -> bv
        let s_3759_3: Bits = Bits::new(s_3759_2 as u128, 4u16);
        // D s_3759_4: cmp-eq s_3759_1 s_3759_3
        let s_3759_4: bool = ((s_3759_1) == (s_3759_3));
        // D s_3759_5: write-var gs#119077 <= s_3759_4
        fn_state.gs_119077 = s_3759_4;
        // N s_3759_6: jump b3442
        return block_3442(state, tracer, fn_state);
    }
    fn block_3760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3760_0: read-var CRn:u8
        let s_3760_0: u8 = fn_state.CRn;
        // D s_3760_1: cast zx s_3760_0 -> bv
        let s_3760_1: Bits = Bits::new(s_3760_0 as u128, 4u16);
        // C s_3760_2: const #13u : u8
        let s_3760_2: u8 = 13;
        // C s_3760_3: cast zx s_3760_2 -> bv
        let s_3760_3: Bits = Bits::new(s_3760_2 as u128, 4u16);
        // D s_3760_4: cmp-eq s_3760_1 s_3760_3
        let s_3760_4: bool = ((s_3760_1) == (s_3760_3));
        // D s_3760_5: write-var gs#119076 <= s_3760_4
        fn_state.gs_119076 = s_3760_4;
        // N s_3760_6: jump b3440
        return block_3440(state, tracer, fn_state);
    }
    fn block_3761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3761_0: read-var el:u8
        let s_3761_0: u8 = fn_state.el;
        // D s_3761_1: read-var coproc:u8
        let s_3761_1: u8 = fn_state.coproc;
        // D s_3761_2: read-var opc1:u8
        let s_3761_2: u8 = fn_state.opc1;
        // D s_3761_3: read-var CRn:u8
        let s_3761_3: u8 = fn_state.CRn;
        // D s_3761_4: read-var opc2:u8
        let s_3761_4: u8 = fn_state.opc2;
        // D s_3761_5: read-var CRm:u8
        let s_3761_5: u8 = fn_state.CRm;
        // D s_3761_6: read-var t:i
        let s_3761_6: i128 = fn_state.t;
        // D s_3761_7: call AMCNTENCLR0_SysRegRead32_4cd517564ca44d4e(s_3761_0, s_3761_1, s_3761_2, s_3761_3, s_3761_4, s_3761_5, s_3761_6)
        let s_3761_7: () = AMCNTENCLR0_SysRegRead32_4cd517564ca44d4e(
            state,
            tracer,
            s_3761_0,
            s_3761_1,
            s_3761_2,
            s_3761_3,
            s_3761_4,
            s_3761_5,
            s_3761_6,
        );
        // N s_3761_8: return
        return;
    }
    fn block_3762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3762_0: read-var opc2:u8
        let s_3762_0: u8 = fn_state.opc2;
        // D s_3762_1: cast zx s_3762_0 -> bv
        let s_3762_1: Bits = Bits::new(s_3762_0 as u128, 3u16);
        // C s_3762_2: const #4u : u8
        let s_3762_2: u8 = 4;
        // C s_3762_3: cast zx s_3762_2 -> bv
        let s_3762_3: Bits = Bits::new(s_3762_2 as u128, 3u16);
        // D s_3762_4: cmp-eq s_3762_1 s_3762_3
        let s_3762_4: bool = ((s_3762_1) == (s_3762_3));
        // D s_3762_5: write-var gs#119075 <= s_3762_4
        fn_state.gs_119075 = s_3762_4;
        // N s_3762_6: jump b3437
        return block_3437(state, tracer, fn_state);
    }
    fn block_3763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3763_0: read-var opc1:u8
        let s_3763_0: u8 = fn_state.opc1;
        // D s_3763_1: cast zx s_3763_0 -> bv
        let s_3763_1: Bits = Bits::new(s_3763_0 as u128, 3u16);
        // C s_3763_2: const #0u : u8
        let s_3763_2: u8 = 0;
        // C s_3763_3: cast zx s_3763_2 -> bv
        let s_3763_3: Bits = Bits::new(s_3763_2 as u128, 3u16);
        // D s_3763_4: cmp-eq s_3763_1 s_3763_3
        let s_3763_4: bool = ((s_3763_1) == (s_3763_3));
        // D s_3763_5: write-var gs#119074 <= s_3763_4
        fn_state.gs_119074 = s_3763_4;
        // N s_3763_6: jump b3435
        return block_3435(state, tracer, fn_state);
    }
    fn block_3764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3764_0: read-var coproc:u8
        let s_3764_0: u8 = fn_state.coproc;
        // D s_3764_1: cast zx s_3764_0 -> bv
        let s_3764_1: Bits = Bits::new(s_3764_0 as u128, 4u16);
        // C s_3764_2: const #15u : u8
        let s_3764_2: u8 = 15;
        // C s_3764_3: cast zx s_3764_2 -> bv
        let s_3764_3: Bits = Bits::new(s_3764_2 as u128, 4u16);
        // D s_3764_4: cmp-eq s_3764_1 s_3764_3
        let s_3764_4: bool = ((s_3764_1) == (s_3764_3));
        // D s_3764_5: write-var gs#119073 <= s_3764_4
        fn_state.gs_119073 = s_3764_4;
        // N s_3764_6: jump b3433
        return block_3433(state, tracer, fn_state);
    }
    fn block_3765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3765_0: read-var CRn:u8
        let s_3765_0: u8 = fn_state.CRn;
        // D s_3765_1: cast zx s_3765_0 -> bv
        let s_3765_1: Bits = Bits::new(s_3765_0 as u128, 4u16);
        // C s_3765_2: const #13u : u8
        let s_3765_2: u8 = 13;
        // C s_3765_3: cast zx s_3765_2 -> bv
        let s_3765_3: Bits = Bits::new(s_3765_2 as u128, 4u16);
        // D s_3765_4: cmp-eq s_3765_1 s_3765_3
        let s_3765_4: bool = ((s_3765_1) == (s_3765_3));
        // D s_3765_5: write-var gs#119072 <= s_3765_4
        fn_state.gs_119072 = s_3765_4;
        // N s_3765_6: jump b3431
        return block_3431(state, tracer, fn_state);
    }
    fn block_3766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3766_0: read-var el:u8
        let s_3766_0: u8 = fn_state.el;
        // D s_3766_1: read-var coproc:u8
        let s_3766_1: u8 = fn_state.coproc;
        // D s_3766_2: read-var opc1:u8
        let s_3766_2: u8 = fn_state.opc1;
        // D s_3766_3: read-var CRn:u8
        let s_3766_3: u8 = fn_state.CRn;
        // D s_3766_4: read-var opc2:u8
        let s_3766_4: u8 = fn_state.opc2;
        // D s_3766_5: read-var CRm:u8
        let s_3766_5: u8 = fn_state.CRm;
        // D s_3766_6: read-var t:i
        let s_3766_6: i128 = fn_state.t;
        // D s_3766_7: call AMCNTENSET0_SysRegRead32_941308a2fea42e28(s_3766_0, s_3766_1, s_3766_2, s_3766_3, s_3766_4, s_3766_5, s_3766_6)
        let s_3766_7: () = AMCNTENSET0_SysRegRead32_941308a2fea42e28(
            state,
            tracer,
            s_3766_0,
            s_3766_1,
            s_3766_2,
            s_3766_3,
            s_3766_4,
            s_3766_5,
            s_3766_6,
        );
        // N s_3766_8: return
        return;
    }
    fn block_3767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3767_0: read-var opc2:u8
        let s_3767_0: u8 = fn_state.opc2;
        // D s_3767_1: cast zx s_3767_0 -> bv
        let s_3767_1: Bits = Bits::new(s_3767_0 as u128, 3u16);
        // C s_3767_2: const #5u : u8
        let s_3767_2: u8 = 5;
        // C s_3767_3: cast zx s_3767_2 -> bv
        let s_3767_3: Bits = Bits::new(s_3767_2 as u128, 3u16);
        // D s_3767_4: cmp-eq s_3767_1 s_3767_3
        let s_3767_4: bool = ((s_3767_1) == (s_3767_3));
        // D s_3767_5: write-var gs#119071 <= s_3767_4
        fn_state.gs_119071 = s_3767_4;
        // N s_3767_6: jump b3428
        return block_3428(state, tracer, fn_state);
    }
    fn block_3768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3768_0: read-var opc1:u8
        let s_3768_0: u8 = fn_state.opc1;
        // D s_3768_1: cast zx s_3768_0 -> bv
        let s_3768_1: Bits = Bits::new(s_3768_0 as u128, 3u16);
        // C s_3768_2: const #0u : u8
        let s_3768_2: u8 = 0;
        // C s_3768_3: cast zx s_3768_2 -> bv
        let s_3768_3: Bits = Bits::new(s_3768_2 as u128, 3u16);
        // D s_3768_4: cmp-eq s_3768_1 s_3768_3
        let s_3768_4: bool = ((s_3768_1) == (s_3768_3));
        // D s_3768_5: write-var gs#119070 <= s_3768_4
        fn_state.gs_119070 = s_3768_4;
        // N s_3768_6: jump b3426
        return block_3426(state, tracer, fn_state);
    }
    fn block_3769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3769_0: read-var coproc:u8
        let s_3769_0: u8 = fn_state.coproc;
        // D s_3769_1: cast zx s_3769_0 -> bv
        let s_3769_1: Bits = Bits::new(s_3769_0 as u128, 4u16);
        // C s_3769_2: const #15u : u8
        let s_3769_2: u8 = 15;
        // C s_3769_3: cast zx s_3769_2 -> bv
        let s_3769_3: Bits = Bits::new(s_3769_2 as u128, 4u16);
        // D s_3769_4: cmp-eq s_3769_1 s_3769_3
        let s_3769_4: bool = ((s_3769_1) == (s_3769_3));
        // D s_3769_5: write-var gs#119069 <= s_3769_4
        fn_state.gs_119069 = s_3769_4;
        // N s_3769_6: jump b3424
        return block_3424(state, tracer, fn_state);
    }
    fn block_3770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3770_0: read-var CRn:u8
        let s_3770_0: u8 = fn_state.CRn;
        // D s_3770_1: cast zx s_3770_0 -> bv
        let s_3770_1: Bits = Bits::new(s_3770_0 as u128, 4u16);
        // C s_3770_2: const #13u : u8
        let s_3770_2: u8 = 13;
        // C s_3770_3: cast zx s_3770_2 -> bv
        let s_3770_3: Bits = Bits::new(s_3770_2 as u128, 4u16);
        // D s_3770_4: cmp-eq s_3770_1 s_3770_3
        let s_3770_4: bool = ((s_3770_1) == (s_3770_3));
        // D s_3770_5: write-var gs#119068 <= s_3770_4
        fn_state.gs_119068 = s_3770_4;
        // N s_3770_6: jump b3422
        return block_3422(state, tracer, fn_state);
    }
    fn block_3771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3771_0: read-var el:u8
        let s_3771_0: u8 = fn_state.el;
        // D s_3771_1: read-var coproc:u8
        let s_3771_1: u8 = fn_state.coproc;
        // D s_3771_2: read-var opc1:u8
        let s_3771_2: u8 = fn_state.opc1;
        // D s_3771_3: read-var CRn:u8
        let s_3771_3: u8 = fn_state.CRn;
        // D s_3771_4: read-var opc2:u8
        let s_3771_4: u8 = fn_state.opc2;
        // D s_3771_5: read-var CRm:u8
        let s_3771_5: u8 = fn_state.CRm;
        // D s_3771_6: read-var t:i
        let s_3771_6: i128 = fn_state.t;
        // D s_3771_7: call AMCNTENCLR1_SysRegRead32_d9e05aee283dea2c(s_3771_0, s_3771_1, s_3771_2, s_3771_3, s_3771_4, s_3771_5, s_3771_6)
        let s_3771_7: () = AMCNTENCLR1_SysRegRead32_d9e05aee283dea2c(
            state,
            tracer,
            s_3771_0,
            s_3771_1,
            s_3771_2,
            s_3771_3,
            s_3771_4,
            s_3771_5,
            s_3771_6,
        );
        // N s_3771_8: return
        return;
    }
    fn block_3772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3772_0: read-var opc2:u8
        let s_3772_0: u8 = fn_state.opc2;
        // D s_3772_1: cast zx s_3772_0 -> bv
        let s_3772_1: Bits = Bits::new(s_3772_0 as u128, 3u16);
        // C s_3772_2: const #0u : u8
        let s_3772_2: u8 = 0;
        // C s_3772_3: cast zx s_3772_2 -> bv
        let s_3772_3: Bits = Bits::new(s_3772_2 as u128, 3u16);
        // D s_3772_4: cmp-eq s_3772_1 s_3772_3
        let s_3772_4: bool = ((s_3772_1) == (s_3772_3));
        // D s_3772_5: write-var gs#119067 <= s_3772_4
        fn_state.gs_119067 = s_3772_4;
        // N s_3772_6: jump b3419
        return block_3419(state, tracer, fn_state);
    }
    fn block_3773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3773_0: read-var opc1:u8
        let s_3773_0: u8 = fn_state.opc1;
        // D s_3773_1: cast zx s_3773_0 -> bv
        let s_3773_1: Bits = Bits::new(s_3773_0 as u128, 3u16);
        // C s_3773_2: const #0u : u8
        let s_3773_2: u8 = 0;
        // C s_3773_3: cast zx s_3773_2 -> bv
        let s_3773_3: Bits = Bits::new(s_3773_2 as u128, 3u16);
        // D s_3773_4: cmp-eq s_3773_1 s_3773_3
        let s_3773_4: bool = ((s_3773_1) == (s_3773_3));
        // D s_3773_5: write-var gs#119066 <= s_3773_4
        fn_state.gs_119066 = s_3773_4;
        // N s_3773_6: jump b3417
        return block_3417(state, tracer, fn_state);
    }
    fn block_3774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3774_0: read-var coproc:u8
        let s_3774_0: u8 = fn_state.coproc;
        // D s_3774_1: cast zx s_3774_0 -> bv
        let s_3774_1: Bits = Bits::new(s_3774_0 as u128, 4u16);
        // C s_3774_2: const #15u : u8
        let s_3774_2: u8 = 15;
        // C s_3774_3: cast zx s_3774_2 -> bv
        let s_3774_3: Bits = Bits::new(s_3774_2 as u128, 4u16);
        // D s_3774_4: cmp-eq s_3774_1 s_3774_3
        let s_3774_4: bool = ((s_3774_1) == (s_3774_3));
        // D s_3774_5: write-var gs#119065 <= s_3774_4
        fn_state.gs_119065 = s_3774_4;
        // N s_3774_6: jump b3415
        return block_3415(state, tracer, fn_state);
    }
    fn block_3775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3775_0: read-var CRn:u8
        let s_3775_0: u8 = fn_state.CRn;
        // D s_3775_1: cast zx s_3775_0 -> bv
        let s_3775_1: Bits = Bits::new(s_3775_0 as u128, 4u16);
        // C s_3775_2: const #13u : u8
        let s_3775_2: u8 = 13;
        // C s_3775_3: cast zx s_3775_2 -> bv
        let s_3775_3: Bits = Bits::new(s_3775_2 as u128, 4u16);
        // D s_3775_4: cmp-eq s_3775_1 s_3775_3
        let s_3775_4: bool = ((s_3775_1) == (s_3775_3));
        // D s_3775_5: write-var gs#119064 <= s_3775_4
        fn_state.gs_119064 = s_3775_4;
        // N s_3775_6: jump b3413
        return block_3413(state, tracer, fn_state);
    }
    fn block_3776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3776_0: read-var el:u8
        let s_3776_0: u8 = fn_state.el;
        // D s_3776_1: read-var coproc:u8
        let s_3776_1: u8 = fn_state.coproc;
        // D s_3776_2: read-var opc1:u8
        let s_3776_2: u8 = fn_state.opc1;
        // D s_3776_3: read-var CRn:u8
        let s_3776_3: u8 = fn_state.CRn;
        // D s_3776_4: read-var opc2:u8
        let s_3776_4: u8 = fn_state.opc2;
        // D s_3776_5: read-var CRm:u8
        let s_3776_5: u8 = fn_state.CRm;
        // D s_3776_6: read-var t:i
        let s_3776_6: i128 = fn_state.t;
        // D s_3776_7: call AMCFGR_SysRegRead32_f4b1155615a324f5(s_3776_0, s_3776_1, s_3776_2, s_3776_3, s_3776_4, s_3776_5, s_3776_6)
        let s_3776_7: () = AMCFGR_SysRegRead32_f4b1155615a324f5(
            state,
            tracer,
            s_3776_0,
            s_3776_1,
            s_3776_2,
            s_3776_3,
            s_3776_4,
            s_3776_5,
            s_3776_6,
        );
        // N s_3776_8: return
        return;
    }
    fn block_3777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3777_0: read-var opc2:u8
        let s_3777_0: u8 = fn_state.opc2;
        // D s_3777_1: cast zx s_3777_0 -> bv
        let s_3777_1: Bits = Bits::new(s_3777_0 as u128, 3u16);
        // C s_3777_2: const #1u : u8
        let s_3777_2: u8 = 1;
        // C s_3777_3: cast zx s_3777_2 -> bv
        let s_3777_3: Bits = Bits::new(s_3777_2 as u128, 3u16);
        // D s_3777_4: cmp-eq s_3777_1 s_3777_3
        let s_3777_4: bool = ((s_3777_1) == (s_3777_3));
        // D s_3777_5: write-var gs#119063 <= s_3777_4
        fn_state.gs_119063 = s_3777_4;
        // N s_3777_6: jump b3410
        return block_3410(state, tracer, fn_state);
    }
    fn block_3778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3778_0: read-var opc1:u8
        let s_3778_0: u8 = fn_state.opc1;
        // D s_3778_1: cast zx s_3778_0 -> bv
        let s_3778_1: Bits = Bits::new(s_3778_0 as u128, 3u16);
        // C s_3778_2: const #0u : u8
        let s_3778_2: u8 = 0;
        // C s_3778_3: cast zx s_3778_2 -> bv
        let s_3778_3: Bits = Bits::new(s_3778_2 as u128, 3u16);
        // D s_3778_4: cmp-eq s_3778_1 s_3778_3
        let s_3778_4: bool = ((s_3778_1) == (s_3778_3));
        // D s_3778_5: write-var gs#119062 <= s_3778_4
        fn_state.gs_119062 = s_3778_4;
        // N s_3778_6: jump b3408
        return block_3408(state, tracer, fn_state);
    }
    fn block_3779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3779_0: read-var coproc:u8
        let s_3779_0: u8 = fn_state.coproc;
        // D s_3779_1: cast zx s_3779_0 -> bv
        let s_3779_1: Bits = Bits::new(s_3779_0 as u128, 4u16);
        // C s_3779_2: const #15u : u8
        let s_3779_2: u8 = 15;
        // C s_3779_3: cast zx s_3779_2 -> bv
        let s_3779_3: Bits = Bits::new(s_3779_2 as u128, 4u16);
        // D s_3779_4: cmp-eq s_3779_1 s_3779_3
        let s_3779_4: bool = ((s_3779_1) == (s_3779_3));
        // D s_3779_5: write-var gs#119061 <= s_3779_4
        fn_state.gs_119061 = s_3779_4;
        // N s_3779_6: jump b3406
        return block_3406(state, tracer, fn_state);
    }
    fn block_3780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3780_0: read-var CRn:u8
        let s_3780_0: u8 = fn_state.CRn;
        // D s_3780_1: cast zx s_3780_0 -> bv
        let s_3780_1: Bits = Bits::new(s_3780_0 as u128, 4u16);
        // C s_3780_2: const #13u : u8
        let s_3780_2: u8 = 13;
        // C s_3780_3: cast zx s_3780_2 -> bv
        let s_3780_3: Bits = Bits::new(s_3780_2 as u128, 4u16);
        // D s_3780_4: cmp-eq s_3780_1 s_3780_3
        let s_3780_4: bool = ((s_3780_1) == (s_3780_3));
        // D s_3780_5: write-var gs#119060 <= s_3780_4
        fn_state.gs_119060 = s_3780_4;
        // N s_3780_6: jump b3404
        return block_3404(state, tracer, fn_state);
    }
    fn block_3781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3781_0: read-var el:u8
        let s_3781_0: u8 = fn_state.el;
        // D s_3781_1: read-var coproc:u8
        let s_3781_1: u8 = fn_state.coproc;
        // D s_3781_2: read-var opc1:u8
        let s_3781_2: u8 = fn_state.opc1;
        // D s_3781_3: read-var CRn:u8
        let s_3781_3: u8 = fn_state.CRn;
        // D s_3781_4: read-var opc2:u8
        let s_3781_4: u8 = fn_state.opc2;
        // D s_3781_5: read-var CRm:u8
        let s_3781_5: u8 = fn_state.CRm;
        // D s_3781_6: read-var t:i
        let s_3781_6: i128 = fn_state.t;
        // D s_3781_7: call AMCGCR_SysRegRead32_ec0083efd88e8df5(s_3781_0, s_3781_1, s_3781_2, s_3781_3, s_3781_4, s_3781_5, s_3781_6)
        let s_3781_7: () = AMCGCR_SysRegRead32_ec0083efd88e8df5(
            state,
            tracer,
            s_3781_0,
            s_3781_1,
            s_3781_2,
            s_3781_3,
            s_3781_4,
            s_3781_5,
            s_3781_6,
        );
        // N s_3781_8: return
        return;
    }
    fn block_3782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3782_0: read-var opc2:u8
        let s_3782_0: u8 = fn_state.opc2;
        // D s_3782_1: cast zx s_3782_0 -> bv
        let s_3782_1: Bits = Bits::new(s_3782_0 as u128, 3u16);
        // C s_3782_2: const #2u : u8
        let s_3782_2: u8 = 2;
        // C s_3782_3: cast zx s_3782_2 -> bv
        let s_3782_3: Bits = Bits::new(s_3782_2 as u128, 3u16);
        // D s_3782_4: cmp-eq s_3782_1 s_3782_3
        let s_3782_4: bool = ((s_3782_1) == (s_3782_3));
        // D s_3782_5: write-var gs#119059 <= s_3782_4
        fn_state.gs_119059 = s_3782_4;
        // N s_3782_6: jump b3401
        return block_3401(state, tracer, fn_state);
    }
    fn block_3783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3783_0: read-var opc1:u8
        let s_3783_0: u8 = fn_state.opc1;
        // D s_3783_1: cast zx s_3783_0 -> bv
        let s_3783_1: Bits = Bits::new(s_3783_0 as u128, 3u16);
        // C s_3783_2: const #0u : u8
        let s_3783_2: u8 = 0;
        // C s_3783_3: cast zx s_3783_2 -> bv
        let s_3783_3: Bits = Bits::new(s_3783_2 as u128, 3u16);
        // D s_3783_4: cmp-eq s_3783_1 s_3783_3
        let s_3783_4: bool = ((s_3783_1) == (s_3783_3));
        // D s_3783_5: write-var gs#119058 <= s_3783_4
        fn_state.gs_119058 = s_3783_4;
        // N s_3783_6: jump b3399
        return block_3399(state, tracer, fn_state);
    }
    fn block_3784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3784_0: read-var coproc:u8
        let s_3784_0: u8 = fn_state.coproc;
        // D s_3784_1: cast zx s_3784_0 -> bv
        let s_3784_1: Bits = Bits::new(s_3784_0 as u128, 4u16);
        // C s_3784_2: const #15u : u8
        let s_3784_2: u8 = 15;
        // C s_3784_3: cast zx s_3784_2 -> bv
        let s_3784_3: Bits = Bits::new(s_3784_2 as u128, 4u16);
        // D s_3784_4: cmp-eq s_3784_1 s_3784_3
        let s_3784_4: bool = ((s_3784_1) == (s_3784_3));
        // D s_3784_5: write-var gs#119057 <= s_3784_4
        fn_state.gs_119057 = s_3784_4;
        // N s_3784_6: jump b3397
        return block_3397(state, tracer, fn_state);
    }
    fn block_3785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3785_0: read-var CRn:u8
        let s_3785_0: u8 = fn_state.CRn;
        // D s_3785_1: cast zx s_3785_0 -> bv
        let s_3785_1: Bits = Bits::new(s_3785_0 as u128, 4u16);
        // C s_3785_2: const #13u : u8
        let s_3785_2: u8 = 13;
        // C s_3785_3: cast zx s_3785_2 -> bv
        let s_3785_3: Bits = Bits::new(s_3785_2 as u128, 4u16);
        // D s_3785_4: cmp-eq s_3785_1 s_3785_3
        let s_3785_4: bool = ((s_3785_1) == (s_3785_3));
        // D s_3785_5: write-var gs#119056 <= s_3785_4
        fn_state.gs_119056 = s_3785_4;
        // N s_3785_6: jump b3395
        return block_3395(state, tracer, fn_state);
    }
    fn block_3786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3786_0: read-var el:u8
        let s_3786_0: u8 = fn_state.el;
        // D s_3786_1: read-var coproc:u8
        let s_3786_1: u8 = fn_state.coproc;
        // D s_3786_2: read-var opc1:u8
        let s_3786_2: u8 = fn_state.opc1;
        // D s_3786_3: read-var CRn:u8
        let s_3786_3: u8 = fn_state.CRn;
        // D s_3786_4: read-var opc2:u8
        let s_3786_4: u8 = fn_state.opc2;
        // D s_3786_5: read-var CRm:u8
        let s_3786_5: u8 = fn_state.CRm;
        // D s_3786_6: read-var t:i
        let s_3786_6: i128 = fn_state.t;
        // D s_3786_7: call AMEVTYPER1_SysRegRead32_a5bece13ef847a3b(s_3786_0, s_3786_1, s_3786_2, s_3786_3, s_3786_4, s_3786_5, s_3786_6)
        let s_3786_7: () = AMEVTYPER1_SysRegRead32_a5bece13ef847a3b(
            state,
            tracer,
            s_3786_0,
            s_3786_1,
            s_3786_2,
            s_3786_3,
            s_3786_4,
            s_3786_5,
            s_3786_6,
        );
        // N s_3786_8: return
        return;
    }
    fn block_3787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3787_0: read-var opc2:u8
        let s_3787_0: u8 = fn_state.opc2;
        // D s_3787_1: cast zx s_3787_0 -> bv
        let s_3787_1: Bits = Bits::new(s_3787_0 as u128, 3u16);
        // C s_3787_2: const #0u : u8
        let s_3787_2: u8 = 0;
        // C s_3787_3: cast zx s_3787_2 -> bv
        let s_3787_3: Bits = Bits::new(s_3787_2 as u128, 3u16);
        // D s_3787_4: cmp-eq s_3787_1 s_3787_3
        let s_3787_4: bool = ((s_3787_1) == (s_3787_3));
        // D s_3787_5: write-var gs#119055 <= s_3787_4
        fn_state.gs_119055 = s_3787_4;
        // N s_3787_6: jump b3392
        return block_3392(state, tracer, fn_state);
    }
    fn block_3788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3788_0: read-var opc1:u8
        let s_3788_0: u8 = fn_state.opc1;
        // D s_3788_1: cast zx s_3788_0 -> bv
        let s_3788_1: Bits = Bits::new(s_3788_0 as u128, 3u16);
        // C s_3788_2: const #0u : u8
        let s_3788_2: u8 = 0;
        // C s_3788_3: cast zx s_3788_2 -> bv
        let s_3788_3: Bits = Bits::new(s_3788_2 as u128, 3u16);
        // D s_3788_4: cmp-eq s_3788_1 s_3788_3
        let s_3788_4: bool = ((s_3788_1) == (s_3788_3));
        // D s_3788_5: write-var gs#119054 <= s_3788_4
        fn_state.gs_119054 = s_3788_4;
        // N s_3788_6: jump b3390
        return block_3390(state, tracer, fn_state);
    }
    fn block_3789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3789_0: read-var coproc:u8
        let s_3789_0: u8 = fn_state.coproc;
        // D s_3789_1: cast zx s_3789_0 -> bv
        let s_3789_1: Bits = Bits::new(s_3789_0 as u128, 4u16);
        // C s_3789_2: const #15u : u8
        let s_3789_2: u8 = 15;
        // C s_3789_3: cast zx s_3789_2 -> bv
        let s_3789_3: Bits = Bits::new(s_3789_2 as u128, 4u16);
        // D s_3789_4: cmp-eq s_3789_1 s_3789_3
        let s_3789_4: bool = ((s_3789_1) == (s_3789_3));
        // D s_3789_5: write-var gs#119053 <= s_3789_4
        fn_state.gs_119053 = s_3789_4;
        // N s_3789_6: jump b3388
        return block_3388(state, tracer, fn_state);
    }
    fn block_3790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3790_0: read-var CRn:u8
        let s_3790_0: u8 = fn_state.CRn;
        // D s_3790_1: cast zx s_3790_0 -> bv
        let s_3790_1: Bits = Bits::new(s_3790_0 as u128, 4u16);
        // C s_3790_2: const #13u : u8
        let s_3790_2: u8 = 13;
        // C s_3790_3: cast zx s_3790_2 -> bv
        let s_3790_3: Bits = Bits::new(s_3790_2 as u128, 4u16);
        // D s_3790_4: cmp-eq s_3790_1 s_3790_3
        let s_3790_4: bool = ((s_3790_1) == (s_3790_3));
        // D s_3790_5: write-var gs#119052 <= s_3790_4
        fn_state.gs_119052 = s_3790_4;
        // N s_3790_6: jump b3386
        return block_3386(state, tracer, fn_state);
    }
    fn block_3791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3791_0: read-var el:u8
        let s_3791_0: u8 = fn_state.el;
        // D s_3791_1: read-var coproc:u8
        let s_3791_1: u8 = fn_state.coproc;
        // D s_3791_2: read-var opc1:u8
        let s_3791_2: u8 = fn_state.opc1;
        // D s_3791_3: read-var CRn:u8
        let s_3791_3: u8 = fn_state.CRn;
        // D s_3791_4: read-var opc2:u8
        let s_3791_4: u8 = fn_state.opc2;
        // D s_3791_5: read-var CRm:u8
        let s_3791_5: u8 = fn_state.CRm;
        // D s_3791_6: read-var t:i
        let s_3791_6: i128 = fn_state.t;
        // D s_3791_7: call AMEVTYPER1_SysRegRead32_6862bf1fd0c624fa(s_3791_0, s_3791_1, s_3791_2, s_3791_3, s_3791_4, s_3791_5, s_3791_6)
        let s_3791_7: () = AMEVTYPER1_SysRegRead32_6862bf1fd0c624fa(
            state,
            tracer,
            s_3791_0,
            s_3791_1,
            s_3791_2,
            s_3791_3,
            s_3791_4,
            s_3791_5,
            s_3791_6,
        );
        // N s_3791_8: return
        return;
    }
    fn block_3792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3792_0: read-var opc2:u8
        let s_3792_0: u8 = fn_state.opc2;
        // D s_3792_1: cast zx s_3792_0 -> bv
        let s_3792_1: Bits = Bits::new(s_3792_0 as u128, 3u16);
        // C s_3792_2: const #1u : u8
        let s_3792_2: u8 = 1;
        // C s_3792_3: cast zx s_3792_2 -> bv
        let s_3792_3: Bits = Bits::new(s_3792_2 as u128, 3u16);
        // D s_3792_4: cmp-eq s_3792_1 s_3792_3
        let s_3792_4: bool = ((s_3792_1) == (s_3792_3));
        // D s_3792_5: write-var gs#119051 <= s_3792_4
        fn_state.gs_119051 = s_3792_4;
        // N s_3792_6: jump b3383
        return block_3383(state, tracer, fn_state);
    }
    fn block_3793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3793_0: read-var opc1:u8
        let s_3793_0: u8 = fn_state.opc1;
        // D s_3793_1: cast zx s_3793_0 -> bv
        let s_3793_1: Bits = Bits::new(s_3793_0 as u128, 3u16);
        // C s_3793_2: const #0u : u8
        let s_3793_2: u8 = 0;
        // C s_3793_3: cast zx s_3793_2 -> bv
        let s_3793_3: Bits = Bits::new(s_3793_2 as u128, 3u16);
        // D s_3793_4: cmp-eq s_3793_1 s_3793_3
        let s_3793_4: bool = ((s_3793_1) == (s_3793_3));
        // D s_3793_5: write-var gs#119050 <= s_3793_4
        fn_state.gs_119050 = s_3793_4;
        // N s_3793_6: jump b3381
        return block_3381(state, tracer, fn_state);
    }
    fn block_3794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3794_0: read-var coproc:u8
        let s_3794_0: u8 = fn_state.coproc;
        // D s_3794_1: cast zx s_3794_0 -> bv
        let s_3794_1: Bits = Bits::new(s_3794_0 as u128, 4u16);
        // C s_3794_2: const #15u : u8
        let s_3794_2: u8 = 15;
        // C s_3794_3: cast zx s_3794_2 -> bv
        let s_3794_3: Bits = Bits::new(s_3794_2 as u128, 4u16);
        // D s_3794_4: cmp-eq s_3794_1 s_3794_3
        let s_3794_4: bool = ((s_3794_1) == (s_3794_3));
        // D s_3794_5: write-var gs#119049 <= s_3794_4
        fn_state.gs_119049 = s_3794_4;
        // N s_3794_6: jump b3379
        return block_3379(state, tracer, fn_state);
    }
    fn block_3795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3795_0: read-var CRn:u8
        let s_3795_0: u8 = fn_state.CRn;
        // D s_3795_1: cast zx s_3795_0 -> bv
        let s_3795_1: Bits = Bits::new(s_3795_0 as u128, 4u16);
        // C s_3795_2: const #13u : u8
        let s_3795_2: u8 = 13;
        // C s_3795_3: cast zx s_3795_2 -> bv
        let s_3795_3: Bits = Bits::new(s_3795_2 as u128, 4u16);
        // D s_3795_4: cmp-eq s_3795_1 s_3795_3
        let s_3795_4: bool = ((s_3795_1) == (s_3795_3));
        // D s_3795_5: write-var gs#119048 <= s_3795_4
        fn_state.gs_119048 = s_3795_4;
        // N s_3795_6: jump b3377
        return block_3377(state, tracer, fn_state);
    }
    fn block_3796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3796_0: read-var el:u8
        let s_3796_0: u8 = fn_state.el;
        // D s_3796_1: read-var coproc:u8
        let s_3796_1: u8 = fn_state.coproc;
        // D s_3796_2: read-var opc1:u8
        let s_3796_2: u8 = fn_state.opc1;
        // D s_3796_3: read-var CRn:u8
        let s_3796_3: u8 = fn_state.CRn;
        // D s_3796_4: read-var opc2:u8
        let s_3796_4: u8 = fn_state.opc2;
        // D s_3796_5: read-var CRm:u8
        let s_3796_5: u8 = fn_state.CRm;
        // D s_3796_6: read-var t:i
        let s_3796_6: i128 = fn_state.t;
        // D s_3796_7: call AMEVTYPER1_SysRegRead32_3f1d2f749c9eacac(s_3796_0, s_3796_1, s_3796_2, s_3796_3, s_3796_4, s_3796_5, s_3796_6)
        let s_3796_7: () = AMEVTYPER1_SysRegRead32_3f1d2f749c9eacac(
            state,
            tracer,
            s_3796_0,
            s_3796_1,
            s_3796_2,
            s_3796_3,
            s_3796_4,
            s_3796_5,
            s_3796_6,
        );
        // N s_3796_8: return
        return;
    }
    fn block_3797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3797_0: read-var opc2:u8
        let s_3797_0: u8 = fn_state.opc2;
        // D s_3797_1: cast zx s_3797_0 -> bv
        let s_3797_1: Bits = Bits::new(s_3797_0 as u128, 3u16);
        // C s_3797_2: const #2u : u8
        let s_3797_2: u8 = 2;
        // C s_3797_3: cast zx s_3797_2 -> bv
        let s_3797_3: Bits = Bits::new(s_3797_2 as u128, 3u16);
        // D s_3797_4: cmp-eq s_3797_1 s_3797_3
        let s_3797_4: bool = ((s_3797_1) == (s_3797_3));
        // D s_3797_5: write-var gs#119047 <= s_3797_4
        fn_state.gs_119047 = s_3797_4;
        // N s_3797_6: jump b3374
        return block_3374(state, tracer, fn_state);
    }
    fn block_3798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3798_0: read-var opc1:u8
        let s_3798_0: u8 = fn_state.opc1;
        // D s_3798_1: cast zx s_3798_0 -> bv
        let s_3798_1: Bits = Bits::new(s_3798_0 as u128, 3u16);
        // C s_3798_2: const #0u : u8
        let s_3798_2: u8 = 0;
        // C s_3798_3: cast zx s_3798_2 -> bv
        let s_3798_3: Bits = Bits::new(s_3798_2 as u128, 3u16);
        // D s_3798_4: cmp-eq s_3798_1 s_3798_3
        let s_3798_4: bool = ((s_3798_1) == (s_3798_3));
        // D s_3798_5: write-var gs#119046 <= s_3798_4
        fn_state.gs_119046 = s_3798_4;
        // N s_3798_6: jump b3372
        return block_3372(state, tracer, fn_state);
    }
    fn block_3799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3799_0: read-var coproc:u8
        let s_3799_0: u8 = fn_state.coproc;
        // D s_3799_1: cast zx s_3799_0 -> bv
        let s_3799_1: Bits = Bits::new(s_3799_0 as u128, 4u16);
        // C s_3799_2: const #15u : u8
        let s_3799_2: u8 = 15;
        // C s_3799_3: cast zx s_3799_2 -> bv
        let s_3799_3: Bits = Bits::new(s_3799_2 as u128, 4u16);
        // D s_3799_4: cmp-eq s_3799_1 s_3799_3
        let s_3799_4: bool = ((s_3799_1) == (s_3799_3));
        // D s_3799_5: write-var gs#119045 <= s_3799_4
        fn_state.gs_119045 = s_3799_4;
        // N s_3799_6: jump b3370
        return block_3370(state, tracer, fn_state);
    }
    fn block_3800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3800_0: read-var CRn:u8
        let s_3800_0: u8 = fn_state.CRn;
        // D s_3800_1: cast zx s_3800_0 -> bv
        let s_3800_1: Bits = Bits::new(s_3800_0 as u128, 4u16);
        // C s_3800_2: const #13u : u8
        let s_3800_2: u8 = 13;
        // C s_3800_3: cast zx s_3800_2 -> bv
        let s_3800_3: Bits = Bits::new(s_3800_2 as u128, 4u16);
        // D s_3800_4: cmp-eq s_3800_1 s_3800_3
        let s_3800_4: bool = ((s_3800_1) == (s_3800_3));
        // D s_3800_5: write-var gs#119044 <= s_3800_4
        fn_state.gs_119044 = s_3800_4;
        // N s_3800_6: jump b3368
        return block_3368(state, tracer, fn_state);
    }
    fn block_3801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3801_0: read-var el:u8
        let s_3801_0: u8 = fn_state.el;
        // D s_3801_1: read-var coproc:u8
        let s_3801_1: u8 = fn_state.coproc;
        // D s_3801_2: read-var opc1:u8
        let s_3801_2: u8 = fn_state.opc1;
        // D s_3801_3: read-var CRn:u8
        let s_3801_3: u8 = fn_state.CRn;
        // D s_3801_4: read-var opc2:u8
        let s_3801_4: u8 = fn_state.opc2;
        // D s_3801_5: read-var CRm:u8
        let s_3801_5: u8 = fn_state.CRm;
        // D s_3801_6: read-var t:i
        let s_3801_6: i128 = fn_state.t;
        // D s_3801_7: call AMEVTYPER1_SysRegRead32_5da5d2022384b9e4(s_3801_0, s_3801_1, s_3801_2, s_3801_3, s_3801_4, s_3801_5, s_3801_6)
        let s_3801_7: () = AMEVTYPER1_SysRegRead32_5da5d2022384b9e4(
            state,
            tracer,
            s_3801_0,
            s_3801_1,
            s_3801_2,
            s_3801_3,
            s_3801_4,
            s_3801_5,
            s_3801_6,
        );
        // N s_3801_8: return
        return;
    }
    fn block_3802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3802_0: read-var opc2:u8
        let s_3802_0: u8 = fn_state.opc2;
        // D s_3802_1: cast zx s_3802_0 -> bv
        let s_3802_1: Bits = Bits::new(s_3802_0 as u128, 3u16);
        // C s_3802_2: const #3u : u8
        let s_3802_2: u8 = 3;
        // C s_3802_3: cast zx s_3802_2 -> bv
        let s_3802_3: Bits = Bits::new(s_3802_2 as u128, 3u16);
        // D s_3802_4: cmp-eq s_3802_1 s_3802_3
        let s_3802_4: bool = ((s_3802_1) == (s_3802_3));
        // D s_3802_5: write-var gs#119043 <= s_3802_4
        fn_state.gs_119043 = s_3802_4;
        // N s_3802_6: jump b3365
        return block_3365(state, tracer, fn_state);
    }
    fn block_3803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3803_0: read-var opc1:u8
        let s_3803_0: u8 = fn_state.opc1;
        // D s_3803_1: cast zx s_3803_0 -> bv
        let s_3803_1: Bits = Bits::new(s_3803_0 as u128, 3u16);
        // C s_3803_2: const #0u : u8
        let s_3803_2: u8 = 0;
        // C s_3803_3: cast zx s_3803_2 -> bv
        let s_3803_3: Bits = Bits::new(s_3803_2 as u128, 3u16);
        // D s_3803_4: cmp-eq s_3803_1 s_3803_3
        let s_3803_4: bool = ((s_3803_1) == (s_3803_3));
        // D s_3803_5: write-var gs#119042 <= s_3803_4
        fn_state.gs_119042 = s_3803_4;
        // N s_3803_6: jump b3363
        return block_3363(state, tracer, fn_state);
    }
    fn block_3804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3804_0: read-var coproc:u8
        let s_3804_0: u8 = fn_state.coproc;
        // D s_3804_1: cast zx s_3804_0 -> bv
        let s_3804_1: Bits = Bits::new(s_3804_0 as u128, 4u16);
        // C s_3804_2: const #15u : u8
        let s_3804_2: u8 = 15;
        // C s_3804_3: cast zx s_3804_2 -> bv
        let s_3804_3: Bits = Bits::new(s_3804_2 as u128, 4u16);
        // D s_3804_4: cmp-eq s_3804_1 s_3804_3
        let s_3804_4: bool = ((s_3804_1) == (s_3804_3));
        // D s_3804_5: write-var gs#119041 <= s_3804_4
        fn_state.gs_119041 = s_3804_4;
        // N s_3804_6: jump b3361
        return block_3361(state, tracer, fn_state);
    }
    fn block_3805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3805_0: read-var CRn:u8
        let s_3805_0: u8 = fn_state.CRn;
        // D s_3805_1: cast zx s_3805_0 -> bv
        let s_3805_1: Bits = Bits::new(s_3805_0 as u128, 4u16);
        // C s_3805_2: const #13u : u8
        let s_3805_2: u8 = 13;
        // C s_3805_3: cast zx s_3805_2 -> bv
        let s_3805_3: Bits = Bits::new(s_3805_2 as u128, 4u16);
        // D s_3805_4: cmp-eq s_3805_1 s_3805_3
        let s_3805_4: bool = ((s_3805_1) == (s_3805_3));
        // D s_3805_5: write-var gs#119040 <= s_3805_4
        fn_state.gs_119040 = s_3805_4;
        // N s_3805_6: jump b3359
        return block_3359(state, tracer, fn_state);
    }
    fn block_3806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3806_0: read-var el:u8
        let s_3806_0: u8 = fn_state.el;
        // D s_3806_1: read-var coproc:u8
        let s_3806_1: u8 = fn_state.coproc;
        // D s_3806_2: read-var opc1:u8
        let s_3806_2: u8 = fn_state.opc1;
        // D s_3806_3: read-var CRn:u8
        let s_3806_3: u8 = fn_state.CRn;
        // D s_3806_4: read-var opc2:u8
        let s_3806_4: u8 = fn_state.opc2;
        // D s_3806_5: read-var CRm:u8
        let s_3806_5: u8 = fn_state.CRm;
        // D s_3806_6: read-var t:i
        let s_3806_6: i128 = fn_state.t;
        // D s_3806_7: call AMEVTYPER1_SysRegRead32_bc839289c9bacd64(s_3806_0, s_3806_1, s_3806_2, s_3806_3, s_3806_4, s_3806_5, s_3806_6)
        let s_3806_7: () = AMEVTYPER1_SysRegRead32_bc839289c9bacd64(
            state,
            tracer,
            s_3806_0,
            s_3806_1,
            s_3806_2,
            s_3806_3,
            s_3806_4,
            s_3806_5,
            s_3806_6,
        );
        // N s_3806_8: return
        return;
    }
    fn block_3807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3807_0: read-var opc2:u8
        let s_3807_0: u8 = fn_state.opc2;
        // D s_3807_1: cast zx s_3807_0 -> bv
        let s_3807_1: Bits = Bits::new(s_3807_0 as u128, 3u16);
        // C s_3807_2: const #4u : u8
        let s_3807_2: u8 = 4;
        // C s_3807_3: cast zx s_3807_2 -> bv
        let s_3807_3: Bits = Bits::new(s_3807_2 as u128, 3u16);
        // D s_3807_4: cmp-eq s_3807_1 s_3807_3
        let s_3807_4: bool = ((s_3807_1) == (s_3807_3));
        // D s_3807_5: write-var gs#119039 <= s_3807_4
        fn_state.gs_119039 = s_3807_4;
        // N s_3807_6: jump b3356
        return block_3356(state, tracer, fn_state);
    }
    fn block_3808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3808_0: read-var opc1:u8
        let s_3808_0: u8 = fn_state.opc1;
        // D s_3808_1: cast zx s_3808_0 -> bv
        let s_3808_1: Bits = Bits::new(s_3808_0 as u128, 3u16);
        // C s_3808_2: const #0u : u8
        let s_3808_2: u8 = 0;
        // C s_3808_3: cast zx s_3808_2 -> bv
        let s_3808_3: Bits = Bits::new(s_3808_2 as u128, 3u16);
        // D s_3808_4: cmp-eq s_3808_1 s_3808_3
        let s_3808_4: bool = ((s_3808_1) == (s_3808_3));
        // D s_3808_5: write-var gs#119038 <= s_3808_4
        fn_state.gs_119038 = s_3808_4;
        // N s_3808_6: jump b3354
        return block_3354(state, tracer, fn_state);
    }
    fn block_3809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3809_0: read-var coproc:u8
        let s_3809_0: u8 = fn_state.coproc;
        // D s_3809_1: cast zx s_3809_0 -> bv
        let s_3809_1: Bits = Bits::new(s_3809_0 as u128, 4u16);
        // C s_3809_2: const #15u : u8
        let s_3809_2: u8 = 15;
        // C s_3809_3: cast zx s_3809_2 -> bv
        let s_3809_3: Bits = Bits::new(s_3809_2 as u128, 4u16);
        // D s_3809_4: cmp-eq s_3809_1 s_3809_3
        let s_3809_4: bool = ((s_3809_1) == (s_3809_3));
        // D s_3809_5: write-var gs#119037 <= s_3809_4
        fn_state.gs_119037 = s_3809_4;
        // N s_3809_6: jump b3352
        return block_3352(state, tracer, fn_state);
    }
    fn block_3810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3810_0: read-var CRn:u8
        let s_3810_0: u8 = fn_state.CRn;
        // D s_3810_1: cast zx s_3810_0 -> bv
        let s_3810_1: Bits = Bits::new(s_3810_0 as u128, 4u16);
        // C s_3810_2: const #13u : u8
        let s_3810_2: u8 = 13;
        // C s_3810_3: cast zx s_3810_2 -> bv
        let s_3810_3: Bits = Bits::new(s_3810_2 as u128, 4u16);
        // D s_3810_4: cmp-eq s_3810_1 s_3810_3
        let s_3810_4: bool = ((s_3810_1) == (s_3810_3));
        // D s_3810_5: write-var gs#119036 <= s_3810_4
        fn_state.gs_119036 = s_3810_4;
        // N s_3810_6: jump b3350
        return block_3350(state, tracer, fn_state);
    }
    fn block_3811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3811_0: read-var el:u8
        let s_3811_0: u8 = fn_state.el;
        // D s_3811_1: read-var coproc:u8
        let s_3811_1: u8 = fn_state.coproc;
        // D s_3811_2: read-var opc1:u8
        let s_3811_2: u8 = fn_state.opc1;
        // D s_3811_3: read-var CRn:u8
        let s_3811_3: u8 = fn_state.CRn;
        // D s_3811_4: read-var opc2:u8
        let s_3811_4: u8 = fn_state.opc2;
        // D s_3811_5: read-var CRm:u8
        let s_3811_5: u8 = fn_state.CRm;
        // D s_3811_6: read-var t:i
        let s_3811_6: i128 = fn_state.t;
        // D s_3811_7: call AMEVTYPER1_SysRegRead32_aefd3ad06352acdf(s_3811_0, s_3811_1, s_3811_2, s_3811_3, s_3811_4, s_3811_5, s_3811_6)
        let s_3811_7: () = AMEVTYPER1_SysRegRead32_aefd3ad06352acdf(
            state,
            tracer,
            s_3811_0,
            s_3811_1,
            s_3811_2,
            s_3811_3,
            s_3811_4,
            s_3811_5,
            s_3811_6,
        );
        // N s_3811_8: return
        return;
    }
    fn block_3812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3812_0: read-var opc2:u8
        let s_3812_0: u8 = fn_state.opc2;
        // D s_3812_1: cast zx s_3812_0 -> bv
        let s_3812_1: Bits = Bits::new(s_3812_0 as u128, 3u16);
        // C s_3812_2: const #5u : u8
        let s_3812_2: u8 = 5;
        // C s_3812_3: cast zx s_3812_2 -> bv
        let s_3812_3: Bits = Bits::new(s_3812_2 as u128, 3u16);
        // D s_3812_4: cmp-eq s_3812_1 s_3812_3
        let s_3812_4: bool = ((s_3812_1) == (s_3812_3));
        // D s_3812_5: write-var gs#119035 <= s_3812_4
        fn_state.gs_119035 = s_3812_4;
        // N s_3812_6: jump b3347
        return block_3347(state, tracer, fn_state);
    }
    fn block_3813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3813_0: read-var opc1:u8
        let s_3813_0: u8 = fn_state.opc1;
        // D s_3813_1: cast zx s_3813_0 -> bv
        let s_3813_1: Bits = Bits::new(s_3813_0 as u128, 3u16);
        // C s_3813_2: const #0u : u8
        let s_3813_2: u8 = 0;
        // C s_3813_3: cast zx s_3813_2 -> bv
        let s_3813_3: Bits = Bits::new(s_3813_2 as u128, 3u16);
        // D s_3813_4: cmp-eq s_3813_1 s_3813_3
        let s_3813_4: bool = ((s_3813_1) == (s_3813_3));
        // D s_3813_5: write-var gs#119034 <= s_3813_4
        fn_state.gs_119034 = s_3813_4;
        // N s_3813_6: jump b3345
        return block_3345(state, tracer, fn_state);
    }
    fn block_3814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3814_0: read-var coproc:u8
        let s_3814_0: u8 = fn_state.coproc;
        // D s_3814_1: cast zx s_3814_0 -> bv
        let s_3814_1: Bits = Bits::new(s_3814_0 as u128, 4u16);
        // C s_3814_2: const #15u : u8
        let s_3814_2: u8 = 15;
        // C s_3814_3: cast zx s_3814_2 -> bv
        let s_3814_3: Bits = Bits::new(s_3814_2 as u128, 4u16);
        // D s_3814_4: cmp-eq s_3814_1 s_3814_3
        let s_3814_4: bool = ((s_3814_1) == (s_3814_3));
        // D s_3814_5: write-var gs#119033 <= s_3814_4
        fn_state.gs_119033 = s_3814_4;
        // N s_3814_6: jump b3343
        return block_3343(state, tracer, fn_state);
    }
    fn block_3815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3815_0: read-var CRn:u8
        let s_3815_0: u8 = fn_state.CRn;
        // D s_3815_1: cast zx s_3815_0 -> bv
        let s_3815_1: Bits = Bits::new(s_3815_0 as u128, 4u16);
        // C s_3815_2: const #13u : u8
        let s_3815_2: u8 = 13;
        // C s_3815_3: cast zx s_3815_2 -> bv
        let s_3815_3: Bits = Bits::new(s_3815_2 as u128, 4u16);
        // D s_3815_4: cmp-eq s_3815_1 s_3815_3
        let s_3815_4: bool = ((s_3815_1) == (s_3815_3));
        // D s_3815_5: write-var gs#119032 <= s_3815_4
        fn_state.gs_119032 = s_3815_4;
        // N s_3815_6: jump b3341
        return block_3341(state, tracer, fn_state);
    }
    fn block_3816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3816_0: read-var el:u8
        let s_3816_0: u8 = fn_state.el;
        // D s_3816_1: read-var coproc:u8
        let s_3816_1: u8 = fn_state.coproc;
        // D s_3816_2: read-var opc1:u8
        let s_3816_2: u8 = fn_state.opc1;
        // D s_3816_3: read-var CRn:u8
        let s_3816_3: u8 = fn_state.CRn;
        // D s_3816_4: read-var opc2:u8
        let s_3816_4: u8 = fn_state.opc2;
        // D s_3816_5: read-var CRm:u8
        let s_3816_5: u8 = fn_state.CRm;
        // D s_3816_6: read-var t:i
        let s_3816_6: i128 = fn_state.t;
        // D s_3816_7: call AMEVTYPER1_SysRegRead32_d76669b6678fb9d9(s_3816_0, s_3816_1, s_3816_2, s_3816_3, s_3816_4, s_3816_5, s_3816_6)
        let s_3816_7: () = AMEVTYPER1_SysRegRead32_d76669b6678fb9d9(
            state,
            tracer,
            s_3816_0,
            s_3816_1,
            s_3816_2,
            s_3816_3,
            s_3816_4,
            s_3816_5,
            s_3816_6,
        );
        // N s_3816_8: return
        return;
    }
    fn block_3817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3817_0: read-var opc2:u8
        let s_3817_0: u8 = fn_state.opc2;
        // D s_3817_1: cast zx s_3817_0 -> bv
        let s_3817_1: Bits = Bits::new(s_3817_0 as u128, 3u16);
        // C s_3817_2: const #6u : u8
        let s_3817_2: u8 = 6;
        // C s_3817_3: cast zx s_3817_2 -> bv
        let s_3817_3: Bits = Bits::new(s_3817_2 as u128, 3u16);
        // D s_3817_4: cmp-eq s_3817_1 s_3817_3
        let s_3817_4: bool = ((s_3817_1) == (s_3817_3));
        // D s_3817_5: write-var gs#119031 <= s_3817_4
        fn_state.gs_119031 = s_3817_4;
        // N s_3817_6: jump b3338
        return block_3338(state, tracer, fn_state);
    }
    fn block_3818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3818_0: read-var opc1:u8
        let s_3818_0: u8 = fn_state.opc1;
        // D s_3818_1: cast zx s_3818_0 -> bv
        let s_3818_1: Bits = Bits::new(s_3818_0 as u128, 3u16);
        // C s_3818_2: const #0u : u8
        let s_3818_2: u8 = 0;
        // C s_3818_3: cast zx s_3818_2 -> bv
        let s_3818_3: Bits = Bits::new(s_3818_2 as u128, 3u16);
        // D s_3818_4: cmp-eq s_3818_1 s_3818_3
        let s_3818_4: bool = ((s_3818_1) == (s_3818_3));
        // D s_3818_5: write-var gs#119030 <= s_3818_4
        fn_state.gs_119030 = s_3818_4;
        // N s_3818_6: jump b3336
        return block_3336(state, tracer, fn_state);
    }
    fn block_3819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3819_0: read-var coproc:u8
        let s_3819_0: u8 = fn_state.coproc;
        // D s_3819_1: cast zx s_3819_0 -> bv
        let s_3819_1: Bits = Bits::new(s_3819_0 as u128, 4u16);
        // C s_3819_2: const #15u : u8
        let s_3819_2: u8 = 15;
        // C s_3819_3: cast zx s_3819_2 -> bv
        let s_3819_3: Bits = Bits::new(s_3819_2 as u128, 4u16);
        // D s_3819_4: cmp-eq s_3819_1 s_3819_3
        let s_3819_4: bool = ((s_3819_1) == (s_3819_3));
        // D s_3819_5: write-var gs#119029 <= s_3819_4
        fn_state.gs_119029 = s_3819_4;
        // N s_3819_6: jump b3334
        return block_3334(state, tracer, fn_state);
    }
    fn block_3820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3820_0: read-var CRn:u8
        let s_3820_0: u8 = fn_state.CRn;
        // D s_3820_1: cast zx s_3820_0 -> bv
        let s_3820_1: Bits = Bits::new(s_3820_0 as u128, 4u16);
        // C s_3820_2: const #13u : u8
        let s_3820_2: u8 = 13;
        // C s_3820_3: cast zx s_3820_2 -> bv
        let s_3820_3: Bits = Bits::new(s_3820_2 as u128, 4u16);
        // D s_3820_4: cmp-eq s_3820_1 s_3820_3
        let s_3820_4: bool = ((s_3820_1) == (s_3820_3));
        // D s_3820_5: write-var gs#119028 <= s_3820_4
        fn_state.gs_119028 = s_3820_4;
        // N s_3820_6: jump b3332
        return block_3332(state, tracer, fn_state);
    }
    fn block_3821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3821_0: read-var el:u8
        let s_3821_0: u8 = fn_state.el;
        // D s_3821_1: read-var coproc:u8
        let s_3821_1: u8 = fn_state.coproc;
        // D s_3821_2: read-var opc1:u8
        let s_3821_2: u8 = fn_state.opc1;
        // D s_3821_3: read-var CRn:u8
        let s_3821_3: u8 = fn_state.CRn;
        // D s_3821_4: read-var opc2:u8
        let s_3821_4: u8 = fn_state.opc2;
        // D s_3821_5: read-var CRm:u8
        let s_3821_5: u8 = fn_state.CRm;
        // D s_3821_6: read-var t:i
        let s_3821_6: i128 = fn_state.t;
        // D s_3821_7: call AMEVTYPER1_SysRegRead32_e5dbca925a693d3a(s_3821_0, s_3821_1, s_3821_2, s_3821_3, s_3821_4, s_3821_5, s_3821_6)
        let s_3821_7: () = AMEVTYPER1_SysRegRead32_e5dbca925a693d3a(
            state,
            tracer,
            s_3821_0,
            s_3821_1,
            s_3821_2,
            s_3821_3,
            s_3821_4,
            s_3821_5,
            s_3821_6,
        );
        // N s_3821_8: return
        return;
    }
    fn block_3822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3822_0: read-var opc2:u8
        let s_3822_0: u8 = fn_state.opc2;
        // D s_3822_1: cast zx s_3822_0 -> bv
        let s_3822_1: Bits = Bits::new(s_3822_0 as u128, 3u16);
        // C s_3822_2: const #7u : u8
        let s_3822_2: u8 = 7;
        // C s_3822_3: cast zx s_3822_2 -> bv
        let s_3822_3: Bits = Bits::new(s_3822_2 as u128, 3u16);
        // D s_3822_4: cmp-eq s_3822_1 s_3822_3
        let s_3822_4: bool = ((s_3822_1) == (s_3822_3));
        // D s_3822_5: write-var gs#119027 <= s_3822_4
        fn_state.gs_119027 = s_3822_4;
        // N s_3822_6: jump b3329
        return block_3329(state, tracer, fn_state);
    }
    fn block_3823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3823_0: read-var opc1:u8
        let s_3823_0: u8 = fn_state.opc1;
        // D s_3823_1: cast zx s_3823_0 -> bv
        let s_3823_1: Bits = Bits::new(s_3823_0 as u128, 3u16);
        // C s_3823_2: const #0u : u8
        let s_3823_2: u8 = 0;
        // C s_3823_3: cast zx s_3823_2 -> bv
        let s_3823_3: Bits = Bits::new(s_3823_2 as u128, 3u16);
        // D s_3823_4: cmp-eq s_3823_1 s_3823_3
        let s_3823_4: bool = ((s_3823_1) == (s_3823_3));
        // D s_3823_5: write-var gs#119026 <= s_3823_4
        fn_state.gs_119026 = s_3823_4;
        // N s_3823_6: jump b3327
        return block_3327(state, tracer, fn_state);
    }
    fn block_3824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3824_0: read-var coproc:u8
        let s_3824_0: u8 = fn_state.coproc;
        // D s_3824_1: cast zx s_3824_0 -> bv
        let s_3824_1: Bits = Bits::new(s_3824_0 as u128, 4u16);
        // C s_3824_2: const #15u : u8
        let s_3824_2: u8 = 15;
        // C s_3824_3: cast zx s_3824_2 -> bv
        let s_3824_3: Bits = Bits::new(s_3824_2 as u128, 4u16);
        // D s_3824_4: cmp-eq s_3824_1 s_3824_3
        let s_3824_4: bool = ((s_3824_1) == (s_3824_3));
        // D s_3824_5: write-var gs#119025 <= s_3824_4
        fn_state.gs_119025 = s_3824_4;
        // N s_3824_6: jump b3325
        return block_3325(state, tracer, fn_state);
    }
    fn block_3825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3825_0: read-var CRn:u8
        let s_3825_0: u8 = fn_state.CRn;
        // D s_3825_1: cast zx s_3825_0 -> bv
        let s_3825_1: Bits = Bits::new(s_3825_0 as u128, 4u16);
        // C s_3825_2: const #13u : u8
        let s_3825_2: u8 = 13;
        // C s_3825_3: cast zx s_3825_2 -> bv
        let s_3825_3: Bits = Bits::new(s_3825_2 as u128, 4u16);
        // D s_3825_4: cmp-eq s_3825_1 s_3825_3
        let s_3825_4: bool = ((s_3825_1) == (s_3825_3));
        // D s_3825_5: write-var gs#119024 <= s_3825_4
        fn_state.gs_119024 = s_3825_4;
        // N s_3825_6: jump b3323
        return block_3323(state, tracer, fn_state);
    }
    fn block_3826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3826_0: read-var el:u8
        let s_3826_0: u8 = fn_state.el;
        // D s_3826_1: read-var coproc:u8
        let s_3826_1: u8 = fn_state.coproc;
        // D s_3826_2: read-var opc1:u8
        let s_3826_2: u8 = fn_state.opc1;
        // D s_3826_3: read-var CRn:u8
        let s_3826_3: u8 = fn_state.CRn;
        // D s_3826_4: read-var opc2:u8
        let s_3826_4: u8 = fn_state.opc2;
        // D s_3826_5: read-var CRm:u8
        let s_3826_5: u8 = fn_state.CRm;
        // D s_3826_6: read-var t:i
        let s_3826_6: i128 = fn_state.t;
        // D s_3826_7: call AMEVTYPER1_SysRegRead32_72835fc6dfc4b11f(s_3826_0, s_3826_1, s_3826_2, s_3826_3, s_3826_4, s_3826_5, s_3826_6)
        let s_3826_7: () = AMEVTYPER1_SysRegRead32_72835fc6dfc4b11f(
            state,
            tracer,
            s_3826_0,
            s_3826_1,
            s_3826_2,
            s_3826_3,
            s_3826_4,
            s_3826_5,
            s_3826_6,
        );
        // N s_3826_8: return
        return;
    }
    fn block_3827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3827_0: read-var opc2:u8
        let s_3827_0: u8 = fn_state.opc2;
        // D s_3827_1: cast zx s_3827_0 -> bv
        let s_3827_1: Bits = Bits::new(s_3827_0 as u128, 3u16);
        // C s_3827_2: const #0u : u8
        let s_3827_2: u8 = 0;
        // C s_3827_3: cast zx s_3827_2 -> bv
        let s_3827_3: Bits = Bits::new(s_3827_2 as u128, 3u16);
        // D s_3827_4: cmp-eq s_3827_1 s_3827_3
        let s_3827_4: bool = ((s_3827_1) == (s_3827_3));
        // D s_3827_5: write-var gs#119023 <= s_3827_4
        fn_state.gs_119023 = s_3827_4;
        // N s_3827_6: jump b3320
        return block_3320(state, tracer, fn_state);
    }
    fn block_3828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3828_0: read-var opc1:u8
        let s_3828_0: u8 = fn_state.opc1;
        // D s_3828_1: cast zx s_3828_0 -> bv
        let s_3828_1: Bits = Bits::new(s_3828_0 as u128, 3u16);
        // C s_3828_2: const #0u : u8
        let s_3828_2: u8 = 0;
        // C s_3828_3: cast zx s_3828_2 -> bv
        let s_3828_3: Bits = Bits::new(s_3828_2 as u128, 3u16);
        // D s_3828_4: cmp-eq s_3828_1 s_3828_3
        let s_3828_4: bool = ((s_3828_1) == (s_3828_3));
        // D s_3828_5: write-var gs#119022 <= s_3828_4
        fn_state.gs_119022 = s_3828_4;
        // N s_3828_6: jump b3318
        return block_3318(state, tracer, fn_state);
    }
    fn block_3829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3829_0: read-var coproc:u8
        let s_3829_0: u8 = fn_state.coproc;
        // D s_3829_1: cast zx s_3829_0 -> bv
        let s_3829_1: Bits = Bits::new(s_3829_0 as u128, 4u16);
        // C s_3829_2: const #15u : u8
        let s_3829_2: u8 = 15;
        // C s_3829_3: cast zx s_3829_2 -> bv
        let s_3829_3: Bits = Bits::new(s_3829_2 as u128, 4u16);
        // D s_3829_4: cmp-eq s_3829_1 s_3829_3
        let s_3829_4: bool = ((s_3829_1) == (s_3829_3));
        // D s_3829_5: write-var gs#119021 <= s_3829_4
        fn_state.gs_119021 = s_3829_4;
        // N s_3829_6: jump b3316
        return block_3316(state, tracer, fn_state);
    }
    fn block_3830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3830_0: read-var CRn:u8
        let s_3830_0: u8 = fn_state.CRn;
        // D s_3830_1: cast zx s_3830_0 -> bv
        let s_3830_1: Bits = Bits::new(s_3830_0 as u128, 4u16);
        // C s_3830_2: const #13u : u8
        let s_3830_2: u8 = 13;
        // C s_3830_3: cast zx s_3830_2 -> bv
        let s_3830_3: Bits = Bits::new(s_3830_2 as u128, 4u16);
        // D s_3830_4: cmp-eq s_3830_1 s_3830_3
        let s_3830_4: bool = ((s_3830_1) == (s_3830_3));
        // D s_3830_5: write-var gs#119020 <= s_3830_4
        fn_state.gs_119020 = s_3830_4;
        // N s_3830_6: jump b3314
        return block_3314(state, tracer, fn_state);
    }
    fn block_3831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3831_0: read-var el:u8
        let s_3831_0: u8 = fn_state.el;
        // D s_3831_1: read-var coproc:u8
        let s_3831_1: u8 = fn_state.coproc;
        // D s_3831_2: read-var opc1:u8
        let s_3831_2: u8 = fn_state.opc1;
        // D s_3831_3: read-var CRn:u8
        let s_3831_3: u8 = fn_state.CRn;
        // D s_3831_4: read-var opc2:u8
        let s_3831_4: u8 = fn_state.opc2;
        // D s_3831_5: read-var CRm:u8
        let s_3831_5: u8 = fn_state.CRm;
        // D s_3831_6: read-var t:i
        let s_3831_6: i128 = fn_state.t;
        // D s_3831_7: call AMEVTYPER1_SysRegRead32_ecafc26f65f1dda2(s_3831_0, s_3831_1, s_3831_2, s_3831_3, s_3831_4, s_3831_5, s_3831_6)
        let s_3831_7: () = AMEVTYPER1_SysRegRead32_ecafc26f65f1dda2(
            state,
            tracer,
            s_3831_0,
            s_3831_1,
            s_3831_2,
            s_3831_3,
            s_3831_4,
            s_3831_5,
            s_3831_6,
        );
        // N s_3831_8: return
        return;
    }
    fn block_3832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3832_0: read-var opc2:u8
        let s_3832_0: u8 = fn_state.opc2;
        // D s_3832_1: cast zx s_3832_0 -> bv
        let s_3832_1: Bits = Bits::new(s_3832_0 as u128, 3u16);
        // C s_3832_2: const #1u : u8
        let s_3832_2: u8 = 1;
        // C s_3832_3: cast zx s_3832_2 -> bv
        let s_3832_3: Bits = Bits::new(s_3832_2 as u128, 3u16);
        // D s_3832_4: cmp-eq s_3832_1 s_3832_3
        let s_3832_4: bool = ((s_3832_1) == (s_3832_3));
        // D s_3832_5: write-var gs#119019 <= s_3832_4
        fn_state.gs_119019 = s_3832_4;
        // N s_3832_6: jump b3311
        return block_3311(state, tracer, fn_state);
    }
    fn block_3833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3833_0: read-var opc1:u8
        let s_3833_0: u8 = fn_state.opc1;
        // D s_3833_1: cast zx s_3833_0 -> bv
        let s_3833_1: Bits = Bits::new(s_3833_0 as u128, 3u16);
        // C s_3833_2: const #0u : u8
        let s_3833_2: u8 = 0;
        // C s_3833_3: cast zx s_3833_2 -> bv
        let s_3833_3: Bits = Bits::new(s_3833_2 as u128, 3u16);
        // D s_3833_4: cmp-eq s_3833_1 s_3833_3
        let s_3833_4: bool = ((s_3833_1) == (s_3833_3));
        // D s_3833_5: write-var gs#119018 <= s_3833_4
        fn_state.gs_119018 = s_3833_4;
        // N s_3833_6: jump b3309
        return block_3309(state, tracer, fn_state);
    }
    fn block_3834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3834_0: read-var coproc:u8
        let s_3834_0: u8 = fn_state.coproc;
        // D s_3834_1: cast zx s_3834_0 -> bv
        let s_3834_1: Bits = Bits::new(s_3834_0 as u128, 4u16);
        // C s_3834_2: const #15u : u8
        let s_3834_2: u8 = 15;
        // C s_3834_3: cast zx s_3834_2 -> bv
        let s_3834_3: Bits = Bits::new(s_3834_2 as u128, 4u16);
        // D s_3834_4: cmp-eq s_3834_1 s_3834_3
        let s_3834_4: bool = ((s_3834_1) == (s_3834_3));
        // D s_3834_5: write-var gs#119017 <= s_3834_4
        fn_state.gs_119017 = s_3834_4;
        // N s_3834_6: jump b3307
        return block_3307(state, tracer, fn_state);
    }
    fn block_3835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3835_0: read-var CRn:u8
        let s_3835_0: u8 = fn_state.CRn;
        // D s_3835_1: cast zx s_3835_0 -> bv
        let s_3835_1: Bits = Bits::new(s_3835_0 as u128, 4u16);
        // C s_3835_2: const #13u : u8
        let s_3835_2: u8 = 13;
        // C s_3835_3: cast zx s_3835_2 -> bv
        let s_3835_3: Bits = Bits::new(s_3835_2 as u128, 4u16);
        // D s_3835_4: cmp-eq s_3835_1 s_3835_3
        let s_3835_4: bool = ((s_3835_1) == (s_3835_3));
        // D s_3835_5: write-var gs#119016 <= s_3835_4
        fn_state.gs_119016 = s_3835_4;
        // N s_3835_6: jump b3305
        return block_3305(state, tracer, fn_state);
    }
    fn block_3836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3836_0: read-var el:u8
        let s_3836_0: u8 = fn_state.el;
        // D s_3836_1: read-var coproc:u8
        let s_3836_1: u8 = fn_state.coproc;
        // D s_3836_2: read-var opc1:u8
        let s_3836_2: u8 = fn_state.opc1;
        // D s_3836_3: read-var CRn:u8
        let s_3836_3: u8 = fn_state.CRn;
        // D s_3836_4: read-var opc2:u8
        let s_3836_4: u8 = fn_state.opc2;
        // D s_3836_5: read-var CRm:u8
        let s_3836_5: u8 = fn_state.CRm;
        // D s_3836_6: read-var t:i
        let s_3836_6: i128 = fn_state.t;
        // D s_3836_7: call AMEVTYPER1_SysRegRead32_56620f65cf2520b9(s_3836_0, s_3836_1, s_3836_2, s_3836_3, s_3836_4, s_3836_5, s_3836_6)
        let s_3836_7: () = AMEVTYPER1_SysRegRead32_56620f65cf2520b9(
            state,
            tracer,
            s_3836_0,
            s_3836_1,
            s_3836_2,
            s_3836_3,
            s_3836_4,
            s_3836_5,
            s_3836_6,
        );
        // N s_3836_8: return
        return;
    }
    fn block_3837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3837_0: read-var opc2:u8
        let s_3837_0: u8 = fn_state.opc2;
        // D s_3837_1: cast zx s_3837_0 -> bv
        let s_3837_1: Bits = Bits::new(s_3837_0 as u128, 3u16);
        // C s_3837_2: const #2u : u8
        let s_3837_2: u8 = 2;
        // C s_3837_3: cast zx s_3837_2 -> bv
        let s_3837_3: Bits = Bits::new(s_3837_2 as u128, 3u16);
        // D s_3837_4: cmp-eq s_3837_1 s_3837_3
        let s_3837_4: bool = ((s_3837_1) == (s_3837_3));
        // D s_3837_5: write-var gs#119015 <= s_3837_4
        fn_state.gs_119015 = s_3837_4;
        // N s_3837_6: jump b3302
        return block_3302(state, tracer, fn_state);
    }
    fn block_3838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3838_0: read-var opc1:u8
        let s_3838_0: u8 = fn_state.opc1;
        // D s_3838_1: cast zx s_3838_0 -> bv
        let s_3838_1: Bits = Bits::new(s_3838_0 as u128, 3u16);
        // C s_3838_2: const #0u : u8
        let s_3838_2: u8 = 0;
        // C s_3838_3: cast zx s_3838_2 -> bv
        let s_3838_3: Bits = Bits::new(s_3838_2 as u128, 3u16);
        // D s_3838_4: cmp-eq s_3838_1 s_3838_3
        let s_3838_4: bool = ((s_3838_1) == (s_3838_3));
        // D s_3838_5: write-var gs#119014 <= s_3838_4
        fn_state.gs_119014 = s_3838_4;
        // N s_3838_6: jump b3300
        return block_3300(state, tracer, fn_state);
    }
    fn block_3839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3839_0: read-var coproc:u8
        let s_3839_0: u8 = fn_state.coproc;
        // D s_3839_1: cast zx s_3839_0 -> bv
        let s_3839_1: Bits = Bits::new(s_3839_0 as u128, 4u16);
        // C s_3839_2: const #15u : u8
        let s_3839_2: u8 = 15;
        // C s_3839_3: cast zx s_3839_2 -> bv
        let s_3839_3: Bits = Bits::new(s_3839_2 as u128, 4u16);
        // D s_3839_4: cmp-eq s_3839_1 s_3839_3
        let s_3839_4: bool = ((s_3839_1) == (s_3839_3));
        // D s_3839_5: write-var gs#119013 <= s_3839_4
        fn_state.gs_119013 = s_3839_4;
        // N s_3839_6: jump b3298
        return block_3298(state, tracer, fn_state);
    }
    fn block_3840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3840_0: read-var CRn:u8
        let s_3840_0: u8 = fn_state.CRn;
        // D s_3840_1: cast zx s_3840_0 -> bv
        let s_3840_1: Bits = Bits::new(s_3840_0 as u128, 4u16);
        // C s_3840_2: const #13u : u8
        let s_3840_2: u8 = 13;
        // C s_3840_3: cast zx s_3840_2 -> bv
        let s_3840_3: Bits = Bits::new(s_3840_2 as u128, 4u16);
        // D s_3840_4: cmp-eq s_3840_1 s_3840_3
        let s_3840_4: bool = ((s_3840_1) == (s_3840_3));
        // D s_3840_5: write-var gs#119012 <= s_3840_4
        fn_state.gs_119012 = s_3840_4;
        // N s_3840_6: jump b3296
        return block_3296(state, tracer, fn_state);
    }
    fn block_3841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3841_0: read-var el:u8
        let s_3841_0: u8 = fn_state.el;
        // D s_3841_1: read-var coproc:u8
        let s_3841_1: u8 = fn_state.coproc;
        // D s_3841_2: read-var opc1:u8
        let s_3841_2: u8 = fn_state.opc1;
        // D s_3841_3: read-var CRn:u8
        let s_3841_3: u8 = fn_state.CRn;
        // D s_3841_4: read-var opc2:u8
        let s_3841_4: u8 = fn_state.opc2;
        // D s_3841_5: read-var CRm:u8
        let s_3841_5: u8 = fn_state.CRm;
        // D s_3841_6: read-var t:i
        let s_3841_6: i128 = fn_state.t;
        // D s_3841_7: call AMEVTYPER1_SysRegRead32_3d5ee14ab14e0600(s_3841_0, s_3841_1, s_3841_2, s_3841_3, s_3841_4, s_3841_5, s_3841_6)
        let s_3841_7: () = AMEVTYPER1_SysRegRead32_3d5ee14ab14e0600(
            state,
            tracer,
            s_3841_0,
            s_3841_1,
            s_3841_2,
            s_3841_3,
            s_3841_4,
            s_3841_5,
            s_3841_6,
        );
        // N s_3841_8: return
        return;
    }
    fn block_3842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3842_0: read-var opc2:u8
        let s_3842_0: u8 = fn_state.opc2;
        // D s_3842_1: cast zx s_3842_0 -> bv
        let s_3842_1: Bits = Bits::new(s_3842_0 as u128, 3u16);
        // C s_3842_2: const #3u : u8
        let s_3842_2: u8 = 3;
        // C s_3842_3: cast zx s_3842_2 -> bv
        let s_3842_3: Bits = Bits::new(s_3842_2 as u128, 3u16);
        // D s_3842_4: cmp-eq s_3842_1 s_3842_3
        let s_3842_4: bool = ((s_3842_1) == (s_3842_3));
        // D s_3842_5: write-var gs#119011 <= s_3842_4
        fn_state.gs_119011 = s_3842_4;
        // N s_3842_6: jump b3293
        return block_3293(state, tracer, fn_state);
    }
    fn block_3843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3843_0: read-var opc1:u8
        let s_3843_0: u8 = fn_state.opc1;
        // D s_3843_1: cast zx s_3843_0 -> bv
        let s_3843_1: Bits = Bits::new(s_3843_0 as u128, 3u16);
        // C s_3843_2: const #0u : u8
        let s_3843_2: u8 = 0;
        // C s_3843_3: cast zx s_3843_2 -> bv
        let s_3843_3: Bits = Bits::new(s_3843_2 as u128, 3u16);
        // D s_3843_4: cmp-eq s_3843_1 s_3843_3
        let s_3843_4: bool = ((s_3843_1) == (s_3843_3));
        // D s_3843_5: write-var gs#119010 <= s_3843_4
        fn_state.gs_119010 = s_3843_4;
        // N s_3843_6: jump b3291
        return block_3291(state, tracer, fn_state);
    }
    fn block_3844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3844_0: read-var coproc:u8
        let s_3844_0: u8 = fn_state.coproc;
        // D s_3844_1: cast zx s_3844_0 -> bv
        let s_3844_1: Bits = Bits::new(s_3844_0 as u128, 4u16);
        // C s_3844_2: const #15u : u8
        let s_3844_2: u8 = 15;
        // C s_3844_3: cast zx s_3844_2 -> bv
        let s_3844_3: Bits = Bits::new(s_3844_2 as u128, 4u16);
        // D s_3844_4: cmp-eq s_3844_1 s_3844_3
        let s_3844_4: bool = ((s_3844_1) == (s_3844_3));
        // D s_3844_5: write-var gs#119009 <= s_3844_4
        fn_state.gs_119009 = s_3844_4;
        // N s_3844_6: jump b3289
        return block_3289(state, tracer, fn_state);
    }
    fn block_3845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3845_0: read-var CRn:u8
        let s_3845_0: u8 = fn_state.CRn;
        // D s_3845_1: cast zx s_3845_0 -> bv
        let s_3845_1: Bits = Bits::new(s_3845_0 as u128, 4u16);
        // C s_3845_2: const #13u : u8
        let s_3845_2: u8 = 13;
        // C s_3845_3: cast zx s_3845_2 -> bv
        let s_3845_3: Bits = Bits::new(s_3845_2 as u128, 4u16);
        // D s_3845_4: cmp-eq s_3845_1 s_3845_3
        let s_3845_4: bool = ((s_3845_1) == (s_3845_3));
        // D s_3845_5: write-var gs#119008 <= s_3845_4
        fn_state.gs_119008 = s_3845_4;
        // N s_3845_6: jump b3287
        return block_3287(state, tracer, fn_state);
    }
    fn block_3846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3846_0: read-var el:u8
        let s_3846_0: u8 = fn_state.el;
        // D s_3846_1: read-var coproc:u8
        let s_3846_1: u8 = fn_state.coproc;
        // D s_3846_2: read-var opc1:u8
        let s_3846_2: u8 = fn_state.opc1;
        // D s_3846_3: read-var CRn:u8
        let s_3846_3: u8 = fn_state.CRn;
        // D s_3846_4: read-var opc2:u8
        let s_3846_4: u8 = fn_state.opc2;
        // D s_3846_5: read-var CRm:u8
        let s_3846_5: u8 = fn_state.CRm;
        // D s_3846_6: read-var t:i
        let s_3846_6: i128 = fn_state.t;
        // D s_3846_7: call AMEVTYPER1_SysRegRead32_727db649d7fd62f8(s_3846_0, s_3846_1, s_3846_2, s_3846_3, s_3846_4, s_3846_5, s_3846_6)
        let s_3846_7: () = AMEVTYPER1_SysRegRead32_727db649d7fd62f8(
            state,
            tracer,
            s_3846_0,
            s_3846_1,
            s_3846_2,
            s_3846_3,
            s_3846_4,
            s_3846_5,
            s_3846_6,
        );
        // N s_3846_8: return
        return;
    }
    fn block_3847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3847_0: read-var opc2:u8
        let s_3847_0: u8 = fn_state.opc2;
        // D s_3847_1: cast zx s_3847_0 -> bv
        let s_3847_1: Bits = Bits::new(s_3847_0 as u128, 3u16);
        // C s_3847_2: const #4u : u8
        let s_3847_2: u8 = 4;
        // C s_3847_3: cast zx s_3847_2 -> bv
        let s_3847_3: Bits = Bits::new(s_3847_2 as u128, 3u16);
        // D s_3847_4: cmp-eq s_3847_1 s_3847_3
        let s_3847_4: bool = ((s_3847_1) == (s_3847_3));
        // D s_3847_5: write-var gs#119007 <= s_3847_4
        fn_state.gs_119007 = s_3847_4;
        // N s_3847_6: jump b3284
        return block_3284(state, tracer, fn_state);
    }
    fn block_3848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3848_0: read-var opc1:u8
        let s_3848_0: u8 = fn_state.opc1;
        // D s_3848_1: cast zx s_3848_0 -> bv
        let s_3848_1: Bits = Bits::new(s_3848_0 as u128, 3u16);
        // C s_3848_2: const #0u : u8
        let s_3848_2: u8 = 0;
        // C s_3848_3: cast zx s_3848_2 -> bv
        let s_3848_3: Bits = Bits::new(s_3848_2 as u128, 3u16);
        // D s_3848_4: cmp-eq s_3848_1 s_3848_3
        let s_3848_4: bool = ((s_3848_1) == (s_3848_3));
        // D s_3848_5: write-var gs#119006 <= s_3848_4
        fn_state.gs_119006 = s_3848_4;
        // N s_3848_6: jump b3282
        return block_3282(state, tracer, fn_state);
    }
    fn block_3849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3849_0: read-var coproc:u8
        let s_3849_0: u8 = fn_state.coproc;
        // D s_3849_1: cast zx s_3849_0 -> bv
        let s_3849_1: Bits = Bits::new(s_3849_0 as u128, 4u16);
        // C s_3849_2: const #15u : u8
        let s_3849_2: u8 = 15;
        // C s_3849_3: cast zx s_3849_2 -> bv
        let s_3849_3: Bits = Bits::new(s_3849_2 as u128, 4u16);
        // D s_3849_4: cmp-eq s_3849_1 s_3849_3
        let s_3849_4: bool = ((s_3849_1) == (s_3849_3));
        // D s_3849_5: write-var gs#119005 <= s_3849_4
        fn_state.gs_119005 = s_3849_4;
        // N s_3849_6: jump b3280
        return block_3280(state, tracer, fn_state);
    }
    fn block_3850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3850_0: read-var CRn:u8
        let s_3850_0: u8 = fn_state.CRn;
        // D s_3850_1: cast zx s_3850_0 -> bv
        let s_3850_1: Bits = Bits::new(s_3850_0 as u128, 4u16);
        // C s_3850_2: const #13u : u8
        let s_3850_2: u8 = 13;
        // C s_3850_3: cast zx s_3850_2 -> bv
        let s_3850_3: Bits = Bits::new(s_3850_2 as u128, 4u16);
        // D s_3850_4: cmp-eq s_3850_1 s_3850_3
        let s_3850_4: bool = ((s_3850_1) == (s_3850_3));
        // D s_3850_5: write-var gs#119004 <= s_3850_4
        fn_state.gs_119004 = s_3850_4;
        // N s_3850_6: jump b3278
        return block_3278(state, tracer, fn_state);
    }
    fn block_3851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3851_0: read-var el:u8
        let s_3851_0: u8 = fn_state.el;
        // D s_3851_1: read-var coproc:u8
        let s_3851_1: u8 = fn_state.coproc;
        // D s_3851_2: read-var opc1:u8
        let s_3851_2: u8 = fn_state.opc1;
        // D s_3851_3: read-var CRn:u8
        let s_3851_3: u8 = fn_state.CRn;
        // D s_3851_4: read-var opc2:u8
        let s_3851_4: u8 = fn_state.opc2;
        // D s_3851_5: read-var CRm:u8
        let s_3851_5: u8 = fn_state.CRm;
        // D s_3851_6: read-var t:i
        let s_3851_6: i128 = fn_state.t;
        // D s_3851_7: call AMEVTYPER1_SysRegRead32_b4ee1ae1a6a9e5fe(s_3851_0, s_3851_1, s_3851_2, s_3851_3, s_3851_4, s_3851_5, s_3851_6)
        let s_3851_7: () = AMEVTYPER1_SysRegRead32_b4ee1ae1a6a9e5fe(
            state,
            tracer,
            s_3851_0,
            s_3851_1,
            s_3851_2,
            s_3851_3,
            s_3851_4,
            s_3851_5,
            s_3851_6,
        );
        // N s_3851_8: return
        return;
    }
    fn block_3852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3852_0: read-var opc2:u8
        let s_3852_0: u8 = fn_state.opc2;
        // D s_3852_1: cast zx s_3852_0 -> bv
        let s_3852_1: Bits = Bits::new(s_3852_0 as u128, 3u16);
        // C s_3852_2: const #5u : u8
        let s_3852_2: u8 = 5;
        // C s_3852_3: cast zx s_3852_2 -> bv
        let s_3852_3: Bits = Bits::new(s_3852_2 as u128, 3u16);
        // D s_3852_4: cmp-eq s_3852_1 s_3852_3
        let s_3852_4: bool = ((s_3852_1) == (s_3852_3));
        // D s_3852_5: write-var gs#119003 <= s_3852_4
        fn_state.gs_119003 = s_3852_4;
        // N s_3852_6: jump b3275
        return block_3275(state, tracer, fn_state);
    }
    fn block_3853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3853_0: read-var opc1:u8
        let s_3853_0: u8 = fn_state.opc1;
        // D s_3853_1: cast zx s_3853_0 -> bv
        let s_3853_1: Bits = Bits::new(s_3853_0 as u128, 3u16);
        // C s_3853_2: const #0u : u8
        let s_3853_2: u8 = 0;
        // C s_3853_3: cast zx s_3853_2 -> bv
        let s_3853_3: Bits = Bits::new(s_3853_2 as u128, 3u16);
        // D s_3853_4: cmp-eq s_3853_1 s_3853_3
        let s_3853_4: bool = ((s_3853_1) == (s_3853_3));
        // D s_3853_5: write-var gs#119002 <= s_3853_4
        fn_state.gs_119002 = s_3853_4;
        // N s_3853_6: jump b3273
        return block_3273(state, tracer, fn_state);
    }
    fn block_3854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3854_0: read-var coproc:u8
        let s_3854_0: u8 = fn_state.coproc;
        // D s_3854_1: cast zx s_3854_0 -> bv
        let s_3854_1: Bits = Bits::new(s_3854_0 as u128, 4u16);
        // C s_3854_2: const #15u : u8
        let s_3854_2: u8 = 15;
        // C s_3854_3: cast zx s_3854_2 -> bv
        let s_3854_3: Bits = Bits::new(s_3854_2 as u128, 4u16);
        // D s_3854_4: cmp-eq s_3854_1 s_3854_3
        let s_3854_4: bool = ((s_3854_1) == (s_3854_3));
        // D s_3854_5: write-var gs#119001 <= s_3854_4
        fn_state.gs_119001 = s_3854_4;
        // N s_3854_6: jump b3271
        return block_3271(state, tracer, fn_state);
    }
    fn block_3855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3855_0: read-var CRn:u8
        let s_3855_0: u8 = fn_state.CRn;
        // D s_3855_1: cast zx s_3855_0 -> bv
        let s_3855_1: Bits = Bits::new(s_3855_0 as u128, 4u16);
        // C s_3855_2: const #13u : u8
        let s_3855_2: u8 = 13;
        // C s_3855_3: cast zx s_3855_2 -> bv
        let s_3855_3: Bits = Bits::new(s_3855_2 as u128, 4u16);
        // D s_3855_4: cmp-eq s_3855_1 s_3855_3
        let s_3855_4: bool = ((s_3855_1) == (s_3855_3));
        // D s_3855_5: write-var gs#119000 <= s_3855_4
        fn_state.gs_119000 = s_3855_4;
        // N s_3855_6: jump b3269
        return block_3269(state, tracer, fn_state);
    }
    fn block_3856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3856_0: read-var el:u8
        let s_3856_0: u8 = fn_state.el;
        // D s_3856_1: read-var coproc:u8
        let s_3856_1: u8 = fn_state.coproc;
        // D s_3856_2: read-var opc1:u8
        let s_3856_2: u8 = fn_state.opc1;
        // D s_3856_3: read-var CRn:u8
        let s_3856_3: u8 = fn_state.CRn;
        // D s_3856_4: read-var opc2:u8
        let s_3856_4: u8 = fn_state.opc2;
        // D s_3856_5: read-var CRm:u8
        let s_3856_5: u8 = fn_state.CRm;
        // D s_3856_6: read-var t:i
        let s_3856_6: i128 = fn_state.t;
        // D s_3856_7: call AMEVTYPER1_SysRegRead32_30353b694529c623(s_3856_0, s_3856_1, s_3856_2, s_3856_3, s_3856_4, s_3856_5, s_3856_6)
        let s_3856_7: () = AMEVTYPER1_SysRegRead32_30353b694529c623(
            state,
            tracer,
            s_3856_0,
            s_3856_1,
            s_3856_2,
            s_3856_3,
            s_3856_4,
            s_3856_5,
            s_3856_6,
        );
        // N s_3856_8: return
        return;
    }
    fn block_3857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3857_0: read-var opc2:u8
        let s_3857_0: u8 = fn_state.opc2;
        // D s_3857_1: cast zx s_3857_0 -> bv
        let s_3857_1: Bits = Bits::new(s_3857_0 as u128, 3u16);
        // C s_3857_2: const #6u : u8
        let s_3857_2: u8 = 6;
        // C s_3857_3: cast zx s_3857_2 -> bv
        let s_3857_3: Bits = Bits::new(s_3857_2 as u128, 3u16);
        // D s_3857_4: cmp-eq s_3857_1 s_3857_3
        let s_3857_4: bool = ((s_3857_1) == (s_3857_3));
        // D s_3857_5: write-var gs#118999 <= s_3857_4
        fn_state.gs_118999 = s_3857_4;
        // N s_3857_6: jump b3266
        return block_3266(state, tracer, fn_state);
    }
    fn block_3858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3858_0: read-var opc1:u8
        let s_3858_0: u8 = fn_state.opc1;
        // D s_3858_1: cast zx s_3858_0 -> bv
        let s_3858_1: Bits = Bits::new(s_3858_0 as u128, 3u16);
        // C s_3858_2: const #0u : u8
        let s_3858_2: u8 = 0;
        // C s_3858_3: cast zx s_3858_2 -> bv
        let s_3858_3: Bits = Bits::new(s_3858_2 as u128, 3u16);
        // D s_3858_4: cmp-eq s_3858_1 s_3858_3
        let s_3858_4: bool = ((s_3858_1) == (s_3858_3));
        // D s_3858_5: write-var gs#118998 <= s_3858_4
        fn_state.gs_118998 = s_3858_4;
        // N s_3858_6: jump b3264
        return block_3264(state, tracer, fn_state);
    }
    fn block_3859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3859_0: read-var coproc:u8
        let s_3859_0: u8 = fn_state.coproc;
        // D s_3859_1: cast zx s_3859_0 -> bv
        let s_3859_1: Bits = Bits::new(s_3859_0 as u128, 4u16);
        // C s_3859_2: const #15u : u8
        let s_3859_2: u8 = 15;
        // C s_3859_3: cast zx s_3859_2 -> bv
        let s_3859_3: Bits = Bits::new(s_3859_2 as u128, 4u16);
        // D s_3859_4: cmp-eq s_3859_1 s_3859_3
        let s_3859_4: bool = ((s_3859_1) == (s_3859_3));
        // D s_3859_5: write-var gs#118997 <= s_3859_4
        fn_state.gs_118997 = s_3859_4;
        // N s_3859_6: jump b3262
        return block_3262(state, tracer, fn_state);
    }
    fn block_3860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3860_0: read-var CRn:u8
        let s_3860_0: u8 = fn_state.CRn;
        // D s_3860_1: cast zx s_3860_0 -> bv
        let s_3860_1: Bits = Bits::new(s_3860_0 as u128, 4u16);
        // C s_3860_2: const #13u : u8
        let s_3860_2: u8 = 13;
        // C s_3860_3: cast zx s_3860_2 -> bv
        let s_3860_3: Bits = Bits::new(s_3860_2 as u128, 4u16);
        // D s_3860_4: cmp-eq s_3860_1 s_3860_3
        let s_3860_4: bool = ((s_3860_1) == (s_3860_3));
        // D s_3860_5: write-var gs#118996 <= s_3860_4
        fn_state.gs_118996 = s_3860_4;
        // N s_3860_6: jump b3260
        return block_3260(state, tracer, fn_state);
    }
    fn block_3861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3861_0: read-var el:u8
        let s_3861_0: u8 = fn_state.el;
        // D s_3861_1: read-var coproc:u8
        let s_3861_1: u8 = fn_state.coproc;
        // D s_3861_2: read-var opc1:u8
        let s_3861_2: u8 = fn_state.opc1;
        // D s_3861_3: read-var CRn:u8
        let s_3861_3: u8 = fn_state.CRn;
        // D s_3861_4: read-var opc2:u8
        let s_3861_4: u8 = fn_state.opc2;
        // D s_3861_5: read-var CRm:u8
        let s_3861_5: u8 = fn_state.CRm;
        // D s_3861_6: read-var t:i
        let s_3861_6: i128 = fn_state.t;
        // D s_3861_7: call AMEVTYPER1_SysRegRead32_3704564c9ad105a9(s_3861_0, s_3861_1, s_3861_2, s_3861_3, s_3861_4, s_3861_5, s_3861_6)
        let s_3861_7: () = AMEVTYPER1_SysRegRead32_3704564c9ad105a9(
            state,
            tracer,
            s_3861_0,
            s_3861_1,
            s_3861_2,
            s_3861_3,
            s_3861_4,
            s_3861_5,
            s_3861_6,
        );
        // N s_3861_8: return
        return;
    }
    fn block_3862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3862_0: read-var opc2:u8
        let s_3862_0: u8 = fn_state.opc2;
        // D s_3862_1: cast zx s_3862_0 -> bv
        let s_3862_1: Bits = Bits::new(s_3862_0 as u128, 3u16);
        // C s_3862_2: const #7u : u8
        let s_3862_2: u8 = 7;
        // C s_3862_3: cast zx s_3862_2 -> bv
        let s_3862_3: Bits = Bits::new(s_3862_2 as u128, 3u16);
        // D s_3862_4: cmp-eq s_3862_1 s_3862_3
        let s_3862_4: bool = ((s_3862_1) == (s_3862_3));
        // D s_3862_5: write-var gs#118995 <= s_3862_4
        fn_state.gs_118995 = s_3862_4;
        // N s_3862_6: jump b3257
        return block_3257(state, tracer, fn_state);
    }
    fn block_3863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3863_0: read-var opc1:u8
        let s_3863_0: u8 = fn_state.opc1;
        // D s_3863_1: cast zx s_3863_0 -> bv
        let s_3863_1: Bits = Bits::new(s_3863_0 as u128, 3u16);
        // C s_3863_2: const #0u : u8
        let s_3863_2: u8 = 0;
        // C s_3863_3: cast zx s_3863_2 -> bv
        let s_3863_3: Bits = Bits::new(s_3863_2 as u128, 3u16);
        // D s_3863_4: cmp-eq s_3863_1 s_3863_3
        let s_3863_4: bool = ((s_3863_1) == (s_3863_3));
        // D s_3863_5: write-var gs#118994 <= s_3863_4
        fn_state.gs_118994 = s_3863_4;
        // N s_3863_6: jump b3255
        return block_3255(state, tracer, fn_state);
    }
    fn block_3864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3864_0: read-var coproc:u8
        let s_3864_0: u8 = fn_state.coproc;
        // D s_3864_1: cast zx s_3864_0 -> bv
        let s_3864_1: Bits = Bits::new(s_3864_0 as u128, 4u16);
        // C s_3864_2: const #15u : u8
        let s_3864_2: u8 = 15;
        // C s_3864_3: cast zx s_3864_2 -> bv
        let s_3864_3: Bits = Bits::new(s_3864_2 as u128, 4u16);
        // D s_3864_4: cmp-eq s_3864_1 s_3864_3
        let s_3864_4: bool = ((s_3864_1) == (s_3864_3));
        // D s_3864_5: write-var gs#118993 <= s_3864_4
        fn_state.gs_118993 = s_3864_4;
        // N s_3864_6: jump b3253
        return block_3253(state, tracer, fn_state);
    }
    fn block_3865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3865_0: read-var CRn:u8
        let s_3865_0: u8 = fn_state.CRn;
        // D s_3865_1: cast zx s_3865_0 -> bv
        let s_3865_1: Bits = Bits::new(s_3865_0 as u128, 4u16);
        // C s_3865_2: const #13u : u8
        let s_3865_2: u8 = 13;
        // C s_3865_3: cast zx s_3865_2 -> bv
        let s_3865_3: Bits = Bits::new(s_3865_2 as u128, 4u16);
        // D s_3865_4: cmp-eq s_3865_1 s_3865_3
        let s_3865_4: bool = ((s_3865_1) == (s_3865_3));
        // D s_3865_5: write-var gs#118992 <= s_3865_4
        fn_state.gs_118992 = s_3865_4;
        // N s_3865_6: jump b3251
        return block_3251(state, tracer, fn_state);
    }
    fn block_3866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3866_0: read-var el:u8
        let s_3866_0: u8 = fn_state.el;
        // D s_3866_1: read-var coproc:u8
        let s_3866_1: u8 = fn_state.coproc;
        // D s_3866_2: read-var opc1:u8
        let s_3866_2: u8 = fn_state.opc1;
        // D s_3866_3: read-var CRn:u8
        let s_3866_3: u8 = fn_state.CRn;
        // D s_3866_4: read-var opc2:u8
        let s_3866_4: u8 = fn_state.opc2;
        // D s_3866_5: read-var CRm:u8
        let s_3866_5: u8 = fn_state.CRm;
        // D s_3866_6: read-var t:i
        let s_3866_6: i128 = fn_state.t;
        // D s_3866_7: call AMUSERENR_SysRegRead32_a8f18bf4f7170234(s_3866_0, s_3866_1, s_3866_2, s_3866_3, s_3866_4, s_3866_5, s_3866_6)
        let s_3866_7: () = AMUSERENR_SysRegRead32_a8f18bf4f7170234(
            state,
            tracer,
            s_3866_0,
            s_3866_1,
            s_3866_2,
            s_3866_3,
            s_3866_4,
            s_3866_5,
            s_3866_6,
        );
        // N s_3866_8: return
        return;
    }
    fn block_3867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3867_0: read-var opc2:u8
        let s_3867_0: u8 = fn_state.opc2;
        // D s_3867_1: cast zx s_3867_0 -> bv
        let s_3867_1: Bits = Bits::new(s_3867_0 as u128, 3u16);
        // C s_3867_2: const #3u : u8
        let s_3867_2: u8 = 3;
        // C s_3867_3: cast zx s_3867_2 -> bv
        let s_3867_3: Bits = Bits::new(s_3867_2 as u128, 3u16);
        // D s_3867_4: cmp-eq s_3867_1 s_3867_3
        let s_3867_4: bool = ((s_3867_1) == (s_3867_3));
        // D s_3867_5: write-var gs#118991 <= s_3867_4
        fn_state.gs_118991 = s_3867_4;
        // N s_3867_6: jump b3248
        return block_3248(state, tracer, fn_state);
    }
    fn block_3868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3868_0: read-var opc1:u8
        let s_3868_0: u8 = fn_state.opc1;
        // D s_3868_1: cast zx s_3868_0 -> bv
        let s_3868_1: Bits = Bits::new(s_3868_0 as u128, 3u16);
        // C s_3868_2: const #0u : u8
        let s_3868_2: u8 = 0;
        // C s_3868_3: cast zx s_3868_2 -> bv
        let s_3868_3: Bits = Bits::new(s_3868_2 as u128, 3u16);
        // D s_3868_4: cmp-eq s_3868_1 s_3868_3
        let s_3868_4: bool = ((s_3868_1) == (s_3868_3));
        // D s_3868_5: write-var gs#118990 <= s_3868_4
        fn_state.gs_118990 = s_3868_4;
        // N s_3868_6: jump b3246
        return block_3246(state, tracer, fn_state);
    }
    fn block_3869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3869_0: read-var coproc:u8
        let s_3869_0: u8 = fn_state.coproc;
        // D s_3869_1: cast zx s_3869_0 -> bv
        let s_3869_1: Bits = Bits::new(s_3869_0 as u128, 4u16);
        // C s_3869_2: const #15u : u8
        let s_3869_2: u8 = 15;
        // C s_3869_3: cast zx s_3869_2 -> bv
        let s_3869_3: Bits = Bits::new(s_3869_2 as u128, 4u16);
        // D s_3869_4: cmp-eq s_3869_1 s_3869_3
        let s_3869_4: bool = ((s_3869_1) == (s_3869_3));
        // D s_3869_5: write-var gs#118989 <= s_3869_4
        fn_state.gs_118989 = s_3869_4;
        // N s_3869_6: jump b3244
        return block_3244(state, tracer, fn_state);
    }
    fn block_3870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3870_0: read-var CRn:u8
        let s_3870_0: u8 = fn_state.CRn;
        // D s_3870_1: cast zx s_3870_0 -> bv
        let s_3870_1: Bits = Bits::new(s_3870_0 as u128, 4u16);
        // C s_3870_2: const #13u : u8
        let s_3870_2: u8 = 13;
        // C s_3870_3: cast zx s_3870_2 -> bv
        let s_3870_3: Bits = Bits::new(s_3870_2 as u128, 4u16);
        // D s_3870_4: cmp-eq s_3870_1 s_3870_3
        let s_3870_4: bool = ((s_3870_1) == (s_3870_3));
        // D s_3870_5: write-var gs#118988 <= s_3870_4
        fn_state.gs_118988 = s_3870_4;
        // N s_3870_6: jump b3242
        return block_3242(state, tracer, fn_state);
    }
    fn block_3871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3871_0: read-var el:u8
        let s_3871_0: u8 = fn_state.el;
        // D s_3871_1: read-var coproc:u8
        let s_3871_1: u8 = fn_state.coproc;
        // D s_3871_2: read-var opc1:u8
        let s_3871_2: u8 = fn_state.opc1;
        // D s_3871_3: read-var CRn:u8
        let s_3871_3: u8 = fn_state.CRn;
        // D s_3871_4: read-var opc2:u8
        let s_3871_4: u8 = fn_state.opc2;
        // D s_3871_5: read-var CRm:u8
        let s_3871_5: u8 = fn_state.CRm;
        // D s_3871_6: read-var t:i
        let s_3871_6: i128 = fn_state.t;
        // D s_3871_7: call AMEVTYPER0_SysRegRead32_3d4ae79d0a2a83f7(s_3871_0, s_3871_1, s_3871_2, s_3871_3, s_3871_4, s_3871_5, s_3871_6)
        let s_3871_7: () = AMEVTYPER0_SysRegRead32_3d4ae79d0a2a83f7(
            state,
            tracer,
            s_3871_0,
            s_3871_1,
            s_3871_2,
            s_3871_3,
            s_3871_4,
            s_3871_5,
            s_3871_6,
        );
        // N s_3871_8: return
        return;
    }
    fn block_3872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3872_0: read-var opc2:u8
        let s_3872_0: u8 = fn_state.opc2;
        // D s_3872_1: cast zx s_3872_0 -> bv
        let s_3872_1: Bits = Bits::new(s_3872_0 as u128, 3u16);
        // C s_3872_2: const #0u : u8
        let s_3872_2: u8 = 0;
        // C s_3872_3: cast zx s_3872_2 -> bv
        let s_3872_3: Bits = Bits::new(s_3872_2 as u128, 3u16);
        // D s_3872_4: cmp-eq s_3872_1 s_3872_3
        let s_3872_4: bool = ((s_3872_1) == (s_3872_3));
        // D s_3872_5: write-var gs#118987 <= s_3872_4
        fn_state.gs_118987 = s_3872_4;
        // N s_3872_6: jump b3239
        return block_3239(state, tracer, fn_state);
    }
    fn block_3873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3873_0: read-var opc1:u8
        let s_3873_0: u8 = fn_state.opc1;
        // D s_3873_1: cast zx s_3873_0 -> bv
        let s_3873_1: Bits = Bits::new(s_3873_0 as u128, 3u16);
        // C s_3873_2: const #0u : u8
        let s_3873_2: u8 = 0;
        // C s_3873_3: cast zx s_3873_2 -> bv
        let s_3873_3: Bits = Bits::new(s_3873_2 as u128, 3u16);
        // D s_3873_4: cmp-eq s_3873_1 s_3873_3
        let s_3873_4: bool = ((s_3873_1) == (s_3873_3));
        // D s_3873_5: write-var gs#118986 <= s_3873_4
        fn_state.gs_118986 = s_3873_4;
        // N s_3873_6: jump b3237
        return block_3237(state, tracer, fn_state);
    }
    fn block_3874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3874_0: read-var coproc:u8
        let s_3874_0: u8 = fn_state.coproc;
        // D s_3874_1: cast zx s_3874_0 -> bv
        let s_3874_1: Bits = Bits::new(s_3874_0 as u128, 4u16);
        // C s_3874_2: const #15u : u8
        let s_3874_2: u8 = 15;
        // C s_3874_3: cast zx s_3874_2 -> bv
        let s_3874_3: Bits = Bits::new(s_3874_2 as u128, 4u16);
        // D s_3874_4: cmp-eq s_3874_1 s_3874_3
        let s_3874_4: bool = ((s_3874_1) == (s_3874_3));
        // D s_3874_5: write-var gs#118985 <= s_3874_4
        fn_state.gs_118985 = s_3874_4;
        // N s_3874_6: jump b3235
        return block_3235(state, tracer, fn_state);
    }
    fn block_3875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3875_0: read-var CRn:u8
        let s_3875_0: u8 = fn_state.CRn;
        // D s_3875_1: cast zx s_3875_0 -> bv
        let s_3875_1: Bits = Bits::new(s_3875_0 as u128, 4u16);
        // C s_3875_2: const #13u : u8
        let s_3875_2: u8 = 13;
        // C s_3875_3: cast zx s_3875_2 -> bv
        let s_3875_3: Bits = Bits::new(s_3875_2 as u128, 4u16);
        // D s_3875_4: cmp-eq s_3875_1 s_3875_3
        let s_3875_4: bool = ((s_3875_1) == (s_3875_3));
        // D s_3875_5: write-var gs#118984 <= s_3875_4
        fn_state.gs_118984 = s_3875_4;
        // N s_3875_6: jump b3233
        return block_3233(state, tracer, fn_state);
    }
    fn block_3876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3876_0: read-var el:u8
        let s_3876_0: u8 = fn_state.el;
        // D s_3876_1: read-var coproc:u8
        let s_3876_1: u8 = fn_state.coproc;
        // D s_3876_2: read-var opc1:u8
        let s_3876_2: u8 = fn_state.opc1;
        // D s_3876_3: read-var CRn:u8
        let s_3876_3: u8 = fn_state.CRn;
        // D s_3876_4: read-var opc2:u8
        let s_3876_4: u8 = fn_state.opc2;
        // D s_3876_5: read-var CRm:u8
        let s_3876_5: u8 = fn_state.CRm;
        // D s_3876_6: read-var t:i
        let s_3876_6: i128 = fn_state.t;
        // D s_3876_7: call AMEVTYPER0_SysRegRead32_2bb2f6721c44cef6(s_3876_0, s_3876_1, s_3876_2, s_3876_3, s_3876_4, s_3876_5, s_3876_6)
        let s_3876_7: () = AMEVTYPER0_SysRegRead32_2bb2f6721c44cef6(
            state,
            tracer,
            s_3876_0,
            s_3876_1,
            s_3876_2,
            s_3876_3,
            s_3876_4,
            s_3876_5,
            s_3876_6,
        );
        // N s_3876_8: return
        return;
    }
    fn block_3877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3877_0: read-var opc2:u8
        let s_3877_0: u8 = fn_state.opc2;
        // D s_3877_1: cast zx s_3877_0 -> bv
        let s_3877_1: Bits = Bits::new(s_3877_0 as u128, 3u16);
        // C s_3877_2: const #1u : u8
        let s_3877_2: u8 = 1;
        // C s_3877_3: cast zx s_3877_2 -> bv
        let s_3877_3: Bits = Bits::new(s_3877_2 as u128, 3u16);
        // D s_3877_4: cmp-eq s_3877_1 s_3877_3
        let s_3877_4: bool = ((s_3877_1) == (s_3877_3));
        // D s_3877_5: write-var gs#118983 <= s_3877_4
        fn_state.gs_118983 = s_3877_4;
        // N s_3877_6: jump b3230
        return block_3230(state, tracer, fn_state);
    }
    fn block_3878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3878_0: read-var opc1:u8
        let s_3878_0: u8 = fn_state.opc1;
        // D s_3878_1: cast zx s_3878_0 -> bv
        let s_3878_1: Bits = Bits::new(s_3878_0 as u128, 3u16);
        // C s_3878_2: const #0u : u8
        let s_3878_2: u8 = 0;
        // C s_3878_3: cast zx s_3878_2 -> bv
        let s_3878_3: Bits = Bits::new(s_3878_2 as u128, 3u16);
        // D s_3878_4: cmp-eq s_3878_1 s_3878_3
        let s_3878_4: bool = ((s_3878_1) == (s_3878_3));
        // D s_3878_5: write-var gs#118982 <= s_3878_4
        fn_state.gs_118982 = s_3878_4;
        // N s_3878_6: jump b3228
        return block_3228(state, tracer, fn_state);
    }
    fn block_3879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3879_0: read-var coproc:u8
        let s_3879_0: u8 = fn_state.coproc;
        // D s_3879_1: cast zx s_3879_0 -> bv
        let s_3879_1: Bits = Bits::new(s_3879_0 as u128, 4u16);
        // C s_3879_2: const #15u : u8
        let s_3879_2: u8 = 15;
        // C s_3879_3: cast zx s_3879_2 -> bv
        let s_3879_3: Bits = Bits::new(s_3879_2 as u128, 4u16);
        // D s_3879_4: cmp-eq s_3879_1 s_3879_3
        let s_3879_4: bool = ((s_3879_1) == (s_3879_3));
        // D s_3879_5: write-var gs#118981 <= s_3879_4
        fn_state.gs_118981 = s_3879_4;
        // N s_3879_6: jump b3226
        return block_3226(state, tracer, fn_state);
    }
    fn block_3880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3880_0: read-var CRn:u8
        let s_3880_0: u8 = fn_state.CRn;
        // D s_3880_1: cast zx s_3880_0 -> bv
        let s_3880_1: Bits = Bits::new(s_3880_0 as u128, 4u16);
        // C s_3880_2: const #13u : u8
        let s_3880_2: u8 = 13;
        // C s_3880_3: cast zx s_3880_2 -> bv
        let s_3880_3: Bits = Bits::new(s_3880_2 as u128, 4u16);
        // D s_3880_4: cmp-eq s_3880_1 s_3880_3
        let s_3880_4: bool = ((s_3880_1) == (s_3880_3));
        // D s_3880_5: write-var gs#118980 <= s_3880_4
        fn_state.gs_118980 = s_3880_4;
        // N s_3880_6: jump b3224
        return block_3224(state, tracer, fn_state);
    }
    fn block_3881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3881_0: read-var el:u8
        let s_3881_0: u8 = fn_state.el;
        // D s_3881_1: read-var coproc:u8
        let s_3881_1: u8 = fn_state.coproc;
        // D s_3881_2: read-var opc1:u8
        let s_3881_2: u8 = fn_state.opc1;
        // D s_3881_3: read-var CRn:u8
        let s_3881_3: u8 = fn_state.CRn;
        // D s_3881_4: read-var opc2:u8
        let s_3881_4: u8 = fn_state.opc2;
        // D s_3881_5: read-var CRm:u8
        let s_3881_5: u8 = fn_state.CRm;
        // D s_3881_6: read-var t:i
        let s_3881_6: i128 = fn_state.t;
        // D s_3881_7: call AMEVTYPER0_SysRegRead32_2e79e456f9d1dcd3(s_3881_0, s_3881_1, s_3881_2, s_3881_3, s_3881_4, s_3881_5, s_3881_6)
        let s_3881_7: () = AMEVTYPER0_SysRegRead32_2e79e456f9d1dcd3(
            state,
            tracer,
            s_3881_0,
            s_3881_1,
            s_3881_2,
            s_3881_3,
            s_3881_4,
            s_3881_5,
            s_3881_6,
        );
        // N s_3881_8: return
        return;
    }
    fn block_3882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3882_0: read-var opc2:u8
        let s_3882_0: u8 = fn_state.opc2;
        // D s_3882_1: cast zx s_3882_0 -> bv
        let s_3882_1: Bits = Bits::new(s_3882_0 as u128, 3u16);
        // C s_3882_2: const #2u : u8
        let s_3882_2: u8 = 2;
        // C s_3882_3: cast zx s_3882_2 -> bv
        let s_3882_3: Bits = Bits::new(s_3882_2 as u128, 3u16);
        // D s_3882_4: cmp-eq s_3882_1 s_3882_3
        let s_3882_4: bool = ((s_3882_1) == (s_3882_3));
        // D s_3882_5: write-var gs#118979 <= s_3882_4
        fn_state.gs_118979 = s_3882_4;
        // N s_3882_6: jump b3221
        return block_3221(state, tracer, fn_state);
    }
    fn block_3883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3883_0: read-var opc1:u8
        let s_3883_0: u8 = fn_state.opc1;
        // D s_3883_1: cast zx s_3883_0 -> bv
        let s_3883_1: Bits = Bits::new(s_3883_0 as u128, 3u16);
        // C s_3883_2: const #0u : u8
        let s_3883_2: u8 = 0;
        // C s_3883_3: cast zx s_3883_2 -> bv
        let s_3883_3: Bits = Bits::new(s_3883_2 as u128, 3u16);
        // D s_3883_4: cmp-eq s_3883_1 s_3883_3
        let s_3883_4: bool = ((s_3883_1) == (s_3883_3));
        // D s_3883_5: write-var gs#118978 <= s_3883_4
        fn_state.gs_118978 = s_3883_4;
        // N s_3883_6: jump b3219
        return block_3219(state, tracer, fn_state);
    }
    fn block_3884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3884_0: read-var coproc:u8
        let s_3884_0: u8 = fn_state.coproc;
        // D s_3884_1: cast zx s_3884_0 -> bv
        let s_3884_1: Bits = Bits::new(s_3884_0 as u128, 4u16);
        // C s_3884_2: const #15u : u8
        let s_3884_2: u8 = 15;
        // C s_3884_3: cast zx s_3884_2 -> bv
        let s_3884_3: Bits = Bits::new(s_3884_2 as u128, 4u16);
        // D s_3884_4: cmp-eq s_3884_1 s_3884_3
        let s_3884_4: bool = ((s_3884_1) == (s_3884_3));
        // D s_3884_5: write-var gs#118977 <= s_3884_4
        fn_state.gs_118977 = s_3884_4;
        // N s_3884_6: jump b3217
        return block_3217(state, tracer, fn_state);
    }
    fn block_3885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3885_0: read-var CRn:u8
        let s_3885_0: u8 = fn_state.CRn;
        // D s_3885_1: cast zx s_3885_0 -> bv
        let s_3885_1: Bits = Bits::new(s_3885_0 as u128, 4u16);
        // C s_3885_2: const #13u : u8
        let s_3885_2: u8 = 13;
        // C s_3885_3: cast zx s_3885_2 -> bv
        let s_3885_3: Bits = Bits::new(s_3885_2 as u128, 4u16);
        // D s_3885_4: cmp-eq s_3885_1 s_3885_3
        let s_3885_4: bool = ((s_3885_1) == (s_3885_3));
        // D s_3885_5: write-var gs#118976 <= s_3885_4
        fn_state.gs_118976 = s_3885_4;
        // N s_3885_6: jump b3215
        return block_3215(state, tracer, fn_state);
    }
    fn block_3886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3886_0: read-var el:u8
        let s_3886_0: u8 = fn_state.el;
        // D s_3886_1: read-var coproc:u8
        let s_3886_1: u8 = fn_state.coproc;
        // D s_3886_2: read-var opc1:u8
        let s_3886_2: u8 = fn_state.opc1;
        // D s_3886_3: read-var CRn:u8
        let s_3886_3: u8 = fn_state.CRn;
        // D s_3886_4: read-var opc2:u8
        let s_3886_4: u8 = fn_state.opc2;
        // D s_3886_5: read-var CRm:u8
        let s_3886_5: u8 = fn_state.CRm;
        // D s_3886_6: read-var t:i
        let s_3886_6: i128 = fn_state.t;
        // D s_3886_7: call AMEVTYPER0_SysRegRead32_d72cb28d75eca03e(s_3886_0, s_3886_1, s_3886_2, s_3886_3, s_3886_4, s_3886_5, s_3886_6)
        let s_3886_7: () = AMEVTYPER0_SysRegRead32_d72cb28d75eca03e(
            state,
            tracer,
            s_3886_0,
            s_3886_1,
            s_3886_2,
            s_3886_3,
            s_3886_4,
            s_3886_5,
            s_3886_6,
        );
        // N s_3886_8: return
        return;
    }
    fn block_3887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3887_0: read-var opc2:u8
        let s_3887_0: u8 = fn_state.opc2;
        // D s_3887_1: cast zx s_3887_0 -> bv
        let s_3887_1: Bits = Bits::new(s_3887_0 as u128, 3u16);
        // C s_3887_2: const #3u : u8
        let s_3887_2: u8 = 3;
        // C s_3887_3: cast zx s_3887_2 -> bv
        let s_3887_3: Bits = Bits::new(s_3887_2 as u128, 3u16);
        // D s_3887_4: cmp-eq s_3887_1 s_3887_3
        let s_3887_4: bool = ((s_3887_1) == (s_3887_3));
        // D s_3887_5: write-var gs#118975 <= s_3887_4
        fn_state.gs_118975 = s_3887_4;
        // N s_3887_6: jump b3212
        return block_3212(state, tracer, fn_state);
    }
    fn block_3888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3888_0: read-var opc1:u8
        let s_3888_0: u8 = fn_state.opc1;
        // D s_3888_1: cast zx s_3888_0 -> bv
        let s_3888_1: Bits = Bits::new(s_3888_0 as u128, 3u16);
        // C s_3888_2: const #0u : u8
        let s_3888_2: u8 = 0;
        // C s_3888_3: cast zx s_3888_2 -> bv
        let s_3888_3: Bits = Bits::new(s_3888_2 as u128, 3u16);
        // D s_3888_4: cmp-eq s_3888_1 s_3888_3
        let s_3888_4: bool = ((s_3888_1) == (s_3888_3));
        // D s_3888_5: write-var gs#118974 <= s_3888_4
        fn_state.gs_118974 = s_3888_4;
        // N s_3888_6: jump b3210
        return block_3210(state, tracer, fn_state);
    }
    fn block_3889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3889_0: read-var coproc:u8
        let s_3889_0: u8 = fn_state.coproc;
        // D s_3889_1: cast zx s_3889_0 -> bv
        let s_3889_1: Bits = Bits::new(s_3889_0 as u128, 4u16);
        // C s_3889_2: const #15u : u8
        let s_3889_2: u8 = 15;
        // C s_3889_3: cast zx s_3889_2 -> bv
        let s_3889_3: Bits = Bits::new(s_3889_2 as u128, 4u16);
        // D s_3889_4: cmp-eq s_3889_1 s_3889_3
        let s_3889_4: bool = ((s_3889_1) == (s_3889_3));
        // D s_3889_5: write-var gs#118973 <= s_3889_4
        fn_state.gs_118973 = s_3889_4;
        // N s_3889_6: jump b3208
        return block_3208(state, tracer, fn_state);
    }
    fn block_3890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3890_0: read-var CRn:u8
        let s_3890_0: u8 = fn_state.CRn;
        // D s_3890_1: cast zx s_3890_0 -> bv
        let s_3890_1: Bits = Bits::new(s_3890_0 as u128, 4u16);
        // C s_3890_2: const #13u : u8
        let s_3890_2: u8 = 13;
        // C s_3890_3: cast zx s_3890_2 -> bv
        let s_3890_3: Bits = Bits::new(s_3890_2 as u128, 4u16);
        // D s_3890_4: cmp-eq s_3890_1 s_3890_3
        let s_3890_4: bool = ((s_3890_1) == (s_3890_3));
        // D s_3890_5: write-var gs#118972 <= s_3890_4
        fn_state.gs_118972 = s_3890_4;
        // N s_3890_6: jump b3206
        return block_3206(state, tracer, fn_state);
    }
    fn block_3891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3891_0: read-var el:u8
        let s_3891_0: u8 = fn_state.el;
        // D s_3891_1: read-var coproc:u8
        let s_3891_1: u8 = fn_state.coproc;
        // D s_3891_2: read-var opc1:u8
        let s_3891_2: u8 = fn_state.opc1;
        // D s_3891_3: read-var CRn:u8
        let s_3891_3: u8 = fn_state.CRn;
        // D s_3891_4: read-var opc2:u8
        let s_3891_4: u8 = fn_state.opc2;
        // D s_3891_5: read-var CRm:u8
        let s_3891_5: u8 = fn_state.CRm;
        // D s_3891_6: read-var t:i
        let s_3891_6: i128 = fn_state.t;
        // D s_3891_7: call ID_ISAR1_SysRegRead32_2151a78ccf12fa49(s_3891_0, s_3891_1, s_3891_2, s_3891_3, s_3891_4, s_3891_5, s_3891_6)
        let s_3891_7: () = ID_ISAR1_SysRegRead32_2151a78ccf12fa49(
            state,
            tracer,
            s_3891_0,
            s_3891_1,
            s_3891_2,
            s_3891_3,
            s_3891_4,
            s_3891_5,
            s_3891_6,
        );
        // N s_3891_8: return
        return;
    }
    fn block_3892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3892_0: read-var opc2:u8
        let s_3892_0: u8 = fn_state.opc2;
        // D s_3892_1: cast zx s_3892_0 -> bv
        let s_3892_1: Bits = Bits::new(s_3892_0 as u128, 3u16);
        // C s_3892_2: const #1u : u8
        let s_3892_2: u8 = 1;
        // C s_3892_3: cast zx s_3892_2 -> bv
        let s_3892_3: Bits = Bits::new(s_3892_2 as u128, 3u16);
        // D s_3892_4: cmp-eq s_3892_1 s_3892_3
        let s_3892_4: bool = ((s_3892_1) == (s_3892_3));
        // D s_3892_5: write-var gs#118971 <= s_3892_4
        fn_state.gs_118971 = s_3892_4;
        // N s_3892_6: jump b3203
        return block_3203(state, tracer, fn_state);
    }
    fn block_3893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3893_0: read-var opc1:u8
        let s_3893_0: u8 = fn_state.opc1;
        // D s_3893_1: cast zx s_3893_0 -> bv
        let s_3893_1: Bits = Bits::new(s_3893_0 as u128, 3u16);
        // C s_3893_2: const #0u : u8
        let s_3893_2: u8 = 0;
        // C s_3893_3: cast zx s_3893_2 -> bv
        let s_3893_3: Bits = Bits::new(s_3893_2 as u128, 3u16);
        // D s_3893_4: cmp-eq s_3893_1 s_3893_3
        let s_3893_4: bool = ((s_3893_1) == (s_3893_3));
        // D s_3893_5: write-var gs#118970 <= s_3893_4
        fn_state.gs_118970 = s_3893_4;
        // N s_3893_6: jump b3201
        return block_3201(state, tracer, fn_state);
    }
    fn block_3894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3894_0: read-var coproc:u8
        let s_3894_0: u8 = fn_state.coproc;
        // D s_3894_1: cast zx s_3894_0 -> bv
        let s_3894_1: Bits = Bits::new(s_3894_0 as u128, 4u16);
        // C s_3894_2: const #15u : u8
        let s_3894_2: u8 = 15;
        // C s_3894_3: cast zx s_3894_2 -> bv
        let s_3894_3: Bits = Bits::new(s_3894_2 as u128, 4u16);
        // D s_3894_4: cmp-eq s_3894_1 s_3894_3
        let s_3894_4: bool = ((s_3894_1) == (s_3894_3));
        // D s_3894_5: write-var gs#118969 <= s_3894_4
        fn_state.gs_118969 = s_3894_4;
        // N s_3894_6: jump b3199
        return block_3199(state, tracer, fn_state);
    }
    fn block_3895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3895_0: read-var CRn:u8
        let s_3895_0: u8 = fn_state.CRn;
        // D s_3895_1: cast zx s_3895_0 -> bv
        let s_3895_1: Bits = Bits::new(s_3895_0 as u128, 4u16);
        // C s_3895_2: const #0u : u8
        let s_3895_2: u8 = 0;
        // C s_3895_3: cast zx s_3895_2 -> bv
        let s_3895_3: Bits = Bits::new(s_3895_2 as u128, 4u16);
        // D s_3895_4: cmp-eq s_3895_1 s_3895_3
        let s_3895_4: bool = ((s_3895_1) == (s_3895_3));
        // D s_3895_5: write-var gs#118968 <= s_3895_4
        fn_state.gs_118968 = s_3895_4;
        // N s_3895_6: jump b3197
        return block_3197(state, tracer, fn_state);
    }
    fn block_3896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3896_0: read-var el:u8
        let s_3896_0: u8 = fn_state.el;
        // D s_3896_1: read-var coproc:u8
        let s_3896_1: u8 = fn_state.coproc;
        // D s_3896_2: read-var opc1:u8
        let s_3896_2: u8 = fn_state.opc1;
        // D s_3896_3: read-var CRn:u8
        let s_3896_3: u8 = fn_state.CRn;
        // D s_3896_4: read-var opc2:u8
        let s_3896_4: u8 = fn_state.opc2;
        // D s_3896_5: read-var CRm:u8
        let s_3896_5: u8 = fn_state.CRm;
        // D s_3896_6: read-var t:i
        let s_3896_6: i128 = fn_state.t;
        // D s_3896_7: call DLR_SysRegRead32_8fb9614c85c3b992(s_3896_0, s_3896_1, s_3896_2, s_3896_3, s_3896_4, s_3896_5, s_3896_6)
        let s_3896_7: () = DLR_SysRegRead32_8fb9614c85c3b992(
            state,
            tracer,
            s_3896_0,
            s_3896_1,
            s_3896_2,
            s_3896_3,
            s_3896_4,
            s_3896_5,
            s_3896_6,
        );
        // N s_3896_8: return
        return;
    }
    fn block_3897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3897_0: read-var opc2:u8
        let s_3897_0: u8 = fn_state.opc2;
        // D s_3897_1: cast zx s_3897_0 -> bv
        let s_3897_1: Bits = Bits::new(s_3897_0 as u128, 3u16);
        // C s_3897_2: const #1u : u8
        let s_3897_2: u8 = 1;
        // C s_3897_3: cast zx s_3897_2 -> bv
        let s_3897_3: Bits = Bits::new(s_3897_2 as u128, 3u16);
        // D s_3897_4: cmp-eq s_3897_1 s_3897_3
        let s_3897_4: bool = ((s_3897_1) == (s_3897_3));
        // D s_3897_5: write-var gs#118967 <= s_3897_4
        fn_state.gs_118967 = s_3897_4;
        // N s_3897_6: jump b3194
        return block_3194(state, tracer, fn_state);
    }
    fn block_3898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3898_0: read-var opc1:u8
        let s_3898_0: u8 = fn_state.opc1;
        // D s_3898_1: cast zx s_3898_0 -> bv
        let s_3898_1: Bits = Bits::new(s_3898_0 as u128, 3u16);
        // C s_3898_2: const #3u : u8
        let s_3898_2: u8 = 3;
        // C s_3898_3: cast zx s_3898_2 -> bv
        let s_3898_3: Bits = Bits::new(s_3898_2 as u128, 3u16);
        // D s_3898_4: cmp-eq s_3898_1 s_3898_3
        let s_3898_4: bool = ((s_3898_1) == (s_3898_3));
        // D s_3898_5: write-var gs#118966 <= s_3898_4
        fn_state.gs_118966 = s_3898_4;
        // N s_3898_6: jump b3192
        return block_3192(state, tracer, fn_state);
    }
    fn block_3899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3899_0: read-var coproc:u8
        let s_3899_0: u8 = fn_state.coproc;
        // D s_3899_1: cast zx s_3899_0 -> bv
        let s_3899_1: Bits = Bits::new(s_3899_0 as u128, 4u16);
        // C s_3899_2: const #15u : u8
        let s_3899_2: u8 = 15;
        // C s_3899_3: cast zx s_3899_2 -> bv
        let s_3899_3: Bits = Bits::new(s_3899_2 as u128, 4u16);
        // D s_3899_4: cmp-eq s_3899_1 s_3899_3
        let s_3899_4: bool = ((s_3899_1) == (s_3899_3));
        // D s_3899_5: write-var gs#118965 <= s_3899_4
        fn_state.gs_118965 = s_3899_4;
        // N s_3899_6: jump b3190
        return block_3190(state, tracer, fn_state);
    }
    fn block_3900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3900_0: read-var CRn:u8
        let s_3900_0: u8 = fn_state.CRn;
        // D s_3900_1: cast zx s_3900_0 -> bv
        let s_3900_1: Bits = Bits::new(s_3900_0 as u128, 4u16);
        // C s_3900_2: const #4u : u8
        let s_3900_2: u8 = 4;
        // C s_3900_3: cast zx s_3900_2 -> bv
        let s_3900_3: Bits = Bits::new(s_3900_2 as u128, 4u16);
        // D s_3900_4: cmp-eq s_3900_1 s_3900_3
        let s_3900_4: bool = ((s_3900_1) == (s_3900_3));
        // D s_3900_5: write-var gs#118964 <= s_3900_4
        fn_state.gs_118964 = s_3900_4;
        // N s_3900_6: jump b3188
        return block_3188(state, tracer, fn_state);
    }
    fn block_3901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3901_0: read-var el:u8
        let s_3901_0: u8 = fn_state.el;
        // D s_3901_1: read-var coproc:u8
        let s_3901_1: u8 = fn_state.coproc;
        // D s_3901_2: read-var opc1:u8
        let s_3901_2: u8 = fn_state.opc1;
        // D s_3901_3: read-var CRn:u8
        let s_3901_3: u8 = fn_state.CRn;
        // D s_3901_4: read-var opc2:u8
        let s_3901_4: u8 = fn_state.opc2;
        // D s_3901_5: read-var CRm:u8
        let s_3901_5: u8 = fn_state.CRm;
        // D s_3901_6: read-var t:i
        let s_3901_6: i128 = fn_state.t;
        // D s_3901_7: call SDCR_SysRegRead32_c381e11131eb8dc4(s_3901_0, s_3901_1, s_3901_2, s_3901_3, s_3901_4, s_3901_5, s_3901_6)
        let s_3901_7: () = SDCR_SysRegRead32_c381e11131eb8dc4(
            state,
            tracer,
            s_3901_0,
            s_3901_1,
            s_3901_2,
            s_3901_3,
            s_3901_4,
            s_3901_5,
            s_3901_6,
        );
        // N s_3901_8: return
        return;
    }
    fn block_3902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3902_0: read-var opc2:u8
        let s_3902_0: u8 = fn_state.opc2;
        // D s_3902_1: cast zx s_3902_0 -> bv
        let s_3902_1: Bits = Bits::new(s_3902_0 as u128, 3u16);
        // C s_3902_2: const #1u : u8
        let s_3902_2: u8 = 1;
        // C s_3902_3: cast zx s_3902_2 -> bv
        let s_3902_3: Bits = Bits::new(s_3902_2 as u128, 3u16);
        // D s_3902_4: cmp-eq s_3902_1 s_3902_3
        let s_3902_4: bool = ((s_3902_1) == (s_3902_3));
        // D s_3902_5: write-var gs#118963 <= s_3902_4
        fn_state.gs_118963 = s_3902_4;
        // N s_3902_6: jump b3185
        return block_3185(state, tracer, fn_state);
    }
    fn block_3903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3903_0: read-var opc1:u8
        let s_3903_0: u8 = fn_state.opc1;
        // D s_3903_1: cast zx s_3903_0 -> bv
        let s_3903_1: Bits = Bits::new(s_3903_0 as u128, 3u16);
        // C s_3903_2: const #0u : u8
        let s_3903_2: u8 = 0;
        // C s_3903_3: cast zx s_3903_2 -> bv
        let s_3903_3: Bits = Bits::new(s_3903_2 as u128, 3u16);
        // D s_3903_4: cmp-eq s_3903_1 s_3903_3
        let s_3903_4: bool = ((s_3903_1) == (s_3903_3));
        // D s_3903_5: write-var gs#118962 <= s_3903_4
        fn_state.gs_118962 = s_3903_4;
        // N s_3903_6: jump b3183
        return block_3183(state, tracer, fn_state);
    }
    fn block_3904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3904_0: read-var coproc:u8
        let s_3904_0: u8 = fn_state.coproc;
        // D s_3904_1: cast zx s_3904_0 -> bv
        let s_3904_1: Bits = Bits::new(s_3904_0 as u128, 4u16);
        // C s_3904_2: const #15u : u8
        let s_3904_2: u8 = 15;
        // C s_3904_3: cast zx s_3904_2 -> bv
        let s_3904_3: Bits = Bits::new(s_3904_2 as u128, 4u16);
        // D s_3904_4: cmp-eq s_3904_1 s_3904_3
        let s_3904_4: bool = ((s_3904_1) == (s_3904_3));
        // D s_3904_5: write-var gs#118961 <= s_3904_4
        fn_state.gs_118961 = s_3904_4;
        // N s_3904_6: jump b3181
        return block_3181(state, tracer, fn_state);
    }
    fn block_3905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3905_0: read-var CRn:u8
        let s_3905_0: u8 = fn_state.CRn;
        // D s_3905_1: cast zx s_3905_0 -> bv
        let s_3905_1: Bits = Bits::new(s_3905_0 as u128, 4u16);
        // C s_3905_2: const #1u : u8
        let s_3905_2: u8 = 1;
        // C s_3905_3: cast zx s_3905_2 -> bv
        let s_3905_3: Bits = Bits::new(s_3905_2 as u128, 4u16);
        // D s_3905_4: cmp-eq s_3905_1 s_3905_3
        let s_3905_4: bool = ((s_3905_1) == (s_3905_3));
        // D s_3905_5: write-var gs#118960 <= s_3905_4
        fn_state.gs_118960 = s_3905_4;
        // N s_3905_6: jump b3179
        return block_3179(state, tracer, fn_state);
    }
    fn block_3906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3906_0: read-var el:u8
        let s_3906_0: u8 = fn_state.el;
        // D s_3906_1: read-var coproc:u8
        let s_3906_1: u8 = fn_state.coproc;
        // D s_3906_2: read-var opc1:u8
        let s_3906_2: u8 = fn_state.opc1;
        // D s_3906_3: read-var CRn:u8
        let s_3906_3: u8 = fn_state.CRn;
        // D s_3906_4: read-var opc2:u8
        let s_3906_4: u8 = fn_state.opc2;
        // D s_3906_5: read-var CRm:u8
        let s_3906_5: u8 = fn_state.CRm;
        // D s_3906_6: read-var t:i
        let s_3906_6: i128 = fn_state.t;
        // D s_3906_7: call ICC_SRE_SysRegRead32_4fd5ef8b1be9c965(s_3906_0, s_3906_1, s_3906_2, s_3906_3, s_3906_4, s_3906_5, s_3906_6)
        let s_3906_7: () = ICC_SRE_SysRegRead32_4fd5ef8b1be9c965(
            state,
            tracer,
            s_3906_0,
            s_3906_1,
            s_3906_2,
            s_3906_3,
            s_3906_4,
            s_3906_5,
            s_3906_6,
        );
        // N s_3906_8: return
        return;
    }
    fn block_3907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3907_0: read-var opc2:u8
        let s_3907_0: u8 = fn_state.opc2;
        // D s_3907_1: cast zx s_3907_0 -> bv
        let s_3907_1: Bits = Bits::new(s_3907_0 as u128, 3u16);
        // C s_3907_2: const #5u : u8
        let s_3907_2: u8 = 5;
        // C s_3907_3: cast zx s_3907_2 -> bv
        let s_3907_3: Bits = Bits::new(s_3907_2 as u128, 3u16);
        // D s_3907_4: cmp-eq s_3907_1 s_3907_3
        let s_3907_4: bool = ((s_3907_1) == (s_3907_3));
        // D s_3907_5: write-var gs#118959 <= s_3907_4
        fn_state.gs_118959 = s_3907_4;
        // N s_3907_6: jump b3176
        return block_3176(state, tracer, fn_state);
    }
    fn block_3908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3908_0: read-var opc1:u8
        let s_3908_0: u8 = fn_state.opc1;
        // D s_3908_1: cast zx s_3908_0 -> bv
        let s_3908_1: Bits = Bits::new(s_3908_0 as u128, 3u16);
        // C s_3908_2: const #0u : u8
        let s_3908_2: u8 = 0;
        // C s_3908_3: cast zx s_3908_2 -> bv
        let s_3908_3: Bits = Bits::new(s_3908_2 as u128, 3u16);
        // D s_3908_4: cmp-eq s_3908_1 s_3908_3
        let s_3908_4: bool = ((s_3908_1) == (s_3908_3));
        // D s_3908_5: write-var gs#118958 <= s_3908_4
        fn_state.gs_118958 = s_3908_4;
        // N s_3908_6: jump b3174
        return block_3174(state, tracer, fn_state);
    }
    fn block_3909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3909_0: read-var coproc:u8
        let s_3909_0: u8 = fn_state.coproc;
        // D s_3909_1: cast zx s_3909_0 -> bv
        let s_3909_1: Bits = Bits::new(s_3909_0 as u128, 4u16);
        // C s_3909_2: const #15u : u8
        let s_3909_2: u8 = 15;
        // C s_3909_3: cast zx s_3909_2 -> bv
        let s_3909_3: Bits = Bits::new(s_3909_2 as u128, 4u16);
        // D s_3909_4: cmp-eq s_3909_1 s_3909_3
        let s_3909_4: bool = ((s_3909_1) == (s_3909_3));
        // D s_3909_5: write-var gs#118957 <= s_3909_4
        fn_state.gs_118957 = s_3909_4;
        // N s_3909_6: jump b3172
        return block_3172(state, tracer, fn_state);
    }
    fn block_3910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3910_0: read-var CRn:u8
        let s_3910_0: u8 = fn_state.CRn;
        // D s_3910_1: cast zx s_3910_0 -> bv
        let s_3910_1: Bits = Bits::new(s_3910_0 as u128, 4u16);
        // C s_3910_2: const #12u : u8
        let s_3910_2: u8 = 12;
        // C s_3910_3: cast zx s_3910_2 -> bv
        let s_3910_3: Bits = Bits::new(s_3910_2 as u128, 4u16);
        // D s_3910_4: cmp-eq s_3910_1 s_3910_3
        let s_3910_4: bool = ((s_3910_1) == (s_3910_3));
        // D s_3910_5: write-var gs#118956 <= s_3910_4
        fn_state.gs_118956 = s_3910_4;
        // N s_3910_6: jump b3170
        return block_3170(state, tracer, fn_state);
    }
    fn block_3911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3911_0: read-var el:u8
        let s_3911_0: u8 = fn_state.el;
        // D s_3911_1: read-var coproc:u8
        let s_3911_1: u8 = fn_state.coproc;
        // D s_3911_2: read-var opc1:u8
        let s_3911_2: u8 = fn_state.opc1;
        // D s_3911_3: read-var CRn:u8
        let s_3911_3: u8 = fn_state.CRn;
        // D s_3911_4: read-var opc2:u8
        let s_3911_4: u8 = fn_state.opc2;
        // D s_3911_5: read-var CRm:u8
        let s_3911_5: u8 = fn_state.CRm;
        // D s_3911_6: read-var t:i
        let s_3911_6: i128 = fn_state.t;
        // D s_3911_7: call DSPSR2_SysRegRead32_6da9b04f72c6c3f2(s_3911_0, s_3911_1, s_3911_2, s_3911_3, s_3911_4, s_3911_5, s_3911_6)
        let s_3911_7: () = DSPSR2_SysRegRead32_6da9b04f72c6c3f2(
            state,
            tracer,
            s_3911_0,
            s_3911_1,
            s_3911_2,
            s_3911_3,
            s_3911_4,
            s_3911_5,
            s_3911_6,
        );
        // N s_3911_8: return
        return;
    }
    fn block_3912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3912_0: read-var opc2:u8
        let s_3912_0: u8 = fn_state.opc2;
        // D s_3912_1: cast zx s_3912_0 -> bv
        let s_3912_1: Bits = Bits::new(s_3912_0 as u128, 3u16);
        // C s_3912_2: const #2u : u8
        let s_3912_2: u8 = 2;
        // C s_3912_3: cast zx s_3912_2 -> bv
        let s_3912_3: Bits = Bits::new(s_3912_2 as u128, 3u16);
        // D s_3912_4: cmp-eq s_3912_1 s_3912_3
        let s_3912_4: bool = ((s_3912_1) == (s_3912_3));
        // D s_3912_5: write-var gs#118955 <= s_3912_4
        fn_state.gs_118955 = s_3912_4;
        // N s_3912_6: jump b3167
        return block_3167(state, tracer, fn_state);
    }
    fn block_3913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3913_0: read-var opc1:u8
        let s_3913_0: u8 = fn_state.opc1;
        // D s_3913_1: cast zx s_3913_0 -> bv
        let s_3913_1: Bits = Bits::new(s_3913_0 as u128, 3u16);
        // C s_3913_2: const #3u : u8
        let s_3913_2: u8 = 3;
        // C s_3913_3: cast zx s_3913_2 -> bv
        let s_3913_3: Bits = Bits::new(s_3913_2 as u128, 3u16);
        // D s_3913_4: cmp-eq s_3913_1 s_3913_3
        let s_3913_4: bool = ((s_3913_1) == (s_3913_3));
        // D s_3913_5: write-var gs#118954 <= s_3913_4
        fn_state.gs_118954 = s_3913_4;
        // N s_3913_6: jump b3165
        return block_3165(state, tracer, fn_state);
    }
    fn block_3914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3914_0: read-var coproc:u8
        let s_3914_0: u8 = fn_state.coproc;
        // D s_3914_1: cast zx s_3914_0 -> bv
        let s_3914_1: Bits = Bits::new(s_3914_0 as u128, 4u16);
        // C s_3914_2: const #15u : u8
        let s_3914_2: u8 = 15;
        // C s_3914_3: cast zx s_3914_2 -> bv
        let s_3914_3: Bits = Bits::new(s_3914_2 as u128, 4u16);
        // D s_3914_4: cmp-eq s_3914_1 s_3914_3
        let s_3914_4: bool = ((s_3914_1) == (s_3914_3));
        // D s_3914_5: write-var gs#118953 <= s_3914_4
        fn_state.gs_118953 = s_3914_4;
        // N s_3914_6: jump b3163
        return block_3163(state, tracer, fn_state);
    }
    fn block_3915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3915_0: read-var CRn:u8
        let s_3915_0: u8 = fn_state.CRn;
        // D s_3915_1: cast zx s_3915_0 -> bv
        let s_3915_1: Bits = Bits::new(s_3915_0 as u128, 4u16);
        // C s_3915_2: const #4u : u8
        let s_3915_2: u8 = 4;
        // C s_3915_3: cast zx s_3915_2 -> bv
        let s_3915_3: Bits = Bits::new(s_3915_2 as u128, 4u16);
        // D s_3915_4: cmp-eq s_3915_1 s_3915_3
        let s_3915_4: bool = ((s_3915_1) == (s_3915_3));
        // D s_3915_5: write-var gs#118952 <= s_3915_4
        fn_state.gs_118952 = s_3915_4;
        // N s_3915_6: jump b3161
        return block_3161(state, tracer, fn_state);
    }
    fn block_3916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3916_0: read-var el:u8
        let s_3916_0: u8 = fn_state.el;
        // D s_3916_1: read-var coproc:u8
        let s_3916_1: u8 = fn_state.coproc;
        // D s_3916_2: read-var opc1:u8
        let s_3916_2: u8 = fn_state.opc1;
        // D s_3916_3: read-var CRn:u8
        let s_3916_3: u8 = fn_state.CRn;
        // D s_3916_4: read-var opc2:u8
        let s_3916_4: u8 = fn_state.opc2;
        // D s_3916_5: read-var CRm:u8
        let s_3916_5: u8 = fn_state.CRm;
        // D s_3916_6: read-var t:i
        let s_3916_6: i128 = fn_state.t;
        // D s_3916_7: call ICH_LRC_SysRegRead32_fa7f4e2cc52b6a12(s_3916_0, s_3916_1, s_3916_2, s_3916_3, s_3916_4, s_3916_5, s_3916_6)
        let s_3916_7: () = ICH_LRC_SysRegRead32_fa7f4e2cc52b6a12(
            state,
            tracer,
            s_3916_0,
            s_3916_1,
            s_3916_2,
            s_3916_3,
            s_3916_4,
            s_3916_5,
            s_3916_6,
        );
        // N s_3916_8: return
        return;
    }
    fn block_3917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3917_0: read-var opc2:u8
        let s_3917_0: u8 = fn_state.opc2;
        // D s_3917_1: cast zx s_3917_0 -> bv
        let s_3917_1: Bits = Bits::new(s_3917_0 as u128, 3u16);
        // C s_3917_2: const #0u : u8
        let s_3917_2: u8 = 0;
        // C s_3917_3: cast zx s_3917_2 -> bv
        let s_3917_3: Bits = Bits::new(s_3917_2 as u128, 3u16);
        // D s_3917_4: cmp-eq s_3917_1 s_3917_3
        let s_3917_4: bool = ((s_3917_1) == (s_3917_3));
        // D s_3917_5: write-var gs#118951 <= s_3917_4
        fn_state.gs_118951 = s_3917_4;
        // N s_3917_6: jump b3158
        return block_3158(state, tracer, fn_state);
    }
    fn block_3918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3918_0: read-var opc1:u8
        let s_3918_0: u8 = fn_state.opc1;
        // D s_3918_1: cast zx s_3918_0 -> bv
        let s_3918_1: Bits = Bits::new(s_3918_0 as u128, 3u16);
        // C s_3918_2: const #4u : u8
        let s_3918_2: u8 = 4;
        // C s_3918_3: cast zx s_3918_2 -> bv
        let s_3918_3: Bits = Bits::new(s_3918_2 as u128, 3u16);
        // D s_3918_4: cmp-eq s_3918_1 s_3918_3
        let s_3918_4: bool = ((s_3918_1) == (s_3918_3));
        // D s_3918_5: write-var gs#118950 <= s_3918_4
        fn_state.gs_118950 = s_3918_4;
        // N s_3918_6: jump b3156
        return block_3156(state, tracer, fn_state);
    }
    fn block_3919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3919_0: read-var coproc:u8
        let s_3919_0: u8 = fn_state.coproc;
        // D s_3919_1: cast zx s_3919_0 -> bv
        let s_3919_1: Bits = Bits::new(s_3919_0 as u128, 4u16);
        // C s_3919_2: const #15u : u8
        let s_3919_2: u8 = 15;
        // C s_3919_3: cast zx s_3919_2 -> bv
        let s_3919_3: Bits = Bits::new(s_3919_2 as u128, 4u16);
        // D s_3919_4: cmp-eq s_3919_1 s_3919_3
        let s_3919_4: bool = ((s_3919_1) == (s_3919_3));
        // D s_3919_5: write-var gs#118949 <= s_3919_4
        fn_state.gs_118949 = s_3919_4;
        // N s_3919_6: jump b3154
        return block_3154(state, tracer, fn_state);
    }
    fn block_3920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3920_0: read-var CRn:u8
        let s_3920_0: u8 = fn_state.CRn;
        // D s_3920_1: cast zx s_3920_0 -> bv
        let s_3920_1: Bits = Bits::new(s_3920_0 as u128, 4u16);
        // C s_3920_2: const #12u : u8
        let s_3920_2: u8 = 12;
        // C s_3920_3: cast zx s_3920_2 -> bv
        let s_3920_3: Bits = Bits::new(s_3920_2 as u128, 4u16);
        // D s_3920_4: cmp-eq s_3920_1 s_3920_3
        let s_3920_4: bool = ((s_3920_1) == (s_3920_3));
        // D s_3920_5: write-var gs#118948 <= s_3920_4
        fn_state.gs_118948 = s_3920_4;
        // N s_3920_6: jump b3152
        return block_3152(state, tracer, fn_state);
    }
    fn block_3921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3921_0: read-var el:u8
        let s_3921_0: u8 = fn_state.el;
        // D s_3921_1: read-var coproc:u8
        let s_3921_1: u8 = fn_state.coproc;
        // D s_3921_2: read-var opc1:u8
        let s_3921_2: u8 = fn_state.opc1;
        // D s_3921_3: read-var CRn:u8
        let s_3921_3: u8 = fn_state.CRn;
        // D s_3921_4: read-var opc2:u8
        let s_3921_4: u8 = fn_state.opc2;
        // D s_3921_5: read-var CRm:u8
        let s_3921_5: u8 = fn_state.CRm;
        // D s_3921_6: read-var t:i
        let s_3921_6: i128 = fn_state.t;
        // D s_3921_7: call ICH_LRC_SysRegRead32_ce80e380eb49f8f4(s_3921_0, s_3921_1, s_3921_2, s_3921_3, s_3921_4, s_3921_5, s_3921_6)
        let s_3921_7: () = ICH_LRC_SysRegRead32_ce80e380eb49f8f4(
            state,
            tracer,
            s_3921_0,
            s_3921_1,
            s_3921_2,
            s_3921_3,
            s_3921_4,
            s_3921_5,
            s_3921_6,
        );
        // N s_3921_8: return
        return;
    }
    fn block_3922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3922_0: read-var opc2:u8
        let s_3922_0: u8 = fn_state.opc2;
        // D s_3922_1: cast zx s_3922_0 -> bv
        let s_3922_1: Bits = Bits::new(s_3922_0 as u128, 3u16);
        // C s_3922_2: const #1u : u8
        let s_3922_2: u8 = 1;
        // C s_3922_3: cast zx s_3922_2 -> bv
        let s_3922_3: Bits = Bits::new(s_3922_2 as u128, 3u16);
        // D s_3922_4: cmp-eq s_3922_1 s_3922_3
        let s_3922_4: bool = ((s_3922_1) == (s_3922_3));
        // D s_3922_5: write-var gs#118947 <= s_3922_4
        fn_state.gs_118947 = s_3922_4;
        // N s_3922_6: jump b3149
        return block_3149(state, tracer, fn_state);
    }
    fn block_3923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3923_0: read-var opc1:u8
        let s_3923_0: u8 = fn_state.opc1;
        // D s_3923_1: cast zx s_3923_0 -> bv
        let s_3923_1: Bits = Bits::new(s_3923_0 as u128, 3u16);
        // C s_3923_2: const #4u : u8
        let s_3923_2: u8 = 4;
        // C s_3923_3: cast zx s_3923_2 -> bv
        let s_3923_3: Bits = Bits::new(s_3923_2 as u128, 3u16);
        // D s_3923_4: cmp-eq s_3923_1 s_3923_3
        let s_3923_4: bool = ((s_3923_1) == (s_3923_3));
        // D s_3923_5: write-var gs#118946 <= s_3923_4
        fn_state.gs_118946 = s_3923_4;
        // N s_3923_6: jump b3147
        return block_3147(state, tracer, fn_state);
    }
    fn block_3924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3924_0: read-var coproc:u8
        let s_3924_0: u8 = fn_state.coproc;
        // D s_3924_1: cast zx s_3924_0 -> bv
        let s_3924_1: Bits = Bits::new(s_3924_0 as u128, 4u16);
        // C s_3924_2: const #15u : u8
        let s_3924_2: u8 = 15;
        // C s_3924_3: cast zx s_3924_2 -> bv
        let s_3924_3: Bits = Bits::new(s_3924_2 as u128, 4u16);
        // D s_3924_4: cmp-eq s_3924_1 s_3924_3
        let s_3924_4: bool = ((s_3924_1) == (s_3924_3));
        // D s_3924_5: write-var gs#118945 <= s_3924_4
        fn_state.gs_118945 = s_3924_4;
        // N s_3924_6: jump b3145
        return block_3145(state, tracer, fn_state);
    }
    fn block_3925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3925_0: read-var CRn:u8
        let s_3925_0: u8 = fn_state.CRn;
        // D s_3925_1: cast zx s_3925_0 -> bv
        let s_3925_1: Bits = Bits::new(s_3925_0 as u128, 4u16);
        // C s_3925_2: const #12u : u8
        let s_3925_2: u8 = 12;
        // C s_3925_3: cast zx s_3925_2 -> bv
        let s_3925_3: Bits = Bits::new(s_3925_2 as u128, 4u16);
        // D s_3925_4: cmp-eq s_3925_1 s_3925_3
        let s_3925_4: bool = ((s_3925_1) == (s_3925_3));
        // D s_3925_5: write-var gs#118944 <= s_3925_4
        fn_state.gs_118944 = s_3925_4;
        // N s_3925_6: jump b3143
        return block_3143(state, tracer, fn_state);
    }
    fn block_3926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3926_0: read-var el:u8
        let s_3926_0: u8 = fn_state.el;
        // D s_3926_1: read-var coproc:u8
        let s_3926_1: u8 = fn_state.coproc;
        // D s_3926_2: read-var opc1:u8
        let s_3926_2: u8 = fn_state.opc1;
        // D s_3926_3: read-var CRn:u8
        let s_3926_3: u8 = fn_state.CRn;
        // D s_3926_4: read-var opc2:u8
        let s_3926_4: u8 = fn_state.opc2;
        // D s_3926_5: read-var CRm:u8
        let s_3926_5: u8 = fn_state.CRm;
        // D s_3926_6: read-var t:i
        let s_3926_6: i128 = fn_state.t;
        // D s_3926_7: call ICH_LRC_SysRegRead32_792ff81aa718ff76(s_3926_0, s_3926_1, s_3926_2, s_3926_3, s_3926_4, s_3926_5, s_3926_6)
        let s_3926_7: () = ICH_LRC_SysRegRead32_792ff81aa718ff76(
            state,
            tracer,
            s_3926_0,
            s_3926_1,
            s_3926_2,
            s_3926_3,
            s_3926_4,
            s_3926_5,
            s_3926_6,
        );
        // N s_3926_8: return
        return;
    }
    fn block_3927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3927_0: read-var opc2:u8
        let s_3927_0: u8 = fn_state.opc2;
        // D s_3927_1: cast zx s_3927_0 -> bv
        let s_3927_1: Bits = Bits::new(s_3927_0 as u128, 3u16);
        // C s_3927_2: const #2u : u8
        let s_3927_2: u8 = 2;
        // C s_3927_3: cast zx s_3927_2 -> bv
        let s_3927_3: Bits = Bits::new(s_3927_2 as u128, 3u16);
        // D s_3927_4: cmp-eq s_3927_1 s_3927_3
        let s_3927_4: bool = ((s_3927_1) == (s_3927_3));
        // D s_3927_5: write-var gs#118943 <= s_3927_4
        fn_state.gs_118943 = s_3927_4;
        // N s_3927_6: jump b3140
        return block_3140(state, tracer, fn_state);
    }
    fn block_3928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3928_0: read-var opc1:u8
        let s_3928_0: u8 = fn_state.opc1;
        // D s_3928_1: cast zx s_3928_0 -> bv
        let s_3928_1: Bits = Bits::new(s_3928_0 as u128, 3u16);
        // C s_3928_2: const #4u : u8
        let s_3928_2: u8 = 4;
        // C s_3928_3: cast zx s_3928_2 -> bv
        let s_3928_3: Bits = Bits::new(s_3928_2 as u128, 3u16);
        // D s_3928_4: cmp-eq s_3928_1 s_3928_3
        let s_3928_4: bool = ((s_3928_1) == (s_3928_3));
        // D s_3928_5: write-var gs#118942 <= s_3928_4
        fn_state.gs_118942 = s_3928_4;
        // N s_3928_6: jump b3138
        return block_3138(state, tracer, fn_state);
    }
    fn block_3929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3929_0: read-var coproc:u8
        let s_3929_0: u8 = fn_state.coproc;
        // D s_3929_1: cast zx s_3929_0 -> bv
        let s_3929_1: Bits = Bits::new(s_3929_0 as u128, 4u16);
        // C s_3929_2: const #15u : u8
        let s_3929_2: u8 = 15;
        // C s_3929_3: cast zx s_3929_2 -> bv
        let s_3929_3: Bits = Bits::new(s_3929_2 as u128, 4u16);
        // D s_3929_4: cmp-eq s_3929_1 s_3929_3
        let s_3929_4: bool = ((s_3929_1) == (s_3929_3));
        // D s_3929_5: write-var gs#118941 <= s_3929_4
        fn_state.gs_118941 = s_3929_4;
        // N s_3929_6: jump b3136
        return block_3136(state, tracer, fn_state);
    }
    fn block_3930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3930_0: read-var CRn:u8
        let s_3930_0: u8 = fn_state.CRn;
        // D s_3930_1: cast zx s_3930_0 -> bv
        let s_3930_1: Bits = Bits::new(s_3930_0 as u128, 4u16);
        // C s_3930_2: const #12u : u8
        let s_3930_2: u8 = 12;
        // C s_3930_3: cast zx s_3930_2 -> bv
        let s_3930_3: Bits = Bits::new(s_3930_2 as u128, 4u16);
        // D s_3930_4: cmp-eq s_3930_1 s_3930_3
        let s_3930_4: bool = ((s_3930_1) == (s_3930_3));
        // D s_3930_5: write-var gs#118940 <= s_3930_4
        fn_state.gs_118940 = s_3930_4;
        // N s_3930_6: jump b3134
        return block_3134(state, tracer, fn_state);
    }
    fn block_3931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3931_0: read-var el:u8
        let s_3931_0: u8 = fn_state.el;
        // D s_3931_1: read-var coproc:u8
        let s_3931_1: u8 = fn_state.coproc;
        // D s_3931_2: read-var opc1:u8
        let s_3931_2: u8 = fn_state.opc1;
        // D s_3931_3: read-var CRn:u8
        let s_3931_3: u8 = fn_state.CRn;
        // D s_3931_4: read-var opc2:u8
        let s_3931_4: u8 = fn_state.opc2;
        // D s_3931_5: read-var CRm:u8
        let s_3931_5: u8 = fn_state.CRm;
        // D s_3931_6: read-var t:i
        let s_3931_6: i128 = fn_state.t;
        // D s_3931_7: call ICH_LRC_SysRegRead32_a29c320b6a841a2d(s_3931_0, s_3931_1, s_3931_2, s_3931_3, s_3931_4, s_3931_5, s_3931_6)
        let s_3931_7: () = ICH_LRC_SysRegRead32_a29c320b6a841a2d(
            state,
            tracer,
            s_3931_0,
            s_3931_1,
            s_3931_2,
            s_3931_3,
            s_3931_4,
            s_3931_5,
            s_3931_6,
        );
        // N s_3931_8: return
        return;
    }
    fn block_3932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3932_0: read-var opc2:u8
        let s_3932_0: u8 = fn_state.opc2;
        // D s_3932_1: cast zx s_3932_0 -> bv
        let s_3932_1: Bits = Bits::new(s_3932_0 as u128, 3u16);
        // C s_3932_2: const #3u : u8
        let s_3932_2: u8 = 3;
        // C s_3932_3: cast zx s_3932_2 -> bv
        let s_3932_3: Bits = Bits::new(s_3932_2 as u128, 3u16);
        // D s_3932_4: cmp-eq s_3932_1 s_3932_3
        let s_3932_4: bool = ((s_3932_1) == (s_3932_3));
        // D s_3932_5: write-var gs#118939 <= s_3932_4
        fn_state.gs_118939 = s_3932_4;
        // N s_3932_6: jump b3131
        return block_3131(state, tracer, fn_state);
    }
    fn block_3933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3933_0: read-var opc1:u8
        let s_3933_0: u8 = fn_state.opc1;
        // D s_3933_1: cast zx s_3933_0 -> bv
        let s_3933_1: Bits = Bits::new(s_3933_0 as u128, 3u16);
        // C s_3933_2: const #4u : u8
        let s_3933_2: u8 = 4;
        // C s_3933_3: cast zx s_3933_2 -> bv
        let s_3933_3: Bits = Bits::new(s_3933_2 as u128, 3u16);
        // D s_3933_4: cmp-eq s_3933_1 s_3933_3
        let s_3933_4: bool = ((s_3933_1) == (s_3933_3));
        // D s_3933_5: write-var gs#118938 <= s_3933_4
        fn_state.gs_118938 = s_3933_4;
        // N s_3933_6: jump b3129
        return block_3129(state, tracer, fn_state);
    }
    fn block_3934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3934_0: read-var coproc:u8
        let s_3934_0: u8 = fn_state.coproc;
        // D s_3934_1: cast zx s_3934_0 -> bv
        let s_3934_1: Bits = Bits::new(s_3934_0 as u128, 4u16);
        // C s_3934_2: const #15u : u8
        let s_3934_2: u8 = 15;
        // C s_3934_3: cast zx s_3934_2 -> bv
        let s_3934_3: Bits = Bits::new(s_3934_2 as u128, 4u16);
        // D s_3934_4: cmp-eq s_3934_1 s_3934_3
        let s_3934_4: bool = ((s_3934_1) == (s_3934_3));
        // D s_3934_5: write-var gs#118937 <= s_3934_4
        fn_state.gs_118937 = s_3934_4;
        // N s_3934_6: jump b3127
        return block_3127(state, tracer, fn_state);
    }
    fn block_3935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3935_0: read-var CRn:u8
        let s_3935_0: u8 = fn_state.CRn;
        // D s_3935_1: cast zx s_3935_0 -> bv
        let s_3935_1: Bits = Bits::new(s_3935_0 as u128, 4u16);
        // C s_3935_2: const #12u : u8
        let s_3935_2: u8 = 12;
        // C s_3935_3: cast zx s_3935_2 -> bv
        let s_3935_3: Bits = Bits::new(s_3935_2 as u128, 4u16);
        // D s_3935_4: cmp-eq s_3935_1 s_3935_3
        let s_3935_4: bool = ((s_3935_1) == (s_3935_3));
        // D s_3935_5: write-var gs#118936 <= s_3935_4
        fn_state.gs_118936 = s_3935_4;
        // N s_3935_6: jump b3125
        return block_3125(state, tracer, fn_state);
    }
    fn block_3936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3936_0: read-var el:u8
        let s_3936_0: u8 = fn_state.el;
        // D s_3936_1: read-var coproc:u8
        let s_3936_1: u8 = fn_state.coproc;
        // D s_3936_2: read-var opc1:u8
        let s_3936_2: u8 = fn_state.opc1;
        // D s_3936_3: read-var CRn:u8
        let s_3936_3: u8 = fn_state.CRn;
        // D s_3936_4: read-var opc2:u8
        let s_3936_4: u8 = fn_state.opc2;
        // D s_3936_5: read-var CRm:u8
        let s_3936_5: u8 = fn_state.CRm;
        // D s_3936_6: read-var t:i
        let s_3936_6: i128 = fn_state.t;
        // D s_3936_7: call ICH_LRC_SysRegRead32_1fc599a8419d7830(s_3936_0, s_3936_1, s_3936_2, s_3936_3, s_3936_4, s_3936_5, s_3936_6)
        let s_3936_7: () = ICH_LRC_SysRegRead32_1fc599a8419d7830(
            state,
            tracer,
            s_3936_0,
            s_3936_1,
            s_3936_2,
            s_3936_3,
            s_3936_4,
            s_3936_5,
            s_3936_6,
        );
        // N s_3936_8: return
        return;
    }
    fn block_3937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3937_0: read-var opc2:u8
        let s_3937_0: u8 = fn_state.opc2;
        // D s_3937_1: cast zx s_3937_0 -> bv
        let s_3937_1: Bits = Bits::new(s_3937_0 as u128, 3u16);
        // C s_3937_2: const #4u : u8
        let s_3937_2: u8 = 4;
        // C s_3937_3: cast zx s_3937_2 -> bv
        let s_3937_3: Bits = Bits::new(s_3937_2 as u128, 3u16);
        // D s_3937_4: cmp-eq s_3937_1 s_3937_3
        let s_3937_4: bool = ((s_3937_1) == (s_3937_3));
        // D s_3937_5: write-var gs#118935 <= s_3937_4
        fn_state.gs_118935 = s_3937_4;
        // N s_3937_6: jump b3122
        return block_3122(state, tracer, fn_state);
    }
    fn block_3938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3938_0: read-var opc1:u8
        let s_3938_0: u8 = fn_state.opc1;
        // D s_3938_1: cast zx s_3938_0 -> bv
        let s_3938_1: Bits = Bits::new(s_3938_0 as u128, 3u16);
        // C s_3938_2: const #4u : u8
        let s_3938_2: u8 = 4;
        // C s_3938_3: cast zx s_3938_2 -> bv
        let s_3938_3: Bits = Bits::new(s_3938_2 as u128, 3u16);
        // D s_3938_4: cmp-eq s_3938_1 s_3938_3
        let s_3938_4: bool = ((s_3938_1) == (s_3938_3));
        // D s_3938_5: write-var gs#118934 <= s_3938_4
        fn_state.gs_118934 = s_3938_4;
        // N s_3938_6: jump b3120
        return block_3120(state, tracer, fn_state);
    }
    fn block_3939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3939_0: read-var coproc:u8
        let s_3939_0: u8 = fn_state.coproc;
        // D s_3939_1: cast zx s_3939_0 -> bv
        let s_3939_1: Bits = Bits::new(s_3939_0 as u128, 4u16);
        // C s_3939_2: const #15u : u8
        let s_3939_2: u8 = 15;
        // C s_3939_3: cast zx s_3939_2 -> bv
        let s_3939_3: Bits = Bits::new(s_3939_2 as u128, 4u16);
        // D s_3939_4: cmp-eq s_3939_1 s_3939_3
        let s_3939_4: bool = ((s_3939_1) == (s_3939_3));
        // D s_3939_5: write-var gs#118933 <= s_3939_4
        fn_state.gs_118933 = s_3939_4;
        // N s_3939_6: jump b3118
        return block_3118(state, tracer, fn_state);
    }
    fn block_3940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3940_0: read-var CRn:u8
        let s_3940_0: u8 = fn_state.CRn;
        // D s_3940_1: cast zx s_3940_0 -> bv
        let s_3940_1: Bits = Bits::new(s_3940_0 as u128, 4u16);
        // C s_3940_2: const #12u : u8
        let s_3940_2: u8 = 12;
        // C s_3940_3: cast zx s_3940_2 -> bv
        let s_3940_3: Bits = Bits::new(s_3940_2 as u128, 4u16);
        // D s_3940_4: cmp-eq s_3940_1 s_3940_3
        let s_3940_4: bool = ((s_3940_1) == (s_3940_3));
        // D s_3940_5: write-var gs#118932 <= s_3940_4
        fn_state.gs_118932 = s_3940_4;
        // N s_3940_6: jump b3116
        return block_3116(state, tracer, fn_state);
    }
    fn block_3941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3941_0: read-var el:u8
        let s_3941_0: u8 = fn_state.el;
        // D s_3941_1: read-var coproc:u8
        let s_3941_1: u8 = fn_state.coproc;
        // D s_3941_2: read-var opc1:u8
        let s_3941_2: u8 = fn_state.opc1;
        // D s_3941_3: read-var CRn:u8
        let s_3941_3: u8 = fn_state.CRn;
        // D s_3941_4: read-var opc2:u8
        let s_3941_4: u8 = fn_state.opc2;
        // D s_3941_5: read-var CRm:u8
        let s_3941_5: u8 = fn_state.CRm;
        // D s_3941_6: read-var t:i
        let s_3941_6: i128 = fn_state.t;
        // D s_3941_7: call ICH_LRC_SysRegRead32_376ab6d5a4721697(s_3941_0, s_3941_1, s_3941_2, s_3941_3, s_3941_4, s_3941_5, s_3941_6)
        let s_3941_7: () = ICH_LRC_SysRegRead32_376ab6d5a4721697(
            state,
            tracer,
            s_3941_0,
            s_3941_1,
            s_3941_2,
            s_3941_3,
            s_3941_4,
            s_3941_5,
            s_3941_6,
        );
        // N s_3941_8: return
        return;
    }
    fn block_3942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3942_0: read-var opc2:u8
        let s_3942_0: u8 = fn_state.opc2;
        // D s_3942_1: cast zx s_3942_0 -> bv
        let s_3942_1: Bits = Bits::new(s_3942_0 as u128, 3u16);
        // C s_3942_2: const #5u : u8
        let s_3942_2: u8 = 5;
        // C s_3942_3: cast zx s_3942_2 -> bv
        let s_3942_3: Bits = Bits::new(s_3942_2 as u128, 3u16);
        // D s_3942_4: cmp-eq s_3942_1 s_3942_3
        let s_3942_4: bool = ((s_3942_1) == (s_3942_3));
        // D s_3942_5: write-var gs#118931 <= s_3942_4
        fn_state.gs_118931 = s_3942_4;
        // N s_3942_6: jump b3113
        return block_3113(state, tracer, fn_state);
    }
    fn block_3943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3943_0: read-var opc1:u8
        let s_3943_0: u8 = fn_state.opc1;
        // D s_3943_1: cast zx s_3943_0 -> bv
        let s_3943_1: Bits = Bits::new(s_3943_0 as u128, 3u16);
        // C s_3943_2: const #4u : u8
        let s_3943_2: u8 = 4;
        // C s_3943_3: cast zx s_3943_2 -> bv
        let s_3943_3: Bits = Bits::new(s_3943_2 as u128, 3u16);
        // D s_3943_4: cmp-eq s_3943_1 s_3943_3
        let s_3943_4: bool = ((s_3943_1) == (s_3943_3));
        // D s_3943_5: write-var gs#118930 <= s_3943_4
        fn_state.gs_118930 = s_3943_4;
        // N s_3943_6: jump b3111
        return block_3111(state, tracer, fn_state);
    }
    fn block_3944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3944_0: read-var coproc:u8
        let s_3944_0: u8 = fn_state.coproc;
        // D s_3944_1: cast zx s_3944_0 -> bv
        let s_3944_1: Bits = Bits::new(s_3944_0 as u128, 4u16);
        // C s_3944_2: const #15u : u8
        let s_3944_2: u8 = 15;
        // C s_3944_3: cast zx s_3944_2 -> bv
        let s_3944_3: Bits = Bits::new(s_3944_2 as u128, 4u16);
        // D s_3944_4: cmp-eq s_3944_1 s_3944_3
        let s_3944_4: bool = ((s_3944_1) == (s_3944_3));
        // D s_3944_5: write-var gs#118929 <= s_3944_4
        fn_state.gs_118929 = s_3944_4;
        // N s_3944_6: jump b3109
        return block_3109(state, tracer, fn_state);
    }
    fn block_3945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3945_0: read-var CRn:u8
        let s_3945_0: u8 = fn_state.CRn;
        // D s_3945_1: cast zx s_3945_0 -> bv
        let s_3945_1: Bits = Bits::new(s_3945_0 as u128, 4u16);
        // C s_3945_2: const #12u : u8
        let s_3945_2: u8 = 12;
        // C s_3945_3: cast zx s_3945_2 -> bv
        let s_3945_3: Bits = Bits::new(s_3945_2 as u128, 4u16);
        // D s_3945_4: cmp-eq s_3945_1 s_3945_3
        let s_3945_4: bool = ((s_3945_1) == (s_3945_3));
        // D s_3945_5: write-var gs#118928 <= s_3945_4
        fn_state.gs_118928 = s_3945_4;
        // N s_3945_6: jump b3107
        return block_3107(state, tracer, fn_state);
    }
    fn block_3946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3946_0: read-var el:u8
        let s_3946_0: u8 = fn_state.el;
        // D s_3946_1: read-var coproc:u8
        let s_3946_1: u8 = fn_state.coproc;
        // D s_3946_2: read-var opc1:u8
        let s_3946_2: u8 = fn_state.opc1;
        // D s_3946_3: read-var CRn:u8
        let s_3946_3: u8 = fn_state.CRn;
        // D s_3946_4: read-var opc2:u8
        let s_3946_4: u8 = fn_state.opc2;
        // D s_3946_5: read-var CRm:u8
        let s_3946_5: u8 = fn_state.CRm;
        // D s_3946_6: read-var t:i
        let s_3946_6: i128 = fn_state.t;
        // D s_3946_7: call ICH_LRC_SysRegRead32_2f30eacc54c36948(s_3946_0, s_3946_1, s_3946_2, s_3946_3, s_3946_4, s_3946_5, s_3946_6)
        let s_3946_7: () = ICH_LRC_SysRegRead32_2f30eacc54c36948(
            state,
            tracer,
            s_3946_0,
            s_3946_1,
            s_3946_2,
            s_3946_3,
            s_3946_4,
            s_3946_5,
            s_3946_6,
        );
        // N s_3946_8: return
        return;
    }
    fn block_3947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3947_0: read-var opc2:u8
        let s_3947_0: u8 = fn_state.opc2;
        // D s_3947_1: cast zx s_3947_0 -> bv
        let s_3947_1: Bits = Bits::new(s_3947_0 as u128, 3u16);
        // C s_3947_2: const #6u : u8
        let s_3947_2: u8 = 6;
        // C s_3947_3: cast zx s_3947_2 -> bv
        let s_3947_3: Bits = Bits::new(s_3947_2 as u128, 3u16);
        // D s_3947_4: cmp-eq s_3947_1 s_3947_3
        let s_3947_4: bool = ((s_3947_1) == (s_3947_3));
        // D s_3947_5: write-var gs#118927 <= s_3947_4
        fn_state.gs_118927 = s_3947_4;
        // N s_3947_6: jump b3104
        return block_3104(state, tracer, fn_state);
    }
    fn block_3948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3948_0: read-var opc1:u8
        let s_3948_0: u8 = fn_state.opc1;
        // D s_3948_1: cast zx s_3948_0 -> bv
        let s_3948_1: Bits = Bits::new(s_3948_0 as u128, 3u16);
        // C s_3948_2: const #4u : u8
        let s_3948_2: u8 = 4;
        // C s_3948_3: cast zx s_3948_2 -> bv
        let s_3948_3: Bits = Bits::new(s_3948_2 as u128, 3u16);
        // D s_3948_4: cmp-eq s_3948_1 s_3948_3
        let s_3948_4: bool = ((s_3948_1) == (s_3948_3));
        // D s_3948_5: write-var gs#118926 <= s_3948_4
        fn_state.gs_118926 = s_3948_4;
        // N s_3948_6: jump b3102
        return block_3102(state, tracer, fn_state);
    }
    fn block_3949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3949_0: read-var coproc:u8
        let s_3949_0: u8 = fn_state.coproc;
        // D s_3949_1: cast zx s_3949_0 -> bv
        let s_3949_1: Bits = Bits::new(s_3949_0 as u128, 4u16);
        // C s_3949_2: const #15u : u8
        let s_3949_2: u8 = 15;
        // C s_3949_3: cast zx s_3949_2 -> bv
        let s_3949_3: Bits = Bits::new(s_3949_2 as u128, 4u16);
        // D s_3949_4: cmp-eq s_3949_1 s_3949_3
        let s_3949_4: bool = ((s_3949_1) == (s_3949_3));
        // D s_3949_5: write-var gs#118925 <= s_3949_4
        fn_state.gs_118925 = s_3949_4;
        // N s_3949_6: jump b3100
        return block_3100(state, tracer, fn_state);
    }
    fn block_3950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3950_0: read-var CRn:u8
        let s_3950_0: u8 = fn_state.CRn;
        // D s_3950_1: cast zx s_3950_0 -> bv
        let s_3950_1: Bits = Bits::new(s_3950_0 as u128, 4u16);
        // C s_3950_2: const #12u : u8
        let s_3950_2: u8 = 12;
        // C s_3950_3: cast zx s_3950_2 -> bv
        let s_3950_3: Bits = Bits::new(s_3950_2 as u128, 4u16);
        // D s_3950_4: cmp-eq s_3950_1 s_3950_3
        let s_3950_4: bool = ((s_3950_1) == (s_3950_3));
        // D s_3950_5: write-var gs#118924 <= s_3950_4
        fn_state.gs_118924 = s_3950_4;
        // N s_3950_6: jump b3098
        return block_3098(state, tracer, fn_state);
    }
    fn block_3951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3951_0: read-var el:u8
        let s_3951_0: u8 = fn_state.el;
        // D s_3951_1: read-var coproc:u8
        let s_3951_1: u8 = fn_state.coproc;
        // D s_3951_2: read-var opc1:u8
        let s_3951_2: u8 = fn_state.opc1;
        // D s_3951_3: read-var CRn:u8
        let s_3951_3: u8 = fn_state.CRn;
        // D s_3951_4: read-var opc2:u8
        let s_3951_4: u8 = fn_state.opc2;
        // D s_3951_5: read-var CRm:u8
        let s_3951_5: u8 = fn_state.CRm;
        // D s_3951_6: read-var t:i
        let s_3951_6: i128 = fn_state.t;
        // D s_3951_7: call ICH_LRC_SysRegRead32_5e3a0d745c54eaf7(s_3951_0, s_3951_1, s_3951_2, s_3951_3, s_3951_4, s_3951_5, s_3951_6)
        let s_3951_7: () = ICH_LRC_SysRegRead32_5e3a0d745c54eaf7(
            state,
            tracer,
            s_3951_0,
            s_3951_1,
            s_3951_2,
            s_3951_3,
            s_3951_4,
            s_3951_5,
            s_3951_6,
        );
        // N s_3951_8: return
        return;
    }
    fn block_3952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3952_0: read-var opc2:u8
        let s_3952_0: u8 = fn_state.opc2;
        // D s_3952_1: cast zx s_3952_0 -> bv
        let s_3952_1: Bits = Bits::new(s_3952_0 as u128, 3u16);
        // C s_3952_2: const #7u : u8
        let s_3952_2: u8 = 7;
        // C s_3952_3: cast zx s_3952_2 -> bv
        let s_3952_3: Bits = Bits::new(s_3952_2 as u128, 3u16);
        // D s_3952_4: cmp-eq s_3952_1 s_3952_3
        let s_3952_4: bool = ((s_3952_1) == (s_3952_3));
        // D s_3952_5: write-var gs#118923 <= s_3952_4
        fn_state.gs_118923 = s_3952_4;
        // N s_3952_6: jump b3095
        return block_3095(state, tracer, fn_state);
    }
    fn block_3953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3953_0: read-var opc1:u8
        let s_3953_0: u8 = fn_state.opc1;
        // D s_3953_1: cast zx s_3953_0 -> bv
        let s_3953_1: Bits = Bits::new(s_3953_0 as u128, 3u16);
        // C s_3953_2: const #4u : u8
        let s_3953_2: u8 = 4;
        // C s_3953_3: cast zx s_3953_2 -> bv
        let s_3953_3: Bits = Bits::new(s_3953_2 as u128, 3u16);
        // D s_3953_4: cmp-eq s_3953_1 s_3953_3
        let s_3953_4: bool = ((s_3953_1) == (s_3953_3));
        // D s_3953_5: write-var gs#118922 <= s_3953_4
        fn_state.gs_118922 = s_3953_4;
        // N s_3953_6: jump b3093
        return block_3093(state, tracer, fn_state);
    }
    fn block_3954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3954_0: read-var coproc:u8
        let s_3954_0: u8 = fn_state.coproc;
        // D s_3954_1: cast zx s_3954_0 -> bv
        let s_3954_1: Bits = Bits::new(s_3954_0 as u128, 4u16);
        // C s_3954_2: const #15u : u8
        let s_3954_2: u8 = 15;
        // C s_3954_3: cast zx s_3954_2 -> bv
        let s_3954_3: Bits = Bits::new(s_3954_2 as u128, 4u16);
        // D s_3954_4: cmp-eq s_3954_1 s_3954_3
        let s_3954_4: bool = ((s_3954_1) == (s_3954_3));
        // D s_3954_5: write-var gs#118921 <= s_3954_4
        fn_state.gs_118921 = s_3954_4;
        // N s_3954_6: jump b3091
        return block_3091(state, tracer, fn_state);
    }
    fn block_3955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3955_0: read-var CRn:u8
        let s_3955_0: u8 = fn_state.CRn;
        // D s_3955_1: cast zx s_3955_0 -> bv
        let s_3955_1: Bits = Bits::new(s_3955_0 as u128, 4u16);
        // C s_3955_2: const #12u : u8
        let s_3955_2: u8 = 12;
        // C s_3955_3: cast zx s_3955_2 -> bv
        let s_3955_3: Bits = Bits::new(s_3955_2 as u128, 4u16);
        // D s_3955_4: cmp-eq s_3955_1 s_3955_3
        let s_3955_4: bool = ((s_3955_1) == (s_3955_3));
        // D s_3955_5: write-var gs#118920 <= s_3955_4
        fn_state.gs_118920 = s_3955_4;
        // N s_3955_6: jump b3089
        return block_3089(state, tracer, fn_state);
    }
    fn block_3956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3956_0: read-var el:u8
        let s_3956_0: u8 = fn_state.el;
        // D s_3956_1: read-var coproc:u8
        let s_3956_1: u8 = fn_state.coproc;
        // D s_3956_2: read-var opc1:u8
        let s_3956_2: u8 = fn_state.opc1;
        // D s_3956_3: read-var CRn:u8
        let s_3956_3: u8 = fn_state.CRn;
        // D s_3956_4: read-var opc2:u8
        let s_3956_4: u8 = fn_state.opc2;
        // D s_3956_5: read-var CRm:u8
        let s_3956_5: u8 = fn_state.CRm;
        // D s_3956_6: read-var t:i
        let s_3956_6: i128 = fn_state.t;
        // D s_3956_7: call ICH_LRC_SysRegRead32_ebf1ecd69e0bcfb2(s_3956_0, s_3956_1, s_3956_2, s_3956_3, s_3956_4, s_3956_5, s_3956_6)
        let s_3956_7: () = ICH_LRC_SysRegRead32_ebf1ecd69e0bcfb2(
            state,
            tracer,
            s_3956_0,
            s_3956_1,
            s_3956_2,
            s_3956_3,
            s_3956_4,
            s_3956_5,
            s_3956_6,
        );
        // N s_3956_8: return
        return;
    }
    fn block_3957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3957_0: read-var opc2:u8
        let s_3957_0: u8 = fn_state.opc2;
        // D s_3957_1: cast zx s_3957_0 -> bv
        let s_3957_1: Bits = Bits::new(s_3957_0 as u128, 3u16);
        // C s_3957_2: const #0u : u8
        let s_3957_2: u8 = 0;
        // C s_3957_3: cast zx s_3957_2 -> bv
        let s_3957_3: Bits = Bits::new(s_3957_2 as u128, 3u16);
        // D s_3957_4: cmp-eq s_3957_1 s_3957_3
        let s_3957_4: bool = ((s_3957_1) == (s_3957_3));
        // D s_3957_5: write-var gs#118919 <= s_3957_4
        fn_state.gs_118919 = s_3957_4;
        // N s_3957_6: jump b3086
        return block_3086(state, tracer, fn_state);
    }
    fn block_3958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3958_0: read-var opc1:u8
        let s_3958_0: u8 = fn_state.opc1;
        // D s_3958_1: cast zx s_3958_0 -> bv
        let s_3958_1: Bits = Bits::new(s_3958_0 as u128, 3u16);
        // C s_3958_2: const #4u : u8
        let s_3958_2: u8 = 4;
        // C s_3958_3: cast zx s_3958_2 -> bv
        let s_3958_3: Bits = Bits::new(s_3958_2 as u128, 3u16);
        // D s_3958_4: cmp-eq s_3958_1 s_3958_3
        let s_3958_4: bool = ((s_3958_1) == (s_3958_3));
        // D s_3958_5: write-var gs#118918 <= s_3958_4
        fn_state.gs_118918 = s_3958_4;
        // N s_3958_6: jump b3084
        return block_3084(state, tracer, fn_state);
    }
    fn block_3959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3959_0: read-var coproc:u8
        let s_3959_0: u8 = fn_state.coproc;
        // D s_3959_1: cast zx s_3959_0 -> bv
        let s_3959_1: Bits = Bits::new(s_3959_0 as u128, 4u16);
        // C s_3959_2: const #15u : u8
        let s_3959_2: u8 = 15;
        // C s_3959_3: cast zx s_3959_2 -> bv
        let s_3959_3: Bits = Bits::new(s_3959_2 as u128, 4u16);
        // D s_3959_4: cmp-eq s_3959_1 s_3959_3
        let s_3959_4: bool = ((s_3959_1) == (s_3959_3));
        // D s_3959_5: write-var gs#118917 <= s_3959_4
        fn_state.gs_118917 = s_3959_4;
        // N s_3959_6: jump b3082
        return block_3082(state, tracer, fn_state);
    }
    fn block_3960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3960_0: read-var CRn:u8
        let s_3960_0: u8 = fn_state.CRn;
        // D s_3960_1: cast zx s_3960_0 -> bv
        let s_3960_1: Bits = Bits::new(s_3960_0 as u128, 4u16);
        // C s_3960_2: const #12u : u8
        let s_3960_2: u8 = 12;
        // C s_3960_3: cast zx s_3960_2 -> bv
        let s_3960_3: Bits = Bits::new(s_3960_2 as u128, 4u16);
        // D s_3960_4: cmp-eq s_3960_1 s_3960_3
        let s_3960_4: bool = ((s_3960_1) == (s_3960_3));
        // D s_3960_5: write-var gs#118916 <= s_3960_4
        fn_state.gs_118916 = s_3960_4;
        // N s_3960_6: jump b3080
        return block_3080(state, tracer, fn_state);
    }
    fn block_3961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3961_0: read-var el:u8
        let s_3961_0: u8 = fn_state.el;
        // D s_3961_1: read-var coproc:u8
        let s_3961_1: u8 = fn_state.coproc;
        // D s_3961_2: read-var opc1:u8
        let s_3961_2: u8 = fn_state.opc1;
        // D s_3961_3: read-var CRn:u8
        let s_3961_3: u8 = fn_state.CRn;
        // D s_3961_4: read-var opc2:u8
        let s_3961_4: u8 = fn_state.opc2;
        // D s_3961_5: read-var CRm:u8
        let s_3961_5: u8 = fn_state.CRm;
        // D s_3961_6: read-var t:i
        let s_3961_6: i128 = fn_state.t;
        // D s_3961_7: call ICH_LRC_SysRegRead32_c7c19edd6493b5c7(s_3961_0, s_3961_1, s_3961_2, s_3961_3, s_3961_4, s_3961_5, s_3961_6)
        let s_3961_7: () = ICH_LRC_SysRegRead32_c7c19edd6493b5c7(
            state,
            tracer,
            s_3961_0,
            s_3961_1,
            s_3961_2,
            s_3961_3,
            s_3961_4,
            s_3961_5,
            s_3961_6,
        );
        // N s_3961_8: return
        return;
    }
    fn block_3962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3962_0: read-var opc2:u8
        let s_3962_0: u8 = fn_state.opc2;
        // D s_3962_1: cast zx s_3962_0 -> bv
        let s_3962_1: Bits = Bits::new(s_3962_0 as u128, 3u16);
        // C s_3962_2: const #1u : u8
        let s_3962_2: u8 = 1;
        // C s_3962_3: cast zx s_3962_2 -> bv
        let s_3962_3: Bits = Bits::new(s_3962_2 as u128, 3u16);
        // D s_3962_4: cmp-eq s_3962_1 s_3962_3
        let s_3962_4: bool = ((s_3962_1) == (s_3962_3));
        // D s_3962_5: write-var gs#118915 <= s_3962_4
        fn_state.gs_118915 = s_3962_4;
        // N s_3962_6: jump b3077
        return block_3077(state, tracer, fn_state);
    }
    fn block_3963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3963_0: read-var opc1:u8
        let s_3963_0: u8 = fn_state.opc1;
        // D s_3963_1: cast zx s_3963_0 -> bv
        let s_3963_1: Bits = Bits::new(s_3963_0 as u128, 3u16);
        // C s_3963_2: const #4u : u8
        let s_3963_2: u8 = 4;
        // C s_3963_3: cast zx s_3963_2 -> bv
        let s_3963_3: Bits = Bits::new(s_3963_2 as u128, 3u16);
        // D s_3963_4: cmp-eq s_3963_1 s_3963_3
        let s_3963_4: bool = ((s_3963_1) == (s_3963_3));
        // D s_3963_5: write-var gs#118914 <= s_3963_4
        fn_state.gs_118914 = s_3963_4;
        // N s_3963_6: jump b3075
        return block_3075(state, tracer, fn_state);
    }
    fn block_3964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3964_0: read-var coproc:u8
        let s_3964_0: u8 = fn_state.coproc;
        // D s_3964_1: cast zx s_3964_0 -> bv
        let s_3964_1: Bits = Bits::new(s_3964_0 as u128, 4u16);
        // C s_3964_2: const #15u : u8
        let s_3964_2: u8 = 15;
        // C s_3964_3: cast zx s_3964_2 -> bv
        let s_3964_3: Bits = Bits::new(s_3964_2 as u128, 4u16);
        // D s_3964_4: cmp-eq s_3964_1 s_3964_3
        let s_3964_4: bool = ((s_3964_1) == (s_3964_3));
        // D s_3964_5: write-var gs#118913 <= s_3964_4
        fn_state.gs_118913 = s_3964_4;
        // N s_3964_6: jump b3073
        return block_3073(state, tracer, fn_state);
    }
    fn block_3965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3965_0: read-var CRn:u8
        let s_3965_0: u8 = fn_state.CRn;
        // D s_3965_1: cast zx s_3965_0 -> bv
        let s_3965_1: Bits = Bits::new(s_3965_0 as u128, 4u16);
        // C s_3965_2: const #12u : u8
        let s_3965_2: u8 = 12;
        // C s_3965_3: cast zx s_3965_2 -> bv
        let s_3965_3: Bits = Bits::new(s_3965_2 as u128, 4u16);
        // D s_3965_4: cmp-eq s_3965_1 s_3965_3
        let s_3965_4: bool = ((s_3965_1) == (s_3965_3));
        // D s_3965_5: write-var gs#118912 <= s_3965_4
        fn_state.gs_118912 = s_3965_4;
        // N s_3965_6: jump b3071
        return block_3071(state, tracer, fn_state);
    }
    fn block_3966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3966_0: read-var el:u8
        let s_3966_0: u8 = fn_state.el;
        // D s_3966_1: read-var coproc:u8
        let s_3966_1: u8 = fn_state.coproc;
        // D s_3966_2: read-var opc1:u8
        let s_3966_2: u8 = fn_state.opc1;
        // D s_3966_3: read-var CRn:u8
        let s_3966_3: u8 = fn_state.CRn;
        // D s_3966_4: read-var opc2:u8
        let s_3966_4: u8 = fn_state.opc2;
        // D s_3966_5: read-var CRm:u8
        let s_3966_5: u8 = fn_state.CRm;
        // D s_3966_6: read-var t:i
        let s_3966_6: i128 = fn_state.t;
        // D s_3966_7: call ICH_LRC_SysRegRead32_604585b24b60fdae(s_3966_0, s_3966_1, s_3966_2, s_3966_3, s_3966_4, s_3966_5, s_3966_6)
        let s_3966_7: () = ICH_LRC_SysRegRead32_604585b24b60fdae(
            state,
            tracer,
            s_3966_0,
            s_3966_1,
            s_3966_2,
            s_3966_3,
            s_3966_4,
            s_3966_5,
            s_3966_6,
        );
        // N s_3966_8: return
        return;
    }
    fn block_3967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3967_0: read-var opc2:u8
        let s_3967_0: u8 = fn_state.opc2;
        // D s_3967_1: cast zx s_3967_0 -> bv
        let s_3967_1: Bits = Bits::new(s_3967_0 as u128, 3u16);
        // C s_3967_2: const #2u : u8
        let s_3967_2: u8 = 2;
        // C s_3967_3: cast zx s_3967_2 -> bv
        let s_3967_3: Bits = Bits::new(s_3967_2 as u128, 3u16);
        // D s_3967_4: cmp-eq s_3967_1 s_3967_3
        let s_3967_4: bool = ((s_3967_1) == (s_3967_3));
        // D s_3967_5: write-var gs#118911 <= s_3967_4
        fn_state.gs_118911 = s_3967_4;
        // N s_3967_6: jump b3068
        return block_3068(state, tracer, fn_state);
    }
    fn block_3968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3968_0: read-var opc1:u8
        let s_3968_0: u8 = fn_state.opc1;
        // D s_3968_1: cast zx s_3968_0 -> bv
        let s_3968_1: Bits = Bits::new(s_3968_0 as u128, 3u16);
        // C s_3968_2: const #4u : u8
        let s_3968_2: u8 = 4;
        // C s_3968_3: cast zx s_3968_2 -> bv
        let s_3968_3: Bits = Bits::new(s_3968_2 as u128, 3u16);
        // D s_3968_4: cmp-eq s_3968_1 s_3968_3
        let s_3968_4: bool = ((s_3968_1) == (s_3968_3));
        // D s_3968_5: write-var gs#118910 <= s_3968_4
        fn_state.gs_118910 = s_3968_4;
        // N s_3968_6: jump b3066
        return block_3066(state, tracer, fn_state);
    }
    fn block_3969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3969_0: read-var coproc:u8
        let s_3969_0: u8 = fn_state.coproc;
        // D s_3969_1: cast zx s_3969_0 -> bv
        let s_3969_1: Bits = Bits::new(s_3969_0 as u128, 4u16);
        // C s_3969_2: const #15u : u8
        let s_3969_2: u8 = 15;
        // C s_3969_3: cast zx s_3969_2 -> bv
        let s_3969_3: Bits = Bits::new(s_3969_2 as u128, 4u16);
        // D s_3969_4: cmp-eq s_3969_1 s_3969_3
        let s_3969_4: bool = ((s_3969_1) == (s_3969_3));
        // D s_3969_5: write-var gs#118909 <= s_3969_4
        fn_state.gs_118909 = s_3969_4;
        // N s_3969_6: jump b3064
        return block_3064(state, tracer, fn_state);
    }
    fn block_3970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3970_0: read-var CRn:u8
        let s_3970_0: u8 = fn_state.CRn;
        // D s_3970_1: cast zx s_3970_0 -> bv
        let s_3970_1: Bits = Bits::new(s_3970_0 as u128, 4u16);
        // C s_3970_2: const #12u : u8
        let s_3970_2: u8 = 12;
        // C s_3970_3: cast zx s_3970_2 -> bv
        let s_3970_3: Bits = Bits::new(s_3970_2 as u128, 4u16);
        // D s_3970_4: cmp-eq s_3970_1 s_3970_3
        let s_3970_4: bool = ((s_3970_1) == (s_3970_3));
        // D s_3970_5: write-var gs#118908 <= s_3970_4
        fn_state.gs_118908 = s_3970_4;
        // N s_3970_6: jump b3062
        return block_3062(state, tracer, fn_state);
    }
    fn block_3971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3971_0: read-var el:u8
        let s_3971_0: u8 = fn_state.el;
        // D s_3971_1: read-var coproc:u8
        let s_3971_1: u8 = fn_state.coproc;
        // D s_3971_2: read-var opc1:u8
        let s_3971_2: u8 = fn_state.opc1;
        // D s_3971_3: read-var CRn:u8
        let s_3971_3: u8 = fn_state.CRn;
        // D s_3971_4: read-var opc2:u8
        let s_3971_4: u8 = fn_state.opc2;
        // D s_3971_5: read-var CRm:u8
        let s_3971_5: u8 = fn_state.CRm;
        // D s_3971_6: read-var t:i
        let s_3971_6: i128 = fn_state.t;
        // D s_3971_7: call ICH_LRC_SysRegRead32_9d34a1da3a3d8af6(s_3971_0, s_3971_1, s_3971_2, s_3971_3, s_3971_4, s_3971_5, s_3971_6)
        let s_3971_7: () = ICH_LRC_SysRegRead32_9d34a1da3a3d8af6(
            state,
            tracer,
            s_3971_0,
            s_3971_1,
            s_3971_2,
            s_3971_3,
            s_3971_4,
            s_3971_5,
            s_3971_6,
        );
        // N s_3971_8: return
        return;
    }
    fn block_3972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3972_0: read-var opc2:u8
        let s_3972_0: u8 = fn_state.opc2;
        // D s_3972_1: cast zx s_3972_0 -> bv
        let s_3972_1: Bits = Bits::new(s_3972_0 as u128, 3u16);
        // C s_3972_2: const #3u : u8
        let s_3972_2: u8 = 3;
        // C s_3972_3: cast zx s_3972_2 -> bv
        let s_3972_3: Bits = Bits::new(s_3972_2 as u128, 3u16);
        // D s_3972_4: cmp-eq s_3972_1 s_3972_3
        let s_3972_4: bool = ((s_3972_1) == (s_3972_3));
        // D s_3972_5: write-var gs#118907 <= s_3972_4
        fn_state.gs_118907 = s_3972_4;
        // N s_3972_6: jump b3059
        return block_3059(state, tracer, fn_state);
    }
    fn block_3973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3973_0: read-var opc1:u8
        let s_3973_0: u8 = fn_state.opc1;
        // D s_3973_1: cast zx s_3973_0 -> bv
        let s_3973_1: Bits = Bits::new(s_3973_0 as u128, 3u16);
        // C s_3973_2: const #4u : u8
        let s_3973_2: u8 = 4;
        // C s_3973_3: cast zx s_3973_2 -> bv
        let s_3973_3: Bits = Bits::new(s_3973_2 as u128, 3u16);
        // D s_3973_4: cmp-eq s_3973_1 s_3973_3
        let s_3973_4: bool = ((s_3973_1) == (s_3973_3));
        // D s_3973_5: write-var gs#118906 <= s_3973_4
        fn_state.gs_118906 = s_3973_4;
        // N s_3973_6: jump b3057
        return block_3057(state, tracer, fn_state);
    }
    fn block_3974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3974_0: read-var coproc:u8
        let s_3974_0: u8 = fn_state.coproc;
        // D s_3974_1: cast zx s_3974_0 -> bv
        let s_3974_1: Bits = Bits::new(s_3974_0 as u128, 4u16);
        // C s_3974_2: const #15u : u8
        let s_3974_2: u8 = 15;
        // C s_3974_3: cast zx s_3974_2 -> bv
        let s_3974_3: Bits = Bits::new(s_3974_2 as u128, 4u16);
        // D s_3974_4: cmp-eq s_3974_1 s_3974_3
        let s_3974_4: bool = ((s_3974_1) == (s_3974_3));
        // D s_3974_5: write-var gs#118905 <= s_3974_4
        fn_state.gs_118905 = s_3974_4;
        // N s_3974_6: jump b3055
        return block_3055(state, tracer, fn_state);
    }
    fn block_3975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3975_0: read-var CRn:u8
        let s_3975_0: u8 = fn_state.CRn;
        // D s_3975_1: cast zx s_3975_0 -> bv
        let s_3975_1: Bits = Bits::new(s_3975_0 as u128, 4u16);
        // C s_3975_2: const #12u : u8
        let s_3975_2: u8 = 12;
        // C s_3975_3: cast zx s_3975_2 -> bv
        let s_3975_3: Bits = Bits::new(s_3975_2 as u128, 4u16);
        // D s_3975_4: cmp-eq s_3975_1 s_3975_3
        let s_3975_4: bool = ((s_3975_1) == (s_3975_3));
        // D s_3975_5: write-var gs#118904 <= s_3975_4
        fn_state.gs_118904 = s_3975_4;
        // N s_3975_6: jump b3053
        return block_3053(state, tracer, fn_state);
    }
    fn block_3976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3976_0: read-var el:u8
        let s_3976_0: u8 = fn_state.el;
        // D s_3976_1: read-var coproc:u8
        let s_3976_1: u8 = fn_state.coproc;
        // D s_3976_2: read-var opc1:u8
        let s_3976_2: u8 = fn_state.opc1;
        // D s_3976_3: read-var CRn:u8
        let s_3976_3: u8 = fn_state.CRn;
        // D s_3976_4: read-var opc2:u8
        let s_3976_4: u8 = fn_state.opc2;
        // D s_3976_5: read-var CRm:u8
        let s_3976_5: u8 = fn_state.CRm;
        // D s_3976_6: read-var t:i
        let s_3976_6: i128 = fn_state.t;
        // D s_3976_7: call ICH_LRC_SysRegRead32_ff6694005f1d0b3b(s_3976_0, s_3976_1, s_3976_2, s_3976_3, s_3976_4, s_3976_5, s_3976_6)
        let s_3976_7: () = ICH_LRC_SysRegRead32_ff6694005f1d0b3b(
            state,
            tracer,
            s_3976_0,
            s_3976_1,
            s_3976_2,
            s_3976_3,
            s_3976_4,
            s_3976_5,
            s_3976_6,
        );
        // N s_3976_8: return
        return;
    }
    fn block_3977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3977_0: read-var opc2:u8
        let s_3977_0: u8 = fn_state.opc2;
        // D s_3977_1: cast zx s_3977_0 -> bv
        let s_3977_1: Bits = Bits::new(s_3977_0 as u128, 3u16);
        // C s_3977_2: const #4u : u8
        let s_3977_2: u8 = 4;
        // C s_3977_3: cast zx s_3977_2 -> bv
        let s_3977_3: Bits = Bits::new(s_3977_2 as u128, 3u16);
        // D s_3977_4: cmp-eq s_3977_1 s_3977_3
        let s_3977_4: bool = ((s_3977_1) == (s_3977_3));
        // D s_3977_5: write-var gs#118903 <= s_3977_4
        fn_state.gs_118903 = s_3977_4;
        // N s_3977_6: jump b3050
        return block_3050(state, tracer, fn_state);
    }
    fn block_3978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3978_0: read-var opc1:u8
        let s_3978_0: u8 = fn_state.opc1;
        // D s_3978_1: cast zx s_3978_0 -> bv
        let s_3978_1: Bits = Bits::new(s_3978_0 as u128, 3u16);
        // C s_3978_2: const #4u : u8
        let s_3978_2: u8 = 4;
        // C s_3978_3: cast zx s_3978_2 -> bv
        let s_3978_3: Bits = Bits::new(s_3978_2 as u128, 3u16);
        // D s_3978_4: cmp-eq s_3978_1 s_3978_3
        let s_3978_4: bool = ((s_3978_1) == (s_3978_3));
        // D s_3978_5: write-var gs#118902 <= s_3978_4
        fn_state.gs_118902 = s_3978_4;
        // N s_3978_6: jump b3048
        return block_3048(state, tracer, fn_state);
    }
    fn block_3979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3979_0: read-var coproc:u8
        let s_3979_0: u8 = fn_state.coproc;
        // D s_3979_1: cast zx s_3979_0 -> bv
        let s_3979_1: Bits = Bits::new(s_3979_0 as u128, 4u16);
        // C s_3979_2: const #15u : u8
        let s_3979_2: u8 = 15;
        // C s_3979_3: cast zx s_3979_2 -> bv
        let s_3979_3: Bits = Bits::new(s_3979_2 as u128, 4u16);
        // D s_3979_4: cmp-eq s_3979_1 s_3979_3
        let s_3979_4: bool = ((s_3979_1) == (s_3979_3));
        // D s_3979_5: write-var gs#118901 <= s_3979_4
        fn_state.gs_118901 = s_3979_4;
        // N s_3979_6: jump b3046
        return block_3046(state, tracer, fn_state);
    }
    fn block_3980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3980_0: read-var CRn:u8
        let s_3980_0: u8 = fn_state.CRn;
        // D s_3980_1: cast zx s_3980_0 -> bv
        let s_3980_1: Bits = Bits::new(s_3980_0 as u128, 4u16);
        // C s_3980_2: const #12u : u8
        let s_3980_2: u8 = 12;
        // C s_3980_3: cast zx s_3980_2 -> bv
        let s_3980_3: Bits = Bits::new(s_3980_2 as u128, 4u16);
        // D s_3980_4: cmp-eq s_3980_1 s_3980_3
        let s_3980_4: bool = ((s_3980_1) == (s_3980_3));
        // D s_3980_5: write-var gs#118900 <= s_3980_4
        fn_state.gs_118900 = s_3980_4;
        // N s_3980_6: jump b3044
        return block_3044(state, tracer, fn_state);
    }
    fn block_3981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3981_0: read-var el:u8
        let s_3981_0: u8 = fn_state.el;
        // D s_3981_1: read-var coproc:u8
        let s_3981_1: u8 = fn_state.coproc;
        // D s_3981_2: read-var opc1:u8
        let s_3981_2: u8 = fn_state.opc1;
        // D s_3981_3: read-var CRn:u8
        let s_3981_3: u8 = fn_state.CRn;
        // D s_3981_4: read-var opc2:u8
        let s_3981_4: u8 = fn_state.opc2;
        // D s_3981_5: read-var CRm:u8
        let s_3981_5: u8 = fn_state.CRm;
        // D s_3981_6: read-var t:i
        let s_3981_6: i128 = fn_state.t;
        // D s_3981_7: call ICH_LRC_SysRegRead32_2d5fdc0c0df5489a(s_3981_0, s_3981_1, s_3981_2, s_3981_3, s_3981_4, s_3981_5, s_3981_6)
        let s_3981_7: () = ICH_LRC_SysRegRead32_2d5fdc0c0df5489a(
            state,
            tracer,
            s_3981_0,
            s_3981_1,
            s_3981_2,
            s_3981_3,
            s_3981_4,
            s_3981_5,
            s_3981_6,
        );
        // N s_3981_8: return
        return;
    }
    fn block_3982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3982_0: read-var opc2:u8
        let s_3982_0: u8 = fn_state.opc2;
        // D s_3982_1: cast zx s_3982_0 -> bv
        let s_3982_1: Bits = Bits::new(s_3982_0 as u128, 3u16);
        // C s_3982_2: const #5u : u8
        let s_3982_2: u8 = 5;
        // C s_3982_3: cast zx s_3982_2 -> bv
        let s_3982_3: Bits = Bits::new(s_3982_2 as u128, 3u16);
        // D s_3982_4: cmp-eq s_3982_1 s_3982_3
        let s_3982_4: bool = ((s_3982_1) == (s_3982_3));
        // D s_3982_5: write-var gs#118899 <= s_3982_4
        fn_state.gs_118899 = s_3982_4;
        // N s_3982_6: jump b3041
        return block_3041(state, tracer, fn_state);
    }
    fn block_3983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3983_0: read-var opc1:u8
        let s_3983_0: u8 = fn_state.opc1;
        // D s_3983_1: cast zx s_3983_0 -> bv
        let s_3983_1: Bits = Bits::new(s_3983_0 as u128, 3u16);
        // C s_3983_2: const #4u : u8
        let s_3983_2: u8 = 4;
        // C s_3983_3: cast zx s_3983_2 -> bv
        let s_3983_3: Bits = Bits::new(s_3983_2 as u128, 3u16);
        // D s_3983_4: cmp-eq s_3983_1 s_3983_3
        let s_3983_4: bool = ((s_3983_1) == (s_3983_3));
        // D s_3983_5: write-var gs#118898 <= s_3983_4
        fn_state.gs_118898 = s_3983_4;
        // N s_3983_6: jump b3039
        return block_3039(state, tracer, fn_state);
    }
    fn block_3984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3984_0: read-var coproc:u8
        let s_3984_0: u8 = fn_state.coproc;
        // D s_3984_1: cast zx s_3984_0 -> bv
        let s_3984_1: Bits = Bits::new(s_3984_0 as u128, 4u16);
        // C s_3984_2: const #15u : u8
        let s_3984_2: u8 = 15;
        // C s_3984_3: cast zx s_3984_2 -> bv
        let s_3984_3: Bits = Bits::new(s_3984_2 as u128, 4u16);
        // D s_3984_4: cmp-eq s_3984_1 s_3984_3
        let s_3984_4: bool = ((s_3984_1) == (s_3984_3));
        // D s_3984_5: write-var gs#118897 <= s_3984_4
        fn_state.gs_118897 = s_3984_4;
        // N s_3984_6: jump b3037
        return block_3037(state, tracer, fn_state);
    }
    fn block_3985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3985_0: read-var CRn:u8
        let s_3985_0: u8 = fn_state.CRn;
        // D s_3985_1: cast zx s_3985_0 -> bv
        let s_3985_1: Bits = Bits::new(s_3985_0 as u128, 4u16);
        // C s_3985_2: const #12u : u8
        let s_3985_2: u8 = 12;
        // C s_3985_3: cast zx s_3985_2 -> bv
        let s_3985_3: Bits = Bits::new(s_3985_2 as u128, 4u16);
        // D s_3985_4: cmp-eq s_3985_1 s_3985_3
        let s_3985_4: bool = ((s_3985_1) == (s_3985_3));
        // D s_3985_5: write-var gs#118896 <= s_3985_4
        fn_state.gs_118896 = s_3985_4;
        // N s_3985_6: jump b3035
        return block_3035(state, tracer, fn_state);
    }
    fn block_3986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3986_0: read-var el:u8
        let s_3986_0: u8 = fn_state.el;
        // D s_3986_1: read-var coproc:u8
        let s_3986_1: u8 = fn_state.coproc;
        // D s_3986_2: read-var opc1:u8
        let s_3986_2: u8 = fn_state.opc1;
        // D s_3986_3: read-var CRn:u8
        let s_3986_3: u8 = fn_state.CRn;
        // D s_3986_4: read-var opc2:u8
        let s_3986_4: u8 = fn_state.opc2;
        // D s_3986_5: read-var CRm:u8
        let s_3986_5: u8 = fn_state.CRm;
        // D s_3986_6: read-var t:i
        let s_3986_6: i128 = fn_state.t;
        // D s_3986_7: call ICH_LRC_SysRegRead32_ede8f5720388c87c(s_3986_0, s_3986_1, s_3986_2, s_3986_3, s_3986_4, s_3986_5, s_3986_6)
        let s_3986_7: () = ICH_LRC_SysRegRead32_ede8f5720388c87c(
            state,
            tracer,
            s_3986_0,
            s_3986_1,
            s_3986_2,
            s_3986_3,
            s_3986_4,
            s_3986_5,
            s_3986_6,
        );
        // N s_3986_8: return
        return;
    }
    fn block_3987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3987_0: read-var opc2:u8
        let s_3987_0: u8 = fn_state.opc2;
        // D s_3987_1: cast zx s_3987_0 -> bv
        let s_3987_1: Bits = Bits::new(s_3987_0 as u128, 3u16);
        // C s_3987_2: const #6u : u8
        let s_3987_2: u8 = 6;
        // C s_3987_3: cast zx s_3987_2 -> bv
        let s_3987_3: Bits = Bits::new(s_3987_2 as u128, 3u16);
        // D s_3987_4: cmp-eq s_3987_1 s_3987_3
        let s_3987_4: bool = ((s_3987_1) == (s_3987_3));
        // D s_3987_5: write-var gs#118895 <= s_3987_4
        fn_state.gs_118895 = s_3987_4;
        // N s_3987_6: jump b3032
        return block_3032(state, tracer, fn_state);
    }
    fn block_3988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3988_0: read-var opc1:u8
        let s_3988_0: u8 = fn_state.opc1;
        // D s_3988_1: cast zx s_3988_0 -> bv
        let s_3988_1: Bits = Bits::new(s_3988_0 as u128, 3u16);
        // C s_3988_2: const #4u : u8
        let s_3988_2: u8 = 4;
        // C s_3988_3: cast zx s_3988_2 -> bv
        let s_3988_3: Bits = Bits::new(s_3988_2 as u128, 3u16);
        // D s_3988_4: cmp-eq s_3988_1 s_3988_3
        let s_3988_4: bool = ((s_3988_1) == (s_3988_3));
        // D s_3988_5: write-var gs#118894 <= s_3988_4
        fn_state.gs_118894 = s_3988_4;
        // N s_3988_6: jump b3030
        return block_3030(state, tracer, fn_state);
    }
    fn block_3989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3989_0: read-var coproc:u8
        let s_3989_0: u8 = fn_state.coproc;
        // D s_3989_1: cast zx s_3989_0 -> bv
        let s_3989_1: Bits = Bits::new(s_3989_0 as u128, 4u16);
        // C s_3989_2: const #15u : u8
        let s_3989_2: u8 = 15;
        // C s_3989_3: cast zx s_3989_2 -> bv
        let s_3989_3: Bits = Bits::new(s_3989_2 as u128, 4u16);
        // D s_3989_4: cmp-eq s_3989_1 s_3989_3
        let s_3989_4: bool = ((s_3989_1) == (s_3989_3));
        // D s_3989_5: write-var gs#118893 <= s_3989_4
        fn_state.gs_118893 = s_3989_4;
        // N s_3989_6: jump b3028
        return block_3028(state, tracer, fn_state);
    }
    fn block_3990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3990_0: read-var CRn:u8
        let s_3990_0: u8 = fn_state.CRn;
        // D s_3990_1: cast zx s_3990_0 -> bv
        let s_3990_1: Bits = Bits::new(s_3990_0 as u128, 4u16);
        // C s_3990_2: const #12u : u8
        let s_3990_2: u8 = 12;
        // C s_3990_3: cast zx s_3990_2 -> bv
        let s_3990_3: Bits = Bits::new(s_3990_2 as u128, 4u16);
        // D s_3990_4: cmp-eq s_3990_1 s_3990_3
        let s_3990_4: bool = ((s_3990_1) == (s_3990_3));
        // D s_3990_5: write-var gs#118892 <= s_3990_4
        fn_state.gs_118892 = s_3990_4;
        // N s_3990_6: jump b3026
        return block_3026(state, tracer, fn_state);
    }
    fn block_3991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3991_0: read-var el:u8
        let s_3991_0: u8 = fn_state.el;
        // D s_3991_1: read-var coproc:u8
        let s_3991_1: u8 = fn_state.coproc;
        // D s_3991_2: read-var opc1:u8
        let s_3991_2: u8 = fn_state.opc1;
        // D s_3991_3: read-var CRn:u8
        let s_3991_3: u8 = fn_state.CRn;
        // D s_3991_4: read-var opc2:u8
        let s_3991_4: u8 = fn_state.opc2;
        // D s_3991_5: read-var CRm:u8
        let s_3991_5: u8 = fn_state.CRm;
        // D s_3991_6: read-var t:i
        let s_3991_6: i128 = fn_state.t;
        // D s_3991_7: call ICH_LRC_SysRegRead32_7819c0333582e456(s_3991_0, s_3991_1, s_3991_2, s_3991_3, s_3991_4, s_3991_5, s_3991_6)
        let s_3991_7: () = ICH_LRC_SysRegRead32_7819c0333582e456(
            state,
            tracer,
            s_3991_0,
            s_3991_1,
            s_3991_2,
            s_3991_3,
            s_3991_4,
            s_3991_5,
            s_3991_6,
        );
        // N s_3991_8: return
        return;
    }
    fn block_3992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3992_0: read-var opc2:u8
        let s_3992_0: u8 = fn_state.opc2;
        // D s_3992_1: cast zx s_3992_0 -> bv
        let s_3992_1: Bits = Bits::new(s_3992_0 as u128, 3u16);
        // C s_3992_2: const #7u : u8
        let s_3992_2: u8 = 7;
        // C s_3992_3: cast zx s_3992_2 -> bv
        let s_3992_3: Bits = Bits::new(s_3992_2 as u128, 3u16);
        // D s_3992_4: cmp-eq s_3992_1 s_3992_3
        let s_3992_4: bool = ((s_3992_1) == (s_3992_3));
        // D s_3992_5: write-var gs#118891 <= s_3992_4
        fn_state.gs_118891 = s_3992_4;
        // N s_3992_6: jump b3023
        return block_3023(state, tracer, fn_state);
    }
    fn block_3993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3993_0: read-var opc1:u8
        let s_3993_0: u8 = fn_state.opc1;
        // D s_3993_1: cast zx s_3993_0 -> bv
        let s_3993_1: Bits = Bits::new(s_3993_0 as u128, 3u16);
        // C s_3993_2: const #4u : u8
        let s_3993_2: u8 = 4;
        // C s_3993_3: cast zx s_3993_2 -> bv
        let s_3993_3: Bits = Bits::new(s_3993_2 as u128, 3u16);
        // D s_3993_4: cmp-eq s_3993_1 s_3993_3
        let s_3993_4: bool = ((s_3993_1) == (s_3993_3));
        // D s_3993_5: write-var gs#118890 <= s_3993_4
        fn_state.gs_118890 = s_3993_4;
        // N s_3993_6: jump b3021
        return block_3021(state, tracer, fn_state);
    }
    fn block_3994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3994_0: read-var coproc:u8
        let s_3994_0: u8 = fn_state.coproc;
        // D s_3994_1: cast zx s_3994_0 -> bv
        let s_3994_1: Bits = Bits::new(s_3994_0 as u128, 4u16);
        // C s_3994_2: const #15u : u8
        let s_3994_2: u8 = 15;
        // C s_3994_3: cast zx s_3994_2 -> bv
        let s_3994_3: Bits = Bits::new(s_3994_2 as u128, 4u16);
        // D s_3994_4: cmp-eq s_3994_1 s_3994_3
        let s_3994_4: bool = ((s_3994_1) == (s_3994_3));
        // D s_3994_5: write-var gs#118889 <= s_3994_4
        fn_state.gs_118889 = s_3994_4;
        // N s_3994_6: jump b3019
        return block_3019(state, tracer, fn_state);
    }
    fn block_3995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3995_0: read-var CRn:u8
        let s_3995_0: u8 = fn_state.CRn;
        // D s_3995_1: cast zx s_3995_0 -> bv
        let s_3995_1: Bits = Bits::new(s_3995_0 as u128, 4u16);
        // C s_3995_2: const #12u : u8
        let s_3995_2: u8 = 12;
        // C s_3995_3: cast zx s_3995_2 -> bv
        let s_3995_3: Bits = Bits::new(s_3995_2 as u128, 4u16);
        // D s_3995_4: cmp-eq s_3995_1 s_3995_3
        let s_3995_4: bool = ((s_3995_1) == (s_3995_3));
        // D s_3995_5: write-var gs#118888 <= s_3995_4
        fn_state.gs_118888 = s_3995_4;
        // N s_3995_6: jump b3017
        return block_3017(state, tracer, fn_state);
    }
    fn block_3996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3996_0: read-var el:u8
        let s_3996_0: u8 = fn_state.el;
        // D s_3996_1: read-var coproc:u8
        let s_3996_1: u8 = fn_state.coproc;
        // D s_3996_2: read-var opc1:u8
        let s_3996_2: u8 = fn_state.opc1;
        // D s_3996_3: read-var CRn:u8
        let s_3996_3: u8 = fn_state.CRn;
        // D s_3996_4: read-var opc2:u8
        let s_3996_4: u8 = fn_state.opc2;
        // D s_3996_5: read-var CRm:u8
        let s_3996_5: u8 = fn_state.CRm;
        // D s_3996_6: read-var t:i
        let s_3996_6: i128 = fn_state.t;
        // D s_3996_7: call DBGDEVID2_SysRegRead32_6baefcc664f89312(s_3996_0, s_3996_1, s_3996_2, s_3996_3, s_3996_4, s_3996_5, s_3996_6)
        let s_3996_7: () = DBGDEVID2_SysRegRead32_6baefcc664f89312(
            state,
            tracer,
            s_3996_0,
            s_3996_1,
            s_3996_2,
            s_3996_3,
            s_3996_4,
            s_3996_5,
            s_3996_6,
        );
        // N s_3996_8: return
        return;
    }
    fn block_3997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3997_0: read-var opc2:u8
        let s_3997_0: u8 = fn_state.opc2;
        // D s_3997_1: cast zx s_3997_0 -> bv
        let s_3997_1: Bits = Bits::new(s_3997_0 as u128, 3u16);
        // C s_3997_2: const #7u : u8
        let s_3997_2: u8 = 7;
        // C s_3997_3: cast zx s_3997_2 -> bv
        let s_3997_3: Bits = Bits::new(s_3997_2 as u128, 3u16);
        // D s_3997_4: cmp-eq s_3997_1 s_3997_3
        let s_3997_4: bool = ((s_3997_1) == (s_3997_3));
        // D s_3997_5: write-var gs#118887 <= s_3997_4
        fn_state.gs_118887 = s_3997_4;
        // N s_3997_6: jump b3014
        return block_3014(state, tracer, fn_state);
    }
    fn block_3998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3998_0: read-var opc1:u8
        let s_3998_0: u8 = fn_state.opc1;
        // D s_3998_1: cast zx s_3998_0 -> bv
        let s_3998_1: Bits = Bits::new(s_3998_0 as u128, 3u16);
        // C s_3998_2: const #0u : u8
        let s_3998_2: u8 = 0;
        // C s_3998_3: cast zx s_3998_2 -> bv
        let s_3998_3: Bits = Bits::new(s_3998_2 as u128, 3u16);
        // D s_3998_4: cmp-eq s_3998_1 s_3998_3
        let s_3998_4: bool = ((s_3998_1) == (s_3998_3));
        // D s_3998_5: write-var gs#118886 <= s_3998_4
        fn_state.gs_118886 = s_3998_4;
        // N s_3998_6: jump b3012
        return block_3012(state, tracer, fn_state);
    }
    fn block_3999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_3999_0: read-var coproc:u8
        let s_3999_0: u8 = fn_state.coproc;
        // D s_3999_1: cast zx s_3999_0 -> bv
        let s_3999_1: Bits = Bits::new(s_3999_0 as u128, 4u16);
        // C s_3999_2: const #14u : u8
        let s_3999_2: u8 = 14;
        // C s_3999_3: cast zx s_3999_2 -> bv
        let s_3999_3: Bits = Bits::new(s_3999_2 as u128, 4u16);
        // D s_3999_4: cmp-eq s_3999_1 s_3999_3
        let s_3999_4: bool = ((s_3999_1) == (s_3999_3));
        // D s_3999_5: write-var gs#118885 <= s_3999_4
        fn_state.gs_118885 = s_3999_4;
        // N s_3999_6: jump b3010
        return block_3010(state, tracer, fn_state);
    }
    fn block_4000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4000_0: read-var CRn:u8
        let s_4000_0: u8 = fn_state.CRn;
        // D s_4000_1: cast zx s_4000_0 -> bv
        let s_4000_1: Bits = Bits::new(s_4000_0 as u128, 4u16);
        // C s_4000_2: const #7u : u8
        let s_4000_2: u8 = 7;
        // C s_4000_3: cast zx s_4000_2 -> bv
        let s_4000_3: Bits = Bits::new(s_4000_2 as u128, 4u16);
        // D s_4000_4: cmp-eq s_4000_1 s_4000_3
        let s_4000_4: bool = ((s_4000_1) == (s_4000_3));
        // D s_4000_5: write-var gs#118884 <= s_4000_4
        fn_state.gs_118884 = s_4000_4;
        // N s_4000_6: jump b3008
        return block_3008(state, tracer, fn_state);
    }
    fn block_4001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4001_0: read-var el:u8
        let s_4001_0: u8 = fn_state.el;
        // D s_4001_1: read-var coproc:u8
        let s_4001_1: u8 = fn_state.coproc;
        // D s_4001_2: read-var opc1:u8
        let s_4001_2: u8 = fn_state.opc1;
        // D s_4001_3: read-var CRn:u8
        let s_4001_3: u8 = fn_state.CRn;
        // D s_4001_4: read-var opc2:u8
        let s_4001_4: u8 = fn_state.opc2;
        // D s_4001_5: read-var CRm:u8
        let s_4001_5: u8 = fn_state.CRm;
        // D s_4001_6: read-var t:i
        let s_4001_6: i128 = fn_state.t;
        // D s_4001_7: call CCSIDR_SysRegRead32_4e417948cc9050d5(s_4001_0, s_4001_1, s_4001_2, s_4001_3, s_4001_4, s_4001_5, s_4001_6)
        let s_4001_7: () = CCSIDR_SysRegRead32_4e417948cc9050d5(
            state,
            tracer,
            s_4001_0,
            s_4001_1,
            s_4001_2,
            s_4001_3,
            s_4001_4,
            s_4001_5,
            s_4001_6,
        );
        // N s_4001_8: return
        return;
    }
    fn block_4002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4002_0: read-var opc2:u8
        let s_4002_0: u8 = fn_state.opc2;
        // D s_4002_1: cast zx s_4002_0 -> bv
        let s_4002_1: Bits = Bits::new(s_4002_0 as u128, 3u16);
        // C s_4002_2: const #0u : u8
        let s_4002_2: u8 = 0;
        // C s_4002_3: cast zx s_4002_2 -> bv
        let s_4002_3: Bits = Bits::new(s_4002_2 as u128, 3u16);
        // D s_4002_4: cmp-eq s_4002_1 s_4002_3
        let s_4002_4: bool = ((s_4002_1) == (s_4002_3));
        // D s_4002_5: write-var gs#118883 <= s_4002_4
        fn_state.gs_118883 = s_4002_4;
        // N s_4002_6: jump b3005
        return block_3005(state, tracer, fn_state);
    }
    fn block_4003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4003_0: read-var opc1:u8
        let s_4003_0: u8 = fn_state.opc1;
        // D s_4003_1: cast zx s_4003_0 -> bv
        let s_4003_1: Bits = Bits::new(s_4003_0 as u128, 3u16);
        // C s_4003_2: const #1u : u8
        let s_4003_2: u8 = 1;
        // C s_4003_3: cast zx s_4003_2 -> bv
        let s_4003_3: Bits = Bits::new(s_4003_2 as u128, 3u16);
        // D s_4003_4: cmp-eq s_4003_1 s_4003_3
        let s_4003_4: bool = ((s_4003_1) == (s_4003_3));
        // D s_4003_5: write-var gs#118882 <= s_4003_4
        fn_state.gs_118882 = s_4003_4;
        // N s_4003_6: jump b3003
        return block_3003(state, tracer, fn_state);
    }
    fn block_4004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4004_0: read-var coproc:u8
        let s_4004_0: u8 = fn_state.coproc;
        // D s_4004_1: cast zx s_4004_0 -> bv
        let s_4004_1: Bits = Bits::new(s_4004_0 as u128, 4u16);
        // C s_4004_2: const #15u : u8
        let s_4004_2: u8 = 15;
        // C s_4004_3: cast zx s_4004_2 -> bv
        let s_4004_3: Bits = Bits::new(s_4004_2 as u128, 4u16);
        // D s_4004_4: cmp-eq s_4004_1 s_4004_3
        let s_4004_4: bool = ((s_4004_1) == (s_4004_3));
        // D s_4004_5: write-var gs#118881 <= s_4004_4
        fn_state.gs_118881 = s_4004_4;
        // N s_4004_6: jump b3001
        return block_3001(state, tracer, fn_state);
    }
    fn block_4005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4005_0: read-var CRn:u8
        let s_4005_0: u8 = fn_state.CRn;
        // D s_4005_1: cast zx s_4005_0 -> bv
        let s_4005_1: Bits = Bits::new(s_4005_0 as u128, 4u16);
        // C s_4005_2: const #0u : u8
        let s_4005_2: u8 = 0;
        // C s_4005_3: cast zx s_4005_2 -> bv
        let s_4005_3: Bits = Bits::new(s_4005_2 as u128, 4u16);
        // D s_4005_4: cmp-eq s_4005_1 s_4005_3
        let s_4005_4: bool = ((s_4005_1) == (s_4005_3));
        // D s_4005_5: write-var gs#118880 <= s_4005_4
        fn_state.gs_118880 = s_4005_4;
        // N s_4005_6: jump b2999
        return block_2999(state, tracer, fn_state);
    }
    fn block_4006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4006_0: read-var el:u8
        let s_4006_0: u8 = fn_state.el;
        // D s_4006_1: read-var coproc:u8
        let s_4006_1: u8 = fn_state.coproc;
        // D s_4006_2: read-var opc1:u8
        let s_4006_2: u8 = fn_state.opc1;
        // D s_4006_3: read-var CRn:u8
        let s_4006_3: u8 = fn_state.CRn;
        // D s_4006_4: read-var opc2:u8
        let s_4006_4: u8 = fn_state.opc2;
        // D s_4006_5: read-var CRm:u8
        let s_4006_5: u8 = fn_state.CRm;
        // D s_4006_6: read-var t:i
        let s_4006_6: i128 = fn_state.t;
        // D s_4006_7: call AMAIR1_SysRegRead32_abbf588378c53393(s_4006_0, s_4006_1, s_4006_2, s_4006_3, s_4006_4, s_4006_5, s_4006_6)
        let s_4006_7: () = AMAIR1_SysRegRead32_abbf588378c53393(
            state,
            tracer,
            s_4006_0,
            s_4006_1,
            s_4006_2,
            s_4006_3,
            s_4006_4,
            s_4006_5,
            s_4006_6,
        );
        // N s_4006_8: return
        return;
    }
    fn block_4007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4007_0: read-var opc2:u8
        let s_4007_0: u8 = fn_state.opc2;
        // D s_4007_1: cast zx s_4007_0 -> bv
        let s_4007_1: Bits = Bits::new(s_4007_0 as u128, 3u16);
        // C s_4007_2: const #1u : u8
        let s_4007_2: u8 = 1;
        // C s_4007_3: cast zx s_4007_2 -> bv
        let s_4007_3: Bits = Bits::new(s_4007_2 as u128, 3u16);
        // D s_4007_4: cmp-eq s_4007_1 s_4007_3
        let s_4007_4: bool = ((s_4007_1) == (s_4007_3));
        // D s_4007_5: write-var gs#118879 <= s_4007_4
        fn_state.gs_118879 = s_4007_4;
        // N s_4007_6: jump b2996
        return block_2996(state, tracer, fn_state);
    }
    fn block_4008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4008_0: read-var opc1:u8
        let s_4008_0: u8 = fn_state.opc1;
        // D s_4008_1: cast zx s_4008_0 -> bv
        let s_4008_1: Bits = Bits::new(s_4008_0 as u128, 3u16);
        // C s_4008_2: const #0u : u8
        let s_4008_2: u8 = 0;
        // C s_4008_3: cast zx s_4008_2 -> bv
        let s_4008_3: Bits = Bits::new(s_4008_2 as u128, 3u16);
        // D s_4008_4: cmp-eq s_4008_1 s_4008_3
        let s_4008_4: bool = ((s_4008_1) == (s_4008_3));
        // D s_4008_5: write-var gs#118878 <= s_4008_4
        fn_state.gs_118878 = s_4008_4;
        // N s_4008_6: jump b2994
        return block_2994(state, tracer, fn_state);
    }
    fn block_4009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4009_0: read-var coproc:u8
        let s_4009_0: u8 = fn_state.coproc;
        // D s_4009_1: cast zx s_4009_0 -> bv
        let s_4009_1: Bits = Bits::new(s_4009_0 as u128, 4u16);
        // C s_4009_2: const #15u : u8
        let s_4009_2: u8 = 15;
        // C s_4009_3: cast zx s_4009_2 -> bv
        let s_4009_3: Bits = Bits::new(s_4009_2 as u128, 4u16);
        // D s_4009_4: cmp-eq s_4009_1 s_4009_3
        let s_4009_4: bool = ((s_4009_1) == (s_4009_3));
        // D s_4009_5: write-var gs#118877 <= s_4009_4
        fn_state.gs_118877 = s_4009_4;
        // N s_4009_6: jump b2992
        return block_2992(state, tracer, fn_state);
    }
    fn block_4010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4010_0: read-var CRn:u8
        let s_4010_0: u8 = fn_state.CRn;
        // D s_4010_1: cast zx s_4010_0 -> bv
        let s_4010_1: Bits = Bits::new(s_4010_0 as u128, 4u16);
        // C s_4010_2: const #10u : u8
        let s_4010_2: u8 = 10;
        // C s_4010_3: cast zx s_4010_2 -> bv
        let s_4010_3: Bits = Bits::new(s_4010_2 as u128, 4u16);
        // D s_4010_4: cmp-eq s_4010_1 s_4010_3
        let s_4010_4: bool = ((s_4010_1) == (s_4010_3));
        // D s_4010_5: write-var gs#118876 <= s_4010_4
        fn_state.gs_118876 = s_4010_4;
        // N s_4010_6: jump b2990
        return block_2990(state, tracer, fn_state);
    }
    fn block_4011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4011_0: read-var el:u8
        let s_4011_0: u8 = fn_state.el;
        // D s_4011_1: read-var coproc:u8
        let s_4011_1: u8 = fn_state.coproc;
        // D s_4011_2: read-var opc1:u8
        let s_4011_2: u8 = fn_state.opc1;
        // D s_4011_3: read-var CRn:u8
        let s_4011_3: u8 = fn_state.CRn;
        // D s_4011_4: read-var opc2:u8
        let s_4011_4: u8 = fn_state.opc2;
        // D s_4011_5: read-var CRm:u8
        let s_4011_5: u8 = fn_state.CRm;
        // D s_4011_6: read-var t:i
        let s_4011_6: i128 = fn_state.t;
        // D s_4011_7: call CNTHP_CTL_SysRegRead32_5ea09b260a579171(s_4011_0, s_4011_1, s_4011_2, s_4011_3, s_4011_4, s_4011_5, s_4011_6)
        let s_4011_7: () = CNTHP_CTL_SysRegRead32_5ea09b260a579171(
            state,
            tracer,
            s_4011_0,
            s_4011_1,
            s_4011_2,
            s_4011_3,
            s_4011_4,
            s_4011_5,
            s_4011_6,
        );
        // N s_4011_8: return
        return;
    }
    fn block_4012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4012_0: read-var opc2:u8
        let s_4012_0: u8 = fn_state.opc2;
        // D s_4012_1: cast zx s_4012_0 -> bv
        let s_4012_1: Bits = Bits::new(s_4012_0 as u128, 3u16);
        // C s_4012_2: const #1u : u8
        let s_4012_2: u8 = 1;
        // C s_4012_3: cast zx s_4012_2 -> bv
        let s_4012_3: Bits = Bits::new(s_4012_2 as u128, 3u16);
        // D s_4012_4: cmp-eq s_4012_1 s_4012_3
        let s_4012_4: bool = ((s_4012_1) == (s_4012_3));
        // D s_4012_5: write-var gs#118875 <= s_4012_4
        fn_state.gs_118875 = s_4012_4;
        // N s_4012_6: jump b2987
        return block_2987(state, tracer, fn_state);
    }
    fn block_4013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4013_0: read-var opc1:u8
        let s_4013_0: u8 = fn_state.opc1;
        // D s_4013_1: cast zx s_4013_0 -> bv
        let s_4013_1: Bits = Bits::new(s_4013_0 as u128, 3u16);
        // C s_4013_2: const #4u : u8
        let s_4013_2: u8 = 4;
        // C s_4013_3: cast zx s_4013_2 -> bv
        let s_4013_3: Bits = Bits::new(s_4013_2 as u128, 3u16);
        // D s_4013_4: cmp-eq s_4013_1 s_4013_3
        let s_4013_4: bool = ((s_4013_1) == (s_4013_3));
        // D s_4013_5: write-var gs#118874 <= s_4013_4
        fn_state.gs_118874 = s_4013_4;
        // N s_4013_6: jump b2985
        return block_2985(state, tracer, fn_state);
    }
    fn block_4014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4014_0: read-var coproc:u8
        let s_4014_0: u8 = fn_state.coproc;
        // D s_4014_1: cast zx s_4014_0 -> bv
        let s_4014_1: Bits = Bits::new(s_4014_0 as u128, 4u16);
        // C s_4014_2: const #15u : u8
        let s_4014_2: u8 = 15;
        // C s_4014_3: cast zx s_4014_2 -> bv
        let s_4014_3: Bits = Bits::new(s_4014_2 as u128, 4u16);
        // D s_4014_4: cmp-eq s_4014_1 s_4014_3
        let s_4014_4: bool = ((s_4014_1) == (s_4014_3));
        // D s_4014_5: write-var gs#118873 <= s_4014_4
        fn_state.gs_118873 = s_4014_4;
        // N s_4014_6: jump b2983
        return block_2983(state, tracer, fn_state);
    }
    fn block_4015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4015_0: read-var CRn:u8
        let s_4015_0: u8 = fn_state.CRn;
        // D s_4015_1: cast zx s_4015_0 -> bv
        let s_4015_1: Bits = Bits::new(s_4015_0 as u128, 4u16);
        // C s_4015_2: const #14u : u8
        let s_4015_2: u8 = 14;
        // C s_4015_3: cast zx s_4015_2 -> bv
        let s_4015_3: Bits = Bits::new(s_4015_2 as u128, 4u16);
        // D s_4015_4: cmp-eq s_4015_1 s_4015_3
        let s_4015_4: bool = ((s_4015_1) == (s_4015_3));
        // D s_4015_5: write-var gs#118872 <= s_4015_4
        fn_state.gs_118872 = s_4015_4;
        // N s_4015_6: jump b2981
        return block_2981(state, tracer, fn_state);
    }
    fn block_4016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4016_0: read-var el:u8
        let s_4016_0: u8 = fn_state.el;
        // D s_4016_1: read-var coproc:u8
        let s_4016_1: u8 = fn_state.coproc;
        // D s_4016_2: read-var opc1:u8
        let s_4016_2: u8 = fn_state.opc1;
        // D s_4016_3: read-var CRn:u8
        let s_4016_3: u8 = fn_state.CRn;
        // D s_4016_4: read-var opc2:u8
        let s_4016_4: u8 = fn_state.opc2;
        // D s_4016_5: read-var CRm:u8
        let s_4016_5: u8 = fn_state.CRm;
        // D s_4016_6: read-var t:i
        let s_4016_6: i128 = fn_state.t;
        // D s_4016_7: call TRFCR_SysRegRead32_4539d9acce538415(s_4016_0, s_4016_1, s_4016_2, s_4016_3, s_4016_4, s_4016_5, s_4016_6)
        let s_4016_7: () = TRFCR_SysRegRead32_4539d9acce538415(
            state,
            tracer,
            s_4016_0,
            s_4016_1,
            s_4016_2,
            s_4016_3,
            s_4016_4,
            s_4016_5,
            s_4016_6,
        );
        // N s_4016_8: return
        return;
    }
    fn block_4017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4017_0: read-var opc2:u8
        let s_4017_0: u8 = fn_state.opc2;
        // D s_4017_1: cast zx s_4017_0 -> bv
        let s_4017_1: Bits = Bits::new(s_4017_0 as u128, 3u16);
        // C s_4017_2: const #1u : u8
        let s_4017_2: u8 = 1;
        // C s_4017_3: cast zx s_4017_2 -> bv
        let s_4017_3: Bits = Bits::new(s_4017_2 as u128, 3u16);
        // D s_4017_4: cmp-eq s_4017_1 s_4017_3
        let s_4017_4: bool = ((s_4017_1) == (s_4017_3));
        // D s_4017_5: write-var gs#118871 <= s_4017_4
        fn_state.gs_118871 = s_4017_4;
        // N s_4017_6: jump b2978
        return block_2978(state, tracer, fn_state);
    }
    fn block_4018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4018_0: read-var opc1:u8
        let s_4018_0: u8 = fn_state.opc1;
        // D s_4018_1: cast zx s_4018_0 -> bv
        let s_4018_1: Bits = Bits::new(s_4018_0 as u128, 3u16);
        // C s_4018_2: const #0u : u8
        let s_4018_2: u8 = 0;
        // C s_4018_3: cast zx s_4018_2 -> bv
        let s_4018_3: Bits = Bits::new(s_4018_2 as u128, 3u16);
        // D s_4018_4: cmp-eq s_4018_1 s_4018_3
        let s_4018_4: bool = ((s_4018_1) == (s_4018_3));
        // D s_4018_5: write-var gs#118870 <= s_4018_4
        fn_state.gs_118870 = s_4018_4;
        // N s_4018_6: jump b2976
        return block_2976(state, tracer, fn_state);
    }
    fn block_4019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4019_0: read-var coproc:u8
        let s_4019_0: u8 = fn_state.coproc;
        // D s_4019_1: cast zx s_4019_0 -> bv
        let s_4019_1: Bits = Bits::new(s_4019_0 as u128, 4u16);
        // C s_4019_2: const #15u : u8
        let s_4019_2: u8 = 15;
        // C s_4019_3: cast zx s_4019_2 -> bv
        let s_4019_3: Bits = Bits::new(s_4019_2 as u128, 4u16);
        // D s_4019_4: cmp-eq s_4019_1 s_4019_3
        let s_4019_4: bool = ((s_4019_1) == (s_4019_3));
        // D s_4019_5: write-var gs#118869 <= s_4019_4
        fn_state.gs_118869 = s_4019_4;
        // N s_4019_6: jump b2974
        return block_2974(state, tracer, fn_state);
    }
    fn block_4020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4020_0: read-var CRn:u8
        let s_4020_0: u8 = fn_state.CRn;
        // D s_4020_1: cast zx s_4020_0 -> bv
        let s_4020_1: Bits = Bits::new(s_4020_0 as u128, 4u16);
        // C s_4020_2: const #1u : u8
        let s_4020_2: u8 = 1;
        // C s_4020_3: cast zx s_4020_2 -> bv
        let s_4020_3: Bits = Bits::new(s_4020_2 as u128, 4u16);
        // D s_4020_4: cmp-eq s_4020_1 s_4020_3
        let s_4020_4: bool = ((s_4020_1) == (s_4020_3));
        // D s_4020_5: write-var gs#118868 <= s_4020_4
        fn_state.gs_118868 = s_4020_4;
        // N s_4020_6: jump b2972
        return block_2972(state, tracer, fn_state);
    }
    fn block_4021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4021_0: read-var el:u8
        let s_4021_0: u8 = fn_state.el;
        // D s_4021_1: read-var coproc:u8
        let s_4021_1: u8 = fn_state.coproc;
        // D s_4021_2: read-var opc1:u8
        let s_4021_2: u8 = fn_state.opc1;
        // D s_4021_3: read-var CRn:u8
        let s_4021_3: u8 = fn_state.CRn;
        // D s_4021_4: read-var opc2:u8
        let s_4021_4: u8 = fn_state.opc2;
        // D s_4021_5: read-var CRm:u8
        let s_4021_5: u8 = fn_state.CRm;
        // D s_4021_6: read-var t:i
        let s_4021_6: i128 = fn_state.t;
        // D s_4021_7: call DBGOSLSR_SysRegRead32_7c8a1f5e56c0fe64(s_4021_0, s_4021_1, s_4021_2, s_4021_3, s_4021_4, s_4021_5, s_4021_6)
        let s_4021_7: () = DBGOSLSR_SysRegRead32_7c8a1f5e56c0fe64(
            state,
            tracer,
            s_4021_0,
            s_4021_1,
            s_4021_2,
            s_4021_3,
            s_4021_4,
            s_4021_5,
            s_4021_6,
        );
        // N s_4021_8: return
        return;
    }
    fn block_4022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4022_0: read-var opc2:u8
        let s_4022_0: u8 = fn_state.opc2;
        // D s_4022_1: cast zx s_4022_0 -> bv
        let s_4022_1: Bits = Bits::new(s_4022_0 as u128, 3u16);
        // C s_4022_2: const #4u : u8
        let s_4022_2: u8 = 4;
        // C s_4022_3: cast zx s_4022_2 -> bv
        let s_4022_3: Bits = Bits::new(s_4022_2 as u128, 3u16);
        // D s_4022_4: cmp-eq s_4022_1 s_4022_3
        let s_4022_4: bool = ((s_4022_1) == (s_4022_3));
        // D s_4022_5: write-var gs#118867 <= s_4022_4
        fn_state.gs_118867 = s_4022_4;
        // N s_4022_6: jump b2969
        return block_2969(state, tracer, fn_state);
    }
    fn block_4023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4023_0: read-var opc1:u8
        let s_4023_0: u8 = fn_state.opc1;
        // D s_4023_1: cast zx s_4023_0 -> bv
        let s_4023_1: Bits = Bits::new(s_4023_0 as u128, 3u16);
        // C s_4023_2: const #0u : u8
        let s_4023_2: u8 = 0;
        // C s_4023_3: cast zx s_4023_2 -> bv
        let s_4023_3: Bits = Bits::new(s_4023_2 as u128, 3u16);
        // D s_4023_4: cmp-eq s_4023_1 s_4023_3
        let s_4023_4: bool = ((s_4023_1) == (s_4023_3));
        // D s_4023_5: write-var gs#118866 <= s_4023_4
        fn_state.gs_118866 = s_4023_4;
        // N s_4023_6: jump b2967
        return block_2967(state, tracer, fn_state);
    }
    fn block_4024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4024_0: read-var coproc:u8
        let s_4024_0: u8 = fn_state.coproc;
        // D s_4024_1: cast zx s_4024_0 -> bv
        let s_4024_1: Bits = Bits::new(s_4024_0 as u128, 4u16);
        // C s_4024_2: const #14u : u8
        let s_4024_2: u8 = 14;
        // C s_4024_3: cast zx s_4024_2 -> bv
        let s_4024_3: Bits = Bits::new(s_4024_2 as u128, 4u16);
        // D s_4024_4: cmp-eq s_4024_1 s_4024_3
        let s_4024_4: bool = ((s_4024_1) == (s_4024_3));
        // D s_4024_5: write-var gs#118865 <= s_4024_4
        fn_state.gs_118865 = s_4024_4;
        // N s_4024_6: jump b2965
        return block_2965(state, tracer, fn_state);
    }
    fn block_4025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4025_0: read-var CRn:u8
        let s_4025_0: u8 = fn_state.CRn;
        // D s_4025_1: cast zx s_4025_0 -> bv
        let s_4025_1: Bits = Bits::new(s_4025_0 as u128, 4u16);
        // C s_4025_2: const #1u : u8
        let s_4025_2: u8 = 1;
        // C s_4025_3: cast zx s_4025_2 -> bv
        let s_4025_3: Bits = Bits::new(s_4025_2 as u128, 4u16);
        // D s_4025_4: cmp-eq s_4025_1 s_4025_3
        let s_4025_4: bool = ((s_4025_1) == (s_4025_3));
        // D s_4025_5: write-var gs#118864 <= s_4025_4
        fn_state.gs_118864 = s_4025_4;
        // N s_4025_6: jump b2963
        return block_2963(state, tracer, fn_state);
    }
    fn block_4026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4026_0: read-var el:u8
        let s_4026_0: u8 = fn_state.el;
        // D s_4026_1: read-var coproc:u8
        let s_4026_1: u8 = fn_state.coproc;
        // D s_4026_2: read-var opc1:u8
        let s_4026_2: u8 = fn_state.opc1;
        // D s_4026_3: read-var CRn:u8
        let s_4026_3: u8 = fn_state.CRn;
        // D s_4026_4: read-var opc2:u8
        let s_4026_4: u8 = fn_state.opc2;
        // D s_4026_5: read-var CRm:u8
        let s_4026_5: u8 = fn_state.CRm;
        // D s_4026_6: read-var t:i
        let s_4026_6: i128 = fn_state.t;
        // D s_4026_7: call ID_ISAR2_SysRegRead32_24153ecb491475a1(s_4026_0, s_4026_1, s_4026_2, s_4026_3, s_4026_4, s_4026_5, s_4026_6)
        let s_4026_7: () = ID_ISAR2_SysRegRead32_24153ecb491475a1(
            state,
            tracer,
            s_4026_0,
            s_4026_1,
            s_4026_2,
            s_4026_3,
            s_4026_4,
            s_4026_5,
            s_4026_6,
        );
        // N s_4026_8: return
        return;
    }
    fn block_4027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4027_0: read-var opc2:u8
        let s_4027_0: u8 = fn_state.opc2;
        // D s_4027_1: cast zx s_4027_0 -> bv
        let s_4027_1: Bits = Bits::new(s_4027_0 as u128, 3u16);
        // C s_4027_2: const #2u : u8
        let s_4027_2: u8 = 2;
        // C s_4027_3: cast zx s_4027_2 -> bv
        let s_4027_3: Bits = Bits::new(s_4027_2 as u128, 3u16);
        // D s_4027_4: cmp-eq s_4027_1 s_4027_3
        let s_4027_4: bool = ((s_4027_1) == (s_4027_3));
        // D s_4027_5: write-var gs#118863 <= s_4027_4
        fn_state.gs_118863 = s_4027_4;
        // N s_4027_6: jump b2960
        return block_2960(state, tracer, fn_state);
    }
    fn block_4028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4028_0: read-var opc1:u8
        let s_4028_0: u8 = fn_state.opc1;
        // D s_4028_1: cast zx s_4028_0 -> bv
        let s_4028_1: Bits = Bits::new(s_4028_0 as u128, 3u16);
        // C s_4028_2: const #0u : u8
        let s_4028_2: u8 = 0;
        // C s_4028_3: cast zx s_4028_2 -> bv
        let s_4028_3: Bits = Bits::new(s_4028_2 as u128, 3u16);
        // D s_4028_4: cmp-eq s_4028_1 s_4028_3
        let s_4028_4: bool = ((s_4028_1) == (s_4028_3));
        // D s_4028_5: write-var gs#118862 <= s_4028_4
        fn_state.gs_118862 = s_4028_4;
        // N s_4028_6: jump b2958
        return block_2958(state, tracer, fn_state);
    }
    fn block_4029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4029_0: read-var coproc:u8
        let s_4029_0: u8 = fn_state.coproc;
        // D s_4029_1: cast zx s_4029_0 -> bv
        let s_4029_1: Bits = Bits::new(s_4029_0 as u128, 4u16);
        // C s_4029_2: const #15u : u8
        let s_4029_2: u8 = 15;
        // C s_4029_3: cast zx s_4029_2 -> bv
        let s_4029_3: Bits = Bits::new(s_4029_2 as u128, 4u16);
        // D s_4029_4: cmp-eq s_4029_1 s_4029_3
        let s_4029_4: bool = ((s_4029_1) == (s_4029_3));
        // D s_4029_5: write-var gs#118861 <= s_4029_4
        fn_state.gs_118861 = s_4029_4;
        // N s_4029_6: jump b2956
        return block_2956(state, tracer, fn_state);
    }
    fn block_4030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4030_0: read-var CRn:u8
        let s_4030_0: u8 = fn_state.CRn;
        // D s_4030_1: cast zx s_4030_0 -> bv
        let s_4030_1: Bits = Bits::new(s_4030_0 as u128, 4u16);
        // C s_4030_2: const #0u : u8
        let s_4030_2: u8 = 0;
        // C s_4030_3: cast zx s_4030_2 -> bv
        let s_4030_3: Bits = Bits::new(s_4030_2 as u128, 4u16);
        // D s_4030_4: cmp-eq s_4030_1 s_4030_3
        let s_4030_4: bool = ((s_4030_1) == (s_4030_3));
        // D s_4030_5: write-var gs#118860 <= s_4030_4
        fn_state.gs_118860 = s_4030_4;
        // N s_4030_6: jump b2954
        return block_2954(state, tracer, fn_state);
    }
    fn block_4031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4031_0: read-var el:u8
        let s_4031_0: u8 = fn_state.el;
        // D s_4031_1: read-var coproc:u8
        let s_4031_1: u8 = fn_state.coproc;
        // D s_4031_2: read-var opc1:u8
        let s_4031_2: u8 = fn_state.opc1;
        // D s_4031_3: read-var CRn:u8
        let s_4031_3: u8 = fn_state.CRn;
        // D s_4031_4: read-var opc2:u8
        let s_4031_4: u8 = fn_state.opc2;
        // D s_4031_5: read-var CRm:u8
        let s_4031_5: u8 = fn_state.CRm;
        // D s_4031_6: read-var t:i
        let s_4031_6: i128 = fn_state.t;
        // D s_4031_7: call PMCNTENCLR_SysRegRead32_fae3650c5f5d677d(s_4031_0, s_4031_1, s_4031_2, s_4031_3, s_4031_4, s_4031_5, s_4031_6)
        let s_4031_7: () = PMCNTENCLR_SysRegRead32_fae3650c5f5d677d(
            state,
            tracer,
            s_4031_0,
            s_4031_1,
            s_4031_2,
            s_4031_3,
            s_4031_4,
            s_4031_5,
            s_4031_6,
        );
        // N s_4031_8: return
        return;
    }
    fn block_4032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4032_0: read-var opc2:u8
        let s_4032_0: u8 = fn_state.opc2;
        // D s_4032_1: cast zx s_4032_0 -> bv
        let s_4032_1: Bits = Bits::new(s_4032_0 as u128, 3u16);
        // C s_4032_2: const #2u : u8
        let s_4032_2: u8 = 2;
        // C s_4032_3: cast zx s_4032_2 -> bv
        let s_4032_3: Bits = Bits::new(s_4032_2 as u128, 3u16);
        // D s_4032_4: cmp-eq s_4032_1 s_4032_3
        let s_4032_4: bool = ((s_4032_1) == (s_4032_3));
        // D s_4032_5: write-var gs#118859 <= s_4032_4
        fn_state.gs_118859 = s_4032_4;
        // N s_4032_6: jump b2951
        return block_2951(state, tracer, fn_state);
    }
    fn block_4033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4033_0: read-var opc1:u8
        let s_4033_0: u8 = fn_state.opc1;
        // D s_4033_1: cast zx s_4033_0 -> bv
        let s_4033_1: Bits = Bits::new(s_4033_0 as u128, 3u16);
        // C s_4033_2: const #0u : u8
        let s_4033_2: u8 = 0;
        // C s_4033_3: cast zx s_4033_2 -> bv
        let s_4033_3: Bits = Bits::new(s_4033_2 as u128, 3u16);
        // D s_4033_4: cmp-eq s_4033_1 s_4033_3
        let s_4033_4: bool = ((s_4033_1) == (s_4033_3));
        // D s_4033_5: write-var gs#118858 <= s_4033_4
        fn_state.gs_118858 = s_4033_4;
        // N s_4033_6: jump b2949
        return block_2949(state, tracer, fn_state);
    }
    fn block_4034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4034_0: read-var coproc:u8
        let s_4034_0: u8 = fn_state.coproc;
        // D s_4034_1: cast zx s_4034_0 -> bv
        let s_4034_1: Bits = Bits::new(s_4034_0 as u128, 4u16);
        // C s_4034_2: const #15u : u8
        let s_4034_2: u8 = 15;
        // C s_4034_3: cast zx s_4034_2 -> bv
        let s_4034_3: Bits = Bits::new(s_4034_2 as u128, 4u16);
        // D s_4034_4: cmp-eq s_4034_1 s_4034_3
        let s_4034_4: bool = ((s_4034_1) == (s_4034_3));
        // D s_4034_5: write-var gs#118857 <= s_4034_4
        fn_state.gs_118857 = s_4034_4;
        // N s_4034_6: jump b2947
        return block_2947(state, tracer, fn_state);
    }
    fn block_4035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4035_0: read-var CRn:u8
        let s_4035_0: u8 = fn_state.CRn;
        // D s_4035_1: cast zx s_4035_0 -> bv
        let s_4035_1: Bits = Bits::new(s_4035_0 as u128, 4u16);
        // C s_4035_2: const #9u : u8
        let s_4035_2: u8 = 9;
        // C s_4035_3: cast zx s_4035_2 -> bv
        let s_4035_3: Bits = Bits::new(s_4035_2 as u128, 4u16);
        // D s_4035_4: cmp-eq s_4035_1 s_4035_3
        let s_4035_4: bool = ((s_4035_1) == (s_4035_3));
        // D s_4035_5: write-var gs#118856 <= s_4035_4
        fn_state.gs_118856 = s_4035_4;
        // N s_4035_6: jump b2945
        return block_2945(state, tracer, fn_state);
    }
    fn block_4036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4036_0: read-var el:u8
        let s_4036_0: u8 = fn_state.el;
        // D s_4036_1: read-var coproc:u8
        let s_4036_1: u8 = fn_state.coproc;
        // D s_4036_2: read-var opc1:u8
        let s_4036_2: u8 = fn_state.opc1;
        // D s_4036_3: read-var CRn:u8
        let s_4036_3: u8 = fn_state.CRn;
        // D s_4036_4: read-var opc2:u8
        let s_4036_4: u8 = fn_state.opc2;
        // D s_4036_5: read-var CRm:u8
        let s_4036_5: u8 = fn_state.CRm;
        // D s_4036_6: read-var t:i
        let s_4036_6: i128 = fn_state.t;
        // D s_4036_7: call DFAR_SysRegRead32_24eaaed98bd8c8b9(s_4036_0, s_4036_1, s_4036_2, s_4036_3, s_4036_4, s_4036_5, s_4036_6)
        let s_4036_7: () = DFAR_SysRegRead32_24eaaed98bd8c8b9(
            state,
            tracer,
            s_4036_0,
            s_4036_1,
            s_4036_2,
            s_4036_3,
            s_4036_4,
            s_4036_5,
            s_4036_6,
        );
        // N s_4036_8: return
        return;
    }
    fn block_4037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4037_0: read-var opc2:u8
        let s_4037_0: u8 = fn_state.opc2;
        // D s_4037_1: cast zx s_4037_0 -> bv
        let s_4037_1: Bits = Bits::new(s_4037_0 as u128, 3u16);
        // C s_4037_2: const #0u : u8
        let s_4037_2: u8 = 0;
        // C s_4037_3: cast zx s_4037_2 -> bv
        let s_4037_3: Bits = Bits::new(s_4037_2 as u128, 3u16);
        // D s_4037_4: cmp-eq s_4037_1 s_4037_3
        let s_4037_4: bool = ((s_4037_1) == (s_4037_3));
        // D s_4037_5: write-var gs#118855 <= s_4037_4
        fn_state.gs_118855 = s_4037_4;
        // N s_4037_6: jump b2942
        return block_2942(state, tracer, fn_state);
    }
    fn block_4038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4038_0: read-var opc1:u8
        let s_4038_0: u8 = fn_state.opc1;
        // D s_4038_1: cast zx s_4038_0 -> bv
        let s_4038_1: Bits = Bits::new(s_4038_0 as u128, 3u16);
        // C s_4038_2: const #0u : u8
        let s_4038_2: u8 = 0;
        // C s_4038_3: cast zx s_4038_2 -> bv
        let s_4038_3: Bits = Bits::new(s_4038_2 as u128, 3u16);
        // D s_4038_4: cmp-eq s_4038_1 s_4038_3
        let s_4038_4: bool = ((s_4038_1) == (s_4038_3));
        // D s_4038_5: write-var gs#118854 <= s_4038_4
        fn_state.gs_118854 = s_4038_4;
        // N s_4038_6: jump b2940
        return block_2940(state, tracer, fn_state);
    }
    fn block_4039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4039_0: read-var coproc:u8
        let s_4039_0: u8 = fn_state.coproc;
        // D s_4039_1: cast zx s_4039_0 -> bv
        let s_4039_1: Bits = Bits::new(s_4039_0 as u128, 4u16);
        // C s_4039_2: const #15u : u8
        let s_4039_2: u8 = 15;
        // C s_4039_3: cast zx s_4039_2 -> bv
        let s_4039_3: Bits = Bits::new(s_4039_2 as u128, 4u16);
        // D s_4039_4: cmp-eq s_4039_1 s_4039_3
        let s_4039_4: bool = ((s_4039_1) == (s_4039_3));
        // D s_4039_5: write-var gs#118853 <= s_4039_4
        fn_state.gs_118853 = s_4039_4;
        // N s_4039_6: jump b2938
        return block_2938(state, tracer, fn_state);
    }
    fn block_4040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4040_0: read-var CRn:u8
        let s_4040_0: u8 = fn_state.CRn;
        // D s_4040_1: cast zx s_4040_0 -> bv
        let s_4040_1: Bits = Bits::new(s_4040_0 as u128, 4u16);
        // C s_4040_2: const #6u : u8
        let s_4040_2: u8 = 6;
        // C s_4040_3: cast zx s_4040_2 -> bv
        let s_4040_3: Bits = Bits::new(s_4040_2 as u128, 4u16);
        // D s_4040_4: cmp-eq s_4040_1 s_4040_3
        let s_4040_4: bool = ((s_4040_1) == (s_4040_3));
        // D s_4040_5: write-var gs#118852 <= s_4040_4
        fn_state.gs_118852 = s_4040_4;
        // N s_4040_6: jump b2936
        return block_2936(state, tracer, fn_state);
    }
    fn block_4041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4041_0: read-var el:u8
        let s_4041_0: u8 = fn_state.el;
        // D s_4041_1: read-var coproc:u8
        let s_4041_1: u8 = fn_state.coproc;
        // D s_4041_2: read-var opc1:u8
        let s_4041_2: u8 = fn_state.opc1;
        // D s_4041_3: read-var CRn:u8
        let s_4041_3: u8 = fn_state.CRn;
        // D s_4041_4: read-var opc2:u8
        let s_4041_4: u8 = fn_state.opc2;
        // D s_4041_5: read-var CRm:u8
        let s_4041_5: u8 = fn_state.CRm;
        // D s_4041_6: read-var t:i
        let s_4041_6: i128 = fn_state.t;
        // D s_4041_7: call CONTEXTIDR_SysRegRead32_a8d33c511e223d46(s_4041_0, s_4041_1, s_4041_2, s_4041_3, s_4041_4, s_4041_5, s_4041_6)
        let s_4041_7: () = CONTEXTIDR_SysRegRead32_a8d33c511e223d46(
            state,
            tracer,
            s_4041_0,
            s_4041_1,
            s_4041_2,
            s_4041_3,
            s_4041_4,
            s_4041_5,
            s_4041_6,
        );
        // N s_4041_8: return
        return;
    }
    fn block_4042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4042_0: read-var opc2:u8
        let s_4042_0: u8 = fn_state.opc2;
        // D s_4042_1: cast zx s_4042_0 -> bv
        let s_4042_1: Bits = Bits::new(s_4042_0 as u128, 3u16);
        // C s_4042_2: const #1u : u8
        let s_4042_2: u8 = 1;
        // C s_4042_3: cast zx s_4042_2 -> bv
        let s_4042_3: Bits = Bits::new(s_4042_2 as u128, 3u16);
        // D s_4042_4: cmp-eq s_4042_1 s_4042_3
        let s_4042_4: bool = ((s_4042_1) == (s_4042_3));
        // D s_4042_5: write-var gs#118851 <= s_4042_4
        fn_state.gs_118851 = s_4042_4;
        // N s_4042_6: jump b2933
        return block_2933(state, tracer, fn_state);
    }
    fn block_4043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4043_0: read-var opc1:u8
        let s_4043_0: u8 = fn_state.opc1;
        // D s_4043_1: cast zx s_4043_0 -> bv
        let s_4043_1: Bits = Bits::new(s_4043_0 as u128, 3u16);
        // C s_4043_2: const #0u : u8
        let s_4043_2: u8 = 0;
        // C s_4043_3: cast zx s_4043_2 -> bv
        let s_4043_3: Bits = Bits::new(s_4043_2 as u128, 3u16);
        // D s_4043_4: cmp-eq s_4043_1 s_4043_3
        let s_4043_4: bool = ((s_4043_1) == (s_4043_3));
        // D s_4043_5: write-var gs#118850 <= s_4043_4
        fn_state.gs_118850 = s_4043_4;
        // N s_4043_6: jump b2931
        return block_2931(state, tracer, fn_state);
    }
    fn block_4044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4044_0: read-var coproc:u8
        let s_4044_0: u8 = fn_state.coproc;
        // D s_4044_1: cast zx s_4044_0 -> bv
        let s_4044_1: Bits = Bits::new(s_4044_0 as u128, 4u16);
        // C s_4044_2: const #15u : u8
        let s_4044_2: u8 = 15;
        // C s_4044_3: cast zx s_4044_2 -> bv
        let s_4044_3: Bits = Bits::new(s_4044_2 as u128, 4u16);
        // D s_4044_4: cmp-eq s_4044_1 s_4044_3
        let s_4044_4: bool = ((s_4044_1) == (s_4044_3));
        // D s_4044_5: write-var gs#118849 <= s_4044_4
        fn_state.gs_118849 = s_4044_4;
        // N s_4044_6: jump b2929
        return block_2929(state, tracer, fn_state);
    }
    fn block_4045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4045_0: read-var CRn:u8
        let s_4045_0: u8 = fn_state.CRn;
        // D s_4045_1: cast zx s_4045_0 -> bv
        let s_4045_1: Bits = Bits::new(s_4045_0 as u128, 4u16);
        // C s_4045_2: const #13u : u8
        let s_4045_2: u8 = 13;
        // C s_4045_3: cast zx s_4045_2 -> bv
        let s_4045_3: Bits = Bits::new(s_4045_2 as u128, 4u16);
        // D s_4045_4: cmp-eq s_4045_1 s_4045_3
        let s_4045_4: bool = ((s_4045_1) == (s_4045_3));
        // D s_4045_5: write-var gs#118848 <= s_4045_4
        fn_state.gs_118848 = s_4045_4;
        // N s_4045_6: jump b2927
        return block_2927(state, tracer, fn_state);
    }
    fn block_4046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4046_0: read-var el:u8
        let s_4046_0: u8 = fn_state.el;
        // D s_4046_1: read-var coproc:u8
        let s_4046_1: u8 = fn_state.coproc;
        // D s_4046_2: read-var opc1:u8
        let s_4046_2: u8 = fn_state.opc1;
        // D s_4046_3: read-var CRn:u8
        let s_4046_3: u8 = fn_state.CRn;
        // D s_4046_4: read-var opc2:u8
        let s_4046_4: u8 = fn_state.opc2;
        // D s_4046_5: read-var CRm:u8
        let s_4046_5: u8 = fn_state.CRm;
        // D s_4046_6: read-var t:i
        let s_4046_6: i128 = fn_state.t;
        // D s_4046_7: call HTPIDR_SysRegRead32_882efba325cc7f8f(s_4046_0, s_4046_1, s_4046_2, s_4046_3, s_4046_4, s_4046_5, s_4046_6)
        let s_4046_7: () = HTPIDR_SysRegRead32_882efba325cc7f8f(
            state,
            tracer,
            s_4046_0,
            s_4046_1,
            s_4046_2,
            s_4046_3,
            s_4046_4,
            s_4046_5,
            s_4046_6,
        );
        // N s_4046_8: return
        return;
    }
    fn block_4047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4047_0: read-var opc2:u8
        let s_4047_0: u8 = fn_state.opc2;
        // D s_4047_1: cast zx s_4047_0 -> bv
        let s_4047_1: Bits = Bits::new(s_4047_0 as u128, 3u16);
        // C s_4047_2: const #2u : u8
        let s_4047_2: u8 = 2;
        // C s_4047_3: cast zx s_4047_2 -> bv
        let s_4047_3: Bits = Bits::new(s_4047_2 as u128, 3u16);
        // D s_4047_4: cmp-eq s_4047_1 s_4047_3
        let s_4047_4: bool = ((s_4047_1) == (s_4047_3));
        // D s_4047_5: write-var gs#118847 <= s_4047_4
        fn_state.gs_118847 = s_4047_4;
        // N s_4047_6: jump b2924
        return block_2924(state, tracer, fn_state);
    }
    fn block_4048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4048_0: read-var opc1:u8
        let s_4048_0: u8 = fn_state.opc1;
        // D s_4048_1: cast zx s_4048_0 -> bv
        let s_4048_1: Bits = Bits::new(s_4048_0 as u128, 3u16);
        // C s_4048_2: const #4u : u8
        let s_4048_2: u8 = 4;
        // C s_4048_3: cast zx s_4048_2 -> bv
        let s_4048_3: Bits = Bits::new(s_4048_2 as u128, 3u16);
        // D s_4048_4: cmp-eq s_4048_1 s_4048_3
        let s_4048_4: bool = ((s_4048_1) == (s_4048_3));
        // D s_4048_5: write-var gs#118846 <= s_4048_4
        fn_state.gs_118846 = s_4048_4;
        // N s_4048_6: jump b2922
        return block_2922(state, tracer, fn_state);
    }
    fn block_4049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4049_0: read-var coproc:u8
        let s_4049_0: u8 = fn_state.coproc;
        // D s_4049_1: cast zx s_4049_0 -> bv
        let s_4049_1: Bits = Bits::new(s_4049_0 as u128, 4u16);
        // C s_4049_2: const #15u : u8
        let s_4049_2: u8 = 15;
        // C s_4049_3: cast zx s_4049_2 -> bv
        let s_4049_3: Bits = Bits::new(s_4049_2 as u128, 4u16);
        // D s_4049_4: cmp-eq s_4049_1 s_4049_3
        let s_4049_4: bool = ((s_4049_1) == (s_4049_3));
        // D s_4049_5: write-var gs#118845 <= s_4049_4
        fn_state.gs_118845 = s_4049_4;
        // N s_4049_6: jump b2920
        return block_2920(state, tracer, fn_state);
    }
    fn block_4050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4050_0: read-var CRn:u8
        let s_4050_0: u8 = fn_state.CRn;
        // D s_4050_1: cast zx s_4050_0 -> bv
        let s_4050_1: Bits = Bits::new(s_4050_0 as u128, 4u16);
        // C s_4050_2: const #13u : u8
        let s_4050_2: u8 = 13;
        // C s_4050_3: cast zx s_4050_2 -> bv
        let s_4050_3: Bits = Bits::new(s_4050_2 as u128, 4u16);
        // D s_4050_4: cmp-eq s_4050_1 s_4050_3
        let s_4050_4: bool = ((s_4050_1) == (s_4050_3));
        // D s_4050_5: write-var gs#118844 <= s_4050_4
        fn_state.gs_118844 = s_4050_4;
        // N s_4050_6: jump b2918
        return block_2918(state, tracer, fn_state);
    }
    fn block_4051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4051_0: read-var el:u8
        let s_4051_0: u8 = fn_state.el;
        // D s_4051_1: read-var coproc:u8
        let s_4051_1: u8 = fn_state.coproc;
        // D s_4051_2: read-var opc1:u8
        let s_4051_2: u8 = fn_state.opc1;
        // D s_4051_3: read-var CRn:u8
        let s_4051_3: u8 = fn_state.CRn;
        // D s_4051_4: read-var opc2:u8
        let s_4051_4: u8 = fn_state.opc2;
        // D s_4051_5: read-var CRm:u8
        let s_4051_5: u8 = fn_state.CRm;
        // D s_4051_6: read-var t:i
        let s_4051_6: i128 = fn_state.t;
        // D s_4051_7: call PMEVTYPER_SysRegRead32_d18be2a53d09e4e3(s_4051_0, s_4051_1, s_4051_2, s_4051_3, s_4051_4, s_4051_5, s_4051_6)
        let s_4051_7: () = PMEVTYPER_SysRegRead32_d18be2a53d09e4e3(
            state,
            tracer,
            s_4051_0,
            s_4051_1,
            s_4051_2,
            s_4051_3,
            s_4051_4,
            s_4051_5,
            s_4051_6,
        );
        // N s_4051_8: return
        return;
    }
    fn block_4052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4052_0: read-var opc2:u8
        let s_4052_0: u8 = fn_state.opc2;
        // D s_4052_1: cast zx s_4052_0 -> bv
        let s_4052_1: Bits = Bits::new(s_4052_0 as u128, 3u16);
        // C s_4052_2: const #0u : u8
        let s_4052_2: u8 = 0;
        // C s_4052_3: cast zx s_4052_2 -> bv
        let s_4052_3: Bits = Bits::new(s_4052_2 as u128, 3u16);
        // D s_4052_4: cmp-eq s_4052_1 s_4052_3
        let s_4052_4: bool = ((s_4052_1) == (s_4052_3));
        // D s_4052_5: write-var gs#118843 <= s_4052_4
        fn_state.gs_118843 = s_4052_4;
        // N s_4052_6: jump b2915
        return block_2915(state, tracer, fn_state);
    }
    fn block_4053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4053_0: read-var opc1:u8
        let s_4053_0: u8 = fn_state.opc1;
        // D s_4053_1: cast zx s_4053_0 -> bv
        let s_4053_1: Bits = Bits::new(s_4053_0 as u128, 3u16);
        // C s_4053_2: const #0u : u8
        let s_4053_2: u8 = 0;
        // C s_4053_3: cast zx s_4053_2 -> bv
        let s_4053_3: Bits = Bits::new(s_4053_2 as u128, 3u16);
        // D s_4053_4: cmp-eq s_4053_1 s_4053_3
        let s_4053_4: bool = ((s_4053_1) == (s_4053_3));
        // D s_4053_5: write-var gs#118842 <= s_4053_4
        fn_state.gs_118842 = s_4053_4;
        // N s_4053_6: jump b2913
        return block_2913(state, tracer, fn_state);
    }
    fn block_4054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4054_0: read-var coproc:u8
        let s_4054_0: u8 = fn_state.coproc;
        // D s_4054_1: cast zx s_4054_0 -> bv
        let s_4054_1: Bits = Bits::new(s_4054_0 as u128, 4u16);
        // C s_4054_2: const #15u : u8
        let s_4054_2: u8 = 15;
        // C s_4054_3: cast zx s_4054_2 -> bv
        let s_4054_3: Bits = Bits::new(s_4054_2 as u128, 4u16);
        // D s_4054_4: cmp-eq s_4054_1 s_4054_3
        let s_4054_4: bool = ((s_4054_1) == (s_4054_3));
        // D s_4054_5: write-var gs#118841 <= s_4054_4
        fn_state.gs_118841 = s_4054_4;
        // N s_4054_6: jump b2911
        return block_2911(state, tracer, fn_state);
    }
    fn block_4055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4055_0: read-var CRn:u8
        let s_4055_0: u8 = fn_state.CRn;
        // D s_4055_1: cast zx s_4055_0 -> bv
        let s_4055_1: Bits = Bits::new(s_4055_0 as u128, 4u16);
        // C s_4055_2: const #14u : u8
        let s_4055_2: u8 = 14;
        // C s_4055_3: cast zx s_4055_2 -> bv
        let s_4055_3: Bits = Bits::new(s_4055_2 as u128, 4u16);
        // D s_4055_4: cmp-eq s_4055_1 s_4055_3
        let s_4055_4: bool = ((s_4055_1) == (s_4055_3));
        // D s_4055_5: write-var gs#118840 <= s_4055_4
        fn_state.gs_118840 = s_4055_4;
        // N s_4055_6: jump b2909
        return block_2909(state, tracer, fn_state);
    }
    fn block_4056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4056_0: read-var el:u8
        let s_4056_0: u8 = fn_state.el;
        // D s_4056_1: read-var coproc:u8
        let s_4056_1: u8 = fn_state.coproc;
        // D s_4056_2: read-var opc1:u8
        let s_4056_2: u8 = fn_state.opc1;
        // D s_4056_3: read-var CRn:u8
        let s_4056_3: u8 = fn_state.CRn;
        // D s_4056_4: read-var opc2:u8
        let s_4056_4: u8 = fn_state.opc2;
        // D s_4056_5: read-var CRm:u8
        let s_4056_5: u8 = fn_state.CRm;
        // D s_4056_6: read-var t:i
        let s_4056_6: i128 = fn_state.t;
        // D s_4056_7: call PMEVTYPER_SysRegRead32_b14a395988483b96(s_4056_0, s_4056_1, s_4056_2, s_4056_3, s_4056_4, s_4056_5, s_4056_6)
        let s_4056_7: () = PMEVTYPER_SysRegRead32_b14a395988483b96(
            state,
            tracer,
            s_4056_0,
            s_4056_1,
            s_4056_2,
            s_4056_3,
            s_4056_4,
            s_4056_5,
            s_4056_6,
        );
        // N s_4056_8: return
        return;
    }
    fn block_4057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4057_0: read-var opc2:u8
        let s_4057_0: u8 = fn_state.opc2;
        // D s_4057_1: cast zx s_4057_0 -> bv
        let s_4057_1: Bits = Bits::new(s_4057_0 as u128, 3u16);
        // C s_4057_2: const #1u : u8
        let s_4057_2: u8 = 1;
        // C s_4057_3: cast zx s_4057_2 -> bv
        let s_4057_3: Bits = Bits::new(s_4057_2 as u128, 3u16);
        // D s_4057_4: cmp-eq s_4057_1 s_4057_3
        let s_4057_4: bool = ((s_4057_1) == (s_4057_3));
        // D s_4057_5: write-var gs#118839 <= s_4057_4
        fn_state.gs_118839 = s_4057_4;
        // N s_4057_6: jump b2906
        return block_2906(state, tracer, fn_state);
    }
    fn block_4058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4058_0: read-var opc1:u8
        let s_4058_0: u8 = fn_state.opc1;
        // D s_4058_1: cast zx s_4058_0 -> bv
        let s_4058_1: Bits = Bits::new(s_4058_0 as u128, 3u16);
        // C s_4058_2: const #0u : u8
        let s_4058_2: u8 = 0;
        // C s_4058_3: cast zx s_4058_2 -> bv
        let s_4058_3: Bits = Bits::new(s_4058_2 as u128, 3u16);
        // D s_4058_4: cmp-eq s_4058_1 s_4058_3
        let s_4058_4: bool = ((s_4058_1) == (s_4058_3));
        // D s_4058_5: write-var gs#118838 <= s_4058_4
        fn_state.gs_118838 = s_4058_4;
        // N s_4058_6: jump b2904
        return block_2904(state, tracer, fn_state);
    }
    fn block_4059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4059_0: read-var coproc:u8
        let s_4059_0: u8 = fn_state.coproc;
        // D s_4059_1: cast zx s_4059_0 -> bv
        let s_4059_1: Bits = Bits::new(s_4059_0 as u128, 4u16);
        // C s_4059_2: const #15u : u8
        let s_4059_2: u8 = 15;
        // C s_4059_3: cast zx s_4059_2 -> bv
        let s_4059_3: Bits = Bits::new(s_4059_2 as u128, 4u16);
        // D s_4059_4: cmp-eq s_4059_1 s_4059_3
        let s_4059_4: bool = ((s_4059_1) == (s_4059_3));
        // D s_4059_5: write-var gs#118837 <= s_4059_4
        fn_state.gs_118837 = s_4059_4;
        // N s_4059_6: jump b2902
        return block_2902(state, tracer, fn_state);
    }
    fn block_4060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4060_0: read-var CRn:u8
        let s_4060_0: u8 = fn_state.CRn;
        // D s_4060_1: cast zx s_4060_0 -> bv
        let s_4060_1: Bits = Bits::new(s_4060_0 as u128, 4u16);
        // C s_4060_2: const #14u : u8
        let s_4060_2: u8 = 14;
        // C s_4060_3: cast zx s_4060_2 -> bv
        let s_4060_3: Bits = Bits::new(s_4060_2 as u128, 4u16);
        // D s_4060_4: cmp-eq s_4060_1 s_4060_3
        let s_4060_4: bool = ((s_4060_1) == (s_4060_3));
        // D s_4060_5: write-var gs#118836 <= s_4060_4
        fn_state.gs_118836 = s_4060_4;
        // N s_4060_6: jump b2900
        return block_2900(state, tracer, fn_state);
    }
    fn block_4061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4061_0: read-var el:u8
        let s_4061_0: u8 = fn_state.el;
        // D s_4061_1: read-var coproc:u8
        let s_4061_1: u8 = fn_state.coproc;
        // D s_4061_2: read-var opc1:u8
        let s_4061_2: u8 = fn_state.opc1;
        // D s_4061_3: read-var CRn:u8
        let s_4061_3: u8 = fn_state.CRn;
        // D s_4061_4: read-var opc2:u8
        let s_4061_4: u8 = fn_state.opc2;
        // D s_4061_5: read-var CRm:u8
        let s_4061_5: u8 = fn_state.CRm;
        // D s_4061_6: read-var t:i
        let s_4061_6: i128 = fn_state.t;
        // D s_4061_7: call PMEVTYPER_SysRegRead32_a724b3fb2f78856f(s_4061_0, s_4061_1, s_4061_2, s_4061_3, s_4061_4, s_4061_5, s_4061_6)
        let s_4061_7: () = PMEVTYPER_SysRegRead32_a724b3fb2f78856f(
            state,
            tracer,
            s_4061_0,
            s_4061_1,
            s_4061_2,
            s_4061_3,
            s_4061_4,
            s_4061_5,
            s_4061_6,
        );
        // N s_4061_8: return
        return;
    }
    fn block_4062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4062_0: read-var opc2:u8
        let s_4062_0: u8 = fn_state.opc2;
        // D s_4062_1: cast zx s_4062_0 -> bv
        let s_4062_1: Bits = Bits::new(s_4062_0 as u128, 3u16);
        // C s_4062_2: const #2u : u8
        let s_4062_2: u8 = 2;
        // C s_4062_3: cast zx s_4062_2 -> bv
        let s_4062_3: Bits = Bits::new(s_4062_2 as u128, 3u16);
        // D s_4062_4: cmp-eq s_4062_1 s_4062_3
        let s_4062_4: bool = ((s_4062_1) == (s_4062_3));
        // D s_4062_5: write-var gs#118835 <= s_4062_4
        fn_state.gs_118835 = s_4062_4;
        // N s_4062_6: jump b2897
        return block_2897(state, tracer, fn_state);
    }
    fn block_4063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4063_0: read-var opc1:u8
        let s_4063_0: u8 = fn_state.opc1;
        // D s_4063_1: cast zx s_4063_0 -> bv
        let s_4063_1: Bits = Bits::new(s_4063_0 as u128, 3u16);
        // C s_4063_2: const #0u : u8
        let s_4063_2: u8 = 0;
        // C s_4063_3: cast zx s_4063_2 -> bv
        let s_4063_3: Bits = Bits::new(s_4063_2 as u128, 3u16);
        // D s_4063_4: cmp-eq s_4063_1 s_4063_3
        let s_4063_4: bool = ((s_4063_1) == (s_4063_3));
        // D s_4063_5: write-var gs#118834 <= s_4063_4
        fn_state.gs_118834 = s_4063_4;
        // N s_4063_6: jump b2895
        return block_2895(state, tracer, fn_state);
    }
    fn block_4064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4064_0: read-var coproc:u8
        let s_4064_0: u8 = fn_state.coproc;
        // D s_4064_1: cast zx s_4064_0 -> bv
        let s_4064_1: Bits = Bits::new(s_4064_0 as u128, 4u16);
        // C s_4064_2: const #15u : u8
        let s_4064_2: u8 = 15;
        // C s_4064_3: cast zx s_4064_2 -> bv
        let s_4064_3: Bits = Bits::new(s_4064_2 as u128, 4u16);
        // D s_4064_4: cmp-eq s_4064_1 s_4064_3
        let s_4064_4: bool = ((s_4064_1) == (s_4064_3));
        // D s_4064_5: write-var gs#118833 <= s_4064_4
        fn_state.gs_118833 = s_4064_4;
        // N s_4064_6: jump b2893
        return block_2893(state, tracer, fn_state);
    }
    fn block_4065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4065_0: read-var CRn:u8
        let s_4065_0: u8 = fn_state.CRn;
        // D s_4065_1: cast zx s_4065_0 -> bv
        let s_4065_1: Bits = Bits::new(s_4065_0 as u128, 4u16);
        // C s_4065_2: const #14u : u8
        let s_4065_2: u8 = 14;
        // C s_4065_3: cast zx s_4065_2 -> bv
        let s_4065_3: Bits = Bits::new(s_4065_2 as u128, 4u16);
        // D s_4065_4: cmp-eq s_4065_1 s_4065_3
        let s_4065_4: bool = ((s_4065_1) == (s_4065_3));
        // D s_4065_5: write-var gs#118832 <= s_4065_4
        fn_state.gs_118832 = s_4065_4;
        // N s_4065_6: jump b2891
        return block_2891(state, tracer, fn_state);
    }
    fn block_4066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4066_0: read-var el:u8
        let s_4066_0: u8 = fn_state.el;
        // D s_4066_1: read-var coproc:u8
        let s_4066_1: u8 = fn_state.coproc;
        // D s_4066_2: read-var opc1:u8
        let s_4066_2: u8 = fn_state.opc1;
        // D s_4066_3: read-var CRn:u8
        let s_4066_3: u8 = fn_state.CRn;
        // D s_4066_4: read-var opc2:u8
        let s_4066_4: u8 = fn_state.opc2;
        // D s_4066_5: read-var CRm:u8
        let s_4066_5: u8 = fn_state.CRm;
        // D s_4066_6: read-var t:i
        let s_4066_6: i128 = fn_state.t;
        // D s_4066_7: call PMEVTYPER_SysRegRead32_3dc043fab8866695(s_4066_0, s_4066_1, s_4066_2, s_4066_3, s_4066_4, s_4066_5, s_4066_6)
        let s_4066_7: () = PMEVTYPER_SysRegRead32_3dc043fab8866695(
            state,
            tracer,
            s_4066_0,
            s_4066_1,
            s_4066_2,
            s_4066_3,
            s_4066_4,
            s_4066_5,
            s_4066_6,
        );
        // N s_4066_8: return
        return;
    }
    fn block_4067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4067_0: read-var opc2:u8
        let s_4067_0: u8 = fn_state.opc2;
        // D s_4067_1: cast zx s_4067_0 -> bv
        let s_4067_1: Bits = Bits::new(s_4067_0 as u128, 3u16);
        // C s_4067_2: const #3u : u8
        let s_4067_2: u8 = 3;
        // C s_4067_3: cast zx s_4067_2 -> bv
        let s_4067_3: Bits = Bits::new(s_4067_2 as u128, 3u16);
        // D s_4067_4: cmp-eq s_4067_1 s_4067_3
        let s_4067_4: bool = ((s_4067_1) == (s_4067_3));
        // D s_4067_5: write-var gs#118831 <= s_4067_4
        fn_state.gs_118831 = s_4067_4;
        // N s_4067_6: jump b2888
        return block_2888(state, tracer, fn_state);
    }
    fn block_4068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4068_0: read-var opc1:u8
        let s_4068_0: u8 = fn_state.opc1;
        // D s_4068_1: cast zx s_4068_0 -> bv
        let s_4068_1: Bits = Bits::new(s_4068_0 as u128, 3u16);
        // C s_4068_2: const #0u : u8
        let s_4068_2: u8 = 0;
        // C s_4068_3: cast zx s_4068_2 -> bv
        let s_4068_3: Bits = Bits::new(s_4068_2 as u128, 3u16);
        // D s_4068_4: cmp-eq s_4068_1 s_4068_3
        let s_4068_4: bool = ((s_4068_1) == (s_4068_3));
        // D s_4068_5: write-var gs#118830 <= s_4068_4
        fn_state.gs_118830 = s_4068_4;
        // N s_4068_6: jump b2886
        return block_2886(state, tracer, fn_state);
    }
    fn block_4069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4069_0: read-var coproc:u8
        let s_4069_0: u8 = fn_state.coproc;
        // D s_4069_1: cast zx s_4069_0 -> bv
        let s_4069_1: Bits = Bits::new(s_4069_0 as u128, 4u16);
        // C s_4069_2: const #15u : u8
        let s_4069_2: u8 = 15;
        // C s_4069_3: cast zx s_4069_2 -> bv
        let s_4069_3: Bits = Bits::new(s_4069_2 as u128, 4u16);
        // D s_4069_4: cmp-eq s_4069_1 s_4069_3
        let s_4069_4: bool = ((s_4069_1) == (s_4069_3));
        // D s_4069_5: write-var gs#118829 <= s_4069_4
        fn_state.gs_118829 = s_4069_4;
        // N s_4069_6: jump b2884
        return block_2884(state, tracer, fn_state);
    }
    fn block_4070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4070_0: read-var CRn:u8
        let s_4070_0: u8 = fn_state.CRn;
        // D s_4070_1: cast zx s_4070_0 -> bv
        let s_4070_1: Bits = Bits::new(s_4070_0 as u128, 4u16);
        // C s_4070_2: const #14u : u8
        let s_4070_2: u8 = 14;
        // C s_4070_3: cast zx s_4070_2 -> bv
        let s_4070_3: Bits = Bits::new(s_4070_2 as u128, 4u16);
        // D s_4070_4: cmp-eq s_4070_1 s_4070_3
        let s_4070_4: bool = ((s_4070_1) == (s_4070_3));
        // D s_4070_5: write-var gs#118828 <= s_4070_4
        fn_state.gs_118828 = s_4070_4;
        // N s_4070_6: jump b2882
        return block_2882(state, tracer, fn_state);
    }
    fn block_4071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4071_0: read-var el:u8
        let s_4071_0: u8 = fn_state.el;
        // D s_4071_1: read-var coproc:u8
        let s_4071_1: u8 = fn_state.coproc;
        // D s_4071_2: read-var opc1:u8
        let s_4071_2: u8 = fn_state.opc1;
        // D s_4071_3: read-var CRn:u8
        let s_4071_3: u8 = fn_state.CRn;
        // D s_4071_4: read-var opc2:u8
        let s_4071_4: u8 = fn_state.opc2;
        // D s_4071_5: read-var CRm:u8
        let s_4071_5: u8 = fn_state.CRm;
        // D s_4071_6: read-var t:i
        let s_4071_6: i128 = fn_state.t;
        // D s_4071_7: call PMEVTYPER_SysRegRead32_ee465be2d00a40c6(s_4071_0, s_4071_1, s_4071_2, s_4071_3, s_4071_4, s_4071_5, s_4071_6)
        let s_4071_7: () = PMEVTYPER_SysRegRead32_ee465be2d00a40c6(
            state,
            tracer,
            s_4071_0,
            s_4071_1,
            s_4071_2,
            s_4071_3,
            s_4071_4,
            s_4071_5,
            s_4071_6,
        );
        // N s_4071_8: return
        return;
    }
    fn block_4072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4072_0: read-var opc2:u8
        let s_4072_0: u8 = fn_state.opc2;
        // D s_4072_1: cast zx s_4072_0 -> bv
        let s_4072_1: Bits = Bits::new(s_4072_0 as u128, 3u16);
        // C s_4072_2: const #4u : u8
        let s_4072_2: u8 = 4;
        // C s_4072_3: cast zx s_4072_2 -> bv
        let s_4072_3: Bits = Bits::new(s_4072_2 as u128, 3u16);
        // D s_4072_4: cmp-eq s_4072_1 s_4072_3
        let s_4072_4: bool = ((s_4072_1) == (s_4072_3));
        // D s_4072_5: write-var gs#118827 <= s_4072_4
        fn_state.gs_118827 = s_4072_4;
        // N s_4072_6: jump b2879
        return block_2879(state, tracer, fn_state);
    }
    fn block_4073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4073_0: read-var opc1:u8
        let s_4073_0: u8 = fn_state.opc1;
        // D s_4073_1: cast zx s_4073_0 -> bv
        let s_4073_1: Bits = Bits::new(s_4073_0 as u128, 3u16);
        // C s_4073_2: const #0u : u8
        let s_4073_2: u8 = 0;
        // C s_4073_3: cast zx s_4073_2 -> bv
        let s_4073_3: Bits = Bits::new(s_4073_2 as u128, 3u16);
        // D s_4073_4: cmp-eq s_4073_1 s_4073_3
        let s_4073_4: bool = ((s_4073_1) == (s_4073_3));
        // D s_4073_5: write-var gs#118826 <= s_4073_4
        fn_state.gs_118826 = s_4073_4;
        // N s_4073_6: jump b2877
        return block_2877(state, tracer, fn_state);
    }
    fn block_4074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4074_0: read-var coproc:u8
        let s_4074_0: u8 = fn_state.coproc;
        // D s_4074_1: cast zx s_4074_0 -> bv
        let s_4074_1: Bits = Bits::new(s_4074_0 as u128, 4u16);
        // C s_4074_2: const #15u : u8
        let s_4074_2: u8 = 15;
        // C s_4074_3: cast zx s_4074_2 -> bv
        let s_4074_3: Bits = Bits::new(s_4074_2 as u128, 4u16);
        // D s_4074_4: cmp-eq s_4074_1 s_4074_3
        let s_4074_4: bool = ((s_4074_1) == (s_4074_3));
        // D s_4074_5: write-var gs#118825 <= s_4074_4
        fn_state.gs_118825 = s_4074_4;
        // N s_4074_6: jump b2875
        return block_2875(state, tracer, fn_state);
    }
    fn block_4075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4075_0: read-var CRn:u8
        let s_4075_0: u8 = fn_state.CRn;
        // D s_4075_1: cast zx s_4075_0 -> bv
        let s_4075_1: Bits = Bits::new(s_4075_0 as u128, 4u16);
        // C s_4075_2: const #14u : u8
        let s_4075_2: u8 = 14;
        // C s_4075_3: cast zx s_4075_2 -> bv
        let s_4075_3: Bits = Bits::new(s_4075_2 as u128, 4u16);
        // D s_4075_4: cmp-eq s_4075_1 s_4075_3
        let s_4075_4: bool = ((s_4075_1) == (s_4075_3));
        // D s_4075_5: write-var gs#118824 <= s_4075_4
        fn_state.gs_118824 = s_4075_4;
        // N s_4075_6: jump b2873
        return block_2873(state, tracer, fn_state);
    }
    fn block_4076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4076_0: read-var el:u8
        let s_4076_0: u8 = fn_state.el;
        // D s_4076_1: read-var coproc:u8
        let s_4076_1: u8 = fn_state.coproc;
        // D s_4076_2: read-var opc1:u8
        let s_4076_2: u8 = fn_state.opc1;
        // D s_4076_3: read-var CRn:u8
        let s_4076_3: u8 = fn_state.CRn;
        // D s_4076_4: read-var opc2:u8
        let s_4076_4: u8 = fn_state.opc2;
        // D s_4076_5: read-var CRm:u8
        let s_4076_5: u8 = fn_state.CRm;
        // D s_4076_6: read-var t:i
        let s_4076_6: i128 = fn_state.t;
        // D s_4076_7: call PMEVTYPER_SysRegRead32_9a798dcf0daf95cb(s_4076_0, s_4076_1, s_4076_2, s_4076_3, s_4076_4, s_4076_5, s_4076_6)
        let s_4076_7: () = PMEVTYPER_SysRegRead32_9a798dcf0daf95cb(
            state,
            tracer,
            s_4076_0,
            s_4076_1,
            s_4076_2,
            s_4076_3,
            s_4076_4,
            s_4076_5,
            s_4076_6,
        );
        // N s_4076_8: return
        return;
    }
    fn block_4077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4077_0: read-var opc2:u8
        let s_4077_0: u8 = fn_state.opc2;
        // D s_4077_1: cast zx s_4077_0 -> bv
        let s_4077_1: Bits = Bits::new(s_4077_0 as u128, 3u16);
        // C s_4077_2: const #5u : u8
        let s_4077_2: u8 = 5;
        // C s_4077_3: cast zx s_4077_2 -> bv
        let s_4077_3: Bits = Bits::new(s_4077_2 as u128, 3u16);
        // D s_4077_4: cmp-eq s_4077_1 s_4077_3
        let s_4077_4: bool = ((s_4077_1) == (s_4077_3));
        // D s_4077_5: write-var gs#118823 <= s_4077_4
        fn_state.gs_118823 = s_4077_4;
        // N s_4077_6: jump b2870
        return block_2870(state, tracer, fn_state);
    }
    fn block_4078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4078_0: read-var opc1:u8
        let s_4078_0: u8 = fn_state.opc1;
        // D s_4078_1: cast zx s_4078_0 -> bv
        let s_4078_1: Bits = Bits::new(s_4078_0 as u128, 3u16);
        // C s_4078_2: const #0u : u8
        let s_4078_2: u8 = 0;
        // C s_4078_3: cast zx s_4078_2 -> bv
        let s_4078_3: Bits = Bits::new(s_4078_2 as u128, 3u16);
        // D s_4078_4: cmp-eq s_4078_1 s_4078_3
        let s_4078_4: bool = ((s_4078_1) == (s_4078_3));
        // D s_4078_5: write-var gs#118822 <= s_4078_4
        fn_state.gs_118822 = s_4078_4;
        // N s_4078_6: jump b2868
        return block_2868(state, tracer, fn_state);
    }
    fn block_4079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4079_0: read-var coproc:u8
        let s_4079_0: u8 = fn_state.coproc;
        // D s_4079_1: cast zx s_4079_0 -> bv
        let s_4079_1: Bits = Bits::new(s_4079_0 as u128, 4u16);
        // C s_4079_2: const #15u : u8
        let s_4079_2: u8 = 15;
        // C s_4079_3: cast zx s_4079_2 -> bv
        let s_4079_3: Bits = Bits::new(s_4079_2 as u128, 4u16);
        // D s_4079_4: cmp-eq s_4079_1 s_4079_3
        let s_4079_4: bool = ((s_4079_1) == (s_4079_3));
        // D s_4079_5: write-var gs#118821 <= s_4079_4
        fn_state.gs_118821 = s_4079_4;
        // N s_4079_6: jump b2866
        return block_2866(state, tracer, fn_state);
    }
    fn block_4080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4080_0: read-var CRn:u8
        let s_4080_0: u8 = fn_state.CRn;
        // D s_4080_1: cast zx s_4080_0 -> bv
        let s_4080_1: Bits = Bits::new(s_4080_0 as u128, 4u16);
        // C s_4080_2: const #14u : u8
        let s_4080_2: u8 = 14;
        // C s_4080_3: cast zx s_4080_2 -> bv
        let s_4080_3: Bits = Bits::new(s_4080_2 as u128, 4u16);
        // D s_4080_4: cmp-eq s_4080_1 s_4080_3
        let s_4080_4: bool = ((s_4080_1) == (s_4080_3));
        // D s_4080_5: write-var gs#118820 <= s_4080_4
        fn_state.gs_118820 = s_4080_4;
        // N s_4080_6: jump b2864
        return block_2864(state, tracer, fn_state);
    }
    fn block_4081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4081_0: read-var el:u8
        let s_4081_0: u8 = fn_state.el;
        // D s_4081_1: read-var coproc:u8
        let s_4081_1: u8 = fn_state.coproc;
        // D s_4081_2: read-var opc1:u8
        let s_4081_2: u8 = fn_state.opc1;
        // D s_4081_3: read-var CRn:u8
        let s_4081_3: u8 = fn_state.CRn;
        // D s_4081_4: read-var opc2:u8
        let s_4081_4: u8 = fn_state.opc2;
        // D s_4081_5: read-var CRm:u8
        let s_4081_5: u8 = fn_state.CRm;
        // D s_4081_6: read-var t:i
        let s_4081_6: i128 = fn_state.t;
        // D s_4081_7: call PMEVTYPER_SysRegRead32_b52dcbee696e133d(s_4081_0, s_4081_1, s_4081_2, s_4081_3, s_4081_4, s_4081_5, s_4081_6)
        let s_4081_7: () = PMEVTYPER_SysRegRead32_b52dcbee696e133d(
            state,
            tracer,
            s_4081_0,
            s_4081_1,
            s_4081_2,
            s_4081_3,
            s_4081_4,
            s_4081_5,
            s_4081_6,
        );
        // N s_4081_8: return
        return;
    }
    fn block_4082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4082_0: read-var opc2:u8
        let s_4082_0: u8 = fn_state.opc2;
        // D s_4082_1: cast zx s_4082_0 -> bv
        let s_4082_1: Bits = Bits::new(s_4082_0 as u128, 3u16);
        // C s_4082_2: const #6u : u8
        let s_4082_2: u8 = 6;
        // C s_4082_3: cast zx s_4082_2 -> bv
        let s_4082_3: Bits = Bits::new(s_4082_2 as u128, 3u16);
        // D s_4082_4: cmp-eq s_4082_1 s_4082_3
        let s_4082_4: bool = ((s_4082_1) == (s_4082_3));
        // D s_4082_5: write-var gs#118819 <= s_4082_4
        fn_state.gs_118819 = s_4082_4;
        // N s_4082_6: jump b2861
        return block_2861(state, tracer, fn_state);
    }
    fn block_4083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4083_0: read-var opc1:u8
        let s_4083_0: u8 = fn_state.opc1;
        // D s_4083_1: cast zx s_4083_0 -> bv
        let s_4083_1: Bits = Bits::new(s_4083_0 as u128, 3u16);
        // C s_4083_2: const #0u : u8
        let s_4083_2: u8 = 0;
        // C s_4083_3: cast zx s_4083_2 -> bv
        let s_4083_3: Bits = Bits::new(s_4083_2 as u128, 3u16);
        // D s_4083_4: cmp-eq s_4083_1 s_4083_3
        let s_4083_4: bool = ((s_4083_1) == (s_4083_3));
        // D s_4083_5: write-var gs#118818 <= s_4083_4
        fn_state.gs_118818 = s_4083_4;
        // N s_4083_6: jump b2859
        return block_2859(state, tracer, fn_state);
    }
    fn block_4084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4084_0: read-var coproc:u8
        let s_4084_0: u8 = fn_state.coproc;
        // D s_4084_1: cast zx s_4084_0 -> bv
        let s_4084_1: Bits = Bits::new(s_4084_0 as u128, 4u16);
        // C s_4084_2: const #15u : u8
        let s_4084_2: u8 = 15;
        // C s_4084_3: cast zx s_4084_2 -> bv
        let s_4084_3: Bits = Bits::new(s_4084_2 as u128, 4u16);
        // D s_4084_4: cmp-eq s_4084_1 s_4084_3
        let s_4084_4: bool = ((s_4084_1) == (s_4084_3));
        // D s_4084_5: write-var gs#118817 <= s_4084_4
        fn_state.gs_118817 = s_4084_4;
        // N s_4084_6: jump b2857
        return block_2857(state, tracer, fn_state);
    }
    fn block_4085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4085_0: read-var CRn:u8
        let s_4085_0: u8 = fn_state.CRn;
        // D s_4085_1: cast zx s_4085_0 -> bv
        let s_4085_1: Bits = Bits::new(s_4085_0 as u128, 4u16);
        // C s_4085_2: const #14u : u8
        let s_4085_2: u8 = 14;
        // C s_4085_3: cast zx s_4085_2 -> bv
        let s_4085_3: Bits = Bits::new(s_4085_2 as u128, 4u16);
        // D s_4085_4: cmp-eq s_4085_1 s_4085_3
        let s_4085_4: bool = ((s_4085_1) == (s_4085_3));
        // D s_4085_5: write-var gs#118816 <= s_4085_4
        fn_state.gs_118816 = s_4085_4;
        // N s_4085_6: jump b2855
        return block_2855(state, tracer, fn_state);
    }
    fn block_4086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4086_0: read-var el:u8
        let s_4086_0: u8 = fn_state.el;
        // D s_4086_1: read-var coproc:u8
        let s_4086_1: u8 = fn_state.coproc;
        // D s_4086_2: read-var opc1:u8
        let s_4086_2: u8 = fn_state.opc1;
        // D s_4086_3: read-var CRn:u8
        let s_4086_3: u8 = fn_state.CRn;
        // D s_4086_4: read-var opc2:u8
        let s_4086_4: u8 = fn_state.opc2;
        // D s_4086_5: read-var CRm:u8
        let s_4086_5: u8 = fn_state.CRm;
        // D s_4086_6: read-var t:i
        let s_4086_6: i128 = fn_state.t;
        // D s_4086_7: call PMEVTYPER_SysRegRead32_bfb617825f6df35a(s_4086_0, s_4086_1, s_4086_2, s_4086_3, s_4086_4, s_4086_5, s_4086_6)
        let s_4086_7: () = PMEVTYPER_SysRegRead32_bfb617825f6df35a(
            state,
            tracer,
            s_4086_0,
            s_4086_1,
            s_4086_2,
            s_4086_3,
            s_4086_4,
            s_4086_5,
            s_4086_6,
        );
        // N s_4086_8: return
        return;
    }
    fn block_4087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4087_0: read-var opc2:u8
        let s_4087_0: u8 = fn_state.opc2;
        // D s_4087_1: cast zx s_4087_0 -> bv
        let s_4087_1: Bits = Bits::new(s_4087_0 as u128, 3u16);
        // C s_4087_2: const #7u : u8
        let s_4087_2: u8 = 7;
        // C s_4087_3: cast zx s_4087_2 -> bv
        let s_4087_3: Bits = Bits::new(s_4087_2 as u128, 3u16);
        // D s_4087_4: cmp-eq s_4087_1 s_4087_3
        let s_4087_4: bool = ((s_4087_1) == (s_4087_3));
        // D s_4087_5: write-var gs#118815 <= s_4087_4
        fn_state.gs_118815 = s_4087_4;
        // N s_4087_6: jump b2852
        return block_2852(state, tracer, fn_state);
    }
    fn block_4088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4088_0: read-var opc1:u8
        let s_4088_0: u8 = fn_state.opc1;
        // D s_4088_1: cast zx s_4088_0 -> bv
        let s_4088_1: Bits = Bits::new(s_4088_0 as u128, 3u16);
        // C s_4088_2: const #0u : u8
        let s_4088_2: u8 = 0;
        // C s_4088_3: cast zx s_4088_2 -> bv
        let s_4088_3: Bits = Bits::new(s_4088_2 as u128, 3u16);
        // D s_4088_4: cmp-eq s_4088_1 s_4088_3
        let s_4088_4: bool = ((s_4088_1) == (s_4088_3));
        // D s_4088_5: write-var gs#118814 <= s_4088_4
        fn_state.gs_118814 = s_4088_4;
        // N s_4088_6: jump b2850
        return block_2850(state, tracer, fn_state);
    }
    fn block_4089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4089_0: read-var coproc:u8
        let s_4089_0: u8 = fn_state.coproc;
        // D s_4089_1: cast zx s_4089_0 -> bv
        let s_4089_1: Bits = Bits::new(s_4089_0 as u128, 4u16);
        // C s_4089_2: const #15u : u8
        let s_4089_2: u8 = 15;
        // C s_4089_3: cast zx s_4089_2 -> bv
        let s_4089_3: Bits = Bits::new(s_4089_2 as u128, 4u16);
        // D s_4089_4: cmp-eq s_4089_1 s_4089_3
        let s_4089_4: bool = ((s_4089_1) == (s_4089_3));
        // D s_4089_5: write-var gs#118813 <= s_4089_4
        fn_state.gs_118813 = s_4089_4;
        // N s_4089_6: jump b2848
        return block_2848(state, tracer, fn_state);
    }
    fn block_4090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4090_0: read-var CRn:u8
        let s_4090_0: u8 = fn_state.CRn;
        // D s_4090_1: cast zx s_4090_0 -> bv
        let s_4090_1: Bits = Bits::new(s_4090_0 as u128, 4u16);
        // C s_4090_2: const #14u : u8
        let s_4090_2: u8 = 14;
        // C s_4090_3: cast zx s_4090_2 -> bv
        let s_4090_3: Bits = Bits::new(s_4090_2 as u128, 4u16);
        // D s_4090_4: cmp-eq s_4090_1 s_4090_3
        let s_4090_4: bool = ((s_4090_1) == (s_4090_3));
        // D s_4090_5: write-var gs#118812 <= s_4090_4
        fn_state.gs_118812 = s_4090_4;
        // N s_4090_6: jump b2846
        return block_2846(state, tracer, fn_state);
    }
    fn block_4091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4091_0: read-var el:u8
        let s_4091_0: u8 = fn_state.el;
        // D s_4091_1: read-var coproc:u8
        let s_4091_1: u8 = fn_state.coproc;
        // D s_4091_2: read-var opc1:u8
        let s_4091_2: u8 = fn_state.opc1;
        // D s_4091_3: read-var CRn:u8
        let s_4091_3: u8 = fn_state.CRn;
        // D s_4091_4: read-var opc2:u8
        let s_4091_4: u8 = fn_state.opc2;
        // D s_4091_5: read-var CRm:u8
        let s_4091_5: u8 = fn_state.CRm;
        // D s_4091_6: read-var t:i
        let s_4091_6: i128 = fn_state.t;
        // D s_4091_7: call PMEVTYPER_SysRegRead32_b68c85bd6c592527(s_4091_0, s_4091_1, s_4091_2, s_4091_3, s_4091_4, s_4091_5, s_4091_6)
        let s_4091_7: () = PMEVTYPER_SysRegRead32_b68c85bd6c592527(
            state,
            tracer,
            s_4091_0,
            s_4091_1,
            s_4091_2,
            s_4091_3,
            s_4091_4,
            s_4091_5,
            s_4091_6,
        );
        // N s_4091_8: return
        return;
    }
    fn block_4092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4092_0: read-var opc2:u8
        let s_4092_0: u8 = fn_state.opc2;
        // D s_4092_1: cast zx s_4092_0 -> bv
        let s_4092_1: Bits = Bits::new(s_4092_0 as u128, 3u16);
        // C s_4092_2: const #0u : u8
        let s_4092_2: u8 = 0;
        // C s_4092_3: cast zx s_4092_2 -> bv
        let s_4092_3: Bits = Bits::new(s_4092_2 as u128, 3u16);
        // D s_4092_4: cmp-eq s_4092_1 s_4092_3
        let s_4092_4: bool = ((s_4092_1) == (s_4092_3));
        // D s_4092_5: write-var gs#118811 <= s_4092_4
        fn_state.gs_118811 = s_4092_4;
        // N s_4092_6: jump b2843
        return block_2843(state, tracer, fn_state);
    }
    fn block_4093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4093_0: read-var opc1:u8
        let s_4093_0: u8 = fn_state.opc1;
        // D s_4093_1: cast zx s_4093_0 -> bv
        let s_4093_1: Bits = Bits::new(s_4093_0 as u128, 3u16);
        // C s_4093_2: const #0u : u8
        let s_4093_2: u8 = 0;
        // C s_4093_3: cast zx s_4093_2 -> bv
        let s_4093_3: Bits = Bits::new(s_4093_2 as u128, 3u16);
        // D s_4093_4: cmp-eq s_4093_1 s_4093_3
        let s_4093_4: bool = ((s_4093_1) == (s_4093_3));
        // D s_4093_5: write-var gs#118810 <= s_4093_4
        fn_state.gs_118810 = s_4093_4;
        // N s_4093_6: jump b2841
        return block_2841(state, tracer, fn_state);
    }
    fn block_4094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4094_0: read-var coproc:u8
        let s_4094_0: u8 = fn_state.coproc;
        // D s_4094_1: cast zx s_4094_0 -> bv
        let s_4094_1: Bits = Bits::new(s_4094_0 as u128, 4u16);
        // C s_4094_2: const #15u : u8
        let s_4094_2: u8 = 15;
        // C s_4094_3: cast zx s_4094_2 -> bv
        let s_4094_3: Bits = Bits::new(s_4094_2 as u128, 4u16);
        // D s_4094_4: cmp-eq s_4094_1 s_4094_3
        let s_4094_4: bool = ((s_4094_1) == (s_4094_3));
        // D s_4094_5: write-var gs#118809 <= s_4094_4
        fn_state.gs_118809 = s_4094_4;
        // N s_4094_6: jump b2839
        return block_2839(state, tracer, fn_state);
    }
    fn block_4095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4095_0: read-var CRn:u8
        let s_4095_0: u8 = fn_state.CRn;
        // D s_4095_1: cast zx s_4095_0 -> bv
        let s_4095_1: Bits = Bits::new(s_4095_0 as u128, 4u16);
        // C s_4095_2: const #14u : u8
        let s_4095_2: u8 = 14;
        // C s_4095_3: cast zx s_4095_2 -> bv
        let s_4095_3: Bits = Bits::new(s_4095_2 as u128, 4u16);
        // D s_4095_4: cmp-eq s_4095_1 s_4095_3
        let s_4095_4: bool = ((s_4095_1) == (s_4095_3));
        // D s_4095_5: write-var gs#118808 <= s_4095_4
        fn_state.gs_118808 = s_4095_4;
        // N s_4095_6: jump b2837
        return block_2837(state, tracer, fn_state);
    }
    fn block_4096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4096_0: read-var el:u8
        let s_4096_0: u8 = fn_state.el;
        // D s_4096_1: read-var coproc:u8
        let s_4096_1: u8 = fn_state.coproc;
        // D s_4096_2: read-var opc1:u8
        let s_4096_2: u8 = fn_state.opc1;
        // D s_4096_3: read-var CRn:u8
        let s_4096_3: u8 = fn_state.CRn;
        // D s_4096_4: read-var opc2:u8
        let s_4096_4: u8 = fn_state.opc2;
        // D s_4096_5: read-var CRm:u8
        let s_4096_5: u8 = fn_state.CRm;
        // D s_4096_6: read-var t:i
        let s_4096_6: i128 = fn_state.t;
        // D s_4096_7: call PMEVTYPER_SysRegRead32_2a2c31ce2d7ed27e(s_4096_0, s_4096_1, s_4096_2, s_4096_3, s_4096_4, s_4096_5, s_4096_6)
        let s_4096_7: () = PMEVTYPER_SysRegRead32_2a2c31ce2d7ed27e(
            state,
            tracer,
            s_4096_0,
            s_4096_1,
            s_4096_2,
            s_4096_3,
            s_4096_4,
            s_4096_5,
            s_4096_6,
        );
        // N s_4096_8: return
        return;
    }
    fn block_4097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4097_0: read-var opc2:u8
        let s_4097_0: u8 = fn_state.opc2;
        // D s_4097_1: cast zx s_4097_0 -> bv
        let s_4097_1: Bits = Bits::new(s_4097_0 as u128, 3u16);
        // C s_4097_2: const #1u : u8
        let s_4097_2: u8 = 1;
        // C s_4097_3: cast zx s_4097_2 -> bv
        let s_4097_3: Bits = Bits::new(s_4097_2 as u128, 3u16);
        // D s_4097_4: cmp-eq s_4097_1 s_4097_3
        let s_4097_4: bool = ((s_4097_1) == (s_4097_3));
        // D s_4097_5: write-var gs#118807 <= s_4097_4
        fn_state.gs_118807 = s_4097_4;
        // N s_4097_6: jump b2834
        return block_2834(state, tracer, fn_state);
    }
    fn block_4098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4098_0: read-var opc1:u8
        let s_4098_0: u8 = fn_state.opc1;
        // D s_4098_1: cast zx s_4098_0 -> bv
        let s_4098_1: Bits = Bits::new(s_4098_0 as u128, 3u16);
        // C s_4098_2: const #0u : u8
        let s_4098_2: u8 = 0;
        // C s_4098_3: cast zx s_4098_2 -> bv
        let s_4098_3: Bits = Bits::new(s_4098_2 as u128, 3u16);
        // D s_4098_4: cmp-eq s_4098_1 s_4098_3
        let s_4098_4: bool = ((s_4098_1) == (s_4098_3));
        // D s_4098_5: write-var gs#118806 <= s_4098_4
        fn_state.gs_118806 = s_4098_4;
        // N s_4098_6: jump b2832
        return block_2832(state, tracer, fn_state);
    }
    fn block_4099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4099_0: read-var coproc:u8
        let s_4099_0: u8 = fn_state.coproc;
        // D s_4099_1: cast zx s_4099_0 -> bv
        let s_4099_1: Bits = Bits::new(s_4099_0 as u128, 4u16);
        // C s_4099_2: const #15u : u8
        let s_4099_2: u8 = 15;
        // C s_4099_3: cast zx s_4099_2 -> bv
        let s_4099_3: Bits = Bits::new(s_4099_2 as u128, 4u16);
        // D s_4099_4: cmp-eq s_4099_1 s_4099_3
        let s_4099_4: bool = ((s_4099_1) == (s_4099_3));
        // D s_4099_5: write-var gs#118805 <= s_4099_4
        fn_state.gs_118805 = s_4099_4;
        // N s_4099_6: jump b2830
        return block_2830(state, tracer, fn_state);
    }
    fn block_4100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4100_0: read-var CRn:u8
        let s_4100_0: u8 = fn_state.CRn;
        // D s_4100_1: cast zx s_4100_0 -> bv
        let s_4100_1: Bits = Bits::new(s_4100_0 as u128, 4u16);
        // C s_4100_2: const #14u : u8
        let s_4100_2: u8 = 14;
        // C s_4100_3: cast zx s_4100_2 -> bv
        let s_4100_3: Bits = Bits::new(s_4100_2 as u128, 4u16);
        // D s_4100_4: cmp-eq s_4100_1 s_4100_3
        let s_4100_4: bool = ((s_4100_1) == (s_4100_3));
        // D s_4100_5: write-var gs#118804 <= s_4100_4
        fn_state.gs_118804 = s_4100_4;
        // N s_4100_6: jump b2828
        return block_2828(state, tracer, fn_state);
    }
    fn block_4101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4101_0: read-var el:u8
        let s_4101_0: u8 = fn_state.el;
        // D s_4101_1: read-var coproc:u8
        let s_4101_1: u8 = fn_state.coproc;
        // D s_4101_2: read-var opc1:u8
        let s_4101_2: u8 = fn_state.opc1;
        // D s_4101_3: read-var CRn:u8
        let s_4101_3: u8 = fn_state.CRn;
        // D s_4101_4: read-var opc2:u8
        let s_4101_4: u8 = fn_state.opc2;
        // D s_4101_5: read-var CRm:u8
        let s_4101_5: u8 = fn_state.CRm;
        // D s_4101_6: read-var t:i
        let s_4101_6: i128 = fn_state.t;
        // D s_4101_7: call PMEVTYPER_SysRegRead32_019fd9c590c5493b(s_4101_0, s_4101_1, s_4101_2, s_4101_3, s_4101_4, s_4101_5, s_4101_6)
        let s_4101_7: () = PMEVTYPER_SysRegRead32_019fd9c590c5493b(
            state,
            tracer,
            s_4101_0,
            s_4101_1,
            s_4101_2,
            s_4101_3,
            s_4101_4,
            s_4101_5,
            s_4101_6,
        );
        // N s_4101_8: return
        return;
    }
    fn block_4102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4102_0: read-var opc2:u8
        let s_4102_0: u8 = fn_state.opc2;
        // D s_4102_1: cast zx s_4102_0 -> bv
        let s_4102_1: Bits = Bits::new(s_4102_0 as u128, 3u16);
        // C s_4102_2: const #2u : u8
        let s_4102_2: u8 = 2;
        // C s_4102_3: cast zx s_4102_2 -> bv
        let s_4102_3: Bits = Bits::new(s_4102_2 as u128, 3u16);
        // D s_4102_4: cmp-eq s_4102_1 s_4102_3
        let s_4102_4: bool = ((s_4102_1) == (s_4102_3));
        // D s_4102_5: write-var gs#118803 <= s_4102_4
        fn_state.gs_118803 = s_4102_4;
        // N s_4102_6: jump b2825
        return block_2825(state, tracer, fn_state);
    }
    fn block_4103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4103_0: read-var opc1:u8
        let s_4103_0: u8 = fn_state.opc1;
        // D s_4103_1: cast zx s_4103_0 -> bv
        let s_4103_1: Bits = Bits::new(s_4103_0 as u128, 3u16);
        // C s_4103_2: const #0u : u8
        let s_4103_2: u8 = 0;
        // C s_4103_3: cast zx s_4103_2 -> bv
        let s_4103_3: Bits = Bits::new(s_4103_2 as u128, 3u16);
        // D s_4103_4: cmp-eq s_4103_1 s_4103_3
        let s_4103_4: bool = ((s_4103_1) == (s_4103_3));
        // D s_4103_5: write-var gs#118802 <= s_4103_4
        fn_state.gs_118802 = s_4103_4;
        // N s_4103_6: jump b2823
        return block_2823(state, tracer, fn_state);
    }
    fn block_4104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4104_0: read-var coproc:u8
        let s_4104_0: u8 = fn_state.coproc;
        // D s_4104_1: cast zx s_4104_0 -> bv
        let s_4104_1: Bits = Bits::new(s_4104_0 as u128, 4u16);
        // C s_4104_2: const #15u : u8
        let s_4104_2: u8 = 15;
        // C s_4104_3: cast zx s_4104_2 -> bv
        let s_4104_3: Bits = Bits::new(s_4104_2 as u128, 4u16);
        // D s_4104_4: cmp-eq s_4104_1 s_4104_3
        let s_4104_4: bool = ((s_4104_1) == (s_4104_3));
        // D s_4104_5: write-var gs#118801 <= s_4104_4
        fn_state.gs_118801 = s_4104_4;
        // N s_4104_6: jump b2821
        return block_2821(state, tracer, fn_state);
    }
    fn block_4105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4105_0: read-var CRn:u8
        let s_4105_0: u8 = fn_state.CRn;
        // D s_4105_1: cast zx s_4105_0 -> bv
        let s_4105_1: Bits = Bits::new(s_4105_0 as u128, 4u16);
        // C s_4105_2: const #14u : u8
        let s_4105_2: u8 = 14;
        // C s_4105_3: cast zx s_4105_2 -> bv
        let s_4105_3: Bits = Bits::new(s_4105_2 as u128, 4u16);
        // D s_4105_4: cmp-eq s_4105_1 s_4105_3
        let s_4105_4: bool = ((s_4105_1) == (s_4105_3));
        // D s_4105_5: write-var gs#118800 <= s_4105_4
        fn_state.gs_118800 = s_4105_4;
        // N s_4105_6: jump b2819
        return block_2819(state, tracer, fn_state);
    }
    fn block_4106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4106_0: read-var el:u8
        let s_4106_0: u8 = fn_state.el;
        // D s_4106_1: read-var coproc:u8
        let s_4106_1: u8 = fn_state.coproc;
        // D s_4106_2: read-var opc1:u8
        let s_4106_2: u8 = fn_state.opc1;
        // D s_4106_3: read-var CRn:u8
        let s_4106_3: u8 = fn_state.CRn;
        // D s_4106_4: read-var opc2:u8
        let s_4106_4: u8 = fn_state.opc2;
        // D s_4106_5: read-var CRm:u8
        let s_4106_5: u8 = fn_state.CRm;
        // D s_4106_6: read-var t:i
        let s_4106_6: i128 = fn_state.t;
        // D s_4106_7: call PMEVTYPER_SysRegRead32_cad120e9f2cb9ca7(s_4106_0, s_4106_1, s_4106_2, s_4106_3, s_4106_4, s_4106_5, s_4106_6)
        let s_4106_7: () = PMEVTYPER_SysRegRead32_cad120e9f2cb9ca7(
            state,
            tracer,
            s_4106_0,
            s_4106_1,
            s_4106_2,
            s_4106_3,
            s_4106_4,
            s_4106_5,
            s_4106_6,
        );
        // N s_4106_8: return
        return;
    }
    fn block_4107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4107_0: read-var opc2:u8
        let s_4107_0: u8 = fn_state.opc2;
        // D s_4107_1: cast zx s_4107_0 -> bv
        let s_4107_1: Bits = Bits::new(s_4107_0 as u128, 3u16);
        // C s_4107_2: const #3u : u8
        let s_4107_2: u8 = 3;
        // C s_4107_3: cast zx s_4107_2 -> bv
        let s_4107_3: Bits = Bits::new(s_4107_2 as u128, 3u16);
        // D s_4107_4: cmp-eq s_4107_1 s_4107_3
        let s_4107_4: bool = ((s_4107_1) == (s_4107_3));
        // D s_4107_5: write-var gs#118799 <= s_4107_4
        fn_state.gs_118799 = s_4107_4;
        // N s_4107_6: jump b2816
        return block_2816(state, tracer, fn_state);
    }
    fn block_4108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4108_0: read-var opc1:u8
        let s_4108_0: u8 = fn_state.opc1;
        // D s_4108_1: cast zx s_4108_0 -> bv
        let s_4108_1: Bits = Bits::new(s_4108_0 as u128, 3u16);
        // C s_4108_2: const #0u : u8
        let s_4108_2: u8 = 0;
        // C s_4108_3: cast zx s_4108_2 -> bv
        let s_4108_3: Bits = Bits::new(s_4108_2 as u128, 3u16);
        // D s_4108_4: cmp-eq s_4108_1 s_4108_3
        let s_4108_4: bool = ((s_4108_1) == (s_4108_3));
        // D s_4108_5: write-var gs#118798 <= s_4108_4
        fn_state.gs_118798 = s_4108_4;
        // N s_4108_6: jump b2814
        return block_2814(state, tracer, fn_state);
    }
    fn block_4109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4109_0: read-var coproc:u8
        let s_4109_0: u8 = fn_state.coproc;
        // D s_4109_1: cast zx s_4109_0 -> bv
        let s_4109_1: Bits = Bits::new(s_4109_0 as u128, 4u16);
        // C s_4109_2: const #15u : u8
        let s_4109_2: u8 = 15;
        // C s_4109_3: cast zx s_4109_2 -> bv
        let s_4109_3: Bits = Bits::new(s_4109_2 as u128, 4u16);
        // D s_4109_4: cmp-eq s_4109_1 s_4109_3
        let s_4109_4: bool = ((s_4109_1) == (s_4109_3));
        // D s_4109_5: write-var gs#118797 <= s_4109_4
        fn_state.gs_118797 = s_4109_4;
        // N s_4109_6: jump b2812
        return block_2812(state, tracer, fn_state);
    }
    fn block_4110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4110_0: read-var CRn:u8
        let s_4110_0: u8 = fn_state.CRn;
        // D s_4110_1: cast zx s_4110_0 -> bv
        let s_4110_1: Bits = Bits::new(s_4110_0 as u128, 4u16);
        // C s_4110_2: const #14u : u8
        let s_4110_2: u8 = 14;
        // C s_4110_3: cast zx s_4110_2 -> bv
        let s_4110_3: Bits = Bits::new(s_4110_2 as u128, 4u16);
        // D s_4110_4: cmp-eq s_4110_1 s_4110_3
        let s_4110_4: bool = ((s_4110_1) == (s_4110_3));
        // D s_4110_5: write-var gs#118796 <= s_4110_4
        fn_state.gs_118796 = s_4110_4;
        // N s_4110_6: jump b2810
        return block_2810(state, tracer, fn_state);
    }
    fn block_4111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4111_0: read-var el:u8
        let s_4111_0: u8 = fn_state.el;
        // D s_4111_1: read-var coproc:u8
        let s_4111_1: u8 = fn_state.coproc;
        // D s_4111_2: read-var opc1:u8
        let s_4111_2: u8 = fn_state.opc1;
        // D s_4111_3: read-var CRn:u8
        let s_4111_3: u8 = fn_state.CRn;
        // D s_4111_4: read-var opc2:u8
        let s_4111_4: u8 = fn_state.opc2;
        // D s_4111_5: read-var CRm:u8
        let s_4111_5: u8 = fn_state.CRm;
        // D s_4111_6: read-var t:i
        let s_4111_6: i128 = fn_state.t;
        // D s_4111_7: call PMEVTYPER_SysRegRead32_45af701dced58b54(s_4111_0, s_4111_1, s_4111_2, s_4111_3, s_4111_4, s_4111_5, s_4111_6)
        let s_4111_7: () = PMEVTYPER_SysRegRead32_45af701dced58b54(
            state,
            tracer,
            s_4111_0,
            s_4111_1,
            s_4111_2,
            s_4111_3,
            s_4111_4,
            s_4111_5,
            s_4111_6,
        );
        // N s_4111_8: return
        return;
    }
    fn block_4112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4112_0: read-var opc2:u8
        let s_4112_0: u8 = fn_state.opc2;
        // D s_4112_1: cast zx s_4112_0 -> bv
        let s_4112_1: Bits = Bits::new(s_4112_0 as u128, 3u16);
        // C s_4112_2: const #4u : u8
        let s_4112_2: u8 = 4;
        // C s_4112_3: cast zx s_4112_2 -> bv
        let s_4112_3: Bits = Bits::new(s_4112_2 as u128, 3u16);
        // D s_4112_4: cmp-eq s_4112_1 s_4112_3
        let s_4112_4: bool = ((s_4112_1) == (s_4112_3));
        // D s_4112_5: write-var gs#118795 <= s_4112_4
        fn_state.gs_118795 = s_4112_4;
        // N s_4112_6: jump b2807
        return block_2807(state, tracer, fn_state);
    }
    fn block_4113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4113_0: read-var opc1:u8
        let s_4113_0: u8 = fn_state.opc1;
        // D s_4113_1: cast zx s_4113_0 -> bv
        let s_4113_1: Bits = Bits::new(s_4113_0 as u128, 3u16);
        // C s_4113_2: const #0u : u8
        let s_4113_2: u8 = 0;
        // C s_4113_3: cast zx s_4113_2 -> bv
        let s_4113_3: Bits = Bits::new(s_4113_2 as u128, 3u16);
        // D s_4113_4: cmp-eq s_4113_1 s_4113_3
        let s_4113_4: bool = ((s_4113_1) == (s_4113_3));
        // D s_4113_5: write-var gs#118794 <= s_4113_4
        fn_state.gs_118794 = s_4113_4;
        // N s_4113_6: jump b2805
        return block_2805(state, tracer, fn_state);
    }
    fn block_4114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4114_0: read-var coproc:u8
        let s_4114_0: u8 = fn_state.coproc;
        // D s_4114_1: cast zx s_4114_0 -> bv
        let s_4114_1: Bits = Bits::new(s_4114_0 as u128, 4u16);
        // C s_4114_2: const #15u : u8
        let s_4114_2: u8 = 15;
        // C s_4114_3: cast zx s_4114_2 -> bv
        let s_4114_3: Bits = Bits::new(s_4114_2 as u128, 4u16);
        // D s_4114_4: cmp-eq s_4114_1 s_4114_3
        let s_4114_4: bool = ((s_4114_1) == (s_4114_3));
        // D s_4114_5: write-var gs#118793 <= s_4114_4
        fn_state.gs_118793 = s_4114_4;
        // N s_4114_6: jump b2803
        return block_2803(state, tracer, fn_state);
    }
    fn block_4115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4115_0: read-var CRn:u8
        let s_4115_0: u8 = fn_state.CRn;
        // D s_4115_1: cast zx s_4115_0 -> bv
        let s_4115_1: Bits = Bits::new(s_4115_0 as u128, 4u16);
        // C s_4115_2: const #14u : u8
        let s_4115_2: u8 = 14;
        // C s_4115_3: cast zx s_4115_2 -> bv
        let s_4115_3: Bits = Bits::new(s_4115_2 as u128, 4u16);
        // D s_4115_4: cmp-eq s_4115_1 s_4115_3
        let s_4115_4: bool = ((s_4115_1) == (s_4115_3));
        // D s_4115_5: write-var gs#118792 <= s_4115_4
        fn_state.gs_118792 = s_4115_4;
        // N s_4115_6: jump b2801
        return block_2801(state, tracer, fn_state);
    }
    fn block_4116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4116_0: read-var el:u8
        let s_4116_0: u8 = fn_state.el;
        // D s_4116_1: read-var coproc:u8
        let s_4116_1: u8 = fn_state.coproc;
        // D s_4116_2: read-var opc1:u8
        let s_4116_2: u8 = fn_state.opc1;
        // D s_4116_3: read-var CRn:u8
        let s_4116_3: u8 = fn_state.CRn;
        // D s_4116_4: read-var opc2:u8
        let s_4116_4: u8 = fn_state.opc2;
        // D s_4116_5: read-var CRm:u8
        let s_4116_5: u8 = fn_state.CRm;
        // D s_4116_6: read-var t:i
        let s_4116_6: i128 = fn_state.t;
        // D s_4116_7: call PMEVTYPER_SysRegRead32_e8227d66c6f9da2f(s_4116_0, s_4116_1, s_4116_2, s_4116_3, s_4116_4, s_4116_5, s_4116_6)
        let s_4116_7: () = PMEVTYPER_SysRegRead32_e8227d66c6f9da2f(
            state,
            tracer,
            s_4116_0,
            s_4116_1,
            s_4116_2,
            s_4116_3,
            s_4116_4,
            s_4116_5,
            s_4116_6,
        );
        // N s_4116_8: return
        return;
    }
    fn block_4117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4117_0: read-var opc2:u8
        let s_4117_0: u8 = fn_state.opc2;
        // D s_4117_1: cast zx s_4117_0 -> bv
        let s_4117_1: Bits = Bits::new(s_4117_0 as u128, 3u16);
        // C s_4117_2: const #5u : u8
        let s_4117_2: u8 = 5;
        // C s_4117_3: cast zx s_4117_2 -> bv
        let s_4117_3: Bits = Bits::new(s_4117_2 as u128, 3u16);
        // D s_4117_4: cmp-eq s_4117_1 s_4117_3
        let s_4117_4: bool = ((s_4117_1) == (s_4117_3));
        // D s_4117_5: write-var gs#118791 <= s_4117_4
        fn_state.gs_118791 = s_4117_4;
        // N s_4117_6: jump b2798
        return block_2798(state, tracer, fn_state);
    }
    fn block_4118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4118_0: read-var opc1:u8
        let s_4118_0: u8 = fn_state.opc1;
        // D s_4118_1: cast zx s_4118_0 -> bv
        let s_4118_1: Bits = Bits::new(s_4118_0 as u128, 3u16);
        // C s_4118_2: const #0u : u8
        let s_4118_2: u8 = 0;
        // C s_4118_3: cast zx s_4118_2 -> bv
        let s_4118_3: Bits = Bits::new(s_4118_2 as u128, 3u16);
        // D s_4118_4: cmp-eq s_4118_1 s_4118_3
        let s_4118_4: bool = ((s_4118_1) == (s_4118_3));
        // D s_4118_5: write-var gs#118790 <= s_4118_4
        fn_state.gs_118790 = s_4118_4;
        // N s_4118_6: jump b2796
        return block_2796(state, tracer, fn_state);
    }
    fn block_4119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4119_0: read-var coproc:u8
        let s_4119_0: u8 = fn_state.coproc;
        // D s_4119_1: cast zx s_4119_0 -> bv
        let s_4119_1: Bits = Bits::new(s_4119_0 as u128, 4u16);
        // C s_4119_2: const #15u : u8
        let s_4119_2: u8 = 15;
        // C s_4119_3: cast zx s_4119_2 -> bv
        let s_4119_3: Bits = Bits::new(s_4119_2 as u128, 4u16);
        // D s_4119_4: cmp-eq s_4119_1 s_4119_3
        let s_4119_4: bool = ((s_4119_1) == (s_4119_3));
        // D s_4119_5: write-var gs#118789 <= s_4119_4
        fn_state.gs_118789 = s_4119_4;
        // N s_4119_6: jump b2794
        return block_2794(state, tracer, fn_state);
    }
    fn block_4120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4120_0: read-var CRn:u8
        let s_4120_0: u8 = fn_state.CRn;
        // D s_4120_1: cast zx s_4120_0 -> bv
        let s_4120_1: Bits = Bits::new(s_4120_0 as u128, 4u16);
        // C s_4120_2: const #14u : u8
        let s_4120_2: u8 = 14;
        // C s_4120_3: cast zx s_4120_2 -> bv
        let s_4120_3: Bits = Bits::new(s_4120_2 as u128, 4u16);
        // D s_4120_4: cmp-eq s_4120_1 s_4120_3
        let s_4120_4: bool = ((s_4120_1) == (s_4120_3));
        // D s_4120_5: write-var gs#118788 <= s_4120_4
        fn_state.gs_118788 = s_4120_4;
        // N s_4120_6: jump b2792
        return block_2792(state, tracer, fn_state);
    }
    fn block_4121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4121_0: read-var el:u8
        let s_4121_0: u8 = fn_state.el;
        // D s_4121_1: read-var coproc:u8
        let s_4121_1: u8 = fn_state.coproc;
        // D s_4121_2: read-var opc1:u8
        let s_4121_2: u8 = fn_state.opc1;
        // D s_4121_3: read-var CRn:u8
        let s_4121_3: u8 = fn_state.CRn;
        // D s_4121_4: read-var opc2:u8
        let s_4121_4: u8 = fn_state.opc2;
        // D s_4121_5: read-var CRm:u8
        let s_4121_5: u8 = fn_state.CRm;
        // D s_4121_6: read-var t:i
        let s_4121_6: i128 = fn_state.t;
        // D s_4121_7: call PMEVTYPER_SysRegRead32_8e1055d5eee8d8d8(s_4121_0, s_4121_1, s_4121_2, s_4121_3, s_4121_4, s_4121_5, s_4121_6)
        let s_4121_7: () = PMEVTYPER_SysRegRead32_8e1055d5eee8d8d8(
            state,
            tracer,
            s_4121_0,
            s_4121_1,
            s_4121_2,
            s_4121_3,
            s_4121_4,
            s_4121_5,
            s_4121_6,
        );
        // N s_4121_8: return
        return;
    }
    fn block_4122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4122_0: read-var opc2:u8
        let s_4122_0: u8 = fn_state.opc2;
        // D s_4122_1: cast zx s_4122_0 -> bv
        let s_4122_1: Bits = Bits::new(s_4122_0 as u128, 3u16);
        // C s_4122_2: const #6u : u8
        let s_4122_2: u8 = 6;
        // C s_4122_3: cast zx s_4122_2 -> bv
        let s_4122_3: Bits = Bits::new(s_4122_2 as u128, 3u16);
        // D s_4122_4: cmp-eq s_4122_1 s_4122_3
        let s_4122_4: bool = ((s_4122_1) == (s_4122_3));
        // D s_4122_5: write-var gs#118787 <= s_4122_4
        fn_state.gs_118787 = s_4122_4;
        // N s_4122_6: jump b2789
        return block_2789(state, tracer, fn_state);
    }
    fn block_4123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4123_0: read-var opc1:u8
        let s_4123_0: u8 = fn_state.opc1;
        // D s_4123_1: cast zx s_4123_0 -> bv
        let s_4123_1: Bits = Bits::new(s_4123_0 as u128, 3u16);
        // C s_4123_2: const #0u : u8
        let s_4123_2: u8 = 0;
        // C s_4123_3: cast zx s_4123_2 -> bv
        let s_4123_3: Bits = Bits::new(s_4123_2 as u128, 3u16);
        // D s_4123_4: cmp-eq s_4123_1 s_4123_3
        let s_4123_4: bool = ((s_4123_1) == (s_4123_3));
        // D s_4123_5: write-var gs#118786 <= s_4123_4
        fn_state.gs_118786 = s_4123_4;
        // N s_4123_6: jump b2787
        return block_2787(state, tracer, fn_state);
    }
    fn block_4124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4124_0: read-var coproc:u8
        let s_4124_0: u8 = fn_state.coproc;
        // D s_4124_1: cast zx s_4124_0 -> bv
        let s_4124_1: Bits = Bits::new(s_4124_0 as u128, 4u16);
        // C s_4124_2: const #15u : u8
        let s_4124_2: u8 = 15;
        // C s_4124_3: cast zx s_4124_2 -> bv
        let s_4124_3: Bits = Bits::new(s_4124_2 as u128, 4u16);
        // D s_4124_4: cmp-eq s_4124_1 s_4124_3
        let s_4124_4: bool = ((s_4124_1) == (s_4124_3));
        // D s_4124_5: write-var gs#118785 <= s_4124_4
        fn_state.gs_118785 = s_4124_4;
        // N s_4124_6: jump b2785
        return block_2785(state, tracer, fn_state);
    }
    fn block_4125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4125_0: read-var CRn:u8
        let s_4125_0: u8 = fn_state.CRn;
        // D s_4125_1: cast zx s_4125_0 -> bv
        let s_4125_1: Bits = Bits::new(s_4125_0 as u128, 4u16);
        // C s_4125_2: const #14u : u8
        let s_4125_2: u8 = 14;
        // C s_4125_3: cast zx s_4125_2 -> bv
        let s_4125_3: Bits = Bits::new(s_4125_2 as u128, 4u16);
        // D s_4125_4: cmp-eq s_4125_1 s_4125_3
        let s_4125_4: bool = ((s_4125_1) == (s_4125_3));
        // D s_4125_5: write-var gs#118784 <= s_4125_4
        fn_state.gs_118784 = s_4125_4;
        // N s_4125_6: jump b2783
        return block_2783(state, tracer, fn_state);
    }
    fn block_4126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4126_0: read-var el:u8
        let s_4126_0: u8 = fn_state.el;
        // D s_4126_1: read-var coproc:u8
        let s_4126_1: u8 = fn_state.coproc;
        // D s_4126_2: read-var opc1:u8
        let s_4126_2: u8 = fn_state.opc1;
        // D s_4126_3: read-var CRn:u8
        let s_4126_3: u8 = fn_state.CRn;
        // D s_4126_4: read-var opc2:u8
        let s_4126_4: u8 = fn_state.opc2;
        // D s_4126_5: read-var CRm:u8
        let s_4126_5: u8 = fn_state.CRm;
        // D s_4126_6: read-var t:i
        let s_4126_6: i128 = fn_state.t;
        // D s_4126_7: call PMEVTYPER_SysRegRead32_b777a7113ecfbff9(s_4126_0, s_4126_1, s_4126_2, s_4126_3, s_4126_4, s_4126_5, s_4126_6)
        let s_4126_7: () = PMEVTYPER_SysRegRead32_b777a7113ecfbff9(
            state,
            tracer,
            s_4126_0,
            s_4126_1,
            s_4126_2,
            s_4126_3,
            s_4126_4,
            s_4126_5,
            s_4126_6,
        );
        // N s_4126_8: return
        return;
    }
    fn block_4127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4127_0: read-var opc2:u8
        let s_4127_0: u8 = fn_state.opc2;
        // D s_4127_1: cast zx s_4127_0 -> bv
        let s_4127_1: Bits = Bits::new(s_4127_0 as u128, 3u16);
        // C s_4127_2: const #7u : u8
        let s_4127_2: u8 = 7;
        // C s_4127_3: cast zx s_4127_2 -> bv
        let s_4127_3: Bits = Bits::new(s_4127_2 as u128, 3u16);
        // D s_4127_4: cmp-eq s_4127_1 s_4127_3
        let s_4127_4: bool = ((s_4127_1) == (s_4127_3));
        // D s_4127_5: write-var gs#118783 <= s_4127_4
        fn_state.gs_118783 = s_4127_4;
        // N s_4127_6: jump b2780
        return block_2780(state, tracer, fn_state);
    }
    fn block_4128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4128_0: read-var opc1:u8
        let s_4128_0: u8 = fn_state.opc1;
        // D s_4128_1: cast zx s_4128_0 -> bv
        let s_4128_1: Bits = Bits::new(s_4128_0 as u128, 3u16);
        // C s_4128_2: const #0u : u8
        let s_4128_2: u8 = 0;
        // C s_4128_3: cast zx s_4128_2 -> bv
        let s_4128_3: Bits = Bits::new(s_4128_2 as u128, 3u16);
        // D s_4128_4: cmp-eq s_4128_1 s_4128_3
        let s_4128_4: bool = ((s_4128_1) == (s_4128_3));
        // D s_4128_5: write-var gs#118782 <= s_4128_4
        fn_state.gs_118782 = s_4128_4;
        // N s_4128_6: jump b2778
        return block_2778(state, tracer, fn_state);
    }
    fn block_4129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4129_0: read-var coproc:u8
        let s_4129_0: u8 = fn_state.coproc;
        // D s_4129_1: cast zx s_4129_0 -> bv
        let s_4129_1: Bits = Bits::new(s_4129_0 as u128, 4u16);
        // C s_4129_2: const #15u : u8
        let s_4129_2: u8 = 15;
        // C s_4129_3: cast zx s_4129_2 -> bv
        let s_4129_3: Bits = Bits::new(s_4129_2 as u128, 4u16);
        // D s_4129_4: cmp-eq s_4129_1 s_4129_3
        let s_4129_4: bool = ((s_4129_1) == (s_4129_3));
        // D s_4129_5: write-var gs#118781 <= s_4129_4
        fn_state.gs_118781 = s_4129_4;
        // N s_4129_6: jump b2776
        return block_2776(state, tracer, fn_state);
    }
    fn block_4130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4130_0: read-var CRn:u8
        let s_4130_0: u8 = fn_state.CRn;
        // D s_4130_1: cast zx s_4130_0 -> bv
        let s_4130_1: Bits = Bits::new(s_4130_0 as u128, 4u16);
        // C s_4130_2: const #14u : u8
        let s_4130_2: u8 = 14;
        // C s_4130_3: cast zx s_4130_2 -> bv
        let s_4130_3: Bits = Bits::new(s_4130_2 as u128, 4u16);
        // D s_4130_4: cmp-eq s_4130_1 s_4130_3
        let s_4130_4: bool = ((s_4130_1) == (s_4130_3));
        // D s_4130_5: write-var gs#118780 <= s_4130_4
        fn_state.gs_118780 = s_4130_4;
        // N s_4130_6: jump b2774
        return block_2774(state, tracer, fn_state);
    }
    fn block_4131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4131_0: read-var el:u8
        let s_4131_0: u8 = fn_state.el;
        // D s_4131_1: read-var coproc:u8
        let s_4131_1: u8 = fn_state.coproc;
        // D s_4131_2: read-var opc1:u8
        let s_4131_2: u8 = fn_state.opc1;
        // D s_4131_3: read-var CRn:u8
        let s_4131_3: u8 = fn_state.CRn;
        // D s_4131_4: read-var opc2:u8
        let s_4131_4: u8 = fn_state.opc2;
        // D s_4131_5: read-var CRm:u8
        let s_4131_5: u8 = fn_state.CRm;
        // D s_4131_6: read-var t:i
        let s_4131_6: i128 = fn_state.t;
        // D s_4131_7: call PMEVTYPER_SysRegRead32_4afbf88ec8f5d079(s_4131_0, s_4131_1, s_4131_2, s_4131_3, s_4131_4, s_4131_5, s_4131_6)
        let s_4131_7: () = PMEVTYPER_SysRegRead32_4afbf88ec8f5d079(
            state,
            tracer,
            s_4131_0,
            s_4131_1,
            s_4131_2,
            s_4131_3,
            s_4131_4,
            s_4131_5,
            s_4131_6,
        );
        // N s_4131_8: return
        return;
    }
    fn block_4132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4132_0: read-var opc2:u8
        let s_4132_0: u8 = fn_state.opc2;
        // D s_4132_1: cast zx s_4132_0 -> bv
        let s_4132_1: Bits = Bits::new(s_4132_0 as u128, 3u16);
        // C s_4132_2: const #0u : u8
        let s_4132_2: u8 = 0;
        // C s_4132_3: cast zx s_4132_2 -> bv
        let s_4132_3: Bits = Bits::new(s_4132_2 as u128, 3u16);
        // D s_4132_4: cmp-eq s_4132_1 s_4132_3
        let s_4132_4: bool = ((s_4132_1) == (s_4132_3));
        // D s_4132_5: write-var gs#118779 <= s_4132_4
        fn_state.gs_118779 = s_4132_4;
        // N s_4132_6: jump b2771
        return block_2771(state, tracer, fn_state);
    }
    fn block_4133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4133_0: read-var opc1:u8
        let s_4133_0: u8 = fn_state.opc1;
        // D s_4133_1: cast zx s_4133_0 -> bv
        let s_4133_1: Bits = Bits::new(s_4133_0 as u128, 3u16);
        // C s_4133_2: const #0u : u8
        let s_4133_2: u8 = 0;
        // C s_4133_3: cast zx s_4133_2 -> bv
        let s_4133_3: Bits = Bits::new(s_4133_2 as u128, 3u16);
        // D s_4133_4: cmp-eq s_4133_1 s_4133_3
        let s_4133_4: bool = ((s_4133_1) == (s_4133_3));
        // D s_4133_5: write-var gs#118778 <= s_4133_4
        fn_state.gs_118778 = s_4133_4;
        // N s_4133_6: jump b2769
        return block_2769(state, tracer, fn_state);
    }
    fn block_4134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4134_0: read-var coproc:u8
        let s_4134_0: u8 = fn_state.coproc;
        // D s_4134_1: cast zx s_4134_0 -> bv
        let s_4134_1: Bits = Bits::new(s_4134_0 as u128, 4u16);
        // C s_4134_2: const #15u : u8
        let s_4134_2: u8 = 15;
        // C s_4134_3: cast zx s_4134_2 -> bv
        let s_4134_3: Bits = Bits::new(s_4134_2 as u128, 4u16);
        // D s_4134_4: cmp-eq s_4134_1 s_4134_3
        let s_4134_4: bool = ((s_4134_1) == (s_4134_3));
        // D s_4134_5: write-var gs#118777 <= s_4134_4
        fn_state.gs_118777 = s_4134_4;
        // N s_4134_6: jump b2767
        return block_2767(state, tracer, fn_state);
    }
    fn block_4135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4135_0: read-var CRn:u8
        let s_4135_0: u8 = fn_state.CRn;
        // D s_4135_1: cast zx s_4135_0 -> bv
        let s_4135_1: Bits = Bits::new(s_4135_0 as u128, 4u16);
        // C s_4135_2: const #14u : u8
        let s_4135_2: u8 = 14;
        // C s_4135_3: cast zx s_4135_2 -> bv
        let s_4135_3: Bits = Bits::new(s_4135_2 as u128, 4u16);
        // D s_4135_4: cmp-eq s_4135_1 s_4135_3
        let s_4135_4: bool = ((s_4135_1) == (s_4135_3));
        // D s_4135_5: write-var gs#118776 <= s_4135_4
        fn_state.gs_118776 = s_4135_4;
        // N s_4135_6: jump b2765
        return block_2765(state, tracer, fn_state);
    }
    fn block_4136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4136_0: read-var el:u8
        let s_4136_0: u8 = fn_state.el;
        // D s_4136_1: read-var coproc:u8
        let s_4136_1: u8 = fn_state.coproc;
        // D s_4136_2: read-var opc1:u8
        let s_4136_2: u8 = fn_state.opc1;
        // D s_4136_3: read-var CRn:u8
        let s_4136_3: u8 = fn_state.CRn;
        // D s_4136_4: read-var opc2:u8
        let s_4136_4: u8 = fn_state.opc2;
        // D s_4136_5: read-var CRm:u8
        let s_4136_5: u8 = fn_state.CRm;
        // D s_4136_6: read-var t:i
        let s_4136_6: i128 = fn_state.t;
        // D s_4136_7: call PMEVTYPER_SysRegRead32_ade15d0dc858c933(s_4136_0, s_4136_1, s_4136_2, s_4136_3, s_4136_4, s_4136_5, s_4136_6)
        let s_4136_7: () = PMEVTYPER_SysRegRead32_ade15d0dc858c933(
            state,
            tracer,
            s_4136_0,
            s_4136_1,
            s_4136_2,
            s_4136_3,
            s_4136_4,
            s_4136_5,
            s_4136_6,
        );
        // N s_4136_8: return
        return;
    }
    fn block_4137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4137_0: read-var opc2:u8
        let s_4137_0: u8 = fn_state.opc2;
        // D s_4137_1: cast zx s_4137_0 -> bv
        let s_4137_1: Bits = Bits::new(s_4137_0 as u128, 3u16);
        // C s_4137_2: const #1u : u8
        let s_4137_2: u8 = 1;
        // C s_4137_3: cast zx s_4137_2 -> bv
        let s_4137_3: Bits = Bits::new(s_4137_2 as u128, 3u16);
        // D s_4137_4: cmp-eq s_4137_1 s_4137_3
        let s_4137_4: bool = ((s_4137_1) == (s_4137_3));
        // D s_4137_5: write-var gs#118775 <= s_4137_4
        fn_state.gs_118775 = s_4137_4;
        // N s_4137_6: jump b2762
        return block_2762(state, tracer, fn_state);
    }
    fn block_4138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4138_0: read-var opc1:u8
        let s_4138_0: u8 = fn_state.opc1;
        // D s_4138_1: cast zx s_4138_0 -> bv
        let s_4138_1: Bits = Bits::new(s_4138_0 as u128, 3u16);
        // C s_4138_2: const #0u : u8
        let s_4138_2: u8 = 0;
        // C s_4138_3: cast zx s_4138_2 -> bv
        let s_4138_3: Bits = Bits::new(s_4138_2 as u128, 3u16);
        // D s_4138_4: cmp-eq s_4138_1 s_4138_3
        let s_4138_4: bool = ((s_4138_1) == (s_4138_3));
        // D s_4138_5: write-var gs#118774 <= s_4138_4
        fn_state.gs_118774 = s_4138_4;
        // N s_4138_6: jump b2760
        return block_2760(state, tracer, fn_state);
    }
    fn block_4139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4139_0: read-var coproc:u8
        let s_4139_0: u8 = fn_state.coproc;
        // D s_4139_1: cast zx s_4139_0 -> bv
        let s_4139_1: Bits = Bits::new(s_4139_0 as u128, 4u16);
        // C s_4139_2: const #15u : u8
        let s_4139_2: u8 = 15;
        // C s_4139_3: cast zx s_4139_2 -> bv
        let s_4139_3: Bits = Bits::new(s_4139_2 as u128, 4u16);
        // D s_4139_4: cmp-eq s_4139_1 s_4139_3
        let s_4139_4: bool = ((s_4139_1) == (s_4139_3));
        // D s_4139_5: write-var gs#118773 <= s_4139_4
        fn_state.gs_118773 = s_4139_4;
        // N s_4139_6: jump b2758
        return block_2758(state, tracer, fn_state);
    }
    fn block_4140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4140_0: read-var CRn:u8
        let s_4140_0: u8 = fn_state.CRn;
        // D s_4140_1: cast zx s_4140_0 -> bv
        let s_4140_1: Bits = Bits::new(s_4140_0 as u128, 4u16);
        // C s_4140_2: const #14u : u8
        let s_4140_2: u8 = 14;
        // C s_4140_3: cast zx s_4140_2 -> bv
        let s_4140_3: Bits = Bits::new(s_4140_2 as u128, 4u16);
        // D s_4140_4: cmp-eq s_4140_1 s_4140_3
        let s_4140_4: bool = ((s_4140_1) == (s_4140_3));
        // D s_4140_5: write-var gs#118772 <= s_4140_4
        fn_state.gs_118772 = s_4140_4;
        // N s_4140_6: jump b2756
        return block_2756(state, tracer, fn_state);
    }
    fn block_4141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4141_0: read-var el:u8
        let s_4141_0: u8 = fn_state.el;
        // D s_4141_1: read-var coproc:u8
        let s_4141_1: u8 = fn_state.coproc;
        // D s_4141_2: read-var opc1:u8
        let s_4141_2: u8 = fn_state.opc1;
        // D s_4141_3: read-var CRn:u8
        let s_4141_3: u8 = fn_state.CRn;
        // D s_4141_4: read-var opc2:u8
        let s_4141_4: u8 = fn_state.opc2;
        // D s_4141_5: read-var CRm:u8
        let s_4141_5: u8 = fn_state.CRm;
        // D s_4141_6: read-var t:i
        let s_4141_6: i128 = fn_state.t;
        // D s_4141_7: call PMEVTYPER_SysRegRead32_70d9e1901968a9f9(s_4141_0, s_4141_1, s_4141_2, s_4141_3, s_4141_4, s_4141_5, s_4141_6)
        let s_4141_7: () = PMEVTYPER_SysRegRead32_70d9e1901968a9f9(
            state,
            tracer,
            s_4141_0,
            s_4141_1,
            s_4141_2,
            s_4141_3,
            s_4141_4,
            s_4141_5,
            s_4141_6,
        );
        // N s_4141_8: return
        return;
    }
    fn block_4142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4142_0: read-var opc2:u8
        let s_4142_0: u8 = fn_state.opc2;
        // D s_4142_1: cast zx s_4142_0 -> bv
        let s_4142_1: Bits = Bits::new(s_4142_0 as u128, 3u16);
        // C s_4142_2: const #2u : u8
        let s_4142_2: u8 = 2;
        // C s_4142_3: cast zx s_4142_2 -> bv
        let s_4142_3: Bits = Bits::new(s_4142_2 as u128, 3u16);
        // D s_4142_4: cmp-eq s_4142_1 s_4142_3
        let s_4142_4: bool = ((s_4142_1) == (s_4142_3));
        // D s_4142_5: write-var gs#118771 <= s_4142_4
        fn_state.gs_118771 = s_4142_4;
        // N s_4142_6: jump b2753
        return block_2753(state, tracer, fn_state);
    }
    fn block_4143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4143_0: read-var opc1:u8
        let s_4143_0: u8 = fn_state.opc1;
        // D s_4143_1: cast zx s_4143_0 -> bv
        let s_4143_1: Bits = Bits::new(s_4143_0 as u128, 3u16);
        // C s_4143_2: const #0u : u8
        let s_4143_2: u8 = 0;
        // C s_4143_3: cast zx s_4143_2 -> bv
        let s_4143_3: Bits = Bits::new(s_4143_2 as u128, 3u16);
        // D s_4143_4: cmp-eq s_4143_1 s_4143_3
        let s_4143_4: bool = ((s_4143_1) == (s_4143_3));
        // D s_4143_5: write-var gs#118770 <= s_4143_4
        fn_state.gs_118770 = s_4143_4;
        // N s_4143_6: jump b2751
        return block_2751(state, tracer, fn_state);
    }
    fn block_4144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4144_0: read-var coproc:u8
        let s_4144_0: u8 = fn_state.coproc;
        // D s_4144_1: cast zx s_4144_0 -> bv
        let s_4144_1: Bits = Bits::new(s_4144_0 as u128, 4u16);
        // C s_4144_2: const #15u : u8
        let s_4144_2: u8 = 15;
        // C s_4144_3: cast zx s_4144_2 -> bv
        let s_4144_3: Bits = Bits::new(s_4144_2 as u128, 4u16);
        // D s_4144_4: cmp-eq s_4144_1 s_4144_3
        let s_4144_4: bool = ((s_4144_1) == (s_4144_3));
        // D s_4144_5: write-var gs#118769 <= s_4144_4
        fn_state.gs_118769 = s_4144_4;
        // N s_4144_6: jump b2749
        return block_2749(state, tracer, fn_state);
    }
    fn block_4145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4145_0: read-var CRn:u8
        let s_4145_0: u8 = fn_state.CRn;
        // D s_4145_1: cast zx s_4145_0 -> bv
        let s_4145_1: Bits = Bits::new(s_4145_0 as u128, 4u16);
        // C s_4145_2: const #14u : u8
        let s_4145_2: u8 = 14;
        // C s_4145_3: cast zx s_4145_2 -> bv
        let s_4145_3: Bits = Bits::new(s_4145_2 as u128, 4u16);
        // D s_4145_4: cmp-eq s_4145_1 s_4145_3
        let s_4145_4: bool = ((s_4145_1) == (s_4145_3));
        // D s_4145_5: write-var gs#118768 <= s_4145_4
        fn_state.gs_118768 = s_4145_4;
        // N s_4145_6: jump b2747
        return block_2747(state, tracer, fn_state);
    }
    fn block_4146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4146_0: read-var el:u8
        let s_4146_0: u8 = fn_state.el;
        // D s_4146_1: read-var coproc:u8
        let s_4146_1: u8 = fn_state.coproc;
        // D s_4146_2: read-var opc1:u8
        let s_4146_2: u8 = fn_state.opc1;
        // D s_4146_3: read-var CRn:u8
        let s_4146_3: u8 = fn_state.CRn;
        // D s_4146_4: read-var opc2:u8
        let s_4146_4: u8 = fn_state.opc2;
        // D s_4146_5: read-var CRm:u8
        let s_4146_5: u8 = fn_state.CRm;
        // D s_4146_6: read-var t:i
        let s_4146_6: i128 = fn_state.t;
        // D s_4146_7: call PMEVTYPER_SysRegRead32_cee8110828f1d34e(s_4146_0, s_4146_1, s_4146_2, s_4146_3, s_4146_4, s_4146_5, s_4146_6)
        let s_4146_7: () = PMEVTYPER_SysRegRead32_cee8110828f1d34e(
            state,
            tracer,
            s_4146_0,
            s_4146_1,
            s_4146_2,
            s_4146_3,
            s_4146_4,
            s_4146_5,
            s_4146_6,
        );
        // N s_4146_8: return
        return;
    }
    fn block_4147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4147_0: read-var opc2:u8
        let s_4147_0: u8 = fn_state.opc2;
        // D s_4147_1: cast zx s_4147_0 -> bv
        let s_4147_1: Bits = Bits::new(s_4147_0 as u128, 3u16);
        // C s_4147_2: const #3u : u8
        let s_4147_2: u8 = 3;
        // C s_4147_3: cast zx s_4147_2 -> bv
        let s_4147_3: Bits = Bits::new(s_4147_2 as u128, 3u16);
        // D s_4147_4: cmp-eq s_4147_1 s_4147_3
        let s_4147_4: bool = ((s_4147_1) == (s_4147_3));
        // D s_4147_5: write-var gs#118767 <= s_4147_4
        fn_state.gs_118767 = s_4147_4;
        // N s_4147_6: jump b2744
        return block_2744(state, tracer, fn_state);
    }
    fn block_4148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4148_0: read-var opc1:u8
        let s_4148_0: u8 = fn_state.opc1;
        // D s_4148_1: cast zx s_4148_0 -> bv
        let s_4148_1: Bits = Bits::new(s_4148_0 as u128, 3u16);
        // C s_4148_2: const #0u : u8
        let s_4148_2: u8 = 0;
        // C s_4148_3: cast zx s_4148_2 -> bv
        let s_4148_3: Bits = Bits::new(s_4148_2 as u128, 3u16);
        // D s_4148_4: cmp-eq s_4148_1 s_4148_3
        let s_4148_4: bool = ((s_4148_1) == (s_4148_3));
        // D s_4148_5: write-var gs#118766 <= s_4148_4
        fn_state.gs_118766 = s_4148_4;
        // N s_4148_6: jump b2742
        return block_2742(state, tracer, fn_state);
    }
    fn block_4149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4149_0: read-var coproc:u8
        let s_4149_0: u8 = fn_state.coproc;
        // D s_4149_1: cast zx s_4149_0 -> bv
        let s_4149_1: Bits = Bits::new(s_4149_0 as u128, 4u16);
        // C s_4149_2: const #15u : u8
        let s_4149_2: u8 = 15;
        // C s_4149_3: cast zx s_4149_2 -> bv
        let s_4149_3: Bits = Bits::new(s_4149_2 as u128, 4u16);
        // D s_4149_4: cmp-eq s_4149_1 s_4149_3
        let s_4149_4: bool = ((s_4149_1) == (s_4149_3));
        // D s_4149_5: write-var gs#118765 <= s_4149_4
        fn_state.gs_118765 = s_4149_4;
        // N s_4149_6: jump b2740
        return block_2740(state, tracer, fn_state);
    }
    fn block_4150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4150_0: read-var CRn:u8
        let s_4150_0: u8 = fn_state.CRn;
        // D s_4150_1: cast zx s_4150_0 -> bv
        let s_4150_1: Bits = Bits::new(s_4150_0 as u128, 4u16);
        // C s_4150_2: const #14u : u8
        let s_4150_2: u8 = 14;
        // C s_4150_3: cast zx s_4150_2 -> bv
        let s_4150_3: Bits = Bits::new(s_4150_2 as u128, 4u16);
        // D s_4150_4: cmp-eq s_4150_1 s_4150_3
        let s_4150_4: bool = ((s_4150_1) == (s_4150_3));
        // D s_4150_5: write-var gs#118764 <= s_4150_4
        fn_state.gs_118764 = s_4150_4;
        // N s_4150_6: jump b2738
        return block_2738(state, tracer, fn_state);
    }
    fn block_4151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4151_0: read-var el:u8
        let s_4151_0: u8 = fn_state.el;
        // D s_4151_1: read-var coproc:u8
        let s_4151_1: u8 = fn_state.coproc;
        // D s_4151_2: read-var opc1:u8
        let s_4151_2: u8 = fn_state.opc1;
        // D s_4151_3: read-var CRn:u8
        let s_4151_3: u8 = fn_state.CRn;
        // D s_4151_4: read-var opc2:u8
        let s_4151_4: u8 = fn_state.opc2;
        // D s_4151_5: read-var CRm:u8
        let s_4151_5: u8 = fn_state.CRm;
        // D s_4151_6: read-var t:i
        let s_4151_6: i128 = fn_state.t;
        // D s_4151_7: call PMEVTYPER_SysRegRead32_e8862be86d9568ea(s_4151_0, s_4151_1, s_4151_2, s_4151_3, s_4151_4, s_4151_5, s_4151_6)
        let s_4151_7: () = PMEVTYPER_SysRegRead32_e8862be86d9568ea(
            state,
            tracer,
            s_4151_0,
            s_4151_1,
            s_4151_2,
            s_4151_3,
            s_4151_4,
            s_4151_5,
            s_4151_6,
        );
        // N s_4151_8: return
        return;
    }
    fn block_4152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4152_0: read-var opc2:u8
        let s_4152_0: u8 = fn_state.opc2;
        // D s_4152_1: cast zx s_4152_0 -> bv
        let s_4152_1: Bits = Bits::new(s_4152_0 as u128, 3u16);
        // C s_4152_2: const #4u : u8
        let s_4152_2: u8 = 4;
        // C s_4152_3: cast zx s_4152_2 -> bv
        let s_4152_3: Bits = Bits::new(s_4152_2 as u128, 3u16);
        // D s_4152_4: cmp-eq s_4152_1 s_4152_3
        let s_4152_4: bool = ((s_4152_1) == (s_4152_3));
        // D s_4152_5: write-var gs#118763 <= s_4152_4
        fn_state.gs_118763 = s_4152_4;
        // N s_4152_6: jump b2735
        return block_2735(state, tracer, fn_state);
    }
    fn block_4153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4153_0: read-var opc1:u8
        let s_4153_0: u8 = fn_state.opc1;
        // D s_4153_1: cast zx s_4153_0 -> bv
        let s_4153_1: Bits = Bits::new(s_4153_0 as u128, 3u16);
        // C s_4153_2: const #0u : u8
        let s_4153_2: u8 = 0;
        // C s_4153_3: cast zx s_4153_2 -> bv
        let s_4153_3: Bits = Bits::new(s_4153_2 as u128, 3u16);
        // D s_4153_4: cmp-eq s_4153_1 s_4153_3
        let s_4153_4: bool = ((s_4153_1) == (s_4153_3));
        // D s_4153_5: write-var gs#118762 <= s_4153_4
        fn_state.gs_118762 = s_4153_4;
        // N s_4153_6: jump b2733
        return block_2733(state, tracer, fn_state);
    }
    fn block_4154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4154_0: read-var coproc:u8
        let s_4154_0: u8 = fn_state.coproc;
        // D s_4154_1: cast zx s_4154_0 -> bv
        let s_4154_1: Bits = Bits::new(s_4154_0 as u128, 4u16);
        // C s_4154_2: const #15u : u8
        let s_4154_2: u8 = 15;
        // C s_4154_3: cast zx s_4154_2 -> bv
        let s_4154_3: Bits = Bits::new(s_4154_2 as u128, 4u16);
        // D s_4154_4: cmp-eq s_4154_1 s_4154_3
        let s_4154_4: bool = ((s_4154_1) == (s_4154_3));
        // D s_4154_5: write-var gs#118761 <= s_4154_4
        fn_state.gs_118761 = s_4154_4;
        // N s_4154_6: jump b2731
        return block_2731(state, tracer, fn_state);
    }
    fn block_4155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4155_0: read-var CRn:u8
        let s_4155_0: u8 = fn_state.CRn;
        // D s_4155_1: cast zx s_4155_0 -> bv
        let s_4155_1: Bits = Bits::new(s_4155_0 as u128, 4u16);
        // C s_4155_2: const #14u : u8
        let s_4155_2: u8 = 14;
        // C s_4155_3: cast zx s_4155_2 -> bv
        let s_4155_3: Bits = Bits::new(s_4155_2 as u128, 4u16);
        // D s_4155_4: cmp-eq s_4155_1 s_4155_3
        let s_4155_4: bool = ((s_4155_1) == (s_4155_3));
        // D s_4155_5: write-var gs#118760 <= s_4155_4
        fn_state.gs_118760 = s_4155_4;
        // N s_4155_6: jump b2729
        return block_2729(state, tracer, fn_state);
    }
    fn block_4156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4156_0: read-var el:u8
        let s_4156_0: u8 = fn_state.el;
        // D s_4156_1: read-var coproc:u8
        let s_4156_1: u8 = fn_state.coproc;
        // D s_4156_2: read-var opc1:u8
        let s_4156_2: u8 = fn_state.opc1;
        // D s_4156_3: read-var CRn:u8
        let s_4156_3: u8 = fn_state.CRn;
        // D s_4156_4: read-var opc2:u8
        let s_4156_4: u8 = fn_state.opc2;
        // D s_4156_5: read-var CRm:u8
        let s_4156_5: u8 = fn_state.CRm;
        // D s_4156_6: read-var t:i
        let s_4156_6: i128 = fn_state.t;
        // D s_4156_7: call PMEVTYPER_SysRegRead32_2d5128aa6d782f92(s_4156_0, s_4156_1, s_4156_2, s_4156_3, s_4156_4, s_4156_5, s_4156_6)
        let s_4156_7: () = PMEVTYPER_SysRegRead32_2d5128aa6d782f92(
            state,
            tracer,
            s_4156_0,
            s_4156_1,
            s_4156_2,
            s_4156_3,
            s_4156_4,
            s_4156_5,
            s_4156_6,
        );
        // N s_4156_8: return
        return;
    }
    fn block_4157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4157_0: read-var opc2:u8
        let s_4157_0: u8 = fn_state.opc2;
        // D s_4157_1: cast zx s_4157_0 -> bv
        let s_4157_1: Bits = Bits::new(s_4157_0 as u128, 3u16);
        // C s_4157_2: const #5u : u8
        let s_4157_2: u8 = 5;
        // C s_4157_3: cast zx s_4157_2 -> bv
        let s_4157_3: Bits = Bits::new(s_4157_2 as u128, 3u16);
        // D s_4157_4: cmp-eq s_4157_1 s_4157_3
        let s_4157_4: bool = ((s_4157_1) == (s_4157_3));
        // D s_4157_5: write-var gs#118759 <= s_4157_4
        fn_state.gs_118759 = s_4157_4;
        // N s_4157_6: jump b2726
        return block_2726(state, tracer, fn_state);
    }
    fn block_4158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4158_0: read-var opc1:u8
        let s_4158_0: u8 = fn_state.opc1;
        // D s_4158_1: cast zx s_4158_0 -> bv
        let s_4158_1: Bits = Bits::new(s_4158_0 as u128, 3u16);
        // C s_4158_2: const #0u : u8
        let s_4158_2: u8 = 0;
        // C s_4158_3: cast zx s_4158_2 -> bv
        let s_4158_3: Bits = Bits::new(s_4158_2 as u128, 3u16);
        // D s_4158_4: cmp-eq s_4158_1 s_4158_3
        let s_4158_4: bool = ((s_4158_1) == (s_4158_3));
        // D s_4158_5: write-var gs#118758 <= s_4158_4
        fn_state.gs_118758 = s_4158_4;
        // N s_4158_6: jump b2724
        return block_2724(state, tracer, fn_state);
    }
    fn block_4159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4159_0: read-var coproc:u8
        let s_4159_0: u8 = fn_state.coproc;
        // D s_4159_1: cast zx s_4159_0 -> bv
        let s_4159_1: Bits = Bits::new(s_4159_0 as u128, 4u16);
        // C s_4159_2: const #15u : u8
        let s_4159_2: u8 = 15;
        // C s_4159_3: cast zx s_4159_2 -> bv
        let s_4159_3: Bits = Bits::new(s_4159_2 as u128, 4u16);
        // D s_4159_4: cmp-eq s_4159_1 s_4159_3
        let s_4159_4: bool = ((s_4159_1) == (s_4159_3));
        // D s_4159_5: write-var gs#118757 <= s_4159_4
        fn_state.gs_118757 = s_4159_4;
        // N s_4159_6: jump b2722
        return block_2722(state, tracer, fn_state);
    }
    fn block_4160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4160_0: read-var CRn:u8
        let s_4160_0: u8 = fn_state.CRn;
        // D s_4160_1: cast zx s_4160_0 -> bv
        let s_4160_1: Bits = Bits::new(s_4160_0 as u128, 4u16);
        // C s_4160_2: const #14u : u8
        let s_4160_2: u8 = 14;
        // C s_4160_3: cast zx s_4160_2 -> bv
        let s_4160_3: Bits = Bits::new(s_4160_2 as u128, 4u16);
        // D s_4160_4: cmp-eq s_4160_1 s_4160_3
        let s_4160_4: bool = ((s_4160_1) == (s_4160_3));
        // D s_4160_5: write-var gs#118756 <= s_4160_4
        fn_state.gs_118756 = s_4160_4;
        // N s_4160_6: jump b2720
        return block_2720(state, tracer, fn_state);
    }
    fn block_4161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4161_0: read-var el:u8
        let s_4161_0: u8 = fn_state.el;
        // D s_4161_1: read-var coproc:u8
        let s_4161_1: u8 = fn_state.coproc;
        // D s_4161_2: read-var opc1:u8
        let s_4161_2: u8 = fn_state.opc1;
        // D s_4161_3: read-var CRn:u8
        let s_4161_3: u8 = fn_state.CRn;
        // D s_4161_4: read-var opc2:u8
        let s_4161_4: u8 = fn_state.opc2;
        // D s_4161_5: read-var CRm:u8
        let s_4161_5: u8 = fn_state.CRm;
        // D s_4161_6: read-var t:i
        let s_4161_6: i128 = fn_state.t;
        // D s_4161_7: call PMEVTYPER_SysRegRead32_2680120d4a51efdc(s_4161_0, s_4161_1, s_4161_2, s_4161_3, s_4161_4, s_4161_5, s_4161_6)
        let s_4161_7: () = PMEVTYPER_SysRegRead32_2680120d4a51efdc(
            state,
            tracer,
            s_4161_0,
            s_4161_1,
            s_4161_2,
            s_4161_3,
            s_4161_4,
            s_4161_5,
            s_4161_6,
        );
        // N s_4161_8: return
        return;
    }
    fn block_4162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4162_0: read-var opc2:u8
        let s_4162_0: u8 = fn_state.opc2;
        // D s_4162_1: cast zx s_4162_0 -> bv
        let s_4162_1: Bits = Bits::new(s_4162_0 as u128, 3u16);
        // C s_4162_2: const #6u : u8
        let s_4162_2: u8 = 6;
        // C s_4162_3: cast zx s_4162_2 -> bv
        let s_4162_3: Bits = Bits::new(s_4162_2 as u128, 3u16);
        // D s_4162_4: cmp-eq s_4162_1 s_4162_3
        let s_4162_4: bool = ((s_4162_1) == (s_4162_3));
        // D s_4162_5: write-var gs#118755 <= s_4162_4
        fn_state.gs_118755 = s_4162_4;
        // N s_4162_6: jump b2717
        return block_2717(state, tracer, fn_state);
    }
    fn block_4163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4163_0: read-var opc1:u8
        let s_4163_0: u8 = fn_state.opc1;
        // D s_4163_1: cast zx s_4163_0 -> bv
        let s_4163_1: Bits = Bits::new(s_4163_0 as u128, 3u16);
        // C s_4163_2: const #0u : u8
        let s_4163_2: u8 = 0;
        // C s_4163_3: cast zx s_4163_2 -> bv
        let s_4163_3: Bits = Bits::new(s_4163_2 as u128, 3u16);
        // D s_4163_4: cmp-eq s_4163_1 s_4163_3
        let s_4163_4: bool = ((s_4163_1) == (s_4163_3));
        // D s_4163_5: write-var gs#118754 <= s_4163_4
        fn_state.gs_118754 = s_4163_4;
        // N s_4163_6: jump b2715
        return block_2715(state, tracer, fn_state);
    }
    fn block_4164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4164_0: read-var coproc:u8
        let s_4164_0: u8 = fn_state.coproc;
        // D s_4164_1: cast zx s_4164_0 -> bv
        let s_4164_1: Bits = Bits::new(s_4164_0 as u128, 4u16);
        // C s_4164_2: const #15u : u8
        let s_4164_2: u8 = 15;
        // C s_4164_3: cast zx s_4164_2 -> bv
        let s_4164_3: Bits = Bits::new(s_4164_2 as u128, 4u16);
        // D s_4164_4: cmp-eq s_4164_1 s_4164_3
        let s_4164_4: bool = ((s_4164_1) == (s_4164_3));
        // D s_4164_5: write-var gs#118753 <= s_4164_4
        fn_state.gs_118753 = s_4164_4;
        // N s_4164_6: jump b2713
        return block_2713(state, tracer, fn_state);
    }
    fn block_4165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4165_0: read-var CRn:u8
        let s_4165_0: u8 = fn_state.CRn;
        // D s_4165_1: cast zx s_4165_0 -> bv
        let s_4165_1: Bits = Bits::new(s_4165_0 as u128, 4u16);
        // C s_4165_2: const #14u : u8
        let s_4165_2: u8 = 14;
        // C s_4165_3: cast zx s_4165_2 -> bv
        let s_4165_3: Bits = Bits::new(s_4165_2 as u128, 4u16);
        // D s_4165_4: cmp-eq s_4165_1 s_4165_3
        let s_4165_4: bool = ((s_4165_1) == (s_4165_3));
        // D s_4165_5: write-var gs#118752 <= s_4165_4
        fn_state.gs_118752 = s_4165_4;
        // N s_4165_6: jump b2711
        return block_2711(state, tracer, fn_state);
    }
    fn block_4166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4166_0: read-var el:u8
        let s_4166_0: u8 = fn_state.el;
        // D s_4166_1: read-var coproc:u8
        let s_4166_1: u8 = fn_state.coproc;
        // D s_4166_2: read-var opc1:u8
        let s_4166_2: u8 = fn_state.opc1;
        // D s_4166_3: read-var CRn:u8
        let s_4166_3: u8 = fn_state.CRn;
        // D s_4166_4: read-var opc2:u8
        let s_4166_4: u8 = fn_state.opc2;
        // D s_4166_5: read-var CRm:u8
        let s_4166_5: u8 = fn_state.CRm;
        // D s_4166_6: read-var t:i
        let s_4166_6: i128 = fn_state.t;
        // D s_4166_7: call PMEVTYPER_SysRegRead32_5a6097f662a615bc(s_4166_0, s_4166_1, s_4166_2, s_4166_3, s_4166_4, s_4166_5, s_4166_6)
        let s_4166_7: () = PMEVTYPER_SysRegRead32_5a6097f662a615bc(
            state,
            tracer,
            s_4166_0,
            s_4166_1,
            s_4166_2,
            s_4166_3,
            s_4166_4,
            s_4166_5,
            s_4166_6,
        );
        // N s_4166_8: return
        return;
    }
    fn block_4167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4167_0: read-var opc2:u8
        let s_4167_0: u8 = fn_state.opc2;
        // D s_4167_1: cast zx s_4167_0 -> bv
        let s_4167_1: Bits = Bits::new(s_4167_0 as u128, 3u16);
        // C s_4167_2: const #7u : u8
        let s_4167_2: u8 = 7;
        // C s_4167_3: cast zx s_4167_2 -> bv
        let s_4167_3: Bits = Bits::new(s_4167_2 as u128, 3u16);
        // D s_4167_4: cmp-eq s_4167_1 s_4167_3
        let s_4167_4: bool = ((s_4167_1) == (s_4167_3));
        // D s_4167_5: write-var gs#118751 <= s_4167_4
        fn_state.gs_118751 = s_4167_4;
        // N s_4167_6: jump b2708
        return block_2708(state, tracer, fn_state);
    }
    fn block_4168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4168_0: read-var opc1:u8
        let s_4168_0: u8 = fn_state.opc1;
        // D s_4168_1: cast zx s_4168_0 -> bv
        let s_4168_1: Bits = Bits::new(s_4168_0 as u128, 3u16);
        // C s_4168_2: const #0u : u8
        let s_4168_2: u8 = 0;
        // C s_4168_3: cast zx s_4168_2 -> bv
        let s_4168_3: Bits = Bits::new(s_4168_2 as u128, 3u16);
        // D s_4168_4: cmp-eq s_4168_1 s_4168_3
        let s_4168_4: bool = ((s_4168_1) == (s_4168_3));
        // D s_4168_5: write-var gs#118750 <= s_4168_4
        fn_state.gs_118750 = s_4168_4;
        // N s_4168_6: jump b2706
        return block_2706(state, tracer, fn_state);
    }
    fn block_4169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4169_0: read-var coproc:u8
        let s_4169_0: u8 = fn_state.coproc;
        // D s_4169_1: cast zx s_4169_0 -> bv
        let s_4169_1: Bits = Bits::new(s_4169_0 as u128, 4u16);
        // C s_4169_2: const #15u : u8
        let s_4169_2: u8 = 15;
        // C s_4169_3: cast zx s_4169_2 -> bv
        let s_4169_3: Bits = Bits::new(s_4169_2 as u128, 4u16);
        // D s_4169_4: cmp-eq s_4169_1 s_4169_3
        let s_4169_4: bool = ((s_4169_1) == (s_4169_3));
        // D s_4169_5: write-var gs#118749 <= s_4169_4
        fn_state.gs_118749 = s_4169_4;
        // N s_4169_6: jump b2704
        return block_2704(state, tracer, fn_state);
    }
    fn block_4170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4170_0: read-var CRn:u8
        let s_4170_0: u8 = fn_state.CRn;
        // D s_4170_1: cast zx s_4170_0 -> bv
        let s_4170_1: Bits = Bits::new(s_4170_0 as u128, 4u16);
        // C s_4170_2: const #14u : u8
        let s_4170_2: u8 = 14;
        // C s_4170_3: cast zx s_4170_2 -> bv
        let s_4170_3: Bits = Bits::new(s_4170_2 as u128, 4u16);
        // D s_4170_4: cmp-eq s_4170_1 s_4170_3
        let s_4170_4: bool = ((s_4170_1) == (s_4170_3));
        // D s_4170_5: write-var gs#118748 <= s_4170_4
        fn_state.gs_118748 = s_4170_4;
        // N s_4170_6: jump b2702
        return block_2702(state, tracer, fn_state);
    }
    fn block_4171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4171_0: read-var el:u8
        let s_4171_0: u8 = fn_state.el;
        // D s_4171_1: read-var coproc:u8
        let s_4171_1: u8 = fn_state.coproc;
        // D s_4171_2: read-var opc1:u8
        let s_4171_2: u8 = fn_state.opc1;
        // D s_4171_3: read-var CRn:u8
        let s_4171_3: u8 = fn_state.CRn;
        // D s_4171_4: read-var opc2:u8
        let s_4171_4: u8 = fn_state.opc2;
        // D s_4171_5: read-var CRm:u8
        let s_4171_5: u8 = fn_state.CRm;
        // D s_4171_6: read-var t:i
        let s_4171_6: i128 = fn_state.t;
        // D s_4171_7: call PMEVTYPER_SysRegRead32_011983e256b06e5a(s_4171_0, s_4171_1, s_4171_2, s_4171_3, s_4171_4, s_4171_5, s_4171_6)
        let s_4171_7: () = PMEVTYPER_SysRegRead32_011983e256b06e5a(
            state,
            tracer,
            s_4171_0,
            s_4171_1,
            s_4171_2,
            s_4171_3,
            s_4171_4,
            s_4171_5,
            s_4171_6,
        );
        // N s_4171_8: return
        return;
    }
    fn block_4172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4172_0: read-var opc2:u8
        let s_4172_0: u8 = fn_state.opc2;
        // D s_4172_1: cast zx s_4172_0 -> bv
        let s_4172_1: Bits = Bits::new(s_4172_0 as u128, 3u16);
        // C s_4172_2: const #0u : u8
        let s_4172_2: u8 = 0;
        // C s_4172_3: cast zx s_4172_2 -> bv
        let s_4172_3: Bits = Bits::new(s_4172_2 as u128, 3u16);
        // D s_4172_4: cmp-eq s_4172_1 s_4172_3
        let s_4172_4: bool = ((s_4172_1) == (s_4172_3));
        // D s_4172_5: write-var gs#118747 <= s_4172_4
        fn_state.gs_118747 = s_4172_4;
        // N s_4172_6: jump b2699
        return block_2699(state, tracer, fn_state);
    }
    fn block_4173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4173_0: read-var opc1:u8
        let s_4173_0: u8 = fn_state.opc1;
        // D s_4173_1: cast zx s_4173_0 -> bv
        let s_4173_1: Bits = Bits::new(s_4173_0 as u128, 3u16);
        // C s_4173_2: const #0u : u8
        let s_4173_2: u8 = 0;
        // C s_4173_3: cast zx s_4173_2 -> bv
        let s_4173_3: Bits = Bits::new(s_4173_2 as u128, 3u16);
        // D s_4173_4: cmp-eq s_4173_1 s_4173_3
        let s_4173_4: bool = ((s_4173_1) == (s_4173_3));
        // D s_4173_5: write-var gs#118746 <= s_4173_4
        fn_state.gs_118746 = s_4173_4;
        // N s_4173_6: jump b2697
        return block_2697(state, tracer, fn_state);
    }
    fn block_4174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4174_0: read-var coproc:u8
        let s_4174_0: u8 = fn_state.coproc;
        // D s_4174_1: cast zx s_4174_0 -> bv
        let s_4174_1: Bits = Bits::new(s_4174_0 as u128, 4u16);
        // C s_4174_2: const #15u : u8
        let s_4174_2: u8 = 15;
        // C s_4174_3: cast zx s_4174_2 -> bv
        let s_4174_3: Bits = Bits::new(s_4174_2 as u128, 4u16);
        // D s_4174_4: cmp-eq s_4174_1 s_4174_3
        let s_4174_4: bool = ((s_4174_1) == (s_4174_3));
        // D s_4174_5: write-var gs#118745 <= s_4174_4
        fn_state.gs_118745 = s_4174_4;
        // N s_4174_6: jump b2695
        return block_2695(state, tracer, fn_state);
    }
    fn block_4175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4175_0: read-var CRn:u8
        let s_4175_0: u8 = fn_state.CRn;
        // D s_4175_1: cast zx s_4175_0 -> bv
        let s_4175_1: Bits = Bits::new(s_4175_0 as u128, 4u16);
        // C s_4175_2: const #14u : u8
        let s_4175_2: u8 = 14;
        // C s_4175_3: cast zx s_4175_2 -> bv
        let s_4175_3: Bits = Bits::new(s_4175_2 as u128, 4u16);
        // D s_4175_4: cmp-eq s_4175_1 s_4175_3
        let s_4175_4: bool = ((s_4175_1) == (s_4175_3));
        // D s_4175_5: write-var gs#118744 <= s_4175_4
        fn_state.gs_118744 = s_4175_4;
        // N s_4175_6: jump b2693
        return block_2693(state, tracer, fn_state);
    }
    fn block_4176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4176_0: read-var el:u8
        let s_4176_0: u8 = fn_state.el;
        // D s_4176_1: read-var coproc:u8
        let s_4176_1: u8 = fn_state.coproc;
        // D s_4176_2: read-var opc1:u8
        let s_4176_2: u8 = fn_state.opc1;
        // D s_4176_3: read-var CRn:u8
        let s_4176_3: u8 = fn_state.CRn;
        // D s_4176_4: read-var opc2:u8
        let s_4176_4: u8 = fn_state.opc2;
        // D s_4176_5: read-var CRm:u8
        let s_4176_5: u8 = fn_state.CRm;
        // D s_4176_6: read-var t:i
        let s_4176_6: i128 = fn_state.t;
        // D s_4176_7: call PMEVTYPER_SysRegRead32_0ba0c427729d1f96(s_4176_0, s_4176_1, s_4176_2, s_4176_3, s_4176_4, s_4176_5, s_4176_6)
        let s_4176_7: () = PMEVTYPER_SysRegRead32_0ba0c427729d1f96(
            state,
            tracer,
            s_4176_0,
            s_4176_1,
            s_4176_2,
            s_4176_3,
            s_4176_4,
            s_4176_5,
            s_4176_6,
        );
        // N s_4176_8: return
        return;
    }
    fn block_4177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4177_0: read-var opc2:u8
        let s_4177_0: u8 = fn_state.opc2;
        // D s_4177_1: cast zx s_4177_0 -> bv
        let s_4177_1: Bits = Bits::new(s_4177_0 as u128, 3u16);
        // C s_4177_2: const #1u : u8
        let s_4177_2: u8 = 1;
        // C s_4177_3: cast zx s_4177_2 -> bv
        let s_4177_3: Bits = Bits::new(s_4177_2 as u128, 3u16);
        // D s_4177_4: cmp-eq s_4177_1 s_4177_3
        let s_4177_4: bool = ((s_4177_1) == (s_4177_3));
        // D s_4177_5: write-var gs#118743 <= s_4177_4
        fn_state.gs_118743 = s_4177_4;
        // N s_4177_6: jump b2690
        return block_2690(state, tracer, fn_state);
    }
    fn block_4178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4178_0: read-var opc1:u8
        let s_4178_0: u8 = fn_state.opc1;
        // D s_4178_1: cast zx s_4178_0 -> bv
        let s_4178_1: Bits = Bits::new(s_4178_0 as u128, 3u16);
        // C s_4178_2: const #0u : u8
        let s_4178_2: u8 = 0;
        // C s_4178_3: cast zx s_4178_2 -> bv
        let s_4178_3: Bits = Bits::new(s_4178_2 as u128, 3u16);
        // D s_4178_4: cmp-eq s_4178_1 s_4178_3
        let s_4178_4: bool = ((s_4178_1) == (s_4178_3));
        // D s_4178_5: write-var gs#118742 <= s_4178_4
        fn_state.gs_118742 = s_4178_4;
        // N s_4178_6: jump b2688
        return block_2688(state, tracer, fn_state);
    }
    fn block_4179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4179_0: read-var coproc:u8
        let s_4179_0: u8 = fn_state.coproc;
        // D s_4179_1: cast zx s_4179_0 -> bv
        let s_4179_1: Bits = Bits::new(s_4179_0 as u128, 4u16);
        // C s_4179_2: const #15u : u8
        let s_4179_2: u8 = 15;
        // C s_4179_3: cast zx s_4179_2 -> bv
        let s_4179_3: Bits = Bits::new(s_4179_2 as u128, 4u16);
        // D s_4179_4: cmp-eq s_4179_1 s_4179_3
        let s_4179_4: bool = ((s_4179_1) == (s_4179_3));
        // D s_4179_5: write-var gs#118741 <= s_4179_4
        fn_state.gs_118741 = s_4179_4;
        // N s_4179_6: jump b2686
        return block_2686(state, tracer, fn_state);
    }
    fn block_4180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4180_0: read-var CRn:u8
        let s_4180_0: u8 = fn_state.CRn;
        // D s_4180_1: cast zx s_4180_0 -> bv
        let s_4180_1: Bits = Bits::new(s_4180_0 as u128, 4u16);
        // C s_4180_2: const #14u : u8
        let s_4180_2: u8 = 14;
        // C s_4180_3: cast zx s_4180_2 -> bv
        let s_4180_3: Bits = Bits::new(s_4180_2 as u128, 4u16);
        // D s_4180_4: cmp-eq s_4180_1 s_4180_3
        let s_4180_4: bool = ((s_4180_1) == (s_4180_3));
        // D s_4180_5: write-var gs#118740 <= s_4180_4
        fn_state.gs_118740 = s_4180_4;
        // N s_4180_6: jump b2684
        return block_2684(state, tracer, fn_state);
    }
    fn block_4181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4181_0: read-var el:u8
        let s_4181_0: u8 = fn_state.el;
        // D s_4181_1: read-var coproc:u8
        let s_4181_1: u8 = fn_state.coproc;
        // D s_4181_2: read-var opc1:u8
        let s_4181_2: u8 = fn_state.opc1;
        // D s_4181_3: read-var CRn:u8
        let s_4181_3: u8 = fn_state.CRn;
        // D s_4181_4: read-var opc2:u8
        let s_4181_4: u8 = fn_state.opc2;
        // D s_4181_5: read-var CRm:u8
        let s_4181_5: u8 = fn_state.CRm;
        // D s_4181_6: read-var t:i
        let s_4181_6: i128 = fn_state.t;
        // D s_4181_7: call PMEVTYPER_SysRegRead32_787de500d1f2ae74(s_4181_0, s_4181_1, s_4181_2, s_4181_3, s_4181_4, s_4181_5, s_4181_6)
        let s_4181_7: () = PMEVTYPER_SysRegRead32_787de500d1f2ae74(
            state,
            tracer,
            s_4181_0,
            s_4181_1,
            s_4181_2,
            s_4181_3,
            s_4181_4,
            s_4181_5,
            s_4181_6,
        );
        // N s_4181_8: return
        return;
    }
    fn block_4182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4182_0: read-var opc2:u8
        let s_4182_0: u8 = fn_state.opc2;
        // D s_4182_1: cast zx s_4182_0 -> bv
        let s_4182_1: Bits = Bits::new(s_4182_0 as u128, 3u16);
        // C s_4182_2: const #2u : u8
        let s_4182_2: u8 = 2;
        // C s_4182_3: cast zx s_4182_2 -> bv
        let s_4182_3: Bits = Bits::new(s_4182_2 as u128, 3u16);
        // D s_4182_4: cmp-eq s_4182_1 s_4182_3
        let s_4182_4: bool = ((s_4182_1) == (s_4182_3));
        // D s_4182_5: write-var gs#118739 <= s_4182_4
        fn_state.gs_118739 = s_4182_4;
        // N s_4182_6: jump b2681
        return block_2681(state, tracer, fn_state);
    }
    fn block_4183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4183_0: read-var opc1:u8
        let s_4183_0: u8 = fn_state.opc1;
        // D s_4183_1: cast zx s_4183_0 -> bv
        let s_4183_1: Bits = Bits::new(s_4183_0 as u128, 3u16);
        // C s_4183_2: const #0u : u8
        let s_4183_2: u8 = 0;
        // C s_4183_3: cast zx s_4183_2 -> bv
        let s_4183_3: Bits = Bits::new(s_4183_2 as u128, 3u16);
        // D s_4183_4: cmp-eq s_4183_1 s_4183_3
        let s_4183_4: bool = ((s_4183_1) == (s_4183_3));
        // D s_4183_5: write-var gs#118738 <= s_4183_4
        fn_state.gs_118738 = s_4183_4;
        // N s_4183_6: jump b2679
        return block_2679(state, tracer, fn_state);
    }
    fn block_4184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4184_0: read-var coproc:u8
        let s_4184_0: u8 = fn_state.coproc;
        // D s_4184_1: cast zx s_4184_0 -> bv
        let s_4184_1: Bits = Bits::new(s_4184_0 as u128, 4u16);
        // C s_4184_2: const #15u : u8
        let s_4184_2: u8 = 15;
        // C s_4184_3: cast zx s_4184_2 -> bv
        let s_4184_3: Bits = Bits::new(s_4184_2 as u128, 4u16);
        // D s_4184_4: cmp-eq s_4184_1 s_4184_3
        let s_4184_4: bool = ((s_4184_1) == (s_4184_3));
        // D s_4184_5: write-var gs#118737 <= s_4184_4
        fn_state.gs_118737 = s_4184_4;
        // N s_4184_6: jump b2677
        return block_2677(state, tracer, fn_state);
    }
    fn block_4185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4185_0: read-var CRn:u8
        let s_4185_0: u8 = fn_state.CRn;
        // D s_4185_1: cast zx s_4185_0 -> bv
        let s_4185_1: Bits = Bits::new(s_4185_0 as u128, 4u16);
        // C s_4185_2: const #14u : u8
        let s_4185_2: u8 = 14;
        // C s_4185_3: cast zx s_4185_2 -> bv
        let s_4185_3: Bits = Bits::new(s_4185_2 as u128, 4u16);
        // D s_4185_4: cmp-eq s_4185_1 s_4185_3
        let s_4185_4: bool = ((s_4185_1) == (s_4185_3));
        // D s_4185_5: write-var gs#118736 <= s_4185_4
        fn_state.gs_118736 = s_4185_4;
        // N s_4185_6: jump b2675
        return block_2675(state, tracer, fn_state);
    }
    fn block_4186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4186_0: read-var el:u8
        let s_4186_0: u8 = fn_state.el;
        // D s_4186_1: read-var coproc:u8
        let s_4186_1: u8 = fn_state.coproc;
        // D s_4186_2: read-var opc1:u8
        let s_4186_2: u8 = fn_state.opc1;
        // D s_4186_3: read-var CRn:u8
        let s_4186_3: u8 = fn_state.CRn;
        // D s_4186_4: read-var opc2:u8
        let s_4186_4: u8 = fn_state.opc2;
        // D s_4186_5: read-var CRm:u8
        let s_4186_5: u8 = fn_state.CRm;
        // D s_4186_6: read-var t:i
        let s_4186_6: i128 = fn_state.t;
        // D s_4186_7: call PMEVTYPER_SysRegRead32_345e68f734e8d287(s_4186_0, s_4186_1, s_4186_2, s_4186_3, s_4186_4, s_4186_5, s_4186_6)
        let s_4186_7: () = PMEVTYPER_SysRegRead32_345e68f734e8d287(
            state,
            tracer,
            s_4186_0,
            s_4186_1,
            s_4186_2,
            s_4186_3,
            s_4186_4,
            s_4186_5,
            s_4186_6,
        );
        // N s_4186_8: return
        return;
    }
    fn block_4187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4187_0: read-var opc2:u8
        let s_4187_0: u8 = fn_state.opc2;
        // D s_4187_1: cast zx s_4187_0 -> bv
        let s_4187_1: Bits = Bits::new(s_4187_0 as u128, 3u16);
        // C s_4187_2: const #3u : u8
        let s_4187_2: u8 = 3;
        // C s_4187_3: cast zx s_4187_2 -> bv
        let s_4187_3: Bits = Bits::new(s_4187_2 as u128, 3u16);
        // D s_4187_4: cmp-eq s_4187_1 s_4187_3
        let s_4187_4: bool = ((s_4187_1) == (s_4187_3));
        // D s_4187_5: write-var gs#118735 <= s_4187_4
        fn_state.gs_118735 = s_4187_4;
        // N s_4187_6: jump b2672
        return block_2672(state, tracer, fn_state);
    }
    fn block_4188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4188_0: read-var opc1:u8
        let s_4188_0: u8 = fn_state.opc1;
        // D s_4188_1: cast zx s_4188_0 -> bv
        let s_4188_1: Bits = Bits::new(s_4188_0 as u128, 3u16);
        // C s_4188_2: const #0u : u8
        let s_4188_2: u8 = 0;
        // C s_4188_3: cast zx s_4188_2 -> bv
        let s_4188_3: Bits = Bits::new(s_4188_2 as u128, 3u16);
        // D s_4188_4: cmp-eq s_4188_1 s_4188_3
        let s_4188_4: bool = ((s_4188_1) == (s_4188_3));
        // D s_4188_5: write-var gs#118734 <= s_4188_4
        fn_state.gs_118734 = s_4188_4;
        // N s_4188_6: jump b2670
        return block_2670(state, tracer, fn_state);
    }
    fn block_4189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4189_0: read-var coproc:u8
        let s_4189_0: u8 = fn_state.coproc;
        // D s_4189_1: cast zx s_4189_0 -> bv
        let s_4189_1: Bits = Bits::new(s_4189_0 as u128, 4u16);
        // C s_4189_2: const #15u : u8
        let s_4189_2: u8 = 15;
        // C s_4189_3: cast zx s_4189_2 -> bv
        let s_4189_3: Bits = Bits::new(s_4189_2 as u128, 4u16);
        // D s_4189_4: cmp-eq s_4189_1 s_4189_3
        let s_4189_4: bool = ((s_4189_1) == (s_4189_3));
        // D s_4189_5: write-var gs#118733 <= s_4189_4
        fn_state.gs_118733 = s_4189_4;
        // N s_4189_6: jump b2668
        return block_2668(state, tracer, fn_state);
    }
    fn block_4190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4190_0: read-var CRn:u8
        let s_4190_0: u8 = fn_state.CRn;
        // D s_4190_1: cast zx s_4190_0 -> bv
        let s_4190_1: Bits = Bits::new(s_4190_0 as u128, 4u16);
        // C s_4190_2: const #14u : u8
        let s_4190_2: u8 = 14;
        // C s_4190_3: cast zx s_4190_2 -> bv
        let s_4190_3: Bits = Bits::new(s_4190_2 as u128, 4u16);
        // D s_4190_4: cmp-eq s_4190_1 s_4190_3
        let s_4190_4: bool = ((s_4190_1) == (s_4190_3));
        // D s_4190_5: write-var gs#118732 <= s_4190_4
        fn_state.gs_118732 = s_4190_4;
        // N s_4190_6: jump b2666
        return block_2666(state, tracer, fn_state);
    }
    fn block_4191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4191_0: read-var el:u8
        let s_4191_0: u8 = fn_state.el;
        // D s_4191_1: read-var coproc:u8
        let s_4191_1: u8 = fn_state.coproc;
        // D s_4191_2: read-var opc1:u8
        let s_4191_2: u8 = fn_state.opc1;
        // D s_4191_3: read-var CRn:u8
        let s_4191_3: u8 = fn_state.CRn;
        // D s_4191_4: read-var opc2:u8
        let s_4191_4: u8 = fn_state.opc2;
        // D s_4191_5: read-var CRm:u8
        let s_4191_5: u8 = fn_state.CRm;
        // D s_4191_6: read-var t:i
        let s_4191_6: i128 = fn_state.t;
        // D s_4191_7: call PMEVTYPER_SysRegRead32_b74d04d561403857(s_4191_0, s_4191_1, s_4191_2, s_4191_3, s_4191_4, s_4191_5, s_4191_6)
        let s_4191_7: () = PMEVTYPER_SysRegRead32_b74d04d561403857(
            state,
            tracer,
            s_4191_0,
            s_4191_1,
            s_4191_2,
            s_4191_3,
            s_4191_4,
            s_4191_5,
            s_4191_6,
        );
        // N s_4191_8: return
        return;
    }
    fn block_4192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4192_0: read-var opc2:u8
        let s_4192_0: u8 = fn_state.opc2;
        // D s_4192_1: cast zx s_4192_0 -> bv
        let s_4192_1: Bits = Bits::new(s_4192_0 as u128, 3u16);
        // C s_4192_2: const #4u : u8
        let s_4192_2: u8 = 4;
        // C s_4192_3: cast zx s_4192_2 -> bv
        let s_4192_3: Bits = Bits::new(s_4192_2 as u128, 3u16);
        // D s_4192_4: cmp-eq s_4192_1 s_4192_3
        let s_4192_4: bool = ((s_4192_1) == (s_4192_3));
        // D s_4192_5: write-var gs#118731 <= s_4192_4
        fn_state.gs_118731 = s_4192_4;
        // N s_4192_6: jump b2663
        return block_2663(state, tracer, fn_state);
    }
    fn block_4193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4193_0: read-var opc1:u8
        let s_4193_0: u8 = fn_state.opc1;
        // D s_4193_1: cast zx s_4193_0 -> bv
        let s_4193_1: Bits = Bits::new(s_4193_0 as u128, 3u16);
        // C s_4193_2: const #0u : u8
        let s_4193_2: u8 = 0;
        // C s_4193_3: cast zx s_4193_2 -> bv
        let s_4193_3: Bits = Bits::new(s_4193_2 as u128, 3u16);
        // D s_4193_4: cmp-eq s_4193_1 s_4193_3
        let s_4193_4: bool = ((s_4193_1) == (s_4193_3));
        // D s_4193_5: write-var gs#118730 <= s_4193_4
        fn_state.gs_118730 = s_4193_4;
        // N s_4193_6: jump b2661
        return block_2661(state, tracer, fn_state);
    }
    fn block_4194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4194_0: read-var coproc:u8
        let s_4194_0: u8 = fn_state.coproc;
        // D s_4194_1: cast zx s_4194_0 -> bv
        let s_4194_1: Bits = Bits::new(s_4194_0 as u128, 4u16);
        // C s_4194_2: const #15u : u8
        let s_4194_2: u8 = 15;
        // C s_4194_3: cast zx s_4194_2 -> bv
        let s_4194_3: Bits = Bits::new(s_4194_2 as u128, 4u16);
        // D s_4194_4: cmp-eq s_4194_1 s_4194_3
        let s_4194_4: bool = ((s_4194_1) == (s_4194_3));
        // D s_4194_5: write-var gs#118729 <= s_4194_4
        fn_state.gs_118729 = s_4194_4;
        // N s_4194_6: jump b2659
        return block_2659(state, tracer, fn_state);
    }
    fn block_4195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4195_0: read-var CRn:u8
        let s_4195_0: u8 = fn_state.CRn;
        // D s_4195_1: cast zx s_4195_0 -> bv
        let s_4195_1: Bits = Bits::new(s_4195_0 as u128, 4u16);
        // C s_4195_2: const #14u : u8
        let s_4195_2: u8 = 14;
        // C s_4195_3: cast zx s_4195_2 -> bv
        let s_4195_3: Bits = Bits::new(s_4195_2 as u128, 4u16);
        // D s_4195_4: cmp-eq s_4195_1 s_4195_3
        let s_4195_4: bool = ((s_4195_1) == (s_4195_3));
        // D s_4195_5: write-var gs#118728 <= s_4195_4
        fn_state.gs_118728 = s_4195_4;
        // N s_4195_6: jump b2657
        return block_2657(state, tracer, fn_state);
    }
    fn block_4196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4196_0: read-var el:u8
        let s_4196_0: u8 = fn_state.el;
        // D s_4196_1: read-var coproc:u8
        let s_4196_1: u8 = fn_state.coproc;
        // D s_4196_2: read-var opc1:u8
        let s_4196_2: u8 = fn_state.opc1;
        // D s_4196_3: read-var CRn:u8
        let s_4196_3: u8 = fn_state.CRn;
        // D s_4196_4: read-var opc2:u8
        let s_4196_4: u8 = fn_state.opc2;
        // D s_4196_5: read-var CRm:u8
        let s_4196_5: u8 = fn_state.CRm;
        // D s_4196_6: read-var t:i
        let s_4196_6: i128 = fn_state.t;
        // D s_4196_7: call PMEVTYPER_SysRegRead32_34d3c9683f50305a(s_4196_0, s_4196_1, s_4196_2, s_4196_3, s_4196_4, s_4196_5, s_4196_6)
        let s_4196_7: () = PMEVTYPER_SysRegRead32_34d3c9683f50305a(
            state,
            tracer,
            s_4196_0,
            s_4196_1,
            s_4196_2,
            s_4196_3,
            s_4196_4,
            s_4196_5,
            s_4196_6,
        );
        // N s_4196_8: return
        return;
    }
    fn block_4197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4197_0: read-var opc2:u8
        let s_4197_0: u8 = fn_state.opc2;
        // D s_4197_1: cast zx s_4197_0 -> bv
        let s_4197_1: Bits = Bits::new(s_4197_0 as u128, 3u16);
        // C s_4197_2: const #5u : u8
        let s_4197_2: u8 = 5;
        // C s_4197_3: cast zx s_4197_2 -> bv
        let s_4197_3: Bits = Bits::new(s_4197_2 as u128, 3u16);
        // D s_4197_4: cmp-eq s_4197_1 s_4197_3
        let s_4197_4: bool = ((s_4197_1) == (s_4197_3));
        // D s_4197_5: write-var gs#118727 <= s_4197_4
        fn_state.gs_118727 = s_4197_4;
        // N s_4197_6: jump b2654
        return block_2654(state, tracer, fn_state);
    }
    fn block_4198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4198_0: read-var opc1:u8
        let s_4198_0: u8 = fn_state.opc1;
        // D s_4198_1: cast zx s_4198_0 -> bv
        let s_4198_1: Bits = Bits::new(s_4198_0 as u128, 3u16);
        // C s_4198_2: const #0u : u8
        let s_4198_2: u8 = 0;
        // C s_4198_3: cast zx s_4198_2 -> bv
        let s_4198_3: Bits = Bits::new(s_4198_2 as u128, 3u16);
        // D s_4198_4: cmp-eq s_4198_1 s_4198_3
        let s_4198_4: bool = ((s_4198_1) == (s_4198_3));
        // D s_4198_5: write-var gs#118726 <= s_4198_4
        fn_state.gs_118726 = s_4198_4;
        // N s_4198_6: jump b2652
        return block_2652(state, tracer, fn_state);
    }
    fn block_4199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4199_0: read-var coproc:u8
        let s_4199_0: u8 = fn_state.coproc;
        // D s_4199_1: cast zx s_4199_0 -> bv
        let s_4199_1: Bits = Bits::new(s_4199_0 as u128, 4u16);
        // C s_4199_2: const #15u : u8
        let s_4199_2: u8 = 15;
        // C s_4199_3: cast zx s_4199_2 -> bv
        let s_4199_3: Bits = Bits::new(s_4199_2 as u128, 4u16);
        // D s_4199_4: cmp-eq s_4199_1 s_4199_3
        let s_4199_4: bool = ((s_4199_1) == (s_4199_3));
        // D s_4199_5: write-var gs#118725 <= s_4199_4
        fn_state.gs_118725 = s_4199_4;
        // N s_4199_6: jump b2650
        return block_2650(state, tracer, fn_state);
    }
    fn block_4200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4200_0: read-var CRn:u8
        let s_4200_0: u8 = fn_state.CRn;
        // D s_4200_1: cast zx s_4200_0 -> bv
        let s_4200_1: Bits = Bits::new(s_4200_0 as u128, 4u16);
        // C s_4200_2: const #14u : u8
        let s_4200_2: u8 = 14;
        // C s_4200_3: cast zx s_4200_2 -> bv
        let s_4200_3: Bits = Bits::new(s_4200_2 as u128, 4u16);
        // D s_4200_4: cmp-eq s_4200_1 s_4200_3
        let s_4200_4: bool = ((s_4200_1) == (s_4200_3));
        // D s_4200_5: write-var gs#118724 <= s_4200_4
        fn_state.gs_118724 = s_4200_4;
        // N s_4200_6: jump b2648
        return block_2648(state, tracer, fn_state);
    }
    fn block_4201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4201_0: read-var el:u8
        let s_4201_0: u8 = fn_state.el;
        // D s_4201_1: read-var coproc:u8
        let s_4201_1: u8 = fn_state.coproc;
        // D s_4201_2: read-var opc1:u8
        let s_4201_2: u8 = fn_state.opc1;
        // D s_4201_3: read-var CRn:u8
        let s_4201_3: u8 = fn_state.CRn;
        // D s_4201_4: read-var opc2:u8
        let s_4201_4: u8 = fn_state.opc2;
        // D s_4201_5: read-var CRm:u8
        let s_4201_5: u8 = fn_state.CRm;
        // D s_4201_6: read-var t:i
        let s_4201_6: i128 = fn_state.t;
        // D s_4201_7: call PMEVTYPER_SysRegRead32_33e8370847f18109(s_4201_0, s_4201_1, s_4201_2, s_4201_3, s_4201_4, s_4201_5, s_4201_6)
        let s_4201_7: () = PMEVTYPER_SysRegRead32_33e8370847f18109(
            state,
            tracer,
            s_4201_0,
            s_4201_1,
            s_4201_2,
            s_4201_3,
            s_4201_4,
            s_4201_5,
            s_4201_6,
        );
        // N s_4201_8: return
        return;
    }
    fn block_4202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4202_0: read-var opc2:u8
        let s_4202_0: u8 = fn_state.opc2;
        // D s_4202_1: cast zx s_4202_0 -> bv
        let s_4202_1: Bits = Bits::new(s_4202_0 as u128, 3u16);
        // C s_4202_2: const #6u : u8
        let s_4202_2: u8 = 6;
        // C s_4202_3: cast zx s_4202_2 -> bv
        let s_4202_3: Bits = Bits::new(s_4202_2 as u128, 3u16);
        // D s_4202_4: cmp-eq s_4202_1 s_4202_3
        let s_4202_4: bool = ((s_4202_1) == (s_4202_3));
        // D s_4202_5: write-var gs#118723 <= s_4202_4
        fn_state.gs_118723 = s_4202_4;
        // N s_4202_6: jump b2645
        return block_2645(state, tracer, fn_state);
    }
    fn block_4203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4203_0: read-var opc1:u8
        let s_4203_0: u8 = fn_state.opc1;
        // D s_4203_1: cast zx s_4203_0 -> bv
        let s_4203_1: Bits = Bits::new(s_4203_0 as u128, 3u16);
        // C s_4203_2: const #0u : u8
        let s_4203_2: u8 = 0;
        // C s_4203_3: cast zx s_4203_2 -> bv
        let s_4203_3: Bits = Bits::new(s_4203_2 as u128, 3u16);
        // D s_4203_4: cmp-eq s_4203_1 s_4203_3
        let s_4203_4: bool = ((s_4203_1) == (s_4203_3));
        // D s_4203_5: write-var gs#118722 <= s_4203_4
        fn_state.gs_118722 = s_4203_4;
        // N s_4203_6: jump b2643
        return block_2643(state, tracer, fn_state);
    }
    fn block_4204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4204_0: read-var coproc:u8
        let s_4204_0: u8 = fn_state.coproc;
        // D s_4204_1: cast zx s_4204_0 -> bv
        let s_4204_1: Bits = Bits::new(s_4204_0 as u128, 4u16);
        // C s_4204_2: const #15u : u8
        let s_4204_2: u8 = 15;
        // C s_4204_3: cast zx s_4204_2 -> bv
        let s_4204_3: Bits = Bits::new(s_4204_2 as u128, 4u16);
        // D s_4204_4: cmp-eq s_4204_1 s_4204_3
        let s_4204_4: bool = ((s_4204_1) == (s_4204_3));
        // D s_4204_5: write-var gs#118721 <= s_4204_4
        fn_state.gs_118721 = s_4204_4;
        // N s_4204_6: jump b2641
        return block_2641(state, tracer, fn_state);
    }
    fn block_4205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4205_0: read-var CRn:u8
        let s_4205_0: u8 = fn_state.CRn;
        // D s_4205_1: cast zx s_4205_0 -> bv
        let s_4205_1: Bits = Bits::new(s_4205_0 as u128, 4u16);
        // C s_4205_2: const #14u : u8
        let s_4205_2: u8 = 14;
        // C s_4205_3: cast zx s_4205_2 -> bv
        let s_4205_3: Bits = Bits::new(s_4205_2 as u128, 4u16);
        // D s_4205_4: cmp-eq s_4205_1 s_4205_3
        let s_4205_4: bool = ((s_4205_1) == (s_4205_3));
        // D s_4205_5: write-var gs#118720 <= s_4205_4
        fn_state.gs_118720 = s_4205_4;
        // N s_4205_6: jump b2639
        return block_2639(state, tracer, fn_state);
    }
    fn block_4206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4206_0: read-var el:u8
        let s_4206_0: u8 = fn_state.el;
        // D s_4206_1: read-var coproc:u8
        let s_4206_1: u8 = fn_state.coproc;
        // D s_4206_2: read-var opc1:u8
        let s_4206_2: u8 = fn_state.opc1;
        // D s_4206_3: read-var CRn:u8
        let s_4206_3: u8 = fn_state.CRn;
        // D s_4206_4: read-var opc2:u8
        let s_4206_4: u8 = fn_state.opc2;
        // D s_4206_5: read-var CRm:u8
        let s_4206_5: u8 = fn_state.CRm;
        // D s_4206_6: read-var t:i
        let s_4206_6: i128 = fn_state.t;
        // D s_4206_7: call VPIDR_SysRegRead32_4e4cbaa7ba154382(s_4206_0, s_4206_1, s_4206_2, s_4206_3, s_4206_4, s_4206_5, s_4206_6)
        let s_4206_7: () = VPIDR_SysRegRead32_4e4cbaa7ba154382(
            state,
            tracer,
            s_4206_0,
            s_4206_1,
            s_4206_2,
            s_4206_3,
            s_4206_4,
            s_4206_5,
            s_4206_6,
        );
        // N s_4206_8: return
        return;
    }
    fn block_4207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4207_0: read-var opc2:u8
        let s_4207_0: u8 = fn_state.opc2;
        // D s_4207_1: cast zx s_4207_0 -> bv
        let s_4207_1: Bits = Bits::new(s_4207_0 as u128, 3u16);
        // C s_4207_2: const #0u : u8
        let s_4207_2: u8 = 0;
        // C s_4207_3: cast zx s_4207_2 -> bv
        let s_4207_3: Bits = Bits::new(s_4207_2 as u128, 3u16);
        // D s_4207_4: cmp-eq s_4207_1 s_4207_3
        let s_4207_4: bool = ((s_4207_1) == (s_4207_3));
        // D s_4207_5: write-var gs#118719 <= s_4207_4
        fn_state.gs_118719 = s_4207_4;
        // N s_4207_6: jump b2636
        return block_2636(state, tracer, fn_state);
    }
    fn block_4208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4208_0: read-var opc1:u8
        let s_4208_0: u8 = fn_state.opc1;
        // D s_4208_1: cast zx s_4208_0 -> bv
        let s_4208_1: Bits = Bits::new(s_4208_0 as u128, 3u16);
        // C s_4208_2: const #4u : u8
        let s_4208_2: u8 = 4;
        // C s_4208_3: cast zx s_4208_2 -> bv
        let s_4208_3: Bits = Bits::new(s_4208_2 as u128, 3u16);
        // D s_4208_4: cmp-eq s_4208_1 s_4208_3
        let s_4208_4: bool = ((s_4208_1) == (s_4208_3));
        // D s_4208_5: write-var gs#118718 <= s_4208_4
        fn_state.gs_118718 = s_4208_4;
        // N s_4208_6: jump b2634
        return block_2634(state, tracer, fn_state);
    }
    fn block_4209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4209_0: read-var coproc:u8
        let s_4209_0: u8 = fn_state.coproc;
        // D s_4209_1: cast zx s_4209_0 -> bv
        let s_4209_1: Bits = Bits::new(s_4209_0 as u128, 4u16);
        // C s_4209_2: const #15u : u8
        let s_4209_2: u8 = 15;
        // C s_4209_3: cast zx s_4209_2 -> bv
        let s_4209_3: Bits = Bits::new(s_4209_2 as u128, 4u16);
        // D s_4209_4: cmp-eq s_4209_1 s_4209_3
        let s_4209_4: bool = ((s_4209_1) == (s_4209_3));
        // D s_4209_5: write-var gs#118717 <= s_4209_4
        fn_state.gs_118717 = s_4209_4;
        // N s_4209_6: jump b2632
        return block_2632(state, tracer, fn_state);
    }
    fn block_4210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4210_0: read-var CRn:u8
        let s_4210_0: u8 = fn_state.CRn;
        // D s_4210_1: cast zx s_4210_0 -> bv
        let s_4210_1: Bits = Bits::new(s_4210_0 as u128, 4u16);
        // C s_4210_2: const #0u : u8
        let s_4210_2: u8 = 0;
        // C s_4210_3: cast zx s_4210_2 -> bv
        let s_4210_3: Bits = Bits::new(s_4210_2 as u128, 4u16);
        // D s_4210_4: cmp-eq s_4210_1 s_4210_3
        let s_4210_4: bool = ((s_4210_1) == (s_4210_3));
        // D s_4210_5: write-var gs#118716 <= s_4210_4
        fn_state.gs_118716 = s_4210_4;
        // N s_4210_6: jump b2630
        return block_2630(state, tracer, fn_state);
    }
    fn block_4211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4211_0: read-var el:u8
        let s_4211_0: u8 = fn_state.el;
        // D s_4211_1: read-var coproc:u8
        let s_4211_1: u8 = fn_state.coproc;
        // D s_4211_2: read-var opc1:u8
        let s_4211_2: u8 = fn_state.opc1;
        // D s_4211_3: read-var CRn:u8
        let s_4211_3: u8 = fn_state.CRn;
        // D s_4211_4: read-var opc2:u8
        let s_4211_4: u8 = fn_state.opc2;
        // D s_4211_5: read-var CRm:u8
        let s_4211_5: u8 = fn_state.CRm;
        // D s_4211_6: read-var t:i
        let s_4211_6: i128 = fn_state.t;
        // D s_4211_7: call DBGDTRRXint_SysRegRead32_ce20085c05aae144(s_4211_0, s_4211_1, s_4211_2, s_4211_3, s_4211_4, s_4211_5, s_4211_6)
        let s_4211_7: () = DBGDTRRXint_SysRegRead32_ce20085c05aae144(
            state,
            tracer,
            s_4211_0,
            s_4211_1,
            s_4211_2,
            s_4211_3,
            s_4211_4,
            s_4211_5,
            s_4211_6,
        );
        // N s_4211_8: return
        return;
    }
    fn block_4212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4212_0: read-var opc2:u8
        let s_4212_0: u8 = fn_state.opc2;
        // D s_4212_1: cast zx s_4212_0 -> bv
        let s_4212_1: Bits = Bits::new(s_4212_0 as u128, 3u16);
        // C s_4212_2: const #0u : u8
        let s_4212_2: u8 = 0;
        // C s_4212_3: cast zx s_4212_2 -> bv
        let s_4212_3: Bits = Bits::new(s_4212_2 as u128, 3u16);
        // D s_4212_4: cmp-eq s_4212_1 s_4212_3
        let s_4212_4: bool = ((s_4212_1) == (s_4212_3));
        // D s_4212_5: write-var gs#118715 <= s_4212_4
        fn_state.gs_118715 = s_4212_4;
        // N s_4212_6: jump b2627
        return block_2627(state, tracer, fn_state);
    }
    fn block_4213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4213_0: read-var opc1:u8
        let s_4213_0: u8 = fn_state.opc1;
        // D s_4213_1: cast zx s_4213_0 -> bv
        let s_4213_1: Bits = Bits::new(s_4213_0 as u128, 3u16);
        // C s_4213_2: const #0u : u8
        let s_4213_2: u8 = 0;
        // C s_4213_3: cast zx s_4213_2 -> bv
        let s_4213_3: Bits = Bits::new(s_4213_2 as u128, 3u16);
        // D s_4213_4: cmp-eq s_4213_1 s_4213_3
        let s_4213_4: bool = ((s_4213_1) == (s_4213_3));
        // D s_4213_5: write-var gs#118714 <= s_4213_4
        fn_state.gs_118714 = s_4213_4;
        // N s_4213_6: jump b2625
        return block_2625(state, tracer, fn_state);
    }
    fn block_4214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4214_0: read-var coproc:u8
        let s_4214_0: u8 = fn_state.coproc;
        // D s_4214_1: cast zx s_4214_0 -> bv
        let s_4214_1: Bits = Bits::new(s_4214_0 as u128, 4u16);
        // C s_4214_2: const #14u : u8
        let s_4214_2: u8 = 14;
        // C s_4214_3: cast zx s_4214_2 -> bv
        let s_4214_3: Bits = Bits::new(s_4214_2 as u128, 4u16);
        // D s_4214_4: cmp-eq s_4214_1 s_4214_3
        let s_4214_4: bool = ((s_4214_1) == (s_4214_3));
        // D s_4214_5: write-var gs#118713 <= s_4214_4
        fn_state.gs_118713 = s_4214_4;
        // N s_4214_6: jump b2623
        return block_2623(state, tracer, fn_state);
    }
    fn block_4215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4215_0: read-var CRn:u8
        let s_4215_0: u8 = fn_state.CRn;
        // D s_4215_1: cast zx s_4215_0 -> bv
        let s_4215_1: Bits = Bits::new(s_4215_0 as u128, 4u16);
        // C s_4215_2: const #0u : u8
        let s_4215_2: u8 = 0;
        // C s_4215_3: cast zx s_4215_2 -> bv
        let s_4215_3: Bits = Bits::new(s_4215_2 as u128, 4u16);
        // D s_4215_4: cmp-eq s_4215_1 s_4215_3
        let s_4215_4: bool = ((s_4215_1) == (s_4215_3));
        // D s_4215_5: write-var gs#118712 <= s_4215_4
        fn_state.gs_118712 = s_4215_4;
        // N s_4215_6: jump b2621
        return block_2621(state, tracer, fn_state);
    }
    fn block_4216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4216_0: read-var el:u8
        let s_4216_0: u8 = fn_state.el;
        // D s_4216_1: read-var coproc:u8
        let s_4216_1: u8 = fn_state.coproc;
        // D s_4216_2: read-var opc1:u8
        let s_4216_2: u8 = fn_state.opc1;
        // D s_4216_3: read-var CRn:u8
        let s_4216_3: u8 = fn_state.CRn;
        // D s_4216_4: read-var opc2:u8
        let s_4216_4: u8 = fn_state.opc2;
        // D s_4216_5: read-var CRm:u8
        let s_4216_5: u8 = fn_state.CRm;
        // D s_4216_6: read-var t:i
        let s_4216_6: i128 = fn_state.t;
        // D s_4216_7: call HTRFCR_SysRegRead32_b1ffee03b0b71c5a(s_4216_0, s_4216_1, s_4216_2, s_4216_3, s_4216_4, s_4216_5, s_4216_6)
        let s_4216_7: () = HTRFCR_SysRegRead32_b1ffee03b0b71c5a(
            state,
            tracer,
            s_4216_0,
            s_4216_1,
            s_4216_2,
            s_4216_3,
            s_4216_4,
            s_4216_5,
            s_4216_6,
        );
        // N s_4216_8: return
        return;
    }
    fn block_4217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4217_0: read-var opc2:u8
        let s_4217_0: u8 = fn_state.opc2;
        // D s_4217_1: cast zx s_4217_0 -> bv
        let s_4217_1: Bits = Bits::new(s_4217_0 as u128, 3u16);
        // C s_4217_2: const #1u : u8
        let s_4217_2: u8 = 1;
        // C s_4217_3: cast zx s_4217_2 -> bv
        let s_4217_3: Bits = Bits::new(s_4217_2 as u128, 3u16);
        // D s_4217_4: cmp-eq s_4217_1 s_4217_3
        let s_4217_4: bool = ((s_4217_1) == (s_4217_3));
        // D s_4217_5: write-var gs#118711 <= s_4217_4
        fn_state.gs_118711 = s_4217_4;
        // N s_4217_6: jump b2618
        return block_2618(state, tracer, fn_state);
    }
    fn block_4218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4218_0: read-var opc1:u8
        let s_4218_0: u8 = fn_state.opc1;
        // D s_4218_1: cast zx s_4218_0 -> bv
        let s_4218_1: Bits = Bits::new(s_4218_0 as u128, 3u16);
        // C s_4218_2: const #4u : u8
        let s_4218_2: u8 = 4;
        // C s_4218_3: cast zx s_4218_2 -> bv
        let s_4218_3: Bits = Bits::new(s_4218_2 as u128, 3u16);
        // D s_4218_4: cmp-eq s_4218_1 s_4218_3
        let s_4218_4: bool = ((s_4218_1) == (s_4218_3));
        // D s_4218_5: write-var gs#118710 <= s_4218_4
        fn_state.gs_118710 = s_4218_4;
        // N s_4218_6: jump b2616
        return block_2616(state, tracer, fn_state);
    }
    fn block_4219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4219_0: read-var coproc:u8
        let s_4219_0: u8 = fn_state.coproc;
        // D s_4219_1: cast zx s_4219_0 -> bv
        let s_4219_1: Bits = Bits::new(s_4219_0 as u128, 4u16);
        // C s_4219_2: const #15u : u8
        let s_4219_2: u8 = 15;
        // C s_4219_3: cast zx s_4219_2 -> bv
        let s_4219_3: Bits = Bits::new(s_4219_2 as u128, 4u16);
        // D s_4219_4: cmp-eq s_4219_1 s_4219_3
        let s_4219_4: bool = ((s_4219_1) == (s_4219_3));
        // D s_4219_5: write-var gs#118709 <= s_4219_4
        fn_state.gs_118709 = s_4219_4;
        // N s_4219_6: jump b2614
        return block_2614(state, tracer, fn_state);
    }
    fn block_4220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4220_0: read-var CRn:u8
        let s_4220_0: u8 = fn_state.CRn;
        // D s_4220_1: cast zx s_4220_0 -> bv
        let s_4220_1: Bits = Bits::new(s_4220_0 as u128, 4u16);
        // C s_4220_2: const #1u : u8
        let s_4220_2: u8 = 1;
        // C s_4220_3: cast zx s_4220_2 -> bv
        let s_4220_3: Bits = Bits::new(s_4220_2 as u128, 4u16);
        // D s_4220_4: cmp-eq s_4220_1 s_4220_3
        let s_4220_4: bool = ((s_4220_1) == (s_4220_3));
        // D s_4220_5: write-var gs#118708 <= s_4220_4
        fn_state.gs_118708 = s_4220_4;
        // N s_4220_6: jump b2612
        return block_2612(state, tracer, fn_state);
    }
    fn block_4221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4221_0: read-var el:u8
        let s_4221_0: u8 = fn_state.el;
        // D s_4221_1: read-var coproc:u8
        let s_4221_1: u8 = fn_state.coproc;
        // D s_4221_2: read-var opc1:u8
        let s_4221_2: u8 = fn_state.opc1;
        // D s_4221_3: read-var CRn:u8
        let s_4221_3: u8 = fn_state.CRn;
        // D s_4221_4: read-var opc2:u8
        let s_4221_4: u8 = fn_state.opc2;
        // D s_4221_5: read-var CRm:u8
        let s_4221_5: u8 = fn_state.CRm;
        // D s_4221_6: read-var t:i
        let s_4221_6: i128 = fn_state.t;
        // D s_4221_7: call IFAR_SysRegRead32_22cba1cec07771af(s_4221_0, s_4221_1, s_4221_2, s_4221_3, s_4221_4, s_4221_5, s_4221_6)
        let s_4221_7: () = IFAR_SysRegRead32_22cba1cec07771af(
            state,
            tracer,
            s_4221_0,
            s_4221_1,
            s_4221_2,
            s_4221_3,
            s_4221_4,
            s_4221_5,
            s_4221_6,
        );
        // N s_4221_8: return
        return;
    }
    fn block_4222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4222_0: read-var opc2:u8
        let s_4222_0: u8 = fn_state.opc2;
        // D s_4222_1: cast zx s_4222_0 -> bv
        let s_4222_1: Bits = Bits::new(s_4222_0 as u128, 3u16);
        // C s_4222_2: const #2u : u8
        let s_4222_2: u8 = 2;
        // C s_4222_3: cast zx s_4222_2 -> bv
        let s_4222_3: Bits = Bits::new(s_4222_2 as u128, 3u16);
        // D s_4222_4: cmp-eq s_4222_1 s_4222_3
        let s_4222_4: bool = ((s_4222_1) == (s_4222_3));
        // D s_4222_5: write-var gs#118707 <= s_4222_4
        fn_state.gs_118707 = s_4222_4;
        // N s_4222_6: jump b2609
        return block_2609(state, tracer, fn_state);
    }
    fn block_4223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4223_0: read-var opc1:u8
        let s_4223_0: u8 = fn_state.opc1;
        // D s_4223_1: cast zx s_4223_0 -> bv
        let s_4223_1: Bits = Bits::new(s_4223_0 as u128, 3u16);
        // C s_4223_2: const #0u : u8
        let s_4223_2: u8 = 0;
        // C s_4223_3: cast zx s_4223_2 -> bv
        let s_4223_3: Bits = Bits::new(s_4223_2 as u128, 3u16);
        // D s_4223_4: cmp-eq s_4223_1 s_4223_3
        let s_4223_4: bool = ((s_4223_1) == (s_4223_3));
        // D s_4223_5: write-var gs#118706 <= s_4223_4
        fn_state.gs_118706 = s_4223_4;
        // N s_4223_6: jump b2607
        return block_2607(state, tracer, fn_state);
    }
    fn block_4224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4224_0: read-var coproc:u8
        let s_4224_0: u8 = fn_state.coproc;
        // D s_4224_1: cast zx s_4224_0 -> bv
        let s_4224_1: Bits = Bits::new(s_4224_0 as u128, 4u16);
        // C s_4224_2: const #15u : u8
        let s_4224_2: u8 = 15;
        // C s_4224_3: cast zx s_4224_2 -> bv
        let s_4224_3: Bits = Bits::new(s_4224_2 as u128, 4u16);
        // D s_4224_4: cmp-eq s_4224_1 s_4224_3
        let s_4224_4: bool = ((s_4224_1) == (s_4224_3));
        // D s_4224_5: write-var gs#118705 <= s_4224_4
        fn_state.gs_118705 = s_4224_4;
        // N s_4224_6: jump b2605
        return block_2605(state, tracer, fn_state);
    }
    fn block_4225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4225_0: read-var CRn:u8
        let s_4225_0: u8 = fn_state.CRn;
        // D s_4225_1: cast zx s_4225_0 -> bv
        let s_4225_1: Bits = Bits::new(s_4225_0 as u128, 4u16);
        // C s_4225_2: const #6u : u8
        let s_4225_2: u8 = 6;
        // C s_4225_3: cast zx s_4225_2 -> bv
        let s_4225_3: Bits = Bits::new(s_4225_2 as u128, 4u16);
        // D s_4225_4: cmp-eq s_4225_1 s_4225_3
        let s_4225_4: bool = ((s_4225_1) == (s_4225_3));
        // D s_4225_5: write-var gs#118704 <= s_4225_4
        fn_state.gs_118704 = s_4225_4;
        // N s_4225_6: jump b2603
        return block_2603(state, tracer, fn_state);
    }
    fn block_4226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4226_0: read-var el:u8
        let s_4226_0: u8 = fn_state.el;
        // D s_4226_1: read-var coproc:u8
        let s_4226_1: u8 = fn_state.coproc;
        // D s_4226_2: read-var opc1:u8
        let s_4226_2: u8 = fn_state.opc1;
        // D s_4226_3: read-var CRn:u8
        let s_4226_3: u8 = fn_state.CRn;
        // D s_4226_4: read-var opc2:u8
        let s_4226_4: u8 = fn_state.opc2;
        // D s_4226_5: read-var CRm:u8
        let s_4226_5: u8 = fn_state.CRm;
        // D s_4226_6: read-var t:i
        let s_4226_6: i128 = fn_state.t;
        // D s_4226_7: call TPIDRPRW_SysRegRead32_2042d633efa21064(s_4226_0, s_4226_1, s_4226_2, s_4226_3, s_4226_4, s_4226_5, s_4226_6)
        let s_4226_7: () = TPIDRPRW_SysRegRead32_2042d633efa21064(
            state,
            tracer,
            s_4226_0,
            s_4226_1,
            s_4226_2,
            s_4226_3,
            s_4226_4,
            s_4226_5,
            s_4226_6,
        );
        // N s_4226_8: return
        return;
    }
    fn block_4227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4227_0: read-var opc2:u8
        let s_4227_0: u8 = fn_state.opc2;
        // D s_4227_1: cast zx s_4227_0 -> bv
        let s_4227_1: Bits = Bits::new(s_4227_0 as u128, 3u16);
        // C s_4227_2: const #4u : u8
        let s_4227_2: u8 = 4;
        // C s_4227_3: cast zx s_4227_2 -> bv
        let s_4227_3: Bits = Bits::new(s_4227_2 as u128, 3u16);
        // D s_4227_4: cmp-eq s_4227_1 s_4227_3
        let s_4227_4: bool = ((s_4227_1) == (s_4227_3));
        // D s_4227_5: write-var gs#118703 <= s_4227_4
        fn_state.gs_118703 = s_4227_4;
        // N s_4227_6: jump b2600
        return block_2600(state, tracer, fn_state);
    }
    fn block_4228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4228_0: read-var opc1:u8
        let s_4228_0: u8 = fn_state.opc1;
        // D s_4228_1: cast zx s_4228_0 -> bv
        let s_4228_1: Bits = Bits::new(s_4228_0 as u128, 3u16);
        // C s_4228_2: const #0u : u8
        let s_4228_2: u8 = 0;
        // C s_4228_3: cast zx s_4228_2 -> bv
        let s_4228_3: Bits = Bits::new(s_4228_2 as u128, 3u16);
        // D s_4228_4: cmp-eq s_4228_1 s_4228_3
        let s_4228_4: bool = ((s_4228_1) == (s_4228_3));
        // D s_4228_5: write-var gs#118702 <= s_4228_4
        fn_state.gs_118702 = s_4228_4;
        // N s_4228_6: jump b2598
        return block_2598(state, tracer, fn_state);
    }
    fn block_4229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4229_0: read-var coproc:u8
        let s_4229_0: u8 = fn_state.coproc;
        // D s_4229_1: cast zx s_4229_0 -> bv
        let s_4229_1: Bits = Bits::new(s_4229_0 as u128, 4u16);
        // C s_4229_2: const #15u : u8
        let s_4229_2: u8 = 15;
        // C s_4229_3: cast zx s_4229_2 -> bv
        let s_4229_3: Bits = Bits::new(s_4229_2 as u128, 4u16);
        // D s_4229_4: cmp-eq s_4229_1 s_4229_3
        let s_4229_4: bool = ((s_4229_1) == (s_4229_3));
        // D s_4229_5: write-var gs#118701 <= s_4229_4
        fn_state.gs_118701 = s_4229_4;
        // N s_4229_6: jump b2596
        return block_2596(state, tracer, fn_state);
    }
    fn block_4230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4230_0: read-var CRn:u8
        let s_4230_0: u8 = fn_state.CRn;
        // D s_4230_1: cast zx s_4230_0 -> bv
        let s_4230_1: Bits = Bits::new(s_4230_0 as u128, 4u16);
        // C s_4230_2: const #13u : u8
        let s_4230_2: u8 = 13;
        // C s_4230_3: cast zx s_4230_2 -> bv
        let s_4230_3: Bits = Bits::new(s_4230_2 as u128, 4u16);
        // D s_4230_4: cmp-eq s_4230_1 s_4230_3
        let s_4230_4: bool = ((s_4230_1) == (s_4230_3));
        // D s_4230_5: write-var gs#118700 <= s_4230_4
        fn_state.gs_118700 = s_4230_4;
        // N s_4230_6: jump b2594
        return block_2594(state, tracer, fn_state);
    }
    fn block_4231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4231_0: read-var el:u8
        let s_4231_0: u8 = fn_state.el;
        // D s_4231_1: read-var coproc:u8
        let s_4231_1: u8 = fn_state.coproc;
        // D s_4231_2: read-var opc1:u8
        let s_4231_2: u8 = fn_state.opc1;
        // D s_4231_3: read-var CRn:u8
        let s_4231_3: u8 = fn_state.CRn;
        // D s_4231_4: read-var opc2:u8
        let s_4231_4: u8 = fn_state.opc2;
        // D s_4231_5: read-var CRm:u8
        let s_4231_5: u8 = fn_state.CRm;
        // D s_4231_6: read-var t:i
        let s_4231_6: i128 = fn_state.t;
        // D s_4231_7: call DBGDIDR_SysRegRead32_8ee636612218bdd3(s_4231_0, s_4231_1, s_4231_2, s_4231_3, s_4231_4, s_4231_5, s_4231_6)
        let s_4231_7: () = DBGDIDR_SysRegRead32_8ee636612218bdd3(
            state,
            tracer,
            s_4231_0,
            s_4231_1,
            s_4231_2,
            s_4231_3,
            s_4231_4,
            s_4231_5,
            s_4231_6,
        );
        // N s_4231_8: return
        return;
    }
    fn block_4232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4232_0: read-var opc2:u8
        let s_4232_0: u8 = fn_state.opc2;
        // D s_4232_1: cast zx s_4232_0 -> bv
        let s_4232_1: Bits = Bits::new(s_4232_0 as u128, 3u16);
        // C s_4232_2: const #0u : u8
        let s_4232_2: u8 = 0;
        // C s_4232_3: cast zx s_4232_2 -> bv
        let s_4232_3: Bits = Bits::new(s_4232_2 as u128, 3u16);
        // D s_4232_4: cmp-eq s_4232_1 s_4232_3
        let s_4232_4: bool = ((s_4232_1) == (s_4232_3));
        // D s_4232_5: write-var gs#118699 <= s_4232_4
        fn_state.gs_118699 = s_4232_4;
        // N s_4232_6: jump b2591
        return block_2591(state, tracer, fn_state);
    }
    fn block_4233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4233_0: read-var opc1:u8
        let s_4233_0: u8 = fn_state.opc1;
        // D s_4233_1: cast zx s_4233_0 -> bv
        let s_4233_1: Bits = Bits::new(s_4233_0 as u128, 3u16);
        // C s_4233_2: const #0u : u8
        let s_4233_2: u8 = 0;
        // C s_4233_3: cast zx s_4233_2 -> bv
        let s_4233_3: Bits = Bits::new(s_4233_2 as u128, 3u16);
        // D s_4233_4: cmp-eq s_4233_1 s_4233_3
        let s_4233_4: bool = ((s_4233_1) == (s_4233_3));
        // D s_4233_5: write-var gs#118698 <= s_4233_4
        fn_state.gs_118698 = s_4233_4;
        // N s_4233_6: jump b2589
        return block_2589(state, tracer, fn_state);
    }
    fn block_4234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4234_0: read-var coproc:u8
        let s_4234_0: u8 = fn_state.coproc;
        // D s_4234_1: cast zx s_4234_0 -> bv
        let s_4234_1: Bits = Bits::new(s_4234_0 as u128, 4u16);
        // C s_4234_2: const #14u : u8
        let s_4234_2: u8 = 14;
        // C s_4234_3: cast zx s_4234_2 -> bv
        let s_4234_3: Bits = Bits::new(s_4234_2 as u128, 4u16);
        // D s_4234_4: cmp-eq s_4234_1 s_4234_3
        let s_4234_4: bool = ((s_4234_1) == (s_4234_3));
        // D s_4234_5: write-var gs#118697 <= s_4234_4
        fn_state.gs_118697 = s_4234_4;
        // N s_4234_6: jump b2587
        return block_2587(state, tracer, fn_state);
    }
    fn block_4235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4235_0: read-var CRn:u8
        let s_4235_0: u8 = fn_state.CRn;
        // D s_4235_1: cast zx s_4235_0 -> bv
        let s_4235_1: Bits = Bits::new(s_4235_0 as u128, 4u16);
        // C s_4235_2: const #0u : u8
        let s_4235_2: u8 = 0;
        // C s_4235_3: cast zx s_4235_2 -> bv
        let s_4235_3: Bits = Bits::new(s_4235_2 as u128, 4u16);
        // D s_4235_4: cmp-eq s_4235_1 s_4235_3
        let s_4235_4: bool = ((s_4235_1) == (s_4235_3));
        // D s_4235_5: write-var gs#118696 <= s_4235_4
        fn_state.gs_118696 = s_4235_4;
        // N s_4235_6: jump b2585
        return block_2585(state, tracer, fn_state);
    }
    fn block_4236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4236_0: read-var el:u8
        let s_4236_0: u8 = fn_state.el;
        // D s_4236_1: read-var coproc:u8
        let s_4236_1: u8 = fn_state.coproc;
        // D s_4236_2: read-var opc1:u8
        let s_4236_2: u8 = fn_state.opc1;
        // D s_4236_3: read-var CRn:u8
        let s_4236_3: u8 = fn_state.CRn;
        // D s_4236_4: read-var opc2:u8
        let s_4236_4: u8 = fn_state.opc2;
        // D s_4236_5: read-var CRm:u8
        let s_4236_5: u8 = fn_state.CRm;
        // D s_4236_6: read-var t:i
        let s_4236_6: i128 = fn_state.t;
        // D s_4236_7: call MIDR_SysRegRead32_54aebb004f1db6c9(s_4236_0, s_4236_1, s_4236_2, s_4236_3, s_4236_4, s_4236_5, s_4236_6)
        let s_4236_7: () = MIDR_SysRegRead32_54aebb004f1db6c9(
            state,
            tracer,
            s_4236_0,
            s_4236_1,
            s_4236_2,
            s_4236_3,
            s_4236_4,
            s_4236_5,
            s_4236_6,
        );
        // N s_4236_8: return
        return;
    }
    fn block_4237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4237_0: read-var opc2:u8
        let s_4237_0: u8 = fn_state.opc2;
        // D s_4237_1: cast zx s_4237_0 -> bv
        let s_4237_1: Bits = Bits::new(s_4237_0 as u128, 3u16);
        // C s_4237_2: const #0u : u8
        let s_4237_2: u8 = 0;
        // C s_4237_3: cast zx s_4237_2 -> bv
        let s_4237_3: Bits = Bits::new(s_4237_2 as u128, 3u16);
        // D s_4237_4: cmp-eq s_4237_1 s_4237_3
        let s_4237_4: bool = ((s_4237_1) == (s_4237_3));
        // D s_4237_5: write-var gs#118695 <= s_4237_4
        fn_state.gs_118695 = s_4237_4;
        // N s_4237_6: jump b2582
        return block_2582(state, tracer, fn_state);
    }
    fn block_4238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4238_0: read-var opc1:u8
        let s_4238_0: u8 = fn_state.opc1;
        // D s_4238_1: cast zx s_4238_0 -> bv
        let s_4238_1: Bits = Bits::new(s_4238_0 as u128, 3u16);
        // C s_4238_2: const #0u : u8
        let s_4238_2: u8 = 0;
        // C s_4238_3: cast zx s_4238_2 -> bv
        let s_4238_3: Bits = Bits::new(s_4238_2 as u128, 3u16);
        // D s_4238_4: cmp-eq s_4238_1 s_4238_3
        let s_4238_4: bool = ((s_4238_1) == (s_4238_3));
        // D s_4238_5: write-var gs#118694 <= s_4238_4
        fn_state.gs_118694 = s_4238_4;
        // N s_4238_6: jump b2580
        return block_2580(state, tracer, fn_state);
    }
    fn block_4239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4239_0: read-var coproc:u8
        let s_4239_0: u8 = fn_state.coproc;
        // D s_4239_1: cast zx s_4239_0 -> bv
        let s_4239_1: Bits = Bits::new(s_4239_0 as u128, 4u16);
        // C s_4239_2: const #15u : u8
        let s_4239_2: u8 = 15;
        // C s_4239_3: cast zx s_4239_2 -> bv
        let s_4239_3: Bits = Bits::new(s_4239_2 as u128, 4u16);
        // D s_4239_4: cmp-eq s_4239_1 s_4239_3
        let s_4239_4: bool = ((s_4239_1) == (s_4239_3));
        // D s_4239_5: write-var gs#118693 <= s_4239_4
        fn_state.gs_118693 = s_4239_4;
        // N s_4239_6: jump b2578
        return block_2578(state, tracer, fn_state);
    }
    fn block_4240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4240_0: read-var CRn:u8
        let s_4240_0: u8 = fn_state.CRn;
        // D s_4240_1: cast zx s_4240_0 -> bv
        let s_4240_1: Bits = Bits::new(s_4240_0 as u128, 4u16);
        // C s_4240_2: const #0u : u8
        let s_4240_2: u8 = 0;
        // C s_4240_3: cast zx s_4240_2 -> bv
        let s_4240_3: Bits = Bits::new(s_4240_2 as u128, 4u16);
        // D s_4240_4: cmp-eq s_4240_1 s_4240_3
        let s_4240_4: bool = ((s_4240_1) == (s_4240_3));
        // D s_4240_5: write-var gs#118692 <= s_4240_4
        fn_state.gs_118692 = s_4240_4;
        // N s_4240_6: jump b2576
        return block_2576(state, tracer, fn_state);
    }
    fn block_4241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4241_0: read-var el:u8
        let s_4241_0: u8 = fn_state.el;
        // D s_4241_1: read-var coproc:u8
        let s_4241_1: u8 = fn_state.coproc;
        // D s_4241_2: read-var opc1:u8
        let s_4241_2: u8 = fn_state.opc1;
        // D s_4241_3: read-var CRn:u8
        let s_4241_3: u8 = fn_state.CRn;
        // D s_4241_4: read-var opc2:u8
        let s_4241_4: u8 = fn_state.opc2;
        // D s_4241_5: read-var CRm:u8
        let s_4241_5: u8 = fn_state.CRm;
        // D s_4241_6: read-var t:i
        let s_4241_6: i128 = fn_state.t;
        // D s_4241_7: call HDFAR_SysRegRead32_b442fa1081ced0da(s_4241_0, s_4241_1, s_4241_2, s_4241_3, s_4241_4, s_4241_5, s_4241_6)
        let s_4241_7: () = HDFAR_SysRegRead32_b442fa1081ced0da(
            state,
            tracer,
            s_4241_0,
            s_4241_1,
            s_4241_2,
            s_4241_3,
            s_4241_4,
            s_4241_5,
            s_4241_6,
        );
        // N s_4241_8: return
        return;
    }
    fn block_4242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4242_0: read-var opc2:u8
        let s_4242_0: u8 = fn_state.opc2;
        // D s_4242_1: cast zx s_4242_0 -> bv
        let s_4242_1: Bits = Bits::new(s_4242_0 as u128, 3u16);
        // C s_4242_2: const #0u : u8
        let s_4242_2: u8 = 0;
        // C s_4242_3: cast zx s_4242_2 -> bv
        let s_4242_3: Bits = Bits::new(s_4242_2 as u128, 3u16);
        // D s_4242_4: cmp-eq s_4242_1 s_4242_3
        let s_4242_4: bool = ((s_4242_1) == (s_4242_3));
        // D s_4242_5: write-var gs#118691 <= s_4242_4
        fn_state.gs_118691 = s_4242_4;
        // N s_4242_6: jump b2573
        return block_2573(state, tracer, fn_state);
    }
    fn block_4243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4243_0: read-var opc1:u8
        let s_4243_0: u8 = fn_state.opc1;
        // D s_4243_1: cast zx s_4243_0 -> bv
        let s_4243_1: Bits = Bits::new(s_4243_0 as u128, 3u16);
        // C s_4243_2: const #4u : u8
        let s_4243_2: u8 = 4;
        // C s_4243_3: cast zx s_4243_2 -> bv
        let s_4243_3: Bits = Bits::new(s_4243_2 as u128, 3u16);
        // D s_4243_4: cmp-eq s_4243_1 s_4243_3
        let s_4243_4: bool = ((s_4243_1) == (s_4243_3));
        // D s_4243_5: write-var gs#118690 <= s_4243_4
        fn_state.gs_118690 = s_4243_4;
        // N s_4243_6: jump b2571
        return block_2571(state, tracer, fn_state);
    }
    fn block_4244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4244_0: read-var coproc:u8
        let s_4244_0: u8 = fn_state.coproc;
        // D s_4244_1: cast zx s_4244_0 -> bv
        let s_4244_1: Bits = Bits::new(s_4244_0 as u128, 4u16);
        // C s_4244_2: const #15u : u8
        let s_4244_2: u8 = 15;
        // C s_4244_3: cast zx s_4244_2 -> bv
        let s_4244_3: Bits = Bits::new(s_4244_2 as u128, 4u16);
        // D s_4244_4: cmp-eq s_4244_1 s_4244_3
        let s_4244_4: bool = ((s_4244_1) == (s_4244_3));
        // D s_4244_5: write-var gs#118689 <= s_4244_4
        fn_state.gs_118689 = s_4244_4;
        // N s_4244_6: jump b2569
        return block_2569(state, tracer, fn_state);
    }
    fn block_4245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4245_0: read-var CRn:u8
        let s_4245_0: u8 = fn_state.CRn;
        // D s_4245_1: cast zx s_4245_0 -> bv
        let s_4245_1: Bits = Bits::new(s_4245_0 as u128, 4u16);
        // C s_4245_2: const #6u : u8
        let s_4245_2: u8 = 6;
        // C s_4245_3: cast zx s_4245_2 -> bv
        let s_4245_3: Bits = Bits::new(s_4245_2 as u128, 4u16);
        // D s_4245_4: cmp-eq s_4245_1 s_4245_3
        let s_4245_4: bool = ((s_4245_1) == (s_4245_3));
        // D s_4245_5: write-var gs#118688 <= s_4245_4
        fn_state.gs_118688 = s_4245_4;
        // N s_4245_6: jump b2567
        return block_2567(state, tracer, fn_state);
    }
    fn block_4246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4246_0: read-var el:u8
        let s_4246_0: u8 = fn_state.el;
        // D s_4246_1: read-var coproc:u8
        let s_4246_1: u8 = fn_state.coproc;
        // D s_4246_2: read-var opc1:u8
        let s_4246_2: u8 = fn_state.opc1;
        // D s_4246_3: read-var CRn:u8
        let s_4246_3: u8 = fn_state.CRn;
        // D s_4246_4: read-var opc2:u8
        let s_4246_4: u8 = fn_state.opc2;
        // D s_4246_5: read-var CRm:u8
        let s_4246_5: u8 = fn_state.CRm;
        // D s_4246_6: read-var t:i
        let s_4246_6: i128 = fn_state.t;
        // D s_4246_7: call IFSR_SysRegRead32_20bacf70303447cc(s_4246_0, s_4246_1, s_4246_2, s_4246_3, s_4246_4, s_4246_5, s_4246_6)
        let s_4246_7: () = IFSR_SysRegRead32_20bacf70303447cc(
            state,
            tracer,
            s_4246_0,
            s_4246_1,
            s_4246_2,
            s_4246_3,
            s_4246_4,
            s_4246_5,
            s_4246_6,
        );
        // N s_4246_8: return
        return;
    }
    fn block_4247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4247_0: read-var opc2:u8
        let s_4247_0: u8 = fn_state.opc2;
        // D s_4247_1: cast zx s_4247_0 -> bv
        let s_4247_1: Bits = Bits::new(s_4247_0 as u128, 3u16);
        // C s_4247_2: const #1u : u8
        let s_4247_2: u8 = 1;
        // C s_4247_3: cast zx s_4247_2 -> bv
        let s_4247_3: Bits = Bits::new(s_4247_2 as u128, 3u16);
        // D s_4247_4: cmp-eq s_4247_1 s_4247_3
        let s_4247_4: bool = ((s_4247_1) == (s_4247_3));
        // D s_4247_5: write-var gs#118687 <= s_4247_4
        fn_state.gs_118687 = s_4247_4;
        // N s_4247_6: jump b2564
        return block_2564(state, tracer, fn_state);
    }
    fn block_4248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4248_0: read-var opc1:u8
        let s_4248_0: u8 = fn_state.opc1;
        // D s_4248_1: cast zx s_4248_0 -> bv
        let s_4248_1: Bits = Bits::new(s_4248_0 as u128, 3u16);
        // C s_4248_2: const #0u : u8
        let s_4248_2: u8 = 0;
        // C s_4248_3: cast zx s_4248_2 -> bv
        let s_4248_3: Bits = Bits::new(s_4248_2 as u128, 3u16);
        // D s_4248_4: cmp-eq s_4248_1 s_4248_3
        let s_4248_4: bool = ((s_4248_1) == (s_4248_3));
        // D s_4248_5: write-var gs#118686 <= s_4248_4
        fn_state.gs_118686 = s_4248_4;
        // N s_4248_6: jump b2562
        return block_2562(state, tracer, fn_state);
    }
    fn block_4249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4249_0: read-var coproc:u8
        let s_4249_0: u8 = fn_state.coproc;
        // D s_4249_1: cast zx s_4249_0 -> bv
        let s_4249_1: Bits = Bits::new(s_4249_0 as u128, 4u16);
        // C s_4249_2: const #15u : u8
        let s_4249_2: u8 = 15;
        // C s_4249_3: cast zx s_4249_2 -> bv
        let s_4249_3: Bits = Bits::new(s_4249_2 as u128, 4u16);
        // D s_4249_4: cmp-eq s_4249_1 s_4249_3
        let s_4249_4: bool = ((s_4249_1) == (s_4249_3));
        // D s_4249_5: write-var gs#118685 <= s_4249_4
        fn_state.gs_118685 = s_4249_4;
        // N s_4249_6: jump b2560
        return block_2560(state, tracer, fn_state);
    }
    fn block_4250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4250_0: read-var CRn:u8
        let s_4250_0: u8 = fn_state.CRn;
        // D s_4250_1: cast zx s_4250_0 -> bv
        let s_4250_1: Bits = Bits::new(s_4250_0 as u128, 4u16);
        // C s_4250_2: const #5u : u8
        let s_4250_2: u8 = 5;
        // C s_4250_3: cast zx s_4250_2 -> bv
        let s_4250_3: Bits = Bits::new(s_4250_2 as u128, 4u16);
        // D s_4250_4: cmp-eq s_4250_1 s_4250_3
        let s_4250_4: bool = ((s_4250_1) == (s_4250_3));
        // D s_4250_5: write-var gs#118684 <= s_4250_4
        fn_state.gs_118684 = s_4250_4;
        // N s_4250_6: jump b2558
        return block_2558(state, tracer, fn_state);
    }
    fn block_4251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4251_0: read-var el:u8
        let s_4251_0: u8 = fn_state.el;
        // D s_4251_1: read-var coproc:u8
        let s_4251_1: u8 = fn_state.coproc;
        // D s_4251_2: read-var opc1:u8
        let s_4251_2: u8 = fn_state.opc1;
        // D s_4251_3: read-var CRn:u8
        let s_4251_3: u8 = fn_state.CRn;
        // D s_4251_4: read-var opc2:u8
        let s_4251_4: u8 = fn_state.opc2;
        // D s_4251_5: read-var CRm:u8
        let s_4251_5: u8 = fn_state.CRm;
        // D s_4251_6: read-var t:i
        let s_4251_6: i128 = fn_state.t;
        // D s_4251_7: call DBGDSCRext_SysRegRead32_bbe7b972eea0caec(s_4251_0, s_4251_1, s_4251_2, s_4251_3, s_4251_4, s_4251_5, s_4251_6)
        let s_4251_7: () = DBGDSCRext_SysRegRead32_bbe7b972eea0caec(
            state,
            tracer,
            s_4251_0,
            s_4251_1,
            s_4251_2,
            s_4251_3,
            s_4251_4,
            s_4251_5,
            s_4251_6,
        );
        // N s_4251_8: return
        return;
    }
    fn block_4252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4252_0: read-var opc2:u8
        let s_4252_0: u8 = fn_state.opc2;
        // D s_4252_1: cast zx s_4252_0 -> bv
        let s_4252_1: Bits = Bits::new(s_4252_0 as u128, 3u16);
        // C s_4252_2: const #2u : u8
        let s_4252_2: u8 = 2;
        // C s_4252_3: cast zx s_4252_2 -> bv
        let s_4252_3: Bits = Bits::new(s_4252_2 as u128, 3u16);
        // D s_4252_4: cmp-eq s_4252_1 s_4252_3
        let s_4252_4: bool = ((s_4252_1) == (s_4252_3));
        // D s_4252_5: write-var gs#118683 <= s_4252_4
        fn_state.gs_118683 = s_4252_4;
        // N s_4252_6: jump b2555
        return block_2555(state, tracer, fn_state);
    }
    fn block_4253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4253_0: read-var opc1:u8
        let s_4253_0: u8 = fn_state.opc1;
        // D s_4253_1: cast zx s_4253_0 -> bv
        let s_4253_1: Bits = Bits::new(s_4253_0 as u128, 3u16);
        // C s_4253_2: const #0u : u8
        let s_4253_2: u8 = 0;
        // C s_4253_3: cast zx s_4253_2 -> bv
        let s_4253_3: Bits = Bits::new(s_4253_2 as u128, 3u16);
        // D s_4253_4: cmp-eq s_4253_1 s_4253_3
        let s_4253_4: bool = ((s_4253_1) == (s_4253_3));
        // D s_4253_5: write-var gs#118682 <= s_4253_4
        fn_state.gs_118682 = s_4253_4;
        // N s_4253_6: jump b2553
        return block_2553(state, tracer, fn_state);
    }
    fn block_4254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4254_0: read-var coproc:u8
        let s_4254_0: u8 = fn_state.coproc;
        // D s_4254_1: cast zx s_4254_0 -> bv
        let s_4254_1: Bits = Bits::new(s_4254_0 as u128, 4u16);
        // C s_4254_2: const #14u : u8
        let s_4254_2: u8 = 14;
        // C s_4254_3: cast zx s_4254_2 -> bv
        let s_4254_3: Bits = Bits::new(s_4254_2 as u128, 4u16);
        // D s_4254_4: cmp-eq s_4254_1 s_4254_3
        let s_4254_4: bool = ((s_4254_1) == (s_4254_3));
        // D s_4254_5: write-var gs#118681 <= s_4254_4
        fn_state.gs_118681 = s_4254_4;
        // N s_4254_6: jump b2551
        return block_2551(state, tracer, fn_state);
    }
    fn block_4255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4255_0: read-var CRn:u8
        let s_4255_0: u8 = fn_state.CRn;
        // D s_4255_1: cast zx s_4255_0 -> bv
        let s_4255_1: Bits = Bits::new(s_4255_0 as u128, 4u16);
        // C s_4255_2: const #0u : u8
        let s_4255_2: u8 = 0;
        // C s_4255_3: cast zx s_4255_2 -> bv
        let s_4255_3: Bits = Bits::new(s_4255_2 as u128, 4u16);
        // D s_4255_4: cmp-eq s_4255_1 s_4255_3
        let s_4255_4: bool = ((s_4255_1) == (s_4255_3));
        // D s_4255_5: write-var gs#118680 <= s_4255_4
        fn_state.gs_118680 = s_4255_4;
        // N s_4255_6: jump b2549
        return block_2549(state, tracer, fn_state);
    }
    fn block_4256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4256_0: read-var el:u8
        let s_4256_0: u8 = fn_state.el;
        // D s_4256_1: read-var coproc:u8
        let s_4256_1: u8 = fn_state.coproc;
        // D s_4256_2: read-var opc1:u8
        let s_4256_2: u8 = fn_state.opc1;
        // D s_4256_3: read-var CRn:u8
        let s_4256_3: u8 = fn_state.CRn;
        // D s_4256_4: read-var opc2:u8
        let s_4256_4: u8 = fn_state.opc2;
        // D s_4256_5: read-var CRm:u8
        let s_4256_5: u8 = fn_state.CRm;
        // D s_4256_6: read-var t:i
        let s_4256_6: i128 = fn_state.t;
        // D s_4256_7: call DBGDCCINT_SysRegRead32_ba602311e159b54c(s_4256_0, s_4256_1, s_4256_2, s_4256_3, s_4256_4, s_4256_5, s_4256_6)
        let s_4256_7: () = DBGDCCINT_SysRegRead32_ba602311e159b54c(
            state,
            tracer,
            s_4256_0,
            s_4256_1,
            s_4256_2,
            s_4256_3,
            s_4256_4,
            s_4256_5,
            s_4256_6,
        );
        // N s_4256_8: return
        return;
    }
    fn block_4257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4257_0: read-var opc2:u8
        let s_4257_0: u8 = fn_state.opc2;
        // D s_4257_1: cast zx s_4257_0 -> bv
        let s_4257_1: Bits = Bits::new(s_4257_0 as u128, 3u16);
        // C s_4257_2: const #0u : u8
        let s_4257_2: u8 = 0;
        // C s_4257_3: cast zx s_4257_2 -> bv
        let s_4257_3: Bits = Bits::new(s_4257_2 as u128, 3u16);
        // D s_4257_4: cmp-eq s_4257_1 s_4257_3
        let s_4257_4: bool = ((s_4257_1) == (s_4257_3));
        // D s_4257_5: write-var gs#118679 <= s_4257_4
        fn_state.gs_118679 = s_4257_4;
        // N s_4257_6: jump b2546
        return block_2546(state, tracer, fn_state);
    }
    fn block_4258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4258_0: read-var opc1:u8
        let s_4258_0: u8 = fn_state.opc1;
        // D s_4258_1: cast zx s_4258_0 -> bv
        let s_4258_1: Bits = Bits::new(s_4258_0 as u128, 3u16);
        // C s_4258_2: const #0u : u8
        let s_4258_2: u8 = 0;
        // C s_4258_3: cast zx s_4258_2 -> bv
        let s_4258_3: Bits = Bits::new(s_4258_2 as u128, 3u16);
        // D s_4258_4: cmp-eq s_4258_1 s_4258_3
        let s_4258_4: bool = ((s_4258_1) == (s_4258_3));
        // D s_4258_5: write-var gs#118678 <= s_4258_4
        fn_state.gs_118678 = s_4258_4;
        // N s_4258_6: jump b2544
        return block_2544(state, tracer, fn_state);
    }
    fn block_4259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4259_0: read-var coproc:u8
        let s_4259_0: u8 = fn_state.coproc;
        // D s_4259_1: cast zx s_4259_0 -> bv
        let s_4259_1: Bits = Bits::new(s_4259_0 as u128, 4u16);
        // C s_4259_2: const #14u : u8
        let s_4259_2: u8 = 14;
        // C s_4259_3: cast zx s_4259_2 -> bv
        let s_4259_3: Bits = Bits::new(s_4259_2 as u128, 4u16);
        // D s_4259_4: cmp-eq s_4259_1 s_4259_3
        let s_4259_4: bool = ((s_4259_1) == (s_4259_3));
        // D s_4259_5: write-var gs#118677 <= s_4259_4
        fn_state.gs_118677 = s_4259_4;
        // N s_4259_6: jump b2542
        return block_2542(state, tracer, fn_state);
    }
    fn block_4260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4260_0: read-var CRn:u8
        let s_4260_0: u8 = fn_state.CRn;
        // D s_4260_1: cast zx s_4260_0 -> bv
        let s_4260_1: Bits = Bits::new(s_4260_0 as u128, 4u16);
        // C s_4260_2: const #0u : u8
        let s_4260_2: u8 = 0;
        // C s_4260_3: cast zx s_4260_2 -> bv
        let s_4260_3: Bits = Bits::new(s_4260_2 as u128, 4u16);
        // D s_4260_4: cmp-eq s_4260_1 s_4260_3
        let s_4260_4: bool = ((s_4260_1) == (s_4260_3));
        // D s_4260_5: write-var gs#118676 <= s_4260_4
        fn_state.gs_118676 = s_4260_4;
        // N s_4260_6: jump b2540
        return block_2540(state, tracer, fn_state);
    }
    fn block_4261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4261_0: read-var el:u8
        let s_4261_0: u8 = fn_state.el;
        // D s_4261_1: read-var coproc:u8
        let s_4261_1: u8 = fn_state.coproc;
        // D s_4261_2: read-var opc1:u8
        let s_4261_2: u8 = fn_state.opc1;
        // D s_4261_3: read-var CRn:u8
        let s_4261_3: u8 = fn_state.CRn;
        // D s_4261_4: read-var opc2:u8
        let s_4261_4: u8 = fn_state.opc2;
        // D s_4261_5: read-var CRm:u8
        let s_4261_5: u8 = fn_state.CRm;
        // D s_4261_6: read-var t:i
        let s_4261_6: i128 = fn_state.t;
        // D s_4261_7: call DBGDSCRint_SysRegRead32_4d6240b644e5e8d8(s_4261_0, s_4261_1, s_4261_2, s_4261_3, s_4261_4, s_4261_5, s_4261_6)
        let s_4261_7: () = DBGDSCRint_SysRegRead32_4d6240b644e5e8d8(
            state,
            tracer,
            s_4261_0,
            s_4261_1,
            s_4261_2,
            s_4261_3,
            s_4261_4,
            s_4261_5,
            s_4261_6,
        );
        // N s_4261_8: return
        return;
    }
    fn block_4262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4262_0: read-var opc2:u8
        let s_4262_0: u8 = fn_state.opc2;
        // D s_4262_1: cast zx s_4262_0 -> bv
        let s_4262_1: Bits = Bits::new(s_4262_0 as u128, 3u16);
        // C s_4262_2: const #0u : u8
        let s_4262_2: u8 = 0;
        // C s_4262_3: cast zx s_4262_2 -> bv
        let s_4262_3: Bits = Bits::new(s_4262_2 as u128, 3u16);
        // D s_4262_4: cmp-eq s_4262_1 s_4262_3
        let s_4262_4: bool = ((s_4262_1) == (s_4262_3));
        // D s_4262_5: write-var gs#118675 <= s_4262_4
        fn_state.gs_118675 = s_4262_4;
        // N s_4262_6: jump b2537
        return block_2537(state, tracer, fn_state);
    }
    fn block_4263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4263_0: read-var opc1:u8
        let s_4263_0: u8 = fn_state.opc1;
        // D s_4263_1: cast zx s_4263_0 -> bv
        let s_4263_1: Bits = Bits::new(s_4263_0 as u128, 3u16);
        // C s_4263_2: const #0u : u8
        let s_4263_2: u8 = 0;
        // C s_4263_3: cast zx s_4263_2 -> bv
        let s_4263_3: Bits = Bits::new(s_4263_2 as u128, 3u16);
        // D s_4263_4: cmp-eq s_4263_1 s_4263_3
        let s_4263_4: bool = ((s_4263_1) == (s_4263_3));
        // D s_4263_5: write-var gs#118674 <= s_4263_4
        fn_state.gs_118674 = s_4263_4;
        // N s_4263_6: jump b2535
        return block_2535(state, tracer, fn_state);
    }
    fn block_4264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4264_0: read-var coproc:u8
        let s_4264_0: u8 = fn_state.coproc;
        // D s_4264_1: cast zx s_4264_0 -> bv
        let s_4264_1: Bits = Bits::new(s_4264_0 as u128, 4u16);
        // C s_4264_2: const #14u : u8
        let s_4264_2: u8 = 14;
        // C s_4264_3: cast zx s_4264_2 -> bv
        let s_4264_3: Bits = Bits::new(s_4264_2 as u128, 4u16);
        // D s_4264_4: cmp-eq s_4264_1 s_4264_3
        let s_4264_4: bool = ((s_4264_1) == (s_4264_3));
        // D s_4264_5: write-var gs#118673 <= s_4264_4
        fn_state.gs_118673 = s_4264_4;
        // N s_4264_6: jump b2533
        return block_2533(state, tracer, fn_state);
    }
    fn block_4265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4265_0: read-var CRn:u8
        let s_4265_0: u8 = fn_state.CRn;
        // D s_4265_1: cast zx s_4265_0 -> bv
        let s_4265_1: Bits = Bits::new(s_4265_0 as u128, 4u16);
        // C s_4265_2: const #0u : u8
        let s_4265_2: u8 = 0;
        // C s_4265_3: cast zx s_4265_2 -> bv
        let s_4265_3: Bits = Bits::new(s_4265_2 as u128, 4u16);
        // D s_4265_4: cmp-eq s_4265_1 s_4265_3
        let s_4265_4: bool = ((s_4265_1) == (s_4265_3));
        // D s_4265_5: write-var gs#118672 <= s_4265_4
        fn_state.gs_118672 = s_4265_4;
        // N s_4265_6: jump b2531
        return block_2531(state, tracer, fn_state);
    }
    fn block_4266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4266_0: read-var el:u8
        let s_4266_0: u8 = fn_state.el;
        // D s_4266_1: read-var coproc:u8
        let s_4266_1: u8 = fn_state.coproc;
        // D s_4266_2: read-var opc1:u8
        let s_4266_2: u8 = fn_state.opc1;
        // D s_4266_3: read-var CRn:u8
        let s_4266_3: u8 = fn_state.CRn;
        // D s_4266_4: read-var opc2:u8
        let s_4266_4: u8 = fn_state.opc2;
        // D s_4266_5: read-var CRm:u8
        let s_4266_5: u8 = fn_state.CRm;
        // D s_4266_6: read-var t:i
        let s_4266_6: i128 = fn_state.t;
        // D s_4266_7: call ID_PFR0_SysRegRead32_aa91a2f0748f31d4(s_4266_0, s_4266_1, s_4266_2, s_4266_3, s_4266_4, s_4266_5, s_4266_6)
        let s_4266_7: () = ID_PFR0_SysRegRead32_aa91a2f0748f31d4(
            state,
            tracer,
            s_4266_0,
            s_4266_1,
            s_4266_2,
            s_4266_3,
            s_4266_4,
            s_4266_5,
            s_4266_6,
        );
        // N s_4266_8: return
        return;
    }
    fn block_4267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4267_0: read-var opc2:u8
        let s_4267_0: u8 = fn_state.opc2;
        // D s_4267_1: cast zx s_4267_0 -> bv
        let s_4267_1: Bits = Bits::new(s_4267_0 as u128, 3u16);
        // C s_4267_2: const #0u : u8
        let s_4267_2: u8 = 0;
        // C s_4267_3: cast zx s_4267_2 -> bv
        let s_4267_3: Bits = Bits::new(s_4267_2 as u128, 3u16);
        // D s_4267_4: cmp-eq s_4267_1 s_4267_3
        let s_4267_4: bool = ((s_4267_1) == (s_4267_3));
        // D s_4267_5: write-var gs#118671 <= s_4267_4
        fn_state.gs_118671 = s_4267_4;
        // N s_4267_6: jump b2528
        return block_2528(state, tracer, fn_state);
    }
    fn block_4268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4268_0: read-var opc1:u8
        let s_4268_0: u8 = fn_state.opc1;
        // D s_4268_1: cast zx s_4268_0 -> bv
        let s_4268_1: Bits = Bits::new(s_4268_0 as u128, 3u16);
        // C s_4268_2: const #0u : u8
        let s_4268_2: u8 = 0;
        // C s_4268_3: cast zx s_4268_2 -> bv
        let s_4268_3: Bits = Bits::new(s_4268_2 as u128, 3u16);
        // D s_4268_4: cmp-eq s_4268_1 s_4268_3
        let s_4268_4: bool = ((s_4268_1) == (s_4268_3));
        // D s_4268_5: write-var gs#118670 <= s_4268_4
        fn_state.gs_118670 = s_4268_4;
        // N s_4268_6: jump b2526
        return block_2526(state, tracer, fn_state);
    }
    fn block_4269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4269_0: read-var coproc:u8
        let s_4269_0: u8 = fn_state.coproc;
        // D s_4269_1: cast zx s_4269_0 -> bv
        let s_4269_1: Bits = Bits::new(s_4269_0 as u128, 4u16);
        // C s_4269_2: const #15u : u8
        let s_4269_2: u8 = 15;
        // C s_4269_3: cast zx s_4269_2 -> bv
        let s_4269_3: Bits = Bits::new(s_4269_2 as u128, 4u16);
        // D s_4269_4: cmp-eq s_4269_1 s_4269_3
        let s_4269_4: bool = ((s_4269_1) == (s_4269_3));
        // D s_4269_5: write-var gs#118669 <= s_4269_4
        fn_state.gs_118669 = s_4269_4;
        // N s_4269_6: jump b2524
        return block_2524(state, tracer, fn_state);
    }
    fn block_4270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4270_0: read-var CRn:u8
        let s_4270_0: u8 = fn_state.CRn;
        // D s_4270_1: cast zx s_4270_0 -> bv
        let s_4270_1: Bits = Bits::new(s_4270_0 as u128, 4u16);
        // C s_4270_2: const #0u : u8
        let s_4270_2: u8 = 0;
        // C s_4270_3: cast zx s_4270_2 -> bv
        let s_4270_3: Bits = Bits::new(s_4270_2 as u128, 4u16);
        // D s_4270_4: cmp-eq s_4270_1 s_4270_3
        let s_4270_4: bool = ((s_4270_1) == (s_4270_3));
        // D s_4270_5: write-var gs#118668 <= s_4270_4
        fn_state.gs_118668 = s_4270_4;
        // N s_4270_6: jump b2522
        return block_2522(state, tracer, fn_state);
    }
    fn block_4271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4271_0: read-var el:u8
        let s_4271_0: u8 = fn_state.el;
        // D s_4271_1: read-var coproc:u8
        let s_4271_1: u8 = fn_state.coproc;
        // D s_4271_2: read-var opc1:u8
        let s_4271_2: u8 = fn_state.opc1;
        // D s_4271_3: read-var CRn:u8
        let s_4271_3: u8 = fn_state.CRn;
        // D s_4271_4: read-var opc2:u8
        let s_4271_4: u8 = fn_state.opc2;
        // D s_4271_5: read-var CRm:u8
        let s_4271_5: u8 = fn_state.CRm;
        // D s_4271_6: read-var t:i
        let s_4271_6: i128 = fn_state.t;
        // D s_4271_7: call SCTLR_SysRegRead32_e01eef2d08d9809d(s_4271_0, s_4271_1, s_4271_2, s_4271_3, s_4271_4, s_4271_5, s_4271_6)
        let s_4271_7: () = SCTLR_SysRegRead32_e01eef2d08d9809d(
            state,
            tracer,
            s_4271_0,
            s_4271_1,
            s_4271_2,
            s_4271_3,
            s_4271_4,
            s_4271_5,
            s_4271_6,
        );
        // N s_4271_8: return
        return;
    }
    fn block_4272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4272_0: read-var opc2:u8
        let s_4272_0: u8 = fn_state.opc2;
        // D s_4272_1: cast zx s_4272_0 -> bv
        let s_4272_1: Bits = Bits::new(s_4272_0 as u128, 3u16);
        // C s_4272_2: const #0u : u8
        let s_4272_2: u8 = 0;
        // C s_4272_3: cast zx s_4272_2 -> bv
        let s_4272_3: Bits = Bits::new(s_4272_2 as u128, 3u16);
        // D s_4272_4: cmp-eq s_4272_1 s_4272_3
        let s_4272_4: bool = ((s_4272_1) == (s_4272_3));
        // D s_4272_5: write-var gs#118667 <= s_4272_4
        fn_state.gs_118667 = s_4272_4;
        // N s_4272_6: jump b2519
        return block_2519(state, tracer, fn_state);
    }
    fn block_4273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4273_0: read-var opc1:u8
        let s_4273_0: u8 = fn_state.opc1;
        // D s_4273_1: cast zx s_4273_0 -> bv
        let s_4273_1: Bits = Bits::new(s_4273_0 as u128, 3u16);
        // C s_4273_2: const #0u : u8
        let s_4273_2: u8 = 0;
        // C s_4273_3: cast zx s_4273_2 -> bv
        let s_4273_3: Bits = Bits::new(s_4273_2 as u128, 3u16);
        // D s_4273_4: cmp-eq s_4273_1 s_4273_3
        let s_4273_4: bool = ((s_4273_1) == (s_4273_3));
        // D s_4273_5: write-var gs#118666 <= s_4273_4
        fn_state.gs_118666 = s_4273_4;
        // N s_4273_6: jump b2517
        return block_2517(state, tracer, fn_state);
    }
    fn block_4274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4274_0: read-var coproc:u8
        let s_4274_0: u8 = fn_state.coproc;
        // D s_4274_1: cast zx s_4274_0 -> bv
        let s_4274_1: Bits = Bits::new(s_4274_0 as u128, 4u16);
        // C s_4274_2: const #15u : u8
        let s_4274_2: u8 = 15;
        // C s_4274_3: cast zx s_4274_2 -> bv
        let s_4274_3: Bits = Bits::new(s_4274_2 as u128, 4u16);
        // D s_4274_4: cmp-eq s_4274_1 s_4274_3
        let s_4274_4: bool = ((s_4274_1) == (s_4274_3));
        // D s_4274_5: write-var gs#118665 <= s_4274_4
        fn_state.gs_118665 = s_4274_4;
        // N s_4274_6: jump b2515
        return block_2515(state, tracer, fn_state);
    }
    fn block_4275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4275_0: read-var CRn:u8
        let s_4275_0: u8 = fn_state.CRn;
        // D s_4275_1: cast zx s_4275_0 -> bv
        let s_4275_1: Bits = Bits::new(s_4275_0 as u128, 4u16);
        // C s_4275_2: const #1u : u8
        let s_4275_2: u8 = 1;
        // C s_4275_3: cast zx s_4275_2 -> bv
        let s_4275_3: Bits = Bits::new(s_4275_2 as u128, 4u16);
        // D s_4275_4: cmp-eq s_4275_1 s_4275_3
        let s_4275_4: bool = ((s_4275_1) == (s_4275_3));
        // D s_4275_5: write-var gs#118664 <= s_4275_4
        fn_state.gs_118664 = s_4275_4;
        // N s_4275_6: jump b2513
        return block_2513(state, tracer, fn_state);
    }
    fn block_4276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4276_0: read-var el:u8
        let s_4276_0: u8 = fn_state.el;
        // D s_4276_1: read-var coproc:u8
        let s_4276_1: u8 = fn_state.coproc;
        // D s_4276_2: read-var opc1:u8
        let s_4276_2: u8 = fn_state.opc1;
        // D s_4276_3: read-var CRn:u8
        let s_4276_3: u8 = fn_state.CRn;
        // D s_4276_4: read-var opc2:u8
        let s_4276_4: u8 = fn_state.opc2;
        // D s_4276_5: read-var CRm:u8
        let s_4276_5: u8 = fn_state.CRm;
        // D s_4276_6: read-var t:i
        let s_4276_6: i128 = fn_state.t;
        // D s_4276_7: call HAIFSR_SysRegRead32_6fddec5e27f03691(s_4276_0, s_4276_1, s_4276_2, s_4276_3, s_4276_4, s_4276_5, s_4276_6)
        let s_4276_7: () = HAIFSR_SysRegRead32_6fddec5e27f03691(
            state,
            tracer,
            s_4276_0,
            s_4276_1,
            s_4276_2,
            s_4276_3,
            s_4276_4,
            s_4276_5,
            s_4276_6,
        );
        // N s_4276_8: return
        return;
    }
    fn block_4277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4277_0: read-var opc2:u8
        let s_4277_0: u8 = fn_state.opc2;
        // D s_4277_1: cast zx s_4277_0 -> bv
        let s_4277_1: Bits = Bits::new(s_4277_0 as u128, 3u16);
        // C s_4277_2: const #1u : u8
        let s_4277_2: u8 = 1;
        // C s_4277_3: cast zx s_4277_2 -> bv
        let s_4277_3: Bits = Bits::new(s_4277_2 as u128, 3u16);
        // D s_4277_4: cmp-eq s_4277_1 s_4277_3
        let s_4277_4: bool = ((s_4277_1) == (s_4277_3));
        // D s_4277_5: write-var gs#118663 <= s_4277_4
        fn_state.gs_118663 = s_4277_4;
        // N s_4277_6: jump b2510
        return block_2510(state, tracer, fn_state);
    }
    fn block_4278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4278_0: read-var opc1:u8
        let s_4278_0: u8 = fn_state.opc1;
        // D s_4278_1: cast zx s_4278_0 -> bv
        let s_4278_1: Bits = Bits::new(s_4278_0 as u128, 3u16);
        // C s_4278_2: const #4u : u8
        let s_4278_2: u8 = 4;
        // C s_4278_3: cast zx s_4278_2 -> bv
        let s_4278_3: Bits = Bits::new(s_4278_2 as u128, 3u16);
        // D s_4278_4: cmp-eq s_4278_1 s_4278_3
        let s_4278_4: bool = ((s_4278_1) == (s_4278_3));
        // D s_4278_5: write-var gs#118662 <= s_4278_4
        fn_state.gs_118662 = s_4278_4;
        // N s_4278_6: jump b2508
        return block_2508(state, tracer, fn_state);
    }
    fn block_4279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4279_0: read-var coproc:u8
        let s_4279_0: u8 = fn_state.coproc;
        // D s_4279_1: cast zx s_4279_0 -> bv
        let s_4279_1: Bits = Bits::new(s_4279_0 as u128, 4u16);
        // C s_4279_2: const #15u : u8
        let s_4279_2: u8 = 15;
        // C s_4279_3: cast zx s_4279_2 -> bv
        let s_4279_3: Bits = Bits::new(s_4279_2 as u128, 4u16);
        // D s_4279_4: cmp-eq s_4279_1 s_4279_3
        let s_4279_4: bool = ((s_4279_1) == (s_4279_3));
        // D s_4279_5: write-var gs#118661 <= s_4279_4
        fn_state.gs_118661 = s_4279_4;
        // N s_4279_6: jump b2506
        return block_2506(state, tracer, fn_state);
    }
    fn block_4280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4280_0: read-var CRn:u8
        let s_4280_0: u8 = fn_state.CRn;
        // D s_4280_1: cast zx s_4280_0 -> bv
        let s_4280_1: Bits = Bits::new(s_4280_0 as u128, 4u16);
        // C s_4280_2: const #5u : u8
        let s_4280_2: u8 = 5;
        // C s_4280_3: cast zx s_4280_2 -> bv
        let s_4280_3: Bits = Bits::new(s_4280_2 as u128, 4u16);
        // D s_4280_4: cmp-eq s_4280_1 s_4280_3
        let s_4280_4: bool = ((s_4280_1) == (s_4280_3));
        // D s_4280_5: write-var gs#118660 <= s_4280_4
        fn_state.gs_118660 = s_4280_4;
        // N s_4280_6: jump b2504
        return block_2504(state, tracer, fn_state);
    }
    fn block_4281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4281_0: read-var el:u8
        let s_4281_0: u8 = fn_state.el;
        // D s_4281_1: read-var coproc:u8
        let s_4281_1: u8 = fn_state.coproc;
        // D s_4281_2: read-var opc1:u8
        let s_4281_2: u8 = fn_state.opc1;
        // D s_4281_3: read-var CRn:u8
        let s_4281_3: u8 = fn_state.CRn;
        // D s_4281_4: read-var opc2:u8
        let s_4281_4: u8 = fn_state.opc2;
        // D s_4281_5: read-var CRm:u8
        let s_4281_5: u8 = fn_state.CRm;
        // D s_4281_6: read-var t:i
        let s_4281_6: i128 = fn_state.t;
        // D s_4281_7: call ISR_SysRegRead32_6db4255755bcf0b1(s_4281_0, s_4281_1, s_4281_2, s_4281_3, s_4281_4, s_4281_5, s_4281_6)
        let s_4281_7: () = ISR_SysRegRead32_6db4255755bcf0b1(
            state,
            tracer,
            s_4281_0,
            s_4281_1,
            s_4281_2,
            s_4281_3,
            s_4281_4,
            s_4281_5,
            s_4281_6,
        );
        // N s_4281_8: return
        return;
    }
    fn block_4282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4282_0: read-var opc2:u8
        let s_4282_0: u8 = fn_state.opc2;
        // D s_4282_1: cast zx s_4282_0 -> bv
        let s_4282_1: Bits = Bits::new(s_4282_0 as u128, 3u16);
        // C s_4282_2: const #0u : u8
        let s_4282_2: u8 = 0;
        // C s_4282_3: cast zx s_4282_2 -> bv
        let s_4282_3: Bits = Bits::new(s_4282_2 as u128, 3u16);
        // D s_4282_4: cmp-eq s_4282_1 s_4282_3
        let s_4282_4: bool = ((s_4282_1) == (s_4282_3));
        // D s_4282_5: write-var gs#118659 <= s_4282_4
        fn_state.gs_118659 = s_4282_4;
        // N s_4282_6: jump b2501
        return block_2501(state, tracer, fn_state);
    }
    fn block_4283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4283_0: read-var opc1:u8
        let s_4283_0: u8 = fn_state.opc1;
        // D s_4283_1: cast zx s_4283_0 -> bv
        let s_4283_1: Bits = Bits::new(s_4283_0 as u128, 3u16);
        // C s_4283_2: const #0u : u8
        let s_4283_2: u8 = 0;
        // C s_4283_3: cast zx s_4283_2 -> bv
        let s_4283_3: Bits = Bits::new(s_4283_2 as u128, 3u16);
        // D s_4283_4: cmp-eq s_4283_1 s_4283_3
        let s_4283_4: bool = ((s_4283_1) == (s_4283_3));
        // D s_4283_5: write-var gs#118658 <= s_4283_4
        fn_state.gs_118658 = s_4283_4;
        // N s_4283_6: jump b2499
        return block_2499(state, tracer, fn_state);
    }
    fn block_4284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4284_0: read-var coproc:u8
        let s_4284_0: u8 = fn_state.coproc;
        // D s_4284_1: cast zx s_4284_0 -> bv
        let s_4284_1: Bits = Bits::new(s_4284_0 as u128, 4u16);
        // C s_4284_2: const #15u : u8
        let s_4284_2: u8 = 15;
        // C s_4284_3: cast zx s_4284_2 -> bv
        let s_4284_3: Bits = Bits::new(s_4284_2 as u128, 4u16);
        // D s_4284_4: cmp-eq s_4284_1 s_4284_3
        let s_4284_4: bool = ((s_4284_1) == (s_4284_3));
        // D s_4284_5: write-var gs#118657 <= s_4284_4
        fn_state.gs_118657 = s_4284_4;
        // N s_4284_6: jump b2497
        return block_2497(state, tracer, fn_state);
    }
    fn block_4285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4285_0: read-var CRn:u8
        let s_4285_0: u8 = fn_state.CRn;
        // D s_4285_1: cast zx s_4285_0 -> bv
        let s_4285_1: Bits = Bits::new(s_4285_0 as u128, 4u16);
        // C s_4285_2: const #12u : u8
        let s_4285_2: u8 = 12;
        // C s_4285_3: cast zx s_4285_2 -> bv
        let s_4285_3: Bits = Bits::new(s_4285_2 as u128, 4u16);
        // D s_4285_4: cmp-eq s_4285_1 s_4285_3
        let s_4285_4: bool = ((s_4285_1) == (s_4285_3));
        // D s_4285_5: write-var gs#118656 <= s_4285_4
        fn_state.gs_118656 = s_4285_4;
        // N s_4285_6: jump b2495
        return block_2495(state, tracer, fn_state);
    }
    fn block_4286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4286_0: read-var el:u8
        let s_4286_0: u8 = fn_state.el;
        // D s_4286_1: read-var coproc:u8
        let s_4286_1: u8 = fn_state.coproc;
        // D s_4286_2: read-var opc1:u8
        let s_4286_2: u8 = fn_state.opc1;
        // D s_4286_3: read-var CRn:u8
        let s_4286_3: u8 = fn_state.CRn;
        // D s_4286_4: read-var opc2:u8
        let s_4286_4: u8 = fn_state.opc2;
        // D s_4286_5: read-var CRm:u8
        let s_4286_5: u8 = fn_state.CRm;
        // D s_4286_6: read-var t:i
        let s_4286_6: i128 = fn_state.t;
        // D s_4286_7: call HAMAIR1_SysRegRead32_b4da9627c11c58d9(s_4286_0, s_4286_1, s_4286_2, s_4286_3, s_4286_4, s_4286_5, s_4286_6)
        let s_4286_7: () = HAMAIR1_SysRegRead32_b4da9627c11c58d9(
            state,
            tracer,
            s_4286_0,
            s_4286_1,
            s_4286_2,
            s_4286_3,
            s_4286_4,
            s_4286_5,
            s_4286_6,
        );
        // N s_4286_8: return
        return;
    }
    fn block_4287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4287_0: read-var opc2:u8
        let s_4287_0: u8 = fn_state.opc2;
        // D s_4287_1: cast zx s_4287_0 -> bv
        let s_4287_1: Bits = Bits::new(s_4287_0 as u128, 3u16);
        // C s_4287_2: const #1u : u8
        let s_4287_2: u8 = 1;
        // C s_4287_3: cast zx s_4287_2 -> bv
        let s_4287_3: Bits = Bits::new(s_4287_2 as u128, 3u16);
        // D s_4287_4: cmp-eq s_4287_1 s_4287_3
        let s_4287_4: bool = ((s_4287_1) == (s_4287_3));
        // D s_4287_5: write-var gs#118655 <= s_4287_4
        fn_state.gs_118655 = s_4287_4;
        // N s_4287_6: jump b2492
        return block_2492(state, tracer, fn_state);
    }
    fn block_4288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4288_0: read-var opc1:u8
        let s_4288_0: u8 = fn_state.opc1;
        // D s_4288_1: cast zx s_4288_0 -> bv
        let s_4288_1: Bits = Bits::new(s_4288_0 as u128, 3u16);
        // C s_4288_2: const #4u : u8
        let s_4288_2: u8 = 4;
        // C s_4288_3: cast zx s_4288_2 -> bv
        let s_4288_3: Bits = Bits::new(s_4288_2 as u128, 3u16);
        // D s_4288_4: cmp-eq s_4288_1 s_4288_3
        let s_4288_4: bool = ((s_4288_1) == (s_4288_3));
        // D s_4288_5: write-var gs#118654 <= s_4288_4
        fn_state.gs_118654 = s_4288_4;
        // N s_4288_6: jump b2490
        return block_2490(state, tracer, fn_state);
    }
    fn block_4289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4289_0: read-var coproc:u8
        let s_4289_0: u8 = fn_state.coproc;
        // D s_4289_1: cast zx s_4289_0 -> bv
        let s_4289_1: Bits = Bits::new(s_4289_0 as u128, 4u16);
        // C s_4289_2: const #15u : u8
        let s_4289_2: u8 = 15;
        // C s_4289_3: cast zx s_4289_2 -> bv
        let s_4289_3: Bits = Bits::new(s_4289_2 as u128, 4u16);
        // D s_4289_4: cmp-eq s_4289_1 s_4289_3
        let s_4289_4: bool = ((s_4289_1) == (s_4289_3));
        // D s_4289_5: write-var gs#118653 <= s_4289_4
        fn_state.gs_118653 = s_4289_4;
        // N s_4289_6: jump b2488
        return block_2488(state, tracer, fn_state);
    }
    fn block_4290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4290_0: read-var CRn:u8
        let s_4290_0: u8 = fn_state.CRn;
        // D s_4290_1: cast zx s_4290_0 -> bv
        let s_4290_1: Bits = Bits::new(s_4290_0 as u128, 4u16);
        // C s_4290_2: const #10u : u8
        let s_4290_2: u8 = 10;
        // C s_4290_3: cast zx s_4290_2 -> bv
        let s_4290_3: Bits = Bits::new(s_4290_2 as u128, 4u16);
        // D s_4290_4: cmp-eq s_4290_1 s_4290_3
        let s_4290_4: bool = ((s_4290_1) == (s_4290_3));
        // D s_4290_5: write-var gs#118652 <= s_4290_4
        fn_state.gs_118652 = s_4290_4;
        // N s_4290_6: jump b2486
        return block_2486(state, tracer, fn_state);
    }
    fn block_4291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4291_0: read-var el:u8
        let s_4291_0: u8 = fn_state.el;
        // D s_4291_1: read-var coproc:u8
        let s_4291_1: u8 = fn_state.coproc;
        // D s_4291_2: read-var opc1:u8
        let s_4291_2: u8 = fn_state.opc1;
        // D s_4291_3: read-var CRn:u8
        let s_4291_3: u8 = fn_state.CRn;
        // D s_4291_4: read-var opc2:u8
        let s_4291_4: u8 = fn_state.opc2;
        // D s_4291_5: read-var CRm:u8
        let s_4291_5: u8 = fn_state.CRm;
        // D s_4291_6: read-var t:i
        let s_4291_6: i128 = fn_state.t;
        // D s_4291_7: call ID_MMFR2_SysRegRead32_9a2dcb4cb3946cb0(s_4291_0, s_4291_1, s_4291_2, s_4291_3, s_4291_4, s_4291_5, s_4291_6)
        let s_4291_7: () = ID_MMFR2_SysRegRead32_9a2dcb4cb3946cb0(
            state,
            tracer,
            s_4291_0,
            s_4291_1,
            s_4291_2,
            s_4291_3,
            s_4291_4,
            s_4291_5,
            s_4291_6,
        );
        // N s_4291_8: return
        return;
    }
    fn block_4292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4292_0: read-var opc2:u8
        let s_4292_0: u8 = fn_state.opc2;
        // D s_4292_1: cast zx s_4292_0 -> bv
        let s_4292_1: Bits = Bits::new(s_4292_0 as u128, 3u16);
        // C s_4292_2: const #6u : u8
        let s_4292_2: u8 = 6;
        // C s_4292_3: cast zx s_4292_2 -> bv
        let s_4292_3: Bits = Bits::new(s_4292_2 as u128, 3u16);
        // D s_4292_4: cmp-eq s_4292_1 s_4292_3
        let s_4292_4: bool = ((s_4292_1) == (s_4292_3));
        // D s_4292_5: write-var gs#118651 <= s_4292_4
        fn_state.gs_118651 = s_4292_4;
        // N s_4292_6: jump b2483
        return block_2483(state, tracer, fn_state);
    }
    fn block_4293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4293_0: read-var opc1:u8
        let s_4293_0: u8 = fn_state.opc1;
        // D s_4293_1: cast zx s_4293_0 -> bv
        let s_4293_1: Bits = Bits::new(s_4293_0 as u128, 3u16);
        // C s_4293_2: const #0u : u8
        let s_4293_2: u8 = 0;
        // C s_4293_3: cast zx s_4293_2 -> bv
        let s_4293_3: Bits = Bits::new(s_4293_2 as u128, 3u16);
        // D s_4293_4: cmp-eq s_4293_1 s_4293_3
        let s_4293_4: bool = ((s_4293_1) == (s_4293_3));
        // D s_4293_5: write-var gs#118650 <= s_4293_4
        fn_state.gs_118650 = s_4293_4;
        // N s_4293_6: jump b2481
        return block_2481(state, tracer, fn_state);
    }
    fn block_4294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4294_0: read-var coproc:u8
        let s_4294_0: u8 = fn_state.coproc;
        // D s_4294_1: cast zx s_4294_0 -> bv
        let s_4294_1: Bits = Bits::new(s_4294_0 as u128, 4u16);
        // C s_4294_2: const #15u : u8
        let s_4294_2: u8 = 15;
        // C s_4294_3: cast zx s_4294_2 -> bv
        let s_4294_3: Bits = Bits::new(s_4294_2 as u128, 4u16);
        // D s_4294_4: cmp-eq s_4294_1 s_4294_3
        let s_4294_4: bool = ((s_4294_1) == (s_4294_3));
        // D s_4294_5: write-var gs#118649 <= s_4294_4
        fn_state.gs_118649 = s_4294_4;
        // N s_4294_6: jump b2479
        return block_2479(state, tracer, fn_state);
    }
    fn block_4295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4295_0: read-var CRn:u8
        let s_4295_0: u8 = fn_state.CRn;
        // D s_4295_1: cast zx s_4295_0 -> bv
        let s_4295_1: Bits = Bits::new(s_4295_0 as u128, 4u16);
        // C s_4295_2: const #0u : u8
        let s_4295_2: u8 = 0;
        // C s_4295_3: cast zx s_4295_2 -> bv
        let s_4295_3: Bits = Bits::new(s_4295_2 as u128, 4u16);
        // D s_4295_4: cmp-eq s_4295_1 s_4295_3
        let s_4295_4: bool = ((s_4295_1) == (s_4295_3));
        // D s_4295_5: write-var gs#118648 <= s_4295_4
        fn_state.gs_118648 = s_4295_4;
        // N s_4295_6: jump b2477
        return block_2477(state, tracer, fn_state);
    }
    fn block_4296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4296_0: read-var el:u8
        let s_4296_0: u8 = fn_state.el;
        // D s_4296_1: read-var coproc:u8
        let s_4296_1: u8 = fn_state.coproc;
        // D s_4296_2: read-var opc1:u8
        let s_4296_2: u8 = fn_state.opc1;
        // D s_4296_3: read-var CRn:u8
        let s_4296_3: u8 = fn_state.CRn;
        // D s_4296_4: read-var opc2:u8
        let s_4296_4: u8 = fn_state.opc2;
        // D s_4296_5: read-var CRm:u8
        let s_4296_5: u8 = fn_state.CRm;
        // D s_4296_6: read-var t:i
        let s_4296_6: i128 = fn_state.t;
        // D s_4296_7: call CPACR_SysRegRead32_3e95a711394f5115(s_4296_0, s_4296_1, s_4296_2, s_4296_3, s_4296_4, s_4296_5, s_4296_6)
        let s_4296_7: () = CPACR_SysRegRead32_3e95a711394f5115(
            state,
            tracer,
            s_4296_0,
            s_4296_1,
            s_4296_2,
            s_4296_3,
            s_4296_4,
            s_4296_5,
            s_4296_6,
        );
        // N s_4296_8: return
        return;
    }
    fn block_4297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4297_0: read-var opc2:u8
        let s_4297_0: u8 = fn_state.opc2;
        // D s_4297_1: cast zx s_4297_0 -> bv
        let s_4297_1: Bits = Bits::new(s_4297_0 as u128, 3u16);
        // C s_4297_2: const #2u : u8
        let s_4297_2: u8 = 2;
        // C s_4297_3: cast zx s_4297_2 -> bv
        let s_4297_3: Bits = Bits::new(s_4297_2 as u128, 3u16);
        // D s_4297_4: cmp-eq s_4297_1 s_4297_3
        let s_4297_4: bool = ((s_4297_1) == (s_4297_3));
        // D s_4297_5: write-var gs#118647 <= s_4297_4
        fn_state.gs_118647 = s_4297_4;
        // N s_4297_6: jump b2474
        return block_2474(state, tracer, fn_state);
    }
    fn block_4298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4298_0: read-var opc1:u8
        let s_4298_0: u8 = fn_state.opc1;
        // D s_4298_1: cast zx s_4298_0 -> bv
        let s_4298_1: Bits = Bits::new(s_4298_0 as u128, 3u16);
        // C s_4298_2: const #0u : u8
        let s_4298_2: u8 = 0;
        // C s_4298_3: cast zx s_4298_2 -> bv
        let s_4298_3: Bits = Bits::new(s_4298_2 as u128, 3u16);
        // D s_4298_4: cmp-eq s_4298_1 s_4298_3
        let s_4298_4: bool = ((s_4298_1) == (s_4298_3));
        // D s_4298_5: write-var gs#118646 <= s_4298_4
        fn_state.gs_118646 = s_4298_4;
        // N s_4298_6: jump b2472
        return block_2472(state, tracer, fn_state);
    }
    fn block_4299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4299_0: read-var coproc:u8
        let s_4299_0: u8 = fn_state.coproc;
        // D s_4299_1: cast zx s_4299_0 -> bv
        let s_4299_1: Bits = Bits::new(s_4299_0 as u128, 4u16);
        // C s_4299_2: const #15u : u8
        let s_4299_2: u8 = 15;
        // C s_4299_3: cast zx s_4299_2 -> bv
        let s_4299_3: Bits = Bits::new(s_4299_2 as u128, 4u16);
        // D s_4299_4: cmp-eq s_4299_1 s_4299_3
        let s_4299_4: bool = ((s_4299_1) == (s_4299_3));
        // D s_4299_5: write-var gs#118645 <= s_4299_4
        fn_state.gs_118645 = s_4299_4;
        // N s_4299_6: jump b2470
        return block_2470(state, tracer, fn_state);
    }
    fn block_4300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4300_0: read-var CRn:u8
        let s_4300_0: u8 = fn_state.CRn;
        // D s_4300_1: cast zx s_4300_0 -> bv
        let s_4300_1: Bits = Bits::new(s_4300_0 as u128, 4u16);
        // C s_4300_2: const #1u : u8
        let s_4300_2: u8 = 1;
        // C s_4300_3: cast zx s_4300_2 -> bv
        let s_4300_3: Bits = Bits::new(s_4300_2 as u128, 4u16);
        // D s_4300_4: cmp-eq s_4300_1 s_4300_3
        let s_4300_4: bool = ((s_4300_1) == (s_4300_3));
        // D s_4300_5: write-var gs#118644 <= s_4300_4
        fn_state.gs_118644 = s_4300_4;
        // N s_4300_6: jump b2468
        return block_2468(state, tracer, fn_state);
    }
    fn block_4301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4301_0: read-var el:u8
        let s_4301_0: u8 = fn_state.el;
        // D s_4301_1: read-var coproc:u8
        let s_4301_1: u8 = fn_state.coproc;
        // D s_4301_2: read-var opc1:u8
        let s_4301_2: u8 = fn_state.opc1;
        // D s_4301_3: read-var CRn:u8
        let s_4301_3: u8 = fn_state.CRn;
        // D s_4301_4: read-var opc2:u8
        let s_4301_4: u8 = fn_state.opc2;
        // D s_4301_5: read-var CRm:u8
        let s_4301_5: u8 = fn_state.CRm;
        // D s_4301_6: read-var t:i
        let s_4301_6: i128 = fn_state.t;
        // D s_4301_7: call ACTLR2_SysRegRead32_b5235ae9298d37ab(s_4301_0, s_4301_1, s_4301_2, s_4301_3, s_4301_4, s_4301_5, s_4301_6)
        let s_4301_7: () = ACTLR2_SysRegRead32_b5235ae9298d37ab(
            state,
            tracer,
            s_4301_0,
            s_4301_1,
            s_4301_2,
            s_4301_3,
            s_4301_4,
            s_4301_5,
            s_4301_6,
        );
        // N s_4301_8: return
        return;
    }
    fn block_4302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4302_0: read-var opc2:u8
        let s_4302_0: u8 = fn_state.opc2;
        // D s_4302_1: cast zx s_4302_0 -> bv
        let s_4302_1: Bits = Bits::new(s_4302_0 as u128, 3u16);
        // C s_4302_2: const #3u : u8
        let s_4302_2: u8 = 3;
        // C s_4302_3: cast zx s_4302_2 -> bv
        let s_4302_3: Bits = Bits::new(s_4302_2 as u128, 3u16);
        // D s_4302_4: cmp-eq s_4302_1 s_4302_3
        let s_4302_4: bool = ((s_4302_1) == (s_4302_3));
        // D s_4302_5: write-var gs#118643 <= s_4302_4
        fn_state.gs_118643 = s_4302_4;
        // N s_4302_6: jump b2465
        return block_2465(state, tracer, fn_state);
    }
    fn block_4303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4303_0: read-var opc1:u8
        let s_4303_0: u8 = fn_state.opc1;
        // D s_4303_1: cast zx s_4303_0 -> bv
        let s_4303_1: Bits = Bits::new(s_4303_0 as u128, 3u16);
        // C s_4303_2: const #0u : u8
        let s_4303_2: u8 = 0;
        // C s_4303_3: cast zx s_4303_2 -> bv
        let s_4303_3: Bits = Bits::new(s_4303_2 as u128, 3u16);
        // D s_4303_4: cmp-eq s_4303_1 s_4303_3
        let s_4303_4: bool = ((s_4303_1) == (s_4303_3));
        // D s_4303_5: write-var gs#118642 <= s_4303_4
        fn_state.gs_118642 = s_4303_4;
        // N s_4303_6: jump b2463
        return block_2463(state, tracer, fn_state);
    }
    fn block_4304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4304_0: read-var coproc:u8
        let s_4304_0: u8 = fn_state.coproc;
        // D s_4304_1: cast zx s_4304_0 -> bv
        let s_4304_1: Bits = Bits::new(s_4304_0 as u128, 4u16);
        // C s_4304_2: const #15u : u8
        let s_4304_2: u8 = 15;
        // C s_4304_3: cast zx s_4304_2 -> bv
        let s_4304_3: Bits = Bits::new(s_4304_2 as u128, 4u16);
        // D s_4304_4: cmp-eq s_4304_1 s_4304_3
        let s_4304_4: bool = ((s_4304_1) == (s_4304_3));
        // D s_4304_5: write-var gs#118641 <= s_4304_4
        fn_state.gs_118641 = s_4304_4;
        // N s_4304_6: jump b2461
        return block_2461(state, tracer, fn_state);
    }
    fn block_4305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4305_0: read-var CRn:u8
        let s_4305_0: u8 = fn_state.CRn;
        // D s_4305_1: cast zx s_4305_0 -> bv
        let s_4305_1: Bits = Bits::new(s_4305_0 as u128, 4u16);
        // C s_4305_2: const #1u : u8
        let s_4305_2: u8 = 1;
        // C s_4305_3: cast zx s_4305_2 -> bv
        let s_4305_3: Bits = Bits::new(s_4305_2 as u128, 4u16);
        // D s_4305_4: cmp-eq s_4305_1 s_4305_3
        let s_4305_4: bool = ((s_4305_1) == (s_4305_3));
        // D s_4305_5: write-var gs#118640 <= s_4305_4
        fn_state.gs_118640 = s_4305_4;
        // N s_4305_6: jump b2459
        return block_2459(state, tracer, fn_state);
    }
    fn block_4306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4306_0: read-var el:u8
        let s_4306_0: u8 = fn_state.el;
        // D s_4306_1: read-var coproc:u8
        let s_4306_1: u8 = fn_state.coproc;
        // D s_4306_2: read-var opc1:u8
        let s_4306_2: u8 = fn_state.opc1;
        // D s_4306_3: read-var CRn:u8
        let s_4306_3: u8 = fn_state.CRn;
        // D s_4306_4: read-var opc2:u8
        let s_4306_4: u8 = fn_state.opc2;
        // D s_4306_5: read-var CRm:u8
        let s_4306_5: u8 = fn_state.CRm;
        // D s_4306_6: read-var t:i
        let s_4306_6: i128 = fn_state.t;
        // D s_4306_7: call ICH_MISR_SysRegRead32_b1b3df82fdb149c6(s_4306_0, s_4306_1, s_4306_2, s_4306_3, s_4306_4, s_4306_5, s_4306_6)
        let s_4306_7: () = ICH_MISR_SysRegRead32_b1b3df82fdb149c6(
            state,
            tracer,
            s_4306_0,
            s_4306_1,
            s_4306_2,
            s_4306_3,
            s_4306_4,
            s_4306_5,
            s_4306_6,
        );
        // N s_4306_8: return
        return;
    }
    fn block_4307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4307_0: read-var opc2:u8
        let s_4307_0: u8 = fn_state.opc2;
        // D s_4307_1: cast zx s_4307_0 -> bv
        let s_4307_1: Bits = Bits::new(s_4307_0 as u128, 3u16);
        // C s_4307_2: const #2u : u8
        let s_4307_2: u8 = 2;
        // C s_4307_3: cast zx s_4307_2 -> bv
        let s_4307_3: Bits = Bits::new(s_4307_2 as u128, 3u16);
        // D s_4307_4: cmp-eq s_4307_1 s_4307_3
        let s_4307_4: bool = ((s_4307_1) == (s_4307_3));
        // D s_4307_5: write-var gs#118639 <= s_4307_4
        fn_state.gs_118639 = s_4307_4;
        // N s_4307_6: jump b2456
        return block_2456(state, tracer, fn_state);
    }
    fn block_4308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4308_0: read-var opc1:u8
        let s_4308_0: u8 = fn_state.opc1;
        // D s_4308_1: cast zx s_4308_0 -> bv
        let s_4308_1: Bits = Bits::new(s_4308_0 as u128, 3u16);
        // C s_4308_2: const #4u : u8
        let s_4308_2: u8 = 4;
        // C s_4308_3: cast zx s_4308_2 -> bv
        let s_4308_3: Bits = Bits::new(s_4308_2 as u128, 3u16);
        // D s_4308_4: cmp-eq s_4308_1 s_4308_3
        let s_4308_4: bool = ((s_4308_1) == (s_4308_3));
        // D s_4308_5: write-var gs#118638 <= s_4308_4
        fn_state.gs_118638 = s_4308_4;
        // N s_4308_6: jump b2454
        return block_2454(state, tracer, fn_state);
    }
    fn block_4309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4309_0: read-var coproc:u8
        let s_4309_0: u8 = fn_state.coproc;
        // D s_4309_1: cast zx s_4309_0 -> bv
        let s_4309_1: Bits = Bits::new(s_4309_0 as u128, 4u16);
        // C s_4309_2: const #15u : u8
        let s_4309_2: u8 = 15;
        // C s_4309_3: cast zx s_4309_2 -> bv
        let s_4309_3: Bits = Bits::new(s_4309_2 as u128, 4u16);
        // D s_4309_4: cmp-eq s_4309_1 s_4309_3
        let s_4309_4: bool = ((s_4309_1) == (s_4309_3));
        // D s_4309_5: write-var gs#118637 <= s_4309_4
        fn_state.gs_118637 = s_4309_4;
        // N s_4309_6: jump b2452
        return block_2452(state, tracer, fn_state);
    }
    fn block_4310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4310_0: read-var CRn:u8
        let s_4310_0: u8 = fn_state.CRn;
        // D s_4310_1: cast zx s_4310_0 -> bv
        let s_4310_1: Bits = Bits::new(s_4310_0 as u128, 4u16);
        // C s_4310_2: const #12u : u8
        let s_4310_2: u8 = 12;
        // C s_4310_3: cast zx s_4310_2 -> bv
        let s_4310_3: Bits = Bits::new(s_4310_2 as u128, 4u16);
        // D s_4310_4: cmp-eq s_4310_1 s_4310_3
        let s_4310_4: bool = ((s_4310_1) == (s_4310_3));
        // D s_4310_5: write-var gs#118636 <= s_4310_4
        fn_state.gs_118636 = s_4310_4;
        // N s_4310_6: jump b2450
        return block_2450(state, tracer, fn_state);
    }
    fn block_4311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4311_0: read-var el:u8
        let s_4311_0: u8 = fn_state.el;
        // D s_4311_1: read-var coproc:u8
        let s_4311_1: u8 = fn_state.coproc;
        // D s_4311_2: read-var opc1:u8
        let s_4311_2: u8 = fn_state.opc1;
        // D s_4311_3: read-var CRn:u8
        let s_4311_3: u8 = fn_state.CRn;
        // D s_4311_4: read-var opc2:u8
        let s_4311_4: u8 = fn_state.opc2;
        // D s_4311_5: read-var CRm:u8
        let s_4311_5: u8 = fn_state.CRm;
        // D s_4311_6: read-var t:i
        let s_4311_6: i128 = fn_state.t;
        // D s_4311_7: call MVBAR_SysRegRead32_248e7559e6798c99(s_4311_0, s_4311_1, s_4311_2, s_4311_3, s_4311_4, s_4311_5, s_4311_6)
        let s_4311_7: () = MVBAR_SysRegRead32_248e7559e6798c99(
            state,
            tracer,
            s_4311_0,
            s_4311_1,
            s_4311_2,
            s_4311_3,
            s_4311_4,
            s_4311_5,
            s_4311_6,
        );
        // N s_4311_8: return
        return;
    }
    fn block_4312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4312_0: read-var opc2:u8
        let s_4312_0: u8 = fn_state.opc2;
        // D s_4312_1: cast zx s_4312_0 -> bv
        let s_4312_1: Bits = Bits::new(s_4312_0 as u128, 3u16);
        // C s_4312_2: const #1u : u8
        let s_4312_2: u8 = 1;
        // C s_4312_3: cast zx s_4312_2 -> bv
        let s_4312_3: Bits = Bits::new(s_4312_2 as u128, 3u16);
        // D s_4312_4: cmp-eq s_4312_1 s_4312_3
        let s_4312_4: bool = ((s_4312_1) == (s_4312_3));
        // D s_4312_5: write-var gs#118635 <= s_4312_4
        fn_state.gs_118635 = s_4312_4;
        // N s_4312_6: jump b2447
        return block_2447(state, tracer, fn_state);
    }
    fn block_4313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4313_0: read-var opc1:u8
        let s_4313_0: u8 = fn_state.opc1;
        // D s_4313_1: cast zx s_4313_0 -> bv
        let s_4313_1: Bits = Bits::new(s_4313_0 as u128, 3u16);
        // C s_4313_2: const #0u : u8
        let s_4313_2: u8 = 0;
        // C s_4313_3: cast zx s_4313_2 -> bv
        let s_4313_3: Bits = Bits::new(s_4313_2 as u128, 3u16);
        // D s_4313_4: cmp-eq s_4313_1 s_4313_3
        let s_4313_4: bool = ((s_4313_1) == (s_4313_3));
        // D s_4313_5: write-var gs#118634 <= s_4313_4
        fn_state.gs_118634 = s_4313_4;
        // N s_4313_6: jump b2445
        return block_2445(state, tracer, fn_state);
    }
    fn block_4314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4314_0: read-var coproc:u8
        let s_4314_0: u8 = fn_state.coproc;
        // D s_4314_1: cast zx s_4314_0 -> bv
        let s_4314_1: Bits = Bits::new(s_4314_0 as u128, 4u16);
        // C s_4314_2: const #15u : u8
        let s_4314_2: u8 = 15;
        // C s_4314_3: cast zx s_4314_2 -> bv
        let s_4314_3: Bits = Bits::new(s_4314_2 as u128, 4u16);
        // D s_4314_4: cmp-eq s_4314_1 s_4314_3
        let s_4314_4: bool = ((s_4314_1) == (s_4314_3));
        // D s_4314_5: write-var gs#118633 <= s_4314_4
        fn_state.gs_118633 = s_4314_4;
        // N s_4314_6: jump b2443
        return block_2443(state, tracer, fn_state);
    }
    fn block_4315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4315_0: read-var CRn:u8
        let s_4315_0: u8 = fn_state.CRn;
        // D s_4315_1: cast zx s_4315_0 -> bv
        let s_4315_1: Bits = Bits::new(s_4315_0 as u128, 4u16);
        // C s_4315_2: const #12u : u8
        let s_4315_2: u8 = 12;
        // C s_4315_3: cast zx s_4315_2 -> bv
        let s_4315_3: Bits = Bits::new(s_4315_2 as u128, 4u16);
        // D s_4315_4: cmp-eq s_4315_1 s_4315_3
        let s_4315_4: bool = ((s_4315_1) == (s_4315_3));
        // D s_4315_5: write-var gs#118632 <= s_4315_4
        fn_state.gs_118632 = s_4315_4;
        // N s_4315_6: jump b2441
        return block_2441(state, tracer, fn_state);
    }
    fn block_4316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4316_0: read-var el:u8
        let s_4316_0: u8 = fn_state.el;
        // D s_4316_1: read-var coproc:u8
        let s_4316_1: u8 = fn_state.coproc;
        // D s_4316_2: read-var opc1:u8
        let s_4316_2: u8 = fn_state.opc1;
        // D s_4316_3: read-var CRn:u8
        let s_4316_3: u8 = fn_state.CRn;
        // D s_4316_4: read-var opc2:u8
        let s_4316_4: u8 = fn_state.opc2;
        // D s_4316_5: read-var CRm:u8
        let s_4316_5: u8 = fn_state.CRm;
        // D s_4316_6: read-var t:i
        let s_4316_6: i128 = fn_state.t;
        // D s_4316_7: call CCSIDR2_SysRegRead32_b747ebd0fcc6df4e(s_4316_0, s_4316_1, s_4316_2, s_4316_3, s_4316_4, s_4316_5, s_4316_6)
        let s_4316_7: () = CCSIDR2_SysRegRead32_b747ebd0fcc6df4e(
            state,
            tracer,
            s_4316_0,
            s_4316_1,
            s_4316_2,
            s_4316_3,
            s_4316_4,
            s_4316_5,
            s_4316_6,
        );
        // N s_4316_8: return
        return;
    }
    fn block_4317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4317_0: read-var opc2:u8
        let s_4317_0: u8 = fn_state.opc2;
        // D s_4317_1: cast zx s_4317_0 -> bv
        let s_4317_1: Bits = Bits::new(s_4317_0 as u128, 3u16);
        // C s_4317_2: const #2u : u8
        let s_4317_2: u8 = 2;
        // C s_4317_3: cast zx s_4317_2 -> bv
        let s_4317_3: Bits = Bits::new(s_4317_2 as u128, 3u16);
        // D s_4317_4: cmp-eq s_4317_1 s_4317_3
        let s_4317_4: bool = ((s_4317_1) == (s_4317_3));
        // D s_4317_5: write-var gs#118631 <= s_4317_4
        fn_state.gs_118631 = s_4317_4;
        // N s_4317_6: jump b2438
        return block_2438(state, tracer, fn_state);
    }
    fn block_4318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4318_0: read-var opc1:u8
        let s_4318_0: u8 = fn_state.opc1;
        // D s_4318_1: cast zx s_4318_0 -> bv
        let s_4318_1: Bits = Bits::new(s_4318_0 as u128, 3u16);
        // C s_4318_2: const #1u : u8
        let s_4318_2: u8 = 1;
        // C s_4318_3: cast zx s_4318_2 -> bv
        let s_4318_3: Bits = Bits::new(s_4318_2 as u128, 3u16);
        // D s_4318_4: cmp-eq s_4318_1 s_4318_3
        let s_4318_4: bool = ((s_4318_1) == (s_4318_3));
        // D s_4318_5: write-var gs#118630 <= s_4318_4
        fn_state.gs_118630 = s_4318_4;
        // N s_4318_6: jump b2436
        return block_2436(state, tracer, fn_state);
    }
    fn block_4319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4319_0: read-var coproc:u8
        let s_4319_0: u8 = fn_state.coproc;
        // D s_4319_1: cast zx s_4319_0 -> bv
        let s_4319_1: Bits = Bits::new(s_4319_0 as u128, 4u16);
        // C s_4319_2: const #15u : u8
        let s_4319_2: u8 = 15;
        // C s_4319_3: cast zx s_4319_2 -> bv
        let s_4319_3: Bits = Bits::new(s_4319_2 as u128, 4u16);
        // D s_4319_4: cmp-eq s_4319_1 s_4319_3
        let s_4319_4: bool = ((s_4319_1) == (s_4319_3));
        // D s_4319_5: write-var gs#118629 <= s_4319_4
        fn_state.gs_118629 = s_4319_4;
        // N s_4319_6: jump b2434
        return block_2434(state, tracer, fn_state);
    }
    fn block_4320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4320_0: read-var CRn:u8
        let s_4320_0: u8 = fn_state.CRn;
        // D s_4320_1: cast zx s_4320_0 -> bv
        let s_4320_1: Bits = Bits::new(s_4320_0 as u128, 4u16);
        // C s_4320_2: const #0u : u8
        let s_4320_2: u8 = 0;
        // C s_4320_3: cast zx s_4320_2 -> bv
        let s_4320_3: Bits = Bits::new(s_4320_2 as u128, 4u16);
        // D s_4320_4: cmp-eq s_4320_1 s_4320_3
        let s_4320_4: bool = ((s_4320_1) == (s_4320_3));
        // D s_4320_5: write-var gs#118628 <= s_4320_4
        fn_state.gs_118628 = s_4320_4;
        // N s_4320_6: jump b2432
        return block_2432(state, tracer, fn_state);
    }
    fn block_4321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4321_0: read-var el:u8
        let s_4321_0: u8 = fn_state.el;
        // D s_4321_1: read-var coproc:u8
        let s_4321_1: u8 = fn_state.coproc;
        // D s_4321_2: read-var opc1:u8
        let s_4321_2: u8 = fn_state.opc1;
        // D s_4321_3: read-var CRn:u8
        let s_4321_3: u8 = fn_state.CRn;
        // D s_4321_4: read-var opc2:u8
        let s_4321_4: u8 = fn_state.opc2;
        // D s_4321_5: read-var CRm:u8
        let s_4321_5: u8 = fn_state.CRm;
        // D s_4321_6: read-var t:i
        let s_4321_6: i128 = fn_state.t;
        // D s_4321_7: call DBGOSECCR_SysRegRead32_391dd35ddd37f699(s_4321_0, s_4321_1, s_4321_2, s_4321_3, s_4321_4, s_4321_5, s_4321_6)
        let s_4321_7: () = DBGOSECCR_SysRegRead32_391dd35ddd37f699(
            state,
            tracer,
            s_4321_0,
            s_4321_1,
            s_4321_2,
            s_4321_3,
            s_4321_4,
            s_4321_5,
            s_4321_6,
        );
        // N s_4321_8: return
        return;
    }
    fn block_4322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4322_0: read-var opc2:u8
        let s_4322_0: u8 = fn_state.opc2;
        // D s_4322_1: cast zx s_4322_0 -> bv
        let s_4322_1: Bits = Bits::new(s_4322_0 as u128, 3u16);
        // C s_4322_2: const #2u : u8
        let s_4322_2: u8 = 2;
        // C s_4322_3: cast zx s_4322_2 -> bv
        let s_4322_3: Bits = Bits::new(s_4322_2 as u128, 3u16);
        // D s_4322_4: cmp-eq s_4322_1 s_4322_3
        let s_4322_4: bool = ((s_4322_1) == (s_4322_3));
        // D s_4322_5: write-var gs#118627 <= s_4322_4
        fn_state.gs_118627 = s_4322_4;
        // N s_4322_6: jump b2429
        return block_2429(state, tracer, fn_state);
    }
    fn block_4323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4323_0: read-var opc1:u8
        let s_4323_0: u8 = fn_state.opc1;
        // D s_4323_1: cast zx s_4323_0 -> bv
        let s_4323_1: Bits = Bits::new(s_4323_0 as u128, 3u16);
        // C s_4323_2: const #0u : u8
        let s_4323_2: u8 = 0;
        // C s_4323_3: cast zx s_4323_2 -> bv
        let s_4323_3: Bits = Bits::new(s_4323_2 as u128, 3u16);
        // D s_4323_4: cmp-eq s_4323_1 s_4323_3
        let s_4323_4: bool = ((s_4323_1) == (s_4323_3));
        // D s_4323_5: write-var gs#118626 <= s_4323_4
        fn_state.gs_118626 = s_4323_4;
        // N s_4323_6: jump b2427
        return block_2427(state, tracer, fn_state);
    }
    fn block_4324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4324_0: read-var coproc:u8
        let s_4324_0: u8 = fn_state.coproc;
        // D s_4324_1: cast zx s_4324_0 -> bv
        let s_4324_1: Bits = Bits::new(s_4324_0 as u128, 4u16);
        // C s_4324_2: const #14u : u8
        let s_4324_2: u8 = 14;
        // C s_4324_3: cast zx s_4324_2 -> bv
        let s_4324_3: Bits = Bits::new(s_4324_2 as u128, 4u16);
        // D s_4324_4: cmp-eq s_4324_1 s_4324_3
        let s_4324_4: bool = ((s_4324_1) == (s_4324_3));
        // D s_4324_5: write-var gs#118625 <= s_4324_4
        fn_state.gs_118625 = s_4324_4;
        // N s_4324_6: jump b2425
        return block_2425(state, tracer, fn_state);
    }
    fn block_4325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4325_0: read-var CRn:u8
        let s_4325_0: u8 = fn_state.CRn;
        // D s_4325_1: cast zx s_4325_0 -> bv
        let s_4325_1: Bits = Bits::new(s_4325_0 as u128, 4u16);
        // C s_4325_2: const #0u : u8
        let s_4325_2: u8 = 0;
        // C s_4325_3: cast zx s_4325_2 -> bv
        let s_4325_3: Bits = Bits::new(s_4325_2 as u128, 4u16);
        // D s_4325_4: cmp-eq s_4325_1 s_4325_3
        let s_4325_4: bool = ((s_4325_1) == (s_4325_3));
        // D s_4325_5: write-var gs#118624 <= s_4325_4
        fn_state.gs_118624 = s_4325_4;
        // N s_4325_6: jump b2423
        return block_2423(state, tracer, fn_state);
    }
    fn block_4326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4326_0: read-var el:u8
        let s_4326_0: u8 = fn_state.el;
        // D s_4326_1: read-var coproc:u8
        let s_4326_1: u8 = fn_state.coproc;
        // D s_4326_2: read-var opc1:u8
        let s_4326_2: u8 = fn_state.opc1;
        // D s_4326_3: read-var CRn:u8
        let s_4326_3: u8 = fn_state.CRn;
        // D s_4326_4: read-var opc2:u8
        let s_4326_4: u8 = fn_state.opc2;
        // D s_4326_5: read-var CRm:u8
        let s_4326_5: u8 = fn_state.CRm;
        // D s_4326_6: read-var t:i
        let s_4326_6: i128 = fn_state.t;
        // D s_4326_7: call DFSR_SysRegRead32_094c65de67978ba7(s_4326_0, s_4326_1, s_4326_2, s_4326_3, s_4326_4, s_4326_5, s_4326_6)
        let s_4326_7: () = DFSR_SysRegRead32_094c65de67978ba7(
            state,
            tracer,
            s_4326_0,
            s_4326_1,
            s_4326_2,
            s_4326_3,
            s_4326_4,
            s_4326_5,
            s_4326_6,
        );
        // N s_4326_8: return
        return;
    }
    fn block_4327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4327_0: read-var opc2:u8
        let s_4327_0: u8 = fn_state.opc2;
        // D s_4327_1: cast zx s_4327_0 -> bv
        let s_4327_1: Bits = Bits::new(s_4327_0 as u128, 3u16);
        // C s_4327_2: const #0u : u8
        let s_4327_2: u8 = 0;
        // C s_4327_3: cast zx s_4327_2 -> bv
        let s_4327_3: Bits = Bits::new(s_4327_2 as u128, 3u16);
        // D s_4327_4: cmp-eq s_4327_1 s_4327_3
        let s_4327_4: bool = ((s_4327_1) == (s_4327_3));
        // D s_4327_5: write-var gs#118623 <= s_4327_4
        fn_state.gs_118623 = s_4327_4;
        // N s_4327_6: jump b2420
        return block_2420(state, tracer, fn_state);
    }
    fn block_4328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4328_0: read-var opc1:u8
        let s_4328_0: u8 = fn_state.opc1;
        // D s_4328_1: cast zx s_4328_0 -> bv
        let s_4328_1: Bits = Bits::new(s_4328_0 as u128, 3u16);
        // C s_4328_2: const #0u : u8
        let s_4328_2: u8 = 0;
        // C s_4328_3: cast zx s_4328_2 -> bv
        let s_4328_3: Bits = Bits::new(s_4328_2 as u128, 3u16);
        // D s_4328_4: cmp-eq s_4328_1 s_4328_3
        let s_4328_4: bool = ((s_4328_1) == (s_4328_3));
        // D s_4328_5: write-var gs#118622 <= s_4328_4
        fn_state.gs_118622 = s_4328_4;
        // N s_4328_6: jump b2418
        return block_2418(state, tracer, fn_state);
    }
    fn block_4329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4329_0: read-var coproc:u8
        let s_4329_0: u8 = fn_state.coproc;
        // D s_4329_1: cast zx s_4329_0 -> bv
        let s_4329_1: Bits = Bits::new(s_4329_0 as u128, 4u16);
        // C s_4329_2: const #15u : u8
        let s_4329_2: u8 = 15;
        // C s_4329_3: cast zx s_4329_2 -> bv
        let s_4329_3: Bits = Bits::new(s_4329_2 as u128, 4u16);
        // D s_4329_4: cmp-eq s_4329_1 s_4329_3
        let s_4329_4: bool = ((s_4329_1) == (s_4329_3));
        // D s_4329_5: write-var gs#118621 <= s_4329_4
        fn_state.gs_118621 = s_4329_4;
        // N s_4329_6: jump b2416
        return block_2416(state, tracer, fn_state);
    }
    fn block_4330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4330_0: read-var CRn:u8
        let s_4330_0: u8 = fn_state.CRn;
        // D s_4330_1: cast zx s_4330_0 -> bv
        let s_4330_1: Bits = Bits::new(s_4330_0 as u128, 4u16);
        // C s_4330_2: const #5u : u8
        let s_4330_2: u8 = 5;
        // C s_4330_3: cast zx s_4330_2 -> bv
        let s_4330_3: Bits = Bits::new(s_4330_2 as u128, 4u16);
        // D s_4330_4: cmp-eq s_4330_1 s_4330_3
        let s_4330_4: bool = ((s_4330_1) == (s_4330_3));
        // D s_4330_5: write-var gs#118620 <= s_4330_4
        fn_state.gs_118620 = s_4330_4;
        // N s_4330_6: jump b2414
        return block_2414(state, tracer, fn_state);
    }
    fn block_4331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4331_0: read-var el:u8
        let s_4331_0: u8 = fn_state.el;
        // D s_4331_1: read-var coproc:u8
        let s_4331_1: u8 = fn_state.coproc;
        // D s_4331_2: read-var opc1:u8
        let s_4331_2: u8 = fn_state.opc1;
        // D s_4331_3: read-var CRn:u8
        let s_4331_3: u8 = fn_state.CRn;
        // D s_4331_4: read-var opc2:u8
        let s_4331_4: u8 = fn_state.opc2;
        // D s_4331_5: read-var CRm:u8
        let s_4331_5: u8 = fn_state.CRm;
        // D s_4331_6: read-var t:i
        let s_4331_6: i128 = fn_state.t;
        // D s_4331_7: call DBGDEVID_SysRegRead32_66290830e754b76a(s_4331_0, s_4331_1, s_4331_2, s_4331_3, s_4331_4, s_4331_5, s_4331_6)
        let s_4331_7: () = DBGDEVID_SysRegRead32_66290830e754b76a(
            state,
            tracer,
            s_4331_0,
            s_4331_1,
            s_4331_2,
            s_4331_3,
            s_4331_4,
            s_4331_5,
            s_4331_6,
        );
        // N s_4331_8: return
        return;
    }
    fn block_4332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4332_0: read-var opc2:u8
        let s_4332_0: u8 = fn_state.opc2;
        // D s_4332_1: cast zx s_4332_0 -> bv
        let s_4332_1: Bits = Bits::new(s_4332_0 as u128, 3u16);
        // C s_4332_2: const #7u : u8
        let s_4332_2: u8 = 7;
        // C s_4332_3: cast zx s_4332_2 -> bv
        let s_4332_3: Bits = Bits::new(s_4332_2 as u128, 3u16);
        // D s_4332_4: cmp-eq s_4332_1 s_4332_3
        let s_4332_4: bool = ((s_4332_1) == (s_4332_3));
        // D s_4332_5: write-var gs#118619 <= s_4332_4
        fn_state.gs_118619 = s_4332_4;
        // N s_4332_6: jump b2411
        return block_2411(state, tracer, fn_state);
    }
    fn block_4333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4333_0: read-var opc1:u8
        let s_4333_0: u8 = fn_state.opc1;
        // D s_4333_1: cast zx s_4333_0 -> bv
        let s_4333_1: Bits = Bits::new(s_4333_0 as u128, 3u16);
        // C s_4333_2: const #0u : u8
        let s_4333_2: u8 = 0;
        // C s_4333_3: cast zx s_4333_2 -> bv
        let s_4333_3: Bits = Bits::new(s_4333_2 as u128, 3u16);
        // D s_4333_4: cmp-eq s_4333_1 s_4333_3
        let s_4333_4: bool = ((s_4333_1) == (s_4333_3));
        // D s_4333_5: write-var gs#118618 <= s_4333_4
        fn_state.gs_118618 = s_4333_4;
        // N s_4333_6: jump b2409
        return block_2409(state, tracer, fn_state);
    }
    fn block_4334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4334_0: read-var coproc:u8
        let s_4334_0: u8 = fn_state.coproc;
        // D s_4334_1: cast zx s_4334_0 -> bv
        let s_4334_1: Bits = Bits::new(s_4334_0 as u128, 4u16);
        // C s_4334_2: const #14u : u8
        let s_4334_2: u8 = 14;
        // C s_4334_3: cast zx s_4334_2 -> bv
        let s_4334_3: Bits = Bits::new(s_4334_2 as u128, 4u16);
        // D s_4334_4: cmp-eq s_4334_1 s_4334_3
        let s_4334_4: bool = ((s_4334_1) == (s_4334_3));
        // D s_4334_5: write-var gs#118617 <= s_4334_4
        fn_state.gs_118617 = s_4334_4;
        // N s_4334_6: jump b2407
        return block_2407(state, tracer, fn_state);
    }
    fn block_4335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4335_0: read-var CRn:u8
        let s_4335_0: u8 = fn_state.CRn;
        // D s_4335_1: cast zx s_4335_0 -> bv
        let s_4335_1: Bits = Bits::new(s_4335_0 as u128, 4u16);
        // C s_4335_2: const #7u : u8
        let s_4335_2: u8 = 7;
        // C s_4335_3: cast zx s_4335_2 -> bv
        let s_4335_3: Bits = Bits::new(s_4335_2 as u128, 4u16);
        // D s_4335_4: cmp-eq s_4335_1 s_4335_3
        let s_4335_4: bool = ((s_4335_1) == (s_4335_3));
        // D s_4335_5: write-var gs#118616 <= s_4335_4
        fn_state.gs_118616 = s_4335_4;
        // N s_4335_6: jump b2405
        return block_2405(state, tracer, fn_state);
    }
    fn block_4336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4336_0: read-var el:u8
        let s_4336_0: u8 = fn_state.el;
        // D s_4336_1: read-var coproc:u8
        let s_4336_1: u8 = fn_state.coproc;
        // D s_4336_2: read-var opc1:u8
        let s_4336_2: u8 = fn_state.opc1;
        // D s_4336_3: read-var CRn:u8
        let s_4336_3: u8 = fn_state.CRn;
        // D s_4336_4: read-var opc2:u8
        let s_4336_4: u8 = fn_state.opc2;
        // D s_4336_5: read-var CRm:u8
        let s_4336_5: u8 = fn_state.CRm;
        // D s_4336_6: read-var t:i
        let s_4336_6: i128 = fn_state.t;
        // D s_4336_7: call PMINTENSET_SysRegRead32_44a5f589c4b56eb5(s_4336_0, s_4336_1, s_4336_2, s_4336_3, s_4336_4, s_4336_5, s_4336_6)
        let s_4336_7: () = PMINTENSET_SysRegRead32_44a5f589c4b56eb5(
            state,
            tracer,
            s_4336_0,
            s_4336_1,
            s_4336_2,
            s_4336_3,
            s_4336_4,
            s_4336_5,
            s_4336_6,
        );
        // N s_4336_8: return
        return;
    }
    fn block_4337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4337_0: read-var opc2:u8
        let s_4337_0: u8 = fn_state.opc2;
        // D s_4337_1: cast zx s_4337_0 -> bv
        let s_4337_1: Bits = Bits::new(s_4337_0 as u128, 3u16);
        // C s_4337_2: const #1u : u8
        let s_4337_2: u8 = 1;
        // C s_4337_3: cast zx s_4337_2 -> bv
        let s_4337_3: Bits = Bits::new(s_4337_2 as u128, 3u16);
        // D s_4337_4: cmp-eq s_4337_1 s_4337_3
        let s_4337_4: bool = ((s_4337_1) == (s_4337_3));
        // D s_4337_5: write-var gs#118615 <= s_4337_4
        fn_state.gs_118615 = s_4337_4;
        // N s_4337_6: jump b2402
        return block_2402(state, tracer, fn_state);
    }
    fn block_4338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4338_0: read-var opc1:u8
        let s_4338_0: u8 = fn_state.opc1;
        // D s_4338_1: cast zx s_4338_0 -> bv
        let s_4338_1: Bits = Bits::new(s_4338_0 as u128, 3u16);
        // C s_4338_2: const #0u : u8
        let s_4338_2: u8 = 0;
        // C s_4338_3: cast zx s_4338_2 -> bv
        let s_4338_3: Bits = Bits::new(s_4338_2 as u128, 3u16);
        // D s_4338_4: cmp-eq s_4338_1 s_4338_3
        let s_4338_4: bool = ((s_4338_1) == (s_4338_3));
        // D s_4338_5: write-var gs#118614 <= s_4338_4
        fn_state.gs_118614 = s_4338_4;
        // N s_4338_6: jump b2400
        return block_2400(state, tracer, fn_state);
    }
    fn block_4339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4339_0: read-var coproc:u8
        let s_4339_0: u8 = fn_state.coproc;
        // D s_4339_1: cast zx s_4339_0 -> bv
        let s_4339_1: Bits = Bits::new(s_4339_0 as u128, 4u16);
        // C s_4339_2: const #15u : u8
        let s_4339_2: u8 = 15;
        // C s_4339_3: cast zx s_4339_2 -> bv
        let s_4339_3: Bits = Bits::new(s_4339_2 as u128, 4u16);
        // D s_4339_4: cmp-eq s_4339_1 s_4339_3
        let s_4339_4: bool = ((s_4339_1) == (s_4339_3));
        // D s_4339_5: write-var gs#118613 <= s_4339_4
        fn_state.gs_118613 = s_4339_4;
        // N s_4339_6: jump b2398
        return block_2398(state, tracer, fn_state);
    }
    fn block_4340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4340_0: read-var CRn:u8
        let s_4340_0: u8 = fn_state.CRn;
        // D s_4340_1: cast zx s_4340_0 -> bv
        let s_4340_1: Bits = Bits::new(s_4340_0 as u128, 4u16);
        // C s_4340_2: const #9u : u8
        let s_4340_2: u8 = 9;
        // C s_4340_3: cast zx s_4340_2 -> bv
        let s_4340_3: Bits = Bits::new(s_4340_2 as u128, 4u16);
        // D s_4340_4: cmp-eq s_4340_1 s_4340_3
        let s_4340_4: bool = ((s_4340_1) == (s_4340_3));
        // D s_4340_5: write-var gs#118612 <= s_4340_4
        fn_state.gs_118612 = s_4340_4;
        // N s_4340_6: jump b2396
        return block_2396(state, tracer, fn_state);
    }
    fn block_4341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4341_0: read-var el:u8
        let s_4341_0: u8 = fn_state.el;
        // D s_4341_1: read-var coproc:u8
        let s_4341_1: u8 = fn_state.coproc;
        // D s_4341_2: read-var opc1:u8
        let s_4341_2: u8 = fn_state.opc1;
        // D s_4341_3: read-var CRn:u8
        let s_4341_3: u8 = fn_state.CRn;
        // D s_4341_4: read-var opc2:u8
        let s_4341_4: u8 = fn_state.opc2;
        // D s_4341_5: read-var CRm:u8
        let s_4341_5: u8 = fn_state.CRm;
        // D s_4341_6: read-var t:i
        let s_4341_6: i128 = fn_state.t;
        // D s_4341_7: call CNTFRQ_SysRegRead32_4d7a0faa14f3d1f9(s_4341_0, s_4341_1, s_4341_2, s_4341_3, s_4341_4, s_4341_5, s_4341_6)
        let s_4341_7: () = CNTFRQ_SysRegRead32_4d7a0faa14f3d1f9(
            state,
            tracer,
            s_4341_0,
            s_4341_1,
            s_4341_2,
            s_4341_3,
            s_4341_4,
            s_4341_5,
            s_4341_6,
        );
        // N s_4341_8: return
        return;
    }
    fn block_4342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4342_0: read-var opc2:u8
        let s_4342_0: u8 = fn_state.opc2;
        // D s_4342_1: cast zx s_4342_0 -> bv
        let s_4342_1: Bits = Bits::new(s_4342_0 as u128, 3u16);
        // C s_4342_2: const #0u : u8
        let s_4342_2: u8 = 0;
        // C s_4342_3: cast zx s_4342_2 -> bv
        let s_4342_3: Bits = Bits::new(s_4342_2 as u128, 3u16);
        // D s_4342_4: cmp-eq s_4342_1 s_4342_3
        let s_4342_4: bool = ((s_4342_1) == (s_4342_3));
        // D s_4342_5: write-var gs#118611 <= s_4342_4
        fn_state.gs_118611 = s_4342_4;
        // N s_4342_6: jump b2393
        return block_2393(state, tracer, fn_state);
    }
    fn block_4343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4343_0: read-var opc1:u8
        let s_4343_0: u8 = fn_state.opc1;
        // D s_4343_1: cast zx s_4343_0 -> bv
        let s_4343_1: Bits = Bits::new(s_4343_0 as u128, 3u16);
        // C s_4343_2: const #0u : u8
        let s_4343_2: u8 = 0;
        // C s_4343_3: cast zx s_4343_2 -> bv
        let s_4343_3: Bits = Bits::new(s_4343_2 as u128, 3u16);
        // D s_4343_4: cmp-eq s_4343_1 s_4343_3
        let s_4343_4: bool = ((s_4343_1) == (s_4343_3));
        // D s_4343_5: write-var gs#118610 <= s_4343_4
        fn_state.gs_118610 = s_4343_4;
        // N s_4343_6: jump b2391
        return block_2391(state, tracer, fn_state);
    }
    fn block_4344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4344_0: read-var coproc:u8
        let s_4344_0: u8 = fn_state.coproc;
        // D s_4344_1: cast zx s_4344_0 -> bv
        let s_4344_1: Bits = Bits::new(s_4344_0 as u128, 4u16);
        // C s_4344_2: const #15u : u8
        let s_4344_2: u8 = 15;
        // C s_4344_3: cast zx s_4344_2 -> bv
        let s_4344_3: Bits = Bits::new(s_4344_2 as u128, 4u16);
        // D s_4344_4: cmp-eq s_4344_1 s_4344_3
        let s_4344_4: bool = ((s_4344_1) == (s_4344_3));
        // D s_4344_5: write-var gs#118609 <= s_4344_4
        fn_state.gs_118609 = s_4344_4;
        // N s_4344_6: jump b2389
        return block_2389(state, tracer, fn_state);
    }
    fn block_4345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4345_0: read-var CRn:u8
        let s_4345_0: u8 = fn_state.CRn;
        // D s_4345_1: cast zx s_4345_0 -> bv
        let s_4345_1: Bits = Bits::new(s_4345_0 as u128, 4u16);
        // C s_4345_2: const #14u : u8
        let s_4345_2: u8 = 14;
        // C s_4345_3: cast zx s_4345_2 -> bv
        let s_4345_3: Bits = Bits::new(s_4345_2 as u128, 4u16);
        // D s_4345_4: cmp-eq s_4345_1 s_4345_3
        let s_4345_4: bool = ((s_4345_1) == (s_4345_3));
        // D s_4345_5: write-var gs#118608 <= s_4345_4
        fn_state.gs_118608 = s_4345_4;
        // N s_4345_6: jump b2387
        return block_2387(state, tracer, fn_state);
    }
    fn block_4346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4346_0: read-var el:u8
        let s_4346_0: u8 = fn_state.el;
        // D s_4346_1: read-var coproc:u8
        let s_4346_1: u8 = fn_state.coproc;
        // D s_4346_2: read-var opc1:u8
        let s_4346_2: u8 = fn_state.opc1;
        // D s_4346_3: read-var CRn:u8
        let s_4346_3: u8 = fn_state.CRn;
        // D s_4346_4: read-var opc2:u8
        let s_4346_4: u8 = fn_state.opc2;
        // D s_4346_5: read-var CRm:u8
        let s_4346_5: u8 = fn_state.CRm;
        // D s_4346_6: read-var t:i
        let s_4346_6: i128 = fn_state.t;
        // D s_4346_7: call TLBTR_SysRegRead32_2cb899c86cc4ff56(s_4346_0, s_4346_1, s_4346_2, s_4346_3, s_4346_4, s_4346_5, s_4346_6)
        let s_4346_7: () = TLBTR_SysRegRead32_2cb899c86cc4ff56(
            state,
            tracer,
            s_4346_0,
            s_4346_1,
            s_4346_2,
            s_4346_3,
            s_4346_4,
            s_4346_5,
            s_4346_6,
        );
        // N s_4346_8: return
        return;
    }
    fn block_4347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4347_0: read-var opc2:u8
        let s_4347_0: u8 = fn_state.opc2;
        // D s_4347_1: cast zx s_4347_0 -> bv
        let s_4347_1: Bits = Bits::new(s_4347_0 as u128, 3u16);
        // C s_4347_2: const #3u : u8
        let s_4347_2: u8 = 3;
        // C s_4347_3: cast zx s_4347_2 -> bv
        let s_4347_3: Bits = Bits::new(s_4347_2 as u128, 3u16);
        // D s_4347_4: cmp-eq s_4347_1 s_4347_3
        let s_4347_4: bool = ((s_4347_1) == (s_4347_3));
        // D s_4347_5: write-var gs#118607 <= s_4347_4
        fn_state.gs_118607 = s_4347_4;
        // N s_4347_6: jump b2384
        return block_2384(state, tracer, fn_state);
    }
    fn block_4348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4348_0: read-var opc1:u8
        let s_4348_0: u8 = fn_state.opc1;
        // D s_4348_1: cast zx s_4348_0 -> bv
        let s_4348_1: Bits = Bits::new(s_4348_0 as u128, 3u16);
        // C s_4348_2: const #0u : u8
        let s_4348_2: u8 = 0;
        // C s_4348_3: cast zx s_4348_2 -> bv
        let s_4348_3: Bits = Bits::new(s_4348_2 as u128, 3u16);
        // D s_4348_4: cmp-eq s_4348_1 s_4348_3
        let s_4348_4: bool = ((s_4348_1) == (s_4348_3));
        // D s_4348_5: write-var gs#118606 <= s_4348_4
        fn_state.gs_118606 = s_4348_4;
        // N s_4348_6: jump b2382
        return block_2382(state, tracer, fn_state);
    }
    fn block_4349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4349_0: read-var coproc:u8
        let s_4349_0: u8 = fn_state.coproc;
        // D s_4349_1: cast zx s_4349_0 -> bv
        let s_4349_1: Bits = Bits::new(s_4349_0 as u128, 4u16);
        // C s_4349_2: const #15u : u8
        let s_4349_2: u8 = 15;
        // C s_4349_3: cast zx s_4349_2 -> bv
        let s_4349_3: Bits = Bits::new(s_4349_2 as u128, 4u16);
        // D s_4349_4: cmp-eq s_4349_1 s_4349_3
        let s_4349_4: bool = ((s_4349_1) == (s_4349_3));
        // D s_4349_5: write-var gs#118605 <= s_4349_4
        fn_state.gs_118605 = s_4349_4;
        // N s_4349_6: jump b2380
        return block_2380(state, tracer, fn_state);
    }
    fn block_4350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4350_0: read-var CRn:u8
        let s_4350_0: u8 = fn_state.CRn;
        // D s_4350_1: cast zx s_4350_0 -> bv
        let s_4350_1: Bits = Bits::new(s_4350_0 as u128, 4u16);
        // C s_4350_2: const #0u : u8
        let s_4350_2: u8 = 0;
        // C s_4350_3: cast zx s_4350_2 -> bv
        let s_4350_3: Bits = Bits::new(s_4350_2 as u128, 4u16);
        // D s_4350_4: cmp-eq s_4350_1 s_4350_3
        let s_4350_4: bool = ((s_4350_1) == (s_4350_3));
        // D s_4350_5: write-var gs#118604 <= s_4350_4
        fn_state.gs_118604 = s_4350_4;
        // N s_4350_6: jump b2378
        return block_2378(state, tracer, fn_state);
    }
    fn block_4351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4351_0: read-var el:u8
        let s_4351_0: u8 = fn_state.el;
        // D s_4351_1: read-var coproc:u8
        let s_4351_1: u8 = fn_state.coproc;
        // D s_4351_2: read-var opc1:u8
        let s_4351_2: u8 = fn_state.opc1;
        // D s_4351_3: read-var CRn:u8
        let s_4351_3: u8 = fn_state.CRn;
        // D s_4351_4: read-var opc2:u8
        let s_4351_4: u8 = fn_state.opc2;
        // D s_4351_5: read-var CRm:u8
        let s_4351_5: u8 = fn_state.CRm;
        // D s_4351_6: read-var t:i
        let s_4351_6: i128 = fn_state.t;
        // D s_4351_7: call ICC_MGRPEN1_SysRegRead32_92bbab53b6030359(s_4351_0, s_4351_1, s_4351_2, s_4351_3, s_4351_4, s_4351_5, s_4351_6)
        let s_4351_7: () = ICC_MGRPEN1_SysRegRead32_92bbab53b6030359(
            state,
            tracer,
            s_4351_0,
            s_4351_1,
            s_4351_2,
            s_4351_3,
            s_4351_4,
            s_4351_5,
            s_4351_6,
        );
        // N s_4351_8: return
        return;
    }
    fn block_4352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4352_0: read-var opc2:u8
        let s_4352_0: u8 = fn_state.opc2;
        // D s_4352_1: cast zx s_4352_0 -> bv
        let s_4352_1: Bits = Bits::new(s_4352_0 as u128, 3u16);
        // C s_4352_2: const #7u : u8
        let s_4352_2: u8 = 7;
        // C s_4352_3: cast zx s_4352_2 -> bv
        let s_4352_3: Bits = Bits::new(s_4352_2 as u128, 3u16);
        // D s_4352_4: cmp-eq s_4352_1 s_4352_3
        let s_4352_4: bool = ((s_4352_1) == (s_4352_3));
        // D s_4352_5: write-var gs#118603 <= s_4352_4
        fn_state.gs_118603 = s_4352_4;
        // N s_4352_6: jump b2375
        return block_2375(state, tracer, fn_state);
    }
    fn block_4353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4353_0: read-var opc1:u8
        let s_4353_0: u8 = fn_state.opc1;
        // D s_4353_1: cast zx s_4353_0 -> bv
        let s_4353_1: Bits = Bits::new(s_4353_0 as u128, 3u16);
        // C s_4353_2: const #6u : u8
        let s_4353_2: u8 = 6;
        // C s_4353_3: cast zx s_4353_2 -> bv
        let s_4353_3: Bits = Bits::new(s_4353_2 as u128, 3u16);
        // D s_4353_4: cmp-eq s_4353_1 s_4353_3
        let s_4353_4: bool = ((s_4353_1) == (s_4353_3));
        // D s_4353_5: write-var gs#118602 <= s_4353_4
        fn_state.gs_118602 = s_4353_4;
        // N s_4353_6: jump b2373
        return block_2373(state, tracer, fn_state);
    }
    fn block_4354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4354_0: read-var coproc:u8
        let s_4354_0: u8 = fn_state.coproc;
        // D s_4354_1: cast zx s_4354_0 -> bv
        let s_4354_1: Bits = Bits::new(s_4354_0 as u128, 4u16);
        // C s_4354_2: const #15u : u8
        let s_4354_2: u8 = 15;
        // C s_4354_3: cast zx s_4354_2 -> bv
        let s_4354_3: Bits = Bits::new(s_4354_2 as u128, 4u16);
        // D s_4354_4: cmp-eq s_4354_1 s_4354_3
        let s_4354_4: bool = ((s_4354_1) == (s_4354_3));
        // D s_4354_5: write-var gs#118601 <= s_4354_4
        fn_state.gs_118601 = s_4354_4;
        // N s_4354_6: jump b2371
        return block_2371(state, tracer, fn_state);
    }
    fn block_4355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4355_0: read-var CRn:u8
        let s_4355_0: u8 = fn_state.CRn;
        // D s_4355_1: cast zx s_4355_0 -> bv
        let s_4355_1: Bits = Bits::new(s_4355_0 as u128, 4u16);
        // C s_4355_2: const #12u : u8
        let s_4355_2: u8 = 12;
        // C s_4355_3: cast zx s_4355_2 -> bv
        let s_4355_3: Bits = Bits::new(s_4355_2 as u128, 4u16);
        // D s_4355_4: cmp-eq s_4355_1 s_4355_3
        let s_4355_4: bool = ((s_4355_1) == (s_4355_3));
        // D s_4355_5: write-var gs#118600 <= s_4355_4
        fn_state.gs_118600 = s_4355_4;
        // N s_4355_6: jump b2369
        return block_2369(state, tracer, fn_state);
    }
    fn block_4356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4356_0: read-var el:u8
        let s_4356_0: u8 = fn_state.el;
        // D s_4356_1: read-var coproc:u8
        let s_4356_1: u8 = fn_state.coproc;
        // D s_4356_2: read-var opc1:u8
        let s_4356_2: u8 = fn_state.opc1;
        // D s_4356_3: read-var CRn:u8
        let s_4356_3: u8 = fn_state.CRn;
        // D s_4356_4: read-var opc2:u8
        let s_4356_4: u8 = fn_state.opc2;
        // D s_4356_5: read-var CRm:u8
        let s_4356_5: u8 = fn_state.CRm;
        // D s_4356_6: read-var t:i
        let s_4356_6: i128 = fn_state.t;
        // D s_4356_7: call VTCR_SysRegRead32_23b906196b602c93(s_4356_0, s_4356_1, s_4356_2, s_4356_3, s_4356_4, s_4356_5, s_4356_6)
        let s_4356_7: () = VTCR_SysRegRead32_23b906196b602c93(
            state,
            tracer,
            s_4356_0,
            s_4356_1,
            s_4356_2,
            s_4356_3,
            s_4356_4,
            s_4356_5,
            s_4356_6,
        );
        // N s_4356_8: return
        return;
    }
    fn block_4357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4357_0: read-var opc2:u8
        let s_4357_0: u8 = fn_state.opc2;
        // D s_4357_1: cast zx s_4357_0 -> bv
        let s_4357_1: Bits = Bits::new(s_4357_0 as u128, 3u16);
        // C s_4357_2: const #2u : u8
        let s_4357_2: u8 = 2;
        // C s_4357_3: cast zx s_4357_2 -> bv
        let s_4357_3: Bits = Bits::new(s_4357_2 as u128, 3u16);
        // D s_4357_4: cmp-eq s_4357_1 s_4357_3
        let s_4357_4: bool = ((s_4357_1) == (s_4357_3));
        // D s_4357_5: write-var gs#118599 <= s_4357_4
        fn_state.gs_118599 = s_4357_4;
        // N s_4357_6: jump b2366
        return block_2366(state, tracer, fn_state);
    }
    fn block_4358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4358_0: read-var opc1:u8
        let s_4358_0: u8 = fn_state.opc1;
        // D s_4358_1: cast zx s_4358_0 -> bv
        let s_4358_1: Bits = Bits::new(s_4358_0 as u128, 3u16);
        // C s_4358_2: const #4u : u8
        let s_4358_2: u8 = 4;
        // C s_4358_3: cast zx s_4358_2 -> bv
        let s_4358_3: Bits = Bits::new(s_4358_2 as u128, 3u16);
        // D s_4358_4: cmp-eq s_4358_1 s_4358_3
        let s_4358_4: bool = ((s_4358_1) == (s_4358_3));
        // D s_4358_5: write-var gs#118598 <= s_4358_4
        fn_state.gs_118598 = s_4358_4;
        // N s_4358_6: jump b2364
        return block_2364(state, tracer, fn_state);
    }
    fn block_4359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4359_0: read-var coproc:u8
        let s_4359_0: u8 = fn_state.coproc;
        // D s_4359_1: cast zx s_4359_0 -> bv
        let s_4359_1: Bits = Bits::new(s_4359_0 as u128, 4u16);
        // C s_4359_2: const #15u : u8
        let s_4359_2: u8 = 15;
        // C s_4359_3: cast zx s_4359_2 -> bv
        let s_4359_3: Bits = Bits::new(s_4359_2 as u128, 4u16);
        // D s_4359_4: cmp-eq s_4359_1 s_4359_3
        let s_4359_4: bool = ((s_4359_1) == (s_4359_3));
        // D s_4359_5: write-var gs#118597 <= s_4359_4
        fn_state.gs_118597 = s_4359_4;
        // N s_4359_6: jump b2362
        return block_2362(state, tracer, fn_state);
    }
    fn block_4360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4360_0: read-var CRn:u8
        let s_4360_0: u8 = fn_state.CRn;
        // D s_4360_1: cast zx s_4360_0 -> bv
        let s_4360_1: Bits = Bits::new(s_4360_0 as u128, 4u16);
        // C s_4360_2: const #2u : u8
        let s_4360_2: u8 = 2;
        // C s_4360_3: cast zx s_4360_2 -> bv
        let s_4360_3: Bits = Bits::new(s_4360_2 as u128, 4u16);
        // D s_4360_4: cmp-eq s_4360_1 s_4360_3
        let s_4360_4: bool = ((s_4360_1) == (s_4360_3));
        // D s_4360_5: write-var gs#118596 <= s_4360_4
        fn_state.gs_118596 = s_4360_4;
        // N s_4360_6: jump b2360
        return block_2360(state, tracer, fn_state);
    }
    fn block_4361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4361_0: read-var el:u8
        let s_4361_0: u8 = fn_state.el;
        // D s_4361_1: read-var coproc:u8
        let s_4361_1: u8 = fn_state.coproc;
        // D s_4361_2: read-var opc1:u8
        let s_4361_2: u8 = fn_state.opc1;
        // D s_4361_3: read-var CRn:u8
        let s_4361_3: u8 = fn_state.CRn;
        // D s_4361_4: read-var opc2:u8
        let s_4361_4: u8 = fn_state.opc2;
        // D s_4361_5: read-var CRm:u8
        let s_4361_5: u8 = fn_state.CRm;
        // D s_4361_6: read-var t:i
        let s_4361_6: i128 = fn_state.t;
        // D s_4361_7: call ID_ISAR3_SysRegRead32_417ae56f4d3a61c8(s_4361_0, s_4361_1, s_4361_2, s_4361_3, s_4361_4, s_4361_5, s_4361_6)
        let s_4361_7: () = ID_ISAR3_SysRegRead32_417ae56f4d3a61c8(
            state,
            tracer,
            s_4361_0,
            s_4361_1,
            s_4361_2,
            s_4361_3,
            s_4361_4,
            s_4361_5,
            s_4361_6,
        );
        // N s_4361_8: return
        return;
    }
    fn block_4362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4362_0: read-var opc2:u8
        let s_4362_0: u8 = fn_state.opc2;
        // D s_4362_1: cast zx s_4362_0 -> bv
        let s_4362_1: Bits = Bits::new(s_4362_0 as u128, 3u16);
        // C s_4362_2: const #3u : u8
        let s_4362_2: u8 = 3;
        // C s_4362_3: cast zx s_4362_2 -> bv
        let s_4362_3: Bits = Bits::new(s_4362_2 as u128, 3u16);
        // D s_4362_4: cmp-eq s_4362_1 s_4362_3
        let s_4362_4: bool = ((s_4362_1) == (s_4362_3));
        // D s_4362_5: write-var gs#118595 <= s_4362_4
        fn_state.gs_118595 = s_4362_4;
        // N s_4362_6: jump b2357
        return block_2357(state, tracer, fn_state);
    }
    fn block_4363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4363_0: read-var opc1:u8
        let s_4363_0: u8 = fn_state.opc1;
        // D s_4363_1: cast zx s_4363_0 -> bv
        let s_4363_1: Bits = Bits::new(s_4363_0 as u128, 3u16);
        // C s_4363_2: const #0u : u8
        let s_4363_2: u8 = 0;
        // C s_4363_3: cast zx s_4363_2 -> bv
        let s_4363_3: Bits = Bits::new(s_4363_2 as u128, 3u16);
        // D s_4363_4: cmp-eq s_4363_1 s_4363_3
        let s_4363_4: bool = ((s_4363_1) == (s_4363_3));
        // D s_4363_5: write-var gs#118594 <= s_4363_4
        fn_state.gs_118594 = s_4363_4;
        // N s_4363_6: jump b2355
        return block_2355(state, tracer, fn_state);
    }
    fn block_4364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4364_0: read-var coproc:u8
        let s_4364_0: u8 = fn_state.coproc;
        // D s_4364_1: cast zx s_4364_0 -> bv
        let s_4364_1: Bits = Bits::new(s_4364_0 as u128, 4u16);
        // C s_4364_2: const #15u : u8
        let s_4364_2: u8 = 15;
        // C s_4364_3: cast zx s_4364_2 -> bv
        let s_4364_3: Bits = Bits::new(s_4364_2 as u128, 4u16);
        // D s_4364_4: cmp-eq s_4364_1 s_4364_3
        let s_4364_4: bool = ((s_4364_1) == (s_4364_3));
        // D s_4364_5: write-var gs#118593 <= s_4364_4
        fn_state.gs_118593 = s_4364_4;
        // N s_4364_6: jump b2353
        return block_2353(state, tracer, fn_state);
    }
    fn block_4365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4365_0: read-var CRn:u8
        let s_4365_0: u8 = fn_state.CRn;
        // D s_4365_1: cast zx s_4365_0 -> bv
        let s_4365_1: Bits = Bits::new(s_4365_0 as u128, 4u16);
        // C s_4365_2: const #0u : u8
        let s_4365_2: u8 = 0;
        // C s_4365_3: cast zx s_4365_2 -> bv
        let s_4365_3: Bits = Bits::new(s_4365_2 as u128, 4u16);
        // D s_4365_4: cmp-eq s_4365_1 s_4365_3
        let s_4365_4: bool = ((s_4365_1) == (s_4365_3));
        // D s_4365_5: write-var gs#118592 <= s_4365_4
        fn_state.gs_118592 = s_4365_4;
        // N s_4365_6: jump b2351
        return block_2351(state, tracer, fn_state);
    }
    fn block_4366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4366_0: read-var el:u8
        let s_4366_0: u8 = fn_state.el;
        // D s_4366_1: read-var coproc:u8
        let s_4366_1: u8 = fn_state.coproc;
        // D s_4366_2: read-var opc1:u8
        let s_4366_2: u8 = fn_state.opc1;
        // D s_4366_3: read-var CRn:u8
        let s_4366_3: u8 = fn_state.CRn;
        // D s_4366_4: read-var opc2:u8
        let s_4366_4: u8 = fn_state.opc2;
        // D s_4366_5: read-var CRm:u8
        let s_4366_5: u8 = fn_state.CRm;
        // D s_4366_6: read-var t:i
        let s_4366_6: i128 = fn_state.t;
        // D s_4366_7: call HSCTLR_SysRegRead32_7d1999deb1c478b9(s_4366_0, s_4366_1, s_4366_2, s_4366_3, s_4366_4, s_4366_5, s_4366_6)
        let s_4366_7: () = HSCTLR_SysRegRead32_7d1999deb1c478b9(
            state,
            tracer,
            s_4366_0,
            s_4366_1,
            s_4366_2,
            s_4366_3,
            s_4366_4,
            s_4366_5,
            s_4366_6,
        );
        // N s_4366_8: return
        return;
    }
    fn block_4367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4367_0: read-var opc2:u8
        let s_4367_0: u8 = fn_state.opc2;
        // D s_4367_1: cast zx s_4367_0 -> bv
        let s_4367_1: Bits = Bits::new(s_4367_0 as u128, 3u16);
        // C s_4367_2: const #0u : u8
        let s_4367_2: u8 = 0;
        // C s_4367_3: cast zx s_4367_2 -> bv
        let s_4367_3: Bits = Bits::new(s_4367_2 as u128, 3u16);
        // D s_4367_4: cmp-eq s_4367_1 s_4367_3
        let s_4367_4: bool = ((s_4367_1) == (s_4367_3));
        // D s_4367_5: write-var gs#118591 <= s_4367_4
        fn_state.gs_118591 = s_4367_4;
        // N s_4367_6: jump b2348
        return block_2348(state, tracer, fn_state);
    }
    fn block_4368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4368_0: read-var opc1:u8
        let s_4368_0: u8 = fn_state.opc1;
        // D s_4368_1: cast zx s_4368_0 -> bv
        let s_4368_1: Bits = Bits::new(s_4368_0 as u128, 3u16);
        // C s_4368_2: const #4u : u8
        let s_4368_2: u8 = 4;
        // C s_4368_3: cast zx s_4368_2 -> bv
        let s_4368_3: Bits = Bits::new(s_4368_2 as u128, 3u16);
        // D s_4368_4: cmp-eq s_4368_1 s_4368_3
        let s_4368_4: bool = ((s_4368_1) == (s_4368_3));
        // D s_4368_5: write-var gs#118590 <= s_4368_4
        fn_state.gs_118590 = s_4368_4;
        // N s_4368_6: jump b2346
        return block_2346(state, tracer, fn_state);
    }
    fn block_4369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4369_0: read-var coproc:u8
        let s_4369_0: u8 = fn_state.coproc;
        // D s_4369_1: cast zx s_4369_0 -> bv
        let s_4369_1: Bits = Bits::new(s_4369_0 as u128, 4u16);
        // C s_4369_2: const #15u : u8
        let s_4369_2: u8 = 15;
        // C s_4369_3: cast zx s_4369_2 -> bv
        let s_4369_3: Bits = Bits::new(s_4369_2 as u128, 4u16);
        // D s_4369_4: cmp-eq s_4369_1 s_4369_3
        let s_4369_4: bool = ((s_4369_1) == (s_4369_3));
        // D s_4369_5: write-var gs#118589 <= s_4369_4
        fn_state.gs_118589 = s_4369_4;
        // N s_4369_6: jump b2344
        return block_2344(state, tracer, fn_state);
    }
    fn block_4370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4370_0: read-var CRn:u8
        let s_4370_0: u8 = fn_state.CRn;
        // D s_4370_1: cast zx s_4370_0 -> bv
        let s_4370_1: Bits = Bits::new(s_4370_0 as u128, 4u16);
        // C s_4370_2: const #1u : u8
        let s_4370_2: u8 = 1;
        // C s_4370_3: cast zx s_4370_2 -> bv
        let s_4370_3: Bits = Bits::new(s_4370_2 as u128, 4u16);
        // D s_4370_4: cmp-eq s_4370_1 s_4370_3
        let s_4370_4: bool = ((s_4370_1) == (s_4370_3));
        // D s_4370_5: write-var gs#118588 <= s_4370_4
        fn_state.gs_118588 = s_4370_4;
        // N s_4370_6: jump b2342
        return block_2342(state, tracer, fn_state);
    }
    fn block_4371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4371_0: read-var el:u8
        let s_4371_0: u8 = fn_state.el;
        // D s_4371_1: read-var coproc:u8
        let s_4371_1: u8 = fn_state.coproc;
        // D s_4371_2: read-var opc1:u8
        let s_4371_2: u8 = fn_state.opc1;
        // D s_4371_3: read-var CRn:u8
        let s_4371_3: u8 = fn_state.CRn;
        // D s_4371_4: read-var opc2:u8
        let s_4371_4: u8 = fn_state.opc2;
        // D s_4371_5: read-var CRm:u8
        let s_4371_5: u8 = fn_state.CRm;
        // D s_4371_6: read-var t:i
        let s_4371_6: i128 = fn_state.t;
        // D s_4371_7: call DBGWFAR_SysRegRead32_eb3aaa02963f85c2(s_4371_0, s_4371_1, s_4371_2, s_4371_3, s_4371_4, s_4371_5, s_4371_6)
        let s_4371_7: () = DBGWFAR_SysRegRead32_eb3aaa02963f85c2(
            state,
            tracer,
            s_4371_0,
            s_4371_1,
            s_4371_2,
            s_4371_3,
            s_4371_4,
            s_4371_5,
            s_4371_6,
        );
        // N s_4371_8: return
        return;
    }
    fn block_4372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4372_0: read-var opc2:u8
        let s_4372_0: u8 = fn_state.opc2;
        // D s_4372_1: cast zx s_4372_0 -> bv
        let s_4372_1: Bits = Bits::new(s_4372_0 as u128, 3u16);
        // C s_4372_2: const #0u : u8
        let s_4372_2: u8 = 0;
        // C s_4372_3: cast zx s_4372_2 -> bv
        let s_4372_3: Bits = Bits::new(s_4372_2 as u128, 3u16);
        // D s_4372_4: cmp-eq s_4372_1 s_4372_3
        let s_4372_4: bool = ((s_4372_1) == (s_4372_3));
        // D s_4372_5: write-var gs#118587 <= s_4372_4
        fn_state.gs_118587 = s_4372_4;
        // N s_4372_6: jump b2339
        return block_2339(state, tracer, fn_state);
    }
    fn block_4373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4373_0: read-var opc1:u8
        let s_4373_0: u8 = fn_state.opc1;
        // D s_4373_1: cast zx s_4373_0 -> bv
        let s_4373_1: Bits = Bits::new(s_4373_0 as u128, 3u16);
        // C s_4373_2: const #0u : u8
        let s_4373_2: u8 = 0;
        // C s_4373_3: cast zx s_4373_2 -> bv
        let s_4373_3: Bits = Bits::new(s_4373_2 as u128, 3u16);
        // D s_4373_4: cmp-eq s_4373_1 s_4373_3
        let s_4373_4: bool = ((s_4373_1) == (s_4373_3));
        // D s_4373_5: write-var gs#118586 <= s_4373_4
        fn_state.gs_118586 = s_4373_4;
        // N s_4373_6: jump b2337
        return block_2337(state, tracer, fn_state);
    }
    fn block_4374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4374_0: read-var coproc:u8
        let s_4374_0: u8 = fn_state.coproc;
        // D s_4374_1: cast zx s_4374_0 -> bv
        let s_4374_1: Bits = Bits::new(s_4374_0 as u128, 4u16);
        // C s_4374_2: const #14u : u8
        let s_4374_2: u8 = 14;
        // C s_4374_3: cast zx s_4374_2 -> bv
        let s_4374_3: Bits = Bits::new(s_4374_2 as u128, 4u16);
        // D s_4374_4: cmp-eq s_4374_1 s_4374_3
        let s_4374_4: bool = ((s_4374_1) == (s_4374_3));
        // D s_4374_5: write-var gs#118585 <= s_4374_4
        fn_state.gs_118585 = s_4374_4;
        // N s_4374_6: jump b2335
        return block_2335(state, tracer, fn_state);
    }
    fn block_4375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4375_0: read-var CRn:u8
        let s_4375_0: u8 = fn_state.CRn;
        // D s_4375_1: cast zx s_4375_0 -> bv
        let s_4375_1: Bits = Bits::new(s_4375_0 as u128, 4u16);
        // C s_4375_2: const #0u : u8
        let s_4375_2: u8 = 0;
        // C s_4375_3: cast zx s_4375_2 -> bv
        let s_4375_3: Bits = Bits::new(s_4375_2 as u128, 4u16);
        // D s_4375_4: cmp-eq s_4375_1 s_4375_3
        let s_4375_4: bool = ((s_4375_1) == (s_4375_3));
        // D s_4375_5: write-var gs#118584 <= s_4375_4
        fn_state.gs_118584 = s_4375_4;
        // N s_4375_6: jump b2333
        return block_2333(state, tracer, fn_state);
    }
    fn block_4376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4376_0: read-var el:u8
        let s_4376_0: u8 = fn_state.el;
        // D s_4376_1: read-var coproc:u8
        let s_4376_1: u8 = fn_state.coproc;
        // D s_4376_2: read-var opc1:u8
        let s_4376_2: u8 = fn_state.opc1;
        // D s_4376_3: read-var CRn:u8
        let s_4376_3: u8 = fn_state.CRn;
        // D s_4376_4: read-var opc2:u8
        let s_4376_4: u8 = fn_state.opc2;
        // D s_4376_5: read-var CRm:u8
        let s_4376_5: u8 = fn_state.CRm;
        // D s_4376_6: read-var t:i
        let s_4376_6: i128 = fn_state.t;
        // D s_4376_7: call DBGBCR_SysRegRead32_2c7e30fbae6d4b48(s_4376_0, s_4376_1, s_4376_2, s_4376_3, s_4376_4, s_4376_5, s_4376_6)
        let s_4376_7: () = DBGBCR_SysRegRead32_2c7e30fbae6d4b48(
            state,
            tracer,
            s_4376_0,
            s_4376_1,
            s_4376_2,
            s_4376_3,
            s_4376_4,
            s_4376_5,
            s_4376_6,
        );
        // N s_4376_8: return
        return;
    }
    fn block_4377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4377_0: read-var opc2:u8
        let s_4377_0: u8 = fn_state.opc2;
        // D s_4377_1: cast zx s_4377_0 -> bv
        let s_4377_1: Bits = Bits::new(s_4377_0 as u128, 3u16);
        // C s_4377_2: const #5u : u8
        let s_4377_2: u8 = 5;
        // C s_4377_3: cast zx s_4377_2 -> bv
        let s_4377_3: Bits = Bits::new(s_4377_2 as u128, 3u16);
        // D s_4377_4: cmp-eq s_4377_1 s_4377_3
        let s_4377_4: bool = ((s_4377_1) == (s_4377_3));
        // D s_4377_5: write-var gs#118583 <= s_4377_4
        fn_state.gs_118583 = s_4377_4;
        // N s_4377_6: jump b2330
        return block_2330(state, tracer, fn_state);
    }
    fn block_4378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4378_0: read-var opc1:u8
        let s_4378_0: u8 = fn_state.opc1;
        // D s_4378_1: cast zx s_4378_0 -> bv
        let s_4378_1: Bits = Bits::new(s_4378_0 as u128, 3u16);
        // C s_4378_2: const #0u : u8
        let s_4378_2: u8 = 0;
        // C s_4378_3: cast zx s_4378_2 -> bv
        let s_4378_3: Bits = Bits::new(s_4378_2 as u128, 3u16);
        // D s_4378_4: cmp-eq s_4378_1 s_4378_3
        let s_4378_4: bool = ((s_4378_1) == (s_4378_3));
        // D s_4378_5: write-var gs#118582 <= s_4378_4
        fn_state.gs_118582 = s_4378_4;
        // N s_4378_6: jump b2328
        return block_2328(state, tracer, fn_state);
    }
    fn block_4379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4379_0: read-var coproc:u8
        let s_4379_0: u8 = fn_state.coproc;
        // D s_4379_1: cast zx s_4379_0 -> bv
        let s_4379_1: Bits = Bits::new(s_4379_0 as u128, 4u16);
        // C s_4379_2: const #14u : u8
        let s_4379_2: u8 = 14;
        // C s_4379_3: cast zx s_4379_2 -> bv
        let s_4379_3: Bits = Bits::new(s_4379_2 as u128, 4u16);
        // D s_4379_4: cmp-eq s_4379_1 s_4379_3
        let s_4379_4: bool = ((s_4379_1) == (s_4379_3));
        // D s_4379_5: write-var gs#118581 <= s_4379_4
        fn_state.gs_118581 = s_4379_4;
        // N s_4379_6: jump b2326
        return block_2326(state, tracer, fn_state);
    }
    fn block_4380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4380_0: read-var CRn:u8
        let s_4380_0: u8 = fn_state.CRn;
        // D s_4380_1: cast zx s_4380_0 -> bv
        let s_4380_1: Bits = Bits::new(s_4380_0 as u128, 4u16);
        // C s_4380_2: const #0u : u8
        let s_4380_2: u8 = 0;
        // C s_4380_3: cast zx s_4380_2 -> bv
        let s_4380_3: Bits = Bits::new(s_4380_2 as u128, 4u16);
        // D s_4380_4: cmp-eq s_4380_1 s_4380_3
        let s_4380_4: bool = ((s_4380_1) == (s_4380_3));
        // D s_4380_5: write-var gs#118580 <= s_4380_4
        fn_state.gs_118580 = s_4380_4;
        // N s_4380_6: jump b2324
        return block_2324(state, tracer, fn_state);
    }
    fn block_4381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4381_0: read-var el:u8
        let s_4381_0: u8 = fn_state.el;
        // D s_4381_1: read-var coproc:u8
        let s_4381_1: u8 = fn_state.coproc;
        // D s_4381_2: read-var opc1:u8
        let s_4381_2: u8 = fn_state.opc1;
        // D s_4381_3: read-var CRn:u8
        let s_4381_3: u8 = fn_state.CRn;
        // D s_4381_4: read-var opc2:u8
        let s_4381_4: u8 = fn_state.opc2;
        // D s_4381_5: read-var CRm:u8
        let s_4381_5: u8 = fn_state.CRm;
        // D s_4381_6: read-var t:i
        let s_4381_6: i128 = fn_state.t;
        // D s_4381_7: call DBGBCR_SysRegRead32_0c66b90b6558a3cb(s_4381_0, s_4381_1, s_4381_2, s_4381_3, s_4381_4, s_4381_5, s_4381_6)
        let s_4381_7: () = DBGBCR_SysRegRead32_0c66b90b6558a3cb(
            state,
            tracer,
            s_4381_0,
            s_4381_1,
            s_4381_2,
            s_4381_3,
            s_4381_4,
            s_4381_5,
            s_4381_6,
        );
        // N s_4381_8: return
        return;
    }
    fn block_4382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4382_0: read-var opc2:u8
        let s_4382_0: u8 = fn_state.opc2;
        // D s_4382_1: cast zx s_4382_0 -> bv
        let s_4382_1: Bits = Bits::new(s_4382_0 as u128, 3u16);
        // C s_4382_2: const #5u : u8
        let s_4382_2: u8 = 5;
        // C s_4382_3: cast zx s_4382_2 -> bv
        let s_4382_3: Bits = Bits::new(s_4382_2 as u128, 3u16);
        // D s_4382_4: cmp-eq s_4382_1 s_4382_3
        let s_4382_4: bool = ((s_4382_1) == (s_4382_3));
        // D s_4382_5: write-var gs#118579 <= s_4382_4
        fn_state.gs_118579 = s_4382_4;
        // N s_4382_6: jump b2321
        return block_2321(state, tracer, fn_state);
    }
    fn block_4383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4383_0: read-var opc1:u8
        let s_4383_0: u8 = fn_state.opc1;
        // D s_4383_1: cast zx s_4383_0 -> bv
        let s_4383_1: Bits = Bits::new(s_4383_0 as u128, 3u16);
        // C s_4383_2: const #0u : u8
        let s_4383_2: u8 = 0;
        // C s_4383_3: cast zx s_4383_2 -> bv
        let s_4383_3: Bits = Bits::new(s_4383_2 as u128, 3u16);
        // D s_4383_4: cmp-eq s_4383_1 s_4383_3
        let s_4383_4: bool = ((s_4383_1) == (s_4383_3));
        // D s_4383_5: write-var gs#118578 <= s_4383_4
        fn_state.gs_118578 = s_4383_4;
        // N s_4383_6: jump b2319
        return block_2319(state, tracer, fn_state);
    }
    fn block_4384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4384_0: read-var coproc:u8
        let s_4384_0: u8 = fn_state.coproc;
        // D s_4384_1: cast zx s_4384_0 -> bv
        let s_4384_1: Bits = Bits::new(s_4384_0 as u128, 4u16);
        // C s_4384_2: const #14u : u8
        let s_4384_2: u8 = 14;
        // C s_4384_3: cast zx s_4384_2 -> bv
        let s_4384_3: Bits = Bits::new(s_4384_2 as u128, 4u16);
        // D s_4384_4: cmp-eq s_4384_1 s_4384_3
        let s_4384_4: bool = ((s_4384_1) == (s_4384_3));
        // D s_4384_5: write-var gs#118577 <= s_4384_4
        fn_state.gs_118577 = s_4384_4;
        // N s_4384_6: jump b2317
        return block_2317(state, tracer, fn_state);
    }
    fn block_4385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4385_0: read-var CRn:u8
        let s_4385_0: u8 = fn_state.CRn;
        // D s_4385_1: cast zx s_4385_0 -> bv
        let s_4385_1: Bits = Bits::new(s_4385_0 as u128, 4u16);
        // C s_4385_2: const #0u : u8
        let s_4385_2: u8 = 0;
        // C s_4385_3: cast zx s_4385_2 -> bv
        let s_4385_3: Bits = Bits::new(s_4385_2 as u128, 4u16);
        // D s_4385_4: cmp-eq s_4385_1 s_4385_3
        let s_4385_4: bool = ((s_4385_1) == (s_4385_3));
        // D s_4385_5: write-var gs#118576 <= s_4385_4
        fn_state.gs_118576 = s_4385_4;
        // N s_4385_6: jump b2315
        return block_2315(state, tracer, fn_state);
    }
    fn block_4386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4386_0: read-var el:u8
        let s_4386_0: u8 = fn_state.el;
        // D s_4386_1: read-var coproc:u8
        let s_4386_1: u8 = fn_state.coproc;
        // D s_4386_2: read-var opc1:u8
        let s_4386_2: u8 = fn_state.opc1;
        // D s_4386_3: read-var CRn:u8
        let s_4386_3: u8 = fn_state.CRn;
        // D s_4386_4: read-var opc2:u8
        let s_4386_4: u8 = fn_state.opc2;
        // D s_4386_5: read-var CRm:u8
        let s_4386_5: u8 = fn_state.CRm;
        // D s_4386_6: read-var t:i
        let s_4386_6: i128 = fn_state.t;
        // D s_4386_7: call DBGBCR_SysRegRead32_4aa006511c22539c(s_4386_0, s_4386_1, s_4386_2, s_4386_3, s_4386_4, s_4386_5, s_4386_6)
        let s_4386_7: () = DBGBCR_SysRegRead32_4aa006511c22539c(
            state,
            tracer,
            s_4386_0,
            s_4386_1,
            s_4386_2,
            s_4386_3,
            s_4386_4,
            s_4386_5,
            s_4386_6,
        );
        // N s_4386_8: return
        return;
    }
    fn block_4387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4387_0: read-var opc2:u8
        let s_4387_0: u8 = fn_state.opc2;
        // D s_4387_1: cast zx s_4387_0 -> bv
        let s_4387_1: Bits = Bits::new(s_4387_0 as u128, 3u16);
        // C s_4387_2: const #5u : u8
        let s_4387_2: u8 = 5;
        // C s_4387_3: cast zx s_4387_2 -> bv
        let s_4387_3: Bits = Bits::new(s_4387_2 as u128, 3u16);
        // D s_4387_4: cmp-eq s_4387_1 s_4387_3
        let s_4387_4: bool = ((s_4387_1) == (s_4387_3));
        // D s_4387_5: write-var gs#118575 <= s_4387_4
        fn_state.gs_118575 = s_4387_4;
        // N s_4387_6: jump b2312
        return block_2312(state, tracer, fn_state);
    }
    fn block_4388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4388_0: read-var opc1:u8
        let s_4388_0: u8 = fn_state.opc1;
        // D s_4388_1: cast zx s_4388_0 -> bv
        let s_4388_1: Bits = Bits::new(s_4388_0 as u128, 3u16);
        // C s_4388_2: const #0u : u8
        let s_4388_2: u8 = 0;
        // C s_4388_3: cast zx s_4388_2 -> bv
        let s_4388_3: Bits = Bits::new(s_4388_2 as u128, 3u16);
        // D s_4388_4: cmp-eq s_4388_1 s_4388_3
        let s_4388_4: bool = ((s_4388_1) == (s_4388_3));
        // D s_4388_5: write-var gs#118574 <= s_4388_4
        fn_state.gs_118574 = s_4388_4;
        // N s_4388_6: jump b2310
        return block_2310(state, tracer, fn_state);
    }
    fn block_4389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4389_0: read-var coproc:u8
        let s_4389_0: u8 = fn_state.coproc;
        // D s_4389_1: cast zx s_4389_0 -> bv
        let s_4389_1: Bits = Bits::new(s_4389_0 as u128, 4u16);
        // C s_4389_2: const #14u : u8
        let s_4389_2: u8 = 14;
        // C s_4389_3: cast zx s_4389_2 -> bv
        let s_4389_3: Bits = Bits::new(s_4389_2 as u128, 4u16);
        // D s_4389_4: cmp-eq s_4389_1 s_4389_3
        let s_4389_4: bool = ((s_4389_1) == (s_4389_3));
        // D s_4389_5: write-var gs#118573 <= s_4389_4
        fn_state.gs_118573 = s_4389_4;
        // N s_4389_6: jump b2308
        return block_2308(state, tracer, fn_state);
    }
    fn block_4390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4390_0: read-var CRn:u8
        let s_4390_0: u8 = fn_state.CRn;
        // D s_4390_1: cast zx s_4390_0 -> bv
        let s_4390_1: Bits = Bits::new(s_4390_0 as u128, 4u16);
        // C s_4390_2: const #0u : u8
        let s_4390_2: u8 = 0;
        // C s_4390_3: cast zx s_4390_2 -> bv
        let s_4390_3: Bits = Bits::new(s_4390_2 as u128, 4u16);
        // D s_4390_4: cmp-eq s_4390_1 s_4390_3
        let s_4390_4: bool = ((s_4390_1) == (s_4390_3));
        // D s_4390_5: write-var gs#118572 <= s_4390_4
        fn_state.gs_118572 = s_4390_4;
        // N s_4390_6: jump b2306
        return block_2306(state, tracer, fn_state);
    }
    fn block_4391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4391_0: read-var el:u8
        let s_4391_0: u8 = fn_state.el;
        // D s_4391_1: read-var coproc:u8
        let s_4391_1: u8 = fn_state.coproc;
        // D s_4391_2: read-var opc1:u8
        let s_4391_2: u8 = fn_state.opc1;
        // D s_4391_3: read-var CRn:u8
        let s_4391_3: u8 = fn_state.CRn;
        // D s_4391_4: read-var opc2:u8
        let s_4391_4: u8 = fn_state.opc2;
        // D s_4391_5: read-var CRm:u8
        let s_4391_5: u8 = fn_state.CRm;
        // D s_4391_6: read-var t:i
        let s_4391_6: i128 = fn_state.t;
        // D s_4391_7: call DBGBCR_SysRegRead32_4c18d60e0902660d(s_4391_0, s_4391_1, s_4391_2, s_4391_3, s_4391_4, s_4391_5, s_4391_6)
        let s_4391_7: () = DBGBCR_SysRegRead32_4c18d60e0902660d(
            state,
            tracer,
            s_4391_0,
            s_4391_1,
            s_4391_2,
            s_4391_3,
            s_4391_4,
            s_4391_5,
            s_4391_6,
        );
        // N s_4391_8: return
        return;
    }
    fn block_4392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4392_0: read-var opc2:u8
        let s_4392_0: u8 = fn_state.opc2;
        // D s_4392_1: cast zx s_4392_0 -> bv
        let s_4392_1: Bits = Bits::new(s_4392_0 as u128, 3u16);
        // C s_4392_2: const #5u : u8
        let s_4392_2: u8 = 5;
        // C s_4392_3: cast zx s_4392_2 -> bv
        let s_4392_3: Bits = Bits::new(s_4392_2 as u128, 3u16);
        // D s_4392_4: cmp-eq s_4392_1 s_4392_3
        let s_4392_4: bool = ((s_4392_1) == (s_4392_3));
        // D s_4392_5: write-var gs#118571 <= s_4392_4
        fn_state.gs_118571 = s_4392_4;
        // N s_4392_6: jump b2303
        return block_2303(state, tracer, fn_state);
    }
    fn block_4393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4393_0: read-var opc1:u8
        let s_4393_0: u8 = fn_state.opc1;
        // D s_4393_1: cast zx s_4393_0 -> bv
        let s_4393_1: Bits = Bits::new(s_4393_0 as u128, 3u16);
        // C s_4393_2: const #0u : u8
        let s_4393_2: u8 = 0;
        // C s_4393_3: cast zx s_4393_2 -> bv
        let s_4393_3: Bits = Bits::new(s_4393_2 as u128, 3u16);
        // D s_4393_4: cmp-eq s_4393_1 s_4393_3
        let s_4393_4: bool = ((s_4393_1) == (s_4393_3));
        // D s_4393_5: write-var gs#118570 <= s_4393_4
        fn_state.gs_118570 = s_4393_4;
        // N s_4393_6: jump b2301
        return block_2301(state, tracer, fn_state);
    }
    fn block_4394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4394_0: read-var coproc:u8
        let s_4394_0: u8 = fn_state.coproc;
        // D s_4394_1: cast zx s_4394_0 -> bv
        let s_4394_1: Bits = Bits::new(s_4394_0 as u128, 4u16);
        // C s_4394_2: const #14u : u8
        let s_4394_2: u8 = 14;
        // C s_4394_3: cast zx s_4394_2 -> bv
        let s_4394_3: Bits = Bits::new(s_4394_2 as u128, 4u16);
        // D s_4394_4: cmp-eq s_4394_1 s_4394_3
        let s_4394_4: bool = ((s_4394_1) == (s_4394_3));
        // D s_4394_5: write-var gs#118569 <= s_4394_4
        fn_state.gs_118569 = s_4394_4;
        // N s_4394_6: jump b2299
        return block_2299(state, tracer, fn_state);
    }
    fn block_4395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4395_0: read-var CRn:u8
        let s_4395_0: u8 = fn_state.CRn;
        // D s_4395_1: cast zx s_4395_0 -> bv
        let s_4395_1: Bits = Bits::new(s_4395_0 as u128, 4u16);
        // C s_4395_2: const #0u : u8
        let s_4395_2: u8 = 0;
        // C s_4395_3: cast zx s_4395_2 -> bv
        let s_4395_3: Bits = Bits::new(s_4395_2 as u128, 4u16);
        // D s_4395_4: cmp-eq s_4395_1 s_4395_3
        let s_4395_4: bool = ((s_4395_1) == (s_4395_3));
        // D s_4395_5: write-var gs#118568 <= s_4395_4
        fn_state.gs_118568 = s_4395_4;
        // N s_4395_6: jump b2297
        return block_2297(state, tracer, fn_state);
    }
    fn block_4396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4396_0: read-var el:u8
        let s_4396_0: u8 = fn_state.el;
        // D s_4396_1: read-var coproc:u8
        let s_4396_1: u8 = fn_state.coproc;
        // D s_4396_2: read-var opc1:u8
        let s_4396_2: u8 = fn_state.opc1;
        // D s_4396_3: read-var CRn:u8
        let s_4396_3: u8 = fn_state.CRn;
        // D s_4396_4: read-var opc2:u8
        let s_4396_4: u8 = fn_state.opc2;
        // D s_4396_5: read-var CRm:u8
        let s_4396_5: u8 = fn_state.CRm;
        // D s_4396_6: read-var t:i
        let s_4396_6: i128 = fn_state.t;
        // D s_4396_7: call DBGBCR_SysRegRead32_db1b198c49f933c0(s_4396_0, s_4396_1, s_4396_2, s_4396_3, s_4396_4, s_4396_5, s_4396_6)
        let s_4396_7: () = DBGBCR_SysRegRead32_db1b198c49f933c0(
            state,
            tracer,
            s_4396_0,
            s_4396_1,
            s_4396_2,
            s_4396_3,
            s_4396_4,
            s_4396_5,
            s_4396_6,
        );
        // N s_4396_8: return
        return;
    }
    fn block_4397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4397_0: read-var opc2:u8
        let s_4397_0: u8 = fn_state.opc2;
        // D s_4397_1: cast zx s_4397_0 -> bv
        let s_4397_1: Bits = Bits::new(s_4397_0 as u128, 3u16);
        // C s_4397_2: const #5u : u8
        let s_4397_2: u8 = 5;
        // C s_4397_3: cast zx s_4397_2 -> bv
        let s_4397_3: Bits = Bits::new(s_4397_2 as u128, 3u16);
        // D s_4397_4: cmp-eq s_4397_1 s_4397_3
        let s_4397_4: bool = ((s_4397_1) == (s_4397_3));
        // D s_4397_5: write-var gs#118567 <= s_4397_4
        fn_state.gs_118567 = s_4397_4;
        // N s_4397_6: jump b2294
        return block_2294(state, tracer, fn_state);
    }
    fn block_4398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4398_0: read-var opc1:u8
        let s_4398_0: u8 = fn_state.opc1;
        // D s_4398_1: cast zx s_4398_0 -> bv
        let s_4398_1: Bits = Bits::new(s_4398_0 as u128, 3u16);
        // C s_4398_2: const #0u : u8
        let s_4398_2: u8 = 0;
        // C s_4398_3: cast zx s_4398_2 -> bv
        let s_4398_3: Bits = Bits::new(s_4398_2 as u128, 3u16);
        // D s_4398_4: cmp-eq s_4398_1 s_4398_3
        let s_4398_4: bool = ((s_4398_1) == (s_4398_3));
        // D s_4398_5: write-var gs#118566 <= s_4398_4
        fn_state.gs_118566 = s_4398_4;
        // N s_4398_6: jump b2292
        return block_2292(state, tracer, fn_state);
    }
    fn block_4399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4399_0: read-var coproc:u8
        let s_4399_0: u8 = fn_state.coproc;
        // D s_4399_1: cast zx s_4399_0 -> bv
        let s_4399_1: Bits = Bits::new(s_4399_0 as u128, 4u16);
        // C s_4399_2: const #14u : u8
        let s_4399_2: u8 = 14;
        // C s_4399_3: cast zx s_4399_2 -> bv
        let s_4399_3: Bits = Bits::new(s_4399_2 as u128, 4u16);
        // D s_4399_4: cmp-eq s_4399_1 s_4399_3
        let s_4399_4: bool = ((s_4399_1) == (s_4399_3));
        // D s_4399_5: write-var gs#118565 <= s_4399_4
        fn_state.gs_118565 = s_4399_4;
        // N s_4399_6: jump b2290
        return block_2290(state, tracer, fn_state);
    }
    fn block_4400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4400_0: read-var CRn:u8
        let s_4400_0: u8 = fn_state.CRn;
        // D s_4400_1: cast zx s_4400_0 -> bv
        let s_4400_1: Bits = Bits::new(s_4400_0 as u128, 4u16);
        // C s_4400_2: const #0u : u8
        let s_4400_2: u8 = 0;
        // C s_4400_3: cast zx s_4400_2 -> bv
        let s_4400_3: Bits = Bits::new(s_4400_2 as u128, 4u16);
        // D s_4400_4: cmp-eq s_4400_1 s_4400_3
        let s_4400_4: bool = ((s_4400_1) == (s_4400_3));
        // D s_4400_5: write-var gs#118564 <= s_4400_4
        fn_state.gs_118564 = s_4400_4;
        // N s_4400_6: jump b2288
        return block_2288(state, tracer, fn_state);
    }
    fn block_4401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4401_0: read-var el:u8
        let s_4401_0: u8 = fn_state.el;
        // D s_4401_1: read-var coproc:u8
        let s_4401_1: u8 = fn_state.coproc;
        // D s_4401_2: read-var opc1:u8
        let s_4401_2: u8 = fn_state.opc1;
        // D s_4401_3: read-var CRn:u8
        let s_4401_3: u8 = fn_state.CRn;
        // D s_4401_4: read-var opc2:u8
        let s_4401_4: u8 = fn_state.opc2;
        // D s_4401_5: read-var CRm:u8
        let s_4401_5: u8 = fn_state.CRm;
        // D s_4401_6: read-var t:i
        let s_4401_6: i128 = fn_state.t;
        // D s_4401_7: call DBGBCR_SysRegRead32_524a8653177fde8f(s_4401_0, s_4401_1, s_4401_2, s_4401_3, s_4401_4, s_4401_5, s_4401_6)
        let s_4401_7: () = DBGBCR_SysRegRead32_524a8653177fde8f(
            state,
            tracer,
            s_4401_0,
            s_4401_1,
            s_4401_2,
            s_4401_3,
            s_4401_4,
            s_4401_5,
            s_4401_6,
        );
        // N s_4401_8: return
        return;
    }
    fn block_4402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4402_0: read-var opc2:u8
        let s_4402_0: u8 = fn_state.opc2;
        // D s_4402_1: cast zx s_4402_0 -> bv
        let s_4402_1: Bits = Bits::new(s_4402_0 as u128, 3u16);
        // C s_4402_2: const #5u : u8
        let s_4402_2: u8 = 5;
        // C s_4402_3: cast zx s_4402_2 -> bv
        let s_4402_3: Bits = Bits::new(s_4402_2 as u128, 3u16);
        // D s_4402_4: cmp-eq s_4402_1 s_4402_3
        let s_4402_4: bool = ((s_4402_1) == (s_4402_3));
        // D s_4402_5: write-var gs#118563 <= s_4402_4
        fn_state.gs_118563 = s_4402_4;
        // N s_4402_6: jump b2285
        return block_2285(state, tracer, fn_state);
    }
    fn block_4403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4403_0: read-var opc1:u8
        let s_4403_0: u8 = fn_state.opc1;
        // D s_4403_1: cast zx s_4403_0 -> bv
        let s_4403_1: Bits = Bits::new(s_4403_0 as u128, 3u16);
        // C s_4403_2: const #0u : u8
        let s_4403_2: u8 = 0;
        // C s_4403_3: cast zx s_4403_2 -> bv
        let s_4403_3: Bits = Bits::new(s_4403_2 as u128, 3u16);
        // D s_4403_4: cmp-eq s_4403_1 s_4403_3
        let s_4403_4: bool = ((s_4403_1) == (s_4403_3));
        // D s_4403_5: write-var gs#118562 <= s_4403_4
        fn_state.gs_118562 = s_4403_4;
        // N s_4403_6: jump b2283
        return block_2283(state, tracer, fn_state);
    }
    fn block_4404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4404_0: read-var coproc:u8
        let s_4404_0: u8 = fn_state.coproc;
        // D s_4404_1: cast zx s_4404_0 -> bv
        let s_4404_1: Bits = Bits::new(s_4404_0 as u128, 4u16);
        // C s_4404_2: const #14u : u8
        let s_4404_2: u8 = 14;
        // C s_4404_3: cast zx s_4404_2 -> bv
        let s_4404_3: Bits = Bits::new(s_4404_2 as u128, 4u16);
        // D s_4404_4: cmp-eq s_4404_1 s_4404_3
        let s_4404_4: bool = ((s_4404_1) == (s_4404_3));
        // D s_4404_5: write-var gs#118561 <= s_4404_4
        fn_state.gs_118561 = s_4404_4;
        // N s_4404_6: jump b2281
        return block_2281(state, tracer, fn_state);
    }
    fn block_4405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4405_0: read-var CRn:u8
        let s_4405_0: u8 = fn_state.CRn;
        // D s_4405_1: cast zx s_4405_0 -> bv
        let s_4405_1: Bits = Bits::new(s_4405_0 as u128, 4u16);
        // C s_4405_2: const #0u : u8
        let s_4405_2: u8 = 0;
        // C s_4405_3: cast zx s_4405_2 -> bv
        let s_4405_3: Bits = Bits::new(s_4405_2 as u128, 4u16);
        // D s_4405_4: cmp-eq s_4405_1 s_4405_3
        let s_4405_4: bool = ((s_4405_1) == (s_4405_3));
        // D s_4405_5: write-var gs#118560 <= s_4405_4
        fn_state.gs_118560 = s_4405_4;
        // N s_4405_6: jump b2279
        return block_2279(state, tracer, fn_state);
    }
    fn block_4406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4406_0: read-var el:u8
        let s_4406_0: u8 = fn_state.el;
        // D s_4406_1: read-var coproc:u8
        let s_4406_1: u8 = fn_state.coproc;
        // D s_4406_2: read-var opc1:u8
        let s_4406_2: u8 = fn_state.opc1;
        // D s_4406_3: read-var CRn:u8
        let s_4406_3: u8 = fn_state.CRn;
        // D s_4406_4: read-var opc2:u8
        let s_4406_4: u8 = fn_state.opc2;
        // D s_4406_5: read-var CRm:u8
        let s_4406_5: u8 = fn_state.CRm;
        // D s_4406_6: read-var t:i
        let s_4406_6: i128 = fn_state.t;
        // D s_4406_7: call DBGBCR_SysRegRead32_01c2798f5fc44bfa(s_4406_0, s_4406_1, s_4406_2, s_4406_3, s_4406_4, s_4406_5, s_4406_6)
        let s_4406_7: () = DBGBCR_SysRegRead32_01c2798f5fc44bfa(
            state,
            tracer,
            s_4406_0,
            s_4406_1,
            s_4406_2,
            s_4406_3,
            s_4406_4,
            s_4406_5,
            s_4406_6,
        );
        // N s_4406_8: return
        return;
    }
    fn block_4407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4407_0: read-var opc2:u8
        let s_4407_0: u8 = fn_state.opc2;
        // D s_4407_1: cast zx s_4407_0 -> bv
        let s_4407_1: Bits = Bits::new(s_4407_0 as u128, 3u16);
        // C s_4407_2: const #5u : u8
        let s_4407_2: u8 = 5;
        // C s_4407_3: cast zx s_4407_2 -> bv
        let s_4407_3: Bits = Bits::new(s_4407_2 as u128, 3u16);
        // D s_4407_4: cmp-eq s_4407_1 s_4407_3
        let s_4407_4: bool = ((s_4407_1) == (s_4407_3));
        // D s_4407_5: write-var gs#118559 <= s_4407_4
        fn_state.gs_118559 = s_4407_4;
        // N s_4407_6: jump b2276
        return block_2276(state, tracer, fn_state);
    }
    fn block_4408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4408_0: read-var opc1:u8
        let s_4408_0: u8 = fn_state.opc1;
        // D s_4408_1: cast zx s_4408_0 -> bv
        let s_4408_1: Bits = Bits::new(s_4408_0 as u128, 3u16);
        // C s_4408_2: const #0u : u8
        let s_4408_2: u8 = 0;
        // C s_4408_3: cast zx s_4408_2 -> bv
        let s_4408_3: Bits = Bits::new(s_4408_2 as u128, 3u16);
        // D s_4408_4: cmp-eq s_4408_1 s_4408_3
        let s_4408_4: bool = ((s_4408_1) == (s_4408_3));
        // D s_4408_5: write-var gs#118558 <= s_4408_4
        fn_state.gs_118558 = s_4408_4;
        // N s_4408_6: jump b2274
        return block_2274(state, tracer, fn_state);
    }
    fn block_4409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4409_0: read-var coproc:u8
        let s_4409_0: u8 = fn_state.coproc;
        // D s_4409_1: cast zx s_4409_0 -> bv
        let s_4409_1: Bits = Bits::new(s_4409_0 as u128, 4u16);
        // C s_4409_2: const #14u : u8
        let s_4409_2: u8 = 14;
        // C s_4409_3: cast zx s_4409_2 -> bv
        let s_4409_3: Bits = Bits::new(s_4409_2 as u128, 4u16);
        // D s_4409_4: cmp-eq s_4409_1 s_4409_3
        let s_4409_4: bool = ((s_4409_1) == (s_4409_3));
        // D s_4409_5: write-var gs#118557 <= s_4409_4
        fn_state.gs_118557 = s_4409_4;
        // N s_4409_6: jump b2272
        return block_2272(state, tracer, fn_state);
    }
    fn block_4410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4410_0: read-var CRn:u8
        let s_4410_0: u8 = fn_state.CRn;
        // D s_4410_1: cast zx s_4410_0 -> bv
        let s_4410_1: Bits = Bits::new(s_4410_0 as u128, 4u16);
        // C s_4410_2: const #0u : u8
        let s_4410_2: u8 = 0;
        // C s_4410_3: cast zx s_4410_2 -> bv
        let s_4410_3: Bits = Bits::new(s_4410_2 as u128, 4u16);
        // D s_4410_4: cmp-eq s_4410_1 s_4410_3
        let s_4410_4: bool = ((s_4410_1) == (s_4410_3));
        // D s_4410_5: write-var gs#118556 <= s_4410_4
        fn_state.gs_118556 = s_4410_4;
        // N s_4410_6: jump b2270
        return block_2270(state, tracer, fn_state);
    }
    fn block_4411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4411_0: read-var el:u8
        let s_4411_0: u8 = fn_state.el;
        // D s_4411_1: read-var coproc:u8
        let s_4411_1: u8 = fn_state.coproc;
        // D s_4411_2: read-var opc1:u8
        let s_4411_2: u8 = fn_state.opc1;
        // D s_4411_3: read-var CRn:u8
        let s_4411_3: u8 = fn_state.CRn;
        // D s_4411_4: read-var opc2:u8
        let s_4411_4: u8 = fn_state.opc2;
        // D s_4411_5: read-var CRm:u8
        let s_4411_5: u8 = fn_state.CRm;
        // D s_4411_6: read-var t:i
        let s_4411_6: i128 = fn_state.t;
        // D s_4411_7: call DBGBCR_SysRegRead32_e0d675a59f2b5c3e(s_4411_0, s_4411_1, s_4411_2, s_4411_3, s_4411_4, s_4411_5, s_4411_6)
        let s_4411_7: () = DBGBCR_SysRegRead32_e0d675a59f2b5c3e(
            state,
            tracer,
            s_4411_0,
            s_4411_1,
            s_4411_2,
            s_4411_3,
            s_4411_4,
            s_4411_5,
            s_4411_6,
        );
        // N s_4411_8: return
        return;
    }
    fn block_4412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4412_0: read-var opc2:u8
        let s_4412_0: u8 = fn_state.opc2;
        // D s_4412_1: cast zx s_4412_0 -> bv
        let s_4412_1: Bits = Bits::new(s_4412_0 as u128, 3u16);
        // C s_4412_2: const #5u : u8
        let s_4412_2: u8 = 5;
        // C s_4412_3: cast zx s_4412_2 -> bv
        let s_4412_3: Bits = Bits::new(s_4412_2 as u128, 3u16);
        // D s_4412_4: cmp-eq s_4412_1 s_4412_3
        let s_4412_4: bool = ((s_4412_1) == (s_4412_3));
        // D s_4412_5: write-var gs#118555 <= s_4412_4
        fn_state.gs_118555 = s_4412_4;
        // N s_4412_6: jump b2267
        return block_2267(state, tracer, fn_state);
    }
    fn block_4413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4413_0: read-var opc1:u8
        let s_4413_0: u8 = fn_state.opc1;
        // D s_4413_1: cast zx s_4413_0 -> bv
        let s_4413_1: Bits = Bits::new(s_4413_0 as u128, 3u16);
        // C s_4413_2: const #0u : u8
        let s_4413_2: u8 = 0;
        // C s_4413_3: cast zx s_4413_2 -> bv
        let s_4413_3: Bits = Bits::new(s_4413_2 as u128, 3u16);
        // D s_4413_4: cmp-eq s_4413_1 s_4413_3
        let s_4413_4: bool = ((s_4413_1) == (s_4413_3));
        // D s_4413_5: write-var gs#118554 <= s_4413_4
        fn_state.gs_118554 = s_4413_4;
        // N s_4413_6: jump b2265
        return block_2265(state, tracer, fn_state);
    }
    fn block_4414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4414_0: read-var coproc:u8
        let s_4414_0: u8 = fn_state.coproc;
        // D s_4414_1: cast zx s_4414_0 -> bv
        let s_4414_1: Bits = Bits::new(s_4414_0 as u128, 4u16);
        // C s_4414_2: const #14u : u8
        let s_4414_2: u8 = 14;
        // C s_4414_3: cast zx s_4414_2 -> bv
        let s_4414_3: Bits = Bits::new(s_4414_2 as u128, 4u16);
        // D s_4414_4: cmp-eq s_4414_1 s_4414_3
        let s_4414_4: bool = ((s_4414_1) == (s_4414_3));
        // D s_4414_5: write-var gs#118553 <= s_4414_4
        fn_state.gs_118553 = s_4414_4;
        // N s_4414_6: jump b2263
        return block_2263(state, tracer, fn_state);
    }
    fn block_4415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4415_0: read-var CRn:u8
        let s_4415_0: u8 = fn_state.CRn;
        // D s_4415_1: cast zx s_4415_0 -> bv
        let s_4415_1: Bits = Bits::new(s_4415_0 as u128, 4u16);
        // C s_4415_2: const #0u : u8
        let s_4415_2: u8 = 0;
        // C s_4415_3: cast zx s_4415_2 -> bv
        let s_4415_3: Bits = Bits::new(s_4415_2 as u128, 4u16);
        // D s_4415_4: cmp-eq s_4415_1 s_4415_3
        let s_4415_4: bool = ((s_4415_1) == (s_4415_3));
        // D s_4415_5: write-var gs#118552 <= s_4415_4
        fn_state.gs_118552 = s_4415_4;
        // N s_4415_6: jump b2261
        return block_2261(state, tracer, fn_state);
    }
    fn block_4416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4416_0: read-var el:u8
        let s_4416_0: u8 = fn_state.el;
        // D s_4416_1: read-var coproc:u8
        let s_4416_1: u8 = fn_state.coproc;
        // D s_4416_2: read-var opc1:u8
        let s_4416_2: u8 = fn_state.opc1;
        // D s_4416_3: read-var CRn:u8
        let s_4416_3: u8 = fn_state.CRn;
        // D s_4416_4: read-var opc2:u8
        let s_4416_4: u8 = fn_state.opc2;
        // D s_4416_5: read-var CRm:u8
        let s_4416_5: u8 = fn_state.CRm;
        // D s_4416_6: read-var t:i
        let s_4416_6: i128 = fn_state.t;
        // D s_4416_7: call DBGBCR_SysRegRead32_cdd1fd850dc45db5(s_4416_0, s_4416_1, s_4416_2, s_4416_3, s_4416_4, s_4416_5, s_4416_6)
        let s_4416_7: () = DBGBCR_SysRegRead32_cdd1fd850dc45db5(
            state,
            tracer,
            s_4416_0,
            s_4416_1,
            s_4416_2,
            s_4416_3,
            s_4416_4,
            s_4416_5,
            s_4416_6,
        );
        // N s_4416_8: return
        return;
    }
    fn block_4417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4417_0: read-var opc2:u8
        let s_4417_0: u8 = fn_state.opc2;
        // D s_4417_1: cast zx s_4417_0 -> bv
        let s_4417_1: Bits = Bits::new(s_4417_0 as u128, 3u16);
        // C s_4417_2: const #5u : u8
        let s_4417_2: u8 = 5;
        // C s_4417_3: cast zx s_4417_2 -> bv
        let s_4417_3: Bits = Bits::new(s_4417_2 as u128, 3u16);
        // D s_4417_4: cmp-eq s_4417_1 s_4417_3
        let s_4417_4: bool = ((s_4417_1) == (s_4417_3));
        // D s_4417_5: write-var gs#118551 <= s_4417_4
        fn_state.gs_118551 = s_4417_4;
        // N s_4417_6: jump b2258
        return block_2258(state, tracer, fn_state);
    }
    fn block_4418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4418_0: read-var opc1:u8
        let s_4418_0: u8 = fn_state.opc1;
        // D s_4418_1: cast zx s_4418_0 -> bv
        let s_4418_1: Bits = Bits::new(s_4418_0 as u128, 3u16);
        // C s_4418_2: const #0u : u8
        let s_4418_2: u8 = 0;
        // C s_4418_3: cast zx s_4418_2 -> bv
        let s_4418_3: Bits = Bits::new(s_4418_2 as u128, 3u16);
        // D s_4418_4: cmp-eq s_4418_1 s_4418_3
        let s_4418_4: bool = ((s_4418_1) == (s_4418_3));
        // D s_4418_5: write-var gs#118550 <= s_4418_4
        fn_state.gs_118550 = s_4418_4;
        // N s_4418_6: jump b2256
        return block_2256(state, tracer, fn_state);
    }
    fn block_4419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4419_0: read-var coproc:u8
        let s_4419_0: u8 = fn_state.coproc;
        // D s_4419_1: cast zx s_4419_0 -> bv
        let s_4419_1: Bits = Bits::new(s_4419_0 as u128, 4u16);
        // C s_4419_2: const #14u : u8
        let s_4419_2: u8 = 14;
        // C s_4419_3: cast zx s_4419_2 -> bv
        let s_4419_3: Bits = Bits::new(s_4419_2 as u128, 4u16);
        // D s_4419_4: cmp-eq s_4419_1 s_4419_3
        let s_4419_4: bool = ((s_4419_1) == (s_4419_3));
        // D s_4419_5: write-var gs#118549 <= s_4419_4
        fn_state.gs_118549 = s_4419_4;
        // N s_4419_6: jump b2254
        return block_2254(state, tracer, fn_state);
    }
    fn block_4420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4420_0: read-var CRn:u8
        let s_4420_0: u8 = fn_state.CRn;
        // D s_4420_1: cast zx s_4420_0 -> bv
        let s_4420_1: Bits = Bits::new(s_4420_0 as u128, 4u16);
        // C s_4420_2: const #0u : u8
        let s_4420_2: u8 = 0;
        // C s_4420_3: cast zx s_4420_2 -> bv
        let s_4420_3: Bits = Bits::new(s_4420_2 as u128, 4u16);
        // D s_4420_4: cmp-eq s_4420_1 s_4420_3
        let s_4420_4: bool = ((s_4420_1) == (s_4420_3));
        // D s_4420_5: write-var gs#118548 <= s_4420_4
        fn_state.gs_118548 = s_4420_4;
        // N s_4420_6: jump b2252
        return block_2252(state, tracer, fn_state);
    }
    fn block_4421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4421_0: read-var el:u8
        let s_4421_0: u8 = fn_state.el;
        // D s_4421_1: read-var coproc:u8
        let s_4421_1: u8 = fn_state.coproc;
        // D s_4421_2: read-var opc1:u8
        let s_4421_2: u8 = fn_state.opc1;
        // D s_4421_3: read-var CRn:u8
        let s_4421_3: u8 = fn_state.CRn;
        // D s_4421_4: read-var opc2:u8
        let s_4421_4: u8 = fn_state.opc2;
        // D s_4421_5: read-var CRm:u8
        let s_4421_5: u8 = fn_state.CRm;
        // D s_4421_6: read-var t:i
        let s_4421_6: i128 = fn_state.t;
        // D s_4421_7: call DBGBCR_SysRegRead32_2a19913e0ff50654(s_4421_0, s_4421_1, s_4421_2, s_4421_3, s_4421_4, s_4421_5, s_4421_6)
        let s_4421_7: () = DBGBCR_SysRegRead32_2a19913e0ff50654(
            state,
            tracer,
            s_4421_0,
            s_4421_1,
            s_4421_2,
            s_4421_3,
            s_4421_4,
            s_4421_5,
            s_4421_6,
        );
        // N s_4421_8: return
        return;
    }
    fn block_4422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4422_0: read-var opc2:u8
        let s_4422_0: u8 = fn_state.opc2;
        // D s_4422_1: cast zx s_4422_0 -> bv
        let s_4422_1: Bits = Bits::new(s_4422_0 as u128, 3u16);
        // C s_4422_2: const #5u : u8
        let s_4422_2: u8 = 5;
        // C s_4422_3: cast zx s_4422_2 -> bv
        let s_4422_3: Bits = Bits::new(s_4422_2 as u128, 3u16);
        // D s_4422_4: cmp-eq s_4422_1 s_4422_3
        let s_4422_4: bool = ((s_4422_1) == (s_4422_3));
        // D s_4422_5: write-var gs#118547 <= s_4422_4
        fn_state.gs_118547 = s_4422_4;
        // N s_4422_6: jump b2249
        return block_2249(state, tracer, fn_state);
    }
    fn block_4423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4423_0: read-var opc1:u8
        let s_4423_0: u8 = fn_state.opc1;
        // D s_4423_1: cast zx s_4423_0 -> bv
        let s_4423_1: Bits = Bits::new(s_4423_0 as u128, 3u16);
        // C s_4423_2: const #0u : u8
        let s_4423_2: u8 = 0;
        // C s_4423_3: cast zx s_4423_2 -> bv
        let s_4423_3: Bits = Bits::new(s_4423_2 as u128, 3u16);
        // D s_4423_4: cmp-eq s_4423_1 s_4423_3
        let s_4423_4: bool = ((s_4423_1) == (s_4423_3));
        // D s_4423_5: write-var gs#118546 <= s_4423_4
        fn_state.gs_118546 = s_4423_4;
        // N s_4423_6: jump b2247
        return block_2247(state, tracer, fn_state);
    }
    fn block_4424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4424_0: read-var coproc:u8
        let s_4424_0: u8 = fn_state.coproc;
        // D s_4424_1: cast zx s_4424_0 -> bv
        let s_4424_1: Bits = Bits::new(s_4424_0 as u128, 4u16);
        // C s_4424_2: const #14u : u8
        let s_4424_2: u8 = 14;
        // C s_4424_3: cast zx s_4424_2 -> bv
        let s_4424_3: Bits = Bits::new(s_4424_2 as u128, 4u16);
        // D s_4424_4: cmp-eq s_4424_1 s_4424_3
        let s_4424_4: bool = ((s_4424_1) == (s_4424_3));
        // D s_4424_5: write-var gs#118545 <= s_4424_4
        fn_state.gs_118545 = s_4424_4;
        // N s_4424_6: jump b2245
        return block_2245(state, tracer, fn_state);
    }
    fn block_4425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4425_0: read-var CRn:u8
        let s_4425_0: u8 = fn_state.CRn;
        // D s_4425_1: cast zx s_4425_0 -> bv
        let s_4425_1: Bits = Bits::new(s_4425_0 as u128, 4u16);
        // C s_4425_2: const #0u : u8
        let s_4425_2: u8 = 0;
        // C s_4425_3: cast zx s_4425_2 -> bv
        let s_4425_3: Bits = Bits::new(s_4425_2 as u128, 4u16);
        // D s_4425_4: cmp-eq s_4425_1 s_4425_3
        let s_4425_4: bool = ((s_4425_1) == (s_4425_3));
        // D s_4425_5: write-var gs#118544 <= s_4425_4
        fn_state.gs_118544 = s_4425_4;
        // N s_4425_6: jump b2243
        return block_2243(state, tracer, fn_state);
    }
    fn block_4426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4426_0: read-var el:u8
        let s_4426_0: u8 = fn_state.el;
        // D s_4426_1: read-var coproc:u8
        let s_4426_1: u8 = fn_state.coproc;
        // D s_4426_2: read-var opc1:u8
        let s_4426_2: u8 = fn_state.opc1;
        // D s_4426_3: read-var CRn:u8
        let s_4426_3: u8 = fn_state.CRn;
        // D s_4426_4: read-var opc2:u8
        let s_4426_4: u8 = fn_state.opc2;
        // D s_4426_5: read-var CRm:u8
        let s_4426_5: u8 = fn_state.CRm;
        // D s_4426_6: read-var t:i
        let s_4426_6: i128 = fn_state.t;
        // D s_4426_7: call DBGBCR_SysRegRead32_afe89ec5412ea81e(s_4426_0, s_4426_1, s_4426_2, s_4426_3, s_4426_4, s_4426_5, s_4426_6)
        let s_4426_7: () = DBGBCR_SysRegRead32_afe89ec5412ea81e(
            state,
            tracer,
            s_4426_0,
            s_4426_1,
            s_4426_2,
            s_4426_3,
            s_4426_4,
            s_4426_5,
            s_4426_6,
        );
        // N s_4426_8: return
        return;
    }
    fn block_4427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4427_0: read-var opc2:u8
        let s_4427_0: u8 = fn_state.opc2;
        // D s_4427_1: cast zx s_4427_0 -> bv
        let s_4427_1: Bits = Bits::new(s_4427_0 as u128, 3u16);
        // C s_4427_2: const #5u : u8
        let s_4427_2: u8 = 5;
        // C s_4427_3: cast zx s_4427_2 -> bv
        let s_4427_3: Bits = Bits::new(s_4427_2 as u128, 3u16);
        // D s_4427_4: cmp-eq s_4427_1 s_4427_3
        let s_4427_4: bool = ((s_4427_1) == (s_4427_3));
        // D s_4427_5: write-var gs#118543 <= s_4427_4
        fn_state.gs_118543 = s_4427_4;
        // N s_4427_6: jump b2240
        return block_2240(state, tracer, fn_state);
    }
    fn block_4428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4428_0: read-var opc1:u8
        let s_4428_0: u8 = fn_state.opc1;
        // D s_4428_1: cast zx s_4428_0 -> bv
        let s_4428_1: Bits = Bits::new(s_4428_0 as u128, 3u16);
        // C s_4428_2: const #0u : u8
        let s_4428_2: u8 = 0;
        // C s_4428_3: cast zx s_4428_2 -> bv
        let s_4428_3: Bits = Bits::new(s_4428_2 as u128, 3u16);
        // D s_4428_4: cmp-eq s_4428_1 s_4428_3
        let s_4428_4: bool = ((s_4428_1) == (s_4428_3));
        // D s_4428_5: write-var gs#118542 <= s_4428_4
        fn_state.gs_118542 = s_4428_4;
        // N s_4428_6: jump b2238
        return block_2238(state, tracer, fn_state);
    }
    fn block_4429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4429_0: read-var coproc:u8
        let s_4429_0: u8 = fn_state.coproc;
        // D s_4429_1: cast zx s_4429_0 -> bv
        let s_4429_1: Bits = Bits::new(s_4429_0 as u128, 4u16);
        // C s_4429_2: const #14u : u8
        let s_4429_2: u8 = 14;
        // C s_4429_3: cast zx s_4429_2 -> bv
        let s_4429_3: Bits = Bits::new(s_4429_2 as u128, 4u16);
        // D s_4429_4: cmp-eq s_4429_1 s_4429_3
        let s_4429_4: bool = ((s_4429_1) == (s_4429_3));
        // D s_4429_5: write-var gs#118541 <= s_4429_4
        fn_state.gs_118541 = s_4429_4;
        // N s_4429_6: jump b2236
        return block_2236(state, tracer, fn_state);
    }
    fn block_4430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4430_0: read-var CRn:u8
        let s_4430_0: u8 = fn_state.CRn;
        // D s_4430_1: cast zx s_4430_0 -> bv
        let s_4430_1: Bits = Bits::new(s_4430_0 as u128, 4u16);
        // C s_4430_2: const #0u : u8
        let s_4430_2: u8 = 0;
        // C s_4430_3: cast zx s_4430_2 -> bv
        let s_4430_3: Bits = Bits::new(s_4430_2 as u128, 4u16);
        // D s_4430_4: cmp-eq s_4430_1 s_4430_3
        let s_4430_4: bool = ((s_4430_1) == (s_4430_3));
        // D s_4430_5: write-var gs#118540 <= s_4430_4
        fn_state.gs_118540 = s_4430_4;
        // N s_4430_6: jump b2234
        return block_2234(state, tracer, fn_state);
    }
    fn block_4431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4431_0: read-var el:u8
        let s_4431_0: u8 = fn_state.el;
        // D s_4431_1: read-var coproc:u8
        let s_4431_1: u8 = fn_state.coproc;
        // D s_4431_2: read-var opc1:u8
        let s_4431_2: u8 = fn_state.opc1;
        // D s_4431_3: read-var CRn:u8
        let s_4431_3: u8 = fn_state.CRn;
        // D s_4431_4: read-var opc2:u8
        let s_4431_4: u8 = fn_state.opc2;
        // D s_4431_5: read-var CRm:u8
        let s_4431_5: u8 = fn_state.CRm;
        // D s_4431_6: read-var t:i
        let s_4431_6: i128 = fn_state.t;
        // D s_4431_7: call DBGBCR_SysRegRead32_f6f0a6ec5a19d902(s_4431_0, s_4431_1, s_4431_2, s_4431_3, s_4431_4, s_4431_5, s_4431_6)
        let s_4431_7: () = DBGBCR_SysRegRead32_f6f0a6ec5a19d902(
            state,
            tracer,
            s_4431_0,
            s_4431_1,
            s_4431_2,
            s_4431_3,
            s_4431_4,
            s_4431_5,
            s_4431_6,
        );
        // N s_4431_8: return
        return;
    }
    fn block_4432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4432_0: read-var opc2:u8
        let s_4432_0: u8 = fn_state.opc2;
        // D s_4432_1: cast zx s_4432_0 -> bv
        let s_4432_1: Bits = Bits::new(s_4432_0 as u128, 3u16);
        // C s_4432_2: const #5u : u8
        let s_4432_2: u8 = 5;
        // C s_4432_3: cast zx s_4432_2 -> bv
        let s_4432_3: Bits = Bits::new(s_4432_2 as u128, 3u16);
        // D s_4432_4: cmp-eq s_4432_1 s_4432_3
        let s_4432_4: bool = ((s_4432_1) == (s_4432_3));
        // D s_4432_5: write-var gs#118539 <= s_4432_4
        fn_state.gs_118539 = s_4432_4;
        // N s_4432_6: jump b2231
        return block_2231(state, tracer, fn_state);
    }
    fn block_4433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4433_0: read-var opc1:u8
        let s_4433_0: u8 = fn_state.opc1;
        // D s_4433_1: cast zx s_4433_0 -> bv
        let s_4433_1: Bits = Bits::new(s_4433_0 as u128, 3u16);
        // C s_4433_2: const #0u : u8
        let s_4433_2: u8 = 0;
        // C s_4433_3: cast zx s_4433_2 -> bv
        let s_4433_3: Bits = Bits::new(s_4433_2 as u128, 3u16);
        // D s_4433_4: cmp-eq s_4433_1 s_4433_3
        let s_4433_4: bool = ((s_4433_1) == (s_4433_3));
        // D s_4433_5: write-var gs#118538 <= s_4433_4
        fn_state.gs_118538 = s_4433_4;
        // N s_4433_6: jump b2229
        return block_2229(state, tracer, fn_state);
    }
    fn block_4434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4434_0: read-var coproc:u8
        let s_4434_0: u8 = fn_state.coproc;
        // D s_4434_1: cast zx s_4434_0 -> bv
        let s_4434_1: Bits = Bits::new(s_4434_0 as u128, 4u16);
        // C s_4434_2: const #14u : u8
        let s_4434_2: u8 = 14;
        // C s_4434_3: cast zx s_4434_2 -> bv
        let s_4434_3: Bits = Bits::new(s_4434_2 as u128, 4u16);
        // D s_4434_4: cmp-eq s_4434_1 s_4434_3
        let s_4434_4: bool = ((s_4434_1) == (s_4434_3));
        // D s_4434_5: write-var gs#118537 <= s_4434_4
        fn_state.gs_118537 = s_4434_4;
        // N s_4434_6: jump b2227
        return block_2227(state, tracer, fn_state);
    }
    fn block_4435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4435_0: read-var CRn:u8
        let s_4435_0: u8 = fn_state.CRn;
        // D s_4435_1: cast zx s_4435_0 -> bv
        let s_4435_1: Bits = Bits::new(s_4435_0 as u128, 4u16);
        // C s_4435_2: const #0u : u8
        let s_4435_2: u8 = 0;
        // C s_4435_3: cast zx s_4435_2 -> bv
        let s_4435_3: Bits = Bits::new(s_4435_2 as u128, 4u16);
        // D s_4435_4: cmp-eq s_4435_1 s_4435_3
        let s_4435_4: bool = ((s_4435_1) == (s_4435_3));
        // D s_4435_5: write-var gs#118536 <= s_4435_4
        fn_state.gs_118536 = s_4435_4;
        // N s_4435_6: jump b2225
        return block_2225(state, tracer, fn_state);
    }
    fn block_4436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4436_0: read-var el:u8
        let s_4436_0: u8 = fn_state.el;
        // D s_4436_1: read-var coproc:u8
        let s_4436_1: u8 = fn_state.coproc;
        // D s_4436_2: read-var opc1:u8
        let s_4436_2: u8 = fn_state.opc1;
        // D s_4436_3: read-var CRn:u8
        let s_4436_3: u8 = fn_state.CRn;
        // D s_4436_4: read-var opc2:u8
        let s_4436_4: u8 = fn_state.opc2;
        // D s_4436_5: read-var CRm:u8
        let s_4436_5: u8 = fn_state.CRm;
        // D s_4436_6: read-var t:i
        let s_4436_6: i128 = fn_state.t;
        // D s_4436_7: call DBGBCR_SysRegRead32_216d13962e754b99(s_4436_0, s_4436_1, s_4436_2, s_4436_3, s_4436_4, s_4436_5, s_4436_6)
        let s_4436_7: () = DBGBCR_SysRegRead32_216d13962e754b99(
            state,
            tracer,
            s_4436_0,
            s_4436_1,
            s_4436_2,
            s_4436_3,
            s_4436_4,
            s_4436_5,
            s_4436_6,
        );
        // N s_4436_8: return
        return;
    }
    fn block_4437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4437_0: read-var opc2:u8
        let s_4437_0: u8 = fn_state.opc2;
        // D s_4437_1: cast zx s_4437_0 -> bv
        let s_4437_1: Bits = Bits::new(s_4437_0 as u128, 3u16);
        // C s_4437_2: const #5u : u8
        let s_4437_2: u8 = 5;
        // C s_4437_3: cast zx s_4437_2 -> bv
        let s_4437_3: Bits = Bits::new(s_4437_2 as u128, 3u16);
        // D s_4437_4: cmp-eq s_4437_1 s_4437_3
        let s_4437_4: bool = ((s_4437_1) == (s_4437_3));
        // D s_4437_5: write-var gs#118535 <= s_4437_4
        fn_state.gs_118535 = s_4437_4;
        // N s_4437_6: jump b2222
        return block_2222(state, tracer, fn_state);
    }
    fn block_4438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4438_0: read-var opc1:u8
        let s_4438_0: u8 = fn_state.opc1;
        // D s_4438_1: cast zx s_4438_0 -> bv
        let s_4438_1: Bits = Bits::new(s_4438_0 as u128, 3u16);
        // C s_4438_2: const #0u : u8
        let s_4438_2: u8 = 0;
        // C s_4438_3: cast zx s_4438_2 -> bv
        let s_4438_3: Bits = Bits::new(s_4438_2 as u128, 3u16);
        // D s_4438_4: cmp-eq s_4438_1 s_4438_3
        let s_4438_4: bool = ((s_4438_1) == (s_4438_3));
        // D s_4438_5: write-var gs#118534 <= s_4438_4
        fn_state.gs_118534 = s_4438_4;
        // N s_4438_6: jump b2220
        return block_2220(state, tracer, fn_state);
    }
    fn block_4439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4439_0: read-var coproc:u8
        let s_4439_0: u8 = fn_state.coproc;
        // D s_4439_1: cast zx s_4439_0 -> bv
        let s_4439_1: Bits = Bits::new(s_4439_0 as u128, 4u16);
        // C s_4439_2: const #14u : u8
        let s_4439_2: u8 = 14;
        // C s_4439_3: cast zx s_4439_2 -> bv
        let s_4439_3: Bits = Bits::new(s_4439_2 as u128, 4u16);
        // D s_4439_4: cmp-eq s_4439_1 s_4439_3
        let s_4439_4: bool = ((s_4439_1) == (s_4439_3));
        // D s_4439_5: write-var gs#118533 <= s_4439_4
        fn_state.gs_118533 = s_4439_4;
        // N s_4439_6: jump b2218
        return block_2218(state, tracer, fn_state);
    }
    fn block_4440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4440_0: read-var CRn:u8
        let s_4440_0: u8 = fn_state.CRn;
        // D s_4440_1: cast zx s_4440_0 -> bv
        let s_4440_1: Bits = Bits::new(s_4440_0 as u128, 4u16);
        // C s_4440_2: const #0u : u8
        let s_4440_2: u8 = 0;
        // C s_4440_3: cast zx s_4440_2 -> bv
        let s_4440_3: Bits = Bits::new(s_4440_2 as u128, 4u16);
        // D s_4440_4: cmp-eq s_4440_1 s_4440_3
        let s_4440_4: bool = ((s_4440_1) == (s_4440_3));
        // D s_4440_5: write-var gs#118532 <= s_4440_4
        fn_state.gs_118532 = s_4440_4;
        // N s_4440_6: jump b2216
        return block_2216(state, tracer, fn_state);
    }
    fn block_4441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4441_0: read-var el:u8
        let s_4441_0: u8 = fn_state.el;
        // D s_4441_1: read-var coproc:u8
        let s_4441_1: u8 = fn_state.coproc;
        // D s_4441_2: read-var opc1:u8
        let s_4441_2: u8 = fn_state.opc1;
        // D s_4441_3: read-var CRn:u8
        let s_4441_3: u8 = fn_state.CRn;
        // D s_4441_4: read-var opc2:u8
        let s_4441_4: u8 = fn_state.opc2;
        // D s_4441_5: read-var CRm:u8
        let s_4441_5: u8 = fn_state.CRm;
        // D s_4441_6: read-var t:i
        let s_4441_6: i128 = fn_state.t;
        // D s_4441_7: call DBGBCR_SysRegRead32_8fb0687c13a9ae99(s_4441_0, s_4441_1, s_4441_2, s_4441_3, s_4441_4, s_4441_5, s_4441_6)
        let s_4441_7: () = DBGBCR_SysRegRead32_8fb0687c13a9ae99(
            state,
            tracer,
            s_4441_0,
            s_4441_1,
            s_4441_2,
            s_4441_3,
            s_4441_4,
            s_4441_5,
            s_4441_6,
        );
        // N s_4441_8: return
        return;
    }
    fn block_4442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4442_0: read-var opc2:u8
        let s_4442_0: u8 = fn_state.opc2;
        // D s_4442_1: cast zx s_4442_0 -> bv
        let s_4442_1: Bits = Bits::new(s_4442_0 as u128, 3u16);
        // C s_4442_2: const #5u : u8
        let s_4442_2: u8 = 5;
        // C s_4442_3: cast zx s_4442_2 -> bv
        let s_4442_3: Bits = Bits::new(s_4442_2 as u128, 3u16);
        // D s_4442_4: cmp-eq s_4442_1 s_4442_3
        let s_4442_4: bool = ((s_4442_1) == (s_4442_3));
        // D s_4442_5: write-var gs#118531 <= s_4442_4
        fn_state.gs_118531 = s_4442_4;
        // N s_4442_6: jump b2213
        return block_2213(state, tracer, fn_state);
    }
    fn block_4443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4443_0: read-var opc1:u8
        let s_4443_0: u8 = fn_state.opc1;
        // D s_4443_1: cast zx s_4443_0 -> bv
        let s_4443_1: Bits = Bits::new(s_4443_0 as u128, 3u16);
        // C s_4443_2: const #0u : u8
        let s_4443_2: u8 = 0;
        // C s_4443_3: cast zx s_4443_2 -> bv
        let s_4443_3: Bits = Bits::new(s_4443_2 as u128, 3u16);
        // D s_4443_4: cmp-eq s_4443_1 s_4443_3
        let s_4443_4: bool = ((s_4443_1) == (s_4443_3));
        // D s_4443_5: write-var gs#118530 <= s_4443_4
        fn_state.gs_118530 = s_4443_4;
        // N s_4443_6: jump b2211
        return block_2211(state, tracer, fn_state);
    }
    fn block_4444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4444_0: read-var coproc:u8
        let s_4444_0: u8 = fn_state.coproc;
        // D s_4444_1: cast zx s_4444_0 -> bv
        let s_4444_1: Bits = Bits::new(s_4444_0 as u128, 4u16);
        // C s_4444_2: const #14u : u8
        let s_4444_2: u8 = 14;
        // C s_4444_3: cast zx s_4444_2 -> bv
        let s_4444_3: Bits = Bits::new(s_4444_2 as u128, 4u16);
        // D s_4444_4: cmp-eq s_4444_1 s_4444_3
        let s_4444_4: bool = ((s_4444_1) == (s_4444_3));
        // D s_4444_5: write-var gs#118529 <= s_4444_4
        fn_state.gs_118529 = s_4444_4;
        // N s_4444_6: jump b2209
        return block_2209(state, tracer, fn_state);
    }
    fn block_4445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4445_0: read-var CRn:u8
        let s_4445_0: u8 = fn_state.CRn;
        // D s_4445_1: cast zx s_4445_0 -> bv
        let s_4445_1: Bits = Bits::new(s_4445_0 as u128, 4u16);
        // C s_4445_2: const #0u : u8
        let s_4445_2: u8 = 0;
        // C s_4445_3: cast zx s_4445_2 -> bv
        let s_4445_3: Bits = Bits::new(s_4445_2 as u128, 4u16);
        // D s_4445_4: cmp-eq s_4445_1 s_4445_3
        let s_4445_4: bool = ((s_4445_1) == (s_4445_3));
        // D s_4445_5: write-var gs#118528 <= s_4445_4
        fn_state.gs_118528 = s_4445_4;
        // N s_4445_6: jump b2207
        return block_2207(state, tracer, fn_state);
    }
    fn block_4446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4446_0: read-var el:u8
        let s_4446_0: u8 = fn_state.el;
        // D s_4446_1: read-var coproc:u8
        let s_4446_1: u8 = fn_state.coproc;
        // D s_4446_2: read-var opc1:u8
        let s_4446_2: u8 = fn_state.opc1;
        // D s_4446_3: read-var CRn:u8
        let s_4446_3: u8 = fn_state.CRn;
        // D s_4446_4: read-var opc2:u8
        let s_4446_4: u8 = fn_state.opc2;
        // D s_4446_5: read-var CRm:u8
        let s_4446_5: u8 = fn_state.CRm;
        // D s_4446_6: read-var t:i
        let s_4446_6: i128 = fn_state.t;
        // D s_4446_7: call DBGBCR_SysRegRead32_5711831aec3ae94d(s_4446_0, s_4446_1, s_4446_2, s_4446_3, s_4446_4, s_4446_5, s_4446_6)
        let s_4446_7: () = DBGBCR_SysRegRead32_5711831aec3ae94d(
            state,
            tracer,
            s_4446_0,
            s_4446_1,
            s_4446_2,
            s_4446_3,
            s_4446_4,
            s_4446_5,
            s_4446_6,
        );
        // N s_4446_8: return
        return;
    }
    fn block_4447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4447_0: read-var opc2:u8
        let s_4447_0: u8 = fn_state.opc2;
        // D s_4447_1: cast zx s_4447_0 -> bv
        let s_4447_1: Bits = Bits::new(s_4447_0 as u128, 3u16);
        // C s_4447_2: const #5u : u8
        let s_4447_2: u8 = 5;
        // C s_4447_3: cast zx s_4447_2 -> bv
        let s_4447_3: Bits = Bits::new(s_4447_2 as u128, 3u16);
        // D s_4447_4: cmp-eq s_4447_1 s_4447_3
        let s_4447_4: bool = ((s_4447_1) == (s_4447_3));
        // D s_4447_5: write-var gs#118527 <= s_4447_4
        fn_state.gs_118527 = s_4447_4;
        // N s_4447_6: jump b2204
        return block_2204(state, tracer, fn_state);
    }
    fn block_4448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4448_0: read-var opc1:u8
        let s_4448_0: u8 = fn_state.opc1;
        // D s_4448_1: cast zx s_4448_0 -> bv
        let s_4448_1: Bits = Bits::new(s_4448_0 as u128, 3u16);
        // C s_4448_2: const #0u : u8
        let s_4448_2: u8 = 0;
        // C s_4448_3: cast zx s_4448_2 -> bv
        let s_4448_3: Bits = Bits::new(s_4448_2 as u128, 3u16);
        // D s_4448_4: cmp-eq s_4448_1 s_4448_3
        let s_4448_4: bool = ((s_4448_1) == (s_4448_3));
        // D s_4448_5: write-var gs#118526 <= s_4448_4
        fn_state.gs_118526 = s_4448_4;
        // N s_4448_6: jump b2202
        return block_2202(state, tracer, fn_state);
    }
    fn block_4449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4449_0: read-var coproc:u8
        let s_4449_0: u8 = fn_state.coproc;
        // D s_4449_1: cast zx s_4449_0 -> bv
        let s_4449_1: Bits = Bits::new(s_4449_0 as u128, 4u16);
        // C s_4449_2: const #14u : u8
        let s_4449_2: u8 = 14;
        // C s_4449_3: cast zx s_4449_2 -> bv
        let s_4449_3: Bits = Bits::new(s_4449_2 as u128, 4u16);
        // D s_4449_4: cmp-eq s_4449_1 s_4449_3
        let s_4449_4: bool = ((s_4449_1) == (s_4449_3));
        // D s_4449_5: write-var gs#118525 <= s_4449_4
        fn_state.gs_118525 = s_4449_4;
        // N s_4449_6: jump b2200
        return block_2200(state, tracer, fn_state);
    }
    fn block_4450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4450_0: read-var CRn:u8
        let s_4450_0: u8 = fn_state.CRn;
        // D s_4450_1: cast zx s_4450_0 -> bv
        let s_4450_1: Bits = Bits::new(s_4450_0 as u128, 4u16);
        // C s_4450_2: const #0u : u8
        let s_4450_2: u8 = 0;
        // C s_4450_3: cast zx s_4450_2 -> bv
        let s_4450_3: Bits = Bits::new(s_4450_2 as u128, 4u16);
        // D s_4450_4: cmp-eq s_4450_1 s_4450_3
        let s_4450_4: bool = ((s_4450_1) == (s_4450_3));
        // D s_4450_5: write-var gs#118524 <= s_4450_4
        fn_state.gs_118524 = s_4450_4;
        // N s_4450_6: jump b2198
        return block_2198(state, tracer, fn_state);
    }
    fn block_4451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4451_0: read-var el:u8
        let s_4451_0: u8 = fn_state.el;
        // D s_4451_1: read-var coproc:u8
        let s_4451_1: u8 = fn_state.coproc;
        // D s_4451_2: read-var opc1:u8
        let s_4451_2: u8 = fn_state.opc1;
        // D s_4451_3: read-var CRn:u8
        let s_4451_3: u8 = fn_state.CRn;
        // D s_4451_4: read-var opc2:u8
        let s_4451_4: u8 = fn_state.opc2;
        // D s_4451_5: read-var CRm:u8
        let s_4451_5: u8 = fn_state.CRm;
        // D s_4451_6: read-var t:i
        let s_4451_6: i128 = fn_state.t;
        // D s_4451_7: call DBGBCR_SysRegRead32_cbd47314947043c8(s_4451_0, s_4451_1, s_4451_2, s_4451_3, s_4451_4, s_4451_5, s_4451_6)
        let s_4451_7: () = DBGBCR_SysRegRead32_cbd47314947043c8(
            state,
            tracer,
            s_4451_0,
            s_4451_1,
            s_4451_2,
            s_4451_3,
            s_4451_4,
            s_4451_5,
            s_4451_6,
        );
        // N s_4451_8: return
        return;
    }
    fn block_4452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4452_0: read-var opc2:u8
        let s_4452_0: u8 = fn_state.opc2;
        // D s_4452_1: cast zx s_4452_0 -> bv
        let s_4452_1: Bits = Bits::new(s_4452_0 as u128, 3u16);
        // C s_4452_2: const #5u : u8
        let s_4452_2: u8 = 5;
        // C s_4452_3: cast zx s_4452_2 -> bv
        let s_4452_3: Bits = Bits::new(s_4452_2 as u128, 3u16);
        // D s_4452_4: cmp-eq s_4452_1 s_4452_3
        let s_4452_4: bool = ((s_4452_1) == (s_4452_3));
        // D s_4452_5: write-var gs#118523 <= s_4452_4
        fn_state.gs_118523 = s_4452_4;
        // N s_4452_6: jump b2195
        return block_2195(state, tracer, fn_state);
    }
    fn block_4453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4453_0: read-var opc1:u8
        let s_4453_0: u8 = fn_state.opc1;
        // D s_4453_1: cast zx s_4453_0 -> bv
        let s_4453_1: Bits = Bits::new(s_4453_0 as u128, 3u16);
        // C s_4453_2: const #0u : u8
        let s_4453_2: u8 = 0;
        // C s_4453_3: cast zx s_4453_2 -> bv
        let s_4453_3: Bits = Bits::new(s_4453_2 as u128, 3u16);
        // D s_4453_4: cmp-eq s_4453_1 s_4453_3
        let s_4453_4: bool = ((s_4453_1) == (s_4453_3));
        // D s_4453_5: write-var gs#118522 <= s_4453_4
        fn_state.gs_118522 = s_4453_4;
        // N s_4453_6: jump b2193
        return block_2193(state, tracer, fn_state);
    }
    fn block_4454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4454_0: read-var coproc:u8
        let s_4454_0: u8 = fn_state.coproc;
        // D s_4454_1: cast zx s_4454_0 -> bv
        let s_4454_1: Bits = Bits::new(s_4454_0 as u128, 4u16);
        // C s_4454_2: const #14u : u8
        let s_4454_2: u8 = 14;
        // C s_4454_3: cast zx s_4454_2 -> bv
        let s_4454_3: Bits = Bits::new(s_4454_2 as u128, 4u16);
        // D s_4454_4: cmp-eq s_4454_1 s_4454_3
        let s_4454_4: bool = ((s_4454_1) == (s_4454_3));
        // D s_4454_5: write-var gs#118521 <= s_4454_4
        fn_state.gs_118521 = s_4454_4;
        // N s_4454_6: jump b2191
        return block_2191(state, tracer, fn_state);
    }
    fn block_4455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4455_0: read-var CRn:u8
        let s_4455_0: u8 = fn_state.CRn;
        // D s_4455_1: cast zx s_4455_0 -> bv
        let s_4455_1: Bits = Bits::new(s_4455_0 as u128, 4u16);
        // C s_4455_2: const #0u : u8
        let s_4455_2: u8 = 0;
        // C s_4455_3: cast zx s_4455_2 -> bv
        let s_4455_3: Bits = Bits::new(s_4455_2 as u128, 4u16);
        // D s_4455_4: cmp-eq s_4455_1 s_4455_3
        let s_4455_4: bool = ((s_4455_1) == (s_4455_3));
        // D s_4455_5: write-var gs#118520 <= s_4455_4
        fn_state.gs_118520 = s_4455_4;
        // N s_4455_6: jump b2189
        return block_2189(state, tracer, fn_state);
    }
    fn block_4456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4456_0: read-var el:u8
        let s_4456_0: u8 = fn_state.el;
        // D s_4456_1: read-var coproc:u8
        let s_4456_1: u8 = fn_state.coproc;
        // D s_4456_2: read-var opc1:u8
        let s_4456_2: u8 = fn_state.opc1;
        // D s_4456_3: read-var CRn:u8
        let s_4456_3: u8 = fn_state.CRn;
        // D s_4456_4: read-var opc2:u8
        let s_4456_4: u8 = fn_state.opc2;
        // D s_4456_5: read-var CRm:u8
        let s_4456_5: u8 = fn_state.CRm;
        // D s_4456_6: read-var t:i
        let s_4456_6: i128 = fn_state.t;
        // D s_4456_7: call PMOVSSET_SysRegRead32_c13d421fe8504cc2(s_4456_0, s_4456_1, s_4456_2, s_4456_3, s_4456_4, s_4456_5, s_4456_6)
        let s_4456_7: () = PMOVSSET_SysRegRead32_c13d421fe8504cc2(
            state,
            tracer,
            s_4456_0,
            s_4456_1,
            s_4456_2,
            s_4456_3,
            s_4456_4,
            s_4456_5,
            s_4456_6,
        );
        // N s_4456_8: return
        return;
    }
    fn block_4457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4457_0: read-var opc2:u8
        let s_4457_0: u8 = fn_state.opc2;
        // D s_4457_1: cast zx s_4457_0 -> bv
        let s_4457_1: Bits = Bits::new(s_4457_0 as u128, 3u16);
        // C s_4457_2: const #3u : u8
        let s_4457_2: u8 = 3;
        // C s_4457_3: cast zx s_4457_2 -> bv
        let s_4457_3: Bits = Bits::new(s_4457_2 as u128, 3u16);
        // D s_4457_4: cmp-eq s_4457_1 s_4457_3
        let s_4457_4: bool = ((s_4457_1) == (s_4457_3));
        // D s_4457_5: write-var gs#118519 <= s_4457_4
        fn_state.gs_118519 = s_4457_4;
        // N s_4457_6: jump b2186
        return block_2186(state, tracer, fn_state);
    }
    fn block_4458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4458_0: read-var opc1:u8
        let s_4458_0: u8 = fn_state.opc1;
        // D s_4458_1: cast zx s_4458_0 -> bv
        let s_4458_1: Bits = Bits::new(s_4458_0 as u128, 3u16);
        // C s_4458_2: const #0u : u8
        let s_4458_2: u8 = 0;
        // C s_4458_3: cast zx s_4458_2 -> bv
        let s_4458_3: Bits = Bits::new(s_4458_2 as u128, 3u16);
        // D s_4458_4: cmp-eq s_4458_1 s_4458_3
        let s_4458_4: bool = ((s_4458_1) == (s_4458_3));
        // D s_4458_5: write-var gs#118518 <= s_4458_4
        fn_state.gs_118518 = s_4458_4;
        // N s_4458_6: jump b2184
        return block_2184(state, tracer, fn_state);
    }
    fn block_4459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4459_0: read-var coproc:u8
        let s_4459_0: u8 = fn_state.coproc;
        // D s_4459_1: cast zx s_4459_0 -> bv
        let s_4459_1: Bits = Bits::new(s_4459_0 as u128, 4u16);
        // C s_4459_2: const #15u : u8
        let s_4459_2: u8 = 15;
        // C s_4459_3: cast zx s_4459_2 -> bv
        let s_4459_3: Bits = Bits::new(s_4459_2 as u128, 4u16);
        // D s_4459_4: cmp-eq s_4459_1 s_4459_3
        let s_4459_4: bool = ((s_4459_1) == (s_4459_3));
        // D s_4459_5: write-var gs#118517 <= s_4459_4
        fn_state.gs_118517 = s_4459_4;
        // N s_4459_6: jump b2182
        return block_2182(state, tracer, fn_state);
    }
    fn block_4460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4460_0: read-var CRn:u8
        let s_4460_0: u8 = fn_state.CRn;
        // D s_4460_1: cast zx s_4460_0 -> bv
        let s_4460_1: Bits = Bits::new(s_4460_0 as u128, 4u16);
        // C s_4460_2: const #9u : u8
        let s_4460_2: u8 = 9;
        // C s_4460_3: cast zx s_4460_2 -> bv
        let s_4460_3: Bits = Bits::new(s_4460_2 as u128, 4u16);
        // D s_4460_4: cmp-eq s_4460_1 s_4460_3
        let s_4460_4: bool = ((s_4460_1) == (s_4460_3));
        // D s_4460_5: write-var gs#118516 <= s_4460_4
        fn_state.gs_118516 = s_4460_4;
        // N s_4460_6: jump b2180
        return block_2180(state, tracer, fn_state);
    }
    fn block_4461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4461_0: read-var el:u8
        let s_4461_0: u8 = fn_state.el;
        // D s_4461_1: read-var coproc:u8
        let s_4461_1: u8 = fn_state.coproc;
        // D s_4461_2: read-var opc1:u8
        let s_4461_2: u8 = fn_state.opc1;
        // D s_4461_3: read-var CRn:u8
        let s_4461_3: u8 = fn_state.CRn;
        // D s_4461_4: read-var opc2:u8
        let s_4461_4: u8 = fn_state.opc2;
        // D s_4461_5: read-var CRm:u8
        let s_4461_5: u8 = fn_state.CRm;
        // D s_4461_6: read-var t:i
        let s_4461_6: i128 = fn_state.t;
        // D s_4461_7: call CNTKCTL_SysRegRead32_9166ed3878001f60(s_4461_0, s_4461_1, s_4461_2, s_4461_3, s_4461_4, s_4461_5, s_4461_6)
        let s_4461_7: () = CNTKCTL_SysRegRead32_9166ed3878001f60(
            state,
            tracer,
            s_4461_0,
            s_4461_1,
            s_4461_2,
            s_4461_3,
            s_4461_4,
            s_4461_5,
            s_4461_6,
        );
        // N s_4461_8: return
        return;
    }
    fn block_4462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4462_0: read-var opc2:u8
        let s_4462_0: u8 = fn_state.opc2;
        // D s_4462_1: cast zx s_4462_0 -> bv
        let s_4462_1: Bits = Bits::new(s_4462_0 as u128, 3u16);
        // C s_4462_2: const #0u : u8
        let s_4462_2: u8 = 0;
        // C s_4462_3: cast zx s_4462_2 -> bv
        let s_4462_3: Bits = Bits::new(s_4462_2 as u128, 3u16);
        // D s_4462_4: cmp-eq s_4462_1 s_4462_3
        let s_4462_4: bool = ((s_4462_1) == (s_4462_3));
        // D s_4462_5: write-var gs#118515 <= s_4462_4
        fn_state.gs_118515 = s_4462_4;
        // N s_4462_6: jump b2177
        return block_2177(state, tracer, fn_state);
    }
    fn block_4463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4463_0: read-var opc1:u8
        let s_4463_0: u8 = fn_state.opc1;
        // D s_4463_1: cast zx s_4463_0 -> bv
        let s_4463_1: Bits = Bits::new(s_4463_0 as u128, 3u16);
        // C s_4463_2: const #0u : u8
        let s_4463_2: u8 = 0;
        // C s_4463_3: cast zx s_4463_2 -> bv
        let s_4463_3: Bits = Bits::new(s_4463_2 as u128, 3u16);
        // D s_4463_4: cmp-eq s_4463_1 s_4463_3
        let s_4463_4: bool = ((s_4463_1) == (s_4463_3));
        // D s_4463_5: write-var gs#118514 <= s_4463_4
        fn_state.gs_118514 = s_4463_4;
        // N s_4463_6: jump b2175
        return block_2175(state, tracer, fn_state);
    }
    fn block_4464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4464_0: read-var coproc:u8
        let s_4464_0: u8 = fn_state.coproc;
        // D s_4464_1: cast zx s_4464_0 -> bv
        let s_4464_1: Bits = Bits::new(s_4464_0 as u128, 4u16);
        // C s_4464_2: const #15u : u8
        let s_4464_2: u8 = 15;
        // C s_4464_3: cast zx s_4464_2 -> bv
        let s_4464_3: Bits = Bits::new(s_4464_2 as u128, 4u16);
        // D s_4464_4: cmp-eq s_4464_1 s_4464_3
        let s_4464_4: bool = ((s_4464_1) == (s_4464_3));
        // D s_4464_5: write-var gs#118513 <= s_4464_4
        fn_state.gs_118513 = s_4464_4;
        // N s_4464_6: jump b2173
        return block_2173(state, tracer, fn_state);
    }
    fn block_4465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4465_0: read-var CRn:u8
        let s_4465_0: u8 = fn_state.CRn;
        // D s_4465_1: cast zx s_4465_0 -> bv
        let s_4465_1: Bits = Bits::new(s_4465_0 as u128, 4u16);
        // C s_4465_2: const #14u : u8
        let s_4465_2: u8 = 14;
        // C s_4465_3: cast zx s_4465_2 -> bv
        let s_4465_3: Bits = Bits::new(s_4465_2 as u128, 4u16);
        // D s_4465_4: cmp-eq s_4465_1 s_4465_3
        let s_4465_4: bool = ((s_4465_1) == (s_4465_3));
        // D s_4465_5: write-var gs#118512 <= s_4465_4
        fn_state.gs_118512 = s_4465_4;
        // N s_4465_6: jump b2171
        return block_2171(state, tracer, fn_state);
    }
    fn block_4466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4466_0: read-var el:u8
        let s_4466_0: u8 = fn_state.el;
        // D s_4466_1: read-var coproc:u8
        let s_4466_1: u8 = fn_state.coproc;
        // D s_4466_2: read-var opc1:u8
        let s_4466_2: u8 = fn_state.opc1;
        // D s_4466_3: read-var CRn:u8
        let s_4466_3: u8 = fn_state.CRn;
        // D s_4466_4: read-var opc2:u8
        let s_4466_4: u8 = fn_state.opc2;
        // D s_4466_5: read-var CRm:u8
        let s_4466_5: u8 = fn_state.CRm;
        // D s_4466_6: read-var t:i
        let s_4466_6: i128 = fn_state.t;
        // D s_4466_7: call JMCR_SysRegRead32_f5fe518171c35ee0(s_4466_0, s_4466_1, s_4466_2, s_4466_3, s_4466_4, s_4466_5, s_4466_6)
        let s_4466_7: () = JMCR_SysRegRead32_f5fe518171c35ee0(
            state,
            tracer,
            s_4466_0,
            s_4466_1,
            s_4466_2,
            s_4466_3,
            s_4466_4,
            s_4466_5,
            s_4466_6,
        );
        // N s_4466_8: return
        return;
    }
    fn block_4467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4467_0: read-var opc2:u8
        let s_4467_0: u8 = fn_state.opc2;
        // D s_4467_1: cast zx s_4467_0 -> bv
        let s_4467_1: Bits = Bits::new(s_4467_0 as u128, 3u16);
        // C s_4467_2: const #0u : u8
        let s_4467_2: u8 = 0;
        // C s_4467_3: cast zx s_4467_2 -> bv
        let s_4467_3: Bits = Bits::new(s_4467_2 as u128, 3u16);
        // D s_4467_4: cmp-eq s_4467_1 s_4467_3
        let s_4467_4: bool = ((s_4467_1) == (s_4467_3));
        // D s_4467_5: write-var gs#118511 <= s_4467_4
        fn_state.gs_118511 = s_4467_4;
        // N s_4467_6: jump b2168
        return block_2168(state, tracer, fn_state);
    }
    fn block_4468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4468_0: read-var opc1:u8
        let s_4468_0: u8 = fn_state.opc1;
        // D s_4468_1: cast zx s_4468_0 -> bv
        let s_4468_1: Bits = Bits::new(s_4468_0 as u128, 3u16);
        // C s_4468_2: const #7u : u8
        let s_4468_2: u8 = 7;
        // C s_4468_3: cast zx s_4468_2 -> bv
        let s_4468_3: Bits = Bits::new(s_4468_2 as u128, 3u16);
        // D s_4468_4: cmp-eq s_4468_1 s_4468_3
        let s_4468_4: bool = ((s_4468_1) == (s_4468_3));
        // D s_4468_5: write-var gs#118510 <= s_4468_4
        fn_state.gs_118510 = s_4468_4;
        // N s_4468_6: jump b2166
        return block_2166(state, tracer, fn_state);
    }
    fn block_4469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4469_0: read-var coproc:u8
        let s_4469_0: u8 = fn_state.coproc;
        // D s_4469_1: cast zx s_4469_0 -> bv
        let s_4469_1: Bits = Bits::new(s_4469_0 as u128, 4u16);
        // C s_4469_2: const #14u : u8
        let s_4469_2: u8 = 14;
        // C s_4469_3: cast zx s_4469_2 -> bv
        let s_4469_3: Bits = Bits::new(s_4469_2 as u128, 4u16);
        // D s_4469_4: cmp-eq s_4469_1 s_4469_3
        let s_4469_4: bool = ((s_4469_1) == (s_4469_3));
        // D s_4469_5: write-var gs#118509 <= s_4469_4
        fn_state.gs_118509 = s_4469_4;
        // N s_4469_6: jump b2164
        return block_2164(state, tracer, fn_state);
    }
    fn block_4470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4470_0: read-var CRn:u8
        let s_4470_0: u8 = fn_state.CRn;
        // D s_4470_1: cast zx s_4470_0 -> bv
        let s_4470_1: Bits = Bits::new(s_4470_0 as u128, 4u16);
        // C s_4470_2: const #2u : u8
        let s_4470_2: u8 = 2;
        // C s_4470_3: cast zx s_4470_2 -> bv
        let s_4470_3: Bits = Bits::new(s_4470_2 as u128, 4u16);
        // D s_4470_4: cmp-eq s_4470_1 s_4470_3
        let s_4470_4: bool = ((s_4470_1) == (s_4470_3));
        // D s_4470_5: write-var gs#118508 <= s_4470_4
        fn_state.gs_118508 = s_4470_4;
        // N s_4470_6: jump b2162
        return block_2162(state, tracer, fn_state);
    }
    fn block_4471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4471_0: read-var el:u8
        let s_4471_0: u8 = fn_state.el;
        // D s_4471_1: read-var coproc:u8
        let s_4471_1: u8 = fn_state.coproc;
        // D s_4471_2: read-var opc1:u8
        let s_4471_2: u8 = fn_state.opc1;
        // D s_4471_3: read-var CRn:u8
        let s_4471_3: u8 = fn_state.CRn;
        // D s_4471_4: read-var opc2:u8
        let s_4471_4: u8 = fn_state.opc2;
        // D s_4471_5: read-var CRm:u8
        let s_4471_5: u8 = fn_state.CRm;
        // D s_4471_6: read-var t:i
        let s_4471_6: i128 = fn_state.t;
        // D s_4471_7: call HADFSR_SysRegRead32_c586b2ce1fe8150f(s_4471_0, s_4471_1, s_4471_2, s_4471_3, s_4471_4, s_4471_5, s_4471_6)
        let s_4471_7: () = HADFSR_SysRegRead32_c586b2ce1fe8150f(
            state,
            tracer,
            s_4471_0,
            s_4471_1,
            s_4471_2,
            s_4471_3,
            s_4471_4,
            s_4471_5,
            s_4471_6,
        );
        // N s_4471_8: return
        return;
    }
    fn block_4472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4472_0: read-var opc2:u8
        let s_4472_0: u8 = fn_state.opc2;
        // D s_4472_1: cast zx s_4472_0 -> bv
        let s_4472_1: Bits = Bits::new(s_4472_0 as u128, 3u16);
        // C s_4472_2: const #0u : u8
        let s_4472_2: u8 = 0;
        // C s_4472_3: cast zx s_4472_2 -> bv
        let s_4472_3: Bits = Bits::new(s_4472_2 as u128, 3u16);
        // D s_4472_4: cmp-eq s_4472_1 s_4472_3
        let s_4472_4: bool = ((s_4472_1) == (s_4472_3));
        // D s_4472_5: write-var gs#118507 <= s_4472_4
        fn_state.gs_118507 = s_4472_4;
        // N s_4472_6: jump b2159
        return block_2159(state, tracer, fn_state);
    }
    fn block_4473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4473_0: read-var opc1:u8
        let s_4473_0: u8 = fn_state.opc1;
        // D s_4473_1: cast zx s_4473_0 -> bv
        let s_4473_1: Bits = Bits::new(s_4473_0 as u128, 3u16);
        // C s_4473_2: const #4u : u8
        let s_4473_2: u8 = 4;
        // C s_4473_3: cast zx s_4473_2 -> bv
        let s_4473_3: Bits = Bits::new(s_4473_2 as u128, 3u16);
        // D s_4473_4: cmp-eq s_4473_1 s_4473_3
        let s_4473_4: bool = ((s_4473_1) == (s_4473_3));
        // D s_4473_5: write-var gs#118506 <= s_4473_4
        fn_state.gs_118506 = s_4473_4;
        // N s_4473_6: jump b2157
        return block_2157(state, tracer, fn_state);
    }
    fn block_4474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4474_0: read-var coproc:u8
        let s_4474_0: u8 = fn_state.coproc;
        // D s_4474_1: cast zx s_4474_0 -> bv
        let s_4474_1: Bits = Bits::new(s_4474_0 as u128, 4u16);
        // C s_4474_2: const #15u : u8
        let s_4474_2: u8 = 15;
        // C s_4474_3: cast zx s_4474_2 -> bv
        let s_4474_3: Bits = Bits::new(s_4474_2 as u128, 4u16);
        // D s_4474_4: cmp-eq s_4474_1 s_4474_3
        let s_4474_4: bool = ((s_4474_1) == (s_4474_3));
        // D s_4474_5: write-var gs#118505 <= s_4474_4
        fn_state.gs_118505 = s_4474_4;
        // N s_4474_6: jump b2155
        return block_2155(state, tracer, fn_state);
    }
    fn block_4475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4475_0: read-var CRn:u8
        let s_4475_0: u8 = fn_state.CRn;
        // D s_4475_1: cast zx s_4475_0 -> bv
        let s_4475_1: Bits = Bits::new(s_4475_0 as u128, 4u16);
        // C s_4475_2: const #5u : u8
        let s_4475_2: u8 = 5;
        // C s_4475_3: cast zx s_4475_2 -> bv
        let s_4475_3: Bits = Bits::new(s_4475_2 as u128, 4u16);
        // D s_4475_4: cmp-eq s_4475_1 s_4475_3
        let s_4475_4: bool = ((s_4475_1) == (s_4475_3));
        // D s_4475_5: write-var gs#118504 <= s_4475_4
        fn_state.gs_118504 = s_4475_4;
        // N s_4475_6: jump b2153
        return block_2153(state, tracer, fn_state);
    }
    fn block_4476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4476_0: read-var el:u8
        let s_4476_0: u8 = fn_state.el;
        // D s_4476_1: read-var coproc:u8
        let s_4476_1: u8 = fn_state.coproc;
        // D s_4476_2: read-var opc1:u8
        let s_4476_2: u8 = fn_state.opc1;
        // D s_4476_3: read-var CRn:u8
        let s_4476_3: u8 = fn_state.CRn;
        // D s_4476_4: read-var opc2:u8
        let s_4476_4: u8 = fn_state.opc2;
        // D s_4476_5: read-var CRm:u8
        let s_4476_5: u8 = fn_state.CRm;
        // D s_4476_6: read-var t:i
        let s_4476_6: i128 = fn_state.t;
        // D s_4476_7: call ICH_LR_SysRegRead32_223cf2e0fdc1ff05(s_4476_0, s_4476_1, s_4476_2, s_4476_3, s_4476_4, s_4476_5, s_4476_6)
        let s_4476_7: () = ICH_LR_SysRegRead32_223cf2e0fdc1ff05(
            state,
            tracer,
            s_4476_0,
            s_4476_1,
            s_4476_2,
            s_4476_3,
            s_4476_4,
            s_4476_5,
            s_4476_6,
        );
        // N s_4476_8: return
        return;
    }
    fn block_4477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4477_0: read-var opc2:u8
        let s_4477_0: u8 = fn_state.opc2;
        // D s_4477_1: cast zx s_4477_0 -> bv
        let s_4477_1: Bits = Bits::new(s_4477_0 as u128, 3u16);
        // C s_4477_2: const #0u : u8
        let s_4477_2: u8 = 0;
        // C s_4477_3: cast zx s_4477_2 -> bv
        let s_4477_3: Bits = Bits::new(s_4477_2 as u128, 3u16);
        // D s_4477_4: cmp-eq s_4477_1 s_4477_3
        let s_4477_4: bool = ((s_4477_1) == (s_4477_3));
        // D s_4477_5: write-var gs#118503 <= s_4477_4
        fn_state.gs_118503 = s_4477_4;
        // N s_4477_6: jump b2150
        return block_2150(state, tracer, fn_state);
    }
    fn block_4478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4478_0: read-var opc1:u8
        let s_4478_0: u8 = fn_state.opc1;
        // D s_4478_1: cast zx s_4478_0 -> bv
        let s_4478_1: Bits = Bits::new(s_4478_0 as u128, 3u16);
        // C s_4478_2: const #4u : u8
        let s_4478_2: u8 = 4;
        // C s_4478_3: cast zx s_4478_2 -> bv
        let s_4478_3: Bits = Bits::new(s_4478_2 as u128, 3u16);
        // D s_4478_4: cmp-eq s_4478_1 s_4478_3
        let s_4478_4: bool = ((s_4478_1) == (s_4478_3));
        // D s_4478_5: write-var gs#118502 <= s_4478_4
        fn_state.gs_118502 = s_4478_4;
        // N s_4478_6: jump b2148
        return block_2148(state, tracer, fn_state);
    }
    fn block_4479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4479_0: read-var coproc:u8
        let s_4479_0: u8 = fn_state.coproc;
        // D s_4479_1: cast zx s_4479_0 -> bv
        let s_4479_1: Bits = Bits::new(s_4479_0 as u128, 4u16);
        // C s_4479_2: const #15u : u8
        let s_4479_2: u8 = 15;
        // C s_4479_3: cast zx s_4479_2 -> bv
        let s_4479_3: Bits = Bits::new(s_4479_2 as u128, 4u16);
        // D s_4479_4: cmp-eq s_4479_1 s_4479_3
        let s_4479_4: bool = ((s_4479_1) == (s_4479_3));
        // D s_4479_5: write-var gs#118501 <= s_4479_4
        fn_state.gs_118501 = s_4479_4;
        // N s_4479_6: jump b2146
        return block_2146(state, tracer, fn_state);
    }
    fn block_4480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4480_0: read-var CRn:u8
        let s_4480_0: u8 = fn_state.CRn;
        // D s_4480_1: cast zx s_4480_0 -> bv
        let s_4480_1: Bits = Bits::new(s_4480_0 as u128, 4u16);
        // C s_4480_2: const #12u : u8
        let s_4480_2: u8 = 12;
        // C s_4480_3: cast zx s_4480_2 -> bv
        let s_4480_3: Bits = Bits::new(s_4480_2 as u128, 4u16);
        // D s_4480_4: cmp-eq s_4480_1 s_4480_3
        let s_4480_4: bool = ((s_4480_1) == (s_4480_3));
        // D s_4480_5: write-var gs#118500 <= s_4480_4
        fn_state.gs_118500 = s_4480_4;
        // N s_4480_6: jump b2144
        return block_2144(state, tracer, fn_state);
    }
    fn block_4481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4481_0: read-var el:u8
        let s_4481_0: u8 = fn_state.el;
        // D s_4481_1: read-var coproc:u8
        let s_4481_1: u8 = fn_state.coproc;
        // D s_4481_2: read-var opc1:u8
        let s_4481_2: u8 = fn_state.opc1;
        // D s_4481_3: read-var CRn:u8
        let s_4481_3: u8 = fn_state.CRn;
        // D s_4481_4: read-var opc2:u8
        let s_4481_4: u8 = fn_state.opc2;
        // D s_4481_5: read-var CRm:u8
        let s_4481_5: u8 = fn_state.CRm;
        // D s_4481_6: read-var t:i
        let s_4481_6: i128 = fn_state.t;
        // D s_4481_7: call ICH_LR_SysRegRead32_074065db8610395b(s_4481_0, s_4481_1, s_4481_2, s_4481_3, s_4481_4, s_4481_5, s_4481_6)
        let s_4481_7: () = ICH_LR_SysRegRead32_074065db8610395b(
            state,
            tracer,
            s_4481_0,
            s_4481_1,
            s_4481_2,
            s_4481_3,
            s_4481_4,
            s_4481_5,
            s_4481_6,
        );
        // N s_4481_8: return
        return;
    }
    fn block_4482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4482_0: read-var opc2:u8
        let s_4482_0: u8 = fn_state.opc2;
        // D s_4482_1: cast zx s_4482_0 -> bv
        let s_4482_1: Bits = Bits::new(s_4482_0 as u128, 3u16);
        // C s_4482_2: const #1u : u8
        let s_4482_2: u8 = 1;
        // C s_4482_3: cast zx s_4482_2 -> bv
        let s_4482_3: Bits = Bits::new(s_4482_2 as u128, 3u16);
        // D s_4482_4: cmp-eq s_4482_1 s_4482_3
        let s_4482_4: bool = ((s_4482_1) == (s_4482_3));
        // D s_4482_5: write-var gs#118499 <= s_4482_4
        fn_state.gs_118499 = s_4482_4;
        // N s_4482_6: jump b2141
        return block_2141(state, tracer, fn_state);
    }
    fn block_4483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4483_0: read-var opc1:u8
        let s_4483_0: u8 = fn_state.opc1;
        // D s_4483_1: cast zx s_4483_0 -> bv
        let s_4483_1: Bits = Bits::new(s_4483_0 as u128, 3u16);
        // C s_4483_2: const #4u : u8
        let s_4483_2: u8 = 4;
        // C s_4483_3: cast zx s_4483_2 -> bv
        let s_4483_3: Bits = Bits::new(s_4483_2 as u128, 3u16);
        // D s_4483_4: cmp-eq s_4483_1 s_4483_3
        let s_4483_4: bool = ((s_4483_1) == (s_4483_3));
        // D s_4483_5: write-var gs#118498 <= s_4483_4
        fn_state.gs_118498 = s_4483_4;
        // N s_4483_6: jump b2139
        return block_2139(state, tracer, fn_state);
    }
    fn block_4484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4484_0: read-var coproc:u8
        let s_4484_0: u8 = fn_state.coproc;
        // D s_4484_1: cast zx s_4484_0 -> bv
        let s_4484_1: Bits = Bits::new(s_4484_0 as u128, 4u16);
        // C s_4484_2: const #15u : u8
        let s_4484_2: u8 = 15;
        // C s_4484_3: cast zx s_4484_2 -> bv
        let s_4484_3: Bits = Bits::new(s_4484_2 as u128, 4u16);
        // D s_4484_4: cmp-eq s_4484_1 s_4484_3
        let s_4484_4: bool = ((s_4484_1) == (s_4484_3));
        // D s_4484_5: write-var gs#118497 <= s_4484_4
        fn_state.gs_118497 = s_4484_4;
        // N s_4484_6: jump b2137
        return block_2137(state, tracer, fn_state);
    }
    fn block_4485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4485_0: read-var CRn:u8
        let s_4485_0: u8 = fn_state.CRn;
        // D s_4485_1: cast zx s_4485_0 -> bv
        let s_4485_1: Bits = Bits::new(s_4485_0 as u128, 4u16);
        // C s_4485_2: const #12u : u8
        let s_4485_2: u8 = 12;
        // C s_4485_3: cast zx s_4485_2 -> bv
        let s_4485_3: Bits = Bits::new(s_4485_2 as u128, 4u16);
        // D s_4485_4: cmp-eq s_4485_1 s_4485_3
        let s_4485_4: bool = ((s_4485_1) == (s_4485_3));
        // D s_4485_5: write-var gs#118496 <= s_4485_4
        fn_state.gs_118496 = s_4485_4;
        // N s_4485_6: jump b2135
        return block_2135(state, tracer, fn_state);
    }
    fn block_4486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4486_0: read-var el:u8
        let s_4486_0: u8 = fn_state.el;
        // D s_4486_1: read-var coproc:u8
        let s_4486_1: u8 = fn_state.coproc;
        // D s_4486_2: read-var opc1:u8
        let s_4486_2: u8 = fn_state.opc1;
        // D s_4486_3: read-var CRn:u8
        let s_4486_3: u8 = fn_state.CRn;
        // D s_4486_4: read-var opc2:u8
        let s_4486_4: u8 = fn_state.opc2;
        // D s_4486_5: read-var CRm:u8
        let s_4486_5: u8 = fn_state.CRm;
        // D s_4486_6: read-var t:i
        let s_4486_6: i128 = fn_state.t;
        // D s_4486_7: call ICH_LR_SysRegRead32_aff6b82779d5a019(s_4486_0, s_4486_1, s_4486_2, s_4486_3, s_4486_4, s_4486_5, s_4486_6)
        let s_4486_7: () = ICH_LR_SysRegRead32_aff6b82779d5a019(
            state,
            tracer,
            s_4486_0,
            s_4486_1,
            s_4486_2,
            s_4486_3,
            s_4486_4,
            s_4486_5,
            s_4486_6,
        );
        // N s_4486_8: return
        return;
    }
    fn block_4487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4487_0: read-var opc2:u8
        let s_4487_0: u8 = fn_state.opc2;
        // D s_4487_1: cast zx s_4487_0 -> bv
        let s_4487_1: Bits = Bits::new(s_4487_0 as u128, 3u16);
        // C s_4487_2: const #2u : u8
        let s_4487_2: u8 = 2;
        // C s_4487_3: cast zx s_4487_2 -> bv
        let s_4487_3: Bits = Bits::new(s_4487_2 as u128, 3u16);
        // D s_4487_4: cmp-eq s_4487_1 s_4487_3
        let s_4487_4: bool = ((s_4487_1) == (s_4487_3));
        // D s_4487_5: write-var gs#118495 <= s_4487_4
        fn_state.gs_118495 = s_4487_4;
        // N s_4487_6: jump b2132
        return block_2132(state, tracer, fn_state);
    }
    fn block_4488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4488_0: read-var opc1:u8
        let s_4488_0: u8 = fn_state.opc1;
        // D s_4488_1: cast zx s_4488_0 -> bv
        let s_4488_1: Bits = Bits::new(s_4488_0 as u128, 3u16);
        // C s_4488_2: const #4u : u8
        let s_4488_2: u8 = 4;
        // C s_4488_3: cast zx s_4488_2 -> bv
        let s_4488_3: Bits = Bits::new(s_4488_2 as u128, 3u16);
        // D s_4488_4: cmp-eq s_4488_1 s_4488_3
        let s_4488_4: bool = ((s_4488_1) == (s_4488_3));
        // D s_4488_5: write-var gs#118494 <= s_4488_4
        fn_state.gs_118494 = s_4488_4;
        // N s_4488_6: jump b2130
        return block_2130(state, tracer, fn_state);
    }
    fn block_4489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4489_0: read-var coproc:u8
        let s_4489_0: u8 = fn_state.coproc;
        // D s_4489_1: cast zx s_4489_0 -> bv
        let s_4489_1: Bits = Bits::new(s_4489_0 as u128, 4u16);
        // C s_4489_2: const #15u : u8
        let s_4489_2: u8 = 15;
        // C s_4489_3: cast zx s_4489_2 -> bv
        let s_4489_3: Bits = Bits::new(s_4489_2 as u128, 4u16);
        // D s_4489_4: cmp-eq s_4489_1 s_4489_3
        let s_4489_4: bool = ((s_4489_1) == (s_4489_3));
        // D s_4489_5: write-var gs#118493 <= s_4489_4
        fn_state.gs_118493 = s_4489_4;
        // N s_4489_6: jump b2128
        return block_2128(state, tracer, fn_state);
    }
    fn block_4490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4490_0: read-var CRn:u8
        let s_4490_0: u8 = fn_state.CRn;
        // D s_4490_1: cast zx s_4490_0 -> bv
        let s_4490_1: Bits = Bits::new(s_4490_0 as u128, 4u16);
        // C s_4490_2: const #12u : u8
        let s_4490_2: u8 = 12;
        // C s_4490_3: cast zx s_4490_2 -> bv
        let s_4490_3: Bits = Bits::new(s_4490_2 as u128, 4u16);
        // D s_4490_4: cmp-eq s_4490_1 s_4490_3
        let s_4490_4: bool = ((s_4490_1) == (s_4490_3));
        // D s_4490_5: write-var gs#118492 <= s_4490_4
        fn_state.gs_118492 = s_4490_4;
        // N s_4490_6: jump b2126
        return block_2126(state, tracer, fn_state);
    }
    fn block_4491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4491_0: read-var el:u8
        let s_4491_0: u8 = fn_state.el;
        // D s_4491_1: read-var coproc:u8
        let s_4491_1: u8 = fn_state.coproc;
        // D s_4491_2: read-var opc1:u8
        let s_4491_2: u8 = fn_state.opc1;
        // D s_4491_3: read-var CRn:u8
        let s_4491_3: u8 = fn_state.CRn;
        // D s_4491_4: read-var opc2:u8
        let s_4491_4: u8 = fn_state.opc2;
        // D s_4491_5: read-var CRm:u8
        let s_4491_5: u8 = fn_state.CRm;
        // D s_4491_6: read-var t:i
        let s_4491_6: i128 = fn_state.t;
        // D s_4491_7: call ICH_LR_SysRegRead32_b53ec5837b358bc1(s_4491_0, s_4491_1, s_4491_2, s_4491_3, s_4491_4, s_4491_5, s_4491_6)
        let s_4491_7: () = ICH_LR_SysRegRead32_b53ec5837b358bc1(
            state,
            tracer,
            s_4491_0,
            s_4491_1,
            s_4491_2,
            s_4491_3,
            s_4491_4,
            s_4491_5,
            s_4491_6,
        );
        // N s_4491_8: return
        return;
    }
    fn block_4492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4492_0: read-var opc2:u8
        let s_4492_0: u8 = fn_state.opc2;
        // D s_4492_1: cast zx s_4492_0 -> bv
        let s_4492_1: Bits = Bits::new(s_4492_0 as u128, 3u16);
        // C s_4492_2: const #3u : u8
        let s_4492_2: u8 = 3;
        // C s_4492_3: cast zx s_4492_2 -> bv
        let s_4492_3: Bits = Bits::new(s_4492_2 as u128, 3u16);
        // D s_4492_4: cmp-eq s_4492_1 s_4492_3
        let s_4492_4: bool = ((s_4492_1) == (s_4492_3));
        // D s_4492_5: write-var gs#118491 <= s_4492_4
        fn_state.gs_118491 = s_4492_4;
        // N s_4492_6: jump b2123
        return block_2123(state, tracer, fn_state);
    }
    fn block_4493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4493_0: read-var opc1:u8
        let s_4493_0: u8 = fn_state.opc1;
        // D s_4493_1: cast zx s_4493_0 -> bv
        let s_4493_1: Bits = Bits::new(s_4493_0 as u128, 3u16);
        // C s_4493_2: const #4u : u8
        let s_4493_2: u8 = 4;
        // C s_4493_3: cast zx s_4493_2 -> bv
        let s_4493_3: Bits = Bits::new(s_4493_2 as u128, 3u16);
        // D s_4493_4: cmp-eq s_4493_1 s_4493_3
        let s_4493_4: bool = ((s_4493_1) == (s_4493_3));
        // D s_4493_5: write-var gs#118490 <= s_4493_4
        fn_state.gs_118490 = s_4493_4;
        // N s_4493_6: jump b2121
        return block_2121(state, tracer, fn_state);
    }
    fn block_4494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4494_0: read-var coproc:u8
        let s_4494_0: u8 = fn_state.coproc;
        // D s_4494_1: cast zx s_4494_0 -> bv
        let s_4494_1: Bits = Bits::new(s_4494_0 as u128, 4u16);
        // C s_4494_2: const #15u : u8
        let s_4494_2: u8 = 15;
        // C s_4494_3: cast zx s_4494_2 -> bv
        let s_4494_3: Bits = Bits::new(s_4494_2 as u128, 4u16);
        // D s_4494_4: cmp-eq s_4494_1 s_4494_3
        let s_4494_4: bool = ((s_4494_1) == (s_4494_3));
        // D s_4494_5: write-var gs#118489 <= s_4494_4
        fn_state.gs_118489 = s_4494_4;
        // N s_4494_6: jump b2119
        return block_2119(state, tracer, fn_state);
    }
    fn block_4495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4495_0: read-var CRn:u8
        let s_4495_0: u8 = fn_state.CRn;
        // D s_4495_1: cast zx s_4495_0 -> bv
        let s_4495_1: Bits = Bits::new(s_4495_0 as u128, 4u16);
        // C s_4495_2: const #12u : u8
        let s_4495_2: u8 = 12;
        // C s_4495_3: cast zx s_4495_2 -> bv
        let s_4495_3: Bits = Bits::new(s_4495_2 as u128, 4u16);
        // D s_4495_4: cmp-eq s_4495_1 s_4495_3
        let s_4495_4: bool = ((s_4495_1) == (s_4495_3));
        // D s_4495_5: write-var gs#118488 <= s_4495_4
        fn_state.gs_118488 = s_4495_4;
        // N s_4495_6: jump b2117
        return block_2117(state, tracer, fn_state);
    }
    fn block_4496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4496_0: read-var el:u8
        let s_4496_0: u8 = fn_state.el;
        // D s_4496_1: read-var coproc:u8
        let s_4496_1: u8 = fn_state.coproc;
        // D s_4496_2: read-var opc1:u8
        let s_4496_2: u8 = fn_state.opc1;
        // D s_4496_3: read-var CRn:u8
        let s_4496_3: u8 = fn_state.CRn;
        // D s_4496_4: read-var opc2:u8
        let s_4496_4: u8 = fn_state.opc2;
        // D s_4496_5: read-var CRm:u8
        let s_4496_5: u8 = fn_state.CRm;
        // D s_4496_6: read-var t:i
        let s_4496_6: i128 = fn_state.t;
        // D s_4496_7: call ICH_LR_SysRegRead32_91b224d16fef9888(s_4496_0, s_4496_1, s_4496_2, s_4496_3, s_4496_4, s_4496_5, s_4496_6)
        let s_4496_7: () = ICH_LR_SysRegRead32_91b224d16fef9888(
            state,
            tracer,
            s_4496_0,
            s_4496_1,
            s_4496_2,
            s_4496_3,
            s_4496_4,
            s_4496_5,
            s_4496_6,
        );
        // N s_4496_8: return
        return;
    }
    fn block_4497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4497_0: read-var opc2:u8
        let s_4497_0: u8 = fn_state.opc2;
        // D s_4497_1: cast zx s_4497_0 -> bv
        let s_4497_1: Bits = Bits::new(s_4497_0 as u128, 3u16);
        // C s_4497_2: const #4u : u8
        let s_4497_2: u8 = 4;
        // C s_4497_3: cast zx s_4497_2 -> bv
        let s_4497_3: Bits = Bits::new(s_4497_2 as u128, 3u16);
        // D s_4497_4: cmp-eq s_4497_1 s_4497_3
        let s_4497_4: bool = ((s_4497_1) == (s_4497_3));
        // D s_4497_5: write-var gs#118487 <= s_4497_4
        fn_state.gs_118487 = s_4497_4;
        // N s_4497_6: jump b2114
        return block_2114(state, tracer, fn_state);
    }
    fn block_4498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4498_0: read-var opc1:u8
        let s_4498_0: u8 = fn_state.opc1;
        // D s_4498_1: cast zx s_4498_0 -> bv
        let s_4498_1: Bits = Bits::new(s_4498_0 as u128, 3u16);
        // C s_4498_2: const #4u : u8
        let s_4498_2: u8 = 4;
        // C s_4498_3: cast zx s_4498_2 -> bv
        let s_4498_3: Bits = Bits::new(s_4498_2 as u128, 3u16);
        // D s_4498_4: cmp-eq s_4498_1 s_4498_3
        let s_4498_4: bool = ((s_4498_1) == (s_4498_3));
        // D s_4498_5: write-var gs#118486 <= s_4498_4
        fn_state.gs_118486 = s_4498_4;
        // N s_4498_6: jump b2112
        return block_2112(state, tracer, fn_state);
    }
    fn block_4499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4499_0: read-var coproc:u8
        let s_4499_0: u8 = fn_state.coproc;
        // D s_4499_1: cast zx s_4499_0 -> bv
        let s_4499_1: Bits = Bits::new(s_4499_0 as u128, 4u16);
        // C s_4499_2: const #15u : u8
        let s_4499_2: u8 = 15;
        // C s_4499_3: cast zx s_4499_2 -> bv
        let s_4499_3: Bits = Bits::new(s_4499_2 as u128, 4u16);
        // D s_4499_4: cmp-eq s_4499_1 s_4499_3
        let s_4499_4: bool = ((s_4499_1) == (s_4499_3));
        // D s_4499_5: write-var gs#118485 <= s_4499_4
        fn_state.gs_118485 = s_4499_4;
        // N s_4499_6: jump b2110
        return block_2110(state, tracer, fn_state);
    }
    fn block_4500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4500_0: read-var CRn:u8
        let s_4500_0: u8 = fn_state.CRn;
        // D s_4500_1: cast zx s_4500_0 -> bv
        let s_4500_1: Bits = Bits::new(s_4500_0 as u128, 4u16);
        // C s_4500_2: const #12u : u8
        let s_4500_2: u8 = 12;
        // C s_4500_3: cast zx s_4500_2 -> bv
        let s_4500_3: Bits = Bits::new(s_4500_2 as u128, 4u16);
        // D s_4500_4: cmp-eq s_4500_1 s_4500_3
        let s_4500_4: bool = ((s_4500_1) == (s_4500_3));
        // D s_4500_5: write-var gs#118484 <= s_4500_4
        fn_state.gs_118484 = s_4500_4;
        // N s_4500_6: jump b2108
        return block_2108(state, tracer, fn_state);
    }
    fn block_4501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4501_0: read-var el:u8
        let s_4501_0: u8 = fn_state.el;
        // D s_4501_1: read-var coproc:u8
        let s_4501_1: u8 = fn_state.coproc;
        // D s_4501_2: read-var opc1:u8
        let s_4501_2: u8 = fn_state.opc1;
        // D s_4501_3: read-var CRn:u8
        let s_4501_3: u8 = fn_state.CRn;
        // D s_4501_4: read-var opc2:u8
        let s_4501_4: u8 = fn_state.opc2;
        // D s_4501_5: read-var CRm:u8
        let s_4501_5: u8 = fn_state.CRm;
        // D s_4501_6: read-var t:i
        let s_4501_6: i128 = fn_state.t;
        // D s_4501_7: call ICH_LR_SysRegRead32_3dfad36dd01cdeec(s_4501_0, s_4501_1, s_4501_2, s_4501_3, s_4501_4, s_4501_5, s_4501_6)
        let s_4501_7: () = ICH_LR_SysRegRead32_3dfad36dd01cdeec(
            state,
            tracer,
            s_4501_0,
            s_4501_1,
            s_4501_2,
            s_4501_3,
            s_4501_4,
            s_4501_5,
            s_4501_6,
        );
        // N s_4501_8: return
        return;
    }
    fn block_4502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4502_0: read-var opc2:u8
        let s_4502_0: u8 = fn_state.opc2;
        // D s_4502_1: cast zx s_4502_0 -> bv
        let s_4502_1: Bits = Bits::new(s_4502_0 as u128, 3u16);
        // C s_4502_2: const #5u : u8
        let s_4502_2: u8 = 5;
        // C s_4502_3: cast zx s_4502_2 -> bv
        let s_4502_3: Bits = Bits::new(s_4502_2 as u128, 3u16);
        // D s_4502_4: cmp-eq s_4502_1 s_4502_3
        let s_4502_4: bool = ((s_4502_1) == (s_4502_3));
        // D s_4502_5: write-var gs#118483 <= s_4502_4
        fn_state.gs_118483 = s_4502_4;
        // N s_4502_6: jump b2105
        return block_2105(state, tracer, fn_state);
    }
    fn block_4503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4503_0: read-var opc1:u8
        let s_4503_0: u8 = fn_state.opc1;
        // D s_4503_1: cast zx s_4503_0 -> bv
        let s_4503_1: Bits = Bits::new(s_4503_0 as u128, 3u16);
        // C s_4503_2: const #4u : u8
        let s_4503_2: u8 = 4;
        // C s_4503_3: cast zx s_4503_2 -> bv
        let s_4503_3: Bits = Bits::new(s_4503_2 as u128, 3u16);
        // D s_4503_4: cmp-eq s_4503_1 s_4503_3
        let s_4503_4: bool = ((s_4503_1) == (s_4503_3));
        // D s_4503_5: write-var gs#118482 <= s_4503_4
        fn_state.gs_118482 = s_4503_4;
        // N s_4503_6: jump b2103
        return block_2103(state, tracer, fn_state);
    }
    fn block_4504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4504_0: read-var coproc:u8
        let s_4504_0: u8 = fn_state.coproc;
        // D s_4504_1: cast zx s_4504_0 -> bv
        let s_4504_1: Bits = Bits::new(s_4504_0 as u128, 4u16);
        // C s_4504_2: const #15u : u8
        let s_4504_2: u8 = 15;
        // C s_4504_3: cast zx s_4504_2 -> bv
        let s_4504_3: Bits = Bits::new(s_4504_2 as u128, 4u16);
        // D s_4504_4: cmp-eq s_4504_1 s_4504_3
        let s_4504_4: bool = ((s_4504_1) == (s_4504_3));
        // D s_4504_5: write-var gs#118481 <= s_4504_4
        fn_state.gs_118481 = s_4504_4;
        // N s_4504_6: jump b2101
        return block_2101(state, tracer, fn_state);
    }
    fn block_4505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4505_0: read-var CRn:u8
        let s_4505_0: u8 = fn_state.CRn;
        // D s_4505_1: cast zx s_4505_0 -> bv
        let s_4505_1: Bits = Bits::new(s_4505_0 as u128, 4u16);
        // C s_4505_2: const #12u : u8
        let s_4505_2: u8 = 12;
        // C s_4505_3: cast zx s_4505_2 -> bv
        let s_4505_3: Bits = Bits::new(s_4505_2 as u128, 4u16);
        // D s_4505_4: cmp-eq s_4505_1 s_4505_3
        let s_4505_4: bool = ((s_4505_1) == (s_4505_3));
        // D s_4505_5: write-var gs#118480 <= s_4505_4
        fn_state.gs_118480 = s_4505_4;
        // N s_4505_6: jump b2099
        return block_2099(state, tracer, fn_state);
    }
    fn block_4506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4506_0: read-var el:u8
        let s_4506_0: u8 = fn_state.el;
        // D s_4506_1: read-var coproc:u8
        let s_4506_1: u8 = fn_state.coproc;
        // D s_4506_2: read-var opc1:u8
        let s_4506_2: u8 = fn_state.opc1;
        // D s_4506_3: read-var CRn:u8
        let s_4506_3: u8 = fn_state.CRn;
        // D s_4506_4: read-var opc2:u8
        let s_4506_4: u8 = fn_state.opc2;
        // D s_4506_5: read-var CRm:u8
        let s_4506_5: u8 = fn_state.CRm;
        // D s_4506_6: read-var t:i
        let s_4506_6: i128 = fn_state.t;
        // D s_4506_7: call ICH_LR_SysRegRead32_7cf030ba66b1e3f5(s_4506_0, s_4506_1, s_4506_2, s_4506_3, s_4506_4, s_4506_5, s_4506_6)
        let s_4506_7: () = ICH_LR_SysRegRead32_7cf030ba66b1e3f5(
            state,
            tracer,
            s_4506_0,
            s_4506_1,
            s_4506_2,
            s_4506_3,
            s_4506_4,
            s_4506_5,
            s_4506_6,
        );
        // N s_4506_8: return
        return;
    }
    fn block_4507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4507_0: read-var opc2:u8
        let s_4507_0: u8 = fn_state.opc2;
        // D s_4507_1: cast zx s_4507_0 -> bv
        let s_4507_1: Bits = Bits::new(s_4507_0 as u128, 3u16);
        // C s_4507_2: const #6u : u8
        let s_4507_2: u8 = 6;
        // C s_4507_3: cast zx s_4507_2 -> bv
        let s_4507_3: Bits = Bits::new(s_4507_2 as u128, 3u16);
        // D s_4507_4: cmp-eq s_4507_1 s_4507_3
        let s_4507_4: bool = ((s_4507_1) == (s_4507_3));
        // D s_4507_5: write-var gs#118479 <= s_4507_4
        fn_state.gs_118479 = s_4507_4;
        // N s_4507_6: jump b2096
        return block_2096(state, tracer, fn_state);
    }
    fn block_4508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4508_0: read-var opc1:u8
        let s_4508_0: u8 = fn_state.opc1;
        // D s_4508_1: cast zx s_4508_0 -> bv
        let s_4508_1: Bits = Bits::new(s_4508_0 as u128, 3u16);
        // C s_4508_2: const #4u : u8
        let s_4508_2: u8 = 4;
        // C s_4508_3: cast zx s_4508_2 -> bv
        let s_4508_3: Bits = Bits::new(s_4508_2 as u128, 3u16);
        // D s_4508_4: cmp-eq s_4508_1 s_4508_3
        let s_4508_4: bool = ((s_4508_1) == (s_4508_3));
        // D s_4508_5: write-var gs#118478 <= s_4508_4
        fn_state.gs_118478 = s_4508_4;
        // N s_4508_6: jump b2094
        return block_2094(state, tracer, fn_state);
    }
    fn block_4509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4509_0: read-var coproc:u8
        let s_4509_0: u8 = fn_state.coproc;
        // D s_4509_1: cast zx s_4509_0 -> bv
        let s_4509_1: Bits = Bits::new(s_4509_0 as u128, 4u16);
        // C s_4509_2: const #15u : u8
        let s_4509_2: u8 = 15;
        // C s_4509_3: cast zx s_4509_2 -> bv
        let s_4509_3: Bits = Bits::new(s_4509_2 as u128, 4u16);
        // D s_4509_4: cmp-eq s_4509_1 s_4509_3
        let s_4509_4: bool = ((s_4509_1) == (s_4509_3));
        // D s_4509_5: write-var gs#118477 <= s_4509_4
        fn_state.gs_118477 = s_4509_4;
        // N s_4509_6: jump b2092
        return block_2092(state, tracer, fn_state);
    }
    fn block_4510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4510_0: read-var CRn:u8
        let s_4510_0: u8 = fn_state.CRn;
        // D s_4510_1: cast zx s_4510_0 -> bv
        let s_4510_1: Bits = Bits::new(s_4510_0 as u128, 4u16);
        // C s_4510_2: const #12u : u8
        let s_4510_2: u8 = 12;
        // C s_4510_3: cast zx s_4510_2 -> bv
        let s_4510_3: Bits = Bits::new(s_4510_2 as u128, 4u16);
        // D s_4510_4: cmp-eq s_4510_1 s_4510_3
        let s_4510_4: bool = ((s_4510_1) == (s_4510_3));
        // D s_4510_5: write-var gs#118476 <= s_4510_4
        fn_state.gs_118476 = s_4510_4;
        // N s_4510_6: jump b2090
        return block_2090(state, tracer, fn_state);
    }
    fn block_4511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4511_0: read-var el:u8
        let s_4511_0: u8 = fn_state.el;
        // D s_4511_1: read-var coproc:u8
        let s_4511_1: u8 = fn_state.coproc;
        // D s_4511_2: read-var opc1:u8
        let s_4511_2: u8 = fn_state.opc1;
        // D s_4511_3: read-var CRn:u8
        let s_4511_3: u8 = fn_state.CRn;
        // D s_4511_4: read-var opc2:u8
        let s_4511_4: u8 = fn_state.opc2;
        // D s_4511_5: read-var CRm:u8
        let s_4511_5: u8 = fn_state.CRm;
        // D s_4511_6: read-var t:i
        let s_4511_6: i128 = fn_state.t;
        // D s_4511_7: call ICH_LR_SysRegRead32_3d583fbb8aa5513b(s_4511_0, s_4511_1, s_4511_2, s_4511_3, s_4511_4, s_4511_5, s_4511_6)
        let s_4511_7: () = ICH_LR_SysRegRead32_3d583fbb8aa5513b(
            state,
            tracer,
            s_4511_0,
            s_4511_1,
            s_4511_2,
            s_4511_3,
            s_4511_4,
            s_4511_5,
            s_4511_6,
        );
        // N s_4511_8: return
        return;
    }
    fn block_4512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4512_0: read-var opc2:u8
        let s_4512_0: u8 = fn_state.opc2;
        // D s_4512_1: cast zx s_4512_0 -> bv
        let s_4512_1: Bits = Bits::new(s_4512_0 as u128, 3u16);
        // C s_4512_2: const #7u : u8
        let s_4512_2: u8 = 7;
        // C s_4512_3: cast zx s_4512_2 -> bv
        let s_4512_3: Bits = Bits::new(s_4512_2 as u128, 3u16);
        // D s_4512_4: cmp-eq s_4512_1 s_4512_3
        let s_4512_4: bool = ((s_4512_1) == (s_4512_3));
        // D s_4512_5: write-var gs#118475 <= s_4512_4
        fn_state.gs_118475 = s_4512_4;
        // N s_4512_6: jump b2087
        return block_2087(state, tracer, fn_state);
    }
    fn block_4513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4513_0: read-var opc1:u8
        let s_4513_0: u8 = fn_state.opc1;
        // D s_4513_1: cast zx s_4513_0 -> bv
        let s_4513_1: Bits = Bits::new(s_4513_0 as u128, 3u16);
        // C s_4513_2: const #4u : u8
        let s_4513_2: u8 = 4;
        // C s_4513_3: cast zx s_4513_2 -> bv
        let s_4513_3: Bits = Bits::new(s_4513_2 as u128, 3u16);
        // D s_4513_4: cmp-eq s_4513_1 s_4513_3
        let s_4513_4: bool = ((s_4513_1) == (s_4513_3));
        // D s_4513_5: write-var gs#118474 <= s_4513_4
        fn_state.gs_118474 = s_4513_4;
        // N s_4513_6: jump b2085
        return block_2085(state, tracer, fn_state);
    }
    fn block_4514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4514_0: read-var coproc:u8
        let s_4514_0: u8 = fn_state.coproc;
        // D s_4514_1: cast zx s_4514_0 -> bv
        let s_4514_1: Bits = Bits::new(s_4514_0 as u128, 4u16);
        // C s_4514_2: const #15u : u8
        let s_4514_2: u8 = 15;
        // C s_4514_3: cast zx s_4514_2 -> bv
        let s_4514_3: Bits = Bits::new(s_4514_2 as u128, 4u16);
        // D s_4514_4: cmp-eq s_4514_1 s_4514_3
        let s_4514_4: bool = ((s_4514_1) == (s_4514_3));
        // D s_4514_5: write-var gs#118473 <= s_4514_4
        fn_state.gs_118473 = s_4514_4;
        // N s_4514_6: jump b2083
        return block_2083(state, tracer, fn_state);
    }
    fn block_4515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4515_0: read-var CRn:u8
        let s_4515_0: u8 = fn_state.CRn;
        // D s_4515_1: cast zx s_4515_0 -> bv
        let s_4515_1: Bits = Bits::new(s_4515_0 as u128, 4u16);
        // C s_4515_2: const #12u : u8
        let s_4515_2: u8 = 12;
        // C s_4515_3: cast zx s_4515_2 -> bv
        let s_4515_3: Bits = Bits::new(s_4515_2 as u128, 4u16);
        // D s_4515_4: cmp-eq s_4515_1 s_4515_3
        let s_4515_4: bool = ((s_4515_1) == (s_4515_3));
        // D s_4515_5: write-var gs#118472 <= s_4515_4
        fn_state.gs_118472 = s_4515_4;
        // N s_4515_6: jump b2081
        return block_2081(state, tracer, fn_state);
    }
    fn block_4516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4516_0: read-var el:u8
        let s_4516_0: u8 = fn_state.el;
        // D s_4516_1: read-var coproc:u8
        let s_4516_1: u8 = fn_state.coproc;
        // D s_4516_2: read-var opc1:u8
        let s_4516_2: u8 = fn_state.opc1;
        // D s_4516_3: read-var CRn:u8
        let s_4516_3: u8 = fn_state.CRn;
        // D s_4516_4: read-var opc2:u8
        let s_4516_4: u8 = fn_state.opc2;
        // D s_4516_5: read-var CRm:u8
        let s_4516_5: u8 = fn_state.CRm;
        // D s_4516_6: read-var t:i
        let s_4516_6: i128 = fn_state.t;
        // D s_4516_7: call ICH_LR_SysRegRead32_9b173de940ca1870(s_4516_0, s_4516_1, s_4516_2, s_4516_3, s_4516_4, s_4516_5, s_4516_6)
        let s_4516_7: () = ICH_LR_SysRegRead32_9b173de940ca1870(
            state,
            tracer,
            s_4516_0,
            s_4516_1,
            s_4516_2,
            s_4516_3,
            s_4516_4,
            s_4516_5,
            s_4516_6,
        );
        // N s_4516_8: return
        return;
    }
    fn block_4517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4517_0: read-var opc2:u8
        let s_4517_0: u8 = fn_state.opc2;
        // D s_4517_1: cast zx s_4517_0 -> bv
        let s_4517_1: Bits = Bits::new(s_4517_0 as u128, 3u16);
        // C s_4517_2: const #0u : u8
        let s_4517_2: u8 = 0;
        // C s_4517_3: cast zx s_4517_2 -> bv
        let s_4517_3: Bits = Bits::new(s_4517_2 as u128, 3u16);
        // D s_4517_4: cmp-eq s_4517_1 s_4517_3
        let s_4517_4: bool = ((s_4517_1) == (s_4517_3));
        // D s_4517_5: write-var gs#118471 <= s_4517_4
        fn_state.gs_118471 = s_4517_4;
        // N s_4517_6: jump b2078
        return block_2078(state, tracer, fn_state);
    }
    fn block_4518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4518_0: read-var opc1:u8
        let s_4518_0: u8 = fn_state.opc1;
        // D s_4518_1: cast zx s_4518_0 -> bv
        let s_4518_1: Bits = Bits::new(s_4518_0 as u128, 3u16);
        // C s_4518_2: const #4u : u8
        let s_4518_2: u8 = 4;
        // C s_4518_3: cast zx s_4518_2 -> bv
        let s_4518_3: Bits = Bits::new(s_4518_2 as u128, 3u16);
        // D s_4518_4: cmp-eq s_4518_1 s_4518_3
        let s_4518_4: bool = ((s_4518_1) == (s_4518_3));
        // D s_4518_5: write-var gs#118470 <= s_4518_4
        fn_state.gs_118470 = s_4518_4;
        // N s_4518_6: jump b2076
        return block_2076(state, tracer, fn_state);
    }
    fn block_4519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4519_0: read-var coproc:u8
        let s_4519_0: u8 = fn_state.coproc;
        // D s_4519_1: cast zx s_4519_0 -> bv
        let s_4519_1: Bits = Bits::new(s_4519_0 as u128, 4u16);
        // C s_4519_2: const #15u : u8
        let s_4519_2: u8 = 15;
        // C s_4519_3: cast zx s_4519_2 -> bv
        let s_4519_3: Bits = Bits::new(s_4519_2 as u128, 4u16);
        // D s_4519_4: cmp-eq s_4519_1 s_4519_3
        let s_4519_4: bool = ((s_4519_1) == (s_4519_3));
        // D s_4519_5: write-var gs#118469 <= s_4519_4
        fn_state.gs_118469 = s_4519_4;
        // N s_4519_6: jump b2074
        return block_2074(state, tracer, fn_state);
    }
    fn block_4520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4520_0: read-var CRn:u8
        let s_4520_0: u8 = fn_state.CRn;
        // D s_4520_1: cast zx s_4520_0 -> bv
        let s_4520_1: Bits = Bits::new(s_4520_0 as u128, 4u16);
        // C s_4520_2: const #12u : u8
        let s_4520_2: u8 = 12;
        // C s_4520_3: cast zx s_4520_2 -> bv
        let s_4520_3: Bits = Bits::new(s_4520_2 as u128, 4u16);
        // D s_4520_4: cmp-eq s_4520_1 s_4520_3
        let s_4520_4: bool = ((s_4520_1) == (s_4520_3));
        // D s_4520_5: write-var gs#118468 <= s_4520_4
        fn_state.gs_118468 = s_4520_4;
        // N s_4520_6: jump b2072
        return block_2072(state, tracer, fn_state);
    }
    fn block_4521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4521_0: read-var el:u8
        let s_4521_0: u8 = fn_state.el;
        // D s_4521_1: read-var coproc:u8
        let s_4521_1: u8 = fn_state.coproc;
        // D s_4521_2: read-var opc1:u8
        let s_4521_2: u8 = fn_state.opc1;
        // D s_4521_3: read-var CRn:u8
        let s_4521_3: u8 = fn_state.CRn;
        // D s_4521_4: read-var opc2:u8
        let s_4521_4: u8 = fn_state.opc2;
        // D s_4521_5: read-var CRm:u8
        let s_4521_5: u8 = fn_state.CRm;
        // D s_4521_6: read-var t:i
        let s_4521_6: i128 = fn_state.t;
        // D s_4521_7: call ICH_LR_SysRegRead32_3bf5b46e983d4c12(s_4521_0, s_4521_1, s_4521_2, s_4521_3, s_4521_4, s_4521_5, s_4521_6)
        let s_4521_7: () = ICH_LR_SysRegRead32_3bf5b46e983d4c12(
            state,
            tracer,
            s_4521_0,
            s_4521_1,
            s_4521_2,
            s_4521_3,
            s_4521_4,
            s_4521_5,
            s_4521_6,
        );
        // N s_4521_8: return
        return;
    }
    fn block_4522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4522_0: read-var opc2:u8
        let s_4522_0: u8 = fn_state.opc2;
        // D s_4522_1: cast zx s_4522_0 -> bv
        let s_4522_1: Bits = Bits::new(s_4522_0 as u128, 3u16);
        // C s_4522_2: const #1u : u8
        let s_4522_2: u8 = 1;
        // C s_4522_3: cast zx s_4522_2 -> bv
        let s_4522_3: Bits = Bits::new(s_4522_2 as u128, 3u16);
        // D s_4522_4: cmp-eq s_4522_1 s_4522_3
        let s_4522_4: bool = ((s_4522_1) == (s_4522_3));
        // D s_4522_5: write-var gs#118467 <= s_4522_4
        fn_state.gs_118467 = s_4522_4;
        // N s_4522_6: jump b2069
        return block_2069(state, tracer, fn_state);
    }
    fn block_4523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4523_0: read-var opc1:u8
        let s_4523_0: u8 = fn_state.opc1;
        // D s_4523_1: cast zx s_4523_0 -> bv
        let s_4523_1: Bits = Bits::new(s_4523_0 as u128, 3u16);
        // C s_4523_2: const #4u : u8
        let s_4523_2: u8 = 4;
        // C s_4523_3: cast zx s_4523_2 -> bv
        let s_4523_3: Bits = Bits::new(s_4523_2 as u128, 3u16);
        // D s_4523_4: cmp-eq s_4523_1 s_4523_3
        let s_4523_4: bool = ((s_4523_1) == (s_4523_3));
        // D s_4523_5: write-var gs#118466 <= s_4523_4
        fn_state.gs_118466 = s_4523_4;
        // N s_4523_6: jump b2067
        return block_2067(state, tracer, fn_state);
    }
    fn block_4524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4524_0: read-var coproc:u8
        let s_4524_0: u8 = fn_state.coproc;
        // D s_4524_1: cast zx s_4524_0 -> bv
        let s_4524_1: Bits = Bits::new(s_4524_0 as u128, 4u16);
        // C s_4524_2: const #15u : u8
        let s_4524_2: u8 = 15;
        // C s_4524_3: cast zx s_4524_2 -> bv
        let s_4524_3: Bits = Bits::new(s_4524_2 as u128, 4u16);
        // D s_4524_4: cmp-eq s_4524_1 s_4524_3
        let s_4524_4: bool = ((s_4524_1) == (s_4524_3));
        // D s_4524_5: write-var gs#118465 <= s_4524_4
        fn_state.gs_118465 = s_4524_4;
        // N s_4524_6: jump b2065
        return block_2065(state, tracer, fn_state);
    }
    fn block_4525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4525_0: read-var CRn:u8
        let s_4525_0: u8 = fn_state.CRn;
        // D s_4525_1: cast zx s_4525_0 -> bv
        let s_4525_1: Bits = Bits::new(s_4525_0 as u128, 4u16);
        // C s_4525_2: const #12u : u8
        let s_4525_2: u8 = 12;
        // C s_4525_3: cast zx s_4525_2 -> bv
        let s_4525_3: Bits = Bits::new(s_4525_2 as u128, 4u16);
        // D s_4525_4: cmp-eq s_4525_1 s_4525_3
        let s_4525_4: bool = ((s_4525_1) == (s_4525_3));
        // D s_4525_5: write-var gs#118464 <= s_4525_4
        fn_state.gs_118464 = s_4525_4;
        // N s_4525_6: jump b2063
        return block_2063(state, tracer, fn_state);
    }
    fn block_4526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4526_0: read-var el:u8
        let s_4526_0: u8 = fn_state.el;
        // D s_4526_1: read-var coproc:u8
        let s_4526_1: u8 = fn_state.coproc;
        // D s_4526_2: read-var opc1:u8
        let s_4526_2: u8 = fn_state.opc1;
        // D s_4526_3: read-var CRn:u8
        let s_4526_3: u8 = fn_state.CRn;
        // D s_4526_4: read-var opc2:u8
        let s_4526_4: u8 = fn_state.opc2;
        // D s_4526_5: read-var CRm:u8
        let s_4526_5: u8 = fn_state.CRm;
        // D s_4526_6: read-var t:i
        let s_4526_6: i128 = fn_state.t;
        // D s_4526_7: call ICH_LR_SysRegRead32_1d761f8769ecc810(s_4526_0, s_4526_1, s_4526_2, s_4526_3, s_4526_4, s_4526_5, s_4526_6)
        let s_4526_7: () = ICH_LR_SysRegRead32_1d761f8769ecc810(
            state,
            tracer,
            s_4526_0,
            s_4526_1,
            s_4526_2,
            s_4526_3,
            s_4526_4,
            s_4526_5,
            s_4526_6,
        );
        // N s_4526_8: return
        return;
    }
    fn block_4527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4527_0: read-var opc2:u8
        let s_4527_0: u8 = fn_state.opc2;
        // D s_4527_1: cast zx s_4527_0 -> bv
        let s_4527_1: Bits = Bits::new(s_4527_0 as u128, 3u16);
        // C s_4527_2: const #2u : u8
        let s_4527_2: u8 = 2;
        // C s_4527_3: cast zx s_4527_2 -> bv
        let s_4527_3: Bits = Bits::new(s_4527_2 as u128, 3u16);
        // D s_4527_4: cmp-eq s_4527_1 s_4527_3
        let s_4527_4: bool = ((s_4527_1) == (s_4527_3));
        // D s_4527_5: write-var gs#118463 <= s_4527_4
        fn_state.gs_118463 = s_4527_4;
        // N s_4527_6: jump b2060
        return block_2060(state, tracer, fn_state);
    }
    fn block_4528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4528_0: read-var opc1:u8
        let s_4528_0: u8 = fn_state.opc1;
        // D s_4528_1: cast zx s_4528_0 -> bv
        let s_4528_1: Bits = Bits::new(s_4528_0 as u128, 3u16);
        // C s_4528_2: const #4u : u8
        let s_4528_2: u8 = 4;
        // C s_4528_3: cast zx s_4528_2 -> bv
        let s_4528_3: Bits = Bits::new(s_4528_2 as u128, 3u16);
        // D s_4528_4: cmp-eq s_4528_1 s_4528_3
        let s_4528_4: bool = ((s_4528_1) == (s_4528_3));
        // D s_4528_5: write-var gs#118462 <= s_4528_4
        fn_state.gs_118462 = s_4528_4;
        // N s_4528_6: jump b2058
        return block_2058(state, tracer, fn_state);
    }
    fn block_4529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4529_0: read-var coproc:u8
        let s_4529_0: u8 = fn_state.coproc;
        // D s_4529_1: cast zx s_4529_0 -> bv
        let s_4529_1: Bits = Bits::new(s_4529_0 as u128, 4u16);
        // C s_4529_2: const #15u : u8
        let s_4529_2: u8 = 15;
        // C s_4529_3: cast zx s_4529_2 -> bv
        let s_4529_3: Bits = Bits::new(s_4529_2 as u128, 4u16);
        // D s_4529_4: cmp-eq s_4529_1 s_4529_3
        let s_4529_4: bool = ((s_4529_1) == (s_4529_3));
        // D s_4529_5: write-var gs#118461 <= s_4529_4
        fn_state.gs_118461 = s_4529_4;
        // N s_4529_6: jump b2056
        return block_2056(state, tracer, fn_state);
    }
    fn block_4530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4530_0: read-var CRn:u8
        let s_4530_0: u8 = fn_state.CRn;
        // D s_4530_1: cast zx s_4530_0 -> bv
        let s_4530_1: Bits = Bits::new(s_4530_0 as u128, 4u16);
        // C s_4530_2: const #12u : u8
        let s_4530_2: u8 = 12;
        // C s_4530_3: cast zx s_4530_2 -> bv
        let s_4530_3: Bits = Bits::new(s_4530_2 as u128, 4u16);
        // D s_4530_4: cmp-eq s_4530_1 s_4530_3
        let s_4530_4: bool = ((s_4530_1) == (s_4530_3));
        // D s_4530_5: write-var gs#118460 <= s_4530_4
        fn_state.gs_118460 = s_4530_4;
        // N s_4530_6: jump b2054
        return block_2054(state, tracer, fn_state);
    }
    fn block_4531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4531_0: read-var el:u8
        let s_4531_0: u8 = fn_state.el;
        // D s_4531_1: read-var coproc:u8
        let s_4531_1: u8 = fn_state.coproc;
        // D s_4531_2: read-var opc1:u8
        let s_4531_2: u8 = fn_state.opc1;
        // D s_4531_3: read-var CRn:u8
        let s_4531_3: u8 = fn_state.CRn;
        // D s_4531_4: read-var opc2:u8
        let s_4531_4: u8 = fn_state.opc2;
        // D s_4531_5: read-var CRm:u8
        let s_4531_5: u8 = fn_state.CRm;
        // D s_4531_6: read-var t:i
        let s_4531_6: i128 = fn_state.t;
        // D s_4531_7: call ICH_LR_SysRegRead32_45c00df4516639fa(s_4531_0, s_4531_1, s_4531_2, s_4531_3, s_4531_4, s_4531_5, s_4531_6)
        let s_4531_7: () = ICH_LR_SysRegRead32_45c00df4516639fa(
            state,
            tracer,
            s_4531_0,
            s_4531_1,
            s_4531_2,
            s_4531_3,
            s_4531_4,
            s_4531_5,
            s_4531_6,
        );
        // N s_4531_8: return
        return;
    }
    fn block_4532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4532_0: read-var opc2:u8
        let s_4532_0: u8 = fn_state.opc2;
        // D s_4532_1: cast zx s_4532_0 -> bv
        let s_4532_1: Bits = Bits::new(s_4532_0 as u128, 3u16);
        // C s_4532_2: const #3u : u8
        let s_4532_2: u8 = 3;
        // C s_4532_3: cast zx s_4532_2 -> bv
        let s_4532_3: Bits = Bits::new(s_4532_2 as u128, 3u16);
        // D s_4532_4: cmp-eq s_4532_1 s_4532_3
        let s_4532_4: bool = ((s_4532_1) == (s_4532_3));
        // D s_4532_5: write-var gs#118459 <= s_4532_4
        fn_state.gs_118459 = s_4532_4;
        // N s_4532_6: jump b2051
        return block_2051(state, tracer, fn_state);
    }
    fn block_4533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4533_0: read-var opc1:u8
        let s_4533_0: u8 = fn_state.opc1;
        // D s_4533_1: cast zx s_4533_0 -> bv
        let s_4533_1: Bits = Bits::new(s_4533_0 as u128, 3u16);
        // C s_4533_2: const #4u : u8
        let s_4533_2: u8 = 4;
        // C s_4533_3: cast zx s_4533_2 -> bv
        let s_4533_3: Bits = Bits::new(s_4533_2 as u128, 3u16);
        // D s_4533_4: cmp-eq s_4533_1 s_4533_3
        let s_4533_4: bool = ((s_4533_1) == (s_4533_3));
        // D s_4533_5: write-var gs#118458 <= s_4533_4
        fn_state.gs_118458 = s_4533_4;
        // N s_4533_6: jump b2049
        return block_2049(state, tracer, fn_state);
    }
    fn block_4534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4534_0: read-var coproc:u8
        let s_4534_0: u8 = fn_state.coproc;
        // D s_4534_1: cast zx s_4534_0 -> bv
        let s_4534_1: Bits = Bits::new(s_4534_0 as u128, 4u16);
        // C s_4534_2: const #15u : u8
        let s_4534_2: u8 = 15;
        // C s_4534_3: cast zx s_4534_2 -> bv
        let s_4534_3: Bits = Bits::new(s_4534_2 as u128, 4u16);
        // D s_4534_4: cmp-eq s_4534_1 s_4534_3
        let s_4534_4: bool = ((s_4534_1) == (s_4534_3));
        // D s_4534_5: write-var gs#118457 <= s_4534_4
        fn_state.gs_118457 = s_4534_4;
        // N s_4534_6: jump b2047
        return block_2047(state, tracer, fn_state);
    }
    fn block_4535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4535_0: read-var CRn:u8
        let s_4535_0: u8 = fn_state.CRn;
        // D s_4535_1: cast zx s_4535_0 -> bv
        let s_4535_1: Bits = Bits::new(s_4535_0 as u128, 4u16);
        // C s_4535_2: const #12u : u8
        let s_4535_2: u8 = 12;
        // C s_4535_3: cast zx s_4535_2 -> bv
        let s_4535_3: Bits = Bits::new(s_4535_2 as u128, 4u16);
        // D s_4535_4: cmp-eq s_4535_1 s_4535_3
        let s_4535_4: bool = ((s_4535_1) == (s_4535_3));
        // D s_4535_5: write-var gs#118456 <= s_4535_4
        fn_state.gs_118456 = s_4535_4;
        // N s_4535_6: jump b2045
        return block_2045(state, tracer, fn_state);
    }
    fn block_4536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4536_0: read-var el:u8
        let s_4536_0: u8 = fn_state.el;
        // D s_4536_1: read-var coproc:u8
        let s_4536_1: u8 = fn_state.coproc;
        // D s_4536_2: read-var opc1:u8
        let s_4536_2: u8 = fn_state.opc1;
        // D s_4536_3: read-var CRn:u8
        let s_4536_3: u8 = fn_state.CRn;
        // D s_4536_4: read-var opc2:u8
        let s_4536_4: u8 = fn_state.opc2;
        // D s_4536_5: read-var CRm:u8
        let s_4536_5: u8 = fn_state.CRm;
        // D s_4536_6: read-var t:i
        let s_4536_6: i128 = fn_state.t;
        // D s_4536_7: call ICH_LR_SysRegRead32_ca0e018c3a31cc4a(s_4536_0, s_4536_1, s_4536_2, s_4536_3, s_4536_4, s_4536_5, s_4536_6)
        let s_4536_7: () = ICH_LR_SysRegRead32_ca0e018c3a31cc4a(
            state,
            tracer,
            s_4536_0,
            s_4536_1,
            s_4536_2,
            s_4536_3,
            s_4536_4,
            s_4536_5,
            s_4536_6,
        );
        // N s_4536_8: return
        return;
    }
    fn block_4537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4537_0: read-var opc2:u8
        let s_4537_0: u8 = fn_state.opc2;
        // D s_4537_1: cast zx s_4537_0 -> bv
        let s_4537_1: Bits = Bits::new(s_4537_0 as u128, 3u16);
        // C s_4537_2: const #4u : u8
        let s_4537_2: u8 = 4;
        // C s_4537_3: cast zx s_4537_2 -> bv
        let s_4537_3: Bits = Bits::new(s_4537_2 as u128, 3u16);
        // D s_4537_4: cmp-eq s_4537_1 s_4537_3
        let s_4537_4: bool = ((s_4537_1) == (s_4537_3));
        // D s_4537_5: write-var gs#118455 <= s_4537_4
        fn_state.gs_118455 = s_4537_4;
        // N s_4537_6: jump b2042
        return block_2042(state, tracer, fn_state);
    }
    fn block_4538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4538_0: read-var opc1:u8
        let s_4538_0: u8 = fn_state.opc1;
        // D s_4538_1: cast zx s_4538_0 -> bv
        let s_4538_1: Bits = Bits::new(s_4538_0 as u128, 3u16);
        // C s_4538_2: const #4u : u8
        let s_4538_2: u8 = 4;
        // C s_4538_3: cast zx s_4538_2 -> bv
        let s_4538_3: Bits = Bits::new(s_4538_2 as u128, 3u16);
        // D s_4538_4: cmp-eq s_4538_1 s_4538_3
        let s_4538_4: bool = ((s_4538_1) == (s_4538_3));
        // D s_4538_5: write-var gs#118454 <= s_4538_4
        fn_state.gs_118454 = s_4538_4;
        // N s_4538_6: jump b2040
        return block_2040(state, tracer, fn_state);
    }
    fn block_4539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4539_0: read-var coproc:u8
        let s_4539_0: u8 = fn_state.coproc;
        // D s_4539_1: cast zx s_4539_0 -> bv
        let s_4539_1: Bits = Bits::new(s_4539_0 as u128, 4u16);
        // C s_4539_2: const #15u : u8
        let s_4539_2: u8 = 15;
        // C s_4539_3: cast zx s_4539_2 -> bv
        let s_4539_3: Bits = Bits::new(s_4539_2 as u128, 4u16);
        // D s_4539_4: cmp-eq s_4539_1 s_4539_3
        let s_4539_4: bool = ((s_4539_1) == (s_4539_3));
        // D s_4539_5: write-var gs#118453 <= s_4539_4
        fn_state.gs_118453 = s_4539_4;
        // N s_4539_6: jump b2038
        return block_2038(state, tracer, fn_state);
    }
    fn block_4540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4540_0: read-var CRn:u8
        let s_4540_0: u8 = fn_state.CRn;
        // D s_4540_1: cast zx s_4540_0 -> bv
        let s_4540_1: Bits = Bits::new(s_4540_0 as u128, 4u16);
        // C s_4540_2: const #12u : u8
        let s_4540_2: u8 = 12;
        // C s_4540_3: cast zx s_4540_2 -> bv
        let s_4540_3: Bits = Bits::new(s_4540_2 as u128, 4u16);
        // D s_4540_4: cmp-eq s_4540_1 s_4540_3
        let s_4540_4: bool = ((s_4540_1) == (s_4540_3));
        // D s_4540_5: write-var gs#118452 <= s_4540_4
        fn_state.gs_118452 = s_4540_4;
        // N s_4540_6: jump b2036
        return block_2036(state, tracer, fn_state);
    }
    fn block_4541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4541_0: read-var el:u8
        let s_4541_0: u8 = fn_state.el;
        // D s_4541_1: read-var coproc:u8
        let s_4541_1: u8 = fn_state.coproc;
        // D s_4541_2: read-var opc1:u8
        let s_4541_2: u8 = fn_state.opc1;
        // D s_4541_3: read-var CRn:u8
        let s_4541_3: u8 = fn_state.CRn;
        // D s_4541_4: read-var opc2:u8
        let s_4541_4: u8 = fn_state.opc2;
        // D s_4541_5: read-var CRm:u8
        let s_4541_5: u8 = fn_state.CRm;
        // D s_4541_6: read-var t:i
        let s_4541_6: i128 = fn_state.t;
        // D s_4541_7: call ICH_LR_SysRegRead32_1acb03f084987252(s_4541_0, s_4541_1, s_4541_2, s_4541_3, s_4541_4, s_4541_5, s_4541_6)
        let s_4541_7: () = ICH_LR_SysRegRead32_1acb03f084987252(
            state,
            tracer,
            s_4541_0,
            s_4541_1,
            s_4541_2,
            s_4541_3,
            s_4541_4,
            s_4541_5,
            s_4541_6,
        );
        // N s_4541_8: return
        return;
    }
    fn block_4542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4542_0: read-var opc2:u8
        let s_4542_0: u8 = fn_state.opc2;
        // D s_4542_1: cast zx s_4542_0 -> bv
        let s_4542_1: Bits = Bits::new(s_4542_0 as u128, 3u16);
        // C s_4542_2: const #5u : u8
        let s_4542_2: u8 = 5;
        // C s_4542_3: cast zx s_4542_2 -> bv
        let s_4542_3: Bits = Bits::new(s_4542_2 as u128, 3u16);
        // D s_4542_4: cmp-eq s_4542_1 s_4542_3
        let s_4542_4: bool = ((s_4542_1) == (s_4542_3));
        // D s_4542_5: write-var gs#118451 <= s_4542_4
        fn_state.gs_118451 = s_4542_4;
        // N s_4542_6: jump b2033
        return block_2033(state, tracer, fn_state);
    }
    fn block_4543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4543_0: read-var opc1:u8
        let s_4543_0: u8 = fn_state.opc1;
        // D s_4543_1: cast zx s_4543_0 -> bv
        let s_4543_1: Bits = Bits::new(s_4543_0 as u128, 3u16);
        // C s_4543_2: const #4u : u8
        let s_4543_2: u8 = 4;
        // C s_4543_3: cast zx s_4543_2 -> bv
        let s_4543_3: Bits = Bits::new(s_4543_2 as u128, 3u16);
        // D s_4543_4: cmp-eq s_4543_1 s_4543_3
        let s_4543_4: bool = ((s_4543_1) == (s_4543_3));
        // D s_4543_5: write-var gs#118450 <= s_4543_4
        fn_state.gs_118450 = s_4543_4;
        // N s_4543_6: jump b2031
        return block_2031(state, tracer, fn_state);
    }
    fn block_4544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4544_0: read-var coproc:u8
        let s_4544_0: u8 = fn_state.coproc;
        // D s_4544_1: cast zx s_4544_0 -> bv
        let s_4544_1: Bits = Bits::new(s_4544_0 as u128, 4u16);
        // C s_4544_2: const #15u : u8
        let s_4544_2: u8 = 15;
        // C s_4544_3: cast zx s_4544_2 -> bv
        let s_4544_3: Bits = Bits::new(s_4544_2 as u128, 4u16);
        // D s_4544_4: cmp-eq s_4544_1 s_4544_3
        let s_4544_4: bool = ((s_4544_1) == (s_4544_3));
        // D s_4544_5: write-var gs#118449 <= s_4544_4
        fn_state.gs_118449 = s_4544_4;
        // N s_4544_6: jump b2029
        return block_2029(state, tracer, fn_state);
    }
    fn block_4545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4545_0: read-var CRn:u8
        let s_4545_0: u8 = fn_state.CRn;
        // D s_4545_1: cast zx s_4545_0 -> bv
        let s_4545_1: Bits = Bits::new(s_4545_0 as u128, 4u16);
        // C s_4545_2: const #12u : u8
        let s_4545_2: u8 = 12;
        // C s_4545_3: cast zx s_4545_2 -> bv
        let s_4545_3: Bits = Bits::new(s_4545_2 as u128, 4u16);
        // D s_4545_4: cmp-eq s_4545_1 s_4545_3
        let s_4545_4: bool = ((s_4545_1) == (s_4545_3));
        // D s_4545_5: write-var gs#118448 <= s_4545_4
        fn_state.gs_118448 = s_4545_4;
        // N s_4545_6: jump b2027
        return block_2027(state, tracer, fn_state);
    }
    fn block_4546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4546_0: read-var el:u8
        let s_4546_0: u8 = fn_state.el;
        // D s_4546_1: read-var coproc:u8
        let s_4546_1: u8 = fn_state.coproc;
        // D s_4546_2: read-var opc1:u8
        let s_4546_2: u8 = fn_state.opc1;
        // D s_4546_3: read-var CRn:u8
        let s_4546_3: u8 = fn_state.CRn;
        // D s_4546_4: read-var opc2:u8
        let s_4546_4: u8 = fn_state.opc2;
        // D s_4546_5: read-var CRm:u8
        let s_4546_5: u8 = fn_state.CRm;
        // D s_4546_6: read-var t:i
        let s_4546_6: i128 = fn_state.t;
        // D s_4546_7: call ICH_LR_SysRegRead32_1d190d8da488b71c(s_4546_0, s_4546_1, s_4546_2, s_4546_3, s_4546_4, s_4546_5, s_4546_6)
        let s_4546_7: () = ICH_LR_SysRegRead32_1d190d8da488b71c(
            state,
            tracer,
            s_4546_0,
            s_4546_1,
            s_4546_2,
            s_4546_3,
            s_4546_4,
            s_4546_5,
            s_4546_6,
        );
        // N s_4546_8: return
        return;
    }
    fn block_4547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4547_0: read-var opc2:u8
        let s_4547_0: u8 = fn_state.opc2;
        // D s_4547_1: cast zx s_4547_0 -> bv
        let s_4547_1: Bits = Bits::new(s_4547_0 as u128, 3u16);
        // C s_4547_2: const #6u : u8
        let s_4547_2: u8 = 6;
        // C s_4547_3: cast zx s_4547_2 -> bv
        let s_4547_3: Bits = Bits::new(s_4547_2 as u128, 3u16);
        // D s_4547_4: cmp-eq s_4547_1 s_4547_3
        let s_4547_4: bool = ((s_4547_1) == (s_4547_3));
        // D s_4547_5: write-var gs#118447 <= s_4547_4
        fn_state.gs_118447 = s_4547_4;
        // N s_4547_6: jump b2024
        return block_2024(state, tracer, fn_state);
    }
    fn block_4548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4548_0: read-var opc1:u8
        let s_4548_0: u8 = fn_state.opc1;
        // D s_4548_1: cast zx s_4548_0 -> bv
        let s_4548_1: Bits = Bits::new(s_4548_0 as u128, 3u16);
        // C s_4548_2: const #4u : u8
        let s_4548_2: u8 = 4;
        // C s_4548_3: cast zx s_4548_2 -> bv
        let s_4548_3: Bits = Bits::new(s_4548_2 as u128, 3u16);
        // D s_4548_4: cmp-eq s_4548_1 s_4548_3
        let s_4548_4: bool = ((s_4548_1) == (s_4548_3));
        // D s_4548_5: write-var gs#118446 <= s_4548_4
        fn_state.gs_118446 = s_4548_4;
        // N s_4548_6: jump b2022
        return block_2022(state, tracer, fn_state);
    }
    fn block_4549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4549_0: read-var coproc:u8
        let s_4549_0: u8 = fn_state.coproc;
        // D s_4549_1: cast zx s_4549_0 -> bv
        let s_4549_1: Bits = Bits::new(s_4549_0 as u128, 4u16);
        // C s_4549_2: const #15u : u8
        let s_4549_2: u8 = 15;
        // C s_4549_3: cast zx s_4549_2 -> bv
        let s_4549_3: Bits = Bits::new(s_4549_2 as u128, 4u16);
        // D s_4549_4: cmp-eq s_4549_1 s_4549_3
        let s_4549_4: bool = ((s_4549_1) == (s_4549_3));
        // D s_4549_5: write-var gs#118445 <= s_4549_4
        fn_state.gs_118445 = s_4549_4;
        // N s_4549_6: jump b2020
        return block_2020(state, tracer, fn_state);
    }
    fn block_4550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4550_0: read-var CRn:u8
        let s_4550_0: u8 = fn_state.CRn;
        // D s_4550_1: cast zx s_4550_0 -> bv
        let s_4550_1: Bits = Bits::new(s_4550_0 as u128, 4u16);
        // C s_4550_2: const #12u : u8
        let s_4550_2: u8 = 12;
        // C s_4550_3: cast zx s_4550_2 -> bv
        let s_4550_3: Bits = Bits::new(s_4550_2 as u128, 4u16);
        // D s_4550_4: cmp-eq s_4550_1 s_4550_3
        let s_4550_4: bool = ((s_4550_1) == (s_4550_3));
        // D s_4550_5: write-var gs#118444 <= s_4550_4
        fn_state.gs_118444 = s_4550_4;
        // N s_4550_6: jump b2018
        return block_2018(state, tracer, fn_state);
    }
    fn block_4551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4551_0: read-var el:u8
        let s_4551_0: u8 = fn_state.el;
        // D s_4551_1: read-var coproc:u8
        let s_4551_1: u8 = fn_state.coproc;
        // D s_4551_2: read-var opc1:u8
        let s_4551_2: u8 = fn_state.opc1;
        // D s_4551_3: read-var CRn:u8
        let s_4551_3: u8 = fn_state.CRn;
        // D s_4551_4: read-var opc2:u8
        let s_4551_4: u8 = fn_state.opc2;
        // D s_4551_5: read-var CRm:u8
        let s_4551_5: u8 = fn_state.CRm;
        // D s_4551_6: read-var t:i
        let s_4551_6: i128 = fn_state.t;
        // D s_4551_7: call ICH_LR_SysRegRead32_8e77adbc9c8c8d7d(s_4551_0, s_4551_1, s_4551_2, s_4551_3, s_4551_4, s_4551_5, s_4551_6)
        let s_4551_7: () = ICH_LR_SysRegRead32_8e77adbc9c8c8d7d(
            state,
            tracer,
            s_4551_0,
            s_4551_1,
            s_4551_2,
            s_4551_3,
            s_4551_4,
            s_4551_5,
            s_4551_6,
        );
        // N s_4551_8: return
        return;
    }
    fn block_4552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4552_0: read-var opc2:u8
        let s_4552_0: u8 = fn_state.opc2;
        // D s_4552_1: cast zx s_4552_0 -> bv
        let s_4552_1: Bits = Bits::new(s_4552_0 as u128, 3u16);
        // C s_4552_2: const #7u : u8
        let s_4552_2: u8 = 7;
        // C s_4552_3: cast zx s_4552_2 -> bv
        let s_4552_3: Bits = Bits::new(s_4552_2 as u128, 3u16);
        // D s_4552_4: cmp-eq s_4552_1 s_4552_3
        let s_4552_4: bool = ((s_4552_1) == (s_4552_3));
        // D s_4552_5: write-var gs#118443 <= s_4552_4
        fn_state.gs_118443 = s_4552_4;
        // N s_4552_6: jump b2015
        return block_2015(state, tracer, fn_state);
    }
    fn block_4553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4553_0: read-var opc1:u8
        let s_4553_0: u8 = fn_state.opc1;
        // D s_4553_1: cast zx s_4553_0 -> bv
        let s_4553_1: Bits = Bits::new(s_4553_0 as u128, 3u16);
        // C s_4553_2: const #4u : u8
        let s_4553_2: u8 = 4;
        // C s_4553_3: cast zx s_4553_2 -> bv
        let s_4553_3: Bits = Bits::new(s_4553_2 as u128, 3u16);
        // D s_4553_4: cmp-eq s_4553_1 s_4553_3
        let s_4553_4: bool = ((s_4553_1) == (s_4553_3));
        // D s_4553_5: write-var gs#118442 <= s_4553_4
        fn_state.gs_118442 = s_4553_4;
        // N s_4553_6: jump b2013
        return block_2013(state, tracer, fn_state);
    }
    fn block_4554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4554_0: read-var coproc:u8
        let s_4554_0: u8 = fn_state.coproc;
        // D s_4554_1: cast zx s_4554_0 -> bv
        let s_4554_1: Bits = Bits::new(s_4554_0 as u128, 4u16);
        // C s_4554_2: const #15u : u8
        let s_4554_2: u8 = 15;
        // C s_4554_3: cast zx s_4554_2 -> bv
        let s_4554_3: Bits = Bits::new(s_4554_2 as u128, 4u16);
        // D s_4554_4: cmp-eq s_4554_1 s_4554_3
        let s_4554_4: bool = ((s_4554_1) == (s_4554_3));
        // D s_4554_5: write-var gs#118441 <= s_4554_4
        fn_state.gs_118441 = s_4554_4;
        // N s_4554_6: jump b2011
        return block_2011(state, tracer, fn_state);
    }
    fn block_4555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4555_0: read-var CRn:u8
        let s_4555_0: u8 = fn_state.CRn;
        // D s_4555_1: cast zx s_4555_0 -> bv
        let s_4555_1: Bits = Bits::new(s_4555_0 as u128, 4u16);
        // C s_4555_2: const #12u : u8
        let s_4555_2: u8 = 12;
        // C s_4555_3: cast zx s_4555_2 -> bv
        let s_4555_3: Bits = Bits::new(s_4555_2 as u128, 4u16);
        // D s_4555_4: cmp-eq s_4555_1 s_4555_3
        let s_4555_4: bool = ((s_4555_1) == (s_4555_3));
        // D s_4555_5: write-var gs#118440 <= s_4555_4
        fn_state.gs_118440 = s_4555_4;
        // N s_4555_6: jump b2009
        return block_2009(state, tracer, fn_state);
    }
    fn block_4556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4556_0: read-var el:u8
        let s_4556_0: u8 = fn_state.el;
        // D s_4556_1: read-var coproc:u8
        let s_4556_1: u8 = fn_state.coproc;
        // D s_4556_2: read-var opc1:u8
        let s_4556_2: u8 = fn_state.opc1;
        // D s_4556_3: read-var CRn:u8
        let s_4556_3: u8 = fn_state.CRn;
        // D s_4556_4: read-var opc2:u8
        let s_4556_4: u8 = fn_state.opc2;
        // D s_4556_5: read-var CRm:u8
        let s_4556_5: u8 = fn_state.CRm;
        // D s_4556_6: read-var t:i
        let s_4556_6: i128 = fn_state.t;
        // D s_4556_7: call ID_DFR1_SysRegRead32_a7aac5df14f5281e(s_4556_0, s_4556_1, s_4556_2, s_4556_3, s_4556_4, s_4556_5, s_4556_6)
        let s_4556_7: () = ID_DFR1_SysRegRead32_a7aac5df14f5281e(
            state,
            tracer,
            s_4556_0,
            s_4556_1,
            s_4556_2,
            s_4556_3,
            s_4556_4,
            s_4556_5,
            s_4556_6,
        );
        // N s_4556_8: return
        return;
    }
    fn block_4557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4557_0: read-var opc2:u8
        let s_4557_0: u8 = fn_state.opc2;
        // D s_4557_1: cast zx s_4557_0 -> bv
        let s_4557_1: Bits = Bits::new(s_4557_0 as u128, 3u16);
        // C s_4557_2: const #5u : u8
        let s_4557_2: u8 = 5;
        // C s_4557_3: cast zx s_4557_2 -> bv
        let s_4557_3: Bits = Bits::new(s_4557_2 as u128, 3u16);
        // D s_4557_4: cmp-eq s_4557_1 s_4557_3
        let s_4557_4: bool = ((s_4557_1) == (s_4557_3));
        // D s_4557_5: write-var gs#118439 <= s_4557_4
        fn_state.gs_118439 = s_4557_4;
        // N s_4557_6: jump b2006
        return block_2006(state, tracer, fn_state);
    }
    fn block_4558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4558_0: read-var opc1:u8
        let s_4558_0: u8 = fn_state.opc1;
        // D s_4558_1: cast zx s_4558_0 -> bv
        let s_4558_1: Bits = Bits::new(s_4558_0 as u128, 3u16);
        // C s_4558_2: const #0u : u8
        let s_4558_2: u8 = 0;
        // C s_4558_3: cast zx s_4558_2 -> bv
        let s_4558_3: Bits = Bits::new(s_4558_2 as u128, 3u16);
        // D s_4558_4: cmp-eq s_4558_1 s_4558_3
        let s_4558_4: bool = ((s_4558_1) == (s_4558_3));
        // D s_4558_5: write-var gs#118438 <= s_4558_4
        fn_state.gs_118438 = s_4558_4;
        // N s_4558_6: jump b2004
        return block_2004(state, tracer, fn_state);
    }
    fn block_4559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4559_0: read-var coproc:u8
        let s_4559_0: u8 = fn_state.coproc;
        // D s_4559_1: cast zx s_4559_0 -> bv
        let s_4559_1: Bits = Bits::new(s_4559_0 as u128, 4u16);
        // C s_4559_2: const #15u : u8
        let s_4559_2: u8 = 15;
        // C s_4559_3: cast zx s_4559_2 -> bv
        let s_4559_3: Bits = Bits::new(s_4559_2 as u128, 4u16);
        // D s_4559_4: cmp-eq s_4559_1 s_4559_3
        let s_4559_4: bool = ((s_4559_1) == (s_4559_3));
        // D s_4559_5: write-var gs#118437 <= s_4559_4
        fn_state.gs_118437 = s_4559_4;
        // N s_4559_6: jump b2002
        return block_2002(state, tracer, fn_state);
    }
    fn block_4560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4560_0: read-var CRn:u8
        let s_4560_0: u8 = fn_state.CRn;
        // D s_4560_1: cast zx s_4560_0 -> bv
        let s_4560_1: Bits = Bits::new(s_4560_0 as u128, 4u16);
        // C s_4560_2: const #0u : u8
        let s_4560_2: u8 = 0;
        // C s_4560_3: cast zx s_4560_2 -> bv
        let s_4560_3: Bits = Bits::new(s_4560_2 as u128, 4u16);
        // D s_4560_4: cmp-eq s_4560_1 s_4560_3
        let s_4560_4: bool = ((s_4560_1) == (s_4560_3));
        // D s_4560_5: write-var gs#118436 <= s_4560_4
        fn_state.gs_118436 = s_4560_4;
        // N s_4560_6: jump b2000
        return block_2000(state, tracer, fn_state);
    }
    fn block_4561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4561_0: read-var el:u8
        let s_4561_0: u8 = fn_state.el;
        // D s_4561_1: read-var coproc:u8
        let s_4561_1: u8 = fn_state.coproc;
        // D s_4561_2: read-var opc1:u8
        let s_4561_2: u8 = fn_state.opc1;
        // D s_4561_3: read-var CRn:u8
        let s_4561_3: u8 = fn_state.CRn;
        // D s_4561_4: read-var opc2:u8
        let s_4561_4: u8 = fn_state.opc2;
        // D s_4561_5: read-var CRm:u8
        let s_4561_5: u8 = fn_state.CRm;
        // D s_4561_6: read-var t:i
        let s_4561_6: i128 = fn_state.t;
        // D s_4561_7: call FCSEIDR_SysRegRead32_cb9b2f57b39997f9(s_4561_0, s_4561_1, s_4561_2, s_4561_3, s_4561_4, s_4561_5, s_4561_6)
        let s_4561_7: () = FCSEIDR_SysRegRead32_cb9b2f57b39997f9(
            state,
            tracer,
            s_4561_0,
            s_4561_1,
            s_4561_2,
            s_4561_3,
            s_4561_4,
            s_4561_5,
            s_4561_6,
        );
        // N s_4561_8: return
        return;
    }
    fn block_4562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4562_0: read-var opc2:u8
        let s_4562_0: u8 = fn_state.opc2;
        // D s_4562_1: cast zx s_4562_0 -> bv
        let s_4562_1: Bits = Bits::new(s_4562_0 as u128, 3u16);
        // C s_4562_2: const #0u : u8
        let s_4562_2: u8 = 0;
        // C s_4562_3: cast zx s_4562_2 -> bv
        let s_4562_3: Bits = Bits::new(s_4562_2 as u128, 3u16);
        // D s_4562_4: cmp-eq s_4562_1 s_4562_3
        let s_4562_4: bool = ((s_4562_1) == (s_4562_3));
        // D s_4562_5: write-var gs#118435 <= s_4562_4
        fn_state.gs_118435 = s_4562_4;
        // N s_4562_6: jump b1997
        return block_1997(state, tracer, fn_state);
    }
    fn block_4563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4563_0: read-var opc1:u8
        let s_4563_0: u8 = fn_state.opc1;
        // D s_4563_1: cast zx s_4563_0 -> bv
        let s_4563_1: Bits = Bits::new(s_4563_0 as u128, 3u16);
        // C s_4563_2: const #0u : u8
        let s_4563_2: u8 = 0;
        // C s_4563_3: cast zx s_4563_2 -> bv
        let s_4563_3: Bits = Bits::new(s_4563_2 as u128, 3u16);
        // D s_4563_4: cmp-eq s_4563_1 s_4563_3
        let s_4563_4: bool = ((s_4563_1) == (s_4563_3));
        // D s_4563_5: write-var gs#118434 <= s_4563_4
        fn_state.gs_118434 = s_4563_4;
        // N s_4563_6: jump b1995
        return block_1995(state, tracer, fn_state);
    }
    fn block_4564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4564_0: read-var coproc:u8
        let s_4564_0: u8 = fn_state.coproc;
        // D s_4564_1: cast zx s_4564_0 -> bv
        let s_4564_1: Bits = Bits::new(s_4564_0 as u128, 4u16);
        // C s_4564_2: const #15u : u8
        let s_4564_2: u8 = 15;
        // C s_4564_3: cast zx s_4564_2 -> bv
        let s_4564_3: Bits = Bits::new(s_4564_2 as u128, 4u16);
        // D s_4564_4: cmp-eq s_4564_1 s_4564_3
        let s_4564_4: bool = ((s_4564_1) == (s_4564_3));
        // D s_4564_5: write-var gs#118433 <= s_4564_4
        fn_state.gs_118433 = s_4564_4;
        // N s_4564_6: jump b1993
        return block_1993(state, tracer, fn_state);
    }
    fn block_4565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4565_0: read-var CRn:u8
        let s_4565_0: u8 = fn_state.CRn;
        // D s_4565_1: cast zx s_4565_0 -> bv
        let s_4565_1: Bits = Bits::new(s_4565_0 as u128, 4u16);
        // C s_4565_2: const #13u : u8
        let s_4565_2: u8 = 13;
        // C s_4565_3: cast zx s_4565_2 -> bv
        let s_4565_3: Bits = Bits::new(s_4565_2 as u128, 4u16);
        // D s_4565_4: cmp-eq s_4565_1 s_4565_3
        let s_4565_4: bool = ((s_4565_1) == (s_4565_3));
        // D s_4565_5: write-var gs#118432 <= s_4565_4
        fn_state.gs_118432 = s_4565_4;
        // N s_4565_6: jump b1991
        return block_1991(state, tracer, fn_state);
    }
    fn block_4566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4566_0: read-var el:u8
        let s_4566_0: u8 = fn_state.el;
        // D s_4566_1: read-var coproc:u8
        let s_4566_1: u8 = fn_state.coproc;
        // D s_4566_2: read-var opc1:u8
        let s_4566_2: u8 = fn_state.opc1;
        // D s_4566_3: read-var CRn:u8
        let s_4566_3: u8 = fn_state.CRn;
        // D s_4566_4: read-var opc2:u8
        let s_4566_4: u8 = fn_state.opc2;
        // D s_4566_5: read-var CRm:u8
        let s_4566_5: u8 = fn_state.CRm;
        // D s_4566_6: read-var t:i
        let s_4566_6: i128 = fn_state.t;
        // D s_4566_7: call HSR_SysRegRead32_8b698f9bb5858477(s_4566_0, s_4566_1, s_4566_2, s_4566_3, s_4566_4, s_4566_5, s_4566_6)
        let s_4566_7: () = HSR_SysRegRead32_8b698f9bb5858477(
            state,
            tracer,
            s_4566_0,
            s_4566_1,
            s_4566_2,
            s_4566_3,
            s_4566_4,
            s_4566_5,
            s_4566_6,
        );
        // N s_4566_8: return
        return;
    }
    fn block_4567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4567_0: read-var opc2:u8
        let s_4567_0: u8 = fn_state.opc2;
        // D s_4567_1: cast zx s_4567_0 -> bv
        let s_4567_1: Bits = Bits::new(s_4567_0 as u128, 3u16);
        // C s_4567_2: const #0u : u8
        let s_4567_2: u8 = 0;
        // C s_4567_3: cast zx s_4567_2 -> bv
        let s_4567_3: Bits = Bits::new(s_4567_2 as u128, 3u16);
        // D s_4567_4: cmp-eq s_4567_1 s_4567_3
        let s_4567_4: bool = ((s_4567_1) == (s_4567_3));
        // D s_4567_5: write-var gs#118431 <= s_4567_4
        fn_state.gs_118431 = s_4567_4;
        // N s_4567_6: jump b1988
        return block_1988(state, tracer, fn_state);
    }
    fn block_4568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4568_0: read-var opc1:u8
        let s_4568_0: u8 = fn_state.opc1;
        // D s_4568_1: cast zx s_4568_0 -> bv
        let s_4568_1: Bits = Bits::new(s_4568_0 as u128, 3u16);
        // C s_4568_2: const #4u : u8
        let s_4568_2: u8 = 4;
        // C s_4568_3: cast zx s_4568_2 -> bv
        let s_4568_3: Bits = Bits::new(s_4568_2 as u128, 3u16);
        // D s_4568_4: cmp-eq s_4568_1 s_4568_3
        let s_4568_4: bool = ((s_4568_1) == (s_4568_3));
        // D s_4568_5: write-var gs#118430 <= s_4568_4
        fn_state.gs_118430 = s_4568_4;
        // N s_4568_6: jump b1986
        return block_1986(state, tracer, fn_state);
    }
    fn block_4569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4569_0: read-var coproc:u8
        let s_4569_0: u8 = fn_state.coproc;
        // D s_4569_1: cast zx s_4569_0 -> bv
        let s_4569_1: Bits = Bits::new(s_4569_0 as u128, 4u16);
        // C s_4569_2: const #15u : u8
        let s_4569_2: u8 = 15;
        // C s_4569_3: cast zx s_4569_2 -> bv
        let s_4569_3: Bits = Bits::new(s_4569_2 as u128, 4u16);
        // D s_4569_4: cmp-eq s_4569_1 s_4569_3
        let s_4569_4: bool = ((s_4569_1) == (s_4569_3));
        // D s_4569_5: write-var gs#118429 <= s_4569_4
        fn_state.gs_118429 = s_4569_4;
        // N s_4569_6: jump b1984
        return block_1984(state, tracer, fn_state);
    }
    fn block_4570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4570_0: read-var CRn:u8
        let s_4570_0: u8 = fn_state.CRn;
        // D s_4570_1: cast zx s_4570_0 -> bv
        let s_4570_1: Bits = Bits::new(s_4570_0 as u128, 4u16);
        // C s_4570_2: const #5u : u8
        let s_4570_2: u8 = 5;
        // C s_4570_3: cast zx s_4570_2 -> bv
        let s_4570_3: Bits = Bits::new(s_4570_2 as u128, 4u16);
        // D s_4570_4: cmp-eq s_4570_1 s_4570_3
        let s_4570_4: bool = ((s_4570_1) == (s_4570_3));
        // D s_4570_5: write-var gs#118428 <= s_4570_4
        fn_state.gs_118428 = s_4570_4;
        // N s_4570_6: jump b1982
        return block_1982(state, tracer, fn_state);
    }
    fn block_4571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4571_0: read-var el:u8
        let s_4571_0: u8 = fn_state.el;
        // D s_4571_1: read-var coproc:u8
        let s_4571_1: u8 = fn_state.coproc;
        // D s_4571_2: read-var opc1:u8
        let s_4571_2: u8 = fn_state.opc1;
        // D s_4571_3: read-var CRn:u8
        let s_4571_3: u8 = fn_state.CRn;
        // D s_4571_4: read-var opc2:u8
        let s_4571_4: u8 = fn_state.opc2;
        // D s_4571_5: read-var CRm:u8
        let s_4571_5: u8 = fn_state.CRm;
        // D s_4571_6: read-var t:i
        let s_4571_6: i128 = fn_state.t;
        // D s_4571_7: call PMCEID2_SysRegRead32_68a39928b2956924(s_4571_0, s_4571_1, s_4571_2, s_4571_3, s_4571_4, s_4571_5, s_4571_6)
        let s_4571_7: () = PMCEID2_SysRegRead32_68a39928b2956924(
            state,
            tracer,
            s_4571_0,
            s_4571_1,
            s_4571_2,
            s_4571_3,
            s_4571_4,
            s_4571_5,
            s_4571_6,
        );
        // N s_4571_8: return
        return;
    }
    fn block_4572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4572_0: read-var opc2:u8
        let s_4572_0: u8 = fn_state.opc2;
        // D s_4572_1: cast zx s_4572_0 -> bv
        let s_4572_1: Bits = Bits::new(s_4572_0 as u128, 3u16);
        // C s_4572_2: const #4u : u8
        let s_4572_2: u8 = 4;
        // C s_4572_3: cast zx s_4572_2 -> bv
        let s_4572_3: Bits = Bits::new(s_4572_2 as u128, 3u16);
        // D s_4572_4: cmp-eq s_4572_1 s_4572_3
        let s_4572_4: bool = ((s_4572_1) == (s_4572_3));
        // D s_4572_5: write-var gs#118427 <= s_4572_4
        fn_state.gs_118427 = s_4572_4;
        // N s_4572_6: jump b1979
        return block_1979(state, tracer, fn_state);
    }
    fn block_4573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4573_0: read-var opc1:u8
        let s_4573_0: u8 = fn_state.opc1;
        // D s_4573_1: cast zx s_4573_0 -> bv
        let s_4573_1: Bits = Bits::new(s_4573_0 as u128, 3u16);
        // C s_4573_2: const #0u : u8
        let s_4573_2: u8 = 0;
        // C s_4573_3: cast zx s_4573_2 -> bv
        let s_4573_3: Bits = Bits::new(s_4573_2 as u128, 3u16);
        // D s_4573_4: cmp-eq s_4573_1 s_4573_3
        let s_4573_4: bool = ((s_4573_1) == (s_4573_3));
        // D s_4573_5: write-var gs#118426 <= s_4573_4
        fn_state.gs_118426 = s_4573_4;
        // N s_4573_6: jump b1977
        return block_1977(state, tracer, fn_state);
    }
    fn block_4574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4574_0: read-var coproc:u8
        let s_4574_0: u8 = fn_state.coproc;
        // D s_4574_1: cast zx s_4574_0 -> bv
        let s_4574_1: Bits = Bits::new(s_4574_0 as u128, 4u16);
        // C s_4574_2: const #15u : u8
        let s_4574_2: u8 = 15;
        // C s_4574_3: cast zx s_4574_2 -> bv
        let s_4574_3: Bits = Bits::new(s_4574_2 as u128, 4u16);
        // D s_4574_4: cmp-eq s_4574_1 s_4574_3
        let s_4574_4: bool = ((s_4574_1) == (s_4574_3));
        // D s_4574_5: write-var gs#118425 <= s_4574_4
        fn_state.gs_118425 = s_4574_4;
        // N s_4574_6: jump b1975
        return block_1975(state, tracer, fn_state);
    }
    fn block_4575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4575_0: read-var CRn:u8
        let s_4575_0: u8 = fn_state.CRn;
        // D s_4575_1: cast zx s_4575_0 -> bv
        let s_4575_1: Bits = Bits::new(s_4575_0 as u128, 4u16);
        // C s_4575_2: const #9u : u8
        let s_4575_2: u8 = 9;
        // C s_4575_3: cast zx s_4575_2 -> bv
        let s_4575_3: Bits = Bits::new(s_4575_2 as u128, 4u16);
        // D s_4575_4: cmp-eq s_4575_1 s_4575_3
        let s_4575_4: bool = ((s_4575_1) == (s_4575_3));
        // D s_4575_5: write-var gs#118424 <= s_4575_4
        fn_state.gs_118424 = s_4575_4;
        // N s_4575_6: jump b1973
        return block_1973(state, tracer, fn_state);
    }
    fn block_4576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4576_0: read-var el:u8
        let s_4576_0: u8 = fn_state.el;
        // D s_4576_1: read-var coproc:u8
        let s_4576_1: u8 = fn_state.coproc;
        // D s_4576_2: read-var opc1:u8
        let s_4576_2: u8 = fn_state.opc1;
        // D s_4576_3: read-var CRn:u8
        let s_4576_3: u8 = fn_state.CRn;
        // D s_4576_4: read-var opc2:u8
        let s_4576_4: u8 = fn_state.opc2;
        // D s_4576_5: read-var CRm:u8
        let s_4576_5: u8 = fn_state.CRm;
        // D s_4576_6: read-var t:i
        let s_4576_6: i128 = fn_state.t;
        // D s_4576_7: call ID_ISAR4_SysRegRead32_851598e56793628d(s_4576_0, s_4576_1, s_4576_2, s_4576_3, s_4576_4, s_4576_5, s_4576_6)
        let s_4576_7: () = ID_ISAR4_SysRegRead32_851598e56793628d(
            state,
            tracer,
            s_4576_0,
            s_4576_1,
            s_4576_2,
            s_4576_3,
            s_4576_4,
            s_4576_5,
            s_4576_6,
        );
        // N s_4576_8: return
        return;
    }
    fn block_4577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4577_0: read-var opc2:u8
        let s_4577_0: u8 = fn_state.opc2;
        // D s_4577_1: cast zx s_4577_0 -> bv
        let s_4577_1: Bits = Bits::new(s_4577_0 as u128, 3u16);
        // C s_4577_2: const #4u : u8
        let s_4577_2: u8 = 4;
        // C s_4577_3: cast zx s_4577_2 -> bv
        let s_4577_3: Bits = Bits::new(s_4577_2 as u128, 3u16);
        // D s_4577_4: cmp-eq s_4577_1 s_4577_3
        let s_4577_4: bool = ((s_4577_1) == (s_4577_3));
        // D s_4577_5: write-var gs#118423 <= s_4577_4
        fn_state.gs_118423 = s_4577_4;
        // N s_4577_6: jump b1970
        return block_1970(state, tracer, fn_state);
    }
    fn block_4578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4578_0: read-var opc1:u8
        let s_4578_0: u8 = fn_state.opc1;
        // D s_4578_1: cast zx s_4578_0 -> bv
        let s_4578_1: Bits = Bits::new(s_4578_0 as u128, 3u16);
        // C s_4578_2: const #0u : u8
        let s_4578_2: u8 = 0;
        // C s_4578_3: cast zx s_4578_2 -> bv
        let s_4578_3: Bits = Bits::new(s_4578_2 as u128, 3u16);
        // D s_4578_4: cmp-eq s_4578_1 s_4578_3
        let s_4578_4: bool = ((s_4578_1) == (s_4578_3));
        // D s_4578_5: write-var gs#118422 <= s_4578_4
        fn_state.gs_118422 = s_4578_4;
        // N s_4578_6: jump b1968
        return block_1968(state, tracer, fn_state);
    }
    fn block_4579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4579_0: read-var coproc:u8
        let s_4579_0: u8 = fn_state.coproc;
        // D s_4579_1: cast zx s_4579_0 -> bv
        let s_4579_1: Bits = Bits::new(s_4579_0 as u128, 4u16);
        // C s_4579_2: const #15u : u8
        let s_4579_2: u8 = 15;
        // C s_4579_3: cast zx s_4579_2 -> bv
        let s_4579_3: Bits = Bits::new(s_4579_2 as u128, 4u16);
        // D s_4579_4: cmp-eq s_4579_1 s_4579_3
        let s_4579_4: bool = ((s_4579_1) == (s_4579_3));
        // D s_4579_5: write-var gs#118421 <= s_4579_4
        fn_state.gs_118421 = s_4579_4;
        // N s_4579_6: jump b1966
        return block_1966(state, tracer, fn_state);
    }
    fn block_4580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4580_0: read-var CRn:u8
        let s_4580_0: u8 = fn_state.CRn;
        // D s_4580_1: cast zx s_4580_0 -> bv
        let s_4580_1: Bits = Bits::new(s_4580_0 as u128, 4u16);
        // C s_4580_2: const #0u : u8
        let s_4580_2: u8 = 0;
        // C s_4580_3: cast zx s_4580_2 -> bv
        let s_4580_3: Bits = Bits::new(s_4580_2 as u128, 4u16);
        // D s_4580_4: cmp-eq s_4580_1 s_4580_3
        let s_4580_4: bool = ((s_4580_1) == (s_4580_3));
        // D s_4580_5: write-var gs#118420 <= s_4580_4
        fn_state.gs_118420 = s_4580_4;
        // N s_4580_6: jump b1964
        return block_1964(state, tracer, fn_state);
    }
    fn block_4581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4581_0: read-var el:u8
        let s_4581_0: u8 = fn_state.el;
        // D s_4581_1: read-var coproc:u8
        let s_4581_1: u8 = fn_state.coproc;
        // D s_4581_2: read-var opc1:u8
        let s_4581_2: u8 = fn_state.opc1;
        // D s_4581_3: read-var CRn:u8
        let s_4581_3: u8 = fn_state.CRn;
        // D s_4581_4: read-var opc2:u8
        let s_4581_4: u8 = fn_state.opc2;
        // D s_4581_5: read-var CRm:u8
        let s_4581_5: u8 = fn_state.CRm;
        // D s_4581_6: read-var t:i
        let s_4581_6: i128 = fn_state.t;
        // D s_4581_7: call TTBCR2_SysRegRead32_9005164b21d17bb0(s_4581_0, s_4581_1, s_4581_2, s_4581_3, s_4581_4, s_4581_5, s_4581_6)
        let s_4581_7: () = TTBCR2_SysRegRead32_9005164b21d17bb0(
            state,
            tracer,
            s_4581_0,
            s_4581_1,
            s_4581_2,
            s_4581_3,
            s_4581_4,
            s_4581_5,
            s_4581_6,
        );
        // N s_4581_8: return
        return;
    }
    fn block_4582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4582_0: read-var opc2:u8
        let s_4582_0: u8 = fn_state.opc2;
        // D s_4582_1: cast zx s_4582_0 -> bv
        let s_4582_1: Bits = Bits::new(s_4582_0 as u128, 3u16);
        // C s_4582_2: const #3u : u8
        let s_4582_2: u8 = 3;
        // C s_4582_3: cast zx s_4582_2 -> bv
        let s_4582_3: Bits = Bits::new(s_4582_2 as u128, 3u16);
        // D s_4582_4: cmp-eq s_4582_1 s_4582_3
        let s_4582_4: bool = ((s_4582_1) == (s_4582_3));
        // D s_4582_5: write-var gs#118419 <= s_4582_4
        fn_state.gs_118419 = s_4582_4;
        // N s_4582_6: jump b1961
        return block_1961(state, tracer, fn_state);
    }
    fn block_4583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4583_0: read-var opc1:u8
        let s_4583_0: u8 = fn_state.opc1;
        // D s_4583_1: cast zx s_4583_0 -> bv
        let s_4583_1: Bits = Bits::new(s_4583_0 as u128, 3u16);
        // C s_4583_2: const #0u : u8
        let s_4583_2: u8 = 0;
        // C s_4583_3: cast zx s_4583_2 -> bv
        let s_4583_3: Bits = Bits::new(s_4583_2 as u128, 3u16);
        // D s_4583_4: cmp-eq s_4583_1 s_4583_3
        let s_4583_4: bool = ((s_4583_1) == (s_4583_3));
        // D s_4583_5: write-var gs#118418 <= s_4583_4
        fn_state.gs_118418 = s_4583_4;
        // N s_4583_6: jump b1959
        return block_1959(state, tracer, fn_state);
    }
    fn block_4584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4584_0: read-var coproc:u8
        let s_4584_0: u8 = fn_state.coproc;
        // D s_4584_1: cast zx s_4584_0 -> bv
        let s_4584_1: Bits = Bits::new(s_4584_0 as u128, 4u16);
        // C s_4584_2: const #15u : u8
        let s_4584_2: u8 = 15;
        // C s_4584_3: cast zx s_4584_2 -> bv
        let s_4584_3: Bits = Bits::new(s_4584_2 as u128, 4u16);
        // D s_4584_4: cmp-eq s_4584_1 s_4584_3
        let s_4584_4: bool = ((s_4584_1) == (s_4584_3));
        // D s_4584_5: write-var gs#118417 <= s_4584_4
        fn_state.gs_118417 = s_4584_4;
        // N s_4584_6: jump b1957
        return block_1957(state, tracer, fn_state);
    }
    fn block_4585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4585_0: read-var CRn:u8
        let s_4585_0: u8 = fn_state.CRn;
        // D s_4585_1: cast zx s_4585_0 -> bv
        let s_4585_1: Bits = Bits::new(s_4585_0 as u128, 4u16);
        // C s_4585_2: const #2u : u8
        let s_4585_2: u8 = 2;
        // C s_4585_3: cast zx s_4585_2 -> bv
        let s_4585_3: Bits = Bits::new(s_4585_2 as u128, 4u16);
        // D s_4585_4: cmp-eq s_4585_1 s_4585_3
        let s_4585_4: bool = ((s_4585_1) == (s_4585_3));
        // D s_4585_5: write-var gs#118416 <= s_4585_4
        fn_state.gs_118416 = s_4585_4;
        // N s_4585_6: jump b1955
        return block_1955(state, tracer, fn_state);
    }
    fn block_4586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4586_0: read-var el:u8
        let s_4586_0: u8 = fn_state.el;
        // D s_4586_1: read-var coproc:u8
        let s_4586_1: u8 = fn_state.coproc;
        // D s_4586_2: read-var opc1:u8
        let s_4586_2: u8 = fn_state.opc1;
        // D s_4586_3: read-var CRn:u8
        let s_4586_3: u8 = fn_state.CRn;
        // D s_4586_4: read-var opc2:u8
        let s_4586_4: u8 = fn_state.opc2;
        // D s_4586_5: read-var CRm:u8
        let s_4586_5: u8 = fn_state.CRm;
        // D s_4586_6: read-var t:i
        let s_4586_6: i128 = fn_state.t;
        // D s_4586_7: call ICC_HPPIR0_SysRegRead32_b32431f23ec6243a(s_4586_0, s_4586_1, s_4586_2, s_4586_3, s_4586_4, s_4586_5, s_4586_6)
        let s_4586_7: () = ICC_HPPIR0_SysRegRead32_b32431f23ec6243a(
            state,
            tracer,
            s_4586_0,
            s_4586_1,
            s_4586_2,
            s_4586_3,
            s_4586_4,
            s_4586_5,
            s_4586_6,
        );
        // N s_4586_8: return
        return;
    }
    fn block_4587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4587_0: read-var opc2:u8
        let s_4587_0: u8 = fn_state.opc2;
        // D s_4587_1: cast zx s_4587_0 -> bv
        let s_4587_1: Bits = Bits::new(s_4587_0 as u128, 3u16);
        // C s_4587_2: const #2u : u8
        let s_4587_2: u8 = 2;
        // C s_4587_3: cast zx s_4587_2 -> bv
        let s_4587_3: Bits = Bits::new(s_4587_2 as u128, 3u16);
        // D s_4587_4: cmp-eq s_4587_1 s_4587_3
        let s_4587_4: bool = ((s_4587_1) == (s_4587_3));
        // D s_4587_5: write-var gs#118415 <= s_4587_4
        fn_state.gs_118415 = s_4587_4;
        // N s_4587_6: jump b1952
        return block_1952(state, tracer, fn_state);
    }
    fn block_4588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4588_0: read-var opc1:u8
        let s_4588_0: u8 = fn_state.opc1;
        // D s_4588_1: cast zx s_4588_0 -> bv
        let s_4588_1: Bits = Bits::new(s_4588_0 as u128, 3u16);
        // C s_4588_2: const #0u : u8
        let s_4588_2: u8 = 0;
        // C s_4588_3: cast zx s_4588_2 -> bv
        let s_4588_3: Bits = Bits::new(s_4588_2 as u128, 3u16);
        // D s_4588_4: cmp-eq s_4588_1 s_4588_3
        let s_4588_4: bool = ((s_4588_1) == (s_4588_3));
        // D s_4588_5: write-var gs#118414 <= s_4588_4
        fn_state.gs_118414 = s_4588_4;
        // N s_4588_6: jump b1950
        return block_1950(state, tracer, fn_state);
    }
    fn block_4589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4589_0: read-var coproc:u8
        let s_4589_0: u8 = fn_state.coproc;
        // D s_4589_1: cast zx s_4589_0 -> bv
        let s_4589_1: Bits = Bits::new(s_4589_0 as u128, 4u16);
        // C s_4589_2: const #15u : u8
        let s_4589_2: u8 = 15;
        // C s_4589_3: cast zx s_4589_2 -> bv
        let s_4589_3: Bits = Bits::new(s_4589_2 as u128, 4u16);
        // D s_4589_4: cmp-eq s_4589_1 s_4589_3
        let s_4589_4: bool = ((s_4589_1) == (s_4589_3));
        // D s_4589_5: write-var gs#118413 <= s_4589_4
        fn_state.gs_118413 = s_4589_4;
        // N s_4589_6: jump b1948
        return block_1948(state, tracer, fn_state);
    }
    fn block_4590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4590_0: read-var CRn:u8
        let s_4590_0: u8 = fn_state.CRn;
        // D s_4590_1: cast zx s_4590_0 -> bv
        let s_4590_1: Bits = Bits::new(s_4590_0 as u128, 4u16);
        // C s_4590_2: const #12u : u8
        let s_4590_2: u8 = 12;
        // C s_4590_3: cast zx s_4590_2 -> bv
        let s_4590_3: Bits = Bits::new(s_4590_2 as u128, 4u16);
        // D s_4590_4: cmp-eq s_4590_1 s_4590_3
        let s_4590_4: bool = ((s_4590_1) == (s_4590_3));
        // D s_4590_5: write-var gs#118412 <= s_4590_4
        fn_state.gs_118412 = s_4590_4;
        // N s_4590_6: jump b1946
        return block_1946(state, tracer, fn_state);
    }
    fn block_4591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4591_0: read-var el:u8
        let s_4591_0: u8 = fn_state.el;
        // D s_4591_1: read-var coproc:u8
        let s_4591_1: u8 = fn_state.coproc;
        // D s_4591_2: read-var opc1:u8
        let s_4591_2: u8 = fn_state.opc1;
        // D s_4591_3: read-var CRn:u8
        let s_4591_3: u8 = fn_state.CRn;
        // D s_4591_4: read-var opc2:u8
        let s_4591_4: u8 = fn_state.opc2;
        // D s_4591_5: read-var CRm:u8
        let s_4591_5: u8 = fn_state.CRm;
        // D s_4591_6: read-var t:i
        let s_4591_6: i128 = fn_state.t;
        // D s_4591_7: call PMCEID3_SysRegRead32_2032ab5473c7b6ab(s_4591_0, s_4591_1, s_4591_2, s_4591_3, s_4591_4, s_4591_5, s_4591_6)
        let s_4591_7: () = PMCEID3_SysRegRead32_2032ab5473c7b6ab(
            state,
            tracer,
            s_4591_0,
            s_4591_1,
            s_4591_2,
            s_4591_3,
            s_4591_4,
            s_4591_5,
            s_4591_6,
        );
        // N s_4591_8: return
        return;
    }
    fn block_4592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4592_0: read-var opc2:u8
        let s_4592_0: u8 = fn_state.opc2;
        // D s_4592_1: cast zx s_4592_0 -> bv
        let s_4592_1: Bits = Bits::new(s_4592_0 as u128, 3u16);
        // C s_4592_2: const #5u : u8
        let s_4592_2: u8 = 5;
        // C s_4592_3: cast zx s_4592_2 -> bv
        let s_4592_3: Bits = Bits::new(s_4592_2 as u128, 3u16);
        // D s_4592_4: cmp-eq s_4592_1 s_4592_3
        let s_4592_4: bool = ((s_4592_1) == (s_4592_3));
        // D s_4592_5: write-var gs#118411 <= s_4592_4
        fn_state.gs_118411 = s_4592_4;
        // N s_4592_6: jump b1943
        return block_1943(state, tracer, fn_state);
    }
    fn block_4593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4593_0: read-var opc1:u8
        let s_4593_0: u8 = fn_state.opc1;
        // D s_4593_1: cast zx s_4593_0 -> bv
        let s_4593_1: Bits = Bits::new(s_4593_0 as u128, 3u16);
        // C s_4593_2: const #0u : u8
        let s_4593_2: u8 = 0;
        // C s_4593_3: cast zx s_4593_2 -> bv
        let s_4593_3: Bits = Bits::new(s_4593_2 as u128, 3u16);
        // D s_4593_4: cmp-eq s_4593_1 s_4593_3
        let s_4593_4: bool = ((s_4593_1) == (s_4593_3));
        // D s_4593_5: write-var gs#118410 <= s_4593_4
        fn_state.gs_118410 = s_4593_4;
        // N s_4593_6: jump b1941
        return block_1941(state, tracer, fn_state);
    }
    fn block_4594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4594_0: read-var coproc:u8
        let s_4594_0: u8 = fn_state.coproc;
        // D s_4594_1: cast zx s_4594_0 -> bv
        let s_4594_1: Bits = Bits::new(s_4594_0 as u128, 4u16);
        // C s_4594_2: const #15u : u8
        let s_4594_2: u8 = 15;
        // C s_4594_3: cast zx s_4594_2 -> bv
        let s_4594_3: Bits = Bits::new(s_4594_2 as u128, 4u16);
        // D s_4594_4: cmp-eq s_4594_1 s_4594_3
        let s_4594_4: bool = ((s_4594_1) == (s_4594_3));
        // D s_4594_5: write-var gs#118409 <= s_4594_4
        fn_state.gs_118409 = s_4594_4;
        // N s_4594_6: jump b1939
        return block_1939(state, tracer, fn_state);
    }
    fn block_4595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4595_0: read-var CRn:u8
        let s_4595_0: u8 = fn_state.CRn;
        // D s_4595_1: cast zx s_4595_0 -> bv
        let s_4595_1: Bits = Bits::new(s_4595_0 as u128, 4u16);
        // C s_4595_2: const #9u : u8
        let s_4595_2: u8 = 9;
        // C s_4595_3: cast zx s_4595_2 -> bv
        let s_4595_3: Bits = Bits::new(s_4595_2 as u128, 4u16);
        // D s_4595_4: cmp-eq s_4595_1 s_4595_3
        let s_4595_4: bool = ((s_4595_1) == (s_4595_3));
        // D s_4595_5: write-var gs#118408 <= s_4595_4
        fn_state.gs_118408 = s_4595_4;
        // N s_4595_6: jump b1937
        return block_1937(state, tracer, fn_state);
    }
    fn block_4596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4596_0: read-var el:u8
        let s_4596_0: u8 = fn_state.el;
        // D s_4596_1: read-var coproc:u8
        let s_4596_1: u8 = fn_state.coproc;
        // D s_4596_2: read-var opc1:u8
        let s_4596_2: u8 = fn_state.opc1;
        // D s_4596_3: read-var CRn:u8
        let s_4596_3: u8 = fn_state.CRn;
        // D s_4596_4: read-var opc2:u8
        let s_4596_4: u8 = fn_state.opc2;
        // D s_4596_5: read-var CRm:u8
        let s_4596_5: u8 = fn_state.CRm;
        // D s_4596_6: read-var t:i
        let s_4596_6: i128 = fn_state.t;
        // D s_4596_7: call HMAIR1_SysRegRead32_fd5c958c2380e7ae(s_4596_0, s_4596_1, s_4596_2, s_4596_3, s_4596_4, s_4596_5, s_4596_6)
        let s_4596_7: () = HMAIR1_SysRegRead32_fd5c958c2380e7ae(
            state,
            tracer,
            s_4596_0,
            s_4596_1,
            s_4596_2,
            s_4596_3,
            s_4596_4,
            s_4596_5,
            s_4596_6,
        );
        // N s_4596_8: return
        return;
    }
    fn block_4597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4597_0: read-var opc2:u8
        let s_4597_0: u8 = fn_state.opc2;
        // D s_4597_1: cast zx s_4597_0 -> bv
        let s_4597_1: Bits = Bits::new(s_4597_0 as u128, 3u16);
        // C s_4597_2: const #1u : u8
        let s_4597_2: u8 = 1;
        // C s_4597_3: cast zx s_4597_2 -> bv
        let s_4597_3: Bits = Bits::new(s_4597_2 as u128, 3u16);
        // D s_4597_4: cmp-eq s_4597_1 s_4597_3
        let s_4597_4: bool = ((s_4597_1) == (s_4597_3));
        // D s_4597_5: write-var gs#118407 <= s_4597_4
        fn_state.gs_118407 = s_4597_4;
        // N s_4597_6: jump b1934
        return block_1934(state, tracer, fn_state);
    }
    fn block_4598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4598_0: read-var opc1:u8
        let s_4598_0: u8 = fn_state.opc1;
        // D s_4598_1: cast zx s_4598_0 -> bv
        let s_4598_1: Bits = Bits::new(s_4598_0 as u128, 3u16);
        // C s_4598_2: const #4u : u8
        let s_4598_2: u8 = 4;
        // C s_4598_3: cast zx s_4598_2 -> bv
        let s_4598_3: Bits = Bits::new(s_4598_2 as u128, 3u16);
        // D s_4598_4: cmp-eq s_4598_1 s_4598_3
        let s_4598_4: bool = ((s_4598_1) == (s_4598_3));
        // D s_4598_5: write-var gs#118406 <= s_4598_4
        fn_state.gs_118406 = s_4598_4;
        // N s_4598_6: jump b1932
        return block_1932(state, tracer, fn_state);
    }
    fn block_4599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4599_0: read-var coproc:u8
        let s_4599_0: u8 = fn_state.coproc;
        // D s_4599_1: cast zx s_4599_0 -> bv
        let s_4599_1: Bits = Bits::new(s_4599_0 as u128, 4u16);
        // C s_4599_2: const #15u : u8
        let s_4599_2: u8 = 15;
        // C s_4599_3: cast zx s_4599_2 -> bv
        let s_4599_3: Bits = Bits::new(s_4599_2 as u128, 4u16);
        // D s_4599_4: cmp-eq s_4599_1 s_4599_3
        let s_4599_4: bool = ((s_4599_1) == (s_4599_3));
        // D s_4599_5: write-var gs#118405 <= s_4599_4
        fn_state.gs_118405 = s_4599_4;
        // N s_4599_6: jump b1930
        return block_1930(state, tracer, fn_state);
    }
    fn block_4600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4600_0: read-var CRn:u8
        let s_4600_0: u8 = fn_state.CRn;
        // D s_4600_1: cast zx s_4600_0 -> bv
        let s_4600_1: Bits = Bits::new(s_4600_0 as u128, 4u16);
        // C s_4600_2: const #10u : u8
        let s_4600_2: u8 = 10;
        // C s_4600_3: cast zx s_4600_2 -> bv
        let s_4600_3: Bits = Bits::new(s_4600_2 as u128, 4u16);
        // D s_4600_4: cmp-eq s_4600_1 s_4600_3
        let s_4600_4: bool = ((s_4600_1) == (s_4600_3));
        // D s_4600_5: write-var gs#118404 <= s_4600_4
        fn_state.gs_118404 = s_4600_4;
        // N s_4600_6: jump b1928
        return block_1928(state, tracer, fn_state);
    }
    fn block_4601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4601_0: read-var el:u8
        let s_4601_0: u8 = fn_state.el;
        // D s_4601_1: read-var coproc:u8
        let s_4601_1: u8 = fn_state.coproc;
        // D s_4601_2: read-var opc1:u8
        let s_4601_2: u8 = fn_state.opc1;
        // D s_4601_3: read-var CRn:u8
        let s_4601_3: u8 = fn_state.CRn;
        // D s_4601_4: read-var opc2:u8
        let s_4601_4: u8 = fn_state.opc2;
        // D s_4601_5: read-var CRm:u8
        let s_4601_5: u8 = fn_state.CRm;
        // D s_4601_6: read-var t:i
        let s_4601_6: i128 = fn_state.t;
        // D s_4601_7: call RMR_SysRegRead32_43cf65be6b4153a2(s_4601_0, s_4601_1, s_4601_2, s_4601_3, s_4601_4, s_4601_5, s_4601_6)
        let s_4601_7: () = RMR_SysRegRead32_43cf65be6b4153a2(
            state,
            tracer,
            s_4601_0,
            s_4601_1,
            s_4601_2,
            s_4601_3,
            s_4601_4,
            s_4601_5,
            s_4601_6,
        );
        // N s_4601_8: return
        return;
    }
    fn block_4602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4602_0: read-var opc2:u8
        let s_4602_0: u8 = fn_state.opc2;
        // D s_4602_1: cast zx s_4602_0 -> bv
        let s_4602_1: Bits = Bits::new(s_4602_0 as u128, 3u16);
        // C s_4602_2: const #2u : u8
        let s_4602_2: u8 = 2;
        // C s_4602_3: cast zx s_4602_2 -> bv
        let s_4602_3: Bits = Bits::new(s_4602_2 as u128, 3u16);
        // D s_4602_4: cmp-eq s_4602_1 s_4602_3
        let s_4602_4: bool = ((s_4602_1) == (s_4602_3));
        // D s_4602_5: write-var gs#118403 <= s_4602_4
        fn_state.gs_118403 = s_4602_4;
        // N s_4602_6: jump b1925
        return block_1925(state, tracer, fn_state);
    }
    fn block_4603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4603_0: read-var opc1:u8
        let s_4603_0: u8 = fn_state.opc1;
        // D s_4603_1: cast zx s_4603_0 -> bv
        let s_4603_1: Bits = Bits::new(s_4603_0 as u128, 3u16);
        // C s_4603_2: const #0u : u8
        let s_4603_2: u8 = 0;
        // C s_4603_3: cast zx s_4603_2 -> bv
        let s_4603_3: Bits = Bits::new(s_4603_2 as u128, 3u16);
        // D s_4603_4: cmp-eq s_4603_1 s_4603_3
        let s_4603_4: bool = ((s_4603_1) == (s_4603_3));
        // D s_4603_5: write-var gs#118402 <= s_4603_4
        fn_state.gs_118402 = s_4603_4;
        // N s_4603_6: jump b1923
        return block_1923(state, tracer, fn_state);
    }
    fn block_4604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4604_0: read-var coproc:u8
        let s_4604_0: u8 = fn_state.coproc;
        // D s_4604_1: cast zx s_4604_0 -> bv
        let s_4604_1: Bits = Bits::new(s_4604_0 as u128, 4u16);
        // C s_4604_2: const #15u : u8
        let s_4604_2: u8 = 15;
        // C s_4604_3: cast zx s_4604_2 -> bv
        let s_4604_3: Bits = Bits::new(s_4604_2 as u128, 4u16);
        // D s_4604_4: cmp-eq s_4604_1 s_4604_3
        let s_4604_4: bool = ((s_4604_1) == (s_4604_3));
        // D s_4604_5: write-var gs#118401 <= s_4604_4
        fn_state.gs_118401 = s_4604_4;
        // N s_4604_6: jump b1921
        return block_1921(state, tracer, fn_state);
    }
    fn block_4605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4605_0: read-var CRn:u8
        let s_4605_0: u8 = fn_state.CRn;
        // D s_4605_1: cast zx s_4605_0 -> bv
        let s_4605_1: Bits = Bits::new(s_4605_0 as u128, 4u16);
        // C s_4605_2: const #12u : u8
        let s_4605_2: u8 = 12;
        // C s_4605_3: cast zx s_4605_2 -> bv
        let s_4605_3: Bits = Bits::new(s_4605_2 as u128, 4u16);
        // D s_4605_4: cmp-eq s_4605_1 s_4605_3
        let s_4605_4: bool = ((s_4605_1) == (s_4605_3));
        // D s_4605_5: write-var gs#118400 <= s_4605_4
        fn_state.gs_118400 = s_4605_4;
        // N s_4605_6: jump b1919
        return block_1919(state, tracer, fn_state);
    }
    fn block_4606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4606_0: read-var el:u8
        let s_4606_0: u8 = fn_state.el;
        // D s_4606_1: read-var coproc:u8
        let s_4606_1: u8 = fn_state.coproc;
        // D s_4606_2: read-var opc1:u8
        let s_4606_2: u8 = fn_state.opc1;
        // D s_4606_3: read-var CRn:u8
        let s_4606_3: u8 = fn_state.CRn;
        // D s_4606_4: read-var opc2:u8
        let s_4606_4: u8 = fn_state.opc2;
        // D s_4606_5: read-var CRm:u8
        let s_4606_5: u8 = fn_state.CRm;
        // D s_4606_6: read-var t:i
        let s_4606_6: i128 = fn_state.t;
        // D s_4606_7: call ICH_HCR_SysRegRead32_49d2eca523adf51c(s_4606_0, s_4606_1, s_4606_2, s_4606_3, s_4606_4, s_4606_5, s_4606_6)
        let s_4606_7: () = ICH_HCR_SysRegRead32_49d2eca523adf51c(
            state,
            tracer,
            s_4606_0,
            s_4606_1,
            s_4606_2,
            s_4606_3,
            s_4606_4,
            s_4606_5,
            s_4606_6,
        );
        // N s_4606_8: return
        return;
    }
    fn block_4607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4607_0: read-var opc2:u8
        let s_4607_0: u8 = fn_state.opc2;
        // D s_4607_1: cast zx s_4607_0 -> bv
        let s_4607_1: Bits = Bits::new(s_4607_0 as u128, 3u16);
        // C s_4607_2: const #0u : u8
        let s_4607_2: u8 = 0;
        // C s_4607_3: cast zx s_4607_2 -> bv
        let s_4607_3: Bits = Bits::new(s_4607_2 as u128, 3u16);
        // D s_4607_4: cmp-eq s_4607_1 s_4607_3
        let s_4607_4: bool = ((s_4607_1) == (s_4607_3));
        // D s_4607_5: write-var gs#118399 <= s_4607_4
        fn_state.gs_118399 = s_4607_4;
        // N s_4607_6: jump b1916
        return block_1916(state, tracer, fn_state);
    }
    fn block_4608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4608_0: read-var opc1:u8
        let s_4608_0: u8 = fn_state.opc1;
        // D s_4608_1: cast zx s_4608_0 -> bv
        let s_4608_1: Bits = Bits::new(s_4608_0 as u128, 3u16);
        // C s_4608_2: const #4u : u8
        let s_4608_2: u8 = 4;
        // C s_4608_3: cast zx s_4608_2 -> bv
        let s_4608_3: Bits = Bits::new(s_4608_2 as u128, 3u16);
        // D s_4608_4: cmp-eq s_4608_1 s_4608_3
        let s_4608_4: bool = ((s_4608_1) == (s_4608_3));
        // D s_4608_5: write-var gs#118398 <= s_4608_4
        fn_state.gs_118398 = s_4608_4;
        // N s_4608_6: jump b1914
        return block_1914(state, tracer, fn_state);
    }
    fn block_4609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4609_0: read-var coproc:u8
        let s_4609_0: u8 = fn_state.coproc;
        // D s_4609_1: cast zx s_4609_0 -> bv
        let s_4609_1: Bits = Bits::new(s_4609_0 as u128, 4u16);
        // C s_4609_2: const #15u : u8
        let s_4609_2: u8 = 15;
        // C s_4609_3: cast zx s_4609_2 -> bv
        let s_4609_3: Bits = Bits::new(s_4609_2 as u128, 4u16);
        // D s_4609_4: cmp-eq s_4609_1 s_4609_3
        let s_4609_4: bool = ((s_4609_1) == (s_4609_3));
        // D s_4609_5: write-var gs#118397 <= s_4609_4
        fn_state.gs_118397 = s_4609_4;
        // N s_4609_6: jump b1912
        return block_1912(state, tracer, fn_state);
    }
    fn block_4610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4610_0: read-var CRn:u8
        let s_4610_0: u8 = fn_state.CRn;
        // D s_4610_1: cast zx s_4610_0 -> bv
        let s_4610_1: Bits = Bits::new(s_4610_0 as u128, 4u16);
        // C s_4610_2: const #12u : u8
        let s_4610_2: u8 = 12;
        // C s_4610_3: cast zx s_4610_2 -> bv
        let s_4610_3: Bits = Bits::new(s_4610_2 as u128, 4u16);
        // D s_4610_4: cmp-eq s_4610_1 s_4610_3
        let s_4610_4: bool = ((s_4610_1) == (s_4610_3));
        // D s_4610_5: write-var gs#118396 <= s_4610_4
        fn_state.gs_118396 = s_4610_4;
        // N s_4610_6: jump b1910
        return block_1910(state, tracer, fn_state);
    }
    fn block_4611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4611_0: read-var el:u8
        let s_4611_0: u8 = fn_state.el;
        // D s_4611_1: read-var coproc:u8
        let s_4611_1: u8 = fn_state.coproc;
        // D s_4611_2: read-var opc1:u8
        let s_4611_2: u8 = fn_state.opc1;
        // D s_4611_3: read-var CRn:u8
        let s_4611_3: u8 = fn_state.CRn;
        // D s_4611_4: read-var opc2:u8
        let s_4611_4: u8 = fn_state.opc2;
        // D s_4611_5: read-var CRm:u8
        let s_4611_5: u8 = fn_state.CRm;
        // D s_4611_6: read-var t:i
        let s_4611_6: i128 = fn_state.t;
        // D s_4611_7: call ID_PFR1_SysRegRead32_699454254ae0abbb(s_4611_0, s_4611_1, s_4611_2, s_4611_3, s_4611_4, s_4611_5, s_4611_6)
        let s_4611_7: () = ID_PFR1_SysRegRead32_699454254ae0abbb(
            state,
            tracer,
            s_4611_0,
            s_4611_1,
            s_4611_2,
            s_4611_3,
            s_4611_4,
            s_4611_5,
            s_4611_6,
        );
        // N s_4611_8: return
        return;
    }
    fn block_4612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4612_0: read-var opc2:u8
        let s_4612_0: u8 = fn_state.opc2;
        // D s_4612_1: cast zx s_4612_0 -> bv
        let s_4612_1: Bits = Bits::new(s_4612_0 as u128, 3u16);
        // C s_4612_2: const #1u : u8
        let s_4612_2: u8 = 1;
        // C s_4612_3: cast zx s_4612_2 -> bv
        let s_4612_3: Bits = Bits::new(s_4612_2 as u128, 3u16);
        // D s_4612_4: cmp-eq s_4612_1 s_4612_3
        let s_4612_4: bool = ((s_4612_1) == (s_4612_3));
        // D s_4612_5: write-var gs#118395 <= s_4612_4
        fn_state.gs_118395 = s_4612_4;
        // N s_4612_6: jump b1907
        return block_1907(state, tracer, fn_state);
    }
    fn block_4613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4613_0: read-var opc1:u8
        let s_4613_0: u8 = fn_state.opc1;
        // D s_4613_1: cast zx s_4613_0 -> bv
        let s_4613_1: Bits = Bits::new(s_4613_0 as u128, 3u16);
        // C s_4613_2: const #0u : u8
        let s_4613_2: u8 = 0;
        // C s_4613_3: cast zx s_4613_2 -> bv
        let s_4613_3: Bits = Bits::new(s_4613_2 as u128, 3u16);
        // D s_4613_4: cmp-eq s_4613_1 s_4613_3
        let s_4613_4: bool = ((s_4613_1) == (s_4613_3));
        // D s_4613_5: write-var gs#118394 <= s_4613_4
        fn_state.gs_118394 = s_4613_4;
        // N s_4613_6: jump b1905
        return block_1905(state, tracer, fn_state);
    }
    fn block_4614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4614_0: read-var coproc:u8
        let s_4614_0: u8 = fn_state.coproc;
        // D s_4614_1: cast zx s_4614_0 -> bv
        let s_4614_1: Bits = Bits::new(s_4614_0 as u128, 4u16);
        // C s_4614_2: const #15u : u8
        let s_4614_2: u8 = 15;
        // C s_4614_3: cast zx s_4614_2 -> bv
        let s_4614_3: Bits = Bits::new(s_4614_2 as u128, 4u16);
        // D s_4614_4: cmp-eq s_4614_1 s_4614_3
        let s_4614_4: bool = ((s_4614_1) == (s_4614_3));
        // D s_4614_5: write-var gs#118393 <= s_4614_4
        fn_state.gs_118393 = s_4614_4;
        // N s_4614_6: jump b1903
        return block_1903(state, tracer, fn_state);
    }
    fn block_4615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4615_0: read-var CRn:u8
        let s_4615_0: u8 = fn_state.CRn;
        // D s_4615_1: cast zx s_4615_0 -> bv
        let s_4615_1: Bits = Bits::new(s_4615_0 as u128, 4u16);
        // C s_4615_2: const #0u : u8
        let s_4615_2: u8 = 0;
        // C s_4615_3: cast zx s_4615_2 -> bv
        let s_4615_3: Bits = Bits::new(s_4615_2 as u128, 4u16);
        // D s_4615_4: cmp-eq s_4615_1 s_4615_3
        let s_4615_4: bool = ((s_4615_1) == (s_4615_3));
        // D s_4615_5: write-var gs#118392 <= s_4615_4
        fn_state.gs_118392 = s_4615_4;
        // N s_4615_6: jump b1901
        return block_1901(state, tracer, fn_state);
    }
    fn block_4616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4616_0: read-var el:u8
        let s_4616_0: u8 = fn_state.el;
        // D s_4616_1: read-var coproc:u8
        let s_4616_1: u8 = fn_state.coproc;
        // D s_4616_2: read-var opc1:u8
        let s_4616_2: u8 = fn_state.opc1;
        // D s_4616_3: read-var CRn:u8
        let s_4616_3: u8 = fn_state.CRn;
        // D s_4616_4: read-var opc2:u8
        let s_4616_4: u8 = fn_state.opc2;
        // D s_4616_5: read-var CRm:u8
        let s_4616_5: u8 = fn_state.CRm;
        // D s_4616_6: read-var t:i
        let s_4616_6: i128 = fn_state.t;
        // D s_4616_7: call ICC_PMR_SysRegRead32_aa604b328cea6616(s_4616_0, s_4616_1, s_4616_2, s_4616_3, s_4616_4, s_4616_5, s_4616_6)
        let s_4616_7: () = ICC_PMR_SysRegRead32_aa604b328cea6616(
            state,
            tracer,
            s_4616_0,
            s_4616_1,
            s_4616_2,
            s_4616_3,
            s_4616_4,
            s_4616_5,
            s_4616_6,
        );
        // N s_4616_8: return
        return;
    }
    fn block_4617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4617_0: read-var opc2:u8
        let s_4617_0: u8 = fn_state.opc2;
        // D s_4617_1: cast zx s_4617_0 -> bv
        let s_4617_1: Bits = Bits::new(s_4617_0 as u128, 3u16);
        // C s_4617_2: const #0u : u8
        let s_4617_2: u8 = 0;
        // C s_4617_3: cast zx s_4617_2 -> bv
        let s_4617_3: Bits = Bits::new(s_4617_2 as u128, 3u16);
        // D s_4617_4: cmp-eq s_4617_1 s_4617_3
        let s_4617_4: bool = ((s_4617_1) == (s_4617_3));
        // D s_4617_5: write-var gs#118391 <= s_4617_4
        fn_state.gs_118391 = s_4617_4;
        // N s_4617_6: jump b1898
        return block_1898(state, tracer, fn_state);
    }
    fn block_4618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4618_0: read-var opc1:u8
        let s_4618_0: u8 = fn_state.opc1;
        // D s_4618_1: cast zx s_4618_0 -> bv
        let s_4618_1: Bits = Bits::new(s_4618_0 as u128, 3u16);
        // C s_4618_2: const #0u : u8
        let s_4618_2: u8 = 0;
        // C s_4618_3: cast zx s_4618_2 -> bv
        let s_4618_3: Bits = Bits::new(s_4618_2 as u128, 3u16);
        // D s_4618_4: cmp-eq s_4618_1 s_4618_3
        let s_4618_4: bool = ((s_4618_1) == (s_4618_3));
        // D s_4618_5: write-var gs#118390 <= s_4618_4
        fn_state.gs_118390 = s_4618_4;
        // N s_4618_6: jump b1896
        return block_1896(state, tracer, fn_state);
    }
    fn block_4619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4619_0: read-var coproc:u8
        let s_4619_0: u8 = fn_state.coproc;
        // D s_4619_1: cast zx s_4619_0 -> bv
        let s_4619_1: Bits = Bits::new(s_4619_0 as u128, 4u16);
        // C s_4619_2: const #15u : u8
        let s_4619_2: u8 = 15;
        // C s_4619_3: cast zx s_4619_2 -> bv
        let s_4619_3: Bits = Bits::new(s_4619_2 as u128, 4u16);
        // D s_4619_4: cmp-eq s_4619_1 s_4619_3
        let s_4619_4: bool = ((s_4619_1) == (s_4619_3));
        // D s_4619_5: write-var gs#118389 <= s_4619_4
        fn_state.gs_118389 = s_4619_4;
        // N s_4619_6: jump b1894
        return block_1894(state, tracer, fn_state);
    }
    fn block_4620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4620_0: read-var CRn:u8
        let s_4620_0: u8 = fn_state.CRn;
        // D s_4620_1: cast zx s_4620_0 -> bv
        let s_4620_1: Bits = Bits::new(s_4620_0 as u128, 4u16);
        // C s_4620_2: const #4u : u8
        let s_4620_2: u8 = 4;
        // C s_4620_3: cast zx s_4620_2 -> bv
        let s_4620_3: Bits = Bits::new(s_4620_2 as u128, 4u16);
        // D s_4620_4: cmp-eq s_4620_1 s_4620_3
        let s_4620_4: bool = ((s_4620_1) == (s_4620_3));
        // D s_4620_5: write-var gs#118388 <= s_4620_4
        fn_state.gs_118388 = s_4620_4;
        // N s_4620_6: jump b1892
        return block_1892(state, tracer, fn_state);
    }
    fn block_4621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4621_0: read-var el:u8
        let s_4621_0: u8 = fn_state.el;
        // D s_4621_1: read-var coproc:u8
        let s_4621_1: u8 = fn_state.coproc;
        // D s_4621_2: read-var opc1:u8
        let s_4621_2: u8 = fn_state.opc1;
        // D s_4621_3: read-var CRn:u8
        let s_4621_3: u8 = fn_state.CRn;
        // D s_4621_4: read-var opc2:u8
        let s_4621_4: u8 = fn_state.opc2;
        // D s_4621_5: read-var CRm:u8
        let s_4621_5: u8 = fn_state.CRm;
        // D s_4621_6: read-var t:i
        let s_4621_6: i128 = fn_state.t;
        // D s_4621_7: call AIDR_SysRegRead32_ce556bd47a2bd19b(s_4621_0, s_4621_1, s_4621_2, s_4621_3, s_4621_4, s_4621_5, s_4621_6)
        let s_4621_7: () = AIDR_SysRegRead32_ce556bd47a2bd19b(
            state,
            tracer,
            s_4621_0,
            s_4621_1,
            s_4621_2,
            s_4621_3,
            s_4621_4,
            s_4621_5,
            s_4621_6,
        );
        // N s_4621_8: return
        return;
    }
    fn block_4622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4622_0: read-var opc2:u8
        let s_4622_0: u8 = fn_state.opc2;
        // D s_4622_1: cast zx s_4622_0 -> bv
        let s_4622_1: Bits = Bits::new(s_4622_0 as u128, 3u16);
        // C s_4622_2: const #7u : u8
        let s_4622_2: u8 = 7;
        // C s_4622_3: cast zx s_4622_2 -> bv
        let s_4622_3: Bits = Bits::new(s_4622_2 as u128, 3u16);
        // D s_4622_4: cmp-eq s_4622_1 s_4622_3
        let s_4622_4: bool = ((s_4622_1) == (s_4622_3));
        // D s_4622_5: write-var gs#118387 <= s_4622_4
        fn_state.gs_118387 = s_4622_4;
        // N s_4622_6: jump b1889
        return block_1889(state, tracer, fn_state);
    }
    fn block_4623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4623_0: read-var opc1:u8
        let s_4623_0: u8 = fn_state.opc1;
        // D s_4623_1: cast zx s_4623_0 -> bv
        let s_4623_1: Bits = Bits::new(s_4623_0 as u128, 3u16);
        // C s_4623_2: const #1u : u8
        let s_4623_2: u8 = 1;
        // C s_4623_3: cast zx s_4623_2 -> bv
        let s_4623_3: Bits = Bits::new(s_4623_2 as u128, 3u16);
        // D s_4623_4: cmp-eq s_4623_1 s_4623_3
        let s_4623_4: bool = ((s_4623_1) == (s_4623_3));
        // D s_4623_5: write-var gs#118386 <= s_4623_4
        fn_state.gs_118386 = s_4623_4;
        // N s_4623_6: jump b1887
        return block_1887(state, tracer, fn_state);
    }
    fn block_4624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4624_0: read-var coproc:u8
        let s_4624_0: u8 = fn_state.coproc;
        // D s_4624_1: cast zx s_4624_0 -> bv
        let s_4624_1: Bits = Bits::new(s_4624_0 as u128, 4u16);
        // C s_4624_2: const #15u : u8
        let s_4624_2: u8 = 15;
        // C s_4624_3: cast zx s_4624_2 -> bv
        let s_4624_3: Bits = Bits::new(s_4624_2 as u128, 4u16);
        // D s_4624_4: cmp-eq s_4624_1 s_4624_3
        let s_4624_4: bool = ((s_4624_1) == (s_4624_3));
        // D s_4624_5: write-var gs#118385 <= s_4624_4
        fn_state.gs_118385 = s_4624_4;
        // N s_4624_6: jump b1885
        return block_1885(state, tracer, fn_state);
    }
    fn block_4625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4625_0: read-var CRn:u8
        let s_4625_0: u8 = fn_state.CRn;
        // D s_4625_1: cast zx s_4625_0 -> bv
        let s_4625_1: Bits = Bits::new(s_4625_0 as u128, 4u16);
        // C s_4625_2: const #0u : u8
        let s_4625_2: u8 = 0;
        // C s_4625_3: cast zx s_4625_2 -> bv
        let s_4625_3: Bits = Bits::new(s_4625_2 as u128, 4u16);
        // D s_4625_4: cmp-eq s_4625_1 s_4625_3
        let s_4625_4: bool = ((s_4625_1) == (s_4625_3));
        // D s_4625_5: write-var gs#118384 <= s_4625_4
        fn_state.gs_118384 = s_4625_4;
        // N s_4625_6: jump b1883
        return block_1883(state, tracer, fn_state);
    }
    fn block_4626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4626_0: read-var el:u8
        let s_4626_0: u8 = fn_state.el;
        // D s_4626_1: read-var coproc:u8
        let s_4626_1: u8 = fn_state.coproc;
        // D s_4626_2: read-var opc1:u8
        let s_4626_2: u8 = fn_state.opc1;
        // D s_4626_3: read-var CRn:u8
        let s_4626_3: u8 = fn_state.CRn;
        // D s_4626_4: read-var opc2:u8
        let s_4626_4: u8 = fn_state.opc2;
        // D s_4626_5: read-var CRm:u8
        let s_4626_5: u8 = fn_state.CRm;
        // D s_4626_6: read-var t:i
        let s_4626_6: i128 = fn_state.t;
        // D s_4626_7: call HTCR_SysRegRead32_ad0d0f0fabd96a9f(s_4626_0, s_4626_1, s_4626_2, s_4626_3, s_4626_4, s_4626_5, s_4626_6)
        let s_4626_7: () = HTCR_SysRegRead32_ad0d0f0fabd96a9f(
            state,
            tracer,
            s_4626_0,
            s_4626_1,
            s_4626_2,
            s_4626_3,
            s_4626_4,
            s_4626_5,
            s_4626_6,
        );
        // N s_4626_8: return
        return;
    }
    fn block_4627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4627_0: read-var opc2:u8
        let s_4627_0: u8 = fn_state.opc2;
        // D s_4627_1: cast zx s_4627_0 -> bv
        let s_4627_1: Bits = Bits::new(s_4627_0 as u128, 3u16);
        // C s_4627_2: const #2u : u8
        let s_4627_2: u8 = 2;
        // C s_4627_3: cast zx s_4627_2 -> bv
        let s_4627_3: Bits = Bits::new(s_4627_2 as u128, 3u16);
        // D s_4627_4: cmp-eq s_4627_1 s_4627_3
        let s_4627_4: bool = ((s_4627_1) == (s_4627_3));
        // D s_4627_5: write-var gs#118383 <= s_4627_4
        fn_state.gs_118383 = s_4627_4;
        // N s_4627_6: jump b1880
        return block_1880(state, tracer, fn_state);
    }
    fn block_4628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4628_0: read-var opc1:u8
        let s_4628_0: u8 = fn_state.opc1;
        // D s_4628_1: cast zx s_4628_0 -> bv
        let s_4628_1: Bits = Bits::new(s_4628_0 as u128, 3u16);
        // C s_4628_2: const #4u : u8
        let s_4628_2: u8 = 4;
        // C s_4628_3: cast zx s_4628_2 -> bv
        let s_4628_3: Bits = Bits::new(s_4628_2 as u128, 3u16);
        // D s_4628_4: cmp-eq s_4628_1 s_4628_3
        let s_4628_4: bool = ((s_4628_1) == (s_4628_3));
        // D s_4628_5: write-var gs#118382 <= s_4628_4
        fn_state.gs_118382 = s_4628_4;
        // N s_4628_6: jump b1878
        return block_1878(state, tracer, fn_state);
    }
    fn block_4629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4629_0: read-var coproc:u8
        let s_4629_0: u8 = fn_state.coproc;
        // D s_4629_1: cast zx s_4629_0 -> bv
        let s_4629_1: Bits = Bits::new(s_4629_0 as u128, 4u16);
        // C s_4629_2: const #15u : u8
        let s_4629_2: u8 = 15;
        // C s_4629_3: cast zx s_4629_2 -> bv
        let s_4629_3: Bits = Bits::new(s_4629_2 as u128, 4u16);
        // D s_4629_4: cmp-eq s_4629_1 s_4629_3
        let s_4629_4: bool = ((s_4629_1) == (s_4629_3));
        // D s_4629_5: write-var gs#118381 <= s_4629_4
        fn_state.gs_118381 = s_4629_4;
        // N s_4629_6: jump b1876
        return block_1876(state, tracer, fn_state);
    }
    fn block_4630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4630_0: read-var CRn:u8
        let s_4630_0: u8 = fn_state.CRn;
        // D s_4630_1: cast zx s_4630_0 -> bv
        let s_4630_1: Bits = Bits::new(s_4630_0 as u128, 4u16);
        // C s_4630_2: const #2u : u8
        let s_4630_2: u8 = 2;
        // C s_4630_3: cast zx s_4630_2 -> bv
        let s_4630_3: Bits = Bits::new(s_4630_2 as u128, 4u16);
        // D s_4630_4: cmp-eq s_4630_1 s_4630_3
        let s_4630_4: bool = ((s_4630_1) == (s_4630_3));
        // D s_4630_5: write-var gs#118380 <= s_4630_4
        fn_state.gs_118380 = s_4630_4;
        // N s_4630_6: jump b1874
        return block_1874(state, tracer, fn_state);
    }
    fn block_4631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4631_0: read-var el:u8
        let s_4631_0: u8 = fn_state.el;
        // D s_4631_1: read-var coproc:u8
        let s_4631_1: u8 = fn_state.coproc;
        // D s_4631_2: read-var opc1:u8
        let s_4631_2: u8 = fn_state.opc1;
        // D s_4631_3: read-var CRn:u8
        let s_4631_3: u8 = fn_state.CRn;
        // D s_4631_4: read-var opc2:u8
        let s_4631_4: u8 = fn_state.opc2;
        // D s_4631_5: read-var CRm:u8
        let s_4631_5: u8 = fn_state.CRm;
        // D s_4631_6: read-var t:i
        let s_4631_6: i128 = fn_state.t;
        // D s_4631_7: call ID_ISAR5_SysRegRead32_32e7eeb4ddf57791(s_4631_0, s_4631_1, s_4631_2, s_4631_3, s_4631_4, s_4631_5, s_4631_6)
        let s_4631_7: () = ID_ISAR5_SysRegRead32_32e7eeb4ddf57791(
            state,
            tracer,
            s_4631_0,
            s_4631_1,
            s_4631_2,
            s_4631_3,
            s_4631_4,
            s_4631_5,
            s_4631_6,
        );
        // N s_4631_8: return
        return;
    }
    fn block_4632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4632_0: read-var opc2:u8
        let s_4632_0: u8 = fn_state.opc2;
        // D s_4632_1: cast zx s_4632_0 -> bv
        let s_4632_1: Bits = Bits::new(s_4632_0 as u128, 3u16);
        // C s_4632_2: const #5u : u8
        let s_4632_2: u8 = 5;
        // C s_4632_3: cast zx s_4632_2 -> bv
        let s_4632_3: Bits = Bits::new(s_4632_2 as u128, 3u16);
        // D s_4632_4: cmp-eq s_4632_1 s_4632_3
        let s_4632_4: bool = ((s_4632_1) == (s_4632_3));
        // D s_4632_5: write-var gs#118379 <= s_4632_4
        fn_state.gs_118379 = s_4632_4;
        // N s_4632_6: jump b1871
        return block_1871(state, tracer, fn_state);
    }
    fn block_4633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4633_0: read-var opc1:u8
        let s_4633_0: u8 = fn_state.opc1;
        // D s_4633_1: cast zx s_4633_0 -> bv
        let s_4633_1: Bits = Bits::new(s_4633_0 as u128, 3u16);
        // C s_4633_2: const #0u : u8
        let s_4633_2: u8 = 0;
        // C s_4633_3: cast zx s_4633_2 -> bv
        let s_4633_3: Bits = Bits::new(s_4633_2 as u128, 3u16);
        // D s_4633_4: cmp-eq s_4633_1 s_4633_3
        let s_4633_4: bool = ((s_4633_1) == (s_4633_3));
        // D s_4633_5: write-var gs#118378 <= s_4633_4
        fn_state.gs_118378 = s_4633_4;
        // N s_4633_6: jump b1869
        return block_1869(state, tracer, fn_state);
    }
    fn block_4634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4634_0: read-var coproc:u8
        let s_4634_0: u8 = fn_state.coproc;
        // D s_4634_1: cast zx s_4634_0 -> bv
        let s_4634_1: Bits = Bits::new(s_4634_0 as u128, 4u16);
        // C s_4634_2: const #15u : u8
        let s_4634_2: u8 = 15;
        // C s_4634_3: cast zx s_4634_2 -> bv
        let s_4634_3: Bits = Bits::new(s_4634_2 as u128, 4u16);
        // D s_4634_4: cmp-eq s_4634_1 s_4634_3
        let s_4634_4: bool = ((s_4634_1) == (s_4634_3));
        // D s_4634_5: write-var gs#118377 <= s_4634_4
        fn_state.gs_118377 = s_4634_4;
        // N s_4634_6: jump b1867
        return block_1867(state, tracer, fn_state);
    }
    fn block_4635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4635_0: read-var CRn:u8
        let s_4635_0: u8 = fn_state.CRn;
        // D s_4635_1: cast zx s_4635_0 -> bv
        let s_4635_1: Bits = Bits::new(s_4635_0 as u128, 4u16);
        // C s_4635_2: const #0u : u8
        let s_4635_2: u8 = 0;
        // C s_4635_3: cast zx s_4635_2 -> bv
        let s_4635_3: Bits = Bits::new(s_4635_2 as u128, 4u16);
        // D s_4635_4: cmp-eq s_4635_1 s_4635_3
        let s_4635_4: bool = ((s_4635_1) == (s_4635_3));
        // D s_4635_5: write-var gs#118376 <= s_4635_4
        fn_state.gs_118376 = s_4635_4;
        // N s_4635_6: jump b1865
        return block_1865(state, tracer, fn_state);
    }
    fn block_4636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4636_0: read-var el:u8
        let s_4636_0: u8 = fn_state.el;
        // D s_4636_1: read-var coproc:u8
        let s_4636_1: u8 = fn_state.coproc;
        // D s_4636_2: read-var opc1:u8
        let s_4636_2: u8 = fn_state.opc1;
        // D s_4636_3: read-var CRn:u8
        let s_4636_3: u8 = fn_state.CRn;
        // D s_4636_4: read-var opc2:u8
        let s_4636_4: u8 = fn_state.opc2;
        // D s_4636_5: read-var CRm:u8
        let s_4636_5: u8 = fn_state.CRm;
        // D s_4636_6: read-var t:i
        let s_4636_6: i128 = fn_state.t;
        // D s_4636_7: call ICH_AP0R_SysRegRead32_8a9ae74c0d05c4d8(s_4636_0, s_4636_1, s_4636_2, s_4636_3, s_4636_4, s_4636_5, s_4636_6)
        let s_4636_7: () = ICH_AP0R_SysRegRead32_8a9ae74c0d05c4d8(
            state,
            tracer,
            s_4636_0,
            s_4636_1,
            s_4636_2,
            s_4636_3,
            s_4636_4,
            s_4636_5,
            s_4636_6,
        );
        // N s_4636_8: return
        return;
    }
    fn block_4637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4637_0: read-var opc2:u8
        let s_4637_0: u8 = fn_state.opc2;
        // D s_4637_1: cast zx s_4637_0 -> bv
        let s_4637_1: Bits = Bits::new(s_4637_0 as u128, 3u16);
        // C s_4637_2: const #0u : u8
        let s_4637_2: u8 = 0;
        // C s_4637_3: cast zx s_4637_2 -> bv
        let s_4637_3: Bits = Bits::new(s_4637_2 as u128, 3u16);
        // D s_4637_4: cmp-eq s_4637_1 s_4637_3
        let s_4637_4: bool = ((s_4637_1) == (s_4637_3));
        // D s_4637_5: write-var gs#118375 <= s_4637_4
        fn_state.gs_118375 = s_4637_4;
        // N s_4637_6: jump b1862
        return block_1862(state, tracer, fn_state);
    }
    fn block_4638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4638_0: read-var opc1:u8
        let s_4638_0: u8 = fn_state.opc1;
        // D s_4638_1: cast zx s_4638_0 -> bv
        let s_4638_1: Bits = Bits::new(s_4638_0 as u128, 3u16);
        // C s_4638_2: const #4u : u8
        let s_4638_2: u8 = 4;
        // C s_4638_3: cast zx s_4638_2 -> bv
        let s_4638_3: Bits = Bits::new(s_4638_2 as u128, 3u16);
        // D s_4638_4: cmp-eq s_4638_1 s_4638_3
        let s_4638_4: bool = ((s_4638_1) == (s_4638_3));
        // D s_4638_5: write-var gs#118374 <= s_4638_4
        fn_state.gs_118374 = s_4638_4;
        // N s_4638_6: jump b1860
        return block_1860(state, tracer, fn_state);
    }
    fn block_4639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4639_0: read-var coproc:u8
        let s_4639_0: u8 = fn_state.coproc;
        // D s_4639_1: cast zx s_4639_0 -> bv
        let s_4639_1: Bits = Bits::new(s_4639_0 as u128, 4u16);
        // C s_4639_2: const #15u : u8
        let s_4639_2: u8 = 15;
        // C s_4639_3: cast zx s_4639_2 -> bv
        let s_4639_3: Bits = Bits::new(s_4639_2 as u128, 4u16);
        // D s_4639_4: cmp-eq s_4639_1 s_4639_3
        let s_4639_4: bool = ((s_4639_1) == (s_4639_3));
        // D s_4639_5: write-var gs#118373 <= s_4639_4
        fn_state.gs_118373 = s_4639_4;
        // N s_4639_6: jump b1858
        return block_1858(state, tracer, fn_state);
    }
    fn block_4640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4640_0: read-var CRn:u8
        let s_4640_0: u8 = fn_state.CRn;
        // D s_4640_1: cast zx s_4640_0 -> bv
        let s_4640_1: Bits = Bits::new(s_4640_0 as u128, 4u16);
        // C s_4640_2: const #12u : u8
        let s_4640_2: u8 = 12;
        // C s_4640_3: cast zx s_4640_2 -> bv
        let s_4640_3: Bits = Bits::new(s_4640_2 as u128, 4u16);
        // D s_4640_4: cmp-eq s_4640_1 s_4640_3
        let s_4640_4: bool = ((s_4640_1) == (s_4640_3));
        // D s_4640_5: write-var gs#118372 <= s_4640_4
        fn_state.gs_118372 = s_4640_4;
        // N s_4640_6: jump b1856
        return block_1856(state, tracer, fn_state);
    }
    fn block_4641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4641_0: read-var el:u8
        let s_4641_0: u8 = fn_state.el;
        // D s_4641_1: read-var coproc:u8
        let s_4641_1: u8 = fn_state.coproc;
        // D s_4641_2: read-var opc1:u8
        let s_4641_2: u8 = fn_state.opc1;
        // D s_4641_3: read-var CRn:u8
        let s_4641_3: u8 = fn_state.CRn;
        // D s_4641_4: read-var opc2:u8
        let s_4641_4: u8 = fn_state.opc2;
        // D s_4641_5: read-var CRm:u8
        let s_4641_5: u8 = fn_state.CRm;
        // D s_4641_6: read-var t:i
        let s_4641_6: i128 = fn_state.t;
        // D s_4641_7: call ICH_AP0R_SysRegRead32_fa5d134ae7836c23(s_4641_0, s_4641_1, s_4641_2, s_4641_3, s_4641_4, s_4641_5, s_4641_6)
        let s_4641_7: () = ICH_AP0R_SysRegRead32_fa5d134ae7836c23(
            state,
            tracer,
            s_4641_0,
            s_4641_1,
            s_4641_2,
            s_4641_3,
            s_4641_4,
            s_4641_5,
            s_4641_6,
        );
        // N s_4641_8: return
        return;
    }
    fn block_4642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4642_0: read-var opc2:u8
        let s_4642_0: u8 = fn_state.opc2;
        // D s_4642_1: cast zx s_4642_0 -> bv
        let s_4642_1: Bits = Bits::new(s_4642_0 as u128, 3u16);
        // C s_4642_2: const #1u : u8
        let s_4642_2: u8 = 1;
        // C s_4642_3: cast zx s_4642_2 -> bv
        let s_4642_3: Bits = Bits::new(s_4642_2 as u128, 3u16);
        // D s_4642_4: cmp-eq s_4642_1 s_4642_3
        let s_4642_4: bool = ((s_4642_1) == (s_4642_3));
        // D s_4642_5: write-var gs#118371 <= s_4642_4
        fn_state.gs_118371 = s_4642_4;
        // N s_4642_6: jump b1853
        return block_1853(state, tracer, fn_state);
    }
    fn block_4643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4643_0: read-var opc1:u8
        let s_4643_0: u8 = fn_state.opc1;
        // D s_4643_1: cast zx s_4643_0 -> bv
        let s_4643_1: Bits = Bits::new(s_4643_0 as u128, 3u16);
        // C s_4643_2: const #4u : u8
        let s_4643_2: u8 = 4;
        // C s_4643_3: cast zx s_4643_2 -> bv
        let s_4643_3: Bits = Bits::new(s_4643_2 as u128, 3u16);
        // D s_4643_4: cmp-eq s_4643_1 s_4643_3
        let s_4643_4: bool = ((s_4643_1) == (s_4643_3));
        // D s_4643_5: write-var gs#118370 <= s_4643_4
        fn_state.gs_118370 = s_4643_4;
        // N s_4643_6: jump b1851
        return block_1851(state, tracer, fn_state);
    }
    fn block_4644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4644_0: read-var coproc:u8
        let s_4644_0: u8 = fn_state.coproc;
        // D s_4644_1: cast zx s_4644_0 -> bv
        let s_4644_1: Bits = Bits::new(s_4644_0 as u128, 4u16);
        // C s_4644_2: const #15u : u8
        let s_4644_2: u8 = 15;
        // C s_4644_3: cast zx s_4644_2 -> bv
        let s_4644_3: Bits = Bits::new(s_4644_2 as u128, 4u16);
        // D s_4644_4: cmp-eq s_4644_1 s_4644_3
        let s_4644_4: bool = ((s_4644_1) == (s_4644_3));
        // D s_4644_5: write-var gs#118369 <= s_4644_4
        fn_state.gs_118369 = s_4644_4;
        // N s_4644_6: jump b1849
        return block_1849(state, tracer, fn_state);
    }
    fn block_4645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4645_0: read-var CRn:u8
        let s_4645_0: u8 = fn_state.CRn;
        // D s_4645_1: cast zx s_4645_0 -> bv
        let s_4645_1: Bits = Bits::new(s_4645_0 as u128, 4u16);
        // C s_4645_2: const #12u : u8
        let s_4645_2: u8 = 12;
        // C s_4645_3: cast zx s_4645_2 -> bv
        let s_4645_3: Bits = Bits::new(s_4645_2 as u128, 4u16);
        // D s_4645_4: cmp-eq s_4645_1 s_4645_3
        let s_4645_4: bool = ((s_4645_1) == (s_4645_3));
        // D s_4645_5: write-var gs#118368 <= s_4645_4
        fn_state.gs_118368 = s_4645_4;
        // N s_4645_6: jump b1847
        return block_1847(state, tracer, fn_state);
    }
    fn block_4646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4646_0: read-var el:u8
        let s_4646_0: u8 = fn_state.el;
        // D s_4646_1: read-var coproc:u8
        let s_4646_1: u8 = fn_state.coproc;
        // D s_4646_2: read-var opc1:u8
        let s_4646_2: u8 = fn_state.opc1;
        // D s_4646_3: read-var CRn:u8
        let s_4646_3: u8 = fn_state.CRn;
        // D s_4646_4: read-var opc2:u8
        let s_4646_4: u8 = fn_state.opc2;
        // D s_4646_5: read-var CRm:u8
        let s_4646_5: u8 = fn_state.CRm;
        // D s_4646_6: read-var t:i
        let s_4646_6: i128 = fn_state.t;
        // D s_4646_7: call ICH_AP0R_SysRegRead32_f7de8d51fc141ec6(s_4646_0, s_4646_1, s_4646_2, s_4646_3, s_4646_4, s_4646_5, s_4646_6)
        let s_4646_7: () = ICH_AP0R_SysRegRead32_f7de8d51fc141ec6(
            state,
            tracer,
            s_4646_0,
            s_4646_1,
            s_4646_2,
            s_4646_3,
            s_4646_4,
            s_4646_5,
            s_4646_6,
        );
        // N s_4646_8: return
        return;
    }
    fn block_4647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4647_0: read-var opc2:u8
        let s_4647_0: u8 = fn_state.opc2;
        // D s_4647_1: cast zx s_4647_0 -> bv
        let s_4647_1: Bits = Bits::new(s_4647_0 as u128, 3u16);
        // C s_4647_2: const #2u : u8
        let s_4647_2: u8 = 2;
        // C s_4647_3: cast zx s_4647_2 -> bv
        let s_4647_3: Bits = Bits::new(s_4647_2 as u128, 3u16);
        // D s_4647_4: cmp-eq s_4647_1 s_4647_3
        let s_4647_4: bool = ((s_4647_1) == (s_4647_3));
        // D s_4647_5: write-var gs#118367 <= s_4647_4
        fn_state.gs_118367 = s_4647_4;
        // N s_4647_6: jump b1844
        return block_1844(state, tracer, fn_state);
    }
    fn block_4648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4648_0: read-var opc1:u8
        let s_4648_0: u8 = fn_state.opc1;
        // D s_4648_1: cast zx s_4648_0 -> bv
        let s_4648_1: Bits = Bits::new(s_4648_0 as u128, 3u16);
        // C s_4648_2: const #4u : u8
        let s_4648_2: u8 = 4;
        // C s_4648_3: cast zx s_4648_2 -> bv
        let s_4648_3: Bits = Bits::new(s_4648_2 as u128, 3u16);
        // D s_4648_4: cmp-eq s_4648_1 s_4648_3
        let s_4648_4: bool = ((s_4648_1) == (s_4648_3));
        // D s_4648_5: write-var gs#118366 <= s_4648_4
        fn_state.gs_118366 = s_4648_4;
        // N s_4648_6: jump b1842
        return block_1842(state, tracer, fn_state);
    }
    fn block_4649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4649_0: read-var coproc:u8
        let s_4649_0: u8 = fn_state.coproc;
        // D s_4649_1: cast zx s_4649_0 -> bv
        let s_4649_1: Bits = Bits::new(s_4649_0 as u128, 4u16);
        // C s_4649_2: const #15u : u8
        let s_4649_2: u8 = 15;
        // C s_4649_3: cast zx s_4649_2 -> bv
        let s_4649_3: Bits = Bits::new(s_4649_2 as u128, 4u16);
        // D s_4649_4: cmp-eq s_4649_1 s_4649_3
        let s_4649_4: bool = ((s_4649_1) == (s_4649_3));
        // D s_4649_5: write-var gs#118365 <= s_4649_4
        fn_state.gs_118365 = s_4649_4;
        // N s_4649_6: jump b1840
        return block_1840(state, tracer, fn_state);
    }
    fn block_4650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4650_0: read-var CRn:u8
        let s_4650_0: u8 = fn_state.CRn;
        // D s_4650_1: cast zx s_4650_0 -> bv
        let s_4650_1: Bits = Bits::new(s_4650_0 as u128, 4u16);
        // C s_4650_2: const #12u : u8
        let s_4650_2: u8 = 12;
        // C s_4650_3: cast zx s_4650_2 -> bv
        let s_4650_3: Bits = Bits::new(s_4650_2 as u128, 4u16);
        // D s_4650_4: cmp-eq s_4650_1 s_4650_3
        let s_4650_4: bool = ((s_4650_1) == (s_4650_3));
        // D s_4650_5: write-var gs#118364 <= s_4650_4
        fn_state.gs_118364 = s_4650_4;
        // N s_4650_6: jump b1838
        return block_1838(state, tracer, fn_state);
    }
    fn block_4651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4651_0: read-var el:u8
        let s_4651_0: u8 = fn_state.el;
        // D s_4651_1: read-var coproc:u8
        let s_4651_1: u8 = fn_state.coproc;
        // D s_4651_2: read-var opc1:u8
        let s_4651_2: u8 = fn_state.opc1;
        // D s_4651_3: read-var CRn:u8
        let s_4651_3: u8 = fn_state.CRn;
        // D s_4651_4: read-var opc2:u8
        let s_4651_4: u8 = fn_state.opc2;
        // D s_4651_5: read-var CRm:u8
        let s_4651_5: u8 = fn_state.CRm;
        // D s_4651_6: read-var t:i
        let s_4651_6: i128 = fn_state.t;
        // D s_4651_7: call ICH_AP0R_SysRegRead32_941887291ce9d9ce(s_4651_0, s_4651_1, s_4651_2, s_4651_3, s_4651_4, s_4651_5, s_4651_6)
        let s_4651_7: () = ICH_AP0R_SysRegRead32_941887291ce9d9ce(
            state,
            tracer,
            s_4651_0,
            s_4651_1,
            s_4651_2,
            s_4651_3,
            s_4651_4,
            s_4651_5,
            s_4651_6,
        );
        // N s_4651_8: return
        return;
    }
    fn block_4652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4652_0: read-var opc2:u8
        let s_4652_0: u8 = fn_state.opc2;
        // D s_4652_1: cast zx s_4652_0 -> bv
        let s_4652_1: Bits = Bits::new(s_4652_0 as u128, 3u16);
        // C s_4652_2: const #3u : u8
        let s_4652_2: u8 = 3;
        // C s_4652_3: cast zx s_4652_2 -> bv
        let s_4652_3: Bits = Bits::new(s_4652_2 as u128, 3u16);
        // D s_4652_4: cmp-eq s_4652_1 s_4652_3
        let s_4652_4: bool = ((s_4652_1) == (s_4652_3));
        // D s_4652_5: write-var gs#118363 <= s_4652_4
        fn_state.gs_118363 = s_4652_4;
        // N s_4652_6: jump b1835
        return block_1835(state, tracer, fn_state);
    }
    fn block_4653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4653_0: read-var opc1:u8
        let s_4653_0: u8 = fn_state.opc1;
        // D s_4653_1: cast zx s_4653_0 -> bv
        let s_4653_1: Bits = Bits::new(s_4653_0 as u128, 3u16);
        // C s_4653_2: const #4u : u8
        let s_4653_2: u8 = 4;
        // C s_4653_3: cast zx s_4653_2 -> bv
        let s_4653_3: Bits = Bits::new(s_4653_2 as u128, 3u16);
        // D s_4653_4: cmp-eq s_4653_1 s_4653_3
        let s_4653_4: bool = ((s_4653_1) == (s_4653_3));
        // D s_4653_5: write-var gs#118362 <= s_4653_4
        fn_state.gs_118362 = s_4653_4;
        // N s_4653_6: jump b1833
        return block_1833(state, tracer, fn_state);
    }
    fn block_4654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4654_0: read-var coproc:u8
        let s_4654_0: u8 = fn_state.coproc;
        // D s_4654_1: cast zx s_4654_0 -> bv
        let s_4654_1: Bits = Bits::new(s_4654_0 as u128, 4u16);
        // C s_4654_2: const #15u : u8
        let s_4654_2: u8 = 15;
        // C s_4654_3: cast zx s_4654_2 -> bv
        let s_4654_3: Bits = Bits::new(s_4654_2 as u128, 4u16);
        // D s_4654_4: cmp-eq s_4654_1 s_4654_3
        let s_4654_4: bool = ((s_4654_1) == (s_4654_3));
        // D s_4654_5: write-var gs#118361 <= s_4654_4
        fn_state.gs_118361 = s_4654_4;
        // N s_4654_6: jump b1831
        return block_1831(state, tracer, fn_state);
    }
    fn block_4655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4655_0: read-var CRn:u8
        let s_4655_0: u8 = fn_state.CRn;
        // D s_4655_1: cast zx s_4655_0 -> bv
        let s_4655_1: Bits = Bits::new(s_4655_0 as u128, 4u16);
        // C s_4655_2: const #12u : u8
        let s_4655_2: u8 = 12;
        // C s_4655_3: cast zx s_4655_2 -> bv
        let s_4655_3: Bits = Bits::new(s_4655_2 as u128, 4u16);
        // D s_4655_4: cmp-eq s_4655_1 s_4655_3
        let s_4655_4: bool = ((s_4655_1) == (s_4655_3));
        // D s_4655_5: write-var gs#118360 <= s_4655_4
        fn_state.gs_118360 = s_4655_4;
        // N s_4655_6: jump b1829
        return block_1829(state, tracer, fn_state);
    }
    fn block_4656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4656_0: read-var el:u8
        let s_4656_0: u8 = fn_state.el;
        // D s_4656_1: read-var coproc:u8
        let s_4656_1: u8 = fn_state.coproc;
        // D s_4656_2: read-var opc1:u8
        let s_4656_2: u8 = fn_state.opc1;
        // D s_4656_3: read-var CRn:u8
        let s_4656_3: u8 = fn_state.CRn;
        // D s_4656_4: read-var opc2:u8
        let s_4656_4: u8 = fn_state.opc2;
        // D s_4656_5: read-var CRm:u8
        let s_4656_5: u8 = fn_state.CRm;
        // D s_4656_6: read-var t:i
        let s_4656_6: i128 = fn_state.t;
        // D s_4656_7: call PMCCFILTR_SysRegRead32_1da10de344b09eac(s_4656_0, s_4656_1, s_4656_2, s_4656_3, s_4656_4, s_4656_5, s_4656_6)
        let s_4656_7: () = PMCCFILTR_SysRegRead32_1da10de344b09eac(
            state,
            tracer,
            s_4656_0,
            s_4656_1,
            s_4656_2,
            s_4656_3,
            s_4656_4,
            s_4656_5,
            s_4656_6,
        );
        // N s_4656_8: return
        return;
    }
    fn block_4657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4657_0: read-var opc2:u8
        let s_4657_0: u8 = fn_state.opc2;
        // D s_4657_1: cast zx s_4657_0 -> bv
        let s_4657_1: Bits = Bits::new(s_4657_0 as u128, 3u16);
        // C s_4657_2: const #7u : u8
        let s_4657_2: u8 = 7;
        // C s_4657_3: cast zx s_4657_2 -> bv
        let s_4657_3: Bits = Bits::new(s_4657_2 as u128, 3u16);
        // D s_4657_4: cmp-eq s_4657_1 s_4657_3
        let s_4657_4: bool = ((s_4657_1) == (s_4657_3));
        // D s_4657_5: write-var gs#118359 <= s_4657_4
        fn_state.gs_118359 = s_4657_4;
        // N s_4657_6: jump b1826
        return block_1826(state, tracer, fn_state);
    }
    fn block_4658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4658_0: read-var opc1:u8
        let s_4658_0: u8 = fn_state.opc1;
        // D s_4658_1: cast zx s_4658_0 -> bv
        let s_4658_1: Bits = Bits::new(s_4658_0 as u128, 3u16);
        // C s_4658_2: const #0u : u8
        let s_4658_2: u8 = 0;
        // C s_4658_3: cast zx s_4658_2 -> bv
        let s_4658_3: Bits = Bits::new(s_4658_2 as u128, 3u16);
        // D s_4658_4: cmp-eq s_4658_1 s_4658_3
        let s_4658_4: bool = ((s_4658_1) == (s_4658_3));
        // D s_4658_5: write-var gs#118358 <= s_4658_4
        fn_state.gs_118358 = s_4658_4;
        // N s_4658_6: jump b1824
        return block_1824(state, tracer, fn_state);
    }
    fn block_4659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4659_0: read-var coproc:u8
        let s_4659_0: u8 = fn_state.coproc;
        // D s_4659_1: cast zx s_4659_0 -> bv
        let s_4659_1: Bits = Bits::new(s_4659_0 as u128, 4u16);
        // C s_4659_2: const #15u : u8
        let s_4659_2: u8 = 15;
        // C s_4659_3: cast zx s_4659_2 -> bv
        let s_4659_3: Bits = Bits::new(s_4659_2 as u128, 4u16);
        // D s_4659_4: cmp-eq s_4659_1 s_4659_3
        let s_4659_4: bool = ((s_4659_1) == (s_4659_3));
        // D s_4659_5: write-var gs#118357 <= s_4659_4
        fn_state.gs_118357 = s_4659_4;
        // N s_4659_6: jump b1822
        return block_1822(state, tracer, fn_state);
    }
    fn block_4660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4660_0: read-var CRn:u8
        let s_4660_0: u8 = fn_state.CRn;
        // D s_4660_1: cast zx s_4660_0 -> bv
        let s_4660_1: Bits = Bits::new(s_4660_0 as u128, 4u16);
        // C s_4660_2: const #14u : u8
        let s_4660_2: u8 = 14;
        // C s_4660_3: cast zx s_4660_2 -> bv
        let s_4660_3: Bits = Bits::new(s_4660_2 as u128, 4u16);
        // D s_4660_4: cmp-eq s_4660_1 s_4660_3
        let s_4660_4: bool = ((s_4660_1) == (s_4660_3));
        // D s_4660_5: write-var gs#118356 <= s_4660_4
        fn_state.gs_118356 = s_4660_4;
        // N s_4660_6: jump b1820
        return block_1820(state, tracer, fn_state);
    }
    fn block_4661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4661_0: read-var el:u8
        let s_4661_0: u8 = fn_state.el;
        // D s_4661_1: read-var coproc:u8
        let s_4661_1: u8 = fn_state.coproc;
        // D s_4661_2: read-var opc1:u8
        let s_4661_2: u8 = fn_state.opc1;
        // D s_4661_3: read-var CRn:u8
        let s_4661_3: u8 = fn_state.CRn;
        // D s_4661_4: read-var opc2:u8
        let s_4661_4: u8 = fn_state.opc2;
        // D s_4661_5: read-var CRm:u8
        let s_4661_5: u8 = fn_state.CRm;
        // D s_4661_6: read-var t:i
        let s_4661_6: i128 = fn_state.t;
        // D s_4661_7: call ICC_HSRE_SysRegRead32_0e6b0f816b017dd6(s_4661_0, s_4661_1, s_4661_2, s_4661_3, s_4661_4, s_4661_5, s_4661_6)
        let s_4661_7: () = ICC_HSRE_SysRegRead32_0e6b0f816b017dd6(
            state,
            tracer,
            s_4661_0,
            s_4661_1,
            s_4661_2,
            s_4661_3,
            s_4661_4,
            s_4661_5,
            s_4661_6,
        );
        // N s_4661_8: return
        return;
    }
    fn block_4662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4662_0: read-var opc2:u8
        let s_4662_0: u8 = fn_state.opc2;
        // D s_4662_1: cast zx s_4662_0 -> bv
        let s_4662_1: Bits = Bits::new(s_4662_0 as u128, 3u16);
        // C s_4662_2: const #5u : u8
        let s_4662_2: u8 = 5;
        // C s_4662_3: cast zx s_4662_2 -> bv
        let s_4662_3: Bits = Bits::new(s_4662_2 as u128, 3u16);
        // D s_4662_4: cmp-eq s_4662_1 s_4662_3
        let s_4662_4: bool = ((s_4662_1) == (s_4662_3));
        // D s_4662_5: write-var gs#118355 <= s_4662_4
        fn_state.gs_118355 = s_4662_4;
        // N s_4662_6: jump b1817
        return block_1817(state, tracer, fn_state);
    }
    fn block_4663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4663_0: read-var opc1:u8
        let s_4663_0: u8 = fn_state.opc1;
        // D s_4663_1: cast zx s_4663_0 -> bv
        let s_4663_1: Bits = Bits::new(s_4663_0 as u128, 3u16);
        // C s_4663_2: const #4u : u8
        let s_4663_2: u8 = 4;
        // C s_4663_3: cast zx s_4663_2 -> bv
        let s_4663_3: Bits = Bits::new(s_4663_2 as u128, 3u16);
        // D s_4663_4: cmp-eq s_4663_1 s_4663_3
        let s_4663_4: bool = ((s_4663_1) == (s_4663_3));
        // D s_4663_5: write-var gs#118354 <= s_4663_4
        fn_state.gs_118354 = s_4663_4;
        // N s_4663_6: jump b1815
        return block_1815(state, tracer, fn_state);
    }
    fn block_4664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4664_0: read-var coproc:u8
        let s_4664_0: u8 = fn_state.coproc;
        // D s_4664_1: cast zx s_4664_0 -> bv
        let s_4664_1: Bits = Bits::new(s_4664_0 as u128, 4u16);
        // C s_4664_2: const #15u : u8
        let s_4664_2: u8 = 15;
        // C s_4664_3: cast zx s_4664_2 -> bv
        let s_4664_3: Bits = Bits::new(s_4664_2 as u128, 4u16);
        // D s_4664_4: cmp-eq s_4664_1 s_4664_3
        let s_4664_4: bool = ((s_4664_1) == (s_4664_3));
        // D s_4664_5: write-var gs#118353 <= s_4664_4
        fn_state.gs_118353 = s_4664_4;
        // N s_4664_6: jump b1813
        return block_1813(state, tracer, fn_state);
    }
    fn block_4665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4665_0: read-var CRn:u8
        let s_4665_0: u8 = fn_state.CRn;
        // D s_4665_1: cast zx s_4665_0 -> bv
        let s_4665_1: Bits = Bits::new(s_4665_0 as u128, 4u16);
        // C s_4665_2: const #12u : u8
        let s_4665_2: u8 = 12;
        // C s_4665_3: cast zx s_4665_2 -> bv
        let s_4665_3: Bits = Bits::new(s_4665_2 as u128, 4u16);
        // D s_4665_4: cmp-eq s_4665_1 s_4665_3
        let s_4665_4: bool = ((s_4665_1) == (s_4665_3));
        // D s_4665_5: write-var gs#118352 <= s_4665_4
        fn_state.gs_118352 = s_4665_4;
        // N s_4665_6: jump b1811
        return block_1811(state, tracer, fn_state);
    }
    fn block_4666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4666_0: read-var el:u8
        let s_4666_0: u8 = fn_state.el;
        // D s_4666_1: read-var coproc:u8
        let s_4666_1: u8 = fn_state.coproc;
        // D s_4666_2: read-var opc1:u8
        let s_4666_2: u8 = fn_state.opc1;
        // D s_4666_3: read-var CRn:u8
        let s_4666_3: u8 = fn_state.CRn;
        // D s_4666_4: read-var opc2:u8
        let s_4666_4: u8 = fn_state.opc2;
        // D s_4666_5: read-var CRm:u8
        let s_4666_5: u8 = fn_state.CRm;
        // D s_4666_6: read-var t:i
        let s_4666_6: i128 = fn_state.t;
        // D s_4666_7: call HAMAIR0_SysRegRead32_377efb316c773bdf(s_4666_0, s_4666_1, s_4666_2, s_4666_3, s_4666_4, s_4666_5, s_4666_6)
        let s_4666_7: () = HAMAIR0_SysRegRead32_377efb316c773bdf(
            state,
            tracer,
            s_4666_0,
            s_4666_1,
            s_4666_2,
            s_4666_3,
            s_4666_4,
            s_4666_5,
            s_4666_6,
        );
        // N s_4666_8: return
        return;
    }
    fn block_4667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4667_0: read-var opc2:u8
        let s_4667_0: u8 = fn_state.opc2;
        // D s_4667_1: cast zx s_4667_0 -> bv
        let s_4667_1: Bits = Bits::new(s_4667_0 as u128, 3u16);
        // C s_4667_2: const #0u : u8
        let s_4667_2: u8 = 0;
        // C s_4667_3: cast zx s_4667_2 -> bv
        let s_4667_3: Bits = Bits::new(s_4667_2 as u128, 3u16);
        // D s_4667_4: cmp-eq s_4667_1 s_4667_3
        let s_4667_4: bool = ((s_4667_1) == (s_4667_3));
        // D s_4667_5: write-var gs#118351 <= s_4667_4
        fn_state.gs_118351 = s_4667_4;
        // N s_4667_6: jump b1808
        return block_1808(state, tracer, fn_state);
    }
    fn block_4668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4668_0: read-var opc1:u8
        let s_4668_0: u8 = fn_state.opc1;
        // D s_4668_1: cast zx s_4668_0 -> bv
        let s_4668_1: Bits = Bits::new(s_4668_0 as u128, 3u16);
        // C s_4668_2: const #4u : u8
        let s_4668_2: u8 = 4;
        // C s_4668_3: cast zx s_4668_2 -> bv
        let s_4668_3: Bits = Bits::new(s_4668_2 as u128, 3u16);
        // D s_4668_4: cmp-eq s_4668_1 s_4668_3
        let s_4668_4: bool = ((s_4668_1) == (s_4668_3));
        // D s_4668_5: write-var gs#118350 <= s_4668_4
        fn_state.gs_118350 = s_4668_4;
        // N s_4668_6: jump b1806
        return block_1806(state, tracer, fn_state);
    }
    fn block_4669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4669_0: read-var coproc:u8
        let s_4669_0: u8 = fn_state.coproc;
        // D s_4669_1: cast zx s_4669_0 -> bv
        let s_4669_1: Bits = Bits::new(s_4669_0 as u128, 4u16);
        // C s_4669_2: const #15u : u8
        let s_4669_2: u8 = 15;
        // C s_4669_3: cast zx s_4669_2 -> bv
        let s_4669_3: Bits = Bits::new(s_4669_2 as u128, 4u16);
        // D s_4669_4: cmp-eq s_4669_1 s_4669_3
        let s_4669_4: bool = ((s_4669_1) == (s_4669_3));
        // D s_4669_5: write-var gs#118349 <= s_4669_4
        fn_state.gs_118349 = s_4669_4;
        // N s_4669_6: jump b1804
        return block_1804(state, tracer, fn_state);
    }
    fn block_4670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4670_0: read-var CRn:u8
        let s_4670_0: u8 = fn_state.CRn;
        // D s_4670_1: cast zx s_4670_0 -> bv
        let s_4670_1: Bits = Bits::new(s_4670_0 as u128, 4u16);
        // C s_4670_2: const #10u : u8
        let s_4670_2: u8 = 10;
        // C s_4670_3: cast zx s_4670_2 -> bv
        let s_4670_3: Bits = Bits::new(s_4670_2 as u128, 4u16);
        // D s_4670_4: cmp-eq s_4670_1 s_4670_3
        let s_4670_4: bool = ((s_4670_1) == (s_4670_3));
        // D s_4670_5: write-var gs#118348 <= s_4670_4
        fn_state.gs_118348 = s_4670_4;
        // N s_4670_6: jump b1802
        return block_1802(state, tracer, fn_state);
    }
    fn block_4671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4671_0: read-var el:u8
        let s_4671_0: u8 = fn_state.el;
        // D s_4671_1: read-var coproc:u8
        let s_4671_1: u8 = fn_state.coproc;
        // D s_4671_2: read-var opc1:u8
        let s_4671_2: u8 = fn_state.opc1;
        // D s_4671_3: read-var CRn:u8
        let s_4671_3: u8 = fn_state.CRn;
        // D s_4671_4: read-var opc2:u8
        let s_4671_4: u8 = fn_state.opc2;
        // D s_4671_5: read-var CRm:u8
        let s_4671_5: u8 = fn_state.CRm;
        // D s_4671_6: read-var t:i
        let s_4671_6: i128 = fn_state.t;
        // D s_4671_7: call HDCR_SysRegRead32_ca37580e50123c00(s_4671_0, s_4671_1, s_4671_2, s_4671_3, s_4671_4, s_4671_5, s_4671_6)
        let s_4671_7: () = HDCR_SysRegRead32_ca37580e50123c00(
            state,
            tracer,
            s_4671_0,
            s_4671_1,
            s_4671_2,
            s_4671_3,
            s_4671_4,
            s_4671_5,
            s_4671_6,
        );
        // N s_4671_8: return
        return;
    }
    fn block_4672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4672_0: read-var opc2:u8
        let s_4672_0: u8 = fn_state.opc2;
        // D s_4672_1: cast zx s_4672_0 -> bv
        let s_4672_1: Bits = Bits::new(s_4672_0 as u128, 3u16);
        // C s_4672_2: const #1u : u8
        let s_4672_2: u8 = 1;
        // C s_4672_3: cast zx s_4672_2 -> bv
        let s_4672_3: Bits = Bits::new(s_4672_2 as u128, 3u16);
        // D s_4672_4: cmp-eq s_4672_1 s_4672_3
        let s_4672_4: bool = ((s_4672_1) == (s_4672_3));
        // D s_4672_5: write-var gs#118347 <= s_4672_4
        fn_state.gs_118347 = s_4672_4;
        // N s_4672_6: jump b1799
        return block_1799(state, tracer, fn_state);
    }
    fn block_4673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4673_0: read-var opc1:u8
        let s_4673_0: u8 = fn_state.opc1;
        // D s_4673_1: cast zx s_4673_0 -> bv
        let s_4673_1: Bits = Bits::new(s_4673_0 as u128, 3u16);
        // C s_4673_2: const #4u : u8
        let s_4673_2: u8 = 4;
        // C s_4673_3: cast zx s_4673_2 -> bv
        let s_4673_3: Bits = Bits::new(s_4673_2 as u128, 3u16);
        // D s_4673_4: cmp-eq s_4673_1 s_4673_3
        let s_4673_4: bool = ((s_4673_1) == (s_4673_3));
        // D s_4673_5: write-var gs#118346 <= s_4673_4
        fn_state.gs_118346 = s_4673_4;
        // N s_4673_6: jump b1797
        return block_1797(state, tracer, fn_state);
    }
    fn block_4674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4674_0: read-var coproc:u8
        let s_4674_0: u8 = fn_state.coproc;
        // D s_4674_1: cast zx s_4674_0 -> bv
        let s_4674_1: Bits = Bits::new(s_4674_0 as u128, 4u16);
        // C s_4674_2: const #15u : u8
        let s_4674_2: u8 = 15;
        // C s_4674_3: cast zx s_4674_2 -> bv
        let s_4674_3: Bits = Bits::new(s_4674_2 as u128, 4u16);
        // D s_4674_4: cmp-eq s_4674_1 s_4674_3
        let s_4674_4: bool = ((s_4674_1) == (s_4674_3));
        // D s_4674_5: write-var gs#118345 <= s_4674_4
        fn_state.gs_118345 = s_4674_4;
        // N s_4674_6: jump b1795
        return block_1795(state, tracer, fn_state);
    }
    fn block_4675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4675_0: read-var CRn:u8
        let s_4675_0: u8 = fn_state.CRn;
        // D s_4675_1: cast zx s_4675_0 -> bv
        let s_4675_1: Bits = Bits::new(s_4675_0 as u128, 4u16);
        // C s_4675_2: const #1u : u8
        let s_4675_2: u8 = 1;
        // C s_4675_3: cast zx s_4675_2 -> bv
        let s_4675_3: Bits = Bits::new(s_4675_2 as u128, 4u16);
        // D s_4675_4: cmp-eq s_4675_1 s_4675_3
        let s_4675_4: bool = ((s_4675_1) == (s_4675_3));
        // D s_4675_5: write-var gs#118344 <= s_4675_4
        fn_state.gs_118344 = s_4675_4;
        // N s_4675_6: jump b1793
        return block_1793(state, tracer, fn_state);
    }
    fn block_4676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4676_0: read-var el:u8
        let s_4676_0: u8 = fn_state.el;
        // D s_4676_1: read-var coproc:u8
        let s_4676_1: u8 = fn_state.coproc;
        // D s_4676_2: read-var opc1:u8
        let s_4676_2: u8 = fn_state.opc1;
        // D s_4676_3: read-var CRn:u8
        let s_4676_3: u8 = fn_state.CRn;
        // D s_4676_4: read-var opc2:u8
        let s_4676_4: u8 = fn_state.opc2;
        // D s_4676_5: read-var CRm:u8
        let s_4676_5: u8 = fn_state.CRm;
        // D s_4676_6: read-var t:i
        let s_4676_6: i128 = fn_state.t;
        // D s_4676_7: call AMAIR0_SysRegRead32_9c3a882cb83d441e(s_4676_0, s_4676_1, s_4676_2, s_4676_3, s_4676_4, s_4676_5, s_4676_6)
        let s_4676_7: () = AMAIR0_SysRegRead32_9c3a882cb83d441e(
            state,
            tracer,
            s_4676_0,
            s_4676_1,
            s_4676_2,
            s_4676_3,
            s_4676_4,
            s_4676_5,
            s_4676_6,
        );
        // N s_4676_8: return
        return;
    }
    fn block_4677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4677_0: read-var opc2:u8
        let s_4677_0: u8 = fn_state.opc2;
        // D s_4677_1: cast zx s_4677_0 -> bv
        let s_4677_1: Bits = Bits::new(s_4677_0 as u128, 3u16);
        // C s_4677_2: const #0u : u8
        let s_4677_2: u8 = 0;
        // C s_4677_3: cast zx s_4677_2 -> bv
        let s_4677_3: Bits = Bits::new(s_4677_2 as u128, 3u16);
        // D s_4677_4: cmp-eq s_4677_1 s_4677_3
        let s_4677_4: bool = ((s_4677_1) == (s_4677_3));
        // D s_4677_5: write-var gs#118343 <= s_4677_4
        fn_state.gs_118343 = s_4677_4;
        // N s_4677_6: jump b1790
        return block_1790(state, tracer, fn_state);
    }
    fn block_4678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4678_0: read-var opc1:u8
        let s_4678_0: u8 = fn_state.opc1;
        // D s_4678_1: cast zx s_4678_0 -> bv
        let s_4678_1: Bits = Bits::new(s_4678_0 as u128, 3u16);
        // C s_4678_2: const #0u : u8
        let s_4678_2: u8 = 0;
        // C s_4678_3: cast zx s_4678_2 -> bv
        let s_4678_3: Bits = Bits::new(s_4678_2 as u128, 3u16);
        // D s_4678_4: cmp-eq s_4678_1 s_4678_3
        let s_4678_4: bool = ((s_4678_1) == (s_4678_3));
        // D s_4678_5: write-var gs#118342 <= s_4678_4
        fn_state.gs_118342 = s_4678_4;
        // N s_4678_6: jump b1788
        return block_1788(state, tracer, fn_state);
    }
    fn block_4679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4679_0: read-var coproc:u8
        let s_4679_0: u8 = fn_state.coproc;
        // D s_4679_1: cast zx s_4679_0 -> bv
        let s_4679_1: Bits = Bits::new(s_4679_0 as u128, 4u16);
        // C s_4679_2: const #15u : u8
        let s_4679_2: u8 = 15;
        // C s_4679_3: cast zx s_4679_2 -> bv
        let s_4679_3: Bits = Bits::new(s_4679_2 as u128, 4u16);
        // D s_4679_4: cmp-eq s_4679_1 s_4679_3
        let s_4679_4: bool = ((s_4679_1) == (s_4679_3));
        // D s_4679_5: write-var gs#118341 <= s_4679_4
        fn_state.gs_118341 = s_4679_4;
        // N s_4679_6: jump b1786
        return block_1786(state, tracer, fn_state);
    }
    fn block_4680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4680_0: read-var CRn:u8
        let s_4680_0: u8 = fn_state.CRn;
        // D s_4680_1: cast zx s_4680_0 -> bv
        let s_4680_1: Bits = Bits::new(s_4680_0 as u128, 4u16);
        // C s_4680_2: const #10u : u8
        let s_4680_2: u8 = 10;
        // C s_4680_3: cast zx s_4680_2 -> bv
        let s_4680_3: Bits = Bits::new(s_4680_2 as u128, 4u16);
        // D s_4680_4: cmp-eq s_4680_1 s_4680_3
        let s_4680_4: bool = ((s_4680_1) == (s_4680_3));
        // D s_4680_5: write-var gs#118340 <= s_4680_4
        fn_state.gs_118340 = s_4680_4;
        // N s_4680_6: jump b1784
        return block_1784(state, tracer, fn_state);
    }
    fn block_4681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4681_0: read-var el:u8
        let s_4681_0: u8 = fn_state.el;
        // D s_4681_1: read-var coproc:u8
        let s_4681_1: u8 = fn_state.coproc;
        // D s_4681_2: read-var opc1:u8
        let s_4681_2: u8 = fn_state.opc1;
        // D s_4681_3: read-var CRn:u8
        let s_4681_3: u8 = fn_state.CRn;
        // D s_4681_4: read-var opc2:u8
        let s_4681_4: u8 = fn_state.opc2;
        // D s_4681_5: read-var CRm:u8
        let s_4681_5: u8 = fn_state.CRm;
        // D s_4681_6: read-var t:i
        let s_4681_6: i128 = fn_state.t;
        // D s_4681_7: call ICH_EISR_SysRegRead32_6c8baaadbfc73196(s_4681_0, s_4681_1, s_4681_2, s_4681_3, s_4681_4, s_4681_5, s_4681_6)
        let s_4681_7: () = ICH_EISR_SysRegRead32_6c8baaadbfc73196(
            state,
            tracer,
            s_4681_0,
            s_4681_1,
            s_4681_2,
            s_4681_3,
            s_4681_4,
            s_4681_5,
            s_4681_6,
        );
        // N s_4681_8: return
        return;
    }
    fn block_4682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4682_0: read-var opc2:u8
        let s_4682_0: u8 = fn_state.opc2;
        // D s_4682_1: cast zx s_4682_0 -> bv
        let s_4682_1: Bits = Bits::new(s_4682_0 as u128, 3u16);
        // C s_4682_2: const #3u : u8
        let s_4682_2: u8 = 3;
        // C s_4682_3: cast zx s_4682_2 -> bv
        let s_4682_3: Bits = Bits::new(s_4682_2 as u128, 3u16);
        // D s_4682_4: cmp-eq s_4682_1 s_4682_3
        let s_4682_4: bool = ((s_4682_1) == (s_4682_3));
        // D s_4682_5: write-var gs#118339 <= s_4682_4
        fn_state.gs_118339 = s_4682_4;
        // N s_4682_6: jump b1781
        return block_1781(state, tracer, fn_state);
    }
    fn block_4683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4683_0: read-var opc1:u8
        let s_4683_0: u8 = fn_state.opc1;
        // D s_4683_1: cast zx s_4683_0 -> bv
        let s_4683_1: Bits = Bits::new(s_4683_0 as u128, 3u16);
        // C s_4683_2: const #4u : u8
        let s_4683_2: u8 = 4;
        // C s_4683_3: cast zx s_4683_2 -> bv
        let s_4683_3: Bits = Bits::new(s_4683_2 as u128, 3u16);
        // D s_4683_4: cmp-eq s_4683_1 s_4683_3
        let s_4683_4: bool = ((s_4683_1) == (s_4683_3));
        // D s_4683_5: write-var gs#118338 <= s_4683_4
        fn_state.gs_118338 = s_4683_4;
        // N s_4683_6: jump b1779
        return block_1779(state, tracer, fn_state);
    }
    fn block_4684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4684_0: read-var coproc:u8
        let s_4684_0: u8 = fn_state.coproc;
        // D s_4684_1: cast zx s_4684_0 -> bv
        let s_4684_1: Bits = Bits::new(s_4684_0 as u128, 4u16);
        // C s_4684_2: const #15u : u8
        let s_4684_2: u8 = 15;
        // C s_4684_3: cast zx s_4684_2 -> bv
        let s_4684_3: Bits = Bits::new(s_4684_2 as u128, 4u16);
        // D s_4684_4: cmp-eq s_4684_1 s_4684_3
        let s_4684_4: bool = ((s_4684_1) == (s_4684_3));
        // D s_4684_5: write-var gs#118337 <= s_4684_4
        fn_state.gs_118337 = s_4684_4;
        // N s_4684_6: jump b1777
        return block_1777(state, tracer, fn_state);
    }
    fn block_4685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4685_0: read-var CRn:u8
        let s_4685_0: u8 = fn_state.CRn;
        // D s_4685_1: cast zx s_4685_0 -> bv
        let s_4685_1: Bits = Bits::new(s_4685_0 as u128, 4u16);
        // C s_4685_2: const #12u : u8
        let s_4685_2: u8 = 12;
        // C s_4685_3: cast zx s_4685_2 -> bv
        let s_4685_3: Bits = Bits::new(s_4685_2 as u128, 4u16);
        // D s_4685_4: cmp-eq s_4685_1 s_4685_3
        let s_4685_4: bool = ((s_4685_1) == (s_4685_3));
        // D s_4685_5: write-var gs#118336 <= s_4685_4
        fn_state.gs_118336 = s_4685_4;
        // N s_4685_6: jump b1775
        return block_1775(state, tracer, fn_state);
    }
    fn block_4686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4686_0: read-var el:u8
        let s_4686_0: u8 = fn_state.el;
        // D s_4686_1: read-var coproc:u8
        let s_4686_1: u8 = fn_state.coproc;
        // D s_4686_2: read-var opc1:u8
        let s_4686_2: u8 = fn_state.opc1;
        // D s_4686_3: read-var CRn:u8
        let s_4686_3: u8 = fn_state.CRn;
        // D s_4686_4: read-var opc2:u8
        let s_4686_4: u8 = fn_state.opc2;
        // D s_4686_5: read-var CRm:u8
        let s_4686_5: u8 = fn_state.CRm;
        // D s_4686_6: read-var t:i
        let s_4686_6: i128 = fn_state.t;
        // D s_4686_7: call ID_MMFR0_SysRegRead32_80f3ab2fd79cbbab(s_4686_0, s_4686_1, s_4686_2, s_4686_3, s_4686_4, s_4686_5, s_4686_6)
        let s_4686_7: () = ID_MMFR0_SysRegRead32_80f3ab2fd79cbbab(
            state,
            tracer,
            s_4686_0,
            s_4686_1,
            s_4686_2,
            s_4686_3,
            s_4686_4,
            s_4686_5,
            s_4686_6,
        );
        // N s_4686_8: return
        return;
    }
    fn block_4687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4687_0: read-var opc2:u8
        let s_4687_0: u8 = fn_state.opc2;
        // D s_4687_1: cast zx s_4687_0 -> bv
        let s_4687_1: Bits = Bits::new(s_4687_0 as u128, 3u16);
        // C s_4687_2: const #4u : u8
        let s_4687_2: u8 = 4;
        // C s_4687_3: cast zx s_4687_2 -> bv
        let s_4687_3: Bits = Bits::new(s_4687_2 as u128, 3u16);
        // D s_4687_4: cmp-eq s_4687_1 s_4687_3
        let s_4687_4: bool = ((s_4687_1) == (s_4687_3));
        // D s_4687_5: write-var gs#118335 <= s_4687_4
        fn_state.gs_118335 = s_4687_4;
        // N s_4687_6: jump b1772
        return block_1772(state, tracer, fn_state);
    }
    fn block_4688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4688_0: read-var opc1:u8
        let s_4688_0: u8 = fn_state.opc1;
        // D s_4688_1: cast zx s_4688_0 -> bv
        let s_4688_1: Bits = Bits::new(s_4688_0 as u128, 3u16);
        // C s_4688_2: const #0u : u8
        let s_4688_2: u8 = 0;
        // C s_4688_3: cast zx s_4688_2 -> bv
        let s_4688_3: Bits = Bits::new(s_4688_2 as u128, 3u16);
        // D s_4688_4: cmp-eq s_4688_1 s_4688_3
        let s_4688_4: bool = ((s_4688_1) == (s_4688_3));
        // D s_4688_5: write-var gs#118334 <= s_4688_4
        fn_state.gs_118334 = s_4688_4;
        // N s_4688_6: jump b1770
        return block_1770(state, tracer, fn_state);
    }
    fn block_4689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4689_0: read-var coproc:u8
        let s_4689_0: u8 = fn_state.coproc;
        // D s_4689_1: cast zx s_4689_0 -> bv
        let s_4689_1: Bits = Bits::new(s_4689_0 as u128, 4u16);
        // C s_4689_2: const #15u : u8
        let s_4689_2: u8 = 15;
        // C s_4689_3: cast zx s_4689_2 -> bv
        let s_4689_3: Bits = Bits::new(s_4689_2 as u128, 4u16);
        // D s_4689_4: cmp-eq s_4689_1 s_4689_3
        let s_4689_4: bool = ((s_4689_1) == (s_4689_3));
        // D s_4689_5: write-var gs#118333 <= s_4689_4
        fn_state.gs_118333 = s_4689_4;
        // N s_4689_6: jump b1768
        return block_1768(state, tracer, fn_state);
    }
    fn block_4690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4690_0: read-var CRn:u8
        let s_4690_0: u8 = fn_state.CRn;
        // D s_4690_1: cast zx s_4690_0 -> bv
        let s_4690_1: Bits = Bits::new(s_4690_0 as u128, 4u16);
        // C s_4690_2: const #0u : u8
        let s_4690_2: u8 = 0;
        // C s_4690_3: cast zx s_4690_2 -> bv
        let s_4690_3: Bits = Bits::new(s_4690_2 as u128, 4u16);
        // D s_4690_4: cmp-eq s_4690_1 s_4690_3
        let s_4690_4: bool = ((s_4690_1) == (s_4690_3));
        // D s_4690_5: write-var gs#118332 <= s_4690_4
        fn_state.gs_118332 = s_4690_4;
        // N s_4690_6: jump b1766
        return block_1766(state, tracer, fn_state);
    }
    fn block_4691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4691_0: read-var el:u8
        let s_4691_0: u8 = fn_state.el;
        // D s_4691_1: read-var coproc:u8
        let s_4691_1: u8 = fn_state.coproc;
        // D s_4691_2: read-var opc1:u8
        let s_4691_2: u8 = fn_state.opc1;
        // D s_4691_3: read-var CRn:u8
        let s_4691_3: u8 = fn_state.CRn;
        // D s_4691_4: read-var opc2:u8
        let s_4691_4: u8 = fn_state.opc2;
        // D s_4691_5: read-var CRm:u8
        let s_4691_5: u8 = fn_state.CRm;
        // D s_4691_6: read-var t:i
        let s_4691_6: i128 = fn_state.t;
        // D s_4691_7: call ICH_AP1R_SysRegRead32_0df0cbf9f8197fd3(s_4691_0, s_4691_1, s_4691_2, s_4691_3, s_4691_4, s_4691_5, s_4691_6)
        let s_4691_7: () = ICH_AP1R_SysRegRead32_0df0cbf9f8197fd3(
            state,
            tracer,
            s_4691_0,
            s_4691_1,
            s_4691_2,
            s_4691_3,
            s_4691_4,
            s_4691_5,
            s_4691_6,
        );
        // N s_4691_8: return
        return;
    }
    fn block_4692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4692_0: read-var opc2:u8
        let s_4692_0: u8 = fn_state.opc2;
        // D s_4692_1: cast zx s_4692_0 -> bv
        let s_4692_1: Bits = Bits::new(s_4692_0 as u128, 3u16);
        // C s_4692_2: const #0u : u8
        let s_4692_2: u8 = 0;
        // C s_4692_3: cast zx s_4692_2 -> bv
        let s_4692_3: Bits = Bits::new(s_4692_2 as u128, 3u16);
        // D s_4692_4: cmp-eq s_4692_1 s_4692_3
        let s_4692_4: bool = ((s_4692_1) == (s_4692_3));
        // D s_4692_5: write-var gs#118331 <= s_4692_4
        fn_state.gs_118331 = s_4692_4;
        // N s_4692_6: jump b1763
        return block_1763(state, tracer, fn_state);
    }
    fn block_4693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4693_0: read-var opc1:u8
        let s_4693_0: u8 = fn_state.opc1;
        // D s_4693_1: cast zx s_4693_0 -> bv
        let s_4693_1: Bits = Bits::new(s_4693_0 as u128, 3u16);
        // C s_4693_2: const #4u : u8
        let s_4693_2: u8 = 4;
        // C s_4693_3: cast zx s_4693_2 -> bv
        let s_4693_3: Bits = Bits::new(s_4693_2 as u128, 3u16);
        // D s_4693_4: cmp-eq s_4693_1 s_4693_3
        let s_4693_4: bool = ((s_4693_1) == (s_4693_3));
        // D s_4693_5: write-var gs#118330 <= s_4693_4
        fn_state.gs_118330 = s_4693_4;
        // N s_4693_6: jump b1761
        return block_1761(state, tracer, fn_state);
    }
    fn block_4694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4694_0: read-var coproc:u8
        let s_4694_0: u8 = fn_state.coproc;
        // D s_4694_1: cast zx s_4694_0 -> bv
        let s_4694_1: Bits = Bits::new(s_4694_0 as u128, 4u16);
        // C s_4694_2: const #15u : u8
        let s_4694_2: u8 = 15;
        // C s_4694_3: cast zx s_4694_2 -> bv
        let s_4694_3: Bits = Bits::new(s_4694_2 as u128, 4u16);
        // D s_4694_4: cmp-eq s_4694_1 s_4694_3
        let s_4694_4: bool = ((s_4694_1) == (s_4694_3));
        // D s_4694_5: write-var gs#118329 <= s_4694_4
        fn_state.gs_118329 = s_4694_4;
        // N s_4694_6: jump b1759
        return block_1759(state, tracer, fn_state);
    }
    fn block_4695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4695_0: read-var CRn:u8
        let s_4695_0: u8 = fn_state.CRn;
        // D s_4695_1: cast zx s_4695_0 -> bv
        let s_4695_1: Bits = Bits::new(s_4695_0 as u128, 4u16);
        // C s_4695_2: const #12u : u8
        let s_4695_2: u8 = 12;
        // C s_4695_3: cast zx s_4695_2 -> bv
        let s_4695_3: Bits = Bits::new(s_4695_2 as u128, 4u16);
        // D s_4695_4: cmp-eq s_4695_1 s_4695_3
        let s_4695_4: bool = ((s_4695_1) == (s_4695_3));
        // D s_4695_5: write-var gs#118328 <= s_4695_4
        fn_state.gs_118328 = s_4695_4;
        // N s_4695_6: jump b1757
        return block_1757(state, tracer, fn_state);
    }
    fn block_4696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4696_0: read-var el:u8
        let s_4696_0: u8 = fn_state.el;
        // D s_4696_1: read-var coproc:u8
        let s_4696_1: u8 = fn_state.coproc;
        // D s_4696_2: read-var opc1:u8
        let s_4696_2: u8 = fn_state.opc1;
        // D s_4696_3: read-var CRn:u8
        let s_4696_3: u8 = fn_state.CRn;
        // D s_4696_4: read-var opc2:u8
        let s_4696_4: u8 = fn_state.opc2;
        // D s_4696_5: read-var CRm:u8
        let s_4696_5: u8 = fn_state.CRm;
        // D s_4696_6: read-var t:i
        let s_4696_6: i128 = fn_state.t;
        // D s_4696_7: call ICH_AP1R_SysRegRead32_893d03c9b3bc367a(s_4696_0, s_4696_1, s_4696_2, s_4696_3, s_4696_4, s_4696_5, s_4696_6)
        let s_4696_7: () = ICH_AP1R_SysRegRead32_893d03c9b3bc367a(
            state,
            tracer,
            s_4696_0,
            s_4696_1,
            s_4696_2,
            s_4696_3,
            s_4696_4,
            s_4696_5,
            s_4696_6,
        );
        // N s_4696_8: return
        return;
    }
    fn block_4697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4697_0: read-var opc2:u8
        let s_4697_0: u8 = fn_state.opc2;
        // D s_4697_1: cast zx s_4697_0 -> bv
        let s_4697_1: Bits = Bits::new(s_4697_0 as u128, 3u16);
        // C s_4697_2: const #1u : u8
        let s_4697_2: u8 = 1;
        // C s_4697_3: cast zx s_4697_2 -> bv
        let s_4697_3: Bits = Bits::new(s_4697_2 as u128, 3u16);
        // D s_4697_4: cmp-eq s_4697_1 s_4697_3
        let s_4697_4: bool = ((s_4697_1) == (s_4697_3));
        // D s_4697_5: write-var gs#118327 <= s_4697_4
        fn_state.gs_118327 = s_4697_4;
        // N s_4697_6: jump b1754
        return block_1754(state, tracer, fn_state);
    }
    fn block_4698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4698_0: read-var opc1:u8
        let s_4698_0: u8 = fn_state.opc1;
        // D s_4698_1: cast zx s_4698_0 -> bv
        let s_4698_1: Bits = Bits::new(s_4698_0 as u128, 3u16);
        // C s_4698_2: const #4u : u8
        let s_4698_2: u8 = 4;
        // C s_4698_3: cast zx s_4698_2 -> bv
        let s_4698_3: Bits = Bits::new(s_4698_2 as u128, 3u16);
        // D s_4698_4: cmp-eq s_4698_1 s_4698_3
        let s_4698_4: bool = ((s_4698_1) == (s_4698_3));
        // D s_4698_5: write-var gs#118326 <= s_4698_4
        fn_state.gs_118326 = s_4698_4;
        // N s_4698_6: jump b1752
        return block_1752(state, tracer, fn_state);
    }
    fn block_4699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4699_0: read-var coproc:u8
        let s_4699_0: u8 = fn_state.coproc;
        // D s_4699_1: cast zx s_4699_0 -> bv
        let s_4699_1: Bits = Bits::new(s_4699_0 as u128, 4u16);
        // C s_4699_2: const #15u : u8
        let s_4699_2: u8 = 15;
        // C s_4699_3: cast zx s_4699_2 -> bv
        let s_4699_3: Bits = Bits::new(s_4699_2 as u128, 4u16);
        // D s_4699_4: cmp-eq s_4699_1 s_4699_3
        let s_4699_4: bool = ((s_4699_1) == (s_4699_3));
        // D s_4699_5: write-var gs#118325 <= s_4699_4
        fn_state.gs_118325 = s_4699_4;
        // N s_4699_6: jump b1750
        return block_1750(state, tracer, fn_state);
    }
    fn block_4700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4700_0: read-var CRn:u8
        let s_4700_0: u8 = fn_state.CRn;
        // D s_4700_1: cast zx s_4700_0 -> bv
        let s_4700_1: Bits = Bits::new(s_4700_0 as u128, 4u16);
        // C s_4700_2: const #12u : u8
        let s_4700_2: u8 = 12;
        // C s_4700_3: cast zx s_4700_2 -> bv
        let s_4700_3: Bits = Bits::new(s_4700_2 as u128, 4u16);
        // D s_4700_4: cmp-eq s_4700_1 s_4700_3
        let s_4700_4: bool = ((s_4700_1) == (s_4700_3));
        // D s_4700_5: write-var gs#118324 <= s_4700_4
        fn_state.gs_118324 = s_4700_4;
        // N s_4700_6: jump b1748
        return block_1748(state, tracer, fn_state);
    }
    fn block_4701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4701_0: read-var el:u8
        let s_4701_0: u8 = fn_state.el;
        // D s_4701_1: read-var coproc:u8
        let s_4701_1: u8 = fn_state.coproc;
        // D s_4701_2: read-var opc1:u8
        let s_4701_2: u8 = fn_state.opc1;
        // D s_4701_3: read-var CRn:u8
        let s_4701_3: u8 = fn_state.CRn;
        // D s_4701_4: read-var opc2:u8
        let s_4701_4: u8 = fn_state.opc2;
        // D s_4701_5: read-var CRm:u8
        let s_4701_5: u8 = fn_state.CRm;
        // D s_4701_6: read-var t:i
        let s_4701_6: i128 = fn_state.t;
        // D s_4701_7: call ICH_AP1R_SysRegRead32_21b1b518e28be46b(s_4701_0, s_4701_1, s_4701_2, s_4701_3, s_4701_4, s_4701_5, s_4701_6)
        let s_4701_7: () = ICH_AP1R_SysRegRead32_21b1b518e28be46b(
            state,
            tracer,
            s_4701_0,
            s_4701_1,
            s_4701_2,
            s_4701_3,
            s_4701_4,
            s_4701_5,
            s_4701_6,
        );
        // N s_4701_8: return
        return;
    }
    fn block_4702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4702_0: read-var opc2:u8
        let s_4702_0: u8 = fn_state.opc2;
        // D s_4702_1: cast zx s_4702_0 -> bv
        let s_4702_1: Bits = Bits::new(s_4702_0 as u128, 3u16);
        // C s_4702_2: const #2u : u8
        let s_4702_2: u8 = 2;
        // C s_4702_3: cast zx s_4702_2 -> bv
        let s_4702_3: Bits = Bits::new(s_4702_2 as u128, 3u16);
        // D s_4702_4: cmp-eq s_4702_1 s_4702_3
        let s_4702_4: bool = ((s_4702_1) == (s_4702_3));
        // D s_4702_5: write-var gs#118323 <= s_4702_4
        fn_state.gs_118323 = s_4702_4;
        // N s_4702_6: jump b1745
        return block_1745(state, tracer, fn_state);
    }
    fn block_4703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4703_0: read-var opc1:u8
        let s_4703_0: u8 = fn_state.opc1;
        // D s_4703_1: cast zx s_4703_0 -> bv
        let s_4703_1: Bits = Bits::new(s_4703_0 as u128, 3u16);
        // C s_4703_2: const #4u : u8
        let s_4703_2: u8 = 4;
        // C s_4703_3: cast zx s_4703_2 -> bv
        let s_4703_3: Bits = Bits::new(s_4703_2 as u128, 3u16);
        // D s_4703_4: cmp-eq s_4703_1 s_4703_3
        let s_4703_4: bool = ((s_4703_1) == (s_4703_3));
        // D s_4703_5: write-var gs#118322 <= s_4703_4
        fn_state.gs_118322 = s_4703_4;
        // N s_4703_6: jump b1743
        return block_1743(state, tracer, fn_state);
    }
    fn block_4704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4704_0: read-var coproc:u8
        let s_4704_0: u8 = fn_state.coproc;
        // D s_4704_1: cast zx s_4704_0 -> bv
        let s_4704_1: Bits = Bits::new(s_4704_0 as u128, 4u16);
        // C s_4704_2: const #15u : u8
        let s_4704_2: u8 = 15;
        // C s_4704_3: cast zx s_4704_2 -> bv
        let s_4704_3: Bits = Bits::new(s_4704_2 as u128, 4u16);
        // D s_4704_4: cmp-eq s_4704_1 s_4704_3
        let s_4704_4: bool = ((s_4704_1) == (s_4704_3));
        // D s_4704_5: write-var gs#118321 <= s_4704_4
        fn_state.gs_118321 = s_4704_4;
        // N s_4704_6: jump b1741
        return block_1741(state, tracer, fn_state);
    }
    fn block_4705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4705_0: read-var CRn:u8
        let s_4705_0: u8 = fn_state.CRn;
        // D s_4705_1: cast zx s_4705_0 -> bv
        let s_4705_1: Bits = Bits::new(s_4705_0 as u128, 4u16);
        // C s_4705_2: const #12u : u8
        let s_4705_2: u8 = 12;
        // C s_4705_3: cast zx s_4705_2 -> bv
        let s_4705_3: Bits = Bits::new(s_4705_2 as u128, 4u16);
        // D s_4705_4: cmp-eq s_4705_1 s_4705_3
        let s_4705_4: bool = ((s_4705_1) == (s_4705_3));
        // D s_4705_5: write-var gs#118320 <= s_4705_4
        fn_state.gs_118320 = s_4705_4;
        // N s_4705_6: jump b1739
        return block_1739(state, tracer, fn_state);
    }
    fn block_4706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4706_0: read-var el:u8
        let s_4706_0: u8 = fn_state.el;
        // D s_4706_1: read-var coproc:u8
        let s_4706_1: u8 = fn_state.coproc;
        // D s_4706_2: read-var opc1:u8
        let s_4706_2: u8 = fn_state.opc1;
        // D s_4706_3: read-var CRn:u8
        let s_4706_3: u8 = fn_state.CRn;
        // D s_4706_4: read-var opc2:u8
        let s_4706_4: u8 = fn_state.opc2;
        // D s_4706_5: read-var CRm:u8
        let s_4706_5: u8 = fn_state.CRm;
        // D s_4706_6: read-var t:i
        let s_4706_6: i128 = fn_state.t;
        // D s_4706_7: call ICH_AP1R_SysRegRead32_19b0a11aa0aeb1f4(s_4706_0, s_4706_1, s_4706_2, s_4706_3, s_4706_4, s_4706_5, s_4706_6)
        let s_4706_7: () = ICH_AP1R_SysRegRead32_19b0a11aa0aeb1f4(
            state,
            tracer,
            s_4706_0,
            s_4706_1,
            s_4706_2,
            s_4706_3,
            s_4706_4,
            s_4706_5,
            s_4706_6,
        );
        // N s_4706_8: return
        return;
    }
    fn block_4707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4707_0: read-var opc2:u8
        let s_4707_0: u8 = fn_state.opc2;
        // D s_4707_1: cast zx s_4707_0 -> bv
        let s_4707_1: Bits = Bits::new(s_4707_0 as u128, 3u16);
        // C s_4707_2: const #3u : u8
        let s_4707_2: u8 = 3;
        // C s_4707_3: cast zx s_4707_2 -> bv
        let s_4707_3: Bits = Bits::new(s_4707_2 as u128, 3u16);
        // D s_4707_4: cmp-eq s_4707_1 s_4707_3
        let s_4707_4: bool = ((s_4707_1) == (s_4707_3));
        // D s_4707_5: write-var gs#118319 <= s_4707_4
        fn_state.gs_118319 = s_4707_4;
        // N s_4707_6: jump b1736
        return block_1736(state, tracer, fn_state);
    }
    fn block_4708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4708_0: read-var opc1:u8
        let s_4708_0: u8 = fn_state.opc1;
        // D s_4708_1: cast zx s_4708_0 -> bv
        let s_4708_1: Bits = Bits::new(s_4708_0 as u128, 3u16);
        // C s_4708_2: const #4u : u8
        let s_4708_2: u8 = 4;
        // C s_4708_3: cast zx s_4708_2 -> bv
        let s_4708_3: Bits = Bits::new(s_4708_2 as u128, 3u16);
        // D s_4708_4: cmp-eq s_4708_1 s_4708_3
        let s_4708_4: bool = ((s_4708_1) == (s_4708_3));
        // D s_4708_5: write-var gs#118318 <= s_4708_4
        fn_state.gs_118318 = s_4708_4;
        // N s_4708_6: jump b1734
        return block_1734(state, tracer, fn_state);
    }
    fn block_4709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4709_0: read-var coproc:u8
        let s_4709_0: u8 = fn_state.coproc;
        // D s_4709_1: cast zx s_4709_0 -> bv
        let s_4709_1: Bits = Bits::new(s_4709_0 as u128, 4u16);
        // C s_4709_2: const #15u : u8
        let s_4709_2: u8 = 15;
        // C s_4709_3: cast zx s_4709_2 -> bv
        let s_4709_3: Bits = Bits::new(s_4709_2 as u128, 4u16);
        // D s_4709_4: cmp-eq s_4709_1 s_4709_3
        let s_4709_4: bool = ((s_4709_1) == (s_4709_3));
        // D s_4709_5: write-var gs#118317 <= s_4709_4
        fn_state.gs_118317 = s_4709_4;
        // N s_4709_6: jump b1732
        return block_1732(state, tracer, fn_state);
    }
    fn block_4710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4710_0: read-var CRn:u8
        let s_4710_0: u8 = fn_state.CRn;
        // D s_4710_1: cast zx s_4710_0 -> bv
        let s_4710_1: Bits = Bits::new(s_4710_0 as u128, 4u16);
        // C s_4710_2: const #12u : u8
        let s_4710_2: u8 = 12;
        // C s_4710_3: cast zx s_4710_2 -> bv
        let s_4710_3: Bits = Bits::new(s_4710_2 as u128, 4u16);
        // D s_4710_4: cmp-eq s_4710_1 s_4710_3
        let s_4710_4: bool = ((s_4710_1) == (s_4710_3));
        // D s_4710_5: write-var gs#118316 <= s_4710_4
        fn_state.gs_118316 = s_4710_4;
        // N s_4710_6: jump b1730
        return block_1730(state, tracer, fn_state);
    }
    fn block_4711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4711_0: read-var el:u8
        let s_4711_0: u8 = fn_state.el;
        // D s_4711_1: read-var coproc:u8
        let s_4711_1: u8 = fn_state.coproc;
        // D s_4711_2: read-var opc1:u8
        let s_4711_2: u8 = fn_state.opc1;
        // D s_4711_3: read-var CRn:u8
        let s_4711_3: u8 = fn_state.CRn;
        // D s_4711_4: read-var opc2:u8
        let s_4711_4: u8 = fn_state.opc2;
        // D s_4711_5: read-var CRm:u8
        let s_4711_5: u8 = fn_state.CRm;
        // D s_4711_6: read-var t:i
        let s_4711_6: i128 = fn_state.t;
        // D s_4711_7: call NSACR_SysRegRead32_a9b2f143c1a6ce93(s_4711_0, s_4711_1, s_4711_2, s_4711_3, s_4711_4, s_4711_5, s_4711_6)
        let s_4711_7: () = NSACR_SysRegRead32_a9b2f143c1a6ce93(
            state,
            tracer,
            s_4711_0,
            s_4711_1,
            s_4711_2,
            s_4711_3,
            s_4711_4,
            s_4711_5,
            s_4711_6,
        );
        // N s_4711_8: return
        return;
    }
    fn block_4712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4712_0: read-var opc2:u8
        let s_4712_0: u8 = fn_state.opc2;
        // D s_4712_1: cast zx s_4712_0 -> bv
        let s_4712_1: Bits = Bits::new(s_4712_0 as u128, 3u16);
        // C s_4712_2: const #2u : u8
        let s_4712_2: u8 = 2;
        // C s_4712_3: cast zx s_4712_2 -> bv
        let s_4712_3: Bits = Bits::new(s_4712_2 as u128, 3u16);
        // D s_4712_4: cmp-eq s_4712_1 s_4712_3
        let s_4712_4: bool = ((s_4712_1) == (s_4712_3));
        // D s_4712_5: write-var gs#118315 <= s_4712_4
        fn_state.gs_118315 = s_4712_4;
        // N s_4712_6: jump b1727
        return block_1727(state, tracer, fn_state);
    }
    fn block_4713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4713_0: read-var opc1:u8
        let s_4713_0: u8 = fn_state.opc1;
        // D s_4713_1: cast zx s_4713_0 -> bv
        let s_4713_1: Bits = Bits::new(s_4713_0 as u128, 3u16);
        // C s_4713_2: const #0u : u8
        let s_4713_2: u8 = 0;
        // C s_4713_3: cast zx s_4713_2 -> bv
        let s_4713_3: Bits = Bits::new(s_4713_2 as u128, 3u16);
        // D s_4713_4: cmp-eq s_4713_1 s_4713_3
        let s_4713_4: bool = ((s_4713_1) == (s_4713_3));
        // D s_4713_5: write-var gs#118314 <= s_4713_4
        fn_state.gs_118314 = s_4713_4;
        // N s_4713_6: jump b1725
        return block_1725(state, tracer, fn_state);
    }
    fn block_4714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4714_0: read-var coproc:u8
        let s_4714_0: u8 = fn_state.coproc;
        // D s_4714_1: cast zx s_4714_0 -> bv
        let s_4714_1: Bits = Bits::new(s_4714_0 as u128, 4u16);
        // C s_4714_2: const #15u : u8
        let s_4714_2: u8 = 15;
        // C s_4714_3: cast zx s_4714_2 -> bv
        let s_4714_3: Bits = Bits::new(s_4714_2 as u128, 4u16);
        // D s_4714_4: cmp-eq s_4714_1 s_4714_3
        let s_4714_4: bool = ((s_4714_1) == (s_4714_3));
        // D s_4714_5: write-var gs#118313 <= s_4714_4
        fn_state.gs_118313 = s_4714_4;
        // N s_4714_6: jump b1723
        return block_1723(state, tracer, fn_state);
    }
    fn block_4715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4715_0: read-var CRn:u8
        let s_4715_0: u8 = fn_state.CRn;
        // D s_4715_1: cast zx s_4715_0 -> bv
        let s_4715_1: Bits = Bits::new(s_4715_0 as u128, 4u16);
        // C s_4715_2: const #1u : u8
        let s_4715_2: u8 = 1;
        // C s_4715_3: cast zx s_4715_2 -> bv
        let s_4715_3: Bits = Bits::new(s_4715_2 as u128, 4u16);
        // D s_4715_4: cmp-eq s_4715_1 s_4715_3
        let s_4715_4: bool = ((s_4715_1) == (s_4715_3));
        // D s_4715_5: write-var gs#118312 <= s_4715_4
        fn_state.gs_118312 = s_4715_4;
        // N s_4715_6: jump b1721
        return block_1721(state, tracer, fn_state);
    }
    fn block_4716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4716_0: read-var el:u8
        let s_4716_0: u8 = fn_state.el;
        // D s_4716_1: read-var coproc:u8
        let s_4716_1: u8 = fn_state.coproc;
        // D s_4716_2: read-var opc1:u8
        let s_4716_2: u8 = fn_state.opc1;
        // D s_4716_3: read-var CRn:u8
        let s_4716_3: u8 = fn_state.CRn;
        // D s_4716_4: read-var opc2:u8
        let s_4716_4: u8 = fn_state.opc2;
        // D s_4716_5: read-var CRm:u8
        let s_4716_5: u8 = fn_state.CRm;
        // D s_4716_6: read-var t:i
        let s_4716_6: i128 = fn_state.t;
        // D s_4716_7: call SCR_SysRegRead32_7742164cbe24da83(s_4716_0, s_4716_1, s_4716_2, s_4716_3, s_4716_4, s_4716_5, s_4716_6)
        let s_4716_7: () = SCR_SysRegRead32_7742164cbe24da83(
            state,
            tracer,
            s_4716_0,
            s_4716_1,
            s_4716_2,
            s_4716_3,
            s_4716_4,
            s_4716_5,
            s_4716_6,
        );
        // N s_4716_8: return
        return;
    }
    fn block_4717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4717_0: read-var opc2:u8
        let s_4717_0: u8 = fn_state.opc2;
        // D s_4717_1: cast zx s_4717_0 -> bv
        let s_4717_1: Bits = Bits::new(s_4717_0 as u128, 3u16);
        // C s_4717_2: const #0u : u8
        let s_4717_2: u8 = 0;
        // C s_4717_3: cast zx s_4717_2 -> bv
        let s_4717_3: Bits = Bits::new(s_4717_2 as u128, 3u16);
        // D s_4717_4: cmp-eq s_4717_1 s_4717_3
        let s_4717_4: bool = ((s_4717_1) == (s_4717_3));
        // D s_4717_5: write-var gs#118311 <= s_4717_4
        fn_state.gs_118311 = s_4717_4;
        // N s_4717_6: jump b1718
        return block_1718(state, tracer, fn_state);
    }
    fn block_4718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4718_0: read-var opc1:u8
        let s_4718_0: u8 = fn_state.opc1;
        // D s_4718_1: cast zx s_4718_0 -> bv
        let s_4718_1: Bits = Bits::new(s_4718_0 as u128, 3u16);
        // C s_4718_2: const #0u : u8
        let s_4718_2: u8 = 0;
        // C s_4718_3: cast zx s_4718_2 -> bv
        let s_4718_3: Bits = Bits::new(s_4718_2 as u128, 3u16);
        // D s_4718_4: cmp-eq s_4718_1 s_4718_3
        let s_4718_4: bool = ((s_4718_1) == (s_4718_3));
        // D s_4718_5: write-var gs#118310 <= s_4718_4
        fn_state.gs_118310 = s_4718_4;
        // N s_4718_6: jump b1716
        return block_1716(state, tracer, fn_state);
    }
    fn block_4719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4719_0: read-var coproc:u8
        let s_4719_0: u8 = fn_state.coproc;
        // D s_4719_1: cast zx s_4719_0 -> bv
        let s_4719_1: Bits = Bits::new(s_4719_0 as u128, 4u16);
        // C s_4719_2: const #15u : u8
        let s_4719_2: u8 = 15;
        // C s_4719_3: cast zx s_4719_2 -> bv
        let s_4719_3: Bits = Bits::new(s_4719_2 as u128, 4u16);
        // D s_4719_4: cmp-eq s_4719_1 s_4719_3
        let s_4719_4: bool = ((s_4719_1) == (s_4719_3));
        // D s_4719_5: write-var gs#118309 <= s_4719_4
        fn_state.gs_118309 = s_4719_4;
        // N s_4719_6: jump b1714
        return block_1714(state, tracer, fn_state);
    }
    fn block_4720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4720_0: read-var CRn:u8
        let s_4720_0: u8 = fn_state.CRn;
        // D s_4720_1: cast zx s_4720_0 -> bv
        let s_4720_1: Bits = Bits::new(s_4720_0 as u128, 4u16);
        // C s_4720_2: const #1u : u8
        let s_4720_2: u8 = 1;
        // C s_4720_3: cast zx s_4720_2 -> bv
        let s_4720_3: Bits = Bits::new(s_4720_2 as u128, 4u16);
        // D s_4720_4: cmp-eq s_4720_1 s_4720_3
        let s_4720_4: bool = ((s_4720_1) == (s_4720_3));
        // D s_4720_5: write-var gs#118308 <= s_4720_4
        fn_state.gs_118308 = s_4720_4;
        // N s_4720_6: jump b1712
        return block_1712(state, tracer, fn_state);
    }
    fn block_4721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4721_0: read-var el:u8
        let s_4721_0: u8 = fn_state.el;
        // D s_4721_1: read-var coproc:u8
        let s_4721_1: u8 = fn_state.coproc;
        // D s_4721_2: read-var opc1:u8
        let s_4721_2: u8 = fn_state.opc1;
        // D s_4721_3: read-var CRn:u8
        let s_4721_3: u8 = fn_state.CRn;
        // D s_4721_4: read-var opc2:u8
        let s_4721_4: u8 = fn_state.opc2;
        // D s_4721_5: read-var CRm:u8
        let s_4721_5: u8 = fn_state.CRm;
        // D s_4721_6: read-var t:i
        let s_4721_6: i128 = fn_state.t;
        // D s_4721_7: call CNTHVS_CTL_SysRegRead32_a44e5d4ed8fbfe64(s_4721_0, s_4721_1, s_4721_2, s_4721_3, s_4721_4, s_4721_5, s_4721_6)
        let s_4721_7: () = CNTHVS_CTL_SysRegRead32_a44e5d4ed8fbfe64(
            state,
            tracer,
            s_4721_0,
            s_4721_1,
            s_4721_2,
            s_4721_3,
            s_4721_4,
            s_4721_5,
            s_4721_6,
        );
        // N s_4721_8: return
        return;
    }
    fn block_4722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4722_0: read-var opc2:u8
        let s_4722_0: u8 = fn_state.opc2;
        // D s_4722_1: cast zx s_4722_0 -> bv
        let s_4722_1: Bits = Bits::new(s_4722_0 as u128, 3u16);
        // C s_4722_2: const #1u : u8
        let s_4722_2: u8 = 1;
        // C s_4722_3: cast zx s_4722_2 -> bv
        let s_4722_3: Bits = Bits::new(s_4722_2 as u128, 3u16);
        // D s_4722_4: cmp-eq s_4722_1 s_4722_3
        let s_4722_4: bool = ((s_4722_1) == (s_4722_3));
        // D s_4722_5: write-var gs#118307 <= s_4722_4
        fn_state.gs_118307 = s_4722_4;
        // N s_4722_6: jump b1709
        return block_1709(state, tracer, fn_state);
    }
    fn block_4723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4723_0: read-var opc1:u8
        let s_4723_0: u8 = fn_state.opc1;
        // D s_4723_1: cast zx s_4723_0 -> bv
        let s_4723_1: Bits = Bits::new(s_4723_0 as u128, 3u16);
        // C s_4723_2: const #0u : u8
        let s_4723_2: u8 = 0;
        // C s_4723_3: cast zx s_4723_2 -> bv
        let s_4723_3: Bits = Bits::new(s_4723_2 as u128, 3u16);
        // D s_4723_4: cmp-eq s_4723_1 s_4723_3
        let s_4723_4: bool = ((s_4723_1) == (s_4723_3));
        // D s_4723_5: write-var gs#118306 <= s_4723_4
        fn_state.gs_118306 = s_4723_4;
        // N s_4723_6: jump b1707
        return block_1707(state, tracer, fn_state);
    }
    fn block_4724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4724_0: read-var coproc:u8
        let s_4724_0: u8 = fn_state.coproc;
        // D s_4724_1: cast zx s_4724_0 -> bv
        let s_4724_1: Bits = Bits::new(s_4724_0 as u128, 4u16);
        // C s_4724_2: const #15u : u8
        let s_4724_2: u8 = 15;
        // C s_4724_3: cast zx s_4724_2 -> bv
        let s_4724_3: Bits = Bits::new(s_4724_2 as u128, 4u16);
        // D s_4724_4: cmp-eq s_4724_1 s_4724_3
        let s_4724_4: bool = ((s_4724_1) == (s_4724_3));
        // D s_4724_5: write-var gs#118305 <= s_4724_4
        fn_state.gs_118305 = s_4724_4;
        // N s_4724_6: jump b1705
        return block_1705(state, tracer, fn_state);
    }
    fn block_4725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4725_0: read-var CRn:u8
        let s_4725_0: u8 = fn_state.CRn;
        // D s_4725_1: cast zx s_4725_0 -> bv
        let s_4725_1: Bits = Bits::new(s_4725_0 as u128, 4u16);
        // C s_4725_2: const #14u : u8
        let s_4725_2: u8 = 14;
        // C s_4725_3: cast zx s_4725_2 -> bv
        let s_4725_3: Bits = Bits::new(s_4725_2 as u128, 4u16);
        // D s_4725_4: cmp-eq s_4725_1 s_4725_3
        let s_4725_4: bool = ((s_4725_1) == (s_4725_3));
        // D s_4725_5: write-var gs#118304 <= s_4725_4
        fn_state.gs_118304 = s_4725_4;
        // N s_4725_6: jump b1703
        return block_1703(state, tracer, fn_state);
    }
    fn block_4726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4726_0: read-var el:u8
        let s_4726_0: u8 = fn_state.el;
        // D s_4726_1: read-var coproc:u8
        let s_4726_1: u8 = fn_state.coproc;
        // D s_4726_2: read-var opc1:u8
        let s_4726_2: u8 = fn_state.opc1;
        // D s_4726_3: read-var CRn:u8
        let s_4726_3: u8 = fn_state.CRn;
        // D s_4726_4: read-var opc2:u8
        let s_4726_4: u8 = fn_state.opc2;
        // D s_4726_5: read-var CRm:u8
        let s_4726_5: u8 = fn_state.CRm;
        // D s_4726_6: read-var t:i
        let s_4726_6: i128 = fn_state.t;
        // D s_4726_7: call DBGDTRRXext_SysRegRead32_4782be13f891eb2e(s_4726_0, s_4726_1, s_4726_2, s_4726_3, s_4726_4, s_4726_5, s_4726_6)
        let s_4726_7: () = DBGDTRRXext_SysRegRead32_4782be13f891eb2e(
            state,
            tracer,
            s_4726_0,
            s_4726_1,
            s_4726_2,
            s_4726_3,
            s_4726_4,
            s_4726_5,
            s_4726_6,
        );
        // N s_4726_8: return
        return;
    }
    fn block_4727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4727_0: read-var opc2:u8
        let s_4727_0: u8 = fn_state.opc2;
        // D s_4727_1: cast zx s_4727_0 -> bv
        let s_4727_1: Bits = Bits::new(s_4727_0 as u128, 3u16);
        // C s_4727_2: const #2u : u8
        let s_4727_2: u8 = 2;
        // C s_4727_3: cast zx s_4727_2 -> bv
        let s_4727_3: Bits = Bits::new(s_4727_2 as u128, 3u16);
        // D s_4727_4: cmp-eq s_4727_1 s_4727_3
        let s_4727_4: bool = ((s_4727_1) == (s_4727_3));
        // D s_4727_5: write-var gs#118303 <= s_4727_4
        fn_state.gs_118303 = s_4727_4;
        // N s_4727_6: jump b1700
        return block_1700(state, tracer, fn_state);
    }
    fn block_4728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4728_0: read-var opc1:u8
        let s_4728_0: u8 = fn_state.opc1;
        // D s_4728_1: cast zx s_4728_0 -> bv
        let s_4728_1: Bits = Bits::new(s_4728_0 as u128, 3u16);
        // C s_4728_2: const #0u : u8
        let s_4728_2: u8 = 0;
        // C s_4728_3: cast zx s_4728_2 -> bv
        let s_4728_3: Bits = Bits::new(s_4728_2 as u128, 3u16);
        // D s_4728_4: cmp-eq s_4728_1 s_4728_3
        let s_4728_4: bool = ((s_4728_1) == (s_4728_3));
        // D s_4728_5: write-var gs#118302 <= s_4728_4
        fn_state.gs_118302 = s_4728_4;
        // N s_4728_6: jump b1698
        return block_1698(state, tracer, fn_state);
    }
    fn block_4729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4729_0: read-var coproc:u8
        let s_4729_0: u8 = fn_state.coproc;
        // D s_4729_1: cast zx s_4729_0 -> bv
        let s_4729_1: Bits = Bits::new(s_4729_0 as u128, 4u16);
        // C s_4729_2: const #14u : u8
        let s_4729_2: u8 = 14;
        // C s_4729_3: cast zx s_4729_2 -> bv
        let s_4729_3: Bits = Bits::new(s_4729_2 as u128, 4u16);
        // D s_4729_4: cmp-eq s_4729_1 s_4729_3
        let s_4729_4: bool = ((s_4729_1) == (s_4729_3));
        // D s_4729_5: write-var gs#118301 <= s_4729_4
        fn_state.gs_118301 = s_4729_4;
        // N s_4729_6: jump b1696
        return block_1696(state, tracer, fn_state);
    }
    fn block_4730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4730_0: read-var CRn:u8
        let s_4730_0: u8 = fn_state.CRn;
        // D s_4730_1: cast zx s_4730_0 -> bv
        let s_4730_1: Bits = Bits::new(s_4730_0 as u128, 4u16);
        // C s_4730_2: const #0u : u8
        let s_4730_2: u8 = 0;
        // C s_4730_3: cast zx s_4730_2 -> bv
        let s_4730_3: Bits = Bits::new(s_4730_2 as u128, 4u16);
        // D s_4730_4: cmp-eq s_4730_1 s_4730_3
        let s_4730_4: bool = ((s_4730_1) == (s_4730_3));
        // D s_4730_5: write-var gs#118300 <= s_4730_4
        fn_state.gs_118300 = s_4730_4;
        // N s_4730_6: jump b1694
        return block_1694(state, tracer, fn_state);
    }
    fn block_4731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4731_0: read-var el:u8
        let s_4731_0: u8 = fn_state.el;
        // D s_4731_1: read-var coproc:u8
        let s_4731_1: u8 = fn_state.coproc;
        // D s_4731_2: read-var opc1:u8
        let s_4731_2: u8 = fn_state.opc1;
        // D s_4731_3: read-var CRn:u8
        let s_4731_3: u8 = fn_state.CRn;
        // D s_4731_4: read-var opc2:u8
        let s_4731_4: u8 = fn_state.opc2;
        // D s_4731_5: read-var CRm:u8
        let s_4731_5: u8 = fn_state.CRm;
        // D s_4731_6: read-var t:i
        let s_4731_6: i128 = fn_state.t;
        // D s_4731_7: call ACTLR_SysRegRead32_6cec3685fb7200c1(s_4731_0, s_4731_1, s_4731_2, s_4731_3, s_4731_4, s_4731_5, s_4731_6)
        let s_4731_7: () = ACTLR_SysRegRead32_6cec3685fb7200c1(
            state,
            tracer,
            s_4731_0,
            s_4731_1,
            s_4731_2,
            s_4731_3,
            s_4731_4,
            s_4731_5,
            s_4731_6,
        );
        // N s_4731_8: return
        return;
    }
    fn block_4732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4732_0: read-var opc2:u8
        let s_4732_0: u8 = fn_state.opc2;
        // D s_4732_1: cast zx s_4732_0 -> bv
        let s_4732_1: Bits = Bits::new(s_4732_0 as u128, 3u16);
        // C s_4732_2: const #1u : u8
        let s_4732_2: u8 = 1;
        // C s_4732_3: cast zx s_4732_2 -> bv
        let s_4732_3: Bits = Bits::new(s_4732_2 as u128, 3u16);
        // D s_4732_4: cmp-eq s_4732_1 s_4732_3
        let s_4732_4: bool = ((s_4732_1) == (s_4732_3));
        // D s_4732_5: write-var gs#118299 <= s_4732_4
        fn_state.gs_118299 = s_4732_4;
        // N s_4732_6: jump b1691
        return block_1691(state, tracer, fn_state);
    }
    fn block_4733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4733_0: read-var opc1:u8
        let s_4733_0: u8 = fn_state.opc1;
        // D s_4733_1: cast zx s_4733_0 -> bv
        let s_4733_1: Bits = Bits::new(s_4733_0 as u128, 3u16);
        // C s_4733_2: const #0u : u8
        let s_4733_2: u8 = 0;
        // C s_4733_3: cast zx s_4733_2 -> bv
        let s_4733_3: Bits = Bits::new(s_4733_2 as u128, 3u16);
        // D s_4733_4: cmp-eq s_4733_1 s_4733_3
        let s_4733_4: bool = ((s_4733_1) == (s_4733_3));
        // D s_4733_5: write-var gs#118298 <= s_4733_4
        fn_state.gs_118298 = s_4733_4;
        // N s_4733_6: jump b1689
        return block_1689(state, tracer, fn_state);
    }
    fn block_4734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4734_0: read-var coproc:u8
        let s_4734_0: u8 = fn_state.coproc;
        // D s_4734_1: cast zx s_4734_0 -> bv
        let s_4734_1: Bits = Bits::new(s_4734_0 as u128, 4u16);
        // C s_4734_2: const #15u : u8
        let s_4734_2: u8 = 15;
        // C s_4734_3: cast zx s_4734_2 -> bv
        let s_4734_3: Bits = Bits::new(s_4734_2 as u128, 4u16);
        // D s_4734_4: cmp-eq s_4734_1 s_4734_3
        let s_4734_4: bool = ((s_4734_1) == (s_4734_3));
        // D s_4734_5: write-var gs#118297 <= s_4734_4
        fn_state.gs_118297 = s_4734_4;
        // N s_4734_6: jump b1687
        return block_1687(state, tracer, fn_state);
    }
    fn block_4735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4735_0: read-var CRn:u8
        let s_4735_0: u8 = fn_state.CRn;
        // D s_4735_1: cast zx s_4735_0 -> bv
        let s_4735_1: Bits = Bits::new(s_4735_0 as u128, 4u16);
        // C s_4735_2: const #1u : u8
        let s_4735_2: u8 = 1;
        // C s_4735_3: cast zx s_4735_2 -> bv
        let s_4735_3: Bits = Bits::new(s_4735_2 as u128, 4u16);
        // D s_4735_4: cmp-eq s_4735_1 s_4735_3
        let s_4735_4: bool = ((s_4735_1) == (s_4735_3));
        // D s_4735_5: write-var gs#118296 <= s_4735_4
        fn_state.gs_118296 = s_4735_4;
        // N s_4735_6: jump b1685
        return block_1685(state, tracer, fn_state);
    }
    fn block_4736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4736_0: read-var el:u8
        let s_4736_0: u8 = fn_state.el;
        // D s_4736_1: read-var coproc:u8
        let s_4736_1: u8 = fn_state.coproc;
        // D s_4736_2: read-var opc1:u8
        let s_4736_2: u8 = fn_state.opc1;
        // D s_4736_3: read-var CRn:u8
        let s_4736_3: u8 = fn_state.CRn;
        // D s_4736_4: read-var opc2:u8
        let s_4736_4: u8 = fn_state.opc2;
        // D s_4736_5: read-var CRm:u8
        let s_4736_5: u8 = fn_state.CRm;
        // D s_4736_6: read-var t:i
        let s_4736_6: i128 = fn_state.t;
        // D s_4736_7: call DBGDTRTXext_SysRegRead32_dbe218a3250d179f(s_4736_0, s_4736_1, s_4736_2, s_4736_3, s_4736_4, s_4736_5, s_4736_6)
        let s_4736_7: () = DBGDTRTXext_SysRegRead32_dbe218a3250d179f(
            state,
            tracer,
            s_4736_0,
            s_4736_1,
            s_4736_2,
            s_4736_3,
            s_4736_4,
            s_4736_5,
            s_4736_6,
        );
        // N s_4736_8: return
        return;
    }
    fn block_4737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4737_0: read-var opc2:u8
        let s_4737_0: u8 = fn_state.opc2;
        // D s_4737_1: cast zx s_4737_0 -> bv
        let s_4737_1: Bits = Bits::new(s_4737_0 as u128, 3u16);
        // C s_4737_2: const #2u : u8
        let s_4737_2: u8 = 2;
        // C s_4737_3: cast zx s_4737_2 -> bv
        let s_4737_3: Bits = Bits::new(s_4737_2 as u128, 3u16);
        // D s_4737_4: cmp-eq s_4737_1 s_4737_3
        let s_4737_4: bool = ((s_4737_1) == (s_4737_3));
        // D s_4737_5: write-var gs#118295 <= s_4737_4
        fn_state.gs_118295 = s_4737_4;
        // N s_4737_6: jump b1682
        return block_1682(state, tracer, fn_state);
    }
    fn block_4738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4738_0: read-var opc1:u8
        let s_4738_0: u8 = fn_state.opc1;
        // D s_4738_1: cast zx s_4738_0 -> bv
        let s_4738_1: Bits = Bits::new(s_4738_0 as u128, 3u16);
        // C s_4738_2: const #0u : u8
        let s_4738_2: u8 = 0;
        // C s_4738_3: cast zx s_4738_2 -> bv
        let s_4738_3: Bits = Bits::new(s_4738_2 as u128, 3u16);
        // D s_4738_4: cmp-eq s_4738_1 s_4738_3
        let s_4738_4: bool = ((s_4738_1) == (s_4738_3));
        // D s_4738_5: write-var gs#118294 <= s_4738_4
        fn_state.gs_118294 = s_4738_4;
        // N s_4738_6: jump b1680
        return block_1680(state, tracer, fn_state);
    }
    fn block_4739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4739_0: read-var coproc:u8
        let s_4739_0: u8 = fn_state.coproc;
        // D s_4739_1: cast zx s_4739_0 -> bv
        let s_4739_1: Bits = Bits::new(s_4739_0 as u128, 4u16);
        // C s_4739_2: const #14u : u8
        let s_4739_2: u8 = 14;
        // C s_4739_3: cast zx s_4739_2 -> bv
        let s_4739_3: Bits = Bits::new(s_4739_2 as u128, 4u16);
        // D s_4739_4: cmp-eq s_4739_1 s_4739_3
        let s_4739_4: bool = ((s_4739_1) == (s_4739_3));
        // D s_4739_5: write-var gs#118293 <= s_4739_4
        fn_state.gs_118293 = s_4739_4;
        // N s_4739_6: jump b1678
        return block_1678(state, tracer, fn_state);
    }
    fn block_4740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4740_0: read-var CRn:u8
        let s_4740_0: u8 = fn_state.CRn;
        // D s_4740_1: cast zx s_4740_0 -> bv
        let s_4740_1: Bits = Bits::new(s_4740_0 as u128, 4u16);
        // C s_4740_2: const #0u : u8
        let s_4740_2: u8 = 0;
        // C s_4740_3: cast zx s_4740_2 -> bv
        let s_4740_3: Bits = Bits::new(s_4740_2 as u128, 4u16);
        // D s_4740_4: cmp-eq s_4740_1 s_4740_3
        let s_4740_4: bool = ((s_4740_1) == (s_4740_3));
        // D s_4740_5: write-var gs#118292 <= s_4740_4
        fn_state.gs_118292 = s_4740_4;
        // N s_4740_6: jump b1676
        return block_1676(state, tracer, fn_state);
    }
    fn block_4741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4741_0: read-var el:u8
        let s_4741_0: u8 = fn_state.el;
        // D s_4741_1: read-var coproc:u8
        let s_4741_1: u8 = fn_state.coproc;
        // D s_4741_2: read-var opc1:u8
        let s_4741_2: u8 = fn_state.opc1;
        // D s_4741_3: read-var CRn:u8
        let s_4741_3: u8 = fn_state.CRn;
        // D s_4741_4: read-var opc2:u8
        let s_4741_4: u8 = fn_state.opc2;
        // D s_4741_5: read-var CRm:u8
        let s_4741_5: u8 = fn_state.CRm;
        // D s_4741_6: read-var t:i
        let s_4741_6: i128 = fn_state.t;
        // D s_4741_7: call PMEVCNTR_SysRegRead32_d5dc3b561b7d1a1d(s_4741_0, s_4741_1, s_4741_2, s_4741_3, s_4741_4, s_4741_5, s_4741_6)
        let s_4741_7: () = PMEVCNTR_SysRegRead32_d5dc3b561b7d1a1d(
            state,
            tracer,
            s_4741_0,
            s_4741_1,
            s_4741_2,
            s_4741_3,
            s_4741_4,
            s_4741_5,
            s_4741_6,
        );
        // N s_4741_8: return
        return;
    }
    fn block_4742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4742_0: read-var opc2:u8
        let s_4742_0: u8 = fn_state.opc2;
        // D s_4742_1: cast zx s_4742_0 -> bv
        let s_4742_1: Bits = Bits::new(s_4742_0 as u128, 3u16);
        // C s_4742_2: const #0u : u8
        let s_4742_2: u8 = 0;
        // C s_4742_3: cast zx s_4742_2 -> bv
        let s_4742_3: Bits = Bits::new(s_4742_2 as u128, 3u16);
        // D s_4742_4: cmp-eq s_4742_1 s_4742_3
        let s_4742_4: bool = ((s_4742_1) == (s_4742_3));
        // D s_4742_5: write-var gs#118291 <= s_4742_4
        fn_state.gs_118291 = s_4742_4;
        // N s_4742_6: jump b1673
        return block_1673(state, tracer, fn_state);
    }
    fn block_4743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4743_0: read-var opc1:u8
        let s_4743_0: u8 = fn_state.opc1;
        // D s_4743_1: cast zx s_4743_0 -> bv
        let s_4743_1: Bits = Bits::new(s_4743_0 as u128, 3u16);
        // C s_4743_2: const #0u : u8
        let s_4743_2: u8 = 0;
        // C s_4743_3: cast zx s_4743_2 -> bv
        let s_4743_3: Bits = Bits::new(s_4743_2 as u128, 3u16);
        // D s_4743_4: cmp-eq s_4743_1 s_4743_3
        let s_4743_4: bool = ((s_4743_1) == (s_4743_3));
        // D s_4743_5: write-var gs#118290 <= s_4743_4
        fn_state.gs_118290 = s_4743_4;
        // N s_4743_6: jump b1671
        return block_1671(state, tracer, fn_state);
    }
    fn block_4744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4744_0: read-var coproc:u8
        let s_4744_0: u8 = fn_state.coproc;
        // D s_4744_1: cast zx s_4744_0 -> bv
        let s_4744_1: Bits = Bits::new(s_4744_0 as u128, 4u16);
        // C s_4744_2: const #15u : u8
        let s_4744_2: u8 = 15;
        // C s_4744_3: cast zx s_4744_2 -> bv
        let s_4744_3: Bits = Bits::new(s_4744_2 as u128, 4u16);
        // D s_4744_4: cmp-eq s_4744_1 s_4744_3
        let s_4744_4: bool = ((s_4744_1) == (s_4744_3));
        // D s_4744_5: write-var gs#118289 <= s_4744_4
        fn_state.gs_118289 = s_4744_4;
        // N s_4744_6: jump b1669
        return block_1669(state, tracer, fn_state);
    }
    fn block_4745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4745_0: read-var CRn:u8
        let s_4745_0: u8 = fn_state.CRn;
        // D s_4745_1: cast zx s_4745_0 -> bv
        let s_4745_1: Bits = Bits::new(s_4745_0 as u128, 4u16);
        // C s_4745_2: const #14u : u8
        let s_4745_2: u8 = 14;
        // C s_4745_3: cast zx s_4745_2 -> bv
        let s_4745_3: Bits = Bits::new(s_4745_2 as u128, 4u16);
        // D s_4745_4: cmp-eq s_4745_1 s_4745_3
        let s_4745_4: bool = ((s_4745_1) == (s_4745_3));
        // D s_4745_5: write-var gs#118288 <= s_4745_4
        fn_state.gs_118288 = s_4745_4;
        // N s_4745_6: jump b1667
        return block_1667(state, tracer, fn_state);
    }
    fn block_4746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4746_0: read-var el:u8
        let s_4746_0: u8 = fn_state.el;
        // D s_4746_1: read-var coproc:u8
        let s_4746_1: u8 = fn_state.coproc;
        // D s_4746_2: read-var opc1:u8
        let s_4746_2: u8 = fn_state.opc1;
        // D s_4746_3: read-var CRn:u8
        let s_4746_3: u8 = fn_state.CRn;
        // D s_4746_4: read-var opc2:u8
        let s_4746_4: u8 = fn_state.opc2;
        // D s_4746_5: read-var CRm:u8
        let s_4746_5: u8 = fn_state.CRm;
        // D s_4746_6: read-var t:i
        let s_4746_6: i128 = fn_state.t;
        // D s_4746_7: call PMEVCNTR_SysRegRead32_009022738d54bbb6(s_4746_0, s_4746_1, s_4746_2, s_4746_3, s_4746_4, s_4746_5, s_4746_6)
        let s_4746_7: () = PMEVCNTR_SysRegRead32_009022738d54bbb6(
            state,
            tracer,
            s_4746_0,
            s_4746_1,
            s_4746_2,
            s_4746_3,
            s_4746_4,
            s_4746_5,
            s_4746_6,
        );
        // N s_4746_8: return
        return;
    }
    fn block_4747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4747_0: read-var opc2:u8
        let s_4747_0: u8 = fn_state.opc2;
        // D s_4747_1: cast zx s_4747_0 -> bv
        let s_4747_1: Bits = Bits::new(s_4747_0 as u128, 3u16);
        // C s_4747_2: const #1u : u8
        let s_4747_2: u8 = 1;
        // C s_4747_3: cast zx s_4747_2 -> bv
        let s_4747_3: Bits = Bits::new(s_4747_2 as u128, 3u16);
        // D s_4747_4: cmp-eq s_4747_1 s_4747_3
        let s_4747_4: bool = ((s_4747_1) == (s_4747_3));
        // D s_4747_5: write-var gs#118287 <= s_4747_4
        fn_state.gs_118287 = s_4747_4;
        // N s_4747_6: jump b1664
        return block_1664(state, tracer, fn_state);
    }
    fn block_4748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4748_0: read-var opc1:u8
        let s_4748_0: u8 = fn_state.opc1;
        // D s_4748_1: cast zx s_4748_0 -> bv
        let s_4748_1: Bits = Bits::new(s_4748_0 as u128, 3u16);
        // C s_4748_2: const #0u : u8
        let s_4748_2: u8 = 0;
        // C s_4748_3: cast zx s_4748_2 -> bv
        let s_4748_3: Bits = Bits::new(s_4748_2 as u128, 3u16);
        // D s_4748_4: cmp-eq s_4748_1 s_4748_3
        let s_4748_4: bool = ((s_4748_1) == (s_4748_3));
        // D s_4748_5: write-var gs#118286 <= s_4748_4
        fn_state.gs_118286 = s_4748_4;
        // N s_4748_6: jump b1662
        return block_1662(state, tracer, fn_state);
    }
    fn block_4749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4749_0: read-var coproc:u8
        let s_4749_0: u8 = fn_state.coproc;
        // D s_4749_1: cast zx s_4749_0 -> bv
        let s_4749_1: Bits = Bits::new(s_4749_0 as u128, 4u16);
        // C s_4749_2: const #15u : u8
        let s_4749_2: u8 = 15;
        // C s_4749_3: cast zx s_4749_2 -> bv
        let s_4749_3: Bits = Bits::new(s_4749_2 as u128, 4u16);
        // D s_4749_4: cmp-eq s_4749_1 s_4749_3
        let s_4749_4: bool = ((s_4749_1) == (s_4749_3));
        // D s_4749_5: write-var gs#118285 <= s_4749_4
        fn_state.gs_118285 = s_4749_4;
        // N s_4749_6: jump b1660
        return block_1660(state, tracer, fn_state);
    }
    fn block_4750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4750_0: read-var CRn:u8
        let s_4750_0: u8 = fn_state.CRn;
        // D s_4750_1: cast zx s_4750_0 -> bv
        let s_4750_1: Bits = Bits::new(s_4750_0 as u128, 4u16);
        // C s_4750_2: const #14u : u8
        let s_4750_2: u8 = 14;
        // C s_4750_3: cast zx s_4750_2 -> bv
        let s_4750_3: Bits = Bits::new(s_4750_2 as u128, 4u16);
        // D s_4750_4: cmp-eq s_4750_1 s_4750_3
        let s_4750_4: bool = ((s_4750_1) == (s_4750_3));
        // D s_4750_5: write-var gs#118284 <= s_4750_4
        fn_state.gs_118284 = s_4750_4;
        // N s_4750_6: jump b1658
        return block_1658(state, tracer, fn_state);
    }
    fn block_4751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4751_0: read-var el:u8
        let s_4751_0: u8 = fn_state.el;
        // D s_4751_1: read-var coproc:u8
        let s_4751_1: u8 = fn_state.coproc;
        // D s_4751_2: read-var opc1:u8
        let s_4751_2: u8 = fn_state.opc1;
        // D s_4751_3: read-var CRn:u8
        let s_4751_3: u8 = fn_state.CRn;
        // D s_4751_4: read-var opc2:u8
        let s_4751_4: u8 = fn_state.opc2;
        // D s_4751_5: read-var CRm:u8
        let s_4751_5: u8 = fn_state.CRm;
        // D s_4751_6: read-var t:i
        let s_4751_6: i128 = fn_state.t;
        // D s_4751_7: call PMEVCNTR_SysRegRead32_1560b599f2aebd5f(s_4751_0, s_4751_1, s_4751_2, s_4751_3, s_4751_4, s_4751_5, s_4751_6)
        let s_4751_7: () = PMEVCNTR_SysRegRead32_1560b599f2aebd5f(
            state,
            tracer,
            s_4751_0,
            s_4751_1,
            s_4751_2,
            s_4751_3,
            s_4751_4,
            s_4751_5,
            s_4751_6,
        );
        // N s_4751_8: return
        return;
    }
    fn block_4752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4752_0: read-var opc2:u8
        let s_4752_0: u8 = fn_state.opc2;
        // D s_4752_1: cast zx s_4752_0 -> bv
        let s_4752_1: Bits = Bits::new(s_4752_0 as u128, 3u16);
        // C s_4752_2: const #2u : u8
        let s_4752_2: u8 = 2;
        // C s_4752_3: cast zx s_4752_2 -> bv
        let s_4752_3: Bits = Bits::new(s_4752_2 as u128, 3u16);
        // D s_4752_4: cmp-eq s_4752_1 s_4752_3
        let s_4752_4: bool = ((s_4752_1) == (s_4752_3));
        // D s_4752_5: write-var gs#118283 <= s_4752_4
        fn_state.gs_118283 = s_4752_4;
        // N s_4752_6: jump b1655
        return block_1655(state, tracer, fn_state);
    }
    fn block_4753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4753_0: read-var opc1:u8
        let s_4753_0: u8 = fn_state.opc1;
        // D s_4753_1: cast zx s_4753_0 -> bv
        let s_4753_1: Bits = Bits::new(s_4753_0 as u128, 3u16);
        // C s_4753_2: const #0u : u8
        let s_4753_2: u8 = 0;
        // C s_4753_3: cast zx s_4753_2 -> bv
        let s_4753_3: Bits = Bits::new(s_4753_2 as u128, 3u16);
        // D s_4753_4: cmp-eq s_4753_1 s_4753_3
        let s_4753_4: bool = ((s_4753_1) == (s_4753_3));
        // D s_4753_5: write-var gs#118282 <= s_4753_4
        fn_state.gs_118282 = s_4753_4;
        // N s_4753_6: jump b1653
        return block_1653(state, tracer, fn_state);
    }
    fn block_4754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4754_0: read-var coproc:u8
        let s_4754_0: u8 = fn_state.coproc;
        // D s_4754_1: cast zx s_4754_0 -> bv
        let s_4754_1: Bits = Bits::new(s_4754_0 as u128, 4u16);
        // C s_4754_2: const #15u : u8
        let s_4754_2: u8 = 15;
        // C s_4754_3: cast zx s_4754_2 -> bv
        let s_4754_3: Bits = Bits::new(s_4754_2 as u128, 4u16);
        // D s_4754_4: cmp-eq s_4754_1 s_4754_3
        let s_4754_4: bool = ((s_4754_1) == (s_4754_3));
        // D s_4754_5: write-var gs#118281 <= s_4754_4
        fn_state.gs_118281 = s_4754_4;
        // N s_4754_6: jump b1651
        return block_1651(state, tracer, fn_state);
    }
    fn block_4755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4755_0: read-var CRn:u8
        let s_4755_0: u8 = fn_state.CRn;
        // D s_4755_1: cast zx s_4755_0 -> bv
        let s_4755_1: Bits = Bits::new(s_4755_0 as u128, 4u16);
        // C s_4755_2: const #14u : u8
        let s_4755_2: u8 = 14;
        // C s_4755_3: cast zx s_4755_2 -> bv
        let s_4755_3: Bits = Bits::new(s_4755_2 as u128, 4u16);
        // D s_4755_4: cmp-eq s_4755_1 s_4755_3
        let s_4755_4: bool = ((s_4755_1) == (s_4755_3));
        // D s_4755_5: write-var gs#118280 <= s_4755_4
        fn_state.gs_118280 = s_4755_4;
        // N s_4755_6: jump b1649
        return block_1649(state, tracer, fn_state);
    }
    fn block_4756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4756_0: read-var el:u8
        let s_4756_0: u8 = fn_state.el;
        // D s_4756_1: read-var coproc:u8
        let s_4756_1: u8 = fn_state.coproc;
        // D s_4756_2: read-var opc1:u8
        let s_4756_2: u8 = fn_state.opc1;
        // D s_4756_3: read-var CRn:u8
        let s_4756_3: u8 = fn_state.CRn;
        // D s_4756_4: read-var opc2:u8
        let s_4756_4: u8 = fn_state.opc2;
        // D s_4756_5: read-var CRm:u8
        let s_4756_5: u8 = fn_state.CRm;
        // D s_4756_6: read-var t:i
        let s_4756_6: i128 = fn_state.t;
        // D s_4756_7: call PMEVCNTR_SysRegRead32_896d408c19840560(s_4756_0, s_4756_1, s_4756_2, s_4756_3, s_4756_4, s_4756_5, s_4756_6)
        let s_4756_7: () = PMEVCNTR_SysRegRead32_896d408c19840560(
            state,
            tracer,
            s_4756_0,
            s_4756_1,
            s_4756_2,
            s_4756_3,
            s_4756_4,
            s_4756_5,
            s_4756_6,
        );
        // N s_4756_8: return
        return;
    }
    fn block_4757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4757_0: read-var opc2:u8
        let s_4757_0: u8 = fn_state.opc2;
        // D s_4757_1: cast zx s_4757_0 -> bv
        let s_4757_1: Bits = Bits::new(s_4757_0 as u128, 3u16);
        // C s_4757_2: const #3u : u8
        let s_4757_2: u8 = 3;
        // C s_4757_3: cast zx s_4757_2 -> bv
        let s_4757_3: Bits = Bits::new(s_4757_2 as u128, 3u16);
        // D s_4757_4: cmp-eq s_4757_1 s_4757_3
        let s_4757_4: bool = ((s_4757_1) == (s_4757_3));
        // D s_4757_5: write-var gs#118279 <= s_4757_4
        fn_state.gs_118279 = s_4757_4;
        // N s_4757_6: jump b1646
        return block_1646(state, tracer, fn_state);
    }
    fn block_4758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4758_0: read-var opc1:u8
        let s_4758_0: u8 = fn_state.opc1;
        // D s_4758_1: cast zx s_4758_0 -> bv
        let s_4758_1: Bits = Bits::new(s_4758_0 as u128, 3u16);
        // C s_4758_2: const #0u : u8
        let s_4758_2: u8 = 0;
        // C s_4758_3: cast zx s_4758_2 -> bv
        let s_4758_3: Bits = Bits::new(s_4758_2 as u128, 3u16);
        // D s_4758_4: cmp-eq s_4758_1 s_4758_3
        let s_4758_4: bool = ((s_4758_1) == (s_4758_3));
        // D s_4758_5: write-var gs#118278 <= s_4758_4
        fn_state.gs_118278 = s_4758_4;
        // N s_4758_6: jump b1644
        return block_1644(state, tracer, fn_state);
    }
    fn block_4759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4759_0: read-var coproc:u8
        let s_4759_0: u8 = fn_state.coproc;
        // D s_4759_1: cast zx s_4759_0 -> bv
        let s_4759_1: Bits = Bits::new(s_4759_0 as u128, 4u16);
        // C s_4759_2: const #15u : u8
        let s_4759_2: u8 = 15;
        // C s_4759_3: cast zx s_4759_2 -> bv
        let s_4759_3: Bits = Bits::new(s_4759_2 as u128, 4u16);
        // D s_4759_4: cmp-eq s_4759_1 s_4759_3
        let s_4759_4: bool = ((s_4759_1) == (s_4759_3));
        // D s_4759_5: write-var gs#118277 <= s_4759_4
        fn_state.gs_118277 = s_4759_4;
        // N s_4759_6: jump b1642
        return block_1642(state, tracer, fn_state);
    }
    fn block_4760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4760_0: read-var CRn:u8
        let s_4760_0: u8 = fn_state.CRn;
        // D s_4760_1: cast zx s_4760_0 -> bv
        let s_4760_1: Bits = Bits::new(s_4760_0 as u128, 4u16);
        // C s_4760_2: const #14u : u8
        let s_4760_2: u8 = 14;
        // C s_4760_3: cast zx s_4760_2 -> bv
        let s_4760_3: Bits = Bits::new(s_4760_2 as u128, 4u16);
        // D s_4760_4: cmp-eq s_4760_1 s_4760_3
        let s_4760_4: bool = ((s_4760_1) == (s_4760_3));
        // D s_4760_5: write-var gs#118276 <= s_4760_4
        fn_state.gs_118276 = s_4760_4;
        // N s_4760_6: jump b1640
        return block_1640(state, tracer, fn_state);
    }
    fn block_4761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4761_0: read-var el:u8
        let s_4761_0: u8 = fn_state.el;
        // D s_4761_1: read-var coproc:u8
        let s_4761_1: u8 = fn_state.coproc;
        // D s_4761_2: read-var opc1:u8
        let s_4761_2: u8 = fn_state.opc1;
        // D s_4761_3: read-var CRn:u8
        let s_4761_3: u8 = fn_state.CRn;
        // D s_4761_4: read-var opc2:u8
        let s_4761_4: u8 = fn_state.opc2;
        // D s_4761_5: read-var CRm:u8
        let s_4761_5: u8 = fn_state.CRm;
        // D s_4761_6: read-var t:i
        let s_4761_6: i128 = fn_state.t;
        // D s_4761_7: call PMEVCNTR_SysRegRead32_039d4c0d22de13a2(s_4761_0, s_4761_1, s_4761_2, s_4761_3, s_4761_4, s_4761_5, s_4761_6)
        let s_4761_7: () = PMEVCNTR_SysRegRead32_039d4c0d22de13a2(
            state,
            tracer,
            s_4761_0,
            s_4761_1,
            s_4761_2,
            s_4761_3,
            s_4761_4,
            s_4761_5,
            s_4761_6,
        );
        // N s_4761_8: return
        return;
    }
    fn block_4762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4762_0: read-var opc2:u8
        let s_4762_0: u8 = fn_state.opc2;
        // D s_4762_1: cast zx s_4762_0 -> bv
        let s_4762_1: Bits = Bits::new(s_4762_0 as u128, 3u16);
        // C s_4762_2: const #4u : u8
        let s_4762_2: u8 = 4;
        // C s_4762_3: cast zx s_4762_2 -> bv
        let s_4762_3: Bits = Bits::new(s_4762_2 as u128, 3u16);
        // D s_4762_4: cmp-eq s_4762_1 s_4762_3
        let s_4762_4: bool = ((s_4762_1) == (s_4762_3));
        // D s_4762_5: write-var gs#118275 <= s_4762_4
        fn_state.gs_118275 = s_4762_4;
        // N s_4762_6: jump b1637
        return block_1637(state, tracer, fn_state);
    }
    fn block_4763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4763_0: read-var opc1:u8
        let s_4763_0: u8 = fn_state.opc1;
        // D s_4763_1: cast zx s_4763_0 -> bv
        let s_4763_1: Bits = Bits::new(s_4763_0 as u128, 3u16);
        // C s_4763_2: const #0u : u8
        let s_4763_2: u8 = 0;
        // C s_4763_3: cast zx s_4763_2 -> bv
        let s_4763_3: Bits = Bits::new(s_4763_2 as u128, 3u16);
        // D s_4763_4: cmp-eq s_4763_1 s_4763_3
        let s_4763_4: bool = ((s_4763_1) == (s_4763_3));
        // D s_4763_5: write-var gs#118274 <= s_4763_4
        fn_state.gs_118274 = s_4763_4;
        // N s_4763_6: jump b1635
        return block_1635(state, tracer, fn_state);
    }
    fn block_4764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4764_0: read-var coproc:u8
        let s_4764_0: u8 = fn_state.coproc;
        // D s_4764_1: cast zx s_4764_0 -> bv
        let s_4764_1: Bits = Bits::new(s_4764_0 as u128, 4u16);
        // C s_4764_2: const #15u : u8
        let s_4764_2: u8 = 15;
        // C s_4764_3: cast zx s_4764_2 -> bv
        let s_4764_3: Bits = Bits::new(s_4764_2 as u128, 4u16);
        // D s_4764_4: cmp-eq s_4764_1 s_4764_3
        let s_4764_4: bool = ((s_4764_1) == (s_4764_3));
        // D s_4764_5: write-var gs#118273 <= s_4764_4
        fn_state.gs_118273 = s_4764_4;
        // N s_4764_6: jump b1633
        return block_1633(state, tracer, fn_state);
    }
    fn block_4765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4765_0: read-var CRn:u8
        let s_4765_0: u8 = fn_state.CRn;
        // D s_4765_1: cast zx s_4765_0 -> bv
        let s_4765_1: Bits = Bits::new(s_4765_0 as u128, 4u16);
        // C s_4765_2: const #14u : u8
        let s_4765_2: u8 = 14;
        // C s_4765_3: cast zx s_4765_2 -> bv
        let s_4765_3: Bits = Bits::new(s_4765_2 as u128, 4u16);
        // D s_4765_4: cmp-eq s_4765_1 s_4765_3
        let s_4765_4: bool = ((s_4765_1) == (s_4765_3));
        // D s_4765_5: write-var gs#118272 <= s_4765_4
        fn_state.gs_118272 = s_4765_4;
        // N s_4765_6: jump b1631
        return block_1631(state, tracer, fn_state);
    }
    fn block_4766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4766_0: read-var el:u8
        let s_4766_0: u8 = fn_state.el;
        // D s_4766_1: read-var coproc:u8
        let s_4766_1: u8 = fn_state.coproc;
        // D s_4766_2: read-var opc1:u8
        let s_4766_2: u8 = fn_state.opc1;
        // D s_4766_3: read-var CRn:u8
        let s_4766_3: u8 = fn_state.CRn;
        // D s_4766_4: read-var opc2:u8
        let s_4766_4: u8 = fn_state.opc2;
        // D s_4766_5: read-var CRm:u8
        let s_4766_5: u8 = fn_state.CRm;
        // D s_4766_6: read-var t:i
        let s_4766_6: i128 = fn_state.t;
        // D s_4766_7: call PMEVCNTR_SysRegRead32_07d83a1ba6647217(s_4766_0, s_4766_1, s_4766_2, s_4766_3, s_4766_4, s_4766_5, s_4766_6)
        let s_4766_7: () = PMEVCNTR_SysRegRead32_07d83a1ba6647217(
            state,
            tracer,
            s_4766_0,
            s_4766_1,
            s_4766_2,
            s_4766_3,
            s_4766_4,
            s_4766_5,
            s_4766_6,
        );
        // N s_4766_8: return
        return;
    }
    fn block_4767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4767_0: read-var opc2:u8
        let s_4767_0: u8 = fn_state.opc2;
        // D s_4767_1: cast zx s_4767_0 -> bv
        let s_4767_1: Bits = Bits::new(s_4767_0 as u128, 3u16);
        // C s_4767_2: const #5u : u8
        let s_4767_2: u8 = 5;
        // C s_4767_3: cast zx s_4767_2 -> bv
        let s_4767_3: Bits = Bits::new(s_4767_2 as u128, 3u16);
        // D s_4767_4: cmp-eq s_4767_1 s_4767_3
        let s_4767_4: bool = ((s_4767_1) == (s_4767_3));
        // D s_4767_5: write-var gs#118271 <= s_4767_4
        fn_state.gs_118271 = s_4767_4;
        // N s_4767_6: jump b1628
        return block_1628(state, tracer, fn_state);
    }
    fn block_4768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4768_0: read-var opc1:u8
        let s_4768_0: u8 = fn_state.opc1;
        // D s_4768_1: cast zx s_4768_0 -> bv
        let s_4768_1: Bits = Bits::new(s_4768_0 as u128, 3u16);
        // C s_4768_2: const #0u : u8
        let s_4768_2: u8 = 0;
        // C s_4768_3: cast zx s_4768_2 -> bv
        let s_4768_3: Bits = Bits::new(s_4768_2 as u128, 3u16);
        // D s_4768_4: cmp-eq s_4768_1 s_4768_3
        let s_4768_4: bool = ((s_4768_1) == (s_4768_3));
        // D s_4768_5: write-var gs#118270 <= s_4768_4
        fn_state.gs_118270 = s_4768_4;
        // N s_4768_6: jump b1626
        return block_1626(state, tracer, fn_state);
    }
    fn block_4769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4769_0: read-var coproc:u8
        let s_4769_0: u8 = fn_state.coproc;
        // D s_4769_1: cast zx s_4769_0 -> bv
        let s_4769_1: Bits = Bits::new(s_4769_0 as u128, 4u16);
        // C s_4769_2: const #15u : u8
        let s_4769_2: u8 = 15;
        // C s_4769_3: cast zx s_4769_2 -> bv
        let s_4769_3: Bits = Bits::new(s_4769_2 as u128, 4u16);
        // D s_4769_4: cmp-eq s_4769_1 s_4769_3
        let s_4769_4: bool = ((s_4769_1) == (s_4769_3));
        // D s_4769_5: write-var gs#118269 <= s_4769_4
        fn_state.gs_118269 = s_4769_4;
        // N s_4769_6: jump b1624
        return block_1624(state, tracer, fn_state);
    }
    fn block_4770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4770_0: read-var CRn:u8
        let s_4770_0: u8 = fn_state.CRn;
        // D s_4770_1: cast zx s_4770_0 -> bv
        let s_4770_1: Bits = Bits::new(s_4770_0 as u128, 4u16);
        // C s_4770_2: const #14u : u8
        let s_4770_2: u8 = 14;
        // C s_4770_3: cast zx s_4770_2 -> bv
        let s_4770_3: Bits = Bits::new(s_4770_2 as u128, 4u16);
        // D s_4770_4: cmp-eq s_4770_1 s_4770_3
        let s_4770_4: bool = ((s_4770_1) == (s_4770_3));
        // D s_4770_5: write-var gs#118268 <= s_4770_4
        fn_state.gs_118268 = s_4770_4;
        // N s_4770_6: jump b1622
        return block_1622(state, tracer, fn_state);
    }
    fn block_4771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4771_0: read-var el:u8
        let s_4771_0: u8 = fn_state.el;
        // D s_4771_1: read-var coproc:u8
        let s_4771_1: u8 = fn_state.coproc;
        // D s_4771_2: read-var opc1:u8
        let s_4771_2: u8 = fn_state.opc1;
        // D s_4771_3: read-var CRn:u8
        let s_4771_3: u8 = fn_state.CRn;
        // D s_4771_4: read-var opc2:u8
        let s_4771_4: u8 = fn_state.opc2;
        // D s_4771_5: read-var CRm:u8
        let s_4771_5: u8 = fn_state.CRm;
        // D s_4771_6: read-var t:i
        let s_4771_6: i128 = fn_state.t;
        // D s_4771_7: call PMEVCNTR_SysRegRead32_6b342829d2da8112(s_4771_0, s_4771_1, s_4771_2, s_4771_3, s_4771_4, s_4771_5, s_4771_6)
        let s_4771_7: () = PMEVCNTR_SysRegRead32_6b342829d2da8112(
            state,
            tracer,
            s_4771_0,
            s_4771_1,
            s_4771_2,
            s_4771_3,
            s_4771_4,
            s_4771_5,
            s_4771_6,
        );
        // N s_4771_8: return
        return;
    }
    fn block_4772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4772_0: read-var opc2:u8
        let s_4772_0: u8 = fn_state.opc2;
        // D s_4772_1: cast zx s_4772_0 -> bv
        let s_4772_1: Bits = Bits::new(s_4772_0 as u128, 3u16);
        // C s_4772_2: const #6u : u8
        let s_4772_2: u8 = 6;
        // C s_4772_3: cast zx s_4772_2 -> bv
        let s_4772_3: Bits = Bits::new(s_4772_2 as u128, 3u16);
        // D s_4772_4: cmp-eq s_4772_1 s_4772_3
        let s_4772_4: bool = ((s_4772_1) == (s_4772_3));
        // D s_4772_5: write-var gs#118267 <= s_4772_4
        fn_state.gs_118267 = s_4772_4;
        // N s_4772_6: jump b1619
        return block_1619(state, tracer, fn_state);
    }
    fn block_4773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4773_0: read-var opc1:u8
        let s_4773_0: u8 = fn_state.opc1;
        // D s_4773_1: cast zx s_4773_0 -> bv
        let s_4773_1: Bits = Bits::new(s_4773_0 as u128, 3u16);
        // C s_4773_2: const #0u : u8
        let s_4773_2: u8 = 0;
        // C s_4773_3: cast zx s_4773_2 -> bv
        let s_4773_3: Bits = Bits::new(s_4773_2 as u128, 3u16);
        // D s_4773_4: cmp-eq s_4773_1 s_4773_3
        let s_4773_4: bool = ((s_4773_1) == (s_4773_3));
        // D s_4773_5: write-var gs#118266 <= s_4773_4
        fn_state.gs_118266 = s_4773_4;
        // N s_4773_6: jump b1617
        return block_1617(state, tracer, fn_state);
    }
    fn block_4774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4774_0: read-var coproc:u8
        let s_4774_0: u8 = fn_state.coproc;
        // D s_4774_1: cast zx s_4774_0 -> bv
        let s_4774_1: Bits = Bits::new(s_4774_0 as u128, 4u16);
        // C s_4774_2: const #15u : u8
        let s_4774_2: u8 = 15;
        // C s_4774_3: cast zx s_4774_2 -> bv
        let s_4774_3: Bits = Bits::new(s_4774_2 as u128, 4u16);
        // D s_4774_4: cmp-eq s_4774_1 s_4774_3
        let s_4774_4: bool = ((s_4774_1) == (s_4774_3));
        // D s_4774_5: write-var gs#118265 <= s_4774_4
        fn_state.gs_118265 = s_4774_4;
        // N s_4774_6: jump b1615
        return block_1615(state, tracer, fn_state);
    }
    fn block_4775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4775_0: read-var CRn:u8
        let s_4775_0: u8 = fn_state.CRn;
        // D s_4775_1: cast zx s_4775_0 -> bv
        let s_4775_1: Bits = Bits::new(s_4775_0 as u128, 4u16);
        // C s_4775_2: const #14u : u8
        let s_4775_2: u8 = 14;
        // C s_4775_3: cast zx s_4775_2 -> bv
        let s_4775_3: Bits = Bits::new(s_4775_2 as u128, 4u16);
        // D s_4775_4: cmp-eq s_4775_1 s_4775_3
        let s_4775_4: bool = ((s_4775_1) == (s_4775_3));
        // D s_4775_5: write-var gs#118264 <= s_4775_4
        fn_state.gs_118264 = s_4775_4;
        // N s_4775_6: jump b1613
        return block_1613(state, tracer, fn_state);
    }
    fn block_4776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4776_0: read-var el:u8
        let s_4776_0: u8 = fn_state.el;
        // D s_4776_1: read-var coproc:u8
        let s_4776_1: u8 = fn_state.coproc;
        // D s_4776_2: read-var opc1:u8
        let s_4776_2: u8 = fn_state.opc1;
        // D s_4776_3: read-var CRn:u8
        let s_4776_3: u8 = fn_state.CRn;
        // D s_4776_4: read-var opc2:u8
        let s_4776_4: u8 = fn_state.opc2;
        // D s_4776_5: read-var CRm:u8
        let s_4776_5: u8 = fn_state.CRm;
        // D s_4776_6: read-var t:i
        let s_4776_6: i128 = fn_state.t;
        // D s_4776_7: call PMEVCNTR_SysRegRead32_ae92cdab2a8b2c18(s_4776_0, s_4776_1, s_4776_2, s_4776_3, s_4776_4, s_4776_5, s_4776_6)
        let s_4776_7: () = PMEVCNTR_SysRegRead32_ae92cdab2a8b2c18(
            state,
            tracer,
            s_4776_0,
            s_4776_1,
            s_4776_2,
            s_4776_3,
            s_4776_4,
            s_4776_5,
            s_4776_6,
        );
        // N s_4776_8: return
        return;
    }
    fn block_4777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4777_0: read-var opc2:u8
        let s_4777_0: u8 = fn_state.opc2;
        // D s_4777_1: cast zx s_4777_0 -> bv
        let s_4777_1: Bits = Bits::new(s_4777_0 as u128, 3u16);
        // C s_4777_2: const #7u : u8
        let s_4777_2: u8 = 7;
        // C s_4777_3: cast zx s_4777_2 -> bv
        let s_4777_3: Bits = Bits::new(s_4777_2 as u128, 3u16);
        // D s_4777_4: cmp-eq s_4777_1 s_4777_3
        let s_4777_4: bool = ((s_4777_1) == (s_4777_3));
        // D s_4777_5: write-var gs#118263 <= s_4777_4
        fn_state.gs_118263 = s_4777_4;
        // N s_4777_6: jump b1610
        return block_1610(state, tracer, fn_state);
    }
    fn block_4778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4778_0: read-var opc1:u8
        let s_4778_0: u8 = fn_state.opc1;
        // D s_4778_1: cast zx s_4778_0 -> bv
        let s_4778_1: Bits = Bits::new(s_4778_0 as u128, 3u16);
        // C s_4778_2: const #0u : u8
        let s_4778_2: u8 = 0;
        // C s_4778_3: cast zx s_4778_2 -> bv
        let s_4778_3: Bits = Bits::new(s_4778_2 as u128, 3u16);
        // D s_4778_4: cmp-eq s_4778_1 s_4778_3
        let s_4778_4: bool = ((s_4778_1) == (s_4778_3));
        // D s_4778_5: write-var gs#118262 <= s_4778_4
        fn_state.gs_118262 = s_4778_4;
        // N s_4778_6: jump b1608
        return block_1608(state, tracer, fn_state);
    }
    fn block_4779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4779_0: read-var coproc:u8
        let s_4779_0: u8 = fn_state.coproc;
        // D s_4779_1: cast zx s_4779_0 -> bv
        let s_4779_1: Bits = Bits::new(s_4779_0 as u128, 4u16);
        // C s_4779_2: const #15u : u8
        let s_4779_2: u8 = 15;
        // C s_4779_3: cast zx s_4779_2 -> bv
        let s_4779_3: Bits = Bits::new(s_4779_2 as u128, 4u16);
        // D s_4779_4: cmp-eq s_4779_1 s_4779_3
        let s_4779_4: bool = ((s_4779_1) == (s_4779_3));
        // D s_4779_5: write-var gs#118261 <= s_4779_4
        fn_state.gs_118261 = s_4779_4;
        // N s_4779_6: jump b1606
        return block_1606(state, tracer, fn_state);
    }
    fn block_4780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4780_0: read-var CRn:u8
        let s_4780_0: u8 = fn_state.CRn;
        // D s_4780_1: cast zx s_4780_0 -> bv
        let s_4780_1: Bits = Bits::new(s_4780_0 as u128, 4u16);
        // C s_4780_2: const #14u : u8
        let s_4780_2: u8 = 14;
        // C s_4780_3: cast zx s_4780_2 -> bv
        let s_4780_3: Bits = Bits::new(s_4780_2 as u128, 4u16);
        // D s_4780_4: cmp-eq s_4780_1 s_4780_3
        let s_4780_4: bool = ((s_4780_1) == (s_4780_3));
        // D s_4780_5: write-var gs#118260 <= s_4780_4
        fn_state.gs_118260 = s_4780_4;
        // N s_4780_6: jump b1604
        return block_1604(state, tracer, fn_state);
    }
    fn block_4781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4781_0: read-var el:u8
        let s_4781_0: u8 = fn_state.el;
        // D s_4781_1: read-var coproc:u8
        let s_4781_1: u8 = fn_state.coproc;
        // D s_4781_2: read-var opc1:u8
        let s_4781_2: u8 = fn_state.opc1;
        // D s_4781_3: read-var CRn:u8
        let s_4781_3: u8 = fn_state.CRn;
        // D s_4781_4: read-var opc2:u8
        let s_4781_4: u8 = fn_state.opc2;
        // D s_4781_5: read-var CRm:u8
        let s_4781_5: u8 = fn_state.CRm;
        // D s_4781_6: read-var t:i
        let s_4781_6: i128 = fn_state.t;
        // D s_4781_7: call PMEVCNTR_SysRegRead32_ab42fc938eac6b81(s_4781_0, s_4781_1, s_4781_2, s_4781_3, s_4781_4, s_4781_5, s_4781_6)
        let s_4781_7: () = PMEVCNTR_SysRegRead32_ab42fc938eac6b81(
            state,
            tracer,
            s_4781_0,
            s_4781_1,
            s_4781_2,
            s_4781_3,
            s_4781_4,
            s_4781_5,
            s_4781_6,
        );
        // N s_4781_8: return
        return;
    }
    fn block_4782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4782_0: read-var opc2:u8
        let s_4782_0: u8 = fn_state.opc2;
        // D s_4782_1: cast zx s_4782_0 -> bv
        let s_4782_1: Bits = Bits::new(s_4782_0 as u128, 3u16);
        // C s_4782_2: const #0u : u8
        let s_4782_2: u8 = 0;
        // C s_4782_3: cast zx s_4782_2 -> bv
        let s_4782_3: Bits = Bits::new(s_4782_2 as u128, 3u16);
        // D s_4782_4: cmp-eq s_4782_1 s_4782_3
        let s_4782_4: bool = ((s_4782_1) == (s_4782_3));
        // D s_4782_5: write-var gs#118259 <= s_4782_4
        fn_state.gs_118259 = s_4782_4;
        // N s_4782_6: jump b1601
        return block_1601(state, tracer, fn_state);
    }
    fn block_4783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4783_0: read-var opc1:u8
        let s_4783_0: u8 = fn_state.opc1;
        // D s_4783_1: cast zx s_4783_0 -> bv
        let s_4783_1: Bits = Bits::new(s_4783_0 as u128, 3u16);
        // C s_4783_2: const #0u : u8
        let s_4783_2: u8 = 0;
        // C s_4783_3: cast zx s_4783_2 -> bv
        let s_4783_3: Bits = Bits::new(s_4783_2 as u128, 3u16);
        // D s_4783_4: cmp-eq s_4783_1 s_4783_3
        let s_4783_4: bool = ((s_4783_1) == (s_4783_3));
        // D s_4783_5: write-var gs#118258 <= s_4783_4
        fn_state.gs_118258 = s_4783_4;
        // N s_4783_6: jump b1599
        return block_1599(state, tracer, fn_state);
    }
    fn block_4784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4784_0: read-var coproc:u8
        let s_4784_0: u8 = fn_state.coproc;
        // D s_4784_1: cast zx s_4784_0 -> bv
        let s_4784_1: Bits = Bits::new(s_4784_0 as u128, 4u16);
        // C s_4784_2: const #15u : u8
        let s_4784_2: u8 = 15;
        // C s_4784_3: cast zx s_4784_2 -> bv
        let s_4784_3: Bits = Bits::new(s_4784_2 as u128, 4u16);
        // D s_4784_4: cmp-eq s_4784_1 s_4784_3
        let s_4784_4: bool = ((s_4784_1) == (s_4784_3));
        // D s_4784_5: write-var gs#118257 <= s_4784_4
        fn_state.gs_118257 = s_4784_4;
        // N s_4784_6: jump b1597
        return block_1597(state, tracer, fn_state);
    }
    fn block_4785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4785_0: read-var CRn:u8
        let s_4785_0: u8 = fn_state.CRn;
        // D s_4785_1: cast zx s_4785_0 -> bv
        let s_4785_1: Bits = Bits::new(s_4785_0 as u128, 4u16);
        // C s_4785_2: const #14u : u8
        let s_4785_2: u8 = 14;
        // C s_4785_3: cast zx s_4785_2 -> bv
        let s_4785_3: Bits = Bits::new(s_4785_2 as u128, 4u16);
        // D s_4785_4: cmp-eq s_4785_1 s_4785_3
        let s_4785_4: bool = ((s_4785_1) == (s_4785_3));
        // D s_4785_5: write-var gs#118256 <= s_4785_4
        fn_state.gs_118256 = s_4785_4;
        // N s_4785_6: jump b1595
        return block_1595(state, tracer, fn_state);
    }
    fn block_4786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4786_0: read-var el:u8
        let s_4786_0: u8 = fn_state.el;
        // D s_4786_1: read-var coproc:u8
        let s_4786_1: u8 = fn_state.coproc;
        // D s_4786_2: read-var opc1:u8
        let s_4786_2: u8 = fn_state.opc1;
        // D s_4786_3: read-var CRn:u8
        let s_4786_3: u8 = fn_state.CRn;
        // D s_4786_4: read-var opc2:u8
        let s_4786_4: u8 = fn_state.opc2;
        // D s_4786_5: read-var CRm:u8
        let s_4786_5: u8 = fn_state.CRm;
        // D s_4786_6: read-var t:i
        let s_4786_6: i128 = fn_state.t;
        // D s_4786_7: call PMEVCNTR_SysRegRead32_45099baba0e3c6c8(s_4786_0, s_4786_1, s_4786_2, s_4786_3, s_4786_4, s_4786_5, s_4786_6)
        let s_4786_7: () = PMEVCNTR_SysRegRead32_45099baba0e3c6c8(
            state,
            tracer,
            s_4786_0,
            s_4786_1,
            s_4786_2,
            s_4786_3,
            s_4786_4,
            s_4786_5,
            s_4786_6,
        );
        // N s_4786_8: return
        return;
    }
    fn block_4787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4787_0: read-var opc2:u8
        let s_4787_0: u8 = fn_state.opc2;
        // D s_4787_1: cast zx s_4787_0 -> bv
        let s_4787_1: Bits = Bits::new(s_4787_0 as u128, 3u16);
        // C s_4787_2: const #1u : u8
        let s_4787_2: u8 = 1;
        // C s_4787_3: cast zx s_4787_2 -> bv
        let s_4787_3: Bits = Bits::new(s_4787_2 as u128, 3u16);
        // D s_4787_4: cmp-eq s_4787_1 s_4787_3
        let s_4787_4: bool = ((s_4787_1) == (s_4787_3));
        // D s_4787_5: write-var gs#118255 <= s_4787_4
        fn_state.gs_118255 = s_4787_4;
        // N s_4787_6: jump b1592
        return block_1592(state, tracer, fn_state);
    }
    fn block_4788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4788_0: read-var opc1:u8
        let s_4788_0: u8 = fn_state.opc1;
        // D s_4788_1: cast zx s_4788_0 -> bv
        let s_4788_1: Bits = Bits::new(s_4788_0 as u128, 3u16);
        // C s_4788_2: const #0u : u8
        let s_4788_2: u8 = 0;
        // C s_4788_3: cast zx s_4788_2 -> bv
        let s_4788_3: Bits = Bits::new(s_4788_2 as u128, 3u16);
        // D s_4788_4: cmp-eq s_4788_1 s_4788_3
        let s_4788_4: bool = ((s_4788_1) == (s_4788_3));
        // D s_4788_5: write-var gs#118254 <= s_4788_4
        fn_state.gs_118254 = s_4788_4;
        // N s_4788_6: jump b1590
        return block_1590(state, tracer, fn_state);
    }
    fn block_4789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4789_0: read-var coproc:u8
        let s_4789_0: u8 = fn_state.coproc;
        // D s_4789_1: cast zx s_4789_0 -> bv
        let s_4789_1: Bits = Bits::new(s_4789_0 as u128, 4u16);
        // C s_4789_2: const #15u : u8
        let s_4789_2: u8 = 15;
        // C s_4789_3: cast zx s_4789_2 -> bv
        let s_4789_3: Bits = Bits::new(s_4789_2 as u128, 4u16);
        // D s_4789_4: cmp-eq s_4789_1 s_4789_3
        let s_4789_4: bool = ((s_4789_1) == (s_4789_3));
        // D s_4789_5: write-var gs#118253 <= s_4789_4
        fn_state.gs_118253 = s_4789_4;
        // N s_4789_6: jump b1588
        return block_1588(state, tracer, fn_state);
    }
    fn block_4790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4790_0: read-var CRn:u8
        let s_4790_0: u8 = fn_state.CRn;
        // D s_4790_1: cast zx s_4790_0 -> bv
        let s_4790_1: Bits = Bits::new(s_4790_0 as u128, 4u16);
        // C s_4790_2: const #14u : u8
        let s_4790_2: u8 = 14;
        // C s_4790_3: cast zx s_4790_2 -> bv
        let s_4790_3: Bits = Bits::new(s_4790_2 as u128, 4u16);
        // D s_4790_4: cmp-eq s_4790_1 s_4790_3
        let s_4790_4: bool = ((s_4790_1) == (s_4790_3));
        // D s_4790_5: write-var gs#118252 <= s_4790_4
        fn_state.gs_118252 = s_4790_4;
        // N s_4790_6: jump b1586
        return block_1586(state, tracer, fn_state);
    }
    fn block_4791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4791_0: read-var el:u8
        let s_4791_0: u8 = fn_state.el;
        // D s_4791_1: read-var coproc:u8
        let s_4791_1: u8 = fn_state.coproc;
        // D s_4791_2: read-var opc1:u8
        let s_4791_2: u8 = fn_state.opc1;
        // D s_4791_3: read-var CRn:u8
        let s_4791_3: u8 = fn_state.CRn;
        // D s_4791_4: read-var opc2:u8
        let s_4791_4: u8 = fn_state.opc2;
        // D s_4791_5: read-var CRm:u8
        let s_4791_5: u8 = fn_state.CRm;
        // D s_4791_6: read-var t:i
        let s_4791_6: i128 = fn_state.t;
        // D s_4791_7: call PMEVCNTR_SysRegRead32_42630578733f5de1(s_4791_0, s_4791_1, s_4791_2, s_4791_3, s_4791_4, s_4791_5, s_4791_6)
        let s_4791_7: () = PMEVCNTR_SysRegRead32_42630578733f5de1(
            state,
            tracer,
            s_4791_0,
            s_4791_1,
            s_4791_2,
            s_4791_3,
            s_4791_4,
            s_4791_5,
            s_4791_6,
        );
        // N s_4791_8: return
        return;
    }
    fn block_4792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4792_0: read-var opc2:u8
        let s_4792_0: u8 = fn_state.opc2;
        // D s_4792_1: cast zx s_4792_0 -> bv
        let s_4792_1: Bits = Bits::new(s_4792_0 as u128, 3u16);
        // C s_4792_2: const #2u : u8
        let s_4792_2: u8 = 2;
        // C s_4792_3: cast zx s_4792_2 -> bv
        let s_4792_3: Bits = Bits::new(s_4792_2 as u128, 3u16);
        // D s_4792_4: cmp-eq s_4792_1 s_4792_3
        let s_4792_4: bool = ((s_4792_1) == (s_4792_3));
        // D s_4792_5: write-var gs#118251 <= s_4792_4
        fn_state.gs_118251 = s_4792_4;
        // N s_4792_6: jump b1583
        return block_1583(state, tracer, fn_state);
    }
    fn block_4793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4793_0: read-var opc1:u8
        let s_4793_0: u8 = fn_state.opc1;
        // D s_4793_1: cast zx s_4793_0 -> bv
        let s_4793_1: Bits = Bits::new(s_4793_0 as u128, 3u16);
        // C s_4793_2: const #0u : u8
        let s_4793_2: u8 = 0;
        // C s_4793_3: cast zx s_4793_2 -> bv
        let s_4793_3: Bits = Bits::new(s_4793_2 as u128, 3u16);
        // D s_4793_4: cmp-eq s_4793_1 s_4793_3
        let s_4793_4: bool = ((s_4793_1) == (s_4793_3));
        // D s_4793_5: write-var gs#118250 <= s_4793_4
        fn_state.gs_118250 = s_4793_4;
        // N s_4793_6: jump b1581
        return block_1581(state, tracer, fn_state);
    }
    fn block_4794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4794_0: read-var coproc:u8
        let s_4794_0: u8 = fn_state.coproc;
        // D s_4794_1: cast zx s_4794_0 -> bv
        let s_4794_1: Bits = Bits::new(s_4794_0 as u128, 4u16);
        // C s_4794_2: const #15u : u8
        let s_4794_2: u8 = 15;
        // C s_4794_3: cast zx s_4794_2 -> bv
        let s_4794_3: Bits = Bits::new(s_4794_2 as u128, 4u16);
        // D s_4794_4: cmp-eq s_4794_1 s_4794_3
        let s_4794_4: bool = ((s_4794_1) == (s_4794_3));
        // D s_4794_5: write-var gs#118249 <= s_4794_4
        fn_state.gs_118249 = s_4794_4;
        // N s_4794_6: jump b1579
        return block_1579(state, tracer, fn_state);
    }
    fn block_4795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4795_0: read-var CRn:u8
        let s_4795_0: u8 = fn_state.CRn;
        // D s_4795_1: cast zx s_4795_0 -> bv
        let s_4795_1: Bits = Bits::new(s_4795_0 as u128, 4u16);
        // C s_4795_2: const #14u : u8
        let s_4795_2: u8 = 14;
        // C s_4795_3: cast zx s_4795_2 -> bv
        let s_4795_3: Bits = Bits::new(s_4795_2 as u128, 4u16);
        // D s_4795_4: cmp-eq s_4795_1 s_4795_3
        let s_4795_4: bool = ((s_4795_1) == (s_4795_3));
        // D s_4795_5: write-var gs#118248 <= s_4795_4
        fn_state.gs_118248 = s_4795_4;
        // N s_4795_6: jump b1577
        return block_1577(state, tracer, fn_state);
    }
    fn block_4796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4796_0: read-var el:u8
        let s_4796_0: u8 = fn_state.el;
        // D s_4796_1: read-var coproc:u8
        let s_4796_1: u8 = fn_state.coproc;
        // D s_4796_2: read-var opc1:u8
        let s_4796_2: u8 = fn_state.opc1;
        // D s_4796_3: read-var CRn:u8
        let s_4796_3: u8 = fn_state.CRn;
        // D s_4796_4: read-var opc2:u8
        let s_4796_4: u8 = fn_state.opc2;
        // D s_4796_5: read-var CRm:u8
        let s_4796_5: u8 = fn_state.CRm;
        // D s_4796_6: read-var t:i
        let s_4796_6: i128 = fn_state.t;
        // D s_4796_7: call PMEVCNTR_SysRegRead32_a6f4d7c9818fe27f(s_4796_0, s_4796_1, s_4796_2, s_4796_3, s_4796_4, s_4796_5, s_4796_6)
        let s_4796_7: () = PMEVCNTR_SysRegRead32_a6f4d7c9818fe27f(
            state,
            tracer,
            s_4796_0,
            s_4796_1,
            s_4796_2,
            s_4796_3,
            s_4796_4,
            s_4796_5,
            s_4796_6,
        );
        // N s_4796_8: return
        return;
    }
    fn block_4797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4797_0: read-var opc2:u8
        let s_4797_0: u8 = fn_state.opc2;
        // D s_4797_1: cast zx s_4797_0 -> bv
        let s_4797_1: Bits = Bits::new(s_4797_0 as u128, 3u16);
        // C s_4797_2: const #3u : u8
        let s_4797_2: u8 = 3;
        // C s_4797_3: cast zx s_4797_2 -> bv
        let s_4797_3: Bits = Bits::new(s_4797_2 as u128, 3u16);
        // D s_4797_4: cmp-eq s_4797_1 s_4797_3
        let s_4797_4: bool = ((s_4797_1) == (s_4797_3));
        // D s_4797_5: write-var gs#118247 <= s_4797_4
        fn_state.gs_118247 = s_4797_4;
        // N s_4797_6: jump b1574
        return block_1574(state, tracer, fn_state);
    }
    fn block_4798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4798_0: read-var opc1:u8
        let s_4798_0: u8 = fn_state.opc1;
        // D s_4798_1: cast zx s_4798_0 -> bv
        let s_4798_1: Bits = Bits::new(s_4798_0 as u128, 3u16);
        // C s_4798_2: const #0u : u8
        let s_4798_2: u8 = 0;
        // C s_4798_3: cast zx s_4798_2 -> bv
        let s_4798_3: Bits = Bits::new(s_4798_2 as u128, 3u16);
        // D s_4798_4: cmp-eq s_4798_1 s_4798_3
        let s_4798_4: bool = ((s_4798_1) == (s_4798_3));
        // D s_4798_5: write-var gs#118246 <= s_4798_4
        fn_state.gs_118246 = s_4798_4;
        // N s_4798_6: jump b1572
        return block_1572(state, tracer, fn_state);
    }
    fn block_4799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4799_0: read-var coproc:u8
        let s_4799_0: u8 = fn_state.coproc;
        // D s_4799_1: cast zx s_4799_0 -> bv
        let s_4799_1: Bits = Bits::new(s_4799_0 as u128, 4u16);
        // C s_4799_2: const #15u : u8
        let s_4799_2: u8 = 15;
        // C s_4799_3: cast zx s_4799_2 -> bv
        let s_4799_3: Bits = Bits::new(s_4799_2 as u128, 4u16);
        // D s_4799_4: cmp-eq s_4799_1 s_4799_3
        let s_4799_4: bool = ((s_4799_1) == (s_4799_3));
        // D s_4799_5: write-var gs#118245 <= s_4799_4
        fn_state.gs_118245 = s_4799_4;
        // N s_4799_6: jump b1570
        return block_1570(state, tracer, fn_state);
    }
    fn block_4800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4800_0: read-var CRn:u8
        let s_4800_0: u8 = fn_state.CRn;
        // D s_4800_1: cast zx s_4800_0 -> bv
        let s_4800_1: Bits = Bits::new(s_4800_0 as u128, 4u16);
        // C s_4800_2: const #14u : u8
        let s_4800_2: u8 = 14;
        // C s_4800_3: cast zx s_4800_2 -> bv
        let s_4800_3: Bits = Bits::new(s_4800_2 as u128, 4u16);
        // D s_4800_4: cmp-eq s_4800_1 s_4800_3
        let s_4800_4: bool = ((s_4800_1) == (s_4800_3));
        // D s_4800_5: write-var gs#118244 <= s_4800_4
        fn_state.gs_118244 = s_4800_4;
        // N s_4800_6: jump b1568
        return block_1568(state, tracer, fn_state);
    }
    fn block_4801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4801_0: read-var el:u8
        let s_4801_0: u8 = fn_state.el;
        // D s_4801_1: read-var coproc:u8
        let s_4801_1: u8 = fn_state.coproc;
        // D s_4801_2: read-var opc1:u8
        let s_4801_2: u8 = fn_state.opc1;
        // D s_4801_3: read-var CRn:u8
        let s_4801_3: u8 = fn_state.CRn;
        // D s_4801_4: read-var opc2:u8
        let s_4801_4: u8 = fn_state.opc2;
        // D s_4801_5: read-var CRm:u8
        let s_4801_5: u8 = fn_state.CRm;
        // D s_4801_6: read-var t:i
        let s_4801_6: i128 = fn_state.t;
        // D s_4801_7: call PMEVCNTR_SysRegRead32_396f7b80977acfd5(s_4801_0, s_4801_1, s_4801_2, s_4801_3, s_4801_4, s_4801_5, s_4801_6)
        let s_4801_7: () = PMEVCNTR_SysRegRead32_396f7b80977acfd5(
            state,
            tracer,
            s_4801_0,
            s_4801_1,
            s_4801_2,
            s_4801_3,
            s_4801_4,
            s_4801_5,
            s_4801_6,
        );
        // N s_4801_8: return
        return;
    }
    fn block_4802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4802_0: read-var opc2:u8
        let s_4802_0: u8 = fn_state.opc2;
        // D s_4802_1: cast zx s_4802_0 -> bv
        let s_4802_1: Bits = Bits::new(s_4802_0 as u128, 3u16);
        // C s_4802_2: const #4u : u8
        let s_4802_2: u8 = 4;
        // C s_4802_3: cast zx s_4802_2 -> bv
        let s_4802_3: Bits = Bits::new(s_4802_2 as u128, 3u16);
        // D s_4802_4: cmp-eq s_4802_1 s_4802_3
        let s_4802_4: bool = ((s_4802_1) == (s_4802_3));
        // D s_4802_5: write-var gs#118243 <= s_4802_4
        fn_state.gs_118243 = s_4802_4;
        // N s_4802_6: jump b1565
        return block_1565(state, tracer, fn_state);
    }
    fn block_4803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4803_0: read-var opc1:u8
        let s_4803_0: u8 = fn_state.opc1;
        // D s_4803_1: cast zx s_4803_0 -> bv
        let s_4803_1: Bits = Bits::new(s_4803_0 as u128, 3u16);
        // C s_4803_2: const #0u : u8
        let s_4803_2: u8 = 0;
        // C s_4803_3: cast zx s_4803_2 -> bv
        let s_4803_3: Bits = Bits::new(s_4803_2 as u128, 3u16);
        // D s_4803_4: cmp-eq s_4803_1 s_4803_3
        let s_4803_4: bool = ((s_4803_1) == (s_4803_3));
        // D s_4803_5: write-var gs#118242 <= s_4803_4
        fn_state.gs_118242 = s_4803_4;
        // N s_4803_6: jump b1563
        return block_1563(state, tracer, fn_state);
    }
    fn block_4804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4804_0: read-var coproc:u8
        let s_4804_0: u8 = fn_state.coproc;
        // D s_4804_1: cast zx s_4804_0 -> bv
        let s_4804_1: Bits = Bits::new(s_4804_0 as u128, 4u16);
        // C s_4804_2: const #15u : u8
        let s_4804_2: u8 = 15;
        // C s_4804_3: cast zx s_4804_2 -> bv
        let s_4804_3: Bits = Bits::new(s_4804_2 as u128, 4u16);
        // D s_4804_4: cmp-eq s_4804_1 s_4804_3
        let s_4804_4: bool = ((s_4804_1) == (s_4804_3));
        // D s_4804_5: write-var gs#118241 <= s_4804_4
        fn_state.gs_118241 = s_4804_4;
        // N s_4804_6: jump b1561
        return block_1561(state, tracer, fn_state);
    }
    fn block_4805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4805_0: read-var CRn:u8
        let s_4805_0: u8 = fn_state.CRn;
        // D s_4805_1: cast zx s_4805_0 -> bv
        let s_4805_1: Bits = Bits::new(s_4805_0 as u128, 4u16);
        // C s_4805_2: const #14u : u8
        let s_4805_2: u8 = 14;
        // C s_4805_3: cast zx s_4805_2 -> bv
        let s_4805_3: Bits = Bits::new(s_4805_2 as u128, 4u16);
        // D s_4805_4: cmp-eq s_4805_1 s_4805_3
        let s_4805_4: bool = ((s_4805_1) == (s_4805_3));
        // D s_4805_5: write-var gs#118240 <= s_4805_4
        fn_state.gs_118240 = s_4805_4;
        // N s_4805_6: jump b1559
        return block_1559(state, tracer, fn_state);
    }
    fn block_4806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4806_0: read-var el:u8
        let s_4806_0: u8 = fn_state.el;
        // D s_4806_1: read-var coproc:u8
        let s_4806_1: u8 = fn_state.coproc;
        // D s_4806_2: read-var opc1:u8
        let s_4806_2: u8 = fn_state.opc1;
        // D s_4806_3: read-var CRn:u8
        let s_4806_3: u8 = fn_state.CRn;
        // D s_4806_4: read-var opc2:u8
        let s_4806_4: u8 = fn_state.opc2;
        // D s_4806_5: read-var CRm:u8
        let s_4806_5: u8 = fn_state.CRm;
        // D s_4806_6: read-var t:i
        let s_4806_6: i128 = fn_state.t;
        // D s_4806_7: call PMEVCNTR_SysRegRead32_e863a7e57380d153(s_4806_0, s_4806_1, s_4806_2, s_4806_3, s_4806_4, s_4806_5, s_4806_6)
        let s_4806_7: () = PMEVCNTR_SysRegRead32_e863a7e57380d153(
            state,
            tracer,
            s_4806_0,
            s_4806_1,
            s_4806_2,
            s_4806_3,
            s_4806_4,
            s_4806_5,
            s_4806_6,
        );
        // N s_4806_8: return
        return;
    }
    fn block_4807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4807_0: read-var opc2:u8
        let s_4807_0: u8 = fn_state.opc2;
        // D s_4807_1: cast zx s_4807_0 -> bv
        let s_4807_1: Bits = Bits::new(s_4807_0 as u128, 3u16);
        // C s_4807_2: const #5u : u8
        let s_4807_2: u8 = 5;
        // C s_4807_3: cast zx s_4807_2 -> bv
        let s_4807_3: Bits = Bits::new(s_4807_2 as u128, 3u16);
        // D s_4807_4: cmp-eq s_4807_1 s_4807_3
        let s_4807_4: bool = ((s_4807_1) == (s_4807_3));
        // D s_4807_5: write-var gs#118239 <= s_4807_4
        fn_state.gs_118239 = s_4807_4;
        // N s_4807_6: jump b1556
        return block_1556(state, tracer, fn_state);
    }
    fn block_4808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4808_0: read-var opc1:u8
        let s_4808_0: u8 = fn_state.opc1;
        // D s_4808_1: cast zx s_4808_0 -> bv
        let s_4808_1: Bits = Bits::new(s_4808_0 as u128, 3u16);
        // C s_4808_2: const #0u : u8
        let s_4808_2: u8 = 0;
        // C s_4808_3: cast zx s_4808_2 -> bv
        let s_4808_3: Bits = Bits::new(s_4808_2 as u128, 3u16);
        // D s_4808_4: cmp-eq s_4808_1 s_4808_3
        let s_4808_4: bool = ((s_4808_1) == (s_4808_3));
        // D s_4808_5: write-var gs#118238 <= s_4808_4
        fn_state.gs_118238 = s_4808_4;
        // N s_4808_6: jump b1554
        return block_1554(state, tracer, fn_state);
    }
    fn block_4809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4809_0: read-var coproc:u8
        let s_4809_0: u8 = fn_state.coproc;
        // D s_4809_1: cast zx s_4809_0 -> bv
        let s_4809_1: Bits = Bits::new(s_4809_0 as u128, 4u16);
        // C s_4809_2: const #15u : u8
        let s_4809_2: u8 = 15;
        // C s_4809_3: cast zx s_4809_2 -> bv
        let s_4809_3: Bits = Bits::new(s_4809_2 as u128, 4u16);
        // D s_4809_4: cmp-eq s_4809_1 s_4809_3
        let s_4809_4: bool = ((s_4809_1) == (s_4809_3));
        // D s_4809_5: write-var gs#118237 <= s_4809_4
        fn_state.gs_118237 = s_4809_4;
        // N s_4809_6: jump b1552
        return block_1552(state, tracer, fn_state);
    }
    fn block_4810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4810_0: read-var CRn:u8
        let s_4810_0: u8 = fn_state.CRn;
        // D s_4810_1: cast zx s_4810_0 -> bv
        let s_4810_1: Bits = Bits::new(s_4810_0 as u128, 4u16);
        // C s_4810_2: const #14u : u8
        let s_4810_2: u8 = 14;
        // C s_4810_3: cast zx s_4810_2 -> bv
        let s_4810_3: Bits = Bits::new(s_4810_2 as u128, 4u16);
        // D s_4810_4: cmp-eq s_4810_1 s_4810_3
        let s_4810_4: bool = ((s_4810_1) == (s_4810_3));
        // D s_4810_5: write-var gs#118236 <= s_4810_4
        fn_state.gs_118236 = s_4810_4;
        // N s_4810_6: jump b1550
        return block_1550(state, tracer, fn_state);
    }
    fn block_4811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4811_0: read-var el:u8
        let s_4811_0: u8 = fn_state.el;
        // D s_4811_1: read-var coproc:u8
        let s_4811_1: u8 = fn_state.coproc;
        // D s_4811_2: read-var opc1:u8
        let s_4811_2: u8 = fn_state.opc1;
        // D s_4811_3: read-var CRn:u8
        let s_4811_3: u8 = fn_state.CRn;
        // D s_4811_4: read-var opc2:u8
        let s_4811_4: u8 = fn_state.opc2;
        // D s_4811_5: read-var CRm:u8
        let s_4811_5: u8 = fn_state.CRm;
        // D s_4811_6: read-var t:i
        let s_4811_6: i128 = fn_state.t;
        // D s_4811_7: call PMEVCNTR_SysRegRead32_7153d356d6a0fa3b(s_4811_0, s_4811_1, s_4811_2, s_4811_3, s_4811_4, s_4811_5, s_4811_6)
        let s_4811_7: () = PMEVCNTR_SysRegRead32_7153d356d6a0fa3b(
            state,
            tracer,
            s_4811_0,
            s_4811_1,
            s_4811_2,
            s_4811_3,
            s_4811_4,
            s_4811_5,
            s_4811_6,
        );
        // N s_4811_8: return
        return;
    }
    fn block_4812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4812_0: read-var opc2:u8
        let s_4812_0: u8 = fn_state.opc2;
        // D s_4812_1: cast zx s_4812_0 -> bv
        let s_4812_1: Bits = Bits::new(s_4812_0 as u128, 3u16);
        // C s_4812_2: const #6u : u8
        let s_4812_2: u8 = 6;
        // C s_4812_3: cast zx s_4812_2 -> bv
        let s_4812_3: Bits = Bits::new(s_4812_2 as u128, 3u16);
        // D s_4812_4: cmp-eq s_4812_1 s_4812_3
        let s_4812_4: bool = ((s_4812_1) == (s_4812_3));
        // D s_4812_5: write-var gs#118235 <= s_4812_4
        fn_state.gs_118235 = s_4812_4;
        // N s_4812_6: jump b1547
        return block_1547(state, tracer, fn_state);
    }
    fn block_4813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4813_0: read-var opc1:u8
        let s_4813_0: u8 = fn_state.opc1;
        // D s_4813_1: cast zx s_4813_0 -> bv
        let s_4813_1: Bits = Bits::new(s_4813_0 as u128, 3u16);
        // C s_4813_2: const #0u : u8
        let s_4813_2: u8 = 0;
        // C s_4813_3: cast zx s_4813_2 -> bv
        let s_4813_3: Bits = Bits::new(s_4813_2 as u128, 3u16);
        // D s_4813_4: cmp-eq s_4813_1 s_4813_3
        let s_4813_4: bool = ((s_4813_1) == (s_4813_3));
        // D s_4813_5: write-var gs#118234 <= s_4813_4
        fn_state.gs_118234 = s_4813_4;
        // N s_4813_6: jump b1545
        return block_1545(state, tracer, fn_state);
    }
    fn block_4814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4814_0: read-var coproc:u8
        let s_4814_0: u8 = fn_state.coproc;
        // D s_4814_1: cast zx s_4814_0 -> bv
        let s_4814_1: Bits = Bits::new(s_4814_0 as u128, 4u16);
        // C s_4814_2: const #15u : u8
        let s_4814_2: u8 = 15;
        // C s_4814_3: cast zx s_4814_2 -> bv
        let s_4814_3: Bits = Bits::new(s_4814_2 as u128, 4u16);
        // D s_4814_4: cmp-eq s_4814_1 s_4814_3
        let s_4814_4: bool = ((s_4814_1) == (s_4814_3));
        // D s_4814_5: write-var gs#118233 <= s_4814_4
        fn_state.gs_118233 = s_4814_4;
        // N s_4814_6: jump b1543
        return block_1543(state, tracer, fn_state);
    }
    fn block_4815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4815_0: read-var CRn:u8
        let s_4815_0: u8 = fn_state.CRn;
        // D s_4815_1: cast zx s_4815_0 -> bv
        let s_4815_1: Bits = Bits::new(s_4815_0 as u128, 4u16);
        // C s_4815_2: const #14u : u8
        let s_4815_2: u8 = 14;
        // C s_4815_3: cast zx s_4815_2 -> bv
        let s_4815_3: Bits = Bits::new(s_4815_2 as u128, 4u16);
        // D s_4815_4: cmp-eq s_4815_1 s_4815_3
        let s_4815_4: bool = ((s_4815_1) == (s_4815_3));
        // D s_4815_5: write-var gs#118232 <= s_4815_4
        fn_state.gs_118232 = s_4815_4;
        // N s_4815_6: jump b1541
        return block_1541(state, tracer, fn_state);
    }
    fn block_4816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4816_0: read-var el:u8
        let s_4816_0: u8 = fn_state.el;
        // D s_4816_1: read-var coproc:u8
        let s_4816_1: u8 = fn_state.coproc;
        // D s_4816_2: read-var opc1:u8
        let s_4816_2: u8 = fn_state.opc1;
        // D s_4816_3: read-var CRn:u8
        let s_4816_3: u8 = fn_state.CRn;
        // D s_4816_4: read-var opc2:u8
        let s_4816_4: u8 = fn_state.opc2;
        // D s_4816_5: read-var CRm:u8
        let s_4816_5: u8 = fn_state.CRm;
        // D s_4816_6: read-var t:i
        let s_4816_6: i128 = fn_state.t;
        // D s_4816_7: call PMEVCNTR_SysRegRead32_567f48afcd553f0b(s_4816_0, s_4816_1, s_4816_2, s_4816_3, s_4816_4, s_4816_5, s_4816_6)
        let s_4816_7: () = PMEVCNTR_SysRegRead32_567f48afcd553f0b(
            state,
            tracer,
            s_4816_0,
            s_4816_1,
            s_4816_2,
            s_4816_3,
            s_4816_4,
            s_4816_5,
            s_4816_6,
        );
        // N s_4816_8: return
        return;
    }
    fn block_4817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4817_0: read-var opc2:u8
        let s_4817_0: u8 = fn_state.opc2;
        // D s_4817_1: cast zx s_4817_0 -> bv
        let s_4817_1: Bits = Bits::new(s_4817_0 as u128, 3u16);
        // C s_4817_2: const #7u : u8
        let s_4817_2: u8 = 7;
        // C s_4817_3: cast zx s_4817_2 -> bv
        let s_4817_3: Bits = Bits::new(s_4817_2 as u128, 3u16);
        // D s_4817_4: cmp-eq s_4817_1 s_4817_3
        let s_4817_4: bool = ((s_4817_1) == (s_4817_3));
        // D s_4817_5: write-var gs#118231 <= s_4817_4
        fn_state.gs_118231 = s_4817_4;
        // N s_4817_6: jump b1538
        return block_1538(state, tracer, fn_state);
    }
    fn block_4818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4818_0: read-var opc1:u8
        let s_4818_0: u8 = fn_state.opc1;
        // D s_4818_1: cast zx s_4818_0 -> bv
        let s_4818_1: Bits = Bits::new(s_4818_0 as u128, 3u16);
        // C s_4818_2: const #0u : u8
        let s_4818_2: u8 = 0;
        // C s_4818_3: cast zx s_4818_2 -> bv
        let s_4818_3: Bits = Bits::new(s_4818_2 as u128, 3u16);
        // D s_4818_4: cmp-eq s_4818_1 s_4818_3
        let s_4818_4: bool = ((s_4818_1) == (s_4818_3));
        // D s_4818_5: write-var gs#118230 <= s_4818_4
        fn_state.gs_118230 = s_4818_4;
        // N s_4818_6: jump b1536
        return block_1536(state, tracer, fn_state);
    }
    fn block_4819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4819_0: read-var coproc:u8
        let s_4819_0: u8 = fn_state.coproc;
        // D s_4819_1: cast zx s_4819_0 -> bv
        let s_4819_1: Bits = Bits::new(s_4819_0 as u128, 4u16);
        // C s_4819_2: const #15u : u8
        let s_4819_2: u8 = 15;
        // C s_4819_3: cast zx s_4819_2 -> bv
        let s_4819_3: Bits = Bits::new(s_4819_2 as u128, 4u16);
        // D s_4819_4: cmp-eq s_4819_1 s_4819_3
        let s_4819_4: bool = ((s_4819_1) == (s_4819_3));
        // D s_4819_5: write-var gs#118229 <= s_4819_4
        fn_state.gs_118229 = s_4819_4;
        // N s_4819_6: jump b1534
        return block_1534(state, tracer, fn_state);
    }
    fn block_4820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4820_0: read-var CRn:u8
        let s_4820_0: u8 = fn_state.CRn;
        // D s_4820_1: cast zx s_4820_0 -> bv
        let s_4820_1: Bits = Bits::new(s_4820_0 as u128, 4u16);
        // C s_4820_2: const #14u : u8
        let s_4820_2: u8 = 14;
        // C s_4820_3: cast zx s_4820_2 -> bv
        let s_4820_3: Bits = Bits::new(s_4820_2 as u128, 4u16);
        // D s_4820_4: cmp-eq s_4820_1 s_4820_3
        let s_4820_4: bool = ((s_4820_1) == (s_4820_3));
        // D s_4820_5: write-var gs#118228 <= s_4820_4
        fn_state.gs_118228 = s_4820_4;
        // N s_4820_6: jump b1532
        return block_1532(state, tracer, fn_state);
    }
    fn block_4821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4821_0: read-var el:u8
        let s_4821_0: u8 = fn_state.el;
        // D s_4821_1: read-var coproc:u8
        let s_4821_1: u8 = fn_state.coproc;
        // D s_4821_2: read-var opc1:u8
        let s_4821_2: u8 = fn_state.opc1;
        // D s_4821_3: read-var CRn:u8
        let s_4821_3: u8 = fn_state.CRn;
        // D s_4821_4: read-var opc2:u8
        let s_4821_4: u8 = fn_state.opc2;
        // D s_4821_5: read-var CRm:u8
        let s_4821_5: u8 = fn_state.CRm;
        // D s_4821_6: read-var t:i
        let s_4821_6: i128 = fn_state.t;
        // D s_4821_7: call PMEVCNTR_SysRegRead32_7f423837889a1eb7(s_4821_0, s_4821_1, s_4821_2, s_4821_3, s_4821_4, s_4821_5, s_4821_6)
        let s_4821_7: () = PMEVCNTR_SysRegRead32_7f423837889a1eb7(
            state,
            tracer,
            s_4821_0,
            s_4821_1,
            s_4821_2,
            s_4821_3,
            s_4821_4,
            s_4821_5,
            s_4821_6,
        );
        // N s_4821_8: return
        return;
    }
    fn block_4822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4822_0: read-var opc2:u8
        let s_4822_0: u8 = fn_state.opc2;
        // D s_4822_1: cast zx s_4822_0 -> bv
        let s_4822_1: Bits = Bits::new(s_4822_0 as u128, 3u16);
        // C s_4822_2: const #0u : u8
        let s_4822_2: u8 = 0;
        // C s_4822_3: cast zx s_4822_2 -> bv
        let s_4822_3: Bits = Bits::new(s_4822_2 as u128, 3u16);
        // D s_4822_4: cmp-eq s_4822_1 s_4822_3
        let s_4822_4: bool = ((s_4822_1) == (s_4822_3));
        // D s_4822_5: write-var gs#118227 <= s_4822_4
        fn_state.gs_118227 = s_4822_4;
        // N s_4822_6: jump b1529
        return block_1529(state, tracer, fn_state);
    }
    fn block_4823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4823_0: read-var opc1:u8
        let s_4823_0: u8 = fn_state.opc1;
        // D s_4823_1: cast zx s_4823_0 -> bv
        let s_4823_1: Bits = Bits::new(s_4823_0 as u128, 3u16);
        // C s_4823_2: const #0u : u8
        let s_4823_2: u8 = 0;
        // C s_4823_3: cast zx s_4823_2 -> bv
        let s_4823_3: Bits = Bits::new(s_4823_2 as u128, 3u16);
        // D s_4823_4: cmp-eq s_4823_1 s_4823_3
        let s_4823_4: bool = ((s_4823_1) == (s_4823_3));
        // D s_4823_5: write-var gs#118226 <= s_4823_4
        fn_state.gs_118226 = s_4823_4;
        // N s_4823_6: jump b1527
        return block_1527(state, tracer, fn_state);
    }
    fn block_4824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4824_0: read-var coproc:u8
        let s_4824_0: u8 = fn_state.coproc;
        // D s_4824_1: cast zx s_4824_0 -> bv
        let s_4824_1: Bits = Bits::new(s_4824_0 as u128, 4u16);
        // C s_4824_2: const #15u : u8
        let s_4824_2: u8 = 15;
        // C s_4824_3: cast zx s_4824_2 -> bv
        let s_4824_3: Bits = Bits::new(s_4824_2 as u128, 4u16);
        // D s_4824_4: cmp-eq s_4824_1 s_4824_3
        let s_4824_4: bool = ((s_4824_1) == (s_4824_3));
        // D s_4824_5: write-var gs#118225 <= s_4824_4
        fn_state.gs_118225 = s_4824_4;
        // N s_4824_6: jump b1525
        return block_1525(state, tracer, fn_state);
    }
    fn block_4825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4825_0: read-var CRn:u8
        let s_4825_0: u8 = fn_state.CRn;
        // D s_4825_1: cast zx s_4825_0 -> bv
        let s_4825_1: Bits = Bits::new(s_4825_0 as u128, 4u16);
        // C s_4825_2: const #14u : u8
        let s_4825_2: u8 = 14;
        // C s_4825_3: cast zx s_4825_2 -> bv
        let s_4825_3: Bits = Bits::new(s_4825_2 as u128, 4u16);
        // D s_4825_4: cmp-eq s_4825_1 s_4825_3
        let s_4825_4: bool = ((s_4825_1) == (s_4825_3));
        // D s_4825_5: write-var gs#118224 <= s_4825_4
        fn_state.gs_118224 = s_4825_4;
        // N s_4825_6: jump b1523
        return block_1523(state, tracer, fn_state);
    }
    fn block_4826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4826_0: read-var el:u8
        let s_4826_0: u8 = fn_state.el;
        // D s_4826_1: read-var coproc:u8
        let s_4826_1: u8 = fn_state.coproc;
        // D s_4826_2: read-var opc1:u8
        let s_4826_2: u8 = fn_state.opc1;
        // D s_4826_3: read-var CRn:u8
        let s_4826_3: u8 = fn_state.CRn;
        // D s_4826_4: read-var opc2:u8
        let s_4826_4: u8 = fn_state.opc2;
        // D s_4826_5: read-var CRm:u8
        let s_4826_5: u8 = fn_state.CRm;
        // D s_4826_6: read-var t:i
        let s_4826_6: i128 = fn_state.t;
        // D s_4826_7: call PMEVCNTR_SysRegRead32_83a06d357cd23a85(s_4826_0, s_4826_1, s_4826_2, s_4826_3, s_4826_4, s_4826_5, s_4826_6)
        let s_4826_7: () = PMEVCNTR_SysRegRead32_83a06d357cd23a85(
            state,
            tracer,
            s_4826_0,
            s_4826_1,
            s_4826_2,
            s_4826_3,
            s_4826_4,
            s_4826_5,
            s_4826_6,
        );
        // N s_4826_8: return
        return;
    }
    fn block_4827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4827_0: read-var opc2:u8
        let s_4827_0: u8 = fn_state.opc2;
        // D s_4827_1: cast zx s_4827_0 -> bv
        let s_4827_1: Bits = Bits::new(s_4827_0 as u128, 3u16);
        // C s_4827_2: const #1u : u8
        let s_4827_2: u8 = 1;
        // C s_4827_3: cast zx s_4827_2 -> bv
        let s_4827_3: Bits = Bits::new(s_4827_2 as u128, 3u16);
        // D s_4827_4: cmp-eq s_4827_1 s_4827_3
        let s_4827_4: bool = ((s_4827_1) == (s_4827_3));
        // D s_4827_5: write-var gs#118223 <= s_4827_4
        fn_state.gs_118223 = s_4827_4;
        // N s_4827_6: jump b1520
        return block_1520(state, tracer, fn_state);
    }
    fn block_4828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4828_0: read-var opc1:u8
        let s_4828_0: u8 = fn_state.opc1;
        // D s_4828_1: cast zx s_4828_0 -> bv
        let s_4828_1: Bits = Bits::new(s_4828_0 as u128, 3u16);
        // C s_4828_2: const #0u : u8
        let s_4828_2: u8 = 0;
        // C s_4828_3: cast zx s_4828_2 -> bv
        let s_4828_3: Bits = Bits::new(s_4828_2 as u128, 3u16);
        // D s_4828_4: cmp-eq s_4828_1 s_4828_3
        let s_4828_4: bool = ((s_4828_1) == (s_4828_3));
        // D s_4828_5: write-var gs#118222 <= s_4828_4
        fn_state.gs_118222 = s_4828_4;
        // N s_4828_6: jump b1518
        return block_1518(state, tracer, fn_state);
    }
    fn block_4829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4829_0: read-var coproc:u8
        let s_4829_0: u8 = fn_state.coproc;
        // D s_4829_1: cast zx s_4829_0 -> bv
        let s_4829_1: Bits = Bits::new(s_4829_0 as u128, 4u16);
        // C s_4829_2: const #15u : u8
        let s_4829_2: u8 = 15;
        // C s_4829_3: cast zx s_4829_2 -> bv
        let s_4829_3: Bits = Bits::new(s_4829_2 as u128, 4u16);
        // D s_4829_4: cmp-eq s_4829_1 s_4829_3
        let s_4829_4: bool = ((s_4829_1) == (s_4829_3));
        // D s_4829_5: write-var gs#118221 <= s_4829_4
        fn_state.gs_118221 = s_4829_4;
        // N s_4829_6: jump b1516
        return block_1516(state, tracer, fn_state);
    }
    fn block_4830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4830_0: read-var CRn:u8
        let s_4830_0: u8 = fn_state.CRn;
        // D s_4830_1: cast zx s_4830_0 -> bv
        let s_4830_1: Bits = Bits::new(s_4830_0 as u128, 4u16);
        // C s_4830_2: const #14u : u8
        let s_4830_2: u8 = 14;
        // C s_4830_3: cast zx s_4830_2 -> bv
        let s_4830_3: Bits = Bits::new(s_4830_2 as u128, 4u16);
        // D s_4830_4: cmp-eq s_4830_1 s_4830_3
        let s_4830_4: bool = ((s_4830_1) == (s_4830_3));
        // D s_4830_5: write-var gs#118220 <= s_4830_4
        fn_state.gs_118220 = s_4830_4;
        // N s_4830_6: jump b1514
        return block_1514(state, tracer, fn_state);
    }
    fn block_4831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4831_0: read-var el:u8
        let s_4831_0: u8 = fn_state.el;
        // D s_4831_1: read-var coproc:u8
        let s_4831_1: u8 = fn_state.coproc;
        // D s_4831_2: read-var opc1:u8
        let s_4831_2: u8 = fn_state.opc1;
        // D s_4831_3: read-var CRn:u8
        let s_4831_3: u8 = fn_state.CRn;
        // D s_4831_4: read-var opc2:u8
        let s_4831_4: u8 = fn_state.opc2;
        // D s_4831_5: read-var CRm:u8
        let s_4831_5: u8 = fn_state.CRm;
        // D s_4831_6: read-var t:i
        let s_4831_6: i128 = fn_state.t;
        // D s_4831_7: call PMEVCNTR_SysRegRead32_a0e4f3bc8390131d(s_4831_0, s_4831_1, s_4831_2, s_4831_3, s_4831_4, s_4831_5, s_4831_6)
        let s_4831_7: () = PMEVCNTR_SysRegRead32_a0e4f3bc8390131d(
            state,
            tracer,
            s_4831_0,
            s_4831_1,
            s_4831_2,
            s_4831_3,
            s_4831_4,
            s_4831_5,
            s_4831_6,
        );
        // N s_4831_8: return
        return;
    }
    fn block_4832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4832_0: read-var opc2:u8
        let s_4832_0: u8 = fn_state.opc2;
        // D s_4832_1: cast zx s_4832_0 -> bv
        let s_4832_1: Bits = Bits::new(s_4832_0 as u128, 3u16);
        // C s_4832_2: const #2u : u8
        let s_4832_2: u8 = 2;
        // C s_4832_3: cast zx s_4832_2 -> bv
        let s_4832_3: Bits = Bits::new(s_4832_2 as u128, 3u16);
        // D s_4832_4: cmp-eq s_4832_1 s_4832_3
        let s_4832_4: bool = ((s_4832_1) == (s_4832_3));
        // D s_4832_5: write-var gs#118219 <= s_4832_4
        fn_state.gs_118219 = s_4832_4;
        // N s_4832_6: jump b1511
        return block_1511(state, tracer, fn_state);
    }
    fn block_4833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4833_0: read-var opc1:u8
        let s_4833_0: u8 = fn_state.opc1;
        // D s_4833_1: cast zx s_4833_0 -> bv
        let s_4833_1: Bits = Bits::new(s_4833_0 as u128, 3u16);
        // C s_4833_2: const #0u : u8
        let s_4833_2: u8 = 0;
        // C s_4833_3: cast zx s_4833_2 -> bv
        let s_4833_3: Bits = Bits::new(s_4833_2 as u128, 3u16);
        // D s_4833_4: cmp-eq s_4833_1 s_4833_3
        let s_4833_4: bool = ((s_4833_1) == (s_4833_3));
        // D s_4833_5: write-var gs#118218 <= s_4833_4
        fn_state.gs_118218 = s_4833_4;
        // N s_4833_6: jump b1509
        return block_1509(state, tracer, fn_state);
    }
    fn block_4834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4834_0: read-var coproc:u8
        let s_4834_0: u8 = fn_state.coproc;
        // D s_4834_1: cast zx s_4834_0 -> bv
        let s_4834_1: Bits = Bits::new(s_4834_0 as u128, 4u16);
        // C s_4834_2: const #15u : u8
        let s_4834_2: u8 = 15;
        // C s_4834_3: cast zx s_4834_2 -> bv
        let s_4834_3: Bits = Bits::new(s_4834_2 as u128, 4u16);
        // D s_4834_4: cmp-eq s_4834_1 s_4834_3
        let s_4834_4: bool = ((s_4834_1) == (s_4834_3));
        // D s_4834_5: write-var gs#118217 <= s_4834_4
        fn_state.gs_118217 = s_4834_4;
        // N s_4834_6: jump b1507
        return block_1507(state, tracer, fn_state);
    }
    fn block_4835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4835_0: read-var CRn:u8
        let s_4835_0: u8 = fn_state.CRn;
        // D s_4835_1: cast zx s_4835_0 -> bv
        let s_4835_1: Bits = Bits::new(s_4835_0 as u128, 4u16);
        // C s_4835_2: const #14u : u8
        let s_4835_2: u8 = 14;
        // C s_4835_3: cast zx s_4835_2 -> bv
        let s_4835_3: Bits = Bits::new(s_4835_2 as u128, 4u16);
        // D s_4835_4: cmp-eq s_4835_1 s_4835_3
        let s_4835_4: bool = ((s_4835_1) == (s_4835_3));
        // D s_4835_5: write-var gs#118216 <= s_4835_4
        fn_state.gs_118216 = s_4835_4;
        // N s_4835_6: jump b1505
        return block_1505(state, tracer, fn_state);
    }
    fn block_4836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4836_0: read-var el:u8
        let s_4836_0: u8 = fn_state.el;
        // D s_4836_1: read-var coproc:u8
        let s_4836_1: u8 = fn_state.coproc;
        // D s_4836_2: read-var opc1:u8
        let s_4836_2: u8 = fn_state.opc1;
        // D s_4836_3: read-var CRn:u8
        let s_4836_3: u8 = fn_state.CRn;
        // D s_4836_4: read-var opc2:u8
        let s_4836_4: u8 = fn_state.opc2;
        // D s_4836_5: read-var CRm:u8
        let s_4836_5: u8 = fn_state.CRm;
        // D s_4836_6: read-var t:i
        let s_4836_6: i128 = fn_state.t;
        // D s_4836_7: call PMEVCNTR_SysRegRead32_029a264e693ebe08(s_4836_0, s_4836_1, s_4836_2, s_4836_3, s_4836_4, s_4836_5, s_4836_6)
        let s_4836_7: () = PMEVCNTR_SysRegRead32_029a264e693ebe08(
            state,
            tracer,
            s_4836_0,
            s_4836_1,
            s_4836_2,
            s_4836_3,
            s_4836_4,
            s_4836_5,
            s_4836_6,
        );
        // N s_4836_8: return
        return;
    }
    fn block_4837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4837_0: read-var opc2:u8
        let s_4837_0: u8 = fn_state.opc2;
        // D s_4837_1: cast zx s_4837_0 -> bv
        let s_4837_1: Bits = Bits::new(s_4837_0 as u128, 3u16);
        // C s_4837_2: const #3u : u8
        let s_4837_2: u8 = 3;
        // C s_4837_3: cast zx s_4837_2 -> bv
        let s_4837_3: Bits = Bits::new(s_4837_2 as u128, 3u16);
        // D s_4837_4: cmp-eq s_4837_1 s_4837_3
        let s_4837_4: bool = ((s_4837_1) == (s_4837_3));
        // D s_4837_5: write-var gs#118215 <= s_4837_4
        fn_state.gs_118215 = s_4837_4;
        // N s_4837_6: jump b1502
        return block_1502(state, tracer, fn_state);
    }
    fn block_4838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4838_0: read-var opc1:u8
        let s_4838_0: u8 = fn_state.opc1;
        // D s_4838_1: cast zx s_4838_0 -> bv
        let s_4838_1: Bits = Bits::new(s_4838_0 as u128, 3u16);
        // C s_4838_2: const #0u : u8
        let s_4838_2: u8 = 0;
        // C s_4838_3: cast zx s_4838_2 -> bv
        let s_4838_3: Bits = Bits::new(s_4838_2 as u128, 3u16);
        // D s_4838_4: cmp-eq s_4838_1 s_4838_3
        let s_4838_4: bool = ((s_4838_1) == (s_4838_3));
        // D s_4838_5: write-var gs#118214 <= s_4838_4
        fn_state.gs_118214 = s_4838_4;
        // N s_4838_6: jump b1500
        return block_1500(state, tracer, fn_state);
    }
    fn block_4839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4839_0: read-var coproc:u8
        let s_4839_0: u8 = fn_state.coproc;
        // D s_4839_1: cast zx s_4839_0 -> bv
        let s_4839_1: Bits = Bits::new(s_4839_0 as u128, 4u16);
        // C s_4839_2: const #15u : u8
        let s_4839_2: u8 = 15;
        // C s_4839_3: cast zx s_4839_2 -> bv
        let s_4839_3: Bits = Bits::new(s_4839_2 as u128, 4u16);
        // D s_4839_4: cmp-eq s_4839_1 s_4839_3
        let s_4839_4: bool = ((s_4839_1) == (s_4839_3));
        // D s_4839_5: write-var gs#118213 <= s_4839_4
        fn_state.gs_118213 = s_4839_4;
        // N s_4839_6: jump b1498
        return block_1498(state, tracer, fn_state);
    }
    fn block_4840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4840_0: read-var CRn:u8
        let s_4840_0: u8 = fn_state.CRn;
        // D s_4840_1: cast zx s_4840_0 -> bv
        let s_4840_1: Bits = Bits::new(s_4840_0 as u128, 4u16);
        // C s_4840_2: const #14u : u8
        let s_4840_2: u8 = 14;
        // C s_4840_3: cast zx s_4840_2 -> bv
        let s_4840_3: Bits = Bits::new(s_4840_2 as u128, 4u16);
        // D s_4840_4: cmp-eq s_4840_1 s_4840_3
        let s_4840_4: bool = ((s_4840_1) == (s_4840_3));
        // D s_4840_5: write-var gs#118212 <= s_4840_4
        fn_state.gs_118212 = s_4840_4;
        // N s_4840_6: jump b1496
        return block_1496(state, tracer, fn_state);
    }
    fn block_4841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4841_0: read-var el:u8
        let s_4841_0: u8 = fn_state.el;
        // D s_4841_1: read-var coproc:u8
        let s_4841_1: u8 = fn_state.coproc;
        // D s_4841_2: read-var opc1:u8
        let s_4841_2: u8 = fn_state.opc1;
        // D s_4841_3: read-var CRn:u8
        let s_4841_3: u8 = fn_state.CRn;
        // D s_4841_4: read-var opc2:u8
        let s_4841_4: u8 = fn_state.opc2;
        // D s_4841_5: read-var CRm:u8
        let s_4841_5: u8 = fn_state.CRm;
        // D s_4841_6: read-var t:i
        let s_4841_6: i128 = fn_state.t;
        // D s_4841_7: call PMEVCNTR_SysRegRead32_1774c818fab12807(s_4841_0, s_4841_1, s_4841_2, s_4841_3, s_4841_4, s_4841_5, s_4841_6)
        let s_4841_7: () = PMEVCNTR_SysRegRead32_1774c818fab12807(
            state,
            tracer,
            s_4841_0,
            s_4841_1,
            s_4841_2,
            s_4841_3,
            s_4841_4,
            s_4841_5,
            s_4841_6,
        );
        // N s_4841_8: return
        return;
    }
    fn block_4842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4842_0: read-var opc2:u8
        let s_4842_0: u8 = fn_state.opc2;
        // D s_4842_1: cast zx s_4842_0 -> bv
        let s_4842_1: Bits = Bits::new(s_4842_0 as u128, 3u16);
        // C s_4842_2: const #4u : u8
        let s_4842_2: u8 = 4;
        // C s_4842_3: cast zx s_4842_2 -> bv
        let s_4842_3: Bits = Bits::new(s_4842_2 as u128, 3u16);
        // D s_4842_4: cmp-eq s_4842_1 s_4842_3
        let s_4842_4: bool = ((s_4842_1) == (s_4842_3));
        // D s_4842_5: write-var gs#118211 <= s_4842_4
        fn_state.gs_118211 = s_4842_4;
        // N s_4842_6: jump b1493
        return block_1493(state, tracer, fn_state);
    }
    fn block_4843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4843_0: read-var opc1:u8
        let s_4843_0: u8 = fn_state.opc1;
        // D s_4843_1: cast zx s_4843_0 -> bv
        let s_4843_1: Bits = Bits::new(s_4843_0 as u128, 3u16);
        // C s_4843_2: const #0u : u8
        let s_4843_2: u8 = 0;
        // C s_4843_3: cast zx s_4843_2 -> bv
        let s_4843_3: Bits = Bits::new(s_4843_2 as u128, 3u16);
        // D s_4843_4: cmp-eq s_4843_1 s_4843_3
        let s_4843_4: bool = ((s_4843_1) == (s_4843_3));
        // D s_4843_5: write-var gs#118210 <= s_4843_4
        fn_state.gs_118210 = s_4843_4;
        // N s_4843_6: jump b1491
        return block_1491(state, tracer, fn_state);
    }
    fn block_4844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4844_0: read-var coproc:u8
        let s_4844_0: u8 = fn_state.coproc;
        // D s_4844_1: cast zx s_4844_0 -> bv
        let s_4844_1: Bits = Bits::new(s_4844_0 as u128, 4u16);
        // C s_4844_2: const #15u : u8
        let s_4844_2: u8 = 15;
        // C s_4844_3: cast zx s_4844_2 -> bv
        let s_4844_3: Bits = Bits::new(s_4844_2 as u128, 4u16);
        // D s_4844_4: cmp-eq s_4844_1 s_4844_3
        let s_4844_4: bool = ((s_4844_1) == (s_4844_3));
        // D s_4844_5: write-var gs#118209 <= s_4844_4
        fn_state.gs_118209 = s_4844_4;
        // N s_4844_6: jump b1489
        return block_1489(state, tracer, fn_state);
    }
    fn block_4845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4845_0: read-var CRn:u8
        let s_4845_0: u8 = fn_state.CRn;
        // D s_4845_1: cast zx s_4845_0 -> bv
        let s_4845_1: Bits = Bits::new(s_4845_0 as u128, 4u16);
        // C s_4845_2: const #14u : u8
        let s_4845_2: u8 = 14;
        // C s_4845_3: cast zx s_4845_2 -> bv
        let s_4845_3: Bits = Bits::new(s_4845_2 as u128, 4u16);
        // D s_4845_4: cmp-eq s_4845_1 s_4845_3
        let s_4845_4: bool = ((s_4845_1) == (s_4845_3));
        // D s_4845_5: write-var gs#118208 <= s_4845_4
        fn_state.gs_118208 = s_4845_4;
        // N s_4845_6: jump b1487
        return block_1487(state, tracer, fn_state);
    }
    fn block_4846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4846_0: read-var el:u8
        let s_4846_0: u8 = fn_state.el;
        // D s_4846_1: read-var coproc:u8
        let s_4846_1: u8 = fn_state.coproc;
        // D s_4846_2: read-var opc1:u8
        let s_4846_2: u8 = fn_state.opc1;
        // D s_4846_3: read-var CRn:u8
        let s_4846_3: u8 = fn_state.CRn;
        // D s_4846_4: read-var opc2:u8
        let s_4846_4: u8 = fn_state.opc2;
        // D s_4846_5: read-var CRm:u8
        let s_4846_5: u8 = fn_state.CRm;
        // D s_4846_6: read-var t:i
        let s_4846_6: i128 = fn_state.t;
        // D s_4846_7: call PMEVCNTR_SysRegRead32_63ff5bc2709c8d46(s_4846_0, s_4846_1, s_4846_2, s_4846_3, s_4846_4, s_4846_5, s_4846_6)
        let s_4846_7: () = PMEVCNTR_SysRegRead32_63ff5bc2709c8d46(
            state,
            tracer,
            s_4846_0,
            s_4846_1,
            s_4846_2,
            s_4846_3,
            s_4846_4,
            s_4846_5,
            s_4846_6,
        );
        // N s_4846_8: return
        return;
    }
    fn block_4847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4847_0: read-var opc2:u8
        let s_4847_0: u8 = fn_state.opc2;
        // D s_4847_1: cast zx s_4847_0 -> bv
        let s_4847_1: Bits = Bits::new(s_4847_0 as u128, 3u16);
        // C s_4847_2: const #5u : u8
        let s_4847_2: u8 = 5;
        // C s_4847_3: cast zx s_4847_2 -> bv
        let s_4847_3: Bits = Bits::new(s_4847_2 as u128, 3u16);
        // D s_4847_4: cmp-eq s_4847_1 s_4847_3
        let s_4847_4: bool = ((s_4847_1) == (s_4847_3));
        // D s_4847_5: write-var gs#118207 <= s_4847_4
        fn_state.gs_118207 = s_4847_4;
        // N s_4847_6: jump b1484
        return block_1484(state, tracer, fn_state);
    }
    fn block_4848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4848_0: read-var opc1:u8
        let s_4848_0: u8 = fn_state.opc1;
        // D s_4848_1: cast zx s_4848_0 -> bv
        let s_4848_1: Bits = Bits::new(s_4848_0 as u128, 3u16);
        // C s_4848_2: const #0u : u8
        let s_4848_2: u8 = 0;
        // C s_4848_3: cast zx s_4848_2 -> bv
        let s_4848_3: Bits = Bits::new(s_4848_2 as u128, 3u16);
        // D s_4848_4: cmp-eq s_4848_1 s_4848_3
        let s_4848_4: bool = ((s_4848_1) == (s_4848_3));
        // D s_4848_5: write-var gs#118206 <= s_4848_4
        fn_state.gs_118206 = s_4848_4;
        // N s_4848_6: jump b1482
        return block_1482(state, tracer, fn_state);
    }
    fn block_4849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4849_0: read-var coproc:u8
        let s_4849_0: u8 = fn_state.coproc;
        // D s_4849_1: cast zx s_4849_0 -> bv
        let s_4849_1: Bits = Bits::new(s_4849_0 as u128, 4u16);
        // C s_4849_2: const #15u : u8
        let s_4849_2: u8 = 15;
        // C s_4849_3: cast zx s_4849_2 -> bv
        let s_4849_3: Bits = Bits::new(s_4849_2 as u128, 4u16);
        // D s_4849_4: cmp-eq s_4849_1 s_4849_3
        let s_4849_4: bool = ((s_4849_1) == (s_4849_3));
        // D s_4849_5: write-var gs#118205 <= s_4849_4
        fn_state.gs_118205 = s_4849_4;
        // N s_4849_6: jump b1480
        return block_1480(state, tracer, fn_state);
    }
    fn block_4850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4850_0: read-var CRn:u8
        let s_4850_0: u8 = fn_state.CRn;
        // D s_4850_1: cast zx s_4850_0 -> bv
        let s_4850_1: Bits = Bits::new(s_4850_0 as u128, 4u16);
        // C s_4850_2: const #14u : u8
        let s_4850_2: u8 = 14;
        // C s_4850_3: cast zx s_4850_2 -> bv
        let s_4850_3: Bits = Bits::new(s_4850_2 as u128, 4u16);
        // D s_4850_4: cmp-eq s_4850_1 s_4850_3
        let s_4850_4: bool = ((s_4850_1) == (s_4850_3));
        // D s_4850_5: write-var gs#118204 <= s_4850_4
        fn_state.gs_118204 = s_4850_4;
        // N s_4850_6: jump b1478
        return block_1478(state, tracer, fn_state);
    }
    fn block_4851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4851_0: read-var el:u8
        let s_4851_0: u8 = fn_state.el;
        // D s_4851_1: read-var coproc:u8
        let s_4851_1: u8 = fn_state.coproc;
        // D s_4851_2: read-var opc1:u8
        let s_4851_2: u8 = fn_state.opc1;
        // D s_4851_3: read-var CRn:u8
        let s_4851_3: u8 = fn_state.CRn;
        // D s_4851_4: read-var opc2:u8
        let s_4851_4: u8 = fn_state.opc2;
        // D s_4851_5: read-var CRm:u8
        let s_4851_5: u8 = fn_state.CRm;
        // D s_4851_6: read-var t:i
        let s_4851_6: i128 = fn_state.t;
        // D s_4851_7: call PMEVCNTR_SysRegRead32_3cff703cf4dc4c8d(s_4851_0, s_4851_1, s_4851_2, s_4851_3, s_4851_4, s_4851_5, s_4851_6)
        let s_4851_7: () = PMEVCNTR_SysRegRead32_3cff703cf4dc4c8d(
            state,
            tracer,
            s_4851_0,
            s_4851_1,
            s_4851_2,
            s_4851_3,
            s_4851_4,
            s_4851_5,
            s_4851_6,
        );
        // N s_4851_8: return
        return;
    }
    fn block_4852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4852_0: read-var opc2:u8
        let s_4852_0: u8 = fn_state.opc2;
        // D s_4852_1: cast zx s_4852_0 -> bv
        let s_4852_1: Bits = Bits::new(s_4852_0 as u128, 3u16);
        // C s_4852_2: const #6u : u8
        let s_4852_2: u8 = 6;
        // C s_4852_3: cast zx s_4852_2 -> bv
        let s_4852_3: Bits = Bits::new(s_4852_2 as u128, 3u16);
        // D s_4852_4: cmp-eq s_4852_1 s_4852_3
        let s_4852_4: bool = ((s_4852_1) == (s_4852_3));
        // D s_4852_5: write-var gs#118203 <= s_4852_4
        fn_state.gs_118203 = s_4852_4;
        // N s_4852_6: jump b1475
        return block_1475(state, tracer, fn_state);
    }
    fn block_4853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4853_0: read-var opc1:u8
        let s_4853_0: u8 = fn_state.opc1;
        // D s_4853_1: cast zx s_4853_0 -> bv
        let s_4853_1: Bits = Bits::new(s_4853_0 as u128, 3u16);
        // C s_4853_2: const #0u : u8
        let s_4853_2: u8 = 0;
        // C s_4853_3: cast zx s_4853_2 -> bv
        let s_4853_3: Bits = Bits::new(s_4853_2 as u128, 3u16);
        // D s_4853_4: cmp-eq s_4853_1 s_4853_3
        let s_4853_4: bool = ((s_4853_1) == (s_4853_3));
        // D s_4853_5: write-var gs#118202 <= s_4853_4
        fn_state.gs_118202 = s_4853_4;
        // N s_4853_6: jump b1473
        return block_1473(state, tracer, fn_state);
    }
    fn block_4854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4854_0: read-var coproc:u8
        let s_4854_0: u8 = fn_state.coproc;
        // D s_4854_1: cast zx s_4854_0 -> bv
        let s_4854_1: Bits = Bits::new(s_4854_0 as u128, 4u16);
        // C s_4854_2: const #15u : u8
        let s_4854_2: u8 = 15;
        // C s_4854_3: cast zx s_4854_2 -> bv
        let s_4854_3: Bits = Bits::new(s_4854_2 as u128, 4u16);
        // D s_4854_4: cmp-eq s_4854_1 s_4854_3
        let s_4854_4: bool = ((s_4854_1) == (s_4854_3));
        // D s_4854_5: write-var gs#118201 <= s_4854_4
        fn_state.gs_118201 = s_4854_4;
        // N s_4854_6: jump b1471
        return block_1471(state, tracer, fn_state);
    }
    fn block_4855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4855_0: read-var CRn:u8
        let s_4855_0: u8 = fn_state.CRn;
        // D s_4855_1: cast zx s_4855_0 -> bv
        let s_4855_1: Bits = Bits::new(s_4855_0 as u128, 4u16);
        // C s_4855_2: const #14u : u8
        let s_4855_2: u8 = 14;
        // C s_4855_3: cast zx s_4855_2 -> bv
        let s_4855_3: Bits = Bits::new(s_4855_2 as u128, 4u16);
        // D s_4855_4: cmp-eq s_4855_1 s_4855_3
        let s_4855_4: bool = ((s_4855_1) == (s_4855_3));
        // D s_4855_5: write-var gs#118200 <= s_4855_4
        fn_state.gs_118200 = s_4855_4;
        // N s_4855_6: jump b1469
        return block_1469(state, tracer, fn_state);
    }
    fn block_4856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4856_0: read-var el:u8
        let s_4856_0: u8 = fn_state.el;
        // D s_4856_1: read-var coproc:u8
        let s_4856_1: u8 = fn_state.coproc;
        // D s_4856_2: read-var opc1:u8
        let s_4856_2: u8 = fn_state.opc1;
        // D s_4856_3: read-var CRn:u8
        let s_4856_3: u8 = fn_state.CRn;
        // D s_4856_4: read-var opc2:u8
        let s_4856_4: u8 = fn_state.opc2;
        // D s_4856_5: read-var CRm:u8
        let s_4856_5: u8 = fn_state.CRm;
        // D s_4856_6: read-var t:i
        let s_4856_6: i128 = fn_state.t;
        // D s_4856_7: call PMEVCNTR_SysRegRead32_acccf1406f935146(s_4856_0, s_4856_1, s_4856_2, s_4856_3, s_4856_4, s_4856_5, s_4856_6)
        let s_4856_7: () = PMEVCNTR_SysRegRead32_acccf1406f935146(
            state,
            tracer,
            s_4856_0,
            s_4856_1,
            s_4856_2,
            s_4856_3,
            s_4856_4,
            s_4856_5,
            s_4856_6,
        );
        // N s_4856_8: return
        return;
    }
    fn block_4857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4857_0: read-var opc2:u8
        let s_4857_0: u8 = fn_state.opc2;
        // D s_4857_1: cast zx s_4857_0 -> bv
        let s_4857_1: Bits = Bits::new(s_4857_0 as u128, 3u16);
        // C s_4857_2: const #7u : u8
        let s_4857_2: u8 = 7;
        // C s_4857_3: cast zx s_4857_2 -> bv
        let s_4857_3: Bits = Bits::new(s_4857_2 as u128, 3u16);
        // D s_4857_4: cmp-eq s_4857_1 s_4857_3
        let s_4857_4: bool = ((s_4857_1) == (s_4857_3));
        // D s_4857_5: write-var gs#118199 <= s_4857_4
        fn_state.gs_118199 = s_4857_4;
        // N s_4857_6: jump b1466
        return block_1466(state, tracer, fn_state);
    }
    fn block_4858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4858_0: read-var opc1:u8
        let s_4858_0: u8 = fn_state.opc1;
        // D s_4858_1: cast zx s_4858_0 -> bv
        let s_4858_1: Bits = Bits::new(s_4858_0 as u128, 3u16);
        // C s_4858_2: const #0u : u8
        let s_4858_2: u8 = 0;
        // C s_4858_3: cast zx s_4858_2 -> bv
        let s_4858_3: Bits = Bits::new(s_4858_2 as u128, 3u16);
        // D s_4858_4: cmp-eq s_4858_1 s_4858_3
        let s_4858_4: bool = ((s_4858_1) == (s_4858_3));
        // D s_4858_5: write-var gs#118198 <= s_4858_4
        fn_state.gs_118198 = s_4858_4;
        // N s_4858_6: jump b1464
        return block_1464(state, tracer, fn_state);
    }
    fn block_4859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4859_0: read-var coproc:u8
        let s_4859_0: u8 = fn_state.coproc;
        // D s_4859_1: cast zx s_4859_0 -> bv
        let s_4859_1: Bits = Bits::new(s_4859_0 as u128, 4u16);
        // C s_4859_2: const #15u : u8
        let s_4859_2: u8 = 15;
        // C s_4859_3: cast zx s_4859_2 -> bv
        let s_4859_3: Bits = Bits::new(s_4859_2 as u128, 4u16);
        // D s_4859_4: cmp-eq s_4859_1 s_4859_3
        let s_4859_4: bool = ((s_4859_1) == (s_4859_3));
        // D s_4859_5: write-var gs#118197 <= s_4859_4
        fn_state.gs_118197 = s_4859_4;
        // N s_4859_6: jump b1462
        return block_1462(state, tracer, fn_state);
    }
    fn block_4860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4860_0: read-var CRn:u8
        let s_4860_0: u8 = fn_state.CRn;
        // D s_4860_1: cast zx s_4860_0 -> bv
        let s_4860_1: Bits = Bits::new(s_4860_0 as u128, 4u16);
        // C s_4860_2: const #14u : u8
        let s_4860_2: u8 = 14;
        // C s_4860_3: cast zx s_4860_2 -> bv
        let s_4860_3: Bits = Bits::new(s_4860_2 as u128, 4u16);
        // D s_4860_4: cmp-eq s_4860_1 s_4860_3
        let s_4860_4: bool = ((s_4860_1) == (s_4860_3));
        // D s_4860_5: write-var gs#118196 <= s_4860_4
        fn_state.gs_118196 = s_4860_4;
        // N s_4860_6: jump b1460
        return block_1460(state, tracer, fn_state);
    }
    fn block_4861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4861_0: read-var el:u8
        let s_4861_0: u8 = fn_state.el;
        // D s_4861_1: read-var coproc:u8
        let s_4861_1: u8 = fn_state.coproc;
        // D s_4861_2: read-var opc1:u8
        let s_4861_2: u8 = fn_state.opc1;
        // D s_4861_3: read-var CRn:u8
        let s_4861_3: u8 = fn_state.CRn;
        // D s_4861_4: read-var opc2:u8
        let s_4861_4: u8 = fn_state.opc2;
        // D s_4861_5: read-var CRm:u8
        let s_4861_5: u8 = fn_state.CRm;
        // D s_4861_6: read-var t:i
        let s_4861_6: i128 = fn_state.t;
        // D s_4861_7: call PMEVCNTR_SysRegRead32_707b33e723e1c43a(s_4861_0, s_4861_1, s_4861_2, s_4861_3, s_4861_4, s_4861_5, s_4861_6)
        let s_4861_7: () = PMEVCNTR_SysRegRead32_707b33e723e1c43a(
            state,
            tracer,
            s_4861_0,
            s_4861_1,
            s_4861_2,
            s_4861_3,
            s_4861_4,
            s_4861_5,
            s_4861_6,
        );
        // N s_4861_8: return
        return;
    }
    fn block_4862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4862_0: read-var opc2:u8
        let s_4862_0: u8 = fn_state.opc2;
        // D s_4862_1: cast zx s_4862_0 -> bv
        let s_4862_1: Bits = Bits::new(s_4862_0 as u128, 3u16);
        // C s_4862_2: const #0u : u8
        let s_4862_2: u8 = 0;
        // C s_4862_3: cast zx s_4862_2 -> bv
        let s_4862_3: Bits = Bits::new(s_4862_2 as u128, 3u16);
        // D s_4862_4: cmp-eq s_4862_1 s_4862_3
        let s_4862_4: bool = ((s_4862_1) == (s_4862_3));
        // D s_4862_5: write-var gs#118195 <= s_4862_4
        fn_state.gs_118195 = s_4862_4;
        // N s_4862_6: jump b1457
        return block_1457(state, tracer, fn_state);
    }
    fn block_4863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4863_0: read-var opc1:u8
        let s_4863_0: u8 = fn_state.opc1;
        // D s_4863_1: cast zx s_4863_0 -> bv
        let s_4863_1: Bits = Bits::new(s_4863_0 as u128, 3u16);
        // C s_4863_2: const #0u : u8
        let s_4863_2: u8 = 0;
        // C s_4863_3: cast zx s_4863_2 -> bv
        let s_4863_3: Bits = Bits::new(s_4863_2 as u128, 3u16);
        // D s_4863_4: cmp-eq s_4863_1 s_4863_3
        let s_4863_4: bool = ((s_4863_1) == (s_4863_3));
        // D s_4863_5: write-var gs#118194 <= s_4863_4
        fn_state.gs_118194 = s_4863_4;
        // N s_4863_6: jump b1455
        return block_1455(state, tracer, fn_state);
    }
    fn block_4864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4864_0: read-var coproc:u8
        let s_4864_0: u8 = fn_state.coproc;
        // D s_4864_1: cast zx s_4864_0 -> bv
        let s_4864_1: Bits = Bits::new(s_4864_0 as u128, 4u16);
        // C s_4864_2: const #15u : u8
        let s_4864_2: u8 = 15;
        // C s_4864_3: cast zx s_4864_2 -> bv
        let s_4864_3: Bits = Bits::new(s_4864_2 as u128, 4u16);
        // D s_4864_4: cmp-eq s_4864_1 s_4864_3
        let s_4864_4: bool = ((s_4864_1) == (s_4864_3));
        // D s_4864_5: write-var gs#118193 <= s_4864_4
        fn_state.gs_118193 = s_4864_4;
        // N s_4864_6: jump b1453
        return block_1453(state, tracer, fn_state);
    }
    fn block_4865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4865_0: read-var CRn:u8
        let s_4865_0: u8 = fn_state.CRn;
        // D s_4865_1: cast zx s_4865_0 -> bv
        let s_4865_1: Bits = Bits::new(s_4865_0 as u128, 4u16);
        // C s_4865_2: const #14u : u8
        let s_4865_2: u8 = 14;
        // C s_4865_3: cast zx s_4865_2 -> bv
        let s_4865_3: Bits = Bits::new(s_4865_2 as u128, 4u16);
        // D s_4865_4: cmp-eq s_4865_1 s_4865_3
        let s_4865_4: bool = ((s_4865_1) == (s_4865_3));
        // D s_4865_5: write-var gs#118192 <= s_4865_4
        fn_state.gs_118192 = s_4865_4;
        // N s_4865_6: jump b1451
        return block_1451(state, tracer, fn_state);
    }
    fn block_4866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4866_0: read-var el:u8
        let s_4866_0: u8 = fn_state.el;
        // D s_4866_1: read-var coproc:u8
        let s_4866_1: u8 = fn_state.coproc;
        // D s_4866_2: read-var opc1:u8
        let s_4866_2: u8 = fn_state.opc1;
        // D s_4866_3: read-var CRn:u8
        let s_4866_3: u8 = fn_state.CRn;
        // D s_4866_4: read-var opc2:u8
        let s_4866_4: u8 = fn_state.opc2;
        // D s_4866_5: read-var CRm:u8
        let s_4866_5: u8 = fn_state.CRm;
        // D s_4866_6: read-var t:i
        let s_4866_6: i128 = fn_state.t;
        // D s_4866_7: call PMEVCNTR_SysRegRead32_f577cb392ba87833(s_4866_0, s_4866_1, s_4866_2, s_4866_3, s_4866_4, s_4866_5, s_4866_6)
        let s_4866_7: () = PMEVCNTR_SysRegRead32_f577cb392ba87833(
            state,
            tracer,
            s_4866_0,
            s_4866_1,
            s_4866_2,
            s_4866_3,
            s_4866_4,
            s_4866_5,
            s_4866_6,
        );
        // N s_4866_8: return
        return;
    }
    fn block_4867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4867_0: read-var opc2:u8
        let s_4867_0: u8 = fn_state.opc2;
        // D s_4867_1: cast zx s_4867_0 -> bv
        let s_4867_1: Bits = Bits::new(s_4867_0 as u128, 3u16);
        // C s_4867_2: const #1u : u8
        let s_4867_2: u8 = 1;
        // C s_4867_3: cast zx s_4867_2 -> bv
        let s_4867_3: Bits = Bits::new(s_4867_2 as u128, 3u16);
        // D s_4867_4: cmp-eq s_4867_1 s_4867_3
        let s_4867_4: bool = ((s_4867_1) == (s_4867_3));
        // D s_4867_5: write-var gs#118191 <= s_4867_4
        fn_state.gs_118191 = s_4867_4;
        // N s_4867_6: jump b1448
        return block_1448(state, tracer, fn_state);
    }
    fn block_4868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4868_0: read-var opc1:u8
        let s_4868_0: u8 = fn_state.opc1;
        // D s_4868_1: cast zx s_4868_0 -> bv
        let s_4868_1: Bits = Bits::new(s_4868_0 as u128, 3u16);
        // C s_4868_2: const #0u : u8
        let s_4868_2: u8 = 0;
        // C s_4868_3: cast zx s_4868_2 -> bv
        let s_4868_3: Bits = Bits::new(s_4868_2 as u128, 3u16);
        // D s_4868_4: cmp-eq s_4868_1 s_4868_3
        let s_4868_4: bool = ((s_4868_1) == (s_4868_3));
        // D s_4868_5: write-var gs#118190 <= s_4868_4
        fn_state.gs_118190 = s_4868_4;
        // N s_4868_6: jump b1446
        return block_1446(state, tracer, fn_state);
    }
    fn block_4869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4869_0: read-var coproc:u8
        let s_4869_0: u8 = fn_state.coproc;
        // D s_4869_1: cast zx s_4869_0 -> bv
        let s_4869_1: Bits = Bits::new(s_4869_0 as u128, 4u16);
        // C s_4869_2: const #15u : u8
        let s_4869_2: u8 = 15;
        // C s_4869_3: cast zx s_4869_2 -> bv
        let s_4869_3: Bits = Bits::new(s_4869_2 as u128, 4u16);
        // D s_4869_4: cmp-eq s_4869_1 s_4869_3
        let s_4869_4: bool = ((s_4869_1) == (s_4869_3));
        // D s_4869_5: write-var gs#118189 <= s_4869_4
        fn_state.gs_118189 = s_4869_4;
        // N s_4869_6: jump b1444
        return block_1444(state, tracer, fn_state);
    }
    fn block_4870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4870_0: read-var CRn:u8
        let s_4870_0: u8 = fn_state.CRn;
        // D s_4870_1: cast zx s_4870_0 -> bv
        let s_4870_1: Bits = Bits::new(s_4870_0 as u128, 4u16);
        // C s_4870_2: const #14u : u8
        let s_4870_2: u8 = 14;
        // C s_4870_3: cast zx s_4870_2 -> bv
        let s_4870_3: Bits = Bits::new(s_4870_2 as u128, 4u16);
        // D s_4870_4: cmp-eq s_4870_1 s_4870_3
        let s_4870_4: bool = ((s_4870_1) == (s_4870_3));
        // D s_4870_5: write-var gs#118188 <= s_4870_4
        fn_state.gs_118188 = s_4870_4;
        // N s_4870_6: jump b1442
        return block_1442(state, tracer, fn_state);
    }
    fn block_4871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4871_0: read-var el:u8
        let s_4871_0: u8 = fn_state.el;
        // D s_4871_1: read-var coproc:u8
        let s_4871_1: u8 = fn_state.coproc;
        // D s_4871_2: read-var opc1:u8
        let s_4871_2: u8 = fn_state.opc1;
        // D s_4871_3: read-var CRn:u8
        let s_4871_3: u8 = fn_state.CRn;
        // D s_4871_4: read-var opc2:u8
        let s_4871_4: u8 = fn_state.opc2;
        // D s_4871_5: read-var CRm:u8
        let s_4871_5: u8 = fn_state.CRm;
        // D s_4871_6: read-var t:i
        let s_4871_6: i128 = fn_state.t;
        // D s_4871_7: call PMEVCNTR_SysRegRead32_138cd582631ad0fb(s_4871_0, s_4871_1, s_4871_2, s_4871_3, s_4871_4, s_4871_5, s_4871_6)
        let s_4871_7: () = PMEVCNTR_SysRegRead32_138cd582631ad0fb(
            state,
            tracer,
            s_4871_0,
            s_4871_1,
            s_4871_2,
            s_4871_3,
            s_4871_4,
            s_4871_5,
            s_4871_6,
        );
        // N s_4871_8: return
        return;
    }
    fn block_4872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4872_0: read-var opc2:u8
        let s_4872_0: u8 = fn_state.opc2;
        // D s_4872_1: cast zx s_4872_0 -> bv
        let s_4872_1: Bits = Bits::new(s_4872_0 as u128, 3u16);
        // C s_4872_2: const #2u : u8
        let s_4872_2: u8 = 2;
        // C s_4872_3: cast zx s_4872_2 -> bv
        let s_4872_3: Bits = Bits::new(s_4872_2 as u128, 3u16);
        // D s_4872_4: cmp-eq s_4872_1 s_4872_3
        let s_4872_4: bool = ((s_4872_1) == (s_4872_3));
        // D s_4872_5: write-var gs#118187 <= s_4872_4
        fn_state.gs_118187 = s_4872_4;
        // N s_4872_6: jump b1439
        return block_1439(state, tracer, fn_state);
    }
    fn block_4873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4873_0: read-var opc1:u8
        let s_4873_0: u8 = fn_state.opc1;
        // D s_4873_1: cast zx s_4873_0 -> bv
        let s_4873_1: Bits = Bits::new(s_4873_0 as u128, 3u16);
        // C s_4873_2: const #0u : u8
        let s_4873_2: u8 = 0;
        // C s_4873_3: cast zx s_4873_2 -> bv
        let s_4873_3: Bits = Bits::new(s_4873_2 as u128, 3u16);
        // D s_4873_4: cmp-eq s_4873_1 s_4873_3
        let s_4873_4: bool = ((s_4873_1) == (s_4873_3));
        // D s_4873_5: write-var gs#118186 <= s_4873_4
        fn_state.gs_118186 = s_4873_4;
        // N s_4873_6: jump b1437
        return block_1437(state, tracer, fn_state);
    }
    fn block_4874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4874_0: read-var coproc:u8
        let s_4874_0: u8 = fn_state.coproc;
        // D s_4874_1: cast zx s_4874_0 -> bv
        let s_4874_1: Bits = Bits::new(s_4874_0 as u128, 4u16);
        // C s_4874_2: const #15u : u8
        let s_4874_2: u8 = 15;
        // C s_4874_3: cast zx s_4874_2 -> bv
        let s_4874_3: Bits = Bits::new(s_4874_2 as u128, 4u16);
        // D s_4874_4: cmp-eq s_4874_1 s_4874_3
        let s_4874_4: bool = ((s_4874_1) == (s_4874_3));
        // D s_4874_5: write-var gs#118185 <= s_4874_4
        fn_state.gs_118185 = s_4874_4;
        // N s_4874_6: jump b1435
        return block_1435(state, tracer, fn_state);
    }
    fn block_4875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4875_0: read-var CRn:u8
        let s_4875_0: u8 = fn_state.CRn;
        // D s_4875_1: cast zx s_4875_0 -> bv
        let s_4875_1: Bits = Bits::new(s_4875_0 as u128, 4u16);
        // C s_4875_2: const #14u : u8
        let s_4875_2: u8 = 14;
        // C s_4875_3: cast zx s_4875_2 -> bv
        let s_4875_3: Bits = Bits::new(s_4875_2 as u128, 4u16);
        // D s_4875_4: cmp-eq s_4875_1 s_4875_3
        let s_4875_4: bool = ((s_4875_1) == (s_4875_3));
        // D s_4875_5: write-var gs#118184 <= s_4875_4
        fn_state.gs_118184 = s_4875_4;
        // N s_4875_6: jump b1433
        return block_1433(state, tracer, fn_state);
    }
    fn block_4876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4876_0: read-var el:u8
        let s_4876_0: u8 = fn_state.el;
        // D s_4876_1: read-var coproc:u8
        let s_4876_1: u8 = fn_state.coproc;
        // D s_4876_2: read-var opc1:u8
        let s_4876_2: u8 = fn_state.opc1;
        // D s_4876_3: read-var CRn:u8
        let s_4876_3: u8 = fn_state.CRn;
        // D s_4876_4: read-var opc2:u8
        let s_4876_4: u8 = fn_state.opc2;
        // D s_4876_5: read-var CRm:u8
        let s_4876_5: u8 = fn_state.CRm;
        // D s_4876_6: read-var t:i
        let s_4876_6: i128 = fn_state.t;
        // D s_4876_7: call PMEVCNTR_SysRegRead32_4e38caf85e50badb(s_4876_0, s_4876_1, s_4876_2, s_4876_3, s_4876_4, s_4876_5, s_4876_6)
        let s_4876_7: () = PMEVCNTR_SysRegRead32_4e38caf85e50badb(
            state,
            tracer,
            s_4876_0,
            s_4876_1,
            s_4876_2,
            s_4876_3,
            s_4876_4,
            s_4876_5,
            s_4876_6,
        );
        // N s_4876_8: return
        return;
    }
    fn block_4877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4877_0: read-var opc2:u8
        let s_4877_0: u8 = fn_state.opc2;
        // D s_4877_1: cast zx s_4877_0 -> bv
        let s_4877_1: Bits = Bits::new(s_4877_0 as u128, 3u16);
        // C s_4877_2: const #3u : u8
        let s_4877_2: u8 = 3;
        // C s_4877_3: cast zx s_4877_2 -> bv
        let s_4877_3: Bits = Bits::new(s_4877_2 as u128, 3u16);
        // D s_4877_4: cmp-eq s_4877_1 s_4877_3
        let s_4877_4: bool = ((s_4877_1) == (s_4877_3));
        // D s_4877_5: write-var gs#118183 <= s_4877_4
        fn_state.gs_118183 = s_4877_4;
        // N s_4877_6: jump b1430
        return block_1430(state, tracer, fn_state);
    }
    fn block_4878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4878_0: read-var opc1:u8
        let s_4878_0: u8 = fn_state.opc1;
        // D s_4878_1: cast zx s_4878_0 -> bv
        let s_4878_1: Bits = Bits::new(s_4878_0 as u128, 3u16);
        // C s_4878_2: const #0u : u8
        let s_4878_2: u8 = 0;
        // C s_4878_3: cast zx s_4878_2 -> bv
        let s_4878_3: Bits = Bits::new(s_4878_2 as u128, 3u16);
        // D s_4878_4: cmp-eq s_4878_1 s_4878_3
        let s_4878_4: bool = ((s_4878_1) == (s_4878_3));
        // D s_4878_5: write-var gs#118182 <= s_4878_4
        fn_state.gs_118182 = s_4878_4;
        // N s_4878_6: jump b1428
        return block_1428(state, tracer, fn_state);
    }
    fn block_4879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4879_0: read-var coproc:u8
        let s_4879_0: u8 = fn_state.coproc;
        // D s_4879_1: cast zx s_4879_0 -> bv
        let s_4879_1: Bits = Bits::new(s_4879_0 as u128, 4u16);
        // C s_4879_2: const #15u : u8
        let s_4879_2: u8 = 15;
        // C s_4879_3: cast zx s_4879_2 -> bv
        let s_4879_3: Bits = Bits::new(s_4879_2 as u128, 4u16);
        // D s_4879_4: cmp-eq s_4879_1 s_4879_3
        let s_4879_4: bool = ((s_4879_1) == (s_4879_3));
        // D s_4879_5: write-var gs#118181 <= s_4879_4
        fn_state.gs_118181 = s_4879_4;
        // N s_4879_6: jump b1426
        return block_1426(state, tracer, fn_state);
    }
    fn block_4880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4880_0: read-var CRn:u8
        let s_4880_0: u8 = fn_state.CRn;
        // D s_4880_1: cast zx s_4880_0 -> bv
        let s_4880_1: Bits = Bits::new(s_4880_0 as u128, 4u16);
        // C s_4880_2: const #14u : u8
        let s_4880_2: u8 = 14;
        // C s_4880_3: cast zx s_4880_2 -> bv
        let s_4880_3: Bits = Bits::new(s_4880_2 as u128, 4u16);
        // D s_4880_4: cmp-eq s_4880_1 s_4880_3
        let s_4880_4: bool = ((s_4880_1) == (s_4880_3));
        // D s_4880_5: write-var gs#118180 <= s_4880_4
        fn_state.gs_118180 = s_4880_4;
        // N s_4880_6: jump b1424
        return block_1424(state, tracer, fn_state);
    }
    fn block_4881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4881_0: read-var el:u8
        let s_4881_0: u8 = fn_state.el;
        // D s_4881_1: read-var coproc:u8
        let s_4881_1: u8 = fn_state.coproc;
        // D s_4881_2: read-var opc1:u8
        let s_4881_2: u8 = fn_state.opc1;
        // D s_4881_3: read-var CRn:u8
        let s_4881_3: u8 = fn_state.CRn;
        // D s_4881_4: read-var opc2:u8
        let s_4881_4: u8 = fn_state.opc2;
        // D s_4881_5: read-var CRm:u8
        let s_4881_5: u8 = fn_state.CRm;
        // D s_4881_6: read-var t:i
        let s_4881_6: i128 = fn_state.t;
        // D s_4881_7: call PMEVCNTR_SysRegRead32_01bab0512200ef97(s_4881_0, s_4881_1, s_4881_2, s_4881_3, s_4881_4, s_4881_5, s_4881_6)
        let s_4881_7: () = PMEVCNTR_SysRegRead32_01bab0512200ef97(
            state,
            tracer,
            s_4881_0,
            s_4881_1,
            s_4881_2,
            s_4881_3,
            s_4881_4,
            s_4881_5,
            s_4881_6,
        );
        // N s_4881_8: return
        return;
    }
    fn block_4882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4882_0: read-var opc2:u8
        let s_4882_0: u8 = fn_state.opc2;
        // D s_4882_1: cast zx s_4882_0 -> bv
        let s_4882_1: Bits = Bits::new(s_4882_0 as u128, 3u16);
        // C s_4882_2: const #4u : u8
        let s_4882_2: u8 = 4;
        // C s_4882_3: cast zx s_4882_2 -> bv
        let s_4882_3: Bits = Bits::new(s_4882_2 as u128, 3u16);
        // D s_4882_4: cmp-eq s_4882_1 s_4882_3
        let s_4882_4: bool = ((s_4882_1) == (s_4882_3));
        // D s_4882_5: write-var gs#118179 <= s_4882_4
        fn_state.gs_118179 = s_4882_4;
        // N s_4882_6: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_4883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4883_0: read-var opc1:u8
        let s_4883_0: u8 = fn_state.opc1;
        // D s_4883_1: cast zx s_4883_0 -> bv
        let s_4883_1: Bits = Bits::new(s_4883_0 as u128, 3u16);
        // C s_4883_2: const #0u : u8
        let s_4883_2: u8 = 0;
        // C s_4883_3: cast zx s_4883_2 -> bv
        let s_4883_3: Bits = Bits::new(s_4883_2 as u128, 3u16);
        // D s_4883_4: cmp-eq s_4883_1 s_4883_3
        let s_4883_4: bool = ((s_4883_1) == (s_4883_3));
        // D s_4883_5: write-var gs#118178 <= s_4883_4
        fn_state.gs_118178 = s_4883_4;
        // N s_4883_6: jump b1419
        return block_1419(state, tracer, fn_state);
    }
    fn block_4884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4884_0: read-var coproc:u8
        let s_4884_0: u8 = fn_state.coproc;
        // D s_4884_1: cast zx s_4884_0 -> bv
        let s_4884_1: Bits = Bits::new(s_4884_0 as u128, 4u16);
        // C s_4884_2: const #15u : u8
        let s_4884_2: u8 = 15;
        // C s_4884_3: cast zx s_4884_2 -> bv
        let s_4884_3: Bits = Bits::new(s_4884_2 as u128, 4u16);
        // D s_4884_4: cmp-eq s_4884_1 s_4884_3
        let s_4884_4: bool = ((s_4884_1) == (s_4884_3));
        // D s_4884_5: write-var gs#118177 <= s_4884_4
        fn_state.gs_118177 = s_4884_4;
        // N s_4884_6: jump b1417
        return block_1417(state, tracer, fn_state);
    }
    fn block_4885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4885_0: read-var CRn:u8
        let s_4885_0: u8 = fn_state.CRn;
        // D s_4885_1: cast zx s_4885_0 -> bv
        let s_4885_1: Bits = Bits::new(s_4885_0 as u128, 4u16);
        // C s_4885_2: const #14u : u8
        let s_4885_2: u8 = 14;
        // C s_4885_3: cast zx s_4885_2 -> bv
        let s_4885_3: Bits = Bits::new(s_4885_2 as u128, 4u16);
        // D s_4885_4: cmp-eq s_4885_1 s_4885_3
        let s_4885_4: bool = ((s_4885_1) == (s_4885_3));
        // D s_4885_5: write-var gs#118176 <= s_4885_4
        fn_state.gs_118176 = s_4885_4;
        // N s_4885_6: jump b1415
        return block_1415(state, tracer, fn_state);
    }
    fn block_4886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4886_0: read-var el:u8
        let s_4886_0: u8 = fn_state.el;
        // D s_4886_1: read-var coproc:u8
        let s_4886_1: u8 = fn_state.coproc;
        // D s_4886_2: read-var opc1:u8
        let s_4886_2: u8 = fn_state.opc1;
        // D s_4886_3: read-var CRn:u8
        let s_4886_3: u8 = fn_state.CRn;
        // D s_4886_4: read-var opc2:u8
        let s_4886_4: u8 = fn_state.opc2;
        // D s_4886_5: read-var CRm:u8
        let s_4886_5: u8 = fn_state.CRm;
        // D s_4886_6: read-var t:i
        let s_4886_6: i128 = fn_state.t;
        // D s_4886_7: call PMEVCNTR_SysRegRead32_70f084c8c157c7b4(s_4886_0, s_4886_1, s_4886_2, s_4886_3, s_4886_4, s_4886_5, s_4886_6)
        let s_4886_7: () = PMEVCNTR_SysRegRead32_70f084c8c157c7b4(
            state,
            tracer,
            s_4886_0,
            s_4886_1,
            s_4886_2,
            s_4886_3,
            s_4886_4,
            s_4886_5,
            s_4886_6,
        );
        // N s_4886_8: return
        return;
    }
    fn block_4887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4887_0: read-var opc2:u8
        let s_4887_0: u8 = fn_state.opc2;
        // D s_4887_1: cast zx s_4887_0 -> bv
        let s_4887_1: Bits = Bits::new(s_4887_0 as u128, 3u16);
        // C s_4887_2: const #5u : u8
        let s_4887_2: u8 = 5;
        // C s_4887_3: cast zx s_4887_2 -> bv
        let s_4887_3: Bits = Bits::new(s_4887_2 as u128, 3u16);
        // D s_4887_4: cmp-eq s_4887_1 s_4887_3
        let s_4887_4: bool = ((s_4887_1) == (s_4887_3));
        // D s_4887_5: write-var gs#118175 <= s_4887_4
        fn_state.gs_118175 = s_4887_4;
        // N s_4887_6: jump b1412
        return block_1412(state, tracer, fn_state);
    }
    fn block_4888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4888_0: read-var opc1:u8
        let s_4888_0: u8 = fn_state.opc1;
        // D s_4888_1: cast zx s_4888_0 -> bv
        let s_4888_1: Bits = Bits::new(s_4888_0 as u128, 3u16);
        // C s_4888_2: const #0u : u8
        let s_4888_2: u8 = 0;
        // C s_4888_3: cast zx s_4888_2 -> bv
        let s_4888_3: Bits = Bits::new(s_4888_2 as u128, 3u16);
        // D s_4888_4: cmp-eq s_4888_1 s_4888_3
        let s_4888_4: bool = ((s_4888_1) == (s_4888_3));
        // D s_4888_5: write-var gs#118174 <= s_4888_4
        fn_state.gs_118174 = s_4888_4;
        // N s_4888_6: jump b1410
        return block_1410(state, tracer, fn_state);
    }
    fn block_4889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4889_0: read-var coproc:u8
        let s_4889_0: u8 = fn_state.coproc;
        // D s_4889_1: cast zx s_4889_0 -> bv
        let s_4889_1: Bits = Bits::new(s_4889_0 as u128, 4u16);
        // C s_4889_2: const #15u : u8
        let s_4889_2: u8 = 15;
        // C s_4889_3: cast zx s_4889_2 -> bv
        let s_4889_3: Bits = Bits::new(s_4889_2 as u128, 4u16);
        // D s_4889_4: cmp-eq s_4889_1 s_4889_3
        let s_4889_4: bool = ((s_4889_1) == (s_4889_3));
        // D s_4889_5: write-var gs#118173 <= s_4889_4
        fn_state.gs_118173 = s_4889_4;
        // N s_4889_6: jump b1408
        return block_1408(state, tracer, fn_state);
    }
    fn block_4890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4890_0: read-var CRn:u8
        let s_4890_0: u8 = fn_state.CRn;
        // D s_4890_1: cast zx s_4890_0 -> bv
        let s_4890_1: Bits = Bits::new(s_4890_0 as u128, 4u16);
        // C s_4890_2: const #14u : u8
        let s_4890_2: u8 = 14;
        // C s_4890_3: cast zx s_4890_2 -> bv
        let s_4890_3: Bits = Bits::new(s_4890_2 as u128, 4u16);
        // D s_4890_4: cmp-eq s_4890_1 s_4890_3
        let s_4890_4: bool = ((s_4890_1) == (s_4890_3));
        // D s_4890_5: write-var gs#118172 <= s_4890_4
        fn_state.gs_118172 = s_4890_4;
        // N s_4890_6: jump b1406
        return block_1406(state, tracer, fn_state);
    }
    fn block_4891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4891_0: read-var el:u8
        let s_4891_0: u8 = fn_state.el;
        // D s_4891_1: read-var coproc:u8
        let s_4891_1: u8 = fn_state.coproc;
        // D s_4891_2: read-var opc1:u8
        let s_4891_2: u8 = fn_state.opc1;
        // D s_4891_3: read-var CRn:u8
        let s_4891_3: u8 = fn_state.CRn;
        // D s_4891_4: read-var opc2:u8
        let s_4891_4: u8 = fn_state.opc2;
        // D s_4891_5: read-var CRm:u8
        let s_4891_5: u8 = fn_state.CRm;
        // D s_4891_6: read-var t:i
        let s_4891_6: i128 = fn_state.t;
        // D s_4891_7: call PMEVCNTR_SysRegRead32_6a5d074d2473e341(s_4891_0, s_4891_1, s_4891_2, s_4891_3, s_4891_4, s_4891_5, s_4891_6)
        let s_4891_7: () = PMEVCNTR_SysRegRead32_6a5d074d2473e341(
            state,
            tracer,
            s_4891_0,
            s_4891_1,
            s_4891_2,
            s_4891_3,
            s_4891_4,
            s_4891_5,
            s_4891_6,
        );
        // N s_4891_8: return
        return;
    }
    fn block_4892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4892_0: read-var opc2:u8
        let s_4892_0: u8 = fn_state.opc2;
        // D s_4892_1: cast zx s_4892_0 -> bv
        let s_4892_1: Bits = Bits::new(s_4892_0 as u128, 3u16);
        // C s_4892_2: const #6u : u8
        let s_4892_2: u8 = 6;
        // C s_4892_3: cast zx s_4892_2 -> bv
        let s_4892_3: Bits = Bits::new(s_4892_2 as u128, 3u16);
        // D s_4892_4: cmp-eq s_4892_1 s_4892_3
        let s_4892_4: bool = ((s_4892_1) == (s_4892_3));
        // D s_4892_5: write-var gs#118171 <= s_4892_4
        fn_state.gs_118171 = s_4892_4;
        // N s_4892_6: jump b1403
        return block_1403(state, tracer, fn_state);
    }
    fn block_4893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4893_0: read-var opc1:u8
        let s_4893_0: u8 = fn_state.opc1;
        // D s_4893_1: cast zx s_4893_0 -> bv
        let s_4893_1: Bits = Bits::new(s_4893_0 as u128, 3u16);
        // C s_4893_2: const #0u : u8
        let s_4893_2: u8 = 0;
        // C s_4893_3: cast zx s_4893_2 -> bv
        let s_4893_3: Bits = Bits::new(s_4893_2 as u128, 3u16);
        // D s_4893_4: cmp-eq s_4893_1 s_4893_3
        let s_4893_4: bool = ((s_4893_1) == (s_4893_3));
        // D s_4893_5: write-var gs#118170 <= s_4893_4
        fn_state.gs_118170 = s_4893_4;
        // N s_4893_6: jump b1401
        return block_1401(state, tracer, fn_state);
    }
    fn block_4894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4894_0: read-var coproc:u8
        let s_4894_0: u8 = fn_state.coproc;
        // D s_4894_1: cast zx s_4894_0 -> bv
        let s_4894_1: Bits = Bits::new(s_4894_0 as u128, 4u16);
        // C s_4894_2: const #15u : u8
        let s_4894_2: u8 = 15;
        // C s_4894_3: cast zx s_4894_2 -> bv
        let s_4894_3: Bits = Bits::new(s_4894_2 as u128, 4u16);
        // D s_4894_4: cmp-eq s_4894_1 s_4894_3
        let s_4894_4: bool = ((s_4894_1) == (s_4894_3));
        // D s_4894_5: write-var gs#118169 <= s_4894_4
        fn_state.gs_118169 = s_4894_4;
        // N s_4894_6: jump b1399
        return block_1399(state, tracer, fn_state);
    }
    fn block_4895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4895_0: read-var CRn:u8
        let s_4895_0: u8 = fn_state.CRn;
        // D s_4895_1: cast zx s_4895_0 -> bv
        let s_4895_1: Bits = Bits::new(s_4895_0 as u128, 4u16);
        // C s_4895_2: const #14u : u8
        let s_4895_2: u8 = 14;
        // C s_4895_3: cast zx s_4895_2 -> bv
        let s_4895_3: Bits = Bits::new(s_4895_2 as u128, 4u16);
        // D s_4895_4: cmp-eq s_4895_1 s_4895_3
        let s_4895_4: bool = ((s_4895_1) == (s_4895_3));
        // D s_4895_5: write-var gs#118168 <= s_4895_4
        fn_state.gs_118168 = s_4895_4;
        // N s_4895_6: jump b1397
        return block_1397(state, tracer, fn_state);
    }
    fn block_4896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4896_0: read-var el:u8
        let s_4896_0: u8 = fn_state.el;
        // D s_4896_1: read-var coproc:u8
        let s_4896_1: u8 = fn_state.coproc;
        // D s_4896_2: read-var opc1:u8
        let s_4896_2: u8 = fn_state.opc1;
        // D s_4896_3: read-var CRn:u8
        let s_4896_3: u8 = fn_state.CRn;
        // D s_4896_4: read-var opc2:u8
        let s_4896_4: u8 = fn_state.opc2;
        // D s_4896_5: read-var CRm:u8
        let s_4896_5: u8 = fn_state.CRm;
        // D s_4896_6: read-var t:i
        let s_4896_6: i128 = fn_state.t;
        // D s_4896_7: call TPIDRURO_SysRegRead32_331a0b9503da6305(s_4896_0, s_4896_1, s_4896_2, s_4896_3, s_4896_4, s_4896_5, s_4896_6)
        let s_4896_7: () = TPIDRURO_SysRegRead32_331a0b9503da6305(
            state,
            tracer,
            s_4896_0,
            s_4896_1,
            s_4896_2,
            s_4896_3,
            s_4896_4,
            s_4896_5,
            s_4896_6,
        );
        // N s_4896_8: return
        return;
    }
    fn block_4897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4897_0: read-var opc2:u8
        let s_4897_0: u8 = fn_state.opc2;
        // D s_4897_1: cast zx s_4897_0 -> bv
        let s_4897_1: Bits = Bits::new(s_4897_0 as u128, 3u16);
        // C s_4897_2: const #3u : u8
        let s_4897_2: u8 = 3;
        // C s_4897_3: cast zx s_4897_2 -> bv
        let s_4897_3: Bits = Bits::new(s_4897_2 as u128, 3u16);
        // D s_4897_4: cmp-eq s_4897_1 s_4897_3
        let s_4897_4: bool = ((s_4897_1) == (s_4897_3));
        // D s_4897_5: write-var gs#118167 <= s_4897_4
        fn_state.gs_118167 = s_4897_4;
        // N s_4897_6: jump b1394
        return block_1394(state, tracer, fn_state);
    }
    fn block_4898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4898_0: read-var opc1:u8
        let s_4898_0: u8 = fn_state.opc1;
        // D s_4898_1: cast zx s_4898_0 -> bv
        let s_4898_1: Bits = Bits::new(s_4898_0 as u128, 3u16);
        // C s_4898_2: const #0u : u8
        let s_4898_2: u8 = 0;
        // C s_4898_3: cast zx s_4898_2 -> bv
        let s_4898_3: Bits = Bits::new(s_4898_2 as u128, 3u16);
        // D s_4898_4: cmp-eq s_4898_1 s_4898_3
        let s_4898_4: bool = ((s_4898_1) == (s_4898_3));
        // D s_4898_5: write-var gs#118166 <= s_4898_4
        fn_state.gs_118166 = s_4898_4;
        // N s_4898_6: jump b1392
        return block_1392(state, tracer, fn_state);
    }
    fn block_4899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4899_0: read-var coproc:u8
        let s_4899_0: u8 = fn_state.coproc;
        // D s_4899_1: cast zx s_4899_0 -> bv
        let s_4899_1: Bits = Bits::new(s_4899_0 as u128, 4u16);
        // C s_4899_2: const #15u : u8
        let s_4899_2: u8 = 15;
        // C s_4899_3: cast zx s_4899_2 -> bv
        let s_4899_3: Bits = Bits::new(s_4899_2 as u128, 4u16);
        // D s_4899_4: cmp-eq s_4899_1 s_4899_3
        let s_4899_4: bool = ((s_4899_1) == (s_4899_3));
        // D s_4899_5: write-var gs#118165 <= s_4899_4
        fn_state.gs_118165 = s_4899_4;
        // N s_4899_6: jump b1390
        return block_1390(state, tracer, fn_state);
    }
    fn block_4900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4900_0: read-var CRn:u8
        let s_4900_0: u8 = fn_state.CRn;
        // D s_4900_1: cast zx s_4900_0 -> bv
        let s_4900_1: Bits = Bits::new(s_4900_0 as u128, 4u16);
        // C s_4900_2: const #13u : u8
        let s_4900_2: u8 = 13;
        // C s_4900_3: cast zx s_4900_2 -> bv
        let s_4900_3: Bits = Bits::new(s_4900_2 as u128, 4u16);
        // D s_4900_4: cmp-eq s_4900_1 s_4900_3
        let s_4900_4: bool = ((s_4900_1) == (s_4900_3));
        // D s_4900_5: write-var gs#118164 <= s_4900_4
        fn_state.gs_118164 = s_4900_4;
        // N s_4900_6: jump b1388
        return block_1388(state, tracer, fn_state);
    }
    fn block_4901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4901_0: read-var el:u8
        let s_4901_0: u8 = fn_state.el;
        // D s_4901_1: read-var coproc:u8
        let s_4901_1: u8 = fn_state.coproc;
        // D s_4901_2: read-var opc1:u8
        let s_4901_2: u8 = fn_state.opc1;
        // D s_4901_3: read-var CRn:u8
        let s_4901_3: u8 = fn_state.CRn;
        // D s_4901_4: read-var opc2:u8
        let s_4901_4: u8 = fn_state.opc2;
        // D s_4901_5: read-var CRm:u8
        let s_4901_5: u8 = fn_state.CRm;
        // D s_4901_6: read-var t:i
        let s_4901_6: i128 = fn_state.t;
        // D s_4901_7: call NMRR_SysRegRead32_f8e132fd5a9e9c17(s_4901_0, s_4901_1, s_4901_2, s_4901_3, s_4901_4, s_4901_5, s_4901_6)
        let s_4901_7: () = NMRR_SysRegRead32_f8e132fd5a9e9c17(
            state,
            tracer,
            s_4901_0,
            s_4901_1,
            s_4901_2,
            s_4901_3,
            s_4901_4,
            s_4901_5,
            s_4901_6,
        );
        // N s_4901_8: return
        return;
    }
    fn block_4902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4902_0: read-var opc2:u8
        let s_4902_0: u8 = fn_state.opc2;
        // D s_4902_1: cast zx s_4902_0 -> bv
        let s_4902_1: Bits = Bits::new(s_4902_0 as u128, 3u16);
        // C s_4902_2: const #1u : u8
        let s_4902_2: u8 = 1;
        // C s_4902_3: cast zx s_4902_2 -> bv
        let s_4902_3: Bits = Bits::new(s_4902_2 as u128, 3u16);
        // D s_4902_4: cmp-eq s_4902_1 s_4902_3
        let s_4902_4: bool = ((s_4902_1) == (s_4902_3));
        // D s_4902_5: write-var gs#118163 <= s_4902_4
        fn_state.gs_118163 = s_4902_4;
        // N s_4902_6: jump b1385
        return block_1385(state, tracer, fn_state);
    }
    fn block_4903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4903_0: read-var opc1:u8
        let s_4903_0: u8 = fn_state.opc1;
        // D s_4903_1: cast zx s_4903_0 -> bv
        let s_4903_1: Bits = Bits::new(s_4903_0 as u128, 3u16);
        // C s_4903_2: const #0u : u8
        let s_4903_2: u8 = 0;
        // C s_4903_3: cast zx s_4903_2 -> bv
        let s_4903_3: Bits = Bits::new(s_4903_2 as u128, 3u16);
        // D s_4903_4: cmp-eq s_4903_1 s_4903_3
        let s_4903_4: bool = ((s_4903_1) == (s_4903_3));
        // D s_4903_5: write-var gs#118162 <= s_4903_4
        fn_state.gs_118162 = s_4903_4;
        // N s_4903_6: jump b1383
        return block_1383(state, tracer, fn_state);
    }
    fn block_4904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4904_0: read-var coproc:u8
        let s_4904_0: u8 = fn_state.coproc;
        // D s_4904_1: cast zx s_4904_0 -> bv
        let s_4904_1: Bits = Bits::new(s_4904_0 as u128, 4u16);
        // C s_4904_2: const #15u : u8
        let s_4904_2: u8 = 15;
        // C s_4904_3: cast zx s_4904_2 -> bv
        let s_4904_3: Bits = Bits::new(s_4904_2 as u128, 4u16);
        // D s_4904_4: cmp-eq s_4904_1 s_4904_3
        let s_4904_4: bool = ((s_4904_1) == (s_4904_3));
        // D s_4904_5: write-var gs#118161 <= s_4904_4
        fn_state.gs_118161 = s_4904_4;
        // N s_4904_6: jump b1381
        return block_1381(state, tracer, fn_state);
    }
    fn block_4905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4905_0: read-var CRn:u8
        let s_4905_0: u8 = fn_state.CRn;
        // D s_4905_1: cast zx s_4905_0 -> bv
        let s_4905_1: Bits = Bits::new(s_4905_0 as u128, 4u16);
        // C s_4905_2: const #10u : u8
        let s_4905_2: u8 = 10;
        // C s_4905_3: cast zx s_4905_2 -> bv
        let s_4905_3: Bits = Bits::new(s_4905_2 as u128, 4u16);
        // D s_4905_4: cmp-eq s_4905_1 s_4905_3
        let s_4905_4: bool = ((s_4905_1) == (s_4905_3));
        // D s_4905_5: write-var gs#118160 <= s_4905_4
        fn_state.gs_118160 = s_4905_4;
        // N s_4905_6: jump b1379
        return block_1379(state, tracer, fn_state);
    }
    fn block_4906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4906_0: read-var el:u8
        let s_4906_0: u8 = fn_state.el;
        // D s_4906_1: read-var coproc:u8
        let s_4906_1: u8 = fn_state.coproc;
        // D s_4906_2: read-var opc1:u8
        let s_4906_2: u8 = fn_state.opc1;
        // D s_4906_3: read-var CRn:u8
        let s_4906_3: u8 = fn_state.CRn;
        // D s_4906_4: read-var opc2:u8
        let s_4906_4: u8 = fn_state.opc2;
        // D s_4906_5: read-var CRm:u8
        let s_4906_5: u8 = fn_state.CRm;
        // D s_4906_6: read-var t:i
        let s_4906_6: i128 = fn_state.t;
        // D s_4906_7: call DBGCLAIMSET_SysRegRead32_06784b0343d7d2f1(s_4906_0, s_4906_1, s_4906_2, s_4906_3, s_4906_4, s_4906_5, s_4906_6)
        let s_4906_7: () = DBGCLAIMSET_SysRegRead32_06784b0343d7d2f1(
            state,
            tracer,
            s_4906_0,
            s_4906_1,
            s_4906_2,
            s_4906_3,
            s_4906_4,
            s_4906_5,
            s_4906_6,
        );
        // N s_4906_8: return
        return;
    }
    fn block_4907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4907_0: read-var opc2:u8
        let s_4907_0: u8 = fn_state.opc2;
        // D s_4907_1: cast zx s_4907_0 -> bv
        let s_4907_1: Bits = Bits::new(s_4907_0 as u128, 3u16);
        // C s_4907_2: const #6u : u8
        let s_4907_2: u8 = 6;
        // C s_4907_3: cast zx s_4907_2 -> bv
        let s_4907_3: Bits = Bits::new(s_4907_2 as u128, 3u16);
        // D s_4907_4: cmp-eq s_4907_1 s_4907_3
        let s_4907_4: bool = ((s_4907_1) == (s_4907_3));
        // D s_4907_5: write-var gs#118159 <= s_4907_4
        fn_state.gs_118159 = s_4907_4;
        // N s_4907_6: jump b1376
        return block_1376(state, tracer, fn_state);
    }
    fn block_4908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4908_0: read-var opc1:u8
        let s_4908_0: u8 = fn_state.opc1;
        // D s_4908_1: cast zx s_4908_0 -> bv
        let s_4908_1: Bits = Bits::new(s_4908_0 as u128, 3u16);
        // C s_4908_2: const #0u : u8
        let s_4908_2: u8 = 0;
        // C s_4908_3: cast zx s_4908_2 -> bv
        let s_4908_3: Bits = Bits::new(s_4908_2 as u128, 3u16);
        // D s_4908_4: cmp-eq s_4908_1 s_4908_3
        let s_4908_4: bool = ((s_4908_1) == (s_4908_3));
        // D s_4908_5: write-var gs#118158 <= s_4908_4
        fn_state.gs_118158 = s_4908_4;
        // N s_4908_6: jump b1374
        return block_1374(state, tracer, fn_state);
    }
    fn block_4909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4909_0: read-var coproc:u8
        let s_4909_0: u8 = fn_state.coproc;
        // D s_4909_1: cast zx s_4909_0 -> bv
        let s_4909_1: Bits = Bits::new(s_4909_0 as u128, 4u16);
        // C s_4909_2: const #14u : u8
        let s_4909_2: u8 = 14;
        // C s_4909_3: cast zx s_4909_2 -> bv
        let s_4909_3: Bits = Bits::new(s_4909_2 as u128, 4u16);
        // D s_4909_4: cmp-eq s_4909_1 s_4909_3
        let s_4909_4: bool = ((s_4909_1) == (s_4909_3));
        // D s_4909_5: write-var gs#118157 <= s_4909_4
        fn_state.gs_118157 = s_4909_4;
        // N s_4909_6: jump b1372
        return block_1372(state, tracer, fn_state);
    }
    fn block_4910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4910_0: read-var CRn:u8
        let s_4910_0: u8 = fn_state.CRn;
        // D s_4910_1: cast zx s_4910_0 -> bv
        let s_4910_1: Bits = Bits::new(s_4910_0 as u128, 4u16);
        // C s_4910_2: const #7u : u8
        let s_4910_2: u8 = 7;
        // C s_4910_3: cast zx s_4910_2 -> bv
        let s_4910_3: Bits = Bits::new(s_4910_2 as u128, 4u16);
        // D s_4910_4: cmp-eq s_4910_1 s_4910_3
        let s_4910_4: bool = ((s_4910_1) == (s_4910_3));
        // D s_4910_5: write-var gs#118156 <= s_4910_4
        fn_state.gs_118156 = s_4910_4;
        // N s_4910_6: jump b1370
        return block_1370(state, tracer, fn_state);
    }
    fn block_4911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4911_0: read-var el:u8
        let s_4911_0: u8 = fn_state.el;
        // D s_4911_1: read-var coproc:u8
        let s_4911_1: u8 = fn_state.coproc;
        // D s_4911_2: read-var opc1:u8
        let s_4911_2: u8 = fn_state.opc1;
        // D s_4911_3: read-var CRn:u8
        let s_4911_3: u8 = fn_state.CRn;
        // D s_4911_4: read-var opc2:u8
        let s_4911_4: u8 = fn_state.opc2;
        // D s_4911_5: read-var CRm:u8
        let s_4911_5: u8 = fn_state.CRm;
        // D s_4911_6: read-var t:i
        let s_4911_6: i128 = fn_state.t;
        // D s_4911_7: call ID_AFR0_SysRegRead32_49547d26babbff09(s_4911_0, s_4911_1, s_4911_2, s_4911_3, s_4911_4, s_4911_5, s_4911_6)
        let s_4911_7: () = ID_AFR0_SysRegRead32_49547d26babbff09(
            state,
            tracer,
            s_4911_0,
            s_4911_1,
            s_4911_2,
            s_4911_3,
            s_4911_4,
            s_4911_5,
            s_4911_6,
        );
        // N s_4911_8: return
        return;
    }
    fn block_4912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4912_0: read-var opc2:u8
        let s_4912_0: u8 = fn_state.opc2;
        // D s_4912_1: cast zx s_4912_0 -> bv
        let s_4912_1: Bits = Bits::new(s_4912_0 as u128, 3u16);
        // C s_4912_2: const #3u : u8
        let s_4912_2: u8 = 3;
        // C s_4912_3: cast zx s_4912_2 -> bv
        let s_4912_3: Bits = Bits::new(s_4912_2 as u128, 3u16);
        // D s_4912_4: cmp-eq s_4912_1 s_4912_3
        let s_4912_4: bool = ((s_4912_1) == (s_4912_3));
        // D s_4912_5: write-var gs#118155 <= s_4912_4
        fn_state.gs_118155 = s_4912_4;
        // N s_4912_6: jump b1367
        return block_1367(state, tracer, fn_state);
    }
    fn block_4913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4913_0: read-var opc1:u8
        let s_4913_0: u8 = fn_state.opc1;
        // D s_4913_1: cast zx s_4913_0 -> bv
        let s_4913_1: Bits = Bits::new(s_4913_0 as u128, 3u16);
        // C s_4913_2: const #0u : u8
        let s_4913_2: u8 = 0;
        // C s_4913_3: cast zx s_4913_2 -> bv
        let s_4913_3: Bits = Bits::new(s_4913_2 as u128, 3u16);
        // D s_4913_4: cmp-eq s_4913_1 s_4913_3
        let s_4913_4: bool = ((s_4913_1) == (s_4913_3));
        // D s_4913_5: write-var gs#118154 <= s_4913_4
        fn_state.gs_118154 = s_4913_4;
        // N s_4913_6: jump b1365
        return block_1365(state, tracer, fn_state);
    }
    fn block_4914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4914_0: read-var coproc:u8
        let s_4914_0: u8 = fn_state.coproc;
        // D s_4914_1: cast zx s_4914_0 -> bv
        let s_4914_1: Bits = Bits::new(s_4914_0 as u128, 4u16);
        // C s_4914_2: const #15u : u8
        let s_4914_2: u8 = 15;
        // C s_4914_3: cast zx s_4914_2 -> bv
        let s_4914_3: Bits = Bits::new(s_4914_2 as u128, 4u16);
        // D s_4914_4: cmp-eq s_4914_1 s_4914_3
        let s_4914_4: bool = ((s_4914_1) == (s_4914_3));
        // D s_4914_5: write-var gs#118153 <= s_4914_4
        fn_state.gs_118153 = s_4914_4;
        // N s_4914_6: jump b1363
        return block_1363(state, tracer, fn_state);
    }
    fn block_4915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4915_0: read-var CRn:u8
        let s_4915_0: u8 = fn_state.CRn;
        // D s_4915_1: cast zx s_4915_0 -> bv
        let s_4915_1: Bits = Bits::new(s_4915_0 as u128, 4u16);
        // C s_4915_2: const #0u : u8
        let s_4915_2: u8 = 0;
        // C s_4915_3: cast zx s_4915_2 -> bv
        let s_4915_3: Bits = Bits::new(s_4915_2 as u128, 4u16);
        // D s_4915_4: cmp-eq s_4915_1 s_4915_3
        let s_4915_4: bool = ((s_4915_1) == (s_4915_3));
        // D s_4915_5: write-var gs#118152 <= s_4915_4
        fn_state.gs_118152 = s_4915_4;
        // N s_4915_6: jump b1361
        return block_1361(state, tracer, fn_state);
    }
    fn block_4916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4916_0: read-var el:u8
        let s_4916_0: u8 = fn_state.el;
        // D s_4916_1: read-var coproc:u8
        let s_4916_1: u8 = fn_state.coproc;
        // D s_4916_2: read-var opc1:u8
        let s_4916_2: u8 = fn_state.opc1;
        // D s_4916_3: read-var CRn:u8
        let s_4916_3: u8 = fn_state.CRn;
        // D s_4916_4: read-var opc2:u8
        let s_4916_4: u8 = fn_state.opc2;
        // D s_4916_5: read-var CRm:u8
        let s_4916_5: u8 = fn_state.CRm;
        // D s_4916_6: read-var t:i
        let s_4916_6: i128 = fn_state.t;
        // D s_4916_7: call PMSELR_SysRegRead32_cbb0200049a096ed(s_4916_0, s_4916_1, s_4916_2, s_4916_3, s_4916_4, s_4916_5, s_4916_6)
        let s_4916_7: () = PMSELR_SysRegRead32_cbb0200049a096ed(
            state,
            tracer,
            s_4916_0,
            s_4916_1,
            s_4916_2,
            s_4916_3,
            s_4916_4,
            s_4916_5,
            s_4916_6,
        );
        // N s_4916_8: return
        return;
    }
    fn block_4917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4917_0: read-var opc2:u8
        let s_4917_0: u8 = fn_state.opc2;
        // D s_4917_1: cast zx s_4917_0 -> bv
        let s_4917_1: Bits = Bits::new(s_4917_0 as u128, 3u16);
        // C s_4917_2: const #5u : u8
        let s_4917_2: u8 = 5;
        // C s_4917_3: cast zx s_4917_2 -> bv
        let s_4917_3: Bits = Bits::new(s_4917_2 as u128, 3u16);
        // D s_4917_4: cmp-eq s_4917_1 s_4917_3
        let s_4917_4: bool = ((s_4917_1) == (s_4917_3));
        // D s_4917_5: write-var gs#118151 <= s_4917_4
        fn_state.gs_118151 = s_4917_4;
        // N s_4917_6: jump b1358
        return block_1358(state, tracer, fn_state);
    }
    fn block_4918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4918_0: read-var opc1:u8
        let s_4918_0: u8 = fn_state.opc1;
        // D s_4918_1: cast zx s_4918_0 -> bv
        let s_4918_1: Bits = Bits::new(s_4918_0 as u128, 3u16);
        // C s_4918_2: const #0u : u8
        let s_4918_2: u8 = 0;
        // C s_4918_3: cast zx s_4918_2 -> bv
        let s_4918_3: Bits = Bits::new(s_4918_2 as u128, 3u16);
        // D s_4918_4: cmp-eq s_4918_1 s_4918_3
        let s_4918_4: bool = ((s_4918_1) == (s_4918_3));
        // D s_4918_5: write-var gs#118150 <= s_4918_4
        fn_state.gs_118150 = s_4918_4;
        // N s_4918_6: jump b1356
        return block_1356(state, tracer, fn_state);
    }
    fn block_4919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4919_0: read-var coproc:u8
        let s_4919_0: u8 = fn_state.coproc;
        // D s_4919_1: cast zx s_4919_0 -> bv
        let s_4919_1: Bits = Bits::new(s_4919_0 as u128, 4u16);
        // C s_4919_2: const #15u : u8
        let s_4919_2: u8 = 15;
        // C s_4919_3: cast zx s_4919_2 -> bv
        let s_4919_3: Bits = Bits::new(s_4919_2 as u128, 4u16);
        // D s_4919_4: cmp-eq s_4919_1 s_4919_3
        let s_4919_4: bool = ((s_4919_1) == (s_4919_3));
        // D s_4919_5: write-var gs#118149 <= s_4919_4
        fn_state.gs_118149 = s_4919_4;
        // N s_4919_6: jump b1354
        return block_1354(state, tracer, fn_state);
    }
    fn block_4920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4920_0: read-var CRn:u8
        let s_4920_0: u8 = fn_state.CRn;
        // D s_4920_1: cast zx s_4920_0 -> bv
        let s_4920_1: Bits = Bits::new(s_4920_0 as u128, 4u16);
        // C s_4920_2: const #9u : u8
        let s_4920_2: u8 = 9;
        // C s_4920_3: cast zx s_4920_2 -> bv
        let s_4920_3: Bits = Bits::new(s_4920_2 as u128, 4u16);
        // D s_4920_4: cmp-eq s_4920_1 s_4920_3
        let s_4920_4: bool = ((s_4920_1) == (s_4920_3));
        // D s_4920_5: write-var gs#118148 <= s_4920_4
        fn_state.gs_118148 = s_4920_4;
        // N s_4920_6: jump b1352
        return block_1352(state, tracer, fn_state);
    }
    fn block_4921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4921_0: read-var el:u8
        let s_4921_0: u8 = fn_state.el;
        // D s_4921_1: read-var coproc:u8
        let s_4921_1: u8 = fn_state.coproc;
        // D s_4921_2: read-var opc1:u8
        let s_4921_2: u8 = fn_state.opc1;
        // D s_4921_3: read-var CRn:u8
        let s_4921_3: u8 = fn_state.CRn;
        // D s_4921_4: read-var opc2:u8
        let s_4921_4: u8 = fn_state.opc2;
        // D s_4921_5: read-var CRm:u8
        let s_4921_5: u8 = fn_state.CRm;
        // D s_4921_6: read-var t:i
        let s_4921_6: i128 = fn_state.t;
        // D s_4921_7: call ICC_MCTLR_SysRegRead32_f1e0f70708724584(s_4921_0, s_4921_1, s_4921_2, s_4921_3, s_4921_4, s_4921_5, s_4921_6)
        let s_4921_7: () = ICC_MCTLR_SysRegRead32_f1e0f70708724584(
            state,
            tracer,
            s_4921_0,
            s_4921_1,
            s_4921_2,
            s_4921_3,
            s_4921_4,
            s_4921_5,
            s_4921_6,
        );
        // N s_4921_8: return
        return;
    }
    fn block_4922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4922_0: read-var opc2:u8
        let s_4922_0: u8 = fn_state.opc2;
        // D s_4922_1: cast zx s_4922_0 -> bv
        let s_4922_1: Bits = Bits::new(s_4922_0 as u128, 3u16);
        // C s_4922_2: const #4u : u8
        let s_4922_2: u8 = 4;
        // C s_4922_3: cast zx s_4922_2 -> bv
        let s_4922_3: Bits = Bits::new(s_4922_2 as u128, 3u16);
        // D s_4922_4: cmp-eq s_4922_1 s_4922_3
        let s_4922_4: bool = ((s_4922_1) == (s_4922_3));
        // D s_4922_5: write-var gs#118147 <= s_4922_4
        fn_state.gs_118147 = s_4922_4;
        // N s_4922_6: jump b1349
        return block_1349(state, tracer, fn_state);
    }
    fn block_4923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4923_0: read-var opc1:u8
        let s_4923_0: u8 = fn_state.opc1;
        // D s_4923_1: cast zx s_4923_0 -> bv
        let s_4923_1: Bits = Bits::new(s_4923_0 as u128, 3u16);
        // C s_4923_2: const #6u : u8
        let s_4923_2: u8 = 6;
        // C s_4923_3: cast zx s_4923_2 -> bv
        let s_4923_3: Bits = Bits::new(s_4923_2 as u128, 3u16);
        // D s_4923_4: cmp-eq s_4923_1 s_4923_3
        let s_4923_4: bool = ((s_4923_1) == (s_4923_3));
        // D s_4923_5: write-var gs#118146 <= s_4923_4
        fn_state.gs_118146 = s_4923_4;
        // N s_4923_6: jump b1347
        return block_1347(state, tracer, fn_state);
    }
    fn block_4924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4924_0: read-var coproc:u8
        let s_4924_0: u8 = fn_state.coproc;
        // D s_4924_1: cast zx s_4924_0 -> bv
        let s_4924_1: Bits = Bits::new(s_4924_0 as u128, 4u16);
        // C s_4924_2: const #15u : u8
        let s_4924_2: u8 = 15;
        // C s_4924_3: cast zx s_4924_2 -> bv
        let s_4924_3: Bits = Bits::new(s_4924_2 as u128, 4u16);
        // D s_4924_4: cmp-eq s_4924_1 s_4924_3
        let s_4924_4: bool = ((s_4924_1) == (s_4924_3));
        // D s_4924_5: write-var gs#118145 <= s_4924_4
        fn_state.gs_118145 = s_4924_4;
        // N s_4924_6: jump b1345
        return block_1345(state, tracer, fn_state);
    }
    fn block_4925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4925_0: read-var CRn:u8
        let s_4925_0: u8 = fn_state.CRn;
        // D s_4925_1: cast zx s_4925_0 -> bv
        let s_4925_1: Bits = Bits::new(s_4925_0 as u128, 4u16);
        // C s_4925_2: const #12u : u8
        let s_4925_2: u8 = 12;
        // C s_4925_3: cast zx s_4925_2 -> bv
        let s_4925_3: Bits = Bits::new(s_4925_2 as u128, 4u16);
        // D s_4925_4: cmp-eq s_4925_1 s_4925_3
        let s_4925_4: bool = ((s_4925_1) == (s_4925_3));
        // D s_4925_5: write-var gs#118144 <= s_4925_4
        fn_state.gs_118144 = s_4925_4;
        // N s_4925_6: jump b1343
        return block_1343(state, tracer, fn_state);
    }
    fn block_4926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4926_0: read-var el:u8
        let s_4926_0: u8 = fn_state.el;
        // D s_4926_1: read-var coproc:u8
        let s_4926_1: u8 = fn_state.coproc;
        // D s_4926_2: read-var opc1:u8
        let s_4926_2: u8 = fn_state.opc1;
        // D s_4926_3: read-var CRn:u8
        let s_4926_3: u8 = fn_state.CRn;
        // D s_4926_4: read-var opc2:u8
        let s_4926_4: u8 = fn_state.opc2;
        // D s_4926_5: read-var CRm:u8
        let s_4926_5: u8 = fn_state.CRm;
        // D s_4926_6: read-var t:i
        let s_4926_6: i128 = fn_state.t;
        // D s_4926_7: call HSTR_SysRegRead32_1f7e6811bde077a5(s_4926_0, s_4926_1, s_4926_2, s_4926_3, s_4926_4, s_4926_5, s_4926_6)
        let s_4926_7: () = HSTR_SysRegRead32_1f7e6811bde077a5(
            state,
            tracer,
            s_4926_0,
            s_4926_1,
            s_4926_2,
            s_4926_3,
            s_4926_4,
            s_4926_5,
            s_4926_6,
        );
        // N s_4926_8: return
        return;
    }
    fn block_4927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4927_0: read-var opc2:u8
        let s_4927_0: u8 = fn_state.opc2;
        // D s_4927_1: cast zx s_4927_0 -> bv
        let s_4927_1: Bits = Bits::new(s_4927_0 as u128, 3u16);
        // C s_4927_2: const #3u : u8
        let s_4927_2: u8 = 3;
        // C s_4927_3: cast zx s_4927_2 -> bv
        let s_4927_3: Bits = Bits::new(s_4927_2 as u128, 3u16);
        // D s_4927_4: cmp-eq s_4927_1 s_4927_3
        let s_4927_4: bool = ((s_4927_1) == (s_4927_3));
        // D s_4927_5: write-var gs#118143 <= s_4927_4
        fn_state.gs_118143 = s_4927_4;
        // N s_4927_6: jump b1340
        return block_1340(state, tracer, fn_state);
    }
    fn block_4928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4928_0: read-var opc1:u8
        let s_4928_0: u8 = fn_state.opc1;
        // D s_4928_1: cast zx s_4928_0 -> bv
        let s_4928_1: Bits = Bits::new(s_4928_0 as u128, 3u16);
        // C s_4928_2: const #4u : u8
        let s_4928_2: u8 = 4;
        // C s_4928_3: cast zx s_4928_2 -> bv
        let s_4928_3: Bits = Bits::new(s_4928_2 as u128, 3u16);
        // D s_4928_4: cmp-eq s_4928_1 s_4928_3
        let s_4928_4: bool = ((s_4928_1) == (s_4928_3));
        // D s_4928_5: write-var gs#118142 <= s_4928_4
        fn_state.gs_118142 = s_4928_4;
        // N s_4928_6: jump b1338
        return block_1338(state, tracer, fn_state);
    }
    fn block_4929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4929_0: read-var coproc:u8
        let s_4929_0: u8 = fn_state.coproc;
        // D s_4929_1: cast zx s_4929_0 -> bv
        let s_4929_1: Bits = Bits::new(s_4929_0 as u128, 4u16);
        // C s_4929_2: const #15u : u8
        let s_4929_2: u8 = 15;
        // C s_4929_3: cast zx s_4929_2 -> bv
        let s_4929_3: Bits = Bits::new(s_4929_2 as u128, 4u16);
        // D s_4929_4: cmp-eq s_4929_1 s_4929_3
        let s_4929_4: bool = ((s_4929_1) == (s_4929_3));
        // D s_4929_5: write-var gs#118141 <= s_4929_4
        fn_state.gs_118141 = s_4929_4;
        // N s_4929_6: jump b1336
        return block_1336(state, tracer, fn_state);
    }
    fn block_4930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4930_0: read-var CRn:u8
        let s_4930_0: u8 = fn_state.CRn;
        // D s_4930_1: cast zx s_4930_0 -> bv
        let s_4930_1: Bits = Bits::new(s_4930_0 as u128, 4u16);
        // C s_4930_2: const #1u : u8
        let s_4930_2: u8 = 1;
        // C s_4930_3: cast zx s_4930_2 -> bv
        let s_4930_3: Bits = Bits::new(s_4930_2 as u128, 4u16);
        // D s_4930_4: cmp-eq s_4930_1 s_4930_3
        let s_4930_4: bool = ((s_4930_1) == (s_4930_3));
        // D s_4930_5: write-var gs#118140 <= s_4930_4
        fn_state.gs_118140 = s_4930_4;
        // N s_4930_6: jump b1334
        return block_1334(state, tracer, fn_state);
    }
    fn block_4931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4931_0: read-var el:u8
        let s_4931_0: u8 = fn_state.el;
        // D s_4931_1: read-var coproc:u8
        let s_4931_1: u8 = fn_state.coproc;
        // D s_4931_2: read-var opc1:u8
        let s_4931_2: u8 = fn_state.opc1;
        // D s_4931_3: read-var CRn:u8
        let s_4931_3: u8 = fn_state.CRn;
        // D s_4931_4: read-var opc2:u8
        let s_4931_4: u8 = fn_state.opc2;
        // D s_4931_5: read-var CRm:u8
        let s_4931_5: u8 = fn_state.CRm;
        // D s_4931_6: read-var t:i
        let s_4931_6: i128 = fn_state.t;
        // D s_4931_7: call DSPSR_SysRegRead32_b8ab5544c94609ec(s_4931_0, s_4931_1, s_4931_2, s_4931_3, s_4931_4, s_4931_5, s_4931_6)
        let s_4931_7: () = DSPSR_SysRegRead32_b8ab5544c94609ec(
            state,
            tracer,
            s_4931_0,
            s_4931_1,
            s_4931_2,
            s_4931_3,
            s_4931_4,
            s_4931_5,
            s_4931_6,
        );
        // N s_4931_8: return
        return;
    }
    fn block_4932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4932_0: read-var opc2:u8
        let s_4932_0: u8 = fn_state.opc2;
        // D s_4932_1: cast zx s_4932_0 -> bv
        let s_4932_1: Bits = Bits::new(s_4932_0 as u128, 3u16);
        // C s_4932_2: const #0u : u8
        let s_4932_2: u8 = 0;
        // C s_4932_3: cast zx s_4932_2 -> bv
        let s_4932_3: Bits = Bits::new(s_4932_2 as u128, 3u16);
        // D s_4932_4: cmp-eq s_4932_1 s_4932_3
        let s_4932_4: bool = ((s_4932_1) == (s_4932_3));
        // D s_4932_5: write-var gs#118139 <= s_4932_4
        fn_state.gs_118139 = s_4932_4;
        // N s_4932_6: jump b1331
        return block_1331(state, tracer, fn_state);
    }
    fn block_4933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4933_0: read-var opc1:u8
        let s_4933_0: u8 = fn_state.opc1;
        // D s_4933_1: cast zx s_4933_0 -> bv
        let s_4933_1: Bits = Bits::new(s_4933_0 as u128, 3u16);
        // C s_4933_2: const #3u : u8
        let s_4933_2: u8 = 3;
        // C s_4933_3: cast zx s_4933_2 -> bv
        let s_4933_3: Bits = Bits::new(s_4933_2 as u128, 3u16);
        // D s_4933_4: cmp-eq s_4933_1 s_4933_3
        let s_4933_4: bool = ((s_4933_1) == (s_4933_3));
        // D s_4933_5: write-var gs#118138 <= s_4933_4
        fn_state.gs_118138 = s_4933_4;
        // N s_4933_6: jump b1329
        return block_1329(state, tracer, fn_state);
    }
    fn block_4934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4934_0: read-var coproc:u8
        let s_4934_0: u8 = fn_state.coproc;
        // D s_4934_1: cast zx s_4934_0 -> bv
        let s_4934_1: Bits = Bits::new(s_4934_0 as u128, 4u16);
        // C s_4934_2: const #15u : u8
        let s_4934_2: u8 = 15;
        // C s_4934_3: cast zx s_4934_2 -> bv
        let s_4934_3: Bits = Bits::new(s_4934_2 as u128, 4u16);
        // D s_4934_4: cmp-eq s_4934_1 s_4934_3
        let s_4934_4: bool = ((s_4934_1) == (s_4934_3));
        // D s_4934_5: write-var gs#118137 <= s_4934_4
        fn_state.gs_118137 = s_4934_4;
        // N s_4934_6: jump b1327
        return block_1327(state, tracer, fn_state);
    }
    fn block_4935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4935_0: read-var CRn:u8
        let s_4935_0: u8 = fn_state.CRn;
        // D s_4935_1: cast zx s_4935_0 -> bv
        let s_4935_1: Bits = Bits::new(s_4935_0 as u128, 4u16);
        // C s_4935_2: const #4u : u8
        let s_4935_2: u8 = 4;
        // C s_4935_3: cast zx s_4935_2 -> bv
        let s_4935_3: Bits = Bits::new(s_4935_2 as u128, 4u16);
        // D s_4935_4: cmp-eq s_4935_1 s_4935_3
        let s_4935_4: bool = ((s_4935_1) == (s_4935_3));
        // D s_4935_5: write-var gs#118136 <= s_4935_4
        fn_state.gs_118136 = s_4935_4;
        // N s_4935_6: jump b1325
        return block_1325(state, tracer, fn_state);
    }
    fn block_4936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4936_0: read-var el:u8
        let s_4936_0: u8 = fn_state.el;
        // D s_4936_1: read-var coproc:u8
        let s_4936_1: u8 = fn_state.coproc;
        // D s_4936_2: read-var opc1:u8
        let s_4936_2: u8 = fn_state.opc1;
        // D s_4936_3: read-var CRn:u8
        let s_4936_3: u8 = fn_state.CRn;
        // D s_4936_4: read-var opc2:u8
        let s_4936_4: u8 = fn_state.opc2;
        // D s_4936_5: read-var CRm:u8
        let s_4936_5: u8 = fn_state.CRm;
        // D s_4936_6: read-var t:i
        let s_4936_6: i128 = fn_state.t;
        // D s_4936_7: call HVBAR_SysRegRead32_d6c8aecebbe5fd70(s_4936_0, s_4936_1, s_4936_2, s_4936_3, s_4936_4, s_4936_5, s_4936_6)
        let s_4936_7: () = HVBAR_SysRegRead32_d6c8aecebbe5fd70(
            state,
            tracer,
            s_4936_0,
            s_4936_1,
            s_4936_2,
            s_4936_3,
            s_4936_4,
            s_4936_5,
            s_4936_6,
        );
        // N s_4936_8: return
        return;
    }
    fn block_4937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4937_0: read-var opc2:u8
        let s_4937_0: u8 = fn_state.opc2;
        // D s_4937_1: cast zx s_4937_0 -> bv
        let s_4937_1: Bits = Bits::new(s_4937_0 as u128, 3u16);
        // C s_4937_2: const #0u : u8
        let s_4937_2: u8 = 0;
        // C s_4937_3: cast zx s_4937_2 -> bv
        let s_4937_3: Bits = Bits::new(s_4937_2 as u128, 3u16);
        // D s_4937_4: cmp-eq s_4937_1 s_4937_3
        let s_4937_4: bool = ((s_4937_1) == (s_4937_3));
        // D s_4937_5: write-var gs#118135 <= s_4937_4
        fn_state.gs_118135 = s_4937_4;
        // N s_4937_6: jump b1322
        return block_1322(state, tracer, fn_state);
    }
    fn block_4938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4938_0: read-var opc1:u8
        let s_4938_0: u8 = fn_state.opc1;
        // D s_4938_1: cast zx s_4938_0 -> bv
        let s_4938_1: Bits = Bits::new(s_4938_0 as u128, 3u16);
        // C s_4938_2: const #4u : u8
        let s_4938_2: u8 = 4;
        // C s_4938_3: cast zx s_4938_2 -> bv
        let s_4938_3: Bits = Bits::new(s_4938_2 as u128, 3u16);
        // D s_4938_4: cmp-eq s_4938_1 s_4938_3
        let s_4938_4: bool = ((s_4938_1) == (s_4938_3));
        // D s_4938_5: write-var gs#118134 <= s_4938_4
        fn_state.gs_118134 = s_4938_4;
        // N s_4938_6: jump b1320
        return block_1320(state, tracer, fn_state);
    }
    fn block_4939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4939_0: read-var coproc:u8
        let s_4939_0: u8 = fn_state.coproc;
        // D s_4939_1: cast zx s_4939_0 -> bv
        let s_4939_1: Bits = Bits::new(s_4939_0 as u128, 4u16);
        // C s_4939_2: const #15u : u8
        let s_4939_2: u8 = 15;
        // C s_4939_3: cast zx s_4939_2 -> bv
        let s_4939_3: Bits = Bits::new(s_4939_2 as u128, 4u16);
        // D s_4939_4: cmp-eq s_4939_1 s_4939_3
        let s_4939_4: bool = ((s_4939_1) == (s_4939_3));
        // D s_4939_5: write-var gs#118133 <= s_4939_4
        fn_state.gs_118133 = s_4939_4;
        // N s_4939_6: jump b1318
        return block_1318(state, tracer, fn_state);
    }
    fn block_4940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4940_0: read-var CRn:u8
        let s_4940_0: u8 = fn_state.CRn;
        // D s_4940_1: cast zx s_4940_0 -> bv
        let s_4940_1: Bits = Bits::new(s_4940_0 as u128, 4u16);
        // C s_4940_2: const #12u : u8
        let s_4940_2: u8 = 12;
        // C s_4940_3: cast zx s_4940_2 -> bv
        let s_4940_3: Bits = Bits::new(s_4940_2 as u128, 4u16);
        // D s_4940_4: cmp-eq s_4940_1 s_4940_3
        let s_4940_4: bool = ((s_4940_1) == (s_4940_3));
        // D s_4940_5: write-var gs#118132 <= s_4940_4
        fn_state.gs_118132 = s_4940_4;
        // N s_4940_6: jump b1316
        return block_1316(state, tracer, fn_state);
    }
    fn block_4941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4941_0: read-var el:u8
        let s_4941_0: u8 = fn_state.el;
        // D s_4941_1: read-var coproc:u8
        let s_4941_1: u8 = fn_state.coproc;
        // D s_4941_2: read-var opc1:u8
        let s_4941_2: u8 = fn_state.opc1;
        // D s_4941_3: read-var CRn:u8
        let s_4941_3: u8 = fn_state.CRn;
        // D s_4941_4: read-var opc2:u8
        let s_4941_4: u8 = fn_state.opc2;
        // D s_4941_5: read-var CRm:u8
        let s_4941_5: u8 = fn_state.CRm;
        // D s_4941_6: read-var t:i
        let s_4941_6: i128 = fn_state.t;
        // D s_4941_7: call VMPIDR_SysRegRead32_2f5b95225c646973(s_4941_0, s_4941_1, s_4941_2, s_4941_3, s_4941_4, s_4941_5, s_4941_6)
        let s_4941_7: () = VMPIDR_SysRegRead32_2f5b95225c646973(
            state,
            tracer,
            s_4941_0,
            s_4941_1,
            s_4941_2,
            s_4941_3,
            s_4941_4,
            s_4941_5,
            s_4941_6,
        );
        // N s_4941_8: return
        return;
    }
    fn block_4942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4942_0: read-var opc2:u8
        let s_4942_0: u8 = fn_state.opc2;
        // D s_4942_1: cast zx s_4942_0 -> bv
        let s_4942_1: Bits = Bits::new(s_4942_0 as u128, 3u16);
        // C s_4942_2: const #5u : u8
        let s_4942_2: u8 = 5;
        // C s_4942_3: cast zx s_4942_2 -> bv
        let s_4942_3: Bits = Bits::new(s_4942_2 as u128, 3u16);
        // D s_4942_4: cmp-eq s_4942_1 s_4942_3
        let s_4942_4: bool = ((s_4942_1) == (s_4942_3));
        // D s_4942_5: write-var gs#118131 <= s_4942_4
        fn_state.gs_118131 = s_4942_4;
        // N s_4942_6: jump b1313
        return block_1313(state, tracer, fn_state);
    }
    fn block_4943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4943_0: read-var opc1:u8
        let s_4943_0: u8 = fn_state.opc1;
        // D s_4943_1: cast zx s_4943_0 -> bv
        let s_4943_1: Bits = Bits::new(s_4943_0 as u128, 3u16);
        // C s_4943_2: const #0u : u8
        let s_4943_2: u8 = 0;
        // C s_4943_3: cast zx s_4943_2 -> bv
        let s_4943_3: Bits = Bits::new(s_4943_2 as u128, 3u16);
        // D s_4943_4: cmp-eq s_4943_1 s_4943_3
        let s_4943_4: bool = ((s_4943_1) == (s_4943_3));
        // D s_4943_5: write-var gs#118130 <= s_4943_4
        fn_state.gs_118130 = s_4943_4;
        // N s_4943_6: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_4944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4944_0: read-var coproc:u8
        let s_4944_0: u8 = fn_state.coproc;
        // D s_4944_1: cast zx s_4944_0 -> bv
        let s_4944_1: Bits = Bits::new(s_4944_0 as u128, 4u16);
        // C s_4944_2: const #15u : u8
        let s_4944_2: u8 = 15;
        // C s_4944_3: cast zx s_4944_2 -> bv
        let s_4944_3: Bits = Bits::new(s_4944_2 as u128, 4u16);
        // D s_4944_4: cmp-eq s_4944_1 s_4944_3
        let s_4944_4: bool = ((s_4944_1) == (s_4944_3));
        // D s_4944_5: write-var gs#118129 <= s_4944_4
        fn_state.gs_118129 = s_4944_4;
        // N s_4944_6: jump b1309
        return block_1309(state, tracer, fn_state);
    }
    fn block_4945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4945_0: read-var CRn:u8
        let s_4945_0: u8 = fn_state.CRn;
        // D s_4945_1: cast zx s_4945_0 -> bv
        let s_4945_1: Bits = Bits::new(s_4945_0 as u128, 4u16);
        // C s_4945_2: const #0u : u8
        let s_4945_2: u8 = 0;
        // C s_4945_3: cast zx s_4945_2 -> bv
        let s_4945_3: Bits = Bits::new(s_4945_2 as u128, 4u16);
        // D s_4945_4: cmp-eq s_4945_1 s_4945_3
        let s_4945_4: bool = ((s_4945_1) == (s_4945_3));
        // D s_4945_5: write-var gs#118128 <= s_4945_4
        fn_state.gs_118128 = s_4945_4;
        // N s_4945_6: jump b1307
        return block_1307(state, tracer, fn_state);
    }
    fn block_4946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4946_0: read-var el:u8
        let s_4946_0: u8 = fn_state.el;
        // D s_4946_1: read-var coproc:u8
        let s_4946_1: u8 = fn_state.coproc;
        // D s_4946_2: read-var opc1:u8
        let s_4946_2: u8 = fn_state.opc1;
        // D s_4946_3: read-var CRn:u8
        let s_4946_3: u8 = fn_state.CRn;
        // D s_4946_4: read-var opc2:u8
        let s_4946_4: u8 = fn_state.opc2;
        // D s_4946_5: read-var CRm:u8
        let s_4946_5: u8 = fn_state.CRm;
        // D s_4946_6: read-var t:i
        let s_4946_6: i128 = fn_state.t;
        // D s_4946_7: call VMPIDR_SysRegRead32_e5aa49e29a7b94ba(s_4946_0, s_4946_1, s_4946_2, s_4946_3, s_4946_4, s_4946_5, s_4946_6)
        let s_4946_7: () = VMPIDR_SysRegRead32_e5aa49e29a7b94ba(
            state,
            tracer,
            s_4946_0,
            s_4946_1,
            s_4946_2,
            s_4946_3,
            s_4946_4,
            s_4946_5,
            s_4946_6,
        );
        // N s_4946_8: return
        return;
    }
    fn block_4947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4947_0: read-var opc2:u8
        let s_4947_0: u8 = fn_state.opc2;
        // D s_4947_1: cast zx s_4947_0 -> bv
        let s_4947_1: Bits = Bits::new(s_4947_0 as u128, 3u16);
        // C s_4947_2: const #5u : u8
        let s_4947_2: u8 = 5;
        // C s_4947_3: cast zx s_4947_2 -> bv
        let s_4947_3: Bits = Bits::new(s_4947_2 as u128, 3u16);
        // D s_4947_4: cmp-eq s_4947_1 s_4947_3
        let s_4947_4: bool = ((s_4947_1) == (s_4947_3));
        // D s_4947_5: write-var gs#118127 <= s_4947_4
        fn_state.gs_118127 = s_4947_4;
        // N s_4947_6: jump b1304
        return block_1304(state, tracer, fn_state);
    }
    fn block_4948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4948_0: read-var opc1:u8
        let s_4948_0: u8 = fn_state.opc1;
        // D s_4948_1: cast zx s_4948_0 -> bv
        let s_4948_1: Bits = Bits::new(s_4948_0 as u128, 3u16);
        // C s_4948_2: const #4u : u8
        let s_4948_2: u8 = 4;
        // C s_4948_3: cast zx s_4948_2 -> bv
        let s_4948_3: Bits = Bits::new(s_4948_2 as u128, 3u16);
        // D s_4948_4: cmp-eq s_4948_1 s_4948_3
        let s_4948_4: bool = ((s_4948_1) == (s_4948_3));
        // D s_4948_5: write-var gs#118126 <= s_4948_4
        fn_state.gs_118126 = s_4948_4;
        // N s_4948_6: jump b1302
        return block_1302(state, tracer, fn_state);
    }
    fn block_4949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4949_0: read-var coproc:u8
        let s_4949_0: u8 = fn_state.coproc;
        // D s_4949_1: cast zx s_4949_0 -> bv
        let s_4949_1: Bits = Bits::new(s_4949_0 as u128, 4u16);
        // C s_4949_2: const #15u : u8
        let s_4949_2: u8 = 15;
        // C s_4949_3: cast zx s_4949_2 -> bv
        let s_4949_3: Bits = Bits::new(s_4949_2 as u128, 4u16);
        // D s_4949_4: cmp-eq s_4949_1 s_4949_3
        let s_4949_4: bool = ((s_4949_1) == (s_4949_3));
        // D s_4949_5: write-var gs#118125 <= s_4949_4
        fn_state.gs_118125 = s_4949_4;
        // N s_4949_6: jump b1300
        return block_1300(state, tracer, fn_state);
    }
    fn block_4950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4950_0: read-var CRn:u8
        let s_4950_0: u8 = fn_state.CRn;
        // D s_4950_1: cast zx s_4950_0 -> bv
        let s_4950_1: Bits = Bits::new(s_4950_0 as u128, 4u16);
        // C s_4950_2: const #0u : u8
        let s_4950_2: u8 = 0;
        // C s_4950_3: cast zx s_4950_2 -> bv
        let s_4950_3: Bits = Bits::new(s_4950_2 as u128, 4u16);
        // D s_4950_4: cmp-eq s_4950_1 s_4950_3
        let s_4950_4: bool = ((s_4950_1) == (s_4950_3));
        // D s_4950_5: write-var gs#118124 <= s_4950_4
        fn_state.gs_118124 = s_4950_4;
        // N s_4950_6: jump b1298
        return block_1298(state, tracer, fn_state);
    }
    fn block_4951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4951_0: read-var el:u8
        let s_4951_0: u8 = fn_state.el;
        // D s_4951_1: read-var coproc:u8
        let s_4951_1: u8 = fn_state.coproc;
        // D s_4951_2: read-var opc1:u8
        let s_4951_2: u8 = fn_state.opc1;
        // D s_4951_3: read-var CRn:u8
        let s_4951_3: u8 = fn_state.CRn;
        // D s_4951_4: read-var opc2:u8
        let s_4951_4: u8 = fn_state.opc2;
        // D s_4951_5: read-var CRm:u8
        let s_4951_5: u8 = fn_state.CRm;
        // D s_4951_6: read-var t:i
        let s_4951_6: i128 = fn_state.t;
        // D s_4951_7: call PMMIR_SysRegRead32_39e2ebac78343651(s_4951_0, s_4951_1, s_4951_2, s_4951_3, s_4951_4, s_4951_5, s_4951_6)
        let s_4951_7: () = PMMIR_SysRegRead32_39e2ebac78343651(
            state,
            tracer,
            s_4951_0,
            s_4951_1,
            s_4951_2,
            s_4951_3,
            s_4951_4,
            s_4951_5,
            s_4951_6,
        );
        // N s_4951_8: return
        return;
    }
    fn block_4952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4952_0: read-var opc2:u8
        let s_4952_0: u8 = fn_state.opc2;
        // D s_4952_1: cast zx s_4952_0 -> bv
        let s_4952_1: Bits = Bits::new(s_4952_0 as u128, 3u16);
        // C s_4952_2: const #6u : u8
        let s_4952_2: u8 = 6;
        // C s_4952_3: cast zx s_4952_2 -> bv
        let s_4952_3: Bits = Bits::new(s_4952_2 as u128, 3u16);
        // D s_4952_4: cmp-eq s_4952_1 s_4952_3
        let s_4952_4: bool = ((s_4952_1) == (s_4952_3));
        // D s_4952_5: write-var gs#118123 <= s_4952_4
        fn_state.gs_118123 = s_4952_4;
        // N s_4952_6: jump b1295
        return block_1295(state, tracer, fn_state);
    }
    fn block_4953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4953_0: read-var opc1:u8
        let s_4953_0: u8 = fn_state.opc1;
        // D s_4953_1: cast zx s_4953_0 -> bv
        let s_4953_1: Bits = Bits::new(s_4953_0 as u128, 3u16);
        // C s_4953_2: const #0u : u8
        let s_4953_2: u8 = 0;
        // C s_4953_3: cast zx s_4953_2 -> bv
        let s_4953_3: Bits = Bits::new(s_4953_2 as u128, 3u16);
        // D s_4953_4: cmp-eq s_4953_1 s_4953_3
        let s_4953_4: bool = ((s_4953_1) == (s_4953_3));
        // D s_4953_5: write-var gs#118122 <= s_4953_4
        fn_state.gs_118122 = s_4953_4;
        // N s_4953_6: jump b1293
        return block_1293(state, tracer, fn_state);
    }
    fn block_4954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4954_0: read-var coproc:u8
        let s_4954_0: u8 = fn_state.coproc;
        // D s_4954_1: cast zx s_4954_0 -> bv
        let s_4954_1: Bits = Bits::new(s_4954_0 as u128, 4u16);
        // C s_4954_2: const #15u : u8
        let s_4954_2: u8 = 15;
        // C s_4954_3: cast zx s_4954_2 -> bv
        let s_4954_3: Bits = Bits::new(s_4954_2 as u128, 4u16);
        // D s_4954_4: cmp-eq s_4954_1 s_4954_3
        let s_4954_4: bool = ((s_4954_1) == (s_4954_3));
        // D s_4954_5: write-var gs#118121 <= s_4954_4
        fn_state.gs_118121 = s_4954_4;
        // N s_4954_6: jump b1291
        return block_1291(state, tracer, fn_state);
    }
    fn block_4955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4955_0: read-var CRn:u8
        let s_4955_0: u8 = fn_state.CRn;
        // D s_4955_1: cast zx s_4955_0 -> bv
        let s_4955_1: Bits = Bits::new(s_4955_0 as u128, 4u16);
        // C s_4955_2: const #9u : u8
        let s_4955_2: u8 = 9;
        // C s_4955_3: cast zx s_4955_2 -> bv
        let s_4955_3: Bits = Bits::new(s_4955_2 as u128, 4u16);
        // D s_4955_4: cmp-eq s_4955_1 s_4955_3
        let s_4955_4: bool = ((s_4955_1) == (s_4955_3));
        // D s_4955_5: write-var gs#118120 <= s_4955_4
        fn_state.gs_118120 = s_4955_4;
        // N s_4955_6: jump b1289
        return block_1289(state, tracer, fn_state);
    }
    fn block_4956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4956_0: read-var el:u8
        let s_4956_0: u8 = fn_state.el;
        // D s_4956_1: read-var coproc:u8
        let s_4956_1: u8 = fn_state.coproc;
        // D s_4956_2: read-var opc1:u8
        let s_4956_2: u8 = fn_state.opc1;
        // D s_4956_3: read-var CRn:u8
        let s_4956_3: u8 = fn_state.CRn;
        // D s_4956_4: read-var opc2:u8
        let s_4956_4: u8 = fn_state.opc2;
        // D s_4956_5: read-var CRm:u8
        let s_4956_5: u8 = fn_state.CRm;
        // D s_4956_6: read-var t:i
        let s_4956_6: i128 = fn_state.t;
        // D s_4956_7: call ICC_MSRE_SysRegRead32_79a8be5256989c32(s_4956_0, s_4956_1, s_4956_2, s_4956_3, s_4956_4, s_4956_5, s_4956_6)
        let s_4956_7: () = ICC_MSRE_SysRegRead32_79a8be5256989c32(
            state,
            tracer,
            s_4956_0,
            s_4956_1,
            s_4956_2,
            s_4956_3,
            s_4956_4,
            s_4956_5,
            s_4956_6,
        );
        // N s_4956_8: return
        return;
    }
    fn block_4957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4957_0: read-var opc2:u8
        let s_4957_0: u8 = fn_state.opc2;
        // D s_4957_1: cast zx s_4957_0 -> bv
        let s_4957_1: Bits = Bits::new(s_4957_0 as u128, 3u16);
        // C s_4957_2: const #5u : u8
        let s_4957_2: u8 = 5;
        // C s_4957_3: cast zx s_4957_2 -> bv
        let s_4957_3: Bits = Bits::new(s_4957_2 as u128, 3u16);
        // D s_4957_4: cmp-eq s_4957_1 s_4957_3
        let s_4957_4: bool = ((s_4957_1) == (s_4957_3));
        // D s_4957_5: write-var gs#118119 <= s_4957_4
        fn_state.gs_118119 = s_4957_4;
        // N s_4957_6: jump b1286
        return block_1286(state, tracer, fn_state);
    }
    fn block_4958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4958_0: read-var opc1:u8
        let s_4958_0: u8 = fn_state.opc1;
        // D s_4958_1: cast zx s_4958_0 -> bv
        let s_4958_1: Bits = Bits::new(s_4958_0 as u128, 3u16);
        // C s_4958_2: const #6u : u8
        let s_4958_2: u8 = 6;
        // C s_4958_3: cast zx s_4958_2 -> bv
        let s_4958_3: Bits = Bits::new(s_4958_2 as u128, 3u16);
        // D s_4958_4: cmp-eq s_4958_1 s_4958_3
        let s_4958_4: bool = ((s_4958_1) == (s_4958_3));
        // D s_4958_5: write-var gs#118118 <= s_4958_4
        fn_state.gs_118118 = s_4958_4;
        // N s_4958_6: jump b1284
        return block_1284(state, tracer, fn_state);
    }
    fn block_4959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4959_0: read-var coproc:u8
        let s_4959_0: u8 = fn_state.coproc;
        // D s_4959_1: cast zx s_4959_0 -> bv
        let s_4959_1: Bits = Bits::new(s_4959_0 as u128, 4u16);
        // C s_4959_2: const #15u : u8
        let s_4959_2: u8 = 15;
        // C s_4959_3: cast zx s_4959_2 -> bv
        let s_4959_3: Bits = Bits::new(s_4959_2 as u128, 4u16);
        // D s_4959_4: cmp-eq s_4959_1 s_4959_3
        let s_4959_4: bool = ((s_4959_1) == (s_4959_3));
        // D s_4959_5: write-var gs#118117 <= s_4959_4
        fn_state.gs_118117 = s_4959_4;
        // N s_4959_6: jump b1282
        return block_1282(state, tracer, fn_state);
    }
    fn block_4960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4960_0: read-var CRn:u8
        let s_4960_0: u8 = fn_state.CRn;
        // D s_4960_1: cast zx s_4960_0 -> bv
        let s_4960_1: Bits = Bits::new(s_4960_0 as u128, 4u16);
        // C s_4960_2: const #12u : u8
        let s_4960_2: u8 = 12;
        // C s_4960_3: cast zx s_4960_2 -> bv
        let s_4960_3: Bits = Bits::new(s_4960_2 as u128, 4u16);
        // D s_4960_4: cmp-eq s_4960_1 s_4960_3
        let s_4960_4: bool = ((s_4960_1) == (s_4960_3));
        // D s_4960_5: write-var gs#118116 <= s_4960_4
        fn_state.gs_118116 = s_4960_4;
        // N s_4960_6: jump b1280
        return block_1280(state, tracer, fn_state);
    }
    fn block_4961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4961_0: read-var el:u8
        let s_4961_0: u8 = fn_state.el;
        // D s_4961_1: read-var coproc:u8
        let s_4961_1: u8 = fn_state.coproc;
        // D s_4961_2: read-var opc1:u8
        let s_4961_2: u8 = fn_state.opc1;
        // D s_4961_3: read-var CRn:u8
        let s_4961_3: u8 = fn_state.CRn;
        // D s_4961_4: read-var opc2:u8
        let s_4961_4: u8 = fn_state.opc2;
        // D s_4961_5: read-var CRm:u8
        let s_4961_5: u8 = fn_state.CRm;
        // D s_4961_6: read-var t:i
        let s_4961_6: i128 = fn_state.t;
        // D s_4961_7: call ID_MMFR1_SysRegRead32_1bde596fb100a5b5(s_4961_0, s_4961_1, s_4961_2, s_4961_3, s_4961_4, s_4961_5, s_4961_6)
        let s_4961_7: () = ID_MMFR1_SysRegRead32_1bde596fb100a5b5(
            state,
            tracer,
            s_4961_0,
            s_4961_1,
            s_4961_2,
            s_4961_3,
            s_4961_4,
            s_4961_5,
            s_4961_6,
        );
        // N s_4961_8: return
        return;
    }
    fn block_4962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4962_0: read-var opc2:u8
        let s_4962_0: u8 = fn_state.opc2;
        // D s_4962_1: cast zx s_4962_0 -> bv
        let s_4962_1: Bits = Bits::new(s_4962_0 as u128, 3u16);
        // C s_4962_2: const #5u : u8
        let s_4962_2: u8 = 5;
        // C s_4962_3: cast zx s_4962_2 -> bv
        let s_4962_3: Bits = Bits::new(s_4962_2 as u128, 3u16);
        // D s_4962_4: cmp-eq s_4962_1 s_4962_3
        let s_4962_4: bool = ((s_4962_1) == (s_4962_3));
        // D s_4962_5: write-var gs#118115 <= s_4962_4
        fn_state.gs_118115 = s_4962_4;
        // N s_4962_6: jump b1277
        return block_1277(state, tracer, fn_state);
    }
    fn block_4963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4963_0: read-var opc1:u8
        let s_4963_0: u8 = fn_state.opc1;
        // D s_4963_1: cast zx s_4963_0 -> bv
        let s_4963_1: Bits = Bits::new(s_4963_0 as u128, 3u16);
        // C s_4963_2: const #0u : u8
        let s_4963_2: u8 = 0;
        // C s_4963_3: cast zx s_4963_2 -> bv
        let s_4963_3: Bits = Bits::new(s_4963_2 as u128, 3u16);
        // D s_4963_4: cmp-eq s_4963_1 s_4963_3
        let s_4963_4: bool = ((s_4963_1) == (s_4963_3));
        // D s_4963_5: write-var gs#118114 <= s_4963_4
        fn_state.gs_118114 = s_4963_4;
        // N s_4963_6: jump b1275
        return block_1275(state, tracer, fn_state);
    }
    fn block_4964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4964_0: read-var coproc:u8
        let s_4964_0: u8 = fn_state.coproc;
        // D s_4964_1: cast zx s_4964_0 -> bv
        let s_4964_1: Bits = Bits::new(s_4964_0 as u128, 4u16);
        // C s_4964_2: const #15u : u8
        let s_4964_2: u8 = 15;
        // C s_4964_3: cast zx s_4964_2 -> bv
        let s_4964_3: Bits = Bits::new(s_4964_2 as u128, 4u16);
        // D s_4964_4: cmp-eq s_4964_1 s_4964_3
        let s_4964_4: bool = ((s_4964_1) == (s_4964_3));
        // D s_4964_5: write-var gs#118113 <= s_4964_4
        fn_state.gs_118113 = s_4964_4;
        // N s_4964_6: jump b1273
        return block_1273(state, tracer, fn_state);
    }
    fn block_4965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4965_0: read-var CRn:u8
        let s_4965_0: u8 = fn_state.CRn;
        // D s_4965_1: cast zx s_4965_0 -> bv
        let s_4965_1: Bits = Bits::new(s_4965_0 as u128, 4u16);
        // C s_4965_2: const #0u : u8
        let s_4965_2: u8 = 0;
        // C s_4965_3: cast zx s_4965_2 -> bv
        let s_4965_3: Bits = Bits::new(s_4965_2 as u128, 4u16);
        // D s_4965_4: cmp-eq s_4965_1 s_4965_3
        let s_4965_4: bool = ((s_4965_1) == (s_4965_3));
        // D s_4965_5: write-var gs#118112 <= s_4965_4
        fn_state.gs_118112 = s_4965_4;
        // N s_4965_6: jump b1271
        return block_1271(state, tracer, fn_state);
    }
    fn block_4966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4966_0: read-var el:u8
        let s_4966_0: u8 = fn_state.el;
        // D s_4966_1: read-var coproc:u8
        let s_4966_1: u8 = fn_state.coproc;
        // D s_4966_2: read-var opc1:u8
        let s_4966_2: u8 = fn_state.opc1;
        // D s_4966_3: read-var CRn:u8
        let s_4966_3: u8 = fn_state.CRn;
        // D s_4966_4: read-var opc2:u8
        let s_4966_4: u8 = fn_state.opc2;
        // D s_4966_5: read-var CRm:u8
        let s_4966_5: u8 = fn_state.CRm;
        // D s_4966_6: read-var t:i
        let s_4966_6: i128 = fn_state.t;
        // D s_4966_7: call REVIDR_SysRegRead32_423676c78008247b(s_4966_0, s_4966_1, s_4966_2, s_4966_3, s_4966_4, s_4966_5, s_4966_6)
        let s_4966_7: () = REVIDR_SysRegRead32_423676c78008247b(
            state,
            tracer,
            s_4966_0,
            s_4966_1,
            s_4966_2,
            s_4966_3,
            s_4966_4,
            s_4966_5,
            s_4966_6,
        );
        // N s_4966_8: return
        return;
    }
    fn block_4967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4967_0: read-var opc2:u8
        let s_4967_0: u8 = fn_state.opc2;
        // D s_4967_1: cast zx s_4967_0 -> bv
        let s_4967_1: Bits = Bits::new(s_4967_0 as u128, 3u16);
        // C s_4967_2: const #6u : u8
        let s_4967_2: u8 = 6;
        // C s_4967_3: cast zx s_4967_2 -> bv
        let s_4967_3: Bits = Bits::new(s_4967_2 as u128, 3u16);
        // D s_4967_4: cmp-eq s_4967_1 s_4967_3
        let s_4967_4: bool = ((s_4967_1) == (s_4967_3));
        // D s_4967_5: write-var gs#118111 <= s_4967_4
        fn_state.gs_118111 = s_4967_4;
        // N s_4967_6: jump b1268
        return block_1268(state, tracer, fn_state);
    }
    fn block_4968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4968_0: read-var opc1:u8
        let s_4968_0: u8 = fn_state.opc1;
        // D s_4968_1: cast zx s_4968_0 -> bv
        let s_4968_1: Bits = Bits::new(s_4968_0 as u128, 3u16);
        // C s_4968_2: const #0u : u8
        let s_4968_2: u8 = 0;
        // C s_4968_3: cast zx s_4968_2 -> bv
        let s_4968_3: Bits = Bits::new(s_4968_2 as u128, 3u16);
        // D s_4968_4: cmp-eq s_4968_1 s_4968_3
        let s_4968_4: bool = ((s_4968_1) == (s_4968_3));
        // D s_4968_5: write-var gs#118110 <= s_4968_4
        fn_state.gs_118110 = s_4968_4;
        // N s_4968_6: jump b1266
        return block_1266(state, tracer, fn_state);
    }
    fn block_4969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4969_0: read-var coproc:u8
        let s_4969_0: u8 = fn_state.coproc;
        // D s_4969_1: cast zx s_4969_0 -> bv
        let s_4969_1: Bits = Bits::new(s_4969_0 as u128, 4u16);
        // C s_4969_2: const #15u : u8
        let s_4969_2: u8 = 15;
        // C s_4969_3: cast zx s_4969_2 -> bv
        let s_4969_3: Bits = Bits::new(s_4969_2 as u128, 4u16);
        // D s_4969_4: cmp-eq s_4969_1 s_4969_3
        let s_4969_4: bool = ((s_4969_1) == (s_4969_3));
        // D s_4969_5: write-var gs#118109 <= s_4969_4
        fn_state.gs_118109 = s_4969_4;
        // N s_4969_6: jump b1264
        return block_1264(state, tracer, fn_state);
    }
    fn block_4970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4970_0: read-var CRn:u8
        let s_4970_0: u8 = fn_state.CRn;
        // D s_4970_1: cast zx s_4970_0 -> bv
        let s_4970_1: Bits = Bits::new(s_4970_0 as u128, 4u16);
        // C s_4970_2: const #0u : u8
        let s_4970_2: u8 = 0;
        // C s_4970_3: cast zx s_4970_2 -> bv
        let s_4970_3: Bits = Bits::new(s_4970_2 as u128, 4u16);
        // D s_4970_4: cmp-eq s_4970_1 s_4970_3
        let s_4970_4: bool = ((s_4970_1) == (s_4970_3));
        // D s_4970_5: write-var gs#118108 <= s_4970_4
        fn_state.gs_118108 = s_4970_4;
        // N s_4970_6: jump b1262
        return block_1262(state, tracer, fn_state);
    }
    fn block_4971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4971_0: read-var el:u8
        let s_4971_0: u8 = fn_state.el;
        // D s_4971_1: read-var coproc:u8
        let s_4971_1: u8 = fn_state.coproc;
        // D s_4971_2: read-var opc1:u8
        let s_4971_2: u8 = fn_state.opc1;
        // D s_4971_3: read-var CRn:u8
        let s_4971_3: u8 = fn_state.CRn;
        // D s_4971_4: read-var opc2:u8
        let s_4971_4: u8 = fn_state.opc2;
        // D s_4971_5: read-var CRm:u8
        let s_4971_5: u8 = fn_state.CRm;
        // D s_4971_6: read-var t:i
        let s_4971_6: i128 = fn_state.t;
        // D s_4971_7: call DBGVCR_SysRegRead32_19db55a72a941c5f(s_4971_0, s_4971_1, s_4971_2, s_4971_3, s_4971_4, s_4971_5, s_4971_6)
        let s_4971_7: () = DBGVCR_SysRegRead32_19db55a72a941c5f(
            state,
            tracer,
            s_4971_0,
            s_4971_1,
            s_4971_2,
            s_4971_3,
            s_4971_4,
            s_4971_5,
            s_4971_6,
        );
        // N s_4971_8: return
        return;
    }
    fn block_4972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4972_0: read-var opc2:u8
        let s_4972_0: u8 = fn_state.opc2;
        // D s_4972_1: cast zx s_4972_0 -> bv
        let s_4972_1: Bits = Bits::new(s_4972_0 as u128, 3u16);
        // C s_4972_2: const #0u : u8
        let s_4972_2: u8 = 0;
        // C s_4972_3: cast zx s_4972_2 -> bv
        let s_4972_3: Bits = Bits::new(s_4972_2 as u128, 3u16);
        // D s_4972_4: cmp-eq s_4972_1 s_4972_3
        let s_4972_4: bool = ((s_4972_1) == (s_4972_3));
        // D s_4972_5: write-var gs#118107 <= s_4972_4
        fn_state.gs_118107 = s_4972_4;
        // N s_4972_6: jump b1259
        return block_1259(state, tracer, fn_state);
    }
    fn block_4973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4973_0: read-var opc1:u8
        let s_4973_0: u8 = fn_state.opc1;
        // D s_4973_1: cast zx s_4973_0 -> bv
        let s_4973_1: Bits = Bits::new(s_4973_0 as u128, 3u16);
        // C s_4973_2: const #0u : u8
        let s_4973_2: u8 = 0;
        // C s_4973_3: cast zx s_4973_2 -> bv
        let s_4973_3: Bits = Bits::new(s_4973_2 as u128, 3u16);
        // D s_4973_4: cmp-eq s_4973_1 s_4973_3
        let s_4973_4: bool = ((s_4973_1) == (s_4973_3));
        // D s_4973_5: write-var gs#118106 <= s_4973_4
        fn_state.gs_118106 = s_4973_4;
        // N s_4973_6: jump b1257
        return block_1257(state, tracer, fn_state);
    }
    fn block_4974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4974_0: read-var coproc:u8
        let s_4974_0: u8 = fn_state.coproc;
        // D s_4974_1: cast zx s_4974_0 -> bv
        let s_4974_1: Bits = Bits::new(s_4974_0 as u128, 4u16);
        // C s_4974_2: const #14u : u8
        let s_4974_2: u8 = 14;
        // C s_4974_3: cast zx s_4974_2 -> bv
        let s_4974_3: Bits = Bits::new(s_4974_2 as u128, 4u16);
        // D s_4974_4: cmp-eq s_4974_1 s_4974_3
        let s_4974_4: bool = ((s_4974_1) == (s_4974_3));
        // D s_4974_5: write-var gs#118105 <= s_4974_4
        fn_state.gs_118105 = s_4974_4;
        // N s_4974_6: jump b1255
        return block_1255(state, tracer, fn_state);
    }
    fn block_4975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4975_0: read-var CRn:u8
        let s_4975_0: u8 = fn_state.CRn;
        // D s_4975_1: cast zx s_4975_0 -> bv
        let s_4975_1: Bits = Bits::new(s_4975_0 as u128, 4u16);
        // C s_4975_2: const #0u : u8
        let s_4975_2: u8 = 0;
        // C s_4975_3: cast zx s_4975_2 -> bv
        let s_4975_3: Bits = Bits::new(s_4975_2 as u128, 4u16);
        // D s_4975_4: cmp-eq s_4975_1 s_4975_3
        let s_4975_4: bool = ((s_4975_1) == (s_4975_3));
        // D s_4975_5: write-var gs#118104 <= s_4975_4
        fn_state.gs_118104 = s_4975_4;
        // N s_4975_6: jump b1253
        return block_1253(state, tracer, fn_state);
    }
    fn block_4976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4976_0: read-var el:u8
        let s_4976_0: u8 = fn_state.el;
        // D s_4976_1: read-var coproc:u8
        let s_4976_1: u8 = fn_state.coproc;
        // D s_4976_2: read-var opc1:u8
        let s_4976_2: u8 = fn_state.opc1;
        // D s_4976_3: read-var CRn:u8
        let s_4976_3: u8 = fn_state.CRn;
        // D s_4976_4: read-var opc2:u8
        let s_4976_4: u8 = fn_state.opc2;
        // D s_4976_5: read-var CRm:u8
        let s_4976_5: u8 = fn_state.CRm;
        // D s_4976_6: read-var t:i
        let s_4976_6: i128 = fn_state.t;
        // D s_4976_7: call CNTHCTL_SysRegRead32_36df328680cb805f(s_4976_0, s_4976_1, s_4976_2, s_4976_3, s_4976_4, s_4976_5, s_4976_6)
        let s_4976_7: () = CNTHCTL_SysRegRead32_36df328680cb805f(
            state,
            tracer,
            s_4976_0,
            s_4976_1,
            s_4976_2,
            s_4976_3,
            s_4976_4,
            s_4976_5,
            s_4976_6,
        );
        // N s_4976_8: return
        return;
    }
    fn block_4977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4977_0: read-var opc2:u8
        let s_4977_0: u8 = fn_state.opc2;
        // D s_4977_1: cast zx s_4977_0 -> bv
        let s_4977_1: Bits = Bits::new(s_4977_0 as u128, 3u16);
        // C s_4977_2: const #0u : u8
        let s_4977_2: u8 = 0;
        // C s_4977_3: cast zx s_4977_2 -> bv
        let s_4977_3: Bits = Bits::new(s_4977_2 as u128, 3u16);
        // D s_4977_4: cmp-eq s_4977_1 s_4977_3
        let s_4977_4: bool = ((s_4977_1) == (s_4977_3));
        // D s_4977_5: write-var gs#118103 <= s_4977_4
        fn_state.gs_118103 = s_4977_4;
        // N s_4977_6: jump b1250
        return block_1250(state, tracer, fn_state);
    }
    fn block_4978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4978_0: read-var opc1:u8
        let s_4978_0: u8 = fn_state.opc1;
        // D s_4978_1: cast zx s_4978_0 -> bv
        let s_4978_1: Bits = Bits::new(s_4978_0 as u128, 3u16);
        // C s_4978_2: const #4u : u8
        let s_4978_2: u8 = 4;
        // C s_4978_3: cast zx s_4978_2 -> bv
        let s_4978_3: Bits = Bits::new(s_4978_2 as u128, 3u16);
        // D s_4978_4: cmp-eq s_4978_1 s_4978_3
        let s_4978_4: bool = ((s_4978_1) == (s_4978_3));
        // D s_4978_5: write-var gs#118102 <= s_4978_4
        fn_state.gs_118102 = s_4978_4;
        // N s_4978_6: jump b1248
        return block_1248(state, tracer, fn_state);
    }
    fn block_4979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4979_0: read-var coproc:u8
        let s_4979_0: u8 = fn_state.coproc;
        // D s_4979_1: cast zx s_4979_0 -> bv
        let s_4979_1: Bits = Bits::new(s_4979_0 as u128, 4u16);
        // C s_4979_2: const #15u : u8
        let s_4979_2: u8 = 15;
        // C s_4979_3: cast zx s_4979_2 -> bv
        let s_4979_3: Bits = Bits::new(s_4979_2 as u128, 4u16);
        // D s_4979_4: cmp-eq s_4979_1 s_4979_3
        let s_4979_4: bool = ((s_4979_1) == (s_4979_3));
        // D s_4979_5: write-var gs#118101 <= s_4979_4
        fn_state.gs_118101 = s_4979_4;
        // N s_4979_6: jump b1246
        return block_1246(state, tracer, fn_state);
    }
    fn block_4980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4980_0: read-var CRn:u8
        let s_4980_0: u8 = fn_state.CRn;
        // D s_4980_1: cast zx s_4980_0 -> bv
        let s_4980_1: Bits = Bits::new(s_4980_0 as u128, 4u16);
        // C s_4980_2: const #14u : u8
        let s_4980_2: u8 = 14;
        // C s_4980_3: cast zx s_4980_2 -> bv
        let s_4980_3: Bits = Bits::new(s_4980_2 as u128, 4u16);
        // D s_4980_4: cmp-eq s_4980_1 s_4980_3
        let s_4980_4: bool = ((s_4980_1) == (s_4980_3));
        // D s_4980_5: write-var gs#118100 <= s_4980_4
        fn_state.gs_118100 = s_4980_4;
        // N s_4980_6: jump b1244
        return block_1244(state, tracer, fn_state);
    }
    fn block_4981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4981_0: read-var el:u8
        let s_4981_0: u8 = fn_state.el;
        // D s_4981_1: read-var coproc:u8
        let s_4981_1: u8 = fn_state.coproc;
        // D s_4981_2: read-var opc1:u8
        let s_4981_2: u8 = fn_state.opc1;
        // D s_4981_3: read-var CRn:u8
        let s_4981_3: u8 = fn_state.CRn;
        // D s_4981_4: read-var opc2:u8
        let s_4981_4: u8 = fn_state.opc2;
        // D s_4981_5: read-var CRm:u8
        let s_4981_5: u8 = fn_state.CRm;
        // D s_4981_6: read-var t:i
        let s_4981_6: i128 = fn_state.t;
        // D s_4981_7: call ADFSR_SysRegRead32_12834f15645083f8(s_4981_0, s_4981_1, s_4981_2, s_4981_3, s_4981_4, s_4981_5, s_4981_6)
        let s_4981_7: () = ADFSR_SysRegRead32_12834f15645083f8(
            state,
            tracer,
            s_4981_0,
            s_4981_1,
            s_4981_2,
            s_4981_3,
            s_4981_4,
            s_4981_5,
            s_4981_6,
        );
        // N s_4981_8: return
        return;
    }
    fn block_4982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4982_0: read-var opc2:u8
        let s_4982_0: u8 = fn_state.opc2;
        // D s_4982_1: cast zx s_4982_0 -> bv
        let s_4982_1: Bits = Bits::new(s_4982_0 as u128, 3u16);
        // C s_4982_2: const #0u : u8
        let s_4982_2: u8 = 0;
        // C s_4982_3: cast zx s_4982_2 -> bv
        let s_4982_3: Bits = Bits::new(s_4982_2 as u128, 3u16);
        // D s_4982_4: cmp-eq s_4982_1 s_4982_3
        let s_4982_4: bool = ((s_4982_1) == (s_4982_3));
        // D s_4982_5: write-var gs#118099 <= s_4982_4
        fn_state.gs_118099 = s_4982_4;
        // N s_4982_6: jump b1241
        return block_1241(state, tracer, fn_state);
    }
    fn block_4983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4983_0: read-var opc1:u8
        let s_4983_0: u8 = fn_state.opc1;
        // D s_4983_1: cast zx s_4983_0 -> bv
        let s_4983_1: Bits = Bits::new(s_4983_0 as u128, 3u16);
        // C s_4983_2: const #0u : u8
        let s_4983_2: u8 = 0;
        // C s_4983_3: cast zx s_4983_2 -> bv
        let s_4983_3: Bits = Bits::new(s_4983_2 as u128, 3u16);
        // D s_4983_4: cmp-eq s_4983_1 s_4983_3
        let s_4983_4: bool = ((s_4983_1) == (s_4983_3));
        // D s_4983_5: write-var gs#118098 <= s_4983_4
        fn_state.gs_118098 = s_4983_4;
        // N s_4983_6: jump b1239
        return block_1239(state, tracer, fn_state);
    }
    fn block_4984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4984_0: read-var coproc:u8
        let s_4984_0: u8 = fn_state.coproc;
        // D s_4984_1: cast zx s_4984_0 -> bv
        let s_4984_1: Bits = Bits::new(s_4984_0 as u128, 4u16);
        // C s_4984_2: const #15u : u8
        let s_4984_2: u8 = 15;
        // C s_4984_3: cast zx s_4984_2 -> bv
        let s_4984_3: Bits = Bits::new(s_4984_2 as u128, 4u16);
        // D s_4984_4: cmp-eq s_4984_1 s_4984_3
        let s_4984_4: bool = ((s_4984_1) == (s_4984_3));
        // D s_4984_5: write-var gs#118097 <= s_4984_4
        fn_state.gs_118097 = s_4984_4;
        // N s_4984_6: jump b1237
        return block_1237(state, tracer, fn_state);
    }
    fn block_4985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4985_0: read-var CRn:u8
        let s_4985_0: u8 = fn_state.CRn;
        // D s_4985_1: cast zx s_4985_0 -> bv
        let s_4985_1: Bits = Bits::new(s_4985_0 as u128, 4u16);
        // C s_4985_2: const #5u : u8
        let s_4985_2: u8 = 5;
        // C s_4985_3: cast zx s_4985_2 -> bv
        let s_4985_3: Bits = Bits::new(s_4985_2 as u128, 4u16);
        // D s_4985_4: cmp-eq s_4985_1 s_4985_3
        let s_4985_4: bool = ((s_4985_1) == (s_4985_3));
        // D s_4985_5: write-var gs#118096 <= s_4985_4
        fn_state.gs_118096 = s_4985_4;
        // N s_4985_6: jump b1235
        return block_1235(state, tracer, fn_state);
    }
    fn block_4986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4986_0: read-var el:u8
        let s_4986_0: u8 = fn_state.el;
        // D s_4986_1: read-var coproc:u8
        let s_4986_1: u8 = fn_state.coproc;
        // D s_4986_2: read-var opc1:u8
        let s_4986_2: u8 = fn_state.opc1;
        // D s_4986_3: read-var CRn:u8
        let s_4986_3: u8 = fn_state.CRn;
        // D s_4986_4: read-var opc2:u8
        let s_4986_4: u8 = fn_state.opc2;
        // D s_4986_5: read-var CRm:u8
        let s_4986_5: u8 = fn_state.CRm;
        // D s_4986_6: read-var t:i
        let s_4986_6: i128 = fn_state.t;
        // D s_4986_7: call ICV_AP1R_SysRegRead32_f50b3adcd6cb4d7f(s_4986_0, s_4986_1, s_4986_2, s_4986_3, s_4986_4, s_4986_5, s_4986_6)
        let s_4986_7: () = ICV_AP1R_SysRegRead32_f50b3adcd6cb4d7f(
            state,
            tracer,
            s_4986_0,
            s_4986_1,
            s_4986_2,
            s_4986_3,
            s_4986_4,
            s_4986_5,
            s_4986_6,
        );
        // N s_4986_8: return
        return;
    }
    fn block_4987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4987_0: read-var opc2:u8
        let s_4987_0: u8 = fn_state.opc2;
        // D s_4987_1: cast zx s_4987_0 -> bv
        let s_4987_1: Bits = Bits::new(s_4987_0 as u128, 3u16);
        // C s_4987_2: const #0u : u8
        let s_4987_2: u8 = 0;
        // C s_4987_3: cast zx s_4987_2 -> bv
        let s_4987_3: Bits = Bits::new(s_4987_2 as u128, 3u16);
        // D s_4987_4: cmp-eq s_4987_1 s_4987_3
        let s_4987_4: bool = ((s_4987_1) == (s_4987_3));
        // D s_4987_5: write-var gs#118095 <= s_4987_4
        fn_state.gs_118095 = s_4987_4;
        // N s_4987_6: jump b1232
        return block_1232(state, tracer, fn_state);
    }
    fn block_4988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4988_0: read-var opc1:u8
        let s_4988_0: u8 = fn_state.opc1;
        // D s_4988_1: cast zx s_4988_0 -> bv
        let s_4988_1: Bits = Bits::new(s_4988_0 as u128, 3u16);
        // C s_4988_2: const #0u : u8
        let s_4988_2: u8 = 0;
        // C s_4988_3: cast zx s_4988_2 -> bv
        let s_4988_3: Bits = Bits::new(s_4988_2 as u128, 3u16);
        // D s_4988_4: cmp-eq s_4988_1 s_4988_3
        let s_4988_4: bool = ((s_4988_1) == (s_4988_3));
        // D s_4988_5: write-var gs#118094 <= s_4988_4
        fn_state.gs_118094 = s_4988_4;
        // N s_4988_6: jump b1230
        return block_1230(state, tracer, fn_state);
    }
    fn block_4989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4989_0: read-var coproc:u8
        let s_4989_0: u8 = fn_state.coproc;
        // D s_4989_1: cast zx s_4989_0 -> bv
        let s_4989_1: Bits = Bits::new(s_4989_0 as u128, 4u16);
        // C s_4989_2: const #15u : u8
        let s_4989_2: u8 = 15;
        // C s_4989_3: cast zx s_4989_2 -> bv
        let s_4989_3: Bits = Bits::new(s_4989_2 as u128, 4u16);
        // D s_4989_4: cmp-eq s_4989_1 s_4989_3
        let s_4989_4: bool = ((s_4989_1) == (s_4989_3));
        // D s_4989_5: write-var gs#118093 <= s_4989_4
        fn_state.gs_118093 = s_4989_4;
        // N s_4989_6: jump b1228
        return block_1228(state, tracer, fn_state);
    }
    fn block_4990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4990_0: read-var CRn:u8
        let s_4990_0: u8 = fn_state.CRn;
        // D s_4990_1: cast zx s_4990_0 -> bv
        let s_4990_1: Bits = Bits::new(s_4990_0 as u128, 4u16);
        // C s_4990_2: const #12u : u8
        let s_4990_2: u8 = 12;
        // C s_4990_3: cast zx s_4990_2 -> bv
        let s_4990_3: Bits = Bits::new(s_4990_2 as u128, 4u16);
        // D s_4990_4: cmp-eq s_4990_1 s_4990_3
        let s_4990_4: bool = ((s_4990_1) == (s_4990_3));
        // D s_4990_5: write-var gs#118092 <= s_4990_4
        fn_state.gs_118092 = s_4990_4;
        // N s_4990_6: jump b1226
        return block_1226(state, tracer, fn_state);
    }
    fn block_4991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4991_0: read-var el:u8
        let s_4991_0: u8 = fn_state.el;
        // D s_4991_1: read-var coproc:u8
        let s_4991_1: u8 = fn_state.coproc;
        // D s_4991_2: read-var opc1:u8
        let s_4991_2: u8 = fn_state.opc1;
        // D s_4991_3: read-var CRn:u8
        let s_4991_3: u8 = fn_state.CRn;
        // D s_4991_4: read-var opc2:u8
        let s_4991_4: u8 = fn_state.opc2;
        // D s_4991_5: read-var CRm:u8
        let s_4991_5: u8 = fn_state.CRm;
        // D s_4991_6: read-var t:i
        let s_4991_6: i128 = fn_state.t;
        // D s_4991_7: call ICV_AP1R_SysRegRead32_06c655ca9c8e2c1e(s_4991_0, s_4991_1, s_4991_2, s_4991_3, s_4991_4, s_4991_5, s_4991_6)
        let s_4991_7: () = ICV_AP1R_SysRegRead32_06c655ca9c8e2c1e(
            state,
            tracer,
            s_4991_0,
            s_4991_1,
            s_4991_2,
            s_4991_3,
            s_4991_4,
            s_4991_5,
            s_4991_6,
        );
        // N s_4991_8: return
        return;
    }
    fn block_4992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4992_0: read-var opc2:u8
        let s_4992_0: u8 = fn_state.opc2;
        // D s_4992_1: cast zx s_4992_0 -> bv
        let s_4992_1: Bits = Bits::new(s_4992_0 as u128, 3u16);
        // C s_4992_2: const #1u : u8
        let s_4992_2: u8 = 1;
        // C s_4992_3: cast zx s_4992_2 -> bv
        let s_4992_3: Bits = Bits::new(s_4992_2 as u128, 3u16);
        // D s_4992_4: cmp-eq s_4992_1 s_4992_3
        let s_4992_4: bool = ((s_4992_1) == (s_4992_3));
        // D s_4992_5: write-var gs#118091 <= s_4992_4
        fn_state.gs_118091 = s_4992_4;
        // N s_4992_6: jump b1223
        return block_1223(state, tracer, fn_state);
    }
    fn block_4993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4993_0: read-var opc1:u8
        let s_4993_0: u8 = fn_state.opc1;
        // D s_4993_1: cast zx s_4993_0 -> bv
        let s_4993_1: Bits = Bits::new(s_4993_0 as u128, 3u16);
        // C s_4993_2: const #0u : u8
        let s_4993_2: u8 = 0;
        // C s_4993_3: cast zx s_4993_2 -> bv
        let s_4993_3: Bits = Bits::new(s_4993_2 as u128, 3u16);
        // D s_4993_4: cmp-eq s_4993_1 s_4993_3
        let s_4993_4: bool = ((s_4993_1) == (s_4993_3));
        // D s_4993_5: write-var gs#118090 <= s_4993_4
        fn_state.gs_118090 = s_4993_4;
        // N s_4993_6: jump b1221
        return block_1221(state, tracer, fn_state);
    }
    fn block_4994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4994_0: read-var coproc:u8
        let s_4994_0: u8 = fn_state.coproc;
        // D s_4994_1: cast zx s_4994_0 -> bv
        let s_4994_1: Bits = Bits::new(s_4994_0 as u128, 4u16);
        // C s_4994_2: const #15u : u8
        let s_4994_2: u8 = 15;
        // C s_4994_3: cast zx s_4994_2 -> bv
        let s_4994_3: Bits = Bits::new(s_4994_2 as u128, 4u16);
        // D s_4994_4: cmp-eq s_4994_1 s_4994_3
        let s_4994_4: bool = ((s_4994_1) == (s_4994_3));
        // D s_4994_5: write-var gs#118089 <= s_4994_4
        fn_state.gs_118089 = s_4994_4;
        // N s_4994_6: jump b1219
        return block_1219(state, tracer, fn_state);
    }
    fn block_4995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4995_0: read-var CRn:u8
        let s_4995_0: u8 = fn_state.CRn;
        // D s_4995_1: cast zx s_4995_0 -> bv
        let s_4995_1: Bits = Bits::new(s_4995_0 as u128, 4u16);
        // C s_4995_2: const #12u : u8
        let s_4995_2: u8 = 12;
        // C s_4995_3: cast zx s_4995_2 -> bv
        let s_4995_3: Bits = Bits::new(s_4995_2 as u128, 4u16);
        // D s_4995_4: cmp-eq s_4995_1 s_4995_3
        let s_4995_4: bool = ((s_4995_1) == (s_4995_3));
        // D s_4995_5: write-var gs#118088 <= s_4995_4
        fn_state.gs_118088 = s_4995_4;
        // N s_4995_6: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_4996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4996_0: read-var el:u8
        let s_4996_0: u8 = fn_state.el;
        // D s_4996_1: read-var coproc:u8
        let s_4996_1: u8 = fn_state.coproc;
        // D s_4996_2: read-var opc1:u8
        let s_4996_2: u8 = fn_state.opc1;
        // D s_4996_3: read-var CRn:u8
        let s_4996_3: u8 = fn_state.CRn;
        // D s_4996_4: read-var opc2:u8
        let s_4996_4: u8 = fn_state.opc2;
        // D s_4996_5: read-var CRm:u8
        let s_4996_5: u8 = fn_state.CRm;
        // D s_4996_6: read-var t:i
        let s_4996_6: i128 = fn_state.t;
        // D s_4996_7: call ICV_AP1R_SysRegRead32_c631f0bb4000bb22(s_4996_0, s_4996_1, s_4996_2, s_4996_3, s_4996_4, s_4996_5, s_4996_6)
        let s_4996_7: () = ICV_AP1R_SysRegRead32_c631f0bb4000bb22(
            state,
            tracer,
            s_4996_0,
            s_4996_1,
            s_4996_2,
            s_4996_3,
            s_4996_4,
            s_4996_5,
            s_4996_6,
        );
        // N s_4996_8: return
        return;
    }
    fn block_4997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4997_0: read-var opc2:u8
        let s_4997_0: u8 = fn_state.opc2;
        // D s_4997_1: cast zx s_4997_0 -> bv
        let s_4997_1: Bits = Bits::new(s_4997_0 as u128, 3u16);
        // C s_4997_2: const #2u : u8
        let s_4997_2: u8 = 2;
        // C s_4997_3: cast zx s_4997_2 -> bv
        let s_4997_3: Bits = Bits::new(s_4997_2 as u128, 3u16);
        // D s_4997_4: cmp-eq s_4997_1 s_4997_3
        let s_4997_4: bool = ((s_4997_1) == (s_4997_3));
        // D s_4997_5: write-var gs#118087 <= s_4997_4
        fn_state.gs_118087 = s_4997_4;
        // N s_4997_6: jump b1214
        return block_1214(state, tracer, fn_state);
    }
    fn block_4998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4998_0: read-var opc1:u8
        let s_4998_0: u8 = fn_state.opc1;
        // D s_4998_1: cast zx s_4998_0 -> bv
        let s_4998_1: Bits = Bits::new(s_4998_0 as u128, 3u16);
        // C s_4998_2: const #0u : u8
        let s_4998_2: u8 = 0;
        // C s_4998_3: cast zx s_4998_2 -> bv
        let s_4998_3: Bits = Bits::new(s_4998_2 as u128, 3u16);
        // D s_4998_4: cmp-eq s_4998_1 s_4998_3
        let s_4998_4: bool = ((s_4998_1) == (s_4998_3));
        // D s_4998_5: write-var gs#118086 <= s_4998_4
        fn_state.gs_118086 = s_4998_4;
        // N s_4998_6: jump b1212
        return block_1212(state, tracer, fn_state);
    }
    fn block_4999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4999_0: read-var coproc:u8
        let s_4999_0: u8 = fn_state.coproc;
        // D s_4999_1: cast zx s_4999_0 -> bv
        let s_4999_1: Bits = Bits::new(s_4999_0 as u128, 4u16);
        // C s_4999_2: const #15u : u8
        let s_4999_2: u8 = 15;
        // C s_4999_3: cast zx s_4999_2 -> bv
        let s_4999_3: Bits = Bits::new(s_4999_2 as u128, 4u16);
        // D s_4999_4: cmp-eq s_4999_1 s_4999_3
        let s_4999_4: bool = ((s_4999_1) == (s_4999_3));
        // D s_4999_5: write-var gs#118085 <= s_4999_4
        fn_state.gs_118085 = s_4999_4;
        // N s_4999_6: jump b1210
        return block_1210(state, tracer, fn_state);
    }
    fn block_5000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5000_0: read-var CRn:u8
        let s_5000_0: u8 = fn_state.CRn;
        // D s_5000_1: cast zx s_5000_0 -> bv
        let s_5000_1: Bits = Bits::new(s_5000_0 as u128, 4u16);
        // C s_5000_2: const #12u : u8
        let s_5000_2: u8 = 12;
        // C s_5000_3: cast zx s_5000_2 -> bv
        let s_5000_3: Bits = Bits::new(s_5000_2 as u128, 4u16);
        // D s_5000_4: cmp-eq s_5000_1 s_5000_3
        let s_5000_4: bool = ((s_5000_1) == (s_5000_3));
        // D s_5000_5: write-var gs#118084 <= s_5000_4
        fn_state.gs_118084 = s_5000_4;
        // N s_5000_6: jump b1208
        return block_1208(state, tracer, fn_state);
    }
    fn block_5001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5001_0: read-var el:u8
        let s_5001_0: u8 = fn_state.el;
        // D s_5001_1: read-var coproc:u8
        let s_5001_1: u8 = fn_state.coproc;
        // D s_5001_2: read-var opc1:u8
        let s_5001_2: u8 = fn_state.opc1;
        // D s_5001_3: read-var CRn:u8
        let s_5001_3: u8 = fn_state.CRn;
        // D s_5001_4: read-var opc2:u8
        let s_5001_4: u8 = fn_state.opc2;
        // D s_5001_5: read-var CRm:u8
        let s_5001_5: u8 = fn_state.CRm;
        // D s_5001_6: read-var t:i
        let s_5001_6: i128 = fn_state.t;
        // D s_5001_7: call ICV_AP1R_SysRegRead32_97b8eb46fd54eb2b(s_5001_0, s_5001_1, s_5001_2, s_5001_3, s_5001_4, s_5001_5, s_5001_6)
        let s_5001_7: () = ICV_AP1R_SysRegRead32_97b8eb46fd54eb2b(
            state,
            tracer,
            s_5001_0,
            s_5001_1,
            s_5001_2,
            s_5001_3,
            s_5001_4,
            s_5001_5,
            s_5001_6,
        );
        // N s_5001_8: return
        return;
    }
    fn block_5002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5002_0: read-var opc2:u8
        let s_5002_0: u8 = fn_state.opc2;
        // D s_5002_1: cast zx s_5002_0 -> bv
        let s_5002_1: Bits = Bits::new(s_5002_0 as u128, 3u16);
        // C s_5002_2: const #3u : u8
        let s_5002_2: u8 = 3;
        // C s_5002_3: cast zx s_5002_2 -> bv
        let s_5002_3: Bits = Bits::new(s_5002_2 as u128, 3u16);
        // D s_5002_4: cmp-eq s_5002_1 s_5002_3
        let s_5002_4: bool = ((s_5002_1) == (s_5002_3));
        // D s_5002_5: write-var gs#118083 <= s_5002_4
        fn_state.gs_118083 = s_5002_4;
        // N s_5002_6: jump b1205
        return block_1205(state, tracer, fn_state);
    }
    fn block_5003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5003_0: read-var opc1:u8
        let s_5003_0: u8 = fn_state.opc1;
        // D s_5003_1: cast zx s_5003_0 -> bv
        let s_5003_1: Bits = Bits::new(s_5003_0 as u128, 3u16);
        // C s_5003_2: const #0u : u8
        let s_5003_2: u8 = 0;
        // C s_5003_3: cast zx s_5003_2 -> bv
        let s_5003_3: Bits = Bits::new(s_5003_2 as u128, 3u16);
        // D s_5003_4: cmp-eq s_5003_1 s_5003_3
        let s_5003_4: bool = ((s_5003_1) == (s_5003_3));
        // D s_5003_5: write-var gs#118082 <= s_5003_4
        fn_state.gs_118082 = s_5003_4;
        // N s_5003_6: jump b1203
        return block_1203(state, tracer, fn_state);
    }
    fn block_5004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5004_0: read-var coproc:u8
        let s_5004_0: u8 = fn_state.coproc;
        // D s_5004_1: cast zx s_5004_0 -> bv
        let s_5004_1: Bits = Bits::new(s_5004_0 as u128, 4u16);
        // C s_5004_2: const #15u : u8
        let s_5004_2: u8 = 15;
        // C s_5004_3: cast zx s_5004_2 -> bv
        let s_5004_3: Bits = Bits::new(s_5004_2 as u128, 4u16);
        // D s_5004_4: cmp-eq s_5004_1 s_5004_3
        let s_5004_4: bool = ((s_5004_1) == (s_5004_3));
        // D s_5004_5: write-var gs#118081 <= s_5004_4
        fn_state.gs_118081 = s_5004_4;
        // N s_5004_6: jump b1201
        return block_1201(state, tracer, fn_state);
    }
    fn block_5005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5005_0: read-var CRn:u8
        let s_5005_0: u8 = fn_state.CRn;
        // D s_5005_1: cast zx s_5005_0 -> bv
        let s_5005_1: Bits = Bits::new(s_5005_0 as u128, 4u16);
        // C s_5005_2: const #12u : u8
        let s_5005_2: u8 = 12;
        // C s_5005_3: cast zx s_5005_2 -> bv
        let s_5005_3: Bits = Bits::new(s_5005_2 as u128, 4u16);
        // D s_5005_4: cmp-eq s_5005_1 s_5005_3
        let s_5005_4: bool = ((s_5005_1) == (s_5005_3));
        // D s_5005_5: write-var gs#118080 <= s_5005_4
        fn_state.gs_118080 = s_5005_4;
        // N s_5005_6: jump b1199
        return block_1199(state, tracer, fn_state);
    }
    fn block_5006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5006_0: read-var el:u8
        let s_5006_0: u8 = fn_state.el;
        // D s_5006_1: read-var coproc:u8
        let s_5006_1: u8 = fn_state.coproc;
        // D s_5006_2: read-var opc1:u8
        let s_5006_2: u8 = fn_state.opc1;
        // D s_5006_3: read-var CRn:u8
        let s_5006_3: u8 = fn_state.CRn;
        // D s_5006_4: read-var opc2:u8
        let s_5006_4: u8 = fn_state.opc2;
        // D s_5006_5: read-var CRm:u8
        let s_5006_5: u8 = fn_state.CRm;
        // D s_5006_6: read-var t:i
        let s_5006_6: i128 = fn_state.t;
        // D s_5006_7: call ICC_BPR0_SysRegRead32_7c3bac42de4de5ac(s_5006_0, s_5006_1, s_5006_2, s_5006_3, s_5006_4, s_5006_5, s_5006_6)
        let s_5006_7: () = ICC_BPR0_SysRegRead32_7c3bac42de4de5ac(
            state,
            tracer,
            s_5006_0,
            s_5006_1,
            s_5006_2,
            s_5006_3,
            s_5006_4,
            s_5006_5,
            s_5006_6,
        );
        // N s_5006_8: return
        return;
    }
    fn block_5007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5007_0: read-var opc2:u8
        let s_5007_0: u8 = fn_state.opc2;
        // D s_5007_1: cast zx s_5007_0 -> bv
        let s_5007_1: Bits = Bits::new(s_5007_0 as u128, 3u16);
        // C s_5007_2: const #3u : u8
        let s_5007_2: u8 = 3;
        // C s_5007_3: cast zx s_5007_2 -> bv
        let s_5007_3: Bits = Bits::new(s_5007_2 as u128, 3u16);
        // D s_5007_4: cmp-eq s_5007_1 s_5007_3
        let s_5007_4: bool = ((s_5007_1) == (s_5007_3));
        // D s_5007_5: write-var gs#118079 <= s_5007_4
        fn_state.gs_118079 = s_5007_4;
        // N s_5007_6: jump b1196
        return block_1196(state, tracer, fn_state);
    }
    fn block_5008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5008_0: read-var opc1:u8
        let s_5008_0: u8 = fn_state.opc1;
        // D s_5008_1: cast zx s_5008_0 -> bv
        let s_5008_1: Bits = Bits::new(s_5008_0 as u128, 3u16);
        // C s_5008_2: const #0u : u8
        let s_5008_2: u8 = 0;
        // C s_5008_3: cast zx s_5008_2 -> bv
        let s_5008_3: Bits = Bits::new(s_5008_2 as u128, 3u16);
        // D s_5008_4: cmp-eq s_5008_1 s_5008_3
        let s_5008_4: bool = ((s_5008_1) == (s_5008_3));
        // D s_5008_5: write-var gs#118078 <= s_5008_4
        fn_state.gs_118078 = s_5008_4;
        // N s_5008_6: jump b1194
        return block_1194(state, tracer, fn_state);
    }
    fn block_5009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5009_0: read-var coproc:u8
        let s_5009_0: u8 = fn_state.coproc;
        // D s_5009_1: cast zx s_5009_0 -> bv
        let s_5009_1: Bits = Bits::new(s_5009_0 as u128, 4u16);
        // C s_5009_2: const #15u : u8
        let s_5009_2: u8 = 15;
        // C s_5009_3: cast zx s_5009_2 -> bv
        let s_5009_3: Bits = Bits::new(s_5009_2 as u128, 4u16);
        // D s_5009_4: cmp-eq s_5009_1 s_5009_3
        let s_5009_4: bool = ((s_5009_1) == (s_5009_3));
        // D s_5009_5: write-var gs#118077 <= s_5009_4
        fn_state.gs_118077 = s_5009_4;
        // N s_5009_6: jump b1192
        return block_1192(state, tracer, fn_state);
    }
    fn block_5010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5010_0: read-var CRn:u8
        let s_5010_0: u8 = fn_state.CRn;
        // D s_5010_1: cast zx s_5010_0 -> bv
        let s_5010_1: Bits = Bits::new(s_5010_0 as u128, 4u16);
        // C s_5010_2: const #12u : u8
        let s_5010_2: u8 = 12;
        // C s_5010_3: cast zx s_5010_2 -> bv
        let s_5010_3: Bits = Bits::new(s_5010_2 as u128, 4u16);
        // D s_5010_4: cmp-eq s_5010_1 s_5010_3
        let s_5010_4: bool = ((s_5010_1) == (s_5010_3));
        // D s_5010_5: write-var gs#118076 <= s_5010_4
        fn_state.gs_118076 = s_5010_4;
        // N s_5010_6: jump b1190
        return block_1190(state, tracer, fn_state);
    }
    fn block_5011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5011_0: read-var el:u8
        let s_5011_0: u8 = fn_state.el;
        // D s_5011_1: read-var coproc:u8
        let s_5011_1: u8 = fn_state.coproc;
        // D s_5011_2: read-var opc1:u8
        let s_5011_2: u8 = fn_state.opc1;
        // D s_5011_3: read-var CRn:u8
        let s_5011_3: u8 = fn_state.CRn;
        // D s_5011_4: read-var opc2:u8
        let s_5011_4: u8 = fn_state.opc2;
        // D s_5011_5: read-var CRm:u8
        let s_5011_5: u8 = fn_state.CRm;
        // D s_5011_6: read-var t:i
        let s_5011_6: i128 = fn_state.t;
        // D s_5011_7: call TPIDRURW_SysRegRead32_844b54dbacb876a1(s_5011_0, s_5011_1, s_5011_2, s_5011_3, s_5011_4, s_5011_5, s_5011_6)
        let s_5011_7: () = TPIDRURW_SysRegRead32_844b54dbacb876a1(
            state,
            tracer,
            s_5011_0,
            s_5011_1,
            s_5011_2,
            s_5011_3,
            s_5011_4,
            s_5011_5,
            s_5011_6,
        );
        // N s_5011_8: return
        return;
    }
    fn block_5012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5012_0: read-var opc2:u8
        let s_5012_0: u8 = fn_state.opc2;
        // D s_5012_1: cast zx s_5012_0 -> bv
        let s_5012_1: Bits = Bits::new(s_5012_0 as u128, 3u16);
        // C s_5012_2: const #2u : u8
        let s_5012_2: u8 = 2;
        // C s_5012_3: cast zx s_5012_2 -> bv
        let s_5012_3: Bits = Bits::new(s_5012_2 as u128, 3u16);
        // D s_5012_4: cmp-eq s_5012_1 s_5012_3
        let s_5012_4: bool = ((s_5012_1) == (s_5012_3));
        // D s_5012_5: write-var gs#118075 <= s_5012_4
        fn_state.gs_118075 = s_5012_4;
        // N s_5012_6: jump b1187
        return block_1187(state, tracer, fn_state);
    }
    fn block_5013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5013_0: read-var opc1:u8
        let s_5013_0: u8 = fn_state.opc1;
        // D s_5013_1: cast zx s_5013_0 -> bv
        let s_5013_1: Bits = Bits::new(s_5013_0 as u128, 3u16);
        // C s_5013_2: const #0u : u8
        let s_5013_2: u8 = 0;
        // C s_5013_3: cast zx s_5013_2 -> bv
        let s_5013_3: Bits = Bits::new(s_5013_2 as u128, 3u16);
        // D s_5013_4: cmp-eq s_5013_1 s_5013_3
        let s_5013_4: bool = ((s_5013_1) == (s_5013_3));
        // D s_5013_5: write-var gs#118074 <= s_5013_4
        fn_state.gs_118074 = s_5013_4;
        // N s_5013_6: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_5014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5014_0: read-var coproc:u8
        let s_5014_0: u8 = fn_state.coproc;
        // D s_5014_1: cast zx s_5014_0 -> bv
        let s_5014_1: Bits = Bits::new(s_5014_0 as u128, 4u16);
        // C s_5014_2: const #15u : u8
        let s_5014_2: u8 = 15;
        // C s_5014_3: cast zx s_5014_2 -> bv
        let s_5014_3: Bits = Bits::new(s_5014_2 as u128, 4u16);
        // D s_5014_4: cmp-eq s_5014_1 s_5014_3
        let s_5014_4: bool = ((s_5014_1) == (s_5014_3));
        // D s_5014_5: write-var gs#118073 <= s_5014_4
        fn_state.gs_118073 = s_5014_4;
        // N s_5014_6: jump b1183
        return block_1183(state, tracer, fn_state);
    }
    fn block_5015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5015_0: read-var CRn:u8
        let s_5015_0: u8 = fn_state.CRn;
        // D s_5015_1: cast zx s_5015_0 -> bv
        let s_5015_1: Bits = Bits::new(s_5015_0 as u128, 4u16);
        // C s_5015_2: const #13u : u8
        let s_5015_2: u8 = 13;
        // C s_5015_3: cast zx s_5015_2 -> bv
        let s_5015_3: Bits = Bits::new(s_5015_2 as u128, 4u16);
        // D s_5015_4: cmp-eq s_5015_1 s_5015_3
        let s_5015_4: bool = ((s_5015_1) == (s_5015_3));
        // D s_5015_5: write-var gs#118072 <= s_5015_4
        fn_state.gs_118072 = s_5015_4;
        // N s_5015_6: jump b1181
        return block_1181(state, tracer, fn_state);
    }
    fn block_5016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5016_0: read-var el:u8
        let s_5016_0: u8 = fn_state.el;
        // D s_5016_1: read-var coproc:u8
        let s_5016_1: u8 = fn_state.coproc;
        // D s_5016_2: read-var opc1:u8
        let s_5016_2: u8 = fn_state.opc1;
        // D s_5016_3: read-var CRn:u8
        let s_5016_3: u8 = fn_state.CRn;
        // D s_5016_4: read-var opc2:u8
        let s_5016_4: u8 = fn_state.opc2;
        // D s_5016_5: read-var CRm:u8
        let s_5016_5: u8 = fn_state.CRm;
        // D s_5016_6: read-var t:i
        let s_5016_6: i128 = fn_state.t;
        // D s_5016_7: call ID_MMFR4_SysRegRead32_8caa2bb66e738b87(s_5016_0, s_5016_1, s_5016_2, s_5016_3, s_5016_4, s_5016_5, s_5016_6)
        let s_5016_7: () = ID_MMFR4_SysRegRead32_8caa2bb66e738b87(
            state,
            tracer,
            s_5016_0,
            s_5016_1,
            s_5016_2,
            s_5016_3,
            s_5016_4,
            s_5016_5,
            s_5016_6,
        );
        // N s_5016_8: return
        return;
    }
    fn block_5017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5017_0: read-var opc2:u8
        let s_5017_0: u8 = fn_state.opc2;
        // D s_5017_1: cast zx s_5017_0 -> bv
        let s_5017_1: Bits = Bits::new(s_5017_0 as u128, 3u16);
        // C s_5017_2: const #6u : u8
        let s_5017_2: u8 = 6;
        // C s_5017_3: cast zx s_5017_2 -> bv
        let s_5017_3: Bits = Bits::new(s_5017_2 as u128, 3u16);
        // D s_5017_4: cmp-eq s_5017_1 s_5017_3
        let s_5017_4: bool = ((s_5017_1) == (s_5017_3));
        // D s_5017_5: write-var gs#118071 <= s_5017_4
        fn_state.gs_118071 = s_5017_4;
        // N s_5017_6: jump b1178
        return block_1178(state, tracer, fn_state);
    }
    fn block_5018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5018_0: read-var opc1:u8
        let s_5018_0: u8 = fn_state.opc1;
        // D s_5018_1: cast zx s_5018_0 -> bv
        let s_5018_1: Bits = Bits::new(s_5018_0 as u128, 3u16);
        // C s_5018_2: const #0u : u8
        let s_5018_2: u8 = 0;
        // C s_5018_3: cast zx s_5018_2 -> bv
        let s_5018_3: Bits = Bits::new(s_5018_2 as u128, 3u16);
        // D s_5018_4: cmp-eq s_5018_1 s_5018_3
        let s_5018_4: bool = ((s_5018_1) == (s_5018_3));
        // D s_5018_5: write-var gs#118070 <= s_5018_4
        fn_state.gs_118070 = s_5018_4;
        // N s_5018_6: jump b1176
        return block_1176(state, tracer, fn_state);
    }
    fn block_5019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5019_0: read-var coproc:u8
        let s_5019_0: u8 = fn_state.coproc;
        // D s_5019_1: cast zx s_5019_0 -> bv
        let s_5019_1: Bits = Bits::new(s_5019_0 as u128, 4u16);
        // C s_5019_2: const #15u : u8
        let s_5019_2: u8 = 15;
        // C s_5019_3: cast zx s_5019_2 -> bv
        let s_5019_3: Bits = Bits::new(s_5019_2 as u128, 4u16);
        // D s_5019_4: cmp-eq s_5019_1 s_5019_3
        let s_5019_4: bool = ((s_5019_1) == (s_5019_3));
        // D s_5019_5: write-var gs#118069 <= s_5019_4
        fn_state.gs_118069 = s_5019_4;
        // N s_5019_6: jump b1174
        return block_1174(state, tracer, fn_state);
    }
    fn block_5020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5020_0: read-var CRn:u8
        let s_5020_0: u8 = fn_state.CRn;
        // D s_5020_1: cast zx s_5020_0 -> bv
        let s_5020_1: Bits = Bits::new(s_5020_0 as u128, 4u16);
        // C s_5020_2: const #0u : u8
        let s_5020_2: u8 = 0;
        // C s_5020_3: cast zx s_5020_2 -> bv
        let s_5020_3: Bits = Bits::new(s_5020_2 as u128, 4u16);
        // D s_5020_4: cmp-eq s_5020_1 s_5020_3
        let s_5020_4: bool = ((s_5020_1) == (s_5020_3));
        // D s_5020_5: write-var gs#118068 <= s_5020_4
        fn_state.gs_118068 = s_5020_4;
        // N s_5020_6: jump b1172
        return block_1172(state, tracer, fn_state);
    }
    fn block_5021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5021_0: read-var el:u8
        let s_5021_0: u8 = fn_state.el;
        // D s_5021_1: read-var coproc:u8
        let s_5021_1: u8 = fn_state.coproc;
        // D s_5021_2: read-var opc1:u8
        let s_5021_2: u8 = fn_state.opc1;
        // D s_5021_3: read-var CRn:u8
        let s_5021_3: u8 = fn_state.CRn;
        // D s_5021_4: read-var opc2:u8
        let s_5021_4: u8 = fn_state.opc2;
        // D s_5021_5: read-var CRm:u8
        let s_5021_5: u8 = fn_state.CRm;
        // D s_5021_6: read-var t:i
        let s_5021_6: i128 = fn_state.t;
        // D s_5021_7: call SDER_SysRegRead32_0b9374021ce6ef0e(s_5021_0, s_5021_1, s_5021_2, s_5021_3, s_5021_4, s_5021_5, s_5021_6)
        let s_5021_7: () = SDER_SysRegRead32_0b9374021ce6ef0e(
            state,
            tracer,
            s_5021_0,
            s_5021_1,
            s_5021_2,
            s_5021_3,
            s_5021_4,
            s_5021_5,
            s_5021_6,
        );
        // N s_5021_8: return
        return;
    }
    fn block_5022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5022_0: read-var opc2:u8
        let s_5022_0: u8 = fn_state.opc2;
        // D s_5022_1: cast zx s_5022_0 -> bv
        let s_5022_1: Bits = Bits::new(s_5022_0 as u128, 3u16);
        // C s_5022_2: const #1u : u8
        let s_5022_2: u8 = 1;
        // C s_5022_3: cast zx s_5022_2 -> bv
        let s_5022_3: Bits = Bits::new(s_5022_2 as u128, 3u16);
        // D s_5022_4: cmp-eq s_5022_1 s_5022_3
        let s_5022_4: bool = ((s_5022_1) == (s_5022_3));
        // D s_5022_5: write-var gs#118067 <= s_5022_4
        fn_state.gs_118067 = s_5022_4;
        // N s_5022_6: jump b1169
        return block_1169(state, tracer, fn_state);
    }
    fn block_5023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5023_0: read-var opc1:u8
        let s_5023_0: u8 = fn_state.opc1;
        // D s_5023_1: cast zx s_5023_0 -> bv
        let s_5023_1: Bits = Bits::new(s_5023_0 as u128, 3u16);
        // C s_5023_2: const #0u : u8
        let s_5023_2: u8 = 0;
        // C s_5023_3: cast zx s_5023_2 -> bv
        let s_5023_3: Bits = Bits::new(s_5023_2 as u128, 3u16);
        // D s_5023_4: cmp-eq s_5023_1 s_5023_3
        let s_5023_4: bool = ((s_5023_1) == (s_5023_3));
        // D s_5023_5: write-var gs#118066 <= s_5023_4
        fn_state.gs_118066 = s_5023_4;
        // N s_5023_6: jump b1167
        return block_1167(state, tracer, fn_state);
    }
    fn block_5024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5024_0: read-var coproc:u8
        let s_5024_0: u8 = fn_state.coproc;
        // D s_5024_1: cast zx s_5024_0 -> bv
        let s_5024_1: Bits = Bits::new(s_5024_0 as u128, 4u16);
        // C s_5024_2: const #15u : u8
        let s_5024_2: u8 = 15;
        // C s_5024_3: cast zx s_5024_2 -> bv
        let s_5024_3: Bits = Bits::new(s_5024_2 as u128, 4u16);
        // D s_5024_4: cmp-eq s_5024_1 s_5024_3
        let s_5024_4: bool = ((s_5024_1) == (s_5024_3));
        // D s_5024_5: write-var gs#118065 <= s_5024_4
        fn_state.gs_118065 = s_5024_4;
        // N s_5024_6: jump b1165
        return block_1165(state, tracer, fn_state);
    }
    fn block_5025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5025_0: read-var CRn:u8
        let s_5025_0: u8 = fn_state.CRn;
        // D s_5025_1: cast zx s_5025_0 -> bv
        let s_5025_1: Bits = Bits::new(s_5025_0 as u128, 4u16);
        // C s_5025_2: const #1u : u8
        let s_5025_2: u8 = 1;
        // C s_5025_3: cast zx s_5025_2 -> bv
        let s_5025_3: Bits = Bits::new(s_5025_2 as u128, 4u16);
        // D s_5025_4: cmp-eq s_5025_1 s_5025_3
        let s_5025_4: bool = ((s_5025_1) == (s_5025_3));
        // D s_5025_5: write-var gs#118064 <= s_5025_4
        fn_state.gs_118064 = s_5025_4;
        // N s_5025_6: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_5026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5026_0: read-var el:u8
        let s_5026_0: u8 = fn_state.el;
        // D s_5026_1: read-var coproc:u8
        let s_5026_1: u8 = fn_state.coproc;
        // D s_5026_2: read-var opc1:u8
        let s_5026_2: u8 = fn_state.opc1;
        // D s_5026_3: read-var CRn:u8
        let s_5026_3: u8 = fn_state.CRn;
        // D s_5026_4: read-var opc2:u8
        let s_5026_4: u8 = fn_state.opc2;
        // D s_5026_5: read-var CRm:u8
        let s_5026_5: u8 = fn_state.CRm;
        // D s_5026_6: read-var t:i
        let s_5026_6: i128 = fn_state.t;
        // D s_5026_7: call DBGPRCR_SysRegRead32_ff2c6b0471b55490(s_5026_0, s_5026_1, s_5026_2, s_5026_3, s_5026_4, s_5026_5, s_5026_6)
        let s_5026_7: () = DBGPRCR_SysRegRead32_ff2c6b0471b55490(
            state,
            tracer,
            s_5026_0,
            s_5026_1,
            s_5026_2,
            s_5026_3,
            s_5026_4,
            s_5026_5,
            s_5026_6,
        );
        // N s_5026_8: return
        return;
    }
    fn block_5027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5027_0: read-var opc2:u8
        let s_5027_0: u8 = fn_state.opc2;
        // D s_5027_1: cast zx s_5027_0 -> bv
        let s_5027_1: Bits = Bits::new(s_5027_0 as u128, 3u16);
        // C s_5027_2: const #4u : u8
        let s_5027_2: u8 = 4;
        // C s_5027_3: cast zx s_5027_2 -> bv
        let s_5027_3: Bits = Bits::new(s_5027_2 as u128, 3u16);
        // D s_5027_4: cmp-eq s_5027_1 s_5027_3
        let s_5027_4: bool = ((s_5027_1) == (s_5027_3));
        // D s_5027_5: write-var gs#118063 <= s_5027_4
        fn_state.gs_118063 = s_5027_4;
        // N s_5027_6: jump b1160
        return block_1160(state, tracer, fn_state);
    }
    fn block_5028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5028_0: read-var opc1:u8
        let s_5028_0: u8 = fn_state.opc1;
        // D s_5028_1: cast zx s_5028_0 -> bv
        let s_5028_1: Bits = Bits::new(s_5028_0 as u128, 3u16);
        // C s_5028_2: const #0u : u8
        let s_5028_2: u8 = 0;
        // C s_5028_3: cast zx s_5028_2 -> bv
        let s_5028_3: Bits = Bits::new(s_5028_2 as u128, 3u16);
        // D s_5028_4: cmp-eq s_5028_1 s_5028_3
        let s_5028_4: bool = ((s_5028_1) == (s_5028_3));
        // D s_5028_5: write-var gs#118062 <= s_5028_4
        fn_state.gs_118062 = s_5028_4;
        // N s_5028_6: jump b1158
        return block_1158(state, tracer, fn_state);
    }
    fn block_5029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5029_0: read-var coproc:u8
        let s_5029_0: u8 = fn_state.coproc;
        // D s_5029_1: cast zx s_5029_0 -> bv
        let s_5029_1: Bits = Bits::new(s_5029_0 as u128, 4u16);
        // C s_5029_2: const #14u : u8
        let s_5029_2: u8 = 14;
        // C s_5029_3: cast zx s_5029_2 -> bv
        let s_5029_3: Bits = Bits::new(s_5029_2 as u128, 4u16);
        // D s_5029_4: cmp-eq s_5029_1 s_5029_3
        let s_5029_4: bool = ((s_5029_1) == (s_5029_3));
        // D s_5029_5: write-var gs#118061 <= s_5029_4
        fn_state.gs_118061 = s_5029_4;
        // N s_5029_6: jump b1156
        return block_1156(state, tracer, fn_state);
    }
    fn block_5030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5030_0: read-var CRn:u8
        let s_5030_0: u8 = fn_state.CRn;
        // D s_5030_1: cast zx s_5030_0 -> bv
        let s_5030_1: Bits = Bits::new(s_5030_0 as u128, 4u16);
        // C s_5030_2: const #1u : u8
        let s_5030_2: u8 = 1;
        // C s_5030_3: cast zx s_5030_2 -> bv
        let s_5030_3: Bits = Bits::new(s_5030_2 as u128, 4u16);
        // D s_5030_4: cmp-eq s_5030_1 s_5030_3
        let s_5030_4: bool = ((s_5030_1) == (s_5030_3));
        // D s_5030_5: write-var gs#118060 <= s_5030_4
        fn_state.gs_118060 = s_5030_4;
        // N s_5030_6: jump b1154
        return block_1154(state, tracer, fn_state);
    }
    fn block_5031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5031_0: read-var el:u8
        let s_5031_0: u8 = fn_state.el;
        // D s_5031_1: read-var coproc:u8
        let s_5031_1: u8 = fn_state.coproc;
        // D s_5031_2: read-var opc1:u8
        let s_5031_2: u8 = fn_state.opc1;
        // D s_5031_3: read-var CRn:u8
        let s_5031_3: u8 = fn_state.CRn;
        // D s_5031_4: read-var opc2:u8
        let s_5031_4: u8 = fn_state.opc2;
        // D s_5031_5: read-var CRm:u8
        let s_5031_5: u8 = fn_state.CRm;
        // D s_5031_6: read-var t:i
        let s_5031_6: i128 = fn_state.t;
        // D s_5031_7: call PMINTENCLR_SysRegRead32_f6b2fae1205a00f6(s_5031_0, s_5031_1, s_5031_2, s_5031_3, s_5031_4, s_5031_5, s_5031_6)
        let s_5031_7: () = PMINTENCLR_SysRegRead32_f6b2fae1205a00f6(
            state,
            tracer,
            s_5031_0,
            s_5031_1,
            s_5031_2,
            s_5031_3,
            s_5031_4,
            s_5031_5,
            s_5031_6,
        );
        // N s_5031_8: return
        return;
    }
    fn block_5032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5032_0: read-var opc2:u8
        let s_5032_0: u8 = fn_state.opc2;
        // D s_5032_1: cast zx s_5032_0 -> bv
        let s_5032_1: Bits = Bits::new(s_5032_0 as u128, 3u16);
        // C s_5032_2: const #2u : u8
        let s_5032_2: u8 = 2;
        // C s_5032_3: cast zx s_5032_2 -> bv
        let s_5032_3: Bits = Bits::new(s_5032_2 as u128, 3u16);
        // D s_5032_4: cmp-eq s_5032_1 s_5032_3
        let s_5032_4: bool = ((s_5032_1) == (s_5032_3));
        // D s_5032_5: write-var gs#118059 <= s_5032_4
        fn_state.gs_118059 = s_5032_4;
        // N s_5032_6: jump b1151
        return block_1151(state, tracer, fn_state);
    }
    fn block_5033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5033_0: read-var opc1:u8
        let s_5033_0: u8 = fn_state.opc1;
        // D s_5033_1: cast zx s_5033_0 -> bv
        let s_5033_1: Bits = Bits::new(s_5033_0 as u128, 3u16);
        // C s_5033_2: const #0u : u8
        let s_5033_2: u8 = 0;
        // C s_5033_3: cast zx s_5033_2 -> bv
        let s_5033_3: Bits = Bits::new(s_5033_2 as u128, 3u16);
        // D s_5033_4: cmp-eq s_5033_1 s_5033_3
        let s_5033_4: bool = ((s_5033_1) == (s_5033_3));
        // D s_5033_5: write-var gs#118058 <= s_5033_4
        fn_state.gs_118058 = s_5033_4;
        // N s_5033_6: jump b1149
        return block_1149(state, tracer, fn_state);
    }
    fn block_5034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5034_0: read-var coproc:u8
        let s_5034_0: u8 = fn_state.coproc;
        // D s_5034_1: cast zx s_5034_0 -> bv
        let s_5034_1: Bits = Bits::new(s_5034_0 as u128, 4u16);
        // C s_5034_2: const #15u : u8
        let s_5034_2: u8 = 15;
        // C s_5034_3: cast zx s_5034_2 -> bv
        let s_5034_3: Bits = Bits::new(s_5034_2 as u128, 4u16);
        // D s_5034_4: cmp-eq s_5034_1 s_5034_3
        let s_5034_4: bool = ((s_5034_1) == (s_5034_3));
        // D s_5034_5: write-var gs#118057 <= s_5034_4
        fn_state.gs_118057 = s_5034_4;
        // N s_5034_6: jump b1147
        return block_1147(state, tracer, fn_state);
    }
    fn block_5035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5035_0: read-var CRn:u8
        let s_5035_0: u8 = fn_state.CRn;
        // D s_5035_1: cast zx s_5035_0 -> bv
        let s_5035_1: Bits = Bits::new(s_5035_0 as u128, 4u16);
        // C s_5035_2: const #9u : u8
        let s_5035_2: u8 = 9;
        // C s_5035_3: cast zx s_5035_2 -> bv
        let s_5035_3: Bits = Bits::new(s_5035_2 as u128, 4u16);
        // D s_5035_4: cmp-eq s_5035_1 s_5035_3
        let s_5035_4: bool = ((s_5035_1) == (s_5035_3));
        // D s_5035_5: write-var gs#118056 <= s_5035_4
        fn_state.gs_118056 = s_5035_4;
        // N s_5035_6: jump b1145
        return block_1145(state, tracer, fn_state);
    }
    fn block_5036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5036_0: read-var el:u8
        let s_5036_0: u8 = fn_state.el;
        // D s_5036_1: read-var coproc:u8
        let s_5036_1: u8 = fn_state.coproc;
        // D s_5036_2: read-var opc1:u8
        let s_5036_2: u8 = fn_state.opc1;
        // D s_5036_3: read-var CRn:u8
        let s_5036_3: u8 = fn_state.CRn;
        // D s_5036_4: read-var opc2:u8
        let s_5036_4: u8 = fn_state.opc2;
        // D s_5036_5: read-var CRm:u8
        let s_5036_5: u8 = fn_state.CRm;
        // D s_5036_6: read-var t:i
        let s_5036_6: i128 = fn_state.t;
        // D s_5036_7: call ID_ISAR0_SysRegRead32_bb26ec35196a236d(s_5036_0, s_5036_1, s_5036_2, s_5036_3, s_5036_4, s_5036_5, s_5036_6)
        let s_5036_7: () = ID_ISAR0_SysRegRead32_bb26ec35196a236d(
            state,
            tracer,
            s_5036_0,
            s_5036_1,
            s_5036_2,
            s_5036_3,
            s_5036_4,
            s_5036_5,
            s_5036_6,
        );
        // N s_5036_8: return
        return;
    }
    fn block_5037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5037_0: read-var opc2:u8
        let s_5037_0: u8 = fn_state.opc2;
        // D s_5037_1: cast zx s_5037_0 -> bv
        let s_5037_1: Bits = Bits::new(s_5037_0 as u128, 3u16);
        // C s_5037_2: const #0u : u8
        let s_5037_2: u8 = 0;
        // C s_5037_3: cast zx s_5037_2 -> bv
        let s_5037_3: Bits = Bits::new(s_5037_2 as u128, 3u16);
        // D s_5037_4: cmp-eq s_5037_1 s_5037_3
        let s_5037_4: bool = ((s_5037_1) == (s_5037_3));
        // D s_5037_5: write-var gs#118055 <= s_5037_4
        fn_state.gs_118055 = s_5037_4;
        // N s_5037_6: jump b1142
        return block_1142(state, tracer, fn_state);
    }
    fn block_5038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5038_0: read-var opc1:u8
        let s_5038_0: u8 = fn_state.opc1;
        // D s_5038_1: cast zx s_5038_0 -> bv
        let s_5038_1: Bits = Bits::new(s_5038_0 as u128, 3u16);
        // C s_5038_2: const #0u : u8
        let s_5038_2: u8 = 0;
        // C s_5038_3: cast zx s_5038_2 -> bv
        let s_5038_3: Bits = Bits::new(s_5038_2 as u128, 3u16);
        // D s_5038_4: cmp-eq s_5038_1 s_5038_3
        let s_5038_4: bool = ((s_5038_1) == (s_5038_3));
        // D s_5038_5: write-var gs#118054 <= s_5038_4
        fn_state.gs_118054 = s_5038_4;
        // N s_5038_6: jump b1140
        return block_1140(state, tracer, fn_state);
    }
    fn block_5039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5039_0: read-var coproc:u8
        let s_5039_0: u8 = fn_state.coproc;
        // D s_5039_1: cast zx s_5039_0 -> bv
        let s_5039_1: Bits = Bits::new(s_5039_0 as u128, 4u16);
        // C s_5039_2: const #15u : u8
        let s_5039_2: u8 = 15;
        // C s_5039_3: cast zx s_5039_2 -> bv
        let s_5039_3: Bits = Bits::new(s_5039_2 as u128, 4u16);
        // D s_5039_4: cmp-eq s_5039_1 s_5039_3
        let s_5039_4: bool = ((s_5039_1) == (s_5039_3));
        // D s_5039_5: write-var gs#118053 <= s_5039_4
        fn_state.gs_118053 = s_5039_4;
        // N s_5039_6: jump b1138
        return block_1138(state, tracer, fn_state);
    }
    fn block_5040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5040_0: read-var CRn:u8
        let s_5040_0: u8 = fn_state.CRn;
        // D s_5040_1: cast zx s_5040_0 -> bv
        let s_5040_1: Bits = Bits::new(s_5040_0 as u128, 4u16);
        // C s_5040_2: const #0u : u8
        let s_5040_2: u8 = 0;
        // C s_5040_3: cast zx s_5040_2 -> bv
        let s_5040_3: Bits = Bits::new(s_5040_2 as u128, 4u16);
        // D s_5040_4: cmp-eq s_5040_1 s_5040_3
        let s_5040_4: bool = ((s_5040_1) == (s_5040_3));
        // D s_5040_5: write-var gs#118052 <= s_5040_4
        fn_state.gs_118052 = s_5040_4;
        // N s_5040_6: jump b1136
        return block_1136(state, tracer, fn_state);
    }
    fn block_5041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5041_0: read-var el:u8
        let s_5041_0: u8 = fn_state.el;
        // D s_5041_1: read-var coproc:u8
        let s_5041_1: u8 = fn_state.coproc;
        // D s_5041_2: read-var opc1:u8
        let s_5041_2: u8 = fn_state.opc1;
        // D s_5041_3: read-var CRn:u8
        let s_5041_3: u8 = fn_state.CRn;
        // D s_5041_4: read-var opc2:u8
        let s_5041_4: u8 = fn_state.opc2;
        // D s_5041_5: read-var CRm:u8
        let s_5041_5: u8 = fn_state.CRm;
        // D s_5041_6: read-var t:i
        let s_5041_6: i128 = fn_state.t;
        // D s_5041_7: call VBAR_SysRegRead32_cbb282dd5c9d55ce(s_5041_0, s_5041_1, s_5041_2, s_5041_3, s_5041_4, s_5041_5, s_5041_6)
        let s_5041_7: () = VBAR_SysRegRead32_cbb282dd5c9d55ce(
            state,
            tracer,
            s_5041_0,
            s_5041_1,
            s_5041_2,
            s_5041_3,
            s_5041_4,
            s_5041_5,
            s_5041_6,
        );
        // N s_5041_8: return
        return;
    }
    fn block_5042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5042_0: read-var opc2:u8
        let s_5042_0: u8 = fn_state.opc2;
        // D s_5042_1: cast zx s_5042_0 -> bv
        let s_5042_1: Bits = Bits::new(s_5042_0 as u128, 3u16);
        // C s_5042_2: const #0u : u8
        let s_5042_2: u8 = 0;
        // C s_5042_3: cast zx s_5042_2 -> bv
        let s_5042_3: Bits = Bits::new(s_5042_2 as u128, 3u16);
        // D s_5042_4: cmp-eq s_5042_1 s_5042_3
        let s_5042_4: bool = ((s_5042_1) == (s_5042_3));
        // D s_5042_5: write-var gs#118051 <= s_5042_4
        fn_state.gs_118051 = s_5042_4;
        // N s_5042_6: jump b1133
        return block_1133(state, tracer, fn_state);
    }
    fn block_5043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5043_0: read-var opc1:u8
        let s_5043_0: u8 = fn_state.opc1;
        // D s_5043_1: cast zx s_5043_0 -> bv
        let s_5043_1: Bits = Bits::new(s_5043_0 as u128, 3u16);
        // C s_5043_2: const #0u : u8
        let s_5043_2: u8 = 0;
        // C s_5043_3: cast zx s_5043_2 -> bv
        let s_5043_3: Bits = Bits::new(s_5043_2 as u128, 3u16);
        // D s_5043_4: cmp-eq s_5043_1 s_5043_3
        let s_5043_4: bool = ((s_5043_1) == (s_5043_3));
        // D s_5043_5: write-var gs#118050 <= s_5043_4
        fn_state.gs_118050 = s_5043_4;
        // N s_5043_6: jump b1131
        return block_1131(state, tracer, fn_state);
    }
    fn block_5044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5044_0: read-var coproc:u8
        let s_5044_0: u8 = fn_state.coproc;
        // D s_5044_1: cast zx s_5044_0 -> bv
        let s_5044_1: Bits = Bits::new(s_5044_0 as u128, 4u16);
        // C s_5044_2: const #15u : u8
        let s_5044_2: u8 = 15;
        // C s_5044_3: cast zx s_5044_2 -> bv
        let s_5044_3: Bits = Bits::new(s_5044_2 as u128, 4u16);
        // D s_5044_4: cmp-eq s_5044_1 s_5044_3
        let s_5044_4: bool = ((s_5044_1) == (s_5044_3));
        // D s_5044_5: write-var gs#118049 <= s_5044_4
        fn_state.gs_118049 = s_5044_4;
        // N s_5044_6: jump b1129
        return block_1129(state, tracer, fn_state);
    }
    fn block_5045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5045_0: read-var CRn:u8
        let s_5045_0: u8 = fn_state.CRn;
        // D s_5045_1: cast zx s_5045_0 -> bv
        let s_5045_1: Bits = Bits::new(s_5045_0 as u128, 4u16);
        // C s_5045_2: const #12u : u8
        let s_5045_2: u8 = 12;
        // C s_5045_3: cast zx s_5045_2 -> bv
        let s_5045_3: Bits = Bits::new(s_5045_2 as u128, 4u16);
        // D s_5045_4: cmp-eq s_5045_1 s_5045_3
        let s_5045_4: bool = ((s_5045_1) == (s_5045_3));
        // D s_5045_5: write-var gs#118048 <= s_5045_4
        fn_state.gs_118048 = s_5045_4;
        // N s_5045_6: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_5046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5046_0: read-var el:u8
        let s_5046_0: u8 = fn_state.el;
        // D s_5046_1: read-var coproc:u8
        let s_5046_1: u8 = fn_state.coproc;
        // D s_5046_2: read-var opc1:u8
        let s_5046_2: u8 = fn_state.opc1;
        // D s_5046_3: read-var CRn:u8
        let s_5046_3: u8 = fn_state.CRn;
        // D s_5046_4: read-var opc2:u8
        let s_5046_4: u8 = fn_state.opc2;
        // D s_5046_5: read-var CRm:u8
        let s_5046_5: u8 = fn_state.CRm;
        // D s_5046_6: read-var t:i
        let s_5046_6: i128 = fn_state.t;
        // D s_5046_7: call ICV_RPR_SysRegRead32_ce7e7d8c013c544d(s_5046_0, s_5046_1, s_5046_2, s_5046_3, s_5046_4, s_5046_5, s_5046_6)
        let s_5046_7: () = ICV_RPR_SysRegRead32_ce7e7d8c013c544d(
            state,
            tracer,
            s_5046_0,
            s_5046_1,
            s_5046_2,
            s_5046_3,
            s_5046_4,
            s_5046_5,
            s_5046_6,
        );
        // N s_5046_8: return
        return;
    }
    fn block_5047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5047_0: read-var opc2:u8
        let s_5047_0: u8 = fn_state.opc2;
        // D s_5047_1: cast zx s_5047_0 -> bv
        let s_5047_1: Bits = Bits::new(s_5047_0 as u128, 3u16);
        // C s_5047_2: const #3u : u8
        let s_5047_2: u8 = 3;
        // C s_5047_3: cast zx s_5047_2 -> bv
        let s_5047_3: Bits = Bits::new(s_5047_2 as u128, 3u16);
        // D s_5047_4: cmp-eq s_5047_1 s_5047_3
        let s_5047_4: bool = ((s_5047_1) == (s_5047_3));
        // D s_5047_5: write-var gs#118047 <= s_5047_4
        fn_state.gs_118047 = s_5047_4;
        // N s_5047_6: jump b1124
        return block_1124(state, tracer, fn_state);
    }
    fn block_5048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5048_0: read-var opc1:u8
        let s_5048_0: u8 = fn_state.opc1;
        // D s_5048_1: cast zx s_5048_0 -> bv
        let s_5048_1: Bits = Bits::new(s_5048_0 as u128, 3u16);
        // C s_5048_2: const #0u : u8
        let s_5048_2: u8 = 0;
        // C s_5048_3: cast zx s_5048_2 -> bv
        let s_5048_3: Bits = Bits::new(s_5048_2 as u128, 3u16);
        // D s_5048_4: cmp-eq s_5048_1 s_5048_3
        let s_5048_4: bool = ((s_5048_1) == (s_5048_3));
        // D s_5048_5: write-var gs#118046 <= s_5048_4
        fn_state.gs_118046 = s_5048_4;
        // N s_5048_6: jump b1122
        return block_1122(state, tracer, fn_state);
    }
    fn block_5049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5049_0: read-var coproc:u8
        let s_5049_0: u8 = fn_state.coproc;
        // D s_5049_1: cast zx s_5049_0 -> bv
        let s_5049_1: Bits = Bits::new(s_5049_0 as u128, 4u16);
        // C s_5049_2: const #15u : u8
        let s_5049_2: u8 = 15;
        // C s_5049_3: cast zx s_5049_2 -> bv
        let s_5049_3: Bits = Bits::new(s_5049_2 as u128, 4u16);
        // D s_5049_4: cmp-eq s_5049_1 s_5049_3
        let s_5049_4: bool = ((s_5049_1) == (s_5049_3));
        // D s_5049_5: write-var gs#118045 <= s_5049_4
        fn_state.gs_118045 = s_5049_4;
        // N s_5049_6: jump b1120
        return block_1120(state, tracer, fn_state);
    }
    fn block_5050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5050_0: read-var CRn:u8
        let s_5050_0: u8 = fn_state.CRn;
        // D s_5050_1: cast zx s_5050_0 -> bv
        let s_5050_1: Bits = Bits::new(s_5050_0 as u128, 4u16);
        // C s_5050_2: const #12u : u8
        let s_5050_2: u8 = 12;
        // C s_5050_3: cast zx s_5050_2 -> bv
        let s_5050_3: Bits = Bits::new(s_5050_2 as u128, 4u16);
        // D s_5050_4: cmp-eq s_5050_1 s_5050_3
        let s_5050_4: bool = ((s_5050_1) == (s_5050_3));
        // D s_5050_5: write-var gs#118044 <= s_5050_4
        fn_state.gs_118044 = s_5050_4;
        // N s_5050_6: jump b1118
        return block_1118(state, tracer, fn_state);
    }
    fn block_5051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5051_0: read-var el:u8
        let s_5051_0: u8 = fn_state.el;
        // D s_5051_1: read-var coproc:u8
        let s_5051_1: u8 = fn_state.coproc;
        // D s_5051_2: read-var opc1:u8
        let s_5051_2: u8 = fn_state.opc1;
        // D s_5051_3: read-var CRn:u8
        let s_5051_3: u8 = fn_state.CRn;
        // D s_5051_4: read-var opc2:u8
        let s_5051_4: u8 = fn_state.opc2;
        // D s_5051_5: read-var CRm:u8
        let s_5051_5: u8 = fn_state.CRm;
        // D s_5051_6: read-var t:i
        let s_5051_6: i128 = fn_state.t;
        // D s_5051_7: call PMXEVTYPER_SysRegRead32_7d423ea169145383(s_5051_0, s_5051_1, s_5051_2, s_5051_3, s_5051_4, s_5051_5, s_5051_6)
        let s_5051_7: () = PMXEVTYPER_SysRegRead32_7d423ea169145383(
            state,
            tracer,
            s_5051_0,
            s_5051_1,
            s_5051_2,
            s_5051_3,
            s_5051_4,
            s_5051_5,
            s_5051_6,
        );
        // N s_5051_8: return
        return;
    }
    fn block_5052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5052_0: read-var opc2:u8
        let s_5052_0: u8 = fn_state.opc2;
        // D s_5052_1: cast zx s_5052_0 -> bv
        let s_5052_1: Bits = Bits::new(s_5052_0 as u128, 3u16);
        // C s_5052_2: const #1u : u8
        let s_5052_2: u8 = 1;
        // C s_5052_3: cast zx s_5052_2 -> bv
        let s_5052_3: Bits = Bits::new(s_5052_2 as u128, 3u16);
        // D s_5052_4: cmp-eq s_5052_1 s_5052_3
        let s_5052_4: bool = ((s_5052_1) == (s_5052_3));
        // D s_5052_5: write-var gs#118043 <= s_5052_4
        fn_state.gs_118043 = s_5052_4;
        // N s_5052_6: jump b1115
        return block_1115(state, tracer, fn_state);
    }
    fn block_5053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5053_0: read-var opc1:u8
        let s_5053_0: u8 = fn_state.opc1;
        // D s_5053_1: cast zx s_5053_0 -> bv
        let s_5053_1: Bits = Bits::new(s_5053_0 as u128, 3u16);
        // C s_5053_2: const #0u : u8
        let s_5053_2: u8 = 0;
        // C s_5053_3: cast zx s_5053_2 -> bv
        let s_5053_3: Bits = Bits::new(s_5053_2 as u128, 3u16);
        // D s_5053_4: cmp-eq s_5053_1 s_5053_3
        let s_5053_4: bool = ((s_5053_1) == (s_5053_3));
        // D s_5053_5: write-var gs#118042 <= s_5053_4
        fn_state.gs_118042 = s_5053_4;
        // N s_5053_6: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_5054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5054_0: read-var coproc:u8
        let s_5054_0: u8 = fn_state.coproc;
        // D s_5054_1: cast zx s_5054_0 -> bv
        let s_5054_1: Bits = Bits::new(s_5054_0 as u128, 4u16);
        // C s_5054_2: const #15u : u8
        let s_5054_2: u8 = 15;
        // C s_5054_3: cast zx s_5054_2 -> bv
        let s_5054_3: Bits = Bits::new(s_5054_2 as u128, 4u16);
        // D s_5054_4: cmp-eq s_5054_1 s_5054_3
        let s_5054_4: bool = ((s_5054_1) == (s_5054_3));
        // D s_5054_5: write-var gs#118041 <= s_5054_4
        fn_state.gs_118041 = s_5054_4;
        // N s_5054_6: jump b1111
        return block_1111(state, tracer, fn_state);
    }
    fn block_5055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5055_0: read-var CRn:u8
        let s_5055_0: u8 = fn_state.CRn;
        // D s_5055_1: cast zx s_5055_0 -> bv
        let s_5055_1: Bits = Bits::new(s_5055_0 as u128, 4u16);
        // C s_5055_2: const #9u : u8
        let s_5055_2: u8 = 9;
        // C s_5055_3: cast zx s_5055_2 -> bv
        let s_5055_3: Bits = Bits::new(s_5055_2 as u128, 4u16);
        // D s_5055_4: cmp-eq s_5055_1 s_5055_3
        let s_5055_4: bool = ((s_5055_1) == (s_5055_3));
        // D s_5055_5: write-var gs#118040 <= s_5055_4
        fn_state.gs_118040 = s_5055_4;
        // N s_5055_6: jump b1109
        return block_1109(state, tracer, fn_state);
    }
    fn block_5056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5056_0: read-var el:u8
        let s_5056_0: u8 = fn_state.el;
        // D s_5056_1: read-var coproc:u8
        let s_5056_1: u8 = fn_state.coproc;
        // D s_5056_2: read-var opc1:u8
        let s_5056_2: u8 = fn_state.opc1;
        // D s_5056_3: read-var CRn:u8
        let s_5056_3: u8 = fn_state.CRn;
        // D s_5056_4: read-var opc2:u8
        let s_5056_4: u8 = fn_state.opc2;
        // D s_5056_5: read-var CRm:u8
        let s_5056_5: u8 = fn_state.CRm;
        // D s_5056_6: read-var t:i
        let s_5056_6: i128 = fn_state.t;
        // D s_5056_7: call ICC_BPR1_SysRegRead32_afd3e126a3be69bd(s_5056_0, s_5056_1, s_5056_2, s_5056_3, s_5056_4, s_5056_5, s_5056_6)
        let s_5056_7: () = ICC_BPR1_SysRegRead32_afd3e126a3be69bd(
            state,
            tracer,
            s_5056_0,
            s_5056_1,
            s_5056_2,
            s_5056_3,
            s_5056_4,
            s_5056_5,
            s_5056_6,
        );
        // N s_5056_8: return
        return;
    }
    fn block_5057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5057_0: read-var opc2:u8
        let s_5057_0: u8 = fn_state.opc2;
        // D s_5057_1: cast zx s_5057_0 -> bv
        let s_5057_1: Bits = Bits::new(s_5057_0 as u128, 3u16);
        // C s_5057_2: const #3u : u8
        let s_5057_2: u8 = 3;
        // C s_5057_3: cast zx s_5057_2 -> bv
        let s_5057_3: Bits = Bits::new(s_5057_2 as u128, 3u16);
        // D s_5057_4: cmp-eq s_5057_1 s_5057_3
        let s_5057_4: bool = ((s_5057_1) == (s_5057_3));
        // D s_5057_5: write-var gs#118039 <= s_5057_4
        fn_state.gs_118039 = s_5057_4;
        // N s_5057_6: jump b1106
        return block_1106(state, tracer, fn_state);
    }
    fn block_5058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5058_0: read-var opc1:u8
        let s_5058_0: u8 = fn_state.opc1;
        // D s_5058_1: cast zx s_5058_0 -> bv
        let s_5058_1: Bits = Bits::new(s_5058_0 as u128, 3u16);
        // C s_5058_2: const #0u : u8
        let s_5058_2: u8 = 0;
        // C s_5058_3: cast zx s_5058_2 -> bv
        let s_5058_3: Bits = Bits::new(s_5058_2 as u128, 3u16);
        // D s_5058_4: cmp-eq s_5058_1 s_5058_3
        let s_5058_4: bool = ((s_5058_1) == (s_5058_3));
        // D s_5058_5: write-var gs#118038 <= s_5058_4
        fn_state.gs_118038 = s_5058_4;
        // N s_5058_6: jump b1104
        return block_1104(state, tracer, fn_state);
    }
    fn block_5059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5059_0: read-var coproc:u8
        let s_5059_0: u8 = fn_state.coproc;
        // D s_5059_1: cast zx s_5059_0 -> bv
        let s_5059_1: Bits = Bits::new(s_5059_0 as u128, 4u16);
        // C s_5059_2: const #15u : u8
        let s_5059_2: u8 = 15;
        // C s_5059_3: cast zx s_5059_2 -> bv
        let s_5059_3: Bits = Bits::new(s_5059_2 as u128, 4u16);
        // D s_5059_4: cmp-eq s_5059_1 s_5059_3
        let s_5059_4: bool = ((s_5059_1) == (s_5059_3));
        // D s_5059_5: write-var gs#118037 <= s_5059_4
        fn_state.gs_118037 = s_5059_4;
        // N s_5059_6: jump b1102
        return block_1102(state, tracer, fn_state);
    }
    fn block_5060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5060_0: read-var CRn:u8
        let s_5060_0: u8 = fn_state.CRn;
        // D s_5060_1: cast zx s_5060_0 -> bv
        let s_5060_1: Bits = Bits::new(s_5060_0 as u128, 4u16);
        // C s_5060_2: const #12u : u8
        let s_5060_2: u8 = 12;
        // C s_5060_3: cast zx s_5060_2 -> bv
        let s_5060_3: Bits = Bits::new(s_5060_2 as u128, 4u16);
        // D s_5060_4: cmp-eq s_5060_1 s_5060_3
        let s_5060_4: bool = ((s_5060_1) == (s_5060_3));
        // D s_5060_5: write-var gs#118036 <= s_5060_4
        fn_state.gs_118036 = s_5060_4;
        // N s_5060_6: jump b1100
        return block_1100(state, tracer, fn_state);
    }
    fn block_5061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5061_0: read-var el:u8
        let s_5061_0: u8 = fn_state.el;
        // D s_5061_1: read-var coproc:u8
        let s_5061_1: u8 = fn_state.coproc;
        // D s_5061_2: read-var opc1:u8
        let s_5061_2: u8 = fn_state.opc1;
        // D s_5061_3: read-var CRn:u8
        let s_5061_3: u8 = fn_state.CRn;
        // D s_5061_4: read-var opc2:u8
        let s_5061_4: u8 = fn_state.opc2;
        // D s_5061_5: read-var CRm:u8
        let s_5061_5: u8 = fn_state.CRm;
        // D s_5061_6: read-var t:i
        let s_5061_6: i128 = fn_state.t;
        // D s_5061_7: call DBGDEVID1_SysRegRead32_faeb62347ce88c7a(s_5061_0, s_5061_1, s_5061_2, s_5061_3, s_5061_4, s_5061_5, s_5061_6)
        let s_5061_7: () = DBGDEVID1_SysRegRead32_faeb62347ce88c7a(
            state,
            tracer,
            s_5061_0,
            s_5061_1,
            s_5061_2,
            s_5061_3,
            s_5061_4,
            s_5061_5,
            s_5061_6,
        );
        // N s_5061_8: return
        return;
    }
    fn block_5062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5062_0: read-var opc2:u8
        let s_5062_0: u8 = fn_state.opc2;
        // D s_5062_1: cast zx s_5062_0 -> bv
        let s_5062_1: Bits = Bits::new(s_5062_0 as u128, 3u16);
        // C s_5062_2: const #7u : u8
        let s_5062_2: u8 = 7;
        // C s_5062_3: cast zx s_5062_2 -> bv
        let s_5062_3: Bits = Bits::new(s_5062_2 as u128, 3u16);
        // D s_5062_4: cmp-eq s_5062_1 s_5062_3
        let s_5062_4: bool = ((s_5062_1) == (s_5062_3));
        // D s_5062_5: write-var gs#118035 <= s_5062_4
        fn_state.gs_118035 = s_5062_4;
        // N s_5062_6: jump b1097
        return block_1097(state, tracer, fn_state);
    }
    fn block_5063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5063_0: read-var opc1:u8
        let s_5063_0: u8 = fn_state.opc1;
        // D s_5063_1: cast zx s_5063_0 -> bv
        let s_5063_1: Bits = Bits::new(s_5063_0 as u128, 3u16);
        // C s_5063_2: const #0u : u8
        let s_5063_2: u8 = 0;
        // C s_5063_3: cast zx s_5063_2 -> bv
        let s_5063_3: Bits = Bits::new(s_5063_2 as u128, 3u16);
        // D s_5063_4: cmp-eq s_5063_1 s_5063_3
        let s_5063_4: bool = ((s_5063_1) == (s_5063_3));
        // D s_5063_5: write-var gs#118034 <= s_5063_4
        fn_state.gs_118034 = s_5063_4;
        // N s_5063_6: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_5064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5064_0: read-var coproc:u8
        let s_5064_0: u8 = fn_state.coproc;
        // D s_5064_1: cast zx s_5064_0 -> bv
        let s_5064_1: Bits = Bits::new(s_5064_0 as u128, 4u16);
        // C s_5064_2: const #14u : u8
        let s_5064_2: u8 = 14;
        // C s_5064_3: cast zx s_5064_2 -> bv
        let s_5064_3: Bits = Bits::new(s_5064_2 as u128, 4u16);
        // D s_5064_4: cmp-eq s_5064_1 s_5064_3
        let s_5064_4: bool = ((s_5064_1) == (s_5064_3));
        // D s_5064_5: write-var gs#118033 <= s_5064_4
        fn_state.gs_118033 = s_5064_4;
        // N s_5064_6: jump b1093
        return block_1093(state, tracer, fn_state);
    }
    fn block_5065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5065_0: read-var CRn:u8
        let s_5065_0: u8 = fn_state.CRn;
        // D s_5065_1: cast zx s_5065_0 -> bv
        let s_5065_1: Bits = Bits::new(s_5065_0 as u128, 4u16);
        // C s_5065_2: const #7u : u8
        let s_5065_2: u8 = 7;
        // C s_5065_3: cast zx s_5065_2 -> bv
        let s_5065_3: Bits = Bits::new(s_5065_2 as u128, 4u16);
        // D s_5065_4: cmp-eq s_5065_1 s_5065_3
        let s_5065_4: bool = ((s_5065_1) == (s_5065_3));
        // D s_5065_5: write-var gs#118032 <= s_5065_4
        fn_state.gs_118032 = s_5065_4;
        // N s_5065_6: jump b1091
        return block_1091(state, tracer, fn_state);
    }
    fn block_5066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5066_0: read-var el:u8
        let s_5066_0: u8 = fn_state.el;
        // D s_5066_1: read-var coproc:u8
        let s_5066_1: u8 = fn_state.coproc;
        // D s_5066_2: read-var opc1:u8
        let s_5066_2: u8 = fn_state.opc1;
        // D s_5066_3: read-var CRn:u8
        let s_5066_3: u8 = fn_state.CRn;
        // D s_5066_4: read-var opc2:u8
        let s_5066_4: u8 = fn_state.opc2;
        // D s_5066_5: read-var CRm:u8
        let s_5066_5: u8 = fn_state.CRm;
        // D s_5066_6: read-var t:i
        let s_5066_6: i128 = fn_state.t;
        // D s_5066_7: call ICH_VMCR_SysRegRead32_c4afb8cb8e0d0a5d(s_5066_0, s_5066_1, s_5066_2, s_5066_3, s_5066_4, s_5066_5, s_5066_6)
        let s_5066_7: () = ICH_VMCR_SysRegRead32_c4afb8cb8e0d0a5d(
            state,
            tracer,
            s_5066_0,
            s_5066_1,
            s_5066_2,
            s_5066_3,
            s_5066_4,
            s_5066_5,
            s_5066_6,
        );
        // N s_5066_8: return
        return;
    }
    fn block_5067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5067_0: read-var opc2:u8
        let s_5067_0: u8 = fn_state.opc2;
        // D s_5067_1: cast zx s_5067_0 -> bv
        let s_5067_1: Bits = Bits::new(s_5067_0 as u128, 3u16);
        // C s_5067_2: const #7u : u8
        let s_5067_2: u8 = 7;
        // C s_5067_3: cast zx s_5067_2 -> bv
        let s_5067_3: Bits = Bits::new(s_5067_2 as u128, 3u16);
        // D s_5067_4: cmp-eq s_5067_1 s_5067_3
        let s_5067_4: bool = ((s_5067_1) == (s_5067_3));
        // D s_5067_5: write-var gs#118031 <= s_5067_4
        fn_state.gs_118031 = s_5067_4;
        // N s_5067_6: jump b1088
        return block_1088(state, tracer, fn_state);
    }
    fn block_5068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5068_0: read-var opc1:u8
        let s_5068_0: u8 = fn_state.opc1;
        // D s_5068_1: cast zx s_5068_0 -> bv
        let s_5068_1: Bits = Bits::new(s_5068_0 as u128, 3u16);
        // C s_5068_2: const #4u : u8
        let s_5068_2: u8 = 4;
        // C s_5068_3: cast zx s_5068_2 -> bv
        let s_5068_3: Bits = Bits::new(s_5068_2 as u128, 3u16);
        // D s_5068_4: cmp-eq s_5068_1 s_5068_3
        let s_5068_4: bool = ((s_5068_1) == (s_5068_3));
        // D s_5068_5: write-var gs#118030 <= s_5068_4
        fn_state.gs_118030 = s_5068_4;
        // N s_5068_6: jump b1086
        return block_1086(state, tracer, fn_state);
    }
    fn block_5069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5069_0: read-var coproc:u8
        let s_5069_0: u8 = fn_state.coproc;
        // D s_5069_1: cast zx s_5069_0 -> bv
        let s_5069_1: Bits = Bits::new(s_5069_0 as u128, 4u16);
        // C s_5069_2: const #15u : u8
        let s_5069_2: u8 = 15;
        // C s_5069_3: cast zx s_5069_2 -> bv
        let s_5069_3: Bits = Bits::new(s_5069_2 as u128, 4u16);
        // D s_5069_4: cmp-eq s_5069_1 s_5069_3
        let s_5069_4: bool = ((s_5069_1) == (s_5069_3));
        // D s_5069_5: write-var gs#118029 <= s_5069_4
        fn_state.gs_118029 = s_5069_4;
        // N s_5069_6: jump b1084
        return block_1084(state, tracer, fn_state);
    }
    fn block_5070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5070_0: read-var CRn:u8
        let s_5070_0: u8 = fn_state.CRn;
        // D s_5070_1: cast zx s_5070_0 -> bv
        let s_5070_1: Bits = Bits::new(s_5070_0 as u128, 4u16);
        // C s_5070_2: const #12u : u8
        let s_5070_2: u8 = 12;
        // C s_5070_3: cast zx s_5070_2 -> bv
        let s_5070_3: Bits = Bits::new(s_5070_2 as u128, 4u16);
        // D s_5070_4: cmp-eq s_5070_1 s_5070_3
        let s_5070_4: bool = ((s_5070_1) == (s_5070_3));
        // D s_5070_5: write-var gs#118028 <= s_5070_4
        fn_state.gs_118028 = s_5070_4;
        // N s_5070_6: jump b1082
        return block_1082(state, tracer, fn_state);
    }
    fn block_5071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5071_0: read-var el:u8
        let s_5071_0: u8 = fn_state.el;
        // D s_5071_1: read-var coproc:u8
        let s_5071_1: u8 = fn_state.coproc;
        // D s_5071_2: read-var opc1:u8
        let s_5071_2: u8 = fn_state.opc1;
        // D s_5071_3: read-var CRn:u8
        let s_5071_3: u8 = fn_state.CRn;
        // D s_5071_4: read-var opc2:u8
        let s_5071_4: u8 = fn_state.opc2;
        // D s_5071_5: read-var CRm:u8
        let s_5071_5: u8 = fn_state.CRm;
        // D s_5071_6: read-var t:i
        let s_5071_6: i128 = fn_state.t;
        // D s_5071_7: call DBGWCR_SysRegRead32_a166e9fb14e381a7(s_5071_0, s_5071_1, s_5071_2, s_5071_3, s_5071_4, s_5071_5, s_5071_6)
        let s_5071_7: () = DBGWCR_SysRegRead32_a166e9fb14e381a7(
            state,
            tracer,
            s_5071_0,
            s_5071_1,
            s_5071_2,
            s_5071_3,
            s_5071_4,
            s_5071_5,
            s_5071_6,
        );
        // N s_5071_8: return
        return;
    }
    fn block_5072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5072_0: read-var opc2:u8
        let s_5072_0: u8 = fn_state.opc2;
        // D s_5072_1: cast zx s_5072_0 -> bv
        let s_5072_1: Bits = Bits::new(s_5072_0 as u128, 3u16);
        // C s_5072_2: const #7u : u8
        let s_5072_2: u8 = 7;
        // C s_5072_3: cast zx s_5072_2 -> bv
        let s_5072_3: Bits = Bits::new(s_5072_2 as u128, 3u16);
        // D s_5072_4: cmp-eq s_5072_1 s_5072_3
        let s_5072_4: bool = ((s_5072_1) == (s_5072_3));
        // D s_5072_5: write-var gs#118027 <= s_5072_4
        fn_state.gs_118027 = s_5072_4;
        // N s_5072_6: jump b1079
        return block_1079(state, tracer, fn_state);
    }
    fn block_5073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5073_0: read-var opc1:u8
        let s_5073_0: u8 = fn_state.opc1;
        // D s_5073_1: cast zx s_5073_0 -> bv
        let s_5073_1: Bits = Bits::new(s_5073_0 as u128, 3u16);
        // C s_5073_2: const #0u : u8
        let s_5073_2: u8 = 0;
        // C s_5073_3: cast zx s_5073_2 -> bv
        let s_5073_3: Bits = Bits::new(s_5073_2 as u128, 3u16);
        // D s_5073_4: cmp-eq s_5073_1 s_5073_3
        let s_5073_4: bool = ((s_5073_1) == (s_5073_3));
        // D s_5073_5: write-var gs#118026 <= s_5073_4
        fn_state.gs_118026 = s_5073_4;
        // N s_5073_6: jump b1077
        return block_1077(state, tracer, fn_state);
    }
    fn block_5074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5074_0: read-var coproc:u8
        let s_5074_0: u8 = fn_state.coproc;
        // D s_5074_1: cast zx s_5074_0 -> bv
        let s_5074_1: Bits = Bits::new(s_5074_0 as u128, 4u16);
        // C s_5074_2: const #14u : u8
        let s_5074_2: u8 = 14;
        // C s_5074_3: cast zx s_5074_2 -> bv
        let s_5074_3: Bits = Bits::new(s_5074_2 as u128, 4u16);
        // D s_5074_4: cmp-eq s_5074_1 s_5074_3
        let s_5074_4: bool = ((s_5074_1) == (s_5074_3));
        // D s_5074_5: write-var gs#118025 <= s_5074_4
        fn_state.gs_118025 = s_5074_4;
        // N s_5074_6: jump b1075
        return block_1075(state, tracer, fn_state);
    }
    fn block_5075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5075_0: read-var CRn:u8
        let s_5075_0: u8 = fn_state.CRn;
        // D s_5075_1: cast zx s_5075_0 -> bv
        let s_5075_1: Bits = Bits::new(s_5075_0 as u128, 4u16);
        // C s_5075_2: const #0u : u8
        let s_5075_2: u8 = 0;
        // C s_5075_3: cast zx s_5075_2 -> bv
        let s_5075_3: Bits = Bits::new(s_5075_2 as u128, 4u16);
        // D s_5075_4: cmp-eq s_5075_1 s_5075_3
        let s_5075_4: bool = ((s_5075_1) == (s_5075_3));
        // D s_5075_5: write-var gs#118024 <= s_5075_4
        fn_state.gs_118024 = s_5075_4;
        // N s_5075_6: jump b1073
        return block_1073(state, tracer, fn_state);
    }
    fn block_5076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5076_0: read-var el:u8
        let s_5076_0: u8 = fn_state.el;
        // D s_5076_1: read-var coproc:u8
        let s_5076_1: u8 = fn_state.coproc;
        // D s_5076_2: read-var opc1:u8
        let s_5076_2: u8 = fn_state.opc1;
        // D s_5076_3: read-var CRn:u8
        let s_5076_3: u8 = fn_state.CRn;
        // D s_5076_4: read-var opc2:u8
        let s_5076_4: u8 = fn_state.opc2;
        // D s_5076_5: read-var CRm:u8
        let s_5076_5: u8 = fn_state.CRm;
        // D s_5076_6: read-var t:i
        let s_5076_6: i128 = fn_state.t;
        // D s_5076_7: call DBGWCR_SysRegRead32_e262457611dfe741(s_5076_0, s_5076_1, s_5076_2, s_5076_3, s_5076_4, s_5076_5, s_5076_6)
        let s_5076_7: () = DBGWCR_SysRegRead32_e262457611dfe741(
            state,
            tracer,
            s_5076_0,
            s_5076_1,
            s_5076_2,
            s_5076_3,
            s_5076_4,
            s_5076_5,
            s_5076_6,
        );
        // N s_5076_8: return
        return;
    }
    fn block_5077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5077_0: read-var opc2:u8
        let s_5077_0: u8 = fn_state.opc2;
        // D s_5077_1: cast zx s_5077_0 -> bv
        let s_5077_1: Bits = Bits::new(s_5077_0 as u128, 3u16);
        // C s_5077_2: const #7u : u8
        let s_5077_2: u8 = 7;
        // C s_5077_3: cast zx s_5077_2 -> bv
        let s_5077_3: Bits = Bits::new(s_5077_2 as u128, 3u16);
        // D s_5077_4: cmp-eq s_5077_1 s_5077_3
        let s_5077_4: bool = ((s_5077_1) == (s_5077_3));
        // D s_5077_5: write-var gs#118023 <= s_5077_4
        fn_state.gs_118023 = s_5077_4;
        // N s_5077_6: jump b1070
        return block_1070(state, tracer, fn_state);
    }
    fn block_5078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5078_0: read-var opc1:u8
        let s_5078_0: u8 = fn_state.opc1;
        // D s_5078_1: cast zx s_5078_0 -> bv
        let s_5078_1: Bits = Bits::new(s_5078_0 as u128, 3u16);
        // C s_5078_2: const #0u : u8
        let s_5078_2: u8 = 0;
        // C s_5078_3: cast zx s_5078_2 -> bv
        let s_5078_3: Bits = Bits::new(s_5078_2 as u128, 3u16);
        // D s_5078_4: cmp-eq s_5078_1 s_5078_3
        let s_5078_4: bool = ((s_5078_1) == (s_5078_3));
        // D s_5078_5: write-var gs#118022 <= s_5078_4
        fn_state.gs_118022 = s_5078_4;
        // N s_5078_6: jump b1068
        return block_1068(state, tracer, fn_state);
    }
    fn block_5079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5079_0: read-var coproc:u8
        let s_5079_0: u8 = fn_state.coproc;
        // D s_5079_1: cast zx s_5079_0 -> bv
        let s_5079_1: Bits = Bits::new(s_5079_0 as u128, 4u16);
        // C s_5079_2: const #14u : u8
        let s_5079_2: u8 = 14;
        // C s_5079_3: cast zx s_5079_2 -> bv
        let s_5079_3: Bits = Bits::new(s_5079_2 as u128, 4u16);
        // D s_5079_4: cmp-eq s_5079_1 s_5079_3
        let s_5079_4: bool = ((s_5079_1) == (s_5079_3));
        // D s_5079_5: write-var gs#118021 <= s_5079_4
        fn_state.gs_118021 = s_5079_4;
        // N s_5079_6: jump b1066
        return block_1066(state, tracer, fn_state);
    }
    fn block_5080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5080_0: read-var CRn:u8
        let s_5080_0: u8 = fn_state.CRn;
        // D s_5080_1: cast zx s_5080_0 -> bv
        let s_5080_1: Bits = Bits::new(s_5080_0 as u128, 4u16);
        // C s_5080_2: const #0u : u8
        let s_5080_2: u8 = 0;
        // C s_5080_3: cast zx s_5080_2 -> bv
        let s_5080_3: Bits = Bits::new(s_5080_2 as u128, 4u16);
        // D s_5080_4: cmp-eq s_5080_1 s_5080_3
        let s_5080_4: bool = ((s_5080_1) == (s_5080_3));
        // D s_5080_5: write-var gs#118020 <= s_5080_4
        fn_state.gs_118020 = s_5080_4;
        // N s_5080_6: jump b1064
        return block_1064(state, tracer, fn_state);
    }
    fn block_5081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5081_0: read-var el:u8
        let s_5081_0: u8 = fn_state.el;
        // D s_5081_1: read-var coproc:u8
        let s_5081_1: u8 = fn_state.coproc;
        // D s_5081_2: read-var opc1:u8
        let s_5081_2: u8 = fn_state.opc1;
        // D s_5081_3: read-var CRn:u8
        let s_5081_3: u8 = fn_state.CRn;
        // D s_5081_4: read-var opc2:u8
        let s_5081_4: u8 = fn_state.opc2;
        // D s_5081_5: read-var CRm:u8
        let s_5081_5: u8 = fn_state.CRm;
        // D s_5081_6: read-var t:i
        let s_5081_6: i128 = fn_state.t;
        // D s_5081_7: call DBGWCR_SysRegRead32_c04d3d89801ab85d(s_5081_0, s_5081_1, s_5081_2, s_5081_3, s_5081_4, s_5081_5, s_5081_6)
        let s_5081_7: () = DBGWCR_SysRegRead32_c04d3d89801ab85d(
            state,
            tracer,
            s_5081_0,
            s_5081_1,
            s_5081_2,
            s_5081_3,
            s_5081_4,
            s_5081_5,
            s_5081_6,
        );
        // N s_5081_8: return
        return;
    }
    fn block_5082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5082_0: read-var opc2:u8
        let s_5082_0: u8 = fn_state.opc2;
        // D s_5082_1: cast zx s_5082_0 -> bv
        let s_5082_1: Bits = Bits::new(s_5082_0 as u128, 3u16);
        // C s_5082_2: const #7u : u8
        let s_5082_2: u8 = 7;
        // C s_5082_3: cast zx s_5082_2 -> bv
        let s_5082_3: Bits = Bits::new(s_5082_2 as u128, 3u16);
        // D s_5082_4: cmp-eq s_5082_1 s_5082_3
        let s_5082_4: bool = ((s_5082_1) == (s_5082_3));
        // D s_5082_5: write-var gs#118019 <= s_5082_4
        fn_state.gs_118019 = s_5082_4;
        // N s_5082_6: jump b1061
        return block_1061(state, tracer, fn_state);
    }
    fn block_5083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5083_0: read-var opc1:u8
        let s_5083_0: u8 = fn_state.opc1;
        // D s_5083_1: cast zx s_5083_0 -> bv
        let s_5083_1: Bits = Bits::new(s_5083_0 as u128, 3u16);
        // C s_5083_2: const #0u : u8
        let s_5083_2: u8 = 0;
        // C s_5083_3: cast zx s_5083_2 -> bv
        let s_5083_3: Bits = Bits::new(s_5083_2 as u128, 3u16);
        // D s_5083_4: cmp-eq s_5083_1 s_5083_3
        let s_5083_4: bool = ((s_5083_1) == (s_5083_3));
        // D s_5083_5: write-var gs#118018 <= s_5083_4
        fn_state.gs_118018 = s_5083_4;
        // N s_5083_6: jump b1059
        return block_1059(state, tracer, fn_state);
    }
    fn block_5084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5084_0: read-var coproc:u8
        let s_5084_0: u8 = fn_state.coproc;
        // D s_5084_1: cast zx s_5084_0 -> bv
        let s_5084_1: Bits = Bits::new(s_5084_0 as u128, 4u16);
        // C s_5084_2: const #14u : u8
        let s_5084_2: u8 = 14;
        // C s_5084_3: cast zx s_5084_2 -> bv
        let s_5084_3: Bits = Bits::new(s_5084_2 as u128, 4u16);
        // D s_5084_4: cmp-eq s_5084_1 s_5084_3
        let s_5084_4: bool = ((s_5084_1) == (s_5084_3));
        // D s_5084_5: write-var gs#118017 <= s_5084_4
        fn_state.gs_118017 = s_5084_4;
        // N s_5084_6: jump b1057
        return block_1057(state, tracer, fn_state);
    }
    fn block_5085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5085_0: read-var CRn:u8
        let s_5085_0: u8 = fn_state.CRn;
        // D s_5085_1: cast zx s_5085_0 -> bv
        let s_5085_1: Bits = Bits::new(s_5085_0 as u128, 4u16);
        // C s_5085_2: const #0u : u8
        let s_5085_2: u8 = 0;
        // C s_5085_3: cast zx s_5085_2 -> bv
        let s_5085_3: Bits = Bits::new(s_5085_2 as u128, 4u16);
        // D s_5085_4: cmp-eq s_5085_1 s_5085_3
        let s_5085_4: bool = ((s_5085_1) == (s_5085_3));
        // D s_5085_5: write-var gs#118016 <= s_5085_4
        fn_state.gs_118016 = s_5085_4;
        // N s_5085_6: jump b1055
        return block_1055(state, tracer, fn_state);
    }
    fn block_5086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5086_0: read-var el:u8
        let s_5086_0: u8 = fn_state.el;
        // D s_5086_1: read-var coproc:u8
        let s_5086_1: u8 = fn_state.coproc;
        // D s_5086_2: read-var opc1:u8
        let s_5086_2: u8 = fn_state.opc1;
        // D s_5086_3: read-var CRn:u8
        let s_5086_3: u8 = fn_state.CRn;
        // D s_5086_4: read-var opc2:u8
        let s_5086_4: u8 = fn_state.opc2;
        // D s_5086_5: read-var CRm:u8
        let s_5086_5: u8 = fn_state.CRm;
        // D s_5086_6: read-var t:i
        let s_5086_6: i128 = fn_state.t;
        // D s_5086_7: call DBGWCR_SysRegRead32_862efdc01d71fc1c(s_5086_0, s_5086_1, s_5086_2, s_5086_3, s_5086_4, s_5086_5, s_5086_6)
        let s_5086_7: () = DBGWCR_SysRegRead32_862efdc01d71fc1c(
            state,
            tracer,
            s_5086_0,
            s_5086_1,
            s_5086_2,
            s_5086_3,
            s_5086_4,
            s_5086_5,
            s_5086_6,
        );
        // N s_5086_8: return
        return;
    }
    fn block_5087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5087_0: read-var opc2:u8
        let s_5087_0: u8 = fn_state.opc2;
        // D s_5087_1: cast zx s_5087_0 -> bv
        let s_5087_1: Bits = Bits::new(s_5087_0 as u128, 3u16);
        // C s_5087_2: const #7u : u8
        let s_5087_2: u8 = 7;
        // C s_5087_3: cast zx s_5087_2 -> bv
        let s_5087_3: Bits = Bits::new(s_5087_2 as u128, 3u16);
        // D s_5087_4: cmp-eq s_5087_1 s_5087_3
        let s_5087_4: bool = ((s_5087_1) == (s_5087_3));
        // D s_5087_5: write-var gs#118015 <= s_5087_4
        fn_state.gs_118015 = s_5087_4;
        // N s_5087_6: jump b1052
        return block_1052(state, tracer, fn_state);
    }
    fn block_5088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5088_0: read-var opc1:u8
        let s_5088_0: u8 = fn_state.opc1;
        // D s_5088_1: cast zx s_5088_0 -> bv
        let s_5088_1: Bits = Bits::new(s_5088_0 as u128, 3u16);
        // C s_5088_2: const #0u : u8
        let s_5088_2: u8 = 0;
        // C s_5088_3: cast zx s_5088_2 -> bv
        let s_5088_3: Bits = Bits::new(s_5088_2 as u128, 3u16);
        // D s_5088_4: cmp-eq s_5088_1 s_5088_3
        let s_5088_4: bool = ((s_5088_1) == (s_5088_3));
        // D s_5088_5: write-var gs#118014 <= s_5088_4
        fn_state.gs_118014 = s_5088_4;
        // N s_5088_6: jump b1050
        return block_1050(state, tracer, fn_state);
    }
    fn block_5089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5089_0: read-var coproc:u8
        let s_5089_0: u8 = fn_state.coproc;
        // D s_5089_1: cast zx s_5089_0 -> bv
        let s_5089_1: Bits = Bits::new(s_5089_0 as u128, 4u16);
        // C s_5089_2: const #14u : u8
        let s_5089_2: u8 = 14;
        // C s_5089_3: cast zx s_5089_2 -> bv
        let s_5089_3: Bits = Bits::new(s_5089_2 as u128, 4u16);
        // D s_5089_4: cmp-eq s_5089_1 s_5089_3
        let s_5089_4: bool = ((s_5089_1) == (s_5089_3));
        // D s_5089_5: write-var gs#118013 <= s_5089_4
        fn_state.gs_118013 = s_5089_4;
        // N s_5089_6: jump b1048
        return block_1048(state, tracer, fn_state);
    }
    fn block_5090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5090_0: read-var CRn:u8
        let s_5090_0: u8 = fn_state.CRn;
        // D s_5090_1: cast zx s_5090_0 -> bv
        let s_5090_1: Bits = Bits::new(s_5090_0 as u128, 4u16);
        // C s_5090_2: const #0u : u8
        let s_5090_2: u8 = 0;
        // C s_5090_3: cast zx s_5090_2 -> bv
        let s_5090_3: Bits = Bits::new(s_5090_2 as u128, 4u16);
        // D s_5090_4: cmp-eq s_5090_1 s_5090_3
        let s_5090_4: bool = ((s_5090_1) == (s_5090_3));
        // D s_5090_5: write-var gs#118012 <= s_5090_4
        fn_state.gs_118012 = s_5090_4;
        // N s_5090_6: jump b1046
        return block_1046(state, tracer, fn_state);
    }
    fn block_5091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5091_0: read-var el:u8
        let s_5091_0: u8 = fn_state.el;
        // D s_5091_1: read-var coproc:u8
        let s_5091_1: u8 = fn_state.coproc;
        // D s_5091_2: read-var opc1:u8
        let s_5091_2: u8 = fn_state.opc1;
        // D s_5091_3: read-var CRn:u8
        let s_5091_3: u8 = fn_state.CRn;
        // D s_5091_4: read-var opc2:u8
        let s_5091_4: u8 = fn_state.opc2;
        // D s_5091_5: read-var CRm:u8
        let s_5091_5: u8 = fn_state.CRm;
        // D s_5091_6: read-var t:i
        let s_5091_6: i128 = fn_state.t;
        // D s_5091_7: call DBGWCR_SysRegRead32_c11448c554efe1b1(s_5091_0, s_5091_1, s_5091_2, s_5091_3, s_5091_4, s_5091_5, s_5091_6)
        let s_5091_7: () = DBGWCR_SysRegRead32_c11448c554efe1b1(
            state,
            tracer,
            s_5091_0,
            s_5091_1,
            s_5091_2,
            s_5091_3,
            s_5091_4,
            s_5091_5,
            s_5091_6,
        );
        // N s_5091_8: return
        return;
    }
    fn block_5092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5092_0: read-var opc2:u8
        let s_5092_0: u8 = fn_state.opc2;
        // D s_5092_1: cast zx s_5092_0 -> bv
        let s_5092_1: Bits = Bits::new(s_5092_0 as u128, 3u16);
        // C s_5092_2: const #7u : u8
        let s_5092_2: u8 = 7;
        // C s_5092_3: cast zx s_5092_2 -> bv
        let s_5092_3: Bits = Bits::new(s_5092_2 as u128, 3u16);
        // D s_5092_4: cmp-eq s_5092_1 s_5092_3
        let s_5092_4: bool = ((s_5092_1) == (s_5092_3));
        // D s_5092_5: write-var gs#118011 <= s_5092_4
        fn_state.gs_118011 = s_5092_4;
        // N s_5092_6: jump b1043
        return block_1043(state, tracer, fn_state);
    }
    fn block_5093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5093_0: read-var opc1:u8
        let s_5093_0: u8 = fn_state.opc1;
        // D s_5093_1: cast zx s_5093_0 -> bv
        let s_5093_1: Bits = Bits::new(s_5093_0 as u128, 3u16);
        // C s_5093_2: const #0u : u8
        let s_5093_2: u8 = 0;
        // C s_5093_3: cast zx s_5093_2 -> bv
        let s_5093_3: Bits = Bits::new(s_5093_2 as u128, 3u16);
        // D s_5093_4: cmp-eq s_5093_1 s_5093_3
        let s_5093_4: bool = ((s_5093_1) == (s_5093_3));
        // D s_5093_5: write-var gs#118010 <= s_5093_4
        fn_state.gs_118010 = s_5093_4;
        // N s_5093_6: jump b1041
        return block_1041(state, tracer, fn_state);
    }
    fn block_5094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5094_0: read-var coproc:u8
        let s_5094_0: u8 = fn_state.coproc;
        // D s_5094_1: cast zx s_5094_0 -> bv
        let s_5094_1: Bits = Bits::new(s_5094_0 as u128, 4u16);
        // C s_5094_2: const #14u : u8
        let s_5094_2: u8 = 14;
        // C s_5094_3: cast zx s_5094_2 -> bv
        let s_5094_3: Bits = Bits::new(s_5094_2 as u128, 4u16);
        // D s_5094_4: cmp-eq s_5094_1 s_5094_3
        let s_5094_4: bool = ((s_5094_1) == (s_5094_3));
        // D s_5094_5: write-var gs#118009 <= s_5094_4
        fn_state.gs_118009 = s_5094_4;
        // N s_5094_6: jump b1039
        return block_1039(state, tracer, fn_state);
    }
    fn block_5095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5095_0: read-var CRn:u8
        let s_5095_0: u8 = fn_state.CRn;
        // D s_5095_1: cast zx s_5095_0 -> bv
        let s_5095_1: Bits = Bits::new(s_5095_0 as u128, 4u16);
        // C s_5095_2: const #0u : u8
        let s_5095_2: u8 = 0;
        // C s_5095_3: cast zx s_5095_2 -> bv
        let s_5095_3: Bits = Bits::new(s_5095_2 as u128, 4u16);
        // D s_5095_4: cmp-eq s_5095_1 s_5095_3
        let s_5095_4: bool = ((s_5095_1) == (s_5095_3));
        // D s_5095_5: write-var gs#118008 <= s_5095_4
        fn_state.gs_118008 = s_5095_4;
        // N s_5095_6: jump b1037
        return block_1037(state, tracer, fn_state);
    }
    fn block_5096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5096_0: read-var el:u8
        let s_5096_0: u8 = fn_state.el;
        // D s_5096_1: read-var coproc:u8
        let s_5096_1: u8 = fn_state.coproc;
        // D s_5096_2: read-var opc1:u8
        let s_5096_2: u8 = fn_state.opc1;
        // D s_5096_3: read-var CRn:u8
        let s_5096_3: u8 = fn_state.CRn;
        // D s_5096_4: read-var opc2:u8
        let s_5096_4: u8 = fn_state.opc2;
        // D s_5096_5: read-var CRm:u8
        let s_5096_5: u8 = fn_state.CRm;
        // D s_5096_6: read-var t:i
        let s_5096_6: i128 = fn_state.t;
        // D s_5096_7: call DBGWCR_SysRegRead32_696fee9dbbdf30bb(s_5096_0, s_5096_1, s_5096_2, s_5096_3, s_5096_4, s_5096_5, s_5096_6)
        let s_5096_7: () = DBGWCR_SysRegRead32_696fee9dbbdf30bb(
            state,
            tracer,
            s_5096_0,
            s_5096_1,
            s_5096_2,
            s_5096_3,
            s_5096_4,
            s_5096_5,
            s_5096_6,
        );
        // N s_5096_8: return
        return;
    }
    fn block_5097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5097_0: read-var opc2:u8
        let s_5097_0: u8 = fn_state.opc2;
        // D s_5097_1: cast zx s_5097_0 -> bv
        let s_5097_1: Bits = Bits::new(s_5097_0 as u128, 3u16);
        // C s_5097_2: const #7u : u8
        let s_5097_2: u8 = 7;
        // C s_5097_3: cast zx s_5097_2 -> bv
        let s_5097_3: Bits = Bits::new(s_5097_2 as u128, 3u16);
        // D s_5097_4: cmp-eq s_5097_1 s_5097_3
        let s_5097_4: bool = ((s_5097_1) == (s_5097_3));
        // D s_5097_5: write-var gs#118007 <= s_5097_4
        fn_state.gs_118007 = s_5097_4;
        // N s_5097_6: jump b1034
        return block_1034(state, tracer, fn_state);
    }
    fn block_5098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5098_0: read-var opc1:u8
        let s_5098_0: u8 = fn_state.opc1;
        // D s_5098_1: cast zx s_5098_0 -> bv
        let s_5098_1: Bits = Bits::new(s_5098_0 as u128, 3u16);
        // C s_5098_2: const #0u : u8
        let s_5098_2: u8 = 0;
        // C s_5098_3: cast zx s_5098_2 -> bv
        let s_5098_3: Bits = Bits::new(s_5098_2 as u128, 3u16);
        // D s_5098_4: cmp-eq s_5098_1 s_5098_3
        let s_5098_4: bool = ((s_5098_1) == (s_5098_3));
        // D s_5098_5: write-var gs#118006 <= s_5098_4
        fn_state.gs_118006 = s_5098_4;
        // N s_5098_6: jump b1032
        return block_1032(state, tracer, fn_state);
    }
    fn block_5099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5099_0: read-var coproc:u8
        let s_5099_0: u8 = fn_state.coproc;
        // D s_5099_1: cast zx s_5099_0 -> bv
        let s_5099_1: Bits = Bits::new(s_5099_0 as u128, 4u16);
        // C s_5099_2: const #14u : u8
        let s_5099_2: u8 = 14;
        // C s_5099_3: cast zx s_5099_2 -> bv
        let s_5099_3: Bits = Bits::new(s_5099_2 as u128, 4u16);
        // D s_5099_4: cmp-eq s_5099_1 s_5099_3
        let s_5099_4: bool = ((s_5099_1) == (s_5099_3));
        // D s_5099_5: write-var gs#118005 <= s_5099_4
        fn_state.gs_118005 = s_5099_4;
        // N s_5099_6: jump b1030
        return block_1030(state, tracer, fn_state);
    }
    fn block_5100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5100_0: read-var CRn:u8
        let s_5100_0: u8 = fn_state.CRn;
        // D s_5100_1: cast zx s_5100_0 -> bv
        let s_5100_1: Bits = Bits::new(s_5100_0 as u128, 4u16);
        // C s_5100_2: const #0u : u8
        let s_5100_2: u8 = 0;
        // C s_5100_3: cast zx s_5100_2 -> bv
        let s_5100_3: Bits = Bits::new(s_5100_2 as u128, 4u16);
        // D s_5100_4: cmp-eq s_5100_1 s_5100_3
        let s_5100_4: bool = ((s_5100_1) == (s_5100_3));
        // D s_5100_5: write-var gs#118004 <= s_5100_4
        fn_state.gs_118004 = s_5100_4;
        // N s_5100_6: jump b1028
        return block_1028(state, tracer, fn_state);
    }
    fn block_5101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5101_0: read-var el:u8
        let s_5101_0: u8 = fn_state.el;
        // D s_5101_1: read-var coproc:u8
        let s_5101_1: u8 = fn_state.coproc;
        // D s_5101_2: read-var opc1:u8
        let s_5101_2: u8 = fn_state.opc1;
        // D s_5101_3: read-var CRn:u8
        let s_5101_3: u8 = fn_state.CRn;
        // D s_5101_4: read-var opc2:u8
        let s_5101_4: u8 = fn_state.opc2;
        // D s_5101_5: read-var CRm:u8
        let s_5101_5: u8 = fn_state.CRm;
        // D s_5101_6: read-var t:i
        let s_5101_6: i128 = fn_state.t;
        // D s_5101_7: call DBGWCR_SysRegRead32_427272e014730b50(s_5101_0, s_5101_1, s_5101_2, s_5101_3, s_5101_4, s_5101_5, s_5101_6)
        let s_5101_7: () = DBGWCR_SysRegRead32_427272e014730b50(
            state,
            tracer,
            s_5101_0,
            s_5101_1,
            s_5101_2,
            s_5101_3,
            s_5101_4,
            s_5101_5,
            s_5101_6,
        );
        // N s_5101_8: return
        return;
    }
    fn block_5102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5102_0: read-var opc2:u8
        let s_5102_0: u8 = fn_state.opc2;
        // D s_5102_1: cast zx s_5102_0 -> bv
        let s_5102_1: Bits = Bits::new(s_5102_0 as u128, 3u16);
        // C s_5102_2: const #7u : u8
        let s_5102_2: u8 = 7;
        // C s_5102_3: cast zx s_5102_2 -> bv
        let s_5102_3: Bits = Bits::new(s_5102_2 as u128, 3u16);
        // D s_5102_4: cmp-eq s_5102_1 s_5102_3
        let s_5102_4: bool = ((s_5102_1) == (s_5102_3));
        // D s_5102_5: write-var gs#118003 <= s_5102_4
        fn_state.gs_118003 = s_5102_4;
        // N s_5102_6: jump b1025
        return block_1025(state, tracer, fn_state);
    }
    fn block_5103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5103_0: read-var opc1:u8
        let s_5103_0: u8 = fn_state.opc1;
        // D s_5103_1: cast zx s_5103_0 -> bv
        let s_5103_1: Bits = Bits::new(s_5103_0 as u128, 3u16);
        // C s_5103_2: const #0u : u8
        let s_5103_2: u8 = 0;
        // C s_5103_3: cast zx s_5103_2 -> bv
        let s_5103_3: Bits = Bits::new(s_5103_2 as u128, 3u16);
        // D s_5103_4: cmp-eq s_5103_1 s_5103_3
        let s_5103_4: bool = ((s_5103_1) == (s_5103_3));
        // D s_5103_5: write-var gs#118002 <= s_5103_4
        fn_state.gs_118002 = s_5103_4;
        // N s_5103_6: jump b1023
        return block_1023(state, tracer, fn_state);
    }
    fn block_5104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5104_0: read-var coproc:u8
        let s_5104_0: u8 = fn_state.coproc;
        // D s_5104_1: cast zx s_5104_0 -> bv
        let s_5104_1: Bits = Bits::new(s_5104_0 as u128, 4u16);
        // C s_5104_2: const #14u : u8
        let s_5104_2: u8 = 14;
        // C s_5104_3: cast zx s_5104_2 -> bv
        let s_5104_3: Bits = Bits::new(s_5104_2 as u128, 4u16);
        // D s_5104_4: cmp-eq s_5104_1 s_5104_3
        let s_5104_4: bool = ((s_5104_1) == (s_5104_3));
        // D s_5104_5: write-var gs#118001 <= s_5104_4
        fn_state.gs_118001 = s_5104_4;
        // N s_5104_6: jump b1021
        return block_1021(state, tracer, fn_state);
    }
    fn block_5105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5105_0: read-var CRn:u8
        let s_5105_0: u8 = fn_state.CRn;
        // D s_5105_1: cast zx s_5105_0 -> bv
        let s_5105_1: Bits = Bits::new(s_5105_0 as u128, 4u16);
        // C s_5105_2: const #0u : u8
        let s_5105_2: u8 = 0;
        // C s_5105_3: cast zx s_5105_2 -> bv
        let s_5105_3: Bits = Bits::new(s_5105_2 as u128, 4u16);
        // D s_5105_4: cmp-eq s_5105_1 s_5105_3
        let s_5105_4: bool = ((s_5105_1) == (s_5105_3));
        // D s_5105_5: write-var gs#118000 <= s_5105_4
        fn_state.gs_118000 = s_5105_4;
        // N s_5105_6: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_5106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5106_0: read-var el:u8
        let s_5106_0: u8 = fn_state.el;
        // D s_5106_1: read-var coproc:u8
        let s_5106_1: u8 = fn_state.coproc;
        // D s_5106_2: read-var opc1:u8
        let s_5106_2: u8 = fn_state.opc1;
        // D s_5106_3: read-var CRn:u8
        let s_5106_3: u8 = fn_state.CRn;
        // D s_5106_4: read-var opc2:u8
        let s_5106_4: u8 = fn_state.opc2;
        // D s_5106_5: read-var CRm:u8
        let s_5106_5: u8 = fn_state.CRm;
        // D s_5106_6: read-var t:i
        let s_5106_6: i128 = fn_state.t;
        // D s_5106_7: call DBGWCR_SysRegRead32_c49e6cc415f000b3(s_5106_0, s_5106_1, s_5106_2, s_5106_3, s_5106_4, s_5106_5, s_5106_6)
        let s_5106_7: () = DBGWCR_SysRegRead32_c49e6cc415f000b3(
            state,
            tracer,
            s_5106_0,
            s_5106_1,
            s_5106_2,
            s_5106_3,
            s_5106_4,
            s_5106_5,
            s_5106_6,
        );
        // N s_5106_8: return
        return;
    }
    fn block_5107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5107_0: read-var opc2:u8
        let s_5107_0: u8 = fn_state.opc2;
        // D s_5107_1: cast zx s_5107_0 -> bv
        let s_5107_1: Bits = Bits::new(s_5107_0 as u128, 3u16);
        // C s_5107_2: const #7u : u8
        let s_5107_2: u8 = 7;
        // C s_5107_3: cast zx s_5107_2 -> bv
        let s_5107_3: Bits = Bits::new(s_5107_2 as u128, 3u16);
        // D s_5107_4: cmp-eq s_5107_1 s_5107_3
        let s_5107_4: bool = ((s_5107_1) == (s_5107_3));
        // D s_5107_5: write-var gs#117999 <= s_5107_4
        fn_state.gs_117999 = s_5107_4;
        // N s_5107_6: jump b1016
        return block_1016(state, tracer, fn_state);
    }
    fn block_5108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5108_0: read-var opc1:u8
        let s_5108_0: u8 = fn_state.opc1;
        // D s_5108_1: cast zx s_5108_0 -> bv
        let s_5108_1: Bits = Bits::new(s_5108_0 as u128, 3u16);
        // C s_5108_2: const #0u : u8
        let s_5108_2: u8 = 0;
        // C s_5108_3: cast zx s_5108_2 -> bv
        let s_5108_3: Bits = Bits::new(s_5108_2 as u128, 3u16);
        // D s_5108_4: cmp-eq s_5108_1 s_5108_3
        let s_5108_4: bool = ((s_5108_1) == (s_5108_3));
        // D s_5108_5: write-var gs#117998 <= s_5108_4
        fn_state.gs_117998 = s_5108_4;
        // N s_5108_6: jump b1014
        return block_1014(state, tracer, fn_state);
    }
    fn block_5109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5109_0: read-var coproc:u8
        let s_5109_0: u8 = fn_state.coproc;
        // D s_5109_1: cast zx s_5109_0 -> bv
        let s_5109_1: Bits = Bits::new(s_5109_0 as u128, 4u16);
        // C s_5109_2: const #14u : u8
        let s_5109_2: u8 = 14;
        // C s_5109_3: cast zx s_5109_2 -> bv
        let s_5109_3: Bits = Bits::new(s_5109_2 as u128, 4u16);
        // D s_5109_4: cmp-eq s_5109_1 s_5109_3
        let s_5109_4: bool = ((s_5109_1) == (s_5109_3));
        // D s_5109_5: write-var gs#117997 <= s_5109_4
        fn_state.gs_117997 = s_5109_4;
        // N s_5109_6: jump b1012
        return block_1012(state, tracer, fn_state);
    }
    fn block_5110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5110_0: read-var CRn:u8
        let s_5110_0: u8 = fn_state.CRn;
        // D s_5110_1: cast zx s_5110_0 -> bv
        let s_5110_1: Bits = Bits::new(s_5110_0 as u128, 4u16);
        // C s_5110_2: const #0u : u8
        let s_5110_2: u8 = 0;
        // C s_5110_3: cast zx s_5110_2 -> bv
        let s_5110_3: Bits = Bits::new(s_5110_2 as u128, 4u16);
        // D s_5110_4: cmp-eq s_5110_1 s_5110_3
        let s_5110_4: bool = ((s_5110_1) == (s_5110_3));
        // D s_5110_5: write-var gs#117996 <= s_5110_4
        fn_state.gs_117996 = s_5110_4;
        // N s_5110_6: jump b1010
        return block_1010(state, tracer, fn_state);
    }
    fn block_5111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5111_0: read-var el:u8
        let s_5111_0: u8 = fn_state.el;
        // D s_5111_1: read-var coproc:u8
        let s_5111_1: u8 = fn_state.coproc;
        // D s_5111_2: read-var opc1:u8
        let s_5111_2: u8 = fn_state.opc1;
        // D s_5111_3: read-var CRn:u8
        let s_5111_3: u8 = fn_state.CRn;
        // D s_5111_4: read-var opc2:u8
        let s_5111_4: u8 = fn_state.opc2;
        // D s_5111_5: read-var CRm:u8
        let s_5111_5: u8 = fn_state.CRm;
        // D s_5111_6: read-var t:i
        let s_5111_6: i128 = fn_state.t;
        // D s_5111_7: call DBGWCR_SysRegRead32_f40826807efdc23f(s_5111_0, s_5111_1, s_5111_2, s_5111_3, s_5111_4, s_5111_5, s_5111_6)
        let s_5111_7: () = DBGWCR_SysRegRead32_f40826807efdc23f(
            state,
            tracer,
            s_5111_0,
            s_5111_1,
            s_5111_2,
            s_5111_3,
            s_5111_4,
            s_5111_5,
            s_5111_6,
        );
        // N s_5111_8: return
        return;
    }
    fn block_5112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5112_0: read-var opc2:u8
        let s_5112_0: u8 = fn_state.opc2;
        // D s_5112_1: cast zx s_5112_0 -> bv
        let s_5112_1: Bits = Bits::new(s_5112_0 as u128, 3u16);
        // C s_5112_2: const #7u : u8
        let s_5112_2: u8 = 7;
        // C s_5112_3: cast zx s_5112_2 -> bv
        let s_5112_3: Bits = Bits::new(s_5112_2 as u128, 3u16);
        // D s_5112_4: cmp-eq s_5112_1 s_5112_3
        let s_5112_4: bool = ((s_5112_1) == (s_5112_3));
        // D s_5112_5: write-var gs#117995 <= s_5112_4
        fn_state.gs_117995 = s_5112_4;
        // N s_5112_6: jump b1007
        return block_1007(state, tracer, fn_state);
    }
    fn block_5113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5113_0: read-var opc1:u8
        let s_5113_0: u8 = fn_state.opc1;
        // D s_5113_1: cast zx s_5113_0 -> bv
        let s_5113_1: Bits = Bits::new(s_5113_0 as u128, 3u16);
        // C s_5113_2: const #0u : u8
        let s_5113_2: u8 = 0;
        // C s_5113_3: cast zx s_5113_2 -> bv
        let s_5113_3: Bits = Bits::new(s_5113_2 as u128, 3u16);
        // D s_5113_4: cmp-eq s_5113_1 s_5113_3
        let s_5113_4: bool = ((s_5113_1) == (s_5113_3));
        // D s_5113_5: write-var gs#117994 <= s_5113_4
        fn_state.gs_117994 = s_5113_4;
        // N s_5113_6: jump b1005
        return block_1005(state, tracer, fn_state);
    }
    fn block_5114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5114_0: read-var coproc:u8
        let s_5114_0: u8 = fn_state.coproc;
        // D s_5114_1: cast zx s_5114_0 -> bv
        let s_5114_1: Bits = Bits::new(s_5114_0 as u128, 4u16);
        // C s_5114_2: const #14u : u8
        let s_5114_2: u8 = 14;
        // C s_5114_3: cast zx s_5114_2 -> bv
        let s_5114_3: Bits = Bits::new(s_5114_2 as u128, 4u16);
        // D s_5114_4: cmp-eq s_5114_1 s_5114_3
        let s_5114_4: bool = ((s_5114_1) == (s_5114_3));
        // D s_5114_5: write-var gs#117993 <= s_5114_4
        fn_state.gs_117993 = s_5114_4;
        // N s_5114_6: jump b1003
        return block_1003(state, tracer, fn_state);
    }
    fn block_5115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5115_0: read-var CRn:u8
        let s_5115_0: u8 = fn_state.CRn;
        // D s_5115_1: cast zx s_5115_0 -> bv
        let s_5115_1: Bits = Bits::new(s_5115_0 as u128, 4u16);
        // C s_5115_2: const #0u : u8
        let s_5115_2: u8 = 0;
        // C s_5115_3: cast zx s_5115_2 -> bv
        let s_5115_3: Bits = Bits::new(s_5115_2 as u128, 4u16);
        // D s_5115_4: cmp-eq s_5115_1 s_5115_3
        let s_5115_4: bool = ((s_5115_1) == (s_5115_3));
        // D s_5115_5: write-var gs#117992 <= s_5115_4
        fn_state.gs_117992 = s_5115_4;
        // N s_5115_6: jump b1001
        return block_1001(state, tracer, fn_state);
    }
    fn block_5116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5116_0: read-var el:u8
        let s_5116_0: u8 = fn_state.el;
        // D s_5116_1: read-var coproc:u8
        let s_5116_1: u8 = fn_state.coproc;
        // D s_5116_2: read-var opc1:u8
        let s_5116_2: u8 = fn_state.opc1;
        // D s_5116_3: read-var CRn:u8
        let s_5116_3: u8 = fn_state.CRn;
        // D s_5116_4: read-var opc2:u8
        let s_5116_4: u8 = fn_state.opc2;
        // D s_5116_5: read-var CRm:u8
        let s_5116_5: u8 = fn_state.CRm;
        // D s_5116_6: read-var t:i
        let s_5116_6: i128 = fn_state.t;
        // D s_5116_7: call DBGWCR_SysRegRead32_2c8e3f6807d0cbe3(s_5116_0, s_5116_1, s_5116_2, s_5116_3, s_5116_4, s_5116_5, s_5116_6)
        let s_5116_7: () = DBGWCR_SysRegRead32_2c8e3f6807d0cbe3(
            state,
            tracer,
            s_5116_0,
            s_5116_1,
            s_5116_2,
            s_5116_3,
            s_5116_4,
            s_5116_5,
            s_5116_6,
        );
        // N s_5116_8: return
        return;
    }
    fn block_5117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5117_0: read-var opc2:u8
        let s_5117_0: u8 = fn_state.opc2;
        // D s_5117_1: cast zx s_5117_0 -> bv
        let s_5117_1: Bits = Bits::new(s_5117_0 as u128, 3u16);
        // C s_5117_2: const #7u : u8
        let s_5117_2: u8 = 7;
        // C s_5117_3: cast zx s_5117_2 -> bv
        let s_5117_3: Bits = Bits::new(s_5117_2 as u128, 3u16);
        // D s_5117_4: cmp-eq s_5117_1 s_5117_3
        let s_5117_4: bool = ((s_5117_1) == (s_5117_3));
        // D s_5117_5: write-var gs#117991 <= s_5117_4
        fn_state.gs_117991 = s_5117_4;
        // N s_5117_6: jump b998
        return block_998(state, tracer, fn_state);
    }
    fn block_5118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5118_0: read-var opc1:u8
        let s_5118_0: u8 = fn_state.opc1;
        // D s_5118_1: cast zx s_5118_0 -> bv
        let s_5118_1: Bits = Bits::new(s_5118_0 as u128, 3u16);
        // C s_5118_2: const #0u : u8
        let s_5118_2: u8 = 0;
        // C s_5118_3: cast zx s_5118_2 -> bv
        let s_5118_3: Bits = Bits::new(s_5118_2 as u128, 3u16);
        // D s_5118_4: cmp-eq s_5118_1 s_5118_3
        let s_5118_4: bool = ((s_5118_1) == (s_5118_3));
        // D s_5118_5: write-var gs#117990 <= s_5118_4
        fn_state.gs_117990 = s_5118_4;
        // N s_5118_6: jump b996
        return block_996(state, tracer, fn_state);
    }
    fn block_5119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5119_0: read-var coproc:u8
        let s_5119_0: u8 = fn_state.coproc;
        // D s_5119_1: cast zx s_5119_0 -> bv
        let s_5119_1: Bits = Bits::new(s_5119_0 as u128, 4u16);
        // C s_5119_2: const #14u : u8
        let s_5119_2: u8 = 14;
        // C s_5119_3: cast zx s_5119_2 -> bv
        let s_5119_3: Bits = Bits::new(s_5119_2 as u128, 4u16);
        // D s_5119_4: cmp-eq s_5119_1 s_5119_3
        let s_5119_4: bool = ((s_5119_1) == (s_5119_3));
        // D s_5119_5: write-var gs#117989 <= s_5119_4
        fn_state.gs_117989 = s_5119_4;
        // N s_5119_6: jump b994
        return block_994(state, tracer, fn_state);
    }
    fn block_5120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5120_0: read-var CRn:u8
        let s_5120_0: u8 = fn_state.CRn;
        // D s_5120_1: cast zx s_5120_0 -> bv
        let s_5120_1: Bits = Bits::new(s_5120_0 as u128, 4u16);
        // C s_5120_2: const #0u : u8
        let s_5120_2: u8 = 0;
        // C s_5120_3: cast zx s_5120_2 -> bv
        let s_5120_3: Bits = Bits::new(s_5120_2 as u128, 4u16);
        // D s_5120_4: cmp-eq s_5120_1 s_5120_3
        let s_5120_4: bool = ((s_5120_1) == (s_5120_3));
        // D s_5120_5: write-var gs#117988 <= s_5120_4
        fn_state.gs_117988 = s_5120_4;
        // N s_5120_6: jump b992
        return block_992(state, tracer, fn_state);
    }
    fn block_5121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5121_0: read-var el:u8
        let s_5121_0: u8 = fn_state.el;
        // D s_5121_1: read-var coproc:u8
        let s_5121_1: u8 = fn_state.coproc;
        // D s_5121_2: read-var opc1:u8
        let s_5121_2: u8 = fn_state.opc1;
        // D s_5121_3: read-var CRn:u8
        let s_5121_3: u8 = fn_state.CRn;
        // D s_5121_4: read-var opc2:u8
        let s_5121_4: u8 = fn_state.opc2;
        // D s_5121_5: read-var CRm:u8
        let s_5121_5: u8 = fn_state.CRm;
        // D s_5121_6: read-var t:i
        let s_5121_6: i128 = fn_state.t;
        // D s_5121_7: call DBGWCR_SysRegRead32_c5e0186238203543(s_5121_0, s_5121_1, s_5121_2, s_5121_3, s_5121_4, s_5121_5, s_5121_6)
        let s_5121_7: () = DBGWCR_SysRegRead32_c5e0186238203543(
            state,
            tracer,
            s_5121_0,
            s_5121_1,
            s_5121_2,
            s_5121_3,
            s_5121_4,
            s_5121_5,
            s_5121_6,
        );
        // N s_5121_8: return
        return;
    }
    fn block_5122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5122_0: read-var opc2:u8
        let s_5122_0: u8 = fn_state.opc2;
        // D s_5122_1: cast zx s_5122_0 -> bv
        let s_5122_1: Bits = Bits::new(s_5122_0 as u128, 3u16);
        // C s_5122_2: const #7u : u8
        let s_5122_2: u8 = 7;
        // C s_5122_3: cast zx s_5122_2 -> bv
        let s_5122_3: Bits = Bits::new(s_5122_2 as u128, 3u16);
        // D s_5122_4: cmp-eq s_5122_1 s_5122_3
        let s_5122_4: bool = ((s_5122_1) == (s_5122_3));
        // D s_5122_5: write-var gs#117987 <= s_5122_4
        fn_state.gs_117987 = s_5122_4;
        // N s_5122_6: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_5123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5123_0: read-var opc1:u8
        let s_5123_0: u8 = fn_state.opc1;
        // D s_5123_1: cast zx s_5123_0 -> bv
        let s_5123_1: Bits = Bits::new(s_5123_0 as u128, 3u16);
        // C s_5123_2: const #0u : u8
        let s_5123_2: u8 = 0;
        // C s_5123_3: cast zx s_5123_2 -> bv
        let s_5123_3: Bits = Bits::new(s_5123_2 as u128, 3u16);
        // D s_5123_4: cmp-eq s_5123_1 s_5123_3
        let s_5123_4: bool = ((s_5123_1) == (s_5123_3));
        // D s_5123_5: write-var gs#117986 <= s_5123_4
        fn_state.gs_117986 = s_5123_4;
        // N s_5123_6: jump b987
        return block_987(state, tracer, fn_state);
    }
    fn block_5124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5124_0: read-var coproc:u8
        let s_5124_0: u8 = fn_state.coproc;
        // D s_5124_1: cast zx s_5124_0 -> bv
        let s_5124_1: Bits = Bits::new(s_5124_0 as u128, 4u16);
        // C s_5124_2: const #14u : u8
        let s_5124_2: u8 = 14;
        // C s_5124_3: cast zx s_5124_2 -> bv
        let s_5124_3: Bits = Bits::new(s_5124_2 as u128, 4u16);
        // D s_5124_4: cmp-eq s_5124_1 s_5124_3
        let s_5124_4: bool = ((s_5124_1) == (s_5124_3));
        // D s_5124_5: write-var gs#117985 <= s_5124_4
        fn_state.gs_117985 = s_5124_4;
        // N s_5124_6: jump b985
        return block_985(state, tracer, fn_state);
    }
    fn block_5125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5125_0: read-var CRn:u8
        let s_5125_0: u8 = fn_state.CRn;
        // D s_5125_1: cast zx s_5125_0 -> bv
        let s_5125_1: Bits = Bits::new(s_5125_0 as u128, 4u16);
        // C s_5125_2: const #0u : u8
        let s_5125_2: u8 = 0;
        // C s_5125_3: cast zx s_5125_2 -> bv
        let s_5125_3: Bits = Bits::new(s_5125_2 as u128, 4u16);
        // D s_5125_4: cmp-eq s_5125_1 s_5125_3
        let s_5125_4: bool = ((s_5125_1) == (s_5125_3));
        // D s_5125_5: write-var gs#117984 <= s_5125_4
        fn_state.gs_117984 = s_5125_4;
        // N s_5125_6: jump b983
        return block_983(state, tracer, fn_state);
    }
    fn block_5126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5126_0: read-var el:u8
        let s_5126_0: u8 = fn_state.el;
        // D s_5126_1: read-var coproc:u8
        let s_5126_1: u8 = fn_state.coproc;
        // D s_5126_2: read-var opc1:u8
        let s_5126_2: u8 = fn_state.opc1;
        // D s_5126_3: read-var CRn:u8
        let s_5126_3: u8 = fn_state.CRn;
        // D s_5126_4: read-var opc2:u8
        let s_5126_4: u8 = fn_state.opc2;
        // D s_5126_5: read-var CRm:u8
        let s_5126_5: u8 = fn_state.CRm;
        // D s_5126_6: read-var t:i
        let s_5126_6: i128 = fn_state.t;
        // D s_5126_7: call DBGWCR_SysRegRead32_34b30f3cf3218c16(s_5126_0, s_5126_1, s_5126_2, s_5126_3, s_5126_4, s_5126_5, s_5126_6)
        let s_5126_7: () = DBGWCR_SysRegRead32_34b30f3cf3218c16(
            state,
            tracer,
            s_5126_0,
            s_5126_1,
            s_5126_2,
            s_5126_3,
            s_5126_4,
            s_5126_5,
            s_5126_6,
        );
        // N s_5126_8: return
        return;
    }
    fn block_5127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5127_0: read-var opc2:u8
        let s_5127_0: u8 = fn_state.opc2;
        // D s_5127_1: cast zx s_5127_0 -> bv
        let s_5127_1: Bits = Bits::new(s_5127_0 as u128, 3u16);
        // C s_5127_2: const #7u : u8
        let s_5127_2: u8 = 7;
        // C s_5127_3: cast zx s_5127_2 -> bv
        let s_5127_3: Bits = Bits::new(s_5127_2 as u128, 3u16);
        // D s_5127_4: cmp-eq s_5127_1 s_5127_3
        let s_5127_4: bool = ((s_5127_1) == (s_5127_3));
        // D s_5127_5: write-var gs#117983 <= s_5127_4
        fn_state.gs_117983 = s_5127_4;
        // N s_5127_6: jump b980
        return block_980(state, tracer, fn_state);
    }
    fn block_5128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5128_0: read-var opc1:u8
        let s_5128_0: u8 = fn_state.opc1;
        // D s_5128_1: cast zx s_5128_0 -> bv
        let s_5128_1: Bits = Bits::new(s_5128_0 as u128, 3u16);
        // C s_5128_2: const #0u : u8
        let s_5128_2: u8 = 0;
        // C s_5128_3: cast zx s_5128_2 -> bv
        let s_5128_3: Bits = Bits::new(s_5128_2 as u128, 3u16);
        // D s_5128_4: cmp-eq s_5128_1 s_5128_3
        let s_5128_4: bool = ((s_5128_1) == (s_5128_3));
        // D s_5128_5: write-var gs#117982 <= s_5128_4
        fn_state.gs_117982 = s_5128_4;
        // N s_5128_6: jump b978
        return block_978(state, tracer, fn_state);
    }
    fn block_5129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5129_0: read-var coproc:u8
        let s_5129_0: u8 = fn_state.coproc;
        // D s_5129_1: cast zx s_5129_0 -> bv
        let s_5129_1: Bits = Bits::new(s_5129_0 as u128, 4u16);
        // C s_5129_2: const #14u : u8
        let s_5129_2: u8 = 14;
        // C s_5129_3: cast zx s_5129_2 -> bv
        let s_5129_3: Bits = Bits::new(s_5129_2 as u128, 4u16);
        // D s_5129_4: cmp-eq s_5129_1 s_5129_3
        let s_5129_4: bool = ((s_5129_1) == (s_5129_3));
        // D s_5129_5: write-var gs#117981 <= s_5129_4
        fn_state.gs_117981 = s_5129_4;
        // N s_5129_6: jump b976
        return block_976(state, tracer, fn_state);
    }
    fn block_5130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5130_0: read-var CRn:u8
        let s_5130_0: u8 = fn_state.CRn;
        // D s_5130_1: cast zx s_5130_0 -> bv
        let s_5130_1: Bits = Bits::new(s_5130_0 as u128, 4u16);
        // C s_5130_2: const #0u : u8
        let s_5130_2: u8 = 0;
        // C s_5130_3: cast zx s_5130_2 -> bv
        let s_5130_3: Bits = Bits::new(s_5130_2 as u128, 4u16);
        // D s_5130_4: cmp-eq s_5130_1 s_5130_3
        let s_5130_4: bool = ((s_5130_1) == (s_5130_3));
        // D s_5130_5: write-var gs#117980 <= s_5130_4
        fn_state.gs_117980 = s_5130_4;
        // N s_5130_6: jump b974
        return block_974(state, tracer, fn_state);
    }
    fn block_5131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5131_0: read-var el:u8
        let s_5131_0: u8 = fn_state.el;
        // D s_5131_1: read-var coproc:u8
        let s_5131_1: u8 = fn_state.coproc;
        // D s_5131_2: read-var opc1:u8
        let s_5131_2: u8 = fn_state.opc1;
        // D s_5131_3: read-var CRn:u8
        let s_5131_3: u8 = fn_state.CRn;
        // D s_5131_4: read-var opc2:u8
        let s_5131_4: u8 = fn_state.opc2;
        // D s_5131_5: read-var CRm:u8
        let s_5131_5: u8 = fn_state.CRm;
        // D s_5131_6: read-var t:i
        let s_5131_6: i128 = fn_state.t;
        // D s_5131_7: call DBGWCR_SysRegRead32_60f3efc31648e354(s_5131_0, s_5131_1, s_5131_2, s_5131_3, s_5131_4, s_5131_5, s_5131_6)
        let s_5131_7: () = DBGWCR_SysRegRead32_60f3efc31648e354(
            state,
            tracer,
            s_5131_0,
            s_5131_1,
            s_5131_2,
            s_5131_3,
            s_5131_4,
            s_5131_5,
            s_5131_6,
        );
        // N s_5131_8: return
        return;
    }
    fn block_5132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5132_0: read-var opc2:u8
        let s_5132_0: u8 = fn_state.opc2;
        // D s_5132_1: cast zx s_5132_0 -> bv
        let s_5132_1: Bits = Bits::new(s_5132_0 as u128, 3u16);
        // C s_5132_2: const #7u : u8
        let s_5132_2: u8 = 7;
        // C s_5132_3: cast zx s_5132_2 -> bv
        let s_5132_3: Bits = Bits::new(s_5132_2 as u128, 3u16);
        // D s_5132_4: cmp-eq s_5132_1 s_5132_3
        let s_5132_4: bool = ((s_5132_1) == (s_5132_3));
        // D s_5132_5: write-var gs#117979 <= s_5132_4
        fn_state.gs_117979 = s_5132_4;
        // N s_5132_6: jump b971
        return block_971(state, tracer, fn_state);
    }
    fn block_5133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5133_0: read-var opc1:u8
        let s_5133_0: u8 = fn_state.opc1;
        // D s_5133_1: cast zx s_5133_0 -> bv
        let s_5133_1: Bits = Bits::new(s_5133_0 as u128, 3u16);
        // C s_5133_2: const #0u : u8
        let s_5133_2: u8 = 0;
        // C s_5133_3: cast zx s_5133_2 -> bv
        let s_5133_3: Bits = Bits::new(s_5133_2 as u128, 3u16);
        // D s_5133_4: cmp-eq s_5133_1 s_5133_3
        let s_5133_4: bool = ((s_5133_1) == (s_5133_3));
        // D s_5133_5: write-var gs#117978 <= s_5133_4
        fn_state.gs_117978 = s_5133_4;
        // N s_5133_6: jump b969
        return block_969(state, tracer, fn_state);
    }
    fn block_5134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5134_0: read-var coproc:u8
        let s_5134_0: u8 = fn_state.coproc;
        // D s_5134_1: cast zx s_5134_0 -> bv
        let s_5134_1: Bits = Bits::new(s_5134_0 as u128, 4u16);
        // C s_5134_2: const #14u : u8
        let s_5134_2: u8 = 14;
        // C s_5134_3: cast zx s_5134_2 -> bv
        let s_5134_3: Bits = Bits::new(s_5134_2 as u128, 4u16);
        // D s_5134_4: cmp-eq s_5134_1 s_5134_3
        let s_5134_4: bool = ((s_5134_1) == (s_5134_3));
        // D s_5134_5: write-var gs#117977 <= s_5134_4
        fn_state.gs_117977 = s_5134_4;
        // N s_5134_6: jump b967
        return block_967(state, tracer, fn_state);
    }
    fn block_5135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5135_0: read-var CRn:u8
        let s_5135_0: u8 = fn_state.CRn;
        // D s_5135_1: cast zx s_5135_0 -> bv
        let s_5135_1: Bits = Bits::new(s_5135_0 as u128, 4u16);
        // C s_5135_2: const #0u : u8
        let s_5135_2: u8 = 0;
        // C s_5135_3: cast zx s_5135_2 -> bv
        let s_5135_3: Bits = Bits::new(s_5135_2 as u128, 4u16);
        // D s_5135_4: cmp-eq s_5135_1 s_5135_3
        let s_5135_4: bool = ((s_5135_1) == (s_5135_3));
        // D s_5135_5: write-var gs#117976 <= s_5135_4
        fn_state.gs_117976 = s_5135_4;
        // N s_5135_6: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_5136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5136_0: read-var el:u8
        let s_5136_0: u8 = fn_state.el;
        // D s_5136_1: read-var coproc:u8
        let s_5136_1: u8 = fn_state.coproc;
        // D s_5136_2: read-var opc1:u8
        let s_5136_2: u8 = fn_state.opc1;
        // D s_5136_3: read-var CRn:u8
        let s_5136_3: u8 = fn_state.CRn;
        // D s_5136_4: read-var opc2:u8
        let s_5136_4: u8 = fn_state.opc2;
        // D s_5136_5: read-var CRm:u8
        let s_5136_5: u8 = fn_state.CRm;
        // D s_5136_6: read-var t:i
        let s_5136_6: i128 = fn_state.t;
        // D s_5136_7: call DBGWCR_SysRegRead32_fba46a7399a2c310(s_5136_0, s_5136_1, s_5136_2, s_5136_3, s_5136_4, s_5136_5, s_5136_6)
        let s_5136_7: () = DBGWCR_SysRegRead32_fba46a7399a2c310(
            state,
            tracer,
            s_5136_0,
            s_5136_1,
            s_5136_2,
            s_5136_3,
            s_5136_4,
            s_5136_5,
            s_5136_6,
        );
        // N s_5136_8: return
        return;
    }
    fn block_5137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5137_0: read-var opc2:u8
        let s_5137_0: u8 = fn_state.opc2;
        // D s_5137_1: cast zx s_5137_0 -> bv
        let s_5137_1: Bits = Bits::new(s_5137_0 as u128, 3u16);
        // C s_5137_2: const #7u : u8
        let s_5137_2: u8 = 7;
        // C s_5137_3: cast zx s_5137_2 -> bv
        let s_5137_3: Bits = Bits::new(s_5137_2 as u128, 3u16);
        // D s_5137_4: cmp-eq s_5137_1 s_5137_3
        let s_5137_4: bool = ((s_5137_1) == (s_5137_3));
        // D s_5137_5: write-var gs#117975 <= s_5137_4
        fn_state.gs_117975 = s_5137_4;
        // N s_5137_6: jump b962
        return block_962(state, tracer, fn_state);
    }
    fn block_5138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5138_0: read-var opc1:u8
        let s_5138_0: u8 = fn_state.opc1;
        // D s_5138_1: cast zx s_5138_0 -> bv
        let s_5138_1: Bits = Bits::new(s_5138_0 as u128, 3u16);
        // C s_5138_2: const #0u : u8
        let s_5138_2: u8 = 0;
        // C s_5138_3: cast zx s_5138_2 -> bv
        let s_5138_3: Bits = Bits::new(s_5138_2 as u128, 3u16);
        // D s_5138_4: cmp-eq s_5138_1 s_5138_3
        let s_5138_4: bool = ((s_5138_1) == (s_5138_3));
        // D s_5138_5: write-var gs#117974 <= s_5138_4
        fn_state.gs_117974 = s_5138_4;
        // N s_5138_6: jump b960
        return block_960(state, tracer, fn_state);
    }
    fn block_5139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5139_0: read-var coproc:u8
        let s_5139_0: u8 = fn_state.coproc;
        // D s_5139_1: cast zx s_5139_0 -> bv
        let s_5139_1: Bits = Bits::new(s_5139_0 as u128, 4u16);
        // C s_5139_2: const #14u : u8
        let s_5139_2: u8 = 14;
        // C s_5139_3: cast zx s_5139_2 -> bv
        let s_5139_3: Bits = Bits::new(s_5139_2 as u128, 4u16);
        // D s_5139_4: cmp-eq s_5139_1 s_5139_3
        let s_5139_4: bool = ((s_5139_1) == (s_5139_3));
        // D s_5139_5: write-var gs#117973 <= s_5139_4
        fn_state.gs_117973 = s_5139_4;
        // N s_5139_6: jump b958
        return block_958(state, tracer, fn_state);
    }
    fn block_5140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5140_0: read-var CRn:u8
        let s_5140_0: u8 = fn_state.CRn;
        // D s_5140_1: cast zx s_5140_0 -> bv
        let s_5140_1: Bits = Bits::new(s_5140_0 as u128, 4u16);
        // C s_5140_2: const #0u : u8
        let s_5140_2: u8 = 0;
        // C s_5140_3: cast zx s_5140_2 -> bv
        let s_5140_3: Bits = Bits::new(s_5140_2 as u128, 4u16);
        // D s_5140_4: cmp-eq s_5140_1 s_5140_3
        let s_5140_4: bool = ((s_5140_1) == (s_5140_3));
        // D s_5140_5: write-var gs#117972 <= s_5140_4
        fn_state.gs_117972 = s_5140_4;
        // N s_5140_6: jump b956
        return block_956(state, tracer, fn_state);
    }
    fn block_5141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5141_0: read-var el:u8
        let s_5141_0: u8 = fn_state.el;
        // D s_5141_1: read-var coproc:u8
        let s_5141_1: u8 = fn_state.coproc;
        // D s_5141_2: read-var opc1:u8
        let s_5141_2: u8 = fn_state.opc1;
        // D s_5141_3: read-var CRn:u8
        let s_5141_3: u8 = fn_state.CRn;
        // D s_5141_4: read-var opc2:u8
        let s_5141_4: u8 = fn_state.opc2;
        // D s_5141_5: read-var CRm:u8
        let s_5141_5: u8 = fn_state.CRm;
        // D s_5141_6: read-var t:i
        let s_5141_6: i128 = fn_state.t;
        // D s_5141_7: call DBGWCR_SysRegRead32_3b1b0be7aff03388(s_5141_0, s_5141_1, s_5141_2, s_5141_3, s_5141_4, s_5141_5, s_5141_6)
        let s_5141_7: () = DBGWCR_SysRegRead32_3b1b0be7aff03388(
            state,
            tracer,
            s_5141_0,
            s_5141_1,
            s_5141_2,
            s_5141_3,
            s_5141_4,
            s_5141_5,
            s_5141_6,
        );
        // N s_5141_8: return
        return;
    }
    fn block_5142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5142_0: read-var opc2:u8
        let s_5142_0: u8 = fn_state.opc2;
        // D s_5142_1: cast zx s_5142_0 -> bv
        let s_5142_1: Bits = Bits::new(s_5142_0 as u128, 3u16);
        // C s_5142_2: const #7u : u8
        let s_5142_2: u8 = 7;
        // C s_5142_3: cast zx s_5142_2 -> bv
        let s_5142_3: Bits = Bits::new(s_5142_2 as u128, 3u16);
        // D s_5142_4: cmp-eq s_5142_1 s_5142_3
        let s_5142_4: bool = ((s_5142_1) == (s_5142_3));
        // D s_5142_5: write-var gs#117971 <= s_5142_4
        fn_state.gs_117971 = s_5142_4;
        // N s_5142_6: jump b953
        return block_953(state, tracer, fn_state);
    }
    fn block_5143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5143_0: read-var opc1:u8
        let s_5143_0: u8 = fn_state.opc1;
        // D s_5143_1: cast zx s_5143_0 -> bv
        let s_5143_1: Bits = Bits::new(s_5143_0 as u128, 3u16);
        // C s_5143_2: const #0u : u8
        let s_5143_2: u8 = 0;
        // C s_5143_3: cast zx s_5143_2 -> bv
        let s_5143_3: Bits = Bits::new(s_5143_2 as u128, 3u16);
        // D s_5143_4: cmp-eq s_5143_1 s_5143_3
        let s_5143_4: bool = ((s_5143_1) == (s_5143_3));
        // D s_5143_5: write-var gs#117970 <= s_5143_4
        fn_state.gs_117970 = s_5143_4;
        // N s_5143_6: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_5144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5144_0: read-var coproc:u8
        let s_5144_0: u8 = fn_state.coproc;
        // D s_5144_1: cast zx s_5144_0 -> bv
        let s_5144_1: Bits = Bits::new(s_5144_0 as u128, 4u16);
        // C s_5144_2: const #14u : u8
        let s_5144_2: u8 = 14;
        // C s_5144_3: cast zx s_5144_2 -> bv
        let s_5144_3: Bits = Bits::new(s_5144_2 as u128, 4u16);
        // D s_5144_4: cmp-eq s_5144_1 s_5144_3
        let s_5144_4: bool = ((s_5144_1) == (s_5144_3));
        // D s_5144_5: write-var gs#117969 <= s_5144_4
        fn_state.gs_117969 = s_5144_4;
        // N s_5144_6: jump b949
        return block_949(state, tracer, fn_state);
    }
    fn block_5145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5145_0: read-var CRn:u8
        let s_5145_0: u8 = fn_state.CRn;
        // D s_5145_1: cast zx s_5145_0 -> bv
        let s_5145_1: Bits = Bits::new(s_5145_0 as u128, 4u16);
        // C s_5145_2: const #0u : u8
        let s_5145_2: u8 = 0;
        // C s_5145_3: cast zx s_5145_2 -> bv
        let s_5145_3: Bits = Bits::new(s_5145_2 as u128, 4u16);
        // D s_5145_4: cmp-eq s_5145_1 s_5145_3
        let s_5145_4: bool = ((s_5145_1) == (s_5145_3));
        // D s_5145_5: write-var gs#117968 <= s_5145_4
        fn_state.gs_117968 = s_5145_4;
        // N s_5145_6: jump b947
        return block_947(state, tracer, fn_state);
    }
    fn block_5146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5146_0: read-var el:u8
        let s_5146_0: u8 = fn_state.el;
        // D s_5146_1: read-var coproc:u8
        let s_5146_1: u8 = fn_state.coproc;
        // D s_5146_2: read-var opc1:u8
        let s_5146_2: u8 = fn_state.opc1;
        // D s_5146_3: read-var CRn:u8
        let s_5146_3: u8 = fn_state.CRn;
        // D s_5146_4: read-var opc2:u8
        let s_5146_4: u8 = fn_state.opc2;
        // D s_5146_5: read-var CRm:u8
        let s_5146_5: u8 = fn_state.CRm;
        // D s_5146_6: read-var t:i
        let s_5146_6: i128 = fn_state.t;
        // D s_5146_7: call DBGWCR_SysRegRead32_fa67eb6a8f2349c1(s_5146_0, s_5146_1, s_5146_2, s_5146_3, s_5146_4, s_5146_5, s_5146_6)
        let s_5146_7: () = DBGWCR_SysRegRead32_fa67eb6a8f2349c1(
            state,
            tracer,
            s_5146_0,
            s_5146_1,
            s_5146_2,
            s_5146_3,
            s_5146_4,
            s_5146_5,
            s_5146_6,
        );
        // N s_5146_8: return
        return;
    }
    fn block_5147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5147_0: read-var opc2:u8
        let s_5147_0: u8 = fn_state.opc2;
        // D s_5147_1: cast zx s_5147_0 -> bv
        let s_5147_1: Bits = Bits::new(s_5147_0 as u128, 3u16);
        // C s_5147_2: const #7u : u8
        let s_5147_2: u8 = 7;
        // C s_5147_3: cast zx s_5147_2 -> bv
        let s_5147_3: Bits = Bits::new(s_5147_2 as u128, 3u16);
        // D s_5147_4: cmp-eq s_5147_1 s_5147_3
        let s_5147_4: bool = ((s_5147_1) == (s_5147_3));
        // D s_5147_5: write-var gs#117967 <= s_5147_4
        fn_state.gs_117967 = s_5147_4;
        // N s_5147_6: jump b944
        return block_944(state, tracer, fn_state);
    }
    fn block_5148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5148_0: read-var opc1:u8
        let s_5148_0: u8 = fn_state.opc1;
        // D s_5148_1: cast zx s_5148_0 -> bv
        let s_5148_1: Bits = Bits::new(s_5148_0 as u128, 3u16);
        // C s_5148_2: const #0u : u8
        let s_5148_2: u8 = 0;
        // C s_5148_3: cast zx s_5148_2 -> bv
        let s_5148_3: Bits = Bits::new(s_5148_2 as u128, 3u16);
        // D s_5148_4: cmp-eq s_5148_1 s_5148_3
        let s_5148_4: bool = ((s_5148_1) == (s_5148_3));
        // D s_5148_5: write-var gs#117966 <= s_5148_4
        fn_state.gs_117966 = s_5148_4;
        // N s_5148_6: jump b942
        return block_942(state, tracer, fn_state);
    }
    fn block_5149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5149_0: read-var coproc:u8
        let s_5149_0: u8 = fn_state.coproc;
        // D s_5149_1: cast zx s_5149_0 -> bv
        let s_5149_1: Bits = Bits::new(s_5149_0 as u128, 4u16);
        // C s_5149_2: const #14u : u8
        let s_5149_2: u8 = 14;
        // C s_5149_3: cast zx s_5149_2 -> bv
        let s_5149_3: Bits = Bits::new(s_5149_2 as u128, 4u16);
        // D s_5149_4: cmp-eq s_5149_1 s_5149_3
        let s_5149_4: bool = ((s_5149_1) == (s_5149_3));
        // D s_5149_5: write-var gs#117965 <= s_5149_4
        fn_state.gs_117965 = s_5149_4;
        // N s_5149_6: jump b940
        return block_940(state, tracer, fn_state);
    }
    fn block_5150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5150_0: read-var CRn:u8
        let s_5150_0: u8 = fn_state.CRn;
        // D s_5150_1: cast zx s_5150_0 -> bv
        let s_5150_1: Bits = Bits::new(s_5150_0 as u128, 4u16);
        // C s_5150_2: const #0u : u8
        let s_5150_2: u8 = 0;
        // C s_5150_3: cast zx s_5150_2 -> bv
        let s_5150_3: Bits = Bits::new(s_5150_2 as u128, 4u16);
        // D s_5150_4: cmp-eq s_5150_1 s_5150_3
        let s_5150_4: bool = ((s_5150_1) == (s_5150_3));
        // D s_5150_5: write-var gs#117964 <= s_5150_4
        fn_state.gs_117964 = s_5150_4;
        // N s_5150_6: jump b938
        return block_938(state, tracer, fn_state);
    }
    fn block_5151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5151_0: read-var el:u8
        let s_5151_0: u8 = fn_state.el;
        // D s_5151_1: read-var coproc:u8
        let s_5151_1: u8 = fn_state.coproc;
        // D s_5151_2: read-var opc1:u8
        let s_5151_2: u8 = fn_state.opc1;
        // D s_5151_3: read-var CRn:u8
        let s_5151_3: u8 = fn_state.CRn;
        // D s_5151_4: read-var opc2:u8
        let s_5151_4: u8 = fn_state.opc2;
        // D s_5151_5: read-var CRm:u8
        let s_5151_5: u8 = fn_state.CRm;
        // D s_5151_6: read-var t:i
        let s_5151_6: i128 = fn_state.t;
        // D s_5151_7: call PMCR_SysRegRead32_fb694f2a3eabe8b5(s_5151_0, s_5151_1, s_5151_2, s_5151_3, s_5151_4, s_5151_5, s_5151_6)
        let s_5151_7: () = PMCR_SysRegRead32_fb694f2a3eabe8b5(
            state,
            tracer,
            s_5151_0,
            s_5151_1,
            s_5151_2,
            s_5151_3,
            s_5151_4,
            s_5151_5,
            s_5151_6,
        );
        // N s_5151_8: return
        return;
    }
    fn block_5152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5152_0: read-var opc2:u8
        let s_5152_0: u8 = fn_state.opc2;
        // D s_5152_1: cast zx s_5152_0 -> bv
        let s_5152_1: Bits = Bits::new(s_5152_0 as u128, 3u16);
        // C s_5152_2: const #0u : u8
        let s_5152_2: u8 = 0;
        // C s_5152_3: cast zx s_5152_2 -> bv
        let s_5152_3: Bits = Bits::new(s_5152_2 as u128, 3u16);
        // D s_5152_4: cmp-eq s_5152_1 s_5152_3
        let s_5152_4: bool = ((s_5152_1) == (s_5152_3));
        // D s_5152_5: write-var gs#117963 <= s_5152_4
        fn_state.gs_117963 = s_5152_4;
        // N s_5152_6: jump b935
        return block_935(state, tracer, fn_state);
    }
    fn block_5153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5153_0: read-var opc1:u8
        let s_5153_0: u8 = fn_state.opc1;
        // D s_5153_1: cast zx s_5153_0 -> bv
        let s_5153_1: Bits = Bits::new(s_5153_0 as u128, 3u16);
        // C s_5153_2: const #0u : u8
        let s_5153_2: u8 = 0;
        // C s_5153_3: cast zx s_5153_2 -> bv
        let s_5153_3: Bits = Bits::new(s_5153_2 as u128, 3u16);
        // D s_5153_4: cmp-eq s_5153_1 s_5153_3
        let s_5153_4: bool = ((s_5153_1) == (s_5153_3));
        // D s_5153_5: write-var gs#117962 <= s_5153_4
        fn_state.gs_117962 = s_5153_4;
        // N s_5153_6: jump b933
        return block_933(state, tracer, fn_state);
    }
    fn block_5154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5154_0: read-var coproc:u8
        let s_5154_0: u8 = fn_state.coproc;
        // D s_5154_1: cast zx s_5154_0 -> bv
        let s_5154_1: Bits = Bits::new(s_5154_0 as u128, 4u16);
        // C s_5154_2: const #15u : u8
        let s_5154_2: u8 = 15;
        // C s_5154_3: cast zx s_5154_2 -> bv
        let s_5154_3: Bits = Bits::new(s_5154_2 as u128, 4u16);
        // D s_5154_4: cmp-eq s_5154_1 s_5154_3
        let s_5154_4: bool = ((s_5154_1) == (s_5154_3));
        // D s_5154_5: write-var gs#117961 <= s_5154_4
        fn_state.gs_117961 = s_5154_4;
        // N s_5154_6: jump b931
        return block_931(state, tracer, fn_state);
    }
    fn block_5155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5155_0: read-var CRn:u8
        let s_5155_0: u8 = fn_state.CRn;
        // D s_5155_1: cast zx s_5155_0 -> bv
        let s_5155_1: Bits = Bits::new(s_5155_0 as u128, 4u16);
        // C s_5155_2: const #9u : u8
        let s_5155_2: u8 = 9;
        // C s_5155_3: cast zx s_5155_2 -> bv
        let s_5155_3: Bits = Bits::new(s_5155_2 as u128, 4u16);
        // D s_5155_4: cmp-eq s_5155_1 s_5155_3
        let s_5155_4: bool = ((s_5155_1) == (s_5155_3));
        // D s_5155_5: write-var gs#117960 <= s_5155_4
        fn_state.gs_117960 = s_5155_4;
        // N s_5155_6: jump b929
        return block_929(state, tracer, fn_state);
    }
    fn block_5156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5156_0: read-var el:u8
        let s_5156_0: u8 = fn_state.el;
        // D s_5156_1: read-var coproc:u8
        let s_5156_1: u8 = fn_state.coproc;
        // D s_5156_2: read-var opc1:u8
        let s_5156_2: u8 = fn_state.opc1;
        // D s_5156_3: read-var CRn:u8
        let s_5156_3: u8 = fn_state.CRn;
        // D s_5156_4: read-var opc2:u8
        let s_5156_4: u8 = fn_state.opc2;
        // D s_5156_5: read-var CRm:u8
        let s_5156_5: u8 = fn_state.CRm;
        // D s_5156_6: read-var t:i
        let s_5156_6: i128 = fn_state.t;
        // D s_5156_7: call JIDR_SysRegRead32_f362dc25ffe4f377(s_5156_0, s_5156_1, s_5156_2, s_5156_3, s_5156_4, s_5156_5, s_5156_6)
        let s_5156_7: () = JIDR_SysRegRead32_f362dc25ffe4f377(
            state,
            tracer,
            s_5156_0,
            s_5156_1,
            s_5156_2,
            s_5156_3,
            s_5156_4,
            s_5156_5,
            s_5156_6,
        );
        // N s_5156_8: return
        return;
    }
    fn block_5157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5157_0: read-var opc2:u8
        let s_5157_0: u8 = fn_state.opc2;
        // D s_5157_1: cast zx s_5157_0 -> bv
        let s_5157_1: Bits = Bits::new(s_5157_0 as u128, 3u16);
        // C s_5157_2: const #0u : u8
        let s_5157_2: u8 = 0;
        // C s_5157_3: cast zx s_5157_2 -> bv
        let s_5157_3: Bits = Bits::new(s_5157_2 as u128, 3u16);
        // D s_5157_4: cmp-eq s_5157_1 s_5157_3
        let s_5157_4: bool = ((s_5157_1) == (s_5157_3));
        // D s_5157_5: write-var gs#117959 <= s_5157_4
        fn_state.gs_117959 = s_5157_4;
        // N s_5157_6: jump b926
        return block_926(state, tracer, fn_state);
    }
    fn block_5158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5158_0: read-var opc1:u8
        let s_5158_0: u8 = fn_state.opc1;
        // D s_5158_1: cast zx s_5158_0 -> bv
        let s_5158_1: Bits = Bits::new(s_5158_0 as u128, 3u16);
        // C s_5158_2: const #7u : u8
        let s_5158_2: u8 = 7;
        // C s_5158_3: cast zx s_5158_2 -> bv
        let s_5158_3: Bits = Bits::new(s_5158_2 as u128, 3u16);
        // D s_5158_4: cmp-eq s_5158_1 s_5158_3
        let s_5158_4: bool = ((s_5158_1) == (s_5158_3));
        // D s_5158_5: write-var gs#117958 <= s_5158_4
        fn_state.gs_117958 = s_5158_4;
        // N s_5158_6: jump b924
        return block_924(state, tracer, fn_state);
    }
    fn block_5159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5159_0: read-var coproc:u8
        let s_5159_0: u8 = fn_state.coproc;
        // D s_5159_1: cast zx s_5159_0 -> bv
        let s_5159_1: Bits = Bits::new(s_5159_0 as u128, 4u16);
        // C s_5159_2: const #14u : u8
        let s_5159_2: u8 = 14;
        // C s_5159_3: cast zx s_5159_2 -> bv
        let s_5159_3: Bits = Bits::new(s_5159_2 as u128, 4u16);
        // D s_5159_4: cmp-eq s_5159_1 s_5159_3
        let s_5159_4: bool = ((s_5159_1) == (s_5159_3));
        // D s_5159_5: write-var gs#117957 <= s_5159_4
        fn_state.gs_117957 = s_5159_4;
        // N s_5159_6: jump b922
        return block_922(state, tracer, fn_state);
    }
    fn block_5160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5160_0: read-var CRn:u8
        let s_5160_0: u8 = fn_state.CRn;
        // D s_5160_1: cast zx s_5160_0 -> bv
        let s_5160_1: Bits = Bits::new(s_5160_0 as u128, 4u16);
        // C s_5160_2: const #0u : u8
        let s_5160_2: u8 = 0;
        // C s_5160_3: cast zx s_5160_2 -> bv
        let s_5160_3: Bits = Bits::new(s_5160_2 as u128, 4u16);
        // D s_5160_4: cmp-eq s_5160_1 s_5160_3
        let s_5160_4: bool = ((s_5160_1) == (s_5160_3));
        // D s_5160_5: write-var gs#117956 <= s_5160_4
        fn_state.gs_117956 = s_5160_4;
        // N s_5160_6: jump b920
        return block_920(state, tracer, fn_state);
    }
    fn block_5161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5161_0: read-var el:u8
        let s_5161_0: u8 = fn_state.el;
        // D s_5161_1: read-var coproc:u8
        let s_5161_1: u8 = fn_state.coproc;
        // D s_5161_2: read-var opc1:u8
        let s_5161_2: u8 = fn_state.opc1;
        // D s_5161_3: read-var CRn:u8
        let s_5161_3: u8 = fn_state.CRn;
        // D s_5161_4: read-var opc2:u8
        let s_5161_4: u8 = fn_state.opc2;
        // D s_5161_5: read-var CRm:u8
        let s_5161_5: u8 = fn_state.CRm;
        // D s_5161_6: read-var t:i
        let s_5161_6: i128 = fn_state.t;
        // D s_5161_7: call CSSELR_SysRegRead32_b9908a214e4391b4(s_5161_0, s_5161_1, s_5161_2, s_5161_3, s_5161_4, s_5161_5, s_5161_6)
        let s_5161_7: () = CSSELR_SysRegRead32_b9908a214e4391b4(
            state,
            tracer,
            s_5161_0,
            s_5161_1,
            s_5161_2,
            s_5161_3,
            s_5161_4,
            s_5161_5,
            s_5161_6,
        );
        // N s_5161_8: return
        return;
    }
    fn block_5162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5162_0: read-var opc2:u8
        let s_5162_0: u8 = fn_state.opc2;
        // D s_5162_1: cast zx s_5162_0 -> bv
        let s_5162_1: Bits = Bits::new(s_5162_0 as u128, 3u16);
        // C s_5162_2: const #0u : u8
        let s_5162_2: u8 = 0;
        // C s_5162_3: cast zx s_5162_2 -> bv
        let s_5162_3: Bits = Bits::new(s_5162_2 as u128, 3u16);
        // D s_5162_4: cmp-eq s_5162_1 s_5162_3
        let s_5162_4: bool = ((s_5162_1) == (s_5162_3));
        // D s_5162_5: write-var gs#117955 <= s_5162_4
        fn_state.gs_117955 = s_5162_4;
        // N s_5162_6: jump b917
        return block_917(state, tracer, fn_state);
    }
    fn block_5163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5163_0: read-var opc1:u8
        let s_5163_0: u8 = fn_state.opc1;
        // D s_5163_1: cast zx s_5163_0 -> bv
        let s_5163_1: Bits = Bits::new(s_5163_0 as u128, 3u16);
        // C s_5163_2: const #2u : u8
        let s_5163_2: u8 = 2;
        // C s_5163_3: cast zx s_5163_2 -> bv
        let s_5163_3: Bits = Bits::new(s_5163_2 as u128, 3u16);
        // D s_5163_4: cmp-eq s_5163_1 s_5163_3
        let s_5163_4: bool = ((s_5163_1) == (s_5163_3));
        // D s_5163_5: write-var gs#117954 <= s_5163_4
        fn_state.gs_117954 = s_5163_4;
        // N s_5163_6: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_5164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5164_0: read-var coproc:u8
        let s_5164_0: u8 = fn_state.coproc;
        // D s_5164_1: cast zx s_5164_0 -> bv
        let s_5164_1: Bits = Bits::new(s_5164_0 as u128, 4u16);
        // C s_5164_2: const #15u : u8
        let s_5164_2: u8 = 15;
        // C s_5164_3: cast zx s_5164_2 -> bv
        let s_5164_3: Bits = Bits::new(s_5164_2 as u128, 4u16);
        // D s_5164_4: cmp-eq s_5164_1 s_5164_3
        let s_5164_4: bool = ((s_5164_1) == (s_5164_3));
        // D s_5164_5: write-var gs#117953 <= s_5164_4
        fn_state.gs_117953 = s_5164_4;
        // N s_5164_6: jump b913
        return block_913(state, tracer, fn_state);
    }
    fn block_5165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5165_0: read-var CRn:u8
        let s_5165_0: u8 = fn_state.CRn;
        // D s_5165_1: cast zx s_5165_0 -> bv
        let s_5165_1: Bits = Bits::new(s_5165_0 as u128, 4u16);
        // C s_5165_2: const #0u : u8
        let s_5165_2: u8 = 0;
        // C s_5165_3: cast zx s_5165_2 -> bv
        let s_5165_3: Bits = Bits::new(s_5165_2 as u128, 4u16);
        // D s_5165_4: cmp-eq s_5165_1 s_5165_3
        let s_5165_4: bool = ((s_5165_1) == (s_5165_3));
        // D s_5165_5: write-var gs#117952 <= s_5165_4
        fn_state.gs_117952 = s_5165_4;
        // N s_5165_6: jump b911
        return block_911(state, tracer, fn_state);
    }
    fn block_5166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5166_0: read-var el:u8
        let s_5166_0: u8 = fn_state.el;
        // D s_5166_1: read-var coproc:u8
        let s_5166_1: u8 = fn_state.coproc;
        // D s_5166_2: read-var opc1:u8
        let s_5166_2: u8 = fn_state.opc1;
        // D s_5166_3: read-var CRn:u8
        let s_5166_3: u8 = fn_state.CRn;
        // D s_5166_4: read-var opc2:u8
        let s_5166_4: u8 = fn_state.opc2;
        // D s_5166_5: read-var CRm:u8
        let s_5166_5: u8 = fn_state.CRm;
        // D s_5166_6: read-var t:i
        let s_5166_6: i128 = fn_state.t;
        // D s_5166_7: call ICH_VTR_SysRegRead32_1187208e70ad69e9(s_5166_0, s_5166_1, s_5166_2, s_5166_3, s_5166_4, s_5166_5, s_5166_6)
        let s_5166_7: () = ICH_VTR_SysRegRead32_1187208e70ad69e9(
            state,
            tracer,
            s_5166_0,
            s_5166_1,
            s_5166_2,
            s_5166_3,
            s_5166_4,
            s_5166_5,
            s_5166_6,
        );
        // N s_5166_8: return
        return;
    }
    fn block_5167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5167_0: read-var opc2:u8
        let s_5167_0: u8 = fn_state.opc2;
        // D s_5167_1: cast zx s_5167_0 -> bv
        let s_5167_1: Bits = Bits::new(s_5167_0 as u128, 3u16);
        // C s_5167_2: const #1u : u8
        let s_5167_2: u8 = 1;
        // C s_5167_3: cast zx s_5167_2 -> bv
        let s_5167_3: Bits = Bits::new(s_5167_2 as u128, 3u16);
        // D s_5167_4: cmp-eq s_5167_1 s_5167_3
        let s_5167_4: bool = ((s_5167_1) == (s_5167_3));
        // D s_5167_5: write-var gs#117951 <= s_5167_4
        fn_state.gs_117951 = s_5167_4;
        // N s_5167_6: jump b908
        return block_908(state, tracer, fn_state);
    }
    fn block_5168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5168_0: read-var opc1:u8
        let s_5168_0: u8 = fn_state.opc1;
        // D s_5168_1: cast zx s_5168_0 -> bv
        let s_5168_1: Bits = Bits::new(s_5168_0 as u128, 3u16);
        // C s_5168_2: const #4u : u8
        let s_5168_2: u8 = 4;
        // C s_5168_3: cast zx s_5168_2 -> bv
        let s_5168_3: Bits = Bits::new(s_5168_2 as u128, 3u16);
        // D s_5168_4: cmp-eq s_5168_1 s_5168_3
        let s_5168_4: bool = ((s_5168_1) == (s_5168_3));
        // D s_5168_5: write-var gs#117950 <= s_5168_4
        fn_state.gs_117950 = s_5168_4;
        // N s_5168_6: jump b906
        return block_906(state, tracer, fn_state);
    }
    fn block_5169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5169_0: read-var coproc:u8
        let s_5169_0: u8 = fn_state.coproc;
        // D s_5169_1: cast zx s_5169_0 -> bv
        let s_5169_1: Bits = Bits::new(s_5169_0 as u128, 4u16);
        // C s_5169_2: const #15u : u8
        let s_5169_2: u8 = 15;
        // C s_5169_3: cast zx s_5169_2 -> bv
        let s_5169_3: Bits = Bits::new(s_5169_2 as u128, 4u16);
        // D s_5169_4: cmp-eq s_5169_1 s_5169_3
        let s_5169_4: bool = ((s_5169_1) == (s_5169_3));
        // D s_5169_5: write-var gs#117949 <= s_5169_4
        fn_state.gs_117949 = s_5169_4;
        // N s_5169_6: jump b904
        return block_904(state, tracer, fn_state);
    }
    fn block_5170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5170_0: read-var CRn:u8
        let s_5170_0: u8 = fn_state.CRn;
        // D s_5170_1: cast zx s_5170_0 -> bv
        let s_5170_1: Bits = Bits::new(s_5170_0 as u128, 4u16);
        // C s_5170_2: const #12u : u8
        let s_5170_2: u8 = 12;
        // C s_5170_3: cast zx s_5170_2 -> bv
        let s_5170_3: Bits = Bits::new(s_5170_2 as u128, 4u16);
        // D s_5170_4: cmp-eq s_5170_1 s_5170_3
        let s_5170_4: bool = ((s_5170_1) == (s_5170_3));
        // D s_5170_5: write-var gs#117948 <= s_5170_4
        fn_state.gs_117948 = s_5170_4;
        // N s_5170_6: jump b902
        return block_902(state, tracer, fn_state);
    }
    fn block_5171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5171_0: read-var el:u8
        let s_5171_0: u8 = fn_state.el;
        // D s_5171_1: read-var coproc:u8
        let s_5171_1: u8 = fn_state.coproc;
        // D s_5171_2: read-var opc1:u8
        let s_5171_2: u8 = fn_state.opc1;
        // D s_5171_3: read-var CRn:u8
        let s_5171_3: u8 = fn_state.CRn;
        // D s_5171_4: read-var opc2:u8
        let s_5171_4: u8 = fn_state.opc2;
        // D s_5171_5: read-var CRm:u8
        let s_5171_5: u8 = fn_state.CRm;
        // D s_5171_6: read-var t:i
        let s_5171_6: i128 = fn_state.t;
        // D s_5171_7: call DACR_SysRegRead32_a5e223b70013760e(s_5171_0, s_5171_1, s_5171_2, s_5171_3, s_5171_4, s_5171_5, s_5171_6)
        let s_5171_7: () = DACR_SysRegRead32_a5e223b70013760e(
            state,
            tracer,
            s_5171_0,
            s_5171_1,
            s_5171_2,
            s_5171_3,
            s_5171_4,
            s_5171_5,
            s_5171_6,
        );
        // N s_5171_8: return
        return;
    }
    fn block_5172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5172_0: read-var opc2:u8
        let s_5172_0: u8 = fn_state.opc2;
        // D s_5172_1: cast zx s_5172_0 -> bv
        let s_5172_1: Bits = Bits::new(s_5172_0 as u128, 3u16);
        // C s_5172_2: const #0u : u8
        let s_5172_2: u8 = 0;
        // C s_5172_3: cast zx s_5172_2 -> bv
        let s_5172_3: Bits = Bits::new(s_5172_2 as u128, 3u16);
        // D s_5172_4: cmp-eq s_5172_1 s_5172_3
        let s_5172_4: bool = ((s_5172_1) == (s_5172_3));
        // D s_5172_5: write-var gs#117947 <= s_5172_4
        fn_state.gs_117947 = s_5172_4;
        // N s_5172_6: jump b899
        return block_899(state, tracer, fn_state);
    }
    fn block_5173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5173_0: read-var opc1:u8
        let s_5173_0: u8 = fn_state.opc1;
        // D s_5173_1: cast zx s_5173_0 -> bv
        let s_5173_1: Bits = Bits::new(s_5173_0 as u128, 3u16);
        // C s_5173_2: const #0u : u8
        let s_5173_2: u8 = 0;
        // C s_5173_3: cast zx s_5173_2 -> bv
        let s_5173_3: Bits = Bits::new(s_5173_2 as u128, 3u16);
        // D s_5173_4: cmp-eq s_5173_1 s_5173_3
        let s_5173_4: bool = ((s_5173_1) == (s_5173_3));
        // D s_5173_5: write-var gs#117946 <= s_5173_4
        fn_state.gs_117946 = s_5173_4;
        // N s_5173_6: jump b897
        return block_897(state, tracer, fn_state);
    }
    fn block_5174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5174_0: read-var coproc:u8
        let s_5174_0: u8 = fn_state.coproc;
        // D s_5174_1: cast zx s_5174_0 -> bv
        let s_5174_1: Bits = Bits::new(s_5174_0 as u128, 4u16);
        // C s_5174_2: const #15u : u8
        let s_5174_2: u8 = 15;
        // C s_5174_3: cast zx s_5174_2 -> bv
        let s_5174_3: Bits = Bits::new(s_5174_2 as u128, 4u16);
        // D s_5174_4: cmp-eq s_5174_1 s_5174_3
        let s_5174_4: bool = ((s_5174_1) == (s_5174_3));
        // D s_5174_5: write-var gs#117945 <= s_5174_4
        fn_state.gs_117945 = s_5174_4;
        // N s_5174_6: jump b895
        return block_895(state, tracer, fn_state);
    }
    fn block_5175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5175_0: read-var CRn:u8
        let s_5175_0: u8 = fn_state.CRn;
        // D s_5175_1: cast zx s_5175_0 -> bv
        let s_5175_1: Bits = Bits::new(s_5175_0 as u128, 4u16);
        // C s_5175_2: const #3u : u8
        let s_5175_2: u8 = 3;
        // C s_5175_3: cast zx s_5175_2 -> bv
        let s_5175_3: Bits = Bits::new(s_5175_2 as u128, 4u16);
        // D s_5175_4: cmp-eq s_5175_1 s_5175_3
        let s_5175_4: bool = ((s_5175_1) == (s_5175_3));
        // D s_5175_5: write-var gs#117944 <= s_5175_4
        fn_state.gs_117944 = s_5175_4;
        // N s_5175_6: jump b893
        return block_893(state, tracer, fn_state);
    }
    fn block_5176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5176_0: read-var el:u8
        let s_5176_0: u8 = fn_state.el;
        // D s_5176_1: read-var coproc:u8
        let s_5176_1: u8 = fn_state.coproc;
        // D s_5176_2: read-var opc1:u8
        let s_5176_2: u8 = fn_state.opc1;
        // D s_5176_3: read-var CRn:u8
        let s_5176_3: u8 = fn_state.CRn;
        // D s_5176_4: read-var opc2:u8
        let s_5176_4: u8 = fn_state.opc2;
        // D s_5176_5: read-var CRm:u8
        let s_5176_5: u8 = fn_state.CRm;
        // D s_5176_6: read-var t:i
        let s_5176_6: i128 = fn_state.t;
        // D s_5176_7: call HMAIR0_SysRegRead32_f157e09e6f0e50a5(s_5176_0, s_5176_1, s_5176_2, s_5176_3, s_5176_4, s_5176_5, s_5176_6)
        let s_5176_7: () = HMAIR0_SysRegRead32_f157e09e6f0e50a5(
            state,
            tracer,
            s_5176_0,
            s_5176_1,
            s_5176_2,
            s_5176_3,
            s_5176_4,
            s_5176_5,
            s_5176_6,
        );
        // N s_5176_8: return
        return;
    }
    fn block_5177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5177_0: read-var opc2:u8
        let s_5177_0: u8 = fn_state.opc2;
        // D s_5177_1: cast zx s_5177_0 -> bv
        let s_5177_1: Bits = Bits::new(s_5177_0 as u128, 3u16);
        // C s_5177_2: const #0u : u8
        let s_5177_2: u8 = 0;
        // C s_5177_3: cast zx s_5177_2 -> bv
        let s_5177_3: Bits = Bits::new(s_5177_2 as u128, 3u16);
        // D s_5177_4: cmp-eq s_5177_1 s_5177_3
        let s_5177_4: bool = ((s_5177_1) == (s_5177_3));
        // D s_5177_5: write-var gs#117943 <= s_5177_4
        fn_state.gs_117943 = s_5177_4;
        // N s_5177_6: jump b890
        return block_890(state, tracer, fn_state);
    }
    fn block_5178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5178_0: read-var opc1:u8
        let s_5178_0: u8 = fn_state.opc1;
        // D s_5178_1: cast zx s_5178_0 -> bv
        let s_5178_1: Bits = Bits::new(s_5178_0 as u128, 3u16);
        // C s_5178_2: const #4u : u8
        let s_5178_2: u8 = 4;
        // C s_5178_3: cast zx s_5178_2 -> bv
        let s_5178_3: Bits = Bits::new(s_5178_2 as u128, 3u16);
        // D s_5178_4: cmp-eq s_5178_1 s_5178_3
        let s_5178_4: bool = ((s_5178_1) == (s_5178_3));
        // D s_5178_5: write-var gs#117942 <= s_5178_4
        fn_state.gs_117942 = s_5178_4;
        // N s_5178_6: jump b888
        return block_888(state, tracer, fn_state);
    }
    fn block_5179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5179_0: read-var coproc:u8
        let s_5179_0: u8 = fn_state.coproc;
        // D s_5179_1: cast zx s_5179_0 -> bv
        let s_5179_1: Bits = Bits::new(s_5179_0 as u128, 4u16);
        // C s_5179_2: const #15u : u8
        let s_5179_2: u8 = 15;
        // C s_5179_3: cast zx s_5179_2 -> bv
        let s_5179_3: Bits = Bits::new(s_5179_2 as u128, 4u16);
        // D s_5179_4: cmp-eq s_5179_1 s_5179_3
        let s_5179_4: bool = ((s_5179_1) == (s_5179_3));
        // D s_5179_5: write-var gs#117941 <= s_5179_4
        fn_state.gs_117941 = s_5179_4;
        // N s_5179_6: jump b886
        return block_886(state, tracer, fn_state);
    }
    fn block_5180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5180_0: read-var CRn:u8
        let s_5180_0: u8 = fn_state.CRn;
        // D s_5180_1: cast zx s_5180_0 -> bv
        let s_5180_1: Bits = Bits::new(s_5180_0 as u128, 4u16);
        // C s_5180_2: const #10u : u8
        let s_5180_2: u8 = 10;
        // C s_5180_3: cast zx s_5180_2 -> bv
        let s_5180_3: Bits = Bits::new(s_5180_2 as u128, 4u16);
        // D s_5180_4: cmp-eq s_5180_1 s_5180_3
        let s_5180_4: bool = ((s_5180_1) == (s_5180_3));
        // D s_5180_5: write-var gs#117940 <= s_5180_4
        fn_state.gs_117940 = s_5180_4;
        // N s_5180_6: jump b884
        return block_884(state, tracer, fn_state);
    }
    fn block_5181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5181_0: read-var el:u8
        let s_5181_0: u8 = fn_state.el;
        // D s_5181_1: read-var coproc:u8
        let s_5181_1: u8 = fn_state.coproc;
        // D s_5181_2: read-var opc1:u8
        let s_5181_2: u8 = fn_state.opc1;
        // D s_5181_3: read-var CRn:u8
        let s_5181_3: u8 = fn_state.CRn;
        // D s_5181_4: read-var opc2:u8
        let s_5181_4: u8 = fn_state.opc2;
        // D s_5181_5: read-var CRm:u8
        let s_5181_5: u8 = fn_state.CRm;
        // D s_5181_6: read-var t:i
        let s_5181_6: i128 = fn_state.t;
        // D s_5181_7: call ID_PFR2_SysRegRead32_d658419137606f13(s_5181_0, s_5181_1, s_5181_2, s_5181_3, s_5181_4, s_5181_5, s_5181_6)
        let s_5181_7: () = ID_PFR2_SysRegRead32_d658419137606f13(
            state,
            tracer,
            s_5181_0,
            s_5181_1,
            s_5181_2,
            s_5181_3,
            s_5181_4,
            s_5181_5,
            s_5181_6,
        );
        // N s_5181_8: return
        return;
    }
    fn block_5182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5182_0: read-var opc2:u8
        let s_5182_0: u8 = fn_state.opc2;
        // D s_5182_1: cast zx s_5182_0 -> bv
        let s_5182_1: Bits = Bits::new(s_5182_0 as u128, 3u16);
        // C s_5182_2: const #4u : u8
        let s_5182_2: u8 = 4;
        // C s_5182_3: cast zx s_5182_2 -> bv
        let s_5182_3: Bits = Bits::new(s_5182_2 as u128, 3u16);
        // D s_5182_4: cmp-eq s_5182_1 s_5182_3
        let s_5182_4: bool = ((s_5182_1) == (s_5182_3));
        // D s_5182_5: write-var gs#117939 <= s_5182_4
        fn_state.gs_117939 = s_5182_4;
        // N s_5182_6: jump b881
        return block_881(state, tracer, fn_state);
    }
    fn block_5183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5183_0: read-var opc1:u8
        let s_5183_0: u8 = fn_state.opc1;
        // D s_5183_1: cast zx s_5183_0 -> bv
        let s_5183_1: Bits = Bits::new(s_5183_0 as u128, 3u16);
        // C s_5183_2: const #0u : u8
        let s_5183_2: u8 = 0;
        // C s_5183_3: cast zx s_5183_2 -> bv
        let s_5183_3: Bits = Bits::new(s_5183_2 as u128, 3u16);
        // D s_5183_4: cmp-eq s_5183_1 s_5183_3
        let s_5183_4: bool = ((s_5183_1) == (s_5183_3));
        // D s_5183_5: write-var gs#117938 <= s_5183_4
        fn_state.gs_117938 = s_5183_4;
        // N s_5183_6: jump b879
        return block_879(state, tracer, fn_state);
    }
    fn block_5184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5184_0: read-var coproc:u8
        let s_5184_0: u8 = fn_state.coproc;
        // D s_5184_1: cast zx s_5184_0 -> bv
        let s_5184_1: Bits = Bits::new(s_5184_0 as u128, 4u16);
        // C s_5184_2: const #15u : u8
        let s_5184_2: u8 = 15;
        // C s_5184_3: cast zx s_5184_2 -> bv
        let s_5184_3: Bits = Bits::new(s_5184_2 as u128, 4u16);
        // D s_5184_4: cmp-eq s_5184_1 s_5184_3
        let s_5184_4: bool = ((s_5184_1) == (s_5184_3));
        // D s_5184_5: write-var gs#117937 <= s_5184_4
        fn_state.gs_117937 = s_5184_4;
        // N s_5184_6: jump b877
        return block_877(state, tracer, fn_state);
    }
    fn block_5185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5185_0: read-var CRn:u8
        let s_5185_0: u8 = fn_state.CRn;
        // D s_5185_1: cast zx s_5185_0 -> bv
        let s_5185_1: Bits = Bits::new(s_5185_0 as u128, 4u16);
        // C s_5185_2: const #0u : u8
        let s_5185_2: u8 = 0;
        // C s_5185_3: cast zx s_5185_2 -> bv
        let s_5185_3: Bits = Bits::new(s_5185_2 as u128, 4u16);
        // D s_5185_4: cmp-eq s_5185_1 s_5185_3
        let s_5185_4: bool = ((s_5185_1) == (s_5185_3));
        // D s_5185_5: write-var gs#117936 <= s_5185_4
        fn_state.gs_117936 = s_5185_4;
        // N s_5185_6: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_5186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5186_0: read-var el:u8
        let s_5186_0: u8 = fn_state.el;
        // D s_5186_1: read-var coproc:u8
        let s_5186_1: u8 = fn_state.coproc;
        // D s_5186_2: read-var opc1:u8
        let s_5186_2: u8 = fn_state.opc1;
        // D s_5186_3: read-var CRn:u8
        let s_5186_3: u8 = fn_state.CRn;
        // D s_5186_4: read-var opc2:u8
        let s_5186_4: u8 = fn_state.opc2;
        // D s_5186_5: read-var CRm:u8
        let s_5186_5: u8 = fn_state.CRm;
        // D s_5186_6: read-var t:i
        let s_5186_6: i128 = fn_state.t;
        // D s_5186_7: call HCR2_SysRegRead32_f7ed44285bae255b(s_5186_0, s_5186_1, s_5186_2, s_5186_3, s_5186_4, s_5186_5, s_5186_6)
        let s_5186_7: () = HCR2_SysRegRead32_f7ed44285bae255b(
            state,
            tracer,
            s_5186_0,
            s_5186_1,
            s_5186_2,
            s_5186_3,
            s_5186_4,
            s_5186_5,
            s_5186_6,
        );
        // N s_5186_8: return
        return;
    }
    fn block_5187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5187_0: read-var opc2:u8
        let s_5187_0: u8 = fn_state.opc2;
        // D s_5187_1: cast zx s_5187_0 -> bv
        let s_5187_1: Bits = Bits::new(s_5187_0 as u128, 3u16);
        // C s_5187_2: const #4u : u8
        let s_5187_2: u8 = 4;
        // C s_5187_3: cast zx s_5187_2 -> bv
        let s_5187_3: Bits = Bits::new(s_5187_2 as u128, 3u16);
        // D s_5187_4: cmp-eq s_5187_1 s_5187_3
        let s_5187_4: bool = ((s_5187_1) == (s_5187_3));
        // D s_5187_5: write-var gs#117935 <= s_5187_4
        fn_state.gs_117935 = s_5187_4;
        // N s_5187_6: jump b872
        return block_872(state, tracer, fn_state);
    }
    fn block_5188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5188_0: read-var opc1:u8
        let s_5188_0: u8 = fn_state.opc1;
        // D s_5188_1: cast zx s_5188_0 -> bv
        let s_5188_1: Bits = Bits::new(s_5188_0 as u128, 3u16);
        // C s_5188_2: const #4u : u8
        let s_5188_2: u8 = 4;
        // C s_5188_3: cast zx s_5188_2 -> bv
        let s_5188_3: Bits = Bits::new(s_5188_2 as u128, 3u16);
        // D s_5188_4: cmp-eq s_5188_1 s_5188_3
        let s_5188_4: bool = ((s_5188_1) == (s_5188_3));
        // D s_5188_5: write-var gs#117934 <= s_5188_4
        fn_state.gs_117934 = s_5188_4;
        // N s_5188_6: jump b870
        return block_870(state, tracer, fn_state);
    }
    fn block_5189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5189_0: read-var coproc:u8
        let s_5189_0: u8 = fn_state.coproc;
        // D s_5189_1: cast zx s_5189_0 -> bv
        let s_5189_1: Bits = Bits::new(s_5189_0 as u128, 4u16);
        // C s_5189_2: const #15u : u8
        let s_5189_2: u8 = 15;
        // C s_5189_3: cast zx s_5189_2 -> bv
        let s_5189_3: Bits = Bits::new(s_5189_2 as u128, 4u16);
        // D s_5189_4: cmp-eq s_5189_1 s_5189_3
        let s_5189_4: bool = ((s_5189_1) == (s_5189_3));
        // D s_5189_5: write-var gs#117933 <= s_5189_4
        fn_state.gs_117933 = s_5189_4;
        // N s_5189_6: jump b868
        return block_868(state, tracer, fn_state);
    }
    fn block_5190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5190_0: read-var CRn:u8
        let s_5190_0: u8 = fn_state.CRn;
        // D s_5190_1: cast zx s_5190_0 -> bv
        let s_5190_1: Bits = Bits::new(s_5190_0 as u128, 4u16);
        // C s_5190_2: const #1u : u8
        let s_5190_2: u8 = 1;
        // C s_5190_3: cast zx s_5190_2 -> bv
        let s_5190_3: Bits = Bits::new(s_5190_2 as u128, 4u16);
        // D s_5190_4: cmp-eq s_5190_1 s_5190_3
        let s_5190_4: bool = ((s_5190_1) == (s_5190_3));
        // D s_5190_5: write-var gs#117932 <= s_5190_4
        fn_state.gs_117932 = s_5190_4;
        // N s_5190_6: jump b866
        return block_866(state, tracer, fn_state);
    }
    fn block_5191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5191_0: read-var el:u8
        let s_5191_0: u8 = fn_state.el;
        // D s_5191_1: read-var coproc:u8
        let s_5191_1: u8 = fn_state.coproc;
        // D s_5191_2: read-var opc1:u8
        let s_5191_2: u8 = fn_state.opc1;
        // D s_5191_3: read-var CRn:u8
        let s_5191_3: u8 = fn_state.CRn;
        // D s_5191_4: read-var opc2:u8
        let s_5191_4: u8 = fn_state.opc2;
        // D s_5191_5: read-var CRm:u8
        let s_5191_5: u8 = fn_state.CRm;
        // D s_5191_6: read-var t:i
        let s_5191_6: i128 = fn_state.t;
        // D s_5191_7: call HRMR_SysRegRead32_ce0678ac4cae9992(s_5191_0, s_5191_1, s_5191_2, s_5191_3, s_5191_4, s_5191_5, s_5191_6)
        let s_5191_7: () = HRMR_SysRegRead32_ce0678ac4cae9992(
            state,
            tracer,
            s_5191_0,
            s_5191_1,
            s_5191_2,
            s_5191_3,
            s_5191_4,
            s_5191_5,
            s_5191_6,
        );
        // N s_5191_8: return
        return;
    }
    fn block_5192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5192_0: read-var opc2:u8
        let s_5192_0: u8 = fn_state.opc2;
        // D s_5192_1: cast zx s_5192_0 -> bv
        let s_5192_1: Bits = Bits::new(s_5192_0 as u128, 3u16);
        // C s_5192_2: const #2u : u8
        let s_5192_2: u8 = 2;
        // C s_5192_3: cast zx s_5192_2 -> bv
        let s_5192_3: Bits = Bits::new(s_5192_2 as u128, 3u16);
        // D s_5192_4: cmp-eq s_5192_1 s_5192_3
        let s_5192_4: bool = ((s_5192_1) == (s_5192_3));
        // D s_5192_5: write-var gs#117931 <= s_5192_4
        fn_state.gs_117931 = s_5192_4;
        // N s_5192_6: jump b863
        return block_863(state, tracer, fn_state);
    }
    fn block_5193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5193_0: read-var opc1:u8
        let s_5193_0: u8 = fn_state.opc1;
        // D s_5193_1: cast zx s_5193_0 -> bv
        let s_5193_1: Bits = Bits::new(s_5193_0 as u128, 3u16);
        // C s_5193_2: const #4u : u8
        let s_5193_2: u8 = 4;
        // C s_5193_3: cast zx s_5193_2 -> bv
        let s_5193_3: Bits = Bits::new(s_5193_2 as u128, 3u16);
        // D s_5193_4: cmp-eq s_5193_1 s_5193_3
        let s_5193_4: bool = ((s_5193_1) == (s_5193_3));
        // D s_5193_5: write-var gs#117930 <= s_5193_4
        fn_state.gs_117930 = s_5193_4;
        // N s_5193_6: jump b861
        return block_861(state, tracer, fn_state);
    }
    fn block_5194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5194_0: read-var coproc:u8
        let s_5194_0: u8 = fn_state.coproc;
        // D s_5194_1: cast zx s_5194_0 -> bv
        let s_5194_1: Bits = Bits::new(s_5194_0 as u128, 4u16);
        // C s_5194_2: const #15u : u8
        let s_5194_2: u8 = 15;
        // C s_5194_3: cast zx s_5194_2 -> bv
        let s_5194_3: Bits = Bits::new(s_5194_2 as u128, 4u16);
        // D s_5194_4: cmp-eq s_5194_1 s_5194_3
        let s_5194_4: bool = ((s_5194_1) == (s_5194_3));
        // D s_5194_5: write-var gs#117929 <= s_5194_4
        fn_state.gs_117929 = s_5194_4;
        // N s_5194_6: jump b859
        return block_859(state, tracer, fn_state);
    }
    fn block_5195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5195_0: read-var CRn:u8
        let s_5195_0: u8 = fn_state.CRn;
        // D s_5195_1: cast zx s_5195_0 -> bv
        let s_5195_1: Bits = Bits::new(s_5195_0 as u128, 4u16);
        // C s_5195_2: const #12u : u8
        let s_5195_2: u8 = 12;
        // C s_5195_3: cast zx s_5195_2 -> bv
        let s_5195_3: Bits = Bits::new(s_5195_2 as u128, 4u16);
        // D s_5195_4: cmp-eq s_5195_1 s_5195_3
        let s_5195_4: bool = ((s_5195_1) == (s_5195_3));
        // D s_5195_5: write-var gs#117928 <= s_5195_4
        fn_state.gs_117928 = s_5195_4;
        // N s_5195_6: jump b857
        return block_857(state, tracer, fn_state);
    }
    fn block_5196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5196_0: read-var el:u8
        let s_5196_0: u8 = fn_state.el;
        // D s_5196_1: read-var coproc:u8
        let s_5196_1: u8 = fn_state.coproc;
        // D s_5196_2: read-var opc1:u8
        let s_5196_2: u8 = fn_state.opc1;
        // D s_5196_3: read-var CRn:u8
        let s_5196_3: u8 = fn_state.CRn;
        // D s_5196_4: read-var opc2:u8
        let s_5196_4: u8 = fn_state.opc2;
        // D s_5196_5: read-var CRm:u8
        let s_5196_5: u8 = fn_state.CRm;
        // D s_5196_6: read-var t:i
        let s_5196_6: i128 = fn_state.t;
        // D s_5196_7: call ICV_AP0R_SysRegRead32_72af30ac5c792211(s_5196_0, s_5196_1, s_5196_2, s_5196_3, s_5196_4, s_5196_5, s_5196_6)
        let s_5196_7: () = ICV_AP0R_SysRegRead32_72af30ac5c792211(
            state,
            tracer,
            s_5196_0,
            s_5196_1,
            s_5196_2,
            s_5196_3,
            s_5196_4,
            s_5196_5,
            s_5196_6,
        );
        // N s_5196_8: return
        return;
    }
    fn block_5197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5197_0: read-var opc2:u8
        let s_5197_0: u8 = fn_state.opc2;
        // D s_5197_1: cast zx s_5197_0 -> bv
        let s_5197_1: Bits = Bits::new(s_5197_0 as u128, 3u16);
        // C s_5197_2: const #4u : u8
        let s_5197_2: u8 = 4;
        // C s_5197_3: cast zx s_5197_2 -> bv
        let s_5197_3: Bits = Bits::new(s_5197_2 as u128, 3u16);
        // D s_5197_4: cmp-eq s_5197_1 s_5197_3
        let s_5197_4: bool = ((s_5197_1) == (s_5197_3));
        // D s_5197_5: write-var gs#117927 <= s_5197_4
        fn_state.gs_117927 = s_5197_4;
        // N s_5197_6: jump b854
        return block_854(state, tracer, fn_state);
    }
    fn block_5198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5198_0: read-var opc1:u8
        let s_5198_0: u8 = fn_state.opc1;
        // D s_5198_1: cast zx s_5198_0 -> bv
        let s_5198_1: Bits = Bits::new(s_5198_0 as u128, 3u16);
        // C s_5198_2: const #0u : u8
        let s_5198_2: u8 = 0;
        // C s_5198_3: cast zx s_5198_2 -> bv
        let s_5198_3: Bits = Bits::new(s_5198_2 as u128, 3u16);
        // D s_5198_4: cmp-eq s_5198_1 s_5198_3
        let s_5198_4: bool = ((s_5198_1) == (s_5198_3));
        // D s_5198_5: write-var gs#117926 <= s_5198_4
        fn_state.gs_117926 = s_5198_4;
        // N s_5198_6: jump b852
        return block_852(state, tracer, fn_state);
    }
    fn block_5199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5199_0: read-var coproc:u8
        let s_5199_0: u8 = fn_state.coproc;
        // D s_5199_1: cast zx s_5199_0 -> bv
        let s_5199_1: Bits = Bits::new(s_5199_0 as u128, 4u16);
        // C s_5199_2: const #15u : u8
        let s_5199_2: u8 = 15;
        // C s_5199_3: cast zx s_5199_2 -> bv
        let s_5199_3: Bits = Bits::new(s_5199_2 as u128, 4u16);
        // D s_5199_4: cmp-eq s_5199_1 s_5199_3
        let s_5199_4: bool = ((s_5199_1) == (s_5199_3));
        // D s_5199_5: write-var gs#117925 <= s_5199_4
        fn_state.gs_117925 = s_5199_4;
        // N s_5199_6: jump b850
        return block_850(state, tracer, fn_state);
    }
    fn block_5200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5200_0: read-var CRn:u8
        let s_5200_0: u8 = fn_state.CRn;
        // D s_5200_1: cast zx s_5200_0 -> bv
        let s_5200_1: Bits = Bits::new(s_5200_0 as u128, 4u16);
        // C s_5200_2: const #12u : u8
        let s_5200_2: u8 = 12;
        // C s_5200_3: cast zx s_5200_2 -> bv
        let s_5200_3: Bits = Bits::new(s_5200_2 as u128, 4u16);
        // D s_5200_4: cmp-eq s_5200_1 s_5200_3
        let s_5200_4: bool = ((s_5200_1) == (s_5200_3));
        // D s_5200_5: write-var gs#117924 <= s_5200_4
        fn_state.gs_117924 = s_5200_4;
        // N s_5200_6: jump b848
        return block_848(state, tracer, fn_state);
    }
    fn block_5201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5201_0: read-var el:u8
        let s_5201_0: u8 = fn_state.el;
        // D s_5201_1: read-var coproc:u8
        let s_5201_1: u8 = fn_state.coproc;
        // D s_5201_2: read-var opc1:u8
        let s_5201_2: u8 = fn_state.opc1;
        // D s_5201_3: read-var CRn:u8
        let s_5201_3: u8 = fn_state.CRn;
        // D s_5201_4: read-var opc2:u8
        let s_5201_4: u8 = fn_state.opc2;
        // D s_5201_5: read-var CRm:u8
        let s_5201_5: u8 = fn_state.CRm;
        // D s_5201_6: read-var t:i
        let s_5201_6: i128 = fn_state.t;
        // D s_5201_7: call ICV_AP0R_SysRegRead32_30ba9fd61ae1e604(s_5201_0, s_5201_1, s_5201_2, s_5201_3, s_5201_4, s_5201_5, s_5201_6)
        let s_5201_7: () = ICV_AP0R_SysRegRead32_30ba9fd61ae1e604(
            state,
            tracer,
            s_5201_0,
            s_5201_1,
            s_5201_2,
            s_5201_3,
            s_5201_4,
            s_5201_5,
            s_5201_6,
        );
        // N s_5201_8: return
        return;
    }
    fn block_5202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5202_0: read-var opc2:u8
        let s_5202_0: u8 = fn_state.opc2;
        // D s_5202_1: cast zx s_5202_0 -> bv
        let s_5202_1: Bits = Bits::new(s_5202_0 as u128, 3u16);
        // C s_5202_2: const #5u : u8
        let s_5202_2: u8 = 5;
        // C s_5202_3: cast zx s_5202_2 -> bv
        let s_5202_3: Bits = Bits::new(s_5202_2 as u128, 3u16);
        // D s_5202_4: cmp-eq s_5202_1 s_5202_3
        let s_5202_4: bool = ((s_5202_1) == (s_5202_3));
        // D s_5202_5: write-var gs#117923 <= s_5202_4
        fn_state.gs_117923 = s_5202_4;
        // N s_5202_6: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_5203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5203_0: read-var opc1:u8
        let s_5203_0: u8 = fn_state.opc1;
        // D s_5203_1: cast zx s_5203_0 -> bv
        let s_5203_1: Bits = Bits::new(s_5203_0 as u128, 3u16);
        // C s_5203_2: const #0u : u8
        let s_5203_2: u8 = 0;
        // C s_5203_3: cast zx s_5203_2 -> bv
        let s_5203_3: Bits = Bits::new(s_5203_2 as u128, 3u16);
        // D s_5203_4: cmp-eq s_5203_1 s_5203_3
        let s_5203_4: bool = ((s_5203_1) == (s_5203_3));
        // D s_5203_5: write-var gs#117922 <= s_5203_4
        fn_state.gs_117922 = s_5203_4;
        // N s_5203_6: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_5204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5204_0: read-var coproc:u8
        let s_5204_0: u8 = fn_state.coproc;
        // D s_5204_1: cast zx s_5204_0 -> bv
        let s_5204_1: Bits = Bits::new(s_5204_0 as u128, 4u16);
        // C s_5204_2: const #15u : u8
        let s_5204_2: u8 = 15;
        // C s_5204_3: cast zx s_5204_2 -> bv
        let s_5204_3: Bits = Bits::new(s_5204_2 as u128, 4u16);
        // D s_5204_4: cmp-eq s_5204_1 s_5204_3
        let s_5204_4: bool = ((s_5204_1) == (s_5204_3));
        // D s_5204_5: write-var gs#117921 <= s_5204_4
        fn_state.gs_117921 = s_5204_4;
        // N s_5204_6: jump b841
        return block_841(state, tracer, fn_state);
    }
    fn block_5205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5205_0: read-var CRn:u8
        let s_5205_0: u8 = fn_state.CRn;
        // D s_5205_1: cast zx s_5205_0 -> bv
        let s_5205_1: Bits = Bits::new(s_5205_0 as u128, 4u16);
        // C s_5205_2: const #12u : u8
        let s_5205_2: u8 = 12;
        // C s_5205_3: cast zx s_5205_2 -> bv
        let s_5205_3: Bits = Bits::new(s_5205_2 as u128, 4u16);
        // D s_5205_4: cmp-eq s_5205_1 s_5205_3
        let s_5205_4: bool = ((s_5205_1) == (s_5205_3));
        // D s_5205_5: write-var gs#117920 <= s_5205_4
        fn_state.gs_117920 = s_5205_4;
        // N s_5205_6: jump b839
        return block_839(state, tracer, fn_state);
    }
    fn block_5206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5206_0: read-var el:u8
        let s_5206_0: u8 = fn_state.el;
        // D s_5206_1: read-var coproc:u8
        let s_5206_1: u8 = fn_state.coproc;
        // D s_5206_2: read-var opc1:u8
        let s_5206_2: u8 = fn_state.opc1;
        // D s_5206_3: read-var CRn:u8
        let s_5206_3: u8 = fn_state.CRn;
        // D s_5206_4: read-var opc2:u8
        let s_5206_4: u8 = fn_state.opc2;
        // D s_5206_5: read-var CRm:u8
        let s_5206_5: u8 = fn_state.CRm;
        // D s_5206_6: read-var t:i
        let s_5206_6: i128 = fn_state.t;
        // D s_5206_7: call ICV_AP0R_SysRegRead32_dc4d5081c52e9718(s_5206_0, s_5206_1, s_5206_2, s_5206_3, s_5206_4, s_5206_5, s_5206_6)
        let s_5206_7: () = ICV_AP0R_SysRegRead32_dc4d5081c52e9718(
            state,
            tracer,
            s_5206_0,
            s_5206_1,
            s_5206_2,
            s_5206_3,
            s_5206_4,
            s_5206_5,
            s_5206_6,
        );
        // N s_5206_8: return
        return;
    }
    fn block_5207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5207_0: read-var opc2:u8
        let s_5207_0: u8 = fn_state.opc2;
        // D s_5207_1: cast zx s_5207_0 -> bv
        let s_5207_1: Bits = Bits::new(s_5207_0 as u128, 3u16);
        // C s_5207_2: const #6u : u8
        let s_5207_2: u8 = 6;
        // C s_5207_3: cast zx s_5207_2 -> bv
        let s_5207_3: Bits = Bits::new(s_5207_2 as u128, 3u16);
        // D s_5207_4: cmp-eq s_5207_1 s_5207_3
        let s_5207_4: bool = ((s_5207_1) == (s_5207_3));
        // D s_5207_5: write-var gs#117919 <= s_5207_4
        fn_state.gs_117919 = s_5207_4;
        // N s_5207_6: jump b836
        return block_836(state, tracer, fn_state);
    }
    fn block_5208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5208_0: read-var opc1:u8
        let s_5208_0: u8 = fn_state.opc1;
        // D s_5208_1: cast zx s_5208_0 -> bv
        let s_5208_1: Bits = Bits::new(s_5208_0 as u128, 3u16);
        // C s_5208_2: const #0u : u8
        let s_5208_2: u8 = 0;
        // C s_5208_3: cast zx s_5208_2 -> bv
        let s_5208_3: Bits = Bits::new(s_5208_2 as u128, 3u16);
        // D s_5208_4: cmp-eq s_5208_1 s_5208_3
        let s_5208_4: bool = ((s_5208_1) == (s_5208_3));
        // D s_5208_5: write-var gs#117918 <= s_5208_4
        fn_state.gs_117918 = s_5208_4;
        // N s_5208_6: jump b834
        return block_834(state, tracer, fn_state);
    }
    fn block_5209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5209_0: read-var coproc:u8
        let s_5209_0: u8 = fn_state.coproc;
        // D s_5209_1: cast zx s_5209_0 -> bv
        let s_5209_1: Bits = Bits::new(s_5209_0 as u128, 4u16);
        // C s_5209_2: const #15u : u8
        let s_5209_2: u8 = 15;
        // C s_5209_3: cast zx s_5209_2 -> bv
        let s_5209_3: Bits = Bits::new(s_5209_2 as u128, 4u16);
        // D s_5209_4: cmp-eq s_5209_1 s_5209_3
        let s_5209_4: bool = ((s_5209_1) == (s_5209_3));
        // D s_5209_5: write-var gs#117917 <= s_5209_4
        fn_state.gs_117917 = s_5209_4;
        // N s_5209_6: jump b832
        return block_832(state, tracer, fn_state);
    }
    fn block_5210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5210_0: read-var CRn:u8
        let s_5210_0: u8 = fn_state.CRn;
        // D s_5210_1: cast zx s_5210_0 -> bv
        let s_5210_1: Bits = Bits::new(s_5210_0 as u128, 4u16);
        // C s_5210_2: const #12u : u8
        let s_5210_2: u8 = 12;
        // C s_5210_3: cast zx s_5210_2 -> bv
        let s_5210_3: Bits = Bits::new(s_5210_2 as u128, 4u16);
        // D s_5210_4: cmp-eq s_5210_1 s_5210_3
        let s_5210_4: bool = ((s_5210_1) == (s_5210_3));
        // D s_5210_5: write-var gs#117916 <= s_5210_4
        fn_state.gs_117916 = s_5210_4;
        // N s_5210_6: jump b830
        return block_830(state, tracer, fn_state);
    }
    fn block_5211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5211_0: read-var el:u8
        let s_5211_0: u8 = fn_state.el;
        // D s_5211_1: read-var coproc:u8
        let s_5211_1: u8 = fn_state.coproc;
        // D s_5211_2: read-var opc1:u8
        let s_5211_2: u8 = fn_state.opc1;
        // D s_5211_3: read-var CRn:u8
        let s_5211_3: u8 = fn_state.CRn;
        // D s_5211_4: read-var opc2:u8
        let s_5211_4: u8 = fn_state.opc2;
        // D s_5211_5: read-var CRm:u8
        let s_5211_5: u8 = fn_state.CRm;
        // D s_5211_6: read-var t:i
        let s_5211_6: i128 = fn_state.t;
        // D s_5211_7: call ICV_AP0R_SysRegRead32_c3c1719656dd9c14(s_5211_0, s_5211_1, s_5211_2, s_5211_3, s_5211_4, s_5211_5, s_5211_6)
        let s_5211_7: () = ICV_AP0R_SysRegRead32_c3c1719656dd9c14(
            state,
            tracer,
            s_5211_0,
            s_5211_1,
            s_5211_2,
            s_5211_3,
            s_5211_4,
            s_5211_5,
            s_5211_6,
        );
        // N s_5211_8: return
        return;
    }
    fn block_5212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5212_0: read-var opc2:u8
        let s_5212_0: u8 = fn_state.opc2;
        // D s_5212_1: cast zx s_5212_0 -> bv
        let s_5212_1: Bits = Bits::new(s_5212_0 as u128, 3u16);
        // C s_5212_2: const #7u : u8
        let s_5212_2: u8 = 7;
        // C s_5212_3: cast zx s_5212_2 -> bv
        let s_5212_3: Bits = Bits::new(s_5212_2 as u128, 3u16);
        // D s_5212_4: cmp-eq s_5212_1 s_5212_3
        let s_5212_4: bool = ((s_5212_1) == (s_5212_3));
        // D s_5212_5: write-var gs#117915 <= s_5212_4
        fn_state.gs_117915 = s_5212_4;
        // N s_5212_6: jump b827
        return block_827(state, tracer, fn_state);
    }
    fn block_5213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5213_0: read-var opc1:u8
        let s_5213_0: u8 = fn_state.opc1;
        // D s_5213_1: cast zx s_5213_0 -> bv
        let s_5213_1: Bits = Bits::new(s_5213_0 as u128, 3u16);
        // C s_5213_2: const #0u : u8
        let s_5213_2: u8 = 0;
        // C s_5213_3: cast zx s_5213_2 -> bv
        let s_5213_3: Bits = Bits::new(s_5213_2 as u128, 3u16);
        // D s_5213_4: cmp-eq s_5213_1 s_5213_3
        let s_5213_4: bool = ((s_5213_1) == (s_5213_3));
        // D s_5213_5: write-var gs#117914 <= s_5213_4
        fn_state.gs_117914 = s_5213_4;
        // N s_5213_6: jump b825
        return block_825(state, tracer, fn_state);
    }
    fn block_5214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5214_0: read-var coproc:u8
        let s_5214_0: u8 = fn_state.coproc;
        // D s_5214_1: cast zx s_5214_0 -> bv
        let s_5214_1: Bits = Bits::new(s_5214_0 as u128, 4u16);
        // C s_5214_2: const #15u : u8
        let s_5214_2: u8 = 15;
        // C s_5214_3: cast zx s_5214_2 -> bv
        let s_5214_3: Bits = Bits::new(s_5214_2 as u128, 4u16);
        // D s_5214_4: cmp-eq s_5214_1 s_5214_3
        let s_5214_4: bool = ((s_5214_1) == (s_5214_3));
        // D s_5214_5: write-var gs#117913 <= s_5214_4
        fn_state.gs_117913 = s_5214_4;
        // N s_5214_6: jump b823
        return block_823(state, tracer, fn_state);
    }
    fn block_5215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5215_0: read-var CRn:u8
        let s_5215_0: u8 = fn_state.CRn;
        // D s_5215_1: cast zx s_5215_0 -> bv
        let s_5215_1: Bits = Bits::new(s_5215_0 as u128, 4u16);
        // C s_5215_2: const #12u : u8
        let s_5215_2: u8 = 12;
        // C s_5215_3: cast zx s_5215_2 -> bv
        let s_5215_3: Bits = Bits::new(s_5215_2 as u128, 4u16);
        // D s_5215_4: cmp-eq s_5215_1 s_5215_3
        let s_5215_4: bool = ((s_5215_1) == (s_5215_3));
        // D s_5215_5: write-var gs#117912 <= s_5215_4
        fn_state.gs_117912 = s_5215_4;
        // N s_5215_6: jump b821
        return block_821(state, tracer, fn_state);
    }
    fn block_5216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5216_0: read-var el:u8
        let s_5216_0: u8 = fn_state.el;
        // D s_5216_1: read-var coproc:u8
        let s_5216_1: u8 = fn_state.coproc;
        // D s_5216_2: read-var opc1:u8
        let s_5216_2: u8 = fn_state.opc1;
        // D s_5216_3: read-var CRn:u8
        let s_5216_3: u8 = fn_state.CRn;
        // D s_5216_4: read-var opc2:u8
        let s_5216_4: u8 = fn_state.opc2;
        // D s_5216_5: read-var CRm:u8
        let s_5216_5: u8 = fn_state.CRm;
        // D s_5216_6: read-var t:i
        let s_5216_6: i128 = fn_state.t;
        // D s_5216_7: call ID_MMFR5_SysRegRead32_e1f37b0c1fecac4d(s_5216_0, s_5216_1, s_5216_2, s_5216_3, s_5216_4, s_5216_5, s_5216_6)
        let s_5216_7: () = ID_MMFR5_SysRegRead32_e1f37b0c1fecac4d(
            state,
            tracer,
            s_5216_0,
            s_5216_1,
            s_5216_2,
            s_5216_3,
            s_5216_4,
            s_5216_5,
            s_5216_6,
        );
        // N s_5216_8: return
        return;
    }
    fn block_5217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5217_0: read-var opc2:u8
        let s_5217_0: u8 = fn_state.opc2;
        // D s_5217_1: cast zx s_5217_0 -> bv
        let s_5217_1: Bits = Bits::new(s_5217_0 as u128, 3u16);
        // C s_5217_2: const #6u : u8
        let s_5217_2: u8 = 6;
        // C s_5217_3: cast zx s_5217_2 -> bv
        let s_5217_3: Bits = Bits::new(s_5217_2 as u128, 3u16);
        // D s_5217_4: cmp-eq s_5217_1 s_5217_3
        let s_5217_4: bool = ((s_5217_1) == (s_5217_3));
        // D s_5217_5: write-var gs#117911 <= s_5217_4
        fn_state.gs_117911 = s_5217_4;
        // N s_5217_6: jump b818
        return block_818(state, tracer, fn_state);
    }
    fn block_5218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5218_0: read-var opc1:u8
        let s_5218_0: u8 = fn_state.opc1;
        // D s_5218_1: cast zx s_5218_0 -> bv
        let s_5218_1: Bits = Bits::new(s_5218_0 as u128, 3u16);
        // C s_5218_2: const #0u : u8
        let s_5218_2: u8 = 0;
        // C s_5218_3: cast zx s_5218_2 -> bv
        let s_5218_3: Bits = Bits::new(s_5218_2 as u128, 3u16);
        // D s_5218_4: cmp-eq s_5218_1 s_5218_3
        let s_5218_4: bool = ((s_5218_1) == (s_5218_3));
        // D s_5218_5: write-var gs#117910 <= s_5218_4
        fn_state.gs_117910 = s_5218_4;
        // N s_5218_6: jump b816
        return block_816(state, tracer, fn_state);
    }
    fn block_5219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5219_0: read-var coproc:u8
        let s_5219_0: u8 = fn_state.coproc;
        // D s_5219_1: cast zx s_5219_0 -> bv
        let s_5219_1: Bits = Bits::new(s_5219_0 as u128, 4u16);
        // C s_5219_2: const #15u : u8
        let s_5219_2: u8 = 15;
        // C s_5219_3: cast zx s_5219_2 -> bv
        let s_5219_3: Bits = Bits::new(s_5219_2 as u128, 4u16);
        // D s_5219_4: cmp-eq s_5219_1 s_5219_3
        let s_5219_4: bool = ((s_5219_1) == (s_5219_3));
        // D s_5219_5: write-var gs#117909 <= s_5219_4
        fn_state.gs_117909 = s_5219_4;
        // N s_5219_6: jump b814
        return block_814(state, tracer, fn_state);
    }
    fn block_5220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5220_0: read-var CRn:u8
        let s_5220_0: u8 = fn_state.CRn;
        // D s_5220_1: cast zx s_5220_0 -> bv
        let s_5220_1: Bits = Bits::new(s_5220_0 as u128, 4u16);
        // C s_5220_2: const #0u : u8
        let s_5220_2: u8 = 0;
        // C s_5220_3: cast zx s_5220_2 -> bv
        let s_5220_3: Bits = Bits::new(s_5220_2 as u128, 4u16);
        // D s_5220_4: cmp-eq s_5220_1 s_5220_3
        let s_5220_4: bool = ((s_5220_1) == (s_5220_3));
        // D s_5220_5: write-var gs#117908 <= s_5220_4
        fn_state.gs_117908 = s_5220_4;
        // N s_5220_6: jump b812
        return block_812(state, tracer, fn_state);
    }
    fn block_5221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5221_0: read-var el:u8
        let s_5221_0: u8 = fn_state.el;
        // D s_5221_1: read-var coproc:u8
        let s_5221_1: u8 = fn_state.coproc;
        // D s_5221_2: read-var opc1:u8
        let s_5221_2: u8 = fn_state.opc1;
        // D s_5221_3: read-var CRn:u8
        let s_5221_3: u8 = fn_state.CRn;
        // D s_5221_4: read-var opc2:u8
        let s_5221_4: u8 = fn_state.opc2;
        // D s_5221_5: read-var CRm:u8
        let s_5221_5: u8 = fn_state.CRm;
        // D s_5221_6: read-var t:i
        let s_5221_6: i128 = fn_state.t;
        // D s_5221_7: call ICV_HPPIR1_SysRegRead32_b45bf9d6297cda27(s_5221_0, s_5221_1, s_5221_2, s_5221_3, s_5221_4, s_5221_5, s_5221_6)
        let s_5221_7: () = ICV_HPPIR1_SysRegRead32_b45bf9d6297cda27(
            state,
            tracer,
            s_5221_0,
            s_5221_1,
            s_5221_2,
            s_5221_3,
            s_5221_4,
            s_5221_5,
            s_5221_6,
        );
        // N s_5221_8: return
        return;
    }
    fn block_5222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5222_0: read-var opc2:u8
        let s_5222_0: u8 = fn_state.opc2;
        // D s_5222_1: cast zx s_5222_0 -> bv
        let s_5222_1: Bits = Bits::new(s_5222_0 as u128, 3u16);
        // C s_5222_2: const #2u : u8
        let s_5222_2: u8 = 2;
        // C s_5222_3: cast zx s_5222_2 -> bv
        let s_5222_3: Bits = Bits::new(s_5222_2 as u128, 3u16);
        // D s_5222_4: cmp-eq s_5222_1 s_5222_3
        let s_5222_4: bool = ((s_5222_1) == (s_5222_3));
        // D s_5222_5: write-var gs#117907 <= s_5222_4
        fn_state.gs_117907 = s_5222_4;
        // N s_5222_6: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_5223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5223_0: read-var opc1:u8
        let s_5223_0: u8 = fn_state.opc1;
        // D s_5223_1: cast zx s_5223_0 -> bv
        let s_5223_1: Bits = Bits::new(s_5223_0 as u128, 3u16);
        // C s_5223_2: const #0u : u8
        let s_5223_2: u8 = 0;
        // C s_5223_3: cast zx s_5223_2 -> bv
        let s_5223_3: Bits = Bits::new(s_5223_2 as u128, 3u16);
        // D s_5223_4: cmp-eq s_5223_1 s_5223_3
        let s_5223_4: bool = ((s_5223_1) == (s_5223_3));
        // D s_5223_5: write-var gs#117906 <= s_5223_4
        fn_state.gs_117906 = s_5223_4;
        // N s_5223_6: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_5224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5224_0: read-var coproc:u8
        let s_5224_0: u8 = fn_state.coproc;
        // D s_5224_1: cast zx s_5224_0 -> bv
        let s_5224_1: Bits = Bits::new(s_5224_0 as u128, 4u16);
        // C s_5224_2: const #15u : u8
        let s_5224_2: u8 = 15;
        // C s_5224_3: cast zx s_5224_2 -> bv
        let s_5224_3: Bits = Bits::new(s_5224_2 as u128, 4u16);
        // D s_5224_4: cmp-eq s_5224_1 s_5224_3
        let s_5224_4: bool = ((s_5224_1) == (s_5224_3));
        // D s_5224_5: write-var gs#117905 <= s_5224_4
        fn_state.gs_117905 = s_5224_4;
        // N s_5224_6: jump b805
        return block_805(state, tracer, fn_state);
    }
    fn block_5225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5225_0: read-var CRn:u8
        let s_5225_0: u8 = fn_state.CRn;
        // D s_5225_1: cast zx s_5225_0 -> bv
        let s_5225_1: Bits = Bits::new(s_5225_0 as u128, 4u16);
        // C s_5225_2: const #12u : u8
        let s_5225_2: u8 = 12;
        // C s_5225_3: cast zx s_5225_2 -> bv
        let s_5225_3: Bits = Bits::new(s_5225_2 as u128, 4u16);
        // D s_5225_4: cmp-eq s_5225_1 s_5225_3
        let s_5225_4: bool = ((s_5225_1) == (s_5225_3));
        // D s_5225_5: write-var gs#117904 <= s_5225_4
        fn_state.gs_117904 = s_5225_4;
        // N s_5225_6: jump b803
        return block_803(state, tracer, fn_state);
    }
    fn block_5226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5226_0: read-var el:u8
        let s_5226_0: u8 = fn_state.el;
        // D s_5226_1: read-var coproc:u8
        let s_5226_1: u8 = fn_state.coproc;
        // D s_5226_2: read-var opc1:u8
        let s_5226_2: u8 = fn_state.opc1;
        // D s_5226_3: read-var CRn:u8
        let s_5226_3: u8 = fn_state.CRn;
        // D s_5226_4: read-var opc2:u8
        let s_5226_4: u8 = fn_state.opc2;
        // D s_5226_5: read-var CRm:u8
        let s_5226_5: u8 = fn_state.CRm;
        // D s_5226_6: read-var t:i
        let s_5226_6: i128 = fn_state.t;
        // D s_5226_7: call DBGWVR_SysRegRead32_c6ca5289ed10ec19(s_5226_0, s_5226_1, s_5226_2, s_5226_3, s_5226_4, s_5226_5, s_5226_6)
        let s_5226_7: () = DBGWVR_SysRegRead32_c6ca5289ed10ec19(
            state,
            tracer,
            s_5226_0,
            s_5226_1,
            s_5226_2,
            s_5226_3,
            s_5226_4,
            s_5226_5,
            s_5226_6,
        );
        // N s_5226_8: return
        return;
    }
    fn block_5227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5227_0: read-var opc2:u8
        let s_5227_0: u8 = fn_state.opc2;
        // D s_5227_1: cast zx s_5227_0 -> bv
        let s_5227_1: Bits = Bits::new(s_5227_0 as u128, 3u16);
        // C s_5227_2: const #6u : u8
        let s_5227_2: u8 = 6;
        // C s_5227_3: cast zx s_5227_2 -> bv
        let s_5227_3: Bits = Bits::new(s_5227_2 as u128, 3u16);
        // D s_5227_4: cmp-eq s_5227_1 s_5227_3
        let s_5227_4: bool = ((s_5227_1) == (s_5227_3));
        // D s_5227_5: write-var gs#117903 <= s_5227_4
        fn_state.gs_117903 = s_5227_4;
        // N s_5227_6: jump b800
        return block_800(state, tracer, fn_state);
    }
    fn block_5228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5228_0: read-var opc1:u8
        let s_5228_0: u8 = fn_state.opc1;
        // D s_5228_1: cast zx s_5228_0 -> bv
        let s_5228_1: Bits = Bits::new(s_5228_0 as u128, 3u16);
        // C s_5228_2: const #0u : u8
        let s_5228_2: u8 = 0;
        // C s_5228_3: cast zx s_5228_2 -> bv
        let s_5228_3: Bits = Bits::new(s_5228_2 as u128, 3u16);
        // D s_5228_4: cmp-eq s_5228_1 s_5228_3
        let s_5228_4: bool = ((s_5228_1) == (s_5228_3));
        // D s_5228_5: write-var gs#117902 <= s_5228_4
        fn_state.gs_117902 = s_5228_4;
        // N s_5228_6: jump b798
        return block_798(state, tracer, fn_state);
    }
    fn block_5229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5229_0: read-var coproc:u8
        let s_5229_0: u8 = fn_state.coproc;
        // D s_5229_1: cast zx s_5229_0 -> bv
        let s_5229_1: Bits = Bits::new(s_5229_0 as u128, 4u16);
        // C s_5229_2: const #14u : u8
        let s_5229_2: u8 = 14;
        // C s_5229_3: cast zx s_5229_2 -> bv
        let s_5229_3: Bits = Bits::new(s_5229_2 as u128, 4u16);
        // D s_5229_4: cmp-eq s_5229_1 s_5229_3
        let s_5229_4: bool = ((s_5229_1) == (s_5229_3));
        // D s_5229_5: write-var gs#117901 <= s_5229_4
        fn_state.gs_117901 = s_5229_4;
        // N s_5229_6: jump b796
        return block_796(state, tracer, fn_state);
    }
    fn block_5230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5230_0: read-var CRn:u8
        let s_5230_0: u8 = fn_state.CRn;
        // D s_5230_1: cast zx s_5230_0 -> bv
        let s_5230_1: Bits = Bits::new(s_5230_0 as u128, 4u16);
        // C s_5230_2: const #0u : u8
        let s_5230_2: u8 = 0;
        // C s_5230_3: cast zx s_5230_2 -> bv
        let s_5230_3: Bits = Bits::new(s_5230_2 as u128, 4u16);
        // D s_5230_4: cmp-eq s_5230_1 s_5230_3
        let s_5230_4: bool = ((s_5230_1) == (s_5230_3));
        // D s_5230_5: write-var gs#117900 <= s_5230_4
        fn_state.gs_117900 = s_5230_4;
        // N s_5230_6: jump b794
        return block_794(state, tracer, fn_state);
    }
    fn block_5231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5231_0: read-var el:u8
        let s_5231_0: u8 = fn_state.el;
        // D s_5231_1: read-var coproc:u8
        let s_5231_1: u8 = fn_state.coproc;
        // D s_5231_2: read-var opc1:u8
        let s_5231_2: u8 = fn_state.opc1;
        // D s_5231_3: read-var CRn:u8
        let s_5231_3: u8 = fn_state.CRn;
        // D s_5231_4: read-var opc2:u8
        let s_5231_4: u8 = fn_state.opc2;
        // D s_5231_5: read-var CRm:u8
        let s_5231_5: u8 = fn_state.CRm;
        // D s_5231_6: read-var t:i
        let s_5231_6: i128 = fn_state.t;
        // D s_5231_7: call DBGWVR_SysRegRead32_6a1d08c571006557(s_5231_0, s_5231_1, s_5231_2, s_5231_3, s_5231_4, s_5231_5, s_5231_6)
        let s_5231_7: () = DBGWVR_SysRegRead32_6a1d08c571006557(
            state,
            tracer,
            s_5231_0,
            s_5231_1,
            s_5231_2,
            s_5231_3,
            s_5231_4,
            s_5231_5,
            s_5231_6,
        );
        // N s_5231_8: return
        return;
    }
    fn block_5232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5232_0: read-var opc2:u8
        let s_5232_0: u8 = fn_state.opc2;
        // D s_5232_1: cast zx s_5232_0 -> bv
        let s_5232_1: Bits = Bits::new(s_5232_0 as u128, 3u16);
        // C s_5232_2: const #6u : u8
        let s_5232_2: u8 = 6;
        // C s_5232_3: cast zx s_5232_2 -> bv
        let s_5232_3: Bits = Bits::new(s_5232_2 as u128, 3u16);
        // D s_5232_4: cmp-eq s_5232_1 s_5232_3
        let s_5232_4: bool = ((s_5232_1) == (s_5232_3));
        // D s_5232_5: write-var gs#117899 <= s_5232_4
        fn_state.gs_117899 = s_5232_4;
        // N s_5232_6: jump b791
        return block_791(state, tracer, fn_state);
    }
    fn block_5233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5233_0: read-var opc1:u8
        let s_5233_0: u8 = fn_state.opc1;
        // D s_5233_1: cast zx s_5233_0 -> bv
        let s_5233_1: Bits = Bits::new(s_5233_0 as u128, 3u16);
        // C s_5233_2: const #0u : u8
        let s_5233_2: u8 = 0;
        // C s_5233_3: cast zx s_5233_2 -> bv
        let s_5233_3: Bits = Bits::new(s_5233_2 as u128, 3u16);
        // D s_5233_4: cmp-eq s_5233_1 s_5233_3
        let s_5233_4: bool = ((s_5233_1) == (s_5233_3));
        // D s_5233_5: write-var gs#117898 <= s_5233_4
        fn_state.gs_117898 = s_5233_4;
        // N s_5233_6: jump b789
        return block_789(state, tracer, fn_state);
    }
    fn block_5234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5234_0: read-var coproc:u8
        let s_5234_0: u8 = fn_state.coproc;
        // D s_5234_1: cast zx s_5234_0 -> bv
        let s_5234_1: Bits = Bits::new(s_5234_0 as u128, 4u16);
        // C s_5234_2: const #14u : u8
        let s_5234_2: u8 = 14;
        // C s_5234_3: cast zx s_5234_2 -> bv
        let s_5234_3: Bits = Bits::new(s_5234_2 as u128, 4u16);
        // D s_5234_4: cmp-eq s_5234_1 s_5234_3
        let s_5234_4: bool = ((s_5234_1) == (s_5234_3));
        // D s_5234_5: write-var gs#117897 <= s_5234_4
        fn_state.gs_117897 = s_5234_4;
        // N s_5234_6: jump b787
        return block_787(state, tracer, fn_state);
    }
    fn block_5235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5235_0: read-var CRn:u8
        let s_5235_0: u8 = fn_state.CRn;
        // D s_5235_1: cast zx s_5235_0 -> bv
        let s_5235_1: Bits = Bits::new(s_5235_0 as u128, 4u16);
        // C s_5235_2: const #0u : u8
        let s_5235_2: u8 = 0;
        // C s_5235_3: cast zx s_5235_2 -> bv
        let s_5235_3: Bits = Bits::new(s_5235_2 as u128, 4u16);
        // D s_5235_4: cmp-eq s_5235_1 s_5235_3
        let s_5235_4: bool = ((s_5235_1) == (s_5235_3));
        // D s_5235_5: write-var gs#117896 <= s_5235_4
        fn_state.gs_117896 = s_5235_4;
        // N s_5235_6: jump b785
        return block_785(state, tracer, fn_state);
    }
    fn block_5236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5236_0: read-var el:u8
        let s_5236_0: u8 = fn_state.el;
        // D s_5236_1: read-var coproc:u8
        let s_5236_1: u8 = fn_state.coproc;
        // D s_5236_2: read-var opc1:u8
        let s_5236_2: u8 = fn_state.opc1;
        // D s_5236_3: read-var CRn:u8
        let s_5236_3: u8 = fn_state.CRn;
        // D s_5236_4: read-var opc2:u8
        let s_5236_4: u8 = fn_state.opc2;
        // D s_5236_5: read-var CRm:u8
        let s_5236_5: u8 = fn_state.CRm;
        // D s_5236_6: read-var t:i
        let s_5236_6: i128 = fn_state.t;
        // D s_5236_7: call DBGWVR_SysRegRead32_7cd7645018d2576e(s_5236_0, s_5236_1, s_5236_2, s_5236_3, s_5236_4, s_5236_5, s_5236_6)
        let s_5236_7: () = DBGWVR_SysRegRead32_7cd7645018d2576e(
            state,
            tracer,
            s_5236_0,
            s_5236_1,
            s_5236_2,
            s_5236_3,
            s_5236_4,
            s_5236_5,
            s_5236_6,
        );
        // N s_5236_8: return
        return;
    }
    fn block_5237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5237_0: read-var opc2:u8
        let s_5237_0: u8 = fn_state.opc2;
        // D s_5237_1: cast zx s_5237_0 -> bv
        let s_5237_1: Bits = Bits::new(s_5237_0 as u128, 3u16);
        // C s_5237_2: const #6u : u8
        let s_5237_2: u8 = 6;
        // C s_5237_3: cast zx s_5237_2 -> bv
        let s_5237_3: Bits = Bits::new(s_5237_2 as u128, 3u16);
        // D s_5237_4: cmp-eq s_5237_1 s_5237_3
        let s_5237_4: bool = ((s_5237_1) == (s_5237_3));
        // D s_5237_5: write-var gs#117895 <= s_5237_4
        fn_state.gs_117895 = s_5237_4;
        // N s_5237_6: jump b782
        return block_782(state, tracer, fn_state);
    }
    fn block_5238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5238_0: read-var opc1:u8
        let s_5238_0: u8 = fn_state.opc1;
        // D s_5238_1: cast zx s_5238_0 -> bv
        let s_5238_1: Bits = Bits::new(s_5238_0 as u128, 3u16);
        // C s_5238_2: const #0u : u8
        let s_5238_2: u8 = 0;
        // C s_5238_3: cast zx s_5238_2 -> bv
        let s_5238_3: Bits = Bits::new(s_5238_2 as u128, 3u16);
        // D s_5238_4: cmp-eq s_5238_1 s_5238_3
        let s_5238_4: bool = ((s_5238_1) == (s_5238_3));
        // D s_5238_5: write-var gs#117894 <= s_5238_4
        fn_state.gs_117894 = s_5238_4;
        // N s_5238_6: jump b780
        return block_780(state, tracer, fn_state);
    }
    fn block_5239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5239_0: read-var coproc:u8
        let s_5239_0: u8 = fn_state.coproc;
        // D s_5239_1: cast zx s_5239_0 -> bv
        let s_5239_1: Bits = Bits::new(s_5239_0 as u128, 4u16);
        // C s_5239_2: const #14u : u8
        let s_5239_2: u8 = 14;
        // C s_5239_3: cast zx s_5239_2 -> bv
        let s_5239_3: Bits = Bits::new(s_5239_2 as u128, 4u16);
        // D s_5239_4: cmp-eq s_5239_1 s_5239_3
        let s_5239_4: bool = ((s_5239_1) == (s_5239_3));
        // D s_5239_5: write-var gs#117893 <= s_5239_4
        fn_state.gs_117893 = s_5239_4;
        // N s_5239_6: jump b778
        return block_778(state, tracer, fn_state);
    }
    fn block_5240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5240_0: read-var CRn:u8
        let s_5240_0: u8 = fn_state.CRn;
        // D s_5240_1: cast zx s_5240_0 -> bv
        let s_5240_1: Bits = Bits::new(s_5240_0 as u128, 4u16);
        // C s_5240_2: const #0u : u8
        let s_5240_2: u8 = 0;
        // C s_5240_3: cast zx s_5240_2 -> bv
        let s_5240_3: Bits = Bits::new(s_5240_2 as u128, 4u16);
        // D s_5240_4: cmp-eq s_5240_1 s_5240_3
        let s_5240_4: bool = ((s_5240_1) == (s_5240_3));
        // D s_5240_5: write-var gs#117892 <= s_5240_4
        fn_state.gs_117892 = s_5240_4;
        // N s_5240_6: jump b776
        return block_776(state, tracer, fn_state);
    }
    fn block_5241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5241_0: read-var el:u8
        let s_5241_0: u8 = fn_state.el;
        // D s_5241_1: read-var coproc:u8
        let s_5241_1: u8 = fn_state.coproc;
        // D s_5241_2: read-var opc1:u8
        let s_5241_2: u8 = fn_state.opc1;
        // D s_5241_3: read-var CRn:u8
        let s_5241_3: u8 = fn_state.CRn;
        // D s_5241_4: read-var opc2:u8
        let s_5241_4: u8 = fn_state.opc2;
        // D s_5241_5: read-var CRm:u8
        let s_5241_5: u8 = fn_state.CRm;
        // D s_5241_6: read-var t:i
        let s_5241_6: i128 = fn_state.t;
        // D s_5241_7: call DBGWVR_SysRegRead32_328f6a9c09b12c20(s_5241_0, s_5241_1, s_5241_2, s_5241_3, s_5241_4, s_5241_5, s_5241_6)
        let s_5241_7: () = DBGWVR_SysRegRead32_328f6a9c09b12c20(
            state,
            tracer,
            s_5241_0,
            s_5241_1,
            s_5241_2,
            s_5241_3,
            s_5241_4,
            s_5241_5,
            s_5241_6,
        );
        // N s_5241_8: return
        return;
    }
    fn block_5242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5242_0: read-var opc2:u8
        let s_5242_0: u8 = fn_state.opc2;
        // D s_5242_1: cast zx s_5242_0 -> bv
        let s_5242_1: Bits = Bits::new(s_5242_0 as u128, 3u16);
        // C s_5242_2: const #6u : u8
        let s_5242_2: u8 = 6;
        // C s_5242_3: cast zx s_5242_2 -> bv
        let s_5242_3: Bits = Bits::new(s_5242_2 as u128, 3u16);
        // D s_5242_4: cmp-eq s_5242_1 s_5242_3
        let s_5242_4: bool = ((s_5242_1) == (s_5242_3));
        // D s_5242_5: write-var gs#117891 <= s_5242_4
        fn_state.gs_117891 = s_5242_4;
        // N s_5242_6: jump b773
        return block_773(state, tracer, fn_state);
    }
    fn block_5243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5243_0: read-var opc1:u8
        let s_5243_0: u8 = fn_state.opc1;
        // D s_5243_1: cast zx s_5243_0 -> bv
        let s_5243_1: Bits = Bits::new(s_5243_0 as u128, 3u16);
        // C s_5243_2: const #0u : u8
        let s_5243_2: u8 = 0;
        // C s_5243_3: cast zx s_5243_2 -> bv
        let s_5243_3: Bits = Bits::new(s_5243_2 as u128, 3u16);
        // D s_5243_4: cmp-eq s_5243_1 s_5243_3
        let s_5243_4: bool = ((s_5243_1) == (s_5243_3));
        // D s_5243_5: write-var gs#117890 <= s_5243_4
        fn_state.gs_117890 = s_5243_4;
        // N s_5243_6: jump b771
        return block_771(state, tracer, fn_state);
    }
    fn block_5244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5244_0: read-var coproc:u8
        let s_5244_0: u8 = fn_state.coproc;
        // D s_5244_1: cast zx s_5244_0 -> bv
        let s_5244_1: Bits = Bits::new(s_5244_0 as u128, 4u16);
        // C s_5244_2: const #14u : u8
        let s_5244_2: u8 = 14;
        // C s_5244_3: cast zx s_5244_2 -> bv
        let s_5244_3: Bits = Bits::new(s_5244_2 as u128, 4u16);
        // D s_5244_4: cmp-eq s_5244_1 s_5244_3
        let s_5244_4: bool = ((s_5244_1) == (s_5244_3));
        // D s_5244_5: write-var gs#117889 <= s_5244_4
        fn_state.gs_117889 = s_5244_4;
        // N s_5244_6: jump b769
        return block_769(state, tracer, fn_state);
    }
    fn block_5245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5245_0: read-var CRn:u8
        let s_5245_0: u8 = fn_state.CRn;
        // D s_5245_1: cast zx s_5245_0 -> bv
        let s_5245_1: Bits = Bits::new(s_5245_0 as u128, 4u16);
        // C s_5245_2: const #0u : u8
        let s_5245_2: u8 = 0;
        // C s_5245_3: cast zx s_5245_2 -> bv
        let s_5245_3: Bits = Bits::new(s_5245_2 as u128, 4u16);
        // D s_5245_4: cmp-eq s_5245_1 s_5245_3
        let s_5245_4: bool = ((s_5245_1) == (s_5245_3));
        // D s_5245_5: write-var gs#117888 <= s_5245_4
        fn_state.gs_117888 = s_5245_4;
        // N s_5245_6: jump b767
        return block_767(state, tracer, fn_state);
    }
    fn block_5246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5246_0: read-var el:u8
        let s_5246_0: u8 = fn_state.el;
        // D s_5246_1: read-var coproc:u8
        let s_5246_1: u8 = fn_state.coproc;
        // D s_5246_2: read-var opc1:u8
        let s_5246_2: u8 = fn_state.opc1;
        // D s_5246_3: read-var CRn:u8
        let s_5246_3: u8 = fn_state.CRn;
        // D s_5246_4: read-var opc2:u8
        let s_5246_4: u8 = fn_state.opc2;
        // D s_5246_5: read-var CRm:u8
        let s_5246_5: u8 = fn_state.CRm;
        // D s_5246_6: read-var t:i
        let s_5246_6: i128 = fn_state.t;
        // D s_5246_7: call DBGWVR_SysRegRead32_da9f18e2f273c366(s_5246_0, s_5246_1, s_5246_2, s_5246_3, s_5246_4, s_5246_5, s_5246_6)
        let s_5246_7: () = DBGWVR_SysRegRead32_da9f18e2f273c366(
            state,
            tracer,
            s_5246_0,
            s_5246_1,
            s_5246_2,
            s_5246_3,
            s_5246_4,
            s_5246_5,
            s_5246_6,
        );
        // N s_5246_8: return
        return;
    }
    fn block_5247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5247_0: read-var opc2:u8
        let s_5247_0: u8 = fn_state.opc2;
        // D s_5247_1: cast zx s_5247_0 -> bv
        let s_5247_1: Bits = Bits::new(s_5247_0 as u128, 3u16);
        // C s_5247_2: const #6u : u8
        let s_5247_2: u8 = 6;
        // C s_5247_3: cast zx s_5247_2 -> bv
        let s_5247_3: Bits = Bits::new(s_5247_2 as u128, 3u16);
        // D s_5247_4: cmp-eq s_5247_1 s_5247_3
        let s_5247_4: bool = ((s_5247_1) == (s_5247_3));
        // D s_5247_5: write-var gs#117887 <= s_5247_4
        fn_state.gs_117887 = s_5247_4;
        // N s_5247_6: jump b764
        return block_764(state, tracer, fn_state);
    }
    fn block_5248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5248_0: read-var opc1:u8
        let s_5248_0: u8 = fn_state.opc1;
        // D s_5248_1: cast zx s_5248_0 -> bv
        let s_5248_1: Bits = Bits::new(s_5248_0 as u128, 3u16);
        // C s_5248_2: const #0u : u8
        let s_5248_2: u8 = 0;
        // C s_5248_3: cast zx s_5248_2 -> bv
        let s_5248_3: Bits = Bits::new(s_5248_2 as u128, 3u16);
        // D s_5248_4: cmp-eq s_5248_1 s_5248_3
        let s_5248_4: bool = ((s_5248_1) == (s_5248_3));
        // D s_5248_5: write-var gs#117886 <= s_5248_4
        fn_state.gs_117886 = s_5248_4;
        // N s_5248_6: jump b762
        return block_762(state, tracer, fn_state);
    }
    fn block_5249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5249_0: read-var coproc:u8
        let s_5249_0: u8 = fn_state.coproc;
        // D s_5249_1: cast zx s_5249_0 -> bv
        let s_5249_1: Bits = Bits::new(s_5249_0 as u128, 4u16);
        // C s_5249_2: const #14u : u8
        let s_5249_2: u8 = 14;
        // C s_5249_3: cast zx s_5249_2 -> bv
        let s_5249_3: Bits = Bits::new(s_5249_2 as u128, 4u16);
        // D s_5249_4: cmp-eq s_5249_1 s_5249_3
        let s_5249_4: bool = ((s_5249_1) == (s_5249_3));
        // D s_5249_5: write-var gs#117885 <= s_5249_4
        fn_state.gs_117885 = s_5249_4;
        // N s_5249_6: jump b760
        return block_760(state, tracer, fn_state);
    }
    fn block_5250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5250_0: read-var CRn:u8
        let s_5250_0: u8 = fn_state.CRn;
        // D s_5250_1: cast zx s_5250_0 -> bv
        let s_5250_1: Bits = Bits::new(s_5250_0 as u128, 4u16);
        // C s_5250_2: const #0u : u8
        let s_5250_2: u8 = 0;
        // C s_5250_3: cast zx s_5250_2 -> bv
        let s_5250_3: Bits = Bits::new(s_5250_2 as u128, 4u16);
        // D s_5250_4: cmp-eq s_5250_1 s_5250_3
        let s_5250_4: bool = ((s_5250_1) == (s_5250_3));
        // D s_5250_5: write-var gs#117884 <= s_5250_4
        fn_state.gs_117884 = s_5250_4;
        // N s_5250_6: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_5251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5251_0: read-var el:u8
        let s_5251_0: u8 = fn_state.el;
        // D s_5251_1: read-var coproc:u8
        let s_5251_1: u8 = fn_state.coproc;
        // D s_5251_2: read-var opc1:u8
        let s_5251_2: u8 = fn_state.opc1;
        // D s_5251_3: read-var CRn:u8
        let s_5251_3: u8 = fn_state.CRn;
        // D s_5251_4: read-var opc2:u8
        let s_5251_4: u8 = fn_state.opc2;
        // D s_5251_5: read-var CRm:u8
        let s_5251_5: u8 = fn_state.CRm;
        // D s_5251_6: read-var t:i
        let s_5251_6: i128 = fn_state.t;
        // D s_5251_7: call DBGWVR_SysRegRead32_f5ed12ff92151086(s_5251_0, s_5251_1, s_5251_2, s_5251_3, s_5251_4, s_5251_5, s_5251_6)
        let s_5251_7: () = DBGWVR_SysRegRead32_f5ed12ff92151086(
            state,
            tracer,
            s_5251_0,
            s_5251_1,
            s_5251_2,
            s_5251_3,
            s_5251_4,
            s_5251_5,
            s_5251_6,
        );
        // N s_5251_8: return
        return;
    }
    fn block_5252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5252_0: read-var opc2:u8
        let s_5252_0: u8 = fn_state.opc2;
        // D s_5252_1: cast zx s_5252_0 -> bv
        let s_5252_1: Bits = Bits::new(s_5252_0 as u128, 3u16);
        // C s_5252_2: const #6u : u8
        let s_5252_2: u8 = 6;
        // C s_5252_3: cast zx s_5252_2 -> bv
        let s_5252_3: Bits = Bits::new(s_5252_2 as u128, 3u16);
        // D s_5252_4: cmp-eq s_5252_1 s_5252_3
        let s_5252_4: bool = ((s_5252_1) == (s_5252_3));
        // D s_5252_5: write-var gs#117883 <= s_5252_4
        fn_state.gs_117883 = s_5252_4;
        // N s_5252_6: jump b755
        return block_755(state, tracer, fn_state);
    }
    fn block_5253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5253_0: read-var opc1:u8
        let s_5253_0: u8 = fn_state.opc1;
        // D s_5253_1: cast zx s_5253_0 -> bv
        let s_5253_1: Bits = Bits::new(s_5253_0 as u128, 3u16);
        // C s_5253_2: const #0u : u8
        let s_5253_2: u8 = 0;
        // C s_5253_3: cast zx s_5253_2 -> bv
        let s_5253_3: Bits = Bits::new(s_5253_2 as u128, 3u16);
        // D s_5253_4: cmp-eq s_5253_1 s_5253_3
        let s_5253_4: bool = ((s_5253_1) == (s_5253_3));
        // D s_5253_5: write-var gs#117882 <= s_5253_4
        fn_state.gs_117882 = s_5253_4;
        // N s_5253_6: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_5254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5254_0: read-var coproc:u8
        let s_5254_0: u8 = fn_state.coproc;
        // D s_5254_1: cast zx s_5254_0 -> bv
        let s_5254_1: Bits = Bits::new(s_5254_0 as u128, 4u16);
        // C s_5254_2: const #14u : u8
        let s_5254_2: u8 = 14;
        // C s_5254_3: cast zx s_5254_2 -> bv
        let s_5254_3: Bits = Bits::new(s_5254_2 as u128, 4u16);
        // D s_5254_4: cmp-eq s_5254_1 s_5254_3
        let s_5254_4: bool = ((s_5254_1) == (s_5254_3));
        // D s_5254_5: write-var gs#117881 <= s_5254_4
        fn_state.gs_117881 = s_5254_4;
        // N s_5254_6: jump b751
        return block_751(state, tracer, fn_state);
    }
    fn block_5255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5255_0: read-var CRn:u8
        let s_5255_0: u8 = fn_state.CRn;
        // D s_5255_1: cast zx s_5255_0 -> bv
        let s_5255_1: Bits = Bits::new(s_5255_0 as u128, 4u16);
        // C s_5255_2: const #0u : u8
        let s_5255_2: u8 = 0;
        // C s_5255_3: cast zx s_5255_2 -> bv
        let s_5255_3: Bits = Bits::new(s_5255_2 as u128, 4u16);
        // D s_5255_4: cmp-eq s_5255_1 s_5255_3
        let s_5255_4: bool = ((s_5255_1) == (s_5255_3));
        // D s_5255_5: write-var gs#117880 <= s_5255_4
        fn_state.gs_117880 = s_5255_4;
        // N s_5255_6: jump b749
        return block_749(state, tracer, fn_state);
    }
    fn block_5256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5256_0: read-var el:u8
        let s_5256_0: u8 = fn_state.el;
        // D s_5256_1: read-var coproc:u8
        let s_5256_1: u8 = fn_state.coproc;
        // D s_5256_2: read-var opc1:u8
        let s_5256_2: u8 = fn_state.opc1;
        // D s_5256_3: read-var CRn:u8
        let s_5256_3: u8 = fn_state.CRn;
        // D s_5256_4: read-var opc2:u8
        let s_5256_4: u8 = fn_state.opc2;
        // D s_5256_5: read-var CRm:u8
        let s_5256_5: u8 = fn_state.CRm;
        // D s_5256_6: read-var t:i
        let s_5256_6: i128 = fn_state.t;
        // D s_5256_7: call DBGWVR_SysRegRead32_4f5bca529a325f7f(s_5256_0, s_5256_1, s_5256_2, s_5256_3, s_5256_4, s_5256_5, s_5256_6)
        let s_5256_7: () = DBGWVR_SysRegRead32_4f5bca529a325f7f(
            state,
            tracer,
            s_5256_0,
            s_5256_1,
            s_5256_2,
            s_5256_3,
            s_5256_4,
            s_5256_5,
            s_5256_6,
        );
        // N s_5256_8: return
        return;
    }
    fn block_5257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5257_0: read-var opc2:u8
        let s_5257_0: u8 = fn_state.opc2;
        // D s_5257_1: cast zx s_5257_0 -> bv
        let s_5257_1: Bits = Bits::new(s_5257_0 as u128, 3u16);
        // C s_5257_2: const #6u : u8
        let s_5257_2: u8 = 6;
        // C s_5257_3: cast zx s_5257_2 -> bv
        let s_5257_3: Bits = Bits::new(s_5257_2 as u128, 3u16);
        // D s_5257_4: cmp-eq s_5257_1 s_5257_3
        let s_5257_4: bool = ((s_5257_1) == (s_5257_3));
        // D s_5257_5: write-var gs#117879 <= s_5257_4
        fn_state.gs_117879 = s_5257_4;
        // N s_5257_6: jump b746
        return block_746(state, tracer, fn_state);
    }
    fn block_5258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5258_0: read-var opc1:u8
        let s_5258_0: u8 = fn_state.opc1;
        // D s_5258_1: cast zx s_5258_0 -> bv
        let s_5258_1: Bits = Bits::new(s_5258_0 as u128, 3u16);
        // C s_5258_2: const #0u : u8
        let s_5258_2: u8 = 0;
        // C s_5258_3: cast zx s_5258_2 -> bv
        let s_5258_3: Bits = Bits::new(s_5258_2 as u128, 3u16);
        // D s_5258_4: cmp-eq s_5258_1 s_5258_3
        let s_5258_4: bool = ((s_5258_1) == (s_5258_3));
        // D s_5258_5: write-var gs#117878 <= s_5258_4
        fn_state.gs_117878 = s_5258_4;
        // N s_5258_6: jump b744
        return block_744(state, tracer, fn_state);
    }
    fn block_5259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5259_0: read-var coproc:u8
        let s_5259_0: u8 = fn_state.coproc;
        // D s_5259_1: cast zx s_5259_0 -> bv
        let s_5259_1: Bits = Bits::new(s_5259_0 as u128, 4u16);
        // C s_5259_2: const #14u : u8
        let s_5259_2: u8 = 14;
        // C s_5259_3: cast zx s_5259_2 -> bv
        let s_5259_3: Bits = Bits::new(s_5259_2 as u128, 4u16);
        // D s_5259_4: cmp-eq s_5259_1 s_5259_3
        let s_5259_4: bool = ((s_5259_1) == (s_5259_3));
        // D s_5259_5: write-var gs#117877 <= s_5259_4
        fn_state.gs_117877 = s_5259_4;
        // N s_5259_6: jump b742
        return block_742(state, tracer, fn_state);
    }
    fn block_5260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5260_0: read-var CRn:u8
        let s_5260_0: u8 = fn_state.CRn;
        // D s_5260_1: cast zx s_5260_0 -> bv
        let s_5260_1: Bits = Bits::new(s_5260_0 as u128, 4u16);
        // C s_5260_2: const #0u : u8
        let s_5260_2: u8 = 0;
        // C s_5260_3: cast zx s_5260_2 -> bv
        let s_5260_3: Bits = Bits::new(s_5260_2 as u128, 4u16);
        // D s_5260_4: cmp-eq s_5260_1 s_5260_3
        let s_5260_4: bool = ((s_5260_1) == (s_5260_3));
        // D s_5260_5: write-var gs#117876 <= s_5260_4
        fn_state.gs_117876 = s_5260_4;
        // N s_5260_6: jump b740
        return block_740(state, tracer, fn_state);
    }
    fn block_5261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5261_0: read-var el:u8
        let s_5261_0: u8 = fn_state.el;
        // D s_5261_1: read-var coproc:u8
        let s_5261_1: u8 = fn_state.coproc;
        // D s_5261_2: read-var opc1:u8
        let s_5261_2: u8 = fn_state.opc1;
        // D s_5261_3: read-var CRn:u8
        let s_5261_3: u8 = fn_state.CRn;
        // D s_5261_4: read-var opc2:u8
        let s_5261_4: u8 = fn_state.opc2;
        // D s_5261_5: read-var CRm:u8
        let s_5261_5: u8 = fn_state.CRm;
        // D s_5261_6: read-var t:i
        let s_5261_6: i128 = fn_state.t;
        // D s_5261_7: call DBGWVR_SysRegRead32_4bb9af81a75faa61(s_5261_0, s_5261_1, s_5261_2, s_5261_3, s_5261_4, s_5261_5, s_5261_6)
        let s_5261_7: () = DBGWVR_SysRegRead32_4bb9af81a75faa61(
            state,
            tracer,
            s_5261_0,
            s_5261_1,
            s_5261_2,
            s_5261_3,
            s_5261_4,
            s_5261_5,
            s_5261_6,
        );
        // N s_5261_8: return
        return;
    }
    fn block_5262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5262_0: read-var opc2:u8
        let s_5262_0: u8 = fn_state.opc2;
        // D s_5262_1: cast zx s_5262_0 -> bv
        let s_5262_1: Bits = Bits::new(s_5262_0 as u128, 3u16);
        // C s_5262_2: const #6u : u8
        let s_5262_2: u8 = 6;
        // C s_5262_3: cast zx s_5262_2 -> bv
        let s_5262_3: Bits = Bits::new(s_5262_2 as u128, 3u16);
        // D s_5262_4: cmp-eq s_5262_1 s_5262_3
        let s_5262_4: bool = ((s_5262_1) == (s_5262_3));
        // D s_5262_5: write-var gs#117875 <= s_5262_4
        fn_state.gs_117875 = s_5262_4;
        // N s_5262_6: jump b737
        return block_737(state, tracer, fn_state);
    }
    fn block_5263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5263_0: read-var opc1:u8
        let s_5263_0: u8 = fn_state.opc1;
        // D s_5263_1: cast zx s_5263_0 -> bv
        let s_5263_1: Bits = Bits::new(s_5263_0 as u128, 3u16);
        // C s_5263_2: const #0u : u8
        let s_5263_2: u8 = 0;
        // C s_5263_3: cast zx s_5263_2 -> bv
        let s_5263_3: Bits = Bits::new(s_5263_2 as u128, 3u16);
        // D s_5263_4: cmp-eq s_5263_1 s_5263_3
        let s_5263_4: bool = ((s_5263_1) == (s_5263_3));
        // D s_5263_5: write-var gs#117874 <= s_5263_4
        fn_state.gs_117874 = s_5263_4;
        // N s_5263_6: jump b735
        return block_735(state, tracer, fn_state);
    }
    fn block_5264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5264_0: read-var coproc:u8
        let s_5264_0: u8 = fn_state.coproc;
        // D s_5264_1: cast zx s_5264_0 -> bv
        let s_5264_1: Bits = Bits::new(s_5264_0 as u128, 4u16);
        // C s_5264_2: const #14u : u8
        let s_5264_2: u8 = 14;
        // C s_5264_3: cast zx s_5264_2 -> bv
        let s_5264_3: Bits = Bits::new(s_5264_2 as u128, 4u16);
        // D s_5264_4: cmp-eq s_5264_1 s_5264_3
        let s_5264_4: bool = ((s_5264_1) == (s_5264_3));
        // D s_5264_5: write-var gs#117873 <= s_5264_4
        fn_state.gs_117873 = s_5264_4;
        // N s_5264_6: jump b733
        return block_733(state, tracer, fn_state);
    }
    fn block_5265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5265_0: read-var CRn:u8
        let s_5265_0: u8 = fn_state.CRn;
        // D s_5265_1: cast zx s_5265_0 -> bv
        let s_5265_1: Bits = Bits::new(s_5265_0 as u128, 4u16);
        // C s_5265_2: const #0u : u8
        let s_5265_2: u8 = 0;
        // C s_5265_3: cast zx s_5265_2 -> bv
        let s_5265_3: Bits = Bits::new(s_5265_2 as u128, 4u16);
        // D s_5265_4: cmp-eq s_5265_1 s_5265_3
        let s_5265_4: bool = ((s_5265_1) == (s_5265_3));
        // D s_5265_5: write-var gs#117872 <= s_5265_4
        fn_state.gs_117872 = s_5265_4;
        // N s_5265_6: jump b731
        return block_731(state, tracer, fn_state);
    }
    fn block_5266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5266_0: read-var el:u8
        let s_5266_0: u8 = fn_state.el;
        // D s_5266_1: read-var coproc:u8
        let s_5266_1: u8 = fn_state.coproc;
        // D s_5266_2: read-var opc1:u8
        let s_5266_2: u8 = fn_state.opc1;
        // D s_5266_3: read-var CRn:u8
        let s_5266_3: u8 = fn_state.CRn;
        // D s_5266_4: read-var opc2:u8
        let s_5266_4: u8 = fn_state.opc2;
        // D s_5266_5: read-var CRm:u8
        let s_5266_5: u8 = fn_state.CRm;
        // D s_5266_6: read-var t:i
        let s_5266_6: i128 = fn_state.t;
        // D s_5266_7: call DBGWVR_SysRegRead32_0f5b4c975d3928f0(s_5266_0, s_5266_1, s_5266_2, s_5266_3, s_5266_4, s_5266_5, s_5266_6)
        let s_5266_7: () = DBGWVR_SysRegRead32_0f5b4c975d3928f0(
            state,
            tracer,
            s_5266_0,
            s_5266_1,
            s_5266_2,
            s_5266_3,
            s_5266_4,
            s_5266_5,
            s_5266_6,
        );
        // N s_5266_8: return
        return;
    }
    fn block_5267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5267_0: read-var opc2:u8
        let s_5267_0: u8 = fn_state.opc2;
        // D s_5267_1: cast zx s_5267_0 -> bv
        let s_5267_1: Bits = Bits::new(s_5267_0 as u128, 3u16);
        // C s_5267_2: const #6u : u8
        let s_5267_2: u8 = 6;
        // C s_5267_3: cast zx s_5267_2 -> bv
        let s_5267_3: Bits = Bits::new(s_5267_2 as u128, 3u16);
        // D s_5267_4: cmp-eq s_5267_1 s_5267_3
        let s_5267_4: bool = ((s_5267_1) == (s_5267_3));
        // D s_5267_5: write-var gs#117871 <= s_5267_4
        fn_state.gs_117871 = s_5267_4;
        // N s_5267_6: jump b728
        return block_728(state, tracer, fn_state);
    }
    fn block_5268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5268_0: read-var opc1:u8
        let s_5268_0: u8 = fn_state.opc1;
        // D s_5268_1: cast zx s_5268_0 -> bv
        let s_5268_1: Bits = Bits::new(s_5268_0 as u128, 3u16);
        // C s_5268_2: const #0u : u8
        let s_5268_2: u8 = 0;
        // C s_5268_3: cast zx s_5268_2 -> bv
        let s_5268_3: Bits = Bits::new(s_5268_2 as u128, 3u16);
        // D s_5268_4: cmp-eq s_5268_1 s_5268_3
        let s_5268_4: bool = ((s_5268_1) == (s_5268_3));
        // D s_5268_5: write-var gs#117870 <= s_5268_4
        fn_state.gs_117870 = s_5268_4;
        // N s_5268_6: jump b726
        return block_726(state, tracer, fn_state);
    }
    fn block_5269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5269_0: read-var coproc:u8
        let s_5269_0: u8 = fn_state.coproc;
        // D s_5269_1: cast zx s_5269_0 -> bv
        let s_5269_1: Bits = Bits::new(s_5269_0 as u128, 4u16);
        // C s_5269_2: const #14u : u8
        let s_5269_2: u8 = 14;
        // C s_5269_3: cast zx s_5269_2 -> bv
        let s_5269_3: Bits = Bits::new(s_5269_2 as u128, 4u16);
        // D s_5269_4: cmp-eq s_5269_1 s_5269_3
        let s_5269_4: bool = ((s_5269_1) == (s_5269_3));
        // D s_5269_5: write-var gs#117869 <= s_5269_4
        fn_state.gs_117869 = s_5269_4;
        // N s_5269_6: jump b724
        return block_724(state, tracer, fn_state);
    }
    fn block_5270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5270_0: read-var CRn:u8
        let s_5270_0: u8 = fn_state.CRn;
        // D s_5270_1: cast zx s_5270_0 -> bv
        let s_5270_1: Bits = Bits::new(s_5270_0 as u128, 4u16);
        // C s_5270_2: const #0u : u8
        let s_5270_2: u8 = 0;
        // C s_5270_3: cast zx s_5270_2 -> bv
        let s_5270_3: Bits = Bits::new(s_5270_2 as u128, 4u16);
        // D s_5270_4: cmp-eq s_5270_1 s_5270_3
        let s_5270_4: bool = ((s_5270_1) == (s_5270_3));
        // D s_5270_5: write-var gs#117868 <= s_5270_4
        fn_state.gs_117868 = s_5270_4;
        // N s_5270_6: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_5271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5271_0: read-var el:u8
        let s_5271_0: u8 = fn_state.el;
        // D s_5271_1: read-var coproc:u8
        let s_5271_1: u8 = fn_state.coproc;
        // D s_5271_2: read-var opc1:u8
        let s_5271_2: u8 = fn_state.opc1;
        // D s_5271_3: read-var CRn:u8
        let s_5271_3: u8 = fn_state.CRn;
        // D s_5271_4: read-var opc2:u8
        let s_5271_4: u8 = fn_state.opc2;
        // D s_5271_5: read-var CRm:u8
        let s_5271_5: u8 = fn_state.CRm;
        // D s_5271_6: read-var t:i
        let s_5271_6: i128 = fn_state.t;
        // D s_5271_7: call DBGWVR_SysRegRead32_00161ecd371e1b48(s_5271_0, s_5271_1, s_5271_2, s_5271_3, s_5271_4, s_5271_5, s_5271_6)
        let s_5271_7: () = DBGWVR_SysRegRead32_00161ecd371e1b48(
            state,
            tracer,
            s_5271_0,
            s_5271_1,
            s_5271_2,
            s_5271_3,
            s_5271_4,
            s_5271_5,
            s_5271_6,
        );
        // N s_5271_8: return
        return;
    }
    fn block_5272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5272_0: read-var opc2:u8
        let s_5272_0: u8 = fn_state.opc2;
        // D s_5272_1: cast zx s_5272_0 -> bv
        let s_5272_1: Bits = Bits::new(s_5272_0 as u128, 3u16);
        // C s_5272_2: const #6u : u8
        let s_5272_2: u8 = 6;
        // C s_5272_3: cast zx s_5272_2 -> bv
        let s_5272_3: Bits = Bits::new(s_5272_2 as u128, 3u16);
        // D s_5272_4: cmp-eq s_5272_1 s_5272_3
        let s_5272_4: bool = ((s_5272_1) == (s_5272_3));
        // D s_5272_5: write-var gs#117867 <= s_5272_4
        fn_state.gs_117867 = s_5272_4;
        // N s_5272_6: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_5273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5273_0: read-var opc1:u8
        let s_5273_0: u8 = fn_state.opc1;
        // D s_5273_1: cast zx s_5273_0 -> bv
        let s_5273_1: Bits = Bits::new(s_5273_0 as u128, 3u16);
        // C s_5273_2: const #0u : u8
        let s_5273_2: u8 = 0;
        // C s_5273_3: cast zx s_5273_2 -> bv
        let s_5273_3: Bits = Bits::new(s_5273_2 as u128, 3u16);
        // D s_5273_4: cmp-eq s_5273_1 s_5273_3
        let s_5273_4: bool = ((s_5273_1) == (s_5273_3));
        // D s_5273_5: write-var gs#117866 <= s_5273_4
        fn_state.gs_117866 = s_5273_4;
        // N s_5273_6: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_5274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5274_0: read-var coproc:u8
        let s_5274_0: u8 = fn_state.coproc;
        // D s_5274_1: cast zx s_5274_0 -> bv
        let s_5274_1: Bits = Bits::new(s_5274_0 as u128, 4u16);
        // C s_5274_2: const #14u : u8
        let s_5274_2: u8 = 14;
        // C s_5274_3: cast zx s_5274_2 -> bv
        let s_5274_3: Bits = Bits::new(s_5274_2 as u128, 4u16);
        // D s_5274_4: cmp-eq s_5274_1 s_5274_3
        let s_5274_4: bool = ((s_5274_1) == (s_5274_3));
        // D s_5274_5: write-var gs#117865 <= s_5274_4
        fn_state.gs_117865 = s_5274_4;
        // N s_5274_6: jump b715
        return block_715(state, tracer, fn_state);
    }
    fn block_5275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5275_0: read-var CRn:u8
        let s_5275_0: u8 = fn_state.CRn;
        // D s_5275_1: cast zx s_5275_0 -> bv
        let s_5275_1: Bits = Bits::new(s_5275_0 as u128, 4u16);
        // C s_5275_2: const #0u : u8
        let s_5275_2: u8 = 0;
        // C s_5275_3: cast zx s_5275_2 -> bv
        let s_5275_3: Bits = Bits::new(s_5275_2 as u128, 4u16);
        // D s_5275_4: cmp-eq s_5275_1 s_5275_3
        let s_5275_4: bool = ((s_5275_1) == (s_5275_3));
        // D s_5275_5: write-var gs#117864 <= s_5275_4
        fn_state.gs_117864 = s_5275_4;
        // N s_5275_6: jump b713
        return block_713(state, tracer, fn_state);
    }
    fn block_5276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5276_0: read-var el:u8
        let s_5276_0: u8 = fn_state.el;
        // D s_5276_1: read-var coproc:u8
        let s_5276_1: u8 = fn_state.coproc;
        // D s_5276_2: read-var opc1:u8
        let s_5276_2: u8 = fn_state.opc1;
        // D s_5276_3: read-var CRn:u8
        let s_5276_3: u8 = fn_state.CRn;
        // D s_5276_4: read-var opc2:u8
        let s_5276_4: u8 = fn_state.opc2;
        // D s_5276_5: read-var CRm:u8
        let s_5276_5: u8 = fn_state.CRm;
        // D s_5276_6: read-var t:i
        let s_5276_6: i128 = fn_state.t;
        // D s_5276_7: call DBGWVR_SysRegRead32_a8d1c2ea29be76f1(s_5276_0, s_5276_1, s_5276_2, s_5276_3, s_5276_4, s_5276_5, s_5276_6)
        let s_5276_7: () = DBGWVR_SysRegRead32_a8d1c2ea29be76f1(
            state,
            tracer,
            s_5276_0,
            s_5276_1,
            s_5276_2,
            s_5276_3,
            s_5276_4,
            s_5276_5,
            s_5276_6,
        );
        // N s_5276_8: return
        return;
    }
    fn block_5277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5277_0: read-var opc2:u8
        let s_5277_0: u8 = fn_state.opc2;
        // D s_5277_1: cast zx s_5277_0 -> bv
        let s_5277_1: Bits = Bits::new(s_5277_0 as u128, 3u16);
        // C s_5277_2: const #6u : u8
        let s_5277_2: u8 = 6;
        // C s_5277_3: cast zx s_5277_2 -> bv
        let s_5277_3: Bits = Bits::new(s_5277_2 as u128, 3u16);
        // D s_5277_4: cmp-eq s_5277_1 s_5277_3
        let s_5277_4: bool = ((s_5277_1) == (s_5277_3));
        // D s_5277_5: write-var gs#117863 <= s_5277_4
        fn_state.gs_117863 = s_5277_4;
        // N s_5277_6: jump b710
        return block_710(state, tracer, fn_state);
    }
    fn block_5278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5278_0: read-var opc1:u8
        let s_5278_0: u8 = fn_state.opc1;
        // D s_5278_1: cast zx s_5278_0 -> bv
        let s_5278_1: Bits = Bits::new(s_5278_0 as u128, 3u16);
        // C s_5278_2: const #0u : u8
        let s_5278_2: u8 = 0;
        // C s_5278_3: cast zx s_5278_2 -> bv
        let s_5278_3: Bits = Bits::new(s_5278_2 as u128, 3u16);
        // D s_5278_4: cmp-eq s_5278_1 s_5278_3
        let s_5278_4: bool = ((s_5278_1) == (s_5278_3));
        // D s_5278_5: write-var gs#117862 <= s_5278_4
        fn_state.gs_117862 = s_5278_4;
        // N s_5278_6: jump b708
        return block_708(state, tracer, fn_state);
    }
    fn block_5279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5279_0: read-var coproc:u8
        let s_5279_0: u8 = fn_state.coproc;
        // D s_5279_1: cast zx s_5279_0 -> bv
        let s_5279_1: Bits = Bits::new(s_5279_0 as u128, 4u16);
        // C s_5279_2: const #14u : u8
        let s_5279_2: u8 = 14;
        // C s_5279_3: cast zx s_5279_2 -> bv
        let s_5279_3: Bits = Bits::new(s_5279_2 as u128, 4u16);
        // D s_5279_4: cmp-eq s_5279_1 s_5279_3
        let s_5279_4: bool = ((s_5279_1) == (s_5279_3));
        // D s_5279_5: write-var gs#117861 <= s_5279_4
        fn_state.gs_117861 = s_5279_4;
        // N s_5279_6: jump b706
        return block_706(state, tracer, fn_state);
    }
    fn block_5280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5280_0: read-var CRn:u8
        let s_5280_0: u8 = fn_state.CRn;
        // D s_5280_1: cast zx s_5280_0 -> bv
        let s_5280_1: Bits = Bits::new(s_5280_0 as u128, 4u16);
        // C s_5280_2: const #0u : u8
        let s_5280_2: u8 = 0;
        // C s_5280_3: cast zx s_5280_2 -> bv
        let s_5280_3: Bits = Bits::new(s_5280_2 as u128, 4u16);
        // D s_5280_4: cmp-eq s_5280_1 s_5280_3
        let s_5280_4: bool = ((s_5280_1) == (s_5280_3));
        // D s_5280_5: write-var gs#117860 <= s_5280_4
        fn_state.gs_117860 = s_5280_4;
        // N s_5280_6: jump b704
        return block_704(state, tracer, fn_state);
    }
    fn block_5281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5281_0: read-var el:u8
        let s_5281_0: u8 = fn_state.el;
        // D s_5281_1: read-var coproc:u8
        let s_5281_1: u8 = fn_state.coproc;
        // D s_5281_2: read-var opc1:u8
        let s_5281_2: u8 = fn_state.opc1;
        // D s_5281_3: read-var CRn:u8
        let s_5281_3: u8 = fn_state.CRn;
        // D s_5281_4: read-var opc2:u8
        let s_5281_4: u8 = fn_state.opc2;
        // D s_5281_5: read-var CRm:u8
        let s_5281_5: u8 = fn_state.CRm;
        // D s_5281_6: read-var t:i
        let s_5281_6: i128 = fn_state.t;
        // D s_5281_7: call DBGWVR_SysRegRead32_672b3a4673cc16b1(s_5281_0, s_5281_1, s_5281_2, s_5281_3, s_5281_4, s_5281_5, s_5281_6)
        let s_5281_7: () = DBGWVR_SysRegRead32_672b3a4673cc16b1(
            state,
            tracer,
            s_5281_0,
            s_5281_1,
            s_5281_2,
            s_5281_3,
            s_5281_4,
            s_5281_5,
            s_5281_6,
        );
        // N s_5281_8: return
        return;
    }
    fn block_5282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5282_0: read-var opc2:u8
        let s_5282_0: u8 = fn_state.opc2;
        // D s_5282_1: cast zx s_5282_0 -> bv
        let s_5282_1: Bits = Bits::new(s_5282_0 as u128, 3u16);
        // C s_5282_2: const #6u : u8
        let s_5282_2: u8 = 6;
        // C s_5282_3: cast zx s_5282_2 -> bv
        let s_5282_3: Bits = Bits::new(s_5282_2 as u128, 3u16);
        // D s_5282_4: cmp-eq s_5282_1 s_5282_3
        let s_5282_4: bool = ((s_5282_1) == (s_5282_3));
        // D s_5282_5: write-var gs#117859 <= s_5282_4
        fn_state.gs_117859 = s_5282_4;
        // N s_5282_6: jump b701
        return block_701(state, tracer, fn_state);
    }
    fn block_5283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5283_0: read-var opc1:u8
        let s_5283_0: u8 = fn_state.opc1;
        // D s_5283_1: cast zx s_5283_0 -> bv
        let s_5283_1: Bits = Bits::new(s_5283_0 as u128, 3u16);
        // C s_5283_2: const #0u : u8
        let s_5283_2: u8 = 0;
        // C s_5283_3: cast zx s_5283_2 -> bv
        let s_5283_3: Bits = Bits::new(s_5283_2 as u128, 3u16);
        // D s_5283_4: cmp-eq s_5283_1 s_5283_3
        let s_5283_4: bool = ((s_5283_1) == (s_5283_3));
        // D s_5283_5: write-var gs#117858 <= s_5283_4
        fn_state.gs_117858 = s_5283_4;
        // N s_5283_6: jump b699
        return block_699(state, tracer, fn_state);
    }
    fn block_5284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5284_0: read-var coproc:u8
        let s_5284_0: u8 = fn_state.coproc;
        // D s_5284_1: cast zx s_5284_0 -> bv
        let s_5284_1: Bits = Bits::new(s_5284_0 as u128, 4u16);
        // C s_5284_2: const #14u : u8
        let s_5284_2: u8 = 14;
        // C s_5284_3: cast zx s_5284_2 -> bv
        let s_5284_3: Bits = Bits::new(s_5284_2 as u128, 4u16);
        // D s_5284_4: cmp-eq s_5284_1 s_5284_3
        let s_5284_4: bool = ((s_5284_1) == (s_5284_3));
        // D s_5284_5: write-var gs#117857 <= s_5284_4
        fn_state.gs_117857 = s_5284_4;
        // N s_5284_6: jump b697
        return block_697(state, tracer, fn_state);
    }
    fn block_5285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5285_0: read-var CRn:u8
        let s_5285_0: u8 = fn_state.CRn;
        // D s_5285_1: cast zx s_5285_0 -> bv
        let s_5285_1: Bits = Bits::new(s_5285_0 as u128, 4u16);
        // C s_5285_2: const #0u : u8
        let s_5285_2: u8 = 0;
        // C s_5285_3: cast zx s_5285_2 -> bv
        let s_5285_3: Bits = Bits::new(s_5285_2 as u128, 4u16);
        // D s_5285_4: cmp-eq s_5285_1 s_5285_3
        let s_5285_4: bool = ((s_5285_1) == (s_5285_3));
        // D s_5285_5: write-var gs#117856 <= s_5285_4
        fn_state.gs_117856 = s_5285_4;
        // N s_5285_6: jump b695
        return block_695(state, tracer, fn_state);
    }
    fn block_5286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5286_0: read-var el:u8
        let s_5286_0: u8 = fn_state.el;
        // D s_5286_1: read-var coproc:u8
        let s_5286_1: u8 = fn_state.coproc;
        // D s_5286_2: read-var opc1:u8
        let s_5286_2: u8 = fn_state.opc1;
        // D s_5286_3: read-var CRn:u8
        let s_5286_3: u8 = fn_state.CRn;
        // D s_5286_4: read-var opc2:u8
        let s_5286_4: u8 = fn_state.opc2;
        // D s_5286_5: read-var CRm:u8
        let s_5286_5: u8 = fn_state.CRm;
        // D s_5286_6: read-var t:i
        let s_5286_6: i128 = fn_state.t;
        // D s_5286_7: call DBGWVR_SysRegRead32_2e5f3331ba566316(s_5286_0, s_5286_1, s_5286_2, s_5286_3, s_5286_4, s_5286_5, s_5286_6)
        let s_5286_7: () = DBGWVR_SysRegRead32_2e5f3331ba566316(
            state,
            tracer,
            s_5286_0,
            s_5286_1,
            s_5286_2,
            s_5286_3,
            s_5286_4,
            s_5286_5,
            s_5286_6,
        );
        // N s_5286_8: return
        return;
    }
    fn block_5287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5287_0: read-var opc2:u8
        let s_5287_0: u8 = fn_state.opc2;
        // D s_5287_1: cast zx s_5287_0 -> bv
        let s_5287_1: Bits = Bits::new(s_5287_0 as u128, 3u16);
        // C s_5287_2: const #6u : u8
        let s_5287_2: u8 = 6;
        // C s_5287_3: cast zx s_5287_2 -> bv
        let s_5287_3: Bits = Bits::new(s_5287_2 as u128, 3u16);
        // D s_5287_4: cmp-eq s_5287_1 s_5287_3
        let s_5287_4: bool = ((s_5287_1) == (s_5287_3));
        // D s_5287_5: write-var gs#117855 <= s_5287_4
        fn_state.gs_117855 = s_5287_4;
        // N s_5287_6: jump b692
        return block_692(state, tracer, fn_state);
    }
    fn block_5288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5288_0: read-var opc1:u8
        let s_5288_0: u8 = fn_state.opc1;
        // D s_5288_1: cast zx s_5288_0 -> bv
        let s_5288_1: Bits = Bits::new(s_5288_0 as u128, 3u16);
        // C s_5288_2: const #0u : u8
        let s_5288_2: u8 = 0;
        // C s_5288_3: cast zx s_5288_2 -> bv
        let s_5288_3: Bits = Bits::new(s_5288_2 as u128, 3u16);
        // D s_5288_4: cmp-eq s_5288_1 s_5288_3
        let s_5288_4: bool = ((s_5288_1) == (s_5288_3));
        // D s_5288_5: write-var gs#117854 <= s_5288_4
        fn_state.gs_117854 = s_5288_4;
        // N s_5288_6: jump b690
        return block_690(state, tracer, fn_state);
    }
    fn block_5289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5289_0: read-var coproc:u8
        let s_5289_0: u8 = fn_state.coproc;
        // D s_5289_1: cast zx s_5289_0 -> bv
        let s_5289_1: Bits = Bits::new(s_5289_0 as u128, 4u16);
        // C s_5289_2: const #14u : u8
        let s_5289_2: u8 = 14;
        // C s_5289_3: cast zx s_5289_2 -> bv
        let s_5289_3: Bits = Bits::new(s_5289_2 as u128, 4u16);
        // D s_5289_4: cmp-eq s_5289_1 s_5289_3
        let s_5289_4: bool = ((s_5289_1) == (s_5289_3));
        // D s_5289_5: write-var gs#117853 <= s_5289_4
        fn_state.gs_117853 = s_5289_4;
        // N s_5289_6: jump b688
        return block_688(state, tracer, fn_state);
    }
    fn block_5290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5290_0: read-var CRn:u8
        let s_5290_0: u8 = fn_state.CRn;
        // D s_5290_1: cast zx s_5290_0 -> bv
        let s_5290_1: Bits = Bits::new(s_5290_0 as u128, 4u16);
        // C s_5290_2: const #0u : u8
        let s_5290_2: u8 = 0;
        // C s_5290_3: cast zx s_5290_2 -> bv
        let s_5290_3: Bits = Bits::new(s_5290_2 as u128, 4u16);
        // D s_5290_4: cmp-eq s_5290_1 s_5290_3
        let s_5290_4: bool = ((s_5290_1) == (s_5290_3));
        // D s_5290_5: write-var gs#117852 <= s_5290_4
        fn_state.gs_117852 = s_5290_4;
        // N s_5290_6: jump b686
        return block_686(state, tracer, fn_state);
    }
    fn block_5291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5291_0: read-var el:u8
        let s_5291_0: u8 = fn_state.el;
        // D s_5291_1: read-var coproc:u8
        let s_5291_1: u8 = fn_state.coproc;
        // D s_5291_2: read-var opc1:u8
        let s_5291_2: u8 = fn_state.opc1;
        // D s_5291_3: read-var CRn:u8
        let s_5291_3: u8 = fn_state.CRn;
        // D s_5291_4: read-var opc2:u8
        let s_5291_4: u8 = fn_state.opc2;
        // D s_5291_5: read-var CRm:u8
        let s_5291_5: u8 = fn_state.CRm;
        // D s_5291_6: read-var t:i
        let s_5291_6: i128 = fn_state.t;
        // D s_5291_7: call DBGWVR_SysRegRead32_9fd65afd85a62538(s_5291_0, s_5291_1, s_5291_2, s_5291_3, s_5291_4, s_5291_5, s_5291_6)
        let s_5291_7: () = DBGWVR_SysRegRead32_9fd65afd85a62538(
            state,
            tracer,
            s_5291_0,
            s_5291_1,
            s_5291_2,
            s_5291_3,
            s_5291_4,
            s_5291_5,
            s_5291_6,
        );
        // N s_5291_8: return
        return;
    }
    fn block_5292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5292_0: read-var opc2:u8
        let s_5292_0: u8 = fn_state.opc2;
        // D s_5292_1: cast zx s_5292_0 -> bv
        let s_5292_1: Bits = Bits::new(s_5292_0 as u128, 3u16);
        // C s_5292_2: const #6u : u8
        let s_5292_2: u8 = 6;
        // C s_5292_3: cast zx s_5292_2 -> bv
        let s_5292_3: Bits = Bits::new(s_5292_2 as u128, 3u16);
        // D s_5292_4: cmp-eq s_5292_1 s_5292_3
        let s_5292_4: bool = ((s_5292_1) == (s_5292_3));
        // D s_5292_5: write-var gs#117851 <= s_5292_4
        fn_state.gs_117851 = s_5292_4;
        // N s_5292_6: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_5293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5293_0: read-var opc1:u8
        let s_5293_0: u8 = fn_state.opc1;
        // D s_5293_1: cast zx s_5293_0 -> bv
        let s_5293_1: Bits = Bits::new(s_5293_0 as u128, 3u16);
        // C s_5293_2: const #0u : u8
        let s_5293_2: u8 = 0;
        // C s_5293_3: cast zx s_5293_2 -> bv
        let s_5293_3: Bits = Bits::new(s_5293_2 as u128, 3u16);
        // D s_5293_4: cmp-eq s_5293_1 s_5293_3
        let s_5293_4: bool = ((s_5293_1) == (s_5293_3));
        // D s_5293_5: write-var gs#117850 <= s_5293_4
        fn_state.gs_117850 = s_5293_4;
        // N s_5293_6: jump b681
        return block_681(state, tracer, fn_state);
    }
    fn block_5294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5294_0: read-var coproc:u8
        let s_5294_0: u8 = fn_state.coproc;
        // D s_5294_1: cast zx s_5294_0 -> bv
        let s_5294_1: Bits = Bits::new(s_5294_0 as u128, 4u16);
        // C s_5294_2: const #14u : u8
        let s_5294_2: u8 = 14;
        // C s_5294_3: cast zx s_5294_2 -> bv
        let s_5294_3: Bits = Bits::new(s_5294_2 as u128, 4u16);
        // D s_5294_4: cmp-eq s_5294_1 s_5294_3
        let s_5294_4: bool = ((s_5294_1) == (s_5294_3));
        // D s_5294_5: write-var gs#117849 <= s_5294_4
        fn_state.gs_117849 = s_5294_4;
        // N s_5294_6: jump b679
        return block_679(state, tracer, fn_state);
    }
    fn block_5295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5295_0: read-var CRn:u8
        let s_5295_0: u8 = fn_state.CRn;
        // D s_5295_1: cast zx s_5295_0 -> bv
        let s_5295_1: Bits = Bits::new(s_5295_0 as u128, 4u16);
        // C s_5295_2: const #0u : u8
        let s_5295_2: u8 = 0;
        // C s_5295_3: cast zx s_5295_2 -> bv
        let s_5295_3: Bits = Bits::new(s_5295_2 as u128, 4u16);
        // D s_5295_4: cmp-eq s_5295_1 s_5295_3
        let s_5295_4: bool = ((s_5295_1) == (s_5295_3));
        // D s_5295_5: write-var gs#117848 <= s_5295_4
        fn_state.gs_117848 = s_5295_4;
        // N s_5295_6: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_5296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5296_0: read-var el:u8
        let s_5296_0: u8 = fn_state.el;
        // D s_5296_1: read-var coproc:u8
        let s_5296_1: u8 = fn_state.coproc;
        // D s_5296_2: read-var opc1:u8
        let s_5296_2: u8 = fn_state.opc1;
        // D s_5296_3: read-var CRn:u8
        let s_5296_3: u8 = fn_state.CRn;
        // D s_5296_4: read-var opc2:u8
        let s_5296_4: u8 = fn_state.opc2;
        // D s_5296_5: read-var CRm:u8
        let s_5296_5: u8 = fn_state.CRm;
        // D s_5296_6: read-var t:i
        let s_5296_6: i128 = fn_state.t;
        // D s_5296_7: call DBGWVR_SysRegRead32_b4df3a7002c9f7a0(s_5296_0, s_5296_1, s_5296_2, s_5296_3, s_5296_4, s_5296_5, s_5296_6)
        let s_5296_7: () = DBGWVR_SysRegRead32_b4df3a7002c9f7a0(
            state,
            tracer,
            s_5296_0,
            s_5296_1,
            s_5296_2,
            s_5296_3,
            s_5296_4,
            s_5296_5,
            s_5296_6,
        );
        // N s_5296_8: return
        return;
    }
    fn block_5297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5297_0: read-var opc2:u8
        let s_5297_0: u8 = fn_state.opc2;
        // D s_5297_1: cast zx s_5297_0 -> bv
        let s_5297_1: Bits = Bits::new(s_5297_0 as u128, 3u16);
        // C s_5297_2: const #6u : u8
        let s_5297_2: u8 = 6;
        // C s_5297_3: cast zx s_5297_2 -> bv
        let s_5297_3: Bits = Bits::new(s_5297_2 as u128, 3u16);
        // D s_5297_4: cmp-eq s_5297_1 s_5297_3
        let s_5297_4: bool = ((s_5297_1) == (s_5297_3));
        // D s_5297_5: write-var gs#117847 <= s_5297_4
        fn_state.gs_117847 = s_5297_4;
        // N s_5297_6: jump b674
        return block_674(state, tracer, fn_state);
    }
    fn block_5298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5298_0: read-var opc1:u8
        let s_5298_0: u8 = fn_state.opc1;
        // D s_5298_1: cast zx s_5298_0 -> bv
        let s_5298_1: Bits = Bits::new(s_5298_0 as u128, 3u16);
        // C s_5298_2: const #0u : u8
        let s_5298_2: u8 = 0;
        // C s_5298_3: cast zx s_5298_2 -> bv
        let s_5298_3: Bits = Bits::new(s_5298_2 as u128, 3u16);
        // D s_5298_4: cmp-eq s_5298_1 s_5298_3
        let s_5298_4: bool = ((s_5298_1) == (s_5298_3));
        // D s_5298_5: write-var gs#117846 <= s_5298_4
        fn_state.gs_117846 = s_5298_4;
        // N s_5298_6: jump b672
        return block_672(state, tracer, fn_state);
    }
    fn block_5299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5299_0: read-var coproc:u8
        let s_5299_0: u8 = fn_state.coproc;
        // D s_5299_1: cast zx s_5299_0 -> bv
        let s_5299_1: Bits = Bits::new(s_5299_0 as u128, 4u16);
        // C s_5299_2: const #14u : u8
        let s_5299_2: u8 = 14;
        // C s_5299_3: cast zx s_5299_2 -> bv
        let s_5299_3: Bits = Bits::new(s_5299_2 as u128, 4u16);
        // D s_5299_4: cmp-eq s_5299_1 s_5299_3
        let s_5299_4: bool = ((s_5299_1) == (s_5299_3));
        // D s_5299_5: write-var gs#117845 <= s_5299_4
        fn_state.gs_117845 = s_5299_4;
        // N s_5299_6: jump b670
        return block_670(state, tracer, fn_state);
    }
    fn block_5300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5300_0: read-var CRn:u8
        let s_5300_0: u8 = fn_state.CRn;
        // D s_5300_1: cast zx s_5300_0 -> bv
        let s_5300_1: Bits = Bits::new(s_5300_0 as u128, 4u16);
        // C s_5300_2: const #0u : u8
        let s_5300_2: u8 = 0;
        // C s_5300_3: cast zx s_5300_2 -> bv
        let s_5300_3: Bits = Bits::new(s_5300_2 as u128, 4u16);
        // D s_5300_4: cmp-eq s_5300_1 s_5300_3
        let s_5300_4: bool = ((s_5300_1) == (s_5300_3));
        // D s_5300_5: write-var gs#117844 <= s_5300_4
        fn_state.gs_117844 = s_5300_4;
        // N s_5300_6: jump b668
        return block_668(state, tracer, fn_state);
    }
    fn block_5301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5301_0: read-var el:u8
        let s_5301_0: u8 = fn_state.el;
        // D s_5301_1: read-var coproc:u8
        let s_5301_1: u8 = fn_state.coproc;
        // D s_5301_2: read-var opc1:u8
        let s_5301_2: u8 = fn_state.opc1;
        // D s_5301_3: read-var CRn:u8
        let s_5301_3: u8 = fn_state.CRn;
        // D s_5301_4: read-var opc2:u8
        let s_5301_4: u8 = fn_state.opc2;
        // D s_5301_5: read-var CRm:u8
        let s_5301_5: u8 = fn_state.CRm;
        // D s_5301_6: read-var t:i
        let s_5301_6: i128 = fn_state.t;
        // D s_5301_7: call DBGWVR_SysRegRead32_de66eaaa5ee8659b(s_5301_0, s_5301_1, s_5301_2, s_5301_3, s_5301_4, s_5301_5, s_5301_6)
        let s_5301_7: () = DBGWVR_SysRegRead32_de66eaaa5ee8659b(
            state,
            tracer,
            s_5301_0,
            s_5301_1,
            s_5301_2,
            s_5301_3,
            s_5301_4,
            s_5301_5,
            s_5301_6,
        );
        // N s_5301_8: return
        return;
    }
    fn block_5302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5302_0: read-var opc2:u8
        let s_5302_0: u8 = fn_state.opc2;
        // D s_5302_1: cast zx s_5302_0 -> bv
        let s_5302_1: Bits = Bits::new(s_5302_0 as u128, 3u16);
        // C s_5302_2: const #6u : u8
        let s_5302_2: u8 = 6;
        // C s_5302_3: cast zx s_5302_2 -> bv
        let s_5302_3: Bits = Bits::new(s_5302_2 as u128, 3u16);
        // D s_5302_4: cmp-eq s_5302_1 s_5302_3
        let s_5302_4: bool = ((s_5302_1) == (s_5302_3));
        // D s_5302_5: write-var gs#117843 <= s_5302_4
        fn_state.gs_117843 = s_5302_4;
        // N s_5302_6: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_5303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5303_0: read-var opc1:u8
        let s_5303_0: u8 = fn_state.opc1;
        // D s_5303_1: cast zx s_5303_0 -> bv
        let s_5303_1: Bits = Bits::new(s_5303_0 as u128, 3u16);
        // C s_5303_2: const #0u : u8
        let s_5303_2: u8 = 0;
        // C s_5303_3: cast zx s_5303_2 -> bv
        let s_5303_3: Bits = Bits::new(s_5303_2 as u128, 3u16);
        // D s_5303_4: cmp-eq s_5303_1 s_5303_3
        let s_5303_4: bool = ((s_5303_1) == (s_5303_3));
        // D s_5303_5: write-var gs#117842 <= s_5303_4
        fn_state.gs_117842 = s_5303_4;
        // N s_5303_6: jump b663
        return block_663(state, tracer, fn_state);
    }
    fn block_5304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5304_0: read-var coproc:u8
        let s_5304_0: u8 = fn_state.coproc;
        // D s_5304_1: cast zx s_5304_0 -> bv
        let s_5304_1: Bits = Bits::new(s_5304_0 as u128, 4u16);
        // C s_5304_2: const #14u : u8
        let s_5304_2: u8 = 14;
        // C s_5304_3: cast zx s_5304_2 -> bv
        let s_5304_3: Bits = Bits::new(s_5304_2 as u128, 4u16);
        // D s_5304_4: cmp-eq s_5304_1 s_5304_3
        let s_5304_4: bool = ((s_5304_1) == (s_5304_3));
        // D s_5304_5: write-var gs#117841 <= s_5304_4
        fn_state.gs_117841 = s_5304_4;
        // N s_5304_6: jump b661
        return block_661(state, tracer, fn_state);
    }
    fn block_5305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5305_0: read-var CRn:u8
        let s_5305_0: u8 = fn_state.CRn;
        // D s_5305_1: cast zx s_5305_0 -> bv
        let s_5305_1: Bits = Bits::new(s_5305_0 as u128, 4u16);
        // C s_5305_2: const #0u : u8
        let s_5305_2: u8 = 0;
        // C s_5305_3: cast zx s_5305_2 -> bv
        let s_5305_3: Bits = Bits::new(s_5305_2 as u128, 4u16);
        // D s_5305_4: cmp-eq s_5305_1 s_5305_3
        let s_5305_4: bool = ((s_5305_1) == (s_5305_3));
        // D s_5305_5: write-var gs#117840 <= s_5305_4
        fn_state.gs_117840 = s_5305_4;
        // N s_5305_6: jump b659
        return block_659(state, tracer, fn_state);
    }
    fn block_5306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5306_0: read-var el:u8
        let s_5306_0: u8 = fn_state.el;
        // D s_5306_1: read-var coproc:u8
        let s_5306_1: u8 = fn_state.coproc;
        // D s_5306_2: read-var opc1:u8
        let s_5306_2: u8 = fn_state.opc1;
        // D s_5306_3: read-var CRn:u8
        let s_5306_3: u8 = fn_state.CRn;
        // D s_5306_4: read-var opc2:u8
        let s_5306_4: u8 = fn_state.opc2;
        // D s_5306_5: read-var CRm:u8
        let s_5306_5: u8 = fn_state.CRm;
        // D s_5306_6: read-var t:i
        let s_5306_6: i128 = fn_state.t;
        // D s_5306_7: call TCMTR_SysRegRead32_88195aa504d1c43a(s_5306_0, s_5306_1, s_5306_2, s_5306_3, s_5306_4, s_5306_5, s_5306_6)
        let s_5306_7: () = TCMTR_SysRegRead32_88195aa504d1c43a(
            state,
            tracer,
            s_5306_0,
            s_5306_1,
            s_5306_2,
            s_5306_3,
            s_5306_4,
            s_5306_5,
            s_5306_6,
        );
        // N s_5306_8: return
        return;
    }
    fn block_5307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5307_0: read-var opc2:u8
        let s_5307_0: u8 = fn_state.opc2;
        // D s_5307_1: cast zx s_5307_0 -> bv
        let s_5307_1: Bits = Bits::new(s_5307_0 as u128, 3u16);
        // C s_5307_2: const #2u : u8
        let s_5307_2: u8 = 2;
        // C s_5307_3: cast zx s_5307_2 -> bv
        let s_5307_3: Bits = Bits::new(s_5307_2 as u128, 3u16);
        // D s_5307_4: cmp-eq s_5307_1 s_5307_3
        let s_5307_4: bool = ((s_5307_1) == (s_5307_3));
        // D s_5307_5: write-var gs#117839 <= s_5307_4
        fn_state.gs_117839 = s_5307_4;
        // N s_5307_6: jump b656
        return block_656(state, tracer, fn_state);
    }
    fn block_5308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5308_0: read-var opc1:u8
        let s_5308_0: u8 = fn_state.opc1;
        // D s_5308_1: cast zx s_5308_0 -> bv
        let s_5308_1: Bits = Bits::new(s_5308_0 as u128, 3u16);
        // C s_5308_2: const #0u : u8
        let s_5308_2: u8 = 0;
        // C s_5308_3: cast zx s_5308_2 -> bv
        let s_5308_3: Bits = Bits::new(s_5308_2 as u128, 3u16);
        // D s_5308_4: cmp-eq s_5308_1 s_5308_3
        let s_5308_4: bool = ((s_5308_1) == (s_5308_3));
        // D s_5308_5: write-var gs#117838 <= s_5308_4
        fn_state.gs_117838 = s_5308_4;
        // N s_5308_6: jump b654
        return block_654(state, tracer, fn_state);
    }
    fn block_5309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5309_0: read-var coproc:u8
        let s_5309_0: u8 = fn_state.coproc;
        // D s_5309_1: cast zx s_5309_0 -> bv
        let s_5309_1: Bits = Bits::new(s_5309_0 as u128, 4u16);
        // C s_5309_2: const #15u : u8
        let s_5309_2: u8 = 15;
        // C s_5309_3: cast zx s_5309_2 -> bv
        let s_5309_3: Bits = Bits::new(s_5309_2 as u128, 4u16);
        // D s_5309_4: cmp-eq s_5309_1 s_5309_3
        let s_5309_4: bool = ((s_5309_1) == (s_5309_3));
        // D s_5309_5: write-var gs#117837 <= s_5309_4
        fn_state.gs_117837 = s_5309_4;
        // N s_5309_6: jump b652
        return block_652(state, tracer, fn_state);
    }
    fn block_5310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5310_0: read-var CRn:u8
        let s_5310_0: u8 = fn_state.CRn;
        // D s_5310_1: cast zx s_5310_0 -> bv
        let s_5310_1: Bits = Bits::new(s_5310_0 as u128, 4u16);
        // C s_5310_2: const #0u : u8
        let s_5310_2: u8 = 0;
        // C s_5310_3: cast zx s_5310_2 -> bv
        let s_5310_3: Bits = Bits::new(s_5310_2 as u128, 4u16);
        // D s_5310_4: cmp-eq s_5310_1 s_5310_3
        let s_5310_4: bool = ((s_5310_1) == (s_5310_3));
        // D s_5310_5: write-var gs#117836 <= s_5310_4
        fn_state.gs_117836 = s_5310_4;
        // N s_5310_6: jump b650
        return block_650(state, tracer, fn_state);
    }
    fn block_5311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5311_0: read-var el:u8
        let s_5311_0: u8 = fn_state.el;
        // D s_5311_1: read-var coproc:u8
        let s_5311_1: u8 = fn_state.coproc;
        // D s_5311_2: read-var opc1:u8
        let s_5311_2: u8 = fn_state.opc1;
        // D s_5311_3: read-var CRn:u8
        let s_5311_3: u8 = fn_state.CRn;
        // D s_5311_4: read-var opc2:u8
        let s_5311_4: u8 = fn_state.opc2;
        // D s_5311_5: read-var CRm:u8
        let s_5311_5: u8 = fn_state.CRm;
        // D s_5311_6: read-var t:i
        let s_5311_6: i128 = fn_state.t;
        // D s_5311_7: call DBGCLAIMCLR_SysRegRead32_42a543613e49cb33(s_5311_0, s_5311_1, s_5311_2, s_5311_3, s_5311_4, s_5311_5, s_5311_6)
        let s_5311_7: () = DBGCLAIMCLR_SysRegRead32_42a543613e49cb33(
            state,
            tracer,
            s_5311_0,
            s_5311_1,
            s_5311_2,
            s_5311_3,
            s_5311_4,
            s_5311_5,
            s_5311_6,
        );
        // N s_5311_8: return
        return;
    }
    fn block_5312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5312_0: read-var opc2:u8
        let s_5312_0: u8 = fn_state.opc2;
        // D s_5312_1: cast zx s_5312_0 -> bv
        let s_5312_1: Bits = Bits::new(s_5312_0 as u128, 3u16);
        // C s_5312_2: const #6u : u8
        let s_5312_2: u8 = 6;
        // C s_5312_3: cast zx s_5312_2 -> bv
        let s_5312_3: Bits = Bits::new(s_5312_2 as u128, 3u16);
        // D s_5312_4: cmp-eq s_5312_1 s_5312_3
        let s_5312_4: bool = ((s_5312_1) == (s_5312_3));
        // D s_5312_5: write-var gs#117835 <= s_5312_4
        fn_state.gs_117835 = s_5312_4;
        // N s_5312_6: jump b647
        return block_647(state, tracer, fn_state);
    }
    fn block_5313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5313_0: read-var opc1:u8
        let s_5313_0: u8 = fn_state.opc1;
        // D s_5313_1: cast zx s_5313_0 -> bv
        let s_5313_1: Bits = Bits::new(s_5313_0 as u128, 3u16);
        // C s_5313_2: const #0u : u8
        let s_5313_2: u8 = 0;
        // C s_5313_3: cast zx s_5313_2 -> bv
        let s_5313_3: Bits = Bits::new(s_5313_2 as u128, 3u16);
        // D s_5313_4: cmp-eq s_5313_1 s_5313_3
        let s_5313_4: bool = ((s_5313_1) == (s_5313_3));
        // D s_5313_5: write-var gs#117834 <= s_5313_4
        fn_state.gs_117834 = s_5313_4;
        // N s_5313_6: jump b645
        return block_645(state, tracer, fn_state);
    }
    fn block_5314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5314_0: read-var coproc:u8
        let s_5314_0: u8 = fn_state.coproc;
        // D s_5314_1: cast zx s_5314_0 -> bv
        let s_5314_1: Bits = Bits::new(s_5314_0 as u128, 4u16);
        // C s_5314_2: const #14u : u8
        let s_5314_2: u8 = 14;
        // C s_5314_3: cast zx s_5314_2 -> bv
        let s_5314_3: Bits = Bits::new(s_5314_2 as u128, 4u16);
        // D s_5314_4: cmp-eq s_5314_1 s_5314_3
        let s_5314_4: bool = ((s_5314_1) == (s_5314_3));
        // D s_5314_5: write-var gs#117833 <= s_5314_4
        fn_state.gs_117833 = s_5314_4;
        // N s_5314_6: jump b643
        return block_643(state, tracer, fn_state);
    }
    fn block_5315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5315_0: read-var CRn:u8
        let s_5315_0: u8 = fn_state.CRn;
        // D s_5315_1: cast zx s_5315_0 -> bv
        let s_5315_1: Bits = Bits::new(s_5315_0 as u128, 4u16);
        // C s_5315_2: const #7u : u8
        let s_5315_2: u8 = 7;
        // C s_5315_3: cast zx s_5315_2 -> bv
        let s_5315_3: Bits = Bits::new(s_5315_2 as u128, 4u16);
        // D s_5315_4: cmp-eq s_5315_1 s_5315_3
        let s_5315_4: bool = ((s_5315_1) == (s_5315_3));
        // D s_5315_5: write-var gs#117832 <= s_5315_4
        fn_state.gs_117832 = s_5315_4;
        // N s_5315_6: jump b641
        return block_641(state, tracer, fn_state);
    }
    fn block_5316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5316_0: read-var el:u8
        let s_5316_0: u8 = fn_state.el;
        // D s_5316_1: read-var coproc:u8
        let s_5316_1: u8 = fn_state.coproc;
        // D s_5316_2: read-var opc1:u8
        let s_5316_2: u8 = fn_state.opc1;
        // D s_5316_3: read-var CRn:u8
        let s_5316_3: u8 = fn_state.CRn;
        // D s_5316_4: read-var opc2:u8
        let s_5316_4: u8 = fn_state.opc2;
        // D s_5316_5: read-var CRm:u8
        let s_5316_5: u8 = fn_state.CRm;
        // D s_5316_6: read-var t:i
        let s_5316_6: i128 = fn_state.t;
        // D s_5316_7: call CNTV_TVAL_SysRegRead32_ac1a47c2d11f8dd9(s_5316_0, s_5316_1, s_5316_2, s_5316_3, s_5316_4, s_5316_5, s_5316_6)
        let s_5316_7: () = CNTV_TVAL_SysRegRead32_ac1a47c2d11f8dd9(
            state,
            tracer,
            s_5316_0,
            s_5316_1,
            s_5316_2,
            s_5316_3,
            s_5316_4,
            s_5316_5,
            s_5316_6,
        );
        // N s_5316_8: return
        return;
    }
    fn block_5317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5317_0: read-var opc2:u8
        let s_5317_0: u8 = fn_state.opc2;
        // D s_5317_1: cast zx s_5317_0 -> bv
        let s_5317_1: Bits = Bits::new(s_5317_0 as u128, 3u16);
        // C s_5317_2: const #0u : u8
        let s_5317_2: u8 = 0;
        // C s_5317_3: cast zx s_5317_2 -> bv
        let s_5317_3: Bits = Bits::new(s_5317_2 as u128, 3u16);
        // D s_5317_4: cmp-eq s_5317_1 s_5317_3
        let s_5317_4: bool = ((s_5317_1) == (s_5317_3));
        // D s_5317_5: write-var gs#117831 <= s_5317_4
        fn_state.gs_117831 = s_5317_4;
        // N s_5317_6: jump b638
        return block_638(state, tracer, fn_state);
    }
    fn block_5318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5318_0: read-var opc1:u8
        let s_5318_0: u8 = fn_state.opc1;
        // D s_5318_1: cast zx s_5318_0 -> bv
        let s_5318_1: Bits = Bits::new(s_5318_0 as u128, 3u16);
        // C s_5318_2: const #0u : u8
        let s_5318_2: u8 = 0;
        // C s_5318_3: cast zx s_5318_2 -> bv
        let s_5318_3: Bits = Bits::new(s_5318_2 as u128, 3u16);
        // D s_5318_4: cmp-eq s_5318_1 s_5318_3
        let s_5318_4: bool = ((s_5318_1) == (s_5318_3));
        // D s_5318_5: write-var gs#117830 <= s_5318_4
        fn_state.gs_117830 = s_5318_4;
        // N s_5318_6: jump b636
        return block_636(state, tracer, fn_state);
    }
    fn block_5319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5319_0: read-var coproc:u8
        let s_5319_0: u8 = fn_state.coproc;
        // D s_5319_1: cast zx s_5319_0 -> bv
        let s_5319_1: Bits = Bits::new(s_5319_0 as u128, 4u16);
        // C s_5319_2: const #15u : u8
        let s_5319_2: u8 = 15;
        // C s_5319_3: cast zx s_5319_2 -> bv
        let s_5319_3: Bits = Bits::new(s_5319_2 as u128, 4u16);
        // D s_5319_4: cmp-eq s_5319_1 s_5319_3
        let s_5319_4: bool = ((s_5319_1) == (s_5319_3));
        // D s_5319_5: write-var gs#117829 <= s_5319_4
        fn_state.gs_117829 = s_5319_4;
        // N s_5319_6: jump b634
        return block_634(state, tracer, fn_state);
    }
    fn block_5320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5320_0: read-var CRn:u8
        let s_5320_0: u8 = fn_state.CRn;
        // D s_5320_1: cast zx s_5320_0 -> bv
        let s_5320_1: Bits = Bits::new(s_5320_0 as u128, 4u16);
        // C s_5320_2: const #14u : u8
        let s_5320_2: u8 = 14;
        // C s_5320_3: cast zx s_5320_2 -> bv
        let s_5320_3: Bits = Bits::new(s_5320_2 as u128, 4u16);
        // D s_5320_4: cmp-eq s_5320_1 s_5320_3
        let s_5320_4: bool = ((s_5320_1) == (s_5320_3));
        // D s_5320_5: write-var gs#117828 <= s_5320_4
        fn_state.gs_117828 = s_5320_4;
        // N s_5320_6: jump b632
        return block_632(state, tracer, fn_state);
    }
    fn block_5321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5321_0: read-var el:u8
        let s_5321_0: u8 = fn_state.el;
        // D s_5321_1: read-var coproc:u8
        let s_5321_1: u8 = fn_state.coproc;
        // D s_5321_2: read-var opc1:u8
        let s_5321_2: u8 = fn_state.opc1;
        // D s_5321_3: read-var CRn:u8
        let s_5321_3: u8 = fn_state.CRn;
        // D s_5321_4: read-var opc2:u8
        let s_5321_4: u8 = fn_state.opc2;
        // D s_5321_5: read-var CRm:u8
        let s_5321_5: u8 = fn_state.CRm;
        // D s_5321_6: read-var t:i
        let s_5321_6: i128 = fn_state.t;
        // D s_5321_7: call HPFAR_SysRegRead32_985da2a8b12c2ec3(s_5321_0, s_5321_1, s_5321_2, s_5321_3, s_5321_4, s_5321_5, s_5321_6)
        let s_5321_7: () = HPFAR_SysRegRead32_985da2a8b12c2ec3(
            state,
            tracer,
            s_5321_0,
            s_5321_1,
            s_5321_2,
            s_5321_3,
            s_5321_4,
            s_5321_5,
            s_5321_6,
        );
        // N s_5321_8: return
        return;
    }
    fn block_5322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5322_0: read-var opc2:u8
        let s_5322_0: u8 = fn_state.opc2;
        // D s_5322_1: cast zx s_5322_0 -> bv
        let s_5322_1: Bits = Bits::new(s_5322_0 as u128, 3u16);
        // C s_5322_2: const #4u : u8
        let s_5322_2: u8 = 4;
        // C s_5322_3: cast zx s_5322_2 -> bv
        let s_5322_3: Bits = Bits::new(s_5322_2 as u128, 3u16);
        // D s_5322_4: cmp-eq s_5322_1 s_5322_3
        let s_5322_4: bool = ((s_5322_1) == (s_5322_3));
        // D s_5322_5: write-var gs#117827 <= s_5322_4
        fn_state.gs_117827 = s_5322_4;
        // N s_5322_6: jump b629
        return block_629(state, tracer, fn_state);
    }
    fn block_5323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5323_0: read-var opc1:u8
        let s_5323_0: u8 = fn_state.opc1;
        // D s_5323_1: cast zx s_5323_0 -> bv
        let s_5323_1: Bits = Bits::new(s_5323_0 as u128, 3u16);
        // C s_5323_2: const #4u : u8
        let s_5323_2: u8 = 4;
        // C s_5323_3: cast zx s_5323_2 -> bv
        let s_5323_3: Bits = Bits::new(s_5323_2 as u128, 3u16);
        // D s_5323_4: cmp-eq s_5323_1 s_5323_3
        let s_5323_4: bool = ((s_5323_1) == (s_5323_3));
        // D s_5323_5: write-var gs#117826 <= s_5323_4
        fn_state.gs_117826 = s_5323_4;
        // N s_5323_6: jump b627
        return block_627(state, tracer, fn_state);
    }
    fn block_5324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5324_0: read-var coproc:u8
        let s_5324_0: u8 = fn_state.coproc;
        // D s_5324_1: cast zx s_5324_0 -> bv
        let s_5324_1: Bits = Bits::new(s_5324_0 as u128, 4u16);
        // C s_5324_2: const #15u : u8
        let s_5324_2: u8 = 15;
        // C s_5324_3: cast zx s_5324_2 -> bv
        let s_5324_3: Bits = Bits::new(s_5324_2 as u128, 4u16);
        // D s_5324_4: cmp-eq s_5324_1 s_5324_3
        let s_5324_4: bool = ((s_5324_1) == (s_5324_3));
        // D s_5324_5: write-var gs#117825 <= s_5324_4
        fn_state.gs_117825 = s_5324_4;
        // N s_5324_6: jump b625
        return block_625(state, tracer, fn_state);
    }
    fn block_5325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5325_0: read-var CRn:u8
        let s_5325_0: u8 = fn_state.CRn;
        // D s_5325_1: cast zx s_5325_0 -> bv
        let s_5325_1: Bits = Bits::new(s_5325_0 as u128, 4u16);
        // C s_5325_2: const #6u : u8
        let s_5325_2: u8 = 6;
        // C s_5325_3: cast zx s_5325_2 -> bv
        let s_5325_3: Bits = Bits::new(s_5325_2 as u128, 4u16);
        // D s_5325_4: cmp-eq s_5325_1 s_5325_3
        let s_5325_4: bool = ((s_5325_1) == (s_5325_3));
        // D s_5325_5: write-var gs#117824 <= s_5325_4
        fn_state.gs_117824 = s_5325_4;
        // N s_5325_6: jump b623
        return block_623(state, tracer, fn_state);
    }
    fn block_5326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5326_0: read-var el:u8
        let s_5326_0: u8 = fn_state.el;
        // D s_5326_1: read-var coproc:u8
        let s_5326_1: u8 = fn_state.coproc;
        // D s_5326_2: read-var opc1:u8
        let s_5326_2: u8 = fn_state.opc1;
        // D s_5326_3: read-var CRn:u8
        let s_5326_3: u8 = fn_state.CRn;
        // D s_5326_4: read-var opc2:u8
        let s_5326_4: u8 = fn_state.opc2;
        // D s_5326_5: read-var CRm:u8
        let s_5326_5: u8 = fn_state.CRm;
        // D s_5326_6: read-var t:i
        let s_5326_6: i128 = fn_state.t;
        // D s_5326_7: call HACTLR_SysRegRead32_2bf8282054123267(s_5326_0, s_5326_1, s_5326_2, s_5326_3, s_5326_4, s_5326_5, s_5326_6)
        let s_5326_7: () = HACTLR_SysRegRead32_2bf8282054123267(
            state,
            tracer,
            s_5326_0,
            s_5326_1,
            s_5326_2,
            s_5326_3,
            s_5326_4,
            s_5326_5,
            s_5326_6,
        );
        // N s_5326_8: return
        return;
    }
    fn block_5327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5327_0: read-var opc2:u8
        let s_5327_0: u8 = fn_state.opc2;
        // D s_5327_1: cast zx s_5327_0 -> bv
        let s_5327_1: Bits = Bits::new(s_5327_0 as u128, 3u16);
        // C s_5327_2: const #1u : u8
        let s_5327_2: u8 = 1;
        // C s_5327_3: cast zx s_5327_2 -> bv
        let s_5327_3: Bits = Bits::new(s_5327_2 as u128, 3u16);
        // D s_5327_4: cmp-eq s_5327_1 s_5327_3
        let s_5327_4: bool = ((s_5327_1) == (s_5327_3));
        // D s_5327_5: write-var gs#117823 <= s_5327_4
        fn_state.gs_117823 = s_5327_4;
        // N s_5327_6: jump b620
        return block_620(state, tracer, fn_state);
    }
    fn block_5328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5328_0: read-var opc1:u8
        let s_5328_0: u8 = fn_state.opc1;
        // D s_5328_1: cast zx s_5328_0 -> bv
        let s_5328_1: Bits = Bits::new(s_5328_0 as u128, 3u16);
        // C s_5328_2: const #4u : u8
        let s_5328_2: u8 = 4;
        // C s_5328_3: cast zx s_5328_2 -> bv
        let s_5328_3: Bits = Bits::new(s_5328_2 as u128, 3u16);
        // D s_5328_4: cmp-eq s_5328_1 s_5328_3
        let s_5328_4: bool = ((s_5328_1) == (s_5328_3));
        // D s_5328_5: write-var gs#117822 <= s_5328_4
        fn_state.gs_117822 = s_5328_4;
        // N s_5328_6: jump b618
        return block_618(state, tracer, fn_state);
    }
    fn block_5329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5329_0: read-var coproc:u8
        let s_5329_0: u8 = fn_state.coproc;
        // D s_5329_1: cast zx s_5329_0 -> bv
        let s_5329_1: Bits = Bits::new(s_5329_0 as u128, 4u16);
        // C s_5329_2: const #15u : u8
        let s_5329_2: u8 = 15;
        // C s_5329_3: cast zx s_5329_2 -> bv
        let s_5329_3: Bits = Bits::new(s_5329_2 as u128, 4u16);
        // D s_5329_4: cmp-eq s_5329_1 s_5329_3
        let s_5329_4: bool = ((s_5329_1) == (s_5329_3));
        // D s_5329_5: write-var gs#117821 <= s_5329_4
        fn_state.gs_117821 = s_5329_4;
        // N s_5329_6: jump b616
        return block_616(state, tracer, fn_state);
    }
    fn block_5330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5330_0: read-var CRn:u8
        let s_5330_0: u8 = fn_state.CRn;
        // D s_5330_1: cast zx s_5330_0 -> bv
        let s_5330_1: Bits = Bits::new(s_5330_0 as u128, 4u16);
        // C s_5330_2: const #1u : u8
        let s_5330_2: u8 = 1;
        // C s_5330_3: cast zx s_5330_2 -> bv
        let s_5330_3: Bits = Bits::new(s_5330_2 as u128, 4u16);
        // D s_5330_4: cmp-eq s_5330_1 s_5330_3
        let s_5330_4: bool = ((s_5330_1) == (s_5330_3));
        // D s_5330_5: write-var gs#117820 <= s_5330_4
        fn_state.gs_117820 = s_5330_4;
        // N s_5330_6: jump b614
        return block_614(state, tracer, fn_state);
    }
    fn block_5331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5331_0: read-var el:u8
        let s_5331_0: u8 = fn_state.el;
        // D s_5331_1: read-var coproc:u8
        let s_5331_1: u8 = fn_state.coproc;
        // D s_5331_2: read-var opc1:u8
        let s_5331_2: u8 = fn_state.opc1;
        // D s_5331_3: read-var CRn:u8
        let s_5331_3: u8 = fn_state.CRn;
        // D s_5331_4: read-var opc2:u8
        let s_5331_4: u8 = fn_state.opc2;
        // D s_5331_5: read-var CRm:u8
        let s_5331_5: u8 = fn_state.CRm;
        // D s_5331_6: read-var t:i
        let s_5331_6: i128 = fn_state.t;
        // D s_5331_7: call ID_ISAR6_SysRegRead32_b87615d75481dd47(s_5331_0, s_5331_1, s_5331_2, s_5331_3, s_5331_4, s_5331_5, s_5331_6)
        let s_5331_7: () = ID_ISAR6_SysRegRead32_b87615d75481dd47(
            state,
            tracer,
            s_5331_0,
            s_5331_1,
            s_5331_2,
            s_5331_3,
            s_5331_4,
            s_5331_5,
            s_5331_6,
        );
        // N s_5331_8: return
        return;
    }
    fn block_5332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5332_0: read-var opc2:u8
        let s_5332_0: u8 = fn_state.opc2;
        // D s_5332_1: cast zx s_5332_0 -> bv
        let s_5332_1: Bits = Bits::new(s_5332_0 as u128, 3u16);
        // C s_5332_2: const #7u : u8
        let s_5332_2: u8 = 7;
        // C s_5332_3: cast zx s_5332_2 -> bv
        let s_5332_3: Bits = Bits::new(s_5332_2 as u128, 3u16);
        // D s_5332_4: cmp-eq s_5332_1 s_5332_3
        let s_5332_4: bool = ((s_5332_1) == (s_5332_3));
        // D s_5332_5: write-var gs#117819 <= s_5332_4
        fn_state.gs_117819 = s_5332_4;
        // N s_5332_6: jump b611
        return block_611(state, tracer, fn_state);
    }
    fn block_5333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5333_0: read-var opc1:u8
        let s_5333_0: u8 = fn_state.opc1;
        // D s_5333_1: cast zx s_5333_0 -> bv
        let s_5333_1: Bits = Bits::new(s_5333_0 as u128, 3u16);
        // C s_5333_2: const #0u : u8
        let s_5333_2: u8 = 0;
        // C s_5333_3: cast zx s_5333_2 -> bv
        let s_5333_3: Bits = Bits::new(s_5333_2 as u128, 3u16);
        // D s_5333_4: cmp-eq s_5333_1 s_5333_3
        let s_5333_4: bool = ((s_5333_1) == (s_5333_3));
        // D s_5333_5: write-var gs#117818 <= s_5333_4
        fn_state.gs_117818 = s_5333_4;
        // N s_5333_6: jump b609
        return block_609(state, tracer, fn_state);
    }
    fn block_5334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5334_0: read-var coproc:u8
        let s_5334_0: u8 = fn_state.coproc;
        // D s_5334_1: cast zx s_5334_0 -> bv
        let s_5334_1: Bits = Bits::new(s_5334_0 as u128, 4u16);
        // C s_5334_2: const #15u : u8
        let s_5334_2: u8 = 15;
        // C s_5334_3: cast zx s_5334_2 -> bv
        let s_5334_3: Bits = Bits::new(s_5334_2 as u128, 4u16);
        // D s_5334_4: cmp-eq s_5334_1 s_5334_3
        let s_5334_4: bool = ((s_5334_1) == (s_5334_3));
        // D s_5334_5: write-var gs#117817 <= s_5334_4
        fn_state.gs_117817 = s_5334_4;
        // N s_5334_6: jump b607
        return block_607(state, tracer, fn_state);
    }
    fn block_5335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5335_0: read-var CRn:u8
        let s_5335_0: u8 = fn_state.CRn;
        // D s_5335_1: cast zx s_5335_0 -> bv
        let s_5335_1: Bits = Bits::new(s_5335_0 as u128, 4u16);
        // C s_5335_2: const #0u : u8
        let s_5335_2: u8 = 0;
        // C s_5335_3: cast zx s_5335_2 -> bv
        let s_5335_3: Bits = Bits::new(s_5335_2 as u128, 4u16);
        // D s_5335_4: cmp-eq s_5335_1 s_5335_3
        let s_5335_4: bool = ((s_5335_1) == (s_5335_3));
        // D s_5335_5: write-var gs#117816 <= s_5335_4
        fn_state.gs_117816 = s_5335_4;
        // N s_5335_6: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_5336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5336_0: read-var el:u8
        let s_5336_0: u8 = fn_state.el;
        // D s_5336_1: read-var coproc:u8
        let s_5336_1: u8 = fn_state.coproc;
        // D s_5336_2: read-var opc1:u8
        let s_5336_2: u8 = fn_state.opc1;
        // D s_5336_3: read-var CRn:u8
        let s_5336_3: u8 = fn_state.CRn;
        // D s_5336_4: read-var opc2:u8
        let s_5336_4: u8 = fn_state.opc2;
        // D s_5336_5: read-var CRm:u8
        let s_5336_5: u8 = fn_state.CRm;
        // D s_5336_6: read-var t:i
        let s_5336_6: i128 = fn_state.t;
        // D s_5336_7: call DBGBXVR_SysRegRead32_718e496a0f71d413(s_5336_0, s_5336_1, s_5336_2, s_5336_3, s_5336_4, s_5336_5, s_5336_6)
        let s_5336_7: () = DBGBXVR_SysRegRead32_718e496a0f71d413(
            state,
            tracer,
            s_5336_0,
            s_5336_1,
            s_5336_2,
            s_5336_3,
            s_5336_4,
            s_5336_5,
            s_5336_6,
        );
        // N s_5336_8: return
        return;
    }
    fn block_5337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5337_0: read-var opc2:u8
        let s_5337_0: u8 = fn_state.opc2;
        // D s_5337_1: cast zx s_5337_0 -> bv
        let s_5337_1: Bits = Bits::new(s_5337_0 as u128, 3u16);
        // C s_5337_2: const #1u : u8
        let s_5337_2: u8 = 1;
        // C s_5337_3: cast zx s_5337_2 -> bv
        let s_5337_3: Bits = Bits::new(s_5337_2 as u128, 3u16);
        // D s_5337_4: cmp-eq s_5337_1 s_5337_3
        let s_5337_4: bool = ((s_5337_1) == (s_5337_3));
        // D s_5337_5: write-var gs#117815 <= s_5337_4
        fn_state.gs_117815 = s_5337_4;
        // N s_5337_6: jump b602
        return block_602(state, tracer, fn_state);
    }
    fn block_5338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5338_0: read-var opc1:u8
        let s_5338_0: u8 = fn_state.opc1;
        // D s_5338_1: cast zx s_5338_0 -> bv
        let s_5338_1: Bits = Bits::new(s_5338_0 as u128, 3u16);
        // C s_5338_2: const #0u : u8
        let s_5338_2: u8 = 0;
        // C s_5338_3: cast zx s_5338_2 -> bv
        let s_5338_3: Bits = Bits::new(s_5338_2 as u128, 3u16);
        // D s_5338_4: cmp-eq s_5338_1 s_5338_3
        let s_5338_4: bool = ((s_5338_1) == (s_5338_3));
        // D s_5338_5: write-var gs#117814 <= s_5338_4
        fn_state.gs_117814 = s_5338_4;
        // N s_5338_6: jump b600
        return block_600(state, tracer, fn_state);
    }
    fn block_5339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5339_0: read-var coproc:u8
        let s_5339_0: u8 = fn_state.coproc;
        // D s_5339_1: cast zx s_5339_0 -> bv
        let s_5339_1: Bits = Bits::new(s_5339_0 as u128, 4u16);
        // C s_5339_2: const #14u : u8
        let s_5339_2: u8 = 14;
        // C s_5339_3: cast zx s_5339_2 -> bv
        let s_5339_3: Bits = Bits::new(s_5339_2 as u128, 4u16);
        // D s_5339_4: cmp-eq s_5339_1 s_5339_3
        let s_5339_4: bool = ((s_5339_1) == (s_5339_3));
        // D s_5339_5: write-var gs#117813 <= s_5339_4
        fn_state.gs_117813 = s_5339_4;
        // N s_5339_6: jump b598
        return block_598(state, tracer, fn_state);
    }
    fn block_5340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5340_0: read-var CRn:u8
        let s_5340_0: u8 = fn_state.CRn;
        // D s_5340_1: cast zx s_5340_0 -> bv
        let s_5340_1: Bits = Bits::new(s_5340_0 as u128, 4u16);
        // C s_5340_2: const #1u : u8
        let s_5340_2: u8 = 1;
        // C s_5340_3: cast zx s_5340_2 -> bv
        let s_5340_3: Bits = Bits::new(s_5340_2 as u128, 4u16);
        // D s_5340_4: cmp-eq s_5340_1 s_5340_3
        let s_5340_4: bool = ((s_5340_1) == (s_5340_3));
        // D s_5340_5: write-var gs#117812 <= s_5340_4
        fn_state.gs_117812 = s_5340_4;
        // N s_5340_6: jump b596
        return block_596(state, tracer, fn_state);
    }
    fn block_5341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5341_0: read-var el:u8
        let s_5341_0: u8 = fn_state.el;
        // D s_5341_1: read-var coproc:u8
        let s_5341_1: u8 = fn_state.coproc;
        // D s_5341_2: read-var opc1:u8
        let s_5341_2: u8 = fn_state.opc1;
        // D s_5341_3: read-var CRn:u8
        let s_5341_3: u8 = fn_state.CRn;
        // D s_5341_4: read-var opc2:u8
        let s_5341_4: u8 = fn_state.opc2;
        // D s_5341_5: read-var CRm:u8
        let s_5341_5: u8 = fn_state.CRm;
        // D s_5341_6: read-var t:i
        let s_5341_6: i128 = fn_state.t;
        // D s_5341_7: call DBGBXVR_SysRegRead32_dac7cb34b3ce5d73(s_5341_0, s_5341_1, s_5341_2, s_5341_3, s_5341_4, s_5341_5, s_5341_6)
        let s_5341_7: () = DBGBXVR_SysRegRead32_dac7cb34b3ce5d73(
            state,
            tracer,
            s_5341_0,
            s_5341_1,
            s_5341_2,
            s_5341_3,
            s_5341_4,
            s_5341_5,
            s_5341_6,
        );
        // N s_5341_8: return
        return;
    }
    fn block_5342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5342_0: read-var opc2:u8
        let s_5342_0: u8 = fn_state.opc2;
        // D s_5342_1: cast zx s_5342_0 -> bv
        let s_5342_1: Bits = Bits::new(s_5342_0 as u128, 3u16);
        // C s_5342_2: const #1u : u8
        let s_5342_2: u8 = 1;
        // C s_5342_3: cast zx s_5342_2 -> bv
        let s_5342_3: Bits = Bits::new(s_5342_2 as u128, 3u16);
        // D s_5342_4: cmp-eq s_5342_1 s_5342_3
        let s_5342_4: bool = ((s_5342_1) == (s_5342_3));
        // D s_5342_5: write-var gs#117811 <= s_5342_4
        fn_state.gs_117811 = s_5342_4;
        // N s_5342_6: jump b593
        return block_593(state, tracer, fn_state);
    }
    fn block_5343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5343_0: read-var opc1:u8
        let s_5343_0: u8 = fn_state.opc1;
        // D s_5343_1: cast zx s_5343_0 -> bv
        let s_5343_1: Bits = Bits::new(s_5343_0 as u128, 3u16);
        // C s_5343_2: const #0u : u8
        let s_5343_2: u8 = 0;
        // C s_5343_3: cast zx s_5343_2 -> bv
        let s_5343_3: Bits = Bits::new(s_5343_2 as u128, 3u16);
        // D s_5343_4: cmp-eq s_5343_1 s_5343_3
        let s_5343_4: bool = ((s_5343_1) == (s_5343_3));
        // D s_5343_5: write-var gs#117810 <= s_5343_4
        fn_state.gs_117810 = s_5343_4;
        // N s_5343_6: jump b591
        return block_591(state, tracer, fn_state);
    }
    fn block_5344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5344_0: read-var coproc:u8
        let s_5344_0: u8 = fn_state.coproc;
        // D s_5344_1: cast zx s_5344_0 -> bv
        let s_5344_1: Bits = Bits::new(s_5344_0 as u128, 4u16);
        // C s_5344_2: const #14u : u8
        let s_5344_2: u8 = 14;
        // C s_5344_3: cast zx s_5344_2 -> bv
        let s_5344_3: Bits = Bits::new(s_5344_2 as u128, 4u16);
        // D s_5344_4: cmp-eq s_5344_1 s_5344_3
        let s_5344_4: bool = ((s_5344_1) == (s_5344_3));
        // D s_5344_5: write-var gs#117809 <= s_5344_4
        fn_state.gs_117809 = s_5344_4;
        // N s_5344_6: jump b589
        return block_589(state, tracer, fn_state);
    }
    fn block_5345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5345_0: read-var CRn:u8
        let s_5345_0: u8 = fn_state.CRn;
        // D s_5345_1: cast zx s_5345_0 -> bv
        let s_5345_1: Bits = Bits::new(s_5345_0 as u128, 4u16);
        // C s_5345_2: const #1u : u8
        let s_5345_2: u8 = 1;
        // C s_5345_3: cast zx s_5345_2 -> bv
        let s_5345_3: Bits = Bits::new(s_5345_2 as u128, 4u16);
        // D s_5345_4: cmp-eq s_5345_1 s_5345_3
        let s_5345_4: bool = ((s_5345_1) == (s_5345_3));
        // D s_5345_5: write-var gs#117808 <= s_5345_4
        fn_state.gs_117808 = s_5345_4;
        // N s_5345_6: jump b587
        return block_587(state, tracer, fn_state);
    }
    fn block_5346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5346_0: read-var el:u8
        let s_5346_0: u8 = fn_state.el;
        // D s_5346_1: read-var coproc:u8
        let s_5346_1: u8 = fn_state.coproc;
        // D s_5346_2: read-var opc1:u8
        let s_5346_2: u8 = fn_state.opc1;
        // D s_5346_3: read-var CRn:u8
        let s_5346_3: u8 = fn_state.CRn;
        // D s_5346_4: read-var opc2:u8
        let s_5346_4: u8 = fn_state.opc2;
        // D s_5346_5: read-var CRm:u8
        let s_5346_5: u8 = fn_state.CRm;
        // D s_5346_6: read-var t:i
        let s_5346_6: i128 = fn_state.t;
        // D s_5346_7: call DBGBXVR_SysRegRead32_9a88c64f6ef204ae(s_5346_0, s_5346_1, s_5346_2, s_5346_3, s_5346_4, s_5346_5, s_5346_6)
        let s_5346_7: () = DBGBXVR_SysRegRead32_9a88c64f6ef204ae(
            state,
            tracer,
            s_5346_0,
            s_5346_1,
            s_5346_2,
            s_5346_3,
            s_5346_4,
            s_5346_5,
            s_5346_6,
        );
        // N s_5346_8: return
        return;
    }
    fn block_5347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5347_0: read-var opc2:u8
        let s_5347_0: u8 = fn_state.opc2;
        // D s_5347_1: cast zx s_5347_0 -> bv
        let s_5347_1: Bits = Bits::new(s_5347_0 as u128, 3u16);
        // C s_5347_2: const #1u : u8
        let s_5347_2: u8 = 1;
        // C s_5347_3: cast zx s_5347_2 -> bv
        let s_5347_3: Bits = Bits::new(s_5347_2 as u128, 3u16);
        // D s_5347_4: cmp-eq s_5347_1 s_5347_3
        let s_5347_4: bool = ((s_5347_1) == (s_5347_3));
        // D s_5347_5: write-var gs#117807 <= s_5347_4
        fn_state.gs_117807 = s_5347_4;
        // N s_5347_6: jump b584
        return block_584(state, tracer, fn_state);
    }
    fn block_5348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5348_0: read-var opc1:u8
        let s_5348_0: u8 = fn_state.opc1;
        // D s_5348_1: cast zx s_5348_0 -> bv
        let s_5348_1: Bits = Bits::new(s_5348_0 as u128, 3u16);
        // C s_5348_2: const #0u : u8
        let s_5348_2: u8 = 0;
        // C s_5348_3: cast zx s_5348_2 -> bv
        let s_5348_3: Bits = Bits::new(s_5348_2 as u128, 3u16);
        // D s_5348_4: cmp-eq s_5348_1 s_5348_3
        let s_5348_4: bool = ((s_5348_1) == (s_5348_3));
        // D s_5348_5: write-var gs#117806 <= s_5348_4
        fn_state.gs_117806 = s_5348_4;
        // N s_5348_6: jump b582
        return block_582(state, tracer, fn_state);
    }
    fn block_5349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5349_0: read-var coproc:u8
        let s_5349_0: u8 = fn_state.coproc;
        // D s_5349_1: cast zx s_5349_0 -> bv
        let s_5349_1: Bits = Bits::new(s_5349_0 as u128, 4u16);
        // C s_5349_2: const #14u : u8
        let s_5349_2: u8 = 14;
        // C s_5349_3: cast zx s_5349_2 -> bv
        let s_5349_3: Bits = Bits::new(s_5349_2 as u128, 4u16);
        // D s_5349_4: cmp-eq s_5349_1 s_5349_3
        let s_5349_4: bool = ((s_5349_1) == (s_5349_3));
        // D s_5349_5: write-var gs#117805 <= s_5349_4
        fn_state.gs_117805 = s_5349_4;
        // N s_5349_6: jump b580
        return block_580(state, tracer, fn_state);
    }
    fn block_5350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5350_0: read-var CRn:u8
        let s_5350_0: u8 = fn_state.CRn;
        // D s_5350_1: cast zx s_5350_0 -> bv
        let s_5350_1: Bits = Bits::new(s_5350_0 as u128, 4u16);
        // C s_5350_2: const #1u : u8
        let s_5350_2: u8 = 1;
        // C s_5350_3: cast zx s_5350_2 -> bv
        let s_5350_3: Bits = Bits::new(s_5350_2 as u128, 4u16);
        // D s_5350_4: cmp-eq s_5350_1 s_5350_3
        let s_5350_4: bool = ((s_5350_1) == (s_5350_3));
        // D s_5350_5: write-var gs#117804 <= s_5350_4
        fn_state.gs_117804 = s_5350_4;
        // N s_5350_6: jump b578
        return block_578(state, tracer, fn_state);
    }
    fn block_5351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5351_0: read-var el:u8
        let s_5351_0: u8 = fn_state.el;
        // D s_5351_1: read-var coproc:u8
        let s_5351_1: u8 = fn_state.coproc;
        // D s_5351_2: read-var opc1:u8
        let s_5351_2: u8 = fn_state.opc1;
        // D s_5351_3: read-var CRn:u8
        let s_5351_3: u8 = fn_state.CRn;
        // D s_5351_4: read-var opc2:u8
        let s_5351_4: u8 = fn_state.opc2;
        // D s_5351_5: read-var CRm:u8
        let s_5351_5: u8 = fn_state.CRm;
        // D s_5351_6: read-var t:i
        let s_5351_6: i128 = fn_state.t;
        // D s_5351_7: call DBGBXVR_SysRegRead32_f467d6fedc917b46(s_5351_0, s_5351_1, s_5351_2, s_5351_3, s_5351_4, s_5351_5, s_5351_6)
        let s_5351_7: () = DBGBXVR_SysRegRead32_f467d6fedc917b46(
            state,
            tracer,
            s_5351_0,
            s_5351_1,
            s_5351_2,
            s_5351_3,
            s_5351_4,
            s_5351_5,
            s_5351_6,
        );
        // N s_5351_8: return
        return;
    }
    fn block_5352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5352_0: read-var opc2:u8
        let s_5352_0: u8 = fn_state.opc2;
        // D s_5352_1: cast zx s_5352_0 -> bv
        let s_5352_1: Bits = Bits::new(s_5352_0 as u128, 3u16);
        // C s_5352_2: const #1u : u8
        let s_5352_2: u8 = 1;
        // C s_5352_3: cast zx s_5352_2 -> bv
        let s_5352_3: Bits = Bits::new(s_5352_2 as u128, 3u16);
        // D s_5352_4: cmp-eq s_5352_1 s_5352_3
        let s_5352_4: bool = ((s_5352_1) == (s_5352_3));
        // D s_5352_5: write-var gs#117803 <= s_5352_4
        fn_state.gs_117803 = s_5352_4;
        // N s_5352_6: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_5353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5353_0: read-var opc1:u8
        let s_5353_0: u8 = fn_state.opc1;
        // D s_5353_1: cast zx s_5353_0 -> bv
        let s_5353_1: Bits = Bits::new(s_5353_0 as u128, 3u16);
        // C s_5353_2: const #0u : u8
        let s_5353_2: u8 = 0;
        // C s_5353_3: cast zx s_5353_2 -> bv
        let s_5353_3: Bits = Bits::new(s_5353_2 as u128, 3u16);
        // D s_5353_4: cmp-eq s_5353_1 s_5353_3
        let s_5353_4: bool = ((s_5353_1) == (s_5353_3));
        // D s_5353_5: write-var gs#117802 <= s_5353_4
        fn_state.gs_117802 = s_5353_4;
        // N s_5353_6: jump b573
        return block_573(state, tracer, fn_state);
    }
    fn block_5354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5354_0: read-var coproc:u8
        let s_5354_0: u8 = fn_state.coproc;
        // D s_5354_1: cast zx s_5354_0 -> bv
        let s_5354_1: Bits = Bits::new(s_5354_0 as u128, 4u16);
        // C s_5354_2: const #14u : u8
        let s_5354_2: u8 = 14;
        // C s_5354_3: cast zx s_5354_2 -> bv
        let s_5354_3: Bits = Bits::new(s_5354_2 as u128, 4u16);
        // D s_5354_4: cmp-eq s_5354_1 s_5354_3
        let s_5354_4: bool = ((s_5354_1) == (s_5354_3));
        // D s_5354_5: write-var gs#117801 <= s_5354_4
        fn_state.gs_117801 = s_5354_4;
        // N s_5354_6: jump b571
        return block_571(state, tracer, fn_state);
    }
    fn block_5355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5355_0: read-var CRn:u8
        let s_5355_0: u8 = fn_state.CRn;
        // D s_5355_1: cast zx s_5355_0 -> bv
        let s_5355_1: Bits = Bits::new(s_5355_0 as u128, 4u16);
        // C s_5355_2: const #1u : u8
        let s_5355_2: u8 = 1;
        // C s_5355_3: cast zx s_5355_2 -> bv
        let s_5355_3: Bits = Bits::new(s_5355_2 as u128, 4u16);
        // D s_5355_4: cmp-eq s_5355_1 s_5355_3
        let s_5355_4: bool = ((s_5355_1) == (s_5355_3));
        // D s_5355_5: write-var gs#117800 <= s_5355_4
        fn_state.gs_117800 = s_5355_4;
        // N s_5355_6: jump b569
        return block_569(state, tracer, fn_state);
    }
    fn block_5356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5356_0: read-var el:u8
        let s_5356_0: u8 = fn_state.el;
        // D s_5356_1: read-var coproc:u8
        let s_5356_1: u8 = fn_state.coproc;
        // D s_5356_2: read-var opc1:u8
        let s_5356_2: u8 = fn_state.opc1;
        // D s_5356_3: read-var CRn:u8
        let s_5356_3: u8 = fn_state.CRn;
        // D s_5356_4: read-var opc2:u8
        let s_5356_4: u8 = fn_state.opc2;
        // D s_5356_5: read-var CRm:u8
        let s_5356_5: u8 = fn_state.CRm;
        // D s_5356_6: read-var t:i
        let s_5356_6: i128 = fn_state.t;
        // D s_5356_7: call DBGBXVR_SysRegRead32_4c6fa7f444c624cb(s_5356_0, s_5356_1, s_5356_2, s_5356_3, s_5356_4, s_5356_5, s_5356_6)
        let s_5356_7: () = DBGBXVR_SysRegRead32_4c6fa7f444c624cb(
            state,
            tracer,
            s_5356_0,
            s_5356_1,
            s_5356_2,
            s_5356_3,
            s_5356_4,
            s_5356_5,
            s_5356_6,
        );
        // N s_5356_8: return
        return;
    }
    fn block_5357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5357_0: read-var opc2:u8
        let s_5357_0: u8 = fn_state.opc2;
        // D s_5357_1: cast zx s_5357_0 -> bv
        let s_5357_1: Bits = Bits::new(s_5357_0 as u128, 3u16);
        // C s_5357_2: const #1u : u8
        let s_5357_2: u8 = 1;
        // C s_5357_3: cast zx s_5357_2 -> bv
        let s_5357_3: Bits = Bits::new(s_5357_2 as u128, 3u16);
        // D s_5357_4: cmp-eq s_5357_1 s_5357_3
        let s_5357_4: bool = ((s_5357_1) == (s_5357_3));
        // D s_5357_5: write-var gs#117799 <= s_5357_4
        fn_state.gs_117799 = s_5357_4;
        // N s_5357_6: jump b566
        return block_566(state, tracer, fn_state);
    }
    fn block_5358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5358_0: read-var opc1:u8
        let s_5358_0: u8 = fn_state.opc1;
        // D s_5358_1: cast zx s_5358_0 -> bv
        let s_5358_1: Bits = Bits::new(s_5358_0 as u128, 3u16);
        // C s_5358_2: const #0u : u8
        let s_5358_2: u8 = 0;
        // C s_5358_3: cast zx s_5358_2 -> bv
        let s_5358_3: Bits = Bits::new(s_5358_2 as u128, 3u16);
        // D s_5358_4: cmp-eq s_5358_1 s_5358_3
        let s_5358_4: bool = ((s_5358_1) == (s_5358_3));
        // D s_5358_5: write-var gs#117798 <= s_5358_4
        fn_state.gs_117798 = s_5358_4;
        // N s_5358_6: jump b564
        return block_564(state, tracer, fn_state);
    }
    fn block_5359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5359_0: read-var coproc:u8
        let s_5359_0: u8 = fn_state.coproc;
        // D s_5359_1: cast zx s_5359_0 -> bv
        let s_5359_1: Bits = Bits::new(s_5359_0 as u128, 4u16);
        // C s_5359_2: const #14u : u8
        let s_5359_2: u8 = 14;
        // C s_5359_3: cast zx s_5359_2 -> bv
        let s_5359_3: Bits = Bits::new(s_5359_2 as u128, 4u16);
        // D s_5359_4: cmp-eq s_5359_1 s_5359_3
        let s_5359_4: bool = ((s_5359_1) == (s_5359_3));
        // D s_5359_5: write-var gs#117797 <= s_5359_4
        fn_state.gs_117797 = s_5359_4;
        // N s_5359_6: jump b562
        return block_562(state, tracer, fn_state);
    }
    fn block_5360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5360_0: read-var CRn:u8
        let s_5360_0: u8 = fn_state.CRn;
        // D s_5360_1: cast zx s_5360_0 -> bv
        let s_5360_1: Bits = Bits::new(s_5360_0 as u128, 4u16);
        // C s_5360_2: const #1u : u8
        let s_5360_2: u8 = 1;
        // C s_5360_3: cast zx s_5360_2 -> bv
        let s_5360_3: Bits = Bits::new(s_5360_2 as u128, 4u16);
        // D s_5360_4: cmp-eq s_5360_1 s_5360_3
        let s_5360_4: bool = ((s_5360_1) == (s_5360_3));
        // D s_5360_5: write-var gs#117796 <= s_5360_4
        fn_state.gs_117796 = s_5360_4;
        // N s_5360_6: jump b560
        return block_560(state, tracer, fn_state);
    }
    fn block_5361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5361_0: read-var el:u8
        let s_5361_0: u8 = fn_state.el;
        // D s_5361_1: read-var coproc:u8
        let s_5361_1: u8 = fn_state.coproc;
        // D s_5361_2: read-var opc1:u8
        let s_5361_2: u8 = fn_state.opc1;
        // D s_5361_3: read-var CRn:u8
        let s_5361_3: u8 = fn_state.CRn;
        // D s_5361_4: read-var opc2:u8
        let s_5361_4: u8 = fn_state.opc2;
        // D s_5361_5: read-var CRm:u8
        let s_5361_5: u8 = fn_state.CRm;
        // D s_5361_6: read-var t:i
        let s_5361_6: i128 = fn_state.t;
        // D s_5361_7: call DBGBXVR_SysRegRead32_52c85c2c5daef517(s_5361_0, s_5361_1, s_5361_2, s_5361_3, s_5361_4, s_5361_5, s_5361_6)
        let s_5361_7: () = DBGBXVR_SysRegRead32_52c85c2c5daef517(
            state,
            tracer,
            s_5361_0,
            s_5361_1,
            s_5361_2,
            s_5361_3,
            s_5361_4,
            s_5361_5,
            s_5361_6,
        );
        // N s_5361_8: return
        return;
    }
    fn block_5362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5362_0: read-var opc2:u8
        let s_5362_0: u8 = fn_state.opc2;
        // D s_5362_1: cast zx s_5362_0 -> bv
        let s_5362_1: Bits = Bits::new(s_5362_0 as u128, 3u16);
        // C s_5362_2: const #1u : u8
        let s_5362_2: u8 = 1;
        // C s_5362_3: cast zx s_5362_2 -> bv
        let s_5362_3: Bits = Bits::new(s_5362_2 as u128, 3u16);
        // D s_5362_4: cmp-eq s_5362_1 s_5362_3
        let s_5362_4: bool = ((s_5362_1) == (s_5362_3));
        // D s_5362_5: write-var gs#117795 <= s_5362_4
        fn_state.gs_117795 = s_5362_4;
        // N s_5362_6: jump b557
        return block_557(state, tracer, fn_state);
    }
    fn block_5363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5363_0: read-var opc1:u8
        let s_5363_0: u8 = fn_state.opc1;
        // D s_5363_1: cast zx s_5363_0 -> bv
        let s_5363_1: Bits = Bits::new(s_5363_0 as u128, 3u16);
        // C s_5363_2: const #0u : u8
        let s_5363_2: u8 = 0;
        // C s_5363_3: cast zx s_5363_2 -> bv
        let s_5363_3: Bits = Bits::new(s_5363_2 as u128, 3u16);
        // D s_5363_4: cmp-eq s_5363_1 s_5363_3
        let s_5363_4: bool = ((s_5363_1) == (s_5363_3));
        // D s_5363_5: write-var gs#117794 <= s_5363_4
        fn_state.gs_117794 = s_5363_4;
        // N s_5363_6: jump b555
        return block_555(state, tracer, fn_state);
    }
    fn block_5364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5364_0: read-var coproc:u8
        let s_5364_0: u8 = fn_state.coproc;
        // D s_5364_1: cast zx s_5364_0 -> bv
        let s_5364_1: Bits = Bits::new(s_5364_0 as u128, 4u16);
        // C s_5364_2: const #14u : u8
        let s_5364_2: u8 = 14;
        // C s_5364_3: cast zx s_5364_2 -> bv
        let s_5364_3: Bits = Bits::new(s_5364_2 as u128, 4u16);
        // D s_5364_4: cmp-eq s_5364_1 s_5364_3
        let s_5364_4: bool = ((s_5364_1) == (s_5364_3));
        // D s_5364_5: write-var gs#117793 <= s_5364_4
        fn_state.gs_117793 = s_5364_4;
        // N s_5364_6: jump b553
        return block_553(state, tracer, fn_state);
    }
    fn block_5365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5365_0: read-var CRn:u8
        let s_5365_0: u8 = fn_state.CRn;
        // D s_5365_1: cast zx s_5365_0 -> bv
        let s_5365_1: Bits = Bits::new(s_5365_0 as u128, 4u16);
        // C s_5365_2: const #1u : u8
        let s_5365_2: u8 = 1;
        // C s_5365_3: cast zx s_5365_2 -> bv
        let s_5365_3: Bits = Bits::new(s_5365_2 as u128, 4u16);
        // D s_5365_4: cmp-eq s_5365_1 s_5365_3
        let s_5365_4: bool = ((s_5365_1) == (s_5365_3));
        // D s_5365_5: write-var gs#117792 <= s_5365_4
        fn_state.gs_117792 = s_5365_4;
        // N s_5365_6: jump b551
        return block_551(state, tracer, fn_state);
    }
    fn block_5366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5366_0: read-var el:u8
        let s_5366_0: u8 = fn_state.el;
        // D s_5366_1: read-var coproc:u8
        let s_5366_1: u8 = fn_state.coproc;
        // D s_5366_2: read-var opc1:u8
        let s_5366_2: u8 = fn_state.opc1;
        // D s_5366_3: read-var CRn:u8
        let s_5366_3: u8 = fn_state.CRn;
        // D s_5366_4: read-var opc2:u8
        let s_5366_4: u8 = fn_state.opc2;
        // D s_5366_5: read-var CRm:u8
        let s_5366_5: u8 = fn_state.CRm;
        // D s_5366_6: read-var t:i
        let s_5366_6: i128 = fn_state.t;
        // D s_5366_7: call DBGBXVR_SysRegRead32_78ef58571ab2de22(s_5366_0, s_5366_1, s_5366_2, s_5366_3, s_5366_4, s_5366_5, s_5366_6)
        let s_5366_7: () = DBGBXVR_SysRegRead32_78ef58571ab2de22(
            state,
            tracer,
            s_5366_0,
            s_5366_1,
            s_5366_2,
            s_5366_3,
            s_5366_4,
            s_5366_5,
            s_5366_6,
        );
        // N s_5366_8: return
        return;
    }
    fn block_5367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5367_0: read-var opc2:u8
        let s_5367_0: u8 = fn_state.opc2;
        // D s_5367_1: cast zx s_5367_0 -> bv
        let s_5367_1: Bits = Bits::new(s_5367_0 as u128, 3u16);
        // C s_5367_2: const #1u : u8
        let s_5367_2: u8 = 1;
        // C s_5367_3: cast zx s_5367_2 -> bv
        let s_5367_3: Bits = Bits::new(s_5367_2 as u128, 3u16);
        // D s_5367_4: cmp-eq s_5367_1 s_5367_3
        let s_5367_4: bool = ((s_5367_1) == (s_5367_3));
        // D s_5367_5: write-var gs#117791 <= s_5367_4
        fn_state.gs_117791 = s_5367_4;
        // N s_5367_6: jump b548
        return block_548(state, tracer, fn_state);
    }
    fn block_5368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5368_0: read-var opc1:u8
        let s_5368_0: u8 = fn_state.opc1;
        // D s_5368_1: cast zx s_5368_0 -> bv
        let s_5368_1: Bits = Bits::new(s_5368_0 as u128, 3u16);
        // C s_5368_2: const #0u : u8
        let s_5368_2: u8 = 0;
        // C s_5368_3: cast zx s_5368_2 -> bv
        let s_5368_3: Bits = Bits::new(s_5368_2 as u128, 3u16);
        // D s_5368_4: cmp-eq s_5368_1 s_5368_3
        let s_5368_4: bool = ((s_5368_1) == (s_5368_3));
        // D s_5368_5: write-var gs#117790 <= s_5368_4
        fn_state.gs_117790 = s_5368_4;
        // N s_5368_6: jump b546
        return block_546(state, tracer, fn_state);
    }
    fn block_5369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5369_0: read-var coproc:u8
        let s_5369_0: u8 = fn_state.coproc;
        // D s_5369_1: cast zx s_5369_0 -> bv
        let s_5369_1: Bits = Bits::new(s_5369_0 as u128, 4u16);
        // C s_5369_2: const #14u : u8
        let s_5369_2: u8 = 14;
        // C s_5369_3: cast zx s_5369_2 -> bv
        let s_5369_3: Bits = Bits::new(s_5369_2 as u128, 4u16);
        // D s_5369_4: cmp-eq s_5369_1 s_5369_3
        let s_5369_4: bool = ((s_5369_1) == (s_5369_3));
        // D s_5369_5: write-var gs#117789 <= s_5369_4
        fn_state.gs_117789 = s_5369_4;
        // N s_5369_6: jump b544
        return block_544(state, tracer, fn_state);
    }
    fn block_5370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5370_0: read-var CRn:u8
        let s_5370_0: u8 = fn_state.CRn;
        // D s_5370_1: cast zx s_5370_0 -> bv
        let s_5370_1: Bits = Bits::new(s_5370_0 as u128, 4u16);
        // C s_5370_2: const #1u : u8
        let s_5370_2: u8 = 1;
        // C s_5370_3: cast zx s_5370_2 -> bv
        let s_5370_3: Bits = Bits::new(s_5370_2 as u128, 4u16);
        // D s_5370_4: cmp-eq s_5370_1 s_5370_3
        let s_5370_4: bool = ((s_5370_1) == (s_5370_3));
        // D s_5370_5: write-var gs#117788 <= s_5370_4
        fn_state.gs_117788 = s_5370_4;
        // N s_5370_6: jump b542
        return block_542(state, tracer, fn_state);
    }
    fn block_5371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5371_0: read-var el:u8
        let s_5371_0: u8 = fn_state.el;
        // D s_5371_1: read-var coproc:u8
        let s_5371_1: u8 = fn_state.coproc;
        // D s_5371_2: read-var opc1:u8
        let s_5371_2: u8 = fn_state.opc1;
        // D s_5371_3: read-var CRn:u8
        let s_5371_3: u8 = fn_state.CRn;
        // D s_5371_4: read-var opc2:u8
        let s_5371_4: u8 = fn_state.opc2;
        // D s_5371_5: read-var CRm:u8
        let s_5371_5: u8 = fn_state.CRm;
        // D s_5371_6: read-var t:i
        let s_5371_6: i128 = fn_state.t;
        // D s_5371_7: call DBGBXVR_SysRegRead32_8e4aad430b2ecf98(s_5371_0, s_5371_1, s_5371_2, s_5371_3, s_5371_4, s_5371_5, s_5371_6)
        let s_5371_7: () = DBGBXVR_SysRegRead32_8e4aad430b2ecf98(
            state,
            tracer,
            s_5371_0,
            s_5371_1,
            s_5371_2,
            s_5371_3,
            s_5371_4,
            s_5371_5,
            s_5371_6,
        );
        // N s_5371_8: return
        return;
    }
    fn block_5372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5372_0: read-var opc2:u8
        let s_5372_0: u8 = fn_state.opc2;
        // D s_5372_1: cast zx s_5372_0 -> bv
        let s_5372_1: Bits = Bits::new(s_5372_0 as u128, 3u16);
        // C s_5372_2: const #1u : u8
        let s_5372_2: u8 = 1;
        // C s_5372_3: cast zx s_5372_2 -> bv
        let s_5372_3: Bits = Bits::new(s_5372_2 as u128, 3u16);
        // D s_5372_4: cmp-eq s_5372_1 s_5372_3
        let s_5372_4: bool = ((s_5372_1) == (s_5372_3));
        // D s_5372_5: write-var gs#117787 <= s_5372_4
        fn_state.gs_117787 = s_5372_4;
        // N s_5372_6: jump b539
        return block_539(state, tracer, fn_state);
    }
    fn block_5373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5373_0: read-var opc1:u8
        let s_5373_0: u8 = fn_state.opc1;
        // D s_5373_1: cast zx s_5373_0 -> bv
        let s_5373_1: Bits = Bits::new(s_5373_0 as u128, 3u16);
        // C s_5373_2: const #0u : u8
        let s_5373_2: u8 = 0;
        // C s_5373_3: cast zx s_5373_2 -> bv
        let s_5373_3: Bits = Bits::new(s_5373_2 as u128, 3u16);
        // D s_5373_4: cmp-eq s_5373_1 s_5373_3
        let s_5373_4: bool = ((s_5373_1) == (s_5373_3));
        // D s_5373_5: write-var gs#117786 <= s_5373_4
        fn_state.gs_117786 = s_5373_4;
        // N s_5373_6: jump b537
        return block_537(state, tracer, fn_state);
    }
    fn block_5374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5374_0: read-var coproc:u8
        let s_5374_0: u8 = fn_state.coproc;
        // D s_5374_1: cast zx s_5374_0 -> bv
        let s_5374_1: Bits = Bits::new(s_5374_0 as u128, 4u16);
        // C s_5374_2: const #14u : u8
        let s_5374_2: u8 = 14;
        // C s_5374_3: cast zx s_5374_2 -> bv
        let s_5374_3: Bits = Bits::new(s_5374_2 as u128, 4u16);
        // D s_5374_4: cmp-eq s_5374_1 s_5374_3
        let s_5374_4: bool = ((s_5374_1) == (s_5374_3));
        // D s_5374_5: write-var gs#117785 <= s_5374_4
        fn_state.gs_117785 = s_5374_4;
        // N s_5374_6: jump b535
        return block_535(state, tracer, fn_state);
    }
    fn block_5375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5375_0: read-var CRn:u8
        let s_5375_0: u8 = fn_state.CRn;
        // D s_5375_1: cast zx s_5375_0 -> bv
        let s_5375_1: Bits = Bits::new(s_5375_0 as u128, 4u16);
        // C s_5375_2: const #1u : u8
        let s_5375_2: u8 = 1;
        // C s_5375_3: cast zx s_5375_2 -> bv
        let s_5375_3: Bits = Bits::new(s_5375_2 as u128, 4u16);
        // D s_5375_4: cmp-eq s_5375_1 s_5375_3
        let s_5375_4: bool = ((s_5375_1) == (s_5375_3));
        // D s_5375_5: write-var gs#117784 <= s_5375_4
        fn_state.gs_117784 = s_5375_4;
        // N s_5375_6: jump b533
        return block_533(state, tracer, fn_state);
    }
    fn block_5376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5376_0: read-var el:u8
        let s_5376_0: u8 = fn_state.el;
        // D s_5376_1: read-var coproc:u8
        let s_5376_1: u8 = fn_state.coproc;
        // D s_5376_2: read-var opc1:u8
        let s_5376_2: u8 = fn_state.opc1;
        // D s_5376_3: read-var CRn:u8
        let s_5376_3: u8 = fn_state.CRn;
        // D s_5376_4: read-var opc2:u8
        let s_5376_4: u8 = fn_state.opc2;
        // D s_5376_5: read-var CRm:u8
        let s_5376_5: u8 = fn_state.CRm;
        // D s_5376_6: read-var t:i
        let s_5376_6: i128 = fn_state.t;
        // D s_5376_7: call DBGBXVR_SysRegRead32_7ae84360e0b64934(s_5376_0, s_5376_1, s_5376_2, s_5376_3, s_5376_4, s_5376_5, s_5376_6)
        let s_5376_7: () = DBGBXVR_SysRegRead32_7ae84360e0b64934(
            state,
            tracer,
            s_5376_0,
            s_5376_1,
            s_5376_2,
            s_5376_3,
            s_5376_4,
            s_5376_5,
            s_5376_6,
        );
        // N s_5376_8: return
        return;
    }
    fn block_5377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5377_0: read-var opc2:u8
        let s_5377_0: u8 = fn_state.opc2;
        // D s_5377_1: cast zx s_5377_0 -> bv
        let s_5377_1: Bits = Bits::new(s_5377_0 as u128, 3u16);
        // C s_5377_2: const #1u : u8
        let s_5377_2: u8 = 1;
        // C s_5377_3: cast zx s_5377_2 -> bv
        let s_5377_3: Bits = Bits::new(s_5377_2 as u128, 3u16);
        // D s_5377_4: cmp-eq s_5377_1 s_5377_3
        let s_5377_4: bool = ((s_5377_1) == (s_5377_3));
        // D s_5377_5: write-var gs#117783 <= s_5377_4
        fn_state.gs_117783 = s_5377_4;
        // N s_5377_6: jump b530
        return block_530(state, tracer, fn_state);
    }
    fn block_5378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5378_0: read-var opc1:u8
        let s_5378_0: u8 = fn_state.opc1;
        // D s_5378_1: cast zx s_5378_0 -> bv
        let s_5378_1: Bits = Bits::new(s_5378_0 as u128, 3u16);
        // C s_5378_2: const #0u : u8
        let s_5378_2: u8 = 0;
        // C s_5378_3: cast zx s_5378_2 -> bv
        let s_5378_3: Bits = Bits::new(s_5378_2 as u128, 3u16);
        // D s_5378_4: cmp-eq s_5378_1 s_5378_3
        let s_5378_4: bool = ((s_5378_1) == (s_5378_3));
        // D s_5378_5: write-var gs#117782 <= s_5378_4
        fn_state.gs_117782 = s_5378_4;
        // N s_5378_6: jump b528
        return block_528(state, tracer, fn_state);
    }
    fn block_5379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5379_0: read-var coproc:u8
        let s_5379_0: u8 = fn_state.coproc;
        // D s_5379_1: cast zx s_5379_0 -> bv
        let s_5379_1: Bits = Bits::new(s_5379_0 as u128, 4u16);
        // C s_5379_2: const #14u : u8
        let s_5379_2: u8 = 14;
        // C s_5379_3: cast zx s_5379_2 -> bv
        let s_5379_3: Bits = Bits::new(s_5379_2 as u128, 4u16);
        // D s_5379_4: cmp-eq s_5379_1 s_5379_3
        let s_5379_4: bool = ((s_5379_1) == (s_5379_3));
        // D s_5379_5: write-var gs#117781 <= s_5379_4
        fn_state.gs_117781 = s_5379_4;
        // N s_5379_6: jump b526
        return block_526(state, tracer, fn_state);
    }
    fn block_5380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5380_0: read-var CRn:u8
        let s_5380_0: u8 = fn_state.CRn;
        // D s_5380_1: cast zx s_5380_0 -> bv
        let s_5380_1: Bits = Bits::new(s_5380_0 as u128, 4u16);
        // C s_5380_2: const #1u : u8
        let s_5380_2: u8 = 1;
        // C s_5380_3: cast zx s_5380_2 -> bv
        let s_5380_3: Bits = Bits::new(s_5380_2 as u128, 4u16);
        // D s_5380_4: cmp-eq s_5380_1 s_5380_3
        let s_5380_4: bool = ((s_5380_1) == (s_5380_3));
        // D s_5380_5: write-var gs#117780 <= s_5380_4
        fn_state.gs_117780 = s_5380_4;
        // N s_5380_6: jump b524
        return block_524(state, tracer, fn_state);
    }
    fn block_5381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5381_0: read-var el:u8
        let s_5381_0: u8 = fn_state.el;
        // D s_5381_1: read-var coproc:u8
        let s_5381_1: u8 = fn_state.coproc;
        // D s_5381_2: read-var opc1:u8
        let s_5381_2: u8 = fn_state.opc1;
        // D s_5381_3: read-var CRn:u8
        let s_5381_3: u8 = fn_state.CRn;
        // D s_5381_4: read-var opc2:u8
        let s_5381_4: u8 = fn_state.opc2;
        // D s_5381_5: read-var CRm:u8
        let s_5381_5: u8 = fn_state.CRm;
        // D s_5381_6: read-var t:i
        let s_5381_6: i128 = fn_state.t;
        // D s_5381_7: call DBGBXVR_SysRegRead32_56d437c5026e56e6(s_5381_0, s_5381_1, s_5381_2, s_5381_3, s_5381_4, s_5381_5, s_5381_6)
        let s_5381_7: () = DBGBXVR_SysRegRead32_56d437c5026e56e6(
            state,
            tracer,
            s_5381_0,
            s_5381_1,
            s_5381_2,
            s_5381_3,
            s_5381_4,
            s_5381_5,
            s_5381_6,
        );
        // N s_5381_8: return
        return;
    }
    fn block_5382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5382_0: read-var opc2:u8
        let s_5382_0: u8 = fn_state.opc2;
        // D s_5382_1: cast zx s_5382_0 -> bv
        let s_5382_1: Bits = Bits::new(s_5382_0 as u128, 3u16);
        // C s_5382_2: const #1u : u8
        let s_5382_2: u8 = 1;
        // C s_5382_3: cast zx s_5382_2 -> bv
        let s_5382_3: Bits = Bits::new(s_5382_2 as u128, 3u16);
        // D s_5382_4: cmp-eq s_5382_1 s_5382_3
        let s_5382_4: bool = ((s_5382_1) == (s_5382_3));
        // D s_5382_5: write-var gs#117779 <= s_5382_4
        fn_state.gs_117779 = s_5382_4;
        // N s_5382_6: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_5383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5383_0: read-var opc1:u8
        let s_5383_0: u8 = fn_state.opc1;
        // D s_5383_1: cast zx s_5383_0 -> bv
        let s_5383_1: Bits = Bits::new(s_5383_0 as u128, 3u16);
        // C s_5383_2: const #0u : u8
        let s_5383_2: u8 = 0;
        // C s_5383_3: cast zx s_5383_2 -> bv
        let s_5383_3: Bits = Bits::new(s_5383_2 as u128, 3u16);
        // D s_5383_4: cmp-eq s_5383_1 s_5383_3
        let s_5383_4: bool = ((s_5383_1) == (s_5383_3));
        // D s_5383_5: write-var gs#117778 <= s_5383_4
        fn_state.gs_117778 = s_5383_4;
        // N s_5383_6: jump b519
        return block_519(state, tracer, fn_state);
    }
    fn block_5384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5384_0: read-var coproc:u8
        let s_5384_0: u8 = fn_state.coproc;
        // D s_5384_1: cast zx s_5384_0 -> bv
        let s_5384_1: Bits = Bits::new(s_5384_0 as u128, 4u16);
        // C s_5384_2: const #14u : u8
        let s_5384_2: u8 = 14;
        // C s_5384_3: cast zx s_5384_2 -> bv
        let s_5384_3: Bits = Bits::new(s_5384_2 as u128, 4u16);
        // D s_5384_4: cmp-eq s_5384_1 s_5384_3
        let s_5384_4: bool = ((s_5384_1) == (s_5384_3));
        // D s_5384_5: write-var gs#117777 <= s_5384_4
        fn_state.gs_117777 = s_5384_4;
        // N s_5384_6: jump b517
        return block_517(state, tracer, fn_state);
    }
    fn block_5385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5385_0: read-var CRn:u8
        let s_5385_0: u8 = fn_state.CRn;
        // D s_5385_1: cast zx s_5385_0 -> bv
        let s_5385_1: Bits = Bits::new(s_5385_0 as u128, 4u16);
        // C s_5385_2: const #1u : u8
        let s_5385_2: u8 = 1;
        // C s_5385_3: cast zx s_5385_2 -> bv
        let s_5385_3: Bits = Bits::new(s_5385_2 as u128, 4u16);
        // D s_5385_4: cmp-eq s_5385_1 s_5385_3
        let s_5385_4: bool = ((s_5385_1) == (s_5385_3));
        // D s_5385_5: write-var gs#117776 <= s_5385_4
        fn_state.gs_117776 = s_5385_4;
        // N s_5385_6: jump b515
        return block_515(state, tracer, fn_state);
    }
    fn block_5386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5386_0: read-var el:u8
        let s_5386_0: u8 = fn_state.el;
        // D s_5386_1: read-var coproc:u8
        let s_5386_1: u8 = fn_state.coproc;
        // D s_5386_2: read-var opc1:u8
        let s_5386_2: u8 = fn_state.opc1;
        // D s_5386_3: read-var CRn:u8
        let s_5386_3: u8 = fn_state.CRn;
        // D s_5386_4: read-var opc2:u8
        let s_5386_4: u8 = fn_state.opc2;
        // D s_5386_5: read-var CRm:u8
        let s_5386_5: u8 = fn_state.CRm;
        // D s_5386_6: read-var t:i
        let s_5386_6: i128 = fn_state.t;
        // D s_5386_7: call DBGBXVR_SysRegRead32_e8fd3bc58d8acce2(s_5386_0, s_5386_1, s_5386_2, s_5386_3, s_5386_4, s_5386_5, s_5386_6)
        let s_5386_7: () = DBGBXVR_SysRegRead32_e8fd3bc58d8acce2(
            state,
            tracer,
            s_5386_0,
            s_5386_1,
            s_5386_2,
            s_5386_3,
            s_5386_4,
            s_5386_5,
            s_5386_6,
        );
        // N s_5386_8: return
        return;
    }
    fn block_5387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5387_0: read-var opc2:u8
        let s_5387_0: u8 = fn_state.opc2;
        // D s_5387_1: cast zx s_5387_0 -> bv
        let s_5387_1: Bits = Bits::new(s_5387_0 as u128, 3u16);
        // C s_5387_2: const #1u : u8
        let s_5387_2: u8 = 1;
        // C s_5387_3: cast zx s_5387_2 -> bv
        let s_5387_3: Bits = Bits::new(s_5387_2 as u128, 3u16);
        // D s_5387_4: cmp-eq s_5387_1 s_5387_3
        let s_5387_4: bool = ((s_5387_1) == (s_5387_3));
        // D s_5387_5: write-var gs#117775 <= s_5387_4
        fn_state.gs_117775 = s_5387_4;
        // N s_5387_6: jump b512
        return block_512(state, tracer, fn_state);
    }
    fn block_5388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5388_0: read-var opc1:u8
        let s_5388_0: u8 = fn_state.opc1;
        // D s_5388_1: cast zx s_5388_0 -> bv
        let s_5388_1: Bits = Bits::new(s_5388_0 as u128, 3u16);
        // C s_5388_2: const #0u : u8
        let s_5388_2: u8 = 0;
        // C s_5388_3: cast zx s_5388_2 -> bv
        let s_5388_3: Bits = Bits::new(s_5388_2 as u128, 3u16);
        // D s_5388_4: cmp-eq s_5388_1 s_5388_3
        let s_5388_4: bool = ((s_5388_1) == (s_5388_3));
        // D s_5388_5: write-var gs#117774 <= s_5388_4
        fn_state.gs_117774 = s_5388_4;
        // N s_5388_6: jump b510
        return block_510(state, tracer, fn_state);
    }
    fn block_5389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5389_0: read-var coproc:u8
        let s_5389_0: u8 = fn_state.coproc;
        // D s_5389_1: cast zx s_5389_0 -> bv
        let s_5389_1: Bits = Bits::new(s_5389_0 as u128, 4u16);
        // C s_5389_2: const #14u : u8
        let s_5389_2: u8 = 14;
        // C s_5389_3: cast zx s_5389_2 -> bv
        let s_5389_3: Bits = Bits::new(s_5389_2 as u128, 4u16);
        // D s_5389_4: cmp-eq s_5389_1 s_5389_3
        let s_5389_4: bool = ((s_5389_1) == (s_5389_3));
        // D s_5389_5: write-var gs#117773 <= s_5389_4
        fn_state.gs_117773 = s_5389_4;
        // N s_5389_6: jump b508
        return block_508(state, tracer, fn_state);
    }
    fn block_5390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5390_0: read-var CRn:u8
        let s_5390_0: u8 = fn_state.CRn;
        // D s_5390_1: cast zx s_5390_0 -> bv
        let s_5390_1: Bits = Bits::new(s_5390_0 as u128, 4u16);
        // C s_5390_2: const #1u : u8
        let s_5390_2: u8 = 1;
        // C s_5390_3: cast zx s_5390_2 -> bv
        let s_5390_3: Bits = Bits::new(s_5390_2 as u128, 4u16);
        // D s_5390_4: cmp-eq s_5390_1 s_5390_3
        let s_5390_4: bool = ((s_5390_1) == (s_5390_3));
        // D s_5390_5: write-var gs#117772 <= s_5390_4
        fn_state.gs_117772 = s_5390_4;
        // N s_5390_6: jump b506
        return block_506(state, tracer, fn_state);
    }
    fn block_5391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5391_0: read-var el:u8
        let s_5391_0: u8 = fn_state.el;
        // D s_5391_1: read-var coproc:u8
        let s_5391_1: u8 = fn_state.coproc;
        // D s_5391_2: read-var opc1:u8
        let s_5391_2: u8 = fn_state.opc1;
        // D s_5391_3: read-var CRn:u8
        let s_5391_3: u8 = fn_state.CRn;
        // D s_5391_4: read-var opc2:u8
        let s_5391_4: u8 = fn_state.opc2;
        // D s_5391_5: read-var CRm:u8
        let s_5391_5: u8 = fn_state.CRm;
        // D s_5391_6: read-var t:i
        let s_5391_6: i128 = fn_state.t;
        // D s_5391_7: call DBGBXVR_SysRegRead32_745a1f5c08c2c352(s_5391_0, s_5391_1, s_5391_2, s_5391_3, s_5391_4, s_5391_5, s_5391_6)
        let s_5391_7: () = DBGBXVR_SysRegRead32_745a1f5c08c2c352(
            state,
            tracer,
            s_5391_0,
            s_5391_1,
            s_5391_2,
            s_5391_3,
            s_5391_4,
            s_5391_5,
            s_5391_6,
        );
        // N s_5391_8: return
        return;
    }
    fn block_5392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5392_0: read-var opc2:u8
        let s_5392_0: u8 = fn_state.opc2;
        // D s_5392_1: cast zx s_5392_0 -> bv
        let s_5392_1: Bits = Bits::new(s_5392_0 as u128, 3u16);
        // C s_5392_2: const #1u : u8
        let s_5392_2: u8 = 1;
        // C s_5392_3: cast zx s_5392_2 -> bv
        let s_5392_3: Bits = Bits::new(s_5392_2 as u128, 3u16);
        // D s_5392_4: cmp-eq s_5392_1 s_5392_3
        let s_5392_4: bool = ((s_5392_1) == (s_5392_3));
        // D s_5392_5: write-var gs#117771 <= s_5392_4
        fn_state.gs_117771 = s_5392_4;
        // N s_5392_6: jump b503
        return block_503(state, tracer, fn_state);
    }
    fn block_5393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5393_0: read-var opc1:u8
        let s_5393_0: u8 = fn_state.opc1;
        // D s_5393_1: cast zx s_5393_0 -> bv
        let s_5393_1: Bits = Bits::new(s_5393_0 as u128, 3u16);
        // C s_5393_2: const #0u : u8
        let s_5393_2: u8 = 0;
        // C s_5393_3: cast zx s_5393_2 -> bv
        let s_5393_3: Bits = Bits::new(s_5393_2 as u128, 3u16);
        // D s_5393_4: cmp-eq s_5393_1 s_5393_3
        let s_5393_4: bool = ((s_5393_1) == (s_5393_3));
        // D s_5393_5: write-var gs#117770 <= s_5393_4
        fn_state.gs_117770 = s_5393_4;
        // N s_5393_6: jump b501
        return block_501(state, tracer, fn_state);
    }
    fn block_5394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5394_0: read-var coproc:u8
        let s_5394_0: u8 = fn_state.coproc;
        // D s_5394_1: cast zx s_5394_0 -> bv
        let s_5394_1: Bits = Bits::new(s_5394_0 as u128, 4u16);
        // C s_5394_2: const #14u : u8
        let s_5394_2: u8 = 14;
        // C s_5394_3: cast zx s_5394_2 -> bv
        let s_5394_3: Bits = Bits::new(s_5394_2 as u128, 4u16);
        // D s_5394_4: cmp-eq s_5394_1 s_5394_3
        let s_5394_4: bool = ((s_5394_1) == (s_5394_3));
        // D s_5394_5: write-var gs#117769 <= s_5394_4
        fn_state.gs_117769 = s_5394_4;
        // N s_5394_6: jump b499
        return block_499(state, tracer, fn_state);
    }
    fn block_5395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5395_0: read-var CRn:u8
        let s_5395_0: u8 = fn_state.CRn;
        // D s_5395_1: cast zx s_5395_0 -> bv
        let s_5395_1: Bits = Bits::new(s_5395_0 as u128, 4u16);
        // C s_5395_2: const #1u : u8
        let s_5395_2: u8 = 1;
        // C s_5395_3: cast zx s_5395_2 -> bv
        let s_5395_3: Bits = Bits::new(s_5395_2 as u128, 4u16);
        // D s_5395_4: cmp-eq s_5395_1 s_5395_3
        let s_5395_4: bool = ((s_5395_1) == (s_5395_3));
        // D s_5395_5: write-var gs#117768 <= s_5395_4
        fn_state.gs_117768 = s_5395_4;
        // N s_5395_6: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_5396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5396_0: read-var el:u8
        let s_5396_0: u8 = fn_state.el;
        // D s_5396_1: read-var coproc:u8
        let s_5396_1: u8 = fn_state.coproc;
        // D s_5396_2: read-var opc1:u8
        let s_5396_2: u8 = fn_state.opc1;
        // D s_5396_3: read-var CRn:u8
        let s_5396_3: u8 = fn_state.CRn;
        // D s_5396_4: read-var opc2:u8
        let s_5396_4: u8 = fn_state.opc2;
        // D s_5396_5: read-var CRm:u8
        let s_5396_5: u8 = fn_state.CRm;
        // D s_5396_6: read-var t:i
        let s_5396_6: i128 = fn_state.t;
        // D s_5396_7: call DBGBXVR_SysRegRead32_fa2068509c645345(s_5396_0, s_5396_1, s_5396_2, s_5396_3, s_5396_4, s_5396_5, s_5396_6)
        let s_5396_7: () = DBGBXVR_SysRegRead32_fa2068509c645345(
            state,
            tracer,
            s_5396_0,
            s_5396_1,
            s_5396_2,
            s_5396_3,
            s_5396_4,
            s_5396_5,
            s_5396_6,
        );
        // N s_5396_8: return
        return;
    }
    fn block_5397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5397_0: read-var opc2:u8
        let s_5397_0: u8 = fn_state.opc2;
        // D s_5397_1: cast zx s_5397_0 -> bv
        let s_5397_1: Bits = Bits::new(s_5397_0 as u128, 3u16);
        // C s_5397_2: const #1u : u8
        let s_5397_2: u8 = 1;
        // C s_5397_3: cast zx s_5397_2 -> bv
        let s_5397_3: Bits = Bits::new(s_5397_2 as u128, 3u16);
        // D s_5397_4: cmp-eq s_5397_1 s_5397_3
        let s_5397_4: bool = ((s_5397_1) == (s_5397_3));
        // D s_5397_5: write-var gs#117767 <= s_5397_4
        fn_state.gs_117767 = s_5397_4;
        // N s_5397_6: jump b494
        return block_494(state, tracer, fn_state);
    }
    fn block_5398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5398_0: read-var opc1:u8
        let s_5398_0: u8 = fn_state.opc1;
        // D s_5398_1: cast zx s_5398_0 -> bv
        let s_5398_1: Bits = Bits::new(s_5398_0 as u128, 3u16);
        // C s_5398_2: const #0u : u8
        let s_5398_2: u8 = 0;
        // C s_5398_3: cast zx s_5398_2 -> bv
        let s_5398_3: Bits = Bits::new(s_5398_2 as u128, 3u16);
        // D s_5398_4: cmp-eq s_5398_1 s_5398_3
        let s_5398_4: bool = ((s_5398_1) == (s_5398_3));
        // D s_5398_5: write-var gs#117766 <= s_5398_4
        fn_state.gs_117766 = s_5398_4;
        // N s_5398_6: jump b492
        return block_492(state, tracer, fn_state);
    }
    fn block_5399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5399_0: read-var coproc:u8
        let s_5399_0: u8 = fn_state.coproc;
        // D s_5399_1: cast zx s_5399_0 -> bv
        let s_5399_1: Bits = Bits::new(s_5399_0 as u128, 4u16);
        // C s_5399_2: const #14u : u8
        let s_5399_2: u8 = 14;
        // C s_5399_3: cast zx s_5399_2 -> bv
        let s_5399_3: Bits = Bits::new(s_5399_2 as u128, 4u16);
        // D s_5399_4: cmp-eq s_5399_1 s_5399_3
        let s_5399_4: bool = ((s_5399_1) == (s_5399_3));
        // D s_5399_5: write-var gs#117765 <= s_5399_4
        fn_state.gs_117765 = s_5399_4;
        // N s_5399_6: jump b490
        return block_490(state, tracer, fn_state);
    }
    fn block_5400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5400_0: read-var CRn:u8
        let s_5400_0: u8 = fn_state.CRn;
        // D s_5400_1: cast zx s_5400_0 -> bv
        let s_5400_1: Bits = Bits::new(s_5400_0 as u128, 4u16);
        // C s_5400_2: const #1u : u8
        let s_5400_2: u8 = 1;
        // C s_5400_3: cast zx s_5400_2 -> bv
        let s_5400_3: Bits = Bits::new(s_5400_2 as u128, 4u16);
        // D s_5400_4: cmp-eq s_5400_1 s_5400_3
        let s_5400_4: bool = ((s_5400_1) == (s_5400_3));
        // D s_5400_5: write-var gs#117764 <= s_5400_4
        fn_state.gs_117764 = s_5400_4;
        // N s_5400_6: jump b488
        return block_488(state, tracer, fn_state);
    }
    fn block_5401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5401_0: read-var el:u8
        let s_5401_0: u8 = fn_state.el;
        // D s_5401_1: read-var coproc:u8
        let s_5401_1: u8 = fn_state.coproc;
        // D s_5401_2: read-var opc1:u8
        let s_5401_2: u8 = fn_state.opc1;
        // D s_5401_3: read-var CRn:u8
        let s_5401_3: u8 = fn_state.CRn;
        // D s_5401_4: read-var opc2:u8
        let s_5401_4: u8 = fn_state.opc2;
        // D s_5401_5: read-var CRm:u8
        let s_5401_5: u8 = fn_state.CRm;
        // D s_5401_6: read-var t:i
        let s_5401_6: i128 = fn_state.t;
        // D s_5401_7: call DBGBXVR_SysRegRead32_e9303c37358e3794(s_5401_0, s_5401_1, s_5401_2, s_5401_3, s_5401_4, s_5401_5, s_5401_6)
        let s_5401_7: () = DBGBXVR_SysRegRead32_e9303c37358e3794(
            state,
            tracer,
            s_5401_0,
            s_5401_1,
            s_5401_2,
            s_5401_3,
            s_5401_4,
            s_5401_5,
            s_5401_6,
        );
        // N s_5401_8: return
        return;
    }
    fn block_5402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5402_0: read-var opc2:u8
        let s_5402_0: u8 = fn_state.opc2;
        // D s_5402_1: cast zx s_5402_0 -> bv
        let s_5402_1: Bits = Bits::new(s_5402_0 as u128, 3u16);
        // C s_5402_2: const #1u : u8
        let s_5402_2: u8 = 1;
        // C s_5402_3: cast zx s_5402_2 -> bv
        let s_5402_3: Bits = Bits::new(s_5402_2 as u128, 3u16);
        // D s_5402_4: cmp-eq s_5402_1 s_5402_3
        let s_5402_4: bool = ((s_5402_1) == (s_5402_3));
        // D s_5402_5: write-var gs#117763 <= s_5402_4
        fn_state.gs_117763 = s_5402_4;
        // N s_5402_6: jump b485
        return block_485(state, tracer, fn_state);
    }
    fn block_5403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5403_0: read-var opc1:u8
        let s_5403_0: u8 = fn_state.opc1;
        // D s_5403_1: cast zx s_5403_0 -> bv
        let s_5403_1: Bits = Bits::new(s_5403_0 as u128, 3u16);
        // C s_5403_2: const #0u : u8
        let s_5403_2: u8 = 0;
        // C s_5403_3: cast zx s_5403_2 -> bv
        let s_5403_3: Bits = Bits::new(s_5403_2 as u128, 3u16);
        // D s_5403_4: cmp-eq s_5403_1 s_5403_3
        let s_5403_4: bool = ((s_5403_1) == (s_5403_3));
        // D s_5403_5: write-var gs#117762 <= s_5403_4
        fn_state.gs_117762 = s_5403_4;
        // N s_5403_6: jump b483
        return block_483(state, tracer, fn_state);
    }
    fn block_5404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5404_0: read-var coproc:u8
        let s_5404_0: u8 = fn_state.coproc;
        // D s_5404_1: cast zx s_5404_0 -> bv
        let s_5404_1: Bits = Bits::new(s_5404_0 as u128, 4u16);
        // C s_5404_2: const #14u : u8
        let s_5404_2: u8 = 14;
        // C s_5404_3: cast zx s_5404_2 -> bv
        let s_5404_3: Bits = Bits::new(s_5404_2 as u128, 4u16);
        // D s_5404_4: cmp-eq s_5404_1 s_5404_3
        let s_5404_4: bool = ((s_5404_1) == (s_5404_3));
        // D s_5404_5: write-var gs#117761 <= s_5404_4
        fn_state.gs_117761 = s_5404_4;
        // N s_5404_6: jump b481
        return block_481(state, tracer, fn_state);
    }
    fn block_5405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5405_0: read-var CRn:u8
        let s_5405_0: u8 = fn_state.CRn;
        // D s_5405_1: cast zx s_5405_0 -> bv
        let s_5405_1: Bits = Bits::new(s_5405_0 as u128, 4u16);
        // C s_5405_2: const #1u : u8
        let s_5405_2: u8 = 1;
        // C s_5405_3: cast zx s_5405_2 -> bv
        let s_5405_3: Bits = Bits::new(s_5405_2 as u128, 4u16);
        // D s_5405_4: cmp-eq s_5405_1 s_5405_3
        let s_5405_4: bool = ((s_5405_1) == (s_5405_3));
        // D s_5405_5: write-var gs#117760 <= s_5405_4
        fn_state.gs_117760 = s_5405_4;
        // N s_5405_6: jump b479
        return block_479(state, tracer, fn_state);
    }
    fn block_5406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5406_0: read-var el:u8
        let s_5406_0: u8 = fn_state.el;
        // D s_5406_1: read-var coproc:u8
        let s_5406_1: u8 = fn_state.coproc;
        // D s_5406_2: read-var opc1:u8
        let s_5406_2: u8 = fn_state.opc1;
        // D s_5406_3: read-var CRn:u8
        let s_5406_3: u8 = fn_state.CRn;
        // D s_5406_4: read-var opc2:u8
        let s_5406_4: u8 = fn_state.opc2;
        // D s_5406_5: read-var CRm:u8
        let s_5406_5: u8 = fn_state.CRm;
        // D s_5406_6: read-var t:i
        let s_5406_6: i128 = fn_state.t;
        // D s_5406_7: call DBGBXVR_SysRegRead32_1c27a604d2b4f32b(s_5406_0, s_5406_1, s_5406_2, s_5406_3, s_5406_4, s_5406_5, s_5406_6)
        let s_5406_7: () = DBGBXVR_SysRegRead32_1c27a604d2b4f32b(
            state,
            tracer,
            s_5406_0,
            s_5406_1,
            s_5406_2,
            s_5406_3,
            s_5406_4,
            s_5406_5,
            s_5406_6,
        );
        // N s_5406_8: return
        return;
    }
    fn block_5407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5407_0: read-var opc2:u8
        let s_5407_0: u8 = fn_state.opc2;
        // D s_5407_1: cast zx s_5407_0 -> bv
        let s_5407_1: Bits = Bits::new(s_5407_0 as u128, 3u16);
        // C s_5407_2: const #1u : u8
        let s_5407_2: u8 = 1;
        // C s_5407_3: cast zx s_5407_2 -> bv
        let s_5407_3: Bits = Bits::new(s_5407_2 as u128, 3u16);
        // D s_5407_4: cmp-eq s_5407_1 s_5407_3
        let s_5407_4: bool = ((s_5407_1) == (s_5407_3));
        // D s_5407_5: write-var gs#117759 <= s_5407_4
        fn_state.gs_117759 = s_5407_4;
        // N s_5407_6: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_5408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5408_0: read-var opc1:u8
        let s_5408_0: u8 = fn_state.opc1;
        // D s_5408_1: cast zx s_5408_0 -> bv
        let s_5408_1: Bits = Bits::new(s_5408_0 as u128, 3u16);
        // C s_5408_2: const #0u : u8
        let s_5408_2: u8 = 0;
        // C s_5408_3: cast zx s_5408_2 -> bv
        let s_5408_3: Bits = Bits::new(s_5408_2 as u128, 3u16);
        // D s_5408_4: cmp-eq s_5408_1 s_5408_3
        let s_5408_4: bool = ((s_5408_1) == (s_5408_3));
        // D s_5408_5: write-var gs#117758 <= s_5408_4
        fn_state.gs_117758 = s_5408_4;
        // N s_5408_6: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_5409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5409_0: read-var coproc:u8
        let s_5409_0: u8 = fn_state.coproc;
        // D s_5409_1: cast zx s_5409_0 -> bv
        let s_5409_1: Bits = Bits::new(s_5409_0 as u128, 4u16);
        // C s_5409_2: const #14u : u8
        let s_5409_2: u8 = 14;
        // C s_5409_3: cast zx s_5409_2 -> bv
        let s_5409_3: Bits = Bits::new(s_5409_2 as u128, 4u16);
        // D s_5409_4: cmp-eq s_5409_1 s_5409_3
        let s_5409_4: bool = ((s_5409_1) == (s_5409_3));
        // D s_5409_5: write-var gs#117757 <= s_5409_4
        fn_state.gs_117757 = s_5409_4;
        // N s_5409_6: jump b472
        return block_472(state, tracer, fn_state);
    }
    fn block_5410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5410_0: read-var CRn:u8
        let s_5410_0: u8 = fn_state.CRn;
        // D s_5410_1: cast zx s_5410_0 -> bv
        let s_5410_1: Bits = Bits::new(s_5410_0 as u128, 4u16);
        // C s_5410_2: const #1u : u8
        let s_5410_2: u8 = 1;
        // C s_5410_3: cast zx s_5410_2 -> bv
        let s_5410_3: Bits = Bits::new(s_5410_2 as u128, 4u16);
        // D s_5410_4: cmp-eq s_5410_1 s_5410_3
        let s_5410_4: bool = ((s_5410_1) == (s_5410_3));
        // D s_5410_5: write-var gs#117756 <= s_5410_4
        fn_state.gs_117756 = s_5410_4;
        // N s_5410_6: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_5411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5411_0: read-var el:u8
        let s_5411_0: u8 = fn_state.el;
        // D s_5411_1: read-var coproc:u8
        let s_5411_1: u8 = fn_state.coproc;
        // D s_5411_2: read-var opc1:u8
        let s_5411_2: u8 = fn_state.opc1;
        // D s_5411_3: read-var CRn:u8
        let s_5411_3: u8 = fn_state.CRn;
        // D s_5411_4: read-var opc2:u8
        let s_5411_4: u8 = fn_state.opc2;
        // D s_5411_5: read-var CRm:u8
        let s_5411_5: u8 = fn_state.CRm;
        // D s_5411_6: read-var t:i
        let s_5411_6: i128 = fn_state.t;
        // D s_5411_7: call DBGBXVR_SysRegRead32_7511d8f154b2cfe2(s_5411_0, s_5411_1, s_5411_2, s_5411_3, s_5411_4, s_5411_5, s_5411_6)
        let s_5411_7: () = DBGBXVR_SysRegRead32_7511d8f154b2cfe2(
            state,
            tracer,
            s_5411_0,
            s_5411_1,
            s_5411_2,
            s_5411_3,
            s_5411_4,
            s_5411_5,
            s_5411_6,
        );
        // N s_5411_8: return
        return;
    }
    fn block_5412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5412_0: read-var opc2:u8
        let s_5412_0: u8 = fn_state.opc2;
        // D s_5412_1: cast zx s_5412_0 -> bv
        let s_5412_1: Bits = Bits::new(s_5412_0 as u128, 3u16);
        // C s_5412_2: const #1u : u8
        let s_5412_2: u8 = 1;
        // C s_5412_3: cast zx s_5412_2 -> bv
        let s_5412_3: Bits = Bits::new(s_5412_2 as u128, 3u16);
        // D s_5412_4: cmp-eq s_5412_1 s_5412_3
        let s_5412_4: bool = ((s_5412_1) == (s_5412_3));
        // D s_5412_5: write-var gs#117755 <= s_5412_4
        fn_state.gs_117755 = s_5412_4;
        // N s_5412_6: jump b467
        return block_467(state, tracer, fn_state);
    }
    fn block_5413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5413_0: read-var opc1:u8
        let s_5413_0: u8 = fn_state.opc1;
        // D s_5413_1: cast zx s_5413_0 -> bv
        let s_5413_1: Bits = Bits::new(s_5413_0 as u128, 3u16);
        // C s_5413_2: const #0u : u8
        let s_5413_2: u8 = 0;
        // C s_5413_3: cast zx s_5413_2 -> bv
        let s_5413_3: Bits = Bits::new(s_5413_2 as u128, 3u16);
        // D s_5413_4: cmp-eq s_5413_1 s_5413_3
        let s_5413_4: bool = ((s_5413_1) == (s_5413_3));
        // D s_5413_5: write-var gs#117754 <= s_5413_4
        fn_state.gs_117754 = s_5413_4;
        // N s_5413_6: jump b465
        return block_465(state, tracer, fn_state);
    }
    fn block_5414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5414_0: read-var coproc:u8
        let s_5414_0: u8 = fn_state.coproc;
        // D s_5414_1: cast zx s_5414_0 -> bv
        let s_5414_1: Bits = Bits::new(s_5414_0 as u128, 4u16);
        // C s_5414_2: const #14u : u8
        let s_5414_2: u8 = 14;
        // C s_5414_3: cast zx s_5414_2 -> bv
        let s_5414_3: Bits = Bits::new(s_5414_2 as u128, 4u16);
        // D s_5414_4: cmp-eq s_5414_1 s_5414_3
        let s_5414_4: bool = ((s_5414_1) == (s_5414_3));
        // D s_5414_5: write-var gs#117753 <= s_5414_4
        fn_state.gs_117753 = s_5414_4;
        // N s_5414_6: jump b463
        return block_463(state, tracer, fn_state);
    }
    fn block_5415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5415_0: read-var CRn:u8
        let s_5415_0: u8 = fn_state.CRn;
        // D s_5415_1: cast zx s_5415_0 -> bv
        let s_5415_1: Bits = Bits::new(s_5415_0 as u128, 4u16);
        // C s_5415_2: const #1u : u8
        let s_5415_2: u8 = 1;
        // C s_5415_3: cast zx s_5415_2 -> bv
        let s_5415_3: Bits = Bits::new(s_5415_2 as u128, 4u16);
        // D s_5415_4: cmp-eq s_5415_1 s_5415_3
        let s_5415_4: bool = ((s_5415_1) == (s_5415_3));
        // D s_5415_5: write-var gs#117752 <= s_5415_4
        fn_state.gs_117752 = s_5415_4;
        // N s_5415_6: jump b461
        return block_461(state, tracer, fn_state);
    }
    fn block_5416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5416_0: read-var el:u8
        let s_5416_0: u8 = fn_state.el;
        // D s_5416_1: read-var coproc:u8
        let s_5416_1: u8 = fn_state.coproc;
        // D s_5416_2: read-var opc1:u8
        let s_5416_2: u8 = fn_state.opc1;
        // D s_5416_3: read-var CRn:u8
        let s_5416_3: u8 = fn_state.CRn;
        // D s_5416_4: read-var opc2:u8
        let s_5416_4: u8 = fn_state.opc2;
        // D s_5416_5: read-var CRm:u8
        let s_5416_5: u8 = fn_state.CRm;
        // D s_5416_6: read-var t:i
        let s_5416_6: i128 = fn_state.t;
        // D s_5416_7: call CNTHP_TVAL_SysRegRead32_fdd1a67f3e306983(s_5416_0, s_5416_1, s_5416_2, s_5416_3, s_5416_4, s_5416_5, s_5416_6)
        let s_5416_7: () = CNTHP_TVAL_SysRegRead32_fdd1a67f3e306983(
            state,
            tracer,
            s_5416_0,
            s_5416_1,
            s_5416_2,
            s_5416_3,
            s_5416_4,
            s_5416_5,
            s_5416_6,
        );
        // N s_5416_8: return
        return;
    }
    fn block_5417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5417_0: read-var opc2:u8
        let s_5417_0: u8 = fn_state.opc2;
        // D s_5417_1: cast zx s_5417_0 -> bv
        let s_5417_1: Bits = Bits::new(s_5417_0 as u128, 3u16);
        // C s_5417_2: const #0u : u8
        let s_5417_2: u8 = 0;
        // C s_5417_3: cast zx s_5417_2 -> bv
        let s_5417_3: Bits = Bits::new(s_5417_2 as u128, 3u16);
        // D s_5417_4: cmp-eq s_5417_1 s_5417_3
        let s_5417_4: bool = ((s_5417_1) == (s_5417_3));
        // D s_5417_5: write-var gs#117751 <= s_5417_4
        fn_state.gs_117751 = s_5417_4;
        // N s_5417_6: jump b458
        return block_458(state, tracer, fn_state);
    }
    fn block_5418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5418_0: read-var opc1:u8
        let s_5418_0: u8 = fn_state.opc1;
        // D s_5418_1: cast zx s_5418_0 -> bv
        let s_5418_1: Bits = Bits::new(s_5418_0 as u128, 3u16);
        // C s_5418_2: const #0u : u8
        let s_5418_2: u8 = 0;
        // C s_5418_3: cast zx s_5418_2 -> bv
        let s_5418_3: Bits = Bits::new(s_5418_2 as u128, 3u16);
        // D s_5418_4: cmp-eq s_5418_1 s_5418_3
        let s_5418_4: bool = ((s_5418_1) == (s_5418_3));
        // D s_5418_5: write-var gs#117750 <= s_5418_4
        fn_state.gs_117750 = s_5418_4;
        // N s_5418_6: jump b456
        return block_456(state, tracer, fn_state);
    }
    fn block_5419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5419_0: read-var coproc:u8
        let s_5419_0: u8 = fn_state.coproc;
        // D s_5419_1: cast zx s_5419_0 -> bv
        let s_5419_1: Bits = Bits::new(s_5419_0 as u128, 4u16);
        // C s_5419_2: const #15u : u8
        let s_5419_2: u8 = 15;
        // C s_5419_3: cast zx s_5419_2 -> bv
        let s_5419_3: Bits = Bits::new(s_5419_2 as u128, 4u16);
        // D s_5419_4: cmp-eq s_5419_1 s_5419_3
        let s_5419_4: bool = ((s_5419_1) == (s_5419_3));
        // D s_5419_5: write-var gs#117749 <= s_5419_4
        fn_state.gs_117749 = s_5419_4;
        // N s_5419_6: jump b454
        return block_454(state, tracer, fn_state);
    }
    fn block_5420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5420_0: read-var CRn:u8
        let s_5420_0: u8 = fn_state.CRn;
        // D s_5420_1: cast zx s_5420_0 -> bv
        let s_5420_1: Bits = Bits::new(s_5420_0 as u128, 4u16);
        // C s_5420_2: const #14u : u8
        let s_5420_2: u8 = 14;
        // C s_5420_3: cast zx s_5420_2 -> bv
        let s_5420_3: Bits = Bits::new(s_5420_2 as u128, 4u16);
        // D s_5420_4: cmp-eq s_5420_1 s_5420_3
        let s_5420_4: bool = ((s_5420_1) == (s_5420_3));
        // D s_5420_5: write-var gs#117748 <= s_5420_4
        fn_state.gs_117748 = s_5420_4;
        // N s_5420_6: jump b452
        return block_452(state, tracer, fn_state);
    }
    fn block_5421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5421_0: read-var el:u8
        let s_5421_0: u8 = fn_state.el;
        // D s_5421_1: read-var coproc:u8
        let s_5421_1: u8 = fn_state.coproc;
        // D s_5421_2: read-var opc1:u8
        let s_5421_2: u8 = fn_state.opc1;
        // D s_5421_3: read-var CRn:u8
        let s_5421_3: u8 = fn_state.CRn;
        // D s_5421_4: read-var opc2:u8
        let s_5421_4: u8 = fn_state.opc2;
        // D s_5421_5: read-var CRm:u8
        let s_5421_5: u8 = fn_state.CRm;
        // D s_5421_6: read-var t:i
        let s_5421_6: i128 = fn_state.t;
        // D s_5421_7: call CNTHP_TVAL_SysRegRead32_ea212b21a99af571(s_5421_0, s_5421_1, s_5421_2, s_5421_3, s_5421_4, s_5421_5, s_5421_6)
        let s_5421_7: () = CNTHP_TVAL_SysRegRead32_ea212b21a99af571(
            state,
            tracer,
            s_5421_0,
            s_5421_1,
            s_5421_2,
            s_5421_3,
            s_5421_4,
            s_5421_5,
            s_5421_6,
        );
        // N s_5421_8: return
        return;
    }
    fn block_5422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5422_0: read-var opc2:u8
        let s_5422_0: u8 = fn_state.opc2;
        // D s_5422_1: cast zx s_5422_0 -> bv
        let s_5422_1: Bits = Bits::new(s_5422_0 as u128, 3u16);
        // C s_5422_2: const #0u : u8
        let s_5422_2: u8 = 0;
        // C s_5422_3: cast zx s_5422_2 -> bv
        let s_5422_3: Bits = Bits::new(s_5422_2 as u128, 3u16);
        // D s_5422_4: cmp-eq s_5422_1 s_5422_3
        let s_5422_4: bool = ((s_5422_1) == (s_5422_3));
        // D s_5422_5: write-var gs#117747 <= s_5422_4
        fn_state.gs_117747 = s_5422_4;
        // N s_5422_6: jump b449
        return block_449(state, tracer, fn_state);
    }
    fn block_5423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5423_0: read-var opc1:u8
        let s_5423_0: u8 = fn_state.opc1;
        // D s_5423_1: cast zx s_5423_0 -> bv
        let s_5423_1: Bits = Bits::new(s_5423_0 as u128, 3u16);
        // C s_5423_2: const #4u : u8
        let s_5423_2: u8 = 4;
        // C s_5423_3: cast zx s_5423_2 -> bv
        let s_5423_3: Bits = Bits::new(s_5423_2 as u128, 3u16);
        // D s_5423_4: cmp-eq s_5423_1 s_5423_3
        let s_5423_4: bool = ((s_5423_1) == (s_5423_3));
        // D s_5423_5: write-var gs#117746 <= s_5423_4
        fn_state.gs_117746 = s_5423_4;
        // N s_5423_6: jump b447
        return block_447(state, tracer, fn_state);
    }
    fn block_5424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5424_0: read-var coproc:u8
        let s_5424_0: u8 = fn_state.coproc;
        // D s_5424_1: cast zx s_5424_0 -> bv
        let s_5424_1: Bits = Bits::new(s_5424_0 as u128, 4u16);
        // C s_5424_2: const #15u : u8
        let s_5424_2: u8 = 15;
        // C s_5424_3: cast zx s_5424_2 -> bv
        let s_5424_3: Bits = Bits::new(s_5424_2 as u128, 4u16);
        // D s_5424_4: cmp-eq s_5424_1 s_5424_3
        let s_5424_4: bool = ((s_5424_1) == (s_5424_3));
        // D s_5424_5: write-var gs#117745 <= s_5424_4
        fn_state.gs_117745 = s_5424_4;
        // N s_5424_6: jump b445
        return block_445(state, tracer, fn_state);
    }
    fn block_5425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5425_0: read-var CRn:u8
        let s_5425_0: u8 = fn_state.CRn;
        // D s_5425_1: cast zx s_5425_0 -> bv
        let s_5425_1: Bits = Bits::new(s_5425_0 as u128, 4u16);
        // C s_5425_2: const #14u : u8
        let s_5425_2: u8 = 14;
        // C s_5425_3: cast zx s_5425_2 -> bv
        let s_5425_3: Bits = Bits::new(s_5425_2 as u128, 4u16);
        // D s_5425_4: cmp-eq s_5425_1 s_5425_3
        let s_5425_4: bool = ((s_5425_1) == (s_5425_3));
        // D s_5425_5: write-var gs#117744 <= s_5425_4
        fn_state.gs_117744 = s_5425_4;
        // N s_5425_6: jump b443
        return block_443(state, tracer, fn_state);
    }
    fn block_5426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5426_0: read-var el:u8
        let s_5426_0: u8 = fn_state.el;
        // D s_5426_1: read-var coproc:u8
        let s_5426_1: u8 = fn_state.coproc;
        // D s_5426_2: read-var opc1:u8
        let s_5426_2: u8 = fn_state.opc1;
        // D s_5426_3: read-var CRn:u8
        let s_5426_3: u8 = fn_state.CRn;
        // D s_5426_4: read-var opc2:u8
        let s_5426_4: u8 = fn_state.opc2;
        // D s_5426_5: read-var CRm:u8
        let s_5426_5: u8 = fn_state.CRm;
        // D s_5426_6: read-var t:i
        let s_5426_6: i128 = fn_state.t;
        // D s_5426_7: call ICV_CTLR_SysRegRead32_084685ae7c38b87e(s_5426_0, s_5426_1, s_5426_2, s_5426_3, s_5426_4, s_5426_5, s_5426_6)
        let s_5426_7: () = ICV_CTLR_SysRegRead32_084685ae7c38b87e(
            state,
            tracer,
            s_5426_0,
            s_5426_1,
            s_5426_2,
            s_5426_3,
            s_5426_4,
            s_5426_5,
            s_5426_6,
        );
        // N s_5426_8: return
        return;
    }
    fn block_5427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5427_0: read-var opc2:u8
        let s_5427_0: u8 = fn_state.opc2;
        // D s_5427_1: cast zx s_5427_0 -> bv
        let s_5427_1: Bits = Bits::new(s_5427_0 as u128, 3u16);
        // C s_5427_2: const #4u : u8
        let s_5427_2: u8 = 4;
        // C s_5427_3: cast zx s_5427_2 -> bv
        let s_5427_3: Bits = Bits::new(s_5427_2 as u128, 3u16);
        // D s_5427_4: cmp-eq s_5427_1 s_5427_3
        let s_5427_4: bool = ((s_5427_1) == (s_5427_3));
        // D s_5427_5: write-var gs#117743 <= s_5427_4
        fn_state.gs_117743 = s_5427_4;
        // N s_5427_6: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_5428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5428_0: read-var opc1:u8
        let s_5428_0: u8 = fn_state.opc1;
        // D s_5428_1: cast zx s_5428_0 -> bv
        let s_5428_1: Bits = Bits::new(s_5428_0 as u128, 3u16);
        // C s_5428_2: const #0u : u8
        let s_5428_2: u8 = 0;
        // C s_5428_3: cast zx s_5428_2 -> bv
        let s_5428_3: Bits = Bits::new(s_5428_2 as u128, 3u16);
        // D s_5428_4: cmp-eq s_5428_1 s_5428_3
        let s_5428_4: bool = ((s_5428_1) == (s_5428_3));
        // D s_5428_5: write-var gs#117742 <= s_5428_4
        fn_state.gs_117742 = s_5428_4;
        // N s_5428_6: jump b438
        return block_438(state, tracer, fn_state);
    }
    fn block_5429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5429_0: read-var coproc:u8
        let s_5429_0: u8 = fn_state.coproc;
        // D s_5429_1: cast zx s_5429_0 -> bv
        let s_5429_1: Bits = Bits::new(s_5429_0 as u128, 4u16);
        // C s_5429_2: const #15u : u8
        let s_5429_2: u8 = 15;
        // C s_5429_3: cast zx s_5429_2 -> bv
        let s_5429_3: Bits = Bits::new(s_5429_2 as u128, 4u16);
        // D s_5429_4: cmp-eq s_5429_1 s_5429_3
        let s_5429_4: bool = ((s_5429_1) == (s_5429_3));
        // D s_5429_5: write-var gs#117741 <= s_5429_4
        fn_state.gs_117741 = s_5429_4;
        // N s_5429_6: jump b436
        return block_436(state, tracer, fn_state);
    }
    fn block_5430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5430_0: read-var CRn:u8
        let s_5430_0: u8 = fn_state.CRn;
        // D s_5430_1: cast zx s_5430_0 -> bv
        let s_5430_1: Bits = Bits::new(s_5430_0 as u128, 4u16);
        // C s_5430_2: const #12u : u8
        let s_5430_2: u8 = 12;
        // C s_5430_3: cast zx s_5430_2 -> bv
        let s_5430_3: Bits = Bits::new(s_5430_2 as u128, 4u16);
        // D s_5430_4: cmp-eq s_5430_1 s_5430_3
        let s_5430_4: bool = ((s_5430_1) == (s_5430_3));
        // D s_5430_5: write-var gs#117740 <= s_5430_4
        fn_state.gs_117740 = s_5430_4;
        // N s_5430_6: jump b434
        return block_434(state, tracer, fn_state);
    }
    fn block_5431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5431_0: read-var el:u8
        let s_5431_0: u8 = fn_state.el;
        // D s_5431_1: read-var coproc:u8
        let s_5431_1: u8 = fn_state.coproc;
        // D s_5431_2: read-var opc1:u8
        let s_5431_2: u8 = fn_state.opc1;
        // D s_5431_3: read-var CRn:u8
        let s_5431_3: u8 = fn_state.CRn;
        // D s_5431_4: read-var opc2:u8
        let s_5431_4: u8 = fn_state.opc2;
        // D s_5431_5: read-var CRm:u8
        let s_5431_5: u8 = fn_state.CRm;
        // D s_5431_6: read-var t:i
        let s_5431_6: i128 = fn_state.t;
        // D s_5431_7: call PMCEID0_SysRegRead32_827b64f588d9ff2d(s_5431_0, s_5431_1, s_5431_2, s_5431_3, s_5431_4, s_5431_5, s_5431_6)
        let s_5431_7: () = PMCEID0_SysRegRead32_827b64f588d9ff2d(
            state,
            tracer,
            s_5431_0,
            s_5431_1,
            s_5431_2,
            s_5431_3,
            s_5431_4,
            s_5431_5,
            s_5431_6,
        );
        // N s_5431_8: return
        return;
    }
    fn block_5432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5432_0: read-var opc2:u8
        let s_5432_0: u8 = fn_state.opc2;
        // D s_5432_1: cast zx s_5432_0 -> bv
        let s_5432_1: Bits = Bits::new(s_5432_0 as u128, 3u16);
        // C s_5432_2: const #6u : u8
        let s_5432_2: u8 = 6;
        // C s_5432_3: cast zx s_5432_2 -> bv
        let s_5432_3: Bits = Bits::new(s_5432_2 as u128, 3u16);
        // D s_5432_4: cmp-eq s_5432_1 s_5432_3
        let s_5432_4: bool = ((s_5432_1) == (s_5432_3));
        // D s_5432_5: write-var gs#117739 <= s_5432_4
        fn_state.gs_117739 = s_5432_4;
        // N s_5432_6: jump b431
        return block_431(state, tracer, fn_state);
    }
    fn block_5433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5433_0: read-var opc1:u8
        let s_5433_0: u8 = fn_state.opc1;
        // D s_5433_1: cast zx s_5433_0 -> bv
        let s_5433_1: Bits = Bits::new(s_5433_0 as u128, 3u16);
        // C s_5433_2: const #0u : u8
        let s_5433_2: u8 = 0;
        // C s_5433_3: cast zx s_5433_2 -> bv
        let s_5433_3: Bits = Bits::new(s_5433_2 as u128, 3u16);
        // D s_5433_4: cmp-eq s_5433_1 s_5433_3
        let s_5433_4: bool = ((s_5433_1) == (s_5433_3));
        // D s_5433_5: write-var gs#117738 <= s_5433_4
        fn_state.gs_117738 = s_5433_4;
        // N s_5433_6: jump b429
        return block_429(state, tracer, fn_state);
    }
    fn block_5434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5434_0: read-var coproc:u8
        let s_5434_0: u8 = fn_state.coproc;
        // D s_5434_1: cast zx s_5434_0 -> bv
        let s_5434_1: Bits = Bits::new(s_5434_0 as u128, 4u16);
        // C s_5434_2: const #15u : u8
        let s_5434_2: u8 = 15;
        // C s_5434_3: cast zx s_5434_2 -> bv
        let s_5434_3: Bits = Bits::new(s_5434_2 as u128, 4u16);
        // D s_5434_4: cmp-eq s_5434_1 s_5434_3
        let s_5434_4: bool = ((s_5434_1) == (s_5434_3));
        // D s_5434_5: write-var gs#117737 <= s_5434_4
        fn_state.gs_117737 = s_5434_4;
        // N s_5434_6: jump b427
        return block_427(state, tracer, fn_state);
    }
    fn block_5435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5435_0: read-var CRn:u8
        let s_5435_0: u8 = fn_state.CRn;
        // D s_5435_1: cast zx s_5435_0 -> bv
        let s_5435_1: Bits = Bits::new(s_5435_0 as u128, 4u16);
        // C s_5435_2: const #9u : u8
        let s_5435_2: u8 = 9;
        // C s_5435_3: cast zx s_5435_2 -> bv
        let s_5435_3: Bits = Bits::new(s_5435_2 as u128, 4u16);
        // D s_5435_4: cmp-eq s_5435_1 s_5435_3
        let s_5435_4: bool = ((s_5435_1) == (s_5435_3));
        // D s_5435_5: write-var gs#117736 <= s_5435_4
        fn_state.gs_117736 = s_5435_4;
        // N s_5435_6: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_5436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5436_0: read-var el:u8
        let s_5436_0: u8 = fn_state.el;
        // D s_5436_1: read-var coproc:u8
        let s_5436_1: u8 = fn_state.coproc;
        // D s_5436_2: read-var opc1:u8
        let s_5436_2: u8 = fn_state.opc1;
        // D s_5436_3: read-var CRn:u8
        let s_5436_3: u8 = fn_state.CRn;
        // D s_5436_4: read-var opc2:u8
        let s_5436_4: u8 = fn_state.opc2;
        // D s_5436_5: read-var CRm:u8
        let s_5436_5: u8 = fn_state.CRm;
        // D s_5436_6: read-var t:i
        let s_5436_6: i128 = fn_state.t;
        // D s_5436_7: call PRRR_SysRegRead32_4a556a683141be75(s_5436_0, s_5436_1, s_5436_2, s_5436_3, s_5436_4, s_5436_5, s_5436_6)
        let s_5436_7: () = PRRR_SysRegRead32_4a556a683141be75(
            state,
            tracer,
            s_5436_0,
            s_5436_1,
            s_5436_2,
            s_5436_3,
            s_5436_4,
            s_5436_5,
            s_5436_6,
        );
        // N s_5436_8: return
        return;
    }
    fn block_5437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5437_0: read-var opc2:u8
        let s_5437_0: u8 = fn_state.opc2;
        // D s_5437_1: cast zx s_5437_0 -> bv
        let s_5437_1: Bits = Bits::new(s_5437_0 as u128, 3u16);
        // C s_5437_2: const #0u : u8
        let s_5437_2: u8 = 0;
        // C s_5437_3: cast zx s_5437_2 -> bv
        let s_5437_3: Bits = Bits::new(s_5437_2 as u128, 3u16);
        // D s_5437_4: cmp-eq s_5437_1 s_5437_3
        let s_5437_4: bool = ((s_5437_1) == (s_5437_3));
        // D s_5437_5: write-var gs#117735 <= s_5437_4
        fn_state.gs_117735 = s_5437_4;
        // N s_5437_6: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_5438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5438_0: read-var opc1:u8
        let s_5438_0: u8 = fn_state.opc1;
        // D s_5438_1: cast zx s_5438_0 -> bv
        let s_5438_1: Bits = Bits::new(s_5438_0 as u128, 3u16);
        // C s_5438_2: const #0u : u8
        let s_5438_2: u8 = 0;
        // C s_5438_3: cast zx s_5438_2 -> bv
        let s_5438_3: Bits = Bits::new(s_5438_2 as u128, 3u16);
        // D s_5438_4: cmp-eq s_5438_1 s_5438_3
        let s_5438_4: bool = ((s_5438_1) == (s_5438_3));
        // D s_5438_5: write-var gs#117734 <= s_5438_4
        fn_state.gs_117734 = s_5438_4;
        // N s_5438_6: jump b420
        return block_420(state, tracer, fn_state);
    }
    fn block_5439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5439_0: read-var coproc:u8
        let s_5439_0: u8 = fn_state.coproc;
        // D s_5439_1: cast zx s_5439_0 -> bv
        let s_5439_1: Bits = Bits::new(s_5439_0 as u128, 4u16);
        // C s_5439_2: const #15u : u8
        let s_5439_2: u8 = 15;
        // C s_5439_3: cast zx s_5439_2 -> bv
        let s_5439_3: Bits = Bits::new(s_5439_2 as u128, 4u16);
        // D s_5439_4: cmp-eq s_5439_1 s_5439_3
        let s_5439_4: bool = ((s_5439_1) == (s_5439_3));
        // D s_5439_5: write-var gs#117733 <= s_5439_4
        fn_state.gs_117733 = s_5439_4;
        // N s_5439_6: jump b418
        return block_418(state, tracer, fn_state);
    }
    fn block_5440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5440_0: read-var CRn:u8
        let s_5440_0: u8 = fn_state.CRn;
        // D s_5440_1: cast zx s_5440_0 -> bv
        let s_5440_1: Bits = Bits::new(s_5440_0 as u128, 4u16);
        // C s_5440_2: const #10u : u8
        let s_5440_2: u8 = 10;
        // C s_5440_3: cast zx s_5440_2 -> bv
        let s_5440_3: Bits = Bits::new(s_5440_2 as u128, 4u16);
        // D s_5440_4: cmp-eq s_5440_1 s_5440_3
        let s_5440_4: bool = ((s_5440_1) == (s_5440_3));
        // D s_5440_5: write-var gs#117732 <= s_5440_4
        fn_state.gs_117732 = s_5440_4;
        // N s_5440_6: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_5441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5441_0: read-var el:u8
        let s_5441_0: u8 = fn_state.el;
        // D s_5441_1: read-var coproc:u8
        let s_5441_1: u8 = fn_state.coproc;
        // D s_5441_2: read-var opc1:u8
        let s_5441_2: u8 = fn_state.opc1;
        // D s_5441_3: read-var CRn:u8
        let s_5441_3: u8 = fn_state.CRn;
        // D s_5441_4: read-var opc2:u8
        let s_5441_4: u8 = fn_state.opc2;
        // D s_5441_5: read-var CRm:u8
        let s_5441_5: u8 = fn_state.CRm;
        // D s_5441_6: read-var t:i
        let s_5441_6: i128 = fn_state.t;
        // D s_5441_7: call ID_MMFR3_SysRegRead32_e386d40c006b0b90(s_5441_0, s_5441_1, s_5441_2, s_5441_3, s_5441_4, s_5441_5, s_5441_6)
        let s_5441_7: () = ID_MMFR3_SysRegRead32_e386d40c006b0b90(
            state,
            tracer,
            s_5441_0,
            s_5441_1,
            s_5441_2,
            s_5441_3,
            s_5441_4,
            s_5441_5,
            s_5441_6,
        );
        // N s_5441_8: return
        return;
    }
    fn block_5442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5442_0: read-var opc2:u8
        let s_5442_0: u8 = fn_state.opc2;
        // D s_5442_1: cast zx s_5442_0 -> bv
        let s_5442_1: Bits = Bits::new(s_5442_0 as u128, 3u16);
        // C s_5442_2: const #7u : u8
        let s_5442_2: u8 = 7;
        // C s_5442_3: cast zx s_5442_2 -> bv
        let s_5442_3: Bits = Bits::new(s_5442_2 as u128, 3u16);
        // D s_5442_4: cmp-eq s_5442_1 s_5442_3
        let s_5442_4: bool = ((s_5442_1) == (s_5442_3));
        // D s_5442_5: write-var gs#117731 <= s_5442_4
        fn_state.gs_117731 = s_5442_4;
        // N s_5442_6: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_5443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5443_0: read-var opc1:u8
        let s_5443_0: u8 = fn_state.opc1;
        // D s_5443_1: cast zx s_5443_0 -> bv
        let s_5443_1: Bits = Bits::new(s_5443_0 as u128, 3u16);
        // C s_5443_2: const #0u : u8
        let s_5443_2: u8 = 0;
        // C s_5443_3: cast zx s_5443_2 -> bv
        let s_5443_3: Bits = Bits::new(s_5443_2 as u128, 3u16);
        // D s_5443_4: cmp-eq s_5443_1 s_5443_3
        let s_5443_4: bool = ((s_5443_1) == (s_5443_3));
        // D s_5443_5: write-var gs#117730 <= s_5443_4
        fn_state.gs_117730 = s_5443_4;
        // N s_5443_6: jump b411
        return block_411(state, tracer, fn_state);
    }
    fn block_5444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5444_0: read-var coproc:u8
        let s_5444_0: u8 = fn_state.coproc;
        // D s_5444_1: cast zx s_5444_0 -> bv
        let s_5444_1: Bits = Bits::new(s_5444_0 as u128, 4u16);
        // C s_5444_2: const #15u : u8
        let s_5444_2: u8 = 15;
        // C s_5444_3: cast zx s_5444_2 -> bv
        let s_5444_3: Bits = Bits::new(s_5444_2 as u128, 4u16);
        // D s_5444_4: cmp-eq s_5444_1 s_5444_3
        let s_5444_4: bool = ((s_5444_1) == (s_5444_3));
        // D s_5444_5: write-var gs#117729 <= s_5444_4
        fn_state.gs_117729 = s_5444_4;
        // N s_5444_6: jump b409
        return block_409(state, tracer, fn_state);
    }
    fn block_5445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5445_0: read-var CRn:u8
        let s_5445_0: u8 = fn_state.CRn;
        // D s_5445_1: cast zx s_5445_0 -> bv
        let s_5445_1: Bits = Bits::new(s_5445_0 as u128, 4u16);
        // C s_5445_2: const #0u : u8
        let s_5445_2: u8 = 0;
        // C s_5445_3: cast zx s_5445_2 -> bv
        let s_5445_3: Bits = Bits::new(s_5445_2 as u128, 4u16);
        // D s_5445_4: cmp-eq s_5445_1 s_5445_3
        let s_5445_4: bool = ((s_5445_1) == (s_5445_3));
        // D s_5445_5: write-var gs#117728 <= s_5445_4
        fn_state.gs_117728 = s_5445_4;
        // N s_5445_6: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_5446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5446_0: read-var el:u8
        let s_5446_0: u8 = fn_state.el;
        // D s_5446_1: read-var coproc:u8
        let s_5446_1: u8 = fn_state.coproc;
        // D s_5446_2: read-var opc1:u8
        let s_5446_2: u8 = fn_state.opc1;
        // D s_5446_3: read-var CRn:u8
        let s_5446_3: u8 = fn_state.CRn;
        // D s_5446_4: read-var opc2:u8
        let s_5446_4: u8 = fn_state.opc2;
        // D s_5446_5: read-var CRm:u8
        let s_5446_5: u8 = fn_state.CRm;
        // D s_5446_6: read-var t:i
        let s_5446_6: i128 = fn_state.t;
        // D s_5446_7: call ICV_IGRPEN0_SysRegRead32_762db4bb97023cca(s_5446_0, s_5446_1, s_5446_2, s_5446_3, s_5446_4, s_5446_5, s_5446_6)
        let s_5446_7: () = ICV_IGRPEN0_SysRegRead32_762db4bb97023cca(
            state,
            tracer,
            s_5446_0,
            s_5446_1,
            s_5446_2,
            s_5446_3,
            s_5446_4,
            s_5446_5,
            s_5446_6,
        );
        // N s_5446_8: return
        return;
    }
    fn block_5447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5447_0: read-var opc2:u8
        let s_5447_0: u8 = fn_state.opc2;
        // D s_5447_1: cast zx s_5447_0 -> bv
        let s_5447_1: Bits = Bits::new(s_5447_0 as u128, 3u16);
        // C s_5447_2: const #6u : u8
        let s_5447_2: u8 = 6;
        // C s_5447_3: cast zx s_5447_2 -> bv
        let s_5447_3: Bits = Bits::new(s_5447_2 as u128, 3u16);
        // D s_5447_4: cmp-eq s_5447_1 s_5447_3
        let s_5447_4: bool = ((s_5447_1) == (s_5447_3));
        // D s_5447_5: write-var gs#117727 <= s_5447_4
        fn_state.gs_117727 = s_5447_4;
        // N s_5447_6: jump b404
        return block_404(state, tracer, fn_state);
    }
    fn block_5448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5448_0: read-var opc1:u8
        let s_5448_0: u8 = fn_state.opc1;
        // D s_5448_1: cast zx s_5448_0 -> bv
        let s_5448_1: Bits = Bits::new(s_5448_0 as u128, 3u16);
        // C s_5448_2: const #0u : u8
        let s_5448_2: u8 = 0;
        // C s_5448_3: cast zx s_5448_2 -> bv
        let s_5448_3: Bits = Bits::new(s_5448_2 as u128, 3u16);
        // D s_5448_4: cmp-eq s_5448_1 s_5448_3
        let s_5448_4: bool = ((s_5448_1) == (s_5448_3));
        // D s_5448_5: write-var gs#117726 <= s_5448_4
        fn_state.gs_117726 = s_5448_4;
        // N s_5448_6: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_5449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5449_0: read-var coproc:u8
        let s_5449_0: u8 = fn_state.coproc;
        // D s_5449_1: cast zx s_5449_0 -> bv
        let s_5449_1: Bits = Bits::new(s_5449_0 as u128, 4u16);
        // C s_5449_2: const #15u : u8
        let s_5449_2: u8 = 15;
        // C s_5449_3: cast zx s_5449_2 -> bv
        let s_5449_3: Bits = Bits::new(s_5449_2 as u128, 4u16);
        // D s_5449_4: cmp-eq s_5449_1 s_5449_3
        let s_5449_4: bool = ((s_5449_1) == (s_5449_3));
        // D s_5449_5: write-var gs#117725 <= s_5449_4
        fn_state.gs_117725 = s_5449_4;
        // N s_5449_6: jump b400
        return block_400(state, tracer, fn_state);
    }
    fn block_5450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5450_0: read-var CRn:u8
        let s_5450_0: u8 = fn_state.CRn;
        // D s_5450_1: cast zx s_5450_0 -> bv
        let s_5450_1: Bits = Bits::new(s_5450_0 as u128, 4u16);
        // C s_5450_2: const #12u : u8
        let s_5450_2: u8 = 12;
        // C s_5450_3: cast zx s_5450_2 -> bv
        let s_5450_3: Bits = Bits::new(s_5450_2 as u128, 4u16);
        // D s_5450_4: cmp-eq s_5450_1 s_5450_3
        let s_5450_4: bool = ((s_5450_1) == (s_5450_3));
        // D s_5450_5: write-var gs#117724 <= s_5450_4
        fn_state.gs_117724 = s_5450_4;
        // N s_5450_6: jump b398
        return block_398(state, tracer, fn_state);
    }
    fn block_5451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5451_0: read-var el:u8
        let s_5451_0: u8 = fn_state.el;
        // D s_5451_1: read-var coproc:u8
        let s_5451_1: u8 = fn_state.coproc;
        // D s_5451_2: read-var opc1:u8
        let s_5451_2: u8 = fn_state.opc1;
        // D s_5451_3: read-var CRn:u8
        let s_5451_3: u8 = fn_state.CRn;
        // D s_5451_4: read-var opc2:u8
        let s_5451_4: u8 = fn_state.opc2;
        // D s_5451_5: read-var CRm:u8
        let s_5451_5: u8 = fn_state.CRm;
        // D s_5451_6: read-var t:i
        let s_5451_6: i128 = fn_state.t;
        // D s_5451_7: call PMCNTENSET_SysRegRead32_2d54f3b38c0729f6(s_5451_0, s_5451_1, s_5451_2, s_5451_3, s_5451_4, s_5451_5, s_5451_6)
        let s_5451_7: () = PMCNTENSET_SysRegRead32_2d54f3b38c0729f6(
            state,
            tracer,
            s_5451_0,
            s_5451_1,
            s_5451_2,
            s_5451_3,
            s_5451_4,
            s_5451_5,
            s_5451_6,
        );
        // N s_5451_8: return
        return;
    }
    fn block_5452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5452_0: read-var opc2:u8
        let s_5452_0: u8 = fn_state.opc2;
        // D s_5452_1: cast zx s_5452_0 -> bv
        let s_5452_1: Bits = Bits::new(s_5452_0 as u128, 3u16);
        // C s_5452_2: const #1u : u8
        let s_5452_2: u8 = 1;
        // C s_5452_3: cast zx s_5452_2 -> bv
        let s_5452_3: Bits = Bits::new(s_5452_2 as u128, 3u16);
        // D s_5452_4: cmp-eq s_5452_1 s_5452_3
        let s_5452_4: bool = ((s_5452_1) == (s_5452_3));
        // D s_5452_5: write-var gs#117723 <= s_5452_4
        fn_state.gs_117723 = s_5452_4;
        // N s_5452_6: jump b395
        return block_395(state, tracer, fn_state);
    }
    fn block_5453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5453_0: read-var opc1:u8
        let s_5453_0: u8 = fn_state.opc1;
        // D s_5453_1: cast zx s_5453_0 -> bv
        let s_5453_1: Bits = Bits::new(s_5453_0 as u128, 3u16);
        // C s_5453_2: const #0u : u8
        let s_5453_2: u8 = 0;
        // C s_5453_3: cast zx s_5453_2 -> bv
        let s_5453_3: Bits = Bits::new(s_5453_2 as u128, 3u16);
        // D s_5453_4: cmp-eq s_5453_1 s_5453_3
        let s_5453_4: bool = ((s_5453_1) == (s_5453_3));
        // D s_5453_5: write-var gs#117722 <= s_5453_4
        fn_state.gs_117722 = s_5453_4;
        // N s_5453_6: jump b393
        return block_393(state, tracer, fn_state);
    }
    fn block_5454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5454_0: read-var coproc:u8
        let s_5454_0: u8 = fn_state.coproc;
        // D s_5454_1: cast zx s_5454_0 -> bv
        let s_5454_1: Bits = Bits::new(s_5454_0 as u128, 4u16);
        // C s_5454_2: const #15u : u8
        let s_5454_2: u8 = 15;
        // C s_5454_3: cast zx s_5454_2 -> bv
        let s_5454_3: Bits = Bits::new(s_5454_2 as u128, 4u16);
        // D s_5454_4: cmp-eq s_5454_1 s_5454_3
        let s_5454_4: bool = ((s_5454_1) == (s_5454_3));
        // D s_5454_5: write-var gs#117721 <= s_5454_4
        fn_state.gs_117721 = s_5454_4;
        // N s_5454_6: jump b391
        return block_391(state, tracer, fn_state);
    }
    fn block_5455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5455_0: read-var CRn:u8
        let s_5455_0: u8 = fn_state.CRn;
        // D s_5455_1: cast zx s_5455_0 -> bv
        let s_5455_1: Bits = Bits::new(s_5455_0 as u128, 4u16);
        // C s_5455_2: const #9u : u8
        let s_5455_2: u8 = 9;
        // C s_5455_3: cast zx s_5455_2 -> bv
        let s_5455_3: Bits = Bits::new(s_5455_2 as u128, 4u16);
        // D s_5455_4: cmp-eq s_5455_1 s_5455_3
        let s_5455_4: bool = ((s_5455_1) == (s_5455_3));
        // D s_5455_5: write-var gs#117720 <= s_5455_4
        fn_state.gs_117720 = s_5455_4;
        // N s_5455_6: jump b389
        return block_389(state, tracer, fn_state);
    }
    fn block_5456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5456_0: read-var el:u8
        let s_5456_0: u8 = fn_state.el;
        // D s_5456_1: read-var coproc:u8
        let s_5456_1: u8 = fn_state.coproc;
        // D s_5456_2: read-var opc1:u8
        let s_5456_2: u8 = fn_state.opc1;
        // D s_5456_3: read-var CRn:u8
        let s_5456_3: u8 = fn_state.CRn;
        // D s_5456_4: read-var opc2:u8
        let s_5456_4: u8 = fn_state.opc2;
        // D s_5456_5: read-var CRm:u8
        let s_5456_5: u8 = fn_state.CRm;
        // D s_5456_6: read-var t:i
        let s_5456_6: i128 = fn_state.t;
        // D s_5456_7: call ICC_IAR0_SysRegRead32_22d846d8001a81c5(s_5456_0, s_5456_1, s_5456_2, s_5456_3, s_5456_4, s_5456_5, s_5456_6)
        let s_5456_7: () = ICC_IAR0_SysRegRead32_22d846d8001a81c5(
            state,
            tracer,
            s_5456_0,
            s_5456_1,
            s_5456_2,
            s_5456_3,
            s_5456_4,
            s_5456_5,
            s_5456_6,
        );
        // N s_5456_8: return
        return;
    }
    fn block_5457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5457_0: read-var opc2:u8
        let s_5457_0: u8 = fn_state.opc2;
        // D s_5457_1: cast zx s_5457_0 -> bv
        let s_5457_1: Bits = Bits::new(s_5457_0 as u128, 3u16);
        // C s_5457_2: const #0u : u8
        let s_5457_2: u8 = 0;
        // C s_5457_3: cast zx s_5457_2 -> bv
        let s_5457_3: Bits = Bits::new(s_5457_2 as u128, 3u16);
        // D s_5457_4: cmp-eq s_5457_1 s_5457_3
        let s_5457_4: bool = ((s_5457_1) == (s_5457_3));
        // D s_5457_5: write-var gs#117719 <= s_5457_4
        fn_state.gs_117719 = s_5457_4;
        // N s_5457_6: jump b386
        return block_386(state, tracer, fn_state);
    }
    fn block_5458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5458_0: read-var opc1:u8
        let s_5458_0: u8 = fn_state.opc1;
        // D s_5458_1: cast zx s_5458_0 -> bv
        let s_5458_1: Bits = Bits::new(s_5458_0 as u128, 3u16);
        // C s_5458_2: const #0u : u8
        let s_5458_2: u8 = 0;
        // C s_5458_3: cast zx s_5458_2 -> bv
        let s_5458_3: Bits = Bits::new(s_5458_2 as u128, 3u16);
        // D s_5458_4: cmp-eq s_5458_1 s_5458_3
        let s_5458_4: bool = ((s_5458_1) == (s_5458_3));
        // D s_5458_5: write-var gs#117718 <= s_5458_4
        fn_state.gs_117718 = s_5458_4;
        // N s_5458_6: jump b384
        return block_384(state, tracer, fn_state);
    }
    fn block_5459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5459_0: read-var coproc:u8
        let s_5459_0: u8 = fn_state.coproc;
        // D s_5459_1: cast zx s_5459_0 -> bv
        let s_5459_1: Bits = Bits::new(s_5459_0 as u128, 4u16);
        // C s_5459_2: const #15u : u8
        let s_5459_2: u8 = 15;
        // C s_5459_3: cast zx s_5459_2 -> bv
        let s_5459_3: Bits = Bits::new(s_5459_2 as u128, 4u16);
        // D s_5459_4: cmp-eq s_5459_1 s_5459_3
        let s_5459_4: bool = ((s_5459_1) == (s_5459_3));
        // D s_5459_5: write-var gs#117717 <= s_5459_4
        fn_state.gs_117717 = s_5459_4;
        // N s_5459_6: jump b382
        return block_382(state, tracer, fn_state);
    }
    fn block_5460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5460_0: read-var CRn:u8
        let s_5460_0: u8 = fn_state.CRn;
        // D s_5460_1: cast zx s_5460_0 -> bv
        let s_5460_1: Bits = Bits::new(s_5460_0 as u128, 4u16);
        // C s_5460_2: const #12u : u8
        let s_5460_2: u8 = 12;
        // C s_5460_3: cast zx s_5460_2 -> bv
        let s_5460_3: Bits = Bits::new(s_5460_2 as u128, 4u16);
        // D s_5460_4: cmp-eq s_5460_1 s_5460_3
        let s_5460_4: bool = ((s_5460_1) == (s_5460_3));
        // D s_5460_5: write-var gs#117716 <= s_5460_4
        fn_state.gs_117716 = s_5460_4;
        // N s_5460_6: jump b380
        return block_380(state, tracer, fn_state);
    }
    fn block_5461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5461_0: read-var el:u8
        let s_5461_0: u8 = fn_state.el;
        // D s_5461_1: read-var coproc:u8
        let s_5461_1: u8 = fn_state.coproc;
        // D s_5461_2: read-var opc1:u8
        let s_5461_2: u8 = fn_state.opc1;
        // D s_5461_3: read-var CRn:u8
        let s_5461_3: u8 = fn_state.CRn;
        // D s_5461_4: read-var opc2:u8
        let s_5461_4: u8 = fn_state.opc2;
        // D s_5461_5: read-var CRm:u8
        let s_5461_5: u8 = fn_state.CRm;
        // D s_5461_6: read-var t:i
        let s_5461_6: i128 = fn_state.t;
        // D s_5461_7: call DBGAUTHSTATUS_SysRegRead32_e99aa927d23f6bfc(s_5461_0, s_5461_1, s_5461_2, s_5461_3, s_5461_4, s_5461_5, s_5461_6)
        let s_5461_7: () = DBGAUTHSTATUS_SysRegRead32_e99aa927d23f6bfc(
            state,
            tracer,
            s_5461_0,
            s_5461_1,
            s_5461_2,
            s_5461_3,
            s_5461_4,
            s_5461_5,
            s_5461_6,
        );
        // N s_5461_8: return
        return;
    }
    fn block_5462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5462_0: read-var opc2:u8
        let s_5462_0: u8 = fn_state.opc2;
        // D s_5462_1: cast zx s_5462_0 -> bv
        let s_5462_1: Bits = Bits::new(s_5462_0 as u128, 3u16);
        // C s_5462_2: const #6u : u8
        let s_5462_2: u8 = 6;
        // C s_5462_3: cast zx s_5462_2 -> bv
        let s_5462_3: Bits = Bits::new(s_5462_2 as u128, 3u16);
        // D s_5462_4: cmp-eq s_5462_1 s_5462_3
        let s_5462_4: bool = ((s_5462_1) == (s_5462_3));
        // D s_5462_5: write-var gs#117715 <= s_5462_4
        fn_state.gs_117715 = s_5462_4;
        // N s_5462_6: jump b377
        return block_377(state, tracer, fn_state);
    }
    fn block_5463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5463_0: read-var opc1:u8
        let s_5463_0: u8 = fn_state.opc1;
        // D s_5463_1: cast zx s_5463_0 -> bv
        let s_5463_1: Bits = Bits::new(s_5463_0 as u128, 3u16);
        // C s_5463_2: const #0u : u8
        let s_5463_2: u8 = 0;
        // C s_5463_3: cast zx s_5463_2 -> bv
        let s_5463_3: Bits = Bits::new(s_5463_2 as u128, 3u16);
        // D s_5463_4: cmp-eq s_5463_1 s_5463_3
        let s_5463_4: bool = ((s_5463_1) == (s_5463_3));
        // D s_5463_5: write-var gs#117714 <= s_5463_4
        fn_state.gs_117714 = s_5463_4;
        // N s_5463_6: jump b375
        return block_375(state, tracer, fn_state);
    }
    fn block_5464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5464_0: read-var coproc:u8
        let s_5464_0: u8 = fn_state.coproc;
        // D s_5464_1: cast zx s_5464_0 -> bv
        let s_5464_1: Bits = Bits::new(s_5464_0 as u128, 4u16);
        // C s_5464_2: const #14u : u8
        let s_5464_2: u8 = 14;
        // C s_5464_3: cast zx s_5464_2 -> bv
        let s_5464_3: Bits = Bits::new(s_5464_2 as u128, 4u16);
        // D s_5464_4: cmp-eq s_5464_1 s_5464_3
        let s_5464_4: bool = ((s_5464_1) == (s_5464_3));
        // D s_5464_5: write-var gs#117713 <= s_5464_4
        fn_state.gs_117713 = s_5464_4;
        // N s_5464_6: jump b373
        return block_373(state, tracer, fn_state);
    }
    fn block_5465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5465_0: read-var CRn:u8
        let s_5465_0: u8 = fn_state.CRn;
        // D s_5465_1: cast zx s_5465_0 -> bv
        let s_5465_1: Bits = Bits::new(s_5465_0 as u128, 4u16);
        // C s_5465_2: const #7u : u8
        let s_5465_2: u8 = 7;
        // C s_5465_3: cast zx s_5465_2 -> bv
        let s_5465_3: Bits = Bits::new(s_5465_2 as u128, 4u16);
        // D s_5465_4: cmp-eq s_5465_1 s_5465_3
        let s_5465_4: bool = ((s_5465_1) == (s_5465_3));
        // D s_5465_5: write-var gs#117712 <= s_5465_4
        fn_state.gs_117712 = s_5465_4;
        // N s_5465_6: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_5466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5466_0: read-var el:u8
        let s_5466_0: u8 = fn_state.el;
        // D s_5466_1: read-var coproc:u8
        let s_5466_1: u8 = fn_state.coproc;
        // D s_5466_2: read-var opc1:u8
        let s_5466_2: u8 = fn_state.opc1;
        // D s_5466_3: read-var CRn:u8
        let s_5466_3: u8 = fn_state.CRn;
        // D s_5466_4: read-var opc2:u8
        let s_5466_4: u8 = fn_state.opc2;
        // D s_5466_5: read-var CRm:u8
        let s_5466_5: u8 = fn_state.CRm;
        // D s_5466_6: read-var t:i
        let s_5466_6: i128 = fn_state.t;
        // D s_5466_7: call PMCEID1_SysRegRead32_dc9c0fe15ac731b4(s_5466_0, s_5466_1, s_5466_2, s_5466_3, s_5466_4, s_5466_5, s_5466_6)
        let s_5466_7: () = PMCEID1_SysRegRead32_dc9c0fe15ac731b4(
            state,
            tracer,
            s_5466_0,
            s_5466_1,
            s_5466_2,
            s_5466_3,
            s_5466_4,
            s_5466_5,
            s_5466_6,
        );
        // N s_5466_8: return
        return;
    }
    fn block_5467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5467_0: read-var opc2:u8
        let s_5467_0: u8 = fn_state.opc2;
        // D s_5467_1: cast zx s_5467_0 -> bv
        let s_5467_1: Bits = Bits::new(s_5467_0 as u128, 3u16);
        // C s_5467_2: const #7u : u8
        let s_5467_2: u8 = 7;
        // C s_5467_3: cast zx s_5467_2 -> bv
        let s_5467_3: Bits = Bits::new(s_5467_2 as u128, 3u16);
        // D s_5467_4: cmp-eq s_5467_1 s_5467_3
        let s_5467_4: bool = ((s_5467_1) == (s_5467_3));
        // D s_5467_5: write-var gs#117711 <= s_5467_4
        fn_state.gs_117711 = s_5467_4;
        // N s_5467_6: jump b368
        return block_368(state, tracer, fn_state);
    }
    fn block_5468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5468_0: read-var opc1:u8
        let s_5468_0: u8 = fn_state.opc1;
        // D s_5468_1: cast zx s_5468_0 -> bv
        let s_5468_1: Bits = Bits::new(s_5468_0 as u128, 3u16);
        // C s_5468_2: const #0u : u8
        let s_5468_2: u8 = 0;
        // C s_5468_3: cast zx s_5468_2 -> bv
        let s_5468_3: Bits = Bits::new(s_5468_2 as u128, 3u16);
        // D s_5468_4: cmp-eq s_5468_1 s_5468_3
        let s_5468_4: bool = ((s_5468_1) == (s_5468_3));
        // D s_5468_5: write-var gs#117710 <= s_5468_4
        fn_state.gs_117710 = s_5468_4;
        // N s_5468_6: jump b366
        return block_366(state, tracer, fn_state);
    }
    fn block_5469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5469_0: read-var coproc:u8
        let s_5469_0: u8 = fn_state.coproc;
        // D s_5469_1: cast zx s_5469_0 -> bv
        let s_5469_1: Bits = Bits::new(s_5469_0 as u128, 4u16);
        // C s_5469_2: const #15u : u8
        let s_5469_2: u8 = 15;
        // C s_5469_3: cast zx s_5469_2 -> bv
        let s_5469_3: Bits = Bits::new(s_5469_2 as u128, 4u16);
        // D s_5469_4: cmp-eq s_5469_1 s_5469_3
        let s_5469_4: bool = ((s_5469_1) == (s_5469_3));
        // D s_5469_5: write-var gs#117709 <= s_5469_4
        fn_state.gs_117709 = s_5469_4;
        // N s_5469_6: jump b364
        return block_364(state, tracer, fn_state);
    }
    fn block_5470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5470_0: read-var CRn:u8
        let s_5470_0: u8 = fn_state.CRn;
        // D s_5470_1: cast zx s_5470_0 -> bv
        let s_5470_1: Bits = Bits::new(s_5470_0 as u128, 4u16);
        // C s_5470_2: const #9u : u8
        let s_5470_2: u8 = 9;
        // C s_5470_3: cast zx s_5470_2 -> bv
        let s_5470_3: Bits = Bits::new(s_5470_2 as u128, 4u16);
        // D s_5470_4: cmp-eq s_5470_1 s_5470_3
        let s_5470_4: bool = ((s_5470_1) == (s_5470_3));
        // D s_5470_5: write-var gs#117708 <= s_5470_4
        fn_state.gs_117708 = s_5470_4;
        // N s_5470_6: jump b362
        return block_362(state, tracer, fn_state);
    }
    fn block_5471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5471_0: read-var el:u8
        let s_5471_0: u8 = fn_state.el;
        // D s_5471_1: read-var coproc:u8
        let s_5471_1: u8 = fn_state.coproc;
        // D s_5471_2: read-var opc1:u8
        let s_5471_2: u8 = fn_state.opc1;
        // D s_5471_3: read-var CRn:u8
        let s_5471_3: u8 = fn_state.CRn;
        // D s_5471_4: read-var opc2:u8
        let s_5471_4: u8 = fn_state.opc2;
        // D s_5471_5: read-var CRm:u8
        let s_5471_5: u8 = fn_state.CRm;
        // D s_5471_6: read-var t:i
        let s_5471_6: i128 = fn_state.t;
        // D s_5471_7: call DBGBVR_SysRegRead32_c036021238cbadaa(s_5471_0, s_5471_1, s_5471_2, s_5471_3, s_5471_4, s_5471_5, s_5471_6)
        let s_5471_7: () = DBGBVR_SysRegRead32_c036021238cbadaa(
            state,
            tracer,
            s_5471_0,
            s_5471_1,
            s_5471_2,
            s_5471_3,
            s_5471_4,
            s_5471_5,
            s_5471_6,
        );
        // N s_5471_8: return
        return;
    }
    fn block_5472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5472_0: read-var opc2:u8
        let s_5472_0: u8 = fn_state.opc2;
        // D s_5472_1: cast zx s_5472_0 -> bv
        let s_5472_1: Bits = Bits::new(s_5472_0 as u128, 3u16);
        // C s_5472_2: const #4u : u8
        let s_5472_2: u8 = 4;
        // C s_5472_3: cast zx s_5472_2 -> bv
        let s_5472_3: Bits = Bits::new(s_5472_2 as u128, 3u16);
        // D s_5472_4: cmp-eq s_5472_1 s_5472_3
        let s_5472_4: bool = ((s_5472_1) == (s_5472_3));
        // D s_5472_5: write-var gs#117707 <= s_5472_4
        fn_state.gs_117707 = s_5472_4;
        // N s_5472_6: jump b359
        return block_359(state, tracer, fn_state);
    }
    fn block_5473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5473_0: read-var opc1:u8
        let s_5473_0: u8 = fn_state.opc1;
        // D s_5473_1: cast zx s_5473_0 -> bv
        let s_5473_1: Bits = Bits::new(s_5473_0 as u128, 3u16);
        // C s_5473_2: const #0u : u8
        let s_5473_2: u8 = 0;
        // C s_5473_3: cast zx s_5473_2 -> bv
        let s_5473_3: Bits = Bits::new(s_5473_2 as u128, 3u16);
        // D s_5473_4: cmp-eq s_5473_1 s_5473_3
        let s_5473_4: bool = ((s_5473_1) == (s_5473_3));
        // D s_5473_5: write-var gs#117706 <= s_5473_4
        fn_state.gs_117706 = s_5473_4;
        // N s_5473_6: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_5474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5474_0: read-var coproc:u8
        let s_5474_0: u8 = fn_state.coproc;
        // D s_5474_1: cast zx s_5474_0 -> bv
        let s_5474_1: Bits = Bits::new(s_5474_0 as u128, 4u16);
        // C s_5474_2: const #14u : u8
        let s_5474_2: u8 = 14;
        // C s_5474_3: cast zx s_5474_2 -> bv
        let s_5474_3: Bits = Bits::new(s_5474_2 as u128, 4u16);
        // D s_5474_4: cmp-eq s_5474_1 s_5474_3
        let s_5474_4: bool = ((s_5474_1) == (s_5474_3));
        // D s_5474_5: write-var gs#117705 <= s_5474_4
        fn_state.gs_117705 = s_5474_4;
        // N s_5474_6: jump b355
        return block_355(state, tracer, fn_state);
    }
    fn block_5475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5475_0: read-var CRn:u8
        let s_5475_0: u8 = fn_state.CRn;
        // D s_5475_1: cast zx s_5475_0 -> bv
        let s_5475_1: Bits = Bits::new(s_5475_0 as u128, 4u16);
        // C s_5475_2: const #0u : u8
        let s_5475_2: u8 = 0;
        // C s_5475_3: cast zx s_5475_2 -> bv
        let s_5475_3: Bits = Bits::new(s_5475_2 as u128, 4u16);
        // D s_5475_4: cmp-eq s_5475_1 s_5475_3
        let s_5475_4: bool = ((s_5475_1) == (s_5475_3));
        // D s_5475_5: write-var gs#117704 <= s_5475_4
        fn_state.gs_117704 = s_5475_4;
        // N s_5475_6: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_5476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5476_0: read-var el:u8
        let s_5476_0: u8 = fn_state.el;
        // D s_5476_1: read-var coproc:u8
        let s_5476_1: u8 = fn_state.coproc;
        // D s_5476_2: read-var opc1:u8
        let s_5476_2: u8 = fn_state.opc1;
        // D s_5476_3: read-var CRn:u8
        let s_5476_3: u8 = fn_state.CRn;
        // D s_5476_4: read-var opc2:u8
        let s_5476_4: u8 = fn_state.opc2;
        // D s_5476_5: read-var CRm:u8
        let s_5476_5: u8 = fn_state.CRm;
        // D s_5476_6: read-var t:i
        let s_5476_6: i128 = fn_state.t;
        // D s_5476_7: call DBGBVR_SysRegRead32_54fa7eb1a8a086d2(s_5476_0, s_5476_1, s_5476_2, s_5476_3, s_5476_4, s_5476_5, s_5476_6)
        let s_5476_7: () = DBGBVR_SysRegRead32_54fa7eb1a8a086d2(
            state,
            tracer,
            s_5476_0,
            s_5476_1,
            s_5476_2,
            s_5476_3,
            s_5476_4,
            s_5476_5,
            s_5476_6,
        );
        // N s_5476_8: return
        return;
    }
    fn block_5477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5477_0: read-var opc2:u8
        let s_5477_0: u8 = fn_state.opc2;
        // D s_5477_1: cast zx s_5477_0 -> bv
        let s_5477_1: Bits = Bits::new(s_5477_0 as u128, 3u16);
        // C s_5477_2: const #4u : u8
        let s_5477_2: u8 = 4;
        // C s_5477_3: cast zx s_5477_2 -> bv
        let s_5477_3: Bits = Bits::new(s_5477_2 as u128, 3u16);
        // D s_5477_4: cmp-eq s_5477_1 s_5477_3
        let s_5477_4: bool = ((s_5477_1) == (s_5477_3));
        // D s_5477_5: write-var gs#117703 <= s_5477_4
        fn_state.gs_117703 = s_5477_4;
        // N s_5477_6: jump b350
        return block_350(state, tracer, fn_state);
    }
    fn block_5478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5478_0: read-var opc1:u8
        let s_5478_0: u8 = fn_state.opc1;
        // D s_5478_1: cast zx s_5478_0 -> bv
        let s_5478_1: Bits = Bits::new(s_5478_0 as u128, 3u16);
        // C s_5478_2: const #0u : u8
        let s_5478_2: u8 = 0;
        // C s_5478_3: cast zx s_5478_2 -> bv
        let s_5478_3: Bits = Bits::new(s_5478_2 as u128, 3u16);
        // D s_5478_4: cmp-eq s_5478_1 s_5478_3
        let s_5478_4: bool = ((s_5478_1) == (s_5478_3));
        // D s_5478_5: write-var gs#117702 <= s_5478_4
        fn_state.gs_117702 = s_5478_4;
        // N s_5478_6: jump b348
        return block_348(state, tracer, fn_state);
    }
    fn block_5479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5479_0: read-var coproc:u8
        let s_5479_0: u8 = fn_state.coproc;
        // D s_5479_1: cast zx s_5479_0 -> bv
        let s_5479_1: Bits = Bits::new(s_5479_0 as u128, 4u16);
        // C s_5479_2: const #14u : u8
        let s_5479_2: u8 = 14;
        // C s_5479_3: cast zx s_5479_2 -> bv
        let s_5479_3: Bits = Bits::new(s_5479_2 as u128, 4u16);
        // D s_5479_4: cmp-eq s_5479_1 s_5479_3
        let s_5479_4: bool = ((s_5479_1) == (s_5479_3));
        // D s_5479_5: write-var gs#117701 <= s_5479_4
        fn_state.gs_117701 = s_5479_4;
        // N s_5479_6: jump b346
        return block_346(state, tracer, fn_state);
    }
    fn block_5480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5480_0: read-var CRn:u8
        let s_5480_0: u8 = fn_state.CRn;
        // D s_5480_1: cast zx s_5480_0 -> bv
        let s_5480_1: Bits = Bits::new(s_5480_0 as u128, 4u16);
        // C s_5480_2: const #0u : u8
        let s_5480_2: u8 = 0;
        // C s_5480_3: cast zx s_5480_2 -> bv
        let s_5480_3: Bits = Bits::new(s_5480_2 as u128, 4u16);
        // D s_5480_4: cmp-eq s_5480_1 s_5480_3
        let s_5480_4: bool = ((s_5480_1) == (s_5480_3));
        // D s_5480_5: write-var gs#117700 <= s_5480_4
        fn_state.gs_117700 = s_5480_4;
        // N s_5480_6: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_5481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5481_0: read-var el:u8
        let s_5481_0: u8 = fn_state.el;
        // D s_5481_1: read-var coproc:u8
        let s_5481_1: u8 = fn_state.coproc;
        // D s_5481_2: read-var opc1:u8
        let s_5481_2: u8 = fn_state.opc1;
        // D s_5481_3: read-var CRn:u8
        let s_5481_3: u8 = fn_state.CRn;
        // D s_5481_4: read-var opc2:u8
        let s_5481_4: u8 = fn_state.opc2;
        // D s_5481_5: read-var CRm:u8
        let s_5481_5: u8 = fn_state.CRm;
        // D s_5481_6: read-var t:i
        let s_5481_6: i128 = fn_state.t;
        // D s_5481_7: call DBGBVR_SysRegRead32_1730a99ffdcdb940(s_5481_0, s_5481_1, s_5481_2, s_5481_3, s_5481_4, s_5481_5, s_5481_6)
        let s_5481_7: () = DBGBVR_SysRegRead32_1730a99ffdcdb940(
            state,
            tracer,
            s_5481_0,
            s_5481_1,
            s_5481_2,
            s_5481_3,
            s_5481_4,
            s_5481_5,
            s_5481_6,
        );
        // N s_5481_8: return
        return;
    }
    fn block_5482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5482_0: read-var opc2:u8
        let s_5482_0: u8 = fn_state.opc2;
        // D s_5482_1: cast zx s_5482_0 -> bv
        let s_5482_1: Bits = Bits::new(s_5482_0 as u128, 3u16);
        // C s_5482_2: const #4u : u8
        let s_5482_2: u8 = 4;
        // C s_5482_3: cast zx s_5482_2 -> bv
        let s_5482_3: Bits = Bits::new(s_5482_2 as u128, 3u16);
        // D s_5482_4: cmp-eq s_5482_1 s_5482_3
        let s_5482_4: bool = ((s_5482_1) == (s_5482_3));
        // D s_5482_5: write-var gs#117699 <= s_5482_4
        fn_state.gs_117699 = s_5482_4;
        // N s_5482_6: jump b341
        return block_341(state, tracer, fn_state);
    }
    fn block_5483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5483_0: read-var opc1:u8
        let s_5483_0: u8 = fn_state.opc1;
        // D s_5483_1: cast zx s_5483_0 -> bv
        let s_5483_1: Bits = Bits::new(s_5483_0 as u128, 3u16);
        // C s_5483_2: const #0u : u8
        let s_5483_2: u8 = 0;
        // C s_5483_3: cast zx s_5483_2 -> bv
        let s_5483_3: Bits = Bits::new(s_5483_2 as u128, 3u16);
        // D s_5483_4: cmp-eq s_5483_1 s_5483_3
        let s_5483_4: bool = ((s_5483_1) == (s_5483_3));
        // D s_5483_5: write-var gs#117698 <= s_5483_4
        fn_state.gs_117698 = s_5483_4;
        // N s_5483_6: jump b339
        return block_339(state, tracer, fn_state);
    }
    fn block_5484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5484_0: read-var coproc:u8
        let s_5484_0: u8 = fn_state.coproc;
        // D s_5484_1: cast zx s_5484_0 -> bv
        let s_5484_1: Bits = Bits::new(s_5484_0 as u128, 4u16);
        // C s_5484_2: const #14u : u8
        let s_5484_2: u8 = 14;
        // C s_5484_3: cast zx s_5484_2 -> bv
        let s_5484_3: Bits = Bits::new(s_5484_2 as u128, 4u16);
        // D s_5484_4: cmp-eq s_5484_1 s_5484_3
        let s_5484_4: bool = ((s_5484_1) == (s_5484_3));
        // D s_5484_5: write-var gs#117697 <= s_5484_4
        fn_state.gs_117697 = s_5484_4;
        // N s_5484_6: jump b337
        return block_337(state, tracer, fn_state);
    }
    fn block_5485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5485_0: read-var CRn:u8
        let s_5485_0: u8 = fn_state.CRn;
        // D s_5485_1: cast zx s_5485_0 -> bv
        let s_5485_1: Bits = Bits::new(s_5485_0 as u128, 4u16);
        // C s_5485_2: const #0u : u8
        let s_5485_2: u8 = 0;
        // C s_5485_3: cast zx s_5485_2 -> bv
        let s_5485_3: Bits = Bits::new(s_5485_2 as u128, 4u16);
        // D s_5485_4: cmp-eq s_5485_1 s_5485_3
        let s_5485_4: bool = ((s_5485_1) == (s_5485_3));
        // D s_5485_5: write-var gs#117696 <= s_5485_4
        fn_state.gs_117696 = s_5485_4;
        // N s_5485_6: jump b335
        return block_335(state, tracer, fn_state);
    }
    fn block_5486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5486_0: read-var el:u8
        let s_5486_0: u8 = fn_state.el;
        // D s_5486_1: read-var coproc:u8
        let s_5486_1: u8 = fn_state.coproc;
        // D s_5486_2: read-var opc1:u8
        let s_5486_2: u8 = fn_state.opc1;
        // D s_5486_3: read-var CRn:u8
        let s_5486_3: u8 = fn_state.CRn;
        // D s_5486_4: read-var opc2:u8
        let s_5486_4: u8 = fn_state.opc2;
        // D s_5486_5: read-var CRm:u8
        let s_5486_5: u8 = fn_state.CRm;
        // D s_5486_6: read-var t:i
        let s_5486_6: i128 = fn_state.t;
        // D s_5486_7: call DBGBVR_SysRegRead32_4b2492f939b2d68d(s_5486_0, s_5486_1, s_5486_2, s_5486_3, s_5486_4, s_5486_5, s_5486_6)
        let s_5486_7: () = DBGBVR_SysRegRead32_4b2492f939b2d68d(
            state,
            tracer,
            s_5486_0,
            s_5486_1,
            s_5486_2,
            s_5486_3,
            s_5486_4,
            s_5486_5,
            s_5486_6,
        );
        // N s_5486_8: return
        return;
    }
    fn block_5487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5487_0: read-var opc2:u8
        let s_5487_0: u8 = fn_state.opc2;
        // D s_5487_1: cast zx s_5487_0 -> bv
        let s_5487_1: Bits = Bits::new(s_5487_0 as u128, 3u16);
        // C s_5487_2: const #4u : u8
        let s_5487_2: u8 = 4;
        // C s_5487_3: cast zx s_5487_2 -> bv
        let s_5487_3: Bits = Bits::new(s_5487_2 as u128, 3u16);
        // D s_5487_4: cmp-eq s_5487_1 s_5487_3
        let s_5487_4: bool = ((s_5487_1) == (s_5487_3));
        // D s_5487_5: write-var gs#117695 <= s_5487_4
        fn_state.gs_117695 = s_5487_4;
        // N s_5487_6: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_5488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5488_0: read-var opc1:u8
        let s_5488_0: u8 = fn_state.opc1;
        // D s_5488_1: cast zx s_5488_0 -> bv
        let s_5488_1: Bits = Bits::new(s_5488_0 as u128, 3u16);
        // C s_5488_2: const #0u : u8
        let s_5488_2: u8 = 0;
        // C s_5488_3: cast zx s_5488_2 -> bv
        let s_5488_3: Bits = Bits::new(s_5488_2 as u128, 3u16);
        // D s_5488_4: cmp-eq s_5488_1 s_5488_3
        let s_5488_4: bool = ((s_5488_1) == (s_5488_3));
        // D s_5488_5: write-var gs#117694 <= s_5488_4
        fn_state.gs_117694 = s_5488_4;
        // N s_5488_6: jump b330
        return block_330(state, tracer, fn_state);
    }
    fn block_5489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5489_0: read-var coproc:u8
        let s_5489_0: u8 = fn_state.coproc;
        // D s_5489_1: cast zx s_5489_0 -> bv
        let s_5489_1: Bits = Bits::new(s_5489_0 as u128, 4u16);
        // C s_5489_2: const #14u : u8
        let s_5489_2: u8 = 14;
        // C s_5489_3: cast zx s_5489_2 -> bv
        let s_5489_3: Bits = Bits::new(s_5489_2 as u128, 4u16);
        // D s_5489_4: cmp-eq s_5489_1 s_5489_3
        let s_5489_4: bool = ((s_5489_1) == (s_5489_3));
        // D s_5489_5: write-var gs#117693 <= s_5489_4
        fn_state.gs_117693 = s_5489_4;
        // N s_5489_6: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_5490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5490_0: read-var CRn:u8
        let s_5490_0: u8 = fn_state.CRn;
        // D s_5490_1: cast zx s_5490_0 -> bv
        let s_5490_1: Bits = Bits::new(s_5490_0 as u128, 4u16);
        // C s_5490_2: const #0u : u8
        let s_5490_2: u8 = 0;
        // C s_5490_3: cast zx s_5490_2 -> bv
        let s_5490_3: Bits = Bits::new(s_5490_2 as u128, 4u16);
        // D s_5490_4: cmp-eq s_5490_1 s_5490_3
        let s_5490_4: bool = ((s_5490_1) == (s_5490_3));
        // D s_5490_5: write-var gs#117692 <= s_5490_4
        fn_state.gs_117692 = s_5490_4;
        // N s_5490_6: jump b326
        return block_326(state, tracer, fn_state);
    }
    fn block_5491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5491_0: read-var el:u8
        let s_5491_0: u8 = fn_state.el;
        // D s_5491_1: read-var coproc:u8
        let s_5491_1: u8 = fn_state.coproc;
        // D s_5491_2: read-var opc1:u8
        let s_5491_2: u8 = fn_state.opc1;
        // D s_5491_3: read-var CRn:u8
        let s_5491_3: u8 = fn_state.CRn;
        // D s_5491_4: read-var opc2:u8
        let s_5491_4: u8 = fn_state.opc2;
        // D s_5491_5: read-var CRm:u8
        let s_5491_5: u8 = fn_state.CRm;
        // D s_5491_6: read-var t:i
        let s_5491_6: i128 = fn_state.t;
        // D s_5491_7: call DBGBVR_SysRegRead32_00f589dd9b6e498d(s_5491_0, s_5491_1, s_5491_2, s_5491_3, s_5491_4, s_5491_5, s_5491_6)
        let s_5491_7: () = DBGBVR_SysRegRead32_00f589dd9b6e498d(
            state,
            tracer,
            s_5491_0,
            s_5491_1,
            s_5491_2,
            s_5491_3,
            s_5491_4,
            s_5491_5,
            s_5491_6,
        );
        // N s_5491_8: return
        return;
    }
    fn block_5492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5492_0: read-var opc2:u8
        let s_5492_0: u8 = fn_state.opc2;
        // D s_5492_1: cast zx s_5492_0 -> bv
        let s_5492_1: Bits = Bits::new(s_5492_0 as u128, 3u16);
        // C s_5492_2: const #4u : u8
        let s_5492_2: u8 = 4;
        // C s_5492_3: cast zx s_5492_2 -> bv
        let s_5492_3: Bits = Bits::new(s_5492_2 as u128, 3u16);
        // D s_5492_4: cmp-eq s_5492_1 s_5492_3
        let s_5492_4: bool = ((s_5492_1) == (s_5492_3));
        // D s_5492_5: write-var gs#117691 <= s_5492_4
        fn_state.gs_117691 = s_5492_4;
        // N s_5492_6: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_5493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5493_0: read-var opc1:u8
        let s_5493_0: u8 = fn_state.opc1;
        // D s_5493_1: cast zx s_5493_0 -> bv
        let s_5493_1: Bits = Bits::new(s_5493_0 as u128, 3u16);
        // C s_5493_2: const #0u : u8
        let s_5493_2: u8 = 0;
        // C s_5493_3: cast zx s_5493_2 -> bv
        let s_5493_3: Bits = Bits::new(s_5493_2 as u128, 3u16);
        // D s_5493_4: cmp-eq s_5493_1 s_5493_3
        let s_5493_4: bool = ((s_5493_1) == (s_5493_3));
        // D s_5493_5: write-var gs#117690 <= s_5493_4
        fn_state.gs_117690 = s_5493_4;
        // N s_5493_6: jump b321
        return block_321(state, tracer, fn_state);
    }
    fn block_5494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5494_0: read-var coproc:u8
        let s_5494_0: u8 = fn_state.coproc;
        // D s_5494_1: cast zx s_5494_0 -> bv
        let s_5494_1: Bits = Bits::new(s_5494_0 as u128, 4u16);
        // C s_5494_2: const #14u : u8
        let s_5494_2: u8 = 14;
        // C s_5494_3: cast zx s_5494_2 -> bv
        let s_5494_3: Bits = Bits::new(s_5494_2 as u128, 4u16);
        // D s_5494_4: cmp-eq s_5494_1 s_5494_3
        let s_5494_4: bool = ((s_5494_1) == (s_5494_3));
        // D s_5494_5: write-var gs#117689 <= s_5494_4
        fn_state.gs_117689 = s_5494_4;
        // N s_5494_6: jump b319
        return block_319(state, tracer, fn_state);
    }
    fn block_5495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5495_0: read-var CRn:u8
        let s_5495_0: u8 = fn_state.CRn;
        // D s_5495_1: cast zx s_5495_0 -> bv
        let s_5495_1: Bits = Bits::new(s_5495_0 as u128, 4u16);
        // C s_5495_2: const #0u : u8
        let s_5495_2: u8 = 0;
        // C s_5495_3: cast zx s_5495_2 -> bv
        let s_5495_3: Bits = Bits::new(s_5495_2 as u128, 4u16);
        // D s_5495_4: cmp-eq s_5495_1 s_5495_3
        let s_5495_4: bool = ((s_5495_1) == (s_5495_3));
        // D s_5495_5: write-var gs#117688 <= s_5495_4
        fn_state.gs_117688 = s_5495_4;
        // N s_5495_6: jump b317
        return block_317(state, tracer, fn_state);
    }
    fn block_5496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5496_0: read-var el:u8
        let s_5496_0: u8 = fn_state.el;
        // D s_5496_1: read-var coproc:u8
        let s_5496_1: u8 = fn_state.coproc;
        // D s_5496_2: read-var opc1:u8
        let s_5496_2: u8 = fn_state.opc1;
        // D s_5496_3: read-var CRn:u8
        let s_5496_3: u8 = fn_state.CRn;
        // D s_5496_4: read-var opc2:u8
        let s_5496_4: u8 = fn_state.opc2;
        // D s_5496_5: read-var CRm:u8
        let s_5496_5: u8 = fn_state.CRm;
        // D s_5496_6: read-var t:i
        let s_5496_6: i128 = fn_state.t;
        // D s_5496_7: call DBGBVR_SysRegRead32_82067dc9734a6b24(s_5496_0, s_5496_1, s_5496_2, s_5496_3, s_5496_4, s_5496_5, s_5496_6)
        let s_5496_7: () = DBGBVR_SysRegRead32_82067dc9734a6b24(
            state,
            tracer,
            s_5496_0,
            s_5496_1,
            s_5496_2,
            s_5496_3,
            s_5496_4,
            s_5496_5,
            s_5496_6,
        );
        // N s_5496_8: return
        return;
    }
    fn block_5497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5497_0: read-var opc2:u8
        let s_5497_0: u8 = fn_state.opc2;
        // D s_5497_1: cast zx s_5497_0 -> bv
        let s_5497_1: Bits = Bits::new(s_5497_0 as u128, 3u16);
        // C s_5497_2: const #4u : u8
        let s_5497_2: u8 = 4;
        // C s_5497_3: cast zx s_5497_2 -> bv
        let s_5497_3: Bits = Bits::new(s_5497_2 as u128, 3u16);
        // D s_5497_4: cmp-eq s_5497_1 s_5497_3
        let s_5497_4: bool = ((s_5497_1) == (s_5497_3));
        // D s_5497_5: write-var gs#117687 <= s_5497_4
        fn_state.gs_117687 = s_5497_4;
        // N s_5497_6: jump b314
        return block_314(state, tracer, fn_state);
    }
    fn block_5498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5498_0: read-var opc1:u8
        let s_5498_0: u8 = fn_state.opc1;
        // D s_5498_1: cast zx s_5498_0 -> bv
        let s_5498_1: Bits = Bits::new(s_5498_0 as u128, 3u16);
        // C s_5498_2: const #0u : u8
        let s_5498_2: u8 = 0;
        // C s_5498_3: cast zx s_5498_2 -> bv
        let s_5498_3: Bits = Bits::new(s_5498_2 as u128, 3u16);
        // D s_5498_4: cmp-eq s_5498_1 s_5498_3
        let s_5498_4: bool = ((s_5498_1) == (s_5498_3));
        // D s_5498_5: write-var gs#117686 <= s_5498_4
        fn_state.gs_117686 = s_5498_4;
        // N s_5498_6: jump b312
        return block_312(state, tracer, fn_state);
    }
    fn block_5499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5499_0: read-var coproc:u8
        let s_5499_0: u8 = fn_state.coproc;
        // D s_5499_1: cast zx s_5499_0 -> bv
        let s_5499_1: Bits = Bits::new(s_5499_0 as u128, 4u16);
        // C s_5499_2: const #14u : u8
        let s_5499_2: u8 = 14;
        // C s_5499_3: cast zx s_5499_2 -> bv
        let s_5499_3: Bits = Bits::new(s_5499_2 as u128, 4u16);
        // D s_5499_4: cmp-eq s_5499_1 s_5499_3
        let s_5499_4: bool = ((s_5499_1) == (s_5499_3));
        // D s_5499_5: write-var gs#117685 <= s_5499_4
        fn_state.gs_117685 = s_5499_4;
        // N s_5499_6: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_5500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5500_0: read-var CRn:u8
        let s_5500_0: u8 = fn_state.CRn;
        // D s_5500_1: cast zx s_5500_0 -> bv
        let s_5500_1: Bits = Bits::new(s_5500_0 as u128, 4u16);
        // C s_5500_2: const #0u : u8
        let s_5500_2: u8 = 0;
        // C s_5500_3: cast zx s_5500_2 -> bv
        let s_5500_3: Bits = Bits::new(s_5500_2 as u128, 4u16);
        // D s_5500_4: cmp-eq s_5500_1 s_5500_3
        let s_5500_4: bool = ((s_5500_1) == (s_5500_3));
        // D s_5500_5: write-var gs#117684 <= s_5500_4
        fn_state.gs_117684 = s_5500_4;
        // N s_5500_6: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_5501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5501_0: read-var el:u8
        let s_5501_0: u8 = fn_state.el;
        // D s_5501_1: read-var coproc:u8
        let s_5501_1: u8 = fn_state.coproc;
        // D s_5501_2: read-var opc1:u8
        let s_5501_2: u8 = fn_state.opc1;
        // D s_5501_3: read-var CRn:u8
        let s_5501_3: u8 = fn_state.CRn;
        // D s_5501_4: read-var opc2:u8
        let s_5501_4: u8 = fn_state.opc2;
        // D s_5501_5: read-var CRm:u8
        let s_5501_5: u8 = fn_state.CRm;
        // D s_5501_6: read-var t:i
        let s_5501_6: i128 = fn_state.t;
        // D s_5501_7: call DBGBVR_SysRegRead32_7547e126cd447504(s_5501_0, s_5501_1, s_5501_2, s_5501_3, s_5501_4, s_5501_5, s_5501_6)
        let s_5501_7: () = DBGBVR_SysRegRead32_7547e126cd447504(
            state,
            tracer,
            s_5501_0,
            s_5501_1,
            s_5501_2,
            s_5501_3,
            s_5501_4,
            s_5501_5,
            s_5501_6,
        );
        // N s_5501_8: return
        return;
    }
    fn block_5502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5502_0: read-var opc2:u8
        let s_5502_0: u8 = fn_state.opc2;
        // D s_5502_1: cast zx s_5502_0 -> bv
        let s_5502_1: Bits = Bits::new(s_5502_0 as u128, 3u16);
        // C s_5502_2: const #4u : u8
        let s_5502_2: u8 = 4;
        // C s_5502_3: cast zx s_5502_2 -> bv
        let s_5502_3: Bits = Bits::new(s_5502_2 as u128, 3u16);
        // D s_5502_4: cmp-eq s_5502_1 s_5502_3
        let s_5502_4: bool = ((s_5502_1) == (s_5502_3));
        // D s_5502_5: write-var gs#117683 <= s_5502_4
        fn_state.gs_117683 = s_5502_4;
        // N s_5502_6: jump b305
        return block_305(state, tracer, fn_state);
    }
    fn block_5503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5503_0: read-var opc1:u8
        let s_5503_0: u8 = fn_state.opc1;
        // D s_5503_1: cast zx s_5503_0 -> bv
        let s_5503_1: Bits = Bits::new(s_5503_0 as u128, 3u16);
        // C s_5503_2: const #0u : u8
        let s_5503_2: u8 = 0;
        // C s_5503_3: cast zx s_5503_2 -> bv
        let s_5503_3: Bits = Bits::new(s_5503_2 as u128, 3u16);
        // D s_5503_4: cmp-eq s_5503_1 s_5503_3
        let s_5503_4: bool = ((s_5503_1) == (s_5503_3));
        // D s_5503_5: write-var gs#117682 <= s_5503_4
        fn_state.gs_117682 = s_5503_4;
        // N s_5503_6: jump b303
        return block_303(state, tracer, fn_state);
    }
    fn block_5504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5504_0: read-var coproc:u8
        let s_5504_0: u8 = fn_state.coproc;
        // D s_5504_1: cast zx s_5504_0 -> bv
        let s_5504_1: Bits = Bits::new(s_5504_0 as u128, 4u16);
        // C s_5504_2: const #14u : u8
        let s_5504_2: u8 = 14;
        // C s_5504_3: cast zx s_5504_2 -> bv
        let s_5504_3: Bits = Bits::new(s_5504_2 as u128, 4u16);
        // D s_5504_4: cmp-eq s_5504_1 s_5504_3
        let s_5504_4: bool = ((s_5504_1) == (s_5504_3));
        // D s_5504_5: write-var gs#117681 <= s_5504_4
        fn_state.gs_117681 = s_5504_4;
        // N s_5504_6: jump b301
        return block_301(state, tracer, fn_state);
    }
    fn block_5505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5505_0: read-var CRn:u8
        let s_5505_0: u8 = fn_state.CRn;
        // D s_5505_1: cast zx s_5505_0 -> bv
        let s_5505_1: Bits = Bits::new(s_5505_0 as u128, 4u16);
        // C s_5505_2: const #0u : u8
        let s_5505_2: u8 = 0;
        // C s_5505_3: cast zx s_5505_2 -> bv
        let s_5505_3: Bits = Bits::new(s_5505_2 as u128, 4u16);
        // D s_5505_4: cmp-eq s_5505_1 s_5505_3
        let s_5505_4: bool = ((s_5505_1) == (s_5505_3));
        // D s_5505_5: write-var gs#117680 <= s_5505_4
        fn_state.gs_117680 = s_5505_4;
        // N s_5505_6: jump b299
        return block_299(state, tracer, fn_state);
    }
    fn block_5506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5506_0: read-var el:u8
        let s_5506_0: u8 = fn_state.el;
        // D s_5506_1: read-var coproc:u8
        let s_5506_1: u8 = fn_state.coproc;
        // D s_5506_2: read-var opc1:u8
        let s_5506_2: u8 = fn_state.opc1;
        // D s_5506_3: read-var CRn:u8
        let s_5506_3: u8 = fn_state.CRn;
        // D s_5506_4: read-var opc2:u8
        let s_5506_4: u8 = fn_state.opc2;
        // D s_5506_5: read-var CRm:u8
        let s_5506_5: u8 = fn_state.CRm;
        // D s_5506_6: read-var t:i
        let s_5506_6: i128 = fn_state.t;
        // D s_5506_7: call DBGBVR_SysRegRead32_0d7192e87273fee3(s_5506_0, s_5506_1, s_5506_2, s_5506_3, s_5506_4, s_5506_5, s_5506_6)
        let s_5506_7: () = DBGBVR_SysRegRead32_0d7192e87273fee3(
            state,
            tracer,
            s_5506_0,
            s_5506_1,
            s_5506_2,
            s_5506_3,
            s_5506_4,
            s_5506_5,
            s_5506_6,
        );
        // N s_5506_8: return
        return;
    }
    fn block_5507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5507_0: read-var opc2:u8
        let s_5507_0: u8 = fn_state.opc2;
        // D s_5507_1: cast zx s_5507_0 -> bv
        let s_5507_1: Bits = Bits::new(s_5507_0 as u128, 3u16);
        // C s_5507_2: const #4u : u8
        let s_5507_2: u8 = 4;
        // C s_5507_3: cast zx s_5507_2 -> bv
        let s_5507_3: Bits = Bits::new(s_5507_2 as u128, 3u16);
        // D s_5507_4: cmp-eq s_5507_1 s_5507_3
        let s_5507_4: bool = ((s_5507_1) == (s_5507_3));
        // D s_5507_5: write-var gs#117679 <= s_5507_4
        fn_state.gs_117679 = s_5507_4;
        // N s_5507_6: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_5508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5508_0: read-var opc1:u8
        let s_5508_0: u8 = fn_state.opc1;
        // D s_5508_1: cast zx s_5508_0 -> bv
        let s_5508_1: Bits = Bits::new(s_5508_0 as u128, 3u16);
        // C s_5508_2: const #0u : u8
        let s_5508_2: u8 = 0;
        // C s_5508_3: cast zx s_5508_2 -> bv
        let s_5508_3: Bits = Bits::new(s_5508_2 as u128, 3u16);
        // D s_5508_4: cmp-eq s_5508_1 s_5508_3
        let s_5508_4: bool = ((s_5508_1) == (s_5508_3));
        // D s_5508_5: write-var gs#117678 <= s_5508_4
        fn_state.gs_117678 = s_5508_4;
        // N s_5508_6: jump b294
        return block_294(state, tracer, fn_state);
    }
    fn block_5509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5509_0: read-var coproc:u8
        let s_5509_0: u8 = fn_state.coproc;
        // D s_5509_1: cast zx s_5509_0 -> bv
        let s_5509_1: Bits = Bits::new(s_5509_0 as u128, 4u16);
        // C s_5509_2: const #14u : u8
        let s_5509_2: u8 = 14;
        // C s_5509_3: cast zx s_5509_2 -> bv
        let s_5509_3: Bits = Bits::new(s_5509_2 as u128, 4u16);
        // D s_5509_4: cmp-eq s_5509_1 s_5509_3
        let s_5509_4: bool = ((s_5509_1) == (s_5509_3));
        // D s_5509_5: write-var gs#117677 <= s_5509_4
        fn_state.gs_117677 = s_5509_4;
        // N s_5509_6: jump b292
        return block_292(state, tracer, fn_state);
    }
    fn block_5510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5510_0: read-var CRn:u8
        let s_5510_0: u8 = fn_state.CRn;
        // D s_5510_1: cast zx s_5510_0 -> bv
        let s_5510_1: Bits = Bits::new(s_5510_0 as u128, 4u16);
        // C s_5510_2: const #0u : u8
        let s_5510_2: u8 = 0;
        // C s_5510_3: cast zx s_5510_2 -> bv
        let s_5510_3: Bits = Bits::new(s_5510_2 as u128, 4u16);
        // D s_5510_4: cmp-eq s_5510_1 s_5510_3
        let s_5510_4: bool = ((s_5510_1) == (s_5510_3));
        // D s_5510_5: write-var gs#117676 <= s_5510_4
        fn_state.gs_117676 = s_5510_4;
        // N s_5510_6: jump b290
        return block_290(state, tracer, fn_state);
    }
    fn block_5511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5511_0: read-var el:u8
        let s_5511_0: u8 = fn_state.el;
        // D s_5511_1: read-var coproc:u8
        let s_5511_1: u8 = fn_state.coproc;
        // D s_5511_2: read-var opc1:u8
        let s_5511_2: u8 = fn_state.opc1;
        // D s_5511_3: read-var CRn:u8
        let s_5511_3: u8 = fn_state.CRn;
        // D s_5511_4: read-var opc2:u8
        let s_5511_4: u8 = fn_state.opc2;
        // D s_5511_5: read-var CRm:u8
        let s_5511_5: u8 = fn_state.CRm;
        // D s_5511_6: read-var t:i
        let s_5511_6: i128 = fn_state.t;
        // D s_5511_7: call DBGBVR_SysRegRead32_08fe9e5e419581ae(s_5511_0, s_5511_1, s_5511_2, s_5511_3, s_5511_4, s_5511_5, s_5511_6)
        let s_5511_7: () = DBGBVR_SysRegRead32_08fe9e5e419581ae(
            state,
            tracer,
            s_5511_0,
            s_5511_1,
            s_5511_2,
            s_5511_3,
            s_5511_4,
            s_5511_5,
            s_5511_6,
        );
        // N s_5511_8: return
        return;
    }
    fn block_5512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5512_0: read-var opc2:u8
        let s_5512_0: u8 = fn_state.opc2;
        // D s_5512_1: cast zx s_5512_0 -> bv
        let s_5512_1: Bits = Bits::new(s_5512_0 as u128, 3u16);
        // C s_5512_2: const #4u : u8
        let s_5512_2: u8 = 4;
        // C s_5512_3: cast zx s_5512_2 -> bv
        let s_5512_3: Bits = Bits::new(s_5512_2 as u128, 3u16);
        // D s_5512_4: cmp-eq s_5512_1 s_5512_3
        let s_5512_4: bool = ((s_5512_1) == (s_5512_3));
        // D s_5512_5: write-var gs#117675 <= s_5512_4
        fn_state.gs_117675 = s_5512_4;
        // N s_5512_6: jump b287
        return block_287(state, tracer, fn_state);
    }
    fn block_5513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5513_0: read-var opc1:u8
        let s_5513_0: u8 = fn_state.opc1;
        // D s_5513_1: cast zx s_5513_0 -> bv
        let s_5513_1: Bits = Bits::new(s_5513_0 as u128, 3u16);
        // C s_5513_2: const #0u : u8
        let s_5513_2: u8 = 0;
        // C s_5513_3: cast zx s_5513_2 -> bv
        let s_5513_3: Bits = Bits::new(s_5513_2 as u128, 3u16);
        // D s_5513_4: cmp-eq s_5513_1 s_5513_3
        let s_5513_4: bool = ((s_5513_1) == (s_5513_3));
        // D s_5513_5: write-var gs#117674 <= s_5513_4
        fn_state.gs_117674 = s_5513_4;
        // N s_5513_6: jump b285
        return block_285(state, tracer, fn_state);
    }
    fn block_5514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5514_0: read-var coproc:u8
        let s_5514_0: u8 = fn_state.coproc;
        // D s_5514_1: cast zx s_5514_0 -> bv
        let s_5514_1: Bits = Bits::new(s_5514_0 as u128, 4u16);
        // C s_5514_2: const #14u : u8
        let s_5514_2: u8 = 14;
        // C s_5514_3: cast zx s_5514_2 -> bv
        let s_5514_3: Bits = Bits::new(s_5514_2 as u128, 4u16);
        // D s_5514_4: cmp-eq s_5514_1 s_5514_3
        let s_5514_4: bool = ((s_5514_1) == (s_5514_3));
        // D s_5514_5: write-var gs#117673 <= s_5514_4
        fn_state.gs_117673 = s_5514_4;
        // N s_5514_6: jump b283
        return block_283(state, tracer, fn_state);
    }
    fn block_5515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5515_0: read-var CRn:u8
        let s_5515_0: u8 = fn_state.CRn;
        // D s_5515_1: cast zx s_5515_0 -> bv
        let s_5515_1: Bits = Bits::new(s_5515_0 as u128, 4u16);
        // C s_5515_2: const #0u : u8
        let s_5515_2: u8 = 0;
        // C s_5515_3: cast zx s_5515_2 -> bv
        let s_5515_3: Bits = Bits::new(s_5515_2 as u128, 4u16);
        // D s_5515_4: cmp-eq s_5515_1 s_5515_3
        let s_5515_4: bool = ((s_5515_1) == (s_5515_3));
        // D s_5515_5: write-var gs#117672 <= s_5515_4
        fn_state.gs_117672 = s_5515_4;
        // N s_5515_6: jump b281
        return block_281(state, tracer, fn_state);
    }
    fn block_5516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5516_0: read-var el:u8
        let s_5516_0: u8 = fn_state.el;
        // D s_5516_1: read-var coproc:u8
        let s_5516_1: u8 = fn_state.coproc;
        // D s_5516_2: read-var opc1:u8
        let s_5516_2: u8 = fn_state.opc1;
        // D s_5516_3: read-var CRn:u8
        let s_5516_3: u8 = fn_state.CRn;
        // D s_5516_4: read-var opc2:u8
        let s_5516_4: u8 = fn_state.opc2;
        // D s_5516_5: read-var CRm:u8
        let s_5516_5: u8 = fn_state.CRm;
        // D s_5516_6: read-var t:i
        let s_5516_6: i128 = fn_state.t;
        // D s_5516_7: call DBGBVR_SysRegRead32_aeb056e353dc1a63(s_5516_0, s_5516_1, s_5516_2, s_5516_3, s_5516_4, s_5516_5, s_5516_6)
        let s_5516_7: () = DBGBVR_SysRegRead32_aeb056e353dc1a63(
            state,
            tracer,
            s_5516_0,
            s_5516_1,
            s_5516_2,
            s_5516_3,
            s_5516_4,
            s_5516_5,
            s_5516_6,
        );
        // N s_5516_8: return
        return;
    }
    fn block_5517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5517_0: read-var opc2:u8
        let s_5517_0: u8 = fn_state.opc2;
        // D s_5517_1: cast zx s_5517_0 -> bv
        let s_5517_1: Bits = Bits::new(s_5517_0 as u128, 3u16);
        // C s_5517_2: const #4u : u8
        let s_5517_2: u8 = 4;
        // C s_5517_3: cast zx s_5517_2 -> bv
        let s_5517_3: Bits = Bits::new(s_5517_2 as u128, 3u16);
        // D s_5517_4: cmp-eq s_5517_1 s_5517_3
        let s_5517_4: bool = ((s_5517_1) == (s_5517_3));
        // D s_5517_5: write-var gs#117671 <= s_5517_4
        fn_state.gs_117671 = s_5517_4;
        // N s_5517_6: jump b278
        return block_278(state, tracer, fn_state);
    }
    fn block_5518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5518_0: read-var opc1:u8
        let s_5518_0: u8 = fn_state.opc1;
        // D s_5518_1: cast zx s_5518_0 -> bv
        let s_5518_1: Bits = Bits::new(s_5518_0 as u128, 3u16);
        // C s_5518_2: const #0u : u8
        let s_5518_2: u8 = 0;
        // C s_5518_3: cast zx s_5518_2 -> bv
        let s_5518_3: Bits = Bits::new(s_5518_2 as u128, 3u16);
        // D s_5518_4: cmp-eq s_5518_1 s_5518_3
        let s_5518_4: bool = ((s_5518_1) == (s_5518_3));
        // D s_5518_5: write-var gs#117670 <= s_5518_4
        fn_state.gs_117670 = s_5518_4;
        // N s_5518_6: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_5519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5519_0: read-var coproc:u8
        let s_5519_0: u8 = fn_state.coproc;
        // D s_5519_1: cast zx s_5519_0 -> bv
        let s_5519_1: Bits = Bits::new(s_5519_0 as u128, 4u16);
        // C s_5519_2: const #14u : u8
        let s_5519_2: u8 = 14;
        // C s_5519_3: cast zx s_5519_2 -> bv
        let s_5519_3: Bits = Bits::new(s_5519_2 as u128, 4u16);
        // D s_5519_4: cmp-eq s_5519_1 s_5519_3
        let s_5519_4: bool = ((s_5519_1) == (s_5519_3));
        // D s_5519_5: write-var gs#117669 <= s_5519_4
        fn_state.gs_117669 = s_5519_4;
        // N s_5519_6: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_5520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5520_0: read-var CRn:u8
        let s_5520_0: u8 = fn_state.CRn;
        // D s_5520_1: cast zx s_5520_0 -> bv
        let s_5520_1: Bits = Bits::new(s_5520_0 as u128, 4u16);
        // C s_5520_2: const #0u : u8
        let s_5520_2: u8 = 0;
        // C s_5520_3: cast zx s_5520_2 -> bv
        let s_5520_3: Bits = Bits::new(s_5520_2 as u128, 4u16);
        // D s_5520_4: cmp-eq s_5520_1 s_5520_3
        let s_5520_4: bool = ((s_5520_1) == (s_5520_3));
        // D s_5520_5: write-var gs#117668 <= s_5520_4
        fn_state.gs_117668 = s_5520_4;
        // N s_5520_6: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_5521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5521_0: read-var el:u8
        let s_5521_0: u8 = fn_state.el;
        // D s_5521_1: read-var coproc:u8
        let s_5521_1: u8 = fn_state.coproc;
        // D s_5521_2: read-var opc1:u8
        let s_5521_2: u8 = fn_state.opc1;
        // D s_5521_3: read-var CRn:u8
        let s_5521_3: u8 = fn_state.CRn;
        // D s_5521_4: read-var opc2:u8
        let s_5521_4: u8 = fn_state.opc2;
        // D s_5521_5: read-var CRm:u8
        let s_5521_5: u8 = fn_state.CRm;
        // D s_5521_6: read-var t:i
        let s_5521_6: i128 = fn_state.t;
        // D s_5521_7: call DBGBVR_SysRegRead32_4a2928b59ff2bd88(s_5521_0, s_5521_1, s_5521_2, s_5521_3, s_5521_4, s_5521_5, s_5521_6)
        let s_5521_7: () = DBGBVR_SysRegRead32_4a2928b59ff2bd88(
            state,
            tracer,
            s_5521_0,
            s_5521_1,
            s_5521_2,
            s_5521_3,
            s_5521_4,
            s_5521_5,
            s_5521_6,
        );
        // N s_5521_8: return
        return;
    }
    fn block_5522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5522_0: read-var opc2:u8
        let s_5522_0: u8 = fn_state.opc2;
        // D s_5522_1: cast zx s_5522_0 -> bv
        let s_5522_1: Bits = Bits::new(s_5522_0 as u128, 3u16);
        // C s_5522_2: const #4u : u8
        let s_5522_2: u8 = 4;
        // C s_5522_3: cast zx s_5522_2 -> bv
        let s_5522_3: Bits = Bits::new(s_5522_2 as u128, 3u16);
        // D s_5522_4: cmp-eq s_5522_1 s_5522_3
        let s_5522_4: bool = ((s_5522_1) == (s_5522_3));
        // D s_5522_5: write-var gs#117667 <= s_5522_4
        fn_state.gs_117667 = s_5522_4;
        // N s_5522_6: jump b269
        return block_269(state, tracer, fn_state);
    }
    fn block_5523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5523_0: read-var opc1:u8
        let s_5523_0: u8 = fn_state.opc1;
        // D s_5523_1: cast zx s_5523_0 -> bv
        let s_5523_1: Bits = Bits::new(s_5523_0 as u128, 3u16);
        // C s_5523_2: const #0u : u8
        let s_5523_2: u8 = 0;
        // C s_5523_3: cast zx s_5523_2 -> bv
        let s_5523_3: Bits = Bits::new(s_5523_2 as u128, 3u16);
        // D s_5523_4: cmp-eq s_5523_1 s_5523_3
        let s_5523_4: bool = ((s_5523_1) == (s_5523_3));
        // D s_5523_5: write-var gs#117666 <= s_5523_4
        fn_state.gs_117666 = s_5523_4;
        // N s_5523_6: jump b267
        return block_267(state, tracer, fn_state);
    }
    fn block_5524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5524_0: read-var coproc:u8
        let s_5524_0: u8 = fn_state.coproc;
        // D s_5524_1: cast zx s_5524_0 -> bv
        let s_5524_1: Bits = Bits::new(s_5524_0 as u128, 4u16);
        // C s_5524_2: const #14u : u8
        let s_5524_2: u8 = 14;
        // C s_5524_3: cast zx s_5524_2 -> bv
        let s_5524_3: Bits = Bits::new(s_5524_2 as u128, 4u16);
        // D s_5524_4: cmp-eq s_5524_1 s_5524_3
        let s_5524_4: bool = ((s_5524_1) == (s_5524_3));
        // D s_5524_5: write-var gs#117665 <= s_5524_4
        fn_state.gs_117665 = s_5524_4;
        // N s_5524_6: jump b265
        return block_265(state, tracer, fn_state);
    }
    fn block_5525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5525_0: read-var CRn:u8
        let s_5525_0: u8 = fn_state.CRn;
        // D s_5525_1: cast zx s_5525_0 -> bv
        let s_5525_1: Bits = Bits::new(s_5525_0 as u128, 4u16);
        // C s_5525_2: const #0u : u8
        let s_5525_2: u8 = 0;
        // C s_5525_3: cast zx s_5525_2 -> bv
        let s_5525_3: Bits = Bits::new(s_5525_2 as u128, 4u16);
        // D s_5525_4: cmp-eq s_5525_1 s_5525_3
        let s_5525_4: bool = ((s_5525_1) == (s_5525_3));
        // D s_5525_5: write-var gs#117664 <= s_5525_4
        fn_state.gs_117664 = s_5525_4;
        // N s_5525_6: jump b263
        return block_263(state, tracer, fn_state);
    }
    fn block_5526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5526_0: read-var el:u8
        let s_5526_0: u8 = fn_state.el;
        // D s_5526_1: read-var coproc:u8
        let s_5526_1: u8 = fn_state.coproc;
        // D s_5526_2: read-var opc1:u8
        let s_5526_2: u8 = fn_state.opc1;
        // D s_5526_3: read-var CRn:u8
        let s_5526_3: u8 = fn_state.CRn;
        // D s_5526_4: read-var opc2:u8
        let s_5526_4: u8 = fn_state.opc2;
        // D s_5526_5: read-var CRm:u8
        let s_5526_5: u8 = fn_state.CRm;
        // D s_5526_6: read-var t:i
        let s_5526_6: i128 = fn_state.t;
        // D s_5526_7: call DBGBVR_SysRegRead32_c4752bdaff15ec68(s_5526_0, s_5526_1, s_5526_2, s_5526_3, s_5526_4, s_5526_5, s_5526_6)
        let s_5526_7: () = DBGBVR_SysRegRead32_c4752bdaff15ec68(
            state,
            tracer,
            s_5526_0,
            s_5526_1,
            s_5526_2,
            s_5526_3,
            s_5526_4,
            s_5526_5,
            s_5526_6,
        );
        // N s_5526_8: return
        return;
    }
    fn block_5527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5527_0: read-var opc2:u8
        let s_5527_0: u8 = fn_state.opc2;
        // D s_5527_1: cast zx s_5527_0 -> bv
        let s_5527_1: Bits = Bits::new(s_5527_0 as u128, 3u16);
        // C s_5527_2: const #4u : u8
        let s_5527_2: u8 = 4;
        // C s_5527_3: cast zx s_5527_2 -> bv
        let s_5527_3: Bits = Bits::new(s_5527_2 as u128, 3u16);
        // D s_5527_4: cmp-eq s_5527_1 s_5527_3
        let s_5527_4: bool = ((s_5527_1) == (s_5527_3));
        // D s_5527_5: write-var gs#117663 <= s_5527_4
        fn_state.gs_117663 = s_5527_4;
        // N s_5527_6: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_5528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5528_0: read-var opc1:u8
        let s_5528_0: u8 = fn_state.opc1;
        // D s_5528_1: cast zx s_5528_0 -> bv
        let s_5528_1: Bits = Bits::new(s_5528_0 as u128, 3u16);
        // C s_5528_2: const #0u : u8
        let s_5528_2: u8 = 0;
        // C s_5528_3: cast zx s_5528_2 -> bv
        let s_5528_3: Bits = Bits::new(s_5528_2 as u128, 3u16);
        // D s_5528_4: cmp-eq s_5528_1 s_5528_3
        let s_5528_4: bool = ((s_5528_1) == (s_5528_3));
        // D s_5528_5: write-var gs#117662 <= s_5528_4
        fn_state.gs_117662 = s_5528_4;
        // N s_5528_6: jump b258
        return block_258(state, tracer, fn_state);
    }
    fn block_5529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5529_0: read-var coproc:u8
        let s_5529_0: u8 = fn_state.coproc;
        // D s_5529_1: cast zx s_5529_0 -> bv
        let s_5529_1: Bits = Bits::new(s_5529_0 as u128, 4u16);
        // C s_5529_2: const #14u : u8
        let s_5529_2: u8 = 14;
        // C s_5529_3: cast zx s_5529_2 -> bv
        let s_5529_3: Bits = Bits::new(s_5529_2 as u128, 4u16);
        // D s_5529_4: cmp-eq s_5529_1 s_5529_3
        let s_5529_4: bool = ((s_5529_1) == (s_5529_3));
        // D s_5529_5: write-var gs#117661 <= s_5529_4
        fn_state.gs_117661 = s_5529_4;
        // N s_5529_6: jump b256
        return block_256(state, tracer, fn_state);
    }
    fn block_5530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5530_0: read-var CRn:u8
        let s_5530_0: u8 = fn_state.CRn;
        // D s_5530_1: cast zx s_5530_0 -> bv
        let s_5530_1: Bits = Bits::new(s_5530_0 as u128, 4u16);
        // C s_5530_2: const #0u : u8
        let s_5530_2: u8 = 0;
        // C s_5530_3: cast zx s_5530_2 -> bv
        let s_5530_3: Bits = Bits::new(s_5530_2 as u128, 4u16);
        // D s_5530_4: cmp-eq s_5530_1 s_5530_3
        let s_5530_4: bool = ((s_5530_1) == (s_5530_3));
        // D s_5530_5: write-var gs#117660 <= s_5530_4
        fn_state.gs_117660 = s_5530_4;
        // N s_5530_6: jump b254
        return block_254(state, tracer, fn_state);
    }
    fn block_5531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5531_0: read-var el:u8
        let s_5531_0: u8 = fn_state.el;
        // D s_5531_1: read-var coproc:u8
        let s_5531_1: u8 = fn_state.coproc;
        // D s_5531_2: read-var opc1:u8
        let s_5531_2: u8 = fn_state.opc1;
        // D s_5531_3: read-var CRn:u8
        let s_5531_3: u8 = fn_state.CRn;
        // D s_5531_4: read-var opc2:u8
        let s_5531_4: u8 = fn_state.opc2;
        // D s_5531_5: read-var CRm:u8
        let s_5531_5: u8 = fn_state.CRm;
        // D s_5531_6: read-var t:i
        let s_5531_6: i128 = fn_state.t;
        // D s_5531_7: call DBGBVR_SysRegRead32_3b08f67b830efeb5(s_5531_0, s_5531_1, s_5531_2, s_5531_3, s_5531_4, s_5531_5, s_5531_6)
        let s_5531_7: () = DBGBVR_SysRegRead32_3b08f67b830efeb5(
            state,
            tracer,
            s_5531_0,
            s_5531_1,
            s_5531_2,
            s_5531_3,
            s_5531_4,
            s_5531_5,
            s_5531_6,
        );
        // N s_5531_8: return
        return;
    }
    fn block_5532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5532_0: read-var opc2:u8
        let s_5532_0: u8 = fn_state.opc2;
        // D s_5532_1: cast zx s_5532_0 -> bv
        let s_5532_1: Bits = Bits::new(s_5532_0 as u128, 3u16);
        // C s_5532_2: const #4u : u8
        let s_5532_2: u8 = 4;
        // C s_5532_3: cast zx s_5532_2 -> bv
        let s_5532_3: Bits = Bits::new(s_5532_2 as u128, 3u16);
        // D s_5532_4: cmp-eq s_5532_1 s_5532_3
        let s_5532_4: bool = ((s_5532_1) == (s_5532_3));
        // D s_5532_5: write-var gs#117659 <= s_5532_4
        fn_state.gs_117659 = s_5532_4;
        // N s_5532_6: jump b251
        return block_251(state, tracer, fn_state);
    }
    fn block_5533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5533_0: read-var opc1:u8
        let s_5533_0: u8 = fn_state.opc1;
        // D s_5533_1: cast zx s_5533_0 -> bv
        let s_5533_1: Bits = Bits::new(s_5533_0 as u128, 3u16);
        // C s_5533_2: const #0u : u8
        let s_5533_2: u8 = 0;
        // C s_5533_3: cast zx s_5533_2 -> bv
        let s_5533_3: Bits = Bits::new(s_5533_2 as u128, 3u16);
        // D s_5533_4: cmp-eq s_5533_1 s_5533_3
        let s_5533_4: bool = ((s_5533_1) == (s_5533_3));
        // D s_5533_5: write-var gs#117658 <= s_5533_4
        fn_state.gs_117658 = s_5533_4;
        // N s_5533_6: jump b249
        return block_249(state, tracer, fn_state);
    }
    fn block_5534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5534_0: read-var coproc:u8
        let s_5534_0: u8 = fn_state.coproc;
        // D s_5534_1: cast zx s_5534_0 -> bv
        let s_5534_1: Bits = Bits::new(s_5534_0 as u128, 4u16);
        // C s_5534_2: const #14u : u8
        let s_5534_2: u8 = 14;
        // C s_5534_3: cast zx s_5534_2 -> bv
        let s_5534_3: Bits = Bits::new(s_5534_2 as u128, 4u16);
        // D s_5534_4: cmp-eq s_5534_1 s_5534_3
        let s_5534_4: bool = ((s_5534_1) == (s_5534_3));
        // D s_5534_5: write-var gs#117657 <= s_5534_4
        fn_state.gs_117657 = s_5534_4;
        // N s_5534_6: jump b247
        return block_247(state, tracer, fn_state);
    }
    fn block_5535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5535_0: read-var CRn:u8
        let s_5535_0: u8 = fn_state.CRn;
        // D s_5535_1: cast zx s_5535_0 -> bv
        let s_5535_1: Bits = Bits::new(s_5535_0 as u128, 4u16);
        // C s_5535_2: const #0u : u8
        let s_5535_2: u8 = 0;
        // C s_5535_3: cast zx s_5535_2 -> bv
        let s_5535_3: Bits = Bits::new(s_5535_2 as u128, 4u16);
        // D s_5535_4: cmp-eq s_5535_1 s_5535_3
        let s_5535_4: bool = ((s_5535_1) == (s_5535_3));
        // D s_5535_5: write-var gs#117656 <= s_5535_4
        fn_state.gs_117656 = s_5535_4;
        // N s_5535_6: jump b245
        return block_245(state, tracer, fn_state);
    }
    fn block_5536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5536_0: read-var el:u8
        let s_5536_0: u8 = fn_state.el;
        // D s_5536_1: read-var coproc:u8
        let s_5536_1: u8 = fn_state.coproc;
        // D s_5536_2: read-var opc1:u8
        let s_5536_2: u8 = fn_state.opc1;
        // D s_5536_3: read-var CRn:u8
        let s_5536_3: u8 = fn_state.CRn;
        // D s_5536_4: read-var opc2:u8
        let s_5536_4: u8 = fn_state.opc2;
        // D s_5536_5: read-var CRm:u8
        let s_5536_5: u8 = fn_state.CRm;
        // D s_5536_6: read-var t:i
        let s_5536_6: i128 = fn_state.t;
        // D s_5536_7: call DBGBVR_SysRegRead32_3127ee8e7174eb76(s_5536_0, s_5536_1, s_5536_2, s_5536_3, s_5536_4, s_5536_5, s_5536_6)
        let s_5536_7: () = DBGBVR_SysRegRead32_3127ee8e7174eb76(
            state,
            tracer,
            s_5536_0,
            s_5536_1,
            s_5536_2,
            s_5536_3,
            s_5536_4,
            s_5536_5,
            s_5536_6,
        );
        // N s_5536_8: return
        return;
    }
    fn block_5537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5537_0: read-var opc2:u8
        let s_5537_0: u8 = fn_state.opc2;
        // D s_5537_1: cast zx s_5537_0 -> bv
        let s_5537_1: Bits = Bits::new(s_5537_0 as u128, 3u16);
        // C s_5537_2: const #4u : u8
        let s_5537_2: u8 = 4;
        // C s_5537_3: cast zx s_5537_2 -> bv
        let s_5537_3: Bits = Bits::new(s_5537_2 as u128, 3u16);
        // D s_5537_4: cmp-eq s_5537_1 s_5537_3
        let s_5537_4: bool = ((s_5537_1) == (s_5537_3));
        // D s_5537_5: write-var gs#117655 <= s_5537_4
        fn_state.gs_117655 = s_5537_4;
        // N s_5537_6: jump b242
        return block_242(state, tracer, fn_state);
    }
    fn block_5538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5538_0: read-var opc1:u8
        let s_5538_0: u8 = fn_state.opc1;
        // D s_5538_1: cast zx s_5538_0 -> bv
        let s_5538_1: Bits = Bits::new(s_5538_0 as u128, 3u16);
        // C s_5538_2: const #0u : u8
        let s_5538_2: u8 = 0;
        // C s_5538_3: cast zx s_5538_2 -> bv
        let s_5538_3: Bits = Bits::new(s_5538_2 as u128, 3u16);
        // D s_5538_4: cmp-eq s_5538_1 s_5538_3
        let s_5538_4: bool = ((s_5538_1) == (s_5538_3));
        // D s_5538_5: write-var gs#117654 <= s_5538_4
        fn_state.gs_117654 = s_5538_4;
        // N s_5538_6: jump b240
        return block_240(state, tracer, fn_state);
    }
    fn block_5539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5539_0: read-var coproc:u8
        let s_5539_0: u8 = fn_state.coproc;
        // D s_5539_1: cast zx s_5539_0 -> bv
        let s_5539_1: Bits = Bits::new(s_5539_0 as u128, 4u16);
        // C s_5539_2: const #14u : u8
        let s_5539_2: u8 = 14;
        // C s_5539_3: cast zx s_5539_2 -> bv
        let s_5539_3: Bits = Bits::new(s_5539_2 as u128, 4u16);
        // D s_5539_4: cmp-eq s_5539_1 s_5539_3
        let s_5539_4: bool = ((s_5539_1) == (s_5539_3));
        // D s_5539_5: write-var gs#117653 <= s_5539_4
        fn_state.gs_117653 = s_5539_4;
        // N s_5539_6: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_5540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5540_0: read-var CRn:u8
        let s_5540_0: u8 = fn_state.CRn;
        // D s_5540_1: cast zx s_5540_0 -> bv
        let s_5540_1: Bits = Bits::new(s_5540_0 as u128, 4u16);
        // C s_5540_2: const #0u : u8
        let s_5540_2: u8 = 0;
        // C s_5540_3: cast zx s_5540_2 -> bv
        let s_5540_3: Bits = Bits::new(s_5540_2 as u128, 4u16);
        // D s_5540_4: cmp-eq s_5540_1 s_5540_3
        let s_5540_4: bool = ((s_5540_1) == (s_5540_3));
        // D s_5540_5: write-var gs#117652 <= s_5540_4
        fn_state.gs_117652 = s_5540_4;
        // N s_5540_6: jump b236
        return block_236(state, tracer, fn_state);
    }
    fn block_5541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5541_0: read-var el:u8
        let s_5541_0: u8 = fn_state.el;
        // D s_5541_1: read-var coproc:u8
        let s_5541_1: u8 = fn_state.coproc;
        // D s_5541_2: read-var opc1:u8
        let s_5541_2: u8 = fn_state.opc1;
        // D s_5541_3: read-var CRn:u8
        let s_5541_3: u8 = fn_state.CRn;
        // D s_5541_4: read-var opc2:u8
        let s_5541_4: u8 = fn_state.opc2;
        // D s_5541_5: read-var CRm:u8
        let s_5541_5: u8 = fn_state.CRm;
        // D s_5541_6: read-var t:i
        let s_5541_6: i128 = fn_state.t;
        // D s_5541_7: call DBGBVR_SysRegRead32_7ba934859e2de1ac(s_5541_0, s_5541_1, s_5541_2, s_5541_3, s_5541_4, s_5541_5, s_5541_6)
        let s_5541_7: () = DBGBVR_SysRegRead32_7ba934859e2de1ac(
            state,
            tracer,
            s_5541_0,
            s_5541_1,
            s_5541_2,
            s_5541_3,
            s_5541_4,
            s_5541_5,
            s_5541_6,
        );
        // N s_5541_8: return
        return;
    }
    fn block_5542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5542_0: read-var opc2:u8
        let s_5542_0: u8 = fn_state.opc2;
        // D s_5542_1: cast zx s_5542_0 -> bv
        let s_5542_1: Bits = Bits::new(s_5542_0 as u128, 3u16);
        // C s_5542_2: const #4u : u8
        let s_5542_2: u8 = 4;
        // C s_5542_3: cast zx s_5542_2 -> bv
        let s_5542_3: Bits = Bits::new(s_5542_2 as u128, 3u16);
        // D s_5542_4: cmp-eq s_5542_1 s_5542_3
        let s_5542_4: bool = ((s_5542_1) == (s_5542_3));
        // D s_5542_5: write-var gs#117651 <= s_5542_4
        fn_state.gs_117651 = s_5542_4;
        // N s_5542_6: jump b233
        return block_233(state, tracer, fn_state);
    }
    fn block_5543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5543_0: read-var opc1:u8
        let s_5543_0: u8 = fn_state.opc1;
        // D s_5543_1: cast zx s_5543_0 -> bv
        let s_5543_1: Bits = Bits::new(s_5543_0 as u128, 3u16);
        // C s_5543_2: const #0u : u8
        let s_5543_2: u8 = 0;
        // C s_5543_3: cast zx s_5543_2 -> bv
        let s_5543_3: Bits = Bits::new(s_5543_2 as u128, 3u16);
        // D s_5543_4: cmp-eq s_5543_1 s_5543_3
        let s_5543_4: bool = ((s_5543_1) == (s_5543_3));
        // D s_5543_5: write-var gs#117650 <= s_5543_4
        fn_state.gs_117650 = s_5543_4;
        // N s_5543_6: jump b231
        return block_231(state, tracer, fn_state);
    }
    fn block_5544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5544_0: read-var coproc:u8
        let s_5544_0: u8 = fn_state.coproc;
        // D s_5544_1: cast zx s_5544_0 -> bv
        let s_5544_1: Bits = Bits::new(s_5544_0 as u128, 4u16);
        // C s_5544_2: const #14u : u8
        let s_5544_2: u8 = 14;
        // C s_5544_3: cast zx s_5544_2 -> bv
        let s_5544_3: Bits = Bits::new(s_5544_2 as u128, 4u16);
        // D s_5544_4: cmp-eq s_5544_1 s_5544_3
        let s_5544_4: bool = ((s_5544_1) == (s_5544_3));
        // D s_5544_5: write-var gs#117649 <= s_5544_4
        fn_state.gs_117649 = s_5544_4;
        // N s_5544_6: jump b229
        return block_229(state, tracer, fn_state);
    }
    fn block_5545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5545_0: read-var CRn:u8
        let s_5545_0: u8 = fn_state.CRn;
        // D s_5545_1: cast zx s_5545_0 -> bv
        let s_5545_1: Bits = Bits::new(s_5545_0 as u128, 4u16);
        // C s_5545_2: const #0u : u8
        let s_5545_2: u8 = 0;
        // C s_5545_3: cast zx s_5545_2 -> bv
        let s_5545_3: Bits = Bits::new(s_5545_2 as u128, 4u16);
        // D s_5545_4: cmp-eq s_5545_1 s_5545_3
        let s_5545_4: bool = ((s_5545_1) == (s_5545_3));
        // D s_5545_5: write-var gs#117648 <= s_5545_4
        fn_state.gs_117648 = s_5545_4;
        // N s_5545_6: jump b227
        return block_227(state, tracer, fn_state);
    }
    fn block_5546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5546_0: read-var el:u8
        let s_5546_0: u8 = fn_state.el;
        // D s_5546_1: read-var coproc:u8
        let s_5546_1: u8 = fn_state.coproc;
        // D s_5546_2: read-var opc1:u8
        let s_5546_2: u8 = fn_state.opc1;
        // D s_5546_3: read-var CRn:u8
        let s_5546_3: u8 = fn_state.CRn;
        // D s_5546_4: read-var opc2:u8
        let s_5546_4: u8 = fn_state.opc2;
        // D s_5546_5: read-var CRm:u8
        let s_5546_5: u8 = fn_state.CRm;
        // D s_5546_6: read-var t:i
        let s_5546_6: i128 = fn_state.t;
        // D s_5546_7: call DBGBVR_SysRegRead32_731a4ca5463f9ac4(s_5546_0, s_5546_1, s_5546_2, s_5546_3, s_5546_4, s_5546_5, s_5546_6)
        let s_5546_7: () = DBGBVR_SysRegRead32_731a4ca5463f9ac4(
            state,
            tracer,
            s_5546_0,
            s_5546_1,
            s_5546_2,
            s_5546_3,
            s_5546_4,
            s_5546_5,
            s_5546_6,
        );
        // N s_5546_8: return
        return;
    }
    fn block_5547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5547_0: read-var opc2:u8
        let s_5547_0: u8 = fn_state.opc2;
        // D s_5547_1: cast zx s_5547_0 -> bv
        let s_5547_1: Bits = Bits::new(s_5547_0 as u128, 3u16);
        // C s_5547_2: const #4u : u8
        let s_5547_2: u8 = 4;
        // C s_5547_3: cast zx s_5547_2 -> bv
        let s_5547_3: Bits = Bits::new(s_5547_2 as u128, 3u16);
        // D s_5547_4: cmp-eq s_5547_1 s_5547_3
        let s_5547_4: bool = ((s_5547_1) == (s_5547_3));
        // D s_5547_5: write-var gs#117647 <= s_5547_4
        fn_state.gs_117647 = s_5547_4;
        // N s_5547_6: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_5548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5548_0: read-var opc1:u8
        let s_5548_0: u8 = fn_state.opc1;
        // D s_5548_1: cast zx s_5548_0 -> bv
        let s_5548_1: Bits = Bits::new(s_5548_0 as u128, 3u16);
        // C s_5548_2: const #0u : u8
        let s_5548_2: u8 = 0;
        // C s_5548_3: cast zx s_5548_2 -> bv
        let s_5548_3: Bits = Bits::new(s_5548_2 as u128, 3u16);
        // D s_5548_4: cmp-eq s_5548_1 s_5548_3
        let s_5548_4: bool = ((s_5548_1) == (s_5548_3));
        // D s_5548_5: write-var gs#117646 <= s_5548_4
        fn_state.gs_117646 = s_5548_4;
        // N s_5548_6: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_5549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5549_0: read-var coproc:u8
        let s_5549_0: u8 = fn_state.coproc;
        // D s_5549_1: cast zx s_5549_0 -> bv
        let s_5549_1: Bits = Bits::new(s_5549_0 as u128, 4u16);
        // C s_5549_2: const #14u : u8
        let s_5549_2: u8 = 14;
        // C s_5549_3: cast zx s_5549_2 -> bv
        let s_5549_3: Bits = Bits::new(s_5549_2 as u128, 4u16);
        // D s_5549_4: cmp-eq s_5549_1 s_5549_3
        let s_5549_4: bool = ((s_5549_1) == (s_5549_3));
        // D s_5549_5: write-var gs#117645 <= s_5549_4
        fn_state.gs_117645 = s_5549_4;
        // N s_5549_6: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_5550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5550_0: read-var CRn:u8
        let s_5550_0: u8 = fn_state.CRn;
        // D s_5550_1: cast zx s_5550_0 -> bv
        let s_5550_1: Bits = Bits::new(s_5550_0 as u128, 4u16);
        // C s_5550_2: const #0u : u8
        let s_5550_2: u8 = 0;
        // C s_5550_3: cast zx s_5550_2 -> bv
        let s_5550_3: Bits = Bits::new(s_5550_2 as u128, 4u16);
        // D s_5550_4: cmp-eq s_5550_1 s_5550_3
        let s_5550_4: bool = ((s_5550_1) == (s_5550_3));
        // D s_5550_5: write-var gs#117644 <= s_5550_4
        fn_state.gs_117644 = s_5550_4;
        // N s_5550_6: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_5551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5551_0: read-var el:u8
        let s_5551_0: u8 = fn_state.el;
        // D s_5551_1: read-var coproc:u8
        let s_5551_1: u8 = fn_state.coproc;
        // D s_5551_2: read-var opc1:u8
        let s_5551_2: u8 = fn_state.opc1;
        // D s_5551_3: read-var CRn:u8
        let s_5551_3: u8 = fn_state.CRn;
        // D s_5551_4: read-var opc2:u8
        let s_5551_4: u8 = fn_state.opc2;
        // D s_5551_5: read-var CRm:u8
        let s_5551_5: u8 = fn_state.CRm;
        // D s_5551_6: read-var t:i
        let s_5551_6: i128 = fn_state.t;
        // D s_5551_7: call CNTHPS_CTL_SysRegRead32_a99d410e49082e9f(s_5551_0, s_5551_1, s_5551_2, s_5551_3, s_5551_4, s_5551_5, s_5551_6)
        let s_5551_7: () = CNTHPS_CTL_SysRegRead32_a99d410e49082e9f(
            state,
            tracer,
            s_5551_0,
            s_5551_1,
            s_5551_2,
            s_5551_3,
            s_5551_4,
            s_5551_5,
            s_5551_6,
        );
        // N s_5551_8: return
        return;
    }
    fn block_5552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5552_0: read-var opc2:u8
        let s_5552_0: u8 = fn_state.opc2;
        // D s_5552_1: cast zx s_5552_0 -> bv
        let s_5552_1: Bits = Bits::new(s_5552_0 as u128, 3u16);
        // C s_5552_2: const #1u : u8
        let s_5552_2: u8 = 1;
        // C s_5552_3: cast zx s_5552_2 -> bv
        let s_5552_3: Bits = Bits::new(s_5552_2 as u128, 3u16);
        // D s_5552_4: cmp-eq s_5552_1 s_5552_3
        let s_5552_4: bool = ((s_5552_1) == (s_5552_3));
        // D s_5552_5: write-var gs#117643 <= s_5552_4
        fn_state.gs_117643 = s_5552_4;
        // N s_5552_6: jump b215
        return block_215(state, tracer, fn_state);
    }
    fn block_5553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5553_0: read-var opc1:u8
        let s_5553_0: u8 = fn_state.opc1;
        // D s_5553_1: cast zx s_5553_0 -> bv
        let s_5553_1: Bits = Bits::new(s_5553_0 as u128, 3u16);
        // C s_5553_2: const #0u : u8
        let s_5553_2: u8 = 0;
        // C s_5553_3: cast zx s_5553_2 -> bv
        let s_5553_3: Bits = Bits::new(s_5553_2 as u128, 3u16);
        // D s_5553_4: cmp-eq s_5553_1 s_5553_3
        let s_5553_4: bool = ((s_5553_1) == (s_5553_3));
        // D s_5553_5: write-var gs#117642 <= s_5553_4
        fn_state.gs_117642 = s_5553_4;
        // N s_5553_6: jump b213
        return block_213(state, tracer, fn_state);
    }
    fn block_5554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5554_0: read-var coproc:u8
        let s_5554_0: u8 = fn_state.coproc;
        // D s_5554_1: cast zx s_5554_0 -> bv
        let s_5554_1: Bits = Bits::new(s_5554_0 as u128, 4u16);
        // C s_5554_2: const #15u : u8
        let s_5554_2: u8 = 15;
        // C s_5554_3: cast zx s_5554_2 -> bv
        let s_5554_3: Bits = Bits::new(s_5554_2 as u128, 4u16);
        // D s_5554_4: cmp-eq s_5554_1 s_5554_3
        let s_5554_4: bool = ((s_5554_1) == (s_5554_3));
        // D s_5554_5: write-var gs#117641 <= s_5554_4
        fn_state.gs_117641 = s_5554_4;
        // N s_5554_6: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_5555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5555_0: read-var CRn:u8
        let s_5555_0: u8 = fn_state.CRn;
        // D s_5555_1: cast zx s_5555_0 -> bv
        let s_5555_1: Bits = Bits::new(s_5555_0 as u128, 4u16);
        // C s_5555_2: const #14u : u8
        let s_5555_2: u8 = 14;
        // C s_5555_3: cast zx s_5555_2 -> bv
        let s_5555_3: Bits = Bits::new(s_5555_2 as u128, 4u16);
        // D s_5555_4: cmp-eq s_5555_1 s_5555_3
        let s_5555_4: bool = ((s_5555_1) == (s_5555_3));
        // D s_5555_5: write-var gs#117640 <= s_5555_4
        fn_state.gs_117640 = s_5555_4;
        // N s_5555_6: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_5556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5556_0: read-var el:u8
        let s_5556_0: u8 = fn_state.el;
        // D s_5556_1: read-var coproc:u8
        let s_5556_1: u8 = fn_state.coproc;
        // D s_5556_2: read-var opc1:u8
        let s_5556_2: u8 = fn_state.opc1;
        // D s_5556_3: read-var CRn:u8
        let s_5556_3: u8 = fn_state.CRn;
        // D s_5556_4: read-var opc2:u8
        let s_5556_4: u8 = fn_state.opc2;
        // D s_5556_5: read-var CRm:u8
        let s_5556_5: u8 = fn_state.CRm;
        // D s_5556_6: read-var t:i
        let s_5556_6: i128 = fn_state.t;
        // D s_5556_7: call PMUSERENR_SysRegRead32_a6257daec876c857(s_5556_0, s_5556_1, s_5556_2, s_5556_3, s_5556_4, s_5556_5, s_5556_6)
        let s_5556_7: () = PMUSERENR_SysRegRead32_a6257daec876c857(
            state,
            tracer,
            s_5556_0,
            s_5556_1,
            s_5556_2,
            s_5556_3,
            s_5556_4,
            s_5556_5,
            s_5556_6,
        );
        // N s_5556_8: return
        return;
    }
    fn block_5557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5557_0: read-var opc2:u8
        let s_5557_0: u8 = fn_state.opc2;
        // D s_5557_1: cast zx s_5557_0 -> bv
        let s_5557_1: Bits = Bits::new(s_5557_0 as u128, 3u16);
        // C s_5557_2: const #0u : u8
        let s_5557_2: u8 = 0;
        // C s_5557_3: cast zx s_5557_2 -> bv
        let s_5557_3: Bits = Bits::new(s_5557_2 as u128, 3u16);
        // D s_5557_4: cmp-eq s_5557_1 s_5557_3
        let s_5557_4: bool = ((s_5557_1) == (s_5557_3));
        // D s_5557_5: write-var gs#117639 <= s_5557_4
        fn_state.gs_117639 = s_5557_4;
        // N s_5557_6: jump b206
        return block_206(state, tracer, fn_state);
    }
    fn block_5558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5558_0: read-var opc1:u8
        let s_5558_0: u8 = fn_state.opc1;
        // D s_5558_1: cast zx s_5558_0 -> bv
        let s_5558_1: Bits = Bits::new(s_5558_0 as u128, 3u16);
        // C s_5558_2: const #0u : u8
        let s_5558_2: u8 = 0;
        // C s_5558_3: cast zx s_5558_2 -> bv
        let s_5558_3: Bits = Bits::new(s_5558_2 as u128, 3u16);
        // D s_5558_4: cmp-eq s_5558_1 s_5558_3
        let s_5558_4: bool = ((s_5558_1) == (s_5558_3));
        // D s_5558_5: write-var gs#117638 <= s_5558_4
        fn_state.gs_117638 = s_5558_4;
        // N s_5558_6: jump b204
        return block_204(state, tracer, fn_state);
    }
    fn block_5559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5559_0: read-var coproc:u8
        let s_5559_0: u8 = fn_state.coproc;
        // D s_5559_1: cast zx s_5559_0 -> bv
        let s_5559_1: Bits = Bits::new(s_5559_0 as u128, 4u16);
        // C s_5559_2: const #15u : u8
        let s_5559_2: u8 = 15;
        // C s_5559_3: cast zx s_5559_2 -> bv
        let s_5559_3: Bits = Bits::new(s_5559_2 as u128, 4u16);
        // D s_5559_4: cmp-eq s_5559_1 s_5559_3
        let s_5559_4: bool = ((s_5559_1) == (s_5559_3));
        // D s_5559_5: write-var gs#117637 <= s_5559_4
        fn_state.gs_117637 = s_5559_4;
        // N s_5559_6: jump b202
        return block_202(state, tracer, fn_state);
    }
    fn block_5560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5560_0: read-var CRn:u8
        let s_5560_0: u8 = fn_state.CRn;
        // D s_5560_1: cast zx s_5560_0 -> bv
        let s_5560_1: Bits = Bits::new(s_5560_0 as u128, 4u16);
        // C s_5560_2: const #9u : u8
        let s_5560_2: u8 = 9;
        // C s_5560_3: cast zx s_5560_2 -> bv
        let s_5560_3: Bits = Bits::new(s_5560_2 as u128, 4u16);
        // D s_5560_4: cmp-eq s_5560_1 s_5560_3
        let s_5560_4: bool = ((s_5560_1) == (s_5560_3));
        // D s_5560_5: write-var gs#117636 <= s_5560_4
        fn_state.gs_117636 = s_5560_4;
        // N s_5560_6: jump b200
        return block_200(state, tracer, fn_state);
    }
    fn block_5561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5561_0: read-var el:u8
        let s_5561_0: u8 = fn_state.el;
        // D s_5561_1: read-var coproc:u8
        let s_5561_1: u8 = fn_state.coproc;
        // D s_5561_2: read-var opc1:u8
        let s_5561_2: u8 = fn_state.opc1;
        // D s_5561_3: read-var CRn:u8
        let s_5561_3: u8 = fn_state.CRn;
        // D s_5561_4: read-var opc2:u8
        let s_5561_4: u8 = fn_state.opc2;
        // D s_5561_5: read-var CRm:u8
        let s_5561_5: u8 = fn_state.CRm;
        // D s_5561_6: read-var t:i
        let s_5561_6: i128 = fn_state.t;
        // D s_5561_7: call CTR_SysRegRead32_99a8e042837c333b(s_5561_0, s_5561_1, s_5561_2, s_5561_3, s_5561_4, s_5561_5, s_5561_6)
        let s_5561_7: () = CTR_SysRegRead32_99a8e042837c333b(
            state,
            tracer,
            s_5561_0,
            s_5561_1,
            s_5561_2,
            s_5561_3,
            s_5561_4,
            s_5561_5,
            s_5561_6,
        );
        // N s_5561_8: return
        return;
    }
    fn block_5562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5562_0: read-var opc2:u8
        let s_5562_0: u8 = fn_state.opc2;
        // D s_5562_1: cast zx s_5562_0 -> bv
        let s_5562_1: Bits = Bits::new(s_5562_0 as u128, 3u16);
        // C s_5562_2: const #1u : u8
        let s_5562_2: u8 = 1;
        // C s_5562_3: cast zx s_5562_2 -> bv
        let s_5562_3: Bits = Bits::new(s_5562_2 as u128, 3u16);
        // D s_5562_4: cmp-eq s_5562_1 s_5562_3
        let s_5562_4: bool = ((s_5562_1) == (s_5562_3));
        // D s_5562_5: write-var gs#117635 <= s_5562_4
        fn_state.gs_117635 = s_5562_4;
        // N s_5562_6: jump b197
        return block_197(state, tracer, fn_state);
    }
    fn block_5563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5563_0: read-var opc1:u8
        let s_5563_0: u8 = fn_state.opc1;
        // D s_5563_1: cast zx s_5563_0 -> bv
        let s_5563_1: Bits = Bits::new(s_5563_0 as u128, 3u16);
        // C s_5563_2: const #0u : u8
        let s_5563_2: u8 = 0;
        // C s_5563_3: cast zx s_5563_2 -> bv
        let s_5563_3: Bits = Bits::new(s_5563_2 as u128, 3u16);
        // D s_5563_4: cmp-eq s_5563_1 s_5563_3
        let s_5563_4: bool = ((s_5563_1) == (s_5563_3));
        // D s_5563_5: write-var gs#117634 <= s_5563_4
        fn_state.gs_117634 = s_5563_4;
        // N s_5563_6: jump b195
        return block_195(state, tracer, fn_state);
    }
    fn block_5564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5564_0: read-var coproc:u8
        let s_5564_0: u8 = fn_state.coproc;
        // D s_5564_1: cast zx s_5564_0 -> bv
        let s_5564_1: Bits = Bits::new(s_5564_0 as u128, 4u16);
        // C s_5564_2: const #15u : u8
        let s_5564_2: u8 = 15;
        // C s_5564_3: cast zx s_5564_2 -> bv
        let s_5564_3: Bits = Bits::new(s_5564_2 as u128, 4u16);
        // D s_5564_4: cmp-eq s_5564_1 s_5564_3
        let s_5564_4: bool = ((s_5564_1) == (s_5564_3));
        // D s_5564_5: write-var gs#117633 <= s_5564_4
        fn_state.gs_117633 = s_5564_4;
        // N s_5564_6: jump b193
        return block_193(state, tracer, fn_state);
    }
    fn block_5565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5565_0: read-var CRn:u8
        let s_5565_0: u8 = fn_state.CRn;
        // D s_5565_1: cast zx s_5565_0 -> bv
        let s_5565_1: Bits = Bits::new(s_5565_0 as u128, 4u16);
        // C s_5565_2: const #0u : u8
        let s_5565_2: u8 = 0;
        // C s_5565_3: cast zx s_5565_2 -> bv
        let s_5565_3: Bits = Bits::new(s_5565_2 as u128, 4u16);
        // D s_5565_4: cmp-eq s_5565_1 s_5565_3
        let s_5565_4: bool = ((s_5565_1) == (s_5565_3));
        // D s_5565_5: write-var gs#117632 <= s_5565_4
        fn_state.gs_117632 = s_5565_4;
        // N s_5565_6: jump b191
        return block_191(state, tracer, fn_state);
    }
    fn block_5566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5566_0: read-var el:u8
        let s_5566_0: u8 = fn_state.el;
        // D s_5566_1: read-var coproc:u8
        let s_5566_1: u8 = fn_state.coproc;
        // D s_5566_2: read-var opc1:u8
        let s_5566_2: u8 = fn_state.opc1;
        // D s_5566_3: read-var CRn:u8
        let s_5566_3: u8 = fn_state.CRn;
        // D s_5566_4: read-var opc2:u8
        let s_5566_4: u8 = fn_state.opc2;
        // D s_5566_5: read-var CRm:u8
        let s_5566_5: u8 = fn_state.CRm;
        // D s_5566_6: read-var t:i
        let s_5566_6: i128 = fn_state.t;
        // D s_5566_7: call PMOVSR_SysRegRead32_3a98253be39f82fc(s_5566_0, s_5566_1, s_5566_2, s_5566_3, s_5566_4, s_5566_5, s_5566_6)
        let s_5566_7: () = PMOVSR_SysRegRead32_3a98253be39f82fc(
            state,
            tracer,
            s_5566_0,
            s_5566_1,
            s_5566_2,
            s_5566_3,
            s_5566_4,
            s_5566_5,
            s_5566_6,
        );
        // N s_5566_8: return
        return;
    }
    fn block_5567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5567_0: read-var opc2:u8
        let s_5567_0: u8 = fn_state.opc2;
        // D s_5567_1: cast zx s_5567_0 -> bv
        let s_5567_1: Bits = Bits::new(s_5567_0 as u128, 3u16);
        // C s_5567_2: const #3u : u8
        let s_5567_2: u8 = 3;
        // C s_5567_3: cast zx s_5567_2 -> bv
        let s_5567_3: Bits = Bits::new(s_5567_2 as u128, 3u16);
        // D s_5567_4: cmp-eq s_5567_1 s_5567_3
        let s_5567_4: bool = ((s_5567_1) == (s_5567_3));
        // D s_5567_5: write-var gs#117631 <= s_5567_4
        fn_state.gs_117631 = s_5567_4;
        // N s_5567_6: jump b188
        return block_188(state, tracer, fn_state);
    }
    fn block_5568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5568_0: read-var opc1:u8
        let s_5568_0: u8 = fn_state.opc1;
        // D s_5568_1: cast zx s_5568_0 -> bv
        let s_5568_1: Bits = Bits::new(s_5568_0 as u128, 3u16);
        // C s_5568_2: const #0u : u8
        let s_5568_2: u8 = 0;
        // C s_5568_3: cast zx s_5568_2 -> bv
        let s_5568_3: Bits = Bits::new(s_5568_2 as u128, 3u16);
        // D s_5568_4: cmp-eq s_5568_1 s_5568_3
        let s_5568_4: bool = ((s_5568_1) == (s_5568_3));
        // D s_5568_5: write-var gs#117630 <= s_5568_4
        fn_state.gs_117630 = s_5568_4;
        // N s_5568_6: jump b186
        return block_186(state, tracer, fn_state);
    }
    fn block_5569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5569_0: read-var coproc:u8
        let s_5569_0: u8 = fn_state.coproc;
        // D s_5569_1: cast zx s_5569_0 -> bv
        let s_5569_1: Bits = Bits::new(s_5569_0 as u128, 4u16);
        // C s_5569_2: const #15u : u8
        let s_5569_2: u8 = 15;
        // C s_5569_3: cast zx s_5569_2 -> bv
        let s_5569_3: Bits = Bits::new(s_5569_2 as u128, 4u16);
        // D s_5569_4: cmp-eq s_5569_1 s_5569_3
        let s_5569_4: bool = ((s_5569_1) == (s_5569_3));
        // D s_5569_5: write-var gs#117629 <= s_5569_4
        fn_state.gs_117629 = s_5569_4;
        // N s_5569_6: jump b184
        return block_184(state, tracer, fn_state);
    }
    fn block_5570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5570_0: read-var CRn:u8
        let s_5570_0: u8 = fn_state.CRn;
        // D s_5570_1: cast zx s_5570_0 -> bv
        let s_5570_1: Bits = Bits::new(s_5570_0 as u128, 4u16);
        // C s_5570_2: const #9u : u8
        let s_5570_2: u8 = 9;
        // C s_5570_3: cast zx s_5570_2 -> bv
        let s_5570_3: Bits = Bits::new(s_5570_2 as u128, 4u16);
        // D s_5570_4: cmp-eq s_5570_1 s_5570_3
        let s_5570_4: bool = ((s_5570_1) == (s_5570_3));
        // D s_5570_5: write-var gs#117628 <= s_5570_4
        fn_state.gs_117628 = s_5570_4;
        // N s_5570_6: jump b182
        return block_182(state, tracer, fn_state);
    }
    fn block_5571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5571_0: read-var el:u8
        let s_5571_0: u8 = fn_state.el;
        // D s_5571_1: read-var coproc:u8
        let s_5571_1: u8 = fn_state.coproc;
        // D s_5571_2: read-var opc1:u8
        let s_5571_2: u8 = fn_state.opc1;
        // D s_5571_3: read-var CRn:u8
        let s_5571_3: u8 = fn_state.CRn;
        // D s_5571_4: read-var opc2:u8
        let s_5571_4: u8 = fn_state.opc2;
        // D s_5571_5: read-var CRm:u8
        let s_5571_5: u8 = fn_state.CRm;
        // D s_5571_6: read-var t:i
        let s_5571_6: i128 = fn_state.t;
        // D s_5571_7: call ICV_IGRPEN1_SysRegRead32_9335bbfc906f43aa(s_5571_0, s_5571_1, s_5571_2, s_5571_3, s_5571_4, s_5571_5, s_5571_6)
        let s_5571_7: () = ICV_IGRPEN1_SysRegRead32_9335bbfc906f43aa(
            state,
            tracer,
            s_5571_0,
            s_5571_1,
            s_5571_2,
            s_5571_3,
            s_5571_4,
            s_5571_5,
            s_5571_6,
        );
        // N s_5571_8: return
        return;
    }
    fn block_5572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5572_0: read-var opc2:u8
        let s_5572_0: u8 = fn_state.opc2;
        // D s_5572_1: cast zx s_5572_0 -> bv
        let s_5572_1: Bits = Bits::new(s_5572_0 as u128, 3u16);
        // C s_5572_2: const #7u : u8
        let s_5572_2: u8 = 7;
        // C s_5572_3: cast zx s_5572_2 -> bv
        let s_5572_3: Bits = Bits::new(s_5572_2 as u128, 3u16);
        // D s_5572_4: cmp-eq s_5572_1 s_5572_3
        let s_5572_4: bool = ((s_5572_1) == (s_5572_3));
        // D s_5572_5: write-var gs#117627 <= s_5572_4
        fn_state.gs_117627 = s_5572_4;
        // N s_5572_6: jump b179
        return block_179(state, tracer, fn_state);
    }
    fn block_5573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5573_0: read-var opc1:u8
        let s_5573_0: u8 = fn_state.opc1;
        // D s_5573_1: cast zx s_5573_0 -> bv
        let s_5573_1: Bits = Bits::new(s_5573_0 as u128, 3u16);
        // C s_5573_2: const #0u : u8
        let s_5573_2: u8 = 0;
        // C s_5573_3: cast zx s_5573_2 -> bv
        let s_5573_3: Bits = Bits::new(s_5573_2 as u128, 3u16);
        // D s_5573_4: cmp-eq s_5573_1 s_5573_3
        let s_5573_4: bool = ((s_5573_1) == (s_5573_3));
        // D s_5573_5: write-var gs#117626 <= s_5573_4
        fn_state.gs_117626 = s_5573_4;
        // N s_5573_6: jump b177
        return block_177(state, tracer, fn_state);
    }
    fn block_5574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5574_0: read-var coproc:u8
        let s_5574_0: u8 = fn_state.coproc;
        // D s_5574_1: cast zx s_5574_0 -> bv
        let s_5574_1: Bits = Bits::new(s_5574_0 as u128, 4u16);
        // C s_5574_2: const #15u : u8
        let s_5574_2: u8 = 15;
        // C s_5574_3: cast zx s_5574_2 -> bv
        let s_5574_3: Bits = Bits::new(s_5574_2 as u128, 4u16);
        // D s_5574_4: cmp-eq s_5574_1 s_5574_3
        let s_5574_4: bool = ((s_5574_1) == (s_5574_3));
        // D s_5574_5: write-var gs#117625 <= s_5574_4
        fn_state.gs_117625 = s_5574_4;
        // N s_5574_6: jump b175
        return block_175(state, tracer, fn_state);
    }
    fn block_5575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5575_0: read-var CRn:u8
        let s_5575_0: u8 = fn_state.CRn;
        // D s_5575_1: cast zx s_5575_0 -> bv
        let s_5575_1: Bits = Bits::new(s_5575_0 as u128, 4u16);
        // C s_5575_2: const #12u : u8
        let s_5575_2: u8 = 12;
        // C s_5575_3: cast zx s_5575_2 -> bv
        let s_5575_3: Bits = Bits::new(s_5575_2 as u128, 4u16);
        // D s_5575_4: cmp-eq s_5575_1 s_5575_3
        let s_5575_4: bool = ((s_5575_1) == (s_5575_3));
        // D s_5575_5: write-var gs#117624 <= s_5575_4
        fn_state.gs_117624 = s_5575_4;
        // N s_5575_6: jump b173
        return block_173(state, tracer, fn_state);
    }
    fn block_5576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5576_0: read-var el:u8
        let s_5576_0: u8 = fn_state.el;
        // D s_5576_1: read-var coproc:u8
        let s_5576_1: u8 = fn_state.coproc;
        // D s_5576_2: read-var opc1:u8
        let s_5576_2: u8 = fn_state.opc1;
        // D s_5576_3: read-var CRn:u8
        let s_5576_3: u8 = fn_state.CRn;
        // D s_5576_4: read-var opc2:u8
        let s_5576_4: u8 = fn_state.opc2;
        // D s_5576_5: read-var CRm:u8
        let s_5576_5: u8 = fn_state.CRm;
        // D s_5576_6: read-var t:i
        let s_5576_6: i128 = fn_state.t;
        // D s_5576_7: call HCPTR_SysRegRead32_36b5e5e38803084d(s_5576_0, s_5576_1, s_5576_2, s_5576_3, s_5576_4, s_5576_5, s_5576_6)
        let s_5576_7: () = HCPTR_SysRegRead32_36b5e5e38803084d(
            state,
            tracer,
            s_5576_0,
            s_5576_1,
            s_5576_2,
            s_5576_3,
            s_5576_4,
            s_5576_5,
            s_5576_6,
        );
        // N s_5576_8: return
        return;
    }
    fn block_5577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5577_0: read-var opc2:u8
        let s_5577_0: u8 = fn_state.opc2;
        // D s_5577_1: cast zx s_5577_0 -> bv
        let s_5577_1: Bits = Bits::new(s_5577_0 as u128, 3u16);
        // C s_5577_2: const #2u : u8
        let s_5577_2: u8 = 2;
        // C s_5577_3: cast zx s_5577_2 -> bv
        let s_5577_3: Bits = Bits::new(s_5577_2 as u128, 3u16);
        // D s_5577_4: cmp-eq s_5577_1 s_5577_3
        let s_5577_4: bool = ((s_5577_1) == (s_5577_3));
        // D s_5577_5: write-var gs#117623 <= s_5577_4
        fn_state.gs_117623 = s_5577_4;
        // N s_5577_6: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_5578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5578_0: read-var opc1:u8
        let s_5578_0: u8 = fn_state.opc1;
        // D s_5578_1: cast zx s_5578_0 -> bv
        let s_5578_1: Bits = Bits::new(s_5578_0 as u128, 3u16);
        // C s_5578_2: const #4u : u8
        let s_5578_2: u8 = 4;
        // C s_5578_3: cast zx s_5578_2 -> bv
        let s_5578_3: Bits = Bits::new(s_5578_2 as u128, 3u16);
        // D s_5578_4: cmp-eq s_5578_1 s_5578_3
        let s_5578_4: bool = ((s_5578_1) == (s_5578_3));
        // D s_5578_5: write-var gs#117622 <= s_5578_4
        fn_state.gs_117622 = s_5578_4;
        // N s_5578_6: jump b168
        return block_168(state, tracer, fn_state);
    }
    fn block_5579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5579_0: read-var coproc:u8
        let s_5579_0: u8 = fn_state.coproc;
        // D s_5579_1: cast zx s_5579_0 -> bv
        let s_5579_1: Bits = Bits::new(s_5579_0 as u128, 4u16);
        // C s_5579_2: const #15u : u8
        let s_5579_2: u8 = 15;
        // C s_5579_3: cast zx s_5579_2 -> bv
        let s_5579_3: Bits = Bits::new(s_5579_2 as u128, 4u16);
        // D s_5579_4: cmp-eq s_5579_1 s_5579_3
        let s_5579_4: bool = ((s_5579_1) == (s_5579_3));
        // D s_5579_5: write-var gs#117621 <= s_5579_4
        fn_state.gs_117621 = s_5579_4;
        // N s_5579_6: jump b166
        return block_166(state, tracer, fn_state);
    }
    fn block_5580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5580_0: read-var CRn:u8
        let s_5580_0: u8 = fn_state.CRn;
        // D s_5580_1: cast zx s_5580_0 -> bv
        let s_5580_1: Bits = Bits::new(s_5580_0 as u128, 4u16);
        // C s_5580_2: const #1u : u8
        let s_5580_2: u8 = 1;
        // C s_5580_3: cast zx s_5580_2 -> bv
        let s_5580_3: Bits = Bits::new(s_5580_2 as u128, 4u16);
        // D s_5580_4: cmp-eq s_5580_1 s_5580_3
        let s_5580_4: bool = ((s_5580_1) == (s_5580_3));
        // D s_5580_5: write-var gs#117620 <= s_5580_4
        fn_state.gs_117620 = s_5580_4;
        // N s_5580_6: jump b164
        return block_164(state, tracer, fn_state);
    }
    fn block_5581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5581_0: read-var el:u8
        let s_5581_0: u8 = fn_state.el;
        // D s_5581_1: read-var coproc:u8
        let s_5581_1: u8 = fn_state.coproc;
        // D s_5581_2: read-var opc1:u8
        let s_5581_2: u8 = fn_state.opc1;
        // D s_5581_3: read-var CRn:u8
        let s_5581_3: u8 = fn_state.CRn;
        // D s_5581_4: read-var opc2:u8
        let s_5581_4: u8 = fn_state.opc2;
        // D s_5581_5: read-var CRm:u8
        let s_5581_5: u8 = fn_state.CRm;
        // D s_5581_6: read-var t:i
        let s_5581_6: i128 = fn_state.t;
        // D s_5581_7: call JOSCR_SysRegRead32_64dbf044d539336d(s_5581_0, s_5581_1, s_5581_2, s_5581_3, s_5581_4, s_5581_5, s_5581_6)
        let s_5581_7: () = JOSCR_SysRegRead32_64dbf044d539336d(
            state,
            tracer,
            s_5581_0,
            s_5581_1,
            s_5581_2,
            s_5581_3,
            s_5581_4,
            s_5581_5,
            s_5581_6,
        );
        // N s_5581_8: return
        return;
    }
    fn block_5582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5582_0: read-var opc2:u8
        let s_5582_0: u8 = fn_state.opc2;
        // D s_5582_1: cast zx s_5582_0 -> bv
        let s_5582_1: Bits = Bits::new(s_5582_0 as u128, 3u16);
        // C s_5582_2: const #0u : u8
        let s_5582_2: u8 = 0;
        // C s_5582_3: cast zx s_5582_2 -> bv
        let s_5582_3: Bits = Bits::new(s_5582_2 as u128, 3u16);
        // D s_5582_4: cmp-eq s_5582_1 s_5582_3
        let s_5582_4: bool = ((s_5582_1) == (s_5582_3));
        // D s_5582_5: write-var gs#117619 <= s_5582_4
        fn_state.gs_117619 = s_5582_4;
        // N s_5582_6: jump b161
        return block_161(state, tracer, fn_state);
    }
    fn block_5583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5583_0: read-var opc1:u8
        let s_5583_0: u8 = fn_state.opc1;
        // D s_5583_1: cast zx s_5583_0 -> bv
        let s_5583_1: Bits = Bits::new(s_5583_0 as u128, 3u16);
        // C s_5583_2: const #7u : u8
        let s_5583_2: u8 = 7;
        // C s_5583_3: cast zx s_5583_2 -> bv
        let s_5583_3: Bits = Bits::new(s_5583_2 as u128, 3u16);
        // D s_5583_4: cmp-eq s_5583_1 s_5583_3
        let s_5583_4: bool = ((s_5583_1) == (s_5583_3));
        // D s_5583_5: write-var gs#117618 <= s_5583_4
        fn_state.gs_117618 = s_5583_4;
        // N s_5583_6: jump b159
        return block_159(state, tracer, fn_state);
    }
    fn block_5584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5584_0: read-var coproc:u8
        let s_5584_0: u8 = fn_state.coproc;
        // D s_5584_1: cast zx s_5584_0 -> bv
        let s_5584_1: Bits = Bits::new(s_5584_0 as u128, 4u16);
        // C s_5584_2: const #14u : u8
        let s_5584_2: u8 = 14;
        // C s_5584_3: cast zx s_5584_2 -> bv
        let s_5584_3: Bits = Bits::new(s_5584_2 as u128, 4u16);
        // D s_5584_4: cmp-eq s_5584_1 s_5584_3
        let s_5584_4: bool = ((s_5584_1) == (s_5584_3));
        // D s_5584_5: write-var gs#117617 <= s_5584_4
        fn_state.gs_117617 = s_5584_4;
        // N s_5584_6: jump b157
        return block_157(state, tracer, fn_state);
    }
    fn block_5585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5585_0: read-var CRn:u8
        let s_5585_0: u8 = fn_state.CRn;
        // D s_5585_1: cast zx s_5585_0 -> bv
        let s_5585_1: Bits = Bits::new(s_5585_0 as u128, 4u16);
        // C s_5585_2: const #1u : u8
        let s_5585_2: u8 = 1;
        // C s_5585_3: cast zx s_5585_2 -> bv
        let s_5585_3: Bits = Bits::new(s_5585_2 as u128, 4u16);
        // D s_5585_4: cmp-eq s_5585_1 s_5585_3
        let s_5585_4: bool = ((s_5585_1) == (s_5585_3));
        // D s_5585_5: write-var gs#117616 <= s_5585_4
        fn_state.gs_117616 = s_5585_4;
        // N s_5585_6: jump b155
        return block_155(state, tracer, fn_state);
    }
    fn block_5586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5586_0: read-var el:u8
        let s_5586_0: u8 = fn_state.el;
        // D s_5586_1: read-var coproc:u8
        let s_5586_1: u8 = fn_state.coproc;
        // D s_5586_2: read-var opc1:u8
        let s_5586_2: u8 = fn_state.opc1;
        // D s_5586_3: read-var CRn:u8
        let s_5586_3: u8 = fn_state.CRn;
        // D s_5586_4: read-var opc2:u8
        let s_5586_4: u8 = fn_state.opc2;
        // D s_5586_5: read-var CRm:u8
        let s_5586_5: u8 = fn_state.CRm;
        // D s_5586_6: read-var t:i
        let s_5586_6: i128 = fn_state.t;
        // D s_5586_7: call HACR_SysRegRead32_a717d701accd9575(s_5586_0, s_5586_1, s_5586_2, s_5586_3, s_5586_4, s_5586_5, s_5586_6)
        let s_5586_7: () = HACR_SysRegRead32_a717d701accd9575(
            state,
            tracer,
            s_5586_0,
            s_5586_1,
            s_5586_2,
            s_5586_3,
            s_5586_4,
            s_5586_5,
            s_5586_6,
        );
        // N s_5586_8: return
        return;
    }
    fn block_5587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5587_0: read-var opc2:u8
        let s_5587_0: u8 = fn_state.opc2;
        // D s_5587_1: cast zx s_5587_0 -> bv
        let s_5587_1: Bits = Bits::new(s_5587_0 as u128, 3u16);
        // C s_5587_2: const #7u : u8
        let s_5587_2: u8 = 7;
        // C s_5587_3: cast zx s_5587_2 -> bv
        let s_5587_3: Bits = Bits::new(s_5587_2 as u128, 3u16);
        // D s_5587_4: cmp-eq s_5587_1 s_5587_3
        let s_5587_4: bool = ((s_5587_1) == (s_5587_3));
        // D s_5587_5: write-var gs#117615 <= s_5587_4
        fn_state.gs_117615 = s_5587_4;
        // N s_5587_6: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_5588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5588_0: read-var opc1:u8
        let s_5588_0: u8 = fn_state.opc1;
        // D s_5588_1: cast zx s_5588_0 -> bv
        let s_5588_1: Bits = Bits::new(s_5588_0 as u128, 3u16);
        // C s_5588_2: const #4u : u8
        let s_5588_2: u8 = 4;
        // C s_5588_3: cast zx s_5588_2 -> bv
        let s_5588_3: Bits = Bits::new(s_5588_2 as u128, 3u16);
        // D s_5588_4: cmp-eq s_5588_1 s_5588_3
        let s_5588_4: bool = ((s_5588_1) == (s_5588_3));
        // D s_5588_5: write-var gs#117614 <= s_5588_4
        fn_state.gs_117614 = s_5588_4;
        // N s_5588_6: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_5589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5589_0: read-var coproc:u8
        let s_5589_0: u8 = fn_state.coproc;
        // D s_5589_1: cast zx s_5589_0 -> bv
        let s_5589_1: Bits = Bits::new(s_5589_0 as u128, 4u16);
        // C s_5589_2: const #15u : u8
        let s_5589_2: u8 = 15;
        // C s_5589_3: cast zx s_5589_2 -> bv
        let s_5589_3: Bits = Bits::new(s_5589_2 as u128, 4u16);
        // D s_5589_4: cmp-eq s_5589_1 s_5589_3
        let s_5589_4: bool = ((s_5589_1) == (s_5589_3));
        // D s_5589_5: write-var gs#117613 <= s_5589_4
        fn_state.gs_117613 = s_5589_4;
        // N s_5589_6: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_5590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5590_0: read-var CRn:u8
        let s_5590_0: u8 = fn_state.CRn;
        // D s_5590_1: cast zx s_5590_0 -> bv
        let s_5590_1: Bits = Bits::new(s_5590_0 as u128, 4u16);
        // C s_5590_2: const #1u : u8
        let s_5590_2: u8 = 1;
        // C s_5590_3: cast zx s_5590_2 -> bv
        let s_5590_3: Bits = Bits::new(s_5590_2 as u128, 4u16);
        // D s_5590_4: cmp-eq s_5590_1 s_5590_3
        let s_5590_4: bool = ((s_5590_1) == (s_5590_3));
        // D s_5590_5: write-var gs#117612 <= s_5590_4
        fn_state.gs_117612 = s_5590_4;
        // N s_5590_6: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_5591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5591_0: read-var el:u8
        let s_5591_0: u8 = fn_state.el;
        // D s_5591_1: read-var coproc:u8
        let s_5591_1: u8 = fn_state.coproc;
        // D s_5591_2: read-var opc1:u8
        let s_5591_2: u8 = fn_state.opc1;
        // D s_5591_3: read-var CRn:u8
        let s_5591_3: u8 = fn_state.CRn;
        // D s_5591_4: read-var opc2:u8
        let s_5591_4: u8 = fn_state.opc2;
        // D s_5591_5: read-var CRm:u8
        let s_5591_5: u8 = fn_state.CRm;
        // D s_5591_6: read-var t:i
        let s_5591_6: i128 = fn_state.t;
        // D s_5591_7: call CLIDR_SysRegRead32_1324f310591d527a(s_5591_0, s_5591_1, s_5591_2, s_5591_3, s_5591_4, s_5591_5, s_5591_6)
        let s_5591_7: () = CLIDR_SysRegRead32_1324f310591d527a(
            state,
            tracer,
            s_5591_0,
            s_5591_1,
            s_5591_2,
            s_5591_3,
            s_5591_4,
            s_5591_5,
            s_5591_6,
        );
        // N s_5591_8: return
        return;
    }
    fn block_5592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5592_0: read-var opc2:u8
        let s_5592_0: u8 = fn_state.opc2;
        // D s_5592_1: cast zx s_5592_0 -> bv
        let s_5592_1: Bits = Bits::new(s_5592_0 as u128, 3u16);
        // C s_5592_2: const #1u : u8
        let s_5592_2: u8 = 1;
        // C s_5592_3: cast zx s_5592_2 -> bv
        let s_5592_3: Bits = Bits::new(s_5592_2 as u128, 3u16);
        // D s_5592_4: cmp-eq s_5592_1 s_5592_3
        let s_5592_4: bool = ((s_5592_1) == (s_5592_3));
        // D s_5592_5: write-var gs#117611 <= s_5592_4
        fn_state.gs_117611 = s_5592_4;
        // N s_5592_6: jump b143
        return block_143(state, tracer, fn_state);
    }
    fn block_5593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5593_0: read-var opc1:u8
        let s_5593_0: u8 = fn_state.opc1;
        // D s_5593_1: cast zx s_5593_0 -> bv
        let s_5593_1: Bits = Bits::new(s_5593_0 as u128, 3u16);
        // C s_5593_2: const #1u : u8
        let s_5593_2: u8 = 1;
        // C s_5593_3: cast zx s_5593_2 -> bv
        let s_5593_3: Bits = Bits::new(s_5593_2 as u128, 3u16);
        // D s_5593_4: cmp-eq s_5593_1 s_5593_3
        let s_5593_4: bool = ((s_5593_1) == (s_5593_3));
        // D s_5593_5: write-var gs#117610 <= s_5593_4
        fn_state.gs_117610 = s_5593_4;
        // N s_5593_6: jump b141
        return block_141(state, tracer, fn_state);
    }
    fn block_5594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5594_0: read-var coproc:u8
        let s_5594_0: u8 = fn_state.coproc;
        // D s_5594_1: cast zx s_5594_0 -> bv
        let s_5594_1: Bits = Bits::new(s_5594_0 as u128, 4u16);
        // C s_5594_2: const #15u : u8
        let s_5594_2: u8 = 15;
        // C s_5594_3: cast zx s_5594_2 -> bv
        let s_5594_3: Bits = Bits::new(s_5594_2 as u128, 4u16);
        // D s_5594_4: cmp-eq s_5594_1 s_5594_3
        let s_5594_4: bool = ((s_5594_1) == (s_5594_3));
        // D s_5594_5: write-var gs#117609 <= s_5594_4
        fn_state.gs_117609 = s_5594_4;
        // N s_5594_6: jump b139
        return block_139(state, tracer, fn_state);
    }
    fn block_5595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5595_0: read-var CRn:u8
        let s_5595_0: u8 = fn_state.CRn;
        // D s_5595_1: cast zx s_5595_0 -> bv
        let s_5595_1: Bits = Bits::new(s_5595_0 as u128, 4u16);
        // C s_5595_2: const #0u : u8
        let s_5595_2: u8 = 0;
        // C s_5595_3: cast zx s_5595_2 -> bv
        let s_5595_3: Bits = Bits::new(s_5595_2 as u128, 4u16);
        // D s_5595_4: cmp-eq s_5595_1 s_5595_3
        let s_5595_4: bool = ((s_5595_1) == (s_5595_3));
        // D s_5595_5: write-var gs#117608 <= s_5595_4
        fn_state.gs_117608 = s_5595_4;
        // N s_5595_6: jump b137
        return block_137(state, tracer, fn_state);
    }
    fn block_5596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5596_0: read-var el:u8
        let s_5596_0: u8 = fn_state.el;
        // D s_5596_1: read-var coproc:u8
        let s_5596_1: u8 = fn_state.coproc;
        // D s_5596_2: read-var opc1:u8
        let s_5596_2: u8 = fn_state.opc1;
        // D s_5596_3: read-var CRn:u8
        let s_5596_3: u8 = fn_state.CRn;
        // D s_5596_4: read-var opc2:u8
        let s_5596_4: u8 = fn_state.opc2;
        // D s_5596_5: read-var CRm:u8
        let s_5596_5: u8 = fn_state.CRm;
        // D s_5596_6: read-var t:i
        let s_5596_6: i128 = fn_state.t;
        // D s_5596_7: call ID_DFR0_SysRegRead32_cc2c637f50f14510(s_5596_0, s_5596_1, s_5596_2, s_5596_3, s_5596_4, s_5596_5, s_5596_6)
        let s_5596_7: () = ID_DFR0_SysRegRead32_cc2c637f50f14510(
            state,
            tracer,
            s_5596_0,
            s_5596_1,
            s_5596_2,
            s_5596_3,
            s_5596_4,
            s_5596_5,
            s_5596_6,
        );
        // N s_5596_8: return
        return;
    }
    fn block_5597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5597_0: read-var opc2:u8
        let s_5597_0: u8 = fn_state.opc2;
        // D s_5597_1: cast zx s_5597_0 -> bv
        let s_5597_1: Bits = Bits::new(s_5597_0 as u128, 3u16);
        // C s_5597_2: const #2u : u8
        let s_5597_2: u8 = 2;
        // C s_5597_3: cast zx s_5597_2 -> bv
        let s_5597_3: Bits = Bits::new(s_5597_2 as u128, 3u16);
        // D s_5597_4: cmp-eq s_5597_1 s_5597_3
        let s_5597_4: bool = ((s_5597_1) == (s_5597_3));
        // D s_5597_5: write-var gs#117607 <= s_5597_4
        fn_state.gs_117607 = s_5597_4;
        // N s_5597_6: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_5598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5598_0: read-var opc1:u8
        let s_5598_0: u8 = fn_state.opc1;
        // D s_5598_1: cast zx s_5598_0 -> bv
        let s_5598_1: Bits = Bits::new(s_5598_0 as u128, 3u16);
        // C s_5598_2: const #0u : u8
        let s_5598_2: u8 = 0;
        // C s_5598_3: cast zx s_5598_2 -> bv
        let s_5598_3: Bits = Bits::new(s_5598_2 as u128, 3u16);
        // D s_5598_4: cmp-eq s_5598_1 s_5598_3
        let s_5598_4: bool = ((s_5598_1) == (s_5598_3));
        // D s_5598_5: write-var gs#117606 <= s_5598_4
        fn_state.gs_117606 = s_5598_4;
        // N s_5598_6: jump b132
        return block_132(state, tracer, fn_state);
    }
    fn block_5599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5599_0: read-var coproc:u8
        let s_5599_0: u8 = fn_state.coproc;
        // D s_5599_1: cast zx s_5599_0 -> bv
        let s_5599_1: Bits = Bits::new(s_5599_0 as u128, 4u16);
        // C s_5599_2: const #15u : u8
        let s_5599_2: u8 = 15;
        // C s_5599_3: cast zx s_5599_2 -> bv
        let s_5599_3: Bits = Bits::new(s_5599_2 as u128, 4u16);
        // D s_5599_4: cmp-eq s_5599_1 s_5599_3
        let s_5599_4: bool = ((s_5599_1) == (s_5599_3));
        // D s_5599_5: write-var gs#117605 <= s_5599_4
        fn_state.gs_117605 = s_5599_4;
        // N s_5599_6: jump b130
        return block_130(state, tracer, fn_state);
    }
    fn block_5600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5600_0: read-var CRn:u8
        let s_5600_0: u8 = fn_state.CRn;
        // D s_5600_1: cast zx s_5600_0 -> bv
        let s_5600_1: Bits = Bits::new(s_5600_0 as u128, 4u16);
        // C s_5600_2: const #0u : u8
        let s_5600_2: u8 = 0;
        // C s_5600_3: cast zx s_5600_2 -> bv
        let s_5600_3: Bits = Bits::new(s_5600_2 as u128, 4u16);
        // D s_5600_4: cmp-eq s_5600_1 s_5600_3
        let s_5600_4: bool = ((s_5600_1) == (s_5600_3));
        // D s_5600_5: write-var gs#117604 <= s_5600_4
        fn_state.gs_117604 = s_5600_4;
        // N s_5600_6: jump b128
        return block_128(state, tracer, fn_state);
    }
    fn block_5601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5601_0: read-var el:u8
        let s_5601_0: u8 = fn_state.el;
        // D s_5601_1: read-var coproc:u8
        let s_5601_1: u8 = fn_state.coproc;
        // D s_5601_2: read-var opc1:u8
        let s_5601_2: u8 = fn_state.opc1;
        // D s_5601_3: read-var CRn:u8
        let s_5601_3: u8 = fn_state.CRn;
        // D s_5601_4: read-var opc2:u8
        let s_5601_4: u8 = fn_state.opc2;
        // D s_5601_5: read-var CRm:u8
        let s_5601_5: u8 = fn_state.CRm;
        // D s_5601_6: read-var t:i
        let s_5601_6: i128 = fn_state.t;
        // D s_5601_7: call HIFAR_SysRegRead32_97075d5570b400a8(s_5601_0, s_5601_1, s_5601_2, s_5601_3, s_5601_4, s_5601_5, s_5601_6)
        let s_5601_7: () = HIFAR_SysRegRead32_97075d5570b400a8(
            state,
            tracer,
            s_5601_0,
            s_5601_1,
            s_5601_2,
            s_5601_3,
            s_5601_4,
            s_5601_5,
            s_5601_6,
        );
        // N s_5601_8: return
        return;
    }
    fn block_5602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5602_0: read-var opc2:u8
        let s_5602_0: u8 = fn_state.opc2;
        // D s_5602_1: cast zx s_5602_0 -> bv
        let s_5602_1: Bits = Bits::new(s_5602_0 as u128, 3u16);
        // C s_5602_2: const #2u : u8
        let s_5602_2: u8 = 2;
        // C s_5602_3: cast zx s_5602_2 -> bv
        let s_5602_3: Bits = Bits::new(s_5602_2 as u128, 3u16);
        // D s_5602_4: cmp-eq s_5602_1 s_5602_3
        let s_5602_4: bool = ((s_5602_1) == (s_5602_3));
        // D s_5602_5: write-var gs#117603 <= s_5602_4
        fn_state.gs_117603 = s_5602_4;
        // N s_5602_6: jump b125
        return block_125(state, tracer, fn_state);
    }
    fn block_5603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5603_0: read-var opc1:u8
        let s_5603_0: u8 = fn_state.opc1;
        // D s_5603_1: cast zx s_5603_0 -> bv
        let s_5603_1: Bits = Bits::new(s_5603_0 as u128, 3u16);
        // C s_5603_2: const #4u : u8
        let s_5603_2: u8 = 4;
        // C s_5603_3: cast zx s_5603_2 -> bv
        let s_5603_3: Bits = Bits::new(s_5603_2 as u128, 3u16);
        // D s_5603_4: cmp-eq s_5603_1 s_5603_3
        let s_5603_4: bool = ((s_5603_1) == (s_5603_3));
        // D s_5603_5: write-var gs#117602 <= s_5603_4
        fn_state.gs_117602 = s_5603_4;
        // N s_5603_6: jump b123
        return block_123(state, tracer, fn_state);
    }
    fn block_5604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5604_0: read-var coproc:u8
        let s_5604_0: u8 = fn_state.coproc;
        // D s_5604_1: cast zx s_5604_0 -> bv
        let s_5604_1: Bits = Bits::new(s_5604_0 as u128, 4u16);
        // C s_5604_2: const #15u : u8
        let s_5604_2: u8 = 15;
        // C s_5604_3: cast zx s_5604_2 -> bv
        let s_5604_3: Bits = Bits::new(s_5604_2 as u128, 4u16);
        // D s_5604_4: cmp-eq s_5604_1 s_5604_3
        let s_5604_4: bool = ((s_5604_1) == (s_5604_3));
        // D s_5604_5: write-var gs#117601 <= s_5604_4
        fn_state.gs_117601 = s_5604_4;
        // N s_5604_6: jump b121
        return block_121(state, tracer, fn_state);
    }
    fn block_5605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5605_0: read-var CRn:u8
        let s_5605_0: u8 = fn_state.CRn;
        // D s_5605_1: cast zx s_5605_0 -> bv
        let s_5605_1: Bits = Bits::new(s_5605_0 as u128, 4u16);
        // C s_5605_2: const #6u : u8
        let s_5605_2: u8 = 6;
        // C s_5605_3: cast zx s_5605_2 -> bv
        let s_5605_3: Bits = Bits::new(s_5605_2 as u128, 4u16);
        // D s_5605_4: cmp-eq s_5605_1 s_5605_3
        let s_5605_4: bool = ((s_5605_1) == (s_5605_3));
        // D s_5605_5: write-var gs#117600 <= s_5605_4
        fn_state.gs_117600 = s_5605_4;
        // N s_5605_6: jump b119
        return block_119(state, tracer, fn_state);
    }
    fn block_5606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5606_0: read-var el:u8
        let s_5606_0: u8 = fn_state.el;
        // D s_5606_1: read-var coproc:u8
        let s_5606_1: u8 = fn_state.coproc;
        // D s_5606_2: read-var opc1:u8
        let s_5606_2: u8 = fn_state.opc1;
        // D s_5606_3: read-var CRn:u8
        let s_5606_3: u8 = fn_state.CRn;
        // D s_5606_4: read-var opc2:u8
        let s_5606_4: u8 = fn_state.opc2;
        // D s_5606_5: read-var CRm:u8
        let s_5606_5: u8 = fn_state.CRm;
        // D s_5606_6: read-var t:i
        let s_5606_6: i128 = fn_state.t;
        // D s_5606_7: call AIFSR_SysRegRead32_dcd7a0d08b788988(s_5606_0, s_5606_1, s_5606_2, s_5606_3, s_5606_4, s_5606_5, s_5606_6)
        let s_5606_7: () = AIFSR_SysRegRead32_dcd7a0d08b788988(
            state,
            tracer,
            s_5606_0,
            s_5606_1,
            s_5606_2,
            s_5606_3,
            s_5606_4,
            s_5606_5,
            s_5606_6,
        );
        // N s_5606_8: return
        return;
    }
    fn block_5607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5607_0: read-var opc2:u8
        let s_5607_0: u8 = fn_state.opc2;
        // D s_5607_1: cast zx s_5607_0 -> bv
        let s_5607_1: Bits = Bits::new(s_5607_0 as u128, 3u16);
        // C s_5607_2: const #1u : u8
        let s_5607_2: u8 = 1;
        // C s_5607_3: cast zx s_5607_2 -> bv
        let s_5607_3: Bits = Bits::new(s_5607_2 as u128, 3u16);
        // D s_5607_4: cmp-eq s_5607_1 s_5607_3
        let s_5607_4: bool = ((s_5607_1) == (s_5607_3));
        // D s_5607_5: write-var gs#117599 <= s_5607_4
        fn_state.gs_117599 = s_5607_4;
        // N s_5607_6: jump b116
        return block_116(state, tracer, fn_state);
    }
    fn block_5608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5608_0: read-var opc1:u8
        let s_5608_0: u8 = fn_state.opc1;
        // D s_5608_1: cast zx s_5608_0 -> bv
        let s_5608_1: Bits = Bits::new(s_5608_0 as u128, 3u16);
        // C s_5608_2: const #0u : u8
        let s_5608_2: u8 = 0;
        // C s_5608_3: cast zx s_5608_2 -> bv
        let s_5608_3: Bits = Bits::new(s_5608_2 as u128, 3u16);
        // D s_5608_4: cmp-eq s_5608_1 s_5608_3
        let s_5608_4: bool = ((s_5608_1) == (s_5608_3));
        // D s_5608_5: write-var gs#117598 <= s_5608_4
        fn_state.gs_117598 = s_5608_4;
        // N s_5608_6: jump b114
        return block_114(state, tracer, fn_state);
    }
    fn block_5609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5609_0: read-var coproc:u8
        let s_5609_0: u8 = fn_state.coproc;
        // D s_5609_1: cast zx s_5609_0 -> bv
        let s_5609_1: Bits = Bits::new(s_5609_0 as u128, 4u16);
        // C s_5609_2: const #15u : u8
        let s_5609_2: u8 = 15;
        // C s_5609_3: cast zx s_5609_2 -> bv
        let s_5609_3: Bits = Bits::new(s_5609_2 as u128, 4u16);
        // D s_5609_4: cmp-eq s_5609_1 s_5609_3
        let s_5609_4: bool = ((s_5609_1) == (s_5609_3));
        // D s_5609_5: write-var gs#117597 <= s_5609_4
        fn_state.gs_117597 = s_5609_4;
        // N s_5609_6: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_5610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5610_0: read-var CRn:u8
        let s_5610_0: u8 = fn_state.CRn;
        // D s_5610_1: cast zx s_5610_0 -> bv
        let s_5610_1: Bits = Bits::new(s_5610_0 as u128, 4u16);
        // C s_5610_2: const #5u : u8
        let s_5610_2: u8 = 5;
        // C s_5610_3: cast zx s_5610_2 -> bv
        let s_5610_3: Bits = Bits::new(s_5610_2 as u128, 4u16);
        // D s_5610_4: cmp-eq s_5610_1 s_5610_3
        let s_5610_4: bool = ((s_5610_1) == (s_5610_3));
        // D s_5610_5: write-var gs#117596 <= s_5610_4
        fn_state.gs_117596 = s_5610_4;
        // N s_5610_6: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_5611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5611_0: read-var el:u8
        let s_5611_0: u8 = fn_state.el;
        // D s_5611_1: read-var coproc:u8
        let s_5611_1: u8 = fn_state.coproc;
        // D s_5611_2: read-var opc1:u8
        let s_5611_2: u8 = fn_state.opc1;
        // D s_5611_3: read-var CRn:u8
        let s_5611_3: u8 = fn_state.CRn;
        // D s_5611_4: read-var opc2:u8
        let s_5611_4: u8 = fn_state.opc2;
        // D s_5611_5: read-var CRm:u8
        let s_5611_5: u8 = fn_state.CRm;
        // D s_5611_6: read-var t:i
        let s_5611_6: i128 = fn_state.t;
        // D s_5611_7: call ICC_IAR1_SysRegRead32_8d514dfe4b6957fe(s_5611_0, s_5611_1, s_5611_2, s_5611_3, s_5611_4, s_5611_5, s_5611_6)
        let s_5611_7: () = ICC_IAR1_SysRegRead32_8d514dfe4b6957fe(
            state,
            tracer,
            s_5611_0,
            s_5611_1,
            s_5611_2,
            s_5611_3,
            s_5611_4,
            s_5611_5,
            s_5611_6,
        );
        // N s_5611_8: return
        return;
    }
    fn block_5612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5612_0: read-var opc2:u8
        let s_5612_0: u8 = fn_state.opc2;
        // D s_5612_1: cast zx s_5612_0 -> bv
        let s_5612_1: Bits = Bits::new(s_5612_0 as u128, 3u16);
        // C s_5612_2: const #0u : u8
        let s_5612_2: u8 = 0;
        // C s_5612_3: cast zx s_5612_2 -> bv
        let s_5612_3: Bits = Bits::new(s_5612_2 as u128, 3u16);
        // D s_5612_4: cmp-eq s_5612_1 s_5612_3
        let s_5612_4: bool = ((s_5612_1) == (s_5612_3));
        // D s_5612_5: write-var gs#117595 <= s_5612_4
        fn_state.gs_117595 = s_5612_4;
        // N s_5612_6: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_5613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5613_0: read-var opc1:u8
        let s_5613_0: u8 = fn_state.opc1;
        // D s_5613_1: cast zx s_5613_0 -> bv
        let s_5613_1: Bits = Bits::new(s_5613_0 as u128, 3u16);
        // C s_5613_2: const #0u : u8
        let s_5613_2: u8 = 0;
        // C s_5613_3: cast zx s_5613_2 -> bv
        let s_5613_3: Bits = Bits::new(s_5613_2 as u128, 3u16);
        // D s_5613_4: cmp-eq s_5613_1 s_5613_3
        let s_5613_4: bool = ((s_5613_1) == (s_5613_3));
        // D s_5613_5: write-var gs#117594 <= s_5613_4
        fn_state.gs_117594 = s_5613_4;
        // N s_5613_6: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_5614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5614_0: read-var coproc:u8
        let s_5614_0: u8 = fn_state.coproc;
        // D s_5614_1: cast zx s_5614_0 -> bv
        let s_5614_1: Bits = Bits::new(s_5614_0 as u128, 4u16);
        // C s_5614_2: const #15u : u8
        let s_5614_2: u8 = 15;
        // C s_5614_3: cast zx s_5614_2 -> bv
        let s_5614_3: Bits = Bits::new(s_5614_2 as u128, 4u16);
        // D s_5614_4: cmp-eq s_5614_1 s_5614_3
        let s_5614_4: bool = ((s_5614_1) == (s_5614_3));
        // D s_5614_5: write-var gs#117593 <= s_5614_4
        fn_state.gs_117593 = s_5614_4;
        // N s_5614_6: jump b103
        return block_103(state, tracer, fn_state);
    }
    fn block_5615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5615_0: read-var CRn:u8
        let s_5615_0: u8 = fn_state.CRn;
        // D s_5615_1: cast zx s_5615_0 -> bv
        let s_5615_1: Bits = Bits::new(s_5615_0 as u128, 4u16);
        // C s_5615_2: const #12u : u8
        let s_5615_2: u8 = 12;
        // C s_5615_3: cast zx s_5615_2 -> bv
        let s_5615_3: Bits = Bits::new(s_5615_2 as u128, 4u16);
        // D s_5615_4: cmp-eq s_5615_1 s_5615_3
        let s_5615_4: bool = ((s_5615_1) == (s_5615_3));
        // D s_5615_5: write-var gs#117592 <= s_5615_4
        fn_state.gs_117592 = s_5615_4;
        // N s_5615_6: jump b101
        return block_101(state, tracer, fn_state);
    }
    fn block_5616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5616_0: read-var el:u8
        let s_5616_0: u8 = fn_state.el;
        // D s_5616_1: read-var coproc:u8
        let s_5616_1: u8 = fn_state.coproc;
        // D s_5616_2: read-var opc1:u8
        let s_5616_2: u8 = fn_state.opc1;
        // D s_5616_3: read-var CRn:u8
        let s_5616_3: u8 = fn_state.CRn;
        // D s_5616_4: read-var opc2:u8
        let s_5616_4: u8 = fn_state.opc2;
        // D s_5616_5: read-var CRm:u8
        let s_5616_5: u8 = fn_state.CRm;
        // D s_5616_6: read-var t:i
        let s_5616_6: i128 = fn_state.t;
        // D s_5616_7: call ICH_ELRSR_SysRegRead32_1d9d4e5a379e315c(s_5616_0, s_5616_1, s_5616_2, s_5616_3, s_5616_4, s_5616_5, s_5616_6)
        let s_5616_7: () = ICH_ELRSR_SysRegRead32_1d9d4e5a379e315c(
            state,
            tracer,
            s_5616_0,
            s_5616_1,
            s_5616_2,
            s_5616_3,
            s_5616_4,
            s_5616_5,
            s_5616_6,
        );
        // N s_5616_8: return
        return;
    }
    fn block_5617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5617_0: read-var opc2:u8
        let s_5617_0: u8 = fn_state.opc2;
        // D s_5617_1: cast zx s_5617_0 -> bv
        let s_5617_1: Bits = Bits::new(s_5617_0 as u128, 3u16);
        // C s_5617_2: const #5u : u8
        let s_5617_2: u8 = 5;
        // C s_5617_3: cast zx s_5617_2 -> bv
        let s_5617_3: Bits = Bits::new(s_5617_2 as u128, 3u16);
        // D s_5617_4: cmp-eq s_5617_1 s_5617_3
        let s_5617_4: bool = ((s_5617_1) == (s_5617_3));
        // D s_5617_5: write-var gs#117591 <= s_5617_4
        fn_state.gs_117591 = s_5617_4;
        // N s_5617_6: jump b98
        return block_98(state, tracer, fn_state);
    }
    fn block_5618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5618_0: read-var opc1:u8
        let s_5618_0: u8 = fn_state.opc1;
        // D s_5618_1: cast zx s_5618_0 -> bv
        let s_5618_1: Bits = Bits::new(s_5618_0 as u128, 3u16);
        // C s_5618_2: const #4u : u8
        let s_5618_2: u8 = 4;
        // C s_5618_3: cast zx s_5618_2 -> bv
        let s_5618_3: Bits = Bits::new(s_5618_2 as u128, 3u16);
        // D s_5618_4: cmp-eq s_5618_1 s_5618_3
        let s_5618_4: bool = ((s_5618_1) == (s_5618_3));
        // D s_5618_5: write-var gs#117590 <= s_5618_4
        fn_state.gs_117590 = s_5618_4;
        // N s_5618_6: jump b96
        return block_96(state, tracer, fn_state);
    }
    fn block_5619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5619_0: read-var coproc:u8
        let s_5619_0: u8 = fn_state.coproc;
        // D s_5619_1: cast zx s_5619_0 -> bv
        let s_5619_1: Bits = Bits::new(s_5619_0 as u128, 4u16);
        // C s_5619_2: const #15u : u8
        let s_5619_2: u8 = 15;
        // C s_5619_3: cast zx s_5619_2 -> bv
        let s_5619_3: Bits = Bits::new(s_5619_2 as u128, 4u16);
        // D s_5619_4: cmp-eq s_5619_1 s_5619_3
        let s_5619_4: bool = ((s_5619_1) == (s_5619_3));
        // D s_5619_5: write-var gs#117589 <= s_5619_4
        fn_state.gs_117589 = s_5619_4;
        // N s_5619_6: jump b94
        return block_94(state, tracer, fn_state);
    }
    fn block_5620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5620_0: read-var CRn:u8
        let s_5620_0: u8 = fn_state.CRn;
        // D s_5620_1: cast zx s_5620_0 -> bv
        let s_5620_1: Bits = Bits::new(s_5620_0 as u128, 4u16);
        // C s_5620_2: const #12u : u8
        let s_5620_2: u8 = 12;
        // C s_5620_3: cast zx s_5620_2 -> bv
        let s_5620_3: Bits = Bits::new(s_5620_2 as u128, 4u16);
        // D s_5620_4: cmp-eq s_5620_1 s_5620_3
        let s_5620_4: bool = ((s_5620_1) == (s_5620_3));
        // D s_5620_5: write-var gs#117588 <= s_5620_4
        fn_state.gs_117588 = s_5620_4;
        // N s_5620_6: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_5621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5621_0: read-var el:u8
        let s_5621_0: u8 = fn_state.el;
        // D s_5621_1: read-var coproc:u8
        let s_5621_1: u8 = fn_state.coproc;
        // D s_5621_2: read-var opc1:u8
        let s_5621_2: u8 = fn_state.opc1;
        // D s_5621_3: read-var CRn:u8
        let s_5621_3: u8 = fn_state.CRn;
        // D s_5621_4: read-var opc2:u8
        let s_5621_4: u8 = fn_state.opc2;
        // D s_5621_5: read-var CRm:u8
        let s_5621_5: u8 = fn_state.CRm;
        // D s_5621_6: read-var t:i
        let s_5621_6: i128 = fn_state.t;
        // D s_5621_7: call DBGOSDLR_SysRegRead32_c1e6447a93f7efb4(s_5621_0, s_5621_1, s_5621_2, s_5621_3, s_5621_4, s_5621_5, s_5621_6)
        let s_5621_7: () = DBGOSDLR_SysRegRead32_c1e6447a93f7efb4(
            state,
            tracer,
            s_5621_0,
            s_5621_1,
            s_5621_2,
            s_5621_3,
            s_5621_4,
            s_5621_5,
            s_5621_6,
        );
        // N s_5621_8: return
        return;
    }
    fn block_5622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5622_0: read-var opc2:u8
        let s_5622_0: u8 = fn_state.opc2;
        // D s_5622_1: cast zx s_5622_0 -> bv
        let s_5622_1: Bits = Bits::new(s_5622_0 as u128, 3u16);
        // C s_5622_2: const #4u : u8
        let s_5622_2: u8 = 4;
        // C s_5622_3: cast zx s_5622_2 -> bv
        let s_5622_3: Bits = Bits::new(s_5622_2 as u128, 3u16);
        // D s_5622_4: cmp-eq s_5622_1 s_5622_3
        let s_5622_4: bool = ((s_5622_1) == (s_5622_3));
        // D s_5622_5: write-var gs#117587 <= s_5622_4
        fn_state.gs_117587 = s_5622_4;
        // N s_5622_6: jump b89
        return block_89(state, tracer, fn_state);
    }
    fn block_5623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5623_0: read-var opc1:u8
        let s_5623_0: u8 = fn_state.opc1;
        // D s_5623_1: cast zx s_5623_0 -> bv
        let s_5623_1: Bits = Bits::new(s_5623_0 as u128, 3u16);
        // C s_5623_2: const #0u : u8
        let s_5623_2: u8 = 0;
        // C s_5623_3: cast zx s_5623_2 -> bv
        let s_5623_3: Bits = Bits::new(s_5623_2 as u128, 3u16);
        // D s_5623_4: cmp-eq s_5623_1 s_5623_3
        let s_5623_4: bool = ((s_5623_1) == (s_5623_3));
        // D s_5623_5: write-var gs#117586 <= s_5623_4
        fn_state.gs_117586 = s_5623_4;
        // N s_5623_6: jump b87
        return block_87(state, tracer, fn_state);
    }
    fn block_5624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5624_0: read-var coproc:u8
        let s_5624_0: u8 = fn_state.coproc;
        // D s_5624_1: cast zx s_5624_0 -> bv
        let s_5624_1: Bits = Bits::new(s_5624_0 as u128, 4u16);
        // C s_5624_2: const #14u : u8
        let s_5624_2: u8 = 14;
        // C s_5624_3: cast zx s_5624_2 -> bv
        let s_5624_3: Bits = Bits::new(s_5624_2 as u128, 4u16);
        // D s_5624_4: cmp-eq s_5624_1 s_5624_3
        let s_5624_4: bool = ((s_5624_1) == (s_5624_3));
        // D s_5624_5: write-var gs#117585 <= s_5624_4
        fn_state.gs_117585 = s_5624_4;
        // N s_5624_6: jump b85
        return block_85(state, tracer, fn_state);
    }
    fn block_5625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5625_0: read-var CRn:u8
        let s_5625_0: u8 = fn_state.CRn;
        // D s_5625_1: cast zx s_5625_0 -> bv
        let s_5625_1: Bits = Bits::new(s_5625_0 as u128, 4u16);
        // C s_5625_2: const #1u : u8
        let s_5625_2: u8 = 1;
        // C s_5625_3: cast zx s_5625_2 -> bv
        let s_5625_3: Bits = Bits::new(s_5625_2 as u128, 4u16);
        // D s_5625_4: cmp-eq s_5625_1 s_5625_3
        let s_5625_4: bool = ((s_5625_1) == (s_5625_3));
        // D s_5625_5: write-var gs#117584 <= s_5625_4
        fn_state.gs_117584 = s_5625_4;
        // N s_5625_6: jump b83
        return block_83(state, tracer, fn_state);
    }
    fn block_5626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5626_0: read-var el:u8
        let s_5626_0: u8 = fn_state.el;
        // D s_5626_1: read-var coproc:u8
        let s_5626_1: u8 = fn_state.coproc;
        // D s_5626_2: read-var opc1:u8
        let s_5626_2: u8 = fn_state.opc1;
        // D s_5626_3: read-var CRn:u8
        let s_5626_3: u8 = fn_state.CRn;
        // D s_5626_4: read-var opc2:u8
        let s_5626_4: u8 = fn_state.opc2;
        // D s_5626_5: read-var CRm:u8
        let s_5626_5: u8 = fn_state.CRm;
        // D s_5626_6: read-var t:i
        let s_5626_6: i128 = fn_state.t;
        // D s_5626_7: call HCR_SysRegRead32_9baa0bb29521adc6(s_5626_0, s_5626_1, s_5626_2, s_5626_3, s_5626_4, s_5626_5, s_5626_6)
        let s_5626_7: () = HCR_SysRegRead32_9baa0bb29521adc6(
            state,
            tracer,
            s_5626_0,
            s_5626_1,
            s_5626_2,
            s_5626_3,
            s_5626_4,
            s_5626_5,
            s_5626_6,
        );
        // N s_5626_8: return
        return;
    }
    fn block_5627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5627_0: read-var opc2:u8
        let s_5627_0: u8 = fn_state.opc2;
        // D s_5627_1: cast zx s_5627_0 -> bv
        let s_5627_1: Bits = Bits::new(s_5627_0 as u128, 3u16);
        // C s_5627_2: const #0u : u8
        let s_5627_2: u8 = 0;
        // C s_5627_3: cast zx s_5627_2 -> bv
        let s_5627_3: Bits = Bits::new(s_5627_2 as u128, 3u16);
        // D s_5627_4: cmp-eq s_5627_1 s_5627_3
        let s_5627_4: bool = ((s_5627_1) == (s_5627_3));
        // D s_5627_5: write-var gs#117583 <= s_5627_4
        fn_state.gs_117583 = s_5627_4;
        // N s_5627_6: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_5628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5628_0: read-var opc1:u8
        let s_5628_0: u8 = fn_state.opc1;
        // D s_5628_1: cast zx s_5628_0 -> bv
        let s_5628_1: Bits = Bits::new(s_5628_0 as u128, 3u16);
        // C s_5628_2: const #4u : u8
        let s_5628_2: u8 = 4;
        // C s_5628_3: cast zx s_5628_2 -> bv
        let s_5628_3: Bits = Bits::new(s_5628_2 as u128, 3u16);
        // D s_5628_4: cmp-eq s_5628_1 s_5628_3
        let s_5628_4: bool = ((s_5628_1) == (s_5628_3));
        // D s_5628_5: write-var gs#117582 <= s_5628_4
        fn_state.gs_117582 = s_5628_4;
        // N s_5628_6: jump b78
        return block_78(state, tracer, fn_state);
    }
    fn block_5629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5629_0: read-var coproc:u8
        let s_5629_0: u8 = fn_state.coproc;
        // D s_5629_1: cast zx s_5629_0 -> bv
        let s_5629_1: Bits = Bits::new(s_5629_0 as u128, 4u16);
        // C s_5629_2: const #15u : u8
        let s_5629_2: u8 = 15;
        // C s_5629_3: cast zx s_5629_2 -> bv
        let s_5629_3: Bits = Bits::new(s_5629_2 as u128, 4u16);
        // D s_5629_4: cmp-eq s_5629_1 s_5629_3
        let s_5629_4: bool = ((s_5629_1) == (s_5629_3));
        // D s_5629_5: write-var gs#117581 <= s_5629_4
        fn_state.gs_117581 = s_5629_4;
        // N s_5629_6: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_5630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5630_0: read-var CRn:u8
        let s_5630_0: u8 = fn_state.CRn;
        // D s_5630_1: cast zx s_5630_0 -> bv
        let s_5630_1: Bits = Bits::new(s_5630_0 as u128, 4u16);
        // C s_5630_2: const #1u : u8
        let s_5630_2: u8 = 1;
        // C s_5630_3: cast zx s_5630_2 -> bv
        let s_5630_3: Bits = Bits::new(s_5630_2 as u128, 4u16);
        // D s_5630_4: cmp-eq s_5630_1 s_5630_3
        let s_5630_4: bool = ((s_5630_1) == (s_5630_3));
        // D s_5630_5: write-var gs#117580 <= s_5630_4
        fn_state.gs_117580 = s_5630_4;
        // N s_5630_6: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_5631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5631_0: read-var el:u8
        let s_5631_0: u8 = fn_state.el;
        // D s_5631_1: read-var coproc:u8
        let s_5631_1: u8 = fn_state.coproc;
        // D s_5631_2: read-var opc1:u8
        let s_5631_2: u8 = fn_state.opc1;
        // D s_5631_3: read-var CRn:u8
        let s_5631_3: u8 = fn_state.CRn;
        // D s_5631_4: read-var opc2:u8
        let s_5631_4: u8 = fn_state.opc2;
        // D s_5631_5: read-var CRm:u8
        let s_5631_5: u8 = fn_state.CRm;
        // D s_5631_6: read-var t:i
        let s_5631_6: i128 = fn_state.t;
        // D s_5631_7: call PMXEVCNTR_SysRegRead32_3357c1d37107c40d(s_5631_0, s_5631_1, s_5631_2, s_5631_3, s_5631_4, s_5631_5, s_5631_6)
        let s_5631_7: () = PMXEVCNTR_SysRegRead32_3357c1d37107c40d(
            state,
            tracer,
            s_5631_0,
            s_5631_1,
            s_5631_2,
            s_5631_3,
            s_5631_4,
            s_5631_5,
            s_5631_6,
        );
        // N s_5631_8: return
        return;
    }
    fn block_5632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5632_0: read-var opc2:u8
        let s_5632_0: u8 = fn_state.opc2;
        // D s_5632_1: cast zx s_5632_0 -> bv
        let s_5632_1: Bits = Bits::new(s_5632_0 as u128, 3u16);
        // C s_5632_2: const #2u : u8
        let s_5632_2: u8 = 2;
        // C s_5632_3: cast zx s_5632_2 -> bv
        let s_5632_3: Bits = Bits::new(s_5632_2 as u128, 3u16);
        // D s_5632_4: cmp-eq s_5632_1 s_5632_3
        let s_5632_4: bool = ((s_5632_1) == (s_5632_3));
        // D s_5632_5: write-var gs#117579 <= s_5632_4
        fn_state.gs_117579 = s_5632_4;
        // N s_5632_6: jump b71
        return block_71(state, tracer, fn_state);
    }
    fn block_5633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5633_0: read-var opc1:u8
        let s_5633_0: u8 = fn_state.opc1;
        // D s_5633_1: cast zx s_5633_0 -> bv
        let s_5633_1: Bits = Bits::new(s_5633_0 as u128, 3u16);
        // C s_5633_2: const #0u : u8
        let s_5633_2: u8 = 0;
        // C s_5633_3: cast zx s_5633_2 -> bv
        let s_5633_3: Bits = Bits::new(s_5633_2 as u128, 3u16);
        // D s_5633_4: cmp-eq s_5633_1 s_5633_3
        let s_5633_4: bool = ((s_5633_1) == (s_5633_3));
        // D s_5633_5: write-var gs#117578 <= s_5633_4
        fn_state.gs_117578 = s_5633_4;
        // N s_5633_6: jump b69
        return block_69(state, tracer, fn_state);
    }
    fn block_5634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5634_0: read-var coproc:u8
        let s_5634_0: u8 = fn_state.coproc;
        // D s_5634_1: cast zx s_5634_0 -> bv
        let s_5634_1: Bits = Bits::new(s_5634_0 as u128, 4u16);
        // C s_5634_2: const #15u : u8
        let s_5634_2: u8 = 15;
        // C s_5634_3: cast zx s_5634_2 -> bv
        let s_5634_3: Bits = Bits::new(s_5634_2 as u128, 4u16);
        // D s_5634_4: cmp-eq s_5634_1 s_5634_3
        let s_5634_4: bool = ((s_5634_1) == (s_5634_3));
        // D s_5634_5: write-var gs#117577 <= s_5634_4
        fn_state.gs_117577 = s_5634_4;
        // N s_5634_6: jump b67
        return block_67(state, tracer, fn_state);
    }
    fn block_5635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5635_0: read-var CRn:u8
        let s_5635_0: u8 = fn_state.CRn;
        // D s_5635_1: cast zx s_5635_0 -> bv
        let s_5635_1: Bits = Bits::new(s_5635_0 as u128, 4u16);
        // C s_5635_2: const #9u : u8
        let s_5635_2: u8 = 9;
        // C s_5635_3: cast zx s_5635_2 -> bv
        let s_5635_3: Bits = Bits::new(s_5635_2 as u128, 4u16);
        // D s_5635_4: cmp-eq s_5635_1 s_5635_3
        let s_5635_4: bool = ((s_5635_1) == (s_5635_3));
        // D s_5635_5: write-var gs#117576 <= s_5635_4
        fn_state.gs_117576 = s_5635_4;
        // N s_5635_6: jump b65
        return block_65(state, tracer, fn_state);
    }
    fn block_5636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5636_0: read-var el:u8
        let s_5636_0: u8 = fn_state.el;
        // D s_5636_1: read-var coproc:u8
        let s_5636_1: u8 = fn_state.coproc;
        // D s_5636_2: read-var opc1:u8
        let s_5636_2: u8 = fn_state.opc1;
        // D s_5636_3: read-var CRn:u8
        let s_5636_3: u8 = fn_state.CRn;
        // D s_5636_4: read-var opc2:u8
        let s_5636_4: u8 = fn_state.opc2;
        // D s_5636_5: read-var CRm:u8
        let s_5636_5: u8 = fn_state.CRm;
        // D s_5636_6: read-var t:i
        let s_5636_6: i128 = fn_state.t;
        // D s_5636_7: call TTBCR_SysRegRead32_254407681da2385f(s_5636_0, s_5636_1, s_5636_2, s_5636_3, s_5636_4, s_5636_5, s_5636_6)
        let s_5636_7: () = TTBCR_SysRegRead32_254407681da2385f(
            state,
            tracer,
            s_5636_0,
            s_5636_1,
            s_5636_2,
            s_5636_3,
            s_5636_4,
            s_5636_5,
            s_5636_6,
        );
        // N s_5636_8: return
        return;
    }
    fn block_5637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5637_0: read-var opc2:u8
        let s_5637_0: u8 = fn_state.opc2;
        // D s_5637_1: cast zx s_5637_0 -> bv
        let s_5637_1: Bits = Bits::new(s_5637_0 as u128, 3u16);
        // C s_5637_2: const #2u : u8
        let s_5637_2: u8 = 2;
        // C s_5637_3: cast zx s_5637_2 -> bv
        let s_5637_3: Bits = Bits::new(s_5637_2 as u128, 3u16);
        // D s_5637_4: cmp-eq s_5637_1 s_5637_3
        let s_5637_4: bool = ((s_5637_1) == (s_5637_3));
        // D s_5637_5: write-var gs#117575 <= s_5637_4
        fn_state.gs_117575 = s_5637_4;
        // N s_5637_6: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_5638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5638_0: read-var opc1:u8
        let s_5638_0: u8 = fn_state.opc1;
        // D s_5638_1: cast zx s_5638_0 -> bv
        let s_5638_1: Bits = Bits::new(s_5638_0 as u128, 3u16);
        // C s_5638_2: const #0u : u8
        let s_5638_2: u8 = 0;
        // C s_5638_3: cast zx s_5638_2 -> bv
        let s_5638_3: Bits = Bits::new(s_5638_2 as u128, 3u16);
        // D s_5638_4: cmp-eq s_5638_1 s_5638_3
        let s_5638_4: bool = ((s_5638_1) == (s_5638_3));
        // D s_5638_5: write-var gs#117574 <= s_5638_4
        fn_state.gs_117574 = s_5638_4;
        // N s_5638_6: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_5639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5639_0: read-var coproc:u8
        let s_5639_0: u8 = fn_state.coproc;
        // D s_5639_1: cast zx s_5639_0 -> bv
        let s_5639_1: Bits = Bits::new(s_5639_0 as u128, 4u16);
        // C s_5639_2: const #15u : u8
        let s_5639_2: u8 = 15;
        // C s_5639_3: cast zx s_5639_2 -> bv
        let s_5639_3: Bits = Bits::new(s_5639_2 as u128, 4u16);
        // D s_5639_4: cmp-eq s_5639_1 s_5639_3
        let s_5639_4: bool = ((s_5639_1) == (s_5639_3));
        // D s_5639_5: write-var gs#117573 <= s_5639_4
        fn_state.gs_117573 = s_5639_4;
        // N s_5639_6: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_5640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5640_0: read-var CRn:u8
        let s_5640_0: u8 = fn_state.CRn;
        // D s_5640_1: cast zx s_5640_0 -> bv
        let s_5640_1: Bits = Bits::new(s_5640_0 as u128, 4u16);
        // C s_5640_2: const #2u : u8
        let s_5640_2: u8 = 2;
        // C s_5640_3: cast zx s_5640_2 -> bv
        let s_5640_3: Bits = Bits::new(s_5640_2 as u128, 4u16);
        // D s_5640_4: cmp-eq s_5640_1 s_5640_3
        let s_5640_4: bool = ((s_5640_1) == (s_5640_3));
        // D s_5640_5: write-var gs#117572 <= s_5640_4
        fn_state.gs_117572 = s_5640_4;
        // N s_5640_6: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_5641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5641_0: read-var el:u8
        let s_5641_0: u8 = fn_state.el;
        // D s_5641_1: read-var coproc:u8
        let s_5641_1: u8 = fn_state.coproc;
        // D s_5641_2: read-var opc1:u8
        let s_5641_2: u8 = fn_state.opc1;
        // D s_5641_3: read-var CRn:u8
        let s_5641_3: u8 = fn_state.CRn;
        // D s_5641_4: read-var opc2:u8
        let s_5641_4: u8 = fn_state.opc2;
        // D s_5641_5: read-var CRm:u8
        let s_5641_5: u8 = fn_state.CRm;
        // D s_5641_6: read-var t:i
        let s_5641_6: i128 = fn_state.t;
        // D s_5641_7: call DBGDRAR_SysRegRead32_421a9884bf20a229(s_5641_0, s_5641_1, s_5641_2, s_5641_3, s_5641_4, s_5641_5, s_5641_6)
        let s_5641_7: () = DBGDRAR_SysRegRead32_421a9884bf20a229(
            state,
            tracer,
            s_5641_0,
            s_5641_1,
            s_5641_2,
            s_5641_3,
            s_5641_4,
            s_5641_5,
            s_5641_6,
        );
        // N s_5641_8: return
        return;
    }
    fn block_5642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5642_0: read-var opc2:u8
        let s_5642_0: u8 = fn_state.opc2;
        // D s_5642_1: cast zx s_5642_0 -> bv
        let s_5642_1: Bits = Bits::new(s_5642_0 as u128, 3u16);
        // C s_5642_2: const #0u : u8
        let s_5642_2: u8 = 0;
        // C s_5642_3: cast zx s_5642_2 -> bv
        let s_5642_3: Bits = Bits::new(s_5642_2 as u128, 3u16);
        // D s_5642_4: cmp-eq s_5642_1 s_5642_3
        let s_5642_4: bool = ((s_5642_1) == (s_5642_3));
        // D s_5642_5: write-var gs#117571 <= s_5642_4
        fn_state.gs_117571 = s_5642_4;
        // N s_5642_6: jump b53
        return block_53(state, tracer, fn_state);
    }
    fn block_5643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5643_0: read-var opc1:u8
        let s_5643_0: u8 = fn_state.opc1;
        // D s_5643_1: cast zx s_5643_0 -> bv
        let s_5643_1: Bits = Bits::new(s_5643_0 as u128, 3u16);
        // C s_5643_2: const #0u : u8
        let s_5643_2: u8 = 0;
        // C s_5643_3: cast zx s_5643_2 -> bv
        let s_5643_3: Bits = Bits::new(s_5643_2 as u128, 3u16);
        // D s_5643_4: cmp-eq s_5643_1 s_5643_3
        let s_5643_4: bool = ((s_5643_1) == (s_5643_3));
        // D s_5643_5: write-var gs#117570 <= s_5643_4
        fn_state.gs_117570 = s_5643_4;
        // N s_5643_6: jump b51
        return block_51(state, tracer, fn_state);
    }
    fn block_5644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5644_0: read-var coproc:u8
        let s_5644_0: u8 = fn_state.coproc;
        // D s_5644_1: cast zx s_5644_0 -> bv
        let s_5644_1: Bits = Bits::new(s_5644_0 as u128, 4u16);
        // C s_5644_2: const #14u : u8
        let s_5644_2: u8 = 14;
        // C s_5644_3: cast zx s_5644_2 -> bv
        let s_5644_3: Bits = Bits::new(s_5644_2 as u128, 4u16);
        // D s_5644_4: cmp-eq s_5644_1 s_5644_3
        let s_5644_4: bool = ((s_5644_1) == (s_5644_3));
        // D s_5644_5: write-var gs#117569 <= s_5644_4
        fn_state.gs_117569 = s_5644_4;
        // N s_5644_6: jump b49
        return block_49(state, tracer, fn_state);
    }
    fn block_5645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5645_0: read-var CRn:u8
        let s_5645_0: u8 = fn_state.CRn;
        // D s_5645_1: cast zx s_5645_0 -> bv
        let s_5645_1: Bits = Bits::new(s_5645_0 as u128, 4u16);
        // C s_5645_2: const #1u : u8
        let s_5645_2: u8 = 1;
        // C s_5645_3: cast zx s_5645_2 -> bv
        let s_5645_3: Bits = Bits::new(s_5645_2 as u128, 4u16);
        // D s_5645_4: cmp-eq s_5645_1 s_5645_3
        let s_5645_4: bool = ((s_5645_1) == (s_5645_3));
        // D s_5645_5: write-var gs#117568 <= s_5645_4
        fn_state.gs_117568 = s_5645_4;
        // N s_5645_6: jump b47
        return block_47(state, tracer, fn_state);
    }
    fn block_5646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5646_0: read-var el:u8
        let s_5646_0: u8 = fn_state.el;
        // D s_5646_1: read-var coproc:u8
        let s_5646_1: u8 = fn_state.coproc;
        // D s_5646_2: read-var opc1:u8
        let s_5646_2: u8 = fn_state.opc1;
        // D s_5646_3: read-var CRn:u8
        let s_5646_3: u8 = fn_state.CRn;
        // D s_5646_4: read-var opc2:u8
        let s_5646_4: u8 = fn_state.opc2;
        // D s_5646_5: read-var CRm:u8
        let s_5646_5: u8 = fn_state.CRm;
        // D s_5646_6: read-var t:i
        let s_5646_6: i128 = fn_state.t;
        // D s_5646_7: call TTBR0_SysRegRead32_ba6eb6544c3c44a1(s_5646_0, s_5646_1, s_5646_2, s_5646_3, s_5646_4, s_5646_5, s_5646_6)
        let s_5646_7: () = TTBR0_SysRegRead32_ba6eb6544c3c44a1(
            state,
            tracer,
            s_5646_0,
            s_5646_1,
            s_5646_2,
            s_5646_3,
            s_5646_4,
            s_5646_5,
            s_5646_6,
        );
        // N s_5646_8: return
        return;
    }
    fn block_5647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5647_0: read-var opc2:u8
        let s_5647_0: u8 = fn_state.opc2;
        // D s_5647_1: cast zx s_5647_0 -> bv
        let s_5647_1: Bits = Bits::new(s_5647_0 as u128, 3u16);
        // C s_5647_2: const #0u : u8
        let s_5647_2: u8 = 0;
        // C s_5647_3: cast zx s_5647_2 -> bv
        let s_5647_3: Bits = Bits::new(s_5647_2 as u128, 3u16);
        // D s_5647_4: cmp-eq s_5647_1 s_5647_3
        let s_5647_4: bool = ((s_5647_1) == (s_5647_3));
        // D s_5647_5: write-var gs#117567 <= s_5647_4
        fn_state.gs_117567 = s_5647_4;
        // N s_5647_6: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_5648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5648_0: read-var opc1:u8
        let s_5648_0: u8 = fn_state.opc1;
        // D s_5648_1: cast zx s_5648_0 -> bv
        let s_5648_1: Bits = Bits::new(s_5648_0 as u128, 3u16);
        // C s_5648_2: const #0u : u8
        let s_5648_2: u8 = 0;
        // C s_5648_3: cast zx s_5648_2 -> bv
        let s_5648_3: Bits = Bits::new(s_5648_2 as u128, 3u16);
        // D s_5648_4: cmp-eq s_5648_1 s_5648_3
        let s_5648_4: bool = ((s_5648_1) == (s_5648_3));
        // D s_5648_5: write-var gs#117566 <= s_5648_4
        fn_state.gs_117566 = s_5648_4;
        // N s_5648_6: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_5649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5649_0: read-var coproc:u8
        let s_5649_0: u8 = fn_state.coproc;
        // D s_5649_1: cast zx s_5649_0 -> bv
        let s_5649_1: Bits = Bits::new(s_5649_0 as u128, 4u16);
        // C s_5649_2: const #15u : u8
        let s_5649_2: u8 = 15;
        // C s_5649_3: cast zx s_5649_2 -> bv
        let s_5649_3: Bits = Bits::new(s_5649_2 as u128, 4u16);
        // D s_5649_4: cmp-eq s_5649_1 s_5649_3
        let s_5649_4: bool = ((s_5649_1) == (s_5649_3));
        // D s_5649_5: write-var gs#117565 <= s_5649_4
        fn_state.gs_117565 = s_5649_4;
        // N s_5649_6: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_5650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5650_0: read-var CRn:u8
        let s_5650_0: u8 = fn_state.CRn;
        // D s_5650_1: cast zx s_5650_0 -> bv
        let s_5650_1: Bits = Bits::new(s_5650_0 as u128, 4u16);
        // C s_5650_2: const #2u : u8
        let s_5650_2: u8 = 2;
        // C s_5650_3: cast zx s_5650_2 -> bv
        let s_5650_3: Bits = Bits::new(s_5650_2 as u128, 4u16);
        // D s_5650_4: cmp-eq s_5650_1 s_5650_3
        let s_5650_4: bool = ((s_5650_1) == (s_5650_3));
        // D s_5650_5: write-var gs#117564 <= s_5650_4
        fn_state.gs_117564 = s_5650_4;
        // N s_5650_6: jump b38
        return block_38(state, tracer, fn_state);
    }
    fn block_5651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5651_0: read-var el:u8
        let s_5651_0: u8 = fn_state.el;
        // D s_5651_1: read-var coproc:u8
        let s_5651_1: u8 = fn_state.coproc;
        // D s_5651_2: read-var opc1:u8
        let s_5651_2: u8 = fn_state.opc1;
        // D s_5651_3: read-var CRn:u8
        let s_5651_3: u8 = fn_state.CRn;
        // D s_5651_4: read-var opc2:u8
        let s_5651_4: u8 = fn_state.opc2;
        // D s_5651_5: read-var CRm:u8
        let s_5651_5: u8 = fn_state.CRm;
        // D s_5651_6: read-var t:i
        let s_5651_6: i128 = fn_state.t;
        // D s_5651_7: call TTBR1_SysRegRead32_bbb7c8fdac68a224(s_5651_0, s_5651_1, s_5651_2, s_5651_3, s_5651_4, s_5651_5, s_5651_6)
        let s_5651_7: () = TTBR1_SysRegRead32_bbb7c8fdac68a224(
            state,
            tracer,
            s_5651_0,
            s_5651_1,
            s_5651_2,
            s_5651_3,
            s_5651_4,
            s_5651_5,
            s_5651_6,
        );
        // N s_5651_8: return
        return;
    }
    fn block_5652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5652_0: read-var opc2:u8
        let s_5652_0: u8 = fn_state.opc2;
        // D s_5652_1: cast zx s_5652_0 -> bv
        let s_5652_1: Bits = Bits::new(s_5652_0 as u128, 3u16);
        // C s_5652_2: const #1u : u8
        let s_5652_2: u8 = 1;
        // C s_5652_3: cast zx s_5652_2 -> bv
        let s_5652_3: Bits = Bits::new(s_5652_2 as u128, 3u16);
        // D s_5652_4: cmp-eq s_5652_1 s_5652_3
        let s_5652_4: bool = ((s_5652_1) == (s_5652_3));
        // D s_5652_5: write-var gs#117563 <= s_5652_4
        fn_state.gs_117563 = s_5652_4;
        // N s_5652_6: jump b35
        return block_35(state, tracer, fn_state);
    }
    fn block_5653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5653_0: read-var opc1:u8
        let s_5653_0: u8 = fn_state.opc1;
        // D s_5653_1: cast zx s_5653_0 -> bv
        let s_5653_1: Bits = Bits::new(s_5653_0 as u128, 3u16);
        // C s_5653_2: const #0u : u8
        let s_5653_2: u8 = 0;
        // C s_5653_3: cast zx s_5653_2 -> bv
        let s_5653_3: Bits = Bits::new(s_5653_2 as u128, 3u16);
        // D s_5653_4: cmp-eq s_5653_1 s_5653_3
        let s_5653_4: bool = ((s_5653_1) == (s_5653_3));
        // D s_5653_5: write-var gs#117562 <= s_5653_4
        fn_state.gs_117562 = s_5653_4;
        // N s_5653_6: jump b33
        return block_33(state, tracer, fn_state);
    }
    fn block_5654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5654_0: read-var coproc:u8
        let s_5654_0: u8 = fn_state.coproc;
        // D s_5654_1: cast zx s_5654_0 -> bv
        let s_5654_1: Bits = Bits::new(s_5654_0 as u128, 4u16);
        // C s_5654_2: const #15u : u8
        let s_5654_2: u8 = 15;
        // C s_5654_3: cast zx s_5654_2 -> bv
        let s_5654_3: Bits = Bits::new(s_5654_2 as u128, 4u16);
        // D s_5654_4: cmp-eq s_5654_1 s_5654_3
        let s_5654_4: bool = ((s_5654_1) == (s_5654_3));
        // D s_5654_5: write-var gs#117561 <= s_5654_4
        fn_state.gs_117561 = s_5654_4;
        // N s_5654_6: jump b31
        return block_31(state, tracer, fn_state);
    }
    fn block_5655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5655_0: read-var CRn:u8
        let s_5655_0: u8 = fn_state.CRn;
        // D s_5655_1: cast zx s_5655_0 -> bv
        let s_5655_1: Bits = Bits::new(s_5655_0 as u128, 4u16);
        // C s_5655_2: const #2u : u8
        let s_5655_2: u8 = 2;
        // C s_5655_3: cast zx s_5655_2 -> bv
        let s_5655_3: Bits = Bits::new(s_5655_2 as u128, 4u16);
        // D s_5655_4: cmp-eq s_5655_1 s_5655_3
        let s_5655_4: bool = ((s_5655_1) == (s_5655_3));
        // D s_5655_5: write-var gs#117560 <= s_5655_4
        fn_state.gs_117560 = s_5655_4;
        // N s_5655_6: jump b29
        return block_29(state, tracer, fn_state);
    }
    fn block_5656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5656_0: read-var el:u8
        let s_5656_0: u8 = fn_state.el;
        // D s_5656_1: read-var coproc:u8
        let s_5656_1: u8 = fn_state.coproc;
        // D s_5656_2: read-var opc1:u8
        let s_5656_2: u8 = fn_state.opc1;
        // D s_5656_3: read-var CRn:u8
        let s_5656_3: u8 = fn_state.CRn;
        // D s_5656_4: read-var opc2:u8
        let s_5656_4: u8 = fn_state.opc2;
        // D s_5656_5: read-var CRm:u8
        let s_5656_5: u8 = fn_state.CRm;
        // D s_5656_6: read-var t:i
        let s_5656_6: i128 = fn_state.t;
        // D s_5656_7: call PMCCNTR_SysRegRead32_5914763424cd4baf(s_5656_0, s_5656_1, s_5656_2, s_5656_3, s_5656_4, s_5656_5, s_5656_6)
        let s_5656_7: () = PMCCNTR_SysRegRead32_5914763424cd4baf(
            state,
            tracer,
            s_5656_0,
            s_5656_1,
            s_5656_2,
            s_5656_3,
            s_5656_4,
            s_5656_5,
            s_5656_6,
        );
        // N s_5656_8: return
        return;
    }
    fn block_5657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5657_0: read-var opc2:u8
        let s_5657_0: u8 = fn_state.opc2;
        // D s_5657_1: cast zx s_5657_0 -> bv
        let s_5657_1: Bits = Bits::new(s_5657_0 as u128, 3u16);
        // C s_5657_2: const #0u : u8
        let s_5657_2: u8 = 0;
        // C s_5657_3: cast zx s_5657_2 -> bv
        let s_5657_3: Bits = Bits::new(s_5657_2 as u128, 3u16);
        // D s_5657_4: cmp-eq s_5657_1 s_5657_3
        let s_5657_4: bool = ((s_5657_1) == (s_5657_3));
        // D s_5657_5: write-var gs#117559 <= s_5657_4
        fn_state.gs_117559 = s_5657_4;
        // N s_5657_6: jump b26
        return block_26(state, tracer, fn_state);
    }
    fn block_5658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5658_0: read-var opc1:u8
        let s_5658_0: u8 = fn_state.opc1;
        // D s_5658_1: cast zx s_5658_0 -> bv
        let s_5658_1: Bits = Bits::new(s_5658_0 as u128, 3u16);
        // C s_5658_2: const #0u : u8
        let s_5658_2: u8 = 0;
        // C s_5658_3: cast zx s_5658_2 -> bv
        let s_5658_3: Bits = Bits::new(s_5658_2 as u128, 3u16);
        // D s_5658_4: cmp-eq s_5658_1 s_5658_3
        let s_5658_4: bool = ((s_5658_1) == (s_5658_3));
        // D s_5658_5: write-var gs#117558 <= s_5658_4
        fn_state.gs_117558 = s_5658_4;
        // N s_5658_6: jump b24
        return block_24(state, tracer, fn_state);
    }
    fn block_5659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5659_0: read-var coproc:u8
        let s_5659_0: u8 = fn_state.coproc;
        // D s_5659_1: cast zx s_5659_0 -> bv
        let s_5659_1: Bits = Bits::new(s_5659_0 as u128, 4u16);
        // C s_5659_2: const #15u : u8
        let s_5659_2: u8 = 15;
        // C s_5659_3: cast zx s_5659_2 -> bv
        let s_5659_3: Bits = Bits::new(s_5659_2 as u128, 4u16);
        // D s_5659_4: cmp-eq s_5659_1 s_5659_3
        let s_5659_4: bool = ((s_5659_1) == (s_5659_3));
        // D s_5659_5: write-var gs#117557 <= s_5659_4
        fn_state.gs_117557 = s_5659_4;
        // N s_5659_6: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_5660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5660_0: read-var CRn:u8
        let s_5660_0: u8 = fn_state.CRn;
        // D s_5660_1: cast zx s_5660_0 -> bv
        let s_5660_1: Bits = Bits::new(s_5660_0 as u128, 4u16);
        // C s_5660_2: const #9u : u8
        let s_5660_2: u8 = 9;
        // C s_5660_3: cast zx s_5660_2 -> bv
        let s_5660_3: Bits = Bits::new(s_5660_2 as u128, 4u16);
        // D s_5660_4: cmp-eq s_5660_1 s_5660_3
        let s_5660_4: bool = ((s_5660_1) == (s_5660_3));
        // D s_5660_5: write-var gs#117556 <= s_5660_4
        fn_state.gs_117556 = s_5660_4;
        // N s_5660_6: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_5661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5661_0: read-var el:u8
        let s_5661_0: u8 = fn_state.el;
        // D s_5661_1: read-var coproc:u8
        let s_5661_1: u8 = fn_state.coproc;
        // D s_5661_2: read-var opc1:u8
        let s_5661_2: u8 = fn_state.opc1;
        // D s_5661_3: read-var CRn:u8
        let s_5661_3: u8 = fn_state.CRn;
        // D s_5661_4: read-var opc2:u8
        let s_5661_4: u8 = fn_state.opc2;
        // D s_5661_5: read-var CRm:u8
        let s_5661_5: u8 = fn_state.CRm;
        // D s_5661_6: read-var t:i
        let s_5661_6: i128 = fn_state.t;
        // D s_5661_7: call PAR_SysRegRead32_6e09f827d9ae2cf7(s_5661_0, s_5661_1, s_5661_2, s_5661_3, s_5661_4, s_5661_5, s_5661_6)
        let s_5661_7: () = PAR_SysRegRead32_6e09f827d9ae2cf7(
            state,
            tracer,
            s_5661_0,
            s_5661_1,
            s_5661_2,
            s_5661_3,
            s_5661_4,
            s_5661_5,
            s_5661_6,
        );
        // N s_5661_8: return
        return;
    }
    fn block_5662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5662_0: read-var opc2:u8
        let s_5662_0: u8 = fn_state.opc2;
        // D s_5662_1: cast zx s_5662_0 -> bv
        let s_5662_1: Bits = Bits::new(s_5662_0 as u128, 3u16);
        // C s_5662_2: const #0u : u8
        let s_5662_2: u8 = 0;
        // C s_5662_3: cast zx s_5662_2 -> bv
        let s_5662_3: Bits = Bits::new(s_5662_2 as u128, 3u16);
        // D s_5662_4: cmp-eq s_5662_1 s_5662_3
        let s_5662_4: bool = ((s_5662_1) == (s_5662_3));
        // D s_5662_5: write-var gs#117555 <= s_5662_4
        fn_state.gs_117555 = s_5662_4;
        // N s_5662_6: jump b17
        return block_17(state, tracer, fn_state);
    }
    fn block_5663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5663_0: read-var opc1:u8
        let s_5663_0: u8 = fn_state.opc1;
        // D s_5663_1: cast zx s_5663_0 -> bv
        let s_5663_1: Bits = Bits::new(s_5663_0 as u128, 3u16);
        // C s_5663_2: const #0u : u8
        let s_5663_2: u8 = 0;
        // C s_5663_3: cast zx s_5663_2 -> bv
        let s_5663_3: Bits = Bits::new(s_5663_2 as u128, 3u16);
        // D s_5663_4: cmp-eq s_5663_1 s_5663_3
        let s_5663_4: bool = ((s_5663_1) == (s_5663_3));
        // D s_5663_5: write-var gs#117554 <= s_5663_4
        fn_state.gs_117554 = s_5663_4;
        // N s_5663_6: jump b15
        return block_15(state, tracer, fn_state);
    }
    fn block_5664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5664_0: read-var coproc:u8
        let s_5664_0: u8 = fn_state.coproc;
        // D s_5664_1: cast zx s_5664_0 -> bv
        let s_5664_1: Bits = Bits::new(s_5664_0 as u128, 4u16);
        // C s_5664_2: const #15u : u8
        let s_5664_2: u8 = 15;
        // C s_5664_3: cast zx s_5664_2 -> bv
        let s_5664_3: Bits = Bits::new(s_5664_2 as u128, 4u16);
        // D s_5664_4: cmp-eq s_5664_1 s_5664_3
        let s_5664_4: bool = ((s_5664_1) == (s_5664_3));
        // D s_5664_5: write-var gs#117553 <= s_5664_4
        fn_state.gs_117553 = s_5664_4;
        // N s_5664_6: jump b13
        return block_13(state, tracer, fn_state);
    }
    fn block_5665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5665_0: read-var CRn:u8
        let s_5665_0: u8 = fn_state.CRn;
        // D s_5665_1: cast zx s_5665_0 -> bv
        let s_5665_1: Bits = Bits::new(s_5665_0 as u128, 4u16);
        // C s_5665_2: const #7u : u8
        let s_5665_2: u8 = 7;
        // C s_5665_3: cast zx s_5665_2 -> bv
        let s_5665_3: Bits = Bits::new(s_5665_2 as u128, 4u16);
        // D s_5665_4: cmp-eq s_5665_1 s_5665_3
        let s_5665_4: bool = ((s_5665_1) == (s_5665_3));
        // D s_5665_5: write-var gs#117552 <= s_5665_4
        fn_state.gs_117552 = s_5665_4;
        // N s_5665_6: jump b11
        return block_11(state, tracer, fn_state);
    }
    fn block_5666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5666_0: read-var el:u8
        let s_5666_0: u8 = fn_state.el;
        // D s_5666_1: read-var coproc:u8
        let s_5666_1: u8 = fn_state.coproc;
        // D s_5666_2: read-var opc1:u8
        let s_5666_2: u8 = fn_state.opc1;
        // D s_5666_3: read-var CRn:u8
        let s_5666_3: u8 = fn_state.CRn;
        // D s_5666_4: read-var opc2:u8
        let s_5666_4: u8 = fn_state.opc2;
        // D s_5666_5: read-var CRm:u8
        let s_5666_5: u8 = fn_state.CRm;
        // D s_5666_6: read-var t:i
        let s_5666_6: i128 = fn_state.t;
        // D s_5666_7: call DBGDSAR_SysRegRead32_94ff484a75802dcb(s_5666_0, s_5666_1, s_5666_2, s_5666_3, s_5666_4, s_5666_5, s_5666_6)
        let s_5666_7: () = DBGDSAR_SysRegRead32_94ff484a75802dcb(
            state,
            tracer,
            s_5666_0,
            s_5666_1,
            s_5666_2,
            s_5666_3,
            s_5666_4,
            s_5666_5,
            s_5666_6,
        );
        // N s_5666_8: return
        return;
    }
    fn block_5667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5667_0: read-var opc2:u8
        let s_5667_0: u8 = fn_state.opc2;
        // D s_5667_1: cast zx s_5667_0 -> bv
        let s_5667_1: Bits = Bits::new(s_5667_0 as u128, 3u16);
        // C s_5667_2: const #0u : u8
        let s_5667_2: u8 = 0;
        // C s_5667_3: cast zx s_5667_2 -> bv
        let s_5667_3: Bits = Bits::new(s_5667_2 as u128, 3u16);
        // D s_5667_4: cmp-eq s_5667_1 s_5667_3
        let s_5667_4: bool = ((s_5667_1) == (s_5667_3));
        // D s_5667_5: write-var gs#117551 <= s_5667_4
        fn_state.gs_117551 = s_5667_4;
        // N s_5667_6: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_5668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5668_0: read-var opc1:u8
        let s_5668_0: u8 = fn_state.opc1;
        // D s_5668_1: cast zx s_5668_0 -> bv
        let s_5668_1: Bits = Bits::new(s_5668_0 as u128, 3u16);
        // C s_5668_2: const #0u : u8
        let s_5668_2: u8 = 0;
        // C s_5668_3: cast zx s_5668_2 -> bv
        let s_5668_3: Bits = Bits::new(s_5668_2 as u128, 3u16);
        // D s_5668_4: cmp-eq s_5668_1 s_5668_3
        let s_5668_4: bool = ((s_5668_1) == (s_5668_3));
        // D s_5668_5: write-var gs#117550 <= s_5668_4
        fn_state.gs_117550 = s_5668_4;
        // N s_5668_6: jump b6
        return block_6(state, tracer, fn_state);
    }
    fn block_5669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5669_0: read-var coproc:u8
        let s_5669_0: u8 = fn_state.coproc;
        // D s_5669_1: cast zx s_5669_0 -> bv
        let s_5669_1: Bits = Bits::new(s_5669_0 as u128, 4u16);
        // C s_5669_2: const #14u : u8
        let s_5669_2: u8 = 14;
        // C s_5669_3: cast zx s_5669_2 -> bv
        let s_5669_3: Bits = Bits::new(s_5669_2 as u128, 4u16);
        // D s_5669_4: cmp-eq s_5669_1 s_5669_3
        let s_5669_4: bool = ((s_5669_1) == (s_5669_3));
        // D s_5669_5: write-var gs#117549 <= s_5669_4
        fn_state.gs_117549 = s_5669_4;
        // N s_5669_6: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_5670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_5670_0: read-var CRn:u8
        let s_5670_0: u8 = fn_state.CRn;
        // D s_5670_1: cast zx s_5670_0 -> bv
        let s_5670_1: Bits = Bits::new(s_5670_0 as u128, 4u16);
        // C s_5670_2: const #2u : u8
        let s_5670_2: u8 = 2;
        // C s_5670_3: cast zx s_5670_2 -> bv
        let s_5670_3: Bits = Bits::new(s_5670_2 as u128, 4u16);
        // D s_5670_4: cmp-eq s_5670_1 s_5670_3
        let s_5670_4: bool = ((s_5670_1) == (s_5670_3));
        // D s_5670_5: write-var gs#117548 <= s_5670_4
        fn_state.gs_117548 = s_5670_4;
        // N s_5670_6: jump b2
        return block_2(state, tracer, fn_state);
    }
}
