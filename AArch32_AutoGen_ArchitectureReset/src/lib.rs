#![no_std]
#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_doc_comments)]
#![allow(non_upper_case_globals)]
//! BOREALIS GENERATED FILE
extern crate alloc;
use u_update_ICC_HSRE_Type_DIB::*;
use ICH_HCR_read::*;
use DBGOSDLR_write::*;
use u_update_TTBCR_Type_EPD0::*;
use u_update_ICH_EISR_Type_Status15::*;
use DBGAUTHSTATUS_write::*;
use ICC_CTLR_read::*;
use ISR_write::*;
use ICV_HPPIR0_write::*;
use Mk_PMSWINC_Type::*;
use AMCNTENSET0_read::*;
use PAR_write::*;
use Mk_AMCNTENCLR0_Type::*;
use u_update_ICH_HCR_Type_TSEI::*;
use u_update_HCR_Type_TAC::*;
use ICC_SRE_read::*;
use EDSCR_read::*;
use ICV_EOIR1_write::*;
use ICC_PMR_write::*;
use Mk_ICV_EOIR1_Type::*;
use u_update_ICH_EISR_Type_Status2::*;
use Mk_ICH_VTR_Type::*;
use u_update_TTBCR_Type_PD1::*;
use HTRFCR_write::*;
use VDFSR_read::*;
use u_update_SCTLR_Type_I::*;
use TTBR0_write::*;
use u_update_HDCR_Type_TDRA::*;
use CNTHVS_CTL_read::*;
use u_update_ICH_MISR_Type_U::*;
use PMUSERENR_write::*;
use u_update_ICH_EISR_Type_Status4::*;
use u__IMPDEF_boolean::*;
use ISR_read::*;
use PMINTEN_write::*;
use CNTV_CTL_read::*;
use ICH_HCR_write::*;
use u_update_HCR_Type_TPU::*;
use u_update_HSCTLR_Type_nTLSMD::*;
use RMR_read::*;
use u_update_PMCCFILTR_Type_U::*;
use Mk_PMCCFILTR_Type::*;
use u_update_HCR_Type_TWE::*;
use Mk_ID_DFR1_Type::*;
use Mk_CNTHV_CTL_Type::*;
use Mk_DBGDCCINT_Type::*;
use ICV_IGRPEN0_write::*;
use u_update_SCTLR_Type_UWXN::*;
use u_update_ICH_HCR_Type_TDIR::*;
use HRMR_read::*;
use EDECCR_read::*;
use PAR_read::*;
use HSCTLR_write::*;
use ICC_EOIR1_write::*;
use u_update_ICH_HCR_Type_NPIE::*;
use CPACR_write::*;
use HCPTR_write::*;
use ID_AFR0_read::*;
use AMCFGR_write::*;
use u_update_EDECCR_Type_SE3::*;
use u_update_EDSCR_Type_RXfull::*;
use CTR_read::*;
use u_update_SCTLR_Type_nTLSMD::*;
use HTCR_read::*;
use ICV_IGRPEN0_read::*;
use Mk_CCSIDR2_Type::*;
use Mk_DBGDRAR_Type::*;
use u_update_HDCR_Type_HCCD::*;
use u_update_HCR_Type_AMO::*;
use IFSR_read::*;
use u_update_EDSCR_Type_INTdis::*;
use u_update_HCR_Type_HCD::*;
use u_update_PMCR_Type_D::*;
use u_update_HSTR_Type_T0::*;
use DBGCLAIMSET_read::*;
use u_update_HTRFCR_Type_E0HTRE::*;
use u_update_SCTLR_Type_AFE::*;
use DBGPRCR_write::*;
use TTBR1_read::*;
use VBAR_read__2::*;
use Mk_ICV_BPR0_Type::*;
use CNTHP_CTL_write::*;
use PMCR_read::*;
use CCSIDR_read::*;
use VDFSR_write::*;
use DBGOSLSR_write::*;
use Mk_AMUSERENR_Type::*;
use CCSIDR2_write::*;
use VDISR_write::*;
use ICV_DIR_read::*;
use u_update_HCR_Type_TID0::*;
use Mk_ERRIDR_Type::*;
use u_update_HCR_Type_TWI::*;
use u_update_HCPTR_Type_TCP11::*;
use u_update_PMCR_Type_X::*;
use AMCR_write::*;
use Mk_TTBCR2_Type::*;
use VTCR_read::*;
use DFSR_read::*;
use u_update_HCR_Type_SWIO::*;
use AMCNTENSET1_write::*;
use Mk_PMUSERENR_Type::*;
use Mk_ICH_EISR_Type::*;
use Mk_CPACR_Type::*;
use Mk_CNTHCTL_Type::*;
use Mk_ICC_EOIR1_Type::*;
use u_update_HSTR_Type_T15::*;
use u_update_EDSCR_Type_SC2::*;
use u_update_ICH_HCR_Type_VGrp0DIE::*;
use u_update_EDSCR_Type_HDE::*;
use HCR2_read::*;
use CPACR_read__1::*;
use u_update_ICH_EISR_Type_Status12::*;
use DBGDCCINT_write::*;
use u_update_ICV_IGRPEN1_Type_Enable::*;
use u_update_ICV_PMR_Type_Priority::*;
use Mk_ICC_HSRE_Type::*;
use PMOVS_read::*;
use u_update_HCR_Type_TIDCP::*;
use u_update_ICH_MISR_Type_NP::*;
use u_update_HSTR_Type_T8::*;
use u_update_HDCR_Type_TDCC::*;
use ICC_BPR0_write::*;
use ICC_IAR1_write::*;
use ICV_RPR_write::*;
use ID_DFR1_write::*;
use ICV_IAR0_read::*;
use Mk_VDFSR_Type::*;
use ICC_IGRPEN1_write::*;
use ICC_HSRE_read::*;
use u_update_ICH_HCR_Type_LRENPIE::*;
use Mk_DISR_Type::*;
use u_update_HSTR_Type_T13::*;
use ERRSELR_write::*;
use ICC_IAR0_read::*;
use u_update_HSTR_Type_T9::*;
use SCTLR_read__2::*;
use u_update_ICH_EISR_Type_Status9::*;
use Mk_PAR_Type::*;
use u_update_ICH_EISR_Type_Status6::*;
use PMOVS_write::*;
use HVBAR_read::*;
use u_update_HSTR_Type_T11::*;
use VTCR_write::*;
use u_update_ICH_MISR_Type_VGrp1E::*;
use u_update_HCR_Type_DC::*;
use u_update_FPEXC_Type_EN::*;
use ID_PFR2_write::*;
use DISR_read::*;
use ICC_ASGI1R_read::*;
use AMCNTENCLR0_read::*;
use u_update_EDECCR_Type_NSR1::*;
use u_update_SCTLR_Type_CP15BEN::*;
use Mk_PMCR_Type::*;
use Mk_ICC_BPR0_Type::*;
use ID_ISAR5_read::*;
use u_update_ICH_EISR_Type_Status1::*;
use Mk_AMCFGR_Type::*;
use Mk_AMCNTENCLR1_Type::*;
use u_update_EDECCR_Type_SR0::*;
use ICH_VTR_read::*;
use EDECCR_write::*;
use Mk_PMOVS_Type::*;
use Mk_DBGOSDLR_Type::*;
use ICV_EOIR0_read::*;
use Mk_VMPIDR_Type::*;
use u_update_ICH_HCR_Type_TALL0::*;
use ICC_EOIR1_read::*;
use u_update_HCR_Type_TID3::*;
use u_update_VMPIDR_Type_Aff0::*;
use DBGCLAIMSET_write::*;
use u_update_ICH_HCR_Type_TC::*;
use u_update_HSCTLR_Type_C::*;
use Mk_DBGDSCRext_Type::*;
use DBGDSCRext_write::*;
use DSPSR2_read::*;
use Mk_ICC_SGI0R_Type::*;
use u_update_VMPIDR_Type_MT::*;
use u_update_HCPTR_Type_TTA::*;
use u_update_PMCR_Type_E::*;
use u_update_ICH_HCR_Type_En::*;
use u_update_HSTR_Type_T6::*;
use HRMR_write::*;
use ICV_EOIR1_read::*;
use Mk_ICV_IGRPEN0_Type::*;
use ICC_IGRPEN0_write::*;
use u_update_HCR_Type_IMO::*;
use TTBR1_write::*;
use u_update_VMPIDR_Type_U::*;
use HSTR_read::*;
use u_update_EDECCR_Type_RLE1::*;
use Mk_DBGCLAIMCLR_Type::*;
use u_update_PMCR_Type_LP::*;
use u_update_EDSCR_Type_TXfull::*;
use u_update_SCTLR_Type_LSMAOE::*;
use TRFCR_read::*;
use u_update_ICH_MISR_Type_VGrp0D::*;
use PMSELR_read::*;
use u_update_HCR_Type_TGE::*;
use Mk_PRRR_Type::*;
use ICH_MISR_write::*;
use u_update_ICH_EISR_Type_Status14::*;
use u_update_SCTLR_Type_ITD::*;
use u_update_HCR_Type_TTLB::*;
use CNTP_CTL_read::*;
use Mk_ICV_PMR_Type::*;
use DISR_write::*;
use AMCNTENCLR1_read::*;
use u_update_VMPIDR_Type_Aff2::*;
use u_update_EDECCR_Type_SE1::*;
use u_update_TTBCR_Type_N::*;
use Mk_ICC_IAR1_Type::*;
use DBGOSLSR_read::*;
use u_update_ICC_IGRPEN0_Type_Enable::*;
use ICH_ELRSR_write::*;
use PMUSERENR_read::*;
use ICC_RPR_write::*;
use HDCR_read::*;
use u_update_VPIDR_Type_Implementer::*;
use u_update_CPACR_Type_ASEDIS::*;
use Mk_AMCNTENSET0_Type::*;
use MVFR2_read::*;
use u_update_EDECCR_Type_NSR2::*;
use ICC_BPR1_write::*;
use u_update_HCR_Type_BSU::*;
use u_update_SCTLR_Type_WXN::*;
use DBGVCR_write::*;
use Mk_ICC_HPPIR1_Type::*;
use u_update_HRMR_Type_RR::*;
use Mk_ID_MMFR5_Type::*;
use u_update_ICH_EISR_Type_Status13::*;
use AMCGCR_write::*;
use ICV_IAR1_write::*;
use u_update_HTRFCR_Type_TS::*;
use ICC_SGI1R_read::*;
use DBGCLAIMCLR_write::*;
use AMCNTENSET1_read::*;
use ICC_EOIR0_write::*;
use ICV_PMR_write::*;
use u_update_HDCR_Type_MTPME::*;
use HDCR_write::*;
use u_update_EDECCR_Type_SR2::*;
use HCPTR_read::*;
use ICV_CTLR_read::*;
use SDER_write::*;
use CNTHV_CTL_read::*;
use u_update_ICC_SRE_Type_DFB::*;
use u_update_HCR2_Type_TOCU::*;
use Mk_HPFAR_Type::*;
use u_update_CPACR_Type_cp10::*;
use u_update_DBGOSLSR_Type_OSLK::*;
use u_update_SDER_Type_SUIDEN::*;
use Mk_CNTHP_CTL_Type::*;
use Mk_PMINTEN_Type::*;
use Mk_ICV_IGRPEN1_Type::*;
use u_update_CNTHP_CTL_Type_ENABLE::*;
use u_update_PMCCFILTR_Type_NSK::*;
use ICV_HPPIR1_write::*;
use ICV_IGRPEN1_write::*;
use u_update_ICH_HCR_Type_VGrp1EIE::*;
use AMCNTENSET0_write::*;
use u_update_HCR_Type_TID1::*;
use ICV_CTLR_write::*;
use CSSELR_write::*;
use DBGDSCRext_read::*;
use u_update_ICC_PMR_Type_Priority::*;
use u_update_EDECCR_Type_NSR0::*;
use Mk_HTCR_Type::*;
use ICV_BPR1_read::*;
use u_update_DBGDSCRext_Type_MDBGen::*;
use CNTV_CTL_write::*;
use u_update_CPACR_Type_cp11::*;
use Mk_ICC_BPR1_Type::*;
use u_update_HCR2_Type_TEA::*;
use u_update_TTBCR_Type_IRGN1::*;
use u_update_EDSCR_Type_RXO::*;
use VMPIDR_write::*;
use u_update_SCTLR_Type_TRE::*;
use ICV_HPPIR1_read::*;
use SDER_read::*;
use TTBCR2_write::*;
use u_update_EDECCR_Type_RLR2::*;
use HTCR_write::*;
use ICV_IAR1_read::*;
use PMCCFILTR_read::*;
use DBGDRAR_read::*;
use CSSELR_read::*;
use DBGDCCINT_read::*;
use u_update_HCPTR_Type_TAM::*;
use DFSR_write::*;
use Mk_DBGVCR_Type::*;
use u_update_HSTR_Type_T3::*;
use u_update_PMCCFILTR_Type_NSH::*;
use Mk_ICV_HPPIR0_Type::*;
use u_update_EDSCR_Type_MA::*;
use u_update_SCTLR_Type_nTWI::*;
use u_update_HCR2_Type_TICAB::*;
use HTRFCR_read::*;
use Mk_ICV_DIR_Type::*;
use ICC_ASGI1R_write::*;
use Mk_CNTKCTL_Type::*;
use EDSCR_write::*;
use CNTHP_CTL_read::*;
use Mk_CNTHPS_CTL_Type::*;
use u_update_ICC_SRE_Type_DIB::*;
use CNTP_CTL_write::*;
use Mk_ICC_PMR_Type::*;
use u_update_EDECCR_Type_RLE2::*;
use Mk_ICC_SRE_Type::*;
use u_update_PMCR_Type_DP::*;
use Mk_ICC_SGI1R_Type::*;
use Mk_AMCGCR_Type::*;
use u_update_EDSCR2_Type_EHBWE::*;
use Mk_CNTP_CTL_Type::*;
use u_update_HCR_Type_VA::*;
use AMCNTENCLR1_write::*;
use ICC_DIR_write::*;
use Mk_MVFR2_Type::*;
use Mk_TTBR0_Type::*;
use u_update_SDER_Type_SUNIDEN::*;
use ICC_BPR0_read::*;
use u_update_CNTV_CTL_Type_ENABLE::*;
use u_update_DBGCLAIMCLR_Type_CLAIM::*;
use u_update_ICH_EISR_Type_Status7::*;
use ID_AFR0_write::*;
use u_update_ICH_HCR_Type_EOIcount::*;
use ICV_BPR1_write::*;
use ICV_IGRPEN1_read::*;
use u_update_TTBCR_Type_ORGN0::*;
use Mk_ICH_ELRSR_Type::*;
use Mk_ICH_HCR_Type::*;
use ICV_PMR_read::*;
use u_update_SCTLR_Type_nTWE::*;
use TTBCR_write::*;
use u_update_SCTLR_Type_SED::*;
use ICH_EISR_write::*;
use u_update_TRFCR_Type_E1TRE::*;
use CNTHCTL_write::*;
use u_update_EDECCR_Type_RLR0::*;
use Mk_ICV_EOIR0_Type::*;
use DBGDSCRint_write::*;
use CNTHPS_CTL_write::*;
use ICC_SRE_write::*;
use Mk_HSTR_Type::*;
use VPIDR_read::*;
use u_update_HSTR_Type_T7::*;
use MPIDR_read::*;
use u_update_EDSCR_Type_ERR::*;
use Mk_ICV_IAR1_Type::*;
use u_update_HSTR_Type_T10::*;
use ICC_HPPIR1_read::*;
use HPFAR_read::*;
use ICC_HPPIR1_write::*;
use ERRSELR_read::*;
use u_update_ICH_EISR_Type_Status10::*;
use u_update_DBGDCCINT_Type_RX::*;
use u_update_HSTR_Type_T5::*;
use u_update_HCR_Type_TID2::*;
use ICC_SGI0R_read::*;
use u_update_ICC_HSRE_Type_DFB::*;
use u_update_VMPIDR_Type_Aff1::*;
use Mk_RMR_Type::*;
use u_update_HTRFCR_Type_E2TRE::*;
use AMCR_read::*;
use VDISR_read::*;
use Mk_EDSCR_Type::*;
use u_update_HCPTR_Type_TCP10::*;
use DBGDRAR_write::*;
use ID_ISAR5_write::*;
use PMCNTEN_write::*;
use u_update_HCR2_Type_CD::*;
use ICH_MISR_read::*;
use FPSCR_write::*;
use TRFCR_write::*;
use u_update_PMCCFILTR_Type_NSU::*;
use DSPSR2_write::*;
use Mk_ICC_DIR_Type::*;
use EDSCR2_write::*;
use u_update_ICH_EISR_Type_Status3::*;
use u_update_HCR2_Type_TTLBIS::*;
use u_update_VPIDR_Type_PartNum::*;
use ICH_VTR_write::*;
use u_update_HCR_Type_FMO::*;
use HPFAR_write::*;
use Mk_SDER_Type::*;
use DBGCLAIMCLR_read::*;
use u_update_HSCTLR_Type_M::*;
use ICV_IAR0_write::*;
use PMSWINC_read::*;
use u_update_ICH_HCR_Type_VGrp0EIE::*;
use Mk_HCR2_Type::*;
use u_update_ICH_EISR_Type_Status11::*;
use u_update_HDCR_Type_TPM::*;
use TTBCR2_read::*;
use u_update_ICH_MISR_Type_VGrp0E::*;
use Mk_AMCNTENSET1_Type::*;
use Mk_EDECCR_Type::*;
use u_update_TTBCR_Type_PD0::*;
use u_update_VPIDR_Type_Revision::*;
use ICC_IAR0_write::*;
use DBGPRCR_read::*;
use ICV_HPPIR0_read::*;
use Mk_PMCNTEN_Type::*;
use Mk_DSPSR2_Type::*;
use ERRIDR_read::*;
use Mk_ICV_IAR0_Type::*;
use u_update_TTBCR_Type_IRGN0::*;
use u_update_TTBCR_Type_SH1::*;
use Mk_FPEXC_Type::*;
use Mk_CNTHVS_CTL_Type::*;
use u_update_TTBCR_Type_A1::*;
use CNTHVS_CTL_write::*;
use Mk_ERRSELR_Type::*;
use ICC_HPPIR0_write::*;
use ICC_RPR_read::*;
use u_update_HCR_Type_VI::*;
use Mk_DBGPRCR_Type::*;
use Mk_ICC_IAR0_Type::*;
use MVFR2_write::*;
use u_update_TTBCR_Type_EPD1::*;
use DBGAUTHSTATUS_read::*;
use HSTR_write::*;
use ICC_DIR_read::*;
use CNTKCTL_read__1::*;
use u_update_ICH_EISR_Type_Status5::*;
use Mk_ICC_CTLR_Type::*;
use Mk_CTR_Type::*;
use u_update_HCPTR_Type_TCPAC::*;
use u_update_HCR_Type_PTW::*;
use ID_MMFR5_write::*;
use u_update_TTBCR_Type_SH0::*;
use u_update_ICC_IGRPEN1_Type_Enable::*;
use CNTHCTL_read::*;
use ICV_BPR0_read::*;
use ID_PFR2_read::*;
use Mk_VTCR_Type::*;
use Mk_DBGDSCRint_Type::*;
use Mk_FPSCR_Type::*;
use u_update_VPIDR_Type_Architecture::*;
use Mk_TRFCR_Type::*;
use PMINTEN_read::*;
use Mk_ICC_IGRPEN1_Type::*;
use Mk_HCR_Type::*;
use HCR_write::*;
use u_update_ICC_SRE_Type_SRE::*;
use ID_ISAR0_read::*;
use Mk_ID_ISAR0_Type::*;
use u_update_PMCCFILTR_Type_P::*;
use PRRR_write::*;
use Mk_AMCR_Type::*;
use u_update_EDECCR_Type_RLR1::*;
use Mk_CSSELR_Type::*;
use Mk_DBGCLAIMSET_Type::*;
use u_update_ICH_MISR_Type_VGrp1D::*;
use HCR2_write::*;
use u_update_VPIDR_Type_Variant::*;
use u_update_DBGOSDLR_Type_DLK::*;
use CCSIDR2_read::*;
use u_update_HDCR_Type_HPMN::*;
use u_update_HCR_Type_TSW::*;
use Mk_ICH_VMCR_Type::*;
use u_update_EDECCR_Type_NSE1::*;
use Mk_HDCR_Type::*;
use ICV_DIR_write::*;
use TTBCR_read::*;
use u_update_HCR_Type_VF::*;
use ICV_RPR_read::*;
use DBGVCR_read::*;
use Mk_PMSELR_Type::*;
use u_update_ICH_HCR_Type_VGrp1DIE::*;
use Mk_ICV_CTLR_Type::*;
use Mk_IFSR_Type::*;
use Mk_ICH_MISR_Type::*;
use u_update_HDCR_Type_TPMCR::*;
use u_update_EDECCR_Type_NSE2::*;
use u_update_HDCR_Type_TTRF::*;
use CNTKCTL_write::*;
use u_update_EDECCR_Type_SE2::*;
use PMSELR_write::*;
use AMCGCR_read::*;
use Mk_HCPTR_Type::*;
use u_update_HCR_Type_TSC::*;
use ID_MMFR5_read::*;
use Mk_ICV_RPR_Type::*;
use u_update_TTBCR_Type_EAE::*;
use HCR_read::*;
use IsFeatureImplemented::*;
use u_update_SCTLR_Type_A::*;
use Mk_ISR_Type::*;
use u_update_HCR2_Type_TERR::*;
use u_update_HDCR_Type_TDA::*;
use DBGDSCRint_read::*;
use Bit::*;
use Mk_VDISR_Type::*;
use u_update_ICH_HCR_Type_TALL1::*;
use VMPIDR_read::*;
use Mk_TTBCR_Type::*;
use u_update_TRFCR_Type_E0TRE::*;
use VPIDR_write::*;
use u_update_HSTR_Type_T2::*;
use AMUSERENR_write::*;
use Mk_ICV_HPPIR1_Type::*;
use CCSIDR_write::*;
use AMUSERENR_read::*;
use ICC_BPR1_read::*;
use u_update_EDSCR_Type_TDA::*;
use ICC_CTLR_write::*;
use u__UNKNOWN_bits::*;
use Mk_HTRFCR_Type::*;
use u_update_SCTLR_Type_M::*;
use u_update_HCR_Type_TPC::*;
use u_update_ICV_IGRPEN0_Type_Enable::*;
use u_update_HSTR_Type_T12::*;
use u_update_ICH_MISR_Type_EOI::*;
use Mk_MPIDR_Type::*;
use PMCNTEN_read::*;
use ICC_EOIR0_read::*;
use TTBR0_read::*;
use u_update_HSCTLR_Type_I::*;
use u_update_ICH_HCR_Type_vSGIEOICount::*;
use RMR_write::*;
use CNTHPS_CTL_read::*;
use ICC_HPPIR0_read::*;
use Mk_DFSR_Type::*;
use FPSCR_read__1::*;
use ICH_EISR_read::*;
use u_update_HCR_Type_TVM::*;
use PMCCFILTR_write::*;
use HaveAArch64::*;
use CTR_write::*;
use u_update_ICH_EISR_Type_Status0::*;
use PMSWINC_write::*;
use u_update_HCPTR_Type_TASE::*;
use Mk_ICC_IGRPEN0_Type::*;
use Mk_ICC_HPPIR0_Type::*;
use u_update_ICH_EISR_Type_Status8::*;
use HVBAR_write::*;
use ICV_BPR0_write::*;
use u_update_HDCR_Type_HPMD::*;
use FPEXC_read::*;
use Mk_ID_PFR2_Type::*;
use Mk_DBGAUTHSTATUS_Type::*;
use ICC_IGRPEN0_read::*;
use SCTLR_write::*;
use u_update_DBGDSCRext_Type_UDCCdis::*;
use ERRIDR_write::*;
use DBGOSDLR_read::*;
use u_update_CNTP_CTL_Type_ENABLE::*;
use u_update_EDSCR_Type_TXU::*;
use u_update_TTBCR_Type_T0SZ::*;
use u_update_HCR_Type_FB::*;
use u_update_HDCR_Type_HPME::*;
use Mk_ICV_BPR1_Type::*;
use HSCTLR_read::*;
use AMCNTENCLR0_write::*;
use u_update_HSTR_Type_T1::*;
use u_update_TTBCR_Type_ORGN1::*;
use u_update_EDSCR_Type_TFO::*;
use Mk_TTBR1_Type::*;
use AMCFGR_read::*;
use u_update_EDECCR_Type_SR3::*;
use ICV_EOIR0_write::*;
use ICH_VMCR_write::*;
use u_update_HCR2_Type_TID4::*;
use u_update_DBGCLAIMSET_Type_CLAIM::*;
use u_update_HDCR_Type_TDE::*;
use u_update_HDCR_Type_TDOSA::*;
use u_update_TTBCR_Type_T1SZ::*;
use ICC_PMR_read::*;
use u_update_ICH_MISR_Type_LRENP::*;
use IFSR_write::*;
use ICC_SGI1R_write::*;
use ICH_ELRSR_read::*;
use EDSCR2_read::*;
use Mk_EDSCR2_Type::*;
use ICC_IAR1_read::*;
use u_update_HCR2_Type_ID::*;
use MPIDR_write::*;
use u_update_ICC_HSRE_Type_SRE::*;
use ICC_SGI0R_write::*;
use u_update_HCR_Type_TRVM::*;
use Mk_CCSIDR_Type::*;
use u_get_GICD_CTLR_Type_DS::*;
use ICH_VMCR_read::*;
use Mk_ICC_RPR_Type::*;
use u_update_SCTLR_Type_C::*;
use Mk_DBGOSLSR_Type::*;
use ICC_HSRE_write::*;
use Mk_CNTV_CTL_Type::*;
use u_update_EDECCR_Type_SR1::*;
use PRRR_read::*;
use ICC_IGRPEN1_read::*;
use u_update_HTRFCR_Type_CX::*;
use u_update_DBGDCCINT_Type_TX::*;
use u_update_HCR_Type_VM::*;
use CNTHV_CTL_write::*;
use Mk_ICC_EOIR0_Type::*;
use u_update_ICH_HCR_Type_UIE::*;
use ID_DFR1_read::*;
use u_update_RMR_Type_RR::*;
use Mk_HSCTLR_Type::*;
use u_update_HSCTLR_Type_LSMAOE::*;
use Mk_SCTLR_Type::*;
use Mk_ICC_ASGI1R_Type::*;
use Mk_ID_ISAR5_Type::*;
use PMCR_write::*;
use VBAR_write::*;
use FPEXC_write::*;
use ID_ISAR0_write::*;
use Mk_HRMR_Type::*;
use common::*;
pub fn AArch32_AutoGen_ArchitectureReset<T: Tracer>(
    state: &mut State,
    tracer: &T,
    cold: bool,
) -> () {
    #[derive(Default)]
    struct FunctionState {
        gs_44724: bool,
        ga_34862: ProductType700c18a878c5601b,
        ga_36676: ProductType700c18a878c5601b,
        ga_36796: ProductType700c18a878c5601b,
        ga_36228: ProductType700c18a878c5601b,
        ga_36240: ProductType700c18a878c5601b,
        ga_34672: ProductType5c790c8ef59cc8b2,
        ga_36490: ProductType700c18a878c5601b,
        ga_35316: ProductType700c18a878c5601b,
        ga_36294: ProductType700c18a878c5601b,
        ga_35322: ProductType700c18a878c5601b,
        gs_44008: bool,
        ga_35520: ProductType700c18a878c5601b,
        ga_35759: ProductType700c18a878c5601b,
        ga_35512: ProductType700c18a878c5601b,
        gs_44425: bool,
        ga_36344: ProductType700c18a878c5601b,
        ga_35210: ProductType700c18a878c5601b,
        ga_34844: ProductType5c790c8ef59cc8b2,
        ga_35871: ProductType700c18a878c5601b,
        ga_36168: ProductType700c18a878c5601b,
        ga_35290: ProductType700c18a878c5601b,
        ga_36656: ProductType700c18a878c5601b,
        ga_34598: ProductType5c790c8ef59cc8b2,
        ga_36792: ProductType700c18a878c5601b,
        ga_36478: ProductType700c18a878c5601b,
        ga_36274: ProductType700c18a878c5601b,
        ga_36606: ProductType700c18a878c5601b,
        ga_36140: ProductType700c18a878c5601b,
        ga_36546: ProductType700c18a878c5601b,
        ga_36314: ProductType700c18a878c5601b,
        gs_44113: bool,
        ga_35616: ProductType700c18a878c5601b,
        gs_44004: bool,
        ga_36428: ProductType700c18a878c5601b,
        ga_36400: ProductType700c18a878c5601b,
        ga_36368: ProductType700c18a878c5601b,
        ga_36931: ProductType700c18a878c5601b,
        ga_35480: ProductType700c18a878c5601b,
        gs_43993: bool,
        ga_35472: ProductType700c18a878c5601b,
        ga_36740: ProductType700c18a878c5601b,
        gs_44431: bool,
        ga_35186: ProductType700c18a878c5601b,
        gs_44291: bool,
        ga_36668: ProductType700c18a878c5601b,
        ga_36570: ProductType700c18a878c5601b,
        ga_36672: ProductType700c18a878c5601b,
        ga_34646: ProductType5c790c8ef59cc8b2,
        ga_35606: ProductType700c18a878c5601b,
        ga_36598: ProductType700c18a878c5601b,
        ga_36384: ProductType700c18a878c5601b,
        gs_44028: bool,
        ga_34626: ProductType5c790c8ef59cc8b2,
        gs_44421: bool,
        ga_35516: ProductType700c18a878c5601b,
        ga_35831: ProductType700c18a878c5601b,
        ga_36252: ProductType700c18a878c5601b,
        ga_36018: ProductType700c18a878c5601b,
        gs_44409: bool,
        ga_34610: ProductType5c790c8ef59cc8b2,
        ga_36298: ProductType700c18a878c5601b,
        ga_36094: ProductType700c18a878c5601b,
        ga_36022: ProductType700c18a878c5601b,
        ga_36700: ProductType700c18a878c5601b,
        ga_35765: ProductType700c18a878c5601b,
        ga_34578: ProductType5c790c8ef59cc8b2,
        ga_36464: ProductType700c18a878c5601b,
        gs_44040: bool,
        ga_36652: ProductType700c18a878c5601b,
        gs_44118: bool,
        ga_35234: ProductType700c18a878c5601b,
        ga_36030: ProductType700c18a878c5601b,
        ga_35346: ProductType700c18a878c5601b,
        ga_35488: ProductType700c18a878c5601b,
        ga_36038: ProductType700c18a878c5601b,
        gs_44408: bool,
        gs_44426: bool,
        ga_35366: ProductType700c18a878c5601b,
        ga_35578: ProductType700c18a878c5601b,
        ga_35835: ProductType700c18a878c5601b,
        gs_44288: bool,
        ga_36134: ProductType700c18a878c5601b,
        ga_34664: ProductType5c790c8ef59cc8b2,
        gs_43996: bool,
        ga_36190: ProductType700c18a878c5601b,
        ga_34916: ProductType700c18a878c5601b,
        ga_37119: ProductType700c18a878c5601b,
        gs_43981: bool,
        ga_35302: ProductType700c18a878c5601b,
        gs_43985: bool,
        ga_35528: ProductType700c18a878c5601b,
        ga_36474: ProductType700c18a878c5601b,
        ga_36224: ProductType700c18a878c5601b,
        ga_36364: ProductType700c18a878c5601b,
        ga_36110: ProductType700c18a878c5601b,
        gs_44413: bool,
        ga_35753: ProductType700c18a878c5601b,
        ga_34606: ProductType5c790c8ef59cc8b2,
        ga_36340: ProductType700c18a878c5601b,
        ga_34622: ProductType5c790c8ef59cc8b2,
        ga_34650: ProductType5c790c8ef59cc8b2,
        gs_44289: bool,
        ga_35156: ProductType700c18a878c5601b,
        ga_36396: ProductType700c18a878c5601b,
        ga_36424: ProductType700c18a878c5601b,
        gs_43997: bool,
        gs_43999: bool,
        gs_44285: bool,
        gs_43998: bool,
        ga_36444: ProductType700c18a878c5601b,
        ga_35162: ProductType700c18a878c5601b,
        ga_35450: ProductType700c18a878c5601b,
        ga_36800: ProductType700c18a878c5601b,
        ga_35540: ProductType700c18a878c5601b,
        gs_44011: bool,
        gs_44417: bool,
        ga_35747: ProductType700c18a878c5601b,
        ga_36804: ProductType700c18a878c5601b,
        ga_36724: ProductType700c18a878c5601b,
        ga_36688: ProductType700c18a878c5601b,
        gs_44720: bool,
        ga_34586: ProductType5c790c8ef59cc8b2,
        gs_44287: bool,
        ga_36210: ProductType700c18a878c5601b,
        ga_36232: ProductType700c18a878c5601b,
        ga_36176: ProductType700c18a878c5601b,
        ga_36244: ProductType700c18a878c5601b,
        ga_36380: ProductType700c18a878c5601b,
        ga_36248: ProductType700c18a878c5601b,
        ga_35598: ProductType700c18a878c5601b,
        ga_34602: ProductType5c790c8ef59cc8b2,
        ga_36058: ProductType700c18a878c5601b,
        ga_36562: ProductType700c18a878c5601b,
        ga_36306: ProductType700c18a878c5601b,
        ga_36586: ProductType700c18a878c5601b,
        ga_35560: ProductType700c18a878c5601b,
        ga_36558: ProductType700c18a878c5601b,
        ga_36410: ProductType700c18a878c5601b,
        ga_35252: ProductType700c18a878c5601b,
        gs_43989: bool,
        ga_35928: ProductType700c18a878c5601b,
        gs_44006: bool,
        ga_34870: ProductType700c18a878c5601b,
        ga_36692: ProductType700c18a878c5601b,
        ga_36744: ProductType700c18a878c5601b,
        ga_36122: ProductType700c18a878c5601b,
        ga_36760: ProductType700c18a878c5601b,
        ga_36432: ProductType700c18a878c5601b,
        ga_36420: ProductType700c18a878c5601b,
        ga_34898: ProductType700c18a878c5601b,
        ga_34642: ProductType5c790c8ef59cc8b2,
        ga_35556: ProductType700c18a878c5601b,
        ga_36052: ProductType700c18a878c5601b,
        ga_36648: ProductType700c18a878c5601b,
        ga_35426: ProductType700c18a878c5601b,
        ga_36780: ProductType700c18a878c5601b,
        ga_34828: ProductType5c790c8ef59cc8b2,
        gs_44108: bool,
        ga_36328: ProductType700c18a878c5601b,
        ga_34594: ProductType5c790c8ef59cc8b2,
        ga_36172: ProductType700c18a878c5601b,
        gs_43994: bool,
        ga_36542: ProductType700c18a878c5601b,
        gs_43988: bool,
        ga_36664: ProductType700c18a878c5601b,
        ga_36720: ProductType700c18a878c5601b,
        ga_36404: ProductType700c18a878c5601b,
        ga_35524: ProductType700c18a878c5601b,
        gs_44005: bool,
        ga_36440: ProductType700c18a878c5601b,
        ga_35532: ProductType700c18a878c5601b,
        ga_36318: ProductType700c18a878c5601b,
        ga_35294: ProductType700c18a878c5601b,
        ga_35418: ProductType700c18a878c5601b,
        ga_36156: ProductType700c18a878c5601b,
        gs_44009: bool,
        ga_34634: ProductType5c790c8ef59cc8b2,
        gs_44294: bool,
        gs_44282: bool,
        gs_44112: bool,
        ga_36502: ProductType700c18a878c5601b,
        gs_44292: bool,
        ga_35743: ProductType700c18a878c5601b,
        ga_36772: ProductType700c18a878c5601b,
        ga_35496: ProductType700c18a878c5601b,
        ga_35308: ProductType700c18a878c5601b,
        gs_44001: bool,
        ga_35312: ProductType700c18a878c5601b,
        ga_35454: ProductType700c18a878c5601b,
        gs_43991: bool,
        ga_35198: ProductType700c18a878c5601b,
        ga_36470: ProductType700c18a878c5601b,
        ga_36214: ProductType700c18a878c5601b,
        ga_36286: ProductType700c18a878c5601b,
        ga_34660: ProductType5c790c8ef59cc8b2,
        ga_36590: ProductType700c18a878c5601b,
        ga_36118: ProductType700c18a878c5601b,
        ga_36392: ProductType700c18a878c5601b,
        ga_36582: ProductType700c18a878c5601b,
        gs_44010: bool,
        gs_44290: bool,
        gs_44032: bool,
        ga_36160: ProductType700c18a878c5601b,
        ga_36186: ProductType700c18a878c5601b,
        ga_36696: ProductType700c18a878c5601b,
        gs_44286: bool,
        ga_34910: ProductType700c18a878c5601b,
        ga_36014: ProductType700c18a878c5601b,
        ga_35166: ProductType700c18a878c5601b,
        ga_36776: ProductType700c18a878c5601b,
        gs_44293: bool,
        ga_36436: ProductType700c18a878c5601b,
        ga_35460: ProductType700c18a878c5601b,
        ga_34892: ProductType700c18a878c5601b,
        gs_44002: bool,
        gs_43986: bool,
        ga_35484: ProductType700c18a878c5601b,
        ga_35548: ProductType700c18a878c5601b,
        ga_35552: ProductType700c18a878c5601b,
        ga_35444: ProductType700c18a878c5601b,
        ga_36042: ProductType700c18a878c5601b,
        ga_35260: ProductType700c18a878c5601b,
        gs_43987: bool,
        gs_44122: bool,
        ga_35536: ProductType700c18a878c5601b,
        ga_35769: ProductType700c18a878c5601b,
        gs_44024: bool,
        ga_37035: ProductType700c18a878c5601b,
        ga_36148: ProductType700c18a878c5601b,
        gs_44104: bool,
        ga_36310: ProductType700c18a878c5601b,
        ga_34878: ProductType700c18a878c5601b,
        ga_36164: ProductType700c18a878c5601b,
        gs_44039: bool,
        ga_35994: ProductType700c18a878c5601b,
        gs_44284: bool,
        ga_34590: ProductType5c790c8ef59cc8b2,
        ga_36660: ProductType700c18a878c5601b,
        ga_35440: ProductType700c18a878c5601b,
        ga_35504: ProductType700c18a878c5601b,
        ga_36206: ProductType700c18a878c5601b,
        gs_43736: bool,
        ga_36708: ProductType700c18a878c5601b,
        ga_34638: ProductType5c790c8ef59cc8b2,
        ga_35611: ProductType700c18a878c5601b,
        ga_35410: ProductType700c18a878c5601b,
        ga_36680: ProductType700c18a878c5601b,
        gs_44023: bool,
        gs_44749: bool,
        ga_36748: ProductType700c18a878c5601b,
        ga_34668: ProductType5c790c8ef59cc8b2,
        ga_36182: ProductType700c18a878c5601b,
        ga_36732: ProductType700c18a878c5601b,
        ga_36072: ProductType700c18a878c5601b,
        ga_36937: ProductType700c18a878c5601b,
        ga_36768: ProductType700c18a878c5601b,
        ga_36152: ProductType700c18a878c5601b,
        ga_35903: ProductType700c18a878c5601b,
        ga_36756: ProductType700c18a878c5601b,
        ga_35915: ProductType700c18a878c5601b,
        gs_43990: bool,
        ga_35272: ProductType700c18a878c5601b,
        gs_44716: bool,
        ga_35464: ProductType700c18a878c5601b,
        ga_36788: ProductType700c18a878c5601b,
        ga_35414: ProductType700c18a878c5601b,
        gs_44430: bool,
        gs_44123: bool,
        ga_35276: ProductType700c18a878c5601b,
        ga_36712: ProductType700c18a878c5601b,
        ga_35238: ProductType700c18a878c5601b,
        ga_35214: ProductType700c18a878c5601b,
        ga_35781: ProductType700c18a878c5601b,
        ga_35298: ProductType700c18a878c5601b,
        ga_36126: ProductType700c18a878c5601b,
        gs_44281: bool,
        ga_36278: ProductType700c18a878c5601b,
        ga_36602: ProductType700c18a878c5601b,
        gs_44003: bool,
        gs_44283: bool,
        ga_36376: ProductType700c18a878c5601b,
        gs_44428: bool,
        ga_36290: ProductType700c18a878c5601b,
        ga_34840: ProductType5c790c8ef59cc8b2,
        ga_36764: ProductType700c18a878c5601b,
        ga_35248: ProductType700c18a878c5601b,
        ga_36236: ProductType700c18a878c5601b,
        gs_45205: bool,
        ga_35544: ProductType700c18a878c5601b,
        ga_36784: ProductType700c18a878c5601b,
        gs_45018: bool,
        ga_35406: ProductType700c18a878c5601b,
        ga_35891: ProductType700c18a878c5601b,
        ga_35422: ProductType700c18a878c5601b,
        gs_44000: bool,
        ga_35777: ProductType700c18a878c5601b,
        ga_35286: ProductType700c18a878c5601b,
        gs_44725: bool,
        ga_36130: ProductType700c18a878c5601b,
        ga_36552: ProductType700c18a878c5601b,
        ga_35508: ProductType700c18a878c5601b,
        gs_43980: bool,
        ga_36102: ProductType700c18a878c5601b,
        ga_35268: ProductType700c18a878c5601b,
        ga_35773: ProductType700c18a878c5601b,
        gs_44007: bool,
        ga_35334: ProductType700c18a878c5601b,
        ga_36728: ProductType700c18a878c5601b,
        ga_36736: ProductType700c18a878c5601b,
        ga_36046: ProductType700c18a878c5601b,
        ga_35264: ProductType700c18a878c5601b,
        ga_35244: ProductType700c18a878c5601b,
        gs_44427: bool,
        ga_36144: ProductType700c18a878c5601b,
        ga_35256: ProductType700c18a878c5601b,
        gs_43995: bool,
        ga_36704: ProductType700c18a878c5601b,
        ga_36448: ProductType700c18a878c5601b,
        gs_43992: bool,
        ga_35282: ProductType700c18a878c5601b,
        ga_34936: ProductType700c18a878c5601b,
        ga_34614: ProductType5c790c8ef59cc8b2,
        ga_36026: ProductType700c18a878c5601b,
        ga_36372: ProductType700c18a878c5601b,
        ga_36416: ProductType700c18a878c5601b,
        ga_35386: ProductType700c18a878c5601b,
        ga_36106: ProductType700c18a878c5601b,
        ga_34630: ProductType5c790c8ef59cc8b2,
        ga_36716: ProductType700c18a878c5601b,
        ga_36202: ProductType700c18a878c5601b,
        ga_36684: ProductType700c18a878c5601b,
        ga_36114: ProductType700c18a878c5601b,
        ga_36752: ProductType700c18a878c5601b,
        ga_34582: ProductType5c790c8ef59cc8b2,
        ga_37045: ProductType700c18a878c5601b,
        ga_34654: ProductType5c790c8ef59cc8b2,
        ga_35468: ProductType700c18a878c5601b,
        ga_34618: ProductType5c790c8ef59cc8b2,
        ga_36334: ProductType700c18a878c5601b,
        ga_36594: ProductType700c18a878c5601b,
        ga_36452: ProductType700c18a878c5601b,
        ga_36610: ProductType700c18a878c5601b,
        gs_44429: bool,
        ga_35492: ProductType700c18a878c5601b,
        gs_44117: bool,
        ga_35500: ProductType700c18a878c5601b,
        ga_36034: ProductType700c18a878c5601b,
        cold: bool,
    }
    let fn_state = FunctionState {
        cold,
        ..Default::default()
    };
    return block_0(state, tracer, fn_state);
    fn block_0<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_0_0: const #() : ()
        let s_0_0: () = ();
        // S s_0_1: call ICC_SGI1R_read(s_0_0)
        let s_0_1: ProductType5c790c8ef59cc8b2 = ICC_SGI1R_read(state, tracer, s_0_0);
        // D s_0_2: write-var ga#34578 <= s_0_1
        fn_state.ga_34578 = s_0_1;
        // D s_0_3: read-var ga#34578.0:struct
        let s_0_3: u64 = fn_state.ga_34578._0;
        // C s_0_4: const #8s : i
        let s_0_4: i128 = 8;
        // C s_0_5: const #56s : i
        let s_0_5: i128 = 56;
        // D s_0_6: cast zx s_0_3 -> bv
        let s_0_6: Bits = Bits::new(s_0_3 as u128, 64u16);
        // C s_0_7: const #0u : u8
        let s_0_7: u8 = 0;
        // C s_0_8: cast zx s_0_7 -> bv
        let s_0_8: Bits = Bits::new(s_0_7 as u128, 8u16);
        // C s_0_9: const #1u : u64
        let s_0_9: u64 = 1;
        // C s_0_10: cast zx s_0_9 -> bv
        let s_0_10: Bits = Bits::new(s_0_9 as u128, 64u16);
        // C s_0_11: lsl s_0_10 s_0_4
        let s_0_11: Bits = s_0_10 << s_0_4;
        // C s_0_12: sub s_0_11 s_0_10
        let s_0_12: Bits = ((s_0_11) - (s_0_10));
        // C s_0_13: and s_0_8 s_0_12
        let s_0_13: Bits = ((s_0_8) & (s_0_12));
        // C s_0_14: lsl s_0_13 s_0_5
        let s_0_14: Bits = s_0_13 << s_0_5;
        // C s_0_15: lsl s_0_12 s_0_5
        let s_0_15: Bits = s_0_12 << s_0_5;
        // C s_0_16: cmpl s_0_15
        let s_0_16: Bits = !s_0_15;
        // D s_0_17: and s_0_6 s_0_16
        let s_0_17: Bits = ((s_0_6) & (s_0_16));
        // D s_0_18: or s_0_17 s_0_14
        let s_0_18: Bits = ((s_0_17) | (s_0_14));
        // D s_0_19: cast reint s_0_18 -> u64
        let s_0_19: u64 = (s_0_18.value() as u64);
        // D s_0_20: call Mk_ICC_SGI1R_Type(s_0_19)
        let s_0_20: ProductType5c790c8ef59cc8b2 = Mk_ICC_SGI1R_Type(
            state,
            tracer,
            s_0_19,
        );
        // D s_0_21: call ICC_SGI1R_write(s_0_20)
        let s_0_21: () = ICC_SGI1R_write(state, tracer, s_0_20);
        // C s_0_22: const #() : ()
        let s_0_22: () = ();
        // S s_0_23: call ICC_SGI1R_read(s_0_22)
        let s_0_23: ProductType5c790c8ef59cc8b2 = ICC_SGI1R_read(state, tracer, s_0_22);
        // D s_0_24: write-var ga#34582 <= s_0_23
        fn_state.ga_34582 = s_0_23;
        // D s_0_25: read-var ga#34582.0:struct
        let s_0_25: u64 = fn_state.ga_34582._0;
        // C s_0_26: const #3s : i
        let s_0_26: i128 = 3;
        // C s_0_27: const #41s : i
        let s_0_27: i128 = 41;
        // D s_0_28: cast zx s_0_25 -> bv
        let s_0_28: Bits = Bits::new(s_0_25 as u128, 64u16);
        // C s_0_29: const #0u : u8
        let s_0_29: u8 = 0;
        // C s_0_30: cast zx s_0_29 -> bv
        let s_0_30: Bits = Bits::new(s_0_29 as u128, 3u16);
        // C s_0_31: const #1u : u64
        let s_0_31: u64 = 1;
        // C s_0_32: cast zx s_0_31 -> bv
        let s_0_32: Bits = Bits::new(s_0_31 as u128, 64u16);
        // C s_0_33: lsl s_0_32 s_0_26
        let s_0_33: Bits = s_0_32 << s_0_26;
        // C s_0_34: sub s_0_33 s_0_32
        let s_0_34: Bits = ((s_0_33) - (s_0_32));
        // C s_0_35: and s_0_30 s_0_34
        let s_0_35: Bits = ((s_0_30) & (s_0_34));
        // C s_0_36: lsl s_0_35 s_0_27
        let s_0_36: Bits = s_0_35 << s_0_27;
        // C s_0_37: lsl s_0_34 s_0_27
        let s_0_37: Bits = s_0_34 << s_0_27;
        // C s_0_38: cmpl s_0_37
        let s_0_38: Bits = !s_0_37;
        // D s_0_39: and s_0_28 s_0_38
        let s_0_39: Bits = ((s_0_28) & (s_0_38));
        // D s_0_40: or s_0_39 s_0_36
        let s_0_40: Bits = ((s_0_39) | (s_0_36));
        // D s_0_41: cast reint s_0_40 -> u64
        let s_0_41: u64 = (s_0_40.value() as u64);
        // D s_0_42: call Mk_ICC_SGI1R_Type(s_0_41)
        let s_0_42: ProductType5c790c8ef59cc8b2 = Mk_ICC_SGI1R_Type(
            state,
            tracer,
            s_0_41,
        );
        // D s_0_43: call ICC_SGI1R_write(s_0_42)
        let s_0_43: () = ICC_SGI1R_write(state, tracer, s_0_42);
        // C s_0_44: const #() : ()
        let s_0_44: () = ();
        // S s_0_45: call ICC_SGI1R_read(s_0_44)
        let s_0_45: ProductType5c790c8ef59cc8b2 = ICC_SGI1R_read(state, tracer, s_0_44);
        // D s_0_46: write-var ga#34586 <= s_0_45
        fn_state.ga_34586 = s_0_45;
        // D s_0_47: read-var ga#34586.0:struct
        let s_0_47: u64 = fn_state.ga_34586._0;
        // C s_0_48: const #4s : i
        let s_0_48: i128 = 4;
        // C s_0_49: const #28s : i
        let s_0_49: i128 = 28;
        // D s_0_50: cast zx s_0_47 -> bv
        let s_0_50: Bits = Bits::new(s_0_47 as u128, 64u16);
        // C s_0_51: const #0u : u8
        let s_0_51: u8 = 0;
        // C s_0_52: cast zx s_0_51 -> bv
        let s_0_52: Bits = Bits::new(s_0_51 as u128, 4u16);
        // C s_0_53: const #1u : u64
        let s_0_53: u64 = 1;
        // C s_0_54: cast zx s_0_53 -> bv
        let s_0_54: Bits = Bits::new(s_0_53 as u128, 64u16);
        // C s_0_55: lsl s_0_54 s_0_48
        let s_0_55: Bits = s_0_54 << s_0_48;
        // C s_0_56: sub s_0_55 s_0_54
        let s_0_56: Bits = ((s_0_55) - (s_0_54));
        // C s_0_57: and s_0_52 s_0_56
        let s_0_57: Bits = ((s_0_52) & (s_0_56));
        // C s_0_58: lsl s_0_57 s_0_49
        let s_0_58: Bits = s_0_57 << s_0_49;
        // C s_0_59: lsl s_0_56 s_0_49
        let s_0_59: Bits = s_0_56 << s_0_49;
        // C s_0_60: cmpl s_0_59
        let s_0_60: Bits = !s_0_59;
        // D s_0_61: and s_0_50 s_0_60
        let s_0_61: Bits = ((s_0_50) & (s_0_60));
        // D s_0_62: or s_0_61 s_0_58
        let s_0_62: Bits = ((s_0_61) | (s_0_58));
        // D s_0_63: cast reint s_0_62 -> u64
        let s_0_63: u64 = (s_0_62.value() as u64);
        // D s_0_64: call Mk_ICC_SGI1R_Type(s_0_63)
        let s_0_64: ProductType5c790c8ef59cc8b2 = Mk_ICC_SGI1R_Type(
            state,
            tracer,
            s_0_63,
        );
        // D s_0_65: call ICC_SGI1R_write(s_0_64)
        let s_0_65: () = ICC_SGI1R_write(state, tracer, s_0_64);
        // C s_0_66: const #2s : i
        let s_0_66: i128 = 2;
        // C s_0_67: const #15880u : u32
        let s_0_67: u32 = 15880;
        // D s_0_68: read-reg s_0_67:u64
        let s_0_68: u64 = {
            let value = state.read_register::<u64>(s_0_67 as isize);
            tracer.read_register(s_0_67 as isize, value);
            value
        };
        // D s_0_69: cast zx s_0_68 -> bv
        let s_0_69: Bits = Bits::new(s_0_68 as u128, 64u16);
        // C s_0_70: const #0u : u62
        let s_0_70: u64 = 0;
        // C s_0_71: cast zx s_0_70 -> bv
        let s_0_71: Bits = Bits::new(s_0_70 as u128, 62u16);
        // C s_0_72: const #61s : i
        let s_0_72: i128 = 61;
        // C s_0_73: const #1u : u64
        let s_0_73: u64 = 1;
        // C s_0_74: cast zx s_0_73 -> bv
        let s_0_74: Bits = Bits::new(s_0_73 as u128, 64u16);
        // C s_0_75: lsl s_0_74 s_0_72
        let s_0_75: Bits = s_0_74 << s_0_72;
        // C s_0_76: sub s_0_75 s_0_74
        let s_0_76: Bits = ((s_0_75) - (s_0_74));
        // C s_0_77: and s_0_71 s_0_76
        let s_0_77: Bits = ((s_0_71) & (s_0_76));
        // C s_0_78: lsl s_0_77 s_0_66
        let s_0_78: Bits = s_0_77 << s_0_66;
        // C s_0_79: lsl s_0_76 s_0_66
        let s_0_79: Bits = s_0_76 << s_0_66;
        // C s_0_80: cmpl s_0_79
        let s_0_80: Bits = !s_0_79;
        // D s_0_81: and s_0_69 s_0_80
        let s_0_81: Bits = ((s_0_69) & (s_0_80));
        // D s_0_82: or s_0_81 s_0_78
        let s_0_82: Bits = ((s_0_81) | (s_0_78));
        // D s_0_83: cast reint s_0_82 -> u64
        let s_0_83: u64 = (s_0_82.value() as u64);
        // C s_0_84: const #15880u : u32
        let s_0_84: u32 = 15880;
        // N s_0_85: write-reg s_0_84 <= s_0_83
        let s_0_85: () = {
            state.write_register::<u64>(s_0_84 as isize, s_0_83);
            tracer.write_register(s_0_84 as isize, s_0_83);
        };
        // C s_0_86: const #0s : i
        let s_0_86: i128 = 0;
        // C s_0_87: const #15880u : u32
        let s_0_87: u32 = 15880;
        // D s_0_88: read-reg s_0_87:u64
        let s_0_88: u64 = {
            let value = state.read_register::<u64>(s_0_87 as isize);
            tracer.read_register(s_0_87 as isize, value);
            value
        };
        // D s_0_89: cast zx s_0_88 -> bv
        let s_0_89: Bits = Bits::new(s_0_88 as u128, 64u16);
        // C s_0_90: const #0u : u8
        let s_0_90: u8 = 0;
        // C s_0_91: cast zx s_0_90 -> bv
        let s_0_91: Bits = Bits::new(s_0_90 as u128, 2u16);
        // C s_0_92: const #1s : i
        let s_0_92: i128 = 1;
        // C s_0_93: const #1u : u64
        let s_0_93: u64 = 1;
        // C s_0_94: cast zx s_0_93 -> bv
        let s_0_94: Bits = Bits::new(s_0_93 as u128, 64u16);
        // C s_0_95: lsl s_0_94 s_0_92
        let s_0_95: Bits = s_0_94 << s_0_92;
        // C s_0_96: sub s_0_95 s_0_94
        let s_0_96: Bits = ((s_0_95) - (s_0_94));
        // C s_0_97: and s_0_91 s_0_96
        let s_0_97: Bits = ((s_0_91) & (s_0_96));
        // C s_0_98: lsl s_0_97 s_0_86
        let s_0_98: Bits = s_0_97 << s_0_86;
        // C s_0_99: lsl s_0_96 s_0_86
        let s_0_99: Bits = s_0_96 << s_0_86;
        // C s_0_100: cmpl s_0_99
        let s_0_100: Bits = !s_0_99;
        // D s_0_101: and s_0_89 s_0_100
        let s_0_101: Bits = ((s_0_89) & (s_0_100));
        // D s_0_102: or s_0_101 s_0_98
        let s_0_102: Bits = ((s_0_101) | (s_0_98));
        // D s_0_103: cast reint s_0_102 -> u64
        let s_0_103: u64 = (s_0_102.value() as u64);
        // C s_0_104: const #15880u : u32
        let s_0_104: u32 = 15880;
        // N s_0_105: write-reg s_0_104 <= s_0_103
        let s_0_105: () = {
            state.write_register::<u64>(s_0_104 as isize, s_0_103);
            tracer.write_register(s_0_104 as isize, s_0_103);
        };
        // C s_0_106: const #() : ()
        let s_0_106: () = ();
        // S s_0_107: call ICC_SGI0R_read(s_0_106)
        let s_0_107: ProductType5c790c8ef59cc8b2 = ICC_SGI0R_read(
            state,
            tracer,
            s_0_106,
        );
        // D s_0_108: write-var ga#34590 <= s_0_107
        fn_state.ga_34590 = s_0_107;
        // D s_0_109: read-var ga#34590.0:struct
        let s_0_109: u64 = fn_state.ga_34590._0;
        // C s_0_110: const #8s : i
        let s_0_110: i128 = 8;
        // C s_0_111: const #56s : i
        let s_0_111: i128 = 56;
        // D s_0_112: cast zx s_0_109 -> bv
        let s_0_112: Bits = Bits::new(s_0_109 as u128, 64u16);
        // C s_0_113: const #0u : u8
        let s_0_113: u8 = 0;
        // C s_0_114: cast zx s_0_113 -> bv
        let s_0_114: Bits = Bits::new(s_0_113 as u128, 8u16);
        // C s_0_115: const #1u : u64
        let s_0_115: u64 = 1;
        // C s_0_116: cast zx s_0_115 -> bv
        let s_0_116: Bits = Bits::new(s_0_115 as u128, 64u16);
        // C s_0_117: lsl s_0_116 s_0_110
        let s_0_117: Bits = s_0_116 << s_0_110;
        // C s_0_118: sub s_0_117 s_0_116
        let s_0_118: Bits = ((s_0_117) - (s_0_116));
        // C s_0_119: and s_0_114 s_0_118
        let s_0_119: Bits = ((s_0_114) & (s_0_118));
        // C s_0_120: lsl s_0_119 s_0_111
        let s_0_120: Bits = s_0_119 << s_0_111;
        // C s_0_121: lsl s_0_118 s_0_111
        let s_0_121: Bits = s_0_118 << s_0_111;
        // C s_0_122: cmpl s_0_121
        let s_0_122: Bits = !s_0_121;
        // D s_0_123: and s_0_112 s_0_122
        let s_0_123: Bits = ((s_0_112) & (s_0_122));
        // D s_0_124: or s_0_123 s_0_120
        let s_0_124: Bits = ((s_0_123) | (s_0_120));
        // D s_0_125: cast reint s_0_124 -> u64
        let s_0_125: u64 = (s_0_124.value() as u64);
        // D s_0_126: call Mk_ICC_SGI0R_Type(s_0_125)
        let s_0_126: ProductType5c790c8ef59cc8b2 = Mk_ICC_SGI0R_Type(
            state,
            tracer,
            s_0_125,
        );
        // D s_0_127: call ICC_SGI0R_write(s_0_126)
        let s_0_127: () = ICC_SGI0R_write(state, tracer, s_0_126);
        // C s_0_128: const #() : ()
        let s_0_128: () = ();
        // S s_0_129: call ICC_SGI0R_read(s_0_128)
        let s_0_129: ProductType5c790c8ef59cc8b2 = ICC_SGI0R_read(
            state,
            tracer,
            s_0_128,
        );
        // D s_0_130: write-var ga#34594 <= s_0_129
        fn_state.ga_34594 = s_0_129;
        // D s_0_131: read-var ga#34594.0:struct
        let s_0_131: u64 = fn_state.ga_34594._0;
        // C s_0_132: const #3s : i
        let s_0_132: i128 = 3;
        // C s_0_133: const #41s : i
        let s_0_133: i128 = 41;
        // D s_0_134: cast zx s_0_131 -> bv
        let s_0_134: Bits = Bits::new(s_0_131 as u128, 64u16);
        // C s_0_135: const #0u : u8
        let s_0_135: u8 = 0;
        // C s_0_136: cast zx s_0_135 -> bv
        let s_0_136: Bits = Bits::new(s_0_135 as u128, 3u16);
        // C s_0_137: const #1u : u64
        let s_0_137: u64 = 1;
        // C s_0_138: cast zx s_0_137 -> bv
        let s_0_138: Bits = Bits::new(s_0_137 as u128, 64u16);
        // C s_0_139: lsl s_0_138 s_0_132
        let s_0_139: Bits = s_0_138 << s_0_132;
        // C s_0_140: sub s_0_139 s_0_138
        let s_0_140: Bits = ((s_0_139) - (s_0_138));
        // C s_0_141: and s_0_136 s_0_140
        let s_0_141: Bits = ((s_0_136) & (s_0_140));
        // C s_0_142: lsl s_0_141 s_0_133
        let s_0_142: Bits = s_0_141 << s_0_133;
        // C s_0_143: lsl s_0_140 s_0_133
        let s_0_143: Bits = s_0_140 << s_0_133;
        // C s_0_144: cmpl s_0_143
        let s_0_144: Bits = !s_0_143;
        // D s_0_145: and s_0_134 s_0_144
        let s_0_145: Bits = ((s_0_134) & (s_0_144));
        // D s_0_146: or s_0_145 s_0_142
        let s_0_146: Bits = ((s_0_145) | (s_0_142));
        // D s_0_147: cast reint s_0_146 -> u64
        let s_0_147: u64 = (s_0_146.value() as u64);
        // D s_0_148: call Mk_ICC_SGI0R_Type(s_0_147)
        let s_0_148: ProductType5c790c8ef59cc8b2 = Mk_ICC_SGI0R_Type(
            state,
            tracer,
            s_0_147,
        );
        // D s_0_149: call ICC_SGI0R_write(s_0_148)
        let s_0_149: () = ICC_SGI0R_write(state, tracer, s_0_148);
        // C s_0_150: const #() : ()
        let s_0_150: () = ();
        // S s_0_151: call ICC_SGI0R_read(s_0_150)
        let s_0_151: ProductType5c790c8ef59cc8b2 = ICC_SGI0R_read(
            state,
            tracer,
            s_0_150,
        );
        // D s_0_152: write-var ga#34598 <= s_0_151
        fn_state.ga_34598 = s_0_151;
        // D s_0_153: read-var ga#34598.0:struct
        let s_0_153: u64 = fn_state.ga_34598._0;
        // C s_0_154: const #4s : i
        let s_0_154: i128 = 4;
        // C s_0_155: const #28s : i
        let s_0_155: i128 = 28;
        // D s_0_156: cast zx s_0_153 -> bv
        let s_0_156: Bits = Bits::new(s_0_153 as u128, 64u16);
        // C s_0_157: const #0u : u8
        let s_0_157: u8 = 0;
        // C s_0_158: cast zx s_0_157 -> bv
        let s_0_158: Bits = Bits::new(s_0_157 as u128, 4u16);
        // C s_0_159: const #1u : u64
        let s_0_159: u64 = 1;
        // C s_0_160: cast zx s_0_159 -> bv
        let s_0_160: Bits = Bits::new(s_0_159 as u128, 64u16);
        // C s_0_161: lsl s_0_160 s_0_154
        let s_0_161: Bits = s_0_160 << s_0_154;
        // C s_0_162: sub s_0_161 s_0_160
        let s_0_162: Bits = ((s_0_161) - (s_0_160));
        // C s_0_163: and s_0_158 s_0_162
        let s_0_163: Bits = ((s_0_158) & (s_0_162));
        // C s_0_164: lsl s_0_163 s_0_155
        let s_0_164: Bits = s_0_163 << s_0_155;
        // C s_0_165: lsl s_0_162 s_0_155
        let s_0_165: Bits = s_0_162 << s_0_155;
        // C s_0_166: cmpl s_0_165
        let s_0_166: Bits = !s_0_165;
        // D s_0_167: and s_0_156 s_0_166
        let s_0_167: Bits = ((s_0_156) & (s_0_166));
        // D s_0_168: or s_0_167 s_0_164
        let s_0_168: Bits = ((s_0_167) | (s_0_164));
        // D s_0_169: cast reint s_0_168 -> u64
        let s_0_169: u64 = (s_0_168.value() as u64);
        // D s_0_170: call Mk_ICC_SGI0R_Type(s_0_169)
        let s_0_170: ProductType5c790c8ef59cc8b2 = Mk_ICC_SGI0R_Type(
            state,
            tracer,
            s_0_169,
        );
        // D s_0_171: call ICC_SGI0R_write(s_0_170)
        let s_0_171: () = ICC_SGI0R_write(state, tracer, s_0_170);
        // C s_0_172: const #() : ()
        let s_0_172: () = ();
        // S s_0_173: call ICC_ASGI1R_read(s_0_172)
        let s_0_173: ProductType5c790c8ef59cc8b2 = ICC_ASGI1R_read(
            state,
            tracer,
            s_0_172,
        );
        // D s_0_174: write-var ga#34602 <= s_0_173
        fn_state.ga_34602 = s_0_173;
        // D s_0_175: read-var ga#34602.0:struct
        let s_0_175: u64 = fn_state.ga_34602._0;
        // C s_0_176: const #8s : i
        let s_0_176: i128 = 8;
        // C s_0_177: const #56s : i
        let s_0_177: i128 = 56;
        // D s_0_178: cast zx s_0_175 -> bv
        let s_0_178: Bits = Bits::new(s_0_175 as u128, 64u16);
        // C s_0_179: const #0u : u8
        let s_0_179: u8 = 0;
        // C s_0_180: cast zx s_0_179 -> bv
        let s_0_180: Bits = Bits::new(s_0_179 as u128, 8u16);
        // C s_0_181: const #1u : u64
        let s_0_181: u64 = 1;
        // C s_0_182: cast zx s_0_181 -> bv
        let s_0_182: Bits = Bits::new(s_0_181 as u128, 64u16);
        // C s_0_183: lsl s_0_182 s_0_176
        let s_0_183: Bits = s_0_182 << s_0_176;
        // C s_0_184: sub s_0_183 s_0_182
        let s_0_184: Bits = ((s_0_183) - (s_0_182));
        // C s_0_185: and s_0_180 s_0_184
        let s_0_185: Bits = ((s_0_180) & (s_0_184));
        // C s_0_186: lsl s_0_185 s_0_177
        let s_0_186: Bits = s_0_185 << s_0_177;
        // C s_0_187: lsl s_0_184 s_0_177
        let s_0_187: Bits = s_0_184 << s_0_177;
        // C s_0_188: cmpl s_0_187
        let s_0_188: Bits = !s_0_187;
        // D s_0_189: and s_0_178 s_0_188
        let s_0_189: Bits = ((s_0_178) & (s_0_188));
        // D s_0_190: or s_0_189 s_0_186
        let s_0_190: Bits = ((s_0_189) | (s_0_186));
        // D s_0_191: cast reint s_0_190 -> u64
        let s_0_191: u64 = (s_0_190.value() as u64);
        // D s_0_192: call Mk_ICC_ASGI1R_Type(s_0_191)
        let s_0_192: ProductType5c790c8ef59cc8b2 = Mk_ICC_ASGI1R_Type(
            state,
            tracer,
            s_0_191,
        );
        // D s_0_193: call ICC_ASGI1R_write(s_0_192)
        let s_0_193: () = ICC_ASGI1R_write(state, tracer, s_0_192);
        // C s_0_194: const #() : ()
        let s_0_194: () = ();
        // S s_0_195: call ICC_ASGI1R_read(s_0_194)
        let s_0_195: ProductType5c790c8ef59cc8b2 = ICC_ASGI1R_read(
            state,
            tracer,
            s_0_194,
        );
        // D s_0_196: write-var ga#34606 <= s_0_195
        fn_state.ga_34606 = s_0_195;
        // D s_0_197: read-var ga#34606.0:struct
        let s_0_197: u64 = fn_state.ga_34606._0;
        // C s_0_198: const #3s : i
        let s_0_198: i128 = 3;
        // C s_0_199: const #41s : i
        let s_0_199: i128 = 41;
        // D s_0_200: cast zx s_0_197 -> bv
        let s_0_200: Bits = Bits::new(s_0_197 as u128, 64u16);
        // C s_0_201: const #0u : u8
        let s_0_201: u8 = 0;
        // C s_0_202: cast zx s_0_201 -> bv
        let s_0_202: Bits = Bits::new(s_0_201 as u128, 3u16);
        // C s_0_203: const #1u : u64
        let s_0_203: u64 = 1;
        // C s_0_204: cast zx s_0_203 -> bv
        let s_0_204: Bits = Bits::new(s_0_203 as u128, 64u16);
        // C s_0_205: lsl s_0_204 s_0_198
        let s_0_205: Bits = s_0_204 << s_0_198;
        // C s_0_206: sub s_0_205 s_0_204
        let s_0_206: Bits = ((s_0_205) - (s_0_204));
        // C s_0_207: and s_0_202 s_0_206
        let s_0_207: Bits = ((s_0_202) & (s_0_206));
        // C s_0_208: lsl s_0_207 s_0_199
        let s_0_208: Bits = s_0_207 << s_0_199;
        // C s_0_209: lsl s_0_206 s_0_199
        let s_0_209: Bits = s_0_206 << s_0_199;
        // C s_0_210: cmpl s_0_209
        let s_0_210: Bits = !s_0_209;
        // D s_0_211: and s_0_200 s_0_210
        let s_0_211: Bits = ((s_0_200) & (s_0_210));
        // D s_0_212: or s_0_211 s_0_208
        let s_0_212: Bits = ((s_0_211) | (s_0_208));
        // D s_0_213: cast reint s_0_212 -> u64
        let s_0_213: u64 = (s_0_212.value() as u64);
        // D s_0_214: call Mk_ICC_ASGI1R_Type(s_0_213)
        let s_0_214: ProductType5c790c8ef59cc8b2 = Mk_ICC_ASGI1R_Type(
            state,
            tracer,
            s_0_213,
        );
        // D s_0_215: call ICC_ASGI1R_write(s_0_214)
        let s_0_215: () = ICC_ASGI1R_write(state, tracer, s_0_214);
        // C s_0_216: const #() : ()
        let s_0_216: () = ();
        // S s_0_217: call ICC_ASGI1R_read(s_0_216)
        let s_0_217: ProductType5c790c8ef59cc8b2 = ICC_ASGI1R_read(
            state,
            tracer,
            s_0_216,
        );
        // D s_0_218: write-var ga#34610 <= s_0_217
        fn_state.ga_34610 = s_0_217;
        // D s_0_219: read-var ga#34610.0:struct
        let s_0_219: u64 = fn_state.ga_34610._0;
        // C s_0_220: const #4s : i
        let s_0_220: i128 = 4;
        // C s_0_221: const #28s : i
        let s_0_221: i128 = 28;
        // D s_0_222: cast zx s_0_219 -> bv
        let s_0_222: Bits = Bits::new(s_0_219 as u128, 64u16);
        // C s_0_223: const #0u : u8
        let s_0_223: u8 = 0;
        // C s_0_224: cast zx s_0_223 -> bv
        let s_0_224: Bits = Bits::new(s_0_223 as u128, 4u16);
        // C s_0_225: const #1u : u64
        let s_0_225: u64 = 1;
        // C s_0_226: cast zx s_0_225 -> bv
        let s_0_226: Bits = Bits::new(s_0_225 as u128, 64u16);
        // C s_0_227: lsl s_0_226 s_0_220
        let s_0_227: Bits = s_0_226 << s_0_220;
        // C s_0_228: sub s_0_227 s_0_226
        let s_0_228: Bits = ((s_0_227) - (s_0_226));
        // C s_0_229: and s_0_224 s_0_228
        let s_0_229: Bits = ((s_0_224) & (s_0_228));
        // C s_0_230: lsl s_0_229 s_0_221
        let s_0_230: Bits = s_0_229 << s_0_221;
        // C s_0_231: lsl s_0_228 s_0_221
        let s_0_231: Bits = s_0_228 << s_0_221;
        // C s_0_232: cmpl s_0_231
        let s_0_232: Bits = !s_0_231;
        // D s_0_233: and s_0_222 s_0_232
        let s_0_233: Bits = ((s_0_222) & (s_0_232));
        // D s_0_234: or s_0_233 s_0_230
        let s_0_234: Bits = ((s_0_233) | (s_0_230));
        // D s_0_235: cast reint s_0_234 -> u64
        let s_0_235: u64 = (s_0_234.value() as u64);
        // D s_0_236: call Mk_ICC_ASGI1R_Type(s_0_235)
        let s_0_236: ProductType5c790c8ef59cc8b2 = Mk_ICC_ASGI1R_Type(
            state,
            tracer,
            s_0_235,
        );
        // D s_0_237: call ICC_ASGI1R_write(s_0_236)
        let s_0_237: () = ICC_ASGI1R_write(state, tracer, s_0_236);
        // C s_0_238: const #() : ()
        let s_0_238: () = ();
        // S s_0_239: call PAR_read(s_0_238)
        let s_0_239: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_238);
        // D s_0_240: write-var ga#34614 <= s_0_239
        fn_state.ga_34614 = s_0_239;
        // D s_0_241: read-var ga#34614.0:struct
        let s_0_241: u64 = fn_state.ga_34614._0;
        // C s_0_242: const #32s : i
        let s_0_242: i128 = 32;
        // C s_0_243: const #32s : i
        let s_0_243: i128 = 32;
        // D s_0_244: cast zx s_0_241 -> bv
        let s_0_244: Bits = Bits::new(s_0_241 as u128, 64u16);
        // C s_0_245: const #0u : u32
        let s_0_245: u32 = 0;
        // C s_0_246: cast zx s_0_245 -> bv
        let s_0_246: Bits = Bits::new(s_0_245 as u128, 32u16);
        // C s_0_247: const #1u : u64
        let s_0_247: u64 = 1;
        // C s_0_248: cast zx s_0_247 -> bv
        let s_0_248: Bits = Bits::new(s_0_247 as u128, 64u16);
        // C s_0_249: lsl s_0_248 s_0_242
        let s_0_249: Bits = s_0_248 << s_0_242;
        // C s_0_250: sub s_0_249 s_0_248
        let s_0_250: Bits = ((s_0_249) - (s_0_248));
        // C s_0_251: and s_0_246 s_0_250
        let s_0_251: Bits = ((s_0_246) & (s_0_250));
        // C s_0_252: lsl s_0_251 s_0_243
        let s_0_252: Bits = s_0_251 << s_0_243;
        // C s_0_253: lsl s_0_250 s_0_243
        let s_0_253: Bits = s_0_250 << s_0_243;
        // C s_0_254: cmpl s_0_253
        let s_0_254: Bits = !s_0_253;
        // D s_0_255: and s_0_244 s_0_254
        let s_0_255: Bits = ((s_0_244) & (s_0_254));
        // D s_0_256: or s_0_255 s_0_252
        let s_0_256: Bits = ((s_0_255) | (s_0_252));
        // D s_0_257: cast reint s_0_256 -> u64
        let s_0_257: u64 = (s_0_256.value() as u64);
        // D s_0_258: call Mk_PAR_Type(s_0_257)
        let s_0_258: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_257);
        // D s_0_259: call PAR_write(s_0_258)
        let s_0_259: () = PAR_write(state, tracer, s_0_258);
        // C s_0_260: const #() : ()
        let s_0_260: () = ();
        // S s_0_261: call PAR_read(s_0_260)
        let s_0_261: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_260);
        // D s_0_262: write-var ga#34618 <= s_0_261
        fn_state.ga_34618 = s_0_261;
        // D s_0_263: read-var ga#34618.0:struct
        let s_0_263: u64 = fn_state.ga_34618._0;
        // C s_0_264: const #32s : i
        let s_0_264: i128 = 32;
        // C s_0_265: const #32s : i
        let s_0_265: i128 = 32;
        // D s_0_266: cast zx s_0_263 -> bv
        let s_0_266: Bits = Bits::new(s_0_263 as u128, 64u16);
        // C s_0_267: const #0u : u32
        let s_0_267: u32 = 0;
        // C s_0_268: cast zx s_0_267 -> bv
        let s_0_268: Bits = Bits::new(s_0_267 as u128, 32u16);
        // C s_0_269: const #1u : u64
        let s_0_269: u64 = 1;
        // C s_0_270: cast zx s_0_269 -> bv
        let s_0_270: Bits = Bits::new(s_0_269 as u128, 64u16);
        // C s_0_271: lsl s_0_270 s_0_264
        let s_0_271: Bits = s_0_270 << s_0_264;
        // C s_0_272: sub s_0_271 s_0_270
        let s_0_272: Bits = ((s_0_271) - (s_0_270));
        // C s_0_273: and s_0_268 s_0_272
        let s_0_273: Bits = ((s_0_268) & (s_0_272));
        // C s_0_274: lsl s_0_273 s_0_265
        let s_0_274: Bits = s_0_273 << s_0_265;
        // C s_0_275: lsl s_0_272 s_0_265
        let s_0_275: Bits = s_0_272 << s_0_265;
        // C s_0_276: cmpl s_0_275
        let s_0_276: Bits = !s_0_275;
        // D s_0_277: and s_0_266 s_0_276
        let s_0_277: Bits = ((s_0_266) & (s_0_276));
        // D s_0_278: or s_0_277 s_0_274
        let s_0_278: Bits = ((s_0_277) | (s_0_274));
        // D s_0_279: cast reint s_0_278 -> u64
        let s_0_279: u64 = (s_0_278.value() as u64);
        // D s_0_280: call Mk_PAR_Type(s_0_279)
        let s_0_280: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_279);
        // D s_0_281: call PAR_write(s_0_280)
        let s_0_281: () = PAR_write(state, tracer, s_0_280);
        // C s_0_282: const #() : ()
        let s_0_282: () = ();
        // S s_0_283: call PAR_read(s_0_282)
        let s_0_283: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_282);
        // D s_0_284: write-var ga#34622 <= s_0_283
        fn_state.ga_34622 = s_0_283;
        // D s_0_285: read-var ga#34622.0:struct
        let s_0_285: u64 = fn_state.ga_34622._0;
        // C s_0_286: const #4s : i
        let s_0_286: i128 = 4;
        // C s_0_287: const #12s : i
        let s_0_287: i128 = 12;
        // D s_0_288: cast zx s_0_285 -> bv
        let s_0_288: Bits = Bits::new(s_0_285 as u128, 64u16);
        // C s_0_289: const #0u : u8
        let s_0_289: u8 = 0;
        // C s_0_290: cast zx s_0_289 -> bv
        let s_0_290: Bits = Bits::new(s_0_289 as u128, 4u16);
        // C s_0_291: const #1u : u64
        let s_0_291: u64 = 1;
        // C s_0_292: cast zx s_0_291 -> bv
        let s_0_292: Bits = Bits::new(s_0_291 as u128, 64u16);
        // C s_0_293: lsl s_0_292 s_0_286
        let s_0_293: Bits = s_0_292 << s_0_286;
        // C s_0_294: sub s_0_293 s_0_292
        let s_0_294: Bits = ((s_0_293) - (s_0_292));
        // C s_0_295: and s_0_290 s_0_294
        let s_0_295: Bits = ((s_0_290) & (s_0_294));
        // C s_0_296: lsl s_0_295 s_0_287
        let s_0_296: Bits = s_0_295 << s_0_287;
        // C s_0_297: lsl s_0_294 s_0_287
        let s_0_297: Bits = s_0_294 << s_0_287;
        // C s_0_298: cmpl s_0_297
        let s_0_298: Bits = !s_0_297;
        // D s_0_299: and s_0_288 s_0_298
        let s_0_299: Bits = ((s_0_288) & (s_0_298));
        // D s_0_300: or s_0_299 s_0_296
        let s_0_300: Bits = ((s_0_299) | (s_0_296));
        // D s_0_301: cast reint s_0_300 -> u64
        let s_0_301: u64 = (s_0_300.value() as u64);
        // D s_0_302: call Mk_PAR_Type(s_0_301)
        let s_0_302: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_301);
        // D s_0_303: call PAR_write(s_0_302)
        let s_0_303: () = PAR_write(state, tracer, s_0_302);
        // C s_0_304: const #() : ()
        let s_0_304: () = ();
        // S s_0_305: call PAR_read(s_0_304)
        let s_0_305: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_304);
        // D s_0_306: write-var ga#34626 <= s_0_305
        fn_state.ga_34626 = s_0_305;
        // D s_0_307: read-var ga#34626.0:struct
        let s_0_307: u64 = fn_state.ga_34626._0;
        // C s_0_308: const #4s : i
        let s_0_308: i128 = 4;
        // C s_0_309: const #7s : i
        let s_0_309: i128 = 7;
        // D s_0_310: cast zx s_0_307 -> bv
        let s_0_310: Bits = Bits::new(s_0_307 as u128, 64u16);
        // C s_0_311: const #0u : u8
        let s_0_311: u8 = 0;
        // C s_0_312: cast zx s_0_311 -> bv
        let s_0_312: Bits = Bits::new(s_0_311 as u128, 4u16);
        // C s_0_313: const #1u : u64
        let s_0_313: u64 = 1;
        // C s_0_314: cast zx s_0_313 -> bv
        let s_0_314: Bits = Bits::new(s_0_313 as u128, 64u16);
        // C s_0_315: lsl s_0_314 s_0_308
        let s_0_315: Bits = s_0_314 << s_0_308;
        // C s_0_316: sub s_0_315 s_0_314
        let s_0_316: Bits = ((s_0_315) - (s_0_314));
        // C s_0_317: and s_0_312 s_0_316
        let s_0_317: Bits = ((s_0_312) & (s_0_316));
        // C s_0_318: lsl s_0_317 s_0_309
        let s_0_318: Bits = s_0_317 << s_0_309;
        // C s_0_319: lsl s_0_316 s_0_309
        let s_0_319: Bits = s_0_316 << s_0_309;
        // C s_0_320: cmpl s_0_319
        let s_0_320: Bits = !s_0_319;
        // D s_0_321: and s_0_310 s_0_320
        let s_0_321: Bits = ((s_0_310) & (s_0_320));
        // D s_0_322: or s_0_321 s_0_318
        let s_0_322: Bits = ((s_0_321) | (s_0_318));
        // D s_0_323: cast reint s_0_322 -> u64
        let s_0_323: u64 = (s_0_322.value() as u64);
        // D s_0_324: call Mk_PAR_Type(s_0_323)
        let s_0_324: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_323);
        // D s_0_325: call PAR_write(s_0_324)
        let s_0_325: () = PAR_write(state, tracer, s_0_324);
        // C s_0_326: const #() : ()
        let s_0_326: () = ();
        // S s_0_327: call PAR_read(s_0_326)
        let s_0_327: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_326);
        // D s_0_328: write-var ga#34630 <= s_0_327
        fn_state.ga_34630 = s_0_327;
        // D s_0_329: read-var ga#34630.0:struct
        let s_0_329: u64 = fn_state.ga_34630._0;
        // C s_0_330: const #16s : i
        let s_0_330: i128 = 16;
        // C s_0_331: const #40s : i
        let s_0_331: i128 = 40;
        // D s_0_332: cast zx s_0_329 -> bv
        let s_0_332: Bits = Bits::new(s_0_329 as u128, 64u16);
        // C s_0_333: const #0u : u16
        let s_0_333: u16 = 0;
        // C s_0_334: cast zx s_0_333 -> bv
        let s_0_334: Bits = Bits::new(s_0_333 as u128, 16u16);
        // C s_0_335: const #1u : u64
        let s_0_335: u64 = 1;
        // C s_0_336: cast zx s_0_335 -> bv
        let s_0_336: Bits = Bits::new(s_0_335 as u128, 64u16);
        // C s_0_337: lsl s_0_336 s_0_330
        let s_0_337: Bits = s_0_336 << s_0_330;
        // C s_0_338: sub s_0_337 s_0_336
        let s_0_338: Bits = ((s_0_337) - (s_0_336));
        // C s_0_339: and s_0_334 s_0_338
        let s_0_339: Bits = ((s_0_334) & (s_0_338));
        // C s_0_340: lsl s_0_339 s_0_331
        let s_0_340: Bits = s_0_339 << s_0_331;
        // C s_0_341: lsl s_0_338 s_0_331
        let s_0_341: Bits = s_0_338 << s_0_331;
        // C s_0_342: cmpl s_0_341
        let s_0_342: Bits = !s_0_341;
        // D s_0_343: and s_0_332 s_0_342
        let s_0_343: Bits = ((s_0_332) & (s_0_342));
        // D s_0_344: or s_0_343 s_0_340
        let s_0_344: Bits = ((s_0_343) | (s_0_340));
        // D s_0_345: cast reint s_0_344 -> u64
        let s_0_345: u64 = (s_0_344.value() as u64);
        // D s_0_346: call Mk_PAR_Type(s_0_345)
        let s_0_346: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_345);
        // D s_0_347: call PAR_write(s_0_346)
        let s_0_347: () = PAR_write(state, tracer, s_0_346);
        // C s_0_348: const #() : ()
        let s_0_348: () = ();
        // S s_0_349: call PAR_read(s_0_348)
        let s_0_349: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_348);
        // D s_0_350: write-var ga#34634 <= s_0_349
        fn_state.ga_34634 = s_0_349;
        // D s_0_351: read-var ga#34634.0:struct
        let s_0_351: u64 = fn_state.ga_34634._0;
        // C s_0_352: const #6s : i
        let s_0_352: i128 = 6;
        // C s_0_353: const #1s : i
        let s_0_353: i128 = 1;
        // D s_0_354: cast zx s_0_351 -> bv
        let s_0_354: Bits = Bits::new(s_0_351 as u128, 64u16);
        // C s_0_355: const #0u : u8
        let s_0_355: u8 = 0;
        // C s_0_356: cast zx s_0_355 -> bv
        let s_0_356: Bits = Bits::new(s_0_355 as u128, 6u16);
        // C s_0_357: const #1u : u64
        let s_0_357: u64 = 1;
        // C s_0_358: cast zx s_0_357 -> bv
        let s_0_358: Bits = Bits::new(s_0_357 as u128, 64u16);
        // C s_0_359: lsl s_0_358 s_0_352
        let s_0_359: Bits = s_0_358 << s_0_352;
        // C s_0_360: sub s_0_359 s_0_358
        let s_0_360: Bits = ((s_0_359) - (s_0_358));
        // C s_0_361: and s_0_356 s_0_360
        let s_0_361: Bits = ((s_0_356) & (s_0_360));
        // C s_0_362: lsl s_0_361 s_0_353
        let s_0_362: Bits = s_0_361 << s_0_353;
        // C s_0_363: lsl s_0_360 s_0_353
        let s_0_363: Bits = s_0_360 << s_0_353;
        // C s_0_364: cmpl s_0_363
        let s_0_364: Bits = !s_0_363;
        // D s_0_365: and s_0_354 s_0_364
        let s_0_365: Bits = ((s_0_354) & (s_0_364));
        // D s_0_366: or s_0_365 s_0_362
        let s_0_366: Bits = ((s_0_365) | (s_0_362));
        // D s_0_367: cast reint s_0_366 -> u64
        let s_0_367: u64 = (s_0_366.value() as u64);
        // D s_0_368: call Mk_PAR_Type(s_0_367)
        let s_0_368: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_367);
        // D s_0_369: call PAR_write(s_0_368)
        let s_0_369: () = PAR_write(state, tracer, s_0_368);
        // C s_0_370: const #() : ()
        let s_0_370: () = ();
        // S s_0_371: call PAR_read(s_0_370)
        let s_0_371: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_370);
        // D s_0_372: write-var ga#34638 <= s_0_371
        fn_state.ga_34638 = s_0_371;
        // D s_0_373: read-var ga#34638.0:struct
        let s_0_373: u64 = fn_state.ga_34638._0;
        // C s_0_374: const #36s : i
        let s_0_374: i128 = 36;
        // C s_0_375: const #12s : i
        let s_0_375: i128 = 12;
        // D s_0_376: cast zx s_0_373 -> bv
        let s_0_376: Bits = Bits::new(s_0_373 as u128, 64u16);
        // C s_0_377: const #0u : u36
        let s_0_377: u64 = 0;
        // C s_0_378: cast zx s_0_377 -> bv
        let s_0_378: Bits = Bits::new(s_0_377 as u128, 36u16);
        // C s_0_379: const #1u : u64
        let s_0_379: u64 = 1;
        // C s_0_380: cast zx s_0_379 -> bv
        let s_0_380: Bits = Bits::new(s_0_379 as u128, 64u16);
        // C s_0_381: lsl s_0_380 s_0_374
        let s_0_381: Bits = s_0_380 << s_0_374;
        // C s_0_382: sub s_0_381 s_0_380
        let s_0_382: Bits = ((s_0_381) - (s_0_380));
        // C s_0_383: and s_0_378 s_0_382
        let s_0_383: Bits = ((s_0_378) & (s_0_382));
        // C s_0_384: lsl s_0_383 s_0_375
        let s_0_384: Bits = s_0_383 << s_0_375;
        // C s_0_385: lsl s_0_382 s_0_375
        let s_0_385: Bits = s_0_382 << s_0_375;
        // C s_0_386: cmpl s_0_385
        let s_0_386: Bits = !s_0_385;
        // D s_0_387: and s_0_376 s_0_386
        let s_0_387: Bits = ((s_0_376) & (s_0_386));
        // D s_0_388: or s_0_387 s_0_384
        let s_0_388: Bits = ((s_0_387) | (s_0_384));
        // D s_0_389: cast reint s_0_388 -> u64
        let s_0_389: u64 = (s_0_388.value() as u64);
        // D s_0_390: call Mk_PAR_Type(s_0_389)
        let s_0_390: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_389);
        // D s_0_391: call PAR_write(s_0_390)
        let s_0_391: () = PAR_write(state, tracer, s_0_390);
        // C s_0_392: const #() : ()
        let s_0_392: () = ();
        // S s_0_393: call PAR_read(s_0_392)
        let s_0_393: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_392);
        // D s_0_394: write-var ga#34642 <= s_0_393
        fn_state.ga_34642 = s_0_393;
        // D s_0_395: read-var ga#34642.0:struct
        let s_0_395: u64 = fn_state.ga_34642._0;
        // C s_0_396: const #1s : i
        let s_0_396: i128 = 1;
        // C s_0_397: const #10s : i
        let s_0_397: i128 = 10;
        // D s_0_398: cast zx s_0_395 -> bv
        let s_0_398: Bits = Bits::new(s_0_395 as u128, 64u16);
        // C s_0_399: const #0u : u8
        let s_0_399: bool = false;
        // C s_0_400: cast zx s_0_399 -> bv
        let s_0_400: Bits = Bits::new(s_0_399 as u128, 1u16);
        // C s_0_401: const #1u : u64
        let s_0_401: u64 = 1;
        // C s_0_402: cast zx s_0_401 -> bv
        let s_0_402: Bits = Bits::new(s_0_401 as u128, 64u16);
        // C s_0_403: lsl s_0_402 s_0_396
        let s_0_403: Bits = s_0_402 << s_0_396;
        // C s_0_404: sub s_0_403 s_0_402
        let s_0_404: Bits = ((s_0_403) - (s_0_402));
        // C s_0_405: and s_0_400 s_0_404
        let s_0_405: Bits = ((s_0_400) & (s_0_404));
        // C s_0_406: lsl s_0_405 s_0_397
        let s_0_406: Bits = s_0_405 << s_0_397;
        // C s_0_407: lsl s_0_404 s_0_397
        let s_0_407: Bits = s_0_404 << s_0_397;
        // C s_0_408: cmpl s_0_407
        let s_0_408: Bits = !s_0_407;
        // D s_0_409: and s_0_398 s_0_408
        let s_0_409: Bits = ((s_0_398) & (s_0_408));
        // D s_0_410: or s_0_409 s_0_406
        let s_0_410: Bits = ((s_0_409) | (s_0_406));
        // D s_0_411: cast reint s_0_410 -> u64
        let s_0_411: u64 = (s_0_410.value() as u64);
        // D s_0_412: call Mk_PAR_Type(s_0_411)
        let s_0_412: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_411);
        // D s_0_413: call PAR_write(s_0_412)
        let s_0_413: () = PAR_write(state, tracer, s_0_412);
        // C s_0_414: const #() : ()
        let s_0_414: () = ();
        // S s_0_415: call PAR_read(s_0_414)
        let s_0_415: ProductType5c790c8ef59cc8b2 = PAR_read(state, tracer, s_0_414);
        // D s_0_416: write-var ga#34646 <= s_0_415
        fn_state.ga_34646 = s_0_415;
        // D s_0_417: read-var ga#34646.0:struct
        let s_0_417: u64 = fn_state.ga_34646._0;
        // C s_0_418: const #1s : i
        let s_0_418: i128 = 1;
        // C s_0_419: const #7s : i
        let s_0_419: i128 = 7;
        // D s_0_420: cast zx s_0_417 -> bv
        let s_0_420: Bits = Bits::new(s_0_417 as u128, 64u16);
        // C s_0_421: const #0u : u8
        let s_0_421: bool = false;
        // C s_0_422: cast zx s_0_421 -> bv
        let s_0_422: Bits = Bits::new(s_0_421 as u128, 1u16);
        // C s_0_423: const #1u : u64
        let s_0_423: u64 = 1;
        // C s_0_424: cast zx s_0_423 -> bv
        let s_0_424: Bits = Bits::new(s_0_423 as u128, 64u16);
        // C s_0_425: lsl s_0_424 s_0_418
        let s_0_425: Bits = s_0_424 << s_0_418;
        // C s_0_426: sub s_0_425 s_0_424
        let s_0_426: Bits = ((s_0_425) - (s_0_424));
        // C s_0_427: and s_0_422 s_0_426
        let s_0_427: Bits = ((s_0_422) & (s_0_426));
        // C s_0_428: lsl s_0_427 s_0_419
        let s_0_428: Bits = s_0_427 << s_0_419;
        // C s_0_429: lsl s_0_426 s_0_419
        let s_0_429: Bits = s_0_426 << s_0_419;
        // C s_0_430: cmpl s_0_429
        let s_0_430: Bits = !s_0_429;
        // D s_0_431: and s_0_420 s_0_430
        let s_0_431: Bits = ((s_0_420) & (s_0_430));
        // D s_0_432: or s_0_431 s_0_428
        let s_0_432: Bits = ((s_0_431) | (s_0_428));
        // D s_0_433: cast reint s_0_432 -> u64
        let s_0_433: u64 = (s_0_432.value() as u64);
        // D s_0_434: call Mk_PAR_Type(s_0_433)
        let s_0_434: ProductType5c790c8ef59cc8b2 = Mk_PAR_Type(state, tracer, s_0_433);
        // D s_0_435: call PAR_write(s_0_434)
        let s_0_435: () = PAR_write(state, tracer, s_0_434);
        // C s_0_436: const #() : ()
        let s_0_436: () = ();
        // S s_0_437: call TTBR1_read(s_0_436)
        let s_0_437: ProductType5c790c8ef59cc8b2 = TTBR1_read(state, tracer, s_0_436);
        // D s_0_438: write-var ga#34650 <= s_0_437
        fn_state.ga_34650 = s_0_437;
        // D s_0_439: read-var ga#34650.0:struct
        let s_0_439: u64 = fn_state.ga_34650._0;
        // C s_0_440: const #32s : i
        let s_0_440: i128 = 32;
        // C s_0_441: const #32s : i
        let s_0_441: i128 = 32;
        // D s_0_442: cast zx s_0_439 -> bv
        let s_0_442: Bits = Bits::new(s_0_439 as u128, 64u16);
        // C s_0_443: const #0u : u32
        let s_0_443: u32 = 0;
        // C s_0_444: cast zx s_0_443 -> bv
        let s_0_444: Bits = Bits::new(s_0_443 as u128, 32u16);
        // C s_0_445: const #1u : u64
        let s_0_445: u64 = 1;
        // C s_0_446: cast zx s_0_445 -> bv
        let s_0_446: Bits = Bits::new(s_0_445 as u128, 64u16);
        // C s_0_447: lsl s_0_446 s_0_440
        let s_0_447: Bits = s_0_446 << s_0_440;
        // C s_0_448: sub s_0_447 s_0_446
        let s_0_448: Bits = ((s_0_447) - (s_0_446));
        // C s_0_449: and s_0_444 s_0_448
        let s_0_449: Bits = ((s_0_444) & (s_0_448));
        // C s_0_450: lsl s_0_449 s_0_441
        let s_0_450: Bits = s_0_449 << s_0_441;
        // C s_0_451: lsl s_0_448 s_0_441
        let s_0_451: Bits = s_0_448 << s_0_441;
        // C s_0_452: cmpl s_0_451
        let s_0_452: Bits = !s_0_451;
        // D s_0_453: and s_0_442 s_0_452
        let s_0_453: Bits = ((s_0_442) & (s_0_452));
        // D s_0_454: or s_0_453 s_0_450
        let s_0_454: Bits = ((s_0_453) | (s_0_450));
        // D s_0_455: cast reint s_0_454 -> u64
        let s_0_455: u64 = (s_0_454.value() as u64);
        // D s_0_456: call Mk_TTBR1_Type(s_0_455)
        let s_0_456: ProductType5c790c8ef59cc8b2 = Mk_TTBR1_Type(state, tracer, s_0_455);
        // D s_0_457: call TTBR1_write(s_0_456)
        let s_0_457: () = TTBR1_write(state, tracer, s_0_456);
        // C s_0_458: const #() : ()
        let s_0_458: () = ();
        // S s_0_459: call TTBR1_read(s_0_458)
        let s_0_459: ProductType5c790c8ef59cc8b2 = TTBR1_read(state, tracer, s_0_458);
        // D s_0_460: write-var ga#34654 <= s_0_459
        fn_state.ga_34654 = s_0_459;
        // D s_0_461: read-var ga#34654.0:struct
        let s_0_461: u64 = fn_state.ga_34654._0;
        // C s_0_462: const #8s : i
        let s_0_462: i128 = 8;
        // C s_0_463: const #56s : i
        let s_0_463: i128 = 56;
        // D s_0_464: cast zx s_0_461 -> bv
        let s_0_464: Bits = Bits::new(s_0_461 as u128, 64u16);
        // C s_0_465: const #0u : u8
        let s_0_465: u8 = 0;
        // C s_0_466: cast zx s_0_465 -> bv
        let s_0_466: Bits = Bits::new(s_0_465 as u128, 8u16);
        // C s_0_467: const #1u : u64
        let s_0_467: u64 = 1;
        // C s_0_468: cast zx s_0_467 -> bv
        let s_0_468: Bits = Bits::new(s_0_467 as u128, 64u16);
        // C s_0_469: lsl s_0_468 s_0_462
        let s_0_469: Bits = s_0_468 << s_0_462;
        // C s_0_470: sub s_0_469 s_0_468
        let s_0_470: Bits = ((s_0_469) - (s_0_468));
        // C s_0_471: and s_0_466 s_0_470
        let s_0_471: Bits = ((s_0_466) & (s_0_470));
        // C s_0_472: lsl s_0_471 s_0_463
        let s_0_472: Bits = s_0_471 << s_0_463;
        // C s_0_473: lsl s_0_470 s_0_463
        let s_0_473: Bits = s_0_470 << s_0_463;
        // C s_0_474: cmpl s_0_473
        let s_0_474: Bits = !s_0_473;
        // D s_0_475: and s_0_464 s_0_474
        let s_0_475: Bits = ((s_0_464) & (s_0_474));
        // D s_0_476: or s_0_475 s_0_472
        let s_0_476: Bits = ((s_0_475) | (s_0_472));
        // D s_0_477: cast reint s_0_476 -> u64
        let s_0_477: u64 = (s_0_476.value() as u64);
        // D s_0_478: call Mk_TTBR1_Type(s_0_477)
        let s_0_478: ProductType5c790c8ef59cc8b2 = Mk_TTBR1_Type(state, tracer, s_0_477);
        // D s_0_479: call TTBR1_write(s_0_478)
        let s_0_479: () = TTBR1_write(state, tracer, s_0_478);
        // C s_0_480: const #14824u : u32
        let s_0_480: u32 = 14824;
        // D s_0_481: read-reg s_0_480:struct
        let s_0_481: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_0_480 as isize);
            tracer.read_register(s_0_480 as isize, value);
            value
        };
        // C s_0_482: const #14824u : u32
        let s_0_482: u32 = 14824;
        // N s_0_483: write-reg s_0_482 <= s_0_481
        let s_0_483: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_0_482 as isize, s_0_481);
            tracer.write_register(s_0_482 as isize, s_0_481);
        };
        // C s_0_484: const #() : ()
        let s_0_484: () = ();
        // S s_0_485: call TTBR0_read(s_0_484)
        let s_0_485: ProductType5c790c8ef59cc8b2 = TTBR0_read(state, tracer, s_0_484);
        // D s_0_486: write-var ga#34660 <= s_0_485
        fn_state.ga_34660 = s_0_485;
        // D s_0_487: read-var ga#34660.0:struct
        let s_0_487: u64 = fn_state.ga_34660._0;
        // C s_0_488: const #32s : i
        let s_0_488: i128 = 32;
        // C s_0_489: const #32s : i
        let s_0_489: i128 = 32;
        // D s_0_490: cast zx s_0_487 -> bv
        let s_0_490: Bits = Bits::new(s_0_487 as u128, 64u16);
        // C s_0_491: const #0u : u32
        let s_0_491: u32 = 0;
        // C s_0_492: cast zx s_0_491 -> bv
        let s_0_492: Bits = Bits::new(s_0_491 as u128, 32u16);
        // C s_0_493: const #1u : u64
        let s_0_493: u64 = 1;
        // C s_0_494: cast zx s_0_493 -> bv
        let s_0_494: Bits = Bits::new(s_0_493 as u128, 64u16);
        // C s_0_495: lsl s_0_494 s_0_488
        let s_0_495: Bits = s_0_494 << s_0_488;
        // C s_0_496: sub s_0_495 s_0_494
        let s_0_496: Bits = ((s_0_495) - (s_0_494));
        // C s_0_497: and s_0_492 s_0_496
        let s_0_497: Bits = ((s_0_492) & (s_0_496));
        // C s_0_498: lsl s_0_497 s_0_489
        let s_0_498: Bits = s_0_497 << s_0_489;
        // C s_0_499: lsl s_0_496 s_0_489
        let s_0_499: Bits = s_0_496 << s_0_489;
        // C s_0_500: cmpl s_0_499
        let s_0_500: Bits = !s_0_499;
        // D s_0_501: and s_0_490 s_0_500
        let s_0_501: Bits = ((s_0_490) & (s_0_500));
        // D s_0_502: or s_0_501 s_0_498
        let s_0_502: Bits = ((s_0_501) | (s_0_498));
        // D s_0_503: cast reint s_0_502 -> u64
        let s_0_503: u64 = (s_0_502.value() as u64);
        // D s_0_504: call Mk_TTBR0_Type(s_0_503)
        let s_0_504: ProductType5c790c8ef59cc8b2 = Mk_TTBR0_Type(state, tracer, s_0_503);
        // D s_0_505: call TTBR0_write(s_0_504)
        let s_0_505: () = TTBR0_write(state, tracer, s_0_504);
        // C s_0_506: const #() : ()
        let s_0_506: () = ();
        // S s_0_507: call TTBR0_read(s_0_506)
        let s_0_507: ProductType5c790c8ef59cc8b2 = TTBR0_read(state, tracer, s_0_506);
        // D s_0_508: write-var ga#34664 <= s_0_507
        fn_state.ga_34664 = s_0_507;
        // D s_0_509: read-var ga#34664.0:struct
        let s_0_509: u64 = fn_state.ga_34664._0;
        // C s_0_510: const #8s : i
        let s_0_510: i128 = 8;
        // C s_0_511: const #56s : i
        let s_0_511: i128 = 56;
        // D s_0_512: cast zx s_0_509 -> bv
        let s_0_512: Bits = Bits::new(s_0_509 as u128, 64u16);
        // C s_0_513: const #0u : u8
        let s_0_513: u8 = 0;
        // C s_0_514: cast zx s_0_513 -> bv
        let s_0_514: Bits = Bits::new(s_0_513 as u128, 8u16);
        // C s_0_515: const #1u : u64
        let s_0_515: u64 = 1;
        // C s_0_516: cast zx s_0_515 -> bv
        let s_0_516: Bits = Bits::new(s_0_515 as u128, 64u16);
        // C s_0_517: lsl s_0_516 s_0_510
        let s_0_517: Bits = s_0_516 << s_0_510;
        // C s_0_518: sub s_0_517 s_0_516
        let s_0_518: Bits = ((s_0_517) - (s_0_516));
        // C s_0_519: and s_0_514 s_0_518
        let s_0_519: Bits = ((s_0_514) & (s_0_518));
        // C s_0_520: lsl s_0_519 s_0_511
        let s_0_520: Bits = s_0_519 << s_0_511;
        // C s_0_521: lsl s_0_518 s_0_511
        let s_0_521: Bits = s_0_518 << s_0_511;
        // C s_0_522: cmpl s_0_521
        let s_0_522: Bits = !s_0_521;
        // D s_0_523: and s_0_512 s_0_522
        let s_0_523: Bits = ((s_0_512) & (s_0_522));
        // D s_0_524: or s_0_523 s_0_520
        let s_0_524: Bits = ((s_0_523) | (s_0_520));
        // D s_0_525: cast reint s_0_524 -> u64
        let s_0_525: u64 = (s_0_524.value() as u64);
        // D s_0_526: call Mk_TTBR0_Type(s_0_525)
        let s_0_526: ProductType5c790c8ef59cc8b2 = Mk_TTBR0_Type(state, tracer, s_0_525);
        // D s_0_527: call TTBR0_write(s_0_526)
        let s_0_527: () = TTBR0_write(state, tracer, s_0_526);
        // C s_0_528: const #() : ()
        let s_0_528: () = ();
        // S s_0_529: call DBGDRAR_read(s_0_528)
        let s_0_529: ProductType5c790c8ef59cc8b2 = DBGDRAR_read(state, tracer, s_0_528);
        // D s_0_530: write-var ga#34668 <= s_0_529
        fn_state.ga_34668 = s_0_529;
        // D s_0_531: read-var ga#34668.0:struct
        let s_0_531: u64 = fn_state.ga_34668._0;
        // C s_0_532: const #16s : i
        let s_0_532: i128 = 16;
        // C s_0_533: const #48s : i
        let s_0_533: i128 = 48;
        // D s_0_534: cast zx s_0_531 -> bv
        let s_0_534: Bits = Bits::new(s_0_531 as u128, 64u16);
        // C s_0_535: const #0u : u16
        let s_0_535: u16 = 0;
        // C s_0_536: cast zx s_0_535 -> bv
        let s_0_536: Bits = Bits::new(s_0_535 as u128, 16u16);
        // C s_0_537: const #1u : u64
        let s_0_537: u64 = 1;
        // C s_0_538: cast zx s_0_537 -> bv
        let s_0_538: Bits = Bits::new(s_0_537 as u128, 64u16);
        // C s_0_539: lsl s_0_538 s_0_532
        let s_0_539: Bits = s_0_538 << s_0_532;
        // C s_0_540: sub s_0_539 s_0_538
        let s_0_540: Bits = ((s_0_539) - (s_0_538));
        // C s_0_541: and s_0_536 s_0_540
        let s_0_541: Bits = ((s_0_536) & (s_0_540));
        // C s_0_542: lsl s_0_541 s_0_533
        let s_0_542: Bits = s_0_541 << s_0_533;
        // C s_0_543: lsl s_0_540 s_0_533
        let s_0_543: Bits = s_0_540 << s_0_533;
        // C s_0_544: cmpl s_0_543
        let s_0_544: Bits = !s_0_543;
        // D s_0_545: and s_0_534 s_0_544
        let s_0_545: Bits = ((s_0_534) & (s_0_544));
        // D s_0_546: or s_0_545 s_0_542
        let s_0_546: Bits = ((s_0_545) | (s_0_542));
        // D s_0_547: cast reint s_0_546 -> u64
        let s_0_547: u64 = (s_0_546.value() as u64);
        // D s_0_548: call Mk_DBGDRAR_Type(s_0_547)
        let s_0_548: ProductType5c790c8ef59cc8b2 = Mk_DBGDRAR_Type(
            state,
            tracer,
            s_0_547,
        );
        // D s_0_549: call DBGDRAR_write(s_0_548)
        let s_0_549: () = DBGDRAR_write(state, tracer, s_0_548);
        // C s_0_550: const #() : ()
        let s_0_550: () = ();
        // S s_0_551: call DBGDRAR_read(s_0_550)
        let s_0_551: ProductType5c790c8ef59cc8b2 = DBGDRAR_read(state, tracer, s_0_550);
        // D s_0_552: write-var ga#34672 <= s_0_551
        fn_state.ga_34672 = s_0_551;
        // D s_0_553: read-var ga#34672.0:struct
        let s_0_553: u64 = fn_state.ga_34672._0;
        // C s_0_554: const #10s : i
        let s_0_554: i128 = 10;
        // C s_0_555: const #2s : i
        let s_0_555: i128 = 2;
        // D s_0_556: cast zx s_0_553 -> bv
        let s_0_556: Bits = Bits::new(s_0_553 as u128, 64u16);
        // C s_0_557: const #0u : u10
        let s_0_557: u16 = 0;
        // C s_0_558: cast zx s_0_557 -> bv
        let s_0_558: Bits = Bits::new(s_0_557 as u128, 10u16);
        // C s_0_559: const #1u : u64
        let s_0_559: u64 = 1;
        // C s_0_560: cast zx s_0_559 -> bv
        let s_0_560: Bits = Bits::new(s_0_559 as u128, 64u16);
        // C s_0_561: lsl s_0_560 s_0_554
        let s_0_561: Bits = s_0_560 << s_0_554;
        // C s_0_562: sub s_0_561 s_0_560
        let s_0_562: Bits = ((s_0_561) - (s_0_560));
        // C s_0_563: and s_0_558 s_0_562
        let s_0_563: Bits = ((s_0_558) & (s_0_562));
        // C s_0_564: lsl s_0_563 s_0_555
        let s_0_564: Bits = s_0_563 << s_0_555;
        // C s_0_565: lsl s_0_562 s_0_555
        let s_0_565: Bits = s_0_562 << s_0_555;
        // C s_0_566: cmpl s_0_565
        let s_0_566: Bits = !s_0_565;
        // D s_0_567: and s_0_556 s_0_566
        let s_0_567: Bits = ((s_0_556) & (s_0_566));
        // D s_0_568: or s_0_567 s_0_564
        let s_0_568: Bits = ((s_0_567) | (s_0_564));
        // D s_0_569: cast reint s_0_568 -> u64
        let s_0_569: u64 = (s_0_568.value() as u64);
        // D s_0_570: call Mk_DBGDRAR_Type(s_0_569)
        let s_0_570: ProductType5c790c8ef59cc8b2 = Mk_DBGDRAR_Type(
            state,
            tracer,
            s_0_569,
        );
        // D s_0_571: call DBGDRAR_write(s_0_570)
        let s_0_571: () = DBGDRAR_write(state, tracer, s_0_570);
        // C s_0_572: const #22408u : u32
        let s_0_572: u32 = 22408;
        // D s_0_573: read-reg s_0_572:struct
        let s_0_573: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_0_572 as isize);
            tracer.read_register(s_0_572 as isize, value);
            value
        };
        // C s_0_574: const #22408u : u32
        let s_0_574: u32 = 22408;
        // N s_0_575: write-reg s_0_574 <= s_0_573
        let s_0_575: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_0_574 as isize, s_0_573);
            tracer.write_register(s_0_574 as isize, s_0_573);
        };
        // D s_0_576: read-var cold:u8
        let s_0_576: bool = fn_state.cold;
        // D s_0_577: not s_0_576
        let s_0_577: bool = !s_0_576;
        // N s_0_578: branch s_0_577 b651 b1
        if s_0_577 {
            return block_651(state, tracer, fn_state);
        } else {
            return block_1(state, tracer, fn_state);
        };
    }
    fn block_1<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1_0: const #0u : u8
        let s_1_0: bool = false;
        // D s_1_1: write-var gs#43736 <= s_1_0
        fn_state.gs_43736 = s_1_0;
        // N s_1_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_2<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2_0: read-var gs#43736:u8
        let s_2_0: bool = fn_state.gs_43736;
        // N s_2_1: branch s_2_0 b650 b3
        if s_2_0 {
            return block_650(state, tracer, fn_state);
        } else {
            return block_3(state, tracer, fn_state);
        };
    }
    fn block_3<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3_0: const #8s : i64
        let s_3_0: i64 = 8;
        // C s_3_1: cast zx s_3_0 -> i
        let s_3_1: i128 = (i128::try_from(s_3_0).unwrap());
        // S s_3_2: call __UNKNOWN_bits(s_3_1)
        let s_3_2: Bits = u__UNKNOWN_bits(state, tracer, s_3_1);
        // C s_3_3: const #22408u : u32
        let s_3_3: u32 = 22408;
        // D s_3_4: read-reg s_3_3:struct
        let s_3_4: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_3_3 as isize);
            tracer.read_register(s_3_3 as isize, value);
            value
        };
        // C s_3_5: const #22408u : u32
        let s_3_5: u32 = 22408;
        // N s_3_6: write-reg s_3_5 <= s_3_4
        let s_3_6: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_3_5 as isize, s_3_4);
            tracer.write_register(s_3_5 as isize, s_3_4);
        };
        // N s_3_7: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_4<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_4_0: const #14976u : u32
        let s_4_0: u32 = 14976;
        // D s_4_1: read-reg s_4_0:struct
        let s_4_1: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_0 as isize);
            tracer.read_register(s_4_0 as isize, value);
            value
        };
        // C s_4_2: const #14976u : u32
        let s_4_2: u32 = 14976;
        // N s_4_3: write-reg s_4_2 <= s_4_1
        let s_4_3: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_2 as isize, s_4_1);
            tracer.write_register(s_4_2 as isize, s_4_1);
        };
        // C s_4_4: const #14976u : u32
        let s_4_4: u32 = 14976;
        // D s_4_5: read-reg s_4_4:struct
        let s_4_5: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_4 as isize);
            tracer.read_register(s_4_4 as isize, value);
            value
        };
        // C s_4_6: const #14976u : u32
        let s_4_6: u32 = 14976;
        // N s_4_7: write-reg s_4_6 <= s_4_5
        let s_4_7: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_6 as isize, s_4_5);
            tracer.write_register(s_4_6 as isize, s_4_5);
        };
        // C s_4_8: const #0u : u8
        let s_4_8: bool = false;
        // S s_4_9: call Bit(s_4_8)
        let s_4_9: bool = Bit(state, tracer, s_4_8);
        // C s_4_10: const #15496u : u32
        let s_4_10: u32 = 15496;
        // D s_4_11: read-reg s_4_10:struct
        let s_4_11: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_10 as isize);
            tracer.read_register(s_4_10 as isize, value);
            value
        };
        // C s_4_12: const #15496u : u32
        let s_4_12: u32 = 15496;
        // N s_4_13: write-reg s_4_12 <= s_4_11
        let s_4_13: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_12 as isize, s_4_11);
            tracer.write_register(s_4_12 as isize, s_4_11);
        };
        // C s_4_14: const #15496u : u32
        let s_4_14: u32 = 15496;
        // D s_4_15: read-reg s_4_14:struct
        let s_4_15: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_14 as isize);
            tracer.read_register(s_4_14 as isize, value);
            value
        };
        // C s_4_16: const #15496u : u32
        let s_4_16: u32 = 15496;
        // N s_4_17: write-reg s_4_16 <= s_4_15
        let s_4_17: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_16 as isize, s_4_15);
            tracer.write_register(s_4_16 as isize, s_4_15);
        };
        // C s_4_18: const #15496u : u32
        let s_4_18: u32 = 15496;
        // D s_4_19: read-reg s_4_18:struct
        let s_4_19: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_18 as isize);
            tracer.read_register(s_4_18 as isize, value);
            value
        };
        // C s_4_20: const #15496u : u32
        let s_4_20: u32 = 15496;
        // N s_4_21: write-reg s_4_20 <= s_4_19
        let s_4_21: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_20 as isize, s_4_19);
            tracer.write_register(s_4_20 as isize, s_4_19);
        };
        // C s_4_22: const #15496u : u32
        let s_4_22: u32 = 15496;
        // D s_4_23: read-reg s_4_22:struct
        let s_4_23: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_22 as isize);
            tracer.read_register(s_4_22 as isize, value);
            value
        };
        // C s_4_24: const #15496u : u32
        let s_4_24: u32 = 15496;
        // N s_4_25: write-reg s_4_24 <= s_4_23
        let s_4_25: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_24 as isize, s_4_23);
            tracer.write_register(s_4_24 as isize, s_4_23);
        };
        // C s_4_26: const #15496u : u32
        let s_4_26: u32 = 15496;
        // D s_4_27: read-reg s_4_26:struct
        let s_4_27: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_26 as isize);
            tracer.read_register(s_4_26 as isize, value);
            value
        };
        // C s_4_28: const #15496u : u32
        let s_4_28: u32 = 15496;
        // N s_4_29: write-reg s_4_28 <= s_4_27
        let s_4_29: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_28 as isize, s_4_27);
            tracer.write_register(s_4_28 as isize, s_4_27);
        };
        // C s_4_30: const #101784u : u32
        let s_4_30: u32 = 101784;
        // D s_4_31: read-reg s_4_30:struct
        let s_4_31: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_30 as isize);
            tracer.read_register(s_4_30 as isize, value);
            value
        };
        // C s_4_32: const #101784u : u32
        let s_4_32: u32 = 101784;
        // N s_4_33: write-reg s_4_32 <= s_4_31
        let s_4_33: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_32 as isize, s_4_31);
            tracer.write_register(s_4_32 as isize, s_4_31);
        };
        // C s_4_34: const #101784u : u32
        let s_4_34: u32 = 101784;
        // D s_4_35: read-reg s_4_34:struct
        let s_4_35: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_34 as isize);
            tracer.read_register(s_4_34 as isize, value);
            value
        };
        // C s_4_36: const #101784u : u32
        let s_4_36: u32 = 101784;
        // N s_4_37: write-reg s_4_36 <= s_4_35
        let s_4_37: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_36 as isize, s_4_35);
            tracer.write_register(s_4_36 as isize, s_4_35);
        };
        // C s_4_38: const #101784u : u32
        let s_4_38: u32 = 101784;
        // D s_4_39: read-reg s_4_38:struct
        let s_4_39: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_38 as isize);
            tracer.read_register(s_4_38 as isize, value);
            value
        };
        // C s_4_40: const #101784u : u32
        let s_4_40: u32 = 101784;
        // N s_4_41: write-reg s_4_40 <= s_4_39
        let s_4_41: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_40 as isize, s_4_39);
            tracer.write_register(s_4_40 as isize, s_4_39);
        };
        // C s_4_42: const #20184u : u32
        let s_4_42: u32 = 20184;
        // D s_4_43: read-reg s_4_42:struct
        let s_4_43: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_42 as isize);
            tracer.read_register(s_4_42 as isize, value);
            value
        };
        // C s_4_44: const #20184u : u32
        let s_4_44: u32 = 20184;
        // N s_4_45: write-reg s_4_44 <= s_4_43
        let s_4_45: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_44 as isize, s_4_43);
            tracer.write_register(s_4_44 as isize, s_4_43);
        };
        // C s_4_46: const #0u : u8
        let s_4_46: bool = false;
        // S s_4_47: call Bit(s_4_46)
        let s_4_47: bool = Bit(state, tracer, s_4_46);
        // C s_4_48: const #20184u : u32
        let s_4_48: u32 = 20184;
        // D s_4_49: read-reg s_4_48:struct
        let s_4_49: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_48 as isize);
            tracer.read_register(s_4_48 as isize, value);
            value
        };
        // C s_4_50: const #20184u : u32
        let s_4_50: u32 = 20184;
        // N s_4_51: write-reg s_4_50 <= s_4_49
        let s_4_51: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_50 as isize, s_4_49);
            tracer.write_register(s_4_50 as isize, s_4_49);
        };
        // C s_4_52: const #20184u : u32
        let s_4_52: u32 = 20184;
        // D s_4_53: read-reg s_4_52:struct
        let s_4_53: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_52 as isize);
            tracer.read_register(s_4_52 as isize, value);
            value
        };
        // C s_4_54: const #20184u : u32
        let s_4_54: u32 = 20184;
        // N s_4_55: write-reg s_4_54 <= s_4_53
        let s_4_55: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_54 as isize, s_4_53);
            tracer.write_register(s_4_54 as isize, s_4_53);
        };
        // C s_4_56: const #20184u : u32
        let s_4_56: u32 = 20184;
        // D s_4_57: read-reg s_4_56:struct
        let s_4_57: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_56 as isize);
            tracer.read_register(s_4_56 as isize, value);
            value
        };
        // C s_4_58: const #20184u : u32
        let s_4_58: u32 = 20184;
        // N s_4_59: write-reg s_4_58 <= s_4_57
        let s_4_59: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_58 as isize, s_4_57);
            tracer.write_register(s_4_58 as isize, s_4_57);
        };
        // C s_4_60: const #20184u : u32
        let s_4_60: u32 = 20184;
        // D s_4_61: read-reg s_4_60:struct
        let s_4_61: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_60 as isize);
            tracer.read_register(s_4_60 as isize, value);
            value
        };
        // C s_4_62: const #20184u : u32
        let s_4_62: u32 = 20184;
        // N s_4_63: write-reg s_4_62 <= s_4_61
        let s_4_63: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_62 as isize, s_4_61);
            tracer.write_register(s_4_62 as isize, s_4_61);
        };
        // C s_4_64: const #15424u : u32
        let s_4_64: u32 = 15424;
        // D s_4_65: read-reg s_4_64:struct
        let s_4_65: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_64 as isize);
            tracer.read_register(s_4_64 as isize, value);
            value
        };
        // C s_4_66: const #15424u : u32
        let s_4_66: u32 = 15424;
        // N s_4_67: write-reg s_4_66 <= s_4_65
        let s_4_67: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_66 as isize, s_4_65);
            tracer.write_register(s_4_66 as isize, s_4_65);
        };
        // C s_4_68: const #15424u : u32
        let s_4_68: u32 = 15424;
        // D s_4_69: read-reg s_4_68:struct
        let s_4_69: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_68 as isize);
            tracer.read_register(s_4_68 as isize, value);
            value
        };
        // C s_4_70: const #15424u : u32
        let s_4_70: u32 = 15424;
        // N s_4_71: write-reg s_4_70 <= s_4_69
        let s_4_71: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_70 as isize, s_4_69);
            tracer.write_register(s_4_70 as isize, s_4_69);
        };
        // C s_4_72: const #15424u : u32
        let s_4_72: u32 = 15424;
        // D s_4_73: read-reg s_4_72:struct
        let s_4_73: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_72 as isize);
            tracer.read_register(s_4_72 as isize, value);
            value
        };
        // C s_4_74: const #15424u : u32
        let s_4_74: u32 = 15424;
        // N s_4_75: write-reg s_4_74 <= s_4_73
        let s_4_75: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_74 as isize, s_4_73);
            tracer.write_register(s_4_74 as isize, s_4_73);
        };
        // C s_4_76: const #15424u : u32
        let s_4_76: u32 = 15424;
        // D s_4_77: read-reg s_4_76:struct
        let s_4_77: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_76 as isize);
            tracer.read_register(s_4_76 as isize, value);
            value
        };
        // C s_4_78: const #15424u : u32
        let s_4_78: u32 = 15424;
        // N s_4_79: write-reg s_4_78 <= s_4_77
        let s_4_79: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_78 as isize, s_4_77);
            tracer.write_register(s_4_78 as isize, s_4_77);
        };
        // C s_4_80: const #15424u : u32
        let s_4_80: u32 = 15424;
        // D s_4_81: read-reg s_4_80:struct
        let s_4_81: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_80 as isize);
            tracer.read_register(s_4_80 as isize, value);
            value
        };
        // C s_4_82: const #15424u : u32
        let s_4_82: u32 = 15424;
        // N s_4_83: write-reg s_4_82 <= s_4_81
        let s_4_83: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_82 as isize, s_4_81);
            tracer.write_register(s_4_82 as isize, s_4_81);
        };
        // C s_4_84: const #15424u : u32
        let s_4_84: u32 = 15424;
        // D s_4_85: read-reg s_4_84:struct
        let s_4_85: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_84 as isize);
            tracer.read_register(s_4_84 as isize, value);
            value
        };
        // C s_4_86: const #15424u : u32
        let s_4_86: u32 = 15424;
        // N s_4_87: write-reg s_4_86 <= s_4_85
        let s_4_87: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_86 as isize, s_4_85);
            tracer.write_register(s_4_86 as isize, s_4_85);
        };
        // C s_4_88: const #14408u : u32
        let s_4_88: u32 = 14408;
        // D s_4_89: read-reg s_4_88:struct
        let s_4_89: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_88 as isize);
            tracer.read_register(s_4_88 as isize, value);
            value
        };
        // C s_4_90: const #14408u : u32
        let s_4_90: u32 = 14408;
        // N s_4_91: write-reg s_4_90 <= s_4_89
        let s_4_91: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_90 as isize, s_4_89);
            tracer.write_register(s_4_90 as isize, s_4_89);
        };
        // C s_4_92: const #100880u : u32
        let s_4_92: u32 = 100880;
        // D s_4_93: read-reg s_4_92:struct
        let s_4_93: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_92 as isize);
            tracer.read_register(s_4_92 as isize, value);
            value
        };
        // C s_4_94: const #100880u : u32
        let s_4_94: u32 = 100880;
        // N s_4_95: write-reg s_4_94 <= s_4_93
        let s_4_95: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_94 as isize, s_4_93);
            tracer.write_register(s_4_94 as isize, s_4_93);
        };
        // C s_4_96: const #100880u : u32
        let s_4_96: u32 = 100880;
        // D s_4_97: read-reg s_4_96:struct
        let s_4_97: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_96 as isize);
            tracer.read_register(s_4_96 as isize, value);
            value
        };
        // C s_4_98: const #100880u : u32
        let s_4_98: u32 = 100880;
        // N s_4_99: write-reg s_4_98 <= s_4_97
        let s_4_99: () = {
            state.write_register::<ProductType5c790c8ef59cc8b2>(s_4_98 as isize, s_4_97);
            tracer.write_register(s_4_98 as isize, s_4_97);
        };
        // C s_4_100: const #17024u : u32
        let s_4_100: u32 = 17024;
        // D s_4_101: read-reg s_4_100:struct
        let s_4_101: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_100 as isize);
            tracer.read_register(s_4_100 as isize, value);
            value
        };
        // C s_4_102: const #17024u : u32
        let s_4_102: u32 = 17024;
        // N s_4_103: write-reg s_4_102 <= s_4_101
        let s_4_103: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_102 as isize, s_4_101);
            tracer.write_register(s_4_102 as isize, s_4_101);
        };
        // C s_4_104: const #17024u : u32
        let s_4_104: u32 = 17024;
        // D s_4_105: read-reg s_4_104:struct
        let s_4_105: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_104 as isize);
            tracer.read_register(s_4_104 as isize, value);
            value
        };
        // C s_4_106: const #17024u : u32
        let s_4_106: u32 = 17024;
        // N s_4_107: write-reg s_4_106 <= s_4_105
        let s_4_107: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_106 as isize, s_4_105);
            tracer.write_register(s_4_106 as isize, s_4_105);
        };
        // C s_4_108: const #0u : u8
        let s_4_108: bool = false;
        // S s_4_109: call Bit(s_4_108)
        let s_4_109: bool = Bit(state, tracer, s_4_108);
        // C s_4_110: const #17024u : u32
        let s_4_110: u32 = 17024;
        // D s_4_111: read-reg s_4_110:struct
        let s_4_111: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_110 as isize);
            tracer.read_register(s_4_110 as isize, value);
            value
        };
        // C s_4_112: const #17024u : u32
        let s_4_112: u32 = 17024;
        // N s_4_113: write-reg s_4_112 <= s_4_111
        let s_4_113: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_112 as isize, s_4_111);
            tracer.write_register(s_4_112 as isize, s_4_111);
        };
        // C s_4_114: const #17024u : u32
        let s_4_114: u32 = 17024;
        // D s_4_115: read-reg s_4_114:struct
        let s_4_115: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_114 as isize);
            tracer.read_register(s_4_114 as isize, value);
            value
        };
        // C s_4_116: const #17024u : u32
        let s_4_116: u32 = 17024;
        // N s_4_117: write-reg s_4_116 <= s_4_115
        let s_4_117: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_116 as isize, s_4_115);
            tracer.write_register(s_4_116 as isize, s_4_115);
        };
        // C s_4_118: const #0u : u8
        let s_4_118: bool = false;
        // S s_4_119: call Bit(s_4_118)
        let s_4_119: bool = Bit(state, tracer, s_4_118);
        // C s_4_120: const #17024u : u32
        let s_4_120: u32 = 17024;
        // D s_4_121: read-reg s_4_120:struct
        let s_4_121: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_120 as isize);
            tracer.read_register(s_4_120 as isize, value);
            value
        };
        // C s_4_122: const #17024u : u32
        let s_4_122: u32 = 17024;
        // N s_4_123: write-reg s_4_122 <= s_4_121
        let s_4_123: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_122 as isize, s_4_121);
            tracer.write_register(s_4_122 as isize, s_4_121);
        };
        // C s_4_124: const #0u : u8
        let s_4_124: bool = false;
        // S s_4_125: call Bit(s_4_124)
        let s_4_125: bool = Bit(state, tracer, s_4_124);
        // C s_4_126: const #17024u : u32
        let s_4_126: u32 = 17024;
        // D s_4_127: read-reg s_4_126:struct
        let s_4_127: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_126 as isize);
            tracer.read_register(s_4_126 as isize, value);
            value
        };
        // C s_4_128: const #17024u : u32
        let s_4_128: u32 = 17024;
        // N s_4_129: write-reg s_4_128 <= s_4_127
        let s_4_129: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_128 as isize, s_4_127);
            tracer.write_register(s_4_128 as isize, s_4_127);
        };
        // C s_4_130: const #17024u : u32
        let s_4_130: u32 = 17024;
        // D s_4_131: read-reg s_4_130:struct
        let s_4_131: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_130 as isize);
            tracer.read_register(s_4_130 as isize, value);
            value
        };
        // C s_4_132: const #17024u : u32
        let s_4_132: u32 = 17024;
        // N s_4_133: write-reg s_4_132 <= s_4_131
        let s_4_133: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_132 as isize, s_4_131);
            tracer.write_register(s_4_132 as isize, s_4_131);
        };
        // C s_4_134: const #19312u : u32
        let s_4_134: u32 = 19312;
        // D s_4_135: read-reg s_4_134:struct
        let s_4_135: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_134 as isize);
            tracer.read_register(s_4_134 as isize, value);
            value
        };
        // C s_4_136: const #19312u : u32
        let s_4_136: u32 = 19312;
        // N s_4_137: write-reg s_4_136 <= s_4_135
        let s_4_137: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_136 as isize, s_4_135);
            tracer.write_register(s_4_136 as isize, s_4_135);
        };
        // C s_4_138: const #17536u : u32
        let s_4_138: u32 = 17536;
        // D s_4_139: read-reg s_4_138:struct
        let s_4_139: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_138 as isize);
            tracer.read_register(s_4_138 as isize, value);
            value
        };
        // C s_4_140: const #17536u : u32
        let s_4_140: u32 = 17536;
        // N s_4_141: write-reg s_4_140 <= s_4_139
        let s_4_141: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_140 as isize, s_4_139);
            tracer.write_register(s_4_140 as isize, s_4_139);
        };
        // C s_4_142: const #17536u : u32
        let s_4_142: u32 = 17536;
        // D s_4_143: read-reg s_4_142:struct
        let s_4_143: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_142 as isize);
            tracer.read_register(s_4_142 as isize, value);
            value
        };
        // C s_4_144: const #17536u : u32
        let s_4_144: u32 = 17536;
        // N s_4_145: write-reg s_4_144 <= s_4_143
        let s_4_145: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_144 as isize, s_4_143);
            tracer.write_register(s_4_144 as isize, s_4_143);
        };
        // C s_4_146: const #17536u : u32
        let s_4_146: u32 = 17536;
        // D s_4_147: read-reg s_4_146:struct
        let s_4_147: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_146 as isize);
            tracer.read_register(s_4_146 as isize, value);
            value
        };
        // C s_4_148: const #17536u : u32
        let s_4_148: u32 = 17536;
        // N s_4_149: write-reg s_4_148 <= s_4_147
        let s_4_149: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_148 as isize, s_4_147);
            tracer.write_register(s_4_148 as isize, s_4_147);
        };
        // C s_4_150: const #17536u : u32
        let s_4_150: u32 = 17536;
        // D s_4_151: read-reg s_4_150:struct
        let s_4_151: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_150 as isize);
            tracer.read_register(s_4_150 as isize, value);
            value
        };
        // C s_4_152: const #17536u : u32
        let s_4_152: u32 = 17536;
        // N s_4_153: write-reg s_4_152 <= s_4_151
        let s_4_153: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_152 as isize, s_4_151);
            tracer.write_register(s_4_152 as isize, s_4_151);
        };
        // C s_4_154: const #17536u : u32
        let s_4_154: u32 = 17536;
        // D s_4_155: read-reg s_4_154:struct
        let s_4_155: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_154 as isize);
            tracer.read_register(s_4_154 as isize, value);
            value
        };
        // C s_4_156: const #17536u : u32
        let s_4_156: u32 = 17536;
        // N s_4_157: write-reg s_4_156 <= s_4_155
        let s_4_157: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_156 as isize, s_4_155);
            tracer.write_register(s_4_156 as isize, s_4_155);
        };
        // C s_4_158: const #17536u : u32
        let s_4_158: u32 = 17536;
        // D s_4_159: read-reg s_4_158:struct
        let s_4_159: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_158 as isize);
            tracer.read_register(s_4_158 as isize, value);
            value
        };
        // C s_4_160: const #17536u : u32
        let s_4_160: u32 = 17536;
        // N s_4_161: write-reg s_4_160 <= s_4_159
        let s_4_161: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_160 as isize, s_4_159);
            tracer.write_register(s_4_160 as isize, s_4_159);
        };
        // C s_4_162: const #0u : u8
        let s_4_162: bool = false;
        // S s_4_163: call Bit(s_4_162)
        let s_4_163: bool = Bit(state, tracer, s_4_162);
        // C s_4_164: const #17536u : u32
        let s_4_164: u32 = 17536;
        // D s_4_165: read-reg s_4_164:struct
        let s_4_165: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_164 as isize);
            tracer.read_register(s_4_164 as isize, value);
            value
        };
        // C s_4_166: const #17536u : u32
        let s_4_166: u32 = 17536;
        // N s_4_167: write-reg s_4_166 <= s_4_165
        let s_4_167: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_166 as isize, s_4_165);
            tracer.write_register(s_4_166 as isize, s_4_165);
        };
        // C s_4_168: const #17536u : u32
        let s_4_168: u32 = 17536;
        // D s_4_169: read-reg s_4_168:struct
        let s_4_169: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_168 as isize);
            tracer.read_register(s_4_168 as isize, value);
            value
        };
        // C s_4_170: const #17536u : u32
        let s_4_170: u32 = 17536;
        // N s_4_171: write-reg s_4_170 <= s_4_169
        let s_4_171: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_170 as isize, s_4_169);
            tracer.write_register(s_4_170 as isize, s_4_169);
        };
        // C s_4_172: const #17536u : u32
        let s_4_172: u32 = 17536;
        // D s_4_173: read-reg s_4_172:struct
        let s_4_173: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_172 as isize);
            tracer.read_register(s_4_172 as isize, value);
            value
        };
        // C s_4_174: const #17536u : u32
        let s_4_174: u32 = 17536;
        // N s_4_175: write-reg s_4_174 <= s_4_173
        let s_4_175: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_174 as isize, s_4_173);
            tracer.write_register(s_4_174 as isize, s_4_173);
        };
        // C s_4_176: const #17536u : u32
        let s_4_176: u32 = 17536;
        // D s_4_177: read-reg s_4_176:struct
        let s_4_177: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_176 as isize);
            tracer.read_register(s_4_176 as isize, value);
            value
        };
        // C s_4_178: const #17536u : u32
        let s_4_178: u32 = 17536;
        // N s_4_179: write-reg s_4_178 <= s_4_177
        let s_4_179: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_178 as isize, s_4_177);
            tracer.write_register(s_4_178 as isize, s_4_177);
        };
        // C s_4_180: const #10632u : u32
        let s_4_180: u32 = 10632;
        // D s_4_181: read-reg s_4_180:struct
        let s_4_181: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_180 as isize);
            tracer.read_register(s_4_180 as isize, value);
            value
        };
        // C s_4_182: const #10632u : u32
        let s_4_182: u32 = 10632;
        // N s_4_183: write-reg s_4_182 <= s_4_181
        let s_4_183: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_182 as isize, s_4_181);
            tracer.write_register(s_4_182 as isize, s_4_181);
        };
        // C s_4_184: const #10632u : u32
        let s_4_184: u32 = 10632;
        // D s_4_185: read-reg s_4_184:struct
        let s_4_185: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_184 as isize);
            tracer.read_register(s_4_184 as isize, value);
            value
        };
        // C s_4_186: const #10632u : u32
        let s_4_186: u32 = 10632;
        // N s_4_187: write-reg s_4_186 <= s_4_185
        let s_4_187: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_186 as isize, s_4_185);
            tracer.write_register(s_4_186 as isize, s_4_185);
        };
        // C s_4_188: const #23400u : u32
        let s_4_188: u32 = 23400;
        // D s_4_189: read-reg s_4_188:struct
        let s_4_189: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_188 as isize);
            tracer.read_register(s_4_188 as isize, value);
            value
        };
        // C s_4_190: const #23400u : u32
        let s_4_190: u32 = 23400;
        // N s_4_191: write-reg s_4_190 <= s_4_189
        let s_4_191: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_190 as isize, s_4_189);
            tracer.write_register(s_4_190 as isize, s_4_189);
        };
        // C s_4_192: const #23400u : u32
        let s_4_192: u32 = 23400;
        // D s_4_193: read-reg s_4_192:struct
        let s_4_193: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_192 as isize);
            tracer.read_register(s_4_192 as isize, value);
            value
        };
        // C s_4_194: const #23400u : u32
        let s_4_194: u32 = 23400;
        // N s_4_195: write-reg s_4_194 <= s_4_193
        let s_4_195: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_194 as isize, s_4_193);
            tracer.write_register(s_4_194 as isize, s_4_193);
        };
        // C s_4_196: const #21120u : u32
        let s_4_196: u32 = 21120;
        // D s_4_197: read-reg s_4_196:struct
        let s_4_197: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_196 as isize);
            tracer.read_register(s_4_196 as isize, value);
            value
        };
        // C s_4_198: const #21120u : u32
        let s_4_198: u32 = 21120;
        // N s_4_199: write-reg s_4_198 <= s_4_197
        let s_4_199: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_198 as isize, s_4_197);
            tracer.write_register(s_4_198 as isize, s_4_197);
        };
        // C s_4_200: const #90376u : u32
        let s_4_200: u32 = 90376;
        // D s_4_201: read-reg s_4_200:struct
        let s_4_201: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_200 as isize);
            tracer.read_register(s_4_200 as isize, value);
            value
        };
        // C s_4_202: const #90376u : u32
        let s_4_202: u32 = 90376;
        // N s_4_203: write-reg s_4_202 <= s_4_201
        let s_4_203: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_202 as isize, s_4_201);
            tracer.write_register(s_4_202 as isize, s_4_201);
        };
        // C s_4_204: const #90376u : u32
        let s_4_204: u32 = 90376;
        // D s_4_205: read-reg s_4_204:struct
        let s_4_205: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_204 as isize);
            tracer.read_register(s_4_204 as isize, value);
            value
        };
        // C s_4_206: const #90376u : u32
        let s_4_206: u32 = 90376;
        // N s_4_207: write-reg s_4_206 <= s_4_205
        let s_4_207: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_206 as isize, s_4_205);
            tracer.write_register(s_4_206 as isize, s_4_205);
        };
        // C s_4_208: const #22800u : u32
        let s_4_208: u32 = 22800;
        // D s_4_209: read-reg s_4_208:struct
        let s_4_209: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_208 as isize);
            tracer.read_register(s_4_208 as isize, value);
            value
        };
        // C s_4_210: const #22800u : u32
        let s_4_210: u32 = 22800;
        // N s_4_211: write-reg s_4_210 <= s_4_209
        let s_4_211: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_210 as isize, s_4_209);
            tracer.write_register(s_4_210 as isize, s_4_209);
        };
        // C s_4_212: const #22800u : u32
        let s_4_212: u32 = 22800;
        // D s_4_213: read-reg s_4_212:struct
        let s_4_213: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_212 as isize);
            tracer.read_register(s_4_212 as isize, value);
            value
        };
        // C s_4_214: const #22800u : u32
        let s_4_214: u32 = 22800;
        // N s_4_215: write-reg s_4_214 <= s_4_213
        let s_4_215: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_214 as isize, s_4_213);
            tracer.write_register(s_4_214 as isize, s_4_213);
        };
        // C s_4_216: const #22800u : u32
        let s_4_216: u32 = 22800;
        // D s_4_217: read-reg s_4_216:struct
        let s_4_217: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_216 as isize);
            tracer.read_register(s_4_216 as isize, value);
            value
        };
        // C s_4_218: const #22800u : u32
        let s_4_218: u32 = 22800;
        // N s_4_219: write-reg s_4_218 <= s_4_217
        let s_4_219: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_218 as isize, s_4_217);
            tracer.write_register(s_4_218 as isize, s_4_217);
        };
        // C s_4_220: const #22800u : u32
        let s_4_220: u32 = 22800;
        // D s_4_221: read-reg s_4_220:struct
        let s_4_221: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_220 as isize);
            tracer.read_register(s_4_220 as isize, value);
            value
        };
        // C s_4_222: const #22800u : u32
        let s_4_222: u32 = 22800;
        // N s_4_223: write-reg s_4_222 <= s_4_221
        let s_4_223: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_222 as isize, s_4_221);
            tracer.write_register(s_4_222 as isize, s_4_221);
        };
        // C s_4_224: const #102736u : u32
        let s_4_224: u32 = 102736;
        // D s_4_225: read-reg s_4_224:struct
        let s_4_225: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_224 as isize);
            tracer.read_register(s_4_224 as isize, value);
            value
        };
        // C s_4_226: const #102736u : u32
        let s_4_226: u32 = 102736;
        // N s_4_227: write-reg s_4_226 <= s_4_225
        let s_4_227: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_226 as isize, s_4_225);
            tracer.write_register(s_4_226 as isize, s_4_225);
        };
        // C s_4_228: const #13624u : u32
        let s_4_228: u32 = 13624;
        // D s_4_229: read-reg s_4_228:struct
        let s_4_229: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_228 as isize);
            tracer.read_register(s_4_228 as isize, value);
            value
        };
        // C s_4_230: const #13624u : u32
        let s_4_230: u32 = 13624;
        // N s_4_231: write-reg s_4_230 <= s_4_229
        let s_4_231: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_230 as isize, s_4_229);
            tracer.write_register(s_4_230 as isize, s_4_229);
        };
        // C s_4_232: const #14248u : u32
        let s_4_232: u32 = 14248;
        // D s_4_233: read-reg s_4_232:struct
        let s_4_233: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_232 as isize);
            tracer.read_register(s_4_232 as isize, value);
            value
        };
        // C s_4_234: const #14248u : u32
        let s_4_234: u32 = 14248;
        // N s_4_235: write-reg s_4_234 <= s_4_233
        let s_4_235: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_234 as isize, s_4_233);
            tracer.write_register(s_4_234 as isize, s_4_233);
        };
        // C s_4_236: const #0u : u8
        let s_4_236: bool = false;
        // S s_4_237: call Bit(s_4_236)
        let s_4_237: bool = Bit(state, tracer, s_4_236);
        // C s_4_238: const #14248u : u32
        let s_4_238: u32 = 14248;
        // D s_4_239: read-reg s_4_238:struct
        let s_4_239: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_238 as isize);
            tracer.read_register(s_4_238 as isize, value);
            value
        };
        // C s_4_240: const #14248u : u32
        let s_4_240: u32 = 14248;
        // N s_4_241: write-reg s_4_240 <= s_4_239
        let s_4_241: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_240 as isize, s_4_239);
            tracer.write_register(s_4_240 as isize, s_4_239);
        };
        // C s_4_242: const #14248u : u32
        let s_4_242: u32 = 14248;
        // D s_4_243: read-reg s_4_242:struct
        let s_4_243: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_242 as isize);
            tracer.read_register(s_4_242 as isize, value);
            value
        };
        // C s_4_244: const #14248u : u32
        let s_4_244: u32 = 14248;
        // N s_4_245: write-reg s_4_244 <= s_4_243
        let s_4_245: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_244 as isize, s_4_243);
            tracer.write_register(s_4_244 as isize, s_4_243);
        };
        // C s_4_246: const #0u : u8
        let s_4_246: bool = false;
        // S s_4_247: call Bit(s_4_246)
        let s_4_247: bool = Bit(state, tracer, s_4_246);
        // C s_4_248: const #14248u : u32
        let s_4_248: u32 = 14248;
        // D s_4_249: read-reg s_4_248:struct
        let s_4_249: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_248 as isize);
            tracer.read_register(s_4_248 as isize, value);
            value
        };
        // C s_4_250: const #14248u : u32
        let s_4_250: u32 = 14248;
        // N s_4_251: write-reg s_4_250 <= s_4_249
        let s_4_251: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_250 as isize, s_4_249);
            tracer.write_register(s_4_250 as isize, s_4_249);
        };
        // C s_4_252: const #14248u : u32
        let s_4_252: u32 = 14248;
        // D s_4_253: read-reg s_4_252:struct
        let s_4_253: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_252 as isize);
            tracer.read_register(s_4_252 as isize, value);
            value
        };
        // C s_4_254: const #14248u : u32
        let s_4_254: u32 = 14248;
        // N s_4_255: write-reg s_4_254 <= s_4_253
        let s_4_255: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_254 as isize, s_4_253);
            tracer.write_register(s_4_254 as isize, s_4_253);
        };
        // C s_4_256: const #10136u : u32
        let s_4_256: u32 = 10136;
        // D s_4_257: read-reg s_4_256:struct
        let s_4_257: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_256 as isize);
            tracer.read_register(s_4_256 as isize, value);
            value
        };
        // C s_4_258: const #10136u : u32
        let s_4_258: u32 = 10136;
        // N s_4_259: write-reg s_4_258 <= s_4_257
        let s_4_259: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_258 as isize, s_4_257);
            tracer.write_register(s_4_258 as isize, s_4_257);
        };
        // C s_4_260: const #16960u : u32
        let s_4_260: u32 = 16960;
        // D s_4_261: read-reg s_4_260:struct
        let s_4_261: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_260 as isize);
            tracer.read_register(s_4_260 as isize, value);
            value
        };
        // C s_4_262: const #16960u : u32
        let s_4_262: u32 = 16960;
        // N s_4_263: write-reg s_4_262 <= s_4_261
        let s_4_263: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_262 as isize, s_4_261);
            tracer.write_register(s_4_262 as isize, s_4_261);
        };
        // C s_4_264: const #16960u : u32
        let s_4_264: u32 = 16960;
        // D s_4_265: read-reg s_4_264:struct
        let s_4_265: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_264 as isize);
            tracer.read_register(s_4_264 as isize, value);
            value
        };
        // C s_4_266: const #16960u : u32
        let s_4_266: u32 = 16960;
        // N s_4_267: write-reg s_4_266 <= s_4_265
        let s_4_267: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_266 as isize, s_4_265);
            tracer.write_register(s_4_266 as isize, s_4_265);
        };
        // C s_4_268: const #0u : u8
        let s_4_268: bool = false;
        // S s_4_269: call Bit(s_4_268)
        let s_4_269: bool = Bit(state, tracer, s_4_268);
        // C s_4_270: const #16960u : u32
        let s_4_270: u32 = 16960;
        // D s_4_271: read-reg s_4_270:struct
        let s_4_271: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_270 as isize);
            tracer.read_register(s_4_270 as isize, value);
            value
        };
        // C s_4_272: const #16960u : u32
        let s_4_272: u32 = 16960;
        // N s_4_273: write-reg s_4_272 <= s_4_271
        let s_4_273: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_272 as isize, s_4_271);
            tracer.write_register(s_4_272 as isize, s_4_271);
        };
        // C s_4_274: const #16960u : u32
        let s_4_274: u32 = 16960;
        // D s_4_275: read-reg s_4_274:struct
        let s_4_275: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_274 as isize);
            tracer.read_register(s_4_274 as isize, value);
            value
        };
        // C s_4_276: const #16960u : u32
        let s_4_276: u32 = 16960;
        // N s_4_277: write-reg s_4_276 <= s_4_275
        let s_4_277: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_276 as isize, s_4_275);
            tracer.write_register(s_4_276 as isize, s_4_275);
        };
        // C s_4_278: const #0u : u8
        let s_4_278: bool = false;
        // S s_4_279: call Bit(s_4_278)
        let s_4_279: bool = Bit(state, tracer, s_4_278);
        // C s_4_280: const #16960u : u32
        let s_4_280: u32 = 16960;
        // D s_4_281: read-reg s_4_280:struct
        let s_4_281: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_280 as isize);
            tracer.read_register(s_4_280 as isize, value);
            value
        };
        // C s_4_282: const #16960u : u32
        let s_4_282: u32 = 16960;
        // N s_4_283: write-reg s_4_282 <= s_4_281
        let s_4_283: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_282 as isize, s_4_281);
            tracer.write_register(s_4_282 as isize, s_4_281);
        };
        // C s_4_284: const #() : ()
        let s_4_284: () = ();
        // S s_4_285: call PMCNTEN_read(s_4_284)
        let s_4_285: ProductType5c790c8ef59cc8b2 = PMCNTEN_read(state, tracer, s_4_284);
        // D s_4_286: write-var ga#34828 <= s_4_285
        fn_state.ga_34828 = s_4_285;
        // D s_4_287: read-var ga#34828.0:struct
        let s_4_287: u64 = fn_state.ga_34828._0;
        // C s_4_288: const #31s : i
        let s_4_288: i128 = 31;
        // C s_4_289: const #33s : i
        let s_4_289: i128 = 33;
        // D s_4_290: cast zx s_4_287 -> bv
        let s_4_290: Bits = Bits::new(s_4_287 as u128, 64u16);
        // C s_4_291: const #0u : u31
        let s_4_291: u32 = 0;
        // C s_4_292: cast zx s_4_291 -> bv
        let s_4_292: Bits = Bits::new(s_4_291 as u128, 31u16);
        // C s_4_293: const #1u : u64
        let s_4_293: u64 = 1;
        // C s_4_294: cast zx s_4_293 -> bv
        let s_4_294: Bits = Bits::new(s_4_293 as u128, 64u16);
        // C s_4_295: lsl s_4_294 s_4_288
        let s_4_295: Bits = s_4_294 << s_4_288;
        // C s_4_296: sub s_4_295 s_4_294
        let s_4_296: Bits = ((s_4_295) - (s_4_294));
        // C s_4_297: and s_4_292 s_4_296
        let s_4_297: Bits = ((s_4_292) & (s_4_296));
        // C s_4_298: lsl s_4_297 s_4_289
        let s_4_298: Bits = s_4_297 << s_4_289;
        // C s_4_299: lsl s_4_296 s_4_289
        let s_4_299: Bits = s_4_296 << s_4_289;
        // C s_4_300: cmpl s_4_299
        let s_4_300: Bits = !s_4_299;
        // D s_4_301: and s_4_290 s_4_300
        let s_4_301: Bits = ((s_4_290) & (s_4_300));
        // D s_4_302: or s_4_301 s_4_298
        let s_4_302: Bits = ((s_4_301) | (s_4_298));
        // D s_4_303: cast reint s_4_302 -> u64
        let s_4_303: u64 = (s_4_302.value() as u64);
        // D s_4_304: call Mk_PMCNTEN_Type(s_4_303)
        let s_4_304: ProductType5c790c8ef59cc8b2 = Mk_PMCNTEN_Type(
            state,
            tracer,
            s_4_303,
        );
        // D s_4_305: call PMCNTEN_write(s_4_304)
        let s_4_305: () = PMCNTEN_write(state, tracer, s_4_304);
        // C s_4_306: const #14984u : u32
        let s_4_306: u32 = 14984;
        // D s_4_307: read-reg s_4_306:struct
        let s_4_307: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_306 as isize);
            tracer.read_register(s_4_306 as isize, value);
            value
        };
        // C s_4_308: const #14984u : u32
        let s_4_308: u32 = 14984;
        // N s_4_309: write-reg s_4_308 <= s_4_307
        let s_4_309: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_308 as isize, s_4_307);
            tracer.write_register(s_4_308 as isize, s_4_307);
        };
        // C s_4_310: const #0u : u8
        let s_4_310: bool = false;
        // S s_4_311: call Bit(s_4_310)
        let s_4_311: bool = Bit(state, tracer, s_4_310);
        // C s_4_312: const #14984u : u32
        let s_4_312: u32 = 14984;
        // D s_4_313: read-reg s_4_312:struct
        let s_4_313: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_312 as isize);
            tracer.read_register(s_4_312 as isize, value);
            value
        };
        // C s_4_314: const #14984u : u32
        let s_4_314: u32 = 14984;
        // N s_4_315: write-reg s_4_314 <= s_4_313
        let s_4_315: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_314 as isize, s_4_313);
            tracer.write_register(s_4_314 as isize, s_4_313);
        };
        // C s_4_316: const #0u : u8
        let s_4_316: bool = false;
        // S s_4_317: call Bit(s_4_316)
        let s_4_317: bool = Bit(state, tracer, s_4_316);
        // C s_4_318: const #14984u : u32
        let s_4_318: u32 = 14984;
        // D s_4_319: read-reg s_4_318:struct
        let s_4_319: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_318 as isize);
            tracer.read_register(s_4_318 as isize, value);
            value
        };
        // C s_4_320: const #14984u : u32
        let s_4_320: u32 = 14984;
        // N s_4_321: write-reg s_4_320 <= s_4_319
        let s_4_321: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_320 as isize, s_4_319);
            tracer.write_register(s_4_320 as isize, s_4_319);
        };
        // C s_4_322: const #() : ()
        let s_4_322: () = ();
        // S s_4_323: call PMINTEN_read(s_4_322)
        let s_4_323: ProductType5c790c8ef59cc8b2 = PMINTEN_read(state, tracer, s_4_322);
        // D s_4_324: write-var ga#34840 <= s_4_323
        fn_state.ga_34840 = s_4_323;
        // D s_4_325: read-var ga#34840.0:struct
        let s_4_325: u64 = fn_state.ga_34840._0;
        // C s_4_326: const #31s : i
        let s_4_326: i128 = 31;
        // C s_4_327: const #33s : i
        let s_4_327: i128 = 33;
        // D s_4_328: cast zx s_4_325 -> bv
        let s_4_328: Bits = Bits::new(s_4_325 as u128, 64u16);
        // C s_4_329: const #0u : u31
        let s_4_329: u32 = 0;
        // C s_4_330: cast zx s_4_329 -> bv
        let s_4_330: Bits = Bits::new(s_4_329 as u128, 31u16);
        // C s_4_331: const #1u : u64
        let s_4_331: u64 = 1;
        // C s_4_332: cast zx s_4_331 -> bv
        let s_4_332: Bits = Bits::new(s_4_331 as u128, 64u16);
        // C s_4_333: lsl s_4_332 s_4_326
        let s_4_333: Bits = s_4_332 << s_4_326;
        // C s_4_334: sub s_4_333 s_4_332
        let s_4_334: Bits = ((s_4_333) - (s_4_332));
        // C s_4_335: and s_4_330 s_4_334
        let s_4_335: Bits = ((s_4_330) & (s_4_334));
        // C s_4_336: lsl s_4_335 s_4_327
        let s_4_336: Bits = s_4_335 << s_4_327;
        // C s_4_337: lsl s_4_334 s_4_327
        let s_4_337: Bits = s_4_334 << s_4_327;
        // C s_4_338: cmpl s_4_337
        let s_4_338: Bits = !s_4_337;
        // D s_4_339: and s_4_328 s_4_338
        let s_4_339: Bits = ((s_4_328) & (s_4_338));
        // D s_4_340: or s_4_339 s_4_336
        let s_4_340: Bits = ((s_4_339) | (s_4_336));
        // D s_4_341: cast reint s_4_340 -> u64
        let s_4_341: u64 = (s_4_340.value() as u64);
        // D s_4_342: call Mk_PMINTEN_Type(s_4_341)
        let s_4_342: ProductType5c790c8ef59cc8b2 = Mk_PMINTEN_Type(
            state,
            tracer,
            s_4_341,
        );
        // D s_4_343: call PMINTEN_write(s_4_342)
        let s_4_343: () = PMINTEN_write(state, tracer, s_4_342);
        // C s_4_344: const #() : ()
        let s_4_344: () = ();
        // S s_4_345: call PMOVS_read(s_4_344)
        let s_4_345: ProductType5c790c8ef59cc8b2 = PMOVS_read(state, tracer, s_4_344);
        // D s_4_346: write-var ga#34844 <= s_4_345
        fn_state.ga_34844 = s_4_345;
        // D s_4_347: read-var ga#34844.0:struct
        let s_4_347: u64 = fn_state.ga_34844._0;
        // C s_4_348: const #31s : i
        let s_4_348: i128 = 31;
        // C s_4_349: const #33s : i
        let s_4_349: i128 = 33;
        // D s_4_350: cast zx s_4_347 -> bv
        let s_4_350: Bits = Bits::new(s_4_347 as u128, 64u16);
        // C s_4_351: const #0u : u31
        let s_4_351: u32 = 0;
        // C s_4_352: cast zx s_4_351 -> bv
        let s_4_352: Bits = Bits::new(s_4_351 as u128, 31u16);
        // C s_4_353: const #1u : u64
        let s_4_353: u64 = 1;
        // C s_4_354: cast zx s_4_353 -> bv
        let s_4_354: Bits = Bits::new(s_4_353 as u128, 64u16);
        // C s_4_355: lsl s_4_354 s_4_348
        let s_4_355: Bits = s_4_354 << s_4_348;
        // C s_4_356: sub s_4_355 s_4_354
        let s_4_356: Bits = ((s_4_355) - (s_4_354));
        // C s_4_357: and s_4_352 s_4_356
        let s_4_357: Bits = ((s_4_352) & (s_4_356));
        // C s_4_358: lsl s_4_357 s_4_349
        let s_4_358: Bits = s_4_357 << s_4_349;
        // C s_4_359: lsl s_4_356 s_4_349
        let s_4_359: Bits = s_4_356 << s_4_349;
        // C s_4_360: cmpl s_4_359
        let s_4_360: Bits = !s_4_359;
        // D s_4_361: and s_4_350 s_4_360
        let s_4_361: Bits = ((s_4_350) & (s_4_360));
        // D s_4_362: or s_4_361 s_4_358
        let s_4_362: Bits = ((s_4_361) | (s_4_358));
        // D s_4_363: cast reint s_4_362 -> u64
        let s_4_363: u64 = (s_4_362.value() as u64);
        // D s_4_364: call Mk_PMOVS_Type(s_4_363)
        let s_4_364: ProductType5c790c8ef59cc8b2 = Mk_PMOVS_Type(state, tracer, s_4_363);
        // D s_4_365: call PMOVS_write(s_4_364)
        let s_4_365: () = PMOVS_write(state, tracer, s_4_364);
        // C s_4_366: const #11120u : u32
        let s_4_366: u32 = 11120;
        // D s_4_367: read-reg s_4_366:struct
        let s_4_367: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_366 as isize);
            tracer.read_register(s_4_366 as isize, value);
            value
        };
        // C s_4_368: const #11120u : u32
        let s_4_368: u32 = 11120;
        // N s_4_369: write-reg s_4_368 <= s_4_367
        let s_4_369: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_368 as isize, s_4_367);
            tracer.write_register(s_4_368 as isize, s_4_367);
        };
        // C s_4_370: const #11120u : u32
        let s_4_370: u32 = 11120;
        // D s_4_371: read-reg s_4_370:struct
        let s_4_371: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_370 as isize);
            tracer.read_register(s_4_370 as isize, value);
            value
        };
        // C s_4_372: const #11120u : u32
        let s_4_372: u32 = 11120;
        // N s_4_373: write-reg s_4_372 <= s_4_371
        let s_4_373: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_372 as isize, s_4_371);
            tracer.write_register(s_4_372 as isize, s_4_371);
        };
        // C s_4_374: const #11120u : u32
        let s_4_374: u32 = 11120;
        // D s_4_375: read-reg s_4_374:struct
        let s_4_375: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_374 as isize);
            tracer.read_register(s_4_374 as isize, value);
            value
        };
        // C s_4_376: const #11120u : u32
        let s_4_376: u32 = 11120;
        // N s_4_377: write-reg s_4_376 <= s_4_375
        let s_4_377: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_376 as isize, s_4_375);
            tracer.write_register(s_4_376 as isize, s_4_375);
        };
        // C s_4_378: const #11120u : u32
        let s_4_378: u32 = 11120;
        // D s_4_379: read-reg s_4_378:struct
        let s_4_379: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_378 as isize);
            tracer.read_register(s_4_378 as isize, value);
            value
        };
        // C s_4_380: const #11120u : u32
        let s_4_380: u32 = 11120;
        // N s_4_381: write-reg s_4_380 <= s_4_379
        let s_4_381: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_380 as isize, s_4_379);
            tracer.write_register(s_4_380 as isize, s_4_379);
        };
        // C s_4_382: const #17384u : u32
        let s_4_382: u32 = 17384;
        // D s_4_383: read-reg s_4_382:struct
        let s_4_383: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_382 as isize);
            tracer.read_register(s_4_382 as isize, value);
            value
        };
        // C s_4_384: const #17384u : u32
        let s_4_384: u32 = 17384;
        // N s_4_385: write-reg s_4_384 <= s_4_383
        let s_4_385: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_384 as isize, s_4_383);
            tracer.write_register(s_4_384 as isize, s_4_383);
        };
        // C s_4_386: const #1536u : u32
        let s_4_386: u32 = 1536;
        // D s_4_387: read-reg s_4_386:struct
        let s_4_387: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_4_386 as isize);
            tracer.read_register(s_4_386 as isize, value);
            value
        };
        // C s_4_388: const #1536u : u32
        let s_4_388: u32 = 1536;
        // N s_4_389: write-reg s_4_388 <= s_4_387
        let s_4_389: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_4_388 as isize, s_4_387);
            tracer.write_register(s_4_388 as isize, s_4_387);
        };
        // C s_4_390: const #() : ()
        let s_4_390: () = ();
        // S s_4_391: call TTBCR_read(s_4_390)
        let s_4_391: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_390);
        // C s_4_392: const #0u : u8
        let s_4_392: bool = false;
        // S s_4_393: call _update_TTBCR_Type_EAE(s_4_391, s_4_392)
        let s_4_393: ProductType700c18a878c5601b = u_update_TTBCR_Type_EAE(
            state,
            tracer,
            s_4_391,
            s_4_392,
        );
        // S s_4_394: call TTBCR_write(s_4_393)
        let s_4_394: () = TTBCR_write(state, tracer, s_4_393);
        // C s_4_395: const #() : ()
        let s_4_395: () = ();
        // S s_4_396: call TTBCR_read(s_4_395)
        let s_4_396: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_395);
        // D s_4_397: write-var ga#34862 <= s_4_396
        fn_state.ga_34862 = s_4_396;
        // D s_4_398: read-var ga#34862.0:struct
        let s_4_398: u32 = fn_state.ga_34862._0;
        // C s_4_399: const #25s : i
        let s_4_399: i128 = 25;
        // C s_4_400: const #6s : i
        let s_4_400: i128 = 6;
        // D s_4_401: cast zx s_4_398 -> bv
        let s_4_401: Bits = Bits::new(s_4_398 as u128, 32u16);
        // C s_4_402: const #0u : u25
        let s_4_402: u32 = 0;
        // C s_4_403: cast zx s_4_402 -> bv
        let s_4_403: Bits = Bits::new(s_4_402 as u128, 25u16);
        // C s_4_404: const #1u : u64
        let s_4_404: u64 = 1;
        // C s_4_405: cast zx s_4_404 -> bv
        let s_4_405: Bits = Bits::new(s_4_404 as u128, 64u16);
        // C s_4_406: lsl s_4_405 s_4_399
        let s_4_406: Bits = s_4_405 << s_4_399;
        // C s_4_407: sub s_4_406 s_4_405
        let s_4_407: Bits = ((s_4_406) - (s_4_405));
        // C s_4_408: and s_4_403 s_4_407
        let s_4_408: Bits = ((s_4_403) & (s_4_407));
        // C s_4_409: lsl s_4_408 s_4_400
        let s_4_409: Bits = s_4_408 << s_4_400;
        // C s_4_410: lsl s_4_407 s_4_400
        let s_4_410: Bits = s_4_407 << s_4_400;
        // C s_4_411: cmpl s_4_410
        let s_4_411: Bits = !s_4_410;
        // D s_4_412: and s_4_401 s_4_411
        let s_4_412: Bits = ((s_4_401) & (s_4_411));
        // D s_4_413: or s_4_412 s_4_409
        let s_4_413: Bits = ((s_4_412) | (s_4_409));
        // D s_4_414: cast reint s_4_413 -> u32
        let s_4_414: u32 = (s_4_413.value() as u32);
        // D s_4_415: call Mk_TTBCR_Type(s_4_414)
        let s_4_415: ProductType700c18a878c5601b = Mk_TTBCR_Type(state, tracer, s_4_414);
        // D s_4_416: call TTBCR_write(s_4_415)
        let s_4_416: () = TTBCR_write(state, tracer, s_4_415);
        // C s_4_417: const #() : ()
        let s_4_417: () = ();
        // S s_4_418: call TTBCR_read(s_4_417)
        let s_4_418: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_417);
        // C s_4_419: const #0u : u8
        let s_4_419: bool = false;
        // S s_4_420: call _update_TTBCR_Type_PD1(s_4_418, s_4_419)
        let s_4_420: ProductType700c18a878c5601b = u_update_TTBCR_Type_PD1(
            state,
            tracer,
            s_4_418,
            s_4_419,
        );
        // S s_4_421: call TTBCR_write(s_4_420)
        let s_4_421: () = TTBCR_write(state, tracer, s_4_420);
        // C s_4_422: const #() : ()
        let s_4_422: () = ();
        // S s_4_423: call TTBCR_read(s_4_422)
        let s_4_423: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_422);
        // C s_4_424: const #0u : u8
        let s_4_424: bool = false;
        // S s_4_425: call _update_TTBCR_Type_PD0(s_4_423, s_4_424)
        let s_4_425: ProductType700c18a878c5601b = u_update_TTBCR_Type_PD0(
            state,
            tracer,
            s_4_423,
            s_4_424,
        );
        // S s_4_426: call TTBCR_write(s_4_425)
        let s_4_426: () = TTBCR_write(state, tracer, s_4_425);
        // C s_4_427: const #() : ()
        let s_4_427: () = ();
        // S s_4_428: call TTBCR_read(s_4_427)
        let s_4_428: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_427);
        // D s_4_429: write-var ga#34870 <= s_4_428
        fn_state.ga_34870 = s_4_428;
        // D s_4_430: read-var ga#34870.0:struct
        let s_4_430: u32 = fn_state.ga_34870._0;
        // C s_4_431: const #1s : i
        let s_4_431: i128 = 1;
        // C s_4_432: const #3s : i
        let s_4_432: i128 = 3;
        // D s_4_433: cast zx s_4_430 -> bv
        let s_4_433: Bits = Bits::new(s_4_430 as u128, 32u16);
        // C s_4_434: const #0u : u8
        let s_4_434: bool = false;
        // C s_4_435: cast zx s_4_434 -> bv
        let s_4_435: Bits = Bits::new(s_4_434 as u128, 1u16);
        // C s_4_436: const #1u : u64
        let s_4_436: u64 = 1;
        // C s_4_437: cast zx s_4_436 -> bv
        let s_4_437: Bits = Bits::new(s_4_436 as u128, 64u16);
        // C s_4_438: lsl s_4_437 s_4_431
        let s_4_438: Bits = s_4_437 << s_4_431;
        // C s_4_439: sub s_4_438 s_4_437
        let s_4_439: Bits = ((s_4_438) - (s_4_437));
        // C s_4_440: and s_4_435 s_4_439
        let s_4_440: Bits = ((s_4_435) & (s_4_439));
        // C s_4_441: lsl s_4_440 s_4_432
        let s_4_441: Bits = s_4_440 << s_4_432;
        // C s_4_442: lsl s_4_439 s_4_432
        let s_4_442: Bits = s_4_439 << s_4_432;
        // C s_4_443: cmpl s_4_442
        let s_4_443: Bits = !s_4_442;
        // D s_4_444: and s_4_433 s_4_443
        let s_4_444: Bits = ((s_4_433) & (s_4_443));
        // D s_4_445: or s_4_444 s_4_441
        let s_4_445: Bits = ((s_4_444) | (s_4_441));
        // D s_4_446: cast reint s_4_445 -> u32
        let s_4_446: u32 = (s_4_445.value() as u32);
        // D s_4_447: call Mk_TTBCR_Type(s_4_446)
        let s_4_447: ProductType700c18a878c5601b = Mk_TTBCR_Type(state, tracer, s_4_446);
        // D s_4_448: call TTBCR_write(s_4_447)
        let s_4_448: () = TTBCR_write(state, tracer, s_4_447);
        // C s_4_449: const #() : ()
        let s_4_449: () = ();
        // S s_4_450: call TTBCR_read(s_4_449)
        let s_4_450: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_449);
        // C s_4_451: const #0u : u8
        let s_4_451: u8 = 0;
        // S s_4_452: call _update_TTBCR_Type_N(s_4_450, s_4_451)
        let s_4_452: ProductType700c18a878c5601b = u_update_TTBCR_Type_N(
            state,
            tracer,
            s_4_450,
            s_4_451,
        );
        // S s_4_453: call TTBCR_write(s_4_452)
        let s_4_453: () = TTBCR_write(state, tracer, s_4_452);
        // C s_4_454: const #() : ()
        let s_4_454: () = ();
        // S s_4_455: call TTBCR_read(s_4_454)
        let s_4_455: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_454);
        // C s_4_456: const #0u : u8
        let s_4_456: bool = false;
        // S s_4_457: call _update_TTBCR_Type_EAE(s_4_455, s_4_456)
        let s_4_457: ProductType700c18a878c5601b = u_update_TTBCR_Type_EAE(
            state,
            tracer,
            s_4_455,
            s_4_456,
        );
        // S s_4_458: call TTBCR_write(s_4_457)
        let s_4_458: () = TTBCR_write(state, tracer, s_4_457);
        // C s_4_459: const #() : ()
        let s_4_459: () = ();
        // S s_4_460: call TTBCR_read(s_4_459)
        let s_4_460: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_459);
        // D s_4_461: write-var ga#34878 <= s_4_460
        fn_state.ga_34878 = s_4_460;
        // D s_4_462: read-var ga#34878.0:struct
        let s_4_462: u32 = fn_state.ga_34878._0;
        // C s_4_463: const #1s : i
        let s_4_463: i128 = 1;
        // C s_4_464: const #30s : i
        let s_4_464: i128 = 30;
        // D s_4_465: cast zx s_4_462 -> bv
        let s_4_465: Bits = Bits::new(s_4_462 as u128, 32u16);
        // C s_4_466: const #0u : u8
        let s_4_466: bool = false;
        // C s_4_467: cast zx s_4_466 -> bv
        let s_4_467: Bits = Bits::new(s_4_466 as u128, 1u16);
        // C s_4_468: const #1u : u64
        let s_4_468: u64 = 1;
        // C s_4_469: cast zx s_4_468 -> bv
        let s_4_469: Bits = Bits::new(s_4_468 as u128, 64u16);
        // C s_4_470: lsl s_4_469 s_4_463
        let s_4_470: Bits = s_4_469 << s_4_463;
        // C s_4_471: sub s_4_470 s_4_469
        let s_4_471: Bits = ((s_4_470) - (s_4_469));
        // C s_4_472: and s_4_467 s_4_471
        let s_4_472: Bits = ((s_4_467) & (s_4_471));
        // C s_4_473: lsl s_4_472 s_4_464
        let s_4_473: Bits = s_4_472 << s_4_464;
        // C s_4_474: lsl s_4_471 s_4_464
        let s_4_474: Bits = s_4_471 << s_4_464;
        // C s_4_475: cmpl s_4_474
        let s_4_475: Bits = !s_4_474;
        // D s_4_476: and s_4_465 s_4_475
        let s_4_476: Bits = ((s_4_465) & (s_4_475));
        // D s_4_477: or s_4_476 s_4_473
        let s_4_477: Bits = ((s_4_476) | (s_4_473));
        // D s_4_478: cast reint s_4_477 -> u32
        let s_4_478: u32 = (s_4_477.value() as u32);
        // D s_4_479: call Mk_TTBCR_Type(s_4_478)
        let s_4_479: ProductType700c18a878c5601b = Mk_TTBCR_Type(state, tracer, s_4_478);
        // D s_4_480: call TTBCR_write(s_4_479)
        let s_4_480: () = TTBCR_write(state, tracer, s_4_479);
        // C s_4_481: const #() : ()
        let s_4_481: () = ();
        // S s_4_482: call TTBCR_read(s_4_481)
        let s_4_482: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_481);
        // C s_4_483: const #0u : u8
        let s_4_483: u8 = 0;
        // S s_4_484: call _update_TTBCR_Type_SH1(s_4_482, s_4_483)
        let s_4_484: ProductType700c18a878c5601b = u_update_TTBCR_Type_SH1(
            state,
            tracer,
            s_4_482,
            s_4_483,
        );
        // S s_4_485: call TTBCR_write(s_4_484)
        let s_4_485: () = TTBCR_write(state, tracer, s_4_484);
        // C s_4_486: const #() : ()
        let s_4_486: () = ();
        // S s_4_487: call TTBCR_read(s_4_486)
        let s_4_487: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_486);
        // C s_4_488: const #0u : u8
        let s_4_488: u8 = 0;
        // S s_4_489: call _update_TTBCR_Type_ORGN1(s_4_487, s_4_488)
        let s_4_489: ProductType700c18a878c5601b = u_update_TTBCR_Type_ORGN1(
            state,
            tracer,
            s_4_487,
            s_4_488,
        );
        // S s_4_490: call TTBCR_write(s_4_489)
        let s_4_490: () = TTBCR_write(state, tracer, s_4_489);
        // C s_4_491: const #() : ()
        let s_4_491: () = ();
        // S s_4_492: call TTBCR_read(s_4_491)
        let s_4_492: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_491);
        // C s_4_493: const #0u : u8
        let s_4_493: u8 = 0;
        // S s_4_494: call _update_TTBCR_Type_IRGN1(s_4_492, s_4_493)
        let s_4_494: ProductType700c18a878c5601b = u_update_TTBCR_Type_IRGN1(
            state,
            tracer,
            s_4_492,
            s_4_493,
        );
        // S s_4_495: call TTBCR_write(s_4_494)
        let s_4_495: () = TTBCR_write(state, tracer, s_4_494);
        // C s_4_496: const #() : ()
        let s_4_496: () = ();
        // S s_4_497: call TTBCR_read(s_4_496)
        let s_4_497: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_496);
        // C s_4_498: const #0u : u8
        let s_4_498: bool = false;
        // S s_4_499: call _update_TTBCR_Type_EPD1(s_4_497, s_4_498)
        let s_4_499: ProductType700c18a878c5601b = u_update_TTBCR_Type_EPD1(
            state,
            tracer,
            s_4_497,
            s_4_498,
        );
        // S s_4_500: call TTBCR_write(s_4_499)
        let s_4_500: () = TTBCR_write(state, tracer, s_4_499);
        // C s_4_501: const #() : ()
        let s_4_501: () = ();
        // S s_4_502: call TTBCR_read(s_4_501)
        let s_4_502: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_501);
        // C s_4_503: const #0u : u8
        let s_4_503: bool = false;
        // S s_4_504: call _update_TTBCR_Type_A1(s_4_502, s_4_503)
        let s_4_504: ProductType700c18a878c5601b = u_update_TTBCR_Type_A1(
            state,
            tracer,
            s_4_502,
            s_4_503,
        );
        // S s_4_505: call TTBCR_write(s_4_504)
        let s_4_505: () = TTBCR_write(state, tracer, s_4_504);
        // C s_4_506: const #() : ()
        let s_4_506: () = ();
        // S s_4_507: call TTBCR_read(s_4_506)
        let s_4_507: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_506);
        // D s_4_508: write-var ga#34892 <= s_4_507
        fn_state.ga_34892 = s_4_507;
        // D s_4_509: read-var ga#34892.0:struct
        let s_4_509: u32 = fn_state.ga_34892._0;
        // C s_4_510: const #3s : i
        let s_4_510: i128 = 3;
        // C s_4_511: const #19s : i
        let s_4_511: i128 = 19;
        // D s_4_512: cast zx s_4_509 -> bv
        let s_4_512: Bits = Bits::new(s_4_509 as u128, 32u16);
        // C s_4_513: const #0u : u8
        let s_4_513: u8 = 0;
        // C s_4_514: cast zx s_4_513 -> bv
        let s_4_514: Bits = Bits::new(s_4_513 as u128, 3u16);
        // C s_4_515: const #1u : u64
        let s_4_515: u64 = 1;
        // C s_4_516: cast zx s_4_515 -> bv
        let s_4_516: Bits = Bits::new(s_4_515 as u128, 64u16);
        // C s_4_517: lsl s_4_516 s_4_510
        let s_4_517: Bits = s_4_516 << s_4_510;
        // C s_4_518: sub s_4_517 s_4_516
        let s_4_518: Bits = ((s_4_517) - (s_4_516));
        // C s_4_519: and s_4_514 s_4_518
        let s_4_519: Bits = ((s_4_514) & (s_4_518));
        // C s_4_520: lsl s_4_519 s_4_511
        let s_4_520: Bits = s_4_519 << s_4_511;
        // C s_4_521: lsl s_4_518 s_4_511
        let s_4_521: Bits = s_4_518 << s_4_511;
        // C s_4_522: cmpl s_4_521
        let s_4_522: Bits = !s_4_521;
        // D s_4_523: and s_4_512 s_4_522
        let s_4_523: Bits = ((s_4_512) & (s_4_522));
        // D s_4_524: or s_4_523 s_4_520
        let s_4_524: Bits = ((s_4_523) | (s_4_520));
        // D s_4_525: cast reint s_4_524 -> u32
        let s_4_525: u32 = (s_4_524.value() as u32);
        // D s_4_526: call Mk_TTBCR_Type(s_4_525)
        let s_4_526: ProductType700c18a878c5601b = Mk_TTBCR_Type(state, tracer, s_4_525);
        // D s_4_527: call TTBCR_write(s_4_526)
        let s_4_527: () = TTBCR_write(state, tracer, s_4_526);
        // C s_4_528: const #() : ()
        let s_4_528: () = ();
        // S s_4_529: call TTBCR_read(s_4_528)
        let s_4_529: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_528);
        // C s_4_530: const #0u : u8
        let s_4_530: u8 = 0;
        // S s_4_531: call _update_TTBCR_Type_T1SZ(s_4_529, s_4_530)
        let s_4_531: ProductType700c18a878c5601b = u_update_TTBCR_Type_T1SZ(
            state,
            tracer,
            s_4_529,
            s_4_530,
        );
        // S s_4_532: call TTBCR_write(s_4_531)
        let s_4_532: () = TTBCR_write(state, tracer, s_4_531);
        // C s_4_533: const #() : ()
        let s_4_533: () = ();
        // S s_4_534: call TTBCR_read(s_4_533)
        let s_4_534: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_533);
        // D s_4_535: write-var ga#34898 <= s_4_534
        fn_state.ga_34898 = s_4_534;
        // D s_4_536: read-var ga#34898.0:struct
        let s_4_536: u32 = fn_state.ga_34898._0;
        // C s_4_537: const #2s : i
        let s_4_537: i128 = 2;
        // C s_4_538: const #14s : i
        let s_4_538: i128 = 14;
        // D s_4_539: cast zx s_4_536 -> bv
        let s_4_539: Bits = Bits::new(s_4_536 as u128, 32u16);
        // C s_4_540: const #0u : u8
        let s_4_540: u8 = 0;
        // C s_4_541: cast zx s_4_540 -> bv
        let s_4_541: Bits = Bits::new(s_4_540 as u128, 2u16);
        // C s_4_542: const #1u : u64
        let s_4_542: u64 = 1;
        // C s_4_543: cast zx s_4_542 -> bv
        let s_4_543: Bits = Bits::new(s_4_542 as u128, 64u16);
        // C s_4_544: lsl s_4_543 s_4_537
        let s_4_544: Bits = s_4_543 << s_4_537;
        // C s_4_545: sub s_4_544 s_4_543
        let s_4_545: Bits = ((s_4_544) - (s_4_543));
        // C s_4_546: and s_4_541 s_4_545
        let s_4_546: Bits = ((s_4_541) & (s_4_545));
        // C s_4_547: lsl s_4_546 s_4_538
        let s_4_547: Bits = s_4_546 << s_4_538;
        // C s_4_548: lsl s_4_545 s_4_538
        let s_4_548: Bits = s_4_545 << s_4_538;
        // C s_4_549: cmpl s_4_548
        let s_4_549: Bits = !s_4_548;
        // D s_4_550: and s_4_539 s_4_549
        let s_4_550: Bits = ((s_4_539) & (s_4_549));
        // D s_4_551: or s_4_550 s_4_547
        let s_4_551: Bits = ((s_4_550) | (s_4_547));
        // D s_4_552: cast reint s_4_551 -> u32
        let s_4_552: u32 = (s_4_551.value() as u32);
        // D s_4_553: call Mk_TTBCR_Type(s_4_552)
        let s_4_553: ProductType700c18a878c5601b = Mk_TTBCR_Type(state, tracer, s_4_552);
        // D s_4_554: call TTBCR_write(s_4_553)
        let s_4_554: () = TTBCR_write(state, tracer, s_4_553);
        // C s_4_555: const #() : ()
        let s_4_555: () = ();
        // S s_4_556: call TTBCR_read(s_4_555)
        let s_4_556: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_555);
        // C s_4_557: const #0u : u8
        let s_4_557: u8 = 0;
        // S s_4_558: call _update_TTBCR_Type_SH0(s_4_556, s_4_557)
        let s_4_558: ProductType700c18a878c5601b = u_update_TTBCR_Type_SH0(
            state,
            tracer,
            s_4_556,
            s_4_557,
        );
        // S s_4_559: call TTBCR_write(s_4_558)
        let s_4_559: () = TTBCR_write(state, tracer, s_4_558);
        // C s_4_560: const #() : ()
        let s_4_560: () = ();
        // S s_4_561: call TTBCR_read(s_4_560)
        let s_4_561: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_560);
        // C s_4_562: const #0u : u8
        let s_4_562: u8 = 0;
        // S s_4_563: call _update_TTBCR_Type_ORGN0(s_4_561, s_4_562)
        let s_4_563: ProductType700c18a878c5601b = u_update_TTBCR_Type_ORGN0(
            state,
            tracer,
            s_4_561,
            s_4_562,
        );
        // S s_4_564: call TTBCR_write(s_4_563)
        let s_4_564: () = TTBCR_write(state, tracer, s_4_563);
        // C s_4_565: const #() : ()
        let s_4_565: () = ();
        // S s_4_566: call TTBCR_read(s_4_565)
        let s_4_566: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_565);
        // C s_4_567: const #0u : u8
        let s_4_567: u8 = 0;
        // S s_4_568: call _update_TTBCR_Type_IRGN0(s_4_566, s_4_567)
        let s_4_568: ProductType700c18a878c5601b = u_update_TTBCR_Type_IRGN0(
            state,
            tracer,
            s_4_566,
            s_4_567,
        );
        // S s_4_569: call TTBCR_write(s_4_568)
        let s_4_569: () = TTBCR_write(state, tracer, s_4_568);
        // C s_4_570: const #() : ()
        let s_4_570: () = ();
        // S s_4_571: call TTBCR_read(s_4_570)
        let s_4_571: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_570);
        // C s_4_572: const #0u : u8
        let s_4_572: bool = false;
        // S s_4_573: call _update_TTBCR_Type_EPD0(s_4_571, s_4_572)
        let s_4_573: ProductType700c18a878c5601b = u_update_TTBCR_Type_EPD0(
            state,
            tracer,
            s_4_571,
            s_4_572,
        );
        // S s_4_574: call TTBCR_write(s_4_573)
        let s_4_574: () = TTBCR_write(state, tracer, s_4_573);
        // C s_4_575: const #() : ()
        let s_4_575: () = ();
        // S s_4_576: call TTBCR_read(s_4_575)
        let s_4_576: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_575);
        // D s_4_577: write-var ga#34910 <= s_4_576
        fn_state.ga_34910 = s_4_576;
        // D s_4_578: read-var ga#34910.0:struct
        let s_4_578: u32 = fn_state.ga_34910._0;
        // C s_4_579: const #3s : i
        let s_4_579: i128 = 3;
        // C s_4_580: const #3s : i
        let s_4_580: i128 = 3;
        // D s_4_581: cast zx s_4_578 -> bv
        let s_4_581: Bits = Bits::new(s_4_578 as u128, 32u16);
        // C s_4_582: const #0u : u8
        let s_4_582: u8 = 0;
        // C s_4_583: cast zx s_4_582 -> bv
        let s_4_583: Bits = Bits::new(s_4_582 as u128, 3u16);
        // C s_4_584: const #1u : u64
        let s_4_584: u64 = 1;
        // C s_4_585: cast zx s_4_584 -> bv
        let s_4_585: Bits = Bits::new(s_4_584 as u128, 64u16);
        // C s_4_586: lsl s_4_585 s_4_579
        let s_4_586: Bits = s_4_585 << s_4_579;
        // C s_4_587: sub s_4_586 s_4_585
        let s_4_587: Bits = ((s_4_586) - (s_4_585));
        // C s_4_588: and s_4_583 s_4_587
        let s_4_588: Bits = ((s_4_583) & (s_4_587));
        // C s_4_589: lsl s_4_588 s_4_580
        let s_4_589: Bits = s_4_588 << s_4_580;
        // C s_4_590: lsl s_4_587 s_4_580
        let s_4_590: Bits = s_4_587 << s_4_580;
        // C s_4_591: cmpl s_4_590
        let s_4_591: Bits = !s_4_590;
        // D s_4_592: and s_4_581 s_4_591
        let s_4_592: Bits = ((s_4_581) & (s_4_591));
        // D s_4_593: or s_4_592 s_4_589
        let s_4_593: Bits = ((s_4_592) | (s_4_589));
        // D s_4_594: cast reint s_4_593 -> u32
        let s_4_594: u32 = (s_4_593.value() as u32);
        // D s_4_595: call Mk_TTBCR_Type(s_4_594)
        let s_4_595: ProductType700c18a878c5601b = Mk_TTBCR_Type(state, tracer, s_4_594);
        // D s_4_596: call TTBCR_write(s_4_595)
        let s_4_596: () = TTBCR_write(state, tracer, s_4_595);
        // C s_4_597: const #() : ()
        let s_4_597: () = ();
        // S s_4_598: call TTBCR_read(s_4_597)
        let s_4_598: ProductType700c18a878c5601b = TTBCR_read(state, tracer, s_4_597);
        // C s_4_599: const #0u : u8
        let s_4_599: u8 = 0;
        // S s_4_600: call _update_TTBCR_Type_T0SZ(s_4_598, s_4_599)
        let s_4_600: ProductType700c18a878c5601b = u_update_TTBCR_Type_T0SZ(
            state,
            tracer,
            s_4_598,
            s_4_599,
        );
        // S s_4_601: call TTBCR_write(s_4_600)
        let s_4_601: () = TTBCR_write(state, tracer, s_4_600);
        // C s_4_602: const #() : ()
        let s_4_602: () = ();
        // S s_4_603: call HCR_read(s_4_602)
        let s_4_603: ProductType700c18a878c5601b = HCR_read(state, tracer, s_4_602);
        // D s_4_604: write-var ga#34916 <= s_4_603
        fn_state.ga_34916 = s_4_603;
        // D s_4_605: read-var ga#34916.0:struct
        let s_4_605: u32 = fn_state.ga_34916._0;
        // C s_4_606: const #1s : i
        let s_4_606: i128 = 1;
        // C s_4_607: const #31s : i
        let s_4_607: i128 = 31;
        // D s_4_608: cast zx s_4_605 -> bv
        let s_4_608: Bits = Bits::new(s_4_605 as u128, 32u16);
        // C s_4_609: const #0u : u8
        let s_4_609: bool = false;
        // C s_4_610: cast zx s_4_609 -> bv
        let s_4_610: Bits = Bits::new(s_4_609 as u128, 1u16);
        // C s_4_611: const #1u : u64
        let s_4_611: u64 = 1;
        // C s_4_612: cast zx s_4_611 -> bv
        let s_4_612: Bits = Bits::new(s_4_611 as u128, 64u16);
        // C s_4_613: lsl s_4_612 s_4_606
        let s_4_613: Bits = s_4_612 << s_4_606;
        // C s_4_614: sub s_4_613 s_4_612
        let s_4_614: Bits = ((s_4_613) - (s_4_612));
        // C s_4_615: and s_4_610 s_4_614
        let s_4_615: Bits = ((s_4_610) & (s_4_614));
        // C s_4_616: lsl s_4_615 s_4_607
        let s_4_616: Bits = s_4_615 << s_4_607;
        // C s_4_617: lsl s_4_614 s_4_607
        let s_4_617: Bits = s_4_614 << s_4_607;
        // C s_4_618: cmpl s_4_617
        let s_4_618: Bits = !s_4_617;
        // D s_4_619: and s_4_608 s_4_618
        let s_4_619: Bits = ((s_4_608) & (s_4_618));
        // D s_4_620: or s_4_619 s_4_616
        let s_4_620: Bits = ((s_4_619) | (s_4_616));
        // D s_4_621: cast reint s_4_620 -> u32
        let s_4_621: u32 = (s_4_620.value() as u32);
        // D s_4_622: call Mk_HCR_Type(s_4_621)
        let s_4_622: ProductType700c18a878c5601b = Mk_HCR_Type(state, tracer, s_4_621);
        // D s_4_623: call HCR_write(s_4_622)
        let s_4_623: () = HCR_write(state, tracer, s_4_622);
        // D s_4_624: read-var cold:u8
        let s_4_624: bool = fn_state.cold;
        // D s_4_625: not s_4_624
        let s_4_625: bool = !s_4_624;
        // N s_4_626: branch s_4_625 b649 b5
        if s_4_625 {
            return block_649(state, tracer, fn_state);
        } else {
            return block_5(state, tracer, fn_state);
        };
    }
    fn block_5<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_5_0: const #0u : u8
        let s_5_0: bool = false;
        // D s_5_1: write-var gs#43980 <= s_5_0
        fn_state.gs_43980 = s_5_0;
        // N s_5_2: jump b6
        return block_6(state, tracer, fn_state);
    }
    fn block_6<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_6_0: read-var gs#43980:u8
        let s_6_0: bool = fn_state.gs_43980;
        // N s_6_1: branch s_6_0 b648 b7
        if s_6_0 {
            return block_648(state, tracer, fn_state);
        } else {
            return block_7(state, tracer, fn_state);
        };
    }
    fn block_7<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_7_0: const #() : ()
        let s_7_0: () = ();
        // S s_7_1: call HCR_read(s_7_0)
        let s_7_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_7_0);
        // C s_7_2: const #1s : i64
        let s_7_2: i64 = 1;
        // C s_7_3: cast zx s_7_2 -> i
        let s_7_3: i128 = (i128::try_from(s_7_2).unwrap());
        // S s_7_4: call __UNKNOWN_bits(s_7_3)
        let s_7_4: Bits = u__UNKNOWN_bits(state, tracer, s_7_3);
        // S s_7_5: cast reint s_7_4 -> u8
        let s_7_5: bool = ((s_7_4.value()) != 0);
        // S s_7_6: call _update_HCR_Type_TRVM(s_7_1, s_7_5)
        let s_7_6: ProductType700c18a878c5601b = u_update_HCR_Type_TRVM(
            state,
            tracer,
            s_7_1,
            s_7_5,
        );
        // S s_7_7: call HCR_write(s_7_6)
        let s_7_7: () = HCR_write(state, tracer, s_7_6);
        // N s_7_8: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_8<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_8_0: read-var cold:u8
        let s_8_0: bool = fn_state.cold;
        // D s_8_1: not s_8_0
        let s_8_1: bool = !s_8_0;
        // N s_8_2: branch s_8_1 b647 b9
        if s_8_1 {
            return block_647(state, tracer, fn_state);
        } else {
            return block_9(state, tracer, fn_state);
        };
    }
    fn block_9<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_9_0: const #0u : u8
        let s_9_0: bool = false;
        // D s_9_1: write-var gs#43981 <= s_9_0
        fn_state.gs_43981 = s_9_0;
        // N s_9_2: jump b10
        return block_10(state, tracer, fn_state);
    }
    fn block_10<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_10_0: read-var gs#43981:u8
        let s_10_0: bool = fn_state.gs_43981;
        // N s_10_1: branch s_10_0 b646 b11
        if s_10_0 {
            return block_646(state, tracer, fn_state);
        } else {
            return block_11(state, tracer, fn_state);
        };
    }
    fn block_11<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_11_0: const #() : ()
        let s_11_0: () = ();
        // S s_11_1: call HCR_read(s_11_0)
        let s_11_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_11_0);
        // C s_11_2: const #1s : i64
        let s_11_2: i64 = 1;
        // C s_11_3: cast zx s_11_2 -> i
        let s_11_3: i128 = (i128::try_from(s_11_2).unwrap());
        // S s_11_4: call __UNKNOWN_bits(s_11_3)
        let s_11_4: Bits = u__UNKNOWN_bits(state, tracer, s_11_3);
        // S s_11_5: cast reint s_11_4 -> u8
        let s_11_5: bool = ((s_11_4.value()) != 0);
        // S s_11_6: call _update_HCR_Type_HCD(s_11_1, s_11_5)
        let s_11_6: ProductType700c18a878c5601b = u_update_HCR_Type_HCD(
            state,
            tracer,
            s_11_1,
            s_11_5,
        );
        // S s_11_7: call HCR_write(s_11_6)
        let s_11_7: () = HCR_write(state, tracer, s_11_6);
        // N s_11_8: jump b12
        return block_12(state, tracer, fn_state);
    }
    fn block_12<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_12_0: const #() : ()
        let s_12_0: () = ();
        // S s_12_1: call HCR_read(s_12_0)
        let s_12_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_12_0);
        // D s_12_2: write-var ga#34936 <= s_12_1
        fn_state.ga_34936 = s_12_1;
        // D s_12_3: read-var ga#34936.0:struct
        let s_12_3: u32 = fn_state.ga_34936._0;
        // C s_12_4: const #1s : i
        let s_12_4: i128 = 1;
        // C s_12_5: const #28s : i
        let s_12_5: i128 = 28;
        // D s_12_6: cast zx s_12_3 -> bv
        let s_12_6: Bits = Bits::new(s_12_3 as u128, 32u16);
        // C s_12_7: const #0u : u8
        let s_12_7: bool = false;
        // C s_12_8: cast zx s_12_7 -> bv
        let s_12_8: Bits = Bits::new(s_12_7 as u128, 1u16);
        // C s_12_9: const #1u : u64
        let s_12_9: u64 = 1;
        // C s_12_10: cast zx s_12_9 -> bv
        let s_12_10: Bits = Bits::new(s_12_9 as u128, 64u16);
        // C s_12_11: lsl s_12_10 s_12_4
        let s_12_11: Bits = s_12_10 << s_12_4;
        // C s_12_12: sub s_12_11 s_12_10
        let s_12_12: Bits = ((s_12_11) - (s_12_10));
        // C s_12_13: and s_12_8 s_12_12
        let s_12_13: Bits = ((s_12_8) & (s_12_12));
        // C s_12_14: lsl s_12_13 s_12_5
        let s_12_14: Bits = s_12_13 << s_12_5;
        // C s_12_15: lsl s_12_12 s_12_5
        let s_12_15: Bits = s_12_12 << s_12_5;
        // C s_12_16: cmpl s_12_15
        let s_12_16: Bits = !s_12_15;
        // D s_12_17: and s_12_6 s_12_16
        let s_12_17: Bits = ((s_12_6) & (s_12_16));
        // D s_12_18: or s_12_17 s_12_14
        let s_12_18: Bits = ((s_12_17) | (s_12_14));
        // D s_12_19: cast reint s_12_18 -> u32
        let s_12_19: u32 = (s_12_18.value() as u32);
        // D s_12_20: call Mk_HCR_Type(s_12_19)
        let s_12_20: ProductType700c18a878c5601b = Mk_HCR_Type(state, tracer, s_12_19);
        // D s_12_21: call HCR_write(s_12_20)
        let s_12_21: () = HCR_write(state, tracer, s_12_20);
        // D s_12_22: read-var cold:u8
        let s_12_22: bool = fn_state.cold;
        // D s_12_23: not s_12_22
        let s_12_23: bool = !s_12_22;
        // N s_12_24: branch s_12_23 b645 b13
        if s_12_23 {
            return block_645(state, tracer, fn_state);
        } else {
            return block_13(state, tracer, fn_state);
        };
    }
    fn block_13<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_13_0: const #0u : u8
        let s_13_0: bool = false;
        // D s_13_1: write-var gs#43985 <= s_13_0
        fn_state.gs_43985 = s_13_0;
        // N s_13_2: jump b14
        return block_14(state, tracer, fn_state);
    }
    fn block_14<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_14_0: read-var gs#43985:u8
        let s_14_0: bool = fn_state.gs_43985;
        // N s_14_1: branch s_14_0 b644 b15
        if s_14_0 {
            return block_644(state, tracer, fn_state);
        } else {
            return block_15(state, tracer, fn_state);
        };
    }
    fn block_15<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_15_0: const #() : ()
        let s_15_0: () = ();
        // S s_15_1: call HCR_read(s_15_0)
        let s_15_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_15_0);
        // C s_15_2: const #1s : i64
        let s_15_2: i64 = 1;
        // C s_15_3: cast zx s_15_2 -> i
        let s_15_3: i128 = (i128::try_from(s_15_2).unwrap());
        // S s_15_4: call __UNKNOWN_bits(s_15_3)
        let s_15_4: Bits = u__UNKNOWN_bits(state, tracer, s_15_3);
        // S s_15_5: cast reint s_15_4 -> u8
        let s_15_5: bool = ((s_15_4.value()) != 0);
        // S s_15_6: call _update_HCR_Type_TGE(s_15_1, s_15_5)
        let s_15_6: ProductType700c18a878c5601b = u_update_HCR_Type_TGE(
            state,
            tracer,
            s_15_1,
            s_15_5,
        );
        // S s_15_7: call HCR_write(s_15_6)
        let s_15_7: () = HCR_write(state, tracer, s_15_6);
        // N s_15_8: jump b16
        return block_16(state, tracer, fn_state);
    }
    fn block_16<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_16_0: read-var cold:u8
        let s_16_0: bool = fn_state.cold;
        // D s_16_1: not s_16_0
        let s_16_1: bool = !s_16_0;
        // N s_16_2: branch s_16_1 b643 b17
        if s_16_1 {
            return block_643(state, tracer, fn_state);
        } else {
            return block_17(state, tracer, fn_state);
        };
    }
    fn block_17<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_17_0: const #0u : u8
        let s_17_0: bool = false;
        // D s_17_1: write-var gs#43986 <= s_17_0
        fn_state.gs_43986 = s_17_0;
        // N s_17_2: jump b18
        return block_18(state, tracer, fn_state);
    }
    fn block_18<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_18_0: read-var gs#43986:u8
        let s_18_0: bool = fn_state.gs_43986;
        // N s_18_1: branch s_18_0 b642 b19
        if s_18_0 {
            return block_642(state, tracer, fn_state);
        } else {
            return block_19(state, tracer, fn_state);
        };
    }
    fn block_19<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_19_0: const #() : ()
        let s_19_0: () = ();
        // S s_19_1: call HCR_read(s_19_0)
        let s_19_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_19_0);
        // C s_19_2: const #1s : i64
        let s_19_2: i64 = 1;
        // C s_19_3: cast zx s_19_2 -> i
        let s_19_3: i128 = (i128::try_from(s_19_2).unwrap());
        // S s_19_4: call __UNKNOWN_bits(s_19_3)
        let s_19_4: Bits = u__UNKNOWN_bits(state, tracer, s_19_3);
        // S s_19_5: cast reint s_19_4 -> u8
        let s_19_5: bool = ((s_19_4.value()) != 0);
        // S s_19_6: call _update_HCR_Type_TVM(s_19_1, s_19_5)
        let s_19_6: ProductType700c18a878c5601b = u_update_HCR_Type_TVM(
            state,
            tracer,
            s_19_1,
            s_19_5,
        );
        // S s_19_7: call HCR_write(s_19_6)
        let s_19_7: () = HCR_write(state, tracer, s_19_6);
        // N s_19_8: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_20<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_20_0: read-var cold:u8
        let s_20_0: bool = fn_state.cold;
        // D s_20_1: not s_20_0
        let s_20_1: bool = !s_20_0;
        // N s_20_2: branch s_20_1 b641 b21
        if s_20_1 {
            return block_641(state, tracer, fn_state);
        } else {
            return block_21(state, tracer, fn_state);
        };
    }
    fn block_21<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_21_0: const #0u : u8
        let s_21_0: bool = false;
        // D s_21_1: write-var gs#43987 <= s_21_0
        fn_state.gs_43987 = s_21_0;
        // N s_21_2: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_22<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_22_0: read-var gs#43987:u8
        let s_22_0: bool = fn_state.gs_43987;
        // N s_22_1: branch s_22_0 b640 b23
        if s_22_0 {
            return block_640(state, tracer, fn_state);
        } else {
            return block_23(state, tracer, fn_state);
        };
    }
    fn block_23<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_23_0: const #() : ()
        let s_23_0: () = ();
        // S s_23_1: call HCR_read(s_23_0)
        let s_23_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_23_0);
        // C s_23_2: const #1s : i64
        let s_23_2: i64 = 1;
        // C s_23_3: cast zx s_23_2 -> i
        let s_23_3: i128 = (i128::try_from(s_23_2).unwrap());
        // S s_23_4: call __UNKNOWN_bits(s_23_3)
        let s_23_4: Bits = u__UNKNOWN_bits(state, tracer, s_23_3);
        // S s_23_5: cast reint s_23_4 -> u8
        let s_23_5: bool = ((s_23_4.value()) != 0);
        // S s_23_6: call _update_HCR_Type_TTLB(s_23_1, s_23_5)
        let s_23_6: ProductType700c18a878c5601b = u_update_HCR_Type_TTLB(
            state,
            tracer,
            s_23_1,
            s_23_5,
        );
        // S s_23_7: call HCR_write(s_23_6)
        let s_23_7: () = HCR_write(state, tracer, s_23_6);
        // N s_23_8: jump b24
        return block_24(state, tracer, fn_state);
    }
    fn block_24<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_24_0: read-var cold:u8
        let s_24_0: bool = fn_state.cold;
        // D s_24_1: not s_24_0
        let s_24_1: bool = !s_24_0;
        // N s_24_2: branch s_24_1 b639 b25
        if s_24_1 {
            return block_639(state, tracer, fn_state);
        } else {
            return block_25(state, tracer, fn_state);
        };
    }
    fn block_25<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_25_0: const #0u : u8
        let s_25_0: bool = false;
        // D s_25_1: write-var gs#43988 <= s_25_0
        fn_state.gs_43988 = s_25_0;
        // N s_25_2: jump b26
        return block_26(state, tracer, fn_state);
    }
    fn block_26<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_26_0: read-var gs#43988:u8
        let s_26_0: bool = fn_state.gs_43988;
        // N s_26_1: branch s_26_0 b638 b27
        if s_26_0 {
            return block_638(state, tracer, fn_state);
        } else {
            return block_27(state, tracer, fn_state);
        };
    }
    fn block_27<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_27_0: const #() : ()
        let s_27_0: () = ();
        // S s_27_1: call HCR_read(s_27_0)
        let s_27_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_27_0);
        // C s_27_2: const #1s : i64
        let s_27_2: i64 = 1;
        // C s_27_3: cast zx s_27_2 -> i
        let s_27_3: i128 = (i128::try_from(s_27_2).unwrap());
        // S s_27_4: call __UNKNOWN_bits(s_27_3)
        let s_27_4: Bits = u__UNKNOWN_bits(state, tracer, s_27_3);
        // S s_27_5: cast reint s_27_4 -> u8
        let s_27_5: bool = ((s_27_4.value()) != 0);
        // S s_27_6: call _update_HCR_Type_TPU(s_27_1, s_27_5)
        let s_27_6: ProductType700c18a878c5601b = u_update_HCR_Type_TPU(
            state,
            tracer,
            s_27_1,
            s_27_5,
        );
        // S s_27_7: call HCR_write(s_27_6)
        let s_27_7: () = HCR_write(state, tracer, s_27_6);
        // N s_27_8: jump b28
        return block_28(state, tracer, fn_state);
    }
    fn block_28<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_28_0: read-var cold:u8
        let s_28_0: bool = fn_state.cold;
        // D s_28_1: not s_28_0
        let s_28_1: bool = !s_28_0;
        // N s_28_2: branch s_28_1 b637 b29
        if s_28_1 {
            return block_637(state, tracer, fn_state);
        } else {
            return block_29(state, tracer, fn_state);
        };
    }
    fn block_29<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_29_0: const #0u : u8
        let s_29_0: bool = false;
        // D s_29_1: write-var gs#43989 <= s_29_0
        fn_state.gs_43989 = s_29_0;
        // N s_29_2: jump b30
        return block_30(state, tracer, fn_state);
    }
    fn block_30<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_30_0: read-var gs#43989:u8
        let s_30_0: bool = fn_state.gs_43989;
        // N s_30_1: branch s_30_0 b636 b31
        if s_30_0 {
            return block_636(state, tracer, fn_state);
        } else {
            return block_31(state, tracer, fn_state);
        };
    }
    fn block_31<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_31_0: const #() : ()
        let s_31_0: () = ();
        // S s_31_1: call HCR_read(s_31_0)
        let s_31_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_31_0);
        // C s_31_2: const #1s : i64
        let s_31_2: i64 = 1;
        // C s_31_3: cast zx s_31_2 -> i
        let s_31_3: i128 = (i128::try_from(s_31_2).unwrap());
        // S s_31_4: call __UNKNOWN_bits(s_31_3)
        let s_31_4: Bits = u__UNKNOWN_bits(state, tracer, s_31_3);
        // S s_31_5: cast reint s_31_4 -> u8
        let s_31_5: bool = ((s_31_4.value()) != 0);
        // S s_31_6: call _update_HCR_Type_TPC(s_31_1, s_31_5)
        let s_31_6: ProductType700c18a878c5601b = u_update_HCR_Type_TPC(
            state,
            tracer,
            s_31_1,
            s_31_5,
        );
        // S s_31_7: call HCR_write(s_31_6)
        let s_31_7: () = HCR_write(state, tracer, s_31_6);
        // N s_31_8: jump b32
        return block_32(state, tracer, fn_state);
    }
    fn block_32<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_32_0: read-var cold:u8
        let s_32_0: bool = fn_state.cold;
        // D s_32_1: not s_32_0
        let s_32_1: bool = !s_32_0;
        // N s_32_2: branch s_32_1 b635 b33
        if s_32_1 {
            return block_635(state, tracer, fn_state);
        } else {
            return block_33(state, tracer, fn_state);
        };
    }
    fn block_33<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_33_0: const #0u : u8
        let s_33_0: bool = false;
        // D s_33_1: write-var gs#43990 <= s_33_0
        fn_state.gs_43990 = s_33_0;
        // N s_33_2: jump b34
        return block_34(state, tracer, fn_state);
    }
    fn block_34<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_34_0: read-var gs#43990:u8
        let s_34_0: bool = fn_state.gs_43990;
        // N s_34_1: branch s_34_0 b634 b35
        if s_34_0 {
            return block_634(state, tracer, fn_state);
        } else {
            return block_35(state, tracer, fn_state);
        };
    }
    fn block_35<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_35_0: const #() : ()
        let s_35_0: () = ();
        // S s_35_1: call HCR_read(s_35_0)
        let s_35_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_35_0);
        // C s_35_2: const #1s : i64
        let s_35_2: i64 = 1;
        // C s_35_3: cast zx s_35_2 -> i
        let s_35_3: i128 = (i128::try_from(s_35_2).unwrap());
        // S s_35_4: call __UNKNOWN_bits(s_35_3)
        let s_35_4: Bits = u__UNKNOWN_bits(state, tracer, s_35_3);
        // S s_35_5: cast reint s_35_4 -> u8
        let s_35_5: bool = ((s_35_4.value()) != 0);
        // S s_35_6: call _update_HCR_Type_TSW(s_35_1, s_35_5)
        let s_35_6: ProductType700c18a878c5601b = u_update_HCR_Type_TSW(
            state,
            tracer,
            s_35_1,
            s_35_5,
        );
        // S s_35_7: call HCR_write(s_35_6)
        let s_35_7: () = HCR_write(state, tracer, s_35_6);
        // N s_35_8: jump b36
        return block_36(state, tracer, fn_state);
    }
    fn block_36<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_36_0: read-var cold:u8
        let s_36_0: bool = fn_state.cold;
        // D s_36_1: not s_36_0
        let s_36_1: bool = !s_36_0;
        // N s_36_2: branch s_36_1 b633 b37
        if s_36_1 {
            return block_633(state, tracer, fn_state);
        } else {
            return block_37(state, tracer, fn_state);
        };
    }
    fn block_37<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_37_0: const #0u : u8
        let s_37_0: bool = false;
        // D s_37_1: write-var gs#43991 <= s_37_0
        fn_state.gs_43991 = s_37_0;
        // N s_37_2: jump b38
        return block_38(state, tracer, fn_state);
    }
    fn block_38<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_38_0: read-var gs#43991:u8
        let s_38_0: bool = fn_state.gs_43991;
        // N s_38_1: branch s_38_0 b632 b39
        if s_38_0 {
            return block_632(state, tracer, fn_state);
        } else {
            return block_39(state, tracer, fn_state);
        };
    }
    fn block_39<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_39_0: const #() : ()
        let s_39_0: () = ();
        // S s_39_1: call HCR_read(s_39_0)
        let s_39_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_39_0);
        // C s_39_2: const #1s : i64
        let s_39_2: i64 = 1;
        // C s_39_3: cast zx s_39_2 -> i
        let s_39_3: i128 = (i128::try_from(s_39_2).unwrap());
        // S s_39_4: call __UNKNOWN_bits(s_39_3)
        let s_39_4: Bits = u__UNKNOWN_bits(state, tracer, s_39_3);
        // S s_39_5: cast reint s_39_4 -> u8
        let s_39_5: bool = ((s_39_4.value()) != 0);
        // S s_39_6: call _update_HCR_Type_TAC(s_39_1, s_39_5)
        let s_39_6: ProductType700c18a878c5601b = u_update_HCR_Type_TAC(
            state,
            tracer,
            s_39_1,
            s_39_5,
        );
        // S s_39_7: call HCR_write(s_39_6)
        let s_39_7: () = HCR_write(state, tracer, s_39_6);
        // N s_39_8: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_40<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_40_0: read-var cold:u8
        let s_40_0: bool = fn_state.cold;
        // D s_40_1: not s_40_0
        let s_40_1: bool = !s_40_0;
        // N s_40_2: branch s_40_1 b631 b41
        if s_40_1 {
            return block_631(state, tracer, fn_state);
        } else {
            return block_41(state, tracer, fn_state);
        };
    }
    fn block_41<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_41_0: const #0u : u8
        let s_41_0: bool = false;
        // D s_41_1: write-var gs#43992 <= s_41_0
        fn_state.gs_43992 = s_41_0;
        // N s_41_2: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_42<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_42_0: read-var gs#43992:u8
        let s_42_0: bool = fn_state.gs_43992;
        // N s_42_1: branch s_42_0 b630 b43
        if s_42_0 {
            return block_630(state, tracer, fn_state);
        } else {
            return block_43(state, tracer, fn_state);
        };
    }
    fn block_43<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_43_0: const #() : ()
        let s_43_0: () = ();
        // S s_43_1: call HCR_read(s_43_0)
        let s_43_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_43_0);
        // C s_43_2: const #1s : i64
        let s_43_2: i64 = 1;
        // C s_43_3: cast zx s_43_2 -> i
        let s_43_3: i128 = (i128::try_from(s_43_2).unwrap());
        // S s_43_4: call __UNKNOWN_bits(s_43_3)
        let s_43_4: Bits = u__UNKNOWN_bits(state, tracer, s_43_3);
        // S s_43_5: cast reint s_43_4 -> u8
        let s_43_5: bool = ((s_43_4.value()) != 0);
        // S s_43_6: call _update_HCR_Type_TIDCP(s_43_1, s_43_5)
        let s_43_6: ProductType700c18a878c5601b = u_update_HCR_Type_TIDCP(
            state,
            tracer,
            s_43_1,
            s_43_5,
        );
        // S s_43_7: call HCR_write(s_43_6)
        let s_43_7: () = HCR_write(state, tracer, s_43_6);
        // N s_43_8: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_44<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_44_0: read-var cold:u8
        let s_44_0: bool = fn_state.cold;
        // D s_44_1: not s_44_0
        let s_44_1: bool = !s_44_0;
        // N s_44_2: branch s_44_1 b629 b45
        if s_44_1 {
            return block_629(state, tracer, fn_state);
        } else {
            return block_45(state, tracer, fn_state);
        };
    }
    fn block_45<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_45_0: const #0u : u8
        let s_45_0: bool = false;
        // D s_45_1: write-var gs#43993 <= s_45_0
        fn_state.gs_43993 = s_45_0;
        // N s_45_2: jump b46
        return block_46(state, tracer, fn_state);
    }
    fn block_46<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_46_0: read-var gs#43993:u8
        let s_46_0: bool = fn_state.gs_43993;
        // N s_46_1: branch s_46_0 b628 b47
        if s_46_0 {
            return block_628(state, tracer, fn_state);
        } else {
            return block_47(state, tracer, fn_state);
        };
    }
    fn block_47<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_47_0: const #() : ()
        let s_47_0: () = ();
        // S s_47_1: call HCR_read(s_47_0)
        let s_47_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_47_0);
        // C s_47_2: const #1s : i64
        let s_47_2: i64 = 1;
        // C s_47_3: cast zx s_47_2 -> i
        let s_47_3: i128 = (i128::try_from(s_47_2).unwrap());
        // S s_47_4: call __UNKNOWN_bits(s_47_3)
        let s_47_4: Bits = u__UNKNOWN_bits(state, tracer, s_47_3);
        // S s_47_5: cast reint s_47_4 -> u8
        let s_47_5: bool = ((s_47_4.value()) != 0);
        // S s_47_6: call _update_HCR_Type_TSC(s_47_1, s_47_5)
        let s_47_6: ProductType700c18a878c5601b = u_update_HCR_Type_TSC(
            state,
            tracer,
            s_47_1,
            s_47_5,
        );
        // S s_47_7: call HCR_write(s_47_6)
        let s_47_7: () = HCR_write(state, tracer, s_47_6);
        // N s_47_8: jump b48
        return block_48(state, tracer, fn_state);
    }
    fn block_48<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_48_0: read-var cold:u8
        let s_48_0: bool = fn_state.cold;
        // D s_48_1: not s_48_0
        let s_48_1: bool = !s_48_0;
        // N s_48_2: branch s_48_1 b627 b49
        if s_48_1 {
            return block_627(state, tracer, fn_state);
        } else {
            return block_49(state, tracer, fn_state);
        };
    }
    fn block_49<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_49_0: const #0u : u8
        let s_49_0: bool = false;
        // D s_49_1: write-var gs#43994 <= s_49_0
        fn_state.gs_43994 = s_49_0;
        // N s_49_2: jump b50
        return block_50(state, tracer, fn_state);
    }
    fn block_50<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_50_0: read-var gs#43994:u8
        let s_50_0: bool = fn_state.gs_43994;
        // N s_50_1: branch s_50_0 b626 b51
        if s_50_0 {
            return block_626(state, tracer, fn_state);
        } else {
            return block_51(state, tracer, fn_state);
        };
    }
    fn block_51<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_51_0: const #() : ()
        let s_51_0: () = ();
        // S s_51_1: call HCR_read(s_51_0)
        let s_51_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_51_0);
        // C s_51_2: const #1s : i64
        let s_51_2: i64 = 1;
        // C s_51_3: cast zx s_51_2 -> i
        let s_51_3: i128 = (i128::try_from(s_51_2).unwrap());
        // S s_51_4: call __UNKNOWN_bits(s_51_3)
        let s_51_4: Bits = u__UNKNOWN_bits(state, tracer, s_51_3);
        // S s_51_5: cast reint s_51_4 -> u8
        let s_51_5: bool = ((s_51_4.value()) != 0);
        // S s_51_6: call _update_HCR_Type_TID3(s_51_1, s_51_5)
        let s_51_6: ProductType700c18a878c5601b = u_update_HCR_Type_TID3(
            state,
            tracer,
            s_51_1,
            s_51_5,
        );
        // S s_51_7: call HCR_write(s_51_6)
        let s_51_7: () = HCR_write(state, tracer, s_51_6);
        // N s_51_8: jump b52
        return block_52(state, tracer, fn_state);
    }
    fn block_52<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_52_0: read-var cold:u8
        let s_52_0: bool = fn_state.cold;
        // D s_52_1: not s_52_0
        let s_52_1: bool = !s_52_0;
        // N s_52_2: branch s_52_1 b625 b53
        if s_52_1 {
            return block_625(state, tracer, fn_state);
        } else {
            return block_53(state, tracer, fn_state);
        };
    }
    fn block_53<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_53_0: const #0u : u8
        let s_53_0: bool = false;
        // D s_53_1: write-var gs#43995 <= s_53_0
        fn_state.gs_43995 = s_53_0;
        // N s_53_2: jump b54
        return block_54(state, tracer, fn_state);
    }
    fn block_54<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_54_0: read-var gs#43995:u8
        let s_54_0: bool = fn_state.gs_43995;
        // N s_54_1: branch s_54_0 b624 b55
        if s_54_0 {
            return block_624(state, tracer, fn_state);
        } else {
            return block_55(state, tracer, fn_state);
        };
    }
    fn block_55<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_55_0: const #() : ()
        let s_55_0: () = ();
        // S s_55_1: call HCR_read(s_55_0)
        let s_55_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_55_0);
        // C s_55_2: const #1s : i64
        let s_55_2: i64 = 1;
        // C s_55_3: cast zx s_55_2 -> i
        let s_55_3: i128 = (i128::try_from(s_55_2).unwrap());
        // S s_55_4: call __UNKNOWN_bits(s_55_3)
        let s_55_4: Bits = u__UNKNOWN_bits(state, tracer, s_55_3);
        // S s_55_5: cast reint s_55_4 -> u8
        let s_55_5: bool = ((s_55_4.value()) != 0);
        // S s_55_6: call _update_HCR_Type_TID2(s_55_1, s_55_5)
        let s_55_6: ProductType700c18a878c5601b = u_update_HCR_Type_TID2(
            state,
            tracer,
            s_55_1,
            s_55_5,
        );
        // S s_55_7: call HCR_write(s_55_6)
        let s_55_7: () = HCR_write(state, tracer, s_55_6);
        // N s_55_8: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_56<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_56_0: read-var cold:u8
        let s_56_0: bool = fn_state.cold;
        // D s_56_1: not s_56_0
        let s_56_1: bool = !s_56_0;
        // N s_56_2: branch s_56_1 b623 b57
        if s_56_1 {
            return block_623(state, tracer, fn_state);
        } else {
            return block_57(state, tracer, fn_state);
        };
    }
    fn block_57<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_57_0: const #0u : u8
        let s_57_0: bool = false;
        // D s_57_1: write-var gs#43996 <= s_57_0
        fn_state.gs_43996 = s_57_0;
        // N s_57_2: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_58<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_58_0: read-var gs#43996:u8
        let s_58_0: bool = fn_state.gs_43996;
        // N s_58_1: branch s_58_0 b622 b59
        if s_58_0 {
            return block_622(state, tracer, fn_state);
        } else {
            return block_59(state, tracer, fn_state);
        };
    }
    fn block_59<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_59_0: const #() : ()
        let s_59_0: () = ();
        // S s_59_1: call HCR_read(s_59_0)
        let s_59_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_59_0);
        // C s_59_2: const #1s : i64
        let s_59_2: i64 = 1;
        // C s_59_3: cast zx s_59_2 -> i
        let s_59_3: i128 = (i128::try_from(s_59_2).unwrap());
        // S s_59_4: call __UNKNOWN_bits(s_59_3)
        let s_59_4: Bits = u__UNKNOWN_bits(state, tracer, s_59_3);
        // S s_59_5: cast reint s_59_4 -> u8
        let s_59_5: bool = ((s_59_4.value()) != 0);
        // S s_59_6: call _update_HCR_Type_TID1(s_59_1, s_59_5)
        let s_59_6: ProductType700c18a878c5601b = u_update_HCR_Type_TID1(
            state,
            tracer,
            s_59_1,
            s_59_5,
        );
        // S s_59_7: call HCR_write(s_59_6)
        let s_59_7: () = HCR_write(state, tracer, s_59_6);
        // N s_59_8: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_60<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_60_0: read-var cold:u8
        let s_60_0: bool = fn_state.cold;
        // D s_60_1: not s_60_0
        let s_60_1: bool = !s_60_0;
        // N s_60_2: branch s_60_1 b621 b61
        if s_60_1 {
            return block_621(state, tracer, fn_state);
        } else {
            return block_61(state, tracer, fn_state);
        };
    }
    fn block_61<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_61_0: const #0u : u8
        let s_61_0: bool = false;
        // D s_61_1: write-var gs#43997 <= s_61_0
        fn_state.gs_43997 = s_61_0;
        // N s_61_2: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_62<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_62_0: read-var gs#43997:u8
        let s_62_0: bool = fn_state.gs_43997;
        // N s_62_1: branch s_62_0 b620 b63
        if s_62_0 {
            return block_620(state, tracer, fn_state);
        } else {
            return block_63(state, tracer, fn_state);
        };
    }
    fn block_63<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_63_0: const #() : ()
        let s_63_0: () = ();
        // S s_63_1: call HCR_read(s_63_0)
        let s_63_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_63_0);
        // C s_63_2: const #1s : i64
        let s_63_2: i64 = 1;
        // C s_63_3: cast zx s_63_2 -> i
        let s_63_3: i128 = (i128::try_from(s_63_2).unwrap());
        // S s_63_4: call __UNKNOWN_bits(s_63_3)
        let s_63_4: Bits = u__UNKNOWN_bits(state, tracer, s_63_3);
        // S s_63_5: cast reint s_63_4 -> u8
        let s_63_5: bool = ((s_63_4.value()) != 0);
        // S s_63_6: call _update_HCR_Type_TID0(s_63_1, s_63_5)
        let s_63_6: ProductType700c18a878c5601b = u_update_HCR_Type_TID0(
            state,
            tracer,
            s_63_1,
            s_63_5,
        );
        // S s_63_7: call HCR_write(s_63_6)
        let s_63_7: () = HCR_write(state, tracer, s_63_6);
        // N s_63_8: jump b64
        return block_64(state, tracer, fn_state);
    }
    fn block_64<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_64_0: read-var cold:u8
        let s_64_0: bool = fn_state.cold;
        // D s_64_1: not s_64_0
        let s_64_1: bool = !s_64_0;
        // N s_64_2: branch s_64_1 b619 b65
        if s_64_1 {
            return block_619(state, tracer, fn_state);
        } else {
            return block_65(state, tracer, fn_state);
        };
    }
    fn block_65<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_65_0: const #0u : u8
        let s_65_0: bool = false;
        // D s_65_1: write-var gs#43998 <= s_65_0
        fn_state.gs_43998 = s_65_0;
        // N s_65_2: jump b66
        return block_66(state, tracer, fn_state);
    }
    fn block_66<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_66_0: read-var gs#43998:u8
        let s_66_0: bool = fn_state.gs_43998;
        // N s_66_1: branch s_66_0 b618 b67
        if s_66_0 {
            return block_618(state, tracer, fn_state);
        } else {
            return block_67(state, tracer, fn_state);
        };
    }
    fn block_67<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_67_0: const #() : ()
        let s_67_0: () = ();
        // S s_67_1: call HCR_read(s_67_0)
        let s_67_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_67_0);
        // C s_67_2: const #1s : i64
        let s_67_2: i64 = 1;
        // C s_67_3: cast zx s_67_2 -> i
        let s_67_3: i128 = (i128::try_from(s_67_2).unwrap());
        // S s_67_4: call __UNKNOWN_bits(s_67_3)
        let s_67_4: Bits = u__UNKNOWN_bits(state, tracer, s_67_3);
        // S s_67_5: cast reint s_67_4 -> u8
        let s_67_5: bool = ((s_67_4.value()) != 0);
        // S s_67_6: call _update_HCR_Type_TWE(s_67_1, s_67_5)
        let s_67_6: ProductType700c18a878c5601b = u_update_HCR_Type_TWE(
            state,
            tracer,
            s_67_1,
            s_67_5,
        );
        // S s_67_7: call HCR_write(s_67_6)
        let s_67_7: () = HCR_write(state, tracer, s_67_6);
        // N s_67_8: jump b68
        return block_68(state, tracer, fn_state);
    }
    fn block_68<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_68_0: read-var cold:u8
        let s_68_0: bool = fn_state.cold;
        // D s_68_1: not s_68_0
        let s_68_1: bool = !s_68_0;
        // N s_68_2: branch s_68_1 b617 b69
        if s_68_1 {
            return block_617(state, tracer, fn_state);
        } else {
            return block_69(state, tracer, fn_state);
        };
    }
    fn block_69<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_69_0: const #0u : u8
        let s_69_0: bool = false;
        // D s_69_1: write-var gs#43999 <= s_69_0
        fn_state.gs_43999 = s_69_0;
        // N s_69_2: jump b70
        return block_70(state, tracer, fn_state);
    }
    fn block_70<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_70_0: read-var gs#43999:u8
        let s_70_0: bool = fn_state.gs_43999;
        // N s_70_1: branch s_70_0 b616 b71
        if s_70_0 {
            return block_616(state, tracer, fn_state);
        } else {
            return block_71(state, tracer, fn_state);
        };
    }
    fn block_71<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_71_0: const #() : ()
        let s_71_0: () = ();
        // S s_71_1: call HCR_read(s_71_0)
        let s_71_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_71_0);
        // C s_71_2: const #1s : i64
        let s_71_2: i64 = 1;
        // C s_71_3: cast zx s_71_2 -> i
        let s_71_3: i128 = (i128::try_from(s_71_2).unwrap());
        // S s_71_4: call __UNKNOWN_bits(s_71_3)
        let s_71_4: Bits = u__UNKNOWN_bits(state, tracer, s_71_3);
        // S s_71_5: cast reint s_71_4 -> u8
        let s_71_5: bool = ((s_71_4.value()) != 0);
        // S s_71_6: call _update_HCR_Type_TWI(s_71_1, s_71_5)
        let s_71_6: ProductType700c18a878c5601b = u_update_HCR_Type_TWI(
            state,
            tracer,
            s_71_1,
            s_71_5,
        );
        // S s_71_7: call HCR_write(s_71_6)
        let s_71_7: () = HCR_write(state, tracer, s_71_6);
        // N s_71_8: jump b72
        return block_72(state, tracer, fn_state);
    }
    fn block_72<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_72_0: read-var cold:u8
        let s_72_0: bool = fn_state.cold;
        // D s_72_1: not s_72_0
        let s_72_1: bool = !s_72_0;
        // N s_72_2: branch s_72_1 b615 b73
        if s_72_1 {
            return block_615(state, tracer, fn_state);
        } else {
            return block_73(state, tracer, fn_state);
        };
    }
    fn block_73<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_73_0: const #0u : u8
        let s_73_0: bool = false;
        // D s_73_1: write-var gs#44000 <= s_73_0
        fn_state.gs_44000 = s_73_0;
        // N s_73_2: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_74<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_74_0: read-var gs#44000:u8
        let s_74_0: bool = fn_state.gs_44000;
        // N s_74_1: branch s_74_0 b614 b75
        if s_74_0 {
            return block_614(state, tracer, fn_state);
        } else {
            return block_75(state, tracer, fn_state);
        };
    }
    fn block_75<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_75_0: const #() : ()
        let s_75_0: () = ();
        // S s_75_1: call HCR_read(s_75_0)
        let s_75_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_75_0);
        // C s_75_2: const #1s : i64
        let s_75_2: i64 = 1;
        // C s_75_3: cast zx s_75_2 -> i
        let s_75_3: i128 = (i128::try_from(s_75_2).unwrap());
        // S s_75_4: call __UNKNOWN_bits(s_75_3)
        let s_75_4: Bits = u__UNKNOWN_bits(state, tracer, s_75_3);
        // S s_75_5: cast reint s_75_4 -> u8
        let s_75_5: bool = ((s_75_4.value()) != 0);
        // S s_75_6: call _update_HCR_Type_DC(s_75_1, s_75_5)
        let s_75_6: ProductType700c18a878c5601b = u_update_HCR_Type_DC(
            state,
            tracer,
            s_75_1,
            s_75_5,
        );
        // S s_75_7: call HCR_write(s_75_6)
        let s_75_7: () = HCR_write(state, tracer, s_75_6);
        // N s_75_8: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_76<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_76_0: read-var cold:u8
        let s_76_0: bool = fn_state.cold;
        // D s_76_1: not s_76_0
        let s_76_1: bool = !s_76_0;
        // N s_76_2: branch s_76_1 b613 b77
        if s_76_1 {
            return block_613(state, tracer, fn_state);
        } else {
            return block_77(state, tracer, fn_state);
        };
    }
    fn block_77<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_77_0: const #0u : u8
        let s_77_0: bool = false;
        // D s_77_1: write-var gs#44001 <= s_77_0
        fn_state.gs_44001 = s_77_0;
        // N s_77_2: jump b78
        return block_78(state, tracer, fn_state);
    }
    fn block_78<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_78_0: read-var gs#44001:u8
        let s_78_0: bool = fn_state.gs_44001;
        // N s_78_1: branch s_78_0 b612 b79
        if s_78_0 {
            return block_612(state, tracer, fn_state);
        } else {
            return block_79(state, tracer, fn_state);
        };
    }
    fn block_79<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_79_0: const #() : ()
        let s_79_0: () = ();
        // S s_79_1: call HCR_read(s_79_0)
        let s_79_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_79_0);
        // C s_79_2: const #2s : i64
        let s_79_2: i64 = 2;
        // C s_79_3: cast zx s_79_2 -> i
        let s_79_3: i128 = (i128::try_from(s_79_2).unwrap());
        // S s_79_4: call __UNKNOWN_bits(s_79_3)
        let s_79_4: Bits = u__UNKNOWN_bits(state, tracer, s_79_3);
        // S s_79_5: cast reint s_79_4 -> u8
        let s_79_5: u8 = (s_79_4.value() as u8);
        // S s_79_6: call _update_HCR_Type_BSU(s_79_1, s_79_5)
        let s_79_6: ProductType700c18a878c5601b = u_update_HCR_Type_BSU(
            state,
            tracer,
            s_79_1,
            s_79_5,
        );
        // S s_79_7: call HCR_write(s_79_6)
        let s_79_7: () = HCR_write(state, tracer, s_79_6);
        // N s_79_8: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_80<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_80_0: read-var cold:u8
        let s_80_0: bool = fn_state.cold;
        // D s_80_1: not s_80_0
        let s_80_1: bool = !s_80_0;
        // N s_80_2: branch s_80_1 b611 b81
        if s_80_1 {
            return block_611(state, tracer, fn_state);
        } else {
            return block_81(state, tracer, fn_state);
        };
    }
    fn block_81<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_81_0: const #0u : u8
        let s_81_0: bool = false;
        // D s_81_1: write-var gs#44002 <= s_81_0
        fn_state.gs_44002 = s_81_0;
        // N s_81_2: jump b82
        return block_82(state, tracer, fn_state);
    }
    fn block_82<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_82_0: read-var gs#44002:u8
        let s_82_0: bool = fn_state.gs_44002;
        // N s_82_1: branch s_82_0 b610 b83
        if s_82_0 {
            return block_610(state, tracer, fn_state);
        } else {
            return block_83(state, tracer, fn_state);
        };
    }
    fn block_83<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_83_0: const #() : ()
        let s_83_0: () = ();
        // S s_83_1: call HCR_read(s_83_0)
        let s_83_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_83_0);
        // C s_83_2: const #1s : i64
        let s_83_2: i64 = 1;
        // C s_83_3: cast zx s_83_2 -> i
        let s_83_3: i128 = (i128::try_from(s_83_2).unwrap());
        // S s_83_4: call __UNKNOWN_bits(s_83_3)
        let s_83_4: Bits = u__UNKNOWN_bits(state, tracer, s_83_3);
        // S s_83_5: cast reint s_83_4 -> u8
        let s_83_5: bool = ((s_83_4.value()) != 0);
        // S s_83_6: call _update_HCR_Type_FB(s_83_1, s_83_5)
        let s_83_6: ProductType700c18a878c5601b = u_update_HCR_Type_FB(
            state,
            tracer,
            s_83_1,
            s_83_5,
        );
        // S s_83_7: call HCR_write(s_83_6)
        let s_83_7: () = HCR_write(state, tracer, s_83_6);
        // N s_83_8: jump b84
        return block_84(state, tracer, fn_state);
    }
    fn block_84<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_84_0: read-var cold:u8
        let s_84_0: bool = fn_state.cold;
        // D s_84_1: not s_84_0
        let s_84_1: bool = !s_84_0;
        // N s_84_2: branch s_84_1 b609 b85
        if s_84_1 {
            return block_609(state, tracer, fn_state);
        } else {
            return block_85(state, tracer, fn_state);
        };
    }
    fn block_85<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_85_0: const #0u : u8
        let s_85_0: bool = false;
        // D s_85_1: write-var gs#44003 <= s_85_0
        fn_state.gs_44003 = s_85_0;
        // N s_85_2: jump b86
        return block_86(state, tracer, fn_state);
    }
    fn block_86<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_86_0: read-var gs#44003:u8
        let s_86_0: bool = fn_state.gs_44003;
        // N s_86_1: branch s_86_0 b608 b87
        if s_86_0 {
            return block_608(state, tracer, fn_state);
        } else {
            return block_87(state, tracer, fn_state);
        };
    }
    fn block_87<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_87_0: const #() : ()
        let s_87_0: () = ();
        // S s_87_1: call HCR_read(s_87_0)
        let s_87_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_87_0);
        // C s_87_2: const #1s : i64
        let s_87_2: i64 = 1;
        // C s_87_3: cast zx s_87_2 -> i
        let s_87_3: i128 = (i128::try_from(s_87_2).unwrap());
        // S s_87_4: call __UNKNOWN_bits(s_87_3)
        let s_87_4: Bits = u__UNKNOWN_bits(state, tracer, s_87_3);
        // S s_87_5: cast reint s_87_4 -> u8
        let s_87_5: bool = ((s_87_4.value()) != 0);
        // S s_87_6: call _update_HCR_Type_VA(s_87_1, s_87_5)
        let s_87_6: ProductType700c18a878c5601b = u_update_HCR_Type_VA(
            state,
            tracer,
            s_87_1,
            s_87_5,
        );
        // S s_87_7: call HCR_write(s_87_6)
        let s_87_7: () = HCR_write(state, tracer, s_87_6);
        // N s_87_8: jump b88
        return block_88(state, tracer, fn_state);
    }
    fn block_88<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_88_0: read-var cold:u8
        let s_88_0: bool = fn_state.cold;
        // D s_88_1: not s_88_0
        let s_88_1: bool = !s_88_0;
        // N s_88_2: branch s_88_1 b607 b89
        if s_88_1 {
            return block_607(state, tracer, fn_state);
        } else {
            return block_89(state, tracer, fn_state);
        };
    }
    fn block_89<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_89_0: const #0u : u8
        let s_89_0: bool = false;
        // D s_89_1: write-var gs#44004 <= s_89_0
        fn_state.gs_44004 = s_89_0;
        // N s_89_2: jump b90
        return block_90(state, tracer, fn_state);
    }
    fn block_90<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_90_0: read-var gs#44004:u8
        let s_90_0: bool = fn_state.gs_44004;
        // N s_90_1: branch s_90_0 b606 b91
        if s_90_0 {
            return block_606(state, tracer, fn_state);
        } else {
            return block_91(state, tracer, fn_state);
        };
    }
    fn block_91<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_91_0: const #() : ()
        let s_91_0: () = ();
        // S s_91_1: call HCR_read(s_91_0)
        let s_91_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_91_0);
        // C s_91_2: const #1s : i64
        let s_91_2: i64 = 1;
        // C s_91_3: cast zx s_91_2 -> i
        let s_91_3: i128 = (i128::try_from(s_91_2).unwrap());
        // S s_91_4: call __UNKNOWN_bits(s_91_3)
        let s_91_4: Bits = u__UNKNOWN_bits(state, tracer, s_91_3);
        // S s_91_5: cast reint s_91_4 -> u8
        let s_91_5: bool = ((s_91_4.value()) != 0);
        // S s_91_6: call _update_HCR_Type_VI(s_91_1, s_91_5)
        let s_91_6: ProductType700c18a878c5601b = u_update_HCR_Type_VI(
            state,
            tracer,
            s_91_1,
            s_91_5,
        );
        // S s_91_7: call HCR_write(s_91_6)
        let s_91_7: () = HCR_write(state, tracer, s_91_6);
        // N s_91_8: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_92<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_92_0: read-var cold:u8
        let s_92_0: bool = fn_state.cold;
        // D s_92_1: not s_92_0
        let s_92_1: bool = !s_92_0;
        // N s_92_2: branch s_92_1 b605 b93
        if s_92_1 {
            return block_605(state, tracer, fn_state);
        } else {
            return block_93(state, tracer, fn_state);
        };
    }
    fn block_93<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_93_0: const #0u : u8
        let s_93_0: bool = false;
        // D s_93_1: write-var gs#44005 <= s_93_0
        fn_state.gs_44005 = s_93_0;
        // N s_93_2: jump b94
        return block_94(state, tracer, fn_state);
    }
    fn block_94<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_94_0: read-var gs#44005:u8
        let s_94_0: bool = fn_state.gs_44005;
        // N s_94_1: branch s_94_0 b604 b95
        if s_94_0 {
            return block_604(state, tracer, fn_state);
        } else {
            return block_95(state, tracer, fn_state);
        };
    }
    fn block_95<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_95_0: const #() : ()
        let s_95_0: () = ();
        // S s_95_1: call HCR_read(s_95_0)
        let s_95_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_95_0);
        // C s_95_2: const #1s : i64
        let s_95_2: i64 = 1;
        // C s_95_3: cast zx s_95_2 -> i
        let s_95_3: i128 = (i128::try_from(s_95_2).unwrap());
        // S s_95_4: call __UNKNOWN_bits(s_95_3)
        let s_95_4: Bits = u__UNKNOWN_bits(state, tracer, s_95_3);
        // S s_95_5: cast reint s_95_4 -> u8
        let s_95_5: bool = ((s_95_4.value()) != 0);
        // S s_95_6: call _update_HCR_Type_VF(s_95_1, s_95_5)
        let s_95_6: ProductType700c18a878c5601b = u_update_HCR_Type_VF(
            state,
            tracer,
            s_95_1,
            s_95_5,
        );
        // S s_95_7: call HCR_write(s_95_6)
        let s_95_7: () = HCR_write(state, tracer, s_95_6);
        // N s_95_8: jump b96
        return block_96(state, tracer, fn_state);
    }
    fn block_96<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_96_0: read-var cold:u8
        let s_96_0: bool = fn_state.cold;
        // D s_96_1: not s_96_0
        let s_96_1: bool = !s_96_0;
        // N s_96_2: branch s_96_1 b603 b97
        if s_96_1 {
            return block_603(state, tracer, fn_state);
        } else {
            return block_97(state, tracer, fn_state);
        };
    }
    fn block_97<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_97_0: const #0u : u8
        let s_97_0: bool = false;
        // D s_97_1: write-var gs#44006 <= s_97_0
        fn_state.gs_44006 = s_97_0;
        // N s_97_2: jump b98
        return block_98(state, tracer, fn_state);
    }
    fn block_98<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_98_0: read-var gs#44006:u8
        let s_98_0: bool = fn_state.gs_44006;
        // N s_98_1: branch s_98_0 b602 b99
        if s_98_0 {
            return block_602(state, tracer, fn_state);
        } else {
            return block_99(state, tracer, fn_state);
        };
    }
    fn block_99<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_99_0: const #() : ()
        let s_99_0: () = ();
        // S s_99_1: call HCR_read(s_99_0)
        let s_99_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_99_0);
        // C s_99_2: const #1s : i64
        let s_99_2: i64 = 1;
        // C s_99_3: cast zx s_99_2 -> i
        let s_99_3: i128 = (i128::try_from(s_99_2).unwrap());
        // S s_99_4: call __UNKNOWN_bits(s_99_3)
        let s_99_4: Bits = u__UNKNOWN_bits(state, tracer, s_99_3);
        // S s_99_5: cast reint s_99_4 -> u8
        let s_99_5: bool = ((s_99_4.value()) != 0);
        // S s_99_6: call _update_HCR_Type_AMO(s_99_1, s_99_5)
        let s_99_6: ProductType700c18a878c5601b = u_update_HCR_Type_AMO(
            state,
            tracer,
            s_99_1,
            s_99_5,
        );
        // S s_99_7: call HCR_write(s_99_6)
        let s_99_7: () = HCR_write(state, tracer, s_99_6);
        // N s_99_8: jump b100
        return block_100(state, tracer, fn_state);
    }
    fn block_100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_100_0: read-var cold:u8
        let s_100_0: bool = fn_state.cold;
        // D s_100_1: not s_100_0
        let s_100_1: bool = !s_100_0;
        // N s_100_2: branch s_100_1 b601 b101
        if s_100_1 {
            return block_601(state, tracer, fn_state);
        } else {
            return block_101(state, tracer, fn_state);
        };
    }
    fn block_101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_101_0: const #0u : u8
        let s_101_0: bool = false;
        // D s_101_1: write-var gs#44007 <= s_101_0
        fn_state.gs_44007 = s_101_0;
        // N s_101_2: jump b102
        return block_102(state, tracer, fn_state);
    }
    fn block_102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_102_0: read-var gs#44007:u8
        let s_102_0: bool = fn_state.gs_44007;
        // N s_102_1: branch s_102_0 b600 b103
        if s_102_0 {
            return block_600(state, tracer, fn_state);
        } else {
            return block_103(state, tracer, fn_state);
        };
    }
    fn block_103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_103_0: const #() : ()
        let s_103_0: () = ();
        // S s_103_1: call HCR_read(s_103_0)
        let s_103_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_103_0);
        // C s_103_2: const #1s : i64
        let s_103_2: i64 = 1;
        // C s_103_3: cast zx s_103_2 -> i
        let s_103_3: i128 = (i128::try_from(s_103_2).unwrap());
        // S s_103_4: call __UNKNOWN_bits(s_103_3)
        let s_103_4: Bits = u__UNKNOWN_bits(state, tracer, s_103_3);
        // S s_103_5: cast reint s_103_4 -> u8
        let s_103_5: bool = ((s_103_4.value()) != 0);
        // S s_103_6: call _update_HCR_Type_IMO(s_103_1, s_103_5)
        let s_103_6: ProductType700c18a878c5601b = u_update_HCR_Type_IMO(
            state,
            tracer,
            s_103_1,
            s_103_5,
        );
        // S s_103_7: call HCR_write(s_103_6)
        let s_103_7: () = HCR_write(state, tracer, s_103_6);
        // N s_103_8: jump b104
        return block_104(state, tracer, fn_state);
    }
    fn block_104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_104_0: read-var cold:u8
        let s_104_0: bool = fn_state.cold;
        // D s_104_1: not s_104_0
        let s_104_1: bool = !s_104_0;
        // N s_104_2: branch s_104_1 b599 b105
        if s_104_1 {
            return block_599(state, tracer, fn_state);
        } else {
            return block_105(state, tracer, fn_state);
        };
    }
    fn block_105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_105_0: const #0u : u8
        let s_105_0: bool = false;
        // D s_105_1: write-var gs#44008 <= s_105_0
        fn_state.gs_44008 = s_105_0;
        // N s_105_2: jump b106
        return block_106(state, tracer, fn_state);
    }
    fn block_106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_106_0: read-var gs#44008:u8
        let s_106_0: bool = fn_state.gs_44008;
        // N s_106_1: branch s_106_0 b598 b107
        if s_106_0 {
            return block_598(state, tracer, fn_state);
        } else {
            return block_107(state, tracer, fn_state);
        };
    }
    fn block_107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_107_0: const #() : ()
        let s_107_0: () = ();
        // S s_107_1: call HCR_read(s_107_0)
        let s_107_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_107_0);
        // C s_107_2: const #1s : i64
        let s_107_2: i64 = 1;
        // C s_107_3: cast zx s_107_2 -> i
        let s_107_3: i128 = (i128::try_from(s_107_2).unwrap());
        // S s_107_4: call __UNKNOWN_bits(s_107_3)
        let s_107_4: Bits = u__UNKNOWN_bits(state, tracer, s_107_3);
        // S s_107_5: cast reint s_107_4 -> u8
        let s_107_5: bool = ((s_107_4.value()) != 0);
        // S s_107_6: call _update_HCR_Type_FMO(s_107_1, s_107_5)
        let s_107_6: ProductType700c18a878c5601b = u_update_HCR_Type_FMO(
            state,
            tracer,
            s_107_1,
            s_107_5,
        );
        // S s_107_7: call HCR_write(s_107_6)
        let s_107_7: () = HCR_write(state, tracer, s_107_6);
        // N s_107_8: jump b108
        return block_108(state, tracer, fn_state);
    }
    fn block_108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_108_0: read-var cold:u8
        let s_108_0: bool = fn_state.cold;
        // D s_108_1: not s_108_0
        let s_108_1: bool = !s_108_0;
        // N s_108_2: branch s_108_1 b597 b109
        if s_108_1 {
            return block_597(state, tracer, fn_state);
        } else {
            return block_109(state, tracer, fn_state);
        };
    }
    fn block_109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_109_0: const #0u : u8
        let s_109_0: bool = false;
        // D s_109_1: write-var gs#44009 <= s_109_0
        fn_state.gs_44009 = s_109_0;
        // N s_109_2: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_110_0: read-var gs#44009:u8
        let s_110_0: bool = fn_state.gs_44009;
        // N s_110_1: branch s_110_0 b596 b111
        if s_110_0 {
            return block_596(state, tracer, fn_state);
        } else {
            return block_111(state, tracer, fn_state);
        };
    }
    fn block_111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_111_0: const #() : ()
        let s_111_0: () = ();
        // S s_111_1: call HCR_read(s_111_0)
        let s_111_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_111_0);
        // C s_111_2: const #1s : i64
        let s_111_2: i64 = 1;
        // C s_111_3: cast zx s_111_2 -> i
        let s_111_3: i128 = (i128::try_from(s_111_2).unwrap());
        // S s_111_4: call __UNKNOWN_bits(s_111_3)
        let s_111_4: Bits = u__UNKNOWN_bits(state, tracer, s_111_3);
        // S s_111_5: cast reint s_111_4 -> u8
        let s_111_5: bool = ((s_111_4.value()) != 0);
        // S s_111_6: call _update_HCR_Type_PTW(s_111_1, s_111_5)
        let s_111_6: ProductType700c18a878c5601b = u_update_HCR_Type_PTW(
            state,
            tracer,
            s_111_1,
            s_111_5,
        );
        // S s_111_7: call HCR_write(s_111_6)
        let s_111_7: () = HCR_write(state, tracer, s_111_6);
        // N s_111_8: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_112_0: read-var cold:u8
        let s_112_0: bool = fn_state.cold;
        // D s_112_1: not s_112_0
        let s_112_1: bool = !s_112_0;
        // N s_112_2: branch s_112_1 b595 b113
        if s_112_1 {
            return block_595(state, tracer, fn_state);
        } else {
            return block_113(state, tracer, fn_state);
        };
    }
    fn block_113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_113_0: const #0u : u8
        let s_113_0: bool = false;
        // D s_113_1: write-var gs#44010 <= s_113_0
        fn_state.gs_44010 = s_113_0;
        // N s_113_2: jump b114
        return block_114(state, tracer, fn_state);
    }
    fn block_114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_114_0: read-var gs#44010:u8
        let s_114_0: bool = fn_state.gs_44010;
        // N s_114_1: branch s_114_0 b594 b115
        if s_114_0 {
            return block_594(state, tracer, fn_state);
        } else {
            return block_115(state, tracer, fn_state);
        };
    }
    fn block_115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_115_0: const #() : ()
        let s_115_0: () = ();
        // S s_115_1: call HCR_read(s_115_0)
        let s_115_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_115_0);
        // C s_115_2: const #1s : i64
        let s_115_2: i64 = 1;
        // C s_115_3: cast zx s_115_2 -> i
        let s_115_3: i128 = (i128::try_from(s_115_2).unwrap());
        // S s_115_4: call __UNKNOWN_bits(s_115_3)
        let s_115_4: Bits = u__UNKNOWN_bits(state, tracer, s_115_3);
        // S s_115_5: cast reint s_115_4 -> u8
        let s_115_5: bool = ((s_115_4.value()) != 0);
        // S s_115_6: call _update_HCR_Type_SWIO(s_115_1, s_115_5)
        let s_115_6: ProductType700c18a878c5601b = u_update_HCR_Type_SWIO(
            state,
            tracer,
            s_115_1,
            s_115_5,
        );
        // S s_115_7: call HCR_write(s_115_6)
        let s_115_7: () = HCR_write(state, tracer, s_115_6);
        // N s_115_8: jump b116
        return block_116(state, tracer, fn_state);
    }
    fn block_116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_116_0: read-var cold:u8
        let s_116_0: bool = fn_state.cold;
        // D s_116_1: not s_116_0
        let s_116_1: bool = !s_116_0;
        // N s_116_2: branch s_116_1 b593 b117
        if s_116_1 {
            return block_593(state, tracer, fn_state);
        } else {
            return block_117(state, tracer, fn_state);
        };
    }
    fn block_117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_117_0: const #0u : u8
        let s_117_0: bool = false;
        // D s_117_1: write-var gs#44011 <= s_117_0
        fn_state.gs_44011 = s_117_0;
        // N s_117_2: jump b118
        return block_118(state, tracer, fn_state);
    }
    fn block_118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_118_0: read-var gs#44011:u8
        let s_118_0: bool = fn_state.gs_44011;
        // N s_118_1: branch s_118_0 b592 b119
        if s_118_0 {
            return block_592(state, tracer, fn_state);
        } else {
            return block_119(state, tracer, fn_state);
        };
    }
    fn block_119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_119_0: const #() : ()
        let s_119_0: () = ();
        // S s_119_1: call HCR_read(s_119_0)
        let s_119_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_119_0);
        // C s_119_2: const #1s : i64
        let s_119_2: i64 = 1;
        // C s_119_3: cast zx s_119_2 -> i
        let s_119_3: i128 = (i128::try_from(s_119_2).unwrap());
        // S s_119_4: call __UNKNOWN_bits(s_119_3)
        let s_119_4: Bits = u__UNKNOWN_bits(state, tracer, s_119_3);
        // S s_119_5: cast reint s_119_4 -> u8
        let s_119_5: bool = ((s_119_4.value()) != 0);
        // S s_119_6: call _update_HCR_Type_VM(s_119_1, s_119_5)
        let s_119_6: ProductType700c18a878c5601b = u_update_HCR_Type_VM(
            state,
            tracer,
            s_119_1,
            s_119_5,
        );
        // S s_119_7: call HCR_write(s_119_6)
        let s_119_7: () = HCR_write(state, tracer, s_119_6);
        // N s_119_8: jump b120
        return block_120(state, tracer, fn_state);
    }
    fn block_120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_120_0: const #() : ()
        let s_120_0: () = ();
        // S s_120_1: call DBGOSDLR_read(s_120_0)
        let s_120_1: ProductType700c18a878c5601b = DBGOSDLR_read(state, tracer, s_120_0);
        // D s_120_2: write-var ga#35156 <= s_120_1
        fn_state.ga_35156 = s_120_1;
        // D s_120_3: read-var ga#35156.0:struct
        let s_120_3: u32 = fn_state.ga_35156._0;
        // C s_120_4: const #31s : i
        let s_120_4: i128 = 31;
        // C s_120_5: const #1s : i
        let s_120_5: i128 = 1;
        // D s_120_6: cast zx s_120_3 -> bv
        let s_120_6: Bits = Bits::new(s_120_3 as u128, 32u16);
        // C s_120_7: const #0u : u31
        let s_120_7: u32 = 0;
        // C s_120_8: cast zx s_120_7 -> bv
        let s_120_8: Bits = Bits::new(s_120_7 as u128, 31u16);
        // C s_120_9: const #1u : u64
        let s_120_9: u64 = 1;
        // C s_120_10: cast zx s_120_9 -> bv
        let s_120_10: Bits = Bits::new(s_120_9 as u128, 64u16);
        // C s_120_11: lsl s_120_10 s_120_4
        let s_120_11: Bits = s_120_10 << s_120_4;
        // C s_120_12: sub s_120_11 s_120_10
        let s_120_12: Bits = ((s_120_11) - (s_120_10));
        // C s_120_13: and s_120_8 s_120_12
        let s_120_13: Bits = ((s_120_8) & (s_120_12));
        // C s_120_14: lsl s_120_13 s_120_5
        let s_120_14: Bits = s_120_13 << s_120_5;
        // C s_120_15: lsl s_120_12 s_120_5
        let s_120_15: Bits = s_120_12 << s_120_5;
        // C s_120_16: cmpl s_120_15
        let s_120_16: Bits = !s_120_15;
        // D s_120_17: and s_120_6 s_120_16
        let s_120_17: Bits = ((s_120_6) & (s_120_16));
        // D s_120_18: or s_120_17 s_120_14
        let s_120_18: Bits = ((s_120_17) | (s_120_14));
        // D s_120_19: cast reint s_120_18 -> u32
        let s_120_19: u32 = (s_120_18.value() as u32);
        // D s_120_20: call Mk_DBGOSDLR_Type(s_120_19)
        let s_120_20: ProductType700c18a878c5601b = Mk_DBGOSDLR_Type(
            state,
            tracer,
            s_120_19,
        );
        // D s_120_21: call DBGOSDLR_write(s_120_20)
        let s_120_21: () = DBGOSDLR_write(state, tracer, s_120_20);
        // C s_120_22: const #() : ()
        let s_120_22: () = ();
        // S s_120_23: call DBGOSDLR_read(s_120_22)
        let s_120_23: ProductType700c18a878c5601b = DBGOSDLR_read(
            state,
            tracer,
            s_120_22,
        );
        // C s_120_24: const #0u : u8
        let s_120_24: bool = false;
        // S s_120_25: call _update_DBGOSDLR_Type_DLK(s_120_23, s_120_24)
        let s_120_25: ProductType700c18a878c5601b = u_update_DBGOSDLR_Type_DLK(
            state,
            tracer,
            s_120_23,
            s_120_24,
        );
        // S s_120_26: call DBGOSDLR_write(s_120_25)
        let s_120_26: () = DBGOSDLR_write(state, tracer, s_120_25);
        // C s_120_27: const #() : ()
        let s_120_27: () = ();
        // S s_120_28: call ICH_ELRSR_read(s_120_27)
        let s_120_28: ProductType700c18a878c5601b = ICH_ELRSR_read(
            state,
            tracer,
            s_120_27,
        );
        // D s_120_29: write-var ga#35162 <= s_120_28
        fn_state.ga_35162 = s_120_28;
        // D s_120_30: read-var ga#35162.0:struct
        let s_120_30: u32 = fn_state.ga_35162._0;
        // C s_120_31: const #16s : i
        let s_120_31: i128 = 16;
        // C s_120_32: const #16s : i
        let s_120_32: i128 = 16;
        // D s_120_33: cast zx s_120_30 -> bv
        let s_120_33: Bits = Bits::new(s_120_30 as u128, 32u16);
        // C s_120_34: const #0u : u16
        let s_120_34: u16 = 0;
        // C s_120_35: cast zx s_120_34 -> bv
        let s_120_35: Bits = Bits::new(s_120_34 as u128, 16u16);
        // C s_120_36: const #1u : u64
        let s_120_36: u64 = 1;
        // C s_120_37: cast zx s_120_36 -> bv
        let s_120_37: Bits = Bits::new(s_120_36 as u128, 64u16);
        // C s_120_38: lsl s_120_37 s_120_31
        let s_120_38: Bits = s_120_37 << s_120_31;
        // C s_120_39: sub s_120_38 s_120_37
        let s_120_39: Bits = ((s_120_38) - (s_120_37));
        // C s_120_40: and s_120_35 s_120_39
        let s_120_40: Bits = ((s_120_35) & (s_120_39));
        // C s_120_41: lsl s_120_40 s_120_32
        let s_120_41: Bits = s_120_40 << s_120_32;
        // C s_120_42: lsl s_120_39 s_120_32
        let s_120_42: Bits = s_120_39 << s_120_32;
        // C s_120_43: cmpl s_120_42
        let s_120_43: Bits = !s_120_42;
        // D s_120_44: and s_120_33 s_120_43
        let s_120_44: Bits = ((s_120_33) & (s_120_43));
        // D s_120_45: or s_120_44 s_120_41
        let s_120_45: Bits = ((s_120_44) | (s_120_41));
        // D s_120_46: cast reint s_120_45 -> u32
        let s_120_46: u32 = (s_120_45.value() as u32);
        // D s_120_47: call Mk_ICH_ELRSR_Type(s_120_46)
        let s_120_47: ProductType700c18a878c5601b = Mk_ICH_ELRSR_Type(
            state,
            tracer,
            s_120_46,
        );
        // D s_120_48: call ICH_ELRSR_write(s_120_47)
        let s_120_48: () = ICH_ELRSR_write(state, tracer, s_120_47);
        // C s_120_49: const #() : ()
        let s_120_49: () = ();
        // S s_120_50: call ICC_IAR1_read(s_120_49)
        let s_120_50: ProductType700c18a878c5601b = ICC_IAR1_read(
            state,
            tracer,
            s_120_49,
        );
        // D s_120_51: write-var ga#35166 <= s_120_50
        fn_state.ga_35166 = s_120_50;
        // D s_120_52: read-var ga#35166.0:struct
        let s_120_52: u32 = fn_state.ga_35166._0;
        // C s_120_53: const #8s : i
        let s_120_53: i128 = 8;
        // C s_120_54: const #24s : i
        let s_120_54: i128 = 24;
        // D s_120_55: cast zx s_120_52 -> bv
        let s_120_55: Bits = Bits::new(s_120_52 as u128, 32u16);
        // C s_120_56: const #0u : u8
        let s_120_56: u8 = 0;
        // C s_120_57: cast zx s_120_56 -> bv
        let s_120_57: Bits = Bits::new(s_120_56 as u128, 8u16);
        // C s_120_58: const #1u : u64
        let s_120_58: u64 = 1;
        // C s_120_59: cast zx s_120_58 -> bv
        let s_120_59: Bits = Bits::new(s_120_58 as u128, 64u16);
        // C s_120_60: lsl s_120_59 s_120_53
        let s_120_60: Bits = s_120_59 << s_120_53;
        // C s_120_61: sub s_120_60 s_120_59
        let s_120_61: Bits = ((s_120_60) - (s_120_59));
        // C s_120_62: and s_120_57 s_120_61
        let s_120_62: Bits = ((s_120_57) & (s_120_61));
        // C s_120_63: lsl s_120_62 s_120_54
        let s_120_63: Bits = s_120_62 << s_120_54;
        // C s_120_64: lsl s_120_61 s_120_54
        let s_120_64: Bits = s_120_61 << s_120_54;
        // C s_120_65: cmpl s_120_64
        let s_120_65: Bits = !s_120_64;
        // D s_120_66: and s_120_55 s_120_65
        let s_120_66: Bits = ((s_120_55) & (s_120_65));
        // D s_120_67: or s_120_66 s_120_63
        let s_120_67: Bits = ((s_120_66) | (s_120_63));
        // D s_120_68: cast reint s_120_67 -> u32
        let s_120_68: u32 = (s_120_67.value() as u32);
        // D s_120_69: call Mk_ICC_IAR1_Type(s_120_68)
        let s_120_69: ProductType700c18a878c5601b = Mk_ICC_IAR1_Type(
            state,
            tracer,
            s_120_68,
        );
        // D s_120_70: call ICC_IAR1_write(s_120_69)
        let s_120_70: () = ICC_IAR1_write(state, tracer, s_120_69);
        // C s_120_71: const #0s : i
        let s_120_71: i128 = 0;
        // C s_120_72: const #22608u : u32
        let s_120_72: u32 = 22608;
        // D s_120_73: read-reg s_120_72:u32
        let s_120_73: u32 = {
            let value = state.read_register::<u32>(s_120_72 as isize);
            tracer.read_register(s_120_72 as isize, value);
            value
        };
        // D s_120_74: cast zx s_120_73 -> bv
        let s_120_74: Bits = Bits::new(s_120_73 as u128, 32u16);
        // C s_120_75: const #0u : u32
        let s_120_75: u32 = 0;
        // C s_120_76: cast zx s_120_75 -> bv
        let s_120_76: Bits = Bits::new(s_120_75 as u128, 32u16);
        // C s_120_77: const #31s : i
        let s_120_77: i128 = 31;
        // C s_120_78: const #1u : u64
        let s_120_78: u64 = 1;
        // C s_120_79: cast zx s_120_78 -> bv
        let s_120_79: Bits = Bits::new(s_120_78 as u128, 64u16);
        // C s_120_80: lsl s_120_79 s_120_77
        let s_120_80: Bits = s_120_79 << s_120_77;
        // C s_120_81: sub s_120_80 s_120_79
        let s_120_81: Bits = ((s_120_80) - (s_120_79));
        // C s_120_82: and s_120_76 s_120_81
        let s_120_82: Bits = ((s_120_76) & (s_120_81));
        // C s_120_83: lsl s_120_82 s_120_71
        let s_120_83: Bits = s_120_82 << s_120_71;
        // C s_120_84: lsl s_120_81 s_120_71
        let s_120_84: Bits = s_120_81 << s_120_71;
        // C s_120_85: cmpl s_120_84
        let s_120_85: Bits = !s_120_84;
        // D s_120_86: and s_120_74 s_120_85
        let s_120_86: Bits = ((s_120_74) & (s_120_85));
        // D s_120_87: or s_120_86 s_120_83
        let s_120_87: Bits = ((s_120_86) | (s_120_83));
        // D s_120_88: cast reint s_120_87 -> u32
        let s_120_88: u32 = (s_120_87.value() as u32);
        // C s_120_89: const #22608u : u32
        let s_120_89: u32 = 22608;
        // N s_120_90: write-reg s_120_89 <= s_120_88
        let s_120_90: () = {
            state.write_register::<u32>(s_120_89 as isize, s_120_88);
            tracer.write_register(s_120_89 as isize, s_120_88);
        };
        // D s_120_91: read-var cold:u8
        let s_120_91: bool = fn_state.cold;
        // D s_120_92: not s_120_91
        let s_120_92: bool = !s_120_91;
        // N s_120_93: branch s_120_92 b591 b121
        if s_120_92 {
            return block_591(state, tracer, fn_state);
        } else {
            return block_121(state, tracer, fn_state);
        };
    }
    fn block_121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_121_0: const #0u : u8
        let s_121_0: bool = false;
        // D s_121_1: write-var gs#44023 <= s_121_0
        fn_state.gs_44023 = s_121_0;
        // N s_121_2: jump b122
        return block_122(state, tracer, fn_state);
    }
    fn block_122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_122_0: read-var gs#44023:u8
        let s_122_0: bool = fn_state.gs_44023;
        // N s_122_1: branch s_122_0 b590 b123
        if s_122_0 {
            return block_590(state, tracer, fn_state);
        } else {
            return block_123(state, tracer, fn_state);
        };
    }
    fn block_123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_123_0: const #() : ()
        let s_123_0: () = ();
        // S s_123_1: call HCPTR_read(s_123_0)
        let s_123_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_123_0);
        // C s_123_2: const #1s : i64
        let s_123_2: i64 = 1;
        // C s_123_3: cast zx s_123_2 -> i
        let s_123_3: i128 = (i128::try_from(s_123_2).unwrap());
        // S s_123_4: call __UNKNOWN_bits(s_123_3)
        let s_123_4: Bits = u__UNKNOWN_bits(state, tracer, s_123_3);
        // S s_123_5: cast reint s_123_4 -> u8
        let s_123_5: bool = ((s_123_4.value()) != 0);
        // S s_123_6: call _update_HCPTR_Type_TCPAC(s_123_1, s_123_5)
        let s_123_6: ProductType700c18a878c5601b = u_update_HCPTR_Type_TCPAC(
            state,
            tracer,
            s_123_1,
            s_123_5,
        );
        // S s_123_7: call HCPTR_write(s_123_6)
        let s_123_7: () = HCPTR_write(state, tracer, s_123_6);
        // N s_123_8: jump b124
        return block_124(state, tracer, fn_state);
    }
    fn block_124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_124_0: read-var cold:u8
        let s_124_0: bool = fn_state.cold;
        // D s_124_1: not s_124_0
        let s_124_1: bool = !s_124_0;
        // N s_124_2: branch s_124_1 b589 b125
        if s_124_1 {
            return block_589(state, tracer, fn_state);
        } else {
            return block_125(state, tracer, fn_state);
        };
    }
    fn block_125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_125_0: const #0u : u8
        let s_125_0: bool = false;
        // D s_125_1: write-var gs#44024 <= s_125_0
        fn_state.gs_44024 = s_125_0;
        // N s_125_2: jump b126
        return block_126(state, tracer, fn_state);
    }
    fn block_126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_126_0: read-var gs#44024:u8
        let s_126_0: bool = fn_state.gs_44024;
        // N s_126_1: branch s_126_0 b588 b127
        if s_126_0 {
            return block_588(state, tracer, fn_state);
        } else {
            return block_127(state, tracer, fn_state);
        };
    }
    fn block_127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_127_0: const #() : ()
        let s_127_0: () = ();
        // S s_127_1: call HCPTR_read(s_127_0)
        let s_127_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_127_0);
        // C s_127_2: const #1s : i64
        let s_127_2: i64 = 1;
        // C s_127_3: cast zx s_127_2 -> i
        let s_127_3: i128 = (i128::try_from(s_127_2).unwrap());
        // S s_127_4: call __UNKNOWN_bits(s_127_3)
        let s_127_4: Bits = u__UNKNOWN_bits(state, tracer, s_127_3);
        // S s_127_5: cast reint s_127_4 -> u8
        let s_127_5: bool = ((s_127_4.value()) != 0);
        // S s_127_6: call _update_HCPTR_Type_TAM(s_127_1, s_127_5)
        let s_127_6: ProductType700c18a878c5601b = u_update_HCPTR_Type_TAM(
            state,
            tracer,
            s_127_1,
            s_127_5,
        );
        // S s_127_7: call HCPTR_write(s_127_6)
        let s_127_7: () = HCPTR_write(state, tracer, s_127_6);
        // N s_127_8: jump b128
        return block_128(state, tracer, fn_state);
    }
    fn block_128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_128_0: const #() : ()
        let s_128_0: () = ();
        // S s_128_1: call HCPTR_read(s_128_0)
        let s_128_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_128_0);
        // D s_128_2: write-var ga#35186 <= s_128_1
        fn_state.ga_35186 = s_128_1;
        // D s_128_3: read-var ga#35186.0:struct
        let s_128_3: u32 = fn_state.ga_35186._0;
        // C s_128_4: const #9s : i
        let s_128_4: i128 = 9;
        // C s_128_5: const #21s : i
        let s_128_5: i128 = 21;
        // D s_128_6: cast zx s_128_3 -> bv
        let s_128_6: Bits = Bits::new(s_128_3 as u128, 32u16);
        // C s_128_7: const #0u : u9
        let s_128_7: u16 = 0;
        // C s_128_8: cast zx s_128_7 -> bv
        let s_128_8: Bits = Bits::new(s_128_7 as u128, 9u16);
        // C s_128_9: const #1u : u64
        let s_128_9: u64 = 1;
        // C s_128_10: cast zx s_128_9 -> bv
        let s_128_10: Bits = Bits::new(s_128_9 as u128, 64u16);
        // C s_128_11: lsl s_128_10 s_128_4
        let s_128_11: Bits = s_128_10 << s_128_4;
        // C s_128_12: sub s_128_11 s_128_10
        let s_128_12: Bits = ((s_128_11) - (s_128_10));
        // C s_128_13: and s_128_8 s_128_12
        let s_128_13: Bits = ((s_128_8) & (s_128_12));
        // C s_128_14: lsl s_128_13 s_128_5
        let s_128_14: Bits = s_128_13 << s_128_5;
        // C s_128_15: lsl s_128_12 s_128_5
        let s_128_15: Bits = s_128_12 << s_128_5;
        // C s_128_16: cmpl s_128_15
        let s_128_16: Bits = !s_128_15;
        // D s_128_17: and s_128_6 s_128_16
        let s_128_17: Bits = ((s_128_6) & (s_128_16));
        // D s_128_18: or s_128_17 s_128_14
        let s_128_18: Bits = ((s_128_17) | (s_128_14));
        // D s_128_19: cast reint s_128_18 -> u32
        let s_128_19: u32 = (s_128_18.value() as u32);
        // D s_128_20: call Mk_HCPTR_Type(s_128_19)
        let s_128_20: ProductType700c18a878c5601b = Mk_HCPTR_Type(
            state,
            tracer,
            s_128_19,
        );
        // D s_128_21: call HCPTR_write(s_128_20)
        let s_128_21: () = HCPTR_write(state, tracer, s_128_20);
        // D s_128_22: read-var cold:u8
        let s_128_22: bool = fn_state.cold;
        // D s_128_23: not s_128_22
        let s_128_23: bool = !s_128_22;
        // N s_128_24: branch s_128_23 b587 b129
        if s_128_23 {
            return block_587(state, tracer, fn_state);
        } else {
            return block_129(state, tracer, fn_state);
        };
    }
    fn block_129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_129_0: const #0u : u8
        let s_129_0: bool = false;
        // D s_129_1: write-var gs#44028 <= s_129_0
        fn_state.gs_44028 = s_129_0;
        // N s_129_2: jump b130
        return block_130(state, tracer, fn_state);
    }
    fn block_130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_130_0: read-var gs#44028:u8
        let s_130_0: bool = fn_state.gs_44028;
        // N s_130_1: branch s_130_0 b586 b131
        if s_130_0 {
            return block_586(state, tracer, fn_state);
        } else {
            return block_131(state, tracer, fn_state);
        };
    }
    fn block_131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_131_0: const #() : ()
        let s_131_0: () = ();
        // S s_131_1: call HCPTR_read(s_131_0)
        let s_131_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_131_0);
        // C s_131_2: const #1s : i64
        let s_131_2: i64 = 1;
        // C s_131_3: cast zx s_131_2 -> i
        let s_131_3: i128 = (i128::try_from(s_131_2).unwrap());
        // S s_131_4: call __UNKNOWN_bits(s_131_3)
        let s_131_4: Bits = u__UNKNOWN_bits(state, tracer, s_131_3);
        // S s_131_5: cast reint s_131_4 -> u8
        let s_131_5: bool = ((s_131_4.value()) != 0);
        // S s_131_6: call _update_HCPTR_Type_TTA(s_131_1, s_131_5)
        let s_131_6: ProductType700c18a878c5601b = u_update_HCPTR_Type_TTA(
            state,
            tracer,
            s_131_1,
            s_131_5,
        );
        // S s_131_7: call HCPTR_write(s_131_6)
        let s_131_7: () = HCPTR_write(state, tracer, s_131_6);
        // N s_131_8: jump b132
        return block_132(state, tracer, fn_state);
    }
    fn block_132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_132_0: const #() : ()
        let s_132_0: () = ();
        // S s_132_1: call HCPTR_read(s_132_0)
        let s_132_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_132_0);
        // D s_132_2: write-var ga#35198 <= s_132_1
        fn_state.ga_35198 = s_132_1;
        // D s_132_3: read-var ga#35198.0:struct
        let s_132_3: u32 = fn_state.ga_35198._0;
        // C s_132_4: const #4s : i
        let s_132_4: i128 = 4;
        // C s_132_5: const #16s : i
        let s_132_5: i128 = 16;
        // D s_132_6: cast zx s_132_3 -> bv
        let s_132_6: Bits = Bits::new(s_132_3 as u128, 32u16);
        // C s_132_7: const #0u : u8
        let s_132_7: u8 = 0;
        // C s_132_8: cast zx s_132_7 -> bv
        let s_132_8: Bits = Bits::new(s_132_7 as u128, 4u16);
        // C s_132_9: const #1u : u64
        let s_132_9: u64 = 1;
        // C s_132_10: cast zx s_132_9 -> bv
        let s_132_10: Bits = Bits::new(s_132_9 as u128, 64u16);
        // C s_132_11: lsl s_132_10 s_132_4
        let s_132_11: Bits = s_132_10 << s_132_4;
        // C s_132_12: sub s_132_11 s_132_10
        let s_132_12: Bits = ((s_132_11) - (s_132_10));
        // C s_132_13: and s_132_8 s_132_12
        let s_132_13: Bits = ((s_132_8) & (s_132_12));
        // C s_132_14: lsl s_132_13 s_132_5
        let s_132_14: Bits = s_132_13 << s_132_5;
        // C s_132_15: lsl s_132_12 s_132_5
        let s_132_15: Bits = s_132_12 << s_132_5;
        // C s_132_16: cmpl s_132_15
        let s_132_16: Bits = !s_132_15;
        // D s_132_17: and s_132_6 s_132_16
        let s_132_17: Bits = ((s_132_6) & (s_132_16));
        // D s_132_18: or s_132_17 s_132_14
        let s_132_18: Bits = ((s_132_17) | (s_132_14));
        // D s_132_19: cast reint s_132_18 -> u32
        let s_132_19: u32 = (s_132_18.value() as u32);
        // D s_132_20: call Mk_HCPTR_Type(s_132_19)
        let s_132_20: ProductType700c18a878c5601b = Mk_HCPTR_Type(
            state,
            tracer,
            s_132_19,
        );
        // D s_132_21: call HCPTR_write(s_132_20)
        let s_132_21: () = HCPTR_write(state, tracer, s_132_20);
        // D s_132_22: read-var cold:u8
        let s_132_22: bool = fn_state.cold;
        // D s_132_23: not s_132_22
        let s_132_23: bool = !s_132_22;
        // N s_132_24: branch s_132_23 b585 b133
        if s_132_23 {
            return block_585(state, tracer, fn_state);
        } else {
            return block_133(state, tracer, fn_state);
        };
    }
    fn block_133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_133_0: const #0u : u8
        let s_133_0: bool = false;
        // D s_133_1: write-var gs#44032 <= s_133_0
        fn_state.gs_44032 = s_133_0;
        // N s_133_2: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_134_0: read-var gs#44032:u8
        let s_134_0: bool = fn_state.gs_44032;
        // N s_134_1: branch s_134_0 b584 b135
        if s_134_0 {
            return block_584(state, tracer, fn_state);
        } else {
            return block_135(state, tracer, fn_state);
        };
    }
    fn block_135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_135_0: const #() : ()
        let s_135_0: () = ();
        // S s_135_1: call HCPTR_read(s_135_0)
        let s_135_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_135_0);
        // C s_135_2: const #1s : i64
        let s_135_2: i64 = 1;
        // C s_135_3: cast zx s_135_2 -> i
        let s_135_3: i128 = (i128::try_from(s_135_2).unwrap());
        // S s_135_4: call __UNKNOWN_bits(s_135_3)
        let s_135_4: Bits = u__UNKNOWN_bits(state, tracer, s_135_3);
        // S s_135_5: cast reint s_135_4 -> u8
        let s_135_5: bool = ((s_135_4.value()) != 0);
        // S s_135_6: call _update_HCPTR_Type_TASE(s_135_1, s_135_5)
        let s_135_6: ProductType700c18a878c5601b = u_update_HCPTR_Type_TASE(
            state,
            tracer,
            s_135_1,
            s_135_5,
        );
        // S s_135_7: call HCPTR_write(s_135_6)
        let s_135_7: () = HCPTR_write(state, tracer, s_135_6);
        // N s_135_8: jump b136
        return block_136(state, tracer, fn_state);
    }
    fn block_136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_136_0: const #() : ()
        let s_136_0: () = ();
        // S s_136_1: call HCPTR_read(s_136_0)
        let s_136_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_136_0);
        // D s_136_2: write-var ga#35210 <= s_136_1
        fn_state.ga_35210 = s_136_1;
        // D s_136_3: read-var ga#35210.0:struct
        let s_136_3: u32 = fn_state.ga_35210._0;
        // C s_136_4: const #1s : i
        let s_136_4: i128 = 1;
        // C s_136_5: const #14s : i
        let s_136_5: i128 = 14;
        // D s_136_6: cast zx s_136_3 -> bv
        let s_136_6: Bits = Bits::new(s_136_3 as u128, 32u16);
        // C s_136_7: const #0u : u8
        let s_136_7: bool = false;
        // C s_136_8: cast zx s_136_7 -> bv
        let s_136_8: Bits = Bits::new(s_136_7 as u128, 1u16);
        // C s_136_9: const #1u : u64
        let s_136_9: u64 = 1;
        // C s_136_10: cast zx s_136_9 -> bv
        let s_136_10: Bits = Bits::new(s_136_9 as u128, 64u16);
        // C s_136_11: lsl s_136_10 s_136_4
        let s_136_11: Bits = s_136_10 << s_136_4;
        // C s_136_12: sub s_136_11 s_136_10
        let s_136_12: Bits = ((s_136_11) - (s_136_10));
        // C s_136_13: and s_136_8 s_136_12
        let s_136_13: Bits = ((s_136_8) & (s_136_12));
        // C s_136_14: lsl s_136_13 s_136_5
        let s_136_14: Bits = s_136_13 << s_136_5;
        // C s_136_15: lsl s_136_12 s_136_5
        let s_136_15: Bits = s_136_12 << s_136_5;
        // C s_136_16: cmpl s_136_15
        let s_136_16: Bits = !s_136_15;
        // D s_136_17: and s_136_6 s_136_16
        let s_136_17: Bits = ((s_136_6) & (s_136_16));
        // D s_136_18: or s_136_17 s_136_14
        let s_136_18: Bits = ((s_136_17) | (s_136_14));
        // D s_136_19: cast reint s_136_18 -> u32
        let s_136_19: u32 = (s_136_18.value() as u32);
        // D s_136_20: call Mk_HCPTR_Type(s_136_19)
        let s_136_20: ProductType700c18a878c5601b = Mk_HCPTR_Type(
            state,
            tracer,
            s_136_19,
        );
        // D s_136_21: call HCPTR_write(s_136_20)
        let s_136_21: () = HCPTR_write(state, tracer, s_136_20);
        // C s_136_22: const #() : ()
        let s_136_22: () = ();
        // S s_136_23: call HCPTR_read(s_136_22)
        let s_136_23: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_136_22);
        // D s_136_24: write-var ga#35214 <= s_136_23
        fn_state.ga_35214 = s_136_23;
        // D s_136_25: read-var ga#35214.0:struct
        let s_136_25: u32 = fn_state.ga_35214._0;
        // C s_136_26: const #2s : i
        let s_136_26: i128 = 2;
        // C s_136_27: const #12s : i
        let s_136_27: i128 = 12;
        // D s_136_28: cast zx s_136_25 -> bv
        let s_136_28: Bits = Bits::new(s_136_25 as u128, 32u16);
        // C s_136_29: const #3u : u8
        let s_136_29: u8 = 3;
        // C s_136_30: cast zx s_136_29 -> bv
        let s_136_30: Bits = Bits::new(s_136_29 as u128, 2u16);
        // C s_136_31: const #1u : u64
        let s_136_31: u64 = 1;
        // C s_136_32: cast zx s_136_31 -> bv
        let s_136_32: Bits = Bits::new(s_136_31 as u128, 64u16);
        // C s_136_33: lsl s_136_32 s_136_26
        let s_136_33: Bits = s_136_32 << s_136_26;
        // C s_136_34: sub s_136_33 s_136_32
        let s_136_34: Bits = ((s_136_33) - (s_136_32));
        // C s_136_35: and s_136_30 s_136_34
        let s_136_35: Bits = ((s_136_30) & (s_136_34));
        // C s_136_36: lsl s_136_35 s_136_27
        let s_136_36: Bits = s_136_35 << s_136_27;
        // C s_136_37: lsl s_136_34 s_136_27
        let s_136_37: Bits = s_136_34 << s_136_27;
        // C s_136_38: cmpl s_136_37
        let s_136_38: Bits = !s_136_37;
        // D s_136_39: and s_136_28 s_136_38
        let s_136_39: Bits = ((s_136_28) & (s_136_38));
        // D s_136_40: or s_136_39 s_136_36
        let s_136_40: Bits = ((s_136_39) | (s_136_36));
        // D s_136_41: cast reint s_136_40 -> u32
        let s_136_41: u32 = (s_136_40.value() as u32);
        // D s_136_42: call Mk_HCPTR_Type(s_136_41)
        let s_136_42: ProductType700c18a878c5601b = Mk_HCPTR_Type(
            state,
            tracer,
            s_136_41,
        );
        // D s_136_43: call HCPTR_write(s_136_42)
        let s_136_43: () = HCPTR_write(state, tracer, s_136_42);
        // D s_136_44: read-var cold:u8
        let s_136_44: bool = fn_state.cold;
        // D s_136_45: not s_136_44
        let s_136_45: bool = !s_136_44;
        // N s_136_46: branch s_136_45 b583 b137
        if s_136_45 {
            return block_583(state, tracer, fn_state);
        } else {
            return block_137(state, tracer, fn_state);
        };
    }
    fn block_137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_137_0: const #0u : u8
        let s_137_0: bool = false;
        // D s_137_1: write-var gs#44039 <= s_137_0
        fn_state.gs_44039 = s_137_0;
        // N s_137_2: jump b138
        return block_138(state, tracer, fn_state);
    }
    fn block_138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_138_0: read-var gs#44039:u8
        let s_138_0: bool = fn_state.gs_44039;
        // N s_138_1: branch s_138_0 b582 b139
        if s_138_0 {
            return block_582(state, tracer, fn_state);
        } else {
            return block_139(state, tracer, fn_state);
        };
    }
    fn block_139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_139_0: const #() : ()
        let s_139_0: () = ();
        // S s_139_1: call HCPTR_read(s_139_0)
        let s_139_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_139_0);
        // C s_139_2: const #1s : i64
        let s_139_2: i64 = 1;
        // C s_139_3: cast zx s_139_2 -> i
        let s_139_3: i128 = (i128::try_from(s_139_2).unwrap());
        // S s_139_4: call __UNKNOWN_bits(s_139_3)
        let s_139_4: Bits = u__UNKNOWN_bits(state, tracer, s_139_3);
        // S s_139_5: cast reint s_139_4 -> u8
        let s_139_5: bool = ((s_139_4.value()) != 0);
        // S s_139_6: call _update_HCPTR_Type_TCP11(s_139_1, s_139_5)
        let s_139_6: ProductType700c18a878c5601b = u_update_HCPTR_Type_TCP11(
            state,
            tracer,
            s_139_1,
            s_139_5,
        );
        // S s_139_7: call HCPTR_write(s_139_6)
        let s_139_7: () = HCPTR_write(state, tracer, s_139_6);
        // N s_139_8: jump b140
        return block_140(state, tracer, fn_state);
    }
    fn block_140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_140_0: read-var cold:u8
        let s_140_0: bool = fn_state.cold;
        // D s_140_1: not s_140_0
        let s_140_1: bool = !s_140_0;
        // N s_140_2: branch s_140_1 b581 b141
        if s_140_1 {
            return block_581(state, tracer, fn_state);
        } else {
            return block_141(state, tracer, fn_state);
        };
    }
    fn block_141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_141_0: const #0u : u8
        let s_141_0: bool = false;
        // D s_141_1: write-var gs#44040 <= s_141_0
        fn_state.gs_44040 = s_141_0;
        // N s_141_2: jump b142
        return block_142(state, tracer, fn_state);
    }
    fn block_142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_142_0: read-var gs#44040:u8
        let s_142_0: bool = fn_state.gs_44040;
        // N s_142_1: branch s_142_0 b580 b143
        if s_142_0 {
            return block_580(state, tracer, fn_state);
        } else {
            return block_143(state, tracer, fn_state);
        };
    }
    fn block_143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_143_0: const #() : ()
        let s_143_0: () = ();
        // S s_143_1: call HCPTR_read(s_143_0)
        let s_143_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_143_0);
        // C s_143_2: const #1s : i64
        let s_143_2: i64 = 1;
        // C s_143_3: cast zx s_143_2 -> i
        let s_143_3: i128 = (i128::try_from(s_143_2).unwrap());
        // S s_143_4: call __UNKNOWN_bits(s_143_3)
        let s_143_4: Bits = u__UNKNOWN_bits(state, tracer, s_143_3);
        // S s_143_5: cast reint s_143_4 -> u8
        let s_143_5: bool = ((s_143_4.value()) != 0);
        // S s_143_6: call _update_HCPTR_Type_TCP10(s_143_1, s_143_5)
        let s_143_6: ProductType700c18a878c5601b = u_update_HCPTR_Type_TCP10(
            state,
            tracer,
            s_143_1,
            s_143_5,
        );
        // S s_143_7: call HCPTR_write(s_143_6)
        let s_143_7: () = HCPTR_write(state, tracer, s_143_6);
        // N s_143_8: jump b144
        return block_144(state, tracer, fn_state);
    }
    fn block_144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_144_0: const #() : ()
        let s_144_0: () = ();
        // S s_144_1: call HCPTR_read(s_144_0)
        let s_144_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_144_0);
        // D s_144_2: write-var ga#35234 <= s_144_1
        fn_state.ga_35234 = s_144_1;
        // D s_144_3: read-var ga#35234.0:struct
        let s_144_3: u32 = fn_state.ga_35234._0;
        // C s_144_4: const #10s : i
        let s_144_4: i128 = 10;
        // C s_144_5: const #0s : i
        let s_144_5: i128 = 0;
        // D s_144_6: cast zx s_144_3 -> bv
        let s_144_6: Bits = Bits::new(s_144_3 as u128, 32u16);
        // C s_144_7: const #1023u : u10
        let s_144_7: u16 = 1023;
        // C s_144_8: cast zx s_144_7 -> bv
        let s_144_8: Bits = Bits::new(s_144_7 as u128, 10u16);
        // C s_144_9: const #1u : u64
        let s_144_9: u64 = 1;
        // C s_144_10: cast zx s_144_9 -> bv
        let s_144_10: Bits = Bits::new(s_144_9 as u128, 64u16);
        // C s_144_11: lsl s_144_10 s_144_4
        let s_144_11: Bits = s_144_10 << s_144_4;
        // C s_144_12: sub s_144_11 s_144_10
        let s_144_12: Bits = ((s_144_11) - (s_144_10));
        // C s_144_13: and s_144_8 s_144_12
        let s_144_13: Bits = ((s_144_8) & (s_144_12));
        // C s_144_14: lsl s_144_13 s_144_5
        let s_144_14: Bits = s_144_13 << s_144_5;
        // C s_144_15: lsl s_144_12 s_144_5
        let s_144_15: Bits = s_144_12 << s_144_5;
        // C s_144_16: cmpl s_144_15
        let s_144_16: Bits = !s_144_15;
        // D s_144_17: and s_144_6 s_144_16
        let s_144_17: Bits = ((s_144_6) & (s_144_16));
        // D s_144_18: or s_144_17 s_144_14
        let s_144_18: Bits = ((s_144_17) | (s_144_14));
        // D s_144_19: cast reint s_144_18 -> u32
        let s_144_19: u32 = (s_144_18.value() as u32);
        // D s_144_20: call Mk_HCPTR_Type(s_144_19)
        let s_144_20: ProductType700c18a878c5601b = Mk_HCPTR_Type(
            state,
            tracer,
            s_144_19,
        );
        // D s_144_21: call HCPTR_write(s_144_20)
        let s_144_21: () = HCPTR_write(state, tracer, s_144_20);
        // C s_144_22: const #() : ()
        let s_144_22: () = ();
        // S s_144_23: call ICV_IGRPEN1_read(s_144_22)
        let s_144_23: ProductType700c18a878c5601b = ICV_IGRPEN1_read(
            state,
            tracer,
            s_144_22,
        );
        // D s_144_24: write-var ga#35238 <= s_144_23
        fn_state.ga_35238 = s_144_23;
        // D s_144_25: read-var ga#35238.0:struct
        let s_144_25: u32 = fn_state.ga_35238._0;
        // C s_144_26: const #31s : i
        let s_144_26: i128 = 31;
        // C s_144_27: const #1s : i
        let s_144_27: i128 = 1;
        // D s_144_28: cast zx s_144_25 -> bv
        let s_144_28: Bits = Bits::new(s_144_25 as u128, 32u16);
        // C s_144_29: const #0u : u31
        let s_144_29: u32 = 0;
        // C s_144_30: cast zx s_144_29 -> bv
        let s_144_30: Bits = Bits::new(s_144_29 as u128, 31u16);
        // C s_144_31: const #1u : u64
        let s_144_31: u64 = 1;
        // C s_144_32: cast zx s_144_31 -> bv
        let s_144_32: Bits = Bits::new(s_144_31 as u128, 64u16);
        // C s_144_33: lsl s_144_32 s_144_26
        let s_144_33: Bits = s_144_32 << s_144_26;
        // C s_144_34: sub s_144_33 s_144_32
        let s_144_34: Bits = ((s_144_33) - (s_144_32));
        // C s_144_35: and s_144_30 s_144_34
        let s_144_35: Bits = ((s_144_30) & (s_144_34));
        // C s_144_36: lsl s_144_35 s_144_27
        let s_144_36: Bits = s_144_35 << s_144_27;
        // C s_144_37: lsl s_144_34 s_144_27
        let s_144_37: Bits = s_144_34 << s_144_27;
        // C s_144_38: cmpl s_144_37
        let s_144_38: Bits = !s_144_37;
        // D s_144_39: and s_144_28 s_144_38
        let s_144_39: Bits = ((s_144_28) & (s_144_38));
        // D s_144_40: or s_144_39 s_144_36
        let s_144_40: Bits = ((s_144_39) | (s_144_36));
        // D s_144_41: cast reint s_144_40 -> u32
        let s_144_41: u32 = (s_144_40.value() as u32);
        // D s_144_42: call Mk_ICV_IGRPEN1_Type(s_144_41)
        let s_144_42: ProductType700c18a878c5601b = Mk_ICV_IGRPEN1_Type(
            state,
            tracer,
            s_144_41,
        );
        // D s_144_43: call ICV_IGRPEN1_write(s_144_42)
        let s_144_43: () = ICV_IGRPEN1_write(state, tracer, s_144_42);
        // C s_144_44: const #() : ()
        let s_144_44: () = ();
        // S s_144_45: call ICV_IGRPEN1_read(s_144_44)
        let s_144_45: ProductType700c18a878c5601b = ICV_IGRPEN1_read(
            state,
            tracer,
            s_144_44,
        );
        // C s_144_46: const #0u : u8
        let s_144_46: bool = false;
        // S s_144_47: call _update_ICV_IGRPEN1_Type_Enable(s_144_45, s_144_46)
        let s_144_47: ProductType700c18a878c5601b = u_update_ICV_IGRPEN1_Type_Enable(
            state,
            tracer,
            s_144_45,
            s_144_46,
        );
        // S s_144_48: call ICV_IGRPEN1_write(s_144_47)
        let s_144_48: () = ICV_IGRPEN1_write(state, tracer, s_144_47);
        // C s_144_49: const #() : ()
        let s_144_49: () = ();
        // S s_144_50: call CTR_read(s_144_49)
        let s_144_50: ProductType700c18a878c5601b = CTR_read(state, tracer, s_144_49);
        // D s_144_51: write-var ga#35244 <= s_144_50
        fn_state.ga_35244 = s_144_50;
        // D s_144_52: read-var ga#35244.0:struct
        let s_144_52: u32 = fn_state.ga_35244._0;
        // C s_144_53: const #1s : i
        let s_144_53: i128 = 1;
        // C s_144_54: const #31s : i
        let s_144_54: i128 = 31;
        // D s_144_55: cast zx s_144_52 -> bv
        let s_144_55: Bits = Bits::new(s_144_52 as u128, 32u16);
        // C s_144_56: const #1u : u8
        let s_144_56: bool = true;
        // C s_144_57: cast zx s_144_56 -> bv
        let s_144_57: Bits = Bits::new(s_144_56 as u128, 1u16);
        // C s_144_58: const #1u : u64
        let s_144_58: u64 = 1;
        // C s_144_59: cast zx s_144_58 -> bv
        let s_144_59: Bits = Bits::new(s_144_58 as u128, 64u16);
        // C s_144_60: lsl s_144_59 s_144_53
        let s_144_60: Bits = s_144_59 << s_144_53;
        // C s_144_61: sub s_144_60 s_144_59
        let s_144_61: Bits = ((s_144_60) - (s_144_59));
        // C s_144_62: and s_144_57 s_144_61
        let s_144_62: Bits = ((s_144_57) & (s_144_61));
        // C s_144_63: lsl s_144_62 s_144_54
        let s_144_63: Bits = s_144_62 << s_144_54;
        // C s_144_64: lsl s_144_61 s_144_54
        let s_144_64: Bits = s_144_61 << s_144_54;
        // C s_144_65: cmpl s_144_64
        let s_144_65: Bits = !s_144_64;
        // D s_144_66: and s_144_55 s_144_65
        let s_144_66: Bits = ((s_144_55) & (s_144_65));
        // D s_144_67: or s_144_66 s_144_63
        let s_144_67: Bits = ((s_144_66) | (s_144_63));
        // D s_144_68: cast reint s_144_67 -> u32
        let s_144_68: u32 = (s_144_67.value() as u32);
        // D s_144_69: call Mk_CTR_Type(s_144_68)
        let s_144_69: ProductType700c18a878c5601b = Mk_CTR_Type(state, tracer, s_144_68);
        // D s_144_70: call CTR_write(s_144_69)
        let s_144_70: () = CTR_write(state, tracer, s_144_69);
        // C s_144_71: const #() : ()
        let s_144_71: () = ();
        // S s_144_72: call CTR_read(s_144_71)
        let s_144_72: ProductType700c18a878c5601b = CTR_read(state, tracer, s_144_71);
        // D s_144_73: write-var ga#35248 <= s_144_72
        fn_state.ga_35248 = s_144_72;
        // D s_144_74: read-var ga#35248.0:struct
        let s_144_74: u32 = fn_state.ga_35248._0;
        // C s_144_75: const #1s : i
        let s_144_75: i128 = 1;
        // C s_144_76: const #30s : i
        let s_144_76: i128 = 30;
        // D s_144_77: cast zx s_144_74 -> bv
        let s_144_77: Bits = Bits::new(s_144_74 as u128, 32u16);
        // C s_144_78: const #0u : u8
        let s_144_78: bool = false;
        // C s_144_79: cast zx s_144_78 -> bv
        let s_144_79: Bits = Bits::new(s_144_78 as u128, 1u16);
        // C s_144_80: const #1u : u64
        let s_144_80: u64 = 1;
        // C s_144_81: cast zx s_144_80 -> bv
        let s_144_81: Bits = Bits::new(s_144_80 as u128, 64u16);
        // C s_144_82: lsl s_144_81 s_144_75
        let s_144_82: Bits = s_144_81 << s_144_75;
        // C s_144_83: sub s_144_82 s_144_81
        let s_144_83: Bits = ((s_144_82) - (s_144_81));
        // C s_144_84: and s_144_79 s_144_83
        let s_144_84: Bits = ((s_144_79) & (s_144_83));
        // C s_144_85: lsl s_144_84 s_144_76
        let s_144_85: Bits = s_144_84 << s_144_76;
        // C s_144_86: lsl s_144_83 s_144_76
        let s_144_86: Bits = s_144_83 << s_144_76;
        // C s_144_87: cmpl s_144_86
        let s_144_87: Bits = !s_144_86;
        // D s_144_88: and s_144_77 s_144_87
        let s_144_88: Bits = ((s_144_77) & (s_144_87));
        // D s_144_89: or s_144_88 s_144_85
        let s_144_89: Bits = ((s_144_88) | (s_144_85));
        // D s_144_90: cast reint s_144_89 -> u32
        let s_144_90: u32 = (s_144_89.value() as u32);
        // D s_144_91: call Mk_CTR_Type(s_144_90)
        let s_144_91: ProductType700c18a878c5601b = Mk_CTR_Type(state, tracer, s_144_90);
        // D s_144_92: call CTR_write(s_144_91)
        let s_144_92: () = CTR_write(state, tracer, s_144_91);
        // C s_144_93: const #() : ()
        let s_144_93: () = ();
        // S s_144_94: call CTR_read(s_144_93)
        let s_144_94: ProductType700c18a878c5601b = CTR_read(state, tracer, s_144_93);
        // D s_144_95: write-var ga#35252 <= s_144_94
        fn_state.ga_35252 = s_144_94;
        // D s_144_96: read-var ga#35252.0:struct
        let s_144_96: u32 = fn_state.ga_35252._0;
        // C s_144_97: const #10s : i
        let s_144_97: i128 = 10;
        // C s_144_98: const #4s : i
        let s_144_98: i128 = 4;
        // D s_144_99: cast zx s_144_96 -> bv
        let s_144_99: Bits = Bits::new(s_144_96 as u128, 32u16);
        // C s_144_100: const #0u : u10
        let s_144_100: u16 = 0;
        // C s_144_101: cast zx s_144_100 -> bv
        let s_144_101: Bits = Bits::new(s_144_100 as u128, 10u16);
        // C s_144_102: const #1u : u64
        let s_144_102: u64 = 1;
        // C s_144_103: cast zx s_144_102 -> bv
        let s_144_103: Bits = Bits::new(s_144_102 as u128, 64u16);
        // C s_144_104: lsl s_144_103 s_144_97
        let s_144_104: Bits = s_144_103 << s_144_97;
        // C s_144_105: sub s_144_104 s_144_103
        let s_144_105: Bits = ((s_144_104) - (s_144_103));
        // C s_144_106: and s_144_101 s_144_105
        let s_144_106: Bits = ((s_144_101) & (s_144_105));
        // C s_144_107: lsl s_144_106 s_144_98
        let s_144_107: Bits = s_144_106 << s_144_98;
        // C s_144_108: lsl s_144_105 s_144_98
        let s_144_108: Bits = s_144_105 << s_144_98;
        // C s_144_109: cmpl s_144_108
        let s_144_109: Bits = !s_144_108;
        // D s_144_110: and s_144_99 s_144_109
        let s_144_110: Bits = ((s_144_99) & (s_144_109));
        // D s_144_111: or s_144_110 s_144_107
        let s_144_111: Bits = ((s_144_110) | (s_144_107));
        // D s_144_112: cast reint s_144_111 -> u32
        let s_144_112: u32 = (s_144_111.value() as u32);
        // D s_144_113: call Mk_CTR_Type(s_144_112)
        let s_144_113: ProductType700c18a878c5601b = Mk_CTR_Type(
            state,
            tracer,
            s_144_112,
        );
        // D s_144_114: call CTR_write(s_144_113)
        let s_144_114: () = CTR_write(state, tracer, s_144_113);
        // C s_144_115: const #() : ()
        let s_144_115: () = ();
        // S s_144_116: call PMUSERENR_read(s_144_115)
        let s_144_116: ProductType700c18a878c5601b = PMUSERENR_read(
            state,
            tracer,
            s_144_115,
        );
        // D s_144_117: write-var ga#35256 <= s_144_116
        fn_state.ga_35256 = s_144_116;
        // D s_144_118: read-var ga#35256.0:struct
        let s_144_118: u32 = fn_state.ga_35256._0;
        // C s_144_119: const #25s : i
        let s_144_119: i128 = 25;
        // C s_144_120: const #7s : i
        let s_144_120: i128 = 7;
        // D s_144_121: cast zx s_144_118 -> bv
        let s_144_121: Bits = Bits::new(s_144_118 as u128, 32u16);
        // C s_144_122: const #0u : u25
        let s_144_122: u32 = 0;
        // C s_144_123: cast zx s_144_122 -> bv
        let s_144_123: Bits = Bits::new(s_144_122 as u128, 25u16);
        // C s_144_124: const #1u : u64
        let s_144_124: u64 = 1;
        // C s_144_125: cast zx s_144_124 -> bv
        let s_144_125: Bits = Bits::new(s_144_124 as u128, 64u16);
        // C s_144_126: lsl s_144_125 s_144_119
        let s_144_126: Bits = s_144_125 << s_144_119;
        // C s_144_127: sub s_144_126 s_144_125
        let s_144_127: Bits = ((s_144_126) - (s_144_125));
        // C s_144_128: and s_144_123 s_144_127
        let s_144_128: Bits = ((s_144_123) & (s_144_127));
        // C s_144_129: lsl s_144_128 s_144_120
        let s_144_129: Bits = s_144_128 << s_144_120;
        // C s_144_130: lsl s_144_127 s_144_120
        let s_144_130: Bits = s_144_127 << s_144_120;
        // C s_144_131: cmpl s_144_130
        let s_144_131: Bits = !s_144_130;
        // D s_144_132: and s_144_121 s_144_131
        let s_144_132: Bits = ((s_144_121) & (s_144_131));
        // D s_144_133: or s_144_132 s_144_129
        let s_144_133: Bits = ((s_144_132) | (s_144_129));
        // D s_144_134: cast reint s_144_133 -> u32
        let s_144_134: u32 = (s_144_133.value() as u32);
        // D s_144_135: call Mk_PMUSERENR_Type(s_144_134)
        let s_144_135: ProductType700c18a878c5601b = Mk_PMUSERENR_Type(
            state,
            tracer,
            s_144_134,
        );
        // D s_144_136: call PMUSERENR_write(s_144_135)
        let s_144_136: () = PMUSERENR_write(state, tracer, s_144_135);
        // C s_144_137: const #() : ()
        let s_144_137: () = ();
        // S s_144_138: call PMUSERENR_read(s_144_137)
        let s_144_138: ProductType700c18a878c5601b = PMUSERENR_read(
            state,
            tracer,
            s_144_137,
        );
        // D s_144_139: write-var ga#35260 <= s_144_138
        fn_state.ga_35260 = s_144_138;
        // D s_144_140: read-var ga#35260.0:struct
        let s_144_140: u32 = fn_state.ga_35260._0;
        // C s_144_141: const #2s : i
        let s_144_141: i128 = 2;
        // C s_144_142: const #4s : i
        let s_144_142: i128 = 4;
        // D s_144_143: cast zx s_144_140 -> bv
        let s_144_143: Bits = Bits::new(s_144_140 as u128, 32u16);
        // C s_144_144: const #0u : u8
        let s_144_144: u8 = 0;
        // C s_144_145: cast zx s_144_144 -> bv
        let s_144_145: Bits = Bits::new(s_144_144 as u128, 2u16);
        // C s_144_146: const #1u : u64
        let s_144_146: u64 = 1;
        // C s_144_147: cast zx s_144_146 -> bv
        let s_144_147: Bits = Bits::new(s_144_146 as u128, 64u16);
        // C s_144_148: lsl s_144_147 s_144_141
        let s_144_148: Bits = s_144_147 << s_144_141;
        // C s_144_149: sub s_144_148 s_144_147
        let s_144_149: Bits = ((s_144_148) - (s_144_147));
        // C s_144_150: and s_144_145 s_144_149
        let s_144_150: Bits = ((s_144_145) & (s_144_149));
        // C s_144_151: lsl s_144_150 s_144_142
        let s_144_151: Bits = s_144_150 << s_144_142;
        // C s_144_152: lsl s_144_149 s_144_142
        let s_144_152: Bits = s_144_149 << s_144_142;
        // C s_144_153: cmpl s_144_152
        let s_144_153: Bits = !s_144_152;
        // D s_144_154: and s_144_143 s_144_153
        let s_144_154: Bits = ((s_144_143) & (s_144_153));
        // D s_144_155: or s_144_154 s_144_151
        let s_144_155: Bits = ((s_144_154) | (s_144_151));
        // D s_144_156: cast reint s_144_155 -> u32
        let s_144_156: u32 = (s_144_155.value() as u32);
        // D s_144_157: call Mk_PMUSERENR_Type(s_144_156)
        let s_144_157: ProductType700c18a878c5601b = Mk_PMUSERENR_Type(
            state,
            tracer,
            s_144_156,
        );
        // D s_144_158: call PMUSERENR_write(s_144_157)
        let s_144_158: () = PMUSERENR_write(state, tracer, s_144_157);
        // C s_144_159: const #() : ()
        let s_144_159: () = ();
        // S s_144_160: call CNTHPS_CTL_read(s_144_159)
        let s_144_160: ProductType700c18a878c5601b = CNTHPS_CTL_read(
            state,
            tracer,
            s_144_159,
        );
        // D s_144_161: write-var ga#35264 <= s_144_160
        fn_state.ga_35264 = s_144_160;
        // D s_144_162: read-var ga#35264.0:struct
        let s_144_162: u32 = fn_state.ga_35264._0;
        // C s_144_163: const #29s : i
        let s_144_163: i128 = 29;
        // C s_144_164: const #3s : i
        let s_144_164: i128 = 3;
        // D s_144_165: cast zx s_144_162 -> bv
        let s_144_165: Bits = Bits::new(s_144_162 as u128, 32u16);
        // C s_144_166: const #0u : u29
        let s_144_166: u32 = 0;
        // C s_144_167: cast zx s_144_166 -> bv
        let s_144_167: Bits = Bits::new(s_144_166 as u128, 29u16);
        // C s_144_168: const #1u : u64
        let s_144_168: u64 = 1;
        // C s_144_169: cast zx s_144_168 -> bv
        let s_144_169: Bits = Bits::new(s_144_168 as u128, 64u16);
        // C s_144_170: lsl s_144_169 s_144_163
        let s_144_170: Bits = s_144_169 << s_144_163;
        // C s_144_171: sub s_144_170 s_144_169
        let s_144_171: Bits = ((s_144_170) - (s_144_169));
        // C s_144_172: and s_144_167 s_144_171
        let s_144_172: Bits = ((s_144_167) & (s_144_171));
        // C s_144_173: lsl s_144_172 s_144_164
        let s_144_173: Bits = s_144_172 << s_144_164;
        // C s_144_174: lsl s_144_171 s_144_164
        let s_144_174: Bits = s_144_171 << s_144_164;
        // C s_144_175: cmpl s_144_174
        let s_144_175: Bits = !s_144_174;
        // D s_144_176: and s_144_165 s_144_175
        let s_144_176: Bits = ((s_144_165) & (s_144_175));
        // D s_144_177: or s_144_176 s_144_173
        let s_144_177: Bits = ((s_144_176) | (s_144_173));
        // D s_144_178: cast reint s_144_177 -> u32
        let s_144_178: u32 = (s_144_177.value() as u32);
        // D s_144_179: call Mk_CNTHPS_CTL_Type(s_144_178)
        let s_144_179: ProductType700c18a878c5601b = Mk_CNTHPS_CTL_Type(
            state,
            tracer,
            s_144_178,
        );
        // D s_144_180: call CNTHPS_CTL_write(s_144_179)
        let s_144_180: () = CNTHPS_CTL_write(state, tracer, s_144_179);
        // C s_144_181: const #() : ()
        let s_144_181: () = ();
        // S s_144_182: call DBGAUTHSTATUS_read(s_144_181)
        let s_144_182: ProductType700c18a878c5601b = DBGAUTHSTATUS_read(
            state,
            tracer,
            s_144_181,
        );
        // D s_144_183: write-var ga#35268 <= s_144_182
        fn_state.ga_35268 = s_144_182;
        // D s_144_184: read-var ga#35268.0:struct
        let s_144_184: u32 = fn_state.ga_35268._0;
        // C s_144_185: const #24s : i
        let s_144_185: i128 = 24;
        // C s_144_186: const #8s : i
        let s_144_186: i128 = 8;
        // D s_144_187: cast zx s_144_184 -> bv
        let s_144_187: Bits = Bits::new(s_144_184 as u128, 32u16);
        // C s_144_188: const #0u : u24
        let s_144_188: u32 = 0;
        // C s_144_189: cast zx s_144_188 -> bv
        let s_144_189: Bits = Bits::new(s_144_188 as u128, 24u16);
        // C s_144_190: const #1u : u64
        let s_144_190: u64 = 1;
        // C s_144_191: cast zx s_144_190 -> bv
        let s_144_191: Bits = Bits::new(s_144_190 as u128, 64u16);
        // C s_144_192: lsl s_144_191 s_144_185
        let s_144_192: Bits = s_144_191 << s_144_185;
        // C s_144_193: sub s_144_192 s_144_191
        let s_144_193: Bits = ((s_144_192) - (s_144_191));
        // C s_144_194: and s_144_189 s_144_193
        let s_144_194: Bits = ((s_144_189) & (s_144_193));
        // C s_144_195: lsl s_144_194 s_144_186
        let s_144_195: Bits = s_144_194 << s_144_186;
        // C s_144_196: lsl s_144_193 s_144_186
        let s_144_196: Bits = s_144_193 << s_144_186;
        // C s_144_197: cmpl s_144_196
        let s_144_197: Bits = !s_144_196;
        // D s_144_198: and s_144_187 s_144_197
        let s_144_198: Bits = ((s_144_187) & (s_144_197));
        // D s_144_199: or s_144_198 s_144_195
        let s_144_199: Bits = ((s_144_198) | (s_144_195));
        // D s_144_200: cast reint s_144_199 -> u32
        let s_144_200: u32 = (s_144_199.value() as u32);
        // D s_144_201: call Mk_DBGAUTHSTATUS_Type(s_144_200)
        let s_144_201: ProductType700c18a878c5601b = Mk_DBGAUTHSTATUS_Type(
            state,
            tracer,
            s_144_200,
        );
        // D s_144_202: call DBGAUTHSTATUS_write(s_144_201)
        let s_144_202: () = DBGAUTHSTATUS_write(state, tracer, s_144_201);
        // C s_144_203: const #() : ()
        let s_144_203: () = ();
        // S s_144_204: call ICC_IAR0_read(s_144_203)
        let s_144_204: ProductType700c18a878c5601b = ICC_IAR0_read(
            state,
            tracer,
            s_144_203,
        );
        // D s_144_205: write-var ga#35272 <= s_144_204
        fn_state.ga_35272 = s_144_204;
        // D s_144_206: read-var ga#35272.0:struct
        let s_144_206: u32 = fn_state.ga_35272._0;
        // C s_144_207: const #8s : i
        let s_144_207: i128 = 8;
        // C s_144_208: const #24s : i
        let s_144_208: i128 = 24;
        // D s_144_209: cast zx s_144_206 -> bv
        let s_144_209: Bits = Bits::new(s_144_206 as u128, 32u16);
        // C s_144_210: const #0u : u8
        let s_144_210: u8 = 0;
        // C s_144_211: cast zx s_144_210 -> bv
        let s_144_211: Bits = Bits::new(s_144_210 as u128, 8u16);
        // C s_144_212: const #1u : u64
        let s_144_212: u64 = 1;
        // C s_144_213: cast zx s_144_212 -> bv
        let s_144_213: Bits = Bits::new(s_144_212 as u128, 64u16);
        // C s_144_214: lsl s_144_213 s_144_207
        let s_144_214: Bits = s_144_213 << s_144_207;
        // C s_144_215: sub s_144_214 s_144_213
        let s_144_215: Bits = ((s_144_214) - (s_144_213));
        // C s_144_216: and s_144_211 s_144_215
        let s_144_216: Bits = ((s_144_211) & (s_144_215));
        // C s_144_217: lsl s_144_216 s_144_208
        let s_144_217: Bits = s_144_216 << s_144_208;
        // C s_144_218: lsl s_144_215 s_144_208
        let s_144_218: Bits = s_144_215 << s_144_208;
        // C s_144_219: cmpl s_144_218
        let s_144_219: Bits = !s_144_218;
        // D s_144_220: and s_144_209 s_144_219
        let s_144_220: Bits = ((s_144_209) & (s_144_219));
        // D s_144_221: or s_144_220 s_144_217
        let s_144_221: Bits = ((s_144_220) | (s_144_217));
        // D s_144_222: cast reint s_144_221 -> u32
        let s_144_222: u32 = (s_144_221.value() as u32);
        // D s_144_223: call Mk_ICC_IAR0_Type(s_144_222)
        let s_144_223: ProductType700c18a878c5601b = Mk_ICC_IAR0_Type(
            state,
            tracer,
            s_144_222,
        );
        // D s_144_224: call ICC_IAR0_write(s_144_223)
        let s_144_224: () = ICC_IAR0_write(state, tracer, s_144_223);
        // C s_144_225: const #() : ()
        let s_144_225: () = ();
        // S s_144_226: call ICV_IGRPEN0_read(s_144_225)
        let s_144_226: ProductType700c18a878c5601b = ICV_IGRPEN0_read(
            state,
            tracer,
            s_144_225,
        );
        // D s_144_227: write-var ga#35276 <= s_144_226
        fn_state.ga_35276 = s_144_226;
        // D s_144_228: read-var ga#35276.0:struct
        let s_144_228: u32 = fn_state.ga_35276._0;
        // C s_144_229: const #31s : i
        let s_144_229: i128 = 31;
        // C s_144_230: const #1s : i
        let s_144_230: i128 = 1;
        // D s_144_231: cast zx s_144_228 -> bv
        let s_144_231: Bits = Bits::new(s_144_228 as u128, 32u16);
        // C s_144_232: const #0u : u31
        let s_144_232: u32 = 0;
        // C s_144_233: cast zx s_144_232 -> bv
        let s_144_233: Bits = Bits::new(s_144_232 as u128, 31u16);
        // C s_144_234: const #1u : u64
        let s_144_234: u64 = 1;
        // C s_144_235: cast zx s_144_234 -> bv
        let s_144_235: Bits = Bits::new(s_144_234 as u128, 64u16);
        // C s_144_236: lsl s_144_235 s_144_229
        let s_144_236: Bits = s_144_235 << s_144_229;
        // C s_144_237: sub s_144_236 s_144_235
        let s_144_237: Bits = ((s_144_236) - (s_144_235));
        // C s_144_238: and s_144_233 s_144_237
        let s_144_238: Bits = ((s_144_233) & (s_144_237));
        // C s_144_239: lsl s_144_238 s_144_230
        let s_144_239: Bits = s_144_238 << s_144_230;
        // C s_144_240: lsl s_144_237 s_144_230
        let s_144_240: Bits = s_144_237 << s_144_230;
        // C s_144_241: cmpl s_144_240
        let s_144_241: Bits = !s_144_240;
        // D s_144_242: and s_144_231 s_144_241
        let s_144_242: Bits = ((s_144_231) & (s_144_241));
        // D s_144_243: or s_144_242 s_144_239
        let s_144_243: Bits = ((s_144_242) | (s_144_239));
        // D s_144_244: cast reint s_144_243 -> u32
        let s_144_244: u32 = (s_144_243.value() as u32);
        // D s_144_245: call Mk_ICV_IGRPEN0_Type(s_144_244)
        let s_144_245: ProductType700c18a878c5601b = Mk_ICV_IGRPEN0_Type(
            state,
            tracer,
            s_144_244,
        );
        // D s_144_246: call ICV_IGRPEN0_write(s_144_245)
        let s_144_246: () = ICV_IGRPEN0_write(state, tracer, s_144_245);
        // C s_144_247: const #() : ()
        let s_144_247: () = ();
        // S s_144_248: call ICV_IGRPEN0_read(s_144_247)
        let s_144_248: ProductType700c18a878c5601b = ICV_IGRPEN0_read(
            state,
            tracer,
            s_144_247,
        );
        // C s_144_249: const #0u : u8
        let s_144_249: bool = false;
        // S s_144_250: call _update_ICV_IGRPEN0_Type_Enable(s_144_248, s_144_249)
        let s_144_250: ProductType700c18a878c5601b = u_update_ICV_IGRPEN0_Type_Enable(
            state,
            tracer,
            s_144_248,
            s_144_249,
        );
        // S s_144_251: call ICV_IGRPEN0_write(s_144_250)
        let s_144_251: () = ICV_IGRPEN0_write(state, tracer, s_144_250);
        // C s_144_252: const #() : ()
        let s_144_252: () = ();
        // S s_144_253: call PRRR_read(s_144_252)
        let s_144_253: ProductType700c18a878c5601b = PRRR_read(state, tracer, s_144_252);
        // D s_144_254: write-var ga#35282 <= s_144_253
        fn_state.ga_35282 = s_144_253;
        // D s_144_255: read-var ga#35282.0:struct
        let s_144_255: u32 = fn_state.ga_35282._0;
        // C s_144_256: const #4s : i
        let s_144_256: i128 = 4;
        // C s_144_257: const #20s : i
        let s_144_257: i128 = 20;
        // D s_144_258: cast zx s_144_255 -> bv
        let s_144_258: Bits = Bits::new(s_144_255 as u128, 32u16);
        // C s_144_259: const #0u : u8
        let s_144_259: u8 = 0;
        // C s_144_260: cast zx s_144_259 -> bv
        let s_144_260: Bits = Bits::new(s_144_259 as u128, 4u16);
        // C s_144_261: const #1u : u64
        let s_144_261: u64 = 1;
        // C s_144_262: cast zx s_144_261 -> bv
        let s_144_262: Bits = Bits::new(s_144_261 as u128, 64u16);
        // C s_144_263: lsl s_144_262 s_144_256
        let s_144_263: Bits = s_144_262 << s_144_256;
        // C s_144_264: sub s_144_263 s_144_262
        let s_144_264: Bits = ((s_144_263) - (s_144_262));
        // C s_144_265: and s_144_260 s_144_264
        let s_144_265: Bits = ((s_144_260) & (s_144_264));
        // C s_144_266: lsl s_144_265 s_144_257
        let s_144_266: Bits = s_144_265 << s_144_257;
        // C s_144_267: lsl s_144_264 s_144_257
        let s_144_267: Bits = s_144_264 << s_144_257;
        // C s_144_268: cmpl s_144_267
        let s_144_268: Bits = !s_144_267;
        // D s_144_269: and s_144_258 s_144_268
        let s_144_269: Bits = ((s_144_258) & (s_144_268));
        // D s_144_270: or s_144_269 s_144_266
        let s_144_270: Bits = ((s_144_269) | (s_144_266));
        // D s_144_271: cast reint s_144_270 -> u32
        let s_144_271: u32 = (s_144_270.value() as u32);
        // D s_144_272: call Mk_PRRR_Type(s_144_271)
        let s_144_272: ProductType700c18a878c5601b = Mk_PRRR_Type(
            state,
            tracer,
            s_144_271,
        );
        // D s_144_273: call PRRR_write(s_144_272)
        let s_144_273: () = PRRR_write(state, tracer, s_144_272);
        // C s_144_274: const #() : ()
        let s_144_274: () = ();
        // S s_144_275: call ICV_CTLR_read(s_144_274)
        let s_144_275: ProductType700c18a878c5601b = ICV_CTLR_read(
            state,
            tracer,
            s_144_274,
        );
        // D s_144_276: write-var ga#35286 <= s_144_275
        fn_state.ga_35286 = s_144_275;
        // D s_144_277: read-var ga#35286.0:struct
        let s_144_277: u32 = fn_state.ga_35286._0;
        // C s_144_278: const #12s : i
        let s_144_278: i128 = 12;
        // C s_144_279: const #20s : i
        let s_144_279: i128 = 20;
        // D s_144_280: cast zx s_144_277 -> bv
        let s_144_280: Bits = Bits::new(s_144_277 as u128, 32u16);
        // C s_144_281: const #0u : u12
        let s_144_281: u16 = 0;
        // C s_144_282: cast zx s_144_281 -> bv
        let s_144_282: Bits = Bits::new(s_144_281 as u128, 12u16);
        // C s_144_283: const #1u : u64
        let s_144_283: u64 = 1;
        // C s_144_284: cast zx s_144_283 -> bv
        let s_144_284: Bits = Bits::new(s_144_283 as u128, 64u16);
        // C s_144_285: lsl s_144_284 s_144_278
        let s_144_285: Bits = s_144_284 << s_144_278;
        // C s_144_286: sub s_144_285 s_144_284
        let s_144_286: Bits = ((s_144_285) - (s_144_284));
        // C s_144_287: and s_144_282 s_144_286
        let s_144_287: Bits = ((s_144_282) & (s_144_286));
        // C s_144_288: lsl s_144_287 s_144_279
        let s_144_288: Bits = s_144_287 << s_144_279;
        // C s_144_289: lsl s_144_286 s_144_279
        let s_144_289: Bits = s_144_286 << s_144_279;
        // C s_144_290: cmpl s_144_289
        let s_144_290: Bits = !s_144_289;
        // D s_144_291: and s_144_280 s_144_290
        let s_144_291: Bits = ((s_144_280) & (s_144_290));
        // D s_144_292: or s_144_291 s_144_288
        let s_144_292: Bits = ((s_144_291) | (s_144_288));
        // D s_144_293: cast reint s_144_292 -> u32
        let s_144_293: u32 = (s_144_292.value() as u32);
        // D s_144_294: call Mk_ICV_CTLR_Type(s_144_293)
        let s_144_294: ProductType700c18a878c5601b = Mk_ICV_CTLR_Type(
            state,
            tracer,
            s_144_293,
        );
        // D s_144_295: call ICV_CTLR_write(s_144_294)
        let s_144_295: () = ICV_CTLR_write(state, tracer, s_144_294);
        // C s_144_296: const #() : ()
        let s_144_296: () = ();
        // S s_144_297: call ICV_CTLR_read(s_144_296)
        let s_144_297: ProductType700c18a878c5601b = ICV_CTLR_read(
            state,
            tracer,
            s_144_296,
        );
        // D s_144_298: write-var ga#35290 <= s_144_297
        fn_state.ga_35290 = s_144_297;
        // D s_144_299: read-var ga#35290.0:struct
        let s_144_299: u32 = fn_state.ga_35290._0;
        // C s_144_300: const #2s : i
        let s_144_300: i128 = 2;
        // C s_144_301: const #16s : i
        let s_144_301: i128 = 16;
        // D s_144_302: cast zx s_144_299 -> bv
        let s_144_302: Bits = Bits::new(s_144_299 as u128, 32u16);
        // C s_144_303: const #0u : u8
        let s_144_303: u8 = 0;
        // C s_144_304: cast zx s_144_303 -> bv
        let s_144_304: Bits = Bits::new(s_144_303 as u128, 2u16);
        // C s_144_305: const #1u : u64
        let s_144_305: u64 = 1;
        // C s_144_306: cast zx s_144_305 -> bv
        let s_144_306: Bits = Bits::new(s_144_305 as u128, 64u16);
        // C s_144_307: lsl s_144_306 s_144_300
        let s_144_307: Bits = s_144_306 << s_144_300;
        // C s_144_308: sub s_144_307 s_144_306
        let s_144_308: Bits = ((s_144_307) - (s_144_306));
        // C s_144_309: and s_144_304 s_144_308
        let s_144_309: Bits = ((s_144_304) & (s_144_308));
        // C s_144_310: lsl s_144_309 s_144_301
        let s_144_310: Bits = s_144_309 << s_144_301;
        // C s_144_311: lsl s_144_308 s_144_301
        let s_144_311: Bits = s_144_308 << s_144_301;
        // C s_144_312: cmpl s_144_311
        let s_144_312: Bits = !s_144_311;
        // D s_144_313: and s_144_302 s_144_312
        let s_144_313: Bits = ((s_144_302) & (s_144_312));
        // D s_144_314: or s_144_313 s_144_310
        let s_144_314: Bits = ((s_144_313) | (s_144_310));
        // D s_144_315: cast reint s_144_314 -> u32
        let s_144_315: u32 = (s_144_314.value() as u32);
        // D s_144_316: call Mk_ICV_CTLR_Type(s_144_315)
        let s_144_316: ProductType700c18a878c5601b = Mk_ICV_CTLR_Type(
            state,
            tracer,
            s_144_315,
        );
        // D s_144_317: call ICV_CTLR_write(s_144_316)
        let s_144_317: () = ICV_CTLR_write(state, tracer, s_144_316);
        // C s_144_318: const #() : ()
        let s_144_318: () = ();
        // S s_144_319: call ICV_CTLR_read(s_144_318)
        let s_144_319: ProductType700c18a878c5601b = ICV_CTLR_read(
            state,
            tracer,
            s_144_318,
        );
        // D s_144_320: write-var ga#35294 <= s_144_319
        fn_state.ga_35294 = s_144_319;
        // D s_144_321: read-var ga#35294.0:struct
        let s_144_321: u32 = fn_state.ga_35294._0;
        // C s_144_322: const #6s : i
        let s_144_322: i128 = 6;
        // C s_144_323: const #2s : i
        let s_144_323: i128 = 2;
        // D s_144_324: cast zx s_144_321 -> bv
        let s_144_324: Bits = Bits::new(s_144_321 as u128, 32u16);
        // C s_144_325: const #0u : u8
        let s_144_325: u8 = 0;
        // C s_144_326: cast zx s_144_325 -> bv
        let s_144_326: Bits = Bits::new(s_144_325 as u128, 6u16);
        // C s_144_327: const #1u : u64
        let s_144_327: u64 = 1;
        // C s_144_328: cast zx s_144_327 -> bv
        let s_144_328: Bits = Bits::new(s_144_327 as u128, 64u16);
        // C s_144_329: lsl s_144_328 s_144_322
        let s_144_329: Bits = s_144_328 << s_144_322;
        // C s_144_330: sub s_144_329 s_144_328
        let s_144_330: Bits = ((s_144_329) - (s_144_328));
        // C s_144_331: and s_144_326 s_144_330
        let s_144_331: Bits = ((s_144_326) & (s_144_330));
        // C s_144_332: lsl s_144_331 s_144_323
        let s_144_332: Bits = s_144_331 << s_144_323;
        // C s_144_333: lsl s_144_330 s_144_323
        let s_144_333: Bits = s_144_330 << s_144_323;
        // C s_144_334: cmpl s_144_333
        let s_144_334: Bits = !s_144_333;
        // D s_144_335: and s_144_324 s_144_334
        let s_144_335: Bits = ((s_144_324) & (s_144_334));
        // D s_144_336: or s_144_335 s_144_332
        let s_144_336: Bits = ((s_144_335) | (s_144_332));
        // D s_144_337: cast reint s_144_336 -> u32
        let s_144_337: u32 = (s_144_336.value() as u32);
        // D s_144_338: call Mk_ICV_CTLR_Type(s_144_337)
        let s_144_338: ProductType700c18a878c5601b = Mk_ICV_CTLR_Type(
            state,
            tracer,
            s_144_337,
        );
        // D s_144_339: call ICV_CTLR_write(s_144_338)
        let s_144_339: () = ICV_CTLR_write(state, tracer, s_144_338);
        // C s_144_340: const #() : ()
        let s_144_340: () = ();
        // S s_144_341: call HPFAR_read(s_144_340)
        let s_144_341: ProductType700c18a878c5601b = HPFAR_read(
            state,
            tracer,
            s_144_340,
        );
        // D s_144_342: write-var ga#35298 <= s_144_341
        fn_state.ga_35298 = s_144_341;
        // D s_144_343: read-var ga#35298.0:struct
        let s_144_343: u32 = fn_state.ga_35298._0;
        // C s_144_344: const #4s : i
        let s_144_344: i128 = 4;
        // C s_144_345: const #0s : i
        let s_144_345: i128 = 0;
        // D s_144_346: cast zx s_144_343 -> bv
        let s_144_346: Bits = Bits::new(s_144_343 as u128, 32u16);
        // C s_144_347: const #0u : u8
        let s_144_347: u8 = 0;
        // C s_144_348: cast zx s_144_347 -> bv
        let s_144_348: Bits = Bits::new(s_144_347 as u128, 4u16);
        // C s_144_349: const #1u : u64
        let s_144_349: u64 = 1;
        // C s_144_350: cast zx s_144_349 -> bv
        let s_144_350: Bits = Bits::new(s_144_349 as u128, 64u16);
        // C s_144_351: lsl s_144_350 s_144_344
        let s_144_351: Bits = s_144_350 << s_144_344;
        // C s_144_352: sub s_144_351 s_144_350
        let s_144_352: Bits = ((s_144_351) - (s_144_350));
        // C s_144_353: and s_144_348 s_144_352
        let s_144_353: Bits = ((s_144_348) & (s_144_352));
        // C s_144_354: lsl s_144_353 s_144_345
        let s_144_354: Bits = s_144_353 << s_144_345;
        // C s_144_355: lsl s_144_352 s_144_345
        let s_144_355: Bits = s_144_352 << s_144_345;
        // C s_144_356: cmpl s_144_355
        let s_144_356: Bits = !s_144_355;
        // D s_144_357: and s_144_346 s_144_356
        let s_144_357: Bits = ((s_144_346) & (s_144_356));
        // D s_144_358: or s_144_357 s_144_354
        let s_144_358: Bits = ((s_144_357) | (s_144_354));
        // D s_144_359: cast reint s_144_358 -> u32
        let s_144_359: u32 = (s_144_358.value() as u32);
        // D s_144_360: call Mk_HPFAR_Type(s_144_359)
        let s_144_360: ProductType700c18a878c5601b = Mk_HPFAR_Type(
            state,
            tracer,
            s_144_359,
        );
        // D s_144_361: call HPFAR_write(s_144_360)
        let s_144_361: () = HPFAR_write(state, tracer, s_144_360);
        // C s_144_362: const #() : ()
        let s_144_362: () = ();
        // S s_144_363: call DBGCLAIMCLR_read(s_144_362)
        let s_144_363: ProductType700c18a878c5601b = DBGCLAIMCLR_read(
            state,
            tracer,
            s_144_362,
        );
        // D s_144_364: write-var ga#35302 <= s_144_363
        fn_state.ga_35302 = s_144_363;
        // D s_144_365: read-var ga#35302.0:struct
        let s_144_365: u32 = fn_state.ga_35302._0;
        // C s_144_366: const #24s : i
        let s_144_366: i128 = 24;
        // C s_144_367: const #8s : i
        let s_144_367: i128 = 8;
        // D s_144_368: cast zx s_144_365 -> bv
        let s_144_368: Bits = Bits::new(s_144_365 as u128, 32u16);
        // C s_144_369: const #0u : u24
        let s_144_369: u32 = 0;
        // C s_144_370: cast zx s_144_369 -> bv
        let s_144_370: Bits = Bits::new(s_144_369 as u128, 24u16);
        // C s_144_371: const #1u : u64
        let s_144_371: u64 = 1;
        // C s_144_372: cast zx s_144_371 -> bv
        let s_144_372: Bits = Bits::new(s_144_371 as u128, 64u16);
        // C s_144_373: lsl s_144_372 s_144_366
        let s_144_373: Bits = s_144_372 << s_144_366;
        // C s_144_374: sub s_144_373 s_144_372
        let s_144_374: Bits = ((s_144_373) - (s_144_372));
        // C s_144_375: and s_144_370 s_144_374
        let s_144_375: Bits = ((s_144_370) & (s_144_374));
        // C s_144_376: lsl s_144_375 s_144_367
        let s_144_376: Bits = s_144_375 << s_144_367;
        // C s_144_377: lsl s_144_374 s_144_367
        let s_144_377: Bits = s_144_374 << s_144_367;
        // C s_144_378: cmpl s_144_377
        let s_144_378: Bits = !s_144_377;
        // D s_144_379: and s_144_368 s_144_378
        let s_144_379: Bits = ((s_144_368) & (s_144_378));
        // D s_144_380: or s_144_379 s_144_376
        let s_144_380: Bits = ((s_144_379) | (s_144_376));
        // D s_144_381: cast reint s_144_380 -> u32
        let s_144_381: u32 = (s_144_380.value() as u32);
        // D s_144_382: call Mk_DBGCLAIMCLR_Type(s_144_381)
        let s_144_382: ProductType700c18a878c5601b = Mk_DBGCLAIMCLR_Type(
            state,
            tracer,
            s_144_381,
        );
        // D s_144_383: call DBGCLAIMCLR_write(s_144_382)
        let s_144_383: () = DBGCLAIMCLR_write(state, tracer, s_144_382);
        // D s_144_384: read-var cold:u8
        let s_144_384: bool = fn_state.cold;
        // N s_144_385: branch s_144_384 b579 b145
        if s_144_384 {
            return block_579(state, tracer, fn_state);
        } else {
            return block_145(state, tracer, fn_state);
        };
    }
    fn block_145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_145_0: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_146_0: const #() : ()
        let s_146_0: () = ();
        // S s_146_1: call ICV_HPPIR1_read(s_146_0)
        let s_146_1: ProductType700c18a878c5601b = ICV_HPPIR1_read(
            state,
            tracer,
            s_146_0,
        );
        // D s_146_2: write-var ga#35308 <= s_146_1
        fn_state.ga_35308 = s_146_1;
        // D s_146_3: read-var ga#35308.0:struct
        let s_146_3: u32 = fn_state.ga_35308._0;
        // C s_146_4: const #8s : i
        let s_146_4: i128 = 8;
        // C s_146_5: const #24s : i
        let s_146_5: i128 = 24;
        // D s_146_6: cast zx s_146_3 -> bv
        let s_146_6: Bits = Bits::new(s_146_3 as u128, 32u16);
        // C s_146_7: const #0u : u8
        let s_146_7: u8 = 0;
        // C s_146_8: cast zx s_146_7 -> bv
        let s_146_8: Bits = Bits::new(s_146_7 as u128, 8u16);
        // C s_146_9: const #1u : u64
        let s_146_9: u64 = 1;
        // C s_146_10: cast zx s_146_9 -> bv
        let s_146_10: Bits = Bits::new(s_146_9 as u128, 64u16);
        // C s_146_11: lsl s_146_10 s_146_4
        let s_146_11: Bits = s_146_10 << s_146_4;
        // C s_146_12: sub s_146_11 s_146_10
        let s_146_12: Bits = ((s_146_11) - (s_146_10));
        // C s_146_13: and s_146_8 s_146_12
        let s_146_13: Bits = ((s_146_8) & (s_146_12));
        // C s_146_14: lsl s_146_13 s_146_5
        let s_146_14: Bits = s_146_13 << s_146_5;
        // C s_146_15: lsl s_146_12 s_146_5
        let s_146_15: Bits = s_146_12 << s_146_5;
        // C s_146_16: cmpl s_146_15
        let s_146_16: Bits = !s_146_15;
        // D s_146_17: and s_146_6 s_146_16
        let s_146_17: Bits = ((s_146_6) & (s_146_16));
        // D s_146_18: or s_146_17 s_146_14
        let s_146_18: Bits = ((s_146_17) | (s_146_14));
        // D s_146_19: cast reint s_146_18 -> u32
        let s_146_19: u32 = (s_146_18.value() as u32);
        // D s_146_20: call Mk_ICV_HPPIR1_Type(s_146_19)
        let s_146_20: ProductType700c18a878c5601b = Mk_ICV_HPPIR1_Type(
            state,
            tracer,
            s_146_19,
        );
        // D s_146_21: call ICV_HPPIR1_write(s_146_20)
        let s_146_21: () = ICV_HPPIR1_write(state, tracer, s_146_20);
        // C s_146_22: const #() : ()
        let s_146_22: () = ();
        // S s_146_23: call ID_MMFR5_read(s_146_22)
        let s_146_23: ProductType700c18a878c5601b = ID_MMFR5_read(
            state,
            tracer,
            s_146_22,
        );
        // D s_146_24: write-var ga#35312 <= s_146_23
        fn_state.ga_35312 = s_146_23;
        // D s_146_25: read-var ga#35312.0:struct
        let s_146_25: u32 = fn_state.ga_35312._0;
        // C s_146_26: const #24s : i
        let s_146_26: i128 = 24;
        // C s_146_27: const #8s : i
        let s_146_27: i128 = 8;
        // D s_146_28: cast zx s_146_25 -> bv
        let s_146_28: Bits = Bits::new(s_146_25 as u128, 32u16);
        // C s_146_29: const #0u : u24
        let s_146_29: u32 = 0;
        // C s_146_30: cast zx s_146_29 -> bv
        let s_146_30: Bits = Bits::new(s_146_29 as u128, 24u16);
        // C s_146_31: const #1u : u64
        let s_146_31: u64 = 1;
        // C s_146_32: cast zx s_146_31 -> bv
        let s_146_32: Bits = Bits::new(s_146_31 as u128, 64u16);
        // C s_146_33: lsl s_146_32 s_146_26
        let s_146_33: Bits = s_146_32 << s_146_26;
        // C s_146_34: sub s_146_33 s_146_32
        let s_146_34: Bits = ((s_146_33) - (s_146_32));
        // C s_146_35: and s_146_30 s_146_34
        let s_146_35: Bits = ((s_146_30) & (s_146_34));
        // C s_146_36: lsl s_146_35 s_146_27
        let s_146_36: Bits = s_146_35 << s_146_27;
        // C s_146_37: lsl s_146_34 s_146_27
        let s_146_37: Bits = s_146_34 << s_146_27;
        // C s_146_38: cmpl s_146_37
        let s_146_38: Bits = !s_146_37;
        // D s_146_39: and s_146_28 s_146_38
        let s_146_39: Bits = ((s_146_28) & (s_146_38));
        // D s_146_40: or s_146_39 s_146_36
        let s_146_40: Bits = ((s_146_39) | (s_146_36));
        // D s_146_41: cast reint s_146_40 -> u32
        let s_146_41: u32 = (s_146_40.value() as u32);
        // D s_146_42: call Mk_ID_MMFR5_Type(s_146_41)
        let s_146_42: ProductType700c18a878c5601b = Mk_ID_MMFR5_Type(
            state,
            tracer,
            s_146_41,
        );
        // D s_146_43: call ID_MMFR5_write(s_146_42)
        let s_146_43: () = ID_MMFR5_write(state, tracer, s_146_42);
        // C s_146_44: const #() : ()
        let s_146_44: () = ();
        // S s_146_45: call HRMR_read(s_146_44)
        let s_146_45: ProductType700c18a878c5601b = HRMR_read(state, tracer, s_146_44);
        // D s_146_46: write-var ga#35316 <= s_146_45
        fn_state.ga_35316 = s_146_45;
        // D s_146_47: read-var ga#35316.0:struct
        let s_146_47: u32 = fn_state.ga_35316._0;
        // C s_146_48: const #30s : i
        let s_146_48: i128 = 30;
        // C s_146_49: const #2s : i
        let s_146_49: i128 = 2;
        // D s_146_50: cast zx s_146_47 -> bv
        let s_146_50: Bits = Bits::new(s_146_47 as u128, 32u16);
        // C s_146_51: const #0u : u30
        let s_146_51: u32 = 0;
        // C s_146_52: cast zx s_146_51 -> bv
        let s_146_52: Bits = Bits::new(s_146_51 as u128, 30u16);
        // C s_146_53: const #1u : u64
        let s_146_53: u64 = 1;
        // C s_146_54: cast zx s_146_53 -> bv
        let s_146_54: Bits = Bits::new(s_146_53 as u128, 64u16);
        // C s_146_55: lsl s_146_54 s_146_48
        let s_146_55: Bits = s_146_54 << s_146_48;
        // C s_146_56: sub s_146_55 s_146_54
        let s_146_56: Bits = ((s_146_55) - (s_146_54));
        // C s_146_57: and s_146_52 s_146_56
        let s_146_57: Bits = ((s_146_52) & (s_146_56));
        // C s_146_58: lsl s_146_57 s_146_49
        let s_146_58: Bits = s_146_57 << s_146_49;
        // C s_146_59: lsl s_146_56 s_146_49
        let s_146_59: Bits = s_146_56 << s_146_49;
        // C s_146_60: cmpl s_146_59
        let s_146_60: Bits = !s_146_59;
        // D s_146_61: and s_146_50 s_146_60
        let s_146_61: Bits = ((s_146_50) & (s_146_60));
        // D s_146_62: or s_146_61 s_146_58
        let s_146_62: Bits = ((s_146_61) | (s_146_58));
        // D s_146_63: cast reint s_146_62 -> u32
        let s_146_63: u32 = (s_146_62.value() as u32);
        // D s_146_64: call Mk_HRMR_Type(s_146_63)
        let s_146_64: ProductType700c18a878c5601b = Mk_HRMR_Type(
            state,
            tracer,
            s_146_63,
        );
        // D s_146_65: call HRMR_write(s_146_64)
        let s_146_65: () = HRMR_write(state, tracer, s_146_64);
        // C s_146_66: const #() : ()
        let s_146_66: () = ();
        // S s_146_67: call HRMR_read(s_146_66)
        let s_146_67: ProductType700c18a878c5601b = HRMR_read(state, tracer, s_146_66);
        // C s_146_68: const #0u : u8
        let s_146_68: bool = false;
        // S s_146_69: call _update_HRMR_Type_RR(s_146_67, s_146_68)
        let s_146_69: ProductType700c18a878c5601b = u_update_HRMR_Type_RR(
            state,
            tracer,
            s_146_67,
            s_146_68,
        );
        // S s_146_70: call HRMR_write(s_146_69)
        let s_146_70: () = HRMR_write(state, tracer, s_146_69);
        // C s_146_71: const #() : ()
        let s_146_71: () = ();
        // S s_146_72: call HCR2_read(s_146_71)
        let s_146_72: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_146_71);
        // D s_146_73: write-var ga#35322 <= s_146_72
        fn_state.ga_35322 = s_146_72;
        // D s_146_74: read-var ga#35322.0:struct
        let s_146_74: u32 = fn_state.ga_35322._0;
        // C s_146_75: const #9s : i
        let s_146_75: i128 = 9;
        // C s_146_76: const #23s : i
        let s_146_76: i128 = 23;
        // D s_146_77: cast zx s_146_74 -> bv
        let s_146_77: Bits = Bits::new(s_146_74 as u128, 32u16);
        // C s_146_78: const #0u : u9
        let s_146_78: u16 = 0;
        // C s_146_79: cast zx s_146_78 -> bv
        let s_146_79: Bits = Bits::new(s_146_78 as u128, 9u16);
        // C s_146_80: const #1u : u64
        let s_146_80: u64 = 1;
        // C s_146_81: cast zx s_146_80 -> bv
        let s_146_81: Bits = Bits::new(s_146_80 as u128, 64u16);
        // C s_146_82: lsl s_146_81 s_146_75
        let s_146_82: Bits = s_146_81 << s_146_75;
        // C s_146_83: sub s_146_82 s_146_81
        let s_146_83: Bits = ((s_146_82) - (s_146_81));
        // C s_146_84: and s_146_79 s_146_83
        let s_146_84: Bits = ((s_146_79) & (s_146_83));
        // C s_146_85: lsl s_146_84 s_146_76
        let s_146_85: Bits = s_146_84 << s_146_76;
        // C s_146_86: lsl s_146_83 s_146_76
        let s_146_86: Bits = s_146_83 << s_146_76;
        // C s_146_87: cmpl s_146_86
        let s_146_87: Bits = !s_146_86;
        // D s_146_88: and s_146_77 s_146_87
        let s_146_88: Bits = ((s_146_77) & (s_146_87));
        // D s_146_89: or s_146_88 s_146_85
        let s_146_89: Bits = ((s_146_88) | (s_146_85));
        // D s_146_90: cast reint s_146_89 -> u32
        let s_146_90: u32 = (s_146_89.value() as u32);
        // D s_146_91: call Mk_HCR2_Type(s_146_90)
        let s_146_91: ProductType700c18a878c5601b = Mk_HCR2_Type(
            state,
            tracer,
            s_146_90,
        );
        // D s_146_92: call HCR2_write(s_146_91)
        let s_146_92: () = HCR2_write(state, tracer, s_146_91);
        // D s_146_93: read-var cold:u8
        let s_146_93: bool = fn_state.cold;
        // D s_146_94: not s_146_93
        let s_146_94: bool = !s_146_93;
        // N s_146_95: branch s_146_94 b578 b147
        if s_146_94 {
            return block_578(state, tracer, fn_state);
        } else {
            return block_147(state, tracer, fn_state);
        };
    }
    fn block_147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_147_0: const #0u : u8
        let s_147_0: bool = false;
        // D s_147_1: write-var gs#44104 <= s_147_0
        fn_state.gs_44104 = s_147_0;
        // N s_147_2: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_148_0: read-var gs#44104:u8
        let s_148_0: bool = fn_state.gs_44104;
        // N s_148_1: branch s_148_0 b577 b149
        if s_148_0 {
            return block_577(state, tracer, fn_state);
        } else {
            return block_149(state, tracer, fn_state);
        };
    }
    fn block_149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_149_0: const #() : ()
        let s_149_0: () = ();
        // S s_149_1: call HCR2_read(s_149_0)
        let s_149_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_149_0);
        // C s_149_2: const #1s : i64
        let s_149_2: i64 = 1;
        // C s_149_3: cast zx s_149_2 -> i
        let s_149_3: i128 = (i128::try_from(s_149_2).unwrap());
        // S s_149_4: call __UNKNOWN_bits(s_149_3)
        let s_149_4: Bits = u__UNKNOWN_bits(state, tracer, s_149_3);
        // S s_149_5: cast reint s_149_4 -> u8
        let s_149_5: bool = ((s_149_4.value()) != 0);
        // S s_149_6: call _update_HCR2_Type_TTLBIS(s_149_1, s_149_5)
        let s_149_6: ProductType700c18a878c5601b = u_update_HCR2_Type_TTLBIS(
            state,
            tracer,
            s_149_1,
            s_149_5,
        );
        // S s_149_7: call HCR2_write(s_149_6)
        let s_149_7: () = HCR2_write(state, tracer, s_149_6);
        // N s_149_8: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_150_0: const #() : ()
        let s_150_0: () = ();
        // S s_150_1: call HCR2_read(s_150_0)
        let s_150_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_150_0);
        // D s_150_2: write-var ga#35334 <= s_150_1
        fn_state.ga_35334 = s_150_1;
        // D s_150_3: read-var ga#35334.0:struct
        let s_150_3: u32 = fn_state.ga_35334._0;
        // C s_150_4: const #1s : i
        let s_150_4: i128 = 1;
        // C s_150_5: const #21s : i
        let s_150_5: i128 = 21;
        // D s_150_6: cast zx s_150_3 -> bv
        let s_150_6: Bits = Bits::new(s_150_3 as u128, 32u16);
        // C s_150_7: const #0u : u8
        let s_150_7: bool = false;
        // C s_150_8: cast zx s_150_7 -> bv
        let s_150_8: Bits = Bits::new(s_150_7 as u128, 1u16);
        // C s_150_9: const #1u : u64
        let s_150_9: u64 = 1;
        // C s_150_10: cast zx s_150_9 -> bv
        let s_150_10: Bits = Bits::new(s_150_9 as u128, 64u16);
        // C s_150_11: lsl s_150_10 s_150_4
        let s_150_11: Bits = s_150_10 << s_150_4;
        // C s_150_12: sub s_150_11 s_150_10
        let s_150_12: Bits = ((s_150_11) - (s_150_10));
        // C s_150_13: and s_150_8 s_150_12
        let s_150_13: Bits = ((s_150_8) & (s_150_12));
        // C s_150_14: lsl s_150_13 s_150_5
        let s_150_14: Bits = s_150_13 << s_150_5;
        // C s_150_15: lsl s_150_12 s_150_5
        let s_150_15: Bits = s_150_12 << s_150_5;
        // C s_150_16: cmpl s_150_15
        let s_150_16: Bits = !s_150_15;
        // D s_150_17: and s_150_6 s_150_16
        let s_150_17: Bits = ((s_150_6) & (s_150_16));
        // D s_150_18: or s_150_17 s_150_14
        let s_150_18: Bits = ((s_150_17) | (s_150_14));
        // D s_150_19: cast reint s_150_18 -> u32
        let s_150_19: u32 = (s_150_18.value() as u32);
        // D s_150_20: call Mk_HCR2_Type(s_150_19)
        let s_150_20: ProductType700c18a878c5601b = Mk_HCR2_Type(
            state,
            tracer,
            s_150_19,
        );
        // D s_150_21: call HCR2_write(s_150_20)
        let s_150_21: () = HCR2_write(state, tracer, s_150_20);
        // D s_150_22: read-var cold:u8
        let s_150_22: bool = fn_state.cold;
        // D s_150_23: not s_150_22
        let s_150_23: bool = !s_150_22;
        // N s_150_24: branch s_150_23 b576 b151
        if s_150_23 {
            return block_576(state, tracer, fn_state);
        } else {
            return block_151(state, tracer, fn_state);
        };
    }
    fn block_151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_151_0: const #0u : u8
        let s_151_0: bool = false;
        // D s_151_1: write-var gs#44108 <= s_151_0
        fn_state.gs_44108 = s_151_0;
        // N s_151_2: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_152_0: read-var gs#44108:u8
        let s_152_0: bool = fn_state.gs_44108;
        // N s_152_1: branch s_152_0 b575 b153
        if s_152_0 {
            return block_575(state, tracer, fn_state);
        } else {
            return block_153(state, tracer, fn_state);
        };
    }
    fn block_153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_153_0: const #() : ()
        let s_153_0: () = ();
        // S s_153_1: call HCR2_read(s_153_0)
        let s_153_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_153_0);
        // C s_153_2: const #1s : i64
        let s_153_2: i64 = 1;
        // C s_153_3: cast zx s_153_2 -> i
        let s_153_3: i128 = (i128::try_from(s_153_2).unwrap());
        // S s_153_4: call __UNKNOWN_bits(s_153_3)
        let s_153_4: Bits = u__UNKNOWN_bits(state, tracer, s_153_3);
        // S s_153_5: cast reint s_153_4 -> u8
        let s_153_5: bool = ((s_153_4.value()) != 0);
        // S s_153_6: call _update_HCR2_Type_TOCU(s_153_1, s_153_5)
        let s_153_6: ProductType700c18a878c5601b = u_update_HCR2_Type_TOCU(
            state,
            tracer,
            s_153_1,
            s_153_5,
        );
        // S s_153_7: call HCR2_write(s_153_6)
        let s_153_7: () = HCR2_write(state, tracer, s_153_6);
        // N s_153_8: jump b154
        return block_154(state, tracer, fn_state);
    }
    fn block_154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_154_0: const #() : ()
        let s_154_0: () = ();
        // S s_154_1: call HCR2_read(s_154_0)
        let s_154_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_154_0);
        // D s_154_2: write-var ga#35346 <= s_154_1
        fn_state.ga_35346 = s_154_1;
        // D s_154_3: read-var ga#35346.0:struct
        let s_154_3: u32 = fn_state.ga_35346._0;
        // C s_154_4: const #1s : i
        let s_154_4: i128 = 1;
        // C s_154_5: const #19s : i
        let s_154_5: i128 = 19;
        // D s_154_6: cast zx s_154_3 -> bv
        let s_154_6: Bits = Bits::new(s_154_3 as u128, 32u16);
        // C s_154_7: const #0u : u8
        let s_154_7: bool = false;
        // C s_154_8: cast zx s_154_7 -> bv
        let s_154_8: Bits = Bits::new(s_154_7 as u128, 1u16);
        // C s_154_9: const #1u : u64
        let s_154_9: u64 = 1;
        // C s_154_10: cast zx s_154_9 -> bv
        let s_154_10: Bits = Bits::new(s_154_9 as u128, 64u16);
        // C s_154_11: lsl s_154_10 s_154_4
        let s_154_11: Bits = s_154_10 << s_154_4;
        // C s_154_12: sub s_154_11 s_154_10
        let s_154_12: Bits = ((s_154_11) - (s_154_10));
        // C s_154_13: and s_154_8 s_154_12
        let s_154_13: Bits = ((s_154_8) & (s_154_12));
        // C s_154_14: lsl s_154_13 s_154_5
        let s_154_14: Bits = s_154_13 << s_154_5;
        // C s_154_15: lsl s_154_12 s_154_5
        let s_154_15: Bits = s_154_12 << s_154_5;
        // C s_154_16: cmpl s_154_15
        let s_154_16: Bits = !s_154_15;
        // D s_154_17: and s_154_6 s_154_16
        let s_154_17: Bits = ((s_154_6) & (s_154_16));
        // D s_154_18: or s_154_17 s_154_14
        let s_154_18: Bits = ((s_154_17) | (s_154_14));
        // D s_154_19: cast reint s_154_18 -> u32
        let s_154_19: u32 = (s_154_18.value() as u32);
        // D s_154_20: call Mk_HCR2_Type(s_154_19)
        let s_154_20: ProductType700c18a878c5601b = Mk_HCR2_Type(
            state,
            tracer,
            s_154_19,
        );
        // D s_154_21: call HCR2_write(s_154_20)
        let s_154_21: () = HCR2_write(state, tracer, s_154_20);
        // D s_154_22: read-var cold:u8
        let s_154_22: bool = fn_state.cold;
        // D s_154_23: not s_154_22
        let s_154_23: bool = !s_154_22;
        // N s_154_24: branch s_154_23 b574 b155
        if s_154_23 {
            return block_574(state, tracer, fn_state);
        } else {
            return block_155(state, tracer, fn_state);
        };
    }
    fn block_155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_155_0: const #0u : u8
        let s_155_0: bool = false;
        // D s_155_1: write-var gs#44112 <= s_155_0
        fn_state.gs_44112 = s_155_0;
        // N s_155_2: jump b156
        return block_156(state, tracer, fn_state);
    }
    fn block_156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_156_0: read-var gs#44112:u8
        let s_156_0: bool = fn_state.gs_44112;
        // N s_156_1: branch s_156_0 b573 b157
        if s_156_0 {
            return block_573(state, tracer, fn_state);
        } else {
            return block_157(state, tracer, fn_state);
        };
    }
    fn block_157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_157_0: const #() : ()
        let s_157_0: () = ();
        // S s_157_1: call HCR2_read(s_157_0)
        let s_157_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_157_0);
        // C s_157_2: const #1s : i64
        let s_157_2: i64 = 1;
        // C s_157_3: cast zx s_157_2 -> i
        let s_157_3: i128 = (i128::try_from(s_157_2).unwrap());
        // S s_157_4: call __UNKNOWN_bits(s_157_3)
        let s_157_4: Bits = u__UNKNOWN_bits(state, tracer, s_157_3);
        // S s_157_5: cast reint s_157_4 -> u8
        let s_157_5: bool = ((s_157_4.value()) != 0);
        // S s_157_6: call _update_HCR2_Type_TICAB(s_157_1, s_157_5)
        let s_157_6: ProductType700c18a878c5601b = u_update_HCR2_Type_TICAB(
            state,
            tracer,
            s_157_1,
            s_157_5,
        );
        // S s_157_7: call HCR2_write(s_157_6)
        let s_157_7: () = HCR2_write(state, tracer, s_157_6);
        // N s_157_8: jump b158
        return block_158(state, tracer, fn_state);
    }
    fn block_158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_158_0: read-var cold:u8
        let s_158_0: bool = fn_state.cold;
        // D s_158_1: not s_158_0
        let s_158_1: bool = !s_158_0;
        // N s_158_2: branch s_158_1 b572 b159
        if s_158_1 {
            return block_572(state, tracer, fn_state);
        } else {
            return block_159(state, tracer, fn_state);
        };
    }
    fn block_159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_159_0: const #0u : u8
        let s_159_0: bool = false;
        // D s_159_1: write-var gs#44113 <= s_159_0
        fn_state.gs_44113 = s_159_0;
        // N s_159_2: jump b160
        return block_160(state, tracer, fn_state);
    }
    fn block_160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_160_0: read-var gs#44113:u8
        let s_160_0: bool = fn_state.gs_44113;
        // N s_160_1: branch s_160_0 b571 b161
        if s_160_0 {
            return block_571(state, tracer, fn_state);
        } else {
            return block_161(state, tracer, fn_state);
        };
    }
    fn block_161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_161_0: const #() : ()
        let s_161_0: () = ();
        // S s_161_1: call HCR2_read(s_161_0)
        let s_161_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_161_0);
        // C s_161_2: const #1s : i64
        let s_161_2: i64 = 1;
        // C s_161_3: cast zx s_161_2 -> i
        let s_161_3: i128 = (i128::try_from(s_161_2).unwrap());
        // S s_161_4: call __UNKNOWN_bits(s_161_3)
        let s_161_4: Bits = u__UNKNOWN_bits(state, tracer, s_161_3);
        // S s_161_5: cast reint s_161_4 -> u8
        let s_161_5: bool = ((s_161_4.value()) != 0);
        // S s_161_6: call _update_HCR2_Type_TID4(s_161_1, s_161_5)
        let s_161_6: ProductType700c18a878c5601b = u_update_HCR2_Type_TID4(
            state,
            tracer,
            s_161_1,
            s_161_5,
        );
        // S s_161_7: call HCR2_write(s_161_6)
        let s_161_7: () = HCR2_write(state, tracer, s_161_6);
        // N s_161_8: jump b162
        return block_162(state, tracer, fn_state);
    }
    fn block_162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_162_0: const #() : ()
        let s_162_0: () = ();
        // S s_162_1: call HCR2_read(s_162_0)
        let s_162_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_162_0);
        // D s_162_2: write-var ga#35366 <= s_162_1
        fn_state.ga_35366 = s_162_1;
        // D s_162_3: read-var ga#35366.0:struct
        let s_162_3: u32 = fn_state.ga_35366._0;
        // C s_162_4: const #10s : i
        let s_162_4: i128 = 10;
        // C s_162_5: const #7s : i
        let s_162_5: i128 = 7;
        // D s_162_6: cast zx s_162_3 -> bv
        let s_162_6: Bits = Bits::new(s_162_3 as u128, 32u16);
        // C s_162_7: const #0u : u10
        let s_162_7: u16 = 0;
        // C s_162_8: cast zx s_162_7 -> bv
        let s_162_8: Bits = Bits::new(s_162_7 as u128, 10u16);
        // C s_162_9: const #1u : u64
        let s_162_9: u64 = 1;
        // C s_162_10: cast zx s_162_9 -> bv
        let s_162_10: Bits = Bits::new(s_162_9 as u128, 64u16);
        // C s_162_11: lsl s_162_10 s_162_4
        let s_162_11: Bits = s_162_10 << s_162_4;
        // C s_162_12: sub s_162_11 s_162_10
        let s_162_12: Bits = ((s_162_11) - (s_162_10));
        // C s_162_13: and s_162_8 s_162_12
        let s_162_13: Bits = ((s_162_8) & (s_162_12));
        // C s_162_14: lsl s_162_13 s_162_5
        let s_162_14: Bits = s_162_13 << s_162_5;
        // C s_162_15: lsl s_162_12 s_162_5
        let s_162_15: Bits = s_162_12 << s_162_5;
        // C s_162_16: cmpl s_162_15
        let s_162_16: Bits = !s_162_15;
        // D s_162_17: and s_162_6 s_162_16
        let s_162_17: Bits = ((s_162_6) & (s_162_16));
        // D s_162_18: or s_162_17 s_162_14
        let s_162_18: Bits = ((s_162_17) | (s_162_14));
        // D s_162_19: cast reint s_162_18 -> u32
        let s_162_19: u32 = (s_162_18.value() as u32);
        // D s_162_20: call Mk_HCR2_Type(s_162_19)
        let s_162_20: ProductType700c18a878c5601b = Mk_HCR2_Type(
            state,
            tracer,
            s_162_19,
        );
        // D s_162_21: call HCR2_write(s_162_20)
        let s_162_21: () = HCR2_write(state, tracer, s_162_20);
        // D s_162_22: read-var cold:u8
        let s_162_22: bool = fn_state.cold;
        // D s_162_23: not s_162_22
        let s_162_23: bool = !s_162_22;
        // N s_162_24: branch s_162_23 b570 b163
        if s_162_23 {
            return block_570(state, tracer, fn_state);
        } else {
            return block_163(state, tracer, fn_state);
        };
    }
    fn block_163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_163_0: const #0u : u8
        let s_163_0: bool = false;
        // D s_163_1: write-var gs#44117 <= s_163_0
        fn_state.gs_44117 = s_163_0;
        // N s_163_2: jump b164
        return block_164(state, tracer, fn_state);
    }
    fn block_164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_164_0: read-var gs#44117:u8
        let s_164_0: bool = fn_state.gs_44117;
        // N s_164_1: branch s_164_0 b569 b165
        if s_164_0 {
            return block_569(state, tracer, fn_state);
        } else {
            return block_165(state, tracer, fn_state);
        };
    }
    fn block_165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_165_0: const #() : ()
        let s_165_0: () = ();
        // S s_165_1: call HCR2_read(s_165_0)
        let s_165_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_165_0);
        // C s_165_2: const #1s : i64
        let s_165_2: i64 = 1;
        // C s_165_3: cast zx s_165_2 -> i
        let s_165_3: i128 = (i128::try_from(s_165_2).unwrap());
        // S s_165_4: call __UNKNOWN_bits(s_165_3)
        let s_165_4: Bits = u__UNKNOWN_bits(state, tracer, s_165_3);
        // S s_165_5: cast reint s_165_4 -> u8
        let s_165_5: bool = ((s_165_4.value()) != 0);
        // S s_165_6: call _update_HCR2_Type_TEA(s_165_1, s_165_5)
        let s_165_6: ProductType700c18a878c5601b = u_update_HCR2_Type_TEA(
            state,
            tracer,
            s_165_1,
            s_165_5,
        );
        // S s_165_7: call HCR2_write(s_165_6)
        let s_165_7: () = HCR2_write(state, tracer, s_165_6);
        // N s_165_8: jump b166
        return block_166(state, tracer, fn_state);
    }
    fn block_166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_166_0: read-var cold:u8
        let s_166_0: bool = fn_state.cold;
        // D s_166_1: not s_166_0
        let s_166_1: bool = !s_166_0;
        // N s_166_2: branch s_166_1 b568 b167
        if s_166_1 {
            return block_568(state, tracer, fn_state);
        } else {
            return block_167(state, tracer, fn_state);
        };
    }
    fn block_167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_167_0: const #0u : u8
        let s_167_0: bool = false;
        // D s_167_1: write-var gs#44118 <= s_167_0
        fn_state.gs_44118 = s_167_0;
        // N s_167_2: jump b168
        return block_168(state, tracer, fn_state);
    }
    fn block_168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_168_0: read-var gs#44118:u8
        let s_168_0: bool = fn_state.gs_44118;
        // N s_168_1: branch s_168_0 b567 b169
        if s_168_0 {
            return block_567(state, tracer, fn_state);
        } else {
            return block_169(state, tracer, fn_state);
        };
    }
    fn block_169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_169_0: const #() : ()
        let s_169_0: () = ();
        // S s_169_1: call HCR2_read(s_169_0)
        let s_169_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_169_0);
        // C s_169_2: const #1s : i64
        let s_169_2: i64 = 1;
        // C s_169_3: cast zx s_169_2 -> i
        let s_169_3: i128 = (i128::try_from(s_169_2).unwrap());
        // S s_169_4: call __UNKNOWN_bits(s_169_3)
        let s_169_4: Bits = u__UNKNOWN_bits(state, tracer, s_169_3);
        // S s_169_5: cast reint s_169_4 -> u8
        let s_169_5: bool = ((s_169_4.value()) != 0);
        // S s_169_6: call _update_HCR2_Type_TERR(s_169_1, s_169_5)
        let s_169_6: ProductType700c18a878c5601b = u_update_HCR2_Type_TERR(
            state,
            tracer,
            s_169_1,
            s_169_5,
        );
        // S s_169_7: call HCR2_write(s_169_6)
        let s_169_7: () = HCR2_write(state, tracer, s_169_6);
        // N s_169_8: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_170_0: const #() : ()
        let s_170_0: () = ();
        // S s_170_1: call HCR2_read(s_170_0)
        let s_170_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_170_0);
        // D s_170_2: write-var ga#35386 <= s_170_1
        fn_state.ga_35386 = s_170_1;
        // D s_170_3: read-var ga#35386.0:struct
        let s_170_3: u32 = fn_state.ga_35386._0;
        // C s_170_4: const #2s : i
        let s_170_4: i128 = 2;
        // C s_170_5: const #2s : i
        let s_170_5: i128 = 2;
        // D s_170_6: cast zx s_170_3 -> bv
        let s_170_6: Bits = Bits::new(s_170_3 as u128, 32u16);
        // C s_170_7: const #0u : u8
        let s_170_7: u8 = 0;
        // C s_170_8: cast zx s_170_7 -> bv
        let s_170_8: Bits = Bits::new(s_170_7 as u128, 2u16);
        // C s_170_9: const #1u : u64
        let s_170_9: u64 = 1;
        // C s_170_10: cast zx s_170_9 -> bv
        let s_170_10: Bits = Bits::new(s_170_9 as u128, 64u16);
        // C s_170_11: lsl s_170_10 s_170_4
        let s_170_11: Bits = s_170_10 << s_170_4;
        // C s_170_12: sub s_170_11 s_170_10
        let s_170_12: Bits = ((s_170_11) - (s_170_10));
        // C s_170_13: and s_170_8 s_170_12
        let s_170_13: Bits = ((s_170_8) & (s_170_12));
        // C s_170_14: lsl s_170_13 s_170_5
        let s_170_14: Bits = s_170_13 << s_170_5;
        // C s_170_15: lsl s_170_12 s_170_5
        let s_170_15: Bits = s_170_12 << s_170_5;
        // C s_170_16: cmpl s_170_15
        let s_170_16: Bits = !s_170_15;
        // D s_170_17: and s_170_6 s_170_16
        let s_170_17: Bits = ((s_170_6) & (s_170_16));
        // D s_170_18: or s_170_17 s_170_14
        let s_170_18: Bits = ((s_170_17) | (s_170_14));
        // D s_170_19: cast reint s_170_18 -> u32
        let s_170_19: u32 = (s_170_18.value() as u32);
        // D s_170_20: call Mk_HCR2_Type(s_170_19)
        let s_170_20: ProductType700c18a878c5601b = Mk_HCR2_Type(
            state,
            tracer,
            s_170_19,
        );
        // D s_170_21: call HCR2_write(s_170_20)
        let s_170_21: () = HCR2_write(state, tracer, s_170_20);
        // D s_170_22: read-var cold:u8
        let s_170_22: bool = fn_state.cold;
        // D s_170_23: not s_170_22
        let s_170_23: bool = !s_170_22;
        // N s_170_24: branch s_170_23 b566 b171
        if s_170_23 {
            return block_566(state, tracer, fn_state);
        } else {
            return block_171(state, tracer, fn_state);
        };
    }
    fn block_171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_171_0: const #0u : u8
        let s_171_0: bool = false;
        // D s_171_1: write-var gs#44122 <= s_171_0
        fn_state.gs_44122 = s_171_0;
        // N s_171_2: jump b172
        return block_172(state, tracer, fn_state);
    }
    fn block_172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_172_0: read-var gs#44122:u8
        let s_172_0: bool = fn_state.gs_44122;
        // N s_172_1: branch s_172_0 b565 b173
        if s_172_0 {
            return block_565(state, tracer, fn_state);
        } else {
            return block_173(state, tracer, fn_state);
        };
    }
    fn block_173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_173_0: const #() : ()
        let s_173_0: () = ();
        // S s_173_1: call HCR2_read(s_173_0)
        let s_173_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_173_0);
        // C s_173_2: const #1s : i64
        let s_173_2: i64 = 1;
        // C s_173_3: cast zx s_173_2 -> i
        let s_173_3: i128 = (i128::try_from(s_173_2).unwrap());
        // S s_173_4: call __UNKNOWN_bits(s_173_3)
        let s_173_4: Bits = u__UNKNOWN_bits(state, tracer, s_173_3);
        // S s_173_5: cast reint s_173_4 -> u8
        let s_173_5: bool = ((s_173_4.value()) != 0);
        // S s_173_6: call _update_HCR2_Type_ID(s_173_1, s_173_5)
        let s_173_6: ProductType700c18a878c5601b = u_update_HCR2_Type_ID(
            state,
            tracer,
            s_173_1,
            s_173_5,
        );
        // S s_173_7: call HCR2_write(s_173_6)
        let s_173_7: () = HCR2_write(state, tracer, s_173_6);
        // N s_173_8: jump b174
        return block_174(state, tracer, fn_state);
    }
    fn block_174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_174_0: read-var cold:u8
        let s_174_0: bool = fn_state.cold;
        // D s_174_1: not s_174_0
        let s_174_1: bool = !s_174_0;
        // N s_174_2: branch s_174_1 b564 b175
        if s_174_1 {
            return block_564(state, tracer, fn_state);
        } else {
            return block_175(state, tracer, fn_state);
        };
    }
    fn block_175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_175_0: const #0u : u8
        let s_175_0: bool = false;
        // D s_175_1: write-var gs#44123 <= s_175_0
        fn_state.gs_44123 = s_175_0;
        // N s_175_2: jump b176
        return block_176(state, tracer, fn_state);
    }
    fn block_176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_176_0: read-var gs#44123:u8
        let s_176_0: bool = fn_state.gs_44123;
        // N s_176_1: branch s_176_0 b563 b177
        if s_176_0 {
            return block_563(state, tracer, fn_state);
        } else {
            return block_177(state, tracer, fn_state);
        };
    }
    fn block_177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_177_0: const #() : ()
        let s_177_0: () = ();
        // S s_177_1: call HCR2_read(s_177_0)
        let s_177_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_177_0);
        // C s_177_2: const #1s : i64
        let s_177_2: i64 = 1;
        // C s_177_3: cast zx s_177_2 -> i
        let s_177_3: i128 = (i128::try_from(s_177_2).unwrap());
        // S s_177_4: call __UNKNOWN_bits(s_177_3)
        let s_177_4: Bits = u__UNKNOWN_bits(state, tracer, s_177_3);
        // S s_177_5: cast reint s_177_4 -> u8
        let s_177_5: bool = ((s_177_4.value()) != 0);
        // S s_177_6: call _update_HCR2_Type_CD(s_177_1, s_177_5)
        let s_177_6: ProductType700c18a878c5601b = u_update_HCR2_Type_CD(
            state,
            tracer,
            s_177_1,
            s_177_5,
        );
        // S s_177_7: call HCR2_write(s_177_6)
        let s_177_7: () = HCR2_write(state, tracer, s_177_6);
        // N s_177_8: jump b178
        return block_178(state, tracer, fn_state);
    }
    fn block_178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_178_0: const #() : ()
        let s_178_0: () = ();
        // S s_178_1: call ID_PFR2_read(s_178_0)
        let s_178_1: ProductType700c18a878c5601b = ID_PFR2_read(state, tracer, s_178_0);
        // D s_178_2: write-var ga#35406 <= s_178_1
        fn_state.ga_35406 = s_178_1;
        // D s_178_3: read-var ga#35406.0:struct
        let s_178_3: u32 = fn_state.ga_35406._0;
        // C s_178_4: const #20s : i
        let s_178_4: i128 = 20;
        // C s_178_5: const #12s : i
        let s_178_5: i128 = 12;
        // D s_178_6: cast zx s_178_3 -> bv
        let s_178_6: Bits = Bits::new(s_178_3 as u128, 32u16);
        // C s_178_7: const #0u : u20
        let s_178_7: u32 = 0;
        // C s_178_8: cast zx s_178_7 -> bv
        let s_178_8: Bits = Bits::new(s_178_7 as u128, 20u16);
        // C s_178_9: const #1u : u64
        let s_178_9: u64 = 1;
        // C s_178_10: cast zx s_178_9 -> bv
        let s_178_10: Bits = Bits::new(s_178_9 as u128, 64u16);
        // C s_178_11: lsl s_178_10 s_178_4
        let s_178_11: Bits = s_178_10 << s_178_4;
        // C s_178_12: sub s_178_11 s_178_10
        let s_178_12: Bits = ((s_178_11) - (s_178_10));
        // C s_178_13: and s_178_8 s_178_12
        let s_178_13: Bits = ((s_178_8) & (s_178_12));
        // C s_178_14: lsl s_178_13 s_178_5
        let s_178_14: Bits = s_178_13 << s_178_5;
        // C s_178_15: lsl s_178_12 s_178_5
        let s_178_15: Bits = s_178_12 << s_178_5;
        // C s_178_16: cmpl s_178_15
        let s_178_16: Bits = !s_178_15;
        // D s_178_17: and s_178_6 s_178_16
        let s_178_17: Bits = ((s_178_6) & (s_178_16));
        // D s_178_18: or s_178_17 s_178_14
        let s_178_18: Bits = ((s_178_17) | (s_178_14));
        // D s_178_19: cast reint s_178_18 -> u32
        let s_178_19: u32 = (s_178_18.value() as u32);
        // D s_178_20: call Mk_ID_PFR2_Type(s_178_19)
        let s_178_20: ProductType700c18a878c5601b = Mk_ID_PFR2_Type(
            state,
            tracer,
            s_178_19,
        );
        // D s_178_21: call ID_PFR2_write(s_178_20)
        let s_178_21: () = ID_PFR2_write(state, tracer, s_178_20);
        // C s_178_22: const #() : ()
        let s_178_22: () = ();
        // S s_178_23: call ICV_EOIR0_read(s_178_22)
        let s_178_23: ProductType700c18a878c5601b = ICV_EOIR0_read(
            state,
            tracer,
            s_178_22,
        );
        // D s_178_24: write-var ga#35410 <= s_178_23
        fn_state.ga_35410 = s_178_23;
        // D s_178_25: read-var ga#35410.0:struct
        let s_178_25: u32 = fn_state.ga_35410._0;
        // C s_178_26: const #8s : i
        let s_178_26: i128 = 8;
        // C s_178_27: const #24s : i
        let s_178_27: i128 = 24;
        // D s_178_28: cast zx s_178_25 -> bv
        let s_178_28: Bits = Bits::new(s_178_25 as u128, 32u16);
        // C s_178_29: const #0u : u8
        let s_178_29: u8 = 0;
        // C s_178_30: cast zx s_178_29 -> bv
        let s_178_30: Bits = Bits::new(s_178_29 as u128, 8u16);
        // C s_178_31: const #1u : u64
        let s_178_31: u64 = 1;
        // C s_178_32: cast zx s_178_31 -> bv
        let s_178_32: Bits = Bits::new(s_178_31 as u128, 64u16);
        // C s_178_33: lsl s_178_32 s_178_26
        let s_178_33: Bits = s_178_32 << s_178_26;
        // C s_178_34: sub s_178_33 s_178_32
        let s_178_34: Bits = ((s_178_33) - (s_178_32));
        // C s_178_35: and s_178_30 s_178_34
        let s_178_35: Bits = ((s_178_30) & (s_178_34));
        // C s_178_36: lsl s_178_35 s_178_27
        let s_178_36: Bits = s_178_35 << s_178_27;
        // C s_178_37: lsl s_178_34 s_178_27
        let s_178_37: Bits = s_178_34 << s_178_27;
        // C s_178_38: cmpl s_178_37
        let s_178_38: Bits = !s_178_37;
        // D s_178_39: and s_178_28 s_178_38
        let s_178_39: Bits = ((s_178_28) & (s_178_38));
        // D s_178_40: or s_178_39 s_178_36
        let s_178_40: Bits = ((s_178_39) | (s_178_36));
        // D s_178_41: cast reint s_178_40 -> u32
        let s_178_41: u32 = (s_178_40.value() as u32);
        // D s_178_42: call Mk_ICV_EOIR0_Type(s_178_41)
        let s_178_42: ProductType700c18a878c5601b = Mk_ICV_EOIR0_Type(
            state,
            tracer,
            s_178_41,
        );
        // D s_178_43: call ICV_EOIR0_write(s_178_42)
        let s_178_43: () = ICV_EOIR0_write(state, tracer, s_178_42);
        // C s_178_44: const #() : ()
        let s_178_44: () = ();
        // S s_178_45: call ICH_VTR_read(s_178_44)
        let s_178_45: ProductType700c18a878c5601b = ICH_VTR_read(
            state,
            tracer,
            s_178_44,
        );
        // D s_178_46: write-var ga#35414 <= s_178_45
        fn_state.ga_35414 = s_178_45;
        // D s_178_47: read-var ga#35414.0:struct
        let s_178_47: u32 = fn_state.ga_35414._0;
        // C s_178_48: const #14s : i
        let s_178_48: i128 = 14;
        // C s_178_49: const #5s : i
        let s_178_49: i128 = 5;
        // D s_178_50: cast zx s_178_47 -> bv
        let s_178_50: Bits = Bits::new(s_178_47 as u128, 32u16);
        // C s_178_51: const #0u : u14
        let s_178_51: u16 = 0;
        // C s_178_52: cast zx s_178_51 -> bv
        let s_178_52: Bits = Bits::new(s_178_51 as u128, 14u16);
        // C s_178_53: const #1u : u64
        let s_178_53: u64 = 1;
        // C s_178_54: cast zx s_178_53 -> bv
        let s_178_54: Bits = Bits::new(s_178_53 as u128, 64u16);
        // C s_178_55: lsl s_178_54 s_178_48
        let s_178_55: Bits = s_178_54 << s_178_48;
        // C s_178_56: sub s_178_55 s_178_54
        let s_178_56: Bits = ((s_178_55) - (s_178_54));
        // C s_178_57: and s_178_52 s_178_56
        let s_178_57: Bits = ((s_178_52) & (s_178_56));
        // C s_178_58: lsl s_178_57 s_178_49
        let s_178_58: Bits = s_178_57 << s_178_49;
        // C s_178_59: lsl s_178_56 s_178_49
        let s_178_59: Bits = s_178_56 << s_178_49;
        // C s_178_60: cmpl s_178_59
        let s_178_60: Bits = !s_178_59;
        // D s_178_61: and s_178_50 s_178_60
        let s_178_61: Bits = ((s_178_50) & (s_178_60));
        // D s_178_62: or s_178_61 s_178_58
        let s_178_62: Bits = ((s_178_61) | (s_178_58));
        // D s_178_63: cast reint s_178_62 -> u32
        let s_178_63: u32 = (s_178_62.value() as u32);
        // D s_178_64: call Mk_ICH_VTR_Type(s_178_63)
        let s_178_64: ProductType700c18a878c5601b = Mk_ICH_VTR_Type(
            state,
            tracer,
            s_178_63,
        );
        // D s_178_65: call ICH_VTR_write(s_178_64)
        let s_178_65: () = ICH_VTR_write(state, tracer, s_178_64);
        // C s_178_66: const #() : ()
        let s_178_66: () = ();
        // S s_178_67: call CSSELR_read(s_178_66)
        let s_178_67: ProductType700c18a878c5601b = CSSELR_read(state, tracer, s_178_66);
        // D s_178_68: write-var ga#35418 <= s_178_67
        fn_state.ga_35418 = s_178_67;
        // D s_178_69: read-var ga#35418.0:struct
        let s_178_69: u32 = fn_state.ga_35418._0;
        // C s_178_70: const #28s : i
        let s_178_70: i128 = 28;
        // C s_178_71: const #4s : i
        let s_178_71: i128 = 4;
        // D s_178_72: cast zx s_178_69 -> bv
        let s_178_72: Bits = Bits::new(s_178_69 as u128, 32u16);
        // C s_178_73: const #0u : u28
        let s_178_73: u32 = 0;
        // C s_178_74: cast zx s_178_73 -> bv
        let s_178_74: Bits = Bits::new(s_178_73 as u128, 28u16);
        // C s_178_75: const #1u : u64
        let s_178_75: u64 = 1;
        // C s_178_76: cast zx s_178_75 -> bv
        let s_178_76: Bits = Bits::new(s_178_75 as u128, 64u16);
        // C s_178_77: lsl s_178_76 s_178_70
        let s_178_77: Bits = s_178_76 << s_178_70;
        // C s_178_78: sub s_178_77 s_178_76
        let s_178_78: Bits = ((s_178_77) - (s_178_76));
        // C s_178_79: and s_178_74 s_178_78
        let s_178_79: Bits = ((s_178_74) & (s_178_78));
        // C s_178_80: lsl s_178_79 s_178_71
        let s_178_80: Bits = s_178_79 << s_178_71;
        // C s_178_81: lsl s_178_78 s_178_71
        let s_178_81: Bits = s_178_78 << s_178_71;
        // C s_178_82: cmpl s_178_81
        let s_178_82: Bits = !s_178_81;
        // D s_178_83: and s_178_72 s_178_82
        let s_178_83: Bits = ((s_178_72) & (s_178_82));
        // D s_178_84: or s_178_83 s_178_80
        let s_178_84: Bits = ((s_178_83) | (s_178_80));
        // D s_178_85: cast reint s_178_84 -> u32
        let s_178_85: u32 = (s_178_84.value() as u32);
        // D s_178_86: call Mk_CSSELR_Type(s_178_85)
        let s_178_86: ProductType700c18a878c5601b = Mk_CSSELR_Type(
            state,
            tracer,
            s_178_85,
        );
        // D s_178_87: call CSSELR_write(s_178_86)
        let s_178_87: () = CSSELR_write(state, tracer, s_178_86);
        // C s_178_88: const #0s : i
        let s_178_88: i128 = 0;
        // C s_178_89: const #101872u : u32
        let s_178_89: u32 = 101872;
        // D s_178_90: read-reg s_178_89:u32
        let s_178_90: u32 = {
            let value = state.read_register::<u32>(s_178_89 as isize);
            tracer.read_register(s_178_89 as isize, value);
            value
        };
        // D s_178_91: cast zx s_178_90 -> bv
        let s_178_91: Bits = Bits::new(s_178_90 as u128, 32u16);
        // C s_178_92: const #0u : u32
        let s_178_92: u32 = 0;
        // C s_178_93: cast zx s_178_92 -> bv
        let s_178_93: Bits = Bits::new(s_178_92 as u128, 32u16);
        // C s_178_94: const #31s : i
        let s_178_94: i128 = 31;
        // C s_178_95: const #1u : u64
        let s_178_95: u64 = 1;
        // C s_178_96: cast zx s_178_95 -> bv
        let s_178_96: Bits = Bits::new(s_178_95 as u128, 64u16);
        // C s_178_97: lsl s_178_96 s_178_94
        let s_178_97: Bits = s_178_96 << s_178_94;
        // C s_178_98: sub s_178_97 s_178_96
        let s_178_98: Bits = ((s_178_97) - (s_178_96));
        // C s_178_99: and s_178_93 s_178_98
        let s_178_99: Bits = ((s_178_93) & (s_178_98));
        // C s_178_100: lsl s_178_99 s_178_88
        let s_178_100: Bits = s_178_99 << s_178_88;
        // C s_178_101: lsl s_178_98 s_178_88
        let s_178_101: Bits = s_178_98 << s_178_88;
        // C s_178_102: cmpl s_178_101
        let s_178_102: Bits = !s_178_101;
        // D s_178_103: and s_178_91 s_178_102
        let s_178_103: Bits = ((s_178_91) & (s_178_102));
        // D s_178_104: or s_178_103 s_178_100
        let s_178_104: Bits = ((s_178_103) | (s_178_100));
        // D s_178_105: cast reint s_178_104 -> u32
        let s_178_105: u32 = (s_178_104.value() as u32);
        // C s_178_106: const #101872u : u32
        let s_178_106: u32 = 101872;
        // N s_178_107: write-reg s_178_106 <= s_178_105
        let s_178_107: () = {
            state.write_register::<u32>(s_178_106 as isize, s_178_105);
            tracer.write_register(s_178_106 as isize, s_178_105);
        };
        // C s_178_108: const #() : ()
        let s_178_108: () = ();
        // S s_178_109: call PMCR_read(s_178_108)
        let s_178_109: ProductType700c18a878c5601b = PMCR_read(state, tracer, s_178_108);
        // D s_178_110: write-var ga#35422 <= s_178_109
        fn_state.ga_35422 = s_178_109;
        // D s_178_111: read-var ga#35422.0:struct
        let s_178_111: u32 = fn_state.ga_35422._0;
        // C s_178_112: const #1s : i
        let s_178_112: i128 = 1;
        // C s_178_113: const #10s : i
        let s_178_113: i128 = 10;
        // D s_178_114: cast zx s_178_111 -> bv
        let s_178_114: Bits = Bits::new(s_178_111 as u128, 32u16);
        // C s_178_115: const #0u : u8
        let s_178_115: bool = false;
        // C s_178_116: cast zx s_178_115 -> bv
        let s_178_116: Bits = Bits::new(s_178_115 as u128, 1u16);
        // C s_178_117: const #1u : u64
        let s_178_117: u64 = 1;
        // C s_178_118: cast zx s_178_117 -> bv
        let s_178_118: Bits = Bits::new(s_178_117 as u128, 64u16);
        // C s_178_119: lsl s_178_118 s_178_112
        let s_178_119: Bits = s_178_118 << s_178_112;
        // C s_178_120: sub s_178_119 s_178_118
        let s_178_120: Bits = ((s_178_119) - (s_178_118));
        // C s_178_121: and s_178_116 s_178_120
        let s_178_121: Bits = ((s_178_116) & (s_178_120));
        // C s_178_122: lsl s_178_121 s_178_113
        let s_178_122: Bits = s_178_121 << s_178_113;
        // C s_178_123: lsl s_178_120 s_178_113
        let s_178_123: Bits = s_178_120 << s_178_113;
        // C s_178_124: cmpl s_178_123
        let s_178_124: Bits = !s_178_123;
        // D s_178_125: and s_178_114 s_178_124
        let s_178_125: Bits = ((s_178_114) & (s_178_124));
        // D s_178_126: or s_178_125 s_178_122
        let s_178_126: Bits = ((s_178_125) | (s_178_122));
        // D s_178_127: cast reint s_178_126 -> u32
        let s_178_127: u32 = (s_178_126.value() as u32);
        // D s_178_128: call Mk_PMCR_Type(s_178_127)
        let s_178_128: ProductType700c18a878c5601b = Mk_PMCR_Type(
            state,
            tracer,
            s_178_127,
        );
        // D s_178_129: call PMCR_write(s_178_128)
        let s_178_129: () = PMCR_write(state, tracer, s_178_128);
        // C s_178_130: const #() : ()
        let s_178_130: () = ();
        // S s_178_131: call PMCR_read(s_178_130)
        let s_178_131: ProductType700c18a878c5601b = PMCR_read(state, tracer, s_178_130);
        // D s_178_132: write-var ga#35426 <= s_178_131
        fn_state.ga_35426 = s_178_131;
        // D s_178_133: read-var ga#35426.0:struct
        let s_178_133: u32 = fn_state.ga_35426._0;
        // C s_178_134: const #1s : i
        let s_178_134: i128 = 1;
        // C s_178_135: const #8s : i
        let s_178_135: i128 = 8;
        // D s_178_136: cast zx s_178_133 -> bv
        let s_178_136: Bits = Bits::new(s_178_133 as u128, 32u16);
        // C s_178_137: const #0u : u8
        let s_178_137: bool = false;
        // C s_178_138: cast zx s_178_137 -> bv
        let s_178_138: Bits = Bits::new(s_178_137 as u128, 1u16);
        // C s_178_139: const #1u : u64
        let s_178_139: u64 = 1;
        // C s_178_140: cast zx s_178_139 -> bv
        let s_178_140: Bits = Bits::new(s_178_139 as u128, 64u16);
        // C s_178_141: lsl s_178_140 s_178_134
        let s_178_141: Bits = s_178_140 << s_178_134;
        // C s_178_142: sub s_178_141 s_178_140
        let s_178_142: Bits = ((s_178_141) - (s_178_140));
        // C s_178_143: and s_178_138 s_178_142
        let s_178_143: Bits = ((s_178_138) & (s_178_142));
        // C s_178_144: lsl s_178_143 s_178_135
        let s_178_144: Bits = s_178_143 << s_178_135;
        // C s_178_145: lsl s_178_142 s_178_135
        let s_178_145: Bits = s_178_142 << s_178_135;
        // C s_178_146: cmpl s_178_145
        let s_178_146: Bits = !s_178_145;
        // D s_178_147: and s_178_136 s_178_146
        let s_178_147: Bits = ((s_178_136) & (s_178_146));
        // D s_178_148: or s_178_147 s_178_144
        let s_178_148: Bits = ((s_178_147) | (s_178_144));
        // D s_178_149: cast reint s_178_148 -> u32
        let s_178_149: u32 = (s_178_148.value() as u32);
        // D s_178_150: call Mk_PMCR_Type(s_178_149)
        let s_178_150: ProductType700c18a878c5601b = Mk_PMCR_Type(
            state,
            tracer,
            s_178_149,
        );
        // D s_178_151: call PMCR_write(s_178_150)
        let s_178_151: () = PMCR_write(state, tracer, s_178_150);
        // C s_178_152: const #() : ()
        let s_178_152: () = ();
        // S s_178_153: call PMCR_read(s_178_152)
        let s_178_153: ProductType700c18a878c5601b = PMCR_read(state, tracer, s_178_152);
        // C s_178_154: const #0u : u8
        let s_178_154: bool = false;
        // S s_178_155: call _update_PMCR_Type_LP(s_178_153, s_178_154)
        let s_178_155: ProductType700c18a878c5601b = u_update_PMCR_Type_LP(
            state,
            tracer,
            s_178_153,
            s_178_154,
        );
        // S s_178_156: call PMCR_write(s_178_155)
        let s_178_156: () = PMCR_write(state, tracer, s_178_155);
        // C s_178_157: const #() : ()
        let s_178_157: () = ();
        // S s_178_158: call PMCR_read(s_178_157)
        let s_178_158: ProductType700c18a878c5601b = PMCR_read(state, tracer, s_178_157);
        // C s_178_159: const #0u : u8
        let s_178_159: bool = false;
        // S s_178_160: call _update_PMCR_Type_DP(s_178_158, s_178_159)
        let s_178_160: ProductType700c18a878c5601b = u_update_PMCR_Type_DP(
            state,
            tracer,
            s_178_158,
            s_178_159,
        );
        // S s_178_161: call PMCR_write(s_178_160)
        let s_178_161: () = PMCR_write(state, tracer, s_178_160);
        // C s_178_162: const #() : ()
        let s_178_162: () = ();
        // S s_178_163: call PMCR_read(s_178_162)
        let s_178_163: ProductType700c18a878c5601b = PMCR_read(state, tracer, s_178_162);
        // C s_178_164: const #0u : u8
        let s_178_164: bool = false;
        // S s_178_165: call _update_PMCR_Type_X(s_178_163, s_178_164)
        let s_178_165: ProductType700c18a878c5601b = u_update_PMCR_Type_X(
            state,
            tracer,
            s_178_163,
            s_178_164,
        );
        // S s_178_166: call PMCR_write(s_178_165)
        let s_178_166: () = PMCR_write(state, tracer, s_178_165);
        // C s_178_167: const #() : ()
        let s_178_167: () = ();
        // S s_178_168: call PMCR_read(s_178_167)
        let s_178_168: ProductType700c18a878c5601b = PMCR_read(state, tracer, s_178_167);
        // C s_178_169: const #0u : u8
        let s_178_169: bool = false;
        // S s_178_170: call _update_PMCR_Type_D(s_178_168, s_178_169)
        let s_178_170: ProductType700c18a878c5601b = u_update_PMCR_Type_D(
            state,
            tracer,
            s_178_168,
            s_178_169,
        );
        // S s_178_171: call PMCR_write(s_178_170)
        let s_178_171: () = PMCR_write(state, tracer, s_178_170);
        // C s_178_172: const #() : ()
        let s_178_172: () = ();
        // S s_178_173: call PMCR_read(s_178_172)
        let s_178_173: ProductType700c18a878c5601b = PMCR_read(state, tracer, s_178_172);
        // C s_178_174: const #0u : u8
        let s_178_174: bool = false;
        // S s_178_175: call _update_PMCR_Type_E(s_178_173, s_178_174)
        let s_178_175: ProductType700c18a878c5601b = u_update_PMCR_Type_E(
            state,
            tracer,
            s_178_173,
            s_178_174,
        );
        // S s_178_176: call PMCR_write(s_178_175)
        let s_178_176: () = PMCR_write(state, tracer, s_178_175);
        // C s_178_177: const #() : ()
        let s_178_177: () = ();
        // S s_178_178: call ICH_VMCR_read(s_178_177)
        let s_178_178: ProductType700c18a878c5601b = ICH_VMCR_read(
            state,
            tracer,
            s_178_177,
        );
        // D s_178_179: write-var ga#35440 <= s_178_178
        fn_state.ga_35440 = s_178_178;
        // D s_178_180: read-var ga#35440.0:struct
        let s_178_180: u32 = fn_state.ga_35440._0;
        // C s_178_181: const #8s : i
        let s_178_181: i128 = 8;
        // C s_178_182: const #10s : i
        let s_178_182: i128 = 10;
        // D s_178_183: cast zx s_178_180 -> bv
        let s_178_183: Bits = Bits::new(s_178_180 as u128, 32u16);
        // C s_178_184: const #0u : u8
        let s_178_184: u8 = 0;
        // C s_178_185: cast zx s_178_184 -> bv
        let s_178_185: Bits = Bits::new(s_178_184 as u128, 8u16);
        // C s_178_186: const #1u : u64
        let s_178_186: u64 = 1;
        // C s_178_187: cast zx s_178_186 -> bv
        let s_178_187: Bits = Bits::new(s_178_186 as u128, 64u16);
        // C s_178_188: lsl s_178_187 s_178_181
        let s_178_188: Bits = s_178_187 << s_178_181;
        // C s_178_189: sub s_178_188 s_178_187
        let s_178_189: Bits = ((s_178_188) - (s_178_187));
        // C s_178_190: and s_178_185 s_178_189
        let s_178_190: Bits = ((s_178_185) & (s_178_189));
        // C s_178_191: lsl s_178_190 s_178_182
        let s_178_191: Bits = s_178_190 << s_178_182;
        // C s_178_192: lsl s_178_189 s_178_182
        let s_178_192: Bits = s_178_189 << s_178_182;
        // C s_178_193: cmpl s_178_192
        let s_178_193: Bits = !s_178_192;
        // D s_178_194: and s_178_183 s_178_193
        let s_178_194: Bits = ((s_178_183) & (s_178_193));
        // D s_178_195: or s_178_194 s_178_191
        let s_178_195: Bits = ((s_178_194) | (s_178_191));
        // D s_178_196: cast reint s_178_195 -> u32
        let s_178_196: u32 = (s_178_195.value() as u32);
        // D s_178_197: call Mk_ICH_VMCR_Type(s_178_196)
        let s_178_197: ProductType700c18a878c5601b = Mk_ICH_VMCR_Type(
            state,
            tracer,
            s_178_196,
        );
        // D s_178_198: call ICH_VMCR_write(s_178_197)
        let s_178_198: () = ICH_VMCR_write(state, tracer, s_178_197);
        // C s_178_199: const #() : ()
        let s_178_199: () = ();
        // S s_178_200: call ICH_VMCR_read(s_178_199)
        let s_178_200: ProductType700c18a878c5601b = ICH_VMCR_read(
            state,
            tracer,
            s_178_199,
        );
        // D s_178_201: write-var ga#35444 <= s_178_200
        fn_state.ga_35444 = s_178_200;
        // D s_178_202: read-var ga#35444.0:struct
        let s_178_202: u32 = fn_state.ga_35444._0;
        // C s_178_203: const #4s : i
        let s_178_203: i128 = 4;
        // C s_178_204: const #5s : i
        let s_178_204: i128 = 5;
        // D s_178_205: cast zx s_178_202 -> bv
        let s_178_205: Bits = Bits::new(s_178_202 as u128, 32u16);
        // C s_178_206: const #0u : u8
        let s_178_206: u8 = 0;
        // C s_178_207: cast zx s_178_206 -> bv
        let s_178_207: Bits = Bits::new(s_178_206 as u128, 4u16);
        // C s_178_208: const #1u : u64
        let s_178_208: u64 = 1;
        // C s_178_209: cast zx s_178_208 -> bv
        let s_178_209: Bits = Bits::new(s_178_208 as u128, 64u16);
        // C s_178_210: lsl s_178_209 s_178_203
        let s_178_210: Bits = s_178_209 << s_178_203;
        // C s_178_211: sub s_178_210 s_178_209
        let s_178_211: Bits = ((s_178_210) - (s_178_209));
        // C s_178_212: and s_178_207 s_178_211
        let s_178_212: Bits = ((s_178_207) & (s_178_211));
        // C s_178_213: lsl s_178_212 s_178_204
        let s_178_213: Bits = s_178_212 << s_178_204;
        // C s_178_214: lsl s_178_211 s_178_204
        let s_178_214: Bits = s_178_211 << s_178_204;
        // C s_178_215: cmpl s_178_214
        let s_178_215: Bits = !s_178_214;
        // D s_178_216: and s_178_205 s_178_215
        let s_178_216: Bits = ((s_178_205) & (s_178_215));
        // D s_178_217: or s_178_216 s_178_213
        let s_178_217: Bits = ((s_178_216) | (s_178_213));
        // D s_178_218: cast reint s_178_217 -> u32
        let s_178_218: u32 = (s_178_217.value() as u32);
        // D s_178_219: call Mk_ICH_VMCR_Type(s_178_218)
        let s_178_219: ProductType700c18a878c5601b = Mk_ICH_VMCR_Type(
            state,
            tracer,
            s_178_218,
        );
        // D s_178_220: call ICH_VMCR_write(s_178_219)
        let s_178_220: () = ICH_VMCR_write(state, tracer, s_178_219);
        // C s_178_221: const #15232u : u32
        let s_178_221: u32 = 15232;
        // D s_178_222: read-reg s_178_221:struct
        let s_178_222: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_178_221 as isize);
            tracer.read_register(s_178_221 as isize, value);
            value
        };
        // C s_178_223: const #15232u : u32
        let s_178_223: u32 = 15232;
        // N s_178_224: write-reg s_178_223 <= s_178_222
        let s_178_224: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_178_223 as isize, s_178_222);
            tracer.write_register(s_178_223 as isize, s_178_222);
        };
        // C s_178_225: const #() : ()
        let s_178_225: () = ();
        // S s_178_226: call ICC_BPR1_read(s_178_225)
        let s_178_226: ProductType700c18a878c5601b = ICC_BPR1_read(
            state,
            tracer,
            s_178_225,
        );
        // D s_178_227: write-var ga#35450 <= s_178_226
        fn_state.ga_35450 = s_178_226;
        // D s_178_228: read-var ga#35450.0:struct
        let s_178_228: u32 = fn_state.ga_35450._0;
        // C s_178_229: const #29s : i
        let s_178_229: i128 = 29;
        // C s_178_230: const #3s : i
        let s_178_230: i128 = 3;
        // D s_178_231: cast zx s_178_228 -> bv
        let s_178_231: Bits = Bits::new(s_178_228 as u128, 32u16);
        // C s_178_232: const #0u : u29
        let s_178_232: u32 = 0;
        // C s_178_233: cast zx s_178_232 -> bv
        let s_178_233: Bits = Bits::new(s_178_232 as u128, 29u16);
        // C s_178_234: const #1u : u64
        let s_178_234: u64 = 1;
        // C s_178_235: cast zx s_178_234 -> bv
        let s_178_235: Bits = Bits::new(s_178_234 as u128, 64u16);
        // C s_178_236: lsl s_178_235 s_178_229
        let s_178_236: Bits = s_178_235 << s_178_229;
        // C s_178_237: sub s_178_236 s_178_235
        let s_178_237: Bits = ((s_178_236) - (s_178_235));
        // C s_178_238: and s_178_233 s_178_237
        let s_178_238: Bits = ((s_178_233) & (s_178_237));
        // C s_178_239: lsl s_178_238 s_178_230
        let s_178_239: Bits = s_178_238 << s_178_230;
        // C s_178_240: lsl s_178_237 s_178_230
        let s_178_240: Bits = s_178_237 << s_178_230;
        // C s_178_241: cmpl s_178_240
        let s_178_241: Bits = !s_178_240;
        // D s_178_242: and s_178_231 s_178_241
        let s_178_242: Bits = ((s_178_231) & (s_178_241));
        // D s_178_243: or s_178_242 s_178_239
        let s_178_243: Bits = ((s_178_242) | (s_178_239));
        // D s_178_244: cast reint s_178_243 -> u32
        let s_178_244: u32 = (s_178_243.value() as u32);
        // D s_178_245: call Mk_ICC_BPR1_Type(s_178_244)
        let s_178_245: ProductType700c18a878c5601b = Mk_ICC_BPR1_Type(
            state,
            tracer,
            s_178_244,
        );
        // D s_178_246: call ICC_BPR1_write(s_178_245)
        let s_178_246: () = ICC_BPR1_write(state, tracer, s_178_245);
        // C s_178_247: const #() : ()
        let s_178_247: () = ();
        // S s_178_248: call ICV_RPR_read(s_178_247)
        let s_178_248: ProductType700c18a878c5601b = ICV_RPR_read(
            state,
            tracer,
            s_178_247,
        );
        // D s_178_249: write-var ga#35454 <= s_178_248
        fn_state.ga_35454 = s_178_248;
        // D s_178_250: read-var ga#35454.0:struct
        let s_178_250: u32 = fn_state.ga_35454._0;
        // C s_178_251: const #24s : i
        let s_178_251: i128 = 24;
        // C s_178_252: const #8s : i
        let s_178_252: i128 = 8;
        // D s_178_253: cast zx s_178_250 -> bv
        let s_178_253: Bits = Bits::new(s_178_250 as u128, 32u16);
        // C s_178_254: const #0u : u24
        let s_178_254: u32 = 0;
        // C s_178_255: cast zx s_178_254 -> bv
        let s_178_255: Bits = Bits::new(s_178_254 as u128, 24u16);
        // C s_178_256: const #1u : u64
        let s_178_256: u64 = 1;
        // C s_178_257: cast zx s_178_256 -> bv
        let s_178_257: Bits = Bits::new(s_178_256 as u128, 64u16);
        // C s_178_258: lsl s_178_257 s_178_251
        let s_178_258: Bits = s_178_257 << s_178_251;
        // C s_178_259: sub s_178_258 s_178_257
        let s_178_259: Bits = ((s_178_258) - (s_178_257));
        // C s_178_260: and s_178_255 s_178_259
        let s_178_260: Bits = ((s_178_255) & (s_178_259));
        // C s_178_261: lsl s_178_260 s_178_252
        let s_178_261: Bits = s_178_260 << s_178_252;
        // C s_178_262: lsl s_178_259 s_178_252
        let s_178_262: Bits = s_178_259 << s_178_252;
        // C s_178_263: cmpl s_178_262
        let s_178_263: Bits = !s_178_262;
        // D s_178_264: and s_178_253 s_178_263
        let s_178_264: Bits = ((s_178_253) & (s_178_263));
        // D s_178_265: or s_178_264 s_178_261
        let s_178_265: Bits = ((s_178_264) | (s_178_261));
        // D s_178_266: cast reint s_178_265 -> u32
        let s_178_266: u32 = (s_178_265.value() as u32);
        // D s_178_267: call Mk_ICV_RPR_Type(s_178_266)
        let s_178_267: ProductType700c18a878c5601b = Mk_ICV_RPR_Type(
            state,
            tracer,
            s_178_266,
        );
        // D s_178_268: call ICV_RPR_write(s_178_267)
        let s_178_268: () = ICV_RPR_write(state, tracer, s_178_267);
        // C s_178_269: const #() : ()
        let s_178_269: () = ();
        // S s_178_270: call VBAR_read__2(s_178_269)
        let s_178_270: u32 = VBAR_read__2(state, tracer, s_178_269);
        // C s_178_271: const #5s : i
        let s_178_271: i128 = 5;
        // C s_178_272: const #0s : i
        let s_178_272: i128 = 0;
        // S s_178_273: cast zx s_178_270 -> bv
        let s_178_273: Bits = Bits::new(s_178_270 as u128, 32u16);
        // C s_178_274: const #0u : u8
        let s_178_274: u8 = 0;
        // C s_178_275: cast zx s_178_274 -> bv
        let s_178_275: Bits = Bits::new(s_178_274 as u128, 5u16);
        // C s_178_276: const #1u : u64
        let s_178_276: u64 = 1;
        // C s_178_277: cast zx s_178_276 -> bv
        let s_178_277: Bits = Bits::new(s_178_276 as u128, 64u16);
        // C s_178_278: lsl s_178_277 s_178_271
        let s_178_278: Bits = s_178_277 << s_178_271;
        // C s_178_279: sub s_178_278 s_178_277
        let s_178_279: Bits = ((s_178_278) - (s_178_277));
        // C s_178_280: and s_178_275 s_178_279
        let s_178_280: Bits = ((s_178_275) & (s_178_279));
        // C s_178_281: lsl s_178_280 s_178_272
        let s_178_281: Bits = s_178_280 << s_178_272;
        // C s_178_282: lsl s_178_279 s_178_272
        let s_178_282: Bits = s_178_279 << s_178_272;
        // C s_178_283: cmpl s_178_282
        let s_178_283: Bits = !s_178_282;
        // S s_178_284: and s_178_273 s_178_283
        let s_178_284: Bits = ((s_178_273) & (s_178_283));
        // S s_178_285: or s_178_284 s_178_281
        let s_178_285: Bits = ((s_178_284) | (s_178_281));
        // S s_178_286: cast reint s_178_285 -> u32
        let s_178_286: u32 = (s_178_285.value() as u32);
        // S s_178_287: call VBAR_write(s_178_286)
        let s_178_287: () = VBAR_write(state, tracer, s_178_286);
        // C s_178_288: const #() : ()
        let s_178_288: () = ();
        // S s_178_289: call ID_ISAR0_read(s_178_288)
        let s_178_289: ProductType700c18a878c5601b = ID_ISAR0_read(
            state,
            tracer,
            s_178_288,
        );
        // D s_178_290: write-var ga#35460 <= s_178_289
        fn_state.ga_35460 = s_178_289;
        // D s_178_291: read-var ga#35460.0:struct
        let s_178_291: u32 = fn_state.ga_35460._0;
        // C s_178_292: const #4s : i
        let s_178_292: i128 = 4;
        // C s_178_293: const #28s : i
        let s_178_293: i128 = 28;
        // D s_178_294: cast zx s_178_291 -> bv
        let s_178_294: Bits = Bits::new(s_178_291 as u128, 32u16);
        // C s_178_295: const #0u : u8
        let s_178_295: u8 = 0;
        // C s_178_296: cast zx s_178_295 -> bv
        let s_178_296: Bits = Bits::new(s_178_295 as u128, 4u16);
        // C s_178_297: const #1u : u64
        let s_178_297: u64 = 1;
        // C s_178_298: cast zx s_178_297 -> bv
        let s_178_298: Bits = Bits::new(s_178_297 as u128, 64u16);
        // C s_178_299: lsl s_178_298 s_178_292
        let s_178_299: Bits = s_178_298 << s_178_292;
        // C s_178_300: sub s_178_299 s_178_298
        let s_178_300: Bits = ((s_178_299) - (s_178_298));
        // C s_178_301: and s_178_296 s_178_300
        let s_178_301: Bits = ((s_178_296) & (s_178_300));
        // C s_178_302: lsl s_178_301 s_178_293
        let s_178_302: Bits = s_178_301 << s_178_293;
        // C s_178_303: lsl s_178_300 s_178_293
        let s_178_303: Bits = s_178_300 << s_178_293;
        // C s_178_304: cmpl s_178_303
        let s_178_304: Bits = !s_178_303;
        // D s_178_305: and s_178_294 s_178_304
        let s_178_305: Bits = ((s_178_294) & (s_178_304));
        // D s_178_306: or s_178_305 s_178_302
        let s_178_306: Bits = ((s_178_305) | (s_178_302));
        // D s_178_307: cast reint s_178_306 -> u32
        let s_178_307: u32 = (s_178_306.value() as u32);
        // D s_178_308: call Mk_ID_ISAR0_Type(s_178_307)
        let s_178_308: ProductType700c18a878c5601b = Mk_ID_ISAR0_Type(
            state,
            tracer,
            s_178_307,
        );
        // D s_178_309: call ID_ISAR0_write(s_178_308)
        let s_178_309: () = ID_ISAR0_write(state, tracer, s_178_308);
        // C s_178_310: const #() : ()
        let s_178_310: () = ();
        // S s_178_311: call ICV_IAR1_read(s_178_310)
        let s_178_311: ProductType700c18a878c5601b = ICV_IAR1_read(
            state,
            tracer,
            s_178_310,
        );
        // D s_178_312: write-var ga#35464 <= s_178_311
        fn_state.ga_35464 = s_178_311;
        // D s_178_313: read-var ga#35464.0:struct
        let s_178_313: u32 = fn_state.ga_35464._0;
        // C s_178_314: const #8s : i
        let s_178_314: i128 = 8;
        // C s_178_315: const #24s : i
        let s_178_315: i128 = 24;
        // D s_178_316: cast zx s_178_313 -> bv
        let s_178_316: Bits = Bits::new(s_178_313 as u128, 32u16);
        // C s_178_317: const #0u : u8
        let s_178_317: u8 = 0;
        // C s_178_318: cast zx s_178_317 -> bv
        let s_178_318: Bits = Bits::new(s_178_317 as u128, 8u16);
        // C s_178_319: const #1u : u64
        let s_178_319: u64 = 1;
        // C s_178_320: cast zx s_178_319 -> bv
        let s_178_320: Bits = Bits::new(s_178_319 as u128, 64u16);
        // C s_178_321: lsl s_178_320 s_178_314
        let s_178_321: Bits = s_178_320 << s_178_314;
        // C s_178_322: sub s_178_321 s_178_320
        let s_178_322: Bits = ((s_178_321) - (s_178_320));
        // C s_178_323: and s_178_318 s_178_322
        let s_178_323: Bits = ((s_178_318) & (s_178_322));
        // C s_178_324: lsl s_178_323 s_178_315
        let s_178_324: Bits = s_178_323 << s_178_315;
        // C s_178_325: lsl s_178_322 s_178_315
        let s_178_325: Bits = s_178_322 << s_178_315;
        // C s_178_326: cmpl s_178_325
        let s_178_326: Bits = !s_178_325;
        // D s_178_327: and s_178_316 s_178_326
        let s_178_327: Bits = ((s_178_316) & (s_178_326));
        // D s_178_328: or s_178_327 s_178_324
        let s_178_328: Bits = ((s_178_327) | (s_178_324));
        // D s_178_329: cast reint s_178_328 -> u32
        let s_178_329: u32 = (s_178_328.value() as u32);
        // D s_178_330: call Mk_ICV_IAR1_Type(s_178_329)
        let s_178_330: ProductType700c18a878c5601b = Mk_ICV_IAR1_Type(
            state,
            tracer,
            s_178_329,
        );
        // D s_178_331: call ICV_IAR1_write(s_178_330)
        let s_178_331: () = ICV_IAR1_write(state, tracer, s_178_330);
        // C s_178_332: const #() : ()
        let s_178_332: () = ();
        // S s_178_333: call DBGPRCR_read(s_178_332)
        let s_178_333: ProductType700c18a878c5601b = DBGPRCR_read(
            state,
            tracer,
            s_178_332,
        );
        // D s_178_334: write-var ga#35468 <= s_178_333
        fn_state.ga_35468 = s_178_333;
        // D s_178_335: read-var ga#35468.0:struct
        let s_178_335: u32 = fn_state.ga_35468._0;
        // C s_178_336: const #31s : i
        let s_178_336: i128 = 31;
        // C s_178_337: const #1s : i
        let s_178_337: i128 = 1;
        // D s_178_338: cast zx s_178_335 -> bv
        let s_178_338: Bits = Bits::new(s_178_335 as u128, 32u16);
        // C s_178_339: const #0u : u31
        let s_178_339: u32 = 0;
        // C s_178_340: cast zx s_178_339 -> bv
        let s_178_340: Bits = Bits::new(s_178_339 as u128, 31u16);
        // C s_178_341: const #1u : u64
        let s_178_341: u64 = 1;
        // C s_178_342: cast zx s_178_341 -> bv
        let s_178_342: Bits = Bits::new(s_178_341 as u128, 64u16);
        // C s_178_343: lsl s_178_342 s_178_336
        let s_178_343: Bits = s_178_342 << s_178_336;
        // C s_178_344: sub s_178_343 s_178_342
        let s_178_344: Bits = ((s_178_343) - (s_178_342));
        // C s_178_345: and s_178_340 s_178_344
        let s_178_345: Bits = ((s_178_340) & (s_178_344));
        // C s_178_346: lsl s_178_345 s_178_337
        let s_178_346: Bits = s_178_345 << s_178_337;
        // C s_178_347: lsl s_178_344 s_178_337
        let s_178_347: Bits = s_178_344 << s_178_337;
        // C s_178_348: cmpl s_178_347
        let s_178_348: Bits = !s_178_347;
        // D s_178_349: and s_178_338 s_178_348
        let s_178_349: Bits = ((s_178_338) & (s_178_348));
        // D s_178_350: or s_178_349 s_178_346
        let s_178_350: Bits = ((s_178_349) | (s_178_346));
        // D s_178_351: cast reint s_178_350 -> u32
        let s_178_351: u32 = (s_178_350.value() as u32);
        // D s_178_352: call Mk_DBGPRCR_Type(s_178_351)
        let s_178_352: ProductType700c18a878c5601b = Mk_DBGPRCR_Type(
            state,
            tracer,
            s_178_351,
        );
        // D s_178_353: call DBGPRCR_write(s_178_352)
        let s_178_353: () = DBGPRCR_write(state, tracer, s_178_352);
        // C s_178_354: const #() : ()
        let s_178_354: () = ();
        // S s_178_355: call SDER_read(s_178_354)
        let s_178_355: ProductType700c18a878c5601b = SDER_read(state, tracer, s_178_354);
        // D s_178_356: write-var ga#35472 <= s_178_355
        fn_state.ga_35472 = s_178_355;
        // D s_178_357: read-var ga#35472.0:struct
        let s_178_357: u32 = fn_state.ga_35472._0;
        // C s_178_358: const #30s : i
        let s_178_358: i128 = 30;
        // C s_178_359: const #2s : i
        let s_178_359: i128 = 2;
        // D s_178_360: cast zx s_178_357 -> bv
        let s_178_360: Bits = Bits::new(s_178_357 as u128, 32u16);
        // C s_178_361: const #0u : u30
        let s_178_361: u32 = 0;
        // C s_178_362: cast zx s_178_361 -> bv
        let s_178_362: Bits = Bits::new(s_178_361 as u128, 30u16);
        // C s_178_363: const #1u : u64
        let s_178_363: u64 = 1;
        // C s_178_364: cast zx s_178_363 -> bv
        let s_178_364: Bits = Bits::new(s_178_363 as u128, 64u16);
        // C s_178_365: lsl s_178_364 s_178_358
        let s_178_365: Bits = s_178_364 << s_178_358;
        // C s_178_366: sub s_178_365 s_178_364
        let s_178_366: Bits = ((s_178_365) - (s_178_364));
        // C s_178_367: and s_178_362 s_178_366
        let s_178_367: Bits = ((s_178_362) & (s_178_366));
        // C s_178_368: lsl s_178_367 s_178_359
        let s_178_368: Bits = s_178_367 << s_178_359;
        // C s_178_369: lsl s_178_366 s_178_359
        let s_178_369: Bits = s_178_366 << s_178_359;
        // C s_178_370: cmpl s_178_369
        let s_178_370: Bits = !s_178_369;
        // D s_178_371: and s_178_360 s_178_370
        let s_178_371: Bits = ((s_178_360) & (s_178_370));
        // D s_178_372: or s_178_371 s_178_368
        let s_178_372: Bits = ((s_178_371) | (s_178_368));
        // D s_178_373: cast reint s_178_372 -> u32
        let s_178_373: u32 = (s_178_372.value() as u32);
        // D s_178_374: call Mk_SDER_Type(s_178_373)
        let s_178_374: ProductType700c18a878c5601b = Mk_SDER_Type(
            state,
            tracer,
            s_178_373,
        );
        // D s_178_375: call SDER_write(s_178_374)
        let s_178_375: () = SDER_write(state, tracer, s_178_374);
        // C s_178_376: const #() : ()
        let s_178_376: () = ();
        // S s_178_377: call SDER_read(s_178_376)
        let s_178_377: ProductType700c18a878c5601b = SDER_read(state, tracer, s_178_376);
        // C s_178_378: const #0u : u8
        let s_178_378: bool = false;
        // S s_178_379: call _update_SDER_Type_SUNIDEN(s_178_377, s_178_378)
        let s_178_379: ProductType700c18a878c5601b = u_update_SDER_Type_SUNIDEN(
            state,
            tracer,
            s_178_377,
            s_178_378,
        );
        // S s_178_380: call SDER_write(s_178_379)
        let s_178_380: () = SDER_write(state, tracer, s_178_379);
        // C s_178_381: const #() : ()
        let s_178_381: () = ();
        // S s_178_382: call SDER_read(s_178_381)
        let s_178_382: ProductType700c18a878c5601b = SDER_read(state, tracer, s_178_381);
        // C s_178_383: const #0u : u8
        let s_178_383: bool = false;
        // S s_178_384: call _update_SDER_Type_SUIDEN(s_178_382, s_178_383)
        let s_178_384: ProductType700c18a878c5601b = u_update_SDER_Type_SUIDEN(
            state,
            tracer,
            s_178_382,
            s_178_383,
        );
        // S s_178_385: call SDER_write(s_178_384)
        let s_178_385: () = SDER_write(state, tracer, s_178_384);
        // C s_178_386: const #() : ()
        let s_178_386: () = ();
        // S s_178_387: call ICC_EOIR1_read(s_178_386)
        let s_178_387: ProductType700c18a878c5601b = ICC_EOIR1_read(
            state,
            tracer,
            s_178_386,
        );
        // D s_178_388: write-var ga#35480 <= s_178_387
        fn_state.ga_35480 = s_178_387;
        // D s_178_389: read-var ga#35480.0:struct
        let s_178_389: u32 = fn_state.ga_35480._0;
        // C s_178_390: const #8s : i
        let s_178_390: i128 = 8;
        // C s_178_391: const #24s : i
        let s_178_391: i128 = 24;
        // D s_178_392: cast zx s_178_389 -> bv
        let s_178_392: Bits = Bits::new(s_178_389 as u128, 32u16);
        // C s_178_393: const #0u : u8
        let s_178_393: u8 = 0;
        // C s_178_394: cast zx s_178_393 -> bv
        let s_178_394: Bits = Bits::new(s_178_393 as u128, 8u16);
        // C s_178_395: const #1u : u64
        let s_178_395: u64 = 1;
        // C s_178_396: cast zx s_178_395 -> bv
        let s_178_396: Bits = Bits::new(s_178_395 as u128, 64u16);
        // C s_178_397: lsl s_178_396 s_178_390
        let s_178_397: Bits = s_178_396 << s_178_390;
        // C s_178_398: sub s_178_397 s_178_396
        let s_178_398: Bits = ((s_178_397) - (s_178_396));
        // C s_178_399: and s_178_394 s_178_398
        let s_178_399: Bits = ((s_178_394) & (s_178_398));
        // C s_178_400: lsl s_178_399 s_178_391
        let s_178_400: Bits = s_178_399 << s_178_391;
        // C s_178_401: lsl s_178_398 s_178_391
        let s_178_401: Bits = s_178_398 << s_178_391;
        // C s_178_402: cmpl s_178_401
        let s_178_402: Bits = !s_178_401;
        // D s_178_403: and s_178_392 s_178_402
        let s_178_403: Bits = ((s_178_392) & (s_178_402));
        // D s_178_404: or s_178_403 s_178_400
        let s_178_404: Bits = ((s_178_403) | (s_178_400));
        // D s_178_405: cast reint s_178_404 -> u32
        let s_178_405: u32 = (s_178_404.value() as u32);
        // D s_178_406: call Mk_ICC_EOIR1_Type(s_178_405)
        let s_178_406: ProductType700c18a878c5601b = Mk_ICC_EOIR1_Type(
            state,
            tracer,
            s_178_405,
        );
        // D s_178_407: call ICC_EOIR1_write(s_178_406)
        let s_178_407: () = ICC_EOIR1_write(state, tracer, s_178_406);
        // C s_178_408: const #() : ()
        let s_178_408: () = ();
        // S s_178_409: call ICC_BPR0_read(s_178_408)
        let s_178_409: ProductType700c18a878c5601b = ICC_BPR0_read(
            state,
            tracer,
            s_178_408,
        );
        // D s_178_410: write-var ga#35484 <= s_178_409
        fn_state.ga_35484 = s_178_409;
        // D s_178_411: read-var ga#35484.0:struct
        let s_178_411: u32 = fn_state.ga_35484._0;
        // C s_178_412: const #29s : i
        let s_178_412: i128 = 29;
        // C s_178_413: const #3s : i
        let s_178_413: i128 = 3;
        // D s_178_414: cast zx s_178_411 -> bv
        let s_178_414: Bits = Bits::new(s_178_411 as u128, 32u16);
        // C s_178_415: const #0u : u29
        let s_178_415: u32 = 0;
        // C s_178_416: cast zx s_178_415 -> bv
        let s_178_416: Bits = Bits::new(s_178_415 as u128, 29u16);
        // C s_178_417: const #1u : u64
        let s_178_417: u64 = 1;
        // C s_178_418: cast zx s_178_417 -> bv
        let s_178_418: Bits = Bits::new(s_178_417 as u128, 64u16);
        // C s_178_419: lsl s_178_418 s_178_412
        let s_178_419: Bits = s_178_418 << s_178_412;
        // C s_178_420: sub s_178_419 s_178_418
        let s_178_420: Bits = ((s_178_419) - (s_178_418));
        // C s_178_421: and s_178_416 s_178_420
        let s_178_421: Bits = ((s_178_416) & (s_178_420));
        // C s_178_422: lsl s_178_421 s_178_413
        let s_178_422: Bits = s_178_421 << s_178_413;
        // C s_178_423: lsl s_178_420 s_178_413
        let s_178_423: Bits = s_178_420 << s_178_413;
        // C s_178_424: cmpl s_178_423
        let s_178_424: Bits = !s_178_423;
        // D s_178_425: and s_178_414 s_178_424
        let s_178_425: Bits = ((s_178_414) & (s_178_424));
        // D s_178_426: or s_178_425 s_178_422
        let s_178_426: Bits = ((s_178_425) | (s_178_422));
        // D s_178_427: cast reint s_178_426 -> u32
        let s_178_427: u32 = (s_178_426.value() as u32);
        // D s_178_428: call Mk_ICC_BPR0_Type(s_178_427)
        let s_178_428: ProductType700c18a878c5601b = Mk_ICC_BPR0_Type(
            state,
            tracer,
            s_178_427,
        );
        // D s_178_429: call ICC_BPR0_write(s_178_428)
        let s_178_429: () = ICC_BPR0_write(state, tracer, s_178_428);
        // C s_178_430: const #() : ()
        let s_178_430: () = ();
        // S s_178_431: call CNTHCTL_read(s_178_430)
        let s_178_431: ProductType700c18a878c5601b = CNTHCTL_read(
            state,
            tracer,
            s_178_430,
        );
        // D s_178_432: write-var ga#35488 <= s_178_431
        fn_state.ga_35488 = s_178_431;
        // D s_178_433: read-var ga#35488.0:struct
        let s_178_433: u32 = fn_state.ga_35488._0;
        // C s_178_434: const #14s : i
        let s_178_434: i128 = 14;
        // C s_178_435: const #18s : i
        let s_178_435: i128 = 18;
        // D s_178_436: cast zx s_178_433 -> bv
        let s_178_436: Bits = Bits::new(s_178_433 as u128, 32u16);
        // C s_178_437: const #0u : u14
        let s_178_437: u16 = 0;
        // C s_178_438: cast zx s_178_437 -> bv
        let s_178_438: Bits = Bits::new(s_178_437 as u128, 14u16);
        // C s_178_439: const #1u : u64
        let s_178_439: u64 = 1;
        // C s_178_440: cast zx s_178_439 -> bv
        let s_178_440: Bits = Bits::new(s_178_439 as u128, 64u16);
        // C s_178_441: lsl s_178_440 s_178_434
        let s_178_441: Bits = s_178_440 << s_178_434;
        // C s_178_442: sub s_178_441 s_178_440
        let s_178_442: Bits = ((s_178_441) - (s_178_440));
        // C s_178_443: and s_178_438 s_178_442
        let s_178_443: Bits = ((s_178_438) & (s_178_442));
        // C s_178_444: lsl s_178_443 s_178_435
        let s_178_444: Bits = s_178_443 << s_178_435;
        // C s_178_445: lsl s_178_442 s_178_435
        let s_178_445: Bits = s_178_442 << s_178_435;
        // C s_178_446: cmpl s_178_445
        let s_178_446: Bits = !s_178_445;
        // D s_178_447: and s_178_436 s_178_446
        let s_178_447: Bits = ((s_178_436) & (s_178_446));
        // D s_178_448: or s_178_447 s_178_444
        let s_178_448: Bits = ((s_178_447) | (s_178_444));
        // D s_178_449: cast reint s_178_448 -> u32
        let s_178_449: u32 = (s_178_448.value() as u32);
        // D s_178_450: call Mk_CNTHCTL_Type(s_178_449)
        let s_178_450: ProductType700c18a878c5601b = Mk_CNTHCTL_Type(
            state,
            tracer,
            s_178_449,
        );
        // D s_178_451: call CNTHCTL_write(s_178_450)
        let s_178_451: () = CNTHCTL_write(state, tracer, s_178_450);
        // C s_178_452: const #() : ()
        let s_178_452: () = ();
        // S s_178_453: call CNTHCTL_read(s_178_452)
        let s_178_453: ProductType700c18a878c5601b = CNTHCTL_read(
            state,
            tracer,
            s_178_452,
        );
        // D s_178_454: write-var ga#35492 <= s_178_453
        fn_state.ga_35492 = s_178_453;
        // D s_178_455: read-var ga#35492.0:struct
        let s_178_455: u32 = fn_state.ga_35492._0;
        // C s_178_456: const #9s : i
        let s_178_456: i128 = 9;
        // C s_178_457: const #8s : i
        let s_178_457: i128 = 8;
        // D s_178_458: cast zx s_178_455 -> bv
        let s_178_458: Bits = Bits::new(s_178_455 as u128, 32u16);
        // C s_178_459: const #0u : u9
        let s_178_459: u16 = 0;
        // C s_178_460: cast zx s_178_459 -> bv
        let s_178_460: Bits = Bits::new(s_178_459 as u128, 9u16);
        // C s_178_461: const #1u : u64
        let s_178_461: u64 = 1;
        // C s_178_462: cast zx s_178_461 -> bv
        let s_178_462: Bits = Bits::new(s_178_461 as u128, 64u16);
        // C s_178_463: lsl s_178_462 s_178_456
        let s_178_463: Bits = s_178_462 << s_178_456;
        // C s_178_464: sub s_178_463 s_178_462
        let s_178_464: Bits = ((s_178_463) - (s_178_462));
        // C s_178_465: and s_178_460 s_178_464
        let s_178_465: Bits = ((s_178_460) & (s_178_464));
        // C s_178_466: lsl s_178_465 s_178_457
        let s_178_466: Bits = s_178_465 << s_178_457;
        // C s_178_467: lsl s_178_464 s_178_457
        let s_178_467: Bits = s_178_464 << s_178_457;
        // C s_178_468: cmpl s_178_467
        let s_178_468: Bits = !s_178_467;
        // D s_178_469: and s_178_458 s_178_468
        let s_178_469: Bits = ((s_178_458) & (s_178_468));
        // D s_178_470: or s_178_469 s_178_466
        let s_178_470: Bits = ((s_178_469) | (s_178_466));
        // D s_178_471: cast reint s_178_470 -> u32
        let s_178_471: u32 = (s_178_470.value() as u32);
        // D s_178_472: call Mk_CNTHCTL_Type(s_178_471)
        let s_178_472: ProductType700c18a878c5601b = Mk_CNTHCTL_Type(
            state,
            tracer,
            s_178_471,
        );
        // D s_178_473: call CNTHCTL_write(s_178_472)
        let s_178_473: () = CNTHCTL_write(state, tracer, s_178_472);
        // C s_178_474: const #() : ()
        let s_178_474: () = ();
        // S s_178_475: call DBGVCR_read(s_178_474)
        let s_178_475: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_474,
        );
        // D s_178_476: write-var ga#35496 <= s_178_475
        fn_state.ga_35496 = s_178_475;
        // D s_178_477: read-var ga#35496.0:struct
        let s_178_477: u32 = fn_state.ga_35496._0;
        // C s_178_478: const #1s : i
        let s_178_478: i128 = 1;
        // C s_178_479: const #29s : i
        let s_178_479: i128 = 29;
        // D s_178_480: cast zx s_178_477 -> bv
        let s_178_480: Bits = Bits::new(s_178_477 as u128, 32u16);
        // C s_178_481: const #0u : u8
        let s_178_481: bool = false;
        // C s_178_482: cast zx s_178_481 -> bv
        let s_178_482: Bits = Bits::new(s_178_481 as u128, 1u16);
        // C s_178_483: const #1u : u64
        let s_178_483: u64 = 1;
        // C s_178_484: cast zx s_178_483 -> bv
        let s_178_484: Bits = Bits::new(s_178_483 as u128, 64u16);
        // C s_178_485: lsl s_178_484 s_178_478
        let s_178_485: Bits = s_178_484 << s_178_478;
        // C s_178_486: sub s_178_485 s_178_484
        let s_178_486: Bits = ((s_178_485) - (s_178_484));
        // C s_178_487: and s_178_482 s_178_486
        let s_178_487: Bits = ((s_178_482) & (s_178_486));
        // C s_178_488: lsl s_178_487 s_178_479
        let s_178_488: Bits = s_178_487 << s_178_479;
        // C s_178_489: lsl s_178_486 s_178_479
        let s_178_489: Bits = s_178_486 << s_178_479;
        // C s_178_490: cmpl s_178_489
        let s_178_490: Bits = !s_178_489;
        // D s_178_491: and s_178_480 s_178_490
        let s_178_491: Bits = ((s_178_480) & (s_178_490));
        // D s_178_492: or s_178_491 s_178_488
        let s_178_492: Bits = ((s_178_491) | (s_178_488));
        // D s_178_493: cast reint s_178_492 -> u32
        let s_178_493: u32 = (s_178_492.value() as u32);
        // D s_178_494: call Mk_DBGVCR_Type(s_178_493)
        let s_178_494: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_493,
        );
        // D s_178_495: call DBGVCR_write(s_178_494)
        let s_178_495: () = DBGVCR_write(state, tracer, s_178_494);
        // C s_178_496: const #() : ()
        let s_178_496: () = ();
        // S s_178_497: call DBGVCR_read(s_178_496)
        let s_178_497: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_496,
        );
        // D s_178_498: write-var ga#35500 <= s_178_497
        fn_state.ga_35500 = s_178_497;
        // D s_178_499: read-var ga#35500.0:struct
        let s_178_499: u32 = fn_state.ga_35500._0;
        // C s_178_500: const #9s : i
        let s_178_500: i128 = 9;
        // C s_178_501: const #16s : i
        let s_178_501: i128 = 16;
        // D s_178_502: cast zx s_178_499 -> bv
        let s_178_502: Bits = Bits::new(s_178_499 as u128, 32u16);
        // C s_178_503: const #0u : u9
        let s_178_503: u16 = 0;
        // C s_178_504: cast zx s_178_503 -> bv
        let s_178_504: Bits = Bits::new(s_178_503 as u128, 9u16);
        // C s_178_505: const #1u : u64
        let s_178_505: u64 = 1;
        // C s_178_506: cast zx s_178_505 -> bv
        let s_178_506: Bits = Bits::new(s_178_505 as u128, 64u16);
        // C s_178_507: lsl s_178_506 s_178_500
        let s_178_507: Bits = s_178_506 << s_178_500;
        // C s_178_508: sub s_178_507 s_178_506
        let s_178_508: Bits = ((s_178_507) - (s_178_506));
        // C s_178_509: and s_178_504 s_178_508
        let s_178_509: Bits = ((s_178_504) & (s_178_508));
        // C s_178_510: lsl s_178_509 s_178_501
        let s_178_510: Bits = s_178_509 << s_178_501;
        // C s_178_511: lsl s_178_508 s_178_501
        let s_178_511: Bits = s_178_508 << s_178_501;
        // C s_178_512: cmpl s_178_511
        let s_178_512: Bits = !s_178_511;
        // D s_178_513: and s_178_502 s_178_512
        let s_178_513: Bits = ((s_178_502) & (s_178_512));
        // D s_178_514: or s_178_513 s_178_510
        let s_178_514: Bits = ((s_178_513) | (s_178_510));
        // D s_178_515: cast reint s_178_514 -> u32
        let s_178_515: u32 = (s_178_514.value() as u32);
        // D s_178_516: call Mk_DBGVCR_Type(s_178_515)
        let s_178_516: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_515,
        );
        // D s_178_517: call DBGVCR_write(s_178_516)
        let s_178_517: () = DBGVCR_write(state, tracer, s_178_516);
        // C s_178_518: const #() : ()
        let s_178_518: () = ();
        // S s_178_519: call DBGVCR_read(s_178_518)
        let s_178_519: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_518,
        );
        // D s_178_520: write-var ga#35504 <= s_178_519
        fn_state.ga_35504 = s_178_519;
        // D s_178_521: read-var ga#35504.0:struct
        let s_178_521: u32 = fn_state.ga_35504._0;
        // C s_178_522: const #1s : i
        let s_178_522: i128 = 1;
        // C s_178_523: const #13s : i
        let s_178_523: i128 = 13;
        // D s_178_524: cast zx s_178_521 -> bv
        let s_178_524: Bits = Bits::new(s_178_521 as u128, 32u16);
        // C s_178_525: const #0u : u8
        let s_178_525: bool = false;
        // C s_178_526: cast zx s_178_525 -> bv
        let s_178_526: Bits = Bits::new(s_178_525 as u128, 1u16);
        // C s_178_527: const #1u : u64
        let s_178_527: u64 = 1;
        // C s_178_528: cast zx s_178_527 -> bv
        let s_178_528: Bits = Bits::new(s_178_527 as u128, 64u16);
        // C s_178_529: lsl s_178_528 s_178_522
        let s_178_529: Bits = s_178_528 << s_178_522;
        // C s_178_530: sub s_178_529 s_178_528
        let s_178_530: Bits = ((s_178_529) - (s_178_528));
        // C s_178_531: and s_178_526 s_178_530
        let s_178_531: Bits = ((s_178_526) & (s_178_530));
        // C s_178_532: lsl s_178_531 s_178_523
        let s_178_532: Bits = s_178_531 << s_178_523;
        // C s_178_533: lsl s_178_530 s_178_523
        let s_178_533: Bits = s_178_530 << s_178_523;
        // C s_178_534: cmpl s_178_533
        let s_178_534: Bits = !s_178_533;
        // D s_178_535: and s_178_524 s_178_534
        let s_178_535: Bits = ((s_178_524) & (s_178_534));
        // D s_178_536: or s_178_535 s_178_532
        let s_178_536: Bits = ((s_178_535) | (s_178_532));
        // D s_178_537: cast reint s_178_536 -> u32
        let s_178_537: u32 = (s_178_536.value() as u32);
        // D s_178_538: call Mk_DBGVCR_Type(s_178_537)
        let s_178_538: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_537,
        );
        // D s_178_539: call DBGVCR_write(s_178_538)
        let s_178_539: () = DBGVCR_write(state, tracer, s_178_538);
        // C s_178_540: const #() : ()
        let s_178_540: () = ();
        // S s_178_541: call DBGVCR_read(s_178_540)
        let s_178_541: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_540,
        );
        // D s_178_542: write-var ga#35508 <= s_178_541
        fn_state.ga_35508 = s_178_541;
        // D s_178_543: read-var ga#35508.0:struct
        let s_178_543: u32 = fn_state.ga_35508._0;
        // C s_178_544: const #2s : i
        let s_178_544: i128 = 2;
        // C s_178_545: const #8s : i
        let s_178_545: i128 = 8;
        // D s_178_546: cast zx s_178_543 -> bv
        let s_178_546: Bits = Bits::new(s_178_543 as u128, 32u16);
        // C s_178_547: const #0u : u8
        let s_178_547: u8 = 0;
        // C s_178_548: cast zx s_178_547 -> bv
        let s_178_548: Bits = Bits::new(s_178_547 as u128, 2u16);
        // C s_178_549: const #1u : u64
        let s_178_549: u64 = 1;
        // C s_178_550: cast zx s_178_549 -> bv
        let s_178_550: Bits = Bits::new(s_178_549 as u128, 64u16);
        // C s_178_551: lsl s_178_550 s_178_544
        let s_178_551: Bits = s_178_550 << s_178_544;
        // C s_178_552: sub s_178_551 s_178_550
        let s_178_552: Bits = ((s_178_551) - (s_178_550));
        // C s_178_553: and s_178_548 s_178_552
        let s_178_553: Bits = ((s_178_548) & (s_178_552));
        // C s_178_554: lsl s_178_553 s_178_545
        let s_178_554: Bits = s_178_553 << s_178_545;
        // C s_178_555: lsl s_178_552 s_178_545
        let s_178_555: Bits = s_178_552 << s_178_545;
        // C s_178_556: cmpl s_178_555
        let s_178_556: Bits = !s_178_555;
        // D s_178_557: and s_178_546 s_178_556
        let s_178_557: Bits = ((s_178_546) & (s_178_556));
        // D s_178_558: or s_178_557 s_178_554
        let s_178_558: Bits = ((s_178_557) | (s_178_554));
        // D s_178_559: cast reint s_178_558 -> u32
        let s_178_559: u32 = (s_178_558.value() as u32);
        // D s_178_560: call Mk_DBGVCR_Type(s_178_559)
        let s_178_560: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_559,
        );
        // D s_178_561: call DBGVCR_write(s_178_560)
        let s_178_561: () = DBGVCR_write(state, tracer, s_178_560);
        // C s_178_562: const #() : ()
        let s_178_562: () = ();
        // S s_178_563: call DBGVCR_read(s_178_562)
        let s_178_563: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_562,
        );
        // D s_178_564: write-var ga#35512 <= s_178_563
        fn_state.ga_35512 = s_178_563;
        // D s_178_565: read-var ga#35512.0:struct
        let s_178_565: u32 = fn_state.ga_35512._0;
        // C s_178_566: const #1s : i
        let s_178_566: i128 = 1;
        // C s_178_567: const #5s : i
        let s_178_567: i128 = 5;
        // D s_178_568: cast zx s_178_565 -> bv
        let s_178_568: Bits = Bits::new(s_178_565 as u128, 32u16);
        // C s_178_569: const #0u : u8
        let s_178_569: bool = false;
        // C s_178_570: cast zx s_178_569 -> bv
        let s_178_570: Bits = Bits::new(s_178_569 as u128, 1u16);
        // C s_178_571: const #1u : u64
        let s_178_571: u64 = 1;
        // C s_178_572: cast zx s_178_571 -> bv
        let s_178_572: Bits = Bits::new(s_178_571 as u128, 64u16);
        // C s_178_573: lsl s_178_572 s_178_566
        let s_178_573: Bits = s_178_572 << s_178_566;
        // C s_178_574: sub s_178_573 s_178_572
        let s_178_574: Bits = ((s_178_573) - (s_178_572));
        // C s_178_575: and s_178_570 s_178_574
        let s_178_575: Bits = ((s_178_570) & (s_178_574));
        // C s_178_576: lsl s_178_575 s_178_567
        let s_178_576: Bits = s_178_575 << s_178_567;
        // C s_178_577: lsl s_178_574 s_178_567
        let s_178_577: Bits = s_178_574 << s_178_567;
        // C s_178_578: cmpl s_178_577
        let s_178_578: Bits = !s_178_577;
        // D s_178_579: and s_178_568 s_178_578
        let s_178_579: Bits = ((s_178_568) & (s_178_578));
        // D s_178_580: or s_178_579 s_178_576
        let s_178_580: Bits = ((s_178_579) | (s_178_576));
        // D s_178_581: cast reint s_178_580 -> u32
        let s_178_581: u32 = (s_178_580.value() as u32);
        // D s_178_582: call Mk_DBGVCR_Type(s_178_581)
        let s_178_582: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_581,
        );
        // D s_178_583: call DBGVCR_write(s_178_582)
        let s_178_583: () = DBGVCR_write(state, tracer, s_178_582);
        // C s_178_584: const #() : ()
        let s_178_584: () = ();
        // S s_178_585: call DBGVCR_read(s_178_584)
        let s_178_585: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_584,
        );
        // D s_178_586: write-var ga#35516 <= s_178_585
        fn_state.ga_35516 = s_178_585;
        // D s_178_587: read-var ga#35516.0:struct
        let s_178_587: u32 = fn_state.ga_35516._0;
        // C s_178_588: const #1s : i
        let s_178_588: i128 = 1;
        // C s_178_589: const #0s : i
        let s_178_589: i128 = 0;
        // D s_178_590: cast zx s_178_587 -> bv
        let s_178_590: Bits = Bits::new(s_178_587 as u128, 32u16);
        // C s_178_591: const #0u : u8
        let s_178_591: bool = false;
        // C s_178_592: cast zx s_178_591 -> bv
        let s_178_592: Bits = Bits::new(s_178_591 as u128, 1u16);
        // C s_178_593: const #1u : u64
        let s_178_593: u64 = 1;
        // C s_178_594: cast zx s_178_593 -> bv
        let s_178_594: Bits = Bits::new(s_178_593 as u128, 64u16);
        // C s_178_595: lsl s_178_594 s_178_588
        let s_178_595: Bits = s_178_594 << s_178_588;
        // C s_178_596: sub s_178_595 s_178_594
        let s_178_596: Bits = ((s_178_595) - (s_178_594));
        // C s_178_597: and s_178_592 s_178_596
        let s_178_597: Bits = ((s_178_592) & (s_178_596));
        // C s_178_598: lsl s_178_597 s_178_589
        let s_178_598: Bits = s_178_597 << s_178_589;
        // C s_178_599: lsl s_178_596 s_178_589
        let s_178_599: Bits = s_178_596 << s_178_589;
        // C s_178_600: cmpl s_178_599
        let s_178_600: Bits = !s_178_599;
        // D s_178_601: and s_178_590 s_178_600
        let s_178_601: Bits = ((s_178_590) & (s_178_600));
        // D s_178_602: or s_178_601 s_178_598
        let s_178_602: Bits = ((s_178_601) | (s_178_598));
        // D s_178_603: cast reint s_178_602 -> u32
        let s_178_603: u32 = (s_178_602.value() as u32);
        // D s_178_604: call Mk_DBGVCR_Type(s_178_603)
        let s_178_604: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_603,
        );
        // D s_178_605: call DBGVCR_write(s_178_604)
        let s_178_605: () = DBGVCR_write(state, tracer, s_178_604);
        // C s_178_606: const #() : ()
        let s_178_606: () = ();
        // S s_178_607: call DBGVCR_read(s_178_606)
        let s_178_607: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_606,
        );
        // D s_178_608: write-var ga#35520 <= s_178_607
        fn_state.ga_35520 = s_178_607;
        // D s_178_609: read-var ga#35520.0:struct
        let s_178_609: u32 = fn_state.ga_35520._0;
        // C s_178_610: const #1s : i
        let s_178_610: i128 = 1;
        // C s_178_611: const #29s : i
        let s_178_611: i128 = 29;
        // D s_178_612: cast zx s_178_609 -> bv
        let s_178_612: Bits = Bits::new(s_178_609 as u128, 32u16);
        // C s_178_613: const #0u : u8
        let s_178_613: bool = false;
        // C s_178_614: cast zx s_178_613 -> bv
        let s_178_614: Bits = Bits::new(s_178_613 as u128, 1u16);
        // C s_178_615: const #1u : u64
        let s_178_615: u64 = 1;
        // C s_178_616: cast zx s_178_615 -> bv
        let s_178_616: Bits = Bits::new(s_178_615 as u128, 64u16);
        // C s_178_617: lsl s_178_616 s_178_610
        let s_178_617: Bits = s_178_616 << s_178_610;
        // C s_178_618: sub s_178_617 s_178_616
        let s_178_618: Bits = ((s_178_617) - (s_178_616));
        // C s_178_619: and s_178_614 s_178_618
        let s_178_619: Bits = ((s_178_614) & (s_178_618));
        // C s_178_620: lsl s_178_619 s_178_611
        let s_178_620: Bits = s_178_619 << s_178_611;
        // C s_178_621: lsl s_178_618 s_178_611
        let s_178_621: Bits = s_178_618 << s_178_611;
        // C s_178_622: cmpl s_178_621
        let s_178_622: Bits = !s_178_621;
        // D s_178_623: and s_178_612 s_178_622
        let s_178_623: Bits = ((s_178_612) & (s_178_622));
        // D s_178_624: or s_178_623 s_178_620
        let s_178_624: Bits = ((s_178_623) | (s_178_620));
        // D s_178_625: cast reint s_178_624 -> u32
        let s_178_625: u32 = (s_178_624.value() as u32);
        // D s_178_626: call Mk_DBGVCR_Type(s_178_625)
        let s_178_626: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_625,
        );
        // D s_178_627: call DBGVCR_write(s_178_626)
        let s_178_627: () = DBGVCR_write(state, tracer, s_178_626);
        // C s_178_628: const #() : ()
        let s_178_628: () = ();
        // S s_178_629: call DBGVCR_read(s_178_628)
        let s_178_629: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_628,
        );
        // D s_178_630: write-var ga#35524 <= s_178_629
        fn_state.ga_35524 = s_178_629;
        // D s_178_631: read-var ga#35524.0:struct
        let s_178_631: u32 = fn_state.ga_35524._0;
        // C s_178_632: const #17s : i
        let s_178_632: i128 = 17;
        // C s_178_633: const #8s : i
        let s_178_633: i128 = 8;
        // D s_178_634: cast zx s_178_631 -> bv
        let s_178_634: Bits = Bits::new(s_178_631 as u128, 32u16);
        // C s_178_635: const #0u : u17
        let s_178_635: u32 = 0;
        // C s_178_636: cast zx s_178_635 -> bv
        let s_178_636: Bits = Bits::new(s_178_635 as u128, 17u16);
        // C s_178_637: const #1u : u64
        let s_178_637: u64 = 1;
        // C s_178_638: cast zx s_178_637 -> bv
        let s_178_638: Bits = Bits::new(s_178_637 as u128, 64u16);
        // C s_178_639: lsl s_178_638 s_178_632
        let s_178_639: Bits = s_178_638 << s_178_632;
        // C s_178_640: sub s_178_639 s_178_638
        let s_178_640: Bits = ((s_178_639) - (s_178_638));
        // C s_178_641: and s_178_636 s_178_640
        let s_178_641: Bits = ((s_178_636) & (s_178_640));
        // C s_178_642: lsl s_178_641 s_178_633
        let s_178_642: Bits = s_178_641 << s_178_633;
        // C s_178_643: lsl s_178_640 s_178_633
        let s_178_643: Bits = s_178_640 << s_178_633;
        // C s_178_644: cmpl s_178_643
        let s_178_644: Bits = !s_178_643;
        // D s_178_645: and s_178_634 s_178_644
        let s_178_645: Bits = ((s_178_634) & (s_178_644));
        // D s_178_646: or s_178_645 s_178_642
        let s_178_646: Bits = ((s_178_645) | (s_178_642));
        // D s_178_647: cast reint s_178_646 -> u32
        let s_178_647: u32 = (s_178_646.value() as u32);
        // D s_178_648: call Mk_DBGVCR_Type(s_178_647)
        let s_178_648: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_647,
        );
        // D s_178_649: call DBGVCR_write(s_178_648)
        let s_178_649: () = DBGVCR_write(state, tracer, s_178_648);
        // C s_178_650: const #() : ()
        let s_178_650: () = ();
        // S s_178_651: call DBGVCR_read(s_178_650)
        let s_178_651: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_650,
        );
        // D s_178_652: write-var ga#35528 <= s_178_651
        fn_state.ga_35528 = s_178_651;
        // D s_178_653: read-var ga#35528.0:struct
        let s_178_653: u32 = fn_state.ga_35528._0;
        // C s_178_654: const #1s : i
        let s_178_654: i128 = 1;
        // C s_178_655: const #5s : i
        let s_178_655: i128 = 5;
        // D s_178_656: cast zx s_178_653 -> bv
        let s_178_656: Bits = Bits::new(s_178_653 as u128, 32u16);
        // C s_178_657: const #0u : u8
        let s_178_657: bool = false;
        // C s_178_658: cast zx s_178_657 -> bv
        let s_178_658: Bits = Bits::new(s_178_657 as u128, 1u16);
        // C s_178_659: const #1u : u64
        let s_178_659: u64 = 1;
        // C s_178_660: cast zx s_178_659 -> bv
        let s_178_660: Bits = Bits::new(s_178_659 as u128, 64u16);
        // C s_178_661: lsl s_178_660 s_178_654
        let s_178_661: Bits = s_178_660 << s_178_654;
        // C s_178_662: sub s_178_661 s_178_660
        let s_178_662: Bits = ((s_178_661) - (s_178_660));
        // C s_178_663: and s_178_658 s_178_662
        let s_178_663: Bits = ((s_178_658) & (s_178_662));
        // C s_178_664: lsl s_178_663 s_178_655
        let s_178_664: Bits = s_178_663 << s_178_655;
        // C s_178_665: lsl s_178_662 s_178_655
        let s_178_665: Bits = s_178_662 << s_178_655;
        // C s_178_666: cmpl s_178_665
        let s_178_666: Bits = !s_178_665;
        // D s_178_667: and s_178_656 s_178_666
        let s_178_667: Bits = ((s_178_656) & (s_178_666));
        // D s_178_668: or s_178_667 s_178_664
        let s_178_668: Bits = ((s_178_667) | (s_178_664));
        // D s_178_669: cast reint s_178_668 -> u32
        let s_178_669: u32 = (s_178_668.value() as u32);
        // D s_178_670: call Mk_DBGVCR_Type(s_178_669)
        let s_178_670: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_669,
        );
        // D s_178_671: call DBGVCR_write(s_178_670)
        let s_178_671: () = DBGVCR_write(state, tracer, s_178_670);
        // C s_178_672: const #() : ()
        let s_178_672: () = ();
        // S s_178_673: call DBGVCR_read(s_178_672)
        let s_178_673: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_672,
        );
        // D s_178_674: write-var ga#35532 <= s_178_673
        fn_state.ga_35532 = s_178_673;
        // D s_178_675: read-var ga#35532.0:struct
        let s_178_675: u32 = fn_state.ga_35532._0;
        // C s_178_676: const #1s : i
        let s_178_676: i128 = 1;
        // C s_178_677: const #0s : i
        let s_178_677: i128 = 0;
        // D s_178_678: cast zx s_178_675 -> bv
        let s_178_678: Bits = Bits::new(s_178_675 as u128, 32u16);
        // C s_178_679: const #0u : u8
        let s_178_679: bool = false;
        // C s_178_680: cast zx s_178_679 -> bv
        let s_178_680: Bits = Bits::new(s_178_679 as u128, 1u16);
        // C s_178_681: const #1u : u64
        let s_178_681: u64 = 1;
        // C s_178_682: cast zx s_178_681 -> bv
        let s_178_682: Bits = Bits::new(s_178_681 as u128, 64u16);
        // C s_178_683: lsl s_178_682 s_178_676
        let s_178_683: Bits = s_178_682 << s_178_676;
        // C s_178_684: sub s_178_683 s_178_682
        let s_178_684: Bits = ((s_178_683) - (s_178_682));
        // C s_178_685: and s_178_680 s_178_684
        let s_178_685: Bits = ((s_178_680) & (s_178_684));
        // C s_178_686: lsl s_178_685 s_178_677
        let s_178_686: Bits = s_178_685 << s_178_677;
        // C s_178_687: lsl s_178_684 s_178_677
        let s_178_687: Bits = s_178_684 << s_178_677;
        // C s_178_688: cmpl s_178_687
        let s_178_688: Bits = !s_178_687;
        // D s_178_689: and s_178_678 s_178_688
        let s_178_689: Bits = ((s_178_678) & (s_178_688));
        // D s_178_690: or s_178_689 s_178_686
        let s_178_690: Bits = ((s_178_689) | (s_178_686));
        // D s_178_691: cast reint s_178_690 -> u32
        let s_178_691: u32 = (s_178_690.value() as u32);
        // D s_178_692: call Mk_DBGVCR_Type(s_178_691)
        let s_178_692: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_691,
        );
        // D s_178_693: call DBGVCR_write(s_178_692)
        let s_178_693: () = DBGVCR_write(state, tracer, s_178_692);
        // C s_178_694: const #() : ()
        let s_178_694: () = ();
        // S s_178_695: call DBGVCR_read(s_178_694)
        let s_178_695: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_694,
        );
        // D s_178_696: write-var ga#35536 <= s_178_695
        fn_state.ga_35536 = s_178_695;
        // D s_178_697: read-var ga#35536.0:struct
        let s_178_697: u32 = fn_state.ga_35536._0;
        // C s_178_698: const #24s : i
        let s_178_698: i128 = 24;
        // C s_178_699: const #8s : i
        let s_178_699: i128 = 8;
        // D s_178_700: cast zx s_178_697 -> bv
        let s_178_700: Bits = Bits::new(s_178_697 as u128, 32u16);
        // C s_178_701: const #0u : u24
        let s_178_701: u32 = 0;
        // C s_178_702: cast zx s_178_701 -> bv
        let s_178_702: Bits = Bits::new(s_178_701 as u128, 24u16);
        // C s_178_703: const #1u : u64
        let s_178_703: u64 = 1;
        // C s_178_704: cast zx s_178_703 -> bv
        let s_178_704: Bits = Bits::new(s_178_703 as u128, 64u16);
        // C s_178_705: lsl s_178_704 s_178_698
        let s_178_705: Bits = s_178_704 << s_178_698;
        // C s_178_706: sub s_178_705 s_178_704
        let s_178_706: Bits = ((s_178_705) - (s_178_704));
        // C s_178_707: and s_178_702 s_178_706
        let s_178_707: Bits = ((s_178_702) & (s_178_706));
        // C s_178_708: lsl s_178_707 s_178_699
        let s_178_708: Bits = s_178_707 << s_178_699;
        // C s_178_709: lsl s_178_706 s_178_699
        let s_178_709: Bits = s_178_706 << s_178_699;
        // C s_178_710: cmpl s_178_709
        let s_178_710: Bits = !s_178_709;
        // D s_178_711: and s_178_700 s_178_710
        let s_178_711: Bits = ((s_178_700) & (s_178_710));
        // D s_178_712: or s_178_711 s_178_708
        let s_178_712: Bits = ((s_178_711) | (s_178_708));
        // D s_178_713: cast reint s_178_712 -> u32
        let s_178_713: u32 = (s_178_712.value() as u32);
        // D s_178_714: call Mk_DBGVCR_Type(s_178_713)
        let s_178_714: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_713,
        );
        // D s_178_715: call DBGVCR_write(s_178_714)
        let s_178_715: () = DBGVCR_write(state, tracer, s_178_714);
        // C s_178_716: const #() : ()
        let s_178_716: () = ();
        // S s_178_717: call DBGVCR_read(s_178_716)
        let s_178_717: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_716,
        );
        // D s_178_718: write-var ga#35540 <= s_178_717
        fn_state.ga_35540 = s_178_717;
        // D s_178_719: read-var ga#35540.0:struct
        let s_178_719: u32 = fn_state.ga_35540._0;
        // C s_178_720: const #1s : i
        let s_178_720: i128 = 1;
        // C s_178_721: const #5s : i
        let s_178_721: i128 = 5;
        // D s_178_722: cast zx s_178_719 -> bv
        let s_178_722: Bits = Bits::new(s_178_719 as u128, 32u16);
        // C s_178_723: const #0u : u8
        let s_178_723: bool = false;
        // C s_178_724: cast zx s_178_723 -> bv
        let s_178_724: Bits = Bits::new(s_178_723 as u128, 1u16);
        // C s_178_725: const #1u : u64
        let s_178_725: u64 = 1;
        // C s_178_726: cast zx s_178_725 -> bv
        let s_178_726: Bits = Bits::new(s_178_725 as u128, 64u16);
        // C s_178_727: lsl s_178_726 s_178_720
        let s_178_727: Bits = s_178_726 << s_178_720;
        // C s_178_728: sub s_178_727 s_178_726
        let s_178_728: Bits = ((s_178_727) - (s_178_726));
        // C s_178_729: and s_178_724 s_178_728
        let s_178_729: Bits = ((s_178_724) & (s_178_728));
        // C s_178_730: lsl s_178_729 s_178_721
        let s_178_730: Bits = s_178_729 << s_178_721;
        // C s_178_731: lsl s_178_728 s_178_721
        let s_178_731: Bits = s_178_728 << s_178_721;
        // C s_178_732: cmpl s_178_731
        let s_178_732: Bits = !s_178_731;
        // D s_178_733: and s_178_722 s_178_732
        let s_178_733: Bits = ((s_178_722) & (s_178_732));
        // D s_178_734: or s_178_733 s_178_730
        let s_178_734: Bits = ((s_178_733) | (s_178_730));
        // D s_178_735: cast reint s_178_734 -> u32
        let s_178_735: u32 = (s_178_734.value() as u32);
        // D s_178_736: call Mk_DBGVCR_Type(s_178_735)
        let s_178_736: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_735,
        );
        // D s_178_737: call DBGVCR_write(s_178_736)
        let s_178_737: () = DBGVCR_write(state, tracer, s_178_736);
        // C s_178_738: const #() : ()
        let s_178_738: () = ();
        // S s_178_739: call DBGVCR_read(s_178_738)
        let s_178_739: ProductType700c18a878c5601b = DBGVCR_read(
            state,
            tracer,
            s_178_738,
        );
        // D s_178_740: write-var ga#35544 <= s_178_739
        fn_state.ga_35544 = s_178_739;
        // D s_178_741: read-var ga#35544.0:struct
        let s_178_741: u32 = fn_state.ga_35544._0;
        // C s_178_742: const #1s : i
        let s_178_742: i128 = 1;
        // C s_178_743: const #0s : i
        let s_178_743: i128 = 0;
        // D s_178_744: cast zx s_178_741 -> bv
        let s_178_744: Bits = Bits::new(s_178_741 as u128, 32u16);
        // C s_178_745: const #0u : u8
        let s_178_745: bool = false;
        // C s_178_746: cast zx s_178_745 -> bv
        let s_178_746: Bits = Bits::new(s_178_745 as u128, 1u16);
        // C s_178_747: const #1u : u64
        let s_178_747: u64 = 1;
        // C s_178_748: cast zx s_178_747 -> bv
        let s_178_748: Bits = Bits::new(s_178_747 as u128, 64u16);
        // C s_178_749: lsl s_178_748 s_178_742
        let s_178_749: Bits = s_178_748 << s_178_742;
        // C s_178_750: sub s_178_749 s_178_748
        let s_178_750: Bits = ((s_178_749) - (s_178_748));
        // C s_178_751: and s_178_746 s_178_750
        let s_178_751: Bits = ((s_178_746) & (s_178_750));
        // C s_178_752: lsl s_178_751 s_178_743
        let s_178_752: Bits = s_178_751 << s_178_743;
        // C s_178_753: lsl s_178_750 s_178_743
        let s_178_753: Bits = s_178_750 << s_178_743;
        // C s_178_754: cmpl s_178_753
        let s_178_754: Bits = !s_178_753;
        // D s_178_755: and s_178_744 s_178_754
        let s_178_755: Bits = ((s_178_744) & (s_178_754));
        // D s_178_756: or s_178_755 s_178_752
        let s_178_756: Bits = ((s_178_755) | (s_178_752));
        // D s_178_757: cast reint s_178_756 -> u32
        let s_178_757: u32 = (s_178_756.value() as u32);
        // D s_178_758: call Mk_DBGVCR_Type(s_178_757)
        let s_178_758: ProductType700c18a878c5601b = Mk_DBGVCR_Type(
            state,
            tracer,
            s_178_757,
        );
        // D s_178_759: call DBGVCR_write(s_178_758)
        let s_178_759: () = DBGVCR_write(state, tracer, s_178_758);
        // C s_178_760: const #() : ()
        let s_178_760: () = ();
        // S s_178_761: call ICC_EOIR0_read(s_178_760)
        let s_178_761: ProductType700c18a878c5601b = ICC_EOIR0_read(
            state,
            tracer,
            s_178_760,
        );
        // D s_178_762: write-var ga#35548 <= s_178_761
        fn_state.ga_35548 = s_178_761;
        // D s_178_763: read-var ga#35548.0:struct
        let s_178_763: u32 = fn_state.ga_35548._0;
        // C s_178_764: const #8s : i
        let s_178_764: i128 = 8;
        // C s_178_765: const #24s : i
        let s_178_765: i128 = 24;
        // D s_178_766: cast zx s_178_763 -> bv
        let s_178_766: Bits = Bits::new(s_178_763 as u128, 32u16);
        // C s_178_767: const #0u : u8
        let s_178_767: u8 = 0;
        // C s_178_768: cast zx s_178_767 -> bv
        let s_178_768: Bits = Bits::new(s_178_767 as u128, 8u16);
        // C s_178_769: const #1u : u64
        let s_178_769: u64 = 1;
        // C s_178_770: cast zx s_178_769 -> bv
        let s_178_770: Bits = Bits::new(s_178_769 as u128, 64u16);
        // C s_178_771: lsl s_178_770 s_178_764
        let s_178_771: Bits = s_178_770 << s_178_764;
        // C s_178_772: sub s_178_771 s_178_770
        let s_178_772: Bits = ((s_178_771) - (s_178_770));
        // C s_178_773: and s_178_768 s_178_772
        let s_178_773: Bits = ((s_178_768) & (s_178_772));
        // C s_178_774: lsl s_178_773 s_178_765
        let s_178_774: Bits = s_178_773 << s_178_765;
        // C s_178_775: lsl s_178_772 s_178_765
        let s_178_775: Bits = s_178_772 << s_178_765;
        // C s_178_776: cmpl s_178_775
        let s_178_776: Bits = !s_178_775;
        // D s_178_777: and s_178_766 s_178_776
        let s_178_777: Bits = ((s_178_766) & (s_178_776));
        // D s_178_778: or s_178_777 s_178_774
        let s_178_778: Bits = ((s_178_777) | (s_178_774));
        // D s_178_779: cast reint s_178_778 -> u32
        let s_178_779: u32 = (s_178_778.value() as u32);
        // D s_178_780: call Mk_ICC_EOIR0_Type(s_178_779)
        let s_178_780: ProductType700c18a878c5601b = Mk_ICC_EOIR0_Type(
            state,
            tracer,
            s_178_779,
        );
        // D s_178_781: call ICC_EOIR0_write(s_178_780)
        let s_178_781: () = ICC_EOIR0_write(state, tracer, s_178_780);
        // C s_178_782: const #() : ()
        let s_178_782: () = ();
        // S s_178_783: call ICV_BPR1_read(s_178_782)
        let s_178_783: ProductType700c18a878c5601b = ICV_BPR1_read(
            state,
            tracer,
            s_178_782,
        );
        // D s_178_784: write-var ga#35552 <= s_178_783
        fn_state.ga_35552 = s_178_783;
        // D s_178_785: read-var ga#35552.0:struct
        let s_178_785: u32 = fn_state.ga_35552._0;
        // C s_178_786: const #29s : i
        let s_178_786: i128 = 29;
        // C s_178_787: const #3s : i
        let s_178_787: i128 = 3;
        // D s_178_788: cast zx s_178_785 -> bv
        let s_178_788: Bits = Bits::new(s_178_785 as u128, 32u16);
        // C s_178_789: const #0u : u29
        let s_178_789: u32 = 0;
        // C s_178_790: cast zx s_178_789 -> bv
        let s_178_790: Bits = Bits::new(s_178_789 as u128, 29u16);
        // C s_178_791: const #1u : u64
        let s_178_791: u64 = 1;
        // C s_178_792: cast zx s_178_791 -> bv
        let s_178_792: Bits = Bits::new(s_178_791 as u128, 64u16);
        // C s_178_793: lsl s_178_792 s_178_786
        let s_178_793: Bits = s_178_792 << s_178_786;
        // C s_178_794: sub s_178_793 s_178_792
        let s_178_794: Bits = ((s_178_793) - (s_178_792));
        // C s_178_795: and s_178_790 s_178_794
        let s_178_795: Bits = ((s_178_790) & (s_178_794));
        // C s_178_796: lsl s_178_795 s_178_787
        let s_178_796: Bits = s_178_795 << s_178_787;
        // C s_178_797: lsl s_178_794 s_178_787
        let s_178_797: Bits = s_178_794 << s_178_787;
        // C s_178_798: cmpl s_178_797
        let s_178_798: Bits = !s_178_797;
        // D s_178_799: and s_178_788 s_178_798
        let s_178_799: Bits = ((s_178_788) & (s_178_798));
        // D s_178_800: or s_178_799 s_178_796
        let s_178_800: Bits = ((s_178_799) | (s_178_796));
        // D s_178_801: cast reint s_178_800 -> u32
        let s_178_801: u32 = (s_178_800.value() as u32);
        // D s_178_802: call Mk_ICV_BPR1_Type(s_178_801)
        let s_178_802: ProductType700c18a878c5601b = Mk_ICV_BPR1_Type(
            state,
            tracer,
            s_178_801,
        );
        // D s_178_803: call ICV_BPR1_write(s_178_802)
        let s_178_803: () = ICV_BPR1_write(state, tracer, s_178_802);
        // C s_178_804: const #() : ()
        let s_178_804: () = ();
        // S s_178_805: call ICC_RPR_read(s_178_804)
        let s_178_805: ProductType700c18a878c5601b = ICC_RPR_read(
            state,
            tracer,
            s_178_804,
        );
        // D s_178_806: write-var ga#35556 <= s_178_805
        fn_state.ga_35556 = s_178_805;
        // D s_178_807: read-var ga#35556.0:struct
        let s_178_807: u32 = fn_state.ga_35556._0;
        // C s_178_808: const #24s : i
        let s_178_808: i128 = 24;
        // C s_178_809: const #8s : i
        let s_178_809: i128 = 8;
        // D s_178_810: cast zx s_178_807 -> bv
        let s_178_810: Bits = Bits::new(s_178_807 as u128, 32u16);
        // C s_178_811: const #0u : u24
        let s_178_811: u32 = 0;
        // C s_178_812: cast zx s_178_811 -> bv
        let s_178_812: Bits = Bits::new(s_178_811 as u128, 24u16);
        // C s_178_813: const #1u : u64
        let s_178_813: u64 = 1;
        // C s_178_814: cast zx s_178_813 -> bv
        let s_178_814: Bits = Bits::new(s_178_813 as u128, 64u16);
        // C s_178_815: lsl s_178_814 s_178_808
        let s_178_815: Bits = s_178_814 << s_178_808;
        // C s_178_816: sub s_178_815 s_178_814
        let s_178_816: Bits = ((s_178_815) - (s_178_814));
        // C s_178_817: and s_178_812 s_178_816
        let s_178_817: Bits = ((s_178_812) & (s_178_816));
        // C s_178_818: lsl s_178_817 s_178_809
        let s_178_818: Bits = s_178_817 << s_178_809;
        // C s_178_819: lsl s_178_816 s_178_809
        let s_178_819: Bits = s_178_816 << s_178_809;
        // C s_178_820: cmpl s_178_819
        let s_178_820: Bits = !s_178_819;
        // D s_178_821: and s_178_810 s_178_820
        let s_178_821: Bits = ((s_178_810) & (s_178_820));
        // D s_178_822: or s_178_821 s_178_818
        let s_178_822: Bits = ((s_178_821) | (s_178_818));
        // D s_178_823: cast reint s_178_822 -> u32
        let s_178_823: u32 = (s_178_822.value() as u32);
        // D s_178_824: call Mk_ICC_RPR_Type(s_178_823)
        let s_178_824: ProductType700c18a878c5601b = Mk_ICC_RPR_Type(
            state,
            tracer,
            s_178_823,
        );
        // D s_178_825: call ICC_RPR_write(s_178_824)
        let s_178_825: () = ICC_RPR_write(state, tracer, s_178_824);
        // C s_178_826: const #() : ()
        let s_178_826: () = ();
        // S s_178_827: call MVFR2_read(s_178_826)
        let s_178_827: ProductType700c18a878c5601b = MVFR2_read(
            state,
            tracer,
            s_178_826,
        );
        // D s_178_828: write-var ga#35560 <= s_178_827
        fn_state.ga_35560 = s_178_827;
        // D s_178_829: read-var ga#35560.0:struct
        let s_178_829: u32 = fn_state.ga_35560._0;
        // C s_178_830: const #24s : i
        let s_178_830: i128 = 24;
        // C s_178_831: const #8s : i
        let s_178_831: i128 = 8;
        // D s_178_832: cast zx s_178_829 -> bv
        let s_178_832: Bits = Bits::new(s_178_829 as u128, 32u16);
        // C s_178_833: const #0u : u24
        let s_178_833: u32 = 0;
        // C s_178_834: cast zx s_178_833 -> bv
        let s_178_834: Bits = Bits::new(s_178_833 as u128, 24u16);
        // C s_178_835: const #1u : u64
        let s_178_835: u64 = 1;
        // C s_178_836: cast zx s_178_835 -> bv
        let s_178_836: Bits = Bits::new(s_178_835 as u128, 64u16);
        // C s_178_837: lsl s_178_836 s_178_830
        let s_178_837: Bits = s_178_836 << s_178_830;
        // C s_178_838: sub s_178_837 s_178_836
        let s_178_838: Bits = ((s_178_837) - (s_178_836));
        // C s_178_839: and s_178_834 s_178_838
        let s_178_839: Bits = ((s_178_834) & (s_178_838));
        // C s_178_840: lsl s_178_839 s_178_831
        let s_178_840: Bits = s_178_839 << s_178_831;
        // C s_178_841: lsl s_178_838 s_178_831
        let s_178_841: Bits = s_178_838 << s_178_831;
        // C s_178_842: cmpl s_178_841
        let s_178_842: Bits = !s_178_841;
        // D s_178_843: and s_178_832 s_178_842
        let s_178_843: Bits = ((s_178_832) & (s_178_842));
        // D s_178_844: or s_178_843 s_178_840
        let s_178_844: Bits = ((s_178_843) | (s_178_840));
        // D s_178_845: cast reint s_178_844 -> u32
        let s_178_845: u32 = (s_178_844.value() as u32);
        // D s_178_846: call Mk_MVFR2_Type(s_178_845)
        let s_178_846: ProductType700c18a878c5601b = Mk_MVFR2_Type(
            state,
            tracer,
            s_178_845,
        );
        // D s_178_847: call MVFR2_write(s_178_846)
        let s_178_847: () = MVFR2_write(state, tracer, s_178_846);
        // C s_178_848: const #19992u : u32
        let s_178_848: u32 = 19992;
        // D s_178_849: read-reg s_178_848:struct
        let s_178_849: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_178_848 as isize);
            tracer.read_register(s_178_848 as isize, value);
            value
        };
        // C s_178_850: const #19992u : u32
        let s_178_850: u32 = 19992;
        // N s_178_851: write-reg s_178_850 <= s_178_849
        let s_178_851: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_178_850 as isize, s_178_849);
            tracer.write_register(s_178_850 as isize, s_178_849);
        };
        // C s_178_852: const #19992u : u32
        let s_178_852: u32 = 19992;
        // D s_178_853: read-reg s_178_852:struct
        let s_178_853: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_178_852 as isize);
            tracer.read_register(s_178_852 as isize, value);
            value
        };
        // C s_178_854: const #19992u : u32
        let s_178_854: u32 = 19992;
        // N s_178_855: write-reg s_178_854 <= s_178_853
        let s_178_855: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_178_854 as isize, s_178_853);
            tracer.write_register(s_178_854 as isize, s_178_853);
        };
        // C s_178_856: const #19992u : u32
        let s_178_856: u32 = 19992;
        // D s_178_857: read-reg s_178_856:struct
        let s_178_857: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_178_856 as isize);
            tracer.read_register(s_178_856 as isize, value);
            value
        };
        // C s_178_858: const #19992u : u32
        let s_178_858: u32 = 19992;
        // N s_178_859: write-reg s_178_858 <= s_178_857
        let s_178_859: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_178_858 as isize, s_178_857);
            tracer.write_register(s_178_858 as isize, s_178_857);
        };
        // C s_178_860: const #19992u : u32
        let s_178_860: u32 = 19992;
        // D s_178_861: read-reg s_178_860:struct
        let s_178_861: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_178_860 as isize);
            tracer.read_register(s_178_860 as isize, value);
            value
        };
        // C s_178_862: const #19992u : u32
        let s_178_862: u32 = 19992;
        // N s_178_863: write-reg s_178_862 <= s_178_861
        let s_178_863: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_178_862 as isize, s_178_861);
            tracer.write_register(s_178_862 as isize, s_178_861);
        };
        // C s_178_864: const #11640u : u32
        let s_178_864: u32 = 11640;
        // D s_178_865: read-reg s_178_864:struct
        let s_178_865: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_178_864 as isize);
            tracer.read_register(s_178_864 as isize, value);
            value
        };
        // C s_178_866: const #11640u : u32
        let s_178_866: u32 = 11640;
        // N s_178_867: write-reg s_178_866 <= s_178_865
        let s_178_867: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_178_866 as isize, s_178_865);
            tracer.write_register(s_178_866 as isize, s_178_865);
        };
        // C s_178_868: const #() : ()
        let s_178_868: () = ();
        // S s_178_869: call VMPIDR_read(s_178_868)
        let s_178_869: ProductType700c18a878c5601b = VMPIDR_read(
            state,
            tracer,
            s_178_868,
        );
        // C s_178_870: const #1s : i64
        let s_178_870: i64 = 1;
        // C s_178_871: cast zx s_178_870 -> i
        let s_178_871: i128 = (i128::try_from(s_178_870).unwrap());
        // S s_178_872: call __UNKNOWN_bits(s_178_871)
        let s_178_872: Bits = u__UNKNOWN_bits(state, tracer, s_178_871);
        // S s_178_873: cast reint s_178_872 -> u8
        let s_178_873: bool = ((s_178_872.value()) != 0);
        // S s_178_874: call _update_VMPIDR_Type_U(s_178_869, s_178_873)
        let s_178_874: ProductType700c18a878c5601b = u_update_VMPIDR_Type_U(
            state,
            tracer,
            s_178_869,
            s_178_873,
        );
        // S s_178_875: call VMPIDR_write(s_178_874)
        let s_178_875: () = VMPIDR_write(state, tracer, s_178_874);
        // C s_178_876: const #() : ()
        let s_178_876: () = ();
        // S s_178_877: call VMPIDR_read(s_178_876)
        let s_178_877: ProductType700c18a878c5601b = VMPIDR_read(
            state,
            tracer,
            s_178_876,
        );
        // D s_178_878: write-var ga#35578 <= s_178_877
        fn_state.ga_35578 = s_178_877;
        // D s_178_879: read-var ga#35578.0:struct
        let s_178_879: u32 = fn_state.ga_35578._0;
        // C s_178_880: const #5s : i
        let s_178_880: i128 = 5;
        // C s_178_881: const #25s : i
        let s_178_881: i128 = 25;
        // D s_178_882: cast zx s_178_879 -> bv
        let s_178_882: Bits = Bits::new(s_178_879 as u128, 32u16);
        // C s_178_883: const #0u : u8
        let s_178_883: u8 = 0;
        // C s_178_884: cast zx s_178_883 -> bv
        let s_178_884: Bits = Bits::new(s_178_883 as u128, 5u16);
        // C s_178_885: const #1u : u64
        let s_178_885: u64 = 1;
        // C s_178_886: cast zx s_178_885 -> bv
        let s_178_886: Bits = Bits::new(s_178_885 as u128, 64u16);
        // C s_178_887: lsl s_178_886 s_178_880
        let s_178_887: Bits = s_178_886 << s_178_880;
        // C s_178_888: sub s_178_887 s_178_886
        let s_178_888: Bits = ((s_178_887) - (s_178_886));
        // C s_178_889: and s_178_884 s_178_888
        let s_178_889: Bits = ((s_178_884) & (s_178_888));
        // C s_178_890: lsl s_178_889 s_178_881
        let s_178_890: Bits = s_178_889 << s_178_881;
        // C s_178_891: lsl s_178_888 s_178_881
        let s_178_891: Bits = s_178_888 << s_178_881;
        // C s_178_892: cmpl s_178_891
        let s_178_892: Bits = !s_178_891;
        // D s_178_893: and s_178_882 s_178_892
        let s_178_893: Bits = ((s_178_882) & (s_178_892));
        // D s_178_894: or s_178_893 s_178_890
        let s_178_894: Bits = ((s_178_893) | (s_178_890));
        // D s_178_895: cast reint s_178_894 -> u32
        let s_178_895: u32 = (s_178_894.value() as u32);
        // D s_178_896: call Mk_VMPIDR_Type(s_178_895)
        let s_178_896: ProductType700c18a878c5601b = Mk_VMPIDR_Type(
            state,
            tracer,
            s_178_895,
        );
        // D s_178_897: call VMPIDR_write(s_178_896)
        let s_178_897: () = VMPIDR_write(state, tracer, s_178_896);
        // C s_178_898: const #() : ()
        let s_178_898: () = ();
        // S s_178_899: call VMPIDR_read(s_178_898)
        let s_178_899: ProductType700c18a878c5601b = VMPIDR_read(
            state,
            tracer,
            s_178_898,
        );
        // C s_178_900: const #1s : i64
        let s_178_900: i64 = 1;
        // C s_178_901: cast zx s_178_900 -> i
        let s_178_901: i128 = (i128::try_from(s_178_900).unwrap());
        // S s_178_902: call __UNKNOWN_bits(s_178_901)
        let s_178_902: Bits = u__UNKNOWN_bits(state, tracer, s_178_901);
        // S s_178_903: cast reint s_178_902 -> u8
        let s_178_903: bool = ((s_178_902.value()) != 0);
        // S s_178_904: call _update_VMPIDR_Type_MT(s_178_899, s_178_903)
        let s_178_904: ProductType700c18a878c5601b = u_update_VMPIDR_Type_MT(
            state,
            tracer,
            s_178_899,
            s_178_903,
        );
        // S s_178_905: call VMPIDR_write(s_178_904)
        let s_178_905: () = VMPIDR_write(state, tracer, s_178_904);
        // C s_178_906: const #() : ()
        let s_178_906: () = ();
        // S s_178_907: call VMPIDR_read(s_178_906)
        let s_178_907: ProductType700c18a878c5601b = VMPIDR_read(
            state,
            tracer,
            s_178_906,
        );
        // C s_178_908: const #8s : i64
        let s_178_908: i64 = 8;
        // C s_178_909: cast zx s_178_908 -> i
        let s_178_909: i128 = (i128::try_from(s_178_908).unwrap());
        // S s_178_910: call __UNKNOWN_bits(s_178_909)
        let s_178_910: Bits = u__UNKNOWN_bits(state, tracer, s_178_909);
        // S s_178_911: cast reint s_178_910 -> u8
        let s_178_911: u8 = (s_178_910.value() as u8);
        // S s_178_912: call _update_VMPIDR_Type_Aff2(s_178_907, s_178_911)
        let s_178_912: ProductType700c18a878c5601b = u_update_VMPIDR_Type_Aff2(
            state,
            tracer,
            s_178_907,
            s_178_911,
        );
        // S s_178_913: call VMPIDR_write(s_178_912)
        let s_178_913: () = VMPIDR_write(state, tracer, s_178_912);
        // C s_178_914: const #() : ()
        let s_178_914: () = ();
        // S s_178_915: call VMPIDR_read(s_178_914)
        let s_178_915: ProductType700c18a878c5601b = VMPIDR_read(
            state,
            tracer,
            s_178_914,
        );
        // C s_178_916: const #8s : i64
        let s_178_916: i64 = 8;
        // C s_178_917: cast zx s_178_916 -> i
        let s_178_917: i128 = (i128::try_from(s_178_916).unwrap());
        // S s_178_918: call __UNKNOWN_bits(s_178_917)
        let s_178_918: Bits = u__UNKNOWN_bits(state, tracer, s_178_917);
        // S s_178_919: cast reint s_178_918 -> u8
        let s_178_919: u8 = (s_178_918.value() as u8);
        // S s_178_920: call _update_VMPIDR_Type_Aff1(s_178_915, s_178_919)
        let s_178_920: ProductType700c18a878c5601b = u_update_VMPIDR_Type_Aff1(
            state,
            tracer,
            s_178_915,
            s_178_919,
        );
        // S s_178_921: call VMPIDR_write(s_178_920)
        let s_178_921: () = VMPIDR_write(state, tracer, s_178_920);
        // C s_178_922: const #() : ()
        let s_178_922: () = ();
        // S s_178_923: call VMPIDR_read(s_178_922)
        let s_178_923: ProductType700c18a878c5601b = VMPIDR_read(
            state,
            tracer,
            s_178_922,
        );
        // C s_178_924: const #8s : i64
        let s_178_924: i64 = 8;
        // C s_178_925: cast zx s_178_924 -> i
        let s_178_925: i128 = (i128::try_from(s_178_924).unwrap());
        // S s_178_926: call __UNKNOWN_bits(s_178_925)
        let s_178_926: Bits = u__UNKNOWN_bits(state, tracer, s_178_925);
        // S s_178_927: cast reint s_178_926 -> u8
        let s_178_927: u8 = (s_178_926.value() as u8);
        // S s_178_928: call _update_VMPIDR_Type_Aff0(s_178_923, s_178_927)
        let s_178_928: ProductType700c18a878c5601b = u_update_VMPIDR_Type_Aff0(
            state,
            tracer,
            s_178_923,
            s_178_927,
        );
        // S s_178_929: call VMPIDR_write(s_178_928)
        let s_178_929: () = VMPIDR_write(state, tracer, s_178_928);
        // C s_178_930: const #() : ()
        let s_178_930: () = ();
        // S s_178_931: call ICC_IGRPEN1_read(s_178_930)
        let s_178_931: ProductType700c18a878c5601b = ICC_IGRPEN1_read(
            state,
            tracer,
            s_178_930,
        );
        // D s_178_932: write-var ga#35598 <= s_178_931
        fn_state.ga_35598 = s_178_931;
        // D s_178_933: read-var ga#35598.0:struct
        let s_178_933: u32 = fn_state.ga_35598._0;
        // C s_178_934: const #31s : i
        let s_178_934: i128 = 31;
        // C s_178_935: const #1s : i
        let s_178_935: i128 = 1;
        // D s_178_936: cast zx s_178_933 -> bv
        let s_178_936: Bits = Bits::new(s_178_933 as u128, 32u16);
        // C s_178_937: const #0u : u31
        let s_178_937: u32 = 0;
        // C s_178_938: cast zx s_178_937 -> bv
        let s_178_938: Bits = Bits::new(s_178_937 as u128, 31u16);
        // C s_178_939: const #1u : u64
        let s_178_939: u64 = 1;
        // C s_178_940: cast zx s_178_939 -> bv
        let s_178_940: Bits = Bits::new(s_178_939 as u128, 64u16);
        // C s_178_941: lsl s_178_940 s_178_934
        let s_178_941: Bits = s_178_940 << s_178_934;
        // C s_178_942: sub s_178_941 s_178_940
        let s_178_942: Bits = ((s_178_941) - (s_178_940));
        // C s_178_943: and s_178_938 s_178_942
        let s_178_943: Bits = ((s_178_938) & (s_178_942));
        // C s_178_944: lsl s_178_943 s_178_935
        let s_178_944: Bits = s_178_943 << s_178_935;
        // C s_178_945: lsl s_178_942 s_178_935
        let s_178_945: Bits = s_178_942 << s_178_935;
        // C s_178_946: cmpl s_178_945
        let s_178_946: Bits = !s_178_945;
        // D s_178_947: and s_178_936 s_178_946
        let s_178_947: Bits = ((s_178_936) & (s_178_946));
        // D s_178_948: or s_178_947 s_178_944
        let s_178_948: Bits = ((s_178_947) | (s_178_944));
        // D s_178_949: cast reint s_178_948 -> u32
        let s_178_949: u32 = (s_178_948.value() as u32);
        // D s_178_950: call Mk_ICC_IGRPEN1_Type(s_178_949)
        let s_178_950: ProductType700c18a878c5601b = Mk_ICC_IGRPEN1_Type(
            state,
            tracer,
            s_178_949,
        );
        // D s_178_951: call ICC_IGRPEN1_write(s_178_950)
        let s_178_951: () = ICC_IGRPEN1_write(state, tracer, s_178_950);
        // C s_178_952: const #() : ()
        let s_178_952: () = ();
        // S s_178_953: call ICC_IGRPEN1_read(s_178_952)
        let s_178_953: ProductType700c18a878c5601b = ICC_IGRPEN1_read(
            state,
            tracer,
            s_178_952,
        );
        // C s_178_954: const #0u : u8
        let s_178_954: bool = false;
        // S s_178_955: call _update_ICC_IGRPEN1_Type_Enable(s_178_953, s_178_954)
        let s_178_955: ProductType700c18a878c5601b = u_update_ICC_IGRPEN1_Type_Enable(
            state,
            tracer,
            s_178_953,
            s_178_954,
        );
        // S s_178_956: call ICC_IGRPEN1_write(s_178_955)
        let s_178_956: () = ICC_IGRPEN1_write(state, tracer, s_178_955);
        // C s_178_957: const #() : ()
        let s_178_957: () = ();
        // S s_178_958: call HVBAR_read(s_178_957)
        let s_178_958: u32 = HVBAR_read(state, tracer, s_178_957);
        // C s_178_959: const #5s : i
        let s_178_959: i128 = 5;
        // C s_178_960: const #0s : i
        let s_178_960: i128 = 0;
        // S s_178_961: cast zx s_178_958 -> bv
        let s_178_961: Bits = Bits::new(s_178_958 as u128, 32u16);
        // C s_178_962: const #0u : u8
        let s_178_962: u8 = 0;
        // C s_178_963: cast zx s_178_962 -> bv
        let s_178_963: Bits = Bits::new(s_178_962 as u128, 5u16);
        // C s_178_964: const #1u : u64
        let s_178_964: u64 = 1;
        // C s_178_965: cast zx s_178_964 -> bv
        let s_178_965: Bits = Bits::new(s_178_964 as u128, 64u16);
        // C s_178_966: lsl s_178_965 s_178_959
        let s_178_966: Bits = s_178_965 << s_178_959;
        // C s_178_967: sub s_178_966 s_178_965
        let s_178_967: Bits = ((s_178_966) - (s_178_965));
        // C s_178_968: and s_178_963 s_178_967
        let s_178_968: Bits = ((s_178_963) & (s_178_967));
        // C s_178_969: lsl s_178_968 s_178_960
        let s_178_969: Bits = s_178_968 << s_178_960;
        // C s_178_970: lsl s_178_967 s_178_960
        let s_178_970: Bits = s_178_967 << s_178_960;
        // C s_178_971: cmpl s_178_970
        let s_178_971: Bits = !s_178_970;
        // S s_178_972: and s_178_961 s_178_971
        let s_178_972: Bits = ((s_178_961) & (s_178_971));
        // S s_178_973: or s_178_972 s_178_969
        let s_178_973: Bits = ((s_178_972) | (s_178_969));
        // S s_178_974: cast reint s_178_973 -> u32
        let s_178_974: u32 = (s_178_973.value() as u32);
        // S s_178_975: call HVBAR_write(s_178_974)
        let s_178_975: () = HVBAR_write(state, tracer, s_178_974);
        // C s_178_976: const #() : ()
        let s_178_976: () = ();
        // S s_178_977: call HSTR_read(s_178_976)
        let s_178_977: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_178_976);
        // D s_178_978: write-var ga#35606 <= s_178_977
        fn_state.ga_35606 = s_178_977;
        // D s_178_979: read-var ga#35606.0:struct
        let s_178_979: u32 = fn_state.ga_35606._0;
        // C s_178_980: const #2s : i
        let s_178_980: i128 = 2;
        // C s_178_981: const #16s : i
        let s_178_981: i128 = 16;
        // C s_178_982: const #0u : u18
        let s_178_982: u32 = 0;
        // C s_178_983: cast zx s_178_982 -> bv
        let s_178_983: Bits = Bits::new(s_178_982 as u128, 18u16);
        // D s_178_984: bit-extract s_178_983 s_178_980 s_178_981
        let s_178_984: Bits = (Bits::new(
            ((s_178_983) >> (s_178_980)).value(),
            u16::try_from(s_178_981).unwrap(),
        ));
        // D s_178_985: cast reint s_178_984 -> u16
        let s_178_985: u16 = (s_178_984.value() as u16);
        // C s_178_986: const #16s : i
        let s_178_986: i128 = 16;
        // C s_178_987: const #16s : i
        let s_178_987: i128 = 16;
        // D s_178_988: cast zx s_178_979 -> bv
        let s_178_988: Bits = Bits::new(s_178_979 as u128, 32u16);
        // D s_178_989: cast zx s_178_985 -> bv
        let s_178_989: Bits = Bits::new(s_178_985 as u128, 16u16);
        // C s_178_990: const #1u : u64
        let s_178_990: u64 = 1;
        // C s_178_991: cast zx s_178_990 -> bv
        let s_178_991: Bits = Bits::new(s_178_990 as u128, 64u16);
        // C s_178_992: lsl s_178_991 s_178_986
        let s_178_992: Bits = s_178_991 << s_178_986;
        // C s_178_993: sub s_178_992 s_178_991
        let s_178_993: Bits = ((s_178_992) - (s_178_991));
        // D s_178_994: and s_178_989 s_178_993
        let s_178_994: Bits = ((s_178_989) & (s_178_993));
        // D s_178_995: lsl s_178_994 s_178_987
        let s_178_995: Bits = s_178_994 << s_178_987;
        // C s_178_996: lsl s_178_993 s_178_987
        let s_178_996: Bits = s_178_993 << s_178_987;
        // C s_178_997: cmpl s_178_996
        let s_178_997: Bits = !s_178_996;
        // D s_178_998: and s_178_988 s_178_997
        let s_178_998: Bits = ((s_178_988) & (s_178_997));
        // D s_178_999: or s_178_998 s_178_995
        let s_178_999: Bits = ((s_178_998) | (s_178_995));
        // D s_178_1000: cast reint s_178_999 -> u32
        let s_178_1000: u32 = (s_178_999.value() as u32);
        // D s_178_1001: call Mk_HSTR_Type(s_178_1000)
        let s_178_1001: ProductType700c18a878c5601b = Mk_HSTR_Type(
            state,
            tracer,
            s_178_1000,
        );
        // D s_178_1002: call HSTR_write(s_178_1001)
        let s_178_1002: () = HSTR_write(state, tracer, s_178_1001);
        // C s_178_1003: const #() : ()
        let s_178_1003: () = ();
        // S s_178_1004: call HSTR_read(s_178_1003)
        let s_178_1004: ProductType700c18a878c5601b = HSTR_read(
            state,
            tracer,
            s_178_1003,
        );
        // D s_178_1005: write-var ga#35611 <= s_178_1004
        fn_state.ga_35611 = s_178_1004;
        // D s_178_1006: read-var ga#35611.0:struct
        let s_178_1006: u32 = fn_state.ga_35611._0;
        // C s_178_1007: const #1s : i
        let s_178_1007: i128 = 1;
        // C s_178_1008: const #1s : i
        let s_178_1008: i128 = 1;
        // C s_178_1009: const #0u : u18
        let s_178_1009: u32 = 0;
        // C s_178_1010: cast zx s_178_1009 -> bv
        let s_178_1010: Bits = Bits::new(s_178_1009 as u128, 18u16);
        // D s_178_1011: bit-extract s_178_1010 s_178_1007 s_178_1008
        let s_178_1011: Bits = (Bits::new(
            ((s_178_1010) >> (s_178_1007)).value(),
            u16::try_from(s_178_1008).unwrap(),
        ));
        // D s_178_1012: cast reint s_178_1011 -> u8
        let s_178_1012: bool = ((s_178_1011.value()) != 0);
        // C s_178_1013: const #1s : i
        let s_178_1013: i128 = 1;
        // C s_178_1014: const #14s : i
        let s_178_1014: i128 = 14;
        // D s_178_1015: cast zx s_178_1006 -> bv
        let s_178_1015: Bits = Bits::new(s_178_1006 as u128, 32u16);
        // D s_178_1016: cast zx s_178_1012 -> bv
        let s_178_1016: Bits = Bits::new(s_178_1012 as u128, 1u16);
        // C s_178_1017: const #1u : u64
        let s_178_1017: u64 = 1;
        // C s_178_1018: cast zx s_178_1017 -> bv
        let s_178_1018: Bits = Bits::new(s_178_1017 as u128, 64u16);
        // C s_178_1019: lsl s_178_1018 s_178_1013
        let s_178_1019: Bits = s_178_1018 << s_178_1013;
        // C s_178_1020: sub s_178_1019 s_178_1018
        let s_178_1020: Bits = ((s_178_1019) - (s_178_1018));
        // D s_178_1021: and s_178_1016 s_178_1020
        let s_178_1021: Bits = ((s_178_1016) & (s_178_1020));
        // D s_178_1022: lsl s_178_1021 s_178_1014
        let s_178_1022: Bits = s_178_1021 << s_178_1014;
        // C s_178_1023: lsl s_178_1020 s_178_1014
        let s_178_1023: Bits = s_178_1020 << s_178_1014;
        // C s_178_1024: cmpl s_178_1023
        let s_178_1024: Bits = !s_178_1023;
        // D s_178_1025: and s_178_1015 s_178_1024
        let s_178_1025: Bits = ((s_178_1015) & (s_178_1024));
        // D s_178_1026: or s_178_1025 s_178_1022
        let s_178_1026: Bits = ((s_178_1025) | (s_178_1022));
        // D s_178_1027: cast reint s_178_1026 -> u32
        let s_178_1027: u32 = (s_178_1026.value() as u32);
        // D s_178_1028: call Mk_HSTR_Type(s_178_1027)
        let s_178_1028: ProductType700c18a878c5601b = Mk_HSTR_Type(
            state,
            tracer,
            s_178_1027,
        );
        // D s_178_1029: call HSTR_write(s_178_1028)
        let s_178_1029: () = HSTR_write(state, tracer, s_178_1028);
        // C s_178_1030: const #() : ()
        let s_178_1030: () = ();
        // S s_178_1031: call HSTR_read(s_178_1030)
        let s_178_1031: ProductType700c18a878c5601b = HSTR_read(
            state,
            tracer,
            s_178_1030,
        );
        // D s_178_1032: write-var ga#35616 <= s_178_1031
        fn_state.ga_35616 = s_178_1031;
        // D s_178_1033: read-var ga#35616.0:struct
        let s_178_1033: u32 = fn_state.ga_35616._0;
        // C s_178_1034: const #0s : i
        let s_178_1034: i128 = 0;
        // C s_178_1035: const #1s : i
        let s_178_1035: i128 = 1;
        // C s_178_1036: const #0u : u18
        let s_178_1036: u32 = 0;
        // C s_178_1037: cast zx s_178_1036 -> bv
        let s_178_1037: Bits = Bits::new(s_178_1036 as u128, 18u16);
        // D s_178_1038: bit-extract s_178_1037 s_178_1034 s_178_1035
        let s_178_1038: Bits = (Bits::new(
            ((s_178_1037) >> (s_178_1034)).value(),
            u16::try_from(s_178_1035).unwrap(),
        ));
        // D s_178_1039: cast reint s_178_1038 -> u8
        let s_178_1039: bool = ((s_178_1038.value()) != 0);
        // C s_178_1040: const #1s : i
        let s_178_1040: i128 = 1;
        // C s_178_1041: const #4s : i
        let s_178_1041: i128 = 4;
        // D s_178_1042: cast zx s_178_1033 -> bv
        let s_178_1042: Bits = Bits::new(s_178_1033 as u128, 32u16);
        // D s_178_1043: cast zx s_178_1039 -> bv
        let s_178_1043: Bits = Bits::new(s_178_1039 as u128, 1u16);
        // C s_178_1044: const #1u : u64
        let s_178_1044: u64 = 1;
        // C s_178_1045: cast zx s_178_1044 -> bv
        let s_178_1045: Bits = Bits::new(s_178_1044 as u128, 64u16);
        // C s_178_1046: lsl s_178_1045 s_178_1040
        let s_178_1046: Bits = s_178_1045 << s_178_1040;
        // C s_178_1047: sub s_178_1046 s_178_1045
        let s_178_1047: Bits = ((s_178_1046) - (s_178_1045));
        // D s_178_1048: and s_178_1043 s_178_1047
        let s_178_1048: Bits = ((s_178_1043) & (s_178_1047));
        // D s_178_1049: lsl s_178_1048 s_178_1041
        let s_178_1049: Bits = s_178_1048 << s_178_1041;
        // C s_178_1050: lsl s_178_1047 s_178_1041
        let s_178_1050: Bits = s_178_1047 << s_178_1041;
        // C s_178_1051: cmpl s_178_1050
        let s_178_1051: Bits = !s_178_1050;
        // D s_178_1052: and s_178_1042 s_178_1051
        let s_178_1052: Bits = ((s_178_1042) & (s_178_1051));
        // D s_178_1053: or s_178_1052 s_178_1049
        let s_178_1053: Bits = ((s_178_1052) | (s_178_1049));
        // D s_178_1054: cast reint s_178_1053 -> u32
        let s_178_1054: u32 = (s_178_1053.value() as u32);
        // D s_178_1055: call Mk_HSTR_Type(s_178_1054)
        let s_178_1055: ProductType700c18a878c5601b = Mk_HSTR_Type(
            state,
            tracer,
            s_178_1054,
        );
        // D s_178_1056: call HSTR_write(s_178_1055)
        let s_178_1056: () = HSTR_write(state, tracer, s_178_1055);
        // D s_178_1057: read-var cold:u8
        let s_178_1057: bool = fn_state.cold;
        // D s_178_1058: not s_178_1057
        let s_178_1058: bool = !s_178_1057;
        // N s_178_1059: branch s_178_1058 b562 b179
        if s_178_1058 {
            return block_562(state, tracer, fn_state);
        } else {
            return block_179(state, tracer, fn_state);
        };
    }
    fn block_179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_179_0: const #0u : u8
        let s_179_0: bool = false;
        // D s_179_1: write-var gs#44281 <= s_179_0
        fn_state.gs_44281 = s_179_0;
        // N s_179_2: jump b180
        return block_180(state, tracer, fn_state);
    }
    fn block_180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_180_0: read-var gs#44281:u8
        let s_180_0: bool = fn_state.gs_44281;
        // N s_180_1: branch s_180_0 b561 b181
        if s_180_0 {
            return block_561(state, tracer, fn_state);
        } else {
            return block_181(state, tracer, fn_state);
        };
    }
    fn block_181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_181_0: const #() : ()
        let s_181_0: () = ();
        // S s_181_1: call HSTR_read(s_181_0)
        let s_181_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_181_0);
        // C s_181_2: const #1s : i64
        let s_181_2: i64 = 1;
        // C s_181_3: cast zx s_181_2 -> i
        let s_181_3: i128 = (i128::try_from(s_181_2).unwrap());
        // S s_181_4: call __UNKNOWN_bits(s_181_3)
        let s_181_4: Bits = u__UNKNOWN_bits(state, tracer, s_181_3);
        // S s_181_5: cast reint s_181_4 -> u8
        let s_181_5: bool = ((s_181_4.value()) != 0);
        // S s_181_6: call _update_HSTR_Type_T15(s_181_1, s_181_5)
        let s_181_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T15(
            state,
            tracer,
            s_181_1,
            s_181_5,
        );
        // S s_181_7: call HSTR_write(s_181_6)
        let s_181_7: () = HSTR_write(state, tracer, s_181_6);
        // N s_181_8: jump b182
        return block_182(state, tracer, fn_state);
    }
    fn block_182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_182_0: read-var cold:u8
        let s_182_0: bool = fn_state.cold;
        // D s_182_1: not s_182_0
        let s_182_1: bool = !s_182_0;
        // N s_182_2: branch s_182_1 b560 b183
        if s_182_1 {
            return block_560(state, tracer, fn_state);
        } else {
            return block_183(state, tracer, fn_state);
        };
    }
    fn block_183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_183_0: const #0u : u8
        let s_183_0: bool = false;
        // D s_183_1: write-var gs#44282 <= s_183_0
        fn_state.gs_44282 = s_183_0;
        // N s_183_2: jump b184
        return block_184(state, tracer, fn_state);
    }
    fn block_184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_184_0: read-var gs#44282:u8
        let s_184_0: bool = fn_state.gs_44282;
        // N s_184_1: branch s_184_0 b559 b185
        if s_184_0 {
            return block_559(state, tracer, fn_state);
        } else {
            return block_185(state, tracer, fn_state);
        };
    }
    fn block_185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_185_0: const #() : ()
        let s_185_0: () = ();
        // S s_185_1: call HSTR_read(s_185_0)
        let s_185_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_185_0);
        // C s_185_2: const #1s : i64
        let s_185_2: i64 = 1;
        // C s_185_3: cast zx s_185_2 -> i
        let s_185_3: i128 = (i128::try_from(s_185_2).unwrap());
        // S s_185_4: call __UNKNOWN_bits(s_185_3)
        let s_185_4: Bits = u__UNKNOWN_bits(state, tracer, s_185_3);
        // S s_185_5: cast reint s_185_4 -> u8
        let s_185_5: bool = ((s_185_4.value()) != 0);
        // S s_185_6: call _update_HSTR_Type_T13(s_185_1, s_185_5)
        let s_185_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T13(
            state,
            tracer,
            s_185_1,
            s_185_5,
        );
        // S s_185_7: call HSTR_write(s_185_6)
        let s_185_7: () = HSTR_write(state, tracer, s_185_6);
        // N s_185_8: jump b186
        return block_186(state, tracer, fn_state);
    }
    fn block_186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_186_0: read-var cold:u8
        let s_186_0: bool = fn_state.cold;
        // D s_186_1: not s_186_0
        let s_186_1: bool = !s_186_0;
        // N s_186_2: branch s_186_1 b558 b187
        if s_186_1 {
            return block_558(state, tracer, fn_state);
        } else {
            return block_187(state, tracer, fn_state);
        };
    }
    fn block_187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_187_0: const #0u : u8
        let s_187_0: bool = false;
        // D s_187_1: write-var gs#44283 <= s_187_0
        fn_state.gs_44283 = s_187_0;
        // N s_187_2: jump b188
        return block_188(state, tracer, fn_state);
    }
    fn block_188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_188_0: read-var gs#44283:u8
        let s_188_0: bool = fn_state.gs_44283;
        // N s_188_1: branch s_188_0 b557 b189
        if s_188_0 {
            return block_557(state, tracer, fn_state);
        } else {
            return block_189(state, tracer, fn_state);
        };
    }
    fn block_189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_189_0: const #() : ()
        let s_189_0: () = ();
        // S s_189_1: call HSTR_read(s_189_0)
        let s_189_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_189_0);
        // C s_189_2: const #1s : i64
        let s_189_2: i64 = 1;
        // C s_189_3: cast zx s_189_2 -> i
        let s_189_3: i128 = (i128::try_from(s_189_2).unwrap());
        // S s_189_4: call __UNKNOWN_bits(s_189_3)
        let s_189_4: Bits = u__UNKNOWN_bits(state, tracer, s_189_3);
        // S s_189_5: cast reint s_189_4 -> u8
        let s_189_5: bool = ((s_189_4.value()) != 0);
        // S s_189_6: call _update_HSTR_Type_T12(s_189_1, s_189_5)
        let s_189_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T12(
            state,
            tracer,
            s_189_1,
            s_189_5,
        );
        // S s_189_7: call HSTR_write(s_189_6)
        let s_189_7: () = HSTR_write(state, tracer, s_189_6);
        // N s_189_8: jump b190
        return block_190(state, tracer, fn_state);
    }
    fn block_190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_190_0: read-var cold:u8
        let s_190_0: bool = fn_state.cold;
        // D s_190_1: not s_190_0
        let s_190_1: bool = !s_190_0;
        // N s_190_2: branch s_190_1 b556 b191
        if s_190_1 {
            return block_556(state, tracer, fn_state);
        } else {
            return block_191(state, tracer, fn_state);
        };
    }
    fn block_191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_191_0: const #0u : u8
        let s_191_0: bool = false;
        // D s_191_1: write-var gs#44284 <= s_191_0
        fn_state.gs_44284 = s_191_0;
        // N s_191_2: jump b192
        return block_192(state, tracer, fn_state);
    }
    fn block_192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_192_0: read-var gs#44284:u8
        let s_192_0: bool = fn_state.gs_44284;
        // N s_192_1: branch s_192_0 b555 b193
        if s_192_0 {
            return block_555(state, tracer, fn_state);
        } else {
            return block_193(state, tracer, fn_state);
        };
    }
    fn block_193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_193_0: const #() : ()
        let s_193_0: () = ();
        // S s_193_1: call HSTR_read(s_193_0)
        let s_193_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_193_0);
        // C s_193_2: const #1s : i64
        let s_193_2: i64 = 1;
        // C s_193_3: cast zx s_193_2 -> i
        let s_193_3: i128 = (i128::try_from(s_193_2).unwrap());
        // S s_193_4: call __UNKNOWN_bits(s_193_3)
        let s_193_4: Bits = u__UNKNOWN_bits(state, tracer, s_193_3);
        // S s_193_5: cast reint s_193_4 -> u8
        let s_193_5: bool = ((s_193_4.value()) != 0);
        // S s_193_6: call _update_HSTR_Type_T11(s_193_1, s_193_5)
        let s_193_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T11(
            state,
            tracer,
            s_193_1,
            s_193_5,
        );
        // S s_193_7: call HSTR_write(s_193_6)
        let s_193_7: () = HSTR_write(state, tracer, s_193_6);
        // N s_193_8: jump b194
        return block_194(state, tracer, fn_state);
    }
    fn block_194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_194_0: read-var cold:u8
        let s_194_0: bool = fn_state.cold;
        // D s_194_1: not s_194_0
        let s_194_1: bool = !s_194_0;
        // N s_194_2: branch s_194_1 b554 b195
        if s_194_1 {
            return block_554(state, tracer, fn_state);
        } else {
            return block_195(state, tracer, fn_state);
        };
    }
    fn block_195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_195_0: const #0u : u8
        let s_195_0: bool = false;
        // D s_195_1: write-var gs#44285 <= s_195_0
        fn_state.gs_44285 = s_195_0;
        // N s_195_2: jump b196
        return block_196(state, tracer, fn_state);
    }
    fn block_196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_196_0: read-var gs#44285:u8
        let s_196_0: bool = fn_state.gs_44285;
        // N s_196_1: branch s_196_0 b553 b197
        if s_196_0 {
            return block_553(state, tracer, fn_state);
        } else {
            return block_197(state, tracer, fn_state);
        };
    }
    fn block_197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_197_0: const #() : ()
        let s_197_0: () = ();
        // S s_197_1: call HSTR_read(s_197_0)
        let s_197_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_197_0);
        // C s_197_2: const #1s : i64
        let s_197_2: i64 = 1;
        // C s_197_3: cast zx s_197_2 -> i
        let s_197_3: i128 = (i128::try_from(s_197_2).unwrap());
        // S s_197_4: call __UNKNOWN_bits(s_197_3)
        let s_197_4: Bits = u__UNKNOWN_bits(state, tracer, s_197_3);
        // S s_197_5: cast reint s_197_4 -> u8
        let s_197_5: bool = ((s_197_4.value()) != 0);
        // S s_197_6: call _update_HSTR_Type_T10(s_197_1, s_197_5)
        let s_197_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T10(
            state,
            tracer,
            s_197_1,
            s_197_5,
        );
        // S s_197_7: call HSTR_write(s_197_6)
        let s_197_7: () = HSTR_write(state, tracer, s_197_6);
        // N s_197_8: jump b198
        return block_198(state, tracer, fn_state);
    }
    fn block_198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_198_0: read-var cold:u8
        let s_198_0: bool = fn_state.cold;
        // D s_198_1: not s_198_0
        let s_198_1: bool = !s_198_0;
        // N s_198_2: branch s_198_1 b552 b199
        if s_198_1 {
            return block_552(state, tracer, fn_state);
        } else {
            return block_199(state, tracer, fn_state);
        };
    }
    fn block_199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_199_0: const #0u : u8
        let s_199_0: bool = false;
        // D s_199_1: write-var gs#44286 <= s_199_0
        fn_state.gs_44286 = s_199_0;
        // N s_199_2: jump b200
        return block_200(state, tracer, fn_state);
    }
    fn block_200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_200_0: read-var gs#44286:u8
        let s_200_0: bool = fn_state.gs_44286;
        // N s_200_1: branch s_200_0 b551 b201
        if s_200_0 {
            return block_551(state, tracer, fn_state);
        } else {
            return block_201(state, tracer, fn_state);
        };
    }
    fn block_201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_201_0: const #() : ()
        let s_201_0: () = ();
        // S s_201_1: call HSTR_read(s_201_0)
        let s_201_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_201_0);
        // C s_201_2: const #1s : i64
        let s_201_2: i64 = 1;
        // C s_201_3: cast zx s_201_2 -> i
        let s_201_3: i128 = (i128::try_from(s_201_2).unwrap());
        // S s_201_4: call __UNKNOWN_bits(s_201_3)
        let s_201_4: Bits = u__UNKNOWN_bits(state, tracer, s_201_3);
        // S s_201_5: cast reint s_201_4 -> u8
        let s_201_5: bool = ((s_201_4.value()) != 0);
        // S s_201_6: call _update_HSTR_Type_T9(s_201_1, s_201_5)
        let s_201_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T9(
            state,
            tracer,
            s_201_1,
            s_201_5,
        );
        // S s_201_7: call HSTR_write(s_201_6)
        let s_201_7: () = HSTR_write(state, tracer, s_201_6);
        // N s_201_8: jump b202
        return block_202(state, tracer, fn_state);
    }
    fn block_202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_202_0: read-var cold:u8
        let s_202_0: bool = fn_state.cold;
        // D s_202_1: not s_202_0
        let s_202_1: bool = !s_202_0;
        // N s_202_2: branch s_202_1 b550 b203
        if s_202_1 {
            return block_550(state, tracer, fn_state);
        } else {
            return block_203(state, tracer, fn_state);
        };
    }
    fn block_203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_203_0: const #0u : u8
        let s_203_0: bool = false;
        // D s_203_1: write-var gs#44287 <= s_203_0
        fn_state.gs_44287 = s_203_0;
        // N s_203_2: jump b204
        return block_204(state, tracer, fn_state);
    }
    fn block_204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_204_0: read-var gs#44287:u8
        let s_204_0: bool = fn_state.gs_44287;
        // N s_204_1: branch s_204_0 b549 b205
        if s_204_0 {
            return block_549(state, tracer, fn_state);
        } else {
            return block_205(state, tracer, fn_state);
        };
    }
    fn block_205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_205_0: const #() : ()
        let s_205_0: () = ();
        // S s_205_1: call HSTR_read(s_205_0)
        let s_205_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_205_0);
        // C s_205_2: const #1s : i64
        let s_205_2: i64 = 1;
        // C s_205_3: cast zx s_205_2 -> i
        let s_205_3: i128 = (i128::try_from(s_205_2).unwrap());
        // S s_205_4: call __UNKNOWN_bits(s_205_3)
        let s_205_4: Bits = u__UNKNOWN_bits(state, tracer, s_205_3);
        // S s_205_5: cast reint s_205_4 -> u8
        let s_205_5: bool = ((s_205_4.value()) != 0);
        // S s_205_6: call _update_HSTR_Type_T8(s_205_1, s_205_5)
        let s_205_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T8(
            state,
            tracer,
            s_205_1,
            s_205_5,
        );
        // S s_205_7: call HSTR_write(s_205_6)
        let s_205_7: () = HSTR_write(state, tracer, s_205_6);
        // N s_205_8: jump b206
        return block_206(state, tracer, fn_state);
    }
    fn block_206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_206_0: read-var cold:u8
        let s_206_0: bool = fn_state.cold;
        // D s_206_1: not s_206_0
        let s_206_1: bool = !s_206_0;
        // N s_206_2: branch s_206_1 b548 b207
        if s_206_1 {
            return block_548(state, tracer, fn_state);
        } else {
            return block_207(state, tracer, fn_state);
        };
    }
    fn block_207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_207_0: const #0u : u8
        let s_207_0: bool = false;
        // D s_207_1: write-var gs#44288 <= s_207_0
        fn_state.gs_44288 = s_207_0;
        // N s_207_2: jump b208
        return block_208(state, tracer, fn_state);
    }
    fn block_208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_208_0: read-var gs#44288:u8
        let s_208_0: bool = fn_state.gs_44288;
        // N s_208_1: branch s_208_0 b547 b209
        if s_208_0 {
            return block_547(state, tracer, fn_state);
        } else {
            return block_209(state, tracer, fn_state);
        };
    }
    fn block_209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_209_0: const #() : ()
        let s_209_0: () = ();
        // S s_209_1: call HSTR_read(s_209_0)
        let s_209_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_209_0);
        // C s_209_2: const #1s : i64
        let s_209_2: i64 = 1;
        // C s_209_3: cast zx s_209_2 -> i
        let s_209_3: i128 = (i128::try_from(s_209_2).unwrap());
        // S s_209_4: call __UNKNOWN_bits(s_209_3)
        let s_209_4: Bits = u__UNKNOWN_bits(state, tracer, s_209_3);
        // S s_209_5: cast reint s_209_4 -> u8
        let s_209_5: bool = ((s_209_4.value()) != 0);
        // S s_209_6: call _update_HSTR_Type_T7(s_209_1, s_209_5)
        let s_209_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T7(
            state,
            tracer,
            s_209_1,
            s_209_5,
        );
        // S s_209_7: call HSTR_write(s_209_6)
        let s_209_7: () = HSTR_write(state, tracer, s_209_6);
        // N s_209_8: jump b210
        return block_210(state, tracer, fn_state);
    }
    fn block_210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_210_0: read-var cold:u8
        let s_210_0: bool = fn_state.cold;
        // D s_210_1: not s_210_0
        let s_210_1: bool = !s_210_0;
        // N s_210_2: branch s_210_1 b546 b211
        if s_210_1 {
            return block_546(state, tracer, fn_state);
        } else {
            return block_211(state, tracer, fn_state);
        };
    }
    fn block_211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_211_0: const #0u : u8
        let s_211_0: bool = false;
        // D s_211_1: write-var gs#44289 <= s_211_0
        fn_state.gs_44289 = s_211_0;
        // N s_211_2: jump b212
        return block_212(state, tracer, fn_state);
    }
    fn block_212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_212_0: read-var gs#44289:u8
        let s_212_0: bool = fn_state.gs_44289;
        // N s_212_1: branch s_212_0 b545 b213
        if s_212_0 {
            return block_545(state, tracer, fn_state);
        } else {
            return block_213(state, tracer, fn_state);
        };
    }
    fn block_213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_213_0: const #() : ()
        let s_213_0: () = ();
        // S s_213_1: call HSTR_read(s_213_0)
        let s_213_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_213_0);
        // C s_213_2: const #1s : i64
        let s_213_2: i64 = 1;
        // C s_213_3: cast zx s_213_2 -> i
        let s_213_3: i128 = (i128::try_from(s_213_2).unwrap());
        // S s_213_4: call __UNKNOWN_bits(s_213_3)
        let s_213_4: Bits = u__UNKNOWN_bits(state, tracer, s_213_3);
        // S s_213_5: cast reint s_213_4 -> u8
        let s_213_5: bool = ((s_213_4.value()) != 0);
        // S s_213_6: call _update_HSTR_Type_T6(s_213_1, s_213_5)
        let s_213_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T6(
            state,
            tracer,
            s_213_1,
            s_213_5,
        );
        // S s_213_7: call HSTR_write(s_213_6)
        let s_213_7: () = HSTR_write(state, tracer, s_213_6);
        // N s_213_8: jump b214
        return block_214(state, tracer, fn_state);
    }
    fn block_214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_214_0: read-var cold:u8
        let s_214_0: bool = fn_state.cold;
        // D s_214_1: not s_214_0
        let s_214_1: bool = !s_214_0;
        // N s_214_2: branch s_214_1 b544 b215
        if s_214_1 {
            return block_544(state, tracer, fn_state);
        } else {
            return block_215(state, tracer, fn_state);
        };
    }
    fn block_215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_215_0: const #0u : u8
        let s_215_0: bool = false;
        // D s_215_1: write-var gs#44290 <= s_215_0
        fn_state.gs_44290 = s_215_0;
        // N s_215_2: jump b216
        return block_216(state, tracer, fn_state);
    }
    fn block_216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_216_0: read-var gs#44290:u8
        let s_216_0: bool = fn_state.gs_44290;
        // N s_216_1: branch s_216_0 b543 b217
        if s_216_0 {
            return block_543(state, tracer, fn_state);
        } else {
            return block_217(state, tracer, fn_state);
        };
    }
    fn block_217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_217_0: const #() : ()
        let s_217_0: () = ();
        // S s_217_1: call HSTR_read(s_217_0)
        let s_217_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_217_0);
        // C s_217_2: const #1s : i64
        let s_217_2: i64 = 1;
        // C s_217_3: cast zx s_217_2 -> i
        let s_217_3: i128 = (i128::try_from(s_217_2).unwrap());
        // S s_217_4: call __UNKNOWN_bits(s_217_3)
        let s_217_4: Bits = u__UNKNOWN_bits(state, tracer, s_217_3);
        // S s_217_5: cast reint s_217_4 -> u8
        let s_217_5: bool = ((s_217_4.value()) != 0);
        // S s_217_6: call _update_HSTR_Type_T5(s_217_1, s_217_5)
        let s_217_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T5(
            state,
            tracer,
            s_217_1,
            s_217_5,
        );
        // S s_217_7: call HSTR_write(s_217_6)
        let s_217_7: () = HSTR_write(state, tracer, s_217_6);
        // N s_217_8: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_218_0: read-var cold:u8
        let s_218_0: bool = fn_state.cold;
        // D s_218_1: not s_218_0
        let s_218_1: bool = !s_218_0;
        // N s_218_2: branch s_218_1 b542 b219
        if s_218_1 {
            return block_542(state, tracer, fn_state);
        } else {
            return block_219(state, tracer, fn_state);
        };
    }
    fn block_219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_219_0: const #0u : u8
        let s_219_0: bool = false;
        // D s_219_1: write-var gs#44291 <= s_219_0
        fn_state.gs_44291 = s_219_0;
        // N s_219_2: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_220_0: read-var gs#44291:u8
        let s_220_0: bool = fn_state.gs_44291;
        // N s_220_1: branch s_220_0 b541 b221
        if s_220_0 {
            return block_541(state, tracer, fn_state);
        } else {
            return block_221(state, tracer, fn_state);
        };
    }
    fn block_221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_221_0: const #() : ()
        let s_221_0: () = ();
        // S s_221_1: call HSTR_read(s_221_0)
        let s_221_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_221_0);
        // C s_221_2: const #1s : i64
        let s_221_2: i64 = 1;
        // C s_221_3: cast zx s_221_2 -> i
        let s_221_3: i128 = (i128::try_from(s_221_2).unwrap());
        // S s_221_4: call __UNKNOWN_bits(s_221_3)
        let s_221_4: Bits = u__UNKNOWN_bits(state, tracer, s_221_3);
        // S s_221_5: cast reint s_221_4 -> u8
        let s_221_5: bool = ((s_221_4.value()) != 0);
        // S s_221_6: call _update_HSTR_Type_T3(s_221_1, s_221_5)
        let s_221_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T3(
            state,
            tracer,
            s_221_1,
            s_221_5,
        );
        // S s_221_7: call HSTR_write(s_221_6)
        let s_221_7: () = HSTR_write(state, tracer, s_221_6);
        // N s_221_8: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_222_0: read-var cold:u8
        let s_222_0: bool = fn_state.cold;
        // D s_222_1: not s_222_0
        let s_222_1: bool = !s_222_0;
        // N s_222_2: branch s_222_1 b540 b223
        if s_222_1 {
            return block_540(state, tracer, fn_state);
        } else {
            return block_223(state, tracer, fn_state);
        };
    }
    fn block_223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_223_0: const #0u : u8
        let s_223_0: bool = false;
        // D s_223_1: write-var gs#44292 <= s_223_0
        fn_state.gs_44292 = s_223_0;
        // N s_223_2: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_224_0: read-var gs#44292:u8
        let s_224_0: bool = fn_state.gs_44292;
        // N s_224_1: branch s_224_0 b539 b225
        if s_224_0 {
            return block_539(state, tracer, fn_state);
        } else {
            return block_225(state, tracer, fn_state);
        };
    }
    fn block_225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_225_0: const #() : ()
        let s_225_0: () = ();
        // S s_225_1: call HSTR_read(s_225_0)
        let s_225_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_225_0);
        // C s_225_2: const #1s : i64
        let s_225_2: i64 = 1;
        // C s_225_3: cast zx s_225_2 -> i
        let s_225_3: i128 = (i128::try_from(s_225_2).unwrap());
        // S s_225_4: call __UNKNOWN_bits(s_225_3)
        let s_225_4: Bits = u__UNKNOWN_bits(state, tracer, s_225_3);
        // S s_225_5: cast reint s_225_4 -> u8
        let s_225_5: bool = ((s_225_4.value()) != 0);
        // S s_225_6: call _update_HSTR_Type_T2(s_225_1, s_225_5)
        let s_225_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T2(
            state,
            tracer,
            s_225_1,
            s_225_5,
        );
        // S s_225_7: call HSTR_write(s_225_6)
        let s_225_7: () = HSTR_write(state, tracer, s_225_6);
        // N s_225_8: jump b226
        return block_226(state, tracer, fn_state);
    }
    fn block_226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_226_0: read-var cold:u8
        let s_226_0: bool = fn_state.cold;
        // D s_226_1: not s_226_0
        let s_226_1: bool = !s_226_0;
        // N s_226_2: branch s_226_1 b538 b227
        if s_226_1 {
            return block_538(state, tracer, fn_state);
        } else {
            return block_227(state, tracer, fn_state);
        };
    }
    fn block_227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_227_0: const #0u : u8
        let s_227_0: bool = false;
        // D s_227_1: write-var gs#44293 <= s_227_0
        fn_state.gs_44293 = s_227_0;
        // N s_227_2: jump b228
        return block_228(state, tracer, fn_state);
    }
    fn block_228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_228_0: read-var gs#44293:u8
        let s_228_0: bool = fn_state.gs_44293;
        // N s_228_1: branch s_228_0 b537 b229
        if s_228_0 {
            return block_537(state, tracer, fn_state);
        } else {
            return block_229(state, tracer, fn_state);
        };
    }
    fn block_229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_229_0: const #() : ()
        let s_229_0: () = ();
        // S s_229_1: call HSTR_read(s_229_0)
        let s_229_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_229_0);
        // C s_229_2: const #1s : i64
        let s_229_2: i64 = 1;
        // C s_229_3: cast zx s_229_2 -> i
        let s_229_3: i128 = (i128::try_from(s_229_2).unwrap());
        // S s_229_4: call __UNKNOWN_bits(s_229_3)
        let s_229_4: Bits = u__UNKNOWN_bits(state, tracer, s_229_3);
        // S s_229_5: cast reint s_229_4 -> u8
        let s_229_5: bool = ((s_229_4.value()) != 0);
        // S s_229_6: call _update_HSTR_Type_T1(s_229_1, s_229_5)
        let s_229_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T1(
            state,
            tracer,
            s_229_1,
            s_229_5,
        );
        // S s_229_7: call HSTR_write(s_229_6)
        let s_229_7: () = HSTR_write(state, tracer, s_229_6);
        // N s_229_8: jump b230
        return block_230(state, tracer, fn_state);
    }
    fn block_230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_230_0: read-var cold:u8
        let s_230_0: bool = fn_state.cold;
        // D s_230_1: not s_230_0
        let s_230_1: bool = !s_230_0;
        // N s_230_2: branch s_230_1 b536 b231
        if s_230_1 {
            return block_536(state, tracer, fn_state);
        } else {
            return block_231(state, tracer, fn_state);
        };
    }
    fn block_231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_231_0: const #0u : u8
        let s_231_0: bool = false;
        // D s_231_1: write-var gs#44294 <= s_231_0
        fn_state.gs_44294 = s_231_0;
        // N s_231_2: jump b232
        return block_232(state, tracer, fn_state);
    }
    fn block_232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_232_0: read-var gs#44294:u8
        let s_232_0: bool = fn_state.gs_44294;
        // N s_232_1: branch s_232_0 b535 b233
        if s_232_0 {
            return block_535(state, tracer, fn_state);
        } else {
            return block_233(state, tracer, fn_state);
        };
    }
    fn block_233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_233_0: const #() : ()
        let s_233_0: () = ();
        // S s_233_1: call HSTR_read(s_233_0)
        let s_233_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_233_0);
        // C s_233_2: const #1s : i64
        let s_233_2: i64 = 1;
        // C s_233_3: cast zx s_233_2 -> i
        let s_233_3: i128 = (i128::try_from(s_233_2).unwrap());
        // S s_233_4: call __UNKNOWN_bits(s_233_3)
        let s_233_4: Bits = u__UNKNOWN_bits(state, tracer, s_233_3);
        // S s_233_5: cast reint s_233_4 -> u8
        let s_233_5: bool = ((s_233_4.value()) != 0);
        // S s_233_6: call _update_HSTR_Type_T0(s_233_1, s_233_5)
        let s_233_6: ProductType700c18a878c5601b = u_update_HSTR_Type_T0(
            state,
            tracer,
            s_233_1,
            s_233_5,
        );
        // S s_233_7: call HSTR_write(s_233_6)
        let s_233_7: () = HSTR_write(state, tracer, s_233_6);
        // N s_233_8: jump b234
        return block_234(state, tracer, fn_state);
    }
    fn block_234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_234_0: const #21800u : u32
        let s_234_0: u32 = 21800;
        // D s_234_1: read-reg s_234_0:struct
        let s_234_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_234_0 as isize);
            tracer.read_register(s_234_0 as isize, value);
            value
        };
        // C s_234_2: const #21800u : u32
        let s_234_2: u32 = 21800;
        // N s_234_3: write-reg s_234_2 <= s_234_1
        let s_234_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_234_2 as isize, s_234_1);
            tracer.write_register(s_234_2 as isize, s_234_1);
        };
        // C s_234_4: const #0u : u8
        let s_234_4: bool = false;
        // S s_234_5: call Bit(s_234_4)
        let s_234_5: bool = Bit(state, tracer, s_234_4);
        // C s_234_6: const #21800u : u32
        let s_234_6: u32 = 21800;
        // D s_234_7: read-reg s_234_6:struct
        let s_234_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_234_6 as isize);
            tracer.read_register(s_234_6 as isize, value);
            value
        };
        // C s_234_8: const #21800u : u32
        let s_234_8: u32 = 21800;
        // N s_234_9: write-reg s_234_8 <= s_234_7
        let s_234_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_234_8 as isize, s_234_7);
            tracer.write_register(s_234_8 as isize, s_234_7);
        };
        // C s_234_10: const #0u : u8
        let s_234_10: bool = false;
        // S s_234_11: call Bit(s_234_10)
        let s_234_11: bool = Bit(state, tracer, s_234_10);
        // C s_234_12: const #21800u : u32
        let s_234_12: u32 = 21800;
        // D s_234_13: read-reg s_234_12:struct
        let s_234_13: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_234_12 as isize);
            tracer.read_register(s_234_12 as isize, value);
            value
        };
        // C s_234_14: const #21800u : u32
        let s_234_14: u32 = 21800;
        // N s_234_15: write-reg s_234_14 <= s_234_13
        let s_234_15: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_234_14 as isize, s_234_13);
            tracer.write_register(s_234_14 as isize, s_234_13);
        };
        // C s_234_16: const #21800u : u32
        let s_234_16: u32 = 21800;
        // D s_234_17: read-reg s_234_16:struct
        let s_234_17: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_234_16 as isize);
            tracer.read_register(s_234_16 as isize, value);
            value
        };
        // C s_234_18: const #21800u : u32
        let s_234_18: u32 = 21800;
        // N s_234_19: write-reg s_234_18 <= s_234_17
        let s_234_19: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_234_18 as isize, s_234_17);
            tracer.write_register(s_234_18 as isize, s_234_17);
        };
        // C s_234_20: const #() : ()
        let s_234_20: () = ();
        // S s_234_21: call ICC_DIR_read(s_234_20)
        let s_234_21: ProductType700c18a878c5601b = ICC_DIR_read(
            state,
            tracer,
            s_234_20,
        );
        // D s_234_22: write-var ga#35743 <= s_234_21
        fn_state.ga_35743 = s_234_21;
        // D s_234_23: read-var ga#35743.0:struct
        let s_234_23: u32 = fn_state.ga_35743._0;
        // C s_234_24: const #8s : i
        let s_234_24: i128 = 8;
        // C s_234_25: const #24s : i
        let s_234_25: i128 = 24;
        // D s_234_26: cast zx s_234_23 -> bv
        let s_234_26: Bits = Bits::new(s_234_23 as u128, 32u16);
        // C s_234_27: const #0u : u8
        let s_234_27: u8 = 0;
        // C s_234_28: cast zx s_234_27 -> bv
        let s_234_28: Bits = Bits::new(s_234_27 as u128, 8u16);
        // C s_234_29: const #1u : u64
        let s_234_29: u64 = 1;
        // C s_234_30: cast zx s_234_29 -> bv
        let s_234_30: Bits = Bits::new(s_234_29 as u128, 64u16);
        // C s_234_31: lsl s_234_30 s_234_24
        let s_234_31: Bits = s_234_30 << s_234_24;
        // C s_234_32: sub s_234_31 s_234_30
        let s_234_32: Bits = ((s_234_31) - (s_234_30));
        // C s_234_33: and s_234_28 s_234_32
        let s_234_33: Bits = ((s_234_28) & (s_234_32));
        // C s_234_34: lsl s_234_33 s_234_25
        let s_234_34: Bits = s_234_33 << s_234_25;
        // C s_234_35: lsl s_234_32 s_234_25
        let s_234_35: Bits = s_234_32 << s_234_25;
        // C s_234_36: cmpl s_234_35
        let s_234_36: Bits = !s_234_35;
        // D s_234_37: and s_234_26 s_234_36
        let s_234_37: Bits = ((s_234_26) & (s_234_36));
        // D s_234_38: or s_234_37 s_234_34
        let s_234_38: Bits = ((s_234_37) | (s_234_34));
        // D s_234_39: cast reint s_234_38 -> u32
        let s_234_39: u32 = (s_234_38.value() as u32);
        // D s_234_40: call Mk_ICC_DIR_Type(s_234_39)
        let s_234_40: ProductType700c18a878c5601b = Mk_ICC_DIR_Type(
            state,
            tracer,
            s_234_39,
        );
        // D s_234_41: call ICC_DIR_write(s_234_40)
        let s_234_41: () = ICC_DIR_write(state, tracer, s_234_40);
        // C s_234_42: const #() : ()
        let s_234_42: () = ();
        // S s_234_43: call PMSELR_read(s_234_42)
        let s_234_43: ProductType700c18a878c5601b = PMSELR_read(state, tracer, s_234_42);
        // D s_234_44: write-var ga#35747 <= s_234_43
        fn_state.ga_35747 = s_234_43;
        // D s_234_45: read-var ga#35747.0:struct
        let s_234_45: u32 = fn_state.ga_35747._0;
        // C s_234_46: const #27s : i
        let s_234_46: i128 = 27;
        // C s_234_47: const #5s : i
        let s_234_47: i128 = 5;
        // D s_234_48: cast zx s_234_45 -> bv
        let s_234_48: Bits = Bits::new(s_234_45 as u128, 32u16);
        // C s_234_49: const #0u : u27
        let s_234_49: u32 = 0;
        // C s_234_50: cast zx s_234_49 -> bv
        let s_234_50: Bits = Bits::new(s_234_49 as u128, 27u16);
        // C s_234_51: const #1u : u64
        let s_234_51: u64 = 1;
        // C s_234_52: cast zx s_234_51 -> bv
        let s_234_52: Bits = Bits::new(s_234_51 as u128, 64u16);
        // C s_234_53: lsl s_234_52 s_234_46
        let s_234_53: Bits = s_234_52 << s_234_46;
        // C s_234_54: sub s_234_53 s_234_52
        let s_234_54: Bits = ((s_234_53) - (s_234_52));
        // C s_234_55: and s_234_50 s_234_54
        let s_234_55: Bits = ((s_234_50) & (s_234_54));
        // C s_234_56: lsl s_234_55 s_234_47
        let s_234_56: Bits = s_234_55 << s_234_47;
        // C s_234_57: lsl s_234_54 s_234_47
        let s_234_57: Bits = s_234_54 << s_234_47;
        // C s_234_58: cmpl s_234_57
        let s_234_58: Bits = !s_234_57;
        // D s_234_59: and s_234_48 s_234_58
        let s_234_59: Bits = ((s_234_48) & (s_234_58));
        // D s_234_60: or s_234_59 s_234_56
        let s_234_60: Bits = ((s_234_59) | (s_234_56));
        // D s_234_61: cast reint s_234_60 -> u32
        let s_234_61: u32 = (s_234_60.value() as u32);
        // D s_234_62: call Mk_PMSELR_Type(s_234_61)
        let s_234_62: ProductType700c18a878c5601b = Mk_PMSELR_Type(
            state,
            tracer,
            s_234_61,
        );
        // D s_234_63: call PMSELR_write(s_234_62)
        let s_234_63: () = PMSELR_write(state, tracer, s_234_62);
        // C s_234_64: const #() : ()
        let s_234_64: () = ();
        // S s_234_65: call ID_AFR0_read(s_234_64)
        let s_234_65: u32 = ID_AFR0_read(state, tracer, s_234_64);
        // C s_234_66: const #16s : i
        let s_234_66: i128 = 16;
        // C s_234_67: const #16s : i
        let s_234_67: i128 = 16;
        // S s_234_68: cast zx s_234_65 -> bv
        let s_234_68: Bits = Bits::new(s_234_65 as u128, 32u16);
        // C s_234_69: const #0u : u16
        let s_234_69: u16 = 0;
        // C s_234_70: cast zx s_234_69 -> bv
        let s_234_70: Bits = Bits::new(s_234_69 as u128, 16u16);
        // C s_234_71: const #1u : u64
        let s_234_71: u64 = 1;
        // C s_234_72: cast zx s_234_71 -> bv
        let s_234_72: Bits = Bits::new(s_234_71 as u128, 64u16);
        // C s_234_73: lsl s_234_72 s_234_66
        let s_234_73: Bits = s_234_72 << s_234_66;
        // C s_234_74: sub s_234_73 s_234_72
        let s_234_74: Bits = ((s_234_73) - (s_234_72));
        // C s_234_75: and s_234_70 s_234_74
        let s_234_75: Bits = ((s_234_70) & (s_234_74));
        // C s_234_76: lsl s_234_75 s_234_67
        let s_234_76: Bits = s_234_75 << s_234_67;
        // C s_234_77: lsl s_234_74 s_234_67
        let s_234_77: Bits = s_234_74 << s_234_67;
        // C s_234_78: cmpl s_234_77
        let s_234_78: Bits = !s_234_77;
        // S s_234_79: and s_234_68 s_234_78
        let s_234_79: Bits = ((s_234_68) & (s_234_78));
        // S s_234_80: or s_234_79 s_234_76
        let s_234_80: Bits = ((s_234_79) | (s_234_76));
        // S s_234_81: cast reint s_234_80 -> u32
        let s_234_81: u32 = (s_234_80.value() as u32);
        // S s_234_82: call ID_AFR0_write(s_234_81)
        let s_234_82: () = ID_AFR0_write(state, tracer, s_234_81);
        // C s_234_83: const #() : ()
        let s_234_83: () = ();
        // S s_234_84: call DBGCLAIMSET_read(s_234_83)
        let s_234_84: ProductType700c18a878c5601b = DBGCLAIMSET_read(
            state,
            tracer,
            s_234_83,
        );
        // D s_234_85: write-var ga#35753 <= s_234_84
        fn_state.ga_35753 = s_234_84;
        // D s_234_86: read-var ga#35753.0:struct
        let s_234_86: u32 = fn_state.ga_35753._0;
        // C s_234_87: const #24s : i
        let s_234_87: i128 = 24;
        // C s_234_88: const #8s : i
        let s_234_88: i128 = 8;
        // D s_234_89: cast zx s_234_86 -> bv
        let s_234_89: Bits = Bits::new(s_234_86 as u128, 32u16);
        // C s_234_90: const #0u : u24
        let s_234_90: u32 = 0;
        // C s_234_91: cast zx s_234_90 -> bv
        let s_234_91: Bits = Bits::new(s_234_90 as u128, 24u16);
        // C s_234_92: const #1u : u64
        let s_234_92: u64 = 1;
        // C s_234_93: cast zx s_234_92 -> bv
        let s_234_93: Bits = Bits::new(s_234_92 as u128, 64u16);
        // C s_234_94: lsl s_234_93 s_234_87
        let s_234_94: Bits = s_234_93 << s_234_87;
        // C s_234_95: sub s_234_94 s_234_93
        let s_234_95: Bits = ((s_234_94) - (s_234_93));
        // C s_234_96: and s_234_91 s_234_95
        let s_234_96: Bits = ((s_234_91) & (s_234_95));
        // C s_234_97: lsl s_234_96 s_234_88
        let s_234_97: Bits = s_234_96 << s_234_88;
        // C s_234_98: lsl s_234_95 s_234_88
        let s_234_98: Bits = s_234_95 << s_234_88;
        // C s_234_99: cmpl s_234_98
        let s_234_99: Bits = !s_234_98;
        // D s_234_100: and s_234_89 s_234_99
        let s_234_100: Bits = ((s_234_89) & (s_234_99));
        // D s_234_101: or s_234_100 s_234_97
        let s_234_101: Bits = ((s_234_100) | (s_234_97));
        // D s_234_102: cast reint s_234_101 -> u32
        let s_234_102: u32 = (s_234_101.value() as u32);
        // D s_234_103: call Mk_DBGCLAIMSET_Type(s_234_102)
        let s_234_103: ProductType700c18a878c5601b = Mk_DBGCLAIMSET_Type(
            state,
            tracer,
            s_234_102,
        );
        // D s_234_104: call DBGCLAIMSET_write(s_234_103)
        let s_234_104: () = DBGCLAIMSET_write(state, tracer, s_234_103);
        // D s_234_105: read-var cold:u8
        let s_234_105: bool = fn_state.cold;
        // N s_234_106: branch s_234_105 b534 b235
        if s_234_105 {
            return block_534(state, tracer, fn_state);
        } else {
            return block_235(state, tracer, fn_state);
        };
    }
    fn block_235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_235_0: jump b236
        return block_236(state, tracer, fn_state);
    }
    fn block_236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_236_0: const #() : ()
        let s_236_0: () = ();
        // S s_236_1: call ICC_IGRPEN0_read(s_236_0)
        let s_236_1: ProductType700c18a878c5601b = ICC_IGRPEN0_read(
            state,
            tracer,
            s_236_0,
        );
        // D s_236_2: write-var ga#35759 <= s_236_1
        fn_state.ga_35759 = s_236_1;
        // D s_236_3: read-var ga#35759.0:struct
        let s_236_3: u32 = fn_state.ga_35759._0;
        // C s_236_4: const #31s : i
        let s_236_4: i128 = 31;
        // C s_236_5: const #1s : i
        let s_236_5: i128 = 1;
        // D s_236_6: cast zx s_236_3 -> bv
        let s_236_6: Bits = Bits::new(s_236_3 as u128, 32u16);
        // C s_236_7: const #0u : u31
        let s_236_7: u32 = 0;
        // C s_236_8: cast zx s_236_7 -> bv
        let s_236_8: Bits = Bits::new(s_236_7 as u128, 31u16);
        // C s_236_9: const #1u : u64
        let s_236_9: u64 = 1;
        // C s_236_10: cast zx s_236_9 -> bv
        let s_236_10: Bits = Bits::new(s_236_9 as u128, 64u16);
        // C s_236_11: lsl s_236_10 s_236_4
        let s_236_11: Bits = s_236_10 << s_236_4;
        // C s_236_12: sub s_236_11 s_236_10
        let s_236_12: Bits = ((s_236_11) - (s_236_10));
        // C s_236_13: and s_236_8 s_236_12
        let s_236_13: Bits = ((s_236_8) & (s_236_12));
        // C s_236_14: lsl s_236_13 s_236_5
        let s_236_14: Bits = s_236_13 << s_236_5;
        // C s_236_15: lsl s_236_12 s_236_5
        let s_236_15: Bits = s_236_12 << s_236_5;
        // C s_236_16: cmpl s_236_15
        let s_236_16: Bits = !s_236_15;
        // D s_236_17: and s_236_6 s_236_16
        let s_236_17: Bits = ((s_236_6) & (s_236_16));
        // D s_236_18: or s_236_17 s_236_14
        let s_236_18: Bits = ((s_236_17) | (s_236_14));
        // D s_236_19: cast reint s_236_18 -> u32
        let s_236_19: u32 = (s_236_18.value() as u32);
        // D s_236_20: call Mk_ICC_IGRPEN0_Type(s_236_19)
        let s_236_20: ProductType700c18a878c5601b = Mk_ICC_IGRPEN0_Type(
            state,
            tracer,
            s_236_19,
        );
        // D s_236_21: call ICC_IGRPEN0_write(s_236_20)
        let s_236_21: () = ICC_IGRPEN0_write(state, tracer, s_236_20);
        // C s_236_22: const #() : ()
        let s_236_22: () = ();
        // S s_236_23: call ICC_IGRPEN0_read(s_236_22)
        let s_236_23: ProductType700c18a878c5601b = ICC_IGRPEN0_read(
            state,
            tracer,
            s_236_22,
        );
        // C s_236_24: const #0u : u8
        let s_236_24: bool = false;
        // S s_236_25: call _update_ICC_IGRPEN0_Type_Enable(s_236_23, s_236_24)
        let s_236_25: ProductType700c18a878c5601b = u_update_ICC_IGRPEN0_Type_Enable(
            state,
            tracer,
            s_236_23,
            s_236_24,
        );
        // S s_236_26: call ICC_IGRPEN0_write(s_236_25)
        let s_236_26: () = ICC_IGRPEN0_write(state, tracer, s_236_25);
        // C s_236_27: const #() : ()
        let s_236_27: () = ();
        // S s_236_28: call ICC_CTLR_read(s_236_27)
        let s_236_28: ProductType700c18a878c5601b = ICC_CTLR_read(
            state,
            tracer,
            s_236_27,
        );
        // D s_236_29: write-var ga#35765 <= s_236_28
        fn_state.ga_35765 = s_236_28;
        // D s_236_30: read-var ga#35765.0:struct
        let s_236_30: u32 = fn_state.ga_35765._0;
        // C s_236_31: const #12s : i
        let s_236_31: i128 = 12;
        // C s_236_32: const #20s : i
        let s_236_32: i128 = 20;
        // D s_236_33: cast zx s_236_30 -> bv
        let s_236_33: Bits = Bits::new(s_236_30 as u128, 32u16);
        // C s_236_34: const #0u : u12
        let s_236_34: u16 = 0;
        // C s_236_35: cast zx s_236_34 -> bv
        let s_236_35: Bits = Bits::new(s_236_34 as u128, 12u16);
        // C s_236_36: const #1u : u64
        let s_236_36: u64 = 1;
        // C s_236_37: cast zx s_236_36 -> bv
        let s_236_37: Bits = Bits::new(s_236_36 as u128, 64u16);
        // C s_236_38: lsl s_236_37 s_236_31
        let s_236_38: Bits = s_236_37 << s_236_31;
        // C s_236_39: sub s_236_38 s_236_37
        let s_236_39: Bits = ((s_236_38) - (s_236_37));
        // C s_236_40: and s_236_35 s_236_39
        let s_236_40: Bits = ((s_236_35) & (s_236_39));
        // C s_236_41: lsl s_236_40 s_236_32
        let s_236_41: Bits = s_236_40 << s_236_32;
        // C s_236_42: lsl s_236_39 s_236_32
        let s_236_42: Bits = s_236_39 << s_236_32;
        // C s_236_43: cmpl s_236_42
        let s_236_43: Bits = !s_236_42;
        // D s_236_44: and s_236_33 s_236_43
        let s_236_44: Bits = ((s_236_33) & (s_236_43));
        // D s_236_45: or s_236_44 s_236_41
        let s_236_45: Bits = ((s_236_44) | (s_236_41));
        // D s_236_46: cast reint s_236_45 -> u32
        let s_236_46: u32 = (s_236_45.value() as u32);
        // D s_236_47: call Mk_ICC_CTLR_Type(s_236_46)
        let s_236_47: ProductType700c18a878c5601b = Mk_ICC_CTLR_Type(
            state,
            tracer,
            s_236_46,
        );
        // D s_236_48: call ICC_CTLR_write(s_236_47)
        let s_236_48: () = ICC_CTLR_write(state, tracer, s_236_47);
        // C s_236_49: const #() : ()
        let s_236_49: () = ();
        // S s_236_50: call ICC_CTLR_read(s_236_49)
        let s_236_50: ProductType700c18a878c5601b = ICC_CTLR_read(
            state,
            tracer,
            s_236_49,
        );
        // D s_236_51: write-var ga#35769 <= s_236_50
        fn_state.ga_35769 = s_236_50;
        // D s_236_52: read-var ga#35769.0:struct
        let s_236_52: u32 = fn_state.ga_35769._0;
        // C s_236_53: const #2s : i
        let s_236_53: i128 = 2;
        // C s_236_54: const #16s : i
        let s_236_54: i128 = 16;
        // D s_236_55: cast zx s_236_52 -> bv
        let s_236_55: Bits = Bits::new(s_236_52 as u128, 32u16);
        // C s_236_56: const #0u : u8
        let s_236_56: u8 = 0;
        // C s_236_57: cast zx s_236_56 -> bv
        let s_236_57: Bits = Bits::new(s_236_56 as u128, 2u16);
        // C s_236_58: const #1u : u64
        let s_236_58: u64 = 1;
        // C s_236_59: cast zx s_236_58 -> bv
        let s_236_59: Bits = Bits::new(s_236_58 as u128, 64u16);
        // C s_236_60: lsl s_236_59 s_236_53
        let s_236_60: Bits = s_236_59 << s_236_53;
        // C s_236_61: sub s_236_60 s_236_59
        let s_236_61: Bits = ((s_236_60) - (s_236_59));
        // C s_236_62: and s_236_57 s_236_61
        let s_236_62: Bits = ((s_236_57) & (s_236_61));
        // C s_236_63: lsl s_236_62 s_236_54
        let s_236_63: Bits = s_236_62 << s_236_54;
        // C s_236_64: lsl s_236_61 s_236_54
        let s_236_64: Bits = s_236_61 << s_236_54;
        // C s_236_65: cmpl s_236_64
        let s_236_65: Bits = !s_236_64;
        // D s_236_66: and s_236_55 s_236_65
        let s_236_66: Bits = ((s_236_55) & (s_236_65));
        // D s_236_67: or s_236_66 s_236_63
        let s_236_67: Bits = ((s_236_66) | (s_236_63));
        // D s_236_68: cast reint s_236_67 -> u32
        let s_236_68: u32 = (s_236_67.value() as u32);
        // D s_236_69: call Mk_ICC_CTLR_Type(s_236_68)
        let s_236_69: ProductType700c18a878c5601b = Mk_ICC_CTLR_Type(
            state,
            tracer,
            s_236_68,
        );
        // D s_236_70: call ICC_CTLR_write(s_236_69)
        let s_236_70: () = ICC_CTLR_write(state, tracer, s_236_69);
        // C s_236_71: const #() : ()
        let s_236_71: () = ();
        // S s_236_72: call ICC_CTLR_read(s_236_71)
        let s_236_72: ProductType700c18a878c5601b = ICC_CTLR_read(
            state,
            tracer,
            s_236_71,
        );
        // D s_236_73: write-var ga#35773 <= s_236_72
        fn_state.ga_35773 = s_236_72;
        // D s_236_74: read-var ga#35773.0:struct
        let s_236_74: u32 = fn_state.ga_35773._0;
        // C s_236_75: const #1s : i
        let s_236_75: i128 = 1;
        // C s_236_76: const #7s : i
        let s_236_76: i128 = 7;
        // D s_236_77: cast zx s_236_74 -> bv
        let s_236_77: Bits = Bits::new(s_236_74 as u128, 32u16);
        // C s_236_78: const #0u : u8
        let s_236_78: bool = false;
        // C s_236_79: cast zx s_236_78 -> bv
        let s_236_79: Bits = Bits::new(s_236_78 as u128, 1u16);
        // C s_236_80: const #1u : u64
        let s_236_80: u64 = 1;
        // C s_236_81: cast zx s_236_80 -> bv
        let s_236_81: Bits = Bits::new(s_236_80 as u128, 64u16);
        // C s_236_82: lsl s_236_81 s_236_75
        let s_236_82: Bits = s_236_81 << s_236_75;
        // C s_236_83: sub s_236_82 s_236_81
        let s_236_83: Bits = ((s_236_82) - (s_236_81));
        // C s_236_84: and s_236_79 s_236_83
        let s_236_84: Bits = ((s_236_79) & (s_236_83));
        // C s_236_85: lsl s_236_84 s_236_76
        let s_236_85: Bits = s_236_84 << s_236_76;
        // C s_236_86: lsl s_236_83 s_236_76
        let s_236_86: Bits = s_236_83 << s_236_76;
        // C s_236_87: cmpl s_236_86
        let s_236_87: Bits = !s_236_86;
        // D s_236_88: and s_236_77 s_236_87
        let s_236_88: Bits = ((s_236_77) & (s_236_87));
        // D s_236_89: or s_236_88 s_236_85
        let s_236_89: Bits = ((s_236_88) | (s_236_85));
        // D s_236_90: cast reint s_236_89 -> u32
        let s_236_90: u32 = (s_236_89.value() as u32);
        // D s_236_91: call Mk_ICC_CTLR_Type(s_236_90)
        let s_236_91: ProductType700c18a878c5601b = Mk_ICC_CTLR_Type(
            state,
            tracer,
            s_236_90,
        );
        // D s_236_92: call ICC_CTLR_write(s_236_91)
        let s_236_92: () = ICC_CTLR_write(state, tracer, s_236_91);
        // C s_236_93: const #() : ()
        let s_236_93: () = ();
        // S s_236_94: call ICC_CTLR_read(s_236_93)
        let s_236_94: ProductType700c18a878c5601b = ICC_CTLR_read(
            state,
            tracer,
            s_236_93,
        );
        // D s_236_95: write-var ga#35777 <= s_236_94
        fn_state.ga_35777 = s_236_94;
        // D s_236_96: read-var ga#35777.0:struct
        let s_236_96: u32 = fn_state.ga_35777._0;
        // C s_236_97: const #4s : i
        let s_236_97: i128 = 4;
        // C s_236_98: const #2s : i
        let s_236_98: i128 = 2;
        // D s_236_99: cast zx s_236_96 -> bv
        let s_236_99: Bits = Bits::new(s_236_96 as u128, 32u16);
        // C s_236_100: const #0u : u8
        let s_236_100: u8 = 0;
        // C s_236_101: cast zx s_236_100 -> bv
        let s_236_101: Bits = Bits::new(s_236_100 as u128, 4u16);
        // C s_236_102: const #1u : u64
        let s_236_102: u64 = 1;
        // C s_236_103: cast zx s_236_102 -> bv
        let s_236_103: Bits = Bits::new(s_236_102 as u128, 64u16);
        // C s_236_104: lsl s_236_103 s_236_97
        let s_236_104: Bits = s_236_103 << s_236_97;
        // C s_236_105: sub s_236_104 s_236_103
        let s_236_105: Bits = ((s_236_104) - (s_236_103));
        // C s_236_106: and s_236_101 s_236_105
        let s_236_106: Bits = ((s_236_101) & (s_236_105));
        // C s_236_107: lsl s_236_106 s_236_98
        let s_236_107: Bits = s_236_106 << s_236_98;
        // C s_236_108: lsl s_236_105 s_236_98
        let s_236_108: Bits = s_236_105 << s_236_98;
        // C s_236_109: cmpl s_236_108
        let s_236_109: Bits = !s_236_108;
        // D s_236_110: and s_236_99 s_236_109
        let s_236_110: Bits = ((s_236_99) & (s_236_109));
        // D s_236_111: or s_236_110 s_236_107
        let s_236_111: Bits = ((s_236_110) | (s_236_107));
        // D s_236_112: cast reint s_236_111 -> u32
        let s_236_112: u32 = (s_236_111.value() as u32);
        // D s_236_113: call Mk_ICC_CTLR_Type(s_236_112)
        let s_236_113: ProductType700c18a878c5601b = Mk_ICC_CTLR_Type(
            state,
            tracer,
            s_236_112,
        );
        // D s_236_114: call ICC_CTLR_write(s_236_113)
        let s_236_114: () = ICC_CTLR_write(state, tracer, s_236_113);
        // C s_236_115: const #() : ()
        let s_236_115: () = ();
        // S s_236_116: call CNTHVS_CTL_read(s_236_115)
        let s_236_116: ProductType700c18a878c5601b = CNTHVS_CTL_read(
            state,
            tracer,
            s_236_115,
        );
        // D s_236_117: write-var ga#35781 <= s_236_116
        fn_state.ga_35781 = s_236_116;
        // D s_236_118: read-var ga#35781.0:struct
        let s_236_118: u32 = fn_state.ga_35781._0;
        // C s_236_119: const #29s : i
        let s_236_119: i128 = 29;
        // C s_236_120: const #3s : i
        let s_236_120: i128 = 3;
        // D s_236_121: cast zx s_236_118 -> bv
        let s_236_121: Bits = Bits::new(s_236_118 as u128, 32u16);
        // C s_236_122: const #0u : u29
        let s_236_122: u32 = 0;
        // C s_236_123: cast zx s_236_122 -> bv
        let s_236_123: Bits = Bits::new(s_236_122 as u128, 29u16);
        // C s_236_124: const #1u : u64
        let s_236_124: u64 = 1;
        // C s_236_125: cast zx s_236_124 -> bv
        let s_236_125: Bits = Bits::new(s_236_124 as u128, 64u16);
        // C s_236_126: lsl s_236_125 s_236_119
        let s_236_126: Bits = s_236_125 << s_236_119;
        // C s_236_127: sub s_236_126 s_236_125
        let s_236_127: Bits = ((s_236_126) - (s_236_125));
        // C s_236_128: and s_236_123 s_236_127
        let s_236_128: Bits = ((s_236_123) & (s_236_127));
        // C s_236_129: lsl s_236_128 s_236_120
        let s_236_129: Bits = s_236_128 << s_236_120;
        // C s_236_130: lsl s_236_127 s_236_120
        let s_236_130: Bits = s_236_127 << s_236_120;
        // C s_236_131: cmpl s_236_130
        let s_236_131: Bits = !s_236_130;
        // D s_236_132: and s_236_121 s_236_131
        let s_236_132: Bits = ((s_236_121) & (s_236_131));
        // D s_236_133: or s_236_132 s_236_129
        let s_236_133: Bits = ((s_236_132) | (s_236_129));
        // D s_236_134: cast reint s_236_133 -> u32
        let s_236_134: u32 = (s_236_133.value() as u32);
        // D s_236_135: call Mk_CNTHVS_CTL_Type(s_236_134)
        let s_236_135: ProductType700c18a878c5601b = Mk_CNTHVS_CTL_Type(
            state,
            tracer,
            s_236_134,
        );
        // D s_236_136: call CNTHVS_CTL_write(s_236_135)
        let s_236_136: () = CNTHVS_CTL_write(state, tracer, s_236_135);
        // C s_236_137: const #20920u : u32
        let s_236_137: u32 = 20920;
        // D s_236_138: read-reg s_236_137:struct
        let s_236_138: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_137 as isize);
            tracer.read_register(s_236_137 as isize, value);
            value
        };
        // C s_236_139: const #20920u : u32
        let s_236_139: u32 = 20920;
        // N s_236_140: write-reg s_236_139 <= s_236_138
        let s_236_140: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_139 as isize, s_236_138);
            tracer.write_register(s_236_139 as isize, s_236_138);
        };
        // C s_236_141: const #20920u : u32
        let s_236_141: u32 = 20920;
        // D s_236_142: read-reg s_236_141:struct
        let s_236_142: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_141 as isize);
            tracer.read_register(s_236_141 as isize, value);
            value
        };
        // C s_236_143: const #20920u : u32
        let s_236_143: u32 = 20920;
        // N s_236_144: write-reg s_236_143 <= s_236_142
        let s_236_144: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_143 as isize, s_236_142);
            tracer.write_register(s_236_143 as isize, s_236_142);
        };
        // C s_236_145: const #0u : u8
        let s_236_145: bool = false;
        // S s_236_146: call Bit(s_236_145)
        let s_236_146: bool = Bit(state, tracer, s_236_145);
        // C s_236_147: const #20920u : u32
        let s_236_147: u32 = 20920;
        // D s_236_148: read-reg s_236_147:struct
        let s_236_148: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_147 as isize);
            tracer.read_register(s_236_147 as isize, value);
            value
        };
        // C s_236_149: const #20920u : u32
        let s_236_149: u32 = 20920;
        // N s_236_150: write-reg s_236_149 <= s_236_148
        let s_236_150: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_149 as isize, s_236_148);
            tracer.write_register(s_236_149 as isize, s_236_148);
        };
        // C s_236_151: const #20920u : u32
        let s_236_151: u32 = 20920;
        // D s_236_152: read-reg s_236_151:struct
        let s_236_152: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_151 as isize);
            tracer.read_register(s_236_151 as isize, value);
            value
        };
        // C s_236_153: const #20920u : u32
        let s_236_153: u32 = 20920;
        // N s_236_154: write-reg s_236_153 <= s_236_152
        let s_236_154: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_153 as isize, s_236_152);
            tracer.write_register(s_236_153 as isize, s_236_152);
        };
        // C s_236_155: const #20920u : u32
        let s_236_155: u32 = 20920;
        // D s_236_156: read-reg s_236_155:struct
        let s_236_156: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_155 as isize);
            tracer.read_register(s_236_155 as isize, value);
            value
        };
        // C s_236_157: const #20920u : u32
        let s_236_157: u32 = 20920;
        // N s_236_158: write-reg s_236_157 <= s_236_156
        let s_236_158: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_157 as isize, s_236_156);
            tracer.write_register(s_236_157 as isize, s_236_156);
        };
        // C s_236_159: const #20920u : u32
        let s_236_159: u32 = 20920;
        // D s_236_160: read-reg s_236_159:struct
        let s_236_160: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_159 as isize);
            tracer.read_register(s_236_159 as isize, value);
            value
        };
        // C s_236_161: const #20920u : u32
        let s_236_161: u32 = 20920;
        // N s_236_162: write-reg s_236_161 <= s_236_160
        let s_236_162: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_161 as isize, s_236_160);
            tracer.write_register(s_236_161 as isize, s_236_160);
        };
        // C s_236_163: const #20920u : u32
        let s_236_163: u32 = 20920;
        // D s_236_164: read-reg s_236_163:struct
        let s_236_164: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_163 as isize);
            tracer.read_register(s_236_163 as isize, value);
            value
        };
        // C s_236_165: const #20920u : u32
        let s_236_165: u32 = 20920;
        // N s_236_166: write-reg s_236_165 <= s_236_164
        let s_236_166: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_165 as isize, s_236_164);
            tracer.write_register(s_236_165 as isize, s_236_164);
        };
        // C s_236_167: const #20920u : u32
        let s_236_167: u32 = 20920;
        // D s_236_168: read-reg s_236_167:struct
        let s_236_168: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_167 as isize);
            tracer.read_register(s_236_167 as isize, value);
            value
        };
        // C s_236_169: const #20920u : u32
        let s_236_169: u32 = 20920;
        // N s_236_170: write-reg s_236_169 <= s_236_168
        let s_236_170: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_169 as isize, s_236_168);
            tracer.write_register(s_236_169 as isize, s_236_168);
        };
        // C s_236_171: const #20920u : u32
        let s_236_171: u32 = 20920;
        // D s_236_172: read-reg s_236_171:struct
        let s_236_172: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_171 as isize);
            tracer.read_register(s_236_171 as isize, value);
            value
        };
        // C s_236_173: const #20920u : u32
        let s_236_173: u32 = 20920;
        // N s_236_174: write-reg s_236_173 <= s_236_172
        let s_236_174: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_173 as isize, s_236_172);
            tracer.write_register(s_236_173 as isize, s_236_172);
        };
        // C s_236_175: const #20920u : u32
        let s_236_175: u32 = 20920;
        // D s_236_176: read-reg s_236_175:struct
        let s_236_176: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_175 as isize);
            tracer.read_register(s_236_175 as isize, value);
            value
        };
        // C s_236_177: const #20920u : u32
        let s_236_177: u32 = 20920;
        // N s_236_178: write-reg s_236_177 <= s_236_176
        let s_236_178: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_177 as isize, s_236_176);
            tracer.write_register(s_236_177 as isize, s_236_176);
        };
        // C s_236_179: const #20920u : u32
        let s_236_179: u32 = 20920;
        // D s_236_180: read-reg s_236_179:struct
        let s_236_180: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_179 as isize);
            tracer.read_register(s_236_179 as isize, value);
            value
        };
        // C s_236_181: const #20920u : u32
        let s_236_181: u32 = 20920;
        // N s_236_182: write-reg s_236_181 <= s_236_180
        let s_236_182: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_181 as isize, s_236_180);
            tracer.write_register(s_236_181 as isize, s_236_180);
        };
        // C s_236_183: const #20920u : u32
        let s_236_183: u32 = 20920;
        // D s_236_184: read-reg s_236_183:struct
        let s_236_184: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_183 as isize);
            tracer.read_register(s_236_183 as isize, value);
            value
        };
        // C s_236_185: const #20920u : u32
        let s_236_185: u32 = 20920;
        // N s_236_186: write-reg s_236_185 <= s_236_184
        let s_236_186: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_185 as isize, s_236_184);
            tracer.write_register(s_236_185 as isize, s_236_184);
        };
        // C s_236_187: const #20920u : u32
        let s_236_187: u32 = 20920;
        // D s_236_188: read-reg s_236_187:struct
        let s_236_188: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_187 as isize);
            tracer.read_register(s_236_187 as isize, value);
            value
        };
        // C s_236_189: const #20920u : u32
        let s_236_189: u32 = 20920;
        // N s_236_190: write-reg s_236_189 <= s_236_188
        let s_236_190: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_189 as isize, s_236_188);
            tracer.write_register(s_236_189 as isize, s_236_188);
        };
        // C s_236_191: const #20920u : u32
        let s_236_191: u32 = 20920;
        // D s_236_192: read-reg s_236_191:struct
        let s_236_192: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_191 as isize);
            tracer.read_register(s_236_191 as isize, value);
            value
        };
        // C s_236_193: const #20920u : u32
        let s_236_193: u32 = 20920;
        // N s_236_194: write-reg s_236_193 <= s_236_192
        let s_236_194: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_193 as isize, s_236_192);
            tracer.write_register(s_236_193 as isize, s_236_192);
        };
        // C s_236_195: const #20920u : u32
        let s_236_195: u32 = 20920;
        // D s_236_196: read-reg s_236_195:struct
        let s_236_196: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_195 as isize);
            tracer.read_register(s_236_195 as isize, value);
            value
        };
        // C s_236_197: const #20920u : u32
        let s_236_197: u32 = 20920;
        // N s_236_198: write-reg s_236_197 <= s_236_196
        let s_236_198: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_197 as isize, s_236_196);
            tracer.write_register(s_236_197 as isize, s_236_196);
        };
        // C s_236_199: const #20920u : u32
        let s_236_199: u32 = 20920;
        // D s_236_200: read-reg s_236_199:struct
        let s_236_200: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_199 as isize);
            tracer.read_register(s_236_199 as isize, value);
            value
        };
        // C s_236_201: const #20920u : u32
        let s_236_201: u32 = 20920;
        // N s_236_202: write-reg s_236_201 <= s_236_200
        let s_236_202: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_201 as isize, s_236_200);
            tracer.write_register(s_236_201 as isize, s_236_200);
        };
        // C s_236_203: const #102488u : u32
        let s_236_203: u32 = 102488;
        // D s_236_204: read-reg s_236_203:struct
        let s_236_204: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_203 as isize);
            tracer.read_register(s_236_203 as isize, value);
            value
        };
        // C s_236_205: const #102488u : u32
        let s_236_205: u32 = 102488;
        // N s_236_206: write-reg s_236_205 <= s_236_204
        let s_236_206: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_205 as isize, s_236_204);
            tracer.write_register(s_236_205 as isize, s_236_204);
        };
        // C s_236_207: const #102488u : u32
        let s_236_207: u32 = 102488;
        // D s_236_208: read-reg s_236_207:struct
        let s_236_208: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_207 as isize);
            tracer.read_register(s_236_207 as isize, value);
            value
        };
        // C s_236_209: const #102488u : u32
        let s_236_209: u32 = 102488;
        // N s_236_210: write-reg s_236_209 <= s_236_208
        let s_236_210: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_209 as isize, s_236_208);
            tracer.write_register(s_236_209 as isize, s_236_208);
        };
        // C s_236_211: const #0u : u8
        let s_236_211: bool = false;
        // S s_236_212: call Bit(s_236_211)
        let s_236_212: bool = Bit(state, tracer, s_236_211);
        // C s_236_213: const #102488u : u32
        let s_236_213: u32 = 102488;
        // D s_236_214: read-reg s_236_213:struct
        let s_236_214: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_213 as isize);
            tracer.read_register(s_236_213 as isize, value);
            value
        };
        // C s_236_215: const #102488u : u32
        let s_236_215: u32 = 102488;
        // N s_236_216: write-reg s_236_215 <= s_236_214
        let s_236_216: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_215 as isize, s_236_214);
            tracer.write_register(s_236_215 as isize, s_236_214);
        };
        // C s_236_217: const #102488u : u32
        let s_236_217: u32 = 102488;
        // D s_236_218: read-reg s_236_217:struct
        let s_236_218: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_217 as isize);
            tracer.read_register(s_236_217 as isize, value);
            value
        };
        // C s_236_219: const #102488u : u32
        let s_236_219: u32 = 102488;
        // N s_236_220: write-reg s_236_219 <= s_236_218
        let s_236_220: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_219 as isize, s_236_218);
            tracer.write_register(s_236_219 as isize, s_236_218);
        };
        // C s_236_221: const #102488u : u32
        let s_236_221: u32 = 102488;
        // D s_236_222: read-reg s_236_221:struct
        let s_236_222: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_221 as isize);
            tracer.read_register(s_236_221 as isize, value);
            value
        };
        // C s_236_223: const #102488u : u32
        let s_236_223: u32 = 102488;
        // N s_236_224: write-reg s_236_223 <= s_236_222
        let s_236_224: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_223 as isize, s_236_222);
            tracer.write_register(s_236_223 as isize, s_236_222);
        };
        // C s_236_225: const #102488u : u32
        let s_236_225: u32 = 102488;
        // D s_236_226: read-reg s_236_225:struct
        let s_236_226: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_236_225 as isize);
            tracer.read_register(s_236_225 as isize, value);
            value
        };
        // C s_236_227: const #102488u : u32
        let s_236_227: u32 = 102488;
        // N s_236_228: write-reg s_236_227 <= s_236_226
        let s_236_228: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_236_227 as isize, s_236_226);
            tracer.write_register(s_236_227 as isize, s_236_226);
        };
        // C s_236_229: const #() : ()
        let s_236_229: () = ();
        // S s_236_230: call ICV_BPR0_read(s_236_229)
        let s_236_230: ProductType700c18a878c5601b = ICV_BPR0_read(
            state,
            tracer,
            s_236_229,
        );
        // D s_236_231: write-var ga#35831 <= s_236_230
        fn_state.ga_35831 = s_236_230;
        // D s_236_232: read-var ga#35831.0:struct
        let s_236_232: u32 = fn_state.ga_35831._0;
        // C s_236_233: const #29s : i
        let s_236_233: i128 = 29;
        // C s_236_234: const #3s : i
        let s_236_234: i128 = 3;
        // D s_236_235: cast zx s_236_232 -> bv
        let s_236_235: Bits = Bits::new(s_236_232 as u128, 32u16);
        // C s_236_236: const #0u : u29
        let s_236_236: u32 = 0;
        // C s_236_237: cast zx s_236_236 -> bv
        let s_236_237: Bits = Bits::new(s_236_236 as u128, 29u16);
        // C s_236_238: const #1u : u64
        let s_236_238: u64 = 1;
        // C s_236_239: cast zx s_236_238 -> bv
        let s_236_239: Bits = Bits::new(s_236_238 as u128, 64u16);
        // C s_236_240: lsl s_236_239 s_236_233
        let s_236_240: Bits = s_236_239 << s_236_233;
        // C s_236_241: sub s_236_240 s_236_239
        let s_236_241: Bits = ((s_236_240) - (s_236_239));
        // C s_236_242: and s_236_237 s_236_241
        let s_236_242: Bits = ((s_236_237) & (s_236_241));
        // C s_236_243: lsl s_236_242 s_236_234
        let s_236_243: Bits = s_236_242 << s_236_234;
        // C s_236_244: lsl s_236_241 s_236_234
        let s_236_244: Bits = s_236_241 << s_236_234;
        // C s_236_245: cmpl s_236_244
        let s_236_245: Bits = !s_236_244;
        // D s_236_246: and s_236_235 s_236_245
        let s_236_246: Bits = ((s_236_235) & (s_236_245));
        // D s_236_247: or s_236_246 s_236_243
        let s_236_247: Bits = ((s_236_246) | (s_236_243));
        // D s_236_248: cast reint s_236_247 -> u32
        let s_236_248: u32 = (s_236_247.value() as u32);
        // D s_236_249: call Mk_ICV_BPR0_Type(s_236_248)
        let s_236_249: ProductType700c18a878c5601b = Mk_ICV_BPR0_Type(
            state,
            tracer,
            s_236_248,
        );
        // D s_236_250: call ICV_BPR0_write(s_236_249)
        let s_236_250: () = ICV_BPR0_write(state, tracer, s_236_249);
        // C s_236_251: const #() : ()
        let s_236_251: () = ();
        // S s_236_252: call ICH_EISR_read(s_236_251)
        let s_236_252: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_251,
        );
        // D s_236_253: write-var ga#35835 <= s_236_252
        fn_state.ga_35835 = s_236_252;
        // D s_236_254: read-var ga#35835.0:struct
        let s_236_254: u32 = fn_state.ga_35835._0;
        // C s_236_255: const #16s : i
        let s_236_255: i128 = 16;
        // C s_236_256: const #16s : i
        let s_236_256: i128 = 16;
        // D s_236_257: cast zx s_236_254 -> bv
        let s_236_257: Bits = Bits::new(s_236_254 as u128, 32u16);
        // C s_236_258: const #0u : u16
        let s_236_258: u16 = 0;
        // C s_236_259: cast zx s_236_258 -> bv
        let s_236_259: Bits = Bits::new(s_236_258 as u128, 16u16);
        // C s_236_260: const #1u : u64
        let s_236_260: u64 = 1;
        // C s_236_261: cast zx s_236_260 -> bv
        let s_236_261: Bits = Bits::new(s_236_260 as u128, 64u16);
        // C s_236_262: lsl s_236_261 s_236_255
        let s_236_262: Bits = s_236_261 << s_236_255;
        // C s_236_263: sub s_236_262 s_236_261
        let s_236_263: Bits = ((s_236_262) - (s_236_261));
        // C s_236_264: and s_236_259 s_236_263
        let s_236_264: Bits = ((s_236_259) & (s_236_263));
        // C s_236_265: lsl s_236_264 s_236_256
        let s_236_265: Bits = s_236_264 << s_236_256;
        // C s_236_266: lsl s_236_263 s_236_256
        let s_236_266: Bits = s_236_263 << s_236_256;
        // C s_236_267: cmpl s_236_266
        let s_236_267: Bits = !s_236_266;
        // D s_236_268: and s_236_257 s_236_267
        let s_236_268: Bits = ((s_236_257) & (s_236_267));
        // D s_236_269: or s_236_268 s_236_265
        let s_236_269: Bits = ((s_236_268) | (s_236_265));
        // D s_236_270: cast reint s_236_269 -> u32
        let s_236_270: u32 = (s_236_269.value() as u32);
        // D s_236_271: call Mk_ICH_EISR_Type(s_236_270)
        let s_236_271: ProductType700c18a878c5601b = Mk_ICH_EISR_Type(
            state,
            tracer,
            s_236_270,
        );
        // D s_236_272: call ICH_EISR_write(s_236_271)
        let s_236_272: () = ICH_EISR_write(state, tracer, s_236_271);
        // C s_236_273: const #() : ()
        let s_236_273: () = ();
        // S s_236_274: call ICH_EISR_read(s_236_273)
        let s_236_274: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_273,
        );
        // C s_236_275: const #0u : u8
        let s_236_275: bool = false;
        // S s_236_276: call _update_ICH_EISR_Type_Status15(s_236_274, s_236_275)
        let s_236_276: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status15(
            state,
            tracer,
            s_236_274,
            s_236_275,
        );
        // S s_236_277: call ICH_EISR_write(s_236_276)
        let s_236_277: () = ICH_EISR_write(state, tracer, s_236_276);
        // C s_236_278: const #() : ()
        let s_236_278: () = ();
        // S s_236_279: call ICH_EISR_read(s_236_278)
        let s_236_279: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_278,
        );
        // C s_236_280: const #0u : u8
        let s_236_280: bool = false;
        // S s_236_281: call _update_ICH_EISR_Type_Status14(s_236_279, s_236_280)
        let s_236_281: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status14(
            state,
            tracer,
            s_236_279,
            s_236_280,
        );
        // S s_236_282: call ICH_EISR_write(s_236_281)
        let s_236_282: () = ICH_EISR_write(state, tracer, s_236_281);
        // C s_236_283: const #() : ()
        let s_236_283: () = ();
        // S s_236_284: call ICH_EISR_read(s_236_283)
        let s_236_284: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_283,
        );
        // C s_236_285: const #0u : u8
        let s_236_285: bool = false;
        // S s_236_286: call _update_ICH_EISR_Type_Status13(s_236_284, s_236_285)
        let s_236_286: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status13(
            state,
            tracer,
            s_236_284,
            s_236_285,
        );
        // S s_236_287: call ICH_EISR_write(s_236_286)
        let s_236_287: () = ICH_EISR_write(state, tracer, s_236_286);
        // C s_236_288: const #() : ()
        let s_236_288: () = ();
        // S s_236_289: call ICH_EISR_read(s_236_288)
        let s_236_289: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_288,
        );
        // C s_236_290: const #0u : u8
        let s_236_290: bool = false;
        // S s_236_291: call _update_ICH_EISR_Type_Status12(s_236_289, s_236_290)
        let s_236_291: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status12(
            state,
            tracer,
            s_236_289,
            s_236_290,
        );
        // S s_236_292: call ICH_EISR_write(s_236_291)
        let s_236_292: () = ICH_EISR_write(state, tracer, s_236_291);
        // C s_236_293: const #() : ()
        let s_236_293: () = ();
        // S s_236_294: call ICH_EISR_read(s_236_293)
        let s_236_294: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_293,
        );
        // C s_236_295: const #0u : u8
        let s_236_295: bool = false;
        // S s_236_296: call _update_ICH_EISR_Type_Status11(s_236_294, s_236_295)
        let s_236_296: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status11(
            state,
            tracer,
            s_236_294,
            s_236_295,
        );
        // S s_236_297: call ICH_EISR_write(s_236_296)
        let s_236_297: () = ICH_EISR_write(state, tracer, s_236_296);
        // C s_236_298: const #() : ()
        let s_236_298: () = ();
        // S s_236_299: call ICH_EISR_read(s_236_298)
        let s_236_299: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_298,
        );
        // C s_236_300: const #0u : u8
        let s_236_300: bool = false;
        // S s_236_301: call _update_ICH_EISR_Type_Status10(s_236_299, s_236_300)
        let s_236_301: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status10(
            state,
            tracer,
            s_236_299,
            s_236_300,
        );
        // S s_236_302: call ICH_EISR_write(s_236_301)
        let s_236_302: () = ICH_EISR_write(state, tracer, s_236_301);
        // C s_236_303: const #() : ()
        let s_236_303: () = ();
        // S s_236_304: call ICH_EISR_read(s_236_303)
        let s_236_304: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_303,
        );
        // C s_236_305: const #0u : u8
        let s_236_305: bool = false;
        // S s_236_306: call _update_ICH_EISR_Type_Status9(s_236_304, s_236_305)
        let s_236_306: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status9(
            state,
            tracer,
            s_236_304,
            s_236_305,
        );
        // S s_236_307: call ICH_EISR_write(s_236_306)
        let s_236_307: () = ICH_EISR_write(state, tracer, s_236_306);
        // C s_236_308: const #() : ()
        let s_236_308: () = ();
        // S s_236_309: call ICH_EISR_read(s_236_308)
        let s_236_309: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_308,
        );
        // C s_236_310: const #0u : u8
        let s_236_310: bool = false;
        // S s_236_311: call _update_ICH_EISR_Type_Status8(s_236_309, s_236_310)
        let s_236_311: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status8(
            state,
            tracer,
            s_236_309,
            s_236_310,
        );
        // S s_236_312: call ICH_EISR_write(s_236_311)
        let s_236_312: () = ICH_EISR_write(state, tracer, s_236_311);
        // C s_236_313: const #() : ()
        let s_236_313: () = ();
        // S s_236_314: call ICH_EISR_read(s_236_313)
        let s_236_314: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_313,
        );
        // C s_236_315: const #0u : u8
        let s_236_315: bool = false;
        // S s_236_316: call _update_ICH_EISR_Type_Status7(s_236_314, s_236_315)
        let s_236_316: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status7(
            state,
            tracer,
            s_236_314,
            s_236_315,
        );
        // S s_236_317: call ICH_EISR_write(s_236_316)
        let s_236_317: () = ICH_EISR_write(state, tracer, s_236_316);
        // C s_236_318: const #() : ()
        let s_236_318: () = ();
        // S s_236_319: call ICH_EISR_read(s_236_318)
        let s_236_319: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_318,
        );
        // C s_236_320: const #0u : u8
        let s_236_320: bool = false;
        // S s_236_321: call _update_ICH_EISR_Type_Status6(s_236_319, s_236_320)
        let s_236_321: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status6(
            state,
            tracer,
            s_236_319,
            s_236_320,
        );
        // S s_236_322: call ICH_EISR_write(s_236_321)
        let s_236_322: () = ICH_EISR_write(state, tracer, s_236_321);
        // C s_236_323: const #() : ()
        let s_236_323: () = ();
        // S s_236_324: call ICH_EISR_read(s_236_323)
        let s_236_324: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_323,
        );
        // C s_236_325: const #0u : u8
        let s_236_325: bool = false;
        // S s_236_326: call _update_ICH_EISR_Type_Status5(s_236_324, s_236_325)
        let s_236_326: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status5(
            state,
            tracer,
            s_236_324,
            s_236_325,
        );
        // S s_236_327: call ICH_EISR_write(s_236_326)
        let s_236_327: () = ICH_EISR_write(state, tracer, s_236_326);
        // C s_236_328: const #() : ()
        let s_236_328: () = ();
        // S s_236_329: call ICH_EISR_read(s_236_328)
        let s_236_329: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_328,
        );
        // C s_236_330: const #0u : u8
        let s_236_330: bool = false;
        // S s_236_331: call _update_ICH_EISR_Type_Status4(s_236_329, s_236_330)
        let s_236_331: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status4(
            state,
            tracer,
            s_236_329,
            s_236_330,
        );
        // S s_236_332: call ICH_EISR_write(s_236_331)
        let s_236_332: () = ICH_EISR_write(state, tracer, s_236_331);
        // C s_236_333: const #() : ()
        let s_236_333: () = ();
        // S s_236_334: call ICH_EISR_read(s_236_333)
        let s_236_334: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_333,
        );
        // C s_236_335: const #0u : u8
        let s_236_335: bool = false;
        // S s_236_336: call _update_ICH_EISR_Type_Status3(s_236_334, s_236_335)
        let s_236_336: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status3(
            state,
            tracer,
            s_236_334,
            s_236_335,
        );
        // S s_236_337: call ICH_EISR_write(s_236_336)
        let s_236_337: () = ICH_EISR_write(state, tracer, s_236_336);
        // C s_236_338: const #() : ()
        let s_236_338: () = ();
        // S s_236_339: call ICH_EISR_read(s_236_338)
        let s_236_339: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_338,
        );
        // C s_236_340: const #0u : u8
        let s_236_340: bool = false;
        // S s_236_341: call _update_ICH_EISR_Type_Status2(s_236_339, s_236_340)
        let s_236_341: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status2(
            state,
            tracer,
            s_236_339,
            s_236_340,
        );
        // S s_236_342: call ICH_EISR_write(s_236_341)
        let s_236_342: () = ICH_EISR_write(state, tracer, s_236_341);
        // C s_236_343: const #() : ()
        let s_236_343: () = ();
        // S s_236_344: call ICH_EISR_read(s_236_343)
        let s_236_344: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_343,
        );
        // C s_236_345: const #0u : u8
        let s_236_345: bool = false;
        // S s_236_346: call _update_ICH_EISR_Type_Status1(s_236_344, s_236_345)
        let s_236_346: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status1(
            state,
            tracer,
            s_236_344,
            s_236_345,
        );
        // S s_236_347: call ICH_EISR_write(s_236_346)
        let s_236_347: () = ICH_EISR_write(state, tracer, s_236_346);
        // C s_236_348: const #() : ()
        let s_236_348: () = ();
        // S s_236_349: call ICH_EISR_read(s_236_348)
        let s_236_349: ProductType700c18a878c5601b = ICH_EISR_read(
            state,
            tracer,
            s_236_348,
        );
        // C s_236_350: const #0u : u8
        let s_236_350: bool = false;
        // S s_236_351: call _update_ICH_EISR_Type_Status0(s_236_349, s_236_350)
        let s_236_351: ProductType700c18a878c5601b = u_update_ICH_EISR_Type_Status0(
            state,
            tracer,
            s_236_349,
            s_236_350,
        );
        // S s_236_352: call ICH_EISR_write(s_236_351)
        let s_236_352: () = ICH_EISR_write(state, tracer, s_236_351);
        // C s_236_353: const #() : ()
        let s_236_353: () = ();
        // S s_236_354: call HDCR_read(s_236_353)
        let s_236_354: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_236_353);
        // D s_236_355: write-var ga#35871 <= s_236_354
        fn_state.ga_35871 = s_236_354;
        // D s_236_356: read-var ga#35871.0:struct
        let s_236_356: u32 = fn_state.ga_35871._0;
        // C s_236_357: const #2s : i
        let s_236_357: i128 = 2;
        // C s_236_358: const #30s : i
        let s_236_358: i128 = 30;
        // D s_236_359: cast zx s_236_356 -> bv
        let s_236_359: Bits = Bits::new(s_236_356 as u128, 32u16);
        // C s_236_360: const #0u : u8
        let s_236_360: u8 = 0;
        // C s_236_361: cast zx s_236_360 -> bv
        let s_236_361: Bits = Bits::new(s_236_360 as u128, 2u16);
        // C s_236_362: const #1u : u64
        let s_236_362: u64 = 1;
        // C s_236_363: cast zx s_236_362 -> bv
        let s_236_363: Bits = Bits::new(s_236_362 as u128, 64u16);
        // C s_236_364: lsl s_236_363 s_236_357
        let s_236_364: Bits = s_236_363 << s_236_357;
        // C s_236_365: sub s_236_364 s_236_363
        let s_236_365: Bits = ((s_236_364) - (s_236_363));
        // C s_236_366: and s_236_361 s_236_365
        let s_236_366: Bits = ((s_236_361) & (s_236_365));
        // C s_236_367: lsl s_236_366 s_236_358
        let s_236_367: Bits = s_236_366 << s_236_358;
        // C s_236_368: lsl s_236_365 s_236_358
        let s_236_368: Bits = s_236_365 << s_236_358;
        // C s_236_369: cmpl s_236_368
        let s_236_369: Bits = !s_236_368;
        // D s_236_370: and s_236_359 s_236_369
        let s_236_370: Bits = ((s_236_359) & (s_236_369));
        // D s_236_371: or s_236_370 s_236_367
        let s_236_371: Bits = ((s_236_370) | (s_236_367));
        // D s_236_372: cast reint s_236_371 -> u32
        let s_236_372: u32 = (s_236_371.value() as u32);
        // D s_236_373: call Mk_HDCR_Type(s_236_372)
        let s_236_373: ProductType700c18a878c5601b = Mk_HDCR_Type(
            state,
            tracer,
            s_236_372,
        );
        // D s_236_374: call HDCR_write(s_236_373)
        let s_236_374: () = HDCR_write(state, tracer, s_236_373);
        // D s_236_375: read-var cold:u8
        let s_236_375: bool = fn_state.cold;
        // N s_236_376: branch s_236_375 b533 b237
        if s_236_375 {
            return block_533(state, tracer, fn_state);
        } else {
            return block_237(state, tracer, fn_state);
        };
    }
    fn block_237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_237_0: const #0u : u8
        let s_237_0: bool = false;
        // D s_237_1: write-var gs#44408 <= s_237_0
        fn_state.gs_44408 = s_237_0;
        // N s_237_2: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_238_0: read-var gs#44408:u8
        let s_238_0: bool = fn_state.gs_44408;
        // N s_238_1: branch s_238_0 b532 b239
        if s_238_0 {
            return block_532(state, tracer, fn_state);
        } else {
            return block_239(state, tracer, fn_state);
        };
    }
    fn block_239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_239_0: read-var cold:u8
        let s_239_0: bool = fn_state.cold;
        // N s_239_1: branch s_239_0 b531 b240
        if s_239_0 {
            return block_531(state, tracer, fn_state);
        } else {
            return block_240(state, tracer, fn_state);
        };
    }
    fn block_240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_240_0: jump b241
        return block_241(state, tracer, fn_state);
    }
    fn block_241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_241_0: jump b242
        return block_242(state, tracer, fn_state);
    }
    fn block_242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_242_0: read-var cold:u8
        let s_242_0: bool = fn_state.cold;
        // D s_242_1: not s_242_0
        let s_242_1: bool = !s_242_0;
        // N s_242_2: branch s_242_1 b530 b243
        if s_242_1 {
            return block_530(state, tracer, fn_state);
        } else {
            return block_243(state, tracer, fn_state);
        };
    }
    fn block_243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_243_0: const #0u : u8
        let s_243_0: bool = false;
        // D s_243_1: write-var gs#44409 <= s_243_0
        fn_state.gs_44409 = s_243_0;
        // N s_243_2: jump b244
        return block_244(state, tracer, fn_state);
    }
    fn block_244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_244_0: read-var gs#44409:u8
        let s_244_0: bool = fn_state.gs_44409;
        // N s_244_1: branch s_244_0 b529 b245
        if s_244_0 {
            return block_529(state, tracer, fn_state);
        } else {
            return block_245(state, tracer, fn_state);
        };
    }
    fn block_245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_245_0: const #() : ()
        let s_245_0: () = ();
        // S s_245_1: call HDCR_read(s_245_0)
        let s_245_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_245_0);
        // C s_245_2: const #1s : i64
        let s_245_2: i64 = 1;
        // C s_245_3: cast zx s_245_2 -> i
        let s_245_3: i128 = (i128::try_from(s_245_2).unwrap());
        // S s_245_4: call __UNKNOWN_bits(s_245_3)
        let s_245_4: Bits = u__UNKNOWN_bits(state, tracer, s_245_3);
        // S s_245_5: cast reint s_245_4 -> u8
        let s_245_5: bool = ((s_245_4.value()) != 0);
        // S s_245_6: call _update_HDCR_Type_TDCC(s_245_1, s_245_5)
        let s_245_6: ProductType700c18a878c5601b = u_update_HDCR_Type_TDCC(
            state,
            tracer,
            s_245_1,
            s_245_5,
        );
        // S s_245_7: call HDCR_write(s_245_6)
        let s_245_7: () = HDCR_write(state, tracer, s_245_6);
        // N s_245_8: jump b246
        return block_246(state, tracer, fn_state);
    }
    fn block_246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_246_0: const #() : ()
        let s_246_0: () = ();
        // S s_246_1: call HDCR_read(s_246_0)
        let s_246_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_246_0);
        // D s_246_2: write-var ga#35891 <= s_246_1
        fn_state.ga_35891 = s_246_1;
        // D s_246_3: read-var ga#35891.0:struct
        let s_246_3: u32 = fn_state.ga_35891._0;
        // C s_246_4: const #2s : i
        let s_246_4: i128 = 2;
        // C s_246_5: const #24s : i
        let s_246_5: i128 = 24;
        // D s_246_6: cast zx s_246_3 -> bv
        let s_246_6: Bits = Bits::new(s_246_3 as u128, 32u16);
        // C s_246_7: const #0u : u8
        let s_246_7: u8 = 0;
        // C s_246_8: cast zx s_246_7 -> bv
        let s_246_8: Bits = Bits::new(s_246_7 as u128, 2u16);
        // C s_246_9: const #1u : u64
        let s_246_9: u64 = 1;
        // C s_246_10: cast zx s_246_9 -> bv
        let s_246_10: Bits = Bits::new(s_246_9 as u128, 64u16);
        // C s_246_11: lsl s_246_10 s_246_4
        let s_246_11: Bits = s_246_10 << s_246_4;
        // C s_246_12: sub s_246_11 s_246_10
        let s_246_12: Bits = ((s_246_11) - (s_246_10));
        // C s_246_13: and s_246_8 s_246_12
        let s_246_13: Bits = ((s_246_8) & (s_246_12));
        // C s_246_14: lsl s_246_13 s_246_5
        let s_246_14: Bits = s_246_13 << s_246_5;
        // C s_246_15: lsl s_246_12 s_246_5
        let s_246_15: Bits = s_246_12 << s_246_5;
        // C s_246_16: cmpl s_246_15
        let s_246_16: Bits = !s_246_15;
        // D s_246_17: and s_246_6 s_246_16
        let s_246_17: Bits = ((s_246_6) & (s_246_16));
        // D s_246_18: or s_246_17 s_246_14
        let s_246_18: Bits = ((s_246_17) | (s_246_14));
        // D s_246_19: cast reint s_246_18 -> u32
        let s_246_19: u32 = (s_246_18.value() as u32);
        // D s_246_20: call Mk_HDCR_Type(s_246_19)
        let s_246_20: ProductType700c18a878c5601b = Mk_HDCR_Type(
            state,
            tracer,
            s_246_19,
        );
        // D s_246_21: call HDCR_write(s_246_20)
        let s_246_21: () = HDCR_write(state, tracer, s_246_20);
        // D s_246_22: read-var cold:u8
        let s_246_22: bool = fn_state.cold;
        // D s_246_23: not s_246_22
        let s_246_23: bool = !s_246_22;
        // N s_246_24: branch s_246_23 b528 b247
        if s_246_23 {
            return block_528(state, tracer, fn_state);
        } else {
            return block_247(state, tracer, fn_state);
        };
    }
    fn block_247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_247_0: const #0u : u8
        let s_247_0: bool = false;
        // D s_247_1: write-var gs#44413 <= s_247_0
        fn_state.gs_44413 = s_247_0;
        // N s_247_2: jump b248
        return block_248(state, tracer, fn_state);
    }
    fn block_248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_248_0: read-var gs#44413:u8
        let s_248_0: bool = fn_state.gs_44413;
        // N s_248_1: branch s_248_0 b527 b249
        if s_248_0 {
            return block_527(state, tracer, fn_state);
        } else {
            return block_249(state, tracer, fn_state);
        };
    }
    fn block_249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_249_0: const #() : ()
        let s_249_0: () = ();
        // S s_249_1: call HDCR_read(s_249_0)
        let s_249_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_249_0);
        // C s_249_2: const #1s : i64
        let s_249_2: i64 = 1;
        // C s_249_3: cast zx s_249_2 -> i
        let s_249_3: i128 = (i128::try_from(s_249_2).unwrap());
        // S s_249_4: call __UNKNOWN_bits(s_249_3)
        let s_249_4: Bits = u__UNKNOWN_bits(state, tracer, s_249_3);
        // S s_249_5: cast reint s_249_4 -> u8
        let s_249_5: bool = ((s_249_4.value()) != 0);
        // S s_249_6: call _update_HDCR_Type_HCCD(s_249_1, s_249_5)
        let s_249_6: ProductType700c18a878c5601b = u_update_HDCR_Type_HCCD(
            state,
            tracer,
            s_249_1,
            s_249_5,
        );
        // S s_249_7: call HDCR_write(s_249_6)
        let s_249_7: () = HDCR_write(state, tracer, s_249_6);
        // N s_249_8: jump b250
        return block_250(state, tracer, fn_state);
    }
    fn block_250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_250_0: const #() : ()
        let s_250_0: () = ();
        // S s_250_1: call HDCR_read(s_250_0)
        let s_250_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_250_0);
        // D s_250_2: write-var ga#35903 <= s_250_1
        fn_state.ga_35903 = s_250_1;
        // D s_250_3: read-var ga#35903.0:struct
        let s_250_3: u32 = fn_state.ga_35903._0;
        // C s_250_4: const #3s : i
        let s_250_4: i128 = 3;
        // C s_250_5: const #20s : i
        let s_250_5: i128 = 20;
        // D s_250_6: cast zx s_250_3 -> bv
        let s_250_6: Bits = Bits::new(s_250_3 as u128, 32u16);
        // C s_250_7: const #0u : u8
        let s_250_7: u8 = 0;
        // C s_250_8: cast zx s_250_7 -> bv
        let s_250_8: Bits = Bits::new(s_250_7 as u128, 3u16);
        // C s_250_9: const #1u : u64
        let s_250_9: u64 = 1;
        // C s_250_10: cast zx s_250_9 -> bv
        let s_250_10: Bits = Bits::new(s_250_9 as u128, 64u16);
        // C s_250_11: lsl s_250_10 s_250_4
        let s_250_11: Bits = s_250_10 << s_250_4;
        // C s_250_12: sub s_250_11 s_250_10
        let s_250_12: Bits = ((s_250_11) - (s_250_10));
        // C s_250_13: and s_250_8 s_250_12
        let s_250_13: Bits = ((s_250_8) & (s_250_12));
        // C s_250_14: lsl s_250_13 s_250_5
        let s_250_14: Bits = s_250_13 << s_250_5;
        // C s_250_15: lsl s_250_12 s_250_5
        let s_250_15: Bits = s_250_12 << s_250_5;
        // C s_250_16: cmpl s_250_15
        let s_250_16: Bits = !s_250_15;
        // D s_250_17: and s_250_6 s_250_16
        let s_250_17: Bits = ((s_250_6) & (s_250_16));
        // D s_250_18: or s_250_17 s_250_14
        let s_250_18: Bits = ((s_250_17) | (s_250_14));
        // D s_250_19: cast reint s_250_18 -> u32
        let s_250_19: u32 = (s_250_18.value() as u32);
        // D s_250_20: call Mk_HDCR_Type(s_250_19)
        let s_250_20: ProductType700c18a878c5601b = Mk_HDCR_Type(
            state,
            tracer,
            s_250_19,
        );
        // D s_250_21: call HDCR_write(s_250_20)
        let s_250_21: () = HDCR_write(state, tracer, s_250_20);
        // D s_250_22: read-var cold:u8
        let s_250_22: bool = fn_state.cold;
        // D s_250_23: not s_250_22
        let s_250_23: bool = !s_250_22;
        // N s_250_24: branch s_250_23 b526 b251
        if s_250_23 {
            return block_526(state, tracer, fn_state);
        } else {
            return block_251(state, tracer, fn_state);
        };
    }
    fn block_251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_251_0: const #0u : u8
        let s_251_0: bool = false;
        // D s_251_1: write-var gs#44417 <= s_251_0
        fn_state.gs_44417 = s_251_0;
        // N s_251_2: jump b252
        return block_252(state, tracer, fn_state);
    }
    fn block_252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_252_0: read-var gs#44417:u8
        let s_252_0: bool = fn_state.gs_44417;
        // N s_252_1: branch s_252_0 b525 b253
        if s_252_0 {
            return block_525(state, tracer, fn_state);
        } else {
            return block_253(state, tracer, fn_state);
        };
    }
    fn block_253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_253_0: const #() : ()
        let s_253_0: () = ();
        // S s_253_1: call HDCR_read(s_253_0)
        let s_253_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_253_0);
        // C s_253_2: const #1s : i64
        let s_253_2: i64 = 1;
        // C s_253_3: cast zx s_253_2 -> i
        let s_253_3: i128 = (i128::try_from(s_253_2).unwrap());
        // S s_253_4: call __UNKNOWN_bits(s_253_3)
        let s_253_4: Bits = u__UNKNOWN_bits(state, tracer, s_253_3);
        // S s_253_5: cast reint s_253_4 -> u8
        let s_253_5: bool = ((s_253_4.value()) != 0);
        // S s_253_6: call _update_HDCR_Type_TTRF(s_253_1, s_253_5)
        let s_253_6: ProductType700c18a878c5601b = u_update_HDCR_Type_TTRF(
            state,
            tracer,
            s_253_1,
            s_253_5,
        );
        // S s_253_7: call HDCR_write(s_253_6)
        let s_253_7: () = HDCR_write(state, tracer, s_253_6);
        // N s_253_8: jump b254
        return block_254(state, tracer, fn_state);
    }
    fn block_254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_254_0: const #() : ()
        let s_254_0: () = ();
        // S s_254_1: call HDCR_read(s_254_0)
        let s_254_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_254_0);
        // D s_254_2: write-var ga#35915 <= s_254_1
        fn_state.ga_35915 = s_254_1;
        // D s_254_3: read-var ga#35915.0:struct
        let s_254_3: u32 = fn_state.ga_35915._0;
        // C s_254_4: const #1s : i
        let s_254_4: i128 = 1;
        // C s_254_5: const #18s : i
        let s_254_5: i128 = 18;
        // D s_254_6: cast zx s_254_3 -> bv
        let s_254_6: Bits = Bits::new(s_254_3 as u128, 32u16);
        // C s_254_7: const #0u : u8
        let s_254_7: bool = false;
        // C s_254_8: cast zx s_254_7 -> bv
        let s_254_8: Bits = Bits::new(s_254_7 as u128, 1u16);
        // C s_254_9: const #1u : u64
        let s_254_9: u64 = 1;
        // C s_254_10: cast zx s_254_9 -> bv
        let s_254_10: Bits = Bits::new(s_254_9 as u128, 64u16);
        // C s_254_11: lsl s_254_10 s_254_4
        let s_254_11: Bits = s_254_10 << s_254_4;
        // C s_254_12: sub s_254_11 s_254_10
        let s_254_12: Bits = ((s_254_11) - (s_254_10));
        // C s_254_13: and s_254_8 s_254_12
        let s_254_13: Bits = ((s_254_8) & (s_254_12));
        // C s_254_14: lsl s_254_13 s_254_5
        let s_254_14: Bits = s_254_13 << s_254_5;
        // C s_254_15: lsl s_254_12 s_254_5
        let s_254_15: Bits = s_254_12 << s_254_5;
        // C s_254_16: cmpl s_254_15
        let s_254_16: Bits = !s_254_15;
        // D s_254_17: and s_254_6 s_254_16
        let s_254_17: Bits = ((s_254_6) & (s_254_16));
        // D s_254_18: or s_254_17 s_254_14
        let s_254_18: Bits = ((s_254_17) | (s_254_14));
        // D s_254_19: cast reint s_254_18 -> u32
        let s_254_19: u32 = (s_254_18.value() as u32);
        // D s_254_20: call Mk_HDCR_Type(s_254_19)
        let s_254_20: ProductType700c18a878c5601b = Mk_HDCR_Type(
            state,
            tracer,
            s_254_19,
        );
        // D s_254_21: call HDCR_write(s_254_20)
        let s_254_21: () = HDCR_write(state, tracer, s_254_20);
        // D s_254_22: read-var cold:u8
        let s_254_22: bool = fn_state.cold;
        // D s_254_23: not s_254_22
        let s_254_23: bool = !s_254_22;
        // N s_254_24: branch s_254_23 b524 b255
        if s_254_23 {
            return block_524(state, tracer, fn_state);
        } else {
            return block_255(state, tracer, fn_state);
        };
    }
    fn block_255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_255_0: const #0u : u8
        let s_255_0: bool = false;
        // D s_255_1: write-var gs#44421 <= s_255_0
        fn_state.gs_44421 = s_255_0;
        // N s_255_2: jump b256
        return block_256(state, tracer, fn_state);
    }
    fn block_256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_256_0: read-var gs#44421:u8
        let s_256_0: bool = fn_state.gs_44421;
        // N s_256_1: branch s_256_0 b523 b257
        if s_256_0 {
            return block_523(state, tracer, fn_state);
        } else {
            return block_257(state, tracer, fn_state);
        };
    }
    fn block_257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_257_0: const #() : ()
        let s_257_0: () = ();
        // S s_257_1: call HDCR_read(s_257_0)
        let s_257_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_257_0);
        // C s_257_2: const #1s : i64
        let s_257_2: i64 = 1;
        // C s_257_3: cast zx s_257_2 -> i
        let s_257_3: i128 = (i128::try_from(s_257_2).unwrap());
        // S s_257_4: call __UNKNOWN_bits(s_257_3)
        let s_257_4: Bits = u__UNKNOWN_bits(state, tracer, s_257_3);
        // S s_257_5: cast reint s_257_4 -> u8
        let s_257_5: bool = ((s_257_4.value()) != 0);
        // S s_257_6: call _update_HDCR_Type_HPMD(s_257_1, s_257_5)
        let s_257_6: ProductType700c18a878c5601b = u_update_HDCR_Type_HPMD(
            state,
            tracer,
            s_257_1,
            s_257_5,
        );
        // S s_257_7: call HDCR_write(s_257_6)
        let s_257_7: () = HDCR_write(state, tracer, s_257_6);
        // N s_257_8: jump b258
        return block_258(state, tracer, fn_state);
    }
    fn block_258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_258_0: const #() : ()
        let s_258_0: () = ();
        // S s_258_1: call HDCR_read(s_258_0)
        let s_258_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_258_0);
        // D s_258_2: write-var ga#35928 <= s_258_1
        fn_state.ga_35928 = s_258_1;
        // D s_258_3: read-var ga#35928.0:struct
        let s_258_3: u32 = fn_state.ga_35928._0;
        // C s_258_4: const #5s : i
        let s_258_4: i128 = 5;
        // C s_258_5: const #12s : i
        let s_258_5: i128 = 12;
        // D s_258_6: cast zx s_258_3 -> bv
        let s_258_6: Bits = Bits::new(s_258_3 as u128, 32u16);
        // C s_258_7: const #0u : u8
        let s_258_7: u8 = 0;
        // C s_258_8: cast zx s_258_7 -> bv
        let s_258_8: Bits = Bits::new(s_258_7 as u128, 5u16);
        // C s_258_9: const #1u : u64
        let s_258_9: u64 = 1;
        // C s_258_10: cast zx s_258_9 -> bv
        let s_258_10: Bits = Bits::new(s_258_9 as u128, 64u16);
        // C s_258_11: lsl s_258_10 s_258_4
        let s_258_11: Bits = s_258_10 << s_258_4;
        // C s_258_12: sub s_258_11 s_258_10
        let s_258_12: Bits = ((s_258_11) - (s_258_10));
        // C s_258_13: and s_258_8 s_258_12
        let s_258_13: Bits = ((s_258_8) & (s_258_12));
        // C s_258_14: lsl s_258_13 s_258_5
        let s_258_14: Bits = s_258_13 << s_258_5;
        // C s_258_15: lsl s_258_12 s_258_5
        let s_258_15: Bits = s_258_12 << s_258_5;
        // C s_258_16: cmpl s_258_15
        let s_258_16: Bits = !s_258_15;
        // D s_258_17: and s_258_6 s_258_16
        let s_258_17: Bits = ((s_258_6) & (s_258_16));
        // D s_258_18: or s_258_17 s_258_14
        let s_258_18: Bits = ((s_258_17) | (s_258_14));
        // D s_258_19: cast reint s_258_18 -> u32
        let s_258_19: u32 = (s_258_18.value() as u32);
        // D s_258_20: call Mk_HDCR_Type(s_258_19)
        let s_258_20: ProductType700c18a878c5601b = Mk_HDCR_Type(
            state,
            tracer,
            s_258_19,
        );
        // D s_258_21: call HDCR_write(s_258_20)
        let s_258_21: () = HDCR_write(state, tracer, s_258_20);
        // D s_258_22: read-var cold:u8
        let s_258_22: bool = fn_state.cold;
        // D s_258_23: not s_258_22
        let s_258_23: bool = !s_258_22;
        // N s_258_24: branch s_258_23 b522 b259
        if s_258_23 {
            return block_522(state, tracer, fn_state);
        } else {
            return block_259(state, tracer, fn_state);
        };
    }
    fn block_259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_259_0: const #0u : u8
        let s_259_0: bool = false;
        // D s_259_1: write-var gs#44425 <= s_259_0
        fn_state.gs_44425 = s_259_0;
        // N s_259_2: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_260_0: read-var gs#44425:u8
        let s_260_0: bool = fn_state.gs_44425;
        // N s_260_1: branch s_260_0 b521 b261
        if s_260_0 {
            return block_521(state, tracer, fn_state);
        } else {
            return block_261(state, tracer, fn_state);
        };
    }
    fn block_261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_261_0: const #() : ()
        let s_261_0: () = ();
        // S s_261_1: call HDCR_read(s_261_0)
        let s_261_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_261_0);
        // C s_261_2: const #1s : i64
        let s_261_2: i64 = 1;
        // C s_261_3: cast zx s_261_2 -> i
        let s_261_3: i128 = (i128::try_from(s_261_2).unwrap());
        // S s_261_4: call __UNKNOWN_bits(s_261_3)
        let s_261_4: Bits = u__UNKNOWN_bits(state, tracer, s_261_3);
        // S s_261_5: cast reint s_261_4 -> u8
        let s_261_5: bool = ((s_261_4.value()) != 0);
        // S s_261_6: call _update_HDCR_Type_TDRA(s_261_1, s_261_5)
        let s_261_6: ProductType700c18a878c5601b = u_update_HDCR_Type_TDRA(
            state,
            tracer,
            s_261_1,
            s_261_5,
        );
        // S s_261_7: call HDCR_write(s_261_6)
        let s_261_7: () = HDCR_write(state, tracer, s_261_6);
        // N s_261_8: jump b262
        return block_262(state, tracer, fn_state);
    }
    fn block_262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_262_0: read-var cold:u8
        let s_262_0: bool = fn_state.cold;
        // D s_262_1: not s_262_0
        let s_262_1: bool = !s_262_0;
        // N s_262_2: branch s_262_1 b520 b263
        if s_262_1 {
            return block_520(state, tracer, fn_state);
        } else {
            return block_263(state, tracer, fn_state);
        };
    }
    fn block_263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_263_0: const #0u : u8
        let s_263_0: bool = false;
        // D s_263_1: write-var gs#44426 <= s_263_0
        fn_state.gs_44426 = s_263_0;
        // N s_263_2: jump b264
        return block_264(state, tracer, fn_state);
    }
    fn block_264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_264_0: read-var gs#44426:u8
        let s_264_0: bool = fn_state.gs_44426;
        // N s_264_1: branch s_264_0 b519 b265
        if s_264_0 {
            return block_519(state, tracer, fn_state);
        } else {
            return block_265(state, tracer, fn_state);
        };
    }
    fn block_265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_265_0: const #() : ()
        let s_265_0: () = ();
        // S s_265_1: call HDCR_read(s_265_0)
        let s_265_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_265_0);
        // C s_265_2: const #1s : i64
        let s_265_2: i64 = 1;
        // C s_265_3: cast zx s_265_2 -> i
        let s_265_3: i128 = (i128::try_from(s_265_2).unwrap());
        // S s_265_4: call __UNKNOWN_bits(s_265_3)
        let s_265_4: Bits = u__UNKNOWN_bits(state, tracer, s_265_3);
        // S s_265_5: cast reint s_265_4 -> u8
        let s_265_5: bool = ((s_265_4.value()) != 0);
        // S s_265_6: call _update_HDCR_Type_TDOSA(s_265_1, s_265_5)
        let s_265_6: ProductType700c18a878c5601b = u_update_HDCR_Type_TDOSA(
            state,
            tracer,
            s_265_1,
            s_265_5,
        );
        // S s_265_7: call HDCR_write(s_265_6)
        let s_265_7: () = HDCR_write(state, tracer, s_265_6);
        // N s_265_8: jump b266
        return block_266(state, tracer, fn_state);
    }
    fn block_266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_266_0: read-var cold:u8
        let s_266_0: bool = fn_state.cold;
        // D s_266_1: not s_266_0
        let s_266_1: bool = !s_266_0;
        // N s_266_2: branch s_266_1 b518 b267
        if s_266_1 {
            return block_518(state, tracer, fn_state);
        } else {
            return block_267(state, tracer, fn_state);
        };
    }
    fn block_267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_267_0: const #0u : u8
        let s_267_0: bool = false;
        // D s_267_1: write-var gs#44427 <= s_267_0
        fn_state.gs_44427 = s_267_0;
        // N s_267_2: jump b268
        return block_268(state, tracer, fn_state);
    }
    fn block_268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_268_0: read-var gs#44427:u8
        let s_268_0: bool = fn_state.gs_44427;
        // N s_268_1: branch s_268_0 b517 b269
        if s_268_0 {
            return block_517(state, tracer, fn_state);
        } else {
            return block_269(state, tracer, fn_state);
        };
    }
    fn block_269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_269_0: const #() : ()
        let s_269_0: () = ();
        // S s_269_1: call HDCR_read(s_269_0)
        let s_269_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_269_0);
        // C s_269_2: const #1s : i64
        let s_269_2: i64 = 1;
        // C s_269_3: cast zx s_269_2 -> i
        let s_269_3: i128 = (i128::try_from(s_269_2).unwrap());
        // S s_269_4: call __UNKNOWN_bits(s_269_3)
        let s_269_4: Bits = u__UNKNOWN_bits(state, tracer, s_269_3);
        // S s_269_5: cast reint s_269_4 -> u8
        let s_269_5: bool = ((s_269_4.value()) != 0);
        // S s_269_6: call _update_HDCR_Type_TDA(s_269_1, s_269_5)
        let s_269_6: ProductType700c18a878c5601b = u_update_HDCR_Type_TDA(
            state,
            tracer,
            s_269_1,
            s_269_5,
        );
        // S s_269_7: call HDCR_write(s_269_6)
        let s_269_7: () = HDCR_write(state, tracer, s_269_6);
        // N s_269_8: jump b270
        return block_270(state, tracer, fn_state);
    }
    fn block_270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_270_0: read-var cold:u8
        let s_270_0: bool = fn_state.cold;
        // D s_270_1: not s_270_0
        let s_270_1: bool = !s_270_0;
        // N s_270_2: branch s_270_1 b516 b271
        if s_270_1 {
            return block_516(state, tracer, fn_state);
        } else {
            return block_271(state, tracer, fn_state);
        };
    }
    fn block_271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_271_0: const #0u : u8
        let s_271_0: bool = false;
        // D s_271_1: write-var gs#44428 <= s_271_0
        fn_state.gs_44428 = s_271_0;
        // N s_271_2: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_272_0: read-var gs#44428:u8
        let s_272_0: bool = fn_state.gs_44428;
        // N s_272_1: branch s_272_0 b515 b273
        if s_272_0 {
            return block_515(state, tracer, fn_state);
        } else {
            return block_273(state, tracer, fn_state);
        };
    }
    fn block_273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_273_0: const #() : ()
        let s_273_0: () = ();
        // S s_273_1: call HDCR_read(s_273_0)
        let s_273_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_273_0);
        // C s_273_2: const #1s : i64
        let s_273_2: i64 = 1;
        // C s_273_3: cast zx s_273_2 -> i
        let s_273_3: i128 = (i128::try_from(s_273_2).unwrap());
        // S s_273_4: call __UNKNOWN_bits(s_273_3)
        let s_273_4: Bits = u__UNKNOWN_bits(state, tracer, s_273_3);
        // S s_273_5: cast reint s_273_4 -> u8
        let s_273_5: bool = ((s_273_4.value()) != 0);
        // S s_273_6: call _update_HDCR_Type_TDE(s_273_1, s_273_5)
        let s_273_6: ProductType700c18a878c5601b = u_update_HDCR_Type_TDE(
            state,
            tracer,
            s_273_1,
            s_273_5,
        );
        // S s_273_7: call HDCR_write(s_273_6)
        let s_273_7: () = HDCR_write(state, tracer, s_273_6);
        // N s_273_8: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_274_0: read-var cold:u8
        let s_274_0: bool = fn_state.cold;
        // D s_274_1: not s_274_0
        let s_274_1: bool = !s_274_0;
        // N s_274_2: branch s_274_1 b514 b275
        if s_274_1 {
            return block_514(state, tracer, fn_state);
        } else {
            return block_275(state, tracer, fn_state);
        };
    }
    fn block_275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_275_0: const #0u : u8
        let s_275_0: bool = false;
        // D s_275_1: write-var gs#44429 <= s_275_0
        fn_state.gs_44429 = s_275_0;
        // N s_275_2: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_276_0: read-var gs#44429:u8
        let s_276_0: bool = fn_state.gs_44429;
        // N s_276_1: branch s_276_0 b513 b277
        if s_276_0 {
            return block_513(state, tracer, fn_state);
        } else {
            return block_277(state, tracer, fn_state);
        };
    }
    fn block_277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_277_0: const #() : ()
        let s_277_0: () = ();
        // S s_277_1: call HDCR_read(s_277_0)
        let s_277_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_277_0);
        // C s_277_2: const #1s : i64
        let s_277_2: i64 = 1;
        // C s_277_3: cast zx s_277_2 -> i
        let s_277_3: i128 = (i128::try_from(s_277_2).unwrap());
        // S s_277_4: call __UNKNOWN_bits(s_277_3)
        let s_277_4: Bits = u__UNKNOWN_bits(state, tracer, s_277_3);
        // S s_277_5: cast reint s_277_4 -> u8
        let s_277_5: bool = ((s_277_4.value()) != 0);
        // S s_277_6: call _update_HDCR_Type_HPME(s_277_1, s_277_5)
        let s_277_6: ProductType700c18a878c5601b = u_update_HDCR_Type_HPME(
            state,
            tracer,
            s_277_1,
            s_277_5,
        );
        // S s_277_7: call HDCR_write(s_277_6)
        let s_277_7: () = HDCR_write(state, tracer, s_277_6);
        // N s_277_8: jump b278
        return block_278(state, tracer, fn_state);
    }
    fn block_278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_278_0: read-var cold:u8
        let s_278_0: bool = fn_state.cold;
        // D s_278_1: not s_278_0
        let s_278_1: bool = !s_278_0;
        // N s_278_2: branch s_278_1 b512 b279
        if s_278_1 {
            return block_512(state, tracer, fn_state);
        } else {
            return block_279(state, tracer, fn_state);
        };
    }
    fn block_279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_279_0: const #0u : u8
        let s_279_0: bool = false;
        // D s_279_1: write-var gs#44430 <= s_279_0
        fn_state.gs_44430 = s_279_0;
        // N s_279_2: jump b280
        return block_280(state, tracer, fn_state);
    }
    fn block_280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_280_0: read-var gs#44430:u8
        let s_280_0: bool = fn_state.gs_44430;
        // N s_280_1: branch s_280_0 b511 b281
        if s_280_0 {
            return block_511(state, tracer, fn_state);
        } else {
            return block_281(state, tracer, fn_state);
        };
    }
    fn block_281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_281_0: const #() : ()
        let s_281_0: () = ();
        // S s_281_1: call HDCR_read(s_281_0)
        let s_281_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_281_0);
        // C s_281_2: const #1s : i64
        let s_281_2: i64 = 1;
        // C s_281_3: cast zx s_281_2 -> i
        let s_281_3: i128 = (i128::try_from(s_281_2).unwrap());
        // S s_281_4: call __UNKNOWN_bits(s_281_3)
        let s_281_4: Bits = u__UNKNOWN_bits(state, tracer, s_281_3);
        // S s_281_5: cast reint s_281_4 -> u8
        let s_281_5: bool = ((s_281_4.value()) != 0);
        // S s_281_6: call _update_HDCR_Type_TPM(s_281_1, s_281_5)
        let s_281_6: ProductType700c18a878c5601b = u_update_HDCR_Type_TPM(
            state,
            tracer,
            s_281_1,
            s_281_5,
        );
        // S s_281_7: call HDCR_write(s_281_6)
        let s_281_7: () = HDCR_write(state, tracer, s_281_6);
        // N s_281_8: jump b282
        return block_282(state, tracer, fn_state);
    }
    fn block_282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_282_0: read-var cold:u8
        let s_282_0: bool = fn_state.cold;
        // D s_282_1: not s_282_0
        let s_282_1: bool = !s_282_0;
        // N s_282_2: branch s_282_1 b510 b283
        if s_282_1 {
            return block_510(state, tracer, fn_state);
        } else {
            return block_283(state, tracer, fn_state);
        };
    }
    fn block_283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_283_0: const #0u : u8
        let s_283_0: bool = false;
        // D s_283_1: write-var gs#44431 <= s_283_0
        fn_state.gs_44431 = s_283_0;
        // N s_283_2: jump b284
        return block_284(state, tracer, fn_state);
    }
    fn block_284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_284_0: read-var gs#44431:u8
        let s_284_0: bool = fn_state.gs_44431;
        // N s_284_1: branch s_284_0 b509 b285
        if s_284_0 {
            return block_509(state, tracer, fn_state);
        } else {
            return block_285(state, tracer, fn_state);
        };
    }
    fn block_285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_285_0: const #() : ()
        let s_285_0: () = ();
        // S s_285_1: call HDCR_read(s_285_0)
        let s_285_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_285_0);
        // C s_285_2: const #1s : i64
        let s_285_2: i64 = 1;
        // C s_285_3: cast zx s_285_2 -> i
        let s_285_3: i128 = (i128::try_from(s_285_2).unwrap());
        // S s_285_4: call __UNKNOWN_bits(s_285_3)
        let s_285_4: Bits = u__UNKNOWN_bits(state, tracer, s_285_3);
        // S s_285_5: cast reint s_285_4 -> u8
        let s_285_5: bool = ((s_285_4.value()) != 0);
        // S s_285_6: call _update_HDCR_Type_TPMCR(s_285_1, s_285_5)
        let s_285_6: ProductType700c18a878c5601b = u_update_HDCR_Type_TPMCR(
            state,
            tracer,
            s_285_1,
            s_285_5,
        );
        // S s_285_7: call HDCR_write(s_285_6)
        let s_285_7: () = HDCR_write(state, tracer, s_285_6);
        // N s_285_8: jump b286
        return block_286(state, tracer, fn_state);
    }
    fn block_286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_286_0: const #() : ()
        let s_286_0: () = ();
        // S s_286_1: call HDCR_read(s_286_0)
        let s_286_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_286_0);
        // C s_286_2: const #5s : i64
        let s_286_2: i64 = 5;
        // C s_286_3: cast zx s_286_2 -> i
        let s_286_3: i128 = (i128::try_from(s_286_2).unwrap());
        // S s_286_4: call __UNKNOWN_bits(s_286_3)
        let s_286_4: Bits = u__UNKNOWN_bits(state, tracer, s_286_3);
        // S s_286_5: cast reint s_286_4 -> u8
        let s_286_5: u8 = (s_286_4.value() as u8);
        // S s_286_6: call _update_HDCR_Type_HPMN(s_286_1, s_286_5)
        let s_286_6: ProductType700c18a878c5601b = u_update_HDCR_Type_HPMN(
            state,
            tracer,
            s_286_1,
            s_286_5,
        );
        // S s_286_7: call HDCR_write(s_286_6)
        let s_286_7: () = HDCR_write(state, tracer, s_286_6);
        // C s_286_8: const #() : ()
        let s_286_8: () = ();
        // S s_286_9: call ICC_HSRE_read(s_286_8)
        let s_286_9: ProductType700c18a878c5601b = ICC_HSRE_read(state, tracer, s_286_8);
        // D s_286_10: write-var ga#35994 <= s_286_9
        fn_state.ga_35994 = s_286_9;
        // D s_286_11: read-var ga#35994.0:struct
        let s_286_11: u32 = fn_state.ga_35994._0;
        // C s_286_12: const #28s : i
        let s_286_12: i128 = 28;
        // C s_286_13: const #4s : i
        let s_286_13: i128 = 4;
        // D s_286_14: cast zx s_286_11 -> bv
        let s_286_14: Bits = Bits::new(s_286_11 as u128, 32u16);
        // C s_286_15: const #0u : u28
        let s_286_15: u32 = 0;
        // C s_286_16: cast zx s_286_15 -> bv
        let s_286_16: Bits = Bits::new(s_286_15 as u128, 28u16);
        // C s_286_17: const #1u : u64
        let s_286_17: u64 = 1;
        // C s_286_18: cast zx s_286_17 -> bv
        let s_286_18: Bits = Bits::new(s_286_17 as u128, 64u16);
        // C s_286_19: lsl s_286_18 s_286_12
        let s_286_19: Bits = s_286_18 << s_286_12;
        // C s_286_20: sub s_286_19 s_286_18
        let s_286_20: Bits = ((s_286_19) - (s_286_18));
        // C s_286_21: and s_286_16 s_286_20
        let s_286_21: Bits = ((s_286_16) & (s_286_20));
        // C s_286_22: lsl s_286_21 s_286_13
        let s_286_22: Bits = s_286_21 << s_286_13;
        // C s_286_23: lsl s_286_20 s_286_13
        let s_286_23: Bits = s_286_20 << s_286_13;
        // C s_286_24: cmpl s_286_23
        let s_286_24: Bits = !s_286_23;
        // D s_286_25: and s_286_14 s_286_24
        let s_286_25: Bits = ((s_286_14) & (s_286_24));
        // D s_286_26: or s_286_25 s_286_22
        let s_286_26: Bits = ((s_286_25) | (s_286_22));
        // D s_286_27: cast reint s_286_26 -> u32
        let s_286_27: u32 = (s_286_26.value() as u32);
        // D s_286_28: call Mk_ICC_HSRE_Type(s_286_27)
        let s_286_28: ProductType700c18a878c5601b = Mk_ICC_HSRE_Type(
            state,
            tracer,
            s_286_27,
        );
        // D s_286_29: call ICC_HSRE_write(s_286_28)
        let s_286_29: () = ICC_HSRE_write(state, tracer, s_286_28);
        // C s_286_30: const #() : ()
        let s_286_30: () = ();
        // S s_286_31: call ICC_HSRE_read(s_286_30)
        let s_286_31: ProductType700c18a878c5601b = ICC_HSRE_read(
            state,
            tracer,
            s_286_30,
        );
        // C s_286_32: const #0u : u8
        let s_286_32: bool = false;
        // S s_286_33: call _update_ICC_HSRE_Type_DIB(s_286_31, s_286_32)
        let s_286_33: ProductType700c18a878c5601b = u_update_ICC_HSRE_Type_DIB(
            state,
            tracer,
            s_286_31,
            s_286_32,
        );
        // S s_286_34: call ICC_HSRE_write(s_286_33)
        let s_286_34: () = ICC_HSRE_write(state, tracer, s_286_33);
        // C s_286_35: const #() : ()
        let s_286_35: () = ();
        // S s_286_36: call ICC_HSRE_read(s_286_35)
        let s_286_36: ProductType700c18a878c5601b = ICC_HSRE_read(
            state,
            tracer,
            s_286_35,
        );
        // C s_286_37: const #0u : u8
        let s_286_37: bool = false;
        // S s_286_38: call _update_ICC_HSRE_Type_DFB(s_286_36, s_286_37)
        let s_286_38: ProductType700c18a878c5601b = u_update_ICC_HSRE_Type_DFB(
            state,
            tracer,
            s_286_36,
            s_286_37,
        );
        // S s_286_39: call ICC_HSRE_write(s_286_38)
        let s_286_39: () = ICC_HSRE_write(state, tracer, s_286_38);
        // C s_286_40: const #() : ()
        let s_286_40: () = ();
        // S s_286_41: call ICC_HSRE_read(s_286_40)
        let s_286_41: ProductType700c18a878c5601b = ICC_HSRE_read(
            state,
            tracer,
            s_286_40,
        );
        // C s_286_42: const #0u : u8
        let s_286_42: bool = false;
        // S s_286_43: call _update_ICC_HSRE_Type_SRE(s_286_41, s_286_42)
        let s_286_43: ProductType700c18a878c5601b = u_update_ICC_HSRE_Type_SRE(
            state,
            tracer,
            s_286_41,
            s_286_42,
        );
        // S s_286_44: call ICC_HSRE_write(s_286_43)
        let s_286_44: () = ICC_HSRE_write(state, tracer, s_286_43);
        // C s_286_45: const #() : ()
        let s_286_45: () = ();
        // S s_286_46: call PMCCFILTR_read(s_286_45)
        let s_286_46: ProductType700c18a878c5601b = PMCCFILTR_read(
            state,
            tracer,
            s_286_45,
        );
        // C s_286_47: const #0u : u8
        let s_286_47: bool = false;
        // S s_286_48: call _update_PMCCFILTR_Type_P(s_286_46, s_286_47)
        let s_286_48: ProductType700c18a878c5601b = u_update_PMCCFILTR_Type_P(
            state,
            tracer,
            s_286_46,
            s_286_47,
        );
        // S s_286_49: call PMCCFILTR_write(s_286_48)
        let s_286_49: () = PMCCFILTR_write(state, tracer, s_286_48);
        // C s_286_50: const #() : ()
        let s_286_50: () = ();
        // S s_286_51: call PMCCFILTR_read(s_286_50)
        let s_286_51: ProductType700c18a878c5601b = PMCCFILTR_read(
            state,
            tracer,
            s_286_50,
        );
        // C s_286_52: const #0u : u8
        let s_286_52: bool = false;
        // S s_286_53: call _update_PMCCFILTR_Type_U(s_286_51, s_286_52)
        let s_286_53: ProductType700c18a878c5601b = u_update_PMCCFILTR_Type_U(
            state,
            tracer,
            s_286_51,
            s_286_52,
        );
        // S s_286_54: call PMCCFILTR_write(s_286_53)
        let s_286_54: () = PMCCFILTR_write(state, tracer, s_286_53);
        // C s_286_55: const #() : ()
        let s_286_55: () = ();
        // S s_286_56: call PMCCFILTR_read(s_286_55)
        let s_286_56: ProductType700c18a878c5601b = PMCCFILTR_read(
            state,
            tracer,
            s_286_55,
        );
        // C s_286_57: const #0u : u8
        let s_286_57: bool = false;
        // S s_286_58: call _update_PMCCFILTR_Type_NSK(s_286_56, s_286_57)
        let s_286_58: ProductType700c18a878c5601b = u_update_PMCCFILTR_Type_NSK(
            state,
            tracer,
            s_286_56,
            s_286_57,
        );
        // S s_286_59: call PMCCFILTR_write(s_286_58)
        let s_286_59: () = PMCCFILTR_write(state, tracer, s_286_58);
        // C s_286_60: const #() : ()
        let s_286_60: () = ();
        // S s_286_61: call PMCCFILTR_read(s_286_60)
        let s_286_61: ProductType700c18a878c5601b = PMCCFILTR_read(
            state,
            tracer,
            s_286_60,
        );
        // C s_286_62: const #0u : u8
        let s_286_62: bool = false;
        // S s_286_63: call _update_PMCCFILTR_Type_NSU(s_286_61, s_286_62)
        let s_286_63: ProductType700c18a878c5601b = u_update_PMCCFILTR_Type_NSU(
            state,
            tracer,
            s_286_61,
            s_286_62,
        );
        // S s_286_64: call PMCCFILTR_write(s_286_63)
        let s_286_64: () = PMCCFILTR_write(state, tracer, s_286_63);
        // C s_286_65: const #() : ()
        let s_286_65: () = ();
        // S s_286_66: call PMCCFILTR_read(s_286_65)
        let s_286_66: ProductType700c18a878c5601b = PMCCFILTR_read(
            state,
            tracer,
            s_286_65,
        );
        // C s_286_67: const #0u : u8
        let s_286_67: bool = false;
        // S s_286_68: call _update_PMCCFILTR_Type_NSH(s_286_66, s_286_67)
        let s_286_68: ProductType700c18a878c5601b = u_update_PMCCFILTR_Type_NSH(
            state,
            tracer,
            s_286_66,
            s_286_67,
        );
        // S s_286_69: call PMCCFILTR_write(s_286_68)
        let s_286_69: () = PMCCFILTR_write(state, tracer, s_286_68);
        // C s_286_70: const #() : ()
        let s_286_70: () = ();
        // S s_286_71: call PMCCFILTR_read(s_286_70)
        let s_286_71: ProductType700c18a878c5601b = PMCCFILTR_read(
            state,
            tracer,
            s_286_70,
        );
        // D s_286_72: write-var ga#36014 <= s_286_71
        fn_state.ga_36014 = s_286_71;
        // D s_286_73: read-var ga#36014.0:struct
        let s_286_73: u32 = fn_state.ga_36014._0;
        // C s_286_74: const #5s : i
        let s_286_74: i128 = 5;
        // C s_286_75: const #22s : i
        let s_286_75: i128 = 22;
        // D s_286_76: cast zx s_286_73 -> bv
        let s_286_76: Bits = Bits::new(s_286_73 as u128, 32u16);
        // C s_286_77: const #0u : u8
        let s_286_77: u8 = 0;
        // C s_286_78: cast zx s_286_77 -> bv
        let s_286_78: Bits = Bits::new(s_286_77 as u128, 5u16);
        // C s_286_79: const #1u : u64
        let s_286_79: u64 = 1;
        // C s_286_80: cast zx s_286_79 -> bv
        let s_286_80: Bits = Bits::new(s_286_79 as u128, 64u16);
        // C s_286_81: lsl s_286_80 s_286_74
        let s_286_81: Bits = s_286_80 << s_286_74;
        // C s_286_82: sub s_286_81 s_286_80
        let s_286_82: Bits = ((s_286_81) - (s_286_80));
        // C s_286_83: and s_286_78 s_286_82
        let s_286_83: Bits = ((s_286_78) & (s_286_82));
        // C s_286_84: lsl s_286_83 s_286_75
        let s_286_84: Bits = s_286_83 << s_286_75;
        // C s_286_85: lsl s_286_82 s_286_75
        let s_286_85: Bits = s_286_82 << s_286_75;
        // C s_286_86: cmpl s_286_85
        let s_286_86: Bits = !s_286_85;
        // D s_286_87: and s_286_76 s_286_86
        let s_286_87: Bits = ((s_286_76) & (s_286_86));
        // D s_286_88: or s_286_87 s_286_84
        let s_286_88: Bits = ((s_286_87) | (s_286_84));
        // D s_286_89: cast reint s_286_88 -> u32
        let s_286_89: u32 = (s_286_88.value() as u32);
        // D s_286_90: call Mk_PMCCFILTR_Type(s_286_89)
        let s_286_90: ProductType700c18a878c5601b = Mk_PMCCFILTR_Type(
            state,
            tracer,
            s_286_89,
        );
        // D s_286_91: call PMCCFILTR_write(s_286_90)
        let s_286_91: () = PMCCFILTR_write(state, tracer, s_286_90);
        // C s_286_92: const #() : ()
        let s_286_92: () = ();
        // S s_286_93: call PMCCFILTR_read(s_286_92)
        let s_286_93: ProductType700c18a878c5601b = PMCCFILTR_read(
            state,
            tracer,
            s_286_92,
        );
        // D s_286_94: write-var ga#36018 <= s_286_93
        fn_state.ga_36018 = s_286_93;
        // D s_286_95: read-var ga#36018.0:struct
        let s_286_95: u32 = fn_state.ga_36018._0;
        // C s_286_96: const #21s : i
        let s_286_96: i128 = 21;
        // C s_286_97: const #0s : i
        let s_286_97: i128 = 0;
        // D s_286_98: cast zx s_286_95 -> bv
        let s_286_98: Bits = Bits::new(s_286_95 as u128, 32u16);
        // C s_286_99: const #0u : u21
        let s_286_99: u32 = 0;
        // C s_286_100: cast zx s_286_99 -> bv
        let s_286_100: Bits = Bits::new(s_286_99 as u128, 21u16);
        // C s_286_101: const #1u : u64
        let s_286_101: u64 = 1;
        // C s_286_102: cast zx s_286_101 -> bv
        let s_286_102: Bits = Bits::new(s_286_101 as u128, 64u16);
        // C s_286_103: lsl s_286_102 s_286_96
        let s_286_103: Bits = s_286_102 << s_286_96;
        // C s_286_104: sub s_286_103 s_286_102
        let s_286_104: Bits = ((s_286_103) - (s_286_102));
        // C s_286_105: and s_286_100 s_286_104
        let s_286_105: Bits = ((s_286_100) & (s_286_104));
        // C s_286_106: lsl s_286_105 s_286_97
        let s_286_106: Bits = s_286_105 << s_286_97;
        // C s_286_107: lsl s_286_104 s_286_97
        let s_286_107: Bits = s_286_104 << s_286_97;
        // C s_286_108: cmpl s_286_107
        let s_286_108: Bits = !s_286_107;
        // D s_286_109: and s_286_98 s_286_108
        let s_286_109: Bits = ((s_286_98) & (s_286_108));
        // D s_286_110: or s_286_109 s_286_106
        let s_286_110: Bits = ((s_286_109) | (s_286_106));
        // D s_286_111: cast reint s_286_110 -> u32
        let s_286_111: u32 = (s_286_110.value() as u32);
        // D s_286_112: call Mk_PMCCFILTR_Type(s_286_111)
        let s_286_112: ProductType700c18a878c5601b = Mk_PMCCFILTR_Type(
            state,
            tracer,
            s_286_111,
        );
        // D s_286_113: call PMCCFILTR_write(s_286_112)
        let s_286_113: () = PMCCFILTR_write(state, tracer, s_286_112);
        // C s_286_114: const #() : ()
        let s_286_114: () = ();
        // S s_286_115: call ID_ISAR5_read(s_286_114)
        let s_286_115: ProductType700c18a878c5601b = ID_ISAR5_read(
            state,
            tracer,
            s_286_114,
        );
        // D s_286_116: write-var ga#36022 <= s_286_115
        fn_state.ga_36022 = s_286_115;
        // D s_286_117: read-var ga#36022.0:struct
        let s_286_117: u32 = fn_state.ga_36022._0;
        // C s_286_118: const #4s : i
        let s_286_118: i128 = 4;
        // C s_286_119: const #20s : i
        let s_286_119: i128 = 20;
        // D s_286_120: cast zx s_286_117 -> bv
        let s_286_120: Bits = Bits::new(s_286_117 as u128, 32u16);
        // C s_286_121: const #0u : u8
        let s_286_121: u8 = 0;
        // C s_286_122: cast zx s_286_121 -> bv
        let s_286_122: Bits = Bits::new(s_286_121 as u128, 4u16);
        // C s_286_123: const #1u : u64
        let s_286_123: u64 = 1;
        // C s_286_124: cast zx s_286_123 -> bv
        let s_286_124: Bits = Bits::new(s_286_123 as u128, 64u16);
        // C s_286_125: lsl s_286_124 s_286_118
        let s_286_125: Bits = s_286_124 << s_286_118;
        // C s_286_126: sub s_286_125 s_286_124
        let s_286_126: Bits = ((s_286_125) - (s_286_124));
        // C s_286_127: and s_286_122 s_286_126
        let s_286_127: Bits = ((s_286_122) & (s_286_126));
        // C s_286_128: lsl s_286_127 s_286_119
        let s_286_128: Bits = s_286_127 << s_286_119;
        // C s_286_129: lsl s_286_126 s_286_119
        let s_286_129: Bits = s_286_126 << s_286_119;
        // C s_286_130: cmpl s_286_129
        let s_286_130: Bits = !s_286_129;
        // D s_286_131: and s_286_120 s_286_130
        let s_286_131: Bits = ((s_286_120) & (s_286_130));
        // D s_286_132: or s_286_131 s_286_128
        let s_286_132: Bits = ((s_286_131) | (s_286_128));
        // D s_286_133: cast reint s_286_132 -> u32
        let s_286_133: u32 = (s_286_132.value() as u32);
        // D s_286_134: call Mk_ID_ISAR5_Type(s_286_133)
        let s_286_134: ProductType700c18a878c5601b = Mk_ID_ISAR5_Type(
            state,
            tracer,
            s_286_133,
        );
        // D s_286_135: call ID_ISAR5_write(s_286_134)
        let s_286_135: () = ID_ISAR5_write(state, tracer, s_286_134);
        // C s_286_136: const #() : ()
        let s_286_136: () = ();
        // S s_286_137: call HTCR_read(s_286_136)
        let s_286_137: ProductType700c18a878c5601b = HTCR_read(state, tracer, s_286_136);
        // D s_286_138: write-var ga#36026 <= s_286_137
        fn_state.ga_36026 = s_286_137;
        // D s_286_139: read-var ga#36026.0:struct
        let s_286_139: u32 = fn_state.ga_36026._0;
        // C s_286_140: const #1s : i
        let s_286_140: i128 = 1;
        // C s_286_141: const #31s : i
        let s_286_141: i128 = 31;
        // D s_286_142: cast zx s_286_139 -> bv
        let s_286_142: Bits = Bits::new(s_286_139 as u128, 32u16);
        // C s_286_143: const #1u : u8
        let s_286_143: bool = true;
        // C s_286_144: cast zx s_286_143 -> bv
        let s_286_144: Bits = Bits::new(s_286_143 as u128, 1u16);
        // C s_286_145: const #1u : u64
        let s_286_145: u64 = 1;
        // C s_286_146: cast zx s_286_145 -> bv
        let s_286_146: Bits = Bits::new(s_286_145 as u128, 64u16);
        // C s_286_147: lsl s_286_146 s_286_140
        let s_286_147: Bits = s_286_146 << s_286_140;
        // C s_286_148: sub s_286_147 s_286_146
        let s_286_148: Bits = ((s_286_147) - (s_286_146));
        // C s_286_149: and s_286_144 s_286_148
        let s_286_149: Bits = ((s_286_144) & (s_286_148));
        // C s_286_150: lsl s_286_149 s_286_141
        let s_286_150: Bits = s_286_149 << s_286_141;
        // C s_286_151: lsl s_286_148 s_286_141
        let s_286_151: Bits = s_286_148 << s_286_141;
        // C s_286_152: cmpl s_286_151
        let s_286_152: Bits = !s_286_151;
        // D s_286_153: and s_286_142 s_286_152
        let s_286_153: Bits = ((s_286_142) & (s_286_152));
        // D s_286_154: or s_286_153 s_286_150
        let s_286_154: Bits = ((s_286_153) | (s_286_150));
        // D s_286_155: cast reint s_286_154 -> u32
        let s_286_155: u32 = (s_286_154.value() as u32);
        // D s_286_156: call Mk_HTCR_Type(s_286_155)
        let s_286_156: ProductType700c18a878c5601b = Mk_HTCR_Type(
            state,
            tracer,
            s_286_155,
        );
        // D s_286_157: call HTCR_write(s_286_156)
        let s_286_157: () = HTCR_write(state, tracer, s_286_156);
        // C s_286_158: const #() : ()
        let s_286_158: () = ();
        // S s_286_159: call HTCR_read(s_286_158)
        let s_286_159: ProductType700c18a878c5601b = HTCR_read(state, tracer, s_286_158);
        // D s_286_160: write-var ga#36030 <= s_286_159
        fn_state.ga_36030 = s_286_159;
        // D s_286_161: read-var ga#36030.0:struct
        let s_286_161: u32 = fn_state.ga_36030._0;
        // C s_286_162: const #1s : i
        let s_286_162: i128 = 1;
        // C s_286_163: const #29s : i
        let s_286_163: i128 = 29;
        // D s_286_164: cast zx s_286_161 -> bv
        let s_286_164: Bits = Bits::new(s_286_161 as u128, 32u16);
        // C s_286_165: const #0u : u8
        let s_286_165: bool = false;
        // C s_286_166: cast zx s_286_165 -> bv
        let s_286_166: Bits = Bits::new(s_286_165 as u128, 1u16);
        // C s_286_167: const #1u : u64
        let s_286_167: u64 = 1;
        // C s_286_168: cast zx s_286_167 -> bv
        let s_286_168: Bits = Bits::new(s_286_167 as u128, 64u16);
        // C s_286_169: lsl s_286_168 s_286_162
        let s_286_169: Bits = s_286_168 << s_286_162;
        // C s_286_170: sub s_286_169 s_286_168
        let s_286_170: Bits = ((s_286_169) - (s_286_168));
        // C s_286_171: and s_286_166 s_286_170
        let s_286_171: Bits = ((s_286_166) & (s_286_170));
        // C s_286_172: lsl s_286_171 s_286_163
        let s_286_172: Bits = s_286_171 << s_286_163;
        // C s_286_173: lsl s_286_170 s_286_163
        let s_286_173: Bits = s_286_170 << s_286_163;
        // C s_286_174: cmpl s_286_173
        let s_286_174: Bits = !s_286_173;
        // D s_286_175: and s_286_164 s_286_174
        let s_286_175: Bits = ((s_286_164) & (s_286_174));
        // D s_286_176: or s_286_175 s_286_172
        let s_286_176: Bits = ((s_286_175) | (s_286_172));
        // D s_286_177: cast reint s_286_176 -> u32
        let s_286_177: u32 = (s_286_176.value() as u32);
        // D s_286_178: call Mk_HTCR_Type(s_286_177)
        let s_286_178: ProductType700c18a878c5601b = Mk_HTCR_Type(
            state,
            tracer,
            s_286_177,
        );
        // D s_286_179: call HTCR_write(s_286_178)
        let s_286_179: () = HTCR_write(state, tracer, s_286_178);
        // C s_286_180: const #() : ()
        let s_286_180: () = ();
        // S s_286_181: call HTCR_read(s_286_180)
        let s_286_181: ProductType700c18a878c5601b = HTCR_read(state, tracer, s_286_180);
        // D s_286_182: write-var ga#36034 <= s_286_181
        fn_state.ga_36034 = s_286_181;
        // D s_286_183: read-var ga#36034.0:struct
        let s_286_183: u32 = fn_state.ga_36034._0;
        // C s_286_184: const #1s : i
        let s_286_184: i128 = 1;
        // C s_286_185: const #23s : i
        let s_286_185: i128 = 23;
        // D s_286_186: cast zx s_286_183 -> bv
        let s_286_186: Bits = Bits::new(s_286_183 as u128, 32u16);
        // C s_286_187: const #1u : u8
        let s_286_187: bool = true;
        // C s_286_188: cast zx s_286_187 -> bv
        let s_286_188: Bits = Bits::new(s_286_187 as u128, 1u16);
        // C s_286_189: const #1u : u64
        let s_286_189: u64 = 1;
        // C s_286_190: cast zx s_286_189 -> bv
        let s_286_190: Bits = Bits::new(s_286_189 as u128, 64u16);
        // C s_286_191: lsl s_286_190 s_286_184
        let s_286_191: Bits = s_286_190 << s_286_184;
        // C s_286_192: sub s_286_191 s_286_190
        let s_286_192: Bits = ((s_286_191) - (s_286_190));
        // C s_286_193: and s_286_188 s_286_192
        let s_286_193: Bits = ((s_286_188) & (s_286_192));
        // C s_286_194: lsl s_286_193 s_286_185
        let s_286_194: Bits = s_286_193 << s_286_185;
        // C s_286_195: lsl s_286_192 s_286_185
        let s_286_195: Bits = s_286_192 << s_286_185;
        // C s_286_196: cmpl s_286_195
        let s_286_196: Bits = !s_286_195;
        // D s_286_197: and s_286_186 s_286_196
        let s_286_197: Bits = ((s_286_186) & (s_286_196));
        // D s_286_198: or s_286_197 s_286_194
        let s_286_198: Bits = ((s_286_197) | (s_286_194));
        // D s_286_199: cast reint s_286_198 -> u32
        let s_286_199: u32 = (s_286_198.value() as u32);
        // D s_286_200: call Mk_HTCR_Type(s_286_199)
        let s_286_200: ProductType700c18a878c5601b = Mk_HTCR_Type(
            state,
            tracer,
            s_286_199,
        );
        // D s_286_201: call HTCR_write(s_286_200)
        let s_286_201: () = HTCR_write(state, tracer, s_286_200);
        // C s_286_202: const #() : ()
        let s_286_202: () = ();
        // S s_286_203: call HTCR_read(s_286_202)
        let s_286_203: ProductType700c18a878c5601b = HTCR_read(state, tracer, s_286_202);
        // D s_286_204: write-var ga#36038 <= s_286_203
        fn_state.ga_36038 = s_286_203;
        // D s_286_205: read-var ga#36038.0:struct
        let s_286_205: u32 = fn_state.ga_36038._0;
        // C s_286_206: const #9s : i
        let s_286_206: i128 = 9;
        // C s_286_207: const #14s : i
        let s_286_207: i128 = 14;
        // D s_286_208: cast zx s_286_205 -> bv
        let s_286_208: Bits = Bits::new(s_286_205 as u128, 32u16);
        // C s_286_209: const #0u : u9
        let s_286_209: u16 = 0;
        // C s_286_210: cast zx s_286_209 -> bv
        let s_286_210: Bits = Bits::new(s_286_209 as u128, 9u16);
        // C s_286_211: const #1u : u64
        let s_286_211: u64 = 1;
        // C s_286_212: cast zx s_286_211 -> bv
        let s_286_212: Bits = Bits::new(s_286_211 as u128, 64u16);
        // C s_286_213: lsl s_286_212 s_286_206
        let s_286_213: Bits = s_286_212 << s_286_206;
        // C s_286_214: sub s_286_213 s_286_212
        let s_286_214: Bits = ((s_286_213) - (s_286_212));
        // C s_286_215: and s_286_210 s_286_214
        let s_286_215: Bits = ((s_286_210) & (s_286_214));
        // C s_286_216: lsl s_286_215 s_286_207
        let s_286_216: Bits = s_286_215 << s_286_207;
        // C s_286_217: lsl s_286_214 s_286_207
        let s_286_217: Bits = s_286_214 << s_286_207;
        // C s_286_218: cmpl s_286_217
        let s_286_218: Bits = !s_286_217;
        // D s_286_219: and s_286_208 s_286_218
        let s_286_219: Bits = ((s_286_208) & (s_286_218));
        // D s_286_220: or s_286_219 s_286_216
        let s_286_220: Bits = ((s_286_219) | (s_286_216));
        // D s_286_221: cast reint s_286_220 -> u32
        let s_286_221: u32 = (s_286_220.value() as u32);
        // D s_286_222: call Mk_HTCR_Type(s_286_221)
        let s_286_222: ProductType700c18a878c5601b = Mk_HTCR_Type(
            state,
            tracer,
            s_286_221,
        );
        // D s_286_223: call HTCR_write(s_286_222)
        let s_286_223: () = HTCR_write(state, tracer, s_286_222);
        // C s_286_224: const #() : ()
        let s_286_224: () = ();
        // S s_286_225: call HTCR_read(s_286_224)
        let s_286_225: ProductType700c18a878c5601b = HTCR_read(state, tracer, s_286_224);
        // D s_286_226: write-var ga#36042 <= s_286_225
        fn_state.ga_36042 = s_286_225;
        // D s_286_227: read-var ga#36042.0:struct
        let s_286_227: u32 = fn_state.ga_36042._0;
        // C s_286_228: const #5s : i
        let s_286_228: i128 = 5;
        // C s_286_229: const #3s : i
        let s_286_229: i128 = 3;
        // D s_286_230: cast zx s_286_227 -> bv
        let s_286_230: Bits = Bits::new(s_286_227 as u128, 32u16);
        // C s_286_231: const #0u : u8
        let s_286_231: u8 = 0;
        // C s_286_232: cast zx s_286_231 -> bv
        let s_286_232: Bits = Bits::new(s_286_231 as u128, 5u16);
        // C s_286_233: const #1u : u64
        let s_286_233: u64 = 1;
        // C s_286_234: cast zx s_286_233 -> bv
        let s_286_234: Bits = Bits::new(s_286_233 as u128, 64u16);
        // C s_286_235: lsl s_286_234 s_286_228
        let s_286_235: Bits = s_286_234 << s_286_228;
        // C s_286_236: sub s_286_235 s_286_234
        let s_286_236: Bits = ((s_286_235) - (s_286_234));
        // C s_286_237: and s_286_232 s_286_236
        let s_286_237: Bits = ((s_286_232) & (s_286_236));
        // C s_286_238: lsl s_286_237 s_286_229
        let s_286_238: Bits = s_286_237 << s_286_229;
        // C s_286_239: lsl s_286_236 s_286_229
        let s_286_239: Bits = s_286_236 << s_286_229;
        // C s_286_240: cmpl s_286_239
        let s_286_240: Bits = !s_286_239;
        // D s_286_241: and s_286_230 s_286_240
        let s_286_241: Bits = ((s_286_230) & (s_286_240));
        // D s_286_242: or s_286_241 s_286_238
        let s_286_242: Bits = ((s_286_241) | (s_286_238));
        // D s_286_243: cast reint s_286_242 -> u32
        let s_286_243: u32 = (s_286_242.value() as u32);
        // D s_286_244: call Mk_HTCR_Type(s_286_243)
        let s_286_244: ProductType700c18a878c5601b = Mk_HTCR_Type(
            state,
            tracer,
            s_286_243,
        );
        // D s_286_245: call HTCR_write(s_286_244)
        let s_286_245: () = HTCR_write(state, tracer, s_286_244);
        // C s_286_246: const #() : ()
        let s_286_246: () = ();
        // S s_286_247: call ICC_PMR_read(s_286_246)
        let s_286_247: ProductType700c18a878c5601b = ICC_PMR_read(
            state,
            tracer,
            s_286_246,
        );
        // D s_286_248: write-var ga#36046 <= s_286_247
        fn_state.ga_36046 = s_286_247;
        // D s_286_249: read-var ga#36046.0:struct
        let s_286_249: u32 = fn_state.ga_36046._0;
        // C s_286_250: const #24s : i
        let s_286_250: i128 = 24;
        // C s_286_251: const #8s : i
        let s_286_251: i128 = 8;
        // D s_286_252: cast zx s_286_249 -> bv
        let s_286_252: Bits = Bits::new(s_286_249 as u128, 32u16);
        // C s_286_253: const #0u : u24
        let s_286_253: u32 = 0;
        // C s_286_254: cast zx s_286_253 -> bv
        let s_286_254: Bits = Bits::new(s_286_253 as u128, 24u16);
        // C s_286_255: const #1u : u64
        let s_286_255: u64 = 1;
        // C s_286_256: cast zx s_286_255 -> bv
        let s_286_256: Bits = Bits::new(s_286_255 as u128, 64u16);
        // C s_286_257: lsl s_286_256 s_286_250
        let s_286_257: Bits = s_286_256 << s_286_250;
        // C s_286_258: sub s_286_257 s_286_256
        let s_286_258: Bits = ((s_286_257) - (s_286_256));
        // C s_286_259: and s_286_254 s_286_258
        let s_286_259: Bits = ((s_286_254) & (s_286_258));
        // C s_286_260: lsl s_286_259 s_286_251
        let s_286_260: Bits = s_286_259 << s_286_251;
        // C s_286_261: lsl s_286_258 s_286_251
        let s_286_261: Bits = s_286_258 << s_286_251;
        // C s_286_262: cmpl s_286_261
        let s_286_262: Bits = !s_286_261;
        // D s_286_263: and s_286_252 s_286_262
        let s_286_263: Bits = ((s_286_252) & (s_286_262));
        // D s_286_264: or s_286_263 s_286_260
        let s_286_264: Bits = ((s_286_263) | (s_286_260));
        // D s_286_265: cast reint s_286_264 -> u32
        let s_286_265: u32 = (s_286_264.value() as u32);
        // D s_286_266: call Mk_ICC_PMR_Type(s_286_265)
        let s_286_266: ProductType700c18a878c5601b = Mk_ICC_PMR_Type(
            state,
            tracer,
            s_286_265,
        );
        // D s_286_267: call ICC_PMR_write(s_286_266)
        let s_286_267: () = ICC_PMR_write(state, tracer, s_286_266);
        // C s_286_268: const #() : ()
        let s_286_268: () = ();
        // S s_286_269: call ICC_PMR_read(s_286_268)
        let s_286_269: ProductType700c18a878c5601b = ICC_PMR_read(
            state,
            tracer,
            s_286_268,
        );
        // C s_286_270: const #0u : u8
        let s_286_270: u8 = 0;
        // S s_286_271: call _update_ICC_PMR_Type_Priority(s_286_269, s_286_270)
        let s_286_271: ProductType700c18a878c5601b = u_update_ICC_PMR_Type_Priority(
            state,
            tracer,
            s_286_269,
            s_286_270,
        );
        // S s_286_272: call ICC_PMR_write(s_286_271)
        let s_286_272: () = ICC_PMR_write(state, tracer, s_286_271);
        // C s_286_273: const #() : ()
        let s_286_273: () = ();
        // S s_286_274: call ICV_EOIR1_read(s_286_273)
        let s_286_274: ProductType700c18a878c5601b = ICV_EOIR1_read(
            state,
            tracer,
            s_286_273,
        );
        // D s_286_275: write-var ga#36052 <= s_286_274
        fn_state.ga_36052 = s_286_274;
        // D s_286_276: read-var ga#36052.0:struct
        let s_286_276: u32 = fn_state.ga_36052._0;
        // C s_286_277: const #8s : i
        let s_286_277: i128 = 8;
        // C s_286_278: const #24s : i
        let s_286_278: i128 = 24;
        // D s_286_279: cast zx s_286_276 -> bv
        let s_286_279: Bits = Bits::new(s_286_276 as u128, 32u16);
        // C s_286_280: const #0u : u8
        let s_286_280: u8 = 0;
        // C s_286_281: cast zx s_286_280 -> bv
        let s_286_281: Bits = Bits::new(s_286_280 as u128, 8u16);
        // C s_286_282: const #1u : u64
        let s_286_282: u64 = 1;
        // C s_286_283: cast zx s_286_282 -> bv
        let s_286_283: Bits = Bits::new(s_286_282 as u128, 64u16);
        // C s_286_284: lsl s_286_283 s_286_277
        let s_286_284: Bits = s_286_283 << s_286_277;
        // C s_286_285: sub s_286_284 s_286_283
        let s_286_285: Bits = ((s_286_284) - (s_286_283));
        // C s_286_286: and s_286_281 s_286_285
        let s_286_286: Bits = ((s_286_281) & (s_286_285));
        // C s_286_287: lsl s_286_286 s_286_278
        let s_286_287: Bits = s_286_286 << s_286_278;
        // C s_286_288: lsl s_286_285 s_286_278
        let s_286_288: Bits = s_286_285 << s_286_278;
        // C s_286_289: cmpl s_286_288
        let s_286_289: Bits = !s_286_288;
        // D s_286_290: and s_286_279 s_286_289
        let s_286_290: Bits = ((s_286_279) & (s_286_289));
        // D s_286_291: or s_286_290 s_286_287
        let s_286_291: Bits = ((s_286_290) | (s_286_287));
        // D s_286_292: cast reint s_286_291 -> u32
        let s_286_292: u32 = (s_286_291.value() as u32);
        // D s_286_293: call Mk_ICV_EOIR1_Type(s_286_292)
        let s_286_293: ProductType700c18a878c5601b = Mk_ICV_EOIR1_Type(
            state,
            tracer,
            s_286_292,
        );
        // D s_286_294: call ICV_EOIR1_write(s_286_293)
        let s_286_294: () = ICV_EOIR1_write(state, tracer, s_286_293);
        // C s_286_295: const #() : ()
        let s_286_295: () = ();
        // S s_286_296: call ICH_HCR_read(s_286_295)
        let s_286_296: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_295,
        );
        // C s_286_297: const #0u : u8
        let s_286_297: u8 = 0;
        // S s_286_298: call _update_ICH_HCR_Type_EOIcount(s_286_296, s_286_297)
        let s_286_298: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_EOIcount(
            state,
            tracer,
            s_286_296,
            s_286_297,
        );
        // S s_286_299: call ICH_HCR_write(s_286_298)
        let s_286_299: () = ICH_HCR_write(state, tracer, s_286_298);
        // C s_286_300: const #() : ()
        let s_286_300: () = ();
        // S s_286_301: call ICH_HCR_read(s_286_300)
        let s_286_301: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_300,
        );
        // D s_286_302: write-var ga#36058 <= s_286_301
        fn_state.ga_36058 = s_286_301;
        // D s_286_303: read-var ga#36058.0:struct
        let s_286_303: u32 = fn_state.ga_36058._0;
        // C s_286_304: const #12s : i
        let s_286_304: i128 = 12;
        // C s_286_305: const #15s : i
        let s_286_305: i128 = 15;
        // D s_286_306: cast zx s_286_303 -> bv
        let s_286_306: Bits = Bits::new(s_286_303 as u128, 32u16);
        // C s_286_307: const #0u : u12
        let s_286_307: u16 = 0;
        // C s_286_308: cast zx s_286_307 -> bv
        let s_286_308: Bits = Bits::new(s_286_307 as u128, 12u16);
        // C s_286_309: const #1u : u64
        let s_286_309: u64 = 1;
        // C s_286_310: cast zx s_286_309 -> bv
        let s_286_310: Bits = Bits::new(s_286_309 as u128, 64u16);
        // C s_286_311: lsl s_286_310 s_286_304
        let s_286_311: Bits = s_286_310 << s_286_304;
        // C s_286_312: sub s_286_311 s_286_310
        let s_286_312: Bits = ((s_286_311) - (s_286_310));
        // C s_286_313: and s_286_308 s_286_312
        let s_286_313: Bits = ((s_286_308) & (s_286_312));
        // C s_286_314: lsl s_286_313 s_286_305
        let s_286_314: Bits = s_286_313 << s_286_305;
        // C s_286_315: lsl s_286_312 s_286_305
        let s_286_315: Bits = s_286_312 << s_286_305;
        // C s_286_316: cmpl s_286_315
        let s_286_316: Bits = !s_286_315;
        // D s_286_317: and s_286_306 s_286_316
        let s_286_317: Bits = ((s_286_306) & (s_286_316));
        // D s_286_318: or s_286_317 s_286_314
        let s_286_318: Bits = ((s_286_317) | (s_286_314));
        // D s_286_319: cast reint s_286_318 -> u32
        let s_286_319: u32 = (s_286_318.value() as u32);
        // D s_286_320: call Mk_ICH_HCR_Type(s_286_319)
        let s_286_320: ProductType700c18a878c5601b = Mk_ICH_HCR_Type(
            state,
            tracer,
            s_286_319,
        );
        // D s_286_321: call ICH_HCR_write(s_286_320)
        let s_286_321: () = ICH_HCR_write(state, tracer, s_286_320);
        // C s_286_322: const #() : ()
        let s_286_322: () = ();
        // S s_286_323: call ICH_HCR_read(s_286_322)
        let s_286_323: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_322,
        );
        // C s_286_324: const #0u : u8
        let s_286_324: bool = false;
        // S s_286_325: call _update_ICH_HCR_Type_TDIR(s_286_323, s_286_324)
        let s_286_325: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_TDIR(
            state,
            tracer,
            s_286_323,
            s_286_324,
        );
        // S s_286_326: call ICH_HCR_write(s_286_325)
        let s_286_326: () = ICH_HCR_write(state, tracer, s_286_325);
        // C s_286_327: const #() : ()
        let s_286_327: () = ();
        // S s_286_328: call ICH_HCR_read(s_286_327)
        let s_286_328: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_327,
        );
        // C s_286_329: const #0u : u8
        let s_286_329: bool = false;
        // S s_286_330: call _update_ICH_HCR_Type_TSEI(s_286_328, s_286_329)
        let s_286_330: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_TSEI(
            state,
            tracer,
            s_286_328,
            s_286_329,
        );
        // S s_286_331: call ICH_HCR_write(s_286_330)
        let s_286_331: () = ICH_HCR_write(state, tracer, s_286_330);
        // C s_286_332: const #() : ()
        let s_286_332: () = ();
        // S s_286_333: call ICH_HCR_read(s_286_332)
        let s_286_333: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_332,
        );
        // C s_286_334: const #0u : u8
        let s_286_334: bool = false;
        // S s_286_335: call _update_ICH_HCR_Type_TALL1(s_286_333, s_286_334)
        let s_286_335: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_TALL1(
            state,
            tracer,
            s_286_333,
            s_286_334,
        );
        // S s_286_336: call ICH_HCR_write(s_286_335)
        let s_286_336: () = ICH_HCR_write(state, tracer, s_286_335);
        // C s_286_337: const #() : ()
        let s_286_337: () = ();
        // S s_286_338: call ICH_HCR_read(s_286_337)
        let s_286_338: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_337,
        );
        // C s_286_339: const #0u : u8
        let s_286_339: bool = false;
        // S s_286_340: call _update_ICH_HCR_Type_TALL0(s_286_338, s_286_339)
        let s_286_340: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_TALL0(
            state,
            tracer,
            s_286_338,
            s_286_339,
        );
        // S s_286_341: call ICH_HCR_write(s_286_340)
        let s_286_341: () = ICH_HCR_write(state, tracer, s_286_340);
        // C s_286_342: const #() : ()
        let s_286_342: () = ();
        // S s_286_343: call ICH_HCR_read(s_286_342)
        let s_286_343: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_342,
        );
        // C s_286_344: const #0u : u8
        let s_286_344: bool = false;
        // S s_286_345: call _update_ICH_HCR_Type_TC(s_286_343, s_286_344)
        let s_286_345: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_TC(
            state,
            tracer,
            s_286_343,
            s_286_344,
        );
        // S s_286_346: call ICH_HCR_write(s_286_345)
        let s_286_346: () = ICH_HCR_write(state, tracer, s_286_345);
        // C s_286_347: const #() : ()
        let s_286_347: () = ();
        // S s_286_348: call ICH_HCR_read(s_286_347)
        let s_286_348: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_347,
        );
        // D s_286_349: write-var ga#36072 <= s_286_348
        fn_state.ga_36072 = s_286_348;
        // D s_286_350: read-var ga#36072.0:struct
        let s_286_350: u32 = fn_state.ga_36072._0;
        // C s_286_351: const #1s : i
        let s_286_351: i128 = 1;
        // C s_286_352: const #9s : i
        let s_286_352: i128 = 9;
        // D s_286_353: cast zx s_286_350 -> bv
        let s_286_353: Bits = Bits::new(s_286_350 as u128, 32u16);
        // C s_286_354: const #0u : u8
        let s_286_354: bool = false;
        // C s_286_355: cast zx s_286_354 -> bv
        let s_286_355: Bits = Bits::new(s_286_354 as u128, 1u16);
        // C s_286_356: const #1u : u64
        let s_286_356: u64 = 1;
        // C s_286_357: cast zx s_286_356 -> bv
        let s_286_357: Bits = Bits::new(s_286_356 as u128, 64u16);
        // C s_286_358: lsl s_286_357 s_286_351
        let s_286_358: Bits = s_286_357 << s_286_351;
        // C s_286_359: sub s_286_358 s_286_357
        let s_286_359: Bits = ((s_286_358) - (s_286_357));
        // C s_286_360: and s_286_355 s_286_359
        let s_286_360: Bits = ((s_286_355) & (s_286_359));
        // C s_286_361: lsl s_286_360 s_286_352
        let s_286_361: Bits = s_286_360 << s_286_352;
        // C s_286_362: lsl s_286_359 s_286_352
        let s_286_362: Bits = s_286_359 << s_286_352;
        // C s_286_363: cmpl s_286_362
        let s_286_363: Bits = !s_286_362;
        // D s_286_364: and s_286_353 s_286_363
        let s_286_364: Bits = ((s_286_353) & (s_286_363));
        // D s_286_365: or s_286_364 s_286_361
        let s_286_365: Bits = ((s_286_364) | (s_286_361));
        // D s_286_366: cast reint s_286_365 -> u32
        let s_286_366: u32 = (s_286_365.value() as u32);
        // D s_286_367: call Mk_ICH_HCR_Type(s_286_366)
        let s_286_367: ProductType700c18a878c5601b = Mk_ICH_HCR_Type(
            state,
            tracer,
            s_286_366,
        );
        // D s_286_368: call ICH_HCR_write(s_286_367)
        let s_286_368: () = ICH_HCR_write(state, tracer, s_286_367);
        // C s_286_369: const #() : ()
        let s_286_369: () = ();
        // S s_286_370: call ICH_HCR_read(s_286_369)
        let s_286_370: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_369,
        );
        // C s_286_371: const #0u : u8
        let s_286_371: bool = false;
        // S s_286_372: call _update_ICH_HCR_Type_vSGIEOICount(s_286_370, s_286_371)
        let s_286_372: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_vSGIEOICount(
            state,
            tracer,
            s_286_370,
            s_286_371,
        );
        // S s_286_373: call ICH_HCR_write(s_286_372)
        let s_286_373: () = ICH_HCR_write(state, tracer, s_286_372);
        // C s_286_374: const #() : ()
        let s_286_374: () = ();
        // S s_286_375: call ICH_HCR_read(s_286_374)
        let s_286_375: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_374,
        );
        // C s_286_376: const #0u : u8
        let s_286_376: bool = false;
        // S s_286_377: call _update_ICH_HCR_Type_VGrp1DIE(s_286_375, s_286_376)
        let s_286_377: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_VGrp1DIE(
            state,
            tracer,
            s_286_375,
            s_286_376,
        );
        // S s_286_378: call ICH_HCR_write(s_286_377)
        let s_286_378: () = ICH_HCR_write(state, tracer, s_286_377);
        // C s_286_379: const #() : ()
        let s_286_379: () = ();
        // S s_286_380: call ICH_HCR_read(s_286_379)
        let s_286_380: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_379,
        );
        // C s_286_381: const #0u : u8
        let s_286_381: bool = false;
        // S s_286_382: call _update_ICH_HCR_Type_VGrp1EIE(s_286_380, s_286_381)
        let s_286_382: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_VGrp1EIE(
            state,
            tracer,
            s_286_380,
            s_286_381,
        );
        // S s_286_383: call ICH_HCR_write(s_286_382)
        let s_286_383: () = ICH_HCR_write(state, tracer, s_286_382);
        // C s_286_384: const #() : ()
        let s_286_384: () = ();
        // S s_286_385: call ICH_HCR_read(s_286_384)
        let s_286_385: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_384,
        );
        // C s_286_386: const #0u : u8
        let s_286_386: bool = false;
        // S s_286_387: call _update_ICH_HCR_Type_VGrp0DIE(s_286_385, s_286_386)
        let s_286_387: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_VGrp0DIE(
            state,
            tracer,
            s_286_385,
            s_286_386,
        );
        // S s_286_388: call ICH_HCR_write(s_286_387)
        let s_286_388: () = ICH_HCR_write(state, tracer, s_286_387);
        // C s_286_389: const #() : ()
        let s_286_389: () = ();
        // S s_286_390: call ICH_HCR_read(s_286_389)
        let s_286_390: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_389,
        );
        // C s_286_391: const #0u : u8
        let s_286_391: bool = false;
        // S s_286_392: call _update_ICH_HCR_Type_VGrp0EIE(s_286_390, s_286_391)
        let s_286_392: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_VGrp0EIE(
            state,
            tracer,
            s_286_390,
            s_286_391,
        );
        // S s_286_393: call ICH_HCR_write(s_286_392)
        let s_286_393: () = ICH_HCR_write(state, tracer, s_286_392);
        // C s_286_394: const #() : ()
        let s_286_394: () = ();
        // S s_286_395: call ICH_HCR_read(s_286_394)
        let s_286_395: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_394,
        );
        // C s_286_396: const #0u : u8
        let s_286_396: bool = false;
        // S s_286_397: call _update_ICH_HCR_Type_NPIE(s_286_395, s_286_396)
        let s_286_397: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_NPIE(
            state,
            tracer,
            s_286_395,
            s_286_396,
        );
        // S s_286_398: call ICH_HCR_write(s_286_397)
        let s_286_398: () = ICH_HCR_write(state, tracer, s_286_397);
        // C s_286_399: const #() : ()
        let s_286_399: () = ();
        // S s_286_400: call ICH_HCR_read(s_286_399)
        let s_286_400: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_399,
        );
        // C s_286_401: const #0u : u8
        let s_286_401: bool = false;
        // S s_286_402: call _update_ICH_HCR_Type_LRENPIE(s_286_400, s_286_401)
        let s_286_402: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_LRENPIE(
            state,
            tracer,
            s_286_400,
            s_286_401,
        );
        // S s_286_403: call ICH_HCR_write(s_286_402)
        let s_286_403: () = ICH_HCR_write(state, tracer, s_286_402);
        // C s_286_404: const #() : ()
        let s_286_404: () = ();
        // S s_286_405: call ICH_HCR_read(s_286_404)
        let s_286_405: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_404,
        );
        // C s_286_406: const #0u : u8
        let s_286_406: bool = false;
        // S s_286_407: call _update_ICH_HCR_Type_UIE(s_286_405, s_286_406)
        let s_286_407: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_UIE(
            state,
            tracer,
            s_286_405,
            s_286_406,
        );
        // S s_286_408: call ICH_HCR_write(s_286_407)
        let s_286_408: () = ICH_HCR_write(state, tracer, s_286_407);
        // C s_286_409: const #() : ()
        let s_286_409: () = ();
        // S s_286_410: call ICH_HCR_read(s_286_409)
        let s_286_410: ProductType700c18a878c5601b = ICH_HCR_read(
            state,
            tracer,
            s_286_409,
        );
        // C s_286_411: const #0u : u8
        let s_286_411: bool = false;
        // S s_286_412: call _update_ICH_HCR_Type_En(s_286_410, s_286_411)
        let s_286_412: ProductType700c18a878c5601b = u_update_ICH_HCR_Type_En(
            state,
            tracer,
            s_286_410,
            s_286_411,
        );
        // S s_286_413: call ICH_HCR_write(s_286_412)
        let s_286_413: () = ICH_HCR_write(state, tracer, s_286_412);
        // C s_286_414: const #() : ()
        let s_286_414: () = ();
        // S s_286_415: call RMR_read(s_286_414)
        let s_286_415: ProductType700c18a878c5601b = RMR_read(state, tracer, s_286_414);
        // D s_286_416: write-var ga#36094 <= s_286_415
        fn_state.ga_36094 = s_286_415;
        // D s_286_417: read-var ga#36094.0:struct
        let s_286_417: u32 = fn_state.ga_36094._0;
        // C s_286_418: const #30s : i
        let s_286_418: i128 = 30;
        // C s_286_419: const #2s : i
        let s_286_419: i128 = 2;
        // D s_286_420: cast zx s_286_417 -> bv
        let s_286_420: Bits = Bits::new(s_286_417 as u128, 32u16);
        // C s_286_421: const #0u : u30
        let s_286_421: u32 = 0;
        // C s_286_422: cast zx s_286_421 -> bv
        let s_286_422: Bits = Bits::new(s_286_421 as u128, 30u16);
        // C s_286_423: const #1u : u64
        let s_286_423: u64 = 1;
        // C s_286_424: cast zx s_286_423 -> bv
        let s_286_424: Bits = Bits::new(s_286_423 as u128, 64u16);
        // C s_286_425: lsl s_286_424 s_286_418
        let s_286_425: Bits = s_286_424 << s_286_418;
        // C s_286_426: sub s_286_425 s_286_424
        let s_286_426: Bits = ((s_286_425) - (s_286_424));
        // C s_286_427: and s_286_422 s_286_426
        let s_286_427: Bits = ((s_286_422) & (s_286_426));
        // C s_286_428: lsl s_286_427 s_286_419
        let s_286_428: Bits = s_286_427 << s_286_419;
        // C s_286_429: lsl s_286_426 s_286_419
        let s_286_429: Bits = s_286_426 << s_286_419;
        // C s_286_430: cmpl s_286_429
        let s_286_430: Bits = !s_286_429;
        // D s_286_431: and s_286_420 s_286_430
        let s_286_431: Bits = ((s_286_420) & (s_286_430));
        // D s_286_432: or s_286_431 s_286_428
        let s_286_432: Bits = ((s_286_431) | (s_286_428));
        // D s_286_433: cast reint s_286_432 -> u32
        let s_286_433: u32 = (s_286_432.value() as u32);
        // D s_286_434: call Mk_RMR_Type(s_286_433)
        let s_286_434: ProductType700c18a878c5601b = Mk_RMR_Type(
            state,
            tracer,
            s_286_433,
        );
        // D s_286_435: call RMR_write(s_286_434)
        let s_286_435: () = RMR_write(state, tracer, s_286_434);
        // C s_286_436: const #() : ()
        let s_286_436: () = ();
        // S s_286_437: call RMR_read(s_286_436)
        let s_286_437: ProductType700c18a878c5601b = RMR_read(state, tracer, s_286_436);
        // C s_286_438: const #0u : u8
        let s_286_438: bool = false;
        // S s_286_439: call _update_RMR_Type_RR(s_286_437, s_286_438)
        let s_286_439: ProductType700c18a878c5601b = u_update_RMR_Type_RR(
            state,
            tracer,
            s_286_437,
            s_286_438,
        );
        // S s_286_440: call RMR_write(s_286_439)
        let s_286_440: () = RMR_write(state, tracer, s_286_439);
        // C s_286_441: const #() : ()
        let s_286_441: () = ();
        // S s_286_442: call FPEXC_read(s_286_441)
        let s_286_442: ProductType700c18a878c5601b = FPEXC_read(
            state,
            tracer,
            s_286_441,
        );
        // C s_286_443: const #0u : u8
        let s_286_443: bool = false;
        // S s_286_444: call _update_FPEXC_Type_EN(s_286_442, s_286_443)
        let s_286_444: ProductType700c18a878c5601b = u_update_FPEXC_Type_EN(
            state,
            tracer,
            s_286_442,
            s_286_443,
        );
        // S s_286_445: call FPEXC_write(s_286_444)
        let s_286_445: () = FPEXC_write(state, tracer, s_286_444);
        // C s_286_446: const #() : ()
        let s_286_446: () = ();
        // S s_286_447: call FPEXC_read(s_286_446)
        let s_286_447: ProductType700c18a878c5601b = FPEXC_read(
            state,
            tracer,
            s_286_446,
        );
        // D s_286_448: write-var ga#36102 <= s_286_447
        fn_state.ga_36102 = s_286_447;
        // D s_286_449: read-var ga#36102.0:struct
        let s_286_449: u32 = fn_state.ga_36102._0;
        // C s_286_450: const #15s : i
        let s_286_450: i128 = 15;
        // C s_286_451: const #11s : i
        let s_286_451: i128 = 11;
        // D s_286_452: cast zx s_286_449 -> bv
        let s_286_452: Bits = Bits::new(s_286_449 as u128, 32u16);
        // C s_286_453: const #0u : u15
        let s_286_453: u16 = 0;
        // C s_286_454: cast zx s_286_453 -> bv
        let s_286_454: Bits = Bits::new(s_286_453 as u128, 15u16);
        // C s_286_455: const #1u : u64
        let s_286_455: u64 = 1;
        // C s_286_456: cast zx s_286_455 -> bv
        let s_286_456: Bits = Bits::new(s_286_455 as u128, 64u16);
        // C s_286_457: lsl s_286_456 s_286_450
        let s_286_457: Bits = s_286_456 << s_286_450;
        // C s_286_458: sub s_286_457 s_286_456
        let s_286_458: Bits = ((s_286_457) - (s_286_456));
        // C s_286_459: and s_286_454 s_286_458
        let s_286_459: Bits = ((s_286_454) & (s_286_458));
        // C s_286_460: lsl s_286_459 s_286_451
        let s_286_460: Bits = s_286_459 << s_286_451;
        // C s_286_461: lsl s_286_458 s_286_451
        let s_286_461: Bits = s_286_458 << s_286_451;
        // C s_286_462: cmpl s_286_461
        let s_286_462: Bits = !s_286_461;
        // D s_286_463: and s_286_452 s_286_462
        let s_286_463: Bits = ((s_286_452) & (s_286_462));
        // D s_286_464: or s_286_463 s_286_460
        let s_286_464: Bits = ((s_286_463) | (s_286_460));
        // D s_286_465: cast reint s_286_464 -> u32
        let s_286_465: u32 = (s_286_464.value() as u32);
        // D s_286_466: call Mk_FPEXC_Type(s_286_465)
        let s_286_466: ProductType700c18a878c5601b = Mk_FPEXC_Type(
            state,
            tracer,
            s_286_465,
        );
        // D s_286_467: call FPEXC_write(s_286_466)
        let s_286_467: () = FPEXC_write(state, tracer, s_286_466);
        // C s_286_468: const #() : ()
        let s_286_468: () = ();
        // S s_286_469: call FPEXC_read(s_286_468)
        let s_286_469: ProductType700c18a878c5601b = FPEXC_read(
            state,
            tracer,
            s_286_468,
        );
        // D s_286_470: write-var ga#36106 <= s_286_469
        fn_state.ga_36106 = s_286_469;
        // D s_286_471: read-var ga#36106.0:struct
        let s_286_471: u32 = fn_state.ga_36106._0;
        // C s_286_472: const #2s : i
        let s_286_472: i128 = 2;
        // C s_286_473: const #5s : i
        let s_286_473: i128 = 5;
        // D s_286_474: cast zx s_286_471 -> bv
        let s_286_474: Bits = Bits::new(s_286_471 as u128, 32u16);
        // C s_286_475: const #0u : u8
        let s_286_475: u8 = 0;
        // C s_286_476: cast zx s_286_475 -> bv
        let s_286_476: Bits = Bits::new(s_286_475 as u128, 2u16);
        // C s_286_477: const #1u : u64
        let s_286_477: u64 = 1;
        // C s_286_478: cast zx s_286_477 -> bv
        let s_286_478: Bits = Bits::new(s_286_477 as u128, 64u16);
        // C s_286_479: lsl s_286_478 s_286_472
        let s_286_479: Bits = s_286_478 << s_286_472;
        // C s_286_480: sub s_286_479 s_286_478
        let s_286_480: Bits = ((s_286_479) - (s_286_478));
        // C s_286_481: and s_286_476 s_286_480
        let s_286_481: Bits = ((s_286_476) & (s_286_480));
        // C s_286_482: lsl s_286_481 s_286_473
        let s_286_482: Bits = s_286_481 << s_286_473;
        // C s_286_483: lsl s_286_480 s_286_473
        let s_286_483: Bits = s_286_480 << s_286_473;
        // C s_286_484: cmpl s_286_483
        let s_286_484: Bits = !s_286_483;
        // D s_286_485: and s_286_474 s_286_484
        let s_286_485: Bits = ((s_286_474) & (s_286_484));
        // D s_286_486: or s_286_485 s_286_482
        let s_286_486: Bits = ((s_286_485) | (s_286_482));
        // D s_286_487: cast reint s_286_486 -> u32
        let s_286_487: u32 = (s_286_486.value() as u32);
        // D s_286_488: call Mk_FPEXC_Type(s_286_487)
        let s_286_488: ProductType700c18a878c5601b = Mk_FPEXC_Type(
            state,
            tracer,
            s_286_487,
        );
        // D s_286_489: call FPEXC_write(s_286_488)
        let s_286_489: () = FPEXC_write(state, tracer, s_286_488);
        // C s_286_490: const #() : ()
        let s_286_490: () = ();
        // S s_286_491: call ICC_HPPIR0_read(s_286_490)
        let s_286_491: ProductType700c18a878c5601b = ICC_HPPIR0_read(
            state,
            tracer,
            s_286_490,
        );
        // D s_286_492: write-var ga#36110 <= s_286_491
        fn_state.ga_36110 = s_286_491;
        // D s_286_493: read-var ga#36110.0:struct
        let s_286_493: u32 = fn_state.ga_36110._0;
        // C s_286_494: const #8s : i
        let s_286_494: i128 = 8;
        // C s_286_495: const #24s : i
        let s_286_495: i128 = 24;
        // D s_286_496: cast zx s_286_493 -> bv
        let s_286_496: Bits = Bits::new(s_286_493 as u128, 32u16);
        // C s_286_497: const #0u : u8
        let s_286_497: u8 = 0;
        // C s_286_498: cast zx s_286_497 -> bv
        let s_286_498: Bits = Bits::new(s_286_497 as u128, 8u16);
        // C s_286_499: const #1u : u64
        let s_286_499: u64 = 1;
        // C s_286_500: cast zx s_286_499 -> bv
        let s_286_500: Bits = Bits::new(s_286_499 as u128, 64u16);
        // C s_286_501: lsl s_286_500 s_286_494
        let s_286_501: Bits = s_286_500 << s_286_494;
        // C s_286_502: sub s_286_501 s_286_500
        let s_286_502: Bits = ((s_286_501) - (s_286_500));
        // C s_286_503: and s_286_498 s_286_502
        let s_286_503: Bits = ((s_286_498) & (s_286_502));
        // C s_286_504: lsl s_286_503 s_286_495
        let s_286_504: Bits = s_286_503 << s_286_495;
        // C s_286_505: lsl s_286_502 s_286_495
        let s_286_505: Bits = s_286_502 << s_286_495;
        // C s_286_506: cmpl s_286_505
        let s_286_506: Bits = !s_286_505;
        // D s_286_507: and s_286_496 s_286_506
        let s_286_507: Bits = ((s_286_496) & (s_286_506));
        // D s_286_508: or s_286_507 s_286_504
        let s_286_508: Bits = ((s_286_507) | (s_286_504));
        // D s_286_509: cast reint s_286_508 -> u32
        let s_286_509: u32 = (s_286_508.value() as u32);
        // D s_286_510: call Mk_ICC_HPPIR0_Type(s_286_509)
        let s_286_510: ProductType700c18a878c5601b = Mk_ICC_HPPIR0_Type(
            state,
            tracer,
            s_286_509,
        );
        // D s_286_511: call ICC_HPPIR0_write(s_286_510)
        let s_286_511: () = ICC_HPPIR0_write(state, tracer, s_286_510);
        // C s_286_512: const #() : ()
        let s_286_512: () = ();
        // S s_286_513: call TTBCR2_read(s_286_512)
        let s_286_513: ProductType700c18a878c5601b = TTBCR2_read(
            state,
            tracer,
            s_286_512,
        );
        // D s_286_514: write-var ga#36114 <= s_286_513
        fn_state.ga_36114 = s_286_513;
        // D s_286_515: read-var ga#36114.0:struct
        let s_286_515: u32 = fn_state.ga_36114._0;
        // C s_286_516: const #13s : i
        let s_286_516: i128 = 13;
        // C s_286_517: const #19s : i
        let s_286_517: i128 = 19;
        // D s_286_518: cast zx s_286_515 -> bv
        let s_286_518: Bits = Bits::new(s_286_515 as u128, 32u16);
        // C s_286_519: const #0u : u13
        let s_286_519: u16 = 0;
        // C s_286_520: cast zx s_286_519 -> bv
        let s_286_520: Bits = Bits::new(s_286_519 as u128, 13u16);
        // C s_286_521: const #1u : u64
        let s_286_521: u64 = 1;
        // C s_286_522: cast zx s_286_521 -> bv
        let s_286_522: Bits = Bits::new(s_286_521 as u128, 64u16);
        // C s_286_523: lsl s_286_522 s_286_516
        let s_286_523: Bits = s_286_522 << s_286_516;
        // C s_286_524: sub s_286_523 s_286_522
        let s_286_524: Bits = ((s_286_523) - (s_286_522));
        // C s_286_525: and s_286_520 s_286_524
        let s_286_525: Bits = ((s_286_520) & (s_286_524));
        // C s_286_526: lsl s_286_525 s_286_517
        let s_286_526: Bits = s_286_525 << s_286_517;
        // C s_286_527: lsl s_286_524 s_286_517
        let s_286_527: Bits = s_286_524 << s_286_517;
        // C s_286_528: cmpl s_286_527
        let s_286_528: Bits = !s_286_527;
        // D s_286_529: and s_286_518 s_286_528
        let s_286_529: Bits = ((s_286_518) & (s_286_528));
        // D s_286_530: or s_286_529 s_286_526
        let s_286_530: Bits = ((s_286_529) | (s_286_526));
        // D s_286_531: cast reint s_286_530 -> u32
        let s_286_531: u32 = (s_286_530.value() as u32);
        // D s_286_532: call Mk_TTBCR2_Type(s_286_531)
        let s_286_532: ProductType700c18a878c5601b = Mk_TTBCR2_Type(
            state,
            tracer,
            s_286_531,
        );
        // D s_286_533: call TTBCR2_write(s_286_532)
        let s_286_533: () = TTBCR2_write(state, tracer, s_286_532);
        // C s_286_534: const #() : ()
        let s_286_534: () = ();
        // S s_286_535: call TTBCR2_read(s_286_534)
        let s_286_535: ProductType700c18a878c5601b = TTBCR2_read(
            state,
            tracer,
            s_286_534,
        );
        // D s_286_536: write-var ga#36118 <= s_286_535
        fn_state.ga_36118 = s_286_535;
        // D s_286_537: read-var ga#36118.0:struct
        let s_286_537: u32 = fn_state.ga_36118._0;
        // C s_286_538: const #9s : i
        let s_286_538: i128 = 9;
        // C s_286_539: const #0s : i
        let s_286_539: i128 = 0;
        // D s_286_540: cast zx s_286_537 -> bv
        let s_286_540: Bits = Bits::new(s_286_537 as u128, 32u16);
        // C s_286_541: const #0u : u9
        let s_286_541: u16 = 0;
        // C s_286_542: cast zx s_286_541 -> bv
        let s_286_542: Bits = Bits::new(s_286_541 as u128, 9u16);
        // C s_286_543: const #1u : u64
        let s_286_543: u64 = 1;
        // C s_286_544: cast zx s_286_543 -> bv
        let s_286_544: Bits = Bits::new(s_286_543 as u128, 64u16);
        // C s_286_545: lsl s_286_544 s_286_538
        let s_286_545: Bits = s_286_544 << s_286_538;
        // C s_286_546: sub s_286_545 s_286_544
        let s_286_546: Bits = ((s_286_545) - (s_286_544));
        // C s_286_547: and s_286_542 s_286_546
        let s_286_547: Bits = ((s_286_542) & (s_286_546));
        // C s_286_548: lsl s_286_547 s_286_539
        let s_286_548: Bits = s_286_547 << s_286_539;
        // C s_286_549: lsl s_286_546 s_286_539
        let s_286_549: Bits = s_286_546 << s_286_539;
        // C s_286_550: cmpl s_286_549
        let s_286_550: Bits = !s_286_549;
        // D s_286_551: and s_286_540 s_286_550
        let s_286_551: Bits = ((s_286_540) & (s_286_550));
        // D s_286_552: or s_286_551 s_286_548
        let s_286_552: Bits = ((s_286_551) | (s_286_548));
        // D s_286_553: cast reint s_286_552 -> u32
        let s_286_553: u32 = (s_286_552.value() as u32);
        // D s_286_554: call Mk_TTBCR2_Type(s_286_553)
        let s_286_554: ProductType700c18a878c5601b = Mk_TTBCR2_Type(
            state,
            tracer,
            s_286_553,
        );
        // D s_286_555: call TTBCR2_write(s_286_554)
        let s_286_555: () = TTBCR2_write(state, tracer, s_286_554);
        // C s_286_556: const #0s : i
        let s_286_556: i128 = 0;
        // C s_286_557: const #16568u : u32
        let s_286_557: u32 = 16568;
        // D s_286_558: read-reg s_286_557:u32
        let s_286_558: u32 = {
            let value = state.read_register::<u32>(s_286_557 as isize);
            tracer.read_register(s_286_557 as isize, value);
            value
        };
        // D s_286_559: cast zx s_286_558 -> bv
        let s_286_559: Bits = Bits::new(s_286_558 as u128, 32u16);
        // C s_286_560: const #0u : u32
        let s_286_560: u32 = 0;
        // C s_286_561: cast zx s_286_560 -> bv
        let s_286_561: Bits = Bits::new(s_286_560 as u128, 32u16);
        // C s_286_562: const #31s : i
        let s_286_562: i128 = 31;
        // C s_286_563: const #1u : u64
        let s_286_563: u64 = 1;
        // C s_286_564: cast zx s_286_563 -> bv
        let s_286_564: Bits = Bits::new(s_286_563 as u128, 64u16);
        // C s_286_565: lsl s_286_564 s_286_562
        let s_286_565: Bits = s_286_564 << s_286_562;
        // C s_286_566: sub s_286_565 s_286_564
        let s_286_566: Bits = ((s_286_565) - (s_286_564));
        // C s_286_567: and s_286_561 s_286_566
        let s_286_567: Bits = ((s_286_561) & (s_286_566));
        // C s_286_568: lsl s_286_567 s_286_556
        let s_286_568: Bits = s_286_567 << s_286_556;
        // C s_286_569: lsl s_286_566 s_286_556
        let s_286_569: Bits = s_286_566 << s_286_556;
        // C s_286_570: cmpl s_286_569
        let s_286_570: Bits = !s_286_569;
        // D s_286_571: and s_286_559 s_286_570
        let s_286_571: Bits = ((s_286_559) & (s_286_570));
        // D s_286_572: or s_286_571 s_286_568
        let s_286_572: Bits = ((s_286_571) | (s_286_568));
        // D s_286_573: cast reint s_286_572 -> u32
        let s_286_573: u32 = (s_286_572.value() as u32);
        // C s_286_574: const #16568u : u32
        let s_286_574: u32 = 16568;
        // N s_286_575: write-reg s_286_574 <= s_286_573
        let s_286_575: () = {
            state.write_register::<u32>(s_286_574 as isize, s_286_573);
            tracer.write_register(s_286_574 as isize, s_286_573);
        };
        // C s_286_576: const #() : ()
        let s_286_576: () = ();
        // S s_286_577: call ID_DFR1_read(s_286_576)
        let s_286_577: ProductType700c18a878c5601b = ID_DFR1_read(
            state,
            tracer,
            s_286_576,
        );
        // D s_286_578: write-var ga#36122 <= s_286_577
        fn_state.ga_36122 = s_286_577;
        // D s_286_579: read-var ga#36122.0:struct
        let s_286_579: u32 = fn_state.ga_36122._0;
        // C s_286_580: const #24s : i
        let s_286_580: i128 = 24;
        // C s_286_581: const #8s : i
        let s_286_581: i128 = 8;
        // D s_286_582: cast zx s_286_579 -> bv
        let s_286_582: Bits = Bits::new(s_286_579 as u128, 32u16);
        // C s_286_583: const #0u : u24
        let s_286_583: u32 = 0;
        // C s_286_584: cast zx s_286_583 -> bv
        let s_286_584: Bits = Bits::new(s_286_583 as u128, 24u16);
        // C s_286_585: const #1u : u64
        let s_286_585: u64 = 1;
        // C s_286_586: cast zx s_286_585 -> bv
        let s_286_586: Bits = Bits::new(s_286_585 as u128, 64u16);
        // C s_286_587: lsl s_286_586 s_286_580
        let s_286_587: Bits = s_286_586 << s_286_580;
        // C s_286_588: sub s_286_587 s_286_586
        let s_286_588: Bits = ((s_286_587) - (s_286_586));
        // C s_286_589: and s_286_584 s_286_588
        let s_286_589: Bits = ((s_286_584) & (s_286_588));
        // C s_286_590: lsl s_286_589 s_286_581
        let s_286_590: Bits = s_286_589 << s_286_581;
        // C s_286_591: lsl s_286_588 s_286_581
        let s_286_591: Bits = s_286_588 << s_286_581;
        // C s_286_592: cmpl s_286_591
        let s_286_592: Bits = !s_286_591;
        // D s_286_593: and s_286_582 s_286_592
        let s_286_593: Bits = ((s_286_582) & (s_286_592));
        // D s_286_594: or s_286_593 s_286_590
        let s_286_594: Bits = ((s_286_593) | (s_286_590));
        // D s_286_595: cast reint s_286_594 -> u32
        let s_286_595: u32 = (s_286_594.value() as u32);
        // D s_286_596: call Mk_ID_DFR1_Type(s_286_595)
        let s_286_596: ProductType700c18a878c5601b = Mk_ID_DFR1_Type(
            state,
            tracer,
            s_286_595,
        );
        // D s_286_597: call ID_DFR1_write(s_286_596)
        let s_286_597: () = ID_DFR1_write(state, tracer, s_286_596);
        // C s_286_598: const #0s : i
        let s_286_598: i128 = 0;
        // C s_286_599: const #91040u : u32
        let s_286_599: u32 = 91040;
        // D s_286_600: read-reg s_286_599:u32
        let s_286_600: u32 = {
            let value = state.read_register::<u32>(s_286_599 as isize);
            tracer.read_register(s_286_599 as isize, value);
            value
        };
        // D s_286_601: cast zx s_286_600 -> bv
        let s_286_601: Bits = Bits::new(s_286_600 as u128, 32u16);
        // C s_286_602: const #0u : u32
        let s_286_602: u32 = 0;
        // C s_286_603: cast zx s_286_602 -> bv
        let s_286_603: Bits = Bits::new(s_286_602 as u128, 32u16);
        // C s_286_604: const #31s : i
        let s_286_604: i128 = 31;
        // C s_286_605: const #1u : u64
        let s_286_605: u64 = 1;
        // C s_286_606: cast zx s_286_605 -> bv
        let s_286_606: Bits = Bits::new(s_286_605 as u128, 64u16);
        // C s_286_607: lsl s_286_606 s_286_604
        let s_286_607: Bits = s_286_606 << s_286_604;
        // C s_286_608: sub s_286_607 s_286_606
        let s_286_608: Bits = ((s_286_607) - (s_286_606));
        // C s_286_609: and s_286_603 s_286_608
        let s_286_609: Bits = ((s_286_603) & (s_286_608));
        // C s_286_610: lsl s_286_609 s_286_598
        let s_286_610: Bits = s_286_609 << s_286_598;
        // C s_286_611: lsl s_286_608 s_286_598
        let s_286_611: Bits = s_286_608 << s_286_598;
        // C s_286_612: cmpl s_286_611
        let s_286_612: Bits = !s_286_611;
        // D s_286_613: and s_286_601 s_286_612
        let s_286_613: Bits = ((s_286_601) & (s_286_612));
        // D s_286_614: or s_286_613 s_286_610
        let s_286_614: Bits = ((s_286_613) | (s_286_610));
        // D s_286_615: cast reint s_286_614 -> u32
        let s_286_615: u32 = (s_286_614.value() as u32);
        // C s_286_616: const #91040u : u32
        let s_286_616: u32 = 91040;
        // N s_286_617: write-reg s_286_616 <= s_286_615
        let s_286_617: () = {
            state.write_register::<u32>(s_286_616 as isize, s_286_615);
            tracer.write_register(s_286_616 as isize, s_286_615);
        };
        // C s_286_618: const #() : ()
        let s_286_618: () = ();
        // S s_286_619: call CNTKCTL_read__1(s_286_618)
        let s_286_619: ProductType700c18a878c5601b = CNTKCTL_read__1(
            state,
            tracer,
            s_286_618,
        );
        // D s_286_620: write-var ga#36126 <= s_286_619
        fn_state.ga_36126 = s_286_619;
        // D s_286_621: read-var ga#36126.0:struct
        let s_286_621: u32 = fn_state.ga_36126._0;
        // C s_286_622: const #14s : i
        let s_286_622: i128 = 14;
        // C s_286_623: const #18s : i
        let s_286_623: i128 = 18;
        // D s_286_624: cast zx s_286_621 -> bv
        let s_286_624: Bits = Bits::new(s_286_621 as u128, 32u16);
        // C s_286_625: const #0u : u14
        let s_286_625: u16 = 0;
        // C s_286_626: cast zx s_286_625 -> bv
        let s_286_626: Bits = Bits::new(s_286_625 as u128, 14u16);
        // C s_286_627: const #1u : u64
        let s_286_627: u64 = 1;
        // C s_286_628: cast zx s_286_627 -> bv
        let s_286_628: Bits = Bits::new(s_286_627 as u128, 64u16);
        // C s_286_629: lsl s_286_628 s_286_622
        let s_286_629: Bits = s_286_628 << s_286_622;
        // C s_286_630: sub s_286_629 s_286_628
        let s_286_630: Bits = ((s_286_629) - (s_286_628));
        // C s_286_631: and s_286_626 s_286_630
        let s_286_631: Bits = ((s_286_626) & (s_286_630));
        // C s_286_632: lsl s_286_631 s_286_623
        let s_286_632: Bits = s_286_631 << s_286_623;
        // C s_286_633: lsl s_286_630 s_286_623
        let s_286_633: Bits = s_286_630 << s_286_623;
        // C s_286_634: cmpl s_286_633
        let s_286_634: Bits = !s_286_633;
        // D s_286_635: and s_286_624 s_286_634
        let s_286_635: Bits = ((s_286_624) & (s_286_634));
        // D s_286_636: or s_286_635 s_286_632
        let s_286_636: Bits = ((s_286_635) | (s_286_632));
        // D s_286_637: cast reint s_286_636 -> u32
        let s_286_637: u32 = (s_286_636.value() as u32);
        // D s_286_638: call Mk_CNTKCTL_Type(s_286_637)
        let s_286_638: ProductType700c18a878c5601b = Mk_CNTKCTL_Type(
            state,
            tracer,
            s_286_637,
        );
        // D s_286_639: call CNTKCTL_write(s_286_638)
        let s_286_639: () = CNTKCTL_write(state, tracer, s_286_638);
        // C s_286_640: const #() : ()
        let s_286_640: () = ();
        // S s_286_641: call CNTKCTL_read__1(s_286_640)
        let s_286_641: ProductType700c18a878c5601b = CNTKCTL_read__1(
            state,
            tracer,
            s_286_640,
        );
        // D s_286_642: write-var ga#36130 <= s_286_641
        fn_state.ga_36130 = s_286_641;
        // D s_286_643: read-var ga#36130.0:struct
        let s_286_643: u32 = fn_state.ga_36130._0;
        // C s_286_644: const #7s : i
        let s_286_644: i128 = 7;
        // C s_286_645: const #10s : i
        let s_286_645: i128 = 10;
        // D s_286_646: cast zx s_286_643 -> bv
        let s_286_646: Bits = Bits::new(s_286_643 as u128, 32u16);
        // C s_286_647: const #0u : u8
        let s_286_647: u8 = 0;
        // C s_286_648: cast zx s_286_647 -> bv
        let s_286_648: Bits = Bits::new(s_286_647 as u128, 7u16);
        // C s_286_649: const #1u : u64
        let s_286_649: u64 = 1;
        // C s_286_650: cast zx s_286_649 -> bv
        let s_286_650: Bits = Bits::new(s_286_649 as u128, 64u16);
        // C s_286_651: lsl s_286_650 s_286_644
        let s_286_651: Bits = s_286_650 << s_286_644;
        // C s_286_652: sub s_286_651 s_286_650
        let s_286_652: Bits = ((s_286_651) - (s_286_650));
        // C s_286_653: and s_286_648 s_286_652
        let s_286_653: Bits = ((s_286_648) & (s_286_652));
        // C s_286_654: lsl s_286_653 s_286_645
        let s_286_654: Bits = s_286_653 << s_286_645;
        // C s_286_655: lsl s_286_652 s_286_645
        let s_286_655: Bits = s_286_652 << s_286_645;
        // C s_286_656: cmpl s_286_655
        let s_286_656: Bits = !s_286_655;
        // D s_286_657: and s_286_646 s_286_656
        let s_286_657: Bits = ((s_286_646) & (s_286_656));
        // D s_286_658: or s_286_657 s_286_654
        let s_286_658: Bits = ((s_286_657) | (s_286_654));
        // D s_286_659: cast reint s_286_658 -> u32
        let s_286_659: u32 = (s_286_658.value() as u32);
        // D s_286_660: call Mk_CNTKCTL_Type(s_286_659)
        let s_286_660: ProductType700c18a878c5601b = Mk_CNTKCTL_Type(
            state,
            tracer,
            s_286_659,
        );
        // D s_286_661: call CNTKCTL_write(s_286_660)
        let s_286_661: () = CNTKCTL_write(state, tracer, s_286_660);
        // C s_286_662: const #() : ()
        let s_286_662: () = ();
        // S s_286_663: call ICV_PMR_read(s_286_662)
        let s_286_663: ProductType700c18a878c5601b = ICV_PMR_read(
            state,
            tracer,
            s_286_662,
        );
        // D s_286_664: write-var ga#36134 <= s_286_663
        fn_state.ga_36134 = s_286_663;
        // D s_286_665: read-var ga#36134.0:struct
        let s_286_665: u32 = fn_state.ga_36134._0;
        // C s_286_666: const #24s : i
        let s_286_666: i128 = 24;
        // C s_286_667: const #8s : i
        let s_286_667: i128 = 8;
        // D s_286_668: cast zx s_286_665 -> bv
        let s_286_668: Bits = Bits::new(s_286_665 as u128, 32u16);
        // C s_286_669: const #0u : u24
        let s_286_669: u32 = 0;
        // C s_286_670: cast zx s_286_669 -> bv
        let s_286_670: Bits = Bits::new(s_286_669 as u128, 24u16);
        // C s_286_671: const #1u : u64
        let s_286_671: u64 = 1;
        // C s_286_672: cast zx s_286_671 -> bv
        let s_286_672: Bits = Bits::new(s_286_671 as u128, 64u16);
        // C s_286_673: lsl s_286_672 s_286_666
        let s_286_673: Bits = s_286_672 << s_286_666;
        // C s_286_674: sub s_286_673 s_286_672
        let s_286_674: Bits = ((s_286_673) - (s_286_672));
        // C s_286_675: and s_286_670 s_286_674
        let s_286_675: Bits = ((s_286_670) & (s_286_674));
        // C s_286_676: lsl s_286_675 s_286_667
        let s_286_676: Bits = s_286_675 << s_286_667;
        // C s_286_677: lsl s_286_674 s_286_667
        let s_286_677: Bits = s_286_674 << s_286_667;
        // C s_286_678: cmpl s_286_677
        let s_286_678: Bits = !s_286_677;
        // D s_286_679: and s_286_668 s_286_678
        let s_286_679: Bits = ((s_286_668) & (s_286_678));
        // D s_286_680: or s_286_679 s_286_676
        let s_286_680: Bits = ((s_286_679) | (s_286_676));
        // D s_286_681: cast reint s_286_680 -> u32
        let s_286_681: u32 = (s_286_680.value() as u32);
        // D s_286_682: call Mk_ICV_PMR_Type(s_286_681)
        let s_286_682: ProductType700c18a878c5601b = Mk_ICV_PMR_Type(
            state,
            tracer,
            s_286_681,
        );
        // D s_286_683: call ICV_PMR_write(s_286_682)
        let s_286_683: () = ICV_PMR_write(state, tracer, s_286_682);
        // C s_286_684: const #() : ()
        let s_286_684: () = ();
        // S s_286_685: call ICV_PMR_read(s_286_684)
        let s_286_685: ProductType700c18a878c5601b = ICV_PMR_read(
            state,
            tracer,
            s_286_684,
        );
        // C s_286_686: const #0u : u8
        let s_286_686: u8 = 0;
        // S s_286_687: call _update_ICV_PMR_Type_Priority(s_286_685, s_286_686)
        let s_286_687: ProductType700c18a878c5601b = u_update_ICV_PMR_Type_Priority(
            state,
            tracer,
            s_286_685,
            s_286_686,
        );
        // S s_286_688: call ICV_PMR_write(s_286_687)
        let s_286_688: () = ICV_PMR_write(state, tracer, s_286_687);
        // C s_286_689: const #() : ()
        let s_286_689: () = ();
        // S s_286_690: call ICV_HPPIR0_read(s_286_689)
        let s_286_690: ProductType700c18a878c5601b = ICV_HPPIR0_read(
            state,
            tracer,
            s_286_689,
        );
        // D s_286_691: write-var ga#36140 <= s_286_690
        fn_state.ga_36140 = s_286_690;
        // D s_286_692: read-var ga#36140.0:struct
        let s_286_692: u32 = fn_state.ga_36140._0;
        // C s_286_693: const #8s : i
        let s_286_693: i128 = 8;
        // C s_286_694: const #24s : i
        let s_286_694: i128 = 24;
        // D s_286_695: cast zx s_286_692 -> bv
        let s_286_695: Bits = Bits::new(s_286_692 as u128, 32u16);
        // C s_286_696: const #0u : u8
        let s_286_696: u8 = 0;
        // C s_286_697: cast zx s_286_696 -> bv
        let s_286_697: Bits = Bits::new(s_286_696 as u128, 8u16);
        // C s_286_698: const #1u : u64
        let s_286_698: u64 = 1;
        // C s_286_699: cast zx s_286_698 -> bv
        let s_286_699: Bits = Bits::new(s_286_698 as u128, 64u16);
        // C s_286_700: lsl s_286_699 s_286_693
        let s_286_700: Bits = s_286_699 << s_286_693;
        // C s_286_701: sub s_286_700 s_286_699
        let s_286_701: Bits = ((s_286_700) - (s_286_699));
        // C s_286_702: and s_286_697 s_286_701
        let s_286_702: Bits = ((s_286_697) & (s_286_701));
        // C s_286_703: lsl s_286_702 s_286_694
        let s_286_703: Bits = s_286_702 << s_286_694;
        // C s_286_704: lsl s_286_701 s_286_694
        let s_286_704: Bits = s_286_701 << s_286_694;
        // C s_286_705: cmpl s_286_704
        let s_286_705: Bits = !s_286_704;
        // D s_286_706: and s_286_695 s_286_705
        let s_286_706: Bits = ((s_286_695) & (s_286_705));
        // D s_286_707: or s_286_706 s_286_703
        let s_286_707: Bits = ((s_286_706) | (s_286_703));
        // D s_286_708: cast reint s_286_707 -> u32
        let s_286_708: u32 = (s_286_707.value() as u32);
        // D s_286_709: call Mk_ICV_HPPIR0_Type(s_286_708)
        let s_286_709: ProductType700c18a878c5601b = Mk_ICV_HPPIR0_Type(
            state,
            tracer,
            s_286_708,
        );
        // D s_286_710: call ICV_HPPIR0_write(s_286_709)
        let s_286_710: () = ICV_HPPIR0_write(state, tracer, s_286_709);
        // C s_286_711: const #0s : i
        let s_286_711: i128 = 0;
        // C s_286_712: const #101880u : u32
        let s_286_712: u32 = 101880;
        // D s_286_713: read-reg s_286_712:u32
        let s_286_713: u32 = {
            let value = state.read_register::<u32>(s_286_712 as isize);
            tracer.read_register(s_286_712 as isize, value);
            value
        };
        // D s_286_714: cast zx s_286_713 -> bv
        let s_286_714: Bits = Bits::new(s_286_713 as u128, 32u16);
        // C s_286_715: const #0u : u32
        let s_286_715: u32 = 0;
        // C s_286_716: cast zx s_286_715 -> bv
        let s_286_716: Bits = Bits::new(s_286_715 as u128, 32u16);
        // C s_286_717: const #31s : i
        let s_286_717: i128 = 31;
        // C s_286_718: const #1u : u64
        let s_286_718: u64 = 1;
        // C s_286_719: cast zx s_286_718 -> bv
        let s_286_719: Bits = Bits::new(s_286_718 as u128, 64u16);
        // C s_286_720: lsl s_286_719 s_286_717
        let s_286_720: Bits = s_286_719 << s_286_717;
        // C s_286_721: sub s_286_720 s_286_719
        let s_286_721: Bits = ((s_286_720) - (s_286_719));
        // C s_286_722: and s_286_716 s_286_721
        let s_286_722: Bits = ((s_286_716) & (s_286_721));
        // C s_286_723: lsl s_286_722 s_286_711
        let s_286_723: Bits = s_286_722 << s_286_711;
        // C s_286_724: lsl s_286_721 s_286_711
        let s_286_724: Bits = s_286_721 << s_286_711;
        // C s_286_725: cmpl s_286_724
        let s_286_725: Bits = !s_286_724;
        // D s_286_726: and s_286_714 s_286_725
        let s_286_726: Bits = ((s_286_714) & (s_286_725));
        // D s_286_727: or s_286_726 s_286_723
        let s_286_727: Bits = ((s_286_726) | (s_286_723));
        // D s_286_728: cast reint s_286_727 -> u32
        let s_286_728: u32 = (s_286_727.value() as u32);
        // C s_286_729: const #101880u : u32
        let s_286_729: u32 = 101880;
        // N s_286_730: write-reg s_286_729 <= s_286_728
        let s_286_730: () = {
            state.write_register::<u32>(s_286_729 as isize, s_286_728);
            tracer.write_register(s_286_729 as isize, s_286_728);
        };
        // C s_286_731: const #() : ()
        let s_286_731: () = ();
        // S s_286_732: call HSCTLR_read(s_286_731)
        let s_286_732: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_731,
        );
        // D s_286_733: write-var ga#36144 <= s_286_732
        fn_state.ga_36144 = s_286_732;
        // D s_286_734: read-var ga#36144.0:struct
        let s_286_734: u32 = fn_state.ga_36144._0;
        // C s_286_735: const #2s : i
        let s_286_735: i128 = 2;
        // C s_286_736: const #28s : i
        let s_286_736: i128 = 28;
        // D s_286_737: cast zx s_286_734 -> bv
        let s_286_737: Bits = Bits::new(s_286_734 as u128, 32u16);
        // C s_286_738: const #3u : u8
        let s_286_738: u8 = 3;
        // C s_286_739: cast zx s_286_738 -> bv
        let s_286_739: Bits = Bits::new(s_286_738 as u128, 2u16);
        // C s_286_740: const #1u : u64
        let s_286_740: u64 = 1;
        // C s_286_741: cast zx s_286_740 -> bv
        let s_286_741: Bits = Bits::new(s_286_740 as u128, 64u16);
        // C s_286_742: lsl s_286_741 s_286_735
        let s_286_742: Bits = s_286_741 << s_286_735;
        // C s_286_743: sub s_286_742 s_286_741
        let s_286_743: Bits = ((s_286_742) - (s_286_741));
        // C s_286_744: and s_286_739 s_286_743
        let s_286_744: Bits = ((s_286_739) & (s_286_743));
        // C s_286_745: lsl s_286_744 s_286_736
        let s_286_745: Bits = s_286_744 << s_286_736;
        // C s_286_746: lsl s_286_743 s_286_736
        let s_286_746: Bits = s_286_743 << s_286_736;
        // C s_286_747: cmpl s_286_746
        let s_286_747: Bits = !s_286_746;
        // D s_286_748: and s_286_737 s_286_747
        let s_286_748: Bits = ((s_286_737) & (s_286_747));
        // D s_286_749: or s_286_748 s_286_745
        let s_286_749: Bits = ((s_286_748) | (s_286_745));
        // D s_286_750: cast reint s_286_749 -> u32
        let s_286_750: u32 = (s_286_749.value() as u32);
        // D s_286_751: call Mk_HSCTLR_Type(s_286_750)
        let s_286_751: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_750,
        );
        // D s_286_752: call HSCTLR_write(s_286_751)
        let s_286_752: () = HSCTLR_write(state, tracer, s_286_751);
        // C s_286_753: const #() : ()
        let s_286_753: () = ();
        // S s_286_754: call HSCTLR_read(s_286_753)
        let s_286_754: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_753,
        );
        // D s_286_755: write-var ga#36148 <= s_286_754
        fn_state.ga_36148 = s_286_754;
        // D s_286_756: read-var ga#36148.0:struct
        let s_286_756: u32 = fn_state.ga_36148._0;
        // C s_286_757: const #2s : i
        let s_286_757: i128 = 2;
        // C s_286_758: const #26s : i
        let s_286_758: i128 = 26;
        // D s_286_759: cast zx s_286_756 -> bv
        let s_286_759: Bits = Bits::new(s_286_756 as u128, 32u16);
        // C s_286_760: const #0u : u8
        let s_286_760: u8 = 0;
        // C s_286_761: cast zx s_286_760 -> bv
        let s_286_761: Bits = Bits::new(s_286_760 as u128, 2u16);
        // C s_286_762: const #1u : u64
        let s_286_762: u64 = 1;
        // C s_286_763: cast zx s_286_762 -> bv
        let s_286_763: Bits = Bits::new(s_286_762 as u128, 64u16);
        // C s_286_764: lsl s_286_763 s_286_757
        let s_286_764: Bits = s_286_763 << s_286_757;
        // C s_286_765: sub s_286_764 s_286_763
        let s_286_765: Bits = ((s_286_764) - (s_286_763));
        // C s_286_766: and s_286_761 s_286_765
        let s_286_766: Bits = ((s_286_761) & (s_286_765));
        // C s_286_767: lsl s_286_766 s_286_758
        let s_286_767: Bits = s_286_766 << s_286_758;
        // C s_286_768: lsl s_286_765 s_286_758
        let s_286_768: Bits = s_286_765 << s_286_758;
        // C s_286_769: cmpl s_286_768
        let s_286_769: Bits = !s_286_768;
        // D s_286_770: and s_286_759 s_286_769
        let s_286_770: Bits = ((s_286_759) & (s_286_769));
        // D s_286_771: or s_286_770 s_286_767
        let s_286_771: Bits = ((s_286_770) | (s_286_767));
        // D s_286_772: cast reint s_286_771 -> u32
        let s_286_772: u32 = (s_286_771.value() as u32);
        // D s_286_773: call Mk_HSCTLR_Type(s_286_772)
        let s_286_773: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_772,
        );
        // D s_286_774: call HSCTLR_write(s_286_773)
        let s_286_774: () = HSCTLR_write(state, tracer, s_286_773);
        // C s_286_775: const #() : ()
        let s_286_775: () = ();
        // S s_286_776: call HSCTLR_read(s_286_775)
        let s_286_776: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_775,
        );
        // D s_286_777: write-var ga#36152 <= s_286_776
        fn_state.ga_36152 = s_286_776;
        // D s_286_778: read-var ga#36152.0:struct
        let s_286_778: u32 = fn_state.ga_36152._0;
        // C s_286_779: const #1s : i
        let s_286_779: i128 = 1;
        // C s_286_780: const #24s : i
        let s_286_780: i128 = 24;
        // D s_286_781: cast zx s_286_778 -> bv
        let s_286_781: Bits = Bits::new(s_286_778 as u128, 32u16);
        // C s_286_782: const #0u : u8
        let s_286_782: bool = false;
        // C s_286_783: cast zx s_286_782 -> bv
        let s_286_783: Bits = Bits::new(s_286_782 as u128, 1u16);
        // C s_286_784: const #1u : u64
        let s_286_784: u64 = 1;
        // C s_286_785: cast zx s_286_784 -> bv
        let s_286_785: Bits = Bits::new(s_286_784 as u128, 64u16);
        // C s_286_786: lsl s_286_785 s_286_779
        let s_286_786: Bits = s_286_785 << s_286_779;
        // C s_286_787: sub s_286_786 s_286_785
        let s_286_787: Bits = ((s_286_786) - (s_286_785));
        // C s_286_788: and s_286_783 s_286_787
        let s_286_788: Bits = ((s_286_783) & (s_286_787));
        // C s_286_789: lsl s_286_788 s_286_780
        let s_286_789: Bits = s_286_788 << s_286_780;
        // C s_286_790: lsl s_286_787 s_286_780
        let s_286_790: Bits = s_286_787 << s_286_780;
        // C s_286_791: cmpl s_286_790
        let s_286_791: Bits = !s_286_790;
        // D s_286_792: and s_286_781 s_286_791
        let s_286_792: Bits = ((s_286_781) & (s_286_791));
        // D s_286_793: or s_286_792 s_286_789
        let s_286_793: Bits = ((s_286_792) | (s_286_789));
        // D s_286_794: cast reint s_286_793 -> u32
        let s_286_794: u32 = (s_286_793.value() as u32);
        // D s_286_795: call Mk_HSCTLR_Type(s_286_794)
        let s_286_795: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_794,
        );
        // D s_286_796: call HSCTLR_write(s_286_795)
        let s_286_796: () = HSCTLR_write(state, tracer, s_286_795);
        // C s_286_797: const #() : ()
        let s_286_797: () = ();
        // S s_286_798: call HSCTLR_read(s_286_797)
        let s_286_798: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_797,
        );
        // D s_286_799: write-var ga#36156 <= s_286_798
        fn_state.ga_36156 = s_286_798;
        // D s_286_800: read-var ga#36156.0:struct
        let s_286_800: u32 = fn_state.ga_36156._0;
        // C s_286_801: const #2s : i
        let s_286_801: i128 = 2;
        // C s_286_802: const #22s : i
        let s_286_802: i128 = 22;
        // D s_286_803: cast zx s_286_800 -> bv
        let s_286_803: Bits = Bits::new(s_286_800 as u128, 32u16);
        // C s_286_804: const #3u : u8
        let s_286_804: u8 = 3;
        // C s_286_805: cast zx s_286_804 -> bv
        let s_286_805: Bits = Bits::new(s_286_804 as u128, 2u16);
        // C s_286_806: const #1u : u64
        let s_286_806: u64 = 1;
        // C s_286_807: cast zx s_286_806 -> bv
        let s_286_807: Bits = Bits::new(s_286_806 as u128, 64u16);
        // C s_286_808: lsl s_286_807 s_286_801
        let s_286_808: Bits = s_286_807 << s_286_801;
        // C s_286_809: sub s_286_808 s_286_807
        let s_286_809: Bits = ((s_286_808) - (s_286_807));
        // C s_286_810: and s_286_805 s_286_809
        let s_286_810: Bits = ((s_286_805) & (s_286_809));
        // C s_286_811: lsl s_286_810 s_286_802
        let s_286_811: Bits = s_286_810 << s_286_802;
        // C s_286_812: lsl s_286_809 s_286_802
        let s_286_812: Bits = s_286_809 << s_286_802;
        // C s_286_813: cmpl s_286_812
        let s_286_813: Bits = !s_286_812;
        // D s_286_814: and s_286_803 s_286_813
        let s_286_814: Bits = ((s_286_803) & (s_286_813));
        // D s_286_815: or s_286_814 s_286_811
        let s_286_815: Bits = ((s_286_814) | (s_286_811));
        // D s_286_816: cast reint s_286_815 -> u32
        let s_286_816: u32 = (s_286_815.value() as u32);
        // D s_286_817: call Mk_HSCTLR_Type(s_286_816)
        let s_286_817: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_816,
        );
        // D s_286_818: call HSCTLR_write(s_286_817)
        let s_286_818: () = HSCTLR_write(state, tracer, s_286_817);
        // C s_286_819: const #() : ()
        let s_286_819: () = ();
        // S s_286_820: call HSCTLR_read(s_286_819)
        let s_286_820: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_819,
        );
        // D s_286_821: write-var ga#36160 <= s_286_820
        fn_state.ga_36160 = s_286_820;
        // D s_286_822: read-var ga#36160.0:struct
        let s_286_822: u32 = fn_state.ga_36160._0;
        // C s_286_823: const #2s : i
        let s_286_823: i128 = 2;
        // C s_286_824: const #20s : i
        let s_286_824: i128 = 20;
        // D s_286_825: cast zx s_286_822 -> bv
        let s_286_825: Bits = Bits::new(s_286_822 as u128, 32u16);
        // C s_286_826: const #0u : u8
        let s_286_826: u8 = 0;
        // C s_286_827: cast zx s_286_826 -> bv
        let s_286_827: Bits = Bits::new(s_286_826 as u128, 2u16);
        // C s_286_828: const #1u : u64
        let s_286_828: u64 = 1;
        // C s_286_829: cast zx s_286_828 -> bv
        let s_286_829: Bits = Bits::new(s_286_828 as u128, 64u16);
        // C s_286_830: lsl s_286_829 s_286_823
        let s_286_830: Bits = s_286_829 << s_286_823;
        // C s_286_831: sub s_286_830 s_286_829
        let s_286_831: Bits = ((s_286_830) - (s_286_829));
        // C s_286_832: and s_286_827 s_286_831
        let s_286_832: Bits = ((s_286_827) & (s_286_831));
        // C s_286_833: lsl s_286_832 s_286_824
        let s_286_833: Bits = s_286_832 << s_286_824;
        // C s_286_834: lsl s_286_831 s_286_824
        let s_286_834: Bits = s_286_831 << s_286_824;
        // C s_286_835: cmpl s_286_834
        let s_286_835: Bits = !s_286_834;
        // D s_286_836: and s_286_825 s_286_835
        let s_286_836: Bits = ((s_286_825) & (s_286_835));
        // D s_286_837: or s_286_836 s_286_833
        let s_286_837: Bits = ((s_286_836) | (s_286_833));
        // D s_286_838: cast reint s_286_837 -> u32
        let s_286_838: u32 = (s_286_837.value() as u32);
        // D s_286_839: call Mk_HSCTLR_Type(s_286_838)
        let s_286_839: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_838,
        );
        // D s_286_840: call HSCTLR_write(s_286_839)
        let s_286_840: () = HSCTLR_write(state, tracer, s_286_839);
        // C s_286_841: const #() : ()
        let s_286_841: () = ();
        // S s_286_842: call HSCTLR_read(s_286_841)
        let s_286_842: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_841,
        );
        // D s_286_843: write-var ga#36164 <= s_286_842
        fn_state.ga_36164 = s_286_842;
        // D s_286_844: read-var ga#36164.0:struct
        let s_286_844: u32 = fn_state.ga_36164._0;
        // C s_286_845: const #1s : i
        let s_286_845: i128 = 1;
        // C s_286_846: const #18s : i
        let s_286_846: i128 = 18;
        // D s_286_847: cast zx s_286_844 -> bv
        let s_286_847: Bits = Bits::new(s_286_844 as u128, 32u16);
        // C s_286_848: const #1u : u8
        let s_286_848: bool = true;
        // C s_286_849: cast zx s_286_848 -> bv
        let s_286_849: Bits = Bits::new(s_286_848 as u128, 1u16);
        // C s_286_850: const #1u : u64
        let s_286_850: u64 = 1;
        // C s_286_851: cast zx s_286_850 -> bv
        let s_286_851: Bits = Bits::new(s_286_850 as u128, 64u16);
        // C s_286_852: lsl s_286_851 s_286_845
        let s_286_852: Bits = s_286_851 << s_286_845;
        // C s_286_853: sub s_286_852 s_286_851
        let s_286_853: Bits = ((s_286_852) - (s_286_851));
        // C s_286_854: and s_286_849 s_286_853
        let s_286_854: Bits = ((s_286_849) & (s_286_853));
        // C s_286_855: lsl s_286_854 s_286_846
        let s_286_855: Bits = s_286_854 << s_286_846;
        // C s_286_856: lsl s_286_853 s_286_846
        let s_286_856: Bits = s_286_853 << s_286_846;
        // C s_286_857: cmpl s_286_856
        let s_286_857: Bits = !s_286_856;
        // D s_286_858: and s_286_847 s_286_857
        let s_286_858: Bits = ((s_286_847) & (s_286_857));
        // D s_286_859: or s_286_858 s_286_855
        let s_286_859: Bits = ((s_286_858) | (s_286_855));
        // D s_286_860: cast reint s_286_859 -> u32
        let s_286_860: u32 = (s_286_859.value() as u32);
        // D s_286_861: call Mk_HSCTLR_Type(s_286_860)
        let s_286_861: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_860,
        );
        // D s_286_862: call HSCTLR_write(s_286_861)
        let s_286_862: () = HSCTLR_write(state, tracer, s_286_861);
        // C s_286_863: const #() : ()
        let s_286_863: () = ();
        // S s_286_864: call HSCTLR_read(s_286_863)
        let s_286_864: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_863,
        );
        // D s_286_865: write-var ga#36168 <= s_286_864
        fn_state.ga_36168 = s_286_864;
        // D s_286_866: read-var ga#36168.0:struct
        let s_286_866: u32 = fn_state.ga_36168._0;
        // C s_286_867: const #1s : i
        let s_286_867: i128 = 1;
        // C s_286_868: const #17s : i
        let s_286_868: i128 = 17;
        // D s_286_869: cast zx s_286_866 -> bv
        let s_286_869: Bits = Bits::new(s_286_866 as u128, 32u16);
        // C s_286_870: const #0u : u8
        let s_286_870: bool = false;
        // C s_286_871: cast zx s_286_870 -> bv
        let s_286_871: Bits = Bits::new(s_286_870 as u128, 1u16);
        // C s_286_872: const #1u : u64
        let s_286_872: u64 = 1;
        // C s_286_873: cast zx s_286_872 -> bv
        let s_286_873: Bits = Bits::new(s_286_872 as u128, 64u16);
        // C s_286_874: lsl s_286_873 s_286_867
        let s_286_874: Bits = s_286_873 << s_286_867;
        // C s_286_875: sub s_286_874 s_286_873
        let s_286_875: Bits = ((s_286_874) - (s_286_873));
        // C s_286_876: and s_286_871 s_286_875
        let s_286_876: Bits = ((s_286_871) & (s_286_875));
        // C s_286_877: lsl s_286_876 s_286_868
        let s_286_877: Bits = s_286_876 << s_286_868;
        // C s_286_878: lsl s_286_875 s_286_868
        let s_286_878: Bits = s_286_875 << s_286_868;
        // C s_286_879: cmpl s_286_878
        let s_286_879: Bits = !s_286_878;
        // D s_286_880: and s_286_869 s_286_879
        let s_286_880: Bits = ((s_286_869) & (s_286_879));
        // D s_286_881: or s_286_880 s_286_877
        let s_286_881: Bits = ((s_286_880) | (s_286_877));
        // D s_286_882: cast reint s_286_881 -> u32
        let s_286_882: u32 = (s_286_881.value() as u32);
        // D s_286_883: call Mk_HSCTLR_Type(s_286_882)
        let s_286_883: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_882,
        );
        // D s_286_884: call HSCTLR_write(s_286_883)
        let s_286_884: () = HSCTLR_write(state, tracer, s_286_883);
        // C s_286_885: const #() : ()
        let s_286_885: () = ();
        // S s_286_886: call HSCTLR_read(s_286_885)
        let s_286_886: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_885,
        );
        // D s_286_887: write-var ga#36172 <= s_286_886
        fn_state.ga_36172 = s_286_886;
        // D s_286_888: read-var ga#36172.0:struct
        let s_286_888: u32 = fn_state.ga_36172._0;
        // C s_286_889: const #1s : i
        let s_286_889: i128 = 1;
        // C s_286_890: const #16s : i
        let s_286_890: i128 = 16;
        // D s_286_891: cast zx s_286_888 -> bv
        let s_286_891: Bits = Bits::new(s_286_888 as u128, 32u16);
        // C s_286_892: const #1u : u8
        let s_286_892: bool = true;
        // C s_286_893: cast zx s_286_892 -> bv
        let s_286_893: Bits = Bits::new(s_286_892 as u128, 1u16);
        // C s_286_894: const #1u : u64
        let s_286_894: u64 = 1;
        // C s_286_895: cast zx s_286_894 -> bv
        let s_286_895: Bits = Bits::new(s_286_894 as u128, 64u16);
        // C s_286_896: lsl s_286_895 s_286_889
        let s_286_896: Bits = s_286_895 << s_286_889;
        // C s_286_897: sub s_286_896 s_286_895
        let s_286_897: Bits = ((s_286_896) - (s_286_895));
        // C s_286_898: and s_286_893 s_286_897
        let s_286_898: Bits = ((s_286_893) & (s_286_897));
        // C s_286_899: lsl s_286_898 s_286_890
        let s_286_899: Bits = s_286_898 << s_286_890;
        // C s_286_900: lsl s_286_897 s_286_890
        let s_286_900: Bits = s_286_897 << s_286_890;
        // C s_286_901: cmpl s_286_900
        let s_286_901: Bits = !s_286_900;
        // D s_286_902: and s_286_891 s_286_901
        let s_286_902: Bits = ((s_286_891) & (s_286_901));
        // D s_286_903: or s_286_902 s_286_899
        let s_286_903: Bits = ((s_286_902) | (s_286_899));
        // D s_286_904: cast reint s_286_903 -> u32
        let s_286_904: u32 = (s_286_903.value() as u32);
        // D s_286_905: call Mk_HSCTLR_Type(s_286_904)
        let s_286_905: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_904,
        );
        // D s_286_906: call HSCTLR_write(s_286_905)
        let s_286_906: () = HSCTLR_write(state, tracer, s_286_905);
        // C s_286_907: const #() : ()
        let s_286_907: () = ();
        // S s_286_908: call HSCTLR_read(s_286_907)
        let s_286_908: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_907,
        );
        // D s_286_909: write-var ga#36176 <= s_286_908
        fn_state.ga_36176 = s_286_908;
        // D s_286_910: read-var ga#36176.0:struct
        let s_286_910: u32 = fn_state.ga_36176._0;
        // C s_286_911: const #3s : i
        let s_286_911: i128 = 3;
        // C s_286_912: const #13s : i
        let s_286_912: i128 = 13;
        // D s_286_913: cast zx s_286_910 -> bv
        let s_286_913: Bits = Bits::new(s_286_910 as u128, 32u16);
        // C s_286_914: const #0u : u8
        let s_286_914: u8 = 0;
        // C s_286_915: cast zx s_286_914 -> bv
        let s_286_915: Bits = Bits::new(s_286_914 as u128, 3u16);
        // C s_286_916: const #1u : u64
        let s_286_916: u64 = 1;
        // C s_286_917: cast zx s_286_916 -> bv
        let s_286_917: Bits = Bits::new(s_286_916 as u128, 64u16);
        // C s_286_918: lsl s_286_917 s_286_911
        let s_286_918: Bits = s_286_917 << s_286_911;
        // C s_286_919: sub s_286_918 s_286_917
        let s_286_919: Bits = ((s_286_918) - (s_286_917));
        // C s_286_920: and s_286_915 s_286_919
        let s_286_920: Bits = ((s_286_915) & (s_286_919));
        // C s_286_921: lsl s_286_920 s_286_912
        let s_286_921: Bits = s_286_920 << s_286_912;
        // C s_286_922: lsl s_286_919 s_286_912
        let s_286_922: Bits = s_286_919 << s_286_912;
        // C s_286_923: cmpl s_286_922
        let s_286_923: Bits = !s_286_922;
        // D s_286_924: and s_286_913 s_286_923
        let s_286_924: Bits = ((s_286_913) & (s_286_923));
        // D s_286_925: or s_286_924 s_286_921
        let s_286_925: Bits = ((s_286_924) | (s_286_921));
        // D s_286_926: cast reint s_286_925 -> u32
        let s_286_926: u32 = (s_286_925.value() as u32);
        // D s_286_927: call Mk_HSCTLR_Type(s_286_926)
        let s_286_927: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_926,
        );
        // D s_286_928: call HSCTLR_write(s_286_927)
        let s_286_928: () = HSCTLR_write(state, tracer, s_286_927);
        // C s_286_929: const #() : ()
        let s_286_929: () = ();
        // S s_286_930: call HSCTLR_read(s_286_929)
        let s_286_930: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_929,
        );
        // C s_286_931: const #0u : u8
        let s_286_931: bool = false;
        // S s_286_932: call _update_HSCTLR_Type_I(s_286_930, s_286_931)
        let s_286_932: ProductType700c18a878c5601b = u_update_HSCTLR_Type_I(
            state,
            tracer,
            s_286_930,
            s_286_931,
        );
        // S s_286_933: call HSCTLR_write(s_286_932)
        let s_286_933: () = HSCTLR_write(state, tracer, s_286_932);
        // C s_286_934: const #() : ()
        let s_286_934: () = ();
        // S s_286_935: call HSCTLR_read(s_286_934)
        let s_286_935: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_934,
        );
        // D s_286_936: write-var ga#36182 <= s_286_935
        fn_state.ga_36182 = s_286_935;
        // D s_286_937: read-var ga#36182.0:struct
        let s_286_937: u32 = fn_state.ga_36182._0;
        // C s_286_938: const #1s : i
        let s_286_938: i128 = 1;
        // C s_286_939: const #11s : i
        let s_286_939: i128 = 11;
        // D s_286_940: cast zx s_286_937 -> bv
        let s_286_940: Bits = Bits::new(s_286_937 as u128, 32u16);
        // C s_286_941: const #1u : u8
        let s_286_941: bool = true;
        // C s_286_942: cast zx s_286_941 -> bv
        let s_286_942: Bits = Bits::new(s_286_941 as u128, 1u16);
        // C s_286_943: const #1u : u64
        let s_286_943: u64 = 1;
        // C s_286_944: cast zx s_286_943 -> bv
        let s_286_944: Bits = Bits::new(s_286_943 as u128, 64u16);
        // C s_286_945: lsl s_286_944 s_286_938
        let s_286_945: Bits = s_286_944 << s_286_938;
        // C s_286_946: sub s_286_945 s_286_944
        let s_286_946: Bits = ((s_286_945) - (s_286_944));
        // C s_286_947: and s_286_942 s_286_946
        let s_286_947: Bits = ((s_286_942) & (s_286_946));
        // C s_286_948: lsl s_286_947 s_286_939
        let s_286_948: Bits = s_286_947 << s_286_939;
        // C s_286_949: lsl s_286_946 s_286_939
        let s_286_949: Bits = s_286_946 << s_286_939;
        // C s_286_950: cmpl s_286_949
        let s_286_950: Bits = !s_286_949;
        // D s_286_951: and s_286_940 s_286_950
        let s_286_951: Bits = ((s_286_940) & (s_286_950));
        // D s_286_952: or s_286_951 s_286_948
        let s_286_952: Bits = ((s_286_951) | (s_286_948));
        // D s_286_953: cast reint s_286_952 -> u32
        let s_286_953: u32 = (s_286_952.value() as u32);
        // D s_286_954: call Mk_HSCTLR_Type(s_286_953)
        let s_286_954: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_953,
        );
        // D s_286_955: call HSCTLR_write(s_286_954)
        let s_286_955: () = HSCTLR_write(state, tracer, s_286_954);
        // C s_286_956: const #() : ()
        let s_286_956: () = ();
        // S s_286_957: call HSCTLR_read(s_286_956)
        let s_286_957: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_956,
        );
        // D s_286_958: write-var ga#36186 <= s_286_957
        fn_state.ga_36186 = s_286_957;
        // D s_286_959: read-var ga#36186.0:struct
        let s_286_959: u32 = fn_state.ga_36186._0;
        // C s_286_960: const #2s : i
        let s_286_960: i128 = 2;
        // C s_286_961: const #9s : i
        let s_286_961: i128 = 9;
        // D s_286_962: cast zx s_286_959 -> bv
        let s_286_962: Bits = Bits::new(s_286_959 as u128, 32u16);
        // C s_286_963: const #0u : u8
        let s_286_963: u8 = 0;
        // C s_286_964: cast zx s_286_963 -> bv
        let s_286_964: Bits = Bits::new(s_286_963 as u128, 2u16);
        // C s_286_965: const #1u : u64
        let s_286_965: u64 = 1;
        // C s_286_966: cast zx s_286_965 -> bv
        let s_286_966: Bits = Bits::new(s_286_965 as u128, 64u16);
        // C s_286_967: lsl s_286_966 s_286_960
        let s_286_967: Bits = s_286_966 << s_286_960;
        // C s_286_968: sub s_286_967 s_286_966
        let s_286_968: Bits = ((s_286_967) - (s_286_966));
        // C s_286_969: and s_286_964 s_286_968
        let s_286_969: Bits = ((s_286_964) & (s_286_968));
        // C s_286_970: lsl s_286_969 s_286_961
        let s_286_970: Bits = s_286_969 << s_286_961;
        // C s_286_971: lsl s_286_968 s_286_961
        let s_286_971: Bits = s_286_968 << s_286_961;
        // C s_286_972: cmpl s_286_971
        let s_286_972: Bits = !s_286_971;
        // D s_286_973: and s_286_962 s_286_972
        let s_286_973: Bits = ((s_286_962) & (s_286_972));
        // D s_286_974: or s_286_973 s_286_970
        let s_286_974: Bits = ((s_286_973) | (s_286_970));
        // D s_286_975: cast reint s_286_974 -> u32
        let s_286_975: u32 = (s_286_974.value() as u32);
        // D s_286_976: call Mk_HSCTLR_Type(s_286_975)
        let s_286_976: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_975,
        );
        // D s_286_977: call HSCTLR_write(s_286_976)
        let s_286_977: () = HSCTLR_write(state, tracer, s_286_976);
        // C s_286_978: const #() : ()
        let s_286_978: () = ();
        // S s_286_979: call HSCTLR_read(s_286_978)
        let s_286_979: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_978,
        );
        // D s_286_980: write-var ga#36190 <= s_286_979
        fn_state.ga_36190 = s_286_979;
        // D s_286_981: read-var ga#36190.0:struct
        let s_286_981: u32 = fn_state.ga_36190._0;
        // C s_286_982: const #1s : i
        let s_286_982: i128 = 1;
        // C s_286_983: const #6s : i
        let s_286_983: i128 = 6;
        // D s_286_984: cast zx s_286_981 -> bv
        let s_286_984: Bits = Bits::new(s_286_981 as u128, 32u16);
        // C s_286_985: const #0u : u8
        let s_286_985: bool = false;
        // C s_286_986: cast zx s_286_985 -> bv
        let s_286_986: Bits = Bits::new(s_286_985 as u128, 1u16);
        // C s_286_987: const #1u : u64
        let s_286_987: u64 = 1;
        // C s_286_988: cast zx s_286_987 -> bv
        let s_286_988: Bits = Bits::new(s_286_987 as u128, 64u16);
        // C s_286_989: lsl s_286_988 s_286_982
        let s_286_989: Bits = s_286_988 << s_286_982;
        // C s_286_990: sub s_286_989 s_286_988
        let s_286_990: Bits = ((s_286_989) - (s_286_988));
        // C s_286_991: and s_286_986 s_286_990
        let s_286_991: Bits = ((s_286_986) & (s_286_990));
        // C s_286_992: lsl s_286_991 s_286_983
        let s_286_992: Bits = s_286_991 << s_286_983;
        // C s_286_993: lsl s_286_990 s_286_983
        let s_286_993: Bits = s_286_990 << s_286_983;
        // C s_286_994: cmpl s_286_993
        let s_286_994: Bits = !s_286_993;
        // D s_286_995: and s_286_984 s_286_994
        let s_286_995: Bits = ((s_286_984) & (s_286_994));
        // D s_286_996: or s_286_995 s_286_992
        let s_286_996: Bits = ((s_286_995) | (s_286_992));
        // D s_286_997: cast reint s_286_996 -> u32
        let s_286_997: u32 = (s_286_996.value() as u32);
        // D s_286_998: call Mk_HSCTLR_Type(s_286_997)
        let s_286_998: ProductType700c18a878c5601b = Mk_HSCTLR_Type(
            state,
            tracer,
            s_286_997,
        );
        // D s_286_999: call HSCTLR_write(s_286_998)
        let s_286_999: () = HSCTLR_write(state, tracer, s_286_998);
        // C s_286_1000: const #() : ()
        let s_286_1000: () = ();
        // S s_286_1001: call HSCTLR_read(s_286_1000)
        let s_286_1001: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_1000,
        );
        // C s_286_1002: const #1u : u8
        let s_286_1002: bool = true;
        // S s_286_1003: call _update_HSCTLR_Type_LSMAOE(s_286_1001, s_286_1002)
        let s_286_1003: ProductType700c18a878c5601b = u_update_HSCTLR_Type_LSMAOE(
            state,
            tracer,
            s_286_1001,
            s_286_1002,
        );
        // S s_286_1004: call HSCTLR_write(s_286_1003)
        let s_286_1004: () = HSCTLR_write(state, tracer, s_286_1003);
        // C s_286_1005: const #() : ()
        let s_286_1005: () = ();
        // S s_286_1006: call HSCTLR_read(s_286_1005)
        let s_286_1006: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_1005,
        );
        // C s_286_1007: const #1u : u8
        let s_286_1007: bool = true;
        // S s_286_1008: call _update_HSCTLR_Type_nTLSMD(s_286_1006, s_286_1007)
        let s_286_1008: ProductType700c18a878c5601b = u_update_HSCTLR_Type_nTLSMD(
            state,
            tracer,
            s_286_1006,
            s_286_1007,
        );
        // S s_286_1009: call HSCTLR_write(s_286_1008)
        let s_286_1009: () = HSCTLR_write(state, tracer, s_286_1008);
        // C s_286_1010: const #() : ()
        let s_286_1010: () = ();
        // S s_286_1011: call HSCTLR_read(s_286_1010)
        let s_286_1011: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_1010,
        );
        // C s_286_1012: const #0u : u8
        let s_286_1012: bool = false;
        // S s_286_1013: call _update_HSCTLR_Type_C(s_286_1011, s_286_1012)
        let s_286_1013: ProductType700c18a878c5601b = u_update_HSCTLR_Type_C(
            state,
            tracer,
            s_286_1011,
            s_286_1012,
        );
        // S s_286_1014: call HSCTLR_write(s_286_1013)
        let s_286_1014: () = HSCTLR_write(state, tracer, s_286_1013);
        // C s_286_1015: const #() : ()
        let s_286_1015: () = ();
        // S s_286_1016: call HSCTLR_read(s_286_1015)
        let s_286_1016: ProductType700c18a878c5601b = HSCTLR_read(
            state,
            tracer,
            s_286_1015,
        );
        // C s_286_1017: const #0u : u8
        let s_286_1017: bool = false;
        // S s_286_1018: call _update_HSCTLR_Type_M(s_286_1016, s_286_1017)
        let s_286_1018: ProductType700c18a878c5601b = u_update_HSCTLR_Type_M(
            state,
            tracer,
            s_286_1016,
            s_286_1017,
        );
        // S s_286_1019: call HSCTLR_write(s_286_1018)
        let s_286_1019: () = HSCTLR_write(state, tracer, s_286_1018);
        // C s_286_1020: const #() : ()
        let s_286_1020: () = ();
        // S s_286_1021: call VTCR_read(s_286_1020)
        let s_286_1021: ProductType700c18a878c5601b = VTCR_read(
            state,
            tracer,
            s_286_1020,
        );
        // D s_286_1022: write-var ga#36202 <= s_286_1021
        fn_state.ga_36202 = s_286_1021;
        // D s_286_1023: read-var ga#36202.0:struct
        let s_286_1023: u32 = fn_state.ga_36202._0;
        // C s_286_1024: const #1s : i
        let s_286_1024: i128 = 1;
        // C s_286_1025: const #31s : i
        let s_286_1025: i128 = 31;
        // D s_286_1026: cast zx s_286_1023 -> bv
        let s_286_1026: Bits = Bits::new(s_286_1023 as u128, 32u16);
        // C s_286_1027: const #1u : u8
        let s_286_1027: bool = true;
        // C s_286_1028: cast zx s_286_1027 -> bv
        let s_286_1028: Bits = Bits::new(s_286_1027 as u128, 1u16);
        // C s_286_1029: const #1u : u64
        let s_286_1029: u64 = 1;
        // C s_286_1030: cast zx s_286_1029 -> bv
        let s_286_1030: Bits = Bits::new(s_286_1029 as u128, 64u16);
        // C s_286_1031: lsl s_286_1030 s_286_1024
        let s_286_1031: Bits = s_286_1030 << s_286_1024;
        // C s_286_1032: sub s_286_1031 s_286_1030
        let s_286_1032: Bits = ((s_286_1031) - (s_286_1030));
        // C s_286_1033: and s_286_1028 s_286_1032
        let s_286_1033: Bits = ((s_286_1028) & (s_286_1032));
        // C s_286_1034: lsl s_286_1033 s_286_1025
        let s_286_1034: Bits = s_286_1033 << s_286_1025;
        // C s_286_1035: lsl s_286_1032 s_286_1025
        let s_286_1035: Bits = s_286_1032 << s_286_1025;
        // C s_286_1036: cmpl s_286_1035
        let s_286_1036: Bits = !s_286_1035;
        // D s_286_1037: and s_286_1026 s_286_1036
        let s_286_1037: Bits = ((s_286_1026) & (s_286_1036));
        // D s_286_1038: or s_286_1037 s_286_1034
        let s_286_1038: Bits = ((s_286_1037) | (s_286_1034));
        // D s_286_1039: cast reint s_286_1038 -> u32
        let s_286_1039: u32 = (s_286_1038.value() as u32);
        // D s_286_1040: call Mk_VTCR_Type(s_286_1039)
        let s_286_1040: ProductType700c18a878c5601b = Mk_VTCR_Type(
            state,
            tracer,
            s_286_1039,
        );
        // D s_286_1041: call VTCR_write(s_286_1040)
        let s_286_1041: () = VTCR_write(state, tracer, s_286_1040);
        // C s_286_1042: const #() : ()
        let s_286_1042: () = ();
        // S s_286_1043: call VTCR_read(s_286_1042)
        let s_286_1043: ProductType700c18a878c5601b = VTCR_read(
            state,
            tracer,
            s_286_1042,
        );
        // D s_286_1044: write-var ga#36206 <= s_286_1043
        fn_state.ga_36206 = s_286_1043;
        // D s_286_1045: read-var ga#36206.0:struct
        let s_286_1045: u32 = fn_state.ga_36206._0;
        // C s_286_1046: const #2s : i
        let s_286_1046: i128 = 2;
        // C s_286_1047: const #29s : i
        let s_286_1047: i128 = 29;
        // D s_286_1048: cast zx s_286_1045 -> bv
        let s_286_1048: Bits = Bits::new(s_286_1045 as u128, 32u16);
        // C s_286_1049: const #0u : u8
        let s_286_1049: u8 = 0;
        // C s_286_1050: cast zx s_286_1049 -> bv
        let s_286_1050: Bits = Bits::new(s_286_1049 as u128, 2u16);
        // C s_286_1051: const #1u : u64
        let s_286_1051: u64 = 1;
        // C s_286_1052: cast zx s_286_1051 -> bv
        let s_286_1052: Bits = Bits::new(s_286_1051 as u128, 64u16);
        // C s_286_1053: lsl s_286_1052 s_286_1046
        let s_286_1053: Bits = s_286_1052 << s_286_1046;
        // C s_286_1054: sub s_286_1053 s_286_1052
        let s_286_1054: Bits = ((s_286_1053) - (s_286_1052));
        // C s_286_1055: and s_286_1050 s_286_1054
        let s_286_1055: Bits = ((s_286_1050) & (s_286_1054));
        // C s_286_1056: lsl s_286_1055 s_286_1047
        let s_286_1056: Bits = s_286_1055 << s_286_1047;
        // C s_286_1057: lsl s_286_1054 s_286_1047
        let s_286_1057: Bits = s_286_1054 << s_286_1047;
        // C s_286_1058: cmpl s_286_1057
        let s_286_1058: Bits = !s_286_1057;
        // D s_286_1059: and s_286_1048 s_286_1058
        let s_286_1059: Bits = ((s_286_1048) & (s_286_1058));
        // D s_286_1060: or s_286_1059 s_286_1056
        let s_286_1060: Bits = ((s_286_1059) | (s_286_1056));
        // D s_286_1061: cast reint s_286_1060 -> u32
        let s_286_1061: u32 = (s_286_1060.value() as u32);
        // D s_286_1062: call Mk_VTCR_Type(s_286_1061)
        let s_286_1062: ProductType700c18a878c5601b = Mk_VTCR_Type(
            state,
            tracer,
            s_286_1061,
        );
        // D s_286_1063: call VTCR_write(s_286_1062)
        let s_286_1063: () = VTCR_write(state, tracer, s_286_1062);
        // C s_286_1064: const #() : ()
        let s_286_1064: () = ();
        // S s_286_1065: call VTCR_read(s_286_1064)
        let s_286_1065: ProductType700c18a878c5601b = VTCR_read(
            state,
            tracer,
            s_286_1064,
        );
        // D s_286_1066: write-var ga#36210 <= s_286_1065
        fn_state.ga_36210 = s_286_1065;
        // D s_286_1067: read-var ga#36210.0:struct
        let s_286_1067: u32 = fn_state.ga_36210._0;
        // C s_286_1068: const #11s : i
        let s_286_1068: i128 = 11;
        // C s_286_1069: const #14s : i
        let s_286_1069: i128 = 14;
        // D s_286_1070: cast zx s_286_1067 -> bv
        let s_286_1070: Bits = Bits::new(s_286_1067 as u128, 32u16);
        // C s_286_1071: const #0u : u11
        let s_286_1071: u16 = 0;
        // C s_286_1072: cast zx s_286_1071 -> bv
        let s_286_1072: Bits = Bits::new(s_286_1071 as u128, 11u16);
        // C s_286_1073: const #1u : u64
        let s_286_1073: u64 = 1;
        // C s_286_1074: cast zx s_286_1073 -> bv
        let s_286_1074: Bits = Bits::new(s_286_1073 as u128, 64u16);
        // C s_286_1075: lsl s_286_1074 s_286_1068
        let s_286_1075: Bits = s_286_1074 << s_286_1068;
        // C s_286_1076: sub s_286_1075 s_286_1074
        let s_286_1076: Bits = ((s_286_1075) - (s_286_1074));
        // C s_286_1077: and s_286_1072 s_286_1076
        let s_286_1077: Bits = ((s_286_1072) & (s_286_1076));
        // C s_286_1078: lsl s_286_1077 s_286_1069
        let s_286_1078: Bits = s_286_1077 << s_286_1069;
        // C s_286_1079: lsl s_286_1076 s_286_1069
        let s_286_1079: Bits = s_286_1076 << s_286_1069;
        // C s_286_1080: cmpl s_286_1079
        let s_286_1080: Bits = !s_286_1079;
        // D s_286_1081: and s_286_1070 s_286_1080
        let s_286_1081: Bits = ((s_286_1070) & (s_286_1080));
        // D s_286_1082: or s_286_1081 s_286_1078
        let s_286_1082: Bits = ((s_286_1081) | (s_286_1078));
        // D s_286_1083: cast reint s_286_1082 -> u32
        let s_286_1083: u32 = (s_286_1082.value() as u32);
        // D s_286_1084: call Mk_VTCR_Type(s_286_1083)
        let s_286_1084: ProductType700c18a878c5601b = Mk_VTCR_Type(
            state,
            tracer,
            s_286_1083,
        );
        // D s_286_1085: call VTCR_write(s_286_1084)
        let s_286_1085: () = VTCR_write(state, tracer, s_286_1084);
        // C s_286_1086: const #() : ()
        let s_286_1086: () = ();
        // S s_286_1087: call VTCR_read(s_286_1086)
        let s_286_1087: ProductType700c18a878c5601b = VTCR_read(
            state,
            tracer,
            s_286_1086,
        );
        // D s_286_1088: write-var ga#36214 <= s_286_1087
        fn_state.ga_36214 = s_286_1087;
        // D s_286_1089: read-var ga#36214.0:struct
        let s_286_1089: u32 = fn_state.ga_36214._0;
        // C s_286_1090: const #1s : i
        let s_286_1090: i128 = 1;
        // C s_286_1091: const #5s : i
        let s_286_1091: i128 = 5;
        // D s_286_1092: cast zx s_286_1089 -> bv
        let s_286_1092: Bits = Bits::new(s_286_1089 as u128, 32u16);
        // C s_286_1093: const #0u : u8
        let s_286_1093: bool = false;
        // C s_286_1094: cast zx s_286_1093 -> bv
        let s_286_1094: Bits = Bits::new(s_286_1093 as u128, 1u16);
        // C s_286_1095: const #1u : u64
        let s_286_1095: u64 = 1;
        // C s_286_1096: cast zx s_286_1095 -> bv
        let s_286_1096: Bits = Bits::new(s_286_1095 as u128, 64u16);
        // C s_286_1097: lsl s_286_1096 s_286_1090
        let s_286_1097: Bits = s_286_1096 << s_286_1090;
        // C s_286_1098: sub s_286_1097 s_286_1096
        let s_286_1098: Bits = ((s_286_1097) - (s_286_1096));
        // C s_286_1099: and s_286_1094 s_286_1098
        let s_286_1099: Bits = ((s_286_1094) & (s_286_1098));
        // C s_286_1100: lsl s_286_1099 s_286_1091
        let s_286_1100: Bits = s_286_1099 << s_286_1091;
        // C s_286_1101: lsl s_286_1098 s_286_1091
        let s_286_1101: Bits = s_286_1098 << s_286_1091;
        // C s_286_1102: cmpl s_286_1101
        let s_286_1102: Bits = !s_286_1101;
        // D s_286_1103: and s_286_1092 s_286_1102
        let s_286_1103: Bits = ((s_286_1092) & (s_286_1102));
        // D s_286_1104: or s_286_1103 s_286_1100
        let s_286_1104: Bits = ((s_286_1103) | (s_286_1100));
        // D s_286_1105: cast reint s_286_1104 -> u32
        let s_286_1105: u32 = (s_286_1104.value() as u32);
        // D s_286_1106: call Mk_VTCR_Type(s_286_1105)
        let s_286_1106: ProductType700c18a878c5601b = Mk_VTCR_Type(
            state,
            tracer,
            s_286_1105,
        );
        // D s_286_1107: call VTCR_write(s_286_1106)
        let s_286_1107: () = VTCR_write(state, tracer, s_286_1106);
        // C s_286_1108: const #89544u : u32
        let s_286_1108: u32 = 89544;
        // D s_286_1109: read-reg s_286_1108:struct
        let s_286_1109: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_286_1108 as isize);
            tracer.read_register(s_286_1108 as isize, value);
            value
        };
        // C s_286_1110: const #89544u : u32
        let s_286_1110: u32 = 89544;
        // N s_286_1111: write-reg s_286_1110 <= s_286_1109
        let s_286_1111: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_286_1110 as isize, s_286_1109);
            tracer.write_register(s_286_1110 as isize, s_286_1109);
        };
        // C s_286_1112: const #89544u : u32
        let s_286_1112: u32 = 89544;
        // D s_286_1113: read-reg s_286_1112:struct
        let s_286_1113: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_286_1112 as isize);
            tracer.read_register(s_286_1112 as isize, value);
            value
        };
        // C s_286_1114: const #89544u : u32
        let s_286_1114: u32 = 89544;
        // N s_286_1115: write-reg s_286_1114 <= s_286_1113
        let s_286_1115: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_286_1114 as isize, s_286_1113);
            tracer.write_register(s_286_1114 as isize, s_286_1113);
        };
        // C s_286_1116: const #89544u : u32
        let s_286_1116: u32 = 89544;
        // D s_286_1117: read-reg s_286_1116:struct
        let s_286_1117: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_286_1116 as isize);
            tracer.read_register(s_286_1116 as isize, value);
            value
        };
        // C s_286_1118: const #89544u : u32
        let s_286_1118: u32 = 89544;
        // N s_286_1119: write-reg s_286_1118 <= s_286_1117
        let s_286_1119: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_286_1118 as isize, s_286_1117);
            tracer.write_register(s_286_1118 as isize, s_286_1117);
        };
        // C s_286_1120: const #() : ()
        let s_286_1120: () = ();
        // S s_286_1121: call DFSR_read(s_286_1120)
        let s_286_1121: ProductType700c18a878c5601b = DFSR_read(
            state,
            tracer,
            s_286_1120,
        );
        // D s_286_1122: write-var ga#36224 <= s_286_1121
        fn_state.ga_36224 = s_286_1121;
        // D s_286_1123: read-var ga#36224.0:struct
        let s_286_1123: u32 = fn_state.ga_36224._0;
        // C s_286_1124: const #15s : i
        let s_286_1124: i128 = 15;
        // C s_286_1125: const #17s : i
        let s_286_1125: i128 = 17;
        // D s_286_1126: cast zx s_286_1123 -> bv
        let s_286_1126: Bits = Bits::new(s_286_1123 as u128, 32u16);
        // C s_286_1127: const #0u : u15
        let s_286_1127: u16 = 0;
        // C s_286_1128: cast zx s_286_1127 -> bv
        let s_286_1128: Bits = Bits::new(s_286_1127 as u128, 15u16);
        // C s_286_1129: const #1u : u64
        let s_286_1129: u64 = 1;
        // C s_286_1130: cast zx s_286_1129 -> bv
        let s_286_1130: Bits = Bits::new(s_286_1129 as u128, 64u16);
        // C s_286_1131: lsl s_286_1130 s_286_1124
        let s_286_1131: Bits = s_286_1130 << s_286_1124;
        // C s_286_1132: sub s_286_1131 s_286_1130
        let s_286_1132: Bits = ((s_286_1131) - (s_286_1130));
        // C s_286_1133: and s_286_1128 s_286_1132
        let s_286_1133: Bits = ((s_286_1128) & (s_286_1132));
        // C s_286_1134: lsl s_286_1133 s_286_1125
        let s_286_1134: Bits = s_286_1133 << s_286_1125;
        // C s_286_1135: lsl s_286_1132 s_286_1125
        let s_286_1135: Bits = s_286_1132 << s_286_1125;
        // C s_286_1136: cmpl s_286_1135
        let s_286_1136: Bits = !s_286_1135;
        // D s_286_1137: and s_286_1126 s_286_1136
        let s_286_1137: Bits = ((s_286_1126) & (s_286_1136));
        // D s_286_1138: or s_286_1137 s_286_1134
        let s_286_1138: Bits = ((s_286_1137) | (s_286_1134));
        // D s_286_1139: cast reint s_286_1138 -> u32
        let s_286_1139: u32 = (s_286_1138.value() as u32);
        // D s_286_1140: call Mk_DFSR_Type(s_286_1139)
        let s_286_1140: ProductType700c18a878c5601b = Mk_DFSR_Type(
            state,
            tracer,
            s_286_1139,
        );
        // D s_286_1141: call DFSR_write(s_286_1140)
        let s_286_1141: () = DFSR_write(state, tracer, s_286_1140);
        // C s_286_1142: const #() : ()
        let s_286_1142: () = ();
        // S s_286_1143: call DFSR_read(s_286_1142)
        let s_286_1143: ProductType700c18a878c5601b = DFSR_read(
            state,
            tracer,
            s_286_1142,
        );
        // D s_286_1144: write-var ga#36228 <= s_286_1143
        fn_state.ga_36228 = s_286_1143;
        // D s_286_1145: read-var ga#36228.0:struct
        let s_286_1145: u32 = fn_state.ga_36228._0;
        // C s_286_1146: const #1s : i
        let s_286_1146: i128 = 1;
        // C s_286_1147: const #8s : i
        let s_286_1147: i128 = 8;
        // D s_286_1148: cast zx s_286_1145 -> bv
        let s_286_1148: Bits = Bits::new(s_286_1145 as u128, 32u16);
        // C s_286_1149: const #0u : u8
        let s_286_1149: bool = false;
        // C s_286_1150: cast zx s_286_1149 -> bv
        let s_286_1150: Bits = Bits::new(s_286_1149 as u128, 1u16);
        // C s_286_1151: const #1u : u64
        let s_286_1151: u64 = 1;
        // C s_286_1152: cast zx s_286_1151 -> bv
        let s_286_1152: Bits = Bits::new(s_286_1151 as u128, 64u16);
        // C s_286_1153: lsl s_286_1152 s_286_1146
        let s_286_1153: Bits = s_286_1152 << s_286_1146;
        // C s_286_1154: sub s_286_1153 s_286_1152
        let s_286_1154: Bits = ((s_286_1153) - (s_286_1152));
        // C s_286_1155: and s_286_1150 s_286_1154
        let s_286_1155: Bits = ((s_286_1150) & (s_286_1154));
        // C s_286_1156: lsl s_286_1155 s_286_1147
        let s_286_1156: Bits = s_286_1155 << s_286_1147;
        // C s_286_1157: lsl s_286_1154 s_286_1147
        let s_286_1157: Bits = s_286_1154 << s_286_1147;
        // C s_286_1158: cmpl s_286_1157
        let s_286_1158: Bits = !s_286_1157;
        // D s_286_1159: and s_286_1148 s_286_1158
        let s_286_1159: Bits = ((s_286_1148) & (s_286_1158));
        // D s_286_1160: or s_286_1159 s_286_1156
        let s_286_1160: Bits = ((s_286_1159) | (s_286_1156));
        // D s_286_1161: cast reint s_286_1160 -> u32
        let s_286_1161: u32 = (s_286_1160.value() as u32);
        // D s_286_1162: call Mk_DFSR_Type(s_286_1161)
        let s_286_1162: ProductType700c18a878c5601b = Mk_DFSR_Type(
            state,
            tracer,
            s_286_1161,
        );
        // D s_286_1163: call DFSR_write(s_286_1162)
        let s_286_1163: () = DFSR_write(state, tracer, s_286_1162);
        // C s_286_1164: const #() : ()
        let s_286_1164: () = ();
        // S s_286_1165: call DFSR_read(s_286_1164)
        let s_286_1165: ProductType700c18a878c5601b = DFSR_read(
            state,
            tracer,
            s_286_1164,
        );
        // D s_286_1166: write-var ga#36232 <= s_286_1165
        fn_state.ga_36232 = s_286_1165;
        // D s_286_1167: read-var ga#36232.0:struct
        let s_286_1167: u32 = fn_state.ga_36232._0;
        // C s_286_1168: const #15s : i
        let s_286_1168: i128 = 15;
        // C s_286_1169: const #17s : i
        let s_286_1169: i128 = 17;
        // D s_286_1170: cast zx s_286_1167 -> bv
        let s_286_1170: Bits = Bits::new(s_286_1167 as u128, 32u16);
        // C s_286_1171: const #0u : u15
        let s_286_1171: u16 = 0;
        // C s_286_1172: cast zx s_286_1171 -> bv
        let s_286_1172: Bits = Bits::new(s_286_1171 as u128, 15u16);
        // C s_286_1173: const #1u : u64
        let s_286_1173: u64 = 1;
        // C s_286_1174: cast zx s_286_1173 -> bv
        let s_286_1174: Bits = Bits::new(s_286_1173 as u128, 64u16);
        // C s_286_1175: lsl s_286_1174 s_286_1168
        let s_286_1175: Bits = s_286_1174 << s_286_1168;
        // C s_286_1176: sub s_286_1175 s_286_1174
        let s_286_1176: Bits = ((s_286_1175) - (s_286_1174));
        // C s_286_1177: and s_286_1172 s_286_1176
        let s_286_1177: Bits = ((s_286_1172) & (s_286_1176));
        // C s_286_1178: lsl s_286_1177 s_286_1169
        let s_286_1178: Bits = s_286_1177 << s_286_1169;
        // C s_286_1179: lsl s_286_1176 s_286_1169
        let s_286_1179: Bits = s_286_1176 << s_286_1169;
        // C s_286_1180: cmpl s_286_1179
        let s_286_1180: Bits = !s_286_1179;
        // D s_286_1181: and s_286_1170 s_286_1180
        let s_286_1181: Bits = ((s_286_1170) & (s_286_1180));
        // D s_286_1182: or s_286_1181 s_286_1178
        let s_286_1182: Bits = ((s_286_1181) | (s_286_1178));
        // D s_286_1183: cast reint s_286_1182 -> u32
        let s_286_1183: u32 = (s_286_1182.value() as u32);
        // D s_286_1184: call Mk_DFSR_Type(s_286_1183)
        let s_286_1184: ProductType700c18a878c5601b = Mk_DFSR_Type(
            state,
            tracer,
            s_286_1183,
        );
        // D s_286_1185: call DFSR_write(s_286_1184)
        let s_286_1185: () = DFSR_write(state, tracer, s_286_1184);
        // C s_286_1186: const #() : ()
        let s_286_1186: () = ();
        // S s_286_1187: call DFSR_read(s_286_1186)
        let s_286_1187: ProductType700c18a878c5601b = DFSR_read(
            state,
            tracer,
            s_286_1186,
        );
        // D s_286_1188: write-var ga#36236 <= s_286_1187
        fn_state.ga_36236 = s_286_1187;
        // D s_286_1189: read-var ga#36236.0:struct
        let s_286_1189: u32 = fn_state.ga_36236._0;
        // C s_286_1190: const #1s : i
        let s_286_1190: i128 = 1;
        // C s_286_1191: const #10s : i
        let s_286_1191: i128 = 10;
        // D s_286_1192: cast zx s_286_1189 -> bv
        let s_286_1192: Bits = Bits::new(s_286_1189 as u128, 32u16);
        // C s_286_1193: const #0u : u8
        let s_286_1193: bool = false;
        // C s_286_1194: cast zx s_286_1193 -> bv
        let s_286_1194: Bits = Bits::new(s_286_1193 as u128, 1u16);
        // C s_286_1195: const #1u : u64
        let s_286_1195: u64 = 1;
        // C s_286_1196: cast zx s_286_1195 -> bv
        let s_286_1196: Bits = Bits::new(s_286_1195 as u128, 64u16);
        // C s_286_1197: lsl s_286_1196 s_286_1190
        let s_286_1197: Bits = s_286_1196 << s_286_1190;
        // C s_286_1198: sub s_286_1197 s_286_1196
        let s_286_1198: Bits = ((s_286_1197) - (s_286_1196));
        // C s_286_1199: and s_286_1194 s_286_1198
        let s_286_1199: Bits = ((s_286_1194) & (s_286_1198));
        // C s_286_1200: lsl s_286_1199 s_286_1191
        let s_286_1200: Bits = s_286_1199 << s_286_1191;
        // C s_286_1201: lsl s_286_1198 s_286_1191
        let s_286_1201: Bits = s_286_1198 << s_286_1191;
        // C s_286_1202: cmpl s_286_1201
        let s_286_1202: Bits = !s_286_1201;
        // D s_286_1203: and s_286_1192 s_286_1202
        let s_286_1203: Bits = ((s_286_1192) & (s_286_1202));
        // D s_286_1204: or s_286_1203 s_286_1200
        let s_286_1204: Bits = ((s_286_1203) | (s_286_1200));
        // D s_286_1205: cast reint s_286_1204 -> u32
        let s_286_1205: u32 = (s_286_1204.value() as u32);
        // D s_286_1206: call Mk_DFSR_Type(s_286_1205)
        let s_286_1206: ProductType700c18a878c5601b = Mk_DFSR_Type(
            state,
            tracer,
            s_286_1205,
        );
        // D s_286_1207: call DFSR_write(s_286_1206)
        let s_286_1207: () = DFSR_write(state, tracer, s_286_1206);
        // C s_286_1208: const #() : ()
        let s_286_1208: () = ();
        // S s_286_1209: call DFSR_read(s_286_1208)
        let s_286_1209: ProductType700c18a878c5601b = DFSR_read(
            state,
            tracer,
            s_286_1208,
        );
        // D s_286_1210: write-var ga#36240 <= s_286_1209
        fn_state.ga_36240 = s_286_1209;
        // D s_286_1211: read-var ga#36240.0:struct
        let s_286_1211: u32 = fn_state.ga_36240._0;
        // C s_286_1212: const #3s : i
        let s_286_1212: i128 = 3;
        // C s_286_1213: const #6s : i
        let s_286_1213: i128 = 6;
        // D s_286_1214: cast zx s_286_1211 -> bv
        let s_286_1214: Bits = Bits::new(s_286_1211 as u128, 32u16);
        // C s_286_1215: const #0u : u8
        let s_286_1215: u8 = 0;
        // C s_286_1216: cast zx s_286_1215 -> bv
        let s_286_1216: Bits = Bits::new(s_286_1215 as u128, 3u16);
        // C s_286_1217: const #1u : u64
        let s_286_1217: u64 = 1;
        // C s_286_1218: cast zx s_286_1217 -> bv
        let s_286_1218: Bits = Bits::new(s_286_1217 as u128, 64u16);
        // C s_286_1219: lsl s_286_1218 s_286_1212
        let s_286_1219: Bits = s_286_1218 << s_286_1212;
        // C s_286_1220: sub s_286_1219 s_286_1218
        let s_286_1220: Bits = ((s_286_1219) - (s_286_1218));
        // C s_286_1221: and s_286_1216 s_286_1220
        let s_286_1221: Bits = ((s_286_1216) & (s_286_1220));
        // C s_286_1222: lsl s_286_1221 s_286_1213
        let s_286_1222: Bits = s_286_1221 << s_286_1213;
        // C s_286_1223: lsl s_286_1220 s_286_1213
        let s_286_1223: Bits = s_286_1220 << s_286_1213;
        // C s_286_1224: cmpl s_286_1223
        let s_286_1224: Bits = !s_286_1223;
        // D s_286_1225: and s_286_1214 s_286_1224
        let s_286_1225: Bits = ((s_286_1214) & (s_286_1224));
        // D s_286_1226: or s_286_1225 s_286_1222
        let s_286_1226: Bits = ((s_286_1225) | (s_286_1222));
        // D s_286_1227: cast reint s_286_1226 -> u32
        let s_286_1227: u32 = (s_286_1226.value() as u32);
        // D s_286_1228: call Mk_DFSR_Type(s_286_1227)
        let s_286_1228: ProductType700c18a878c5601b = Mk_DFSR_Type(
            state,
            tracer,
            s_286_1227,
        );
        // D s_286_1229: call DFSR_write(s_286_1228)
        let s_286_1229: () = DFSR_write(state, tracer, s_286_1228);
        // C s_286_1230: const #() : ()
        let s_286_1230: () = ();
        // S s_286_1231: call CCSIDR2_read(s_286_1230)
        let s_286_1231: ProductType700c18a878c5601b = CCSIDR2_read(
            state,
            tracer,
            s_286_1230,
        );
        // D s_286_1232: write-var ga#36244 <= s_286_1231
        fn_state.ga_36244 = s_286_1231;
        // D s_286_1233: read-var ga#36244.0:struct
        let s_286_1233: u32 = fn_state.ga_36244._0;
        // C s_286_1234: const #8s : i
        let s_286_1234: i128 = 8;
        // C s_286_1235: const #24s : i
        let s_286_1235: i128 = 24;
        // D s_286_1236: cast zx s_286_1233 -> bv
        let s_286_1236: Bits = Bits::new(s_286_1233 as u128, 32u16);
        // C s_286_1237: const #0u : u8
        let s_286_1237: u8 = 0;
        // C s_286_1238: cast zx s_286_1237 -> bv
        let s_286_1238: Bits = Bits::new(s_286_1237 as u128, 8u16);
        // C s_286_1239: const #1u : u64
        let s_286_1239: u64 = 1;
        // C s_286_1240: cast zx s_286_1239 -> bv
        let s_286_1240: Bits = Bits::new(s_286_1239 as u128, 64u16);
        // C s_286_1241: lsl s_286_1240 s_286_1234
        let s_286_1241: Bits = s_286_1240 << s_286_1234;
        // C s_286_1242: sub s_286_1241 s_286_1240
        let s_286_1242: Bits = ((s_286_1241) - (s_286_1240));
        // C s_286_1243: and s_286_1238 s_286_1242
        let s_286_1243: Bits = ((s_286_1238) & (s_286_1242));
        // C s_286_1244: lsl s_286_1243 s_286_1235
        let s_286_1244: Bits = s_286_1243 << s_286_1235;
        // C s_286_1245: lsl s_286_1242 s_286_1235
        let s_286_1245: Bits = s_286_1242 << s_286_1235;
        // C s_286_1246: cmpl s_286_1245
        let s_286_1246: Bits = !s_286_1245;
        // D s_286_1247: and s_286_1236 s_286_1246
        let s_286_1247: Bits = ((s_286_1236) & (s_286_1246));
        // D s_286_1248: or s_286_1247 s_286_1244
        let s_286_1248: Bits = ((s_286_1247) | (s_286_1244));
        // D s_286_1249: cast reint s_286_1248 -> u32
        let s_286_1249: u32 = (s_286_1248.value() as u32);
        // D s_286_1250: call Mk_CCSIDR2_Type(s_286_1249)
        let s_286_1250: ProductType700c18a878c5601b = Mk_CCSIDR2_Type(
            state,
            tracer,
            s_286_1249,
        );
        // D s_286_1251: call CCSIDR2_write(s_286_1250)
        let s_286_1251: () = CCSIDR2_write(state, tracer, s_286_1250);
        // C s_286_1252: const #() : ()
        let s_286_1252: () = ();
        // S s_286_1253: call CNTHV_CTL_read(s_286_1252)
        let s_286_1253: ProductType700c18a878c5601b = CNTHV_CTL_read(
            state,
            tracer,
            s_286_1252,
        );
        // D s_286_1254: write-var ga#36248 <= s_286_1253
        fn_state.ga_36248 = s_286_1253;
        // D s_286_1255: read-var ga#36248.0:struct
        let s_286_1255: u32 = fn_state.ga_36248._0;
        // C s_286_1256: const #29s : i
        let s_286_1256: i128 = 29;
        // C s_286_1257: const #3s : i
        let s_286_1257: i128 = 3;
        // D s_286_1258: cast zx s_286_1255 -> bv
        let s_286_1258: Bits = Bits::new(s_286_1255 as u128, 32u16);
        // C s_286_1259: const #0u : u29
        let s_286_1259: u32 = 0;
        // C s_286_1260: cast zx s_286_1259 -> bv
        let s_286_1260: Bits = Bits::new(s_286_1259 as u128, 29u16);
        // C s_286_1261: const #1u : u64
        let s_286_1261: u64 = 1;
        // C s_286_1262: cast zx s_286_1261 -> bv
        let s_286_1262: Bits = Bits::new(s_286_1261 as u128, 64u16);
        // C s_286_1263: lsl s_286_1262 s_286_1256
        let s_286_1263: Bits = s_286_1262 << s_286_1256;
        // C s_286_1264: sub s_286_1263 s_286_1262
        let s_286_1264: Bits = ((s_286_1263) - (s_286_1262));
        // C s_286_1265: and s_286_1260 s_286_1264
        let s_286_1265: Bits = ((s_286_1260) & (s_286_1264));
        // C s_286_1266: lsl s_286_1265 s_286_1257
        let s_286_1266: Bits = s_286_1265 << s_286_1257;
        // C s_286_1267: lsl s_286_1264 s_286_1257
        let s_286_1267: Bits = s_286_1264 << s_286_1257;
        // C s_286_1268: cmpl s_286_1267
        let s_286_1268: Bits = !s_286_1267;
        // D s_286_1269: and s_286_1258 s_286_1268
        let s_286_1269: Bits = ((s_286_1258) & (s_286_1268));
        // D s_286_1270: or s_286_1269 s_286_1266
        let s_286_1270: Bits = ((s_286_1269) | (s_286_1266));
        // D s_286_1271: cast reint s_286_1270 -> u32
        let s_286_1271: u32 = (s_286_1270.value() as u32);
        // D s_286_1272: call Mk_CNTHV_CTL_Type(s_286_1271)
        let s_286_1272: ProductType700c18a878c5601b = Mk_CNTHV_CTL_Type(
            state,
            tracer,
            s_286_1271,
        );
        // D s_286_1273: call CNTHV_CTL_write(s_286_1272)
        let s_286_1273: () = CNTHV_CTL_write(state, tracer, s_286_1272);
        // C s_286_1274: const #() : ()
        let s_286_1274: () = ();
        // S s_286_1275: call ICH_MISR_read(s_286_1274)
        let s_286_1275: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1274,
        );
        // D s_286_1276: write-var ga#36252 <= s_286_1275
        fn_state.ga_36252 = s_286_1275;
        // D s_286_1277: read-var ga#36252.0:struct
        let s_286_1277: u32 = fn_state.ga_36252._0;
        // C s_286_1278: const #24s : i
        let s_286_1278: i128 = 24;
        // C s_286_1279: const #8s : i
        let s_286_1279: i128 = 8;
        // D s_286_1280: cast zx s_286_1277 -> bv
        let s_286_1280: Bits = Bits::new(s_286_1277 as u128, 32u16);
        // C s_286_1281: const #0u : u24
        let s_286_1281: u32 = 0;
        // C s_286_1282: cast zx s_286_1281 -> bv
        let s_286_1282: Bits = Bits::new(s_286_1281 as u128, 24u16);
        // C s_286_1283: const #1u : u64
        let s_286_1283: u64 = 1;
        // C s_286_1284: cast zx s_286_1283 -> bv
        let s_286_1284: Bits = Bits::new(s_286_1283 as u128, 64u16);
        // C s_286_1285: lsl s_286_1284 s_286_1278
        let s_286_1285: Bits = s_286_1284 << s_286_1278;
        // C s_286_1286: sub s_286_1285 s_286_1284
        let s_286_1286: Bits = ((s_286_1285) - (s_286_1284));
        // C s_286_1287: and s_286_1282 s_286_1286
        let s_286_1287: Bits = ((s_286_1282) & (s_286_1286));
        // C s_286_1288: lsl s_286_1287 s_286_1279
        let s_286_1288: Bits = s_286_1287 << s_286_1279;
        // C s_286_1289: lsl s_286_1286 s_286_1279
        let s_286_1289: Bits = s_286_1286 << s_286_1279;
        // C s_286_1290: cmpl s_286_1289
        let s_286_1290: Bits = !s_286_1289;
        // D s_286_1291: and s_286_1280 s_286_1290
        let s_286_1291: Bits = ((s_286_1280) & (s_286_1290));
        // D s_286_1292: or s_286_1291 s_286_1288
        let s_286_1292: Bits = ((s_286_1291) | (s_286_1288));
        // D s_286_1293: cast reint s_286_1292 -> u32
        let s_286_1293: u32 = (s_286_1292.value() as u32);
        // D s_286_1294: call Mk_ICH_MISR_Type(s_286_1293)
        let s_286_1294: ProductType700c18a878c5601b = Mk_ICH_MISR_Type(
            state,
            tracer,
            s_286_1293,
        );
        // D s_286_1295: call ICH_MISR_write(s_286_1294)
        let s_286_1295: () = ICH_MISR_write(state, tracer, s_286_1294);
        // C s_286_1296: const #() : ()
        let s_286_1296: () = ();
        // S s_286_1297: call ICH_MISR_read(s_286_1296)
        let s_286_1297: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1296,
        );
        // C s_286_1298: const #0u : u8
        let s_286_1298: bool = false;
        // S s_286_1299: call _update_ICH_MISR_Type_VGrp1D(s_286_1297, s_286_1298)
        let s_286_1299: ProductType700c18a878c5601b = u_update_ICH_MISR_Type_VGrp1D(
            state,
            tracer,
            s_286_1297,
            s_286_1298,
        );
        // S s_286_1300: call ICH_MISR_write(s_286_1299)
        let s_286_1300: () = ICH_MISR_write(state, tracer, s_286_1299);
        // C s_286_1301: const #() : ()
        let s_286_1301: () = ();
        // S s_286_1302: call ICH_MISR_read(s_286_1301)
        let s_286_1302: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1301,
        );
        // C s_286_1303: const #0u : u8
        let s_286_1303: bool = false;
        // S s_286_1304: call _update_ICH_MISR_Type_VGrp1E(s_286_1302, s_286_1303)
        let s_286_1304: ProductType700c18a878c5601b = u_update_ICH_MISR_Type_VGrp1E(
            state,
            tracer,
            s_286_1302,
            s_286_1303,
        );
        // S s_286_1305: call ICH_MISR_write(s_286_1304)
        let s_286_1305: () = ICH_MISR_write(state, tracer, s_286_1304);
        // C s_286_1306: const #() : ()
        let s_286_1306: () = ();
        // S s_286_1307: call ICH_MISR_read(s_286_1306)
        let s_286_1307: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1306,
        );
        // C s_286_1308: const #0u : u8
        let s_286_1308: bool = false;
        // S s_286_1309: call _update_ICH_MISR_Type_VGrp0D(s_286_1307, s_286_1308)
        let s_286_1309: ProductType700c18a878c5601b = u_update_ICH_MISR_Type_VGrp0D(
            state,
            tracer,
            s_286_1307,
            s_286_1308,
        );
        // S s_286_1310: call ICH_MISR_write(s_286_1309)
        let s_286_1310: () = ICH_MISR_write(state, tracer, s_286_1309);
        // C s_286_1311: const #() : ()
        let s_286_1311: () = ();
        // S s_286_1312: call ICH_MISR_read(s_286_1311)
        let s_286_1312: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1311,
        );
        // C s_286_1313: const #0u : u8
        let s_286_1313: bool = false;
        // S s_286_1314: call _update_ICH_MISR_Type_VGrp0E(s_286_1312, s_286_1313)
        let s_286_1314: ProductType700c18a878c5601b = u_update_ICH_MISR_Type_VGrp0E(
            state,
            tracer,
            s_286_1312,
            s_286_1313,
        );
        // S s_286_1315: call ICH_MISR_write(s_286_1314)
        let s_286_1315: () = ICH_MISR_write(state, tracer, s_286_1314);
        // C s_286_1316: const #() : ()
        let s_286_1316: () = ();
        // S s_286_1317: call ICH_MISR_read(s_286_1316)
        let s_286_1317: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1316,
        );
        // C s_286_1318: const #0u : u8
        let s_286_1318: bool = false;
        // S s_286_1319: call _update_ICH_MISR_Type_NP(s_286_1317, s_286_1318)
        let s_286_1319: ProductType700c18a878c5601b = u_update_ICH_MISR_Type_NP(
            state,
            tracer,
            s_286_1317,
            s_286_1318,
        );
        // S s_286_1320: call ICH_MISR_write(s_286_1319)
        let s_286_1320: () = ICH_MISR_write(state, tracer, s_286_1319);
        // C s_286_1321: const #() : ()
        let s_286_1321: () = ();
        // S s_286_1322: call ICH_MISR_read(s_286_1321)
        let s_286_1322: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1321,
        );
        // C s_286_1323: const #0u : u8
        let s_286_1323: bool = false;
        // S s_286_1324: call _update_ICH_MISR_Type_LRENP(s_286_1322, s_286_1323)
        let s_286_1324: ProductType700c18a878c5601b = u_update_ICH_MISR_Type_LRENP(
            state,
            tracer,
            s_286_1322,
            s_286_1323,
        );
        // S s_286_1325: call ICH_MISR_write(s_286_1324)
        let s_286_1325: () = ICH_MISR_write(state, tracer, s_286_1324);
        // C s_286_1326: const #() : ()
        let s_286_1326: () = ();
        // S s_286_1327: call ICH_MISR_read(s_286_1326)
        let s_286_1327: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1326,
        );
        // C s_286_1328: const #0u : u8
        let s_286_1328: bool = false;
        // S s_286_1329: call _update_ICH_MISR_Type_U(s_286_1327, s_286_1328)
        let s_286_1329: ProductType700c18a878c5601b = u_update_ICH_MISR_Type_U(
            state,
            tracer,
            s_286_1327,
            s_286_1328,
        );
        // S s_286_1330: call ICH_MISR_write(s_286_1329)
        let s_286_1330: () = ICH_MISR_write(state, tracer, s_286_1329);
        // C s_286_1331: const #() : ()
        let s_286_1331: () = ();
        // S s_286_1332: call ICH_MISR_read(s_286_1331)
        let s_286_1332: ProductType700c18a878c5601b = ICH_MISR_read(
            state,
            tracer,
            s_286_1331,
        );
        // C s_286_1333: const #0u : u8
        let s_286_1333: bool = false;
        // S s_286_1334: call _update_ICH_MISR_Type_EOI(s_286_1332, s_286_1333)
        let s_286_1334: ProductType700c18a878c5601b = u_update_ICH_MISR_Type_EOI(
            state,
            tracer,
            s_286_1332,
            s_286_1333,
        );
        // S s_286_1335: call ICH_MISR_write(s_286_1334)
        let s_286_1335: () = ICH_MISR_write(state, tracer, s_286_1334);
        // C s_286_1336: const #() : ()
        let s_286_1336: () = ();
        // S s_286_1337: call CPACR_read__1(s_286_1336)
        let s_286_1337: ProductType700c18a878c5601b = CPACR_read__1(
            state,
            tracer,
            s_286_1336,
        );
        // C s_286_1338: const #0u : u8
        let s_286_1338: bool = false;
        // S s_286_1339: call _update_CPACR_Type_ASEDIS(s_286_1337, s_286_1338)
        let s_286_1339: ProductType700c18a878c5601b = u_update_CPACR_Type_ASEDIS(
            state,
            tracer,
            s_286_1337,
            s_286_1338,
        );
        // S s_286_1340: call CPACR_write(s_286_1339)
        let s_286_1340: () = CPACR_write(state, tracer, s_286_1339);
        // C s_286_1341: const #() : ()
        let s_286_1341: () = ();
        // S s_286_1342: call CPACR_read__1(s_286_1341)
        let s_286_1342: ProductType700c18a878c5601b = CPACR_read__1(
            state,
            tracer,
            s_286_1341,
        );
        // D s_286_1343: write-var ga#36274 <= s_286_1342
        fn_state.ga_36274 = s_286_1342;
        // D s_286_1344: read-var ga#36274.0:struct
        let s_286_1344: u32 = fn_state.ga_36274._0;
        // C s_286_1345: const #2s : i
        let s_286_1345: i128 = 2;
        // C s_286_1346: const #29s : i
        let s_286_1346: i128 = 29;
        // D s_286_1347: cast zx s_286_1344 -> bv
        let s_286_1347: Bits = Bits::new(s_286_1344 as u128, 32u16);
        // C s_286_1348: const #0u : u8
        let s_286_1348: u8 = 0;
        // C s_286_1349: cast zx s_286_1348 -> bv
        let s_286_1349: Bits = Bits::new(s_286_1348 as u128, 2u16);
        // C s_286_1350: const #1u : u64
        let s_286_1350: u64 = 1;
        // C s_286_1351: cast zx s_286_1350 -> bv
        let s_286_1351: Bits = Bits::new(s_286_1350 as u128, 64u16);
        // C s_286_1352: lsl s_286_1351 s_286_1345
        let s_286_1352: Bits = s_286_1351 << s_286_1345;
        // C s_286_1353: sub s_286_1352 s_286_1351
        let s_286_1353: Bits = ((s_286_1352) - (s_286_1351));
        // C s_286_1354: and s_286_1349 s_286_1353
        let s_286_1354: Bits = ((s_286_1349) & (s_286_1353));
        // C s_286_1355: lsl s_286_1354 s_286_1346
        let s_286_1355: Bits = s_286_1354 << s_286_1346;
        // C s_286_1356: lsl s_286_1353 s_286_1346
        let s_286_1356: Bits = s_286_1353 << s_286_1346;
        // C s_286_1357: cmpl s_286_1356
        let s_286_1357: Bits = !s_286_1356;
        // D s_286_1358: and s_286_1347 s_286_1357
        let s_286_1358: Bits = ((s_286_1347) & (s_286_1357));
        // D s_286_1359: or s_286_1358 s_286_1355
        let s_286_1359: Bits = ((s_286_1358) | (s_286_1355));
        // D s_286_1360: cast reint s_286_1359 -> u32
        let s_286_1360: u32 = (s_286_1359.value() as u32);
        // D s_286_1361: call Mk_CPACR_Type(s_286_1360)
        let s_286_1361: ProductType700c18a878c5601b = Mk_CPACR_Type(
            state,
            tracer,
            s_286_1360,
        );
        // D s_286_1362: call CPACR_write(s_286_1361)
        let s_286_1362: () = CPACR_write(state, tracer, s_286_1361);
        // C s_286_1363: const #() : ()
        let s_286_1363: () = ();
        // S s_286_1364: call CPACR_read__1(s_286_1363)
        let s_286_1364: ProductType700c18a878c5601b = CPACR_read__1(
            state,
            tracer,
            s_286_1363,
        );
        // D s_286_1365: write-var ga#36278 <= s_286_1364
        fn_state.ga_36278 = s_286_1364;
        // D s_286_1366: read-var ga#36278.0:struct
        let s_286_1366: u32 = fn_state.ga_36278._0;
        // C s_286_1367: const #4s : i
        let s_286_1367: i128 = 4;
        // C s_286_1368: const #24s : i
        let s_286_1368: i128 = 24;
        // D s_286_1369: cast zx s_286_1366 -> bv
        let s_286_1369: Bits = Bits::new(s_286_1366 as u128, 32u16);
        // C s_286_1370: const #0u : u8
        let s_286_1370: u8 = 0;
        // C s_286_1371: cast zx s_286_1370 -> bv
        let s_286_1371: Bits = Bits::new(s_286_1370 as u128, 4u16);
        // C s_286_1372: const #1u : u64
        let s_286_1372: u64 = 1;
        // C s_286_1373: cast zx s_286_1372 -> bv
        let s_286_1373: Bits = Bits::new(s_286_1372 as u128, 64u16);
        // C s_286_1374: lsl s_286_1373 s_286_1367
        let s_286_1374: Bits = s_286_1373 << s_286_1367;
        // C s_286_1375: sub s_286_1374 s_286_1373
        let s_286_1375: Bits = ((s_286_1374) - (s_286_1373));
        // C s_286_1376: and s_286_1371 s_286_1375
        let s_286_1376: Bits = ((s_286_1371) & (s_286_1375));
        // C s_286_1377: lsl s_286_1376 s_286_1368
        let s_286_1377: Bits = s_286_1376 << s_286_1368;
        // C s_286_1378: lsl s_286_1375 s_286_1368
        let s_286_1378: Bits = s_286_1375 << s_286_1368;
        // C s_286_1379: cmpl s_286_1378
        let s_286_1379: Bits = !s_286_1378;
        // D s_286_1380: and s_286_1369 s_286_1379
        let s_286_1380: Bits = ((s_286_1369) & (s_286_1379));
        // D s_286_1381: or s_286_1380 s_286_1377
        let s_286_1381: Bits = ((s_286_1380) | (s_286_1377));
        // D s_286_1382: cast reint s_286_1381 -> u32
        let s_286_1382: u32 = (s_286_1381.value() as u32);
        // D s_286_1383: call Mk_CPACR_Type(s_286_1382)
        let s_286_1383: ProductType700c18a878c5601b = Mk_CPACR_Type(
            state,
            tracer,
            s_286_1382,
        );
        // D s_286_1384: call CPACR_write(s_286_1383)
        let s_286_1384: () = CPACR_write(state, tracer, s_286_1383);
        // C s_286_1385: const #() : ()
        let s_286_1385: () = ();
        // S s_286_1386: call CPACR_read__1(s_286_1385)
        let s_286_1386: ProductType700c18a878c5601b = CPACR_read__1(
            state,
            tracer,
            s_286_1385,
        );
        // C s_286_1387: const #0u : u8
        let s_286_1387: u8 = 0;
        // S s_286_1388: call _update_CPACR_Type_cp11(s_286_1386, s_286_1387)
        let s_286_1388: ProductType700c18a878c5601b = u_update_CPACR_Type_cp11(
            state,
            tracer,
            s_286_1386,
            s_286_1387,
        );
        // S s_286_1389: call CPACR_write(s_286_1388)
        let s_286_1389: () = CPACR_write(state, tracer, s_286_1388);
        // C s_286_1390: const #() : ()
        let s_286_1390: () = ();
        // S s_286_1391: call CPACR_read__1(s_286_1390)
        let s_286_1391: ProductType700c18a878c5601b = CPACR_read__1(
            state,
            tracer,
            s_286_1390,
        );
        // C s_286_1392: const #0u : u8
        let s_286_1392: u8 = 0;
        // S s_286_1393: call _update_CPACR_Type_cp10(s_286_1391, s_286_1392)
        let s_286_1393: ProductType700c18a878c5601b = u_update_CPACR_Type_cp10(
            state,
            tracer,
            s_286_1391,
            s_286_1392,
        );
        // S s_286_1394: call CPACR_write(s_286_1393)
        let s_286_1394: () = CPACR_write(state, tracer, s_286_1393);
        // C s_286_1395: const #() : ()
        let s_286_1395: () = ();
        // S s_286_1396: call CPACR_read__1(s_286_1395)
        let s_286_1396: ProductType700c18a878c5601b = CPACR_read__1(
            state,
            tracer,
            s_286_1395,
        );
        // D s_286_1397: write-var ga#36286 <= s_286_1396
        fn_state.ga_36286 = s_286_1396;
        // D s_286_1398: read-var ga#36286.0:struct
        let s_286_1398: u32 = fn_state.ga_36286._0;
        // C s_286_1399: const #20s : i
        let s_286_1399: i128 = 20;
        // C s_286_1400: const #0s : i
        let s_286_1400: i128 = 0;
        // D s_286_1401: cast zx s_286_1398 -> bv
        let s_286_1401: Bits = Bits::new(s_286_1398 as u128, 32u16);
        // C s_286_1402: const #0u : u20
        let s_286_1402: u32 = 0;
        // C s_286_1403: cast zx s_286_1402 -> bv
        let s_286_1403: Bits = Bits::new(s_286_1402 as u128, 20u16);
        // C s_286_1404: const #1u : u64
        let s_286_1404: u64 = 1;
        // C s_286_1405: cast zx s_286_1404 -> bv
        let s_286_1405: Bits = Bits::new(s_286_1404 as u128, 64u16);
        // C s_286_1406: lsl s_286_1405 s_286_1399
        let s_286_1406: Bits = s_286_1405 << s_286_1399;
        // C s_286_1407: sub s_286_1406 s_286_1405
        let s_286_1407: Bits = ((s_286_1406) - (s_286_1405));
        // C s_286_1408: and s_286_1403 s_286_1407
        let s_286_1408: Bits = ((s_286_1403) & (s_286_1407));
        // C s_286_1409: lsl s_286_1408 s_286_1400
        let s_286_1409: Bits = s_286_1408 << s_286_1400;
        // C s_286_1410: lsl s_286_1407 s_286_1400
        let s_286_1410: Bits = s_286_1407 << s_286_1400;
        // C s_286_1411: cmpl s_286_1410
        let s_286_1411: Bits = !s_286_1410;
        // D s_286_1412: and s_286_1401 s_286_1411
        let s_286_1412: Bits = ((s_286_1401) & (s_286_1411));
        // D s_286_1413: or s_286_1412 s_286_1409
        let s_286_1413: Bits = ((s_286_1412) | (s_286_1409));
        // D s_286_1414: cast reint s_286_1413 -> u32
        let s_286_1414: u32 = (s_286_1413.value() as u32);
        // D s_286_1415: call Mk_CPACR_Type(s_286_1414)
        let s_286_1415: ProductType700c18a878c5601b = Mk_CPACR_Type(
            state,
            tracer,
            s_286_1414,
        );
        // D s_286_1416: call CPACR_write(s_286_1415)
        let s_286_1416: () = CPACR_write(state, tracer, s_286_1415);
        // C s_286_1417: const #() : ()
        let s_286_1417: () = ();
        // S s_286_1418: call ICV_IAR0_read(s_286_1417)
        let s_286_1418: ProductType700c18a878c5601b = ICV_IAR0_read(
            state,
            tracer,
            s_286_1417,
        );
        // D s_286_1419: write-var ga#36290 <= s_286_1418
        fn_state.ga_36290 = s_286_1418;
        // D s_286_1420: read-var ga#36290.0:struct
        let s_286_1420: u32 = fn_state.ga_36290._0;
        // C s_286_1421: const #8s : i
        let s_286_1421: i128 = 8;
        // C s_286_1422: const #24s : i
        let s_286_1422: i128 = 24;
        // D s_286_1423: cast zx s_286_1420 -> bv
        let s_286_1423: Bits = Bits::new(s_286_1420 as u128, 32u16);
        // C s_286_1424: const #0u : u8
        let s_286_1424: u8 = 0;
        // C s_286_1425: cast zx s_286_1424 -> bv
        let s_286_1425: Bits = Bits::new(s_286_1424 as u128, 8u16);
        // C s_286_1426: const #1u : u64
        let s_286_1426: u64 = 1;
        // C s_286_1427: cast zx s_286_1426 -> bv
        let s_286_1427: Bits = Bits::new(s_286_1426 as u128, 64u16);
        // C s_286_1428: lsl s_286_1427 s_286_1421
        let s_286_1428: Bits = s_286_1427 << s_286_1421;
        // C s_286_1429: sub s_286_1428 s_286_1427
        let s_286_1429: Bits = ((s_286_1428) - (s_286_1427));
        // C s_286_1430: and s_286_1425 s_286_1429
        let s_286_1430: Bits = ((s_286_1425) & (s_286_1429));
        // C s_286_1431: lsl s_286_1430 s_286_1422
        let s_286_1431: Bits = s_286_1430 << s_286_1422;
        // C s_286_1432: lsl s_286_1429 s_286_1422
        let s_286_1432: Bits = s_286_1429 << s_286_1422;
        // C s_286_1433: cmpl s_286_1432
        let s_286_1433: Bits = !s_286_1432;
        // D s_286_1434: and s_286_1423 s_286_1433
        let s_286_1434: Bits = ((s_286_1423) & (s_286_1433));
        // D s_286_1435: or s_286_1434 s_286_1431
        let s_286_1435: Bits = ((s_286_1434) | (s_286_1431));
        // D s_286_1436: cast reint s_286_1435 -> u32
        let s_286_1436: u32 = (s_286_1435.value() as u32);
        // D s_286_1437: call Mk_ICV_IAR0_Type(s_286_1436)
        let s_286_1437: ProductType700c18a878c5601b = Mk_ICV_IAR0_Type(
            state,
            tracer,
            s_286_1436,
        );
        // D s_286_1438: call ICV_IAR0_write(s_286_1437)
        let s_286_1438: () = ICV_IAR0_write(state, tracer, s_286_1437);
        // C s_286_1439: const #() : ()
        let s_286_1439: () = ();
        // S s_286_1440: call ISR_read(s_286_1439)
        let s_286_1440: ProductType700c18a878c5601b = ISR_read(
            state,
            tracer,
            s_286_1439,
        );
        // D s_286_1441: write-var ga#36294 <= s_286_1440
        fn_state.ga_36294 = s_286_1440;
        // D s_286_1442: read-var ga#36294.0:struct
        let s_286_1442: u32 = fn_state.ga_36294._0;
        // C s_286_1443: const #23s : i
        let s_286_1443: i128 = 23;
        // C s_286_1444: const #9s : i
        let s_286_1444: i128 = 9;
        // D s_286_1445: cast zx s_286_1442 -> bv
        let s_286_1445: Bits = Bits::new(s_286_1442 as u128, 32u16);
        // C s_286_1446: const #0u : u23
        let s_286_1446: u32 = 0;
        // C s_286_1447: cast zx s_286_1446 -> bv
        let s_286_1447: Bits = Bits::new(s_286_1446 as u128, 23u16);
        // C s_286_1448: const #1u : u64
        let s_286_1448: u64 = 1;
        // C s_286_1449: cast zx s_286_1448 -> bv
        let s_286_1449: Bits = Bits::new(s_286_1448 as u128, 64u16);
        // C s_286_1450: lsl s_286_1449 s_286_1443
        let s_286_1450: Bits = s_286_1449 << s_286_1443;
        // C s_286_1451: sub s_286_1450 s_286_1449
        let s_286_1451: Bits = ((s_286_1450) - (s_286_1449));
        // C s_286_1452: and s_286_1447 s_286_1451
        let s_286_1452: Bits = ((s_286_1447) & (s_286_1451));
        // C s_286_1453: lsl s_286_1452 s_286_1444
        let s_286_1453: Bits = s_286_1452 << s_286_1444;
        // C s_286_1454: lsl s_286_1451 s_286_1444
        let s_286_1454: Bits = s_286_1451 << s_286_1444;
        // C s_286_1455: cmpl s_286_1454
        let s_286_1455: Bits = !s_286_1454;
        // D s_286_1456: and s_286_1445 s_286_1455
        let s_286_1456: Bits = ((s_286_1445) & (s_286_1455));
        // D s_286_1457: or s_286_1456 s_286_1453
        let s_286_1457: Bits = ((s_286_1456) | (s_286_1453));
        // D s_286_1458: cast reint s_286_1457 -> u32
        let s_286_1458: u32 = (s_286_1457.value() as u32);
        // D s_286_1459: call Mk_ISR_Type(s_286_1458)
        let s_286_1459: ProductType700c18a878c5601b = Mk_ISR_Type(
            state,
            tracer,
            s_286_1458,
        );
        // D s_286_1460: call ISR_write(s_286_1459)
        let s_286_1460: () = ISR_write(state, tracer, s_286_1459);
        // C s_286_1461: const #() : ()
        let s_286_1461: () = ();
        // S s_286_1462: call ISR_read(s_286_1461)
        let s_286_1462: ProductType700c18a878c5601b = ISR_read(
            state,
            tracer,
            s_286_1461,
        );
        // D s_286_1463: write-var ga#36298 <= s_286_1462
        fn_state.ga_36298 = s_286_1462;
        // D s_286_1464: read-var ga#36298.0:struct
        let s_286_1464: u32 = fn_state.ga_36298._0;
        // C s_286_1465: const #6s : i
        let s_286_1465: i128 = 6;
        // C s_286_1466: const #0s : i
        let s_286_1466: i128 = 0;
        // D s_286_1467: cast zx s_286_1464 -> bv
        let s_286_1467: Bits = Bits::new(s_286_1464 as u128, 32u16);
        // C s_286_1468: const #0u : u8
        let s_286_1468: u8 = 0;
        // C s_286_1469: cast zx s_286_1468 -> bv
        let s_286_1469: Bits = Bits::new(s_286_1468 as u128, 6u16);
        // C s_286_1470: const #1u : u64
        let s_286_1470: u64 = 1;
        // C s_286_1471: cast zx s_286_1470 -> bv
        let s_286_1471: Bits = Bits::new(s_286_1470 as u128, 64u16);
        // C s_286_1472: lsl s_286_1471 s_286_1465
        let s_286_1472: Bits = s_286_1471 << s_286_1465;
        // C s_286_1473: sub s_286_1472 s_286_1471
        let s_286_1473: Bits = ((s_286_1472) - (s_286_1471));
        // C s_286_1474: and s_286_1469 s_286_1473
        let s_286_1474: Bits = ((s_286_1469) & (s_286_1473));
        // C s_286_1475: lsl s_286_1474 s_286_1466
        let s_286_1475: Bits = s_286_1474 << s_286_1466;
        // C s_286_1476: lsl s_286_1473 s_286_1466
        let s_286_1476: Bits = s_286_1473 << s_286_1466;
        // C s_286_1477: cmpl s_286_1476
        let s_286_1477: Bits = !s_286_1476;
        // D s_286_1478: and s_286_1467 s_286_1477
        let s_286_1478: Bits = ((s_286_1467) & (s_286_1477));
        // D s_286_1479: or s_286_1478 s_286_1475
        let s_286_1479: Bits = ((s_286_1478) | (s_286_1475));
        // D s_286_1480: cast reint s_286_1479 -> u32
        let s_286_1480: u32 = (s_286_1479.value() as u32);
        // D s_286_1481: call Mk_ISR_Type(s_286_1480)
        let s_286_1481: ProductType700c18a878c5601b = Mk_ISR_Type(
            state,
            tracer,
            s_286_1480,
        );
        // D s_286_1482: call ISR_write(s_286_1481)
        let s_286_1482: () = ISR_write(state, tracer, s_286_1481);
        // C s_286_1483: const #() : ()
        let s_286_1483: () = ();
        // S s_286_1484: call SCTLR_read__2(s_286_1483)
        let s_286_1484: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1483,
        );
        // C s_286_1485: const #0u : u8
        let s_286_1485: bool = false;
        // S s_286_1486: call _update_SCTLR_Type_AFE(s_286_1484, s_286_1485)
        let s_286_1486: ProductType700c18a878c5601b = u_update_SCTLR_Type_AFE(
            state,
            tracer,
            s_286_1484,
            s_286_1485,
        );
        // S s_286_1487: call SCTLR_write(s_286_1486)
        let s_286_1487: () = SCTLR_write(state, tracer, s_286_1486);
        // C s_286_1488: const #() : ()
        let s_286_1488: () = ();
        // S s_286_1489: call SCTLR_read__2(s_286_1488)
        let s_286_1489: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1488,
        );
        // C s_286_1490: const #0u : u8
        let s_286_1490: bool = false;
        // S s_286_1491: call _update_SCTLR_Type_TRE(s_286_1489, s_286_1490)
        let s_286_1491: ProductType700c18a878c5601b = u_update_SCTLR_Type_TRE(
            state,
            tracer,
            s_286_1489,
            s_286_1490,
        );
        // S s_286_1492: call SCTLR_write(s_286_1491)
        let s_286_1492: () = SCTLR_write(state, tracer, s_286_1491);
        // C s_286_1493: const #() : ()
        let s_286_1493: () = ();
        // S s_286_1494: call SCTLR_read__2(s_286_1493)
        let s_286_1494: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1493,
        );
        // D s_286_1495: write-var ga#36306 <= s_286_1494
        fn_state.ga_36306 = s_286_1494;
        // D s_286_1496: read-var ga#36306.0:struct
        let s_286_1496: u32 = fn_state.ga_36306._0;
        // C s_286_1497: const #2s : i
        let s_286_1497: i128 = 2;
        // C s_286_1498: const #26s : i
        let s_286_1498: i128 = 26;
        // D s_286_1499: cast zx s_286_1496 -> bv
        let s_286_1499: Bits = Bits::new(s_286_1496 as u128, 32u16);
        // C s_286_1500: const #0u : u8
        let s_286_1500: u8 = 0;
        // C s_286_1501: cast zx s_286_1500 -> bv
        let s_286_1501: Bits = Bits::new(s_286_1500 as u128, 2u16);
        // C s_286_1502: const #1u : u64
        let s_286_1502: u64 = 1;
        // C s_286_1503: cast zx s_286_1502 -> bv
        let s_286_1503: Bits = Bits::new(s_286_1502 as u128, 64u16);
        // C s_286_1504: lsl s_286_1503 s_286_1497
        let s_286_1504: Bits = s_286_1503 << s_286_1497;
        // C s_286_1505: sub s_286_1504 s_286_1503
        let s_286_1505: Bits = ((s_286_1504) - (s_286_1503));
        // C s_286_1506: and s_286_1501 s_286_1505
        let s_286_1506: Bits = ((s_286_1501) & (s_286_1505));
        // C s_286_1507: lsl s_286_1506 s_286_1498
        let s_286_1507: Bits = s_286_1506 << s_286_1498;
        // C s_286_1508: lsl s_286_1505 s_286_1498
        let s_286_1508: Bits = s_286_1505 << s_286_1498;
        // C s_286_1509: cmpl s_286_1508
        let s_286_1509: Bits = !s_286_1508;
        // D s_286_1510: and s_286_1499 s_286_1509
        let s_286_1510: Bits = ((s_286_1499) & (s_286_1509));
        // D s_286_1511: or s_286_1510 s_286_1507
        let s_286_1511: Bits = ((s_286_1510) | (s_286_1507));
        // D s_286_1512: cast reint s_286_1511 -> u32
        let s_286_1512: u32 = (s_286_1511.value() as u32);
        // D s_286_1513: call Mk_SCTLR_Type(s_286_1512)
        let s_286_1513: ProductType700c18a878c5601b = Mk_SCTLR_Type(
            state,
            tracer,
            s_286_1512,
        );
        // D s_286_1514: call SCTLR_write(s_286_1513)
        let s_286_1514: () = SCTLR_write(state, tracer, s_286_1513);
        // C s_286_1515: const #() : ()
        let s_286_1515: () = ();
        // S s_286_1516: call SCTLR_read__2(s_286_1515)
        let s_286_1516: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1515,
        );
        // D s_286_1517: write-var ga#36310 <= s_286_1516
        fn_state.ga_36310 = s_286_1516;
        // D s_286_1518: read-var ga#36310.0:struct
        let s_286_1518: u32 = fn_state.ga_36310._0;
        // C s_286_1519: const #1s : i
        let s_286_1519: i128 = 1;
        // C s_286_1520: const #24s : i
        let s_286_1520: i128 = 24;
        // D s_286_1521: cast zx s_286_1518 -> bv
        let s_286_1521: Bits = Bits::new(s_286_1518 as u128, 32u16);
        // C s_286_1522: const #0u : u8
        let s_286_1522: bool = false;
        // C s_286_1523: cast zx s_286_1522 -> bv
        let s_286_1523: Bits = Bits::new(s_286_1522 as u128, 1u16);
        // C s_286_1524: const #1u : u64
        let s_286_1524: u64 = 1;
        // C s_286_1525: cast zx s_286_1524 -> bv
        let s_286_1525: Bits = Bits::new(s_286_1524 as u128, 64u16);
        // C s_286_1526: lsl s_286_1525 s_286_1519
        let s_286_1526: Bits = s_286_1525 << s_286_1519;
        // C s_286_1527: sub s_286_1526 s_286_1525
        let s_286_1527: Bits = ((s_286_1526) - (s_286_1525));
        // C s_286_1528: and s_286_1523 s_286_1527
        let s_286_1528: Bits = ((s_286_1523) & (s_286_1527));
        // C s_286_1529: lsl s_286_1528 s_286_1520
        let s_286_1529: Bits = s_286_1528 << s_286_1520;
        // C s_286_1530: lsl s_286_1527 s_286_1520
        let s_286_1530: Bits = s_286_1527 << s_286_1520;
        // C s_286_1531: cmpl s_286_1530
        let s_286_1531: Bits = !s_286_1530;
        // D s_286_1532: and s_286_1521 s_286_1531
        let s_286_1532: Bits = ((s_286_1521) & (s_286_1531));
        // D s_286_1533: or s_286_1532 s_286_1529
        let s_286_1533: Bits = ((s_286_1532) | (s_286_1529));
        // D s_286_1534: cast reint s_286_1533 -> u32
        let s_286_1534: u32 = (s_286_1533.value() as u32);
        // D s_286_1535: call Mk_SCTLR_Type(s_286_1534)
        let s_286_1535: ProductType700c18a878c5601b = Mk_SCTLR_Type(
            state,
            tracer,
            s_286_1534,
        );
        // D s_286_1536: call SCTLR_write(s_286_1535)
        let s_286_1536: () = SCTLR_write(state, tracer, s_286_1535);
        // C s_286_1537: const #() : ()
        let s_286_1537: () = ();
        // S s_286_1538: call SCTLR_read__2(s_286_1537)
        let s_286_1538: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1537,
        );
        // D s_286_1539: write-var ga#36314 <= s_286_1538
        fn_state.ga_36314 = s_286_1538;
        // D s_286_1540: read-var ga#36314.0:struct
        let s_286_1540: u32 = fn_state.ga_36314._0;
        // C s_286_1541: const #1s : i
        let s_286_1541: i128 = 1;
        // C s_286_1542: const #22s : i
        let s_286_1542: i128 = 22;
        // D s_286_1543: cast zx s_286_1540 -> bv
        let s_286_1543: Bits = Bits::new(s_286_1540 as u128, 32u16);
        // C s_286_1544: const #1u : u8
        let s_286_1544: bool = true;
        // C s_286_1545: cast zx s_286_1544 -> bv
        let s_286_1545: Bits = Bits::new(s_286_1544 as u128, 1u16);
        // C s_286_1546: const #1u : u64
        let s_286_1546: u64 = 1;
        // C s_286_1547: cast zx s_286_1546 -> bv
        let s_286_1547: Bits = Bits::new(s_286_1546 as u128, 64u16);
        // C s_286_1548: lsl s_286_1547 s_286_1541
        let s_286_1548: Bits = s_286_1547 << s_286_1541;
        // C s_286_1549: sub s_286_1548 s_286_1547
        let s_286_1549: Bits = ((s_286_1548) - (s_286_1547));
        // C s_286_1550: and s_286_1545 s_286_1549
        let s_286_1550: Bits = ((s_286_1545) & (s_286_1549));
        // C s_286_1551: lsl s_286_1550 s_286_1542
        let s_286_1551: Bits = s_286_1550 << s_286_1542;
        // C s_286_1552: lsl s_286_1549 s_286_1542
        let s_286_1552: Bits = s_286_1549 << s_286_1542;
        // C s_286_1553: cmpl s_286_1552
        let s_286_1553: Bits = !s_286_1552;
        // D s_286_1554: and s_286_1543 s_286_1553
        let s_286_1554: Bits = ((s_286_1543) & (s_286_1553));
        // D s_286_1555: or s_286_1554 s_286_1551
        let s_286_1555: Bits = ((s_286_1554) | (s_286_1551));
        // D s_286_1556: cast reint s_286_1555 -> u32
        let s_286_1556: u32 = (s_286_1555.value() as u32);
        // D s_286_1557: call Mk_SCTLR_Type(s_286_1556)
        let s_286_1557: ProductType700c18a878c5601b = Mk_SCTLR_Type(
            state,
            tracer,
            s_286_1556,
        );
        // D s_286_1558: call SCTLR_write(s_286_1557)
        let s_286_1558: () = SCTLR_write(state, tracer, s_286_1557);
        // C s_286_1559: const #() : ()
        let s_286_1559: () = ();
        // S s_286_1560: call SCTLR_read__2(s_286_1559)
        let s_286_1560: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1559,
        );
        // D s_286_1561: write-var ga#36318 <= s_286_1560
        fn_state.ga_36318 = s_286_1560;
        // D s_286_1562: read-var ga#36318.0:struct
        let s_286_1562: u32 = fn_state.ga_36318._0;
        // C s_286_1563: const #1s : i
        let s_286_1563: i128 = 1;
        // C s_286_1564: const #21s : i
        let s_286_1564: i128 = 21;
        // D s_286_1565: cast zx s_286_1562 -> bv
        let s_286_1565: Bits = Bits::new(s_286_1562 as u128, 32u16);
        // C s_286_1566: const #0u : u8
        let s_286_1566: bool = false;
        // C s_286_1567: cast zx s_286_1566 -> bv
        let s_286_1567: Bits = Bits::new(s_286_1566 as u128, 1u16);
        // C s_286_1568: const #1u : u64
        let s_286_1568: u64 = 1;
        // C s_286_1569: cast zx s_286_1568 -> bv
        let s_286_1569: Bits = Bits::new(s_286_1568 as u128, 64u16);
        // C s_286_1570: lsl s_286_1569 s_286_1563
        let s_286_1570: Bits = s_286_1569 << s_286_1563;
        // C s_286_1571: sub s_286_1570 s_286_1569
        let s_286_1571: Bits = ((s_286_1570) - (s_286_1569));
        // C s_286_1572: and s_286_1567 s_286_1571
        let s_286_1572: Bits = ((s_286_1567) & (s_286_1571));
        // C s_286_1573: lsl s_286_1572 s_286_1564
        let s_286_1573: Bits = s_286_1572 << s_286_1564;
        // C s_286_1574: lsl s_286_1571 s_286_1564
        let s_286_1574: Bits = s_286_1571 << s_286_1564;
        // C s_286_1575: cmpl s_286_1574
        let s_286_1575: Bits = !s_286_1574;
        // D s_286_1576: and s_286_1565 s_286_1575
        let s_286_1576: Bits = ((s_286_1565) & (s_286_1575));
        // D s_286_1577: or s_286_1576 s_286_1573
        let s_286_1577: Bits = ((s_286_1576) | (s_286_1573));
        // D s_286_1578: cast reint s_286_1577 -> u32
        let s_286_1578: u32 = (s_286_1577.value() as u32);
        // D s_286_1579: call Mk_SCTLR_Type(s_286_1578)
        let s_286_1579: ProductType700c18a878c5601b = Mk_SCTLR_Type(
            state,
            tracer,
            s_286_1578,
        );
        // D s_286_1580: call SCTLR_write(s_286_1579)
        let s_286_1580: () = SCTLR_write(state, tracer, s_286_1579);
        // C s_286_1581: const #() : ()
        let s_286_1581: () = ();
        // S s_286_1582: call SCTLR_read__2(s_286_1581)
        let s_286_1582: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1581,
        );
        // C s_286_1583: const #0u : u8
        let s_286_1583: bool = false;
        // S s_286_1584: call _update_SCTLR_Type_UWXN(s_286_1582, s_286_1583)
        let s_286_1584: ProductType700c18a878c5601b = u_update_SCTLR_Type_UWXN(
            state,
            tracer,
            s_286_1582,
            s_286_1583,
        );
        // S s_286_1585: call SCTLR_write(s_286_1584)
        let s_286_1585: () = SCTLR_write(state, tracer, s_286_1584);
        // C s_286_1586: const #() : ()
        let s_286_1586: () = ();
        // S s_286_1587: call SCTLR_read__2(s_286_1586)
        let s_286_1587: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1586,
        );
        // C s_286_1588: const #0u : u8
        let s_286_1588: bool = false;
        // S s_286_1589: call _update_SCTLR_Type_WXN(s_286_1587, s_286_1588)
        let s_286_1589: ProductType700c18a878c5601b = u_update_SCTLR_Type_WXN(
            state,
            tracer,
            s_286_1587,
            s_286_1588,
        );
        // S s_286_1590: call SCTLR_write(s_286_1589)
        let s_286_1590: () = SCTLR_write(state, tracer, s_286_1589);
        // C s_286_1591: const #() : ()
        let s_286_1591: () = ();
        // S s_286_1592: call SCTLR_read__2(s_286_1591)
        let s_286_1592: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1591,
        );
        // C s_286_1593: const #1u : u8
        let s_286_1593: bool = true;
        // S s_286_1594: call _update_SCTLR_Type_nTWE(s_286_1592, s_286_1593)
        let s_286_1594: ProductType700c18a878c5601b = u_update_SCTLR_Type_nTWE(
            state,
            tracer,
            s_286_1592,
            s_286_1593,
        );
        // S s_286_1595: call SCTLR_write(s_286_1594)
        let s_286_1595: () = SCTLR_write(state, tracer, s_286_1594);
        // C s_286_1596: const #() : ()
        let s_286_1596: () = ();
        // S s_286_1597: call SCTLR_read__2(s_286_1596)
        let s_286_1597: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1596,
        );
        // D s_286_1598: write-var ga#36328 <= s_286_1597
        fn_state.ga_36328 = s_286_1597;
        // D s_286_1599: read-var ga#36328.0:struct
        let s_286_1599: u32 = fn_state.ga_36328._0;
        // C s_286_1600: const #1s : i
        let s_286_1600: i128 = 1;
        // C s_286_1601: const #17s : i
        let s_286_1601: i128 = 17;
        // D s_286_1602: cast zx s_286_1599 -> bv
        let s_286_1602: Bits = Bits::new(s_286_1599 as u128, 32u16);
        // C s_286_1603: const #0u : u8
        let s_286_1603: bool = false;
        // C s_286_1604: cast zx s_286_1603 -> bv
        let s_286_1604: Bits = Bits::new(s_286_1603 as u128, 1u16);
        // C s_286_1605: const #1u : u64
        let s_286_1605: u64 = 1;
        // C s_286_1606: cast zx s_286_1605 -> bv
        let s_286_1606: Bits = Bits::new(s_286_1605 as u128, 64u16);
        // C s_286_1607: lsl s_286_1606 s_286_1600
        let s_286_1607: Bits = s_286_1606 << s_286_1600;
        // C s_286_1608: sub s_286_1607 s_286_1606
        let s_286_1608: Bits = ((s_286_1607) - (s_286_1606));
        // C s_286_1609: and s_286_1604 s_286_1608
        let s_286_1609: Bits = ((s_286_1604) & (s_286_1608));
        // C s_286_1610: lsl s_286_1609 s_286_1601
        let s_286_1610: Bits = s_286_1609 << s_286_1601;
        // C s_286_1611: lsl s_286_1608 s_286_1601
        let s_286_1611: Bits = s_286_1608 << s_286_1601;
        // C s_286_1612: cmpl s_286_1611
        let s_286_1612: Bits = !s_286_1611;
        // D s_286_1613: and s_286_1602 s_286_1612
        let s_286_1613: Bits = ((s_286_1602) & (s_286_1612));
        // D s_286_1614: or s_286_1613 s_286_1610
        let s_286_1614: Bits = ((s_286_1613) | (s_286_1610));
        // D s_286_1615: cast reint s_286_1614 -> u32
        let s_286_1615: u32 = (s_286_1614.value() as u32);
        // D s_286_1616: call Mk_SCTLR_Type(s_286_1615)
        let s_286_1616: ProductType700c18a878c5601b = Mk_SCTLR_Type(
            state,
            tracer,
            s_286_1615,
        );
        // D s_286_1617: call SCTLR_write(s_286_1616)
        let s_286_1617: () = SCTLR_write(state, tracer, s_286_1616);
        // C s_286_1618: const #() : ()
        let s_286_1618: () = ();
        // S s_286_1619: call SCTLR_read__2(s_286_1618)
        let s_286_1619: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1618,
        );
        // C s_286_1620: const #1u : u8
        let s_286_1620: bool = true;
        // S s_286_1621: call _update_SCTLR_Type_nTWI(s_286_1619, s_286_1620)
        let s_286_1621: ProductType700c18a878c5601b = u_update_SCTLR_Type_nTWI(
            state,
            tracer,
            s_286_1619,
            s_286_1620,
        );
        // S s_286_1622: call SCTLR_write(s_286_1621)
        let s_286_1622: () = SCTLR_write(state, tracer, s_286_1621);
        // C s_286_1623: const #() : ()
        let s_286_1623: () = ();
        // S s_286_1624: call SCTLR_read__2(s_286_1623)
        let s_286_1624: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1623,
        );
        // D s_286_1625: write-var ga#36334 <= s_286_1624
        fn_state.ga_36334 = s_286_1624;
        // D s_286_1626: read-var ga#36334.0:struct
        let s_286_1626: u32 = fn_state.ga_36334._0;
        // C s_286_1627: const #2s : i
        let s_286_1627: i128 = 2;
        // C s_286_1628: const #14s : i
        let s_286_1628: i128 = 14;
        // D s_286_1629: cast zx s_286_1626 -> bv
        let s_286_1629: Bits = Bits::new(s_286_1626 as u128, 32u16);
        // C s_286_1630: const #0u : u8
        let s_286_1630: u8 = 0;
        // C s_286_1631: cast zx s_286_1630 -> bv
        let s_286_1631: Bits = Bits::new(s_286_1630 as u128, 2u16);
        // C s_286_1632: const #1u : u64
        let s_286_1632: u64 = 1;
        // C s_286_1633: cast zx s_286_1632 -> bv
        let s_286_1633: Bits = Bits::new(s_286_1632 as u128, 64u16);
        // C s_286_1634: lsl s_286_1633 s_286_1627
        let s_286_1634: Bits = s_286_1633 << s_286_1627;
        // C s_286_1635: sub s_286_1634 s_286_1633
        let s_286_1635: Bits = ((s_286_1634) - (s_286_1633));
        // C s_286_1636: and s_286_1631 s_286_1635
        let s_286_1636: Bits = ((s_286_1631) & (s_286_1635));
        // C s_286_1637: lsl s_286_1636 s_286_1628
        let s_286_1637: Bits = s_286_1636 << s_286_1628;
        // C s_286_1638: lsl s_286_1635 s_286_1628
        let s_286_1638: Bits = s_286_1635 << s_286_1628;
        // C s_286_1639: cmpl s_286_1638
        let s_286_1639: Bits = !s_286_1638;
        // D s_286_1640: and s_286_1629 s_286_1639
        let s_286_1640: Bits = ((s_286_1629) & (s_286_1639));
        // D s_286_1641: or s_286_1640 s_286_1637
        let s_286_1641: Bits = ((s_286_1640) | (s_286_1637));
        // D s_286_1642: cast reint s_286_1641 -> u32
        let s_286_1642: u32 = (s_286_1641.value() as u32);
        // D s_286_1643: call Mk_SCTLR_Type(s_286_1642)
        let s_286_1643: ProductType700c18a878c5601b = Mk_SCTLR_Type(
            state,
            tracer,
            s_286_1642,
        );
        // D s_286_1644: call SCTLR_write(s_286_1643)
        let s_286_1644: () = SCTLR_write(state, tracer, s_286_1643);
        // C s_286_1645: const #() : ()
        let s_286_1645: () = ();
        // S s_286_1646: call SCTLR_read__2(s_286_1645)
        let s_286_1646: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1645,
        );
        // C s_286_1647: const #0u : u8
        let s_286_1647: bool = false;
        // S s_286_1648: call _update_SCTLR_Type_I(s_286_1646, s_286_1647)
        let s_286_1648: ProductType700c18a878c5601b = u_update_SCTLR_Type_I(
            state,
            tracer,
            s_286_1646,
            s_286_1647,
        );
        // S s_286_1649: call SCTLR_write(s_286_1648)
        let s_286_1649: () = SCTLR_write(state, tracer, s_286_1648);
        // C s_286_1650: const #() : ()
        let s_286_1650: () = ();
        // S s_286_1651: call SCTLR_read__2(s_286_1650)
        let s_286_1651: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1650,
        );
        // D s_286_1652: write-var ga#36340 <= s_286_1651
        fn_state.ga_36340 = s_286_1651;
        // D s_286_1653: read-var ga#36340.0:struct
        let s_286_1653: u32 = fn_state.ga_36340._0;
        // C s_286_1654: const #1s : i
        let s_286_1654: i128 = 1;
        // C s_286_1655: const #11s : i
        let s_286_1655: i128 = 11;
        // D s_286_1656: cast zx s_286_1653 -> bv
        let s_286_1656: Bits = Bits::new(s_286_1653 as u128, 32u16);
        // C s_286_1657: const #1u : u8
        let s_286_1657: bool = true;
        // C s_286_1658: cast zx s_286_1657 -> bv
        let s_286_1658: Bits = Bits::new(s_286_1657 as u128, 1u16);
        // C s_286_1659: const #1u : u64
        let s_286_1659: u64 = 1;
        // C s_286_1660: cast zx s_286_1659 -> bv
        let s_286_1660: Bits = Bits::new(s_286_1659 as u128, 64u16);
        // C s_286_1661: lsl s_286_1660 s_286_1654
        let s_286_1661: Bits = s_286_1660 << s_286_1654;
        // C s_286_1662: sub s_286_1661 s_286_1660
        let s_286_1662: Bits = ((s_286_1661) - (s_286_1660));
        // C s_286_1663: and s_286_1658 s_286_1662
        let s_286_1663: Bits = ((s_286_1658) & (s_286_1662));
        // C s_286_1664: lsl s_286_1663 s_286_1655
        let s_286_1664: Bits = s_286_1663 << s_286_1655;
        // C s_286_1665: lsl s_286_1662 s_286_1655
        let s_286_1665: Bits = s_286_1662 << s_286_1655;
        // C s_286_1666: cmpl s_286_1665
        let s_286_1666: Bits = !s_286_1665;
        // D s_286_1667: and s_286_1656 s_286_1666
        let s_286_1667: Bits = ((s_286_1656) & (s_286_1666));
        // D s_286_1668: or s_286_1667 s_286_1664
        let s_286_1668: Bits = ((s_286_1667) | (s_286_1664));
        // D s_286_1669: cast reint s_286_1668 -> u32
        let s_286_1669: u32 = (s_286_1668.value() as u32);
        // D s_286_1670: call Mk_SCTLR_Type(s_286_1669)
        let s_286_1670: ProductType700c18a878c5601b = Mk_SCTLR_Type(
            state,
            tracer,
            s_286_1669,
        );
        // D s_286_1671: call SCTLR_write(s_286_1670)
        let s_286_1671: () = SCTLR_write(state, tracer, s_286_1670);
        // C s_286_1672: const #() : ()
        let s_286_1672: () = ();
        // S s_286_1673: call SCTLR_read__2(s_286_1672)
        let s_286_1673: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1672,
        );
        // D s_286_1674: write-var ga#36344 <= s_286_1673
        fn_state.ga_36344 = s_286_1673;
        // D s_286_1675: read-var ga#36344.0:struct
        let s_286_1675: u32 = fn_state.ga_36344._0;
        // C s_286_1676: const #1s : i
        let s_286_1676: i128 = 1;
        // C s_286_1677: const #9s : i
        let s_286_1677: i128 = 9;
        // D s_286_1678: cast zx s_286_1675 -> bv
        let s_286_1678: Bits = Bits::new(s_286_1675 as u128, 32u16);
        // C s_286_1679: const #0u : u8
        let s_286_1679: bool = false;
        // C s_286_1680: cast zx s_286_1679 -> bv
        let s_286_1680: Bits = Bits::new(s_286_1679 as u128, 1u16);
        // C s_286_1681: const #1u : u64
        let s_286_1681: u64 = 1;
        // C s_286_1682: cast zx s_286_1681 -> bv
        let s_286_1682: Bits = Bits::new(s_286_1681 as u128, 64u16);
        // C s_286_1683: lsl s_286_1682 s_286_1676
        let s_286_1683: Bits = s_286_1682 << s_286_1676;
        // C s_286_1684: sub s_286_1683 s_286_1682
        let s_286_1684: Bits = ((s_286_1683) - (s_286_1682));
        // C s_286_1685: and s_286_1680 s_286_1684
        let s_286_1685: Bits = ((s_286_1680) & (s_286_1684));
        // C s_286_1686: lsl s_286_1685 s_286_1677
        let s_286_1686: Bits = s_286_1685 << s_286_1677;
        // C s_286_1687: lsl s_286_1684 s_286_1677
        let s_286_1687: Bits = s_286_1684 << s_286_1677;
        // C s_286_1688: cmpl s_286_1687
        let s_286_1688: Bits = !s_286_1687;
        // D s_286_1689: and s_286_1678 s_286_1688
        let s_286_1689: Bits = ((s_286_1678) & (s_286_1688));
        // D s_286_1690: or s_286_1689 s_286_1686
        let s_286_1690: Bits = ((s_286_1689) | (s_286_1686));
        // D s_286_1691: cast reint s_286_1690 -> u32
        let s_286_1691: u32 = (s_286_1690.value() as u32);
        // D s_286_1692: call Mk_SCTLR_Type(s_286_1691)
        let s_286_1692: ProductType700c18a878c5601b = Mk_SCTLR_Type(
            state,
            tracer,
            s_286_1691,
        );
        // D s_286_1693: call SCTLR_write(s_286_1692)
        let s_286_1693: () = SCTLR_write(state, tracer, s_286_1692);
        // C s_286_1694: const #() : ()
        let s_286_1694: () = ();
        // S s_286_1695: call SCTLR_read__2(s_286_1694)
        let s_286_1695: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1694,
        );
        // C s_286_1696: const #0u : u8
        let s_286_1696: bool = false;
        // S s_286_1697: call _update_SCTLR_Type_SED(s_286_1695, s_286_1696)
        let s_286_1697: ProductType700c18a878c5601b = u_update_SCTLR_Type_SED(
            state,
            tracer,
            s_286_1695,
            s_286_1696,
        );
        // S s_286_1698: call SCTLR_write(s_286_1697)
        let s_286_1698: () = SCTLR_write(state, tracer, s_286_1697);
        // C s_286_1699: const #() : ()
        let s_286_1699: () = ();
        // S s_286_1700: call SCTLR_read__2(s_286_1699)
        let s_286_1700: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1699,
        );
        // C s_286_1701: const #0u : u8
        let s_286_1701: bool = false;
        // S s_286_1702: call _update_SCTLR_Type_ITD(s_286_1700, s_286_1701)
        let s_286_1702: ProductType700c18a878c5601b = u_update_SCTLR_Type_ITD(
            state,
            tracer,
            s_286_1700,
            s_286_1701,
        );
        // S s_286_1703: call SCTLR_write(s_286_1702)
        let s_286_1703: () = SCTLR_write(state, tracer, s_286_1702);
        // C s_286_1704: const #() : ()
        let s_286_1704: () = ();
        // S s_286_1705: call SCTLR_read__2(s_286_1704)
        let s_286_1705: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1704,
        );
        // C s_286_1706: const #1u : u8
        let s_286_1706: bool = true;
        // S s_286_1707: call _update_SCTLR_Type_CP15BEN(s_286_1705, s_286_1706)
        let s_286_1707: ProductType700c18a878c5601b = u_update_SCTLR_Type_CP15BEN(
            state,
            tracer,
            s_286_1705,
            s_286_1706,
        );
        // S s_286_1708: call SCTLR_write(s_286_1707)
        let s_286_1708: () = SCTLR_write(state, tracer, s_286_1707);
        // C s_286_1709: const #() : ()
        let s_286_1709: () = ();
        // S s_286_1710: call SCTLR_read__2(s_286_1709)
        let s_286_1710: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1709,
        );
        // C s_286_1711: const #1u : u8
        let s_286_1711: bool = true;
        // S s_286_1712: call _update_SCTLR_Type_LSMAOE(s_286_1710, s_286_1711)
        let s_286_1712: ProductType700c18a878c5601b = u_update_SCTLR_Type_LSMAOE(
            state,
            tracer,
            s_286_1710,
            s_286_1711,
        );
        // S s_286_1713: call SCTLR_write(s_286_1712)
        let s_286_1713: () = SCTLR_write(state, tracer, s_286_1712);
        // C s_286_1714: const #() : ()
        let s_286_1714: () = ();
        // S s_286_1715: call SCTLR_read__2(s_286_1714)
        let s_286_1715: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1714,
        );
        // C s_286_1716: const #1u : u8
        let s_286_1716: bool = true;
        // S s_286_1717: call _update_SCTLR_Type_nTLSMD(s_286_1715, s_286_1716)
        let s_286_1717: ProductType700c18a878c5601b = u_update_SCTLR_Type_nTLSMD(
            state,
            tracer,
            s_286_1715,
            s_286_1716,
        );
        // S s_286_1718: call SCTLR_write(s_286_1717)
        let s_286_1718: () = SCTLR_write(state, tracer, s_286_1717);
        // C s_286_1719: const #() : ()
        let s_286_1719: () = ();
        // S s_286_1720: call SCTLR_read__2(s_286_1719)
        let s_286_1720: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1719,
        );
        // C s_286_1721: const #0u : u8
        let s_286_1721: bool = false;
        // S s_286_1722: call _update_SCTLR_Type_C(s_286_1720, s_286_1721)
        let s_286_1722: ProductType700c18a878c5601b = u_update_SCTLR_Type_C(
            state,
            tracer,
            s_286_1720,
            s_286_1721,
        );
        // S s_286_1723: call SCTLR_write(s_286_1722)
        let s_286_1723: () = SCTLR_write(state, tracer, s_286_1722);
        // C s_286_1724: const #() : ()
        let s_286_1724: () = ();
        // S s_286_1725: call SCTLR_read__2(s_286_1724)
        let s_286_1725: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1724,
        );
        // C s_286_1726: const #0u : u8
        let s_286_1726: bool = false;
        // S s_286_1727: call _update_SCTLR_Type_A(s_286_1725, s_286_1726)
        let s_286_1727: ProductType700c18a878c5601b = u_update_SCTLR_Type_A(
            state,
            tracer,
            s_286_1725,
            s_286_1726,
        );
        // S s_286_1728: call SCTLR_write(s_286_1727)
        let s_286_1728: () = SCTLR_write(state, tracer, s_286_1727);
        // C s_286_1729: const #() : ()
        let s_286_1729: () = ();
        // S s_286_1730: call SCTLR_read__2(s_286_1729)
        let s_286_1730: ProductType700c18a878c5601b = SCTLR_read__2(
            state,
            tracer,
            s_286_1729,
        );
        // C s_286_1731: const #0u : u8
        let s_286_1731: bool = false;
        // S s_286_1732: call _update_SCTLR_Type_M(s_286_1730, s_286_1731)
        let s_286_1732: ProductType700c18a878c5601b = u_update_SCTLR_Type_M(
            state,
            tracer,
            s_286_1730,
            s_286_1731,
        );
        // S s_286_1733: call SCTLR_write(s_286_1732)
        let s_286_1733: () = SCTLR_write(state, tracer, s_286_1732);
        // C s_286_1734: const #() : ()
        let s_286_1734: () = ();
        // S s_286_1735: call DBGDSCRint_read(s_286_1734)
        let s_286_1735: ProductType700c18a878c5601b = DBGDSCRint_read(
            state,
            tracer,
            s_286_1734,
        );
        // D s_286_1736: write-var ga#36364 <= s_286_1735
        fn_state.ga_36364 = s_286_1735;
        // D s_286_1737: read-var ga#36364.0:struct
        let s_286_1737: u32 = fn_state.ga_36364._0;
        // C s_286_1738: const #1s : i
        let s_286_1738: i128 = 1;
        // C s_286_1739: const #31s : i
        let s_286_1739: i128 = 31;
        // D s_286_1740: cast zx s_286_1737 -> bv
        let s_286_1740: Bits = Bits::new(s_286_1737 as u128, 32u16);
        // C s_286_1741: const #0u : u8
        let s_286_1741: bool = false;
        // C s_286_1742: cast zx s_286_1741 -> bv
        let s_286_1742: Bits = Bits::new(s_286_1741 as u128, 1u16);
        // C s_286_1743: const #1u : u64
        let s_286_1743: u64 = 1;
        // C s_286_1744: cast zx s_286_1743 -> bv
        let s_286_1744: Bits = Bits::new(s_286_1743 as u128, 64u16);
        // C s_286_1745: lsl s_286_1744 s_286_1738
        let s_286_1745: Bits = s_286_1744 << s_286_1738;
        // C s_286_1746: sub s_286_1745 s_286_1744
        let s_286_1746: Bits = ((s_286_1745) - (s_286_1744));
        // C s_286_1747: and s_286_1742 s_286_1746
        let s_286_1747: Bits = ((s_286_1742) & (s_286_1746));
        // C s_286_1748: lsl s_286_1747 s_286_1739
        let s_286_1748: Bits = s_286_1747 << s_286_1739;
        // C s_286_1749: lsl s_286_1746 s_286_1739
        let s_286_1749: Bits = s_286_1746 << s_286_1739;
        // C s_286_1750: cmpl s_286_1749
        let s_286_1750: Bits = !s_286_1749;
        // D s_286_1751: and s_286_1740 s_286_1750
        let s_286_1751: Bits = ((s_286_1740) & (s_286_1750));
        // D s_286_1752: or s_286_1751 s_286_1748
        let s_286_1752: Bits = ((s_286_1751) | (s_286_1748));
        // D s_286_1753: cast reint s_286_1752 -> u32
        let s_286_1753: u32 = (s_286_1752.value() as u32);
        // D s_286_1754: call Mk_DBGDSCRint_Type(s_286_1753)
        let s_286_1754: ProductType700c18a878c5601b = Mk_DBGDSCRint_Type(
            state,
            tracer,
            s_286_1753,
        );
        // D s_286_1755: call DBGDSCRint_write(s_286_1754)
        let s_286_1755: () = DBGDSCRint_write(state, tracer, s_286_1754);
        // C s_286_1756: const #() : ()
        let s_286_1756: () = ();
        // S s_286_1757: call DBGDSCRint_read(s_286_1756)
        let s_286_1757: ProductType700c18a878c5601b = DBGDSCRint_read(
            state,
            tracer,
            s_286_1756,
        );
        // D s_286_1758: write-var ga#36368 <= s_286_1757
        fn_state.ga_36368 = s_286_1757;
        // D s_286_1759: read-var ga#36368.0:struct
        let s_286_1759: u32 = fn_state.ga_36368._0;
        // C s_286_1760: const #10s : i
        let s_286_1760: i128 = 10;
        // C s_286_1761: const #19s : i
        let s_286_1761: i128 = 19;
        // D s_286_1762: cast zx s_286_1759 -> bv
        let s_286_1762: Bits = Bits::new(s_286_1759 as u128, 32u16);
        // C s_286_1763: const #0u : u10
        let s_286_1763: u16 = 0;
        // C s_286_1764: cast zx s_286_1763 -> bv
        let s_286_1764: Bits = Bits::new(s_286_1763 as u128, 10u16);
        // C s_286_1765: const #1u : u64
        let s_286_1765: u64 = 1;
        // C s_286_1766: cast zx s_286_1765 -> bv
        let s_286_1766: Bits = Bits::new(s_286_1765 as u128, 64u16);
        // C s_286_1767: lsl s_286_1766 s_286_1760
        let s_286_1767: Bits = s_286_1766 << s_286_1760;
        // C s_286_1768: sub s_286_1767 s_286_1766
        let s_286_1768: Bits = ((s_286_1767) - (s_286_1766));
        // C s_286_1769: and s_286_1764 s_286_1768
        let s_286_1769: Bits = ((s_286_1764) & (s_286_1768));
        // C s_286_1770: lsl s_286_1769 s_286_1761
        let s_286_1770: Bits = s_286_1769 << s_286_1761;
        // C s_286_1771: lsl s_286_1768 s_286_1761
        let s_286_1771: Bits = s_286_1768 << s_286_1761;
        // C s_286_1772: cmpl s_286_1771
        let s_286_1772: Bits = !s_286_1771;
        // D s_286_1773: and s_286_1762 s_286_1772
        let s_286_1773: Bits = ((s_286_1762) & (s_286_1772));
        // D s_286_1774: or s_286_1773 s_286_1770
        let s_286_1774: Bits = ((s_286_1773) | (s_286_1770));
        // D s_286_1775: cast reint s_286_1774 -> u32
        let s_286_1775: u32 = (s_286_1774.value() as u32);
        // D s_286_1776: call Mk_DBGDSCRint_Type(s_286_1775)
        let s_286_1776: ProductType700c18a878c5601b = Mk_DBGDSCRint_Type(
            state,
            tracer,
            s_286_1775,
        );
        // D s_286_1777: call DBGDSCRint_write(s_286_1776)
        let s_286_1777: () = DBGDSCRint_write(state, tracer, s_286_1776);
        // C s_286_1778: const #() : ()
        let s_286_1778: () = ();
        // S s_286_1779: call DBGDSCRint_read(s_286_1778)
        let s_286_1779: ProductType700c18a878c5601b = DBGDSCRint_read(
            state,
            tracer,
            s_286_1778,
        );
        // D s_286_1780: write-var ga#36372 <= s_286_1779
        fn_state.ga_36372 = s_286_1779;
        // D s_286_1781: read-var ga#36372.0:struct
        let s_286_1781: u32 = fn_state.ga_36372._0;
        // C s_286_1782: const #2s : i
        let s_286_1782: i128 = 2;
        // C s_286_1783: const #13s : i
        let s_286_1783: i128 = 13;
        // D s_286_1784: cast zx s_286_1781 -> bv
        let s_286_1784: Bits = Bits::new(s_286_1781 as u128, 32u16);
        // C s_286_1785: const #0u : u8
        let s_286_1785: u8 = 0;
        // C s_286_1786: cast zx s_286_1785 -> bv
        let s_286_1786: Bits = Bits::new(s_286_1785 as u128, 2u16);
        // C s_286_1787: const #1u : u64
        let s_286_1787: u64 = 1;
        // C s_286_1788: cast zx s_286_1787 -> bv
        let s_286_1788: Bits = Bits::new(s_286_1787 as u128, 64u16);
        // C s_286_1789: lsl s_286_1788 s_286_1782
        let s_286_1789: Bits = s_286_1788 << s_286_1782;
        // C s_286_1790: sub s_286_1789 s_286_1788
        let s_286_1790: Bits = ((s_286_1789) - (s_286_1788));
        // C s_286_1791: and s_286_1786 s_286_1790
        let s_286_1791: Bits = ((s_286_1786) & (s_286_1790));
        // C s_286_1792: lsl s_286_1791 s_286_1783
        let s_286_1792: Bits = s_286_1791 << s_286_1783;
        // C s_286_1793: lsl s_286_1790 s_286_1783
        let s_286_1793: Bits = s_286_1790 << s_286_1783;
        // C s_286_1794: cmpl s_286_1793
        let s_286_1794: Bits = !s_286_1793;
        // D s_286_1795: and s_286_1784 s_286_1794
        let s_286_1795: Bits = ((s_286_1784) & (s_286_1794));
        // D s_286_1796: or s_286_1795 s_286_1792
        let s_286_1796: Bits = ((s_286_1795) | (s_286_1792));
        // D s_286_1797: cast reint s_286_1796 -> u32
        let s_286_1797: u32 = (s_286_1796.value() as u32);
        // D s_286_1798: call Mk_DBGDSCRint_Type(s_286_1797)
        let s_286_1798: ProductType700c18a878c5601b = Mk_DBGDSCRint_Type(
            state,
            tracer,
            s_286_1797,
        );
        // D s_286_1799: call DBGDSCRint_write(s_286_1798)
        let s_286_1799: () = DBGDSCRint_write(state, tracer, s_286_1798);
        // C s_286_1800: const #() : ()
        let s_286_1800: () = ();
        // S s_286_1801: call DBGDSCRint_read(s_286_1800)
        let s_286_1801: ProductType700c18a878c5601b = DBGDSCRint_read(
            state,
            tracer,
            s_286_1800,
        );
        // D s_286_1802: write-var ga#36376 <= s_286_1801
        fn_state.ga_36376 = s_286_1801;
        // D s_286_1803: read-var ga#36376.0:struct
        let s_286_1803: u32 = fn_state.ga_36376._0;
        // C s_286_1804: const #6s : i
        let s_286_1804: i128 = 6;
        // C s_286_1805: const #6s : i
        let s_286_1805: i128 = 6;
        // D s_286_1806: cast zx s_286_1803 -> bv
        let s_286_1806: Bits = Bits::new(s_286_1803 as u128, 32u16);
        // C s_286_1807: const #0u : u8
        let s_286_1807: u8 = 0;
        // C s_286_1808: cast zx s_286_1807 -> bv
        let s_286_1808: Bits = Bits::new(s_286_1807 as u128, 6u16);
        // C s_286_1809: const #1u : u64
        let s_286_1809: u64 = 1;
        // C s_286_1810: cast zx s_286_1809 -> bv
        let s_286_1810: Bits = Bits::new(s_286_1809 as u128, 64u16);
        // C s_286_1811: lsl s_286_1810 s_286_1804
        let s_286_1811: Bits = s_286_1810 << s_286_1804;
        // C s_286_1812: sub s_286_1811 s_286_1810
        let s_286_1812: Bits = ((s_286_1811) - (s_286_1810));
        // C s_286_1813: and s_286_1808 s_286_1812
        let s_286_1813: Bits = ((s_286_1808) & (s_286_1812));
        // C s_286_1814: lsl s_286_1813 s_286_1805
        let s_286_1814: Bits = s_286_1813 << s_286_1805;
        // C s_286_1815: lsl s_286_1812 s_286_1805
        let s_286_1815: Bits = s_286_1812 << s_286_1805;
        // C s_286_1816: cmpl s_286_1815
        let s_286_1816: Bits = !s_286_1815;
        // D s_286_1817: and s_286_1806 s_286_1816
        let s_286_1817: Bits = ((s_286_1806) & (s_286_1816));
        // D s_286_1818: or s_286_1817 s_286_1814
        let s_286_1818: Bits = ((s_286_1817) | (s_286_1814));
        // D s_286_1819: cast reint s_286_1818 -> u32
        let s_286_1819: u32 = (s_286_1818.value() as u32);
        // D s_286_1820: call Mk_DBGDSCRint_Type(s_286_1819)
        let s_286_1820: ProductType700c18a878c5601b = Mk_DBGDSCRint_Type(
            state,
            tracer,
            s_286_1819,
        );
        // D s_286_1821: call DBGDSCRint_write(s_286_1820)
        let s_286_1821: () = DBGDSCRint_write(state, tracer, s_286_1820);
        // C s_286_1822: const #() : ()
        let s_286_1822: () = ();
        // S s_286_1823: call DBGDSCRint_read(s_286_1822)
        let s_286_1823: ProductType700c18a878c5601b = DBGDSCRint_read(
            state,
            tracer,
            s_286_1822,
        );
        // D s_286_1824: write-var ga#36380 <= s_286_1823
        fn_state.ga_36380 = s_286_1823;
        // D s_286_1825: read-var ga#36380.0:struct
        let s_286_1825: u32 = fn_state.ga_36380._0;
        // C s_286_1826: const #2s : i
        let s_286_1826: i128 = 2;
        // C s_286_1827: const #0s : i
        let s_286_1827: i128 = 0;
        // D s_286_1828: cast zx s_286_1825 -> bv
        let s_286_1828: Bits = Bits::new(s_286_1825 as u128, 32u16);
        // C s_286_1829: const #0u : u8
        let s_286_1829: u8 = 0;
        // C s_286_1830: cast zx s_286_1829 -> bv
        let s_286_1830: Bits = Bits::new(s_286_1829 as u128, 2u16);
        // C s_286_1831: const #1u : u64
        let s_286_1831: u64 = 1;
        // C s_286_1832: cast zx s_286_1831 -> bv
        let s_286_1832: Bits = Bits::new(s_286_1831 as u128, 64u16);
        // C s_286_1833: lsl s_286_1832 s_286_1826
        let s_286_1833: Bits = s_286_1832 << s_286_1826;
        // C s_286_1834: sub s_286_1833 s_286_1832
        let s_286_1834: Bits = ((s_286_1833) - (s_286_1832));
        // C s_286_1835: and s_286_1830 s_286_1834
        let s_286_1835: Bits = ((s_286_1830) & (s_286_1834));
        // C s_286_1836: lsl s_286_1835 s_286_1827
        let s_286_1836: Bits = s_286_1835 << s_286_1827;
        // C s_286_1837: lsl s_286_1834 s_286_1827
        let s_286_1837: Bits = s_286_1834 << s_286_1827;
        // C s_286_1838: cmpl s_286_1837
        let s_286_1838: Bits = !s_286_1837;
        // D s_286_1839: and s_286_1828 s_286_1838
        let s_286_1839: Bits = ((s_286_1828) & (s_286_1838));
        // D s_286_1840: or s_286_1839 s_286_1836
        let s_286_1840: Bits = ((s_286_1839) | (s_286_1836));
        // D s_286_1841: cast reint s_286_1840 -> u32
        let s_286_1841: u32 = (s_286_1840.value() as u32);
        // D s_286_1842: call Mk_DBGDSCRint_Type(s_286_1841)
        let s_286_1842: ProductType700c18a878c5601b = Mk_DBGDSCRint_Type(
            state,
            tracer,
            s_286_1841,
        );
        // D s_286_1843: call DBGDSCRint_write(s_286_1842)
        let s_286_1843: () = DBGDSCRint_write(state, tracer, s_286_1842);
        // C s_286_1844: const #() : ()
        let s_286_1844: () = ();
        // S s_286_1845: call DBGDCCINT_read(s_286_1844)
        let s_286_1845: ProductType700c18a878c5601b = DBGDCCINT_read(
            state,
            tracer,
            s_286_1844,
        );
        // D s_286_1846: write-var ga#36384 <= s_286_1845
        fn_state.ga_36384 = s_286_1845;
        // D s_286_1847: read-var ga#36384.0:struct
        let s_286_1847: u32 = fn_state.ga_36384._0;
        // C s_286_1848: const #1s : i
        let s_286_1848: i128 = 1;
        // C s_286_1849: const #31s : i
        let s_286_1849: i128 = 31;
        // D s_286_1850: cast zx s_286_1847 -> bv
        let s_286_1850: Bits = Bits::new(s_286_1847 as u128, 32u16);
        // C s_286_1851: const #0u : u8
        let s_286_1851: bool = false;
        // C s_286_1852: cast zx s_286_1851 -> bv
        let s_286_1852: Bits = Bits::new(s_286_1851 as u128, 1u16);
        // C s_286_1853: const #1u : u64
        let s_286_1853: u64 = 1;
        // C s_286_1854: cast zx s_286_1853 -> bv
        let s_286_1854: Bits = Bits::new(s_286_1853 as u128, 64u16);
        // C s_286_1855: lsl s_286_1854 s_286_1848
        let s_286_1855: Bits = s_286_1854 << s_286_1848;
        // C s_286_1856: sub s_286_1855 s_286_1854
        let s_286_1856: Bits = ((s_286_1855) - (s_286_1854));
        // C s_286_1857: and s_286_1852 s_286_1856
        let s_286_1857: Bits = ((s_286_1852) & (s_286_1856));
        // C s_286_1858: lsl s_286_1857 s_286_1849
        let s_286_1858: Bits = s_286_1857 << s_286_1849;
        // C s_286_1859: lsl s_286_1856 s_286_1849
        let s_286_1859: Bits = s_286_1856 << s_286_1849;
        // C s_286_1860: cmpl s_286_1859
        let s_286_1860: Bits = !s_286_1859;
        // D s_286_1861: and s_286_1850 s_286_1860
        let s_286_1861: Bits = ((s_286_1850) & (s_286_1860));
        // D s_286_1862: or s_286_1861 s_286_1858
        let s_286_1862: Bits = ((s_286_1861) | (s_286_1858));
        // D s_286_1863: cast reint s_286_1862 -> u32
        let s_286_1863: u32 = (s_286_1862.value() as u32);
        // D s_286_1864: call Mk_DBGDCCINT_Type(s_286_1863)
        let s_286_1864: ProductType700c18a878c5601b = Mk_DBGDCCINT_Type(
            state,
            tracer,
            s_286_1863,
        );
        // D s_286_1865: call DBGDCCINT_write(s_286_1864)
        let s_286_1865: () = DBGDCCINT_write(state, tracer, s_286_1864);
        // C s_286_1866: const #() : ()
        let s_286_1866: () = ();
        // S s_286_1867: call DBGDCCINT_read(s_286_1866)
        let s_286_1867: ProductType700c18a878c5601b = DBGDCCINT_read(
            state,
            tracer,
            s_286_1866,
        );
        // C s_286_1868: const #0u : u8
        let s_286_1868: bool = false;
        // S s_286_1869: call _update_DBGDCCINT_Type_RX(s_286_1867, s_286_1868)
        let s_286_1869: ProductType700c18a878c5601b = u_update_DBGDCCINT_Type_RX(
            state,
            tracer,
            s_286_1867,
            s_286_1868,
        );
        // S s_286_1870: call DBGDCCINT_write(s_286_1869)
        let s_286_1870: () = DBGDCCINT_write(state, tracer, s_286_1869);
        // C s_286_1871: const #() : ()
        let s_286_1871: () = ();
        // S s_286_1872: call DBGDCCINT_read(s_286_1871)
        let s_286_1872: ProductType700c18a878c5601b = DBGDCCINT_read(
            state,
            tracer,
            s_286_1871,
        );
        // C s_286_1873: const #0u : u8
        let s_286_1873: bool = false;
        // S s_286_1874: call _update_DBGDCCINT_Type_TX(s_286_1872, s_286_1873)
        let s_286_1874: ProductType700c18a878c5601b = u_update_DBGDCCINT_Type_TX(
            state,
            tracer,
            s_286_1872,
            s_286_1873,
        );
        // S s_286_1875: call DBGDCCINT_write(s_286_1874)
        let s_286_1875: () = DBGDCCINT_write(state, tracer, s_286_1874);
        // C s_286_1876: const #() : ()
        let s_286_1876: () = ();
        // S s_286_1877: call DBGDCCINT_read(s_286_1876)
        let s_286_1877: ProductType700c18a878c5601b = DBGDCCINT_read(
            state,
            tracer,
            s_286_1876,
        );
        // D s_286_1878: write-var ga#36392 <= s_286_1877
        fn_state.ga_36392 = s_286_1877;
        // D s_286_1879: read-var ga#36392.0:struct
        let s_286_1879: u32 = fn_state.ga_36392._0;
        // C s_286_1880: const #29s : i
        let s_286_1880: i128 = 29;
        // C s_286_1881: const #0s : i
        let s_286_1881: i128 = 0;
        // D s_286_1882: cast zx s_286_1879 -> bv
        let s_286_1882: Bits = Bits::new(s_286_1879 as u128, 32u16);
        // C s_286_1883: const #0u : u29
        let s_286_1883: u32 = 0;
        // C s_286_1884: cast zx s_286_1883 -> bv
        let s_286_1884: Bits = Bits::new(s_286_1883 as u128, 29u16);
        // C s_286_1885: const #1u : u64
        let s_286_1885: u64 = 1;
        // C s_286_1886: cast zx s_286_1885 -> bv
        let s_286_1886: Bits = Bits::new(s_286_1885 as u128, 64u16);
        // C s_286_1887: lsl s_286_1886 s_286_1880
        let s_286_1887: Bits = s_286_1886 << s_286_1880;
        // C s_286_1888: sub s_286_1887 s_286_1886
        let s_286_1888: Bits = ((s_286_1887) - (s_286_1886));
        // C s_286_1889: and s_286_1884 s_286_1888
        let s_286_1889: Bits = ((s_286_1884) & (s_286_1888));
        // C s_286_1890: lsl s_286_1889 s_286_1881
        let s_286_1890: Bits = s_286_1889 << s_286_1881;
        // C s_286_1891: lsl s_286_1888 s_286_1881
        let s_286_1891: Bits = s_286_1888 << s_286_1881;
        // C s_286_1892: cmpl s_286_1891
        let s_286_1892: Bits = !s_286_1891;
        // D s_286_1893: and s_286_1882 s_286_1892
        let s_286_1893: Bits = ((s_286_1882) & (s_286_1892));
        // D s_286_1894: or s_286_1893 s_286_1890
        let s_286_1894: Bits = ((s_286_1893) | (s_286_1890));
        // D s_286_1895: cast reint s_286_1894 -> u32
        let s_286_1895: u32 = (s_286_1894.value() as u32);
        // D s_286_1896: call Mk_DBGDCCINT_Type(s_286_1895)
        let s_286_1896: ProductType700c18a878c5601b = Mk_DBGDCCINT_Type(
            state,
            tracer,
            s_286_1895,
        );
        // D s_286_1897: call DBGDCCINT_write(s_286_1896)
        let s_286_1897: () = DBGDCCINT_write(state, tracer, s_286_1896);
        // C s_286_1898: const #() : ()
        let s_286_1898: () = ();
        // S s_286_1899: call DBGDSCRext_read(s_286_1898)
        let s_286_1899: ProductType700c18a878c5601b = DBGDSCRext_read(
            state,
            tracer,
            s_286_1898,
        );
        // D s_286_1900: write-var ga#36396 <= s_286_1899
        fn_state.ga_36396 = s_286_1899;
        // D s_286_1901: read-var ga#36396.0:struct
        let s_286_1901: u32 = fn_state.ga_36396._0;
        // C s_286_1902: const #1s : i
        let s_286_1902: i128 = 1;
        // C s_286_1903: const #28s : i
        let s_286_1903: i128 = 28;
        // D s_286_1904: cast zx s_286_1901 -> bv
        let s_286_1904: Bits = Bits::new(s_286_1901 as u128, 32u16);
        // C s_286_1905: const #0u : u8
        let s_286_1905: bool = false;
        // C s_286_1906: cast zx s_286_1905 -> bv
        let s_286_1906: Bits = Bits::new(s_286_1905 as u128, 1u16);
        // C s_286_1907: const #1u : u64
        let s_286_1907: u64 = 1;
        // C s_286_1908: cast zx s_286_1907 -> bv
        let s_286_1908: Bits = Bits::new(s_286_1907 as u128, 64u16);
        // C s_286_1909: lsl s_286_1908 s_286_1902
        let s_286_1909: Bits = s_286_1908 << s_286_1902;
        // C s_286_1910: sub s_286_1909 s_286_1908
        let s_286_1910: Bits = ((s_286_1909) - (s_286_1908));
        // C s_286_1911: and s_286_1906 s_286_1910
        let s_286_1911: Bits = ((s_286_1906) & (s_286_1910));
        // C s_286_1912: lsl s_286_1911 s_286_1903
        let s_286_1912: Bits = s_286_1911 << s_286_1903;
        // C s_286_1913: lsl s_286_1910 s_286_1903
        let s_286_1913: Bits = s_286_1910 << s_286_1903;
        // C s_286_1914: cmpl s_286_1913
        let s_286_1914: Bits = !s_286_1913;
        // D s_286_1915: and s_286_1904 s_286_1914
        let s_286_1915: Bits = ((s_286_1904) & (s_286_1914));
        // D s_286_1916: or s_286_1915 s_286_1912
        let s_286_1916: Bits = ((s_286_1915) | (s_286_1912));
        // D s_286_1917: cast reint s_286_1916 -> u32
        let s_286_1917: u32 = (s_286_1916.value() as u32);
        // D s_286_1918: call Mk_DBGDSCRext_Type(s_286_1917)
        let s_286_1918: ProductType700c18a878c5601b = Mk_DBGDSCRext_Type(
            state,
            tracer,
            s_286_1917,
        );
        // D s_286_1919: call DBGDSCRext_write(s_286_1918)
        let s_286_1919: () = DBGDSCRext_write(state, tracer, s_286_1918);
        // C s_286_1920: const #() : ()
        let s_286_1920: () = ();
        // S s_286_1921: call DBGDSCRext_read(s_286_1920)
        let s_286_1921: ProductType700c18a878c5601b = DBGDSCRext_read(
            state,
            tracer,
            s_286_1920,
        );
        // D s_286_1922: write-var ga#36400 <= s_286_1921
        fn_state.ga_36400 = s_286_1921;
        // D s_286_1923: read-var ga#36400.0:struct
        let s_286_1923: u32 = fn_state.ga_36400._0;
        // C s_286_1924: const #2s : i
        let s_286_1924: i128 = 2;
        // C s_286_1925: const #24s : i
        let s_286_1925: i128 = 24;
        // D s_286_1926: cast zx s_286_1923 -> bv
        let s_286_1926: Bits = Bits::new(s_286_1923 as u128, 32u16);
        // C s_286_1927: const #0u : u8
        let s_286_1927: u8 = 0;
        // C s_286_1928: cast zx s_286_1927 -> bv
        let s_286_1928: Bits = Bits::new(s_286_1927 as u128, 2u16);
        // C s_286_1929: const #1u : u64
        let s_286_1929: u64 = 1;
        // C s_286_1930: cast zx s_286_1929 -> bv
        let s_286_1930: Bits = Bits::new(s_286_1929 as u128, 64u16);
        // C s_286_1931: lsl s_286_1930 s_286_1924
        let s_286_1931: Bits = s_286_1930 << s_286_1924;
        // C s_286_1932: sub s_286_1931 s_286_1930
        let s_286_1932: Bits = ((s_286_1931) - (s_286_1930));
        // C s_286_1933: and s_286_1928 s_286_1932
        let s_286_1933: Bits = ((s_286_1928) & (s_286_1932));
        // C s_286_1934: lsl s_286_1933 s_286_1925
        let s_286_1934: Bits = s_286_1933 << s_286_1925;
        // C s_286_1935: lsl s_286_1932 s_286_1925
        let s_286_1935: Bits = s_286_1932 << s_286_1925;
        // C s_286_1936: cmpl s_286_1935
        let s_286_1936: Bits = !s_286_1935;
        // D s_286_1937: and s_286_1926 s_286_1936
        let s_286_1937: Bits = ((s_286_1926) & (s_286_1936));
        // D s_286_1938: or s_286_1937 s_286_1934
        let s_286_1938: Bits = ((s_286_1937) | (s_286_1934));
        // D s_286_1939: cast reint s_286_1938 -> u32
        let s_286_1939: u32 = (s_286_1938.value() as u32);
        // D s_286_1940: call Mk_DBGDSCRext_Type(s_286_1939)
        let s_286_1940: ProductType700c18a878c5601b = Mk_DBGDSCRext_Type(
            state,
            tracer,
            s_286_1939,
        );
        // D s_286_1941: call DBGDSCRext_write(s_286_1940)
        let s_286_1941: () = DBGDSCRext_write(state, tracer, s_286_1940);
        // C s_286_1942: const #() : ()
        let s_286_1942: () = ();
        // S s_286_1943: call DBGDSCRext_read(s_286_1942)
        let s_286_1943: ProductType700c18a878c5601b = DBGDSCRext_read(
            state,
            tracer,
            s_286_1942,
        );
        // D s_286_1944: write-var ga#36404 <= s_286_1943
        fn_state.ga_36404 = s_286_1943;
        // D s_286_1945: read-var ga#36404.0:struct
        let s_286_1945: u32 = fn_state.ga_36404._0;
        // C s_286_1946: const #1s : i
        let s_286_1946: i128 = 1;
        // C s_286_1947: const #20s : i
        let s_286_1947: i128 = 20;
        // D s_286_1948: cast zx s_286_1945 -> bv
        let s_286_1948: Bits = Bits::new(s_286_1945 as u128, 32u16);
        // C s_286_1949: const #0u : u8
        let s_286_1949: bool = false;
        // C s_286_1950: cast zx s_286_1949 -> bv
        let s_286_1950: Bits = Bits::new(s_286_1949 as u128, 1u16);
        // C s_286_1951: const #1u : u64
        let s_286_1951: u64 = 1;
        // C s_286_1952: cast zx s_286_1951 -> bv
        let s_286_1952: Bits = Bits::new(s_286_1951 as u128, 64u16);
        // C s_286_1953: lsl s_286_1952 s_286_1946
        let s_286_1953: Bits = s_286_1952 << s_286_1946;
        // C s_286_1954: sub s_286_1953 s_286_1952
        let s_286_1954: Bits = ((s_286_1953) - (s_286_1952));
        // C s_286_1955: and s_286_1950 s_286_1954
        let s_286_1955: Bits = ((s_286_1950) & (s_286_1954));
        // C s_286_1956: lsl s_286_1955 s_286_1947
        let s_286_1956: Bits = s_286_1955 << s_286_1947;
        // C s_286_1957: lsl s_286_1954 s_286_1947
        let s_286_1957: Bits = s_286_1954 << s_286_1947;
        // C s_286_1958: cmpl s_286_1957
        let s_286_1958: Bits = !s_286_1957;
        // D s_286_1959: and s_286_1948 s_286_1958
        let s_286_1959: Bits = ((s_286_1948) & (s_286_1958));
        // D s_286_1960: or s_286_1959 s_286_1956
        let s_286_1960: Bits = ((s_286_1959) | (s_286_1956));
        // D s_286_1961: cast reint s_286_1960 -> u32
        let s_286_1961: u32 = (s_286_1960.value() as u32);
        // D s_286_1962: call Mk_DBGDSCRext_Type(s_286_1961)
        let s_286_1962: ProductType700c18a878c5601b = Mk_DBGDSCRext_Type(
            state,
            tracer,
            s_286_1961,
        );
        // D s_286_1963: call DBGDSCRext_write(s_286_1962)
        let s_286_1963: () = DBGDSCRext_write(state, tracer, s_286_1962);
        // C s_286_1964: const #() : ()
        let s_286_1964: () = ();
        // S s_286_1965: call DBGDSCRext_read(s_286_1964)
        let s_286_1965: ProductType700c18a878c5601b = DBGDSCRext_read(
            state,
            tracer,
            s_286_1964,
        );
        // C s_286_1966: const #0u : u8
        let s_286_1966: bool = false;
        // S s_286_1967: call _update_DBGDSCRext_Type_MDBGen(s_286_1965, s_286_1966)
        let s_286_1967: ProductType700c18a878c5601b = u_update_DBGDSCRext_Type_MDBGen(
            state,
            tracer,
            s_286_1965,
            s_286_1966,
        );
        // S s_286_1968: call DBGDSCRext_write(s_286_1967)
        let s_286_1968: () = DBGDSCRext_write(state, tracer, s_286_1967);
        // C s_286_1969: const #() : ()
        let s_286_1969: () = ();
        // S s_286_1970: call DBGDSCRext_read(s_286_1969)
        let s_286_1970: ProductType700c18a878c5601b = DBGDSCRext_read(
            state,
            tracer,
            s_286_1969,
        );
        // D s_286_1971: write-var ga#36410 <= s_286_1970
        fn_state.ga_36410 = s_286_1970;
        // D s_286_1972: read-var ga#36410.0:struct
        let s_286_1972: u32 = fn_state.ga_36410._0;
        // C s_286_1973: const #1s : i
        let s_286_1973: i128 = 1;
        // C s_286_1974: const #13s : i
        let s_286_1974: i128 = 13;
        // D s_286_1975: cast zx s_286_1972 -> bv
        let s_286_1975: Bits = Bits::new(s_286_1972 as u128, 32u16);
        // C s_286_1976: const #0u : u8
        let s_286_1976: bool = false;
        // C s_286_1977: cast zx s_286_1976 -> bv
        let s_286_1977: Bits = Bits::new(s_286_1976 as u128, 1u16);
        // C s_286_1978: const #1u : u64
        let s_286_1978: u64 = 1;
        // C s_286_1979: cast zx s_286_1978 -> bv
        let s_286_1979: Bits = Bits::new(s_286_1978 as u128, 64u16);
        // C s_286_1980: lsl s_286_1979 s_286_1973
        let s_286_1980: Bits = s_286_1979 << s_286_1973;
        // C s_286_1981: sub s_286_1980 s_286_1979
        let s_286_1981: Bits = ((s_286_1980) - (s_286_1979));
        // C s_286_1982: and s_286_1977 s_286_1981
        let s_286_1982: Bits = ((s_286_1977) & (s_286_1981));
        // C s_286_1983: lsl s_286_1982 s_286_1974
        let s_286_1983: Bits = s_286_1982 << s_286_1974;
        // C s_286_1984: lsl s_286_1981 s_286_1974
        let s_286_1984: Bits = s_286_1981 << s_286_1974;
        // C s_286_1985: cmpl s_286_1984
        let s_286_1985: Bits = !s_286_1984;
        // D s_286_1986: and s_286_1975 s_286_1985
        let s_286_1986: Bits = ((s_286_1975) & (s_286_1985));
        // D s_286_1987: or s_286_1986 s_286_1983
        let s_286_1987: Bits = ((s_286_1986) | (s_286_1983));
        // D s_286_1988: cast reint s_286_1987 -> u32
        let s_286_1988: u32 = (s_286_1987.value() as u32);
        // D s_286_1989: call Mk_DBGDSCRext_Type(s_286_1988)
        let s_286_1989: ProductType700c18a878c5601b = Mk_DBGDSCRext_Type(
            state,
            tracer,
            s_286_1988,
        );
        // D s_286_1990: call DBGDSCRext_write(s_286_1989)
        let s_286_1990: () = DBGDSCRext_write(state, tracer, s_286_1989);
        // C s_286_1991: const #() : ()
        let s_286_1991: () = ();
        // S s_286_1992: call DBGDSCRext_read(s_286_1991)
        let s_286_1992: ProductType700c18a878c5601b = DBGDSCRext_read(
            state,
            tracer,
            s_286_1991,
        );
        // C s_286_1993: const #0u : u8
        let s_286_1993: bool = false;
        // S s_286_1994: call _update_DBGDSCRext_Type_UDCCdis(s_286_1992, s_286_1993)
        let s_286_1994: ProductType700c18a878c5601b = u_update_DBGDSCRext_Type_UDCCdis(
            state,
            tracer,
            s_286_1992,
            s_286_1993,
        );
        // S s_286_1995: call DBGDSCRext_write(s_286_1994)
        let s_286_1995: () = DBGDSCRext_write(state, tracer, s_286_1994);
        // C s_286_1996: const #() : ()
        let s_286_1996: () = ();
        // S s_286_1997: call DBGDSCRext_read(s_286_1996)
        let s_286_1997: ProductType700c18a878c5601b = DBGDSCRext_read(
            state,
            tracer,
            s_286_1996,
        );
        // D s_286_1998: write-var ga#36416 <= s_286_1997
        fn_state.ga_36416 = s_286_1997;
        // D s_286_1999: read-var ga#36416.0:struct
        let s_286_1999: u32 = fn_state.ga_36416._0;
        // C s_286_2000: const #5s : i
        let s_286_2000: i128 = 5;
        // C s_286_2001: const #7s : i
        let s_286_2001: i128 = 7;
        // D s_286_2002: cast zx s_286_1999 -> bv
        let s_286_2002: Bits = Bits::new(s_286_1999 as u128, 32u16);
        // C s_286_2003: const #0u : u8
        let s_286_2003: u8 = 0;
        // C s_286_2004: cast zx s_286_2003 -> bv
        let s_286_2004: Bits = Bits::new(s_286_2003 as u128, 5u16);
        // C s_286_2005: const #1u : u64
        let s_286_2005: u64 = 1;
        // C s_286_2006: cast zx s_286_2005 -> bv
        let s_286_2006: Bits = Bits::new(s_286_2005 as u128, 64u16);
        // C s_286_2007: lsl s_286_2006 s_286_2000
        let s_286_2007: Bits = s_286_2006 << s_286_2000;
        // C s_286_2008: sub s_286_2007 s_286_2006
        let s_286_2008: Bits = ((s_286_2007) - (s_286_2006));
        // C s_286_2009: and s_286_2004 s_286_2008
        let s_286_2009: Bits = ((s_286_2004) & (s_286_2008));
        // C s_286_2010: lsl s_286_2009 s_286_2001
        let s_286_2010: Bits = s_286_2009 << s_286_2001;
        // C s_286_2011: lsl s_286_2008 s_286_2001
        let s_286_2011: Bits = s_286_2008 << s_286_2001;
        // C s_286_2012: cmpl s_286_2011
        let s_286_2012: Bits = !s_286_2011;
        // D s_286_2013: and s_286_2002 s_286_2012
        let s_286_2013: Bits = ((s_286_2002) & (s_286_2012));
        // D s_286_2014: or s_286_2013 s_286_2010
        let s_286_2014: Bits = ((s_286_2013) | (s_286_2010));
        // D s_286_2015: cast reint s_286_2014 -> u32
        let s_286_2015: u32 = (s_286_2014.value() as u32);
        // D s_286_2016: call Mk_DBGDSCRext_Type(s_286_2015)
        let s_286_2016: ProductType700c18a878c5601b = Mk_DBGDSCRext_Type(
            state,
            tracer,
            s_286_2015,
        );
        // D s_286_2017: call DBGDSCRext_write(s_286_2016)
        let s_286_2017: () = DBGDSCRext_write(state, tracer, s_286_2016);
        // C s_286_2018: const #() : ()
        let s_286_2018: () = ();
        // S s_286_2019: call DBGDSCRext_read(s_286_2018)
        let s_286_2019: ProductType700c18a878c5601b = DBGDSCRext_read(
            state,
            tracer,
            s_286_2018,
        );
        // D s_286_2020: write-var ga#36420 <= s_286_2019
        fn_state.ga_36420 = s_286_2019;
        // D s_286_2021: read-var ga#36420.0:struct
        let s_286_2021: u32 = fn_state.ga_36420._0;
        // C s_286_2022: const #2s : i
        let s_286_2022: i128 = 2;
        // C s_286_2023: const #0s : i
        let s_286_2023: i128 = 0;
        // D s_286_2024: cast zx s_286_2021 -> bv
        let s_286_2024: Bits = Bits::new(s_286_2021 as u128, 32u16);
        // C s_286_2025: const #0u : u8
        let s_286_2025: u8 = 0;
        // C s_286_2026: cast zx s_286_2025 -> bv
        let s_286_2026: Bits = Bits::new(s_286_2025 as u128, 2u16);
        // C s_286_2027: const #1u : u64
        let s_286_2027: u64 = 1;
        // C s_286_2028: cast zx s_286_2027 -> bv
        let s_286_2028: Bits = Bits::new(s_286_2027 as u128, 64u16);
        // C s_286_2029: lsl s_286_2028 s_286_2022
        let s_286_2029: Bits = s_286_2028 << s_286_2022;
        // C s_286_2030: sub s_286_2029 s_286_2028
        let s_286_2030: Bits = ((s_286_2029) - (s_286_2028));
        // C s_286_2031: and s_286_2026 s_286_2030
        let s_286_2031: Bits = ((s_286_2026) & (s_286_2030));
        // C s_286_2032: lsl s_286_2031 s_286_2023
        let s_286_2032: Bits = s_286_2031 << s_286_2023;
        // C s_286_2033: lsl s_286_2030 s_286_2023
        let s_286_2033: Bits = s_286_2030 << s_286_2023;
        // C s_286_2034: cmpl s_286_2033
        let s_286_2034: Bits = !s_286_2033;
        // D s_286_2035: and s_286_2024 s_286_2034
        let s_286_2035: Bits = ((s_286_2024) & (s_286_2034));
        // D s_286_2036: or s_286_2035 s_286_2032
        let s_286_2036: Bits = ((s_286_2035) | (s_286_2032));
        // D s_286_2037: cast reint s_286_2036 -> u32
        let s_286_2037: u32 = (s_286_2036.value() as u32);
        // D s_286_2038: call Mk_DBGDSCRext_Type(s_286_2037)
        let s_286_2038: ProductType700c18a878c5601b = Mk_DBGDSCRext_Type(
            state,
            tracer,
            s_286_2037,
        );
        // D s_286_2039: call DBGDSCRext_write(s_286_2038)
        let s_286_2039: () = DBGDSCRext_write(state, tracer, s_286_2038);
        // C s_286_2040: const #() : ()
        let s_286_2040: () = ();
        // S s_286_2041: call IFSR_read(s_286_2040)
        let s_286_2041: ProductType700c18a878c5601b = IFSR_read(
            state,
            tracer,
            s_286_2040,
        );
        // D s_286_2042: write-var ga#36424 <= s_286_2041
        fn_state.ga_36424 = s_286_2041;
        // D s_286_2043: read-var ga#36424.0:struct
        let s_286_2043: u32 = fn_state.ga_36424._0;
        // C s_286_2044: const #15s : i
        let s_286_2044: i128 = 15;
        // C s_286_2045: const #17s : i
        let s_286_2045: i128 = 17;
        // D s_286_2046: cast zx s_286_2043 -> bv
        let s_286_2046: Bits = Bits::new(s_286_2043 as u128, 32u16);
        // C s_286_2047: const #0u : u15
        let s_286_2047: u16 = 0;
        // C s_286_2048: cast zx s_286_2047 -> bv
        let s_286_2048: Bits = Bits::new(s_286_2047 as u128, 15u16);
        // C s_286_2049: const #1u : u64
        let s_286_2049: u64 = 1;
        // C s_286_2050: cast zx s_286_2049 -> bv
        let s_286_2050: Bits = Bits::new(s_286_2049 as u128, 64u16);
        // C s_286_2051: lsl s_286_2050 s_286_2044
        let s_286_2051: Bits = s_286_2050 << s_286_2044;
        // C s_286_2052: sub s_286_2051 s_286_2050
        let s_286_2052: Bits = ((s_286_2051) - (s_286_2050));
        // C s_286_2053: and s_286_2048 s_286_2052
        let s_286_2053: Bits = ((s_286_2048) & (s_286_2052));
        // C s_286_2054: lsl s_286_2053 s_286_2045
        let s_286_2054: Bits = s_286_2053 << s_286_2045;
        // C s_286_2055: lsl s_286_2052 s_286_2045
        let s_286_2055: Bits = s_286_2052 << s_286_2045;
        // C s_286_2056: cmpl s_286_2055
        let s_286_2056: Bits = !s_286_2055;
        // D s_286_2057: and s_286_2046 s_286_2056
        let s_286_2057: Bits = ((s_286_2046) & (s_286_2056));
        // D s_286_2058: or s_286_2057 s_286_2054
        let s_286_2058: Bits = ((s_286_2057) | (s_286_2054));
        // D s_286_2059: cast reint s_286_2058 -> u32
        let s_286_2059: u32 = (s_286_2058.value() as u32);
        // D s_286_2060: call Mk_IFSR_Type(s_286_2059)
        let s_286_2060: ProductType700c18a878c5601b = Mk_IFSR_Type(
            state,
            tracer,
            s_286_2059,
        );
        // D s_286_2061: call IFSR_write(s_286_2060)
        let s_286_2061: () = IFSR_write(state, tracer, s_286_2060);
        // C s_286_2062: const #() : ()
        let s_286_2062: () = ();
        // S s_286_2063: call IFSR_read(s_286_2062)
        let s_286_2063: ProductType700c18a878c5601b = IFSR_read(
            state,
            tracer,
            s_286_2062,
        );
        // D s_286_2064: write-var ga#36428 <= s_286_2063
        fn_state.ga_36428 = s_286_2063;
        // D s_286_2065: read-var ga#36428.0:struct
        let s_286_2065: u32 = fn_state.ga_36428._0;
        // C s_286_2066: const #3s : i
        let s_286_2066: i128 = 3;
        // C s_286_2067: const #13s : i
        let s_286_2067: i128 = 13;
        // D s_286_2068: cast zx s_286_2065 -> bv
        let s_286_2068: Bits = Bits::new(s_286_2065 as u128, 32u16);
        // C s_286_2069: const #0u : u8
        let s_286_2069: u8 = 0;
        // C s_286_2070: cast zx s_286_2069 -> bv
        let s_286_2070: Bits = Bits::new(s_286_2069 as u128, 3u16);
        // C s_286_2071: const #1u : u64
        let s_286_2071: u64 = 1;
        // C s_286_2072: cast zx s_286_2071 -> bv
        let s_286_2072: Bits = Bits::new(s_286_2071 as u128, 64u16);
        // C s_286_2073: lsl s_286_2072 s_286_2066
        let s_286_2073: Bits = s_286_2072 << s_286_2066;
        // C s_286_2074: sub s_286_2073 s_286_2072
        let s_286_2074: Bits = ((s_286_2073) - (s_286_2072));
        // C s_286_2075: and s_286_2070 s_286_2074
        let s_286_2075: Bits = ((s_286_2070) & (s_286_2074));
        // C s_286_2076: lsl s_286_2075 s_286_2067
        let s_286_2076: Bits = s_286_2075 << s_286_2067;
        // C s_286_2077: lsl s_286_2074 s_286_2067
        let s_286_2077: Bits = s_286_2074 << s_286_2067;
        // C s_286_2078: cmpl s_286_2077
        let s_286_2078: Bits = !s_286_2077;
        // D s_286_2079: and s_286_2068 s_286_2078
        let s_286_2079: Bits = ((s_286_2068) & (s_286_2078));
        // D s_286_2080: or s_286_2079 s_286_2076
        let s_286_2080: Bits = ((s_286_2079) | (s_286_2076));
        // D s_286_2081: cast reint s_286_2080 -> u32
        let s_286_2081: u32 = (s_286_2080.value() as u32);
        // D s_286_2082: call Mk_IFSR_Type(s_286_2081)
        let s_286_2082: ProductType700c18a878c5601b = Mk_IFSR_Type(
            state,
            tracer,
            s_286_2081,
        );
        // D s_286_2083: call IFSR_write(s_286_2082)
        let s_286_2083: () = IFSR_write(state, tracer, s_286_2082);
        // C s_286_2084: const #() : ()
        let s_286_2084: () = ();
        // S s_286_2085: call IFSR_read(s_286_2084)
        let s_286_2085: ProductType700c18a878c5601b = IFSR_read(
            state,
            tracer,
            s_286_2084,
        );
        // D s_286_2086: write-var ga#36432 <= s_286_2085
        fn_state.ga_36432 = s_286_2085;
        // D s_286_2087: read-var ga#36432.0:struct
        let s_286_2087: u32 = fn_state.ga_36432._0;
        // C s_286_2088: const #1s : i
        let s_286_2088: i128 = 1;
        // C s_286_2089: const #11s : i
        let s_286_2089: i128 = 11;
        // D s_286_2090: cast zx s_286_2087 -> bv
        let s_286_2090: Bits = Bits::new(s_286_2087 as u128, 32u16);
        // C s_286_2091: const #0u : u8
        let s_286_2091: bool = false;
        // C s_286_2092: cast zx s_286_2091 -> bv
        let s_286_2092: Bits = Bits::new(s_286_2091 as u128, 1u16);
        // C s_286_2093: const #1u : u64
        let s_286_2093: u64 = 1;
        // C s_286_2094: cast zx s_286_2093 -> bv
        let s_286_2094: Bits = Bits::new(s_286_2093 as u128, 64u16);
        // C s_286_2095: lsl s_286_2094 s_286_2088
        let s_286_2095: Bits = s_286_2094 << s_286_2088;
        // C s_286_2096: sub s_286_2095 s_286_2094
        let s_286_2096: Bits = ((s_286_2095) - (s_286_2094));
        // C s_286_2097: and s_286_2092 s_286_2096
        let s_286_2097: Bits = ((s_286_2092) & (s_286_2096));
        // C s_286_2098: lsl s_286_2097 s_286_2089
        let s_286_2098: Bits = s_286_2097 << s_286_2089;
        // C s_286_2099: lsl s_286_2096 s_286_2089
        let s_286_2099: Bits = s_286_2096 << s_286_2089;
        // C s_286_2100: cmpl s_286_2099
        let s_286_2100: Bits = !s_286_2099;
        // D s_286_2101: and s_286_2090 s_286_2100
        let s_286_2101: Bits = ((s_286_2090) & (s_286_2100));
        // D s_286_2102: or s_286_2101 s_286_2098
        let s_286_2102: Bits = ((s_286_2101) | (s_286_2098));
        // D s_286_2103: cast reint s_286_2102 -> u32
        let s_286_2103: u32 = (s_286_2102.value() as u32);
        // D s_286_2104: call Mk_IFSR_Type(s_286_2103)
        let s_286_2104: ProductType700c18a878c5601b = Mk_IFSR_Type(
            state,
            tracer,
            s_286_2103,
        );
        // D s_286_2105: call IFSR_write(s_286_2104)
        let s_286_2105: () = IFSR_write(state, tracer, s_286_2104);
        // C s_286_2106: const #() : ()
        let s_286_2106: () = ();
        // S s_286_2107: call IFSR_read(s_286_2106)
        let s_286_2107: ProductType700c18a878c5601b = IFSR_read(
            state,
            tracer,
            s_286_2106,
        );
        // D s_286_2108: write-var ga#36436 <= s_286_2107
        fn_state.ga_36436 = s_286_2107;
        // D s_286_2109: read-var ga#36436.0:struct
        let s_286_2109: u32 = fn_state.ga_36436._0;
        // C s_286_2110: const #5s : i
        let s_286_2110: i128 = 5;
        // C s_286_2111: const #4s : i
        let s_286_2111: i128 = 4;
        // D s_286_2112: cast zx s_286_2109 -> bv
        let s_286_2112: Bits = Bits::new(s_286_2109 as u128, 32u16);
        // C s_286_2113: const #0u : u8
        let s_286_2113: u8 = 0;
        // C s_286_2114: cast zx s_286_2113 -> bv
        let s_286_2114: Bits = Bits::new(s_286_2113 as u128, 5u16);
        // C s_286_2115: const #1u : u64
        let s_286_2115: u64 = 1;
        // C s_286_2116: cast zx s_286_2115 -> bv
        let s_286_2116: Bits = Bits::new(s_286_2115 as u128, 64u16);
        // C s_286_2117: lsl s_286_2116 s_286_2110
        let s_286_2117: Bits = s_286_2116 << s_286_2110;
        // C s_286_2118: sub s_286_2117 s_286_2116
        let s_286_2118: Bits = ((s_286_2117) - (s_286_2116));
        // C s_286_2119: and s_286_2114 s_286_2118
        let s_286_2119: Bits = ((s_286_2114) & (s_286_2118));
        // C s_286_2120: lsl s_286_2119 s_286_2111
        let s_286_2120: Bits = s_286_2119 << s_286_2111;
        // C s_286_2121: lsl s_286_2118 s_286_2111
        let s_286_2121: Bits = s_286_2118 << s_286_2111;
        // C s_286_2122: cmpl s_286_2121
        let s_286_2122: Bits = !s_286_2121;
        // D s_286_2123: and s_286_2112 s_286_2122
        let s_286_2123: Bits = ((s_286_2112) & (s_286_2122));
        // D s_286_2124: or s_286_2123 s_286_2120
        let s_286_2124: Bits = ((s_286_2123) | (s_286_2120));
        // D s_286_2125: cast reint s_286_2124 -> u32
        let s_286_2125: u32 = (s_286_2124.value() as u32);
        // D s_286_2126: call Mk_IFSR_Type(s_286_2125)
        let s_286_2126: ProductType700c18a878c5601b = Mk_IFSR_Type(
            state,
            tracer,
            s_286_2125,
        );
        // D s_286_2127: call IFSR_write(s_286_2126)
        let s_286_2127: () = IFSR_write(state, tracer, s_286_2126);
        // C s_286_2128: const #() : ()
        let s_286_2128: () = ();
        // S s_286_2129: call IFSR_read(s_286_2128)
        let s_286_2129: ProductType700c18a878c5601b = IFSR_read(
            state,
            tracer,
            s_286_2128,
        );
        // D s_286_2130: write-var ga#36440 <= s_286_2129
        fn_state.ga_36440 = s_286_2129;
        // D s_286_2131: read-var ga#36440.0:struct
        let s_286_2131: u32 = fn_state.ga_36440._0;
        // C s_286_2132: const #15s : i
        let s_286_2132: i128 = 15;
        // C s_286_2133: const #17s : i
        let s_286_2133: i128 = 17;
        // D s_286_2134: cast zx s_286_2131 -> bv
        let s_286_2134: Bits = Bits::new(s_286_2131 as u128, 32u16);
        // C s_286_2135: const #0u : u15
        let s_286_2135: u16 = 0;
        // C s_286_2136: cast zx s_286_2135 -> bv
        let s_286_2136: Bits = Bits::new(s_286_2135 as u128, 15u16);
        // C s_286_2137: const #1u : u64
        let s_286_2137: u64 = 1;
        // C s_286_2138: cast zx s_286_2137 -> bv
        let s_286_2138: Bits = Bits::new(s_286_2137 as u128, 64u16);
        // C s_286_2139: lsl s_286_2138 s_286_2132
        let s_286_2139: Bits = s_286_2138 << s_286_2132;
        // C s_286_2140: sub s_286_2139 s_286_2138
        let s_286_2140: Bits = ((s_286_2139) - (s_286_2138));
        // C s_286_2141: and s_286_2136 s_286_2140
        let s_286_2141: Bits = ((s_286_2136) & (s_286_2140));
        // C s_286_2142: lsl s_286_2141 s_286_2133
        let s_286_2142: Bits = s_286_2141 << s_286_2133;
        // C s_286_2143: lsl s_286_2140 s_286_2133
        let s_286_2143: Bits = s_286_2140 << s_286_2133;
        // C s_286_2144: cmpl s_286_2143
        let s_286_2144: Bits = !s_286_2143;
        // D s_286_2145: and s_286_2134 s_286_2144
        let s_286_2145: Bits = ((s_286_2134) & (s_286_2144));
        // D s_286_2146: or s_286_2145 s_286_2142
        let s_286_2146: Bits = ((s_286_2145) | (s_286_2142));
        // D s_286_2147: cast reint s_286_2146 -> u32
        let s_286_2147: u32 = (s_286_2146.value() as u32);
        // D s_286_2148: call Mk_IFSR_Type(s_286_2147)
        let s_286_2148: ProductType700c18a878c5601b = Mk_IFSR_Type(
            state,
            tracer,
            s_286_2147,
        );
        // D s_286_2149: call IFSR_write(s_286_2148)
        let s_286_2149: () = IFSR_write(state, tracer, s_286_2148);
        // C s_286_2150: const #() : ()
        let s_286_2150: () = ();
        // S s_286_2151: call IFSR_read(s_286_2150)
        let s_286_2151: ProductType700c18a878c5601b = IFSR_read(
            state,
            tracer,
            s_286_2150,
        );
        // D s_286_2152: write-var ga#36444 <= s_286_2151
        fn_state.ga_36444 = s_286_2151;
        // D s_286_2153: read-var ga#36444.0:struct
        let s_286_2153: u32 = fn_state.ga_36444._0;
        // C s_286_2154: const #3s : i
        let s_286_2154: i128 = 3;
        // C s_286_2155: const #13s : i
        let s_286_2155: i128 = 13;
        // D s_286_2156: cast zx s_286_2153 -> bv
        let s_286_2156: Bits = Bits::new(s_286_2153 as u128, 32u16);
        // C s_286_2157: const #0u : u8
        let s_286_2157: u8 = 0;
        // C s_286_2158: cast zx s_286_2157 -> bv
        let s_286_2158: Bits = Bits::new(s_286_2157 as u128, 3u16);
        // C s_286_2159: const #1u : u64
        let s_286_2159: u64 = 1;
        // C s_286_2160: cast zx s_286_2159 -> bv
        let s_286_2160: Bits = Bits::new(s_286_2159 as u128, 64u16);
        // C s_286_2161: lsl s_286_2160 s_286_2154
        let s_286_2161: Bits = s_286_2160 << s_286_2154;
        // C s_286_2162: sub s_286_2161 s_286_2160
        let s_286_2162: Bits = ((s_286_2161) - (s_286_2160));
        // C s_286_2163: and s_286_2158 s_286_2162
        let s_286_2163: Bits = ((s_286_2158) & (s_286_2162));
        // C s_286_2164: lsl s_286_2163 s_286_2155
        let s_286_2164: Bits = s_286_2163 << s_286_2155;
        // C s_286_2165: lsl s_286_2162 s_286_2155
        let s_286_2165: Bits = s_286_2162 << s_286_2155;
        // C s_286_2166: cmpl s_286_2165
        let s_286_2166: Bits = !s_286_2165;
        // D s_286_2167: and s_286_2156 s_286_2166
        let s_286_2167: Bits = ((s_286_2156) & (s_286_2166));
        // D s_286_2168: or s_286_2167 s_286_2164
        let s_286_2168: Bits = ((s_286_2167) | (s_286_2164));
        // D s_286_2169: cast reint s_286_2168 -> u32
        let s_286_2169: u32 = (s_286_2168.value() as u32);
        // D s_286_2170: call Mk_IFSR_Type(s_286_2169)
        let s_286_2170: ProductType700c18a878c5601b = Mk_IFSR_Type(
            state,
            tracer,
            s_286_2169,
        );
        // D s_286_2171: call IFSR_write(s_286_2170)
        let s_286_2171: () = IFSR_write(state, tracer, s_286_2170);
        // C s_286_2172: const #() : ()
        let s_286_2172: () = ();
        // S s_286_2173: call IFSR_read(s_286_2172)
        let s_286_2173: ProductType700c18a878c5601b = IFSR_read(
            state,
            tracer,
            s_286_2172,
        );
        // D s_286_2174: write-var ga#36448 <= s_286_2173
        fn_state.ga_36448 = s_286_2173;
        // D s_286_2175: read-var ga#36448.0:struct
        let s_286_2175: u32 = fn_state.ga_36448._0;
        // C s_286_2176: const #2s : i
        let s_286_2176: i128 = 2;
        // C s_286_2177: const #10s : i
        let s_286_2177: i128 = 10;
        // D s_286_2178: cast zx s_286_2175 -> bv
        let s_286_2178: Bits = Bits::new(s_286_2175 as u128, 32u16);
        // C s_286_2179: const #0u : u8
        let s_286_2179: u8 = 0;
        // C s_286_2180: cast zx s_286_2179 -> bv
        let s_286_2180: Bits = Bits::new(s_286_2179 as u128, 2u16);
        // C s_286_2181: const #1u : u64
        let s_286_2181: u64 = 1;
        // C s_286_2182: cast zx s_286_2181 -> bv
        let s_286_2182: Bits = Bits::new(s_286_2181 as u128, 64u16);
        // C s_286_2183: lsl s_286_2182 s_286_2176
        let s_286_2183: Bits = s_286_2182 << s_286_2176;
        // C s_286_2184: sub s_286_2183 s_286_2182
        let s_286_2184: Bits = ((s_286_2183) - (s_286_2182));
        // C s_286_2185: and s_286_2180 s_286_2184
        let s_286_2185: Bits = ((s_286_2180) & (s_286_2184));
        // C s_286_2186: lsl s_286_2185 s_286_2177
        let s_286_2186: Bits = s_286_2185 << s_286_2177;
        // C s_286_2187: lsl s_286_2184 s_286_2177
        let s_286_2187: Bits = s_286_2184 << s_286_2177;
        // C s_286_2188: cmpl s_286_2187
        let s_286_2188: Bits = !s_286_2187;
        // D s_286_2189: and s_286_2178 s_286_2188
        let s_286_2189: Bits = ((s_286_2178) & (s_286_2188));
        // D s_286_2190: or s_286_2189 s_286_2186
        let s_286_2190: Bits = ((s_286_2189) | (s_286_2186));
        // D s_286_2191: cast reint s_286_2190 -> u32
        let s_286_2191: u32 = (s_286_2190.value() as u32);
        // D s_286_2192: call Mk_IFSR_Type(s_286_2191)
        let s_286_2192: ProductType700c18a878c5601b = Mk_IFSR_Type(
            state,
            tracer,
            s_286_2191,
        );
        // D s_286_2193: call IFSR_write(s_286_2192)
        let s_286_2193: () = IFSR_write(state, tracer, s_286_2192);
        // C s_286_2194: const #() : ()
        let s_286_2194: () = ();
        // S s_286_2195: call IFSR_read(s_286_2194)
        let s_286_2195: ProductType700c18a878c5601b = IFSR_read(
            state,
            tracer,
            s_286_2194,
        );
        // D s_286_2196: write-var ga#36452 <= s_286_2195
        fn_state.ga_36452 = s_286_2195;
        // D s_286_2197: read-var ga#36452.0:struct
        let s_286_2197: u32 = fn_state.ga_36452._0;
        // C s_286_2198: const #3s : i
        let s_286_2198: i128 = 3;
        // C s_286_2199: const #6s : i
        let s_286_2199: i128 = 6;
        // D s_286_2200: cast zx s_286_2197 -> bv
        let s_286_2200: Bits = Bits::new(s_286_2197 as u128, 32u16);
        // C s_286_2201: const #0u : u8
        let s_286_2201: u8 = 0;
        // C s_286_2202: cast zx s_286_2201 -> bv
        let s_286_2202: Bits = Bits::new(s_286_2201 as u128, 3u16);
        // C s_286_2203: const #1u : u64
        let s_286_2203: u64 = 1;
        // C s_286_2204: cast zx s_286_2203 -> bv
        let s_286_2204: Bits = Bits::new(s_286_2203 as u128, 64u16);
        // C s_286_2205: lsl s_286_2204 s_286_2198
        let s_286_2205: Bits = s_286_2204 << s_286_2198;
        // C s_286_2206: sub s_286_2205 s_286_2204
        let s_286_2206: Bits = ((s_286_2205) - (s_286_2204));
        // C s_286_2207: and s_286_2202 s_286_2206
        let s_286_2207: Bits = ((s_286_2202) & (s_286_2206));
        // C s_286_2208: lsl s_286_2207 s_286_2199
        let s_286_2208: Bits = s_286_2207 << s_286_2199;
        // C s_286_2209: lsl s_286_2206 s_286_2199
        let s_286_2209: Bits = s_286_2206 << s_286_2199;
        // C s_286_2210: cmpl s_286_2209
        let s_286_2210: Bits = !s_286_2209;
        // D s_286_2211: and s_286_2200 s_286_2210
        let s_286_2211: Bits = ((s_286_2200) & (s_286_2210));
        // D s_286_2212: or s_286_2211 s_286_2208
        let s_286_2212: Bits = ((s_286_2211) | (s_286_2208));
        // D s_286_2213: cast reint s_286_2212 -> u32
        let s_286_2213: u32 = (s_286_2212.value() as u32);
        // D s_286_2214: call Mk_IFSR_Type(s_286_2213)
        let s_286_2214: ProductType700c18a878c5601b = Mk_IFSR_Type(
            state,
            tracer,
            s_286_2213,
        );
        // D s_286_2215: call IFSR_write(s_286_2214)
        let s_286_2215: () = IFSR_write(state, tracer, s_286_2214);
        // C s_286_2216: const #1u : u8
        let s_286_2216: bool = true;
        // S s_286_2217: call Bit(s_286_2216)
        let s_286_2217: bool = Bit(state, tracer, s_286_2216);
        // C s_286_2218: const #16816u : u32
        let s_286_2218: u32 = 16816;
        // D s_286_2219: read-reg s_286_2218:struct
        let s_286_2219: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_286_2218 as isize);
            tracer.read_register(s_286_2218 as isize, value);
            value
        };
        // C s_286_2220: const #16816u : u32
        let s_286_2220: u32 = 16816;
        // N s_286_2221: write-reg s_286_2220 <= s_286_2219
        let s_286_2221: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_286_2220 as isize, s_286_2219);
            tracer.write_register(s_286_2220 as isize, s_286_2219);
        };
        // C s_286_2222: const #0u : u8
        let s_286_2222: bool = false;
        // S s_286_2223: call Bit(s_286_2222)
        let s_286_2223: bool = Bit(state, tracer, s_286_2222);
        // C s_286_2224: const #16816u : u32
        let s_286_2224: u32 = 16816;
        // D s_286_2225: read-reg s_286_2224:struct
        let s_286_2225: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_286_2224 as isize);
            tracer.read_register(s_286_2224 as isize, value);
            value
        };
        // C s_286_2226: const #16816u : u32
        let s_286_2226: u32 = 16816;
        // N s_286_2227: write-reg s_286_2226 <= s_286_2225
        let s_286_2227: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_286_2226 as isize, s_286_2225);
            tracer.write_register(s_286_2226 as isize, s_286_2225);
        };
        // C s_286_2228: const #16816u : u32
        let s_286_2228: u32 = 16816;
        // D s_286_2229: read-reg s_286_2228:struct
        let s_286_2229: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_286_2228 as isize);
            tracer.read_register(s_286_2228 as isize, value);
            value
        };
        // C s_286_2230: const #16816u : u32
        let s_286_2230: u32 = 16816;
        // N s_286_2231: write-reg s_286_2230 <= s_286_2229
        let s_286_2231: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_286_2230 as isize, s_286_2229);
            tracer.write_register(s_286_2230 as isize, s_286_2229);
        };
        // C s_286_2232: const #() : ()
        let s_286_2232: () = ();
        // S s_286_2233: call CNTP_CTL_read(s_286_2232)
        let s_286_2233: ProductType700c18a878c5601b = CNTP_CTL_read(
            state,
            tracer,
            s_286_2232,
        );
        // D s_286_2234: write-var ga#36464 <= s_286_2233
        fn_state.ga_36464 = s_286_2233;
        // D s_286_2235: read-var ga#36464.0:struct
        let s_286_2235: u32 = fn_state.ga_36464._0;
        // C s_286_2236: const #29s : i
        let s_286_2236: i128 = 29;
        // C s_286_2237: const #3s : i
        let s_286_2237: i128 = 3;
        // D s_286_2238: cast zx s_286_2235 -> bv
        let s_286_2238: Bits = Bits::new(s_286_2235 as u128, 32u16);
        // C s_286_2239: const #0u : u29
        let s_286_2239: u32 = 0;
        // C s_286_2240: cast zx s_286_2239 -> bv
        let s_286_2240: Bits = Bits::new(s_286_2239 as u128, 29u16);
        // C s_286_2241: const #1u : u64
        let s_286_2241: u64 = 1;
        // C s_286_2242: cast zx s_286_2241 -> bv
        let s_286_2242: Bits = Bits::new(s_286_2241 as u128, 64u16);
        // C s_286_2243: lsl s_286_2242 s_286_2236
        let s_286_2243: Bits = s_286_2242 << s_286_2236;
        // C s_286_2244: sub s_286_2243 s_286_2242
        let s_286_2244: Bits = ((s_286_2243) - (s_286_2242));
        // C s_286_2245: and s_286_2240 s_286_2244
        let s_286_2245: Bits = ((s_286_2240) & (s_286_2244));
        // C s_286_2246: lsl s_286_2245 s_286_2237
        let s_286_2246: Bits = s_286_2245 << s_286_2237;
        // C s_286_2247: lsl s_286_2244 s_286_2237
        let s_286_2247: Bits = s_286_2244 << s_286_2237;
        // C s_286_2248: cmpl s_286_2247
        let s_286_2248: Bits = !s_286_2247;
        // D s_286_2249: and s_286_2238 s_286_2248
        let s_286_2249: Bits = ((s_286_2238) & (s_286_2248));
        // D s_286_2250: or s_286_2249 s_286_2246
        let s_286_2250: Bits = ((s_286_2249) | (s_286_2246));
        // D s_286_2251: cast reint s_286_2250 -> u32
        let s_286_2251: u32 = (s_286_2250.value() as u32);
        // D s_286_2252: call Mk_CNTP_CTL_Type(s_286_2251)
        let s_286_2252: ProductType700c18a878c5601b = Mk_CNTP_CTL_Type(
            state,
            tracer,
            s_286_2251,
        );
        // D s_286_2253: call CNTP_CTL_write(s_286_2252)
        let s_286_2253: () = CNTP_CTL_write(state, tracer, s_286_2252);
        // C s_286_2254: const #() : ()
        let s_286_2254: () = ();
        // S s_286_2255: call CNTP_CTL_read(s_286_2254)
        let s_286_2255: ProductType700c18a878c5601b = CNTP_CTL_read(
            state,
            tracer,
            s_286_2254,
        );
        // C s_286_2256: const #0u : u8
        let s_286_2256: bool = false;
        // S s_286_2257: call _update_CNTP_CTL_Type_ENABLE(s_286_2255, s_286_2256)
        let s_286_2257: ProductType700c18a878c5601b = u_update_CNTP_CTL_Type_ENABLE(
            state,
            tracer,
            s_286_2255,
            s_286_2256,
        );
        // S s_286_2258: call CNTP_CTL_write(s_286_2257)
        let s_286_2258: () = CNTP_CTL_write(state, tracer, s_286_2257);
        // C s_286_2259: const #() : ()
        let s_286_2259: () = ();
        // S s_286_2260: call FPSCR_read__1(s_286_2259)
        let s_286_2260: ProductType700c18a878c5601b = FPSCR_read__1(
            state,
            tracer,
            s_286_2259,
        );
        // D s_286_2261: write-var ga#36470 <= s_286_2260
        fn_state.ga_36470 = s_286_2260;
        // D s_286_2262: read-var ga#36470.0:struct
        let s_286_2262: u32 = fn_state.ga_36470._0;
        // C s_286_2263: const #2s : i
        let s_286_2263: i128 = 2;
        // C s_286_2264: const #13s : i
        let s_286_2264: i128 = 13;
        // D s_286_2265: cast zx s_286_2262 -> bv
        let s_286_2265: Bits = Bits::new(s_286_2262 as u128, 32u16);
        // C s_286_2266: const #0u : u8
        let s_286_2266: u8 = 0;
        // C s_286_2267: cast zx s_286_2266 -> bv
        let s_286_2267: Bits = Bits::new(s_286_2266 as u128, 2u16);
        // C s_286_2268: const #1u : u64
        let s_286_2268: u64 = 1;
        // C s_286_2269: cast zx s_286_2268 -> bv
        let s_286_2269: Bits = Bits::new(s_286_2268 as u128, 64u16);
        // C s_286_2270: lsl s_286_2269 s_286_2263
        let s_286_2270: Bits = s_286_2269 << s_286_2263;
        // C s_286_2271: sub s_286_2270 s_286_2269
        let s_286_2271: Bits = ((s_286_2270) - (s_286_2269));
        // C s_286_2272: and s_286_2267 s_286_2271
        let s_286_2272: Bits = ((s_286_2267) & (s_286_2271));
        // C s_286_2273: lsl s_286_2272 s_286_2264
        let s_286_2273: Bits = s_286_2272 << s_286_2264;
        // C s_286_2274: lsl s_286_2271 s_286_2264
        let s_286_2274: Bits = s_286_2271 << s_286_2264;
        // C s_286_2275: cmpl s_286_2274
        let s_286_2275: Bits = !s_286_2274;
        // D s_286_2276: and s_286_2265 s_286_2275
        let s_286_2276: Bits = ((s_286_2265) & (s_286_2275));
        // D s_286_2277: or s_286_2276 s_286_2273
        let s_286_2277: Bits = ((s_286_2276) | (s_286_2273));
        // D s_286_2278: cast reint s_286_2277 -> u32
        let s_286_2278: u32 = (s_286_2277.value() as u32);
        // D s_286_2279: call Mk_FPSCR_Type(s_286_2278)
        let s_286_2279: ProductType700c18a878c5601b = Mk_FPSCR_Type(
            state,
            tracer,
            s_286_2278,
        );
        // D s_286_2280: call FPSCR_write(s_286_2279)
        let s_286_2280: () = FPSCR_write(state, tracer, s_286_2279);
        // C s_286_2281: const #() : ()
        let s_286_2281: () = ();
        // S s_286_2282: call FPSCR_read__1(s_286_2281)
        let s_286_2282: ProductType700c18a878c5601b = FPSCR_read__1(
            state,
            tracer,
            s_286_2281,
        );
        // D s_286_2283: write-var ga#36474 <= s_286_2282
        fn_state.ga_36474 = s_286_2282;
        // D s_286_2284: read-var ga#36474.0:struct
        let s_286_2284: u32 = fn_state.ga_36474._0;
        // C s_286_2285: const #2s : i
        let s_286_2285: i128 = 2;
        // C s_286_2286: const #5s : i
        let s_286_2286: i128 = 5;
        // D s_286_2287: cast zx s_286_2284 -> bv
        let s_286_2287: Bits = Bits::new(s_286_2284 as u128, 32u16);
        // C s_286_2288: const #0u : u8
        let s_286_2288: u8 = 0;
        // C s_286_2289: cast zx s_286_2288 -> bv
        let s_286_2289: Bits = Bits::new(s_286_2288 as u128, 2u16);
        // C s_286_2290: const #1u : u64
        let s_286_2290: u64 = 1;
        // C s_286_2291: cast zx s_286_2290 -> bv
        let s_286_2291: Bits = Bits::new(s_286_2290 as u128, 64u16);
        // C s_286_2292: lsl s_286_2291 s_286_2285
        let s_286_2292: Bits = s_286_2291 << s_286_2285;
        // C s_286_2293: sub s_286_2292 s_286_2291
        let s_286_2293: Bits = ((s_286_2292) - (s_286_2291));
        // C s_286_2294: and s_286_2289 s_286_2293
        let s_286_2294: Bits = ((s_286_2289) & (s_286_2293));
        // C s_286_2295: lsl s_286_2294 s_286_2286
        let s_286_2295: Bits = s_286_2294 << s_286_2286;
        // C s_286_2296: lsl s_286_2293 s_286_2286
        let s_286_2296: Bits = s_286_2293 << s_286_2286;
        // C s_286_2297: cmpl s_286_2296
        let s_286_2297: Bits = !s_286_2296;
        // D s_286_2298: and s_286_2287 s_286_2297
        let s_286_2298: Bits = ((s_286_2287) & (s_286_2297));
        // D s_286_2299: or s_286_2298 s_286_2295
        let s_286_2299: Bits = ((s_286_2298) | (s_286_2295));
        // D s_286_2300: cast reint s_286_2299 -> u32
        let s_286_2300: u32 = (s_286_2299.value() as u32);
        // D s_286_2301: call Mk_FPSCR_Type(s_286_2300)
        let s_286_2301: ProductType700c18a878c5601b = Mk_FPSCR_Type(
            state,
            tracer,
            s_286_2300,
        );
        // D s_286_2302: call FPSCR_write(s_286_2301)
        let s_286_2302: () = FPSCR_write(state, tracer, s_286_2301);
        // C s_286_2303: const #() : ()
        let s_286_2303: () = ();
        // S s_286_2304: call HTRFCR_read(s_286_2303)
        let s_286_2304: ProductType700c18a878c5601b = HTRFCR_read(
            state,
            tracer,
            s_286_2303,
        );
        // D s_286_2305: write-var ga#36478 <= s_286_2304
        fn_state.ga_36478 = s_286_2304;
        // D s_286_2306: read-var ga#36478.0:struct
        let s_286_2306: u32 = fn_state.ga_36478._0;
        // C s_286_2307: const #25s : i
        let s_286_2307: i128 = 25;
        // C s_286_2308: const #7s : i
        let s_286_2308: i128 = 7;
        // D s_286_2309: cast zx s_286_2306 -> bv
        let s_286_2309: Bits = Bits::new(s_286_2306 as u128, 32u16);
        // C s_286_2310: const #0u : u25
        let s_286_2310: u32 = 0;
        // C s_286_2311: cast zx s_286_2310 -> bv
        let s_286_2311: Bits = Bits::new(s_286_2310 as u128, 25u16);
        // C s_286_2312: const #1u : u64
        let s_286_2312: u64 = 1;
        // C s_286_2313: cast zx s_286_2312 -> bv
        let s_286_2313: Bits = Bits::new(s_286_2312 as u128, 64u16);
        // C s_286_2314: lsl s_286_2313 s_286_2307
        let s_286_2314: Bits = s_286_2313 << s_286_2307;
        // C s_286_2315: sub s_286_2314 s_286_2313
        let s_286_2315: Bits = ((s_286_2314) - (s_286_2313));
        // C s_286_2316: and s_286_2311 s_286_2315
        let s_286_2316: Bits = ((s_286_2311) & (s_286_2315));
        // C s_286_2317: lsl s_286_2316 s_286_2308
        let s_286_2317: Bits = s_286_2316 << s_286_2308;
        // C s_286_2318: lsl s_286_2315 s_286_2308
        let s_286_2318: Bits = s_286_2315 << s_286_2308;
        // C s_286_2319: cmpl s_286_2318
        let s_286_2319: Bits = !s_286_2318;
        // D s_286_2320: and s_286_2309 s_286_2319
        let s_286_2320: Bits = ((s_286_2309) & (s_286_2319));
        // D s_286_2321: or s_286_2320 s_286_2317
        let s_286_2321: Bits = ((s_286_2320) | (s_286_2317));
        // D s_286_2322: cast reint s_286_2321 -> u32
        let s_286_2322: u32 = (s_286_2321.value() as u32);
        // D s_286_2323: call Mk_HTRFCR_Type(s_286_2322)
        let s_286_2323: ProductType700c18a878c5601b = Mk_HTRFCR_Type(
            state,
            tracer,
            s_286_2322,
        );
        // D s_286_2324: call HTRFCR_write(s_286_2323)
        let s_286_2324: () = HTRFCR_write(state, tracer, s_286_2323);
        // D s_286_2325: read-var cold:u8
        let s_286_2325: bool = fn_state.cold;
        // D s_286_2326: not s_286_2325
        let s_286_2326: bool = !s_286_2325;
        // N s_286_2327: branch s_286_2326 b508 b287
        if s_286_2326 {
            return block_508(state, tracer, fn_state);
        } else {
            return block_287(state, tracer, fn_state);
        };
    }
    fn block_287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_287_0: const #0u : u8
        let s_287_0: bool = false;
        // D s_287_1: write-var gs#44716 <= s_287_0
        fn_state.gs_44716 = s_287_0;
        // N s_287_2: jump b288
        return block_288(state, tracer, fn_state);
    }
    fn block_288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_288_0: read-var gs#44716:u8
        let s_288_0: bool = fn_state.gs_44716;
        // N s_288_1: branch s_288_0 b507 b289
        if s_288_0 {
            return block_507(state, tracer, fn_state);
        } else {
            return block_289(state, tracer, fn_state);
        };
    }
    fn block_289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_289_0: const #() : ()
        let s_289_0: () = ();
        // S s_289_1: call HTRFCR_read(s_289_0)
        let s_289_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_289_0);
        // C s_289_2: const #2s : i64
        let s_289_2: i64 = 2;
        // C s_289_3: cast zx s_289_2 -> i
        let s_289_3: i128 = (i128::try_from(s_289_2).unwrap());
        // S s_289_4: call __UNKNOWN_bits(s_289_3)
        let s_289_4: Bits = u__UNKNOWN_bits(state, tracer, s_289_3);
        // S s_289_5: cast reint s_289_4 -> u8
        let s_289_5: u8 = (s_289_4.value() as u8);
        // S s_289_6: call _update_HTRFCR_Type_TS(s_289_1, s_289_5)
        let s_289_6: ProductType700c18a878c5601b = u_update_HTRFCR_Type_TS(
            state,
            tracer,
            s_289_1,
            s_289_5,
        );
        // S s_289_7: call HTRFCR_write(s_289_6)
        let s_289_7: () = HTRFCR_write(state, tracer, s_289_6);
        // N s_289_8: jump b290
        return block_290(state, tracer, fn_state);
    }
    fn block_290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_290_0: const #() : ()
        let s_290_0: () = ();
        // S s_290_1: call HTRFCR_read(s_290_0)
        let s_290_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_290_0);
        // D s_290_2: write-var ga#36490 <= s_290_1
        fn_state.ga_36490 = s_290_1;
        // D s_290_3: read-var ga#36490.0:struct
        let s_290_3: u32 = fn_state.ga_36490._0;
        // C s_290_4: const #1s : i
        let s_290_4: i128 = 1;
        // C s_290_5: const #4s : i
        let s_290_5: i128 = 4;
        // D s_290_6: cast zx s_290_3 -> bv
        let s_290_6: Bits = Bits::new(s_290_3 as u128, 32u16);
        // C s_290_7: const #0u : u8
        let s_290_7: bool = false;
        // C s_290_8: cast zx s_290_7 -> bv
        let s_290_8: Bits = Bits::new(s_290_7 as u128, 1u16);
        // C s_290_9: const #1u : u64
        let s_290_9: u64 = 1;
        // C s_290_10: cast zx s_290_9 -> bv
        let s_290_10: Bits = Bits::new(s_290_9 as u128, 64u16);
        // C s_290_11: lsl s_290_10 s_290_4
        let s_290_11: Bits = s_290_10 << s_290_4;
        // C s_290_12: sub s_290_11 s_290_10
        let s_290_12: Bits = ((s_290_11) - (s_290_10));
        // C s_290_13: and s_290_8 s_290_12
        let s_290_13: Bits = ((s_290_8) & (s_290_12));
        // C s_290_14: lsl s_290_13 s_290_5
        let s_290_14: Bits = s_290_13 << s_290_5;
        // C s_290_15: lsl s_290_12 s_290_5
        let s_290_15: Bits = s_290_12 << s_290_5;
        // C s_290_16: cmpl s_290_15
        let s_290_16: Bits = !s_290_15;
        // D s_290_17: and s_290_6 s_290_16
        let s_290_17: Bits = ((s_290_6) & (s_290_16));
        // D s_290_18: or s_290_17 s_290_14
        let s_290_18: Bits = ((s_290_17) | (s_290_14));
        // D s_290_19: cast reint s_290_18 -> u32
        let s_290_19: u32 = (s_290_18.value() as u32);
        // D s_290_20: call Mk_HTRFCR_Type(s_290_19)
        let s_290_20: ProductType700c18a878c5601b = Mk_HTRFCR_Type(
            state,
            tracer,
            s_290_19,
        );
        // D s_290_21: call HTRFCR_write(s_290_20)
        let s_290_21: () = HTRFCR_write(state, tracer, s_290_20);
        // D s_290_22: read-var cold:u8
        let s_290_22: bool = fn_state.cold;
        // D s_290_23: not s_290_22
        let s_290_23: bool = !s_290_22;
        // N s_290_24: branch s_290_23 b506 b291
        if s_290_23 {
            return block_506(state, tracer, fn_state);
        } else {
            return block_291(state, tracer, fn_state);
        };
    }
    fn block_291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_291_0: const #0u : u8
        let s_291_0: bool = false;
        // D s_291_1: write-var gs#44720 <= s_291_0
        fn_state.gs_44720 = s_291_0;
        // N s_291_2: jump b292
        return block_292(state, tracer, fn_state);
    }
    fn block_292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_292_0: read-var gs#44720:u8
        let s_292_0: bool = fn_state.gs_44720;
        // N s_292_1: branch s_292_0 b505 b293
        if s_292_0 {
            return block_505(state, tracer, fn_state);
        } else {
            return block_293(state, tracer, fn_state);
        };
    }
    fn block_293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_293_0: const #() : ()
        let s_293_0: () = ();
        // S s_293_1: call HTRFCR_read(s_293_0)
        let s_293_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_293_0);
        // C s_293_2: const #1s : i64
        let s_293_2: i64 = 1;
        // C s_293_3: cast zx s_293_2 -> i
        let s_293_3: i128 = (i128::try_from(s_293_2).unwrap());
        // S s_293_4: call __UNKNOWN_bits(s_293_3)
        let s_293_4: Bits = u__UNKNOWN_bits(state, tracer, s_293_3);
        // S s_293_5: cast reint s_293_4 -> u8
        let s_293_5: bool = ((s_293_4.value()) != 0);
        // S s_293_6: call _update_HTRFCR_Type_CX(s_293_1, s_293_5)
        let s_293_6: ProductType700c18a878c5601b = u_update_HTRFCR_Type_CX(
            state,
            tracer,
            s_293_1,
            s_293_5,
        );
        // S s_293_7: call HTRFCR_write(s_293_6)
        let s_293_7: () = HTRFCR_write(state, tracer, s_293_6);
        // N s_293_8: jump b294
        return block_294(state, tracer, fn_state);
    }
    fn block_294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_294_0: const #() : ()
        let s_294_0: () = ();
        // S s_294_1: call HTRFCR_read(s_294_0)
        let s_294_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_294_0);
        // D s_294_2: write-var ga#36502 <= s_294_1
        fn_state.ga_36502 = s_294_1;
        // D s_294_3: read-var ga#36502.0:struct
        let s_294_3: u32 = fn_state.ga_36502._0;
        // C s_294_4: const #1s : i
        let s_294_4: i128 = 1;
        // C s_294_5: const #2s : i
        let s_294_5: i128 = 2;
        // D s_294_6: cast zx s_294_3 -> bv
        let s_294_6: Bits = Bits::new(s_294_3 as u128, 32u16);
        // C s_294_7: const #0u : u8
        let s_294_7: bool = false;
        // C s_294_8: cast zx s_294_7 -> bv
        let s_294_8: Bits = Bits::new(s_294_7 as u128, 1u16);
        // C s_294_9: const #1u : u64
        let s_294_9: u64 = 1;
        // C s_294_10: cast zx s_294_9 -> bv
        let s_294_10: Bits = Bits::new(s_294_9 as u128, 64u16);
        // C s_294_11: lsl s_294_10 s_294_4
        let s_294_11: Bits = s_294_10 << s_294_4;
        // C s_294_12: sub s_294_11 s_294_10
        let s_294_12: Bits = ((s_294_11) - (s_294_10));
        // C s_294_13: and s_294_8 s_294_12
        let s_294_13: Bits = ((s_294_8) & (s_294_12));
        // C s_294_14: lsl s_294_13 s_294_5
        let s_294_14: Bits = s_294_13 << s_294_5;
        // C s_294_15: lsl s_294_12 s_294_5
        let s_294_15: Bits = s_294_12 << s_294_5;
        // C s_294_16: cmpl s_294_15
        let s_294_16: Bits = !s_294_15;
        // D s_294_17: and s_294_6 s_294_16
        let s_294_17: Bits = ((s_294_6) & (s_294_16));
        // D s_294_18: or s_294_17 s_294_14
        let s_294_18: Bits = ((s_294_17) | (s_294_14));
        // D s_294_19: cast reint s_294_18 -> u32
        let s_294_19: u32 = (s_294_18.value() as u32);
        // D s_294_20: call Mk_HTRFCR_Type(s_294_19)
        let s_294_20: ProductType700c18a878c5601b = Mk_HTRFCR_Type(
            state,
            tracer,
            s_294_19,
        );
        // D s_294_21: call HTRFCR_write(s_294_20)
        let s_294_21: () = HTRFCR_write(state, tracer, s_294_20);
        // D s_294_22: read-var cold:u8
        let s_294_22: bool = fn_state.cold;
        // D s_294_23: not s_294_22
        let s_294_23: bool = !s_294_22;
        // N s_294_24: branch s_294_23 b504 b295
        if s_294_23 {
            return block_504(state, tracer, fn_state);
        } else {
            return block_295(state, tracer, fn_state);
        };
    }
    fn block_295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_295_0: const #0u : u8
        let s_295_0: bool = false;
        // D s_295_1: write-var gs#44724 <= s_295_0
        fn_state.gs_44724 = s_295_0;
        // N s_295_2: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_296_0: read-var gs#44724:u8
        let s_296_0: bool = fn_state.gs_44724;
        // N s_296_1: branch s_296_0 b503 b297
        if s_296_0 {
            return block_503(state, tracer, fn_state);
        } else {
            return block_297(state, tracer, fn_state);
        };
    }
    fn block_297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_297_0: const #() : ()
        let s_297_0: () = ();
        // S s_297_1: call HTRFCR_read(s_297_0)
        let s_297_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_297_0);
        // C s_297_2: const #1s : i64
        let s_297_2: i64 = 1;
        // C s_297_3: cast zx s_297_2 -> i
        let s_297_3: i128 = (i128::try_from(s_297_2).unwrap());
        // S s_297_4: call __UNKNOWN_bits(s_297_3)
        let s_297_4: Bits = u__UNKNOWN_bits(state, tracer, s_297_3);
        // S s_297_5: cast reint s_297_4 -> u8
        let s_297_5: bool = ((s_297_4.value()) != 0);
        // S s_297_6: call _update_HTRFCR_Type_E2TRE(s_297_1, s_297_5)
        let s_297_6: ProductType700c18a878c5601b = u_update_HTRFCR_Type_E2TRE(
            state,
            tracer,
            s_297_1,
            s_297_5,
        );
        // S s_297_7: call HTRFCR_write(s_297_6)
        let s_297_7: () = HTRFCR_write(state, tracer, s_297_6);
        // N s_297_8: jump b298
        return block_298(state, tracer, fn_state);
    }
    fn block_298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_298_0: read-var cold:u8
        let s_298_0: bool = fn_state.cold;
        // D s_298_1: not s_298_0
        let s_298_1: bool = !s_298_0;
        // N s_298_2: branch s_298_1 b502 b299
        if s_298_1 {
            return block_502(state, tracer, fn_state);
        } else {
            return block_299(state, tracer, fn_state);
        };
    }
    fn block_299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_299_0: const #0u : u8
        let s_299_0: bool = false;
        // D s_299_1: write-var gs#44725 <= s_299_0
        fn_state.gs_44725 = s_299_0;
        // N s_299_2: jump b300
        return block_300(state, tracer, fn_state);
    }
    fn block_300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_300_0: read-var gs#44725:u8
        let s_300_0: bool = fn_state.gs_44725;
        // N s_300_1: branch s_300_0 b501 b301
        if s_300_0 {
            return block_501(state, tracer, fn_state);
        } else {
            return block_301(state, tracer, fn_state);
        };
    }
    fn block_301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_301_0: const #() : ()
        let s_301_0: () = ();
        // S s_301_1: call HTRFCR_read(s_301_0)
        let s_301_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_301_0);
        // C s_301_2: const #1s : i64
        let s_301_2: i64 = 1;
        // C s_301_3: cast zx s_301_2 -> i
        let s_301_3: i128 = (i128::try_from(s_301_2).unwrap());
        // S s_301_4: call __UNKNOWN_bits(s_301_3)
        let s_301_4: Bits = u__UNKNOWN_bits(state, tracer, s_301_3);
        // S s_301_5: cast reint s_301_4 -> u8
        let s_301_5: bool = ((s_301_4.value()) != 0);
        // S s_301_6: call _update_HTRFCR_Type_E0HTRE(s_301_1, s_301_5)
        let s_301_6: ProductType700c18a878c5601b = u_update_HTRFCR_Type_E0HTRE(
            state,
            tracer,
            s_301_1,
            s_301_5,
        );
        // S s_301_7: call HTRFCR_write(s_301_6)
        let s_301_7: () = HTRFCR_write(state, tracer, s_301_6);
        // N s_301_8: jump b302
        return block_302(state, tracer, fn_state);
    }
    fn block_302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_302_0: const #() : ()
        let s_302_0: () = ();
        // S s_302_1: call VPIDR_read(s_302_0)
        let s_302_1: ProductType700c18a878c5601b = VPIDR_read(state, tracer, s_302_0);
        // C s_302_2: const #8s : i64
        let s_302_2: i64 = 8;
        // C s_302_3: cast zx s_302_2 -> i
        let s_302_3: i128 = (i128::try_from(s_302_2).unwrap());
        // S s_302_4: call __UNKNOWN_bits(s_302_3)
        let s_302_4: Bits = u__UNKNOWN_bits(state, tracer, s_302_3);
        // S s_302_5: cast reint s_302_4 -> u8
        let s_302_5: u8 = (s_302_4.value() as u8);
        // S s_302_6: call _update_VPIDR_Type_Implementer(s_302_1, s_302_5)
        let s_302_6: ProductType700c18a878c5601b = u_update_VPIDR_Type_Implementer(
            state,
            tracer,
            s_302_1,
            s_302_5,
        );
        // S s_302_7: call VPIDR_write(s_302_6)
        let s_302_7: () = VPIDR_write(state, tracer, s_302_6);
        // C s_302_8: const #() : ()
        let s_302_8: () = ();
        // S s_302_9: call VPIDR_read(s_302_8)
        let s_302_9: ProductType700c18a878c5601b = VPIDR_read(state, tracer, s_302_8);
        // C s_302_10: const #4s : i64
        let s_302_10: i64 = 4;
        // C s_302_11: cast zx s_302_10 -> i
        let s_302_11: i128 = (i128::try_from(s_302_10).unwrap());
        // S s_302_12: call __UNKNOWN_bits(s_302_11)
        let s_302_12: Bits = u__UNKNOWN_bits(state, tracer, s_302_11);
        // S s_302_13: cast reint s_302_12 -> u8
        let s_302_13: u8 = (s_302_12.value() as u8);
        // S s_302_14: call _update_VPIDR_Type_Variant(s_302_9, s_302_13)
        let s_302_14: ProductType700c18a878c5601b = u_update_VPIDR_Type_Variant(
            state,
            tracer,
            s_302_9,
            s_302_13,
        );
        // S s_302_15: call VPIDR_write(s_302_14)
        let s_302_15: () = VPIDR_write(state, tracer, s_302_14);
        // C s_302_16: const #() : ()
        let s_302_16: () = ();
        // S s_302_17: call VPIDR_read(s_302_16)
        let s_302_17: ProductType700c18a878c5601b = VPIDR_read(state, tracer, s_302_16);
        // C s_302_18: const #4s : i64
        let s_302_18: i64 = 4;
        // C s_302_19: cast zx s_302_18 -> i
        let s_302_19: i128 = (i128::try_from(s_302_18).unwrap());
        // S s_302_20: call __UNKNOWN_bits(s_302_19)
        let s_302_20: Bits = u__UNKNOWN_bits(state, tracer, s_302_19);
        // S s_302_21: cast reint s_302_20 -> u8
        let s_302_21: u8 = (s_302_20.value() as u8);
        // S s_302_22: call _update_VPIDR_Type_Architecture(s_302_17, s_302_21)
        let s_302_22: ProductType700c18a878c5601b = u_update_VPIDR_Type_Architecture(
            state,
            tracer,
            s_302_17,
            s_302_21,
        );
        // S s_302_23: call VPIDR_write(s_302_22)
        let s_302_23: () = VPIDR_write(state, tracer, s_302_22);
        // C s_302_24: const #() : ()
        let s_302_24: () = ();
        // S s_302_25: call VPIDR_read(s_302_24)
        let s_302_25: ProductType700c18a878c5601b = VPIDR_read(state, tracer, s_302_24);
        // C s_302_26: const #12s : i64
        let s_302_26: i64 = 12;
        // C s_302_27: cast zx s_302_26 -> i
        let s_302_27: i128 = (i128::try_from(s_302_26).unwrap());
        // S s_302_28: call __UNKNOWN_bits(s_302_27)
        let s_302_28: Bits = u__UNKNOWN_bits(state, tracer, s_302_27);
        // S s_302_29: cast reint s_302_28 -> u12
        let s_302_29: u16 = (s_302_28.value() as u16);
        // S s_302_30: call _update_VPIDR_Type_PartNum(s_302_25, s_302_29)
        let s_302_30: ProductType700c18a878c5601b = u_update_VPIDR_Type_PartNum(
            state,
            tracer,
            s_302_25,
            s_302_29,
        );
        // S s_302_31: call VPIDR_write(s_302_30)
        let s_302_31: () = VPIDR_write(state, tracer, s_302_30);
        // C s_302_32: const #() : ()
        let s_302_32: () = ();
        // S s_302_33: call VPIDR_read(s_302_32)
        let s_302_33: ProductType700c18a878c5601b = VPIDR_read(state, tracer, s_302_32);
        // C s_302_34: const #4s : i64
        let s_302_34: i64 = 4;
        // C s_302_35: cast zx s_302_34 -> i
        let s_302_35: i128 = (i128::try_from(s_302_34).unwrap());
        // S s_302_36: call __UNKNOWN_bits(s_302_35)
        let s_302_36: Bits = u__UNKNOWN_bits(state, tracer, s_302_35);
        // S s_302_37: cast reint s_302_36 -> u8
        let s_302_37: u8 = (s_302_36.value() as u8);
        // S s_302_38: call _update_VPIDR_Type_Revision(s_302_33, s_302_37)
        let s_302_38: ProductType700c18a878c5601b = u_update_VPIDR_Type_Revision(
            state,
            tracer,
            s_302_33,
            s_302_37,
        );
        // S s_302_39: call VPIDR_write(s_302_38)
        let s_302_39: () = VPIDR_write(state, tracer, s_302_38);
        // C s_302_40: const #() : ()
        let s_302_40: () = ();
        // S s_302_41: call PMSWINC_read(s_302_40)
        let s_302_41: ProductType700c18a878c5601b = PMSWINC_read(
            state,
            tracer,
            s_302_40,
        );
        // D s_302_42: write-var ga#36542 <= s_302_41
        fn_state.ga_36542 = s_302_41;
        // D s_302_43: read-var ga#36542.0:struct
        let s_302_43: u32 = fn_state.ga_36542._0;
        // C s_302_44: const #1s : i
        let s_302_44: i128 = 1;
        // C s_302_45: const #31s : i
        let s_302_45: i128 = 31;
        // D s_302_46: cast zx s_302_43 -> bv
        let s_302_46: Bits = Bits::new(s_302_43 as u128, 32u16);
        // C s_302_47: const #0u : u8
        let s_302_47: bool = false;
        // C s_302_48: cast zx s_302_47 -> bv
        let s_302_48: Bits = Bits::new(s_302_47 as u128, 1u16);
        // C s_302_49: const #1u : u64
        let s_302_49: u64 = 1;
        // C s_302_50: cast zx s_302_49 -> bv
        let s_302_50: Bits = Bits::new(s_302_49 as u128, 64u16);
        // C s_302_51: lsl s_302_50 s_302_44
        let s_302_51: Bits = s_302_50 << s_302_44;
        // C s_302_52: sub s_302_51 s_302_50
        let s_302_52: Bits = ((s_302_51) - (s_302_50));
        // C s_302_53: and s_302_48 s_302_52
        let s_302_53: Bits = ((s_302_48) & (s_302_52));
        // C s_302_54: lsl s_302_53 s_302_45
        let s_302_54: Bits = s_302_53 << s_302_45;
        // C s_302_55: lsl s_302_52 s_302_45
        let s_302_55: Bits = s_302_52 << s_302_45;
        // C s_302_56: cmpl s_302_55
        let s_302_56: Bits = !s_302_55;
        // D s_302_57: and s_302_46 s_302_56
        let s_302_57: Bits = ((s_302_46) & (s_302_56));
        // D s_302_58: or s_302_57 s_302_54
        let s_302_58: Bits = ((s_302_57) | (s_302_54));
        // D s_302_59: cast reint s_302_58 -> u32
        let s_302_59: u32 = (s_302_58.value() as u32);
        // D s_302_60: call Mk_PMSWINC_Type(s_302_59)
        let s_302_60: ProductType700c18a878c5601b = Mk_PMSWINC_Type(
            state,
            tracer,
            s_302_59,
        );
        // D s_302_61: call PMSWINC_write(s_302_60)
        let s_302_61: () = PMSWINC_write(state, tracer, s_302_60);
        // C s_302_62: const #() : ()
        let s_302_62: () = ();
        // S s_302_63: call CNTV_CTL_read(s_302_62)
        let s_302_63: ProductType700c18a878c5601b = CNTV_CTL_read(
            state,
            tracer,
            s_302_62,
        );
        // D s_302_64: write-var ga#36546 <= s_302_63
        fn_state.ga_36546 = s_302_63;
        // D s_302_65: read-var ga#36546.0:struct
        let s_302_65: u32 = fn_state.ga_36546._0;
        // C s_302_66: const #29s : i
        let s_302_66: i128 = 29;
        // C s_302_67: const #3s : i
        let s_302_67: i128 = 3;
        // D s_302_68: cast zx s_302_65 -> bv
        let s_302_68: Bits = Bits::new(s_302_65 as u128, 32u16);
        // C s_302_69: const #0u : u29
        let s_302_69: u32 = 0;
        // C s_302_70: cast zx s_302_69 -> bv
        let s_302_70: Bits = Bits::new(s_302_69 as u128, 29u16);
        // C s_302_71: const #1u : u64
        let s_302_71: u64 = 1;
        // C s_302_72: cast zx s_302_71 -> bv
        let s_302_72: Bits = Bits::new(s_302_71 as u128, 64u16);
        // C s_302_73: lsl s_302_72 s_302_66
        let s_302_73: Bits = s_302_72 << s_302_66;
        // C s_302_74: sub s_302_73 s_302_72
        let s_302_74: Bits = ((s_302_73) - (s_302_72));
        // C s_302_75: and s_302_70 s_302_74
        let s_302_75: Bits = ((s_302_70) & (s_302_74));
        // C s_302_76: lsl s_302_75 s_302_67
        let s_302_76: Bits = s_302_75 << s_302_67;
        // C s_302_77: lsl s_302_74 s_302_67
        let s_302_77: Bits = s_302_74 << s_302_67;
        // C s_302_78: cmpl s_302_77
        let s_302_78: Bits = !s_302_77;
        // D s_302_79: and s_302_68 s_302_78
        let s_302_79: Bits = ((s_302_68) & (s_302_78));
        // D s_302_80: or s_302_79 s_302_76
        let s_302_80: Bits = ((s_302_79) | (s_302_76));
        // D s_302_81: cast reint s_302_80 -> u32
        let s_302_81: u32 = (s_302_80.value() as u32);
        // D s_302_82: call Mk_CNTV_CTL_Type(s_302_81)
        let s_302_82: ProductType700c18a878c5601b = Mk_CNTV_CTL_Type(
            state,
            tracer,
            s_302_81,
        );
        // D s_302_83: call CNTV_CTL_write(s_302_82)
        let s_302_83: () = CNTV_CTL_write(state, tracer, s_302_82);
        // C s_302_84: const #() : ()
        let s_302_84: () = ();
        // S s_302_85: call CNTV_CTL_read(s_302_84)
        let s_302_85: ProductType700c18a878c5601b = CNTV_CTL_read(
            state,
            tracer,
            s_302_84,
        );
        // C s_302_86: const #0u : u8
        let s_302_86: bool = false;
        // S s_302_87: call _update_CNTV_CTL_Type_ENABLE(s_302_85, s_302_86)
        let s_302_87: ProductType700c18a878c5601b = u_update_CNTV_CTL_Type_ENABLE(
            state,
            tracer,
            s_302_85,
            s_302_86,
        );
        // S s_302_88: call CNTV_CTL_write(s_302_87)
        let s_302_88: () = CNTV_CTL_write(state, tracer, s_302_87);
        // C s_302_89: const #() : ()
        let s_302_89: () = ();
        // S s_302_90: call DBGOSLSR_read(s_302_89)
        let s_302_90: ProductType700c18a878c5601b = DBGOSLSR_read(
            state,
            tracer,
            s_302_89,
        );
        // D s_302_91: write-var ga#36552 <= s_302_90
        fn_state.ga_36552 = s_302_90;
        // D s_302_92: read-var ga#36552.0:struct
        let s_302_92: u32 = fn_state.ga_36552._0;
        // C s_302_93: const #28s : i
        let s_302_93: i128 = 28;
        // C s_302_94: const #4s : i
        let s_302_94: i128 = 4;
        // D s_302_95: cast zx s_302_92 -> bv
        let s_302_95: Bits = Bits::new(s_302_92 as u128, 32u16);
        // C s_302_96: const #0u : u28
        let s_302_96: u32 = 0;
        // C s_302_97: cast zx s_302_96 -> bv
        let s_302_97: Bits = Bits::new(s_302_96 as u128, 28u16);
        // C s_302_98: const #1u : u64
        let s_302_98: u64 = 1;
        // C s_302_99: cast zx s_302_98 -> bv
        let s_302_99: Bits = Bits::new(s_302_98 as u128, 64u16);
        // C s_302_100: lsl s_302_99 s_302_93
        let s_302_100: Bits = s_302_99 << s_302_93;
        // C s_302_101: sub s_302_100 s_302_99
        let s_302_101: Bits = ((s_302_100) - (s_302_99));
        // C s_302_102: and s_302_97 s_302_101
        let s_302_102: Bits = ((s_302_97) & (s_302_101));
        // C s_302_103: lsl s_302_102 s_302_94
        let s_302_103: Bits = s_302_102 << s_302_94;
        // C s_302_104: lsl s_302_101 s_302_94
        let s_302_104: Bits = s_302_101 << s_302_94;
        // C s_302_105: cmpl s_302_104
        let s_302_105: Bits = !s_302_104;
        // D s_302_106: and s_302_95 s_302_105
        let s_302_106: Bits = ((s_302_95) & (s_302_105));
        // D s_302_107: or s_302_106 s_302_103
        let s_302_107: Bits = ((s_302_106) | (s_302_103));
        // D s_302_108: cast reint s_302_107 -> u32
        let s_302_108: u32 = (s_302_107.value() as u32);
        // D s_302_109: call Mk_DBGOSLSR_Type(s_302_108)
        let s_302_109: ProductType700c18a878c5601b = Mk_DBGOSLSR_Type(
            state,
            tracer,
            s_302_108,
        );
        // D s_302_110: call DBGOSLSR_write(s_302_109)
        let s_302_110: () = DBGOSLSR_write(state, tracer, s_302_109);
        // D s_302_111: read-var cold:u8
        let s_302_111: bool = fn_state.cold;
        // N s_302_112: branch s_302_111 b500 b303
        if s_302_111 {
            return block_500(state, tracer, fn_state);
        } else {
            return block_303(state, tracer, fn_state);
        };
    }
    fn block_303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_303_0: jump b304
        return block_304(state, tracer, fn_state);
    }
    fn block_304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_304_0: const #() : ()
        let s_304_0: () = ();
        // S s_304_1: call TRFCR_read(s_304_0)
        let s_304_1: ProductType700c18a878c5601b = TRFCR_read(state, tracer, s_304_0);
        // D s_304_2: write-var ga#36558 <= s_304_1
        fn_state.ga_36558 = s_304_1;
        // D s_304_3: read-var ga#36558.0:struct
        let s_304_3: u32 = fn_state.ga_36558._0;
        // C s_304_4: const #25s : i
        let s_304_4: i128 = 25;
        // C s_304_5: const #7s : i
        let s_304_5: i128 = 7;
        // D s_304_6: cast zx s_304_3 -> bv
        let s_304_6: Bits = Bits::new(s_304_3 as u128, 32u16);
        // C s_304_7: const #0u : u25
        let s_304_7: u32 = 0;
        // C s_304_8: cast zx s_304_7 -> bv
        let s_304_8: Bits = Bits::new(s_304_7 as u128, 25u16);
        // C s_304_9: const #1u : u64
        let s_304_9: u64 = 1;
        // C s_304_10: cast zx s_304_9 -> bv
        let s_304_10: Bits = Bits::new(s_304_9 as u128, 64u16);
        // C s_304_11: lsl s_304_10 s_304_4
        let s_304_11: Bits = s_304_10 << s_304_4;
        // C s_304_12: sub s_304_11 s_304_10
        let s_304_12: Bits = ((s_304_11) - (s_304_10));
        // C s_304_13: and s_304_8 s_304_12
        let s_304_13: Bits = ((s_304_8) & (s_304_12));
        // C s_304_14: lsl s_304_13 s_304_5
        let s_304_14: Bits = s_304_13 << s_304_5;
        // C s_304_15: lsl s_304_12 s_304_5
        let s_304_15: Bits = s_304_12 << s_304_5;
        // C s_304_16: cmpl s_304_15
        let s_304_16: Bits = !s_304_15;
        // D s_304_17: and s_304_6 s_304_16
        let s_304_17: Bits = ((s_304_6) & (s_304_16));
        // D s_304_18: or s_304_17 s_304_14
        let s_304_18: Bits = ((s_304_17) | (s_304_14));
        // D s_304_19: cast reint s_304_18 -> u32
        let s_304_19: u32 = (s_304_18.value() as u32);
        // D s_304_20: call Mk_TRFCR_Type(s_304_19)
        let s_304_20: ProductType700c18a878c5601b = Mk_TRFCR_Type(
            state,
            tracer,
            s_304_19,
        );
        // D s_304_21: call TRFCR_write(s_304_20)
        let s_304_21: () = TRFCR_write(state, tracer, s_304_20);
        // C s_304_22: const #() : ()
        let s_304_22: () = ();
        // S s_304_23: call TRFCR_read(s_304_22)
        let s_304_23: ProductType700c18a878c5601b = TRFCR_read(state, tracer, s_304_22);
        // D s_304_24: write-var ga#36562 <= s_304_23
        fn_state.ga_36562 = s_304_23;
        // D s_304_25: read-var ga#36562.0:struct
        let s_304_25: u32 = fn_state.ga_36562._0;
        // C s_304_26: const #3s : i
        let s_304_26: i128 = 3;
        // C s_304_27: const #2s : i
        let s_304_27: i128 = 2;
        // D s_304_28: cast zx s_304_25 -> bv
        let s_304_28: Bits = Bits::new(s_304_25 as u128, 32u16);
        // C s_304_29: const #0u : u8
        let s_304_29: u8 = 0;
        // C s_304_30: cast zx s_304_29 -> bv
        let s_304_30: Bits = Bits::new(s_304_29 as u128, 3u16);
        // C s_304_31: const #1u : u64
        let s_304_31: u64 = 1;
        // C s_304_32: cast zx s_304_31 -> bv
        let s_304_32: Bits = Bits::new(s_304_31 as u128, 64u16);
        // C s_304_33: lsl s_304_32 s_304_26
        let s_304_33: Bits = s_304_32 << s_304_26;
        // C s_304_34: sub s_304_33 s_304_32
        let s_304_34: Bits = ((s_304_33) - (s_304_32));
        // C s_304_35: and s_304_30 s_304_34
        let s_304_35: Bits = ((s_304_30) & (s_304_34));
        // C s_304_36: lsl s_304_35 s_304_27
        let s_304_36: Bits = s_304_35 << s_304_27;
        // C s_304_37: lsl s_304_34 s_304_27
        let s_304_37: Bits = s_304_34 << s_304_27;
        // C s_304_38: cmpl s_304_37
        let s_304_38: Bits = !s_304_37;
        // D s_304_39: and s_304_28 s_304_38
        let s_304_39: Bits = ((s_304_28) & (s_304_38));
        // D s_304_40: or s_304_39 s_304_36
        let s_304_40: Bits = ((s_304_39) | (s_304_36));
        // D s_304_41: cast reint s_304_40 -> u32
        let s_304_41: u32 = (s_304_40.value() as u32);
        // D s_304_42: call Mk_TRFCR_Type(s_304_41)
        let s_304_42: ProductType700c18a878c5601b = Mk_TRFCR_Type(
            state,
            tracer,
            s_304_41,
        );
        // D s_304_43: call TRFCR_write(s_304_42)
        let s_304_43: () = TRFCR_write(state, tracer, s_304_42);
        // C s_304_44: const #() : ()
        let s_304_44: () = ();
        // S s_304_45: call TRFCR_read(s_304_44)
        let s_304_45: ProductType700c18a878c5601b = TRFCR_read(state, tracer, s_304_44);
        // C s_304_46: const #0u : u8
        let s_304_46: bool = false;
        // S s_304_47: call _update_TRFCR_Type_E1TRE(s_304_45, s_304_46)
        let s_304_47: ProductType700c18a878c5601b = u_update_TRFCR_Type_E1TRE(
            state,
            tracer,
            s_304_45,
            s_304_46,
        );
        // S s_304_48: call TRFCR_write(s_304_47)
        let s_304_48: () = TRFCR_write(state, tracer, s_304_47);
        // C s_304_49: const #() : ()
        let s_304_49: () = ();
        // S s_304_50: call TRFCR_read(s_304_49)
        let s_304_50: ProductType700c18a878c5601b = TRFCR_read(state, tracer, s_304_49);
        // C s_304_51: const #0u : u8
        let s_304_51: bool = false;
        // S s_304_52: call _update_TRFCR_Type_E0TRE(s_304_50, s_304_51)
        let s_304_52: ProductType700c18a878c5601b = u_update_TRFCR_Type_E0TRE(
            state,
            tracer,
            s_304_50,
            s_304_51,
        );
        // S s_304_53: call TRFCR_write(s_304_52)
        let s_304_53: () = TRFCR_write(state, tracer, s_304_52);
        // C s_304_54: const #() : ()
        let s_304_54: () = ();
        // S s_304_55: call CNTHP_CTL_read(s_304_54)
        let s_304_55: ProductType700c18a878c5601b = CNTHP_CTL_read(
            state,
            tracer,
            s_304_54,
        );
        // D s_304_56: write-var ga#36570 <= s_304_55
        fn_state.ga_36570 = s_304_55;
        // D s_304_57: read-var ga#36570.0:struct
        let s_304_57: u32 = fn_state.ga_36570._0;
        // C s_304_58: const #29s : i
        let s_304_58: i128 = 29;
        // C s_304_59: const #3s : i
        let s_304_59: i128 = 3;
        // D s_304_60: cast zx s_304_57 -> bv
        let s_304_60: Bits = Bits::new(s_304_57 as u128, 32u16);
        // C s_304_61: const #0u : u29
        let s_304_61: u32 = 0;
        // C s_304_62: cast zx s_304_61 -> bv
        let s_304_62: Bits = Bits::new(s_304_61 as u128, 29u16);
        // C s_304_63: const #1u : u64
        let s_304_63: u64 = 1;
        // C s_304_64: cast zx s_304_63 -> bv
        let s_304_64: Bits = Bits::new(s_304_63 as u128, 64u16);
        // C s_304_65: lsl s_304_64 s_304_58
        let s_304_65: Bits = s_304_64 << s_304_58;
        // C s_304_66: sub s_304_65 s_304_64
        let s_304_66: Bits = ((s_304_65) - (s_304_64));
        // C s_304_67: and s_304_62 s_304_66
        let s_304_67: Bits = ((s_304_62) & (s_304_66));
        // C s_304_68: lsl s_304_67 s_304_59
        let s_304_68: Bits = s_304_67 << s_304_59;
        // C s_304_69: lsl s_304_66 s_304_59
        let s_304_69: Bits = s_304_66 << s_304_59;
        // C s_304_70: cmpl s_304_69
        let s_304_70: Bits = !s_304_69;
        // D s_304_71: and s_304_60 s_304_70
        let s_304_71: Bits = ((s_304_60) & (s_304_70));
        // D s_304_72: or s_304_71 s_304_68
        let s_304_72: Bits = ((s_304_71) | (s_304_68));
        // D s_304_73: cast reint s_304_72 -> u32
        let s_304_73: u32 = (s_304_72.value() as u32);
        // D s_304_74: call Mk_CNTHP_CTL_Type(s_304_73)
        let s_304_74: ProductType700c18a878c5601b = Mk_CNTHP_CTL_Type(
            state,
            tracer,
            s_304_73,
        );
        // D s_304_75: call CNTHP_CTL_write(s_304_74)
        let s_304_75: () = CNTHP_CTL_write(state, tracer, s_304_74);
        // D s_304_76: read-var cold:u8
        let s_304_76: bool = fn_state.cold;
        // D s_304_77: not s_304_76
        let s_304_77: bool = !s_304_76;
        // N s_304_78: branch s_304_77 b499 b305
        if s_304_77 {
            return block_499(state, tracer, fn_state);
        } else {
            return block_305(state, tracer, fn_state);
        };
    }
    fn block_305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_305_0: const #0u : u8
        let s_305_0: bool = false;
        // D s_305_1: write-var gs#44749 <= s_305_0
        fn_state.gs_44749 = s_305_0;
        // N s_305_2: jump b306
        return block_306(state, tracer, fn_state);
    }
    fn block_306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_306_0: read-var gs#44749:u8
        let s_306_0: bool = fn_state.gs_44749;
        // N s_306_1: branch s_306_0 b498 b307
        if s_306_0 {
            return block_498(state, tracer, fn_state);
        } else {
            return block_307(state, tracer, fn_state);
        };
    }
    fn block_307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_307_0: const #() : ()
        let s_307_0: () = ();
        // S s_307_1: call CNTHP_CTL_read(s_307_0)
        let s_307_1: ProductType700c18a878c5601b = CNTHP_CTL_read(
            state,
            tracer,
            s_307_0,
        );
        // C s_307_2: const #1s : i64
        let s_307_2: i64 = 1;
        // C s_307_3: cast zx s_307_2 -> i
        let s_307_3: i128 = (i128::try_from(s_307_2).unwrap());
        // S s_307_4: call __UNKNOWN_bits(s_307_3)
        let s_307_4: Bits = u__UNKNOWN_bits(state, tracer, s_307_3);
        // S s_307_5: cast reint s_307_4 -> u8
        let s_307_5: bool = ((s_307_4.value()) != 0);
        // S s_307_6: call _update_CNTHP_CTL_Type_ENABLE(s_307_1, s_307_5)
        let s_307_6: ProductType700c18a878c5601b = u_update_CNTHP_CTL_Type_ENABLE(
            state,
            tracer,
            s_307_1,
            s_307_5,
        );
        // S s_307_7: call CNTHP_CTL_write(s_307_6)
        let s_307_7: () = CNTHP_CTL_write(state, tracer, s_307_6);
        // N s_307_8: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_308_0: const #() : ()
        let s_308_0: () = ();
        // S s_308_1: call CCSIDR_read(s_308_0)
        let s_308_1: ProductType700c18a878c5601b = CCSIDR_read(state, tracer, s_308_0);
        // D s_308_2: write-var ga#36582 <= s_308_1
        fn_state.ga_36582 = s_308_1;
        // D s_308_3: read-var ga#36582.0:struct
        let s_308_3: u32 = fn_state.ga_36582._0;
        // C s_308_4: const #8s : i
        let s_308_4: i128 = 8;
        // C s_308_5: const #24s : i
        let s_308_5: i128 = 24;
        // D s_308_6: cast zx s_308_3 -> bv
        let s_308_6: Bits = Bits::new(s_308_3 as u128, 32u16);
        // C s_308_7: const #0u : u8
        let s_308_7: u8 = 0;
        // C s_308_8: cast zx s_308_7 -> bv
        let s_308_8: Bits = Bits::new(s_308_7 as u128, 8u16);
        // C s_308_9: const #1u : u64
        let s_308_9: u64 = 1;
        // C s_308_10: cast zx s_308_9 -> bv
        let s_308_10: Bits = Bits::new(s_308_9 as u128, 64u16);
        // C s_308_11: lsl s_308_10 s_308_4
        let s_308_11: Bits = s_308_10 << s_308_4;
        // C s_308_12: sub s_308_11 s_308_10
        let s_308_12: Bits = ((s_308_11) - (s_308_10));
        // C s_308_13: and s_308_8 s_308_12
        let s_308_13: Bits = ((s_308_8) & (s_308_12));
        // C s_308_14: lsl s_308_13 s_308_5
        let s_308_14: Bits = s_308_13 << s_308_5;
        // C s_308_15: lsl s_308_12 s_308_5
        let s_308_15: Bits = s_308_12 << s_308_5;
        // C s_308_16: cmpl s_308_15
        let s_308_16: Bits = !s_308_15;
        // D s_308_17: and s_308_6 s_308_16
        let s_308_17: Bits = ((s_308_6) & (s_308_16));
        // D s_308_18: or s_308_17 s_308_14
        let s_308_18: Bits = ((s_308_17) | (s_308_14));
        // D s_308_19: cast reint s_308_18 -> u32
        let s_308_19: u32 = (s_308_18.value() as u32);
        // D s_308_20: call Mk_CCSIDR_Type(s_308_19)
        let s_308_20: ProductType700c18a878c5601b = Mk_CCSIDR_Type(
            state,
            tracer,
            s_308_19,
        );
        // D s_308_21: call CCSIDR_write(s_308_20)
        let s_308_21: () = CCSIDR_write(state, tracer, s_308_20);
        // C s_308_22: const #() : ()
        let s_308_22: () = ();
        // S s_308_23: call CCSIDR_read(s_308_22)
        let s_308_23: ProductType700c18a878c5601b = CCSIDR_read(state, tracer, s_308_22);
        // D s_308_24: write-var ga#36586 <= s_308_23
        fn_state.ga_36586 = s_308_23;
        // D s_308_25: read-var ga#36586.0:struct
        let s_308_25: u32 = fn_state.ga_36586._0;
        // C s_308_26: const #4s : i
        let s_308_26: i128 = 4;
        // C s_308_27: const #28s : i
        let s_308_27: i128 = 28;
        // D s_308_28: cast zx s_308_25 -> bv
        let s_308_28: Bits = Bits::new(s_308_25 as u128, 32u16);
        // C s_308_29: const #0u : u8
        let s_308_29: u8 = 0;
        // C s_308_30: cast zx s_308_29 -> bv
        let s_308_30: Bits = Bits::new(s_308_29 as u128, 4u16);
        // C s_308_31: const #1u : u64
        let s_308_31: u64 = 1;
        // C s_308_32: cast zx s_308_31 -> bv
        let s_308_32: Bits = Bits::new(s_308_31 as u128, 64u16);
        // C s_308_33: lsl s_308_32 s_308_26
        let s_308_33: Bits = s_308_32 << s_308_26;
        // C s_308_34: sub s_308_33 s_308_32
        let s_308_34: Bits = ((s_308_33) - (s_308_32));
        // C s_308_35: and s_308_30 s_308_34
        let s_308_35: Bits = ((s_308_30) & (s_308_34));
        // C s_308_36: lsl s_308_35 s_308_27
        let s_308_36: Bits = s_308_35 << s_308_27;
        // C s_308_37: lsl s_308_34 s_308_27
        let s_308_37: Bits = s_308_34 << s_308_27;
        // C s_308_38: cmpl s_308_37
        let s_308_38: Bits = !s_308_37;
        // D s_308_39: and s_308_28 s_308_38
        let s_308_39: Bits = ((s_308_28) & (s_308_38));
        // D s_308_40: or s_308_39 s_308_36
        let s_308_40: Bits = ((s_308_39) | (s_308_36));
        // D s_308_41: cast reint s_308_40 -> u32
        let s_308_41: u32 = (s_308_40.value() as u32);
        // D s_308_42: call Mk_CCSIDR_Type(s_308_41)
        let s_308_42: ProductType700c18a878c5601b = Mk_CCSIDR_Type(
            state,
            tracer,
            s_308_41,
        );
        // D s_308_43: call CCSIDR_write(s_308_42)
        let s_308_43: () = CCSIDR_write(state, tracer, s_308_42);
        // C s_308_44: const #0s : i
        let s_308_44: i128 = 0;
        // C s_308_45: const #19352u : u32
        let s_308_45: u32 = 19352;
        // D s_308_46: read-reg s_308_45:u32
        let s_308_46: u32 = {
            let value = state.read_register::<u32>(s_308_45 as isize);
            tracer.read_register(s_308_45 as isize, value);
            value
        };
        // D s_308_47: cast zx s_308_46 -> bv
        let s_308_47: Bits = Bits::new(s_308_46 as u128, 32u16);
        // C s_308_48: const #0u : u32
        let s_308_48: u32 = 0;
        // C s_308_49: cast zx s_308_48 -> bv
        let s_308_49: Bits = Bits::new(s_308_48 as u128, 32u16);
        // C s_308_50: const #31s : i
        let s_308_50: i128 = 31;
        // C s_308_51: const #1u : u64
        let s_308_51: u64 = 1;
        // C s_308_52: cast zx s_308_51 -> bv
        let s_308_52: Bits = Bits::new(s_308_51 as u128, 64u16);
        // C s_308_53: lsl s_308_52 s_308_50
        let s_308_53: Bits = s_308_52 << s_308_50;
        // C s_308_54: sub s_308_53 s_308_52
        let s_308_54: Bits = ((s_308_53) - (s_308_52));
        // C s_308_55: and s_308_49 s_308_54
        let s_308_55: Bits = ((s_308_49) & (s_308_54));
        // C s_308_56: lsl s_308_55 s_308_44
        let s_308_56: Bits = s_308_55 << s_308_44;
        // C s_308_57: lsl s_308_54 s_308_44
        let s_308_57: Bits = s_308_54 << s_308_44;
        // C s_308_58: cmpl s_308_57
        let s_308_58: Bits = !s_308_57;
        // D s_308_59: and s_308_47 s_308_58
        let s_308_59: Bits = ((s_308_47) & (s_308_58));
        // D s_308_60: or s_308_59 s_308_56
        let s_308_60: Bits = ((s_308_59) | (s_308_56));
        // D s_308_61: cast reint s_308_60 -> u32
        let s_308_61: u32 = (s_308_60.value() as u32);
        // C s_308_62: const #19352u : u32
        let s_308_62: u32 = 19352;
        // N s_308_63: write-reg s_308_62 <= s_308_61
        let s_308_63: () = {
            state.write_register::<u32>(s_308_62 as isize, s_308_61);
            tracer.write_register(s_308_62 as isize, s_308_61);
        };
        // C s_308_64: const #() : ()
        let s_308_64: () = ();
        // S s_308_65: call ICV_DIR_read(s_308_64)
        let s_308_65: ProductType700c18a878c5601b = ICV_DIR_read(
            state,
            tracer,
            s_308_64,
        );
        // D s_308_66: write-var ga#36590 <= s_308_65
        fn_state.ga_36590 = s_308_65;
        // D s_308_67: read-var ga#36590.0:struct
        let s_308_67: u32 = fn_state.ga_36590._0;
        // C s_308_68: const #8s : i
        let s_308_68: i128 = 8;
        // C s_308_69: const #24s : i
        let s_308_69: i128 = 24;
        // D s_308_70: cast zx s_308_67 -> bv
        let s_308_70: Bits = Bits::new(s_308_67 as u128, 32u16);
        // C s_308_71: const #0u : u8
        let s_308_71: u8 = 0;
        // C s_308_72: cast zx s_308_71 -> bv
        let s_308_72: Bits = Bits::new(s_308_71 as u128, 8u16);
        // C s_308_73: const #1u : u64
        let s_308_73: u64 = 1;
        // C s_308_74: cast zx s_308_73 -> bv
        let s_308_74: Bits = Bits::new(s_308_73 as u128, 64u16);
        // C s_308_75: lsl s_308_74 s_308_68
        let s_308_75: Bits = s_308_74 << s_308_68;
        // C s_308_76: sub s_308_75 s_308_74
        let s_308_76: Bits = ((s_308_75) - (s_308_74));
        // C s_308_77: and s_308_72 s_308_76
        let s_308_77: Bits = ((s_308_72) & (s_308_76));
        // C s_308_78: lsl s_308_77 s_308_69
        let s_308_78: Bits = s_308_77 << s_308_69;
        // C s_308_79: lsl s_308_76 s_308_69
        let s_308_79: Bits = s_308_76 << s_308_69;
        // C s_308_80: cmpl s_308_79
        let s_308_80: Bits = !s_308_79;
        // D s_308_81: and s_308_70 s_308_80
        let s_308_81: Bits = ((s_308_70) & (s_308_80));
        // D s_308_82: or s_308_81 s_308_78
        let s_308_82: Bits = ((s_308_81) | (s_308_78));
        // D s_308_83: cast reint s_308_82 -> u32
        let s_308_83: u32 = (s_308_82.value() as u32);
        // D s_308_84: call Mk_ICV_DIR_Type(s_308_83)
        let s_308_84: ProductType700c18a878c5601b = Mk_ICV_DIR_Type(
            state,
            tracer,
            s_308_83,
        );
        // D s_308_85: call ICV_DIR_write(s_308_84)
        let s_308_85: () = ICV_DIR_write(state, tracer, s_308_84);
        // C s_308_86: const #() : ()
        let s_308_86: () = ();
        // S s_308_87: call MPIDR_read(s_308_86)
        let s_308_87: ProductType700c18a878c5601b = MPIDR_read(state, tracer, s_308_86);
        // D s_308_88: write-var ga#36594 <= s_308_87
        fn_state.ga_36594 = s_308_87;
        // D s_308_89: read-var ga#36594.0:struct
        let s_308_89: u32 = fn_state.ga_36594._0;
        // C s_308_90: const #5s : i
        let s_308_90: i128 = 5;
        // C s_308_91: const #25s : i
        let s_308_91: i128 = 25;
        // D s_308_92: cast zx s_308_89 -> bv
        let s_308_92: Bits = Bits::new(s_308_89 as u128, 32u16);
        // C s_308_93: const #0u : u8
        let s_308_93: u8 = 0;
        // C s_308_94: cast zx s_308_93 -> bv
        let s_308_94: Bits = Bits::new(s_308_93 as u128, 5u16);
        // C s_308_95: const #1u : u64
        let s_308_95: u64 = 1;
        // C s_308_96: cast zx s_308_95 -> bv
        let s_308_96: Bits = Bits::new(s_308_95 as u128, 64u16);
        // C s_308_97: lsl s_308_96 s_308_90
        let s_308_97: Bits = s_308_96 << s_308_90;
        // C s_308_98: sub s_308_97 s_308_96
        let s_308_98: Bits = ((s_308_97) - (s_308_96));
        // C s_308_99: and s_308_94 s_308_98
        let s_308_99: Bits = ((s_308_94) & (s_308_98));
        // C s_308_100: lsl s_308_99 s_308_91
        let s_308_100: Bits = s_308_99 << s_308_91;
        // C s_308_101: lsl s_308_98 s_308_91
        let s_308_101: Bits = s_308_98 << s_308_91;
        // C s_308_102: cmpl s_308_101
        let s_308_102: Bits = !s_308_101;
        // D s_308_103: and s_308_92 s_308_102
        let s_308_103: Bits = ((s_308_92) & (s_308_102));
        // D s_308_104: or s_308_103 s_308_100
        let s_308_104: Bits = ((s_308_103) | (s_308_100));
        // D s_308_105: cast reint s_308_104 -> u32
        let s_308_105: u32 = (s_308_104.value() as u32);
        // D s_308_106: call Mk_MPIDR_Type(s_308_105)
        let s_308_106: ProductType700c18a878c5601b = Mk_MPIDR_Type(
            state,
            tracer,
            s_308_105,
        );
        // D s_308_107: call MPIDR_write(s_308_106)
        let s_308_107: () = MPIDR_write(state, tracer, s_308_106);
        // C s_308_108: const #() : ()
        let s_308_108: () = ();
        // S s_308_109: call DSPSR2_read(s_308_108)
        let s_308_109: ProductType700c18a878c5601b = DSPSR2_read(
            state,
            tracer,
            s_308_108,
        );
        // D s_308_110: write-var ga#36598 <= s_308_109
        fn_state.ga_36598 = s_308_109;
        // D s_308_111: read-var ga#36598.0:struct
        let s_308_111: u32 = fn_state.ga_36598._0;
        // C s_308_112: const #30s : i
        let s_308_112: i128 = 30;
        // C s_308_113: const #2s : i
        let s_308_113: i128 = 2;
        // D s_308_114: cast zx s_308_111 -> bv
        let s_308_114: Bits = Bits::new(s_308_111 as u128, 32u16);
        // C s_308_115: const #0u : u30
        let s_308_115: u32 = 0;
        // C s_308_116: cast zx s_308_115 -> bv
        let s_308_116: Bits = Bits::new(s_308_115 as u128, 30u16);
        // C s_308_117: const #1u : u64
        let s_308_117: u64 = 1;
        // C s_308_118: cast zx s_308_117 -> bv
        let s_308_118: Bits = Bits::new(s_308_117 as u128, 64u16);
        // C s_308_119: lsl s_308_118 s_308_112
        let s_308_119: Bits = s_308_118 << s_308_112;
        // C s_308_120: sub s_308_119 s_308_118
        let s_308_120: Bits = ((s_308_119) - (s_308_118));
        // C s_308_121: and s_308_116 s_308_120
        let s_308_121: Bits = ((s_308_116) & (s_308_120));
        // C s_308_122: lsl s_308_121 s_308_113
        let s_308_122: Bits = s_308_121 << s_308_113;
        // C s_308_123: lsl s_308_120 s_308_113
        let s_308_123: Bits = s_308_120 << s_308_113;
        // C s_308_124: cmpl s_308_123
        let s_308_124: Bits = !s_308_123;
        // D s_308_125: and s_308_114 s_308_124
        let s_308_125: Bits = ((s_308_114) & (s_308_124));
        // D s_308_126: or s_308_125 s_308_122
        let s_308_126: Bits = ((s_308_125) | (s_308_122));
        // D s_308_127: cast reint s_308_126 -> u32
        let s_308_127: u32 = (s_308_126.value() as u32);
        // D s_308_128: call Mk_DSPSR2_Type(s_308_127)
        let s_308_128: ProductType700c18a878c5601b = Mk_DSPSR2_Type(
            state,
            tracer,
            s_308_127,
        );
        // D s_308_129: call DSPSR2_write(s_308_128)
        let s_308_129: () = DSPSR2_write(state, tracer, s_308_128);
        // C s_308_130: const #() : ()
        let s_308_130: () = ();
        // S s_308_131: call DSPSR2_read(s_308_130)
        let s_308_131: ProductType700c18a878c5601b = DSPSR2_read(
            state,
            tracer,
            s_308_130,
        );
        // D s_308_132: write-var ga#36602 <= s_308_131
        fn_state.ga_36602 = s_308_131;
        // D s_308_133: read-var ga#36602.0:struct
        let s_308_133: u32 = fn_state.ga_36602._0;
        // C s_308_134: const #1s : i
        let s_308_134: i128 = 1;
        // C s_308_135: const #0s : i
        let s_308_135: i128 = 0;
        // D s_308_136: cast zx s_308_133 -> bv
        let s_308_136: Bits = Bits::new(s_308_133 as u128, 32u16);
        // C s_308_137: const #0u : u8
        let s_308_137: bool = false;
        // C s_308_138: cast zx s_308_137 -> bv
        let s_308_138: Bits = Bits::new(s_308_137 as u128, 1u16);
        // C s_308_139: const #1u : u64
        let s_308_139: u64 = 1;
        // C s_308_140: cast zx s_308_139 -> bv
        let s_308_140: Bits = Bits::new(s_308_139 as u128, 64u16);
        // C s_308_141: lsl s_308_140 s_308_134
        let s_308_141: Bits = s_308_140 << s_308_134;
        // C s_308_142: sub s_308_141 s_308_140
        let s_308_142: Bits = ((s_308_141) - (s_308_140));
        // C s_308_143: and s_308_138 s_308_142
        let s_308_143: Bits = ((s_308_138) & (s_308_142));
        // C s_308_144: lsl s_308_143 s_308_135
        let s_308_144: Bits = s_308_143 << s_308_135;
        // C s_308_145: lsl s_308_142 s_308_135
        let s_308_145: Bits = s_308_142 << s_308_135;
        // C s_308_146: cmpl s_308_145
        let s_308_146: Bits = !s_308_145;
        // D s_308_147: and s_308_136 s_308_146
        let s_308_147: Bits = ((s_308_136) & (s_308_146));
        // D s_308_148: or s_308_147 s_308_144
        let s_308_148: Bits = ((s_308_147) | (s_308_144));
        // D s_308_149: cast reint s_308_148 -> u32
        let s_308_149: u32 = (s_308_148.value() as u32);
        // D s_308_150: call Mk_DSPSR2_Type(s_308_149)
        let s_308_150: ProductType700c18a878c5601b = Mk_DSPSR2_Type(
            state,
            tracer,
            s_308_149,
        );
        // D s_308_151: call DSPSR2_write(s_308_150)
        let s_308_151: () = DSPSR2_write(state, tracer, s_308_150);
        // C s_308_152: const #() : ()
        let s_308_152: () = ();
        // S s_308_153: call ICC_HPPIR1_read(s_308_152)
        let s_308_153: ProductType700c18a878c5601b = ICC_HPPIR1_read(
            state,
            tracer,
            s_308_152,
        );
        // D s_308_154: write-var ga#36606 <= s_308_153
        fn_state.ga_36606 = s_308_153;
        // D s_308_155: read-var ga#36606.0:struct
        let s_308_155: u32 = fn_state.ga_36606._0;
        // C s_308_156: const #8s : i
        let s_308_156: i128 = 8;
        // C s_308_157: const #24s : i
        let s_308_157: i128 = 24;
        // D s_308_158: cast zx s_308_155 -> bv
        let s_308_158: Bits = Bits::new(s_308_155 as u128, 32u16);
        // C s_308_159: const #0u : u8
        let s_308_159: u8 = 0;
        // C s_308_160: cast zx s_308_159 -> bv
        let s_308_160: Bits = Bits::new(s_308_159 as u128, 8u16);
        // C s_308_161: const #1u : u64
        let s_308_161: u64 = 1;
        // C s_308_162: cast zx s_308_161 -> bv
        let s_308_162: Bits = Bits::new(s_308_161 as u128, 64u16);
        // C s_308_163: lsl s_308_162 s_308_156
        let s_308_163: Bits = s_308_162 << s_308_156;
        // C s_308_164: sub s_308_163 s_308_162
        let s_308_164: Bits = ((s_308_163) - (s_308_162));
        // C s_308_165: and s_308_160 s_308_164
        let s_308_165: Bits = ((s_308_160) & (s_308_164));
        // C s_308_166: lsl s_308_165 s_308_157
        let s_308_166: Bits = s_308_165 << s_308_157;
        // C s_308_167: lsl s_308_164 s_308_157
        let s_308_167: Bits = s_308_164 << s_308_157;
        // C s_308_168: cmpl s_308_167
        let s_308_168: Bits = !s_308_167;
        // D s_308_169: and s_308_158 s_308_168
        let s_308_169: Bits = ((s_308_158) & (s_308_168));
        // D s_308_170: or s_308_169 s_308_166
        let s_308_170: Bits = ((s_308_169) | (s_308_166));
        // D s_308_171: cast reint s_308_170 -> u32
        let s_308_171: u32 = (s_308_170.value() as u32);
        // D s_308_172: call Mk_ICC_HPPIR1_Type(s_308_171)
        let s_308_172: ProductType700c18a878c5601b = Mk_ICC_HPPIR1_Type(
            state,
            tracer,
            s_308_171,
        );
        // D s_308_173: call ICC_HPPIR1_write(s_308_172)
        let s_308_173: () = ICC_HPPIR1_write(state, tracer, s_308_172);
        // C s_308_174: const #() : ()
        let s_308_174: () = ();
        // S s_308_175: call ICC_SRE_read(s_308_174)
        let s_308_175: ProductType700c18a878c5601b = ICC_SRE_read(
            state,
            tracer,
            s_308_174,
        );
        // D s_308_176: write-var ga#36610 <= s_308_175
        fn_state.ga_36610 = s_308_175;
        // D s_308_177: read-var ga#36610.0:struct
        let s_308_177: u32 = fn_state.ga_36610._0;
        // C s_308_178: const #29s : i
        let s_308_178: i128 = 29;
        // C s_308_179: const #3s : i
        let s_308_179: i128 = 3;
        // D s_308_180: cast zx s_308_177 -> bv
        let s_308_180: Bits = Bits::new(s_308_177 as u128, 32u16);
        // C s_308_181: const #0u : u29
        let s_308_181: u32 = 0;
        // C s_308_182: cast zx s_308_181 -> bv
        let s_308_182: Bits = Bits::new(s_308_181 as u128, 29u16);
        // C s_308_183: const #1u : u64
        let s_308_183: u64 = 1;
        // C s_308_184: cast zx s_308_183 -> bv
        let s_308_184: Bits = Bits::new(s_308_183 as u128, 64u16);
        // C s_308_185: lsl s_308_184 s_308_178
        let s_308_185: Bits = s_308_184 << s_308_178;
        // C s_308_186: sub s_308_185 s_308_184
        let s_308_186: Bits = ((s_308_185) - (s_308_184));
        // C s_308_187: and s_308_182 s_308_186
        let s_308_187: Bits = ((s_308_182) & (s_308_186));
        // C s_308_188: lsl s_308_187 s_308_179
        let s_308_188: Bits = s_308_187 << s_308_179;
        // C s_308_189: lsl s_308_186 s_308_179
        let s_308_189: Bits = s_308_186 << s_308_179;
        // C s_308_190: cmpl s_308_189
        let s_308_190: Bits = !s_308_189;
        // D s_308_191: and s_308_180 s_308_190
        let s_308_191: Bits = ((s_308_180) & (s_308_190));
        // D s_308_192: or s_308_191 s_308_188
        let s_308_192: Bits = ((s_308_191) | (s_308_188));
        // D s_308_193: cast reint s_308_192 -> u32
        let s_308_193: u32 = (s_308_192.value() as u32);
        // D s_308_194: call Mk_ICC_SRE_Type(s_308_193)
        let s_308_194: ProductType700c18a878c5601b = Mk_ICC_SRE_Type(
            state,
            tracer,
            s_308_193,
        );
        // D s_308_195: call ICC_SRE_write(s_308_194)
        let s_308_195: () = ICC_SRE_write(state, tracer, s_308_194);
        // C s_308_196: const #() : ()
        let s_308_196: () = ();
        // S s_308_197: call ICC_SRE_read(s_308_196)
        let s_308_197: ProductType700c18a878c5601b = ICC_SRE_read(
            state,
            tracer,
            s_308_196,
        );
        // C s_308_198: const #0u : u8
        let s_308_198: bool = false;
        // S s_308_199: call _update_ICC_SRE_Type_DIB(s_308_197, s_308_198)
        let s_308_199: ProductType700c18a878c5601b = u_update_ICC_SRE_Type_DIB(
            state,
            tracer,
            s_308_197,
            s_308_198,
        );
        // S s_308_200: call ICC_SRE_write(s_308_199)
        let s_308_200: () = ICC_SRE_write(state, tracer, s_308_199);
        // C s_308_201: const #() : ()
        let s_308_201: () = ();
        // S s_308_202: call ICC_SRE_read(s_308_201)
        let s_308_202: ProductType700c18a878c5601b = ICC_SRE_read(
            state,
            tracer,
            s_308_201,
        );
        // C s_308_203: const #0u : u8
        let s_308_203: bool = false;
        // S s_308_204: call _update_ICC_SRE_Type_DFB(s_308_202, s_308_203)
        let s_308_204: ProductType700c18a878c5601b = u_update_ICC_SRE_Type_DFB(
            state,
            tracer,
            s_308_202,
            s_308_203,
        );
        // S s_308_205: call ICC_SRE_write(s_308_204)
        let s_308_205: () = ICC_SRE_write(state, tracer, s_308_204);
        // C s_308_206: const #() : ()
        let s_308_206: () = ();
        // S s_308_207: call ICC_SRE_read(s_308_206)
        let s_308_207: ProductType700c18a878c5601b = ICC_SRE_read(
            state,
            tracer,
            s_308_206,
        );
        // C s_308_208: const #0u : u8
        let s_308_208: bool = false;
        // S s_308_209: call _update_ICC_SRE_Type_SRE(s_308_207, s_308_208)
        let s_308_209: ProductType700c18a878c5601b = u_update_ICC_SRE_Type_SRE(
            state,
            tracer,
            s_308_207,
            s_308_208,
        );
        // S s_308_210: call ICC_SRE_write(s_308_209)
        let s_308_210: () = ICC_SRE_write(state, tracer, s_308_209);
        // C s_308_211: const #15048u : u32
        let s_308_211: u32 = 15048;
        // D s_308_212: read-reg s_308_211:struct
        let s_308_212: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_308_211 as isize);
            tracer.read_register(s_308_211 as isize, value);
            value
        };
        // C s_308_213: const #15048u : u32
        let s_308_213: u32 = 15048;
        // N s_308_214: write-reg s_308_213 <= s_308_212
        let s_308_214: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_308_213 as isize, s_308_212);
            tracer.write_register(s_308_213 as isize, s_308_212);
        };
        // D s_308_215: read-var cold:u8
        let s_308_215: bool = fn_state.cold;
        // N s_308_216: branch s_308_215 b497 b309
        if s_308_215 {
            return block_497(state, tracer, fn_state);
        } else {
            return block_309(state, tracer, fn_state);
        };
    }
    fn block_309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_309_0: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_310_0: const #15048u : u32
        let s_310_0: u32 = 15048;
        // D s_310_1: read-reg s_310_0:struct
        let s_310_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_0 as isize);
            tracer.read_register(s_310_0 as isize, value);
            value
        };
        // C s_310_2: const #15048u : u32
        let s_310_2: u32 = 15048;
        // N s_310_3: write-reg s_310_2 <= s_310_1
        let s_310_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_2 as isize, s_310_1);
            tracer.write_register(s_310_2 as isize, s_310_1);
        };
        // C s_310_4: const #15048u : u32
        let s_310_4: u32 = 15048;
        // D s_310_5: read-reg s_310_4:struct
        let s_310_5: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_4 as isize);
            tracer.read_register(s_310_4 as isize, value);
            value
        };
        // C s_310_6: const #15048u : u32
        let s_310_6: u32 = 15048;
        // N s_310_7: write-reg s_310_6 <= s_310_5
        let s_310_7: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_6 as isize, s_310_5);
            tracer.write_register(s_310_6 as isize, s_310_5);
        };
        // C s_310_8: const #0u : u8
        let s_310_8: bool = false;
        // S s_310_9: call Bit(s_310_8)
        let s_310_9: bool = Bit(state, tracer, s_310_8);
        // C s_310_10: const #15048u : u32
        let s_310_10: u32 = 15048;
        // D s_310_11: read-reg s_310_10:struct
        let s_310_11: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_10 as isize);
            tracer.read_register(s_310_10 as isize, value);
            value
        };
        // C s_310_12: const #15048u : u32
        let s_310_12: u32 = 15048;
        // N s_310_13: write-reg s_310_12 <= s_310_11
        let s_310_13: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_12 as isize, s_310_11);
            tracer.write_register(s_310_12 as isize, s_310_11);
        };
        // C s_310_14: const #15048u : u32
        let s_310_14: u32 = 15048;
        // D s_310_15: read-reg s_310_14:struct
        let s_310_15: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_14 as isize);
            tracer.read_register(s_310_14 as isize, value);
            value
        };
        // C s_310_16: const #15048u : u32
        let s_310_16: u32 = 15048;
        // N s_310_17: write-reg s_310_16 <= s_310_15
        let s_310_17: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_16 as isize, s_310_15);
            tracer.write_register(s_310_16 as isize, s_310_15);
        };
        // C s_310_18: const #15048u : u32
        let s_310_18: u32 = 15048;
        // D s_310_19: read-reg s_310_18:struct
        let s_310_19: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_18 as isize);
            tracer.read_register(s_310_18 as isize, value);
            value
        };
        // C s_310_20: const #15048u : u32
        let s_310_20: u32 = 15048;
        // N s_310_21: write-reg s_310_20 <= s_310_19
        let s_310_21: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_20 as isize, s_310_19);
            tracer.write_register(s_310_20 as isize, s_310_19);
        };
        // C s_310_22: const #15048u : u32
        let s_310_22: u32 = 15048;
        // D s_310_23: read-reg s_310_22:struct
        let s_310_23: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_22 as isize);
            tracer.read_register(s_310_22 as isize, value);
            value
        };
        // C s_310_24: const #15048u : u32
        let s_310_24: u32 = 15048;
        // N s_310_25: write-reg s_310_24 <= s_310_23
        let s_310_25: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_24 as isize, s_310_23);
            tracer.write_register(s_310_24 as isize, s_310_23);
        };
        // C s_310_26: const #15048u : u32
        let s_310_26: u32 = 15048;
        // D s_310_27: read-reg s_310_26:struct
        let s_310_27: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_26 as isize);
            tracer.read_register(s_310_26 as isize, value);
            value
        };
        // C s_310_28: const #15048u : u32
        let s_310_28: u32 = 15048;
        // N s_310_29: write-reg s_310_28 <= s_310_27
        let s_310_29: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_28 as isize, s_310_27);
            tracer.write_register(s_310_28 as isize, s_310_27);
        };
        // C s_310_30: const #15048u : u32
        let s_310_30: u32 = 15048;
        // D s_310_31: read-reg s_310_30:struct
        let s_310_31: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_30 as isize);
            tracer.read_register(s_310_30 as isize, value);
            value
        };
        // C s_310_32: const #15048u : u32
        let s_310_32: u32 = 15048;
        // N s_310_33: write-reg s_310_32 <= s_310_31
        let s_310_33: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_32 as isize, s_310_31);
            tracer.write_register(s_310_32 as isize, s_310_31);
        };
        // C s_310_34: const #0u : u8
        let s_310_34: bool = false;
        // S s_310_35: call Bit(s_310_34)
        let s_310_35: bool = Bit(state, tracer, s_310_34);
        // C s_310_36: const #15048u : u32
        let s_310_36: u32 = 15048;
        // D s_310_37: read-reg s_310_36:struct
        let s_310_37: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_36 as isize);
            tracer.read_register(s_310_36 as isize, value);
            value
        };
        // C s_310_38: const #15048u : u32
        let s_310_38: u32 = 15048;
        // N s_310_39: write-reg s_310_38 <= s_310_37
        let s_310_39: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_38 as isize, s_310_37);
            tracer.write_register(s_310_38 as isize, s_310_37);
        };
        // C s_310_40: const #15048u : u32
        let s_310_40: u32 = 15048;
        // D s_310_41: read-reg s_310_40:struct
        let s_310_41: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_40 as isize);
            tracer.read_register(s_310_40 as isize, value);
            value
        };
        // C s_310_42: const #15048u : u32
        let s_310_42: u32 = 15048;
        // N s_310_43: write-reg s_310_42 <= s_310_41
        let s_310_43: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_42 as isize, s_310_41);
            tracer.write_register(s_310_42 as isize, s_310_41);
        };
        // C s_310_44: const #15048u : u32
        let s_310_44: u32 = 15048;
        // D s_310_45: read-reg s_310_44:struct
        let s_310_45: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_310_44 as isize);
            tracer.read_register(s_310_44 as isize, value);
            value
        };
        // C s_310_46: const #15048u : u32
        let s_310_46: u32 = 15048;
        // N s_310_47: write-reg s_310_46 <= s_310_45
        let s_310_47: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_310_46 as isize, s_310_45);
            tracer.write_register(s_310_46 as isize, s_310_45);
        };
        // C s_310_48: const #() : ()
        let s_310_48: () = ();
        // S s_310_49: call AMUSERENR_read(s_310_48)
        let s_310_49: ProductType700c18a878c5601b = AMUSERENR_read(
            state,
            tracer,
            s_310_48,
        );
        // D s_310_50: write-var ga#36648 <= s_310_49
        fn_state.ga_36648 = s_310_49;
        // D s_310_51: read-var ga#36648.0:struct
        let s_310_51: u32 = fn_state.ga_36648._0;
        // C s_310_52: const #31s : i
        let s_310_52: i128 = 31;
        // C s_310_53: const #1s : i
        let s_310_53: i128 = 1;
        // D s_310_54: cast zx s_310_51 -> bv
        let s_310_54: Bits = Bits::new(s_310_51 as u128, 32u16);
        // C s_310_55: const #0u : u31
        let s_310_55: u32 = 0;
        // C s_310_56: cast zx s_310_55 -> bv
        let s_310_56: Bits = Bits::new(s_310_55 as u128, 31u16);
        // C s_310_57: const #1u : u64
        let s_310_57: u64 = 1;
        // C s_310_58: cast zx s_310_57 -> bv
        let s_310_58: Bits = Bits::new(s_310_57 as u128, 64u16);
        // C s_310_59: lsl s_310_58 s_310_52
        let s_310_59: Bits = s_310_58 << s_310_52;
        // C s_310_60: sub s_310_59 s_310_58
        let s_310_60: Bits = ((s_310_59) - (s_310_58));
        // C s_310_61: and s_310_56 s_310_60
        let s_310_61: Bits = ((s_310_56) & (s_310_60));
        // C s_310_62: lsl s_310_61 s_310_53
        let s_310_62: Bits = s_310_61 << s_310_53;
        // C s_310_63: lsl s_310_60 s_310_53
        let s_310_63: Bits = s_310_60 << s_310_53;
        // C s_310_64: cmpl s_310_63
        let s_310_64: Bits = !s_310_63;
        // D s_310_65: and s_310_54 s_310_64
        let s_310_65: Bits = ((s_310_54) & (s_310_64));
        // D s_310_66: or s_310_65 s_310_62
        let s_310_66: Bits = ((s_310_65) | (s_310_62));
        // D s_310_67: cast reint s_310_66 -> u32
        let s_310_67: u32 = (s_310_66.value() as u32);
        // D s_310_68: call Mk_AMUSERENR_Type(s_310_67)
        let s_310_68: ProductType700c18a878c5601b = Mk_AMUSERENR_Type(
            state,
            tracer,
            s_310_67,
        );
        // D s_310_69: call AMUSERENR_write(s_310_68)
        let s_310_69: () = AMUSERENR_write(state, tracer, s_310_68);
        // C s_310_70: const #() : ()
        let s_310_70: () = ();
        // S s_310_71: call AMCGCR_read(s_310_70)
        let s_310_71: ProductType700c18a878c5601b = AMCGCR_read(state, tracer, s_310_70);
        // D s_310_72: write-var ga#36652 <= s_310_71
        fn_state.ga_36652 = s_310_71;
        // D s_310_73: read-var ga#36652.0:struct
        let s_310_73: u32 = fn_state.ga_36652._0;
        // C s_310_74: const #16s : i
        let s_310_74: i128 = 16;
        // C s_310_75: const #16s : i
        let s_310_75: i128 = 16;
        // D s_310_76: cast zx s_310_73 -> bv
        let s_310_76: Bits = Bits::new(s_310_73 as u128, 32u16);
        // C s_310_77: const #0u : u16
        let s_310_77: u16 = 0;
        // C s_310_78: cast zx s_310_77 -> bv
        let s_310_78: Bits = Bits::new(s_310_77 as u128, 16u16);
        // C s_310_79: const #1u : u64
        let s_310_79: u64 = 1;
        // C s_310_80: cast zx s_310_79 -> bv
        let s_310_80: Bits = Bits::new(s_310_79 as u128, 64u16);
        // C s_310_81: lsl s_310_80 s_310_74
        let s_310_81: Bits = s_310_80 << s_310_74;
        // C s_310_82: sub s_310_81 s_310_80
        let s_310_82: Bits = ((s_310_81) - (s_310_80));
        // C s_310_83: and s_310_78 s_310_82
        let s_310_83: Bits = ((s_310_78) & (s_310_82));
        // C s_310_84: lsl s_310_83 s_310_75
        let s_310_84: Bits = s_310_83 << s_310_75;
        // C s_310_85: lsl s_310_82 s_310_75
        let s_310_85: Bits = s_310_82 << s_310_75;
        // C s_310_86: cmpl s_310_85
        let s_310_86: Bits = !s_310_85;
        // D s_310_87: and s_310_76 s_310_86
        let s_310_87: Bits = ((s_310_76) & (s_310_86));
        // D s_310_88: or s_310_87 s_310_84
        let s_310_88: Bits = ((s_310_87) | (s_310_84));
        // D s_310_89: cast reint s_310_88 -> u32
        let s_310_89: u32 = (s_310_88.value() as u32);
        // D s_310_90: call Mk_AMCGCR_Type(s_310_89)
        let s_310_90: ProductType700c18a878c5601b = Mk_AMCGCR_Type(
            state,
            tracer,
            s_310_89,
        );
        // D s_310_91: call AMCGCR_write(s_310_90)
        let s_310_91: () = AMCGCR_write(state, tracer, s_310_90);
        // C s_310_92: const #() : ()
        let s_310_92: () = ();
        // S s_310_93: call AMCFGR_read(s_310_92)
        let s_310_93: ProductType700c18a878c5601b = AMCFGR_read(state, tracer, s_310_92);
        // D s_310_94: write-var ga#36656 <= s_310_93
        fn_state.ga_36656 = s_310_93;
        // D s_310_95: read-var ga#36656.0:struct
        let s_310_95: u32 = fn_state.ga_36656._0;
        // C s_310_96: const #3s : i
        let s_310_96: i128 = 3;
        // C s_310_97: const #25s : i
        let s_310_97: i128 = 25;
        // D s_310_98: cast zx s_310_95 -> bv
        let s_310_98: Bits = Bits::new(s_310_95 as u128, 32u16);
        // C s_310_99: const #0u : u8
        let s_310_99: u8 = 0;
        // C s_310_100: cast zx s_310_99 -> bv
        let s_310_100: Bits = Bits::new(s_310_99 as u128, 3u16);
        // C s_310_101: const #1u : u64
        let s_310_101: u64 = 1;
        // C s_310_102: cast zx s_310_101 -> bv
        let s_310_102: Bits = Bits::new(s_310_101 as u128, 64u16);
        // C s_310_103: lsl s_310_102 s_310_96
        let s_310_103: Bits = s_310_102 << s_310_96;
        // C s_310_104: sub s_310_103 s_310_102
        let s_310_104: Bits = ((s_310_103) - (s_310_102));
        // C s_310_105: and s_310_100 s_310_104
        let s_310_105: Bits = ((s_310_100) & (s_310_104));
        // C s_310_106: lsl s_310_105 s_310_97
        let s_310_106: Bits = s_310_105 << s_310_97;
        // C s_310_107: lsl s_310_104 s_310_97
        let s_310_107: Bits = s_310_104 << s_310_97;
        // C s_310_108: cmpl s_310_107
        let s_310_108: Bits = !s_310_107;
        // D s_310_109: and s_310_98 s_310_108
        let s_310_109: Bits = ((s_310_98) & (s_310_108));
        // D s_310_110: or s_310_109 s_310_106
        let s_310_110: Bits = ((s_310_109) | (s_310_106));
        // D s_310_111: cast reint s_310_110 -> u32
        let s_310_111: u32 = (s_310_110.value() as u32);
        // D s_310_112: call Mk_AMCFGR_Type(s_310_111)
        let s_310_112: ProductType700c18a878c5601b = Mk_AMCFGR_Type(
            state,
            tracer,
            s_310_111,
        );
        // D s_310_113: call AMCFGR_write(s_310_112)
        let s_310_113: () = AMCFGR_write(state, tracer, s_310_112);
        // C s_310_114: const #() : ()
        let s_310_114: () = ();
        // S s_310_115: call AMCFGR_read(s_310_114)
        let s_310_115: ProductType700c18a878c5601b = AMCFGR_read(
            state,
            tracer,
            s_310_114,
        );
        // D s_310_116: write-var ga#36660 <= s_310_115
        fn_state.ga_36660 = s_310_115;
        // D s_310_117: read-var ga#36660.0:struct
        let s_310_117: u32 = fn_state.ga_36660._0;
        // C s_310_118: const #10s : i
        let s_310_118: i128 = 10;
        // C s_310_119: const #14s : i
        let s_310_119: i128 = 14;
        // D s_310_120: cast zx s_310_117 -> bv
        let s_310_120: Bits = Bits::new(s_310_117 as u128, 32u16);
        // C s_310_121: const #0u : u10
        let s_310_121: u16 = 0;
        // C s_310_122: cast zx s_310_121 -> bv
        let s_310_122: Bits = Bits::new(s_310_121 as u128, 10u16);
        // C s_310_123: const #1u : u64
        let s_310_123: u64 = 1;
        // C s_310_124: cast zx s_310_123 -> bv
        let s_310_124: Bits = Bits::new(s_310_123 as u128, 64u16);
        // C s_310_125: lsl s_310_124 s_310_118
        let s_310_125: Bits = s_310_124 << s_310_118;
        // C s_310_126: sub s_310_125 s_310_124
        let s_310_126: Bits = ((s_310_125) - (s_310_124));
        // C s_310_127: and s_310_122 s_310_126
        let s_310_127: Bits = ((s_310_122) & (s_310_126));
        // C s_310_128: lsl s_310_127 s_310_119
        let s_310_128: Bits = s_310_127 << s_310_119;
        // C s_310_129: lsl s_310_126 s_310_119
        let s_310_129: Bits = s_310_126 << s_310_119;
        // C s_310_130: cmpl s_310_129
        let s_310_130: Bits = !s_310_129;
        // D s_310_131: and s_310_120 s_310_130
        let s_310_131: Bits = ((s_310_120) & (s_310_130));
        // D s_310_132: or s_310_131 s_310_128
        let s_310_132: Bits = ((s_310_131) | (s_310_128));
        // D s_310_133: cast reint s_310_132 -> u32
        let s_310_133: u32 = (s_310_132.value() as u32);
        // D s_310_134: call Mk_AMCFGR_Type(s_310_133)
        let s_310_134: ProductType700c18a878c5601b = Mk_AMCFGR_Type(
            state,
            tracer,
            s_310_133,
        );
        // D s_310_135: call AMCFGR_write(s_310_134)
        let s_310_135: () = AMCFGR_write(state, tracer, s_310_134);
        // C s_310_136: const #() : ()
        let s_310_136: () = ();
        // S s_310_137: call AMCNTENCLR1_read(s_310_136)
        let s_310_137: ProductType700c18a878c5601b = AMCNTENCLR1_read(
            state,
            tracer,
            s_310_136,
        );
        // D s_310_138: write-var ga#36664 <= s_310_137
        fn_state.ga_36664 = s_310_137;
        // D s_310_139: read-var ga#36664.0:struct
        let s_310_139: u32 = fn_state.ga_36664._0;
        // C s_310_140: const #16s : i
        let s_310_140: i128 = 16;
        // C s_310_141: const #16s : i
        let s_310_141: i128 = 16;
        // D s_310_142: cast zx s_310_139 -> bv
        let s_310_142: Bits = Bits::new(s_310_139 as u128, 32u16);
        // C s_310_143: const #0u : u16
        let s_310_143: u16 = 0;
        // C s_310_144: cast zx s_310_143 -> bv
        let s_310_144: Bits = Bits::new(s_310_143 as u128, 16u16);
        // C s_310_145: const #1u : u64
        let s_310_145: u64 = 1;
        // C s_310_146: cast zx s_310_145 -> bv
        let s_310_146: Bits = Bits::new(s_310_145 as u128, 64u16);
        // C s_310_147: lsl s_310_146 s_310_140
        let s_310_147: Bits = s_310_146 << s_310_140;
        // C s_310_148: sub s_310_147 s_310_146
        let s_310_148: Bits = ((s_310_147) - (s_310_146));
        // C s_310_149: and s_310_144 s_310_148
        let s_310_149: Bits = ((s_310_144) & (s_310_148));
        // C s_310_150: lsl s_310_149 s_310_141
        let s_310_150: Bits = s_310_149 << s_310_141;
        // C s_310_151: lsl s_310_148 s_310_141
        let s_310_151: Bits = s_310_148 << s_310_141;
        // C s_310_152: cmpl s_310_151
        let s_310_152: Bits = !s_310_151;
        // D s_310_153: and s_310_142 s_310_152
        let s_310_153: Bits = ((s_310_142) & (s_310_152));
        // D s_310_154: or s_310_153 s_310_150
        let s_310_154: Bits = ((s_310_153) | (s_310_150));
        // D s_310_155: cast reint s_310_154 -> u32
        let s_310_155: u32 = (s_310_154.value() as u32);
        // D s_310_156: call Mk_AMCNTENCLR1_Type(s_310_155)
        let s_310_156: ProductType700c18a878c5601b = Mk_AMCNTENCLR1_Type(
            state,
            tracer,
            s_310_155,
        );
        // D s_310_157: call AMCNTENCLR1_write(s_310_156)
        let s_310_157: () = AMCNTENCLR1_write(state, tracer, s_310_156);
        // D s_310_158: read-var cold:u8
        let s_310_158: bool = fn_state.cold;
        // N s_310_159: branch s_310_158 b496 b311
        if s_310_158 {
            return block_496(state, tracer, fn_state);
        } else {
            return block_311(state, tracer, fn_state);
        };
    }
    fn block_311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_311_0: jump b312
        return block_312(state, tracer, fn_state);
    }
    fn block_312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_312_0: const #() : ()
        let s_312_0: () = ();
        // S s_312_1: call AMCNTENSET0_read(s_312_0)
        let s_312_1: ProductType700c18a878c5601b = AMCNTENSET0_read(
            state,
            tracer,
            s_312_0,
        );
        // D s_312_2: write-var ga#36672 <= s_312_1
        fn_state.ga_36672 = s_312_1;
        // D s_312_3: read-var ga#36672.0:struct
        let s_312_3: u32 = fn_state.ga_36672._0;
        // C s_312_4: const #16s : i
        let s_312_4: i128 = 16;
        // C s_312_5: const #16s : i
        let s_312_5: i128 = 16;
        // D s_312_6: cast zx s_312_3 -> bv
        let s_312_6: Bits = Bits::new(s_312_3 as u128, 32u16);
        // C s_312_7: const #0u : u16
        let s_312_7: u16 = 0;
        // C s_312_8: cast zx s_312_7 -> bv
        let s_312_8: Bits = Bits::new(s_312_7 as u128, 16u16);
        // C s_312_9: const #1u : u64
        let s_312_9: u64 = 1;
        // C s_312_10: cast zx s_312_9 -> bv
        let s_312_10: Bits = Bits::new(s_312_9 as u128, 64u16);
        // C s_312_11: lsl s_312_10 s_312_4
        let s_312_11: Bits = s_312_10 << s_312_4;
        // C s_312_12: sub s_312_11 s_312_10
        let s_312_12: Bits = ((s_312_11) - (s_312_10));
        // C s_312_13: and s_312_8 s_312_12
        let s_312_13: Bits = ((s_312_8) & (s_312_12));
        // C s_312_14: lsl s_312_13 s_312_5
        let s_312_14: Bits = s_312_13 << s_312_5;
        // C s_312_15: lsl s_312_12 s_312_5
        let s_312_15: Bits = s_312_12 << s_312_5;
        // C s_312_16: cmpl s_312_15
        let s_312_16: Bits = !s_312_15;
        // D s_312_17: and s_312_6 s_312_16
        let s_312_17: Bits = ((s_312_6) & (s_312_16));
        // D s_312_18: or s_312_17 s_312_14
        let s_312_18: Bits = ((s_312_17) | (s_312_14));
        // D s_312_19: cast reint s_312_18 -> u32
        let s_312_19: u32 = (s_312_18.value() as u32);
        // D s_312_20: call Mk_AMCNTENSET0_Type(s_312_19)
        let s_312_20: ProductType700c18a878c5601b = Mk_AMCNTENSET0_Type(
            state,
            tracer,
            s_312_19,
        );
        // D s_312_21: call AMCNTENSET0_write(s_312_20)
        let s_312_21: () = AMCNTENSET0_write(state, tracer, s_312_20);
        // C s_312_22: const #() : ()
        let s_312_22: () = ();
        // S s_312_23: call AMCNTENSET0_read(s_312_22)
        let s_312_23: ProductType700c18a878c5601b = AMCNTENSET0_read(
            state,
            tracer,
            s_312_22,
        );
        // D s_312_24: write-var ga#36676 <= s_312_23
        fn_state.ga_36676 = s_312_23;
        // D s_312_25: read-var ga#36676.0:struct
        let s_312_25: u32 = fn_state.ga_36676._0;
        // C s_312_26: const #12s : i
        let s_312_26: i128 = 12;
        // C s_312_27: const #4s : i
        let s_312_27: i128 = 4;
        // D s_312_28: cast zx s_312_25 -> bv
        let s_312_28: Bits = Bits::new(s_312_25 as u128, 32u16);
        // C s_312_29: const #0u : u12
        let s_312_29: u16 = 0;
        // C s_312_30: cast zx s_312_29 -> bv
        let s_312_30: Bits = Bits::new(s_312_29 as u128, 12u16);
        // C s_312_31: const #1u : u64
        let s_312_31: u64 = 1;
        // C s_312_32: cast zx s_312_31 -> bv
        let s_312_32: Bits = Bits::new(s_312_31 as u128, 64u16);
        // C s_312_33: lsl s_312_32 s_312_26
        let s_312_33: Bits = s_312_32 << s_312_26;
        // C s_312_34: sub s_312_33 s_312_32
        let s_312_34: Bits = ((s_312_33) - (s_312_32));
        // C s_312_35: and s_312_30 s_312_34
        let s_312_35: Bits = ((s_312_30) & (s_312_34));
        // C s_312_36: lsl s_312_35 s_312_27
        let s_312_36: Bits = s_312_35 << s_312_27;
        // C s_312_37: lsl s_312_34 s_312_27
        let s_312_37: Bits = s_312_34 << s_312_27;
        // C s_312_38: cmpl s_312_37
        let s_312_38: Bits = !s_312_37;
        // D s_312_39: and s_312_28 s_312_38
        let s_312_39: Bits = ((s_312_28) & (s_312_38));
        // D s_312_40: or s_312_39 s_312_36
        let s_312_40: Bits = ((s_312_39) | (s_312_36));
        // D s_312_41: cast reint s_312_40 -> u32
        let s_312_41: u32 = (s_312_40.value() as u32);
        // D s_312_42: call Mk_AMCNTENSET0_Type(s_312_41)
        let s_312_42: ProductType700c18a878c5601b = Mk_AMCNTENSET0_Type(
            state,
            tracer,
            s_312_41,
        );
        // D s_312_43: call AMCNTENSET0_write(s_312_42)
        let s_312_43: () = AMCNTENSET0_write(state, tracer, s_312_42);
        // D s_312_44: read-var cold:u8
        let s_312_44: bool = fn_state.cold;
        // N s_312_45: branch s_312_44 b495 b313
        if s_312_44 {
            return block_495(state, tracer, fn_state);
        } else {
            return block_313(state, tracer, fn_state);
        };
    }
    fn block_313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_313_0: jump b314
        return block_314(state, tracer, fn_state);
    }
    fn block_314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_314_0: const #() : ()
        let s_314_0: () = ();
        // S s_314_1: call AMCNTENCLR0_read(s_314_0)
        let s_314_1: ProductType700c18a878c5601b = AMCNTENCLR0_read(
            state,
            tracer,
            s_314_0,
        );
        // D s_314_2: write-var ga#36684 <= s_314_1
        fn_state.ga_36684 = s_314_1;
        // D s_314_3: read-var ga#36684.0:struct
        let s_314_3: u32 = fn_state.ga_36684._0;
        // C s_314_4: const #16s : i
        let s_314_4: i128 = 16;
        // C s_314_5: const #16s : i
        let s_314_5: i128 = 16;
        // D s_314_6: cast zx s_314_3 -> bv
        let s_314_6: Bits = Bits::new(s_314_3 as u128, 32u16);
        // C s_314_7: const #0u : u16
        let s_314_7: u16 = 0;
        // C s_314_8: cast zx s_314_7 -> bv
        let s_314_8: Bits = Bits::new(s_314_7 as u128, 16u16);
        // C s_314_9: const #1u : u64
        let s_314_9: u64 = 1;
        // C s_314_10: cast zx s_314_9 -> bv
        let s_314_10: Bits = Bits::new(s_314_9 as u128, 64u16);
        // C s_314_11: lsl s_314_10 s_314_4
        let s_314_11: Bits = s_314_10 << s_314_4;
        // C s_314_12: sub s_314_11 s_314_10
        let s_314_12: Bits = ((s_314_11) - (s_314_10));
        // C s_314_13: and s_314_8 s_314_12
        let s_314_13: Bits = ((s_314_8) & (s_314_12));
        // C s_314_14: lsl s_314_13 s_314_5
        let s_314_14: Bits = s_314_13 << s_314_5;
        // C s_314_15: lsl s_314_12 s_314_5
        let s_314_15: Bits = s_314_12 << s_314_5;
        // C s_314_16: cmpl s_314_15
        let s_314_16: Bits = !s_314_15;
        // D s_314_17: and s_314_6 s_314_16
        let s_314_17: Bits = ((s_314_6) & (s_314_16));
        // D s_314_18: or s_314_17 s_314_14
        let s_314_18: Bits = ((s_314_17) | (s_314_14));
        // D s_314_19: cast reint s_314_18 -> u32
        let s_314_19: u32 = (s_314_18.value() as u32);
        // D s_314_20: call Mk_AMCNTENCLR0_Type(s_314_19)
        let s_314_20: ProductType700c18a878c5601b = Mk_AMCNTENCLR0_Type(
            state,
            tracer,
            s_314_19,
        );
        // D s_314_21: call AMCNTENCLR0_write(s_314_20)
        let s_314_21: () = AMCNTENCLR0_write(state, tracer, s_314_20);
        // C s_314_22: const #() : ()
        let s_314_22: () = ();
        // S s_314_23: call AMCNTENCLR0_read(s_314_22)
        let s_314_23: ProductType700c18a878c5601b = AMCNTENCLR0_read(
            state,
            tracer,
            s_314_22,
        );
        // D s_314_24: write-var ga#36688 <= s_314_23
        fn_state.ga_36688 = s_314_23;
        // D s_314_25: read-var ga#36688.0:struct
        let s_314_25: u32 = fn_state.ga_36688._0;
        // C s_314_26: const #12s : i
        let s_314_26: i128 = 12;
        // C s_314_27: const #4s : i
        let s_314_27: i128 = 4;
        // D s_314_28: cast zx s_314_25 -> bv
        let s_314_28: Bits = Bits::new(s_314_25 as u128, 32u16);
        // C s_314_29: const #0u : u12
        let s_314_29: u16 = 0;
        // C s_314_30: cast zx s_314_29 -> bv
        let s_314_30: Bits = Bits::new(s_314_29 as u128, 12u16);
        // C s_314_31: const #1u : u64
        let s_314_31: u64 = 1;
        // C s_314_32: cast zx s_314_31 -> bv
        let s_314_32: Bits = Bits::new(s_314_31 as u128, 64u16);
        // C s_314_33: lsl s_314_32 s_314_26
        let s_314_33: Bits = s_314_32 << s_314_26;
        // C s_314_34: sub s_314_33 s_314_32
        let s_314_34: Bits = ((s_314_33) - (s_314_32));
        // C s_314_35: and s_314_30 s_314_34
        let s_314_35: Bits = ((s_314_30) & (s_314_34));
        // C s_314_36: lsl s_314_35 s_314_27
        let s_314_36: Bits = s_314_35 << s_314_27;
        // C s_314_37: lsl s_314_34 s_314_27
        let s_314_37: Bits = s_314_34 << s_314_27;
        // C s_314_38: cmpl s_314_37
        let s_314_38: Bits = !s_314_37;
        // D s_314_39: and s_314_28 s_314_38
        let s_314_39: Bits = ((s_314_28) & (s_314_38));
        // D s_314_40: or s_314_39 s_314_36
        let s_314_40: Bits = ((s_314_39) | (s_314_36));
        // D s_314_41: cast reint s_314_40 -> u32
        let s_314_41: u32 = (s_314_40.value() as u32);
        // D s_314_42: call Mk_AMCNTENCLR0_Type(s_314_41)
        let s_314_42: ProductType700c18a878c5601b = Mk_AMCNTENCLR0_Type(
            state,
            tracer,
            s_314_41,
        );
        // D s_314_43: call AMCNTENCLR0_write(s_314_42)
        let s_314_43: () = AMCNTENCLR0_write(state, tracer, s_314_42);
        // D s_314_44: read-var cold:u8
        let s_314_44: bool = fn_state.cold;
        // N s_314_45: branch s_314_44 b494 b315
        if s_314_44 {
            return block_494(state, tracer, fn_state);
        } else {
            return block_315(state, tracer, fn_state);
        };
    }
    fn block_315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_315_0: jump b316
        return block_316(state, tracer, fn_state);
    }
    fn block_316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_316_0: const #() : ()
        let s_316_0: () = ();
        // S s_316_1: call AMCNTENSET1_read(s_316_0)
        let s_316_1: ProductType700c18a878c5601b = AMCNTENSET1_read(
            state,
            tracer,
            s_316_0,
        );
        // D s_316_2: write-var ga#36696 <= s_316_1
        fn_state.ga_36696 = s_316_1;
        // D s_316_3: read-var ga#36696.0:struct
        let s_316_3: u32 = fn_state.ga_36696._0;
        // C s_316_4: const #16s : i
        let s_316_4: i128 = 16;
        // C s_316_5: const #16s : i
        let s_316_5: i128 = 16;
        // D s_316_6: cast zx s_316_3 -> bv
        let s_316_6: Bits = Bits::new(s_316_3 as u128, 32u16);
        // C s_316_7: const #0u : u16
        let s_316_7: u16 = 0;
        // C s_316_8: cast zx s_316_7 -> bv
        let s_316_8: Bits = Bits::new(s_316_7 as u128, 16u16);
        // C s_316_9: const #1u : u64
        let s_316_9: u64 = 1;
        // C s_316_10: cast zx s_316_9 -> bv
        let s_316_10: Bits = Bits::new(s_316_9 as u128, 64u16);
        // C s_316_11: lsl s_316_10 s_316_4
        let s_316_11: Bits = s_316_10 << s_316_4;
        // C s_316_12: sub s_316_11 s_316_10
        let s_316_12: Bits = ((s_316_11) - (s_316_10));
        // C s_316_13: and s_316_8 s_316_12
        let s_316_13: Bits = ((s_316_8) & (s_316_12));
        // C s_316_14: lsl s_316_13 s_316_5
        let s_316_14: Bits = s_316_13 << s_316_5;
        // C s_316_15: lsl s_316_12 s_316_5
        let s_316_15: Bits = s_316_12 << s_316_5;
        // C s_316_16: cmpl s_316_15
        let s_316_16: Bits = !s_316_15;
        // D s_316_17: and s_316_6 s_316_16
        let s_316_17: Bits = ((s_316_6) & (s_316_16));
        // D s_316_18: or s_316_17 s_316_14
        let s_316_18: Bits = ((s_316_17) | (s_316_14));
        // D s_316_19: cast reint s_316_18 -> u32
        let s_316_19: u32 = (s_316_18.value() as u32);
        // D s_316_20: call Mk_AMCNTENSET1_Type(s_316_19)
        let s_316_20: ProductType700c18a878c5601b = Mk_AMCNTENSET1_Type(
            state,
            tracer,
            s_316_19,
        );
        // D s_316_21: call AMCNTENSET1_write(s_316_20)
        let s_316_21: () = AMCNTENSET1_write(state, tracer, s_316_20);
        // D s_316_22: read-var cold:u8
        let s_316_22: bool = fn_state.cold;
        // N s_316_23: branch s_316_22 b493 b317
        if s_316_22 {
            return block_493(state, tracer, fn_state);
        } else {
            return block_317(state, tracer, fn_state);
        };
    }
    fn block_317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_317_0: jump b318
        return block_318(state, tracer, fn_state);
    }
    fn block_318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_318_0: const #() : ()
        let s_318_0: () = ();
        // S s_318_1: call AMCR_read(s_318_0)
        let s_318_1: ProductType700c18a878c5601b = AMCR_read(state, tracer, s_318_0);
        // D s_318_2: write-var ga#36704 <= s_318_1
        fn_state.ga_36704 = s_318_1;
        // D s_318_3: read-var ga#36704.0:struct
        let s_318_3: u32 = fn_state.ga_36704._0;
        // C s_318_4: const #14s : i
        let s_318_4: i128 = 14;
        // C s_318_5: const #18s : i
        let s_318_5: i128 = 18;
        // D s_318_6: cast zx s_318_3 -> bv
        let s_318_6: Bits = Bits::new(s_318_3 as u128, 32u16);
        // C s_318_7: const #0u : u14
        let s_318_7: u16 = 0;
        // C s_318_8: cast zx s_318_7 -> bv
        let s_318_8: Bits = Bits::new(s_318_7 as u128, 14u16);
        // C s_318_9: const #1u : u64
        let s_318_9: u64 = 1;
        // C s_318_10: cast zx s_318_9 -> bv
        let s_318_10: Bits = Bits::new(s_318_9 as u128, 64u16);
        // C s_318_11: lsl s_318_10 s_318_4
        let s_318_11: Bits = s_318_10 << s_318_4;
        // C s_318_12: sub s_318_11 s_318_10
        let s_318_12: Bits = ((s_318_11) - (s_318_10));
        // C s_318_13: and s_318_8 s_318_12
        let s_318_13: Bits = ((s_318_8) & (s_318_12));
        // C s_318_14: lsl s_318_13 s_318_5
        let s_318_14: Bits = s_318_13 << s_318_5;
        // C s_318_15: lsl s_318_12 s_318_5
        let s_318_15: Bits = s_318_12 << s_318_5;
        // C s_318_16: cmpl s_318_15
        let s_318_16: Bits = !s_318_15;
        // D s_318_17: and s_318_6 s_318_16
        let s_318_17: Bits = ((s_318_6) & (s_318_16));
        // D s_318_18: or s_318_17 s_318_14
        let s_318_18: Bits = ((s_318_17) | (s_318_14));
        // D s_318_19: cast reint s_318_18 -> u32
        let s_318_19: u32 = (s_318_18.value() as u32);
        // D s_318_20: call Mk_AMCR_Type(s_318_19)
        let s_318_20: ProductType700c18a878c5601b = Mk_AMCR_Type(
            state,
            tracer,
            s_318_19,
        );
        // D s_318_21: call AMCR_write(s_318_20)
        let s_318_21: () = AMCR_write(state, tracer, s_318_20);
        // C s_318_22: const #() : ()
        let s_318_22: () = ();
        // S s_318_23: call AMCR_read(s_318_22)
        let s_318_23: ProductType700c18a878c5601b = AMCR_read(state, tracer, s_318_22);
        // D s_318_24: write-var ga#36708 <= s_318_23
        fn_state.ga_36708 = s_318_23;
        // D s_318_25: read-var ga#36708.0:struct
        let s_318_25: u32 = fn_state.ga_36708._0;
        // C s_318_26: const #6s : i
        let s_318_26: i128 = 6;
        // C s_318_27: const #11s : i
        let s_318_27: i128 = 11;
        // D s_318_28: cast zx s_318_25 -> bv
        let s_318_28: Bits = Bits::new(s_318_25 as u128, 32u16);
        // C s_318_29: const #0u : u8
        let s_318_29: u8 = 0;
        // C s_318_30: cast zx s_318_29 -> bv
        let s_318_30: Bits = Bits::new(s_318_29 as u128, 6u16);
        // C s_318_31: const #1u : u64
        let s_318_31: u64 = 1;
        // C s_318_32: cast zx s_318_31 -> bv
        let s_318_32: Bits = Bits::new(s_318_31 as u128, 64u16);
        // C s_318_33: lsl s_318_32 s_318_26
        let s_318_33: Bits = s_318_32 << s_318_26;
        // C s_318_34: sub s_318_33 s_318_32
        let s_318_34: Bits = ((s_318_33) - (s_318_32));
        // C s_318_35: and s_318_30 s_318_34
        let s_318_35: Bits = ((s_318_30) & (s_318_34));
        // C s_318_36: lsl s_318_35 s_318_27
        let s_318_36: Bits = s_318_35 << s_318_27;
        // C s_318_37: lsl s_318_34 s_318_27
        let s_318_37: Bits = s_318_34 << s_318_27;
        // C s_318_38: cmpl s_318_37
        let s_318_38: Bits = !s_318_37;
        // D s_318_39: and s_318_28 s_318_38
        let s_318_39: Bits = ((s_318_28) & (s_318_38));
        // D s_318_40: or s_318_39 s_318_36
        let s_318_40: Bits = ((s_318_39) | (s_318_36));
        // D s_318_41: cast reint s_318_40 -> u32
        let s_318_41: u32 = (s_318_40.value() as u32);
        // D s_318_42: call Mk_AMCR_Type(s_318_41)
        let s_318_42: ProductType700c18a878c5601b = Mk_AMCR_Type(
            state,
            tracer,
            s_318_41,
        );
        // D s_318_43: call AMCR_write(s_318_42)
        let s_318_43: () = AMCR_write(state, tracer, s_318_42);
        // C s_318_44: const #() : ()
        let s_318_44: () = ();
        // S s_318_45: call AMCR_read(s_318_44)
        let s_318_45: ProductType700c18a878c5601b = AMCR_read(state, tracer, s_318_44);
        // D s_318_46: write-var ga#36712 <= s_318_45
        fn_state.ga_36712 = s_318_45;
        // D s_318_47: read-var ga#36712.0:struct
        let s_318_47: u32 = fn_state.ga_36712._0;
        // C s_318_48: const #10s : i
        let s_318_48: i128 = 10;
        // C s_318_49: const #0s : i
        let s_318_49: i128 = 0;
        // D s_318_50: cast zx s_318_47 -> bv
        let s_318_50: Bits = Bits::new(s_318_47 as u128, 32u16);
        // C s_318_51: const #0u : u10
        let s_318_51: u16 = 0;
        // C s_318_52: cast zx s_318_51 -> bv
        let s_318_52: Bits = Bits::new(s_318_51 as u128, 10u16);
        // C s_318_53: const #1u : u64
        let s_318_53: u64 = 1;
        // C s_318_54: cast zx s_318_53 -> bv
        let s_318_54: Bits = Bits::new(s_318_53 as u128, 64u16);
        // C s_318_55: lsl s_318_54 s_318_48
        let s_318_55: Bits = s_318_54 << s_318_48;
        // C s_318_56: sub s_318_55 s_318_54
        let s_318_56: Bits = ((s_318_55) - (s_318_54));
        // C s_318_57: and s_318_52 s_318_56
        let s_318_57: Bits = ((s_318_52) & (s_318_56));
        // C s_318_58: lsl s_318_57 s_318_49
        let s_318_58: Bits = s_318_57 << s_318_49;
        // C s_318_59: lsl s_318_56 s_318_49
        let s_318_59: Bits = s_318_56 << s_318_49;
        // C s_318_60: cmpl s_318_59
        let s_318_60: Bits = !s_318_59;
        // D s_318_61: and s_318_50 s_318_60
        let s_318_61: Bits = ((s_318_50) & (s_318_60));
        // D s_318_62: or s_318_61 s_318_58
        let s_318_62: Bits = ((s_318_61) | (s_318_58));
        // D s_318_63: cast reint s_318_62 -> u32
        let s_318_63: u32 = (s_318_62.value() as u32);
        // D s_318_64: call Mk_AMCR_Type(s_318_63)
        let s_318_64: ProductType700c18a878c5601b = Mk_AMCR_Type(
            state,
            tracer,
            s_318_63,
        );
        // D s_318_65: call AMCR_write(s_318_64)
        let s_318_65: () = AMCR_write(state, tracer, s_318_64);
        // C s_318_66: const #() : ()
        let s_318_66: () = ();
        // S s_318_67: call ERRIDR_read(s_318_66)
        let s_318_67: ProductType700c18a878c5601b = ERRIDR_read(state, tracer, s_318_66);
        // D s_318_68: write-var ga#36716 <= s_318_67
        fn_state.ga_36716 = s_318_67;
        // D s_318_69: read-var ga#36716.0:struct
        let s_318_69: u32 = fn_state.ga_36716._0;
        // C s_318_70: const #16s : i
        let s_318_70: i128 = 16;
        // C s_318_71: const #16s : i
        let s_318_71: i128 = 16;
        // D s_318_72: cast zx s_318_69 -> bv
        let s_318_72: Bits = Bits::new(s_318_69 as u128, 32u16);
        // C s_318_73: const #0u : u16
        let s_318_73: u16 = 0;
        // C s_318_74: cast zx s_318_73 -> bv
        let s_318_74: Bits = Bits::new(s_318_73 as u128, 16u16);
        // C s_318_75: const #1u : u64
        let s_318_75: u64 = 1;
        // C s_318_76: cast zx s_318_75 -> bv
        let s_318_76: Bits = Bits::new(s_318_75 as u128, 64u16);
        // C s_318_77: lsl s_318_76 s_318_70
        let s_318_77: Bits = s_318_76 << s_318_70;
        // C s_318_78: sub s_318_77 s_318_76
        let s_318_78: Bits = ((s_318_77) - (s_318_76));
        // C s_318_79: and s_318_74 s_318_78
        let s_318_79: Bits = ((s_318_74) & (s_318_78));
        // C s_318_80: lsl s_318_79 s_318_71
        let s_318_80: Bits = s_318_79 << s_318_71;
        // C s_318_81: lsl s_318_78 s_318_71
        let s_318_81: Bits = s_318_78 << s_318_71;
        // C s_318_82: cmpl s_318_81
        let s_318_82: Bits = !s_318_81;
        // D s_318_83: and s_318_72 s_318_82
        let s_318_83: Bits = ((s_318_72) & (s_318_82));
        // D s_318_84: or s_318_83 s_318_80
        let s_318_84: Bits = ((s_318_83) | (s_318_80));
        // D s_318_85: cast reint s_318_84 -> u32
        let s_318_85: u32 = (s_318_84.value() as u32);
        // D s_318_86: call Mk_ERRIDR_Type(s_318_85)
        let s_318_86: ProductType700c18a878c5601b = Mk_ERRIDR_Type(
            state,
            tracer,
            s_318_85,
        );
        // D s_318_87: call ERRIDR_write(s_318_86)
        let s_318_87: () = ERRIDR_write(state, tracer, s_318_86);
        // C s_318_88: const #() : ()
        let s_318_88: () = ();
        // S s_318_89: call ERRSELR_read(s_318_88)
        let s_318_89: ProductType700c18a878c5601b = ERRSELR_read(
            state,
            tracer,
            s_318_88,
        );
        // D s_318_90: write-var ga#36720 <= s_318_89
        fn_state.ga_36720 = s_318_89;
        // D s_318_91: read-var ga#36720.0:struct
        let s_318_91: u32 = fn_state.ga_36720._0;
        // C s_318_92: const #16s : i
        let s_318_92: i128 = 16;
        // C s_318_93: const #16s : i
        let s_318_93: i128 = 16;
        // D s_318_94: cast zx s_318_91 -> bv
        let s_318_94: Bits = Bits::new(s_318_91 as u128, 32u16);
        // C s_318_95: const #0u : u16
        let s_318_95: u16 = 0;
        // C s_318_96: cast zx s_318_95 -> bv
        let s_318_96: Bits = Bits::new(s_318_95 as u128, 16u16);
        // C s_318_97: const #1u : u64
        let s_318_97: u64 = 1;
        // C s_318_98: cast zx s_318_97 -> bv
        let s_318_98: Bits = Bits::new(s_318_97 as u128, 64u16);
        // C s_318_99: lsl s_318_98 s_318_92
        let s_318_99: Bits = s_318_98 << s_318_92;
        // C s_318_100: sub s_318_99 s_318_98
        let s_318_100: Bits = ((s_318_99) - (s_318_98));
        // C s_318_101: and s_318_96 s_318_100
        let s_318_101: Bits = ((s_318_96) & (s_318_100));
        // C s_318_102: lsl s_318_101 s_318_93
        let s_318_102: Bits = s_318_101 << s_318_93;
        // C s_318_103: lsl s_318_100 s_318_93
        let s_318_103: Bits = s_318_100 << s_318_93;
        // C s_318_104: cmpl s_318_103
        let s_318_104: Bits = !s_318_103;
        // D s_318_105: and s_318_94 s_318_104
        let s_318_105: Bits = ((s_318_94) & (s_318_104));
        // D s_318_106: or s_318_105 s_318_102
        let s_318_106: Bits = ((s_318_105) | (s_318_102));
        // D s_318_107: cast reint s_318_106 -> u32
        let s_318_107: u32 = (s_318_106.value() as u32);
        // D s_318_108: call Mk_ERRSELR_Type(s_318_107)
        let s_318_108: ProductType700c18a878c5601b = Mk_ERRSELR_Type(
            state,
            tracer,
            s_318_107,
        );
        // D s_318_109: call ERRSELR_write(s_318_108)
        let s_318_109: () = ERRSELR_write(state, tracer, s_318_108);
        // C s_318_110: const #() : ()
        let s_318_110: () = ();
        // S s_318_111: call DISR_read(s_318_110)
        let s_318_111: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_110);
        // D s_318_112: write-var ga#36724 <= s_318_111
        fn_state.ga_36724 = s_318_111;
        // D s_318_113: read-var ga#36724.0:struct
        let s_318_113: u32 = fn_state.ga_36724._0;
        // C s_318_114: const #19s : i
        let s_318_114: i128 = 19;
        // C s_318_115: const #12s : i
        let s_318_115: i128 = 12;
        // D s_318_116: cast zx s_318_113 -> bv
        let s_318_116: Bits = Bits::new(s_318_113 as u128, 32u16);
        // C s_318_117: const #0u : u19
        let s_318_117: u32 = 0;
        // C s_318_118: cast zx s_318_117 -> bv
        let s_318_118: Bits = Bits::new(s_318_117 as u128, 19u16);
        // C s_318_119: const #1u : u64
        let s_318_119: u64 = 1;
        // C s_318_120: cast zx s_318_119 -> bv
        let s_318_120: Bits = Bits::new(s_318_119 as u128, 64u16);
        // C s_318_121: lsl s_318_120 s_318_114
        let s_318_121: Bits = s_318_120 << s_318_114;
        // C s_318_122: sub s_318_121 s_318_120
        let s_318_122: Bits = ((s_318_121) - (s_318_120));
        // C s_318_123: and s_318_118 s_318_122
        let s_318_123: Bits = ((s_318_118) & (s_318_122));
        // C s_318_124: lsl s_318_123 s_318_115
        let s_318_124: Bits = s_318_123 << s_318_115;
        // C s_318_125: lsl s_318_122 s_318_115
        let s_318_125: Bits = s_318_122 << s_318_115;
        // C s_318_126: cmpl s_318_125
        let s_318_126: Bits = !s_318_125;
        // D s_318_127: and s_318_116 s_318_126
        let s_318_127: Bits = ((s_318_116) & (s_318_126));
        // D s_318_128: or s_318_127 s_318_124
        let s_318_128: Bits = ((s_318_127) | (s_318_124));
        // D s_318_129: cast reint s_318_128 -> u32
        let s_318_129: u32 = (s_318_128.value() as u32);
        // D s_318_130: call Mk_DISR_Type(s_318_129)
        let s_318_130: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_129,
        );
        // D s_318_131: call DISR_write(s_318_130)
        let s_318_131: () = DISR_write(state, tracer, s_318_130);
        // C s_318_132: const #() : ()
        let s_318_132: () = ();
        // S s_318_133: call DISR_read(s_318_132)
        let s_318_133: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_132);
        // D s_318_134: write-var ga#36728 <= s_318_133
        fn_state.ga_36728 = s_318_133;
        // D s_318_135: read-var ga#36728.0:struct
        let s_318_135: u32 = fn_state.ga_36728._0;
        // C s_318_136: const #3s : i
        let s_318_136: i128 = 3;
        // C s_318_137: const #6s : i
        let s_318_137: i128 = 6;
        // D s_318_138: cast zx s_318_135 -> bv
        let s_318_138: Bits = Bits::new(s_318_135 as u128, 32u16);
        // C s_318_139: const #0u : u8
        let s_318_139: u8 = 0;
        // C s_318_140: cast zx s_318_139 -> bv
        let s_318_140: Bits = Bits::new(s_318_139 as u128, 3u16);
        // C s_318_141: const #1u : u64
        let s_318_141: u64 = 1;
        // C s_318_142: cast zx s_318_141 -> bv
        let s_318_142: Bits = Bits::new(s_318_141 as u128, 64u16);
        // C s_318_143: lsl s_318_142 s_318_136
        let s_318_143: Bits = s_318_142 << s_318_136;
        // C s_318_144: sub s_318_143 s_318_142
        let s_318_144: Bits = ((s_318_143) - (s_318_142));
        // C s_318_145: and s_318_140 s_318_144
        let s_318_145: Bits = ((s_318_140) & (s_318_144));
        // C s_318_146: lsl s_318_145 s_318_137
        let s_318_146: Bits = s_318_145 << s_318_137;
        // C s_318_147: lsl s_318_144 s_318_137
        let s_318_147: Bits = s_318_144 << s_318_137;
        // C s_318_148: cmpl s_318_147
        let s_318_148: Bits = !s_318_147;
        // D s_318_149: and s_318_138 s_318_148
        let s_318_149: Bits = ((s_318_138) & (s_318_148));
        // D s_318_150: or s_318_149 s_318_146
        let s_318_150: Bits = ((s_318_149) | (s_318_146));
        // D s_318_151: cast reint s_318_150 -> u32
        let s_318_151: u32 = (s_318_150.value() as u32);
        // D s_318_152: call Mk_DISR_Type(s_318_151)
        let s_318_152: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_151,
        );
        // D s_318_153: call DISR_write(s_318_152)
        let s_318_153: () = DISR_write(state, tracer, s_318_152);
        // C s_318_154: const #() : ()
        let s_318_154: () = ();
        // S s_318_155: call DISR_read(s_318_154)
        let s_318_155: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_154);
        // D s_318_156: write-var ga#36732 <= s_318_155
        fn_state.ga_36732 = s_318_155;
        // D s_318_157: read-var ga#36732.0:struct
        let s_318_157: u32 = fn_state.ga_36732._0;
        // C s_318_158: const #15s : i
        let s_318_158: i128 = 15;
        // C s_318_159: const #16s : i
        let s_318_159: i128 = 16;
        // D s_318_160: cast zx s_318_157 -> bv
        let s_318_160: Bits = Bits::new(s_318_157 as u128, 32u16);
        // C s_318_161: const #0u : u15
        let s_318_161: u16 = 0;
        // C s_318_162: cast zx s_318_161 -> bv
        let s_318_162: Bits = Bits::new(s_318_161 as u128, 15u16);
        // C s_318_163: const #1u : u64
        let s_318_163: u64 = 1;
        // C s_318_164: cast zx s_318_163 -> bv
        let s_318_164: Bits = Bits::new(s_318_163 as u128, 64u16);
        // C s_318_165: lsl s_318_164 s_318_158
        let s_318_165: Bits = s_318_164 << s_318_158;
        // C s_318_166: sub s_318_165 s_318_164
        let s_318_166: Bits = ((s_318_165) - (s_318_164));
        // C s_318_167: and s_318_162 s_318_166
        let s_318_167: Bits = ((s_318_162) & (s_318_166));
        // C s_318_168: lsl s_318_167 s_318_159
        let s_318_168: Bits = s_318_167 << s_318_159;
        // C s_318_169: lsl s_318_166 s_318_159
        let s_318_169: Bits = s_318_166 << s_318_159;
        // C s_318_170: cmpl s_318_169
        let s_318_170: Bits = !s_318_169;
        // D s_318_171: and s_318_160 s_318_170
        let s_318_171: Bits = ((s_318_160) & (s_318_170));
        // D s_318_172: or s_318_171 s_318_168
        let s_318_172: Bits = ((s_318_171) | (s_318_168));
        // D s_318_173: cast reint s_318_172 -> u32
        let s_318_173: u32 = (s_318_172.value() as u32);
        // D s_318_174: call Mk_DISR_Type(s_318_173)
        let s_318_174: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_173,
        );
        // D s_318_175: call DISR_write(s_318_174)
        let s_318_175: () = DISR_write(state, tracer, s_318_174);
        // C s_318_176: const #() : ()
        let s_318_176: () = ();
        // S s_318_177: call DISR_read(s_318_176)
        let s_318_177: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_176);
        // D s_318_178: write-var ga#36736 <= s_318_177
        fn_state.ga_36736 = s_318_177;
        // D s_318_179: read-var ga#36736.0:struct
        let s_318_179: u32 = fn_state.ga_36736._0;
        // C s_318_180: const #1s : i
        let s_318_180: i128 = 1;
        // C s_318_181: const #13s : i
        let s_318_181: i128 = 13;
        // D s_318_182: cast zx s_318_179 -> bv
        let s_318_182: Bits = Bits::new(s_318_179 as u128, 32u16);
        // C s_318_183: const #0u : u8
        let s_318_183: bool = false;
        // C s_318_184: cast zx s_318_183 -> bv
        let s_318_184: Bits = Bits::new(s_318_183 as u128, 1u16);
        // C s_318_185: const #1u : u64
        let s_318_185: u64 = 1;
        // C s_318_186: cast zx s_318_185 -> bv
        let s_318_186: Bits = Bits::new(s_318_185 as u128, 64u16);
        // C s_318_187: lsl s_318_186 s_318_180
        let s_318_187: Bits = s_318_186 << s_318_180;
        // C s_318_188: sub s_318_187 s_318_186
        let s_318_188: Bits = ((s_318_187) - (s_318_186));
        // C s_318_189: and s_318_184 s_318_188
        let s_318_189: Bits = ((s_318_184) & (s_318_188));
        // C s_318_190: lsl s_318_189 s_318_181
        let s_318_190: Bits = s_318_189 << s_318_181;
        // C s_318_191: lsl s_318_188 s_318_181
        let s_318_191: Bits = s_318_188 << s_318_181;
        // C s_318_192: cmpl s_318_191
        let s_318_192: Bits = !s_318_191;
        // D s_318_193: and s_318_182 s_318_192
        let s_318_193: Bits = ((s_318_182) & (s_318_192));
        // D s_318_194: or s_318_193 s_318_190
        let s_318_194: Bits = ((s_318_193) | (s_318_190));
        // D s_318_195: cast reint s_318_194 -> u32
        let s_318_195: u32 = (s_318_194.value() as u32);
        // D s_318_196: call Mk_DISR_Type(s_318_195)
        let s_318_196: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_195,
        );
        // D s_318_197: call DISR_write(s_318_196)
        let s_318_197: () = DISR_write(state, tracer, s_318_196);
        // C s_318_198: const #() : ()
        let s_318_198: () = ();
        // S s_318_199: call DISR_read(s_318_198)
        let s_318_199: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_198);
        // D s_318_200: write-var ga#36740 <= s_318_199
        fn_state.ga_36740 = s_318_199;
        // D s_318_201: read-var ga#36740.0:struct
        let s_318_201: u32 = fn_state.ga_36740._0;
        // C s_318_202: const #1s : i
        let s_318_202: i128 = 1;
        // C s_318_203: const #11s : i
        let s_318_203: i128 = 11;
        // D s_318_204: cast zx s_318_201 -> bv
        let s_318_204: Bits = Bits::new(s_318_201 as u128, 32u16);
        // C s_318_205: const #0u : u8
        let s_318_205: bool = false;
        // C s_318_206: cast zx s_318_205 -> bv
        let s_318_206: Bits = Bits::new(s_318_205 as u128, 1u16);
        // C s_318_207: const #1u : u64
        let s_318_207: u64 = 1;
        // C s_318_208: cast zx s_318_207 -> bv
        let s_318_208: Bits = Bits::new(s_318_207 as u128, 64u16);
        // C s_318_209: lsl s_318_208 s_318_202
        let s_318_209: Bits = s_318_208 << s_318_202;
        // C s_318_210: sub s_318_209 s_318_208
        let s_318_210: Bits = ((s_318_209) - (s_318_208));
        // C s_318_211: and s_318_206 s_318_210
        let s_318_211: Bits = ((s_318_206) & (s_318_210));
        // C s_318_212: lsl s_318_211 s_318_203
        let s_318_212: Bits = s_318_211 << s_318_203;
        // C s_318_213: lsl s_318_210 s_318_203
        let s_318_213: Bits = s_318_210 << s_318_203;
        // C s_318_214: cmpl s_318_213
        let s_318_214: Bits = !s_318_213;
        // D s_318_215: and s_318_204 s_318_214
        let s_318_215: Bits = ((s_318_204) & (s_318_214));
        // D s_318_216: or s_318_215 s_318_212
        let s_318_216: Bits = ((s_318_215) | (s_318_212));
        // D s_318_217: cast reint s_318_216 -> u32
        let s_318_217: u32 = (s_318_216.value() as u32);
        // D s_318_218: call Mk_DISR_Type(s_318_217)
        let s_318_218: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_217,
        );
        // D s_318_219: call DISR_write(s_318_218)
        let s_318_219: () = DISR_write(state, tracer, s_318_218);
        // C s_318_220: const #() : ()
        let s_318_220: () = ();
        // S s_318_221: call DISR_read(s_318_220)
        let s_318_221: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_220);
        // D s_318_222: write-var ga#36744 <= s_318_221
        fn_state.ga_36744 = s_318_221;
        // D s_318_223: read-var ga#36744.0:struct
        let s_318_223: u32 = fn_state.ga_36744._0;
        // C s_318_224: const #5s : i
        let s_318_224: i128 = 5;
        // C s_318_225: const #4s : i
        let s_318_225: i128 = 4;
        // D s_318_226: cast zx s_318_223 -> bv
        let s_318_226: Bits = Bits::new(s_318_223 as u128, 32u16);
        // C s_318_227: const #0u : u8
        let s_318_227: u8 = 0;
        // C s_318_228: cast zx s_318_227 -> bv
        let s_318_228: Bits = Bits::new(s_318_227 as u128, 5u16);
        // C s_318_229: const #1u : u64
        let s_318_229: u64 = 1;
        // C s_318_230: cast zx s_318_229 -> bv
        let s_318_230: Bits = Bits::new(s_318_229 as u128, 64u16);
        // C s_318_231: lsl s_318_230 s_318_224
        let s_318_231: Bits = s_318_230 << s_318_224;
        // C s_318_232: sub s_318_231 s_318_230
        let s_318_232: Bits = ((s_318_231) - (s_318_230));
        // C s_318_233: and s_318_228 s_318_232
        let s_318_233: Bits = ((s_318_228) & (s_318_232));
        // C s_318_234: lsl s_318_233 s_318_225
        let s_318_234: Bits = s_318_233 << s_318_225;
        // C s_318_235: lsl s_318_232 s_318_225
        let s_318_235: Bits = s_318_232 << s_318_225;
        // C s_318_236: cmpl s_318_235
        let s_318_236: Bits = !s_318_235;
        // D s_318_237: and s_318_226 s_318_236
        let s_318_237: Bits = ((s_318_226) & (s_318_236));
        // D s_318_238: or s_318_237 s_318_234
        let s_318_238: Bits = ((s_318_237) | (s_318_234));
        // D s_318_239: cast reint s_318_238 -> u32
        let s_318_239: u32 = (s_318_238.value() as u32);
        // D s_318_240: call Mk_DISR_Type(s_318_239)
        let s_318_240: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_239,
        );
        // D s_318_241: call DISR_write(s_318_240)
        let s_318_241: () = DISR_write(state, tracer, s_318_240);
        // C s_318_242: const #() : ()
        let s_318_242: () = ();
        // S s_318_243: call DISR_read(s_318_242)
        let s_318_243: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_242);
        // D s_318_244: write-var ga#36748 <= s_318_243
        fn_state.ga_36748 = s_318_243;
        // D s_318_245: read-var ga#36748.0:struct
        let s_318_245: u32 = fn_state.ga_36748._0;
        // C s_318_246: const #15s : i
        let s_318_246: i128 = 15;
        // C s_318_247: const #16s : i
        let s_318_247: i128 = 16;
        // D s_318_248: cast zx s_318_245 -> bv
        let s_318_248: Bits = Bits::new(s_318_245 as u128, 32u16);
        // C s_318_249: const #0u : u15
        let s_318_249: u16 = 0;
        // C s_318_250: cast zx s_318_249 -> bv
        let s_318_250: Bits = Bits::new(s_318_249 as u128, 15u16);
        // C s_318_251: const #1u : u64
        let s_318_251: u64 = 1;
        // C s_318_252: cast zx s_318_251 -> bv
        let s_318_252: Bits = Bits::new(s_318_251 as u128, 64u16);
        // C s_318_253: lsl s_318_252 s_318_246
        let s_318_253: Bits = s_318_252 << s_318_246;
        // C s_318_254: sub s_318_253 s_318_252
        let s_318_254: Bits = ((s_318_253) - (s_318_252));
        // C s_318_255: and s_318_250 s_318_254
        let s_318_255: Bits = ((s_318_250) & (s_318_254));
        // C s_318_256: lsl s_318_255 s_318_247
        let s_318_256: Bits = s_318_255 << s_318_247;
        // C s_318_257: lsl s_318_254 s_318_247
        let s_318_257: Bits = s_318_254 << s_318_247;
        // C s_318_258: cmpl s_318_257
        let s_318_258: Bits = !s_318_257;
        // D s_318_259: and s_318_248 s_318_258
        let s_318_259: Bits = ((s_318_248) & (s_318_258));
        // D s_318_260: or s_318_259 s_318_256
        let s_318_260: Bits = ((s_318_259) | (s_318_256));
        // D s_318_261: cast reint s_318_260 -> u32
        let s_318_261: u32 = (s_318_260.value() as u32);
        // D s_318_262: call Mk_DISR_Type(s_318_261)
        let s_318_262: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_261,
        );
        // D s_318_263: call DISR_write(s_318_262)
        let s_318_263: () = DISR_write(state, tracer, s_318_262);
        // C s_318_264: const #() : ()
        let s_318_264: () = ();
        // S s_318_265: call DISR_read(s_318_264)
        let s_318_265: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_264);
        // D s_318_266: write-var ga#36752 <= s_318_265
        fn_state.ga_36752 = s_318_265;
        // D s_318_267: read-var ga#36752.0:struct
        let s_318_267: u32 = fn_state.ga_36752._0;
        // C s_318_268: const #1s : i
        let s_318_268: i128 = 1;
        // C s_318_269: const #13s : i
        let s_318_269: i128 = 13;
        // D s_318_270: cast zx s_318_267 -> bv
        let s_318_270: Bits = Bits::new(s_318_267 as u128, 32u16);
        // C s_318_271: const #0u : u8
        let s_318_271: bool = false;
        // C s_318_272: cast zx s_318_271 -> bv
        let s_318_272: Bits = Bits::new(s_318_271 as u128, 1u16);
        // C s_318_273: const #1u : u64
        let s_318_273: u64 = 1;
        // C s_318_274: cast zx s_318_273 -> bv
        let s_318_274: Bits = Bits::new(s_318_273 as u128, 64u16);
        // C s_318_275: lsl s_318_274 s_318_268
        let s_318_275: Bits = s_318_274 << s_318_268;
        // C s_318_276: sub s_318_275 s_318_274
        let s_318_276: Bits = ((s_318_275) - (s_318_274));
        // C s_318_277: and s_318_272 s_318_276
        let s_318_277: Bits = ((s_318_272) & (s_318_276));
        // C s_318_278: lsl s_318_277 s_318_269
        let s_318_278: Bits = s_318_277 << s_318_269;
        // C s_318_279: lsl s_318_276 s_318_269
        let s_318_279: Bits = s_318_276 << s_318_269;
        // C s_318_280: cmpl s_318_279
        let s_318_280: Bits = !s_318_279;
        // D s_318_281: and s_318_270 s_318_280
        let s_318_281: Bits = ((s_318_270) & (s_318_280));
        // D s_318_282: or s_318_281 s_318_278
        let s_318_282: Bits = ((s_318_281) | (s_318_278));
        // D s_318_283: cast reint s_318_282 -> u32
        let s_318_283: u32 = (s_318_282.value() as u32);
        // D s_318_284: call Mk_DISR_Type(s_318_283)
        let s_318_284: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_283,
        );
        // D s_318_285: call DISR_write(s_318_284)
        let s_318_285: () = DISR_write(state, tracer, s_318_284);
        // C s_318_286: const #() : ()
        let s_318_286: () = ();
        // S s_318_287: call DISR_read(s_318_286)
        let s_318_287: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_286);
        // D s_318_288: write-var ga#36756 <= s_318_287
        fn_state.ga_36756 = s_318_287;
        // D s_318_289: read-var ga#36756.0:struct
        let s_318_289: u32 = fn_state.ga_36756._0;
        // C s_318_290: const #2s : i
        let s_318_290: i128 = 2;
        // C s_318_291: const #10s : i
        let s_318_291: i128 = 10;
        // D s_318_292: cast zx s_318_289 -> bv
        let s_318_292: Bits = Bits::new(s_318_289 as u128, 32u16);
        // C s_318_293: const #0u : u8
        let s_318_293: u8 = 0;
        // C s_318_294: cast zx s_318_293 -> bv
        let s_318_294: Bits = Bits::new(s_318_293 as u128, 2u16);
        // C s_318_295: const #1u : u64
        let s_318_295: u64 = 1;
        // C s_318_296: cast zx s_318_295 -> bv
        let s_318_296: Bits = Bits::new(s_318_295 as u128, 64u16);
        // C s_318_297: lsl s_318_296 s_318_290
        let s_318_297: Bits = s_318_296 << s_318_290;
        // C s_318_298: sub s_318_297 s_318_296
        let s_318_298: Bits = ((s_318_297) - (s_318_296));
        // C s_318_299: and s_318_294 s_318_298
        let s_318_299: Bits = ((s_318_294) & (s_318_298));
        // C s_318_300: lsl s_318_299 s_318_291
        let s_318_300: Bits = s_318_299 << s_318_291;
        // C s_318_301: lsl s_318_298 s_318_291
        let s_318_301: Bits = s_318_298 << s_318_291;
        // C s_318_302: cmpl s_318_301
        let s_318_302: Bits = !s_318_301;
        // D s_318_303: and s_318_292 s_318_302
        let s_318_303: Bits = ((s_318_292) & (s_318_302));
        // D s_318_304: or s_318_303 s_318_300
        let s_318_304: Bits = ((s_318_303) | (s_318_300));
        // D s_318_305: cast reint s_318_304 -> u32
        let s_318_305: u32 = (s_318_304.value() as u32);
        // D s_318_306: call Mk_DISR_Type(s_318_305)
        let s_318_306: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_305,
        );
        // D s_318_307: call DISR_write(s_318_306)
        let s_318_307: () = DISR_write(state, tracer, s_318_306);
        // C s_318_308: const #() : ()
        let s_318_308: () = ();
        // S s_318_309: call DISR_read(s_318_308)
        let s_318_309: ProductType700c18a878c5601b = DISR_read(state, tracer, s_318_308);
        // D s_318_310: write-var ga#36760 <= s_318_309
        fn_state.ga_36760 = s_318_309;
        // D s_318_311: read-var ga#36760.0:struct
        let s_318_311: u32 = fn_state.ga_36760._0;
        // C s_318_312: const #3s : i
        let s_318_312: i128 = 3;
        // C s_318_313: const #6s : i
        let s_318_313: i128 = 6;
        // D s_318_314: cast zx s_318_311 -> bv
        let s_318_314: Bits = Bits::new(s_318_311 as u128, 32u16);
        // C s_318_315: const #0u : u8
        let s_318_315: u8 = 0;
        // C s_318_316: cast zx s_318_315 -> bv
        let s_318_316: Bits = Bits::new(s_318_315 as u128, 3u16);
        // C s_318_317: const #1u : u64
        let s_318_317: u64 = 1;
        // C s_318_318: cast zx s_318_317 -> bv
        let s_318_318: Bits = Bits::new(s_318_317 as u128, 64u16);
        // C s_318_319: lsl s_318_318 s_318_312
        let s_318_319: Bits = s_318_318 << s_318_312;
        // C s_318_320: sub s_318_319 s_318_318
        let s_318_320: Bits = ((s_318_319) - (s_318_318));
        // C s_318_321: and s_318_316 s_318_320
        let s_318_321: Bits = ((s_318_316) & (s_318_320));
        // C s_318_322: lsl s_318_321 s_318_313
        let s_318_322: Bits = s_318_321 << s_318_313;
        // C s_318_323: lsl s_318_320 s_318_313
        let s_318_323: Bits = s_318_320 << s_318_313;
        // C s_318_324: cmpl s_318_323
        let s_318_324: Bits = !s_318_323;
        // D s_318_325: and s_318_314 s_318_324
        let s_318_325: Bits = ((s_318_314) & (s_318_324));
        // D s_318_326: or s_318_325 s_318_322
        let s_318_326: Bits = ((s_318_325) | (s_318_322));
        // D s_318_327: cast reint s_318_326 -> u32
        let s_318_327: u32 = (s_318_326.value() as u32);
        // D s_318_328: call Mk_DISR_Type(s_318_327)
        let s_318_328: ProductType700c18a878c5601b = Mk_DISR_Type(
            state,
            tracer,
            s_318_327,
        );
        // D s_318_329: call DISR_write(s_318_328)
        let s_318_329: () = DISR_write(state, tracer, s_318_328);
        // C s_318_330: const #() : ()
        let s_318_330: () = ();
        // S s_318_331: call VDFSR_read(s_318_330)
        let s_318_331: ProductType700c18a878c5601b = VDFSR_read(
            state,
            tracer,
            s_318_330,
        );
        // D s_318_332: write-var ga#36764 <= s_318_331
        fn_state.ga_36764 = s_318_331;
        // D s_318_333: read-var ga#36764.0:struct
        let s_318_333: u32 = fn_state.ga_36764._0;
        // C s_318_334: const #16s : i
        let s_318_334: i128 = 16;
        // C s_318_335: const #16s : i
        let s_318_335: i128 = 16;
        // D s_318_336: cast zx s_318_333 -> bv
        let s_318_336: Bits = Bits::new(s_318_333 as u128, 32u16);
        // C s_318_337: const #0u : u16
        let s_318_337: u16 = 0;
        // C s_318_338: cast zx s_318_337 -> bv
        let s_318_338: Bits = Bits::new(s_318_337 as u128, 16u16);
        // C s_318_339: const #1u : u64
        let s_318_339: u64 = 1;
        // C s_318_340: cast zx s_318_339 -> bv
        let s_318_340: Bits = Bits::new(s_318_339 as u128, 64u16);
        // C s_318_341: lsl s_318_340 s_318_334
        let s_318_341: Bits = s_318_340 << s_318_334;
        // C s_318_342: sub s_318_341 s_318_340
        let s_318_342: Bits = ((s_318_341) - (s_318_340));
        // C s_318_343: and s_318_338 s_318_342
        let s_318_343: Bits = ((s_318_338) & (s_318_342));
        // C s_318_344: lsl s_318_343 s_318_335
        let s_318_344: Bits = s_318_343 << s_318_335;
        // C s_318_345: lsl s_318_342 s_318_335
        let s_318_345: Bits = s_318_342 << s_318_335;
        // C s_318_346: cmpl s_318_345
        let s_318_346: Bits = !s_318_345;
        // D s_318_347: and s_318_336 s_318_346
        let s_318_347: Bits = ((s_318_336) & (s_318_346));
        // D s_318_348: or s_318_347 s_318_344
        let s_318_348: Bits = ((s_318_347) | (s_318_344));
        // D s_318_349: cast reint s_318_348 -> u32
        let s_318_349: u32 = (s_318_348.value() as u32);
        // D s_318_350: call Mk_VDFSR_Type(s_318_349)
        let s_318_350: ProductType700c18a878c5601b = Mk_VDFSR_Type(
            state,
            tracer,
            s_318_349,
        );
        // D s_318_351: call VDFSR_write(s_318_350)
        let s_318_351: () = VDFSR_write(state, tracer, s_318_350);
        // C s_318_352: const #() : ()
        let s_318_352: () = ();
        // S s_318_353: call VDFSR_read(s_318_352)
        let s_318_353: ProductType700c18a878c5601b = VDFSR_read(
            state,
            tracer,
            s_318_352,
        );
        // D s_318_354: write-var ga#36768 <= s_318_353
        fn_state.ga_36768 = s_318_353;
        // D s_318_355: read-var ga#36768.0:struct
        let s_318_355: u32 = fn_state.ga_36768._0;
        // C s_318_356: const #1s : i
        let s_318_356: i128 = 1;
        // C s_318_357: const #13s : i
        let s_318_357: i128 = 13;
        // D s_318_358: cast zx s_318_355 -> bv
        let s_318_358: Bits = Bits::new(s_318_355 as u128, 32u16);
        // C s_318_359: const #0u : u8
        let s_318_359: bool = false;
        // C s_318_360: cast zx s_318_359 -> bv
        let s_318_360: Bits = Bits::new(s_318_359 as u128, 1u16);
        // C s_318_361: const #1u : u64
        let s_318_361: u64 = 1;
        // C s_318_362: cast zx s_318_361 -> bv
        let s_318_362: Bits = Bits::new(s_318_361 as u128, 64u16);
        // C s_318_363: lsl s_318_362 s_318_356
        let s_318_363: Bits = s_318_362 << s_318_356;
        // C s_318_364: sub s_318_363 s_318_362
        let s_318_364: Bits = ((s_318_363) - (s_318_362));
        // C s_318_365: and s_318_360 s_318_364
        let s_318_365: Bits = ((s_318_360) & (s_318_364));
        // C s_318_366: lsl s_318_365 s_318_357
        let s_318_366: Bits = s_318_365 << s_318_357;
        // C s_318_367: lsl s_318_364 s_318_357
        let s_318_367: Bits = s_318_364 << s_318_357;
        // C s_318_368: cmpl s_318_367
        let s_318_368: Bits = !s_318_367;
        // D s_318_369: and s_318_358 s_318_368
        let s_318_369: Bits = ((s_318_358) & (s_318_368));
        // D s_318_370: or s_318_369 s_318_366
        let s_318_370: Bits = ((s_318_369) | (s_318_366));
        // D s_318_371: cast reint s_318_370 -> u32
        let s_318_371: u32 = (s_318_370.value() as u32);
        // D s_318_372: call Mk_VDFSR_Type(s_318_371)
        let s_318_372: ProductType700c18a878c5601b = Mk_VDFSR_Type(
            state,
            tracer,
            s_318_371,
        );
        // D s_318_373: call VDFSR_write(s_318_372)
        let s_318_373: () = VDFSR_write(state, tracer, s_318_372);
        // C s_318_374: const #() : ()
        let s_318_374: () = ();
        // S s_318_375: call VDFSR_read(s_318_374)
        let s_318_375: ProductType700c18a878c5601b = VDFSR_read(
            state,
            tracer,
            s_318_374,
        );
        // D s_318_376: write-var ga#36772 <= s_318_375
        fn_state.ga_36772 = s_318_375;
        // D s_318_377: read-var ga#36772.0:struct
        let s_318_377: u32 = fn_state.ga_36772._0;
        // C s_318_378: const #12s : i
        let s_318_378: i128 = 12;
        // C s_318_379: const #0s : i
        let s_318_379: i128 = 0;
        // D s_318_380: cast zx s_318_377 -> bv
        let s_318_380: Bits = Bits::new(s_318_377 as u128, 32u16);
        // C s_318_381: const #0u : u12
        let s_318_381: u16 = 0;
        // C s_318_382: cast zx s_318_381 -> bv
        let s_318_382: Bits = Bits::new(s_318_381 as u128, 12u16);
        // C s_318_383: const #1u : u64
        let s_318_383: u64 = 1;
        // C s_318_384: cast zx s_318_383 -> bv
        let s_318_384: Bits = Bits::new(s_318_383 as u128, 64u16);
        // C s_318_385: lsl s_318_384 s_318_378
        let s_318_385: Bits = s_318_384 << s_318_378;
        // C s_318_386: sub s_318_385 s_318_384
        let s_318_386: Bits = ((s_318_385) - (s_318_384));
        // C s_318_387: and s_318_382 s_318_386
        let s_318_387: Bits = ((s_318_382) & (s_318_386));
        // C s_318_388: lsl s_318_387 s_318_379
        let s_318_388: Bits = s_318_387 << s_318_379;
        // C s_318_389: lsl s_318_386 s_318_379
        let s_318_389: Bits = s_318_386 << s_318_379;
        // C s_318_390: cmpl s_318_389
        let s_318_390: Bits = !s_318_389;
        // D s_318_391: and s_318_380 s_318_390
        let s_318_391: Bits = ((s_318_380) & (s_318_390));
        // D s_318_392: or s_318_391 s_318_388
        let s_318_392: Bits = ((s_318_391) | (s_318_388));
        // D s_318_393: cast reint s_318_392 -> u32
        let s_318_393: u32 = (s_318_392.value() as u32);
        // D s_318_394: call Mk_VDFSR_Type(s_318_393)
        let s_318_394: ProductType700c18a878c5601b = Mk_VDFSR_Type(
            state,
            tracer,
            s_318_393,
        );
        // D s_318_395: call VDFSR_write(s_318_394)
        let s_318_395: () = VDFSR_write(state, tracer, s_318_394);
        // C s_318_396: const #() : ()
        let s_318_396: () = ();
        // S s_318_397: call VDISR_read(s_318_396)
        let s_318_397: ProductType700c18a878c5601b = VDISR_read(
            state,
            tracer,
            s_318_396,
        );
        // D s_318_398: write-var ga#36776 <= s_318_397
        fn_state.ga_36776 = s_318_397;
        // D s_318_399: read-var ga#36776.0:struct
        let s_318_399: u32 = fn_state.ga_36776._0;
        // C s_318_400: const #15s : i
        let s_318_400: i128 = 15;
        // C s_318_401: const #16s : i
        let s_318_401: i128 = 16;
        // D s_318_402: cast zx s_318_399 -> bv
        let s_318_402: Bits = Bits::new(s_318_399 as u128, 32u16);
        // C s_318_403: const #0u : u15
        let s_318_403: u16 = 0;
        // C s_318_404: cast zx s_318_403 -> bv
        let s_318_404: Bits = Bits::new(s_318_403 as u128, 15u16);
        // C s_318_405: const #1u : u64
        let s_318_405: u64 = 1;
        // C s_318_406: cast zx s_318_405 -> bv
        let s_318_406: Bits = Bits::new(s_318_405 as u128, 64u16);
        // C s_318_407: lsl s_318_406 s_318_400
        let s_318_407: Bits = s_318_406 << s_318_400;
        // C s_318_408: sub s_318_407 s_318_406
        let s_318_408: Bits = ((s_318_407) - (s_318_406));
        // C s_318_409: and s_318_404 s_318_408
        let s_318_409: Bits = ((s_318_404) & (s_318_408));
        // C s_318_410: lsl s_318_409 s_318_401
        let s_318_410: Bits = s_318_409 << s_318_401;
        // C s_318_411: lsl s_318_408 s_318_401
        let s_318_411: Bits = s_318_408 << s_318_401;
        // C s_318_412: cmpl s_318_411
        let s_318_412: Bits = !s_318_411;
        // D s_318_413: and s_318_402 s_318_412
        let s_318_413: Bits = ((s_318_402) & (s_318_412));
        // D s_318_414: or s_318_413 s_318_410
        let s_318_414: Bits = ((s_318_413) | (s_318_410));
        // D s_318_415: cast reint s_318_414 -> u32
        let s_318_415: u32 = (s_318_414.value() as u32);
        // D s_318_416: call Mk_VDISR_Type(s_318_415)
        let s_318_416: ProductType700c18a878c5601b = Mk_VDISR_Type(
            state,
            tracer,
            s_318_415,
        );
        // D s_318_417: call VDISR_write(s_318_416)
        let s_318_417: () = VDISR_write(state, tracer, s_318_416);
        // C s_318_418: const #() : ()
        let s_318_418: () = ();
        // S s_318_419: call VDISR_read(s_318_418)
        let s_318_419: ProductType700c18a878c5601b = VDISR_read(
            state,
            tracer,
            s_318_418,
        );
        // D s_318_420: write-var ga#36780 <= s_318_419
        fn_state.ga_36780 = s_318_419;
        // D s_318_421: read-var ga#36780.0:struct
        let s_318_421: u32 = fn_state.ga_36780._0;
        // C s_318_422: const #1s : i
        let s_318_422: i128 = 1;
        // C s_318_423: const #13s : i
        let s_318_423: i128 = 13;
        // D s_318_424: cast zx s_318_421 -> bv
        let s_318_424: Bits = Bits::new(s_318_421 as u128, 32u16);
        // C s_318_425: const #0u : u8
        let s_318_425: bool = false;
        // C s_318_426: cast zx s_318_425 -> bv
        let s_318_426: Bits = Bits::new(s_318_425 as u128, 1u16);
        // C s_318_427: const #1u : u64
        let s_318_427: u64 = 1;
        // C s_318_428: cast zx s_318_427 -> bv
        let s_318_428: Bits = Bits::new(s_318_427 as u128, 64u16);
        // C s_318_429: lsl s_318_428 s_318_422
        let s_318_429: Bits = s_318_428 << s_318_422;
        // C s_318_430: sub s_318_429 s_318_428
        let s_318_430: Bits = ((s_318_429) - (s_318_428));
        // C s_318_431: and s_318_426 s_318_430
        let s_318_431: Bits = ((s_318_426) & (s_318_430));
        // C s_318_432: lsl s_318_431 s_318_423
        let s_318_432: Bits = s_318_431 << s_318_423;
        // C s_318_433: lsl s_318_430 s_318_423
        let s_318_433: Bits = s_318_430 << s_318_423;
        // C s_318_434: cmpl s_318_433
        let s_318_434: Bits = !s_318_433;
        // D s_318_435: and s_318_424 s_318_434
        let s_318_435: Bits = ((s_318_424) & (s_318_434));
        // D s_318_436: or s_318_435 s_318_432
        let s_318_436: Bits = ((s_318_435) | (s_318_432));
        // D s_318_437: cast reint s_318_436 -> u32
        let s_318_437: u32 = (s_318_436.value() as u32);
        // D s_318_438: call Mk_VDISR_Type(s_318_437)
        let s_318_438: ProductType700c18a878c5601b = Mk_VDISR_Type(
            state,
            tracer,
            s_318_437,
        );
        // D s_318_439: call VDISR_write(s_318_438)
        let s_318_439: () = VDISR_write(state, tracer, s_318_438);
        // C s_318_440: const #() : ()
        let s_318_440: () = ();
        // S s_318_441: call VDISR_read(s_318_440)
        let s_318_441: ProductType700c18a878c5601b = VDISR_read(
            state,
            tracer,
            s_318_440,
        );
        // D s_318_442: write-var ga#36784 <= s_318_441
        fn_state.ga_36784 = s_318_441;
        // D s_318_443: read-var ga#36784.0:struct
        let s_318_443: u32 = fn_state.ga_36784._0;
        // C s_318_444: const #1s : i
        let s_318_444: i128 = 1;
        // C s_318_445: const #11s : i
        let s_318_445: i128 = 11;
        // D s_318_446: cast zx s_318_443 -> bv
        let s_318_446: Bits = Bits::new(s_318_443 as u128, 32u16);
        // C s_318_447: const #0u : u8
        let s_318_447: bool = false;
        // C s_318_448: cast zx s_318_447 -> bv
        let s_318_448: Bits = Bits::new(s_318_447 as u128, 1u16);
        // C s_318_449: const #1u : u64
        let s_318_449: u64 = 1;
        // C s_318_450: cast zx s_318_449 -> bv
        let s_318_450: Bits = Bits::new(s_318_449 as u128, 64u16);
        // C s_318_451: lsl s_318_450 s_318_444
        let s_318_451: Bits = s_318_450 << s_318_444;
        // C s_318_452: sub s_318_451 s_318_450
        let s_318_452: Bits = ((s_318_451) - (s_318_450));
        // C s_318_453: and s_318_448 s_318_452
        let s_318_453: Bits = ((s_318_448) & (s_318_452));
        // C s_318_454: lsl s_318_453 s_318_445
        let s_318_454: Bits = s_318_453 << s_318_445;
        // C s_318_455: lsl s_318_452 s_318_445
        let s_318_455: Bits = s_318_452 << s_318_445;
        // C s_318_456: cmpl s_318_455
        let s_318_456: Bits = !s_318_455;
        // D s_318_457: and s_318_446 s_318_456
        let s_318_457: Bits = ((s_318_446) & (s_318_456));
        // D s_318_458: or s_318_457 s_318_454
        let s_318_458: Bits = ((s_318_457) | (s_318_454));
        // D s_318_459: cast reint s_318_458 -> u32
        let s_318_459: u32 = (s_318_458.value() as u32);
        // D s_318_460: call Mk_VDISR_Type(s_318_459)
        let s_318_460: ProductType700c18a878c5601b = Mk_VDISR_Type(
            state,
            tracer,
            s_318_459,
        );
        // D s_318_461: call VDISR_write(s_318_460)
        let s_318_461: () = VDISR_write(state, tracer, s_318_460);
        // C s_318_462: const #() : ()
        let s_318_462: () = ();
        // S s_318_463: call VDISR_read(s_318_462)
        let s_318_463: ProductType700c18a878c5601b = VDISR_read(
            state,
            tracer,
            s_318_462,
        );
        // D s_318_464: write-var ga#36788 <= s_318_463
        fn_state.ga_36788 = s_318_463;
        // D s_318_465: read-var ga#36788.0:struct
        let s_318_465: u32 = fn_state.ga_36788._0;
        // C s_318_466: const #5s : i
        let s_318_466: i128 = 5;
        // C s_318_467: const #4s : i
        let s_318_467: i128 = 4;
        // D s_318_468: cast zx s_318_465 -> bv
        let s_318_468: Bits = Bits::new(s_318_465 as u128, 32u16);
        // C s_318_469: const #0u : u8
        let s_318_469: u8 = 0;
        // C s_318_470: cast zx s_318_469 -> bv
        let s_318_470: Bits = Bits::new(s_318_469 as u128, 5u16);
        // C s_318_471: const #1u : u64
        let s_318_471: u64 = 1;
        // C s_318_472: cast zx s_318_471 -> bv
        let s_318_472: Bits = Bits::new(s_318_471 as u128, 64u16);
        // C s_318_473: lsl s_318_472 s_318_466
        let s_318_473: Bits = s_318_472 << s_318_466;
        // C s_318_474: sub s_318_473 s_318_472
        let s_318_474: Bits = ((s_318_473) - (s_318_472));
        // C s_318_475: and s_318_470 s_318_474
        let s_318_475: Bits = ((s_318_470) & (s_318_474));
        // C s_318_476: lsl s_318_475 s_318_467
        let s_318_476: Bits = s_318_475 << s_318_467;
        // C s_318_477: lsl s_318_474 s_318_467
        let s_318_477: Bits = s_318_474 << s_318_467;
        // C s_318_478: cmpl s_318_477
        let s_318_478: Bits = !s_318_477;
        // D s_318_479: and s_318_468 s_318_478
        let s_318_479: Bits = ((s_318_468) & (s_318_478));
        // D s_318_480: or s_318_479 s_318_476
        let s_318_480: Bits = ((s_318_479) | (s_318_476));
        // D s_318_481: cast reint s_318_480 -> u32
        let s_318_481: u32 = (s_318_480.value() as u32);
        // D s_318_482: call Mk_VDISR_Type(s_318_481)
        let s_318_482: ProductType700c18a878c5601b = Mk_VDISR_Type(
            state,
            tracer,
            s_318_481,
        );
        // D s_318_483: call VDISR_write(s_318_482)
        let s_318_483: () = VDISR_write(state, tracer, s_318_482);
        // C s_318_484: const #() : ()
        let s_318_484: () = ();
        // S s_318_485: call VDISR_read(s_318_484)
        let s_318_485: ProductType700c18a878c5601b = VDISR_read(
            state,
            tracer,
            s_318_484,
        );
        // D s_318_486: write-var ga#36792 <= s_318_485
        fn_state.ga_36792 = s_318_485;
        // D s_318_487: read-var ga#36792.0:struct
        let s_318_487: u32 = fn_state.ga_36792._0;
        // C s_318_488: const #15s : i
        let s_318_488: i128 = 15;
        // C s_318_489: const #16s : i
        let s_318_489: i128 = 16;
        // D s_318_490: cast zx s_318_487 -> bv
        let s_318_490: Bits = Bits::new(s_318_487 as u128, 32u16);
        // C s_318_491: const #0u : u15
        let s_318_491: u16 = 0;
        // C s_318_492: cast zx s_318_491 -> bv
        let s_318_492: Bits = Bits::new(s_318_491 as u128, 15u16);
        // C s_318_493: const #1u : u64
        let s_318_493: u64 = 1;
        // C s_318_494: cast zx s_318_493 -> bv
        let s_318_494: Bits = Bits::new(s_318_493 as u128, 64u16);
        // C s_318_495: lsl s_318_494 s_318_488
        let s_318_495: Bits = s_318_494 << s_318_488;
        // C s_318_496: sub s_318_495 s_318_494
        let s_318_496: Bits = ((s_318_495) - (s_318_494));
        // C s_318_497: and s_318_492 s_318_496
        let s_318_497: Bits = ((s_318_492) & (s_318_496));
        // C s_318_498: lsl s_318_497 s_318_489
        let s_318_498: Bits = s_318_497 << s_318_489;
        // C s_318_499: lsl s_318_496 s_318_489
        let s_318_499: Bits = s_318_496 << s_318_489;
        // C s_318_500: cmpl s_318_499
        let s_318_500: Bits = !s_318_499;
        // D s_318_501: and s_318_490 s_318_500
        let s_318_501: Bits = ((s_318_490) & (s_318_500));
        // D s_318_502: or s_318_501 s_318_498
        let s_318_502: Bits = ((s_318_501) | (s_318_498));
        // D s_318_503: cast reint s_318_502 -> u32
        let s_318_503: u32 = (s_318_502.value() as u32);
        // D s_318_504: call Mk_VDISR_Type(s_318_503)
        let s_318_504: ProductType700c18a878c5601b = Mk_VDISR_Type(
            state,
            tracer,
            s_318_503,
        );
        // D s_318_505: call VDISR_write(s_318_504)
        let s_318_505: () = VDISR_write(state, tracer, s_318_504);
        // C s_318_506: const #() : ()
        let s_318_506: () = ();
        // S s_318_507: call VDISR_read(s_318_506)
        let s_318_507: ProductType700c18a878c5601b = VDISR_read(
            state,
            tracer,
            s_318_506,
        );
        // D s_318_508: write-var ga#36796 <= s_318_507
        fn_state.ga_36796 = s_318_507;
        // D s_318_509: read-var ga#36796.0:struct
        let s_318_509: u32 = fn_state.ga_36796._0;
        // C s_318_510: const #1s : i
        let s_318_510: i128 = 1;
        // C s_318_511: const #13s : i
        let s_318_511: i128 = 13;
        // D s_318_512: cast zx s_318_509 -> bv
        let s_318_512: Bits = Bits::new(s_318_509 as u128, 32u16);
        // C s_318_513: const #0u : u8
        let s_318_513: bool = false;
        // C s_318_514: cast zx s_318_513 -> bv
        let s_318_514: Bits = Bits::new(s_318_513 as u128, 1u16);
        // C s_318_515: const #1u : u64
        let s_318_515: u64 = 1;
        // C s_318_516: cast zx s_318_515 -> bv
        let s_318_516: Bits = Bits::new(s_318_515 as u128, 64u16);
        // C s_318_517: lsl s_318_516 s_318_510
        let s_318_517: Bits = s_318_516 << s_318_510;
        // C s_318_518: sub s_318_517 s_318_516
        let s_318_518: Bits = ((s_318_517) - (s_318_516));
        // C s_318_519: and s_318_514 s_318_518
        let s_318_519: Bits = ((s_318_514) & (s_318_518));
        // C s_318_520: lsl s_318_519 s_318_511
        let s_318_520: Bits = s_318_519 << s_318_511;
        // C s_318_521: lsl s_318_518 s_318_511
        let s_318_521: Bits = s_318_518 << s_318_511;
        // C s_318_522: cmpl s_318_521
        let s_318_522: Bits = !s_318_521;
        // D s_318_523: and s_318_512 s_318_522
        let s_318_523: Bits = ((s_318_512) & (s_318_522));
        // D s_318_524: or s_318_523 s_318_520
        let s_318_524: Bits = ((s_318_523) | (s_318_520));
        // D s_318_525: cast reint s_318_524 -> u32
        let s_318_525: u32 = (s_318_524.value() as u32);
        // D s_318_526: call Mk_VDISR_Type(s_318_525)
        let s_318_526: ProductType700c18a878c5601b = Mk_VDISR_Type(
            state,
            tracer,
            s_318_525,
        );
        // D s_318_527: call VDISR_write(s_318_526)
        let s_318_527: () = VDISR_write(state, tracer, s_318_526);
        // C s_318_528: const #() : ()
        let s_318_528: () = ();
        // S s_318_529: call VDISR_read(s_318_528)
        let s_318_529: ProductType700c18a878c5601b = VDISR_read(
            state,
            tracer,
            s_318_528,
        );
        // D s_318_530: write-var ga#36800 <= s_318_529
        fn_state.ga_36800 = s_318_529;
        // D s_318_531: read-var ga#36800.0:struct
        let s_318_531: u32 = fn_state.ga_36800._0;
        // C s_318_532: const #2s : i
        let s_318_532: i128 = 2;
        // C s_318_533: const #10s : i
        let s_318_533: i128 = 10;
        // D s_318_534: cast zx s_318_531 -> bv
        let s_318_534: Bits = Bits::new(s_318_531 as u128, 32u16);
        // C s_318_535: const #0u : u8
        let s_318_535: u8 = 0;
        // C s_318_536: cast zx s_318_535 -> bv
        let s_318_536: Bits = Bits::new(s_318_535 as u128, 2u16);
        // C s_318_537: const #1u : u64
        let s_318_537: u64 = 1;
        // C s_318_538: cast zx s_318_537 -> bv
        let s_318_538: Bits = Bits::new(s_318_537 as u128, 64u16);
        // C s_318_539: lsl s_318_538 s_318_532
        let s_318_539: Bits = s_318_538 << s_318_532;
        // C s_318_540: sub s_318_539 s_318_538
        let s_318_540: Bits = ((s_318_539) - (s_318_538));
        // C s_318_541: and s_318_536 s_318_540
        let s_318_541: Bits = ((s_318_536) & (s_318_540));
        // C s_318_542: lsl s_318_541 s_318_533
        let s_318_542: Bits = s_318_541 << s_318_533;
        // C s_318_543: lsl s_318_540 s_318_533
        let s_318_543: Bits = s_318_540 << s_318_533;
        // C s_318_544: cmpl s_318_543
        let s_318_544: Bits = !s_318_543;
        // D s_318_545: and s_318_534 s_318_544
        let s_318_545: Bits = ((s_318_534) & (s_318_544));
        // D s_318_546: or s_318_545 s_318_542
        let s_318_546: Bits = ((s_318_545) | (s_318_542));
        // D s_318_547: cast reint s_318_546 -> u32
        let s_318_547: u32 = (s_318_546.value() as u32);
        // D s_318_548: call Mk_VDISR_Type(s_318_547)
        let s_318_548: ProductType700c18a878c5601b = Mk_VDISR_Type(
            state,
            tracer,
            s_318_547,
        );
        // D s_318_549: call VDISR_write(s_318_548)
        let s_318_549: () = VDISR_write(state, tracer, s_318_548);
        // C s_318_550: const #() : ()
        let s_318_550: () = ();
        // S s_318_551: call VDISR_read(s_318_550)
        let s_318_551: ProductType700c18a878c5601b = VDISR_read(
            state,
            tracer,
            s_318_550,
        );
        // D s_318_552: write-var ga#36804 <= s_318_551
        fn_state.ga_36804 = s_318_551;
        // D s_318_553: read-var ga#36804.0:struct
        let s_318_553: u32 = fn_state.ga_36804._0;
        // C s_318_554: const #3s : i
        let s_318_554: i128 = 3;
        // C s_318_555: const #6s : i
        let s_318_555: i128 = 6;
        // D s_318_556: cast zx s_318_553 -> bv
        let s_318_556: Bits = Bits::new(s_318_553 as u128, 32u16);
        // C s_318_557: const #0u : u8
        let s_318_557: u8 = 0;
        // C s_318_558: cast zx s_318_557 -> bv
        let s_318_558: Bits = Bits::new(s_318_557 as u128, 3u16);
        // C s_318_559: const #1u : u64
        let s_318_559: u64 = 1;
        // C s_318_560: cast zx s_318_559 -> bv
        let s_318_560: Bits = Bits::new(s_318_559 as u128, 64u16);
        // C s_318_561: lsl s_318_560 s_318_554
        let s_318_561: Bits = s_318_560 << s_318_554;
        // C s_318_562: sub s_318_561 s_318_560
        let s_318_562: Bits = ((s_318_561) - (s_318_560));
        // C s_318_563: and s_318_558 s_318_562
        let s_318_563: Bits = ((s_318_558) & (s_318_562));
        // C s_318_564: lsl s_318_563 s_318_555
        let s_318_564: Bits = s_318_563 << s_318_555;
        // C s_318_565: lsl s_318_562 s_318_555
        let s_318_565: Bits = s_318_562 << s_318_555;
        // C s_318_566: cmpl s_318_565
        let s_318_566: Bits = !s_318_565;
        // D s_318_567: and s_318_556 s_318_566
        let s_318_567: Bits = ((s_318_556) & (s_318_566));
        // D s_318_568: or s_318_567 s_318_564
        let s_318_568: Bits = ((s_318_567) | (s_318_564));
        // D s_318_569: cast reint s_318_568 -> u32
        let s_318_569: u32 = (s_318_568.value() as u32);
        // D s_318_570: call Mk_VDISR_Type(s_318_569)
        let s_318_570: ProductType700c18a878c5601b = Mk_VDISR_Type(
            state,
            tracer,
            s_318_569,
        );
        // D s_318_571: call VDISR_write(s_318_570)
        let s_318_571: () = VDISR_write(state, tracer, s_318_570);
        // C s_318_572: const #10496u : u32
        let s_318_572: u32 = 10496;
        // D s_318_573: read-reg s_318_572:struct
        let s_318_573: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_318_572 as isize);
            tracer.read_register(s_318_572 as isize, value);
            value
        };
        // C s_318_574: const #10496u : u32
        let s_318_574: u32 = 10496;
        // N s_318_575: write-reg s_318_574 <= s_318_573
        let s_318_575: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_318_574 as isize, s_318_573);
            tracer.write_register(s_318_574 as isize, s_318_573);
        };
        // C s_318_576: const #10496u : u32
        let s_318_576: u32 = 10496;
        // D s_318_577: read-reg s_318_576:struct
        let s_318_577: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_318_576 as isize);
            tracer.read_register(s_318_576 as isize, value);
            value
        };
        // C s_318_578: const #10496u : u32
        let s_318_578: u32 = 10496;
        // N s_318_579: write-reg s_318_578 <= s_318_577
        let s_318_579: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_318_578 as isize, s_318_577);
            tracer.write_register(s_318_578 as isize, s_318_577);
        };
        // C s_318_580: const #"access is Secure, in a system that supports two Security states" : str
        let s_318_580: &'static str = "access is Secure, in a system that supports two Security states";
        // S s_318_581: call __IMPDEF_boolean(s_318_580)
        let s_318_581: bool = u__IMPDEF_boolean(state, tracer, s_318_580);
        // N s_318_582: branch s_318_581 b492 b319
        if s_318_581 {
            return block_492(state, tracer, fn_state);
        } else {
            return block_319(state, tracer, fn_state);
        };
    }
    fn block_319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_319_0: jump b320
        return block_320(state, tracer, fn_state);
    }
    fn block_320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_320_0: const #0u : u8
        let s_320_0: bool = false;
        // S s_320_1: call Bit(s_320_0)
        let s_320_1: bool = Bit(state, tracer, s_320_0);
        // C s_320_2: const #10496u : u32
        let s_320_2: u32 = 10496;
        // D s_320_3: read-reg s_320_2:struct
        let s_320_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_2 as isize);
            tracer.read_register(s_320_2 as isize, value);
            value
        };
        // C s_320_4: const #10496u : u32
        let s_320_4: u32 = 10496;
        // N s_320_5: write-reg s_320_4 <= s_320_3
        let s_320_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_4 as isize, s_320_3);
            tracer.write_register(s_320_4 as isize, s_320_3);
        };
        // C s_320_6: const #10496u : u32
        let s_320_6: u32 = 10496;
        // D s_320_7: read-reg s_320_6:struct
        let s_320_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_6 as isize);
            tracer.read_register(s_320_6 as isize, value);
            value
        };
        // C s_320_8: const #10496u : u32
        let s_320_8: u32 = 10496;
        // N s_320_9: write-reg s_320_8 <= s_320_7
        let s_320_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_8 as isize, s_320_7);
            tracer.write_register(s_320_8 as isize, s_320_7);
        };
        // C s_320_10: const #0u : u8
        let s_320_10: bool = false;
        // S s_320_11: call Bit(s_320_10)
        let s_320_11: bool = Bit(state, tracer, s_320_10);
        // C s_320_12: const #10496u : u32
        let s_320_12: u32 = 10496;
        // D s_320_13: read-reg s_320_12:struct
        let s_320_13: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_12 as isize);
            tracer.read_register(s_320_12 as isize, value);
            value
        };
        // C s_320_14: const #10496u : u32
        let s_320_14: u32 = 10496;
        // N s_320_15: write-reg s_320_14 <= s_320_13
        let s_320_15: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_14 as isize, s_320_13);
            tracer.write_register(s_320_14 as isize, s_320_13);
        };
        // C s_320_16: const #10496u : u32
        let s_320_16: u32 = 10496;
        // D s_320_17: read-reg s_320_16:struct
        let s_320_17: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_16 as isize);
            tracer.read_register(s_320_16 as isize, value);
            value
        };
        // C s_320_18: const #10496u : u32
        let s_320_18: u32 = 10496;
        // N s_320_19: write-reg s_320_18 <= s_320_17
        let s_320_19: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_18 as isize, s_320_17);
            tracer.write_register(s_320_18 as isize, s_320_17);
        };
        // C s_320_20: const #10496u : u32
        let s_320_20: u32 = 10496;
        // D s_320_21: read-reg s_320_20:struct
        let s_320_21: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_20 as isize);
            tracer.read_register(s_320_20 as isize, value);
            value
        };
        // C s_320_22: const #10496u : u32
        let s_320_22: u32 = 10496;
        // N s_320_23: write-reg s_320_22 <= s_320_21
        let s_320_23: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_22 as isize, s_320_21);
            tracer.write_register(s_320_22 as isize, s_320_21);
        };
        // C s_320_24: const #10496u : u32
        let s_320_24: u32 = 10496;
        // D s_320_25: read-reg s_320_24:struct
        let s_320_25: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_24 as isize);
            tracer.read_register(s_320_24 as isize, value);
            value
        };
        // C s_320_26: const #10496u : u32
        let s_320_26: u32 = 10496;
        // N s_320_27: write-reg s_320_26 <= s_320_25
        let s_320_27: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_26 as isize, s_320_25);
            tracer.write_register(s_320_26 as isize, s_320_25);
        };
        // C s_320_28: const #10496u : u32
        let s_320_28: u32 = 10496;
        // D s_320_29: read-reg s_320_28:struct
        let s_320_29: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_28 as isize);
            tracer.read_register(s_320_28 as isize, value);
            value
        };
        // C s_320_30: const #10496u : u32
        let s_320_30: u32 = 10496;
        // N s_320_31: write-reg s_320_30 <= s_320_29
        let s_320_31: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_30 as isize, s_320_29);
            tracer.write_register(s_320_30 as isize, s_320_29);
        };
        // C s_320_32: const #0u : u8
        let s_320_32: bool = false;
        // S s_320_33: call Bit(s_320_32)
        let s_320_33: bool = Bit(state, tracer, s_320_32);
        // C s_320_34: const #10496u : u32
        let s_320_34: u32 = 10496;
        // D s_320_35: read-reg s_320_34:struct
        let s_320_35: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_34 as isize);
            tracer.read_register(s_320_34 as isize, value);
            value
        };
        // C s_320_36: const #10496u : u32
        let s_320_36: u32 = 10496;
        // N s_320_37: write-reg s_320_36 <= s_320_35
        let s_320_37: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_36 as isize, s_320_35);
            tracer.write_register(s_320_36 as isize, s_320_35);
        };
        // C s_320_38: const #10496u : u32
        let s_320_38: u32 = 10496;
        // D s_320_39: read-reg s_320_38:struct
        let s_320_39: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_38 as isize);
            tracer.read_register(s_320_38 as isize, value);
            value
        };
        // C s_320_40: const #10496u : u32
        let s_320_40: u32 = 10496;
        // N s_320_41: write-reg s_320_40 <= s_320_39
        let s_320_41: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_40 as isize, s_320_39);
            tracer.write_register(s_320_40 as isize, s_320_39);
        };
        // C s_320_42: const #10496u : u32
        let s_320_42: u32 = 10496;
        // D s_320_43: read-reg s_320_42:struct
        let s_320_43: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_42 as isize);
            tracer.read_register(s_320_42 as isize, value);
            value
        };
        // C s_320_44: const #10496u : u32
        let s_320_44: u32 = 10496;
        // N s_320_45: write-reg s_320_44 <= s_320_43
        let s_320_45: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_44 as isize, s_320_43);
            tracer.write_register(s_320_44 as isize, s_320_43);
        };
        // C s_320_46: const #15512u : u32
        let s_320_46: u32 = 15512;
        // D s_320_47: read-reg s_320_46:struct
        let s_320_47: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_46 as isize);
            tracer.read_register(s_320_46 as isize, value);
            value
        };
        // C s_320_48: const #15512u : u32
        let s_320_48: u32 = 15512;
        // N s_320_49: write-reg s_320_48 <= s_320_47
        let s_320_49: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_48 as isize, s_320_47);
            tracer.write_register(s_320_48 as isize, s_320_47);
        };
        // C s_320_50: const #18984u : u32
        let s_320_50: u32 = 18984;
        // D s_320_51: read-reg s_320_50:struct
        let s_320_51: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_50 as isize);
            tracer.read_register(s_320_50 as isize, value);
            value
        };
        // C s_320_52: const #18984u : u32
        let s_320_52: u32 = 18984;
        // N s_320_53: write-reg s_320_52 <= s_320_51
        let s_320_53: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_52 as isize, s_320_51);
            tracer.write_register(s_320_52 as isize, s_320_51);
        };
        // C s_320_54: const #17696u : u32
        let s_320_54: u32 = 17696;
        // D s_320_55: read-reg s_320_54:struct
        let s_320_55: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_54 as isize);
            tracer.read_register(s_320_54 as isize, value);
            value
        };
        // C s_320_56: const #17696u : u32
        let s_320_56: u32 = 17696;
        // N s_320_57: write-reg s_320_56 <= s_320_55
        let s_320_57: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_56 as isize, s_320_55);
            tracer.write_register(s_320_56 as isize, s_320_55);
        };
        // C s_320_58: const #20016u : u32
        let s_320_58: u32 = 20016;
        // D s_320_59: read-reg s_320_58:struct
        let s_320_59: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_58 as isize);
            tracer.read_register(s_320_58 as isize, value);
            value
        };
        // C s_320_60: const #20016u : u32
        let s_320_60: u32 = 20016;
        // N s_320_61: write-reg s_320_60 <= s_320_59
        let s_320_61: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_60 as isize, s_320_59);
            tracer.write_register(s_320_60 as isize, s_320_59);
        };
        // C s_320_62: const #22384u : u32
        let s_320_62: u32 = 22384;
        // D s_320_63: read-reg s_320_62:struct
        let s_320_63: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_62 as isize);
            tracer.read_register(s_320_62 as isize, value);
            value
        };
        // C s_320_64: const #22384u : u32
        let s_320_64: u32 = 22384;
        // N s_320_65: write-reg s_320_64 <= s_320_63
        let s_320_65: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_64 as isize, s_320_63);
            tracer.write_register(s_320_64 as isize, s_320_63);
        };
        // C s_320_66: const #22384u : u32
        let s_320_66: u32 = 22384;
        // D s_320_67: read-reg s_320_66:struct
        let s_320_67: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_66 as isize);
            tracer.read_register(s_320_66 as isize, value);
            value
        };
        // C s_320_68: const #22384u : u32
        let s_320_68: u32 = 22384;
        // N s_320_69: write-reg s_320_68 <= s_320_67
        let s_320_69: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_68 as isize, s_320_67);
            tracer.write_register(s_320_68 as isize, s_320_67);
        };
        // C s_320_70: const #22384u : u32
        let s_320_70: u32 = 22384;
        // D s_320_71: read-reg s_320_70:struct
        let s_320_71: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_70 as isize);
            tracer.read_register(s_320_70 as isize, value);
            value
        };
        // C s_320_72: const #22384u : u32
        let s_320_72: u32 = 22384;
        // N s_320_73: write-reg s_320_72 <= s_320_71
        let s_320_73: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_72 as isize, s_320_71);
            tracer.write_register(s_320_72 as isize, s_320_71);
        };
        // C s_320_74: const #22384u : u32
        let s_320_74: u32 = 22384;
        // D s_320_75: read-reg s_320_74:struct
        let s_320_75: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_74 as isize);
            tracer.read_register(s_320_74 as isize, value);
            value
        };
        // C s_320_76: const #22384u : u32
        let s_320_76: u32 = 22384;
        // N s_320_77: write-reg s_320_76 <= s_320_75
        let s_320_77: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_76 as isize, s_320_75);
            tracer.write_register(s_320_76 as isize, s_320_75);
        };
        // C s_320_78: const #22384u : u32
        let s_320_78: u32 = 22384;
        // D s_320_79: read-reg s_320_78:struct
        let s_320_79: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_78 as isize);
            tracer.read_register(s_320_78 as isize, value);
            value
        };
        // C s_320_80: const #22384u : u32
        let s_320_80: u32 = 22384;
        // N s_320_81: write-reg s_320_80 <= s_320_79
        let s_320_81: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_80 as isize, s_320_79);
            tracer.write_register(s_320_80 as isize, s_320_79);
        };
        // C s_320_82: const #22384u : u32
        let s_320_82: u32 = 22384;
        // D s_320_83: read-reg s_320_82:struct
        let s_320_83: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_82 as isize);
            tracer.read_register(s_320_82 as isize, value);
            value
        };
        // C s_320_84: const #22384u : u32
        let s_320_84: u32 = 22384;
        // N s_320_85: write-reg s_320_84 <= s_320_83
        let s_320_85: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_84 as isize, s_320_83);
            tracer.write_register(s_320_84 as isize, s_320_83);
        };
        // C s_320_86: const #22384u : u32
        let s_320_86: u32 = 22384;
        // D s_320_87: read-reg s_320_86:struct
        let s_320_87: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_86 as isize);
            tracer.read_register(s_320_86 as isize, value);
            value
        };
        // C s_320_88: const #22384u : u32
        let s_320_88: u32 = 22384;
        // N s_320_89: write-reg s_320_88 <= s_320_87
        let s_320_89: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_88 as isize, s_320_87);
            tracer.write_register(s_320_88 as isize, s_320_87);
        };
        // C s_320_90: const #22384u : u32
        let s_320_90: u32 = 22384;
        // D s_320_91: read-reg s_320_90:struct
        let s_320_91: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_90 as isize);
            tracer.read_register(s_320_90 as isize, value);
            value
        };
        // C s_320_92: const #22384u : u32
        let s_320_92: u32 = 22384;
        // N s_320_93: write-reg s_320_92 <= s_320_91
        let s_320_93: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_92 as isize, s_320_91);
            tracer.write_register(s_320_92 as isize, s_320_91);
        };
        // C s_320_94: const #22384u : u32
        let s_320_94: u32 = 22384;
        // D s_320_95: read-reg s_320_94:struct
        let s_320_95: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_94 as isize);
            tracer.read_register(s_320_94 as isize, value);
            value
        };
        // C s_320_96: const #22384u : u32
        let s_320_96: u32 = 22384;
        // N s_320_97: write-reg s_320_96 <= s_320_95
        let s_320_97: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_96 as isize, s_320_95);
            tracer.write_register(s_320_96 as isize, s_320_95);
        };
        // C s_320_98: const #13736u : u32
        let s_320_98: u32 = 13736;
        // D s_320_99: read-reg s_320_98:struct
        let s_320_99: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_98 as isize);
            tracer.read_register(s_320_98 as isize, value);
            value
        };
        // C s_320_100: const #13736u : u32
        let s_320_100: u32 = 13736;
        // N s_320_101: write-reg s_320_100 <= s_320_99
        let s_320_101: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_100 as isize, s_320_99);
            tracer.write_register(s_320_100 as isize, s_320_99);
        };
        // C s_320_102: const #15016u : u32
        let s_320_102: u32 = 15016;
        // D s_320_103: read-reg s_320_102:struct
        let s_320_103: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_102 as isize);
            tracer.read_register(s_320_102 as isize, value);
            value
        };
        // C s_320_104: const #15016u : u32
        let s_320_104: u32 = 15016;
        // N s_320_105: write-reg s_320_104 <= s_320_103
        let s_320_105: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_104 as isize, s_320_103);
            tracer.write_register(s_320_104 as isize, s_320_103);
        };
        // C s_320_106: const #15016u : u32
        let s_320_106: u32 = 15016;
        // D s_320_107: read-reg s_320_106:struct
        let s_320_107: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_106 as isize);
            tracer.read_register(s_320_106 as isize, value);
            value
        };
        // C s_320_108: const #15016u : u32
        let s_320_108: u32 = 15016;
        // N s_320_109: write-reg s_320_108 <= s_320_107
        let s_320_109: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_108 as isize, s_320_107);
            tracer.write_register(s_320_108 as isize, s_320_107);
        };
        // C s_320_110: const #15016u : u32
        let s_320_110: u32 = 15016;
        // D s_320_111: read-reg s_320_110:struct
        let s_320_111: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_110 as isize);
            tracer.read_register(s_320_110 as isize, value);
            value
        };
        // C s_320_112: const #15016u : u32
        let s_320_112: u32 = 15016;
        // N s_320_113: write-reg s_320_112 <= s_320_111
        let s_320_113: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_112 as isize, s_320_111);
            tracer.write_register(s_320_112 as isize, s_320_111);
        };
        // C s_320_114: const #15016u : u32
        let s_320_114: u32 = 15016;
        // D s_320_115: read-reg s_320_114:struct
        let s_320_115: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_114 as isize);
            tracer.read_register(s_320_114 as isize, value);
            value
        };
        // C s_320_116: const #15016u : u32
        let s_320_116: u32 = 15016;
        // N s_320_117: write-reg s_320_116 <= s_320_115
        let s_320_117: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_116 as isize, s_320_115);
            tracer.write_register(s_320_116 as isize, s_320_115);
        };
        // C s_320_118: const #15016u : u32
        let s_320_118: u32 = 15016;
        // D s_320_119: read-reg s_320_118:struct
        let s_320_119: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_118 as isize);
            tracer.read_register(s_320_118 as isize, value);
            value
        };
        // C s_320_120: const #15016u : u32
        let s_320_120: u32 = 15016;
        // N s_320_121: write-reg s_320_120 <= s_320_119
        let s_320_121: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_120 as isize, s_320_119);
            tracer.write_register(s_320_120 as isize, s_320_119);
        };
        // C s_320_122: const #15016u : u32
        let s_320_122: u32 = 15016;
        // D s_320_123: read-reg s_320_122:struct
        let s_320_123: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_122 as isize);
            tracer.read_register(s_320_122 as isize, value);
            value
        };
        // C s_320_124: const #15016u : u32
        let s_320_124: u32 = 15016;
        // N s_320_125: write-reg s_320_124 <= s_320_123
        let s_320_125: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_124 as isize, s_320_123);
            tracer.write_register(s_320_124 as isize, s_320_123);
        };
        // C s_320_126: const #13672u : u32
        let s_320_126: u32 = 13672;
        // D s_320_127: read-reg s_320_126:struct
        let s_320_127: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_126 as isize);
            tracer.read_register(s_320_126 as isize, value);
            value
        };
        // C s_320_128: const #13672u : u32
        let s_320_128: u32 = 13672;
        // N s_320_129: write-reg s_320_128 <= s_320_127
        let s_320_129: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_128 as isize, s_320_127);
            tracer.write_register(s_320_128 as isize, s_320_127);
        };
        // C s_320_130: const #15456u : u32
        let s_320_130: u32 = 15456;
        // D s_320_131: read-reg s_320_130:struct
        let s_320_131: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_320_130 as isize);
            tracer.read_register(s_320_130 as isize, value);
            value
        };
        // C s_320_132: const #15456u : u32
        let s_320_132: u32 = 15456;
        // N s_320_133: write-reg s_320_132 <= s_320_131
        let s_320_133: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_320_132 as isize, s_320_131);
            tracer.write_register(s_320_132 as isize, s_320_131);
        };
        // D s_320_134: read-var cold:u8
        let s_320_134: bool = fn_state.cold;
        // N s_320_135: branch s_320_134 b491 b321
        if s_320_134 {
            return block_491(state, tracer, fn_state);
        } else {
            return block_321(state, tracer, fn_state);
        };
    }
    fn block_321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_321_0: const #0u : u8
        let s_321_0: bool = false;
        // D s_321_1: write-var gs#45018 <= s_321_0
        fn_state.gs_45018 = s_321_0;
        // N s_321_2: jump b322
        return block_322(state, tracer, fn_state);
    }
    fn block_322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_322_0: read-var gs#45018:u8
        let s_322_0: bool = fn_state.gs_45018;
        // N s_322_1: branch s_322_0 b490 b323
        if s_322_0 {
            return block_490(state, tracer, fn_state);
        } else {
            return block_323(state, tracer, fn_state);
        };
    }
    fn block_323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_323_0: jump b324
        return block_324(state, tracer, fn_state);
    }
    fn block_324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_324_0: const #219u : u32
        let s_324_0: u32 = 219;
        // S s_324_1: call IsFeatureImplemented(s_324_0)
        let s_324_1: bool = IsFeatureImplemented(state, tracer, s_324_0);
        // S s_324_2: not s_324_1
        let s_324_2: bool = !s_324_1;
        // N s_324_3: branch s_324_2 b489 b325
        if s_324_2 {
            return block_489(state, tracer, fn_state);
        } else {
            return block_325(state, tracer, fn_state);
        };
    }
    fn block_325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_325_0: jump b326
        return block_326(state, tracer, fn_state);
    }
    fn block_326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_326_0: const #101232u : u32
        let s_326_0: u32 = 101232;
        // D s_326_1: read-reg s_326_0:struct
        let s_326_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_0 as isize);
            tracer.read_register(s_326_0 as isize, value);
            value
        };
        // C s_326_2: const #101232u : u32
        let s_326_2: u32 = 101232;
        // N s_326_3: write-reg s_326_2 <= s_326_1
        let s_326_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_2 as isize, s_326_1);
            tracer.write_register(s_326_2 as isize, s_326_1);
        };
        // C s_326_4: const #17680u : u32
        let s_326_4: u32 = 17680;
        // D s_326_5: read-reg s_326_4:struct
        let s_326_5: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_4 as isize);
            tracer.read_register(s_326_4 as isize, value);
            value
        };
        // C s_326_6: const #17680u : u32
        let s_326_6: u32 = 17680;
        // N s_326_7: write-reg s_326_6 <= s_326_5
        let s_326_7: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_6 as isize, s_326_5);
            tracer.write_register(s_326_6 as isize, s_326_5);
        };
        // C s_326_8: const #19376u : u32
        let s_326_8: u32 = 19376;
        // D s_326_9: read-reg s_326_8:struct
        let s_326_9: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_8 as isize);
            tracer.read_register(s_326_8 as isize, value);
            value
        };
        // C s_326_10: const #19376u : u32
        let s_326_10: u32 = 19376;
        // N s_326_11: write-reg s_326_10 <= s_326_9
        let s_326_11: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_10 as isize, s_326_9);
            tracer.write_register(s_326_10 as isize, s_326_9);
        };
        // C s_326_12: const #19376u : u32
        let s_326_12: u32 = 19376;
        // D s_326_13: read-reg s_326_12:struct
        let s_326_13: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_12 as isize);
            tracer.read_register(s_326_12 as isize, value);
            value
        };
        // C s_326_14: const #19376u : u32
        let s_326_14: u32 = 19376;
        // N s_326_15: write-reg s_326_14 <= s_326_13
        let s_326_15: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_14 as isize, s_326_13);
            tracer.write_register(s_326_14 as isize, s_326_13);
        };
        // C s_326_16: const #19376u : u32
        let s_326_16: u32 = 19376;
        // D s_326_17: read-reg s_326_16:struct
        let s_326_17: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_16 as isize);
            tracer.read_register(s_326_16 as isize, value);
            value
        };
        // C s_326_18: const #19376u : u32
        let s_326_18: u32 = 19376;
        // N s_326_19: write-reg s_326_18 <= s_326_17
        let s_326_19: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_18 as isize, s_326_17);
            tracer.write_register(s_326_18 as isize, s_326_17);
        };
        // C s_326_20: const #0u : u8
        let s_326_20: bool = false;
        // S s_326_21: call Bit(s_326_20)
        let s_326_21: bool = Bit(state, tracer, s_326_20);
        // C s_326_22: const #19376u : u32
        let s_326_22: u32 = 19376;
        // D s_326_23: read-reg s_326_22:struct
        let s_326_23: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_22 as isize);
            tracer.read_register(s_326_22 as isize, value);
            value
        };
        // C s_326_24: const #19376u : u32
        let s_326_24: u32 = 19376;
        // N s_326_25: write-reg s_326_24 <= s_326_23
        let s_326_25: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_24 as isize, s_326_23);
            tracer.write_register(s_326_24 as isize, s_326_23);
        };
        // C s_326_26: const #16808u : u32
        let s_326_26: u32 = 16808;
        // D s_326_27: read-reg s_326_26:struct
        let s_326_27: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_26 as isize);
            tracer.read_register(s_326_26 as isize, value);
            value
        };
        // C s_326_28: const #16808u : u32
        let s_326_28: u32 = 16808;
        // N s_326_29: write-reg s_326_28 <= s_326_27
        let s_326_29: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_28 as isize, s_326_27);
            tracer.write_register(s_326_28 as isize, s_326_27);
        };
        // C s_326_30: const #17560u : u32
        let s_326_30: u32 = 17560;
        // D s_326_31: read-reg s_326_30:struct
        let s_326_31: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_30 as isize);
            tracer.read_register(s_326_30 as isize, value);
            value
        };
        // C s_326_32: const #17560u : u32
        let s_326_32: u32 = 17560;
        // N s_326_33: write-reg s_326_32 <= s_326_31
        let s_326_33: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_32 as isize, s_326_31);
            tracer.write_register(s_326_32 as isize, s_326_31);
        };
        // C s_326_34: const #11920u : u32
        let s_326_34: u32 = 11920;
        // D s_326_35: read-reg s_326_34:struct
        let s_326_35: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_34 as isize);
            tracer.read_register(s_326_34 as isize, value);
            value
        };
        // C s_326_36: const #11920u : u32
        let s_326_36: u32 = 11920;
        // N s_326_37: write-reg s_326_36 <= s_326_35
        let s_326_37: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_36 as isize, s_326_35);
            tracer.write_register(s_326_36 as isize, s_326_35);
        };
        // C s_326_38: const #11920u : u32
        let s_326_38: u32 = 11920;
        // D s_326_39: read-reg s_326_38:struct
        let s_326_39: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_38 as isize);
            tracer.read_register(s_326_38 as isize, value);
            value
        };
        // C s_326_40: const #11920u : u32
        let s_326_40: u32 = 11920;
        // N s_326_41: write-reg s_326_40 <= s_326_39
        let s_326_41: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_40 as isize, s_326_39);
            tracer.write_register(s_326_40 as isize, s_326_39);
        };
        // C s_326_42: const #11920u : u32
        let s_326_42: u32 = 11920;
        // D s_326_43: read-reg s_326_42:struct
        let s_326_43: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_42 as isize);
            tracer.read_register(s_326_42 as isize, value);
            value
        };
        // C s_326_44: const #11920u : u32
        let s_326_44: u32 = 11920;
        // N s_326_45: write-reg s_326_44 <= s_326_43
        let s_326_45: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_44 as isize, s_326_43);
            tracer.write_register(s_326_44 as isize, s_326_43);
        };
        // C s_326_46: const #17728u : u32
        let s_326_46: u32 = 17728;
        // D s_326_47: read-reg s_326_46:struct
        let s_326_47: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_46 as isize);
            tracer.read_register(s_326_46 as isize, value);
            value
        };
        // C s_326_48: const #17728u : u32
        let s_326_48: u32 = 17728;
        // N s_326_49: write-reg s_326_48 <= s_326_47
        let s_326_49: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_48 as isize, s_326_47);
            tracer.write_register(s_326_48 as isize, s_326_47);
        };
        // C s_326_50: const #17728u : u32
        let s_326_50: u32 = 17728;
        // D s_326_51: read-reg s_326_50:struct
        let s_326_51: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_50 as isize);
            tracer.read_register(s_326_50 as isize, value);
            value
        };
        // C s_326_52: const #17728u : u32
        let s_326_52: u32 = 17728;
        // N s_326_53: write-reg s_326_52 <= s_326_51
        let s_326_53: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_52 as isize, s_326_51);
            tracer.write_register(s_326_52 as isize, s_326_51);
        };
        // C s_326_54: const #17728u : u32
        let s_326_54: u32 = 17728;
        // D s_326_55: read-reg s_326_54:struct
        let s_326_55: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_54 as isize);
            tracer.read_register(s_326_54 as isize, value);
            value
        };
        // C s_326_56: const #17728u : u32
        let s_326_56: u32 = 17728;
        // N s_326_57: write-reg s_326_56 <= s_326_55
        let s_326_57: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_56 as isize, s_326_55);
            tracer.write_register(s_326_56 as isize, s_326_55);
        };
        // C s_326_58: const #16200u : u32
        let s_326_58: u32 = 16200;
        // D s_326_59: read-reg s_326_58:struct
        let s_326_59: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_58 as isize);
            tracer.read_register(s_326_58 as isize, value);
            value
        };
        // C s_326_60: const #16200u : u32
        let s_326_60: u32 = 16200;
        // N s_326_61: write-reg s_326_60 <= s_326_59
        let s_326_61: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_60 as isize, s_326_59);
            tracer.write_register(s_326_60 as isize, s_326_59);
        };
        // C s_326_62: const #19048u : u32
        let s_326_62: u32 = 19048;
        // D s_326_63: read-reg s_326_62:struct
        let s_326_63: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_62 as isize);
            tracer.read_register(s_326_62 as isize, value);
            value
        };
        // C s_326_64: const #19048u : u32
        let s_326_64: u32 = 19048;
        // N s_326_65: write-reg s_326_64 <= s_326_63
        let s_326_65: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_64 as isize, s_326_63);
            tracer.write_register(s_326_64 as isize, s_326_63);
        };
        // C s_326_66: const #23392u : u32
        let s_326_66: u32 = 23392;
        // D s_326_67: read-reg s_326_66:struct
        let s_326_67: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_66 as isize);
            tracer.read_register(s_326_66 as isize, value);
            value
        };
        // C s_326_68: const #23392u : u32
        let s_326_68: u32 = 23392;
        // N s_326_69: write-reg s_326_68 <= s_326_67
        let s_326_69: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_68 as isize, s_326_67);
            tracer.write_register(s_326_68 as isize, s_326_67);
        };
        // C s_326_70: const #21000u : u32
        let s_326_70: u32 = 21000;
        // D s_326_71: read-reg s_326_70:struct
        let s_326_71: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_70 as isize);
            tracer.read_register(s_326_70 as isize, value);
            value
        };
        // C s_326_72: const #21000u : u32
        let s_326_72: u32 = 21000;
        // N s_326_73: write-reg s_326_72 <= s_326_71
        let s_326_73: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_72 as isize, s_326_71);
            tracer.write_register(s_326_72 as isize, s_326_71);
        };
        // C s_326_74: const #0s : i
        let s_326_74: i128 = 0;
        // C s_326_75: const #104600u : u32
        let s_326_75: u32 = 104600;
        // D s_326_76: read-reg s_326_75:u32
        let s_326_76: u32 = {
            let value = state.read_register::<u32>(s_326_75 as isize);
            tracer.read_register(s_326_75 as isize, value);
            value
        };
        // D s_326_77: cast zx s_326_76 -> bv
        let s_326_77: Bits = Bits::new(s_326_76 as u128, 32u16);
        // C s_326_78: const #0u : u32
        let s_326_78: u32 = 0;
        // C s_326_79: cast zx s_326_78 -> bv
        let s_326_79: Bits = Bits::new(s_326_78 as u128, 32u16);
        // C s_326_80: const #31s : i
        let s_326_80: i128 = 31;
        // C s_326_81: const #1u : u64
        let s_326_81: u64 = 1;
        // C s_326_82: cast zx s_326_81 -> bv
        let s_326_82: Bits = Bits::new(s_326_81 as u128, 64u16);
        // C s_326_83: lsl s_326_82 s_326_80
        let s_326_83: Bits = s_326_82 << s_326_80;
        // C s_326_84: sub s_326_83 s_326_82
        let s_326_84: Bits = ((s_326_83) - (s_326_82));
        // C s_326_85: and s_326_79 s_326_84
        let s_326_85: Bits = ((s_326_79) & (s_326_84));
        // C s_326_86: lsl s_326_85 s_326_74
        let s_326_86: Bits = s_326_85 << s_326_74;
        // C s_326_87: lsl s_326_84 s_326_74
        let s_326_87: Bits = s_326_84 << s_326_74;
        // C s_326_88: cmpl s_326_87
        let s_326_88: Bits = !s_326_87;
        // D s_326_89: and s_326_77 s_326_88
        let s_326_89: Bits = ((s_326_77) & (s_326_88));
        // D s_326_90: or s_326_89 s_326_86
        let s_326_90: Bits = ((s_326_89) | (s_326_86));
        // D s_326_91: cast reint s_326_90 -> u32
        let s_326_91: u32 = (s_326_90.value() as u32);
        // C s_326_92: const #104600u : u32
        let s_326_92: u32 = 104600;
        // N s_326_93: write-reg s_326_92 <= s_326_91
        let s_326_93: () = {
            state.write_register::<u32>(s_326_92 as isize, s_326_91);
            tracer.write_register(s_326_92 as isize, s_326_91);
        };
        // C s_326_94: const #101760u : u32
        let s_326_94: u32 = 101760;
        // D s_326_95: read-reg s_326_94:struct
        let s_326_95: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_94 as isize);
            tracer.read_register(s_326_94 as isize, value);
            value
        };
        // C s_326_96: const #101760u : u32
        let s_326_96: u32 = 101760;
        // N s_326_97: write-reg s_326_96 <= s_326_95
        let s_326_97: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_96 as isize, s_326_95);
            tracer.write_register(s_326_96 as isize, s_326_95);
        };
        // C s_326_98: const #20936u : u32
        let s_326_98: u32 = 20936;
        // D s_326_99: read-reg s_326_98:struct
        let s_326_99: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_98 as isize);
            tracer.read_register(s_326_98 as isize, value);
            value
        };
        // C s_326_100: const #20936u : u32
        let s_326_100: u32 = 20936;
        // N s_326_101: write-reg s_326_100 <= s_326_99
        let s_326_101: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_100 as isize, s_326_99);
            tracer.write_register(s_326_100 as isize, s_326_99);
        };
        // C s_326_102: const #23944u : u32
        let s_326_102: u32 = 23944;
        // D s_326_103: read-reg s_326_102:struct
        let s_326_103: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_326_102 as isize);
            tracer.read_register(s_326_102 as isize, value);
            value
        };
        // C s_326_104: const #23944u : u32
        let s_326_104: u32 = 23944;
        // N s_326_105: write-reg s_326_104 <= s_326_103
        let s_326_105: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_326_104 as isize, s_326_103);
            tracer.write_register(s_326_104 as isize, s_326_103);
        };
        // C s_326_106: const #() : ()
        let s_326_106: () = ();
        // S s_326_107: call EDSCR2_read(s_326_106)
        let s_326_107: ProductType700c18a878c5601b = EDSCR2_read(
            state,
            tracer,
            s_326_106,
        );
        // D s_326_108: write-var ga#36931 <= s_326_107
        fn_state.ga_36931 = s_326_107;
        // D s_326_109: read-var ga#36931.0:struct
        let s_326_109: u32 = fn_state.ga_36931._0;
        // C s_326_110: const #28s : i
        let s_326_110: i128 = 28;
        // C s_326_111: const #4s : i
        let s_326_111: i128 = 4;
        // D s_326_112: cast zx s_326_109 -> bv
        let s_326_112: Bits = Bits::new(s_326_109 as u128, 32u16);
        // C s_326_113: const #0u : u28
        let s_326_113: u32 = 0;
        // C s_326_114: cast zx s_326_113 -> bv
        let s_326_114: Bits = Bits::new(s_326_113 as u128, 28u16);
        // C s_326_115: const #1u : u64
        let s_326_115: u64 = 1;
        // C s_326_116: cast zx s_326_115 -> bv
        let s_326_116: Bits = Bits::new(s_326_115 as u128, 64u16);
        // C s_326_117: lsl s_326_116 s_326_110
        let s_326_117: Bits = s_326_116 << s_326_110;
        // C s_326_118: sub s_326_117 s_326_116
        let s_326_118: Bits = ((s_326_117) - (s_326_116));
        // C s_326_119: and s_326_114 s_326_118
        let s_326_119: Bits = ((s_326_114) & (s_326_118));
        // C s_326_120: lsl s_326_119 s_326_111
        let s_326_120: Bits = s_326_119 << s_326_111;
        // C s_326_121: lsl s_326_118 s_326_111
        let s_326_121: Bits = s_326_118 << s_326_111;
        // C s_326_122: cmpl s_326_121
        let s_326_122: Bits = !s_326_121;
        // D s_326_123: and s_326_112 s_326_122
        let s_326_123: Bits = ((s_326_112) & (s_326_122));
        // D s_326_124: or s_326_123 s_326_120
        let s_326_124: Bits = ((s_326_123) | (s_326_120));
        // D s_326_125: cast reint s_326_124 -> u32
        let s_326_125: u32 = (s_326_124.value() as u32);
        // D s_326_126: call Mk_EDSCR2_Type(s_326_125)
        let s_326_126: ProductType700c18a878c5601b = Mk_EDSCR2_Type(
            state,
            tracer,
            s_326_125,
        );
        // D s_326_127: call EDSCR2_write(s_326_126)
        let s_326_127: () = EDSCR2_write(state, tracer, s_326_126);
        // D s_326_128: read-var cold:u8
        let s_326_128: bool = fn_state.cold;
        // N s_326_129: branch s_326_128 b488 b327
        if s_326_128 {
            return block_488(state, tracer, fn_state);
        } else {
            return block_327(state, tracer, fn_state);
        };
    }
    fn block_327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_327_0: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_328_0: const #() : ()
        let s_328_0: () = ();
        // S s_328_1: call EDSCR2_read(s_328_0)
        let s_328_1: ProductType700c18a878c5601b = EDSCR2_read(state, tracer, s_328_0);
        // D s_328_2: write-var ga#36937 <= s_328_1
        fn_state.ga_36937 = s_328_1;
        // D s_328_3: read-var ga#36937.0:struct
        let s_328_3: u32 = fn_state.ga_36937._0;
        // C s_328_4: const #3s : i
        let s_328_4: i128 = 3;
        // C s_328_5: const #0s : i
        let s_328_5: i128 = 0;
        // D s_328_6: cast zx s_328_3 -> bv
        let s_328_6: Bits = Bits::new(s_328_3 as u128, 32u16);
        // C s_328_7: const #0u : u8
        let s_328_7: u8 = 0;
        // C s_328_8: cast zx s_328_7 -> bv
        let s_328_8: Bits = Bits::new(s_328_7 as u128, 3u16);
        // C s_328_9: const #1u : u64
        let s_328_9: u64 = 1;
        // C s_328_10: cast zx s_328_9 -> bv
        let s_328_10: Bits = Bits::new(s_328_9 as u128, 64u16);
        // C s_328_11: lsl s_328_10 s_328_4
        let s_328_11: Bits = s_328_10 << s_328_4;
        // C s_328_12: sub s_328_11 s_328_10
        let s_328_12: Bits = ((s_328_11) - (s_328_10));
        // C s_328_13: and s_328_8 s_328_12
        let s_328_13: Bits = ((s_328_8) & (s_328_12));
        // C s_328_14: lsl s_328_13 s_328_5
        let s_328_14: Bits = s_328_13 << s_328_5;
        // C s_328_15: lsl s_328_12 s_328_5
        let s_328_15: Bits = s_328_12 << s_328_5;
        // C s_328_16: cmpl s_328_15
        let s_328_16: Bits = !s_328_15;
        // D s_328_17: and s_328_6 s_328_16
        let s_328_17: Bits = ((s_328_6) & (s_328_16));
        // D s_328_18: or s_328_17 s_328_14
        let s_328_18: Bits = ((s_328_17) | (s_328_14));
        // D s_328_19: cast reint s_328_18 -> u32
        let s_328_19: u32 = (s_328_18.value() as u32);
        // D s_328_20: call Mk_EDSCR2_Type(s_328_19)
        let s_328_20: ProductType700c18a878c5601b = Mk_EDSCR2_Type(
            state,
            tracer,
            s_328_19,
        );
        // D s_328_21: call EDSCR2_write(s_328_20)
        let s_328_21: () = EDSCR2_write(state, tracer, s_328_20);
        // C s_328_22: const #10728u : u32
        let s_328_22: u32 = 10728;
        // D s_328_23: read-reg s_328_22:struct
        let s_328_23: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_22 as isize);
            tracer.read_register(s_328_22 as isize, value);
            value
        };
        // C s_328_24: const #10728u : u32
        let s_328_24: u32 = 10728;
        // N s_328_25: write-reg s_328_24 <= s_328_23
        let s_328_25: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_24 as isize, s_328_23);
            tracer.write_register(s_328_24 as isize, s_328_23);
        };
        // C s_328_26: const #11832u : u32
        let s_328_26: u32 = 11832;
        // D s_328_27: read-reg s_328_26:struct
        let s_328_27: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_26 as isize);
            tracer.read_register(s_328_26 as isize, value);
            value
        };
        // C s_328_28: const #11832u : u32
        let s_328_28: u32 = 11832;
        // N s_328_29: write-reg s_328_28 <= s_328_27
        let s_328_29: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_28 as isize, s_328_27);
            tracer.write_register(s_328_28 as isize, s_328_27);
        };
        // C s_328_30: const #13752u : u32
        let s_328_30: u32 = 13752;
        // D s_328_31: read-reg s_328_30:struct
        let s_328_31: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_30 as isize);
            tracer.read_register(s_328_30 as isize, value);
            value
        };
        // C s_328_32: const #13752u : u32
        let s_328_32: u32 = 13752;
        // N s_328_33: write-reg s_328_32 <= s_328_31
        let s_328_33: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_32 as isize, s_328_31);
            tracer.write_register(s_328_32 as isize, s_328_31);
        };
        // C s_328_34: const #13752u : u32
        let s_328_34: u32 = 13752;
        // D s_328_35: read-reg s_328_34:struct
        let s_328_35: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_34 as isize);
            tracer.read_register(s_328_34 as isize, value);
            value
        };
        // C s_328_36: const #13752u : u32
        let s_328_36: u32 = 13752;
        // N s_328_37: write-reg s_328_36 <= s_328_35
        let s_328_37: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_36 as isize, s_328_35);
            tracer.write_register(s_328_36 as isize, s_328_35);
        };
        // C s_328_38: const #13752u : u32
        let s_328_38: u32 = 13752;
        // D s_328_39: read-reg s_328_38:struct
        let s_328_39: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_38 as isize);
            tracer.read_register(s_328_38 as isize, value);
            value
        };
        // C s_328_40: const #13752u : u32
        let s_328_40: u32 = 13752;
        // N s_328_41: write-reg s_328_40 <= s_328_39
        let s_328_41: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_40 as isize, s_328_39);
            tracer.write_register(s_328_40 as isize, s_328_39);
        };
        // C s_328_42: const #17592u : u32
        let s_328_42: u32 = 17592;
        // D s_328_43: read-reg s_328_42:struct
        let s_328_43: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_42 as isize);
            tracer.read_register(s_328_42 as isize, value);
            value
        };
        // C s_328_44: const #17592u : u32
        let s_328_44: u32 = 17592;
        // N s_328_45: write-reg s_328_44 <= s_328_43
        let s_328_45: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_44 as isize, s_328_43);
            tracer.write_register(s_328_44 as isize, s_328_43);
        };
        // C s_328_46: const #12056u : u32
        let s_328_46: u32 = 12056;
        // D s_328_47: read-reg s_328_46:struct
        let s_328_47: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_46 as isize);
            tracer.read_register(s_328_46 as isize, value);
            value
        };
        // C s_328_48: const #12056u : u32
        let s_328_48: u32 = 12056;
        // N s_328_49: write-reg s_328_48 <= s_328_47
        let s_328_49: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_48 as isize, s_328_47);
            tracer.write_register(s_328_48 as isize, s_328_47);
        };
        // C s_328_50: const #12056u : u32
        let s_328_50: u32 = 12056;
        // D s_328_51: read-reg s_328_50:struct
        let s_328_51: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_50 as isize);
            tracer.read_register(s_328_50 as isize, value);
            value
        };
        // C s_328_52: const #12056u : u32
        let s_328_52: u32 = 12056;
        // N s_328_53: write-reg s_328_52 <= s_328_51
        let s_328_53: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_52 as isize, s_328_51);
            tracer.write_register(s_328_52 as isize, s_328_51);
        };
        // C s_328_54: const #1448u : u32
        let s_328_54: u32 = 1448;
        // D s_328_55: read-reg s_328_54:struct
        let s_328_55: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_54 as isize);
            tracer.read_register(s_328_54 as isize, value);
            value
        };
        // C s_328_56: const #1448u : u32
        let s_328_56: u32 = 1448;
        // N s_328_57: write-reg s_328_56 <= s_328_55
        let s_328_57: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_56 as isize, s_328_55);
            tracer.write_register(s_328_56 as isize, s_328_55);
        };
        // C s_328_58: const #22376u : u32
        let s_328_58: u32 = 22376;
        // D s_328_59: read-reg s_328_58:struct
        let s_328_59: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_58 as isize);
            tracer.read_register(s_328_58 as isize, value);
            value
        };
        // C s_328_60: const #22376u : u32
        let s_328_60: u32 = 22376;
        // N s_328_61: write-reg s_328_60 <= s_328_59
        let s_328_61: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_60 as isize, s_328_59);
            tracer.write_register(s_328_60 as isize, s_328_59);
        };
        // C s_328_62: const #22376u : u32
        let s_328_62: u32 = 22376;
        // D s_328_63: read-reg s_328_62:struct
        let s_328_63: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_62 as isize);
            tracer.read_register(s_328_62 as isize, value);
            value
        };
        // C s_328_64: const #22376u : u32
        let s_328_64: u32 = 22376;
        // N s_328_65: write-reg s_328_64 <= s_328_63
        let s_328_65: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_64 as isize, s_328_63);
            tracer.write_register(s_328_64 as isize, s_328_63);
        };
        // C s_328_66: const #22376u : u32
        let s_328_66: u32 = 22376;
        // D s_328_67: read-reg s_328_66:struct
        let s_328_67: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_66 as isize);
            tracer.read_register(s_328_66 as isize, value);
            value
        };
        // C s_328_68: const #22376u : u32
        let s_328_68: u32 = 22376;
        // N s_328_69: write-reg s_328_68 <= s_328_67
        let s_328_69: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_68 as isize, s_328_67);
            tracer.write_register(s_328_68 as isize, s_328_67);
        };
        // C s_328_70: const #22376u : u32
        let s_328_70: u32 = 22376;
        // D s_328_71: read-reg s_328_70:struct
        let s_328_71: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_70 as isize);
            tracer.read_register(s_328_70 as isize, value);
            value
        };
        // C s_328_72: const #22376u : u32
        let s_328_72: u32 = 22376;
        // N s_328_73: write-reg s_328_72 <= s_328_71
        let s_328_73: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_72 as isize, s_328_71);
            tracer.write_register(s_328_72 as isize, s_328_71);
        };
        // C s_328_74: const #22376u : u32
        let s_328_74: u32 = 22376;
        // D s_328_75: read-reg s_328_74:struct
        let s_328_75: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_74 as isize);
            tracer.read_register(s_328_74 as isize, value);
            value
        };
        // C s_328_76: const #22376u : u32
        let s_328_76: u32 = 22376;
        // N s_328_77: write-reg s_328_76 <= s_328_75
        let s_328_77: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_76 as isize, s_328_75);
            tracer.write_register(s_328_76 as isize, s_328_75);
        };
        // C s_328_78: const #22376u : u32
        let s_328_78: u32 = 22376;
        // D s_328_79: read-reg s_328_78:struct
        let s_328_79: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_78 as isize);
            tracer.read_register(s_328_78 as isize, value);
            value
        };
        // C s_328_80: const #22376u : u32
        let s_328_80: u32 = 22376;
        // N s_328_81: write-reg s_328_80 <= s_328_79
        let s_328_81: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_80 as isize, s_328_79);
            tracer.write_register(s_328_80 as isize, s_328_79);
        };
        // C s_328_82: const #22376u : u32
        let s_328_82: u32 = 22376;
        // D s_328_83: read-reg s_328_82:struct
        let s_328_83: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_82 as isize);
            tracer.read_register(s_328_82 as isize, value);
            value
        };
        // C s_328_84: const #22376u : u32
        let s_328_84: u32 = 22376;
        // N s_328_85: write-reg s_328_84 <= s_328_83
        let s_328_85: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_84 as isize, s_328_83);
            tracer.write_register(s_328_84 as isize, s_328_83);
        };
        // C s_328_86: const #22376u : u32
        let s_328_86: u32 = 22376;
        // D s_328_87: read-reg s_328_86:struct
        let s_328_87: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_86 as isize);
            tracer.read_register(s_328_86 as isize, value);
            value
        };
        // C s_328_88: const #22376u : u32
        let s_328_88: u32 = 22376;
        // N s_328_89: write-reg s_328_88 <= s_328_87
        let s_328_89: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_88 as isize, s_328_87);
            tracer.write_register(s_328_88 as isize, s_328_87);
        };
        // C s_328_90: const #22376u : u32
        let s_328_90: u32 = 22376;
        // D s_328_91: read-reg s_328_90:struct
        let s_328_91: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_90 as isize);
            tracer.read_register(s_328_90 as isize, value);
            value
        };
        // C s_328_92: const #22376u : u32
        let s_328_92: u32 = 22376;
        // N s_328_93: write-reg s_328_92 <= s_328_91
        let s_328_93: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_92 as isize, s_328_91);
            tracer.write_register(s_328_92 as isize, s_328_91);
        };
        // C s_328_94: const #22376u : u32
        let s_328_94: u32 = 22376;
        // D s_328_95: read-reg s_328_94:struct
        let s_328_95: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_94 as isize);
            tracer.read_register(s_328_94 as isize, value);
            value
        };
        // C s_328_96: const #22376u : u32
        let s_328_96: u32 = 22376;
        // N s_328_97: write-reg s_328_96 <= s_328_95
        let s_328_97: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_96 as isize, s_328_95);
            tracer.write_register(s_328_96 as isize, s_328_95);
        };
        // C s_328_98: const #22376u : u32
        let s_328_98: u32 = 22376;
        // D s_328_99: read-reg s_328_98:struct
        let s_328_99: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_98 as isize);
            tracer.read_register(s_328_98 as isize, value);
            value
        };
        // C s_328_100: const #22376u : u32
        let s_328_100: u32 = 22376;
        // N s_328_101: write-reg s_328_100 <= s_328_99
        let s_328_101: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_100 as isize, s_328_99);
            tracer.write_register(s_328_100 as isize, s_328_99);
        };
        // C s_328_102: const #22376u : u32
        let s_328_102: u32 = 22376;
        // D s_328_103: read-reg s_328_102:struct
        let s_328_103: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_102 as isize);
            tracer.read_register(s_328_102 as isize, value);
            value
        };
        // C s_328_104: const #22376u : u32
        let s_328_104: u32 = 22376;
        // N s_328_105: write-reg s_328_104 <= s_328_103
        let s_328_105: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_104 as isize, s_328_103);
            tracer.write_register(s_328_104 as isize, s_328_103);
        };
        // C s_328_106: const #22376u : u32
        let s_328_106: u32 = 22376;
        // D s_328_107: read-reg s_328_106:struct
        let s_328_107: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_106 as isize);
            tracer.read_register(s_328_106 as isize, value);
            value
        };
        // C s_328_108: const #22376u : u32
        let s_328_108: u32 = 22376;
        // N s_328_109: write-reg s_328_108 <= s_328_107
        let s_328_109: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_108 as isize, s_328_107);
            tracer.write_register(s_328_108 as isize, s_328_107);
        };
        // C s_328_110: const #22376u : u32
        let s_328_110: u32 = 22376;
        // D s_328_111: read-reg s_328_110:struct
        let s_328_111: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_110 as isize);
            tracer.read_register(s_328_110 as isize, value);
            value
        };
        // C s_328_112: const #22376u : u32
        let s_328_112: u32 = 22376;
        // N s_328_113: write-reg s_328_112 <= s_328_111
        let s_328_113: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_112 as isize, s_328_111);
            tracer.write_register(s_328_112 as isize, s_328_111);
        };
        // C s_328_114: const #22376u : u32
        let s_328_114: u32 = 22376;
        // D s_328_115: read-reg s_328_114:struct
        let s_328_115: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_114 as isize);
            tracer.read_register(s_328_114 as isize, value);
            value
        };
        // C s_328_116: const #22376u : u32
        let s_328_116: u32 = 22376;
        // N s_328_117: write-reg s_328_116 <= s_328_115
        let s_328_117: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_116 as isize, s_328_115);
            tracer.write_register(s_328_116 as isize, s_328_115);
        };
        // C s_328_118: const #22376u : u32
        let s_328_118: u32 = 22376;
        // D s_328_119: read-reg s_328_118:struct
        let s_328_119: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_118 as isize);
            tracer.read_register(s_328_118 as isize, value);
            value
        };
        // C s_328_120: const #22376u : u32
        let s_328_120: u32 = 22376;
        // N s_328_121: write-reg s_328_120 <= s_328_119
        let s_328_121: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_120 as isize, s_328_119);
            tracer.write_register(s_328_120 as isize, s_328_119);
        };
        // C s_328_122: const #22376u : u32
        let s_328_122: u32 = 22376;
        // D s_328_123: read-reg s_328_122:struct
        let s_328_123: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_122 as isize);
            tracer.read_register(s_328_122 as isize, value);
            value
        };
        // C s_328_124: const #22376u : u32
        let s_328_124: u32 = 22376;
        // N s_328_125: write-reg s_328_124 <= s_328_123
        let s_328_125: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_124 as isize, s_328_123);
            tracer.write_register(s_328_124 as isize, s_328_123);
        };
        // C s_328_126: const #15024u : u32
        let s_328_126: u32 = 15024;
        // D s_328_127: read-reg s_328_126:struct
        let s_328_127: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_126 as isize);
            tracer.read_register(s_328_126 as isize, value);
            value
        };
        // C s_328_128: const #15024u : u32
        let s_328_128: u32 = 15024;
        // N s_328_129: write-reg s_328_128 <= s_328_127
        let s_328_129: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_128 as isize, s_328_127);
            tracer.write_register(s_328_128 as isize, s_328_127);
        };
        // C s_328_130: const #12720u : u32
        let s_328_130: u32 = 12720;
        // D s_328_131: read-reg s_328_130:struct
        let s_328_131: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_130 as isize);
            tracer.read_register(s_328_130 as isize, value);
            value
        };
        // C s_328_132: const #12720u : u32
        let s_328_132: u32 = 12720;
        // N s_328_133: write-reg s_328_132 <= s_328_131
        let s_328_133: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_132 as isize, s_328_131);
            tracer.write_register(s_328_132 as isize, s_328_131);
        };
        // C s_328_134: const #18288u : u32
        let s_328_134: u32 = 18288;
        // D s_328_135: read-reg s_328_134:struct
        let s_328_135: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_134 as isize);
            tracer.read_register(s_328_134 as isize, value);
            value
        };
        // C s_328_136: const #18288u : u32
        let s_328_136: u32 = 18288;
        // N s_328_137: write-reg s_328_136 <= s_328_135
        let s_328_137: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_136 as isize, s_328_135);
            tracer.write_register(s_328_136 as isize, s_328_135);
        };
        // C s_328_138: const #18288u : u32
        let s_328_138: u32 = 18288;
        // D s_328_139: read-reg s_328_138:struct
        let s_328_139: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_138 as isize);
            tracer.read_register(s_328_138 as isize, value);
            value
        };
        // C s_328_140: const #18288u : u32
        let s_328_140: u32 = 18288;
        // N s_328_141: write-reg s_328_140 <= s_328_139
        let s_328_141: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_140 as isize, s_328_139);
            tracer.write_register(s_328_140 as isize, s_328_139);
        };
        // C s_328_142: const #18288u : u32
        let s_328_142: u32 = 18288;
        // D s_328_143: read-reg s_328_142:struct
        let s_328_143: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_142 as isize);
            tracer.read_register(s_328_142 as isize, value);
            value
        };
        // C s_328_144: const #18288u : u32
        let s_328_144: u32 = 18288;
        // N s_328_145: write-reg s_328_144 <= s_328_143
        let s_328_145: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_144 as isize, s_328_143);
            tracer.write_register(s_328_144 as isize, s_328_143);
        };
        // C s_328_146: const #18288u : u32
        let s_328_146: u32 = 18288;
        // D s_328_147: read-reg s_328_146:struct
        let s_328_147: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_146 as isize);
            tracer.read_register(s_328_146 as isize, value);
            value
        };
        // C s_328_148: const #18288u : u32
        let s_328_148: u32 = 18288;
        // N s_328_149: write-reg s_328_148 <= s_328_147
        let s_328_149: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_148 as isize, s_328_147);
            tracer.write_register(s_328_148 as isize, s_328_147);
        };
        // C s_328_150: const #14712u : u32
        let s_328_150: u32 = 14712;
        // D s_328_151: read-reg s_328_150:struct
        let s_328_151: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_150 as isize);
            tracer.read_register(s_328_150 as isize, value);
            value
        };
        // C s_328_152: const #14712u : u32
        let s_328_152: u32 = 14712;
        // N s_328_153: write-reg s_328_152 <= s_328_151
        let s_328_153: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_152 as isize, s_328_151);
            tracer.write_register(s_328_152 as isize, s_328_151);
        };
        // C s_328_154: const #14712u : u32
        let s_328_154: u32 = 14712;
        // D s_328_155: read-reg s_328_154:struct
        let s_328_155: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_328_154 as isize);
            tracer.read_register(s_328_154 as isize, value);
            value
        };
        // C s_328_156: const #14712u : u32
        let s_328_156: u32 = 14712;
        // N s_328_157: write-reg s_328_156 <= s_328_155
        let s_328_157: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_328_156 as isize, s_328_155);
            tracer.write_register(s_328_156 as isize, s_328_155);
        };
        // D s_328_158: read-var cold:u8
        let s_328_158: bool = fn_state.cold;
        // N s_328_159: branch s_328_158 b487 b329
        if s_328_158 {
            return block_487(state, tracer, fn_state);
        } else {
            return block_329(state, tracer, fn_state);
        };
    }
    fn block_329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_329_0: jump b330
        return block_330(state, tracer, fn_state);
    }
    fn block_330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_330_0: const #14712u : u32
        let s_330_0: u32 = 14712;
        // D s_330_1: read-reg s_330_0:struct
        let s_330_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_330_0 as isize);
            tracer.read_register(s_330_0 as isize, value);
            value
        };
        // C s_330_2: const #14712u : u32
        let s_330_2: u32 = 14712;
        // N s_330_3: write-reg s_330_2 <= s_330_1
        let s_330_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_330_2 as isize, s_330_1);
            tracer.write_register(s_330_2 as isize, s_330_1);
        };
        // C s_330_4: const #11512u : u32
        let s_330_4: u32 = 11512;
        // D s_330_5: read-reg s_330_4:struct
        let s_330_5: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_330_4 as isize);
            tracer.read_register(s_330_4 as isize, value);
            value
        };
        // C s_330_6: const #11512u : u32
        let s_330_6: u32 = 11512;
        // N s_330_7: write-reg s_330_6 <= s_330_5
        let s_330_7: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_330_6 as isize, s_330_5);
            tracer.write_register(s_330_6 as isize, s_330_5);
        };
        // C s_330_8: const #20312u : u32
        let s_330_8: u32 = 20312;
        // D s_330_9: read-reg s_330_8:struct
        let s_330_9: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_330_8 as isize);
            tracer.read_register(s_330_8 as isize, value);
            value
        };
        // C s_330_10: const #20312u : u32
        let s_330_10: u32 = 20312;
        // N s_330_11: write-reg s_330_10 <= s_330_9
        let s_330_11: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_330_10 as isize, s_330_9);
            tracer.write_register(s_330_10 as isize, s_330_9);
        };
        // C s_330_12: const #20176u : u32
        let s_330_12: u32 = 20176;
        // D s_330_13: read-reg s_330_12:struct
        let s_330_13: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_330_12 as isize);
            tracer.read_register(s_330_12 as isize, value);
            value
        };
        // C s_330_14: const #20176u : u32
        let s_330_14: u32 = 20176;
        // N s_330_15: write-reg s_330_14 <= s_330_13
        let s_330_15: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_330_14 as isize, s_330_13);
            tracer.write_register(s_330_14 as isize, s_330_13);
        };
        // D s_330_16: read-var cold:u8
        let s_330_16: bool = fn_state.cold;
        // N s_330_17: branch s_330_16 b486 b331
        if s_330_16 {
            return block_486(state, tracer, fn_state);
        } else {
            return block_331(state, tracer, fn_state);
        };
    }
    fn block_331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_331_0: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_332_0: const #0u : u8
        let s_332_0: bool = false;
        // S s_332_1: call Bit(s_332_0)
        let s_332_1: bool = Bit(state, tracer, s_332_0);
        // C s_332_2: const #20176u : u32
        let s_332_2: u32 = 20176;
        // D s_332_3: read-reg s_332_2:struct
        let s_332_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_332_2 as isize);
            tracer.read_register(s_332_2 as isize, value);
            value
        };
        // C s_332_4: const #20176u : u32
        let s_332_4: u32 = 20176;
        // N s_332_5: write-reg s_332_4 <= s_332_3
        let s_332_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_332_4 as isize, s_332_3);
            tracer.write_register(s_332_4 as isize, s_332_3);
        };
        // D s_332_6: read-var cold:u8
        let s_332_6: bool = fn_state.cold;
        // N s_332_7: branch s_332_6 b485 b333
        if s_332_6 {
            return block_485(state, tracer, fn_state);
        } else {
            return block_333(state, tracer, fn_state);
        };
    }
    fn block_333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_333_0: const #0u : u8
        let s_333_0: bool = false;
        // D s_333_1: write-var gs#45205 <= s_333_0
        fn_state.gs_45205 = s_333_0;
        // N s_333_2: jump b334
        return block_334(state, tracer, fn_state);
    }
    fn block_334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_334_0: read-var gs#45205:u8
        let s_334_0: bool = fn_state.gs_45205;
        // N s_334_1: branch s_334_0 b484 b335
        if s_334_0 {
            return block_484(state, tracer, fn_state);
        } else {
            return block_335(state, tracer, fn_state);
        };
    }
    fn block_335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_335_0: jump b336
        return block_336(state, tracer, fn_state);
    }
    fn block_336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_336_0: const #219u : u32
        let s_336_0: u32 = 219;
        // S s_336_1: call IsFeatureImplemented(s_336_0)
        let s_336_1: bool = IsFeatureImplemented(state, tracer, s_336_0);
        // S s_336_2: not s_336_1
        let s_336_2: bool = !s_336_1;
        // N s_336_3: branch s_336_2 b483 b337
        if s_336_2 {
            return block_483(state, tracer, fn_state);
        } else {
            return block_337(state, tracer, fn_state);
        };
    }
    fn block_337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_337_0: jump b338
        return block_338(state, tracer, fn_state);
    }
    fn block_338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_338_0: const #20176u : u32
        let s_338_0: u32 = 20176;
        // D s_338_1: read-reg s_338_0:struct
        let s_338_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_338_0 as isize);
            tracer.read_register(s_338_0 as isize, value);
            value
        };
        // C s_338_2: const #20176u : u32
        let s_338_2: u32 = 20176;
        // N s_338_3: write-reg s_338_2 <= s_338_1
        let s_338_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_338_2 as isize, s_338_1);
            tracer.write_register(s_338_2 as isize, s_338_1);
        };
        // C s_338_4: const #20176u : u32
        let s_338_4: u32 = 20176;
        // D s_338_5: read-reg s_338_4:struct
        let s_338_5: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_338_4 as isize);
            tracer.read_register(s_338_4 as isize, value);
            value
        };
        // C s_338_6: const #20176u : u32
        let s_338_6: u32 = 20176;
        // N s_338_7: write-reg s_338_6 <= s_338_5
        let s_338_7: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_338_6 as isize, s_338_5);
            tracer.write_register(s_338_6 as isize, s_338_5);
        };
        // C s_338_8: const #() : ()
        let s_338_8: () = ();
        // S s_338_9: call EDECCR_read(s_338_8)
        let s_338_9: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_338_8);
        // D s_338_10: write-var ga#37035 <= s_338_9
        fn_state.ga_37035 = s_338_9;
        // D s_338_11: read-var ga#37035.0:struct
        let s_338_11: u32 = fn_state.ga_37035._0;
        // C s_338_12: const #9s : i
        let s_338_12: i128 = 9;
        // C s_338_13: const #23s : i
        let s_338_13: i128 = 23;
        // D s_338_14: cast zx s_338_11 -> bv
        let s_338_14: Bits = Bits::new(s_338_11 as u128, 32u16);
        // C s_338_15: const #0u : u9
        let s_338_15: u16 = 0;
        // C s_338_16: cast zx s_338_15 -> bv
        let s_338_16: Bits = Bits::new(s_338_15 as u128, 9u16);
        // C s_338_17: const #1u : u64
        let s_338_17: u64 = 1;
        // C s_338_18: cast zx s_338_17 -> bv
        let s_338_18: Bits = Bits::new(s_338_17 as u128, 64u16);
        // C s_338_19: lsl s_338_18 s_338_12
        let s_338_19: Bits = s_338_18 << s_338_12;
        // C s_338_20: sub s_338_19 s_338_18
        let s_338_20: Bits = ((s_338_19) - (s_338_18));
        // C s_338_21: and s_338_16 s_338_20
        let s_338_21: Bits = ((s_338_16) & (s_338_20));
        // C s_338_22: lsl s_338_21 s_338_13
        let s_338_22: Bits = s_338_21 << s_338_13;
        // C s_338_23: lsl s_338_20 s_338_13
        let s_338_23: Bits = s_338_20 << s_338_13;
        // C s_338_24: cmpl s_338_23
        let s_338_24: Bits = !s_338_23;
        // D s_338_25: and s_338_14 s_338_24
        let s_338_25: Bits = ((s_338_14) & (s_338_24));
        // D s_338_26: or s_338_25 s_338_22
        let s_338_26: Bits = ((s_338_25) | (s_338_22));
        // D s_338_27: cast reint s_338_26 -> u32
        let s_338_27: u32 = (s_338_26.value() as u32);
        // D s_338_28: call Mk_EDECCR_Type(s_338_27)
        let s_338_28: ProductType700c18a878c5601b = Mk_EDECCR_Type(
            state,
            tracer,
            s_338_27,
        );
        // D s_338_29: call EDECCR_write(s_338_28)
        let s_338_29: () = EDECCR_write(state, tracer, s_338_28);
        // D s_338_30: read-var cold:u8
        let s_338_30: bool = fn_state.cold;
        // N s_338_31: branch s_338_30 b482 b339
        if s_338_30 {
            return block_482(state, tracer, fn_state);
        } else {
            return block_339(state, tracer, fn_state);
        };
    }
    fn block_339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_339_0: jump b340
        return block_340(state, tracer, fn_state);
    }
    fn block_340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_340_0: read-var cold:u8
        let s_340_0: bool = fn_state.cold;
        // N s_340_1: branch s_340_0 b481 b341
        if s_340_0 {
            return block_481(state, tracer, fn_state);
        } else {
            return block_341(state, tracer, fn_state);
        };
    }
    fn block_341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_341_0: jump b342
        return block_342(state, tracer, fn_state);
    }
    fn block_342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_342_0: read-var cold:u8
        let s_342_0: bool = fn_state.cold;
        // N s_342_1: branch s_342_0 b480 b343
        if s_342_0 {
            return block_480(state, tracer, fn_state);
        } else {
            return block_343(state, tracer, fn_state);
        };
    }
    fn block_343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_343_0: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_344_0: const #() : ()
        let s_344_0: () = ();
        // S s_344_1: call EDECCR_read(s_344_0)
        let s_344_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_344_0);
        // D s_344_2: write-var ga#37045 <= s_344_1
        fn_state.ga_37045 = s_344_1;
        // D s_344_3: read-var ga#37045.0:struct
        let s_344_3: u32 = fn_state.ga_37045._0;
        // C s_344_4: const #1s : i
        let s_344_4: i128 = 1;
        // C s_344_5: const #19s : i
        let s_344_5: i128 = 19;
        // D s_344_6: cast zx s_344_3 -> bv
        let s_344_6: Bits = Bits::new(s_344_3 as u128, 32u16);
        // C s_344_7: const #0u : u8
        let s_344_7: bool = false;
        // C s_344_8: cast zx s_344_7 -> bv
        let s_344_8: Bits = Bits::new(s_344_7 as u128, 1u16);
        // C s_344_9: const #1u : u64
        let s_344_9: u64 = 1;
        // C s_344_10: cast zx s_344_9 -> bv
        let s_344_10: Bits = Bits::new(s_344_9 as u128, 64u16);
        // C s_344_11: lsl s_344_10 s_344_4
        let s_344_11: Bits = s_344_10 << s_344_4;
        // C s_344_12: sub s_344_11 s_344_10
        let s_344_12: Bits = ((s_344_11) - (s_344_10));
        // C s_344_13: and s_344_8 s_344_12
        let s_344_13: Bits = ((s_344_8) & (s_344_12));
        // C s_344_14: lsl s_344_13 s_344_5
        let s_344_14: Bits = s_344_13 << s_344_5;
        // C s_344_15: lsl s_344_12 s_344_5
        let s_344_15: Bits = s_344_12 << s_344_5;
        // C s_344_16: cmpl s_344_15
        let s_344_16: Bits = !s_344_15;
        // D s_344_17: and s_344_6 s_344_16
        let s_344_17: Bits = ((s_344_6) & (s_344_16));
        // D s_344_18: or s_344_17 s_344_14
        let s_344_18: Bits = ((s_344_17) | (s_344_14));
        // D s_344_19: cast reint s_344_18 -> u32
        let s_344_19: u32 = (s_344_18.value() as u32);
        // D s_344_20: call Mk_EDECCR_Type(s_344_19)
        let s_344_20: ProductType700c18a878c5601b = Mk_EDECCR_Type(
            state,
            tracer,
            s_344_19,
        );
        // D s_344_21: call EDECCR_write(s_344_20)
        let s_344_21: () = EDECCR_write(state, tracer, s_344_20);
        // D s_344_22: read-var cold:u8
        let s_344_22: bool = fn_state.cold;
        // N s_344_23: branch s_344_22 b479 b345
        if s_344_22 {
            return block_479(state, tracer, fn_state);
        } else {
            return block_345(state, tracer, fn_state);
        };
    }
    fn block_345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_345_0: jump b346
        return block_346(state, tracer, fn_state);
    }
    fn block_346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_346_0: read-var cold:u8
        let s_346_0: bool = fn_state.cold;
        // N s_346_1: branch s_346_0 b478 b347
        if s_346_0 {
            return block_478(state, tracer, fn_state);
        } else {
            return block_347(state, tracer, fn_state);
        };
    }
    fn block_347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_347_0: jump b348
        return block_348(state, tracer, fn_state);
    }
    fn block_348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_348_0: read-var cold:u8
        let s_348_0: bool = fn_state.cold;
        // N s_348_1: branch s_348_0 b477 b349
        if s_348_0 {
            return block_477(state, tracer, fn_state);
        } else {
            return block_349(state, tracer, fn_state);
        };
    }
    fn block_349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_349_0: jump b350
        return block_350(state, tracer, fn_state);
    }
    fn block_350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_350_0: read-var cold:u8
        let s_350_0: bool = fn_state.cold;
        // N s_350_1: branch s_350_0 b476 b351
        if s_350_0 {
            return block_476(state, tracer, fn_state);
        } else {
            return block_351(state, tracer, fn_state);
        };
    }
    fn block_351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_351_0: jump b352
        return block_352(state, tracer, fn_state);
    }
    fn block_352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_352_0: read-var cold:u8
        let s_352_0: bool = fn_state.cold;
        // N s_352_1: branch s_352_0 b475 b353
        if s_352_0 {
            return block_475(state, tracer, fn_state);
        } else {
            return block_353(state, tracer, fn_state);
        };
    }
    fn block_353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_353_0: jump b354
        return block_354(state, tracer, fn_state);
    }
    fn block_354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_354_0: read-var cold:u8
        let s_354_0: bool = fn_state.cold;
        // N s_354_1: branch s_354_0 b474 b355
        if s_354_0 {
            return block_474(state, tracer, fn_state);
        } else {
            return block_355(state, tracer, fn_state);
        };
    }
    fn block_355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_355_0: jump b356
        return block_356(state, tracer, fn_state);
    }
    fn block_356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_356_0: read-var cold:u8
        let s_356_0: bool = fn_state.cold;
        // N s_356_1: branch s_356_0 b473 b357
        if s_356_0 {
            return block_473(state, tracer, fn_state);
        } else {
            return block_357(state, tracer, fn_state);
        };
    }
    fn block_357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_357_0: jump b358
        return block_358(state, tracer, fn_state);
    }
    fn block_358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_358_0: read-var cold:u8
        let s_358_0: bool = fn_state.cold;
        // N s_358_1: branch s_358_0 b472 b359
        if s_358_0 {
            return block_472(state, tracer, fn_state);
        } else {
            return block_359(state, tracer, fn_state);
        };
    }
    fn block_359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_359_0: jump b360
        return block_360(state, tracer, fn_state);
    }
    fn block_360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_360_0: read-var cold:u8
        let s_360_0: bool = fn_state.cold;
        // N s_360_1: branch s_360_0 b471 b361
        if s_360_0 {
            return block_471(state, tracer, fn_state);
        } else {
            return block_361(state, tracer, fn_state);
        };
    }
    fn block_361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_361_0: jump b362
        return block_362(state, tracer, fn_state);
    }
    fn block_362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_362_0: read-var cold:u8
        let s_362_0: bool = fn_state.cold;
        // N s_362_1: branch s_362_0 b470 b363
        if s_362_0 {
            return block_470(state, tracer, fn_state);
        } else {
            return block_363(state, tracer, fn_state);
        };
    }
    fn block_363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_363_0: jump b364
        return block_364(state, tracer, fn_state);
    }
    fn block_364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_364_0: read-var cold:u8
        let s_364_0: bool = fn_state.cold;
        // N s_364_1: branch s_364_0 b469 b365
        if s_364_0 {
            return block_469(state, tracer, fn_state);
        } else {
            return block_365(state, tracer, fn_state);
        };
    }
    fn block_365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_365_0: jump b366
        return block_366(state, tracer, fn_state);
    }
    fn block_366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_366_0: read-var cold:u8
        let s_366_0: bool = fn_state.cold;
        // N s_366_1: branch s_366_0 b468 b367
        if s_366_0 {
            return block_468(state, tracer, fn_state);
        } else {
            return block_367(state, tracer, fn_state);
        };
    }
    fn block_367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_367_0: jump b368
        return block_368(state, tracer, fn_state);
    }
    fn block_368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_368_0: read-var cold:u8
        let s_368_0: bool = fn_state.cold;
        // N s_368_1: branch s_368_0 b467 b369
        if s_368_0 {
            return block_467(state, tracer, fn_state);
        } else {
            return block_369(state, tracer, fn_state);
        };
    }
    fn block_369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_369_0: jump b370
        return block_370(state, tracer, fn_state);
    }
    fn block_370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_370_0: read-var cold:u8
        let s_370_0: bool = fn_state.cold;
        // N s_370_1: branch s_370_0 b466 b371
        if s_370_0 {
            return block_466(state, tracer, fn_state);
        } else {
            return block_371(state, tracer, fn_state);
        };
    }
    fn block_371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_371_0: jump b372
        return block_372(state, tracer, fn_state);
    }
    fn block_372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_372_0: const #102544u : u32
        let s_372_0: u32 = 102544;
        // D s_372_1: read-reg s_372_0:struct
        let s_372_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_0 as isize);
            tracer.read_register(s_372_0 as isize, value);
            value
        };
        // C s_372_2: const #102544u : u32
        let s_372_2: u32 = 102544;
        // N s_372_3: write-reg s_372_2 <= s_372_1
        let s_372_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_2 as isize, s_372_1);
            tracer.write_register(s_372_2 as isize, s_372_1);
        };
        // C s_372_4: const #89504u : u32
        let s_372_4: u32 = 89504;
        // D s_372_5: read-reg s_372_4:struct
        let s_372_5: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_4 as isize);
            tracer.read_register(s_372_4 as isize, value);
            value
        };
        // C s_372_6: const #89504u : u32
        let s_372_6: u32 = 89504;
        // N s_372_7: write-reg s_372_6 <= s_372_5
        let s_372_7: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_6 as isize, s_372_5);
            tracer.write_register(s_372_6 as isize, s_372_5);
        };
        // C s_372_8: const #104952u : u32
        let s_372_8: u32 = 104952;
        // D s_372_9: read-reg s_372_8:struct
        let s_372_9: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_8 as isize);
            tracer.read_register(s_372_8 as isize, value);
            value
        };
        // C s_372_10: const #104952u : u32
        let s_372_10: u32 = 104952;
        // N s_372_11: write-reg s_372_10 <= s_372_9
        let s_372_11: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_10 as isize, s_372_9);
            tracer.write_register(s_372_10 as isize, s_372_9);
        };
        // C s_372_12: const #104952u : u32
        let s_372_12: u32 = 104952;
        // D s_372_13: read-reg s_372_12:struct
        let s_372_13: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_12 as isize);
            tracer.read_register(s_372_12 as isize, value);
            value
        };
        // C s_372_14: const #104952u : u32
        let s_372_14: u32 = 104952;
        // N s_372_15: write-reg s_372_14 <= s_372_13
        let s_372_15: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_14 as isize, s_372_13);
            tracer.write_register(s_372_14 as isize, s_372_13);
        };
        // C s_372_16: const #102504u : u32
        let s_372_16: u32 = 102504;
        // D s_372_17: read-reg s_372_16:struct
        let s_372_17: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_16 as isize);
            tracer.read_register(s_372_16 as isize, value);
            value
        };
        // C s_372_18: const #102504u : u32
        let s_372_18: u32 = 102504;
        // N s_372_19: write-reg s_372_18 <= s_372_17
        let s_372_19: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_18 as isize, s_372_17);
            tracer.write_register(s_372_18 as isize, s_372_17);
        };
        // C s_372_20: const #102504u : u32
        let s_372_20: u32 = 102504;
        // D s_372_21: read-reg s_372_20:struct
        let s_372_21: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_20 as isize);
            tracer.read_register(s_372_20 as isize, value);
            value
        };
        // C s_372_22: const #102504u : u32
        let s_372_22: u32 = 102504;
        // N s_372_23: write-reg s_372_22 <= s_372_21
        let s_372_23: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_22 as isize, s_372_21);
            tracer.write_register(s_372_22 as isize, s_372_21);
        };
        // C s_372_24: const #22072u : u32
        let s_372_24: u32 = 22072;
        // D s_372_25: read-reg s_372_24:struct
        let s_372_25: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_24 as isize);
            tracer.read_register(s_372_24 as isize, value);
            value
        };
        // C s_372_26: const #22072u : u32
        let s_372_26: u32 = 22072;
        // N s_372_27: write-reg s_372_26 <= s_372_25
        let s_372_27: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_26 as isize, s_372_25);
            tracer.write_register(s_372_26 as isize, s_372_25);
        };
        // C s_372_28: const #23216u : u32
        let s_372_28: u32 = 23216;
        // D s_372_29: read-reg s_372_28:struct
        let s_372_29: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_28 as isize);
            tracer.read_register(s_372_28 as isize, value);
            value
        };
        // C s_372_30: const #23216u : u32
        let s_372_30: u32 = 23216;
        // N s_372_31: write-reg s_372_30 <= s_372_29
        let s_372_31: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_30 as isize, s_372_29);
            tracer.write_register(s_372_30 as isize, s_372_29);
        };
        // C s_372_32: const #22832u : u32
        let s_372_32: u32 = 22832;
        // D s_372_33: read-reg s_372_32:struct
        let s_372_33: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_32 as isize);
            tracer.read_register(s_372_32 as isize, value);
            value
        };
        // C s_372_34: const #22832u : u32
        let s_372_34: u32 = 22832;
        // N s_372_35: write-reg s_372_34 <= s_372_33
        let s_372_35: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_34 as isize, s_372_33);
            tracer.write_register(s_372_34 as isize, s_372_33);
        };
        // C s_372_36: const #91104u : u32
        let s_372_36: u32 = 91104;
        // D s_372_37: read-reg s_372_36:struct
        let s_372_37: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_36 as isize);
            tracer.read_register(s_372_36 as isize, value);
            value
        };
        // C s_372_38: const #91104u : u32
        let s_372_38: u32 = 91104;
        // N s_372_39: write-reg s_372_38 <= s_372_37
        let s_372_39: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_38 as isize, s_372_37);
            tracer.write_register(s_372_38 as isize, s_372_37);
        };
        // C s_372_40: const #101888u : u32
        let s_372_40: u32 = 101888;
        // D s_372_41: read-reg s_372_40:struct
        let s_372_41: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_40 as isize);
            tracer.read_register(s_372_40 as isize, value);
            value
        };
        // C s_372_42: const #101888u : u32
        let s_372_42: u32 = 101888;
        // N s_372_43: write-reg s_372_42 <= s_372_41
        let s_372_43: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_42 as isize, s_372_41);
            tracer.write_register(s_372_42 as isize, s_372_41);
        };
        // C s_372_44: const #10232u : u32
        let s_372_44: u32 = 10232;
        // D s_372_45: read-reg s_372_44:struct
        let s_372_45: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_372_44 as isize);
            tracer.read_register(s_372_44 as isize, value);
            value
        };
        // C s_372_46: const #10232u : u32
        let s_372_46: u32 = 10232;
        // N s_372_47: write-reg s_372_46 <= s_372_45
        let s_372_47: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_372_46 as isize, s_372_45);
            tracer.write_register(s_372_46 as isize, s_372_45);
        };
        // D s_372_48: read-var cold:u8
        let s_372_48: bool = fn_state.cold;
        // N s_372_49: branch s_372_48 b465 b373
        if s_372_48 {
            return block_465(state, tracer, fn_state);
        } else {
            return block_373(state, tracer, fn_state);
        };
    }
    fn block_373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_373_0: jump b374
        return block_374(state, tracer, fn_state);
    }
    fn block_374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_374_0: read-var cold:u8
        let s_374_0: bool = fn_state.cold;
        // N s_374_1: branch s_374_0 b464 b375
        if s_374_0 {
            return block_464(state, tracer, fn_state);
        } else {
            return block_375(state, tracer, fn_state);
        };
    }
    fn block_375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_375_0: jump b376
        return block_376(state, tracer, fn_state);
    }
    fn block_376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_376_0: read-var cold:u8
        let s_376_0: bool = fn_state.cold;
        // N s_376_1: branch s_376_0 b463 b377
        if s_376_0 {
            return block_463(state, tracer, fn_state);
        } else {
            return block_377(state, tracer, fn_state);
        };
    }
    fn block_377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_377_0: jump b378
        return block_378(state, tracer, fn_state);
    }
    fn block_378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_378_0: read-var cold:u8
        let s_378_0: bool = fn_state.cold;
        // N s_378_1: branch s_378_0 b462 b379
        if s_378_0 {
            return block_462(state, tracer, fn_state);
        } else {
            return block_379(state, tracer, fn_state);
        };
    }
    fn block_379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_379_0: jump b380
        return block_380(state, tracer, fn_state);
    }
    fn block_380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_380_0: read-var cold:u8
        let s_380_0: bool = fn_state.cold;
        // N s_380_1: branch s_380_0 b461 b381
        if s_380_0 {
            return block_461(state, tracer, fn_state);
        } else {
            return block_381(state, tracer, fn_state);
        };
    }
    fn block_381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_381_0: jump b382
        return block_382(state, tracer, fn_state);
    }
    fn block_382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_382_0: read-var cold:u8
        let s_382_0: bool = fn_state.cold;
        // N s_382_1: branch s_382_0 b460 b383
        if s_382_0 {
            return block_460(state, tracer, fn_state);
        } else {
            return block_383(state, tracer, fn_state);
        };
    }
    fn block_383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_383_0: jump b384
        return block_384(state, tracer, fn_state);
    }
    fn block_384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_384_0: read-var cold:u8
        let s_384_0: bool = fn_state.cold;
        // N s_384_1: branch s_384_0 b459 b385
        if s_384_0 {
            return block_459(state, tracer, fn_state);
        } else {
            return block_385(state, tracer, fn_state);
        };
    }
    fn block_385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_385_0: jump b386
        return block_386(state, tracer, fn_state);
    }
    fn block_386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_386_0: read-var cold:u8
        let s_386_0: bool = fn_state.cold;
        // N s_386_1: branch s_386_0 b458 b387
        if s_386_0 {
            return block_458(state, tracer, fn_state);
        } else {
            return block_387(state, tracer, fn_state);
        };
    }
    fn block_387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_387_0: jump b388
        return block_388(state, tracer, fn_state);
    }
    fn block_388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_388_0: read-var cold:u8
        let s_388_0: bool = fn_state.cold;
        // N s_388_1: branch s_388_0 b457 b389
        if s_388_0 {
            return block_457(state, tracer, fn_state);
        } else {
            return block_389(state, tracer, fn_state);
        };
    }
    fn block_389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_389_0: jump b390
        return block_390(state, tracer, fn_state);
    }
    fn block_390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_390_0: const #() : ()
        let s_390_0: () = ();
        // S s_390_1: call EDSCR_read(s_390_0)
        let s_390_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_390_0);
        // D s_390_2: write-var ga#37119 <= s_390_1
        fn_state.ga_37119 = s_390_1;
        // D s_390_3: read-var ga#37119.0:struct
        let s_390_3: u32 = fn_state.ga_37119._0;
        // C s_390_4: const #1s : i
        let s_390_4: i128 = 1;
        // C s_390_5: const #17s : i
        let s_390_5: i128 = 17;
        // D s_390_6: cast zx s_390_3 -> bv
        let s_390_6: Bits = Bits::new(s_390_3 as u128, 32u16);
        // C s_390_7: const #0u : u8
        let s_390_7: bool = false;
        // C s_390_8: cast zx s_390_7 -> bv
        let s_390_8: Bits = Bits::new(s_390_7 as u128, 1u16);
        // C s_390_9: const #1u : u64
        let s_390_9: u64 = 1;
        // C s_390_10: cast zx s_390_9 -> bv
        let s_390_10: Bits = Bits::new(s_390_9 as u128, 64u16);
        // C s_390_11: lsl s_390_10 s_390_4
        let s_390_11: Bits = s_390_10 << s_390_4;
        // C s_390_12: sub s_390_11 s_390_10
        let s_390_12: Bits = ((s_390_11) - (s_390_10));
        // C s_390_13: and s_390_8 s_390_12
        let s_390_13: Bits = ((s_390_8) & (s_390_12));
        // C s_390_14: lsl s_390_13 s_390_5
        let s_390_14: Bits = s_390_13 << s_390_5;
        // C s_390_15: lsl s_390_12 s_390_5
        let s_390_15: Bits = s_390_12 << s_390_5;
        // C s_390_16: cmpl s_390_15
        let s_390_16: Bits = !s_390_15;
        // D s_390_17: and s_390_6 s_390_16
        let s_390_17: Bits = ((s_390_6) & (s_390_16));
        // D s_390_18: or s_390_17 s_390_14
        let s_390_18: Bits = ((s_390_17) | (s_390_14));
        // D s_390_19: cast reint s_390_18 -> u32
        let s_390_19: u32 = (s_390_18.value() as u32);
        // D s_390_20: call Mk_EDSCR_Type(s_390_19)
        let s_390_20: ProductType700c18a878c5601b = Mk_EDSCR_Type(
            state,
            tracer,
            s_390_19,
        );
        // D s_390_21: call EDSCR_write(s_390_20)
        let s_390_21: () = EDSCR_write(state, tracer, s_390_20);
        // D s_390_22: read-var cold:u8
        let s_390_22: bool = fn_state.cold;
        // N s_390_23: branch s_390_22 b456 b391
        if s_390_22 {
            return block_456(state, tracer, fn_state);
        } else {
            return block_391(state, tracer, fn_state);
        };
    }
    fn block_391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_391_0: jump b392
        return block_392(state, tracer, fn_state);
    }
    fn block_392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_392_0: read-var cold:u8
        let s_392_0: bool = fn_state.cold;
        // N s_392_1: branch s_392_0 b455 b393
        if s_392_0 {
            return block_455(state, tracer, fn_state);
        } else {
            return block_393(state, tracer, fn_state);
        };
    }
    fn block_393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_393_0: jump b394
        return block_394(state, tracer, fn_state);
    }
    fn block_394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_394_0: const #22728u : u32
        let s_394_0: u32 = 22728;
        // D s_394_1: read-reg s_394_0:struct
        let s_394_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_0 as isize);
            tracer.read_register(s_394_0 as isize, value);
            value
        };
        // C s_394_2: const #22728u : u32
        let s_394_2: u32 = 22728;
        // N s_394_3: write-reg s_394_2 <= s_394_1
        let s_394_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_2 as isize, s_394_1);
            tracer.write_register(s_394_2 as isize, s_394_1);
        };
        // C s_394_4: const #14512u : u32
        let s_394_4: u32 = 14512;
        // D s_394_5: read-reg s_394_4:struct
        let s_394_5: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_4 as isize);
            tracer.read_register(s_394_4 as isize, value);
            value
        };
        // C s_394_6: const #14512u : u32
        let s_394_6: u32 = 14512;
        // N s_394_7: write-reg s_394_6 <= s_394_5
        let s_394_7: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_6 as isize, s_394_5);
            tracer.write_register(s_394_6 as isize, s_394_5);
        };
        // C s_394_8: const #14512u : u32
        let s_394_8: u32 = 14512;
        // D s_394_9: read-reg s_394_8:struct
        let s_394_9: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_8 as isize);
            tracer.read_register(s_394_8 as isize, value);
            value
        };
        // C s_394_10: const #14512u : u32
        let s_394_10: u32 = 14512;
        // N s_394_11: write-reg s_394_10 <= s_394_9
        let s_394_11: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_10 as isize, s_394_9);
            tracer.write_register(s_394_10 as isize, s_394_9);
        };
        // C s_394_12: const #14512u : u32
        let s_394_12: u32 = 14512;
        // D s_394_13: read-reg s_394_12:struct
        let s_394_13: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_12 as isize);
            tracer.read_register(s_394_12 as isize, value);
            value
        };
        // C s_394_14: const #14512u : u32
        let s_394_14: u32 = 14512;
        // N s_394_15: write-reg s_394_14 <= s_394_13
        let s_394_15: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_14 as isize, s_394_13);
            tracer.write_register(s_394_14 as isize, s_394_13);
        };
        // C s_394_16: const #14512u : u32
        let s_394_16: u32 = 14512;
        // D s_394_17: read-reg s_394_16:struct
        let s_394_17: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_16 as isize);
            tracer.read_register(s_394_16 as isize, value);
            value
        };
        // C s_394_18: const #14512u : u32
        let s_394_18: u32 = 14512;
        // N s_394_19: write-reg s_394_18 <= s_394_17
        let s_394_19: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_18 as isize, s_394_17);
            tracer.write_register(s_394_18 as isize, s_394_17);
        };
        // C s_394_20: const #14512u : u32
        let s_394_20: u32 = 14512;
        // D s_394_21: read-reg s_394_20:struct
        let s_394_21: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_20 as isize);
            tracer.read_register(s_394_20 as isize, value);
            value
        };
        // C s_394_22: const #14512u : u32
        let s_394_22: u32 = 14512;
        // N s_394_23: write-reg s_394_22 <= s_394_21
        let s_394_23: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_22 as isize, s_394_21);
            tracer.write_register(s_394_22 as isize, s_394_21);
        };
        // C s_394_24: const #14512u : u32
        let s_394_24: u32 = 14512;
        // D s_394_25: read-reg s_394_24:struct
        let s_394_25: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_24 as isize);
            tracer.read_register(s_394_24 as isize, value);
            value
        };
        // C s_394_26: const #14512u : u32
        let s_394_26: u32 = 14512;
        // N s_394_27: write-reg s_394_26 <= s_394_25
        let s_394_27: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_26 as isize, s_394_25);
            tracer.write_register(s_394_26 as isize, s_394_25);
        };
        // C s_394_28: const #13696u : u32
        let s_394_28: u32 = 13696;
        // D s_394_29: read-reg s_394_28:struct
        let s_394_29: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_28 as isize);
            tracer.read_register(s_394_28 as isize, value);
            value
        };
        // C s_394_30: const #13696u : u32
        let s_394_30: u32 = 13696;
        // N s_394_31: write-reg s_394_30 <= s_394_29
        let s_394_31: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_30 as isize, s_394_29);
            tracer.write_register(s_394_30 as isize, s_394_29);
        };
        // C s_394_32: const #13696u : u32
        let s_394_32: u32 = 13696;
        // D s_394_33: read-reg s_394_32:struct
        let s_394_33: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_32 as isize);
            tracer.read_register(s_394_32 as isize, value);
            value
        };
        // C s_394_34: const #13696u : u32
        let s_394_34: u32 = 13696;
        // N s_394_35: write-reg s_394_34 <= s_394_33
        let s_394_35: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_34 as isize, s_394_33);
            tracer.write_register(s_394_34 as isize, s_394_33);
        };
        // C s_394_36: const #104536u : u32
        let s_394_36: u32 = 104536;
        // D s_394_37: read-reg s_394_36:struct
        let s_394_37: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_36 as isize);
            tracer.read_register(s_394_36 as isize, value);
            value
        };
        // C s_394_38: const #104536u : u32
        let s_394_38: u32 = 104536;
        // N s_394_39: write-reg s_394_38 <= s_394_37
        let s_394_39: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_38 as isize, s_394_37);
            tracer.write_register(s_394_38 as isize, s_394_37);
        };
        // C s_394_40: const #0s : i
        let s_394_40: i128 = 0;
        // C s_394_41: const #101768u : u32
        let s_394_41: u32 = 101768;
        // D s_394_42: read-reg s_394_41:u32
        let s_394_42: u32 = {
            let value = state.read_register::<u32>(s_394_41 as isize);
            tracer.read_register(s_394_41 as isize, value);
            value
        };
        // D s_394_43: cast zx s_394_42 -> bv
        let s_394_43: Bits = Bits::new(s_394_42 as u128, 32u16);
        // C s_394_44: const #0u : u32
        let s_394_44: u32 = 0;
        // C s_394_45: cast zx s_394_44 -> bv
        let s_394_45: Bits = Bits::new(s_394_44 as u128, 32u16);
        // C s_394_46: const #31s : i
        let s_394_46: i128 = 31;
        // C s_394_47: const #1u : u64
        let s_394_47: u64 = 1;
        // C s_394_48: cast zx s_394_47 -> bv
        let s_394_48: Bits = Bits::new(s_394_47 as u128, 64u16);
        // C s_394_49: lsl s_394_48 s_394_46
        let s_394_49: Bits = s_394_48 << s_394_46;
        // C s_394_50: sub s_394_49 s_394_48
        let s_394_50: Bits = ((s_394_49) - (s_394_48));
        // C s_394_51: and s_394_45 s_394_50
        let s_394_51: Bits = ((s_394_45) & (s_394_50));
        // C s_394_52: lsl s_394_51 s_394_40
        let s_394_52: Bits = s_394_51 << s_394_40;
        // C s_394_53: lsl s_394_50 s_394_40
        let s_394_53: Bits = s_394_50 << s_394_40;
        // C s_394_54: cmpl s_394_53
        let s_394_54: Bits = !s_394_53;
        // D s_394_55: and s_394_43 s_394_54
        let s_394_55: Bits = ((s_394_43) & (s_394_54));
        // D s_394_56: or s_394_55 s_394_52
        let s_394_56: Bits = ((s_394_55) | (s_394_52));
        // D s_394_57: cast reint s_394_56 -> u32
        let s_394_57: u32 = (s_394_56.value() as u32);
        // C s_394_58: const #101768u : u32
        let s_394_58: u32 = 101768;
        // N s_394_59: write-reg s_394_58 <= s_394_57
        let s_394_59: () = {
            state.write_register::<u32>(s_394_58 as isize, s_394_57);
            tracer.write_register(s_394_58 as isize, s_394_57);
        };
        // C s_394_60: const #23440u : u32
        let s_394_60: u32 = 23440;
        // D s_394_61: read-reg s_394_60:struct
        let s_394_61: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_60 as isize);
            tracer.read_register(s_394_60 as isize, value);
            value
        };
        // C s_394_62: const #23440u : u32
        let s_394_62: u32 = 23440;
        // N s_394_63: write-reg s_394_62 <= s_394_61
        let s_394_63: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_62 as isize, s_394_61);
            tracer.write_register(s_394_62 as isize, s_394_61);
        };
        // C s_394_64: const #13680u : u32
        let s_394_64: u32 = 13680;
        // D s_394_65: read-reg s_394_64:struct
        let s_394_65: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_64 as isize);
            tracer.read_register(s_394_64 as isize, value);
            value
        };
        // C s_394_66: const #13680u : u32
        let s_394_66: u32 = 13680;
        // N s_394_67: write-reg s_394_66 <= s_394_65
        let s_394_67: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_66 as isize, s_394_65);
            tracer.write_register(s_394_66 as isize, s_394_65);
        };
        // C s_394_68: const #11472u : u32
        let s_394_68: u32 = 11472;
        // D s_394_69: read-reg s_394_68:struct
        let s_394_69: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_68 as isize);
            tracer.read_register(s_394_68 as isize, value);
            value
        };
        // C s_394_70: const #11472u : u32
        let s_394_70: u32 = 11472;
        // N s_394_71: write-reg s_394_70 <= s_394_69
        let s_394_71: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_70 as isize, s_394_69);
            tracer.write_register(s_394_70 as isize, s_394_69);
        };
        // C s_394_72: const #101048u : u32
        let s_394_72: u32 = 101048;
        // D s_394_73: read-reg s_394_72:struct
        let s_394_73: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_72 as isize);
            tracer.read_register(s_394_72 as isize, value);
            value
        };
        // C s_394_74: const #101048u : u32
        let s_394_74: u32 = 101048;
        // N s_394_75: write-reg s_394_74 <= s_394_73
        let s_394_75: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_74 as isize, s_394_73);
            tracer.write_register(s_394_74 as isize, s_394_73);
        };
        // C s_394_76: const #15712u : u32
        let s_394_76: u32 = 15712;
        // D s_394_77: read-reg s_394_76:struct
        let s_394_77: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_76 as isize);
            tracer.read_register(s_394_76 as isize, value);
            value
        };
        // C s_394_78: const #15712u : u32
        let s_394_78: u32 = 15712;
        // N s_394_79: write-reg s_394_78 <= s_394_77
        let s_394_79: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_78 as isize, s_394_77);
            tracer.write_register(s_394_78 as isize, s_394_77);
        };
        // C s_394_80: const #21944u : u32
        let s_394_80: u32 = 21944;
        // D s_394_81: read-reg s_394_80:struct
        let s_394_81: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_80 as isize);
            tracer.read_register(s_394_80 as isize, value);
            value
        };
        // C s_394_82: const #21944u : u32
        let s_394_82: u32 = 21944;
        // N s_394_83: write-reg s_394_82 <= s_394_81
        let s_394_83: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_82 as isize, s_394_81);
            tracer.write_register(s_394_82 as isize, s_394_81);
        };
        // C s_394_84: const #17048u : u32
        let s_394_84: u32 = 17048;
        // D s_394_85: read-reg s_394_84:struct
        let s_394_85: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_84 as isize);
            tracer.read_register(s_394_84 as isize, value);
            value
        };
        // C s_394_86: const #17048u : u32
        let s_394_86: u32 = 17048;
        // N s_394_87: write-reg s_394_86 <= s_394_85
        let s_394_87: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_86 as isize, s_394_85);
            tracer.write_register(s_394_86 as isize, s_394_85);
        };
        // C s_394_88: const #100800u : u32
        let s_394_88: u32 = 100800;
        // D s_394_89: read-reg s_394_88:struct
        let s_394_89: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_88 as isize);
            tracer.read_register(s_394_88 as isize, value);
            value
        };
        // C s_394_90: const #100800u : u32
        let s_394_90: u32 = 100800;
        // N s_394_91: write-reg s_394_90 <= s_394_89
        let s_394_91: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_90 as isize, s_394_89);
            tracer.write_register(s_394_90 as isize, s_394_89);
        };
        // C s_394_92: const #15648u : u32
        let s_394_92: u32 = 15648;
        // D s_394_93: read-reg s_394_92:struct
        let s_394_93: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_394_92 as isize);
            tracer.read_register(s_394_92 as isize, value);
            value
        };
        // C s_394_94: const #15648u : u32
        let s_394_94: u32 = 15648;
        // N s_394_95: write-reg s_394_94 <= s_394_93
        let s_394_95: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_394_94 as isize, s_394_93);
            tracer.write_register(s_394_94 as isize, s_394_93);
        };
        // C s_394_96: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_394_96: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_394_97: call __IMPDEF_boolean(s_394_96)
        let s_394_97: bool = u__IMPDEF_boolean(state, tracer, s_394_96);
        // N s_394_98: branch s_394_97 b454 b395
        if s_394_97 {
            return block_454(state, tracer, fn_state);
        } else {
            return block_395(state, tracer, fn_state);
        };
    }
    fn block_395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_395_0: jump b396
        return block_396(state, tracer, fn_state);
    }
    fn block_396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_396_0: const #0u : u8
        let s_396_0: bool = false;
        // S s_396_1: call Bit(s_396_0)
        let s_396_1: bool = Bit(state, tracer, s_396_0);
        // C s_396_2: const #15648u : u32
        let s_396_2: u32 = 15648;
        // D s_396_3: read-reg s_396_2:struct
        let s_396_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_396_2 as isize);
            tracer.read_register(s_396_2 as isize, value);
            value
        };
        // C s_396_4: const #15648u : u32
        let s_396_4: u32 = 15648;
        // N s_396_5: write-reg s_396_4 <= s_396_3
        let s_396_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_396_4 as isize, s_396_3);
            tracer.write_register(s_396_4 as isize, s_396_3);
        };
        // C s_396_6: const #15648u : u32
        let s_396_6: u32 = 15648;
        // D s_396_7: read-reg s_396_6:struct
        let s_396_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_396_6 as isize);
            tracer.read_register(s_396_6 as isize, value);
            value
        };
        // C s_396_8: const #15648u : u32
        let s_396_8: u32 = 15648;
        // N s_396_9: write-reg s_396_8 <= s_396_7
        let s_396_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_396_8 as isize, s_396_7);
            tracer.write_register(s_396_8 as isize, s_396_7);
        };
        // C s_396_10: const #10496u : u32
        let s_396_10: u32 = 10496;
        // D s_396_11: read-reg s_396_10:struct
        let s_396_11: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_396_10 as isize);
            tracer.read_register(s_396_10 as isize, value);
            value
        };
        // D s_396_12: call _get_GICD_CTLR_Type_DS(s_396_11)
        let s_396_12: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_396_11);
        // D s_396_13: cast zx s_396_12 -> bv
        let s_396_13: Bits = Bits::new(s_396_12 as u128, 1u16);
        // C s_396_14: const #1u : u8
        let s_396_14: bool = true;
        // C s_396_15: cast zx s_396_14 -> bv
        let s_396_15: Bits = Bits::new(s_396_14 as u128, 1u16);
        // D s_396_16: cmp-eq s_396_13 s_396_15
        let s_396_16: bool = ((s_396_13) == (s_396_15));
        // N s_396_17: branch s_396_16 b453 b397
        if s_396_16 {
            return block_453(state, tracer, fn_state);
        } else {
            return block_397(state, tracer, fn_state);
        };
    }
    fn block_397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_397_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_397_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_397_1: call __IMPDEF_boolean(s_397_0)
        let s_397_1: bool = u__IMPDEF_boolean(state, tracer, s_397_0);
        // N s_397_2: branch s_397_1 b452 b398
        if s_397_1 {
            return block_452(state, tracer, fn_state);
        } else {
            return block_398(state, tracer, fn_state);
        };
    }
    fn block_398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_398_0: jump b399
        return block_399(state, tracer, fn_state);
    }
    fn block_399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_399_0: const #0u : u8
        let s_399_0: bool = false;
        // S s_399_1: call Bit(s_399_0)
        let s_399_1: bool = Bit(state, tracer, s_399_0);
        // C s_399_2: const #15648u : u32
        let s_399_2: u32 = 15648;
        // D s_399_3: read-reg s_399_2:struct
        let s_399_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_399_2 as isize);
            tracer.read_register(s_399_2 as isize, value);
            value
        };
        // C s_399_4: const #15648u : u32
        let s_399_4: u32 = 15648;
        // N s_399_5: write-reg s_399_4 <= s_399_3
        let s_399_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_399_4 as isize, s_399_3);
            tracer.write_register(s_399_4 as isize, s_399_3);
        };
        // C s_399_6: const #10496u : u32
        let s_399_6: u32 = 10496;
        // D s_399_7: read-reg s_399_6:struct
        let s_399_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_399_6 as isize);
            tracer.read_register(s_399_6 as isize, value);
            value
        };
        // D s_399_8: call _get_GICD_CTLR_Type_DS(s_399_7)
        let s_399_8: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_399_7);
        // D s_399_9: cast zx s_399_8 -> bv
        let s_399_9: Bits = Bits::new(s_399_8 as u128, 1u16);
        // C s_399_10: const #1u : u8
        let s_399_10: bool = true;
        // C s_399_11: cast zx s_399_10 -> bv
        let s_399_11: Bits = Bits::new(s_399_10 as u128, 1u16);
        // D s_399_12: cmp-eq s_399_9 s_399_11
        let s_399_12: bool = ((s_399_9) == (s_399_11));
        // N s_399_13: branch s_399_12 b451 b400
        if s_399_12 {
            return block_451(state, tracer, fn_state);
        } else {
            return block_400(state, tracer, fn_state);
        };
    }
    fn block_400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_400_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_400_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_400_1: call __IMPDEF_boolean(s_400_0)
        let s_400_1: bool = u__IMPDEF_boolean(state, tracer, s_400_0);
        // N s_400_2: branch s_400_1 b450 b401
        if s_400_1 {
            return block_450(state, tracer, fn_state);
        } else {
            return block_401(state, tracer, fn_state);
        };
    }
    fn block_401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_401_0: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_402_0: const #0u : u8
        let s_402_0: bool = false;
        // S s_402_1: call Bit(s_402_0)
        let s_402_1: bool = Bit(state, tracer, s_402_0);
        // C s_402_2: const #15648u : u32
        let s_402_2: u32 = 15648;
        // D s_402_3: read-reg s_402_2:struct
        let s_402_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_402_2 as isize);
            tracer.read_register(s_402_2 as isize, value);
            value
        };
        // C s_402_4: const #15648u : u32
        let s_402_4: u32 = 15648;
        // N s_402_5: write-reg s_402_4 <= s_402_3
        let s_402_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_402_4 as isize, s_402_3);
            tracer.write_register(s_402_4 as isize, s_402_3);
        };
        // C s_402_6: const #15648u : u32
        let s_402_6: u32 = 15648;
        // D s_402_7: read-reg s_402_6:struct
        let s_402_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_402_6 as isize);
            tracer.read_register(s_402_6 as isize, value);
            value
        };
        // C s_402_8: const #15648u : u32
        let s_402_8: u32 = 15648;
        // N s_402_9: write-reg s_402_8 <= s_402_7
        let s_402_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_402_8 as isize, s_402_7);
            tracer.write_register(s_402_8 as isize, s_402_7);
        };
        // C s_402_10: const #10496u : u32
        let s_402_10: u32 = 10496;
        // D s_402_11: read-reg s_402_10:struct
        let s_402_11: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_402_10 as isize);
            tracer.read_register(s_402_10 as isize, value);
            value
        };
        // D s_402_12: call _get_GICD_CTLR_Type_DS(s_402_11)
        let s_402_12: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_402_11);
        // D s_402_13: cast zx s_402_12 -> bv
        let s_402_13: Bits = Bits::new(s_402_12 as u128, 1u16);
        // C s_402_14: const #1u : u8
        let s_402_14: bool = true;
        // C s_402_15: cast zx s_402_14 -> bv
        let s_402_15: Bits = Bits::new(s_402_14 as u128, 1u16);
        // D s_402_16: cmp-eq s_402_13 s_402_15
        let s_402_16: bool = ((s_402_13) == (s_402_15));
        // N s_402_17: branch s_402_16 b449 b403
        if s_402_16 {
            return block_449(state, tracer, fn_state);
        } else {
            return block_403(state, tracer, fn_state);
        };
    }
    fn block_403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_403_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_403_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_403_1: call __IMPDEF_boolean(s_403_0)
        let s_403_1: bool = u__IMPDEF_boolean(state, tracer, s_403_0);
        // N s_403_2: branch s_403_1 b448 b404
        if s_403_1 {
            return block_448(state, tracer, fn_state);
        } else {
            return block_404(state, tracer, fn_state);
        };
    }
    fn block_404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_404_0: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_405_0: const #0u : u8
        let s_405_0: bool = false;
        // S s_405_1: call Bit(s_405_0)
        let s_405_1: bool = Bit(state, tracer, s_405_0);
        // C s_405_2: const #15648u : u32
        let s_405_2: u32 = 15648;
        // D s_405_3: read-reg s_405_2:struct
        let s_405_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_405_2 as isize);
            tracer.read_register(s_405_2 as isize, value);
            value
        };
        // C s_405_4: const #15648u : u32
        let s_405_4: u32 = 15648;
        // N s_405_5: write-reg s_405_4 <= s_405_3
        let s_405_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_405_4 as isize, s_405_3);
            tracer.write_register(s_405_4 as isize, s_405_3);
        };
        // C s_405_6: const #15648u : u32
        let s_405_6: u32 = 15648;
        // D s_405_7: read-reg s_405_6:struct
        let s_405_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_405_6 as isize);
            tracer.read_register(s_405_6 as isize, value);
            value
        };
        // C s_405_8: const #15648u : u32
        let s_405_8: u32 = 15648;
        // N s_405_9: write-reg s_405_8 <= s_405_7
        let s_405_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_405_8 as isize, s_405_7);
            tracer.write_register(s_405_8 as isize, s_405_7);
        };
        // C s_405_10: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_405_10: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_405_11: call __IMPDEF_boolean(s_405_10)
        let s_405_11: bool = u__IMPDEF_boolean(state, tracer, s_405_10);
        // N s_405_12: branch s_405_11 b447 b406
        if s_405_11 {
            return block_447(state, tracer, fn_state);
        } else {
            return block_406(state, tracer, fn_state);
        };
    }
    fn block_406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_406_0: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_407_0: const #0u : u8
        let s_407_0: bool = false;
        // S s_407_1: call Bit(s_407_0)
        let s_407_1: bool = Bit(state, tracer, s_407_0);
        // C s_407_2: const #15648u : u32
        let s_407_2: u32 = 15648;
        // D s_407_3: read-reg s_407_2:struct
        let s_407_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_407_2 as isize);
            tracer.read_register(s_407_2 as isize, value);
            value
        };
        // C s_407_4: const #15648u : u32
        let s_407_4: u32 = 15648;
        // N s_407_5: write-reg s_407_4 <= s_407_3
        let s_407_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_407_4 as isize, s_407_3);
            tracer.write_register(s_407_4 as isize, s_407_3);
        };
        // C s_407_6: const #15648u : u32
        let s_407_6: u32 = 15648;
        // D s_407_7: read-reg s_407_6:struct
        let s_407_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_407_6 as isize);
            tracer.read_register(s_407_6 as isize, value);
            value
        };
        // C s_407_8: const #15648u : u32
        let s_407_8: u32 = 15648;
        // N s_407_9: write-reg s_407_8 <= s_407_7
        let s_407_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_407_8 as isize, s_407_7);
            tracer.write_register(s_407_8 as isize, s_407_7);
        };
        // C s_407_10: const #10496u : u32
        let s_407_10: u32 = 10496;
        // D s_407_11: read-reg s_407_10:struct
        let s_407_11: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_407_10 as isize);
            tracer.read_register(s_407_10 as isize, value);
            value
        };
        // D s_407_12: call _get_GICD_CTLR_Type_DS(s_407_11)
        let s_407_12: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_407_11);
        // D s_407_13: cast zx s_407_12 -> bv
        let s_407_13: Bits = Bits::new(s_407_12 as u128, 1u16);
        // C s_407_14: const #1u : u8
        let s_407_14: bool = true;
        // C s_407_15: cast zx s_407_14 -> bv
        let s_407_15: Bits = Bits::new(s_407_14 as u128, 1u16);
        // D s_407_16: cmp-eq s_407_13 s_407_15
        let s_407_16: bool = ((s_407_13) == (s_407_15));
        // N s_407_17: branch s_407_16 b446 b408
        if s_407_16 {
            return block_446(state, tracer, fn_state);
        } else {
            return block_408(state, tracer, fn_state);
        };
    }
    fn block_408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_408_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_408_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_408_1: call __IMPDEF_boolean(s_408_0)
        let s_408_1: bool = u__IMPDEF_boolean(state, tracer, s_408_0);
        // N s_408_2: branch s_408_1 b445 b409
        if s_408_1 {
            return block_445(state, tracer, fn_state);
        } else {
            return block_409(state, tracer, fn_state);
        };
    }
    fn block_409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_409_0: jump b410
        return block_410(state, tracer, fn_state);
    }
    fn block_410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_410_0: const #0u : u8
        let s_410_0: bool = false;
        // S s_410_1: call Bit(s_410_0)
        let s_410_1: bool = Bit(state, tracer, s_410_0);
        // C s_410_2: const #15648u : u32
        let s_410_2: u32 = 15648;
        // D s_410_3: read-reg s_410_2:struct
        let s_410_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_410_2 as isize);
            tracer.read_register(s_410_2 as isize, value);
            value
        };
        // C s_410_4: const #15648u : u32
        let s_410_4: u32 = 15648;
        // N s_410_5: write-reg s_410_4 <= s_410_3
        let s_410_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_410_4 as isize, s_410_3);
            tracer.write_register(s_410_4 as isize, s_410_3);
        };
        // C s_410_6: const #10496u : u32
        let s_410_6: u32 = 10496;
        // D s_410_7: read-reg s_410_6:struct
        let s_410_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_410_6 as isize);
            tracer.read_register(s_410_6 as isize, value);
            value
        };
        // D s_410_8: call _get_GICD_CTLR_Type_DS(s_410_7)
        let s_410_8: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_410_7);
        // D s_410_9: cast zx s_410_8 -> bv
        let s_410_9: Bits = Bits::new(s_410_8 as u128, 1u16);
        // C s_410_10: const #1u : u8
        let s_410_10: bool = true;
        // C s_410_11: cast zx s_410_10 -> bv
        let s_410_11: Bits = Bits::new(s_410_10 as u128, 1u16);
        // D s_410_12: cmp-eq s_410_9 s_410_11
        let s_410_12: bool = ((s_410_9) == (s_410_11));
        // N s_410_13: branch s_410_12 b444 b411
        if s_410_12 {
            return block_444(state, tracer, fn_state);
        } else {
            return block_411(state, tracer, fn_state);
        };
    }
    fn block_411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_411_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_411_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_411_1: call __IMPDEF_boolean(s_411_0)
        let s_411_1: bool = u__IMPDEF_boolean(state, tracer, s_411_0);
        // N s_411_2: branch s_411_1 b443 b412
        if s_411_1 {
            return block_443(state, tracer, fn_state);
        } else {
            return block_412(state, tracer, fn_state);
        };
    }
    fn block_412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_412_0: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_413_0: const #0u : u8
        let s_413_0: bool = false;
        // S s_413_1: call Bit(s_413_0)
        let s_413_1: bool = Bit(state, tracer, s_413_0);
        // C s_413_2: const #15648u : u32
        let s_413_2: u32 = 15648;
        // D s_413_3: read-reg s_413_2:struct
        let s_413_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_413_2 as isize);
            tracer.read_register(s_413_2 as isize, value);
            value
        };
        // C s_413_4: const #15648u : u32
        let s_413_4: u32 = 15648;
        // N s_413_5: write-reg s_413_4 <= s_413_3
        let s_413_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_413_4 as isize, s_413_3);
            tracer.write_register(s_413_4 as isize, s_413_3);
        };
        // C s_413_6: const #15648u : u32
        let s_413_6: u32 = 15648;
        // D s_413_7: read-reg s_413_6:struct
        let s_413_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_413_6 as isize);
            tracer.read_register(s_413_6 as isize, value);
            value
        };
        // C s_413_8: const #15648u : u32
        let s_413_8: u32 = 15648;
        // N s_413_9: write-reg s_413_8 <= s_413_7
        let s_413_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_413_8 as isize, s_413_7);
            tracer.write_register(s_413_8 as isize, s_413_7);
        };
        // C s_413_10: const #15648u : u32
        let s_413_10: u32 = 15648;
        // D s_413_11: read-reg s_413_10:struct
        let s_413_11: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_413_10 as isize);
            tracer.read_register(s_413_10 as isize, value);
            value
        };
        // C s_413_12: const #15648u : u32
        let s_413_12: u32 = 15648;
        // N s_413_13: write-reg s_413_12 <= s_413_11
        let s_413_13: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_413_12 as isize, s_413_11);
            tracer.write_register(s_413_12 as isize, s_413_11);
        };
        // C s_413_14: const #15648u : u32
        let s_413_14: u32 = 15648;
        // D s_413_15: read-reg s_413_14:struct
        let s_413_15: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_413_14 as isize);
            tracer.read_register(s_413_14 as isize, value);
            value
        };
        // C s_413_16: const #15648u : u32
        let s_413_16: u32 = 15648;
        // N s_413_17: write-reg s_413_16 <= s_413_15
        let s_413_17: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_413_16 as isize, s_413_15);
            tracer.write_register(s_413_16 as isize, s_413_15);
        };
        // C s_413_18: const #15648u : u32
        let s_413_18: u32 = 15648;
        // D s_413_19: read-reg s_413_18:struct
        let s_413_19: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_413_18 as isize);
            tracer.read_register(s_413_18 as isize, value);
            value
        };
        // C s_413_20: const #15648u : u32
        let s_413_20: u32 = 15648;
        // N s_413_21: write-reg s_413_20 <= s_413_19
        let s_413_21: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_413_20 as isize, s_413_19);
            tracer.write_register(s_413_20 as isize, s_413_19);
        };
        // C s_413_22: const #0u : u8
        let s_413_22: bool = false;
        // S s_413_23: call Bit(s_413_22)
        let s_413_23: bool = Bit(state, tracer, s_413_22);
        // C s_413_24: const #15648u : u32
        let s_413_24: u32 = 15648;
        // D s_413_25: read-reg s_413_24:struct
        let s_413_25: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_413_24 as isize);
            tracer.read_register(s_413_24 as isize, value);
            value
        };
        // C s_413_26: const #15648u : u32
        let s_413_26: u32 = 15648;
        // N s_413_27: write-reg s_413_26 <= s_413_25
        let s_413_27: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_413_26 as isize, s_413_25);
            tracer.write_register(s_413_26 as isize, s_413_25);
        };
        // C s_413_28: const #10496u : u32
        let s_413_28: u32 = 10496;
        // D s_413_29: read-reg s_413_28:struct
        let s_413_29: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_413_28 as isize);
            tracer.read_register(s_413_28 as isize, value);
            value
        };
        // D s_413_30: call _get_GICD_CTLR_Type_DS(s_413_29)
        let s_413_30: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_413_29);
        // D s_413_31: cast zx s_413_30 -> bv
        let s_413_31: Bits = Bits::new(s_413_30 as u128, 1u16);
        // C s_413_32: const #1u : u8
        let s_413_32: bool = true;
        // C s_413_33: cast zx s_413_32 -> bv
        let s_413_33: Bits = Bits::new(s_413_32 as u128, 1u16);
        // D s_413_34: cmp-eq s_413_31 s_413_33
        let s_413_34: bool = ((s_413_31) == (s_413_33));
        // N s_413_35: branch s_413_34 b442 b414
        if s_413_34 {
            return block_442(state, tracer, fn_state);
        } else {
            return block_414(state, tracer, fn_state);
        };
    }
    fn block_414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_414_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_414_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_414_1: call __IMPDEF_boolean(s_414_0)
        let s_414_1: bool = u__IMPDEF_boolean(state, tracer, s_414_0);
        // N s_414_2: branch s_414_1 b441 b415
        if s_414_1 {
            return block_441(state, tracer, fn_state);
        } else {
            return block_415(state, tracer, fn_state);
        };
    }
    fn block_415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_415_0: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_416_0: const #0u : u8
        let s_416_0: bool = false;
        // S s_416_1: call Bit(s_416_0)
        let s_416_1: bool = Bit(state, tracer, s_416_0);
        // C s_416_2: const #15648u : u32
        let s_416_2: u32 = 15648;
        // D s_416_3: read-reg s_416_2:struct
        let s_416_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_416_2 as isize);
            tracer.read_register(s_416_2 as isize, value);
            value
        };
        // C s_416_4: const #15648u : u32
        let s_416_4: u32 = 15648;
        // N s_416_5: write-reg s_416_4 <= s_416_3
        let s_416_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_416_4 as isize, s_416_3);
            tracer.write_register(s_416_4 as isize, s_416_3);
        };
        // C s_416_6: const #15648u : u32
        let s_416_6: u32 = 15648;
        // D s_416_7: read-reg s_416_6:struct
        let s_416_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_416_6 as isize);
            tracer.read_register(s_416_6 as isize, value);
            value
        };
        // C s_416_8: const #15648u : u32
        let s_416_8: u32 = 15648;
        // N s_416_9: write-reg s_416_8 <= s_416_7
        let s_416_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_416_8 as isize, s_416_7);
            tracer.write_register(s_416_8 as isize, s_416_7);
        };
        // C s_416_10: const #15648u : u32
        let s_416_10: u32 = 15648;
        // D s_416_11: read-reg s_416_10:struct
        let s_416_11: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_416_10 as isize);
            tracer.read_register(s_416_10 as isize, value);
            value
        };
        // C s_416_12: const #15648u : u32
        let s_416_12: u32 = 15648;
        // N s_416_13: write-reg s_416_12 <= s_416_11
        let s_416_13: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_416_12 as isize, s_416_11);
            tracer.write_register(s_416_12 as isize, s_416_11);
        };
        // C s_416_14: const #15648u : u32
        let s_416_14: u32 = 15648;
        // D s_416_15: read-reg s_416_14:struct
        let s_416_15: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_416_14 as isize);
            tracer.read_register(s_416_14 as isize, value);
            value
        };
        // C s_416_16: const #15648u : u32
        let s_416_16: u32 = 15648;
        // N s_416_17: write-reg s_416_16 <= s_416_15
        let s_416_17: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_416_16 as isize, s_416_15);
            tracer.write_register(s_416_16 as isize, s_416_15);
        };
        // C s_416_18: const #10496u : u32
        let s_416_18: u32 = 10496;
        // D s_416_19: read-reg s_416_18:struct
        let s_416_19: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_416_18 as isize);
            tracer.read_register(s_416_18 as isize, value);
            value
        };
        // D s_416_20: call _get_GICD_CTLR_Type_DS(s_416_19)
        let s_416_20: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_416_19);
        // D s_416_21: cast zx s_416_20 -> bv
        let s_416_21: Bits = Bits::new(s_416_20 as u128, 1u16);
        // C s_416_22: const #1u : u8
        let s_416_22: bool = true;
        // C s_416_23: cast zx s_416_22 -> bv
        let s_416_23: Bits = Bits::new(s_416_22 as u128, 1u16);
        // D s_416_24: cmp-eq s_416_21 s_416_23
        let s_416_24: bool = ((s_416_21) == (s_416_23));
        // N s_416_25: branch s_416_24 b440 b417
        if s_416_24 {
            return block_440(state, tracer, fn_state);
        } else {
            return block_417(state, tracer, fn_state);
        };
    }
    fn block_417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_417_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_417_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_417_1: call __IMPDEF_boolean(s_417_0)
        let s_417_1: bool = u__IMPDEF_boolean(state, tracer, s_417_0);
        // N s_417_2: branch s_417_1 b439 b418
        if s_417_1 {
            return block_439(state, tracer, fn_state);
        } else {
            return block_418(state, tracer, fn_state);
        };
    }
    fn block_418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_418_0: jump b419
        return block_419(state, tracer, fn_state);
    }
    fn block_419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_419_0: const #0u : u8
        let s_419_0: bool = false;
        // S s_419_1: call Bit(s_419_0)
        let s_419_1: bool = Bit(state, tracer, s_419_0);
        // C s_419_2: const #15648u : u32
        let s_419_2: u32 = 15648;
        // D s_419_3: read-reg s_419_2:struct
        let s_419_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_419_2 as isize);
            tracer.read_register(s_419_2 as isize, value);
            value
        };
        // C s_419_4: const #15648u : u32
        let s_419_4: u32 = 15648;
        // N s_419_5: write-reg s_419_4 <= s_419_3
        let s_419_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_419_4 as isize, s_419_3);
            tracer.write_register(s_419_4 as isize, s_419_3);
        };
        // C s_419_6: const #10496u : u32
        let s_419_6: u32 = 10496;
        // D s_419_7: read-reg s_419_6:struct
        let s_419_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_419_6 as isize);
            tracer.read_register(s_419_6 as isize, value);
            value
        };
        // D s_419_8: call _get_GICD_CTLR_Type_DS(s_419_7)
        let s_419_8: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_419_7);
        // D s_419_9: cast zx s_419_8 -> bv
        let s_419_9: Bits = Bits::new(s_419_8 as u128, 1u16);
        // C s_419_10: const #1u : u8
        let s_419_10: bool = true;
        // C s_419_11: cast zx s_419_10 -> bv
        let s_419_11: Bits = Bits::new(s_419_10 as u128, 1u16);
        // D s_419_12: cmp-eq s_419_9 s_419_11
        let s_419_12: bool = ((s_419_9) == (s_419_11));
        // N s_419_13: branch s_419_12 b438 b420
        if s_419_12 {
            return block_438(state, tracer, fn_state);
        } else {
            return block_420(state, tracer, fn_state);
        };
    }
    fn block_420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_420_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_420_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_420_1: call __IMPDEF_boolean(s_420_0)
        let s_420_1: bool = u__IMPDEF_boolean(state, tracer, s_420_0);
        // N s_420_2: branch s_420_1 b437 b421
        if s_420_1 {
            return block_437(state, tracer, fn_state);
        } else {
            return block_421(state, tracer, fn_state);
        };
    }
    fn block_421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_421_0: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_422_0: const #0u : u8
        let s_422_0: bool = false;
        // S s_422_1: call Bit(s_422_0)
        let s_422_1: bool = Bit(state, tracer, s_422_0);
        // C s_422_2: const #15648u : u32
        let s_422_2: u32 = 15648;
        // D s_422_3: read-reg s_422_2:struct
        let s_422_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_422_2 as isize);
            tracer.read_register(s_422_2 as isize, value);
            value
        };
        // C s_422_4: const #15648u : u32
        let s_422_4: u32 = 15648;
        // N s_422_5: write-reg s_422_4 <= s_422_3
        let s_422_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_422_4 as isize, s_422_3);
            tracer.write_register(s_422_4 as isize, s_422_3);
        };
        // C s_422_6: const #15648u : u32
        let s_422_6: u32 = 15648;
        // D s_422_7: read-reg s_422_6:struct
        let s_422_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_422_6 as isize);
            tracer.read_register(s_422_6 as isize, value);
            value
        };
        // C s_422_8: const #15648u : u32
        let s_422_8: u32 = 15648;
        // N s_422_9: write-reg s_422_8 <= s_422_7
        let s_422_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_422_8 as isize, s_422_7);
            tracer.write_register(s_422_8 as isize, s_422_7);
        };
        // C s_422_10: const #15648u : u32
        let s_422_10: u32 = 15648;
        // D s_422_11: read-reg s_422_10:struct
        let s_422_11: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_422_10 as isize);
            tracer.read_register(s_422_10 as isize, value);
            value
        };
        // C s_422_12: const #15648u : u32
        let s_422_12: u32 = 15648;
        // N s_422_13: write-reg s_422_12 <= s_422_11
        let s_422_13: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_422_12 as isize, s_422_11);
            tracer.write_register(s_422_12 as isize, s_422_11);
        };
        // C s_422_14: const #15648u : u32
        let s_422_14: u32 = 15648;
        // D s_422_15: read-reg s_422_14:struct
        let s_422_15: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_422_14 as isize);
            tracer.read_register(s_422_14 as isize, value);
            value
        };
        // C s_422_16: const #15648u : u32
        let s_422_16: u32 = 15648;
        // N s_422_17: write-reg s_422_16 <= s_422_15
        let s_422_17: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_422_16 as isize, s_422_15);
            tracer.write_register(s_422_16 as isize, s_422_15);
        };
        // C s_422_18: const #15648u : u32
        let s_422_18: u32 = 15648;
        // D s_422_19: read-reg s_422_18:struct
        let s_422_19: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_422_18 as isize);
            tracer.read_register(s_422_18 as isize, value);
            value
        };
        // C s_422_20: const #15648u : u32
        let s_422_20: u32 = 15648;
        // N s_422_21: write-reg s_422_20 <= s_422_19
        let s_422_21: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_422_20 as isize, s_422_19);
            tracer.write_register(s_422_20 as isize, s_422_19);
        };
        // C s_422_22: const #0u : u8
        let s_422_22: bool = false;
        // S s_422_23: call Bit(s_422_22)
        let s_422_23: bool = Bit(state, tracer, s_422_22);
        // C s_422_24: const #15648u : u32
        let s_422_24: u32 = 15648;
        // D s_422_25: read-reg s_422_24:struct
        let s_422_25: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_422_24 as isize);
            tracer.read_register(s_422_24 as isize, value);
            value
        };
        // C s_422_26: const #15648u : u32
        let s_422_26: u32 = 15648;
        // N s_422_27: write-reg s_422_26 <= s_422_25
        let s_422_27: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_422_26 as isize, s_422_25);
            tracer.write_register(s_422_26 as isize, s_422_25);
        };
        // C s_422_28: const #10496u : u32
        let s_422_28: u32 = 10496;
        // D s_422_29: read-reg s_422_28:struct
        let s_422_29: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_422_28 as isize);
            tracer.read_register(s_422_28 as isize, value);
            value
        };
        // D s_422_30: call _get_GICD_CTLR_Type_DS(s_422_29)
        let s_422_30: bool = u_get_GICD_CTLR_Type_DS(state, tracer, s_422_29);
        // D s_422_31: cast zx s_422_30 -> bv
        let s_422_31: Bits = Bits::new(s_422_30 as u128, 1u16);
        // C s_422_32: const #1u : u8
        let s_422_32: bool = true;
        // C s_422_33: cast zx s_422_32 -> bv
        let s_422_33: Bits = Bits::new(s_422_32 as u128, 1u16);
        // D s_422_34: cmp-eq s_422_31 s_422_33
        let s_422_34: bool = ((s_422_31) == (s_422_33));
        // N s_422_35: branch s_422_34 b436 b423
        if s_422_34 {
            return block_436(state, tracer, fn_state);
        } else {
            return block_423(state, tracer, fn_state);
        };
    }
    fn block_423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_423_0: const #"GICD_CTLR.DS==0, Secure access" : str
        let s_423_0: &'static str = "GICD_CTLR.DS==0, Secure access";
        // S s_423_1: call __IMPDEF_boolean(s_423_0)
        let s_423_1: bool = u__IMPDEF_boolean(state, tracer, s_423_0);
        // N s_423_2: branch s_423_1 b435 b424
        if s_423_1 {
            return block_435(state, tracer, fn_state);
        } else {
            return block_424(state, tracer, fn_state);
        };
    }
    fn block_424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_424_0: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_425_0: const #0u : u8
        let s_425_0: bool = false;
        // S s_425_1: call Bit(s_425_0)
        let s_425_1: bool = Bit(state, tracer, s_425_0);
        // C s_425_2: const #15648u : u32
        let s_425_2: u32 = 15648;
        // D s_425_3: read-reg s_425_2:struct
        let s_425_3: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_425_2 as isize);
            tracer.read_register(s_425_2 as isize, value);
            value
        };
        // C s_425_4: const #15648u : u32
        let s_425_4: u32 = 15648;
        // N s_425_5: write-reg s_425_4 <= s_425_3
        let s_425_5: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_425_4 as isize, s_425_3);
            tracer.write_register(s_425_4 as isize, s_425_3);
        };
        // C s_425_6: const #15648u : u32
        let s_425_6: u32 = 15648;
        // D s_425_7: read-reg s_425_6:struct
        let s_425_7: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_425_6 as isize);
            tracer.read_register(s_425_6 as isize, value);
            value
        };
        // C s_425_8: const #15648u : u32
        let s_425_8: u32 = 15648;
        // N s_425_9: write-reg s_425_8 <= s_425_7
        let s_425_9: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_425_8 as isize, s_425_7);
            tracer.write_register(s_425_8 as isize, s_425_7);
        };
        // C s_425_10: const #90160u : u32
        let s_425_10: u32 = 90160;
        // D s_425_11: read-reg s_425_10:struct
        let s_425_11: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_425_10 as isize);
            tracer.read_register(s_425_10 as isize, value);
            value
        };
        // C s_425_12: const #90160u : u32
        let s_425_12: u32 = 90160;
        // N s_425_13: write-reg s_425_12 <= s_425_11
        let s_425_13: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_425_12 as isize, s_425_11);
            tracer.write_register(s_425_12 as isize, s_425_11);
        };
        // C s_425_14: const #21904u : u32
        let s_425_14: u32 = 21904;
        // D s_425_15: read-reg s_425_14:struct
        let s_425_15: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_425_14 as isize);
            tracer.read_register(s_425_14 as isize, value);
            value
        };
        // C s_425_16: const #21904u : u32
        let s_425_16: u32 = 21904;
        // N s_425_17: write-reg s_425_16 <= s_425_15
        let s_425_17: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_425_16 as isize, s_425_15);
            tracer.write_register(s_425_16 as isize, s_425_15);
        };
        // C s_425_18: const #21904u : u32
        let s_425_18: u32 = 21904;
        // D s_425_19: read-reg s_425_18:struct
        let s_425_19: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_425_18 as isize);
            tracer.read_register(s_425_18 as isize, value);
            value
        };
        // C s_425_20: const #21904u : u32
        let s_425_20: u32 = 21904;
        // N s_425_21: write-reg s_425_20 <= s_425_19
        let s_425_21: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_425_20 as isize, s_425_19);
            tracer.write_register(s_425_20 as isize, s_425_19);
        };
        // C s_425_22: const #14040u : u32
        let s_425_22: u32 = 14040;
        // D s_425_23: read-reg s_425_22:struct
        let s_425_23: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_425_22 as isize);
            tracer.read_register(s_425_22 as isize, value);
            value
        };
        // C s_425_24: const #14040u : u32
        let s_425_24: u32 = 14040;
        // N s_425_25: write-reg s_425_24 <= s_425_23
        let s_425_25: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_425_24 as isize, s_425_23);
            tracer.write_register(s_425_24 as isize, s_425_23);
        };
        // C s_425_26: const #0u : u8
        let s_425_26: bool = false;
        // S s_425_27: call Bit(s_425_26)
        let s_425_27: bool = Bit(state, tracer, s_425_26);
        // C s_425_28: const #14040u : u32
        let s_425_28: u32 = 14040;
        // D s_425_29: read-reg s_425_28:struct
        let s_425_29: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_425_28 as isize);
            tracer.read_register(s_425_28 as isize, value);
            value
        };
        // C s_425_30: const #14040u : u32
        let s_425_30: u32 = 14040;
        // N s_425_31: write-reg s_425_30 <= s_425_29
        let s_425_31: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_425_30 as isize, s_425_29);
            tracer.write_register(s_425_30 as isize, s_425_29);
        };
        // C s_425_32: const #14040u : u32
        let s_425_32: u32 = 14040;
        // D s_425_33: read-reg s_425_32:struct
        let s_425_33: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_425_32 as isize);
            tracer.read_register(s_425_32 as isize, value);
            value
        };
        // C s_425_34: const #14040u : u32
        let s_425_34: u32 = 14040;
        // N s_425_35: write-reg s_425_34 <= s_425_33
        let s_425_35: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_425_34 as isize, s_425_33);
            tracer.write_register(s_425_34 as isize, s_425_33);
        };
        // D s_425_36: read-var cold:u8
        let s_425_36: bool = fn_state.cold;
        // N s_425_37: branch s_425_36 b434 b426
        if s_425_36 {
            return block_434(state, tracer, fn_state);
        } else {
            return block_426(state, tracer, fn_state);
        };
    }
    fn block_426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_426_0: jump b427
        return block_427(state, tracer, fn_state);
    }
    fn block_427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_427_0: read-var cold:u8
        let s_427_0: bool = fn_state.cold;
        // N s_427_1: branch s_427_0 b433 b428
        if s_427_0 {
            return block_433(state, tracer, fn_state);
        } else {
            return block_428(state, tracer, fn_state);
        };
    }
    fn block_428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_428_0: jump b429
        return block_429(state, tracer, fn_state);
    }
    fn block_429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_429_0: const #14040u : u32
        let s_429_0: u32 = 14040;
        // D s_429_1: read-reg s_429_0:struct
        let s_429_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_429_0 as isize);
            tracer.read_register(s_429_0 as isize, value);
            value
        };
        // C s_429_2: const #14040u : u32
        let s_429_2: u32 = 14040;
        // N s_429_3: write-reg s_429_2 <= s_429_1
        let s_429_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_429_2 as isize, s_429_1);
            tracer.write_register(s_429_2 as isize, s_429_1);
        };
        // D s_429_4: read-var cold:u8
        let s_429_4: bool = fn_state.cold;
        // N s_429_5: branch s_429_4 b432 b430
        if s_429_4 {
            return block_432(state, tracer, fn_state);
        } else {
            return block_430(state, tracer, fn_state);
        };
    }
    fn block_430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_430_0: jump b431
        return block_431(state, tracer, fn_state);
    }
    fn block_431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_431_0: const #90464u : u32
        let s_431_0: u32 = 90464;
        // D s_431_1: read-reg s_431_0:struct
        let s_431_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_0 as isize);
            tracer.read_register(s_431_0 as isize, value);
            value
        };
        // C s_431_2: const #90464u : u32
        let s_431_2: u32 = 90464;
        // N s_431_3: write-reg s_431_2 <= s_431_1
        let s_431_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_2 as isize, s_431_1);
            tracer.write_register(s_431_2 as isize, s_431_1);
        };
        // C s_431_4: const #90464u : u32
        let s_431_4: u32 = 90464;
        // D s_431_5: read-reg s_431_4:struct
        let s_431_5: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_4 as isize);
            tracer.read_register(s_431_4 as isize, value);
            value
        };
        // C s_431_6: const #90464u : u32
        let s_431_6: u32 = 90464;
        // N s_431_7: write-reg s_431_6 <= s_431_5
        let s_431_7: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_6 as isize, s_431_5);
            tracer.write_register(s_431_6 as isize, s_431_5);
        };
        // C s_431_8: const #90464u : u32
        let s_431_8: u32 = 90464;
        // D s_431_9: read-reg s_431_8:struct
        let s_431_9: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_8 as isize);
            tracer.read_register(s_431_8 as isize, value);
            value
        };
        // C s_431_10: const #90464u : u32
        let s_431_10: u32 = 90464;
        // N s_431_11: write-reg s_431_10 <= s_431_9
        let s_431_11: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_10 as isize, s_431_9);
            tracer.write_register(s_431_10 as isize, s_431_9);
        };
        // C s_431_12: const #90464u : u32
        let s_431_12: u32 = 90464;
        // D s_431_13: read-reg s_431_12:struct
        let s_431_13: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_12 as isize);
            tracer.read_register(s_431_12 as isize, value);
            value
        };
        // C s_431_14: const #90464u : u32
        let s_431_14: u32 = 90464;
        // N s_431_15: write-reg s_431_14 <= s_431_13
        let s_431_15: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_14 as isize, s_431_13);
            tracer.write_register(s_431_14 as isize, s_431_13);
        };
        // C s_431_16: const #90464u : u32
        let s_431_16: u32 = 90464;
        // D s_431_17: read-reg s_431_16:struct
        let s_431_17: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_16 as isize);
            tracer.read_register(s_431_16 as isize, value);
            value
        };
        // C s_431_18: const #90464u : u32
        let s_431_18: u32 = 90464;
        // N s_431_19: write-reg s_431_18 <= s_431_17
        let s_431_19: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_18 as isize, s_431_17);
            tracer.write_register(s_431_18 as isize, s_431_17);
        };
        // C s_431_20: const #90464u : u32
        let s_431_20: u32 = 90464;
        // D s_431_21: read-reg s_431_20:struct
        let s_431_21: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_20 as isize);
            tracer.read_register(s_431_20 as isize, value);
            value
        };
        // C s_431_22: const #90464u : u32
        let s_431_22: u32 = 90464;
        // N s_431_23: write-reg s_431_22 <= s_431_21
        let s_431_23: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_22 as isize, s_431_21);
            tracer.write_register(s_431_22 as isize, s_431_21);
        };
        // C s_431_24: const #90464u : u32
        let s_431_24: u32 = 90464;
        // D s_431_25: read-reg s_431_24:struct
        let s_431_25: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_24 as isize);
            tracer.read_register(s_431_24 as isize, value);
            value
        };
        // C s_431_26: const #90464u : u32
        let s_431_26: u32 = 90464;
        // N s_431_27: write-reg s_431_26 <= s_431_25
        let s_431_27: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_26 as isize, s_431_25);
            tracer.write_register(s_431_26 as isize, s_431_25);
        };
        // C s_431_28: const #90464u : u32
        let s_431_28: u32 = 90464;
        // D s_431_29: read-reg s_431_28:struct
        let s_431_29: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_28 as isize);
            tracer.read_register(s_431_28 as isize, value);
            value
        };
        // C s_431_30: const #90464u : u32
        let s_431_30: u32 = 90464;
        // N s_431_31: write-reg s_431_30 <= s_431_29
        let s_431_31: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_30 as isize, s_431_29);
            tracer.write_register(s_431_30 as isize, s_431_29);
        };
        // C s_431_32: const #90464u : u32
        let s_431_32: u32 = 90464;
        // D s_431_33: read-reg s_431_32:struct
        let s_431_33: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_32 as isize);
            tracer.read_register(s_431_32 as isize, value);
            value
        };
        // C s_431_34: const #90464u : u32
        let s_431_34: u32 = 90464;
        // N s_431_35: write-reg s_431_34 <= s_431_33
        let s_431_35: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_34 as isize, s_431_33);
            tracer.write_register(s_431_34 as isize, s_431_33);
        };
        // C s_431_36: const #90464u : u32
        let s_431_36: u32 = 90464;
        // D s_431_37: read-reg s_431_36:struct
        let s_431_37: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_36 as isize);
            tracer.read_register(s_431_36 as isize, value);
            value
        };
        // C s_431_38: const #90464u : u32
        let s_431_38: u32 = 90464;
        // N s_431_39: write-reg s_431_38 <= s_431_37
        let s_431_39: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_38 as isize, s_431_37);
            tracer.write_register(s_431_38 as isize, s_431_37);
        };
        // C s_431_40: const #90464u : u32
        let s_431_40: u32 = 90464;
        // D s_431_41: read-reg s_431_40:struct
        let s_431_41: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_40 as isize);
            tracer.read_register(s_431_40 as isize, value);
            value
        };
        // C s_431_42: const #90464u : u32
        let s_431_42: u32 = 90464;
        // N s_431_43: write-reg s_431_42 <= s_431_41
        let s_431_43: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_42 as isize, s_431_41);
            tracer.write_register(s_431_42 as isize, s_431_41);
        };
        // C s_431_44: const #90464u : u32
        let s_431_44: u32 = 90464;
        // D s_431_45: read-reg s_431_44:struct
        let s_431_45: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_44 as isize);
            tracer.read_register(s_431_44 as isize, value);
            value
        };
        // C s_431_46: const #90464u : u32
        let s_431_46: u32 = 90464;
        // N s_431_47: write-reg s_431_46 <= s_431_45
        let s_431_47: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_46 as isize, s_431_45);
            tracer.write_register(s_431_46 as isize, s_431_45);
        };
        // C s_431_48: const #90464u : u32
        let s_431_48: u32 = 90464;
        // D s_431_49: read-reg s_431_48:struct
        let s_431_49: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_48 as isize);
            tracer.read_register(s_431_48 as isize, value);
            value
        };
        // C s_431_50: const #90464u : u32
        let s_431_50: u32 = 90464;
        // N s_431_51: write-reg s_431_50 <= s_431_49
        let s_431_51: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_50 as isize, s_431_49);
            tracer.write_register(s_431_50 as isize, s_431_49);
        };
        // C s_431_52: const #90464u : u32
        let s_431_52: u32 = 90464;
        // D s_431_53: read-reg s_431_52:struct
        let s_431_53: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_52 as isize);
            tracer.read_register(s_431_52 as isize, value);
            value
        };
        // C s_431_54: const #90464u : u32
        let s_431_54: u32 = 90464;
        // N s_431_55: write-reg s_431_54 <= s_431_53
        let s_431_55: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_54 as isize, s_431_53);
            tracer.write_register(s_431_54 as isize, s_431_53);
        };
        // C s_431_56: const #90464u : u32
        let s_431_56: u32 = 90464;
        // D s_431_57: read-reg s_431_56:struct
        let s_431_57: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_56 as isize);
            tracer.read_register(s_431_56 as isize, value);
            value
        };
        // C s_431_58: const #90464u : u32
        let s_431_58: u32 = 90464;
        // N s_431_59: write-reg s_431_58 <= s_431_57
        let s_431_59: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_58 as isize, s_431_57);
            tracer.write_register(s_431_58 as isize, s_431_57);
        };
        // C s_431_60: const #90464u : u32
        let s_431_60: u32 = 90464;
        // D s_431_61: read-reg s_431_60:struct
        let s_431_61: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_60 as isize);
            tracer.read_register(s_431_60 as isize, value);
            value
        };
        // C s_431_62: const #90464u : u32
        let s_431_62: u32 = 90464;
        // N s_431_63: write-reg s_431_62 <= s_431_61
        let s_431_63: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_62 as isize, s_431_61);
            tracer.write_register(s_431_62 as isize, s_431_61);
        };
        // C s_431_64: const #90464u : u32
        let s_431_64: u32 = 90464;
        // D s_431_65: read-reg s_431_64:struct
        let s_431_65: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_64 as isize);
            tracer.read_register(s_431_64 as isize, value);
            value
        };
        // C s_431_66: const #90464u : u32
        let s_431_66: u32 = 90464;
        // N s_431_67: write-reg s_431_66 <= s_431_65
        let s_431_67: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_66 as isize, s_431_65);
            tracer.write_register(s_431_66 as isize, s_431_65);
        };
        // C s_431_68: const #90464u : u32
        let s_431_68: u32 = 90464;
        // D s_431_69: read-reg s_431_68:struct
        let s_431_69: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_68 as isize);
            tracer.read_register(s_431_68 as isize, value);
            value
        };
        // C s_431_70: const #90464u : u32
        let s_431_70: u32 = 90464;
        // N s_431_71: write-reg s_431_70 <= s_431_69
        let s_431_71: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_70 as isize, s_431_69);
            tracer.write_register(s_431_70 as isize, s_431_69);
        };
        // C s_431_72: const #90464u : u32
        let s_431_72: u32 = 90464;
        // D s_431_73: read-reg s_431_72:struct
        let s_431_73: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_72 as isize);
            tracer.read_register(s_431_72 as isize, value);
            value
        };
        // C s_431_74: const #90464u : u32
        let s_431_74: u32 = 90464;
        // N s_431_75: write-reg s_431_74 <= s_431_73
        let s_431_75: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_74 as isize, s_431_73);
            tracer.write_register(s_431_74 as isize, s_431_73);
        };
        // C s_431_76: const #90464u : u32
        let s_431_76: u32 = 90464;
        // D s_431_77: read-reg s_431_76:struct
        let s_431_77: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_76 as isize);
            tracer.read_register(s_431_76 as isize, value);
            value
        };
        // C s_431_78: const #90464u : u32
        let s_431_78: u32 = 90464;
        // N s_431_79: write-reg s_431_78 <= s_431_77
        let s_431_79: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_78 as isize, s_431_77);
            tracer.write_register(s_431_78 as isize, s_431_77);
        };
        // C s_431_80: const #90464u : u32
        let s_431_80: u32 = 90464;
        // D s_431_81: read-reg s_431_80:struct
        let s_431_81: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_80 as isize);
            tracer.read_register(s_431_80 as isize, value);
            value
        };
        // C s_431_82: const #90464u : u32
        let s_431_82: u32 = 90464;
        // N s_431_83: write-reg s_431_82 <= s_431_81
        let s_431_83: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_82 as isize, s_431_81);
            tracer.write_register(s_431_82 as isize, s_431_81);
        };
        // C s_431_84: const #90464u : u32
        let s_431_84: u32 = 90464;
        // D s_431_85: read-reg s_431_84:struct
        let s_431_85: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_84 as isize);
            tracer.read_register(s_431_84 as isize, value);
            value
        };
        // C s_431_86: const #90464u : u32
        let s_431_86: u32 = 90464;
        // N s_431_87: write-reg s_431_86 <= s_431_85
        let s_431_87: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_86 as isize, s_431_85);
            tracer.write_register(s_431_86 as isize, s_431_85);
        };
        // C s_431_88: const #90464u : u32
        let s_431_88: u32 = 90464;
        // D s_431_89: read-reg s_431_88:struct
        let s_431_89: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_88 as isize);
            tracer.read_register(s_431_88 as isize, value);
            value
        };
        // C s_431_90: const #90464u : u32
        let s_431_90: u32 = 90464;
        // N s_431_91: write-reg s_431_90 <= s_431_89
        let s_431_91: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_90 as isize, s_431_89);
            tracer.write_register(s_431_90 as isize, s_431_89);
        };
        // C s_431_92: const #90464u : u32
        let s_431_92: u32 = 90464;
        // D s_431_93: read-reg s_431_92:struct
        let s_431_93: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_92 as isize);
            tracer.read_register(s_431_92 as isize, value);
            value
        };
        // C s_431_94: const #90464u : u32
        let s_431_94: u32 = 90464;
        // N s_431_95: write-reg s_431_94 <= s_431_93
        let s_431_95: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_94 as isize, s_431_93);
            tracer.write_register(s_431_94 as isize, s_431_93);
        };
        // C s_431_96: const #90464u : u32
        let s_431_96: u32 = 90464;
        // D s_431_97: read-reg s_431_96:struct
        let s_431_97: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_96 as isize);
            tracer.read_register(s_431_96 as isize, value);
            value
        };
        // C s_431_98: const #90464u : u32
        let s_431_98: u32 = 90464;
        // N s_431_99: write-reg s_431_98 <= s_431_97
        let s_431_99: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_98 as isize, s_431_97);
            tracer.write_register(s_431_98 as isize, s_431_97);
        };
        // C s_431_100: const #90464u : u32
        let s_431_100: u32 = 90464;
        // D s_431_101: read-reg s_431_100:struct
        let s_431_101: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_100 as isize);
            tracer.read_register(s_431_100 as isize, value);
            value
        };
        // C s_431_102: const #90464u : u32
        let s_431_102: u32 = 90464;
        // N s_431_103: write-reg s_431_102 <= s_431_101
        let s_431_103: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_102 as isize, s_431_101);
            tracer.write_register(s_431_102 as isize, s_431_101);
        };
        // C s_431_104: const #90464u : u32
        let s_431_104: u32 = 90464;
        // D s_431_105: read-reg s_431_104:struct
        let s_431_105: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_104 as isize);
            tracer.read_register(s_431_104 as isize, value);
            value
        };
        // C s_431_106: const #90464u : u32
        let s_431_106: u32 = 90464;
        // N s_431_107: write-reg s_431_106 <= s_431_105
        let s_431_107: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_106 as isize, s_431_105);
            tracer.write_register(s_431_106 as isize, s_431_105);
        };
        // C s_431_108: const #90464u : u32
        let s_431_108: u32 = 90464;
        // D s_431_109: read-reg s_431_108:struct
        let s_431_109: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_108 as isize);
            tracer.read_register(s_431_108 as isize, value);
            value
        };
        // C s_431_110: const #90464u : u32
        let s_431_110: u32 = 90464;
        // N s_431_111: write-reg s_431_110 <= s_431_109
        let s_431_111: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_110 as isize, s_431_109);
            tracer.write_register(s_431_110 as isize, s_431_109);
        };
        // C s_431_112: const #90464u : u32
        let s_431_112: u32 = 90464;
        // D s_431_113: read-reg s_431_112:struct
        let s_431_113: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_112 as isize);
            tracer.read_register(s_431_112 as isize, value);
            value
        };
        // C s_431_114: const #90464u : u32
        let s_431_114: u32 = 90464;
        // N s_431_115: write-reg s_431_114 <= s_431_113
        let s_431_115: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_114 as isize, s_431_113);
            tracer.write_register(s_431_114 as isize, s_431_113);
        };
        // C s_431_116: const #90464u : u32
        let s_431_116: u32 = 90464;
        // D s_431_117: read-reg s_431_116:struct
        let s_431_117: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_116 as isize);
            tracer.read_register(s_431_116 as isize, value);
            value
        };
        // C s_431_118: const #90464u : u32
        let s_431_118: u32 = 90464;
        // N s_431_119: write-reg s_431_118 <= s_431_117
        let s_431_119: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_118 as isize, s_431_117);
            tracer.write_register(s_431_118 as isize, s_431_117);
        };
        // C s_431_120: const #90464u : u32
        let s_431_120: u32 = 90464;
        // D s_431_121: read-reg s_431_120:struct
        let s_431_121: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_120 as isize);
            tracer.read_register(s_431_120 as isize, value);
            value
        };
        // C s_431_122: const #90464u : u32
        let s_431_122: u32 = 90464;
        // N s_431_123: write-reg s_431_122 <= s_431_121
        let s_431_123: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_122 as isize, s_431_121);
            tracer.write_register(s_431_122 as isize, s_431_121);
        };
        // C s_431_124: const #90464u : u32
        let s_431_124: u32 = 90464;
        // D s_431_125: read-reg s_431_124:struct
        let s_431_125: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_124 as isize);
            tracer.read_register(s_431_124 as isize, value);
            value
        };
        // C s_431_126: const #90464u : u32
        let s_431_126: u32 = 90464;
        // N s_431_127: write-reg s_431_126 <= s_431_125
        let s_431_127: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_126 as isize, s_431_125);
            tracer.write_register(s_431_126 as isize, s_431_125);
        };
        // C s_431_128: const #20424u : u32
        let s_431_128: u32 = 20424;
        // D s_431_129: read-reg s_431_128:struct
        let s_431_129: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_128 as isize);
            tracer.read_register(s_431_128 as isize, value);
            value
        };
        // C s_431_130: const #20424u : u32
        let s_431_130: u32 = 20424;
        // N s_431_131: write-reg s_431_130 <= s_431_129
        let s_431_131: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_130 as isize, s_431_129);
            tracer.write_register(s_431_130 as isize, s_431_129);
        };
        // C s_431_132: const #101808u : u32
        let s_431_132: u32 = 101808;
        // D s_431_133: read-reg s_431_132:struct
        let s_431_133: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_132 as isize);
            tracer.read_register(s_431_132 as isize, value);
            value
        };
        // C s_431_134: const #101808u : u32
        let s_431_134: u32 = 101808;
        // N s_431_135: write-reg s_431_134 <= s_431_133
        let s_431_135: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_134 as isize, s_431_133);
            tracer.write_register(s_431_134 as isize, s_431_133);
        };
        // C s_431_136: const #101808u : u32
        let s_431_136: u32 = 101808;
        // D s_431_137: read-reg s_431_136:struct
        let s_431_137: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_136 as isize);
            tracer.read_register(s_431_136 as isize, value);
            value
        };
        // C s_431_138: const #101808u : u32
        let s_431_138: u32 = 101808;
        // N s_431_139: write-reg s_431_138 <= s_431_137
        let s_431_139: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_138 as isize, s_431_137);
            tracer.write_register(s_431_138 as isize, s_431_137);
        };
        // C s_431_140: const #20392u : u32
        let s_431_140: u32 = 20392;
        // D s_431_141: read-reg s_431_140:struct
        let s_431_141: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_140 as isize);
            tracer.read_register(s_431_140 as isize, value);
            value
        };
        // C s_431_142: const #20392u : u32
        let s_431_142: u32 = 20392;
        // N s_431_143: write-reg s_431_142 <= s_431_141
        let s_431_143: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_142 as isize, s_431_141);
            tracer.write_register(s_431_142 as isize, s_431_141);
        };
        // C s_431_144: const #20392u : u32
        let s_431_144: u32 = 20392;
        // D s_431_145: read-reg s_431_144:struct
        let s_431_145: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_144 as isize);
            tracer.read_register(s_431_144 as isize, value);
            value
        };
        // C s_431_146: const #20392u : u32
        let s_431_146: u32 = 20392;
        // N s_431_147: write-reg s_431_146 <= s_431_145
        let s_431_147: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_146 as isize, s_431_145);
            tracer.write_register(s_431_146 as isize, s_431_145);
        };
        // C s_431_148: const #20392u : u32
        let s_431_148: u32 = 20392;
        // D s_431_149: read-reg s_431_148:struct
        let s_431_149: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_148 as isize);
            tracer.read_register(s_431_148 as isize, value);
            value
        };
        // C s_431_150: const #20392u : u32
        let s_431_150: u32 = 20392;
        // N s_431_151: write-reg s_431_150 <= s_431_149
        let s_431_151: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_150 as isize, s_431_149);
            tracer.write_register(s_431_150 as isize, s_431_149);
        };
        // C s_431_152: const #100864u : u32
        let s_431_152: u32 = 100864;
        // D s_431_153: read-reg s_431_152:struct
        let s_431_153: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_152 as isize);
            tracer.read_register(s_431_152 as isize, value);
            value
        };
        // C s_431_154: const #100864u : u32
        let s_431_154: u32 = 100864;
        // N s_431_155: write-reg s_431_154 <= s_431_153
        let s_431_155: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_154 as isize, s_431_153);
            tracer.write_register(s_431_154 as isize, s_431_153);
        };
        // C s_431_156: const #103208u : u32
        let s_431_156: u32 = 103208;
        // D s_431_157: read-reg s_431_156:struct
        let s_431_157: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_156 as isize);
            tracer.read_register(s_431_156 as isize, value);
            value
        };
        // C s_431_158: const #103208u : u32
        let s_431_158: u32 = 103208;
        // N s_431_159: write-reg s_431_158 <= s_431_157
        let s_431_159: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_158 as isize, s_431_157);
            tracer.write_register(s_431_158 as isize, s_431_157);
        };
        // C s_431_160: const #103208u : u32
        let s_431_160: u32 = 103208;
        // D s_431_161: read-reg s_431_160:struct
        let s_431_161: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_160 as isize);
            tracer.read_register(s_431_160 as isize, value);
            value
        };
        // C s_431_162: const #103208u : u32
        let s_431_162: u32 = 103208;
        // N s_431_163: write-reg s_431_162 <= s_431_161
        let s_431_163: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_162 as isize, s_431_161);
            tracer.write_register(s_431_162 as isize, s_431_161);
        };
        // C s_431_164: const #103208u : u32
        let s_431_164: u32 = 103208;
        // D s_431_165: read-reg s_431_164:struct
        let s_431_165: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_164 as isize);
            tracer.read_register(s_431_164 as isize, value);
            value
        };
        // C s_431_166: const #103208u : u32
        let s_431_166: u32 = 103208;
        // N s_431_167: write-reg s_431_166 <= s_431_165
        let s_431_167: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_166 as isize, s_431_165);
            tracer.write_register(s_431_166 as isize, s_431_165);
        };
        // C s_431_168: const #0u : u8
        let s_431_168: bool = false;
        // S s_431_169: call Bit(s_431_168)
        let s_431_169: bool = Bit(state, tracer, s_431_168);
        // C s_431_170: const #103208u : u32
        let s_431_170: u32 = 103208;
        // D s_431_171: read-reg s_431_170:struct
        let s_431_171: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_170 as isize);
            tracer.read_register(s_431_170 as isize, value);
            value
        };
        // C s_431_172: const #103208u : u32
        let s_431_172: u32 = 103208;
        // N s_431_173: write-reg s_431_172 <= s_431_171
        let s_431_173: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_172 as isize, s_431_171);
            tracer.write_register(s_431_172 as isize, s_431_171);
        };
        // C s_431_174: const #12000u : u32
        let s_431_174: u32 = 12000;
        // D s_431_175: read-reg s_431_174:struct
        let s_431_175: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_174 as isize);
            tracer.read_register(s_431_174 as isize, value);
            value
        };
        // C s_431_176: const #12000u : u32
        let s_431_176: u32 = 12000;
        // N s_431_177: write-reg s_431_176 <= s_431_175
        let s_431_177: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_176 as isize, s_431_175);
            tracer.write_register(s_431_176 as isize, s_431_175);
        };
        // C s_431_178: const #102608u : u32
        let s_431_178: u32 = 102608;
        // D s_431_179: read-reg s_431_178:struct
        let s_431_179: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_178 as isize);
            tracer.read_register(s_431_178 as isize, value);
            value
        };
        // C s_431_180: const #102608u : u32
        let s_431_180: u32 = 102608;
        // N s_431_181: write-reg s_431_180 <= s_431_179
        let s_431_181: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_180 as isize, s_431_179);
            tracer.write_register(s_431_180 as isize, s_431_179);
        };
        // C s_431_182: const #91120u : u32
        let s_431_182: u32 = 91120;
        // D s_431_183: read-reg s_431_182:struct
        let s_431_183: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_182 as isize);
            tracer.read_register(s_431_182 as isize, value);
            value
        };
        // C s_431_184: const #91120u : u32
        let s_431_184: u32 = 91120;
        // N s_431_185: write-reg s_431_184 <= s_431_183
        let s_431_185: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_184 as isize, s_431_183);
            tracer.write_register(s_431_184 as isize, s_431_183);
        };
        // C s_431_186: const #91120u : u32
        let s_431_186: u32 = 91120;
        // D s_431_187: read-reg s_431_186:struct
        let s_431_187: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_186 as isize);
            tracer.read_register(s_431_186 as isize, value);
            value
        };
        // C s_431_188: const #91120u : u32
        let s_431_188: u32 = 91120;
        // N s_431_189: write-reg s_431_188 <= s_431_187
        let s_431_189: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_188 as isize, s_431_187);
            tracer.write_register(s_431_188 as isize, s_431_187);
        };
        // C s_431_190: const #91120u : u32
        let s_431_190: u32 = 91120;
        // D s_431_191: read-reg s_431_190:struct
        let s_431_191: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_190 as isize);
            tracer.read_register(s_431_190 as isize, value);
            value
        };
        // C s_431_192: const #91120u : u32
        let s_431_192: u32 = 91120;
        // N s_431_193: write-reg s_431_192 <= s_431_191
        let s_431_193: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_192 as isize, s_431_191);
            tracer.write_register(s_431_192 as isize, s_431_191);
        };
        // C s_431_194: const #91120u : u32
        let s_431_194: u32 = 91120;
        // D s_431_195: read-reg s_431_194:struct
        let s_431_195: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_194 as isize);
            tracer.read_register(s_431_194 as isize, value);
            value
        };
        // C s_431_196: const #91120u : u32
        let s_431_196: u32 = 91120;
        // N s_431_197: write-reg s_431_196 <= s_431_195
        let s_431_197: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_196 as isize, s_431_195);
            tracer.write_register(s_431_196 as isize, s_431_195);
        };
        // C s_431_198: const #91120u : u32
        let s_431_198: u32 = 91120;
        // D s_431_199: read-reg s_431_198:struct
        let s_431_199: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_198 as isize);
            tracer.read_register(s_431_198 as isize, value);
            value
        };
        // C s_431_200: const #91120u : u32
        let s_431_200: u32 = 91120;
        // N s_431_201: write-reg s_431_200 <= s_431_199
        let s_431_201: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_200 as isize, s_431_199);
            tracer.write_register(s_431_200 as isize, s_431_199);
        };
        // C s_431_202: const #91120u : u32
        let s_431_202: u32 = 91120;
        // D s_431_203: read-reg s_431_202:struct
        let s_431_203: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_202 as isize);
            tracer.read_register(s_431_202 as isize, value);
            value
        };
        // C s_431_204: const #91120u : u32
        let s_431_204: u32 = 91120;
        // N s_431_205: write-reg s_431_204 <= s_431_203
        let s_431_205: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_204 as isize, s_431_203);
            tracer.write_register(s_431_204 as isize, s_431_203);
        };
        // C s_431_206: const #91120u : u32
        let s_431_206: u32 = 91120;
        // D s_431_207: read-reg s_431_206:struct
        let s_431_207: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_206 as isize);
            tracer.read_register(s_431_206 as isize, value);
            value
        };
        // C s_431_208: const #91120u : u32
        let s_431_208: u32 = 91120;
        // N s_431_209: write-reg s_431_208 <= s_431_207
        let s_431_209: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_208 as isize, s_431_207);
            tracer.write_register(s_431_208 as isize, s_431_207);
        };
        // C s_431_210: const #91120u : u32
        let s_431_210: u32 = 91120;
        // D s_431_211: read-reg s_431_210:struct
        let s_431_211: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_210 as isize);
            tracer.read_register(s_431_210 as isize, value);
            value
        };
        // C s_431_212: const #91120u : u32
        let s_431_212: u32 = 91120;
        // N s_431_213: write-reg s_431_212 <= s_431_211
        let s_431_213: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_212 as isize, s_431_211);
            tracer.write_register(s_431_212 as isize, s_431_211);
        };
        // C s_431_214: const #91120u : u32
        let s_431_214: u32 = 91120;
        // D s_431_215: read-reg s_431_214:struct
        let s_431_215: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_214 as isize);
            tracer.read_register(s_431_214 as isize, value);
            value
        };
        // C s_431_216: const #91120u : u32
        let s_431_216: u32 = 91120;
        // N s_431_217: write-reg s_431_216 <= s_431_215
        let s_431_217: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_216 as isize, s_431_215);
            tracer.write_register(s_431_216 as isize, s_431_215);
        };
        // C s_431_218: const #91120u : u32
        let s_431_218: u32 = 91120;
        // D s_431_219: read-reg s_431_218:struct
        let s_431_219: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_218 as isize);
            tracer.read_register(s_431_218 as isize, value);
            value
        };
        // C s_431_220: const #91120u : u32
        let s_431_220: u32 = 91120;
        // N s_431_221: write-reg s_431_220 <= s_431_219
        let s_431_221: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_220 as isize, s_431_219);
            tracer.write_register(s_431_220 as isize, s_431_219);
        };
        // C s_431_222: const #91120u : u32
        let s_431_222: u32 = 91120;
        // D s_431_223: read-reg s_431_222:struct
        let s_431_223: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_222 as isize);
            tracer.read_register(s_431_222 as isize, value);
            value
        };
        // C s_431_224: const #91120u : u32
        let s_431_224: u32 = 91120;
        // N s_431_225: write-reg s_431_224 <= s_431_223
        let s_431_225: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_224 as isize, s_431_223);
            tracer.write_register(s_431_224 as isize, s_431_223);
        };
        // C s_431_226: const #91120u : u32
        let s_431_226: u32 = 91120;
        // D s_431_227: read-reg s_431_226:struct
        let s_431_227: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_226 as isize);
            tracer.read_register(s_431_226 as isize, value);
            value
        };
        // C s_431_228: const #91120u : u32
        let s_431_228: u32 = 91120;
        // N s_431_229: write-reg s_431_228 <= s_431_227
        let s_431_229: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_228 as isize, s_431_227);
            tracer.write_register(s_431_228 as isize, s_431_227);
        };
        // C s_431_230: const #91120u : u32
        let s_431_230: u32 = 91120;
        // D s_431_231: read-reg s_431_230:struct
        let s_431_231: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_230 as isize);
            tracer.read_register(s_431_230 as isize, value);
            value
        };
        // C s_431_232: const #91120u : u32
        let s_431_232: u32 = 91120;
        // N s_431_233: write-reg s_431_232 <= s_431_231
        let s_431_233: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_232 as isize, s_431_231);
            tracer.write_register(s_431_232 as isize, s_431_231);
        };
        // C s_431_234: const #91120u : u32
        let s_431_234: u32 = 91120;
        // D s_431_235: read-reg s_431_234:struct
        let s_431_235: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_234 as isize);
            tracer.read_register(s_431_234 as isize, value);
            value
        };
        // C s_431_236: const #91120u : u32
        let s_431_236: u32 = 91120;
        // N s_431_237: write-reg s_431_236 <= s_431_235
        let s_431_237: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_236 as isize, s_431_235);
            tracer.write_register(s_431_236 as isize, s_431_235);
        };
        // C s_431_238: const #91120u : u32
        let s_431_238: u32 = 91120;
        // D s_431_239: read-reg s_431_238:struct
        let s_431_239: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_238 as isize);
            tracer.read_register(s_431_238 as isize, value);
            value
        };
        // C s_431_240: const #91120u : u32
        let s_431_240: u32 = 91120;
        // N s_431_241: write-reg s_431_240 <= s_431_239
        let s_431_241: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_240 as isize, s_431_239);
            tracer.write_register(s_431_240 as isize, s_431_239);
        };
        // C s_431_242: const #91120u : u32
        let s_431_242: u32 = 91120;
        // D s_431_243: read-reg s_431_242:struct
        let s_431_243: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_242 as isize);
            tracer.read_register(s_431_242 as isize, value);
            value
        };
        // C s_431_244: const #91120u : u32
        let s_431_244: u32 = 91120;
        // N s_431_245: write-reg s_431_244 <= s_431_243
        let s_431_245: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_244 as isize, s_431_243);
            tracer.write_register(s_431_244 as isize, s_431_243);
        };
        // C s_431_246: const #91120u : u32
        let s_431_246: u32 = 91120;
        // D s_431_247: read-reg s_431_246:struct
        let s_431_247: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_246 as isize);
            tracer.read_register(s_431_246 as isize, value);
            value
        };
        // C s_431_248: const #91120u : u32
        let s_431_248: u32 = 91120;
        // N s_431_249: write-reg s_431_248 <= s_431_247
        let s_431_249: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_248 as isize, s_431_247);
            tracer.write_register(s_431_248 as isize, s_431_247);
        };
        // C s_431_250: const #91120u : u32
        let s_431_250: u32 = 91120;
        // D s_431_251: read-reg s_431_250:struct
        let s_431_251: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_250 as isize);
            tracer.read_register(s_431_250 as isize, value);
            value
        };
        // C s_431_252: const #91120u : u32
        let s_431_252: u32 = 91120;
        // N s_431_253: write-reg s_431_252 <= s_431_251
        let s_431_253: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_252 as isize, s_431_251);
            tracer.write_register(s_431_252 as isize, s_431_251);
        };
        // C s_431_254: const #91120u : u32
        let s_431_254: u32 = 91120;
        // D s_431_255: read-reg s_431_254:struct
        let s_431_255: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_254 as isize);
            tracer.read_register(s_431_254 as isize, value);
            value
        };
        // C s_431_256: const #91120u : u32
        let s_431_256: u32 = 91120;
        // N s_431_257: write-reg s_431_256 <= s_431_255
        let s_431_257: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_256 as isize, s_431_255);
            tracer.write_register(s_431_256 as isize, s_431_255);
        };
        // C s_431_258: const #91120u : u32
        let s_431_258: u32 = 91120;
        // D s_431_259: read-reg s_431_258:struct
        let s_431_259: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_258 as isize);
            tracer.read_register(s_431_258 as isize, value);
            value
        };
        // C s_431_260: const #91120u : u32
        let s_431_260: u32 = 91120;
        // N s_431_261: write-reg s_431_260 <= s_431_259
        let s_431_261: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_260 as isize, s_431_259);
            tracer.write_register(s_431_260 as isize, s_431_259);
        };
        // C s_431_262: const #91120u : u32
        let s_431_262: u32 = 91120;
        // D s_431_263: read-reg s_431_262:struct
        let s_431_263: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_262 as isize);
            tracer.read_register(s_431_262 as isize, value);
            value
        };
        // C s_431_264: const #91120u : u32
        let s_431_264: u32 = 91120;
        // N s_431_265: write-reg s_431_264 <= s_431_263
        let s_431_265: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_264 as isize, s_431_263);
            tracer.write_register(s_431_264 as isize, s_431_263);
        };
        // C s_431_266: const #91120u : u32
        let s_431_266: u32 = 91120;
        // D s_431_267: read-reg s_431_266:struct
        let s_431_267: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_266 as isize);
            tracer.read_register(s_431_266 as isize, value);
            value
        };
        // C s_431_268: const #91120u : u32
        let s_431_268: u32 = 91120;
        // N s_431_269: write-reg s_431_268 <= s_431_267
        let s_431_269: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_268 as isize, s_431_267);
            tracer.write_register(s_431_268 as isize, s_431_267);
        };
        // C s_431_270: const #91120u : u32
        let s_431_270: u32 = 91120;
        // D s_431_271: read-reg s_431_270:struct
        let s_431_271: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_270 as isize);
            tracer.read_register(s_431_270 as isize, value);
            value
        };
        // C s_431_272: const #91120u : u32
        let s_431_272: u32 = 91120;
        // N s_431_273: write-reg s_431_272 <= s_431_271
        let s_431_273: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_272 as isize, s_431_271);
            tracer.write_register(s_431_272 as isize, s_431_271);
        };
        // C s_431_274: const #91120u : u32
        let s_431_274: u32 = 91120;
        // D s_431_275: read-reg s_431_274:struct
        let s_431_275: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_274 as isize);
            tracer.read_register(s_431_274 as isize, value);
            value
        };
        // C s_431_276: const #91120u : u32
        let s_431_276: u32 = 91120;
        // N s_431_277: write-reg s_431_276 <= s_431_275
        let s_431_277: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_276 as isize, s_431_275);
            tracer.write_register(s_431_276 as isize, s_431_275);
        };
        // C s_431_278: const #91120u : u32
        let s_431_278: u32 = 91120;
        // D s_431_279: read-reg s_431_278:struct
        let s_431_279: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_278 as isize);
            tracer.read_register(s_431_278 as isize, value);
            value
        };
        // C s_431_280: const #91120u : u32
        let s_431_280: u32 = 91120;
        // N s_431_281: write-reg s_431_280 <= s_431_279
        let s_431_281: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_280 as isize, s_431_279);
            tracer.write_register(s_431_280 as isize, s_431_279);
        };
        // C s_431_282: const #91120u : u32
        let s_431_282: u32 = 91120;
        // D s_431_283: read-reg s_431_282:struct
        let s_431_283: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_282 as isize);
            tracer.read_register(s_431_282 as isize, value);
            value
        };
        // C s_431_284: const #91120u : u32
        let s_431_284: u32 = 91120;
        // N s_431_285: write-reg s_431_284 <= s_431_283
        let s_431_285: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_284 as isize, s_431_283);
            tracer.write_register(s_431_284 as isize, s_431_283);
        };
        // C s_431_286: const #91120u : u32
        let s_431_286: u32 = 91120;
        // D s_431_287: read-reg s_431_286:struct
        let s_431_287: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_286 as isize);
            tracer.read_register(s_431_286 as isize, value);
            value
        };
        // C s_431_288: const #91120u : u32
        let s_431_288: u32 = 91120;
        // N s_431_289: write-reg s_431_288 <= s_431_287
        let s_431_289: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_288 as isize, s_431_287);
            tracer.write_register(s_431_288 as isize, s_431_287);
        };
        // C s_431_290: const #91120u : u32
        let s_431_290: u32 = 91120;
        // D s_431_291: read-reg s_431_290:struct
        let s_431_291: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_290 as isize);
            tracer.read_register(s_431_290 as isize, value);
            value
        };
        // C s_431_292: const #91120u : u32
        let s_431_292: u32 = 91120;
        // N s_431_293: write-reg s_431_292 <= s_431_291
        let s_431_293: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_292 as isize, s_431_291);
            tracer.write_register(s_431_292 as isize, s_431_291);
        };
        // C s_431_294: const #91120u : u32
        let s_431_294: u32 = 91120;
        // D s_431_295: read-reg s_431_294:struct
        let s_431_295: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_294 as isize);
            tracer.read_register(s_431_294 as isize, value);
            value
        };
        // C s_431_296: const #91120u : u32
        let s_431_296: u32 = 91120;
        // N s_431_297: write-reg s_431_296 <= s_431_295
        let s_431_297: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_296 as isize, s_431_295);
            tracer.write_register(s_431_296 as isize, s_431_295);
        };
        // C s_431_298: const #91120u : u32
        let s_431_298: u32 = 91120;
        // D s_431_299: read-reg s_431_298:struct
        let s_431_299: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_298 as isize);
            tracer.read_register(s_431_298 as isize, value);
            value
        };
        // C s_431_300: const #91120u : u32
        let s_431_300: u32 = 91120;
        // N s_431_301: write-reg s_431_300 <= s_431_299
        let s_431_301: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_300 as isize, s_431_299);
            tracer.write_register(s_431_300 as isize, s_431_299);
        };
        // C s_431_302: const #91120u : u32
        let s_431_302: u32 = 91120;
        // D s_431_303: read-reg s_431_302:struct
        let s_431_303: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_302 as isize);
            tracer.read_register(s_431_302 as isize, value);
            value
        };
        // C s_431_304: const #91120u : u32
        let s_431_304: u32 = 91120;
        // N s_431_305: write-reg s_431_304 <= s_431_303
        let s_431_305: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_304 as isize, s_431_303);
            tracer.write_register(s_431_304 as isize, s_431_303);
        };
        // C s_431_306: const #91120u : u32
        let s_431_306: u32 = 91120;
        // D s_431_307: read-reg s_431_306:struct
        let s_431_307: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_306 as isize);
            tracer.read_register(s_431_306 as isize, value);
            value
        };
        // C s_431_308: const #91120u : u32
        let s_431_308: u32 = 91120;
        // N s_431_309: write-reg s_431_308 <= s_431_307
        let s_431_309: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_308 as isize, s_431_307);
            tracer.write_register(s_431_308 as isize, s_431_307);
        };
        // C s_431_310: const #104944u : u32
        let s_431_310: u32 = 104944;
        // D s_431_311: read-reg s_431_310:struct
        let s_431_311: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_310 as isize);
            tracer.read_register(s_431_310 as isize, value);
            value
        };
        // C s_431_312: const #104944u : u32
        let s_431_312: u32 = 104944;
        // N s_431_313: write-reg s_431_312 <= s_431_311
        let s_431_313: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_312 as isize, s_431_311);
            tracer.write_register(s_431_312 as isize, s_431_311);
        };
        // C s_431_314: const #11008u : u32
        let s_431_314: u32 = 11008;
        // D s_431_315: read-reg s_431_314:struct
        let s_431_315: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_314 as isize);
            tracer.read_register(s_431_314 as isize, value);
            value
        };
        // C s_431_316: const #11008u : u32
        let s_431_316: u32 = 11008;
        // N s_431_317: write-reg s_431_316 <= s_431_315
        let s_431_317: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_316 as isize, s_431_315);
            tracer.write_register(s_431_316 as isize, s_431_315);
        };
        // C s_431_318: const #11008u : u32
        let s_431_318: u32 = 11008;
        // D s_431_319: read-reg s_431_318:struct
        let s_431_319: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_318 as isize);
            tracer.read_register(s_431_318 as isize, value);
            value
        };
        // C s_431_320: const #11008u : u32
        let s_431_320: u32 = 11008;
        // N s_431_321: write-reg s_431_320 <= s_431_319
        let s_431_321: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_320 as isize, s_431_319);
            tracer.write_register(s_431_320 as isize, s_431_319);
        };
        // C s_431_322: const #102728u : u32
        let s_431_322: u32 = 102728;
        // D s_431_323: read-reg s_431_322:struct
        let s_431_323: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_322 as isize);
            tracer.read_register(s_431_322 as isize, value);
            value
        };
        // C s_431_324: const #102728u : u32
        let s_431_324: u32 = 102728;
        // N s_431_325: write-reg s_431_324 <= s_431_323
        let s_431_325: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_324 as isize, s_431_323);
            tracer.write_register(s_431_324 as isize, s_431_323);
        };
        // C s_431_326: const #23432u : u32
        let s_431_326: u32 = 23432;
        // D s_431_327: read-reg s_431_326:struct
        let s_431_327: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_326 as isize);
            tracer.read_register(s_431_326 as isize, value);
            value
        };
        // C s_431_328: const #23432u : u32
        let s_431_328: u32 = 23432;
        // N s_431_329: write-reg s_431_328 <= s_431_327
        let s_431_329: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_328 as isize, s_431_327);
            tracer.write_register(s_431_328 as isize, s_431_327);
        };
        // C s_431_330: const #23432u : u32
        let s_431_330: u32 = 23432;
        // D s_431_331: read-reg s_431_330:struct
        let s_431_331: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_330 as isize);
            tracer.read_register(s_431_330 as isize, value);
            value
        };
        // C s_431_332: const #23432u : u32
        let s_431_332: u32 = 23432;
        // N s_431_333: write-reg s_431_332 <= s_431_331
        let s_431_333: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_332 as isize, s_431_331);
            tracer.write_register(s_431_332 as isize, s_431_331);
        };
        // C s_431_334: const #15288u : u32
        let s_431_334: u32 = 15288;
        // D s_431_335: read-reg s_431_334:struct
        let s_431_335: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_334 as isize);
            tracer.read_register(s_431_334 as isize, value);
            value
        };
        // C s_431_336: const #15288u : u32
        let s_431_336: u32 = 15288;
        // N s_431_337: write-reg s_431_336 <= s_431_335
        let s_431_337: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_336 as isize, s_431_335);
            tracer.write_register(s_431_336 as isize, s_431_335);
        };
        // C s_431_338: const #102376u : u32
        let s_431_338: u32 = 102376;
        // D s_431_339: read-reg s_431_338:struct
        let s_431_339: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_338 as isize);
            tracer.read_register(s_431_338 as isize, value);
            value
        };
        // C s_431_340: const #102376u : u32
        let s_431_340: u32 = 102376;
        // N s_431_341: write-reg s_431_340 <= s_431_339
        let s_431_341: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_340 as isize, s_431_339);
            tracer.write_register(s_431_340 as isize, s_431_339);
        };
        // C s_431_342: const #20512u : u32
        let s_431_342: u32 = 20512;
        // D s_431_343: read-reg s_431_342:struct
        let s_431_343: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_342 as isize);
            tracer.read_register(s_431_342 as isize, value);
            value
        };
        // C s_431_344: const #20512u : u32
        let s_431_344: u32 = 20512;
        // N s_431_345: write-reg s_431_344 <= s_431_343
        let s_431_345: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_344 as isize, s_431_343);
            tracer.write_register(s_431_344 as isize, s_431_343);
        };
        // C s_431_346: const #17056u : u32
        let s_431_346: u32 = 17056;
        // D s_431_347: read-reg s_431_346:struct
        let s_431_347: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_346 as isize);
            tracer.read_register(s_431_346 as isize, value);
            value
        };
        // C s_431_348: const #17056u : u32
        let s_431_348: u32 = 17056;
        // N s_431_349: write-reg s_431_348 <= s_431_347
        let s_431_349: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_348 as isize, s_431_347);
            tracer.write_register(s_431_348 as isize, s_431_347);
        };
        // C s_431_350: const #17056u : u32
        let s_431_350: u32 = 17056;
        // D s_431_351: read-reg s_431_350:struct
        let s_431_351: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_350 as isize);
            tracer.read_register(s_431_350 as isize, value);
            value
        };
        // C s_431_352: const #17056u : u32
        let s_431_352: u32 = 17056;
        // N s_431_353: write-reg s_431_352 <= s_431_351
        let s_431_353: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_352 as isize, s_431_351);
            tracer.write_register(s_431_352 as isize, s_431_351);
        };
        // C s_431_354: const #18976u : u32
        let s_431_354: u32 = 18976;
        // D s_431_355: read-reg s_431_354:struct
        let s_431_355: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_354 as isize);
            tracer.read_register(s_431_354 as isize, value);
            value
        };
        // C s_431_356: const #18976u : u32
        let s_431_356: u32 = 18976;
        // N s_431_357: write-reg s_431_356 <= s_431_355
        let s_431_357: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_356 as isize, s_431_355);
            tracer.write_register(s_431_356 as isize, s_431_355);
        };
        // C s_431_358: const #18976u : u32
        let s_431_358: u32 = 18976;
        // D s_431_359: read-reg s_431_358:struct
        let s_431_359: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_358 as isize);
            tracer.read_register(s_431_358 as isize, value);
            value
        };
        // C s_431_360: const #18976u : u32
        let s_431_360: u32 = 18976;
        // N s_431_361: write-reg s_431_360 <= s_431_359
        let s_431_361: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_360 as isize, s_431_359);
            tracer.write_register(s_431_360 as isize, s_431_359);
        };
        // C s_431_362: const #16880u : u32
        let s_431_362: u32 = 16880;
        // D s_431_363: read-reg s_431_362:struct
        let s_431_363: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_362 as isize);
            tracer.read_register(s_431_362 as isize, value);
            value
        };
        // C s_431_364: const #16880u : u32
        let s_431_364: u32 = 16880;
        // N s_431_365: write-reg s_431_364 <= s_431_363
        let s_431_365: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_364 as isize, s_431_363);
            tracer.write_register(s_431_364 as isize, s_431_363);
        };
        // C s_431_366: const #15280u : u32
        let s_431_366: u32 = 15280;
        // D s_431_367: read-reg s_431_366:struct
        let s_431_367: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_366 as isize);
            tracer.read_register(s_431_366 as isize, value);
            value
        };
        // C s_431_368: const #15280u : u32
        let s_431_368: u32 = 15280;
        // N s_431_369: write-reg s_431_368 <= s_431_367
        let s_431_369: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_368 as isize, s_431_367);
            tracer.write_register(s_431_368 as isize, s_431_367);
        };
        // C s_431_370: const #11056u : u32
        let s_431_370: u32 = 11056;
        // D s_431_371: read-reg s_431_370:struct
        let s_431_371: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_370 as isize);
            tracer.read_register(s_431_370 as isize, value);
            value
        };
        // C s_431_372: const #11056u : u32
        let s_431_372: u32 = 11056;
        // N s_431_373: write-reg s_431_372 <= s_431_371
        let s_431_373: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_372 as isize, s_431_371);
            tracer.write_register(s_431_372 as isize, s_431_371);
        };
        // C s_431_374: const #13512u : u32
        let s_431_374: u32 = 13512;
        // D s_431_375: read-reg s_431_374:struct
        let s_431_375: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_374 as isize);
            tracer.read_register(s_431_374 as isize, value);
            value
        };
        // C s_431_376: const #13512u : u32
        let s_431_376: u32 = 13512;
        // N s_431_377: write-reg s_431_376 <= s_431_375
        let s_431_377: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_376 as isize, s_431_375);
            tracer.write_register(s_431_376 as isize, s_431_375);
        };
        // C s_431_378: const #10080u : u32
        let s_431_378: u32 = 10080;
        // D s_431_379: read-reg s_431_378:struct
        let s_431_379: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_378 as isize);
            tracer.read_register(s_431_378 as isize, value);
            value
        };
        // C s_431_380: const #10080u : u32
        let s_431_380: u32 = 10080;
        // N s_431_381: write-reg s_431_380 <= s_431_379
        let s_431_381: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_380 as isize, s_431_379);
            tracer.write_register(s_431_380 as isize, s_431_379);
        };
        // C s_431_382: const #90488u : u32
        let s_431_382: u32 = 90488;
        // D s_431_383: read-reg s_431_382:struct
        let s_431_383: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_382 as isize);
            tracer.read_register(s_431_382 as isize, value);
            value
        };
        // C s_431_384: const #90488u : u32
        let s_431_384: u32 = 90488;
        // N s_431_385: write-reg s_431_384 <= s_431_383
        let s_431_385: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_384 as isize, s_431_383);
            tracer.write_register(s_431_384 as isize, s_431_383);
        };
        // C s_431_386: const #0s : i
        let s_431_386: i128 = 0;
        // C s_431_387: const #104832u : u32
        let s_431_387: u32 = 104832;
        // D s_431_388: read-reg s_431_387:u32
        let s_431_388: u32 = {
            let value = state.read_register::<u32>(s_431_387 as isize);
            tracer.read_register(s_431_387 as isize, value);
            value
        };
        // D s_431_389: cast zx s_431_388 -> bv
        let s_431_389: Bits = Bits::new(s_431_388 as u128, 32u16);
        // C s_431_390: const #0u : u32
        let s_431_390: u32 = 0;
        // C s_431_391: cast zx s_431_390 -> bv
        let s_431_391: Bits = Bits::new(s_431_390 as u128, 32u16);
        // C s_431_392: const #31s : i
        let s_431_392: i128 = 31;
        // C s_431_393: const #1u : u64
        let s_431_393: u64 = 1;
        // C s_431_394: cast zx s_431_393 -> bv
        let s_431_394: Bits = Bits::new(s_431_393 as u128, 64u16);
        // C s_431_395: lsl s_431_394 s_431_392
        let s_431_395: Bits = s_431_394 << s_431_392;
        // C s_431_396: sub s_431_395 s_431_394
        let s_431_396: Bits = ((s_431_395) - (s_431_394));
        // C s_431_397: and s_431_391 s_431_396
        let s_431_397: Bits = ((s_431_391) & (s_431_396));
        // C s_431_398: lsl s_431_397 s_431_386
        let s_431_398: Bits = s_431_397 << s_431_386;
        // C s_431_399: lsl s_431_396 s_431_386
        let s_431_399: Bits = s_431_396 << s_431_386;
        // C s_431_400: cmpl s_431_399
        let s_431_400: Bits = !s_431_399;
        // D s_431_401: and s_431_389 s_431_400
        let s_431_401: Bits = ((s_431_389) & (s_431_400));
        // D s_431_402: or s_431_401 s_431_398
        let s_431_402: Bits = ((s_431_401) | (s_431_398));
        // D s_431_403: cast reint s_431_402 -> u32
        let s_431_403: u32 = (s_431_402.value() as u32);
        // C s_431_404: const #104832u : u32
        let s_431_404: u32 = 104832;
        // N s_431_405: write-reg s_431_404 <= s_431_403
        let s_431_405: () = {
            state.write_register::<u32>(s_431_404 as isize, s_431_403);
            tracer.write_register(s_431_404 as isize, s_431_403);
        };
        // C s_431_406: const #14440u : u32
        let s_431_406: u32 = 14440;
        // D s_431_407: read-reg s_431_406:struct
        let s_431_407: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_406 as isize);
            tracer.read_register(s_431_406 as isize, value);
            value
        };
        // C s_431_408: const #14440u : u32
        let s_431_408: u32 = 14440;
        // N s_431_409: write-reg s_431_408 <= s_431_407
        let s_431_409: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_408 as isize, s_431_407);
            tracer.write_register(s_431_408 as isize, s_431_407);
        };
        // C s_431_410: const #1640u : u32
        let s_431_410: u32 = 1640;
        // D s_431_411: read-reg s_431_410:struct
        let s_431_411: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_410 as isize);
            tracer.read_register(s_431_410 as isize, value);
            value
        };
        // C s_431_412: const #1640u : u32
        let s_431_412: u32 = 1640;
        // N s_431_413: write-reg s_431_412 <= s_431_411
        let s_431_413: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_412 as isize, s_431_411);
            tracer.write_register(s_431_412 as isize, s_431_411);
        };
        // C s_431_414: const #22704u : u32
        let s_431_414: u32 = 22704;
        // D s_431_415: read-reg s_431_414:struct
        let s_431_415: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_414 as isize);
            tracer.read_register(s_431_414 as isize, value);
            value
        };
        // C s_431_416: const #22704u : u32
        let s_431_416: u32 = 22704;
        // N s_431_417: write-reg s_431_416 <= s_431_415
        let s_431_417: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_416 as isize, s_431_415);
            tracer.write_register(s_431_416 as isize, s_431_415);
        };
        // C s_431_418: const #15896u : u32
        let s_431_418: u32 = 15896;
        // D s_431_419: read-reg s_431_418:struct
        let s_431_419: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_418 as isize);
            tracer.read_register(s_431_418 as isize, value);
            value
        };
        // C s_431_420: const #15896u : u32
        let s_431_420: u32 = 15896;
        // N s_431_421: write-reg s_431_420 <= s_431_419
        let s_431_421: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_420 as isize, s_431_419);
            tracer.write_register(s_431_420 as isize, s_431_419);
        };
        // C s_431_422: const #23904u : u32
        let s_431_422: u32 = 23904;
        // D s_431_423: read-reg s_431_422:struct
        let s_431_423: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_422 as isize);
            tracer.read_register(s_431_422 as isize, value);
            value
        };
        // C s_431_424: const #23904u : u32
        let s_431_424: u32 = 23904;
        // N s_431_425: write-reg s_431_424 <= s_431_423
        let s_431_425: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_424 as isize, s_431_423);
            tracer.write_register(s_431_424 as isize, s_431_423);
        };
        // C s_431_426: const #20264u : u32
        let s_431_426: u32 = 20264;
        // D s_431_427: read-reg s_431_426:struct
        let s_431_427: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_426 as isize);
            tracer.read_register(s_431_426 as isize, value);
            value
        };
        // C s_431_428: const #20264u : u32
        let s_431_428: u32 = 20264;
        // N s_431_429: write-reg s_431_428 <= s_431_427
        let s_431_429: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_428 as isize, s_431_427);
            tracer.write_register(s_431_428 as isize, s_431_427);
        };
        // C s_431_430: const #13232u : u32
        let s_431_430: u32 = 13232;
        // D s_431_431: read-reg s_431_430:struct
        let s_431_431: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_430 as isize);
            tracer.read_register(s_431_430 as isize, value);
            value
        };
        // C s_431_432: const #13232u : u32
        let s_431_432: u32 = 13232;
        // N s_431_433: write-reg s_431_432 <= s_431_431
        let s_431_433: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_432 as isize, s_431_431);
            tracer.write_register(s_431_432 as isize, s_431_431);
        };
        // C s_431_434: const #13232u : u32
        let s_431_434: u32 = 13232;
        // D s_431_435: read-reg s_431_434:struct
        let s_431_435: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_434 as isize);
            tracer.read_register(s_431_434 as isize, value);
            value
        };
        // C s_431_436: const #13232u : u32
        let s_431_436: u32 = 13232;
        // N s_431_437: write-reg s_431_436 <= s_431_435
        let s_431_437: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_436 as isize, s_431_435);
            tracer.write_register(s_431_436 as isize, s_431_435);
        };
        // C s_431_438: const #13232u : u32
        let s_431_438: u32 = 13232;
        // D s_431_439: read-reg s_431_438:struct
        let s_431_439: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_438 as isize);
            tracer.read_register(s_431_438 as isize, value);
            value
        };
        // C s_431_440: const #13232u : u32
        let s_431_440: u32 = 13232;
        // N s_431_441: write-reg s_431_440 <= s_431_439
        let s_431_441: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_440 as isize, s_431_439);
            tracer.write_register(s_431_440 as isize, s_431_439);
        };
        // C s_431_442: const #13232u : u32
        let s_431_442: u32 = 13232;
        // D s_431_443: read-reg s_431_442:struct
        let s_431_443: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_442 as isize);
            tracer.read_register(s_431_442 as isize, value);
            value
        };
        // C s_431_444: const #13232u : u32
        let s_431_444: u32 = 13232;
        // N s_431_445: write-reg s_431_444 <= s_431_443
        let s_431_445: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_444 as isize, s_431_443);
            tracer.write_register(s_431_444 as isize, s_431_443);
        };
        // C s_431_446: const #13232u : u32
        let s_431_446: u32 = 13232;
        // D s_431_447: read-reg s_431_446:struct
        let s_431_447: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_446 as isize);
            tracer.read_register(s_431_446 as isize, value);
            value
        };
        // C s_431_448: const #13232u : u32
        let s_431_448: u32 = 13232;
        // N s_431_449: write-reg s_431_448 <= s_431_447
        let s_431_449: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_448 as isize, s_431_447);
            tracer.write_register(s_431_448 as isize, s_431_447);
        };
        // C s_431_450: const #13232u : u32
        let s_431_450: u32 = 13232;
        // D s_431_451: read-reg s_431_450:struct
        let s_431_451: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_450 as isize);
            tracer.read_register(s_431_450 as isize, value);
            value
        };
        // C s_431_452: const #13232u : u32
        let s_431_452: u32 = 13232;
        // N s_431_453: write-reg s_431_452 <= s_431_451
        let s_431_453: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_452 as isize, s_431_451);
            tracer.write_register(s_431_452 as isize, s_431_451);
        };
        // C s_431_454: const #103392u : u32
        let s_431_454: u32 = 103392;
        // D s_431_455: read-reg s_431_454:struct
        let s_431_455: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_454 as isize);
            tracer.read_register(s_431_454 as isize, value);
            value
        };
        // C s_431_456: const #103392u : u32
        let s_431_456: u32 = 103392;
        // N s_431_457: write-reg s_431_456 <= s_431_455
        let s_431_457: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_456 as isize, s_431_455);
            tracer.write_register(s_431_456 as isize, s_431_455);
        };
        // C s_431_458: const #10040u : u32
        let s_431_458: u32 = 10040;
        // D s_431_459: read-reg s_431_458:struct
        let s_431_459: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_458 as isize);
            tracer.read_register(s_431_458 as isize, value);
            value
        };
        // C s_431_460: const #10040u : u32
        let s_431_460: u32 = 10040;
        // N s_431_461: write-reg s_431_460 <= s_431_459
        let s_431_461: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_460 as isize, s_431_459);
            tracer.write_register(s_431_460 as isize, s_431_459);
        };
        // C s_431_462: const #102296u : u32
        let s_431_462: u32 = 102296;
        // D s_431_463: read-reg s_431_462:struct
        let s_431_463: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_462 as isize);
            tracer.read_register(s_431_462 as isize, value);
            value
        };
        // C s_431_464: const #102296u : u32
        let s_431_464: u32 = 102296;
        // N s_431_465: write-reg s_431_464 <= s_431_463
        let s_431_465: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_464 as isize, s_431_463);
            tracer.write_register(s_431_464 as isize, s_431_463);
        };
        // C s_431_466: const #102296u : u32
        let s_431_466: u32 = 102296;
        // D s_431_467: read-reg s_431_466:struct
        let s_431_467: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_466 as isize);
            tracer.read_register(s_431_466 as isize, value);
            value
        };
        // C s_431_468: const #102296u : u32
        let s_431_468: u32 = 102296;
        // N s_431_469: write-reg s_431_468 <= s_431_467
        let s_431_469: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_468 as isize, s_431_467);
            tracer.write_register(s_431_468 as isize, s_431_467);
        };
        // C s_431_470: const #102296u : u32
        let s_431_470: u32 = 102296;
        // D s_431_471: read-reg s_431_470:struct
        let s_431_471: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_470 as isize);
            tracer.read_register(s_431_470 as isize, value);
            value
        };
        // C s_431_472: const #102296u : u32
        let s_431_472: u32 = 102296;
        // N s_431_473: write-reg s_431_472 <= s_431_471
        let s_431_473: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_472 as isize, s_431_471);
            tracer.write_register(s_431_472 as isize, s_431_471);
        };
        // C s_431_474: const #102296u : u32
        let s_431_474: u32 = 102296;
        // D s_431_475: read-reg s_431_474:struct
        let s_431_475: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_474 as isize);
            tracer.read_register(s_431_474 as isize, value);
            value
        };
        // C s_431_476: const #102296u : u32
        let s_431_476: u32 = 102296;
        // N s_431_477: write-reg s_431_476 <= s_431_475
        let s_431_477: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_476 as isize, s_431_475);
            tracer.write_register(s_431_476 as isize, s_431_475);
        };
        // C s_431_478: const #16576u : u32
        let s_431_478: u32 = 16576;
        // D s_431_479: read-reg s_431_478:struct
        let s_431_479: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_478 as isize);
            tracer.read_register(s_431_478 as isize, value);
            value
        };
        // C s_431_480: const #16576u : u32
        let s_431_480: u32 = 16576;
        // N s_431_481: write-reg s_431_480 <= s_431_479
        let s_431_481: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_480 as isize, s_431_479);
            tracer.write_register(s_431_480 as isize, s_431_479);
        };
        // C s_431_482: const #10056u : u32
        let s_431_482: u32 = 10056;
        // D s_431_483: read-reg s_431_482:struct
        let s_431_483: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_482 as isize);
            tracer.read_register(s_431_482 as isize, value);
            value
        };
        // C s_431_484: const #10056u : u32
        let s_431_484: u32 = 10056;
        // N s_431_485: write-reg s_431_484 <= s_431_483
        let s_431_485: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_484 as isize, s_431_483);
            tracer.write_register(s_431_484 as isize, s_431_483);
        };
        // C s_431_486: const #19000u : u32
        let s_431_486: u32 = 19000;
        // D s_431_487: read-reg s_431_486:struct
        let s_431_487: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_486 as isize);
            tracer.read_register(s_431_486 as isize, value);
            value
        };
        // C s_431_488: const #19000u : u32
        let s_431_488: u32 = 19000;
        // N s_431_489: write-reg s_431_488 <= s_431_487
        let s_431_489: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_488 as isize, s_431_487);
            tracer.write_register(s_431_488 as isize, s_431_487);
        };
        // C s_431_490: const #12968u : u32
        let s_431_490: u32 = 12968;
        // D s_431_491: read-reg s_431_490:struct
        let s_431_491: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_490 as isize);
            tracer.read_register(s_431_490 as isize, value);
            value
        };
        // C s_431_492: const #12968u : u32
        let s_431_492: u32 = 12968;
        // N s_431_493: write-reg s_431_492 <= s_431_491
        let s_431_493: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_492 as isize, s_431_491);
            tracer.write_register(s_431_492 as isize, s_431_491);
        };
        // C s_431_494: const #90752u : u32
        let s_431_494: u32 = 90752;
        // D s_431_495: read-reg s_431_494:struct
        let s_431_495: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_494 as isize);
            tracer.read_register(s_431_494 as isize, value);
            value
        };
        // C s_431_496: const #90752u : u32
        let s_431_496: u32 = 90752;
        // N s_431_497: write-reg s_431_496 <= s_431_495
        let s_431_497: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_496 as isize, s_431_495);
            tracer.write_register(s_431_496 as isize, s_431_495);
        };
        // C s_431_498: const #21872u : u32
        let s_431_498: u32 = 21872;
        // D s_431_499: read-reg s_431_498:struct
        let s_431_499: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_498 as isize);
            tracer.read_register(s_431_498 as isize, value);
            value
        };
        // C s_431_500: const #21872u : u32
        let s_431_500: u32 = 21872;
        // N s_431_501: write-reg s_431_500 <= s_431_499
        let s_431_501: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_500 as isize, s_431_499);
            tracer.write_register(s_431_500 as isize, s_431_499);
        };
        // C s_431_502: const #104584u : u32
        let s_431_502: u32 = 104584;
        // D s_431_503: read-reg s_431_502:struct
        let s_431_503: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_502 as isize);
            tracer.read_register(s_431_502 as isize, value);
            value
        };
        // C s_431_504: const #104584u : u32
        let s_431_504: u32 = 104584;
        // N s_431_505: write-reg s_431_504 <= s_431_503
        let s_431_505: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_504 as isize, s_431_503);
            tracer.write_register(s_431_504 as isize, s_431_503);
        };
        // C s_431_506: const #13744u : u32
        let s_431_506: u32 = 13744;
        // D s_431_507: read-reg s_431_506:struct
        let s_431_507: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_506 as isize);
            tracer.read_register(s_431_506 as isize, value);
            value
        };
        // C s_431_508: const #13744u : u32
        let s_431_508: u32 = 13744;
        // N s_431_509: write-reg s_431_508 <= s_431_507
        let s_431_509: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_508 as isize, s_431_507);
            tracer.write_register(s_431_508 as isize, s_431_507);
        };
        // C s_431_510: const #10096u : u32
        let s_431_510: u32 = 10096;
        // D s_431_511: read-reg s_431_510:struct
        let s_431_511: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_510 as isize);
            tracer.read_register(s_431_510 as isize, value);
            value
        };
        // C s_431_512: const #10096u : u32
        let s_431_512: u32 = 10096;
        // N s_431_513: write-reg s_431_512 <= s_431_511
        let s_431_513: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_512 as isize, s_431_511);
            tracer.write_register(s_431_512 as isize, s_431_511);
        };
        // C s_431_514: const #1504u : u32
        let s_431_514: u32 = 1504;
        // D s_431_515: read-reg s_431_514:struct
        let s_431_515: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_514 as isize);
            tracer.read_register(s_431_514 as isize, value);
            value
        };
        // C s_431_516: const #1504u : u32
        let s_431_516: u32 = 1504;
        // N s_431_517: write-reg s_431_516 <= s_431_515
        let s_431_517: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_516 as isize, s_431_515);
            tracer.write_register(s_431_516 as isize, s_431_515);
        };
        // C s_431_518: const #90624u : u32
        let s_431_518: u32 = 90624;
        // D s_431_519: read-reg s_431_518:struct
        let s_431_519: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_518 as isize);
            tracer.read_register(s_431_518 as isize, value);
            value
        };
        // C s_431_520: const #90624u : u32
        let s_431_520: u32 = 90624;
        // N s_431_521: write-reg s_431_520 <= s_431_519
        let s_431_521: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_520 as isize, s_431_519);
            tracer.write_register(s_431_520 as isize, s_431_519);
        };
        // C s_431_522: const #102400u : u32
        let s_431_522: u32 = 102400;
        // D s_431_523: read-reg s_431_522:struct
        let s_431_523: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_522 as isize);
            tracer.read_register(s_431_522 as isize, value);
            value
        };
        // C s_431_524: const #102400u : u32
        let s_431_524: u32 = 102400;
        // N s_431_525: write-reg s_431_524 <= s_431_523
        let s_431_525: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_524 as isize, s_431_523);
            tracer.write_register(s_431_524 as isize, s_431_523);
        };
        // C s_431_526: const #22504u : u32
        let s_431_526: u32 = 22504;
        // D s_431_527: read-reg s_431_526:struct
        let s_431_527: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_526 as isize);
            tracer.read_register(s_431_526 as isize, value);
            value
        };
        // C s_431_528: const #22504u : u32
        let s_431_528: u32 = 22504;
        // N s_431_529: write-reg s_431_528 <= s_431_527
        let s_431_529: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_528 as isize, s_431_527);
            tracer.write_register(s_431_528 as isize, s_431_527);
        };
        // C s_431_530: const #22736u : u32
        let s_431_530: u32 = 22736;
        // D s_431_531: read-reg s_431_530:struct
        let s_431_531: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_530 as isize);
            tracer.read_register(s_431_530 as isize, value);
            value
        };
        // C s_431_532: const #22736u : u32
        let s_431_532: u32 = 22736;
        // N s_431_533: write-reg s_431_532 <= s_431_531
        let s_431_533: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_532 as isize, s_431_531);
            tracer.write_register(s_431_532 as isize, s_431_531);
        };
        // C s_431_534: const #20080u : u32
        let s_431_534: u32 = 20080;
        // D s_431_535: read-reg s_431_534:struct
        let s_431_535: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_534 as isize);
            tracer.read_register(s_431_534 as isize, value);
            value
        };
        // C s_431_536: const #20080u : u32
        let s_431_536: u32 = 20080;
        // N s_431_537: write-reg s_431_536 <= s_431_535
        let s_431_537: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_536 as isize, s_431_535);
            tracer.write_register(s_431_536 as isize, s_431_535);
        };
        // C s_431_538: const #21960u : u32
        let s_431_538: u32 = 21960;
        // D s_431_539: read-reg s_431_538:struct
        let s_431_539: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_538 as isize);
            tracer.read_register(s_431_538 as isize, value);
            value
        };
        // C s_431_540: const #21960u : u32
        let s_431_540: u32 = 21960;
        // N s_431_541: write-reg s_431_540 <= s_431_539
        let s_431_541: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_540 as isize, s_431_539);
            tracer.write_register(s_431_540 as isize, s_431_539);
        };
        // C s_431_542: const #15472u : u32
        let s_431_542: u32 = 15472;
        // D s_431_543: read-reg s_431_542:struct
        let s_431_543: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_542 as isize);
            tracer.read_register(s_431_542 as isize, value);
            value
        };
        // C s_431_544: const #15472u : u32
        let s_431_544: u32 = 15472;
        // N s_431_545: write-reg s_431_544 <= s_431_543
        let s_431_545: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_544 as isize, s_431_543);
            tracer.write_register(s_431_544 as isize, s_431_543);
        };
        // C s_431_546: const #19384u : u32
        let s_431_546: u32 = 19384;
        // D s_431_547: read-reg s_431_546:struct
        let s_431_547: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_546 as isize);
            tracer.read_register(s_431_546 as isize, value);
            value
        };
        // C s_431_548: const #19384u : u32
        let s_431_548: u32 = 19384;
        // N s_431_549: write-reg s_431_548 <= s_431_547
        let s_431_549: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_548 as isize, s_431_547);
            tracer.write_register(s_431_548 as isize, s_431_547);
        };
        // C s_431_550: const #14192u : u32
        let s_431_550: u32 = 14192;
        // D s_431_551: read-reg s_431_550:struct
        let s_431_551: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_550 as isize);
            tracer.read_register(s_431_550 as isize, value);
            value
        };
        // C s_431_552: const #14192u : u32
        let s_431_552: u32 = 14192;
        // N s_431_553: write-reg s_431_552 <= s_431_551
        let s_431_553: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_552 as isize, s_431_551);
            tracer.write_register(s_431_552 as isize, s_431_551);
        };
        // C s_431_554: const #22624u : u32
        let s_431_554: u32 = 22624;
        // D s_431_555: read-reg s_431_554:struct
        let s_431_555: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_554 as isize);
            tracer.read_register(s_431_554 as isize, value);
            value
        };
        // C s_431_556: const #22624u : u32
        let s_431_556: u32 = 22624;
        // N s_431_557: write-reg s_431_556 <= s_431_555
        let s_431_557: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_556 as isize, s_431_555);
            tracer.write_register(s_431_556 as isize, s_431_555);
        };
        // C s_431_558: const #22624u : u32
        let s_431_558: u32 = 22624;
        // D s_431_559: read-reg s_431_558:struct
        let s_431_559: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_558 as isize);
            tracer.read_register(s_431_558 as isize, value);
            value
        };
        // C s_431_560: const #22624u : u32
        let s_431_560: u32 = 22624;
        // N s_431_561: write-reg s_431_560 <= s_431_559
        let s_431_561: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_560 as isize, s_431_559);
            tracer.write_register(s_431_560 as isize, s_431_559);
        };
        // C s_431_562: const #22624u : u32
        let s_431_562: u32 = 22624;
        // D s_431_563: read-reg s_431_562:struct
        let s_431_563: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_562 as isize);
            tracer.read_register(s_431_562 as isize, value);
            value
        };
        // C s_431_564: const #22624u : u32
        let s_431_564: u32 = 22624;
        // N s_431_565: write-reg s_431_564 <= s_431_563
        let s_431_565: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_564 as isize, s_431_563);
            tracer.write_register(s_431_564 as isize, s_431_563);
        };
        // C s_431_566: const #103960u : u32
        let s_431_566: u32 = 103960;
        // D s_431_567: read-reg s_431_566:struct
        let s_431_567: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_566 as isize);
            tracer.read_register(s_431_566 as isize, value);
            value
        };
        // C s_431_568: const #103960u : u32
        let s_431_568: u32 = 103960;
        // N s_431_569: write-reg s_431_568 <= s_431_567
        let s_431_569: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_568 as isize, s_431_567);
            tracer.write_register(s_431_568 as isize, s_431_567);
        };
        // C s_431_570: const #17256u : u32
        let s_431_570: u32 = 17256;
        // D s_431_571: read-reg s_431_570:struct
        let s_431_571: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_570 as isize);
            tracer.read_register(s_431_570 as isize, value);
            value
        };
        // C s_431_572: const #17256u : u32
        let s_431_572: u32 = 17256;
        // N s_431_573: write-reg s_431_572 <= s_431_571
        let s_431_573: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_572 as isize, s_431_571);
            tracer.write_register(s_431_572 as isize, s_431_571);
        };
        // C s_431_574: const #100872u : u32
        let s_431_574: u32 = 100872;
        // D s_431_575: read-reg s_431_574:struct
        let s_431_575: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_574 as isize);
            tracer.read_register(s_431_574 as isize, value);
            value
        };
        // C s_431_576: const #100872u : u32
        let s_431_576: u32 = 100872;
        // N s_431_577: write-reg s_431_576 <= s_431_575
        let s_431_577: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_576 as isize, s_431_575);
            tracer.write_register(s_431_576 as isize, s_431_575);
        };
        // C s_431_578: const #10520u : u32
        let s_431_578: u32 = 10520;
        // D s_431_579: read-reg s_431_578:struct
        let s_431_579: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_578 as isize);
            tracer.read_register(s_431_578 as isize, value);
            value
        };
        // C s_431_580: const #10520u : u32
        let s_431_580: u32 = 10520;
        // N s_431_581: write-reg s_431_580 <= s_431_579
        let s_431_581: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_580 as isize, s_431_579);
            tracer.write_register(s_431_580 as isize, s_431_579);
        };
        // C s_431_582: const #20224u : u32
        let s_431_582: u32 = 20224;
        // D s_431_583: read-reg s_431_582:struct
        let s_431_583: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_582 as isize);
            tracer.read_register(s_431_582 as isize, value);
            value
        };
        // C s_431_584: const #20224u : u32
        let s_431_584: u32 = 20224;
        // N s_431_585: write-reg s_431_584 <= s_431_583
        let s_431_585: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_584 as isize, s_431_583);
            tracer.write_register(s_431_584 as isize, s_431_583);
        };
        // C s_431_586: const #102832u : u32
        let s_431_586: u32 = 102832;
        // D s_431_587: read-reg s_431_586:struct
        let s_431_587: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_586 as isize);
            tracer.read_register(s_431_586 as isize, value);
            value
        };
        // C s_431_588: const #102832u : u32
        let s_431_588: u32 = 102832;
        // N s_431_589: write-reg s_431_588 <= s_431_587
        let s_431_589: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_588 as isize, s_431_587);
            tracer.write_register(s_431_588 as isize, s_431_587);
        };
        // C s_431_590: const #18992u : u32
        let s_431_590: u32 = 18992;
        // D s_431_591: read-reg s_431_590:struct
        let s_431_591: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_590 as isize);
            tracer.read_register(s_431_590 as isize, value);
            value
        };
        // C s_431_592: const #18992u : u32
        let s_431_592: u32 = 18992;
        // N s_431_593: write-reg s_431_592 <= s_431_591
        let s_431_593: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_592 as isize, s_431_591);
            tracer.write_register(s_431_592 as isize, s_431_591);
        };
        // C s_431_594: const #12728u : u32
        let s_431_594: u32 = 12728;
        // D s_431_595: read-reg s_431_594:struct
        let s_431_595: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_594 as isize);
            tracer.read_register(s_431_594 as isize, value);
            value
        };
        // C s_431_596: const #12728u : u32
        let s_431_596: u32 = 12728;
        // N s_431_597: write-reg s_431_596 <= s_431_595
        let s_431_597: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_596 as isize, s_431_595);
            tracer.write_register(s_431_596 as isize, s_431_595);
        };
        // C s_431_598: const #102424u : u32
        let s_431_598: u32 = 102424;
        // D s_431_599: read-reg s_431_598:struct
        let s_431_599: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_598 as isize);
            tracer.read_register(s_431_598 as isize, value);
            value
        };
        // C s_431_600: const #102424u : u32
        let s_431_600: u32 = 102424;
        // N s_431_601: write-reg s_431_600 <= s_431_599
        let s_431_601: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_600 as isize, s_431_599);
            tracer.write_register(s_431_600 as isize, s_431_599);
        };
        // C s_431_602: const #102200u : u32
        let s_431_602: u32 = 102200;
        // D s_431_603: read-reg s_431_602:struct
        let s_431_603: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_602 as isize);
            tracer.read_register(s_431_602 as isize, value);
            value
        };
        // C s_431_604: const #102200u : u32
        let s_431_604: u32 = 102200;
        // N s_431_605: write-reg s_431_604 <= s_431_603
        let s_431_605: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_604 as isize, s_431_603);
            tracer.write_register(s_431_604 as isize, s_431_603);
        };
        // C s_431_606: const #102200u : u32
        let s_431_606: u32 = 102200;
        // D s_431_607: read-reg s_431_606:struct
        let s_431_607: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_606 as isize);
            tracer.read_register(s_431_606 as isize, value);
            value
        };
        // C s_431_608: const #102200u : u32
        let s_431_608: u32 = 102200;
        // N s_431_609: write-reg s_431_608 <= s_431_607
        let s_431_609: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_608 as isize, s_431_607);
            tracer.write_register(s_431_608 as isize, s_431_607);
        };
        // C s_431_610: const #15776u : u32
        let s_431_610: u32 = 15776;
        // D s_431_611: read-reg s_431_610:struct
        let s_431_611: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_610 as isize);
            tracer.read_register(s_431_610 as isize, value);
            value
        };
        // C s_431_612: const #15776u : u32
        let s_431_612: u32 = 15776;
        // N s_431_613: write-reg s_431_612 <= s_431_611
        let s_431_613: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_612 as isize, s_431_611);
            tracer.write_register(s_431_612 as isize, s_431_611);
        };
        // C s_431_614: const #104984u : u32
        let s_431_614: u32 = 104984;
        // D s_431_615: read-reg s_431_614:struct
        let s_431_615: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_614 as isize);
            tracer.read_register(s_431_614 as isize, value);
            value
        };
        // C s_431_616: const #104984u : u32
        let s_431_616: u32 = 104984;
        // N s_431_617: write-reg s_431_616 <= s_431_615
        let s_431_617: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_616 as isize, s_431_615);
            tracer.write_register(s_431_616 as isize, s_431_615);
        };
        // C s_431_618: const #14072u : u32
        let s_431_618: u32 = 14072;
        // D s_431_619: read-reg s_431_618:struct
        let s_431_619: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_618 as isize);
            tracer.read_register(s_431_618 as isize, value);
            value
        };
        // C s_431_620: const #14072u : u32
        let s_431_620: u32 = 14072;
        // N s_431_621: write-reg s_431_620 <= s_431_619
        let s_431_621: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_620 as isize, s_431_619);
            tracer.write_register(s_431_620 as isize, s_431_619);
        };
        // C s_431_622: const #16384u : u32
        let s_431_622: u32 = 16384;
        // D s_431_623: read-reg s_431_622:struct
        let s_431_623: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_622 as isize);
            tracer.read_register(s_431_622 as isize, value);
            value
        };
        // C s_431_624: const #16384u : u32
        let s_431_624: u32 = 16384;
        // N s_431_625: write-reg s_431_624 <= s_431_623
        let s_431_625: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_624 as isize, s_431_623);
            tracer.write_register(s_431_624 as isize, s_431_623);
        };
        // C s_431_626: const #104592u : u32
        let s_431_626: u32 = 104592;
        // D s_431_627: read-reg s_431_626:struct
        let s_431_627: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_626 as isize);
            tracer.read_register(s_431_626 as isize, value);
            value
        };
        // C s_431_628: const #104592u : u32
        let s_431_628: u32 = 104592;
        // N s_431_629: write-reg s_431_628 <= s_431_627
        let s_431_629: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_628 as isize, s_431_627);
            tracer.write_register(s_431_628 as isize, s_431_627);
        };
        // C s_431_630: const #12104u : u32
        let s_431_630: u32 = 12104;
        // D s_431_631: read-reg s_431_630:struct
        let s_431_631: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_431_630 as isize);
            tracer.read_register(s_431_630 as isize, value);
            value
        };
        // C s_431_632: const #12104u : u32
        let s_431_632: u32 = 12104;
        // N s_431_633: write-reg s_431_632 <= s_431_631
        let s_431_633: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_431_632 as isize, s_431_631);
            tracer.write_register(s_431_632 as isize, s_431_631);
        };
        // N s_431_634: return
        return;
    }
    fn block_432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_432_0: const #14040u : u32
        let s_432_0: u32 = 14040;
        // D s_432_1: read-reg s_432_0:struct
        let s_432_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_432_0 as isize);
            tracer.read_register(s_432_0 as isize, value);
            value
        };
        // C s_432_2: const #14040u : u32
        let s_432_2: u32 = 14040;
        // N s_432_3: write-reg s_432_2 <= s_432_1
        let s_432_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_432_2 as isize, s_432_1);
            tracer.write_register(s_432_2 as isize, s_432_1);
        };
        // N s_432_4: jump b431
        return block_431(state, tracer, fn_state);
    }
    fn block_433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_433_0: const #14040u : u32
        let s_433_0: u32 = 14040;
        // D s_433_1: read-reg s_433_0:struct
        let s_433_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_433_0 as isize);
            tracer.read_register(s_433_0 as isize, value);
            value
        };
        // C s_433_2: const #14040u : u32
        let s_433_2: u32 = 14040;
        // N s_433_3: write-reg s_433_2 <= s_433_1
        let s_433_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_433_2 as isize, s_433_1);
            tracer.write_register(s_433_2 as isize, s_433_1);
        };
        // N s_433_4: jump b429
        return block_429(state, tracer, fn_state);
    }
    fn block_434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_434_0: const #14040u : u32
        let s_434_0: u32 = 14040;
        // D s_434_1: read-reg s_434_0:struct
        let s_434_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_434_0 as isize);
            tracer.read_register(s_434_0 as isize, value);
            value
        };
        // C s_434_2: const #14040u : u32
        let s_434_2: u32 = 14040;
        // N s_434_3: write-reg s_434_2 <= s_434_1
        let s_434_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_434_2 as isize, s_434_1);
            tracer.write_register(s_434_2 as isize, s_434_1);
        };
        // N s_434_4: jump b427
        return block_427(state, tracer, fn_state);
    }
    fn block_435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_435_0: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_436_0: jump b425
        return block_425(state, tracer, fn_state);
    }
    fn block_437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_437_0: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_438_0: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_439_0: jump b419
        return block_419(state, tracer, fn_state);
    }
    fn block_440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_440_0: jump b419
        return block_419(state, tracer, fn_state);
    }
    fn block_441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_441_0: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_442_0: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_443_0: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_444_0: jump b413
        return block_413(state, tracer, fn_state);
    }
    fn block_445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_445_0: jump b410
        return block_410(state, tracer, fn_state);
    }
    fn block_446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_446_0: jump b410
        return block_410(state, tracer, fn_state);
    }
    fn block_447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_447_0: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_448_0: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_449_0: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_450_0: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_451_0: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_452_0: jump b399
        return block_399(state, tracer, fn_state);
    }
    fn block_453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_453_0: jump b399
        return block_399(state, tracer, fn_state);
    }
    fn block_454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_454_0: jump b396
        return block_396(state, tracer, fn_state);
    }
    fn block_455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_455_0: const #() : ()
        let s_455_0: () = ();
        // S s_455_1: call EDSCR_read(s_455_0)
        let s_455_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_455_0);
        // C s_455_2: const #0u : u8
        let s_455_2: bool = false;
        // S s_455_3: call _update_EDSCR_Type_ERR(s_455_1, s_455_2)
        let s_455_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_ERR(
            state,
            tracer,
            s_455_1,
            s_455_2,
        );
        // S s_455_4: call EDSCR_write(s_455_3)
        let s_455_4: () = EDSCR_write(state, tracer, s_455_3);
        // N s_455_5: jump b394
        return block_394(state, tracer, fn_state);
    }
    fn block_456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_456_0: const #() : ()
        let s_456_0: () = ();
        // S s_456_1: call EDSCR_read(s_456_0)
        let s_456_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_456_0);
        // C s_456_2: const #0u : u8
        let s_456_2: bool = false;
        // S s_456_3: call _update_EDSCR_Type_HDE(s_456_1, s_456_2)
        let s_456_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_HDE(
            state,
            tracer,
            s_456_1,
            s_456_2,
        );
        // S s_456_4: call EDSCR_write(s_456_3)
        let s_456_4: () = EDSCR_write(state, tracer, s_456_3);
        // N s_456_5: jump b392
        return block_392(state, tracer, fn_state);
    }
    fn block_457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_457_0: const #() : ()
        let s_457_0: () = ();
        // S s_457_1: call EDSCR_read(s_457_0)
        let s_457_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_457_0);
        // C s_457_2: const #0u : u8
        let s_457_2: bool = false;
        // S s_457_3: call _update_EDSCR_Type_SC2(s_457_1, s_457_2)
        let s_457_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_SC2(
            state,
            tracer,
            s_457_1,
            s_457_2,
        );
        // S s_457_4: call EDSCR_write(s_457_3)
        let s_457_4: () = EDSCR_write(state, tracer, s_457_3);
        // N s_457_5: jump b390
        return block_390(state, tracer, fn_state);
    }
    fn block_458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_458_0: const #() : ()
        let s_458_0: () = ();
        // S s_458_1: call EDSCR_read(s_458_0)
        let s_458_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_458_0);
        // C s_458_2: const #0u : u8
        let s_458_2: bool = false;
        // S s_458_3: call _update_EDSCR_Type_MA(s_458_1, s_458_2)
        let s_458_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_MA(
            state,
            tracer,
            s_458_1,
            s_458_2,
        );
        // S s_458_4: call EDSCR_write(s_458_3)
        let s_458_4: () = EDSCR_write(state, tracer, s_458_3);
        // N s_458_5: jump b388
        return block_388(state, tracer, fn_state);
    }
    fn block_459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_459_0: const #() : ()
        let s_459_0: () = ();
        // S s_459_1: call EDSCR_read(s_459_0)
        let s_459_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_459_0);
        // C s_459_2: const #0u : u8
        let s_459_2: bool = false;
        // S s_459_3: call _update_EDSCR_Type_TDA(s_459_1, s_459_2)
        let s_459_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_TDA(
            state,
            tracer,
            s_459_1,
            s_459_2,
        );
        // S s_459_4: call EDSCR_write(s_459_3)
        let s_459_4: () = EDSCR_write(state, tracer, s_459_3);
        // N s_459_5: jump b386
        return block_386(state, tracer, fn_state);
    }
    fn block_460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_460_0: const #() : ()
        let s_460_0: () = ();
        // S s_460_1: call EDSCR_read(s_460_0)
        let s_460_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_460_0);
        // C s_460_2: const #0u : u8
        let s_460_2: u8 = 0;
        // S s_460_3: call _update_EDSCR_Type_INTdis(s_460_1, s_460_2)
        let s_460_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_INTdis(
            state,
            tracer,
            s_460_1,
            s_460_2,
        );
        // S s_460_4: call EDSCR_write(s_460_3)
        let s_460_4: () = EDSCR_write(state, tracer, s_460_3);
        // N s_460_5: jump b384
        return block_384(state, tracer, fn_state);
    }
    fn block_461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_461_0: const #() : ()
        let s_461_0: () = ();
        // S s_461_1: call EDSCR_read(s_461_0)
        let s_461_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_461_0);
        // C s_461_2: const #0u : u8
        let s_461_2: bool = false;
        // S s_461_3: call _update_EDSCR_Type_TXU(s_461_1, s_461_2)
        let s_461_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_TXU(
            state,
            tracer,
            s_461_1,
            s_461_2,
        );
        // S s_461_4: call EDSCR_write(s_461_3)
        let s_461_4: () = EDSCR_write(state, tracer, s_461_3);
        // N s_461_5: jump b382
        return block_382(state, tracer, fn_state);
    }
    fn block_462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_462_0: const #() : ()
        let s_462_0: () = ();
        // S s_462_1: call EDSCR_read(s_462_0)
        let s_462_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_462_0);
        // C s_462_2: const #0u : u8
        let s_462_2: bool = false;
        // S s_462_3: call _update_EDSCR_Type_RXO(s_462_1, s_462_2)
        let s_462_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_RXO(
            state,
            tracer,
            s_462_1,
            s_462_2,
        );
        // S s_462_4: call EDSCR_write(s_462_3)
        let s_462_4: () = EDSCR_write(state, tracer, s_462_3);
        // N s_462_5: jump b380
        return block_380(state, tracer, fn_state);
    }
    fn block_463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_463_0: const #() : ()
        let s_463_0: () = ();
        // S s_463_1: call EDSCR_read(s_463_0)
        let s_463_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_463_0);
        // C s_463_2: const #0u : u8
        let s_463_2: bool = false;
        // S s_463_3: call _update_EDSCR_Type_TXfull(s_463_1, s_463_2)
        let s_463_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_TXfull(
            state,
            tracer,
            s_463_1,
            s_463_2,
        );
        // S s_463_4: call EDSCR_write(s_463_3)
        let s_463_4: () = EDSCR_write(state, tracer, s_463_3);
        // N s_463_5: jump b378
        return block_378(state, tracer, fn_state);
    }
    fn block_464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_464_0: const #() : ()
        let s_464_0: () = ();
        // S s_464_1: call EDSCR_read(s_464_0)
        let s_464_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_464_0);
        // C s_464_2: const #0u : u8
        let s_464_2: bool = false;
        // S s_464_3: call _update_EDSCR_Type_RXfull(s_464_1, s_464_2)
        let s_464_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_RXfull(
            state,
            tracer,
            s_464_1,
            s_464_2,
        );
        // S s_464_4: call EDSCR_write(s_464_3)
        let s_464_4: () = EDSCR_write(state, tracer, s_464_3);
        // N s_464_5: jump b376
        return block_376(state, tracer, fn_state);
    }
    fn block_465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_465_0: const #() : ()
        let s_465_0: () = ();
        // S s_465_1: call EDSCR_read(s_465_0)
        let s_465_1: ProductType700c18a878c5601b = EDSCR_read(state, tracer, s_465_0);
        // C s_465_2: const #0u : u8
        let s_465_2: bool = false;
        // S s_465_3: call _update_EDSCR_Type_TFO(s_465_1, s_465_2)
        let s_465_3: ProductType700c18a878c5601b = u_update_EDSCR_Type_TFO(
            state,
            tracer,
            s_465_1,
            s_465_2,
        );
        // S s_465_4: call EDSCR_write(s_465_3)
        let s_465_4: () = EDSCR_write(state, tracer, s_465_3);
        // N s_465_5: jump b374
        return block_374(state, tracer, fn_state);
    }
    fn block_466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_466_0: const #() : ()
        let s_466_0: () = ();
        // S s_466_1: call EDECCR_read(s_466_0)
        let s_466_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_466_0);
        // C s_466_2: const #0u : u8
        let s_466_2: bool = false;
        // S s_466_3: call _update_EDECCR_Type_SE1(s_466_1, s_466_2)
        let s_466_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_SE1(
            state,
            tracer,
            s_466_1,
            s_466_2,
        );
        // S s_466_4: call EDECCR_write(s_466_3)
        let s_466_4: () = EDECCR_write(state, tracer, s_466_3);
        // N s_466_5: jump b372
        return block_372(state, tracer, fn_state);
    }
    fn block_467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_467_0: const #() : ()
        let s_467_0: () = ();
        // S s_467_1: call EDECCR_read(s_467_0)
        let s_467_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_467_0);
        // C s_467_2: const #0u : u8
        let s_467_2: bool = false;
        // S s_467_3: call _update_EDECCR_Type_SE2(s_467_1, s_467_2)
        let s_467_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_SE2(
            state,
            tracer,
            s_467_1,
            s_467_2,
        );
        // S s_467_4: call EDECCR_write(s_467_3)
        let s_467_4: () = EDECCR_write(state, tracer, s_467_3);
        // N s_467_5: jump b370
        return block_370(state, tracer, fn_state);
    }
    fn block_468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_468_0: const #() : ()
        let s_468_0: () = ();
        // S s_468_1: call EDECCR_read(s_468_0)
        let s_468_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_468_0);
        // C s_468_2: const #0u : u8
        let s_468_2: bool = false;
        // S s_468_3: call _update_EDECCR_Type_SE3(s_468_1, s_468_2)
        let s_468_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_SE3(
            state,
            tracer,
            s_468_1,
            s_468_2,
        );
        // S s_468_4: call EDECCR_write(s_468_3)
        let s_468_4: () = EDECCR_write(state, tracer, s_468_3);
        // N s_468_5: jump b368
        return block_368(state, tracer, fn_state);
    }
    fn block_469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_469_0: const #() : ()
        let s_469_0: () = ();
        // S s_469_1: call EDECCR_read(s_469_0)
        let s_469_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_469_0);
        // C s_469_2: const #0u : u8
        let s_469_2: bool = false;
        // S s_469_3: call _update_EDECCR_Type_NSE1(s_469_1, s_469_2)
        let s_469_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_NSE1(
            state,
            tracer,
            s_469_1,
            s_469_2,
        );
        // S s_469_4: call EDECCR_write(s_469_3)
        let s_469_4: () = EDECCR_write(state, tracer, s_469_3);
        // N s_469_5: jump b366
        return block_366(state, tracer, fn_state);
    }
    fn block_470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_470_0: const #() : ()
        let s_470_0: () = ();
        // S s_470_1: call EDECCR_read(s_470_0)
        let s_470_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_470_0);
        // C s_470_2: const #0u : u8
        let s_470_2: bool = false;
        // S s_470_3: call _update_EDECCR_Type_NSE2(s_470_1, s_470_2)
        let s_470_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_NSE2(
            state,
            tracer,
            s_470_1,
            s_470_2,
        );
        // S s_470_4: call EDECCR_write(s_470_3)
        let s_470_4: () = EDECCR_write(state, tracer, s_470_3);
        // N s_470_5: jump b364
        return block_364(state, tracer, fn_state);
    }
    fn block_471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_471_0: const #() : ()
        let s_471_0: () = ();
        // S s_471_1: call EDECCR_read(s_471_0)
        let s_471_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_471_0);
        // C s_471_2: const #0u : u8
        let s_471_2: bool = false;
        // S s_471_3: call _update_EDECCR_Type_SR0(s_471_1, s_471_2)
        let s_471_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_SR0(
            state,
            tracer,
            s_471_1,
            s_471_2,
        );
        // S s_471_4: call EDECCR_write(s_471_3)
        let s_471_4: () = EDECCR_write(state, tracer, s_471_3);
        // N s_471_5: jump b362
        return block_362(state, tracer, fn_state);
    }
    fn block_472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_472_0: const #() : ()
        let s_472_0: () = ();
        // S s_472_1: call EDECCR_read(s_472_0)
        let s_472_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_472_0);
        // C s_472_2: const #0u : u8
        let s_472_2: bool = false;
        // S s_472_3: call _update_EDECCR_Type_SR1(s_472_1, s_472_2)
        let s_472_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_SR1(
            state,
            tracer,
            s_472_1,
            s_472_2,
        );
        // S s_472_4: call EDECCR_write(s_472_3)
        let s_472_4: () = EDECCR_write(state, tracer, s_472_3);
        // N s_472_5: jump b360
        return block_360(state, tracer, fn_state);
    }
    fn block_473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_473_0: const #() : ()
        let s_473_0: () = ();
        // S s_473_1: call EDECCR_read(s_473_0)
        let s_473_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_473_0);
        // C s_473_2: const #0u : u8
        let s_473_2: bool = false;
        // S s_473_3: call _update_EDECCR_Type_SR2(s_473_1, s_473_2)
        let s_473_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_SR2(
            state,
            tracer,
            s_473_1,
            s_473_2,
        );
        // S s_473_4: call EDECCR_write(s_473_3)
        let s_473_4: () = EDECCR_write(state, tracer, s_473_3);
        // N s_473_5: jump b358
        return block_358(state, tracer, fn_state);
    }
    fn block_474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_474_0: const #() : ()
        let s_474_0: () = ();
        // S s_474_1: call EDECCR_read(s_474_0)
        let s_474_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_474_0);
        // C s_474_2: const #0u : u8
        let s_474_2: bool = false;
        // S s_474_3: call _update_EDECCR_Type_SR3(s_474_1, s_474_2)
        let s_474_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_SR3(
            state,
            tracer,
            s_474_1,
            s_474_2,
        );
        // S s_474_4: call EDECCR_write(s_474_3)
        let s_474_4: () = EDECCR_write(state, tracer, s_474_3);
        // N s_474_5: jump b356
        return block_356(state, tracer, fn_state);
    }
    fn block_475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_475_0: const #() : ()
        let s_475_0: () = ();
        // S s_475_1: call EDECCR_read(s_475_0)
        let s_475_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_475_0);
        // C s_475_2: const #0u : u8
        let s_475_2: bool = false;
        // S s_475_3: call _update_EDECCR_Type_NSR0(s_475_1, s_475_2)
        let s_475_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_NSR0(
            state,
            tracer,
            s_475_1,
            s_475_2,
        );
        // S s_475_4: call EDECCR_write(s_475_3)
        let s_475_4: () = EDECCR_write(state, tracer, s_475_3);
        // N s_475_5: jump b354
        return block_354(state, tracer, fn_state);
    }
    fn block_476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_476_0: const #() : ()
        let s_476_0: () = ();
        // S s_476_1: call EDECCR_read(s_476_0)
        let s_476_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_476_0);
        // C s_476_2: const #0u : u8
        let s_476_2: bool = false;
        // S s_476_3: call _update_EDECCR_Type_NSR1(s_476_1, s_476_2)
        let s_476_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_NSR1(
            state,
            tracer,
            s_476_1,
            s_476_2,
        );
        // S s_476_4: call EDECCR_write(s_476_3)
        let s_476_4: () = EDECCR_write(state, tracer, s_476_3);
        // N s_476_5: jump b352
        return block_352(state, tracer, fn_state);
    }
    fn block_477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_477_0: const #() : ()
        let s_477_0: () = ();
        // S s_477_1: call EDECCR_read(s_477_0)
        let s_477_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_477_0);
        // C s_477_2: const #0u : u8
        let s_477_2: bool = false;
        // S s_477_3: call _update_EDECCR_Type_NSR2(s_477_1, s_477_2)
        let s_477_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_NSR2(
            state,
            tracer,
            s_477_1,
            s_477_2,
        );
        // S s_477_4: call EDECCR_write(s_477_3)
        let s_477_4: () = EDECCR_write(state, tracer, s_477_3);
        // N s_477_5: jump b350
        return block_350(state, tracer, fn_state);
    }
    fn block_478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_478_0: const #() : ()
        let s_478_0: () = ();
        // S s_478_1: call EDECCR_read(s_478_0)
        let s_478_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_478_0);
        // C s_478_2: const #0u : u8
        let s_478_2: bool = false;
        // S s_478_3: call _update_EDECCR_Type_RLE1(s_478_1, s_478_2)
        let s_478_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_RLE1(
            state,
            tracer,
            s_478_1,
            s_478_2,
        );
        // S s_478_4: call EDECCR_write(s_478_3)
        let s_478_4: () = EDECCR_write(state, tracer, s_478_3);
        // N s_478_5: jump b348
        return block_348(state, tracer, fn_state);
    }
    fn block_479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_479_0: const #() : ()
        let s_479_0: () = ();
        // S s_479_1: call EDECCR_read(s_479_0)
        let s_479_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_479_0);
        // C s_479_2: const #0u : u8
        let s_479_2: bool = false;
        // S s_479_3: call _update_EDECCR_Type_RLE2(s_479_1, s_479_2)
        let s_479_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_RLE2(
            state,
            tracer,
            s_479_1,
            s_479_2,
        );
        // S s_479_4: call EDECCR_write(s_479_3)
        let s_479_4: () = EDECCR_write(state, tracer, s_479_3);
        // N s_479_5: jump b346
        return block_346(state, tracer, fn_state);
    }
    fn block_480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_480_0: const #() : ()
        let s_480_0: () = ();
        // S s_480_1: call EDECCR_read(s_480_0)
        let s_480_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_480_0);
        // C s_480_2: const #0u : u8
        let s_480_2: bool = false;
        // S s_480_3: call _update_EDECCR_Type_RLR0(s_480_1, s_480_2)
        let s_480_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_RLR0(
            state,
            tracer,
            s_480_1,
            s_480_2,
        );
        // S s_480_4: call EDECCR_write(s_480_3)
        let s_480_4: () = EDECCR_write(state, tracer, s_480_3);
        // N s_480_5: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_481_0: const #() : ()
        let s_481_0: () = ();
        // S s_481_1: call EDECCR_read(s_481_0)
        let s_481_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_481_0);
        // C s_481_2: const #0u : u8
        let s_481_2: bool = false;
        // S s_481_3: call _update_EDECCR_Type_RLR1(s_481_1, s_481_2)
        let s_481_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_RLR1(
            state,
            tracer,
            s_481_1,
            s_481_2,
        );
        // S s_481_4: call EDECCR_write(s_481_3)
        let s_481_4: () = EDECCR_write(state, tracer, s_481_3);
        // N s_481_5: jump b342
        return block_342(state, tracer, fn_state);
    }
    fn block_482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_482_0: const #() : ()
        let s_482_0: () = ();
        // S s_482_1: call EDECCR_read(s_482_0)
        let s_482_1: ProductType700c18a878c5601b = EDECCR_read(state, tracer, s_482_0);
        // C s_482_2: const #0u : u8
        let s_482_2: bool = false;
        // S s_482_3: call _update_EDECCR_Type_RLR2(s_482_1, s_482_2)
        let s_482_3: ProductType700c18a878c5601b = u_update_EDECCR_Type_RLR2(
            state,
            tracer,
            s_482_1,
            s_482_2,
        );
        // S s_482_4: call EDECCR_write(s_482_3)
        let s_482_4: () = EDECCR_write(state, tracer, s_482_3);
        // N s_482_5: jump b340
        return block_340(state, tracer, fn_state);
    }
    fn block_483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_483_0: const #20176u : u32
        let s_483_0: u32 = 20176;
        // D s_483_1: read-reg s_483_0:struct
        let s_483_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_483_0 as isize);
            tracer.read_register(s_483_0 as isize, value);
            value
        };
        // C s_483_2: const #20176u : u32
        let s_483_2: u32 = 20176;
        // N s_483_3: write-reg s_483_2 <= s_483_1
        let s_483_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_483_2 as isize, s_483_1);
            tracer.write_register(s_483_2 as isize, s_483_1);
        };
        // N s_483_4: jump b338
        return block_338(state, tracer, fn_state);
    }
    fn block_484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_484_0: const #20176u : u32
        let s_484_0: u32 = 20176;
        // D s_484_1: read-reg s_484_0:struct
        let s_484_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_484_0 as isize);
            tracer.read_register(s_484_0 as isize, value);
            value
        };
        // C s_484_2: const #20176u : u32
        let s_484_2: u32 = 20176;
        // N s_484_3: write-reg s_484_2 <= s_484_1
        let s_484_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_484_2 as isize, s_484_1);
            tracer.write_register(s_484_2 as isize, s_484_1);
        };
        // N s_484_4: jump b336
        return block_336(state, tracer, fn_state);
    }
    fn block_485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_485_0: const #219u : u32
        let s_485_0: u32 = 219;
        // S s_485_1: call IsFeatureImplemented(s_485_0)
        let s_485_1: bool = IsFeatureImplemented(state, tracer, s_485_0);
        // D s_485_2: write-var gs#45205 <= s_485_1
        fn_state.gs_45205 = s_485_1;
        // N s_485_3: jump b334
        return block_334(state, tracer, fn_state);
    }
    fn block_486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_486_0: const #20176u : u32
        let s_486_0: u32 = 20176;
        // D s_486_1: read-reg s_486_0:struct
        let s_486_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_486_0 as isize);
            tracer.read_register(s_486_0 as isize, value);
            value
        };
        // C s_486_2: const #20176u : u32
        let s_486_2: u32 = 20176;
        // N s_486_3: write-reg s_486_2 <= s_486_1
        let s_486_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_486_2 as isize, s_486_1);
            tracer.write_register(s_486_2 as isize, s_486_1);
        };
        // N s_486_4: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_487_0: const #14712u : u32
        let s_487_0: u32 = 14712;
        // D s_487_1: read-reg s_487_0:struct
        let s_487_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_487_0 as isize);
            tracer.read_register(s_487_0 as isize, value);
            value
        };
        // C s_487_2: const #14712u : u32
        let s_487_2: u32 = 14712;
        // N s_487_3: write-reg s_487_2 <= s_487_1
        let s_487_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_487_2 as isize, s_487_1);
            tracer.write_register(s_487_2 as isize, s_487_1);
        };
        // N s_487_4: jump b330
        return block_330(state, tracer, fn_state);
    }
    fn block_488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_488_0: const #() : ()
        let s_488_0: () = ();
        // S s_488_1: call EDSCR2_read(s_488_0)
        let s_488_1: ProductType700c18a878c5601b = EDSCR2_read(state, tracer, s_488_0);
        // C s_488_2: const #0u : u8
        let s_488_2: bool = false;
        // S s_488_3: call _update_EDSCR2_Type_EHBWE(s_488_1, s_488_2)
        let s_488_3: ProductType700c18a878c5601b = u_update_EDSCR2_Type_EHBWE(
            state,
            tracer,
            s_488_1,
            s_488_2,
        );
        // S s_488_4: call EDSCR2_write(s_488_3)
        let s_488_4: () = EDSCR2_write(state, tracer, s_488_3);
        // N s_488_5: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_489_0: const #15456u : u32
        let s_489_0: u32 = 15456;
        // D s_489_1: read-reg s_489_0:struct
        let s_489_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_489_0 as isize);
            tracer.read_register(s_489_0 as isize, value);
            value
        };
        // C s_489_2: const #15456u : u32
        let s_489_2: u32 = 15456;
        // N s_489_3: write-reg s_489_2 <= s_489_1
        let s_489_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_489_2 as isize, s_489_1);
            tracer.write_register(s_489_2 as isize, s_489_1);
        };
        // N s_489_4: jump b326
        return block_326(state, tracer, fn_state);
    }
    fn block_490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_490_0: const #15456u : u32
        let s_490_0: u32 = 15456;
        // D s_490_1: read-reg s_490_0:struct
        let s_490_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_490_0 as isize);
            tracer.read_register(s_490_0 as isize, value);
            value
        };
        // C s_490_2: const #15456u : u32
        let s_490_2: u32 = 15456;
        // N s_490_3: write-reg s_490_2 <= s_490_1
        let s_490_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_490_2 as isize, s_490_1);
            tracer.write_register(s_490_2 as isize, s_490_1);
        };
        // N s_490_4: jump b324
        return block_324(state, tracer, fn_state);
    }
    fn block_491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_491_0: const #219u : u32
        let s_491_0: u32 = 219;
        // S s_491_1: call IsFeatureImplemented(s_491_0)
        let s_491_1: bool = IsFeatureImplemented(state, tracer, s_491_0);
        // D s_491_2: write-var gs#45018 <= s_491_1
        fn_state.gs_45018 = s_491_1;
        // N s_491_3: jump b322
        return block_322(state, tracer, fn_state);
    }
    fn block_492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_492_0: jump b320
        return block_320(state, tracer, fn_state);
    }
    fn block_493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_493_0: const #() : ()
        let s_493_0: () = ();
        // S s_493_1: call AMCNTENSET1_read(s_493_0)
        let s_493_1: ProductType700c18a878c5601b = AMCNTENSET1_read(
            state,
            tracer,
            s_493_0,
        );
        // D s_493_2: write-var ga#36700 <= s_493_1
        fn_state.ga_36700 = s_493_1;
        // D s_493_3: read-var ga#36700.0:struct
        let s_493_3: u32 = fn_state.ga_36700._0;
        // C s_493_4: const #16s : i
        let s_493_4: i128 = 16;
        // C s_493_5: const #0s : i
        let s_493_5: i128 = 0;
        // D s_493_6: cast zx s_493_3 -> bv
        let s_493_6: Bits = Bits::new(s_493_3 as u128, 32u16);
        // C s_493_7: const #0u : u16
        let s_493_7: u16 = 0;
        // C s_493_8: cast zx s_493_7 -> bv
        let s_493_8: Bits = Bits::new(s_493_7 as u128, 16u16);
        // C s_493_9: const #1u : u64
        let s_493_9: u64 = 1;
        // C s_493_10: cast zx s_493_9 -> bv
        let s_493_10: Bits = Bits::new(s_493_9 as u128, 64u16);
        // C s_493_11: lsl s_493_10 s_493_4
        let s_493_11: Bits = s_493_10 << s_493_4;
        // C s_493_12: sub s_493_11 s_493_10
        let s_493_12: Bits = ((s_493_11) - (s_493_10));
        // C s_493_13: and s_493_8 s_493_12
        let s_493_13: Bits = ((s_493_8) & (s_493_12));
        // C s_493_14: lsl s_493_13 s_493_5
        let s_493_14: Bits = s_493_13 << s_493_5;
        // C s_493_15: lsl s_493_12 s_493_5
        let s_493_15: Bits = s_493_12 << s_493_5;
        // C s_493_16: cmpl s_493_15
        let s_493_16: Bits = !s_493_15;
        // D s_493_17: and s_493_6 s_493_16
        let s_493_17: Bits = ((s_493_6) & (s_493_16));
        // D s_493_18: or s_493_17 s_493_14
        let s_493_18: Bits = ((s_493_17) | (s_493_14));
        // D s_493_19: cast reint s_493_18 -> u32
        let s_493_19: u32 = (s_493_18.value() as u32);
        // D s_493_20: call Mk_AMCNTENSET1_Type(s_493_19)
        let s_493_20: ProductType700c18a878c5601b = Mk_AMCNTENSET1_Type(
            state,
            tracer,
            s_493_19,
        );
        // D s_493_21: call AMCNTENSET1_write(s_493_20)
        let s_493_21: () = AMCNTENSET1_write(state, tracer, s_493_20);
        // N s_493_22: jump b318
        return block_318(state, tracer, fn_state);
    }
    fn block_494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_494_0: const #() : ()
        let s_494_0: () = ();
        // S s_494_1: call AMCNTENCLR0_read(s_494_0)
        let s_494_1: ProductType700c18a878c5601b = AMCNTENCLR0_read(
            state,
            tracer,
            s_494_0,
        );
        // D s_494_2: write-var ga#36692 <= s_494_1
        fn_state.ga_36692 = s_494_1;
        // D s_494_3: read-var ga#36692.0:struct
        let s_494_3: u32 = fn_state.ga_36692._0;
        // C s_494_4: const #4s : i
        let s_494_4: i128 = 4;
        // C s_494_5: const #0s : i
        let s_494_5: i128 = 0;
        // D s_494_6: cast zx s_494_3 -> bv
        let s_494_6: Bits = Bits::new(s_494_3 as u128, 32u16);
        // C s_494_7: const #0u : u8
        let s_494_7: u8 = 0;
        // C s_494_8: cast zx s_494_7 -> bv
        let s_494_8: Bits = Bits::new(s_494_7 as u128, 4u16);
        // C s_494_9: const #1u : u64
        let s_494_9: u64 = 1;
        // C s_494_10: cast zx s_494_9 -> bv
        let s_494_10: Bits = Bits::new(s_494_9 as u128, 64u16);
        // C s_494_11: lsl s_494_10 s_494_4
        let s_494_11: Bits = s_494_10 << s_494_4;
        // C s_494_12: sub s_494_11 s_494_10
        let s_494_12: Bits = ((s_494_11) - (s_494_10));
        // C s_494_13: and s_494_8 s_494_12
        let s_494_13: Bits = ((s_494_8) & (s_494_12));
        // C s_494_14: lsl s_494_13 s_494_5
        let s_494_14: Bits = s_494_13 << s_494_5;
        // C s_494_15: lsl s_494_12 s_494_5
        let s_494_15: Bits = s_494_12 << s_494_5;
        // C s_494_16: cmpl s_494_15
        let s_494_16: Bits = !s_494_15;
        // D s_494_17: and s_494_6 s_494_16
        let s_494_17: Bits = ((s_494_6) & (s_494_16));
        // D s_494_18: or s_494_17 s_494_14
        let s_494_18: Bits = ((s_494_17) | (s_494_14));
        // D s_494_19: cast reint s_494_18 -> u32
        let s_494_19: u32 = (s_494_18.value() as u32);
        // D s_494_20: call Mk_AMCNTENCLR0_Type(s_494_19)
        let s_494_20: ProductType700c18a878c5601b = Mk_AMCNTENCLR0_Type(
            state,
            tracer,
            s_494_19,
        );
        // D s_494_21: call AMCNTENCLR0_write(s_494_20)
        let s_494_21: () = AMCNTENCLR0_write(state, tracer, s_494_20);
        // N s_494_22: jump b316
        return block_316(state, tracer, fn_state);
    }
    fn block_495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_495_0: const #() : ()
        let s_495_0: () = ();
        // S s_495_1: call AMCNTENSET0_read(s_495_0)
        let s_495_1: ProductType700c18a878c5601b = AMCNTENSET0_read(
            state,
            tracer,
            s_495_0,
        );
        // D s_495_2: write-var ga#36680 <= s_495_1
        fn_state.ga_36680 = s_495_1;
        // D s_495_3: read-var ga#36680.0:struct
        let s_495_3: u32 = fn_state.ga_36680._0;
        // C s_495_4: const #4s : i
        let s_495_4: i128 = 4;
        // C s_495_5: const #0s : i
        let s_495_5: i128 = 0;
        // D s_495_6: cast zx s_495_3 -> bv
        let s_495_6: Bits = Bits::new(s_495_3 as u128, 32u16);
        // C s_495_7: const #0u : u8
        let s_495_7: u8 = 0;
        // C s_495_8: cast zx s_495_7 -> bv
        let s_495_8: Bits = Bits::new(s_495_7 as u128, 4u16);
        // C s_495_9: const #1u : u64
        let s_495_9: u64 = 1;
        // C s_495_10: cast zx s_495_9 -> bv
        let s_495_10: Bits = Bits::new(s_495_9 as u128, 64u16);
        // C s_495_11: lsl s_495_10 s_495_4
        let s_495_11: Bits = s_495_10 << s_495_4;
        // C s_495_12: sub s_495_11 s_495_10
        let s_495_12: Bits = ((s_495_11) - (s_495_10));
        // C s_495_13: and s_495_8 s_495_12
        let s_495_13: Bits = ((s_495_8) & (s_495_12));
        // C s_495_14: lsl s_495_13 s_495_5
        let s_495_14: Bits = s_495_13 << s_495_5;
        // C s_495_15: lsl s_495_12 s_495_5
        let s_495_15: Bits = s_495_12 << s_495_5;
        // C s_495_16: cmpl s_495_15
        let s_495_16: Bits = !s_495_15;
        // D s_495_17: and s_495_6 s_495_16
        let s_495_17: Bits = ((s_495_6) & (s_495_16));
        // D s_495_18: or s_495_17 s_495_14
        let s_495_18: Bits = ((s_495_17) | (s_495_14));
        // D s_495_19: cast reint s_495_18 -> u32
        let s_495_19: u32 = (s_495_18.value() as u32);
        // D s_495_20: call Mk_AMCNTENSET0_Type(s_495_19)
        let s_495_20: ProductType700c18a878c5601b = Mk_AMCNTENSET0_Type(
            state,
            tracer,
            s_495_19,
        );
        // D s_495_21: call AMCNTENSET0_write(s_495_20)
        let s_495_21: () = AMCNTENSET0_write(state, tracer, s_495_20);
        // N s_495_22: jump b314
        return block_314(state, tracer, fn_state);
    }
    fn block_496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_496_0: const #() : ()
        let s_496_0: () = ();
        // S s_496_1: call AMCNTENCLR1_read(s_496_0)
        let s_496_1: ProductType700c18a878c5601b = AMCNTENCLR1_read(
            state,
            tracer,
            s_496_0,
        );
        // D s_496_2: write-var ga#36668 <= s_496_1
        fn_state.ga_36668 = s_496_1;
        // D s_496_3: read-var ga#36668.0:struct
        let s_496_3: u32 = fn_state.ga_36668._0;
        // C s_496_4: const #16s : i
        let s_496_4: i128 = 16;
        // C s_496_5: const #0s : i
        let s_496_5: i128 = 0;
        // D s_496_6: cast zx s_496_3 -> bv
        let s_496_6: Bits = Bits::new(s_496_3 as u128, 32u16);
        // C s_496_7: const #0u : u16
        let s_496_7: u16 = 0;
        // C s_496_8: cast zx s_496_7 -> bv
        let s_496_8: Bits = Bits::new(s_496_7 as u128, 16u16);
        // C s_496_9: const #1u : u64
        let s_496_9: u64 = 1;
        // C s_496_10: cast zx s_496_9 -> bv
        let s_496_10: Bits = Bits::new(s_496_9 as u128, 64u16);
        // C s_496_11: lsl s_496_10 s_496_4
        let s_496_11: Bits = s_496_10 << s_496_4;
        // C s_496_12: sub s_496_11 s_496_10
        let s_496_12: Bits = ((s_496_11) - (s_496_10));
        // C s_496_13: and s_496_8 s_496_12
        let s_496_13: Bits = ((s_496_8) & (s_496_12));
        // C s_496_14: lsl s_496_13 s_496_5
        let s_496_14: Bits = s_496_13 << s_496_5;
        // C s_496_15: lsl s_496_12 s_496_5
        let s_496_15: Bits = s_496_12 << s_496_5;
        // C s_496_16: cmpl s_496_15
        let s_496_16: Bits = !s_496_15;
        // D s_496_17: and s_496_6 s_496_16
        let s_496_17: Bits = ((s_496_6) & (s_496_16));
        // D s_496_18: or s_496_17 s_496_14
        let s_496_18: Bits = ((s_496_17) | (s_496_14));
        // D s_496_19: cast reint s_496_18 -> u32
        let s_496_19: u32 = (s_496_18.value() as u32);
        // D s_496_20: call Mk_AMCNTENCLR1_Type(s_496_19)
        let s_496_20: ProductType700c18a878c5601b = Mk_AMCNTENCLR1_Type(
            state,
            tracer,
            s_496_19,
        );
        // D s_496_21: call AMCNTENCLR1_write(s_496_20)
        let s_496_21: () = AMCNTENCLR1_write(state, tracer, s_496_20);
        // N s_496_22: jump b312
        return block_312(state, tracer, fn_state);
    }
    fn block_497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_497_0: const #15048u : u32
        let s_497_0: u32 = 15048;
        // D s_497_1: read-reg s_497_0:struct
        let s_497_1: ProductType700c18a878c5601b = {
            let value = state
                .read_register::<ProductType700c18a878c5601b>(s_497_0 as isize);
            tracer.read_register(s_497_0 as isize, value);
            value
        };
        // C s_497_2: const #15048u : u32
        let s_497_2: u32 = 15048;
        // N s_497_3: write-reg s_497_2 <= s_497_1
        let s_497_3: () = {
            state
                .write_register::<
                    ProductType700c18a878c5601b,
                >(s_497_2 as isize, s_497_1);
            tracer.write_register(s_497_2 as isize, s_497_1);
        };
        // N s_497_4: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_498_0: const #() : ()
        let s_498_0: () = ();
        // S s_498_1: call CNTHP_CTL_read(s_498_0)
        let s_498_1: ProductType700c18a878c5601b = CNTHP_CTL_read(
            state,
            tracer,
            s_498_0,
        );
        // C s_498_2: const #0u : u8
        let s_498_2: bool = false;
        // S s_498_3: call _update_CNTHP_CTL_Type_ENABLE(s_498_1, s_498_2)
        let s_498_3: ProductType700c18a878c5601b = u_update_CNTHP_CTL_Type_ENABLE(
            state,
            tracer,
            s_498_1,
            s_498_2,
        );
        // S s_498_4: call CNTHP_CTL_write(s_498_3)
        let s_498_4: () = CNTHP_CTL_write(state, tracer, s_498_3);
        // N s_498_5: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_499_0: const #"the PE resets into EL2 or EL3" : str
        let s_499_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_499_1: call __IMPDEF_boolean(s_499_0)
        let s_499_1: bool = u__IMPDEF_boolean(state, tracer, s_499_0);
        // D s_499_2: write-var gs#44749 <= s_499_1
        fn_state.gs_44749 = s_499_1;
        // N s_499_3: jump b306
        return block_306(state, tracer, fn_state);
    }
    fn block_500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_500_0: const #() : ()
        let s_500_0: () = ();
        // S s_500_1: call DBGOSLSR_read(s_500_0)
        let s_500_1: ProductType700c18a878c5601b = DBGOSLSR_read(state, tracer, s_500_0);
        // C s_500_2: const #1u : u8
        let s_500_2: bool = true;
        // S s_500_3: call _update_DBGOSLSR_Type_OSLK(s_500_1, s_500_2)
        let s_500_3: ProductType700c18a878c5601b = u_update_DBGOSLSR_Type_OSLK(
            state,
            tracer,
            s_500_1,
            s_500_2,
        );
        // S s_500_4: call DBGOSLSR_write(s_500_3)
        let s_500_4: () = DBGOSLSR_write(state, tracer, s_500_3);
        // N s_500_5: jump b304
        return block_304(state, tracer, fn_state);
    }
    fn block_501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_501_0: const #() : ()
        let s_501_0: () = ();
        // S s_501_1: call HTRFCR_read(s_501_0)
        let s_501_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_501_0);
        // C s_501_2: const #0u : u8
        let s_501_2: bool = false;
        // S s_501_3: call _update_HTRFCR_Type_E0HTRE(s_501_1, s_501_2)
        let s_501_3: ProductType700c18a878c5601b = u_update_HTRFCR_Type_E0HTRE(
            state,
            tracer,
            s_501_1,
            s_501_2,
        );
        // S s_501_4: call HTRFCR_write(s_501_3)
        let s_501_4: () = HTRFCR_write(state, tracer, s_501_3);
        // N s_501_5: jump b302
        return block_302(state, tracer, fn_state);
    }
    fn block_502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_502_0: const #"the PE resets into EL2 or EL3" : str
        let s_502_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_502_1: call __IMPDEF_boolean(s_502_0)
        let s_502_1: bool = u__IMPDEF_boolean(state, tracer, s_502_0);
        // D s_502_2: write-var gs#44725 <= s_502_1
        fn_state.gs_44725 = s_502_1;
        // N s_502_3: jump b300
        return block_300(state, tracer, fn_state);
    }
    fn block_503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_503_0: const #() : ()
        let s_503_0: () = ();
        // S s_503_1: call HTRFCR_read(s_503_0)
        let s_503_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_503_0);
        // C s_503_2: const #0u : u8
        let s_503_2: bool = false;
        // S s_503_3: call _update_HTRFCR_Type_E2TRE(s_503_1, s_503_2)
        let s_503_3: ProductType700c18a878c5601b = u_update_HTRFCR_Type_E2TRE(
            state,
            tracer,
            s_503_1,
            s_503_2,
        );
        // S s_503_4: call HTRFCR_write(s_503_3)
        let s_503_4: () = HTRFCR_write(state, tracer, s_503_3);
        // N s_503_5: jump b298
        return block_298(state, tracer, fn_state);
    }
    fn block_504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_504_0: const #"the PE resets into EL2 or EL3" : str
        let s_504_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_504_1: call __IMPDEF_boolean(s_504_0)
        let s_504_1: bool = u__IMPDEF_boolean(state, tracer, s_504_0);
        // D s_504_2: write-var gs#44724 <= s_504_1
        fn_state.gs_44724 = s_504_1;
        // N s_504_3: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_505_0: const #() : ()
        let s_505_0: () = ();
        // S s_505_1: call HTRFCR_read(s_505_0)
        let s_505_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_505_0);
        // C s_505_2: const #0u : u8
        let s_505_2: bool = false;
        // S s_505_3: call _update_HTRFCR_Type_CX(s_505_1, s_505_2)
        let s_505_3: ProductType700c18a878c5601b = u_update_HTRFCR_Type_CX(
            state,
            tracer,
            s_505_1,
            s_505_2,
        );
        // S s_505_4: call HTRFCR_write(s_505_3)
        let s_505_4: () = HTRFCR_write(state, tracer, s_505_3);
        // N s_505_5: jump b294
        return block_294(state, tracer, fn_state);
    }
    fn block_506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_506_0: const #"the PE resets into EL2 or EL3" : str
        let s_506_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_506_1: call __IMPDEF_boolean(s_506_0)
        let s_506_1: bool = u__IMPDEF_boolean(state, tracer, s_506_0);
        // D s_506_2: write-var gs#44720 <= s_506_1
        fn_state.gs_44720 = s_506_1;
        // N s_506_3: jump b292
        return block_292(state, tracer, fn_state);
    }
    fn block_507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_507_0: const #() : ()
        let s_507_0: () = ();
        // S s_507_1: call HTRFCR_read(s_507_0)
        let s_507_1: ProductType700c18a878c5601b = HTRFCR_read(state, tracer, s_507_0);
        // C s_507_2: const #0u : u8
        let s_507_2: u8 = 0;
        // S s_507_3: call _update_HTRFCR_Type_TS(s_507_1, s_507_2)
        let s_507_3: ProductType700c18a878c5601b = u_update_HTRFCR_Type_TS(
            state,
            tracer,
            s_507_1,
            s_507_2,
        );
        // S s_507_4: call HTRFCR_write(s_507_3)
        let s_507_4: () = HTRFCR_write(state, tracer, s_507_3);
        // N s_507_5: jump b290
        return block_290(state, tracer, fn_state);
    }
    fn block_508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_508_0: const #"the PE resets into EL2 or EL3" : str
        let s_508_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_508_1: call __IMPDEF_boolean(s_508_0)
        let s_508_1: bool = u__IMPDEF_boolean(state, tracer, s_508_0);
        // D s_508_2: write-var gs#44716 <= s_508_1
        fn_state.gs_44716 = s_508_1;
        // N s_508_3: jump b288
        return block_288(state, tracer, fn_state);
    }
    fn block_509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_509_0: const #() : ()
        let s_509_0: () = ();
        // S s_509_1: call HDCR_read(s_509_0)
        let s_509_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_509_0);
        // C s_509_2: const #0u : u8
        let s_509_2: bool = false;
        // S s_509_3: call _update_HDCR_Type_TPMCR(s_509_1, s_509_2)
        let s_509_3: ProductType700c18a878c5601b = u_update_HDCR_Type_TPMCR(
            state,
            tracer,
            s_509_1,
            s_509_2,
        );
        // S s_509_4: call HDCR_write(s_509_3)
        let s_509_4: () = HDCR_write(state, tracer, s_509_3);
        // N s_509_5: jump b286
        return block_286(state, tracer, fn_state);
    }
    fn block_510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_510_0: const #"the PE resets into EL2 or EL3" : str
        let s_510_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_510_1: call __IMPDEF_boolean(s_510_0)
        let s_510_1: bool = u__IMPDEF_boolean(state, tracer, s_510_0);
        // D s_510_2: write-var gs#44431 <= s_510_1
        fn_state.gs_44431 = s_510_1;
        // N s_510_3: jump b284
        return block_284(state, tracer, fn_state);
    }
    fn block_511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_511_0: const #() : ()
        let s_511_0: () = ();
        // S s_511_1: call HDCR_read(s_511_0)
        let s_511_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_511_0);
        // C s_511_2: const #0u : u8
        let s_511_2: bool = false;
        // S s_511_3: call _update_HDCR_Type_TPM(s_511_1, s_511_2)
        let s_511_3: ProductType700c18a878c5601b = u_update_HDCR_Type_TPM(
            state,
            tracer,
            s_511_1,
            s_511_2,
        );
        // S s_511_4: call HDCR_write(s_511_3)
        let s_511_4: () = HDCR_write(state, tracer, s_511_3);
        // N s_511_5: jump b282
        return block_282(state, tracer, fn_state);
    }
    fn block_512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_512_0: const #() : ()
        let s_512_0: () = ();
        // S s_512_1: call HaveAArch64(s_512_0)
        let s_512_1: bool = HaveAArch64(state, tracer, s_512_0);
        // S s_512_2: not s_512_1
        let s_512_2: bool = !s_512_1;
        // D s_512_3: write-var gs#44430 <= s_512_2
        fn_state.gs_44430 = s_512_2;
        // N s_512_4: jump b280
        return block_280(state, tracer, fn_state);
    }
    fn block_513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_513_0: const #() : ()
        let s_513_0: () = ();
        // S s_513_1: call HDCR_read(s_513_0)
        let s_513_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_513_0);
        // C s_513_2: const #0u : u8
        let s_513_2: bool = false;
        // S s_513_3: call _update_HDCR_Type_HPME(s_513_1, s_513_2)
        let s_513_3: ProductType700c18a878c5601b = u_update_HDCR_Type_HPME(
            state,
            tracer,
            s_513_1,
            s_513_2,
        );
        // S s_513_4: call HDCR_write(s_513_3)
        let s_513_4: () = HDCR_write(state, tracer, s_513_3);
        // N s_513_5: jump b278
        return block_278(state, tracer, fn_state);
    }
    fn block_514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_514_0: const #() : ()
        let s_514_0: () = ();
        // S s_514_1: call HaveAArch64(s_514_0)
        let s_514_1: bool = HaveAArch64(state, tracer, s_514_0);
        // S s_514_2: not s_514_1
        let s_514_2: bool = !s_514_1;
        // D s_514_3: write-var gs#44429 <= s_514_2
        fn_state.gs_44429 = s_514_2;
        // N s_514_4: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_515_0: const #() : ()
        let s_515_0: () = ();
        // S s_515_1: call HDCR_read(s_515_0)
        let s_515_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_515_0);
        // C s_515_2: const #0u : u8
        let s_515_2: bool = false;
        // S s_515_3: call _update_HDCR_Type_TDE(s_515_1, s_515_2)
        let s_515_3: ProductType700c18a878c5601b = u_update_HDCR_Type_TDE(
            state,
            tracer,
            s_515_1,
            s_515_2,
        );
        // S s_515_4: call HDCR_write(s_515_3)
        let s_515_4: () = HDCR_write(state, tracer, s_515_3);
        // N s_515_5: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_516_0: const #"the PE resets into EL2 or EL3" : str
        let s_516_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_516_1: call __IMPDEF_boolean(s_516_0)
        let s_516_1: bool = u__IMPDEF_boolean(state, tracer, s_516_0);
        // D s_516_2: write-var gs#44428 <= s_516_1
        fn_state.gs_44428 = s_516_1;
        // N s_516_3: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_517_0: const #() : ()
        let s_517_0: () = ();
        // S s_517_1: call HDCR_read(s_517_0)
        let s_517_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_517_0);
        // C s_517_2: const #0u : u8
        let s_517_2: bool = false;
        // S s_517_3: call _update_HDCR_Type_TDA(s_517_1, s_517_2)
        let s_517_3: ProductType700c18a878c5601b = u_update_HDCR_Type_TDA(
            state,
            tracer,
            s_517_1,
            s_517_2,
        );
        // S s_517_4: call HDCR_write(s_517_3)
        let s_517_4: () = HDCR_write(state, tracer, s_517_3);
        // N s_517_5: jump b270
        return block_270(state, tracer, fn_state);
    }
    fn block_518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_518_0: const #"the PE resets into EL2 or EL3" : str
        let s_518_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_518_1: call __IMPDEF_boolean(s_518_0)
        let s_518_1: bool = u__IMPDEF_boolean(state, tracer, s_518_0);
        // D s_518_2: write-var gs#44427 <= s_518_1
        fn_state.gs_44427 = s_518_1;
        // N s_518_3: jump b268
        return block_268(state, tracer, fn_state);
    }
    fn block_519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_519_0: const #() : ()
        let s_519_0: () = ();
        // S s_519_1: call HDCR_read(s_519_0)
        let s_519_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_519_0);
        // C s_519_2: const #0u : u8
        let s_519_2: bool = false;
        // S s_519_3: call _update_HDCR_Type_TDOSA(s_519_1, s_519_2)
        let s_519_3: ProductType700c18a878c5601b = u_update_HDCR_Type_TDOSA(
            state,
            tracer,
            s_519_1,
            s_519_2,
        );
        // S s_519_4: call HDCR_write(s_519_3)
        let s_519_4: () = HDCR_write(state, tracer, s_519_3);
        // N s_519_5: jump b266
        return block_266(state, tracer, fn_state);
    }
    fn block_520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_520_0: const #"the PE resets into EL2 or EL3" : str
        let s_520_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_520_1: call __IMPDEF_boolean(s_520_0)
        let s_520_1: bool = u__IMPDEF_boolean(state, tracer, s_520_0);
        // D s_520_2: write-var gs#44426 <= s_520_1
        fn_state.gs_44426 = s_520_1;
        // N s_520_3: jump b264
        return block_264(state, tracer, fn_state);
    }
    fn block_521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_521_0: const #() : ()
        let s_521_0: () = ();
        // S s_521_1: call HDCR_read(s_521_0)
        let s_521_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_521_0);
        // C s_521_2: const #0u : u8
        let s_521_2: bool = false;
        // S s_521_3: call _update_HDCR_Type_TDRA(s_521_1, s_521_2)
        let s_521_3: ProductType700c18a878c5601b = u_update_HDCR_Type_TDRA(
            state,
            tracer,
            s_521_1,
            s_521_2,
        );
        // S s_521_4: call HDCR_write(s_521_3)
        let s_521_4: () = HDCR_write(state, tracer, s_521_3);
        // N s_521_5: jump b262
        return block_262(state, tracer, fn_state);
    }
    fn block_522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_522_0: const #"the PE resets into EL2 or EL3" : str
        let s_522_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_522_1: call __IMPDEF_boolean(s_522_0)
        let s_522_1: bool = u__IMPDEF_boolean(state, tracer, s_522_0);
        // D s_522_2: write-var gs#44425 <= s_522_1
        fn_state.gs_44425 = s_522_1;
        // N s_522_3: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_523_0: const #() : ()
        let s_523_0: () = ();
        // S s_523_1: call HDCR_read(s_523_0)
        let s_523_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_523_0);
        // C s_523_2: const #0u : u8
        let s_523_2: bool = false;
        // S s_523_3: call _update_HDCR_Type_HPMD(s_523_1, s_523_2)
        let s_523_3: ProductType700c18a878c5601b = u_update_HDCR_Type_HPMD(
            state,
            tracer,
            s_523_1,
            s_523_2,
        );
        // S s_523_4: call HDCR_write(s_523_3)
        let s_523_4: () = HDCR_write(state, tracer, s_523_3);
        // N s_523_5: jump b258
        return block_258(state, tracer, fn_state);
    }
    fn block_524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_524_0: const #() : ()
        let s_524_0: () = ();
        // S s_524_1: call HaveAArch64(s_524_0)
        let s_524_1: bool = HaveAArch64(state, tracer, s_524_0);
        // S s_524_2: not s_524_1
        let s_524_2: bool = !s_524_1;
        // D s_524_3: write-var gs#44421 <= s_524_2
        fn_state.gs_44421 = s_524_2;
        // N s_524_4: jump b256
        return block_256(state, tracer, fn_state);
    }
    fn block_525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_525_0: const #() : ()
        let s_525_0: () = ();
        // S s_525_1: call HDCR_read(s_525_0)
        let s_525_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_525_0);
        // C s_525_2: const #0u : u8
        let s_525_2: bool = false;
        // S s_525_3: call _update_HDCR_Type_TTRF(s_525_1, s_525_2)
        let s_525_3: ProductType700c18a878c5601b = u_update_HDCR_Type_TTRF(
            state,
            tracer,
            s_525_1,
            s_525_2,
        );
        // S s_525_4: call HDCR_write(s_525_3)
        let s_525_4: () = HDCR_write(state, tracer, s_525_3);
        // N s_525_5: jump b254
        return block_254(state, tracer, fn_state);
    }
    fn block_526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_526_0: const #"the PE resets into EL2 or EL3" : str
        let s_526_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_526_1: call __IMPDEF_boolean(s_526_0)
        let s_526_1: bool = u__IMPDEF_boolean(state, tracer, s_526_0);
        // D s_526_2: write-var gs#44417 <= s_526_1
        fn_state.gs_44417 = s_526_1;
        // N s_526_3: jump b252
        return block_252(state, tracer, fn_state);
    }
    fn block_527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_527_0: const #() : ()
        let s_527_0: () = ();
        // S s_527_1: call HDCR_read(s_527_0)
        let s_527_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_527_0);
        // C s_527_2: const #0u : u8
        let s_527_2: bool = false;
        // S s_527_3: call _update_HDCR_Type_HCCD(s_527_1, s_527_2)
        let s_527_3: ProductType700c18a878c5601b = u_update_HDCR_Type_HCCD(
            state,
            tracer,
            s_527_1,
            s_527_2,
        );
        // S s_527_4: call HDCR_write(s_527_3)
        let s_527_4: () = HDCR_write(state, tracer, s_527_3);
        // N s_527_5: jump b250
        return block_250(state, tracer, fn_state);
    }
    fn block_528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_528_0: const #"the PE resets into EL2 or EL3" : str
        let s_528_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_528_1: call __IMPDEF_boolean(s_528_0)
        let s_528_1: bool = u__IMPDEF_boolean(state, tracer, s_528_0);
        // D s_528_2: write-var gs#44413 <= s_528_1
        fn_state.gs_44413 = s_528_1;
        // N s_528_3: jump b248
        return block_248(state, tracer, fn_state);
    }
    fn block_529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_529_0: const #() : ()
        let s_529_0: () = ();
        // S s_529_1: call HDCR_read(s_529_0)
        let s_529_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_529_0);
        // C s_529_2: const #0u : u8
        let s_529_2: bool = false;
        // S s_529_3: call _update_HDCR_Type_TDCC(s_529_1, s_529_2)
        let s_529_3: ProductType700c18a878c5601b = u_update_HDCR_Type_TDCC(
            state,
            tracer,
            s_529_1,
            s_529_2,
        );
        // S s_529_4: call HDCR_write(s_529_3)
        let s_529_4: () = HDCR_write(state, tracer, s_529_3);
        // N s_529_5: jump b246
        return block_246(state, tracer, fn_state);
    }
    fn block_530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_530_0: const #"the PE resets into EL2 or EL3" : str
        let s_530_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_530_1: call __IMPDEF_boolean(s_530_0)
        let s_530_1: bool = u__IMPDEF_boolean(state, tracer, s_530_0);
        // D s_530_2: write-var gs#44409 <= s_530_1
        fn_state.gs_44409 = s_530_1;
        // N s_530_3: jump b244
        return block_244(state, tracer, fn_state);
    }
    fn block_531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_531_0: const #"the PE resets into EL2 or EL3" : str
        let s_531_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_531_1: call __IMPDEF_boolean(s_531_0)
        let s_531_1: bool = u__IMPDEF_boolean(state, tracer, s_531_0);
        // N s_531_2: jump b241
        return block_241(state, tracer, fn_state);
    }
    fn block_532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_532_0: const #() : ()
        let s_532_0: () = ();
        // S s_532_1: call HDCR_read(s_532_0)
        let s_532_1: ProductType700c18a878c5601b = HDCR_read(state, tracer, s_532_0);
        // C s_532_2: const #1s : i64
        let s_532_2: i64 = 1;
        // C s_532_3: cast zx s_532_2 -> i
        let s_532_3: i128 = (i128::try_from(s_532_2).unwrap());
        // S s_532_4: call __UNKNOWN_bits(s_532_3)
        let s_532_4: Bits = u__UNKNOWN_bits(state, tracer, s_532_3);
        // S s_532_5: cast reint s_532_4 -> u8
        let s_532_5: bool = ((s_532_4.value()) != 0);
        // S s_532_6: call _update_HDCR_Type_MTPME(s_532_1, s_532_5)
        let s_532_6: ProductType700c18a878c5601b = u_update_HDCR_Type_MTPME(
            state,
            tracer,
            s_532_1,
            s_532_5,
        );
        // S s_532_7: call HDCR_write(s_532_6)
        let s_532_7: () = HDCR_write(state, tracer, s_532_6);
        // N s_532_8: jump b242
        return block_242(state, tracer, fn_state);
    }
    fn block_533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_533_0: const #1u : u8
        let s_533_0: bool = true;
        // D s_533_1: write-var gs#44408 <= s_533_0
        fn_state.gs_44408 = s_533_0;
        // N s_533_2: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_534_0: const #() : ()
        let s_534_0: () = ();
        // S s_534_1: call DBGCLAIMSET_read(s_534_0)
        let s_534_1: ProductType700c18a878c5601b = DBGCLAIMSET_read(
            state,
            tracer,
            s_534_0,
        );
        // C s_534_2: const #0u : u8
        let s_534_2: u8 = 0;
        // S s_534_3: call _update_DBGCLAIMSET_Type_CLAIM(s_534_1, s_534_2)
        let s_534_3: ProductType700c18a878c5601b = u_update_DBGCLAIMSET_Type_CLAIM(
            state,
            tracer,
            s_534_1,
            s_534_2,
        );
        // S s_534_4: call DBGCLAIMSET_write(s_534_3)
        let s_534_4: () = DBGCLAIMSET_write(state, tracer, s_534_3);
        // N s_534_5: jump b236
        return block_236(state, tracer, fn_state);
    }
    fn block_535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_535_0: const #() : ()
        let s_535_0: () = ();
        // S s_535_1: call HSTR_read(s_535_0)
        let s_535_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_535_0);
        // C s_535_2: const #0u : u8
        let s_535_2: bool = false;
        // S s_535_3: call _update_HSTR_Type_T0(s_535_1, s_535_2)
        let s_535_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T0(
            state,
            tracer,
            s_535_1,
            s_535_2,
        );
        // S s_535_4: call HSTR_write(s_535_3)
        let s_535_4: () = HSTR_write(state, tracer, s_535_3);
        // N s_535_5: jump b234
        return block_234(state, tracer, fn_state);
    }
    fn block_536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_536_0: const #"the PE resets into EL2 or EL3" : str
        let s_536_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_536_1: call __IMPDEF_boolean(s_536_0)
        let s_536_1: bool = u__IMPDEF_boolean(state, tracer, s_536_0);
        // D s_536_2: write-var gs#44294 <= s_536_1
        fn_state.gs_44294 = s_536_1;
        // N s_536_3: jump b232
        return block_232(state, tracer, fn_state);
    }
    fn block_537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_537_0: const #() : ()
        let s_537_0: () = ();
        // S s_537_1: call HSTR_read(s_537_0)
        let s_537_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_537_0);
        // C s_537_2: const #0u : u8
        let s_537_2: bool = false;
        // S s_537_3: call _update_HSTR_Type_T1(s_537_1, s_537_2)
        let s_537_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T1(
            state,
            tracer,
            s_537_1,
            s_537_2,
        );
        // S s_537_4: call HSTR_write(s_537_3)
        let s_537_4: () = HSTR_write(state, tracer, s_537_3);
        // N s_537_5: jump b230
        return block_230(state, tracer, fn_state);
    }
    fn block_538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_538_0: const #"the PE resets into EL2 or EL3" : str
        let s_538_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_538_1: call __IMPDEF_boolean(s_538_0)
        let s_538_1: bool = u__IMPDEF_boolean(state, tracer, s_538_0);
        // D s_538_2: write-var gs#44293 <= s_538_1
        fn_state.gs_44293 = s_538_1;
        // N s_538_3: jump b228
        return block_228(state, tracer, fn_state);
    }
    fn block_539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_539_0: const #() : ()
        let s_539_0: () = ();
        // S s_539_1: call HSTR_read(s_539_0)
        let s_539_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_539_0);
        // C s_539_2: const #0u : u8
        let s_539_2: bool = false;
        // S s_539_3: call _update_HSTR_Type_T2(s_539_1, s_539_2)
        let s_539_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T2(
            state,
            tracer,
            s_539_1,
            s_539_2,
        );
        // S s_539_4: call HSTR_write(s_539_3)
        let s_539_4: () = HSTR_write(state, tracer, s_539_3);
        // N s_539_5: jump b226
        return block_226(state, tracer, fn_state);
    }
    fn block_540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_540_0: const #"the PE resets into EL2 or EL3" : str
        let s_540_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_540_1: call __IMPDEF_boolean(s_540_0)
        let s_540_1: bool = u__IMPDEF_boolean(state, tracer, s_540_0);
        // D s_540_2: write-var gs#44292 <= s_540_1
        fn_state.gs_44292 = s_540_1;
        // N s_540_3: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_541_0: const #() : ()
        let s_541_0: () = ();
        // S s_541_1: call HSTR_read(s_541_0)
        let s_541_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_541_0);
        // C s_541_2: const #0u : u8
        let s_541_2: bool = false;
        // S s_541_3: call _update_HSTR_Type_T3(s_541_1, s_541_2)
        let s_541_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T3(
            state,
            tracer,
            s_541_1,
            s_541_2,
        );
        // S s_541_4: call HSTR_write(s_541_3)
        let s_541_4: () = HSTR_write(state, tracer, s_541_3);
        // N s_541_5: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_542_0: const #"the PE resets into EL2 or EL3" : str
        let s_542_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_542_1: call __IMPDEF_boolean(s_542_0)
        let s_542_1: bool = u__IMPDEF_boolean(state, tracer, s_542_0);
        // D s_542_2: write-var gs#44291 <= s_542_1
        fn_state.gs_44291 = s_542_1;
        // N s_542_3: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_543_0: const #() : ()
        let s_543_0: () = ();
        // S s_543_1: call HSTR_read(s_543_0)
        let s_543_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_543_0);
        // C s_543_2: const #0u : u8
        let s_543_2: bool = false;
        // S s_543_3: call _update_HSTR_Type_T5(s_543_1, s_543_2)
        let s_543_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T5(
            state,
            tracer,
            s_543_1,
            s_543_2,
        );
        // S s_543_4: call HSTR_write(s_543_3)
        let s_543_4: () = HSTR_write(state, tracer, s_543_3);
        // N s_543_5: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_544_0: const #"the PE resets into EL2 or EL3" : str
        let s_544_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_544_1: call __IMPDEF_boolean(s_544_0)
        let s_544_1: bool = u__IMPDEF_boolean(state, tracer, s_544_0);
        // D s_544_2: write-var gs#44290 <= s_544_1
        fn_state.gs_44290 = s_544_1;
        // N s_544_3: jump b216
        return block_216(state, tracer, fn_state);
    }
    fn block_545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_545_0: const #() : ()
        let s_545_0: () = ();
        // S s_545_1: call HSTR_read(s_545_0)
        let s_545_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_545_0);
        // C s_545_2: const #0u : u8
        let s_545_2: bool = false;
        // S s_545_3: call _update_HSTR_Type_T6(s_545_1, s_545_2)
        let s_545_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T6(
            state,
            tracer,
            s_545_1,
            s_545_2,
        );
        // S s_545_4: call HSTR_write(s_545_3)
        let s_545_4: () = HSTR_write(state, tracer, s_545_3);
        // N s_545_5: jump b214
        return block_214(state, tracer, fn_state);
    }
    fn block_546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_546_0: const #"the PE resets into EL2 or EL3" : str
        let s_546_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_546_1: call __IMPDEF_boolean(s_546_0)
        let s_546_1: bool = u__IMPDEF_boolean(state, tracer, s_546_0);
        // D s_546_2: write-var gs#44289 <= s_546_1
        fn_state.gs_44289 = s_546_1;
        // N s_546_3: jump b212
        return block_212(state, tracer, fn_state);
    }
    fn block_547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_547_0: const #() : ()
        let s_547_0: () = ();
        // S s_547_1: call HSTR_read(s_547_0)
        let s_547_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_547_0);
        // C s_547_2: const #0u : u8
        let s_547_2: bool = false;
        // S s_547_3: call _update_HSTR_Type_T7(s_547_1, s_547_2)
        let s_547_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T7(
            state,
            tracer,
            s_547_1,
            s_547_2,
        );
        // S s_547_4: call HSTR_write(s_547_3)
        let s_547_4: () = HSTR_write(state, tracer, s_547_3);
        // N s_547_5: jump b210
        return block_210(state, tracer, fn_state);
    }
    fn block_548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_548_0: const #"the PE resets into EL2 or EL3" : str
        let s_548_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_548_1: call __IMPDEF_boolean(s_548_0)
        let s_548_1: bool = u__IMPDEF_boolean(state, tracer, s_548_0);
        // D s_548_2: write-var gs#44288 <= s_548_1
        fn_state.gs_44288 = s_548_1;
        // N s_548_3: jump b208
        return block_208(state, tracer, fn_state);
    }
    fn block_549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_549_0: const #() : ()
        let s_549_0: () = ();
        // S s_549_1: call HSTR_read(s_549_0)
        let s_549_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_549_0);
        // C s_549_2: const #0u : u8
        let s_549_2: bool = false;
        // S s_549_3: call _update_HSTR_Type_T8(s_549_1, s_549_2)
        let s_549_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T8(
            state,
            tracer,
            s_549_1,
            s_549_2,
        );
        // S s_549_4: call HSTR_write(s_549_3)
        let s_549_4: () = HSTR_write(state, tracer, s_549_3);
        // N s_549_5: jump b206
        return block_206(state, tracer, fn_state);
    }
    fn block_550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_550_0: const #"the PE resets into EL2 or EL3" : str
        let s_550_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_550_1: call __IMPDEF_boolean(s_550_0)
        let s_550_1: bool = u__IMPDEF_boolean(state, tracer, s_550_0);
        // D s_550_2: write-var gs#44287 <= s_550_1
        fn_state.gs_44287 = s_550_1;
        // N s_550_3: jump b204
        return block_204(state, tracer, fn_state);
    }
    fn block_551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_551_0: const #() : ()
        let s_551_0: () = ();
        // S s_551_1: call HSTR_read(s_551_0)
        let s_551_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_551_0);
        // C s_551_2: const #0u : u8
        let s_551_2: bool = false;
        // S s_551_3: call _update_HSTR_Type_T9(s_551_1, s_551_2)
        let s_551_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T9(
            state,
            tracer,
            s_551_1,
            s_551_2,
        );
        // S s_551_4: call HSTR_write(s_551_3)
        let s_551_4: () = HSTR_write(state, tracer, s_551_3);
        // N s_551_5: jump b202
        return block_202(state, tracer, fn_state);
    }
    fn block_552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_552_0: const #"the PE resets into EL2 or EL3" : str
        let s_552_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_552_1: call __IMPDEF_boolean(s_552_0)
        let s_552_1: bool = u__IMPDEF_boolean(state, tracer, s_552_0);
        // D s_552_2: write-var gs#44286 <= s_552_1
        fn_state.gs_44286 = s_552_1;
        // N s_552_3: jump b200
        return block_200(state, tracer, fn_state);
    }
    fn block_553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_553_0: const #() : ()
        let s_553_0: () = ();
        // S s_553_1: call HSTR_read(s_553_0)
        let s_553_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_553_0);
        // C s_553_2: const #0u : u8
        let s_553_2: bool = false;
        // S s_553_3: call _update_HSTR_Type_T10(s_553_1, s_553_2)
        let s_553_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T10(
            state,
            tracer,
            s_553_1,
            s_553_2,
        );
        // S s_553_4: call HSTR_write(s_553_3)
        let s_553_4: () = HSTR_write(state, tracer, s_553_3);
        // N s_553_5: jump b198
        return block_198(state, tracer, fn_state);
    }
    fn block_554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_554_0: const #"the PE resets into EL2 or EL3" : str
        let s_554_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_554_1: call __IMPDEF_boolean(s_554_0)
        let s_554_1: bool = u__IMPDEF_boolean(state, tracer, s_554_0);
        // D s_554_2: write-var gs#44285 <= s_554_1
        fn_state.gs_44285 = s_554_1;
        // N s_554_3: jump b196
        return block_196(state, tracer, fn_state);
    }
    fn block_555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_555_0: const #() : ()
        let s_555_0: () = ();
        // S s_555_1: call HSTR_read(s_555_0)
        let s_555_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_555_0);
        // C s_555_2: const #0u : u8
        let s_555_2: bool = false;
        // S s_555_3: call _update_HSTR_Type_T11(s_555_1, s_555_2)
        let s_555_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T11(
            state,
            tracer,
            s_555_1,
            s_555_2,
        );
        // S s_555_4: call HSTR_write(s_555_3)
        let s_555_4: () = HSTR_write(state, tracer, s_555_3);
        // N s_555_5: jump b194
        return block_194(state, tracer, fn_state);
    }
    fn block_556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_556_0: const #"the PE resets into EL2 or EL3" : str
        let s_556_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_556_1: call __IMPDEF_boolean(s_556_0)
        let s_556_1: bool = u__IMPDEF_boolean(state, tracer, s_556_0);
        // D s_556_2: write-var gs#44284 <= s_556_1
        fn_state.gs_44284 = s_556_1;
        // N s_556_3: jump b192
        return block_192(state, tracer, fn_state);
    }
    fn block_557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_557_0: const #() : ()
        let s_557_0: () = ();
        // S s_557_1: call HSTR_read(s_557_0)
        let s_557_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_557_0);
        // C s_557_2: const #0u : u8
        let s_557_2: bool = false;
        // S s_557_3: call _update_HSTR_Type_T12(s_557_1, s_557_2)
        let s_557_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T12(
            state,
            tracer,
            s_557_1,
            s_557_2,
        );
        // S s_557_4: call HSTR_write(s_557_3)
        let s_557_4: () = HSTR_write(state, tracer, s_557_3);
        // N s_557_5: jump b190
        return block_190(state, tracer, fn_state);
    }
    fn block_558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_558_0: const #"the PE resets into EL2 or EL3" : str
        let s_558_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_558_1: call __IMPDEF_boolean(s_558_0)
        let s_558_1: bool = u__IMPDEF_boolean(state, tracer, s_558_0);
        // D s_558_2: write-var gs#44283 <= s_558_1
        fn_state.gs_44283 = s_558_1;
        // N s_558_3: jump b188
        return block_188(state, tracer, fn_state);
    }
    fn block_559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_559_0: const #() : ()
        let s_559_0: () = ();
        // S s_559_1: call HSTR_read(s_559_0)
        let s_559_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_559_0);
        // C s_559_2: const #0u : u8
        let s_559_2: bool = false;
        // S s_559_3: call _update_HSTR_Type_T13(s_559_1, s_559_2)
        let s_559_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T13(
            state,
            tracer,
            s_559_1,
            s_559_2,
        );
        // S s_559_4: call HSTR_write(s_559_3)
        let s_559_4: () = HSTR_write(state, tracer, s_559_3);
        // N s_559_5: jump b186
        return block_186(state, tracer, fn_state);
    }
    fn block_560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_560_0: const #"the PE resets into EL2 or EL3" : str
        let s_560_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_560_1: call __IMPDEF_boolean(s_560_0)
        let s_560_1: bool = u__IMPDEF_boolean(state, tracer, s_560_0);
        // D s_560_2: write-var gs#44282 <= s_560_1
        fn_state.gs_44282 = s_560_1;
        // N s_560_3: jump b184
        return block_184(state, tracer, fn_state);
    }
    fn block_561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_561_0: const #() : ()
        let s_561_0: () = ();
        // S s_561_1: call HSTR_read(s_561_0)
        let s_561_1: ProductType700c18a878c5601b = HSTR_read(state, tracer, s_561_0);
        // C s_561_2: const #0u : u8
        let s_561_2: bool = false;
        // S s_561_3: call _update_HSTR_Type_T15(s_561_1, s_561_2)
        let s_561_3: ProductType700c18a878c5601b = u_update_HSTR_Type_T15(
            state,
            tracer,
            s_561_1,
            s_561_2,
        );
        // S s_561_4: call HSTR_write(s_561_3)
        let s_561_4: () = HSTR_write(state, tracer, s_561_3);
        // N s_561_5: jump b182
        return block_182(state, tracer, fn_state);
    }
    fn block_562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_562_0: const #"the PE resets into EL2 or EL3" : str
        let s_562_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_562_1: call __IMPDEF_boolean(s_562_0)
        let s_562_1: bool = u__IMPDEF_boolean(state, tracer, s_562_0);
        // D s_562_2: write-var gs#44281 <= s_562_1
        fn_state.gs_44281 = s_562_1;
        // N s_562_3: jump b180
        return block_180(state, tracer, fn_state);
    }
    fn block_563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_563_0: const #() : ()
        let s_563_0: () = ();
        // S s_563_1: call HCR2_read(s_563_0)
        let s_563_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_563_0);
        // C s_563_2: const #0u : u8
        let s_563_2: bool = false;
        // S s_563_3: call _update_HCR2_Type_CD(s_563_1, s_563_2)
        let s_563_3: ProductType700c18a878c5601b = u_update_HCR2_Type_CD(
            state,
            tracer,
            s_563_1,
            s_563_2,
        );
        // S s_563_4: call HCR2_write(s_563_3)
        let s_563_4: () = HCR2_write(state, tracer, s_563_3);
        // N s_563_5: jump b178
        return block_178(state, tracer, fn_state);
    }
    fn block_564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_564_0: const #"the PE resets into EL2 or EL3" : str
        let s_564_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_564_1: call __IMPDEF_boolean(s_564_0)
        let s_564_1: bool = u__IMPDEF_boolean(state, tracer, s_564_0);
        // D s_564_2: write-var gs#44123 <= s_564_1
        fn_state.gs_44123 = s_564_1;
        // N s_564_3: jump b176
        return block_176(state, tracer, fn_state);
    }
    fn block_565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_565_0: const #() : ()
        let s_565_0: () = ();
        // S s_565_1: call HCR2_read(s_565_0)
        let s_565_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_565_0);
        // C s_565_2: const #0u : u8
        let s_565_2: bool = false;
        // S s_565_3: call _update_HCR2_Type_ID(s_565_1, s_565_2)
        let s_565_3: ProductType700c18a878c5601b = u_update_HCR2_Type_ID(
            state,
            tracer,
            s_565_1,
            s_565_2,
        );
        // S s_565_4: call HCR2_write(s_565_3)
        let s_565_4: () = HCR2_write(state, tracer, s_565_3);
        // N s_565_5: jump b174
        return block_174(state, tracer, fn_state);
    }
    fn block_566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_566_0: const #"the PE resets into EL2 or EL3" : str
        let s_566_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_566_1: call __IMPDEF_boolean(s_566_0)
        let s_566_1: bool = u__IMPDEF_boolean(state, tracer, s_566_0);
        // D s_566_2: write-var gs#44122 <= s_566_1
        fn_state.gs_44122 = s_566_1;
        // N s_566_3: jump b172
        return block_172(state, tracer, fn_state);
    }
    fn block_567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_567_0: const #() : ()
        let s_567_0: () = ();
        // S s_567_1: call HCR2_read(s_567_0)
        let s_567_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_567_0);
        // C s_567_2: const #0u : u8
        let s_567_2: bool = false;
        // S s_567_3: call _update_HCR2_Type_TERR(s_567_1, s_567_2)
        let s_567_3: ProductType700c18a878c5601b = u_update_HCR2_Type_TERR(
            state,
            tracer,
            s_567_1,
            s_567_2,
        );
        // S s_567_4: call HCR2_write(s_567_3)
        let s_567_4: () = HCR2_write(state, tracer, s_567_3);
        // N s_567_5: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_568_0: const #"the PE resets into EL2 or EL3" : str
        let s_568_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_568_1: call __IMPDEF_boolean(s_568_0)
        let s_568_1: bool = u__IMPDEF_boolean(state, tracer, s_568_0);
        // D s_568_2: write-var gs#44118 <= s_568_1
        fn_state.gs_44118 = s_568_1;
        // N s_568_3: jump b168
        return block_168(state, tracer, fn_state);
    }
    fn block_569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_569_0: const #() : ()
        let s_569_0: () = ();
        // S s_569_1: call HCR2_read(s_569_0)
        let s_569_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_569_0);
        // C s_569_2: const #0u : u8
        let s_569_2: bool = false;
        // S s_569_3: call _update_HCR2_Type_TEA(s_569_1, s_569_2)
        let s_569_3: ProductType700c18a878c5601b = u_update_HCR2_Type_TEA(
            state,
            tracer,
            s_569_1,
            s_569_2,
        );
        // S s_569_4: call HCR2_write(s_569_3)
        let s_569_4: () = HCR2_write(state, tracer, s_569_3);
        // N s_569_5: jump b166
        return block_166(state, tracer, fn_state);
    }
    fn block_570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_570_0: const #"the PE resets into EL2 or EL3" : str
        let s_570_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_570_1: call __IMPDEF_boolean(s_570_0)
        let s_570_1: bool = u__IMPDEF_boolean(state, tracer, s_570_0);
        // D s_570_2: write-var gs#44117 <= s_570_1
        fn_state.gs_44117 = s_570_1;
        // N s_570_3: jump b164
        return block_164(state, tracer, fn_state);
    }
    fn block_571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_571_0: const #() : ()
        let s_571_0: () = ();
        // S s_571_1: call HCR2_read(s_571_0)
        let s_571_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_571_0);
        // C s_571_2: const #0u : u8
        let s_571_2: bool = false;
        // S s_571_3: call _update_HCR2_Type_TID4(s_571_1, s_571_2)
        let s_571_3: ProductType700c18a878c5601b = u_update_HCR2_Type_TID4(
            state,
            tracer,
            s_571_1,
            s_571_2,
        );
        // S s_571_4: call HCR2_write(s_571_3)
        let s_571_4: () = HCR2_write(state, tracer, s_571_3);
        // N s_571_5: jump b162
        return block_162(state, tracer, fn_state);
    }
    fn block_572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_572_0: const #"the PE resets into EL2 or EL3" : str
        let s_572_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_572_1: call __IMPDEF_boolean(s_572_0)
        let s_572_1: bool = u__IMPDEF_boolean(state, tracer, s_572_0);
        // D s_572_2: write-var gs#44113 <= s_572_1
        fn_state.gs_44113 = s_572_1;
        // N s_572_3: jump b160
        return block_160(state, tracer, fn_state);
    }
    fn block_573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_573_0: const #() : ()
        let s_573_0: () = ();
        // S s_573_1: call HCR2_read(s_573_0)
        let s_573_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_573_0);
        // C s_573_2: const #0u : u8
        let s_573_2: bool = false;
        // S s_573_3: call _update_HCR2_Type_TICAB(s_573_1, s_573_2)
        let s_573_3: ProductType700c18a878c5601b = u_update_HCR2_Type_TICAB(
            state,
            tracer,
            s_573_1,
            s_573_2,
        );
        // S s_573_4: call HCR2_write(s_573_3)
        let s_573_4: () = HCR2_write(state, tracer, s_573_3);
        // N s_573_5: jump b158
        return block_158(state, tracer, fn_state);
    }
    fn block_574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_574_0: const #"the PE resets into EL2 or EL3" : str
        let s_574_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_574_1: call __IMPDEF_boolean(s_574_0)
        let s_574_1: bool = u__IMPDEF_boolean(state, tracer, s_574_0);
        // D s_574_2: write-var gs#44112 <= s_574_1
        fn_state.gs_44112 = s_574_1;
        // N s_574_3: jump b156
        return block_156(state, tracer, fn_state);
    }
    fn block_575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_575_0: const #() : ()
        let s_575_0: () = ();
        // S s_575_1: call HCR2_read(s_575_0)
        let s_575_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_575_0);
        // C s_575_2: const #0u : u8
        let s_575_2: bool = false;
        // S s_575_3: call _update_HCR2_Type_TOCU(s_575_1, s_575_2)
        let s_575_3: ProductType700c18a878c5601b = u_update_HCR2_Type_TOCU(
            state,
            tracer,
            s_575_1,
            s_575_2,
        );
        // S s_575_4: call HCR2_write(s_575_3)
        let s_575_4: () = HCR2_write(state, tracer, s_575_3);
        // N s_575_5: jump b154
        return block_154(state, tracer, fn_state);
    }
    fn block_576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_576_0: const #"the PE resets into EL2 or EL3" : str
        let s_576_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_576_1: call __IMPDEF_boolean(s_576_0)
        let s_576_1: bool = u__IMPDEF_boolean(state, tracer, s_576_0);
        // D s_576_2: write-var gs#44108 <= s_576_1
        fn_state.gs_44108 = s_576_1;
        // N s_576_3: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_577_0: const #() : ()
        let s_577_0: () = ();
        // S s_577_1: call HCR2_read(s_577_0)
        let s_577_1: ProductType700c18a878c5601b = HCR2_read(state, tracer, s_577_0);
        // C s_577_2: const #0u : u8
        let s_577_2: bool = false;
        // S s_577_3: call _update_HCR2_Type_TTLBIS(s_577_1, s_577_2)
        let s_577_3: ProductType700c18a878c5601b = u_update_HCR2_Type_TTLBIS(
            state,
            tracer,
            s_577_1,
            s_577_2,
        );
        // S s_577_4: call HCR2_write(s_577_3)
        let s_577_4: () = HCR2_write(state, tracer, s_577_3);
        // N s_577_5: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_578_0: const #"the PE resets into EL2 or EL3" : str
        let s_578_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_578_1: call __IMPDEF_boolean(s_578_0)
        let s_578_1: bool = u__IMPDEF_boolean(state, tracer, s_578_0);
        // D s_578_2: write-var gs#44104 <= s_578_1
        fn_state.gs_44104 = s_578_1;
        // N s_578_3: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_579_0: const #() : ()
        let s_579_0: () = ();
        // S s_579_1: call DBGCLAIMCLR_read(s_579_0)
        let s_579_1: ProductType700c18a878c5601b = DBGCLAIMCLR_read(
            state,
            tracer,
            s_579_0,
        );
        // C s_579_2: const #0u : u8
        let s_579_2: u8 = 0;
        // S s_579_3: call _update_DBGCLAIMCLR_Type_CLAIM(s_579_1, s_579_2)
        let s_579_3: ProductType700c18a878c5601b = u_update_DBGCLAIMCLR_Type_CLAIM(
            state,
            tracer,
            s_579_1,
            s_579_2,
        );
        // S s_579_4: call DBGCLAIMCLR_write(s_579_3)
        let s_579_4: () = DBGCLAIMCLR_write(state, tracer, s_579_3);
        // N s_579_5: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_580_0: const #() : ()
        let s_580_0: () = ();
        // S s_580_1: call HCPTR_read(s_580_0)
        let s_580_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_580_0);
        // C s_580_2: const #0u : u8
        let s_580_2: bool = false;
        // S s_580_3: call _update_HCPTR_Type_TCP10(s_580_1, s_580_2)
        let s_580_3: ProductType700c18a878c5601b = u_update_HCPTR_Type_TCP10(
            state,
            tracer,
            s_580_1,
            s_580_2,
        );
        // S s_580_4: call HCPTR_write(s_580_3)
        let s_580_4: () = HCPTR_write(state, tracer, s_580_3);
        // N s_580_5: jump b144
        return block_144(state, tracer, fn_state);
    }
    fn block_581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_581_0: const #"the PE resets into EL2 or EL3" : str
        let s_581_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_581_1: call __IMPDEF_boolean(s_581_0)
        let s_581_1: bool = u__IMPDEF_boolean(state, tracer, s_581_0);
        // D s_581_2: write-var gs#44040 <= s_581_1
        fn_state.gs_44040 = s_581_1;
        // N s_581_3: jump b142
        return block_142(state, tracer, fn_state);
    }
    fn block_582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_582_0: const #() : ()
        let s_582_0: () = ();
        // S s_582_1: call HCPTR_read(s_582_0)
        let s_582_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_582_0);
        // C s_582_2: const #0u : u8
        let s_582_2: bool = false;
        // S s_582_3: call _update_HCPTR_Type_TCP11(s_582_1, s_582_2)
        let s_582_3: ProductType700c18a878c5601b = u_update_HCPTR_Type_TCP11(
            state,
            tracer,
            s_582_1,
            s_582_2,
        );
        // S s_582_4: call HCPTR_write(s_582_3)
        let s_582_4: () = HCPTR_write(state, tracer, s_582_3);
        // N s_582_5: jump b140
        return block_140(state, tracer, fn_state);
    }
    fn block_583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_583_0: const #"the PE resets into EL2 or EL3" : str
        let s_583_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_583_1: call __IMPDEF_boolean(s_583_0)
        let s_583_1: bool = u__IMPDEF_boolean(state, tracer, s_583_0);
        // D s_583_2: write-var gs#44039 <= s_583_1
        fn_state.gs_44039 = s_583_1;
        // N s_583_3: jump b138
        return block_138(state, tracer, fn_state);
    }
    fn block_584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_584_0: const #() : ()
        let s_584_0: () = ();
        // S s_584_1: call HCPTR_read(s_584_0)
        let s_584_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_584_0);
        // C s_584_2: const #0u : u8
        let s_584_2: bool = false;
        // S s_584_3: call _update_HCPTR_Type_TASE(s_584_1, s_584_2)
        let s_584_3: ProductType700c18a878c5601b = u_update_HCPTR_Type_TASE(
            state,
            tracer,
            s_584_1,
            s_584_2,
        );
        // S s_584_4: call HCPTR_write(s_584_3)
        let s_584_4: () = HCPTR_write(state, tracer, s_584_3);
        // N s_584_5: jump b136
        return block_136(state, tracer, fn_state);
    }
    fn block_585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_585_0: const #"the PE resets into EL2 or EL3" : str
        let s_585_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_585_1: call __IMPDEF_boolean(s_585_0)
        let s_585_1: bool = u__IMPDEF_boolean(state, tracer, s_585_0);
        // D s_585_2: write-var gs#44032 <= s_585_1
        fn_state.gs_44032 = s_585_1;
        // N s_585_3: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_586_0: const #() : ()
        let s_586_0: () = ();
        // S s_586_1: call HCPTR_read(s_586_0)
        let s_586_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_586_0);
        // C s_586_2: const #0u : u8
        let s_586_2: bool = false;
        // S s_586_3: call _update_HCPTR_Type_TTA(s_586_1, s_586_2)
        let s_586_3: ProductType700c18a878c5601b = u_update_HCPTR_Type_TTA(
            state,
            tracer,
            s_586_1,
            s_586_2,
        );
        // S s_586_4: call HCPTR_write(s_586_3)
        let s_586_4: () = HCPTR_write(state, tracer, s_586_3);
        // N s_586_5: jump b132
        return block_132(state, tracer, fn_state);
    }
    fn block_587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_587_0: const #"the PE resets into EL2 or EL3" : str
        let s_587_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_587_1: call __IMPDEF_boolean(s_587_0)
        let s_587_1: bool = u__IMPDEF_boolean(state, tracer, s_587_0);
        // D s_587_2: write-var gs#44028 <= s_587_1
        fn_state.gs_44028 = s_587_1;
        // N s_587_3: jump b130
        return block_130(state, tracer, fn_state);
    }
    fn block_588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_588_0: const #() : ()
        let s_588_0: () = ();
        // S s_588_1: call HCPTR_read(s_588_0)
        let s_588_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_588_0);
        // C s_588_2: const #0u : u8
        let s_588_2: bool = false;
        // S s_588_3: call _update_HCPTR_Type_TAM(s_588_1, s_588_2)
        let s_588_3: ProductType700c18a878c5601b = u_update_HCPTR_Type_TAM(
            state,
            tracer,
            s_588_1,
            s_588_2,
        );
        // S s_588_4: call HCPTR_write(s_588_3)
        let s_588_4: () = HCPTR_write(state, tracer, s_588_3);
        // N s_588_5: jump b128
        return block_128(state, tracer, fn_state);
    }
    fn block_589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_589_0: const #"the PE resets into EL2 or EL3" : str
        let s_589_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_589_1: call __IMPDEF_boolean(s_589_0)
        let s_589_1: bool = u__IMPDEF_boolean(state, tracer, s_589_0);
        // D s_589_2: write-var gs#44024 <= s_589_1
        fn_state.gs_44024 = s_589_1;
        // N s_589_3: jump b126
        return block_126(state, tracer, fn_state);
    }
    fn block_590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_590_0: const #() : ()
        let s_590_0: () = ();
        // S s_590_1: call HCPTR_read(s_590_0)
        let s_590_1: ProductType700c18a878c5601b = HCPTR_read(state, tracer, s_590_0);
        // C s_590_2: const #0u : u8
        let s_590_2: bool = false;
        // S s_590_3: call _update_HCPTR_Type_TCPAC(s_590_1, s_590_2)
        let s_590_3: ProductType700c18a878c5601b = u_update_HCPTR_Type_TCPAC(
            state,
            tracer,
            s_590_1,
            s_590_2,
        );
        // S s_590_4: call HCPTR_write(s_590_3)
        let s_590_4: () = HCPTR_write(state, tracer, s_590_3);
        // N s_590_5: jump b124
        return block_124(state, tracer, fn_state);
    }
    fn block_591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_591_0: const #"the PE resets into EL2 or EL3" : str
        let s_591_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_591_1: call __IMPDEF_boolean(s_591_0)
        let s_591_1: bool = u__IMPDEF_boolean(state, tracer, s_591_0);
        // D s_591_2: write-var gs#44023 <= s_591_1
        fn_state.gs_44023 = s_591_1;
        // N s_591_3: jump b122
        return block_122(state, tracer, fn_state);
    }
    fn block_592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_592_0: const #() : ()
        let s_592_0: () = ();
        // S s_592_1: call HCR_read(s_592_0)
        let s_592_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_592_0);
        // C s_592_2: const #0u : u8
        let s_592_2: bool = false;
        // S s_592_3: call _update_HCR_Type_VM(s_592_1, s_592_2)
        let s_592_3: ProductType700c18a878c5601b = u_update_HCR_Type_VM(
            state,
            tracer,
            s_592_1,
            s_592_2,
        );
        // S s_592_4: call HCR_write(s_592_3)
        let s_592_4: () = HCR_write(state, tracer, s_592_3);
        // N s_592_5: jump b120
        return block_120(state, tracer, fn_state);
    }
    fn block_593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_593_0: const #"the PE resets into EL2 or EL3" : str
        let s_593_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_593_1: call __IMPDEF_boolean(s_593_0)
        let s_593_1: bool = u__IMPDEF_boolean(state, tracer, s_593_0);
        // D s_593_2: write-var gs#44011 <= s_593_1
        fn_state.gs_44011 = s_593_1;
        // N s_593_3: jump b118
        return block_118(state, tracer, fn_state);
    }
    fn block_594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_594_0: const #() : ()
        let s_594_0: () = ();
        // S s_594_1: call HCR_read(s_594_0)
        let s_594_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_594_0);
        // C s_594_2: const #0u : u8
        let s_594_2: bool = false;
        // S s_594_3: call _update_HCR_Type_SWIO(s_594_1, s_594_2)
        let s_594_3: ProductType700c18a878c5601b = u_update_HCR_Type_SWIO(
            state,
            tracer,
            s_594_1,
            s_594_2,
        );
        // S s_594_4: call HCR_write(s_594_3)
        let s_594_4: () = HCR_write(state, tracer, s_594_3);
        // N s_594_5: jump b116
        return block_116(state, tracer, fn_state);
    }
    fn block_595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_595_0: const #"the PE resets into EL2 or EL3" : str
        let s_595_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_595_1: call __IMPDEF_boolean(s_595_0)
        let s_595_1: bool = u__IMPDEF_boolean(state, tracer, s_595_0);
        // D s_595_2: write-var gs#44010 <= s_595_1
        fn_state.gs_44010 = s_595_1;
        // N s_595_3: jump b114
        return block_114(state, tracer, fn_state);
    }
    fn block_596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_596_0: const #() : ()
        let s_596_0: () = ();
        // S s_596_1: call HCR_read(s_596_0)
        let s_596_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_596_0);
        // C s_596_2: const #0u : u8
        let s_596_2: bool = false;
        // S s_596_3: call _update_HCR_Type_PTW(s_596_1, s_596_2)
        let s_596_3: ProductType700c18a878c5601b = u_update_HCR_Type_PTW(
            state,
            tracer,
            s_596_1,
            s_596_2,
        );
        // S s_596_4: call HCR_write(s_596_3)
        let s_596_4: () = HCR_write(state, tracer, s_596_3);
        // N s_596_5: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_597_0: const #"the PE resets into EL2 or EL3" : str
        let s_597_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_597_1: call __IMPDEF_boolean(s_597_0)
        let s_597_1: bool = u__IMPDEF_boolean(state, tracer, s_597_0);
        // D s_597_2: write-var gs#44009 <= s_597_1
        fn_state.gs_44009 = s_597_1;
        // N s_597_3: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_598_0: const #() : ()
        let s_598_0: () = ();
        // S s_598_1: call HCR_read(s_598_0)
        let s_598_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_598_0);
        // C s_598_2: const #0u : u8
        let s_598_2: bool = false;
        // S s_598_3: call _update_HCR_Type_FMO(s_598_1, s_598_2)
        let s_598_3: ProductType700c18a878c5601b = u_update_HCR_Type_FMO(
            state,
            tracer,
            s_598_1,
            s_598_2,
        );
        // S s_598_4: call HCR_write(s_598_3)
        let s_598_4: () = HCR_write(state, tracer, s_598_3);
        // N s_598_5: jump b108
        return block_108(state, tracer, fn_state);
    }
    fn block_599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_599_0: const #"the PE resets into EL2 or EL3" : str
        let s_599_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_599_1: call __IMPDEF_boolean(s_599_0)
        let s_599_1: bool = u__IMPDEF_boolean(state, tracer, s_599_0);
        // D s_599_2: write-var gs#44008 <= s_599_1
        fn_state.gs_44008 = s_599_1;
        // N s_599_3: jump b106
        return block_106(state, tracer, fn_state);
    }
    fn block_600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_600_0: const #() : ()
        let s_600_0: () = ();
        // S s_600_1: call HCR_read(s_600_0)
        let s_600_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_600_0);
        // C s_600_2: const #0u : u8
        let s_600_2: bool = false;
        // S s_600_3: call _update_HCR_Type_IMO(s_600_1, s_600_2)
        let s_600_3: ProductType700c18a878c5601b = u_update_HCR_Type_IMO(
            state,
            tracer,
            s_600_1,
            s_600_2,
        );
        // S s_600_4: call HCR_write(s_600_3)
        let s_600_4: () = HCR_write(state, tracer, s_600_3);
        // N s_600_5: jump b104
        return block_104(state, tracer, fn_state);
    }
    fn block_601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_601_0: const #"the PE resets into EL2 or EL3" : str
        let s_601_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_601_1: call __IMPDEF_boolean(s_601_0)
        let s_601_1: bool = u__IMPDEF_boolean(state, tracer, s_601_0);
        // D s_601_2: write-var gs#44007 <= s_601_1
        fn_state.gs_44007 = s_601_1;
        // N s_601_3: jump b102
        return block_102(state, tracer, fn_state);
    }
    fn block_602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_602_0: const #() : ()
        let s_602_0: () = ();
        // S s_602_1: call HCR_read(s_602_0)
        let s_602_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_602_0);
        // C s_602_2: const #0u : u8
        let s_602_2: bool = false;
        // S s_602_3: call _update_HCR_Type_AMO(s_602_1, s_602_2)
        let s_602_3: ProductType700c18a878c5601b = u_update_HCR_Type_AMO(
            state,
            tracer,
            s_602_1,
            s_602_2,
        );
        // S s_602_4: call HCR_write(s_602_3)
        let s_602_4: () = HCR_write(state, tracer, s_602_3);
        // N s_602_5: jump b100
        return block_100(state, tracer, fn_state);
    }
    fn block_603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_603_0: const #"the PE resets into EL2 or EL3" : str
        let s_603_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_603_1: call __IMPDEF_boolean(s_603_0)
        let s_603_1: bool = u__IMPDEF_boolean(state, tracer, s_603_0);
        // D s_603_2: write-var gs#44006 <= s_603_1
        fn_state.gs_44006 = s_603_1;
        // N s_603_3: jump b98
        return block_98(state, tracer, fn_state);
    }
    fn block_604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_604_0: const #() : ()
        let s_604_0: () = ();
        // S s_604_1: call HCR_read(s_604_0)
        let s_604_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_604_0);
        // C s_604_2: const #0u : u8
        let s_604_2: bool = false;
        // S s_604_3: call _update_HCR_Type_VF(s_604_1, s_604_2)
        let s_604_3: ProductType700c18a878c5601b = u_update_HCR_Type_VF(
            state,
            tracer,
            s_604_1,
            s_604_2,
        );
        // S s_604_4: call HCR_write(s_604_3)
        let s_604_4: () = HCR_write(state, tracer, s_604_3);
        // N s_604_5: jump b96
        return block_96(state, tracer, fn_state);
    }
    fn block_605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_605_0: const #"the PE resets into EL2 or EL3" : str
        let s_605_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_605_1: call __IMPDEF_boolean(s_605_0)
        let s_605_1: bool = u__IMPDEF_boolean(state, tracer, s_605_0);
        // D s_605_2: write-var gs#44005 <= s_605_1
        fn_state.gs_44005 = s_605_1;
        // N s_605_3: jump b94
        return block_94(state, tracer, fn_state);
    }
    fn block_606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_606_0: const #() : ()
        let s_606_0: () = ();
        // S s_606_1: call HCR_read(s_606_0)
        let s_606_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_606_0);
        // C s_606_2: const #0u : u8
        let s_606_2: bool = false;
        // S s_606_3: call _update_HCR_Type_VI(s_606_1, s_606_2)
        let s_606_3: ProductType700c18a878c5601b = u_update_HCR_Type_VI(
            state,
            tracer,
            s_606_1,
            s_606_2,
        );
        // S s_606_4: call HCR_write(s_606_3)
        let s_606_4: () = HCR_write(state, tracer, s_606_3);
        // N s_606_5: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_607_0: const #"the PE resets into EL2 or EL3" : str
        let s_607_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_607_1: call __IMPDEF_boolean(s_607_0)
        let s_607_1: bool = u__IMPDEF_boolean(state, tracer, s_607_0);
        // D s_607_2: write-var gs#44004 <= s_607_1
        fn_state.gs_44004 = s_607_1;
        // N s_607_3: jump b90
        return block_90(state, tracer, fn_state);
    }
    fn block_608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_608_0: const #() : ()
        let s_608_0: () = ();
        // S s_608_1: call HCR_read(s_608_0)
        let s_608_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_608_0);
        // C s_608_2: const #0u : u8
        let s_608_2: bool = false;
        // S s_608_3: call _update_HCR_Type_VA(s_608_1, s_608_2)
        let s_608_3: ProductType700c18a878c5601b = u_update_HCR_Type_VA(
            state,
            tracer,
            s_608_1,
            s_608_2,
        );
        // S s_608_4: call HCR_write(s_608_3)
        let s_608_4: () = HCR_write(state, tracer, s_608_3);
        // N s_608_5: jump b88
        return block_88(state, tracer, fn_state);
    }
    fn block_609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_609_0: const #"the PE resets into EL2 or EL3" : str
        let s_609_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_609_1: call __IMPDEF_boolean(s_609_0)
        let s_609_1: bool = u__IMPDEF_boolean(state, tracer, s_609_0);
        // D s_609_2: write-var gs#44003 <= s_609_1
        fn_state.gs_44003 = s_609_1;
        // N s_609_3: jump b86
        return block_86(state, tracer, fn_state);
    }
    fn block_610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_610_0: const #() : ()
        let s_610_0: () = ();
        // S s_610_1: call HCR_read(s_610_0)
        let s_610_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_610_0);
        // C s_610_2: const #0u : u8
        let s_610_2: bool = false;
        // S s_610_3: call _update_HCR_Type_FB(s_610_1, s_610_2)
        let s_610_3: ProductType700c18a878c5601b = u_update_HCR_Type_FB(
            state,
            tracer,
            s_610_1,
            s_610_2,
        );
        // S s_610_4: call HCR_write(s_610_3)
        let s_610_4: () = HCR_write(state, tracer, s_610_3);
        // N s_610_5: jump b84
        return block_84(state, tracer, fn_state);
    }
    fn block_611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_611_0: const #"the PE resets into EL2 or EL3" : str
        let s_611_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_611_1: call __IMPDEF_boolean(s_611_0)
        let s_611_1: bool = u__IMPDEF_boolean(state, tracer, s_611_0);
        // D s_611_2: write-var gs#44002 <= s_611_1
        fn_state.gs_44002 = s_611_1;
        // N s_611_3: jump b82
        return block_82(state, tracer, fn_state);
    }
    fn block_612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_612_0: const #() : ()
        let s_612_0: () = ();
        // S s_612_1: call HCR_read(s_612_0)
        let s_612_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_612_0);
        // C s_612_2: const #0u : u8
        let s_612_2: u8 = 0;
        // S s_612_3: call _update_HCR_Type_BSU(s_612_1, s_612_2)
        let s_612_3: ProductType700c18a878c5601b = u_update_HCR_Type_BSU(
            state,
            tracer,
            s_612_1,
            s_612_2,
        );
        // S s_612_4: call HCR_write(s_612_3)
        let s_612_4: () = HCR_write(state, tracer, s_612_3);
        // N s_612_5: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_613_0: const #"the PE resets into EL2 or EL3" : str
        let s_613_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_613_1: call __IMPDEF_boolean(s_613_0)
        let s_613_1: bool = u__IMPDEF_boolean(state, tracer, s_613_0);
        // D s_613_2: write-var gs#44001 <= s_613_1
        fn_state.gs_44001 = s_613_1;
        // N s_613_3: jump b78
        return block_78(state, tracer, fn_state);
    }
    fn block_614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_614_0: const #() : ()
        let s_614_0: () = ();
        // S s_614_1: call HCR_read(s_614_0)
        let s_614_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_614_0);
        // C s_614_2: const #0u : u8
        let s_614_2: bool = false;
        // S s_614_3: call _update_HCR_Type_DC(s_614_1, s_614_2)
        let s_614_3: ProductType700c18a878c5601b = u_update_HCR_Type_DC(
            state,
            tracer,
            s_614_1,
            s_614_2,
        );
        // S s_614_4: call HCR_write(s_614_3)
        let s_614_4: () = HCR_write(state, tracer, s_614_3);
        // N s_614_5: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_615_0: const #"the PE resets into EL2 or EL3" : str
        let s_615_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_615_1: call __IMPDEF_boolean(s_615_0)
        let s_615_1: bool = u__IMPDEF_boolean(state, tracer, s_615_0);
        // D s_615_2: write-var gs#44000 <= s_615_1
        fn_state.gs_44000 = s_615_1;
        // N s_615_3: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_616_0: const #() : ()
        let s_616_0: () = ();
        // S s_616_1: call HCR_read(s_616_0)
        let s_616_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_616_0);
        // C s_616_2: const #0u : u8
        let s_616_2: bool = false;
        // S s_616_3: call _update_HCR_Type_TWI(s_616_1, s_616_2)
        let s_616_3: ProductType700c18a878c5601b = u_update_HCR_Type_TWI(
            state,
            tracer,
            s_616_1,
            s_616_2,
        );
        // S s_616_4: call HCR_write(s_616_3)
        let s_616_4: () = HCR_write(state, tracer, s_616_3);
        // N s_616_5: jump b72
        return block_72(state, tracer, fn_state);
    }
    fn block_617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_617_0: const #"the PE resets into EL2 or EL3" : str
        let s_617_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_617_1: call __IMPDEF_boolean(s_617_0)
        let s_617_1: bool = u__IMPDEF_boolean(state, tracer, s_617_0);
        // D s_617_2: write-var gs#43999 <= s_617_1
        fn_state.gs_43999 = s_617_1;
        // N s_617_3: jump b70
        return block_70(state, tracer, fn_state);
    }
    fn block_618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_618_0: const #() : ()
        let s_618_0: () = ();
        // S s_618_1: call HCR_read(s_618_0)
        let s_618_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_618_0);
        // C s_618_2: const #0u : u8
        let s_618_2: bool = false;
        // S s_618_3: call _update_HCR_Type_TWE(s_618_1, s_618_2)
        let s_618_3: ProductType700c18a878c5601b = u_update_HCR_Type_TWE(
            state,
            tracer,
            s_618_1,
            s_618_2,
        );
        // S s_618_4: call HCR_write(s_618_3)
        let s_618_4: () = HCR_write(state, tracer, s_618_3);
        // N s_618_5: jump b68
        return block_68(state, tracer, fn_state);
    }
    fn block_619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_619_0: const #"the PE resets into EL2 or EL3" : str
        let s_619_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_619_1: call __IMPDEF_boolean(s_619_0)
        let s_619_1: bool = u__IMPDEF_boolean(state, tracer, s_619_0);
        // D s_619_2: write-var gs#43998 <= s_619_1
        fn_state.gs_43998 = s_619_1;
        // N s_619_3: jump b66
        return block_66(state, tracer, fn_state);
    }
    fn block_620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_620_0: const #() : ()
        let s_620_0: () = ();
        // S s_620_1: call HCR_read(s_620_0)
        let s_620_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_620_0);
        // C s_620_2: const #0u : u8
        let s_620_2: bool = false;
        // S s_620_3: call _update_HCR_Type_TID0(s_620_1, s_620_2)
        let s_620_3: ProductType700c18a878c5601b = u_update_HCR_Type_TID0(
            state,
            tracer,
            s_620_1,
            s_620_2,
        );
        // S s_620_4: call HCR_write(s_620_3)
        let s_620_4: () = HCR_write(state, tracer, s_620_3);
        // N s_620_5: jump b64
        return block_64(state, tracer, fn_state);
    }
    fn block_621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_621_0: const #"the PE resets into EL2 or EL3" : str
        let s_621_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_621_1: call __IMPDEF_boolean(s_621_0)
        let s_621_1: bool = u__IMPDEF_boolean(state, tracer, s_621_0);
        // D s_621_2: write-var gs#43997 <= s_621_1
        fn_state.gs_43997 = s_621_1;
        // N s_621_3: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_622_0: const #() : ()
        let s_622_0: () = ();
        // S s_622_1: call HCR_read(s_622_0)
        let s_622_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_622_0);
        // C s_622_2: const #0u : u8
        let s_622_2: bool = false;
        // S s_622_3: call _update_HCR_Type_TID1(s_622_1, s_622_2)
        let s_622_3: ProductType700c18a878c5601b = u_update_HCR_Type_TID1(
            state,
            tracer,
            s_622_1,
            s_622_2,
        );
        // S s_622_4: call HCR_write(s_622_3)
        let s_622_4: () = HCR_write(state, tracer, s_622_3);
        // N s_622_5: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_623_0: const #"the PE resets into EL2 or EL3" : str
        let s_623_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_623_1: call __IMPDEF_boolean(s_623_0)
        let s_623_1: bool = u__IMPDEF_boolean(state, tracer, s_623_0);
        // D s_623_2: write-var gs#43996 <= s_623_1
        fn_state.gs_43996 = s_623_1;
        // N s_623_3: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_624_0: const #() : ()
        let s_624_0: () = ();
        // S s_624_1: call HCR_read(s_624_0)
        let s_624_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_624_0);
        // C s_624_2: const #0u : u8
        let s_624_2: bool = false;
        // S s_624_3: call _update_HCR_Type_TID2(s_624_1, s_624_2)
        let s_624_3: ProductType700c18a878c5601b = u_update_HCR_Type_TID2(
            state,
            tracer,
            s_624_1,
            s_624_2,
        );
        // S s_624_4: call HCR_write(s_624_3)
        let s_624_4: () = HCR_write(state, tracer, s_624_3);
        // N s_624_5: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_625_0: const #"the PE resets into EL2 or EL3" : str
        let s_625_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_625_1: call __IMPDEF_boolean(s_625_0)
        let s_625_1: bool = u__IMPDEF_boolean(state, tracer, s_625_0);
        // D s_625_2: write-var gs#43995 <= s_625_1
        fn_state.gs_43995 = s_625_1;
        // N s_625_3: jump b54
        return block_54(state, tracer, fn_state);
    }
    fn block_626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_626_0: const #() : ()
        let s_626_0: () = ();
        // S s_626_1: call HCR_read(s_626_0)
        let s_626_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_626_0);
        // C s_626_2: const #0u : u8
        let s_626_2: bool = false;
        // S s_626_3: call _update_HCR_Type_TID3(s_626_1, s_626_2)
        let s_626_3: ProductType700c18a878c5601b = u_update_HCR_Type_TID3(
            state,
            tracer,
            s_626_1,
            s_626_2,
        );
        // S s_626_4: call HCR_write(s_626_3)
        let s_626_4: () = HCR_write(state, tracer, s_626_3);
        // N s_626_5: jump b52
        return block_52(state, tracer, fn_state);
    }
    fn block_627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_627_0: const #"the PE resets into EL2 or EL3" : str
        let s_627_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_627_1: call __IMPDEF_boolean(s_627_0)
        let s_627_1: bool = u__IMPDEF_boolean(state, tracer, s_627_0);
        // D s_627_2: write-var gs#43994 <= s_627_1
        fn_state.gs_43994 = s_627_1;
        // N s_627_3: jump b50
        return block_50(state, tracer, fn_state);
    }
    fn block_628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_628_0: const #() : ()
        let s_628_0: () = ();
        // S s_628_1: call HCR_read(s_628_0)
        let s_628_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_628_0);
        // C s_628_2: const #0u : u8
        let s_628_2: bool = false;
        // S s_628_3: call _update_HCR_Type_TSC(s_628_1, s_628_2)
        let s_628_3: ProductType700c18a878c5601b = u_update_HCR_Type_TSC(
            state,
            tracer,
            s_628_1,
            s_628_2,
        );
        // S s_628_4: call HCR_write(s_628_3)
        let s_628_4: () = HCR_write(state, tracer, s_628_3);
        // N s_628_5: jump b48
        return block_48(state, tracer, fn_state);
    }
    fn block_629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_629_0: const #"the PE resets into EL2 or EL3" : str
        let s_629_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_629_1: call __IMPDEF_boolean(s_629_0)
        let s_629_1: bool = u__IMPDEF_boolean(state, tracer, s_629_0);
        // D s_629_2: write-var gs#43993 <= s_629_1
        fn_state.gs_43993 = s_629_1;
        // N s_629_3: jump b46
        return block_46(state, tracer, fn_state);
    }
    fn block_630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_630_0: const #() : ()
        let s_630_0: () = ();
        // S s_630_1: call HCR_read(s_630_0)
        let s_630_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_630_0);
        // C s_630_2: const #0u : u8
        let s_630_2: bool = false;
        // S s_630_3: call _update_HCR_Type_TIDCP(s_630_1, s_630_2)
        let s_630_3: ProductType700c18a878c5601b = u_update_HCR_Type_TIDCP(
            state,
            tracer,
            s_630_1,
            s_630_2,
        );
        // S s_630_4: call HCR_write(s_630_3)
        let s_630_4: () = HCR_write(state, tracer, s_630_3);
        // N s_630_5: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_631_0: const #"the PE resets into EL2 or EL3" : str
        let s_631_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_631_1: call __IMPDEF_boolean(s_631_0)
        let s_631_1: bool = u__IMPDEF_boolean(state, tracer, s_631_0);
        // D s_631_2: write-var gs#43992 <= s_631_1
        fn_state.gs_43992 = s_631_1;
        // N s_631_3: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_632_0: const #() : ()
        let s_632_0: () = ();
        // S s_632_1: call HCR_read(s_632_0)
        let s_632_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_632_0);
        // C s_632_2: const #0u : u8
        let s_632_2: bool = false;
        // S s_632_3: call _update_HCR_Type_TAC(s_632_1, s_632_2)
        let s_632_3: ProductType700c18a878c5601b = u_update_HCR_Type_TAC(
            state,
            tracer,
            s_632_1,
            s_632_2,
        );
        // S s_632_4: call HCR_write(s_632_3)
        let s_632_4: () = HCR_write(state, tracer, s_632_3);
        // N s_632_5: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_633_0: const #"the PE resets into EL2 or EL3" : str
        let s_633_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_633_1: call __IMPDEF_boolean(s_633_0)
        let s_633_1: bool = u__IMPDEF_boolean(state, tracer, s_633_0);
        // D s_633_2: write-var gs#43991 <= s_633_1
        fn_state.gs_43991 = s_633_1;
        // N s_633_3: jump b38
        return block_38(state, tracer, fn_state);
    }
    fn block_634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_634_0: const #() : ()
        let s_634_0: () = ();
        // S s_634_1: call HCR_read(s_634_0)
        let s_634_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_634_0);
        // C s_634_2: const #0u : u8
        let s_634_2: bool = false;
        // S s_634_3: call _update_HCR_Type_TSW(s_634_1, s_634_2)
        let s_634_3: ProductType700c18a878c5601b = u_update_HCR_Type_TSW(
            state,
            tracer,
            s_634_1,
            s_634_2,
        );
        // S s_634_4: call HCR_write(s_634_3)
        let s_634_4: () = HCR_write(state, tracer, s_634_3);
        // N s_634_5: jump b36
        return block_36(state, tracer, fn_state);
    }
    fn block_635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_635_0: const #"the PE resets into EL2 or EL3" : str
        let s_635_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_635_1: call __IMPDEF_boolean(s_635_0)
        let s_635_1: bool = u__IMPDEF_boolean(state, tracer, s_635_0);
        // D s_635_2: write-var gs#43990 <= s_635_1
        fn_state.gs_43990 = s_635_1;
        // N s_635_3: jump b34
        return block_34(state, tracer, fn_state);
    }
    fn block_636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_636_0: const #() : ()
        let s_636_0: () = ();
        // S s_636_1: call HCR_read(s_636_0)
        let s_636_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_636_0);
        // C s_636_2: const #0u : u8
        let s_636_2: bool = false;
        // S s_636_3: call _update_HCR_Type_TPC(s_636_1, s_636_2)
        let s_636_3: ProductType700c18a878c5601b = u_update_HCR_Type_TPC(
            state,
            tracer,
            s_636_1,
            s_636_2,
        );
        // S s_636_4: call HCR_write(s_636_3)
        let s_636_4: () = HCR_write(state, tracer, s_636_3);
        // N s_636_5: jump b32
        return block_32(state, tracer, fn_state);
    }
    fn block_637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_637_0: const #"the PE resets into EL2 or EL3" : str
        let s_637_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_637_1: call __IMPDEF_boolean(s_637_0)
        let s_637_1: bool = u__IMPDEF_boolean(state, tracer, s_637_0);
        // D s_637_2: write-var gs#43989 <= s_637_1
        fn_state.gs_43989 = s_637_1;
        // N s_637_3: jump b30
        return block_30(state, tracer, fn_state);
    }
    fn block_638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_638_0: const #() : ()
        let s_638_0: () = ();
        // S s_638_1: call HCR_read(s_638_0)
        let s_638_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_638_0);
        // C s_638_2: const #0u : u8
        let s_638_2: bool = false;
        // S s_638_3: call _update_HCR_Type_TPU(s_638_1, s_638_2)
        let s_638_3: ProductType700c18a878c5601b = u_update_HCR_Type_TPU(
            state,
            tracer,
            s_638_1,
            s_638_2,
        );
        // S s_638_4: call HCR_write(s_638_3)
        let s_638_4: () = HCR_write(state, tracer, s_638_3);
        // N s_638_5: jump b28
        return block_28(state, tracer, fn_state);
    }
    fn block_639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_639_0: const #"the PE resets into EL2 or EL3" : str
        let s_639_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_639_1: call __IMPDEF_boolean(s_639_0)
        let s_639_1: bool = u__IMPDEF_boolean(state, tracer, s_639_0);
        // D s_639_2: write-var gs#43988 <= s_639_1
        fn_state.gs_43988 = s_639_1;
        // N s_639_3: jump b26
        return block_26(state, tracer, fn_state);
    }
    fn block_640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_640_0: const #() : ()
        let s_640_0: () = ();
        // S s_640_1: call HCR_read(s_640_0)
        let s_640_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_640_0);
        // C s_640_2: const #0u : u8
        let s_640_2: bool = false;
        // S s_640_3: call _update_HCR_Type_TTLB(s_640_1, s_640_2)
        let s_640_3: ProductType700c18a878c5601b = u_update_HCR_Type_TTLB(
            state,
            tracer,
            s_640_1,
            s_640_2,
        );
        // S s_640_4: call HCR_write(s_640_3)
        let s_640_4: () = HCR_write(state, tracer, s_640_3);
        // N s_640_5: jump b24
        return block_24(state, tracer, fn_state);
    }
    fn block_641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_641_0: const #"the PE resets into EL2 or EL3" : str
        let s_641_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_641_1: call __IMPDEF_boolean(s_641_0)
        let s_641_1: bool = u__IMPDEF_boolean(state, tracer, s_641_0);
        // D s_641_2: write-var gs#43987 <= s_641_1
        fn_state.gs_43987 = s_641_1;
        // N s_641_3: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_642_0: const #() : ()
        let s_642_0: () = ();
        // S s_642_1: call HCR_read(s_642_0)
        let s_642_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_642_0);
        // C s_642_2: const #0u : u8
        let s_642_2: bool = false;
        // S s_642_3: call _update_HCR_Type_TVM(s_642_1, s_642_2)
        let s_642_3: ProductType700c18a878c5601b = u_update_HCR_Type_TVM(
            state,
            tracer,
            s_642_1,
            s_642_2,
        );
        // S s_642_4: call HCR_write(s_642_3)
        let s_642_4: () = HCR_write(state, tracer, s_642_3);
        // N s_642_5: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_643_0: const #"the PE resets into EL2 or EL3" : str
        let s_643_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_643_1: call __IMPDEF_boolean(s_643_0)
        let s_643_1: bool = u__IMPDEF_boolean(state, tracer, s_643_0);
        // D s_643_2: write-var gs#43986 <= s_643_1
        fn_state.gs_43986 = s_643_1;
        // N s_643_3: jump b18
        return block_18(state, tracer, fn_state);
    }
    fn block_644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_644_0: const #() : ()
        let s_644_0: () = ();
        // S s_644_1: call HCR_read(s_644_0)
        let s_644_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_644_0);
        // C s_644_2: const #0u : u8
        let s_644_2: bool = false;
        // S s_644_3: call _update_HCR_Type_TGE(s_644_1, s_644_2)
        let s_644_3: ProductType700c18a878c5601b = u_update_HCR_Type_TGE(
            state,
            tracer,
            s_644_1,
            s_644_2,
        );
        // S s_644_4: call HCR_write(s_644_3)
        let s_644_4: () = HCR_write(state, tracer, s_644_3);
        // N s_644_5: jump b16
        return block_16(state, tracer, fn_state);
    }
    fn block_645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_645_0: const #"the PE resets into EL2 or EL3" : str
        let s_645_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_645_1: call __IMPDEF_boolean(s_645_0)
        let s_645_1: bool = u__IMPDEF_boolean(state, tracer, s_645_0);
        // D s_645_2: write-var gs#43985 <= s_645_1
        fn_state.gs_43985 = s_645_1;
        // N s_645_3: jump b14
        return block_14(state, tracer, fn_state);
    }
    fn block_646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_646_0: const #() : ()
        let s_646_0: () = ();
        // S s_646_1: call HCR_read(s_646_0)
        let s_646_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_646_0);
        // C s_646_2: const #0u : u8
        let s_646_2: bool = false;
        // S s_646_3: call _update_HCR_Type_HCD(s_646_1, s_646_2)
        let s_646_3: ProductType700c18a878c5601b = u_update_HCR_Type_HCD(
            state,
            tracer,
            s_646_1,
            s_646_2,
        );
        // S s_646_4: call HCR_write(s_646_3)
        let s_646_4: () = HCR_write(state, tracer, s_646_3);
        // N s_646_5: jump b12
        return block_12(state, tracer, fn_state);
    }
    fn block_647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_647_0: const #"the PE resets into EL2 or EL3" : str
        let s_647_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_647_1: call __IMPDEF_boolean(s_647_0)
        let s_647_1: bool = u__IMPDEF_boolean(state, tracer, s_647_0);
        // D s_647_2: write-var gs#43981 <= s_647_1
        fn_state.gs_43981 = s_647_1;
        // N s_647_3: jump b10
        return block_10(state, tracer, fn_state);
    }
    fn block_648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_648_0: const #() : ()
        let s_648_0: () = ();
        // S s_648_1: call HCR_read(s_648_0)
        let s_648_1: ProductType700c18a878c5601b = HCR_read(state, tracer, s_648_0);
        // C s_648_2: const #0u : u8
        let s_648_2: bool = false;
        // S s_648_3: call _update_HCR_Type_TRVM(s_648_1, s_648_2)
        let s_648_3: ProductType700c18a878c5601b = u_update_HCR_Type_TRVM(
            state,
            tracer,
            s_648_1,
            s_648_2,
        );
        // S s_648_4: call HCR_write(s_648_3)
        let s_648_4: () = HCR_write(state, tracer, s_648_3);
        // N s_648_5: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_649_0: const #"the PE resets into EL2 or EL3" : str
        let s_649_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_649_1: call __IMPDEF_boolean(s_649_0)
        let s_649_1: bool = u__IMPDEF_boolean(state, tracer, s_649_0);
        // D s_649_2: write-var gs#43980 <= s_649_1
        fn_state.gs_43980 = s_649_1;
        // N s_649_3: jump b6
        return block_6(state, tracer, fn_state);
    }
    fn block_650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_650_0: const #22408u : u32
        let s_650_0: u32 = 22408;
        // D s_650_1: read-reg s_650_0:struct
        let s_650_1: ProductType5c790c8ef59cc8b2 = {
            let value = state
                .read_register::<ProductType5c790c8ef59cc8b2>(s_650_0 as isize);
            tracer.read_register(s_650_0 as isize, value);
            value
        };
        // C s_650_2: const #22408u : u32
        let s_650_2: u32 = 22408;
        // N s_650_3: write-reg s_650_2 <= s_650_1
        let s_650_3: () = {
            state
                .write_register::<
                    ProductType5c790c8ef59cc8b2,
                >(s_650_2 as isize, s_650_1);
            tracer.write_register(s_650_2 as isize, s_650_1);
        };
        // N s_650_4: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_651_0: const #"the PE resets into EL2 or EL3" : str
        let s_651_0: &'static str = "the PE resets into EL2 or EL3";
        // S s_651_1: call __IMPDEF_boolean(s_651_0)
        let s_651_1: bool = u__IMPDEF_boolean(state, tracer, s_651_0);
        // D s_651_2: write-var gs#43736 <= s_651_1
        fn_state.gs_43736 = s_651_1;
        // N s_651_3: jump b2
        return block_2(state, tracer, fn_state);
    }
}
