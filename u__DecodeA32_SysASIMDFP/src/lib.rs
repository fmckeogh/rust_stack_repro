#![no_std]
#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_doc_comments)]
#![allow(non_upper_case_globals)]
//! BOREALIS GENERATED FILE
extern crate alloc;
use decode_aarch32_instrs_VMOV_d_A1enc_A_txt::*;
use decode_aarch32_instrs_VFNMA_A1enc_A_txt::*;
use decode_aarch32_instrs_VADD_f_A2enc_A_txt::*;
use decode_aarch32_instrs_STC_A1enc_A_txt::*;
use decode_aarch32_instrs_VNMLA_A1enc_A_txt::*;
use decode_aarch32_instrs_VSTM_A2enc_A_txt::*;
use decode_aarch32_instrs_VMOV_i_A2enc_A_txt::*;
use decode_aarch32_instrs_VMOV_r_A2enc_A_txt::*;
use decode_aarch32_instrs_VNMLA_A2enc_A_txt::*;
use decode_aarch32_instrs_VFMA_A2enc_A_txt::*;
use decode_aarch32_instrs_MRC_A1enc_A_txt::*;
use decode_aarch32_instrs_VCVTB_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOVX_A1enc_A_txt::*;
use decode_aarch32_instrs_VLDM_A1enc_A_txt::*;
use decode_aarch32_instrs_VDOT_bf16_i_A1enc_A_txt::*;
use decode_aarch32_instrs_SVC_A1enc_A_txt::*;
use decode_aarch32_instrs_VDOT_bf16_A1enc_A_txt::*;
use decode_aarch32_instrs_VCADD_A1enc_A_txt::*;
use decode_aarch32_instrs_VMAXNM_A2enc_A_txt::*;
use decode_aarch32_instrs_VCVTA_vfp_A1enc_A_txt::*;
use decode_aarch32_instrs_VSEL_A1enc_A_txt::*;
use decode_aarch32_instrs_VDIV_A1enc_A_txt::*;
use decode_aarch32_instrs_VDUP_r_A1enc_A_txt::*;
use decode_aarch32_instrs_VINS_A1enc_A_txt::*;
use decode_aarch32_instrs_VCMP_A1enc_A_txt::*;
use decode_aarch32_instrs_VMRS_A1enc_AS_txt::*;
use decode_aarch32_instrs_VCVT_ds_A1enc_A_txt::*;
use decode_aarch32_instrs_VRINTZ_vfp_A1enc_A_txt::*;
use decode_aarch32_instrs_VJCVT_A1enc_A_txt::*;
use decode_aarch32_instrs_VCMLA_idx_A1enc_A_txt::*;
use decode_aarch32_instrs_VCVT_iv_A1enc_A_txt::*;
use decode_aarch32_instrs_VLDR_A1enc_A_txt::*;
use decode_aarch32_instrs_MRRC_A1enc_A_txt::*;
use decode_aarch32_instrs_VSTR_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOV_sr_A1enc_A_txt::*;
use decode_aarch32_instrs_VDOT_s_A1enc_A_txt::*;
use decode_aarch32_instrs_VCMLA_A1enc_A_txt::*;
use decode_aarch32_instrs_VFMAL_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VRINTA_vfp_A1enc_A_txt::*;
use decode_aarch32_instrs_VMLA_f_A2enc_A_txt::*;
use decode_aarch32_instrs_VMSR_A1enc_AS_txt::*;
use decode_aarch32_instrs_VFMA_bf_A1enc_A_txt::*;
use decode_aarch32_instrs_VLDM_A2enc_A_txt::*;
use decode_aarch32_instrs_VCVTT_A1enc_A_txt::*;
use decode_aarch32_instrs_VSTM_A1enc_A_txt::*;
use decode_aarch32_instrs_VMMLA_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOV_rs_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOV_s_A1enc_A_txt::*;
use decode_aarch32_instrs_VMUL_f_A2enc_A_txt::*;
use decode_aarch32_instrs_VABS_A2enc_A_txt::*;
use decode_aarch32_instrs_VSQRT_A1enc_A_txt::*;
use decode_aarch32_instrs_MCRR_A1enc_A_txt::*;
use decode_aarch32_instrs_DOT_A1enc_A_txt::*;
use decode_aarch32_instrs_VUSDOT_A1enc_A_txt::*;
use decode_aarch32_instrs_MMLA_A1enc_A_txt::*;
use decode_aarch32_instrs_LDC_i_A1enc_A_txt::*;
use decode_aarch32_instrs_VCMP_A2enc_A_txt::*;
use decode_aarch32_instrs_VRINTX_vfp_A1enc_A_txt::*;
use decode_aarch32_instrs_VFMA_bfs_A1enc_A_txt::*;
use decode_aarch32_instrs_VDOT_A1enc_A_txt::*;
use decode_aarch32_instrs_VNEG_A2enc_A_txt::*;
use decode_aarch32_instrs_VCVT_xv_A1enc_A_txt::*;
use decode_aarch32_instrs_VCVTB_bf16_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOV_h_A1enc_A_txt::*;
use decode_aarch32_instrs_VSUB_f_A2enc_A_txt::*;
use decode_aarch32_instrs_VFMAL_A1enc_A_txt::*;
use decode_aarch32_instrs_MCR_A1enc_A_txt::*;
use decode_aarch32_instrs_LDC_l_A1enc_A_txt::*;
use decode_aarch32_instrs_VMOV_ss_A1enc_A_txt::*;
use common::*;
pub fn u__DecodeA32_SysASIMDFP<T: Tracer>(
    state: &mut State,
    tracer: &T,
    gs_411767: i128,
    gs_411768: u32,
) -> () {
    #[derive(Default)]
    struct FunctionState {
        u_34096: u32,
        gs_412672: bool,
        imm4H: u8,
        gs_413874: bool,
        gs_413421: bool,
        gs_413152: bool,
        u_34212: u32,
        gs_412907: bool,
        gs_412892: bool,
        gs_411952: bool,
        gs_413898: bool,
        u_34107: u32,
        gs_412222: bool,
        gs_412341: bool,
        gs_412188: bool,
        u_34188: u32,
        gs_413358: bool,
        u_34310: u32,
        gs_413305: bool,
        u_34194: u8,
        u_33965: u32,
        gs_413581: bool,
        u_34220: u32,
        gs_412673: bool,
        gs_412615: bool,
        u_34051: u32,
        gs_412392: bool,
        gs_412726: bool,
        gs_413926: bool,
        u_34249: u32,
        gs_413285: bool,
        gs_412786: bool,
        gs_412039: bool,
        gs_412749: bool,
        u_34033: u8,
        gs_412527: bool,
        gs_411893: bool,
        gs_412347: bool,
        gs_412819: bool,
        gs_413092: bool,
        u_34191: u8,
        gs_413987: bool,
        gs_411842: bool,
        u_34200: u8,
        u_34513: u32,
        gs_413388: bool,
        u_34199: u8,
        gs_412594: bool,
        gs_411780: bool,
        u_34196: u32,
        gs_413121: bool,
        gs_413355: bool,
        gs_414046: bool,
        gs_412559: bool,
        gs_413008: bool,
        gs_411837: bool,
        gs_412104: bool,
        gs_412261: bool,
        gs_413116: bool,
        gs_411927: bool,
        gs_413839: bool,
        u_34414: u32,
        gs_412110: bool,
        gs_413491: bool,
        u_34168: u8,
        gs_413903: bool,
        gs_412700: bool,
        gs_413780: bool,
        gs_413308: bool,
        u_34031: bool,
        gs_412223: bool,
        gs_413328: bool,
        gs_411951: bool,
        u_34208: u8,
        gs_413086: bool,
        u_34029: u32,
        imm4L: u8,
        u_34210: u8,
        gs_412668: bool,
        gs_413806: bool,
        gs_413391: bool,
        gs_411958: bool,
        gs_413643: bool,
        gs_412591: bool,
        gs_412152: bool,
        gs_413929: bool,
        gs_413642: bool,
        gs_413714: bool,
        gs_412489: bool,
        gs_412808: bool,
        gs_412463: bool,
        gs_412705: bool,
        gs_412748: bool,
        gs_412735: bool,
        gs_413776: bool,
        gs_412303: bool,
        gs_412911: bool,
        gs_413010: bool,
        gs_413957: bool,
        u_34205: bool,
        u_34176: u8,
        gs_412938: bool,
        gs_413838: bool,
        gs_411784: bool,
        gs_414017: bool,
        u_34081: u8,
        gs_412636: bool,
        gs_412824: bool,
        gs_413147: bool,
        gs_413390: bool,
        gs_412072: bool,
        gs_412984: bool,
        gs_413959: bool,
        u_34313: u8,
        u_34178: bool,
        gs_413215: bool,
        gs_413897: bool,
        gs_412977: bool,
        gs_413180: bool,
        gs_413645: bool,
        gs_413840: bool,
        gs_413214: bool,
        gs_413220: bool,
        gs_413054: bool,
        gs_413275: bool,
        gs_413454: bool,
        gs_411868: bool,
        gs_412270: bool,
        gs_411953: bool,
        gs_413680: bool,
        gs_413048: bool,
        gs_412263: bool,
        u_34167: u32,
        gs_412494: bool,
        gs_412000: bool,
        gs_412940: bool,
        u_34080: u8,
        u_34367: u32,
        gs_413810: bool,
        gs_412854: bool,
        gs_413488: bool,
        u_34503: u32,
        gs_412387: bool,
        gs_412137: bool,
        u_34341: u32,
        gs_412618: bool,
        u_34207: u8,
        gs_412825: bool,
        gs_413869: bool,
        gs_412032: bool,
        u_34083: bool,
        u_34209: bool,
        gs_413093: bool,
        gs_413221: bool,
        gs_412780: bool,
        Q: bool,
        gs_413902: bool,
        gs_412866: bool,
        u_34311: u8,
        gs_413610: bool,
        gs_412228: bool,
        u_34153: u32,
        gs_412304: bool,
        u_34170: u8,
        gs_411980: bool,
        u_34159: u32,
        gs_413927: bool,
        gs_412747: bool,
        gs_412983: bool,
        gs_413744: bool,
        gs_412040: bool,
        u_34010: u32,
        gs_412785: bool,
        gs_413682: bool,
        gs_412946: bool,
        gs_411922: bool,
        u_34175: bool,
        gs_413213: bool,
        u__opcode: u32,
        merge_var: ProductType7b8639ca40b2f578,
        gs_413302: bool,
        gs_411779: bool,
        gs_412195: bool,
        gs_412035: bool,
        gs_412723: bool,
        u_34308: u8,
        gs_412128: bool,
        u_33972: u32,
        gs_412641: bool,
        gs_413582: bool,
        gs_413179: bool,
        u_34193: bool,
        gs_412945: bool,
        gs_413249: bool,
        gs_412521: bool,
        gs_413955: bool,
        u_34494: u32,
        gs_413153: bool,
        u_34192: u8,
        gs_414021: bool,
        gs_411998: bool,
        gs_412755: bool,
        gs_412870: bool,
        u_34173: u32,
        gs_413422: bool,
        gs_412490: bool,
        gs_413678: bool,
        u_34177: u8,
        u_34032: u8,
        u_34189: u8,
        gs_412372: bool,
        u_34117: u32,
        gs_412423: bool,
        u_34238: u32,
        u_34277: u32,
        gs_412429: bool,
        u_34068: u32,
        gs_412811: bool,
        gs_412134: bool,
        gs_413120: bool,
        u_34190: u8,
        gs_413456: bool,
        u_34061: u32,
        gs_412781: bool,
        gs_412845: bool,
        gs_413088: bool,
        gs_413549: bool,
        gs_413611: bool,
        u_34377: u32,
        gs_412151: bool,
        gs_412229: bool,
        gs_411869: bool,
        u_34471: u32,
        gs_413427: bool,
        gs_412070: bool,
        gs_412592: bool,
        gs_412555: bool,
        u_34394: u32,
        gs_413263: bool,
        gs_411813: bool,
        gs_412078: bool,
        gs_412342: bool,
        gs_412701: bool,
        gs_412754: bool,
        gs_413588: bool,
        u_34021: u32,
        u_34485: u32,
        gs_412820: bool,
        u_34078: u32,
        u_34197: u8,
        gs_413455: bool,
        gs_412369: bool,
        gs_413009: bool,
        gs_411979: bool,
        gs_412187: bool,
        gs_414045: bool,
        u_34174: u8,
        gs_413716: bool,
        gs_412842: bool,
        gs_412805: bool,
        gs_412131: bool,
        gs_411835: bool,
        u_34030: u8,
        gs_413426: bool,
        u_34454: u32,
        gs_413873: bool,
        gs_413050: bool,
        gs_412302: bool,
        u_34180: u32,
        u_34312: u8,
        gs_412979: bool,
        gs_412750: bool,
        gs_413748: bool,
        u_34007: u32,
        gs_412386: bool,
        u_34034: bool,
        gs_413807: bool,
        gs_413245: bool,
        gs_413393: bool,
        u_34358: u32,
        u_34169: bool,
        gs_413184: bool,
        gs_412264: bool,
        gs_412033: bool,
        gs_411957: bool,
        gs_412221: bool,
        gs_411778: bool,
        gs_412149: bool,
        gs_413323: bool,
        gs_413843: bool,
        gs_413518: bool,
        gs_412006: bool,
        gs_412906: bool,
        gs_413679: bool,
        gs_412848: bool,
        gs_414048: bool,
        gs_413216: bool,
        gs_412305: bool,
        gs_412642: bool,
        gs_413713: bool,
        gs_412340: bool,
        gs_413250: bool,
        gs_413841: bool,
        gs_413185: bool,
        gs_413115: bool,
        gs_412553: bool,
        gs_411807: bool,
        u_34171: u8,
        u_34259: u32,
        gs_413547: bool,
        gs_411899: bool,
        gs_413087: bool,
        gs_412309: bool,
        u_34127: u32,
        u_34307: u8,
        gs_412189: bool,
        gs_413281: bool,
        gs_412156: bool,
        gs_412343: bool,
        gs_413085: bool,
        gs_412706: bool,
        u_34287: u32,
        gs_412871: bool,
        gs_412865: bool,
        gs_413325: bool,
        u_34445: u32,
        gs_411864: bool,
        gs_413055: bool,
        gs_414019: bool,
        u_34013: u32,
        gs_412105: bool,
        gs_412614: bool,
        gs_413049: bool,
        gs_413324: bool,
        gs_413985: bool,
        gs_413460: bool,
        gs_411895: bool,
        gs_413745: bool,
        u_34522: u32,
        u_34267: u32,
        gs_412190: bool,
        gs_412391: bool,
        gs_412071: bool,
        gs_412895: bool,
        gs_412001: bool,
        gs_412077: bool,
        u_34079: u8,
        u_34403: u32,
        gs_412457: bool,
        gs_413956: bool,
        gs_412732: bool,
        gs_412666: bool,
        u_34198: bool,
        gs_411836: bool,
        u_34478: u32,
        gs_413326: bool,
        u_33991: u32,
        u_34201: bool,
        gs_412526: bool,
        gs_412462: bool,
        gs_412224: bool,
        gs_413269: bool,
        gs_412667: bool,
        gs_413389: bool,
        u_34204: u8,
        gs_412005: bool,
        gs_411808: bool,
        gs_413583: bool,
        gs_412348: bool,
        u_34387: u32,
        gs_412637: bool,
        u_34315: u32,
        gs_412976: bool,
        gs_412375: bool,
        gs_413896: bool,
        gs_414018: bool,
        gs_413587: bool,
        gs_411841: bool,
        gs_412458: bool,
        gs_412978: bool,
        u_34296: u32,
        gs_412912: bool,
        gs_413612: bool,
        gs_413272: bool,
        gs_412560: bool,
        gs_413746: bool,
        gs_413986: bool,
        B: bool,
        gs_412939: bool,
        gs_411926: bool,
        gs_412106: bool,
        gs_412111: bool,
        reg: u8,
        gs_412616: bool,
        gs_413266: bool,
        gs_413420: bool,
        u_33982: u32,
        gs_413487: bool,
        gs_412073: bool,
        gs_413148: bool,
        gs_412424: bool,
        gs_413047: bool,
        gs_413614: bool,
        gs_412554: bool,
        u_34082: bool,
        gs_413868: bool,
        gs_413015: bool,
        u_34349: u32,
        gs_412157: bool,
        gs_413419: bool,
        gs_413925: bool,
        gs_412428: bool,
        gs_412522: bool,
        gs_412590: bool,
        gs_413489: bool,
        u_34036: u32,
        gs_413808: bool,
        gs_412779: bool,
        gs_413778: bool,
        gs_413014: bool,
        gs_413311: bool,
        u_34306: u32,
        gs_412851: bool,
        gs_413286: bool,
        gs_413546: bool,
        gs_412898: bool,
        gs_412150: bool,
        u_34435: u32,
        u_34206: u8,
        gs_411900: bool,
        gs_413867: bool,
        gs_412269: bool,
        u_34463: u32,
        gs_412692: bool,
        u_34230: u32,
        u_34136: u32,
        gs_413354: bool,
        gs_412422: bool,
        gs_413520: bool,
        u_34203: u32,
        u_33975: u32,
        u_34147: u32,
        gs_413517: bool,
        gs_411894: bool,
        gs_412034: bool,
        gs_412265: bool,
        gs_413461: bool,
        gs_413356: bool,
        gs_412941: bool,
        u_34085: u32,
        gs_413677: bool,
        u_34425: u32,
        gs_412729: bool,
        gs_411812: bool,
        u_34043: u32,
        gs_412262: bool,
        gs_413299: bool,
        gs_411999: bool,
        gs_413989: bool,
        u_33999: u32,
        gs_412385: bool,
        gs_413712: bool,
        gs_413777: bool,
        gs_412310: bool,
        gs_413453: bool,
        u_34333: u32,
        gs_411785: bool,
        gs_412194: bool,
        gs_412495: bool,
        u_34323: u32,
        gs_412864: bool,
        gs_411767: i128,
        gs_411768: u32,
    }
    let fn_state = FunctionState {
        gs_411767,
        gs_411768,
        ..Default::default()
    };
    return block_0(state, tracer, fn_state);
    fn block_0<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_0_0: read-var gs#411767:i
        let s_0_0: i128 = fn_state.gs_411767;
        // D s_0_1: write-var merge#var.0 <= s_0_0
        fn_state.merge_var._0 = s_0_0;
        // D s_0_2: read-var gs#411768:u32
        let s_0_2: u32 = fn_state.gs_411768;
        // D s_0_3: write-var merge#var.1 <= s_0_2
        fn_state.merge_var._1 = s_0_2;
        // D s_0_4: read-var merge#var.1:struct
        let s_0_4: u32 = fn_state.merge_var._1;
        // D s_0_5: write-var __opcode <= s_0_4
        fn_state.u__opcode = s_0_4;
        // C s_0_6: const #25s : i
        let s_0_6: i128 = 25;
        // D s_0_7: read-var __opcode:u32
        let s_0_7: u32 = fn_state.u__opcode;
        // D s_0_8: cast zx s_0_7 -> bv
        let s_0_8: Bits = Bits::new(s_0_7 as u128, 32u16);
        // C s_0_9: const #1s : i64
        let s_0_9: i64 = 1;
        // C s_0_10: cast zx s_0_9 -> i
        let s_0_10: i128 = (i128::try_from(s_0_9).unwrap());
        // C s_0_11: const #2s : i
        let s_0_11: i128 = 2;
        // C s_0_12: add s_0_11 s_0_10
        let s_0_12: i128 = (s_0_11 + s_0_10);
        // D s_0_13: bit-extract s_0_8 s_0_6 s_0_12
        let s_0_13: Bits = (Bits::new(
            ((s_0_8) >> (s_0_6)).value(),
            u16::try_from(s_0_12).unwrap(),
        ));
        // D s_0_14: cast reint s_0_13 -> u8
        let s_0_14: u8 = (s_0_13.value() as u8);
        // D s_0_15: cast zx s_0_14 -> bv
        let s_0_15: Bits = Bits::new(s_0_14 as u128, 3u16);
        // C s_0_16: const #6u : u8
        let s_0_16: u8 = 6;
        // C s_0_17: cast zx s_0_16 -> bv
        let s_0_17: Bits = Bits::new(s_0_16 as u128, 3u16);
        // D s_0_18: cmp-eq s_0_15 s_0_17
        let s_0_18: bool = ((s_0_15) == (s_0_17));
        // N s_0_19: branch s_0_18 b1212 b1
        if s_0_18 {
            return block_1212(state, tracer, fn_state);
        } else {
            return block_1(state, tracer, fn_state);
        };
    }
    fn block_1<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1_0: const #0u : u8
        let s_1_0: bool = false;
        // D s_1_1: write-var gs#411780 <= s_1_0
        fn_state.gs_411780 = s_1_0;
        // N s_1_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_2<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2_0: read-var gs#411780:u8
        let s_2_0: bool = fn_state.gs_411780;
        // N s_2_1: branch s_2_0 b1208 b3
        if s_2_0 {
            return block_1208(state, tracer, fn_state);
        } else {
            return block_3(state, tracer, fn_state);
        };
    }
    fn block_3<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3_0: const #0u : u8
        let s_3_0: bool = false;
        // D s_3_1: write-var gs#411785 <= s_3_0
        fn_state.gs_411785 = s_3_0;
        // N s_3_2: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_4<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4_0: read-var gs#411785:u8
        let s_4_0: bool = fn_state.gs_411785;
        // D s_4_1: not s_4_0
        let s_4_1: bool = !s_4_0;
        // N s_4_2: branch s_4_1 b6 b5
        if s_4_1 {
            return block_6(state, tracer, fn_state);
        } else {
            return block_5(state, tracer, fn_state);
        };
    }
    fn block_5<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_5_0: const #2912s : i
        let s_5_0: i128 = 2912;
        // C s_5_1: const #14696u : u32
        let s_5_1: u32 = 14696;
        // N s_5_2: write-reg s_5_1 <= s_5_0
        let s_5_2: () = {
            state.write_register::<i128>(s_5_1 as isize, s_5_0);
            tracer.write_register(s_5_1 as isize, s_5_0);
        };
        // C s_5_3: const #28s : i
        let s_5_3: i128 = 28;
        // C s_5_4: const #4s : i
        let s_5_4: i128 = 4;
        // D s_5_5: read-var __opcode:u32
        let s_5_5: u32 = fn_state.u__opcode;
        // D s_5_6: cast zx s_5_5 -> bv
        let s_5_6: Bits = Bits::new(s_5_5 as u128, 32u16);
        // D s_5_7: bit-extract s_5_6 s_5_3 s_5_4
        let s_5_7: Bits = (Bits::new(
            ((s_5_6) >> (s_5_3)).value(),
            u16::try_from(s_5_4).unwrap(),
        ));
        // D s_5_8: cast reint s_5_7 -> u8
        let s_5_8: u8 = (s_5_7.value() as u8);
        // C s_5_9: const #24s : i
        let s_5_9: i128 = 24;
        // C s_5_10: const #1s : i
        let s_5_10: i128 = 1;
        // D s_5_11: read-var __opcode:u32
        let s_5_11: u32 = fn_state.u__opcode;
        // D s_5_12: cast zx s_5_11 -> bv
        let s_5_12: Bits = Bits::new(s_5_11 as u128, 32u16);
        // D s_5_13: bit-extract s_5_12 s_5_9 s_5_10
        let s_5_13: Bits = (Bits::new(
            ((s_5_12) >> (s_5_9)).value(),
            u16::try_from(s_5_10).unwrap(),
        ));
        // D s_5_14: cast reint s_5_13 -> u8
        let s_5_14: bool = ((s_5_13.value()) != 0);
        // C s_5_15: const #23s : i
        let s_5_15: i128 = 23;
        // C s_5_16: const #1s : i
        let s_5_16: i128 = 1;
        // D s_5_17: read-var __opcode:u32
        let s_5_17: u32 = fn_state.u__opcode;
        // D s_5_18: cast zx s_5_17 -> bv
        let s_5_18: Bits = Bits::new(s_5_17 as u128, 32u16);
        // D s_5_19: bit-extract s_5_18 s_5_15 s_5_16
        let s_5_19: Bits = (Bits::new(
            ((s_5_18) >> (s_5_15)).value(),
            u16::try_from(s_5_16).unwrap(),
        ));
        // D s_5_20: cast reint s_5_19 -> u8
        let s_5_20: bool = ((s_5_19.value()) != 0);
        // C s_5_21: const #21s : i
        let s_5_21: i128 = 21;
        // C s_5_22: const #1s : i
        let s_5_22: i128 = 1;
        // D s_5_23: read-var __opcode:u32
        let s_5_23: u32 = fn_state.u__opcode;
        // D s_5_24: cast zx s_5_23 -> bv
        let s_5_24: Bits = Bits::new(s_5_23 as u128, 32u16);
        // D s_5_25: bit-extract s_5_24 s_5_21 s_5_22
        let s_5_25: Bits = (Bits::new(
            ((s_5_24) >> (s_5_21)).value(),
            u16::try_from(s_5_22).unwrap(),
        ));
        // D s_5_26: cast reint s_5_25 -> u8
        let s_5_26: bool = ((s_5_25.value()) != 0);
        // C s_5_27: const #16s : i
        let s_5_27: i128 = 16;
        // C s_5_28: const #4s : i
        let s_5_28: i128 = 4;
        // D s_5_29: read-var __opcode:u32
        let s_5_29: u32 = fn_state.u__opcode;
        // D s_5_30: cast zx s_5_29 -> bv
        let s_5_30: Bits = Bits::new(s_5_29 as u128, 32u16);
        // D s_5_31: bit-extract s_5_30 s_5_27 s_5_28
        let s_5_31: Bits = (Bits::new(
            ((s_5_30) >> (s_5_27)).value(),
            u16::try_from(s_5_28).unwrap(),
        ));
        // D s_5_32: cast reint s_5_31 -> u8
        let s_5_32: u8 = (s_5_31.value() as u8);
        // C s_5_33: const #0s : i
        let s_5_33: i128 = 0;
        // C s_5_34: const #8s : i
        let s_5_34: i128 = 8;
        // D s_5_35: read-var __opcode:u32
        let s_5_35: u32 = fn_state.u__opcode;
        // D s_5_36: cast zx s_5_35 -> bv
        let s_5_36: Bits = Bits::new(s_5_35 as u128, 32u16);
        // D s_5_37: bit-extract s_5_36 s_5_33 s_5_34
        let s_5_37: Bits = (Bits::new(
            ((s_5_36) >> (s_5_33)).value(),
            u16::try_from(s_5_34).unwrap(),
        ));
        // D s_5_38: cast reint s_5_37 -> u8
        let s_5_38: u8 = (s_5_37.value() as u8);
        // D s_5_39: call decode_aarch32_instrs_LDC_i_A1enc_A_txt(s_5_8, s_5_14, s_5_20, s_5_26, s_5_32, s_5_38)
        let s_5_39: () = decode_aarch32_instrs_LDC_i_A1enc_A_txt(
            state,
            tracer,
            s_5_8,
            s_5_14,
            s_5_20,
            s_5_26,
            s_5_32,
            s_5_38,
        );
        // N s_5_40: return
        return;
    }
    fn block_6<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_6_0: read-var merge#var.1:struct
        let s_6_0: u32 = fn_state.merge_var._1;
        // D s_6_1: write-var u#33965 <= s_6_0
        fn_state.u_33965 = s_6_0;
        // C s_6_2: const #25s : i
        let s_6_2: i128 = 25;
        // D s_6_3: read-var u#33965:u32
        let s_6_3: u32 = fn_state.u_33965;
        // D s_6_4: cast zx s_6_3 -> bv
        let s_6_4: Bits = Bits::new(s_6_3 as u128, 32u16);
        // C s_6_5: const #1s : i64
        let s_6_5: i64 = 1;
        // C s_6_6: cast zx s_6_5 -> i
        let s_6_6: i128 = (i128::try_from(s_6_5).unwrap());
        // C s_6_7: const #2s : i
        let s_6_7: i128 = 2;
        // C s_6_8: add s_6_7 s_6_6
        let s_6_8: i128 = (s_6_7 + s_6_6);
        // D s_6_9: bit-extract s_6_4 s_6_2 s_6_8
        let s_6_9: Bits = (Bits::new(
            ((s_6_4) >> (s_6_2)).value(),
            u16::try_from(s_6_8).unwrap(),
        ));
        // D s_6_10: cast reint s_6_9 -> u8
        let s_6_10: u8 = (s_6_9.value() as u8);
        // D s_6_11: cast zx s_6_10 -> bv
        let s_6_11: Bits = Bits::new(s_6_10 as u128, 3u16);
        // C s_6_12: const #6u : u8
        let s_6_12: u8 = 6;
        // C s_6_13: cast zx s_6_12 -> bv
        let s_6_13: Bits = Bits::new(s_6_12 as u128, 3u16);
        // D s_6_14: cmp-eq s_6_11 s_6_13
        let s_6_14: bool = ((s_6_11) == (s_6_13));
        // N s_6_15: branch s_6_14 b1204 b7
        if s_6_14 {
            return block_1204(state, tracer, fn_state);
        } else {
            return block_7(state, tracer, fn_state);
        };
    }
    fn block_7<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_7_0: const #0u : u8
        let s_7_0: bool = false;
        // D s_7_1: write-var gs#411808 <= s_7_0
        fn_state.gs_411808 = s_7_0;
        // N s_7_2: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_8<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_8_0: read-var gs#411808:u8
        let s_8_0: bool = fn_state.gs_411808;
        // N s_8_1: branch s_8_0 b1200 b9
        if s_8_0 {
            return block_1200(state, tracer, fn_state);
        } else {
            return block_9(state, tracer, fn_state);
        };
    }
    fn block_9<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_9_0: const #0u : u8
        let s_9_0: bool = false;
        // D s_9_1: write-var gs#411813 <= s_9_0
        fn_state.gs_411813 = s_9_0;
        // N s_9_2: jump b10
        return block_10(state, tracer, fn_state);
    }
    fn block_10<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_10_0: read-var gs#411813:u8
        let s_10_0: bool = fn_state.gs_411813;
        // D s_10_1: not s_10_0
        let s_10_1: bool = !s_10_0;
        // N s_10_2: branch s_10_1 b12 b11
        if s_10_1 {
            return block_12(state, tracer, fn_state);
        } else {
            return block_11(state, tracer, fn_state);
        };
    }
    fn block_11<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_11_0: const #2914s : i
        let s_11_0: i128 = 2914;
        // C s_11_1: const #14696u : u32
        let s_11_1: u32 = 14696;
        // N s_11_2: write-reg s_11_1 <= s_11_0
        let s_11_2: () = {
            state.write_register::<i128>(s_11_1 as isize, s_11_0);
            tracer.write_register(s_11_1 as isize, s_11_0);
        };
        // C s_11_3: const #28s : i
        let s_11_3: i128 = 28;
        // C s_11_4: const #4s : i
        let s_11_4: i128 = 4;
        // D s_11_5: read-var u#33965:u32
        let s_11_5: u32 = fn_state.u_33965;
        // D s_11_6: cast zx s_11_5 -> bv
        let s_11_6: Bits = Bits::new(s_11_5 as u128, 32u16);
        // D s_11_7: bit-extract s_11_6 s_11_3 s_11_4
        let s_11_7: Bits = (Bits::new(
            ((s_11_6) >> (s_11_3)).value(),
            u16::try_from(s_11_4).unwrap(),
        ));
        // D s_11_8: cast reint s_11_7 -> u8
        let s_11_8: u8 = (s_11_7.value() as u8);
        // C s_11_9: const #24s : i
        let s_11_9: i128 = 24;
        // C s_11_10: const #1s : i
        let s_11_10: i128 = 1;
        // D s_11_11: read-var u#33965:u32
        let s_11_11: u32 = fn_state.u_33965;
        // D s_11_12: cast zx s_11_11 -> bv
        let s_11_12: Bits = Bits::new(s_11_11 as u128, 32u16);
        // D s_11_13: bit-extract s_11_12 s_11_9 s_11_10
        let s_11_13: Bits = (Bits::new(
            ((s_11_12) >> (s_11_9)).value(),
            u16::try_from(s_11_10).unwrap(),
        ));
        // D s_11_14: cast reint s_11_13 -> u8
        let s_11_14: bool = ((s_11_13.value()) != 0);
        // C s_11_15: const #23s : i
        let s_11_15: i128 = 23;
        // C s_11_16: const #1s : i
        let s_11_16: i128 = 1;
        // D s_11_17: read-var u#33965:u32
        let s_11_17: u32 = fn_state.u_33965;
        // D s_11_18: cast zx s_11_17 -> bv
        let s_11_18: Bits = Bits::new(s_11_17 as u128, 32u16);
        // D s_11_19: bit-extract s_11_18 s_11_15 s_11_16
        let s_11_19: Bits = (Bits::new(
            ((s_11_18) >> (s_11_15)).value(),
            u16::try_from(s_11_16).unwrap(),
        ));
        // D s_11_20: cast reint s_11_19 -> u8
        let s_11_20: bool = ((s_11_19.value()) != 0);
        // C s_11_21: const #21s : i
        let s_11_21: i128 = 21;
        // C s_11_22: const #1s : i
        let s_11_22: i128 = 1;
        // D s_11_23: read-var u#33965:u32
        let s_11_23: u32 = fn_state.u_33965;
        // D s_11_24: cast zx s_11_23 -> bv
        let s_11_24: Bits = Bits::new(s_11_23 as u128, 32u16);
        // D s_11_25: bit-extract s_11_24 s_11_21 s_11_22
        let s_11_25: Bits = (Bits::new(
            ((s_11_24) >> (s_11_21)).value(),
            u16::try_from(s_11_22).unwrap(),
        ));
        // D s_11_26: cast reint s_11_25 -> u8
        let s_11_26: bool = ((s_11_25.value()) != 0);
        // C s_11_27: const #0s : i
        let s_11_27: i128 = 0;
        // C s_11_28: const #8s : i
        let s_11_28: i128 = 8;
        // D s_11_29: read-var u#33965:u32
        let s_11_29: u32 = fn_state.u_33965;
        // D s_11_30: cast zx s_11_29 -> bv
        let s_11_30: Bits = Bits::new(s_11_29 as u128, 32u16);
        // D s_11_31: bit-extract s_11_30 s_11_27 s_11_28
        let s_11_31: Bits = (Bits::new(
            ((s_11_30) >> (s_11_27)).value(),
            u16::try_from(s_11_28).unwrap(),
        ));
        // D s_11_32: cast reint s_11_31 -> u8
        let s_11_32: u8 = (s_11_31.value() as u8);
        // D s_11_33: call decode_aarch32_instrs_LDC_l_A1enc_A_txt(s_11_8, s_11_14, s_11_20, s_11_26, s_11_32)
        let s_11_33: () = decode_aarch32_instrs_LDC_l_A1enc_A_txt(
            state,
            tracer,
            s_11_8,
            s_11_14,
            s_11_20,
            s_11_26,
            s_11_32,
        );
        // N s_11_34: return
        return;
    }
    fn block_12<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_12_0: read-var merge#var.1:struct
        let s_12_0: u32 = fn_state.merge_var._1;
        // D s_12_1: write-var u#33972 <= s_12_0
        fn_state.u_33972 = s_12_0;
        // C s_12_2: const #24s : i
        let s_12_2: i128 = 24;
        // D s_12_3: read-var u#33972:u32
        let s_12_3: u32 = fn_state.u_33972;
        // D s_12_4: cast zx s_12_3 -> bv
        let s_12_4: Bits = Bits::new(s_12_3 as u128, 32u16);
        // C s_12_5: const #1s : i64
        let s_12_5: i64 = 1;
        // C s_12_6: cast zx s_12_5 -> i
        let s_12_6: i128 = (i128::try_from(s_12_5).unwrap());
        // C s_12_7: const #3s : i
        let s_12_7: i128 = 3;
        // C s_12_8: add s_12_7 s_12_6
        let s_12_8: i128 = (s_12_7 + s_12_6);
        // D s_12_9: bit-extract s_12_4 s_12_2 s_12_8
        let s_12_9: Bits = (Bits::new(
            ((s_12_4) >> (s_12_2)).value(),
            u16::try_from(s_12_8).unwrap(),
        ));
        // D s_12_10: cast reint s_12_9 -> u8
        let s_12_10: u8 = (s_12_9.value() as u8);
        // D s_12_11: cast zx s_12_10 -> bv
        let s_12_11: Bits = Bits::new(s_12_10 as u128, 4u16);
        // C s_12_12: const #14u : u8
        let s_12_12: u8 = 14;
        // C s_12_13: cast zx s_12_12 -> bv
        let s_12_13: Bits = Bits::new(s_12_12 as u128, 4u16);
        // D s_12_14: cmp-eq s_12_11 s_12_13
        let s_12_14: bool = ((s_12_11) == (s_12_13));
        // N s_12_15: branch s_12_14 b1193 b13
        if s_12_14 {
            return block_1193(state, tracer, fn_state);
        } else {
            return block_13(state, tracer, fn_state);
        };
    }
    fn block_13<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_13_0: const #0u : u8
        let s_13_0: bool = false;
        // D s_13_1: write-var gs#411837 <= s_13_0
        fn_state.gs_411837 = s_13_0;
        // N s_13_2: jump b14
        return block_14(state, tracer, fn_state);
    }
    fn block_14<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_14_0: read-var gs#411837:u8
        let s_14_0: bool = fn_state.gs_411837;
        // N s_14_1: branch s_14_0 b1189 b15
        if s_14_0 {
            return block_1189(state, tracer, fn_state);
        } else {
            return block_15(state, tracer, fn_state);
        };
    }
    fn block_15<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_15_0: const #0u : u8
        let s_15_0: bool = false;
        // D s_15_1: write-var gs#411842 <= s_15_0
        fn_state.gs_411842 = s_15_0;
        // N s_15_2: jump b16
        return block_16(state, tracer, fn_state);
    }
    fn block_16<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_16_0: read-var gs#411842:u8
        let s_16_0: bool = fn_state.gs_411842;
        // D s_16_1: not s_16_0
        let s_16_1: bool = !s_16_0;
        // N s_16_2: branch s_16_1 b18 b17
        if s_16_1 {
            return block_18(state, tracer, fn_state);
        } else {
            return block_17(state, tracer, fn_state);
        };
    }
    fn block_17<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_17_0: const #3001s : i
        let s_17_0: i128 = 3001;
        // C s_17_1: const #14696u : u32
        let s_17_1: u32 = 14696;
        // N s_17_2: write-reg s_17_1 <= s_17_0
        let s_17_2: () = {
            state.write_register::<i128>(s_17_1 as isize, s_17_0);
            tracer.write_register(s_17_1 as isize, s_17_0);
        };
        // C s_17_3: const #28s : i
        let s_17_3: i128 = 28;
        // C s_17_4: const #4s : i
        let s_17_4: i128 = 4;
        // D s_17_5: read-var u#33972:u32
        let s_17_5: u32 = fn_state.u_33972;
        // D s_17_6: cast zx s_17_5 -> bv
        let s_17_6: Bits = Bits::new(s_17_5 as u128, 32u16);
        // D s_17_7: bit-extract s_17_6 s_17_3 s_17_4
        let s_17_7: Bits = (Bits::new(
            ((s_17_6) >> (s_17_3)).value(),
            u16::try_from(s_17_4).unwrap(),
        ));
        // D s_17_8: cast reint s_17_7 -> u8
        let s_17_8: u8 = (s_17_7.value() as u8);
        // C s_17_9: const #21s : i
        let s_17_9: i128 = 21;
        // C s_17_10: const #3s : i
        let s_17_10: i128 = 3;
        // D s_17_11: read-var u#33972:u32
        let s_17_11: u32 = fn_state.u_33972;
        // D s_17_12: cast zx s_17_11 -> bv
        let s_17_12: Bits = Bits::new(s_17_11 as u128, 32u16);
        // D s_17_13: bit-extract s_17_12 s_17_9 s_17_10
        let s_17_13: Bits = (Bits::new(
            ((s_17_12) >> (s_17_9)).value(),
            u16::try_from(s_17_10).unwrap(),
        ));
        // D s_17_14: cast reint s_17_13 -> u8
        let s_17_14: u8 = (s_17_13.value() as u8);
        // C s_17_15: const #16s : i
        let s_17_15: i128 = 16;
        // C s_17_16: const #4s : i
        let s_17_16: i128 = 4;
        // D s_17_17: read-var u#33972:u32
        let s_17_17: u32 = fn_state.u_33972;
        // D s_17_18: cast zx s_17_17 -> bv
        let s_17_18: Bits = Bits::new(s_17_17 as u128, 32u16);
        // D s_17_19: bit-extract s_17_18 s_17_15 s_17_16
        let s_17_19: Bits = (Bits::new(
            ((s_17_18) >> (s_17_15)).value(),
            u16::try_from(s_17_16).unwrap(),
        ));
        // D s_17_20: cast reint s_17_19 -> u8
        let s_17_20: u8 = (s_17_19.value() as u8);
        // C s_17_21: const #12s : i
        let s_17_21: i128 = 12;
        // C s_17_22: const #4s : i
        let s_17_22: i128 = 4;
        // D s_17_23: read-var u#33972:u32
        let s_17_23: u32 = fn_state.u_33972;
        // D s_17_24: cast zx s_17_23 -> bv
        let s_17_24: Bits = Bits::new(s_17_23 as u128, 32u16);
        // D s_17_25: bit-extract s_17_24 s_17_21 s_17_22
        let s_17_25: Bits = (Bits::new(
            ((s_17_24) >> (s_17_21)).value(),
            u16::try_from(s_17_22).unwrap(),
        ));
        // D s_17_26: cast reint s_17_25 -> u8
        let s_17_26: u8 = (s_17_25.value() as u8);
        // C s_17_27: const #8s : i
        let s_17_27: i128 = 8;
        // C s_17_28: const #1s : i
        let s_17_28: i128 = 1;
        // D s_17_29: read-var u#33972:u32
        let s_17_29: u32 = fn_state.u_33972;
        // D s_17_30: cast zx s_17_29 -> bv
        let s_17_30: Bits = Bits::new(s_17_29 as u128, 32u16);
        // D s_17_31: bit-extract s_17_30 s_17_27 s_17_28
        let s_17_31: Bits = (Bits::new(
            ((s_17_30) >> (s_17_27)).value(),
            u16::try_from(s_17_28).unwrap(),
        ));
        // D s_17_32: cast reint s_17_31 -> u8
        let s_17_32: bool = ((s_17_31.value()) != 0);
        // C s_17_33: const #5s : i
        let s_17_33: i128 = 5;
        // C s_17_34: const #3s : i
        let s_17_34: i128 = 3;
        // D s_17_35: read-var u#33972:u32
        let s_17_35: u32 = fn_state.u_33972;
        // D s_17_36: cast zx s_17_35 -> bv
        let s_17_36: Bits = Bits::new(s_17_35 as u128, 32u16);
        // D s_17_37: bit-extract s_17_36 s_17_33 s_17_34
        let s_17_37: Bits = (Bits::new(
            ((s_17_36) >> (s_17_33)).value(),
            u16::try_from(s_17_34).unwrap(),
        ));
        // D s_17_38: cast reint s_17_37 -> u8
        let s_17_38: u8 = (s_17_37.value() as u8);
        // C s_17_39: const #0s : i
        let s_17_39: i128 = 0;
        // C s_17_40: const #4s : i
        let s_17_40: i128 = 4;
        // D s_17_41: read-var u#33972:u32
        let s_17_41: u32 = fn_state.u_33972;
        // D s_17_42: cast zx s_17_41 -> bv
        let s_17_42: Bits = Bits::new(s_17_41 as u128, 32u16);
        // D s_17_43: bit-extract s_17_42 s_17_39 s_17_40
        let s_17_43: Bits = (Bits::new(
            ((s_17_42) >> (s_17_39)).value(),
            u16::try_from(s_17_40).unwrap(),
        ));
        // D s_17_44: cast reint s_17_43 -> u8
        let s_17_44: u8 = (s_17_43.value() as u8);
        // D s_17_45: call decode_aarch32_instrs_MCR_A1enc_A_txt(s_17_8, s_17_14, s_17_20, s_17_26, s_17_32, s_17_38, s_17_44)
        let s_17_45: () = decode_aarch32_instrs_MCR_A1enc_A_txt(
            state,
            tracer,
            s_17_8,
            s_17_14,
            s_17_20,
            s_17_26,
            s_17_32,
            s_17_38,
            s_17_44,
        );
        // N s_17_46: return
        return;
    }
    fn block_18<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_18_0: read-var merge#var.1:struct
        let s_18_0: u32 = fn_state.merge_var._1;
        // D s_18_1: write-var u#33975 <= s_18_0
        fn_state.u_33975 = s_18_0;
        // C s_18_2: const #20s : i
        let s_18_2: i128 = 20;
        // D s_18_3: read-var u#33975:u32
        let s_18_3: u32 = fn_state.u_33975;
        // D s_18_4: cast zx s_18_3 -> bv
        let s_18_4: Bits = Bits::new(s_18_3 as u128, 32u16);
        // C s_18_5: const #1s : i64
        let s_18_5: i64 = 1;
        // C s_18_6: cast zx s_18_5 -> i
        let s_18_6: i128 = (i128::try_from(s_18_5).unwrap());
        // C s_18_7: const #7s : i
        let s_18_7: i128 = 7;
        // C s_18_8: add s_18_7 s_18_6
        let s_18_8: i128 = (s_18_7 + s_18_6);
        // D s_18_9: bit-extract s_18_4 s_18_2 s_18_8
        let s_18_9: Bits = (Bits::new(
            ((s_18_4) >> (s_18_2)).value(),
            u16::try_from(s_18_8).unwrap(),
        ));
        // D s_18_10: cast reint s_18_9 -> u8
        let s_18_10: u8 = (s_18_9.value() as u8);
        // D s_18_11: cast zx s_18_10 -> bv
        let s_18_11: Bits = Bits::new(s_18_10 as u128, 8u16);
        // C s_18_12: const #196u : u8
        let s_18_12: u8 = 196;
        // C s_18_13: cast zx s_18_12 -> bv
        let s_18_13: Bits = Bits::new(s_18_12 as u128, 8u16);
        // D s_18_14: cmp-eq s_18_11 s_18_13
        let s_18_14: bool = ((s_18_11) == (s_18_13));
        // N s_18_15: branch s_18_14 b1188 b19
        if s_18_14 {
            return block_1188(state, tracer, fn_state);
        } else {
            return block_19(state, tracer, fn_state);
        };
    }
    fn block_19<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_19_0: const #0u : u8
        let s_19_0: bool = false;
        // D s_19_1: write-var gs#411864 <= s_19_0
        fn_state.gs_411864 = s_19_0;
        // N s_19_2: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_20<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_20_0: read-var gs#411864:u8
        let s_20_0: bool = fn_state.gs_411864;
        // N s_20_1: branch s_20_0 b1184 b21
        if s_20_0 {
            return block_1184(state, tracer, fn_state);
        } else {
            return block_21(state, tracer, fn_state);
        };
    }
    fn block_21<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_21_0: const #0u : u8
        let s_21_0: bool = false;
        // D s_21_1: write-var gs#411869 <= s_21_0
        fn_state.gs_411869 = s_21_0;
        // N s_21_2: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_22<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_22_0: read-var gs#411869:u8
        let s_22_0: bool = fn_state.gs_411869;
        // D s_22_1: not s_22_0
        let s_22_1: bool = !s_22_0;
        // N s_22_2: branch s_22_1 b24 b23
        if s_22_1 {
            return block_24(state, tracer, fn_state);
        } else {
            return block_23(state, tracer, fn_state);
        };
    }
    fn block_23<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_23_0: const #3003s : i
        let s_23_0: i128 = 3003;
        // C s_23_1: const #14696u : u32
        let s_23_1: u32 = 14696;
        // N s_23_2: write-reg s_23_1 <= s_23_0
        let s_23_2: () = {
            state.write_register::<i128>(s_23_1 as isize, s_23_0);
            tracer.write_register(s_23_1 as isize, s_23_0);
        };
        // C s_23_3: const #28s : i
        let s_23_3: i128 = 28;
        // C s_23_4: const #4s : i
        let s_23_4: i128 = 4;
        // D s_23_5: read-var u#33975:u32
        let s_23_5: u32 = fn_state.u_33975;
        // D s_23_6: cast zx s_23_5 -> bv
        let s_23_6: Bits = Bits::new(s_23_5 as u128, 32u16);
        // D s_23_7: bit-extract s_23_6 s_23_3 s_23_4
        let s_23_7: Bits = (Bits::new(
            ((s_23_6) >> (s_23_3)).value(),
            u16::try_from(s_23_4).unwrap(),
        ));
        // D s_23_8: cast reint s_23_7 -> u8
        let s_23_8: u8 = (s_23_7.value() as u8);
        // C s_23_9: const #16s : i
        let s_23_9: i128 = 16;
        // C s_23_10: const #4s : i
        let s_23_10: i128 = 4;
        // D s_23_11: read-var u#33975:u32
        let s_23_11: u32 = fn_state.u_33975;
        // D s_23_12: cast zx s_23_11 -> bv
        let s_23_12: Bits = Bits::new(s_23_11 as u128, 32u16);
        // D s_23_13: bit-extract s_23_12 s_23_9 s_23_10
        let s_23_13: Bits = (Bits::new(
            ((s_23_12) >> (s_23_9)).value(),
            u16::try_from(s_23_10).unwrap(),
        ));
        // D s_23_14: cast reint s_23_13 -> u8
        let s_23_14: u8 = (s_23_13.value() as u8);
        // C s_23_15: const #12s : i
        let s_23_15: i128 = 12;
        // C s_23_16: const #4s : i
        let s_23_16: i128 = 4;
        // D s_23_17: read-var u#33975:u32
        let s_23_17: u32 = fn_state.u_33975;
        // D s_23_18: cast zx s_23_17 -> bv
        let s_23_18: Bits = Bits::new(s_23_17 as u128, 32u16);
        // D s_23_19: bit-extract s_23_18 s_23_15 s_23_16
        let s_23_19: Bits = (Bits::new(
            ((s_23_18) >> (s_23_15)).value(),
            u16::try_from(s_23_16).unwrap(),
        ));
        // D s_23_20: cast reint s_23_19 -> u8
        let s_23_20: u8 = (s_23_19.value() as u8);
        // C s_23_21: const #8s : i
        let s_23_21: i128 = 8;
        // C s_23_22: const #1s : i
        let s_23_22: i128 = 1;
        // D s_23_23: read-var u#33975:u32
        let s_23_23: u32 = fn_state.u_33975;
        // D s_23_24: cast zx s_23_23 -> bv
        let s_23_24: Bits = Bits::new(s_23_23 as u128, 32u16);
        // D s_23_25: bit-extract s_23_24 s_23_21 s_23_22
        let s_23_25: Bits = (Bits::new(
            ((s_23_24) >> (s_23_21)).value(),
            u16::try_from(s_23_22).unwrap(),
        ));
        // D s_23_26: cast reint s_23_25 -> u8
        let s_23_26: bool = ((s_23_25.value()) != 0);
        // C s_23_27: const #4s : i
        let s_23_27: i128 = 4;
        // C s_23_28: const #4s : i
        let s_23_28: i128 = 4;
        // D s_23_29: read-var u#33975:u32
        let s_23_29: u32 = fn_state.u_33975;
        // D s_23_30: cast zx s_23_29 -> bv
        let s_23_30: Bits = Bits::new(s_23_29 as u128, 32u16);
        // D s_23_31: bit-extract s_23_30 s_23_27 s_23_28
        let s_23_31: Bits = (Bits::new(
            ((s_23_30) >> (s_23_27)).value(),
            u16::try_from(s_23_28).unwrap(),
        ));
        // D s_23_32: cast reint s_23_31 -> u8
        let s_23_32: u8 = (s_23_31.value() as u8);
        // C s_23_33: const #0s : i
        let s_23_33: i128 = 0;
        // C s_23_34: const #4s : i
        let s_23_34: i128 = 4;
        // D s_23_35: read-var u#33975:u32
        let s_23_35: u32 = fn_state.u_33975;
        // D s_23_36: cast zx s_23_35 -> bv
        let s_23_36: Bits = Bits::new(s_23_35 as u128, 32u16);
        // D s_23_37: bit-extract s_23_36 s_23_33 s_23_34
        let s_23_37: Bits = (Bits::new(
            ((s_23_36) >> (s_23_33)).value(),
            u16::try_from(s_23_34).unwrap(),
        ));
        // D s_23_38: cast reint s_23_37 -> u8
        let s_23_38: u8 = (s_23_37.value() as u8);
        // D s_23_39: call decode_aarch32_instrs_MCRR_A1enc_A_txt(s_23_8, s_23_14, s_23_20, s_23_26, s_23_32, s_23_38)
        let s_23_39: () = decode_aarch32_instrs_MCRR_A1enc_A_txt(
            state,
            tracer,
            s_23_8,
            s_23_14,
            s_23_20,
            s_23_26,
            s_23_32,
            s_23_38,
        );
        // N s_23_40: return
        return;
    }
    fn block_24<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_24_0: read-var merge#var.1:struct
        let s_24_0: u32 = fn_state.merge_var._1;
        // D s_24_1: write-var u#33982 <= s_24_0
        fn_state.u_33982 = s_24_0;
        // C s_24_2: const #24s : i
        let s_24_2: i128 = 24;
        // D s_24_3: read-var u#33982:u32
        let s_24_3: u32 = fn_state.u_33982;
        // D s_24_4: cast zx s_24_3 -> bv
        let s_24_4: Bits = Bits::new(s_24_3 as u128, 32u16);
        // C s_24_5: const #1s : i64
        let s_24_5: i64 = 1;
        // C s_24_6: cast zx s_24_5 -> i
        let s_24_6: i128 = (i128::try_from(s_24_5).unwrap());
        // C s_24_7: const #3s : i
        let s_24_7: i128 = 3;
        // C s_24_8: add s_24_7 s_24_6
        let s_24_8: i128 = (s_24_7 + s_24_6);
        // D s_24_9: bit-extract s_24_4 s_24_2 s_24_8
        let s_24_9: Bits = (Bits::new(
            ((s_24_4) >> (s_24_2)).value(),
            u16::try_from(s_24_8).unwrap(),
        ));
        // D s_24_10: cast reint s_24_9 -> u8
        let s_24_10: u8 = (s_24_9.value() as u8);
        // D s_24_11: cast zx s_24_10 -> bv
        let s_24_11: Bits = Bits::new(s_24_10 as u128, 4u16);
        // C s_24_12: const #14u : u8
        let s_24_12: u8 = 14;
        // C s_24_13: cast zx s_24_12 -> bv
        let s_24_13: Bits = Bits::new(s_24_12 as u128, 4u16);
        // D s_24_14: cmp-eq s_24_11 s_24_13
        let s_24_14: bool = ((s_24_11) == (s_24_13));
        // N s_24_15: branch s_24_14 b1177 b25
        if s_24_14 {
            return block_1177(state, tracer, fn_state);
        } else {
            return block_25(state, tracer, fn_state);
        };
    }
    fn block_25<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_25_0: const #0u : u8
        let s_25_0: bool = false;
        // D s_25_1: write-var gs#411895 <= s_25_0
        fn_state.gs_411895 = s_25_0;
        // N s_25_2: jump b26
        return block_26(state, tracer, fn_state);
    }
    fn block_26<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_26_0: read-var gs#411895:u8
        let s_26_0: bool = fn_state.gs_411895;
        // N s_26_1: branch s_26_0 b1173 b27
        if s_26_0 {
            return block_1173(state, tracer, fn_state);
        } else {
            return block_27(state, tracer, fn_state);
        };
    }
    fn block_27<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_27_0: const #0u : u8
        let s_27_0: bool = false;
        // D s_27_1: write-var gs#411900 <= s_27_0
        fn_state.gs_411900 = s_27_0;
        // N s_27_2: jump b28
        return block_28(state, tracer, fn_state);
    }
    fn block_28<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_28_0: read-var gs#411900:u8
        let s_28_0: bool = fn_state.gs_411900;
        // D s_28_1: not s_28_0
        let s_28_1: bool = !s_28_0;
        // N s_28_2: branch s_28_1 b30 b29
        if s_28_1 {
            return block_30(state, tracer, fn_state);
        } else {
            return block_29(state, tracer, fn_state);
        };
    }
    fn block_29<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_29_0: const #3023s : i
        let s_29_0: i128 = 3023;
        // C s_29_1: const #14696u : u32
        let s_29_1: u32 = 14696;
        // N s_29_2: write-reg s_29_1 <= s_29_0
        let s_29_2: () = {
            state.write_register::<i128>(s_29_1 as isize, s_29_0);
            tracer.write_register(s_29_1 as isize, s_29_0);
        };
        // C s_29_3: const #28s : i
        let s_29_3: i128 = 28;
        // C s_29_4: const #4s : i
        let s_29_4: i128 = 4;
        // D s_29_5: read-var u#33982:u32
        let s_29_5: u32 = fn_state.u_33982;
        // D s_29_6: cast zx s_29_5 -> bv
        let s_29_6: Bits = Bits::new(s_29_5 as u128, 32u16);
        // D s_29_7: bit-extract s_29_6 s_29_3 s_29_4
        let s_29_7: Bits = (Bits::new(
            ((s_29_6) >> (s_29_3)).value(),
            u16::try_from(s_29_4).unwrap(),
        ));
        // D s_29_8: cast reint s_29_7 -> u8
        let s_29_8: u8 = (s_29_7.value() as u8);
        // C s_29_9: const #21s : i
        let s_29_9: i128 = 21;
        // C s_29_10: const #3s : i
        let s_29_10: i128 = 3;
        // D s_29_11: read-var u#33982:u32
        let s_29_11: u32 = fn_state.u_33982;
        // D s_29_12: cast zx s_29_11 -> bv
        let s_29_12: Bits = Bits::new(s_29_11 as u128, 32u16);
        // D s_29_13: bit-extract s_29_12 s_29_9 s_29_10
        let s_29_13: Bits = (Bits::new(
            ((s_29_12) >> (s_29_9)).value(),
            u16::try_from(s_29_10).unwrap(),
        ));
        // D s_29_14: cast reint s_29_13 -> u8
        let s_29_14: u8 = (s_29_13.value() as u8);
        // C s_29_15: const #16s : i
        let s_29_15: i128 = 16;
        // C s_29_16: const #4s : i
        let s_29_16: i128 = 4;
        // D s_29_17: read-var u#33982:u32
        let s_29_17: u32 = fn_state.u_33982;
        // D s_29_18: cast zx s_29_17 -> bv
        let s_29_18: Bits = Bits::new(s_29_17 as u128, 32u16);
        // D s_29_19: bit-extract s_29_18 s_29_15 s_29_16
        let s_29_19: Bits = (Bits::new(
            ((s_29_18) >> (s_29_15)).value(),
            u16::try_from(s_29_16).unwrap(),
        ));
        // D s_29_20: cast reint s_29_19 -> u8
        let s_29_20: u8 = (s_29_19.value() as u8);
        // C s_29_21: const #12s : i
        let s_29_21: i128 = 12;
        // C s_29_22: const #4s : i
        let s_29_22: i128 = 4;
        // D s_29_23: read-var u#33982:u32
        let s_29_23: u32 = fn_state.u_33982;
        // D s_29_24: cast zx s_29_23 -> bv
        let s_29_24: Bits = Bits::new(s_29_23 as u128, 32u16);
        // D s_29_25: bit-extract s_29_24 s_29_21 s_29_22
        let s_29_25: Bits = (Bits::new(
            ((s_29_24) >> (s_29_21)).value(),
            u16::try_from(s_29_22).unwrap(),
        ));
        // D s_29_26: cast reint s_29_25 -> u8
        let s_29_26: u8 = (s_29_25.value() as u8);
        // C s_29_27: const #8s : i
        let s_29_27: i128 = 8;
        // C s_29_28: const #1s : i
        let s_29_28: i128 = 1;
        // D s_29_29: read-var u#33982:u32
        let s_29_29: u32 = fn_state.u_33982;
        // D s_29_30: cast zx s_29_29 -> bv
        let s_29_30: Bits = Bits::new(s_29_29 as u128, 32u16);
        // D s_29_31: bit-extract s_29_30 s_29_27 s_29_28
        let s_29_31: Bits = (Bits::new(
            ((s_29_30) >> (s_29_27)).value(),
            u16::try_from(s_29_28).unwrap(),
        ));
        // D s_29_32: cast reint s_29_31 -> u8
        let s_29_32: bool = ((s_29_31.value()) != 0);
        // C s_29_33: const #5s : i
        let s_29_33: i128 = 5;
        // C s_29_34: const #3s : i
        let s_29_34: i128 = 3;
        // D s_29_35: read-var u#33982:u32
        let s_29_35: u32 = fn_state.u_33982;
        // D s_29_36: cast zx s_29_35 -> bv
        let s_29_36: Bits = Bits::new(s_29_35 as u128, 32u16);
        // D s_29_37: bit-extract s_29_36 s_29_33 s_29_34
        let s_29_37: Bits = (Bits::new(
            ((s_29_36) >> (s_29_33)).value(),
            u16::try_from(s_29_34).unwrap(),
        ));
        // D s_29_38: cast reint s_29_37 -> u8
        let s_29_38: u8 = (s_29_37.value() as u8);
        // C s_29_39: const #0s : i
        let s_29_39: i128 = 0;
        // C s_29_40: const #4s : i
        let s_29_40: i128 = 4;
        // D s_29_41: read-var u#33982:u32
        let s_29_41: u32 = fn_state.u_33982;
        // D s_29_42: cast zx s_29_41 -> bv
        let s_29_42: Bits = Bits::new(s_29_41 as u128, 32u16);
        // D s_29_43: bit-extract s_29_42 s_29_39 s_29_40
        let s_29_43: Bits = (Bits::new(
            ((s_29_42) >> (s_29_39)).value(),
            u16::try_from(s_29_40).unwrap(),
        ));
        // D s_29_44: cast reint s_29_43 -> u8
        let s_29_44: u8 = (s_29_43.value() as u8);
        // D s_29_45: call decode_aarch32_instrs_MRC_A1enc_A_txt(s_29_8, s_29_14, s_29_20, s_29_26, s_29_32, s_29_38, s_29_44)
        let s_29_45: () = decode_aarch32_instrs_MRC_A1enc_A_txt(
            state,
            tracer,
            s_29_8,
            s_29_14,
            s_29_20,
            s_29_26,
            s_29_32,
            s_29_38,
            s_29_44,
        );
        // N s_29_46: return
        return;
    }
    fn block_30<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_30_0: read-var merge#var.1:struct
        let s_30_0: u32 = fn_state.merge_var._1;
        // D s_30_1: write-var u#33991 <= s_30_0
        fn_state.u_33991 = s_30_0;
        // C s_30_2: const #20s : i
        let s_30_2: i128 = 20;
        // D s_30_3: read-var u#33991:u32
        let s_30_3: u32 = fn_state.u_33991;
        // D s_30_4: cast zx s_30_3 -> bv
        let s_30_4: Bits = Bits::new(s_30_3 as u128, 32u16);
        // C s_30_5: const #1s : i64
        let s_30_5: i64 = 1;
        // C s_30_6: cast zx s_30_5 -> i
        let s_30_6: i128 = (i128::try_from(s_30_5).unwrap());
        // C s_30_7: const #7s : i
        let s_30_7: i128 = 7;
        // C s_30_8: add s_30_7 s_30_6
        let s_30_8: i128 = (s_30_7 + s_30_6);
        // D s_30_9: bit-extract s_30_4 s_30_2 s_30_8
        let s_30_9: Bits = (Bits::new(
            ((s_30_4) >> (s_30_2)).value(),
            u16::try_from(s_30_8).unwrap(),
        ));
        // D s_30_10: cast reint s_30_9 -> u8
        let s_30_10: u8 = (s_30_9.value() as u8);
        // D s_30_11: cast zx s_30_10 -> bv
        let s_30_11: Bits = Bits::new(s_30_10 as u128, 8u16);
        // C s_30_12: const #197u : u8
        let s_30_12: u8 = 197;
        // C s_30_13: cast zx s_30_12 -> bv
        let s_30_13: Bits = Bits::new(s_30_12 as u128, 8u16);
        // D s_30_14: cmp-eq s_30_11 s_30_13
        let s_30_14: bool = ((s_30_11) == (s_30_13));
        // N s_30_15: branch s_30_14 b1172 b31
        if s_30_14 {
            return block_1172(state, tracer, fn_state);
        } else {
            return block_31(state, tracer, fn_state);
        };
    }
    fn block_31<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_31_0: const #0u : u8
        let s_31_0: bool = false;
        // D s_31_1: write-var gs#411922 <= s_31_0
        fn_state.gs_411922 = s_31_0;
        // N s_31_2: jump b32
        return block_32(state, tracer, fn_state);
    }
    fn block_32<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_32_0: read-var gs#411922:u8
        let s_32_0: bool = fn_state.gs_411922;
        // N s_32_1: branch s_32_0 b1168 b33
        if s_32_0 {
            return block_1168(state, tracer, fn_state);
        } else {
            return block_33(state, tracer, fn_state);
        };
    }
    fn block_33<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_33_0: const #0u : u8
        let s_33_0: bool = false;
        // D s_33_1: write-var gs#411927 <= s_33_0
        fn_state.gs_411927 = s_33_0;
        // N s_33_2: jump b34
        return block_34(state, tracer, fn_state);
    }
    fn block_34<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_34_0: read-var gs#411927:u8
        let s_34_0: bool = fn_state.gs_411927;
        // D s_34_1: not s_34_0
        let s_34_1: bool = !s_34_0;
        // N s_34_2: branch s_34_1 b36 b35
        if s_34_1 {
            return block_36(state, tracer, fn_state);
        } else {
            return block_35(state, tracer, fn_state);
        };
    }
    fn block_35<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_35_0: const #3025s : i
        let s_35_0: i128 = 3025;
        // C s_35_1: const #14696u : u32
        let s_35_1: u32 = 14696;
        // N s_35_2: write-reg s_35_1 <= s_35_0
        let s_35_2: () = {
            state.write_register::<i128>(s_35_1 as isize, s_35_0);
            tracer.write_register(s_35_1 as isize, s_35_0);
        };
        // C s_35_3: const #28s : i
        let s_35_3: i128 = 28;
        // C s_35_4: const #4s : i
        let s_35_4: i128 = 4;
        // D s_35_5: read-var u#33991:u32
        let s_35_5: u32 = fn_state.u_33991;
        // D s_35_6: cast zx s_35_5 -> bv
        let s_35_6: Bits = Bits::new(s_35_5 as u128, 32u16);
        // D s_35_7: bit-extract s_35_6 s_35_3 s_35_4
        let s_35_7: Bits = (Bits::new(
            ((s_35_6) >> (s_35_3)).value(),
            u16::try_from(s_35_4).unwrap(),
        ));
        // D s_35_8: cast reint s_35_7 -> u8
        let s_35_8: u8 = (s_35_7.value() as u8);
        // C s_35_9: const #16s : i
        let s_35_9: i128 = 16;
        // C s_35_10: const #4s : i
        let s_35_10: i128 = 4;
        // D s_35_11: read-var u#33991:u32
        let s_35_11: u32 = fn_state.u_33991;
        // D s_35_12: cast zx s_35_11 -> bv
        let s_35_12: Bits = Bits::new(s_35_11 as u128, 32u16);
        // D s_35_13: bit-extract s_35_12 s_35_9 s_35_10
        let s_35_13: Bits = (Bits::new(
            ((s_35_12) >> (s_35_9)).value(),
            u16::try_from(s_35_10).unwrap(),
        ));
        // D s_35_14: cast reint s_35_13 -> u8
        let s_35_14: u8 = (s_35_13.value() as u8);
        // C s_35_15: const #12s : i
        let s_35_15: i128 = 12;
        // C s_35_16: const #4s : i
        let s_35_16: i128 = 4;
        // D s_35_17: read-var u#33991:u32
        let s_35_17: u32 = fn_state.u_33991;
        // D s_35_18: cast zx s_35_17 -> bv
        let s_35_18: Bits = Bits::new(s_35_17 as u128, 32u16);
        // D s_35_19: bit-extract s_35_18 s_35_15 s_35_16
        let s_35_19: Bits = (Bits::new(
            ((s_35_18) >> (s_35_15)).value(),
            u16::try_from(s_35_16).unwrap(),
        ));
        // D s_35_20: cast reint s_35_19 -> u8
        let s_35_20: u8 = (s_35_19.value() as u8);
        // C s_35_21: const #8s : i
        let s_35_21: i128 = 8;
        // C s_35_22: const #1s : i
        let s_35_22: i128 = 1;
        // D s_35_23: read-var u#33991:u32
        let s_35_23: u32 = fn_state.u_33991;
        // D s_35_24: cast zx s_35_23 -> bv
        let s_35_24: Bits = Bits::new(s_35_23 as u128, 32u16);
        // D s_35_25: bit-extract s_35_24 s_35_21 s_35_22
        let s_35_25: Bits = (Bits::new(
            ((s_35_24) >> (s_35_21)).value(),
            u16::try_from(s_35_22).unwrap(),
        ));
        // D s_35_26: cast reint s_35_25 -> u8
        let s_35_26: bool = ((s_35_25.value()) != 0);
        // C s_35_27: const #4s : i
        let s_35_27: i128 = 4;
        // C s_35_28: const #4s : i
        let s_35_28: i128 = 4;
        // D s_35_29: read-var u#33991:u32
        let s_35_29: u32 = fn_state.u_33991;
        // D s_35_30: cast zx s_35_29 -> bv
        let s_35_30: Bits = Bits::new(s_35_29 as u128, 32u16);
        // D s_35_31: bit-extract s_35_30 s_35_27 s_35_28
        let s_35_31: Bits = (Bits::new(
            ((s_35_30) >> (s_35_27)).value(),
            u16::try_from(s_35_28).unwrap(),
        ));
        // D s_35_32: cast reint s_35_31 -> u8
        let s_35_32: u8 = (s_35_31.value() as u8);
        // C s_35_33: const #0s : i
        let s_35_33: i128 = 0;
        // C s_35_34: const #4s : i
        let s_35_34: i128 = 4;
        // D s_35_35: read-var u#33991:u32
        let s_35_35: u32 = fn_state.u_33991;
        // D s_35_36: cast zx s_35_35 -> bv
        let s_35_36: Bits = Bits::new(s_35_35 as u128, 32u16);
        // D s_35_37: bit-extract s_35_36 s_35_33 s_35_34
        let s_35_37: Bits = (Bits::new(
            ((s_35_36) >> (s_35_33)).value(),
            u16::try_from(s_35_34).unwrap(),
        ));
        // D s_35_38: cast reint s_35_37 -> u8
        let s_35_38: u8 = (s_35_37.value() as u8);
        // D s_35_39: call decode_aarch32_instrs_MRRC_A1enc_A_txt(s_35_8, s_35_14, s_35_20, s_35_26, s_35_32, s_35_38)
        let s_35_39: () = decode_aarch32_instrs_MRRC_A1enc_A_txt(
            state,
            tracer,
            s_35_8,
            s_35_14,
            s_35_20,
            s_35_26,
            s_35_32,
            s_35_38,
        );
        // N s_35_40: return
        return;
    }
    fn block_36<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_36_0: read-var merge#var.1:struct
        let s_36_0: u32 = fn_state.merge_var._1;
        // D s_36_1: write-var u#33999 <= s_36_0
        fn_state.u_33999 = s_36_0;
        // C s_36_2: const #25s : i
        let s_36_2: i128 = 25;
        // D s_36_3: read-var u#33999:u32
        let s_36_3: u32 = fn_state.u_33999;
        // D s_36_4: cast zx s_36_3 -> bv
        let s_36_4: Bits = Bits::new(s_36_3 as u128, 32u16);
        // C s_36_5: const #1s : i64
        let s_36_5: i64 = 1;
        // C s_36_6: cast zx s_36_5 -> i
        let s_36_6: i128 = (i128::try_from(s_36_5).unwrap());
        // C s_36_7: const #2s : i
        let s_36_7: i128 = 2;
        // C s_36_8: add s_36_7 s_36_6
        let s_36_8: i128 = (s_36_7 + s_36_6);
        // D s_36_9: bit-extract s_36_4 s_36_2 s_36_8
        let s_36_9: Bits = (Bits::new(
            ((s_36_4) >> (s_36_2)).value(),
            u16::try_from(s_36_8).unwrap(),
        ));
        // D s_36_10: cast reint s_36_9 -> u8
        let s_36_10: u8 = (s_36_9.value() as u8);
        // D s_36_11: cast zx s_36_10 -> bv
        let s_36_11: Bits = Bits::new(s_36_10 as u128, 3u16);
        // C s_36_12: const #6u : u8
        let s_36_12: u8 = 6;
        // C s_36_13: cast zx s_36_12 -> bv
        let s_36_13: Bits = Bits::new(s_36_12 as u128, 3u16);
        // D s_36_14: cmp-eq s_36_11 s_36_13
        let s_36_14: bool = ((s_36_11) == (s_36_13));
        // N s_36_15: branch s_36_14 b1161 b37
        if s_36_14 {
            return block_1161(state, tracer, fn_state);
        } else {
            return block_37(state, tracer, fn_state);
        };
    }
    fn block_37<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_37_0: const #0u : u8
        let s_37_0: bool = false;
        // D s_37_1: write-var gs#411953 <= s_37_0
        fn_state.gs_411953 = s_37_0;
        // N s_37_2: jump b38
        return block_38(state, tracer, fn_state);
    }
    fn block_38<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_38_0: read-var gs#411953:u8
        let s_38_0: bool = fn_state.gs_411953;
        // N s_38_1: branch s_38_0 b1157 b39
        if s_38_0 {
            return block_1157(state, tracer, fn_state);
        } else {
            return block_39(state, tracer, fn_state);
        };
    }
    fn block_39<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_39_0: const #0u : u8
        let s_39_0: bool = false;
        // D s_39_1: write-var gs#411958 <= s_39_0
        fn_state.gs_411958 = s_39_0;
        // N s_39_2: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_40<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_40_0: read-var gs#411958:u8
        let s_40_0: bool = fn_state.gs_411958;
        // D s_40_1: not s_40_0
        let s_40_1: bool = !s_40_0;
        // N s_40_2: branch s_40_1 b42 b41
        if s_40_1 {
            return block_42(state, tracer, fn_state);
        } else {
            return block_41(state, tracer, fn_state);
        };
    }
    fn block_41<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_41_0: const #3184s : i
        let s_41_0: i128 = 3184;
        // C s_41_1: const #14696u : u32
        let s_41_1: u32 = 14696;
        // N s_41_2: write-reg s_41_1 <= s_41_0
        let s_41_2: () = {
            state.write_register::<i128>(s_41_1 as isize, s_41_0);
            tracer.write_register(s_41_1 as isize, s_41_0);
        };
        // C s_41_3: const #28s : i
        let s_41_3: i128 = 28;
        // C s_41_4: const #4s : i
        let s_41_4: i128 = 4;
        // D s_41_5: read-var u#33999:u32
        let s_41_5: u32 = fn_state.u_33999;
        // D s_41_6: cast zx s_41_5 -> bv
        let s_41_6: Bits = Bits::new(s_41_5 as u128, 32u16);
        // D s_41_7: bit-extract s_41_6 s_41_3 s_41_4
        let s_41_7: Bits = (Bits::new(
            ((s_41_6) >> (s_41_3)).value(),
            u16::try_from(s_41_4).unwrap(),
        ));
        // D s_41_8: cast reint s_41_7 -> u8
        let s_41_8: u8 = (s_41_7.value() as u8);
        // C s_41_9: const #24s : i
        let s_41_9: i128 = 24;
        // C s_41_10: const #1s : i
        let s_41_10: i128 = 1;
        // D s_41_11: read-var u#33999:u32
        let s_41_11: u32 = fn_state.u_33999;
        // D s_41_12: cast zx s_41_11 -> bv
        let s_41_12: Bits = Bits::new(s_41_11 as u128, 32u16);
        // D s_41_13: bit-extract s_41_12 s_41_9 s_41_10
        let s_41_13: Bits = (Bits::new(
            ((s_41_12) >> (s_41_9)).value(),
            u16::try_from(s_41_10).unwrap(),
        ));
        // D s_41_14: cast reint s_41_13 -> u8
        let s_41_14: bool = ((s_41_13.value()) != 0);
        // C s_41_15: const #23s : i
        let s_41_15: i128 = 23;
        // C s_41_16: const #1s : i
        let s_41_16: i128 = 1;
        // D s_41_17: read-var u#33999:u32
        let s_41_17: u32 = fn_state.u_33999;
        // D s_41_18: cast zx s_41_17 -> bv
        let s_41_18: Bits = Bits::new(s_41_17 as u128, 32u16);
        // D s_41_19: bit-extract s_41_18 s_41_15 s_41_16
        let s_41_19: Bits = (Bits::new(
            ((s_41_18) >> (s_41_15)).value(),
            u16::try_from(s_41_16).unwrap(),
        ));
        // D s_41_20: cast reint s_41_19 -> u8
        let s_41_20: bool = ((s_41_19.value()) != 0);
        // C s_41_21: const #21s : i
        let s_41_21: i128 = 21;
        // C s_41_22: const #1s : i
        let s_41_22: i128 = 1;
        // D s_41_23: read-var u#33999:u32
        let s_41_23: u32 = fn_state.u_33999;
        // D s_41_24: cast zx s_41_23 -> bv
        let s_41_24: Bits = Bits::new(s_41_23 as u128, 32u16);
        // D s_41_25: bit-extract s_41_24 s_41_21 s_41_22
        let s_41_25: Bits = (Bits::new(
            ((s_41_24) >> (s_41_21)).value(),
            u16::try_from(s_41_22).unwrap(),
        ));
        // D s_41_26: cast reint s_41_25 -> u8
        let s_41_26: bool = ((s_41_25.value()) != 0);
        // C s_41_27: const #16s : i
        let s_41_27: i128 = 16;
        // C s_41_28: const #4s : i
        let s_41_28: i128 = 4;
        // D s_41_29: read-var u#33999:u32
        let s_41_29: u32 = fn_state.u_33999;
        // D s_41_30: cast zx s_41_29 -> bv
        let s_41_30: Bits = Bits::new(s_41_29 as u128, 32u16);
        // D s_41_31: bit-extract s_41_30 s_41_27 s_41_28
        let s_41_31: Bits = (Bits::new(
            ((s_41_30) >> (s_41_27)).value(),
            u16::try_from(s_41_28).unwrap(),
        ));
        // D s_41_32: cast reint s_41_31 -> u8
        let s_41_32: u8 = (s_41_31.value() as u8);
        // C s_41_33: const #0s : i
        let s_41_33: i128 = 0;
        // C s_41_34: const #8s : i
        let s_41_34: i128 = 8;
        // D s_41_35: read-var u#33999:u32
        let s_41_35: u32 = fn_state.u_33999;
        // D s_41_36: cast zx s_41_35 -> bv
        let s_41_36: Bits = Bits::new(s_41_35 as u128, 32u16);
        // D s_41_37: bit-extract s_41_36 s_41_33 s_41_34
        let s_41_37: Bits = (Bits::new(
            ((s_41_36) >> (s_41_33)).value(),
            u16::try_from(s_41_34).unwrap(),
        ));
        // D s_41_38: cast reint s_41_37 -> u8
        let s_41_38: u8 = (s_41_37.value() as u8);
        // D s_41_39: call decode_aarch32_instrs_STC_A1enc_A_txt(s_41_8, s_41_14, s_41_20, s_41_26, s_41_32, s_41_38)
        let s_41_39: () = decode_aarch32_instrs_STC_A1enc_A_txt(
            state,
            tracer,
            s_41_8,
            s_41_14,
            s_41_20,
            s_41_26,
            s_41_32,
            s_41_38,
        );
        // N s_41_40: return
        return;
    }
    fn block_42<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_42_0: read-var merge#var.1:struct
        let s_42_0: u32 = fn_state.merge_var._1;
        // D s_42_1: write-var u#34007 <= s_42_0
        fn_state.u_34007 = s_42_0;
        // C s_42_2: const #24s : i
        let s_42_2: i128 = 24;
        // D s_42_3: read-var u#34007:u32
        let s_42_3: u32 = fn_state.u_34007;
        // D s_42_4: cast zx s_42_3 -> bv
        let s_42_4: Bits = Bits::new(s_42_3 as u128, 32u16);
        // C s_42_5: const #1s : i64
        let s_42_5: i64 = 1;
        // C s_42_6: cast zx s_42_5 -> i
        let s_42_6: i128 = (i128::try_from(s_42_5).unwrap());
        // C s_42_7: const #3s : i
        let s_42_7: i128 = 3;
        // C s_42_8: add s_42_7 s_42_6
        let s_42_8: i128 = (s_42_7 + s_42_6);
        // D s_42_9: bit-extract s_42_4 s_42_2 s_42_8
        let s_42_9: Bits = (Bits::new(
            ((s_42_4) >> (s_42_2)).value(),
            u16::try_from(s_42_8).unwrap(),
        ));
        // D s_42_10: cast reint s_42_9 -> u8
        let s_42_10: u8 = (s_42_9.value() as u8);
        // D s_42_11: cast zx s_42_10 -> bv
        let s_42_11: Bits = Bits::new(s_42_10 as u128, 4u16);
        // C s_42_12: const #15u : u8
        let s_42_12: u8 = 15;
        // C s_42_13: cast zx s_42_12 -> bv
        let s_42_13: Bits = Bits::new(s_42_12 as u128, 4u16);
        // D s_42_14: cmp-eq s_42_11 s_42_13
        let s_42_14: bool = ((s_42_11) == (s_42_13));
        // N s_42_15: branch s_42_14 b1153 b43
        if s_42_14 {
            return block_1153(state, tracer, fn_state);
        } else {
            return block_43(state, tracer, fn_state);
        };
    }
    fn block_43<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_43_0: const #0u : u8
        let s_43_0: bool = false;
        // D s_43_1: write-var gs#411980 <= s_43_0
        fn_state.gs_411980 = s_43_0;
        // N s_43_2: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_44<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_44_0: read-var gs#411980:u8
        let s_44_0: bool = fn_state.gs_411980;
        // D s_44_1: not s_44_0
        let s_44_1: bool = !s_44_0;
        // N s_44_2: branch s_44_1 b46 b45
        if s_44_1 {
            return block_46(state, tracer, fn_state);
        } else {
            return block_45(state, tracer, fn_state);
        };
    }
    fn block_45<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_45_0: const #3251s : i
        let s_45_0: i128 = 3251;
        // C s_45_1: const #14696u : u32
        let s_45_1: u32 = 14696;
        // N s_45_2: write-reg s_45_1 <= s_45_0
        let s_45_2: () = {
            state.write_register::<i128>(s_45_1 as isize, s_45_0);
            tracer.write_register(s_45_1 as isize, s_45_0);
        };
        // C s_45_3: const #28s : i
        let s_45_3: i128 = 28;
        // C s_45_4: const #4s : i
        let s_45_4: i128 = 4;
        // D s_45_5: read-var u#34007:u32
        let s_45_5: u32 = fn_state.u_34007;
        // D s_45_6: cast zx s_45_5 -> bv
        let s_45_6: Bits = Bits::new(s_45_5 as u128, 32u16);
        // D s_45_7: bit-extract s_45_6 s_45_3 s_45_4
        let s_45_7: Bits = (Bits::new(
            ((s_45_6) >> (s_45_3)).value(),
            u16::try_from(s_45_4).unwrap(),
        ));
        // D s_45_8: cast reint s_45_7 -> u8
        let s_45_8: u8 = (s_45_7.value() as u8);
        // C s_45_9: const #0s : i
        let s_45_9: i128 = 0;
        // C s_45_10: const #24s : i
        let s_45_10: i128 = 24;
        // D s_45_11: read-var u#34007:u32
        let s_45_11: u32 = fn_state.u_34007;
        // D s_45_12: cast zx s_45_11 -> bv
        let s_45_12: Bits = Bits::new(s_45_11 as u128, 32u16);
        // D s_45_13: bit-extract s_45_12 s_45_9 s_45_10
        let s_45_13: Bits = (Bits::new(
            ((s_45_12) >> (s_45_9)).value(),
            u16::try_from(s_45_10).unwrap(),
        ));
        // D s_45_14: cast reint s_45_13 -> u24
        let s_45_14: u32 = (s_45_13.value() as u32);
        // D s_45_15: call decode_aarch32_instrs_SVC_A1enc_A_txt(s_45_8, s_45_14)
        let s_45_15: () = decode_aarch32_instrs_SVC_A1enc_A_txt(
            state,
            tracer,
            s_45_8,
            s_45_14,
        );
        // N s_45_16: return
        return;
    }
    fn block_46<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_46_0: read-var merge#var.1:struct
        let s_46_0: u32 = fn_state.merge_var._1;
        // D s_46_1: write-var u#34010 <= s_46_0
        fn_state.u_34010 = s_46_0;
        // C s_46_2: const #23s : i
        let s_46_2: i128 = 23;
        // D s_46_3: read-var u#34010:u32
        let s_46_3: u32 = fn_state.u_34010;
        // D s_46_4: cast zx s_46_3 -> bv
        let s_46_4: Bits = Bits::new(s_46_3 as u128, 32u16);
        // C s_46_5: const #1s : i64
        let s_46_5: i64 = 1;
        // C s_46_6: cast zx s_46_5 -> i
        let s_46_6: i128 = (i128::try_from(s_46_5).unwrap());
        // C s_46_7: const #4s : i
        let s_46_7: i128 = 4;
        // C s_46_8: add s_46_7 s_46_6
        let s_46_8: i128 = (s_46_7 + s_46_6);
        // D s_46_9: bit-extract s_46_4 s_46_2 s_46_8
        let s_46_9: Bits = (Bits::new(
            ((s_46_4) >> (s_46_2)).value(),
            u16::try_from(s_46_8).unwrap(),
        ));
        // D s_46_10: cast reint s_46_9 -> u8
        let s_46_10: u8 = (s_46_9.value() as u8);
        // D s_46_11: cast zx s_46_10 -> bv
        let s_46_11: Bits = Bits::new(s_46_10 as u128, 5u16);
        // C s_46_12: const #29u : u8
        let s_46_12: u8 = 29;
        // C s_46_13: cast zx s_46_12 -> bv
        let s_46_13: Bits = Bits::new(s_46_12 as u128, 5u16);
        // D s_46_14: cmp-eq s_46_11 s_46_13
        let s_46_14: bool = ((s_46_11) == (s_46_13));
        // N s_46_15: branch s_46_14 b1143 b47
        if s_46_14 {
            return block_1143(state, tracer, fn_state);
        } else {
            return block_47(state, tracer, fn_state);
        };
    }
    fn block_47<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_47_0: const #0u : u8
        let s_47_0: bool = false;
        // D s_47_1: write-var gs#412001 <= s_47_0
        fn_state.gs_412001 = s_47_0;
        // N s_47_2: jump b48
        return block_48(state, tracer, fn_state);
    }
    fn block_48<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_48_0: read-var gs#412001:u8
        let s_48_0: bool = fn_state.gs_412001;
        // N s_48_1: branch s_48_0 b1139 b49
        if s_48_0 {
            return block_1139(state, tracer, fn_state);
        } else {
            return block_49(state, tracer, fn_state);
        };
    }
    fn block_49<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_49_0: const #0u : u8
        let s_49_0: bool = false;
        // D s_49_1: write-var gs#412006 <= s_49_0
        fn_state.gs_412006 = s_49_0;
        // N s_49_2: jump b50
        return block_50(state, tracer, fn_state);
    }
    fn block_50<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_50_0: read-var gs#412006:u8
        let s_50_0: bool = fn_state.gs_412006;
        // D s_50_1: not s_50_0
        let s_50_1: bool = !s_50_0;
        // N s_50_2: branch s_50_1 b52 b51
        if s_50_1 {
            return block_52(state, tracer, fn_state);
        } else {
            return block_51(state, tracer, fn_state);
        };
    }
    fn block_51<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_51_0: const #3361s : i
        let s_51_0: i128 = 3361;
        // C s_51_1: const #14696u : u32
        let s_51_1: u32 = 14696;
        // N s_51_2: write-reg s_51_1 <= s_51_0
        let s_51_2: () = {
            state.write_register::<i128>(s_51_1 as isize, s_51_0);
            tracer.write_register(s_51_1 as isize, s_51_0);
        };
        // C s_51_3: const #28s : i
        let s_51_3: i128 = 28;
        // C s_51_4: const #4s : i
        let s_51_4: i128 = 4;
        // D s_51_5: read-var u#34010:u32
        let s_51_5: u32 = fn_state.u_34010;
        // D s_51_6: cast zx s_51_5 -> bv
        let s_51_6: Bits = Bits::new(s_51_5 as u128, 32u16);
        // D s_51_7: bit-extract s_51_6 s_51_3 s_51_4
        let s_51_7: Bits = (Bits::new(
            ((s_51_6) >> (s_51_3)).value(),
            u16::try_from(s_51_4).unwrap(),
        ));
        // D s_51_8: cast reint s_51_7 -> u8
        let s_51_8: u8 = (s_51_7.value() as u8);
        // C s_51_9: const #22s : i
        let s_51_9: i128 = 22;
        // C s_51_10: const #1s : i
        let s_51_10: i128 = 1;
        // D s_51_11: read-var u#34010:u32
        let s_51_11: u32 = fn_state.u_34010;
        // D s_51_12: cast zx s_51_11 -> bv
        let s_51_12: Bits = Bits::new(s_51_11 as u128, 32u16);
        // D s_51_13: bit-extract s_51_12 s_51_9 s_51_10
        let s_51_13: Bits = (Bits::new(
            ((s_51_12) >> (s_51_9)).value(),
            u16::try_from(s_51_10).unwrap(),
        ));
        // D s_51_14: cast reint s_51_13 -> u8
        let s_51_14: bool = ((s_51_13.value()) != 0);
        // C s_51_15: const #12s : i
        let s_51_15: i128 = 12;
        // C s_51_16: const #4s : i
        let s_51_16: i128 = 4;
        // D s_51_17: read-var u#34010:u32
        let s_51_17: u32 = fn_state.u_34010;
        // D s_51_18: cast zx s_51_17 -> bv
        let s_51_18: Bits = Bits::new(s_51_17 as u128, 32u16);
        // D s_51_19: bit-extract s_51_18 s_51_15 s_51_16
        let s_51_19: Bits = (Bits::new(
            ((s_51_18) >> (s_51_15)).value(),
            u16::try_from(s_51_16).unwrap(),
        ));
        // D s_51_20: cast reint s_51_19 -> u8
        let s_51_20: u8 = (s_51_19.value() as u8);
        // C s_51_21: const #8s : i
        let s_51_21: i128 = 8;
        // C s_51_22: const #2s : i
        let s_51_22: i128 = 2;
        // D s_51_23: read-var u#34010:u32
        let s_51_23: u32 = fn_state.u_34010;
        // D s_51_24: cast zx s_51_23 -> bv
        let s_51_24: Bits = Bits::new(s_51_23 as u128, 32u16);
        // D s_51_25: bit-extract s_51_24 s_51_21 s_51_22
        let s_51_25: Bits = (Bits::new(
            ((s_51_24) >> (s_51_21)).value(),
            u16::try_from(s_51_22).unwrap(),
        ));
        // D s_51_26: cast reint s_51_25 -> u8
        let s_51_26: u8 = (s_51_25.value() as u8);
        // C s_51_27: const #5s : i
        let s_51_27: i128 = 5;
        // C s_51_28: const #1s : i
        let s_51_28: i128 = 1;
        // D s_51_29: read-var u#34010:u32
        let s_51_29: u32 = fn_state.u_34010;
        // D s_51_30: cast zx s_51_29 -> bv
        let s_51_30: Bits = Bits::new(s_51_29 as u128, 32u16);
        // D s_51_31: bit-extract s_51_30 s_51_27 s_51_28
        let s_51_31: Bits = (Bits::new(
            ((s_51_30) >> (s_51_27)).value(),
            u16::try_from(s_51_28).unwrap(),
        ));
        // D s_51_32: cast reint s_51_31 -> u8
        let s_51_32: bool = ((s_51_31.value()) != 0);
        // C s_51_33: const #0s : i
        let s_51_33: i128 = 0;
        // C s_51_34: const #4s : i
        let s_51_34: i128 = 4;
        // D s_51_35: read-var u#34010:u32
        let s_51_35: u32 = fn_state.u_34010;
        // D s_51_36: cast zx s_51_35 -> bv
        let s_51_36: Bits = Bits::new(s_51_35 as u128, 32u16);
        // D s_51_37: bit-extract s_51_36 s_51_33 s_51_34
        let s_51_37: Bits = (Bits::new(
            ((s_51_36) >> (s_51_33)).value(),
            u16::try_from(s_51_34).unwrap(),
        ));
        // D s_51_38: cast reint s_51_37 -> u8
        let s_51_38: u8 = (s_51_37.value() as u8);
        // D s_51_39: call decode_aarch32_instrs_VABS_A2enc_A_txt(s_51_8, s_51_14, s_51_20, s_51_26, s_51_32, s_51_38)
        let s_51_39: () = decode_aarch32_instrs_VABS_A2enc_A_txt(
            state,
            tracer,
            s_51_8,
            s_51_14,
            s_51_20,
            s_51_26,
            s_51_32,
            s_51_38,
        );
        // N s_51_40: return
        return;
    }
    fn block_52<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_52_0: read-var merge#var.1:struct
        let s_52_0: u32 = fn_state.merge_var._1;
        // D s_52_1: write-var u#34013 <= s_52_0
        fn_state.u_34013 = s_52_0;
        // C s_52_2: const #23s : i
        let s_52_2: i128 = 23;
        // D s_52_3: read-var u#34013:u32
        let s_52_3: u32 = fn_state.u_34013;
        // D s_52_4: cast zx s_52_3 -> bv
        let s_52_4: Bits = Bits::new(s_52_3 as u128, 32u16);
        // C s_52_5: const #1s : i64
        let s_52_5: i64 = 1;
        // C s_52_6: cast zx s_52_5 -> i
        let s_52_6: i128 = (i128::try_from(s_52_5).unwrap());
        // C s_52_7: const #4s : i
        let s_52_7: i128 = 4;
        // C s_52_8: add s_52_7 s_52_6
        let s_52_8: i128 = (s_52_7 + s_52_6);
        // D s_52_9: bit-extract s_52_4 s_52_2 s_52_8
        let s_52_9: Bits = (Bits::new(
            ((s_52_4) >> (s_52_2)).value(),
            u16::try_from(s_52_8).unwrap(),
        ));
        // D s_52_10: cast reint s_52_9 -> u8
        let s_52_10: u8 = (s_52_9.value() as u8);
        // D s_52_11: cast zx s_52_10 -> bv
        let s_52_11: Bits = Bits::new(s_52_10 as u128, 5u16);
        // C s_52_12: const #28u : u8
        let s_52_12: u8 = 28;
        // C s_52_13: cast zx s_52_12 -> bv
        let s_52_13: Bits = Bits::new(s_52_12 as u128, 5u16);
        // D s_52_14: cmp-eq s_52_11 s_52_13
        let s_52_14: bool = ((s_52_11) == (s_52_13));
        // N s_52_15: branch s_52_14 b1129 b53
        if s_52_14 {
            return block_1129(state, tracer, fn_state);
        } else {
            return block_53(state, tracer, fn_state);
        };
    }
    fn block_53<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_53_0: const #0u : u8
        let s_53_0: bool = false;
        // D s_53_1: write-var gs#412035 <= s_53_0
        fn_state.gs_412035 = s_53_0;
        // N s_53_2: jump b54
        return block_54(state, tracer, fn_state);
    }
    fn block_54<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_54_0: read-var gs#412035:u8
        let s_54_0: bool = fn_state.gs_412035;
        // N s_54_1: branch s_54_0 b1125 b55
        if s_54_0 {
            return block_1125(state, tracer, fn_state);
        } else {
            return block_55(state, tracer, fn_state);
        };
    }
    fn block_55<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_55_0: const #0u : u8
        let s_55_0: bool = false;
        // D s_55_1: write-var gs#412040 <= s_55_0
        fn_state.gs_412040 = s_55_0;
        // N s_55_2: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_56<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_56_0: read-var gs#412040:u8
        let s_56_0: bool = fn_state.gs_412040;
        // D s_56_1: not s_56_0
        let s_56_1: bool = !s_56_0;
        // N s_56_2: branch s_56_1 b58 b57
        if s_56_1 {
            return block_58(state, tracer, fn_state);
        } else {
            return block_57(state, tracer, fn_state);
        };
    }
    fn block_57<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_57_0: const #3367s : i
        let s_57_0: i128 = 3367;
        // C s_57_1: const #14696u : u32
        let s_57_1: u32 = 14696;
        // N s_57_2: write-reg s_57_1 <= s_57_0
        let s_57_2: () = {
            state.write_register::<i128>(s_57_1 as isize, s_57_0);
            tracer.write_register(s_57_1 as isize, s_57_0);
        };
        // C s_57_3: const #28s : i
        let s_57_3: i128 = 28;
        // C s_57_4: const #4s : i
        let s_57_4: i128 = 4;
        // D s_57_5: read-var u#34013:u32
        let s_57_5: u32 = fn_state.u_34013;
        // D s_57_6: cast zx s_57_5 -> bv
        let s_57_6: Bits = Bits::new(s_57_5 as u128, 32u16);
        // D s_57_7: bit-extract s_57_6 s_57_3 s_57_4
        let s_57_7: Bits = (Bits::new(
            ((s_57_6) >> (s_57_3)).value(),
            u16::try_from(s_57_4).unwrap(),
        ));
        // D s_57_8: cast reint s_57_7 -> u8
        let s_57_8: u8 = (s_57_7.value() as u8);
        // C s_57_9: const #22s : i
        let s_57_9: i128 = 22;
        // C s_57_10: const #1s : i
        let s_57_10: i128 = 1;
        // D s_57_11: read-var u#34013:u32
        let s_57_11: u32 = fn_state.u_34013;
        // D s_57_12: cast zx s_57_11 -> bv
        let s_57_12: Bits = Bits::new(s_57_11 as u128, 32u16);
        // D s_57_13: bit-extract s_57_12 s_57_9 s_57_10
        let s_57_13: Bits = (Bits::new(
            ((s_57_12) >> (s_57_9)).value(),
            u16::try_from(s_57_10).unwrap(),
        ));
        // D s_57_14: cast reint s_57_13 -> u8
        let s_57_14: bool = ((s_57_13.value()) != 0);
        // C s_57_15: const #16s : i
        let s_57_15: i128 = 16;
        // C s_57_16: const #4s : i
        let s_57_16: i128 = 4;
        // D s_57_17: read-var u#34013:u32
        let s_57_17: u32 = fn_state.u_34013;
        // D s_57_18: cast zx s_57_17 -> bv
        let s_57_18: Bits = Bits::new(s_57_17 as u128, 32u16);
        // D s_57_19: bit-extract s_57_18 s_57_15 s_57_16
        let s_57_19: Bits = (Bits::new(
            ((s_57_18) >> (s_57_15)).value(),
            u16::try_from(s_57_16).unwrap(),
        ));
        // D s_57_20: cast reint s_57_19 -> u8
        let s_57_20: u8 = (s_57_19.value() as u8);
        // C s_57_21: const #12s : i
        let s_57_21: i128 = 12;
        // C s_57_22: const #4s : i
        let s_57_22: i128 = 4;
        // D s_57_23: read-var u#34013:u32
        let s_57_23: u32 = fn_state.u_34013;
        // D s_57_24: cast zx s_57_23 -> bv
        let s_57_24: Bits = Bits::new(s_57_23 as u128, 32u16);
        // D s_57_25: bit-extract s_57_24 s_57_21 s_57_22
        let s_57_25: Bits = (Bits::new(
            ((s_57_24) >> (s_57_21)).value(),
            u16::try_from(s_57_22).unwrap(),
        ));
        // D s_57_26: cast reint s_57_25 -> u8
        let s_57_26: u8 = (s_57_25.value() as u8);
        // C s_57_27: const #8s : i
        let s_57_27: i128 = 8;
        // C s_57_28: const #2s : i
        let s_57_28: i128 = 2;
        // D s_57_29: read-var u#34013:u32
        let s_57_29: u32 = fn_state.u_34013;
        // D s_57_30: cast zx s_57_29 -> bv
        let s_57_30: Bits = Bits::new(s_57_29 as u128, 32u16);
        // D s_57_31: bit-extract s_57_30 s_57_27 s_57_28
        let s_57_31: Bits = (Bits::new(
            ((s_57_30) >> (s_57_27)).value(),
            u16::try_from(s_57_28).unwrap(),
        ));
        // D s_57_32: cast reint s_57_31 -> u8
        let s_57_32: u8 = (s_57_31.value() as u8);
        // C s_57_33: const #7s : i
        let s_57_33: i128 = 7;
        // C s_57_34: const #1s : i
        let s_57_34: i128 = 1;
        // D s_57_35: read-var u#34013:u32
        let s_57_35: u32 = fn_state.u_34013;
        // D s_57_36: cast zx s_57_35 -> bv
        let s_57_36: Bits = Bits::new(s_57_35 as u128, 32u16);
        // D s_57_37: bit-extract s_57_36 s_57_33 s_57_34
        let s_57_37: Bits = (Bits::new(
            ((s_57_36) >> (s_57_33)).value(),
            u16::try_from(s_57_34).unwrap(),
        ));
        // D s_57_38: cast reint s_57_37 -> u8
        let s_57_38: bool = ((s_57_37.value()) != 0);
        // C s_57_39: const #5s : i
        let s_57_39: i128 = 5;
        // C s_57_40: const #1s : i
        let s_57_40: i128 = 1;
        // D s_57_41: read-var u#34013:u32
        let s_57_41: u32 = fn_state.u_34013;
        // D s_57_42: cast zx s_57_41 -> bv
        let s_57_42: Bits = Bits::new(s_57_41 as u128, 32u16);
        // D s_57_43: bit-extract s_57_42 s_57_39 s_57_40
        let s_57_43: Bits = (Bits::new(
            ((s_57_42) >> (s_57_39)).value(),
            u16::try_from(s_57_40).unwrap(),
        ));
        // D s_57_44: cast reint s_57_43 -> u8
        let s_57_44: bool = ((s_57_43.value()) != 0);
        // C s_57_45: const #0s : i
        let s_57_45: i128 = 0;
        // C s_57_46: const #4s : i
        let s_57_46: i128 = 4;
        // D s_57_47: read-var u#34013:u32
        let s_57_47: u32 = fn_state.u_34013;
        // D s_57_48: cast zx s_57_47 -> bv
        let s_57_48: Bits = Bits::new(s_57_47 as u128, 32u16);
        // D s_57_49: bit-extract s_57_48 s_57_45 s_57_46
        let s_57_49: Bits = (Bits::new(
            ((s_57_48) >> (s_57_45)).value(),
            u16::try_from(s_57_46).unwrap(),
        ));
        // D s_57_50: cast reint s_57_49 -> u8
        let s_57_50: u8 = (s_57_49.value() as u8);
        // D s_57_51: call decode_aarch32_instrs_VADD_f_A2enc_A_txt(s_57_8, s_57_14, s_57_20, s_57_26, s_57_32, s_57_38, s_57_44, s_57_50)
        let s_57_51: () = decode_aarch32_instrs_VADD_f_A2enc_A_txt(
            state,
            tracer,
            s_57_8,
            s_57_14,
            s_57_20,
            s_57_26,
            s_57_32,
            s_57_38,
            s_57_44,
            s_57_50,
        );
        // N s_57_52: return
        return;
    }
    fn block_58<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_58_0: read-var merge#var.1:struct
        let s_58_0: u32 = fn_state.merge_var._1;
        // D s_58_1: write-var u#34021 <= s_58_0
        fn_state.u_34021 = s_58_0;
        // C s_58_2: const #23s : i
        let s_58_2: i128 = 23;
        // D s_58_3: read-var u#34021:u32
        let s_58_3: u32 = fn_state.u_34021;
        // D s_58_4: cast zx s_58_3 -> bv
        let s_58_4: Bits = Bits::new(s_58_3 as u128, 32u16);
        // C s_58_5: const #1s : i64
        let s_58_5: i64 = 1;
        // C s_58_6: cast zx s_58_5 -> i
        let s_58_6: i128 = (i128::try_from(s_58_5).unwrap());
        // C s_58_7: const #4s : i
        let s_58_7: i128 = 4;
        // C s_58_8: add s_58_7 s_58_6
        let s_58_8: i128 = (s_58_7 + s_58_6);
        // D s_58_9: bit-extract s_58_4 s_58_2 s_58_8
        let s_58_9: Bits = (Bits::new(
            ((s_58_4) >> (s_58_2)).value(),
            u16::try_from(s_58_8).unwrap(),
        ));
        // D s_58_10: cast reint s_58_9 -> u8
        let s_58_10: u8 = (s_58_9.value() as u8);
        // D s_58_11: cast zx s_58_10 -> bv
        let s_58_11: Bits = Bits::new(s_58_10 as u128, 5u16);
        // C s_58_12: const #29u : u8
        let s_58_12: u8 = 29;
        // C s_58_13: cast zx s_58_12 -> bv
        let s_58_13: Bits = Bits::new(s_58_12 as u128, 5u16);
        // D s_58_14: cmp-eq s_58_11 s_58_13
        let s_58_14: bool = ((s_58_11) == (s_58_13));
        // N s_58_15: branch s_58_14 b1115 b59
        if s_58_14 {
            return block_1115(state, tracer, fn_state);
        } else {
            return block_59(state, tracer, fn_state);
        };
    }
    fn block_59<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_59_0: const #0u : u8
        let s_59_0: bool = false;
        // D s_59_1: write-var gs#412073 <= s_59_0
        fn_state.gs_412073 = s_59_0;
        // N s_59_2: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_60<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_60_0: read-var gs#412073:u8
        let s_60_0: bool = fn_state.gs_412073;
        // N s_60_1: branch s_60_0 b1111 b61
        if s_60_0 {
            return block_1111(state, tracer, fn_state);
        } else {
            return block_61(state, tracer, fn_state);
        };
    }
    fn block_61<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_61_0: const #0u : u8
        let s_61_0: bool = false;
        // D s_61_1: write-var gs#412078 <= s_61_0
        fn_state.gs_412078 = s_61_0;
        // N s_61_2: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_62<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_62_0: read-var gs#412078:u8
        let s_62_0: bool = fn_state.gs_412078;
        // D s_62_1: not s_62_0
        let s_62_1: bool = !s_62_0;
        // N s_62_2: branch s_62_1 b64 b63
        if s_62_1 {
            return block_64(state, tracer, fn_state);
        } else {
            return block_63(state, tracer, fn_state);
        };
    }
    fn block_63<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_63_0: const #3412s : i
        let s_63_0: i128 = 3412;
        // C s_63_1: const #14696u : u32
        let s_63_1: u32 = 14696;
        // N s_63_2: write-reg s_63_1 <= s_63_0
        let s_63_2: () = {
            state.write_register::<i128>(s_63_1 as isize, s_63_0);
            tracer.write_register(s_63_1 as isize, s_63_0);
        };
        // C s_63_3: const #28s : i
        let s_63_3: i128 = 28;
        // C s_63_4: const #4s : i
        let s_63_4: i128 = 4;
        // D s_63_5: read-var u#34021:u32
        let s_63_5: u32 = fn_state.u_34021;
        // D s_63_6: cast zx s_63_5 -> bv
        let s_63_6: Bits = Bits::new(s_63_5 as u128, 32u16);
        // D s_63_7: bit-extract s_63_6 s_63_3 s_63_4
        let s_63_7: Bits = (Bits::new(
            ((s_63_6) >> (s_63_3)).value(),
            u16::try_from(s_63_4).unwrap(),
        ));
        // D s_63_8: cast reint s_63_7 -> u8
        let s_63_8: u8 = (s_63_7.value() as u8);
        // C s_63_9: const #22s : i
        let s_63_9: i128 = 22;
        // C s_63_10: const #1s : i
        let s_63_10: i128 = 1;
        // D s_63_11: read-var u#34021:u32
        let s_63_11: u32 = fn_state.u_34021;
        // D s_63_12: cast zx s_63_11 -> bv
        let s_63_12: Bits = Bits::new(s_63_11 as u128, 32u16);
        // D s_63_13: bit-extract s_63_12 s_63_9 s_63_10
        let s_63_13: Bits = (Bits::new(
            ((s_63_12) >> (s_63_9)).value(),
            u16::try_from(s_63_10).unwrap(),
        ));
        // D s_63_14: cast reint s_63_13 -> u8
        let s_63_14: bool = ((s_63_13.value()) != 0);
        // C s_63_15: const #12s : i
        let s_63_15: i128 = 12;
        // C s_63_16: const #4s : i
        let s_63_16: i128 = 4;
        // D s_63_17: read-var u#34021:u32
        let s_63_17: u32 = fn_state.u_34021;
        // D s_63_18: cast zx s_63_17 -> bv
        let s_63_18: Bits = Bits::new(s_63_17 as u128, 32u16);
        // D s_63_19: bit-extract s_63_18 s_63_15 s_63_16
        let s_63_19: Bits = (Bits::new(
            ((s_63_18) >> (s_63_15)).value(),
            u16::try_from(s_63_16).unwrap(),
        ));
        // D s_63_20: cast reint s_63_19 -> u8
        let s_63_20: u8 = (s_63_19.value() as u8);
        // C s_63_21: const #8s : i
        let s_63_21: i128 = 8;
        // C s_63_22: const #2s : i
        let s_63_22: i128 = 2;
        // D s_63_23: read-var u#34021:u32
        let s_63_23: u32 = fn_state.u_34021;
        // D s_63_24: cast zx s_63_23 -> bv
        let s_63_24: Bits = Bits::new(s_63_23 as u128, 32u16);
        // D s_63_25: bit-extract s_63_24 s_63_21 s_63_22
        let s_63_25: Bits = (Bits::new(
            ((s_63_24) >> (s_63_21)).value(),
            u16::try_from(s_63_22).unwrap(),
        ));
        // D s_63_26: cast reint s_63_25 -> u8
        let s_63_26: u8 = (s_63_25.value() as u8);
        // C s_63_27: const #7s : i
        let s_63_27: i128 = 7;
        // C s_63_28: const #1s : i
        let s_63_28: i128 = 1;
        // D s_63_29: read-var u#34021:u32
        let s_63_29: u32 = fn_state.u_34021;
        // D s_63_30: cast zx s_63_29 -> bv
        let s_63_30: Bits = Bits::new(s_63_29 as u128, 32u16);
        // D s_63_31: bit-extract s_63_30 s_63_27 s_63_28
        let s_63_31: Bits = (Bits::new(
            ((s_63_30) >> (s_63_27)).value(),
            u16::try_from(s_63_28).unwrap(),
        ));
        // D s_63_32: cast reint s_63_31 -> u8
        let s_63_32: bool = ((s_63_31.value()) != 0);
        // C s_63_33: const #5s : i
        let s_63_33: i128 = 5;
        // C s_63_34: const #1s : i
        let s_63_34: i128 = 1;
        // D s_63_35: read-var u#34021:u32
        let s_63_35: u32 = fn_state.u_34021;
        // D s_63_36: cast zx s_63_35 -> bv
        let s_63_36: Bits = Bits::new(s_63_35 as u128, 32u16);
        // D s_63_37: bit-extract s_63_36 s_63_33 s_63_34
        let s_63_37: Bits = (Bits::new(
            ((s_63_36) >> (s_63_33)).value(),
            u16::try_from(s_63_34).unwrap(),
        ));
        // D s_63_38: cast reint s_63_37 -> u8
        let s_63_38: bool = ((s_63_37.value()) != 0);
        // C s_63_39: const #0s : i
        let s_63_39: i128 = 0;
        // C s_63_40: const #4s : i
        let s_63_40: i128 = 4;
        // D s_63_41: read-var u#34021:u32
        let s_63_41: u32 = fn_state.u_34021;
        // D s_63_42: cast zx s_63_41 -> bv
        let s_63_42: Bits = Bits::new(s_63_41 as u128, 32u16);
        // D s_63_43: bit-extract s_63_42 s_63_39 s_63_40
        let s_63_43: Bits = (Bits::new(
            ((s_63_42) >> (s_63_39)).value(),
            u16::try_from(s_63_40).unwrap(),
        ));
        // D s_63_44: cast reint s_63_43 -> u8
        let s_63_44: u8 = (s_63_43.value() as u8);
        // D s_63_45: call decode_aarch32_instrs_VCMP_A1enc_A_txt(s_63_8, s_63_14, s_63_20, s_63_26, s_63_32, s_63_38, s_63_44)
        let s_63_45: () = decode_aarch32_instrs_VCMP_A1enc_A_txt(
            state,
            tracer,
            s_63_8,
            s_63_14,
            s_63_20,
            s_63_26,
            s_63_32,
            s_63_38,
            s_63_44,
        );
        // N s_63_46: return
        return;
    }
    fn block_64<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_64_0: read-var merge#var.1:struct
        let s_64_0: u32 = fn_state.merge_var._1;
        // D s_64_1: write-var u#34029 <= s_64_0
        fn_state.u_34029 = s_64_0;
        // C s_64_2: const #23s : i
        let s_64_2: i128 = 23;
        // D s_64_3: read-var u#34029:u32
        let s_64_3: u32 = fn_state.u_34029;
        // D s_64_4: cast zx s_64_3 -> bv
        let s_64_4: Bits = Bits::new(s_64_3 as u128, 32u16);
        // C s_64_5: const #1s : i64
        let s_64_5: i64 = 1;
        // C s_64_6: cast zx s_64_5 -> i
        let s_64_6: i128 = (i128::try_from(s_64_5).unwrap());
        // C s_64_7: const #4s : i
        let s_64_7: i128 = 4;
        // C s_64_8: add s_64_7 s_64_6
        let s_64_8: i128 = (s_64_7 + s_64_6);
        // D s_64_9: bit-extract s_64_4 s_64_2 s_64_8
        let s_64_9: Bits = (Bits::new(
            ((s_64_4) >> (s_64_2)).value(),
            u16::try_from(s_64_8).unwrap(),
        ));
        // D s_64_10: cast reint s_64_9 -> u8
        let s_64_10: u8 = (s_64_9.value() as u8);
        // D s_64_11: cast zx s_64_10 -> bv
        let s_64_11: Bits = Bits::new(s_64_10 as u128, 5u16);
        // C s_64_12: const #29u : u8
        let s_64_12: u8 = 29;
        // C s_64_13: cast zx s_64_12 -> bv
        let s_64_13: Bits = Bits::new(s_64_12 as u128, 5u16);
        // D s_64_14: cmp-eq s_64_11 s_64_13
        let s_64_14: bool = ((s_64_11) == (s_64_13));
        // N s_64_15: branch s_64_14 b1104 b65
        if s_64_14 {
            return block_1104(state, tracer, fn_state);
        } else {
            return block_65(state, tracer, fn_state);
        };
    }
    fn block_65<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_65_0: const #0u : u8
        let s_65_0: bool = false;
        // D s_65_1: write-var gs#412106 <= s_65_0
        fn_state.gs_412106 = s_65_0;
        // N s_65_2: jump b66
        return block_66(state, tracer, fn_state);
    }
    fn block_66<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_66_0: read-var gs#412106:u8
        let s_66_0: bool = fn_state.gs_412106;
        // N s_66_1: branch s_66_0 b1100 b67
        if s_66_0 {
            return block_1100(state, tracer, fn_state);
        } else {
            return block_67(state, tracer, fn_state);
        };
    }
    fn block_67<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_67_0: const #0u : u8
        let s_67_0: bool = false;
        // D s_67_1: write-var gs#412111 <= s_67_0
        fn_state.gs_412111 = s_67_0;
        // N s_67_2: jump b68
        return block_68(state, tracer, fn_state);
    }
    fn block_68<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_68_0: read-var gs#412111:u8
        let s_68_0: bool = fn_state.gs_412111;
        // D s_68_1: not s_68_0
        let s_68_1: bool = !s_68_0;
        // N s_68_2: branch s_68_1 b84 b69
        if s_68_1 {
            return block_84(state, tracer, fn_state);
        } else {
            return block_69(state, tracer, fn_state);
        };
    }
    fn block_69<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_69_0: const #3413s : i
        let s_69_0: i128 = 3413;
        // C s_69_1: const #14696u : u32
        let s_69_1: u32 = 14696;
        // N s_69_2: write-reg s_69_1 <= s_69_0
        let s_69_2: () = {
            state.write_register::<i128>(s_69_1 as isize, s_69_0);
            tracer.write_register(s_69_1 as isize, s_69_0);
        };
        // C s_69_3: const #28s : i
        let s_69_3: i128 = 28;
        // C s_69_4: const #4s : i
        let s_69_4: i128 = 4;
        // D s_69_5: read-var u#34029:u32
        let s_69_5: u32 = fn_state.u_34029;
        // D s_69_6: cast zx s_69_5 -> bv
        let s_69_6: Bits = Bits::new(s_69_5 as u128, 32u16);
        // D s_69_7: bit-extract s_69_6 s_69_3 s_69_4
        let s_69_7: Bits = (Bits::new(
            ((s_69_6) >> (s_69_3)).value(),
            u16::try_from(s_69_4).unwrap(),
        ));
        // D s_69_8: cast reint s_69_7 -> u8
        let s_69_8: u8 = (s_69_7.value() as u8);
        // D s_69_9: write-var u#34030 <= s_69_8
        fn_state.u_34030 = s_69_8;
        // C s_69_10: const #22s : i
        let s_69_10: i128 = 22;
        // C s_69_11: const #1s : i
        let s_69_11: i128 = 1;
        // D s_69_12: read-var u#34029:u32
        let s_69_12: u32 = fn_state.u_34029;
        // D s_69_13: cast zx s_69_12 -> bv
        let s_69_13: Bits = Bits::new(s_69_12 as u128, 32u16);
        // D s_69_14: bit-extract s_69_13 s_69_10 s_69_11
        let s_69_14: Bits = (Bits::new(
            ((s_69_13) >> (s_69_10)).value(),
            u16::try_from(s_69_11).unwrap(),
        ));
        // D s_69_15: cast reint s_69_14 -> u8
        let s_69_15: bool = ((s_69_14.value()) != 0);
        // D s_69_16: write-var u#34031 <= s_69_15
        fn_state.u_34031 = s_69_15;
        // C s_69_17: const #12s : i
        let s_69_17: i128 = 12;
        // C s_69_18: const #4s : i
        let s_69_18: i128 = 4;
        // D s_69_19: read-var u#34029:u32
        let s_69_19: u32 = fn_state.u_34029;
        // D s_69_20: cast zx s_69_19 -> bv
        let s_69_20: Bits = Bits::new(s_69_19 as u128, 32u16);
        // D s_69_21: bit-extract s_69_20 s_69_17 s_69_18
        let s_69_21: Bits = (Bits::new(
            ((s_69_20) >> (s_69_17)).value(),
            u16::try_from(s_69_18).unwrap(),
        ));
        // D s_69_22: cast reint s_69_21 -> u8
        let s_69_22: u8 = (s_69_21.value() as u8);
        // D s_69_23: write-var u#34032 <= s_69_22
        fn_state.u_34032 = s_69_22;
        // C s_69_24: const #8s : i
        let s_69_24: i128 = 8;
        // C s_69_25: const #2s : i
        let s_69_25: i128 = 2;
        // D s_69_26: read-var u#34029:u32
        let s_69_26: u32 = fn_state.u_34029;
        // D s_69_27: cast zx s_69_26 -> bv
        let s_69_27: Bits = Bits::new(s_69_26 as u128, 32u16);
        // D s_69_28: bit-extract s_69_27 s_69_24 s_69_25
        let s_69_28: Bits = (Bits::new(
            ((s_69_27) >> (s_69_24)).value(),
            u16::try_from(s_69_25).unwrap(),
        ));
        // D s_69_29: cast reint s_69_28 -> u8
        let s_69_29: u8 = (s_69_28.value() as u8);
        // D s_69_30: write-var u#34033 <= s_69_29
        fn_state.u_34033 = s_69_29;
        // C s_69_31: const #7s : i
        let s_69_31: i128 = 7;
        // C s_69_32: const #1s : i
        let s_69_32: i128 = 1;
        // D s_69_33: read-var u#34029:u32
        let s_69_33: u32 = fn_state.u_34029;
        // D s_69_34: cast zx s_69_33 -> bv
        let s_69_34: Bits = Bits::new(s_69_33 as u128, 32u16);
        // D s_69_35: bit-extract s_69_34 s_69_31 s_69_32
        let s_69_35: Bits = (Bits::new(
            ((s_69_34) >> (s_69_31)).value(),
            u16::try_from(s_69_32).unwrap(),
        ));
        // D s_69_36: cast reint s_69_35 -> u8
        let s_69_36: bool = ((s_69_35.value()) != 0);
        // D s_69_37: write-var u#34034 <= s_69_36
        fn_state.u_34034 = s_69_36;
        // C s_69_38: const #5s : i
        let s_69_38: i128 = 5;
        // D s_69_39: read-var u#34029:u32
        let s_69_39: u32 = fn_state.u_34029;
        // D s_69_40: cast zx s_69_39 -> bv
        let s_69_40: Bits = Bits::new(s_69_39 as u128, 32u16);
        // C s_69_41: const #1u : u64
        let s_69_41: u64 = 1;
        // D s_69_42: bit-extract s_69_40 s_69_38 s_69_41
        let s_69_42: Bits = (Bits::new(
            ((s_69_40) >> (s_69_38)).value(),
            u16::try_from(s_69_41).unwrap(),
        ));
        // D s_69_43: cast reint s_69_42 -> u8
        let s_69_43: bool = ((s_69_42.value()) != 0);
        // C s_69_44: const #0s : i
        let s_69_44: i128 = 0;
        // C s_69_45: const #0u : u64
        let s_69_45: u64 = 0;
        // D s_69_46: cast zx s_69_43 -> u64
        let s_69_46: u64 = (s_69_43 as u64);
        // C s_69_47: const #1u : u64
        let s_69_47: u64 = 1;
        // D s_69_48: and s_69_46 s_69_47
        let s_69_48: u64 = ((s_69_46) & (s_69_47));
        // D s_69_49: cmp-eq s_69_48 s_69_47
        let s_69_49: bool = ((s_69_48) == (s_69_47));
        // D s_69_50: lsl s_69_46 s_69_44
        let s_69_50: u64 = s_69_46 << s_69_44;
        // D s_69_51: or s_69_45 s_69_50
        let s_69_51: u64 = ((s_69_45) | (s_69_50));
        // D s_69_52: cmpl s_69_50
        let s_69_52: u64 = !s_69_50;
        // D s_69_53: and s_69_45 s_69_52
        let s_69_53: u64 = ((s_69_45) & (s_69_52));
        // D s_69_54: select s_69_49 s_69_51 s_69_53
        let s_69_54: u64 = if s_69_49 { s_69_51 } else { s_69_53 };
        // D s_69_55: cast trunc s_69_54 -> u8
        let s_69_55: bool = ((s_69_54) != 0);
        // D s_69_56: cast zx s_69_55 -> bv
        let s_69_56: Bits = Bits::new(s_69_55 as u128, 1u16);
        // C s_69_57: const #0u : u8
        let s_69_57: bool = false;
        // C s_69_58: cast zx s_69_57 -> bv
        let s_69_58: Bits = Bits::new(s_69_57 as u128, 1u16);
        // D s_69_59: cmp-ne s_69_56 s_69_58
        let s_69_59: bool = ((s_69_56) != (s_69_58));
        // N s_69_60: branch s_69_59 b83 b70
        if s_69_59 {
            return block_83(state, tracer, fn_state);
        } else {
            return block_70(state, tracer, fn_state);
        };
    }
    fn block_70<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_70_0: const #0s : i
        let s_70_0: i128 = 0;
        // D s_70_1: read-var u#34029:u32
        let s_70_1: u32 = fn_state.u_34029;
        // D s_70_2: cast zx s_70_1 -> bv
        let s_70_2: Bits = Bits::new(s_70_1 as u128, 32u16);
        // C s_70_3: const #1u : u64
        let s_70_3: u64 = 1;
        // D s_70_4: bit-extract s_70_2 s_70_0 s_70_3
        let s_70_4: Bits = (Bits::new(
            ((s_70_2) >> (s_70_0)).value(),
            u16::try_from(s_70_3).unwrap(),
        ));
        // D s_70_5: cast reint s_70_4 -> u8
        let s_70_5: bool = ((s_70_4.value()) != 0);
        // C s_70_6: const #0s : i
        let s_70_6: i128 = 0;
        // C s_70_7: const #0u : u64
        let s_70_7: u64 = 0;
        // D s_70_8: cast zx s_70_5 -> u64
        let s_70_8: u64 = (s_70_5 as u64);
        // C s_70_9: const #1u : u64
        let s_70_9: u64 = 1;
        // D s_70_10: and s_70_8 s_70_9
        let s_70_10: u64 = ((s_70_8) & (s_70_9));
        // D s_70_11: cmp-eq s_70_10 s_70_9
        let s_70_11: bool = ((s_70_10) == (s_70_9));
        // D s_70_12: lsl s_70_8 s_70_6
        let s_70_12: u64 = s_70_8 << s_70_6;
        // D s_70_13: or s_70_7 s_70_12
        let s_70_13: u64 = ((s_70_7) | (s_70_12));
        // D s_70_14: cmpl s_70_12
        let s_70_14: u64 = !s_70_12;
        // D s_70_15: and s_70_7 s_70_14
        let s_70_15: u64 = ((s_70_7) & (s_70_14));
        // D s_70_16: select s_70_11 s_70_13 s_70_15
        let s_70_16: u64 = if s_70_11 { s_70_13 } else { s_70_15 };
        // D s_70_17: cast trunc s_70_16 -> u8
        let s_70_17: bool = ((s_70_16) != 0);
        // D s_70_18: cast zx s_70_17 -> bv
        let s_70_18: Bits = Bits::new(s_70_17 as u128, 1u16);
        // C s_70_19: const #0u : u8
        let s_70_19: bool = false;
        // C s_70_20: cast zx s_70_19 -> bv
        let s_70_20: Bits = Bits::new(s_70_19 as u128, 1u16);
        // D s_70_21: cmp-ne s_70_18 s_70_20
        let s_70_21: bool = ((s_70_18) != (s_70_20));
        // D s_70_22: write-var gs#412128 <= s_70_21
        fn_state.gs_412128 = s_70_21;
        // N s_70_23: jump b71
        return block_71(state, tracer, fn_state);
    }
    fn block_71<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_71_0: read-var gs#412128:u8
        let s_71_0: bool = fn_state.gs_412128;
        // N s_71_1: branch s_71_0 b82 b72
        if s_71_0 {
            return block_82(state, tracer, fn_state);
        } else {
            return block_72(state, tracer, fn_state);
        };
    }
    fn block_72<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_72_0: const #1s : i
        let s_72_0: i128 = 1;
        // D s_72_1: read-var u#34029:u32
        let s_72_1: u32 = fn_state.u_34029;
        // D s_72_2: cast zx s_72_1 -> bv
        let s_72_2: Bits = Bits::new(s_72_1 as u128, 32u16);
        // C s_72_3: const #1u : u64
        let s_72_3: u64 = 1;
        // D s_72_4: bit-extract s_72_2 s_72_0 s_72_3
        let s_72_4: Bits = (Bits::new(
            ((s_72_2) >> (s_72_0)).value(),
            u16::try_from(s_72_3).unwrap(),
        ));
        // D s_72_5: cast reint s_72_4 -> u8
        let s_72_5: bool = ((s_72_4.value()) != 0);
        // C s_72_6: const #0s : i
        let s_72_6: i128 = 0;
        // C s_72_7: const #0u : u64
        let s_72_7: u64 = 0;
        // D s_72_8: cast zx s_72_5 -> u64
        let s_72_8: u64 = (s_72_5 as u64);
        // C s_72_9: const #1u : u64
        let s_72_9: u64 = 1;
        // D s_72_10: and s_72_8 s_72_9
        let s_72_10: u64 = ((s_72_8) & (s_72_9));
        // D s_72_11: cmp-eq s_72_10 s_72_9
        let s_72_11: bool = ((s_72_10) == (s_72_9));
        // D s_72_12: lsl s_72_8 s_72_6
        let s_72_12: u64 = s_72_8 << s_72_6;
        // D s_72_13: or s_72_7 s_72_12
        let s_72_13: u64 = ((s_72_7) | (s_72_12));
        // D s_72_14: cmpl s_72_12
        let s_72_14: u64 = !s_72_12;
        // D s_72_15: and s_72_7 s_72_14
        let s_72_15: u64 = ((s_72_7) & (s_72_14));
        // D s_72_16: select s_72_11 s_72_13 s_72_15
        let s_72_16: u64 = if s_72_11 { s_72_13 } else { s_72_15 };
        // D s_72_17: cast trunc s_72_16 -> u8
        let s_72_17: bool = ((s_72_16) != 0);
        // D s_72_18: cast zx s_72_17 -> bv
        let s_72_18: Bits = Bits::new(s_72_17 as u128, 1u16);
        // C s_72_19: const #0u : u8
        let s_72_19: bool = false;
        // C s_72_20: cast zx s_72_19 -> bv
        let s_72_20: Bits = Bits::new(s_72_19 as u128, 1u16);
        // D s_72_21: cmp-ne s_72_18 s_72_20
        let s_72_21: bool = ((s_72_18) != (s_72_20));
        // D s_72_22: write-var gs#412131 <= s_72_21
        fn_state.gs_412131 = s_72_21;
        // N s_72_23: jump b73
        return block_73(state, tracer, fn_state);
    }
    fn block_73<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_73_0: read-var gs#412131:u8
        let s_73_0: bool = fn_state.gs_412131;
        // N s_73_1: branch s_73_0 b81 b74
        if s_73_0 {
            return block_81(state, tracer, fn_state);
        } else {
            return block_74(state, tracer, fn_state);
        };
    }
    fn block_74<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_74_0: const #2s : i
        let s_74_0: i128 = 2;
        // D s_74_1: read-var u#34029:u32
        let s_74_1: u32 = fn_state.u_34029;
        // D s_74_2: cast zx s_74_1 -> bv
        let s_74_2: Bits = Bits::new(s_74_1 as u128, 32u16);
        // C s_74_3: const #1u : u64
        let s_74_3: u64 = 1;
        // D s_74_4: bit-extract s_74_2 s_74_0 s_74_3
        let s_74_4: Bits = (Bits::new(
            ((s_74_2) >> (s_74_0)).value(),
            u16::try_from(s_74_3).unwrap(),
        ));
        // D s_74_5: cast reint s_74_4 -> u8
        let s_74_5: bool = ((s_74_4.value()) != 0);
        // C s_74_6: const #0s : i
        let s_74_6: i128 = 0;
        // C s_74_7: const #0u : u64
        let s_74_7: u64 = 0;
        // D s_74_8: cast zx s_74_5 -> u64
        let s_74_8: u64 = (s_74_5 as u64);
        // C s_74_9: const #1u : u64
        let s_74_9: u64 = 1;
        // D s_74_10: and s_74_8 s_74_9
        let s_74_10: u64 = ((s_74_8) & (s_74_9));
        // D s_74_11: cmp-eq s_74_10 s_74_9
        let s_74_11: bool = ((s_74_10) == (s_74_9));
        // D s_74_12: lsl s_74_8 s_74_6
        let s_74_12: u64 = s_74_8 << s_74_6;
        // D s_74_13: or s_74_7 s_74_12
        let s_74_13: u64 = ((s_74_7) | (s_74_12));
        // D s_74_14: cmpl s_74_12
        let s_74_14: u64 = !s_74_12;
        // D s_74_15: and s_74_7 s_74_14
        let s_74_15: u64 = ((s_74_7) & (s_74_14));
        // D s_74_16: select s_74_11 s_74_13 s_74_15
        let s_74_16: u64 = if s_74_11 { s_74_13 } else { s_74_15 };
        // D s_74_17: cast trunc s_74_16 -> u8
        let s_74_17: bool = ((s_74_16) != 0);
        // D s_74_18: cast zx s_74_17 -> bv
        let s_74_18: Bits = Bits::new(s_74_17 as u128, 1u16);
        // C s_74_19: const #0u : u8
        let s_74_19: bool = false;
        // C s_74_20: cast zx s_74_19 -> bv
        let s_74_20: Bits = Bits::new(s_74_19 as u128, 1u16);
        // D s_74_21: cmp-ne s_74_18 s_74_20
        let s_74_21: bool = ((s_74_18) != (s_74_20));
        // D s_74_22: write-var gs#412134 <= s_74_21
        fn_state.gs_412134 = s_74_21;
        // N s_74_23: jump b75
        return block_75(state, tracer, fn_state);
    }
    fn block_75<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_75_0: read-var gs#412134:u8
        let s_75_0: bool = fn_state.gs_412134;
        // N s_75_1: branch s_75_0 b80 b76
        if s_75_0 {
            return block_80(state, tracer, fn_state);
        } else {
            return block_76(state, tracer, fn_state);
        };
    }
    fn block_76<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_76_0: const #3s : i
        let s_76_0: i128 = 3;
        // D s_76_1: read-var u#34029:u32
        let s_76_1: u32 = fn_state.u_34029;
        // D s_76_2: cast zx s_76_1 -> bv
        let s_76_2: Bits = Bits::new(s_76_1 as u128, 32u16);
        // C s_76_3: const #1u : u64
        let s_76_3: u64 = 1;
        // D s_76_4: bit-extract s_76_2 s_76_0 s_76_3
        let s_76_4: Bits = (Bits::new(
            ((s_76_2) >> (s_76_0)).value(),
            u16::try_from(s_76_3).unwrap(),
        ));
        // D s_76_5: cast reint s_76_4 -> u8
        let s_76_5: bool = ((s_76_4.value()) != 0);
        // C s_76_6: const #0s : i
        let s_76_6: i128 = 0;
        // C s_76_7: const #0u : u64
        let s_76_7: u64 = 0;
        // D s_76_8: cast zx s_76_5 -> u64
        let s_76_8: u64 = (s_76_5 as u64);
        // C s_76_9: const #1u : u64
        let s_76_9: u64 = 1;
        // D s_76_10: and s_76_8 s_76_9
        let s_76_10: u64 = ((s_76_8) & (s_76_9));
        // D s_76_11: cmp-eq s_76_10 s_76_9
        let s_76_11: bool = ((s_76_10) == (s_76_9));
        // D s_76_12: lsl s_76_8 s_76_6
        let s_76_12: u64 = s_76_8 << s_76_6;
        // D s_76_13: or s_76_7 s_76_12
        let s_76_13: u64 = ((s_76_7) | (s_76_12));
        // D s_76_14: cmpl s_76_12
        let s_76_14: u64 = !s_76_12;
        // D s_76_15: and s_76_7 s_76_14
        let s_76_15: u64 = ((s_76_7) & (s_76_14));
        // D s_76_16: select s_76_11 s_76_13 s_76_15
        let s_76_16: u64 = if s_76_11 { s_76_13 } else { s_76_15 };
        // D s_76_17: cast trunc s_76_16 -> u8
        let s_76_17: bool = ((s_76_16) != 0);
        // D s_76_18: cast zx s_76_17 -> bv
        let s_76_18: Bits = Bits::new(s_76_17 as u128, 1u16);
        // C s_76_19: const #0u : u8
        let s_76_19: bool = false;
        // C s_76_20: cast zx s_76_19 -> bv
        let s_76_20: Bits = Bits::new(s_76_19 as u128, 1u16);
        // D s_76_21: cmp-ne s_76_18 s_76_20
        let s_76_21: bool = ((s_76_18) != (s_76_20));
        // D s_76_22: write-var gs#412137 <= s_76_21
        fn_state.gs_412137 = s_76_21;
        // N s_76_23: jump b77
        return block_77(state, tracer, fn_state);
    }
    fn block_77<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_77_0: read-var gs#412137:u8
        let s_77_0: bool = fn_state.gs_412137;
        // N s_77_1: branch s_77_0 b79 b78
        if s_77_0 {
            return block_79(state, tracer, fn_state);
        } else {
            return block_78(state, tracer, fn_state);
        };
    }
    fn block_78<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_78_0: read-var u#34030:u8
        let s_78_0: u8 = fn_state.u_34030;
        // D s_78_1: read-var u#34031:u8
        let s_78_1: bool = fn_state.u_34031;
        // D s_78_2: read-var u#34032:u8
        let s_78_2: u8 = fn_state.u_34032;
        // D s_78_3: read-var u#34033:u8
        let s_78_3: u8 = fn_state.u_34033;
        // D s_78_4: read-var u#34034:u8
        let s_78_4: bool = fn_state.u_34034;
        // D s_78_5: call decode_aarch32_instrs_VCMP_A2enc_A_txt(s_78_0, s_78_1, s_78_2, s_78_3, s_78_4)
        let s_78_5: () = decode_aarch32_instrs_VCMP_A2enc_A_txt(
            state,
            tracer,
            s_78_0,
            s_78_1,
            s_78_2,
            s_78_3,
            s_78_4,
        );
        // N s_78_6: return
        return;
    }
    fn block_79<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_79_0: panic
        panic!("{:?}", ());
        // N s_79_1: return
        return;
    }
    fn block_80<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_80_0: const #1u : u8
        let s_80_0: bool = true;
        // D s_80_1: write-var gs#412137 <= s_80_0
        fn_state.gs_412137 = s_80_0;
        // N s_80_2: jump b77
        return block_77(state, tracer, fn_state);
    }
    fn block_81<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_81_0: const #1u : u8
        let s_81_0: bool = true;
        // D s_81_1: write-var gs#412134 <= s_81_0
        fn_state.gs_412134 = s_81_0;
        // N s_81_2: jump b75
        return block_75(state, tracer, fn_state);
    }
    fn block_82<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_82_0: const #1u : u8
        let s_82_0: bool = true;
        // D s_82_1: write-var gs#412131 <= s_82_0
        fn_state.gs_412131 = s_82_0;
        // N s_82_2: jump b73
        return block_73(state, tracer, fn_state);
    }
    fn block_83<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_83_0: const #1u : u8
        let s_83_0: bool = true;
        // D s_83_1: write-var gs#412128 <= s_83_0
        fn_state.gs_412128 = s_83_0;
        // N s_83_2: jump b71
        return block_71(state, tracer, fn_state);
    }
    fn block_84<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_84_0: read-var merge#var.1:struct
        let s_84_0: u32 = fn_state.merge_var._1;
        // D s_84_1: write-var u#34036 <= s_84_0
        fn_state.u_34036 = s_84_0;
        // C s_84_2: const #23s : i
        let s_84_2: i128 = 23;
        // D s_84_3: read-var u#34036:u32
        let s_84_3: u32 = fn_state.u_34036;
        // D s_84_4: cast zx s_84_3 -> bv
        let s_84_4: Bits = Bits::new(s_84_3 as u128, 32u16);
        // C s_84_5: const #1s : i64
        let s_84_5: i64 = 1;
        // C s_84_6: cast zx s_84_5 -> i
        let s_84_6: i128 = (i128::try_from(s_84_5).unwrap());
        // C s_84_7: const #4s : i
        let s_84_7: i128 = 4;
        // C s_84_8: add s_84_7 s_84_6
        let s_84_8: i128 = (s_84_7 + s_84_6);
        // D s_84_9: bit-extract s_84_4 s_84_2 s_84_8
        let s_84_9: Bits = (Bits::new(
            ((s_84_4) >> (s_84_2)).value(),
            u16::try_from(s_84_8).unwrap(),
        ));
        // D s_84_10: cast reint s_84_9 -> u8
        let s_84_10: u8 = (s_84_9.value() as u8);
        // D s_84_11: cast zx s_84_10 -> bv
        let s_84_11: Bits = Bits::new(s_84_10 as u128, 5u16);
        // C s_84_12: const #29u : u8
        let s_84_12: u8 = 29;
        // C s_84_13: cast zx s_84_12 -> bv
        let s_84_13: Bits = Bits::new(s_84_12 as u128, 5u16);
        // D s_84_14: cmp-eq s_84_11 s_84_13
        let s_84_14: bool = ((s_84_11) == (s_84_13));
        // N s_84_15: branch s_84_14 b1090 b85
        if s_84_14 {
            return block_1090(state, tracer, fn_state);
        } else {
            return block_85(state, tracer, fn_state);
        };
    }
    fn block_85<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_85_0: const #0u : u8
        let s_85_0: bool = false;
        // D s_85_1: write-var gs#412152 <= s_85_0
        fn_state.gs_412152 = s_85_0;
        // N s_85_2: jump b86
        return block_86(state, tracer, fn_state);
    }
    fn block_86<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_86_0: read-var gs#412152:u8
        let s_86_0: bool = fn_state.gs_412152;
        // N s_86_1: branch s_86_0 b1086 b87
        if s_86_0 {
            return block_1086(state, tracer, fn_state);
        } else {
            return block_87(state, tracer, fn_state);
        };
    }
    fn block_87<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_87_0: const #0u : u8
        let s_87_0: bool = false;
        // D s_87_1: write-var gs#412157 <= s_87_0
        fn_state.gs_412157 = s_87_0;
        // N s_87_2: jump b88
        return block_88(state, tracer, fn_state);
    }
    fn block_88<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_88_0: read-var gs#412157:u8
        let s_88_0: bool = fn_state.gs_412157;
        // D s_88_1: not s_88_0
        let s_88_1: bool = !s_88_0;
        // N s_88_2: branch s_88_1 b90 b89
        if s_88_1 {
            return block_90(state, tracer, fn_state);
        } else {
            return block_89(state, tracer, fn_state);
        };
    }
    fn block_89<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_89_0: const #3418s : i
        let s_89_0: i128 = 3418;
        // C s_89_1: const #14696u : u32
        let s_89_1: u32 = 14696;
        // N s_89_2: write-reg s_89_1 <= s_89_0
        let s_89_2: () = {
            state.write_register::<i128>(s_89_1 as isize, s_89_0);
            tracer.write_register(s_89_1 as isize, s_89_0);
        };
        // C s_89_3: const #28s : i
        let s_89_3: i128 = 28;
        // C s_89_4: const #4s : i
        let s_89_4: i128 = 4;
        // D s_89_5: read-var u#34036:u32
        let s_89_5: u32 = fn_state.u_34036;
        // D s_89_6: cast zx s_89_5 -> bv
        let s_89_6: Bits = Bits::new(s_89_5 as u128, 32u16);
        // D s_89_7: bit-extract s_89_6 s_89_3 s_89_4
        let s_89_7: Bits = (Bits::new(
            ((s_89_6) >> (s_89_3)).value(),
            u16::try_from(s_89_4).unwrap(),
        ));
        // D s_89_8: cast reint s_89_7 -> u8
        let s_89_8: u8 = (s_89_7.value() as u8);
        // C s_89_9: const #22s : i
        let s_89_9: i128 = 22;
        // C s_89_10: const #1s : i
        let s_89_10: i128 = 1;
        // D s_89_11: read-var u#34036:u32
        let s_89_11: u32 = fn_state.u_34036;
        // D s_89_12: cast zx s_89_11 -> bv
        let s_89_12: Bits = Bits::new(s_89_11 as u128, 32u16);
        // D s_89_13: bit-extract s_89_12 s_89_9 s_89_10
        let s_89_13: Bits = (Bits::new(
            ((s_89_12) >> (s_89_9)).value(),
            u16::try_from(s_89_10).unwrap(),
        ));
        // D s_89_14: cast reint s_89_13 -> u8
        let s_89_14: bool = ((s_89_13.value()) != 0);
        // C s_89_15: const #16s : i
        let s_89_15: i128 = 16;
        // C s_89_16: const #1s : i
        let s_89_16: i128 = 1;
        // D s_89_17: read-var u#34036:u32
        let s_89_17: u32 = fn_state.u_34036;
        // D s_89_18: cast zx s_89_17 -> bv
        let s_89_18: Bits = Bits::new(s_89_17 as u128, 32u16);
        // D s_89_19: bit-extract s_89_18 s_89_15 s_89_16
        let s_89_19: Bits = (Bits::new(
            ((s_89_18) >> (s_89_15)).value(),
            u16::try_from(s_89_16).unwrap(),
        ));
        // D s_89_20: cast reint s_89_19 -> u8
        let s_89_20: bool = ((s_89_19.value()) != 0);
        // C s_89_21: const #12s : i
        let s_89_21: i128 = 12;
        // C s_89_22: const #4s : i
        let s_89_22: i128 = 4;
        // D s_89_23: read-var u#34036:u32
        let s_89_23: u32 = fn_state.u_34036;
        // D s_89_24: cast zx s_89_23 -> bv
        let s_89_24: Bits = Bits::new(s_89_23 as u128, 32u16);
        // D s_89_25: bit-extract s_89_24 s_89_21 s_89_22
        let s_89_25: Bits = (Bits::new(
            ((s_89_24) >> (s_89_21)).value(),
            u16::try_from(s_89_22).unwrap(),
        ));
        // D s_89_26: cast reint s_89_25 -> u8
        let s_89_26: u8 = (s_89_25.value() as u8);
        // C s_89_27: const #8s : i
        let s_89_27: i128 = 8;
        // C s_89_28: const #1s : i
        let s_89_28: i128 = 1;
        // D s_89_29: read-var u#34036:u32
        let s_89_29: u32 = fn_state.u_34036;
        // D s_89_30: cast zx s_89_29 -> bv
        let s_89_30: Bits = Bits::new(s_89_29 as u128, 32u16);
        // D s_89_31: bit-extract s_89_30 s_89_27 s_89_28
        let s_89_31: Bits = (Bits::new(
            ((s_89_30) >> (s_89_27)).value(),
            u16::try_from(s_89_28).unwrap(),
        ));
        // D s_89_32: cast reint s_89_31 -> u8
        let s_89_32: bool = ((s_89_31.value()) != 0);
        // C s_89_33: const #7s : i
        let s_89_33: i128 = 7;
        // C s_89_34: const #1s : i
        let s_89_34: i128 = 1;
        // D s_89_35: read-var u#34036:u32
        let s_89_35: u32 = fn_state.u_34036;
        // D s_89_36: cast zx s_89_35 -> bv
        let s_89_36: Bits = Bits::new(s_89_35 as u128, 32u16);
        // D s_89_37: bit-extract s_89_36 s_89_33 s_89_34
        let s_89_37: Bits = (Bits::new(
            ((s_89_36) >> (s_89_33)).value(),
            u16::try_from(s_89_34).unwrap(),
        ));
        // D s_89_38: cast reint s_89_37 -> u8
        let s_89_38: bool = ((s_89_37.value()) != 0);
        // C s_89_39: const #5s : i
        let s_89_39: i128 = 5;
        // C s_89_40: const #1s : i
        let s_89_40: i128 = 1;
        // D s_89_41: read-var u#34036:u32
        let s_89_41: u32 = fn_state.u_34036;
        // D s_89_42: cast zx s_89_41 -> bv
        let s_89_42: Bits = Bits::new(s_89_41 as u128, 32u16);
        // D s_89_43: bit-extract s_89_42 s_89_39 s_89_40
        let s_89_43: Bits = (Bits::new(
            ((s_89_42) >> (s_89_39)).value(),
            u16::try_from(s_89_40).unwrap(),
        ));
        // D s_89_44: cast reint s_89_43 -> u8
        let s_89_44: bool = ((s_89_43.value()) != 0);
        // C s_89_45: const #0s : i
        let s_89_45: i128 = 0;
        // C s_89_46: const #4s : i
        let s_89_46: i128 = 4;
        // D s_89_47: read-var u#34036:u32
        let s_89_47: u32 = fn_state.u_34036;
        // D s_89_48: cast zx s_89_47 -> bv
        let s_89_48: Bits = Bits::new(s_89_47 as u128, 32u16);
        // D s_89_49: bit-extract s_89_48 s_89_45 s_89_46
        let s_89_49: Bits = (Bits::new(
            ((s_89_48) >> (s_89_45)).value(),
            u16::try_from(s_89_46).unwrap(),
        ));
        // D s_89_50: cast reint s_89_49 -> u8
        let s_89_50: u8 = (s_89_49.value() as u8);
        // D s_89_51: call decode_aarch32_instrs_VCVTB_A1enc_A_txt(s_89_8, s_89_14, s_89_20, s_89_26, s_89_32, s_89_38, s_89_44, s_89_50)
        let s_89_51: () = decode_aarch32_instrs_VCVTB_A1enc_A_txt(
            state,
            tracer,
            s_89_8,
            s_89_14,
            s_89_20,
            s_89_26,
            s_89_32,
            s_89_38,
            s_89_44,
            s_89_50,
        );
        // N s_89_52: return
        return;
    }
    fn block_90<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_90_0: read-var merge#var.1:struct
        let s_90_0: u32 = fn_state.merge_var._1;
        // D s_90_1: write-var u#34043 <= s_90_0
        fn_state.u_34043 = s_90_0;
        // C s_90_2: const #23s : i
        let s_90_2: i128 = 23;
        // D s_90_3: read-var u#34043:u32
        let s_90_3: u32 = fn_state.u_34043;
        // D s_90_4: cast zx s_90_3 -> bv
        let s_90_4: Bits = Bits::new(s_90_3 as u128, 32u16);
        // C s_90_5: const #1s : i64
        let s_90_5: i64 = 1;
        // C s_90_6: cast zx s_90_5 -> i
        let s_90_6: i128 = (i128::try_from(s_90_5).unwrap());
        // C s_90_7: const #4s : i
        let s_90_7: i128 = 4;
        // C s_90_8: add s_90_7 s_90_6
        let s_90_8: i128 = (s_90_7 + s_90_6);
        // D s_90_9: bit-extract s_90_4 s_90_2 s_90_8
        let s_90_9: Bits = (Bits::new(
            ((s_90_4) >> (s_90_2)).value(),
            u16::try_from(s_90_8).unwrap(),
        ));
        // D s_90_10: cast reint s_90_9 -> u8
        let s_90_10: u8 = (s_90_9.value() as u8);
        // D s_90_11: cast zx s_90_10 -> bv
        let s_90_11: Bits = Bits::new(s_90_10 as u128, 5u16);
        // C s_90_12: const #29u : u8
        let s_90_12: u8 = 29;
        // C s_90_13: cast zx s_90_12 -> bv
        let s_90_13: Bits = Bits::new(s_90_12 as u128, 5u16);
        // D s_90_14: cmp-eq s_90_11 s_90_13
        let s_90_14: bool = ((s_90_11) == (s_90_13));
        // N s_90_15: branch s_90_14 b1076 b91
        if s_90_14 {
            return block_1076(state, tracer, fn_state);
        } else {
            return block_91(state, tracer, fn_state);
        };
    }
    fn block_91<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_91_0: const #0u : u8
        let s_91_0: bool = false;
        // D s_91_1: write-var gs#412190 <= s_91_0
        fn_state.gs_412190 = s_91_0;
        // N s_91_2: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_92<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_92_0: read-var gs#412190:u8
        let s_92_0: bool = fn_state.gs_412190;
        // N s_92_1: branch s_92_0 b1072 b93
        if s_92_0 {
            return block_1072(state, tracer, fn_state);
        } else {
            return block_93(state, tracer, fn_state);
        };
    }
    fn block_93<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_93_0: const #0u : u8
        let s_93_0: bool = false;
        // D s_93_1: write-var gs#412195 <= s_93_0
        fn_state.gs_412195 = s_93_0;
        // N s_93_2: jump b94
        return block_94(state, tracer, fn_state);
    }
    fn block_94<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_94_0: read-var gs#412195:u8
        let s_94_0: bool = fn_state.gs_412195;
        // D s_94_1: not s_94_0
        let s_94_1: bool = !s_94_0;
        // N s_94_2: branch s_94_1 b96 b95
        if s_94_1 {
            return block_96(state, tracer, fn_state);
        } else {
            return block_95(state, tracer, fn_state);
        };
    }
    fn block_95<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_95_0: const #3420s : i
        let s_95_0: i128 = 3420;
        // C s_95_1: const #14696u : u32
        let s_95_1: u32 = 14696;
        // N s_95_2: write-reg s_95_1 <= s_95_0
        let s_95_2: () = {
            state.write_register::<i128>(s_95_1 as isize, s_95_0);
            tracer.write_register(s_95_1 as isize, s_95_0);
        };
        // C s_95_3: const #28s : i
        let s_95_3: i128 = 28;
        // C s_95_4: const #4s : i
        let s_95_4: i128 = 4;
        // D s_95_5: read-var u#34043:u32
        let s_95_5: u32 = fn_state.u_34043;
        // D s_95_6: cast zx s_95_5 -> bv
        let s_95_6: Bits = Bits::new(s_95_5 as u128, 32u16);
        // D s_95_7: bit-extract s_95_6 s_95_3 s_95_4
        let s_95_7: Bits = (Bits::new(
            ((s_95_6) >> (s_95_3)).value(),
            u16::try_from(s_95_4).unwrap(),
        ));
        // D s_95_8: cast reint s_95_7 -> u8
        let s_95_8: u8 = (s_95_7.value() as u8);
        // C s_95_9: const #22s : i
        let s_95_9: i128 = 22;
        // C s_95_10: const #1s : i
        let s_95_10: i128 = 1;
        // D s_95_11: read-var u#34043:u32
        let s_95_11: u32 = fn_state.u_34043;
        // D s_95_12: cast zx s_95_11 -> bv
        let s_95_12: Bits = Bits::new(s_95_11 as u128, 32u16);
        // D s_95_13: bit-extract s_95_12 s_95_9 s_95_10
        let s_95_13: Bits = (Bits::new(
            ((s_95_12) >> (s_95_9)).value(),
            u16::try_from(s_95_10).unwrap(),
        ));
        // D s_95_14: cast reint s_95_13 -> u8
        let s_95_14: bool = ((s_95_13.value()) != 0);
        // C s_95_15: const #12s : i
        let s_95_15: i128 = 12;
        // C s_95_16: const #4s : i
        let s_95_16: i128 = 4;
        // D s_95_17: read-var u#34043:u32
        let s_95_17: u32 = fn_state.u_34043;
        // D s_95_18: cast zx s_95_17 -> bv
        let s_95_18: Bits = Bits::new(s_95_17 as u128, 32u16);
        // D s_95_19: bit-extract s_95_18 s_95_15 s_95_16
        let s_95_19: Bits = (Bits::new(
            ((s_95_18) >> (s_95_15)).value(),
            u16::try_from(s_95_16).unwrap(),
        ));
        // D s_95_20: cast reint s_95_19 -> u8
        let s_95_20: u8 = (s_95_19.value() as u8);
        // C s_95_21: const #8s : i
        let s_95_21: i128 = 8;
        // C s_95_22: const #2s : i
        let s_95_22: i128 = 2;
        // D s_95_23: read-var u#34043:u32
        let s_95_23: u32 = fn_state.u_34043;
        // D s_95_24: cast zx s_95_23 -> bv
        let s_95_24: Bits = Bits::new(s_95_23 as u128, 32u16);
        // D s_95_25: bit-extract s_95_24 s_95_21 s_95_22
        let s_95_25: Bits = (Bits::new(
            ((s_95_24) >> (s_95_21)).value(),
            u16::try_from(s_95_22).unwrap(),
        ));
        // D s_95_26: cast reint s_95_25 -> u8
        let s_95_26: u8 = (s_95_25.value() as u8);
        // C s_95_27: const #5s : i
        let s_95_27: i128 = 5;
        // C s_95_28: const #1s : i
        let s_95_28: i128 = 1;
        // D s_95_29: read-var u#34043:u32
        let s_95_29: u32 = fn_state.u_34043;
        // D s_95_30: cast zx s_95_29 -> bv
        let s_95_30: Bits = Bits::new(s_95_29 as u128, 32u16);
        // D s_95_31: bit-extract s_95_30 s_95_27 s_95_28
        let s_95_31: Bits = (Bits::new(
            ((s_95_30) >> (s_95_27)).value(),
            u16::try_from(s_95_28).unwrap(),
        ));
        // D s_95_32: cast reint s_95_31 -> u8
        let s_95_32: bool = ((s_95_31.value()) != 0);
        // C s_95_33: const #0s : i
        let s_95_33: i128 = 0;
        // C s_95_34: const #4s : i
        let s_95_34: i128 = 4;
        // D s_95_35: read-var u#34043:u32
        let s_95_35: u32 = fn_state.u_34043;
        // D s_95_36: cast zx s_95_35 -> bv
        let s_95_36: Bits = Bits::new(s_95_35 as u128, 32u16);
        // D s_95_37: bit-extract s_95_36 s_95_33 s_95_34
        let s_95_37: Bits = (Bits::new(
            ((s_95_36) >> (s_95_33)).value(),
            u16::try_from(s_95_34).unwrap(),
        ));
        // D s_95_38: cast reint s_95_37 -> u8
        let s_95_38: u8 = (s_95_37.value() as u8);
        // D s_95_39: call decode_aarch32_instrs_VCVT_ds_A1enc_A_txt(s_95_8, s_95_14, s_95_20, s_95_26, s_95_32, s_95_38)
        let s_95_39: () = decode_aarch32_instrs_VCVT_ds_A1enc_A_txt(
            state,
            tracer,
            s_95_8,
            s_95_14,
            s_95_20,
            s_95_26,
            s_95_32,
            s_95_38,
        );
        // N s_95_40: return
        return;
    }
    fn block_96<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_96_0: read-var merge#var.1:struct
        let s_96_0: u32 = fn_state.merge_var._1;
        // D s_96_1: write-var u#34051 <= s_96_0
        fn_state.u_34051 = s_96_0;
        // C s_96_2: const #23s : i
        let s_96_2: i128 = 23;
        // D s_96_3: read-var u#34051:u32
        let s_96_3: u32 = fn_state.u_34051;
        // D s_96_4: cast zx s_96_3 -> bv
        let s_96_4: Bits = Bits::new(s_96_3 as u128, 32u16);
        // C s_96_5: const #1s : i64
        let s_96_5: i64 = 1;
        // C s_96_6: cast zx s_96_5 -> i
        let s_96_6: i128 = (i128::try_from(s_96_5).unwrap());
        // C s_96_7: const #4s : i
        let s_96_7: i128 = 4;
        // C s_96_8: add s_96_7 s_96_6
        let s_96_8: i128 = (s_96_7 + s_96_6);
        // D s_96_9: bit-extract s_96_4 s_96_2 s_96_8
        let s_96_9: Bits = (Bits::new(
            ((s_96_4) >> (s_96_2)).value(),
            u16::try_from(s_96_8).unwrap(),
        ));
        // D s_96_10: cast reint s_96_9 -> u8
        let s_96_10: u8 = (s_96_9.value() as u8);
        // D s_96_11: cast zx s_96_10 -> bv
        let s_96_11: Bits = Bits::new(s_96_10 as u128, 5u16);
        // C s_96_12: const #29u : u8
        let s_96_12: u8 = 29;
        // C s_96_13: cast zx s_96_12 -> bv
        let s_96_13: Bits = Bits::new(s_96_12 as u128, 5u16);
        // D s_96_14: cmp-eq s_96_11 s_96_13
        let s_96_14: bool = ((s_96_11) == (s_96_13));
        // N s_96_15: branch s_96_14 b1062 b97
        if s_96_14 {
            return block_1062(state, tracer, fn_state);
        } else {
            return block_97(state, tracer, fn_state);
        };
    }
    fn block_97<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_97_0: const #0u : u8
        let s_97_0: bool = false;
        // D s_97_1: write-var gs#412224 <= s_97_0
        fn_state.gs_412224 = s_97_0;
        // N s_97_2: jump b98
        return block_98(state, tracer, fn_state);
    }
    fn block_98<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_98_0: read-var gs#412224:u8
        let s_98_0: bool = fn_state.gs_412224;
        // N s_98_1: branch s_98_0 b1058 b99
        if s_98_0 {
            return block_1058(state, tracer, fn_state);
        } else {
            return block_99(state, tracer, fn_state);
        };
    }
    fn block_99<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_99_0: const #0u : u8
        let s_99_0: bool = false;
        // D s_99_1: write-var gs#412229 <= s_99_0
        fn_state.gs_412229 = s_99_0;
        // N s_99_2: jump b100
        return block_100(state, tracer, fn_state);
    }
    fn block_100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_100_0: read-var gs#412229:u8
        let s_100_0: bool = fn_state.gs_412229;
        // D s_100_1: not s_100_0
        let s_100_1: bool = !s_100_0;
        // N s_100_2: branch s_100_1 b102 b101
        if s_100_1 {
            return block_102(state, tracer, fn_state);
        } else {
            return block_101(state, tracer, fn_state);
        };
    }
    fn block_101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_101_0: const #3426s : i
        let s_101_0: i128 = 3426;
        // C s_101_1: const #14696u : u32
        let s_101_1: u32 = 14696;
        // N s_101_2: write-reg s_101_1 <= s_101_0
        let s_101_2: () = {
            state.write_register::<i128>(s_101_1 as isize, s_101_0);
            tracer.write_register(s_101_1 as isize, s_101_0);
        };
        // C s_101_3: const #28s : i
        let s_101_3: i128 = 28;
        // C s_101_4: const #4s : i
        let s_101_4: i128 = 4;
        // D s_101_5: read-var u#34051:u32
        let s_101_5: u32 = fn_state.u_34051;
        // D s_101_6: cast zx s_101_5 -> bv
        let s_101_6: Bits = Bits::new(s_101_5 as u128, 32u16);
        // D s_101_7: bit-extract s_101_6 s_101_3 s_101_4
        let s_101_7: Bits = (Bits::new(
            ((s_101_6) >> (s_101_3)).value(),
            u16::try_from(s_101_4).unwrap(),
        ));
        // D s_101_8: cast reint s_101_7 -> u8
        let s_101_8: u8 = (s_101_7.value() as u8);
        // C s_101_9: const #22s : i
        let s_101_9: i128 = 22;
        // C s_101_10: const #1s : i
        let s_101_10: i128 = 1;
        // D s_101_11: read-var u#34051:u32
        let s_101_11: u32 = fn_state.u_34051;
        // D s_101_12: cast zx s_101_11 -> bv
        let s_101_12: Bits = Bits::new(s_101_11 as u128, 32u16);
        // D s_101_13: bit-extract s_101_12 s_101_9 s_101_10
        let s_101_13: Bits = (Bits::new(
            ((s_101_12) >> (s_101_9)).value(),
            u16::try_from(s_101_10).unwrap(),
        ));
        // D s_101_14: cast reint s_101_13 -> u8
        let s_101_14: bool = ((s_101_13.value()) != 0);
        // C s_101_15: const #16s : i
        let s_101_15: i128 = 16;
        // C s_101_16: const #3s : i
        let s_101_16: i128 = 3;
        // D s_101_17: read-var u#34051:u32
        let s_101_17: u32 = fn_state.u_34051;
        // D s_101_18: cast zx s_101_17 -> bv
        let s_101_18: Bits = Bits::new(s_101_17 as u128, 32u16);
        // D s_101_19: bit-extract s_101_18 s_101_15 s_101_16
        let s_101_19: Bits = (Bits::new(
            ((s_101_18) >> (s_101_15)).value(),
            u16::try_from(s_101_16).unwrap(),
        ));
        // D s_101_20: cast reint s_101_19 -> u8
        let s_101_20: u8 = (s_101_19.value() as u8);
        // C s_101_21: const #12s : i
        let s_101_21: i128 = 12;
        // C s_101_22: const #4s : i
        let s_101_22: i128 = 4;
        // D s_101_23: read-var u#34051:u32
        let s_101_23: u32 = fn_state.u_34051;
        // D s_101_24: cast zx s_101_23 -> bv
        let s_101_24: Bits = Bits::new(s_101_23 as u128, 32u16);
        // D s_101_25: bit-extract s_101_24 s_101_21 s_101_22
        let s_101_25: Bits = (Bits::new(
            ((s_101_24) >> (s_101_21)).value(),
            u16::try_from(s_101_22).unwrap(),
        ));
        // D s_101_26: cast reint s_101_25 -> u8
        let s_101_26: u8 = (s_101_25.value() as u8);
        // C s_101_27: const #8s : i
        let s_101_27: i128 = 8;
        // C s_101_28: const #2s : i
        let s_101_28: i128 = 2;
        // D s_101_29: read-var u#34051:u32
        let s_101_29: u32 = fn_state.u_34051;
        // D s_101_30: cast zx s_101_29 -> bv
        let s_101_30: Bits = Bits::new(s_101_29 as u128, 32u16);
        // D s_101_31: bit-extract s_101_30 s_101_27 s_101_28
        let s_101_31: Bits = (Bits::new(
            ((s_101_30) >> (s_101_27)).value(),
            u16::try_from(s_101_28).unwrap(),
        ));
        // D s_101_32: cast reint s_101_31 -> u8
        let s_101_32: u8 = (s_101_31.value() as u8);
        // C s_101_33: const #7s : i
        let s_101_33: i128 = 7;
        // C s_101_34: const #1s : i
        let s_101_34: i128 = 1;
        // D s_101_35: read-var u#34051:u32
        let s_101_35: u32 = fn_state.u_34051;
        // D s_101_36: cast zx s_101_35 -> bv
        let s_101_36: Bits = Bits::new(s_101_35 as u128, 32u16);
        // D s_101_37: bit-extract s_101_36 s_101_33 s_101_34
        let s_101_37: Bits = (Bits::new(
            ((s_101_36) >> (s_101_33)).value(),
            u16::try_from(s_101_34).unwrap(),
        ));
        // D s_101_38: cast reint s_101_37 -> u8
        let s_101_38: bool = ((s_101_37.value()) != 0);
        // C s_101_39: const #5s : i
        let s_101_39: i128 = 5;
        // C s_101_40: const #1s : i
        let s_101_40: i128 = 1;
        // D s_101_41: read-var u#34051:u32
        let s_101_41: u32 = fn_state.u_34051;
        // D s_101_42: cast zx s_101_41 -> bv
        let s_101_42: Bits = Bits::new(s_101_41 as u128, 32u16);
        // D s_101_43: bit-extract s_101_42 s_101_39 s_101_40
        let s_101_43: Bits = (Bits::new(
            ((s_101_42) >> (s_101_39)).value(),
            u16::try_from(s_101_40).unwrap(),
        ));
        // D s_101_44: cast reint s_101_43 -> u8
        let s_101_44: bool = ((s_101_43.value()) != 0);
        // C s_101_45: const #0s : i
        let s_101_45: i128 = 0;
        // C s_101_46: const #4s : i
        let s_101_46: i128 = 4;
        // D s_101_47: read-var u#34051:u32
        let s_101_47: u32 = fn_state.u_34051;
        // D s_101_48: cast zx s_101_47 -> bv
        let s_101_48: Bits = Bits::new(s_101_47 as u128, 32u16);
        // D s_101_49: bit-extract s_101_48 s_101_45 s_101_46
        let s_101_49: Bits = (Bits::new(
            ((s_101_48) >> (s_101_45)).value(),
            u16::try_from(s_101_46).unwrap(),
        ));
        // D s_101_50: cast reint s_101_49 -> u8
        let s_101_50: u8 = (s_101_49.value() as u8);
        // D s_101_51: call decode_aarch32_instrs_VCVT_iv_A1enc_A_txt(s_101_8, s_101_14, s_101_20, s_101_26, s_101_32, s_101_38, s_101_44, s_101_50)
        let s_101_51: () = decode_aarch32_instrs_VCVT_iv_A1enc_A_txt(
            state,
            tracer,
            s_101_8,
            s_101_14,
            s_101_20,
            s_101_26,
            s_101_32,
            s_101_38,
            s_101_44,
            s_101_50,
        );
        // N s_101_52: return
        return;
    }
    fn block_102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_102_0: read-var merge#var.1:struct
        let s_102_0: u32 = fn_state.merge_var._1;
        // D s_102_1: write-var u#34061 <= s_102_0
        fn_state.u_34061 = s_102_0;
        // C s_102_2: const #23s : i
        let s_102_2: i128 = 23;
        // D s_102_3: read-var u#34061:u32
        let s_102_3: u32 = fn_state.u_34061;
        // D s_102_4: cast zx s_102_3 -> bv
        let s_102_4: Bits = Bits::new(s_102_3 as u128, 32u16);
        // C s_102_5: const #1s : i64
        let s_102_5: i64 = 1;
        // C s_102_6: cast zx s_102_5 -> i
        let s_102_6: i128 = (i128::try_from(s_102_5).unwrap());
        // C s_102_7: const #4s : i
        let s_102_7: i128 = 4;
        // C s_102_8: add s_102_7 s_102_6
        let s_102_8: i128 = (s_102_7 + s_102_6);
        // D s_102_9: bit-extract s_102_4 s_102_2 s_102_8
        let s_102_9: Bits = (Bits::new(
            ((s_102_4) >> (s_102_2)).value(),
            u16::try_from(s_102_8).unwrap(),
        ));
        // D s_102_10: cast reint s_102_9 -> u8
        let s_102_10: u8 = (s_102_9.value() as u8);
        // D s_102_11: cast zx s_102_10 -> bv
        let s_102_11: Bits = Bits::new(s_102_10 as u128, 5u16);
        // C s_102_12: const #29u : u8
        let s_102_12: u8 = 29;
        // C s_102_13: cast zx s_102_12 -> bv
        let s_102_13: Bits = Bits::new(s_102_12 as u128, 5u16);
        // D s_102_14: cmp-eq s_102_11 s_102_13
        let s_102_14: bool = ((s_102_11) == (s_102_13));
        // N s_102_15: branch s_102_14 b1045 b103
        if s_102_14 {
            return block_1045(state, tracer, fn_state);
        } else {
            return block_103(state, tracer, fn_state);
        };
    }
    fn block_103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_103_0: const #0u : u8
        let s_103_0: bool = false;
        // D s_103_1: write-var gs#412265 <= s_103_0
        fn_state.gs_412265 = s_103_0;
        // N s_103_2: jump b104
        return block_104(state, tracer, fn_state);
    }
    fn block_104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_104_0: read-var gs#412265:u8
        let s_104_0: bool = fn_state.gs_412265;
        // N s_104_1: branch s_104_0 b1041 b105
        if s_104_0 {
            return block_1041(state, tracer, fn_state);
        } else {
            return block_105(state, tracer, fn_state);
        };
    }
    fn block_105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_105_0: const #0u : u8
        let s_105_0: bool = false;
        // D s_105_1: write-var gs#412270 <= s_105_0
        fn_state.gs_412270 = s_105_0;
        // N s_105_2: jump b106
        return block_106(state, tracer, fn_state);
    }
    fn block_106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_106_0: read-var gs#412270:u8
        let s_106_0: bool = fn_state.gs_412270;
        // D s_106_1: not s_106_0
        let s_106_1: bool = !s_106_0;
        // N s_106_2: branch s_106_1 b108 b107
        if s_106_1 {
            return block_108(state, tracer, fn_state);
        } else {
            return block_107(state, tracer, fn_state);
        };
    }
    fn block_107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_107_0: const #3430s : i
        let s_107_0: i128 = 3430;
        // C s_107_1: const #14696u : u32
        let s_107_1: u32 = 14696;
        // N s_107_2: write-reg s_107_1 <= s_107_0
        let s_107_2: () = {
            state.write_register::<i128>(s_107_1 as isize, s_107_0);
            tracer.write_register(s_107_1 as isize, s_107_0);
        };
        // C s_107_3: const #28s : i
        let s_107_3: i128 = 28;
        // C s_107_4: const #4s : i
        let s_107_4: i128 = 4;
        // D s_107_5: read-var u#34061:u32
        let s_107_5: u32 = fn_state.u_34061;
        // D s_107_6: cast zx s_107_5 -> bv
        let s_107_6: Bits = Bits::new(s_107_5 as u128, 32u16);
        // D s_107_7: bit-extract s_107_6 s_107_3 s_107_4
        let s_107_7: Bits = (Bits::new(
            ((s_107_6) >> (s_107_3)).value(),
            u16::try_from(s_107_4).unwrap(),
        ));
        // D s_107_8: cast reint s_107_7 -> u8
        let s_107_8: u8 = (s_107_7.value() as u8);
        // C s_107_9: const #22s : i
        let s_107_9: i128 = 22;
        // C s_107_10: const #1s : i
        let s_107_10: i128 = 1;
        // D s_107_11: read-var u#34061:u32
        let s_107_11: u32 = fn_state.u_34061;
        // D s_107_12: cast zx s_107_11 -> bv
        let s_107_12: Bits = Bits::new(s_107_11 as u128, 32u16);
        // D s_107_13: bit-extract s_107_12 s_107_9 s_107_10
        let s_107_13: Bits = (Bits::new(
            ((s_107_12) >> (s_107_9)).value(),
            u16::try_from(s_107_10).unwrap(),
        ));
        // D s_107_14: cast reint s_107_13 -> u8
        let s_107_14: bool = ((s_107_13.value()) != 0);
        // C s_107_15: const #18s : i
        let s_107_15: i128 = 18;
        // C s_107_16: const #1s : i
        let s_107_16: i128 = 1;
        // D s_107_17: read-var u#34061:u32
        let s_107_17: u32 = fn_state.u_34061;
        // D s_107_18: cast zx s_107_17 -> bv
        let s_107_18: Bits = Bits::new(s_107_17 as u128, 32u16);
        // D s_107_19: bit-extract s_107_18 s_107_15 s_107_16
        let s_107_19: Bits = (Bits::new(
            ((s_107_18) >> (s_107_15)).value(),
            u16::try_from(s_107_16).unwrap(),
        ));
        // D s_107_20: cast reint s_107_19 -> u8
        let s_107_20: bool = ((s_107_19.value()) != 0);
        // C s_107_21: const #16s : i
        let s_107_21: i128 = 16;
        // C s_107_22: const #1s : i
        let s_107_22: i128 = 1;
        // D s_107_23: read-var u#34061:u32
        let s_107_23: u32 = fn_state.u_34061;
        // D s_107_24: cast zx s_107_23 -> bv
        let s_107_24: Bits = Bits::new(s_107_23 as u128, 32u16);
        // D s_107_25: bit-extract s_107_24 s_107_21 s_107_22
        let s_107_25: Bits = (Bits::new(
            ((s_107_24) >> (s_107_21)).value(),
            u16::try_from(s_107_22).unwrap(),
        ));
        // D s_107_26: cast reint s_107_25 -> u8
        let s_107_26: bool = ((s_107_25.value()) != 0);
        // C s_107_27: const #12s : i
        let s_107_27: i128 = 12;
        // C s_107_28: const #4s : i
        let s_107_28: i128 = 4;
        // D s_107_29: read-var u#34061:u32
        let s_107_29: u32 = fn_state.u_34061;
        // D s_107_30: cast zx s_107_29 -> bv
        let s_107_30: Bits = Bits::new(s_107_29 as u128, 32u16);
        // D s_107_31: bit-extract s_107_30 s_107_27 s_107_28
        let s_107_31: Bits = (Bits::new(
            ((s_107_30) >> (s_107_27)).value(),
            u16::try_from(s_107_28).unwrap(),
        ));
        // D s_107_32: cast reint s_107_31 -> u8
        let s_107_32: u8 = (s_107_31.value() as u8);
        // C s_107_33: const #8s : i
        let s_107_33: i128 = 8;
        // C s_107_34: const #2s : i
        let s_107_34: i128 = 2;
        // D s_107_35: read-var u#34061:u32
        let s_107_35: u32 = fn_state.u_34061;
        // D s_107_36: cast zx s_107_35 -> bv
        let s_107_36: Bits = Bits::new(s_107_35 as u128, 32u16);
        // D s_107_37: bit-extract s_107_36 s_107_33 s_107_34
        let s_107_37: Bits = (Bits::new(
            ((s_107_36) >> (s_107_33)).value(),
            u16::try_from(s_107_34).unwrap(),
        ));
        // D s_107_38: cast reint s_107_37 -> u8
        let s_107_38: u8 = (s_107_37.value() as u8);
        // C s_107_39: const #7s : i
        let s_107_39: i128 = 7;
        // C s_107_40: const #1s : i
        let s_107_40: i128 = 1;
        // D s_107_41: read-var u#34061:u32
        let s_107_41: u32 = fn_state.u_34061;
        // D s_107_42: cast zx s_107_41 -> bv
        let s_107_42: Bits = Bits::new(s_107_41 as u128, 32u16);
        // D s_107_43: bit-extract s_107_42 s_107_39 s_107_40
        let s_107_43: Bits = (Bits::new(
            ((s_107_42) >> (s_107_39)).value(),
            u16::try_from(s_107_40).unwrap(),
        ));
        // D s_107_44: cast reint s_107_43 -> u8
        let s_107_44: bool = ((s_107_43.value()) != 0);
        // C s_107_45: const #5s : i
        let s_107_45: i128 = 5;
        // C s_107_46: const #1s : i
        let s_107_46: i128 = 1;
        // D s_107_47: read-var u#34061:u32
        let s_107_47: u32 = fn_state.u_34061;
        // D s_107_48: cast zx s_107_47 -> bv
        let s_107_48: Bits = Bits::new(s_107_47 as u128, 32u16);
        // D s_107_49: bit-extract s_107_48 s_107_45 s_107_46
        let s_107_49: Bits = (Bits::new(
            ((s_107_48) >> (s_107_45)).value(),
            u16::try_from(s_107_46).unwrap(),
        ));
        // D s_107_50: cast reint s_107_49 -> u8
        let s_107_50: bool = ((s_107_49.value()) != 0);
        // C s_107_51: const #0s : i
        let s_107_51: i128 = 0;
        // C s_107_52: const #4s : i
        let s_107_52: i128 = 4;
        // D s_107_53: read-var u#34061:u32
        let s_107_53: u32 = fn_state.u_34061;
        // D s_107_54: cast zx s_107_53 -> bv
        let s_107_54: Bits = Bits::new(s_107_53 as u128, 32u16);
        // D s_107_55: bit-extract s_107_54 s_107_51 s_107_52
        let s_107_55: Bits = (Bits::new(
            ((s_107_54) >> (s_107_51)).value(),
            u16::try_from(s_107_52).unwrap(),
        ));
        // D s_107_56: cast reint s_107_55 -> u8
        let s_107_56: u8 = (s_107_55.value() as u8);
        // D s_107_57: call decode_aarch32_instrs_VCVT_xv_A1enc_A_txt(s_107_8, s_107_14, s_107_20, s_107_26, s_107_32, s_107_38, s_107_44, s_107_50, s_107_56)
        let s_107_57: () = decode_aarch32_instrs_VCVT_xv_A1enc_A_txt(
            state,
            tracer,
            s_107_8,
            s_107_14,
            s_107_20,
            s_107_26,
            s_107_32,
            s_107_38,
            s_107_44,
            s_107_50,
            s_107_56,
        );
        // N s_107_58: return
        return;
    }
    fn block_108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_108_0: read-var merge#var.1:struct
        let s_108_0: u32 = fn_state.merge_var._1;
        // D s_108_1: write-var u#34068 <= s_108_0
        fn_state.u_34068 = s_108_0;
        // C s_108_2: const #23s : i
        let s_108_2: i128 = 23;
        // D s_108_3: read-var u#34068:u32
        let s_108_3: u32 = fn_state.u_34068;
        // D s_108_4: cast zx s_108_3 -> bv
        let s_108_4: Bits = Bits::new(s_108_3 as u128, 32u16);
        // C s_108_5: const #1s : i64
        let s_108_5: i64 = 1;
        // C s_108_6: cast zx s_108_5 -> i
        let s_108_6: i128 = (i128::try_from(s_108_5).unwrap());
        // C s_108_7: const #4s : i
        let s_108_7: i128 = 4;
        // C s_108_8: add s_108_7 s_108_6
        let s_108_8: i128 = (s_108_7 + s_108_6);
        // D s_108_9: bit-extract s_108_4 s_108_2 s_108_8
        let s_108_9: Bits = (Bits::new(
            ((s_108_4) >> (s_108_2)).value(),
            u16::try_from(s_108_8).unwrap(),
        ));
        // D s_108_10: cast reint s_108_9 -> u8
        let s_108_10: u8 = (s_108_9.value() as u8);
        // D s_108_11: cast zx s_108_10 -> bv
        let s_108_11: Bits = Bits::new(s_108_10 as u128, 5u16);
        // C s_108_12: const #29u : u8
        let s_108_12: u8 = 29;
        // C s_108_13: cast zx s_108_12 -> bv
        let s_108_13: Bits = Bits::new(s_108_12 as u128, 5u16);
        // D s_108_14: cmp-eq s_108_11 s_108_13
        let s_108_14: bool = ((s_108_11) == (s_108_13));
        // N s_108_15: branch s_108_14 b1031 b109
        if s_108_14 {
            return block_1031(state, tracer, fn_state);
        } else {
            return block_109(state, tracer, fn_state);
        };
    }
    fn block_109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_109_0: const #0u : u8
        let s_109_0: bool = false;
        // D s_109_1: write-var gs#412305 <= s_109_0
        fn_state.gs_412305 = s_109_0;
        // N s_109_2: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_110_0: read-var gs#412305:u8
        let s_110_0: bool = fn_state.gs_412305;
        // N s_110_1: branch s_110_0 b1027 b111
        if s_110_0 {
            return block_1027(state, tracer, fn_state);
        } else {
            return block_111(state, tracer, fn_state);
        };
    }
    fn block_111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_111_0: const #0u : u8
        let s_111_0: bool = false;
        // D s_111_1: write-var gs#412310 <= s_111_0
        fn_state.gs_412310 = s_111_0;
        // N s_111_2: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_112_0: read-var gs#412310:u8
        let s_112_0: bool = fn_state.gs_412310;
        // D s_112_1: not s_112_0
        let s_112_1: bool = !s_112_0;
        // N s_112_2: branch s_112_1 b114 b113
        if s_112_1 {
            return block_114(state, tracer, fn_state);
        } else {
            return block_113(state, tracer, fn_state);
        };
    }
    fn block_113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_113_0: const #3432s : i
        let s_113_0: i128 = 3432;
        // C s_113_1: const #14696u : u32
        let s_113_1: u32 = 14696;
        // N s_113_2: write-reg s_113_1 <= s_113_0
        let s_113_2: () = {
            state.write_register::<i128>(s_113_1 as isize, s_113_0);
            tracer.write_register(s_113_1 as isize, s_113_0);
        };
        // C s_113_3: const #28s : i
        let s_113_3: i128 = 28;
        // C s_113_4: const #4s : i
        let s_113_4: i128 = 4;
        // D s_113_5: read-var u#34068:u32
        let s_113_5: u32 = fn_state.u_34068;
        // D s_113_6: cast zx s_113_5 -> bv
        let s_113_6: Bits = Bits::new(s_113_5 as u128, 32u16);
        // D s_113_7: bit-extract s_113_6 s_113_3 s_113_4
        let s_113_7: Bits = (Bits::new(
            ((s_113_6) >> (s_113_3)).value(),
            u16::try_from(s_113_4).unwrap(),
        ));
        // D s_113_8: cast reint s_113_7 -> u8
        let s_113_8: u8 = (s_113_7.value() as u8);
        // C s_113_9: const #22s : i
        let s_113_9: i128 = 22;
        // C s_113_10: const #1s : i
        let s_113_10: i128 = 1;
        // D s_113_11: read-var u#34068:u32
        let s_113_11: u32 = fn_state.u_34068;
        // D s_113_12: cast zx s_113_11 -> bv
        let s_113_12: Bits = Bits::new(s_113_11 as u128, 32u16);
        // D s_113_13: bit-extract s_113_12 s_113_9 s_113_10
        let s_113_13: Bits = (Bits::new(
            ((s_113_12) >> (s_113_9)).value(),
            u16::try_from(s_113_10).unwrap(),
        ));
        // D s_113_14: cast reint s_113_13 -> u8
        let s_113_14: bool = ((s_113_13.value()) != 0);
        // C s_113_15: const #16s : i
        let s_113_15: i128 = 16;
        // C s_113_16: const #4s : i
        let s_113_16: i128 = 4;
        // D s_113_17: read-var u#34068:u32
        let s_113_17: u32 = fn_state.u_34068;
        // D s_113_18: cast zx s_113_17 -> bv
        let s_113_18: Bits = Bits::new(s_113_17 as u128, 32u16);
        // D s_113_19: bit-extract s_113_18 s_113_15 s_113_16
        let s_113_19: Bits = (Bits::new(
            ((s_113_18) >> (s_113_15)).value(),
            u16::try_from(s_113_16).unwrap(),
        ));
        // D s_113_20: cast reint s_113_19 -> u8
        let s_113_20: u8 = (s_113_19.value() as u8);
        // C s_113_21: const #12s : i
        let s_113_21: i128 = 12;
        // C s_113_22: const #4s : i
        let s_113_22: i128 = 4;
        // D s_113_23: read-var u#34068:u32
        let s_113_23: u32 = fn_state.u_34068;
        // D s_113_24: cast zx s_113_23 -> bv
        let s_113_24: Bits = Bits::new(s_113_23 as u128, 32u16);
        // D s_113_25: bit-extract s_113_24 s_113_21 s_113_22
        let s_113_25: Bits = (Bits::new(
            ((s_113_24) >> (s_113_21)).value(),
            u16::try_from(s_113_22).unwrap(),
        ));
        // D s_113_26: cast reint s_113_25 -> u8
        let s_113_26: u8 = (s_113_25.value() as u8);
        // C s_113_27: const #8s : i
        let s_113_27: i128 = 8;
        // C s_113_28: const #2s : i
        let s_113_28: i128 = 2;
        // D s_113_29: read-var u#34068:u32
        let s_113_29: u32 = fn_state.u_34068;
        // D s_113_30: cast zx s_113_29 -> bv
        let s_113_30: Bits = Bits::new(s_113_29 as u128, 32u16);
        // D s_113_31: bit-extract s_113_30 s_113_27 s_113_28
        let s_113_31: Bits = (Bits::new(
            ((s_113_30) >> (s_113_27)).value(),
            u16::try_from(s_113_28).unwrap(),
        ));
        // D s_113_32: cast reint s_113_31 -> u8
        let s_113_32: u8 = (s_113_31.value() as u8);
        // C s_113_33: const #7s : i
        let s_113_33: i128 = 7;
        // C s_113_34: const #1s : i
        let s_113_34: i128 = 1;
        // D s_113_35: read-var u#34068:u32
        let s_113_35: u32 = fn_state.u_34068;
        // D s_113_36: cast zx s_113_35 -> bv
        let s_113_36: Bits = Bits::new(s_113_35 as u128, 32u16);
        // D s_113_37: bit-extract s_113_36 s_113_33 s_113_34
        let s_113_37: Bits = (Bits::new(
            ((s_113_36) >> (s_113_33)).value(),
            u16::try_from(s_113_34).unwrap(),
        ));
        // D s_113_38: cast reint s_113_37 -> u8
        let s_113_38: bool = ((s_113_37.value()) != 0);
        // C s_113_39: const #5s : i
        let s_113_39: i128 = 5;
        // C s_113_40: const #1s : i
        let s_113_40: i128 = 1;
        // D s_113_41: read-var u#34068:u32
        let s_113_41: u32 = fn_state.u_34068;
        // D s_113_42: cast zx s_113_41 -> bv
        let s_113_42: Bits = Bits::new(s_113_41 as u128, 32u16);
        // D s_113_43: bit-extract s_113_42 s_113_39 s_113_40
        let s_113_43: Bits = (Bits::new(
            ((s_113_42) >> (s_113_39)).value(),
            u16::try_from(s_113_40).unwrap(),
        ));
        // D s_113_44: cast reint s_113_43 -> u8
        let s_113_44: bool = ((s_113_43.value()) != 0);
        // C s_113_45: const #0s : i
        let s_113_45: i128 = 0;
        // C s_113_46: const #4s : i
        let s_113_46: i128 = 4;
        // D s_113_47: read-var u#34068:u32
        let s_113_47: u32 = fn_state.u_34068;
        // D s_113_48: cast zx s_113_47 -> bv
        let s_113_48: Bits = Bits::new(s_113_47 as u128, 32u16);
        // D s_113_49: bit-extract s_113_48 s_113_45 s_113_46
        let s_113_49: Bits = (Bits::new(
            ((s_113_48) >> (s_113_45)).value(),
            u16::try_from(s_113_46).unwrap(),
        ));
        // D s_113_50: cast reint s_113_49 -> u8
        let s_113_50: u8 = (s_113_49.value() as u8);
        // D s_113_51: call decode_aarch32_instrs_VDIV_A1enc_A_txt(s_113_8, s_113_14, s_113_20, s_113_26, s_113_32, s_113_38, s_113_44, s_113_50)
        let s_113_51: () = decode_aarch32_instrs_VDIV_A1enc_A_txt(
            state,
            tracer,
            s_113_8,
            s_113_14,
            s_113_20,
            s_113_26,
            s_113_32,
            s_113_38,
            s_113_44,
            s_113_50,
        );
        // N s_113_52: return
        return;
    }
    fn block_114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_114_0: read-var merge#var.1:struct
        let s_114_0: u32 = fn_state.merge_var._1;
        // D s_114_1: write-var u#34078 <= s_114_0
        fn_state.u_34078 = s_114_0;
        // C s_114_2: const #23s : i
        let s_114_2: i128 = 23;
        // D s_114_3: read-var u#34078:u32
        let s_114_3: u32 = fn_state.u_34078;
        // D s_114_4: cast zx s_114_3 -> bv
        let s_114_4: Bits = Bits::new(s_114_3 as u128, 32u16);
        // C s_114_5: const #1s : i64
        let s_114_5: i64 = 1;
        // C s_114_6: cast zx s_114_5 -> i
        let s_114_6: i128 = (i128::try_from(s_114_5).unwrap());
        // C s_114_7: const #4s : i
        let s_114_7: i128 = 4;
        // C s_114_8: add s_114_7 s_114_6
        let s_114_8: i128 = (s_114_7 + s_114_6);
        // D s_114_9: bit-extract s_114_4 s_114_2 s_114_8
        let s_114_9: Bits = (Bits::new(
            ((s_114_4) >> (s_114_2)).value(),
            u16::try_from(s_114_8).unwrap(),
        ));
        // D s_114_10: cast reint s_114_9 -> u8
        let s_114_10: u8 = (s_114_9.value() as u8);
        // D s_114_11: cast zx s_114_10 -> bv
        let s_114_11: Bits = Bits::new(s_114_10 as u128, 5u16);
        // C s_114_12: const #29u : u8
        let s_114_12: u8 = 29;
        // C s_114_13: cast zx s_114_12 -> bv
        let s_114_13: Bits = Bits::new(s_114_12 as u128, 5u16);
        // D s_114_14: cmp-eq s_114_11 s_114_13
        let s_114_14: bool = ((s_114_11) == (s_114_13));
        // N s_114_15: branch s_114_14 b1017 b115
        if s_114_14 {
            return block_1017(state, tracer, fn_state);
        } else {
            return block_115(state, tracer, fn_state);
        };
    }
    fn block_115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_115_0: const #0u : u8
        let s_115_0: bool = false;
        // D s_115_1: write-var gs#412343 <= s_115_0
        fn_state.gs_412343 = s_115_0;
        // N s_115_2: jump b116
        return block_116(state, tracer, fn_state);
    }
    fn block_116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_116_0: read-var gs#412343:u8
        let s_116_0: bool = fn_state.gs_412343;
        // N s_116_1: branch s_116_0 b1013 b117
        if s_116_0 {
            return block_1013(state, tracer, fn_state);
        } else {
            return block_117(state, tracer, fn_state);
        };
    }
    fn block_117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_117_0: const #0u : u8
        let s_117_0: bool = false;
        // D s_117_1: write-var gs#412348 <= s_117_0
        fn_state.gs_412348 = s_117_0;
        // N s_117_2: jump b118
        return block_118(state, tracer, fn_state);
    }
    fn block_118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_118_0: read-var gs#412348:u8
        let s_118_0: bool = fn_state.gs_412348;
        // D s_118_1: not s_118_0
        let s_118_1: bool = !s_118_0;
        // N s_118_2: branch s_118_1 b131 b119
        if s_118_1 {
            return block_131(state, tracer, fn_state);
        } else {
            return block_119(state, tracer, fn_state);
        };
    }
    fn block_119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_119_0: const #3434s : i
        let s_119_0: i128 = 3434;
        // C s_119_1: const #14696u : u32
        let s_119_1: u32 = 14696;
        // N s_119_2: write-reg s_119_1 <= s_119_0
        let s_119_2: () = {
            state.write_register::<i128>(s_119_1 as isize, s_119_0);
            tracer.write_register(s_119_1 as isize, s_119_0);
        };
        // C s_119_3: const #28s : i
        let s_119_3: i128 = 28;
        // C s_119_4: const #4s : i
        let s_119_4: i128 = 4;
        // D s_119_5: read-var u#34078:u32
        let s_119_5: u32 = fn_state.u_34078;
        // D s_119_6: cast zx s_119_5 -> bv
        let s_119_6: Bits = Bits::new(s_119_5 as u128, 32u16);
        // D s_119_7: bit-extract s_119_6 s_119_3 s_119_4
        let s_119_7: Bits = (Bits::new(
            ((s_119_6) >> (s_119_3)).value(),
            u16::try_from(s_119_4).unwrap(),
        ));
        // D s_119_8: cast reint s_119_7 -> u8
        let s_119_8: u8 = (s_119_7.value() as u8);
        // D s_119_9: write-var u#34079 <= s_119_8
        fn_state.u_34079 = s_119_8;
        // C s_119_10: const #22s : i
        let s_119_10: i128 = 22;
        // C s_119_11: const #1s : i
        let s_119_11: i128 = 1;
        // D s_119_12: read-var u#34078:u32
        let s_119_12: u32 = fn_state.u_34078;
        // D s_119_13: cast zx s_119_12 -> bv
        let s_119_13: Bits = Bits::new(s_119_12 as u128, 32u16);
        // D s_119_14: bit-extract s_119_13 s_119_10 s_119_11
        let s_119_14: Bits = (Bits::new(
            ((s_119_13) >> (s_119_10)).value(),
            u16::try_from(s_119_11).unwrap(),
        ));
        // D s_119_15: cast reint s_119_14 -> u8
        let s_119_15: bool = ((s_119_14.value()) != 0);
        // D s_119_16: write-var B <= s_119_15
        fn_state.B = s_119_15;
        // C s_119_17: const #21s : i
        let s_119_17: i128 = 21;
        // C s_119_18: const #1s : i
        let s_119_18: i128 = 1;
        // D s_119_19: read-var u#34078:u32
        let s_119_19: u32 = fn_state.u_34078;
        // D s_119_20: cast zx s_119_19 -> bv
        let s_119_20: Bits = Bits::new(s_119_19 as u128, 32u16);
        // D s_119_21: bit-extract s_119_20 s_119_17 s_119_18
        let s_119_21: Bits = (Bits::new(
            ((s_119_20) >> (s_119_17)).value(),
            u16::try_from(s_119_18).unwrap(),
        ));
        // D s_119_22: cast reint s_119_21 -> u8
        let s_119_22: bool = ((s_119_21.value()) != 0);
        // D s_119_23: write-var Q <= s_119_22
        fn_state.Q = s_119_22;
        // C s_119_24: const #16s : i
        let s_119_24: i128 = 16;
        // C s_119_25: const #4s : i
        let s_119_25: i128 = 4;
        // D s_119_26: read-var u#34078:u32
        let s_119_26: u32 = fn_state.u_34078;
        // D s_119_27: cast zx s_119_26 -> bv
        let s_119_27: Bits = Bits::new(s_119_26 as u128, 32u16);
        // D s_119_28: bit-extract s_119_27 s_119_24 s_119_25
        let s_119_28: Bits = (Bits::new(
            ((s_119_27) >> (s_119_24)).value(),
            u16::try_from(s_119_25).unwrap(),
        ));
        // D s_119_29: cast reint s_119_28 -> u8
        let s_119_29: u8 = (s_119_28.value() as u8);
        // D s_119_30: write-var u#34080 <= s_119_29
        fn_state.u_34080 = s_119_29;
        // C s_119_31: const #12s : i
        let s_119_31: i128 = 12;
        // C s_119_32: const #4s : i
        let s_119_32: i128 = 4;
        // D s_119_33: read-var u#34078:u32
        let s_119_33: u32 = fn_state.u_34078;
        // D s_119_34: cast zx s_119_33 -> bv
        let s_119_34: Bits = Bits::new(s_119_33 as u128, 32u16);
        // D s_119_35: bit-extract s_119_34 s_119_31 s_119_32
        let s_119_35: Bits = (Bits::new(
            ((s_119_34) >> (s_119_31)).value(),
            u16::try_from(s_119_32).unwrap(),
        ));
        // D s_119_36: cast reint s_119_35 -> u8
        let s_119_36: u8 = (s_119_35.value() as u8);
        // D s_119_37: write-var u#34081 <= s_119_36
        fn_state.u_34081 = s_119_36;
        // C s_119_38: const #7s : i
        let s_119_38: i128 = 7;
        // C s_119_39: const #1s : i
        let s_119_39: i128 = 1;
        // D s_119_40: read-var u#34078:u32
        let s_119_40: u32 = fn_state.u_34078;
        // D s_119_41: cast zx s_119_40 -> bv
        let s_119_41: Bits = Bits::new(s_119_40 as u128, 32u16);
        // D s_119_42: bit-extract s_119_41 s_119_38 s_119_39
        let s_119_42: Bits = (Bits::new(
            ((s_119_41) >> (s_119_38)).value(),
            u16::try_from(s_119_39).unwrap(),
        ));
        // D s_119_43: cast reint s_119_42 -> u8
        let s_119_43: bool = ((s_119_42.value()) != 0);
        // D s_119_44: write-var u#34082 <= s_119_43
        fn_state.u_34082 = s_119_43;
        // C s_119_45: const #5s : i
        let s_119_45: i128 = 5;
        // C s_119_46: const #1s : i
        let s_119_46: i128 = 1;
        // D s_119_47: read-var u#34078:u32
        let s_119_47: u32 = fn_state.u_34078;
        // D s_119_48: cast zx s_119_47 -> bv
        let s_119_48: Bits = Bits::new(s_119_47 as u128, 32u16);
        // D s_119_49: bit-extract s_119_48 s_119_45 s_119_46
        let s_119_49: Bits = (Bits::new(
            ((s_119_48) >> (s_119_45)).value(),
            u16::try_from(s_119_46).unwrap(),
        ));
        // D s_119_50: cast reint s_119_49 -> u8
        let s_119_50: bool = ((s_119_49.value()) != 0);
        // D s_119_51: write-var u#34083 <= s_119_50
        fn_state.u_34083 = s_119_50;
        // C s_119_52: const #0s : i
        let s_119_52: i128 = 0;
        // D s_119_53: read-var u#34078:u32
        let s_119_53: u32 = fn_state.u_34078;
        // D s_119_54: cast zx s_119_53 -> bv
        let s_119_54: Bits = Bits::new(s_119_53 as u128, 32u16);
        // C s_119_55: const #1u : u64
        let s_119_55: u64 = 1;
        // D s_119_56: bit-extract s_119_54 s_119_52 s_119_55
        let s_119_56: Bits = (Bits::new(
            ((s_119_54) >> (s_119_52)).value(),
            u16::try_from(s_119_55).unwrap(),
        ));
        // D s_119_57: cast reint s_119_56 -> u8
        let s_119_57: bool = ((s_119_56.value()) != 0);
        // C s_119_58: const #0s : i
        let s_119_58: i128 = 0;
        // C s_119_59: const #0u : u64
        let s_119_59: u64 = 0;
        // D s_119_60: cast zx s_119_57 -> u64
        let s_119_60: u64 = (s_119_57 as u64);
        // C s_119_61: const #1u : u64
        let s_119_61: u64 = 1;
        // D s_119_62: and s_119_60 s_119_61
        let s_119_62: u64 = ((s_119_60) & (s_119_61));
        // D s_119_63: cmp-eq s_119_62 s_119_61
        let s_119_63: bool = ((s_119_62) == (s_119_61));
        // D s_119_64: lsl s_119_60 s_119_58
        let s_119_64: u64 = s_119_60 << s_119_58;
        // D s_119_65: or s_119_59 s_119_64
        let s_119_65: u64 = ((s_119_59) | (s_119_64));
        // D s_119_66: cmpl s_119_64
        let s_119_66: u64 = !s_119_64;
        // D s_119_67: and s_119_59 s_119_66
        let s_119_67: u64 = ((s_119_59) & (s_119_66));
        // D s_119_68: select s_119_63 s_119_65 s_119_67
        let s_119_68: u64 = if s_119_63 { s_119_65 } else { s_119_67 };
        // D s_119_69: cast trunc s_119_68 -> u8
        let s_119_69: bool = ((s_119_68) != 0);
        // D s_119_70: cast zx s_119_69 -> bv
        let s_119_70: Bits = Bits::new(s_119_69 as u128, 1u16);
        // C s_119_71: const #0u : u8
        let s_119_71: bool = false;
        // C s_119_72: cast zx s_119_71 -> bv
        let s_119_72: Bits = Bits::new(s_119_71 as u128, 1u16);
        // D s_119_73: cmp-ne s_119_70 s_119_72
        let s_119_73: bool = ((s_119_70) != (s_119_72));
        // N s_119_74: branch s_119_73 b130 b120
        if s_119_73 {
            return block_130(state, tracer, fn_state);
        } else {
            return block_120(state, tracer, fn_state);
        };
    }
    fn block_120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_120_0: const #1s : i
        let s_120_0: i128 = 1;
        // D s_120_1: read-var u#34078:u32
        let s_120_1: u32 = fn_state.u_34078;
        // D s_120_2: cast zx s_120_1 -> bv
        let s_120_2: Bits = Bits::new(s_120_1 as u128, 32u16);
        // C s_120_3: const #1u : u64
        let s_120_3: u64 = 1;
        // D s_120_4: bit-extract s_120_2 s_120_0 s_120_3
        let s_120_4: Bits = (Bits::new(
            ((s_120_2) >> (s_120_0)).value(),
            u16::try_from(s_120_3).unwrap(),
        ));
        // D s_120_5: cast reint s_120_4 -> u8
        let s_120_5: bool = ((s_120_4.value()) != 0);
        // C s_120_6: const #0s : i
        let s_120_6: i128 = 0;
        // C s_120_7: const #0u : u64
        let s_120_7: u64 = 0;
        // D s_120_8: cast zx s_120_5 -> u64
        let s_120_8: u64 = (s_120_5 as u64);
        // C s_120_9: const #1u : u64
        let s_120_9: u64 = 1;
        // D s_120_10: and s_120_8 s_120_9
        let s_120_10: u64 = ((s_120_8) & (s_120_9));
        // D s_120_11: cmp-eq s_120_10 s_120_9
        let s_120_11: bool = ((s_120_10) == (s_120_9));
        // D s_120_12: lsl s_120_8 s_120_6
        let s_120_12: u64 = s_120_8 << s_120_6;
        // D s_120_13: or s_120_7 s_120_12
        let s_120_13: u64 = ((s_120_7) | (s_120_12));
        // D s_120_14: cmpl s_120_12
        let s_120_14: u64 = !s_120_12;
        // D s_120_15: and s_120_7 s_120_14
        let s_120_15: u64 = ((s_120_7) & (s_120_14));
        // D s_120_16: select s_120_11 s_120_13 s_120_15
        let s_120_16: u64 = if s_120_11 { s_120_13 } else { s_120_15 };
        // D s_120_17: cast trunc s_120_16 -> u8
        let s_120_17: bool = ((s_120_16) != 0);
        // D s_120_18: cast zx s_120_17 -> bv
        let s_120_18: Bits = Bits::new(s_120_17 as u128, 1u16);
        // C s_120_19: const #0u : u8
        let s_120_19: bool = false;
        // C s_120_20: cast zx s_120_19 -> bv
        let s_120_20: Bits = Bits::new(s_120_19 as u128, 1u16);
        // D s_120_21: cmp-ne s_120_18 s_120_20
        let s_120_21: bool = ((s_120_18) != (s_120_20));
        // D s_120_22: write-var gs#412369 <= s_120_21
        fn_state.gs_412369 = s_120_21;
        // N s_120_23: jump b121
        return block_121(state, tracer, fn_state);
    }
    fn block_121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_121_0: read-var gs#412369:u8
        let s_121_0: bool = fn_state.gs_412369;
        // N s_121_1: branch s_121_0 b129 b122
        if s_121_0 {
            return block_129(state, tracer, fn_state);
        } else {
            return block_122(state, tracer, fn_state);
        };
    }
    fn block_122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_122_0: const #2s : i
        let s_122_0: i128 = 2;
        // D s_122_1: read-var u#34078:u32
        let s_122_1: u32 = fn_state.u_34078;
        // D s_122_2: cast zx s_122_1 -> bv
        let s_122_2: Bits = Bits::new(s_122_1 as u128, 32u16);
        // C s_122_3: const #1u : u64
        let s_122_3: u64 = 1;
        // D s_122_4: bit-extract s_122_2 s_122_0 s_122_3
        let s_122_4: Bits = (Bits::new(
            ((s_122_2) >> (s_122_0)).value(),
            u16::try_from(s_122_3).unwrap(),
        ));
        // D s_122_5: cast reint s_122_4 -> u8
        let s_122_5: bool = ((s_122_4.value()) != 0);
        // C s_122_6: const #0s : i
        let s_122_6: i128 = 0;
        // C s_122_7: const #0u : u64
        let s_122_7: u64 = 0;
        // D s_122_8: cast zx s_122_5 -> u64
        let s_122_8: u64 = (s_122_5 as u64);
        // C s_122_9: const #1u : u64
        let s_122_9: u64 = 1;
        // D s_122_10: and s_122_8 s_122_9
        let s_122_10: u64 = ((s_122_8) & (s_122_9));
        // D s_122_11: cmp-eq s_122_10 s_122_9
        let s_122_11: bool = ((s_122_10) == (s_122_9));
        // D s_122_12: lsl s_122_8 s_122_6
        let s_122_12: u64 = s_122_8 << s_122_6;
        // D s_122_13: or s_122_7 s_122_12
        let s_122_13: u64 = ((s_122_7) | (s_122_12));
        // D s_122_14: cmpl s_122_12
        let s_122_14: u64 = !s_122_12;
        // D s_122_15: and s_122_7 s_122_14
        let s_122_15: u64 = ((s_122_7) & (s_122_14));
        // D s_122_16: select s_122_11 s_122_13 s_122_15
        let s_122_16: u64 = if s_122_11 { s_122_13 } else { s_122_15 };
        // D s_122_17: cast trunc s_122_16 -> u8
        let s_122_17: bool = ((s_122_16) != 0);
        // D s_122_18: cast zx s_122_17 -> bv
        let s_122_18: Bits = Bits::new(s_122_17 as u128, 1u16);
        // C s_122_19: const #0u : u8
        let s_122_19: bool = false;
        // C s_122_20: cast zx s_122_19 -> bv
        let s_122_20: Bits = Bits::new(s_122_19 as u128, 1u16);
        // D s_122_21: cmp-ne s_122_18 s_122_20
        let s_122_21: bool = ((s_122_18) != (s_122_20));
        // D s_122_22: write-var gs#412372 <= s_122_21
        fn_state.gs_412372 = s_122_21;
        // N s_122_23: jump b123
        return block_123(state, tracer, fn_state);
    }
    fn block_123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_123_0: read-var gs#412372:u8
        let s_123_0: bool = fn_state.gs_412372;
        // N s_123_1: branch s_123_0 b128 b124
        if s_123_0 {
            return block_128(state, tracer, fn_state);
        } else {
            return block_124(state, tracer, fn_state);
        };
    }
    fn block_124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_124_0: const #3s : i
        let s_124_0: i128 = 3;
        // D s_124_1: read-var u#34078:u32
        let s_124_1: u32 = fn_state.u_34078;
        // D s_124_2: cast zx s_124_1 -> bv
        let s_124_2: Bits = Bits::new(s_124_1 as u128, 32u16);
        // C s_124_3: const #1u : u64
        let s_124_3: u64 = 1;
        // D s_124_4: bit-extract s_124_2 s_124_0 s_124_3
        let s_124_4: Bits = (Bits::new(
            ((s_124_2) >> (s_124_0)).value(),
            u16::try_from(s_124_3).unwrap(),
        ));
        // D s_124_5: cast reint s_124_4 -> u8
        let s_124_5: bool = ((s_124_4.value()) != 0);
        // C s_124_6: const #0s : i
        let s_124_6: i128 = 0;
        // C s_124_7: const #0u : u64
        let s_124_7: u64 = 0;
        // D s_124_8: cast zx s_124_5 -> u64
        let s_124_8: u64 = (s_124_5 as u64);
        // C s_124_9: const #1u : u64
        let s_124_9: u64 = 1;
        // D s_124_10: and s_124_8 s_124_9
        let s_124_10: u64 = ((s_124_8) & (s_124_9));
        // D s_124_11: cmp-eq s_124_10 s_124_9
        let s_124_11: bool = ((s_124_10) == (s_124_9));
        // D s_124_12: lsl s_124_8 s_124_6
        let s_124_12: u64 = s_124_8 << s_124_6;
        // D s_124_13: or s_124_7 s_124_12
        let s_124_13: u64 = ((s_124_7) | (s_124_12));
        // D s_124_14: cmpl s_124_12
        let s_124_14: u64 = !s_124_12;
        // D s_124_15: and s_124_7 s_124_14
        let s_124_15: u64 = ((s_124_7) & (s_124_14));
        // D s_124_16: select s_124_11 s_124_13 s_124_15
        let s_124_16: u64 = if s_124_11 { s_124_13 } else { s_124_15 };
        // D s_124_17: cast trunc s_124_16 -> u8
        let s_124_17: bool = ((s_124_16) != 0);
        // D s_124_18: cast zx s_124_17 -> bv
        let s_124_18: Bits = Bits::new(s_124_17 as u128, 1u16);
        // C s_124_19: const #0u : u8
        let s_124_19: bool = false;
        // C s_124_20: cast zx s_124_19 -> bv
        let s_124_20: Bits = Bits::new(s_124_19 as u128, 1u16);
        // D s_124_21: cmp-ne s_124_18 s_124_20
        let s_124_21: bool = ((s_124_18) != (s_124_20));
        // D s_124_22: write-var gs#412375 <= s_124_21
        fn_state.gs_412375 = s_124_21;
        // N s_124_23: jump b125
        return block_125(state, tracer, fn_state);
    }
    fn block_125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_125_0: read-var gs#412375:u8
        let s_125_0: bool = fn_state.gs_412375;
        // N s_125_1: branch s_125_0 b127 b126
        if s_125_0 {
            return block_127(state, tracer, fn_state);
        } else {
            return block_126(state, tracer, fn_state);
        };
    }
    fn block_126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_126_0: read-var u#34079:u8
        let s_126_0: u8 = fn_state.u_34079;
        // D s_126_1: read-var B:u8
        let s_126_1: bool = fn_state.B;
        // D s_126_2: read-var Q:u8
        let s_126_2: bool = fn_state.Q;
        // D s_126_3: read-var u#34080:u8
        let s_126_3: u8 = fn_state.u_34080;
        // D s_126_4: read-var u#34081:u8
        let s_126_4: u8 = fn_state.u_34081;
        // D s_126_5: read-var u#34082:u8
        let s_126_5: bool = fn_state.u_34082;
        // D s_126_6: read-var u#34083:u8
        let s_126_6: bool = fn_state.u_34083;
        // D s_126_7: call decode_aarch32_instrs_VDUP_r_A1enc_A_txt(s_126_0, s_126_1, s_126_2, s_126_3, s_126_4, s_126_5, s_126_6)
        let s_126_7: () = decode_aarch32_instrs_VDUP_r_A1enc_A_txt(
            state,
            tracer,
            s_126_0,
            s_126_1,
            s_126_2,
            s_126_3,
            s_126_4,
            s_126_5,
            s_126_6,
        );
        // N s_126_8: return
        return;
    }
    fn block_127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_127_0: panic
        panic!("{:?}", ());
        // N s_127_1: return
        return;
    }
    fn block_128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_128_0: const #1u : u8
        let s_128_0: bool = true;
        // D s_128_1: write-var gs#412375 <= s_128_0
        fn_state.gs_412375 = s_128_0;
        // N s_128_2: jump b125
        return block_125(state, tracer, fn_state);
    }
    fn block_129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_129_0: const #1u : u8
        let s_129_0: bool = true;
        // D s_129_1: write-var gs#412372 <= s_129_0
        fn_state.gs_412372 = s_129_0;
        // N s_129_2: jump b123
        return block_123(state, tracer, fn_state);
    }
    fn block_130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_130_0: const #1u : u8
        let s_130_0: bool = true;
        // D s_130_1: write-var gs#412369 <= s_130_0
        fn_state.gs_412369 = s_130_0;
        // N s_130_2: jump b121
        return block_121(state, tracer, fn_state);
    }
    fn block_131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_131_0: read-var merge#var.1:struct
        let s_131_0: u32 = fn_state.merge_var._1;
        // D s_131_1: write-var u#34085 <= s_131_0
        fn_state.u_34085 = s_131_0;
        // C s_131_2: const #23s : i
        let s_131_2: i128 = 23;
        // D s_131_3: read-var u#34085:u32
        let s_131_3: u32 = fn_state.u_34085;
        // D s_131_4: cast zx s_131_3 -> bv
        let s_131_4: Bits = Bits::new(s_131_3 as u128, 32u16);
        // C s_131_5: const #1s : i64
        let s_131_5: i64 = 1;
        // C s_131_6: cast zx s_131_5 -> i
        let s_131_6: i128 = (i128::try_from(s_131_5).unwrap());
        // C s_131_7: const #4s : i
        let s_131_7: i128 = 4;
        // C s_131_8: add s_131_7 s_131_6
        let s_131_8: i128 = (s_131_7 + s_131_6);
        // D s_131_9: bit-extract s_131_4 s_131_2 s_131_8
        let s_131_9: Bits = (Bits::new(
            ((s_131_4) >> (s_131_2)).value(),
            u16::try_from(s_131_8).unwrap(),
        ));
        // D s_131_10: cast reint s_131_9 -> u8
        let s_131_10: u8 = (s_131_9.value() as u8);
        // D s_131_11: cast zx s_131_10 -> bv
        let s_131_11: Bits = Bits::new(s_131_10 as u128, 5u16);
        // C s_131_12: const #29u : u8
        let s_131_12: u8 = 29;
        // C s_131_13: cast zx s_131_12 -> bv
        let s_131_13: Bits = Bits::new(s_131_12 as u128, 5u16);
        // D s_131_14: cmp-eq s_131_11 s_131_13
        let s_131_14: bool = ((s_131_11) == (s_131_13));
        // N s_131_15: branch s_131_14 b1006 b132
        if s_131_14 {
            return block_1006(state, tracer, fn_state);
        } else {
            return block_132(state, tracer, fn_state);
        };
    }
    fn block_132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_132_0: const #0u : u8
        let s_132_0: bool = false;
        // D s_132_1: write-var gs#412387 <= s_132_0
        fn_state.gs_412387 = s_132_0;
        // N s_132_2: jump b133
        return block_133(state, tracer, fn_state);
    }
    fn block_133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_133_0: read-var gs#412387:u8
        let s_133_0: bool = fn_state.gs_412387;
        // N s_133_1: branch s_133_0 b1002 b134
        if s_133_0 {
            return block_1002(state, tracer, fn_state);
        } else {
            return block_134(state, tracer, fn_state);
        };
    }
    fn block_134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_134_0: const #0u : u8
        let s_134_0: bool = false;
        // D s_134_1: write-var gs#412392 <= s_134_0
        fn_state.gs_412392 = s_134_0;
        // N s_134_2: jump b135
        return block_135(state, tracer, fn_state);
    }
    fn block_135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_135_0: read-var gs#412392:u8
        let s_135_0: bool = fn_state.gs_412392;
        // D s_135_1: not s_135_0
        let s_135_1: bool = !s_135_0;
        // N s_135_2: branch s_135_1 b137 b136
        if s_135_1 {
            return block_137(state, tracer, fn_state);
        } else {
            return block_136(state, tracer, fn_state);
        };
    }
    fn block_136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_136_0: const #3443s : i
        let s_136_0: i128 = 3443;
        // C s_136_1: const #14696u : u32
        let s_136_1: u32 = 14696;
        // N s_136_2: write-reg s_136_1 <= s_136_0
        let s_136_2: () = {
            state.write_register::<i128>(s_136_1 as isize, s_136_0);
            tracer.write_register(s_136_1 as isize, s_136_0);
        };
        // C s_136_3: const #28s : i
        let s_136_3: i128 = 28;
        // C s_136_4: const #4s : i
        let s_136_4: i128 = 4;
        // D s_136_5: read-var u#34085:u32
        let s_136_5: u32 = fn_state.u_34085;
        // D s_136_6: cast zx s_136_5 -> bv
        let s_136_6: Bits = Bits::new(s_136_5 as u128, 32u16);
        // D s_136_7: bit-extract s_136_6 s_136_3 s_136_4
        let s_136_7: Bits = (Bits::new(
            ((s_136_6) >> (s_136_3)).value(),
            u16::try_from(s_136_4).unwrap(),
        ));
        // D s_136_8: cast reint s_136_7 -> u8
        let s_136_8: u8 = (s_136_7.value() as u8);
        // C s_136_9: const #22s : i
        let s_136_9: i128 = 22;
        // C s_136_10: const #1s : i
        let s_136_10: i128 = 1;
        // D s_136_11: read-var u#34085:u32
        let s_136_11: u32 = fn_state.u_34085;
        // D s_136_12: cast zx s_136_11 -> bv
        let s_136_12: Bits = Bits::new(s_136_11 as u128, 32u16);
        // D s_136_13: bit-extract s_136_12 s_136_9 s_136_10
        let s_136_13: Bits = (Bits::new(
            ((s_136_12) >> (s_136_9)).value(),
            u16::try_from(s_136_10).unwrap(),
        ));
        // D s_136_14: cast reint s_136_13 -> u8
        let s_136_14: bool = ((s_136_13.value()) != 0);
        // C s_136_15: const #16s : i
        let s_136_15: i128 = 16;
        // C s_136_16: const #4s : i
        let s_136_16: i128 = 4;
        // D s_136_17: read-var u#34085:u32
        let s_136_17: u32 = fn_state.u_34085;
        // D s_136_18: cast zx s_136_17 -> bv
        let s_136_18: Bits = Bits::new(s_136_17 as u128, 32u16);
        // D s_136_19: bit-extract s_136_18 s_136_15 s_136_16
        let s_136_19: Bits = (Bits::new(
            ((s_136_18) >> (s_136_15)).value(),
            u16::try_from(s_136_16).unwrap(),
        ));
        // D s_136_20: cast reint s_136_19 -> u8
        let s_136_20: u8 = (s_136_19.value() as u8);
        // C s_136_21: const #12s : i
        let s_136_21: i128 = 12;
        // C s_136_22: const #4s : i
        let s_136_22: i128 = 4;
        // D s_136_23: read-var u#34085:u32
        let s_136_23: u32 = fn_state.u_34085;
        // D s_136_24: cast zx s_136_23 -> bv
        let s_136_24: Bits = Bits::new(s_136_23 as u128, 32u16);
        // D s_136_25: bit-extract s_136_24 s_136_21 s_136_22
        let s_136_25: Bits = (Bits::new(
            ((s_136_24) >> (s_136_21)).value(),
            u16::try_from(s_136_22).unwrap(),
        ));
        // D s_136_26: cast reint s_136_25 -> u8
        let s_136_26: u8 = (s_136_25.value() as u8);
        // C s_136_27: const #8s : i
        let s_136_27: i128 = 8;
        // C s_136_28: const #2s : i
        let s_136_28: i128 = 2;
        // D s_136_29: read-var u#34085:u32
        let s_136_29: u32 = fn_state.u_34085;
        // D s_136_30: cast zx s_136_29 -> bv
        let s_136_30: Bits = Bits::new(s_136_29 as u128, 32u16);
        // D s_136_31: bit-extract s_136_30 s_136_27 s_136_28
        let s_136_31: Bits = (Bits::new(
            ((s_136_30) >> (s_136_27)).value(),
            u16::try_from(s_136_28).unwrap(),
        ));
        // D s_136_32: cast reint s_136_31 -> u8
        let s_136_32: u8 = (s_136_31.value() as u8);
        // C s_136_33: const #7s : i
        let s_136_33: i128 = 7;
        // C s_136_34: const #1s : i
        let s_136_34: i128 = 1;
        // D s_136_35: read-var u#34085:u32
        let s_136_35: u32 = fn_state.u_34085;
        // D s_136_36: cast zx s_136_35 -> bv
        let s_136_36: Bits = Bits::new(s_136_35 as u128, 32u16);
        // D s_136_37: bit-extract s_136_36 s_136_33 s_136_34
        let s_136_37: Bits = (Bits::new(
            ((s_136_36) >> (s_136_33)).value(),
            u16::try_from(s_136_34).unwrap(),
        ));
        // D s_136_38: cast reint s_136_37 -> u8
        let s_136_38: bool = ((s_136_37.value()) != 0);
        // C s_136_39: const #6s : i
        let s_136_39: i128 = 6;
        // C s_136_40: const #1s : i
        let s_136_40: i128 = 1;
        // D s_136_41: read-var u#34085:u32
        let s_136_41: u32 = fn_state.u_34085;
        // D s_136_42: cast zx s_136_41 -> bv
        let s_136_42: Bits = Bits::new(s_136_41 as u128, 32u16);
        // D s_136_43: bit-extract s_136_42 s_136_39 s_136_40
        let s_136_43: Bits = (Bits::new(
            ((s_136_42) >> (s_136_39)).value(),
            u16::try_from(s_136_40).unwrap(),
        ));
        // D s_136_44: cast reint s_136_43 -> u8
        let s_136_44: bool = ((s_136_43.value()) != 0);
        // C s_136_45: const #5s : i
        let s_136_45: i128 = 5;
        // C s_136_46: const #1s : i
        let s_136_46: i128 = 1;
        // D s_136_47: read-var u#34085:u32
        let s_136_47: u32 = fn_state.u_34085;
        // D s_136_48: cast zx s_136_47 -> bv
        let s_136_48: Bits = Bits::new(s_136_47 as u128, 32u16);
        // D s_136_49: bit-extract s_136_48 s_136_45 s_136_46
        let s_136_49: Bits = (Bits::new(
            ((s_136_48) >> (s_136_45)).value(),
            u16::try_from(s_136_46).unwrap(),
        ));
        // D s_136_50: cast reint s_136_49 -> u8
        let s_136_50: bool = ((s_136_49.value()) != 0);
        // C s_136_51: const #0s : i
        let s_136_51: i128 = 0;
        // C s_136_52: const #4s : i
        let s_136_52: i128 = 4;
        // D s_136_53: read-var u#34085:u32
        let s_136_53: u32 = fn_state.u_34085;
        // D s_136_54: cast zx s_136_53 -> bv
        let s_136_54: Bits = Bits::new(s_136_53 as u128, 32u16);
        // D s_136_55: bit-extract s_136_54 s_136_51 s_136_52
        let s_136_55: Bits = (Bits::new(
            ((s_136_54) >> (s_136_51)).value(),
            u16::try_from(s_136_52).unwrap(),
        ));
        // D s_136_56: cast reint s_136_55 -> u8
        let s_136_56: u8 = (s_136_55.value() as u8);
        // D s_136_57: call decode_aarch32_instrs_VFMA_A2enc_A_txt(s_136_8, s_136_14, s_136_20, s_136_26, s_136_32, s_136_38, s_136_44, s_136_50, s_136_56)
        let s_136_57: () = decode_aarch32_instrs_VFMA_A2enc_A_txt(
            state,
            tracer,
            s_136_8,
            s_136_14,
            s_136_20,
            s_136_26,
            s_136_32,
            s_136_38,
            s_136_44,
            s_136_50,
            s_136_56,
        );
        // N s_136_58: return
        return;
    }
    fn block_137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_137_0: read-var merge#var.1:struct
        let s_137_0: u32 = fn_state.merge_var._1;
        // D s_137_1: write-var u#34096 <= s_137_0
        fn_state.u_34096 = s_137_0;
        // C s_137_2: const #23s : i
        let s_137_2: i128 = 23;
        // D s_137_3: read-var u#34096:u32
        let s_137_3: u32 = fn_state.u_34096;
        // D s_137_4: cast zx s_137_3 -> bv
        let s_137_4: Bits = Bits::new(s_137_3 as u128, 32u16);
        // C s_137_5: const #1s : i64
        let s_137_5: i64 = 1;
        // C s_137_6: cast zx s_137_5 -> i
        let s_137_6: i128 = (i128::try_from(s_137_5).unwrap());
        // C s_137_7: const #4s : i
        let s_137_7: i128 = 4;
        // C s_137_8: add s_137_7 s_137_6
        let s_137_8: i128 = (s_137_7 + s_137_6);
        // D s_137_9: bit-extract s_137_4 s_137_2 s_137_8
        let s_137_9: Bits = (Bits::new(
            ((s_137_4) >> (s_137_2)).value(),
            u16::try_from(s_137_8).unwrap(),
        ));
        // D s_137_10: cast reint s_137_9 -> u8
        let s_137_10: u8 = (s_137_9.value() as u8);
        // D s_137_11: cast zx s_137_10 -> bv
        let s_137_11: Bits = Bits::new(s_137_10 as u128, 5u16);
        // C s_137_12: const #29u : u8
        let s_137_12: u8 = 29;
        // C s_137_13: cast zx s_137_12 -> bv
        let s_137_13: Bits = Bits::new(s_137_12 as u128, 5u16);
        // D s_137_14: cmp-eq s_137_11 s_137_13
        let s_137_14: bool = ((s_137_11) == (s_137_13));
        // N s_137_15: branch s_137_14 b995 b138
        if s_137_14 {
            return block_995(state, tracer, fn_state);
        } else {
            return block_138(state, tracer, fn_state);
        };
    }
    fn block_138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_138_0: const #0u : u8
        let s_138_0: bool = false;
        // D s_138_1: write-var gs#412424 <= s_138_0
        fn_state.gs_412424 = s_138_0;
        // N s_138_2: jump b139
        return block_139(state, tracer, fn_state);
    }
    fn block_139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_139_0: read-var gs#412424:u8
        let s_139_0: bool = fn_state.gs_412424;
        // N s_139_1: branch s_139_0 b991 b140
        if s_139_0 {
            return block_991(state, tracer, fn_state);
        } else {
            return block_140(state, tracer, fn_state);
        };
    }
    fn block_140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_140_0: const #0u : u8
        let s_140_0: bool = false;
        // D s_140_1: write-var gs#412429 <= s_140_0
        fn_state.gs_412429 = s_140_0;
        // N s_140_2: jump b141
        return block_141(state, tracer, fn_state);
    }
    fn block_141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_141_0: read-var gs#412429:u8
        let s_141_0: bool = fn_state.gs_412429;
        // D s_141_1: not s_141_0
        let s_141_1: bool = !s_141_0;
        // N s_141_2: branch s_141_1 b143 b142
        if s_141_1 {
            return block_143(state, tracer, fn_state);
        } else {
            return block_142(state, tracer, fn_state);
        };
    }
    fn block_142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_142_0: const #3446s : i
        let s_142_0: i128 = 3446;
        // C s_142_1: const #14696u : u32
        let s_142_1: u32 = 14696;
        // N s_142_2: write-reg s_142_1 <= s_142_0
        let s_142_2: () = {
            state.write_register::<i128>(s_142_1 as isize, s_142_0);
            tracer.write_register(s_142_1 as isize, s_142_0);
        };
        // C s_142_3: const #28s : i
        let s_142_3: i128 = 28;
        // C s_142_4: const #4s : i
        let s_142_4: i128 = 4;
        // D s_142_5: read-var u#34096:u32
        let s_142_5: u32 = fn_state.u_34096;
        // D s_142_6: cast zx s_142_5 -> bv
        let s_142_6: Bits = Bits::new(s_142_5 as u128, 32u16);
        // D s_142_7: bit-extract s_142_6 s_142_3 s_142_4
        let s_142_7: Bits = (Bits::new(
            ((s_142_6) >> (s_142_3)).value(),
            u16::try_from(s_142_4).unwrap(),
        ));
        // D s_142_8: cast reint s_142_7 -> u8
        let s_142_8: u8 = (s_142_7.value() as u8);
        // C s_142_9: const #22s : i
        let s_142_9: i128 = 22;
        // C s_142_10: const #1s : i
        let s_142_10: i128 = 1;
        // D s_142_11: read-var u#34096:u32
        let s_142_11: u32 = fn_state.u_34096;
        // D s_142_12: cast zx s_142_11 -> bv
        let s_142_12: Bits = Bits::new(s_142_11 as u128, 32u16);
        // D s_142_13: bit-extract s_142_12 s_142_9 s_142_10
        let s_142_13: Bits = (Bits::new(
            ((s_142_12) >> (s_142_9)).value(),
            u16::try_from(s_142_10).unwrap(),
        ));
        // D s_142_14: cast reint s_142_13 -> u8
        let s_142_14: bool = ((s_142_13.value()) != 0);
        // C s_142_15: const #16s : i
        let s_142_15: i128 = 16;
        // C s_142_16: const #4s : i
        let s_142_16: i128 = 4;
        // D s_142_17: read-var u#34096:u32
        let s_142_17: u32 = fn_state.u_34096;
        // D s_142_18: cast zx s_142_17 -> bv
        let s_142_18: Bits = Bits::new(s_142_17 as u128, 32u16);
        // D s_142_19: bit-extract s_142_18 s_142_15 s_142_16
        let s_142_19: Bits = (Bits::new(
            ((s_142_18) >> (s_142_15)).value(),
            u16::try_from(s_142_16).unwrap(),
        ));
        // D s_142_20: cast reint s_142_19 -> u8
        let s_142_20: u8 = (s_142_19.value() as u8);
        // C s_142_21: const #12s : i
        let s_142_21: i128 = 12;
        // C s_142_22: const #4s : i
        let s_142_22: i128 = 4;
        // D s_142_23: read-var u#34096:u32
        let s_142_23: u32 = fn_state.u_34096;
        // D s_142_24: cast zx s_142_23 -> bv
        let s_142_24: Bits = Bits::new(s_142_23 as u128, 32u16);
        // D s_142_25: bit-extract s_142_24 s_142_21 s_142_22
        let s_142_25: Bits = (Bits::new(
            ((s_142_24) >> (s_142_21)).value(),
            u16::try_from(s_142_22).unwrap(),
        ));
        // D s_142_26: cast reint s_142_25 -> u8
        let s_142_26: u8 = (s_142_25.value() as u8);
        // C s_142_27: const #8s : i
        let s_142_27: i128 = 8;
        // C s_142_28: const #2s : i
        let s_142_28: i128 = 2;
        // D s_142_29: read-var u#34096:u32
        let s_142_29: u32 = fn_state.u_34096;
        // D s_142_30: cast zx s_142_29 -> bv
        let s_142_30: Bits = Bits::new(s_142_29 as u128, 32u16);
        // D s_142_31: bit-extract s_142_30 s_142_27 s_142_28
        let s_142_31: Bits = (Bits::new(
            ((s_142_30) >> (s_142_27)).value(),
            u16::try_from(s_142_28).unwrap(),
        ));
        // D s_142_32: cast reint s_142_31 -> u8
        let s_142_32: u8 = (s_142_31.value() as u8);
        // C s_142_33: const #7s : i
        let s_142_33: i128 = 7;
        // C s_142_34: const #1s : i
        let s_142_34: i128 = 1;
        // D s_142_35: read-var u#34096:u32
        let s_142_35: u32 = fn_state.u_34096;
        // D s_142_36: cast zx s_142_35 -> bv
        let s_142_36: Bits = Bits::new(s_142_35 as u128, 32u16);
        // D s_142_37: bit-extract s_142_36 s_142_33 s_142_34
        let s_142_37: Bits = (Bits::new(
            ((s_142_36) >> (s_142_33)).value(),
            u16::try_from(s_142_34).unwrap(),
        ));
        // D s_142_38: cast reint s_142_37 -> u8
        let s_142_38: bool = ((s_142_37.value()) != 0);
        // C s_142_39: const #6s : i
        let s_142_39: i128 = 6;
        // C s_142_40: const #1s : i
        let s_142_40: i128 = 1;
        // D s_142_41: read-var u#34096:u32
        let s_142_41: u32 = fn_state.u_34096;
        // D s_142_42: cast zx s_142_41 -> bv
        let s_142_42: Bits = Bits::new(s_142_41 as u128, 32u16);
        // D s_142_43: bit-extract s_142_42 s_142_39 s_142_40
        let s_142_43: Bits = (Bits::new(
            ((s_142_42) >> (s_142_39)).value(),
            u16::try_from(s_142_40).unwrap(),
        ));
        // D s_142_44: cast reint s_142_43 -> u8
        let s_142_44: bool = ((s_142_43.value()) != 0);
        // C s_142_45: const #5s : i
        let s_142_45: i128 = 5;
        // C s_142_46: const #1s : i
        let s_142_46: i128 = 1;
        // D s_142_47: read-var u#34096:u32
        let s_142_47: u32 = fn_state.u_34096;
        // D s_142_48: cast zx s_142_47 -> bv
        let s_142_48: Bits = Bits::new(s_142_47 as u128, 32u16);
        // D s_142_49: bit-extract s_142_48 s_142_45 s_142_46
        let s_142_49: Bits = (Bits::new(
            ((s_142_48) >> (s_142_45)).value(),
            u16::try_from(s_142_46).unwrap(),
        ));
        // D s_142_50: cast reint s_142_49 -> u8
        let s_142_50: bool = ((s_142_49.value()) != 0);
        // C s_142_51: const #0s : i
        let s_142_51: i128 = 0;
        // C s_142_52: const #4s : i
        let s_142_52: i128 = 4;
        // D s_142_53: read-var u#34096:u32
        let s_142_53: u32 = fn_state.u_34096;
        // D s_142_54: cast zx s_142_53 -> bv
        let s_142_54: Bits = Bits::new(s_142_53 as u128, 32u16);
        // D s_142_55: bit-extract s_142_54 s_142_51 s_142_52
        let s_142_55: Bits = (Bits::new(
            ((s_142_54) >> (s_142_51)).value(),
            u16::try_from(s_142_52).unwrap(),
        ));
        // D s_142_56: cast reint s_142_55 -> u8
        let s_142_56: u8 = (s_142_55.value() as u8);
        // D s_142_57: call decode_aarch32_instrs_VFNMA_A1enc_A_txt(s_142_8, s_142_14, s_142_20, s_142_26, s_142_32, s_142_38, s_142_44, s_142_50, s_142_56)
        let s_142_57: () = decode_aarch32_instrs_VFNMA_A1enc_A_txt(
            state,
            tracer,
            s_142_8,
            s_142_14,
            s_142_20,
            s_142_26,
            s_142_32,
            s_142_38,
            s_142_44,
            s_142_50,
            s_142_56,
        );
        // N s_142_58: return
        return;
    }
    fn block_143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_143_0: read-var merge#var.1:struct
        let s_143_0: u32 = fn_state.merge_var._1;
        // D s_143_1: write-var u#34107 <= s_143_0
        fn_state.u_34107 = s_143_0;
        // C s_143_2: const #25s : i
        let s_143_2: i128 = 25;
        // D s_143_3: read-var u#34107:u32
        let s_143_3: u32 = fn_state.u_34107;
        // D s_143_4: cast zx s_143_3 -> bv
        let s_143_4: Bits = Bits::new(s_143_3 as u128, 32u16);
        // C s_143_5: const #1s : i64
        let s_143_5: i64 = 1;
        // C s_143_6: cast zx s_143_5 -> i
        let s_143_6: i128 = (i128::try_from(s_143_5).unwrap());
        // C s_143_7: const #2s : i
        let s_143_7: i128 = 2;
        // C s_143_8: add s_143_7 s_143_6
        let s_143_8: i128 = (s_143_7 + s_143_6);
        // D s_143_9: bit-extract s_143_4 s_143_2 s_143_8
        let s_143_9: Bits = (Bits::new(
            ((s_143_4) >> (s_143_2)).value(),
            u16::try_from(s_143_8).unwrap(),
        ));
        // D s_143_10: cast reint s_143_9 -> u8
        let s_143_10: u8 = (s_143_9.value() as u8);
        // D s_143_11: cast zx s_143_10 -> bv
        let s_143_11: Bits = Bits::new(s_143_10 as u128, 3u16);
        // C s_143_12: const #6u : u8
        let s_143_12: u8 = 6;
        // C s_143_13: cast zx s_143_12 -> bv
        let s_143_13: Bits = Bits::new(s_143_12 as u128, 3u16);
        // D s_143_14: cmp-eq s_143_11 s_143_13
        let s_143_14: bool = ((s_143_11) == (s_143_13));
        // N s_143_15: branch s_143_14 b987 b144
        if s_143_14 {
            return block_987(state, tracer, fn_state);
        } else {
            return block_144(state, tracer, fn_state);
        };
    }
    fn block_144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_144_0: const #0u : u8
        let s_144_0: bool = false;
        // D s_144_1: write-var gs#412458 <= s_144_0
        fn_state.gs_412458 = s_144_0;
        // N s_144_2: jump b145
        return block_145(state, tracer, fn_state);
    }
    fn block_145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_145_0: read-var gs#412458:u8
        let s_145_0: bool = fn_state.gs_412458;
        // N s_145_1: branch s_145_0 b983 b146
        if s_145_0 {
            return block_983(state, tracer, fn_state);
        } else {
            return block_146(state, tracer, fn_state);
        };
    }
    fn block_146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_146_0: const #0u : u8
        let s_146_0: bool = false;
        // D s_146_1: write-var gs#412463 <= s_146_0
        fn_state.gs_412463 = s_146_0;
        // N s_146_2: jump b147
        return block_147(state, tracer, fn_state);
    }
    fn block_147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_147_0: read-var gs#412463:u8
        let s_147_0: bool = fn_state.gs_412463;
        // D s_147_1: not s_147_0
        let s_147_1: bool = !s_147_0;
        // N s_147_2: branch s_147_1 b149 b148
        if s_147_1 {
            return block_149(state, tracer, fn_state);
        } else {
            return block_148(state, tracer, fn_state);
        };
    }
    fn block_148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_148_0: const #3498s : i
        let s_148_0: i128 = 3498;
        // C s_148_1: const #14696u : u32
        let s_148_1: u32 = 14696;
        // N s_148_2: write-reg s_148_1 <= s_148_0
        let s_148_2: () = {
            state.write_register::<i128>(s_148_1 as isize, s_148_0);
            tracer.write_register(s_148_1 as isize, s_148_0);
        };
        // C s_148_3: const #28s : i
        let s_148_3: i128 = 28;
        // C s_148_4: const #4s : i
        let s_148_4: i128 = 4;
        // D s_148_5: read-var u#34107:u32
        let s_148_5: u32 = fn_state.u_34107;
        // D s_148_6: cast zx s_148_5 -> bv
        let s_148_6: Bits = Bits::new(s_148_5 as u128, 32u16);
        // D s_148_7: bit-extract s_148_6 s_148_3 s_148_4
        let s_148_7: Bits = (Bits::new(
            ((s_148_6) >> (s_148_3)).value(),
            u16::try_from(s_148_4).unwrap(),
        ));
        // D s_148_8: cast reint s_148_7 -> u8
        let s_148_8: u8 = (s_148_7.value() as u8);
        // C s_148_9: const #24s : i
        let s_148_9: i128 = 24;
        // C s_148_10: const #1s : i
        let s_148_10: i128 = 1;
        // D s_148_11: read-var u#34107:u32
        let s_148_11: u32 = fn_state.u_34107;
        // D s_148_12: cast zx s_148_11 -> bv
        let s_148_12: Bits = Bits::new(s_148_11 as u128, 32u16);
        // D s_148_13: bit-extract s_148_12 s_148_9 s_148_10
        let s_148_13: Bits = (Bits::new(
            ((s_148_12) >> (s_148_9)).value(),
            u16::try_from(s_148_10).unwrap(),
        ));
        // D s_148_14: cast reint s_148_13 -> u8
        let s_148_14: bool = ((s_148_13.value()) != 0);
        // C s_148_15: const #23s : i
        let s_148_15: i128 = 23;
        // C s_148_16: const #1s : i
        let s_148_16: i128 = 1;
        // D s_148_17: read-var u#34107:u32
        let s_148_17: u32 = fn_state.u_34107;
        // D s_148_18: cast zx s_148_17 -> bv
        let s_148_18: Bits = Bits::new(s_148_17 as u128, 32u16);
        // D s_148_19: bit-extract s_148_18 s_148_15 s_148_16
        let s_148_19: Bits = (Bits::new(
            ((s_148_18) >> (s_148_15)).value(),
            u16::try_from(s_148_16).unwrap(),
        ));
        // D s_148_20: cast reint s_148_19 -> u8
        let s_148_20: bool = ((s_148_19.value()) != 0);
        // C s_148_21: const #22s : i
        let s_148_21: i128 = 22;
        // C s_148_22: const #1s : i
        let s_148_22: i128 = 1;
        // D s_148_23: read-var u#34107:u32
        let s_148_23: u32 = fn_state.u_34107;
        // D s_148_24: cast zx s_148_23 -> bv
        let s_148_24: Bits = Bits::new(s_148_23 as u128, 32u16);
        // D s_148_25: bit-extract s_148_24 s_148_21 s_148_22
        let s_148_25: Bits = (Bits::new(
            ((s_148_24) >> (s_148_21)).value(),
            u16::try_from(s_148_22).unwrap(),
        ));
        // D s_148_26: cast reint s_148_25 -> u8
        let s_148_26: bool = ((s_148_25.value()) != 0);
        // C s_148_27: const #21s : i
        let s_148_27: i128 = 21;
        // C s_148_28: const #1s : i
        let s_148_28: i128 = 1;
        // D s_148_29: read-var u#34107:u32
        let s_148_29: u32 = fn_state.u_34107;
        // D s_148_30: cast zx s_148_29 -> bv
        let s_148_30: Bits = Bits::new(s_148_29 as u128, 32u16);
        // D s_148_31: bit-extract s_148_30 s_148_27 s_148_28
        let s_148_31: Bits = (Bits::new(
            ((s_148_30) >> (s_148_27)).value(),
            u16::try_from(s_148_28).unwrap(),
        ));
        // D s_148_32: cast reint s_148_31 -> u8
        let s_148_32: bool = ((s_148_31.value()) != 0);
        // C s_148_33: const #16s : i
        let s_148_33: i128 = 16;
        // C s_148_34: const #4s : i
        let s_148_34: i128 = 4;
        // D s_148_35: read-var u#34107:u32
        let s_148_35: u32 = fn_state.u_34107;
        // D s_148_36: cast zx s_148_35 -> bv
        let s_148_36: Bits = Bits::new(s_148_35 as u128, 32u16);
        // D s_148_37: bit-extract s_148_36 s_148_33 s_148_34
        let s_148_37: Bits = (Bits::new(
            ((s_148_36) >> (s_148_33)).value(),
            u16::try_from(s_148_34).unwrap(),
        ));
        // D s_148_38: cast reint s_148_37 -> u8
        let s_148_38: u8 = (s_148_37.value() as u8);
        // C s_148_39: const #12s : i
        let s_148_39: i128 = 12;
        // C s_148_40: const #4s : i
        let s_148_40: i128 = 4;
        // D s_148_41: read-var u#34107:u32
        let s_148_41: u32 = fn_state.u_34107;
        // D s_148_42: cast zx s_148_41 -> bv
        let s_148_42: Bits = Bits::new(s_148_41 as u128, 32u16);
        // D s_148_43: bit-extract s_148_42 s_148_39 s_148_40
        let s_148_43: Bits = (Bits::new(
            ((s_148_42) >> (s_148_39)).value(),
            u16::try_from(s_148_40).unwrap(),
        ));
        // D s_148_44: cast reint s_148_43 -> u8
        let s_148_44: u8 = (s_148_43.value() as u8);
        // C s_148_45: const #0s : i
        let s_148_45: i128 = 0;
        // C s_148_46: const #8s : i
        let s_148_46: i128 = 8;
        // D s_148_47: read-var u#34107:u32
        let s_148_47: u32 = fn_state.u_34107;
        // D s_148_48: cast zx s_148_47 -> bv
        let s_148_48: Bits = Bits::new(s_148_47 as u128, 32u16);
        // D s_148_49: bit-extract s_148_48 s_148_45 s_148_46
        let s_148_49: Bits = (Bits::new(
            ((s_148_48) >> (s_148_45)).value(),
            u16::try_from(s_148_46).unwrap(),
        ));
        // D s_148_50: cast reint s_148_49 -> u8
        let s_148_50: u8 = (s_148_49.value() as u8);
        // D s_148_51: call decode_aarch32_instrs_VLDM_A1enc_A_txt(s_148_8, s_148_14, s_148_20, s_148_26, s_148_32, s_148_38, s_148_44, s_148_50)
        let s_148_51: () = decode_aarch32_instrs_VLDM_A1enc_A_txt(
            state,
            tracer,
            s_148_8,
            s_148_14,
            s_148_20,
            s_148_26,
            s_148_32,
            s_148_38,
            s_148_44,
            s_148_50,
        );
        // N s_148_52: return
        return;
    }
    fn block_149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_149_0: read-var merge#var.1:struct
        let s_149_0: u32 = fn_state.merge_var._1;
        // D s_149_1: write-var u#34117 <= s_149_0
        fn_state.u_34117 = s_149_0;
        // C s_149_2: const #25s : i
        let s_149_2: i128 = 25;
        // D s_149_3: read-var u#34117:u32
        let s_149_3: u32 = fn_state.u_34117;
        // D s_149_4: cast zx s_149_3 -> bv
        let s_149_4: Bits = Bits::new(s_149_3 as u128, 32u16);
        // C s_149_5: const #1s : i64
        let s_149_5: i64 = 1;
        // C s_149_6: cast zx s_149_5 -> i
        let s_149_6: i128 = (i128::try_from(s_149_5).unwrap());
        // C s_149_7: const #2s : i
        let s_149_7: i128 = 2;
        // C s_149_8: add s_149_7 s_149_6
        let s_149_8: i128 = (s_149_7 + s_149_6);
        // D s_149_9: bit-extract s_149_4 s_149_2 s_149_8
        let s_149_9: Bits = (Bits::new(
            ((s_149_4) >> (s_149_2)).value(),
            u16::try_from(s_149_8).unwrap(),
        ));
        // D s_149_10: cast reint s_149_9 -> u8
        let s_149_10: u8 = (s_149_9.value() as u8);
        // D s_149_11: cast zx s_149_10 -> bv
        let s_149_11: Bits = Bits::new(s_149_10 as u128, 3u16);
        // C s_149_12: const #6u : u8
        let s_149_12: u8 = 6;
        // C s_149_13: cast zx s_149_12 -> bv
        let s_149_13: Bits = Bits::new(s_149_12 as u128, 3u16);
        // D s_149_14: cmp-eq s_149_11 s_149_13
        let s_149_14: bool = ((s_149_11) == (s_149_13));
        // N s_149_15: branch s_149_14 b979 b150
        if s_149_14 {
            return block_979(state, tracer, fn_state);
        } else {
            return block_150(state, tracer, fn_state);
        };
    }
    fn block_150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_150_0: const #0u : u8
        let s_150_0: bool = false;
        // D s_150_1: write-var gs#412490 <= s_150_0
        fn_state.gs_412490 = s_150_0;
        // N s_150_2: jump b151
        return block_151(state, tracer, fn_state);
    }
    fn block_151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_151_0: read-var gs#412490:u8
        let s_151_0: bool = fn_state.gs_412490;
        // N s_151_1: branch s_151_0 b975 b152
        if s_151_0 {
            return block_975(state, tracer, fn_state);
        } else {
            return block_152(state, tracer, fn_state);
        };
    }
    fn block_152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_152_0: const #0u : u8
        let s_152_0: bool = false;
        // D s_152_1: write-var gs#412495 <= s_152_0
        fn_state.gs_412495 = s_152_0;
        // N s_152_2: jump b153
        return block_153(state, tracer, fn_state);
    }
    fn block_153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_153_0: read-var gs#412495:u8
        let s_153_0: bool = fn_state.gs_412495;
        // D s_153_1: not s_153_0
        let s_153_1: bool = !s_153_0;
        // N s_153_2: branch s_153_1 b155 b154
        if s_153_1 {
            return block_155(state, tracer, fn_state);
        } else {
            return block_154(state, tracer, fn_state);
        };
    }
    fn block_154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_154_0: const #3499s : i
        let s_154_0: i128 = 3499;
        // C s_154_1: const #14696u : u32
        let s_154_1: u32 = 14696;
        // N s_154_2: write-reg s_154_1 <= s_154_0
        let s_154_2: () = {
            state.write_register::<i128>(s_154_1 as isize, s_154_0);
            tracer.write_register(s_154_1 as isize, s_154_0);
        };
        // C s_154_3: const #28s : i
        let s_154_3: i128 = 28;
        // C s_154_4: const #4s : i
        let s_154_4: i128 = 4;
        // D s_154_5: read-var u#34117:u32
        let s_154_5: u32 = fn_state.u_34117;
        // D s_154_6: cast zx s_154_5 -> bv
        let s_154_6: Bits = Bits::new(s_154_5 as u128, 32u16);
        // D s_154_7: bit-extract s_154_6 s_154_3 s_154_4
        let s_154_7: Bits = (Bits::new(
            ((s_154_6) >> (s_154_3)).value(),
            u16::try_from(s_154_4).unwrap(),
        ));
        // D s_154_8: cast reint s_154_7 -> u8
        let s_154_8: u8 = (s_154_7.value() as u8);
        // C s_154_9: const #24s : i
        let s_154_9: i128 = 24;
        // C s_154_10: const #1s : i
        let s_154_10: i128 = 1;
        // D s_154_11: read-var u#34117:u32
        let s_154_11: u32 = fn_state.u_34117;
        // D s_154_12: cast zx s_154_11 -> bv
        let s_154_12: Bits = Bits::new(s_154_11 as u128, 32u16);
        // D s_154_13: bit-extract s_154_12 s_154_9 s_154_10
        let s_154_13: Bits = (Bits::new(
            ((s_154_12) >> (s_154_9)).value(),
            u16::try_from(s_154_10).unwrap(),
        ));
        // D s_154_14: cast reint s_154_13 -> u8
        let s_154_14: bool = ((s_154_13.value()) != 0);
        // C s_154_15: const #23s : i
        let s_154_15: i128 = 23;
        // C s_154_16: const #1s : i
        let s_154_16: i128 = 1;
        // D s_154_17: read-var u#34117:u32
        let s_154_17: u32 = fn_state.u_34117;
        // D s_154_18: cast zx s_154_17 -> bv
        let s_154_18: Bits = Bits::new(s_154_17 as u128, 32u16);
        // D s_154_19: bit-extract s_154_18 s_154_15 s_154_16
        let s_154_19: Bits = (Bits::new(
            ((s_154_18) >> (s_154_15)).value(),
            u16::try_from(s_154_16).unwrap(),
        ));
        // D s_154_20: cast reint s_154_19 -> u8
        let s_154_20: bool = ((s_154_19.value()) != 0);
        // C s_154_21: const #22s : i
        let s_154_21: i128 = 22;
        // C s_154_22: const #1s : i
        let s_154_22: i128 = 1;
        // D s_154_23: read-var u#34117:u32
        let s_154_23: u32 = fn_state.u_34117;
        // D s_154_24: cast zx s_154_23 -> bv
        let s_154_24: Bits = Bits::new(s_154_23 as u128, 32u16);
        // D s_154_25: bit-extract s_154_24 s_154_21 s_154_22
        let s_154_25: Bits = (Bits::new(
            ((s_154_24) >> (s_154_21)).value(),
            u16::try_from(s_154_22).unwrap(),
        ));
        // D s_154_26: cast reint s_154_25 -> u8
        let s_154_26: bool = ((s_154_25.value()) != 0);
        // C s_154_27: const #21s : i
        let s_154_27: i128 = 21;
        // C s_154_28: const #1s : i
        let s_154_28: i128 = 1;
        // D s_154_29: read-var u#34117:u32
        let s_154_29: u32 = fn_state.u_34117;
        // D s_154_30: cast zx s_154_29 -> bv
        let s_154_30: Bits = Bits::new(s_154_29 as u128, 32u16);
        // D s_154_31: bit-extract s_154_30 s_154_27 s_154_28
        let s_154_31: Bits = (Bits::new(
            ((s_154_30) >> (s_154_27)).value(),
            u16::try_from(s_154_28).unwrap(),
        ));
        // D s_154_32: cast reint s_154_31 -> u8
        let s_154_32: bool = ((s_154_31.value()) != 0);
        // C s_154_33: const #16s : i
        let s_154_33: i128 = 16;
        // C s_154_34: const #4s : i
        let s_154_34: i128 = 4;
        // D s_154_35: read-var u#34117:u32
        let s_154_35: u32 = fn_state.u_34117;
        // D s_154_36: cast zx s_154_35 -> bv
        let s_154_36: Bits = Bits::new(s_154_35 as u128, 32u16);
        // D s_154_37: bit-extract s_154_36 s_154_33 s_154_34
        let s_154_37: Bits = (Bits::new(
            ((s_154_36) >> (s_154_33)).value(),
            u16::try_from(s_154_34).unwrap(),
        ));
        // D s_154_38: cast reint s_154_37 -> u8
        let s_154_38: u8 = (s_154_37.value() as u8);
        // C s_154_39: const #12s : i
        let s_154_39: i128 = 12;
        // C s_154_40: const #4s : i
        let s_154_40: i128 = 4;
        // D s_154_41: read-var u#34117:u32
        let s_154_41: u32 = fn_state.u_34117;
        // D s_154_42: cast zx s_154_41 -> bv
        let s_154_42: Bits = Bits::new(s_154_41 as u128, 32u16);
        // D s_154_43: bit-extract s_154_42 s_154_39 s_154_40
        let s_154_43: Bits = (Bits::new(
            ((s_154_42) >> (s_154_39)).value(),
            u16::try_from(s_154_40).unwrap(),
        ));
        // D s_154_44: cast reint s_154_43 -> u8
        let s_154_44: u8 = (s_154_43.value() as u8);
        // C s_154_45: const #0s : i
        let s_154_45: i128 = 0;
        // C s_154_46: const #8s : i
        let s_154_46: i128 = 8;
        // D s_154_47: read-var u#34117:u32
        let s_154_47: u32 = fn_state.u_34117;
        // D s_154_48: cast zx s_154_47 -> bv
        let s_154_48: Bits = Bits::new(s_154_47 as u128, 32u16);
        // D s_154_49: bit-extract s_154_48 s_154_45 s_154_46
        let s_154_49: Bits = (Bits::new(
            ((s_154_48) >> (s_154_45)).value(),
            u16::try_from(s_154_46).unwrap(),
        ));
        // D s_154_50: cast reint s_154_49 -> u8
        let s_154_50: u8 = (s_154_49.value() as u8);
        // D s_154_51: call decode_aarch32_instrs_VLDM_A2enc_A_txt(s_154_8, s_154_14, s_154_20, s_154_26, s_154_32, s_154_38, s_154_44, s_154_50)
        let s_154_51: () = decode_aarch32_instrs_VLDM_A2enc_A_txt(
            state,
            tracer,
            s_154_8,
            s_154_14,
            s_154_20,
            s_154_26,
            s_154_32,
            s_154_38,
            s_154_44,
            s_154_50,
        );
        // N s_154_52: return
        return;
    }
    fn block_155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_155_0: read-var merge#var.1:struct
        let s_155_0: u32 = fn_state.merge_var._1;
        // D s_155_1: write-var u#34127 <= s_155_0
        fn_state.u_34127 = s_155_0;
        // C s_155_2: const #24s : i
        let s_155_2: i128 = 24;
        // D s_155_3: read-var u#34127:u32
        let s_155_3: u32 = fn_state.u_34127;
        // D s_155_4: cast zx s_155_3 -> bv
        let s_155_4: Bits = Bits::new(s_155_3 as u128, 32u16);
        // C s_155_5: const #1s : i64
        let s_155_5: i64 = 1;
        // C s_155_6: cast zx s_155_5 -> i
        let s_155_6: i128 = (i128::try_from(s_155_5).unwrap());
        // C s_155_7: const #3s : i
        let s_155_7: i128 = 3;
        // C s_155_8: add s_155_7 s_155_6
        let s_155_8: i128 = (s_155_7 + s_155_6);
        // D s_155_9: bit-extract s_155_4 s_155_2 s_155_8
        let s_155_9: Bits = (Bits::new(
            ((s_155_4) >> (s_155_2)).value(),
            u16::try_from(s_155_8).unwrap(),
        ));
        // D s_155_10: cast reint s_155_9 -> u8
        let s_155_10: u8 = (s_155_9.value() as u8);
        // D s_155_11: cast zx s_155_10 -> bv
        let s_155_11: Bits = Bits::new(s_155_10 as u128, 4u16);
        // C s_155_12: const #13u : u8
        let s_155_12: u8 = 13;
        // C s_155_13: cast zx s_155_12 -> bv
        let s_155_13: Bits = Bits::new(s_155_12 as u128, 4u16);
        // D s_155_14: cmp-eq s_155_11 s_155_13
        let s_155_14: bool = ((s_155_11) == (s_155_13));
        // N s_155_15: branch s_155_14 b971 b156
        if s_155_14 {
            return block_971(state, tracer, fn_state);
        } else {
            return block_156(state, tracer, fn_state);
        };
    }
    fn block_156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_156_0: const #0u : u8
        let s_156_0: bool = false;
        // D s_156_1: write-var gs#412522 <= s_156_0
        fn_state.gs_412522 = s_156_0;
        // N s_156_2: jump b157
        return block_157(state, tracer, fn_state);
    }
    fn block_157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_157_0: read-var gs#412522:u8
        let s_157_0: bool = fn_state.gs_412522;
        // N s_157_1: branch s_157_0 b967 b158
        if s_157_0 {
            return block_967(state, tracer, fn_state);
        } else {
            return block_158(state, tracer, fn_state);
        };
    }
    fn block_158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_158_0: const #0u : u8
        let s_158_0: bool = false;
        // D s_158_1: write-var gs#412527 <= s_158_0
        fn_state.gs_412527 = s_158_0;
        // N s_158_2: jump b159
        return block_159(state, tracer, fn_state);
    }
    fn block_159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_159_0: read-var gs#412527:u8
        let s_159_0: bool = fn_state.gs_412527;
        // D s_159_1: not s_159_0
        let s_159_1: bool = !s_159_0;
        // N s_159_2: branch s_159_1 b161 b160
        if s_159_1 {
            return block_161(state, tracer, fn_state);
        } else {
            return block_160(state, tracer, fn_state);
        };
    }
    fn block_160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_160_0: const #3502s : i
        let s_160_0: i128 = 3502;
        // C s_160_1: const #14696u : u32
        let s_160_1: u32 = 14696;
        // N s_160_2: write-reg s_160_1 <= s_160_0
        let s_160_2: () = {
            state.write_register::<i128>(s_160_1 as isize, s_160_0);
            tracer.write_register(s_160_1 as isize, s_160_0);
        };
        // C s_160_3: const #28s : i
        let s_160_3: i128 = 28;
        // C s_160_4: const #4s : i
        let s_160_4: i128 = 4;
        // D s_160_5: read-var u#34127:u32
        let s_160_5: u32 = fn_state.u_34127;
        // D s_160_6: cast zx s_160_5 -> bv
        let s_160_6: Bits = Bits::new(s_160_5 as u128, 32u16);
        // D s_160_7: bit-extract s_160_6 s_160_3 s_160_4
        let s_160_7: Bits = (Bits::new(
            ((s_160_6) >> (s_160_3)).value(),
            u16::try_from(s_160_4).unwrap(),
        ));
        // D s_160_8: cast reint s_160_7 -> u8
        let s_160_8: u8 = (s_160_7.value() as u8);
        // C s_160_9: const #23s : i
        let s_160_9: i128 = 23;
        // C s_160_10: const #1s : i
        let s_160_10: i128 = 1;
        // D s_160_11: read-var u#34127:u32
        let s_160_11: u32 = fn_state.u_34127;
        // D s_160_12: cast zx s_160_11 -> bv
        let s_160_12: Bits = Bits::new(s_160_11 as u128, 32u16);
        // D s_160_13: bit-extract s_160_12 s_160_9 s_160_10
        let s_160_13: Bits = (Bits::new(
            ((s_160_12) >> (s_160_9)).value(),
            u16::try_from(s_160_10).unwrap(),
        ));
        // D s_160_14: cast reint s_160_13 -> u8
        let s_160_14: bool = ((s_160_13.value()) != 0);
        // C s_160_15: const #22s : i
        let s_160_15: i128 = 22;
        // C s_160_16: const #1s : i
        let s_160_16: i128 = 1;
        // D s_160_17: read-var u#34127:u32
        let s_160_17: u32 = fn_state.u_34127;
        // D s_160_18: cast zx s_160_17 -> bv
        let s_160_18: Bits = Bits::new(s_160_17 as u128, 32u16);
        // D s_160_19: bit-extract s_160_18 s_160_15 s_160_16
        let s_160_19: Bits = (Bits::new(
            ((s_160_18) >> (s_160_15)).value(),
            u16::try_from(s_160_16).unwrap(),
        ));
        // D s_160_20: cast reint s_160_19 -> u8
        let s_160_20: bool = ((s_160_19.value()) != 0);
        // C s_160_21: const #16s : i
        let s_160_21: i128 = 16;
        // C s_160_22: const #4s : i
        let s_160_22: i128 = 4;
        // D s_160_23: read-var u#34127:u32
        let s_160_23: u32 = fn_state.u_34127;
        // D s_160_24: cast zx s_160_23 -> bv
        let s_160_24: Bits = Bits::new(s_160_23 as u128, 32u16);
        // D s_160_25: bit-extract s_160_24 s_160_21 s_160_22
        let s_160_25: Bits = (Bits::new(
            ((s_160_24) >> (s_160_21)).value(),
            u16::try_from(s_160_22).unwrap(),
        ));
        // D s_160_26: cast reint s_160_25 -> u8
        let s_160_26: u8 = (s_160_25.value() as u8);
        // C s_160_27: const #12s : i
        let s_160_27: i128 = 12;
        // C s_160_28: const #4s : i
        let s_160_28: i128 = 4;
        // D s_160_29: read-var u#34127:u32
        let s_160_29: u32 = fn_state.u_34127;
        // D s_160_30: cast zx s_160_29 -> bv
        let s_160_30: Bits = Bits::new(s_160_29 as u128, 32u16);
        // D s_160_31: bit-extract s_160_30 s_160_27 s_160_28
        let s_160_31: Bits = (Bits::new(
            ((s_160_30) >> (s_160_27)).value(),
            u16::try_from(s_160_28).unwrap(),
        ));
        // D s_160_32: cast reint s_160_31 -> u8
        let s_160_32: u8 = (s_160_31.value() as u8);
        // C s_160_33: const #8s : i
        let s_160_33: i128 = 8;
        // C s_160_34: const #2s : i
        let s_160_34: i128 = 2;
        // D s_160_35: read-var u#34127:u32
        let s_160_35: u32 = fn_state.u_34127;
        // D s_160_36: cast zx s_160_35 -> bv
        let s_160_36: Bits = Bits::new(s_160_35 as u128, 32u16);
        // D s_160_37: bit-extract s_160_36 s_160_33 s_160_34
        let s_160_37: Bits = (Bits::new(
            ((s_160_36) >> (s_160_33)).value(),
            u16::try_from(s_160_34).unwrap(),
        ));
        // D s_160_38: cast reint s_160_37 -> u8
        let s_160_38: u8 = (s_160_37.value() as u8);
        // C s_160_39: const #0s : i
        let s_160_39: i128 = 0;
        // C s_160_40: const #8s : i
        let s_160_40: i128 = 8;
        // D s_160_41: read-var u#34127:u32
        let s_160_41: u32 = fn_state.u_34127;
        // D s_160_42: cast zx s_160_41 -> bv
        let s_160_42: Bits = Bits::new(s_160_41 as u128, 32u16);
        // D s_160_43: bit-extract s_160_42 s_160_39 s_160_40
        let s_160_43: Bits = (Bits::new(
            ((s_160_42) >> (s_160_39)).value(),
            u16::try_from(s_160_40).unwrap(),
        ));
        // D s_160_44: cast reint s_160_43 -> u8
        let s_160_44: u8 = (s_160_43.value() as u8);
        // D s_160_45: call decode_aarch32_instrs_VLDR_A1enc_A_txt(s_160_8, s_160_14, s_160_20, s_160_26, s_160_32, s_160_38, s_160_44)
        let s_160_45: () = decode_aarch32_instrs_VLDR_A1enc_A_txt(
            state,
            tracer,
            s_160_8,
            s_160_14,
            s_160_20,
            s_160_26,
            s_160_32,
            s_160_38,
            s_160_44,
        );
        // N s_160_46: return
        return;
    }
    fn block_161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_161_0: read-var merge#var.1:struct
        let s_161_0: u32 = fn_state.merge_var._1;
        // D s_161_1: write-var u#34136 <= s_161_0
        fn_state.u_34136 = s_161_0;
        // C s_161_2: const #23s : i
        let s_161_2: i128 = 23;
        // D s_161_3: read-var u#34136:u32
        let s_161_3: u32 = fn_state.u_34136;
        // D s_161_4: cast zx s_161_3 -> bv
        let s_161_4: Bits = Bits::new(s_161_3 as u128, 32u16);
        // C s_161_5: const #1s : i64
        let s_161_5: i64 = 1;
        // C s_161_6: cast zx s_161_5 -> i
        let s_161_6: i128 = (i128::try_from(s_161_5).unwrap());
        // C s_161_7: const #4s : i
        let s_161_7: i128 = 4;
        // C s_161_8: add s_161_7 s_161_6
        let s_161_8: i128 = (s_161_7 + s_161_6);
        // D s_161_9: bit-extract s_161_4 s_161_2 s_161_8
        let s_161_9: Bits = (Bits::new(
            ((s_161_4) >> (s_161_2)).value(),
            u16::try_from(s_161_8).unwrap(),
        ));
        // D s_161_10: cast reint s_161_9 -> u8
        let s_161_10: u8 = (s_161_9.value() as u8);
        // D s_161_11: cast zx s_161_10 -> bv
        let s_161_11: Bits = Bits::new(s_161_10 as u128, 5u16);
        // C s_161_12: const #28u : u8
        let s_161_12: u8 = 28;
        // C s_161_13: cast zx s_161_12 -> bv
        let s_161_13: Bits = Bits::new(s_161_12 as u128, 5u16);
        // D s_161_14: cmp-eq s_161_11 s_161_13
        let s_161_14: bool = ((s_161_11) == (s_161_13));
        // N s_161_15: branch s_161_14 b960 b162
        if s_161_14 {
            return block_960(state, tracer, fn_state);
        } else {
            return block_162(state, tracer, fn_state);
        };
    }
    fn block_162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_162_0: const #0u : u8
        let s_162_0: bool = false;
        // D s_162_1: write-var gs#412555 <= s_162_0
        fn_state.gs_412555 = s_162_0;
        // N s_162_2: jump b163
        return block_163(state, tracer, fn_state);
    }
    fn block_163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_163_0: read-var gs#412555:u8
        let s_163_0: bool = fn_state.gs_412555;
        // N s_163_1: branch s_163_0 b956 b164
        if s_163_0 {
            return block_956(state, tracer, fn_state);
        } else {
            return block_164(state, tracer, fn_state);
        };
    }
    fn block_164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_164_0: const #0u : u8
        let s_164_0: bool = false;
        // D s_164_1: write-var gs#412560 <= s_164_0
        fn_state.gs_412560 = s_164_0;
        // N s_164_2: jump b165
        return block_165(state, tracer, fn_state);
    }
    fn block_165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_165_0: read-var gs#412560:u8
        let s_165_0: bool = fn_state.gs_412560;
        // D s_165_1: not s_165_0
        let s_165_1: bool = !s_165_0;
        // N s_165_2: branch s_165_1 b167 b166
        if s_165_1 {
            return block_167(state, tracer, fn_state);
        } else {
            return block_166(state, tracer, fn_state);
        };
    }
    fn block_166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_166_0: const #3509s : i
        let s_166_0: i128 = 3509;
        // C s_166_1: const #14696u : u32
        let s_166_1: u32 = 14696;
        // N s_166_2: write-reg s_166_1 <= s_166_0
        let s_166_2: () = {
            state.write_register::<i128>(s_166_1 as isize, s_166_0);
            tracer.write_register(s_166_1 as isize, s_166_0);
        };
        // C s_166_3: const #28s : i
        let s_166_3: i128 = 28;
        // C s_166_4: const #4s : i
        let s_166_4: i128 = 4;
        // D s_166_5: read-var u#34136:u32
        let s_166_5: u32 = fn_state.u_34136;
        // D s_166_6: cast zx s_166_5 -> bv
        let s_166_6: Bits = Bits::new(s_166_5 as u128, 32u16);
        // D s_166_7: bit-extract s_166_6 s_166_3 s_166_4
        let s_166_7: Bits = (Bits::new(
            ((s_166_6) >> (s_166_3)).value(),
            u16::try_from(s_166_4).unwrap(),
        ));
        // D s_166_8: cast reint s_166_7 -> u8
        let s_166_8: u8 = (s_166_7.value() as u8);
        // C s_166_9: const #22s : i
        let s_166_9: i128 = 22;
        // C s_166_10: const #1s : i
        let s_166_10: i128 = 1;
        // D s_166_11: read-var u#34136:u32
        let s_166_11: u32 = fn_state.u_34136;
        // D s_166_12: cast zx s_166_11 -> bv
        let s_166_12: Bits = Bits::new(s_166_11 as u128, 32u16);
        // D s_166_13: bit-extract s_166_12 s_166_9 s_166_10
        let s_166_13: Bits = (Bits::new(
            ((s_166_12) >> (s_166_9)).value(),
            u16::try_from(s_166_10).unwrap(),
        ));
        // D s_166_14: cast reint s_166_13 -> u8
        let s_166_14: bool = ((s_166_13.value()) != 0);
        // C s_166_15: const #16s : i
        let s_166_15: i128 = 16;
        // C s_166_16: const #4s : i
        let s_166_16: i128 = 4;
        // D s_166_17: read-var u#34136:u32
        let s_166_17: u32 = fn_state.u_34136;
        // D s_166_18: cast zx s_166_17 -> bv
        let s_166_18: Bits = Bits::new(s_166_17 as u128, 32u16);
        // D s_166_19: bit-extract s_166_18 s_166_15 s_166_16
        let s_166_19: Bits = (Bits::new(
            ((s_166_18) >> (s_166_15)).value(),
            u16::try_from(s_166_16).unwrap(),
        ));
        // D s_166_20: cast reint s_166_19 -> u8
        let s_166_20: u8 = (s_166_19.value() as u8);
        // C s_166_21: const #12s : i
        let s_166_21: i128 = 12;
        // C s_166_22: const #4s : i
        let s_166_22: i128 = 4;
        // D s_166_23: read-var u#34136:u32
        let s_166_23: u32 = fn_state.u_34136;
        // D s_166_24: cast zx s_166_23 -> bv
        let s_166_24: Bits = Bits::new(s_166_23 as u128, 32u16);
        // D s_166_25: bit-extract s_166_24 s_166_21 s_166_22
        let s_166_25: Bits = (Bits::new(
            ((s_166_24) >> (s_166_21)).value(),
            u16::try_from(s_166_22).unwrap(),
        ));
        // D s_166_26: cast reint s_166_25 -> u8
        let s_166_26: u8 = (s_166_25.value() as u8);
        // C s_166_27: const #8s : i
        let s_166_27: i128 = 8;
        // C s_166_28: const #2s : i
        let s_166_28: i128 = 2;
        // D s_166_29: read-var u#34136:u32
        let s_166_29: u32 = fn_state.u_34136;
        // D s_166_30: cast zx s_166_29 -> bv
        let s_166_30: Bits = Bits::new(s_166_29 as u128, 32u16);
        // D s_166_31: bit-extract s_166_30 s_166_27 s_166_28
        let s_166_31: Bits = (Bits::new(
            ((s_166_30) >> (s_166_27)).value(),
            u16::try_from(s_166_28).unwrap(),
        ));
        // D s_166_32: cast reint s_166_31 -> u8
        let s_166_32: u8 = (s_166_31.value() as u8);
        // C s_166_33: const #7s : i
        let s_166_33: i128 = 7;
        // C s_166_34: const #1s : i
        let s_166_34: i128 = 1;
        // D s_166_35: read-var u#34136:u32
        let s_166_35: u32 = fn_state.u_34136;
        // D s_166_36: cast zx s_166_35 -> bv
        let s_166_36: Bits = Bits::new(s_166_35 as u128, 32u16);
        // D s_166_37: bit-extract s_166_36 s_166_33 s_166_34
        let s_166_37: Bits = (Bits::new(
            ((s_166_36) >> (s_166_33)).value(),
            u16::try_from(s_166_34).unwrap(),
        ));
        // D s_166_38: cast reint s_166_37 -> u8
        let s_166_38: bool = ((s_166_37.value()) != 0);
        // C s_166_39: const #6s : i
        let s_166_39: i128 = 6;
        // C s_166_40: const #1s : i
        let s_166_40: i128 = 1;
        // D s_166_41: read-var u#34136:u32
        let s_166_41: u32 = fn_state.u_34136;
        // D s_166_42: cast zx s_166_41 -> bv
        let s_166_42: Bits = Bits::new(s_166_41 as u128, 32u16);
        // D s_166_43: bit-extract s_166_42 s_166_39 s_166_40
        let s_166_43: Bits = (Bits::new(
            ((s_166_42) >> (s_166_39)).value(),
            u16::try_from(s_166_40).unwrap(),
        ));
        // D s_166_44: cast reint s_166_43 -> u8
        let s_166_44: bool = ((s_166_43.value()) != 0);
        // C s_166_45: const #5s : i
        let s_166_45: i128 = 5;
        // C s_166_46: const #1s : i
        let s_166_46: i128 = 1;
        // D s_166_47: read-var u#34136:u32
        let s_166_47: u32 = fn_state.u_34136;
        // D s_166_48: cast zx s_166_47 -> bv
        let s_166_48: Bits = Bits::new(s_166_47 as u128, 32u16);
        // D s_166_49: bit-extract s_166_48 s_166_45 s_166_46
        let s_166_49: Bits = (Bits::new(
            ((s_166_48) >> (s_166_45)).value(),
            u16::try_from(s_166_46).unwrap(),
        ));
        // D s_166_50: cast reint s_166_49 -> u8
        let s_166_50: bool = ((s_166_49.value()) != 0);
        // C s_166_51: const #0s : i
        let s_166_51: i128 = 0;
        // C s_166_52: const #4s : i
        let s_166_52: i128 = 4;
        // D s_166_53: read-var u#34136:u32
        let s_166_53: u32 = fn_state.u_34136;
        // D s_166_54: cast zx s_166_53 -> bv
        let s_166_54: Bits = Bits::new(s_166_53 as u128, 32u16);
        // D s_166_55: bit-extract s_166_54 s_166_51 s_166_52
        let s_166_55: Bits = (Bits::new(
            ((s_166_54) >> (s_166_51)).value(),
            u16::try_from(s_166_52).unwrap(),
        ));
        // D s_166_56: cast reint s_166_55 -> u8
        let s_166_56: u8 = (s_166_55.value() as u8);
        // D s_166_57: call decode_aarch32_instrs_VMLA_f_A2enc_A_txt(s_166_8, s_166_14, s_166_20, s_166_26, s_166_32, s_166_38, s_166_44, s_166_50, s_166_56)
        let s_166_57: () = decode_aarch32_instrs_VMLA_f_A2enc_A_txt(
            state,
            tracer,
            s_166_8,
            s_166_14,
            s_166_20,
            s_166_26,
            s_166_32,
            s_166_38,
            s_166_44,
            s_166_50,
            s_166_56,
        );
        // N s_166_58: return
        return;
    }
    fn block_167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_167_0: read-var merge#var.1:struct
        let s_167_0: u32 = fn_state.merge_var._1;
        // D s_167_1: write-var u#34147 <= s_167_0
        fn_state.u_34147 = s_167_0;
        // C s_167_2: const #23s : i
        let s_167_2: i128 = 23;
        // D s_167_3: read-var u#34147:u32
        let s_167_3: u32 = fn_state.u_34147;
        // D s_167_4: cast zx s_167_3 -> bv
        let s_167_4: Bits = Bits::new(s_167_3 as u128, 32u16);
        // C s_167_5: const #1s : i64
        let s_167_5: i64 = 1;
        // C s_167_6: cast zx s_167_5 -> i
        let s_167_6: i128 = (i128::try_from(s_167_5).unwrap());
        // C s_167_7: const #8s : i
        let s_167_7: i128 = 8;
        // C s_167_8: add s_167_7 s_167_6
        let s_167_8: i128 = (s_167_7 + s_167_6);
        // D s_167_9: bit-extract s_167_4 s_167_2 s_167_8
        let s_167_9: Bits = (Bits::new(
            ((s_167_4) >> (s_167_2)).value(),
            u16::try_from(s_167_8).unwrap(),
        ));
        // D s_167_10: cast reint s_167_9 -> u9
        let s_167_10: u16 = (s_167_9.value() as u16);
        // D s_167_11: cast zx s_167_10 -> bv
        let s_167_11: Bits = Bits::new(s_167_10 as u128, 9u16);
        // C s_167_12: const #509u : u9
        let s_167_12: u16 = 509;
        // C s_167_13: cast zx s_167_12 -> bv
        let s_167_13: Bits = Bits::new(s_167_12 as u128, 9u16);
        // D s_167_14: cmp-eq s_167_11 s_167_13
        let s_167_14: bool = ((s_167_11) == (s_167_13));
        // N s_167_15: branch s_167_14 b949 b168
        if s_167_14 {
            return block_949(state, tracer, fn_state);
        } else {
            return block_168(state, tracer, fn_state);
        };
    }
    fn block_168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_168_0: const #0u : u8
        let s_168_0: bool = false;
        // D s_168_1: write-var gs#412592 <= s_168_0
        fn_state.gs_412592 = s_168_0;
        // N s_168_2: jump b169
        return block_169(state, tracer, fn_state);
    }
    fn block_169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_169_0: read-var gs#412592:u8
        let s_169_0: bool = fn_state.gs_412592;
        // N s_169_1: branch s_169_0 b948 b170
        if s_169_0 {
            return block_948(state, tracer, fn_state);
        } else {
            return block_170(state, tracer, fn_state);
        };
    }
    fn block_170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_170_0: const #0u : u8
        let s_170_0: bool = false;
        // D s_170_1: write-var gs#412594 <= s_170_0
        fn_state.gs_412594 = s_170_0;
        // N s_170_2: jump b171
        return block_171(state, tracer, fn_state);
    }
    fn block_171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_171_0: read-var gs#412594:u8
        let s_171_0: bool = fn_state.gs_412594;
        // D s_171_1: not s_171_0
        let s_171_1: bool = !s_171_0;
        // N s_171_2: branch s_171_1 b173 b172
        if s_171_1 {
            return block_173(state, tracer, fn_state);
        } else {
            return block_172(state, tracer, fn_state);
        };
    }
    fn block_172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_172_0: const #3520s : i
        let s_172_0: i128 = 3520;
        // C s_172_1: const #14696u : u32
        let s_172_1: u32 = 14696;
        // N s_172_2: write-reg s_172_1 <= s_172_0
        let s_172_2: () = {
            state.write_register::<i128>(s_172_1 as isize, s_172_0);
            tracer.write_register(s_172_1 as isize, s_172_0);
        };
        // C s_172_3: const #22s : i
        let s_172_3: i128 = 22;
        // C s_172_4: const #1s : i
        let s_172_4: i128 = 1;
        // D s_172_5: read-var u#34147:u32
        let s_172_5: u32 = fn_state.u_34147;
        // D s_172_6: cast zx s_172_5 -> bv
        let s_172_6: Bits = Bits::new(s_172_5 as u128, 32u16);
        // D s_172_7: bit-extract s_172_6 s_172_3 s_172_4
        let s_172_7: Bits = (Bits::new(
            ((s_172_6) >> (s_172_3)).value(),
            u16::try_from(s_172_4).unwrap(),
        ));
        // D s_172_8: cast reint s_172_7 -> u8
        let s_172_8: bool = ((s_172_7.value()) != 0);
        // C s_172_9: const #12s : i
        let s_172_9: i128 = 12;
        // C s_172_10: const #4s : i
        let s_172_10: i128 = 4;
        // D s_172_11: read-var u#34147:u32
        let s_172_11: u32 = fn_state.u_34147;
        // D s_172_12: cast zx s_172_11 -> bv
        let s_172_12: Bits = Bits::new(s_172_11 as u128, 32u16);
        // D s_172_13: bit-extract s_172_12 s_172_9 s_172_10
        let s_172_13: Bits = (Bits::new(
            ((s_172_12) >> (s_172_9)).value(),
            u16::try_from(s_172_10).unwrap(),
        ));
        // D s_172_14: cast reint s_172_13 -> u8
        let s_172_14: u8 = (s_172_13.value() as u8);
        // C s_172_15: const #5s : i
        let s_172_15: i128 = 5;
        // C s_172_16: const #1s : i
        let s_172_16: i128 = 1;
        // D s_172_17: read-var u#34147:u32
        let s_172_17: u32 = fn_state.u_34147;
        // D s_172_18: cast zx s_172_17 -> bv
        let s_172_18: Bits = Bits::new(s_172_17 as u128, 32u16);
        // D s_172_19: bit-extract s_172_18 s_172_15 s_172_16
        let s_172_19: Bits = (Bits::new(
            ((s_172_18) >> (s_172_15)).value(),
            u16::try_from(s_172_16).unwrap(),
        ));
        // D s_172_20: cast reint s_172_19 -> u8
        let s_172_20: bool = ((s_172_19.value()) != 0);
        // C s_172_21: const #0s : i
        let s_172_21: i128 = 0;
        // C s_172_22: const #4s : i
        let s_172_22: i128 = 4;
        // D s_172_23: read-var u#34147:u32
        let s_172_23: u32 = fn_state.u_34147;
        // D s_172_24: cast zx s_172_23 -> bv
        let s_172_24: Bits = Bits::new(s_172_23 as u128, 32u16);
        // D s_172_25: bit-extract s_172_24 s_172_21 s_172_22
        let s_172_25: Bits = (Bits::new(
            ((s_172_24) >> (s_172_21)).value(),
            u16::try_from(s_172_22).unwrap(),
        ));
        // D s_172_26: cast reint s_172_25 -> u8
        let s_172_26: u8 = (s_172_25.value() as u8);
        // D s_172_27: call decode_aarch32_instrs_VMOVX_A1enc_A_txt(s_172_8, s_172_14, s_172_20, s_172_26)
        let s_172_27: () = decode_aarch32_instrs_VMOVX_A1enc_A_txt(
            state,
            tracer,
            s_172_8,
            s_172_14,
            s_172_20,
            s_172_26,
        );
        // N s_172_28: return
        return;
    }
    fn block_173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_173_0: read-var merge#var.1:struct
        let s_173_0: u32 = fn_state.merge_var._1;
        // D s_173_1: write-var u#34153 <= s_173_0
        fn_state.u_34153 = s_173_0;
        // C s_173_2: const #23s : i
        let s_173_2: i128 = 23;
        // D s_173_3: read-var u#34153:u32
        let s_173_3: u32 = fn_state.u_34153;
        // D s_173_4: cast zx s_173_3 -> bv
        let s_173_4: Bits = Bits::new(s_173_3 as u128, 32u16);
        // C s_173_5: const #1s : i64
        let s_173_5: i64 = 1;
        // C s_173_6: cast zx s_173_5 -> i
        let s_173_6: i128 = (i128::try_from(s_173_5).unwrap());
        // C s_173_7: const #8s : i
        let s_173_7: i128 = 8;
        // C s_173_8: add s_173_7 s_173_6
        let s_173_8: i128 = (s_173_7 + s_173_6);
        // D s_173_9: bit-extract s_173_4 s_173_2 s_173_8
        let s_173_9: Bits = (Bits::new(
            ((s_173_4) >> (s_173_2)).value(),
            u16::try_from(s_173_8).unwrap(),
        ));
        // D s_173_10: cast reint s_173_9 -> u9
        let s_173_10: u16 = (s_173_9.value() as u16);
        // D s_173_11: cast zx s_173_10 -> bv
        let s_173_11: Bits = Bits::new(s_173_10 as u128, 9u16);
        // C s_173_12: const #509u : u9
        let s_173_12: u16 = 509;
        // C s_173_13: cast zx s_173_12 -> bv
        let s_173_13: Bits = Bits::new(s_173_12 as u128, 9u16);
        // D s_173_14: cmp-eq s_173_11 s_173_13
        let s_173_14: bool = ((s_173_11) == (s_173_13));
        // N s_173_15: branch s_173_14 b941 b174
        if s_173_14 {
            return block_941(state, tracer, fn_state);
        } else {
            return block_174(state, tracer, fn_state);
        };
    }
    fn block_174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_174_0: const #0u : u8
        let s_174_0: bool = false;
        // D s_174_1: write-var gs#412616 <= s_174_0
        fn_state.gs_412616 = s_174_0;
        // N s_174_2: jump b175
        return block_175(state, tracer, fn_state);
    }
    fn block_175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_175_0: read-var gs#412616:u8
        let s_175_0: bool = fn_state.gs_412616;
        // N s_175_1: branch s_175_0 b940 b176
        if s_175_0 {
            return block_940(state, tracer, fn_state);
        } else {
            return block_176(state, tracer, fn_state);
        };
    }
    fn block_176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_176_0: const #0u : u8
        let s_176_0: bool = false;
        // D s_176_1: write-var gs#412618 <= s_176_0
        fn_state.gs_412618 = s_176_0;
        // N s_176_2: jump b177
        return block_177(state, tracer, fn_state);
    }
    fn block_177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_177_0: read-var gs#412618:u8
        let s_177_0: bool = fn_state.gs_412618;
        // D s_177_1: not s_177_0
        let s_177_1: bool = !s_177_0;
        // N s_177_2: branch s_177_1 b179 b178
        if s_177_1 {
            return block_179(state, tracer, fn_state);
        } else {
            return block_178(state, tracer, fn_state);
        };
    }
    fn block_178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_178_0: const #3522s : i
        let s_178_0: i128 = 3522;
        // C s_178_1: const #14696u : u32
        let s_178_1: u32 = 14696;
        // N s_178_2: write-reg s_178_1 <= s_178_0
        let s_178_2: () = {
            state.write_register::<i128>(s_178_1 as isize, s_178_0);
            tracer.write_register(s_178_1 as isize, s_178_0);
        };
        // C s_178_3: const #22s : i
        let s_178_3: i128 = 22;
        // C s_178_4: const #1s : i
        let s_178_4: i128 = 1;
        // D s_178_5: read-var u#34153:u32
        let s_178_5: u32 = fn_state.u_34153;
        // D s_178_6: cast zx s_178_5 -> bv
        let s_178_6: Bits = Bits::new(s_178_5 as u128, 32u16);
        // D s_178_7: bit-extract s_178_6 s_178_3 s_178_4
        let s_178_7: Bits = (Bits::new(
            ((s_178_6) >> (s_178_3)).value(),
            u16::try_from(s_178_4).unwrap(),
        ));
        // D s_178_8: cast reint s_178_7 -> u8
        let s_178_8: bool = ((s_178_7.value()) != 0);
        // C s_178_9: const #12s : i
        let s_178_9: i128 = 12;
        // C s_178_10: const #4s : i
        let s_178_10: i128 = 4;
        // D s_178_11: read-var u#34153:u32
        let s_178_11: u32 = fn_state.u_34153;
        // D s_178_12: cast zx s_178_11 -> bv
        let s_178_12: Bits = Bits::new(s_178_11 as u128, 32u16);
        // D s_178_13: bit-extract s_178_12 s_178_9 s_178_10
        let s_178_13: Bits = (Bits::new(
            ((s_178_12) >> (s_178_9)).value(),
            u16::try_from(s_178_10).unwrap(),
        ));
        // D s_178_14: cast reint s_178_13 -> u8
        let s_178_14: u8 = (s_178_13.value() as u8);
        // C s_178_15: const #5s : i
        let s_178_15: i128 = 5;
        // C s_178_16: const #1s : i
        let s_178_16: i128 = 1;
        // D s_178_17: read-var u#34153:u32
        let s_178_17: u32 = fn_state.u_34153;
        // D s_178_18: cast zx s_178_17 -> bv
        let s_178_18: Bits = Bits::new(s_178_17 as u128, 32u16);
        // D s_178_19: bit-extract s_178_18 s_178_15 s_178_16
        let s_178_19: Bits = (Bits::new(
            ((s_178_18) >> (s_178_15)).value(),
            u16::try_from(s_178_16).unwrap(),
        ));
        // D s_178_20: cast reint s_178_19 -> u8
        let s_178_20: bool = ((s_178_19.value()) != 0);
        // C s_178_21: const #0s : i
        let s_178_21: i128 = 0;
        // C s_178_22: const #4s : i
        let s_178_22: i128 = 4;
        // D s_178_23: read-var u#34153:u32
        let s_178_23: u32 = fn_state.u_34153;
        // D s_178_24: cast zx s_178_23 -> bv
        let s_178_24: Bits = Bits::new(s_178_23 as u128, 32u16);
        // D s_178_25: bit-extract s_178_24 s_178_21 s_178_22
        let s_178_25: Bits = (Bits::new(
            ((s_178_24) >> (s_178_21)).value(),
            u16::try_from(s_178_22).unwrap(),
        ));
        // D s_178_26: cast reint s_178_25 -> u8
        let s_178_26: u8 = (s_178_25.value() as u8);
        // D s_178_27: call decode_aarch32_instrs_VINS_A1enc_A_txt(s_178_8, s_178_14, s_178_20, s_178_26)
        let s_178_27: () = decode_aarch32_instrs_VINS_A1enc_A_txt(
            state,
            tracer,
            s_178_8,
            s_178_14,
            s_178_20,
            s_178_26,
        );
        // N s_178_28: return
        return;
    }
    fn block_179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_179_0: read-var merge#var.1:struct
        let s_179_0: u32 = fn_state.merge_var._1;
        // D s_179_1: write-var u#34159 <= s_179_0
        fn_state.u_34159 = s_179_0;
        // C s_179_2: const #21s : i
        let s_179_2: i128 = 21;
        // D s_179_3: read-var u#34159:u32
        let s_179_3: u32 = fn_state.u_34159;
        // D s_179_4: cast zx s_179_3 -> bv
        let s_179_4: Bits = Bits::new(s_179_3 as u128, 32u16);
        // C s_179_5: const #1s : i64
        let s_179_5: i64 = 1;
        // C s_179_6: cast zx s_179_5 -> i
        let s_179_6: i128 = (i128::try_from(s_179_5).unwrap());
        // C s_179_7: const #6s : i
        let s_179_7: i128 = 6;
        // C s_179_8: add s_179_7 s_179_6
        let s_179_8: i128 = (s_179_7 + s_179_6);
        // D s_179_9: bit-extract s_179_4 s_179_2 s_179_8
        let s_179_9: Bits = (Bits::new(
            ((s_179_4) >> (s_179_2)).value(),
            u16::try_from(s_179_8).unwrap(),
        ));
        // D s_179_10: cast reint s_179_9 -> u8
        let s_179_10: u8 = (s_179_9.value() as u8);
        // D s_179_11: cast zx s_179_10 -> bv
        let s_179_11: Bits = Bits::new(s_179_10 as u128, 7u16);
        // C s_179_12: const #98u : u8
        let s_179_12: u8 = 98;
        // C s_179_13: cast zx s_179_12 -> bv
        let s_179_13: Bits = Bits::new(s_179_12 as u128, 7u16);
        // D s_179_14: cmp-eq s_179_11 s_179_13
        let s_179_14: bool = ((s_179_11) == (s_179_13));
        // N s_179_15: branch s_179_14 b936 b180
        if s_179_14 {
            return block_936(state, tracer, fn_state);
        } else {
            return block_180(state, tracer, fn_state);
        };
    }
    fn block_180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_180_0: const #0u : u8
        let s_180_0: bool = false;
        // D s_180_1: write-var gs#412637 <= s_180_0
        fn_state.gs_412637 = s_180_0;
        // N s_180_2: jump b181
        return block_181(state, tracer, fn_state);
    }
    fn block_181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_181_0: read-var gs#412637:u8
        let s_181_0: bool = fn_state.gs_412637;
        // N s_181_1: branch s_181_0 b932 b182
        if s_181_0 {
            return block_932(state, tracer, fn_state);
        } else {
            return block_182(state, tracer, fn_state);
        };
    }
    fn block_182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_182_0: const #0u : u8
        let s_182_0: bool = false;
        // D s_182_1: write-var gs#412642 <= s_182_0
        fn_state.gs_412642 = s_182_0;
        // N s_182_2: jump b183
        return block_183(state, tracer, fn_state);
    }
    fn block_183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_183_0: read-var gs#412642:u8
        let s_183_0: bool = fn_state.gs_412642;
        // D s_183_1: not s_183_0
        let s_183_1: bool = !s_183_0;
        // N s_183_2: branch s_183_1 b185 b184
        if s_183_1 {
            return block_185(state, tracer, fn_state);
        } else {
            return block_184(state, tracer, fn_state);
        };
    }
    fn block_184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_184_0: const #3524s : i
        let s_184_0: i128 = 3524;
        // C s_184_1: const #14696u : u32
        let s_184_1: u32 = 14696;
        // N s_184_2: write-reg s_184_1 <= s_184_0
        let s_184_2: () = {
            state.write_register::<i128>(s_184_1 as isize, s_184_0);
            tracer.write_register(s_184_1 as isize, s_184_0);
        };
        // C s_184_3: const #28s : i
        let s_184_3: i128 = 28;
        // C s_184_4: const #4s : i
        let s_184_4: i128 = 4;
        // D s_184_5: read-var u#34159:u32
        let s_184_5: u32 = fn_state.u_34159;
        // D s_184_6: cast zx s_184_5 -> bv
        let s_184_6: Bits = Bits::new(s_184_5 as u128, 32u16);
        // D s_184_7: bit-extract s_184_6 s_184_3 s_184_4
        let s_184_7: Bits = (Bits::new(
            ((s_184_6) >> (s_184_3)).value(),
            u16::try_from(s_184_4).unwrap(),
        ));
        // D s_184_8: cast reint s_184_7 -> u8
        let s_184_8: u8 = (s_184_7.value() as u8);
        // C s_184_9: const #20s : i
        let s_184_9: i128 = 20;
        // C s_184_10: const #1s : i
        let s_184_10: i128 = 1;
        // D s_184_11: read-var u#34159:u32
        let s_184_11: u32 = fn_state.u_34159;
        // D s_184_12: cast zx s_184_11 -> bv
        let s_184_12: Bits = Bits::new(s_184_11 as u128, 32u16);
        // D s_184_13: bit-extract s_184_12 s_184_9 s_184_10
        let s_184_13: Bits = (Bits::new(
            ((s_184_12) >> (s_184_9)).value(),
            u16::try_from(s_184_10).unwrap(),
        ));
        // D s_184_14: cast reint s_184_13 -> u8
        let s_184_14: bool = ((s_184_13.value()) != 0);
        // C s_184_15: const #16s : i
        let s_184_15: i128 = 16;
        // C s_184_16: const #4s : i
        let s_184_16: i128 = 4;
        // D s_184_17: read-var u#34159:u32
        let s_184_17: u32 = fn_state.u_34159;
        // D s_184_18: cast zx s_184_17 -> bv
        let s_184_18: Bits = Bits::new(s_184_17 as u128, 32u16);
        // D s_184_19: bit-extract s_184_18 s_184_15 s_184_16
        let s_184_19: Bits = (Bits::new(
            ((s_184_18) >> (s_184_15)).value(),
            u16::try_from(s_184_16).unwrap(),
        ));
        // D s_184_20: cast reint s_184_19 -> u8
        let s_184_20: u8 = (s_184_19.value() as u8);
        // C s_184_21: const #12s : i
        let s_184_21: i128 = 12;
        // C s_184_22: const #4s : i
        let s_184_22: i128 = 4;
        // D s_184_23: read-var u#34159:u32
        let s_184_23: u32 = fn_state.u_34159;
        // D s_184_24: cast zx s_184_23 -> bv
        let s_184_24: Bits = Bits::new(s_184_23 as u128, 32u16);
        // D s_184_25: bit-extract s_184_24 s_184_21 s_184_22
        let s_184_25: Bits = (Bits::new(
            ((s_184_24) >> (s_184_21)).value(),
            u16::try_from(s_184_22).unwrap(),
        ));
        // D s_184_26: cast reint s_184_25 -> u8
        let s_184_26: u8 = (s_184_25.value() as u8);
        // C s_184_27: const #5s : i
        let s_184_27: i128 = 5;
        // C s_184_28: const #1s : i
        let s_184_28: i128 = 1;
        // D s_184_29: read-var u#34159:u32
        let s_184_29: u32 = fn_state.u_34159;
        // D s_184_30: cast zx s_184_29 -> bv
        let s_184_30: Bits = Bits::new(s_184_29 as u128, 32u16);
        // D s_184_31: bit-extract s_184_30 s_184_27 s_184_28
        let s_184_31: Bits = (Bits::new(
            ((s_184_30) >> (s_184_27)).value(),
            u16::try_from(s_184_28).unwrap(),
        ));
        // D s_184_32: cast reint s_184_31 -> u8
        let s_184_32: bool = ((s_184_31.value()) != 0);
        // C s_184_33: const #0s : i
        let s_184_33: i128 = 0;
        // C s_184_34: const #4s : i
        let s_184_34: i128 = 4;
        // D s_184_35: read-var u#34159:u32
        let s_184_35: u32 = fn_state.u_34159;
        // D s_184_36: cast zx s_184_35 -> bv
        let s_184_36: Bits = Bits::new(s_184_35 as u128, 32u16);
        // D s_184_37: bit-extract s_184_36 s_184_33 s_184_34
        let s_184_37: Bits = (Bits::new(
            ((s_184_36) >> (s_184_33)).value(),
            u16::try_from(s_184_34).unwrap(),
        ));
        // D s_184_38: cast reint s_184_37 -> u8
        let s_184_38: u8 = (s_184_37.value() as u8);
        // D s_184_39: call decode_aarch32_instrs_VMOV_d_A1enc_A_txt(s_184_8, s_184_14, s_184_20, s_184_26, s_184_32, s_184_38)
        let s_184_39: () = decode_aarch32_instrs_VMOV_d_A1enc_A_txt(
            state,
            tracer,
            s_184_8,
            s_184_14,
            s_184_20,
            s_184_26,
            s_184_32,
            s_184_38,
        );
        // N s_184_40: return
        return;
    }
    fn block_185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_185_0: read-var merge#var.1:struct
        let s_185_0: u32 = fn_state.merge_var._1;
        // D s_185_1: write-var u#34167 <= s_185_0
        fn_state.u_34167 = s_185_0;
        // C s_185_2: const #23s : i
        let s_185_2: i128 = 23;
        // D s_185_3: read-var u#34167:u32
        let s_185_3: u32 = fn_state.u_34167;
        // D s_185_4: cast zx s_185_3 -> bv
        let s_185_4: Bits = Bits::new(s_185_3 as u128, 32u16);
        // C s_185_5: const #1s : i64
        let s_185_5: i64 = 1;
        // C s_185_6: cast zx s_185_5 -> i
        let s_185_6: i128 = (i128::try_from(s_185_5).unwrap());
        // C s_185_7: const #4s : i
        let s_185_7: i128 = 4;
        // C s_185_8: add s_185_7 s_185_6
        let s_185_8: i128 = (s_185_7 + s_185_6);
        // D s_185_9: bit-extract s_185_4 s_185_2 s_185_8
        let s_185_9: Bits = (Bits::new(
            ((s_185_4) >> (s_185_2)).value(),
            u16::try_from(s_185_8).unwrap(),
        ));
        // D s_185_10: cast reint s_185_9 -> u8
        let s_185_10: u8 = (s_185_9.value() as u8);
        // D s_185_11: cast zx s_185_10 -> bv
        let s_185_11: Bits = Bits::new(s_185_10 as u128, 5u16);
        // C s_185_12: const #29u : u8
        let s_185_12: u8 = 29;
        // C s_185_13: cast zx s_185_12 -> bv
        let s_185_13: Bits = Bits::new(s_185_12 as u128, 5u16);
        // D s_185_14: cmp-eq s_185_11 s_185_13
        let s_185_14: bool = ((s_185_11) == (s_185_13));
        // N s_185_15: branch s_185_14 b925 b186
        if s_185_14 {
            return block_925(state, tracer, fn_state);
        } else {
            return block_186(state, tracer, fn_state);
        };
    }
    fn block_186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_186_0: const #0u : u8
        let s_186_0: bool = false;
        // D s_186_1: write-var gs#412668 <= s_186_0
        fn_state.gs_412668 = s_186_0;
        // N s_186_2: jump b187
        return block_187(state, tracer, fn_state);
    }
    fn block_187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_187_0: read-var gs#412668:u8
        let s_187_0: bool = fn_state.gs_412668;
        // N s_187_1: branch s_187_0 b921 b188
        if s_187_0 {
            return block_921(state, tracer, fn_state);
        } else {
            return block_188(state, tracer, fn_state);
        };
    }
    fn block_188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_188_0: const #0u : u8
        let s_188_0: bool = false;
        // D s_188_1: write-var gs#412673 <= s_188_0
        fn_state.gs_412673 = s_188_0;
        // N s_188_2: jump b189
        return block_189(state, tracer, fn_state);
    }
    fn block_189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_189_0: read-var gs#412673:u8
        let s_189_0: bool = fn_state.gs_412673;
        // D s_189_1: not s_189_0
        let s_189_1: bool = !s_189_0;
        // N s_189_2: branch s_189_1 b196 b190
        if s_189_1 {
            return block_196(state, tracer, fn_state);
        } else {
            return block_190(state, tracer, fn_state);
        };
    }
    fn block_190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_190_0: const #3527s : i
        let s_190_0: i128 = 3527;
        // C s_190_1: const #14696u : u32
        let s_190_1: u32 = 14696;
        // N s_190_2: write-reg s_190_1 <= s_190_0
        let s_190_2: () = {
            state.write_register::<i128>(s_190_1 as isize, s_190_0);
            tracer.write_register(s_190_1 as isize, s_190_0);
        };
        // C s_190_3: const #28s : i
        let s_190_3: i128 = 28;
        // C s_190_4: const #4s : i
        let s_190_4: i128 = 4;
        // D s_190_5: read-var u#34167:u32
        let s_190_5: u32 = fn_state.u_34167;
        // D s_190_6: cast zx s_190_5 -> bv
        let s_190_6: Bits = Bits::new(s_190_5 as u128, 32u16);
        // D s_190_7: bit-extract s_190_6 s_190_3 s_190_4
        let s_190_7: Bits = (Bits::new(
            ((s_190_6) >> (s_190_3)).value(),
            u16::try_from(s_190_4).unwrap(),
        ));
        // D s_190_8: cast reint s_190_7 -> u8
        let s_190_8: u8 = (s_190_7.value() as u8);
        // D s_190_9: write-var u#34168 <= s_190_8
        fn_state.u_34168 = s_190_8;
        // C s_190_10: const #22s : i
        let s_190_10: i128 = 22;
        // C s_190_11: const #1s : i
        let s_190_11: i128 = 1;
        // D s_190_12: read-var u#34167:u32
        let s_190_12: u32 = fn_state.u_34167;
        // D s_190_13: cast zx s_190_12 -> bv
        let s_190_13: Bits = Bits::new(s_190_12 as u128, 32u16);
        // D s_190_14: bit-extract s_190_13 s_190_10 s_190_11
        let s_190_14: Bits = (Bits::new(
            ((s_190_13) >> (s_190_10)).value(),
            u16::try_from(s_190_11).unwrap(),
        ));
        // D s_190_15: cast reint s_190_14 -> u8
        let s_190_15: bool = ((s_190_14.value()) != 0);
        // D s_190_16: write-var u#34169 <= s_190_15
        fn_state.u_34169 = s_190_15;
        // C s_190_17: const #16s : i
        let s_190_17: i128 = 16;
        // C s_190_18: const #4s : i
        let s_190_18: i128 = 4;
        // D s_190_19: read-var u#34167:u32
        let s_190_19: u32 = fn_state.u_34167;
        // D s_190_20: cast zx s_190_19 -> bv
        let s_190_20: Bits = Bits::new(s_190_19 as u128, 32u16);
        // D s_190_21: bit-extract s_190_20 s_190_17 s_190_18
        let s_190_21: Bits = (Bits::new(
            ((s_190_20) >> (s_190_17)).value(),
            u16::try_from(s_190_18).unwrap(),
        ));
        // D s_190_22: cast reint s_190_21 -> u8
        let s_190_22: u8 = (s_190_21.value() as u8);
        // D s_190_23: write-var imm4H <= s_190_22
        fn_state.imm4H = s_190_22;
        // C s_190_24: const #12s : i
        let s_190_24: i128 = 12;
        // C s_190_25: const #4s : i
        let s_190_25: i128 = 4;
        // D s_190_26: read-var u#34167:u32
        let s_190_26: u32 = fn_state.u_34167;
        // D s_190_27: cast zx s_190_26 -> bv
        let s_190_27: Bits = Bits::new(s_190_26 as u128, 32u16);
        // D s_190_28: bit-extract s_190_27 s_190_24 s_190_25
        let s_190_28: Bits = (Bits::new(
            ((s_190_27) >> (s_190_24)).value(),
            u16::try_from(s_190_25).unwrap(),
        ));
        // D s_190_29: cast reint s_190_28 -> u8
        let s_190_29: u8 = (s_190_28.value() as u8);
        // D s_190_30: write-var u#34170 <= s_190_29
        fn_state.u_34170 = s_190_29;
        // C s_190_31: const #8s : i
        let s_190_31: i128 = 8;
        // C s_190_32: const #2s : i
        let s_190_32: i128 = 2;
        // D s_190_33: read-var u#34167:u32
        let s_190_33: u32 = fn_state.u_34167;
        // D s_190_34: cast zx s_190_33 -> bv
        let s_190_34: Bits = Bits::new(s_190_33 as u128, 32u16);
        // D s_190_35: bit-extract s_190_34 s_190_31 s_190_32
        let s_190_35: Bits = (Bits::new(
            ((s_190_34) >> (s_190_31)).value(),
            u16::try_from(s_190_32).unwrap(),
        ));
        // D s_190_36: cast reint s_190_35 -> u8
        let s_190_36: u8 = (s_190_35.value() as u8);
        // D s_190_37: write-var u#34171 <= s_190_36
        fn_state.u_34171 = s_190_36;
        // C s_190_38: const #0s : i
        let s_190_38: i128 = 0;
        // C s_190_39: const #4s : i
        let s_190_39: i128 = 4;
        // D s_190_40: read-var u#34167:u32
        let s_190_40: u32 = fn_state.u_34167;
        // D s_190_41: cast zx s_190_40 -> bv
        let s_190_41: Bits = Bits::new(s_190_40 as u128, 32u16);
        // D s_190_42: bit-extract s_190_41 s_190_38 s_190_39
        let s_190_42: Bits = (Bits::new(
            ((s_190_41) >> (s_190_38)).value(),
            u16::try_from(s_190_39).unwrap(),
        ));
        // D s_190_43: cast reint s_190_42 -> u8
        let s_190_43: u8 = (s_190_42.value() as u8);
        // D s_190_44: write-var imm4L <= s_190_43
        fn_state.imm4L = s_190_43;
        // C s_190_45: const #7s : i
        let s_190_45: i128 = 7;
        // D s_190_46: read-var u#34167:u32
        let s_190_46: u32 = fn_state.u_34167;
        // D s_190_47: cast zx s_190_46 -> bv
        let s_190_47: Bits = Bits::new(s_190_46 as u128, 32u16);
        // C s_190_48: const #1u : u64
        let s_190_48: u64 = 1;
        // D s_190_49: bit-extract s_190_47 s_190_45 s_190_48
        let s_190_49: Bits = (Bits::new(
            ((s_190_47) >> (s_190_45)).value(),
            u16::try_from(s_190_48).unwrap(),
        ));
        // D s_190_50: cast reint s_190_49 -> u8
        let s_190_50: bool = ((s_190_49.value()) != 0);
        // C s_190_51: const #0s : i
        let s_190_51: i128 = 0;
        // C s_190_52: const #0u : u64
        let s_190_52: u64 = 0;
        // D s_190_53: cast zx s_190_50 -> u64
        let s_190_53: u64 = (s_190_50 as u64);
        // C s_190_54: const #1u : u64
        let s_190_54: u64 = 1;
        // D s_190_55: and s_190_53 s_190_54
        let s_190_55: u64 = ((s_190_53) & (s_190_54));
        // D s_190_56: cmp-eq s_190_55 s_190_54
        let s_190_56: bool = ((s_190_55) == (s_190_54));
        // D s_190_57: lsl s_190_53 s_190_51
        let s_190_57: u64 = s_190_53 << s_190_51;
        // D s_190_58: or s_190_52 s_190_57
        let s_190_58: u64 = ((s_190_52) | (s_190_57));
        // D s_190_59: cmpl s_190_57
        let s_190_59: u64 = !s_190_57;
        // D s_190_60: and s_190_52 s_190_59
        let s_190_60: u64 = ((s_190_52) & (s_190_59));
        // D s_190_61: select s_190_56 s_190_58 s_190_60
        let s_190_61: u64 = if s_190_56 { s_190_58 } else { s_190_60 };
        // D s_190_62: cast trunc s_190_61 -> u8
        let s_190_62: bool = ((s_190_61) != 0);
        // D s_190_63: cast zx s_190_62 -> bv
        let s_190_63: Bits = Bits::new(s_190_62 as u128, 1u16);
        // C s_190_64: const #0u : u8
        let s_190_64: bool = false;
        // C s_190_65: cast zx s_190_64 -> bv
        let s_190_65: Bits = Bits::new(s_190_64 as u128, 1u16);
        // D s_190_66: cmp-ne s_190_63 s_190_65
        let s_190_66: bool = ((s_190_63) != (s_190_65));
        // N s_190_67: branch s_190_66 b195 b191
        if s_190_66 {
            return block_195(state, tracer, fn_state);
        } else {
            return block_191(state, tracer, fn_state);
        };
    }
    fn block_191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_191_0: const #5s : i
        let s_191_0: i128 = 5;
        // D s_191_1: read-var u#34167:u32
        let s_191_1: u32 = fn_state.u_34167;
        // D s_191_2: cast zx s_191_1 -> bv
        let s_191_2: Bits = Bits::new(s_191_1 as u128, 32u16);
        // C s_191_3: const #1u : u64
        let s_191_3: u64 = 1;
        // D s_191_4: bit-extract s_191_2 s_191_0 s_191_3
        let s_191_4: Bits = (Bits::new(
            ((s_191_2) >> (s_191_0)).value(),
            u16::try_from(s_191_3).unwrap(),
        ));
        // D s_191_5: cast reint s_191_4 -> u8
        let s_191_5: bool = ((s_191_4.value()) != 0);
        // C s_191_6: const #0s : i
        let s_191_6: i128 = 0;
        // C s_191_7: const #0u : u64
        let s_191_7: u64 = 0;
        // D s_191_8: cast zx s_191_5 -> u64
        let s_191_8: u64 = (s_191_5 as u64);
        // C s_191_9: const #1u : u64
        let s_191_9: u64 = 1;
        // D s_191_10: and s_191_8 s_191_9
        let s_191_10: u64 = ((s_191_8) & (s_191_9));
        // D s_191_11: cmp-eq s_191_10 s_191_9
        let s_191_11: bool = ((s_191_10) == (s_191_9));
        // D s_191_12: lsl s_191_8 s_191_6
        let s_191_12: u64 = s_191_8 << s_191_6;
        // D s_191_13: or s_191_7 s_191_12
        let s_191_13: u64 = ((s_191_7) | (s_191_12));
        // D s_191_14: cmpl s_191_12
        let s_191_14: u64 = !s_191_12;
        // D s_191_15: and s_191_7 s_191_14
        let s_191_15: u64 = ((s_191_7) & (s_191_14));
        // D s_191_16: select s_191_11 s_191_13 s_191_15
        let s_191_16: u64 = if s_191_11 { s_191_13 } else { s_191_15 };
        // D s_191_17: cast trunc s_191_16 -> u8
        let s_191_17: bool = ((s_191_16) != 0);
        // D s_191_18: cast zx s_191_17 -> bv
        let s_191_18: Bits = Bits::new(s_191_17 as u128, 1u16);
        // C s_191_19: const #0u : u8
        let s_191_19: bool = false;
        // C s_191_20: cast zx s_191_19 -> bv
        let s_191_20: Bits = Bits::new(s_191_19 as u128, 1u16);
        // D s_191_21: cmp-ne s_191_18 s_191_20
        let s_191_21: bool = ((s_191_18) != (s_191_20));
        // D s_191_22: write-var gs#412692 <= s_191_21
        fn_state.gs_412692 = s_191_21;
        // N s_191_23: jump b192
        return block_192(state, tracer, fn_state);
    }
    fn block_192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_192_0: read-var gs#412692:u8
        let s_192_0: bool = fn_state.gs_412692;
        // N s_192_1: branch s_192_0 b194 b193
        if s_192_0 {
            return block_194(state, tracer, fn_state);
        } else {
            return block_193(state, tracer, fn_state);
        };
    }
    fn block_193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_193_0: read-var u#34168:u8
        let s_193_0: u8 = fn_state.u_34168;
        // D s_193_1: read-var u#34169:u8
        let s_193_1: bool = fn_state.u_34169;
        // D s_193_2: read-var imm4H:u8
        let s_193_2: u8 = fn_state.imm4H;
        // D s_193_3: read-var u#34170:u8
        let s_193_3: u8 = fn_state.u_34170;
        // D s_193_4: read-var u#34171:u8
        let s_193_4: u8 = fn_state.u_34171;
        // D s_193_5: read-var imm4L:u8
        let s_193_5: u8 = fn_state.imm4L;
        // D s_193_6: call decode_aarch32_instrs_VMOV_i_A2enc_A_txt(s_193_0, s_193_1, s_193_2, s_193_3, s_193_4, s_193_5)
        let s_193_6: () = decode_aarch32_instrs_VMOV_i_A2enc_A_txt(
            state,
            tracer,
            s_193_0,
            s_193_1,
            s_193_2,
            s_193_3,
            s_193_4,
            s_193_5,
        );
        // N s_193_7: return
        return;
    }
    fn block_194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_194_0: panic
        panic!("{:?}", ());
        // N s_194_1: return
        return;
    }
    fn block_195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_195_0: const #1u : u8
        let s_195_0: bool = true;
        // D s_195_1: write-var gs#412692 <= s_195_0
        fn_state.gs_412692 = s_195_0;
        // N s_195_2: jump b192
        return block_192(state, tracer, fn_state);
    }
    fn block_196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_196_0: read-var merge#var.1:struct
        let s_196_0: u32 = fn_state.merge_var._1;
        // D s_196_1: write-var u#34173 <= s_196_0
        fn_state.u_34173 = s_196_0;
        // C s_196_2: const #21s : i
        let s_196_2: i128 = 21;
        // D s_196_3: read-var u#34173:u32
        let s_196_3: u32 = fn_state.u_34173;
        // D s_196_4: cast zx s_196_3 -> bv
        let s_196_4: Bits = Bits::new(s_196_3 as u128, 32u16);
        // C s_196_5: const #1s : i64
        let s_196_5: i64 = 1;
        // C s_196_6: cast zx s_196_5 -> i
        let s_196_6: i128 = (i128::try_from(s_196_5).unwrap());
        // C s_196_7: const #6s : i
        let s_196_7: i128 = 6;
        // C s_196_8: add s_196_7 s_196_6
        let s_196_8: i128 = (s_196_7 + s_196_6);
        // D s_196_9: bit-extract s_196_4 s_196_2 s_196_8
        let s_196_9: Bits = (Bits::new(
            ((s_196_4) >> (s_196_2)).value(),
            u16::try_from(s_196_8).unwrap(),
        ));
        // D s_196_10: cast reint s_196_9 -> u8
        let s_196_10: u8 = (s_196_9.value() as u8);
        // D s_196_11: cast zx s_196_10 -> bv
        let s_196_11: Bits = Bits::new(s_196_10 as u128, 7u16);
        // C s_196_12: const #112u : u8
        let s_196_12: u8 = 112;
        // C s_196_13: cast zx s_196_12 -> bv
        let s_196_13: Bits = Bits::new(s_196_12 as u128, 7u16);
        // D s_196_14: cmp-eq s_196_11 s_196_13
        let s_196_14: bool = ((s_196_11) == (s_196_13));
        // N s_196_15: branch s_196_14 b917 b197
        if s_196_14 {
            return block_917(state, tracer, fn_state);
        } else {
            return block_197(state, tracer, fn_state);
        };
    }
    fn block_197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_197_0: const #0u : u8
        let s_197_0: bool = false;
        // D s_197_1: write-var gs#412701 <= s_197_0
        fn_state.gs_412701 = s_197_0;
        // N s_197_2: jump b198
        return block_198(state, tracer, fn_state);
    }
    fn block_198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_198_0: read-var gs#412701:u8
        let s_198_0: bool = fn_state.gs_412701;
        // N s_198_1: branch s_198_0 b913 b199
        if s_198_0 {
            return block_913(state, tracer, fn_state);
        } else {
            return block_199(state, tracer, fn_state);
        };
    }
    fn block_199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_199_0: const #0u : u8
        let s_199_0: bool = false;
        // D s_199_1: write-var gs#412706 <= s_199_0
        fn_state.gs_412706 = s_199_0;
        // N s_199_2: jump b200
        return block_200(state, tracer, fn_state);
    }
    fn block_200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_200_0: read-var gs#412706:u8
        let s_200_0: bool = fn_state.gs_412706;
        // D s_200_1: not s_200_0
        let s_200_1: bool = !s_200_0;
        // N s_200_2: branch s_200_1 b219 b201
        if s_200_1 {
            return block_219(state, tracer, fn_state);
        } else {
            return block_201(state, tracer, fn_state);
        };
    }
    fn block_201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_201_0: const #3540s : i
        let s_201_0: i128 = 3540;
        // C s_201_1: const #14696u : u32
        let s_201_1: u32 = 14696;
        // N s_201_2: write-reg s_201_1 <= s_201_0
        let s_201_2: () = {
            state.write_register::<i128>(s_201_1 as isize, s_201_0);
            tracer.write_register(s_201_1 as isize, s_201_0);
        };
        // C s_201_3: const #28s : i
        let s_201_3: i128 = 28;
        // C s_201_4: const #4s : i
        let s_201_4: i128 = 4;
        // D s_201_5: read-var u#34173:u32
        let s_201_5: u32 = fn_state.u_34173;
        // D s_201_6: cast zx s_201_5 -> bv
        let s_201_6: Bits = Bits::new(s_201_5 as u128, 32u16);
        // D s_201_7: bit-extract s_201_6 s_201_3 s_201_4
        let s_201_7: Bits = (Bits::new(
            ((s_201_6) >> (s_201_3)).value(),
            u16::try_from(s_201_4).unwrap(),
        ));
        // D s_201_8: cast reint s_201_7 -> u8
        let s_201_8: u8 = (s_201_7.value() as u8);
        // D s_201_9: write-var u#34174 <= s_201_8
        fn_state.u_34174 = s_201_8;
        // C s_201_10: const #20s : i
        let s_201_10: i128 = 20;
        // C s_201_11: const #1s : i
        let s_201_11: i128 = 1;
        // D s_201_12: read-var u#34173:u32
        let s_201_12: u32 = fn_state.u_34173;
        // D s_201_13: cast zx s_201_12 -> bv
        let s_201_13: Bits = Bits::new(s_201_12 as u128, 32u16);
        // D s_201_14: bit-extract s_201_13 s_201_10 s_201_11
        let s_201_14: Bits = (Bits::new(
            ((s_201_13) >> (s_201_10)).value(),
            u16::try_from(s_201_11).unwrap(),
        ));
        // D s_201_15: cast reint s_201_14 -> u8
        let s_201_15: bool = ((s_201_14.value()) != 0);
        // D s_201_16: write-var u#34175 <= s_201_15
        fn_state.u_34175 = s_201_15;
        // C s_201_17: const #16s : i
        let s_201_17: i128 = 16;
        // C s_201_18: const #4s : i
        let s_201_18: i128 = 4;
        // D s_201_19: read-var u#34173:u32
        let s_201_19: u32 = fn_state.u_34173;
        // D s_201_20: cast zx s_201_19 -> bv
        let s_201_20: Bits = Bits::new(s_201_19 as u128, 32u16);
        // D s_201_21: bit-extract s_201_20 s_201_17 s_201_18
        let s_201_21: Bits = (Bits::new(
            ((s_201_20) >> (s_201_17)).value(),
            u16::try_from(s_201_18).unwrap(),
        ));
        // D s_201_22: cast reint s_201_21 -> u8
        let s_201_22: u8 = (s_201_21.value() as u8);
        // D s_201_23: write-var u#34176 <= s_201_22
        fn_state.u_34176 = s_201_22;
        // C s_201_24: const #12s : i
        let s_201_24: i128 = 12;
        // C s_201_25: const #4s : i
        let s_201_25: i128 = 4;
        // D s_201_26: read-var u#34173:u32
        let s_201_26: u32 = fn_state.u_34173;
        // D s_201_27: cast zx s_201_26 -> bv
        let s_201_27: Bits = Bits::new(s_201_26 as u128, 32u16);
        // D s_201_28: bit-extract s_201_27 s_201_24 s_201_25
        let s_201_28: Bits = (Bits::new(
            ((s_201_27) >> (s_201_24)).value(),
            u16::try_from(s_201_25).unwrap(),
        ));
        // D s_201_29: cast reint s_201_28 -> u8
        let s_201_29: u8 = (s_201_28.value() as u8);
        // D s_201_30: write-var u#34177 <= s_201_29
        fn_state.u_34177 = s_201_29;
        // C s_201_31: const #7s : i
        let s_201_31: i128 = 7;
        // C s_201_32: const #1s : i
        let s_201_32: i128 = 1;
        // D s_201_33: read-var u#34173:u32
        let s_201_33: u32 = fn_state.u_34173;
        // D s_201_34: cast zx s_201_33 -> bv
        let s_201_34: Bits = Bits::new(s_201_33 as u128, 32u16);
        // D s_201_35: bit-extract s_201_34 s_201_31 s_201_32
        let s_201_35: Bits = (Bits::new(
            ((s_201_34) >> (s_201_31)).value(),
            u16::try_from(s_201_32).unwrap(),
        ));
        // D s_201_36: cast reint s_201_35 -> u8
        let s_201_36: bool = ((s_201_35.value()) != 0);
        // D s_201_37: write-var u#34178 <= s_201_36
        fn_state.u_34178 = s_201_36;
        // C s_201_38: const #5s : i
        let s_201_38: i128 = 5;
        // D s_201_39: read-var u#34173:u32
        let s_201_39: u32 = fn_state.u_34173;
        // D s_201_40: cast zx s_201_39 -> bv
        let s_201_40: Bits = Bits::new(s_201_39 as u128, 32u16);
        // C s_201_41: const #1u : u64
        let s_201_41: u64 = 1;
        // D s_201_42: bit-extract s_201_40 s_201_38 s_201_41
        let s_201_42: Bits = (Bits::new(
            ((s_201_40) >> (s_201_38)).value(),
            u16::try_from(s_201_41).unwrap(),
        ));
        // D s_201_43: cast reint s_201_42 -> u8
        let s_201_43: bool = ((s_201_42.value()) != 0);
        // C s_201_44: const #0s : i
        let s_201_44: i128 = 0;
        // C s_201_45: const #0u : u64
        let s_201_45: u64 = 0;
        // D s_201_46: cast zx s_201_43 -> u64
        let s_201_46: u64 = (s_201_43 as u64);
        // C s_201_47: const #1u : u64
        let s_201_47: u64 = 1;
        // D s_201_48: and s_201_46 s_201_47
        let s_201_48: u64 = ((s_201_46) & (s_201_47));
        // D s_201_49: cmp-eq s_201_48 s_201_47
        let s_201_49: bool = ((s_201_48) == (s_201_47));
        // D s_201_50: lsl s_201_46 s_201_44
        let s_201_50: u64 = s_201_46 << s_201_44;
        // D s_201_51: or s_201_45 s_201_50
        let s_201_51: u64 = ((s_201_45) | (s_201_50));
        // D s_201_52: cmpl s_201_50
        let s_201_52: u64 = !s_201_50;
        // D s_201_53: and s_201_45 s_201_52
        let s_201_53: u64 = ((s_201_45) & (s_201_52));
        // D s_201_54: select s_201_49 s_201_51 s_201_53
        let s_201_54: u64 = if s_201_49 { s_201_51 } else { s_201_53 };
        // D s_201_55: cast trunc s_201_54 -> u8
        let s_201_55: bool = ((s_201_54) != 0);
        // D s_201_56: cast zx s_201_55 -> bv
        let s_201_56: Bits = Bits::new(s_201_55 as u128, 1u16);
        // C s_201_57: const #0u : u8
        let s_201_57: bool = false;
        // C s_201_58: cast zx s_201_57 -> bv
        let s_201_58: Bits = Bits::new(s_201_57 as u128, 1u16);
        // D s_201_59: cmp-ne s_201_56 s_201_58
        let s_201_59: bool = ((s_201_56) != (s_201_58));
        // N s_201_60: branch s_201_59 b218 b202
        if s_201_59 {
            return block_218(state, tracer, fn_state);
        } else {
            return block_202(state, tracer, fn_state);
        };
    }
    fn block_202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_202_0: const #6s : i
        let s_202_0: i128 = 6;
        // D s_202_1: read-var u#34173:u32
        let s_202_1: u32 = fn_state.u_34173;
        // D s_202_2: cast zx s_202_1 -> bv
        let s_202_2: Bits = Bits::new(s_202_1 as u128, 32u16);
        // C s_202_3: const #1u : u64
        let s_202_3: u64 = 1;
        // D s_202_4: bit-extract s_202_2 s_202_0 s_202_3
        let s_202_4: Bits = (Bits::new(
            ((s_202_2) >> (s_202_0)).value(),
            u16::try_from(s_202_3).unwrap(),
        ));
        // D s_202_5: cast reint s_202_4 -> u8
        let s_202_5: bool = ((s_202_4.value()) != 0);
        // C s_202_6: const #0s : i
        let s_202_6: i128 = 0;
        // C s_202_7: const #0u : u64
        let s_202_7: u64 = 0;
        // D s_202_8: cast zx s_202_5 -> u64
        let s_202_8: u64 = (s_202_5 as u64);
        // C s_202_9: const #1u : u64
        let s_202_9: u64 = 1;
        // D s_202_10: and s_202_8 s_202_9
        let s_202_10: u64 = ((s_202_8) & (s_202_9));
        // D s_202_11: cmp-eq s_202_10 s_202_9
        let s_202_11: bool = ((s_202_10) == (s_202_9));
        // D s_202_12: lsl s_202_8 s_202_6
        let s_202_12: u64 = s_202_8 << s_202_6;
        // D s_202_13: or s_202_7 s_202_12
        let s_202_13: u64 = ((s_202_7) | (s_202_12));
        // D s_202_14: cmpl s_202_12
        let s_202_14: u64 = !s_202_12;
        // D s_202_15: and s_202_7 s_202_14
        let s_202_15: u64 = ((s_202_7) & (s_202_14));
        // D s_202_16: select s_202_11 s_202_13 s_202_15
        let s_202_16: u64 = if s_202_11 { s_202_13 } else { s_202_15 };
        // D s_202_17: cast trunc s_202_16 -> u8
        let s_202_17: bool = ((s_202_16) != 0);
        // D s_202_18: cast zx s_202_17 -> bv
        let s_202_18: Bits = Bits::new(s_202_17 as u128, 1u16);
        // C s_202_19: const #0u : u8
        let s_202_19: bool = false;
        // C s_202_20: cast zx s_202_19 -> bv
        let s_202_20: Bits = Bits::new(s_202_19 as u128, 1u16);
        // D s_202_21: cmp-ne s_202_18 s_202_20
        let s_202_21: bool = ((s_202_18) != (s_202_20));
        // D s_202_22: write-var gs#412723 <= s_202_21
        fn_state.gs_412723 = s_202_21;
        // N s_202_23: jump b203
        return block_203(state, tracer, fn_state);
    }
    fn block_203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_203_0: read-var gs#412723:u8
        let s_203_0: bool = fn_state.gs_412723;
        // N s_203_1: branch s_203_0 b217 b204
        if s_203_0 {
            return block_217(state, tracer, fn_state);
        } else {
            return block_204(state, tracer, fn_state);
        };
    }
    fn block_204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_204_0: const #0s : i
        let s_204_0: i128 = 0;
        // D s_204_1: read-var u#34173:u32
        let s_204_1: u32 = fn_state.u_34173;
        // D s_204_2: cast zx s_204_1 -> bv
        let s_204_2: Bits = Bits::new(s_204_1 as u128, 32u16);
        // C s_204_3: const #1u : u64
        let s_204_3: u64 = 1;
        // D s_204_4: bit-extract s_204_2 s_204_0 s_204_3
        let s_204_4: Bits = (Bits::new(
            ((s_204_2) >> (s_204_0)).value(),
            u16::try_from(s_204_3).unwrap(),
        ));
        // D s_204_5: cast reint s_204_4 -> u8
        let s_204_5: bool = ((s_204_4.value()) != 0);
        // C s_204_6: const #0s : i
        let s_204_6: i128 = 0;
        // C s_204_7: const #0u : u64
        let s_204_7: u64 = 0;
        // D s_204_8: cast zx s_204_5 -> u64
        let s_204_8: u64 = (s_204_5 as u64);
        // C s_204_9: const #1u : u64
        let s_204_9: u64 = 1;
        // D s_204_10: and s_204_8 s_204_9
        let s_204_10: u64 = ((s_204_8) & (s_204_9));
        // D s_204_11: cmp-eq s_204_10 s_204_9
        let s_204_11: bool = ((s_204_10) == (s_204_9));
        // D s_204_12: lsl s_204_8 s_204_6
        let s_204_12: u64 = s_204_8 << s_204_6;
        // D s_204_13: or s_204_7 s_204_12
        let s_204_13: u64 = ((s_204_7) | (s_204_12));
        // D s_204_14: cmpl s_204_12
        let s_204_14: u64 = !s_204_12;
        // D s_204_15: and s_204_7 s_204_14
        let s_204_15: u64 = ((s_204_7) & (s_204_14));
        // D s_204_16: select s_204_11 s_204_13 s_204_15
        let s_204_16: u64 = if s_204_11 { s_204_13 } else { s_204_15 };
        // D s_204_17: cast trunc s_204_16 -> u8
        let s_204_17: bool = ((s_204_16) != 0);
        // D s_204_18: cast zx s_204_17 -> bv
        let s_204_18: Bits = Bits::new(s_204_17 as u128, 1u16);
        // C s_204_19: const #0u : u8
        let s_204_19: bool = false;
        // C s_204_20: cast zx s_204_19 -> bv
        let s_204_20: Bits = Bits::new(s_204_19 as u128, 1u16);
        // D s_204_21: cmp-ne s_204_18 s_204_20
        let s_204_21: bool = ((s_204_18) != (s_204_20));
        // D s_204_22: write-var gs#412726 <= s_204_21
        fn_state.gs_412726 = s_204_21;
        // N s_204_23: jump b205
        return block_205(state, tracer, fn_state);
    }
    fn block_205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_205_0: read-var gs#412726:u8
        let s_205_0: bool = fn_state.gs_412726;
        // N s_205_1: branch s_205_0 b216 b206
        if s_205_0 {
            return block_216(state, tracer, fn_state);
        } else {
            return block_206(state, tracer, fn_state);
        };
    }
    fn block_206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_206_0: const #1s : i
        let s_206_0: i128 = 1;
        // D s_206_1: read-var u#34173:u32
        let s_206_1: u32 = fn_state.u_34173;
        // D s_206_2: cast zx s_206_1 -> bv
        let s_206_2: Bits = Bits::new(s_206_1 as u128, 32u16);
        // C s_206_3: const #1u : u64
        let s_206_3: u64 = 1;
        // D s_206_4: bit-extract s_206_2 s_206_0 s_206_3
        let s_206_4: Bits = (Bits::new(
            ((s_206_2) >> (s_206_0)).value(),
            u16::try_from(s_206_3).unwrap(),
        ));
        // D s_206_5: cast reint s_206_4 -> u8
        let s_206_5: bool = ((s_206_4.value()) != 0);
        // C s_206_6: const #0s : i
        let s_206_6: i128 = 0;
        // C s_206_7: const #0u : u64
        let s_206_7: u64 = 0;
        // D s_206_8: cast zx s_206_5 -> u64
        let s_206_8: u64 = (s_206_5 as u64);
        // C s_206_9: const #1u : u64
        let s_206_9: u64 = 1;
        // D s_206_10: and s_206_8 s_206_9
        let s_206_10: u64 = ((s_206_8) & (s_206_9));
        // D s_206_11: cmp-eq s_206_10 s_206_9
        let s_206_11: bool = ((s_206_10) == (s_206_9));
        // D s_206_12: lsl s_206_8 s_206_6
        let s_206_12: u64 = s_206_8 << s_206_6;
        // D s_206_13: or s_206_7 s_206_12
        let s_206_13: u64 = ((s_206_7) | (s_206_12));
        // D s_206_14: cmpl s_206_12
        let s_206_14: u64 = !s_206_12;
        // D s_206_15: and s_206_7 s_206_14
        let s_206_15: u64 = ((s_206_7) & (s_206_14));
        // D s_206_16: select s_206_11 s_206_13 s_206_15
        let s_206_16: u64 = if s_206_11 { s_206_13 } else { s_206_15 };
        // D s_206_17: cast trunc s_206_16 -> u8
        let s_206_17: bool = ((s_206_16) != 0);
        // D s_206_18: cast zx s_206_17 -> bv
        let s_206_18: Bits = Bits::new(s_206_17 as u128, 1u16);
        // C s_206_19: const #0u : u8
        let s_206_19: bool = false;
        // C s_206_20: cast zx s_206_19 -> bv
        let s_206_20: Bits = Bits::new(s_206_19 as u128, 1u16);
        // D s_206_21: cmp-ne s_206_18 s_206_20
        let s_206_21: bool = ((s_206_18) != (s_206_20));
        // D s_206_22: write-var gs#412729 <= s_206_21
        fn_state.gs_412729 = s_206_21;
        // N s_206_23: jump b207
        return block_207(state, tracer, fn_state);
    }
    fn block_207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_207_0: read-var gs#412729:u8
        let s_207_0: bool = fn_state.gs_412729;
        // N s_207_1: branch s_207_0 b215 b208
        if s_207_0 {
            return block_215(state, tracer, fn_state);
        } else {
            return block_208(state, tracer, fn_state);
        };
    }
    fn block_208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_208_0: const #2s : i
        let s_208_0: i128 = 2;
        // D s_208_1: read-var u#34173:u32
        let s_208_1: u32 = fn_state.u_34173;
        // D s_208_2: cast zx s_208_1 -> bv
        let s_208_2: Bits = Bits::new(s_208_1 as u128, 32u16);
        // C s_208_3: const #1u : u64
        let s_208_3: u64 = 1;
        // D s_208_4: bit-extract s_208_2 s_208_0 s_208_3
        let s_208_4: Bits = (Bits::new(
            ((s_208_2) >> (s_208_0)).value(),
            u16::try_from(s_208_3).unwrap(),
        ));
        // D s_208_5: cast reint s_208_4 -> u8
        let s_208_5: bool = ((s_208_4.value()) != 0);
        // C s_208_6: const #0s : i
        let s_208_6: i128 = 0;
        // C s_208_7: const #0u : u64
        let s_208_7: u64 = 0;
        // D s_208_8: cast zx s_208_5 -> u64
        let s_208_8: u64 = (s_208_5 as u64);
        // C s_208_9: const #1u : u64
        let s_208_9: u64 = 1;
        // D s_208_10: and s_208_8 s_208_9
        let s_208_10: u64 = ((s_208_8) & (s_208_9));
        // D s_208_11: cmp-eq s_208_10 s_208_9
        let s_208_11: bool = ((s_208_10) == (s_208_9));
        // D s_208_12: lsl s_208_8 s_208_6
        let s_208_12: u64 = s_208_8 << s_208_6;
        // D s_208_13: or s_208_7 s_208_12
        let s_208_13: u64 = ((s_208_7) | (s_208_12));
        // D s_208_14: cmpl s_208_12
        let s_208_14: u64 = !s_208_12;
        // D s_208_15: and s_208_7 s_208_14
        let s_208_15: u64 = ((s_208_7) & (s_208_14));
        // D s_208_16: select s_208_11 s_208_13 s_208_15
        let s_208_16: u64 = if s_208_11 { s_208_13 } else { s_208_15 };
        // D s_208_17: cast trunc s_208_16 -> u8
        let s_208_17: bool = ((s_208_16) != 0);
        // D s_208_18: cast zx s_208_17 -> bv
        let s_208_18: Bits = Bits::new(s_208_17 as u128, 1u16);
        // C s_208_19: const #0u : u8
        let s_208_19: bool = false;
        // C s_208_20: cast zx s_208_19 -> bv
        let s_208_20: Bits = Bits::new(s_208_19 as u128, 1u16);
        // D s_208_21: cmp-ne s_208_18 s_208_20
        let s_208_21: bool = ((s_208_18) != (s_208_20));
        // D s_208_22: write-var gs#412732 <= s_208_21
        fn_state.gs_412732 = s_208_21;
        // N s_208_23: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_209_0: read-var gs#412732:u8
        let s_209_0: bool = fn_state.gs_412732;
        // N s_209_1: branch s_209_0 b214 b210
        if s_209_0 {
            return block_214(state, tracer, fn_state);
        } else {
            return block_210(state, tracer, fn_state);
        };
    }
    fn block_210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_210_0: const #3s : i
        let s_210_0: i128 = 3;
        // D s_210_1: read-var u#34173:u32
        let s_210_1: u32 = fn_state.u_34173;
        // D s_210_2: cast zx s_210_1 -> bv
        let s_210_2: Bits = Bits::new(s_210_1 as u128, 32u16);
        // C s_210_3: const #1u : u64
        let s_210_3: u64 = 1;
        // D s_210_4: bit-extract s_210_2 s_210_0 s_210_3
        let s_210_4: Bits = (Bits::new(
            ((s_210_2) >> (s_210_0)).value(),
            u16::try_from(s_210_3).unwrap(),
        ));
        // D s_210_5: cast reint s_210_4 -> u8
        let s_210_5: bool = ((s_210_4.value()) != 0);
        // C s_210_6: const #0s : i
        let s_210_6: i128 = 0;
        // C s_210_7: const #0u : u64
        let s_210_7: u64 = 0;
        // D s_210_8: cast zx s_210_5 -> u64
        let s_210_8: u64 = (s_210_5 as u64);
        // C s_210_9: const #1u : u64
        let s_210_9: u64 = 1;
        // D s_210_10: and s_210_8 s_210_9
        let s_210_10: u64 = ((s_210_8) & (s_210_9));
        // D s_210_11: cmp-eq s_210_10 s_210_9
        let s_210_11: bool = ((s_210_10) == (s_210_9));
        // D s_210_12: lsl s_210_8 s_210_6
        let s_210_12: u64 = s_210_8 << s_210_6;
        // D s_210_13: or s_210_7 s_210_12
        let s_210_13: u64 = ((s_210_7) | (s_210_12));
        // D s_210_14: cmpl s_210_12
        let s_210_14: u64 = !s_210_12;
        // D s_210_15: and s_210_7 s_210_14
        let s_210_15: u64 = ((s_210_7) & (s_210_14));
        // D s_210_16: select s_210_11 s_210_13 s_210_15
        let s_210_16: u64 = if s_210_11 { s_210_13 } else { s_210_15 };
        // D s_210_17: cast trunc s_210_16 -> u8
        let s_210_17: bool = ((s_210_16) != 0);
        // D s_210_18: cast zx s_210_17 -> bv
        let s_210_18: Bits = Bits::new(s_210_17 as u128, 1u16);
        // C s_210_19: const #0u : u8
        let s_210_19: bool = false;
        // C s_210_20: cast zx s_210_19 -> bv
        let s_210_20: Bits = Bits::new(s_210_19 as u128, 1u16);
        // D s_210_21: cmp-ne s_210_18 s_210_20
        let s_210_21: bool = ((s_210_18) != (s_210_20));
        // D s_210_22: write-var gs#412735 <= s_210_21
        fn_state.gs_412735 = s_210_21;
        // N s_210_23: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_211_0: read-var gs#412735:u8
        let s_211_0: bool = fn_state.gs_412735;
        // N s_211_1: branch s_211_0 b213 b212
        if s_211_0 {
            return block_213(state, tracer, fn_state);
        } else {
            return block_212(state, tracer, fn_state);
        };
    }
    fn block_212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_212_0: read-var u#34174:u8
        let s_212_0: u8 = fn_state.u_34174;
        // D s_212_1: read-var u#34175:u8
        let s_212_1: bool = fn_state.u_34175;
        // D s_212_2: read-var u#34176:u8
        let s_212_2: u8 = fn_state.u_34176;
        // D s_212_3: read-var u#34177:u8
        let s_212_3: u8 = fn_state.u_34177;
        // D s_212_4: read-var u#34178:u8
        let s_212_4: bool = fn_state.u_34178;
        // D s_212_5: call decode_aarch32_instrs_VMOV_h_A1enc_A_txt(s_212_0, s_212_1, s_212_2, s_212_3, s_212_4)
        let s_212_5: () = decode_aarch32_instrs_VMOV_h_A1enc_A_txt(
            state,
            tracer,
            s_212_0,
            s_212_1,
            s_212_2,
            s_212_3,
            s_212_4,
        );
        // N s_212_6: return
        return;
    }
    fn block_213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_213_0: panic
        panic!("{:?}", ());
        // N s_213_1: return
        return;
    }
    fn block_214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_214_0: const #1u : u8
        let s_214_0: bool = true;
        // D s_214_1: write-var gs#412735 <= s_214_0
        fn_state.gs_412735 = s_214_0;
        // N s_214_2: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_215_0: const #1u : u8
        let s_215_0: bool = true;
        // D s_215_1: write-var gs#412732 <= s_215_0
        fn_state.gs_412732 = s_215_0;
        // N s_215_2: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_216_0: const #1u : u8
        let s_216_0: bool = true;
        // D s_216_1: write-var gs#412729 <= s_216_0
        fn_state.gs_412729 = s_216_0;
        // N s_216_2: jump b207
        return block_207(state, tracer, fn_state);
    }
    fn block_217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_217_0: const #1u : u8
        let s_217_0: bool = true;
        // D s_217_1: write-var gs#412726 <= s_217_0
        fn_state.gs_412726 = s_217_0;
        // N s_217_2: jump b205
        return block_205(state, tracer, fn_state);
    }
    fn block_218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_218_0: const #1u : u8
        let s_218_0: bool = true;
        // D s_218_1: write-var gs#412723 <= s_218_0
        fn_state.gs_412723 = s_218_0;
        // N s_218_2: jump b203
        return block_203(state, tracer, fn_state);
    }
    fn block_219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_219_0: read-var merge#var.1:struct
        let s_219_0: u32 = fn_state.merge_var._1;
        // D s_219_1: write-var u#34180 <= s_219_0
        fn_state.u_34180 = s_219_0;
        // C s_219_2: const #23s : i
        let s_219_2: i128 = 23;
        // D s_219_3: read-var u#34180:u32
        let s_219_3: u32 = fn_state.u_34180;
        // D s_219_4: cast zx s_219_3 -> bv
        let s_219_4: Bits = Bits::new(s_219_3 as u128, 32u16);
        // C s_219_5: const #1s : i64
        let s_219_5: i64 = 1;
        // C s_219_6: cast zx s_219_5 -> i
        let s_219_6: i128 = (i128::try_from(s_219_5).unwrap());
        // C s_219_7: const #4s : i
        let s_219_7: i128 = 4;
        // C s_219_8: add s_219_7 s_219_6
        let s_219_8: i128 = (s_219_7 + s_219_6);
        // D s_219_9: bit-extract s_219_4 s_219_2 s_219_8
        let s_219_9: Bits = (Bits::new(
            ((s_219_4) >> (s_219_2)).value(),
            u16::try_from(s_219_8).unwrap(),
        ));
        // D s_219_10: cast reint s_219_9 -> u8
        let s_219_10: u8 = (s_219_9.value() as u8);
        // D s_219_11: cast zx s_219_10 -> bv
        let s_219_11: Bits = Bits::new(s_219_10 as u128, 5u16);
        // C s_219_12: const #29u : u8
        let s_219_12: u8 = 29;
        // C s_219_13: cast zx s_219_12 -> bv
        let s_219_13: Bits = Bits::new(s_219_12 as u128, 5u16);
        // D s_219_14: cmp-eq s_219_11 s_219_13
        let s_219_14: bool = ((s_219_11) == (s_219_13));
        // N s_219_15: branch s_219_14 b903 b220
        if s_219_14 {
            return block_903(state, tracer, fn_state);
        } else {
            return block_220(state, tracer, fn_state);
        };
    }
    fn block_220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_220_0: const #0u : u8
        let s_220_0: bool = false;
        // D s_220_1: write-var gs#412750 <= s_220_0
        fn_state.gs_412750 = s_220_0;
        // N s_220_2: jump b221
        return block_221(state, tracer, fn_state);
    }
    fn block_221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_221_0: read-var gs#412750:u8
        let s_221_0: bool = fn_state.gs_412750;
        // N s_221_1: branch s_221_0 b899 b222
        if s_221_0 {
            return block_899(state, tracer, fn_state);
        } else {
            return block_222(state, tracer, fn_state);
        };
    }
    fn block_222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_222_0: const #0u : u8
        let s_222_0: bool = false;
        // D s_222_1: write-var gs#412755 <= s_222_0
        fn_state.gs_412755 = s_222_0;
        // N s_222_2: jump b223
        return block_223(state, tracer, fn_state);
    }
    fn block_223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_223_0: read-var gs#412755:u8
        let s_223_0: bool = fn_state.gs_412755;
        // D s_223_1: not s_223_0
        let s_223_1: bool = !s_223_0;
        // N s_223_2: branch s_223_1 b225 b224
        if s_223_1 {
            return block_225(state, tracer, fn_state);
        } else {
            return block_224(state, tracer, fn_state);
        };
    }
    fn block_224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_224_0: const #3542s : i
        let s_224_0: i128 = 3542;
        // C s_224_1: const #14696u : u32
        let s_224_1: u32 = 14696;
        // N s_224_2: write-reg s_224_1 <= s_224_0
        let s_224_2: () = {
            state.write_register::<i128>(s_224_1 as isize, s_224_0);
            tracer.write_register(s_224_1 as isize, s_224_0);
        };
        // C s_224_3: const #28s : i
        let s_224_3: i128 = 28;
        // C s_224_4: const #4s : i
        let s_224_4: i128 = 4;
        // D s_224_5: read-var u#34180:u32
        let s_224_5: u32 = fn_state.u_34180;
        // D s_224_6: cast zx s_224_5 -> bv
        let s_224_6: Bits = Bits::new(s_224_5 as u128, 32u16);
        // D s_224_7: bit-extract s_224_6 s_224_3 s_224_4
        let s_224_7: Bits = (Bits::new(
            ((s_224_6) >> (s_224_3)).value(),
            u16::try_from(s_224_4).unwrap(),
        ));
        // D s_224_8: cast reint s_224_7 -> u8
        let s_224_8: u8 = (s_224_7.value() as u8);
        // C s_224_9: const #22s : i
        let s_224_9: i128 = 22;
        // C s_224_10: const #1s : i
        let s_224_10: i128 = 1;
        // D s_224_11: read-var u#34180:u32
        let s_224_11: u32 = fn_state.u_34180;
        // D s_224_12: cast zx s_224_11 -> bv
        let s_224_12: Bits = Bits::new(s_224_11 as u128, 32u16);
        // D s_224_13: bit-extract s_224_12 s_224_9 s_224_10
        let s_224_13: Bits = (Bits::new(
            ((s_224_12) >> (s_224_9)).value(),
            u16::try_from(s_224_10).unwrap(),
        ));
        // D s_224_14: cast reint s_224_13 -> u8
        let s_224_14: bool = ((s_224_13.value()) != 0);
        // C s_224_15: const #12s : i
        let s_224_15: i128 = 12;
        // C s_224_16: const #4s : i
        let s_224_16: i128 = 4;
        // D s_224_17: read-var u#34180:u32
        let s_224_17: u32 = fn_state.u_34180;
        // D s_224_18: cast zx s_224_17 -> bv
        let s_224_18: Bits = Bits::new(s_224_17 as u128, 32u16);
        // D s_224_19: bit-extract s_224_18 s_224_15 s_224_16
        let s_224_19: Bits = (Bits::new(
            ((s_224_18) >> (s_224_15)).value(),
            u16::try_from(s_224_16).unwrap(),
        ));
        // D s_224_20: cast reint s_224_19 -> u8
        let s_224_20: u8 = (s_224_19.value() as u8);
        // C s_224_21: const #8s : i
        let s_224_21: i128 = 8;
        // C s_224_22: const #2s : i
        let s_224_22: i128 = 2;
        // D s_224_23: read-var u#34180:u32
        let s_224_23: u32 = fn_state.u_34180;
        // D s_224_24: cast zx s_224_23 -> bv
        let s_224_24: Bits = Bits::new(s_224_23 as u128, 32u16);
        // D s_224_25: bit-extract s_224_24 s_224_21 s_224_22
        let s_224_25: Bits = (Bits::new(
            ((s_224_24) >> (s_224_21)).value(),
            u16::try_from(s_224_22).unwrap(),
        ));
        // D s_224_26: cast reint s_224_25 -> u8
        let s_224_26: u8 = (s_224_25.value() as u8);
        // C s_224_27: const #5s : i
        let s_224_27: i128 = 5;
        // C s_224_28: const #1s : i
        let s_224_28: i128 = 1;
        // D s_224_29: read-var u#34180:u32
        let s_224_29: u32 = fn_state.u_34180;
        // D s_224_30: cast zx s_224_29 -> bv
        let s_224_30: Bits = Bits::new(s_224_29 as u128, 32u16);
        // D s_224_31: bit-extract s_224_30 s_224_27 s_224_28
        let s_224_31: Bits = (Bits::new(
            ((s_224_30) >> (s_224_27)).value(),
            u16::try_from(s_224_28).unwrap(),
        ));
        // D s_224_32: cast reint s_224_31 -> u8
        let s_224_32: bool = ((s_224_31.value()) != 0);
        // C s_224_33: const #0s : i
        let s_224_33: i128 = 0;
        // C s_224_34: const #4s : i
        let s_224_34: i128 = 4;
        // D s_224_35: read-var u#34180:u32
        let s_224_35: u32 = fn_state.u_34180;
        // D s_224_36: cast zx s_224_35 -> bv
        let s_224_36: Bits = Bits::new(s_224_35 as u128, 32u16);
        // D s_224_37: bit-extract s_224_36 s_224_33 s_224_34
        let s_224_37: Bits = (Bits::new(
            ((s_224_36) >> (s_224_33)).value(),
            u16::try_from(s_224_34).unwrap(),
        ));
        // D s_224_38: cast reint s_224_37 -> u8
        let s_224_38: u8 = (s_224_37.value() as u8);
        // D s_224_39: call decode_aarch32_instrs_VMOV_r_A2enc_A_txt(s_224_8, s_224_14, s_224_20, s_224_26, s_224_32, s_224_38)
        let s_224_39: () = decode_aarch32_instrs_VMOV_r_A2enc_A_txt(
            state,
            tracer,
            s_224_8,
            s_224_14,
            s_224_20,
            s_224_26,
            s_224_32,
            s_224_38,
        );
        // N s_224_40: return
        return;
    }
    fn block_225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_225_0: read-var merge#var.1:struct
        let s_225_0: u32 = fn_state.merge_var._1;
        // D s_225_1: write-var u#34188 <= s_225_0
        fn_state.u_34188 = s_225_0;
        // C s_225_2: const #23s : i
        let s_225_2: i128 = 23;
        // D s_225_3: read-var u#34188:u32
        let s_225_3: u32 = fn_state.u_34188;
        // D s_225_4: cast zx s_225_3 -> bv
        let s_225_4: Bits = Bits::new(s_225_3 as u128, 32u16);
        // C s_225_5: const #1s : i64
        let s_225_5: i64 = 1;
        // C s_225_6: cast zx s_225_5 -> i
        let s_225_6: i128 = (i128::try_from(s_225_5).unwrap());
        // C s_225_7: const #4s : i
        let s_225_7: i128 = 4;
        // C s_225_8: add s_225_7 s_225_6
        let s_225_8: i128 = (s_225_7 + s_225_6);
        // D s_225_9: bit-extract s_225_4 s_225_2 s_225_8
        let s_225_9: Bits = (Bits::new(
            ((s_225_4) >> (s_225_2)).value(),
            u16::try_from(s_225_8).unwrap(),
        ));
        // D s_225_10: cast reint s_225_9 -> u8
        let s_225_10: u8 = (s_225_9.value() as u8);
        // D s_225_11: cast zx s_225_10 -> bv
        let s_225_11: Bits = Bits::new(s_225_10 as u128, 5u16);
        // C s_225_12: const #28u : u8
        let s_225_12: u8 = 28;
        // C s_225_13: cast zx s_225_12 -> bv
        let s_225_13: Bits = Bits::new(s_225_12 as u128, 5u16);
        // D s_225_14: cmp-eq s_225_11 s_225_13
        let s_225_14: bool = ((s_225_11) == (s_225_13));
        // N s_225_15: branch s_225_14 b892 b226
        if s_225_14 {
            return block_892(state, tracer, fn_state);
        } else {
            return block_226(state, tracer, fn_state);
        };
    }
    fn block_226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_226_0: const #0u : u8
        let s_226_0: bool = false;
        // D s_226_1: write-var gs#412781 <= s_226_0
        fn_state.gs_412781 = s_226_0;
        // N s_226_2: jump b227
        return block_227(state, tracer, fn_state);
    }
    fn block_227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_227_0: read-var gs#412781:u8
        let s_227_0: bool = fn_state.gs_412781;
        // N s_227_1: branch s_227_0 b888 b228
        if s_227_0 {
            return block_888(state, tracer, fn_state);
        } else {
            return block_228(state, tracer, fn_state);
        };
    }
    fn block_228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_228_0: const #0u : u8
        let s_228_0: bool = false;
        // D s_228_1: write-var gs#412786 <= s_228_0
        fn_state.gs_412786 = s_228_0;
        // N s_228_2: jump b229
        return block_229(state, tracer, fn_state);
    }
    fn block_229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_229_0: read-var gs#412786:u8
        let s_229_0: bool = fn_state.gs_412786;
        // D s_229_1: not s_229_0
        let s_229_1: bool = !s_229_0;
        // N s_229_2: branch s_229_1 b242 b230
        if s_229_1 {
            return block_242(state, tracer, fn_state);
        } else {
            return block_230(state, tracer, fn_state);
        };
    }
    fn block_230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_230_0: const #3544s : i
        let s_230_0: i128 = 3544;
        // C s_230_1: const #14696u : u32
        let s_230_1: u32 = 14696;
        // N s_230_2: write-reg s_230_1 <= s_230_0
        let s_230_2: () = {
            state.write_register::<i128>(s_230_1 as isize, s_230_0);
            tracer.write_register(s_230_1 as isize, s_230_0);
        };
        // C s_230_3: const #28s : i
        let s_230_3: i128 = 28;
        // C s_230_4: const #4s : i
        let s_230_4: i128 = 4;
        // D s_230_5: read-var u#34188:u32
        let s_230_5: u32 = fn_state.u_34188;
        // D s_230_6: cast zx s_230_5 -> bv
        let s_230_6: Bits = Bits::new(s_230_5 as u128, 32u16);
        // D s_230_7: bit-extract s_230_6 s_230_3 s_230_4
        let s_230_7: Bits = (Bits::new(
            ((s_230_6) >> (s_230_3)).value(),
            u16::try_from(s_230_4).unwrap(),
        ));
        // D s_230_8: cast reint s_230_7 -> u8
        let s_230_8: u8 = (s_230_7.value() as u8);
        // D s_230_9: write-var u#34189 <= s_230_8
        fn_state.u_34189 = s_230_8;
        // C s_230_10: const #21s : i
        let s_230_10: i128 = 21;
        // C s_230_11: const #2s : i
        let s_230_11: i128 = 2;
        // D s_230_12: read-var u#34188:u32
        let s_230_12: u32 = fn_state.u_34188;
        // D s_230_13: cast zx s_230_12 -> bv
        let s_230_13: Bits = Bits::new(s_230_12 as u128, 32u16);
        // D s_230_14: bit-extract s_230_13 s_230_10 s_230_11
        let s_230_14: Bits = (Bits::new(
            ((s_230_13) >> (s_230_10)).value(),
            u16::try_from(s_230_11).unwrap(),
        ));
        // D s_230_15: cast reint s_230_14 -> u8
        let s_230_15: u8 = (s_230_14.value() as u8);
        // D s_230_16: write-var u#34190 <= s_230_15
        fn_state.u_34190 = s_230_15;
        // C s_230_17: const #16s : i
        let s_230_17: i128 = 16;
        // C s_230_18: const #4s : i
        let s_230_18: i128 = 4;
        // D s_230_19: read-var u#34188:u32
        let s_230_19: u32 = fn_state.u_34188;
        // D s_230_20: cast zx s_230_19 -> bv
        let s_230_20: Bits = Bits::new(s_230_19 as u128, 32u16);
        // D s_230_21: bit-extract s_230_20 s_230_17 s_230_18
        let s_230_21: Bits = (Bits::new(
            ((s_230_20) >> (s_230_17)).value(),
            u16::try_from(s_230_18).unwrap(),
        ));
        // D s_230_22: cast reint s_230_21 -> u8
        let s_230_22: u8 = (s_230_21.value() as u8);
        // D s_230_23: write-var u#34191 <= s_230_22
        fn_state.u_34191 = s_230_22;
        // C s_230_24: const #12s : i
        let s_230_24: i128 = 12;
        // C s_230_25: const #4s : i
        let s_230_25: i128 = 4;
        // D s_230_26: read-var u#34188:u32
        let s_230_26: u32 = fn_state.u_34188;
        // D s_230_27: cast zx s_230_26 -> bv
        let s_230_27: Bits = Bits::new(s_230_26 as u128, 32u16);
        // D s_230_28: bit-extract s_230_27 s_230_24 s_230_25
        let s_230_28: Bits = (Bits::new(
            ((s_230_27) >> (s_230_24)).value(),
            u16::try_from(s_230_25).unwrap(),
        ));
        // D s_230_29: cast reint s_230_28 -> u8
        let s_230_29: u8 = (s_230_28.value() as u8);
        // D s_230_30: write-var u#34192 <= s_230_29
        fn_state.u_34192 = s_230_29;
        // C s_230_31: const #7s : i
        let s_230_31: i128 = 7;
        // C s_230_32: const #1s : i
        let s_230_32: i128 = 1;
        // D s_230_33: read-var u#34188:u32
        let s_230_33: u32 = fn_state.u_34188;
        // D s_230_34: cast zx s_230_33 -> bv
        let s_230_34: Bits = Bits::new(s_230_33 as u128, 32u16);
        // D s_230_35: bit-extract s_230_34 s_230_31 s_230_32
        let s_230_35: Bits = (Bits::new(
            ((s_230_34) >> (s_230_31)).value(),
            u16::try_from(s_230_32).unwrap(),
        ));
        // D s_230_36: cast reint s_230_35 -> u8
        let s_230_36: bool = ((s_230_35.value()) != 0);
        // D s_230_37: write-var u#34193 <= s_230_36
        fn_state.u_34193 = s_230_36;
        // C s_230_38: const #5s : i
        let s_230_38: i128 = 5;
        // C s_230_39: const #2s : i
        let s_230_39: i128 = 2;
        // D s_230_40: read-var u#34188:u32
        let s_230_40: u32 = fn_state.u_34188;
        // D s_230_41: cast zx s_230_40 -> bv
        let s_230_41: Bits = Bits::new(s_230_40 as u128, 32u16);
        // D s_230_42: bit-extract s_230_41 s_230_38 s_230_39
        let s_230_42: Bits = (Bits::new(
            ((s_230_41) >> (s_230_38)).value(),
            u16::try_from(s_230_39).unwrap(),
        ));
        // D s_230_43: cast reint s_230_42 -> u8
        let s_230_43: u8 = (s_230_42.value() as u8);
        // D s_230_44: write-var u#34194 <= s_230_43
        fn_state.u_34194 = s_230_43;
        // C s_230_45: const #0s : i
        let s_230_45: i128 = 0;
        // D s_230_46: read-var u#34188:u32
        let s_230_46: u32 = fn_state.u_34188;
        // D s_230_47: cast zx s_230_46 -> bv
        let s_230_47: Bits = Bits::new(s_230_46 as u128, 32u16);
        // C s_230_48: const #1u : u64
        let s_230_48: u64 = 1;
        // D s_230_49: bit-extract s_230_47 s_230_45 s_230_48
        let s_230_49: Bits = (Bits::new(
            ((s_230_47) >> (s_230_45)).value(),
            u16::try_from(s_230_48).unwrap(),
        ));
        // D s_230_50: cast reint s_230_49 -> u8
        let s_230_50: bool = ((s_230_49.value()) != 0);
        // C s_230_51: const #0s : i
        let s_230_51: i128 = 0;
        // C s_230_52: const #0u : u64
        let s_230_52: u64 = 0;
        // D s_230_53: cast zx s_230_50 -> u64
        let s_230_53: u64 = (s_230_50 as u64);
        // C s_230_54: const #1u : u64
        let s_230_54: u64 = 1;
        // D s_230_55: and s_230_53 s_230_54
        let s_230_55: u64 = ((s_230_53) & (s_230_54));
        // D s_230_56: cmp-eq s_230_55 s_230_54
        let s_230_56: bool = ((s_230_55) == (s_230_54));
        // D s_230_57: lsl s_230_53 s_230_51
        let s_230_57: u64 = s_230_53 << s_230_51;
        // D s_230_58: or s_230_52 s_230_57
        let s_230_58: u64 = ((s_230_52) | (s_230_57));
        // D s_230_59: cmpl s_230_57
        let s_230_59: u64 = !s_230_57;
        // D s_230_60: and s_230_52 s_230_59
        let s_230_60: u64 = ((s_230_52) & (s_230_59));
        // D s_230_61: select s_230_56 s_230_58 s_230_60
        let s_230_61: u64 = if s_230_56 { s_230_58 } else { s_230_60 };
        // D s_230_62: cast trunc s_230_61 -> u8
        let s_230_62: bool = ((s_230_61) != 0);
        // D s_230_63: cast zx s_230_62 -> bv
        let s_230_63: Bits = Bits::new(s_230_62 as u128, 1u16);
        // C s_230_64: const #0u : u8
        let s_230_64: bool = false;
        // C s_230_65: cast zx s_230_64 -> bv
        let s_230_65: Bits = Bits::new(s_230_64 as u128, 1u16);
        // D s_230_66: cmp-ne s_230_63 s_230_65
        let s_230_66: bool = ((s_230_63) != (s_230_65));
        // N s_230_67: branch s_230_66 b241 b231
        if s_230_66 {
            return block_241(state, tracer, fn_state);
        } else {
            return block_231(state, tracer, fn_state);
        };
    }
    fn block_231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_231_0: const #1s : i
        let s_231_0: i128 = 1;
        // D s_231_1: read-var u#34188:u32
        let s_231_1: u32 = fn_state.u_34188;
        // D s_231_2: cast zx s_231_1 -> bv
        let s_231_2: Bits = Bits::new(s_231_1 as u128, 32u16);
        // C s_231_3: const #1u : u64
        let s_231_3: u64 = 1;
        // D s_231_4: bit-extract s_231_2 s_231_0 s_231_3
        let s_231_4: Bits = (Bits::new(
            ((s_231_2) >> (s_231_0)).value(),
            u16::try_from(s_231_3).unwrap(),
        ));
        // D s_231_5: cast reint s_231_4 -> u8
        let s_231_5: bool = ((s_231_4.value()) != 0);
        // C s_231_6: const #0s : i
        let s_231_6: i128 = 0;
        // C s_231_7: const #0u : u64
        let s_231_7: u64 = 0;
        // D s_231_8: cast zx s_231_5 -> u64
        let s_231_8: u64 = (s_231_5 as u64);
        // C s_231_9: const #1u : u64
        let s_231_9: u64 = 1;
        // D s_231_10: and s_231_8 s_231_9
        let s_231_10: u64 = ((s_231_8) & (s_231_9));
        // D s_231_11: cmp-eq s_231_10 s_231_9
        let s_231_11: bool = ((s_231_10) == (s_231_9));
        // D s_231_12: lsl s_231_8 s_231_6
        let s_231_12: u64 = s_231_8 << s_231_6;
        // D s_231_13: or s_231_7 s_231_12
        let s_231_13: u64 = ((s_231_7) | (s_231_12));
        // D s_231_14: cmpl s_231_12
        let s_231_14: u64 = !s_231_12;
        // D s_231_15: and s_231_7 s_231_14
        let s_231_15: u64 = ((s_231_7) & (s_231_14));
        // D s_231_16: select s_231_11 s_231_13 s_231_15
        let s_231_16: u64 = if s_231_11 { s_231_13 } else { s_231_15 };
        // D s_231_17: cast trunc s_231_16 -> u8
        let s_231_17: bool = ((s_231_16) != 0);
        // D s_231_18: cast zx s_231_17 -> bv
        let s_231_18: Bits = Bits::new(s_231_17 as u128, 1u16);
        // C s_231_19: const #0u : u8
        let s_231_19: bool = false;
        // C s_231_20: cast zx s_231_19 -> bv
        let s_231_20: Bits = Bits::new(s_231_19 as u128, 1u16);
        // D s_231_21: cmp-ne s_231_18 s_231_20
        let s_231_21: bool = ((s_231_18) != (s_231_20));
        // D s_231_22: write-var gs#412805 <= s_231_21
        fn_state.gs_412805 = s_231_21;
        // N s_231_23: jump b232
        return block_232(state, tracer, fn_state);
    }
    fn block_232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_232_0: read-var gs#412805:u8
        let s_232_0: bool = fn_state.gs_412805;
        // N s_232_1: branch s_232_0 b240 b233
        if s_232_0 {
            return block_240(state, tracer, fn_state);
        } else {
            return block_233(state, tracer, fn_state);
        };
    }
    fn block_233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_233_0: const #2s : i
        let s_233_0: i128 = 2;
        // D s_233_1: read-var u#34188:u32
        let s_233_1: u32 = fn_state.u_34188;
        // D s_233_2: cast zx s_233_1 -> bv
        let s_233_2: Bits = Bits::new(s_233_1 as u128, 32u16);
        // C s_233_3: const #1u : u64
        let s_233_3: u64 = 1;
        // D s_233_4: bit-extract s_233_2 s_233_0 s_233_3
        let s_233_4: Bits = (Bits::new(
            ((s_233_2) >> (s_233_0)).value(),
            u16::try_from(s_233_3).unwrap(),
        ));
        // D s_233_5: cast reint s_233_4 -> u8
        let s_233_5: bool = ((s_233_4.value()) != 0);
        // C s_233_6: const #0s : i
        let s_233_6: i128 = 0;
        // C s_233_7: const #0u : u64
        let s_233_7: u64 = 0;
        // D s_233_8: cast zx s_233_5 -> u64
        let s_233_8: u64 = (s_233_5 as u64);
        // C s_233_9: const #1u : u64
        let s_233_9: u64 = 1;
        // D s_233_10: and s_233_8 s_233_9
        let s_233_10: u64 = ((s_233_8) & (s_233_9));
        // D s_233_11: cmp-eq s_233_10 s_233_9
        let s_233_11: bool = ((s_233_10) == (s_233_9));
        // D s_233_12: lsl s_233_8 s_233_6
        let s_233_12: u64 = s_233_8 << s_233_6;
        // D s_233_13: or s_233_7 s_233_12
        let s_233_13: u64 = ((s_233_7) | (s_233_12));
        // D s_233_14: cmpl s_233_12
        let s_233_14: u64 = !s_233_12;
        // D s_233_15: and s_233_7 s_233_14
        let s_233_15: u64 = ((s_233_7) & (s_233_14));
        // D s_233_16: select s_233_11 s_233_13 s_233_15
        let s_233_16: u64 = if s_233_11 { s_233_13 } else { s_233_15 };
        // D s_233_17: cast trunc s_233_16 -> u8
        let s_233_17: bool = ((s_233_16) != 0);
        // D s_233_18: cast zx s_233_17 -> bv
        let s_233_18: Bits = Bits::new(s_233_17 as u128, 1u16);
        // C s_233_19: const #0u : u8
        let s_233_19: bool = false;
        // C s_233_20: cast zx s_233_19 -> bv
        let s_233_20: Bits = Bits::new(s_233_19 as u128, 1u16);
        // D s_233_21: cmp-ne s_233_18 s_233_20
        let s_233_21: bool = ((s_233_18) != (s_233_20));
        // D s_233_22: write-var gs#412808 <= s_233_21
        fn_state.gs_412808 = s_233_21;
        // N s_233_23: jump b234
        return block_234(state, tracer, fn_state);
    }
    fn block_234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_234_0: read-var gs#412808:u8
        let s_234_0: bool = fn_state.gs_412808;
        // N s_234_1: branch s_234_0 b239 b235
        if s_234_0 {
            return block_239(state, tracer, fn_state);
        } else {
            return block_235(state, tracer, fn_state);
        };
    }
    fn block_235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_235_0: const #3s : i
        let s_235_0: i128 = 3;
        // D s_235_1: read-var u#34188:u32
        let s_235_1: u32 = fn_state.u_34188;
        // D s_235_2: cast zx s_235_1 -> bv
        let s_235_2: Bits = Bits::new(s_235_1 as u128, 32u16);
        // C s_235_3: const #1u : u64
        let s_235_3: u64 = 1;
        // D s_235_4: bit-extract s_235_2 s_235_0 s_235_3
        let s_235_4: Bits = (Bits::new(
            ((s_235_2) >> (s_235_0)).value(),
            u16::try_from(s_235_3).unwrap(),
        ));
        // D s_235_5: cast reint s_235_4 -> u8
        let s_235_5: bool = ((s_235_4.value()) != 0);
        // C s_235_6: const #0s : i
        let s_235_6: i128 = 0;
        // C s_235_7: const #0u : u64
        let s_235_7: u64 = 0;
        // D s_235_8: cast zx s_235_5 -> u64
        let s_235_8: u64 = (s_235_5 as u64);
        // C s_235_9: const #1u : u64
        let s_235_9: u64 = 1;
        // D s_235_10: and s_235_8 s_235_9
        let s_235_10: u64 = ((s_235_8) & (s_235_9));
        // D s_235_11: cmp-eq s_235_10 s_235_9
        let s_235_11: bool = ((s_235_10) == (s_235_9));
        // D s_235_12: lsl s_235_8 s_235_6
        let s_235_12: u64 = s_235_8 << s_235_6;
        // D s_235_13: or s_235_7 s_235_12
        let s_235_13: u64 = ((s_235_7) | (s_235_12));
        // D s_235_14: cmpl s_235_12
        let s_235_14: u64 = !s_235_12;
        // D s_235_15: and s_235_7 s_235_14
        let s_235_15: u64 = ((s_235_7) & (s_235_14));
        // D s_235_16: select s_235_11 s_235_13 s_235_15
        let s_235_16: u64 = if s_235_11 { s_235_13 } else { s_235_15 };
        // D s_235_17: cast trunc s_235_16 -> u8
        let s_235_17: bool = ((s_235_16) != 0);
        // D s_235_18: cast zx s_235_17 -> bv
        let s_235_18: Bits = Bits::new(s_235_17 as u128, 1u16);
        // C s_235_19: const #0u : u8
        let s_235_19: bool = false;
        // C s_235_20: cast zx s_235_19 -> bv
        let s_235_20: Bits = Bits::new(s_235_19 as u128, 1u16);
        // D s_235_21: cmp-ne s_235_18 s_235_20
        let s_235_21: bool = ((s_235_18) != (s_235_20));
        // D s_235_22: write-var gs#412811 <= s_235_21
        fn_state.gs_412811 = s_235_21;
        // N s_235_23: jump b236
        return block_236(state, tracer, fn_state);
    }
    fn block_236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_236_0: read-var gs#412811:u8
        let s_236_0: bool = fn_state.gs_412811;
        // N s_236_1: branch s_236_0 b238 b237
        if s_236_0 {
            return block_238(state, tracer, fn_state);
        } else {
            return block_237(state, tracer, fn_state);
        };
    }
    fn block_237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_237_0: read-var u#34189:u8
        let s_237_0: u8 = fn_state.u_34189;
        // D s_237_1: read-var u#34190:u8
        let s_237_1: u8 = fn_state.u_34190;
        // D s_237_2: read-var u#34191:u8
        let s_237_2: u8 = fn_state.u_34191;
        // D s_237_3: read-var u#34192:u8
        let s_237_3: u8 = fn_state.u_34192;
        // D s_237_4: read-var u#34193:u8
        let s_237_4: bool = fn_state.u_34193;
        // D s_237_5: read-var u#34194:u8
        let s_237_5: u8 = fn_state.u_34194;
        // D s_237_6: call decode_aarch32_instrs_VMOV_rs_A1enc_A_txt(s_237_0, s_237_1, s_237_2, s_237_3, s_237_4, s_237_5)
        let s_237_6: () = decode_aarch32_instrs_VMOV_rs_A1enc_A_txt(
            state,
            tracer,
            s_237_0,
            s_237_1,
            s_237_2,
            s_237_3,
            s_237_4,
            s_237_5,
        );
        // N s_237_7: return
        return;
    }
    fn block_238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_238_0: panic
        panic!("{:?}", ());
        // N s_238_1: return
        return;
    }
    fn block_239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_239_0: const #1u : u8
        let s_239_0: bool = true;
        // D s_239_1: write-var gs#412811 <= s_239_0
        fn_state.gs_412811 = s_239_0;
        // N s_239_2: jump b236
        return block_236(state, tracer, fn_state);
    }
    fn block_240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_240_0: const #1u : u8
        let s_240_0: bool = true;
        // D s_240_1: write-var gs#412808 <= s_240_0
        fn_state.gs_412808 = s_240_0;
        // N s_240_2: jump b234
        return block_234(state, tracer, fn_state);
    }
    fn block_241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_241_0: const #1u : u8
        let s_241_0: bool = true;
        // D s_241_1: write-var gs#412805 <= s_241_0
        fn_state.gs_412805 = s_241_0;
        // N s_241_2: jump b232
        return block_232(state, tracer, fn_state);
    }
    fn block_242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_242_0: read-var merge#var.1:struct
        let s_242_0: u32 = fn_state.merge_var._1;
        // D s_242_1: write-var u#34196 <= s_242_0
        fn_state.u_34196 = s_242_0;
        // C s_242_2: const #21s : i
        let s_242_2: i128 = 21;
        // D s_242_3: read-var u#34196:u32
        let s_242_3: u32 = fn_state.u_34196;
        // D s_242_4: cast zx s_242_3 -> bv
        let s_242_4: Bits = Bits::new(s_242_3 as u128, 32u16);
        // C s_242_5: const #1s : i64
        let s_242_5: i64 = 1;
        // C s_242_6: cast zx s_242_5 -> i
        let s_242_6: i128 = (i128::try_from(s_242_5).unwrap());
        // C s_242_7: const #6s : i
        let s_242_7: i128 = 6;
        // C s_242_8: add s_242_7 s_242_6
        let s_242_8: i128 = (s_242_7 + s_242_6);
        // D s_242_9: bit-extract s_242_4 s_242_2 s_242_8
        let s_242_9: Bits = (Bits::new(
            ((s_242_4) >> (s_242_2)).value(),
            u16::try_from(s_242_8).unwrap(),
        ));
        // D s_242_10: cast reint s_242_9 -> u8
        let s_242_10: u8 = (s_242_9.value() as u8);
        // D s_242_11: cast zx s_242_10 -> bv
        let s_242_11: Bits = Bits::new(s_242_10 as u128, 7u16);
        // C s_242_12: const #112u : u8
        let s_242_12: u8 = 112;
        // C s_242_13: cast zx s_242_12 -> bv
        let s_242_13: Bits = Bits::new(s_242_12 as u128, 7u16);
        // D s_242_14: cmp-eq s_242_11 s_242_13
        let s_242_14: bool = ((s_242_11) == (s_242_13));
        // N s_242_15: branch s_242_14 b884 b243
        if s_242_14 {
            return block_884(state, tracer, fn_state);
        } else {
            return block_243(state, tracer, fn_state);
        };
    }
    fn block_243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_243_0: const #0u : u8
        let s_243_0: bool = false;
        // D s_243_1: write-var gs#412820 <= s_243_0
        fn_state.gs_412820 = s_243_0;
        // N s_243_2: jump b244
        return block_244(state, tracer, fn_state);
    }
    fn block_244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_244_0: read-var gs#412820:u8
        let s_244_0: bool = fn_state.gs_412820;
        // N s_244_1: branch s_244_0 b880 b245
        if s_244_0 {
            return block_880(state, tracer, fn_state);
        } else {
            return block_245(state, tracer, fn_state);
        };
    }
    fn block_245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_245_0: const #0u : u8
        let s_245_0: bool = false;
        // D s_245_1: write-var gs#412825 <= s_245_0
        fn_state.gs_412825 = s_245_0;
        // N s_245_2: jump b246
        return block_246(state, tracer, fn_state);
    }
    fn block_246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_246_0: read-var gs#412825:u8
        let s_246_0: bool = fn_state.gs_412825;
        // D s_246_1: not s_246_0
        let s_246_1: bool = !s_246_0;
        // N s_246_2: branch s_246_1 b265 b247
        if s_246_1 {
            return block_265(state, tracer, fn_state);
        } else {
            return block_247(state, tracer, fn_state);
        };
    }
    fn block_247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_247_0: const #3546s : i
        let s_247_0: i128 = 3546;
        // C s_247_1: const #14696u : u32
        let s_247_1: u32 = 14696;
        // N s_247_2: write-reg s_247_1 <= s_247_0
        let s_247_2: () = {
            state.write_register::<i128>(s_247_1 as isize, s_247_0);
            tracer.write_register(s_247_1 as isize, s_247_0);
        };
        // C s_247_3: const #28s : i
        let s_247_3: i128 = 28;
        // C s_247_4: const #4s : i
        let s_247_4: i128 = 4;
        // D s_247_5: read-var u#34196:u32
        let s_247_5: u32 = fn_state.u_34196;
        // D s_247_6: cast zx s_247_5 -> bv
        let s_247_6: Bits = Bits::new(s_247_5 as u128, 32u16);
        // D s_247_7: bit-extract s_247_6 s_247_3 s_247_4
        let s_247_7: Bits = (Bits::new(
            ((s_247_6) >> (s_247_3)).value(),
            u16::try_from(s_247_4).unwrap(),
        ));
        // D s_247_8: cast reint s_247_7 -> u8
        let s_247_8: u8 = (s_247_7.value() as u8);
        // D s_247_9: write-var u#34197 <= s_247_8
        fn_state.u_34197 = s_247_8;
        // C s_247_10: const #20s : i
        let s_247_10: i128 = 20;
        // C s_247_11: const #1s : i
        let s_247_11: i128 = 1;
        // D s_247_12: read-var u#34196:u32
        let s_247_12: u32 = fn_state.u_34196;
        // D s_247_13: cast zx s_247_12 -> bv
        let s_247_13: Bits = Bits::new(s_247_12 as u128, 32u16);
        // D s_247_14: bit-extract s_247_13 s_247_10 s_247_11
        let s_247_14: Bits = (Bits::new(
            ((s_247_13) >> (s_247_10)).value(),
            u16::try_from(s_247_11).unwrap(),
        ));
        // D s_247_15: cast reint s_247_14 -> u8
        let s_247_15: bool = ((s_247_14.value()) != 0);
        // D s_247_16: write-var u#34198 <= s_247_15
        fn_state.u_34198 = s_247_15;
        // C s_247_17: const #16s : i
        let s_247_17: i128 = 16;
        // C s_247_18: const #4s : i
        let s_247_18: i128 = 4;
        // D s_247_19: read-var u#34196:u32
        let s_247_19: u32 = fn_state.u_34196;
        // D s_247_20: cast zx s_247_19 -> bv
        let s_247_20: Bits = Bits::new(s_247_19 as u128, 32u16);
        // D s_247_21: bit-extract s_247_20 s_247_17 s_247_18
        let s_247_21: Bits = (Bits::new(
            ((s_247_20) >> (s_247_17)).value(),
            u16::try_from(s_247_18).unwrap(),
        ));
        // D s_247_22: cast reint s_247_21 -> u8
        let s_247_22: u8 = (s_247_21.value() as u8);
        // D s_247_23: write-var u#34199 <= s_247_22
        fn_state.u_34199 = s_247_22;
        // C s_247_24: const #12s : i
        let s_247_24: i128 = 12;
        // C s_247_25: const #4s : i
        let s_247_25: i128 = 4;
        // D s_247_26: read-var u#34196:u32
        let s_247_26: u32 = fn_state.u_34196;
        // D s_247_27: cast zx s_247_26 -> bv
        let s_247_27: Bits = Bits::new(s_247_26 as u128, 32u16);
        // D s_247_28: bit-extract s_247_27 s_247_24 s_247_25
        let s_247_28: Bits = (Bits::new(
            ((s_247_27) >> (s_247_24)).value(),
            u16::try_from(s_247_25).unwrap(),
        ));
        // D s_247_29: cast reint s_247_28 -> u8
        let s_247_29: u8 = (s_247_28.value() as u8);
        // D s_247_30: write-var u#34200 <= s_247_29
        fn_state.u_34200 = s_247_29;
        // C s_247_31: const #7s : i
        let s_247_31: i128 = 7;
        // C s_247_32: const #1s : i
        let s_247_32: i128 = 1;
        // D s_247_33: read-var u#34196:u32
        let s_247_33: u32 = fn_state.u_34196;
        // D s_247_34: cast zx s_247_33 -> bv
        let s_247_34: Bits = Bits::new(s_247_33 as u128, 32u16);
        // D s_247_35: bit-extract s_247_34 s_247_31 s_247_32
        let s_247_35: Bits = (Bits::new(
            ((s_247_34) >> (s_247_31)).value(),
            u16::try_from(s_247_32).unwrap(),
        ));
        // D s_247_36: cast reint s_247_35 -> u8
        let s_247_36: bool = ((s_247_35.value()) != 0);
        // D s_247_37: write-var u#34201 <= s_247_36
        fn_state.u_34201 = s_247_36;
        // C s_247_38: const #5s : i
        let s_247_38: i128 = 5;
        // D s_247_39: read-var u#34196:u32
        let s_247_39: u32 = fn_state.u_34196;
        // D s_247_40: cast zx s_247_39 -> bv
        let s_247_40: Bits = Bits::new(s_247_39 as u128, 32u16);
        // C s_247_41: const #1u : u64
        let s_247_41: u64 = 1;
        // D s_247_42: bit-extract s_247_40 s_247_38 s_247_41
        let s_247_42: Bits = (Bits::new(
            ((s_247_40) >> (s_247_38)).value(),
            u16::try_from(s_247_41).unwrap(),
        ));
        // D s_247_43: cast reint s_247_42 -> u8
        let s_247_43: bool = ((s_247_42.value()) != 0);
        // C s_247_44: const #0s : i
        let s_247_44: i128 = 0;
        // C s_247_45: const #0u : u64
        let s_247_45: u64 = 0;
        // D s_247_46: cast zx s_247_43 -> u64
        let s_247_46: u64 = (s_247_43 as u64);
        // C s_247_47: const #1u : u64
        let s_247_47: u64 = 1;
        // D s_247_48: and s_247_46 s_247_47
        let s_247_48: u64 = ((s_247_46) & (s_247_47));
        // D s_247_49: cmp-eq s_247_48 s_247_47
        let s_247_49: bool = ((s_247_48) == (s_247_47));
        // D s_247_50: lsl s_247_46 s_247_44
        let s_247_50: u64 = s_247_46 << s_247_44;
        // D s_247_51: or s_247_45 s_247_50
        let s_247_51: u64 = ((s_247_45) | (s_247_50));
        // D s_247_52: cmpl s_247_50
        let s_247_52: u64 = !s_247_50;
        // D s_247_53: and s_247_45 s_247_52
        let s_247_53: u64 = ((s_247_45) & (s_247_52));
        // D s_247_54: select s_247_49 s_247_51 s_247_53
        let s_247_54: u64 = if s_247_49 { s_247_51 } else { s_247_53 };
        // D s_247_55: cast trunc s_247_54 -> u8
        let s_247_55: bool = ((s_247_54) != 0);
        // D s_247_56: cast zx s_247_55 -> bv
        let s_247_56: Bits = Bits::new(s_247_55 as u128, 1u16);
        // C s_247_57: const #0u : u8
        let s_247_57: bool = false;
        // C s_247_58: cast zx s_247_57 -> bv
        let s_247_58: Bits = Bits::new(s_247_57 as u128, 1u16);
        // D s_247_59: cmp-ne s_247_56 s_247_58
        let s_247_59: bool = ((s_247_56) != (s_247_58));
        // N s_247_60: branch s_247_59 b264 b248
        if s_247_59 {
            return block_264(state, tracer, fn_state);
        } else {
            return block_248(state, tracer, fn_state);
        };
    }
    fn block_248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_248_0: const #6s : i
        let s_248_0: i128 = 6;
        // D s_248_1: read-var u#34196:u32
        let s_248_1: u32 = fn_state.u_34196;
        // D s_248_2: cast zx s_248_1 -> bv
        let s_248_2: Bits = Bits::new(s_248_1 as u128, 32u16);
        // C s_248_3: const #1u : u64
        let s_248_3: u64 = 1;
        // D s_248_4: bit-extract s_248_2 s_248_0 s_248_3
        let s_248_4: Bits = (Bits::new(
            ((s_248_2) >> (s_248_0)).value(),
            u16::try_from(s_248_3).unwrap(),
        ));
        // D s_248_5: cast reint s_248_4 -> u8
        let s_248_5: bool = ((s_248_4.value()) != 0);
        // C s_248_6: const #0s : i
        let s_248_6: i128 = 0;
        // C s_248_7: const #0u : u64
        let s_248_7: u64 = 0;
        // D s_248_8: cast zx s_248_5 -> u64
        let s_248_8: u64 = (s_248_5 as u64);
        // C s_248_9: const #1u : u64
        let s_248_9: u64 = 1;
        // D s_248_10: and s_248_8 s_248_9
        let s_248_10: u64 = ((s_248_8) & (s_248_9));
        // D s_248_11: cmp-eq s_248_10 s_248_9
        let s_248_11: bool = ((s_248_10) == (s_248_9));
        // D s_248_12: lsl s_248_8 s_248_6
        let s_248_12: u64 = s_248_8 << s_248_6;
        // D s_248_13: or s_248_7 s_248_12
        let s_248_13: u64 = ((s_248_7) | (s_248_12));
        // D s_248_14: cmpl s_248_12
        let s_248_14: u64 = !s_248_12;
        // D s_248_15: and s_248_7 s_248_14
        let s_248_15: u64 = ((s_248_7) & (s_248_14));
        // D s_248_16: select s_248_11 s_248_13 s_248_15
        let s_248_16: u64 = if s_248_11 { s_248_13 } else { s_248_15 };
        // D s_248_17: cast trunc s_248_16 -> u8
        let s_248_17: bool = ((s_248_16) != 0);
        // D s_248_18: cast zx s_248_17 -> bv
        let s_248_18: Bits = Bits::new(s_248_17 as u128, 1u16);
        // C s_248_19: const #0u : u8
        let s_248_19: bool = false;
        // C s_248_20: cast zx s_248_19 -> bv
        let s_248_20: Bits = Bits::new(s_248_19 as u128, 1u16);
        // D s_248_21: cmp-ne s_248_18 s_248_20
        let s_248_21: bool = ((s_248_18) != (s_248_20));
        // D s_248_22: write-var gs#412842 <= s_248_21
        fn_state.gs_412842 = s_248_21;
        // N s_248_23: jump b249
        return block_249(state, tracer, fn_state);
    }
    fn block_249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_249_0: read-var gs#412842:u8
        let s_249_0: bool = fn_state.gs_412842;
        // N s_249_1: branch s_249_0 b263 b250
        if s_249_0 {
            return block_263(state, tracer, fn_state);
        } else {
            return block_250(state, tracer, fn_state);
        };
    }
    fn block_250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_250_0: const #0s : i
        let s_250_0: i128 = 0;
        // D s_250_1: read-var u#34196:u32
        let s_250_1: u32 = fn_state.u_34196;
        // D s_250_2: cast zx s_250_1 -> bv
        let s_250_2: Bits = Bits::new(s_250_1 as u128, 32u16);
        // C s_250_3: const #1u : u64
        let s_250_3: u64 = 1;
        // D s_250_4: bit-extract s_250_2 s_250_0 s_250_3
        let s_250_4: Bits = (Bits::new(
            ((s_250_2) >> (s_250_0)).value(),
            u16::try_from(s_250_3).unwrap(),
        ));
        // D s_250_5: cast reint s_250_4 -> u8
        let s_250_5: bool = ((s_250_4.value()) != 0);
        // C s_250_6: const #0s : i
        let s_250_6: i128 = 0;
        // C s_250_7: const #0u : u64
        let s_250_7: u64 = 0;
        // D s_250_8: cast zx s_250_5 -> u64
        let s_250_8: u64 = (s_250_5 as u64);
        // C s_250_9: const #1u : u64
        let s_250_9: u64 = 1;
        // D s_250_10: and s_250_8 s_250_9
        let s_250_10: u64 = ((s_250_8) & (s_250_9));
        // D s_250_11: cmp-eq s_250_10 s_250_9
        let s_250_11: bool = ((s_250_10) == (s_250_9));
        // D s_250_12: lsl s_250_8 s_250_6
        let s_250_12: u64 = s_250_8 << s_250_6;
        // D s_250_13: or s_250_7 s_250_12
        let s_250_13: u64 = ((s_250_7) | (s_250_12));
        // D s_250_14: cmpl s_250_12
        let s_250_14: u64 = !s_250_12;
        // D s_250_15: and s_250_7 s_250_14
        let s_250_15: u64 = ((s_250_7) & (s_250_14));
        // D s_250_16: select s_250_11 s_250_13 s_250_15
        let s_250_16: u64 = if s_250_11 { s_250_13 } else { s_250_15 };
        // D s_250_17: cast trunc s_250_16 -> u8
        let s_250_17: bool = ((s_250_16) != 0);
        // D s_250_18: cast zx s_250_17 -> bv
        let s_250_18: Bits = Bits::new(s_250_17 as u128, 1u16);
        // C s_250_19: const #0u : u8
        let s_250_19: bool = false;
        // C s_250_20: cast zx s_250_19 -> bv
        let s_250_20: Bits = Bits::new(s_250_19 as u128, 1u16);
        // D s_250_21: cmp-ne s_250_18 s_250_20
        let s_250_21: bool = ((s_250_18) != (s_250_20));
        // D s_250_22: write-var gs#412845 <= s_250_21
        fn_state.gs_412845 = s_250_21;
        // N s_250_23: jump b251
        return block_251(state, tracer, fn_state);
    }
    fn block_251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_251_0: read-var gs#412845:u8
        let s_251_0: bool = fn_state.gs_412845;
        // N s_251_1: branch s_251_0 b262 b252
        if s_251_0 {
            return block_262(state, tracer, fn_state);
        } else {
            return block_252(state, tracer, fn_state);
        };
    }
    fn block_252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_252_0: const #1s : i
        let s_252_0: i128 = 1;
        // D s_252_1: read-var u#34196:u32
        let s_252_1: u32 = fn_state.u_34196;
        // D s_252_2: cast zx s_252_1 -> bv
        let s_252_2: Bits = Bits::new(s_252_1 as u128, 32u16);
        // C s_252_3: const #1u : u64
        let s_252_3: u64 = 1;
        // D s_252_4: bit-extract s_252_2 s_252_0 s_252_3
        let s_252_4: Bits = (Bits::new(
            ((s_252_2) >> (s_252_0)).value(),
            u16::try_from(s_252_3).unwrap(),
        ));
        // D s_252_5: cast reint s_252_4 -> u8
        let s_252_5: bool = ((s_252_4.value()) != 0);
        // C s_252_6: const #0s : i
        let s_252_6: i128 = 0;
        // C s_252_7: const #0u : u64
        let s_252_7: u64 = 0;
        // D s_252_8: cast zx s_252_5 -> u64
        let s_252_8: u64 = (s_252_5 as u64);
        // C s_252_9: const #1u : u64
        let s_252_9: u64 = 1;
        // D s_252_10: and s_252_8 s_252_9
        let s_252_10: u64 = ((s_252_8) & (s_252_9));
        // D s_252_11: cmp-eq s_252_10 s_252_9
        let s_252_11: bool = ((s_252_10) == (s_252_9));
        // D s_252_12: lsl s_252_8 s_252_6
        let s_252_12: u64 = s_252_8 << s_252_6;
        // D s_252_13: or s_252_7 s_252_12
        let s_252_13: u64 = ((s_252_7) | (s_252_12));
        // D s_252_14: cmpl s_252_12
        let s_252_14: u64 = !s_252_12;
        // D s_252_15: and s_252_7 s_252_14
        let s_252_15: u64 = ((s_252_7) & (s_252_14));
        // D s_252_16: select s_252_11 s_252_13 s_252_15
        let s_252_16: u64 = if s_252_11 { s_252_13 } else { s_252_15 };
        // D s_252_17: cast trunc s_252_16 -> u8
        let s_252_17: bool = ((s_252_16) != 0);
        // D s_252_18: cast zx s_252_17 -> bv
        let s_252_18: Bits = Bits::new(s_252_17 as u128, 1u16);
        // C s_252_19: const #0u : u8
        let s_252_19: bool = false;
        // C s_252_20: cast zx s_252_19 -> bv
        let s_252_20: Bits = Bits::new(s_252_19 as u128, 1u16);
        // D s_252_21: cmp-ne s_252_18 s_252_20
        let s_252_21: bool = ((s_252_18) != (s_252_20));
        // D s_252_22: write-var gs#412848 <= s_252_21
        fn_state.gs_412848 = s_252_21;
        // N s_252_23: jump b253
        return block_253(state, tracer, fn_state);
    }
    fn block_253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_253_0: read-var gs#412848:u8
        let s_253_0: bool = fn_state.gs_412848;
        // N s_253_1: branch s_253_0 b261 b254
        if s_253_0 {
            return block_261(state, tracer, fn_state);
        } else {
            return block_254(state, tracer, fn_state);
        };
    }
    fn block_254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_254_0: const #2s : i
        let s_254_0: i128 = 2;
        // D s_254_1: read-var u#34196:u32
        let s_254_1: u32 = fn_state.u_34196;
        // D s_254_2: cast zx s_254_1 -> bv
        let s_254_2: Bits = Bits::new(s_254_1 as u128, 32u16);
        // C s_254_3: const #1u : u64
        let s_254_3: u64 = 1;
        // D s_254_4: bit-extract s_254_2 s_254_0 s_254_3
        let s_254_4: Bits = (Bits::new(
            ((s_254_2) >> (s_254_0)).value(),
            u16::try_from(s_254_3).unwrap(),
        ));
        // D s_254_5: cast reint s_254_4 -> u8
        let s_254_5: bool = ((s_254_4.value()) != 0);
        // C s_254_6: const #0s : i
        let s_254_6: i128 = 0;
        // C s_254_7: const #0u : u64
        let s_254_7: u64 = 0;
        // D s_254_8: cast zx s_254_5 -> u64
        let s_254_8: u64 = (s_254_5 as u64);
        // C s_254_9: const #1u : u64
        let s_254_9: u64 = 1;
        // D s_254_10: and s_254_8 s_254_9
        let s_254_10: u64 = ((s_254_8) & (s_254_9));
        // D s_254_11: cmp-eq s_254_10 s_254_9
        let s_254_11: bool = ((s_254_10) == (s_254_9));
        // D s_254_12: lsl s_254_8 s_254_6
        let s_254_12: u64 = s_254_8 << s_254_6;
        // D s_254_13: or s_254_7 s_254_12
        let s_254_13: u64 = ((s_254_7) | (s_254_12));
        // D s_254_14: cmpl s_254_12
        let s_254_14: u64 = !s_254_12;
        // D s_254_15: and s_254_7 s_254_14
        let s_254_15: u64 = ((s_254_7) & (s_254_14));
        // D s_254_16: select s_254_11 s_254_13 s_254_15
        let s_254_16: u64 = if s_254_11 { s_254_13 } else { s_254_15 };
        // D s_254_17: cast trunc s_254_16 -> u8
        let s_254_17: bool = ((s_254_16) != 0);
        // D s_254_18: cast zx s_254_17 -> bv
        let s_254_18: Bits = Bits::new(s_254_17 as u128, 1u16);
        // C s_254_19: const #0u : u8
        let s_254_19: bool = false;
        // C s_254_20: cast zx s_254_19 -> bv
        let s_254_20: Bits = Bits::new(s_254_19 as u128, 1u16);
        // D s_254_21: cmp-ne s_254_18 s_254_20
        let s_254_21: bool = ((s_254_18) != (s_254_20));
        // D s_254_22: write-var gs#412851 <= s_254_21
        fn_state.gs_412851 = s_254_21;
        // N s_254_23: jump b255
        return block_255(state, tracer, fn_state);
    }
    fn block_255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_255_0: read-var gs#412851:u8
        let s_255_0: bool = fn_state.gs_412851;
        // N s_255_1: branch s_255_0 b260 b256
        if s_255_0 {
            return block_260(state, tracer, fn_state);
        } else {
            return block_256(state, tracer, fn_state);
        };
    }
    fn block_256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_256_0: const #3s : i
        let s_256_0: i128 = 3;
        // D s_256_1: read-var u#34196:u32
        let s_256_1: u32 = fn_state.u_34196;
        // D s_256_2: cast zx s_256_1 -> bv
        let s_256_2: Bits = Bits::new(s_256_1 as u128, 32u16);
        // C s_256_3: const #1u : u64
        let s_256_3: u64 = 1;
        // D s_256_4: bit-extract s_256_2 s_256_0 s_256_3
        let s_256_4: Bits = (Bits::new(
            ((s_256_2) >> (s_256_0)).value(),
            u16::try_from(s_256_3).unwrap(),
        ));
        // D s_256_5: cast reint s_256_4 -> u8
        let s_256_5: bool = ((s_256_4.value()) != 0);
        // C s_256_6: const #0s : i
        let s_256_6: i128 = 0;
        // C s_256_7: const #0u : u64
        let s_256_7: u64 = 0;
        // D s_256_8: cast zx s_256_5 -> u64
        let s_256_8: u64 = (s_256_5 as u64);
        // C s_256_9: const #1u : u64
        let s_256_9: u64 = 1;
        // D s_256_10: and s_256_8 s_256_9
        let s_256_10: u64 = ((s_256_8) & (s_256_9));
        // D s_256_11: cmp-eq s_256_10 s_256_9
        let s_256_11: bool = ((s_256_10) == (s_256_9));
        // D s_256_12: lsl s_256_8 s_256_6
        let s_256_12: u64 = s_256_8 << s_256_6;
        // D s_256_13: or s_256_7 s_256_12
        let s_256_13: u64 = ((s_256_7) | (s_256_12));
        // D s_256_14: cmpl s_256_12
        let s_256_14: u64 = !s_256_12;
        // D s_256_15: and s_256_7 s_256_14
        let s_256_15: u64 = ((s_256_7) & (s_256_14));
        // D s_256_16: select s_256_11 s_256_13 s_256_15
        let s_256_16: u64 = if s_256_11 { s_256_13 } else { s_256_15 };
        // D s_256_17: cast trunc s_256_16 -> u8
        let s_256_17: bool = ((s_256_16) != 0);
        // D s_256_18: cast zx s_256_17 -> bv
        let s_256_18: Bits = Bits::new(s_256_17 as u128, 1u16);
        // C s_256_19: const #0u : u8
        let s_256_19: bool = false;
        // C s_256_20: cast zx s_256_19 -> bv
        let s_256_20: Bits = Bits::new(s_256_19 as u128, 1u16);
        // D s_256_21: cmp-ne s_256_18 s_256_20
        let s_256_21: bool = ((s_256_18) != (s_256_20));
        // D s_256_22: write-var gs#412854 <= s_256_21
        fn_state.gs_412854 = s_256_21;
        // N s_256_23: jump b257
        return block_257(state, tracer, fn_state);
    }
    fn block_257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_257_0: read-var gs#412854:u8
        let s_257_0: bool = fn_state.gs_412854;
        // N s_257_1: branch s_257_0 b259 b258
        if s_257_0 {
            return block_259(state, tracer, fn_state);
        } else {
            return block_258(state, tracer, fn_state);
        };
    }
    fn block_258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_258_0: read-var u#34197:u8
        let s_258_0: u8 = fn_state.u_34197;
        // D s_258_1: read-var u#34198:u8
        let s_258_1: bool = fn_state.u_34198;
        // D s_258_2: read-var u#34199:u8
        let s_258_2: u8 = fn_state.u_34199;
        // D s_258_3: read-var u#34200:u8
        let s_258_3: u8 = fn_state.u_34200;
        // D s_258_4: read-var u#34201:u8
        let s_258_4: bool = fn_state.u_34201;
        // D s_258_5: call decode_aarch32_instrs_VMOV_s_A1enc_A_txt(s_258_0, s_258_1, s_258_2, s_258_3, s_258_4)
        let s_258_5: () = decode_aarch32_instrs_VMOV_s_A1enc_A_txt(
            state,
            tracer,
            s_258_0,
            s_258_1,
            s_258_2,
            s_258_3,
            s_258_4,
        );
        // N s_258_6: return
        return;
    }
    fn block_259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_259_0: panic
        panic!("{:?}", ());
        // N s_259_1: return
        return;
    }
    fn block_260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_260_0: const #1u : u8
        let s_260_0: bool = true;
        // D s_260_1: write-var gs#412854 <= s_260_0
        fn_state.gs_412854 = s_260_0;
        // N s_260_2: jump b257
        return block_257(state, tracer, fn_state);
    }
    fn block_261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_261_0: const #1u : u8
        let s_261_0: bool = true;
        // D s_261_1: write-var gs#412851 <= s_261_0
        fn_state.gs_412851 = s_261_0;
        // N s_261_2: jump b255
        return block_255(state, tracer, fn_state);
    }
    fn block_262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_262_0: const #1u : u8
        let s_262_0: bool = true;
        // D s_262_1: write-var gs#412848 <= s_262_0
        fn_state.gs_412848 = s_262_0;
        // N s_262_2: jump b253
        return block_253(state, tracer, fn_state);
    }
    fn block_263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_263_0: const #1u : u8
        let s_263_0: bool = true;
        // D s_263_1: write-var gs#412845 <= s_263_0
        fn_state.gs_412845 = s_263_0;
        // N s_263_2: jump b251
        return block_251(state, tracer, fn_state);
    }
    fn block_264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_264_0: const #1u : u8
        let s_264_0: bool = true;
        // D s_264_1: write-var gs#412842 <= s_264_0
        fn_state.gs_412842 = s_264_0;
        // N s_264_2: jump b249
        return block_249(state, tracer, fn_state);
    }
    fn block_265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_265_0: read-var merge#var.1:struct
        let s_265_0: u32 = fn_state.merge_var._1;
        // D s_265_1: write-var u#34203 <= s_265_0
        fn_state.u_34203 = s_265_0;
        // C s_265_2: const #24s : i
        let s_265_2: i128 = 24;
        // D s_265_3: read-var u#34203:u32
        let s_265_3: u32 = fn_state.u_34203;
        // D s_265_4: cast zx s_265_3 -> bv
        let s_265_4: Bits = Bits::new(s_265_3 as u128, 32u16);
        // C s_265_5: const #1s : i64
        let s_265_5: i64 = 1;
        // C s_265_6: cast zx s_265_5 -> i
        let s_265_6: i128 = (i128::try_from(s_265_5).unwrap());
        // C s_265_7: const #3s : i
        let s_265_7: i128 = 3;
        // C s_265_8: add s_265_7 s_265_6
        let s_265_8: i128 = (s_265_7 + s_265_6);
        // D s_265_9: bit-extract s_265_4 s_265_2 s_265_8
        let s_265_9: Bits = (Bits::new(
            ((s_265_4) >> (s_265_2)).value(),
            u16::try_from(s_265_8).unwrap(),
        ));
        // D s_265_10: cast reint s_265_9 -> u8
        let s_265_10: u8 = (s_265_9.value() as u8);
        // D s_265_11: cast zx s_265_10 -> bv
        let s_265_11: Bits = Bits::new(s_265_10 as u128, 4u16);
        // C s_265_12: const #14u : u8
        let s_265_12: u8 = 14;
        // C s_265_13: cast zx s_265_12 -> bv
        let s_265_13: Bits = Bits::new(s_265_12 as u128, 4u16);
        // D s_265_14: cmp-eq s_265_11 s_265_13
        let s_265_14: bool = ((s_265_11) == (s_265_13));
        // N s_265_15: branch s_265_14 b873 b266
        if s_265_14 {
            return block_873(state, tracer, fn_state);
        } else {
            return block_266(state, tracer, fn_state);
        };
    }
    fn block_266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_266_0: const #0u : u8
        let s_266_0: bool = false;
        // D s_266_1: write-var gs#412866 <= s_266_0
        fn_state.gs_412866 = s_266_0;
        // N s_266_2: jump b267
        return block_267(state, tracer, fn_state);
    }
    fn block_267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_267_0: read-var gs#412866:u8
        let s_267_0: bool = fn_state.gs_412866;
        // N s_267_1: branch s_267_0 b869 b268
        if s_267_0 {
            return block_869(state, tracer, fn_state);
        } else {
            return block_268(state, tracer, fn_state);
        };
    }
    fn block_268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_268_0: const #0u : u8
        let s_268_0: bool = false;
        // D s_268_1: write-var gs#412871 <= s_268_0
        fn_state.gs_412871 = s_268_0;
        // N s_268_2: jump b269
        return block_269(state, tracer, fn_state);
    }
    fn block_269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_269_0: read-var gs#412871:u8
        let s_269_0: bool = fn_state.gs_412871;
        // D s_269_1: not s_269_0
        let s_269_1: bool = !s_269_0;
        // N s_269_2: branch s_269_1 b282 b270
        if s_269_1 {
            return block_282(state, tracer, fn_state);
        } else {
            return block_270(state, tracer, fn_state);
        };
    }
    fn block_270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_270_0: const #3548s : i
        let s_270_0: i128 = 3548;
        // C s_270_1: const #14696u : u32
        let s_270_1: u32 = 14696;
        // N s_270_2: write-reg s_270_1 <= s_270_0
        let s_270_2: () = {
            state.write_register::<i128>(s_270_1 as isize, s_270_0);
            tracer.write_register(s_270_1 as isize, s_270_0);
        };
        // C s_270_3: const #28s : i
        let s_270_3: i128 = 28;
        // C s_270_4: const #4s : i
        let s_270_4: i128 = 4;
        // D s_270_5: read-var u#34203:u32
        let s_270_5: u32 = fn_state.u_34203;
        // D s_270_6: cast zx s_270_5 -> bv
        let s_270_6: Bits = Bits::new(s_270_5 as u128, 32u16);
        // D s_270_7: bit-extract s_270_6 s_270_3 s_270_4
        let s_270_7: Bits = (Bits::new(
            ((s_270_6) >> (s_270_3)).value(),
            u16::try_from(s_270_4).unwrap(),
        ));
        // D s_270_8: cast reint s_270_7 -> u8
        let s_270_8: u8 = (s_270_7.value() as u8);
        // D s_270_9: write-var u#34204 <= s_270_8
        fn_state.u_34204 = s_270_8;
        // C s_270_10: const #23s : i
        let s_270_10: i128 = 23;
        // C s_270_11: const #1s : i
        let s_270_11: i128 = 1;
        // D s_270_12: read-var u#34203:u32
        let s_270_12: u32 = fn_state.u_34203;
        // D s_270_13: cast zx s_270_12 -> bv
        let s_270_13: Bits = Bits::new(s_270_12 as u128, 32u16);
        // D s_270_14: bit-extract s_270_13 s_270_10 s_270_11
        let s_270_14: Bits = (Bits::new(
            ((s_270_13) >> (s_270_10)).value(),
            u16::try_from(s_270_11).unwrap(),
        ));
        // D s_270_15: cast reint s_270_14 -> u8
        let s_270_15: bool = ((s_270_14.value()) != 0);
        // D s_270_16: write-var u#34205 <= s_270_15
        fn_state.u_34205 = s_270_15;
        // C s_270_17: const #21s : i
        let s_270_17: i128 = 21;
        // C s_270_18: const #2s : i
        let s_270_18: i128 = 2;
        // D s_270_19: read-var u#34203:u32
        let s_270_19: u32 = fn_state.u_34203;
        // D s_270_20: cast zx s_270_19 -> bv
        let s_270_20: Bits = Bits::new(s_270_19 as u128, 32u16);
        // D s_270_21: bit-extract s_270_20 s_270_17 s_270_18
        let s_270_21: Bits = (Bits::new(
            ((s_270_20) >> (s_270_17)).value(),
            u16::try_from(s_270_18).unwrap(),
        ));
        // D s_270_22: cast reint s_270_21 -> u8
        let s_270_22: u8 = (s_270_21.value() as u8);
        // D s_270_23: write-var u#34206 <= s_270_22
        fn_state.u_34206 = s_270_22;
        // C s_270_24: const #16s : i
        let s_270_24: i128 = 16;
        // C s_270_25: const #4s : i
        let s_270_25: i128 = 4;
        // D s_270_26: read-var u#34203:u32
        let s_270_26: u32 = fn_state.u_34203;
        // D s_270_27: cast zx s_270_26 -> bv
        let s_270_27: Bits = Bits::new(s_270_26 as u128, 32u16);
        // D s_270_28: bit-extract s_270_27 s_270_24 s_270_25
        let s_270_28: Bits = (Bits::new(
            ((s_270_27) >> (s_270_24)).value(),
            u16::try_from(s_270_25).unwrap(),
        ));
        // D s_270_29: cast reint s_270_28 -> u8
        let s_270_29: u8 = (s_270_28.value() as u8);
        // D s_270_30: write-var u#34207 <= s_270_29
        fn_state.u_34207 = s_270_29;
        // C s_270_31: const #12s : i
        let s_270_31: i128 = 12;
        // C s_270_32: const #4s : i
        let s_270_32: i128 = 4;
        // D s_270_33: read-var u#34203:u32
        let s_270_33: u32 = fn_state.u_34203;
        // D s_270_34: cast zx s_270_33 -> bv
        let s_270_34: Bits = Bits::new(s_270_33 as u128, 32u16);
        // D s_270_35: bit-extract s_270_34 s_270_31 s_270_32
        let s_270_35: Bits = (Bits::new(
            ((s_270_34) >> (s_270_31)).value(),
            u16::try_from(s_270_32).unwrap(),
        ));
        // D s_270_36: cast reint s_270_35 -> u8
        let s_270_36: u8 = (s_270_35.value() as u8);
        // D s_270_37: write-var u#34208 <= s_270_36
        fn_state.u_34208 = s_270_36;
        // C s_270_38: const #7s : i
        let s_270_38: i128 = 7;
        // C s_270_39: const #1s : i
        let s_270_39: i128 = 1;
        // D s_270_40: read-var u#34203:u32
        let s_270_40: u32 = fn_state.u_34203;
        // D s_270_41: cast zx s_270_40 -> bv
        let s_270_41: Bits = Bits::new(s_270_40 as u128, 32u16);
        // D s_270_42: bit-extract s_270_41 s_270_38 s_270_39
        let s_270_42: Bits = (Bits::new(
            ((s_270_41) >> (s_270_38)).value(),
            u16::try_from(s_270_39).unwrap(),
        ));
        // D s_270_43: cast reint s_270_42 -> u8
        let s_270_43: bool = ((s_270_42.value()) != 0);
        // D s_270_44: write-var u#34209 <= s_270_43
        fn_state.u_34209 = s_270_43;
        // C s_270_45: const #5s : i
        let s_270_45: i128 = 5;
        // C s_270_46: const #2s : i
        let s_270_46: i128 = 2;
        // D s_270_47: read-var u#34203:u32
        let s_270_47: u32 = fn_state.u_34203;
        // D s_270_48: cast zx s_270_47 -> bv
        let s_270_48: Bits = Bits::new(s_270_47 as u128, 32u16);
        // D s_270_49: bit-extract s_270_48 s_270_45 s_270_46
        let s_270_49: Bits = (Bits::new(
            ((s_270_48) >> (s_270_45)).value(),
            u16::try_from(s_270_46).unwrap(),
        ));
        // D s_270_50: cast reint s_270_49 -> u8
        let s_270_50: u8 = (s_270_49.value() as u8);
        // D s_270_51: write-var u#34210 <= s_270_50
        fn_state.u_34210 = s_270_50;
        // C s_270_52: const #0s : i
        let s_270_52: i128 = 0;
        // D s_270_53: read-var u#34203:u32
        let s_270_53: u32 = fn_state.u_34203;
        // D s_270_54: cast zx s_270_53 -> bv
        let s_270_54: Bits = Bits::new(s_270_53 as u128, 32u16);
        // C s_270_55: const #1u : u64
        let s_270_55: u64 = 1;
        // D s_270_56: bit-extract s_270_54 s_270_52 s_270_55
        let s_270_56: Bits = (Bits::new(
            ((s_270_54) >> (s_270_52)).value(),
            u16::try_from(s_270_55).unwrap(),
        ));
        // D s_270_57: cast reint s_270_56 -> u8
        let s_270_57: bool = ((s_270_56.value()) != 0);
        // C s_270_58: const #0s : i
        let s_270_58: i128 = 0;
        // C s_270_59: const #0u : u64
        let s_270_59: u64 = 0;
        // D s_270_60: cast zx s_270_57 -> u64
        let s_270_60: u64 = (s_270_57 as u64);
        // C s_270_61: const #1u : u64
        let s_270_61: u64 = 1;
        // D s_270_62: and s_270_60 s_270_61
        let s_270_62: u64 = ((s_270_60) & (s_270_61));
        // D s_270_63: cmp-eq s_270_62 s_270_61
        let s_270_63: bool = ((s_270_62) == (s_270_61));
        // D s_270_64: lsl s_270_60 s_270_58
        let s_270_64: u64 = s_270_60 << s_270_58;
        // D s_270_65: or s_270_59 s_270_64
        let s_270_65: u64 = ((s_270_59) | (s_270_64));
        // D s_270_66: cmpl s_270_64
        let s_270_66: u64 = !s_270_64;
        // D s_270_67: and s_270_59 s_270_66
        let s_270_67: u64 = ((s_270_59) & (s_270_66));
        // D s_270_68: select s_270_63 s_270_65 s_270_67
        let s_270_68: u64 = if s_270_63 { s_270_65 } else { s_270_67 };
        // D s_270_69: cast trunc s_270_68 -> u8
        let s_270_69: bool = ((s_270_68) != 0);
        // D s_270_70: cast zx s_270_69 -> bv
        let s_270_70: Bits = Bits::new(s_270_69 as u128, 1u16);
        // C s_270_71: const #0u : u8
        let s_270_71: bool = false;
        // C s_270_72: cast zx s_270_71 -> bv
        let s_270_72: Bits = Bits::new(s_270_71 as u128, 1u16);
        // D s_270_73: cmp-ne s_270_70 s_270_72
        let s_270_73: bool = ((s_270_70) != (s_270_72));
        // N s_270_74: branch s_270_73 b281 b271
        if s_270_73 {
            return block_281(state, tracer, fn_state);
        } else {
            return block_271(state, tracer, fn_state);
        };
    }
    fn block_271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_271_0: const #1s : i
        let s_271_0: i128 = 1;
        // D s_271_1: read-var u#34203:u32
        let s_271_1: u32 = fn_state.u_34203;
        // D s_271_2: cast zx s_271_1 -> bv
        let s_271_2: Bits = Bits::new(s_271_1 as u128, 32u16);
        // C s_271_3: const #1u : u64
        let s_271_3: u64 = 1;
        // D s_271_4: bit-extract s_271_2 s_271_0 s_271_3
        let s_271_4: Bits = (Bits::new(
            ((s_271_2) >> (s_271_0)).value(),
            u16::try_from(s_271_3).unwrap(),
        ));
        // D s_271_5: cast reint s_271_4 -> u8
        let s_271_5: bool = ((s_271_4.value()) != 0);
        // C s_271_6: const #0s : i
        let s_271_6: i128 = 0;
        // C s_271_7: const #0u : u64
        let s_271_7: u64 = 0;
        // D s_271_8: cast zx s_271_5 -> u64
        let s_271_8: u64 = (s_271_5 as u64);
        // C s_271_9: const #1u : u64
        let s_271_9: u64 = 1;
        // D s_271_10: and s_271_8 s_271_9
        let s_271_10: u64 = ((s_271_8) & (s_271_9));
        // D s_271_11: cmp-eq s_271_10 s_271_9
        let s_271_11: bool = ((s_271_10) == (s_271_9));
        // D s_271_12: lsl s_271_8 s_271_6
        let s_271_12: u64 = s_271_8 << s_271_6;
        // D s_271_13: or s_271_7 s_271_12
        let s_271_13: u64 = ((s_271_7) | (s_271_12));
        // D s_271_14: cmpl s_271_12
        let s_271_14: u64 = !s_271_12;
        // D s_271_15: and s_271_7 s_271_14
        let s_271_15: u64 = ((s_271_7) & (s_271_14));
        // D s_271_16: select s_271_11 s_271_13 s_271_15
        let s_271_16: u64 = if s_271_11 { s_271_13 } else { s_271_15 };
        // D s_271_17: cast trunc s_271_16 -> u8
        let s_271_17: bool = ((s_271_16) != 0);
        // D s_271_18: cast zx s_271_17 -> bv
        let s_271_18: Bits = Bits::new(s_271_17 as u128, 1u16);
        // C s_271_19: const #0u : u8
        let s_271_19: bool = false;
        // C s_271_20: cast zx s_271_19 -> bv
        let s_271_20: Bits = Bits::new(s_271_19 as u128, 1u16);
        // D s_271_21: cmp-ne s_271_18 s_271_20
        let s_271_21: bool = ((s_271_18) != (s_271_20));
        // D s_271_22: write-var gs#412892 <= s_271_21
        fn_state.gs_412892 = s_271_21;
        // N s_271_23: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_272_0: read-var gs#412892:u8
        let s_272_0: bool = fn_state.gs_412892;
        // N s_272_1: branch s_272_0 b280 b273
        if s_272_0 {
            return block_280(state, tracer, fn_state);
        } else {
            return block_273(state, tracer, fn_state);
        };
    }
    fn block_273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_273_0: const #2s : i
        let s_273_0: i128 = 2;
        // D s_273_1: read-var u#34203:u32
        let s_273_1: u32 = fn_state.u_34203;
        // D s_273_2: cast zx s_273_1 -> bv
        let s_273_2: Bits = Bits::new(s_273_1 as u128, 32u16);
        // C s_273_3: const #1u : u64
        let s_273_3: u64 = 1;
        // D s_273_4: bit-extract s_273_2 s_273_0 s_273_3
        let s_273_4: Bits = (Bits::new(
            ((s_273_2) >> (s_273_0)).value(),
            u16::try_from(s_273_3).unwrap(),
        ));
        // D s_273_5: cast reint s_273_4 -> u8
        let s_273_5: bool = ((s_273_4.value()) != 0);
        // C s_273_6: const #0s : i
        let s_273_6: i128 = 0;
        // C s_273_7: const #0u : u64
        let s_273_7: u64 = 0;
        // D s_273_8: cast zx s_273_5 -> u64
        let s_273_8: u64 = (s_273_5 as u64);
        // C s_273_9: const #1u : u64
        let s_273_9: u64 = 1;
        // D s_273_10: and s_273_8 s_273_9
        let s_273_10: u64 = ((s_273_8) & (s_273_9));
        // D s_273_11: cmp-eq s_273_10 s_273_9
        let s_273_11: bool = ((s_273_10) == (s_273_9));
        // D s_273_12: lsl s_273_8 s_273_6
        let s_273_12: u64 = s_273_8 << s_273_6;
        // D s_273_13: or s_273_7 s_273_12
        let s_273_13: u64 = ((s_273_7) | (s_273_12));
        // D s_273_14: cmpl s_273_12
        let s_273_14: u64 = !s_273_12;
        // D s_273_15: and s_273_7 s_273_14
        let s_273_15: u64 = ((s_273_7) & (s_273_14));
        // D s_273_16: select s_273_11 s_273_13 s_273_15
        let s_273_16: u64 = if s_273_11 { s_273_13 } else { s_273_15 };
        // D s_273_17: cast trunc s_273_16 -> u8
        let s_273_17: bool = ((s_273_16) != 0);
        // D s_273_18: cast zx s_273_17 -> bv
        let s_273_18: Bits = Bits::new(s_273_17 as u128, 1u16);
        // C s_273_19: const #0u : u8
        let s_273_19: bool = false;
        // C s_273_20: cast zx s_273_19 -> bv
        let s_273_20: Bits = Bits::new(s_273_19 as u128, 1u16);
        // D s_273_21: cmp-ne s_273_18 s_273_20
        let s_273_21: bool = ((s_273_18) != (s_273_20));
        // D s_273_22: write-var gs#412895 <= s_273_21
        fn_state.gs_412895 = s_273_21;
        // N s_273_23: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_274_0: read-var gs#412895:u8
        let s_274_0: bool = fn_state.gs_412895;
        // N s_274_1: branch s_274_0 b279 b275
        if s_274_0 {
            return block_279(state, tracer, fn_state);
        } else {
            return block_275(state, tracer, fn_state);
        };
    }
    fn block_275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_275_0: const #3s : i
        let s_275_0: i128 = 3;
        // D s_275_1: read-var u#34203:u32
        let s_275_1: u32 = fn_state.u_34203;
        // D s_275_2: cast zx s_275_1 -> bv
        let s_275_2: Bits = Bits::new(s_275_1 as u128, 32u16);
        // C s_275_3: const #1u : u64
        let s_275_3: u64 = 1;
        // D s_275_4: bit-extract s_275_2 s_275_0 s_275_3
        let s_275_4: Bits = (Bits::new(
            ((s_275_2) >> (s_275_0)).value(),
            u16::try_from(s_275_3).unwrap(),
        ));
        // D s_275_5: cast reint s_275_4 -> u8
        let s_275_5: bool = ((s_275_4.value()) != 0);
        // C s_275_6: const #0s : i
        let s_275_6: i128 = 0;
        // C s_275_7: const #0u : u64
        let s_275_7: u64 = 0;
        // D s_275_8: cast zx s_275_5 -> u64
        let s_275_8: u64 = (s_275_5 as u64);
        // C s_275_9: const #1u : u64
        let s_275_9: u64 = 1;
        // D s_275_10: and s_275_8 s_275_9
        let s_275_10: u64 = ((s_275_8) & (s_275_9));
        // D s_275_11: cmp-eq s_275_10 s_275_9
        let s_275_11: bool = ((s_275_10) == (s_275_9));
        // D s_275_12: lsl s_275_8 s_275_6
        let s_275_12: u64 = s_275_8 << s_275_6;
        // D s_275_13: or s_275_7 s_275_12
        let s_275_13: u64 = ((s_275_7) | (s_275_12));
        // D s_275_14: cmpl s_275_12
        let s_275_14: u64 = !s_275_12;
        // D s_275_15: and s_275_7 s_275_14
        let s_275_15: u64 = ((s_275_7) & (s_275_14));
        // D s_275_16: select s_275_11 s_275_13 s_275_15
        let s_275_16: u64 = if s_275_11 { s_275_13 } else { s_275_15 };
        // D s_275_17: cast trunc s_275_16 -> u8
        let s_275_17: bool = ((s_275_16) != 0);
        // D s_275_18: cast zx s_275_17 -> bv
        let s_275_18: Bits = Bits::new(s_275_17 as u128, 1u16);
        // C s_275_19: const #0u : u8
        let s_275_19: bool = false;
        // C s_275_20: cast zx s_275_19 -> bv
        let s_275_20: Bits = Bits::new(s_275_19 as u128, 1u16);
        // D s_275_21: cmp-ne s_275_18 s_275_20
        let s_275_21: bool = ((s_275_18) != (s_275_20));
        // D s_275_22: write-var gs#412898 <= s_275_21
        fn_state.gs_412898 = s_275_21;
        // N s_275_23: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_276_0: read-var gs#412898:u8
        let s_276_0: bool = fn_state.gs_412898;
        // N s_276_1: branch s_276_0 b278 b277
        if s_276_0 {
            return block_278(state, tracer, fn_state);
        } else {
            return block_277(state, tracer, fn_state);
        };
    }
    fn block_277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_277_0: read-var u#34204:u8
        let s_277_0: u8 = fn_state.u_34204;
        // D s_277_1: read-var u#34205:u8
        let s_277_1: bool = fn_state.u_34205;
        // D s_277_2: read-var u#34206:u8
        let s_277_2: u8 = fn_state.u_34206;
        // D s_277_3: read-var u#34207:u8
        let s_277_3: u8 = fn_state.u_34207;
        // D s_277_4: read-var u#34208:u8
        let s_277_4: u8 = fn_state.u_34208;
        // D s_277_5: read-var u#34209:u8
        let s_277_5: bool = fn_state.u_34209;
        // D s_277_6: read-var u#34210:u8
        let s_277_6: u8 = fn_state.u_34210;
        // D s_277_7: call decode_aarch32_instrs_VMOV_sr_A1enc_A_txt(s_277_0, s_277_1, s_277_2, s_277_3, s_277_4, s_277_5, s_277_6)
        let s_277_7: () = decode_aarch32_instrs_VMOV_sr_A1enc_A_txt(
            state,
            tracer,
            s_277_0,
            s_277_1,
            s_277_2,
            s_277_3,
            s_277_4,
            s_277_5,
            s_277_6,
        );
        // N s_277_8: return
        return;
    }
    fn block_278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_278_0: panic
        panic!("{:?}", ());
        // N s_278_1: return
        return;
    }
    fn block_279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_279_0: const #1u : u8
        let s_279_0: bool = true;
        // D s_279_1: write-var gs#412898 <= s_279_0
        fn_state.gs_412898 = s_279_0;
        // N s_279_2: jump b276
        return block_276(state, tracer, fn_state);
    }
    fn block_280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_280_0: const #1u : u8
        let s_280_0: bool = true;
        // D s_280_1: write-var gs#412895 <= s_280_0
        fn_state.gs_412895 = s_280_0;
        // N s_280_2: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_281_0: const #1u : u8
        let s_281_0: bool = true;
        // D s_281_1: write-var gs#412892 <= s_281_0
        fn_state.gs_412892 = s_281_0;
        // N s_281_2: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_282_0: read-var merge#var.1:struct
        let s_282_0: u32 = fn_state.merge_var._1;
        // D s_282_1: write-var u#34212 <= s_282_0
        fn_state.u_34212 = s_282_0;
        // C s_282_2: const #21s : i
        let s_282_2: i128 = 21;
        // D s_282_3: read-var u#34212:u32
        let s_282_3: u32 = fn_state.u_34212;
        // D s_282_4: cast zx s_282_3 -> bv
        let s_282_4: Bits = Bits::new(s_282_3 as u128, 32u16);
        // C s_282_5: const #1s : i64
        let s_282_5: i64 = 1;
        // C s_282_6: cast zx s_282_5 -> i
        let s_282_6: i128 = (i128::try_from(s_282_5).unwrap());
        // C s_282_7: const #6s : i
        let s_282_7: i128 = 6;
        // C s_282_8: add s_282_7 s_282_6
        let s_282_8: i128 = (s_282_7 + s_282_6);
        // D s_282_9: bit-extract s_282_4 s_282_2 s_282_8
        let s_282_9: Bits = (Bits::new(
            ((s_282_4) >> (s_282_2)).value(),
            u16::try_from(s_282_8).unwrap(),
        ));
        // D s_282_10: cast reint s_282_9 -> u8
        let s_282_10: u8 = (s_282_9.value() as u8);
        // D s_282_11: cast zx s_282_10 -> bv
        let s_282_11: Bits = Bits::new(s_282_10 as u128, 7u16);
        // C s_282_12: const #98u : u8
        let s_282_12: u8 = 98;
        // C s_282_13: cast zx s_282_12 -> bv
        let s_282_13: Bits = Bits::new(s_282_12 as u128, 7u16);
        // D s_282_14: cmp-eq s_282_11 s_282_13
        let s_282_14: bool = ((s_282_11) == (s_282_13));
        // N s_282_15: branch s_282_14 b865 b283
        if s_282_14 {
            return block_865(state, tracer, fn_state);
        } else {
            return block_283(state, tracer, fn_state);
        };
    }
    fn block_283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_283_0: const #0u : u8
        let s_283_0: bool = false;
        // D s_283_1: write-var gs#412907 <= s_283_0
        fn_state.gs_412907 = s_283_0;
        // N s_283_2: jump b284
        return block_284(state, tracer, fn_state);
    }
    fn block_284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_284_0: read-var gs#412907:u8
        let s_284_0: bool = fn_state.gs_412907;
        // N s_284_1: branch s_284_0 b861 b285
        if s_284_0 {
            return block_861(state, tracer, fn_state);
        } else {
            return block_285(state, tracer, fn_state);
        };
    }
    fn block_285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_285_0: const #0u : u8
        let s_285_0: bool = false;
        // D s_285_1: write-var gs#412912 <= s_285_0
        fn_state.gs_412912 = s_285_0;
        // N s_285_2: jump b286
        return block_286(state, tracer, fn_state);
    }
    fn block_286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_286_0: read-var gs#412912:u8
        let s_286_0: bool = fn_state.gs_412912;
        // D s_286_1: not s_286_0
        let s_286_1: bool = !s_286_0;
        // N s_286_2: branch s_286_1 b288 b287
        if s_286_1 {
            return block_288(state, tracer, fn_state);
        } else {
            return block_287(state, tracer, fn_state);
        };
    }
    fn block_287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_287_0: const #3550s : i
        let s_287_0: i128 = 3550;
        // C s_287_1: const #14696u : u32
        let s_287_1: u32 = 14696;
        // N s_287_2: write-reg s_287_1 <= s_287_0
        let s_287_2: () = {
            state.write_register::<i128>(s_287_1 as isize, s_287_0);
            tracer.write_register(s_287_1 as isize, s_287_0);
        };
        // C s_287_3: const #28s : i
        let s_287_3: i128 = 28;
        // C s_287_4: const #4s : i
        let s_287_4: i128 = 4;
        // D s_287_5: read-var u#34212:u32
        let s_287_5: u32 = fn_state.u_34212;
        // D s_287_6: cast zx s_287_5 -> bv
        let s_287_6: Bits = Bits::new(s_287_5 as u128, 32u16);
        // D s_287_7: bit-extract s_287_6 s_287_3 s_287_4
        let s_287_7: Bits = (Bits::new(
            ((s_287_6) >> (s_287_3)).value(),
            u16::try_from(s_287_4).unwrap(),
        ));
        // D s_287_8: cast reint s_287_7 -> u8
        let s_287_8: u8 = (s_287_7.value() as u8);
        // C s_287_9: const #20s : i
        let s_287_9: i128 = 20;
        // C s_287_10: const #1s : i
        let s_287_10: i128 = 1;
        // D s_287_11: read-var u#34212:u32
        let s_287_11: u32 = fn_state.u_34212;
        // D s_287_12: cast zx s_287_11 -> bv
        let s_287_12: Bits = Bits::new(s_287_11 as u128, 32u16);
        // D s_287_13: bit-extract s_287_12 s_287_9 s_287_10
        let s_287_13: Bits = (Bits::new(
            ((s_287_12) >> (s_287_9)).value(),
            u16::try_from(s_287_10).unwrap(),
        ));
        // D s_287_14: cast reint s_287_13 -> u8
        let s_287_14: bool = ((s_287_13.value()) != 0);
        // C s_287_15: const #16s : i
        let s_287_15: i128 = 16;
        // C s_287_16: const #4s : i
        let s_287_16: i128 = 4;
        // D s_287_17: read-var u#34212:u32
        let s_287_17: u32 = fn_state.u_34212;
        // D s_287_18: cast zx s_287_17 -> bv
        let s_287_18: Bits = Bits::new(s_287_17 as u128, 32u16);
        // D s_287_19: bit-extract s_287_18 s_287_15 s_287_16
        let s_287_19: Bits = (Bits::new(
            ((s_287_18) >> (s_287_15)).value(),
            u16::try_from(s_287_16).unwrap(),
        ));
        // D s_287_20: cast reint s_287_19 -> u8
        let s_287_20: u8 = (s_287_19.value() as u8);
        // C s_287_21: const #12s : i
        let s_287_21: i128 = 12;
        // C s_287_22: const #4s : i
        let s_287_22: i128 = 4;
        // D s_287_23: read-var u#34212:u32
        let s_287_23: u32 = fn_state.u_34212;
        // D s_287_24: cast zx s_287_23 -> bv
        let s_287_24: Bits = Bits::new(s_287_23 as u128, 32u16);
        // D s_287_25: bit-extract s_287_24 s_287_21 s_287_22
        let s_287_25: Bits = (Bits::new(
            ((s_287_24) >> (s_287_21)).value(),
            u16::try_from(s_287_22).unwrap(),
        ));
        // D s_287_26: cast reint s_287_25 -> u8
        let s_287_26: u8 = (s_287_25.value() as u8);
        // C s_287_27: const #5s : i
        let s_287_27: i128 = 5;
        // C s_287_28: const #1s : i
        let s_287_28: i128 = 1;
        // D s_287_29: read-var u#34212:u32
        let s_287_29: u32 = fn_state.u_34212;
        // D s_287_30: cast zx s_287_29 -> bv
        let s_287_30: Bits = Bits::new(s_287_29 as u128, 32u16);
        // D s_287_31: bit-extract s_287_30 s_287_27 s_287_28
        let s_287_31: Bits = (Bits::new(
            ((s_287_30) >> (s_287_27)).value(),
            u16::try_from(s_287_28).unwrap(),
        ));
        // D s_287_32: cast reint s_287_31 -> u8
        let s_287_32: bool = ((s_287_31.value()) != 0);
        // C s_287_33: const #0s : i
        let s_287_33: i128 = 0;
        // C s_287_34: const #4s : i
        let s_287_34: i128 = 4;
        // D s_287_35: read-var u#34212:u32
        let s_287_35: u32 = fn_state.u_34212;
        // D s_287_36: cast zx s_287_35 -> bv
        let s_287_36: Bits = Bits::new(s_287_35 as u128, 32u16);
        // D s_287_37: bit-extract s_287_36 s_287_33 s_287_34
        let s_287_37: Bits = (Bits::new(
            ((s_287_36) >> (s_287_33)).value(),
            u16::try_from(s_287_34).unwrap(),
        ));
        // D s_287_38: cast reint s_287_37 -> u8
        let s_287_38: u8 = (s_287_37.value() as u8);
        // D s_287_39: call decode_aarch32_instrs_VMOV_ss_A1enc_A_txt(s_287_8, s_287_14, s_287_20, s_287_26, s_287_32, s_287_38)
        let s_287_39: () = decode_aarch32_instrs_VMOV_ss_A1enc_A_txt(
            state,
            tracer,
            s_287_8,
            s_287_14,
            s_287_20,
            s_287_26,
            s_287_32,
            s_287_38,
        );
        // N s_287_40: return
        return;
    }
    fn block_288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_288_0: read-var merge#var.1:struct
        let s_288_0: u32 = fn_state.merge_var._1;
        // D s_288_1: write-var u#34220 <= s_288_0
        fn_state.u_34220 = s_288_0;
        // C s_288_2: const #23s : i
        let s_288_2: i128 = 23;
        // D s_288_3: read-var u#34220:u32
        let s_288_3: u32 = fn_state.u_34220;
        // D s_288_4: cast zx s_288_3 -> bv
        let s_288_4: Bits = Bits::new(s_288_3 as u128, 32u16);
        // C s_288_5: const #1s : i64
        let s_288_5: i64 = 1;
        // C s_288_6: cast zx s_288_5 -> i
        let s_288_6: i128 = (i128::try_from(s_288_5).unwrap());
        // C s_288_7: const #4s : i
        let s_288_7: i128 = 4;
        // C s_288_8: add s_288_7 s_288_6
        let s_288_8: i128 = (s_288_7 + s_288_6);
        // D s_288_9: bit-extract s_288_4 s_288_2 s_288_8
        let s_288_9: Bits = (Bits::new(
            ((s_288_4) >> (s_288_2)).value(),
            u16::try_from(s_288_8).unwrap(),
        ));
        // D s_288_10: cast reint s_288_9 -> u8
        let s_288_10: u8 = (s_288_9.value() as u8);
        // D s_288_11: cast zx s_288_10 -> bv
        let s_288_11: Bits = Bits::new(s_288_10 as u128, 5u16);
        // C s_288_12: const #28u : u8
        let s_288_12: u8 = 28;
        // C s_288_13: cast zx s_288_12 -> bv
        let s_288_13: Bits = Bits::new(s_288_12 as u128, 5u16);
        // D s_288_14: cmp-eq s_288_11 s_288_13
        let s_288_14: bool = ((s_288_11) == (s_288_13));
        // N s_288_15: branch s_288_14 b851 b289
        if s_288_14 {
            return block_851(state, tracer, fn_state);
        } else {
            return block_289(state, tracer, fn_state);
        };
    }
    fn block_289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_289_0: const #0u : u8
        let s_289_0: bool = false;
        // D s_289_1: write-var gs#412941 <= s_289_0
        fn_state.gs_412941 = s_289_0;
        // N s_289_2: jump b290
        return block_290(state, tracer, fn_state);
    }
    fn block_290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_290_0: read-var gs#412941:u8
        let s_290_0: bool = fn_state.gs_412941;
        // N s_290_1: branch s_290_0 b847 b291
        if s_290_0 {
            return block_847(state, tracer, fn_state);
        } else {
            return block_291(state, tracer, fn_state);
        };
    }
    fn block_291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_291_0: const #0u : u8
        let s_291_0: bool = false;
        // D s_291_1: write-var gs#412946 <= s_291_0
        fn_state.gs_412946 = s_291_0;
        // N s_291_2: jump b292
        return block_292(state, tracer, fn_state);
    }
    fn block_292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_292_0: read-var gs#412946:u8
        let s_292_0: bool = fn_state.gs_412946;
        // D s_292_1: not s_292_0
        let s_292_1: bool = !s_292_0;
        // N s_292_2: branch s_292_1 b294 b293
        if s_292_1 {
            return block_294(state, tracer, fn_state);
        } else {
            return block_293(state, tracer, fn_state);
        };
    }
    fn block_293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_293_0: const #3553s : i
        let s_293_0: i128 = 3553;
        // C s_293_1: const #14696u : u32
        let s_293_1: u32 = 14696;
        // N s_293_2: write-reg s_293_1 <= s_293_0
        let s_293_2: () = {
            state.write_register::<i128>(s_293_1 as isize, s_293_0);
            tracer.write_register(s_293_1 as isize, s_293_0);
        };
        // C s_293_3: const #28s : i
        let s_293_3: i128 = 28;
        // C s_293_4: const #4s : i
        let s_293_4: i128 = 4;
        // D s_293_5: read-var u#34220:u32
        let s_293_5: u32 = fn_state.u_34220;
        // D s_293_6: cast zx s_293_5 -> bv
        let s_293_6: Bits = Bits::new(s_293_5 as u128, 32u16);
        // D s_293_7: bit-extract s_293_6 s_293_3 s_293_4
        let s_293_7: Bits = (Bits::new(
            ((s_293_6) >> (s_293_3)).value(),
            u16::try_from(s_293_4).unwrap(),
        ));
        // D s_293_8: cast reint s_293_7 -> u8
        let s_293_8: u8 = (s_293_7.value() as u8);
        // C s_293_9: const #22s : i
        let s_293_9: i128 = 22;
        // C s_293_10: const #1s : i
        let s_293_10: i128 = 1;
        // D s_293_11: read-var u#34220:u32
        let s_293_11: u32 = fn_state.u_34220;
        // D s_293_12: cast zx s_293_11 -> bv
        let s_293_12: Bits = Bits::new(s_293_11 as u128, 32u16);
        // D s_293_13: bit-extract s_293_12 s_293_9 s_293_10
        let s_293_13: Bits = (Bits::new(
            ((s_293_12) >> (s_293_9)).value(),
            u16::try_from(s_293_10).unwrap(),
        ));
        // D s_293_14: cast reint s_293_13 -> u8
        let s_293_14: bool = ((s_293_13.value()) != 0);
        // C s_293_15: const #16s : i
        let s_293_15: i128 = 16;
        // C s_293_16: const #4s : i
        let s_293_16: i128 = 4;
        // D s_293_17: read-var u#34220:u32
        let s_293_17: u32 = fn_state.u_34220;
        // D s_293_18: cast zx s_293_17 -> bv
        let s_293_18: Bits = Bits::new(s_293_17 as u128, 32u16);
        // D s_293_19: bit-extract s_293_18 s_293_15 s_293_16
        let s_293_19: Bits = (Bits::new(
            ((s_293_18) >> (s_293_15)).value(),
            u16::try_from(s_293_16).unwrap(),
        ));
        // D s_293_20: cast reint s_293_19 -> u8
        let s_293_20: u8 = (s_293_19.value() as u8);
        // C s_293_21: const #12s : i
        let s_293_21: i128 = 12;
        // C s_293_22: const #4s : i
        let s_293_22: i128 = 4;
        // D s_293_23: read-var u#34220:u32
        let s_293_23: u32 = fn_state.u_34220;
        // D s_293_24: cast zx s_293_23 -> bv
        let s_293_24: Bits = Bits::new(s_293_23 as u128, 32u16);
        // D s_293_25: bit-extract s_293_24 s_293_21 s_293_22
        let s_293_25: Bits = (Bits::new(
            ((s_293_24) >> (s_293_21)).value(),
            u16::try_from(s_293_22).unwrap(),
        ));
        // D s_293_26: cast reint s_293_25 -> u8
        let s_293_26: u8 = (s_293_25.value() as u8);
        // C s_293_27: const #8s : i
        let s_293_27: i128 = 8;
        // C s_293_28: const #2s : i
        let s_293_28: i128 = 2;
        // D s_293_29: read-var u#34220:u32
        let s_293_29: u32 = fn_state.u_34220;
        // D s_293_30: cast zx s_293_29 -> bv
        let s_293_30: Bits = Bits::new(s_293_29 as u128, 32u16);
        // D s_293_31: bit-extract s_293_30 s_293_27 s_293_28
        let s_293_31: Bits = (Bits::new(
            ((s_293_30) >> (s_293_27)).value(),
            u16::try_from(s_293_28).unwrap(),
        ));
        // D s_293_32: cast reint s_293_31 -> u8
        let s_293_32: u8 = (s_293_31.value() as u8);
        // C s_293_33: const #7s : i
        let s_293_33: i128 = 7;
        // C s_293_34: const #1s : i
        let s_293_34: i128 = 1;
        // D s_293_35: read-var u#34220:u32
        let s_293_35: u32 = fn_state.u_34220;
        // D s_293_36: cast zx s_293_35 -> bv
        let s_293_36: Bits = Bits::new(s_293_35 as u128, 32u16);
        // D s_293_37: bit-extract s_293_36 s_293_33 s_293_34
        let s_293_37: Bits = (Bits::new(
            ((s_293_36) >> (s_293_33)).value(),
            u16::try_from(s_293_34).unwrap(),
        ));
        // D s_293_38: cast reint s_293_37 -> u8
        let s_293_38: bool = ((s_293_37.value()) != 0);
        // C s_293_39: const #5s : i
        let s_293_39: i128 = 5;
        // C s_293_40: const #1s : i
        let s_293_40: i128 = 1;
        // D s_293_41: read-var u#34220:u32
        let s_293_41: u32 = fn_state.u_34220;
        // D s_293_42: cast zx s_293_41 -> bv
        let s_293_42: Bits = Bits::new(s_293_41 as u128, 32u16);
        // D s_293_43: bit-extract s_293_42 s_293_39 s_293_40
        let s_293_43: Bits = (Bits::new(
            ((s_293_42) >> (s_293_39)).value(),
            u16::try_from(s_293_40).unwrap(),
        ));
        // D s_293_44: cast reint s_293_43 -> u8
        let s_293_44: bool = ((s_293_43.value()) != 0);
        // C s_293_45: const #0s : i
        let s_293_45: i128 = 0;
        // C s_293_46: const #4s : i
        let s_293_46: i128 = 4;
        // D s_293_47: read-var u#34220:u32
        let s_293_47: u32 = fn_state.u_34220;
        // D s_293_48: cast zx s_293_47 -> bv
        let s_293_48: Bits = Bits::new(s_293_47 as u128, 32u16);
        // D s_293_49: bit-extract s_293_48 s_293_45 s_293_46
        let s_293_49: Bits = (Bits::new(
            ((s_293_48) >> (s_293_45)).value(),
            u16::try_from(s_293_46).unwrap(),
        ));
        // D s_293_50: cast reint s_293_49 -> u8
        let s_293_50: u8 = (s_293_49.value() as u8);
        // D s_293_51: call decode_aarch32_instrs_VMUL_f_A2enc_A_txt(s_293_8, s_293_14, s_293_20, s_293_26, s_293_32, s_293_38, s_293_44, s_293_50)
        let s_293_51: () = decode_aarch32_instrs_VMUL_f_A2enc_A_txt(
            state,
            tracer,
            s_293_8,
            s_293_14,
            s_293_20,
            s_293_26,
            s_293_32,
            s_293_38,
            s_293_44,
            s_293_50,
        );
        // N s_293_52: return
        return;
    }
    fn block_294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_294_0: read-var merge#var.1:struct
        let s_294_0: u32 = fn_state.merge_var._1;
        // D s_294_1: write-var u#34230 <= s_294_0
        fn_state.u_34230 = s_294_0;
        // C s_294_2: const #23s : i
        let s_294_2: i128 = 23;
        // D s_294_3: read-var u#34230:u32
        let s_294_3: u32 = fn_state.u_34230;
        // D s_294_4: cast zx s_294_3 -> bv
        let s_294_4: Bits = Bits::new(s_294_3 as u128, 32u16);
        // C s_294_5: const #1s : i64
        let s_294_5: i64 = 1;
        // C s_294_6: cast zx s_294_5 -> i
        let s_294_6: i128 = (i128::try_from(s_294_5).unwrap());
        // C s_294_7: const #4s : i
        let s_294_7: i128 = 4;
        // C s_294_8: add s_294_7 s_294_6
        let s_294_8: i128 = (s_294_7 + s_294_6);
        // D s_294_9: bit-extract s_294_4 s_294_2 s_294_8
        let s_294_9: Bits = (Bits::new(
            ((s_294_4) >> (s_294_2)).value(),
            u16::try_from(s_294_8).unwrap(),
        ));
        // D s_294_10: cast reint s_294_9 -> u8
        let s_294_10: u8 = (s_294_9.value() as u8);
        // D s_294_11: cast zx s_294_10 -> bv
        let s_294_11: Bits = Bits::new(s_294_10 as u128, 5u16);
        // C s_294_12: const #29u : u8
        let s_294_12: u8 = 29;
        // C s_294_13: cast zx s_294_12 -> bv
        let s_294_13: Bits = Bits::new(s_294_12 as u128, 5u16);
        // D s_294_14: cmp-eq s_294_11 s_294_13
        let s_294_14: bool = ((s_294_11) == (s_294_13));
        // N s_294_15: branch s_294_14 b837 b295
        if s_294_14 {
            return block_837(state, tracer, fn_state);
        } else {
            return block_295(state, tracer, fn_state);
        };
    }
    fn block_295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_295_0: const #0u : u8
        let s_295_0: bool = false;
        // D s_295_1: write-var gs#412979 <= s_295_0
        fn_state.gs_412979 = s_295_0;
        // N s_295_2: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_296_0: read-var gs#412979:u8
        let s_296_0: bool = fn_state.gs_412979;
        // N s_296_1: branch s_296_0 b833 b297
        if s_296_0 {
            return block_833(state, tracer, fn_state);
        } else {
            return block_297(state, tracer, fn_state);
        };
    }
    fn block_297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_297_0: const #0u : u8
        let s_297_0: bool = false;
        // D s_297_1: write-var gs#412984 <= s_297_0
        fn_state.gs_412984 = s_297_0;
        // N s_297_2: jump b298
        return block_298(state, tracer, fn_state);
    }
    fn block_298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_298_0: read-var gs#412984:u8
        let s_298_0: bool = fn_state.gs_412984;
        // D s_298_1: not s_298_0
        let s_298_1: bool = !s_298_0;
        // N s_298_2: branch s_298_1 b300 b299
        if s_298_1 {
            return block_300(state, tracer, fn_state);
        } else {
            return block_299(state, tracer, fn_state);
        };
    }
    fn block_299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_299_0: const #3573s : i
        let s_299_0: i128 = 3573;
        // C s_299_1: const #14696u : u32
        let s_299_1: u32 = 14696;
        // N s_299_2: write-reg s_299_1 <= s_299_0
        let s_299_2: () = {
            state.write_register::<i128>(s_299_1 as isize, s_299_0);
            tracer.write_register(s_299_1 as isize, s_299_0);
        };
        // C s_299_3: const #28s : i
        let s_299_3: i128 = 28;
        // C s_299_4: const #4s : i
        let s_299_4: i128 = 4;
        // D s_299_5: read-var u#34230:u32
        let s_299_5: u32 = fn_state.u_34230;
        // D s_299_6: cast zx s_299_5 -> bv
        let s_299_6: Bits = Bits::new(s_299_5 as u128, 32u16);
        // D s_299_7: bit-extract s_299_6 s_299_3 s_299_4
        let s_299_7: Bits = (Bits::new(
            ((s_299_6) >> (s_299_3)).value(),
            u16::try_from(s_299_4).unwrap(),
        ));
        // D s_299_8: cast reint s_299_7 -> u8
        let s_299_8: u8 = (s_299_7.value() as u8);
        // C s_299_9: const #22s : i
        let s_299_9: i128 = 22;
        // C s_299_10: const #1s : i
        let s_299_10: i128 = 1;
        // D s_299_11: read-var u#34230:u32
        let s_299_11: u32 = fn_state.u_34230;
        // D s_299_12: cast zx s_299_11 -> bv
        let s_299_12: Bits = Bits::new(s_299_11 as u128, 32u16);
        // D s_299_13: bit-extract s_299_12 s_299_9 s_299_10
        let s_299_13: Bits = (Bits::new(
            ((s_299_12) >> (s_299_9)).value(),
            u16::try_from(s_299_10).unwrap(),
        ));
        // D s_299_14: cast reint s_299_13 -> u8
        let s_299_14: bool = ((s_299_13.value()) != 0);
        // C s_299_15: const #12s : i
        let s_299_15: i128 = 12;
        // C s_299_16: const #4s : i
        let s_299_16: i128 = 4;
        // D s_299_17: read-var u#34230:u32
        let s_299_17: u32 = fn_state.u_34230;
        // D s_299_18: cast zx s_299_17 -> bv
        let s_299_18: Bits = Bits::new(s_299_17 as u128, 32u16);
        // D s_299_19: bit-extract s_299_18 s_299_15 s_299_16
        let s_299_19: Bits = (Bits::new(
            ((s_299_18) >> (s_299_15)).value(),
            u16::try_from(s_299_16).unwrap(),
        ));
        // D s_299_20: cast reint s_299_19 -> u8
        let s_299_20: u8 = (s_299_19.value() as u8);
        // C s_299_21: const #8s : i
        let s_299_21: i128 = 8;
        // C s_299_22: const #2s : i
        let s_299_22: i128 = 2;
        // D s_299_23: read-var u#34230:u32
        let s_299_23: u32 = fn_state.u_34230;
        // D s_299_24: cast zx s_299_23 -> bv
        let s_299_24: Bits = Bits::new(s_299_23 as u128, 32u16);
        // D s_299_25: bit-extract s_299_24 s_299_21 s_299_22
        let s_299_25: Bits = (Bits::new(
            ((s_299_24) >> (s_299_21)).value(),
            u16::try_from(s_299_22).unwrap(),
        ));
        // D s_299_26: cast reint s_299_25 -> u8
        let s_299_26: u8 = (s_299_25.value() as u8);
        // C s_299_27: const #5s : i
        let s_299_27: i128 = 5;
        // C s_299_28: const #1s : i
        let s_299_28: i128 = 1;
        // D s_299_29: read-var u#34230:u32
        let s_299_29: u32 = fn_state.u_34230;
        // D s_299_30: cast zx s_299_29 -> bv
        let s_299_30: Bits = Bits::new(s_299_29 as u128, 32u16);
        // D s_299_31: bit-extract s_299_30 s_299_27 s_299_28
        let s_299_31: Bits = (Bits::new(
            ((s_299_30) >> (s_299_27)).value(),
            u16::try_from(s_299_28).unwrap(),
        ));
        // D s_299_32: cast reint s_299_31 -> u8
        let s_299_32: bool = ((s_299_31.value()) != 0);
        // C s_299_33: const #0s : i
        let s_299_33: i128 = 0;
        // C s_299_34: const #4s : i
        let s_299_34: i128 = 4;
        // D s_299_35: read-var u#34230:u32
        let s_299_35: u32 = fn_state.u_34230;
        // D s_299_36: cast zx s_299_35 -> bv
        let s_299_36: Bits = Bits::new(s_299_35 as u128, 32u16);
        // D s_299_37: bit-extract s_299_36 s_299_33 s_299_34
        let s_299_37: Bits = (Bits::new(
            ((s_299_36) >> (s_299_33)).value(),
            u16::try_from(s_299_34).unwrap(),
        ));
        // D s_299_38: cast reint s_299_37 -> u8
        let s_299_38: u8 = (s_299_37.value() as u8);
        // D s_299_39: call decode_aarch32_instrs_VNEG_A2enc_A_txt(s_299_8, s_299_14, s_299_20, s_299_26, s_299_32, s_299_38)
        let s_299_39: () = decode_aarch32_instrs_VNEG_A2enc_A_txt(
            state,
            tracer,
            s_299_8,
            s_299_14,
            s_299_20,
            s_299_26,
            s_299_32,
            s_299_38,
        );
        // N s_299_40: return
        return;
    }
    fn block_300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_300_0: read-var merge#var.1:struct
        let s_300_0: u32 = fn_state.merge_var._1;
        // D s_300_1: write-var u#34238 <= s_300_0
        fn_state.u_34238 = s_300_0;
        // C s_300_2: const #23s : i
        let s_300_2: i128 = 23;
        // D s_300_3: read-var u#34238:u32
        let s_300_3: u32 = fn_state.u_34238;
        // D s_300_4: cast zx s_300_3 -> bv
        let s_300_4: Bits = Bits::new(s_300_3 as u128, 32u16);
        // C s_300_5: const #1s : i64
        let s_300_5: i64 = 1;
        // C s_300_6: cast zx s_300_5 -> i
        let s_300_6: i128 = (i128::try_from(s_300_5).unwrap());
        // C s_300_7: const #4s : i
        let s_300_7: i128 = 4;
        // C s_300_8: add s_300_7 s_300_6
        let s_300_8: i128 = (s_300_7 + s_300_6);
        // D s_300_9: bit-extract s_300_4 s_300_2 s_300_8
        let s_300_9: Bits = (Bits::new(
            ((s_300_4) >> (s_300_2)).value(),
            u16::try_from(s_300_8).unwrap(),
        ));
        // D s_300_10: cast reint s_300_9 -> u8
        let s_300_10: u8 = (s_300_9.value() as u8);
        // D s_300_11: cast zx s_300_10 -> bv
        let s_300_11: Bits = Bits::new(s_300_10 as u128, 5u16);
        // C s_300_12: const #28u : u8
        let s_300_12: u8 = 28;
        // C s_300_13: cast zx s_300_12 -> bv
        let s_300_13: Bits = Bits::new(s_300_12 as u128, 5u16);
        // D s_300_14: cmp-eq s_300_11 s_300_13
        let s_300_14: bool = ((s_300_11) == (s_300_13));
        // N s_300_15: branch s_300_14 b826 b301
        if s_300_14 {
            return block_826(state, tracer, fn_state);
        } else {
            return block_301(state, tracer, fn_state);
        };
    }
    fn block_301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_301_0: const #0u : u8
        let s_301_0: bool = false;
        // D s_301_1: write-var gs#413010 <= s_301_0
        fn_state.gs_413010 = s_301_0;
        // N s_301_2: jump b302
        return block_302(state, tracer, fn_state);
    }
    fn block_302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_302_0: read-var gs#413010:u8
        let s_302_0: bool = fn_state.gs_413010;
        // N s_302_1: branch s_302_0 b822 b303
        if s_302_0 {
            return block_822(state, tracer, fn_state);
        } else {
            return block_303(state, tracer, fn_state);
        };
    }
    fn block_303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_303_0: const #0u : u8
        let s_303_0: bool = false;
        // D s_303_1: write-var gs#413015 <= s_303_0
        fn_state.gs_413015 = s_303_0;
        // N s_303_2: jump b304
        return block_304(state, tracer, fn_state);
    }
    fn block_304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_304_0: read-var gs#413015:u8
        let s_304_0: bool = fn_state.gs_413015;
        // D s_304_1: not s_304_0
        let s_304_1: bool = !s_304_0;
        // N s_304_2: branch s_304_1 b306 b305
        if s_304_1 {
            return block_306(state, tracer, fn_state);
        } else {
            return block_305(state, tracer, fn_state);
        };
    }
    fn block_305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_305_0: const #3576s : i
        let s_305_0: i128 = 3576;
        // C s_305_1: const #14696u : u32
        let s_305_1: u32 = 14696;
        // N s_305_2: write-reg s_305_1 <= s_305_0
        let s_305_2: () = {
            state.write_register::<i128>(s_305_1 as isize, s_305_0);
            tracer.write_register(s_305_1 as isize, s_305_0);
        };
        // C s_305_3: const #28s : i
        let s_305_3: i128 = 28;
        // C s_305_4: const #4s : i
        let s_305_4: i128 = 4;
        // D s_305_5: read-var u#34238:u32
        let s_305_5: u32 = fn_state.u_34238;
        // D s_305_6: cast zx s_305_5 -> bv
        let s_305_6: Bits = Bits::new(s_305_5 as u128, 32u16);
        // D s_305_7: bit-extract s_305_6 s_305_3 s_305_4
        let s_305_7: Bits = (Bits::new(
            ((s_305_6) >> (s_305_3)).value(),
            u16::try_from(s_305_4).unwrap(),
        ));
        // D s_305_8: cast reint s_305_7 -> u8
        let s_305_8: u8 = (s_305_7.value() as u8);
        // C s_305_9: const #22s : i
        let s_305_9: i128 = 22;
        // C s_305_10: const #1s : i
        let s_305_10: i128 = 1;
        // D s_305_11: read-var u#34238:u32
        let s_305_11: u32 = fn_state.u_34238;
        // D s_305_12: cast zx s_305_11 -> bv
        let s_305_12: Bits = Bits::new(s_305_11 as u128, 32u16);
        // D s_305_13: bit-extract s_305_12 s_305_9 s_305_10
        let s_305_13: Bits = (Bits::new(
            ((s_305_12) >> (s_305_9)).value(),
            u16::try_from(s_305_10).unwrap(),
        ));
        // D s_305_14: cast reint s_305_13 -> u8
        let s_305_14: bool = ((s_305_13.value()) != 0);
        // C s_305_15: const #16s : i
        let s_305_15: i128 = 16;
        // C s_305_16: const #4s : i
        let s_305_16: i128 = 4;
        // D s_305_17: read-var u#34238:u32
        let s_305_17: u32 = fn_state.u_34238;
        // D s_305_18: cast zx s_305_17 -> bv
        let s_305_18: Bits = Bits::new(s_305_17 as u128, 32u16);
        // D s_305_19: bit-extract s_305_18 s_305_15 s_305_16
        let s_305_19: Bits = (Bits::new(
            ((s_305_18) >> (s_305_15)).value(),
            u16::try_from(s_305_16).unwrap(),
        ));
        // D s_305_20: cast reint s_305_19 -> u8
        let s_305_20: u8 = (s_305_19.value() as u8);
        // C s_305_21: const #12s : i
        let s_305_21: i128 = 12;
        // C s_305_22: const #4s : i
        let s_305_22: i128 = 4;
        // D s_305_23: read-var u#34238:u32
        let s_305_23: u32 = fn_state.u_34238;
        // D s_305_24: cast zx s_305_23 -> bv
        let s_305_24: Bits = Bits::new(s_305_23 as u128, 32u16);
        // D s_305_25: bit-extract s_305_24 s_305_21 s_305_22
        let s_305_25: Bits = (Bits::new(
            ((s_305_24) >> (s_305_21)).value(),
            u16::try_from(s_305_22).unwrap(),
        ));
        // D s_305_26: cast reint s_305_25 -> u8
        let s_305_26: u8 = (s_305_25.value() as u8);
        // C s_305_27: const #8s : i
        let s_305_27: i128 = 8;
        // C s_305_28: const #2s : i
        let s_305_28: i128 = 2;
        // D s_305_29: read-var u#34238:u32
        let s_305_29: u32 = fn_state.u_34238;
        // D s_305_30: cast zx s_305_29 -> bv
        let s_305_30: Bits = Bits::new(s_305_29 as u128, 32u16);
        // D s_305_31: bit-extract s_305_30 s_305_27 s_305_28
        let s_305_31: Bits = (Bits::new(
            ((s_305_30) >> (s_305_27)).value(),
            u16::try_from(s_305_28).unwrap(),
        ));
        // D s_305_32: cast reint s_305_31 -> u8
        let s_305_32: u8 = (s_305_31.value() as u8);
        // C s_305_33: const #7s : i
        let s_305_33: i128 = 7;
        // C s_305_34: const #1s : i
        let s_305_34: i128 = 1;
        // D s_305_35: read-var u#34238:u32
        let s_305_35: u32 = fn_state.u_34238;
        // D s_305_36: cast zx s_305_35 -> bv
        let s_305_36: Bits = Bits::new(s_305_35 as u128, 32u16);
        // D s_305_37: bit-extract s_305_36 s_305_33 s_305_34
        let s_305_37: Bits = (Bits::new(
            ((s_305_36) >> (s_305_33)).value(),
            u16::try_from(s_305_34).unwrap(),
        ));
        // D s_305_38: cast reint s_305_37 -> u8
        let s_305_38: bool = ((s_305_37.value()) != 0);
        // C s_305_39: const #6s : i
        let s_305_39: i128 = 6;
        // C s_305_40: const #1s : i
        let s_305_40: i128 = 1;
        // D s_305_41: read-var u#34238:u32
        let s_305_41: u32 = fn_state.u_34238;
        // D s_305_42: cast zx s_305_41 -> bv
        let s_305_42: Bits = Bits::new(s_305_41 as u128, 32u16);
        // D s_305_43: bit-extract s_305_42 s_305_39 s_305_40
        let s_305_43: Bits = (Bits::new(
            ((s_305_42) >> (s_305_39)).value(),
            u16::try_from(s_305_40).unwrap(),
        ));
        // D s_305_44: cast reint s_305_43 -> u8
        let s_305_44: bool = ((s_305_43.value()) != 0);
        // C s_305_45: const #5s : i
        let s_305_45: i128 = 5;
        // C s_305_46: const #1s : i
        let s_305_46: i128 = 1;
        // D s_305_47: read-var u#34238:u32
        let s_305_47: u32 = fn_state.u_34238;
        // D s_305_48: cast zx s_305_47 -> bv
        let s_305_48: Bits = Bits::new(s_305_47 as u128, 32u16);
        // D s_305_49: bit-extract s_305_48 s_305_45 s_305_46
        let s_305_49: Bits = (Bits::new(
            ((s_305_48) >> (s_305_45)).value(),
            u16::try_from(s_305_46).unwrap(),
        ));
        // D s_305_50: cast reint s_305_49 -> u8
        let s_305_50: bool = ((s_305_49.value()) != 0);
        // C s_305_51: const #0s : i
        let s_305_51: i128 = 0;
        // C s_305_52: const #4s : i
        let s_305_52: i128 = 4;
        // D s_305_53: read-var u#34238:u32
        let s_305_53: u32 = fn_state.u_34238;
        // D s_305_54: cast zx s_305_53 -> bv
        let s_305_54: Bits = Bits::new(s_305_53 as u128, 32u16);
        // D s_305_55: bit-extract s_305_54 s_305_51 s_305_52
        let s_305_55: Bits = (Bits::new(
            ((s_305_54) >> (s_305_51)).value(),
            u16::try_from(s_305_52).unwrap(),
        ));
        // D s_305_56: cast reint s_305_55 -> u8
        let s_305_56: u8 = (s_305_55.value() as u8);
        // D s_305_57: call decode_aarch32_instrs_VNMLA_A1enc_A_txt(s_305_8, s_305_14, s_305_20, s_305_26, s_305_32, s_305_38, s_305_44, s_305_50, s_305_56)
        let s_305_57: () = decode_aarch32_instrs_VNMLA_A1enc_A_txt(
            state,
            tracer,
            s_305_8,
            s_305_14,
            s_305_20,
            s_305_26,
            s_305_32,
            s_305_38,
            s_305_44,
            s_305_50,
            s_305_56,
        );
        // N s_305_58: return
        return;
    }
    fn block_306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_306_0: read-var merge#var.1:struct
        let s_306_0: u32 = fn_state.merge_var._1;
        // D s_306_1: write-var u#34249 <= s_306_0
        fn_state.u_34249 = s_306_0;
        // C s_306_2: const #23s : i
        let s_306_2: i128 = 23;
        // D s_306_3: read-var u#34249:u32
        let s_306_3: u32 = fn_state.u_34249;
        // D s_306_4: cast zx s_306_3 -> bv
        let s_306_4: Bits = Bits::new(s_306_3 as u128, 32u16);
        // C s_306_5: const #1s : i64
        let s_306_5: i64 = 1;
        // C s_306_6: cast zx s_306_5 -> i
        let s_306_6: i128 = (i128::try_from(s_306_5).unwrap());
        // C s_306_7: const #4s : i
        let s_306_7: i128 = 4;
        // C s_306_8: add s_306_7 s_306_6
        let s_306_8: i128 = (s_306_7 + s_306_6);
        // D s_306_9: bit-extract s_306_4 s_306_2 s_306_8
        let s_306_9: Bits = (Bits::new(
            ((s_306_4) >> (s_306_2)).value(),
            u16::try_from(s_306_8).unwrap(),
        ));
        // D s_306_10: cast reint s_306_9 -> u8
        let s_306_10: u8 = (s_306_9.value() as u8);
        // D s_306_11: cast zx s_306_10 -> bv
        let s_306_11: Bits = Bits::new(s_306_10 as u128, 5u16);
        // C s_306_12: const #28u : u8
        let s_306_12: u8 = 28;
        // C s_306_13: cast zx s_306_12 -> bv
        let s_306_13: Bits = Bits::new(s_306_12 as u128, 5u16);
        // D s_306_14: cmp-eq s_306_11 s_306_13
        let s_306_14: bool = ((s_306_11) == (s_306_13));
        // N s_306_15: branch s_306_14 b812 b307
        if s_306_14 {
            return block_812(state, tracer, fn_state);
        } else {
            return block_307(state, tracer, fn_state);
        };
    }
    fn block_307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_307_0: const #0u : u8
        let s_307_0: bool = false;
        // D s_307_1: write-var gs#413050 <= s_307_0
        fn_state.gs_413050 = s_307_0;
        // N s_307_2: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_308_0: read-var gs#413050:u8
        let s_308_0: bool = fn_state.gs_413050;
        // N s_308_1: branch s_308_0 b808 b309
        if s_308_0 {
            return block_808(state, tracer, fn_state);
        } else {
            return block_309(state, tracer, fn_state);
        };
    }
    fn block_309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_309_0: const #0u : u8
        let s_309_0: bool = false;
        // D s_309_1: write-var gs#413055 <= s_309_0
        fn_state.gs_413055 = s_309_0;
        // N s_309_2: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_310_0: read-var gs#413055:u8
        let s_310_0: bool = fn_state.gs_413055;
        // D s_310_1: not s_310_0
        let s_310_1: bool = !s_310_0;
        // N s_310_2: branch s_310_1 b312 b311
        if s_310_1 {
            return block_312(state, tracer, fn_state);
        } else {
            return block_311(state, tracer, fn_state);
        };
    }
    fn block_311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_311_0: const #3577s : i
        let s_311_0: i128 = 3577;
        // C s_311_1: const #14696u : u32
        let s_311_1: u32 = 14696;
        // N s_311_2: write-reg s_311_1 <= s_311_0
        let s_311_2: () = {
            state.write_register::<i128>(s_311_1 as isize, s_311_0);
            tracer.write_register(s_311_1 as isize, s_311_0);
        };
        // C s_311_3: const #28s : i
        let s_311_3: i128 = 28;
        // C s_311_4: const #4s : i
        let s_311_4: i128 = 4;
        // D s_311_5: read-var u#34249:u32
        let s_311_5: u32 = fn_state.u_34249;
        // D s_311_6: cast zx s_311_5 -> bv
        let s_311_6: Bits = Bits::new(s_311_5 as u128, 32u16);
        // D s_311_7: bit-extract s_311_6 s_311_3 s_311_4
        let s_311_7: Bits = (Bits::new(
            ((s_311_6) >> (s_311_3)).value(),
            u16::try_from(s_311_4).unwrap(),
        ));
        // D s_311_8: cast reint s_311_7 -> u8
        let s_311_8: u8 = (s_311_7.value() as u8);
        // C s_311_9: const #22s : i
        let s_311_9: i128 = 22;
        // C s_311_10: const #1s : i
        let s_311_10: i128 = 1;
        // D s_311_11: read-var u#34249:u32
        let s_311_11: u32 = fn_state.u_34249;
        // D s_311_12: cast zx s_311_11 -> bv
        let s_311_12: Bits = Bits::new(s_311_11 as u128, 32u16);
        // D s_311_13: bit-extract s_311_12 s_311_9 s_311_10
        let s_311_13: Bits = (Bits::new(
            ((s_311_12) >> (s_311_9)).value(),
            u16::try_from(s_311_10).unwrap(),
        ));
        // D s_311_14: cast reint s_311_13 -> u8
        let s_311_14: bool = ((s_311_13.value()) != 0);
        // C s_311_15: const #16s : i
        let s_311_15: i128 = 16;
        // C s_311_16: const #4s : i
        let s_311_16: i128 = 4;
        // D s_311_17: read-var u#34249:u32
        let s_311_17: u32 = fn_state.u_34249;
        // D s_311_18: cast zx s_311_17 -> bv
        let s_311_18: Bits = Bits::new(s_311_17 as u128, 32u16);
        // D s_311_19: bit-extract s_311_18 s_311_15 s_311_16
        let s_311_19: Bits = (Bits::new(
            ((s_311_18) >> (s_311_15)).value(),
            u16::try_from(s_311_16).unwrap(),
        ));
        // D s_311_20: cast reint s_311_19 -> u8
        let s_311_20: u8 = (s_311_19.value() as u8);
        // C s_311_21: const #12s : i
        let s_311_21: i128 = 12;
        // C s_311_22: const #4s : i
        let s_311_22: i128 = 4;
        // D s_311_23: read-var u#34249:u32
        let s_311_23: u32 = fn_state.u_34249;
        // D s_311_24: cast zx s_311_23 -> bv
        let s_311_24: Bits = Bits::new(s_311_23 as u128, 32u16);
        // D s_311_25: bit-extract s_311_24 s_311_21 s_311_22
        let s_311_25: Bits = (Bits::new(
            ((s_311_24) >> (s_311_21)).value(),
            u16::try_from(s_311_22).unwrap(),
        ));
        // D s_311_26: cast reint s_311_25 -> u8
        let s_311_26: u8 = (s_311_25.value() as u8);
        // C s_311_27: const #8s : i
        let s_311_27: i128 = 8;
        // C s_311_28: const #2s : i
        let s_311_28: i128 = 2;
        // D s_311_29: read-var u#34249:u32
        let s_311_29: u32 = fn_state.u_34249;
        // D s_311_30: cast zx s_311_29 -> bv
        let s_311_30: Bits = Bits::new(s_311_29 as u128, 32u16);
        // D s_311_31: bit-extract s_311_30 s_311_27 s_311_28
        let s_311_31: Bits = (Bits::new(
            ((s_311_30) >> (s_311_27)).value(),
            u16::try_from(s_311_28).unwrap(),
        ));
        // D s_311_32: cast reint s_311_31 -> u8
        let s_311_32: u8 = (s_311_31.value() as u8);
        // C s_311_33: const #7s : i
        let s_311_33: i128 = 7;
        // C s_311_34: const #1s : i
        let s_311_34: i128 = 1;
        // D s_311_35: read-var u#34249:u32
        let s_311_35: u32 = fn_state.u_34249;
        // D s_311_36: cast zx s_311_35 -> bv
        let s_311_36: Bits = Bits::new(s_311_35 as u128, 32u16);
        // D s_311_37: bit-extract s_311_36 s_311_33 s_311_34
        let s_311_37: Bits = (Bits::new(
            ((s_311_36) >> (s_311_33)).value(),
            u16::try_from(s_311_34).unwrap(),
        ));
        // D s_311_38: cast reint s_311_37 -> u8
        let s_311_38: bool = ((s_311_37.value()) != 0);
        // C s_311_39: const #5s : i
        let s_311_39: i128 = 5;
        // C s_311_40: const #1s : i
        let s_311_40: i128 = 1;
        // D s_311_41: read-var u#34249:u32
        let s_311_41: u32 = fn_state.u_34249;
        // D s_311_42: cast zx s_311_41 -> bv
        let s_311_42: Bits = Bits::new(s_311_41 as u128, 32u16);
        // D s_311_43: bit-extract s_311_42 s_311_39 s_311_40
        let s_311_43: Bits = (Bits::new(
            ((s_311_42) >> (s_311_39)).value(),
            u16::try_from(s_311_40).unwrap(),
        ));
        // D s_311_44: cast reint s_311_43 -> u8
        let s_311_44: bool = ((s_311_43.value()) != 0);
        // C s_311_45: const #0s : i
        let s_311_45: i128 = 0;
        // C s_311_46: const #4s : i
        let s_311_46: i128 = 4;
        // D s_311_47: read-var u#34249:u32
        let s_311_47: u32 = fn_state.u_34249;
        // D s_311_48: cast zx s_311_47 -> bv
        let s_311_48: Bits = Bits::new(s_311_47 as u128, 32u16);
        // D s_311_49: bit-extract s_311_48 s_311_45 s_311_46
        let s_311_49: Bits = (Bits::new(
            ((s_311_48) >> (s_311_45)).value(),
            u16::try_from(s_311_46).unwrap(),
        ));
        // D s_311_50: cast reint s_311_49 -> u8
        let s_311_50: u8 = (s_311_49.value() as u8);
        // D s_311_51: call decode_aarch32_instrs_VNMLA_A2enc_A_txt(s_311_8, s_311_14, s_311_20, s_311_26, s_311_32, s_311_38, s_311_44, s_311_50)
        let s_311_51: () = decode_aarch32_instrs_VNMLA_A2enc_A_txt(
            state,
            tracer,
            s_311_8,
            s_311_14,
            s_311_20,
            s_311_26,
            s_311_32,
            s_311_38,
            s_311_44,
            s_311_50,
        );
        // N s_311_52: return
        return;
    }
    fn block_312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_312_0: read-var merge#var.1:struct
        let s_312_0: u32 = fn_state.merge_var._1;
        // D s_312_1: write-var u#34259 <= s_312_0
        fn_state.u_34259 = s_312_0;
        // C s_312_2: const #23s : i
        let s_312_2: i128 = 23;
        // D s_312_3: read-var u#34259:u32
        let s_312_3: u32 = fn_state.u_34259;
        // D s_312_4: cast zx s_312_3 -> bv
        let s_312_4: Bits = Bits::new(s_312_3 as u128, 32u16);
        // C s_312_5: const #1s : i64
        let s_312_5: i64 = 1;
        // C s_312_6: cast zx s_312_5 -> i
        let s_312_6: i128 = (i128::try_from(s_312_5).unwrap());
        // C s_312_7: const #4s : i
        let s_312_7: i128 = 4;
        // C s_312_8: add s_312_7 s_312_6
        let s_312_8: i128 = (s_312_7 + s_312_6);
        // D s_312_9: bit-extract s_312_4 s_312_2 s_312_8
        let s_312_9: Bits = (Bits::new(
            ((s_312_4) >> (s_312_2)).value(),
            u16::try_from(s_312_8).unwrap(),
        ));
        // D s_312_10: cast reint s_312_9 -> u8
        let s_312_10: u8 = (s_312_9.value() as u8);
        // D s_312_11: cast zx s_312_10 -> bv
        let s_312_11: Bits = Bits::new(s_312_10 as u128, 5u16);
        // C s_312_12: const #29u : u8
        let s_312_12: u8 = 29;
        // C s_312_13: cast zx s_312_12 -> bv
        let s_312_13: Bits = Bits::new(s_312_12 as u128, 5u16);
        // D s_312_14: cmp-eq s_312_11 s_312_13
        let s_312_14: bool = ((s_312_11) == (s_312_13));
        // N s_312_15: branch s_312_14 b798 b313
        if s_312_14 {
            return block_798(state, tracer, fn_state);
        } else {
            return block_313(state, tracer, fn_state);
        };
    }
    fn block_313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_313_0: const #0u : u8
        let s_313_0: bool = false;
        // D s_313_1: write-var gs#413088 <= s_313_0
        fn_state.gs_413088 = s_313_0;
        // N s_313_2: jump b314
        return block_314(state, tracer, fn_state);
    }
    fn block_314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_314_0: read-var gs#413088:u8
        let s_314_0: bool = fn_state.gs_413088;
        // N s_314_1: branch s_314_0 b794 b315
        if s_314_0 {
            return block_794(state, tracer, fn_state);
        } else {
            return block_315(state, tracer, fn_state);
        };
    }
    fn block_315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_315_0: const #0u : u8
        let s_315_0: bool = false;
        // D s_315_1: write-var gs#413093 <= s_315_0
        fn_state.gs_413093 = s_315_0;
        // N s_315_2: jump b316
        return block_316(state, tracer, fn_state);
    }
    fn block_316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_316_0: read-var gs#413093:u8
        let s_316_0: bool = fn_state.gs_413093;
        // D s_316_1: not s_316_0
        let s_316_1: bool = !s_316_0;
        // N s_316_2: branch s_316_1 b318 b317
        if s_316_1 {
            return block_318(state, tracer, fn_state);
        } else {
            return block_317(state, tracer, fn_state);
        };
    }
    fn block_317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_317_0: const #3686s : i
        let s_317_0: i128 = 3686;
        // C s_317_1: const #14696u : u32
        let s_317_1: u32 = 14696;
        // N s_317_2: write-reg s_317_1 <= s_317_0
        let s_317_2: () = {
            state.write_register::<i128>(s_317_1 as isize, s_317_0);
            tracer.write_register(s_317_1 as isize, s_317_0);
        };
        // C s_317_3: const #28s : i
        let s_317_3: i128 = 28;
        // C s_317_4: const #4s : i
        let s_317_4: i128 = 4;
        // D s_317_5: read-var u#34259:u32
        let s_317_5: u32 = fn_state.u_34259;
        // D s_317_6: cast zx s_317_5 -> bv
        let s_317_6: Bits = Bits::new(s_317_5 as u128, 32u16);
        // D s_317_7: bit-extract s_317_6 s_317_3 s_317_4
        let s_317_7: Bits = (Bits::new(
            ((s_317_6) >> (s_317_3)).value(),
            u16::try_from(s_317_4).unwrap(),
        ));
        // D s_317_8: cast reint s_317_7 -> u8
        let s_317_8: u8 = (s_317_7.value() as u8);
        // C s_317_9: const #22s : i
        let s_317_9: i128 = 22;
        // C s_317_10: const #1s : i
        let s_317_10: i128 = 1;
        // D s_317_11: read-var u#34259:u32
        let s_317_11: u32 = fn_state.u_34259;
        // D s_317_12: cast zx s_317_11 -> bv
        let s_317_12: Bits = Bits::new(s_317_11 as u128, 32u16);
        // D s_317_13: bit-extract s_317_12 s_317_9 s_317_10
        let s_317_13: Bits = (Bits::new(
            ((s_317_12) >> (s_317_9)).value(),
            u16::try_from(s_317_10).unwrap(),
        ));
        // D s_317_14: cast reint s_317_13 -> u8
        let s_317_14: bool = ((s_317_13.value()) != 0);
        // C s_317_15: const #12s : i
        let s_317_15: i128 = 12;
        // C s_317_16: const #4s : i
        let s_317_16: i128 = 4;
        // D s_317_17: read-var u#34259:u32
        let s_317_17: u32 = fn_state.u_34259;
        // D s_317_18: cast zx s_317_17 -> bv
        let s_317_18: Bits = Bits::new(s_317_17 as u128, 32u16);
        // D s_317_19: bit-extract s_317_18 s_317_15 s_317_16
        let s_317_19: Bits = (Bits::new(
            ((s_317_18) >> (s_317_15)).value(),
            u16::try_from(s_317_16).unwrap(),
        ));
        // D s_317_20: cast reint s_317_19 -> u8
        let s_317_20: u8 = (s_317_19.value() as u8);
        // C s_317_21: const #8s : i
        let s_317_21: i128 = 8;
        // C s_317_22: const #2s : i
        let s_317_22: i128 = 2;
        // D s_317_23: read-var u#34259:u32
        let s_317_23: u32 = fn_state.u_34259;
        // D s_317_24: cast zx s_317_23 -> bv
        let s_317_24: Bits = Bits::new(s_317_23 as u128, 32u16);
        // D s_317_25: bit-extract s_317_24 s_317_21 s_317_22
        let s_317_25: Bits = (Bits::new(
            ((s_317_24) >> (s_317_21)).value(),
            u16::try_from(s_317_22).unwrap(),
        ));
        // D s_317_26: cast reint s_317_25 -> u8
        let s_317_26: u8 = (s_317_25.value() as u8);
        // C s_317_27: const #5s : i
        let s_317_27: i128 = 5;
        // C s_317_28: const #1s : i
        let s_317_28: i128 = 1;
        // D s_317_29: read-var u#34259:u32
        let s_317_29: u32 = fn_state.u_34259;
        // D s_317_30: cast zx s_317_29 -> bv
        let s_317_30: Bits = Bits::new(s_317_29 as u128, 32u16);
        // D s_317_31: bit-extract s_317_30 s_317_27 s_317_28
        let s_317_31: Bits = (Bits::new(
            ((s_317_30) >> (s_317_27)).value(),
            u16::try_from(s_317_28).unwrap(),
        ));
        // D s_317_32: cast reint s_317_31 -> u8
        let s_317_32: bool = ((s_317_31.value()) != 0);
        // C s_317_33: const #0s : i
        let s_317_33: i128 = 0;
        // C s_317_34: const #4s : i
        let s_317_34: i128 = 4;
        // D s_317_35: read-var u#34259:u32
        let s_317_35: u32 = fn_state.u_34259;
        // D s_317_36: cast zx s_317_35 -> bv
        let s_317_36: Bits = Bits::new(s_317_35 as u128, 32u16);
        // D s_317_37: bit-extract s_317_36 s_317_33 s_317_34
        let s_317_37: Bits = (Bits::new(
            ((s_317_36) >> (s_317_33)).value(),
            u16::try_from(s_317_34).unwrap(),
        ));
        // D s_317_38: cast reint s_317_37 -> u8
        let s_317_38: u8 = (s_317_37.value() as u8);
        // D s_317_39: call decode_aarch32_instrs_VSQRT_A1enc_A_txt(s_317_8, s_317_14, s_317_20, s_317_26, s_317_32, s_317_38)
        let s_317_39: () = decode_aarch32_instrs_VSQRT_A1enc_A_txt(
            state,
            tracer,
            s_317_8,
            s_317_14,
            s_317_20,
            s_317_26,
            s_317_32,
            s_317_38,
        );
        // N s_317_40: return
        return;
    }
    fn block_318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_318_0: read-var merge#var.1:struct
        let s_318_0: u32 = fn_state.merge_var._1;
        // D s_318_1: write-var u#34267 <= s_318_0
        fn_state.u_34267 = s_318_0;
        // C s_318_2: const #25s : i
        let s_318_2: i128 = 25;
        // D s_318_3: read-var u#34267:u32
        let s_318_3: u32 = fn_state.u_34267;
        // D s_318_4: cast zx s_318_3 -> bv
        let s_318_4: Bits = Bits::new(s_318_3 as u128, 32u16);
        // C s_318_5: const #1s : i64
        let s_318_5: i64 = 1;
        // C s_318_6: cast zx s_318_5 -> i
        let s_318_6: i128 = (i128::try_from(s_318_5).unwrap());
        // C s_318_7: const #2s : i
        let s_318_7: i128 = 2;
        // C s_318_8: add s_318_7 s_318_6
        let s_318_8: i128 = (s_318_7 + s_318_6);
        // D s_318_9: bit-extract s_318_4 s_318_2 s_318_8
        let s_318_9: Bits = (Bits::new(
            ((s_318_4) >> (s_318_2)).value(),
            u16::try_from(s_318_8).unwrap(),
        ));
        // D s_318_10: cast reint s_318_9 -> u8
        let s_318_10: u8 = (s_318_9.value() as u8);
        // D s_318_11: cast zx s_318_10 -> bv
        let s_318_11: Bits = Bits::new(s_318_10 as u128, 3u16);
        // C s_318_12: const #6u : u8
        let s_318_12: u8 = 6;
        // C s_318_13: cast zx s_318_12 -> bv
        let s_318_13: Bits = Bits::new(s_318_12 as u128, 3u16);
        // D s_318_14: cmp-eq s_318_11 s_318_13
        let s_318_14: bool = ((s_318_11) == (s_318_13));
        // N s_318_15: branch s_318_14 b790 b319
        if s_318_14 {
            return block_790(state, tracer, fn_state);
        } else {
            return block_319(state, tracer, fn_state);
        };
    }
    fn block_319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_319_0: const #0u : u8
        let s_319_0: bool = false;
        // D s_319_1: write-var gs#413116 <= s_319_0
        fn_state.gs_413116 = s_319_0;
        // N s_319_2: jump b320
        return block_320(state, tracer, fn_state);
    }
    fn block_320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_320_0: read-var gs#413116:u8
        let s_320_0: bool = fn_state.gs_413116;
        // N s_320_1: branch s_320_0 b786 b321
        if s_320_0 {
            return block_786(state, tracer, fn_state);
        } else {
            return block_321(state, tracer, fn_state);
        };
    }
    fn block_321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_321_0: const #0u : u8
        let s_321_0: bool = false;
        // D s_321_1: write-var gs#413121 <= s_321_0
        fn_state.gs_413121 = s_321_0;
        // N s_321_2: jump b322
        return block_322(state, tracer, fn_state);
    }
    fn block_322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_322_0: read-var gs#413121:u8
        let s_322_0: bool = fn_state.gs_413121;
        // D s_322_1: not s_322_0
        let s_322_1: bool = !s_322_0;
        // N s_322_2: branch s_322_1 b324 b323
        if s_322_1 {
            return block_324(state, tracer, fn_state);
        } else {
            return block_323(state, tracer, fn_state);
        };
    }
    fn block_323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_323_0: const #3732s : i
        let s_323_0: i128 = 3732;
        // C s_323_1: const #14696u : u32
        let s_323_1: u32 = 14696;
        // N s_323_2: write-reg s_323_1 <= s_323_0
        let s_323_2: () = {
            state.write_register::<i128>(s_323_1 as isize, s_323_0);
            tracer.write_register(s_323_1 as isize, s_323_0);
        };
        // C s_323_3: const #28s : i
        let s_323_3: i128 = 28;
        // C s_323_4: const #4s : i
        let s_323_4: i128 = 4;
        // D s_323_5: read-var u#34267:u32
        let s_323_5: u32 = fn_state.u_34267;
        // D s_323_6: cast zx s_323_5 -> bv
        let s_323_6: Bits = Bits::new(s_323_5 as u128, 32u16);
        // D s_323_7: bit-extract s_323_6 s_323_3 s_323_4
        let s_323_7: Bits = (Bits::new(
            ((s_323_6) >> (s_323_3)).value(),
            u16::try_from(s_323_4).unwrap(),
        ));
        // D s_323_8: cast reint s_323_7 -> u8
        let s_323_8: u8 = (s_323_7.value() as u8);
        // C s_323_9: const #24s : i
        let s_323_9: i128 = 24;
        // C s_323_10: const #1s : i
        let s_323_10: i128 = 1;
        // D s_323_11: read-var u#34267:u32
        let s_323_11: u32 = fn_state.u_34267;
        // D s_323_12: cast zx s_323_11 -> bv
        let s_323_12: Bits = Bits::new(s_323_11 as u128, 32u16);
        // D s_323_13: bit-extract s_323_12 s_323_9 s_323_10
        let s_323_13: Bits = (Bits::new(
            ((s_323_12) >> (s_323_9)).value(),
            u16::try_from(s_323_10).unwrap(),
        ));
        // D s_323_14: cast reint s_323_13 -> u8
        let s_323_14: bool = ((s_323_13.value()) != 0);
        // C s_323_15: const #23s : i
        let s_323_15: i128 = 23;
        // C s_323_16: const #1s : i
        let s_323_16: i128 = 1;
        // D s_323_17: read-var u#34267:u32
        let s_323_17: u32 = fn_state.u_34267;
        // D s_323_18: cast zx s_323_17 -> bv
        let s_323_18: Bits = Bits::new(s_323_17 as u128, 32u16);
        // D s_323_19: bit-extract s_323_18 s_323_15 s_323_16
        let s_323_19: Bits = (Bits::new(
            ((s_323_18) >> (s_323_15)).value(),
            u16::try_from(s_323_16).unwrap(),
        ));
        // D s_323_20: cast reint s_323_19 -> u8
        let s_323_20: bool = ((s_323_19.value()) != 0);
        // C s_323_21: const #22s : i
        let s_323_21: i128 = 22;
        // C s_323_22: const #1s : i
        let s_323_22: i128 = 1;
        // D s_323_23: read-var u#34267:u32
        let s_323_23: u32 = fn_state.u_34267;
        // D s_323_24: cast zx s_323_23 -> bv
        let s_323_24: Bits = Bits::new(s_323_23 as u128, 32u16);
        // D s_323_25: bit-extract s_323_24 s_323_21 s_323_22
        let s_323_25: Bits = (Bits::new(
            ((s_323_24) >> (s_323_21)).value(),
            u16::try_from(s_323_22).unwrap(),
        ));
        // D s_323_26: cast reint s_323_25 -> u8
        let s_323_26: bool = ((s_323_25.value()) != 0);
        // C s_323_27: const #21s : i
        let s_323_27: i128 = 21;
        // C s_323_28: const #1s : i
        let s_323_28: i128 = 1;
        // D s_323_29: read-var u#34267:u32
        let s_323_29: u32 = fn_state.u_34267;
        // D s_323_30: cast zx s_323_29 -> bv
        let s_323_30: Bits = Bits::new(s_323_29 as u128, 32u16);
        // D s_323_31: bit-extract s_323_30 s_323_27 s_323_28
        let s_323_31: Bits = (Bits::new(
            ((s_323_30) >> (s_323_27)).value(),
            u16::try_from(s_323_28).unwrap(),
        ));
        // D s_323_32: cast reint s_323_31 -> u8
        let s_323_32: bool = ((s_323_31.value()) != 0);
        // C s_323_33: const #16s : i
        let s_323_33: i128 = 16;
        // C s_323_34: const #4s : i
        let s_323_34: i128 = 4;
        // D s_323_35: read-var u#34267:u32
        let s_323_35: u32 = fn_state.u_34267;
        // D s_323_36: cast zx s_323_35 -> bv
        let s_323_36: Bits = Bits::new(s_323_35 as u128, 32u16);
        // D s_323_37: bit-extract s_323_36 s_323_33 s_323_34
        let s_323_37: Bits = (Bits::new(
            ((s_323_36) >> (s_323_33)).value(),
            u16::try_from(s_323_34).unwrap(),
        ));
        // D s_323_38: cast reint s_323_37 -> u8
        let s_323_38: u8 = (s_323_37.value() as u8);
        // C s_323_39: const #12s : i
        let s_323_39: i128 = 12;
        // C s_323_40: const #4s : i
        let s_323_40: i128 = 4;
        // D s_323_41: read-var u#34267:u32
        let s_323_41: u32 = fn_state.u_34267;
        // D s_323_42: cast zx s_323_41 -> bv
        let s_323_42: Bits = Bits::new(s_323_41 as u128, 32u16);
        // D s_323_43: bit-extract s_323_42 s_323_39 s_323_40
        let s_323_43: Bits = (Bits::new(
            ((s_323_42) >> (s_323_39)).value(),
            u16::try_from(s_323_40).unwrap(),
        ));
        // D s_323_44: cast reint s_323_43 -> u8
        let s_323_44: u8 = (s_323_43.value() as u8);
        // C s_323_45: const #0s : i
        let s_323_45: i128 = 0;
        // C s_323_46: const #8s : i
        let s_323_46: i128 = 8;
        // D s_323_47: read-var u#34267:u32
        let s_323_47: u32 = fn_state.u_34267;
        // D s_323_48: cast zx s_323_47 -> bv
        let s_323_48: Bits = Bits::new(s_323_47 as u128, 32u16);
        // D s_323_49: bit-extract s_323_48 s_323_45 s_323_46
        let s_323_49: Bits = (Bits::new(
            ((s_323_48) >> (s_323_45)).value(),
            u16::try_from(s_323_46).unwrap(),
        ));
        // D s_323_50: cast reint s_323_49 -> u8
        let s_323_50: u8 = (s_323_49.value() as u8);
        // D s_323_51: call decode_aarch32_instrs_VSTM_A1enc_A_txt(s_323_8, s_323_14, s_323_20, s_323_26, s_323_32, s_323_38, s_323_44, s_323_50)
        let s_323_51: () = decode_aarch32_instrs_VSTM_A1enc_A_txt(
            state,
            tracer,
            s_323_8,
            s_323_14,
            s_323_20,
            s_323_26,
            s_323_32,
            s_323_38,
            s_323_44,
            s_323_50,
        );
        // N s_323_52: return
        return;
    }
    fn block_324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_324_0: read-var merge#var.1:struct
        let s_324_0: u32 = fn_state.merge_var._1;
        // D s_324_1: write-var u#34277 <= s_324_0
        fn_state.u_34277 = s_324_0;
        // C s_324_2: const #25s : i
        let s_324_2: i128 = 25;
        // D s_324_3: read-var u#34277:u32
        let s_324_3: u32 = fn_state.u_34277;
        // D s_324_4: cast zx s_324_3 -> bv
        let s_324_4: Bits = Bits::new(s_324_3 as u128, 32u16);
        // C s_324_5: const #1s : i64
        let s_324_5: i64 = 1;
        // C s_324_6: cast zx s_324_5 -> i
        let s_324_6: i128 = (i128::try_from(s_324_5).unwrap());
        // C s_324_7: const #2s : i
        let s_324_7: i128 = 2;
        // C s_324_8: add s_324_7 s_324_6
        let s_324_8: i128 = (s_324_7 + s_324_6);
        // D s_324_9: bit-extract s_324_4 s_324_2 s_324_8
        let s_324_9: Bits = (Bits::new(
            ((s_324_4) >> (s_324_2)).value(),
            u16::try_from(s_324_8).unwrap(),
        ));
        // D s_324_10: cast reint s_324_9 -> u8
        let s_324_10: u8 = (s_324_9.value() as u8);
        // D s_324_11: cast zx s_324_10 -> bv
        let s_324_11: Bits = Bits::new(s_324_10 as u128, 3u16);
        // C s_324_12: const #6u : u8
        let s_324_12: u8 = 6;
        // C s_324_13: cast zx s_324_12 -> bv
        let s_324_13: Bits = Bits::new(s_324_12 as u128, 3u16);
        // D s_324_14: cmp-eq s_324_11 s_324_13
        let s_324_14: bool = ((s_324_11) == (s_324_13));
        // N s_324_15: branch s_324_14 b782 b325
        if s_324_14 {
            return block_782(state, tracer, fn_state);
        } else {
            return block_325(state, tracer, fn_state);
        };
    }
    fn block_325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_325_0: const #0u : u8
        let s_325_0: bool = false;
        // D s_325_1: write-var gs#413148 <= s_325_0
        fn_state.gs_413148 = s_325_0;
        // N s_325_2: jump b326
        return block_326(state, tracer, fn_state);
    }
    fn block_326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_326_0: read-var gs#413148:u8
        let s_326_0: bool = fn_state.gs_413148;
        // N s_326_1: branch s_326_0 b778 b327
        if s_326_0 {
            return block_778(state, tracer, fn_state);
        } else {
            return block_327(state, tracer, fn_state);
        };
    }
    fn block_327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_327_0: const #0u : u8
        let s_327_0: bool = false;
        // D s_327_1: write-var gs#413153 <= s_327_0
        fn_state.gs_413153 = s_327_0;
        // N s_327_2: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_328_0: read-var gs#413153:u8
        let s_328_0: bool = fn_state.gs_413153;
        // D s_328_1: not s_328_0
        let s_328_1: bool = !s_328_0;
        // N s_328_2: branch s_328_1 b330 b329
        if s_328_1 {
            return block_330(state, tracer, fn_state);
        } else {
            return block_329(state, tracer, fn_state);
        };
    }
    fn block_329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_329_0: const #3733s : i
        let s_329_0: i128 = 3733;
        // C s_329_1: const #14696u : u32
        let s_329_1: u32 = 14696;
        // N s_329_2: write-reg s_329_1 <= s_329_0
        let s_329_2: () = {
            state.write_register::<i128>(s_329_1 as isize, s_329_0);
            tracer.write_register(s_329_1 as isize, s_329_0);
        };
        // C s_329_3: const #28s : i
        let s_329_3: i128 = 28;
        // C s_329_4: const #4s : i
        let s_329_4: i128 = 4;
        // D s_329_5: read-var u#34277:u32
        let s_329_5: u32 = fn_state.u_34277;
        // D s_329_6: cast zx s_329_5 -> bv
        let s_329_6: Bits = Bits::new(s_329_5 as u128, 32u16);
        // D s_329_7: bit-extract s_329_6 s_329_3 s_329_4
        let s_329_7: Bits = (Bits::new(
            ((s_329_6) >> (s_329_3)).value(),
            u16::try_from(s_329_4).unwrap(),
        ));
        // D s_329_8: cast reint s_329_7 -> u8
        let s_329_8: u8 = (s_329_7.value() as u8);
        // C s_329_9: const #24s : i
        let s_329_9: i128 = 24;
        // C s_329_10: const #1s : i
        let s_329_10: i128 = 1;
        // D s_329_11: read-var u#34277:u32
        let s_329_11: u32 = fn_state.u_34277;
        // D s_329_12: cast zx s_329_11 -> bv
        let s_329_12: Bits = Bits::new(s_329_11 as u128, 32u16);
        // D s_329_13: bit-extract s_329_12 s_329_9 s_329_10
        let s_329_13: Bits = (Bits::new(
            ((s_329_12) >> (s_329_9)).value(),
            u16::try_from(s_329_10).unwrap(),
        ));
        // D s_329_14: cast reint s_329_13 -> u8
        let s_329_14: bool = ((s_329_13.value()) != 0);
        // C s_329_15: const #23s : i
        let s_329_15: i128 = 23;
        // C s_329_16: const #1s : i
        let s_329_16: i128 = 1;
        // D s_329_17: read-var u#34277:u32
        let s_329_17: u32 = fn_state.u_34277;
        // D s_329_18: cast zx s_329_17 -> bv
        let s_329_18: Bits = Bits::new(s_329_17 as u128, 32u16);
        // D s_329_19: bit-extract s_329_18 s_329_15 s_329_16
        let s_329_19: Bits = (Bits::new(
            ((s_329_18) >> (s_329_15)).value(),
            u16::try_from(s_329_16).unwrap(),
        ));
        // D s_329_20: cast reint s_329_19 -> u8
        let s_329_20: bool = ((s_329_19.value()) != 0);
        // C s_329_21: const #22s : i
        let s_329_21: i128 = 22;
        // C s_329_22: const #1s : i
        let s_329_22: i128 = 1;
        // D s_329_23: read-var u#34277:u32
        let s_329_23: u32 = fn_state.u_34277;
        // D s_329_24: cast zx s_329_23 -> bv
        let s_329_24: Bits = Bits::new(s_329_23 as u128, 32u16);
        // D s_329_25: bit-extract s_329_24 s_329_21 s_329_22
        let s_329_25: Bits = (Bits::new(
            ((s_329_24) >> (s_329_21)).value(),
            u16::try_from(s_329_22).unwrap(),
        ));
        // D s_329_26: cast reint s_329_25 -> u8
        let s_329_26: bool = ((s_329_25.value()) != 0);
        // C s_329_27: const #21s : i
        let s_329_27: i128 = 21;
        // C s_329_28: const #1s : i
        let s_329_28: i128 = 1;
        // D s_329_29: read-var u#34277:u32
        let s_329_29: u32 = fn_state.u_34277;
        // D s_329_30: cast zx s_329_29 -> bv
        let s_329_30: Bits = Bits::new(s_329_29 as u128, 32u16);
        // D s_329_31: bit-extract s_329_30 s_329_27 s_329_28
        let s_329_31: Bits = (Bits::new(
            ((s_329_30) >> (s_329_27)).value(),
            u16::try_from(s_329_28).unwrap(),
        ));
        // D s_329_32: cast reint s_329_31 -> u8
        let s_329_32: bool = ((s_329_31.value()) != 0);
        // C s_329_33: const #16s : i
        let s_329_33: i128 = 16;
        // C s_329_34: const #4s : i
        let s_329_34: i128 = 4;
        // D s_329_35: read-var u#34277:u32
        let s_329_35: u32 = fn_state.u_34277;
        // D s_329_36: cast zx s_329_35 -> bv
        let s_329_36: Bits = Bits::new(s_329_35 as u128, 32u16);
        // D s_329_37: bit-extract s_329_36 s_329_33 s_329_34
        let s_329_37: Bits = (Bits::new(
            ((s_329_36) >> (s_329_33)).value(),
            u16::try_from(s_329_34).unwrap(),
        ));
        // D s_329_38: cast reint s_329_37 -> u8
        let s_329_38: u8 = (s_329_37.value() as u8);
        // C s_329_39: const #12s : i
        let s_329_39: i128 = 12;
        // C s_329_40: const #4s : i
        let s_329_40: i128 = 4;
        // D s_329_41: read-var u#34277:u32
        let s_329_41: u32 = fn_state.u_34277;
        // D s_329_42: cast zx s_329_41 -> bv
        let s_329_42: Bits = Bits::new(s_329_41 as u128, 32u16);
        // D s_329_43: bit-extract s_329_42 s_329_39 s_329_40
        let s_329_43: Bits = (Bits::new(
            ((s_329_42) >> (s_329_39)).value(),
            u16::try_from(s_329_40).unwrap(),
        ));
        // D s_329_44: cast reint s_329_43 -> u8
        let s_329_44: u8 = (s_329_43.value() as u8);
        // C s_329_45: const #0s : i
        let s_329_45: i128 = 0;
        // C s_329_46: const #8s : i
        let s_329_46: i128 = 8;
        // D s_329_47: read-var u#34277:u32
        let s_329_47: u32 = fn_state.u_34277;
        // D s_329_48: cast zx s_329_47 -> bv
        let s_329_48: Bits = Bits::new(s_329_47 as u128, 32u16);
        // D s_329_49: bit-extract s_329_48 s_329_45 s_329_46
        let s_329_49: Bits = (Bits::new(
            ((s_329_48) >> (s_329_45)).value(),
            u16::try_from(s_329_46).unwrap(),
        ));
        // D s_329_50: cast reint s_329_49 -> u8
        let s_329_50: u8 = (s_329_49.value() as u8);
        // D s_329_51: call decode_aarch32_instrs_VSTM_A2enc_A_txt(s_329_8, s_329_14, s_329_20, s_329_26, s_329_32, s_329_38, s_329_44, s_329_50)
        let s_329_51: () = decode_aarch32_instrs_VSTM_A2enc_A_txt(
            state,
            tracer,
            s_329_8,
            s_329_14,
            s_329_20,
            s_329_26,
            s_329_32,
            s_329_38,
            s_329_44,
            s_329_50,
        );
        // N s_329_52: return
        return;
    }
    fn block_330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_330_0: read-var merge#var.1:struct
        let s_330_0: u32 = fn_state.merge_var._1;
        // D s_330_1: write-var u#34287 <= s_330_0
        fn_state.u_34287 = s_330_0;
        // C s_330_2: const #24s : i
        let s_330_2: i128 = 24;
        // D s_330_3: read-var u#34287:u32
        let s_330_3: u32 = fn_state.u_34287;
        // D s_330_4: cast zx s_330_3 -> bv
        let s_330_4: Bits = Bits::new(s_330_3 as u128, 32u16);
        // C s_330_5: const #1s : i64
        let s_330_5: i64 = 1;
        // C s_330_6: cast zx s_330_5 -> i
        let s_330_6: i128 = (i128::try_from(s_330_5).unwrap());
        // C s_330_7: const #3s : i
        let s_330_7: i128 = 3;
        // C s_330_8: add s_330_7 s_330_6
        let s_330_8: i128 = (s_330_7 + s_330_6);
        // D s_330_9: bit-extract s_330_4 s_330_2 s_330_8
        let s_330_9: Bits = (Bits::new(
            ((s_330_4) >> (s_330_2)).value(),
            u16::try_from(s_330_8).unwrap(),
        ));
        // D s_330_10: cast reint s_330_9 -> u8
        let s_330_10: u8 = (s_330_9.value() as u8);
        // D s_330_11: cast zx s_330_10 -> bv
        let s_330_11: Bits = Bits::new(s_330_10 as u128, 4u16);
        // C s_330_12: const #13u : u8
        let s_330_12: u8 = 13;
        // C s_330_13: cast zx s_330_12 -> bv
        let s_330_13: Bits = Bits::new(s_330_12 as u128, 4u16);
        // D s_330_14: cmp-eq s_330_11 s_330_13
        let s_330_14: bool = ((s_330_11) == (s_330_13));
        // N s_330_15: branch s_330_14 b774 b331
        if s_330_14 {
            return block_774(state, tracer, fn_state);
        } else {
            return block_331(state, tracer, fn_state);
        };
    }
    fn block_331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_331_0: const #0u : u8
        let s_331_0: bool = false;
        // D s_331_1: write-var gs#413180 <= s_331_0
        fn_state.gs_413180 = s_331_0;
        // N s_331_2: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_332_0: read-var gs#413180:u8
        let s_332_0: bool = fn_state.gs_413180;
        // N s_332_1: branch s_332_0 b770 b333
        if s_332_0 {
            return block_770(state, tracer, fn_state);
        } else {
            return block_333(state, tracer, fn_state);
        };
    }
    fn block_333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_333_0: const #0u : u8
        let s_333_0: bool = false;
        // D s_333_1: write-var gs#413185 <= s_333_0
        fn_state.gs_413185 = s_333_0;
        // N s_333_2: jump b334
        return block_334(state, tracer, fn_state);
    }
    fn block_334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_334_0: read-var gs#413185:u8
        let s_334_0: bool = fn_state.gs_413185;
        // D s_334_1: not s_334_0
        let s_334_1: bool = !s_334_0;
        // N s_334_2: branch s_334_1 b336 b335
        if s_334_1 {
            return block_336(state, tracer, fn_state);
        } else {
            return block_335(state, tracer, fn_state);
        };
    }
    fn block_335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_335_0: const #3736s : i
        let s_335_0: i128 = 3736;
        // C s_335_1: const #14696u : u32
        let s_335_1: u32 = 14696;
        // N s_335_2: write-reg s_335_1 <= s_335_0
        let s_335_2: () = {
            state.write_register::<i128>(s_335_1 as isize, s_335_0);
            tracer.write_register(s_335_1 as isize, s_335_0);
        };
        // C s_335_3: const #28s : i
        let s_335_3: i128 = 28;
        // C s_335_4: const #4s : i
        let s_335_4: i128 = 4;
        // D s_335_5: read-var u#34287:u32
        let s_335_5: u32 = fn_state.u_34287;
        // D s_335_6: cast zx s_335_5 -> bv
        let s_335_6: Bits = Bits::new(s_335_5 as u128, 32u16);
        // D s_335_7: bit-extract s_335_6 s_335_3 s_335_4
        let s_335_7: Bits = (Bits::new(
            ((s_335_6) >> (s_335_3)).value(),
            u16::try_from(s_335_4).unwrap(),
        ));
        // D s_335_8: cast reint s_335_7 -> u8
        let s_335_8: u8 = (s_335_7.value() as u8);
        // C s_335_9: const #23s : i
        let s_335_9: i128 = 23;
        // C s_335_10: const #1s : i
        let s_335_10: i128 = 1;
        // D s_335_11: read-var u#34287:u32
        let s_335_11: u32 = fn_state.u_34287;
        // D s_335_12: cast zx s_335_11 -> bv
        let s_335_12: Bits = Bits::new(s_335_11 as u128, 32u16);
        // D s_335_13: bit-extract s_335_12 s_335_9 s_335_10
        let s_335_13: Bits = (Bits::new(
            ((s_335_12) >> (s_335_9)).value(),
            u16::try_from(s_335_10).unwrap(),
        ));
        // D s_335_14: cast reint s_335_13 -> u8
        let s_335_14: bool = ((s_335_13.value()) != 0);
        // C s_335_15: const #22s : i
        let s_335_15: i128 = 22;
        // C s_335_16: const #1s : i
        let s_335_16: i128 = 1;
        // D s_335_17: read-var u#34287:u32
        let s_335_17: u32 = fn_state.u_34287;
        // D s_335_18: cast zx s_335_17 -> bv
        let s_335_18: Bits = Bits::new(s_335_17 as u128, 32u16);
        // D s_335_19: bit-extract s_335_18 s_335_15 s_335_16
        let s_335_19: Bits = (Bits::new(
            ((s_335_18) >> (s_335_15)).value(),
            u16::try_from(s_335_16).unwrap(),
        ));
        // D s_335_20: cast reint s_335_19 -> u8
        let s_335_20: bool = ((s_335_19.value()) != 0);
        // C s_335_21: const #16s : i
        let s_335_21: i128 = 16;
        // C s_335_22: const #4s : i
        let s_335_22: i128 = 4;
        // D s_335_23: read-var u#34287:u32
        let s_335_23: u32 = fn_state.u_34287;
        // D s_335_24: cast zx s_335_23 -> bv
        let s_335_24: Bits = Bits::new(s_335_23 as u128, 32u16);
        // D s_335_25: bit-extract s_335_24 s_335_21 s_335_22
        let s_335_25: Bits = (Bits::new(
            ((s_335_24) >> (s_335_21)).value(),
            u16::try_from(s_335_22).unwrap(),
        ));
        // D s_335_26: cast reint s_335_25 -> u8
        let s_335_26: u8 = (s_335_25.value() as u8);
        // C s_335_27: const #12s : i
        let s_335_27: i128 = 12;
        // C s_335_28: const #4s : i
        let s_335_28: i128 = 4;
        // D s_335_29: read-var u#34287:u32
        let s_335_29: u32 = fn_state.u_34287;
        // D s_335_30: cast zx s_335_29 -> bv
        let s_335_30: Bits = Bits::new(s_335_29 as u128, 32u16);
        // D s_335_31: bit-extract s_335_30 s_335_27 s_335_28
        let s_335_31: Bits = (Bits::new(
            ((s_335_30) >> (s_335_27)).value(),
            u16::try_from(s_335_28).unwrap(),
        ));
        // D s_335_32: cast reint s_335_31 -> u8
        let s_335_32: u8 = (s_335_31.value() as u8);
        // C s_335_33: const #8s : i
        let s_335_33: i128 = 8;
        // C s_335_34: const #2s : i
        let s_335_34: i128 = 2;
        // D s_335_35: read-var u#34287:u32
        let s_335_35: u32 = fn_state.u_34287;
        // D s_335_36: cast zx s_335_35 -> bv
        let s_335_36: Bits = Bits::new(s_335_35 as u128, 32u16);
        // D s_335_37: bit-extract s_335_36 s_335_33 s_335_34
        let s_335_37: Bits = (Bits::new(
            ((s_335_36) >> (s_335_33)).value(),
            u16::try_from(s_335_34).unwrap(),
        ));
        // D s_335_38: cast reint s_335_37 -> u8
        let s_335_38: u8 = (s_335_37.value() as u8);
        // C s_335_39: const #0s : i
        let s_335_39: i128 = 0;
        // C s_335_40: const #8s : i
        let s_335_40: i128 = 8;
        // D s_335_41: read-var u#34287:u32
        let s_335_41: u32 = fn_state.u_34287;
        // D s_335_42: cast zx s_335_41 -> bv
        let s_335_42: Bits = Bits::new(s_335_41 as u128, 32u16);
        // D s_335_43: bit-extract s_335_42 s_335_39 s_335_40
        let s_335_43: Bits = (Bits::new(
            ((s_335_42) >> (s_335_39)).value(),
            u16::try_from(s_335_40).unwrap(),
        ));
        // D s_335_44: cast reint s_335_43 -> u8
        let s_335_44: u8 = (s_335_43.value() as u8);
        // D s_335_45: call decode_aarch32_instrs_VSTR_A1enc_A_txt(s_335_8, s_335_14, s_335_20, s_335_26, s_335_32, s_335_38, s_335_44)
        let s_335_45: () = decode_aarch32_instrs_VSTR_A1enc_A_txt(
            state,
            tracer,
            s_335_8,
            s_335_14,
            s_335_20,
            s_335_26,
            s_335_32,
            s_335_38,
            s_335_44,
        );
        // N s_335_46: return
        return;
    }
    fn block_336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_336_0: read-var merge#var.1:struct
        let s_336_0: u32 = fn_state.merge_var._1;
        // D s_336_1: write-var u#34296 <= s_336_0
        fn_state.u_34296 = s_336_0;
        // C s_336_2: const #23s : i
        let s_336_2: i128 = 23;
        // D s_336_3: read-var u#34296:u32
        let s_336_3: u32 = fn_state.u_34296;
        // D s_336_4: cast zx s_336_3 -> bv
        let s_336_4: Bits = Bits::new(s_336_3 as u128, 32u16);
        // C s_336_5: const #1s : i64
        let s_336_5: i64 = 1;
        // C s_336_6: cast zx s_336_5 -> i
        let s_336_6: i128 = (i128::try_from(s_336_5).unwrap());
        // C s_336_7: const #4s : i
        let s_336_7: i128 = 4;
        // C s_336_8: add s_336_7 s_336_6
        let s_336_8: i128 = (s_336_7 + s_336_6);
        // D s_336_9: bit-extract s_336_4 s_336_2 s_336_8
        let s_336_9: Bits = (Bits::new(
            ((s_336_4) >> (s_336_2)).value(),
            u16::try_from(s_336_8).unwrap(),
        ));
        // D s_336_10: cast reint s_336_9 -> u8
        let s_336_10: u8 = (s_336_9.value() as u8);
        // D s_336_11: cast zx s_336_10 -> bv
        let s_336_11: Bits = Bits::new(s_336_10 as u128, 5u16);
        // C s_336_12: const #28u : u8
        let s_336_12: u8 = 28;
        // C s_336_13: cast zx s_336_12 -> bv
        let s_336_13: Bits = Bits::new(s_336_12 as u128, 5u16);
        // D s_336_14: cmp-eq s_336_11 s_336_13
        let s_336_14: bool = ((s_336_11) == (s_336_13));
        // N s_336_15: branch s_336_14 b760 b337
        if s_336_14 {
            return block_760(state, tracer, fn_state);
        } else {
            return block_337(state, tracer, fn_state);
        };
    }
    fn block_337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_337_0: const #0u : u8
        let s_337_0: bool = false;
        // D s_337_1: write-var gs#413216 <= s_337_0
        fn_state.gs_413216 = s_337_0;
        // N s_337_2: jump b338
        return block_338(state, tracer, fn_state);
    }
    fn block_338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_338_0: read-var gs#413216:u8
        let s_338_0: bool = fn_state.gs_413216;
        // N s_338_1: branch s_338_0 b756 b339
        if s_338_0 {
            return block_756(state, tracer, fn_state);
        } else {
            return block_339(state, tracer, fn_state);
        };
    }
    fn block_339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_339_0: const #0u : u8
        let s_339_0: bool = false;
        // D s_339_1: write-var gs#413221 <= s_339_0
        fn_state.gs_413221 = s_339_0;
        // N s_339_2: jump b340
        return block_340(state, tracer, fn_state);
    }
    fn block_340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_340_0: read-var gs#413221:u8
        let s_340_0: bool = fn_state.gs_413221;
        // D s_340_1: not s_340_0
        let s_340_1: bool = !s_340_0;
        // N s_340_2: branch s_340_1 b342 b341
        if s_340_1 {
            return block_342(state, tracer, fn_state);
        } else {
            return block_341(state, tracer, fn_state);
        };
    }
    fn block_341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_341_0: const #3739s : i
        let s_341_0: i128 = 3739;
        // C s_341_1: const #14696u : u32
        let s_341_1: u32 = 14696;
        // N s_341_2: write-reg s_341_1 <= s_341_0
        let s_341_2: () = {
            state.write_register::<i128>(s_341_1 as isize, s_341_0);
            tracer.write_register(s_341_1 as isize, s_341_0);
        };
        // C s_341_3: const #28s : i
        let s_341_3: i128 = 28;
        // C s_341_4: const #4s : i
        let s_341_4: i128 = 4;
        // D s_341_5: read-var u#34296:u32
        let s_341_5: u32 = fn_state.u_34296;
        // D s_341_6: cast zx s_341_5 -> bv
        let s_341_6: Bits = Bits::new(s_341_5 as u128, 32u16);
        // D s_341_7: bit-extract s_341_6 s_341_3 s_341_4
        let s_341_7: Bits = (Bits::new(
            ((s_341_6) >> (s_341_3)).value(),
            u16::try_from(s_341_4).unwrap(),
        ));
        // D s_341_8: cast reint s_341_7 -> u8
        let s_341_8: u8 = (s_341_7.value() as u8);
        // C s_341_9: const #22s : i
        let s_341_9: i128 = 22;
        // C s_341_10: const #1s : i
        let s_341_10: i128 = 1;
        // D s_341_11: read-var u#34296:u32
        let s_341_11: u32 = fn_state.u_34296;
        // D s_341_12: cast zx s_341_11 -> bv
        let s_341_12: Bits = Bits::new(s_341_11 as u128, 32u16);
        // D s_341_13: bit-extract s_341_12 s_341_9 s_341_10
        let s_341_13: Bits = (Bits::new(
            ((s_341_12) >> (s_341_9)).value(),
            u16::try_from(s_341_10).unwrap(),
        ));
        // D s_341_14: cast reint s_341_13 -> u8
        let s_341_14: bool = ((s_341_13.value()) != 0);
        // C s_341_15: const #16s : i
        let s_341_15: i128 = 16;
        // C s_341_16: const #4s : i
        let s_341_16: i128 = 4;
        // D s_341_17: read-var u#34296:u32
        let s_341_17: u32 = fn_state.u_34296;
        // D s_341_18: cast zx s_341_17 -> bv
        let s_341_18: Bits = Bits::new(s_341_17 as u128, 32u16);
        // D s_341_19: bit-extract s_341_18 s_341_15 s_341_16
        let s_341_19: Bits = (Bits::new(
            ((s_341_18) >> (s_341_15)).value(),
            u16::try_from(s_341_16).unwrap(),
        ));
        // D s_341_20: cast reint s_341_19 -> u8
        let s_341_20: u8 = (s_341_19.value() as u8);
        // C s_341_21: const #12s : i
        let s_341_21: i128 = 12;
        // C s_341_22: const #4s : i
        let s_341_22: i128 = 4;
        // D s_341_23: read-var u#34296:u32
        let s_341_23: u32 = fn_state.u_34296;
        // D s_341_24: cast zx s_341_23 -> bv
        let s_341_24: Bits = Bits::new(s_341_23 as u128, 32u16);
        // D s_341_25: bit-extract s_341_24 s_341_21 s_341_22
        let s_341_25: Bits = (Bits::new(
            ((s_341_24) >> (s_341_21)).value(),
            u16::try_from(s_341_22).unwrap(),
        ));
        // D s_341_26: cast reint s_341_25 -> u8
        let s_341_26: u8 = (s_341_25.value() as u8);
        // C s_341_27: const #8s : i
        let s_341_27: i128 = 8;
        // C s_341_28: const #2s : i
        let s_341_28: i128 = 2;
        // D s_341_29: read-var u#34296:u32
        let s_341_29: u32 = fn_state.u_34296;
        // D s_341_30: cast zx s_341_29 -> bv
        let s_341_30: Bits = Bits::new(s_341_29 as u128, 32u16);
        // D s_341_31: bit-extract s_341_30 s_341_27 s_341_28
        let s_341_31: Bits = (Bits::new(
            ((s_341_30) >> (s_341_27)).value(),
            u16::try_from(s_341_28).unwrap(),
        ));
        // D s_341_32: cast reint s_341_31 -> u8
        let s_341_32: u8 = (s_341_31.value() as u8);
        // C s_341_33: const #7s : i
        let s_341_33: i128 = 7;
        // C s_341_34: const #1s : i
        let s_341_34: i128 = 1;
        // D s_341_35: read-var u#34296:u32
        let s_341_35: u32 = fn_state.u_34296;
        // D s_341_36: cast zx s_341_35 -> bv
        let s_341_36: Bits = Bits::new(s_341_35 as u128, 32u16);
        // D s_341_37: bit-extract s_341_36 s_341_33 s_341_34
        let s_341_37: Bits = (Bits::new(
            ((s_341_36) >> (s_341_33)).value(),
            u16::try_from(s_341_34).unwrap(),
        ));
        // D s_341_38: cast reint s_341_37 -> u8
        let s_341_38: bool = ((s_341_37.value()) != 0);
        // C s_341_39: const #5s : i
        let s_341_39: i128 = 5;
        // C s_341_40: const #1s : i
        let s_341_40: i128 = 1;
        // D s_341_41: read-var u#34296:u32
        let s_341_41: u32 = fn_state.u_34296;
        // D s_341_42: cast zx s_341_41 -> bv
        let s_341_42: Bits = Bits::new(s_341_41 as u128, 32u16);
        // D s_341_43: bit-extract s_341_42 s_341_39 s_341_40
        let s_341_43: Bits = (Bits::new(
            ((s_341_42) >> (s_341_39)).value(),
            u16::try_from(s_341_40).unwrap(),
        ));
        // D s_341_44: cast reint s_341_43 -> u8
        let s_341_44: bool = ((s_341_43.value()) != 0);
        // C s_341_45: const #0s : i
        let s_341_45: i128 = 0;
        // C s_341_46: const #4s : i
        let s_341_46: i128 = 4;
        // D s_341_47: read-var u#34296:u32
        let s_341_47: u32 = fn_state.u_34296;
        // D s_341_48: cast zx s_341_47 -> bv
        let s_341_48: Bits = Bits::new(s_341_47 as u128, 32u16);
        // D s_341_49: bit-extract s_341_48 s_341_45 s_341_46
        let s_341_49: Bits = (Bits::new(
            ((s_341_48) >> (s_341_45)).value(),
            u16::try_from(s_341_46).unwrap(),
        ));
        // D s_341_50: cast reint s_341_49 -> u8
        let s_341_50: u8 = (s_341_49.value() as u8);
        // D s_341_51: call decode_aarch32_instrs_VSUB_f_A2enc_A_txt(s_341_8, s_341_14, s_341_20, s_341_26, s_341_32, s_341_38, s_341_44, s_341_50)
        let s_341_51: () = decode_aarch32_instrs_VSUB_f_A2enc_A_txt(
            state,
            tracer,
            s_341_8,
            s_341_14,
            s_341_20,
            s_341_26,
            s_341_32,
            s_341_38,
            s_341_44,
            s_341_50,
        );
        // N s_341_52: return
        return;
    }
    fn block_342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_342_0: read-var merge#var.1:struct
        let s_342_0: u32 = fn_state.merge_var._1;
        // D s_342_1: write-var u#34306 <= s_342_0
        fn_state.u_34306 = s_342_0;
        // C s_342_2: const #20s : i
        let s_342_2: i128 = 20;
        // D s_342_3: read-var u#34306:u32
        let s_342_3: u32 = fn_state.u_34306;
        // D s_342_4: cast zx s_342_3 -> bv
        let s_342_4: Bits = Bits::new(s_342_3 as u128, 32u16);
        // C s_342_5: const #1s : i64
        let s_342_5: i64 = 1;
        // C s_342_6: cast zx s_342_5 -> i
        let s_342_6: i128 = (i128::try_from(s_342_5).unwrap());
        // C s_342_7: const #7s : i
        let s_342_7: i128 = 7;
        // C s_342_8: add s_342_7 s_342_6
        let s_342_8: i128 = (s_342_7 + s_342_6);
        // D s_342_9: bit-extract s_342_4 s_342_2 s_342_8
        let s_342_9: Bits = (Bits::new(
            ((s_342_4) >> (s_342_2)).value(),
            u16::try_from(s_342_8).unwrap(),
        ));
        // D s_342_10: cast reint s_342_9 -> u8
        let s_342_10: u8 = (s_342_9.value() as u8);
        // D s_342_11: cast zx s_342_10 -> bv
        let s_342_11: Bits = Bits::new(s_342_10 as u128, 8u16);
        // C s_342_12: const #239u : u8
        let s_342_12: u8 = 239;
        // C s_342_13: cast zx s_342_12 -> bv
        let s_342_13: Bits = Bits::new(s_342_12 as u128, 8u16);
        // D s_342_14: cmp-eq s_342_11 s_342_13
        let s_342_14: bool = ((s_342_11) == (s_342_13));
        // N s_342_15: branch s_342_14 b755 b343
        if s_342_14 {
            return block_755(state, tracer, fn_state);
        } else {
            return block_343(state, tracer, fn_state);
        };
    }
    fn block_343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_343_0: const #0u : u8
        let s_343_0: bool = false;
        // D s_343_1: write-var gs#413245 <= s_343_0
        fn_state.gs_413245 = s_343_0;
        // N s_343_2: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_344_0: read-var gs#413245:u8
        let s_344_0: bool = fn_state.gs_413245;
        // N s_344_1: branch s_344_0 b751 b345
        if s_344_0 {
            return block_751(state, tracer, fn_state);
        } else {
            return block_345(state, tracer, fn_state);
        };
    }
    fn block_345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_345_0: const #0u : u8
        let s_345_0: bool = false;
        // D s_345_1: write-var gs#413250 <= s_345_0
        fn_state.gs_413250 = s_345_0;
        // N s_345_2: jump b346
        return block_346(state, tracer, fn_state);
    }
    fn block_346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_346_0: read-var gs#413250:u8
        let s_346_0: bool = fn_state.gs_413250;
        // D s_346_1: not s_346_0
        let s_346_1: bool = !s_346_0;
        // N s_346_2: branch s_346_1 b365 b347
        if s_346_1 {
            return block_365(state, tracer, fn_state);
        } else {
            return block_347(state, tracer, fn_state);
        };
    }
    fn block_347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_347_0: const #3796s : i
        let s_347_0: i128 = 3796;
        // C s_347_1: const #14696u : u32
        let s_347_1: u32 = 14696;
        // N s_347_2: write-reg s_347_1 <= s_347_0
        let s_347_2: () = {
            state.write_register::<i128>(s_347_1 as isize, s_347_0);
            tracer.write_register(s_347_1 as isize, s_347_0);
        };
        // C s_347_3: const #28s : i
        let s_347_3: i128 = 28;
        // C s_347_4: const #4s : i
        let s_347_4: i128 = 4;
        // D s_347_5: read-var u#34306:u32
        let s_347_5: u32 = fn_state.u_34306;
        // D s_347_6: cast zx s_347_5 -> bv
        let s_347_6: Bits = Bits::new(s_347_5 as u128, 32u16);
        // D s_347_7: bit-extract s_347_6 s_347_3 s_347_4
        let s_347_7: Bits = (Bits::new(
            ((s_347_6) >> (s_347_3)).value(),
            u16::try_from(s_347_4).unwrap(),
        ));
        // D s_347_8: cast reint s_347_7 -> u8
        let s_347_8: u8 = (s_347_7.value() as u8);
        // D s_347_9: write-var u#34307 <= s_347_8
        fn_state.u_34307 = s_347_8;
        // C s_347_10: const #16s : i
        let s_347_10: i128 = 16;
        // C s_347_11: const #4s : i
        let s_347_11: i128 = 4;
        // D s_347_12: read-var u#34306:u32
        let s_347_12: u32 = fn_state.u_34306;
        // D s_347_13: cast zx s_347_12 -> bv
        let s_347_13: Bits = Bits::new(s_347_12 as u128, 32u16);
        // D s_347_14: bit-extract s_347_13 s_347_10 s_347_11
        let s_347_14: Bits = (Bits::new(
            ((s_347_13) >> (s_347_10)).value(),
            u16::try_from(s_347_11).unwrap(),
        ));
        // D s_347_15: cast reint s_347_14 -> u8
        let s_347_15: u8 = (s_347_14.value() as u8);
        // D s_347_16: write-var reg <= s_347_15
        fn_state.reg = s_347_15;
        // C s_347_17: const #12s : i
        let s_347_17: i128 = 12;
        // C s_347_18: const #4s : i
        let s_347_18: i128 = 4;
        // D s_347_19: read-var u#34306:u32
        let s_347_19: u32 = fn_state.u_34306;
        // D s_347_20: cast zx s_347_19 -> bv
        let s_347_20: Bits = Bits::new(s_347_19 as u128, 32u16);
        // D s_347_21: bit-extract s_347_20 s_347_17 s_347_18
        let s_347_21: Bits = (Bits::new(
            ((s_347_20) >> (s_347_17)).value(),
            u16::try_from(s_347_18).unwrap(),
        ));
        // D s_347_22: cast reint s_347_21 -> u8
        let s_347_22: u8 = (s_347_21.value() as u8);
        // D s_347_23: write-var u#34308 <= s_347_22
        fn_state.u_34308 = s_347_22;
        // C s_347_24: const #5s : i
        let s_347_24: i128 = 5;
        // D s_347_25: read-var u#34306:u32
        let s_347_25: u32 = fn_state.u_34306;
        // D s_347_26: cast zx s_347_25 -> bv
        let s_347_26: Bits = Bits::new(s_347_25 as u128, 32u16);
        // C s_347_27: const #1u : u64
        let s_347_27: u64 = 1;
        // D s_347_28: bit-extract s_347_26 s_347_24 s_347_27
        let s_347_28: Bits = (Bits::new(
            ((s_347_26) >> (s_347_24)).value(),
            u16::try_from(s_347_27).unwrap(),
        ));
        // D s_347_29: cast reint s_347_28 -> u8
        let s_347_29: bool = ((s_347_28.value()) != 0);
        // C s_347_30: const #0s : i
        let s_347_30: i128 = 0;
        // C s_347_31: const #0u : u64
        let s_347_31: u64 = 0;
        // D s_347_32: cast zx s_347_29 -> u64
        let s_347_32: u64 = (s_347_29 as u64);
        // C s_347_33: const #1u : u64
        let s_347_33: u64 = 1;
        // D s_347_34: and s_347_32 s_347_33
        let s_347_34: u64 = ((s_347_32) & (s_347_33));
        // D s_347_35: cmp-eq s_347_34 s_347_33
        let s_347_35: bool = ((s_347_34) == (s_347_33));
        // D s_347_36: lsl s_347_32 s_347_30
        let s_347_36: u64 = s_347_32 << s_347_30;
        // D s_347_37: or s_347_31 s_347_36
        let s_347_37: u64 = ((s_347_31) | (s_347_36));
        // D s_347_38: cmpl s_347_36
        let s_347_38: u64 = !s_347_36;
        // D s_347_39: and s_347_31 s_347_38
        let s_347_39: u64 = ((s_347_31) & (s_347_38));
        // D s_347_40: select s_347_35 s_347_37 s_347_39
        let s_347_40: u64 = if s_347_35 { s_347_37 } else { s_347_39 };
        // D s_347_41: cast trunc s_347_40 -> u8
        let s_347_41: bool = ((s_347_40) != 0);
        // D s_347_42: cast zx s_347_41 -> bv
        let s_347_42: Bits = Bits::new(s_347_41 as u128, 1u16);
        // C s_347_43: const #0u : u8
        let s_347_43: bool = false;
        // C s_347_44: cast zx s_347_43 -> bv
        let s_347_44: Bits = Bits::new(s_347_43 as u128, 1u16);
        // D s_347_45: cmp-ne s_347_42 s_347_44
        let s_347_45: bool = ((s_347_42) != (s_347_44));
        // N s_347_46: branch s_347_45 b364 b348
        if s_347_45 {
            return block_364(state, tracer, fn_state);
        } else {
            return block_348(state, tracer, fn_state);
        };
    }
    fn block_348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_348_0: const #6s : i
        let s_348_0: i128 = 6;
        // D s_348_1: read-var u#34306:u32
        let s_348_1: u32 = fn_state.u_34306;
        // D s_348_2: cast zx s_348_1 -> bv
        let s_348_2: Bits = Bits::new(s_348_1 as u128, 32u16);
        // C s_348_3: const #1u : u64
        let s_348_3: u64 = 1;
        // D s_348_4: bit-extract s_348_2 s_348_0 s_348_3
        let s_348_4: Bits = (Bits::new(
            ((s_348_2) >> (s_348_0)).value(),
            u16::try_from(s_348_3).unwrap(),
        ));
        // D s_348_5: cast reint s_348_4 -> u8
        let s_348_5: bool = ((s_348_4.value()) != 0);
        // C s_348_6: const #0s : i
        let s_348_6: i128 = 0;
        // C s_348_7: const #0u : u64
        let s_348_7: u64 = 0;
        // D s_348_8: cast zx s_348_5 -> u64
        let s_348_8: u64 = (s_348_5 as u64);
        // C s_348_9: const #1u : u64
        let s_348_9: u64 = 1;
        // D s_348_10: and s_348_8 s_348_9
        let s_348_10: u64 = ((s_348_8) & (s_348_9));
        // D s_348_11: cmp-eq s_348_10 s_348_9
        let s_348_11: bool = ((s_348_10) == (s_348_9));
        // D s_348_12: lsl s_348_8 s_348_6
        let s_348_12: u64 = s_348_8 << s_348_6;
        // D s_348_13: or s_348_7 s_348_12
        let s_348_13: u64 = ((s_348_7) | (s_348_12));
        // D s_348_14: cmpl s_348_12
        let s_348_14: u64 = !s_348_12;
        // D s_348_15: and s_348_7 s_348_14
        let s_348_15: u64 = ((s_348_7) & (s_348_14));
        // D s_348_16: select s_348_11 s_348_13 s_348_15
        let s_348_16: u64 = if s_348_11 { s_348_13 } else { s_348_15 };
        // D s_348_17: cast trunc s_348_16 -> u8
        let s_348_17: bool = ((s_348_16) != 0);
        // D s_348_18: cast zx s_348_17 -> bv
        let s_348_18: Bits = Bits::new(s_348_17 as u128, 1u16);
        // C s_348_19: const #0u : u8
        let s_348_19: bool = false;
        // C s_348_20: cast zx s_348_19 -> bv
        let s_348_20: Bits = Bits::new(s_348_19 as u128, 1u16);
        // D s_348_21: cmp-ne s_348_18 s_348_20
        let s_348_21: bool = ((s_348_18) != (s_348_20));
        // D s_348_22: write-var gs#413263 <= s_348_21
        fn_state.gs_413263 = s_348_21;
        // N s_348_23: jump b349
        return block_349(state, tracer, fn_state);
    }
    fn block_349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_349_0: read-var gs#413263:u8
        let s_349_0: bool = fn_state.gs_413263;
        // N s_349_1: branch s_349_0 b363 b350
        if s_349_0 {
            return block_363(state, tracer, fn_state);
        } else {
            return block_350(state, tracer, fn_state);
        };
    }
    fn block_350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_350_0: const #0s : i
        let s_350_0: i128 = 0;
        // D s_350_1: read-var u#34306:u32
        let s_350_1: u32 = fn_state.u_34306;
        // D s_350_2: cast zx s_350_1 -> bv
        let s_350_2: Bits = Bits::new(s_350_1 as u128, 32u16);
        // C s_350_3: const #1u : u64
        let s_350_3: u64 = 1;
        // D s_350_4: bit-extract s_350_2 s_350_0 s_350_3
        let s_350_4: Bits = (Bits::new(
            ((s_350_2) >> (s_350_0)).value(),
            u16::try_from(s_350_3).unwrap(),
        ));
        // D s_350_5: cast reint s_350_4 -> u8
        let s_350_5: bool = ((s_350_4.value()) != 0);
        // C s_350_6: const #0s : i
        let s_350_6: i128 = 0;
        // C s_350_7: const #0u : u64
        let s_350_7: u64 = 0;
        // D s_350_8: cast zx s_350_5 -> u64
        let s_350_8: u64 = (s_350_5 as u64);
        // C s_350_9: const #1u : u64
        let s_350_9: u64 = 1;
        // D s_350_10: and s_350_8 s_350_9
        let s_350_10: u64 = ((s_350_8) & (s_350_9));
        // D s_350_11: cmp-eq s_350_10 s_350_9
        let s_350_11: bool = ((s_350_10) == (s_350_9));
        // D s_350_12: lsl s_350_8 s_350_6
        let s_350_12: u64 = s_350_8 << s_350_6;
        // D s_350_13: or s_350_7 s_350_12
        let s_350_13: u64 = ((s_350_7) | (s_350_12));
        // D s_350_14: cmpl s_350_12
        let s_350_14: u64 = !s_350_12;
        // D s_350_15: and s_350_7 s_350_14
        let s_350_15: u64 = ((s_350_7) & (s_350_14));
        // D s_350_16: select s_350_11 s_350_13 s_350_15
        let s_350_16: u64 = if s_350_11 { s_350_13 } else { s_350_15 };
        // D s_350_17: cast trunc s_350_16 -> u8
        let s_350_17: bool = ((s_350_16) != 0);
        // D s_350_18: cast zx s_350_17 -> bv
        let s_350_18: Bits = Bits::new(s_350_17 as u128, 1u16);
        // C s_350_19: const #0u : u8
        let s_350_19: bool = false;
        // C s_350_20: cast zx s_350_19 -> bv
        let s_350_20: Bits = Bits::new(s_350_19 as u128, 1u16);
        // D s_350_21: cmp-ne s_350_18 s_350_20
        let s_350_21: bool = ((s_350_18) != (s_350_20));
        // D s_350_22: write-var gs#413266 <= s_350_21
        fn_state.gs_413266 = s_350_21;
        // N s_350_23: jump b351
        return block_351(state, tracer, fn_state);
    }
    fn block_351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_351_0: read-var gs#413266:u8
        let s_351_0: bool = fn_state.gs_413266;
        // N s_351_1: branch s_351_0 b362 b352
        if s_351_0 {
            return block_362(state, tracer, fn_state);
        } else {
            return block_352(state, tracer, fn_state);
        };
    }
    fn block_352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_352_0: const #1s : i
        let s_352_0: i128 = 1;
        // D s_352_1: read-var u#34306:u32
        let s_352_1: u32 = fn_state.u_34306;
        // D s_352_2: cast zx s_352_1 -> bv
        let s_352_2: Bits = Bits::new(s_352_1 as u128, 32u16);
        // C s_352_3: const #1u : u64
        let s_352_3: u64 = 1;
        // D s_352_4: bit-extract s_352_2 s_352_0 s_352_3
        let s_352_4: Bits = (Bits::new(
            ((s_352_2) >> (s_352_0)).value(),
            u16::try_from(s_352_3).unwrap(),
        ));
        // D s_352_5: cast reint s_352_4 -> u8
        let s_352_5: bool = ((s_352_4.value()) != 0);
        // C s_352_6: const #0s : i
        let s_352_6: i128 = 0;
        // C s_352_7: const #0u : u64
        let s_352_7: u64 = 0;
        // D s_352_8: cast zx s_352_5 -> u64
        let s_352_8: u64 = (s_352_5 as u64);
        // C s_352_9: const #1u : u64
        let s_352_9: u64 = 1;
        // D s_352_10: and s_352_8 s_352_9
        let s_352_10: u64 = ((s_352_8) & (s_352_9));
        // D s_352_11: cmp-eq s_352_10 s_352_9
        let s_352_11: bool = ((s_352_10) == (s_352_9));
        // D s_352_12: lsl s_352_8 s_352_6
        let s_352_12: u64 = s_352_8 << s_352_6;
        // D s_352_13: or s_352_7 s_352_12
        let s_352_13: u64 = ((s_352_7) | (s_352_12));
        // D s_352_14: cmpl s_352_12
        let s_352_14: u64 = !s_352_12;
        // D s_352_15: and s_352_7 s_352_14
        let s_352_15: u64 = ((s_352_7) & (s_352_14));
        // D s_352_16: select s_352_11 s_352_13 s_352_15
        let s_352_16: u64 = if s_352_11 { s_352_13 } else { s_352_15 };
        // D s_352_17: cast trunc s_352_16 -> u8
        let s_352_17: bool = ((s_352_16) != 0);
        // D s_352_18: cast zx s_352_17 -> bv
        let s_352_18: Bits = Bits::new(s_352_17 as u128, 1u16);
        // C s_352_19: const #0u : u8
        let s_352_19: bool = false;
        // C s_352_20: cast zx s_352_19 -> bv
        let s_352_20: Bits = Bits::new(s_352_19 as u128, 1u16);
        // D s_352_21: cmp-ne s_352_18 s_352_20
        let s_352_21: bool = ((s_352_18) != (s_352_20));
        // D s_352_22: write-var gs#413269 <= s_352_21
        fn_state.gs_413269 = s_352_21;
        // N s_352_23: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_353_0: read-var gs#413269:u8
        let s_353_0: bool = fn_state.gs_413269;
        // N s_353_1: branch s_353_0 b361 b354
        if s_353_0 {
            return block_361(state, tracer, fn_state);
        } else {
            return block_354(state, tracer, fn_state);
        };
    }
    fn block_354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_354_0: const #2s : i
        let s_354_0: i128 = 2;
        // D s_354_1: read-var u#34306:u32
        let s_354_1: u32 = fn_state.u_34306;
        // D s_354_2: cast zx s_354_1 -> bv
        let s_354_2: Bits = Bits::new(s_354_1 as u128, 32u16);
        // C s_354_3: const #1u : u64
        let s_354_3: u64 = 1;
        // D s_354_4: bit-extract s_354_2 s_354_0 s_354_3
        let s_354_4: Bits = (Bits::new(
            ((s_354_2) >> (s_354_0)).value(),
            u16::try_from(s_354_3).unwrap(),
        ));
        // D s_354_5: cast reint s_354_4 -> u8
        let s_354_5: bool = ((s_354_4.value()) != 0);
        // C s_354_6: const #0s : i
        let s_354_6: i128 = 0;
        // C s_354_7: const #0u : u64
        let s_354_7: u64 = 0;
        // D s_354_8: cast zx s_354_5 -> u64
        let s_354_8: u64 = (s_354_5 as u64);
        // C s_354_9: const #1u : u64
        let s_354_9: u64 = 1;
        // D s_354_10: and s_354_8 s_354_9
        let s_354_10: u64 = ((s_354_8) & (s_354_9));
        // D s_354_11: cmp-eq s_354_10 s_354_9
        let s_354_11: bool = ((s_354_10) == (s_354_9));
        // D s_354_12: lsl s_354_8 s_354_6
        let s_354_12: u64 = s_354_8 << s_354_6;
        // D s_354_13: or s_354_7 s_354_12
        let s_354_13: u64 = ((s_354_7) | (s_354_12));
        // D s_354_14: cmpl s_354_12
        let s_354_14: u64 = !s_354_12;
        // D s_354_15: and s_354_7 s_354_14
        let s_354_15: u64 = ((s_354_7) & (s_354_14));
        // D s_354_16: select s_354_11 s_354_13 s_354_15
        let s_354_16: u64 = if s_354_11 { s_354_13 } else { s_354_15 };
        // D s_354_17: cast trunc s_354_16 -> u8
        let s_354_17: bool = ((s_354_16) != 0);
        // D s_354_18: cast zx s_354_17 -> bv
        let s_354_18: Bits = Bits::new(s_354_17 as u128, 1u16);
        // C s_354_19: const #0u : u8
        let s_354_19: bool = false;
        // C s_354_20: cast zx s_354_19 -> bv
        let s_354_20: Bits = Bits::new(s_354_19 as u128, 1u16);
        // D s_354_21: cmp-ne s_354_18 s_354_20
        let s_354_21: bool = ((s_354_18) != (s_354_20));
        // D s_354_22: write-var gs#413272 <= s_354_21
        fn_state.gs_413272 = s_354_21;
        // N s_354_23: jump b355
        return block_355(state, tracer, fn_state);
    }
    fn block_355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_355_0: read-var gs#413272:u8
        let s_355_0: bool = fn_state.gs_413272;
        // N s_355_1: branch s_355_0 b360 b356
        if s_355_0 {
            return block_360(state, tracer, fn_state);
        } else {
            return block_356(state, tracer, fn_state);
        };
    }
    fn block_356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_356_0: const #3s : i
        let s_356_0: i128 = 3;
        // D s_356_1: read-var u#34306:u32
        let s_356_1: u32 = fn_state.u_34306;
        // D s_356_2: cast zx s_356_1 -> bv
        let s_356_2: Bits = Bits::new(s_356_1 as u128, 32u16);
        // C s_356_3: const #1u : u64
        let s_356_3: u64 = 1;
        // D s_356_4: bit-extract s_356_2 s_356_0 s_356_3
        let s_356_4: Bits = (Bits::new(
            ((s_356_2) >> (s_356_0)).value(),
            u16::try_from(s_356_3).unwrap(),
        ));
        // D s_356_5: cast reint s_356_4 -> u8
        let s_356_5: bool = ((s_356_4.value()) != 0);
        // C s_356_6: const #0s : i
        let s_356_6: i128 = 0;
        // C s_356_7: const #0u : u64
        let s_356_7: u64 = 0;
        // D s_356_8: cast zx s_356_5 -> u64
        let s_356_8: u64 = (s_356_5 as u64);
        // C s_356_9: const #1u : u64
        let s_356_9: u64 = 1;
        // D s_356_10: and s_356_8 s_356_9
        let s_356_10: u64 = ((s_356_8) & (s_356_9));
        // D s_356_11: cmp-eq s_356_10 s_356_9
        let s_356_11: bool = ((s_356_10) == (s_356_9));
        // D s_356_12: lsl s_356_8 s_356_6
        let s_356_12: u64 = s_356_8 << s_356_6;
        // D s_356_13: or s_356_7 s_356_12
        let s_356_13: u64 = ((s_356_7) | (s_356_12));
        // D s_356_14: cmpl s_356_12
        let s_356_14: u64 = !s_356_12;
        // D s_356_15: and s_356_7 s_356_14
        let s_356_15: u64 = ((s_356_7) & (s_356_14));
        // D s_356_16: select s_356_11 s_356_13 s_356_15
        let s_356_16: u64 = if s_356_11 { s_356_13 } else { s_356_15 };
        // D s_356_17: cast trunc s_356_16 -> u8
        let s_356_17: bool = ((s_356_16) != 0);
        // D s_356_18: cast zx s_356_17 -> bv
        let s_356_18: Bits = Bits::new(s_356_17 as u128, 1u16);
        // C s_356_19: const #0u : u8
        let s_356_19: bool = false;
        // C s_356_20: cast zx s_356_19 -> bv
        let s_356_20: Bits = Bits::new(s_356_19 as u128, 1u16);
        // D s_356_21: cmp-ne s_356_18 s_356_20
        let s_356_21: bool = ((s_356_18) != (s_356_20));
        // D s_356_22: write-var gs#413275 <= s_356_21
        fn_state.gs_413275 = s_356_21;
        // N s_356_23: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_357_0: read-var gs#413275:u8
        let s_357_0: bool = fn_state.gs_413275;
        // N s_357_1: branch s_357_0 b359 b358
        if s_357_0 {
            return block_359(state, tracer, fn_state);
        } else {
            return block_358(state, tracer, fn_state);
        };
    }
    fn block_358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_358_0: read-var u#34307:u8
        let s_358_0: u8 = fn_state.u_34307;
        // D s_358_1: read-var reg:u8
        let s_358_1: u8 = fn_state.reg;
        // D s_358_2: read-var u#34308:u8
        let s_358_2: u8 = fn_state.u_34308;
        // D s_358_3: call decode_aarch32_instrs_VMRS_A1enc_AS_txt(s_358_0, s_358_1, s_358_2)
        let s_358_3: () = decode_aarch32_instrs_VMRS_A1enc_AS_txt(
            state,
            tracer,
            s_358_0,
            s_358_1,
            s_358_2,
        );
        // N s_358_4: return
        return;
    }
    fn block_359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_359_0: panic
        panic!("{:?}", ());
        // N s_359_1: return
        return;
    }
    fn block_360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_360_0: const #1u : u8
        let s_360_0: bool = true;
        // D s_360_1: write-var gs#413275 <= s_360_0
        fn_state.gs_413275 = s_360_0;
        // N s_360_2: jump b357
        return block_357(state, tracer, fn_state);
    }
    fn block_361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_361_0: const #1u : u8
        let s_361_0: bool = true;
        // D s_361_1: write-var gs#413272 <= s_361_0
        fn_state.gs_413272 = s_361_0;
        // N s_361_2: jump b355
        return block_355(state, tracer, fn_state);
    }
    fn block_362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_362_0: const #1u : u8
        let s_362_0: bool = true;
        // D s_362_1: write-var gs#413269 <= s_362_0
        fn_state.gs_413269 = s_362_0;
        // N s_362_2: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_363_0: const #1u : u8
        let s_363_0: bool = true;
        // D s_363_1: write-var gs#413266 <= s_363_0
        fn_state.gs_413266 = s_363_0;
        // N s_363_2: jump b351
        return block_351(state, tracer, fn_state);
    }
    fn block_364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_364_0: const #1u : u8
        let s_364_0: bool = true;
        // D s_364_1: write-var gs#413263 <= s_364_0
        fn_state.gs_413263 = s_364_0;
        // N s_364_2: jump b349
        return block_349(state, tracer, fn_state);
    }
    fn block_365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_365_0: read-var merge#var.1:struct
        let s_365_0: u32 = fn_state.merge_var._1;
        // D s_365_1: write-var u#34310 <= s_365_0
        fn_state.u_34310 = s_365_0;
        // C s_365_2: const #20s : i
        let s_365_2: i128 = 20;
        // D s_365_3: read-var u#34310:u32
        let s_365_3: u32 = fn_state.u_34310;
        // D s_365_4: cast zx s_365_3 -> bv
        let s_365_4: Bits = Bits::new(s_365_3 as u128, 32u16);
        // C s_365_5: const #1s : i64
        let s_365_5: i64 = 1;
        // C s_365_6: cast zx s_365_5 -> i
        let s_365_6: i128 = (i128::try_from(s_365_5).unwrap());
        // C s_365_7: const #7s : i
        let s_365_7: i128 = 7;
        // C s_365_8: add s_365_7 s_365_6
        let s_365_8: i128 = (s_365_7 + s_365_6);
        // D s_365_9: bit-extract s_365_4 s_365_2 s_365_8
        let s_365_9: Bits = (Bits::new(
            ((s_365_4) >> (s_365_2)).value(),
            u16::try_from(s_365_8).unwrap(),
        ));
        // D s_365_10: cast reint s_365_9 -> u8
        let s_365_10: u8 = (s_365_9.value() as u8);
        // D s_365_11: cast zx s_365_10 -> bv
        let s_365_11: Bits = Bits::new(s_365_10 as u128, 8u16);
        // C s_365_12: const #238u : u8
        let s_365_12: u8 = 238;
        // C s_365_13: cast zx s_365_12 -> bv
        let s_365_13: Bits = Bits::new(s_365_12 as u128, 8u16);
        // D s_365_14: cmp-eq s_365_11 s_365_13
        let s_365_14: bool = ((s_365_11) == (s_365_13));
        // N s_365_15: branch s_365_14 b750 b366
        if s_365_14 {
            return block_750(state, tracer, fn_state);
        } else {
            return block_366(state, tracer, fn_state);
        };
    }
    fn block_366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_366_0: const #0u : u8
        let s_366_0: bool = false;
        // D s_366_1: write-var gs#413281 <= s_366_0
        fn_state.gs_413281 = s_366_0;
        // N s_366_2: jump b367
        return block_367(state, tracer, fn_state);
    }
    fn block_367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_367_0: read-var gs#413281:u8
        let s_367_0: bool = fn_state.gs_413281;
        // N s_367_1: branch s_367_0 b746 b368
        if s_367_0 {
            return block_746(state, tracer, fn_state);
        } else {
            return block_368(state, tracer, fn_state);
        };
    }
    fn block_368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_368_0: const #0u : u8
        let s_368_0: bool = false;
        // D s_368_1: write-var gs#413286 <= s_368_0
        fn_state.gs_413286 = s_368_0;
        // N s_368_2: jump b369
        return block_369(state, tracer, fn_state);
    }
    fn block_369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_369_0: read-var gs#413286:u8
        let s_369_0: bool = fn_state.gs_413286;
        // D s_369_1: not s_369_0
        let s_369_1: bool = !s_369_0;
        // N s_369_2: branch s_369_1 b388 b370
        if s_369_1 {
            return block_388(state, tracer, fn_state);
        } else {
            return block_370(state, tracer, fn_state);
        };
    }
    fn block_370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_370_0: const #3798s : i
        let s_370_0: i128 = 3798;
        // C s_370_1: const #14696u : u32
        let s_370_1: u32 = 14696;
        // N s_370_2: write-reg s_370_1 <= s_370_0
        let s_370_2: () = {
            state.write_register::<i128>(s_370_1 as isize, s_370_0);
            tracer.write_register(s_370_1 as isize, s_370_0);
        };
        // C s_370_3: const #28s : i
        let s_370_3: i128 = 28;
        // C s_370_4: const #4s : i
        let s_370_4: i128 = 4;
        // D s_370_5: read-var u#34310:u32
        let s_370_5: u32 = fn_state.u_34310;
        // D s_370_6: cast zx s_370_5 -> bv
        let s_370_6: Bits = Bits::new(s_370_5 as u128, 32u16);
        // D s_370_7: bit-extract s_370_6 s_370_3 s_370_4
        let s_370_7: Bits = (Bits::new(
            ((s_370_6) >> (s_370_3)).value(),
            u16::try_from(s_370_4).unwrap(),
        ));
        // D s_370_8: cast reint s_370_7 -> u8
        let s_370_8: u8 = (s_370_7.value() as u8);
        // D s_370_9: write-var u#34311 <= s_370_8
        fn_state.u_34311 = s_370_8;
        // C s_370_10: const #16s : i
        let s_370_10: i128 = 16;
        // C s_370_11: const #4s : i
        let s_370_11: i128 = 4;
        // D s_370_12: read-var u#34310:u32
        let s_370_12: u32 = fn_state.u_34310;
        // D s_370_13: cast zx s_370_12 -> bv
        let s_370_13: Bits = Bits::new(s_370_12 as u128, 32u16);
        // D s_370_14: bit-extract s_370_13 s_370_10 s_370_11
        let s_370_14: Bits = (Bits::new(
            ((s_370_13) >> (s_370_10)).value(),
            u16::try_from(s_370_11).unwrap(),
        ));
        // D s_370_15: cast reint s_370_14 -> u8
        let s_370_15: u8 = (s_370_14.value() as u8);
        // D s_370_16: write-var u#34312 <= s_370_15
        fn_state.u_34312 = s_370_15;
        // C s_370_17: const #12s : i
        let s_370_17: i128 = 12;
        // C s_370_18: const #4s : i
        let s_370_18: i128 = 4;
        // D s_370_19: read-var u#34310:u32
        let s_370_19: u32 = fn_state.u_34310;
        // D s_370_20: cast zx s_370_19 -> bv
        let s_370_20: Bits = Bits::new(s_370_19 as u128, 32u16);
        // D s_370_21: bit-extract s_370_20 s_370_17 s_370_18
        let s_370_21: Bits = (Bits::new(
            ((s_370_20) >> (s_370_17)).value(),
            u16::try_from(s_370_18).unwrap(),
        ));
        // D s_370_22: cast reint s_370_21 -> u8
        let s_370_22: u8 = (s_370_21.value() as u8);
        // D s_370_23: write-var u#34313 <= s_370_22
        fn_state.u_34313 = s_370_22;
        // C s_370_24: const #5s : i
        let s_370_24: i128 = 5;
        // D s_370_25: read-var u#34310:u32
        let s_370_25: u32 = fn_state.u_34310;
        // D s_370_26: cast zx s_370_25 -> bv
        let s_370_26: Bits = Bits::new(s_370_25 as u128, 32u16);
        // C s_370_27: const #1u : u64
        let s_370_27: u64 = 1;
        // D s_370_28: bit-extract s_370_26 s_370_24 s_370_27
        let s_370_28: Bits = (Bits::new(
            ((s_370_26) >> (s_370_24)).value(),
            u16::try_from(s_370_27).unwrap(),
        ));
        // D s_370_29: cast reint s_370_28 -> u8
        let s_370_29: bool = ((s_370_28.value()) != 0);
        // C s_370_30: const #0s : i
        let s_370_30: i128 = 0;
        // C s_370_31: const #0u : u64
        let s_370_31: u64 = 0;
        // D s_370_32: cast zx s_370_29 -> u64
        let s_370_32: u64 = (s_370_29 as u64);
        // C s_370_33: const #1u : u64
        let s_370_33: u64 = 1;
        // D s_370_34: and s_370_32 s_370_33
        let s_370_34: u64 = ((s_370_32) & (s_370_33));
        // D s_370_35: cmp-eq s_370_34 s_370_33
        let s_370_35: bool = ((s_370_34) == (s_370_33));
        // D s_370_36: lsl s_370_32 s_370_30
        let s_370_36: u64 = s_370_32 << s_370_30;
        // D s_370_37: or s_370_31 s_370_36
        let s_370_37: u64 = ((s_370_31) | (s_370_36));
        // D s_370_38: cmpl s_370_36
        let s_370_38: u64 = !s_370_36;
        // D s_370_39: and s_370_31 s_370_38
        let s_370_39: u64 = ((s_370_31) & (s_370_38));
        // D s_370_40: select s_370_35 s_370_37 s_370_39
        let s_370_40: u64 = if s_370_35 { s_370_37 } else { s_370_39 };
        // D s_370_41: cast trunc s_370_40 -> u8
        let s_370_41: bool = ((s_370_40) != 0);
        // D s_370_42: cast zx s_370_41 -> bv
        let s_370_42: Bits = Bits::new(s_370_41 as u128, 1u16);
        // C s_370_43: const #0u : u8
        let s_370_43: bool = false;
        // C s_370_44: cast zx s_370_43 -> bv
        let s_370_44: Bits = Bits::new(s_370_43 as u128, 1u16);
        // D s_370_45: cmp-ne s_370_42 s_370_44
        let s_370_45: bool = ((s_370_42) != (s_370_44));
        // N s_370_46: branch s_370_45 b387 b371
        if s_370_45 {
            return block_387(state, tracer, fn_state);
        } else {
            return block_371(state, tracer, fn_state);
        };
    }
    fn block_371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_371_0: const #6s : i
        let s_371_0: i128 = 6;
        // D s_371_1: read-var u#34310:u32
        let s_371_1: u32 = fn_state.u_34310;
        // D s_371_2: cast zx s_371_1 -> bv
        let s_371_2: Bits = Bits::new(s_371_1 as u128, 32u16);
        // C s_371_3: const #1u : u64
        let s_371_3: u64 = 1;
        // D s_371_4: bit-extract s_371_2 s_371_0 s_371_3
        let s_371_4: Bits = (Bits::new(
            ((s_371_2) >> (s_371_0)).value(),
            u16::try_from(s_371_3).unwrap(),
        ));
        // D s_371_5: cast reint s_371_4 -> u8
        let s_371_5: bool = ((s_371_4.value()) != 0);
        // C s_371_6: const #0s : i
        let s_371_6: i128 = 0;
        // C s_371_7: const #0u : u64
        let s_371_7: u64 = 0;
        // D s_371_8: cast zx s_371_5 -> u64
        let s_371_8: u64 = (s_371_5 as u64);
        // C s_371_9: const #1u : u64
        let s_371_9: u64 = 1;
        // D s_371_10: and s_371_8 s_371_9
        let s_371_10: u64 = ((s_371_8) & (s_371_9));
        // D s_371_11: cmp-eq s_371_10 s_371_9
        let s_371_11: bool = ((s_371_10) == (s_371_9));
        // D s_371_12: lsl s_371_8 s_371_6
        let s_371_12: u64 = s_371_8 << s_371_6;
        // D s_371_13: or s_371_7 s_371_12
        let s_371_13: u64 = ((s_371_7) | (s_371_12));
        // D s_371_14: cmpl s_371_12
        let s_371_14: u64 = !s_371_12;
        // D s_371_15: and s_371_7 s_371_14
        let s_371_15: u64 = ((s_371_7) & (s_371_14));
        // D s_371_16: select s_371_11 s_371_13 s_371_15
        let s_371_16: u64 = if s_371_11 { s_371_13 } else { s_371_15 };
        // D s_371_17: cast trunc s_371_16 -> u8
        let s_371_17: bool = ((s_371_16) != 0);
        // D s_371_18: cast zx s_371_17 -> bv
        let s_371_18: Bits = Bits::new(s_371_17 as u128, 1u16);
        // C s_371_19: const #0u : u8
        let s_371_19: bool = false;
        // C s_371_20: cast zx s_371_19 -> bv
        let s_371_20: Bits = Bits::new(s_371_19 as u128, 1u16);
        // D s_371_21: cmp-ne s_371_18 s_371_20
        let s_371_21: bool = ((s_371_18) != (s_371_20));
        // D s_371_22: write-var gs#413299 <= s_371_21
        fn_state.gs_413299 = s_371_21;
        // N s_371_23: jump b372
        return block_372(state, tracer, fn_state);
    }
    fn block_372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_372_0: read-var gs#413299:u8
        let s_372_0: bool = fn_state.gs_413299;
        // N s_372_1: branch s_372_0 b386 b373
        if s_372_0 {
            return block_386(state, tracer, fn_state);
        } else {
            return block_373(state, tracer, fn_state);
        };
    }
    fn block_373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_373_0: const #0s : i
        let s_373_0: i128 = 0;
        // D s_373_1: read-var u#34310:u32
        let s_373_1: u32 = fn_state.u_34310;
        // D s_373_2: cast zx s_373_1 -> bv
        let s_373_2: Bits = Bits::new(s_373_1 as u128, 32u16);
        // C s_373_3: const #1u : u64
        let s_373_3: u64 = 1;
        // D s_373_4: bit-extract s_373_2 s_373_0 s_373_3
        let s_373_4: Bits = (Bits::new(
            ((s_373_2) >> (s_373_0)).value(),
            u16::try_from(s_373_3).unwrap(),
        ));
        // D s_373_5: cast reint s_373_4 -> u8
        let s_373_5: bool = ((s_373_4.value()) != 0);
        // C s_373_6: const #0s : i
        let s_373_6: i128 = 0;
        // C s_373_7: const #0u : u64
        let s_373_7: u64 = 0;
        // D s_373_8: cast zx s_373_5 -> u64
        let s_373_8: u64 = (s_373_5 as u64);
        // C s_373_9: const #1u : u64
        let s_373_9: u64 = 1;
        // D s_373_10: and s_373_8 s_373_9
        let s_373_10: u64 = ((s_373_8) & (s_373_9));
        // D s_373_11: cmp-eq s_373_10 s_373_9
        let s_373_11: bool = ((s_373_10) == (s_373_9));
        // D s_373_12: lsl s_373_8 s_373_6
        let s_373_12: u64 = s_373_8 << s_373_6;
        // D s_373_13: or s_373_7 s_373_12
        let s_373_13: u64 = ((s_373_7) | (s_373_12));
        // D s_373_14: cmpl s_373_12
        let s_373_14: u64 = !s_373_12;
        // D s_373_15: and s_373_7 s_373_14
        let s_373_15: u64 = ((s_373_7) & (s_373_14));
        // D s_373_16: select s_373_11 s_373_13 s_373_15
        let s_373_16: u64 = if s_373_11 { s_373_13 } else { s_373_15 };
        // D s_373_17: cast trunc s_373_16 -> u8
        let s_373_17: bool = ((s_373_16) != 0);
        // D s_373_18: cast zx s_373_17 -> bv
        let s_373_18: Bits = Bits::new(s_373_17 as u128, 1u16);
        // C s_373_19: const #0u : u8
        let s_373_19: bool = false;
        // C s_373_20: cast zx s_373_19 -> bv
        let s_373_20: Bits = Bits::new(s_373_19 as u128, 1u16);
        // D s_373_21: cmp-ne s_373_18 s_373_20
        let s_373_21: bool = ((s_373_18) != (s_373_20));
        // D s_373_22: write-var gs#413302 <= s_373_21
        fn_state.gs_413302 = s_373_21;
        // N s_373_23: jump b374
        return block_374(state, tracer, fn_state);
    }
    fn block_374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_374_0: read-var gs#413302:u8
        let s_374_0: bool = fn_state.gs_413302;
        // N s_374_1: branch s_374_0 b385 b375
        if s_374_0 {
            return block_385(state, tracer, fn_state);
        } else {
            return block_375(state, tracer, fn_state);
        };
    }
    fn block_375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_375_0: const #1s : i
        let s_375_0: i128 = 1;
        // D s_375_1: read-var u#34310:u32
        let s_375_1: u32 = fn_state.u_34310;
        // D s_375_2: cast zx s_375_1 -> bv
        let s_375_2: Bits = Bits::new(s_375_1 as u128, 32u16);
        // C s_375_3: const #1u : u64
        let s_375_3: u64 = 1;
        // D s_375_4: bit-extract s_375_2 s_375_0 s_375_3
        let s_375_4: Bits = (Bits::new(
            ((s_375_2) >> (s_375_0)).value(),
            u16::try_from(s_375_3).unwrap(),
        ));
        // D s_375_5: cast reint s_375_4 -> u8
        let s_375_5: bool = ((s_375_4.value()) != 0);
        // C s_375_6: const #0s : i
        let s_375_6: i128 = 0;
        // C s_375_7: const #0u : u64
        let s_375_7: u64 = 0;
        // D s_375_8: cast zx s_375_5 -> u64
        let s_375_8: u64 = (s_375_5 as u64);
        // C s_375_9: const #1u : u64
        let s_375_9: u64 = 1;
        // D s_375_10: and s_375_8 s_375_9
        let s_375_10: u64 = ((s_375_8) & (s_375_9));
        // D s_375_11: cmp-eq s_375_10 s_375_9
        let s_375_11: bool = ((s_375_10) == (s_375_9));
        // D s_375_12: lsl s_375_8 s_375_6
        let s_375_12: u64 = s_375_8 << s_375_6;
        // D s_375_13: or s_375_7 s_375_12
        let s_375_13: u64 = ((s_375_7) | (s_375_12));
        // D s_375_14: cmpl s_375_12
        let s_375_14: u64 = !s_375_12;
        // D s_375_15: and s_375_7 s_375_14
        let s_375_15: u64 = ((s_375_7) & (s_375_14));
        // D s_375_16: select s_375_11 s_375_13 s_375_15
        let s_375_16: u64 = if s_375_11 { s_375_13 } else { s_375_15 };
        // D s_375_17: cast trunc s_375_16 -> u8
        let s_375_17: bool = ((s_375_16) != 0);
        // D s_375_18: cast zx s_375_17 -> bv
        let s_375_18: Bits = Bits::new(s_375_17 as u128, 1u16);
        // C s_375_19: const #0u : u8
        let s_375_19: bool = false;
        // C s_375_20: cast zx s_375_19 -> bv
        let s_375_20: Bits = Bits::new(s_375_19 as u128, 1u16);
        // D s_375_21: cmp-ne s_375_18 s_375_20
        let s_375_21: bool = ((s_375_18) != (s_375_20));
        // D s_375_22: write-var gs#413305 <= s_375_21
        fn_state.gs_413305 = s_375_21;
        // N s_375_23: jump b376
        return block_376(state, tracer, fn_state);
    }
    fn block_376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_376_0: read-var gs#413305:u8
        let s_376_0: bool = fn_state.gs_413305;
        // N s_376_1: branch s_376_0 b384 b377
        if s_376_0 {
            return block_384(state, tracer, fn_state);
        } else {
            return block_377(state, tracer, fn_state);
        };
    }
    fn block_377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_377_0: const #2s : i
        let s_377_0: i128 = 2;
        // D s_377_1: read-var u#34310:u32
        let s_377_1: u32 = fn_state.u_34310;
        // D s_377_2: cast zx s_377_1 -> bv
        let s_377_2: Bits = Bits::new(s_377_1 as u128, 32u16);
        // C s_377_3: const #1u : u64
        let s_377_3: u64 = 1;
        // D s_377_4: bit-extract s_377_2 s_377_0 s_377_3
        let s_377_4: Bits = (Bits::new(
            ((s_377_2) >> (s_377_0)).value(),
            u16::try_from(s_377_3).unwrap(),
        ));
        // D s_377_5: cast reint s_377_4 -> u8
        let s_377_5: bool = ((s_377_4.value()) != 0);
        // C s_377_6: const #0s : i
        let s_377_6: i128 = 0;
        // C s_377_7: const #0u : u64
        let s_377_7: u64 = 0;
        // D s_377_8: cast zx s_377_5 -> u64
        let s_377_8: u64 = (s_377_5 as u64);
        // C s_377_9: const #1u : u64
        let s_377_9: u64 = 1;
        // D s_377_10: and s_377_8 s_377_9
        let s_377_10: u64 = ((s_377_8) & (s_377_9));
        // D s_377_11: cmp-eq s_377_10 s_377_9
        let s_377_11: bool = ((s_377_10) == (s_377_9));
        // D s_377_12: lsl s_377_8 s_377_6
        let s_377_12: u64 = s_377_8 << s_377_6;
        // D s_377_13: or s_377_7 s_377_12
        let s_377_13: u64 = ((s_377_7) | (s_377_12));
        // D s_377_14: cmpl s_377_12
        let s_377_14: u64 = !s_377_12;
        // D s_377_15: and s_377_7 s_377_14
        let s_377_15: u64 = ((s_377_7) & (s_377_14));
        // D s_377_16: select s_377_11 s_377_13 s_377_15
        let s_377_16: u64 = if s_377_11 { s_377_13 } else { s_377_15 };
        // D s_377_17: cast trunc s_377_16 -> u8
        let s_377_17: bool = ((s_377_16) != 0);
        // D s_377_18: cast zx s_377_17 -> bv
        let s_377_18: Bits = Bits::new(s_377_17 as u128, 1u16);
        // C s_377_19: const #0u : u8
        let s_377_19: bool = false;
        // C s_377_20: cast zx s_377_19 -> bv
        let s_377_20: Bits = Bits::new(s_377_19 as u128, 1u16);
        // D s_377_21: cmp-ne s_377_18 s_377_20
        let s_377_21: bool = ((s_377_18) != (s_377_20));
        // D s_377_22: write-var gs#413308 <= s_377_21
        fn_state.gs_413308 = s_377_21;
        // N s_377_23: jump b378
        return block_378(state, tracer, fn_state);
    }
    fn block_378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_378_0: read-var gs#413308:u8
        let s_378_0: bool = fn_state.gs_413308;
        // N s_378_1: branch s_378_0 b383 b379
        if s_378_0 {
            return block_383(state, tracer, fn_state);
        } else {
            return block_379(state, tracer, fn_state);
        };
    }
    fn block_379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_379_0: const #3s : i
        let s_379_0: i128 = 3;
        // D s_379_1: read-var u#34310:u32
        let s_379_1: u32 = fn_state.u_34310;
        // D s_379_2: cast zx s_379_1 -> bv
        let s_379_2: Bits = Bits::new(s_379_1 as u128, 32u16);
        // C s_379_3: const #1u : u64
        let s_379_3: u64 = 1;
        // D s_379_4: bit-extract s_379_2 s_379_0 s_379_3
        let s_379_4: Bits = (Bits::new(
            ((s_379_2) >> (s_379_0)).value(),
            u16::try_from(s_379_3).unwrap(),
        ));
        // D s_379_5: cast reint s_379_4 -> u8
        let s_379_5: bool = ((s_379_4.value()) != 0);
        // C s_379_6: const #0s : i
        let s_379_6: i128 = 0;
        // C s_379_7: const #0u : u64
        let s_379_7: u64 = 0;
        // D s_379_8: cast zx s_379_5 -> u64
        let s_379_8: u64 = (s_379_5 as u64);
        // C s_379_9: const #1u : u64
        let s_379_9: u64 = 1;
        // D s_379_10: and s_379_8 s_379_9
        let s_379_10: u64 = ((s_379_8) & (s_379_9));
        // D s_379_11: cmp-eq s_379_10 s_379_9
        let s_379_11: bool = ((s_379_10) == (s_379_9));
        // D s_379_12: lsl s_379_8 s_379_6
        let s_379_12: u64 = s_379_8 << s_379_6;
        // D s_379_13: or s_379_7 s_379_12
        let s_379_13: u64 = ((s_379_7) | (s_379_12));
        // D s_379_14: cmpl s_379_12
        let s_379_14: u64 = !s_379_12;
        // D s_379_15: and s_379_7 s_379_14
        let s_379_15: u64 = ((s_379_7) & (s_379_14));
        // D s_379_16: select s_379_11 s_379_13 s_379_15
        let s_379_16: u64 = if s_379_11 { s_379_13 } else { s_379_15 };
        // D s_379_17: cast trunc s_379_16 -> u8
        let s_379_17: bool = ((s_379_16) != 0);
        // D s_379_18: cast zx s_379_17 -> bv
        let s_379_18: Bits = Bits::new(s_379_17 as u128, 1u16);
        // C s_379_19: const #0u : u8
        let s_379_19: bool = false;
        // C s_379_20: cast zx s_379_19 -> bv
        let s_379_20: Bits = Bits::new(s_379_19 as u128, 1u16);
        // D s_379_21: cmp-ne s_379_18 s_379_20
        let s_379_21: bool = ((s_379_18) != (s_379_20));
        // D s_379_22: write-var gs#413311 <= s_379_21
        fn_state.gs_413311 = s_379_21;
        // N s_379_23: jump b380
        return block_380(state, tracer, fn_state);
    }
    fn block_380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_380_0: read-var gs#413311:u8
        let s_380_0: bool = fn_state.gs_413311;
        // N s_380_1: branch s_380_0 b382 b381
        if s_380_0 {
            return block_382(state, tracer, fn_state);
        } else {
            return block_381(state, tracer, fn_state);
        };
    }
    fn block_381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_381_0: read-var u#34311:u8
        let s_381_0: u8 = fn_state.u_34311;
        // D s_381_1: read-var u#34312:u8
        let s_381_1: u8 = fn_state.u_34312;
        // D s_381_2: read-var u#34313:u8
        let s_381_2: u8 = fn_state.u_34313;
        // D s_381_3: call decode_aarch32_instrs_VMSR_A1enc_AS_txt(s_381_0, s_381_1, s_381_2)
        let s_381_3: () = decode_aarch32_instrs_VMSR_A1enc_AS_txt(
            state,
            tracer,
            s_381_0,
            s_381_1,
            s_381_2,
        );
        // N s_381_4: return
        return;
    }
    fn block_382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_382_0: panic
        panic!("{:?}", ());
        // N s_382_1: return
        return;
    }
    fn block_383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_383_0: const #1u : u8
        let s_383_0: bool = true;
        // D s_383_1: write-var gs#413311 <= s_383_0
        fn_state.gs_413311 = s_383_0;
        // N s_383_2: jump b380
        return block_380(state, tracer, fn_state);
    }
    fn block_384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_384_0: const #1u : u8
        let s_384_0: bool = true;
        // D s_384_1: write-var gs#413308 <= s_384_0
        fn_state.gs_413308 = s_384_0;
        // N s_384_2: jump b378
        return block_378(state, tracer, fn_state);
    }
    fn block_385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_385_0: const #1u : u8
        let s_385_0: bool = true;
        // D s_385_1: write-var gs#413305 <= s_385_0
        fn_state.gs_413305 = s_385_0;
        // N s_385_2: jump b376
        return block_376(state, tracer, fn_state);
    }
    fn block_386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_386_0: const #1u : u8
        let s_386_0: bool = true;
        // D s_386_1: write-var gs#413302 <= s_386_0
        fn_state.gs_413302 = s_386_0;
        // N s_386_2: jump b374
        return block_374(state, tracer, fn_state);
    }
    fn block_387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_387_0: const #1u : u8
        let s_387_0: bool = true;
        // D s_387_1: write-var gs#413299 <= s_387_0
        fn_state.gs_413299 = s_387_0;
        // N s_387_2: jump b372
        return block_372(state, tracer, fn_state);
    }
    fn block_388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_388_0: read-var merge#var.1:struct
        let s_388_0: u32 = fn_state.merge_var._1;
        // D s_388_1: write-var u#34315 <= s_388_0
        fn_state.u_34315 = s_388_0;
        // C s_388_2: const #23s : i
        let s_388_2: i128 = 23;
        // D s_388_3: read-var u#34315:u32
        let s_388_3: u32 = fn_state.u_34315;
        // D s_388_4: cast zx s_388_3 -> bv
        let s_388_4: Bits = Bits::new(s_388_3 as u128, 32u16);
        // C s_388_5: const #1s : i64
        let s_388_5: i64 = 1;
        // C s_388_6: cast zx s_388_5 -> i
        let s_388_6: i128 = (i128::try_from(s_388_5).unwrap());
        // C s_388_7: const #8s : i
        let s_388_7: i128 = 8;
        // C s_388_8: add s_388_7 s_388_6
        let s_388_8: i128 = (s_388_7 + s_388_6);
        // D s_388_9: bit-extract s_388_4 s_388_2 s_388_8
        let s_388_9: Bits = (Bits::new(
            ((s_388_4) >> (s_388_2)).value(),
            u16::try_from(s_388_8).unwrap(),
        ));
        // D s_388_10: cast reint s_388_9 -> u9
        let s_388_10: u16 = (s_388_9.value() as u16);
        // D s_388_11: cast zx s_388_10 -> bv
        let s_388_11: Bits = Bits::new(s_388_10 as u128, 9u16);
        // C s_388_12: const #509u : u9
        let s_388_12: u16 = 509;
        // C s_388_13: cast zx s_388_12 -> bv
        let s_388_13: Bits = Bits::new(s_388_12 as u128, 9u16);
        // D s_388_14: cmp-eq s_388_11 s_388_13
        let s_388_14: bool = ((s_388_11) == (s_388_13));
        // N s_388_15: branch s_388_14 b736 b389
        if s_388_14 {
            return block_736(state, tracer, fn_state);
        } else {
            return block_389(state, tracer, fn_state);
        };
    }
    fn block_389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_389_0: const #0u : u8
        let s_389_0: bool = false;
        // D s_389_1: write-var gs#413326 <= s_389_0
        fn_state.gs_413326 = s_389_0;
        // N s_389_2: jump b390
        return block_390(state, tracer, fn_state);
    }
    fn block_390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_390_0: read-var gs#413326:u8
        let s_390_0: bool = fn_state.gs_413326;
        // N s_390_1: branch s_390_0 b735 b391
        if s_390_0 {
            return block_735(state, tracer, fn_state);
        } else {
            return block_391(state, tracer, fn_state);
        };
    }
    fn block_391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_391_0: const #0u : u8
        let s_391_0: bool = false;
        // D s_391_1: write-var gs#413328 <= s_391_0
        fn_state.gs_413328 = s_391_0;
        // N s_391_2: jump b392
        return block_392(state, tracer, fn_state);
    }
    fn block_392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_392_0: read-var gs#413328:u8
        let s_392_0: bool = fn_state.gs_413328;
        // D s_392_1: not s_392_0
        let s_392_1: bool = !s_392_0;
        // N s_392_2: branch s_392_1 b394 b393
        if s_392_1 {
            return block_394(state, tracer, fn_state);
        } else {
            return block_393(state, tracer, fn_state);
        };
    }
    fn block_393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_393_0: const #3868s : i
        let s_393_0: i128 = 3868;
        // C s_393_1: const #14696u : u32
        let s_393_1: u32 = 14696;
        // N s_393_2: write-reg s_393_1 <= s_393_0
        let s_393_2: () = {
            state.write_register::<i128>(s_393_1 as isize, s_393_0);
            tracer.write_register(s_393_1 as isize, s_393_0);
        };
        // C s_393_3: const #22s : i
        let s_393_3: i128 = 22;
        // C s_393_4: const #1s : i
        let s_393_4: i128 = 1;
        // D s_393_5: read-var u#34315:u32
        let s_393_5: u32 = fn_state.u_34315;
        // D s_393_6: cast zx s_393_5 -> bv
        let s_393_6: Bits = Bits::new(s_393_5 as u128, 32u16);
        // D s_393_7: bit-extract s_393_6 s_393_3 s_393_4
        let s_393_7: Bits = (Bits::new(
            ((s_393_6) >> (s_393_3)).value(),
            u16::try_from(s_393_4).unwrap(),
        ));
        // D s_393_8: cast reint s_393_7 -> u8
        let s_393_8: bool = ((s_393_7.value()) != 0);
        // C s_393_9: const #16s : i
        let s_393_9: i128 = 16;
        // C s_393_10: const #2s : i
        let s_393_10: i128 = 2;
        // D s_393_11: read-var u#34315:u32
        let s_393_11: u32 = fn_state.u_34315;
        // D s_393_12: cast zx s_393_11 -> bv
        let s_393_12: Bits = Bits::new(s_393_11 as u128, 32u16);
        // D s_393_13: bit-extract s_393_12 s_393_9 s_393_10
        let s_393_13: Bits = (Bits::new(
            ((s_393_12) >> (s_393_9)).value(),
            u16::try_from(s_393_10).unwrap(),
        ));
        // D s_393_14: cast reint s_393_13 -> u8
        let s_393_14: u8 = (s_393_13.value() as u8);
        // C s_393_15: const #12s : i
        let s_393_15: i128 = 12;
        // C s_393_16: const #4s : i
        let s_393_16: i128 = 4;
        // D s_393_17: read-var u#34315:u32
        let s_393_17: u32 = fn_state.u_34315;
        // D s_393_18: cast zx s_393_17 -> bv
        let s_393_18: Bits = Bits::new(s_393_17 as u128, 32u16);
        // D s_393_19: bit-extract s_393_18 s_393_15 s_393_16
        let s_393_19: Bits = (Bits::new(
            ((s_393_18) >> (s_393_15)).value(),
            u16::try_from(s_393_16).unwrap(),
        ));
        // D s_393_20: cast reint s_393_19 -> u8
        let s_393_20: u8 = (s_393_19.value() as u8);
        // C s_393_21: const #8s : i
        let s_393_21: i128 = 8;
        // C s_393_22: const #2s : i
        let s_393_22: i128 = 2;
        // D s_393_23: read-var u#34315:u32
        let s_393_23: u32 = fn_state.u_34315;
        // D s_393_24: cast zx s_393_23 -> bv
        let s_393_24: Bits = Bits::new(s_393_23 as u128, 32u16);
        // D s_393_25: bit-extract s_393_24 s_393_21 s_393_22
        let s_393_25: Bits = (Bits::new(
            ((s_393_24) >> (s_393_21)).value(),
            u16::try_from(s_393_22).unwrap(),
        ));
        // D s_393_26: cast reint s_393_25 -> u8
        let s_393_26: u8 = (s_393_25.value() as u8);
        // C s_393_27: const #7s : i
        let s_393_27: i128 = 7;
        // C s_393_28: const #1s : i
        let s_393_28: i128 = 1;
        // D s_393_29: read-var u#34315:u32
        let s_393_29: u32 = fn_state.u_34315;
        // D s_393_30: cast zx s_393_29 -> bv
        let s_393_30: Bits = Bits::new(s_393_29 as u128, 32u16);
        // D s_393_31: bit-extract s_393_30 s_393_27 s_393_28
        let s_393_31: Bits = (Bits::new(
            ((s_393_30) >> (s_393_27)).value(),
            u16::try_from(s_393_28).unwrap(),
        ));
        // D s_393_32: cast reint s_393_31 -> u8
        let s_393_32: bool = ((s_393_31.value()) != 0);
        // C s_393_33: const #5s : i
        let s_393_33: i128 = 5;
        // C s_393_34: const #1s : i
        let s_393_34: i128 = 1;
        // D s_393_35: read-var u#34315:u32
        let s_393_35: u32 = fn_state.u_34315;
        // D s_393_36: cast zx s_393_35 -> bv
        let s_393_36: Bits = Bits::new(s_393_35 as u128, 32u16);
        // D s_393_37: bit-extract s_393_36 s_393_33 s_393_34
        let s_393_37: Bits = (Bits::new(
            ((s_393_36) >> (s_393_33)).value(),
            u16::try_from(s_393_34).unwrap(),
        ));
        // D s_393_38: cast reint s_393_37 -> u8
        let s_393_38: bool = ((s_393_37.value()) != 0);
        // C s_393_39: const #0s : i
        let s_393_39: i128 = 0;
        // C s_393_40: const #4s : i
        let s_393_40: i128 = 4;
        // D s_393_41: read-var u#34315:u32
        let s_393_41: u32 = fn_state.u_34315;
        // D s_393_42: cast zx s_393_41 -> bv
        let s_393_42: Bits = Bits::new(s_393_41 as u128, 32u16);
        // D s_393_43: bit-extract s_393_42 s_393_39 s_393_40
        let s_393_43: Bits = (Bits::new(
            ((s_393_42) >> (s_393_39)).value(),
            u16::try_from(s_393_40).unwrap(),
        ));
        // D s_393_44: cast reint s_393_43 -> u8
        let s_393_44: u8 = (s_393_43.value() as u8);
        // D s_393_45: call decode_aarch32_instrs_VCVTA_vfp_A1enc_A_txt(s_393_8, s_393_14, s_393_20, s_393_26, s_393_32, s_393_38, s_393_44)
        let s_393_45: () = decode_aarch32_instrs_VCVTA_vfp_A1enc_A_txt(
            state,
            tracer,
            s_393_8,
            s_393_14,
            s_393_20,
            s_393_26,
            s_393_32,
            s_393_38,
            s_393_44,
        );
        // N s_393_46: return
        return;
    }
    fn block_394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_394_0: read-var merge#var.1:struct
        let s_394_0: u32 = fn_state.merge_var._1;
        // D s_394_1: write-var u#34323 <= s_394_0
        fn_state.u_34323 = s_394_0;
        // C s_394_2: const #23s : i
        let s_394_2: i128 = 23;
        // D s_394_3: read-var u#34323:u32
        let s_394_3: u32 = fn_state.u_34323;
        // D s_394_4: cast zx s_394_3 -> bv
        let s_394_4: Bits = Bits::new(s_394_3 as u128, 32u16);
        // C s_394_5: const #1s : i64
        let s_394_5: i64 = 1;
        // C s_394_6: cast zx s_394_5 -> i
        let s_394_6: i128 = (i128::try_from(s_394_5).unwrap());
        // C s_394_7: const #8s : i
        let s_394_7: i128 = 8;
        // C s_394_8: add s_394_7 s_394_6
        let s_394_8: i128 = (s_394_7 + s_394_6);
        // D s_394_9: bit-extract s_394_4 s_394_2 s_394_8
        let s_394_9: Bits = (Bits::new(
            ((s_394_4) >> (s_394_2)).value(),
            u16::try_from(s_394_8).unwrap(),
        ));
        // D s_394_10: cast reint s_394_9 -> u9
        let s_394_10: u16 = (s_394_9.value() as u16);
        // D s_394_11: cast zx s_394_10 -> bv
        let s_394_11: Bits = Bits::new(s_394_10 as u128, 9u16);
        // C s_394_12: const #509u : u9
        let s_394_12: u16 = 509;
        // C s_394_13: cast zx s_394_12 -> bv
        let s_394_13: Bits = Bits::new(s_394_12 as u128, 9u16);
        // D s_394_14: cmp-eq s_394_11 s_394_13
        let s_394_14: bool = ((s_394_11) == (s_394_13));
        // N s_394_15: branch s_394_14 b728 b395
        if s_394_14 {
            return block_728(state, tracer, fn_state);
        } else {
            return block_395(state, tracer, fn_state);
        };
    }
    fn block_395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_395_0: const #0u : u8
        let s_395_0: bool = false;
        // D s_395_1: write-var gs#413356 <= s_395_0
        fn_state.gs_413356 = s_395_0;
        // N s_395_2: jump b396
        return block_396(state, tracer, fn_state);
    }
    fn block_396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_396_0: read-var gs#413356:u8
        let s_396_0: bool = fn_state.gs_413356;
        // N s_396_1: branch s_396_0 b727 b397
        if s_396_0 {
            return block_727(state, tracer, fn_state);
        } else {
            return block_397(state, tracer, fn_state);
        };
    }
    fn block_397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_397_0: const #0u : u8
        let s_397_0: bool = false;
        // D s_397_1: write-var gs#413358 <= s_397_0
        fn_state.gs_413358 = s_397_0;
        // N s_397_2: jump b398
        return block_398(state, tracer, fn_state);
    }
    fn block_398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_398_0: read-var gs#413358:u8
        let s_398_0: bool = fn_state.gs_413358;
        // D s_398_1: not s_398_0
        let s_398_1: bool = !s_398_0;
        // N s_398_2: branch s_398_1 b400 b399
        if s_398_1 {
            return block_400(state, tracer, fn_state);
        } else {
            return block_399(state, tracer, fn_state);
        };
    }
    fn block_399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_399_0: const #3871s : i
        let s_399_0: i128 = 3871;
        // C s_399_1: const #14696u : u32
        let s_399_1: u32 = 14696;
        // N s_399_2: write-reg s_399_1 <= s_399_0
        let s_399_2: () = {
            state.write_register::<i128>(s_399_1 as isize, s_399_0);
            tracer.write_register(s_399_1 as isize, s_399_0);
        };
        // C s_399_3: const #22s : i
        let s_399_3: i128 = 22;
        // C s_399_4: const #1s : i
        let s_399_4: i128 = 1;
        // D s_399_5: read-var u#34323:u32
        let s_399_5: u32 = fn_state.u_34323;
        // D s_399_6: cast zx s_399_5 -> bv
        let s_399_6: Bits = Bits::new(s_399_5 as u128, 32u16);
        // D s_399_7: bit-extract s_399_6 s_399_3 s_399_4
        let s_399_7: Bits = (Bits::new(
            ((s_399_6) >> (s_399_3)).value(),
            u16::try_from(s_399_4).unwrap(),
        ));
        // D s_399_8: cast reint s_399_7 -> u8
        let s_399_8: bool = ((s_399_7.value()) != 0);
        // C s_399_9: const #16s : i
        let s_399_9: i128 = 16;
        // C s_399_10: const #4s : i
        let s_399_10: i128 = 4;
        // D s_399_11: read-var u#34323:u32
        let s_399_11: u32 = fn_state.u_34323;
        // D s_399_12: cast zx s_399_11 -> bv
        let s_399_12: Bits = Bits::new(s_399_11 as u128, 32u16);
        // D s_399_13: bit-extract s_399_12 s_399_9 s_399_10
        let s_399_13: Bits = (Bits::new(
            ((s_399_12) >> (s_399_9)).value(),
            u16::try_from(s_399_10).unwrap(),
        ));
        // D s_399_14: cast reint s_399_13 -> u8
        let s_399_14: u8 = (s_399_13.value() as u8);
        // C s_399_15: const #12s : i
        let s_399_15: i128 = 12;
        // C s_399_16: const #4s : i
        let s_399_16: i128 = 4;
        // D s_399_17: read-var u#34323:u32
        let s_399_17: u32 = fn_state.u_34323;
        // D s_399_18: cast zx s_399_17 -> bv
        let s_399_18: Bits = Bits::new(s_399_17 as u128, 32u16);
        // D s_399_19: bit-extract s_399_18 s_399_15 s_399_16
        let s_399_19: Bits = (Bits::new(
            ((s_399_18) >> (s_399_15)).value(),
            u16::try_from(s_399_16).unwrap(),
        ));
        // D s_399_20: cast reint s_399_19 -> u8
        let s_399_20: u8 = (s_399_19.value() as u8);
        // C s_399_21: const #8s : i
        let s_399_21: i128 = 8;
        // C s_399_22: const #2s : i
        let s_399_22: i128 = 2;
        // D s_399_23: read-var u#34323:u32
        let s_399_23: u32 = fn_state.u_34323;
        // D s_399_24: cast zx s_399_23 -> bv
        let s_399_24: Bits = Bits::new(s_399_23 as u128, 32u16);
        // D s_399_25: bit-extract s_399_24 s_399_21 s_399_22
        let s_399_25: Bits = (Bits::new(
            ((s_399_24) >> (s_399_21)).value(),
            u16::try_from(s_399_22).unwrap(),
        ));
        // D s_399_26: cast reint s_399_25 -> u8
        let s_399_26: u8 = (s_399_25.value() as u8);
        // C s_399_27: const #7s : i
        let s_399_27: i128 = 7;
        // C s_399_28: const #1s : i
        let s_399_28: i128 = 1;
        // D s_399_29: read-var u#34323:u32
        let s_399_29: u32 = fn_state.u_34323;
        // D s_399_30: cast zx s_399_29 -> bv
        let s_399_30: Bits = Bits::new(s_399_29 as u128, 32u16);
        // D s_399_31: bit-extract s_399_30 s_399_27 s_399_28
        let s_399_31: Bits = (Bits::new(
            ((s_399_30) >> (s_399_27)).value(),
            u16::try_from(s_399_28).unwrap(),
        ));
        // D s_399_32: cast reint s_399_31 -> u8
        let s_399_32: bool = ((s_399_31.value()) != 0);
        // C s_399_33: const #6s : i
        let s_399_33: i128 = 6;
        // C s_399_34: const #1s : i
        let s_399_34: i128 = 1;
        // D s_399_35: read-var u#34323:u32
        let s_399_35: u32 = fn_state.u_34323;
        // D s_399_36: cast zx s_399_35 -> bv
        let s_399_36: Bits = Bits::new(s_399_35 as u128, 32u16);
        // D s_399_37: bit-extract s_399_36 s_399_33 s_399_34
        let s_399_37: Bits = (Bits::new(
            ((s_399_36) >> (s_399_33)).value(),
            u16::try_from(s_399_34).unwrap(),
        ));
        // D s_399_38: cast reint s_399_37 -> u8
        let s_399_38: bool = ((s_399_37.value()) != 0);
        // C s_399_39: const #5s : i
        let s_399_39: i128 = 5;
        // C s_399_40: const #1s : i
        let s_399_40: i128 = 1;
        // D s_399_41: read-var u#34323:u32
        let s_399_41: u32 = fn_state.u_34323;
        // D s_399_42: cast zx s_399_41 -> bv
        let s_399_42: Bits = Bits::new(s_399_41 as u128, 32u16);
        // D s_399_43: bit-extract s_399_42 s_399_39 s_399_40
        let s_399_43: Bits = (Bits::new(
            ((s_399_42) >> (s_399_39)).value(),
            u16::try_from(s_399_40).unwrap(),
        ));
        // D s_399_44: cast reint s_399_43 -> u8
        let s_399_44: bool = ((s_399_43.value()) != 0);
        // C s_399_45: const #0s : i
        let s_399_45: i128 = 0;
        // C s_399_46: const #4s : i
        let s_399_46: i128 = 4;
        // D s_399_47: read-var u#34323:u32
        let s_399_47: u32 = fn_state.u_34323;
        // D s_399_48: cast zx s_399_47 -> bv
        let s_399_48: Bits = Bits::new(s_399_47 as u128, 32u16);
        // D s_399_49: bit-extract s_399_48 s_399_45 s_399_46
        let s_399_49: Bits = (Bits::new(
            ((s_399_48) >> (s_399_45)).value(),
            u16::try_from(s_399_46).unwrap(),
        ));
        // D s_399_50: cast reint s_399_49 -> u8
        let s_399_50: u8 = (s_399_49.value() as u8);
        // D s_399_51: call decode_aarch32_instrs_VMAXNM_A2enc_A_txt(s_399_8, s_399_14, s_399_20, s_399_26, s_399_32, s_399_38, s_399_44, s_399_50)
        let s_399_51: () = decode_aarch32_instrs_VMAXNM_A2enc_A_txt(
            state,
            tracer,
            s_399_8,
            s_399_14,
            s_399_20,
            s_399_26,
            s_399_32,
            s_399_38,
            s_399_44,
            s_399_50,
        );
        // N s_399_52: return
        return;
    }
    fn block_400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_400_0: read-var merge#var.1:struct
        let s_400_0: u32 = fn_state.merge_var._1;
        // D s_400_1: write-var u#34333 <= s_400_0
        fn_state.u_34333 = s_400_0;
        // C s_400_2: const #23s : i
        let s_400_2: i128 = 23;
        // D s_400_3: read-var u#34333:u32
        let s_400_3: u32 = fn_state.u_34333;
        // D s_400_4: cast zx s_400_3 -> bv
        let s_400_4: Bits = Bits::new(s_400_3 as u128, 32u16);
        // C s_400_5: const #1s : i64
        let s_400_5: i64 = 1;
        // C s_400_6: cast zx s_400_5 -> i
        let s_400_6: i128 = (i128::try_from(s_400_5).unwrap());
        // C s_400_7: const #8s : i
        let s_400_7: i128 = 8;
        // C s_400_8: add s_400_7 s_400_6
        let s_400_8: i128 = (s_400_7 + s_400_6);
        // D s_400_9: bit-extract s_400_4 s_400_2 s_400_8
        let s_400_9: Bits = (Bits::new(
            ((s_400_4) >> (s_400_2)).value(),
            u16::try_from(s_400_8).unwrap(),
        ));
        // D s_400_10: cast reint s_400_9 -> u9
        let s_400_10: u16 = (s_400_9.value() as u16);
        // D s_400_11: cast zx s_400_10 -> bv
        let s_400_11: Bits = Bits::new(s_400_10 as u128, 9u16);
        // C s_400_12: const #509u : u9
        let s_400_12: u16 = 509;
        // C s_400_13: cast zx s_400_12 -> bv
        let s_400_13: Bits = Bits::new(s_400_12 as u128, 9u16);
        // D s_400_14: cmp-eq s_400_11 s_400_13
        let s_400_14: bool = ((s_400_11) == (s_400_13));
        // N s_400_15: branch s_400_14 b717 b401
        if s_400_14 {
            return block_717(state, tracer, fn_state);
        } else {
            return block_401(state, tracer, fn_state);
        };
    }
    fn block_401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_401_0: const #0u : u8
        let s_401_0: bool = false;
        // D s_401_1: write-var gs#413391 <= s_401_0
        fn_state.gs_413391 = s_401_0;
        // N s_401_2: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_402_0: read-var gs#413391:u8
        let s_402_0: bool = fn_state.gs_413391;
        // N s_402_1: branch s_402_0 b716 b403
        if s_402_0 {
            return block_716(state, tracer, fn_state);
        } else {
            return block_403(state, tracer, fn_state);
        };
    }
    fn block_403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_403_0: const #0u : u8
        let s_403_0: bool = false;
        // D s_403_1: write-var gs#413393 <= s_403_0
        fn_state.gs_413393 = s_403_0;
        // N s_403_2: jump b404
        return block_404(state, tracer, fn_state);
    }
    fn block_404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_404_0: read-var gs#413393:u8
        let s_404_0: bool = fn_state.gs_413393;
        // D s_404_1: not s_404_0
        let s_404_1: bool = !s_404_0;
        // N s_404_2: branch s_404_1 b406 b405
        if s_404_1 {
            return block_406(state, tracer, fn_state);
        } else {
            return block_405(state, tracer, fn_state);
        };
    }
    fn block_405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_405_0: const #3876s : i
        let s_405_0: i128 = 3876;
        // C s_405_1: const #14696u : u32
        let s_405_1: u32 = 14696;
        // N s_405_2: write-reg s_405_1 <= s_405_0
        let s_405_2: () = {
            state.write_register::<i128>(s_405_1 as isize, s_405_0);
            tracer.write_register(s_405_1 as isize, s_405_0);
        };
        // C s_405_3: const #22s : i
        let s_405_3: i128 = 22;
        // C s_405_4: const #1s : i
        let s_405_4: i128 = 1;
        // D s_405_5: read-var u#34333:u32
        let s_405_5: u32 = fn_state.u_34333;
        // D s_405_6: cast zx s_405_5 -> bv
        let s_405_6: Bits = Bits::new(s_405_5 as u128, 32u16);
        // D s_405_7: bit-extract s_405_6 s_405_3 s_405_4
        let s_405_7: Bits = (Bits::new(
            ((s_405_6) >> (s_405_3)).value(),
            u16::try_from(s_405_4).unwrap(),
        ));
        // D s_405_8: cast reint s_405_7 -> u8
        let s_405_8: bool = ((s_405_7.value()) != 0);
        // C s_405_9: const #16s : i
        let s_405_9: i128 = 16;
        // C s_405_10: const #2s : i
        let s_405_10: i128 = 2;
        // D s_405_11: read-var u#34333:u32
        let s_405_11: u32 = fn_state.u_34333;
        // D s_405_12: cast zx s_405_11 -> bv
        let s_405_12: Bits = Bits::new(s_405_11 as u128, 32u16);
        // D s_405_13: bit-extract s_405_12 s_405_9 s_405_10
        let s_405_13: Bits = (Bits::new(
            ((s_405_12) >> (s_405_9)).value(),
            u16::try_from(s_405_10).unwrap(),
        ));
        // D s_405_14: cast reint s_405_13 -> u8
        let s_405_14: u8 = (s_405_13.value() as u8);
        // C s_405_15: const #12s : i
        let s_405_15: i128 = 12;
        // C s_405_16: const #4s : i
        let s_405_16: i128 = 4;
        // D s_405_17: read-var u#34333:u32
        let s_405_17: u32 = fn_state.u_34333;
        // D s_405_18: cast zx s_405_17 -> bv
        let s_405_18: Bits = Bits::new(s_405_17 as u128, 32u16);
        // D s_405_19: bit-extract s_405_18 s_405_15 s_405_16
        let s_405_19: Bits = (Bits::new(
            ((s_405_18) >> (s_405_15)).value(),
            u16::try_from(s_405_16).unwrap(),
        ));
        // D s_405_20: cast reint s_405_19 -> u8
        let s_405_20: u8 = (s_405_19.value() as u8);
        // C s_405_21: const #8s : i
        let s_405_21: i128 = 8;
        // C s_405_22: const #2s : i
        let s_405_22: i128 = 2;
        // D s_405_23: read-var u#34333:u32
        let s_405_23: u32 = fn_state.u_34333;
        // D s_405_24: cast zx s_405_23 -> bv
        let s_405_24: Bits = Bits::new(s_405_23 as u128, 32u16);
        // D s_405_25: bit-extract s_405_24 s_405_21 s_405_22
        let s_405_25: Bits = (Bits::new(
            ((s_405_24) >> (s_405_21)).value(),
            u16::try_from(s_405_22).unwrap(),
        ));
        // D s_405_26: cast reint s_405_25 -> u8
        let s_405_26: u8 = (s_405_25.value() as u8);
        // C s_405_27: const #5s : i
        let s_405_27: i128 = 5;
        // C s_405_28: const #1s : i
        let s_405_28: i128 = 1;
        // D s_405_29: read-var u#34333:u32
        let s_405_29: u32 = fn_state.u_34333;
        // D s_405_30: cast zx s_405_29 -> bv
        let s_405_30: Bits = Bits::new(s_405_29 as u128, 32u16);
        // D s_405_31: bit-extract s_405_30 s_405_27 s_405_28
        let s_405_31: Bits = (Bits::new(
            ((s_405_30) >> (s_405_27)).value(),
            u16::try_from(s_405_28).unwrap(),
        ));
        // D s_405_32: cast reint s_405_31 -> u8
        let s_405_32: bool = ((s_405_31.value()) != 0);
        // C s_405_33: const #0s : i
        let s_405_33: i128 = 0;
        // C s_405_34: const #4s : i
        let s_405_34: i128 = 4;
        // D s_405_35: read-var u#34333:u32
        let s_405_35: u32 = fn_state.u_34333;
        // D s_405_36: cast zx s_405_35 -> bv
        let s_405_36: Bits = Bits::new(s_405_35 as u128, 32u16);
        // D s_405_37: bit-extract s_405_36 s_405_33 s_405_34
        let s_405_37: Bits = (Bits::new(
            ((s_405_36) >> (s_405_33)).value(),
            u16::try_from(s_405_34).unwrap(),
        ));
        // D s_405_38: cast reint s_405_37 -> u8
        let s_405_38: u8 = (s_405_37.value() as u8);
        // D s_405_39: call decode_aarch32_instrs_VRINTA_vfp_A1enc_A_txt(s_405_8, s_405_14, s_405_20, s_405_26, s_405_32, s_405_38)
        let s_405_39: () = decode_aarch32_instrs_VRINTA_vfp_A1enc_A_txt(
            state,
            tracer,
            s_405_8,
            s_405_14,
            s_405_20,
            s_405_26,
            s_405_32,
            s_405_38,
        );
        // N s_405_40: return
        return;
    }
    fn block_406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_406_0: read-var merge#var.1:struct
        let s_406_0: u32 = fn_state.merge_var._1;
        // D s_406_1: write-var u#34341 <= s_406_0
        fn_state.u_34341 = s_406_0;
        // C s_406_2: const #23s : i
        let s_406_2: i128 = 23;
        // D s_406_3: read-var u#34341:u32
        let s_406_3: u32 = fn_state.u_34341;
        // D s_406_4: cast zx s_406_3 -> bv
        let s_406_4: Bits = Bits::new(s_406_3 as u128, 32u16);
        // C s_406_5: const #1s : i64
        let s_406_5: i64 = 1;
        // C s_406_6: cast zx s_406_5 -> i
        let s_406_6: i128 = (i128::try_from(s_406_5).unwrap());
        // C s_406_7: const #4s : i
        let s_406_7: i128 = 4;
        // C s_406_8: add s_406_7 s_406_6
        let s_406_8: i128 = (s_406_7 + s_406_6);
        // D s_406_9: bit-extract s_406_4 s_406_2 s_406_8
        let s_406_9: Bits = (Bits::new(
            ((s_406_4) >> (s_406_2)).value(),
            u16::try_from(s_406_8).unwrap(),
        ));
        // D s_406_10: cast reint s_406_9 -> u8
        let s_406_10: u8 = (s_406_9.value() as u8);
        // D s_406_11: cast zx s_406_10 -> bv
        let s_406_11: Bits = Bits::new(s_406_10 as u128, 5u16);
        // C s_406_12: const #29u : u8
        let s_406_12: u8 = 29;
        // C s_406_13: cast zx s_406_12 -> bv
        let s_406_13: Bits = Bits::new(s_406_12 as u128, 5u16);
        // D s_406_14: cmp-eq s_406_11 s_406_13
        let s_406_14: bool = ((s_406_11) == (s_406_13));
        // N s_406_15: branch s_406_14 b706 b407
        if s_406_14 {
            return block_706(state, tracer, fn_state);
        } else {
            return block_407(state, tracer, fn_state);
        };
    }
    fn block_407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_407_0: const #0u : u8
        let s_407_0: bool = false;
        // D s_407_1: write-var gs#413422 <= s_407_0
        fn_state.gs_413422 = s_407_0;
        // N s_407_2: jump b408
        return block_408(state, tracer, fn_state);
    }
    fn block_408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_408_0: read-var gs#413422:u8
        let s_408_0: bool = fn_state.gs_413422;
        // N s_408_1: branch s_408_0 b702 b409
        if s_408_0 {
            return block_702(state, tracer, fn_state);
        } else {
            return block_409(state, tracer, fn_state);
        };
    }
    fn block_409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_409_0: const #0u : u8
        let s_409_0: bool = false;
        // D s_409_1: write-var gs#413427 <= s_409_0
        fn_state.gs_413427 = s_409_0;
        // N s_409_2: jump b410
        return block_410(state, tracer, fn_state);
    }
    fn block_410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_410_0: read-var gs#413427:u8
        let s_410_0: bool = fn_state.gs_413427;
        // D s_410_1: not s_410_0
        let s_410_1: bool = !s_410_0;
        // N s_410_2: branch s_410_1 b412 b411
        if s_410_1 {
            return block_412(state, tracer, fn_state);
        } else {
            return block_411(state, tracer, fn_state);
        };
    }
    fn block_411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_411_0: const #3880s : i
        let s_411_0: i128 = 3880;
        // C s_411_1: const #14696u : u32
        let s_411_1: u32 = 14696;
        // N s_411_2: write-reg s_411_1 <= s_411_0
        let s_411_2: () = {
            state.write_register::<i128>(s_411_1 as isize, s_411_0);
            tracer.write_register(s_411_1 as isize, s_411_0);
        };
        // C s_411_3: const #28s : i
        let s_411_3: i128 = 28;
        // C s_411_4: const #4s : i
        let s_411_4: i128 = 4;
        // D s_411_5: read-var u#34341:u32
        let s_411_5: u32 = fn_state.u_34341;
        // D s_411_6: cast zx s_411_5 -> bv
        let s_411_6: Bits = Bits::new(s_411_5 as u128, 32u16);
        // D s_411_7: bit-extract s_411_6 s_411_3 s_411_4
        let s_411_7: Bits = (Bits::new(
            ((s_411_6) >> (s_411_3)).value(),
            u16::try_from(s_411_4).unwrap(),
        ));
        // D s_411_8: cast reint s_411_7 -> u8
        let s_411_8: u8 = (s_411_7.value() as u8);
        // C s_411_9: const #22s : i
        let s_411_9: i128 = 22;
        // C s_411_10: const #1s : i
        let s_411_10: i128 = 1;
        // D s_411_11: read-var u#34341:u32
        let s_411_11: u32 = fn_state.u_34341;
        // D s_411_12: cast zx s_411_11 -> bv
        let s_411_12: Bits = Bits::new(s_411_11 as u128, 32u16);
        // D s_411_13: bit-extract s_411_12 s_411_9 s_411_10
        let s_411_13: Bits = (Bits::new(
            ((s_411_12) >> (s_411_9)).value(),
            u16::try_from(s_411_10).unwrap(),
        ));
        // D s_411_14: cast reint s_411_13 -> u8
        let s_411_14: bool = ((s_411_13.value()) != 0);
        // C s_411_15: const #12s : i
        let s_411_15: i128 = 12;
        // C s_411_16: const #4s : i
        let s_411_16: i128 = 4;
        // D s_411_17: read-var u#34341:u32
        let s_411_17: u32 = fn_state.u_34341;
        // D s_411_18: cast zx s_411_17 -> bv
        let s_411_18: Bits = Bits::new(s_411_17 as u128, 32u16);
        // D s_411_19: bit-extract s_411_18 s_411_15 s_411_16
        let s_411_19: Bits = (Bits::new(
            ((s_411_18) >> (s_411_15)).value(),
            u16::try_from(s_411_16).unwrap(),
        ));
        // D s_411_20: cast reint s_411_19 -> u8
        let s_411_20: u8 = (s_411_19.value() as u8);
        // C s_411_21: const #8s : i
        let s_411_21: i128 = 8;
        // C s_411_22: const #2s : i
        let s_411_22: i128 = 2;
        // D s_411_23: read-var u#34341:u32
        let s_411_23: u32 = fn_state.u_34341;
        // D s_411_24: cast zx s_411_23 -> bv
        let s_411_24: Bits = Bits::new(s_411_23 as u128, 32u16);
        // D s_411_25: bit-extract s_411_24 s_411_21 s_411_22
        let s_411_25: Bits = (Bits::new(
            ((s_411_24) >> (s_411_21)).value(),
            u16::try_from(s_411_22).unwrap(),
        ));
        // D s_411_26: cast reint s_411_25 -> u8
        let s_411_26: u8 = (s_411_25.value() as u8);
        // C s_411_27: const #5s : i
        let s_411_27: i128 = 5;
        // C s_411_28: const #1s : i
        let s_411_28: i128 = 1;
        // D s_411_29: read-var u#34341:u32
        let s_411_29: u32 = fn_state.u_34341;
        // D s_411_30: cast zx s_411_29 -> bv
        let s_411_30: Bits = Bits::new(s_411_29 as u128, 32u16);
        // D s_411_31: bit-extract s_411_30 s_411_27 s_411_28
        let s_411_31: Bits = (Bits::new(
            ((s_411_30) >> (s_411_27)).value(),
            u16::try_from(s_411_28).unwrap(),
        ));
        // D s_411_32: cast reint s_411_31 -> u8
        let s_411_32: bool = ((s_411_31.value()) != 0);
        // C s_411_33: const #0s : i
        let s_411_33: i128 = 0;
        // C s_411_34: const #4s : i
        let s_411_34: i128 = 4;
        // D s_411_35: read-var u#34341:u32
        let s_411_35: u32 = fn_state.u_34341;
        // D s_411_36: cast zx s_411_35 -> bv
        let s_411_36: Bits = Bits::new(s_411_35 as u128, 32u16);
        // D s_411_37: bit-extract s_411_36 s_411_33 s_411_34
        let s_411_37: Bits = (Bits::new(
            ((s_411_36) >> (s_411_33)).value(),
            u16::try_from(s_411_34).unwrap(),
        ));
        // D s_411_38: cast reint s_411_37 -> u8
        let s_411_38: u8 = (s_411_37.value() as u8);
        // D s_411_39: call decode_aarch32_instrs_VRINTX_vfp_A1enc_A_txt(s_411_8, s_411_14, s_411_20, s_411_26, s_411_32, s_411_38)
        let s_411_39: () = decode_aarch32_instrs_VRINTX_vfp_A1enc_A_txt(
            state,
            tracer,
            s_411_8,
            s_411_14,
            s_411_20,
            s_411_26,
            s_411_32,
            s_411_38,
        );
        // N s_411_40: return
        return;
    }
    fn block_412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_412_0: read-var merge#var.1:struct
        let s_412_0: u32 = fn_state.merge_var._1;
        // D s_412_1: write-var u#34349 <= s_412_0
        fn_state.u_34349 = s_412_0;
        // C s_412_2: const #23s : i
        let s_412_2: i128 = 23;
        // D s_412_3: read-var u#34349:u32
        let s_412_3: u32 = fn_state.u_34349;
        // D s_412_4: cast zx s_412_3 -> bv
        let s_412_4: Bits = Bits::new(s_412_3 as u128, 32u16);
        // C s_412_5: const #1s : i64
        let s_412_5: i64 = 1;
        // C s_412_6: cast zx s_412_5 -> i
        let s_412_6: i128 = (i128::try_from(s_412_5).unwrap());
        // C s_412_7: const #4s : i
        let s_412_7: i128 = 4;
        // C s_412_8: add s_412_7 s_412_6
        let s_412_8: i128 = (s_412_7 + s_412_6);
        // D s_412_9: bit-extract s_412_4 s_412_2 s_412_8
        let s_412_9: Bits = (Bits::new(
            ((s_412_4) >> (s_412_2)).value(),
            u16::try_from(s_412_8).unwrap(),
        ));
        // D s_412_10: cast reint s_412_9 -> u8
        let s_412_10: u8 = (s_412_9.value() as u8);
        // D s_412_11: cast zx s_412_10 -> bv
        let s_412_11: Bits = Bits::new(s_412_10 as u128, 5u16);
        // C s_412_12: const #29u : u8
        let s_412_12: u8 = 29;
        // C s_412_13: cast zx s_412_12 -> bv
        let s_412_13: Bits = Bits::new(s_412_12 as u128, 5u16);
        // D s_412_14: cmp-eq s_412_11 s_412_13
        let s_412_14: bool = ((s_412_11) == (s_412_13));
        // N s_412_15: branch s_412_14 b692 b413
        if s_412_14 {
            return block_692(state, tracer, fn_state);
        } else {
            return block_413(state, tracer, fn_state);
        };
    }
    fn block_413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_413_0: const #0u : u8
        let s_413_0: bool = false;
        // D s_413_1: write-var gs#413456 <= s_413_0
        fn_state.gs_413456 = s_413_0;
        // N s_413_2: jump b414
        return block_414(state, tracer, fn_state);
    }
    fn block_414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_414_0: read-var gs#413456:u8
        let s_414_0: bool = fn_state.gs_413456;
        // N s_414_1: branch s_414_0 b688 b415
        if s_414_0 {
            return block_688(state, tracer, fn_state);
        } else {
            return block_415(state, tracer, fn_state);
        };
    }
    fn block_415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_415_0: const #0u : u8
        let s_415_0: bool = false;
        // D s_415_1: write-var gs#413461 <= s_415_0
        fn_state.gs_413461 = s_415_0;
        // N s_415_2: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_416_0: read-var gs#413461:u8
        let s_416_0: bool = fn_state.gs_413461;
        // D s_416_1: not s_416_0
        let s_416_1: bool = !s_416_0;
        // N s_416_2: branch s_416_1 b418 b417
        if s_416_1 {
            return block_418(state, tracer, fn_state);
        } else {
            return block_417(state, tracer, fn_state);
        };
    }
    fn block_417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_417_0: const #3884s : i
        let s_417_0: i128 = 3884;
        // C s_417_1: const #14696u : u32
        let s_417_1: u32 = 14696;
        // N s_417_2: write-reg s_417_1 <= s_417_0
        let s_417_2: () = {
            state.write_register::<i128>(s_417_1 as isize, s_417_0);
            tracer.write_register(s_417_1 as isize, s_417_0);
        };
        // C s_417_3: const #28s : i
        let s_417_3: i128 = 28;
        // C s_417_4: const #4s : i
        let s_417_4: i128 = 4;
        // D s_417_5: read-var u#34349:u32
        let s_417_5: u32 = fn_state.u_34349;
        // D s_417_6: cast zx s_417_5 -> bv
        let s_417_6: Bits = Bits::new(s_417_5 as u128, 32u16);
        // D s_417_7: bit-extract s_417_6 s_417_3 s_417_4
        let s_417_7: Bits = (Bits::new(
            ((s_417_6) >> (s_417_3)).value(),
            u16::try_from(s_417_4).unwrap(),
        ));
        // D s_417_8: cast reint s_417_7 -> u8
        let s_417_8: u8 = (s_417_7.value() as u8);
        // C s_417_9: const #22s : i
        let s_417_9: i128 = 22;
        // C s_417_10: const #1s : i
        let s_417_10: i128 = 1;
        // D s_417_11: read-var u#34349:u32
        let s_417_11: u32 = fn_state.u_34349;
        // D s_417_12: cast zx s_417_11 -> bv
        let s_417_12: Bits = Bits::new(s_417_11 as u128, 32u16);
        // D s_417_13: bit-extract s_417_12 s_417_9 s_417_10
        let s_417_13: Bits = (Bits::new(
            ((s_417_12) >> (s_417_9)).value(),
            u16::try_from(s_417_10).unwrap(),
        ));
        // D s_417_14: cast reint s_417_13 -> u8
        let s_417_14: bool = ((s_417_13.value()) != 0);
        // C s_417_15: const #12s : i
        let s_417_15: i128 = 12;
        // C s_417_16: const #4s : i
        let s_417_16: i128 = 4;
        // D s_417_17: read-var u#34349:u32
        let s_417_17: u32 = fn_state.u_34349;
        // D s_417_18: cast zx s_417_17 -> bv
        let s_417_18: Bits = Bits::new(s_417_17 as u128, 32u16);
        // D s_417_19: bit-extract s_417_18 s_417_15 s_417_16
        let s_417_19: Bits = (Bits::new(
            ((s_417_18) >> (s_417_15)).value(),
            u16::try_from(s_417_16).unwrap(),
        ));
        // D s_417_20: cast reint s_417_19 -> u8
        let s_417_20: u8 = (s_417_19.value() as u8);
        // C s_417_21: const #8s : i
        let s_417_21: i128 = 8;
        // C s_417_22: const #2s : i
        let s_417_22: i128 = 2;
        // D s_417_23: read-var u#34349:u32
        let s_417_23: u32 = fn_state.u_34349;
        // D s_417_24: cast zx s_417_23 -> bv
        let s_417_24: Bits = Bits::new(s_417_23 as u128, 32u16);
        // D s_417_25: bit-extract s_417_24 s_417_21 s_417_22
        let s_417_25: Bits = (Bits::new(
            ((s_417_24) >> (s_417_21)).value(),
            u16::try_from(s_417_22).unwrap(),
        ));
        // D s_417_26: cast reint s_417_25 -> u8
        let s_417_26: u8 = (s_417_25.value() as u8);
        // C s_417_27: const #7s : i
        let s_417_27: i128 = 7;
        // C s_417_28: const #1s : i
        let s_417_28: i128 = 1;
        // D s_417_29: read-var u#34349:u32
        let s_417_29: u32 = fn_state.u_34349;
        // D s_417_30: cast zx s_417_29 -> bv
        let s_417_30: Bits = Bits::new(s_417_29 as u128, 32u16);
        // D s_417_31: bit-extract s_417_30 s_417_27 s_417_28
        let s_417_31: Bits = (Bits::new(
            ((s_417_30) >> (s_417_27)).value(),
            u16::try_from(s_417_28).unwrap(),
        ));
        // D s_417_32: cast reint s_417_31 -> u8
        let s_417_32: bool = ((s_417_31.value()) != 0);
        // C s_417_33: const #5s : i
        let s_417_33: i128 = 5;
        // C s_417_34: const #1s : i
        let s_417_34: i128 = 1;
        // D s_417_35: read-var u#34349:u32
        let s_417_35: u32 = fn_state.u_34349;
        // D s_417_36: cast zx s_417_35 -> bv
        let s_417_36: Bits = Bits::new(s_417_35 as u128, 32u16);
        // D s_417_37: bit-extract s_417_36 s_417_33 s_417_34
        let s_417_37: Bits = (Bits::new(
            ((s_417_36) >> (s_417_33)).value(),
            u16::try_from(s_417_34).unwrap(),
        ));
        // D s_417_38: cast reint s_417_37 -> u8
        let s_417_38: bool = ((s_417_37.value()) != 0);
        // C s_417_39: const #0s : i
        let s_417_39: i128 = 0;
        // C s_417_40: const #4s : i
        let s_417_40: i128 = 4;
        // D s_417_41: read-var u#34349:u32
        let s_417_41: u32 = fn_state.u_34349;
        // D s_417_42: cast zx s_417_41 -> bv
        let s_417_42: Bits = Bits::new(s_417_41 as u128, 32u16);
        // D s_417_43: bit-extract s_417_42 s_417_39 s_417_40
        let s_417_43: Bits = (Bits::new(
            ((s_417_42) >> (s_417_39)).value(),
            u16::try_from(s_417_40).unwrap(),
        ));
        // D s_417_44: cast reint s_417_43 -> u8
        let s_417_44: u8 = (s_417_43.value() as u8);
        // D s_417_45: call decode_aarch32_instrs_VRINTZ_vfp_A1enc_A_txt(s_417_8, s_417_14, s_417_20, s_417_26, s_417_32, s_417_38, s_417_44)
        let s_417_45: () = decode_aarch32_instrs_VRINTZ_vfp_A1enc_A_txt(
            state,
            tracer,
            s_417_8,
            s_417_14,
            s_417_20,
            s_417_26,
            s_417_32,
            s_417_38,
            s_417_44,
        );
        // N s_417_46: return
        return;
    }
    fn block_418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_418_0: read-var merge#var.1:struct
        let s_418_0: u32 = fn_state.merge_var._1;
        // D s_418_1: write-var u#34358 <= s_418_0
        fn_state.u_34358 = s_418_0;
        // C s_418_2: const #23s : i
        let s_418_2: i128 = 23;
        // D s_418_3: read-var u#34358:u32
        let s_418_3: u32 = fn_state.u_34358;
        // D s_418_4: cast zx s_418_3 -> bv
        let s_418_4: Bits = Bits::new(s_418_3 as u128, 32u16);
        // C s_418_5: const #1s : i64
        let s_418_5: i64 = 1;
        // C s_418_6: cast zx s_418_5 -> i
        let s_418_6: i128 = (i128::try_from(s_418_5).unwrap());
        // C s_418_7: const #8s : i
        let s_418_7: i128 = 8;
        // C s_418_8: add s_418_7 s_418_6
        let s_418_8: i128 = (s_418_7 + s_418_6);
        // D s_418_9: bit-extract s_418_4 s_418_2 s_418_8
        let s_418_9: Bits = (Bits::new(
            ((s_418_4) >> (s_418_2)).value(),
            u16::try_from(s_418_8).unwrap(),
        ));
        // D s_418_10: cast reint s_418_9 -> u9
        let s_418_10: u16 = (s_418_9.value() as u16);
        // D s_418_11: cast zx s_418_10 -> bv
        let s_418_11: Bits = Bits::new(s_418_10 as u128, 9u16);
        // C s_418_12: const #508u : u9
        let s_418_12: u16 = 508;
        // C s_418_13: cast zx s_418_12 -> bv
        let s_418_13: Bits = Bits::new(s_418_12 as u128, 9u16);
        // D s_418_14: cmp-eq s_418_11 s_418_13
        let s_418_14: bool = ((s_418_11) == (s_418_13));
        // N s_418_15: branch s_418_14 b681 b419
        if s_418_14 {
            return block_681(state, tracer, fn_state);
        } else {
            return block_419(state, tracer, fn_state);
        };
    }
    fn block_419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_419_0: const #0u : u8
        let s_419_0: bool = false;
        // D s_419_1: write-var gs#413489 <= s_419_0
        fn_state.gs_413489 = s_419_0;
        // N s_419_2: jump b420
        return block_420(state, tracer, fn_state);
    }
    fn block_420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_420_0: read-var gs#413489:u8
        let s_420_0: bool = fn_state.gs_413489;
        // N s_420_1: branch s_420_0 b680 b421
        if s_420_0 {
            return block_680(state, tracer, fn_state);
        } else {
            return block_421(state, tracer, fn_state);
        };
    }
    fn block_421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_421_0: const #0u : u8
        let s_421_0: bool = false;
        // D s_421_1: write-var gs#413491 <= s_421_0
        fn_state.gs_413491 = s_421_0;
        // N s_421_2: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_422_0: read-var gs#413491:u8
        let s_422_0: bool = fn_state.gs_413491;
        // D s_422_1: not s_422_0
        let s_422_1: bool = !s_422_0;
        // N s_422_2: branch s_422_1 b424 b423
        if s_422_1 {
            return block_424(state, tracer, fn_state);
        } else {
            return block_423(state, tracer, fn_state);
        };
    }
    fn block_423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_423_0: const #3886s : i
        let s_423_0: i128 = 3886;
        // C s_423_1: const #14696u : u32
        let s_423_1: u32 = 14696;
        // N s_423_2: write-reg s_423_1 <= s_423_0
        let s_423_2: () = {
            state.write_register::<i128>(s_423_1 as isize, s_423_0);
            tracer.write_register(s_423_1 as isize, s_423_0);
        };
        // C s_423_3: const #22s : i
        let s_423_3: i128 = 22;
        // C s_423_4: const #1s : i
        let s_423_4: i128 = 1;
        // D s_423_5: read-var u#34358:u32
        let s_423_5: u32 = fn_state.u_34358;
        // D s_423_6: cast zx s_423_5 -> bv
        let s_423_6: Bits = Bits::new(s_423_5 as u128, 32u16);
        // D s_423_7: bit-extract s_423_6 s_423_3 s_423_4
        let s_423_7: Bits = (Bits::new(
            ((s_423_6) >> (s_423_3)).value(),
            u16::try_from(s_423_4).unwrap(),
        ));
        // D s_423_8: cast reint s_423_7 -> u8
        let s_423_8: bool = ((s_423_7.value()) != 0);
        // C s_423_9: const #20s : i
        let s_423_9: i128 = 20;
        // C s_423_10: const #2s : i
        let s_423_10: i128 = 2;
        // D s_423_11: read-var u#34358:u32
        let s_423_11: u32 = fn_state.u_34358;
        // D s_423_12: cast zx s_423_11 -> bv
        let s_423_12: Bits = Bits::new(s_423_11 as u128, 32u16);
        // D s_423_13: bit-extract s_423_12 s_423_9 s_423_10
        let s_423_13: Bits = (Bits::new(
            ((s_423_12) >> (s_423_9)).value(),
            u16::try_from(s_423_10).unwrap(),
        ));
        // D s_423_14: cast reint s_423_13 -> u8
        let s_423_14: u8 = (s_423_13.value() as u8);
        // C s_423_15: const #16s : i
        let s_423_15: i128 = 16;
        // C s_423_16: const #4s : i
        let s_423_16: i128 = 4;
        // D s_423_17: read-var u#34358:u32
        let s_423_17: u32 = fn_state.u_34358;
        // D s_423_18: cast zx s_423_17 -> bv
        let s_423_18: Bits = Bits::new(s_423_17 as u128, 32u16);
        // D s_423_19: bit-extract s_423_18 s_423_15 s_423_16
        let s_423_19: Bits = (Bits::new(
            ((s_423_18) >> (s_423_15)).value(),
            u16::try_from(s_423_16).unwrap(),
        ));
        // D s_423_20: cast reint s_423_19 -> u8
        let s_423_20: u8 = (s_423_19.value() as u8);
        // C s_423_21: const #12s : i
        let s_423_21: i128 = 12;
        // C s_423_22: const #4s : i
        let s_423_22: i128 = 4;
        // D s_423_23: read-var u#34358:u32
        let s_423_23: u32 = fn_state.u_34358;
        // D s_423_24: cast zx s_423_23 -> bv
        let s_423_24: Bits = Bits::new(s_423_23 as u128, 32u16);
        // D s_423_25: bit-extract s_423_24 s_423_21 s_423_22
        let s_423_25: Bits = (Bits::new(
            ((s_423_24) >> (s_423_21)).value(),
            u16::try_from(s_423_22).unwrap(),
        ));
        // D s_423_26: cast reint s_423_25 -> u8
        let s_423_26: u8 = (s_423_25.value() as u8);
        // C s_423_27: const #8s : i
        let s_423_27: i128 = 8;
        // C s_423_28: const #2s : i
        let s_423_28: i128 = 2;
        // D s_423_29: read-var u#34358:u32
        let s_423_29: u32 = fn_state.u_34358;
        // D s_423_30: cast zx s_423_29 -> bv
        let s_423_30: Bits = Bits::new(s_423_29 as u128, 32u16);
        // D s_423_31: bit-extract s_423_30 s_423_27 s_423_28
        let s_423_31: Bits = (Bits::new(
            ((s_423_30) >> (s_423_27)).value(),
            u16::try_from(s_423_28).unwrap(),
        ));
        // D s_423_32: cast reint s_423_31 -> u8
        let s_423_32: u8 = (s_423_31.value() as u8);
        // C s_423_33: const #7s : i
        let s_423_33: i128 = 7;
        // C s_423_34: const #1s : i
        let s_423_34: i128 = 1;
        // D s_423_35: read-var u#34358:u32
        let s_423_35: u32 = fn_state.u_34358;
        // D s_423_36: cast zx s_423_35 -> bv
        let s_423_36: Bits = Bits::new(s_423_35 as u128, 32u16);
        // D s_423_37: bit-extract s_423_36 s_423_33 s_423_34
        let s_423_37: Bits = (Bits::new(
            ((s_423_36) >> (s_423_33)).value(),
            u16::try_from(s_423_34).unwrap(),
        ));
        // D s_423_38: cast reint s_423_37 -> u8
        let s_423_38: bool = ((s_423_37.value()) != 0);
        // C s_423_39: const #5s : i
        let s_423_39: i128 = 5;
        // C s_423_40: const #1s : i
        let s_423_40: i128 = 1;
        // D s_423_41: read-var u#34358:u32
        let s_423_41: u32 = fn_state.u_34358;
        // D s_423_42: cast zx s_423_41 -> bv
        let s_423_42: Bits = Bits::new(s_423_41 as u128, 32u16);
        // D s_423_43: bit-extract s_423_42 s_423_39 s_423_40
        let s_423_43: Bits = (Bits::new(
            ((s_423_42) >> (s_423_39)).value(),
            u16::try_from(s_423_40).unwrap(),
        ));
        // D s_423_44: cast reint s_423_43 -> u8
        let s_423_44: bool = ((s_423_43.value()) != 0);
        // C s_423_45: const #0s : i
        let s_423_45: i128 = 0;
        // C s_423_46: const #4s : i
        let s_423_46: i128 = 4;
        // D s_423_47: read-var u#34358:u32
        let s_423_47: u32 = fn_state.u_34358;
        // D s_423_48: cast zx s_423_47 -> bv
        let s_423_48: Bits = Bits::new(s_423_47 as u128, 32u16);
        // D s_423_49: bit-extract s_423_48 s_423_45 s_423_46
        let s_423_49: Bits = (Bits::new(
            ((s_423_48) >> (s_423_45)).value(),
            u16::try_from(s_423_46).unwrap(),
        ));
        // D s_423_50: cast reint s_423_49 -> u8
        let s_423_50: u8 = (s_423_49.value() as u8);
        // D s_423_51: call decode_aarch32_instrs_VSEL_A1enc_A_txt(s_423_8, s_423_14, s_423_20, s_423_26, s_423_32, s_423_38, s_423_44, s_423_50)
        let s_423_51: () = decode_aarch32_instrs_VSEL_A1enc_A_txt(
            state,
            tracer,
            s_423_8,
            s_423_14,
            s_423_20,
            s_423_26,
            s_423_32,
            s_423_38,
            s_423_44,
            s_423_50,
        );
        // N s_423_52: return
        return;
    }
    fn block_424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_424_0: read-var merge#var.1:struct
        let s_424_0: u32 = fn_state.merge_var._1;
        // D s_424_1: write-var u#34367 <= s_424_0
        fn_state.u_34367 = s_424_0;
        // C s_424_2: const #23s : i
        let s_424_2: i128 = 23;
        // D s_424_3: read-var u#34367:u32
        let s_424_3: u32 = fn_state.u_34367;
        // D s_424_4: cast zx s_424_3 -> bv
        let s_424_4: Bits = Bits::new(s_424_3 as u128, 32u16);
        // C s_424_5: const #1s : i64
        let s_424_5: i64 = 1;
        // C s_424_6: cast zx s_424_5 -> i
        let s_424_6: i128 = (i128::try_from(s_424_5).unwrap());
        // C s_424_7: const #8s : i
        let s_424_7: i128 = 8;
        // C s_424_8: add s_424_7 s_424_6
        let s_424_8: i128 = (s_424_7 + s_424_6);
        // D s_424_9: bit-extract s_424_4 s_424_2 s_424_8
        let s_424_9: Bits = (Bits::new(
            ((s_424_4) >> (s_424_2)).value(),
            u16::try_from(s_424_8).unwrap(),
        ));
        // D s_424_10: cast reint s_424_9 -> u9
        let s_424_10: u16 = (s_424_9.value() as u16);
        // D s_424_11: cast zx s_424_10 -> bv
        let s_424_11: Bits = Bits::new(s_424_10 as u128, 9u16);
        // C s_424_12: const #504u : u9
        let s_424_12: u16 = 504;
        // C s_424_13: cast zx s_424_12 -> bv
        let s_424_13: Bits = Bits::new(s_424_12 as u128, 9u16);
        // D s_424_14: cmp-eq s_424_11 s_424_13
        let s_424_14: bool = ((s_424_11) == (s_424_13));
        // N s_424_15: branch s_424_14 b676 b425
        if s_424_14 {
            return block_676(state, tracer, fn_state);
        } else {
            return block_425(state, tracer, fn_state);
        };
    }
    fn block_425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_425_0: const #0u : u8
        let s_425_0: bool = false;
        // D s_425_1: write-var gs#413518 <= s_425_0
        fn_state.gs_413518 = s_425_0;
        // N s_425_2: jump b426
        return block_426(state, tracer, fn_state);
    }
    fn block_426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_426_0: read-var gs#413518:u8
        let s_426_0: bool = fn_state.gs_413518;
        // N s_426_1: branch s_426_0 b675 b427
        if s_426_0 {
            return block_675(state, tracer, fn_state);
        } else {
            return block_427(state, tracer, fn_state);
        };
    }
    fn block_427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_427_0: const #0u : u8
        let s_427_0: bool = false;
        // D s_427_1: write-var gs#413520 <= s_427_0
        fn_state.gs_413520 = s_427_0;
        // N s_427_2: jump b428
        return block_428(state, tracer, fn_state);
    }
    fn block_428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_428_0: read-var gs#413520:u8
        let s_428_0: bool = fn_state.gs_413520;
        // D s_428_1: not s_428_0
        let s_428_1: bool = !s_428_0;
        // N s_428_2: branch s_428_1 b430 b429
        if s_428_1 {
            return block_430(state, tracer, fn_state);
        } else {
            return block_429(state, tracer, fn_state);
        };
    }
    fn block_429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_429_0: const #3900s : i
        let s_429_0: i128 = 3900;
        // C s_429_1: const #14696u : u32
        let s_429_1: u32 = 14696;
        // N s_429_2: write-reg s_429_1 <= s_429_0
        let s_429_2: () = {
            state.write_register::<i128>(s_429_1 as isize, s_429_0);
            tracer.write_register(s_429_1 as isize, s_429_0);
        };
        // C s_429_3: const #22s : i
        let s_429_3: i128 = 22;
        // C s_429_4: const #1s : i
        let s_429_4: i128 = 1;
        // D s_429_5: read-var u#34367:u32
        let s_429_5: u32 = fn_state.u_34367;
        // D s_429_6: cast zx s_429_5 -> bv
        let s_429_6: Bits = Bits::new(s_429_5 as u128, 32u16);
        // D s_429_7: bit-extract s_429_6 s_429_3 s_429_4
        let s_429_7: Bits = (Bits::new(
            ((s_429_6) >> (s_429_3)).value(),
            u16::try_from(s_429_4).unwrap(),
        ));
        // D s_429_8: cast reint s_429_7 -> u8
        let s_429_8: bool = ((s_429_7.value()) != 0);
        // C s_429_9: const #16s : i
        let s_429_9: i128 = 16;
        // C s_429_10: const #4s : i
        let s_429_10: i128 = 4;
        // D s_429_11: read-var u#34367:u32
        let s_429_11: u32 = fn_state.u_34367;
        // D s_429_12: cast zx s_429_11 -> bv
        let s_429_12: Bits = Bits::new(s_429_11 as u128, 32u16);
        // D s_429_13: bit-extract s_429_12 s_429_9 s_429_10
        let s_429_13: Bits = (Bits::new(
            ((s_429_12) >> (s_429_9)).value(),
            u16::try_from(s_429_10).unwrap(),
        ));
        // D s_429_14: cast reint s_429_13 -> u8
        let s_429_14: u8 = (s_429_13.value() as u8);
        // C s_429_15: const #12s : i
        let s_429_15: i128 = 12;
        // C s_429_16: const #4s : i
        let s_429_16: i128 = 4;
        // D s_429_17: read-var u#34367:u32
        let s_429_17: u32 = fn_state.u_34367;
        // D s_429_18: cast zx s_429_17 -> bv
        let s_429_18: Bits = Bits::new(s_429_17 as u128, 32u16);
        // D s_429_19: bit-extract s_429_18 s_429_15 s_429_16
        let s_429_19: Bits = (Bits::new(
            ((s_429_18) >> (s_429_15)).value(),
            u16::try_from(s_429_16).unwrap(),
        ));
        // D s_429_20: cast reint s_429_19 -> u8
        let s_429_20: u8 = (s_429_19.value() as u8);
        // C s_429_21: const #7s : i
        let s_429_21: i128 = 7;
        // C s_429_22: const #1s : i
        let s_429_22: i128 = 1;
        // D s_429_23: read-var u#34367:u32
        let s_429_23: u32 = fn_state.u_34367;
        // D s_429_24: cast zx s_429_23 -> bv
        let s_429_24: Bits = Bits::new(s_429_23 as u128, 32u16);
        // D s_429_25: bit-extract s_429_24 s_429_21 s_429_22
        let s_429_25: Bits = (Bits::new(
            ((s_429_24) >> (s_429_21)).value(),
            u16::try_from(s_429_22).unwrap(),
        ));
        // D s_429_26: cast reint s_429_25 -> u8
        let s_429_26: bool = ((s_429_25.value()) != 0);
        // C s_429_27: const #6s : i
        let s_429_27: i128 = 6;
        // C s_429_28: const #1s : i
        let s_429_28: i128 = 1;
        // D s_429_29: read-var u#34367:u32
        let s_429_29: u32 = fn_state.u_34367;
        // D s_429_30: cast zx s_429_29 -> bv
        let s_429_30: Bits = Bits::new(s_429_29 as u128, 32u16);
        // D s_429_31: bit-extract s_429_30 s_429_27 s_429_28
        let s_429_31: Bits = (Bits::new(
            ((s_429_30) >> (s_429_27)).value(),
            u16::try_from(s_429_28).unwrap(),
        ));
        // D s_429_32: cast reint s_429_31 -> u8
        let s_429_32: bool = ((s_429_31.value()) != 0);
        // C s_429_33: const #5s : i
        let s_429_33: i128 = 5;
        // C s_429_34: const #1s : i
        let s_429_34: i128 = 1;
        // D s_429_35: read-var u#34367:u32
        let s_429_35: u32 = fn_state.u_34367;
        // D s_429_36: cast zx s_429_35 -> bv
        let s_429_36: Bits = Bits::new(s_429_35 as u128, 32u16);
        // D s_429_37: bit-extract s_429_36 s_429_33 s_429_34
        let s_429_37: Bits = (Bits::new(
            ((s_429_36) >> (s_429_33)).value(),
            u16::try_from(s_429_34).unwrap(),
        ));
        // D s_429_38: cast reint s_429_37 -> u8
        let s_429_38: bool = ((s_429_37.value()) != 0);
        // C s_429_39: const #4s : i
        let s_429_39: i128 = 4;
        // C s_429_40: const #1s : i
        let s_429_40: i128 = 1;
        // D s_429_41: read-var u#34367:u32
        let s_429_41: u32 = fn_state.u_34367;
        // D s_429_42: cast zx s_429_41 -> bv
        let s_429_42: Bits = Bits::new(s_429_41 as u128, 32u16);
        // D s_429_43: bit-extract s_429_42 s_429_39 s_429_40
        let s_429_43: Bits = (Bits::new(
            ((s_429_42) >> (s_429_39)).value(),
            u16::try_from(s_429_40).unwrap(),
        ));
        // D s_429_44: cast reint s_429_43 -> u8
        let s_429_44: bool = ((s_429_43.value()) != 0);
        // C s_429_45: const #0s : i
        let s_429_45: i128 = 0;
        // C s_429_46: const #4s : i
        let s_429_46: i128 = 4;
        // D s_429_47: read-var u#34367:u32
        let s_429_47: u32 = fn_state.u_34367;
        // D s_429_48: cast zx s_429_47 -> bv
        let s_429_48: Bits = Bits::new(s_429_47 as u128, 32u16);
        // D s_429_49: bit-extract s_429_48 s_429_45 s_429_46
        let s_429_49: Bits = (Bits::new(
            ((s_429_48) >> (s_429_45)).value(),
            u16::try_from(s_429_46).unwrap(),
        ));
        // D s_429_50: cast reint s_429_49 -> u8
        let s_429_50: u8 = (s_429_49.value() as u8);
        // D s_429_51: call decode_aarch32_instrs_VDOT_A1enc_A_txt(s_429_8, s_429_14, s_429_20, s_429_26, s_429_32, s_429_38, s_429_44, s_429_50)
        let s_429_51: () = decode_aarch32_instrs_VDOT_A1enc_A_txt(
            state,
            tracer,
            s_429_8,
            s_429_14,
            s_429_20,
            s_429_26,
            s_429_32,
            s_429_38,
            s_429_44,
            s_429_50,
        );
        // N s_429_52: return
        return;
    }
    fn block_430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_430_0: read-var merge#var.1:struct
        let s_430_0: u32 = fn_state.merge_var._1;
        // D s_430_1: write-var u#34377 <= s_430_0
        fn_state.u_34377 = s_430_0;
        // C s_430_2: const #23s : i
        let s_430_2: i128 = 23;
        // D s_430_3: read-var u#34377:u32
        let s_430_3: u32 = fn_state.u_34377;
        // D s_430_4: cast zx s_430_3 -> bv
        let s_430_4: Bits = Bits::new(s_430_3 as u128, 32u16);
        // C s_430_5: const #1s : i64
        let s_430_5: i64 = 1;
        // C s_430_6: cast zx s_430_5 -> i
        let s_430_6: i128 = (i128::try_from(s_430_5).unwrap());
        // C s_430_7: const #8s : i
        let s_430_7: i128 = 8;
        // C s_430_8: add s_430_7 s_430_6
        let s_430_8: i128 = (s_430_7 + s_430_6);
        // D s_430_9: bit-extract s_430_4 s_430_2 s_430_8
        let s_430_9: Bits = (Bits::new(
            ((s_430_4) >> (s_430_2)).value(),
            u16::try_from(s_430_8).unwrap(),
        ));
        // D s_430_10: cast reint s_430_9 -> u9
        let s_430_10: u16 = (s_430_9.value() as u16);
        // D s_430_11: cast zx s_430_10 -> bv
        let s_430_11: Bits = Bits::new(s_430_10 as u128, 9u16);
        // C s_430_12: const #508u : u9
        let s_430_12: u16 = 508;
        // C s_430_13: cast zx s_430_12 -> bv
        let s_430_13: Bits = Bits::new(s_430_12 as u128, 9u16);
        // D s_430_14: cmp-eq s_430_11 s_430_13
        let s_430_14: bool = ((s_430_11) == (s_430_13));
        // N s_430_15: branch s_430_14 b671 b431
        if s_430_14 {
            return block_671(state, tracer, fn_state);
        } else {
            return block_431(state, tracer, fn_state);
        };
    }
    fn block_431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_431_0: const #0u : u8
        let s_431_0: bool = false;
        // D s_431_1: write-var gs#413547 <= s_431_0
        fn_state.gs_413547 = s_431_0;
        // N s_431_2: jump b432
        return block_432(state, tracer, fn_state);
    }
    fn block_432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_432_0: read-var gs#413547:u8
        let s_432_0: bool = fn_state.gs_413547;
        // N s_432_1: branch s_432_0 b670 b433
        if s_432_0 {
            return block_670(state, tracer, fn_state);
        } else {
            return block_433(state, tracer, fn_state);
        };
    }
    fn block_433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_433_0: const #0u : u8
        let s_433_0: bool = false;
        // D s_433_1: write-var gs#413549 <= s_433_0
        fn_state.gs_413549 = s_433_0;
        // N s_433_2: jump b434
        return block_434(state, tracer, fn_state);
    }
    fn block_434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_434_0: read-var gs#413549:u8
        let s_434_0: bool = fn_state.gs_413549;
        // D s_434_1: not s_434_0
        let s_434_1: bool = !s_434_0;
        // N s_434_2: branch s_434_1 b436 b435
        if s_434_1 {
            return block_436(state, tracer, fn_state);
        } else {
            return block_435(state, tracer, fn_state);
        };
    }
    fn block_435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_435_0: const #3902s : i
        let s_435_0: i128 = 3902;
        // C s_435_1: const #14696u : u32
        let s_435_1: u32 = 14696;
        // N s_435_2: write-reg s_435_1 <= s_435_0
        let s_435_2: () = {
            state.write_register::<i128>(s_435_1 as isize, s_435_0);
            tracer.write_register(s_435_1 as isize, s_435_0);
        };
        // C s_435_3: const #23s : i
        let s_435_3: i128 = 23;
        // C s_435_4: const #1s : i
        let s_435_4: i128 = 1;
        // D s_435_5: read-var u#34377:u32
        let s_435_5: u32 = fn_state.u_34377;
        // D s_435_6: cast zx s_435_5 -> bv
        let s_435_6: Bits = Bits::new(s_435_5 as u128, 32u16);
        // D s_435_7: bit-extract s_435_6 s_435_3 s_435_4
        let s_435_7: Bits = (Bits::new(
            ((s_435_6) >> (s_435_3)).value(),
            u16::try_from(s_435_4).unwrap(),
        ));
        // D s_435_8: cast reint s_435_7 -> u8
        let s_435_8: bool = ((s_435_7.value()) != 0);
        // C s_435_9: const #22s : i
        let s_435_9: i128 = 22;
        // C s_435_10: const #1s : i
        let s_435_10: i128 = 1;
        // D s_435_11: read-var u#34377:u32
        let s_435_11: u32 = fn_state.u_34377;
        // D s_435_12: cast zx s_435_11 -> bv
        let s_435_12: Bits = Bits::new(s_435_11 as u128, 32u16);
        // D s_435_13: bit-extract s_435_12 s_435_9 s_435_10
        let s_435_13: Bits = (Bits::new(
            ((s_435_12) >> (s_435_9)).value(),
            u16::try_from(s_435_10).unwrap(),
        ));
        // D s_435_14: cast reint s_435_13 -> u8
        let s_435_14: bool = ((s_435_13.value()) != 0);
        // C s_435_15: const #20s : i
        let s_435_15: i128 = 20;
        // C s_435_16: const #2s : i
        let s_435_16: i128 = 2;
        // D s_435_17: read-var u#34377:u32
        let s_435_17: u32 = fn_state.u_34377;
        // D s_435_18: cast zx s_435_17 -> bv
        let s_435_18: Bits = Bits::new(s_435_17 as u128, 32u16);
        // D s_435_19: bit-extract s_435_18 s_435_15 s_435_16
        let s_435_19: Bits = (Bits::new(
            ((s_435_18) >> (s_435_15)).value(),
            u16::try_from(s_435_16).unwrap(),
        ));
        // D s_435_20: cast reint s_435_19 -> u8
        let s_435_20: u8 = (s_435_19.value() as u8);
        // C s_435_21: const #16s : i
        let s_435_21: i128 = 16;
        // C s_435_22: const #4s : i
        let s_435_22: i128 = 4;
        // D s_435_23: read-var u#34377:u32
        let s_435_23: u32 = fn_state.u_34377;
        // D s_435_24: cast zx s_435_23 -> bv
        let s_435_24: Bits = Bits::new(s_435_23 as u128, 32u16);
        // D s_435_25: bit-extract s_435_24 s_435_21 s_435_22
        let s_435_25: Bits = (Bits::new(
            ((s_435_24) >> (s_435_21)).value(),
            u16::try_from(s_435_22).unwrap(),
        ));
        // D s_435_26: cast reint s_435_25 -> u8
        let s_435_26: u8 = (s_435_25.value() as u8);
        // C s_435_27: const #12s : i
        let s_435_27: i128 = 12;
        // C s_435_28: const #4s : i
        let s_435_28: i128 = 4;
        // D s_435_29: read-var u#34377:u32
        let s_435_29: u32 = fn_state.u_34377;
        // D s_435_30: cast zx s_435_29 -> bv
        let s_435_30: Bits = Bits::new(s_435_29 as u128, 32u16);
        // D s_435_31: bit-extract s_435_30 s_435_27 s_435_28
        let s_435_31: Bits = (Bits::new(
            ((s_435_30) >> (s_435_27)).value(),
            u16::try_from(s_435_28).unwrap(),
        ));
        // D s_435_32: cast reint s_435_31 -> u8
        let s_435_32: u8 = (s_435_31.value() as u8);
        // C s_435_33: const #7s : i
        let s_435_33: i128 = 7;
        // C s_435_34: const #1s : i
        let s_435_34: i128 = 1;
        // D s_435_35: read-var u#34377:u32
        let s_435_35: u32 = fn_state.u_34377;
        // D s_435_36: cast zx s_435_35 -> bv
        let s_435_36: Bits = Bits::new(s_435_35 as u128, 32u16);
        // D s_435_37: bit-extract s_435_36 s_435_33 s_435_34
        let s_435_37: Bits = (Bits::new(
            ((s_435_36) >> (s_435_33)).value(),
            u16::try_from(s_435_34).unwrap(),
        ));
        // D s_435_38: cast reint s_435_37 -> u8
        let s_435_38: bool = ((s_435_37.value()) != 0);
        // C s_435_39: const #6s : i
        let s_435_39: i128 = 6;
        // C s_435_40: const #1s : i
        let s_435_40: i128 = 1;
        // D s_435_41: read-var u#34377:u32
        let s_435_41: u32 = fn_state.u_34377;
        // D s_435_42: cast zx s_435_41 -> bv
        let s_435_42: Bits = Bits::new(s_435_41 as u128, 32u16);
        // D s_435_43: bit-extract s_435_42 s_435_39 s_435_40
        let s_435_43: Bits = (Bits::new(
            ((s_435_42) >> (s_435_39)).value(),
            u16::try_from(s_435_40).unwrap(),
        ));
        // D s_435_44: cast reint s_435_43 -> u8
        let s_435_44: bool = ((s_435_43.value()) != 0);
        // C s_435_45: const #5s : i
        let s_435_45: i128 = 5;
        // C s_435_46: const #1s : i
        let s_435_46: i128 = 1;
        // D s_435_47: read-var u#34377:u32
        let s_435_47: u32 = fn_state.u_34377;
        // D s_435_48: cast zx s_435_47 -> bv
        let s_435_48: Bits = Bits::new(s_435_47 as u128, 32u16);
        // D s_435_49: bit-extract s_435_48 s_435_45 s_435_46
        let s_435_49: Bits = (Bits::new(
            ((s_435_48) >> (s_435_45)).value(),
            u16::try_from(s_435_46).unwrap(),
        ));
        // D s_435_50: cast reint s_435_49 -> u8
        let s_435_50: bool = ((s_435_49.value()) != 0);
        // C s_435_51: const #4s : i
        let s_435_51: i128 = 4;
        // C s_435_52: const #1s : i
        let s_435_52: i128 = 1;
        // D s_435_53: read-var u#34377:u32
        let s_435_53: u32 = fn_state.u_34377;
        // D s_435_54: cast zx s_435_53 -> bv
        let s_435_54: Bits = Bits::new(s_435_53 as u128, 32u16);
        // D s_435_55: bit-extract s_435_54 s_435_51 s_435_52
        let s_435_55: Bits = (Bits::new(
            ((s_435_54) >> (s_435_51)).value(),
            u16::try_from(s_435_52).unwrap(),
        ));
        // D s_435_56: cast reint s_435_55 -> u8
        let s_435_56: bool = ((s_435_55.value()) != 0);
        // C s_435_57: const #0s : i
        let s_435_57: i128 = 0;
        // C s_435_58: const #4s : i
        let s_435_58: i128 = 4;
        // D s_435_59: read-var u#34377:u32
        let s_435_59: u32 = fn_state.u_34377;
        // D s_435_60: cast zx s_435_59 -> bv
        let s_435_60: Bits = Bits::new(s_435_59 as u128, 32u16);
        // D s_435_61: bit-extract s_435_60 s_435_57 s_435_58
        let s_435_61: Bits = (Bits::new(
            ((s_435_60) >> (s_435_57)).value(),
            u16::try_from(s_435_58).unwrap(),
        ));
        // D s_435_62: cast reint s_435_61 -> u8
        let s_435_62: u8 = (s_435_61.value() as u8);
        // D s_435_63: call decode_aarch32_instrs_VDOT_s_A1enc_A_txt(s_435_8, s_435_14, s_435_20, s_435_26, s_435_32, s_435_38, s_435_44, s_435_50, s_435_56, s_435_62)
        let s_435_63: () = decode_aarch32_instrs_VDOT_s_A1enc_A_txt(
            state,
            tracer,
            s_435_8,
            s_435_14,
            s_435_20,
            s_435_26,
            s_435_32,
            s_435_38,
            s_435_44,
            s_435_50,
            s_435_56,
            s_435_62,
        );
        // N s_435_64: return
        return;
    }
    fn block_436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_436_0: read-var merge#var.1:struct
        let s_436_0: u32 = fn_state.merge_var._1;
        // D s_436_1: write-var u#34387 <= s_436_0
        fn_state.u_34387 = s_436_0;
        // C s_436_2: const #23s : i
        let s_436_2: i128 = 23;
        // D s_436_3: read-var u#34387:u32
        let s_436_3: u32 = fn_state.u_34387;
        // D s_436_4: cast zx s_436_3 -> bv
        let s_436_4: Bits = Bits::new(s_436_3 as u128, 32u16);
        // C s_436_5: const #1s : i64
        let s_436_5: i64 = 1;
        // C s_436_6: cast zx s_436_5 -> i
        let s_436_6: i128 = (i128::try_from(s_436_5).unwrap());
        // C s_436_7: const #4s : i
        let s_436_7: i128 = 4;
        // C s_436_8: add s_436_7 s_436_6
        let s_436_8: i128 = (s_436_7 + s_436_6);
        // D s_436_9: bit-extract s_436_4 s_436_2 s_436_8
        let s_436_9: Bits = (Bits::new(
            ((s_436_4) >> (s_436_2)).value(),
            u16::try_from(s_436_8).unwrap(),
        ));
        // D s_436_10: cast reint s_436_9 -> u8
        let s_436_10: u8 = (s_436_9.value() as u8);
        // D s_436_11: cast zx s_436_10 -> bv
        let s_436_11: Bits = Bits::new(s_436_10 as u128, 5u16);
        // C s_436_12: const #29u : u8
        let s_436_12: u8 = 29;
        // C s_436_13: cast zx s_436_12 -> bv
        let s_436_13: Bits = Bits::new(s_436_12 as u128, 5u16);
        // D s_436_14: cmp-eq s_436_11 s_436_13
        let s_436_14: bool = ((s_436_11) == (s_436_13));
        // N s_436_15: branch s_436_14 b663 b437
        if s_436_14 {
            return block_663(state, tracer, fn_state);
        } else {
            return block_437(state, tracer, fn_state);
        };
    }
    fn block_437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_437_0: const #0u : u8
        let s_437_0: bool = false;
        // D s_437_1: write-var gs#413583 <= s_437_0
        fn_state.gs_413583 = s_437_0;
        // N s_437_2: jump b438
        return block_438(state, tracer, fn_state);
    }
    fn block_438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_438_0: read-var gs#413583:u8
        let s_438_0: bool = fn_state.gs_413583;
        // N s_438_1: branch s_438_0 b659 b439
        if s_438_0 {
            return block_659(state, tracer, fn_state);
        } else {
            return block_439(state, tracer, fn_state);
        };
    }
    fn block_439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_439_0: const #0u : u8
        let s_439_0: bool = false;
        // D s_439_1: write-var gs#413588 <= s_439_0
        fn_state.gs_413588 = s_439_0;
        // N s_439_2: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_440_0: read-var gs#413588:u8
        let s_440_0: bool = fn_state.gs_413588;
        // D s_440_1: not s_440_0
        let s_440_1: bool = !s_440_0;
        // N s_440_2: branch s_440_1 b442 b441
        if s_440_1 {
            return block_442(state, tracer, fn_state);
        } else {
            return block_441(state, tracer, fn_state);
        };
    }
    fn block_441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_441_0: const #3904s : i
        let s_441_0: i128 = 3904;
        // C s_441_1: const #14696u : u32
        let s_441_1: u32 = 14696;
        // N s_441_2: write-reg s_441_1 <= s_441_0
        let s_441_2: () = {
            state.write_register::<i128>(s_441_1 as isize, s_441_0);
            tracer.write_register(s_441_1 as isize, s_441_0);
        };
        // C s_441_3: const #28s : i
        let s_441_3: i128 = 28;
        // C s_441_4: const #4s : i
        let s_441_4: i128 = 4;
        // D s_441_5: read-var u#34387:u32
        let s_441_5: u32 = fn_state.u_34387;
        // D s_441_6: cast zx s_441_5 -> bv
        let s_441_6: Bits = Bits::new(s_441_5 as u128, 32u16);
        // D s_441_7: bit-extract s_441_6 s_441_3 s_441_4
        let s_441_7: Bits = (Bits::new(
            ((s_441_6) >> (s_441_3)).value(),
            u16::try_from(s_441_4).unwrap(),
        ));
        // D s_441_8: cast reint s_441_7 -> u8
        let s_441_8: u8 = (s_441_7.value() as u8);
        // C s_441_9: const #22s : i
        let s_441_9: i128 = 22;
        // C s_441_10: const #1s : i
        let s_441_10: i128 = 1;
        // D s_441_11: read-var u#34387:u32
        let s_441_11: u32 = fn_state.u_34387;
        // D s_441_12: cast zx s_441_11 -> bv
        let s_441_12: Bits = Bits::new(s_441_11 as u128, 32u16);
        // D s_441_13: bit-extract s_441_12 s_441_9 s_441_10
        let s_441_13: Bits = (Bits::new(
            ((s_441_12) >> (s_441_9)).value(),
            u16::try_from(s_441_10).unwrap(),
        ));
        // D s_441_14: cast reint s_441_13 -> u8
        let s_441_14: bool = ((s_441_13.value()) != 0);
        // C s_441_15: const #12s : i
        let s_441_15: i128 = 12;
        // C s_441_16: const #4s : i
        let s_441_16: i128 = 4;
        // D s_441_17: read-var u#34387:u32
        let s_441_17: u32 = fn_state.u_34387;
        // D s_441_18: cast zx s_441_17 -> bv
        let s_441_18: Bits = Bits::new(s_441_17 as u128, 32u16);
        // D s_441_19: bit-extract s_441_18 s_441_15 s_441_16
        let s_441_19: Bits = (Bits::new(
            ((s_441_18) >> (s_441_15)).value(),
            u16::try_from(s_441_16).unwrap(),
        ));
        // D s_441_20: cast reint s_441_19 -> u8
        let s_441_20: u8 = (s_441_19.value() as u8);
        // C s_441_21: const #5s : i
        let s_441_21: i128 = 5;
        // C s_441_22: const #1s : i
        let s_441_22: i128 = 1;
        // D s_441_23: read-var u#34387:u32
        let s_441_23: u32 = fn_state.u_34387;
        // D s_441_24: cast zx s_441_23 -> bv
        let s_441_24: Bits = Bits::new(s_441_23 as u128, 32u16);
        // D s_441_25: bit-extract s_441_24 s_441_21 s_441_22
        let s_441_25: Bits = (Bits::new(
            ((s_441_24) >> (s_441_21)).value(),
            u16::try_from(s_441_22).unwrap(),
        ));
        // D s_441_26: cast reint s_441_25 -> u8
        let s_441_26: bool = ((s_441_25.value()) != 0);
        // C s_441_27: const #0s : i
        let s_441_27: i128 = 0;
        // C s_441_28: const #4s : i
        let s_441_28: i128 = 4;
        // D s_441_29: read-var u#34387:u32
        let s_441_29: u32 = fn_state.u_34387;
        // D s_441_30: cast zx s_441_29 -> bv
        let s_441_30: Bits = Bits::new(s_441_29 as u128, 32u16);
        // D s_441_31: bit-extract s_441_30 s_441_27 s_441_28
        let s_441_31: Bits = (Bits::new(
            ((s_441_30) >> (s_441_27)).value(),
            u16::try_from(s_441_28).unwrap(),
        ));
        // D s_441_32: cast reint s_441_31 -> u8
        let s_441_32: u8 = (s_441_31.value() as u8);
        // D s_441_33: call decode_aarch32_instrs_VJCVT_A1enc_A_txt(s_441_8, s_441_14, s_441_20, s_441_26, s_441_32)
        let s_441_33: () = decode_aarch32_instrs_VJCVT_A1enc_A_txt(
            state,
            tracer,
            s_441_8,
            s_441_14,
            s_441_20,
            s_441_26,
            s_441_32,
        );
        // N s_441_34: return
        return;
    }
    fn block_442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_442_0: read-var merge#var.1:struct
        let s_442_0: u32 = fn_state.merge_var._1;
        // D s_442_1: write-var u#34394 <= s_442_0
        fn_state.u_34394 = s_442_0;
        // C s_442_2: const #25s : i
        let s_442_2: i128 = 25;
        // D s_442_3: read-var u#34394:u32
        let s_442_3: u32 = fn_state.u_34394;
        // D s_442_4: cast zx s_442_3 -> bv
        let s_442_4: Bits = Bits::new(s_442_3 as u128, 32u16);
        // C s_442_5: const #1s : i64
        let s_442_5: i64 = 1;
        // C s_442_6: cast zx s_442_5 -> i
        let s_442_6: i128 = (i128::try_from(s_442_5).unwrap());
        // C s_442_7: const #6s : i
        let s_442_7: i128 = 6;
        // C s_442_8: add s_442_7 s_442_6
        let s_442_8: i128 = (s_442_7 + s_442_6);
        // D s_442_9: bit-extract s_442_4 s_442_2 s_442_8
        let s_442_9: Bits = (Bits::new(
            ((s_442_4) >> (s_442_2)).value(),
            u16::try_from(s_442_8).unwrap(),
        ));
        // D s_442_10: cast reint s_442_9 -> u8
        let s_442_10: u8 = (s_442_9.value() as u8);
        // D s_442_11: cast zx s_442_10 -> bv
        let s_442_11: Bits = Bits::new(s_442_10 as u128, 7u16);
        // C s_442_12: const #126u : u8
        let s_442_12: u8 = 126;
        // C s_442_13: cast zx s_442_12 -> bv
        let s_442_13: Bits = Bits::new(s_442_12 as u128, 7u16);
        // D s_442_14: cmp-eq s_442_11 s_442_13
        let s_442_14: bool = ((s_442_11) == (s_442_13));
        // N s_442_15: branch s_442_14 b652 b443
        if s_442_14 {
            return block_652(state, tracer, fn_state);
        } else {
            return block_443(state, tracer, fn_state);
        };
    }
    fn block_443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_443_0: const #0u : u8
        let s_443_0: bool = false;
        // D s_443_1: write-var gs#413612 <= s_443_0
        fn_state.gs_413612 = s_443_0;
        // N s_443_2: jump b444
        return block_444(state, tracer, fn_state);
    }
    fn block_444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_444_0: read-var gs#413612:u8
        let s_444_0: bool = fn_state.gs_413612;
        // N s_444_1: branch s_444_0 b651 b445
        if s_444_0 {
            return block_651(state, tracer, fn_state);
        } else {
            return block_445(state, tracer, fn_state);
        };
    }
    fn block_445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_445_0: const #0u : u8
        let s_445_0: bool = false;
        // D s_445_1: write-var gs#413614 <= s_445_0
        fn_state.gs_413614 = s_445_0;
        // N s_445_2: jump b446
        return block_446(state, tracer, fn_state);
    }
    fn block_446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_446_0: read-var gs#413614:u8
        let s_446_0: bool = fn_state.gs_413614;
        // D s_446_1: not s_446_0
        let s_446_1: bool = !s_446_0;
        // N s_446_2: branch s_446_1 b448 b447
        if s_446_1 {
            return block_448(state, tracer, fn_state);
        } else {
            return block_447(state, tracer, fn_state);
        };
    }
    fn block_447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_447_0: const #3906s : i
        let s_447_0: i128 = 3906;
        // C s_447_1: const #14696u : u32
        let s_447_1: u32 = 14696;
        // N s_447_2: write-reg s_447_1 <= s_447_0
        let s_447_2: () = {
            state.write_register::<i128>(s_447_1 as isize, s_447_0);
            tracer.write_register(s_447_1 as isize, s_447_0);
        };
        // C s_447_3: const #23s : i
        let s_447_3: i128 = 23;
        // C s_447_4: const #2s : i
        let s_447_4: i128 = 2;
        // D s_447_5: read-var u#34394:u32
        let s_447_5: u32 = fn_state.u_34394;
        // D s_447_6: cast zx s_447_5 -> bv
        let s_447_6: Bits = Bits::new(s_447_5 as u128, 32u16);
        // D s_447_7: bit-extract s_447_6 s_447_3 s_447_4
        let s_447_7: Bits = (Bits::new(
            ((s_447_6) >> (s_447_3)).value(),
            u16::try_from(s_447_4).unwrap(),
        ));
        // D s_447_8: cast reint s_447_7 -> u8
        let s_447_8: u8 = (s_447_7.value() as u8);
        // C s_447_9: const #22s : i
        let s_447_9: i128 = 22;
        // C s_447_10: const #1s : i
        let s_447_10: i128 = 1;
        // D s_447_11: read-var u#34394:u32
        let s_447_11: u32 = fn_state.u_34394;
        // D s_447_12: cast zx s_447_11 -> bv
        let s_447_12: Bits = Bits::new(s_447_11 as u128, 32u16);
        // D s_447_13: bit-extract s_447_12 s_447_9 s_447_10
        let s_447_13: Bits = (Bits::new(
            ((s_447_12) >> (s_447_9)).value(),
            u16::try_from(s_447_10).unwrap(),
        ));
        // D s_447_14: cast reint s_447_13 -> u8
        let s_447_14: bool = ((s_447_13.value()) != 0);
        // C s_447_15: const #20s : i
        let s_447_15: i128 = 20;
        // C s_447_16: const #1s : i
        let s_447_16: i128 = 1;
        // D s_447_17: read-var u#34394:u32
        let s_447_17: u32 = fn_state.u_34394;
        // D s_447_18: cast zx s_447_17 -> bv
        let s_447_18: Bits = Bits::new(s_447_17 as u128, 32u16);
        // D s_447_19: bit-extract s_447_18 s_447_15 s_447_16
        let s_447_19: Bits = (Bits::new(
            ((s_447_18) >> (s_447_15)).value(),
            u16::try_from(s_447_16).unwrap(),
        ));
        // D s_447_20: cast reint s_447_19 -> u8
        let s_447_20: bool = ((s_447_19.value()) != 0);
        // C s_447_21: const #16s : i
        let s_447_21: i128 = 16;
        // C s_447_22: const #4s : i
        let s_447_22: i128 = 4;
        // D s_447_23: read-var u#34394:u32
        let s_447_23: u32 = fn_state.u_34394;
        // D s_447_24: cast zx s_447_23 -> bv
        let s_447_24: Bits = Bits::new(s_447_23 as u128, 32u16);
        // D s_447_25: bit-extract s_447_24 s_447_21 s_447_22
        let s_447_25: Bits = (Bits::new(
            ((s_447_24) >> (s_447_21)).value(),
            u16::try_from(s_447_22).unwrap(),
        ));
        // D s_447_26: cast reint s_447_25 -> u8
        let s_447_26: u8 = (s_447_25.value() as u8);
        // C s_447_27: const #12s : i
        let s_447_27: i128 = 12;
        // C s_447_28: const #4s : i
        let s_447_28: i128 = 4;
        // D s_447_29: read-var u#34394:u32
        let s_447_29: u32 = fn_state.u_34394;
        // D s_447_30: cast zx s_447_29 -> bv
        let s_447_30: Bits = Bits::new(s_447_29 as u128, 32u16);
        // D s_447_31: bit-extract s_447_30 s_447_27 s_447_28
        let s_447_31: Bits = (Bits::new(
            ((s_447_30) >> (s_447_27)).value(),
            u16::try_from(s_447_28).unwrap(),
        ));
        // D s_447_32: cast reint s_447_31 -> u8
        let s_447_32: u8 = (s_447_31.value() as u8);
        // C s_447_33: const #7s : i
        let s_447_33: i128 = 7;
        // C s_447_34: const #1s : i
        let s_447_34: i128 = 1;
        // D s_447_35: read-var u#34394:u32
        let s_447_35: u32 = fn_state.u_34394;
        // D s_447_36: cast zx s_447_35 -> bv
        let s_447_36: Bits = Bits::new(s_447_35 as u128, 32u16);
        // D s_447_37: bit-extract s_447_36 s_447_33 s_447_34
        let s_447_37: Bits = (Bits::new(
            ((s_447_36) >> (s_447_33)).value(),
            u16::try_from(s_447_34).unwrap(),
        ));
        // D s_447_38: cast reint s_447_37 -> u8
        let s_447_38: bool = ((s_447_37.value()) != 0);
        // C s_447_39: const #6s : i
        let s_447_39: i128 = 6;
        // C s_447_40: const #1s : i
        let s_447_40: i128 = 1;
        // D s_447_41: read-var u#34394:u32
        let s_447_41: u32 = fn_state.u_34394;
        // D s_447_42: cast zx s_447_41 -> bv
        let s_447_42: Bits = Bits::new(s_447_41 as u128, 32u16);
        // D s_447_43: bit-extract s_447_42 s_447_39 s_447_40
        let s_447_43: Bits = (Bits::new(
            ((s_447_42) >> (s_447_39)).value(),
            u16::try_from(s_447_40).unwrap(),
        ));
        // D s_447_44: cast reint s_447_43 -> u8
        let s_447_44: bool = ((s_447_43.value()) != 0);
        // C s_447_45: const #5s : i
        let s_447_45: i128 = 5;
        // C s_447_46: const #1s : i
        let s_447_46: i128 = 1;
        // D s_447_47: read-var u#34394:u32
        let s_447_47: u32 = fn_state.u_34394;
        // D s_447_48: cast zx s_447_47 -> bv
        let s_447_48: Bits = Bits::new(s_447_47 as u128, 32u16);
        // D s_447_49: bit-extract s_447_48 s_447_45 s_447_46
        let s_447_49: Bits = (Bits::new(
            ((s_447_48) >> (s_447_45)).value(),
            u16::try_from(s_447_46).unwrap(),
        ));
        // D s_447_50: cast reint s_447_49 -> u8
        let s_447_50: bool = ((s_447_49.value()) != 0);
        // C s_447_51: const #0s : i
        let s_447_51: i128 = 0;
        // C s_447_52: const #4s : i
        let s_447_52: i128 = 4;
        // D s_447_53: read-var u#34394:u32
        let s_447_53: u32 = fn_state.u_34394;
        // D s_447_54: cast zx s_447_53 -> bv
        let s_447_54: Bits = Bits::new(s_447_53 as u128, 32u16);
        // D s_447_55: bit-extract s_447_54 s_447_51 s_447_52
        let s_447_55: Bits = (Bits::new(
            ((s_447_54) >> (s_447_51)).value(),
            u16::try_from(s_447_52).unwrap(),
        ));
        // D s_447_56: cast reint s_447_55 -> u8
        let s_447_56: u8 = (s_447_55.value() as u8);
        // D s_447_57: call decode_aarch32_instrs_VCMLA_A1enc_A_txt(s_447_8, s_447_14, s_447_20, s_447_26, s_447_32, s_447_38, s_447_44, s_447_50, s_447_56)
        let s_447_57: () = decode_aarch32_instrs_VCMLA_A1enc_A_txt(
            state,
            tracer,
            s_447_8,
            s_447_14,
            s_447_20,
            s_447_26,
            s_447_32,
            s_447_38,
            s_447_44,
            s_447_50,
            s_447_56,
        );
        // N s_447_58: return
        return;
    }
    fn block_448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_448_0: read-var merge#var.1:struct
        let s_448_0: u32 = fn_state.merge_var._1;
        // D s_448_1: write-var u#34403 <= s_448_0
        fn_state.u_34403 = s_448_0;
        // C s_448_2: const #24s : i
        let s_448_2: i128 = 24;
        // D s_448_3: read-var u#34403:u32
        let s_448_3: u32 = fn_state.u_34403;
        // D s_448_4: cast zx s_448_3 -> bv
        let s_448_4: Bits = Bits::new(s_448_3 as u128, 32u16);
        // C s_448_5: const #1s : i64
        let s_448_5: i64 = 1;
        // C s_448_6: cast zx s_448_5 -> i
        let s_448_6: i128 = (i128::try_from(s_448_5).unwrap());
        // C s_448_7: const #7s : i
        let s_448_7: i128 = 7;
        // C s_448_8: add s_448_7 s_448_6
        let s_448_8: i128 = (s_448_7 + s_448_6);
        // D s_448_9: bit-extract s_448_4 s_448_2 s_448_8
        let s_448_9: Bits = (Bits::new(
            ((s_448_4) >> (s_448_2)).value(),
            u16::try_from(s_448_8).unwrap(),
        ));
        // D s_448_10: cast reint s_448_9 -> u8
        let s_448_10: u8 = (s_448_9.value() as u8);
        // D s_448_11: cast zx s_448_10 -> bv
        let s_448_11: Bits = Bits::new(s_448_10 as u128, 8u16);
        // C s_448_12: const #254u : u8
        let s_448_12: u8 = 254;
        // C s_448_13: cast zx s_448_12 -> bv
        let s_448_13: Bits = Bits::new(s_448_12 as u128, 8u16);
        // D s_448_14: cmp-eq s_448_11 s_448_13
        let s_448_14: bool = ((s_448_11) == (s_448_13));
        // N s_448_15: branch s_448_14 b647 b449
        if s_448_14 {
            return block_647(state, tracer, fn_state);
        } else {
            return block_449(state, tracer, fn_state);
        };
    }
    fn block_449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_449_0: const #0u : u8
        let s_449_0: bool = false;
        // D s_449_1: write-var gs#413643 <= s_449_0
        fn_state.gs_413643 = s_449_0;
        // N s_449_2: jump b450
        return block_450(state, tracer, fn_state);
    }
    fn block_450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_450_0: read-var gs#413643:u8
        let s_450_0: bool = fn_state.gs_413643;
        // N s_450_1: branch s_450_0 b646 b451
        if s_450_0 {
            return block_646(state, tracer, fn_state);
        } else {
            return block_451(state, tracer, fn_state);
        };
    }
    fn block_451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_451_0: const #0u : u8
        let s_451_0: bool = false;
        // D s_451_1: write-var gs#413645 <= s_451_0
        fn_state.gs_413645 = s_451_0;
        // N s_451_2: jump b452
        return block_452(state, tracer, fn_state);
    }
    fn block_452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_452_0: read-var gs#413645:u8
        let s_452_0: bool = fn_state.gs_413645;
        // D s_452_1: not s_452_0
        let s_452_1: bool = !s_452_0;
        // N s_452_2: branch s_452_1 b454 b453
        if s_452_1 {
            return block_454(state, tracer, fn_state);
        } else {
            return block_453(state, tracer, fn_state);
        };
    }
    fn block_453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_453_0: const #3908s : i
        let s_453_0: i128 = 3908;
        // C s_453_1: const #14696u : u32
        let s_453_1: u32 = 14696;
        // N s_453_2: write-reg s_453_1 <= s_453_0
        let s_453_2: () = {
            state.write_register::<i128>(s_453_1 as isize, s_453_0);
            tracer.write_register(s_453_1 as isize, s_453_0);
        };
        // C s_453_3: const #23s : i
        let s_453_3: i128 = 23;
        // C s_453_4: const #1s : i
        let s_453_4: i128 = 1;
        // D s_453_5: read-var u#34403:u32
        let s_453_5: u32 = fn_state.u_34403;
        // D s_453_6: cast zx s_453_5 -> bv
        let s_453_6: Bits = Bits::new(s_453_5 as u128, 32u16);
        // D s_453_7: bit-extract s_453_6 s_453_3 s_453_4
        let s_453_7: Bits = (Bits::new(
            ((s_453_6) >> (s_453_3)).value(),
            u16::try_from(s_453_4).unwrap(),
        ));
        // D s_453_8: cast reint s_453_7 -> u8
        let s_453_8: bool = ((s_453_7.value()) != 0);
        // C s_453_9: const #22s : i
        let s_453_9: i128 = 22;
        // C s_453_10: const #1s : i
        let s_453_10: i128 = 1;
        // D s_453_11: read-var u#34403:u32
        let s_453_11: u32 = fn_state.u_34403;
        // D s_453_12: cast zx s_453_11 -> bv
        let s_453_12: Bits = Bits::new(s_453_11 as u128, 32u16);
        // D s_453_13: bit-extract s_453_12 s_453_9 s_453_10
        let s_453_13: Bits = (Bits::new(
            ((s_453_12) >> (s_453_9)).value(),
            u16::try_from(s_453_10).unwrap(),
        ));
        // D s_453_14: cast reint s_453_13 -> u8
        let s_453_14: bool = ((s_453_13.value()) != 0);
        // C s_453_15: const #20s : i
        let s_453_15: i128 = 20;
        // C s_453_16: const #2s : i
        let s_453_16: i128 = 2;
        // D s_453_17: read-var u#34403:u32
        let s_453_17: u32 = fn_state.u_34403;
        // D s_453_18: cast zx s_453_17 -> bv
        let s_453_18: Bits = Bits::new(s_453_17 as u128, 32u16);
        // D s_453_19: bit-extract s_453_18 s_453_15 s_453_16
        let s_453_19: Bits = (Bits::new(
            ((s_453_18) >> (s_453_15)).value(),
            u16::try_from(s_453_16).unwrap(),
        ));
        // D s_453_20: cast reint s_453_19 -> u8
        let s_453_20: u8 = (s_453_19.value() as u8);
        // C s_453_21: const #16s : i
        let s_453_21: i128 = 16;
        // C s_453_22: const #4s : i
        let s_453_22: i128 = 4;
        // D s_453_23: read-var u#34403:u32
        let s_453_23: u32 = fn_state.u_34403;
        // D s_453_24: cast zx s_453_23 -> bv
        let s_453_24: Bits = Bits::new(s_453_23 as u128, 32u16);
        // D s_453_25: bit-extract s_453_24 s_453_21 s_453_22
        let s_453_25: Bits = (Bits::new(
            ((s_453_24) >> (s_453_21)).value(),
            u16::try_from(s_453_22).unwrap(),
        ));
        // D s_453_26: cast reint s_453_25 -> u8
        let s_453_26: u8 = (s_453_25.value() as u8);
        // C s_453_27: const #12s : i
        let s_453_27: i128 = 12;
        // C s_453_28: const #4s : i
        let s_453_28: i128 = 4;
        // D s_453_29: read-var u#34403:u32
        let s_453_29: u32 = fn_state.u_34403;
        // D s_453_30: cast zx s_453_29 -> bv
        let s_453_30: Bits = Bits::new(s_453_29 as u128, 32u16);
        // D s_453_31: bit-extract s_453_30 s_453_27 s_453_28
        let s_453_31: Bits = (Bits::new(
            ((s_453_30) >> (s_453_27)).value(),
            u16::try_from(s_453_28).unwrap(),
        ));
        // D s_453_32: cast reint s_453_31 -> u8
        let s_453_32: u8 = (s_453_31.value() as u8);
        // C s_453_33: const #7s : i
        let s_453_33: i128 = 7;
        // C s_453_34: const #1s : i
        let s_453_34: i128 = 1;
        // D s_453_35: read-var u#34403:u32
        let s_453_35: u32 = fn_state.u_34403;
        // D s_453_36: cast zx s_453_35 -> bv
        let s_453_36: Bits = Bits::new(s_453_35 as u128, 32u16);
        // D s_453_37: bit-extract s_453_36 s_453_33 s_453_34
        let s_453_37: Bits = (Bits::new(
            ((s_453_36) >> (s_453_33)).value(),
            u16::try_from(s_453_34).unwrap(),
        ));
        // D s_453_38: cast reint s_453_37 -> u8
        let s_453_38: bool = ((s_453_37.value()) != 0);
        // C s_453_39: const #6s : i
        let s_453_39: i128 = 6;
        // C s_453_40: const #1s : i
        let s_453_40: i128 = 1;
        // D s_453_41: read-var u#34403:u32
        let s_453_41: u32 = fn_state.u_34403;
        // D s_453_42: cast zx s_453_41 -> bv
        let s_453_42: Bits = Bits::new(s_453_41 as u128, 32u16);
        // D s_453_43: bit-extract s_453_42 s_453_39 s_453_40
        let s_453_43: Bits = (Bits::new(
            ((s_453_42) >> (s_453_39)).value(),
            u16::try_from(s_453_40).unwrap(),
        ));
        // D s_453_44: cast reint s_453_43 -> u8
        let s_453_44: bool = ((s_453_43.value()) != 0);
        // C s_453_45: const #5s : i
        let s_453_45: i128 = 5;
        // C s_453_46: const #1s : i
        let s_453_46: i128 = 1;
        // D s_453_47: read-var u#34403:u32
        let s_453_47: u32 = fn_state.u_34403;
        // D s_453_48: cast zx s_453_47 -> bv
        let s_453_48: Bits = Bits::new(s_453_47 as u128, 32u16);
        // D s_453_49: bit-extract s_453_48 s_453_45 s_453_46
        let s_453_49: Bits = (Bits::new(
            ((s_453_48) >> (s_453_45)).value(),
            u16::try_from(s_453_46).unwrap(),
        ));
        // D s_453_50: cast reint s_453_49 -> u8
        let s_453_50: bool = ((s_453_49.value()) != 0);
        // C s_453_51: const #0s : i
        let s_453_51: i128 = 0;
        // C s_453_52: const #4s : i
        let s_453_52: i128 = 4;
        // D s_453_53: read-var u#34403:u32
        let s_453_53: u32 = fn_state.u_34403;
        // D s_453_54: cast zx s_453_53 -> bv
        let s_453_54: Bits = Bits::new(s_453_53 as u128, 32u16);
        // D s_453_55: bit-extract s_453_54 s_453_51 s_453_52
        let s_453_55: Bits = (Bits::new(
            ((s_453_54) >> (s_453_51)).value(),
            u16::try_from(s_453_52).unwrap(),
        ));
        // D s_453_56: cast reint s_453_55 -> u8
        let s_453_56: u8 = (s_453_55.value() as u8);
        // D s_453_57: call decode_aarch32_instrs_VCMLA_idx_A1enc_A_txt(s_453_8, s_453_14, s_453_20, s_453_26, s_453_32, s_453_38, s_453_44, s_453_50, s_453_56)
        let s_453_57: () = decode_aarch32_instrs_VCMLA_idx_A1enc_A_txt(
            state,
            tracer,
            s_453_8,
            s_453_14,
            s_453_20,
            s_453_26,
            s_453_32,
            s_453_38,
            s_453_44,
            s_453_50,
            s_453_56,
        );
        // N s_453_58: return
        return;
    }
    fn block_454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_454_0: read-var merge#var.1:struct
        let s_454_0: u32 = fn_state.merge_var._1;
        // D s_454_1: write-var u#34414 <= s_454_0
        fn_state.u_34414 = s_454_0;
        // C s_454_2: const #25s : i
        let s_454_2: i128 = 25;
        // D s_454_3: read-var u#34414:u32
        let s_454_3: u32 = fn_state.u_34414;
        // D s_454_4: cast zx s_454_3 -> bv
        let s_454_4: Bits = Bits::new(s_454_3 as u128, 32u16);
        // C s_454_5: const #1s : i64
        let s_454_5: i64 = 1;
        // C s_454_6: cast zx s_454_5 -> i
        let s_454_6: i128 = (i128::try_from(s_454_5).unwrap());
        // C s_454_7: const #6s : i
        let s_454_7: i128 = 6;
        // C s_454_8: add s_454_7 s_454_6
        let s_454_8: i128 = (s_454_7 + s_454_6);
        // D s_454_9: bit-extract s_454_4 s_454_2 s_454_8
        let s_454_9: Bits = (Bits::new(
            ((s_454_4) >> (s_454_2)).value(),
            u16::try_from(s_454_8).unwrap(),
        ));
        // D s_454_10: cast reint s_454_9 -> u8
        let s_454_10: u8 = (s_454_9.value() as u8);
        // D s_454_11: cast zx s_454_10 -> bv
        let s_454_11: Bits = Bits::new(s_454_10 as u128, 7u16);
        // C s_454_12: const #126u : u8
        let s_454_12: u8 = 126;
        // C s_454_13: cast zx s_454_12 -> bv
        let s_454_13: Bits = Bits::new(s_454_12 as u128, 7u16);
        // D s_454_14: cmp-eq s_454_11 s_454_13
        let s_454_14: bool = ((s_454_11) == (s_454_13));
        // N s_454_15: branch s_454_14 b636 b455
        if s_454_14 {
            return block_636(state, tracer, fn_state);
        } else {
            return block_455(state, tracer, fn_state);
        };
    }
    fn block_455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_455_0: const #0u : u8
        let s_455_0: bool = false;
        // D s_455_1: write-var gs#413680 <= s_455_0
        fn_state.gs_413680 = s_455_0;
        // N s_455_2: jump b456
        return block_456(state, tracer, fn_state);
    }
    fn block_456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_456_0: read-var gs#413680:u8
        let s_456_0: bool = fn_state.gs_413680;
        // N s_456_1: branch s_456_0 b635 b457
        if s_456_0 {
            return block_635(state, tracer, fn_state);
        } else {
            return block_457(state, tracer, fn_state);
        };
    }
    fn block_457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_457_0: const #0u : u8
        let s_457_0: bool = false;
        // D s_457_1: write-var gs#413682 <= s_457_0
        fn_state.gs_413682 = s_457_0;
        // N s_457_2: jump b458
        return block_458(state, tracer, fn_state);
    }
    fn block_458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_458_0: read-var gs#413682:u8
        let s_458_0: bool = fn_state.gs_413682;
        // D s_458_1: not s_458_0
        let s_458_1: bool = !s_458_0;
        // N s_458_2: branch s_458_1 b460 b459
        if s_458_1 {
            return block_460(state, tracer, fn_state);
        } else {
            return block_459(state, tracer, fn_state);
        };
    }
    fn block_459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_459_0: const #3910s : i
        let s_459_0: i128 = 3910;
        // C s_459_1: const #14696u : u32
        let s_459_1: u32 = 14696;
        // N s_459_2: write-reg s_459_1 <= s_459_0
        let s_459_2: () = {
            state.write_register::<i128>(s_459_1 as isize, s_459_0);
            tracer.write_register(s_459_1 as isize, s_459_0);
        };
        // C s_459_3: const #24s : i
        let s_459_3: i128 = 24;
        // C s_459_4: const #1s : i
        let s_459_4: i128 = 1;
        // D s_459_5: read-var u#34414:u32
        let s_459_5: u32 = fn_state.u_34414;
        // D s_459_6: cast zx s_459_5 -> bv
        let s_459_6: Bits = Bits::new(s_459_5 as u128, 32u16);
        // D s_459_7: bit-extract s_459_6 s_459_3 s_459_4
        let s_459_7: Bits = (Bits::new(
            ((s_459_6) >> (s_459_3)).value(),
            u16::try_from(s_459_4).unwrap(),
        ));
        // D s_459_8: cast reint s_459_7 -> u8
        let s_459_8: bool = ((s_459_7.value()) != 0);
        // C s_459_9: const #22s : i
        let s_459_9: i128 = 22;
        // C s_459_10: const #1s : i
        let s_459_10: i128 = 1;
        // D s_459_11: read-var u#34414:u32
        let s_459_11: u32 = fn_state.u_34414;
        // D s_459_12: cast zx s_459_11 -> bv
        let s_459_12: Bits = Bits::new(s_459_11 as u128, 32u16);
        // D s_459_13: bit-extract s_459_12 s_459_9 s_459_10
        let s_459_13: Bits = (Bits::new(
            ((s_459_12) >> (s_459_9)).value(),
            u16::try_from(s_459_10).unwrap(),
        ));
        // D s_459_14: cast reint s_459_13 -> u8
        let s_459_14: bool = ((s_459_13.value()) != 0);
        // C s_459_15: const #20s : i
        let s_459_15: i128 = 20;
        // C s_459_16: const #1s : i
        let s_459_16: i128 = 1;
        // D s_459_17: read-var u#34414:u32
        let s_459_17: u32 = fn_state.u_34414;
        // D s_459_18: cast zx s_459_17 -> bv
        let s_459_18: Bits = Bits::new(s_459_17 as u128, 32u16);
        // D s_459_19: bit-extract s_459_18 s_459_15 s_459_16
        let s_459_19: Bits = (Bits::new(
            ((s_459_18) >> (s_459_15)).value(),
            u16::try_from(s_459_16).unwrap(),
        ));
        // D s_459_20: cast reint s_459_19 -> u8
        let s_459_20: bool = ((s_459_19.value()) != 0);
        // C s_459_21: const #16s : i
        let s_459_21: i128 = 16;
        // C s_459_22: const #4s : i
        let s_459_22: i128 = 4;
        // D s_459_23: read-var u#34414:u32
        let s_459_23: u32 = fn_state.u_34414;
        // D s_459_24: cast zx s_459_23 -> bv
        let s_459_24: Bits = Bits::new(s_459_23 as u128, 32u16);
        // D s_459_25: bit-extract s_459_24 s_459_21 s_459_22
        let s_459_25: Bits = (Bits::new(
            ((s_459_24) >> (s_459_21)).value(),
            u16::try_from(s_459_22).unwrap(),
        ));
        // D s_459_26: cast reint s_459_25 -> u8
        let s_459_26: u8 = (s_459_25.value() as u8);
        // C s_459_27: const #12s : i
        let s_459_27: i128 = 12;
        // C s_459_28: const #4s : i
        let s_459_28: i128 = 4;
        // D s_459_29: read-var u#34414:u32
        let s_459_29: u32 = fn_state.u_34414;
        // D s_459_30: cast zx s_459_29 -> bv
        let s_459_30: Bits = Bits::new(s_459_29 as u128, 32u16);
        // D s_459_31: bit-extract s_459_30 s_459_27 s_459_28
        let s_459_31: Bits = (Bits::new(
            ((s_459_30) >> (s_459_27)).value(),
            u16::try_from(s_459_28).unwrap(),
        ));
        // D s_459_32: cast reint s_459_31 -> u8
        let s_459_32: u8 = (s_459_31.value() as u8);
        // C s_459_33: const #7s : i
        let s_459_33: i128 = 7;
        // C s_459_34: const #1s : i
        let s_459_34: i128 = 1;
        // D s_459_35: read-var u#34414:u32
        let s_459_35: u32 = fn_state.u_34414;
        // D s_459_36: cast zx s_459_35 -> bv
        let s_459_36: Bits = Bits::new(s_459_35 as u128, 32u16);
        // D s_459_37: bit-extract s_459_36 s_459_33 s_459_34
        let s_459_37: Bits = (Bits::new(
            ((s_459_36) >> (s_459_33)).value(),
            u16::try_from(s_459_34).unwrap(),
        ));
        // D s_459_38: cast reint s_459_37 -> u8
        let s_459_38: bool = ((s_459_37.value()) != 0);
        // C s_459_39: const #6s : i
        let s_459_39: i128 = 6;
        // C s_459_40: const #1s : i
        let s_459_40: i128 = 1;
        // D s_459_41: read-var u#34414:u32
        let s_459_41: u32 = fn_state.u_34414;
        // D s_459_42: cast zx s_459_41 -> bv
        let s_459_42: Bits = Bits::new(s_459_41 as u128, 32u16);
        // D s_459_43: bit-extract s_459_42 s_459_39 s_459_40
        let s_459_43: Bits = (Bits::new(
            ((s_459_42) >> (s_459_39)).value(),
            u16::try_from(s_459_40).unwrap(),
        ));
        // D s_459_44: cast reint s_459_43 -> u8
        let s_459_44: bool = ((s_459_43.value()) != 0);
        // C s_459_45: const #5s : i
        let s_459_45: i128 = 5;
        // C s_459_46: const #1s : i
        let s_459_46: i128 = 1;
        // D s_459_47: read-var u#34414:u32
        let s_459_47: u32 = fn_state.u_34414;
        // D s_459_48: cast zx s_459_47 -> bv
        let s_459_48: Bits = Bits::new(s_459_47 as u128, 32u16);
        // D s_459_49: bit-extract s_459_48 s_459_45 s_459_46
        let s_459_49: Bits = (Bits::new(
            ((s_459_48) >> (s_459_45)).value(),
            u16::try_from(s_459_46).unwrap(),
        ));
        // D s_459_50: cast reint s_459_49 -> u8
        let s_459_50: bool = ((s_459_49.value()) != 0);
        // C s_459_51: const #0s : i
        let s_459_51: i128 = 0;
        // C s_459_52: const #4s : i
        let s_459_52: i128 = 4;
        // D s_459_53: read-var u#34414:u32
        let s_459_53: u32 = fn_state.u_34414;
        // D s_459_54: cast zx s_459_53 -> bv
        let s_459_54: Bits = Bits::new(s_459_53 as u128, 32u16);
        // D s_459_55: bit-extract s_459_54 s_459_51 s_459_52
        let s_459_55: Bits = (Bits::new(
            ((s_459_54) >> (s_459_51)).value(),
            u16::try_from(s_459_52).unwrap(),
        ));
        // D s_459_56: cast reint s_459_55 -> u8
        let s_459_56: u8 = (s_459_55.value() as u8);
        // D s_459_57: call decode_aarch32_instrs_VCADD_A1enc_A_txt(s_459_8, s_459_14, s_459_20, s_459_26, s_459_32, s_459_38, s_459_44, s_459_50, s_459_56)
        let s_459_57: () = decode_aarch32_instrs_VCADD_A1enc_A_txt(
            state,
            tracer,
            s_459_8,
            s_459_14,
            s_459_20,
            s_459_26,
            s_459_32,
            s_459_38,
            s_459_44,
            s_459_50,
            s_459_56,
        );
        // N s_459_58: return
        return;
    }
    fn block_460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_460_0: read-var merge#var.1:struct
        let s_460_0: u32 = fn_state.merge_var._1;
        // D s_460_1: write-var u#34425 <= s_460_0
        fn_state.u_34425 = s_460_0;
        // C s_460_2: const #24s : i
        let s_460_2: i128 = 24;
        // D s_460_3: read-var u#34425:u32
        let s_460_3: u32 = fn_state.u_34425;
        // D s_460_4: cast zx s_460_3 -> bv
        let s_460_4: Bits = Bits::new(s_460_3 as u128, 32u16);
        // C s_460_5: const #1s : i64
        let s_460_5: i64 = 1;
        // C s_460_6: cast zx s_460_5 -> i
        let s_460_6: i128 = (i128::try_from(s_460_5).unwrap());
        // C s_460_7: const #7s : i
        let s_460_7: i128 = 7;
        // C s_460_8: add s_460_7 s_460_6
        let s_460_8: i128 = (s_460_7 + s_460_6);
        // D s_460_9: bit-extract s_460_4 s_460_2 s_460_8
        let s_460_9: Bits = (Bits::new(
            ((s_460_4) >> (s_460_2)).value(),
            u16::try_from(s_460_8).unwrap(),
        ));
        // D s_460_10: cast reint s_460_9 -> u8
        let s_460_10: u8 = (s_460_9.value() as u8);
        // D s_460_11: cast zx s_460_10 -> bv
        let s_460_11: Bits = Bits::new(s_460_10 as u128, 8u16);
        // C s_460_12: const #252u : u8
        let s_460_12: u8 = 252;
        // C s_460_13: cast zx s_460_12 -> bv
        let s_460_13: Bits = Bits::new(s_460_12 as u128, 8u16);
        // D s_460_14: cmp-eq s_460_11 s_460_13
        let s_460_14: bool = ((s_460_11) == (s_460_13));
        // N s_460_15: branch s_460_14 b628 b461
        if s_460_14 {
            return block_628(state, tracer, fn_state);
        } else {
            return block_461(state, tracer, fn_state);
        };
    }
    fn block_461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_461_0: const #0u : u8
        let s_461_0: bool = false;
        // D s_461_1: write-var gs#413714 <= s_461_0
        fn_state.gs_413714 = s_461_0;
        // N s_461_2: jump b462
        return block_462(state, tracer, fn_state);
    }
    fn block_462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_462_0: read-var gs#413714:u8
        let s_462_0: bool = fn_state.gs_413714;
        // N s_462_1: branch s_462_0 b627 b463
        if s_462_0 {
            return block_627(state, tracer, fn_state);
        } else {
            return block_463(state, tracer, fn_state);
        };
    }
    fn block_463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_463_0: const #0u : u8
        let s_463_0: bool = false;
        // D s_463_1: write-var gs#413716 <= s_463_0
        fn_state.gs_413716 = s_463_0;
        // N s_463_2: jump b464
        return block_464(state, tracer, fn_state);
    }
    fn block_464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_464_0: read-var gs#413716:u8
        let s_464_0: bool = fn_state.gs_413716;
        // D s_464_1: not s_464_0
        let s_464_1: bool = !s_464_0;
        // N s_464_2: branch s_464_1 b466 b465
        if s_464_1 {
            return block_466(state, tracer, fn_state);
        } else {
            return block_465(state, tracer, fn_state);
        };
    }
    fn block_465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_465_0: const #3912s : i
        let s_465_0: i128 = 3912;
        // C s_465_1: const #14696u : u32
        let s_465_1: u32 = 14696;
        // N s_465_2: write-reg s_465_1 <= s_465_0
        let s_465_2: () = {
            state.write_register::<i128>(s_465_1 as isize, s_465_0);
            tracer.write_register(s_465_1 as isize, s_465_0);
        };
        // C s_465_3: const #23s : i
        let s_465_3: i128 = 23;
        // C s_465_4: const #1s : i
        let s_465_4: i128 = 1;
        // D s_465_5: read-var u#34425:u32
        let s_465_5: u32 = fn_state.u_34425;
        // D s_465_6: cast zx s_465_5 -> bv
        let s_465_6: Bits = Bits::new(s_465_5 as u128, 32u16);
        // D s_465_7: bit-extract s_465_6 s_465_3 s_465_4
        let s_465_7: Bits = (Bits::new(
            ((s_465_6) >> (s_465_3)).value(),
            u16::try_from(s_465_4).unwrap(),
        ));
        // D s_465_8: cast reint s_465_7 -> u8
        let s_465_8: bool = ((s_465_7.value()) != 0);
        // C s_465_9: const #22s : i
        let s_465_9: i128 = 22;
        // C s_465_10: const #1s : i
        let s_465_10: i128 = 1;
        // D s_465_11: read-var u#34425:u32
        let s_465_11: u32 = fn_state.u_34425;
        // D s_465_12: cast zx s_465_11 -> bv
        let s_465_12: Bits = Bits::new(s_465_11 as u128, 32u16);
        // D s_465_13: bit-extract s_465_12 s_465_9 s_465_10
        let s_465_13: Bits = (Bits::new(
            ((s_465_12) >> (s_465_9)).value(),
            u16::try_from(s_465_10).unwrap(),
        ));
        // D s_465_14: cast reint s_465_13 -> u8
        let s_465_14: bool = ((s_465_13.value()) != 0);
        // C s_465_15: const #16s : i
        let s_465_15: i128 = 16;
        // C s_465_16: const #4s : i
        let s_465_16: i128 = 4;
        // D s_465_17: read-var u#34425:u32
        let s_465_17: u32 = fn_state.u_34425;
        // D s_465_18: cast zx s_465_17 -> bv
        let s_465_18: Bits = Bits::new(s_465_17 as u128, 32u16);
        // D s_465_19: bit-extract s_465_18 s_465_15 s_465_16
        let s_465_19: Bits = (Bits::new(
            ((s_465_18) >> (s_465_15)).value(),
            u16::try_from(s_465_16).unwrap(),
        ));
        // D s_465_20: cast reint s_465_19 -> u8
        let s_465_20: u8 = (s_465_19.value() as u8);
        // C s_465_21: const #12s : i
        let s_465_21: i128 = 12;
        // C s_465_22: const #4s : i
        let s_465_22: i128 = 4;
        // D s_465_23: read-var u#34425:u32
        let s_465_23: u32 = fn_state.u_34425;
        // D s_465_24: cast zx s_465_23 -> bv
        let s_465_24: Bits = Bits::new(s_465_23 as u128, 32u16);
        // D s_465_25: bit-extract s_465_24 s_465_21 s_465_22
        let s_465_25: Bits = (Bits::new(
            ((s_465_24) >> (s_465_21)).value(),
            u16::try_from(s_465_22).unwrap(),
        ));
        // D s_465_26: cast reint s_465_25 -> u8
        let s_465_26: u8 = (s_465_25.value() as u8);
        // C s_465_27: const #7s : i
        let s_465_27: i128 = 7;
        // C s_465_28: const #1s : i
        let s_465_28: i128 = 1;
        // D s_465_29: read-var u#34425:u32
        let s_465_29: u32 = fn_state.u_34425;
        // D s_465_30: cast zx s_465_29 -> bv
        let s_465_30: Bits = Bits::new(s_465_29 as u128, 32u16);
        // D s_465_31: bit-extract s_465_30 s_465_27 s_465_28
        let s_465_31: Bits = (Bits::new(
            ((s_465_30) >> (s_465_27)).value(),
            u16::try_from(s_465_28).unwrap(),
        ));
        // D s_465_32: cast reint s_465_31 -> u8
        let s_465_32: bool = ((s_465_31.value()) != 0);
        // C s_465_33: const #6s : i
        let s_465_33: i128 = 6;
        // C s_465_34: const #1s : i
        let s_465_34: i128 = 1;
        // D s_465_35: read-var u#34425:u32
        let s_465_35: u32 = fn_state.u_34425;
        // D s_465_36: cast zx s_465_35 -> bv
        let s_465_36: Bits = Bits::new(s_465_35 as u128, 32u16);
        // D s_465_37: bit-extract s_465_36 s_465_33 s_465_34
        let s_465_37: Bits = (Bits::new(
            ((s_465_36) >> (s_465_33)).value(),
            u16::try_from(s_465_34).unwrap(),
        ));
        // D s_465_38: cast reint s_465_37 -> u8
        let s_465_38: bool = ((s_465_37.value()) != 0);
        // C s_465_39: const #5s : i
        let s_465_39: i128 = 5;
        // C s_465_40: const #1s : i
        let s_465_40: i128 = 1;
        // D s_465_41: read-var u#34425:u32
        let s_465_41: u32 = fn_state.u_34425;
        // D s_465_42: cast zx s_465_41 -> bv
        let s_465_42: Bits = Bits::new(s_465_41 as u128, 32u16);
        // D s_465_43: bit-extract s_465_42 s_465_39 s_465_40
        let s_465_43: Bits = (Bits::new(
            ((s_465_42) >> (s_465_39)).value(),
            u16::try_from(s_465_40).unwrap(),
        ));
        // D s_465_44: cast reint s_465_43 -> u8
        let s_465_44: bool = ((s_465_43.value()) != 0);
        // C s_465_45: const #0s : i
        let s_465_45: i128 = 0;
        // C s_465_46: const #4s : i
        let s_465_46: i128 = 4;
        // D s_465_47: read-var u#34425:u32
        let s_465_47: u32 = fn_state.u_34425;
        // D s_465_48: cast zx s_465_47 -> bv
        let s_465_48: Bits = Bits::new(s_465_47 as u128, 32u16);
        // D s_465_49: bit-extract s_465_48 s_465_45 s_465_46
        let s_465_49: Bits = (Bits::new(
            ((s_465_48) >> (s_465_45)).value(),
            u16::try_from(s_465_46).unwrap(),
        ));
        // D s_465_50: cast reint s_465_49 -> u8
        let s_465_50: u8 = (s_465_49.value() as u8);
        // D s_465_51: call decode_aarch32_instrs_VFMAL_A1enc_A_txt(s_465_8, s_465_14, s_465_20, s_465_26, s_465_32, s_465_38, s_465_44, s_465_50)
        let s_465_51: () = decode_aarch32_instrs_VFMAL_A1enc_A_txt(
            state,
            tracer,
            s_465_8,
            s_465_14,
            s_465_20,
            s_465_26,
            s_465_32,
            s_465_38,
            s_465_44,
            s_465_50,
        );
        // N s_465_52: return
        return;
    }
    fn block_466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_466_0: read-var merge#var.1:struct
        let s_466_0: u32 = fn_state.merge_var._1;
        // D s_466_1: write-var u#34435 <= s_466_0
        fn_state.u_34435 = s_466_0;
        // C s_466_2: const #23s : i
        let s_466_2: i128 = 23;
        // D s_466_3: read-var u#34435:u32
        let s_466_3: u32 = fn_state.u_34435;
        // D s_466_4: cast zx s_466_3 -> bv
        let s_466_4: Bits = Bits::new(s_466_3 as u128, 32u16);
        // C s_466_5: const #1s : i64
        let s_466_5: i64 = 1;
        // C s_466_6: cast zx s_466_5 -> i
        let s_466_6: i128 = (i128::try_from(s_466_5).unwrap());
        // C s_466_7: const #8s : i
        let s_466_7: i128 = 8;
        // C s_466_8: add s_466_7 s_466_6
        let s_466_8: i128 = (s_466_7 + s_466_6);
        // D s_466_9: bit-extract s_466_4 s_466_2 s_466_8
        let s_466_9: Bits = (Bits::new(
            ((s_466_4) >> (s_466_2)).value(),
            u16::try_from(s_466_8).unwrap(),
        ));
        // D s_466_10: cast reint s_466_9 -> u9
        let s_466_10: u16 = (s_466_9.value() as u16);
        // D s_466_11: cast zx s_466_10 -> bv
        let s_466_11: Bits = Bits::new(s_466_10 as u128, 9u16);
        // C s_466_12: const #508u : u9
        let s_466_12: u16 = 508;
        // C s_466_13: cast zx s_466_12 -> bv
        let s_466_13: Bits = Bits::new(s_466_12 as u128, 9u16);
        // D s_466_14: cmp-eq s_466_11 s_466_13
        let s_466_14: bool = ((s_466_11) == (s_466_13));
        // N s_466_15: branch s_466_14 b620 b467
        if s_466_14 {
            return block_620(state, tracer, fn_state);
        } else {
            return block_467(state, tracer, fn_state);
        };
    }
    fn block_467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_467_0: const #0u : u8
        let s_467_0: bool = false;
        // D s_467_1: write-var gs#413746 <= s_467_0
        fn_state.gs_413746 = s_467_0;
        // N s_467_2: jump b468
        return block_468(state, tracer, fn_state);
    }
    fn block_468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_468_0: read-var gs#413746:u8
        let s_468_0: bool = fn_state.gs_413746;
        // N s_468_1: branch s_468_0 b619 b469
        if s_468_0 {
            return block_619(state, tracer, fn_state);
        } else {
            return block_469(state, tracer, fn_state);
        };
    }
    fn block_469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_469_0: const #0u : u8
        let s_469_0: bool = false;
        // D s_469_1: write-var gs#413748 <= s_469_0
        fn_state.gs_413748 = s_469_0;
        // N s_469_2: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_470_0: read-var gs#413748:u8
        let s_470_0: bool = fn_state.gs_413748;
        // D s_470_1: not s_470_0
        let s_470_1: bool = !s_470_0;
        // N s_470_2: branch s_470_1 b472 b471
        if s_470_1 {
            return block_472(state, tracer, fn_state);
        } else {
            return block_471(state, tracer, fn_state);
        };
    }
    fn block_471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_471_0: const #3914s : i
        let s_471_0: i128 = 3914;
        // C s_471_1: const #14696u : u32
        let s_471_1: u32 = 14696;
        // N s_471_2: write-reg s_471_1 <= s_471_0
        let s_471_2: () = {
            state.write_register::<i128>(s_471_1 as isize, s_471_0);
            tracer.write_register(s_471_1 as isize, s_471_0);
        };
        // C s_471_3: const #22s : i
        let s_471_3: i128 = 22;
        // C s_471_4: const #1s : i
        let s_471_4: i128 = 1;
        // D s_471_5: read-var u#34435:u32
        let s_471_5: u32 = fn_state.u_34435;
        // D s_471_6: cast zx s_471_5 -> bv
        let s_471_6: Bits = Bits::new(s_471_5 as u128, 32u16);
        // D s_471_7: bit-extract s_471_6 s_471_3 s_471_4
        let s_471_7: Bits = (Bits::new(
            ((s_471_6) >> (s_471_3)).value(),
            u16::try_from(s_471_4).unwrap(),
        ));
        // D s_471_8: cast reint s_471_7 -> u8
        let s_471_8: bool = ((s_471_7.value()) != 0);
        // C s_471_9: const #20s : i
        let s_471_9: i128 = 20;
        // C s_471_10: const #1s : i
        let s_471_10: i128 = 1;
        // D s_471_11: read-var u#34435:u32
        let s_471_11: u32 = fn_state.u_34435;
        // D s_471_12: cast zx s_471_11 -> bv
        let s_471_12: Bits = Bits::new(s_471_11 as u128, 32u16);
        // D s_471_13: bit-extract s_471_12 s_471_9 s_471_10
        let s_471_13: Bits = (Bits::new(
            ((s_471_12) >> (s_471_9)).value(),
            u16::try_from(s_471_10).unwrap(),
        ));
        // D s_471_14: cast reint s_471_13 -> u8
        let s_471_14: bool = ((s_471_13.value()) != 0);
        // C s_471_15: const #16s : i
        let s_471_15: i128 = 16;
        // C s_471_16: const #4s : i
        let s_471_16: i128 = 4;
        // D s_471_17: read-var u#34435:u32
        let s_471_17: u32 = fn_state.u_34435;
        // D s_471_18: cast zx s_471_17 -> bv
        let s_471_18: Bits = Bits::new(s_471_17 as u128, 32u16);
        // D s_471_19: bit-extract s_471_18 s_471_15 s_471_16
        let s_471_19: Bits = (Bits::new(
            ((s_471_18) >> (s_471_15)).value(),
            u16::try_from(s_471_16).unwrap(),
        ));
        // D s_471_20: cast reint s_471_19 -> u8
        let s_471_20: u8 = (s_471_19.value() as u8);
        // C s_471_21: const #12s : i
        let s_471_21: i128 = 12;
        // C s_471_22: const #4s : i
        let s_471_22: i128 = 4;
        // D s_471_23: read-var u#34435:u32
        let s_471_23: u32 = fn_state.u_34435;
        // D s_471_24: cast zx s_471_23 -> bv
        let s_471_24: Bits = Bits::new(s_471_23 as u128, 32u16);
        // D s_471_25: bit-extract s_471_24 s_471_21 s_471_22
        let s_471_25: Bits = (Bits::new(
            ((s_471_24) >> (s_471_21)).value(),
            u16::try_from(s_471_22).unwrap(),
        ));
        // D s_471_26: cast reint s_471_25 -> u8
        let s_471_26: u8 = (s_471_25.value() as u8);
        // C s_471_27: const #7s : i
        let s_471_27: i128 = 7;
        // C s_471_28: const #1s : i
        let s_471_28: i128 = 1;
        // D s_471_29: read-var u#34435:u32
        let s_471_29: u32 = fn_state.u_34435;
        // D s_471_30: cast zx s_471_29 -> bv
        let s_471_30: Bits = Bits::new(s_471_29 as u128, 32u16);
        // D s_471_31: bit-extract s_471_30 s_471_27 s_471_28
        let s_471_31: Bits = (Bits::new(
            ((s_471_30) >> (s_471_27)).value(),
            u16::try_from(s_471_28).unwrap(),
        ));
        // D s_471_32: cast reint s_471_31 -> u8
        let s_471_32: bool = ((s_471_31.value()) != 0);
        // C s_471_33: const #6s : i
        let s_471_33: i128 = 6;
        // C s_471_34: const #1s : i
        let s_471_34: i128 = 1;
        // D s_471_35: read-var u#34435:u32
        let s_471_35: u32 = fn_state.u_34435;
        // D s_471_36: cast zx s_471_35 -> bv
        let s_471_36: Bits = Bits::new(s_471_35 as u128, 32u16);
        // D s_471_37: bit-extract s_471_36 s_471_33 s_471_34
        let s_471_37: Bits = (Bits::new(
            ((s_471_36) >> (s_471_33)).value(),
            u16::try_from(s_471_34).unwrap(),
        ));
        // D s_471_38: cast reint s_471_37 -> u8
        let s_471_38: bool = ((s_471_37.value()) != 0);
        // C s_471_39: const #5s : i
        let s_471_39: i128 = 5;
        // C s_471_40: const #1s : i
        let s_471_40: i128 = 1;
        // D s_471_41: read-var u#34435:u32
        let s_471_41: u32 = fn_state.u_34435;
        // D s_471_42: cast zx s_471_41 -> bv
        let s_471_42: Bits = Bits::new(s_471_41 as u128, 32u16);
        // D s_471_43: bit-extract s_471_42 s_471_39 s_471_40
        let s_471_43: Bits = (Bits::new(
            ((s_471_42) >> (s_471_39)).value(),
            u16::try_from(s_471_40).unwrap(),
        ));
        // D s_471_44: cast reint s_471_43 -> u8
        let s_471_44: bool = ((s_471_43.value()) != 0);
        // C s_471_45: const #0s : i
        let s_471_45: i128 = 0;
        // C s_471_46: const #4s : i
        let s_471_46: i128 = 4;
        // D s_471_47: read-var u#34435:u32
        let s_471_47: u32 = fn_state.u_34435;
        // D s_471_48: cast zx s_471_47 -> bv
        let s_471_48: Bits = Bits::new(s_471_47 as u128, 32u16);
        // D s_471_49: bit-extract s_471_48 s_471_45 s_471_46
        let s_471_49: Bits = (Bits::new(
            ((s_471_48) >> (s_471_45)).value(),
            u16::try_from(s_471_46).unwrap(),
        ));
        // D s_471_50: cast reint s_471_49 -> u8
        let s_471_50: u8 = (s_471_49.value() as u8);
        // D s_471_51: call decode_aarch32_instrs_VFMAL_i_A1enc_A_txt(s_471_8, s_471_14, s_471_20, s_471_26, s_471_32, s_471_38, s_471_44, s_471_50)
        let s_471_51: () = decode_aarch32_instrs_VFMAL_i_A1enc_A_txt(
            state,
            tracer,
            s_471_8,
            s_471_14,
            s_471_20,
            s_471_26,
            s_471_32,
            s_471_38,
            s_471_44,
            s_471_50,
        );
        // N s_471_52: return
        return;
    }
    fn block_472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_472_0: read-var merge#var.1:struct
        let s_472_0: u32 = fn_state.merge_var._1;
        // D s_472_1: write-var u#34445 <= s_472_0
        fn_state.u_34445 = s_472_0;
        // C s_472_2: const #23s : i
        let s_472_2: i128 = 23;
        // D s_472_3: read-var u#34445:u32
        let s_472_3: u32 = fn_state.u_34445;
        // D s_472_4: cast zx s_472_3 -> bv
        let s_472_4: Bits = Bits::new(s_472_3 as u128, 32u16);
        // C s_472_5: const #1s : i64
        let s_472_5: i64 = 1;
        // C s_472_6: cast zx s_472_5 -> i
        let s_472_6: i128 = (i128::try_from(s_472_5).unwrap());
        // C s_472_7: const #8s : i
        let s_472_7: i128 = 8;
        // C s_472_8: add s_472_7 s_472_6
        let s_472_8: i128 = (s_472_7 + s_472_6);
        // D s_472_9: bit-extract s_472_4 s_472_2 s_472_8
        let s_472_9: Bits = (Bits::new(
            ((s_472_4) >> (s_472_2)).value(),
            u16::try_from(s_472_8).unwrap(),
        ));
        // D s_472_10: cast reint s_472_9 -> u9
        let s_472_10: u16 = (s_472_9.value() as u16);
        // D s_472_11: cast zx s_472_10 -> bv
        let s_472_11: Bits = Bits::new(s_472_10 as u128, 9u16);
        // C s_472_12: const #504u : u9
        let s_472_12: u16 = 504;
        // C s_472_13: cast zx s_472_12 -> bv
        let s_472_13: Bits = Bits::new(s_472_12 as u128, 9u16);
        // D s_472_14: cmp-eq s_472_11 s_472_13
        let s_472_14: bool = ((s_472_11) == (s_472_13));
        // N s_472_15: branch s_472_14 b612 b473
        if s_472_14 {
            return block_612(state, tracer, fn_state);
        } else {
            return block_473(state, tracer, fn_state);
        };
    }
    fn block_473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_473_0: const #0u : u8
        let s_473_0: bool = false;
        // D s_473_1: write-var gs#413778 <= s_473_0
        fn_state.gs_413778 = s_473_0;
        // N s_473_2: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_474_0: read-var gs#413778:u8
        let s_474_0: bool = fn_state.gs_413778;
        // N s_474_1: branch s_474_0 b611 b475
        if s_474_0 {
            return block_611(state, tracer, fn_state);
        } else {
            return block_475(state, tracer, fn_state);
        };
    }
    fn block_475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_475_0: const #0u : u8
        let s_475_0: bool = false;
        // D s_475_1: write-var gs#413780 <= s_475_0
        fn_state.gs_413780 = s_475_0;
        // N s_475_2: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_476_0: read-var gs#413780:u8
        let s_476_0: bool = fn_state.gs_413780;
        // D s_476_1: not s_476_0
        let s_476_1: bool = !s_476_0;
        // N s_476_2: branch s_476_1 b478 b477
        if s_476_1 {
            return block_478(state, tracer, fn_state);
        } else {
            return block_477(state, tracer, fn_state);
        };
    }
    fn block_477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_477_0: const #3916s : i
        let s_477_0: i128 = 3916;
        // C s_477_1: const #14696u : u32
        let s_477_1: u32 = 14696;
        // N s_477_2: write-reg s_477_1 <= s_477_0
        let s_477_2: () = {
            state.write_register::<i128>(s_477_1 as isize, s_477_0);
            tracer.write_register(s_477_1 as isize, s_477_0);
        };
        // C s_477_3: const #22s : i
        let s_477_3: i128 = 22;
        // C s_477_4: const #1s : i
        let s_477_4: i128 = 1;
        // D s_477_5: read-var u#34445:u32
        let s_477_5: u32 = fn_state.u_34445;
        // D s_477_6: cast zx s_477_5 -> bv
        let s_477_6: Bits = Bits::new(s_477_5 as u128, 32u16);
        // D s_477_7: bit-extract s_477_6 s_477_3 s_477_4
        let s_477_7: Bits = (Bits::new(
            ((s_477_6) >> (s_477_3)).value(),
            u16::try_from(s_477_4).unwrap(),
        ));
        // D s_477_8: cast reint s_477_7 -> u8
        let s_477_8: bool = ((s_477_7.value()) != 0);
        // C s_477_9: const #16s : i
        let s_477_9: i128 = 16;
        // C s_477_10: const #4s : i
        let s_477_10: i128 = 4;
        // D s_477_11: read-var u#34445:u32
        let s_477_11: u32 = fn_state.u_34445;
        // D s_477_12: cast zx s_477_11 -> bv
        let s_477_12: Bits = Bits::new(s_477_11 as u128, 32u16);
        // D s_477_13: bit-extract s_477_12 s_477_9 s_477_10
        let s_477_13: Bits = (Bits::new(
            ((s_477_12) >> (s_477_9)).value(),
            u16::try_from(s_477_10).unwrap(),
        ));
        // D s_477_14: cast reint s_477_13 -> u8
        let s_477_14: u8 = (s_477_13.value() as u8);
        // C s_477_15: const #12s : i
        let s_477_15: i128 = 12;
        // C s_477_16: const #4s : i
        let s_477_16: i128 = 4;
        // D s_477_17: read-var u#34445:u32
        let s_477_17: u32 = fn_state.u_34445;
        // D s_477_18: cast zx s_477_17 -> bv
        let s_477_18: Bits = Bits::new(s_477_17 as u128, 32u16);
        // D s_477_19: bit-extract s_477_18 s_477_15 s_477_16
        let s_477_19: Bits = (Bits::new(
            ((s_477_18) >> (s_477_15)).value(),
            u16::try_from(s_477_16).unwrap(),
        ));
        // D s_477_20: cast reint s_477_19 -> u8
        let s_477_20: u8 = (s_477_19.value() as u8);
        // C s_477_21: const #7s : i
        let s_477_21: i128 = 7;
        // C s_477_22: const #1s : i
        let s_477_22: i128 = 1;
        // D s_477_23: read-var u#34445:u32
        let s_477_23: u32 = fn_state.u_34445;
        // D s_477_24: cast zx s_477_23 -> bv
        let s_477_24: Bits = Bits::new(s_477_23 as u128, 32u16);
        // D s_477_25: bit-extract s_477_24 s_477_21 s_477_22
        let s_477_25: Bits = (Bits::new(
            ((s_477_24) >> (s_477_21)).value(),
            u16::try_from(s_477_22).unwrap(),
        ));
        // D s_477_26: cast reint s_477_25 -> u8
        let s_477_26: bool = ((s_477_25.value()) != 0);
        // C s_477_27: const #6s : i
        let s_477_27: i128 = 6;
        // C s_477_28: const #1s : i
        let s_477_28: i128 = 1;
        // D s_477_29: read-var u#34445:u32
        let s_477_29: u32 = fn_state.u_34445;
        // D s_477_30: cast zx s_477_29 -> bv
        let s_477_30: Bits = Bits::new(s_477_29 as u128, 32u16);
        // D s_477_31: bit-extract s_477_30 s_477_27 s_477_28
        let s_477_31: Bits = (Bits::new(
            ((s_477_30) >> (s_477_27)).value(),
            u16::try_from(s_477_28).unwrap(),
        ));
        // D s_477_32: cast reint s_477_31 -> u8
        let s_477_32: bool = ((s_477_31.value()) != 0);
        // C s_477_33: const #5s : i
        let s_477_33: i128 = 5;
        // C s_477_34: const #1s : i
        let s_477_34: i128 = 1;
        // D s_477_35: read-var u#34445:u32
        let s_477_35: u32 = fn_state.u_34445;
        // D s_477_36: cast zx s_477_35 -> bv
        let s_477_36: Bits = Bits::new(s_477_35 as u128, 32u16);
        // D s_477_37: bit-extract s_477_36 s_477_33 s_477_34
        let s_477_37: Bits = (Bits::new(
            ((s_477_36) >> (s_477_33)).value(),
            u16::try_from(s_477_34).unwrap(),
        ));
        // D s_477_38: cast reint s_477_37 -> u8
        let s_477_38: bool = ((s_477_37.value()) != 0);
        // C s_477_39: const #0s : i
        let s_477_39: i128 = 0;
        // C s_477_40: const #4s : i
        let s_477_40: i128 = 4;
        // D s_477_41: read-var u#34445:u32
        let s_477_41: u32 = fn_state.u_34445;
        // D s_477_42: cast zx s_477_41 -> bv
        let s_477_42: Bits = Bits::new(s_477_41 as u128, 32u16);
        // D s_477_43: bit-extract s_477_42 s_477_39 s_477_40
        let s_477_43: Bits = (Bits::new(
            ((s_477_42) >> (s_477_39)).value(),
            u16::try_from(s_477_40).unwrap(),
        ));
        // D s_477_44: cast reint s_477_43 -> u8
        let s_477_44: u8 = (s_477_43.value() as u8);
        // D s_477_45: call decode_aarch32_instrs_VDOT_bf16_A1enc_A_txt(s_477_8, s_477_14, s_477_20, s_477_26, s_477_32, s_477_38, s_477_44)
        let s_477_45: () = decode_aarch32_instrs_VDOT_bf16_A1enc_A_txt(
            state,
            tracer,
            s_477_8,
            s_477_14,
            s_477_20,
            s_477_26,
            s_477_32,
            s_477_38,
            s_477_44,
        );
        // N s_477_46: return
        return;
    }
    fn block_478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_478_0: read-var merge#var.1:struct
        let s_478_0: u32 = fn_state.merge_var._1;
        // D s_478_1: write-var u#34454 <= s_478_0
        fn_state.u_34454 = s_478_0;
        // C s_478_2: const #23s : i
        let s_478_2: i128 = 23;
        // D s_478_3: read-var u#34454:u32
        let s_478_3: u32 = fn_state.u_34454;
        // D s_478_4: cast zx s_478_3 -> bv
        let s_478_4: Bits = Bits::new(s_478_3 as u128, 32u16);
        // C s_478_5: const #1s : i64
        let s_478_5: i64 = 1;
        // C s_478_6: cast zx s_478_5 -> i
        let s_478_6: i128 = (i128::try_from(s_478_5).unwrap());
        // C s_478_7: const #8s : i
        let s_478_7: i128 = 8;
        // C s_478_8: add s_478_7 s_478_6
        let s_478_8: i128 = (s_478_7 + s_478_6);
        // D s_478_9: bit-extract s_478_4 s_478_2 s_478_8
        let s_478_9: Bits = (Bits::new(
            ((s_478_4) >> (s_478_2)).value(),
            u16::try_from(s_478_8).unwrap(),
        ));
        // D s_478_10: cast reint s_478_9 -> u9
        let s_478_10: u16 = (s_478_9.value() as u16);
        // D s_478_11: cast zx s_478_10 -> bv
        let s_478_11: Bits = Bits::new(s_478_10 as u128, 9u16);
        // C s_478_12: const #508u : u9
        let s_478_12: u16 = 508;
        // C s_478_13: cast zx s_478_12 -> bv
        let s_478_13: Bits = Bits::new(s_478_12 as u128, 9u16);
        // D s_478_14: cmp-eq s_478_11 s_478_13
        let s_478_14: bool = ((s_478_11) == (s_478_13));
        // N s_478_15: branch s_478_14 b604 b479
        if s_478_14 {
            return block_604(state, tracer, fn_state);
        } else {
            return block_479(state, tracer, fn_state);
        };
    }
    fn block_479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_479_0: const #0u : u8
        let s_479_0: bool = false;
        // D s_479_1: write-var gs#413808 <= s_479_0
        fn_state.gs_413808 = s_479_0;
        // N s_479_2: jump b480
        return block_480(state, tracer, fn_state);
    }
    fn block_480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_480_0: read-var gs#413808:u8
        let s_480_0: bool = fn_state.gs_413808;
        // N s_480_1: branch s_480_0 b603 b481
        if s_480_0 {
            return block_603(state, tracer, fn_state);
        } else {
            return block_481(state, tracer, fn_state);
        };
    }
    fn block_481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_481_0: const #0u : u8
        let s_481_0: bool = false;
        // D s_481_1: write-var gs#413810 <= s_481_0
        fn_state.gs_413810 = s_481_0;
        // N s_481_2: jump b482
        return block_482(state, tracer, fn_state);
    }
    fn block_482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_482_0: read-var gs#413810:u8
        let s_482_0: bool = fn_state.gs_413810;
        // D s_482_1: not s_482_0
        let s_482_1: bool = !s_482_0;
        // N s_482_2: branch s_482_1 b484 b483
        if s_482_1 {
            return block_484(state, tracer, fn_state);
        } else {
            return block_483(state, tracer, fn_state);
        };
    }
    fn block_483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_483_0: const #3918s : i
        let s_483_0: i128 = 3918;
        // C s_483_1: const #14696u : u32
        let s_483_1: u32 = 14696;
        // N s_483_2: write-reg s_483_1 <= s_483_0
        let s_483_2: () = {
            state.write_register::<i128>(s_483_1 as isize, s_483_0);
            tracer.write_register(s_483_1 as isize, s_483_0);
        };
        // C s_483_3: const #22s : i
        let s_483_3: i128 = 22;
        // C s_483_4: const #1s : i
        let s_483_4: i128 = 1;
        // D s_483_5: read-var u#34454:u32
        let s_483_5: u32 = fn_state.u_34454;
        // D s_483_6: cast zx s_483_5 -> bv
        let s_483_6: Bits = Bits::new(s_483_5 as u128, 32u16);
        // D s_483_7: bit-extract s_483_6 s_483_3 s_483_4
        let s_483_7: Bits = (Bits::new(
            ((s_483_6) >> (s_483_3)).value(),
            u16::try_from(s_483_4).unwrap(),
        ));
        // D s_483_8: cast reint s_483_7 -> u8
        let s_483_8: bool = ((s_483_7.value()) != 0);
        // C s_483_9: const #16s : i
        let s_483_9: i128 = 16;
        // C s_483_10: const #4s : i
        let s_483_10: i128 = 4;
        // D s_483_11: read-var u#34454:u32
        let s_483_11: u32 = fn_state.u_34454;
        // D s_483_12: cast zx s_483_11 -> bv
        let s_483_12: Bits = Bits::new(s_483_11 as u128, 32u16);
        // D s_483_13: bit-extract s_483_12 s_483_9 s_483_10
        let s_483_13: Bits = (Bits::new(
            ((s_483_12) >> (s_483_9)).value(),
            u16::try_from(s_483_10).unwrap(),
        ));
        // D s_483_14: cast reint s_483_13 -> u8
        let s_483_14: u8 = (s_483_13.value() as u8);
        // C s_483_15: const #12s : i
        let s_483_15: i128 = 12;
        // C s_483_16: const #4s : i
        let s_483_16: i128 = 4;
        // D s_483_17: read-var u#34454:u32
        let s_483_17: u32 = fn_state.u_34454;
        // D s_483_18: cast zx s_483_17 -> bv
        let s_483_18: Bits = Bits::new(s_483_17 as u128, 32u16);
        // D s_483_19: bit-extract s_483_18 s_483_15 s_483_16
        let s_483_19: Bits = (Bits::new(
            ((s_483_18) >> (s_483_15)).value(),
            u16::try_from(s_483_16).unwrap(),
        ));
        // D s_483_20: cast reint s_483_19 -> u8
        let s_483_20: u8 = (s_483_19.value() as u8);
        // C s_483_21: const #7s : i
        let s_483_21: i128 = 7;
        // C s_483_22: const #1s : i
        let s_483_22: i128 = 1;
        // D s_483_23: read-var u#34454:u32
        let s_483_23: u32 = fn_state.u_34454;
        // D s_483_24: cast zx s_483_23 -> bv
        let s_483_24: Bits = Bits::new(s_483_23 as u128, 32u16);
        // D s_483_25: bit-extract s_483_24 s_483_21 s_483_22
        let s_483_25: Bits = (Bits::new(
            ((s_483_24) >> (s_483_21)).value(),
            u16::try_from(s_483_22).unwrap(),
        ));
        // D s_483_26: cast reint s_483_25 -> u8
        let s_483_26: bool = ((s_483_25.value()) != 0);
        // C s_483_27: const #6s : i
        let s_483_27: i128 = 6;
        // C s_483_28: const #1s : i
        let s_483_28: i128 = 1;
        // D s_483_29: read-var u#34454:u32
        let s_483_29: u32 = fn_state.u_34454;
        // D s_483_30: cast zx s_483_29 -> bv
        let s_483_30: Bits = Bits::new(s_483_29 as u128, 32u16);
        // D s_483_31: bit-extract s_483_30 s_483_27 s_483_28
        let s_483_31: Bits = (Bits::new(
            ((s_483_30) >> (s_483_27)).value(),
            u16::try_from(s_483_28).unwrap(),
        ));
        // D s_483_32: cast reint s_483_31 -> u8
        let s_483_32: bool = ((s_483_31.value()) != 0);
        // C s_483_33: const #5s : i
        let s_483_33: i128 = 5;
        // C s_483_34: const #1s : i
        let s_483_34: i128 = 1;
        // D s_483_35: read-var u#34454:u32
        let s_483_35: u32 = fn_state.u_34454;
        // D s_483_36: cast zx s_483_35 -> bv
        let s_483_36: Bits = Bits::new(s_483_35 as u128, 32u16);
        // D s_483_37: bit-extract s_483_36 s_483_33 s_483_34
        let s_483_37: Bits = (Bits::new(
            ((s_483_36) >> (s_483_33)).value(),
            u16::try_from(s_483_34).unwrap(),
        ));
        // D s_483_38: cast reint s_483_37 -> u8
        let s_483_38: bool = ((s_483_37.value()) != 0);
        // C s_483_39: const #0s : i
        let s_483_39: i128 = 0;
        // C s_483_40: const #4s : i
        let s_483_40: i128 = 4;
        // D s_483_41: read-var u#34454:u32
        let s_483_41: u32 = fn_state.u_34454;
        // D s_483_42: cast zx s_483_41 -> bv
        let s_483_42: Bits = Bits::new(s_483_41 as u128, 32u16);
        // D s_483_43: bit-extract s_483_42 s_483_39 s_483_40
        let s_483_43: Bits = (Bits::new(
            ((s_483_42) >> (s_483_39)).value(),
            u16::try_from(s_483_40).unwrap(),
        ));
        // D s_483_44: cast reint s_483_43 -> u8
        let s_483_44: u8 = (s_483_43.value() as u8);
        // D s_483_45: call decode_aarch32_instrs_VDOT_bf16_i_A1enc_A_txt(s_483_8, s_483_14, s_483_20, s_483_26, s_483_32, s_483_38, s_483_44)
        let s_483_45: () = decode_aarch32_instrs_VDOT_bf16_i_A1enc_A_txt(
            state,
            tracer,
            s_483_8,
            s_483_14,
            s_483_20,
            s_483_26,
            s_483_32,
            s_483_38,
            s_483_44,
        );
        // N s_483_46: return
        return;
    }
    fn block_484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_484_0: read-var merge#var.1:struct
        let s_484_0: u32 = fn_state.merge_var._1;
        // D s_484_1: write-var u#34463 <= s_484_0
        fn_state.u_34463 = s_484_0;
        // C s_484_2: const #23s : i
        let s_484_2: i128 = 23;
        // D s_484_3: read-var u#34463:u32
        let s_484_3: u32 = fn_state.u_34463;
        // D s_484_4: cast zx s_484_3 -> bv
        let s_484_4: Bits = Bits::new(s_484_3 as u128, 32u16);
        // C s_484_5: const #1s : i64
        let s_484_5: i64 = 1;
        // C s_484_6: cast zx s_484_5 -> i
        let s_484_6: i128 = (i128::try_from(s_484_5).unwrap());
        // C s_484_7: const #8s : i
        let s_484_7: i128 = 8;
        // C s_484_8: add s_484_7 s_484_6
        let s_484_8: i128 = (s_484_7 + s_484_6);
        // D s_484_9: bit-extract s_484_4 s_484_2 s_484_8
        let s_484_9: Bits = (Bits::new(
            ((s_484_4) >> (s_484_2)).value(),
            u16::try_from(s_484_8).unwrap(),
        ));
        // D s_484_10: cast reint s_484_9 -> u9
        let s_484_10: u16 = (s_484_9.value() as u16);
        // D s_484_11: cast zx s_484_10 -> bv
        let s_484_11: Bits = Bits::new(s_484_10 as u128, 9u16);
        // C s_484_12: const #504u : u9
        let s_484_12: u16 = 504;
        // C s_484_13: cast zx s_484_12 -> bv
        let s_484_13: Bits = Bits::new(s_484_12 as u128, 9u16);
        // D s_484_14: cmp-eq s_484_11 s_484_13
        let s_484_14: bool = ((s_484_11) == (s_484_13));
        // N s_484_15: branch s_484_14 b593 b485
        if s_484_14 {
            return block_593(state, tracer, fn_state);
        } else {
            return block_485(state, tracer, fn_state);
        };
    }
    fn block_485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_485_0: const #0u : u8
        let s_485_0: bool = false;
        // D s_485_1: write-var gs#413841 <= s_485_0
        fn_state.gs_413841 = s_485_0;
        // N s_485_2: jump b486
        return block_486(state, tracer, fn_state);
    }
    fn block_486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_486_0: read-var gs#413841:u8
        let s_486_0: bool = fn_state.gs_413841;
        // N s_486_1: branch s_486_0 b592 b487
        if s_486_0 {
            return block_592(state, tracer, fn_state);
        } else {
            return block_487(state, tracer, fn_state);
        };
    }
    fn block_487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_487_0: const #0u : u8
        let s_487_0: bool = false;
        // D s_487_1: write-var gs#413843 <= s_487_0
        fn_state.gs_413843 = s_487_0;
        // N s_487_2: jump b488
        return block_488(state, tracer, fn_state);
    }
    fn block_488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_488_0: read-var gs#413843:u8
        let s_488_0: bool = fn_state.gs_413843;
        // D s_488_1: not s_488_0
        let s_488_1: bool = !s_488_0;
        // N s_488_2: branch s_488_1 b490 b489
        if s_488_1 {
            return block_490(state, tracer, fn_state);
        } else {
            return block_489(state, tracer, fn_state);
        };
    }
    fn block_489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_489_0: const #3920s : i
        let s_489_0: i128 = 3920;
        // C s_489_1: const #14696u : u32
        let s_489_1: u32 = 14696;
        // N s_489_2: write-reg s_489_1 <= s_489_0
        let s_489_2: () = {
            state.write_register::<i128>(s_489_1 as isize, s_489_0);
            tracer.write_register(s_489_1 as isize, s_489_0);
        };
        // C s_489_3: const #22s : i
        let s_489_3: i128 = 22;
        // C s_489_4: const #1s : i
        let s_489_4: i128 = 1;
        // D s_489_5: read-var u#34463:u32
        let s_489_5: u32 = fn_state.u_34463;
        // D s_489_6: cast zx s_489_5 -> bv
        let s_489_6: Bits = Bits::new(s_489_5 as u128, 32u16);
        // D s_489_7: bit-extract s_489_6 s_489_3 s_489_4
        let s_489_7: Bits = (Bits::new(
            ((s_489_6) >> (s_489_3)).value(),
            u16::try_from(s_489_4).unwrap(),
        ));
        // D s_489_8: cast reint s_489_7 -> u8
        let s_489_8: bool = ((s_489_7.value()) != 0);
        // C s_489_9: const #16s : i
        let s_489_9: i128 = 16;
        // C s_489_10: const #4s : i
        let s_489_10: i128 = 4;
        // D s_489_11: read-var u#34463:u32
        let s_489_11: u32 = fn_state.u_34463;
        // D s_489_12: cast zx s_489_11 -> bv
        let s_489_12: Bits = Bits::new(s_489_11 as u128, 32u16);
        // D s_489_13: bit-extract s_489_12 s_489_9 s_489_10
        let s_489_13: Bits = (Bits::new(
            ((s_489_12) >> (s_489_9)).value(),
            u16::try_from(s_489_10).unwrap(),
        ));
        // D s_489_14: cast reint s_489_13 -> u8
        let s_489_14: u8 = (s_489_13.value() as u8);
        // C s_489_15: const #12s : i
        let s_489_15: i128 = 12;
        // C s_489_16: const #4s : i
        let s_489_16: i128 = 4;
        // D s_489_17: read-var u#34463:u32
        let s_489_17: u32 = fn_state.u_34463;
        // D s_489_18: cast zx s_489_17 -> bv
        let s_489_18: Bits = Bits::new(s_489_17 as u128, 32u16);
        // D s_489_19: bit-extract s_489_18 s_489_15 s_489_16
        let s_489_19: Bits = (Bits::new(
            ((s_489_18) >> (s_489_15)).value(),
            u16::try_from(s_489_16).unwrap(),
        ));
        // D s_489_20: cast reint s_489_19 -> u8
        let s_489_20: u8 = (s_489_19.value() as u8);
        // C s_489_21: const #7s : i
        let s_489_21: i128 = 7;
        // C s_489_22: const #1s : i
        let s_489_22: i128 = 1;
        // D s_489_23: read-var u#34463:u32
        let s_489_23: u32 = fn_state.u_34463;
        // D s_489_24: cast zx s_489_23 -> bv
        let s_489_24: Bits = Bits::new(s_489_23 as u128, 32u16);
        // D s_489_25: bit-extract s_489_24 s_489_21 s_489_22
        let s_489_25: Bits = (Bits::new(
            ((s_489_24) >> (s_489_21)).value(),
            u16::try_from(s_489_22).unwrap(),
        ));
        // D s_489_26: cast reint s_489_25 -> u8
        let s_489_26: bool = ((s_489_25.value()) != 0);
        // C s_489_27: const #5s : i
        let s_489_27: i128 = 5;
        // C s_489_28: const #1s : i
        let s_489_28: i128 = 1;
        // D s_489_29: read-var u#34463:u32
        let s_489_29: u32 = fn_state.u_34463;
        // D s_489_30: cast zx s_489_29 -> bv
        let s_489_30: Bits = Bits::new(s_489_29 as u128, 32u16);
        // D s_489_31: bit-extract s_489_30 s_489_27 s_489_28
        let s_489_31: Bits = (Bits::new(
            ((s_489_30) >> (s_489_27)).value(),
            u16::try_from(s_489_28).unwrap(),
        ));
        // D s_489_32: cast reint s_489_31 -> u8
        let s_489_32: bool = ((s_489_31.value()) != 0);
        // C s_489_33: const #0s : i
        let s_489_33: i128 = 0;
        // C s_489_34: const #4s : i
        let s_489_34: i128 = 4;
        // D s_489_35: read-var u#34463:u32
        let s_489_35: u32 = fn_state.u_34463;
        // D s_489_36: cast zx s_489_35 -> bv
        let s_489_36: Bits = Bits::new(s_489_35 as u128, 32u16);
        // D s_489_37: bit-extract s_489_36 s_489_33 s_489_34
        let s_489_37: Bits = (Bits::new(
            ((s_489_36) >> (s_489_33)).value(),
            u16::try_from(s_489_34).unwrap(),
        ));
        // D s_489_38: cast reint s_489_37 -> u8
        let s_489_38: u8 = (s_489_37.value() as u8);
        // D s_489_39: call decode_aarch32_instrs_VMMLA_A1enc_A_txt(s_489_8, s_489_14, s_489_20, s_489_26, s_489_32, s_489_38)
        let s_489_39: () = decode_aarch32_instrs_VMMLA_A1enc_A_txt(
            state,
            tracer,
            s_489_8,
            s_489_14,
            s_489_20,
            s_489_26,
            s_489_32,
            s_489_38,
        );
        // N s_489_40: return
        return;
    }
    fn block_490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_490_0: read-var merge#var.1:struct
        let s_490_0: u32 = fn_state.merge_var._1;
        // D s_490_1: write-var u#34471 <= s_490_0
        fn_state.u_34471 = s_490_0;
        // C s_490_2: const #23s : i
        let s_490_2: i128 = 23;
        // D s_490_3: read-var u#34471:u32
        let s_490_3: u32 = fn_state.u_34471;
        // D s_490_4: cast zx s_490_3 -> bv
        let s_490_4: Bits = Bits::new(s_490_3 as u128, 32u16);
        // C s_490_5: const #1s : i64
        let s_490_5: i64 = 1;
        // C s_490_6: cast zx s_490_5 -> i
        let s_490_6: i128 = (i128::try_from(s_490_5).unwrap());
        // C s_490_7: const #4s : i
        let s_490_7: i128 = 4;
        // C s_490_8: add s_490_7 s_490_6
        let s_490_8: i128 = (s_490_7 + s_490_6);
        // D s_490_9: bit-extract s_490_4 s_490_2 s_490_8
        let s_490_9: Bits = (Bits::new(
            ((s_490_4) >> (s_490_2)).value(),
            u16::try_from(s_490_8).unwrap(),
        ));
        // D s_490_10: cast reint s_490_9 -> u8
        let s_490_10: u8 = (s_490_9.value() as u8);
        // D s_490_11: cast zx s_490_10 -> bv
        let s_490_11: Bits = Bits::new(s_490_10 as u128, 5u16);
        // C s_490_12: const #29u : u8
        let s_490_12: u8 = 29;
        // C s_490_13: cast zx s_490_12 -> bv
        let s_490_13: Bits = Bits::new(s_490_12 as u128, 5u16);
        // D s_490_14: cmp-eq s_490_11 s_490_13
        let s_490_14: bool = ((s_490_11) == (s_490_13));
        // N s_490_15: branch s_490_14 b585 b491
        if s_490_14 {
            return block_585(state, tracer, fn_state);
        } else {
            return block_491(state, tracer, fn_state);
        };
    }
    fn block_491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_491_0: const #0u : u8
        let s_491_0: bool = false;
        // D s_491_1: write-var gs#413869 <= s_491_0
        fn_state.gs_413869 = s_491_0;
        // N s_491_2: jump b492
        return block_492(state, tracer, fn_state);
    }
    fn block_492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_492_0: read-var gs#413869:u8
        let s_492_0: bool = fn_state.gs_413869;
        // N s_492_1: branch s_492_0 b581 b493
        if s_492_0 {
            return block_581(state, tracer, fn_state);
        } else {
            return block_493(state, tracer, fn_state);
        };
    }
    fn block_493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_493_0: const #0u : u8
        let s_493_0: bool = false;
        // D s_493_1: write-var gs#413874 <= s_493_0
        fn_state.gs_413874 = s_493_0;
        // N s_493_2: jump b494
        return block_494(state, tracer, fn_state);
    }
    fn block_494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_494_0: read-var gs#413874:u8
        let s_494_0: bool = fn_state.gs_413874;
        // D s_494_1: not s_494_0
        let s_494_1: bool = !s_494_0;
        // N s_494_2: branch s_494_1 b496 b495
        if s_494_1 {
            return block_496(state, tracer, fn_state);
        } else {
            return block_495(state, tracer, fn_state);
        };
    }
    fn block_495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_495_0: const #3924s : i
        let s_495_0: i128 = 3924;
        // C s_495_1: const #14696u : u32
        let s_495_1: u32 = 14696;
        // N s_495_2: write-reg s_495_1 <= s_495_0
        let s_495_2: () = {
            state.write_register::<i128>(s_495_1 as isize, s_495_0);
            tracer.write_register(s_495_1 as isize, s_495_0);
        };
        // C s_495_3: const #28s : i
        let s_495_3: i128 = 28;
        // C s_495_4: const #4s : i
        let s_495_4: i128 = 4;
        // D s_495_5: read-var u#34471:u32
        let s_495_5: u32 = fn_state.u_34471;
        // D s_495_6: cast zx s_495_5 -> bv
        let s_495_6: Bits = Bits::new(s_495_5 as u128, 32u16);
        // D s_495_7: bit-extract s_495_6 s_495_3 s_495_4
        let s_495_7: Bits = (Bits::new(
            ((s_495_6) >> (s_495_3)).value(),
            u16::try_from(s_495_4).unwrap(),
        ));
        // D s_495_8: cast reint s_495_7 -> u8
        let s_495_8: u8 = (s_495_7.value() as u8);
        // C s_495_9: const #22s : i
        let s_495_9: i128 = 22;
        // C s_495_10: const #1s : i
        let s_495_10: i128 = 1;
        // D s_495_11: read-var u#34471:u32
        let s_495_11: u32 = fn_state.u_34471;
        // D s_495_12: cast zx s_495_11 -> bv
        let s_495_12: Bits = Bits::new(s_495_11 as u128, 32u16);
        // D s_495_13: bit-extract s_495_12 s_495_9 s_495_10
        let s_495_13: Bits = (Bits::new(
            ((s_495_12) >> (s_495_9)).value(),
            u16::try_from(s_495_10).unwrap(),
        ));
        // D s_495_14: cast reint s_495_13 -> u8
        let s_495_14: bool = ((s_495_13.value()) != 0);
        // C s_495_15: const #12s : i
        let s_495_15: i128 = 12;
        // C s_495_16: const #4s : i
        let s_495_16: i128 = 4;
        // D s_495_17: read-var u#34471:u32
        let s_495_17: u32 = fn_state.u_34471;
        // D s_495_18: cast zx s_495_17 -> bv
        let s_495_18: Bits = Bits::new(s_495_17 as u128, 32u16);
        // D s_495_19: bit-extract s_495_18 s_495_15 s_495_16
        let s_495_19: Bits = (Bits::new(
            ((s_495_18) >> (s_495_15)).value(),
            u16::try_from(s_495_16).unwrap(),
        ));
        // D s_495_20: cast reint s_495_19 -> u8
        let s_495_20: u8 = (s_495_19.value() as u8);
        // C s_495_21: const #5s : i
        let s_495_21: i128 = 5;
        // C s_495_22: const #1s : i
        let s_495_22: i128 = 1;
        // D s_495_23: read-var u#34471:u32
        let s_495_23: u32 = fn_state.u_34471;
        // D s_495_24: cast zx s_495_23 -> bv
        let s_495_24: Bits = Bits::new(s_495_23 as u128, 32u16);
        // D s_495_25: bit-extract s_495_24 s_495_21 s_495_22
        let s_495_25: Bits = (Bits::new(
            ((s_495_24) >> (s_495_21)).value(),
            u16::try_from(s_495_22).unwrap(),
        ));
        // D s_495_26: cast reint s_495_25 -> u8
        let s_495_26: bool = ((s_495_25.value()) != 0);
        // C s_495_27: const #0s : i
        let s_495_27: i128 = 0;
        // C s_495_28: const #4s : i
        let s_495_28: i128 = 4;
        // D s_495_29: read-var u#34471:u32
        let s_495_29: u32 = fn_state.u_34471;
        // D s_495_30: cast zx s_495_29 -> bv
        let s_495_30: Bits = Bits::new(s_495_29 as u128, 32u16);
        // D s_495_31: bit-extract s_495_30 s_495_27 s_495_28
        let s_495_31: Bits = (Bits::new(
            ((s_495_30) >> (s_495_27)).value(),
            u16::try_from(s_495_28).unwrap(),
        ));
        // D s_495_32: cast reint s_495_31 -> u8
        let s_495_32: u8 = (s_495_31.value() as u8);
        // D s_495_33: call decode_aarch32_instrs_VCVTB_bf16_A1enc_A_txt(s_495_8, s_495_14, s_495_20, s_495_26, s_495_32)
        let s_495_33: () = decode_aarch32_instrs_VCVTB_bf16_A1enc_A_txt(
            state,
            tracer,
            s_495_8,
            s_495_14,
            s_495_20,
            s_495_26,
            s_495_32,
        );
        // N s_495_34: return
        return;
    }
    fn block_496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_496_0: read-var merge#var.1:struct
        let s_496_0: u32 = fn_state.merge_var._1;
        // D s_496_1: write-var u#34478 <= s_496_0
        fn_state.u_34478 = s_496_0;
        // C s_496_2: const #23s : i
        let s_496_2: i128 = 23;
        // D s_496_3: read-var u#34478:u32
        let s_496_3: u32 = fn_state.u_34478;
        // D s_496_4: cast zx s_496_3 -> bv
        let s_496_4: Bits = Bits::new(s_496_3 as u128, 32u16);
        // C s_496_5: const #1s : i64
        let s_496_5: i64 = 1;
        // C s_496_6: cast zx s_496_5 -> i
        let s_496_6: i128 = (i128::try_from(s_496_5).unwrap());
        // C s_496_7: const #4s : i
        let s_496_7: i128 = 4;
        // C s_496_8: add s_496_7 s_496_6
        let s_496_8: i128 = (s_496_7 + s_496_6);
        // D s_496_9: bit-extract s_496_4 s_496_2 s_496_8
        let s_496_9: Bits = (Bits::new(
            ((s_496_4) >> (s_496_2)).value(),
            u16::try_from(s_496_8).unwrap(),
        ));
        // D s_496_10: cast reint s_496_9 -> u8
        let s_496_10: u8 = (s_496_9.value() as u8);
        // D s_496_11: cast zx s_496_10 -> bv
        let s_496_11: Bits = Bits::new(s_496_10 as u128, 5u16);
        // C s_496_12: const #29u : u8
        let s_496_12: u8 = 29;
        // C s_496_13: cast zx s_496_12 -> bv
        let s_496_13: Bits = Bits::new(s_496_12 as u128, 5u16);
        // D s_496_14: cmp-eq s_496_11 s_496_13
        let s_496_14: bool = ((s_496_11) == (s_496_13));
        // N s_496_15: branch s_496_14 b574 b497
        if s_496_14 {
            return block_574(state, tracer, fn_state);
        } else {
            return block_497(state, tracer, fn_state);
        };
    }
    fn block_497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_497_0: const #0u : u8
        let s_497_0: bool = false;
        // D s_497_1: write-var gs#413898 <= s_497_0
        fn_state.gs_413898 = s_497_0;
        // N s_497_2: jump b498
        return block_498(state, tracer, fn_state);
    }
    fn block_498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_498_0: read-var gs#413898:u8
        let s_498_0: bool = fn_state.gs_413898;
        // N s_498_1: branch s_498_0 b570 b499
        if s_498_0 {
            return block_570(state, tracer, fn_state);
        } else {
            return block_499(state, tracer, fn_state);
        };
    }
    fn block_499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_499_0: const #0u : u8
        let s_499_0: bool = false;
        // D s_499_1: write-var gs#413903 <= s_499_0
        fn_state.gs_413903 = s_499_0;
        // N s_499_2: jump b500
        return block_500(state, tracer, fn_state);
    }
    fn block_500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_500_0: read-var gs#413903:u8
        let s_500_0: bool = fn_state.gs_413903;
        // D s_500_1: not s_500_0
        let s_500_1: bool = !s_500_0;
        // N s_500_2: branch s_500_1 b502 b501
        if s_500_1 {
            return block_502(state, tracer, fn_state);
        } else {
            return block_501(state, tracer, fn_state);
        };
    }
    fn block_501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_501_0: const #3926s : i
        let s_501_0: i128 = 3926;
        // C s_501_1: const #14696u : u32
        let s_501_1: u32 = 14696;
        // N s_501_2: write-reg s_501_1 <= s_501_0
        let s_501_2: () = {
            state.write_register::<i128>(s_501_1 as isize, s_501_0);
            tracer.write_register(s_501_1 as isize, s_501_0);
        };
        // C s_501_3: const #28s : i
        let s_501_3: i128 = 28;
        // C s_501_4: const #4s : i
        let s_501_4: i128 = 4;
        // D s_501_5: read-var u#34478:u32
        let s_501_5: u32 = fn_state.u_34478;
        // D s_501_6: cast zx s_501_5 -> bv
        let s_501_6: Bits = Bits::new(s_501_5 as u128, 32u16);
        // D s_501_7: bit-extract s_501_6 s_501_3 s_501_4
        let s_501_7: Bits = (Bits::new(
            ((s_501_6) >> (s_501_3)).value(),
            u16::try_from(s_501_4).unwrap(),
        ));
        // D s_501_8: cast reint s_501_7 -> u8
        let s_501_8: u8 = (s_501_7.value() as u8);
        // C s_501_9: const #22s : i
        let s_501_9: i128 = 22;
        // C s_501_10: const #1s : i
        let s_501_10: i128 = 1;
        // D s_501_11: read-var u#34478:u32
        let s_501_11: u32 = fn_state.u_34478;
        // D s_501_12: cast zx s_501_11 -> bv
        let s_501_12: Bits = Bits::new(s_501_11 as u128, 32u16);
        // D s_501_13: bit-extract s_501_12 s_501_9 s_501_10
        let s_501_13: Bits = (Bits::new(
            ((s_501_12) >> (s_501_9)).value(),
            u16::try_from(s_501_10).unwrap(),
        ));
        // D s_501_14: cast reint s_501_13 -> u8
        let s_501_14: bool = ((s_501_13.value()) != 0);
        // C s_501_15: const #12s : i
        let s_501_15: i128 = 12;
        // C s_501_16: const #4s : i
        let s_501_16: i128 = 4;
        // D s_501_17: read-var u#34478:u32
        let s_501_17: u32 = fn_state.u_34478;
        // D s_501_18: cast zx s_501_17 -> bv
        let s_501_18: Bits = Bits::new(s_501_17 as u128, 32u16);
        // D s_501_19: bit-extract s_501_18 s_501_15 s_501_16
        let s_501_19: Bits = (Bits::new(
            ((s_501_18) >> (s_501_15)).value(),
            u16::try_from(s_501_16).unwrap(),
        ));
        // D s_501_20: cast reint s_501_19 -> u8
        let s_501_20: u8 = (s_501_19.value() as u8);
        // C s_501_21: const #5s : i
        let s_501_21: i128 = 5;
        // C s_501_22: const #1s : i
        let s_501_22: i128 = 1;
        // D s_501_23: read-var u#34478:u32
        let s_501_23: u32 = fn_state.u_34478;
        // D s_501_24: cast zx s_501_23 -> bv
        let s_501_24: Bits = Bits::new(s_501_23 as u128, 32u16);
        // D s_501_25: bit-extract s_501_24 s_501_21 s_501_22
        let s_501_25: Bits = (Bits::new(
            ((s_501_24) >> (s_501_21)).value(),
            u16::try_from(s_501_22).unwrap(),
        ));
        // D s_501_26: cast reint s_501_25 -> u8
        let s_501_26: bool = ((s_501_25.value()) != 0);
        // C s_501_27: const #0s : i
        let s_501_27: i128 = 0;
        // C s_501_28: const #4s : i
        let s_501_28: i128 = 4;
        // D s_501_29: read-var u#34478:u32
        let s_501_29: u32 = fn_state.u_34478;
        // D s_501_30: cast zx s_501_29 -> bv
        let s_501_30: Bits = Bits::new(s_501_29 as u128, 32u16);
        // D s_501_31: bit-extract s_501_30 s_501_27 s_501_28
        let s_501_31: Bits = (Bits::new(
            ((s_501_30) >> (s_501_27)).value(),
            u16::try_from(s_501_28).unwrap(),
        ));
        // D s_501_32: cast reint s_501_31 -> u8
        let s_501_32: u8 = (s_501_31.value() as u8);
        // D s_501_33: call decode_aarch32_instrs_VCVTT_A1enc_A_txt(s_501_8, s_501_14, s_501_20, s_501_26, s_501_32)
        let s_501_33: () = decode_aarch32_instrs_VCVTT_A1enc_A_txt(
            state,
            tracer,
            s_501_8,
            s_501_14,
            s_501_20,
            s_501_26,
            s_501_32,
        );
        // N s_501_34: return
        return;
    }
    fn block_502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_502_0: read-var merge#var.1:struct
        let s_502_0: u32 = fn_state.merge_var._1;
        // D s_502_1: write-var u#34485 <= s_502_0
        fn_state.u_34485 = s_502_0;
        // C s_502_2: const #23s : i
        let s_502_2: i128 = 23;
        // D s_502_3: read-var u#34485:u32
        let s_502_3: u32 = fn_state.u_34485;
        // D s_502_4: cast zx s_502_3 -> bv
        let s_502_4: Bits = Bits::new(s_502_3 as u128, 32u16);
        // C s_502_5: const #1s : i64
        let s_502_5: i64 = 1;
        // C s_502_6: cast zx s_502_5 -> i
        let s_502_6: i128 = (i128::try_from(s_502_5).unwrap());
        // C s_502_7: const #8s : i
        let s_502_7: i128 = 8;
        // C s_502_8: add s_502_7 s_502_6
        let s_502_8: i128 = (s_502_7 + s_502_6);
        // D s_502_9: bit-extract s_502_4 s_502_2 s_502_8
        let s_502_9: Bits = (Bits::new(
            ((s_502_4) >> (s_502_2)).value(),
            u16::try_from(s_502_8).unwrap(),
        ));
        // D s_502_10: cast reint s_502_9 -> u9
        let s_502_10: u16 = (s_502_9.value() as u16);
        // D s_502_11: cast zx s_502_10 -> bv
        let s_502_11: Bits = Bits::new(s_502_10 as u128, 9u16);
        // C s_502_12: const #504u : u9
        let s_502_12: u16 = 504;
        // C s_502_13: cast zx s_502_12 -> bv
        let s_502_13: Bits = Bits::new(s_502_12 as u128, 9u16);
        // D s_502_14: cmp-eq s_502_11 s_502_13
        let s_502_14: bool = ((s_502_11) == (s_502_13));
        // N s_502_15: branch s_502_14 b563 b503
        if s_502_14 {
            return block_563(state, tracer, fn_state);
        } else {
            return block_503(state, tracer, fn_state);
        };
    }
    fn block_503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_503_0: const #0u : u8
        let s_503_0: bool = false;
        // D s_503_1: write-var gs#413927 <= s_503_0
        fn_state.gs_413927 = s_503_0;
        // N s_503_2: jump b504
        return block_504(state, tracer, fn_state);
    }
    fn block_504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_504_0: read-var gs#413927:u8
        let s_504_0: bool = fn_state.gs_413927;
        // N s_504_1: branch s_504_0 b562 b505
        if s_504_0 {
            return block_562(state, tracer, fn_state);
        } else {
            return block_505(state, tracer, fn_state);
        };
    }
    fn block_505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_505_0: const #0u : u8
        let s_505_0: bool = false;
        // D s_505_1: write-var gs#413929 <= s_505_0
        fn_state.gs_413929 = s_505_0;
        // N s_505_2: jump b506
        return block_506(state, tracer, fn_state);
    }
    fn block_506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_506_0: read-var gs#413929:u8
        let s_506_0: bool = fn_state.gs_413929;
        // D s_506_1: not s_506_0
        let s_506_1: bool = !s_506_0;
        // N s_506_2: branch s_506_1 b508 b507
        if s_506_1 {
            return block_508(state, tracer, fn_state);
        } else {
            return block_507(state, tracer, fn_state);
        };
    }
    fn block_507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_507_0: const #3928s : i
        let s_507_0: i128 = 3928;
        // C s_507_1: const #14696u : u32
        let s_507_1: u32 = 14696;
        // N s_507_2: write-reg s_507_1 <= s_507_0
        let s_507_2: () = {
            state.write_register::<i128>(s_507_1 as isize, s_507_0);
            tracer.write_register(s_507_1 as isize, s_507_0);
        };
        // C s_507_3: const #22s : i
        let s_507_3: i128 = 22;
        // C s_507_4: const #1s : i
        let s_507_4: i128 = 1;
        // D s_507_5: read-var u#34485:u32
        let s_507_5: u32 = fn_state.u_34485;
        // D s_507_6: cast zx s_507_5 -> bv
        let s_507_6: Bits = Bits::new(s_507_5 as u128, 32u16);
        // D s_507_7: bit-extract s_507_6 s_507_3 s_507_4
        let s_507_7: Bits = (Bits::new(
            ((s_507_6) >> (s_507_3)).value(),
            u16::try_from(s_507_4).unwrap(),
        ));
        // D s_507_8: cast reint s_507_7 -> u8
        let s_507_8: bool = ((s_507_7.value()) != 0);
        // C s_507_9: const #16s : i
        let s_507_9: i128 = 16;
        // C s_507_10: const #4s : i
        let s_507_10: i128 = 4;
        // D s_507_11: read-var u#34485:u32
        let s_507_11: u32 = fn_state.u_34485;
        // D s_507_12: cast zx s_507_11 -> bv
        let s_507_12: Bits = Bits::new(s_507_11 as u128, 32u16);
        // D s_507_13: bit-extract s_507_12 s_507_9 s_507_10
        let s_507_13: Bits = (Bits::new(
            ((s_507_12) >> (s_507_9)).value(),
            u16::try_from(s_507_10).unwrap(),
        ));
        // D s_507_14: cast reint s_507_13 -> u8
        let s_507_14: u8 = (s_507_13.value() as u8);
        // C s_507_15: const #12s : i
        let s_507_15: i128 = 12;
        // C s_507_16: const #4s : i
        let s_507_16: i128 = 4;
        // D s_507_17: read-var u#34485:u32
        let s_507_17: u32 = fn_state.u_34485;
        // D s_507_18: cast zx s_507_17 -> bv
        let s_507_18: Bits = Bits::new(s_507_17 as u128, 32u16);
        // D s_507_19: bit-extract s_507_18 s_507_15 s_507_16
        let s_507_19: Bits = (Bits::new(
            ((s_507_18) >> (s_507_15)).value(),
            u16::try_from(s_507_16).unwrap(),
        ));
        // D s_507_20: cast reint s_507_19 -> u8
        let s_507_20: u8 = (s_507_19.value() as u8);
        // C s_507_21: const #7s : i
        let s_507_21: i128 = 7;
        // C s_507_22: const #1s : i
        let s_507_22: i128 = 1;
        // D s_507_23: read-var u#34485:u32
        let s_507_23: u32 = fn_state.u_34485;
        // D s_507_24: cast zx s_507_23 -> bv
        let s_507_24: Bits = Bits::new(s_507_23 as u128, 32u16);
        // D s_507_25: bit-extract s_507_24 s_507_21 s_507_22
        let s_507_25: Bits = (Bits::new(
            ((s_507_24) >> (s_507_21)).value(),
            u16::try_from(s_507_22).unwrap(),
        ));
        // D s_507_26: cast reint s_507_25 -> u8
        let s_507_26: bool = ((s_507_25.value()) != 0);
        // C s_507_27: const #6s : i
        let s_507_27: i128 = 6;
        // C s_507_28: const #1s : i
        let s_507_28: i128 = 1;
        // D s_507_29: read-var u#34485:u32
        let s_507_29: u32 = fn_state.u_34485;
        // D s_507_30: cast zx s_507_29 -> bv
        let s_507_30: Bits = Bits::new(s_507_29 as u128, 32u16);
        // D s_507_31: bit-extract s_507_30 s_507_27 s_507_28
        let s_507_31: Bits = (Bits::new(
            ((s_507_30) >> (s_507_27)).value(),
            u16::try_from(s_507_28).unwrap(),
        ));
        // D s_507_32: cast reint s_507_31 -> u8
        let s_507_32: bool = ((s_507_31.value()) != 0);
        // C s_507_33: const #5s : i
        let s_507_33: i128 = 5;
        // C s_507_34: const #1s : i
        let s_507_34: i128 = 1;
        // D s_507_35: read-var u#34485:u32
        let s_507_35: u32 = fn_state.u_34485;
        // D s_507_36: cast zx s_507_35 -> bv
        let s_507_36: Bits = Bits::new(s_507_35 as u128, 32u16);
        // D s_507_37: bit-extract s_507_36 s_507_33 s_507_34
        let s_507_37: Bits = (Bits::new(
            ((s_507_36) >> (s_507_33)).value(),
            u16::try_from(s_507_34).unwrap(),
        ));
        // D s_507_38: cast reint s_507_37 -> u8
        let s_507_38: bool = ((s_507_37.value()) != 0);
        // C s_507_39: const #0s : i
        let s_507_39: i128 = 0;
        // C s_507_40: const #4s : i
        let s_507_40: i128 = 4;
        // D s_507_41: read-var u#34485:u32
        let s_507_41: u32 = fn_state.u_34485;
        // D s_507_42: cast zx s_507_41 -> bv
        let s_507_42: Bits = Bits::new(s_507_41 as u128, 32u16);
        // D s_507_43: bit-extract s_507_42 s_507_39 s_507_40
        let s_507_43: Bits = (Bits::new(
            ((s_507_42) >> (s_507_39)).value(),
            u16::try_from(s_507_40).unwrap(),
        ));
        // D s_507_44: cast reint s_507_43 -> u8
        let s_507_44: u8 = (s_507_43.value() as u8);
        // D s_507_45: call decode_aarch32_instrs_VFMA_bf_A1enc_A_txt(s_507_8, s_507_14, s_507_20, s_507_26, s_507_32, s_507_38, s_507_44)
        let s_507_45: () = decode_aarch32_instrs_VFMA_bf_A1enc_A_txt(
            state,
            tracer,
            s_507_8,
            s_507_14,
            s_507_20,
            s_507_26,
            s_507_32,
            s_507_38,
            s_507_44,
        );
        // N s_507_46: return
        return;
    }
    fn block_508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_508_0: read-var merge#var.1:struct
        let s_508_0: u32 = fn_state.merge_var._1;
        // D s_508_1: write-var u#34494 <= s_508_0
        fn_state.u_34494 = s_508_0;
        // C s_508_2: const #23s : i
        let s_508_2: i128 = 23;
        // D s_508_3: read-var u#34494:u32
        let s_508_3: u32 = fn_state.u_34494;
        // D s_508_4: cast zx s_508_3 -> bv
        let s_508_4: Bits = Bits::new(s_508_3 as u128, 32u16);
        // C s_508_5: const #1s : i64
        let s_508_5: i64 = 1;
        // C s_508_6: cast zx s_508_5 -> i
        let s_508_6: i128 = (i128::try_from(s_508_5).unwrap());
        // C s_508_7: const #8s : i
        let s_508_7: i128 = 8;
        // C s_508_8: add s_508_7 s_508_6
        let s_508_8: i128 = (s_508_7 + s_508_6);
        // D s_508_9: bit-extract s_508_4 s_508_2 s_508_8
        let s_508_9: Bits = (Bits::new(
            ((s_508_4) >> (s_508_2)).value(),
            u16::try_from(s_508_8).unwrap(),
        ));
        // D s_508_10: cast reint s_508_9 -> u9
        let s_508_10: u16 = (s_508_9.value() as u16);
        // D s_508_11: cast zx s_508_10 -> bv
        let s_508_11: Bits = Bits::new(s_508_10 as u128, 9u16);
        // C s_508_12: const #508u : u9
        let s_508_12: u16 = 508;
        // C s_508_13: cast zx s_508_12 -> bv
        let s_508_13: Bits = Bits::new(s_508_12 as u128, 9u16);
        // D s_508_14: cmp-eq s_508_11 s_508_13
        let s_508_14: bool = ((s_508_11) == (s_508_13));
        // N s_508_15: branch s_508_14 b555 b509
        if s_508_14 {
            return block_555(state, tracer, fn_state);
        } else {
            return block_509(state, tracer, fn_state);
        };
    }
    fn block_509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_509_0: const #0u : u8
        let s_509_0: bool = false;
        // D s_509_1: write-var gs#413957 <= s_509_0
        fn_state.gs_413957 = s_509_0;
        // N s_509_2: jump b510
        return block_510(state, tracer, fn_state);
    }
    fn block_510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_510_0: read-var gs#413957:u8
        let s_510_0: bool = fn_state.gs_413957;
        // N s_510_1: branch s_510_0 b554 b511
        if s_510_0 {
            return block_554(state, tracer, fn_state);
        } else {
            return block_511(state, tracer, fn_state);
        };
    }
    fn block_511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_511_0: const #0u : u8
        let s_511_0: bool = false;
        // D s_511_1: write-var gs#413959 <= s_511_0
        fn_state.gs_413959 = s_511_0;
        // N s_511_2: jump b512
        return block_512(state, tracer, fn_state);
    }
    fn block_512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_512_0: read-var gs#413959:u8
        let s_512_0: bool = fn_state.gs_413959;
        // D s_512_1: not s_512_0
        let s_512_1: bool = !s_512_0;
        // N s_512_2: branch s_512_1 b514 b513
        if s_512_1 {
            return block_514(state, tracer, fn_state);
        } else {
            return block_513(state, tracer, fn_state);
        };
    }
    fn block_513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_513_0: const #3930s : i
        let s_513_0: i128 = 3930;
        // C s_513_1: const #14696u : u32
        let s_513_1: u32 = 14696;
        // N s_513_2: write-reg s_513_1 <= s_513_0
        let s_513_2: () = {
            state.write_register::<i128>(s_513_1 as isize, s_513_0);
            tracer.write_register(s_513_1 as isize, s_513_0);
        };
        // C s_513_3: const #22s : i
        let s_513_3: i128 = 22;
        // C s_513_4: const #1s : i
        let s_513_4: i128 = 1;
        // D s_513_5: read-var u#34494:u32
        let s_513_5: u32 = fn_state.u_34494;
        // D s_513_6: cast zx s_513_5 -> bv
        let s_513_6: Bits = Bits::new(s_513_5 as u128, 32u16);
        // D s_513_7: bit-extract s_513_6 s_513_3 s_513_4
        let s_513_7: Bits = (Bits::new(
            ((s_513_6) >> (s_513_3)).value(),
            u16::try_from(s_513_4).unwrap(),
        ));
        // D s_513_8: cast reint s_513_7 -> u8
        let s_513_8: bool = ((s_513_7.value()) != 0);
        // C s_513_9: const #16s : i
        let s_513_9: i128 = 16;
        // C s_513_10: const #4s : i
        let s_513_10: i128 = 4;
        // D s_513_11: read-var u#34494:u32
        let s_513_11: u32 = fn_state.u_34494;
        // D s_513_12: cast zx s_513_11 -> bv
        let s_513_12: Bits = Bits::new(s_513_11 as u128, 32u16);
        // D s_513_13: bit-extract s_513_12 s_513_9 s_513_10
        let s_513_13: Bits = (Bits::new(
            ((s_513_12) >> (s_513_9)).value(),
            u16::try_from(s_513_10).unwrap(),
        ));
        // D s_513_14: cast reint s_513_13 -> u8
        let s_513_14: u8 = (s_513_13.value() as u8);
        // C s_513_15: const #12s : i
        let s_513_15: i128 = 12;
        // C s_513_16: const #4s : i
        let s_513_16: i128 = 4;
        // D s_513_17: read-var u#34494:u32
        let s_513_17: u32 = fn_state.u_34494;
        // D s_513_18: cast zx s_513_17 -> bv
        let s_513_18: Bits = Bits::new(s_513_17 as u128, 32u16);
        // D s_513_19: bit-extract s_513_18 s_513_15 s_513_16
        let s_513_19: Bits = (Bits::new(
            ((s_513_18) >> (s_513_15)).value(),
            u16::try_from(s_513_16).unwrap(),
        ));
        // D s_513_20: cast reint s_513_19 -> u8
        let s_513_20: u8 = (s_513_19.value() as u8);
        // C s_513_21: const #7s : i
        let s_513_21: i128 = 7;
        // C s_513_22: const #1s : i
        let s_513_22: i128 = 1;
        // D s_513_23: read-var u#34494:u32
        let s_513_23: u32 = fn_state.u_34494;
        // D s_513_24: cast zx s_513_23 -> bv
        let s_513_24: Bits = Bits::new(s_513_23 as u128, 32u16);
        // D s_513_25: bit-extract s_513_24 s_513_21 s_513_22
        let s_513_25: Bits = (Bits::new(
            ((s_513_24) >> (s_513_21)).value(),
            u16::try_from(s_513_22).unwrap(),
        ));
        // D s_513_26: cast reint s_513_25 -> u8
        let s_513_26: bool = ((s_513_25.value()) != 0);
        // C s_513_27: const #6s : i
        let s_513_27: i128 = 6;
        // C s_513_28: const #1s : i
        let s_513_28: i128 = 1;
        // D s_513_29: read-var u#34494:u32
        let s_513_29: u32 = fn_state.u_34494;
        // D s_513_30: cast zx s_513_29 -> bv
        let s_513_30: Bits = Bits::new(s_513_29 as u128, 32u16);
        // D s_513_31: bit-extract s_513_30 s_513_27 s_513_28
        let s_513_31: Bits = (Bits::new(
            ((s_513_30) >> (s_513_27)).value(),
            u16::try_from(s_513_28).unwrap(),
        ));
        // D s_513_32: cast reint s_513_31 -> u8
        let s_513_32: bool = ((s_513_31.value()) != 0);
        // C s_513_33: const #5s : i
        let s_513_33: i128 = 5;
        // C s_513_34: const #1s : i
        let s_513_34: i128 = 1;
        // D s_513_35: read-var u#34494:u32
        let s_513_35: u32 = fn_state.u_34494;
        // D s_513_36: cast zx s_513_35 -> bv
        let s_513_36: Bits = Bits::new(s_513_35 as u128, 32u16);
        // D s_513_37: bit-extract s_513_36 s_513_33 s_513_34
        let s_513_37: Bits = (Bits::new(
            ((s_513_36) >> (s_513_33)).value(),
            u16::try_from(s_513_34).unwrap(),
        ));
        // D s_513_38: cast reint s_513_37 -> u8
        let s_513_38: bool = ((s_513_37.value()) != 0);
        // C s_513_39: const #0s : i
        let s_513_39: i128 = 0;
        // C s_513_40: const #4s : i
        let s_513_40: i128 = 4;
        // D s_513_41: read-var u#34494:u32
        let s_513_41: u32 = fn_state.u_34494;
        // D s_513_42: cast zx s_513_41 -> bv
        let s_513_42: Bits = Bits::new(s_513_41 as u128, 32u16);
        // D s_513_43: bit-extract s_513_42 s_513_39 s_513_40
        let s_513_43: Bits = (Bits::new(
            ((s_513_42) >> (s_513_39)).value(),
            u16::try_from(s_513_40).unwrap(),
        ));
        // D s_513_44: cast reint s_513_43 -> u8
        let s_513_44: u8 = (s_513_43.value() as u8);
        // D s_513_45: call decode_aarch32_instrs_VFMA_bfs_A1enc_A_txt(s_513_8, s_513_14, s_513_20, s_513_26, s_513_32, s_513_38, s_513_44)
        let s_513_45: () = decode_aarch32_instrs_VFMA_bfs_A1enc_A_txt(
            state,
            tracer,
            s_513_8,
            s_513_14,
            s_513_20,
            s_513_26,
            s_513_32,
            s_513_38,
            s_513_44,
        );
        // N s_513_46: return
        return;
    }
    fn block_514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_514_0: read-var merge#var.1:struct
        let s_514_0: u32 = fn_state.merge_var._1;
        // D s_514_1: write-var u#34503 <= s_514_0
        fn_state.u_34503 = s_514_0;
        // C s_514_2: const #24s : i
        let s_514_2: i128 = 24;
        // D s_514_3: read-var u#34503:u32
        let s_514_3: u32 = fn_state.u_34503;
        // D s_514_4: cast zx s_514_3 -> bv
        let s_514_4: Bits = Bits::new(s_514_3 as u128, 32u16);
        // C s_514_5: const #1s : i64
        let s_514_5: i64 = 1;
        // C s_514_6: cast zx s_514_5 -> i
        let s_514_6: i128 = (i128::try_from(s_514_5).unwrap());
        // C s_514_7: const #7s : i
        let s_514_7: i128 = 7;
        // C s_514_8: add s_514_7 s_514_6
        let s_514_8: i128 = (s_514_7 + s_514_6);
        // D s_514_9: bit-extract s_514_4 s_514_2 s_514_8
        let s_514_9: Bits = (Bits::new(
            ((s_514_4) >> (s_514_2)).value(),
            u16::try_from(s_514_8).unwrap(),
        ));
        // D s_514_10: cast reint s_514_9 -> u8
        let s_514_10: u8 = (s_514_9.value() as u8);
        // D s_514_11: cast zx s_514_10 -> bv
        let s_514_11: Bits = Bits::new(s_514_10 as u128, 8u16);
        // C s_514_12: const #252u : u8
        let s_514_12: u8 = 252;
        // C s_514_13: cast zx s_514_12 -> bv
        let s_514_13: Bits = Bits::new(s_514_12 as u128, 8u16);
        // D s_514_14: cmp-eq s_514_11 s_514_13
        let s_514_14: bool = ((s_514_11) == (s_514_13));
        // N s_514_15: branch s_514_14 b547 b515
        if s_514_14 {
            return block_547(state, tracer, fn_state);
        } else {
            return block_515(state, tracer, fn_state);
        };
    }
    fn block_515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_515_0: const #0u : u8
        let s_515_0: bool = false;
        // D s_515_1: write-var gs#413987 <= s_515_0
        fn_state.gs_413987 = s_515_0;
        // N s_515_2: jump b516
        return block_516(state, tracer, fn_state);
    }
    fn block_516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_516_0: read-var gs#413987:u8
        let s_516_0: bool = fn_state.gs_413987;
        // N s_516_1: branch s_516_0 b546 b517
        if s_516_0 {
            return block_546(state, tracer, fn_state);
        } else {
            return block_517(state, tracer, fn_state);
        };
    }
    fn block_517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_517_0: const #0u : u8
        let s_517_0: bool = false;
        // D s_517_1: write-var gs#413989 <= s_517_0
        fn_state.gs_413989 = s_517_0;
        // N s_517_2: jump b518
        return block_518(state, tracer, fn_state);
    }
    fn block_518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_518_0: read-var gs#413989:u8
        let s_518_0: bool = fn_state.gs_413989;
        // D s_518_1: not s_518_0
        let s_518_1: bool = !s_518_0;
        // N s_518_2: branch s_518_1 b520 b519
        if s_518_1 {
            return block_520(state, tracer, fn_state);
        } else {
            return block_519(state, tracer, fn_state);
        };
    }
    fn block_519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_519_0: const #3932s : i
        let s_519_0: i128 = 3932;
        // C s_519_1: const #14696u : u32
        let s_519_1: u32 = 14696;
        // N s_519_2: write-reg s_519_1 <= s_519_0
        let s_519_2: () = {
            state.write_register::<i128>(s_519_1 as isize, s_519_0);
            tracer.write_register(s_519_1 as isize, s_519_0);
        };
        // C s_519_3: const #23s : i
        let s_519_3: i128 = 23;
        // C s_519_4: const #1s : i
        let s_519_4: i128 = 1;
        // D s_519_5: read-var u#34503:u32
        let s_519_5: u32 = fn_state.u_34503;
        // D s_519_6: cast zx s_519_5 -> bv
        let s_519_6: Bits = Bits::new(s_519_5 as u128, 32u16);
        // D s_519_7: bit-extract s_519_6 s_519_3 s_519_4
        let s_519_7: Bits = (Bits::new(
            ((s_519_6) >> (s_519_3)).value(),
            u16::try_from(s_519_4).unwrap(),
        ));
        // D s_519_8: cast reint s_519_7 -> u8
        let s_519_8: bool = ((s_519_7.value()) != 0);
        // C s_519_9: const #22s : i
        let s_519_9: i128 = 22;
        // C s_519_10: const #1s : i
        let s_519_10: i128 = 1;
        // D s_519_11: read-var u#34503:u32
        let s_519_11: u32 = fn_state.u_34503;
        // D s_519_12: cast zx s_519_11 -> bv
        let s_519_12: Bits = Bits::new(s_519_11 as u128, 32u16);
        // D s_519_13: bit-extract s_519_12 s_519_9 s_519_10
        let s_519_13: Bits = (Bits::new(
            ((s_519_12) >> (s_519_9)).value(),
            u16::try_from(s_519_10).unwrap(),
        ));
        // D s_519_14: cast reint s_519_13 -> u8
        let s_519_14: bool = ((s_519_13.value()) != 0);
        // C s_519_15: const #16s : i
        let s_519_15: i128 = 16;
        // C s_519_16: const #4s : i
        let s_519_16: i128 = 4;
        // D s_519_17: read-var u#34503:u32
        let s_519_17: u32 = fn_state.u_34503;
        // D s_519_18: cast zx s_519_17 -> bv
        let s_519_18: Bits = Bits::new(s_519_17 as u128, 32u16);
        // D s_519_19: bit-extract s_519_18 s_519_15 s_519_16
        let s_519_19: Bits = (Bits::new(
            ((s_519_18) >> (s_519_15)).value(),
            u16::try_from(s_519_16).unwrap(),
        ));
        // D s_519_20: cast reint s_519_19 -> u8
        let s_519_20: u8 = (s_519_19.value() as u8);
        // C s_519_21: const #12s : i
        let s_519_21: i128 = 12;
        // C s_519_22: const #4s : i
        let s_519_22: i128 = 4;
        // D s_519_23: read-var u#34503:u32
        let s_519_23: u32 = fn_state.u_34503;
        // D s_519_24: cast zx s_519_23 -> bv
        let s_519_24: Bits = Bits::new(s_519_23 as u128, 32u16);
        // D s_519_25: bit-extract s_519_24 s_519_21 s_519_22
        let s_519_25: Bits = (Bits::new(
            ((s_519_24) >> (s_519_21)).value(),
            u16::try_from(s_519_22).unwrap(),
        ));
        // D s_519_26: cast reint s_519_25 -> u8
        let s_519_26: u8 = (s_519_25.value() as u8);
        // C s_519_27: const #7s : i
        let s_519_27: i128 = 7;
        // C s_519_28: const #1s : i
        let s_519_28: i128 = 1;
        // D s_519_29: read-var u#34503:u32
        let s_519_29: u32 = fn_state.u_34503;
        // D s_519_30: cast zx s_519_29 -> bv
        let s_519_30: Bits = Bits::new(s_519_29 as u128, 32u16);
        // D s_519_31: bit-extract s_519_30 s_519_27 s_519_28
        let s_519_31: Bits = (Bits::new(
            ((s_519_30) >> (s_519_27)).value(),
            u16::try_from(s_519_28).unwrap(),
        ));
        // D s_519_32: cast reint s_519_31 -> u8
        let s_519_32: bool = ((s_519_31.value()) != 0);
        // C s_519_33: const #5s : i
        let s_519_33: i128 = 5;
        // C s_519_34: const #1s : i
        let s_519_34: i128 = 1;
        // D s_519_35: read-var u#34503:u32
        let s_519_35: u32 = fn_state.u_34503;
        // D s_519_36: cast zx s_519_35 -> bv
        let s_519_36: Bits = Bits::new(s_519_35 as u128, 32u16);
        // D s_519_37: bit-extract s_519_36 s_519_33 s_519_34
        let s_519_37: Bits = (Bits::new(
            ((s_519_36) >> (s_519_33)).value(),
            u16::try_from(s_519_34).unwrap(),
        ));
        // D s_519_38: cast reint s_519_37 -> u8
        let s_519_38: bool = ((s_519_37.value()) != 0);
        // C s_519_39: const #4s : i
        let s_519_39: i128 = 4;
        // C s_519_40: const #1s : i
        let s_519_40: i128 = 1;
        // D s_519_41: read-var u#34503:u32
        let s_519_41: u32 = fn_state.u_34503;
        // D s_519_42: cast zx s_519_41 -> bv
        let s_519_42: Bits = Bits::new(s_519_41 as u128, 32u16);
        // D s_519_43: bit-extract s_519_42 s_519_39 s_519_40
        let s_519_43: Bits = (Bits::new(
            ((s_519_42) >> (s_519_39)).value(),
            u16::try_from(s_519_40).unwrap(),
        ));
        // D s_519_44: cast reint s_519_43 -> u8
        let s_519_44: bool = ((s_519_43.value()) != 0);
        // C s_519_45: const #0s : i
        let s_519_45: i128 = 0;
        // C s_519_46: const #4s : i
        let s_519_46: i128 = 4;
        // D s_519_47: read-var u#34503:u32
        let s_519_47: u32 = fn_state.u_34503;
        // D s_519_48: cast zx s_519_47 -> bv
        let s_519_48: Bits = Bits::new(s_519_47 as u128, 32u16);
        // D s_519_49: bit-extract s_519_48 s_519_45 s_519_46
        let s_519_49: Bits = (Bits::new(
            ((s_519_48) >> (s_519_45)).value(),
            u16::try_from(s_519_46).unwrap(),
        ));
        // D s_519_50: cast reint s_519_49 -> u8
        let s_519_50: u8 = (s_519_49.value() as u8);
        // D s_519_51: call decode_aarch32_instrs_MMLA_A1enc_A_txt(s_519_8, s_519_14, s_519_20, s_519_26, s_519_32, s_519_38, s_519_44, s_519_50)
        let s_519_51: () = decode_aarch32_instrs_MMLA_A1enc_A_txt(
            state,
            tracer,
            s_519_8,
            s_519_14,
            s_519_20,
            s_519_26,
            s_519_32,
            s_519_38,
            s_519_44,
            s_519_50,
        );
        // N s_519_52: return
        return;
    }
    fn block_520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_520_0: read-var merge#var.1:struct
        let s_520_0: u32 = fn_state.merge_var._1;
        // D s_520_1: write-var u#34513 <= s_520_0
        fn_state.u_34513 = s_520_0;
        // C s_520_2: const #23s : i
        let s_520_2: i128 = 23;
        // D s_520_3: read-var u#34513:u32
        let s_520_3: u32 = fn_state.u_34513;
        // D s_520_4: cast zx s_520_3 -> bv
        let s_520_4: Bits = Bits::new(s_520_3 as u128, 32u16);
        // C s_520_5: const #1s : i64
        let s_520_5: i64 = 1;
        // C s_520_6: cast zx s_520_5 -> i
        let s_520_6: i128 = (i128::try_from(s_520_5).unwrap());
        // C s_520_7: const #8s : i
        let s_520_7: i128 = 8;
        // C s_520_8: add s_520_7 s_520_6
        let s_520_8: i128 = (s_520_7 + s_520_6);
        // D s_520_9: bit-extract s_520_4 s_520_2 s_520_8
        let s_520_9: Bits = (Bits::new(
            ((s_520_4) >> (s_520_2)).value(),
            u16::try_from(s_520_8).unwrap(),
        ));
        // D s_520_10: cast reint s_520_9 -> u9
        let s_520_10: u16 = (s_520_9.value() as u16);
        // D s_520_11: cast zx s_520_10 -> bv
        let s_520_11: Bits = Bits::new(s_520_10 as u128, 9u16);
        // C s_520_12: const #505u : u9
        let s_520_12: u16 = 505;
        // C s_520_13: cast zx s_520_12 -> bv
        let s_520_13: Bits = Bits::new(s_520_12 as u128, 9u16);
        // D s_520_14: cmp-eq s_520_11 s_520_13
        let s_520_14: bool = ((s_520_11) == (s_520_13));
        // N s_520_15: branch s_520_14 b539 b521
        if s_520_14 {
            return block_539(state, tracer, fn_state);
        } else {
            return block_521(state, tracer, fn_state);
        };
    }
    fn block_521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_521_0: const #0u : u8
        let s_521_0: bool = false;
        // D s_521_1: write-var gs#414019 <= s_521_0
        fn_state.gs_414019 = s_521_0;
        // N s_521_2: jump b522
        return block_522(state, tracer, fn_state);
    }
    fn block_522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_522_0: read-var gs#414019:u8
        let s_522_0: bool = fn_state.gs_414019;
        // N s_522_1: branch s_522_0 b538 b523
        if s_522_0 {
            return block_538(state, tracer, fn_state);
        } else {
            return block_523(state, tracer, fn_state);
        };
    }
    fn block_523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_523_0: const #0u : u8
        let s_523_0: bool = false;
        // D s_523_1: write-var gs#414021 <= s_523_0
        fn_state.gs_414021 = s_523_0;
        // N s_523_2: jump b524
        return block_524(state, tracer, fn_state);
    }
    fn block_524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_524_0: read-var gs#414021:u8
        let s_524_0: bool = fn_state.gs_414021;
        // D s_524_1: not s_524_0
        let s_524_1: bool = !s_524_0;
        // N s_524_2: branch s_524_1 b526 b525
        if s_524_1 {
            return block_526(state, tracer, fn_state);
        } else {
            return block_525(state, tracer, fn_state);
        };
    }
    fn block_525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_525_0: const #3934s : i
        let s_525_0: i128 = 3934;
        // C s_525_1: const #14696u : u32
        let s_525_1: u32 = 14696;
        // N s_525_2: write-reg s_525_1 <= s_525_0
        let s_525_2: () = {
            state.write_register::<i128>(s_525_1 as isize, s_525_0);
            tracer.write_register(s_525_1 as isize, s_525_0);
        };
        // C s_525_3: const #22s : i
        let s_525_3: i128 = 22;
        // C s_525_4: const #1s : i
        let s_525_4: i128 = 1;
        // D s_525_5: read-var u#34513:u32
        let s_525_5: u32 = fn_state.u_34513;
        // D s_525_6: cast zx s_525_5 -> bv
        let s_525_6: Bits = Bits::new(s_525_5 as u128, 32u16);
        // D s_525_7: bit-extract s_525_6 s_525_3 s_525_4
        let s_525_7: Bits = (Bits::new(
            ((s_525_6) >> (s_525_3)).value(),
            u16::try_from(s_525_4).unwrap(),
        ));
        // D s_525_8: cast reint s_525_7 -> u8
        let s_525_8: bool = ((s_525_7.value()) != 0);
        // C s_525_9: const #16s : i
        let s_525_9: i128 = 16;
        // C s_525_10: const #4s : i
        let s_525_10: i128 = 4;
        // D s_525_11: read-var u#34513:u32
        let s_525_11: u32 = fn_state.u_34513;
        // D s_525_12: cast zx s_525_11 -> bv
        let s_525_12: Bits = Bits::new(s_525_11 as u128, 32u16);
        // D s_525_13: bit-extract s_525_12 s_525_9 s_525_10
        let s_525_13: Bits = (Bits::new(
            ((s_525_12) >> (s_525_9)).value(),
            u16::try_from(s_525_10).unwrap(),
        ));
        // D s_525_14: cast reint s_525_13 -> u8
        let s_525_14: u8 = (s_525_13.value() as u8);
        // C s_525_15: const #12s : i
        let s_525_15: i128 = 12;
        // C s_525_16: const #4s : i
        let s_525_16: i128 = 4;
        // D s_525_17: read-var u#34513:u32
        let s_525_17: u32 = fn_state.u_34513;
        // D s_525_18: cast zx s_525_17 -> bv
        let s_525_18: Bits = Bits::new(s_525_17 as u128, 32u16);
        // D s_525_19: bit-extract s_525_18 s_525_15 s_525_16
        let s_525_19: Bits = (Bits::new(
            ((s_525_18) >> (s_525_15)).value(),
            u16::try_from(s_525_16).unwrap(),
        ));
        // D s_525_20: cast reint s_525_19 -> u8
        let s_525_20: u8 = (s_525_19.value() as u8);
        // C s_525_21: const #7s : i
        let s_525_21: i128 = 7;
        // C s_525_22: const #1s : i
        let s_525_22: i128 = 1;
        // D s_525_23: read-var u#34513:u32
        let s_525_23: u32 = fn_state.u_34513;
        // D s_525_24: cast zx s_525_23 -> bv
        let s_525_24: Bits = Bits::new(s_525_23 as u128, 32u16);
        // D s_525_25: bit-extract s_525_24 s_525_21 s_525_22
        let s_525_25: Bits = (Bits::new(
            ((s_525_24) >> (s_525_21)).value(),
            u16::try_from(s_525_22).unwrap(),
        ));
        // D s_525_26: cast reint s_525_25 -> u8
        let s_525_26: bool = ((s_525_25.value()) != 0);
        // C s_525_27: const #6s : i
        let s_525_27: i128 = 6;
        // C s_525_28: const #1s : i
        let s_525_28: i128 = 1;
        // D s_525_29: read-var u#34513:u32
        let s_525_29: u32 = fn_state.u_34513;
        // D s_525_30: cast zx s_525_29 -> bv
        let s_525_30: Bits = Bits::new(s_525_29 as u128, 32u16);
        // D s_525_31: bit-extract s_525_30 s_525_27 s_525_28
        let s_525_31: Bits = (Bits::new(
            ((s_525_30) >> (s_525_27)).value(),
            u16::try_from(s_525_28).unwrap(),
        ));
        // D s_525_32: cast reint s_525_31 -> u8
        let s_525_32: bool = ((s_525_31.value()) != 0);
        // C s_525_33: const #5s : i
        let s_525_33: i128 = 5;
        // C s_525_34: const #1s : i
        let s_525_34: i128 = 1;
        // D s_525_35: read-var u#34513:u32
        let s_525_35: u32 = fn_state.u_34513;
        // D s_525_36: cast zx s_525_35 -> bv
        let s_525_36: Bits = Bits::new(s_525_35 as u128, 32u16);
        // D s_525_37: bit-extract s_525_36 s_525_33 s_525_34
        let s_525_37: Bits = (Bits::new(
            ((s_525_36) >> (s_525_33)).value(),
            u16::try_from(s_525_34).unwrap(),
        ));
        // D s_525_38: cast reint s_525_37 -> u8
        let s_525_38: bool = ((s_525_37.value()) != 0);
        // C s_525_39: const #0s : i
        let s_525_39: i128 = 0;
        // C s_525_40: const #4s : i
        let s_525_40: i128 = 4;
        // D s_525_41: read-var u#34513:u32
        let s_525_41: u32 = fn_state.u_34513;
        // D s_525_42: cast zx s_525_41 -> bv
        let s_525_42: Bits = Bits::new(s_525_41 as u128, 32u16);
        // D s_525_43: bit-extract s_525_42 s_525_39 s_525_40
        let s_525_43: Bits = (Bits::new(
            ((s_525_42) >> (s_525_39)).value(),
            u16::try_from(s_525_40).unwrap(),
        ));
        // D s_525_44: cast reint s_525_43 -> u8
        let s_525_44: u8 = (s_525_43.value() as u8);
        // D s_525_45: call decode_aarch32_instrs_VUSDOT_A1enc_A_txt(s_525_8, s_525_14, s_525_20, s_525_26, s_525_32, s_525_38, s_525_44)
        let s_525_45: () = decode_aarch32_instrs_VUSDOT_A1enc_A_txt(
            state,
            tracer,
            s_525_8,
            s_525_14,
            s_525_20,
            s_525_26,
            s_525_32,
            s_525_38,
            s_525_44,
        );
        // N s_525_46: return
        return;
    }
    fn block_526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_526_0: read-var merge#var.1:struct
        let s_526_0: u32 = fn_state.merge_var._1;
        // D s_526_1: write-var u#34522 <= s_526_0
        fn_state.u_34522 = s_526_0;
        // C s_526_2: const #23s : i
        let s_526_2: i128 = 23;
        // D s_526_3: read-var u#34522:u32
        let s_526_3: u32 = fn_state.u_34522;
        // D s_526_4: cast zx s_526_3 -> bv
        let s_526_4: Bits = Bits::new(s_526_3 as u128, 32u16);
        // C s_526_5: const #1s : i64
        let s_526_5: i64 = 1;
        // C s_526_6: cast zx s_526_5 -> i
        let s_526_6: i128 = (i128::try_from(s_526_5).unwrap());
        // C s_526_7: const #8s : i
        let s_526_7: i128 = 8;
        // C s_526_8: add s_526_7 s_526_6
        let s_526_8: i128 = (s_526_7 + s_526_6);
        // D s_526_9: bit-extract s_526_4 s_526_2 s_526_8
        let s_526_9: Bits = (Bits::new(
            ((s_526_4) >> (s_526_2)).value(),
            u16::try_from(s_526_8).unwrap(),
        ));
        // D s_526_10: cast reint s_526_9 -> u9
        let s_526_10: u16 = (s_526_9.value() as u16);
        // D s_526_11: cast zx s_526_10 -> bv
        let s_526_11: Bits = Bits::new(s_526_10 as u128, 9u16);
        // C s_526_12: const #509u : u9
        let s_526_12: u16 = 509;
        // C s_526_13: cast zx s_526_12 -> bv
        let s_526_13: Bits = Bits::new(s_526_12 as u128, 9u16);
        // D s_526_14: cmp-eq s_526_11 s_526_13
        let s_526_14: bool = ((s_526_11) == (s_526_13));
        // N s_526_15: branch s_526_14 b534 b527
        if s_526_14 {
            return block_534(state, tracer, fn_state);
        } else {
            return block_527(state, tracer, fn_state);
        };
    }
    fn block_527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_527_0: const #0u : u8
        let s_527_0: bool = false;
        // D s_527_1: write-var gs#414046 <= s_527_0
        fn_state.gs_414046 = s_527_0;
        // N s_527_2: jump b528
        return block_528(state, tracer, fn_state);
    }
    fn block_528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_528_0: read-var gs#414046:u8
        let s_528_0: bool = fn_state.gs_414046;
        // N s_528_1: branch s_528_0 b533 b529
        if s_528_0 {
            return block_533(state, tracer, fn_state);
        } else {
            return block_529(state, tracer, fn_state);
        };
    }
    fn block_529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_529_0: const #0u : u8
        let s_529_0: bool = false;
        // D s_529_1: write-var gs#414048 <= s_529_0
        fn_state.gs_414048 = s_529_0;
        // N s_529_2: jump b530
        return block_530(state, tracer, fn_state);
    }
    fn block_530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_530_0: read-var gs#414048:u8
        let s_530_0: bool = fn_state.gs_414048;
        // D s_530_1: not s_530_0
        let s_530_1: bool = !s_530_0;
        // N s_530_2: branch s_530_1 b532 b531
        if s_530_1 {
            return block_532(state, tracer, fn_state);
        } else {
            return block_531(state, tracer, fn_state);
        };
    }
    fn block_531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_531_0: const #3936s : i
        let s_531_0: i128 = 3936;
        // C s_531_1: const #14696u : u32
        let s_531_1: u32 = 14696;
        // N s_531_2: write-reg s_531_1 <= s_531_0
        let s_531_2: () = {
            state.write_register::<i128>(s_531_1 as isize, s_531_0);
            tracer.write_register(s_531_1 as isize, s_531_0);
        };
        // C s_531_3: const #22s : i
        let s_531_3: i128 = 22;
        // C s_531_4: const #1s : i
        let s_531_4: i128 = 1;
        // D s_531_5: read-var u#34522:u32
        let s_531_5: u32 = fn_state.u_34522;
        // D s_531_6: cast zx s_531_5 -> bv
        let s_531_6: Bits = Bits::new(s_531_5 as u128, 32u16);
        // D s_531_7: bit-extract s_531_6 s_531_3 s_531_4
        let s_531_7: Bits = (Bits::new(
            ((s_531_6) >> (s_531_3)).value(),
            u16::try_from(s_531_4).unwrap(),
        ));
        // D s_531_8: cast reint s_531_7 -> u8
        let s_531_8: bool = ((s_531_7.value()) != 0);
        // C s_531_9: const #16s : i
        let s_531_9: i128 = 16;
        // C s_531_10: const #4s : i
        let s_531_10: i128 = 4;
        // D s_531_11: read-var u#34522:u32
        let s_531_11: u32 = fn_state.u_34522;
        // D s_531_12: cast zx s_531_11 -> bv
        let s_531_12: Bits = Bits::new(s_531_11 as u128, 32u16);
        // D s_531_13: bit-extract s_531_12 s_531_9 s_531_10
        let s_531_13: Bits = (Bits::new(
            ((s_531_12) >> (s_531_9)).value(),
            u16::try_from(s_531_10).unwrap(),
        ));
        // D s_531_14: cast reint s_531_13 -> u8
        let s_531_14: u8 = (s_531_13.value() as u8);
        // C s_531_15: const #12s : i
        let s_531_15: i128 = 12;
        // C s_531_16: const #4s : i
        let s_531_16: i128 = 4;
        // D s_531_17: read-var u#34522:u32
        let s_531_17: u32 = fn_state.u_34522;
        // D s_531_18: cast zx s_531_17 -> bv
        let s_531_18: Bits = Bits::new(s_531_17 as u128, 32u16);
        // D s_531_19: bit-extract s_531_18 s_531_15 s_531_16
        let s_531_19: Bits = (Bits::new(
            ((s_531_18) >> (s_531_15)).value(),
            u16::try_from(s_531_16).unwrap(),
        ));
        // D s_531_20: cast reint s_531_19 -> u8
        let s_531_20: u8 = (s_531_19.value() as u8);
        // C s_531_21: const #7s : i
        let s_531_21: i128 = 7;
        // C s_531_22: const #1s : i
        let s_531_22: i128 = 1;
        // D s_531_23: read-var u#34522:u32
        let s_531_23: u32 = fn_state.u_34522;
        // D s_531_24: cast zx s_531_23 -> bv
        let s_531_24: Bits = Bits::new(s_531_23 as u128, 32u16);
        // D s_531_25: bit-extract s_531_24 s_531_21 s_531_22
        let s_531_25: Bits = (Bits::new(
            ((s_531_24) >> (s_531_21)).value(),
            u16::try_from(s_531_22).unwrap(),
        ));
        // D s_531_26: cast reint s_531_25 -> u8
        let s_531_26: bool = ((s_531_25.value()) != 0);
        // C s_531_27: const #6s : i
        let s_531_27: i128 = 6;
        // C s_531_28: const #1s : i
        let s_531_28: i128 = 1;
        // D s_531_29: read-var u#34522:u32
        let s_531_29: u32 = fn_state.u_34522;
        // D s_531_30: cast zx s_531_29 -> bv
        let s_531_30: Bits = Bits::new(s_531_29 as u128, 32u16);
        // D s_531_31: bit-extract s_531_30 s_531_27 s_531_28
        let s_531_31: Bits = (Bits::new(
            ((s_531_30) >> (s_531_27)).value(),
            u16::try_from(s_531_28).unwrap(),
        ));
        // D s_531_32: cast reint s_531_31 -> u8
        let s_531_32: bool = ((s_531_31.value()) != 0);
        // C s_531_33: const #5s : i
        let s_531_33: i128 = 5;
        // C s_531_34: const #1s : i
        let s_531_34: i128 = 1;
        // D s_531_35: read-var u#34522:u32
        let s_531_35: u32 = fn_state.u_34522;
        // D s_531_36: cast zx s_531_35 -> bv
        let s_531_36: Bits = Bits::new(s_531_35 as u128, 32u16);
        // D s_531_37: bit-extract s_531_36 s_531_33 s_531_34
        let s_531_37: Bits = (Bits::new(
            ((s_531_36) >> (s_531_33)).value(),
            u16::try_from(s_531_34).unwrap(),
        ));
        // D s_531_38: cast reint s_531_37 -> u8
        let s_531_38: bool = ((s_531_37.value()) != 0);
        // C s_531_39: const #4s : i
        let s_531_39: i128 = 4;
        // C s_531_40: const #1s : i
        let s_531_40: i128 = 1;
        // D s_531_41: read-var u#34522:u32
        let s_531_41: u32 = fn_state.u_34522;
        // D s_531_42: cast zx s_531_41 -> bv
        let s_531_42: Bits = Bits::new(s_531_41 as u128, 32u16);
        // D s_531_43: bit-extract s_531_42 s_531_39 s_531_40
        let s_531_43: Bits = (Bits::new(
            ((s_531_42) >> (s_531_39)).value(),
            u16::try_from(s_531_40).unwrap(),
        ));
        // D s_531_44: cast reint s_531_43 -> u8
        let s_531_44: bool = ((s_531_43.value()) != 0);
        // C s_531_45: const #0s : i
        let s_531_45: i128 = 0;
        // C s_531_46: const #4s : i
        let s_531_46: i128 = 4;
        // D s_531_47: read-var u#34522:u32
        let s_531_47: u32 = fn_state.u_34522;
        // D s_531_48: cast zx s_531_47 -> bv
        let s_531_48: Bits = Bits::new(s_531_47 as u128, 32u16);
        // D s_531_49: bit-extract s_531_48 s_531_45 s_531_46
        let s_531_49: Bits = (Bits::new(
            ((s_531_48) >> (s_531_45)).value(),
            u16::try_from(s_531_46).unwrap(),
        ));
        // D s_531_50: cast reint s_531_49 -> u8
        let s_531_50: u8 = (s_531_49.value() as u8);
        // D s_531_51: call decode_aarch32_instrs_DOT_A1enc_A_txt(s_531_8, s_531_14, s_531_20, s_531_26, s_531_32, s_531_38, s_531_44, s_531_50)
        let s_531_51: () = decode_aarch32_instrs_DOT_A1enc_A_txt(
            state,
            tracer,
            s_531_8,
            s_531_14,
            s_531_20,
            s_531_26,
            s_531_32,
            s_531_38,
            s_531_44,
            s_531_50,
        );
        // N s_531_52: return
        return;
    }
    fn block_532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_532_0: panic
        panic!("{:?}", ());
        // N s_532_1: return
        return;
    }
    fn block_533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_533_0: const #3936s : i
        let s_533_0: i128 = 3936;
        // C s_533_1: const #14696u : u32
        let s_533_1: u32 = 14696;
        // D s_533_2: read-reg s_533_1:i
        let s_533_2: i128 = {
            let value = state.read_register::<i128>(s_533_1 as isize);
            tracer.read_register(s_533_1 as isize, value);
            value
        };
        // D s_533_3: cmp-lt s_533_2 s_533_0
        let s_533_3: bool = ((s_533_2) < (s_533_0));
        // D s_533_4: write-var gs#414048 <= s_533_3
        fn_state.gs_414048 = s_533_3;
        // N s_533_5: jump b530
        return block_530(state, tracer, fn_state);
    }
    fn block_534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_534_0: const #20s : i
        let s_534_0: i128 = 20;
        // D s_534_1: read-var u#34522:u32
        let s_534_1: u32 = fn_state.u_34522;
        // D s_534_2: cast zx s_534_1 -> bv
        let s_534_2: Bits = Bits::new(s_534_1 as u128, 32u16);
        // C s_534_3: const #1s : i64
        let s_534_3: i64 = 1;
        // C s_534_4: cast zx s_534_3 -> i
        let s_534_4: i128 = (i128::try_from(s_534_3).unwrap());
        // C s_534_5: const #1s : i
        let s_534_5: i128 = 1;
        // C s_534_6: add s_534_5 s_534_4
        let s_534_6: i128 = (s_534_5 + s_534_4);
        // D s_534_7: bit-extract s_534_2 s_534_0 s_534_6
        let s_534_7: Bits = (Bits::new(
            ((s_534_2) >> (s_534_0)).value(),
            u16::try_from(s_534_6).unwrap(),
        ));
        // D s_534_8: cast reint s_534_7 -> u8
        let s_534_8: u8 = (s_534_7.value() as u8);
        // D s_534_9: cast zx s_534_8 -> bv
        let s_534_9: Bits = Bits::new(s_534_8 as u128, 2u16);
        // C s_534_10: const #0u : u8
        let s_534_10: u8 = 0;
        // C s_534_11: cast zx s_534_10 -> bv
        let s_534_11: Bits = Bits::new(s_534_10 as u128, 2u16);
        // D s_534_12: cmp-eq s_534_9 s_534_11
        let s_534_12: bool = ((s_534_9) == (s_534_11));
        // N s_534_13: branch s_534_12 b537 b535
        if s_534_12 {
            return block_537(state, tracer, fn_state);
        } else {
            return block_535(state, tracer, fn_state);
        };
    }
    fn block_535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_535_0: const #0u : u8
        let s_535_0: bool = false;
        // D s_535_1: write-var gs#414045 <= s_535_0
        fn_state.gs_414045 = s_535_0;
        // N s_535_2: jump b536
        return block_536(state, tracer, fn_state);
    }
    fn block_536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_536_0: read-var gs#414045:u8
        let s_536_0: bool = fn_state.gs_414045;
        // D s_536_1: write-var gs#414046 <= s_536_0
        fn_state.gs_414046 = s_536_0;
        // N s_536_2: jump b528
        return block_528(state, tracer, fn_state);
    }
    fn block_537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_537_0: const #8s : i
        let s_537_0: i128 = 8;
        // D s_537_1: read-var u#34522:u32
        let s_537_1: u32 = fn_state.u_34522;
        // D s_537_2: cast zx s_537_1 -> bv
        let s_537_2: Bits = Bits::new(s_537_1 as u128, 32u16);
        // C s_537_3: const #1s : i64
        let s_537_3: i64 = 1;
        // C s_537_4: cast zx s_537_3 -> i
        let s_537_4: i128 = (i128::try_from(s_537_3).unwrap());
        // C s_537_5: const #3s : i
        let s_537_5: i128 = 3;
        // C s_537_6: add s_537_5 s_537_4
        let s_537_6: i128 = (s_537_5 + s_537_4);
        // D s_537_7: bit-extract s_537_2 s_537_0 s_537_6
        let s_537_7: Bits = (Bits::new(
            ((s_537_2) >> (s_537_0)).value(),
            u16::try_from(s_537_6).unwrap(),
        ));
        // D s_537_8: cast reint s_537_7 -> u8
        let s_537_8: u8 = (s_537_7.value() as u8);
        // D s_537_9: cast zx s_537_8 -> bv
        let s_537_9: Bits = Bits::new(s_537_8 as u128, 4u16);
        // C s_537_10: const #13u : u8
        let s_537_10: u8 = 13;
        // C s_537_11: cast zx s_537_10 -> bv
        let s_537_11: Bits = Bits::new(s_537_10 as u128, 4u16);
        // D s_537_12: cmp-eq s_537_9 s_537_11
        let s_537_12: bool = ((s_537_9) == (s_537_11));
        // D s_537_13: write-var gs#414045 <= s_537_12
        fn_state.gs_414045 = s_537_12;
        // N s_537_14: jump b536
        return block_536(state, tracer, fn_state);
    }
    fn block_538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_538_0: const #3934s : i
        let s_538_0: i128 = 3934;
        // C s_538_1: const #14696u : u32
        let s_538_1: u32 = 14696;
        // D s_538_2: read-reg s_538_1:i
        let s_538_2: i128 = {
            let value = state.read_register::<i128>(s_538_1 as isize);
            tracer.read_register(s_538_1 as isize, value);
            value
        };
        // D s_538_3: cmp-lt s_538_2 s_538_0
        let s_538_3: bool = ((s_538_2) < (s_538_0));
        // D s_538_4: write-var gs#414021 <= s_538_3
        fn_state.gs_414021 = s_538_3;
        // N s_538_5: jump b524
        return block_524(state, tracer, fn_state);
    }
    fn block_539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_539_0: const #20s : i
        let s_539_0: i128 = 20;
        // D s_539_1: read-var u#34513:u32
        let s_539_1: u32 = fn_state.u_34513;
        // D s_539_2: cast zx s_539_1 -> bv
        let s_539_2: Bits = Bits::new(s_539_1 as u128, 32u16);
        // C s_539_3: const #1s : i64
        let s_539_3: i64 = 1;
        // C s_539_4: cast zx s_539_3 -> i
        let s_539_4: i128 = (i128::try_from(s_539_3).unwrap());
        // C s_539_5: const #1s : i
        let s_539_5: i128 = 1;
        // C s_539_6: add s_539_5 s_539_4
        let s_539_6: i128 = (s_539_5 + s_539_4);
        // D s_539_7: bit-extract s_539_2 s_539_0 s_539_6
        let s_539_7: Bits = (Bits::new(
            ((s_539_2) >> (s_539_0)).value(),
            u16::try_from(s_539_6).unwrap(),
        ));
        // D s_539_8: cast reint s_539_7 -> u8
        let s_539_8: u8 = (s_539_7.value() as u8);
        // D s_539_9: cast zx s_539_8 -> bv
        let s_539_9: Bits = Bits::new(s_539_8 as u128, 2u16);
        // C s_539_10: const #2u : u8
        let s_539_10: u8 = 2;
        // C s_539_11: cast zx s_539_10 -> bv
        let s_539_11: Bits = Bits::new(s_539_10 as u128, 2u16);
        // D s_539_12: cmp-eq s_539_9 s_539_11
        let s_539_12: bool = ((s_539_9) == (s_539_11));
        // N s_539_13: branch s_539_12 b542 b540
        if s_539_12 {
            return block_542(state, tracer, fn_state);
        } else {
            return block_540(state, tracer, fn_state);
        };
    }
    fn block_540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_540_0: const #0u : u8
        let s_540_0: bool = false;
        // D s_540_1: write-var gs#414018 <= s_540_0
        fn_state.gs_414018 = s_540_0;
        // N s_540_2: jump b541
        return block_541(state, tracer, fn_state);
    }
    fn block_541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_541_0: read-var gs#414018:u8
        let s_541_0: bool = fn_state.gs_414018;
        // D s_541_1: write-var gs#414019 <= s_541_0
        fn_state.gs_414019 = s_541_0;
        // N s_541_2: jump b522
        return block_522(state, tracer, fn_state);
    }
    fn block_542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_542_0: const #8s : i
        let s_542_0: i128 = 8;
        // D s_542_1: read-var u#34513:u32
        let s_542_1: u32 = fn_state.u_34513;
        // D s_542_2: cast zx s_542_1 -> bv
        let s_542_2: Bits = Bits::new(s_542_1 as u128, 32u16);
        // C s_542_3: const #1s : i64
        let s_542_3: i64 = 1;
        // C s_542_4: cast zx s_542_3 -> i
        let s_542_4: i128 = (i128::try_from(s_542_3).unwrap());
        // C s_542_5: const #3s : i
        let s_542_5: i128 = 3;
        // C s_542_6: add s_542_5 s_542_4
        let s_542_6: i128 = (s_542_5 + s_542_4);
        // D s_542_7: bit-extract s_542_2 s_542_0 s_542_6
        let s_542_7: Bits = (Bits::new(
            ((s_542_2) >> (s_542_0)).value(),
            u16::try_from(s_542_6).unwrap(),
        ));
        // D s_542_8: cast reint s_542_7 -> u8
        let s_542_8: u8 = (s_542_7.value() as u8);
        // D s_542_9: cast zx s_542_8 -> bv
        let s_542_9: Bits = Bits::new(s_542_8 as u128, 4u16);
        // C s_542_10: const #13u : u8
        let s_542_10: u8 = 13;
        // C s_542_11: cast zx s_542_10 -> bv
        let s_542_11: Bits = Bits::new(s_542_10 as u128, 4u16);
        // D s_542_12: cmp-eq s_542_9 s_542_11
        let s_542_12: bool = ((s_542_9) == (s_542_11));
        // N s_542_13: branch s_542_12 b545 b543
        if s_542_12 {
            return block_545(state, tracer, fn_state);
        } else {
            return block_543(state, tracer, fn_state);
        };
    }
    fn block_543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_543_0: const #0u : u8
        let s_543_0: bool = false;
        // D s_543_1: write-var gs#414017 <= s_543_0
        fn_state.gs_414017 = s_543_0;
        // N s_543_2: jump b544
        return block_544(state, tracer, fn_state);
    }
    fn block_544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_544_0: read-var gs#414017:u8
        let s_544_0: bool = fn_state.gs_414017;
        // D s_544_1: write-var gs#414018 <= s_544_0
        fn_state.gs_414018 = s_544_0;
        // N s_544_2: jump b541
        return block_541(state, tracer, fn_state);
    }
    fn block_545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_545_0: const #4s : i
        let s_545_0: i128 = 4;
        // D s_545_1: read-var u#34513:u32
        let s_545_1: u32 = fn_state.u_34513;
        // D s_545_2: cast zx s_545_1 -> bv
        let s_545_2: Bits = Bits::new(s_545_1 as u128, 32u16);
        // C s_545_3: const #1s : i64
        let s_545_3: i64 = 1;
        // C s_545_4: cast zx s_545_3 -> i
        let s_545_4: i128 = (i128::try_from(s_545_3).unwrap());
        // C s_545_5: const #0s : i
        let s_545_5: i128 = 0;
        // C s_545_6: add s_545_5 s_545_4
        let s_545_6: i128 = (s_545_5 + s_545_4);
        // D s_545_7: bit-extract s_545_2 s_545_0 s_545_6
        let s_545_7: Bits = (Bits::new(
            ((s_545_2) >> (s_545_0)).value(),
            u16::try_from(s_545_6).unwrap(),
        ));
        // D s_545_8: cast reint s_545_7 -> u8
        let s_545_8: bool = ((s_545_7.value()) != 0);
        // D s_545_9: cast zx s_545_8 -> bv
        let s_545_9: Bits = Bits::new(s_545_8 as u128, 1u16);
        // C s_545_10: const #0u : u8
        let s_545_10: bool = false;
        // C s_545_11: cast zx s_545_10 -> bv
        let s_545_11: Bits = Bits::new(s_545_10 as u128, 1u16);
        // D s_545_12: cmp-eq s_545_9 s_545_11
        let s_545_12: bool = ((s_545_9) == (s_545_11));
        // D s_545_13: write-var gs#414017 <= s_545_12
        fn_state.gs_414017 = s_545_12;
        // N s_545_14: jump b544
        return block_544(state, tracer, fn_state);
    }
    fn block_546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_546_0: const #3932s : i
        let s_546_0: i128 = 3932;
        // C s_546_1: const #14696u : u32
        let s_546_1: u32 = 14696;
        // D s_546_2: read-reg s_546_1:i
        let s_546_2: i128 = {
            let value = state.read_register::<i128>(s_546_1 as isize);
            tracer.read_register(s_546_1 as isize, value);
            value
        };
        // D s_546_3: cmp-lt s_546_2 s_546_0
        let s_546_3: bool = ((s_546_2) < (s_546_0));
        // D s_546_4: write-var gs#413989 <= s_546_3
        fn_state.gs_413989 = s_546_3;
        // N s_546_5: jump b518
        return block_518(state, tracer, fn_state);
    }
    fn block_547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_547_0: const #20s : i
        let s_547_0: i128 = 20;
        // D s_547_1: read-var u#34503:u32
        let s_547_1: u32 = fn_state.u_34503;
        // D s_547_2: cast zx s_547_1 -> bv
        let s_547_2: Bits = Bits::new(s_547_1 as u128, 32u16);
        // C s_547_3: const #1s : i64
        let s_547_3: i64 = 1;
        // C s_547_4: cast zx s_547_3 -> i
        let s_547_4: i128 = (i128::try_from(s_547_3).unwrap());
        // C s_547_5: const #1s : i
        let s_547_5: i128 = 1;
        // C s_547_6: add s_547_5 s_547_4
        let s_547_6: i128 = (s_547_5 + s_547_4);
        // D s_547_7: bit-extract s_547_2 s_547_0 s_547_6
        let s_547_7: Bits = (Bits::new(
            ((s_547_2) >> (s_547_0)).value(),
            u16::try_from(s_547_6).unwrap(),
        ));
        // D s_547_8: cast reint s_547_7 -> u8
        let s_547_8: u8 = (s_547_7.value() as u8);
        // D s_547_9: cast zx s_547_8 -> bv
        let s_547_9: Bits = Bits::new(s_547_8 as u128, 2u16);
        // C s_547_10: const #2u : u8
        let s_547_10: u8 = 2;
        // C s_547_11: cast zx s_547_10 -> bv
        let s_547_11: Bits = Bits::new(s_547_10 as u128, 2u16);
        // D s_547_12: cmp-eq s_547_9 s_547_11
        let s_547_12: bool = ((s_547_9) == (s_547_11));
        // N s_547_13: branch s_547_12 b550 b548
        if s_547_12 {
            return block_550(state, tracer, fn_state);
        } else {
            return block_548(state, tracer, fn_state);
        };
    }
    fn block_548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_548_0: const #0u : u8
        let s_548_0: bool = false;
        // D s_548_1: write-var gs#413986 <= s_548_0
        fn_state.gs_413986 = s_548_0;
        // N s_548_2: jump b549
        return block_549(state, tracer, fn_state);
    }
    fn block_549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_549_0: read-var gs#413986:u8
        let s_549_0: bool = fn_state.gs_413986;
        // D s_549_1: write-var gs#413987 <= s_549_0
        fn_state.gs_413987 = s_549_0;
        // N s_549_2: jump b516
        return block_516(state, tracer, fn_state);
    }
    fn block_550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_550_0: const #8s : i
        let s_550_0: i128 = 8;
        // D s_550_1: read-var u#34503:u32
        let s_550_1: u32 = fn_state.u_34503;
        // D s_550_2: cast zx s_550_1 -> bv
        let s_550_2: Bits = Bits::new(s_550_1 as u128, 32u16);
        // C s_550_3: const #1s : i64
        let s_550_3: i64 = 1;
        // C s_550_4: cast zx s_550_3 -> i
        let s_550_4: i128 = (i128::try_from(s_550_3).unwrap());
        // C s_550_5: const #3s : i
        let s_550_5: i128 = 3;
        // C s_550_6: add s_550_5 s_550_4
        let s_550_6: i128 = (s_550_5 + s_550_4);
        // D s_550_7: bit-extract s_550_2 s_550_0 s_550_6
        let s_550_7: Bits = (Bits::new(
            ((s_550_2) >> (s_550_0)).value(),
            u16::try_from(s_550_6).unwrap(),
        ));
        // D s_550_8: cast reint s_550_7 -> u8
        let s_550_8: u8 = (s_550_7.value() as u8);
        // D s_550_9: cast zx s_550_8 -> bv
        let s_550_9: Bits = Bits::new(s_550_8 as u128, 4u16);
        // C s_550_10: const #12u : u8
        let s_550_10: u8 = 12;
        // C s_550_11: cast zx s_550_10 -> bv
        let s_550_11: Bits = Bits::new(s_550_10 as u128, 4u16);
        // D s_550_12: cmp-eq s_550_9 s_550_11
        let s_550_12: bool = ((s_550_9) == (s_550_11));
        // N s_550_13: branch s_550_12 b553 b551
        if s_550_12 {
            return block_553(state, tracer, fn_state);
        } else {
            return block_551(state, tracer, fn_state);
        };
    }
    fn block_551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_551_0: const #0u : u8
        let s_551_0: bool = false;
        // D s_551_1: write-var gs#413985 <= s_551_0
        fn_state.gs_413985 = s_551_0;
        // N s_551_2: jump b552
        return block_552(state, tracer, fn_state);
    }
    fn block_552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_552_0: read-var gs#413985:u8
        let s_552_0: bool = fn_state.gs_413985;
        // D s_552_1: write-var gs#413986 <= s_552_0
        fn_state.gs_413986 = s_552_0;
        // N s_552_2: jump b549
        return block_549(state, tracer, fn_state);
    }
    fn block_553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_553_0: const #6s : i
        let s_553_0: i128 = 6;
        // D s_553_1: read-var u#34503:u32
        let s_553_1: u32 = fn_state.u_34503;
        // D s_553_2: cast zx s_553_1 -> bv
        let s_553_2: Bits = Bits::new(s_553_1 as u128, 32u16);
        // C s_553_3: const #1s : i64
        let s_553_3: i64 = 1;
        // C s_553_4: cast zx s_553_3 -> i
        let s_553_4: i128 = (i128::try_from(s_553_3).unwrap());
        // C s_553_5: const #0s : i
        let s_553_5: i128 = 0;
        // C s_553_6: add s_553_5 s_553_4
        let s_553_6: i128 = (s_553_5 + s_553_4);
        // D s_553_7: bit-extract s_553_2 s_553_0 s_553_6
        let s_553_7: Bits = (Bits::new(
            ((s_553_2) >> (s_553_0)).value(),
            u16::try_from(s_553_6).unwrap(),
        ));
        // D s_553_8: cast reint s_553_7 -> u8
        let s_553_8: bool = ((s_553_7.value()) != 0);
        // D s_553_9: cast zx s_553_8 -> bv
        let s_553_9: Bits = Bits::new(s_553_8 as u128, 1u16);
        // C s_553_10: const #1u : u8
        let s_553_10: bool = true;
        // C s_553_11: cast zx s_553_10 -> bv
        let s_553_11: Bits = Bits::new(s_553_10 as u128, 1u16);
        // D s_553_12: cmp-eq s_553_9 s_553_11
        let s_553_12: bool = ((s_553_9) == (s_553_11));
        // D s_553_13: write-var gs#413985 <= s_553_12
        fn_state.gs_413985 = s_553_12;
        // N s_553_14: jump b552
        return block_552(state, tracer, fn_state);
    }
    fn block_554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_554_0: const #3930s : i
        let s_554_0: i128 = 3930;
        // C s_554_1: const #14696u : u32
        let s_554_1: u32 = 14696;
        // D s_554_2: read-reg s_554_1:i
        let s_554_2: i128 = {
            let value = state.read_register::<i128>(s_554_1 as isize);
            tracer.read_register(s_554_1 as isize, value);
            value
        };
        // D s_554_3: cmp-lt s_554_2 s_554_0
        let s_554_3: bool = ((s_554_2) < (s_554_0));
        // D s_554_4: write-var gs#413959 <= s_554_3
        fn_state.gs_413959 = s_554_3;
        // N s_554_5: jump b512
        return block_512(state, tracer, fn_state);
    }
    fn block_555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_555_0: const #20s : i
        let s_555_0: i128 = 20;
        // D s_555_1: read-var u#34494:u32
        let s_555_1: u32 = fn_state.u_34494;
        // D s_555_2: cast zx s_555_1 -> bv
        let s_555_2: Bits = Bits::new(s_555_1 as u128, 32u16);
        // C s_555_3: const #1s : i64
        let s_555_3: i64 = 1;
        // C s_555_4: cast zx s_555_3 -> i
        let s_555_4: i128 = (i128::try_from(s_555_3).unwrap());
        // C s_555_5: const #1s : i
        let s_555_5: i128 = 1;
        // C s_555_6: add s_555_5 s_555_4
        let s_555_6: i128 = (s_555_5 + s_555_4);
        // D s_555_7: bit-extract s_555_2 s_555_0 s_555_6
        let s_555_7: Bits = (Bits::new(
            ((s_555_2) >> (s_555_0)).value(),
            u16::try_from(s_555_6).unwrap(),
        ));
        // D s_555_8: cast reint s_555_7 -> u8
        let s_555_8: u8 = (s_555_7.value() as u8);
        // D s_555_9: cast zx s_555_8 -> bv
        let s_555_9: Bits = Bits::new(s_555_8 as u128, 2u16);
        // C s_555_10: const #3u : u8
        let s_555_10: u8 = 3;
        // C s_555_11: cast zx s_555_10 -> bv
        let s_555_11: Bits = Bits::new(s_555_10 as u128, 2u16);
        // D s_555_12: cmp-eq s_555_9 s_555_11
        let s_555_12: bool = ((s_555_9) == (s_555_11));
        // N s_555_13: branch s_555_12 b558 b556
        if s_555_12 {
            return block_558(state, tracer, fn_state);
        } else {
            return block_556(state, tracer, fn_state);
        };
    }
    fn block_556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_556_0: const #0u : u8
        let s_556_0: bool = false;
        // D s_556_1: write-var gs#413956 <= s_556_0
        fn_state.gs_413956 = s_556_0;
        // N s_556_2: jump b557
        return block_557(state, tracer, fn_state);
    }
    fn block_557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_557_0: read-var gs#413956:u8
        let s_557_0: bool = fn_state.gs_413956;
        // D s_557_1: write-var gs#413957 <= s_557_0
        fn_state.gs_413957 = s_557_0;
        // N s_557_2: jump b510
        return block_510(state, tracer, fn_state);
    }
    fn block_558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_558_0: const #8s : i
        let s_558_0: i128 = 8;
        // D s_558_1: read-var u#34494:u32
        let s_558_1: u32 = fn_state.u_34494;
        // D s_558_2: cast zx s_558_1 -> bv
        let s_558_2: Bits = Bits::new(s_558_1 as u128, 32u16);
        // C s_558_3: const #1s : i64
        let s_558_3: i64 = 1;
        // C s_558_4: cast zx s_558_3 -> i
        let s_558_4: i128 = (i128::try_from(s_558_3).unwrap());
        // C s_558_5: const #3s : i
        let s_558_5: i128 = 3;
        // C s_558_6: add s_558_5 s_558_4
        let s_558_6: i128 = (s_558_5 + s_558_4);
        // D s_558_7: bit-extract s_558_2 s_558_0 s_558_6
        let s_558_7: Bits = (Bits::new(
            ((s_558_2) >> (s_558_0)).value(),
            u16::try_from(s_558_6).unwrap(),
        ));
        // D s_558_8: cast reint s_558_7 -> u8
        let s_558_8: u8 = (s_558_7.value() as u8);
        // D s_558_9: cast zx s_558_8 -> bv
        let s_558_9: Bits = Bits::new(s_558_8 as u128, 4u16);
        // C s_558_10: const #8u : u8
        let s_558_10: u8 = 8;
        // C s_558_11: cast zx s_558_10 -> bv
        let s_558_11: Bits = Bits::new(s_558_10 as u128, 4u16);
        // D s_558_12: cmp-eq s_558_9 s_558_11
        let s_558_12: bool = ((s_558_9) == (s_558_11));
        // N s_558_13: branch s_558_12 b561 b559
        if s_558_12 {
            return block_561(state, tracer, fn_state);
        } else {
            return block_559(state, tracer, fn_state);
        };
    }
    fn block_559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_559_0: const #0u : u8
        let s_559_0: bool = false;
        // D s_559_1: write-var gs#413955 <= s_559_0
        fn_state.gs_413955 = s_559_0;
        // N s_559_2: jump b560
        return block_560(state, tracer, fn_state);
    }
    fn block_560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_560_0: read-var gs#413955:u8
        let s_560_0: bool = fn_state.gs_413955;
        // D s_560_1: write-var gs#413956 <= s_560_0
        fn_state.gs_413956 = s_560_0;
        // N s_560_2: jump b557
        return block_557(state, tracer, fn_state);
    }
    fn block_561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_561_0: const #4s : i
        let s_561_0: i128 = 4;
        // D s_561_1: read-var u#34494:u32
        let s_561_1: u32 = fn_state.u_34494;
        // D s_561_2: cast zx s_561_1 -> bv
        let s_561_2: Bits = Bits::new(s_561_1 as u128, 32u16);
        // C s_561_3: const #1s : i64
        let s_561_3: i64 = 1;
        // C s_561_4: cast zx s_561_3 -> i
        let s_561_4: i128 = (i128::try_from(s_561_3).unwrap());
        // C s_561_5: const #0s : i
        let s_561_5: i128 = 0;
        // C s_561_6: add s_561_5 s_561_4
        let s_561_6: i128 = (s_561_5 + s_561_4);
        // D s_561_7: bit-extract s_561_2 s_561_0 s_561_6
        let s_561_7: Bits = (Bits::new(
            ((s_561_2) >> (s_561_0)).value(),
            u16::try_from(s_561_6).unwrap(),
        ));
        // D s_561_8: cast reint s_561_7 -> u8
        let s_561_8: bool = ((s_561_7.value()) != 0);
        // D s_561_9: cast zx s_561_8 -> bv
        let s_561_9: Bits = Bits::new(s_561_8 as u128, 1u16);
        // C s_561_10: const #1u : u8
        let s_561_10: bool = true;
        // C s_561_11: cast zx s_561_10 -> bv
        let s_561_11: Bits = Bits::new(s_561_10 as u128, 1u16);
        // D s_561_12: cmp-eq s_561_9 s_561_11
        let s_561_12: bool = ((s_561_9) == (s_561_11));
        // D s_561_13: write-var gs#413955 <= s_561_12
        fn_state.gs_413955 = s_561_12;
        // N s_561_14: jump b560
        return block_560(state, tracer, fn_state);
    }
    fn block_562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_562_0: const #3928s : i
        let s_562_0: i128 = 3928;
        // C s_562_1: const #14696u : u32
        let s_562_1: u32 = 14696;
        // D s_562_2: read-reg s_562_1:i
        let s_562_2: i128 = {
            let value = state.read_register::<i128>(s_562_1 as isize);
            tracer.read_register(s_562_1 as isize, value);
            value
        };
        // D s_562_3: cmp-lt s_562_2 s_562_0
        let s_562_3: bool = ((s_562_2) < (s_562_0));
        // D s_562_4: write-var gs#413929 <= s_562_3
        fn_state.gs_413929 = s_562_3;
        // N s_562_5: jump b506
        return block_506(state, tracer, fn_state);
    }
    fn block_563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_563_0: const #20s : i
        let s_563_0: i128 = 20;
        // D s_563_1: read-var u#34485:u32
        let s_563_1: u32 = fn_state.u_34485;
        // D s_563_2: cast zx s_563_1 -> bv
        let s_563_2: Bits = Bits::new(s_563_1 as u128, 32u16);
        // C s_563_3: const #1s : i64
        let s_563_3: i64 = 1;
        // C s_563_4: cast zx s_563_3 -> i
        let s_563_4: i128 = (i128::try_from(s_563_3).unwrap());
        // C s_563_5: const #1s : i
        let s_563_5: i128 = 1;
        // C s_563_6: add s_563_5 s_563_4
        let s_563_6: i128 = (s_563_5 + s_563_4);
        // D s_563_7: bit-extract s_563_2 s_563_0 s_563_6
        let s_563_7: Bits = (Bits::new(
            ((s_563_2) >> (s_563_0)).value(),
            u16::try_from(s_563_6).unwrap(),
        ));
        // D s_563_8: cast reint s_563_7 -> u8
        let s_563_8: u8 = (s_563_7.value() as u8);
        // D s_563_9: cast zx s_563_8 -> bv
        let s_563_9: Bits = Bits::new(s_563_8 as u128, 2u16);
        // C s_563_10: const #3u : u8
        let s_563_10: u8 = 3;
        // C s_563_11: cast zx s_563_10 -> bv
        let s_563_11: Bits = Bits::new(s_563_10 as u128, 2u16);
        // D s_563_12: cmp-eq s_563_9 s_563_11
        let s_563_12: bool = ((s_563_9) == (s_563_11));
        // N s_563_13: branch s_563_12 b566 b564
        if s_563_12 {
            return block_566(state, tracer, fn_state);
        } else {
            return block_564(state, tracer, fn_state);
        };
    }
    fn block_564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_564_0: const #0u : u8
        let s_564_0: bool = false;
        // D s_564_1: write-var gs#413926 <= s_564_0
        fn_state.gs_413926 = s_564_0;
        // N s_564_2: jump b565
        return block_565(state, tracer, fn_state);
    }
    fn block_565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_565_0: read-var gs#413926:u8
        let s_565_0: bool = fn_state.gs_413926;
        // D s_565_1: write-var gs#413927 <= s_565_0
        fn_state.gs_413927 = s_565_0;
        // N s_565_2: jump b504
        return block_504(state, tracer, fn_state);
    }
    fn block_566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_566_0: const #8s : i
        let s_566_0: i128 = 8;
        // D s_566_1: read-var u#34485:u32
        let s_566_1: u32 = fn_state.u_34485;
        // D s_566_2: cast zx s_566_1 -> bv
        let s_566_2: Bits = Bits::new(s_566_1 as u128, 32u16);
        // C s_566_3: const #1s : i64
        let s_566_3: i64 = 1;
        // C s_566_4: cast zx s_566_3 -> i
        let s_566_4: i128 = (i128::try_from(s_566_3).unwrap());
        // C s_566_5: const #3s : i
        let s_566_5: i128 = 3;
        // C s_566_6: add s_566_5 s_566_4
        let s_566_6: i128 = (s_566_5 + s_566_4);
        // D s_566_7: bit-extract s_566_2 s_566_0 s_566_6
        let s_566_7: Bits = (Bits::new(
            ((s_566_2) >> (s_566_0)).value(),
            u16::try_from(s_566_6).unwrap(),
        ));
        // D s_566_8: cast reint s_566_7 -> u8
        let s_566_8: u8 = (s_566_7.value() as u8);
        // D s_566_9: cast zx s_566_8 -> bv
        let s_566_9: Bits = Bits::new(s_566_8 as u128, 4u16);
        // C s_566_10: const #8u : u8
        let s_566_10: u8 = 8;
        // C s_566_11: cast zx s_566_10 -> bv
        let s_566_11: Bits = Bits::new(s_566_10 as u128, 4u16);
        // D s_566_12: cmp-eq s_566_9 s_566_11
        let s_566_12: bool = ((s_566_9) == (s_566_11));
        // N s_566_13: branch s_566_12 b569 b567
        if s_566_12 {
            return block_569(state, tracer, fn_state);
        } else {
            return block_567(state, tracer, fn_state);
        };
    }
    fn block_567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_567_0: const #0u : u8
        let s_567_0: bool = false;
        // D s_567_1: write-var gs#413925 <= s_567_0
        fn_state.gs_413925 = s_567_0;
        // N s_567_2: jump b568
        return block_568(state, tracer, fn_state);
    }
    fn block_568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_568_0: read-var gs#413925:u8
        let s_568_0: bool = fn_state.gs_413925;
        // D s_568_1: write-var gs#413926 <= s_568_0
        fn_state.gs_413926 = s_568_0;
        // N s_568_2: jump b565
        return block_565(state, tracer, fn_state);
    }
    fn block_569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_569_0: const #4s : i
        let s_569_0: i128 = 4;
        // D s_569_1: read-var u#34485:u32
        let s_569_1: u32 = fn_state.u_34485;
        // D s_569_2: cast zx s_569_1 -> bv
        let s_569_2: Bits = Bits::new(s_569_1 as u128, 32u16);
        // C s_569_3: const #1s : i64
        let s_569_3: i64 = 1;
        // C s_569_4: cast zx s_569_3 -> i
        let s_569_4: i128 = (i128::try_from(s_569_3).unwrap());
        // C s_569_5: const #0s : i
        let s_569_5: i128 = 0;
        // C s_569_6: add s_569_5 s_569_4
        let s_569_6: i128 = (s_569_5 + s_569_4);
        // D s_569_7: bit-extract s_569_2 s_569_0 s_569_6
        let s_569_7: Bits = (Bits::new(
            ((s_569_2) >> (s_569_0)).value(),
            u16::try_from(s_569_6).unwrap(),
        ));
        // D s_569_8: cast reint s_569_7 -> u8
        let s_569_8: bool = ((s_569_7.value()) != 0);
        // D s_569_9: cast zx s_569_8 -> bv
        let s_569_9: Bits = Bits::new(s_569_8 as u128, 1u16);
        // C s_569_10: const #1u : u8
        let s_569_10: bool = true;
        // C s_569_11: cast zx s_569_10 -> bv
        let s_569_11: Bits = Bits::new(s_569_10 as u128, 1u16);
        // D s_569_12: cmp-eq s_569_9 s_569_11
        let s_569_12: bool = ((s_569_9) == (s_569_11));
        // D s_569_13: write-var gs#413925 <= s_569_12
        fn_state.gs_413925 = s_569_12;
        // N s_569_14: jump b568
        return block_568(state, tracer, fn_state);
    }
    fn block_570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_570_0: const #28s : i
        let s_570_0: i128 = 28;
        // C s_570_1: const #4s : i
        let s_570_1: i128 = 4;
        // D s_570_2: read-var u#34478:u32
        let s_570_2: u32 = fn_state.u_34478;
        // D s_570_3: cast zx s_570_2 -> bv
        let s_570_3: Bits = Bits::new(s_570_2 as u128, 32u16);
        // D s_570_4: bit-extract s_570_3 s_570_0 s_570_1
        let s_570_4: Bits = (Bits::new(
            ((s_570_3) >> (s_570_0)).value(),
            u16::try_from(s_570_1).unwrap(),
        ));
        // D s_570_5: cast reint s_570_4 -> u8
        let s_570_5: u8 = (s_570_4.value() as u8);
        // D s_570_6: cast zx s_570_5 -> bv
        let s_570_6: Bits = Bits::new(s_570_5 as u128, 4u16);
        // C s_570_7: const #15u : u8
        let s_570_7: u8 = 15;
        // C s_570_8: cast zx s_570_7 -> bv
        let s_570_8: Bits = Bits::new(s_570_7 as u128, 4u16);
        // D s_570_9: cmp-ne s_570_6 s_570_8
        let s_570_9: bool = ((s_570_6) != (s_570_8));
        // N s_570_10: branch s_570_9 b573 b571
        if s_570_9 {
            return block_573(state, tracer, fn_state);
        } else {
            return block_571(state, tracer, fn_state);
        };
    }
    fn block_571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_571_0: const #0u : u8
        let s_571_0: bool = false;
        // D s_571_1: write-var gs#413902 <= s_571_0
        fn_state.gs_413902 = s_571_0;
        // N s_571_2: jump b572
        return block_572(state, tracer, fn_state);
    }
    fn block_572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_572_0: read-var gs#413902:u8
        let s_572_0: bool = fn_state.gs_413902;
        // D s_572_1: write-var gs#413903 <= s_572_0
        fn_state.gs_413903 = s_572_0;
        // N s_572_2: jump b500
        return block_500(state, tracer, fn_state);
    }
    fn block_573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_573_0: const #3926s : i
        let s_573_0: i128 = 3926;
        // C s_573_1: const #14696u : u32
        let s_573_1: u32 = 14696;
        // D s_573_2: read-reg s_573_1:i
        let s_573_2: i128 = {
            let value = state.read_register::<i128>(s_573_1 as isize);
            tracer.read_register(s_573_1 as isize, value);
            value
        };
        // D s_573_3: cmp-lt s_573_2 s_573_0
        let s_573_3: bool = ((s_573_2) < (s_573_0));
        // D s_573_4: write-var gs#413902 <= s_573_3
        fn_state.gs_413902 = s_573_3;
        // N s_573_5: jump b572
        return block_572(state, tracer, fn_state);
    }
    fn block_574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_574_0: const #16s : i
        let s_574_0: i128 = 16;
        // D s_574_1: read-var u#34478:u32
        let s_574_1: u32 = fn_state.u_34478;
        // D s_574_2: cast zx s_574_1 -> bv
        let s_574_2: Bits = Bits::new(s_574_1 as u128, 32u16);
        // C s_574_3: const #1s : i64
        let s_574_3: i64 = 1;
        // C s_574_4: cast zx s_574_3 -> i
        let s_574_4: i128 = (i128::try_from(s_574_3).unwrap());
        // C s_574_5: const #5s : i
        let s_574_5: i128 = 5;
        // C s_574_6: add s_574_5 s_574_4
        let s_574_6: i128 = (s_574_5 + s_574_4);
        // D s_574_7: bit-extract s_574_2 s_574_0 s_574_6
        let s_574_7: Bits = (Bits::new(
            ((s_574_2) >> (s_574_0)).value(),
            u16::try_from(s_574_6).unwrap(),
        ));
        // D s_574_8: cast reint s_574_7 -> u8
        let s_574_8: u8 = (s_574_7.value() as u8);
        // D s_574_9: cast zx s_574_8 -> bv
        let s_574_9: Bits = Bits::new(s_574_8 as u128, 6u16);
        // C s_574_10: const #51u : u8
        let s_574_10: u8 = 51;
        // C s_574_11: cast zx s_574_10 -> bv
        let s_574_11: Bits = Bits::new(s_574_10 as u128, 6u16);
        // D s_574_12: cmp-eq s_574_9 s_574_11
        let s_574_12: bool = ((s_574_9) == (s_574_11));
        // N s_574_13: branch s_574_12 b577 b575
        if s_574_12 {
            return block_577(state, tracer, fn_state);
        } else {
            return block_575(state, tracer, fn_state);
        };
    }
    fn block_575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_575_0: const #0u : u8
        let s_575_0: bool = false;
        // D s_575_1: write-var gs#413897 <= s_575_0
        fn_state.gs_413897 = s_575_0;
        // N s_575_2: jump b576
        return block_576(state, tracer, fn_state);
    }
    fn block_576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_576_0: read-var gs#413897:u8
        let s_576_0: bool = fn_state.gs_413897;
        // D s_576_1: write-var gs#413898 <= s_576_0
        fn_state.gs_413898 = s_576_0;
        // N s_576_2: jump b498
        return block_498(state, tracer, fn_state);
    }
    fn block_577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_577_0: const #6s : i
        let s_577_0: i128 = 6;
        // D s_577_1: read-var u#34478:u32
        let s_577_1: u32 = fn_state.u_34478;
        // D s_577_2: cast zx s_577_1 -> bv
        let s_577_2: Bits = Bits::new(s_577_1 as u128, 32u16);
        // C s_577_3: const #1s : i64
        let s_577_3: i64 = 1;
        // C s_577_4: cast zx s_577_3 -> i
        let s_577_4: i128 = (i128::try_from(s_577_3).unwrap());
        // C s_577_5: const #5s : i
        let s_577_5: i128 = 5;
        // C s_577_6: add s_577_5 s_577_4
        let s_577_6: i128 = (s_577_5 + s_577_4);
        // D s_577_7: bit-extract s_577_2 s_577_0 s_577_6
        let s_577_7: Bits = (Bits::new(
            ((s_577_2) >> (s_577_0)).value(),
            u16::try_from(s_577_6).unwrap(),
        ));
        // D s_577_8: cast reint s_577_7 -> u8
        let s_577_8: u8 = (s_577_7.value() as u8);
        // D s_577_9: cast zx s_577_8 -> bv
        let s_577_9: Bits = Bits::new(s_577_8 as u128, 6u16);
        // C s_577_10: const #39u : u8
        let s_577_10: u8 = 39;
        // C s_577_11: cast zx s_577_10 -> bv
        let s_577_11: Bits = Bits::new(s_577_10 as u128, 6u16);
        // D s_577_12: cmp-eq s_577_9 s_577_11
        let s_577_12: bool = ((s_577_9) == (s_577_11));
        // N s_577_13: branch s_577_12 b580 b578
        if s_577_12 {
            return block_580(state, tracer, fn_state);
        } else {
            return block_578(state, tracer, fn_state);
        };
    }
    fn block_578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_578_0: const #0u : u8
        let s_578_0: bool = false;
        // D s_578_1: write-var gs#413896 <= s_578_0
        fn_state.gs_413896 = s_578_0;
        // N s_578_2: jump b579
        return block_579(state, tracer, fn_state);
    }
    fn block_579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_579_0: read-var gs#413896:u8
        let s_579_0: bool = fn_state.gs_413896;
        // D s_579_1: write-var gs#413897 <= s_579_0
        fn_state.gs_413897 = s_579_0;
        // N s_579_2: jump b576
        return block_576(state, tracer, fn_state);
    }
    fn block_580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_580_0: const #4s : i
        let s_580_0: i128 = 4;
        // D s_580_1: read-var u#34478:u32
        let s_580_1: u32 = fn_state.u_34478;
        // D s_580_2: cast zx s_580_1 -> bv
        let s_580_2: Bits = Bits::new(s_580_1 as u128, 32u16);
        // C s_580_3: const #1s : i64
        let s_580_3: i64 = 1;
        // C s_580_4: cast zx s_580_3 -> i
        let s_580_4: i128 = (i128::try_from(s_580_3).unwrap());
        // C s_580_5: const #0s : i
        let s_580_5: i128 = 0;
        // C s_580_6: add s_580_5 s_580_4
        let s_580_6: i128 = (s_580_5 + s_580_4);
        // D s_580_7: bit-extract s_580_2 s_580_0 s_580_6
        let s_580_7: Bits = (Bits::new(
            ((s_580_2) >> (s_580_0)).value(),
            u16::try_from(s_580_6).unwrap(),
        ));
        // D s_580_8: cast reint s_580_7 -> u8
        let s_580_8: bool = ((s_580_7.value()) != 0);
        // D s_580_9: cast zx s_580_8 -> bv
        let s_580_9: Bits = Bits::new(s_580_8 as u128, 1u16);
        // C s_580_10: const #0u : u8
        let s_580_10: bool = false;
        // C s_580_11: cast zx s_580_10 -> bv
        let s_580_11: Bits = Bits::new(s_580_10 as u128, 1u16);
        // D s_580_12: cmp-eq s_580_9 s_580_11
        let s_580_12: bool = ((s_580_9) == (s_580_11));
        // D s_580_13: write-var gs#413896 <= s_580_12
        fn_state.gs_413896 = s_580_12;
        // N s_580_14: jump b579
        return block_579(state, tracer, fn_state);
    }
    fn block_581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_581_0: const #28s : i
        let s_581_0: i128 = 28;
        // C s_581_1: const #4s : i
        let s_581_1: i128 = 4;
        // D s_581_2: read-var u#34471:u32
        let s_581_2: u32 = fn_state.u_34471;
        // D s_581_3: cast zx s_581_2 -> bv
        let s_581_3: Bits = Bits::new(s_581_2 as u128, 32u16);
        // D s_581_4: bit-extract s_581_3 s_581_0 s_581_1
        let s_581_4: Bits = (Bits::new(
            ((s_581_3) >> (s_581_0)).value(),
            u16::try_from(s_581_1).unwrap(),
        ));
        // D s_581_5: cast reint s_581_4 -> u8
        let s_581_5: u8 = (s_581_4.value() as u8);
        // D s_581_6: cast zx s_581_5 -> bv
        let s_581_6: Bits = Bits::new(s_581_5 as u128, 4u16);
        // C s_581_7: const #15u : u8
        let s_581_7: u8 = 15;
        // C s_581_8: cast zx s_581_7 -> bv
        let s_581_8: Bits = Bits::new(s_581_7 as u128, 4u16);
        // D s_581_9: cmp-ne s_581_6 s_581_8
        let s_581_9: bool = ((s_581_6) != (s_581_8));
        // N s_581_10: branch s_581_9 b584 b582
        if s_581_9 {
            return block_584(state, tracer, fn_state);
        } else {
            return block_582(state, tracer, fn_state);
        };
    }
    fn block_582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_582_0: const #0u : u8
        let s_582_0: bool = false;
        // D s_582_1: write-var gs#413873 <= s_582_0
        fn_state.gs_413873 = s_582_0;
        // N s_582_2: jump b583
        return block_583(state, tracer, fn_state);
    }
    fn block_583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_583_0: read-var gs#413873:u8
        let s_583_0: bool = fn_state.gs_413873;
        // D s_583_1: write-var gs#413874 <= s_583_0
        fn_state.gs_413874 = s_583_0;
        // N s_583_2: jump b494
        return block_494(state, tracer, fn_state);
    }
    fn block_584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_584_0: const #3924s : i
        let s_584_0: i128 = 3924;
        // C s_584_1: const #14696u : u32
        let s_584_1: u32 = 14696;
        // D s_584_2: read-reg s_584_1:i
        let s_584_2: i128 = {
            let value = state.read_register::<i128>(s_584_1 as isize);
            tracer.read_register(s_584_1 as isize, value);
            value
        };
        // D s_584_3: cmp-lt s_584_2 s_584_0
        let s_584_3: bool = ((s_584_2) < (s_584_0));
        // D s_584_4: write-var gs#413873 <= s_584_3
        fn_state.gs_413873 = s_584_3;
        // N s_584_5: jump b583
        return block_583(state, tracer, fn_state);
    }
    fn block_585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_585_0: const #16s : i
        let s_585_0: i128 = 16;
        // D s_585_1: read-var u#34471:u32
        let s_585_1: u32 = fn_state.u_34471;
        // D s_585_2: cast zx s_585_1 -> bv
        let s_585_2: Bits = Bits::new(s_585_1 as u128, 32u16);
        // C s_585_3: const #1s : i64
        let s_585_3: i64 = 1;
        // C s_585_4: cast zx s_585_3 -> i
        let s_585_4: i128 = (i128::try_from(s_585_3).unwrap());
        // C s_585_5: const #5s : i
        let s_585_5: i128 = 5;
        // C s_585_6: add s_585_5 s_585_4
        let s_585_6: i128 = (s_585_5 + s_585_4);
        // D s_585_7: bit-extract s_585_2 s_585_0 s_585_6
        let s_585_7: Bits = (Bits::new(
            ((s_585_2) >> (s_585_0)).value(),
            u16::try_from(s_585_6).unwrap(),
        ));
        // D s_585_8: cast reint s_585_7 -> u8
        let s_585_8: u8 = (s_585_7.value() as u8);
        // D s_585_9: cast zx s_585_8 -> bv
        let s_585_9: Bits = Bits::new(s_585_8 as u128, 6u16);
        // C s_585_10: const #51u : u8
        let s_585_10: u8 = 51;
        // C s_585_11: cast zx s_585_10 -> bv
        let s_585_11: Bits = Bits::new(s_585_10 as u128, 6u16);
        // D s_585_12: cmp-eq s_585_9 s_585_11
        let s_585_12: bool = ((s_585_9) == (s_585_11));
        // N s_585_13: branch s_585_12 b588 b586
        if s_585_12 {
            return block_588(state, tracer, fn_state);
        } else {
            return block_586(state, tracer, fn_state);
        };
    }
    fn block_586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_586_0: const #0u : u8
        let s_586_0: bool = false;
        // D s_586_1: write-var gs#413868 <= s_586_0
        fn_state.gs_413868 = s_586_0;
        // N s_586_2: jump b587
        return block_587(state, tracer, fn_state);
    }
    fn block_587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_587_0: read-var gs#413868:u8
        let s_587_0: bool = fn_state.gs_413868;
        // D s_587_1: write-var gs#413869 <= s_587_0
        fn_state.gs_413869 = s_587_0;
        // N s_587_2: jump b492
        return block_492(state, tracer, fn_state);
    }
    fn block_588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_588_0: const #6s : i
        let s_588_0: i128 = 6;
        // D s_588_1: read-var u#34471:u32
        let s_588_1: u32 = fn_state.u_34471;
        // D s_588_2: cast zx s_588_1 -> bv
        let s_588_2: Bits = Bits::new(s_588_1 as u128, 32u16);
        // C s_588_3: const #1s : i64
        let s_588_3: i64 = 1;
        // C s_588_4: cast zx s_588_3 -> i
        let s_588_4: i128 = (i128::try_from(s_588_3).unwrap());
        // C s_588_5: const #5s : i
        let s_588_5: i128 = 5;
        // C s_588_6: add s_588_5 s_588_4
        let s_588_6: i128 = (s_588_5 + s_588_4);
        // D s_588_7: bit-extract s_588_2 s_588_0 s_588_6
        let s_588_7: Bits = (Bits::new(
            ((s_588_2) >> (s_588_0)).value(),
            u16::try_from(s_588_6).unwrap(),
        ));
        // D s_588_8: cast reint s_588_7 -> u8
        let s_588_8: u8 = (s_588_7.value() as u8);
        // D s_588_9: cast zx s_588_8 -> bv
        let s_588_9: Bits = Bits::new(s_588_8 as u128, 6u16);
        // C s_588_10: const #37u : u8
        let s_588_10: u8 = 37;
        // C s_588_11: cast zx s_588_10 -> bv
        let s_588_11: Bits = Bits::new(s_588_10 as u128, 6u16);
        // D s_588_12: cmp-eq s_588_9 s_588_11
        let s_588_12: bool = ((s_588_9) == (s_588_11));
        // N s_588_13: branch s_588_12 b591 b589
        if s_588_12 {
            return block_591(state, tracer, fn_state);
        } else {
            return block_589(state, tracer, fn_state);
        };
    }
    fn block_589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_589_0: const #0u : u8
        let s_589_0: bool = false;
        // D s_589_1: write-var gs#413867 <= s_589_0
        fn_state.gs_413867 = s_589_0;
        // N s_589_2: jump b590
        return block_590(state, tracer, fn_state);
    }
    fn block_590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_590_0: read-var gs#413867:u8
        let s_590_0: bool = fn_state.gs_413867;
        // D s_590_1: write-var gs#413868 <= s_590_0
        fn_state.gs_413868 = s_590_0;
        // N s_590_2: jump b587
        return block_587(state, tracer, fn_state);
    }
    fn block_591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_591_0: const #4s : i
        let s_591_0: i128 = 4;
        // D s_591_1: read-var u#34471:u32
        let s_591_1: u32 = fn_state.u_34471;
        // D s_591_2: cast zx s_591_1 -> bv
        let s_591_2: Bits = Bits::new(s_591_1 as u128, 32u16);
        // C s_591_3: const #1s : i64
        let s_591_3: i64 = 1;
        // C s_591_4: cast zx s_591_3 -> i
        let s_591_4: i128 = (i128::try_from(s_591_3).unwrap());
        // C s_591_5: const #0s : i
        let s_591_5: i128 = 0;
        // C s_591_6: add s_591_5 s_591_4
        let s_591_6: i128 = (s_591_5 + s_591_4);
        // D s_591_7: bit-extract s_591_2 s_591_0 s_591_6
        let s_591_7: Bits = (Bits::new(
            ((s_591_2) >> (s_591_0)).value(),
            u16::try_from(s_591_6).unwrap(),
        ));
        // D s_591_8: cast reint s_591_7 -> u8
        let s_591_8: bool = ((s_591_7.value()) != 0);
        // D s_591_9: cast zx s_591_8 -> bv
        let s_591_9: Bits = Bits::new(s_591_8 as u128, 1u16);
        // C s_591_10: const #0u : u8
        let s_591_10: bool = false;
        // C s_591_11: cast zx s_591_10 -> bv
        let s_591_11: Bits = Bits::new(s_591_10 as u128, 1u16);
        // D s_591_12: cmp-eq s_591_9 s_591_11
        let s_591_12: bool = ((s_591_9) == (s_591_11));
        // D s_591_13: write-var gs#413867 <= s_591_12
        fn_state.gs_413867 = s_591_12;
        // N s_591_14: jump b590
        return block_590(state, tracer, fn_state);
    }
    fn block_592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_592_0: const #3920s : i
        let s_592_0: i128 = 3920;
        // C s_592_1: const #14696u : u32
        let s_592_1: u32 = 14696;
        // D s_592_2: read-reg s_592_1:i
        let s_592_2: i128 = {
            let value = state.read_register::<i128>(s_592_1 as isize);
            tracer.read_register(s_592_1 as isize, value);
            value
        };
        // D s_592_3: cmp-lt s_592_2 s_592_0
        let s_592_3: bool = ((s_592_2) < (s_592_0));
        // D s_592_4: write-var gs#413843 <= s_592_3
        fn_state.gs_413843 = s_592_3;
        // N s_592_5: jump b488
        return block_488(state, tracer, fn_state);
    }
    fn block_593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_593_0: const #20s : i
        let s_593_0: i128 = 20;
        // D s_593_1: read-var u#34463:u32
        let s_593_1: u32 = fn_state.u_34463;
        // D s_593_2: cast zx s_593_1 -> bv
        let s_593_2: Bits = Bits::new(s_593_1 as u128, 32u16);
        // C s_593_3: const #1s : i64
        let s_593_3: i64 = 1;
        // C s_593_4: cast zx s_593_3 -> i
        let s_593_4: i128 = (i128::try_from(s_593_3).unwrap());
        // C s_593_5: const #1s : i
        let s_593_5: i128 = 1;
        // C s_593_6: add s_593_5 s_593_4
        let s_593_6: i128 = (s_593_5 + s_593_4);
        // D s_593_7: bit-extract s_593_2 s_593_0 s_593_6
        let s_593_7: Bits = (Bits::new(
            ((s_593_2) >> (s_593_0)).value(),
            u16::try_from(s_593_6).unwrap(),
        ));
        // D s_593_8: cast reint s_593_7 -> u8
        let s_593_8: u8 = (s_593_7.value() as u8);
        // D s_593_9: cast zx s_593_8 -> bv
        let s_593_9: Bits = Bits::new(s_593_8 as u128, 2u16);
        // C s_593_10: const #0u : u8
        let s_593_10: u8 = 0;
        // C s_593_11: cast zx s_593_10 -> bv
        let s_593_11: Bits = Bits::new(s_593_10 as u128, 2u16);
        // D s_593_12: cmp-eq s_593_9 s_593_11
        let s_593_12: bool = ((s_593_9) == (s_593_11));
        // N s_593_13: branch s_593_12 b596 b594
        if s_593_12 {
            return block_596(state, tracer, fn_state);
        } else {
            return block_594(state, tracer, fn_state);
        };
    }
    fn block_594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_594_0: const #0u : u8
        let s_594_0: bool = false;
        // D s_594_1: write-var gs#413840 <= s_594_0
        fn_state.gs_413840 = s_594_0;
        // N s_594_2: jump b595
        return block_595(state, tracer, fn_state);
    }
    fn block_595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_595_0: read-var gs#413840:u8
        let s_595_0: bool = fn_state.gs_413840;
        // D s_595_1: write-var gs#413841 <= s_595_0
        fn_state.gs_413841 = s_595_0;
        // N s_595_2: jump b486
        return block_486(state, tracer, fn_state);
    }
    fn block_596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_596_0: const #8s : i
        let s_596_0: i128 = 8;
        // D s_596_1: read-var u#34463:u32
        let s_596_1: u32 = fn_state.u_34463;
        // D s_596_2: cast zx s_596_1 -> bv
        let s_596_2: Bits = Bits::new(s_596_1 as u128, 32u16);
        // C s_596_3: const #1s : i64
        let s_596_3: i64 = 1;
        // C s_596_4: cast zx s_596_3 -> i
        let s_596_4: i128 = (i128::try_from(s_596_3).unwrap());
        // C s_596_5: const #3s : i
        let s_596_5: i128 = 3;
        // C s_596_6: add s_596_5 s_596_4
        let s_596_6: i128 = (s_596_5 + s_596_4);
        // D s_596_7: bit-extract s_596_2 s_596_0 s_596_6
        let s_596_7: Bits = (Bits::new(
            ((s_596_2) >> (s_596_0)).value(),
            u16::try_from(s_596_6).unwrap(),
        ));
        // D s_596_8: cast reint s_596_7 -> u8
        let s_596_8: u8 = (s_596_7.value() as u8);
        // D s_596_9: cast zx s_596_8 -> bv
        let s_596_9: Bits = Bits::new(s_596_8 as u128, 4u16);
        // C s_596_10: const #12u : u8
        let s_596_10: u8 = 12;
        // C s_596_11: cast zx s_596_10 -> bv
        let s_596_11: Bits = Bits::new(s_596_10 as u128, 4u16);
        // D s_596_12: cmp-eq s_596_9 s_596_11
        let s_596_12: bool = ((s_596_9) == (s_596_11));
        // N s_596_13: branch s_596_12 b599 b597
        if s_596_12 {
            return block_599(state, tracer, fn_state);
        } else {
            return block_597(state, tracer, fn_state);
        };
    }
    fn block_597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_597_0: const #0u : u8
        let s_597_0: bool = false;
        // D s_597_1: write-var gs#413839 <= s_597_0
        fn_state.gs_413839 = s_597_0;
        // N s_597_2: jump b598
        return block_598(state, tracer, fn_state);
    }
    fn block_598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_598_0: read-var gs#413839:u8
        let s_598_0: bool = fn_state.gs_413839;
        // D s_598_1: write-var gs#413840 <= s_598_0
        fn_state.gs_413840 = s_598_0;
        // N s_598_2: jump b595
        return block_595(state, tracer, fn_state);
    }
    fn block_599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_599_0: const #6s : i
        let s_599_0: i128 = 6;
        // D s_599_1: read-var u#34463:u32
        let s_599_1: u32 = fn_state.u_34463;
        // D s_599_2: cast zx s_599_1 -> bv
        let s_599_2: Bits = Bits::new(s_599_1 as u128, 32u16);
        // C s_599_3: const #1s : i64
        let s_599_3: i64 = 1;
        // C s_599_4: cast zx s_599_3 -> i
        let s_599_4: i128 = (i128::try_from(s_599_3).unwrap());
        // C s_599_5: const #0s : i
        let s_599_5: i128 = 0;
        // C s_599_6: add s_599_5 s_599_4
        let s_599_6: i128 = (s_599_5 + s_599_4);
        // D s_599_7: bit-extract s_599_2 s_599_0 s_599_6
        let s_599_7: Bits = (Bits::new(
            ((s_599_2) >> (s_599_0)).value(),
            u16::try_from(s_599_6).unwrap(),
        ));
        // D s_599_8: cast reint s_599_7 -> u8
        let s_599_8: bool = ((s_599_7.value()) != 0);
        // D s_599_9: cast zx s_599_8 -> bv
        let s_599_9: Bits = Bits::new(s_599_8 as u128, 1u16);
        // C s_599_10: const #1u : u8
        let s_599_10: bool = true;
        // C s_599_11: cast zx s_599_10 -> bv
        let s_599_11: Bits = Bits::new(s_599_10 as u128, 1u16);
        // D s_599_12: cmp-eq s_599_9 s_599_11
        let s_599_12: bool = ((s_599_9) == (s_599_11));
        // N s_599_13: branch s_599_12 b602 b600
        if s_599_12 {
            return block_602(state, tracer, fn_state);
        } else {
            return block_600(state, tracer, fn_state);
        };
    }
    fn block_600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_600_0: const #0u : u8
        let s_600_0: bool = false;
        // D s_600_1: write-var gs#413838 <= s_600_0
        fn_state.gs_413838 = s_600_0;
        // N s_600_2: jump b601
        return block_601(state, tracer, fn_state);
    }
    fn block_601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_601_0: read-var gs#413838:u8
        let s_601_0: bool = fn_state.gs_413838;
        // D s_601_1: write-var gs#413839 <= s_601_0
        fn_state.gs_413839 = s_601_0;
        // N s_601_2: jump b598
        return block_598(state, tracer, fn_state);
    }
    fn block_602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_602_0: const #4s : i
        let s_602_0: i128 = 4;
        // D s_602_1: read-var u#34463:u32
        let s_602_1: u32 = fn_state.u_34463;
        // D s_602_2: cast zx s_602_1 -> bv
        let s_602_2: Bits = Bits::new(s_602_1 as u128, 32u16);
        // C s_602_3: const #1s : i64
        let s_602_3: i64 = 1;
        // C s_602_4: cast zx s_602_3 -> i
        let s_602_4: i128 = (i128::try_from(s_602_3).unwrap());
        // C s_602_5: const #0s : i
        let s_602_5: i128 = 0;
        // C s_602_6: add s_602_5 s_602_4
        let s_602_6: i128 = (s_602_5 + s_602_4);
        // D s_602_7: bit-extract s_602_2 s_602_0 s_602_6
        let s_602_7: Bits = (Bits::new(
            ((s_602_2) >> (s_602_0)).value(),
            u16::try_from(s_602_6).unwrap(),
        ));
        // D s_602_8: cast reint s_602_7 -> u8
        let s_602_8: bool = ((s_602_7.value()) != 0);
        // D s_602_9: cast zx s_602_8 -> bv
        let s_602_9: Bits = Bits::new(s_602_8 as u128, 1u16);
        // C s_602_10: const #0u : u8
        let s_602_10: bool = false;
        // C s_602_11: cast zx s_602_10 -> bv
        let s_602_11: Bits = Bits::new(s_602_10 as u128, 1u16);
        // D s_602_12: cmp-eq s_602_9 s_602_11
        let s_602_12: bool = ((s_602_9) == (s_602_11));
        // D s_602_13: write-var gs#413838 <= s_602_12
        fn_state.gs_413838 = s_602_12;
        // N s_602_14: jump b601
        return block_601(state, tracer, fn_state);
    }
    fn block_603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_603_0: const #3918s : i
        let s_603_0: i128 = 3918;
        // C s_603_1: const #14696u : u32
        let s_603_1: u32 = 14696;
        // D s_603_2: read-reg s_603_1:i
        let s_603_2: i128 = {
            let value = state.read_register::<i128>(s_603_1 as isize);
            tracer.read_register(s_603_1 as isize, value);
            value
        };
        // D s_603_3: cmp-lt s_603_2 s_603_0
        let s_603_3: bool = ((s_603_2) < (s_603_0));
        // D s_603_4: write-var gs#413810 <= s_603_3
        fn_state.gs_413810 = s_603_3;
        // N s_603_5: jump b482
        return block_482(state, tracer, fn_state);
    }
    fn block_604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_604_0: const #20s : i
        let s_604_0: i128 = 20;
        // D s_604_1: read-var u#34454:u32
        let s_604_1: u32 = fn_state.u_34454;
        // D s_604_2: cast zx s_604_1 -> bv
        let s_604_2: Bits = Bits::new(s_604_1 as u128, 32u16);
        // C s_604_3: const #1s : i64
        let s_604_3: i64 = 1;
        // C s_604_4: cast zx s_604_3 -> i
        let s_604_4: i128 = (i128::try_from(s_604_3).unwrap());
        // C s_604_5: const #1s : i
        let s_604_5: i128 = 1;
        // C s_604_6: add s_604_5 s_604_4
        let s_604_6: i128 = (s_604_5 + s_604_4);
        // D s_604_7: bit-extract s_604_2 s_604_0 s_604_6
        let s_604_7: Bits = (Bits::new(
            ((s_604_2) >> (s_604_0)).value(),
            u16::try_from(s_604_6).unwrap(),
        ));
        // D s_604_8: cast reint s_604_7 -> u8
        let s_604_8: u8 = (s_604_7.value() as u8);
        // D s_604_9: cast zx s_604_8 -> bv
        let s_604_9: Bits = Bits::new(s_604_8 as u128, 2u16);
        // C s_604_10: const #0u : u8
        let s_604_10: u8 = 0;
        // C s_604_11: cast zx s_604_10 -> bv
        let s_604_11: Bits = Bits::new(s_604_10 as u128, 2u16);
        // D s_604_12: cmp-eq s_604_9 s_604_11
        let s_604_12: bool = ((s_604_9) == (s_604_11));
        // N s_604_13: branch s_604_12 b607 b605
        if s_604_12 {
            return block_607(state, tracer, fn_state);
        } else {
            return block_605(state, tracer, fn_state);
        };
    }
    fn block_605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_605_0: const #0u : u8
        let s_605_0: bool = false;
        // D s_605_1: write-var gs#413807 <= s_605_0
        fn_state.gs_413807 = s_605_0;
        // N s_605_2: jump b606
        return block_606(state, tracer, fn_state);
    }
    fn block_606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_606_0: read-var gs#413807:u8
        let s_606_0: bool = fn_state.gs_413807;
        // D s_606_1: write-var gs#413808 <= s_606_0
        fn_state.gs_413808 = s_606_0;
        // N s_606_2: jump b480
        return block_480(state, tracer, fn_state);
    }
    fn block_607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_607_0: const #8s : i
        let s_607_0: i128 = 8;
        // D s_607_1: read-var u#34454:u32
        let s_607_1: u32 = fn_state.u_34454;
        // D s_607_2: cast zx s_607_1 -> bv
        let s_607_2: Bits = Bits::new(s_607_1 as u128, 32u16);
        // C s_607_3: const #1s : i64
        let s_607_3: i64 = 1;
        // C s_607_4: cast zx s_607_3 -> i
        let s_607_4: i128 = (i128::try_from(s_607_3).unwrap());
        // C s_607_5: const #3s : i
        let s_607_5: i128 = 3;
        // C s_607_6: add s_607_5 s_607_4
        let s_607_6: i128 = (s_607_5 + s_607_4);
        // D s_607_7: bit-extract s_607_2 s_607_0 s_607_6
        let s_607_7: Bits = (Bits::new(
            ((s_607_2) >> (s_607_0)).value(),
            u16::try_from(s_607_6).unwrap(),
        ));
        // D s_607_8: cast reint s_607_7 -> u8
        let s_607_8: u8 = (s_607_7.value() as u8);
        // D s_607_9: cast zx s_607_8 -> bv
        let s_607_9: Bits = Bits::new(s_607_8 as u128, 4u16);
        // C s_607_10: const #13u : u8
        let s_607_10: u8 = 13;
        // C s_607_11: cast zx s_607_10 -> bv
        let s_607_11: Bits = Bits::new(s_607_10 as u128, 4u16);
        // D s_607_12: cmp-eq s_607_9 s_607_11
        let s_607_12: bool = ((s_607_9) == (s_607_11));
        // N s_607_13: branch s_607_12 b610 b608
        if s_607_12 {
            return block_610(state, tracer, fn_state);
        } else {
            return block_608(state, tracer, fn_state);
        };
    }
    fn block_608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_608_0: const #0u : u8
        let s_608_0: bool = false;
        // D s_608_1: write-var gs#413806 <= s_608_0
        fn_state.gs_413806 = s_608_0;
        // N s_608_2: jump b609
        return block_609(state, tracer, fn_state);
    }
    fn block_609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_609_0: read-var gs#413806:u8
        let s_609_0: bool = fn_state.gs_413806;
        // D s_609_1: write-var gs#413807 <= s_609_0
        fn_state.gs_413807 = s_609_0;
        // N s_609_2: jump b606
        return block_606(state, tracer, fn_state);
    }
    fn block_610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_610_0: const #4s : i
        let s_610_0: i128 = 4;
        // D s_610_1: read-var u#34454:u32
        let s_610_1: u32 = fn_state.u_34454;
        // D s_610_2: cast zx s_610_1 -> bv
        let s_610_2: Bits = Bits::new(s_610_1 as u128, 32u16);
        // C s_610_3: const #1s : i64
        let s_610_3: i64 = 1;
        // C s_610_4: cast zx s_610_3 -> i
        let s_610_4: i128 = (i128::try_from(s_610_3).unwrap());
        // C s_610_5: const #0s : i
        let s_610_5: i128 = 0;
        // C s_610_6: add s_610_5 s_610_4
        let s_610_6: i128 = (s_610_5 + s_610_4);
        // D s_610_7: bit-extract s_610_2 s_610_0 s_610_6
        let s_610_7: Bits = (Bits::new(
            ((s_610_2) >> (s_610_0)).value(),
            u16::try_from(s_610_6).unwrap(),
        ));
        // D s_610_8: cast reint s_610_7 -> u8
        let s_610_8: bool = ((s_610_7.value()) != 0);
        // D s_610_9: cast zx s_610_8 -> bv
        let s_610_9: Bits = Bits::new(s_610_8 as u128, 1u16);
        // C s_610_10: const #0u : u8
        let s_610_10: bool = false;
        // C s_610_11: cast zx s_610_10 -> bv
        let s_610_11: Bits = Bits::new(s_610_10 as u128, 1u16);
        // D s_610_12: cmp-eq s_610_9 s_610_11
        let s_610_12: bool = ((s_610_9) == (s_610_11));
        // D s_610_13: write-var gs#413806 <= s_610_12
        fn_state.gs_413806 = s_610_12;
        // N s_610_14: jump b609
        return block_609(state, tracer, fn_state);
    }
    fn block_611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_611_0: const #3916s : i
        let s_611_0: i128 = 3916;
        // C s_611_1: const #14696u : u32
        let s_611_1: u32 = 14696;
        // D s_611_2: read-reg s_611_1:i
        let s_611_2: i128 = {
            let value = state.read_register::<i128>(s_611_1 as isize);
            tracer.read_register(s_611_1 as isize, value);
            value
        };
        // D s_611_3: cmp-lt s_611_2 s_611_0
        let s_611_3: bool = ((s_611_2) < (s_611_0));
        // D s_611_4: write-var gs#413780 <= s_611_3
        fn_state.gs_413780 = s_611_3;
        // N s_611_5: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_612_0: const #20s : i
        let s_612_0: i128 = 20;
        // D s_612_1: read-var u#34445:u32
        let s_612_1: u32 = fn_state.u_34445;
        // D s_612_2: cast zx s_612_1 -> bv
        let s_612_2: Bits = Bits::new(s_612_1 as u128, 32u16);
        // C s_612_3: const #1s : i64
        let s_612_3: i64 = 1;
        // C s_612_4: cast zx s_612_3 -> i
        let s_612_4: i128 = (i128::try_from(s_612_3).unwrap());
        // C s_612_5: const #1s : i
        let s_612_5: i128 = 1;
        // C s_612_6: add s_612_5 s_612_4
        let s_612_6: i128 = (s_612_5 + s_612_4);
        // D s_612_7: bit-extract s_612_2 s_612_0 s_612_6
        let s_612_7: Bits = (Bits::new(
            ((s_612_2) >> (s_612_0)).value(),
            u16::try_from(s_612_6).unwrap(),
        ));
        // D s_612_8: cast reint s_612_7 -> u8
        let s_612_8: u8 = (s_612_7.value() as u8);
        // D s_612_9: cast zx s_612_8 -> bv
        let s_612_9: Bits = Bits::new(s_612_8 as u128, 2u16);
        // C s_612_10: const #0u : u8
        let s_612_10: u8 = 0;
        // C s_612_11: cast zx s_612_10 -> bv
        let s_612_11: Bits = Bits::new(s_612_10 as u128, 2u16);
        // D s_612_12: cmp-eq s_612_9 s_612_11
        let s_612_12: bool = ((s_612_9) == (s_612_11));
        // N s_612_13: branch s_612_12 b615 b613
        if s_612_12 {
            return block_615(state, tracer, fn_state);
        } else {
            return block_613(state, tracer, fn_state);
        };
    }
    fn block_613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_613_0: const #0u : u8
        let s_613_0: bool = false;
        // D s_613_1: write-var gs#413777 <= s_613_0
        fn_state.gs_413777 = s_613_0;
        // N s_613_2: jump b614
        return block_614(state, tracer, fn_state);
    }
    fn block_614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_614_0: read-var gs#413777:u8
        let s_614_0: bool = fn_state.gs_413777;
        // D s_614_1: write-var gs#413778 <= s_614_0
        fn_state.gs_413778 = s_614_0;
        // N s_614_2: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_615_0: const #8s : i
        let s_615_0: i128 = 8;
        // D s_615_1: read-var u#34445:u32
        let s_615_1: u32 = fn_state.u_34445;
        // D s_615_2: cast zx s_615_1 -> bv
        let s_615_2: Bits = Bits::new(s_615_1 as u128, 32u16);
        // C s_615_3: const #1s : i64
        let s_615_3: i64 = 1;
        // C s_615_4: cast zx s_615_3 -> i
        let s_615_4: i128 = (i128::try_from(s_615_3).unwrap());
        // C s_615_5: const #3s : i
        let s_615_5: i128 = 3;
        // C s_615_6: add s_615_5 s_615_4
        let s_615_6: i128 = (s_615_5 + s_615_4);
        // D s_615_7: bit-extract s_615_2 s_615_0 s_615_6
        let s_615_7: Bits = (Bits::new(
            ((s_615_2) >> (s_615_0)).value(),
            u16::try_from(s_615_6).unwrap(),
        ));
        // D s_615_8: cast reint s_615_7 -> u8
        let s_615_8: u8 = (s_615_7.value() as u8);
        // D s_615_9: cast zx s_615_8 -> bv
        let s_615_9: Bits = Bits::new(s_615_8 as u128, 4u16);
        // C s_615_10: const #13u : u8
        let s_615_10: u8 = 13;
        // C s_615_11: cast zx s_615_10 -> bv
        let s_615_11: Bits = Bits::new(s_615_10 as u128, 4u16);
        // D s_615_12: cmp-eq s_615_9 s_615_11
        let s_615_12: bool = ((s_615_9) == (s_615_11));
        // N s_615_13: branch s_615_12 b618 b616
        if s_615_12 {
            return block_618(state, tracer, fn_state);
        } else {
            return block_616(state, tracer, fn_state);
        };
    }
    fn block_616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_616_0: const #0u : u8
        let s_616_0: bool = false;
        // D s_616_1: write-var gs#413776 <= s_616_0
        fn_state.gs_413776 = s_616_0;
        // N s_616_2: jump b617
        return block_617(state, tracer, fn_state);
    }
    fn block_617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_617_0: read-var gs#413776:u8
        let s_617_0: bool = fn_state.gs_413776;
        // D s_617_1: write-var gs#413777 <= s_617_0
        fn_state.gs_413777 = s_617_0;
        // N s_617_2: jump b614
        return block_614(state, tracer, fn_state);
    }
    fn block_618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_618_0: const #4s : i
        let s_618_0: i128 = 4;
        // D s_618_1: read-var u#34445:u32
        let s_618_1: u32 = fn_state.u_34445;
        // D s_618_2: cast zx s_618_1 -> bv
        let s_618_2: Bits = Bits::new(s_618_1 as u128, 32u16);
        // C s_618_3: const #1s : i64
        let s_618_3: i64 = 1;
        // C s_618_4: cast zx s_618_3 -> i
        let s_618_4: i128 = (i128::try_from(s_618_3).unwrap());
        // C s_618_5: const #0s : i
        let s_618_5: i128 = 0;
        // C s_618_6: add s_618_5 s_618_4
        let s_618_6: i128 = (s_618_5 + s_618_4);
        // D s_618_7: bit-extract s_618_2 s_618_0 s_618_6
        let s_618_7: Bits = (Bits::new(
            ((s_618_2) >> (s_618_0)).value(),
            u16::try_from(s_618_6).unwrap(),
        ));
        // D s_618_8: cast reint s_618_7 -> u8
        let s_618_8: bool = ((s_618_7.value()) != 0);
        // D s_618_9: cast zx s_618_8 -> bv
        let s_618_9: Bits = Bits::new(s_618_8 as u128, 1u16);
        // C s_618_10: const #0u : u8
        let s_618_10: bool = false;
        // C s_618_11: cast zx s_618_10 -> bv
        let s_618_11: Bits = Bits::new(s_618_10 as u128, 1u16);
        // D s_618_12: cmp-eq s_618_9 s_618_11
        let s_618_12: bool = ((s_618_9) == (s_618_11));
        // D s_618_13: write-var gs#413776 <= s_618_12
        fn_state.gs_413776 = s_618_12;
        // N s_618_14: jump b617
        return block_617(state, tracer, fn_state);
    }
    fn block_619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_619_0: const #3914s : i
        let s_619_0: i128 = 3914;
        // C s_619_1: const #14696u : u32
        let s_619_1: u32 = 14696;
        // D s_619_2: read-reg s_619_1:i
        let s_619_2: i128 = {
            let value = state.read_register::<i128>(s_619_1 as isize);
            tracer.read_register(s_619_1 as isize, value);
            value
        };
        // D s_619_3: cmp-lt s_619_2 s_619_0
        let s_619_3: bool = ((s_619_2) < (s_619_0));
        // D s_619_4: write-var gs#413748 <= s_619_3
        fn_state.gs_413748 = s_619_3;
        // N s_619_5: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_620_0: const #21s : i
        let s_620_0: i128 = 21;
        // D s_620_1: read-var u#34435:u32
        let s_620_1: u32 = fn_state.u_34435;
        // D s_620_2: cast zx s_620_1 -> bv
        let s_620_2: Bits = Bits::new(s_620_1 as u128, 32u16);
        // C s_620_3: const #1s : i64
        let s_620_3: i64 = 1;
        // C s_620_4: cast zx s_620_3 -> i
        let s_620_4: i128 = (i128::try_from(s_620_3).unwrap());
        // C s_620_5: const #0s : i
        let s_620_5: i128 = 0;
        // C s_620_6: add s_620_5 s_620_4
        let s_620_6: i128 = (s_620_5 + s_620_4);
        // D s_620_7: bit-extract s_620_2 s_620_0 s_620_6
        let s_620_7: Bits = (Bits::new(
            ((s_620_2) >> (s_620_0)).value(),
            u16::try_from(s_620_6).unwrap(),
        ));
        // D s_620_8: cast reint s_620_7 -> u8
        let s_620_8: bool = ((s_620_7.value()) != 0);
        // D s_620_9: cast zx s_620_8 -> bv
        let s_620_9: Bits = Bits::new(s_620_8 as u128, 1u16);
        // C s_620_10: const #0u : u8
        let s_620_10: bool = false;
        // C s_620_11: cast zx s_620_10 -> bv
        let s_620_11: Bits = Bits::new(s_620_10 as u128, 1u16);
        // D s_620_12: cmp-eq s_620_9 s_620_11
        let s_620_12: bool = ((s_620_9) == (s_620_11));
        // N s_620_13: branch s_620_12 b623 b621
        if s_620_12 {
            return block_623(state, tracer, fn_state);
        } else {
            return block_621(state, tracer, fn_state);
        };
    }
    fn block_621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_621_0: const #0u : u8
        let s_621_0: bool = false;
        // D s_621_1: write-var gs#413745 <= s_621_0
        fn_state.gs_413745 = s_621_0;
        // N s_621_2: jump b622
        return block_622(state, tracer, fn_state);
    }
    fn block_622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_622_0: read-var gs#413745:u8
        let s_622_0: bool = fn_state.gs_413745;
        // D s_622_1: write-var gs#413746 <= s_622_0
        fn_state.gs_413746 = s_622_0;
        // N s_622_2: jump b468
        return block_468(state, tracer, fn_state);
    }
    fn block_623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_623_0: const #8s : i
        let s_623_0: i128 = 8;
        // D s_623_1: read-var u#34435:u32
        let s_623_1: u32 = fn_state.u_34435;
        // D s_623_2: cast zx s_623_1 -> bv
        let s_623_2: Bits = Bits::new(s_623_1 as u128, 32u16);
        // C s_623_3: const #1s : i64
        let s_623_3: i64 = 1;
        // C s_623_4: cast zx s_623_3 -> i
        let s_623_4: i128 = (i128::try_from(s_623_3).unwrap());
        // C s_623_5: const #3s : i
        let s_623_5: i128 = 3;
        // C s_623_6: add s_623_5 s_623_4
        let s_623_6: i128 = (s_623_5 + s_623_4);
        // D s_623_7: bit-extract s_623_2 s_623_0 s_623_6
        let s_623_7: Bits = (Bits::new(
            ((s_623_2) >> (s_623_0)).value(),
            u16::try_from(s_623_6).unwrap(),
        ));
        // D s_623_8: cast reint s_623_7 -> u8
        let s_623_8: u8 = (s_623_7.value() as u8);
        // D s_623_9: cast zx s_623_8 -> bv
        let s_623_9: Bits = Bits::new(s_623_8 as u128, 4u16);
        // C s_623_10: const #8u : u8
        let s_623_10: u8 = 8;
        // C s_623_11: cast zx s_623_10 -> bv
        let s_623_11: Bits = Bits::new(s_623_10 as u128, 4u16);
        // D s_623_12: cmp-eq s_623_9 s_623_11
        let s_623_12: bool = ((s_623_9) == (s_623_11));
        // N s_623_13: branch s_623_12 b626 b624
        if s_623_12 {
            return block_626(state, tracer, fn_state);
        } else {
            return block_624(state, tracer, fn_state);
        };
    }
    fn block_624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_624_0: const #0u : u8
        let s_624_0: bool = false;
        // D s_624_1: write-var gs#413744 <= s_624_0
        fn_state.gs_413744 = s_624_0;
        // N s_624_2: jump b625
        return block_625(state, tracer, fn_state);
    }
    fn block_625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_625_0: read-var gs#413744:u8
        let s_625_0: bool = fn_state.gs_413744;
        // D s_625_1: write-var gs#413745 <= s_625_0
        fn_state.gs_413745 = s_625_0;
        // N s_625_2: jump b622
        return block_622(state, tracer, fn_state);
    }
    fn block_626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_626_0: const #4s : i
        let s_626_0: i128 = 4;
        // D s_626_1: read-var u#34435:u32
        let s_626_1: u32 = fn_state.u_34435;
        // D s_626_2: cast zx s_626_1 -> bv
        let s_626_2: Bits = Bits::new(s_626_1 as u128, 32u16);
        // C s_626_3: const #1s : i64
        let s_626_3: i64 = 1;
        // C s_626_4: cast zx s_626_3 -> i
        let s_626_4: i128 = (i128::try_from(s_626_3).unwrap());
        // C s_626_5: const #0s : i
        let s_626_5: i128 = 0;
        // C s_626_6: add s_626_5 s_626_4
        let s_626_6: i128 = (s_626_5 + s_626_4);
        // D s_626_7: bit-extract s_626_2 s_626_0 s_626_6
        let s_626_7: Bits = (Bits::new(
            ((s_626_2) >> (s_626_0)).value(),
            u16::try_from(s_626_6).unwrap(),
        ));
        // D s_626_8: cast reint s_626_7 -> u8
        let s_626_8: bool = ((s_626_7.value()) != 0);
        // D s_626_9: cast zx s_626_8 -> bv
        let s_626_9: Bits = Bits::new(s_626_8 as u128, 1u16);
        // C s_626_10: const #1u : u8
        let s_626_10: bool = true;
        // C s_626_11: cast zx s_626_10 -> bv
        let s_626_11: Bits = Bits::new(s_626_10 as u128, 1u16);
        // D s_626_12: cmp-eq s_626_9 s_626_11
        let s_626_12: bool = ((s_626_9) == (s_626_11));
        // D s_626_13: write-var gs#413744 <= s_626_12
        fn_state.gs_413744 = s_626_12;
        // N s_626_14: jump b625
        return block_625(state, tracer, fn_state);
    }
    fn block_627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_627_0: const #3912s : i
        let s_627_0: i128 = 3912;
        // C s_627_1: const #14696u : u32
        let s_627_1: u32 = 14696;
        // D s_627_2: read-reg s_627_1:i
        let s_627_2: i128 = {
            let value = state.read_register::<i128>(s_627_1 as isize);
            tracer.read_register(s_627_1 as isize, value);
            value
        };
        // D s_627_3: cmp-lt s_627_2 s_627_0
        let s_627_3: bool = ((s_627_2) < (s_627_0));
        // D s_627_4: write-var gs#413716 <= s_627_3
        fn_state.gs_413716 = s_627_3;
        // N s_627_5: jump b464
        return block_464(state, tracer, fn_state);
    }
    fn block_628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_628_0: const #20s : i
        let s_628_0: i128 = 20;
        // D s_628_1: read-var u#34425:u32
        let s_628_1: u32 = fn_state.u_34425;
        // D s_628_2: cast zx s_628_1 -> bv
        let s_628_2: Bits = Bits::new(s_628_1 as u128, 32u16);
        // C s_628_3: const #1s : i64
        let s_628_3: i64 = 1;
        // C s_628_4: cast zx s_628_3 -> i
        let s_628_4: i128 = (i128::try_from(s_628_3).unwrap());
        // C s_628_5: const #1s : i
        let s_628_5: i128 = 1;
        // C s_628_6: add s_628_5 s_628_4
        let s_628_6: i128 = (s_628_5 + s_628_4);
        // D s_628_7: bit-extract s_628_2 s_628_0 s_628_6
        let s_628_7: Bits = (Bits::new(
            ((s_628_2) >> (s_628_0)).value(),
            u16::try_from(s_628_6).unwrap(),
        ));
        // D s_628_8: cast reint s_628_7 -> u8
        let s_628_8: u8 = (s_628_7.value() as u8);
        // D s_628_9: cast zx s_628_8 -> bv
        let s_628_9: Bits = Bits::new(s_628_8 as u128, 2u16);
        // C s_628_10: const #2u : u8
        let s_628_10: u8 = 2;
        // C s_628_11: cast zx s_628_10 -> bv
        let s_628_11: Bits = Bits::new(s_628_10 as u128, 2u16);
        // D s_628_12: cmp-eq s_628_9 s_628_11
        let s_628_12: bool = ((s_628_9) == (s_628_11));
        // N s_628_13: branch s_628_12 b631 b629
        if s_628_12 {
            return block_631(state, tracer, fn_state);
        } else {
            return block_629(state, tracer, fn_state);
        };
    }
    fn block_629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_629_0: const #0u : u8
        let s_629_0: bool = false;
        // D s_629_1: write-var gs#413713 <= s_629_0
        fn_state.gs_413713 = s_629_0;
        // N s_629_2: jump b630
        return block_630(state, tracer, fn_state);
    }
    fn block_630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_630_0: read-var gs#413713:u8
        let s_630_0: bool = fn_state.gs_413713;
        // D s_630_1: write-var gs#413714 <= s_630_0
        fn_state.gs_413714 = s_630_0;
        // N s_630_2: jump b462
        return block_462(state, tracer, fn_state);
    }
    fn block_631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_631_0: const #8s : i
        let s_631_0: i128 = 8;
        // D s_631_1: read-var u#34425:u32
        let s_631_1: u32 = fn_state.u_34425;
        // D s_631_2: cast zx s_631_1 -> bv
        let s_631_2: Bits = Bits::new(s_631_1 as u128, 32u16);
        // C s_631_3: const #1s : i64
        let s_631_3: i64 = 1;
        // C s_631_4: cast zx s_631_3 -> i
        let s_631_4: i128 = (i128::try_from(s_631_3).unwrap());
        // C s_631_5: const #3s : i
        let s_631_5: i128 = 3;
        // C s_631_6: add s_631_5 s_631_4
        let s_631_6: i128 = (s_631_5 + s_631_4);
        // D s_631_7: bit-extract s_631_2 s_631_0 s_631_6
        let s_631_7: Bits = (Bits::new(
            ((s_631_2) >> (s_631_0)).value(),
            u16::try_from(s_631_6).unwrap(),
        ));
        // D s_631_8: cast reint s_631_7 -> u8
        let s_631_8: u8 = (s_631_7.value() as u8);
        // D s_631_9: cast zx s_631_8 -> bv
        let s_631_9: Bits = Bits::new(s_631_8 as u128, 4u16);
        // C s_631_10: const #8u : u8
        let s_631_10: u8 = 8;
        // C s_631_11: cast zx s_631_10 -> bv
        let s_631_11: Bits = Bits::new(s_631_10 as u128, 4u16);
        // D s_631_12: cmp-eq s_631_9 s_631_11
        let s_631_12: bool = ((s_631_9) == (s_631_11));
        // N s_631_13: branch s_631_12 b634 b632
        if s_631_12 {
            return block_634(state, tracer, fn_state);
        } else {
            return block_632(state, tracer, fn_state);
        };
    }
    fn block_632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_632_0: const #0u : u8
        let s_632_0: bool = false;
        // D s_632_1: write-var gs#413712 <= s_632_0
        fn_state.gs_413712 = s_632_0;
        // N s_632_2: jump b633
        return block_633(state, tracer, fn_state);
    }
    fn block_633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_633_0: read-var gs#413712:u8
        let s_633_0: bool = fn_state.gs_413712;
        // D s_633_1: write-var gs#413713 <= s_633_0
        fn_state.gs_413713 = s_633_0;
        // N s_633_2: jump b630
        return block_630(state, tracer, fn_state);
    }
    fn block_634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_634_0: const #4s : i
        let s_634_0: i128 = 4;
        // D s_634_1: read-var u#34425:u32
        let s_634_1: u32 = fn_state.u_34425;
        // D s_634_2: cast zx s_634_1 -> bv
        let s_634_2: Bits = Bits::new(s_634_1 as u128, 32u16);
        // C s_634_3: const #1s : i64
        let s_634_3: i64 = 1;
        // C s_634_4: cast zx s_634_3 -> i
        let s_634_4: i128 = (i128::try_from(s_634_3).unwrap());
        // C s_634_5: const #0s : i
        let s_634_5: i128 = 0;
        // C s_634_6: add s_634_5 s_634_4
        let s_634_6: i128 = (s_634_5 + s_634_4);
        // D s_634_7: bit-extract s_634_2 s_634_0 s_634_6
        let s_634_7: Bits = (Bits::new(
            ((s_634_2) >> (s_634_0)).value(),
            u16::try_from(s_634_6).unwrap(),
        ));
        // D s_634_8: cast reint s_634_7 -> u8
        let s_634_8: bool = ((s_634_7.value()) != 0);
        // D s_634_9: cast zx s_634_8 -> bv
        let s_634_9: Bits = Bits::new(s_634_8 as u128, 1u16);
        // C s_634_10: const #1u : u8
        let s_634_10: bool = true;
        // C s_634_11: cast zx s_634_10 -> bv
        let s_634_11: Bits = Bits::new(s_634_10 as u128, 1u16);
        // D s_634_12: cmp-eq s_634_9 s_634_11
        let s_634_12: bool = ((s_634_9) == (s_634_11));
        // D s_634_13: write-var gs#413712 <= s_634_12
        fn_state.gs_413712 = s_634_12;
        // N s_634_14: jump b633
        return block_633(state, tracer, fn_state);
    }
    fn block_635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_635_0: const #3910s : i
        let s_635_0: i128 = 3910;
        // C s_635_1: const #14696u : u32
        let s_635_1: u32 = 14696;
        // D s_635_2: read-reg s_635_1:i
        let s_635_2: i128 = {
            let value = state.read_register::<i128>(s_635_1 as isize);
            tracer.read_register(s_635_1 as isize, value);
            value
        };
        // D s_635_3: cmp-lt s_635_2 s_635_0
        let s_635_3: bool = ((s_635_2) < (s_635_0));
        // D s_635_4: write-var gs#413682 <= s_635_3
        fn_state.gs_413682 = s_635_3;
        // N s_635_5: jump b458
        return block_458(state, tracer, fn_state);
    }
    fn block_636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_636_0: const #23s : i
        let s_636_0: i128 = 23;
        // D s_636_1: read-var u#34414:u32
        let s_636_1: u32 = fn_state.u_34414;
        // D s_636_2: cast zx s_636_1 -> bv
        let s_636_2: Bits = Bits::new(s_636_1 as u128, 32u16);
        // C s_636_3: const #1s : i64
        let s_636_3: i64 = 1;
        // C s_636_4: cast zx s_636_3 -> i
        let s_636_4: i128 = (i128::try_from(s_636_3).unwrap());
        // C s_636_5: const #0s : i
        let s_636_5: i128 = 0;
        // C s_636_6: add s_636_5 s_636_4
        let s_636_6: i128 = (s_636_5 + s_636_4);
        // D s_636_7: bit-extract s_636_2 s_636_0 s_636_6
        let s_636_7: Bits = (Bits::new(
            ((s_636_2) >> (s_636_0)).value(),
            u16::try_from(s_636_6).unwrap(),
        ));
        // D s_636_8: cast reint s_636_7 -> u8
        let s_636_8: bool = ((s_636_7.value()) != 0);
        // D s_636_9: cast zx s_636_8 -> bv
        let s_636_9: Bits = Bits::new(s_636_8 as u128, 1u16);
        // C s_636_10: const #1u : u8
        let s_636_10: bool = true;
        // C s_636_11: cast zx s_636_10 -> bv
        let s_636_11: Bits = Bits::new(s_636_10 as u128, 1u16);
        // D s_636_12: cmp-eq s_636_9 s_636_11
        let s_636_12: bool = ((s_636_9) == (s_636_11));
        // N s_636_13: branch s_636_12 b639 b637
        if s_636_12 {
            return block_639(state, tracer, fn_state);
        } else {
            return block_637(state, tracer, fn_state);
        };
    }
    fn block_637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_637_0: const #0u : u8
        let s_637_0: bool = false;
        // D s_637_1: write-var gs#413679 <= s_637_0
        fn_state.gs_413679 = s_637_0;
        // N s_637_2: jump b638
        return block_638(state, tracer, fn_state);
    }
    fn block_638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_638_0: read-var gs#413679:u8
        let s_638_0: bool = fn_state.gs_413679;
        // D s_638_1: write-var gs#413680 <= s_638_0
        fn_state.gs_413680 = s_638_0;
        // N s_638_2: jump b456
        return block_456(state, tracer, fn_state);
    }
    fn block_639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_639_0: const #21s : i
        let s_639_0: i128 = 21;
        // D s_639_1: read-var u#34414:u32
        let s_639_1: u32 = fn_state.u_34414;
        // D s_639_2: cast zx s_639_1 -> bv
        let s_639_2: Bits = Bits::new(s_639_1 as u128, 32u16);
        // C s_639_3: const #1s : i64
        let s_639_3: i64 = 1;
        // C s_639_4: cast zx s_639_3 -> i
        let s_639_4: i128 = (i128::try_from(s_639_3).unwrap());
        // C s_639_5: const #0s : i
        let s_639_5: i128 = 0;
        // C s_639_6: add s_639_5 s_639_4
        let s_639_6: i128 = (s_639_5 + s_639_4);
        // D s_639_7: bit-extract s_639_2 s_639_0 s_639_6
        let s_639_7: Bits = (Bits::new(
            ((s_639_2) >> (s_639_0)).value(),
            u16::try_from(s_639_6).unwrap(),
        ));
        // D s_639_8: cast reint s_639_7 -> u8
        let s_639_8: bool = ((s_639_7.value()) != 0);
        // D s_639_9: cast zx s_639_8 -> bv
        let s_639_9: Bits = Bits::new(s_639_8 as u128, 1u16);
        // C s_639_10: const #0u : u8
        let s_639_10: bool = false;
        // C s_639_11: cast zx s_639_10 -> bv
        let s_639_11: Bits = Bits::new(s_639_10 as u128, 1u16);
        // D s_639_12: cmp-eq s_639_9 s_639_11
        let s_639_12: bool = ((s_639_9) == (s_639_11));
        // N s_639_13: branch s_639_12 b642 b640
        if s_639_12 {
            return block_642(state, tracer, fn_state);
        } else {
            return block_640(state, tracer, fn_state);
        };
    }
    fn block_640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_640_0: const #0u : u8
        let s_640_0: bool = false;
        // D s_640_1: write-var gs#413678 <= s_640_0
        fn_state.gs_413678 = s_640_0;
        // N s_640_2: jump b641
        return block_641(state, tracer, fn_state);
    }
    fn block_641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_641_0: read-var gs#413678:u8
        let s_641_0: bool = fn_state.gs_413678;
        // D s_641_1: write-var gs#413679 <= s_641_0
        fn_state.gs_413679 = s_641_0;
        // N s_641_2: jump b638
        return block_638(state, tracer, fn_state);
    }
    fn block_642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_642_0: const #8s : i
        let s_642_0: i128 = 8;
        // D s_642_1: read-var u#34414:u32
        let s_642_1: u32 = fn_state.u_34414;
        // D s_642_2: cast zx s_642_1 -> bv
        let s_642_2: Bits = Bits::new(s_642_1 as u128, 32u16);
        // C s_642_3: const #1s : i64
        let s_642_3: i64 = 1;
        // C s_642_4: cast zx s_642_3 -> i
        let s_642_4: i128 = (i128::try_from(s_642_3).unwrap());
        // C s_642_5: const #3s : i
        let s_642_5: i128 = 3;
        // C s_642_6: add s_642_5 s_642_4
        let s_642_6: i128 = (s_642_5 + s_642_4);
        // D s_642_7: bit-extract s_642_2 s_642_0 s_642_6
        let s_642_7: Bits = (Bits::new(
            ((s_642_2) >> (s_642_0)).value(),
            u16::try_from(s_642_6).unwrap(),
        ));
        // D s_642_8: cast reint s_642_7 -> u8
        let s_642_8: u8 = (s_642_7.value() as u8);
        // D s_642_9: cast zx s_642_8 -> bv
        let s_642_9: Bits = Bits::new(s_642_8 as u128, 4u16);
        // C s_642_10: const #8u : u8
        let s_642_10: u8 = 8;
        // C s_642_11: cast zx s_642_10 -> bv
        let s_642_11: Bits = Bits::new(s_642_10 as u128, 4u16);
        // D s_642_12: cmp-eq s_642_9 s_642_11
        let s_642_12: bool = ((s_642_9) == (s_642_11));
        // N s_642_13: branch s_642_12 b645 b643
        if s_642_12 {
            return block_645(state, tracer, fn_state);
        } else {
            return block_643(state, tracer, fn_state);
        };
    }
    fn block_643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_643_0: const #0u : u8
        let s_643_0: bool = false;
        // D s_643_1: write-var gs#413677 <= s_643_0
        fn_state.gs_413677 = s_643_0;
        // N s_643_2: jump b644
        return block_644(state, tracer, fn_state);
    }
    fn block_644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_644_0: read-var gs#413677:u8
        let s_644_0: bool = fn_state.gs_413677;
        // D s_644_1: write-var gs#413678 <= s_644_0
        fn_state.gs_413678 = s_644_0;
        // N s_644_2: jump b641
        return block_641(state, tracer, fn_state);
    }
    fn block_645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_645_0: const #4s : i
        let s_645_0: i128 = 4;
        // D s_645_1: read-var u#34414:u32
        let s_645_1: u32 = fn_state.u_34414;
        // D s_645_2: cast zx s_645_1 -> bv
        let s_645_2: Bits = Bits::new(s_645_1 as u128, 32u16);
        // C s_645_3: const #1s : i64
        let s_645_3: i64 = 1;
        // C s_645_4: cast zx s_645_3 -> i
        let s_645_4: i128 = (i128::try_from(s_645_3).unwrap());
        // C s_645_5: const #0s : i
        let s_645_5: i128 = 0;
        // C s_645_6: add s_645_5 s_645_4
        let s_645_6: i128 = (s_645_5 + s_645_4);
        // D s_645_7: bit-extract s_645_2 s_645_0 s_645_6
        let s_645_7: Bits = (Bits::new(
            ((s_645_2) >> (s_645_0)).value(),
            u16::try_from(s_645_6).unwrap(),
        ));
        // D s_645_8: cast reint s_645_7 -> u8
        let s_645_8: bool = ((s_645_7.value()) != 0);
        // D s_645_9: cast zx s_645_8 -> bv
        let s_645_9: Bits = Bits::new(s_645_8 as u128, 1u16);
        // C s_645_10: const #0u : u8
        let s_645_10: bool = false;
        // C s_645_11: cast zx s_645_10 -> bv
        let s_645_11: Bits = Bits::new(s_645_10 as u128, 1u16);
        // D s_645_12: cmp-eq s_645_9 s_645_11
        let s_645_12: bool = ((s_645_9) == (s_645_11));
        // D s_645_13: write-var gs#413677 <= s_645_12
        fn_state.gs_413677 = s_645_12;
        // N s_645_14: jump b644
        return block_644(state, tracer, fn_state);
    }
    fn block_646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_646_0: const #3908s : i
        let s_646_0: i128 = 3908;
        // C s_646_1: const #14696u : u32
        let s_646_1: u32 = 14696;
        // D s_646_2: read-reg s_646_1:i
        let s_646_2: i128 = {
            let value = state.read_register::<i128>(s_646_1 as isize);
            tracer.read_register(s_646_1 as isize, value);
            value
        };
        // D s_646_3: cmp-lt s_646_2 s_646_0
        let s_646_3: bool = ((s_646_2) < (s_646_0));
        // D s_646_4: write-var gs#413645 <= s_646_3
        fn_state.gs_413645 = s_646_3;
        // N s_646_5: jump b452
        return block_452(state, tracer, fn_state);
    }
    fn block_647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_647_0: const #8s : i
        let s_647_0: i128 = 8;
        // D s_647_1: read-var u#34403:u32
        let s_647_1: u32 = fn_state.u_34403;
        // D s_647_2: cast zx s_647_1 -> bv
        let s_647_2: Bits = Bits::new(s_647_1 as u128, 32u16);
        // C s_647_3: const #1s : i64
        let s_647_3: i64 = 1;
        // C s_647_4: cast zx s_647_3 -> i
        let s_647_4: i128 = (i128::try_from(s_647_3).unwrap());
        // C s_647_5: const #3s : i
        let s_647_5: i128 = 3;
        // C s_647_6: add s_647_5 s_647_4
        let s_647_6: i128 = (s_647_5 + s_647_4);
        // D s_647_7: bit-extract s_647_2 s_647_0 s_647_6
        let s_647_7: Bits = (Bits::new(
            ((s_647_2) >> (s_647_0)).value(),
            u16::try_from(s_647_6).unwrap(),
        ));
        // D s_647_8: cast reint s_647_7 -> u8
        let s_647_8: u8 = (s_647_7.value() as u8);
        // D s_647_9: cast zx s_647_8 -> bv
        let s_647_9: Bits = Bits::new(s_647_8 as u128, 4u16);
        // C s_647_10: const #8u : u8
        let s_647_10: u8 = 8;
        // C s_647_11: cast zx s_647_10 -> bv
        let s_647_11: Bits = Bits::new(s_647_10 as u128, 4u16);
        // D s_647_12: cmp-eq s_647_9 s_647_11
        let s_647_12: bool = ((s_647_9) == (s_647_11));
        // N s_647_13: branch s_647_12 b650 b648
        if s_647_12 {
            return block_650(state, tracer, fn_state);
        } else {
            return block_648(state, tracer, fn_state);
        };
    }
    fn block_648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_648_0: const #0u : u8
        let s_648_0: bool = false;
        // D s_648_1: write-var gs#413642 <= s_648_0
        fn_state.gs_413642 = s_648_0;
        // N s_648_2: jump b649
        return block_649(state, tracer, fn_state);
    }
    fn block_649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_649_0: read-var gs#413642:u8
        let s_649_0: bool = fn_state.gs_413642;
        // D s_649_1: write-var gs#413643 <= s_649_0
        fn_state.gs_413643 = s_649_0;
        // N s_649_2: jump b450
        return block_450(state, tracer, fn_state);
    }
    fn block_650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_650_0: const #4s : i
        let s_650_0: i128 = 4;
        // D s_650_1: read-var u#34403:u32
        let s_650_1: u32 = fn_state.u_34403;
        // D s_650_2: cast zx s_650_1 -> bv
        let s_650_2: Bits = Bits::new(s_650_1 as u128, 32u16);
        // C s_650_3: const #1s : i64
        let s_650_3: i64 = 1;
        // C s_650_4: cast zx s_650_3 -> i
        let s_650_4: i128 = (i128::try_from(s_650_3).unwrap());
        // C s_650_5: const #0s : i
        let s_650_5: i128 = 0;
        // C s_650_6: add s_650_5 s_650_4
        let s_650_6: i128 = (s_650_5 + s_650_4);
        // D s_650_7: bit-extract s_650_2 s_650_0 s_650_6
        let s_650_7: Bits = (Bits::new(
            ((s_650_2) >> (s_650_0)).value(),
            u16::try_from(s_650_6).unwrap(),
        ));
        // D s_650_8: cast reint s_650_7 -> u8
        let s_650_8: bool = ((s_650_7.value()) != 0);
        // D s_650_9: cast zx s_650_8 -> bv
        let s_650_9: Bits = Bits::new(s_650_8 as u128, 1u16);
        // C s_650_10: const #0u : u8
        let s_650_10: bool = false;
        // C s_650_11: cast zx s_650_10 -> bv
        let s_650_11: Bits = Bits::new(s_650_10 as u128, 1u16);
        // D s_650_12: cmp-eq s_650_9 s_650_11
        let s_650_12: bool = ((s_650_9) == (s_650_11));
        // D s_650_13: write-var gs#413642 <= s_650_12
        fn_state.gs_413642 = s_650_12;
        // N s_650_14: jump b649
        return block_649(state, tracer, fn_state);
    }
    fn block_651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_651_0: const #3906s : i
        let s_651_0: i128 = 3906;
        // C s_651_1: const #14696u : u32
        let s_651_1: u32 = 14696;
        // D s_651_2: read-reg s_651_1:i
        let s_651_2: i128 = {
            let value = state.read_register::<i128>(s_651_1 as isize);
            tracer.read_register(s_651_1 as isize, value);
            value
        };
        // D s_651_3: cmp-lt s_651_2 s_651_0
        let s_651_3: bool = ((s_651_2) < (s_651_0));
        // D s_651_4: write-var gs#413614 <= s_651_3
        fn_state.gs_413614 = s_651_3;
        // N s_651_5: jump b446
        return block_446(state, tracer, fn_state);
    }
    fn block_652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_652_0: const #21s : i
        let s_652_0: i128 = 21;
        // D s_652_1: read-var u#34394:u32
        let s_652_1: u32 = fn_state.u_34394;
        // D s_652_2: cast zx s_652_1 -> bv
        let s_652_2: Bits = Bits::new(s_652_1 as u128, 32u16);
        // C s_652_3: const #1s : i64
        let s_652_3: i64 = 1;
        // C s_652_4: cast zx s_652_3 -> i
        let s_652_4: i128 = (i128::try_from(s_652_3).unwrap());
        // C s_652_5: const #0s : i
        let s_652_5: i128 = 0;
        // C s_652_6: add s_652_5 s_652_4
        let s_652_6: i128 = (s_652_5 + s_652_4);
        // D s_652_7: bit-extract s_652_2 s_652_0 s_652_6
        let s_652_7: Bits = (Bits::new(
            ((s_652_2) >> (s_652_0)).value(),
            u16::try_from(s_652_6).unwrap(),
        ));
        // D s_652_8: cast reint s_652_7 -> u8
        let s_652_8: bool = ((s_652_7.value()) != 0);
        // D s_652_9: cast zx s_652_8 -> bv
        let s_652_9: Bits = Bits::new(s_652_8 as u128, 1u16);
        // C s_652_10: const #1u : u8
        let s_652_10: bool = true;
        // C s_652_11: cast zx s_652_10 -> bv
        let s_652_11: Bits = Bits::new(s_652_10 as u128, 1u16);
        // D s_652_12: cmp-eq s_652_9 s_652_11
        let s_652_12: bool = ((s_652_9) == (s_652_11));
        // N s_652_13: branch s_652_12 b655 b653
        if s_652_12 {
            return block_655(state, tracer, fn_state);
        } else {
            return block_653(state, tracer, fn_state);
        };
    }
    fn block_653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_653_0: const #0u : u8
        let s_653_0: bool = false;
        // D s_653_1: write-var gs#413611 <= s_653_0
        fn_state.gs_413611 = s_653_0;
        // N s_653_2: jump b654
        return block_654(state, tracer, fn_state);
    }
    fn block_654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_654_0: read-var gs#413611:u8
        let s_654_0: bool = fn_state.gs_413611;
        // D s_654_1: write-var gs#413612 <= s_654_0
        fn_state.gs_413612 = s_654_0;
        // N s_654_2: jump b444
        return block_444(state, tracer, fn_state);
    }
    fn block_655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_655_0: const #8s : i
        let s_655_0: i128 = 8;
        // D s_655_1: read-var u#34394:u32
        let s_655_1: u32 = fn_state.u_34394;
        // D s_655_2: cast zx s_655_1 -> bv
        let s_655_2: Bits = Bits::new(s_655_1 as u128, 32u16);
        // C s_655_3: const #1s : i64
        let s_655_3: i64 = 1;
        // C s_655_4: cast zx s_655_3 -> i
        let s_655_4: i128 = (i128::try_from(s_655_3).unwrap());
        // C s_655_5: const #3s : i
        let s_655_5: i128 = 3;
        // C s_655_6: add s_655_5 s_655_4
        let s_655_6: i128 = (s_655_5 + s_655_4);
        // D s_655_7: bit-extract s_655_2 s_655_0 s_655_6
        let s_655_7: Bits = (Bits::new(
            ((s_655_2) >> (s_655_0)).value(),
            u16::try_from(s_655_6).unwrap(),
        ));
        // D s_655_8: cast reint s_655_7 -> u8
        let s_655_8: u8 = (s_655_7.value() as u8);
        // D s_655_9: cast zx s_655_8 -> bv
        let s_655_9: Bits = Bits::new(s_655_8 as u128, 4u16);
        // C s_655_10: const #8u : u8
        let s_655_10: u8 = 8;
        // C s_655_11: cast zx s_655_10 -> bv
        let s_655_11: Bits = Bits::new(s_655_10 as u128, 4u16);
        // D s_655_12: cmp-eq s_655_9 s_655_11
        let s_655_12: bool = ((s_655_9) == (s_655_11));
        // N s_655_13: branch s_655_12 b658 b656
        if s_655_12 {
            return block_658(state, tracer, fn_state);
        } else {
            return block_656(state, tracer, fn_state);
        };
    }
    fn block_656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_656_0: const #0u : u8
        let s_656_0: bool = false;
        // D s_656_1: write-var gs#413610 <= s_656_0
        fn_state.gs_413610 = s_656_0;
        // N s_656_2: jump b657
        return block_657(state, tracer, fn_state);
    }
    fn block_657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_657_0: read-var gs#413610:u8
        let s_657_0: bool = fn_state.gs_413610;
        // D s_657_1: write-var gs#413611 <= s_657_0
        fn_state.gs_413611 = s_657_0;
        // N s_657_2: jump b654
        return block_654(state, tracer, fn_state);
    }
    fn block_658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_658_0: const #4s : i
        let s_658_0: i128 = 4;
        // D s_658_1: read-var u#34394:u32
        let s_658_1: u32 = fn_state.u_34394;
        // D s_658_2: cast zx s_658_1 -> bv
        let s_658_2: Bits = Bits::new(s_658_1 as u128, 32u16);
        // C s_658_3: const #1s : i64
        let s_658_3: i64 = 1;
        // C s_658_4: cast zx s_658_3 -> i
        let s_658_4: i128 = (i128::try_from(s_658_3).unwrap());
        // C s_658_5: const #0s : i
        let s_658_5: i128 = 0;
        // C s_658_6: add s_658_5 s_658_4
        let s_658_6: i128 = (s_658_5 + s_658_4);
        // D s_658_7: bit-extract s_658_2 s_658_0 s_658_6
        let s_658_7: Bits = (Bits::new(
            ((s_658_2) >> (s_658_0)).value(),
            u16::try_from(s_658_6).unwrap(),
        ));
        // D s_658_8: cast reint s_658_7 -> u8
        let s_658_8: bool = ((s_658_7.value()) != 0);
        // D s_658_9: cast zx s_658_8 -> bv
        let s_658_9: Bits = Bits::new(s_658_8 as u128, 1u16);
        // C s_658_10: const #0u : u8
        let s_658_10: bool = false;
        // C s_658_11: cast zx s_658_10 -> bv
        let s_658_11: Bits = Bits::new(s_658_10 as u128, 1u16);
        // D s_658_12: cmp-eq s_658_9 s_658_11
        let s_658_12: bool = ((s_658_9) == (s_658_11));
        // D s_658_13: write-var gs#413610 <= s_658_12
        fn_state.gs_413610 = s_658_12;
        // N s_658_14: jump b657
        return block_657(state, tracer, fn_state);
    }
    fn block_659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_659_0: const #28s : i
        let s_659_0: i128 = 28;
        // C s_659_1: const #4s : i
        let s_659_1: i128 = 4;
        // D s_659_2: read-var u#34387:u32
        let s_659_2: u32 = fn_state.u_34387;
        // D s_659_3: cast zx s_659_2 -> bv
        let s_659_3: Bits = Bits::new(s_659_2 as u128, 32u16);
        // D s_659_4: bit-extract s_659_3 s_659_0 s_659_1
        let s_659_4: Bits = (Bits::new(
            ((s_659_3) >> (s_659_0)).value(),
            u16::try_from(s_659_1).unwrap(),
        ));
        // D s_659_5: cast reint s_659_4 -> u8
        let s_659_5: u8 = (s_659_4.value() as u8);
        // D s_659_6: cast zx s_659_5 -> bv
        let s_659_6: Bits = Bits::new(s_659_5 as u128, 4u16);
        // C s_659_7: const #15u : u8
        let s_659_7: u8 = 15;
        // C s_659_8: cast zx s_659_7 -> bv
        let s_659_8: Bits = Bits::new(s_659_7 as u128, 4u16);
        // D s_659_9: cmp-ne s_659_6 s_659_8
        let s_659_9: bool = ((s_659_6) != (s_659_8));
        // N s_659_10: branch s_659_9 b662 b660
        if s_659_9 {
            return block_662(state, tracer, fn_state);
        } else {
            return block_660(state, tracer, fn_state);
        };
    }
    fn block_660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_660_0: const #0u : u8
        let s_660_0: bool = false;
        // D s_660_1: write-var gs#413587 <= s_660_0
        fn_state.gs_413587 = s_660_0;
        // N s_660_2: jump b661
        return block_661(state, tracer, fn_state);
    }
    fn block_661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_661_0: read-var gs#413587:u8
        let s_661_0: bool = fn_state.gs_413587;
        // D s_661_1: write-var gs#413588 <= s_661_0
        fn_state.gs_413588 = s_661_0;
        // N s_661_2: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_662_0: const #3904s : i
        let s_662_0: i128 = 3904;
        // C s_662_1: const #14696u : u32
        let s_662_1: u32 = 14696;
        // D s_662_2: read-reg s_662_1:i
        let s_662_2: i128 = {
            let value = state.read_register::<i128>(s_662_1 as isize);
            tracer.read_register(s_662_1 as isize, value);
            value
        };
        // D s_662_3: cmp-lt s_662_2 s_662_0
        let s_662_3: bool = ((s_662_2) < (s_662_0));
        // D s_662_4: write-var gs#413587 <= s_662_3
        fn_state.gs_413587 = s_662_3;
        // N s_662_5: jump b661
        return block_661(state, tracer, fn_state);
    }
    fn block_663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_663_0: const #16s : i
        let s_663_0: i128 = 16;
        // D s_663_1: read-var u#34387:u32
        let s_663_1: u32 = fn_state.u_34387;
        // D s_663_2: cast zx s_663_1 -> bv
        let s_663_2: Bits = Bits::new(s_663_1 as u128, 32u16);
        // C s_663_3: const #1s : i64
        let s_663_3: i64 = 1;
        // C s_663_4: cast zx s_663_3 -> i
        let s_663_4: i128 = (i128::try_from(s_663_3).unwrap());
        // C s_663_5: const #5s : i
        let s_663_5: i128 = 5;
        // C s_663_6: add s_663_5 s_663_4
        let s_663_6: i128 = (s_663_5 + s_663_4);
        // D s_663_7: bit-extract s_663_2 s_663_0 s_663_6
        let s_663_7: Bits = (Bits::new(
            ((s_663_2) >> (s_663_0)).value(),
            u16::try_from(s_663_6).unwrap(),
        ));
        // D s_663_8: cast reint s_663_7 -> u8
        let s_663_8: u8 = (s_663_7.value() as u8);
        // D s_663_9: cast zx s_663_8 -> bv
        let s_663_9: Bits = Bits::new(s_663_8 as u128, 6u16);
        // C s_663_10: const #57u : u8
        let s_663_10: u8 = 57;
        // C s_663_11: cast zx s_663_10 -> bv
        let s_663_11: Bits = Bits::new(s_663_10 as u128, 6u16);
        // D s_663_12: cmp-eq s_663_9 s_663_11
        let s_663_12: bool = ((s_663_9) == (s_663_11));
        // N s_663_13: branch s_663_12 b666 b664
        if s_663_12 {
            return block_666(state, tracer, fn_state);
        } else {
            return block_664(state, tracer, fn_state);
        };
    }
    fn block_664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_664_0: const #0u : u8
        let s_664_0: bool = false;
        // D s_664_1: write-var gs#413582 <= s_664_0
        fn_state.gs_413582 = s_664_0;
        // N s_664_2: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_665_0: read-var gs#413582:u8
        let s_665_0: bool = fn_state.gs_413582;
        // D s_665_1: write-var gs#413583 <= s_665_0
        fn_state.gs_413583 = s_665_0;
        // N s_665_2: jump b438
        return block_438(state, tracer, fn_state);
    }
    fn block_666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_666_0: const #6s : i
        let s_666_0: i128 = 6;
        // D s_666_1: read-var u#34387:u32
        let s_666_1: u32 = fn_state.u_34387;
        // D s_666_2: cast zx s_666_1 -> bv
        let s_666_2: Bits = Bits::new(s_666_1 as u128, 32u16);
        // C s_666_3: const #1s : i64
        let s_666_3: i64 = 1;
        // C s_666_4: cast zx s_666_3 -> i
        let s_666_4: i128 = (i128::try_from(s_666_3).unwrap());
        // C s_666_5: const #5s : i
        let s_666_5: i128 = 5;
        // C s_666_6: add s_666_5 s_666_4
        let s_666_6: i128 = (s_666_5 + s_666_4);
        // D s_666_7: bit-extract s_666_2 s_666_0 s_666_6
        let s_666_7: Bits = (Bits::new(
            ((s_666_2) >> (s_666_0)).value(),
            u16::try_from(s_666_6).unwrap(),
        ));
        // D s_666_8: cast reint s_666_7 -> u8
        let s_666_8: u8 = (s_666_7.value() as u8);
        // D s_666_9: cast zx s_666_8 -> bv
        let s_666_9: Bits = Bits::new(s_666_8 as u128, 6u16);
        // C s_666_10: const #47u : u8
        let s_666_10: u8 = 47;
        // C s_666_11: cast zx s_666_10 -> bv
        let s_666_11: Bits = Bits::new(s_666_10 as u128, 6u16);
        // D s_666_12: cmp-eq s_666_9 s_666_11
        let s_666_12: bool = ((s_666_9) == (s_666_11));
        // N s_666_13: branch s_666_12 b669 b667
        if s_666_12 {
            return block_669(state, tracer, fn_state);
        } else {
            return block_667(state, tracer, fn_state);
        };
    }
    fn block_667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_667_0: const #0u : u8
        let s_667_0: bool = false;
        // D s_667_1: write-var gs#413581 <= s_667_0
        fn_state.gs_413581 = s_667_0;
        // N s_667_2: jump b668
        return block_668(state, tracer, fn_state);
    }
    fn block_668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_668_0: read-var gs#413581:u8
        let s_668_0: bool = fn_state.gs_413581;
        // D s_668_1: write-var gs#413582 <= s_668_0
        fn_state.gs_413582 = s_668_0;
        // N s_668_2: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_669_0: const #4s : i
        let s_669_0: i128 = 4;
        // D s_669_1: read-var u#34387:u32
        let s_669_1: u32 = fn_state.u_34387;
        // D s_669_2: cast zx s_669_1 -> bv
        let s_669_2: Bits = Bits::new(s_669_1 as u128, 32u16);
        // C s_669_3: const #1s : i64
        let s_669_3: i64 = 1;
        // C s_669_4: cast zx s_669_3 -> i
        let s_669_4: i128 = (i128::try_from(s_669_3).unwrap());
        // C s_669_5: const #0s : i
        let s_669_5: i128 = 0;
        // C s_669_6: add s_669_5 s_669_4
        let s_669_6: i128 = (s_669_5 + s_669_4);
        // D s_669_7: bit-extract s_669_2 s_669_0 s_669_6
        let s_669_7: Bits = (Bits::new(
            ((s_669_2) >> (s_669_0)).value(),
            u16::try_from(s_669_6).unwrap(),
        ));
        // D s_669_8: cast reint s_669_7 -> u8
        let s_669_8: bool = ((s_669_7.value()) != 0);
        // D s_669_9: cast zx s_669_8 -> bv
        let s_669_9: Bits = Bits::new(s_669_8 as u128, 1u16);
        // C s_669_10: const #0u : u8
        let s_669_10: bool = false;
        // C s_669_11: cast zx s_669_10 -> bv
        let s_669_11: Bits = Bits::new(s_669_10 as u128, 1u16);
        // D s_669_12: cmp-eq s_669_9 s_669_11
        let s_669_12: bool = ((s_669_9) == (s_669_11));
        // D s_669_13: write-var gs#413581 <= s_669_12
        fn_state.gs_413581 = s_669_12;
        // N s_669_14: jump b668
        return block_668(state, tracer, fn_state);
    }
    fn block_670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_670_0: const #3902s : i
        let s_670_0: i128 = 3902;
        // C s_670_1: const #14696u : u32
        let s_670_1: u32 = 14696;
        // D s_670_2: read-reg s_670_1:i
        let s_670_2: i128 = {
            let value = state.read_register::<i128>(s_670_1 as isize);
            tracer.read_register(s_670_1 as isize, value);
            value
        };
        // D s_670_3: cmp-lt s_670_2 s_670_0
        let s_670_3: bool = ((s_670_2) < (s_670_0));
        // D s_670_4: write-var gs#413549 <= s_670_3
        fn_state.gs_413549 = s_670_3;
        // N s_670_5: jump b434
        return block_434(state, tracer, fn_state);
    }
    fn block_671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_671_0: const #20s : i
        let s_671_0: i128 = 20;
        // D s_671_1: read-var u#34377:u32
        let s_671_1: u32 = fn_state.u_34377;
        // D s_671_2: cast zx s_671_1 -> bv
        let s_671_2: Bits = Bits::new(s_671_1 as u128, 32u16);
        // C s_671_3: const #1s : i64
        let s_671_3: i64 = 1;
        // C s_671_4: cast zx s_671_3 -> i
        let s_671_4: i128 = (i128::try_from(s_671_3).unwrap());
        // C s_671_5: const #1s : i
        let s_671_5: i128 = 1;
        // C s_671_6: add s_671_5 s_671_4
        let s_671_6: i128 = (s_671_5 + s_671_4);
        // D s_671_7: bit-extract s_671_2 s_671_0 s_671_6
        let s_671_7: Bits = (Bits::new(
            ((s_671_2) >> (s_671_0)).value(),
            u16::try_from(s_671_6).unwrap(),
        ));
        // D s_671_8: cast reint s_671_7 -> u8
        let s_671_8: u8 = (s_671_7.value() as u8);
        // D s_671_9: cast zx s_671_8 -> bv
        let s_671_9: Bits = Bits::new(s_671_8 as u128, 2u16);
        // C s_671_10: const #2u : u8
        let s_671_10: u8 = 2;
        // C s_671_11: cast zx s_671_10 -> bv
        let s_671_11: Bits = Bits::new(s_671_10 as u128, 2u16);
        // D s_671_12: cmp-eq s_671_9 s_671_11
        let s_671_12: bool = ((s_671_9) == (s_671_11));
        // N s_671_13: branch s_671_12 b674 b672
        if s_671_12 {
            return block_674(state, tracer, fn_state);
        } else {
            return block_672(state, tracer, fn_state);
        };
    }
    fn block_672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_672_0: const #0u : u8
        let s_672_0: bool = false;
        // D s_672_1: write-var gs#413546 <= s_672_0
        fn_state.gs_413546 = s_672_0;
        // N s_672_2: jump b673
        return block_673(state, tracer, fn_state);
    }
    fn block_673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_673_0: read-var gs#413546:u8
        let s_673_0: bool = fn_state.gs_413546;
        // D s_673_1: write-var gs#413547 <= s_673_0
        fn_state.gs_413547 = s_673_0;
        // N s_673_2: jump b432
        return block_432(state, tracer, fn_state);
    }
    fn block_674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_674_0: const #8s : i
        let s_674_0: i128 = 8;
        // D s_674_1: read-var u#34377:u32
        let s_674_1: u32 = fn_state.u_34377;
        // D s_674_2: cast zx s_674_1 -> bv
        let s_674_2: Bits = Bits::new(s_674_1 as u128, 32u16);
        // C s_674_3: const #1s : i64
        let s_674_3: i64 = 1;
        // C s_674_4: cast zx s_674_3 -> i
        let s_674_4: i128 = (i128::try_from(s_674_3).unwrap());
        // C s_674_5: const #3s : i
        let s_674_5: i128 = 3;
        // C s_674_6: add s_674_5 s_674_4
        let s_674_6: i128 = (s_674_5 + s_674_4);
        // D s_674_7: bit-extract s_674_2 s_674_0 s_674_6
        let s_674_7: Bits = (Bits::new(
            ((s_674_2) >> (s_674_0)).value(),
            u16::try_from(s_674_6).unwrap(),
        ));
        // D s_674_8: cast reint s_674_7 -> u8
        let s_674_8: u8 = (s_674_7.value() as u8);
        // D s_674_9: cast zx s_674_8 -> bv
        let s_674_9: Bits = Bits::new(s_674_8 as u128, 4u16);
        // C s_674_10: const #13u : u8
        let s_674_10: u8 = 13;
        // C s_674_11: cast zx s_674_10 -> bv
        let s_674_11: Bits = Bits::new(s_674_10 as u128, 4u16);
        // D s_674_12: cmp-eq s_674_9 s_674_11
        let s_674_12: bool = ((s_674_9) == (s_674_11));
        // D s_674_13: write-var gs#413546 <= s_674_12
        fn_state.gs_413546 = s_674_12;
        // N s_674_14: jump b673
        return block_673(state, tracer, fn_state);
    }
    fn block_675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_675_0: const #3900s : i
        let s_675_0: i128 = 3900;
        // C s_675_1: const #14696u : u32
        let s_675_1: u32 = 14696;
        // D s_675_2: read-reg s_675_1:i
        let s_675_2: i128 = {
            let value = state.read_register::<i128>(s_675_1 as isize);
            tracer.read_register(s_675_1 as isize, value);
            value
        };
        // D s_675_3: cmp-lt s_675_2 s_675_0
        let s_675_3: bool = ((s_675_2) < (s_675_0));
        // D s_675_4: write-var gs#413520 <= s_675_3
        fn_state.gs_413520 = s_675_3;
        // N s_675_5: jump b428
        return block_428(state, tracer, fn_state);
    }
    fn block_676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_676_0: const #20s : i
        let s_676_0: i128 = 20;
        // D s_676_1: read-var u#34367:u32
        let s_676_1: u32 = fn_state.u_34367;
        // D s_676_2: cast zx s_676_1 -> bv
        let s_676_2: Bits = Bits::new(s_676_1 as u128, 32u16);
        // C s_676_3: const #1s : i64
        let s_676_3: i64 = 1;
        // C s_676_4: cast zx s_676_3 -> i
        let s_676_4: i128 = (i128::try_from(s_676_3).unwrap());
        // C s_676_5: const #1s : i
        let s_676_5: i128 = 1;
        // C s_676_6: add s_676_5 s_676_4
        let s_676_6: i128 = (s_676_5 + s_676_4);
        // D s_676_7: bit-extract s_676_2 s_676_0 s_676_6
        let s_676_7: Bits = (Bits::new(
            ((s_676_2) >> (s_676_0)).value(),
            u16::try_from(s_676_6).unwrap(),
        ));
        // D s_676_8: cast reint s_676_7 -> u8
        let s_676_8: u8 = (s_676_7.value() as u8);
        // D s_676_9: cast zx s_676_8 -> bv
        let s_676_9: Bits = Bits::new(s_676_8 as u128, 2u16);
        // C s_676_10: const #2u : u8
        let s_676_10: u8 = 2;
        // C s_676_11: cast zx s_676_10 -> bv
        let s_676_11: Bits = Bits::new(s_676_10 as u128, 2u16);
        // D s_676_12: cmp-eq s_676_9 s_676_11
        let s_676_12: bool = ((s_676_9) == (s_676_11));
        // N s_676_13: branch s_676_12 b679 b677
        if s_676_12 {
            return block_679(state, tracer, fn_state);
        } else {
            return block_677(state, tracer, fn_state);
        };
    }
    fn block_677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_677_0: const #0u : u8
        let s_677_0: bool = false;
        // D s_677_1: write-var gs#413517 <= s_677_0
        fn_state.gs_413517 = s_677_0;
        // N s_677_2: jump b678
        return block_678(state, tracer, fn_state);
    }
    fn block_678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_678_0: read-var gs#413517:u8
        let s_678_0: bool = fn_state.gs_413517;
        // D s_678_1: write-var gs#413518 <= s_678_0
        fn_state.gs_413518 = s_678_0;
        // N s_678_2: jump b426
        return block_426(state, tracer, fn_state);
    }
    fn block_679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_679_0: const #8s : i
        let s_679_0: i128 = 8;
        // D s_679_1: read-var u#34367:u32
        let s_679_1: u32 = fn_state.u_34367;
        // D s_679_2: cast zx s_679_1 -> bv
        let s_679_2: Bits = Bits::new(s_679_1 as u128, 32u16);
        // C s_679_3: const #1s : i64
        let s_679_3: i64 = 1;
        // C s_679_4: cast zx s_679_3 -> i
        let s_679_4: i128 = (i128::try_from(s_679_3).unwrap());
        // C s_679_5: const #3s : i
        let s_679_5: i128 = 3;
        // C s_679_6: add s_679_5 s_679_4
        let s_679_6: i128 = (s_679_5 + s_679_4);
        // D s_679_7: bit-extract s_679_2 s_679_0 s_679_6
        let s_679_7: Bits = (Bits::new(
            ((s_679_2) >> (s_679_0)).value(),
            u16::try_from(s_679_6).unwrap(),
        ));
        // D s_679_8: cast reint s_679_7 -> u8
        let s_679_8: u8 = (s_679_7.value() as u8);
        // D s_679_9: cast zx s_679_8 -> bv
        let s_679_9: Bits = Bits::new(s_679_8 as u128, 4u16);
        // C s_679_10: const #13u : u8
        let s_679_10: u8 = 13;
        // C s_679_11: cast zx s_679_10 -> bv
        let s_679_11: Bits = Bits::new(s_679_10 as u128, 4u16);
        // D s_679_12: cmp-eq s_679_9 s_679_11
        let s_679_12: bool = ((s_679_9) == (s_679_11));
        // D s_679_13: write-var gs#413517 <= s_679_12
        fn_state.gs_413517 = s_679_12;
        // N s_679_14: jump b678
        return block_678(state, tracer, fn_state);
    }
    fn block_680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_680_0: const #3886s : i
        let s_680_0: i128 = 3886;
        // C s_680_1: const #14696u : u32
        let s_680_1: u32 = 14696;
        // D s_680_2: read-reg s_680_1:i
        let s_680_2: i128 = {
            let value = state.read_register::<i128>(s_680_1 as isize);
            tracer.read_register(s_680_1 as isize, value);
            value
        };
        // D s_680_3: cmp-lt s_680_2 s_680_0
        let s_680_3: bool = ((s_680_2) < (s_680_0));
        // D s_680_4: write-var gs#413491 <= s_680_3
        fn_state.gs_413491 = s_680_3;
        // N s_680_5: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_681_0: const #10s : i
        let s_681_0: i128 = 10;
        // D s_681_1: read-var u#34358:u32
        let s_681_1: u32 = fn_state.u_34358;
        // D s_681_2: cast zx s_681_1 -> bv
        let s_681_2: Bits = Bits::new(s_681_1 as u128, 32u16);
        // C s_681_3: const #1s : i64
        let s_681_3: i64 = 1;
        // C s_681_4: cast zx s_681_3 -> i
        let s_681_4: i128 = (i128::try_from(s_681_3).unwrap());
        // C s_681_5: const #1s : i
        let s_681_5: i128 = 1;
        // C s_681_6: add s_681_5 s_681_4
        let s_681_6: i128 = (s_681_5 + s_681_4);
        // D s_681_7: bit-extract s_681_2 s_681_0 s_681_6
        let s_681_7: Bits = (Bits::new(
            ((s_681_2) >> (s_681_0)).value(),
            u16::try_from(s_681_6).unwrap(),
        ));
        // D s_681_8: cast reint s_681_7 -> u8
        let s_681_8: u8 = (s_681_7.value() as u8);
        // D s_681_9: cast zx s_681_8 -> bv
        let s_681_9: Bits = Bits::new(s_681_8 as u128, 2u16);
        // C s_681_10: const #2u : u8
        let s_681_10: u8 = 2;
        // C s_681_11: cast zx s_681_10 -> bv
        let s_681_11: Bits = Bits::new(s_681_10 as u128, 2u16);
        // D s_681_12: cmp-eq s_681_9 s_681_11
        let s_681_12: bool = ((s_681_9) == (s_681_11));
        // N s_681_13: branch s_681_12 b684 b682
        if s_681_12 {
            return block_684(state, tracer, fn_state);
        } else {
            return block_682(state, tracer, fn_state);
        };
    }
    fn block_682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_682_0: const #0u : u8
        let s_682_0: bool = false;
        // D s_682_1: write-var gs#413488 <= s_682_0
        fn_state.gs_413488 = s_682_0;
        // N s_682_2: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_683_0: read-var gs#413488:u8
        let s_683_0: bool = fn_state.gs_413488;
        // D s_683_1: write-var gs#413489 <= s_683_0
        fn_state.gs_413489 = s_683_0;
        // N s_683_2: jump b420
        return block_420(state, tracer, fn_state);
    }
    fn block_684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_684_0: const #6s : i
        let s_684_0: i128 = 6;
        // D s_684_1: read-var u#34358:u32
        let s_684_1: u32 = fn_state.u_34358;
        // D s_684_2: cast zx s_684_1 -> bv
        let s_684_2: Bits = Bits::new(s_684_1 as u128, 32u16);
        // C s_684_3: const #1s : i64
        let s_684_3: i64 = 1;
        // C s_684_4: cast zx s_684_3 -> i
        let s_684_4: i128 = (i128::try_from(s_684_3).unwrap());
        // C s_684_5: const #0s : i
        let s_684_5: i128 = 0;
        // C s_684_6: add s_684_5 s_684_4
        let s_684_6: i128 = (s_684_5 + s_684_4);
        // D s_684_7: bit-extract s_684_2 s_684_0 s_684_6
        let s_684_7: Bits = (Bits::new(
            ((s_684_2) >> (s_684_0)).value(),
            u16::try_from(s_684_6).unwrap(),
        ));
        // D s_684_8: cast reint s_684_7 -> u8
        let s_684_8: bool = ((s_684_7.value()) != 0);
        // D s_684_9: cast zx s_684_8 -> bv
        let s_684_9: Bits = Bits::new(s_684_8 as u128, 1u16);
        // C s_684_10: const #0u : u8
        let s_684_10: bool = false;
        // C s_684_11: cast zx s_684_10 -> bv
        let s_684_11: Bits = Bits::new(s_684_10 as u128, 1u16);
        // D s_684_12: cmp-eq s_684_9 s_684_11
        let s_684_12: bool = ((s_684_9) == (s_684_11));
        // N s_684_13: branch s_684_12 b687 b685
        if s_684_12 {
            return block_687(state, tracer, fn_state);
        } else {
            return block_685(state, tracer, fn_state);
        };
    }
    fn block_685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_685_0: const #0u : u8
        let s_685_0: bool = false;
        // D s_685_1: write-var gs#413487 <= s_685_0
        fn_state.gs_413487 = s_685_0;
        // N s_685_2: jump b686
        return block_686(state, tracer, fn_state);
    }
    fn block_686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_686_0: read-var gs#413487:u8
        let s_686_0: bool = fn_state.gs_413487;
        // D s_686_1: write-var gs#413488 <= s_686_0
        fn_state.gs_413488 = s_686_0;
        // N s_686_2: jump b683
        return block_683(state, tracer, fn_state);
    }
    fn block_687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_687_0: const #4s : i
        let s_687_0: i128 = 4;
        // D s_687_1: read-var u#34358:u32
        let s_687_1: u32 = fn_state.u_34358;
        // D s_687_2: cast zx s_687_1 -> bv
        let s_687_2: Bits = Bits::new(s_687_1 as u128, 32u16);
        // C s_687_3: const #1s : i64
        let s_687_3: i64 = 1;
        // C s_687_4: cast zx s_687_3 -> i
        let s_687_4: i128 = (i128::try_from(s_687_3).unwrap());
        // C s_687_5: const #0s : i
        let s_687_5: i128 = 0;
        // C s_687_6: add s_687_5 s_687_4
        let s_687_6: i128 = (s_687_5 + s_687_4);
        // D s_687_7: bit-extract s_687_2 s_687_0 s_687_6
        let s_687_7: Bits = (Bits::new(
            ((s_687_2) >> (s_687_0)).value(),
            u16::try_from(s_687_6).unwrap(),
        ));
        // D s_687_8: cast reint s_687_7 -> u8
        let s_687_8: bool = ((s_687_7.value()) != 0);
        // D s_687_9: cast zx s_687_8 -> bv
        let s_687_9: Bits = Bits::new(s_687_8 as u128, 1u16);
        // C s_687_10: const #0u : u8
        let s_687_10: bool = false;
        // C s_687_11: cast zx s_687_10 -> bv
        let s_687_11: Bits = Bits::new(s_687_10 as u128, 1u16);
        // D s_687_12: cmp-eq s_687_9 s_687_11
        let s_687_12: bool = ((s_687_9) == (s_687_11));
        // D s_687_13: write-var gs#413487 <= s_687_12
        fn_state.gs_413487 = s_687_12;
        // N s_687_14: jump b686
        return block_686(state, tracer, fn_state);
    }
    fn block_688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_688_0: const #28s : i
        let s_688_0: i128 = 28;
        // C s_688_1: const #4s : i
        let s_688_1: i128 = 4;
        // D s_688_2: read-var u#34349:u32
        let s_688_2: u32 = fn_state.u_34349;
        // D s_688_3: cast zx s_688_2 -> bv
        let s_688_3: Bits = Bits::new(s_688_2 as u128, 32u16);
        // D s_688_4: bit-extract s_688_3 s_688_0 s_688_1
        let s_688_4: Bits = (Bits::new(
            ((s_688_3) >> (s_688_0)).value(),
            u16::try_from(s_688_1).unwrap(),
        ));
        // D s_688_5: cast reint s_688_4 -> u8
        let s_688_5: u8 = (s_688_4.value() as u8);
        // D s_688_6: cast zx s_688_5 -> bv
        let s_688_6: Bits = Bits::new(s_688_5 as u128, 4u16);
        // C s_688_7: const #15u : u8
        let s_688_7: u8 = 15;
        // C s_688_8: cast zx s_688_7 -> bv
        let s_688_8: Bits = Bits::new(s_688_7 as u128, 4u16);
        // D s_688_9: cmp-ne s_688_6 s_688_8
        let s_688_9: bool = ((s_688_6) != (s_688_8));
        // N s_688_10: branch s_688_9 b691 b689
        if s_688_9 {
            return block_691(state, tracer, fn_state);
        } else {
            return block_689(state, tracer, fn_state);
        };
    }
    fn block_689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_689_0: const #0u : u8
        let s_689_0: bool = false;
        // D s_689_1: write-var gs#413460 <= s_689_0
        fn_state.gs_413460 = s_689_0;
        // N s_689_2: jump b690
        return block_690(state, tracer, fn_state);
    }
    fn block_690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_690_0: read-var gs#413460:u8
        let s_690_0: bool = fn_state.gs_413460;
        // D s_690_1: write-var gs#413461 <= s_690_0
        fn_state.gs_413461 = s_690_0;
        // N s_690_2: jump b416
        return block_416(state, tracer, fn_state);
    }
    fn block_691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_691_0: const #3884s : i
        let s_691_0: i128 = 3884;
        // C s_691_1: const #14696u : u32
        let s_691_1: u32 = 14696;
        // D s_691_2: read-reg s_691_1:i
        let s_691_2: i128 = {
            let value = state.read_register::<i128>(s_691_1 as isize);
            tracer.read_register(s_691_1 as isize, value);
            value
        };
        // D s_691_3: cmp-lt s_691_2 s_691_0
        let s_691_3: bool = ((s_691_2) < (s_691_0));
        // D s_691_4: write-var gs#413460 <= s_691_3
        fn_state.gs_413460 = s_691_3;
        // N s_691_5: jump b690
        return block_690(state, tracer, fn_state);
    }
    fn block_692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_692_0: const #16s : i
        let s_692_0: i128 = 16;
        // D s_692_1: read-var u#34349:u32
        let s_692_1: u32 = fn_state.u_34349;
        // D s_692_2: cast zx s_692_1 -> bv
        let s_692_2: Bits = Bits::new(s_692_1 as u128, 32u16);
        // C s_692_3: const #1s : i64
        let s_692_3: i64 = 1;
        // C s_692_4: cast zx s_692_3 -> i
        let s_692_4: i128 = (i128::try_from(s_692_3).unwrap());
        // C s_692_5: const #5s : i
        let s_692_5: i128 = 5;
        // C s_692_6: add s_692_5 s_692_4
        let s_692_6: i128 = (s_692_5 + s_692_4);
        // D s_692_7: bit-extract s_692_2 s_692_0 s_692_6
        let s_692_7: Bits = (Bits::new(
            ((s_692_2) >> (s_692_0)).value(),
            u16::try_from(s_692_6).unwrap(),
        ));
        // D s_692_8: cast reint s_692_7 -> u8
        let s_692_8: u8 = (s_692_7.value() as u8);
        // D s_692_9: cast zx s_692_8 -> bv
        let s_692_9: Bits = Bits::new(s_692_8 as u128, 6u16);
        // C s_692_10: const #54u : u8
        let s_692_10: u8 = 54;
        // C s_692_11: cast zx s_692_10 -> bv
        let s_692_11: Bits = Bits::new(s_692_10 as u128, 6u16);
        // D s_692_12: cmp-eq s_692_9 s_692_11
        let s_692_12: bool = ((s_692_9) == (s_692_11));
        // N s_692_13: branch s_692_12 b695 b693
        if s_692_12 {
            return block_695(state, tracer, fn_state);
        } else {
            return block_693(state, tracer, fn_state);
        };
    }
    fn block_693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_693_0: const #0u : u8
        let s_693_0: bool = false;
        // D s_693_1: write-var gs#413455 <= s_693_0
        fn_state.gs_413455 = s_693_0;
        // N s_693_2: jump b694
        return block_694(state, tracer, fn_state);
    }
    fn block_694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_694_0: read-var gs#413455:u8
        let s_694_0: bool = fn_state.gs_413455;
        // D s_694_1: write-var gs#413456 <= s_694_0
        fn_state.gs_413456 = s_694_0;
        // N s_694_2: jump b414
        return block_414(state, tracer, fn_state);
    }
    fn block_695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_695_0: const #10s : i
        let s_695_0: i128 = 10;
        // D s_695_1: read-var u#34349:u32
        let s_695_1: u32 = fn_state.u_34349;
        // D s_695_2: cast zx s_695_1 -> bv
        let s_695_2: Bits = Bits::new(s_695_1 as u128, 32u16);
        // C s_695_3: const #1s : i64
        let s_695_3: i64 = 1;
        // C s_695_4: cast zx s_695_3 -> i
        let s_695_4: i128 = (i128::try_from(s_695_3).unwrap());
        // C s_695_5: const #1s : i
        let s_695_5: i128 = 1;
        // C s_695_6: add s_695_5 s_695_4
        let s_695_6: i128 = (s_695_5 + s_695_4);
        // D s_695_7: bit-extract s_695_2 s_695_0 s_695_6
        let s_695_7: Bits = (Bits::new(
            ((s_695_2) >> (s_695_0)).value(),
            u16::try_from(s_695_6).unwrap(),
        ));
        // D s_695_8: cast reint s_695_7 -> u8
        let s_695_8: u8 = (s_695_7.value() as u8);
        // D s_695_9: cast zx s_695_8 -> bv
        let s_695_9: Bits = Bits::new(s_695_8 as u128, 2u16);
        // C s_695_10: const #2u : u8
        let s_695_10: u8 = 2;
        // C s_695_11: cast zx s_695_10 -> bv
        let s_695_11: Bits = Bits::new(s_695_10 as u128, 2u16);
        // D s_695_12: cmp-eq s_695_9 s_695_11
        let s_695_12: bool = ((s_695_9) == (s_695_11));
        // N s_695_13: branch s_695_12 b698 b696
        if s_695_12 {
            return block_698(state, tracer, fn_state);
        } else {
            return block_696(state, tracer, fn_state);
        };
    }
    fn block_696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_696_0: const #0u : u8
        let s_696_0: bool = false;
        // D s_696_1: write-var gs#413454 <= s_696_0
        fn_state.gs_413454 = s_696_0;
        // N s_696_2: jump b697
        return block_697(state, tracer, fn_state);
    }
    fn block_697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_697_0: read-var gs#413454:u8
        let s_697_0: bool = fn_state.gs_413454;
        // D s_697_1: write-var gs#413455 <= s_697_0
        fn_state.gs_413455 = s_697_0;
        // N s_697_2: jump b694
        return block_694(state, tracer, fn_state);
    }
    fn block_698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_698_0: const #6s : i
        let s_698_0: i128 = 6;
        // D s_698_1: read-var u#34349:u32
        let s_698_1: u32 = fn_state.u_34349;
        // D s_698_2: cast zx s_698_1 -> bv
        let s_698_2: Bits = Bits::new(s_698_1 as u128, 32u16);
        // C s_698_3: const #1s : i64
        let s_698_3: i64 = 1;
        // C s_698_4: cast zx s_698_3 -> i
        let s_698_4: i128 = (i128::try_from(s_698_3).unwrap());
        // C s_698_5: const #0s : i
        let s_698_5: i128 = 0;
        // C s_698_6: add s_698_5 s_698_4
        let s_698_6: i128 = (s_698_5 + s_698_4);
        // D s_698_7: bit-extract s_698_2 s_698_0 s_698_6
        let s_698_7: Bits = (Bits::new(
            ((s_698_2) >> (s_698_0)).value(),
            u16::try_from(s_698_6).unwrap(),
        ));
        // D s_698_8: cast reint s_698_7 -> u8
        let s_698_8: bool = ((s_698_7.value()) != 0);
        // D s_698_9: cast zx s_698_8 -> bv
        let s_698_9: Bits = Bits::new(s_698_8 as u128, 1u16);
        // C s_698_10: const #1u : u8
        let s_698_10: bool = true;
        // C s_698_11: cast zx s_698_10 -> bv
        let s_698_11: Bits = Bits::new(s_698_10 as u128, 1u16);
        // D s_698_12: cmp-eq s_698_9 s_698_11
        let s_698_12: bool = ((s_698_9) == (s_698_11));
        // N s_698_13: branch s_698_12 b701 b699
        if s_698_12 {
            return block_701(state, tracer, fn_state);
        } else {
            return block_699(state, tracer, fn_state);
        };
    }
    fn block_699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_699_0: const #0u : u8
        let s_699_0: bool = false;
        // D s_699_1: write-var gs#413453 <= s_699_0
        fn_state.gs_413453 = s_699_0;
        // N s_699_2: jump b700
        return block_700(state, tracer, fn_state);
    }
    fn block_700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_700_0: read-var gs#413453:u8
        let s_700_0: bool = fn_state.gs_413453;
        // D s_700_1: write-var gs#413454 <= s_700_0
        fn_state.gs_413454 = s_700_0;
        // N s_700_2: jump b697
        return block_697(state, tracer, fn_state);
    }
    fn block_701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_701_0: const #4s : i
        let s_701_0: i128 = 4;
        // D s_701_1: read-var u#34349:u32
        let s_701_1: u32 = fn_state.u_34349;
        // D s_701_2: cast zx s_701_1 -> bv
        let s_701_2: Bits = Bits::new(s_701_1 as u128, 32u16);
        // C s_701_3: const #1s : i64
        let s_701_3: i64 = 1;
        // C s_701_4: cast zx s_701_3 -> i
        let s_701_4: i128 = (i128::try_from(s_701_3).unwrap());
        // C s_701_5: const #0s : i
        let s_701_5: i128 = 0;
        // C s_701_6: add s_701_5 s_701_4
        let s_701_6: i128 = (s_701_5 + s_701_4);
        // D s_701_7: bit-extract s_701_2 s_701_0 s_701_6
        let s_701_7: Bits = (Bits::new(
            ((s_701_2) >> (s_701_0)).value(),
            u16::try_from(s_701_6).unwrap(),
        ));
        // D s_701_8: cast reint s_701_7 -> u8
        let s_701_8: bool = ((s_701_7.value()) != 0);
        // D s_701_9: cast zx s_701_8 -> bv
        let s_701_9: Bits = Bits::new(s_701_8 as u128, 1u16);
        // C s_701_10: const #0u : u8
        let s_701_10: bool = false;
        // C s_701_11: cast zx s_701_10 -> bv
        let s_701_11: Bits = Bits::new(s_701_10 as u128, 1u16);
        // D s_701_12: cmp-eq s_701_9 s_701_11
        let s_701_12: bool = ((s_701_9) == (s_701_11));
        // D s_701_13: write-var gs#413453 <= s_701_12
        fn_state.gs_413453 = s_701_12;
        // N s_701_14: jump b700
        return block_700(state, tracer, fn_state);
    }
    fn block_702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_702_0: const #28s : i
        let s_702_0: i128 = 28;
        // C s_702_1: const #4s : i
        let s_702_1: i128 = 4;
        // D s_702_2: read-var u#34341:u32
        let s_702_2: u32 = fn_state.u_34341;
        // D s_702_3: cast zx s_702_2 -> bv
        let s_702_3: Bits = Bits::new(s_702_2 as u128, 32u16);
        // D s_702_4: bit-extract s_702_3 s_702_0 s_702_1
        let s_702_4: Bits = (Bits::new(
            ((s_702_3) >> (s_702_0)).value(),
            u16::try_from(s_702_1).unwrap(),
        ));
        // D s_702_5: cast reint s_702_4 -> u8
        let s_702_5: u8 = (s_702_4.value() as u8);
        // D s_702_6: cast zx s_702_5 -> bv
        let s_702_6: Bits = Bits::new(s_702_5 as u128, 4u16);
        // C s_702_7: const #15u : u8
        let s_702_7: u8 = 15;
        // C s_702_8: cast zx s_702_7 -> bv
        let s_702_8: Bits = Bits::new(s_702_7 as u128, 4u16);
        // D s_702_9: cmp-ne s_702_6 s_702_8
        let s_702_9: bool = ((s_702_6) != (s_702_8));
        // N s_702_10: branch s_702_9 b705 b703
        if s_702_9 {
            return block_705(state, tracer, fn_state);
        } else {
            return block_703(state, tracer, fn_state);
        };
    }
    fn block_703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_703_0: const #0u : u8
        let s_703_0: bool = false;
        // D s_703_1: write-var gs#413426 <= s_703_0
        fn_state.gs_413426 = s_703_0;
        // N s_703_2: jump b704
        return block_704(state, tracer, fn_state);
    }
    fn block_704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_704_0: read-var gs#413426:u8
        let s_704_0: bool = fn_state.gs_413426;
        // D s_704_1: write-var gs#413427 <= s_704_0
        fn_state.gs_413427 = s_704_0;
        // N s_704_2: jump b410
        return block_410(state, tracer, fn_state);
    }
    fn block_705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_705_0: const #3880s : i
        let s_705_0: i128 = 3880;
        // C s_705_1: const #14696u : u32
        let s_705_1: u32 = 14696;
        // D s_705_2: read-reg s_705_1:i
        let s_705_2: i128 = {
            let value = state.read_register::<i128>(s_705_1 as isize);
            tracer.read_register(s_705_1 as isize, value);
            value
        };
        // D s_705_3: cmp-lt s_705_2 s_705_0
        let s_705_3: bool = ((s_705_2) < (s_705_0));
        // D s_705_4: write-var gs#413426 <= s_705_3
        fn_state.gs_413426 = s_705_3;
        // N s_705_5: jump b704
        return block_704(state, tracer, fn_state);
    }
    fn block_706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_706_0: const #16s : i
        let s_706_0: i128 = 16;
        // D s_706_1: read-var u#34341:u32
        let s_706_1: u32 = fn_state.u_34341;
        // D s_706_2: cast zx s_706_1 -> bv
        let s_706_2: Bits = Bits::new(s_706_1 as u128, 32u16);
        // C s_706_3: const #1s : i64
        let s_706_3: i64 = 1;
        // C s_706_4: cast zx s_706_3 -> i
        let s_706_4: i128 = (i128::try_from(s_706_3).unwrap());
        // C s_706_5: const #5s : i
        let s_706_5: i128 = 5;
        // C s_706_6: add s_706_5 s_706_4
        let s_706_6: i128 = (s_706_5 + s_706_4);
        // D s_706_7: bit-extract s_706_2 s_706_0 s_706_6
        let s_706_7: Bits = (Bits::new(
            ((s_706_2) >> (s_706_0)).value(),
            u16::try_from(s_706_6).unwrap(),
        ));
        // D s_706_8: cast reint s_706_7 -> u8
        let s_706_8: u8 = (s_706_7.value() as u8);
        // D s_706_9: cast zx s_706_8 -> bv
        let s_706_9: Bits = Bits::new(s_706_8 as u128, 6u16);
        // C s_706_10: const #55u : u8
        let s_706_10: u8 = 55;
        // C s_706_11: cast zx s_706_10 -> bv
        let s_706_11: Bits = Bits::new(s_706_10 as u128, 6u16);
        // D s_706_12: cmp-eq s_706_9 s_706_11
        let s_706_12: bool = ((s_706_9) == (s_706_11));
        // N s_706_13: branch s_706_12 b709 b707
        if s_706_12 {
            return block_709(state, tracer, fn_state);
        } else {
            return block_707(state, tracer, fn_state);
        };
    }
    fn block_707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_707_0: const #0u : u8
        let s_707_0: bool = false;
        // D s_707_1: write-var gs#413421 <= s_707_0
        fn_state.gs_413421 = s_707_0;
        // N s_707_2: jump b708
        return block_708(state, tracer, fn_state);
    }
    fn block_708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_708_0: read-var gs#413421:u8
        let s_708_0: bool = fn_state.gs_413421;
        // D s_708_1: write-var gs#413422 <= s_708_0
        fn_state.gs_413422 = s_708_0;
        // N s_708_2: jump b408
        return block_408(state, tracer, fn_state);
    }
    fn block_709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_709_0: const #10s : i
        let s_709_0: i128 = 10;
        // D s_709_1: read-var u#34341:u32
        let s_709_1: u32 = fn_state.u_34341;
        // D s_709_2: cast zx s_709_1 -> bv
        let s_709_2: Bits = Bits::new(s_709_1 as u128, 32u16);
        // C s_709_3: const #1s : i64
        let s_709_3: i64 = 1;
        // C s_709_4: cast zx s_709_3 -> i
        let s_709_4: i128 = (i128::try_from(s_709_3).unwrap());
        // C s_709_5: const #1s : i
        let s_709_5: i128 = 1;
        // C s_709_6: add s_709_5 s_709_4
        let s_709_6: i128 = (s_709_5 + s_709_4);
        // D s_709_7: bit-extract s_709_2 s_709_0 s_709_6
        let s_709_7: Bits = (Bits::new(
            ((s_709_2) >> (s_709_0)).value(),
            u16::try_from(s_709_6).unwrap(),
        ));
        // D s_709_8: cast reint s_709_7 -> u8
        let s_709_8: u8 = (s_709_7.value() as u8);
        // D s_709_9: cast zx s_709_8 -> bv
        let s_709_9: Bits = Bits::new(s_709_8 as u128, 2u16);
        // C s_709_10: const #2u : u8
        let s_709_10: u8 = 2;
        // C s_709_11: cast zx s_709_10 -> bv
        let s_709_11: Bits = Bits::new(s_709_10 as u128, 2u16);
        // D s_709_12: cmp-eq s_709_9 s_709_11
        let s_709_12: bool = ((s_709_9) == (s_709_11));
        // N s_709_13: branch s_709_12 b712 b710
        if s_709_12 {
            return block_712(state, tracer, fn_state);
        } else {
            return block_710(state, tracer, fn_state);
        };
    }
    fn block_710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_710_0: const #0u : u8
        let s_710_0: bool = false;
        // D s_710_1: write-var gs#413420 <= s_710_0
        fn_state.gs_413420 = s_710_0;
        // N s_710_2: jump b711
        return block_711(state, tracer, fn_state);
    }
    fn block_711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_711_0: read-var gs#413420:u8
        let s_711_0: bool = fn_state.gs_413420;
        // D s_711_1: write-var gs#413421 <= s_711_0
        fn_state.gs_413421 = s_711_0;
        // N s_711_2: jump b708
        return block_708(state, tracer, fn_state);
    }
    fn block_712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_712_0: const #6s : i
        let s_712_0: i128 = 6;
        // D s_712_1: read-var u#34341:u32
        let s_712_1: u32 = fn_state.u_34341;
        // D s_712_2: cast zx s_712_1 -> bv
        let s_712_2: Bits = Bits::new(s_712_1 as u128, 32u16);
        // C s_712_3: const #1s : i64
        let s_712_3: i64 = 1;
        // C s_712_4: cast zx s_712_3 -> i
        let s_712_4: i128 = (i128::try_from(s_712_3).unwrap());
        // C s_712_5: const #1s : i
        let s_712_5: i128 = 1;
        // C s_712_6: add s_712_5 s_712_4
        let s_712_6: i128 = (s_712_5 + s_712_4);
        // D s_712_7: bit-extract s_712_2 s_712_0 s_712_6
        let s_712_7: Bits = (Bits::new(
            ((s_712_2) >> (s_712_0)).value(),
            u16::try_from(s_712_6).unwrap(),
        ));
        // D s_712_8: cast reint s_712_7 -> u8
        let s_712_8: u8 = (s_712_7.value() as u8);
        // D s_712_9: cast zx s_712_8 -> bv
        let s_712_9: Bits = Bits::new(s_712_8 as u128, 2u16);
        // C s_712_10: const #1u : u8
        let s_712_10: u8 = 1;
        // C s_712_11: cast zx s_712_10 -> bv
        let s_712_11: Bits = Bits::new(s_712_10 as u128, 2u16);
        // D s_712_12: cmp-eq s_712_9 s_712_11
        let s_712_12: bool = ((s_712_9) == (s_712_11));
        // N s_712_13: branch s_712_12 b715 b713
        if s_712_12 {
            return block_715(state, tracer, fn_state);
        } else {
            return block_713(state, tracer, fn_state);
        };
    }
    fn block_713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_713_0: const #0u : u8
        let s_713_0: bool = false;
        // D s_713_1: write-var gs#413419 <= s_713_0
        fn_state.gs_413419 = s_713_0;
        // N s_713_2: jump b714
        return block_714(state, tracer, fn_state);
    }
    fn block_714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_714_0: read-var gs#413419:u8
        let s_714_0: bool = fn_state.gs_413419;
        // D s_714_1: write-var gs#413420 <= s_714_0
        fn_state.gs_413420 = s_714_0;
        // N s_714_2: jump b711
        return block_711(state, tracer, fn_state);
    }
    fn block_715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_715_0: const #4s : i
        let s_715_0: i128 = 4;
        // D s_715_1: read-var u#34341:u32
        let s_715_1: u32 = fn_state.u_34341;
        // D s_715_2: cast zx s_715_1 -> bv
        let s_715_2: Bits = Bits::new(s_715_1 as u128, 32u16);
        // C s_715_3: const #1s : i64
        let s_715_3: i64 = 1;
        // C s_715_4: cast zx s_715_3 -> i
        let s_715_4: i128 = (i128::try_from(s_715_3).unwrap());
        // C s_715_5: const #0s : i
        let s_715_5: i128 = 0;
        // C s_715_6: add s_715_5 s_715_4
        let s_715_6: i128 = (s_715_5 + s_715_4);
        // D s_715_7: bit-extract s_715_2 s_715_0 s_715_6
        let s_715_7: Bits = (Bits::new(
            ((s_715_2) >> (s_715_0)).value(),
            u16::try_from(s_715_6).unwrap(),
        ));
        // D s_715_8: cast reint s_715_7 -> u8
        let s_715_8: bool = ((s_715_7.value()) != 0);
        // D s_715_9: cast zx s_715_8 -> bv
        let s_715_9: Bits = Bits::new(s_715_8 as u128, 1u16);
        // C s_715_10: const #0u : u8
        let s_715_10: bool = false;
        // C s_715_11: cast zx s_715_10 -> bv
        let s_715_11: Bits = Bits::new(s_715_10 as u128, 1u16);
        // D s_715_12: cmp-eq s_715_9 s_715_11
        let s_715_12: bool = ((s_715_9) == (s_715_11));
        // D s_715_13: write-var gs#413419 <= s_715_12
        fn_state.gs_413419 = s_715_12;
        // N s_715_14: jump b714
        return block_714(state, tracer, fn_state);
    }
    fn block_716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_716_0: const #3876s : i
        let s_716_0: i128 = 3876;
        // C s_716_1: const #14696u : u32
        let s_716_1: u32 = 14696;
        // D s_716_2: read-reg s_716_1:i
        let s_716_2: i128 = {
            let value = state.read_register::<i128>(s_716_1 as isize);
            tracer.read_register(s_716_1 as isize, value);
            value
        };
        // D s_716_3: cmp-lt s_716_2 s_716_0
        let s_716_3: bool = ((s_716_2) < (s_716_0));
        // D s_716_4: write-var gs#413393 <= s_716_3
        fn_state.gs_413393 = s_716_3;
        // N s_716_5: jump b404
        return block_404(state, tracer, fn_state);
    }
    fn block_717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_717_0: const #18s : i
        let s_717_0: i128 = 18;
        // D s_717_1: read-var u#34333:u32
        let s_717_1: u32 = fn_state.u_34333;
        // D s_717_2: cast zx s_717_1 -> bv
        let s_717_2: Bits = Bits::new(s_717_1 as u128, 32u16);
        // C s_717_3: const #1s : i64
        let s_717_3: i64 = 1;
        // C s_717_4: cast zx s_717_3 -> i
        let s_717_4: i128 = (i128::try_from(s_717_3).unwrap());
        // C s_717_5: const #3s : i
        let s_717_5: i128 = 3;
        // C s_717_6: add s_717_5 s_717_4
        let s_717_6: i128 = (s_717_5 + s_717_4);
        // D s_717_7: bit-extract s_717_2 s_717_0 s_717_6
        let s_717_7: Bits = (Bits::new(
            ((s_717_2) >> (s_717_0)).value(),
            u16::try_from(s_717_6).unwrap(),
        ));
        // D s_717_8: cast reint s_717_7 -> u8
        let s_717_8: u8 = (s_717_7.value() as u8);
        // D s_717_9: cast zx s_717_8 -> bv
        let s_717_9: Bits = Bits::new(s_717_8 as u128, 4u16);
        // C s_717_10: const #14u : u8
        let s_717_10: u8 = 14;
        // C s_717_11: cast zx s_717_10 -> bv
        let s_717_11: Bits = Bits::new(s_717_10 as u128, 4u16);
        // D s_717_12: cmp-eq s_717_9 s_717_11
        let s_717_12: bool = ((s_717_9) == (s_717_11));
        // N s_717_13: branch s_717_12 b720 b718
        if s_717_12 {
            return block_720(state, tracer, fn_state);
        } else {
            return block_718(state, tracer, fn_state);
        };
    }
    fn block_718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_718_0: const #0u : u8
        let s_718_0: bool = false;
        // D s_718_1: write-var gs#413390 <= s_718_0
        fn_state.gs_413390 = s_718_0;
        // N s_718_2: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_719_0: read-var gs#413390:u8
        let s_719_0: bool = fn_state.gs_413390;
        // D s_719_1: write-var gs#413391 <= s_719_0
        fn_state.gs_413391 = s_719_0;
        // N s_719_2: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_720_0: const #10s : i
        let s_720_0: i128 = 10;
        // D s_720_1: read-var u#34333:u32
        let s_720_1: u32 = fn_state.u_34333;
        // D s_720_2: cast zx s_720_1 -> bv
        let s_720_2: Bits = Bits::new(s_720_1 as u128, 32u16);
        // C s_720_3: const #1s : i64
        let s_720_3: i64 = 1;
        // C s_720_4: cast zx s_720_3 -> i
        let s_720_4: i128 = (i128::try_from(s_720_3).unwrap());
        // C s_720_5: const #1s : i
        let s_720_5: i128 = 1;
        // C s_720_6: add s_720_5 s_720_4
        let s_720_6: i128 = (s_720_5 + s_720_4);
        // D s_720_7: bit-extract s_720_2 s_720_0 s_720_6
        let s_720_7: Bits = (Bits::new(
            ((s_720_2) >> (s_720_0)).value(),
            u16::try_from(s_720_6).unwrap(),
        ));
        // D s_720_8: cast reint s_720_7 -> u8
        let s_720_8: u8 = (s_720_7.value() as u8);
        // D s_720_9: cast zx s_720_8 -> bv
        let s_720_9: Bits = Bits::new(s_720_8 as u128, 2u16);
        // C s_720_10: const #2u : u8
        let s_720_10: u8 = 2;
        // C s_720_11: cast zx s_720_10 -> bv
        let s_720_11: Bits = Bits::new(s_720_10 as u128, 2u16);
        // D s_720_12: cmp-eq s_720_9 s_720_11
        let s_720_12: bool = ((s_720_9) == (s_720_11));
        // N s_720_13: branch s_720_12 b723 b721
        if s_720_12 {
            return block_723(state, tracer, fn_state);
        } else {
            return block_721(state, tracer, fn_state);
        };
    }
    fn block_721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_721_0: const #0u : u8
        let s_721_0: bool = false;
        // D s_721_1: write-var gs#413389 <= s_721_0
        fn_state.gs_413389 = s_721_0;
        // N s_721_2: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_722_0: read-var gs#413389:u8
        let s_722_0: bool = fn_state.gs_413389;
        // D s_722_1: write-var gs#413390 <= s_722_0
        fn_state.gs_413390 = s_722_0;
        // N s_722_2: jump b719
        return block_719(state, tracer, fn_state);
    }
    fn block_723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_723_0: const #6s : i
        let s_723_0: i128 = 6;
        // D s_723_1: read-var u#34333:u32
        let s_723_1: u32 = fn_state.u_34333;
        // D s_723_2: cast zx s_723_1 -> bv
        let s_723_2: Bits = Bits::new(s_723_1 as u128, 32u16);
        // C s_723_3: const #1s : i64
        let s_723_3: i64 = 1;
        // C s_723_4: cast zx s_723_3 -> i
        let s_723_4: i128 = (i128::try_from(s_723_3).unwrap());
        // C s_723_5: const #1s : i
        let s_723_5: i128 = 1;
        // C s_723_6: add s_723_5 s_723_4
        let s_723_6: i128 = (s_723_5 + s_723_4);
        // D s_723_7: bit-extract s_723_2 s_723_0 s_723_6
        let s_723_7: Bits = (Bits::new(
            ((s_723_2) >> (s_723_0)).value(),
            u16::try_from(s_723_6).unwrap(),
        ));
        // D s_723_8: cast reint s_723_7 -> u8
        let s_723_8: u8 = (s_723_7.value() as u8);
        // D s_723_9: cast zx s_723_8 -> bv
        let s_723_9: Bits = Bits::new(s_723_8 as u128, 2u16);
        // C s_723_10: const #1u : u8
        let s_723_10: u8 = 1;
        // C s_723_11: cast zx s_723_10 -> bv
        let s_723_11: Bits = Bits::new(s_723_10 as u128, 2u16);
        // D s_723_12: cmp-eq s_723_9 s_723_11
        let s_723_12: bool = ((s_723_9) == (s_723_11));
        // N s_723_13: branch s_723_12 b726 b724
        if s_723_12 {
            return block_726(state, tracer, fn_state);
        } else {
            return block_724(state, tracer, fn_state);
        };
    }
    fn block_724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_724_0: const #0u : u8
        let s_724_0: bool = false;
        // D s_724_1: write-var gs#413388 <= s_724_0
        fn_state.gs_413388 = s_724_0;
        // N s_724_2: jump b725
        return block_725(state, tracer, fn_state);
    }
    fn block_725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_725_0: read-var gs#413388:u8
        let s_725_0: bool = fn_state.gs_413388;
        // D s_725_1: write-var gs#413389 <= s_725_0
        fn_state.gs_413389 = s_725_0;
        // N s_725_2: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_726_0: const #4s : i
        let s_726_0: i128 = 4;
        // D s_726_1: read-var u#34333:u32
        let s_726_1: u32 = fn_state.u_34333;
        // D s_726_2: cast zx s_726_1 -> bv
        let s_726_2: Bits = Bits::new(s_726_1 as u128, 32u16);
        // C s_726_3: const #1s : i64
        let s_726_3: i64 = 1;
        // C s_726_4: cast zx s_726_3 -> i
        let s_726_4: i128 = (i128::try_from(s_726_3).unwrap());
        // C s_726_5: const #0s : i
        let s_726_5: i128 = 0;
        // C s_726_6: add s_726_5 s_726_4
        let s_726_6: i128 = (s_726_5 + s_726_4);
        // D s_726_7: bit-extract s_726_2 s_726_0 s_726_6
        let s_726_7: Bits = (Bits::new(
            ((s_726_2) >> (s_726_0)).value(),
            u16::try_from(s_726_6).unwrap(),
        ));
        // D s_726_8: cast reint s_726_7 -> u8
        let s_726_8: bool = ((s_726_7.value()) != 0);
        // D s_726_9: cast zx s_726_8 -> bv
        let s_726_9: Bits = Bits::new(s_726_8 as u128, 1u16);
        // C s_726_10: const #0u : u8
        let s_726_10: bool = false;
        // C s_726_11: cast zx s_726_10 -> bv
        let s_726_11: Bits = Bits::new(s_726_10 as u128, 1u16);
        // D s_726_12: cmp-eq s_726_9 s_726_11
        let s_726_12: bool = ((s_726_9) == (s_726_11));
        // D s_726_13: write-var gs#413388 <= s_726_12
        fn_state.gs_413388 = s_726_12;
        // N s_726_14: jump b725
        return block_725(state, tracer, fn_state);
    }
    fn block_727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_727_0: const #3871s : i
        let s_727_0: i128 = 3871;
        // C s_727_1: const #14696u : u32
        let s_727_1: u32 = 14696;
        // D s_727_2: read-reg s_727_1:i
        let s_727_2: i128 = {
            let value = state.read_register::<i128>(s_727_1 as isize);
            tracer.read_register(s_727_1 as isize, value);
            value
        };
        // D s_727_3: cmp-lt s_727_2 s_727_0
        let s_727_3: bool = ((s_727_2) < (s_727_0));
        // D s_727_4: write-var gs#413358 <= s_727_3
        fn_state.gs_413358 = s_727_3;
        // N s_727_5: jump b398
        return block_398(state, tracer, fn_state);
    }
    fn block_728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_728_0: const #20s : i
        let s_728_0: i128 = 20;
        // D s_728_1: read-var u#34323:u32
        let s_728_1: u32 = fn_state.u_34323;
        // D s_728_2: cast zx s_728_1 -> bv
        let s_728_2: Bits = Bits::new(s_728_1 as u128, 32u16);
        // C s_728_3: const #1s : i64
        let s_728_3: i64 = 1;
        // C s_728_4: cast zx s_728_3 -> i
        let s_728_4: i128 = (i128::try_from(s_728_3).unwrap());
        // C s_728_5: const #1s : i
        let s_728_5: i128 = 1;
        // C s_728_6: add s_728_5 s_728_4
        let s_728_6: i128 = (s_728_5 + s_728_4);
        // D s_728_7: bit-extract s_728_2 s_728_0 s_728_6
        let s_728_7: Bits = (Bits::new(
            ((s_728_2) >> (s_728_0)).value(),
            u16::try_from(s_728_6).unwrap(),
        ));
        // D s_728_8: cast reint s_728_7 -> u8
        let s_728_8: u8 = (s_728_7.value() as u8);
        // D s_728_9: cast zx s_728_8 -> bv
        let s_728_9: Bits = Bits::new(s_728_8 as u128, 2u16);
        // C s_728_10: const #0u : u8
        let s_728_10: u8 = 0;
        // C s_728_11: cast zx s_728_10 -> bv
        let s_728_11: Bits = Bits::new(s_728_10 as u128, 2u16);
        // D s_728_12: cmp-eq s_728_9 s_728_11
        let s_728_12: bool = ((s_728_9) == (s_728_11));
        // N s_728_13: branch s_728_12 b731 b729
        if s_728_12 {
            return block_731(state, tracer, fn_state);
        } else {
            return block_729(state, tracer, fn_state);
        };
    }
    fn block_729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_729_0: const #0u : u8
        let s_729_0: bool = false;
        // D s_729_1: write-var gs#413355 <= s_729_0
        fn_state.gs_413355 = s_729_0;
        // N s_729_2: jump b730
        return block_730(state, tracer, fn_state);
    }
    fn block_730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_730_0: read-var gs#413355:u8
        let s_730_0: bool = fn_state.gs_413355;
        // D s_730_1: write-var gs#413356 <= s_730_0
        fn_state.gs_413356 = s_730_0;
        // N s_730_2: jump b396
        return block_396(state, tracer, fn_state);
    }
    fn block_731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_731_0: const #10s : i
        let s_731_0: i128 = 10;
        // D s_731_1: read-var u#34323:u32
        let s_731_1: u32 = fn_state.u_34323;
        // D s_731_2: cast zx s_731_1 -> bv
        let s_731_2: Bits = Bits::new(s_731_1 as u128, 32u16);
        // C s_731_3: const #1s : i64
        let s_731_3: i64 = 1;
        // C s_731_4: cast zx s_731_3 -> i
        let s_731_4: i128 = (i128::try_from(s_731_3).unwrap());
        // C s_731_5: const #1s : i
        let s_731_5: i128 = 1;
        // C s_731_6: add s_731_5 s_731_4
        let s_731_6: i128 = (s_731_5 + s_731_4);
        // D s_731_7: bit-extract s_731_2 s_731_0 s_731_6
        let s_731_7: Bits = (Bits::new(
            ((s_731_2) >> (s_731_0)).value(),
            u16::try_from(s_731_6).unwrap(),
        ));
        // D s_731_8: cast reint s_731_7 -> u8
        let s_731_8: u8 = (s_731_7.value() as u8);
        // D s_731_9: cast zx s_731_8 -> bv
        let s_731_9: Bits = Bits::new(s_731_8 as u128, 2u16);
        // C s_731_10: const #2u : u8
        let s_731_10: u8 = 2;
        // C s_731_11: cast zx s_731_10 -> bv
        let s_731_11: Bits = Bits::new(s_731_10 as u128, 2u16);
        // D s_731_12: cmp-eq s_731_9 s_731_11
        let s_731_12: bool = ((s_731_9) == (s_731_11));
        // N s_731_13: branch s_731_12 b734 b732
        if s_731_12 {
            return block_734(state, tracer, fn_state);
        } else {
            return block_732(state, tracer, fn_state);
        };
    }
    fn block_732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_732_0: const #0u : u8
        let s_732_0: bool = false;
        // D s_732_1: write-var gs#413354 <= s_732_0
        fn_state.gs_413354 = s_732_0;
        // N s_732_2: jump b733
        return block_733(state, tracer, fn_state);
    }
    fn block_733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_733_0: read-var gs#413354:u8
        let s_733_0: bool = fn_state.gs_413354;
        // D s_733_1: write-var gs#413355 <= s_733_0
        fn_state.gs_413355 = s_733_0;
        // N s_733_2: jump b730
        return block_730(state, tracer, fn_state);
    }
    fn block_734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_734_0: const #4s : i
        let s_734_0: i128 = 4;
        // D s_734_1: read-var u#34323:u32
        let s_734_1: u32 = fn_state.u_34323;
        // D s_734_2: cast zx s_734_1 -> bv
        let s_734_2: Bits = Bits::new(s_734_1 as u128, 32u16);
        // C s_734_3: const #1s : i64
        let s_734_3: i64 = 1;
        // C s_734_4: cast zx s_734_3 -> i
        let s_734_4: i128 = (i128::try_from(s_734_3).unwrap());
        // C s_734_5: const #0s : i
        let s_734_5: i128 = 0;
        // C s_734_6: add s_734_5 s_734_4
        let s_734_6: i128 = (s_734_5 + s_734_4);
        // D s_734_7: bit-extract s_734_2 s_734_0 s_734_6
        let s_734_7: Bits = (Bits::new(
            ((s_734_2) >> (s_734_0)).value(),
            u16::try_from(s_734_6).unwrap(),
        ));
        // D s_734_8: cast reint s_734_7 -> u8
        let s_734_8: bool = ((s_734_7.value()) != 0);
        // D s_734_9: cast zx s_734_8 -> bv
        let s_734_9: Bits = Bits::new(s_734_8 as u128, 1u16);
        // C s_734_10: const #0u : u8
        let s_734_10: bool = false;
        // C s_734_11: cast zx s_734_10 -> bv
        let s_734_11: Bits = Bits::new(s_734_10 as u128, 1u16);
        // D s_734_12: cmp-eq s_734_9 s_734_11
        let s_734_12: bool = ((s_734_9) == (s_734_11));
        // D s_734_13: write-var gs#413354 <= s_734_12
        fn_state.gs_413354 = s_734_12;
        // N s_734_14: jump b733
        return block_733(state, tracer, fn_state);
    }
    fn block_735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_735_0: const #3868s : i
        let s_735_0: i128 = 3868;
        // C s_735_1: const #14696u : u32
        let s_735_1: u32 = 14696;
        // D s_735_2: read-reg s_735_1:i
        let s_735_2: i128 = {
            let value = state.read_register::<i128>(s_735_1 as isize);
            tracer.read_register(s_735_1 as isize, value);
            value
        };
        // D s_735_3: cmp-lt s_735_2 s_735_0
        let s_735_3: bool = ((s_735_2) < (s_735_0));
        // D s_735_4: write-var gs#413328 <= s_735_3
        fn_state.gs_413328 = s_735_3;
        // N s_735_5: jump b392
        return block_392(state, tracer, fn_state);
    }
    fn block_736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_736_0: const #18s : i
        let s_736_0: i128 = 18;
        // D s_736_1: read-var u#34315:u32
        let s_736_1: u32 = fn_state.u_34315;
        // D s_736_2: cast zx s_736_1 -> bv
        let s_736_2: Bits = Bits::new(s_736_1 as u128, 32u16);
        // C s_736_3: const #1s : i64
        let s_736_3: i64 = 1;
        // C s_736_4: cast zx s_736_3 -> i
        let s_736_4: i128 = (i128::try_from(s_736_3).unwrap());
        // C s_736_5: const #3s : i
        let s_736_5: i128 = 3;
        // C s_736_6: add s_736_5 s_736_4
        let s_736_6: i128 = (s_736_5 + s_736_4);
        // D s_736_7: bit-extract s_736_2 s_736_0 s_736_6
        let s_736_7: Bits = (Bits::new(
            ((s_736_2) >> (s_736_0)).value(),
            u16::try_from(s_736_6).unwrap(),
        ));
        // D s_736_8: cast reint s_736_7 -> u8
        let s_736_8: u8 = (s_736_7.value() as u8);
        // D s_736_9: cast zx s_736_8 -> bv
        let s_736_9: Bits = Bits::new(s_736_8 as u128, 4u16);
        // C s_736_10: const #15u : u8
        let s_736_10: u8 = 15;
        // C s_736_11: cast zx s_736_10 -> bv
        let s_736_11: Bits = Bits::new(s_736_10 as u128, 4u16);
        // D s_736_12: cmp-eq s_736_9 s_736_11
        let s_736_12: bool = ((s_736_9) == (s_736_11));
        // N s_736_13: branch s_736_12 b739 b737
        if s_736_12 {
            return block_739(state, tracer, fn_state);
        } else {
            return block_737(state, tracer, fn_state);
        };
    }
    fn block_737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_737_0: const #0u : u8
        let s_737_0: bool = false;
        // D s_737_1: write-var gs#413325 <= s_737_0
        fn_state.gs_413325 = s_737_0;
        // N s_737_2: jump b738
        return block_738(state, tracer, fn_state);
    }
    fn block_738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_738_0: read-var gs#413325:u8
        let s_738_0: bool = fn_state.gs_413325;
        // D s_738_1: write-var gs#413326 <= s_738_0
        fn_state.gs_413326 = s_738_0;
        // N s_738_2: jump b390
        return block_390(state, tracer, fn_state);
    }
    fn block_739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_739_0: const #10s : i
        let s_739_0: i128 = 10;
        // D s_739_1: read-var u#34315:u32
        let s_739_1: u32 = fn_state.u_34315;
        // D s_739_2: cast zx s_739_1 -> bv
        let s_739_2: Bits = Bits::new(s_739_1 as u128, 32u16);
        // C s_739_3: const #1s : i64
        let s_739_3: i64 = 1;
        // C s_739_4: cast zx s_739_3 -> i
        let s_739_4: i128 = (i128::try_from(s_739_3).unwrap());
        // C s_739_5: const #1s : i
        let s_739_5: i128 = 1;
        // C s_739_6: add s_739_5 s_739_4
        let s_739_6: i128 = (s_739_5 + s_739_4);
        // D s_739_7: bit-extract s_739_2 s_739_0 s_739_6
        let s_739_7: Bits = (Bits::new(
            ((s_739_2) >> (s_739_0)).value(),
            u16::try_from(s_739_6).unwrap(),
        ));
        // D s_739_8: cast reint s_739_7 -> u8
        let s_739_8: u8 = (s_739_7.value() as u8);
        // D s_739_9: cast zx s_739_8 -> bv
        let s_739_9: Bits = Bits::new(s_739_8 as u128, 2u16);
        // C s_739_10: const #2u : u8
        let s_739_10: u8 = 2;
        // C s_739_11: cast zx s_739_10 -> bv
        let s_739_11: Bits = Bits::new(s_739_10 as u128, 2u16);
        // D s_739_12: cmp-eq s_739_9 s_739_11
        let s_739_12: bool = ((s_739_9) == (s_739_11));
        // N s_739_13: branch s_739_12 b742 b740
        if s_739_12 {
            return block_742(state, tracer, fn_state);
        } else {
            return block_740(state, tracer, fn_state);
        };
    }
    fn block_740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_740_0: const #0u : u8
        let s_740_0: bool = false;
        // D s_740_1: write-var gs#413324 <= s_740_0
        fn_state.gs_413324 = s_740_0;
        // N s_740_2: jump b741
        return block_741(state, tracer, fn_state);
    }
    fn block_741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_741_0: read-var gs#413324:u8
        let s_741_0: bool = fn_state.gs_413324;
        // D s_741_1: write-var gs#413325 <= s_741_0
        fn_state.gs_413325 = s_741_0;
        // N s_741_2: jump b738
        return block_738(state, tracer, fn_state);
    }
    fn block_742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_742_0: const #6s : i
        let s_742_0: i128 = 6;
        // D s_742_1: read-var u#34315:u32
        let s_742_1: u32 = fn_state.u_34315;
        // D s_742_2: cast zx s_742_1 -> bv
        let s_742_2: Bits = Bits::new(s_742_1 as u128, 32u16);
        // C s_742_3: const #1s : i64
        let s_742_3: i64 = 1;
        // C s_742_4: cast zx s_742_3 -> i
        let s_742_4: i128 = (i128::try_from(s_742_3).unwrap());
        // C s_742_5: const #0s : i
        let s_742_5: i128 = 0;
        // C s_742_6: add s_742_5 s_742_4
        let s_742_6: i128 = (s_742_5 + s_742_4);
        // D s_742_7: bit-extract s_742_2 s_742_0 s_742_6
        let s_742_7: Bits = (Bits::new(
            ((s_742_2) >> (s_742_0)).value(),
            u16::try_from(s_742_6).unwrap(),
        ));
        // D s_742_8: cast reint s_742_7 -> u8
        let s_742_8: bool = ((s_742_7.value()) != 0);
        // D s_742_9: cast zx s_742_8 -> bv
        let s_742_9: Bits = Bits::new(s_742_8 as u128, 1u16);
        // C s_742_10: const #1u : u8
        let s_742_10: bool = true;
        // C s_742_11: cast zx s_742_10 -> bv
        let s_742_11: Bits = Bits::new(s_742_10 as u128, 1u16);
        // D s_742_12: cmp-eq s_742_9 s_742_11
        let s_742_12: bool = ((s_742_9) == (s_742_11));
        // N s_742_13: branch s_742_12 b745 b743
        if s_742_12 {
            return block_745(state, tracer, fn_state);
        } else {
            return block_743(state, tracer, fn_state);
        };
    }
    fn block_743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_743_0: const #0u : u8
        let s_743_0: bool = false;
        // D s_743_1: write-var gs#413323 <= s_743_0
        fn_state.gs_413323 = s_743_0;
        // N s_743_2: jump b744
        return block_744(state, tracer, fn_state);
    }
    fn block_744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_744_0: read-var gs#413323:u8
        let s_744_0: bool = fn_state.gs_413323;
        // D s_744_1: write-var gs#413324 <= s_744_0
        fn_state.gs_413324 = s_744_0;
        // N s_744_2: jump b741
        return block_741(state, tracer, fn_state);
    }
    fn block_745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_745_0: const #4s : i
        let s_745_0: i128 = 4;
        // D s_745_1: read-var u#34315:u32
        let s_745_1: u32 = fn_state.u_34315;
        // D s_745_2: cast zx s_745_1 -> bv
        let s_745_2: Bits = Bits::new(s_745_1 as u128, 32u16);
        // C s_745_3: const #1s : i64
        let s_745_3: i64 = 1;
        // C s_745_4: cast zx s_745_3 -> i
        let s_745_4: i128 = (i128::try_from(s_745_3).unwrap());
        // C s_745_5: const #0s : i
        let s_745_5: i128 = 0;
        // C s_745_6: add s_745_5 s_745_4
        let s_745_6: i128 = (s_745_5 + s_745_4);
        // D s_745_7: bit-extract s_745_2 s_745_0 s_745_6
        let s_745_7: Bits = (Bits::new(
            ((s_745_2) >> (s_745_0)).value(),
            u16::try_from(s_745_6).unwrap(),
        ));
        // D s_745_8: cast reint s_745_7 -> u8
        let s_745_8: bool = ((s_745_7.value()) != 0);
        // D s_745_9: cast zx s_745_8 -> bv
        let s_745_9: Bits = Bits::new(s_745_8 as u128, 1u16);
        // C s_745_10: const #0u : u8
        let s_745_10: bool = false;
        // C s_745_11: cast zx s_745_10 -> bv
        let s_745_11: Bits = Bits::new(s_745_10 as u128, 1u16);
        // D s_745_12: cmp-eq s_745_9 s_745_11
        let s_745_12: bool = ((s_745_9) == (s_745_11));
        // D s_745_13: write-var gs#413323 <= s_745_12
        fn_state.gs_413323 = s_745_12;
        // N s_745_14: jump b744
        return block_744(state, tracer, fn_state);
    }
    fn block_746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_746_0: const #28s : i
        let s_746_0: i128 = 28;
        // C s_746_1: const #4s : i
        let s_746_1: i128 = 4;
        // D s_746_2: read-var u#34310:u32
        let s_746_2: u32 = fn_state.u_34310;
        // D s_746_3: cast zx s_746_2 -> bv
        let s_746_3: Bits = Bits::new(s_746_2 as u128, 32u16);
        // D s_746_4: bit-extract s_746_3 s_746_0 s_746_1
        let s_746_4: Bits = (Bits::new(
            ((s_746_3) >> (s_746_0)).value(),
            u16::try_from(s_746_1).unwrap(),
        ));
        // D s_746_5: cast reint s_746_4 -> u8
        let s_746_5: u8 = (s_746_4.value() as u8);
        // D s_746_6: cast zx s_746_5 -> bv
        let s_746_6: Bits = Bits::new(s_746_5 as u128, 4u16);
        // C s_746_7: const #15u : u8
        let s_746_7: u8 = 15;
        // C s_746_8: cast zx s_746_7 -> bv
        let s_746_8: Bits = Bits::new(s_746_7 as u128, 4u16);
        // D s_746_9: cmp-ne s_746_6 s_746_8
        let s_746_9: bool = ((s_746_6) != (s_746_8));
        // N s_746_10: branch s_746_9 b749 b747
        if s_746_9 {
            return block_749(state, tracer, fn_state);
        } else {
            return block_747(state, tracer, fn_state);
        };
    }
    fn block_747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_747_0: const #0u : u8
        let s_747_0: bool = false;
        // D s_747_1: write-var gs#413285 <= s_747_0
        fn_state.gs_413285 = s_747_0;
        // N s_747_2: jump b748
        return block_748(state, tracer, fn_state);
    }
    fn block_748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_748_0: read-var gs#413285:u8
        let s_748_0: bool = fn_state.gs_413285;
        // D s_748_1: write-var gs#413286 <= s_748_0
        fn_state.gs_413286 = s_748_0;
        // N s_748_2: jump b369
        return block_369(state, tracer, fn_state);
    }
    fn block_749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_749_0: const #3798s : i
        let s_749_0: i128 = 3798;
        // C s_749_1: const #14696u : u32
        let s_749_1: u32 = 14696;
        // D s_749_2: read-reg s_749_1:i
        let s_749_2: i128 = {
            let value = state.read_register::<i128>(s_749_1 as isize);
            tracer.read_register(s_749_1 as isize, value);
            value
        };
        // D s_749_3: cmp-lt s_749_2 s_749_0
        let s_749_3: bool = ((s_749_2) < (s_749_0));
        // D s_749_4: write-var gs#413285 <= s_749_3
        fn_state.gs_413285 = s_749_3;
        // N s_749_5: jump b748
        return block_748(state, tracer, fn_state);
    }
    fn block_750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_750_0: const #0s : i
        let s_750_0: i128 = 0;
        // D s_750_1: read-var u#34310:u32
        let s_750_1: u32 = fn_state.u_34310;
        // D s_750_2: cast zx s_750_1 -> bv
        let s_750_2: Bits = Bits::new(s_750_1 as u128, 32u16);
        // C s_750_3: const #1s : i64
        let s_750_3: i64 = 1;
        // C s_750_4: cast zx s_750_3 -> i
        let s_750_4: i128 = (i128::try_from(s_750_3).unwrap());
        // C s_750_5: const #11s : i
        let s_750_5: i128 = 11;
        // C s_750_6: add s_750_5 s_750_4
        let s_750_6: i128 = (s_750_5 + s_750_4);
        // D s_750_7: bit-extract s_750_2 s_750_0 s_750_6
        let s_750_7: Bits = (Bits::new(
            ((s_750_2) >> (s_750_0)).value(),
            u16::try_from(s_750_6).unwrap(),
        ));
        // D s_750_8: cast reint s_750_7 -> u12
        let s_750_8: u16 = (s_750_7.value() as u16);
        // D s_750_9: cast zx s_750_8 -> bv
        let s_750_9: Bits = Bits::new(s_750_8 as u128, 12u16);
        // C s_750_10: const #2576u : u12
        let s_750_10: u16 = 2576;
        // C s_750_11: cast zx s_750_10 -> bv
        let s_750_11: Bits = Bits::new(s_750_10 as u128, 12u16);
        // D s_750_12: cmp-eq s_750_9 s_750_11
        let s_750_12: bool = ((s_750_9) == (s_750_11));
        // D s_750_13: write-var gs#413281 <= s_750_12
        fn_state.gs_413281 = s_750_12;
        // N s_750_14: jump b367
        return block_367(state, tracer, fn_state);
    }
    fn block_751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_751_0: const #28s : i
        let s_751_0: i128 = 28;
        // C s_751_1: const #4s : i
        let s_751_1: i128 = 4;
        // D s_751_2: read-var u#34306:u32
        let s_751_2: u32 = fn_state.u_34306;
        // D s_751_3: cast zx s_751_2 -> bv
        let s_751_3: Bits = Bits::new(s_751_2 as u128, 32u16);
        // D s_751_4: bit-extract s_751_3 s_751_0 s_751_1
        let s_751_4: Bits = (Bits::new(
            ((s_751_3) >> (s_751_0)).value(),
            u16::try_from(s_751_1).unwrap(),
        ));
        // D s_751_5: cast reint s_751_4 -> u8
        let s_751_5: u8 = (s_751_4.value() as u8);
        // D s_751_6: cast zx s_751_5 -> bv
        let s_751_6: Bits = Bits::new(s_751_5 as u128, 4u16);
        // C s_751_7: const #15u : u8
        let s_751_7: u8 = 15;
        // C s_751_8: cast zx s_751_7 -> bv
        let s_751_8: Bits = Bits::new(s_751_7 as u128, 4u16);
        // D s_751_9: cmp-ne s_751_6 s_751_8
        let s_751_9: bool = ((s_751_6) != (s_751_8));
        // N s_751_10: branch s_751_9 b754 b752
        if s_751_9 {
            return block_754(state, tracer, fn_state);
        } else {
            return block_752(state, tracer, fn_state);
        };
    }
    fn block_752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_752_0: const #0u : u8
        let s_752_0: bool = false;
        // D s_752_1: write-var gs#413249 <= s_752_0
        fn_state.gs_413249 = s_752_0;
        // N s_752_2: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_753_0: read-var gs#413249:u8
        let s_753_0: bool = fn_state.gs_413249;
        // D s_753_1: write-var gs#413250 <= s_753_0
        fn_state.gs_413250 = s_753_0;
        // N s_753_2: jump b346
        return block_346(state, tracer, fn_state);
    }
    fn block_754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_754_0: const #3796s : i
        let s_754_0: i128 = 3796;
        // C s_754_1: const #14696u : u32
        let s_754_1: u32 = 14696;
        // D s_754_2: read-reg s_754_1:i
        let s_754_2: i128 = {
            let value = state.read_register::<i128>(s_754_1 as isize);
            tracer.read_register(s_754_1 as isize, value);
            value
        };
        // D s_754_3: cmp-lt s_754_2 s_754_0
        let s_754_3: bool = ((s_754_2) < (s_754_0));
        // D s_754_4: write-var gs#413249 <= s_754_3
        fn_state.gs_413249 = s_754_3;
        // N s_754_5: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_755_0: const #0s : i
        let s_755_0: i128 = 0;
        // D s_755_1: read-var u#34306:u32
        let s_755_1: u32 = fn_state.u_34306;
        // D s_755_2: cast zx s_755_1 -> bv
        let s_755_2: Bits = Bits::new(s_755_1 as u128, 32u16);
        // C s_755_3: const #1s : i64
        let s_755_3: i64 = 1;
        // C s_755_4: cast zx s_755_3 -> i
        let s_755_4: i128 = (i128::try_from(s_755_3).unwrap());
        // C s_755_5: const #11s : i
        let s_755_5: i128 = 11;
        // C s_755_6: add s_755_5 s_755_4
        let s_755_6: i128 = (s_755_5 + s_755_4);
        // D s_755_7: bit-extract s_755_2 s_755_0 s_755_6
        let s_755_7: Bits = (Bits::new(
            ((s_755_2) >> (s_755_0)).value(),
            u16::try_from(s_755_6).unwrap(),
        ));
        // D s_755_8: cast reint s_755_7 -> u12
        let s_755_8: u16 = (s_755_7.value() as u16);
        // D s_755_9: cast zx s_755_8 -> bv
        let s_755_9: Bits = Bits::new(s_755_8 as u128, 12u16);
        // C s_755_10: const #2576u : u12
        let s_755_10: u16 = 2576;
        // C s_755_11: cast zx s_755_10 -> bv
        let s_755_11: Bits = Bits::new(s_755_10 as u128, 12u16);
        // D s_755_12: cmp-eq s_755_9 s_755_11
        let s_755_12: bool = ((s_755_9) == (s_755_11));
        // D s_755_13: write-var gs#413245 <= s_755_12
        fn_state.gs_413245 = s_755_12;
        // N s_755_14: jump b344
        return block_344(state, tracer, fn_state);
    }
    fn block_756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_756_0: const #28s : i
        let s_756_0: i128 = 28;
        // C s_756_1: const #4s : i
        let s_756_1: i128 = 4;
        // D s_756_2: read-var u#34296:u32
        let s_756_2: u32 = fn_state.u_34296;
        // D s_756_3: cast zx s_756_2 -> bv
        let s_756_3: Bits = Bits::new(s_756_2 as u128, 32u16);
        // D s_756_4: bit-extract s_756_3 s_756_0 s_756_1
        let s_756_4: Bits = (Bits::new(
            ((s_756_3) >> (s_756_0)).value(),
            u16::try_from(s_756_1).unwrap(),
        ));
        // D s_756_5: cast reint s_756_4 -> u8
        let s_756_5: u8 = (s_756_4.value() as u8);
        // D s_756_6: cast zx s_756_5 -> bv
        let s_756_6: Bits = Bits::new(s_756_5 as u128, 4u16);
        // C s_756_7: const #15u : u8
        let s_756_7: u8 = 15;
        // C s_756_8: cast zx s_756_7 -> bv
        let s_756_8: Bits = Bits::new(s_756_7 as u128, 4u16);
        // D s_756_9: cmp-ne s_756_6 s_756_8
        let s_756_9: bool = ((s_756_6) != (s_756_8));
        // N s_756_10: branch s_756_9 b759 b757
        if s_756_9 {
            return block_759(state, tracer, fn_state);
        } else {
            return block_757(state, tracer, fn_state);
        };
    }
    fn block_757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_757_0: const #0u : u8
        let s_757_0: bool = false;
        // D s_757_1: write-var gs#413220 <= s_757_0
        fn_state.gs_413220 = s_757_0;
        // N s_757_2: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_758_0: read-var gs#413220:u8
        let s_758_0: bool = fn_state.gs_413220;
        // D s_758_1: write-var gs#413221 <= s_758_0
        fn_state.gs_413221 = s_758_0;
        // N s_758_2: jump b340
        return block_340(state, tracer, fn_state);
    }
    fn block_759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_759_0: const #3739s : i
        let s_759_0: i128 = 3739;
        // C s_759_1: const #14696u : u32
        let s_759_1: u32 = 14696;
        // D s_759_2: read-reg s_759_1:i
        let s_759_2: i128 = {
            let value = state.read_register::<i128>(s_759_1 as isize);
            tracer.read_register(s_759_1 as isize, value);
            value
        };
        // D s_759_3: cmp-lt s_759_2 s_759_0
        let s_759_3: bool = ((s_759_2) < (s_759_0));
        // D s_759_4: write-var gs#413220 <= s_759_3
        fn_state.gs_413220 = s_759_3;
        // N s_759_5: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_760_0: const #20s : i
        let s_760_0: i128 = 20;
        // D s_760_1: read-var u#34296:u32
        let s_760_1: u32 = fn_state.u_34296;
        // D s_760_2: cast zx s_760_1 -> bv
        let s_760_2: Bits = Bits::new(s_760_1 as u128, 32u16);
        // C s_760_3: const #1s : i64
        let s_760_3: i64 = 1;
        // C s_760_4: cast zx s_760_3 -> i
        let s_760_4: i128 = (i128::try_from(s_760_3).unwrap());
        // C s_760_5: const #1s : i
        let s_760_5: i128 = 1;
        // C s_760_6: add s_760_5 s_760_4
        let s_760_6: i128 = (s_760_5 + s_760_4);
        // D s_760_7: bit-extract s_760_2 s_760_0 s_760_6
        let s_760_7: Bits = (Bits::new(
            ((s_760_2) >> (s_760_0)).value(),
            u16::try_from(s_760_6).unwrap(),
        ));
        // D s_760_8: cast reint s_760_7 -> u8
        let s_760_8: u8 = (s_760_7.value() as u8);
        // D s_760_9: cast zx s_760_8 -> bv
        let s_760_9: Bits = Bits::new(s_760_8 as u128, 2u16);
        // C s_760_10: const #3u : u8
        let s_760_10: u8 = 3;
        // C s_760_11: cast zx s_760_10 -> bv
        let s_760_11: Bits = Bits::new(s_760_10 as u128, 2u16);
        // D s_760_12: cmp-eq s_760_9 s_760_11
        let s_760_12: bool = ((s_760_9) == (s_760_11));
        // N s_760_13: branch s_760_12 b763 b761
        if s_760_12 {
            return block_763(state, tracer, fn_state);
        } else {
            return block_761(state, tracer, fn_state);
        };
    }
    fn block_761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_761_0: const #0u : u8
        let s_761_0: bool = false;
        // D s_761_1: write-var gs#413215 <= s_761_0
        fn_state.gs_413215 = s_761_0;
        // N s_761_2: jump b762
        return block_762(state, tracer, fn_state);
    }
    fn block_762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_762_0: read-var gs#413215:u8
        let s_762_0: bool = fn_state.gs_413215;
        // D s_762_1: write-var gs#413216 <= s_762_0
        fn_state.gs_413216 = s_762_0;
        // N s_762_2: jump b338
        return block_338(state, tracer, fn_state);
    }
    fn block_763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_763_0: const #10s : i
        let s_763_0: i128 = 10;
        // D s_763_1: read-var u#34296:u32
        let s_763_1: u32 = fn_state.u_34296;
        // D s_763_2: cast zx s_763_1 -> bv
        let s_763_2: Bits = Bits::new(s_763_1 as u128, 32u16);
        // C s_763_3: const #1s : i64
        let s_763_3: i64 = 1;
        // C s_763_4: cast zx s_763_3 -> i
        let s_763_4: i128 = (i128::try_from(s_763_3).unwrap());
        // C s_763_5: const #1s : i
        let s_763_5: i128 = 1;
        // C s_763_6: add s_763_5 s_763_4
        let s_763_6: i128 = (s_763_5 + s_763_4);
        // D s_763_7: bit-extract s_763_2 s_763_0 s_763_6
        let s_763_7: Bits = (Bits::new(
            ((s_763_2) >> (s_763_0)).value(),
            u16::try_from(s_763_6).unwrap(),
        ));
        // D s_763_8: cast reint s_763_7 -> u8
        let s_763_8: u8 = (s_763_7.value() as u8);
        // D s_763_9: cast zx s_763_8 -> bv
        let s_763_9: Bits = Bits::new(s_763_8 as u128, 2u16);
        // C s_763_10: const #2u : u8
        let s_763_10: u8 = 2;
        // C s_763_11: cast zx s_763_10 -> bv
        let s_763_11: Bits = Bits::new(s_763_10 as u128, 2u16);
        // D s_763_12: cmp-eq s_763_9 s_763_11
        let s_763_12: bool = ((s_763_9) == (s_763_11));
        // N s_763_13: branch s_763_12 b766 b764
        if s_763_12 {
            return block_766(state, tracer, fn_state);
        } else {
            return block_764(state, tracer, fn_state);
        };
    }
    fn block_764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_764_0: const #0u : u8
        let s_764_0: bool = false;
        // D s_764_1: write-var gs#413214 <= s_764_0
        fn_state.gs_413214 = s_764_0;
        // N s_764_2: jump b765
        return block_765(state, tracer, fn_state);
    }
    fn block_765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_765_0: read-var gs#413214:u8
        let s_765_0: bool = fn_state.gs_413214;
        // D s_765_1: write-var gs#413215 <= s_765_0
        fn_state.gs_413215 = s_765_0;
        // N s_765_2: jump b762
        return block_762(state, tracer, fn_state);
    }
    fn block_766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_766_0: const #6s : i
        let s_766_0: i128 = 6;
        // D s_766_1: read-var u#34296:u32
        let s_766_1: u32 = fn_state.u_34296;
        // D s_766_2: cast zx s_766_1 -> bv
        let s_766_2: Bits = Bits::new(s_766_1 as u128, 32u16);
        // C s_766_3: const #1s : i64
        let s_766_3: i64 = 1;
        // C s_766_4: cast zx s_766_3 -> i
        let s_766_4: i128 = (i128::try_from(s_766_3).unwrap());
        // C s_766_5: const #0s : i
        let s_766_5: i128 = 0;
        // C s_766_6: add s_766_5 s_766_4
        let s_766_6: i128 = (s_766_5 + s_766_4);
        // D s_766_7: bit-extract s_766_2 s_766_0 s_766_6
        let s_766_7: Bits = (Bits::new(
            ((s_766_2) >> (s_766_0)).value(),
            u16::try_from(s_766_6).unwrap(),
        ));
        // D s_766_8: cast reint s_766_7 -> u8
        let s_766_8: bool = ((s_766_7.value()) != 0);
        // D s_766_9: cast zx s_766_8 -> bv
        let s_766_9: Bits = Bits::new(s_766_8 as u128, 1u16);
        // C s_766_10: const #1u : u8
        let s_766_10: bool = true;
        // C s_766_11: cast zx s_766_10 -> bv
        let s_766_11: Bits = Bits::new(s_766_10 as u128, 1u16);
        // D s_766_12: cmp-eq s_766_9 s_766_11
        let s_766_12: bool = ((s_766_9) == (s_766_11));
        // N s_766_13: branch s_766_12 b769 b767
        if s_766_12 {
            return block_769(state, tracer, fn_state);
        } else {
            return block_767(state, tracer, fn_state);
        };
    }
    fn block_767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_767_0: const #0u : u8
        let s_767_0: bool = false;
        // D s_767_1: write-var gs#413213 <= s_767_0
        fn_state.gs_413213 = s_767_0;
        // N s_767_2: jump b768
        return block_768(state, tracer, fn_state);
    }
    fn block_768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_768_0: read-var gs#413213:u8
        let s_768_0: bool = fn_state.gs_413213;
        // D s_768_1: write-var gs#413214 <= s_768_0
        fn_state.gs_413214 = s_768_0;
        // N s_768_2: jump b765
        return block_765(state, tracer, fn_state);
    }
    fn block_769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_769_0: const #4s : i
        let s_769_0: i128 = 4;
        // D s_769_1: read-var u#34296:u32
        let s_769_1: u32 = fn_state.u_34296;
        // D s_769_2: cast zx s_769_1 -> bv
        let s_769_2: Bits = Bits::new(s_769_1 as u128, 32u16);
        // C s_769_3: const #1s : i64
        let s_769_3: i64 = 1;
        // C s_769_4: cast zx s_769_3 -> i
        let s_769_4: i128 = (i128::try_from(s_769_3).unwrap());
        // C s_769_5: const #0s : i
        let s_769_5: i128 = 0;
        // C s_769_6: add s_769_5 s_769_4
        let s_769_6: i128 = (s_769_5 + s_769_4);
        // D s_769_7: bit-extract s_769_2 s_769_0 s_769_6
        let s_769_7: Bits = (Bits::new(
            ((s_769_2) >> (s_769_0)).value(),
            u16::try_from(s_769_6).unwrap(),
        ));
        // D s_769_8: cast reint s_769_7 -> u8
        let s_769_8: bool = ((s_769_7.value()) != 0);
        // D s_769_9: cast zx s_769_8 -> bv
        let s_769_9: Bits = Bits::new(s_769_8 as u128, 1u16);
        // C s_769_10: const #0u : u8
        let s_769_10: bool = false;
        // C s_769_11: cast zx s_769_10 -> bv
        let s_769_11: Bits = Bits::new(s_769_10 as u128, 1u16);
        // D s_769_12: cmp-eq s_769_9 s_769_11
        let s_769_12: bool = ((s_769_9) == (s_769_11));
        // D s_769_13: write-var gs#413213 <= s_769_12
        fn_state.gs_413213 = s_769_12;
        // N s_769_14: jump b768
        return block_768(state, tracer, fn_state);
    }
    fn block_770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_770_0: const #28s : i
        let s_770_0: i128 = 28;
        // C s_770_1: const #4s : i
        let s_770_1: i128 = 4;
        // D s_770_2: read-var u#34287:u32
        let s_770_2: u32 = fn_state.u_34287;
        // D s_770_3: cast zx s_770_2 -> bv
        let s_770_3: Bits = Bits::new(s_770_2 as u128, 32u16);
        // D s_770_4: bit-extract s_770_3 s_770_0 s_770_1
        let s_770_4: Bits = (Bits::new(
            ((s_770_3) >> (s_770_0)).value(),
            u16::try_from(s_770_1).unwrap(),
        ));
        // D s_770_5: cast reint s_770_4 -> u8
        let s_770_5: u8 = (s_770_4.value() as u8);
        // D s_770_6: cast zx s_770_5 -> bv
        let s_770_6: Bits = Bits::new(s_770_5 as u128, 4u16);
        // C s_770_7: const #15u : u8
        let s_770_7: u8 = 15;
        // C s_770_8: cast zx s_770_7 -> bv
        let s_770_8: Bits = Bits::new(s_770_7 as u128, 4u16);
        // D s_770_9: cmp-ne s_770_6 s_770_8
        let s_770_9: bool = ((s_770_6) != (s_770_8));
        // N s_770_10: branch s_770_9 b773 b771
        if s_770_9 {
            return block_773(state, tracer, fn_state);
        } else {
            return block_771(state, tracer, fn_state);
        };
    }
    fn block_771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_771_0: const #0u : u8
        let s_771_0: bool = false;
        // D s_771_1: write-var gs#413184 <= s_771_0
        fn_state.gs_413184 = s_771_0;
        // N s_771_2: jump b772
        return block_772(state, tracer, fn_state);
    }
    fn block_772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_772_0: read-var gs#413184:u8
        let s_772_0: bool = fn_state.gs_413184;
        // D s_772_1: write-var gs#413185 <= s_772_0
        fn_state.gs_413185 = s_772_0;
        // N s_772_2: jump b334
        return block_334(state, tracer, fn_state);
    }
    fn block_773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_773_0: const #3736s : i
        let s_773_0: i128 = 3736;
        // C s_773_1: const #14696u : u32
        let s_773_1: u32 = 14696;
        // D s_773_2: read-reg s_773_1:i
        let s_773_2: i128 = {
            let value = state.read_register::<i128>(s_773_1 as isize);
            tracer.read_register(s_773_1 as isize, value);
            value
        };
        // D s_773_3: cmp-lt s_773_2 s_773_0
        let s_773_3: bool = ((s_773_2) < (s_773_0));
        // D s_773_4: write-var gs#413184 <= s_773_3
        fn_state.gs_413184 = s_773_3;
        // N s_773_5: jump b772
        return block_772(state, tracer, fn_state);
    }
    fn block_774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_774_0: const #20s : i
        let s_774_0: i128 = 20;
        // D s_774_1: read-var u#34287:u32
        let s_774_1: u32 = fn_state.u_34287;
        // D s_774_2: cast zx s_774_1 -> bv
        let s_774_2: Bits = Bits::new(s_774_1 as u128, 32u16);
        // C s_774_3: const #1s : i64
        let s_774_3: i64 = 1;
        // C s_774_4: cast zx s_774_3 -> i
        let s_774_4: i128 = (i128::try_from(s_774_3).unwrap());
        // C s_774_5: const #1s : i
        let s_774_5: i128 = 1;
        // C s_774_6: add s_774_5 s_774_4
        let s_774_6: i128 = (s_774_5 + s_774_4);
        // D s_774_7: bit-extract s_774_2 s_774_0 s_774_6
        let s_774_7: Bits = (Bits::new(
            ((s_774_2) >> (s_774_0)).value(),
            u16::try_from(s_774_6).unwrap(),
        ));
        // D s_774_8: cast reint s_774_7 -> u8
        let s_774_8: u8 = (s_774_7.value() as u8);
        // D s_774_9: cast zx s_774_8 -> bv
        let s_774_9: Bits = Bits::new(s_774_8 as u128, 2u16);
        // C s_774_10: const #0u : u8
        let s_774_10: u8 = 0;
        // C s_774_11: cast zx s_774_10 -> bv
        let s_774_11: Bits = Bits::new(s_774_10 as u128, 2u16);
        // D s_774_12: cmp-eq s_774_9 s_774_11
        let s_774_12: bool = ((s_774_9) == (s_774_11));
        // N s_774_13: branch s_774_12 b777 b775
        if s_774_12 {
            return block_777(state, tracer, fn_state);
        } else {
            return block_775(state, tracer, fn_state);
        };
    }
    fn block_775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_775_0: const #0u : u8
        let s_775_0: bool = false;
        // D s_775_1: write-var gs#413179 <= s_775_0
        fn_state.gs_413179 = s_775_0;
        // N s_775_2: jump b776
        return block_776(state, tracer, fn_state);
    }
    fn block_776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_776_0: read-var gs#413179:u8
        let s_776_0: bool = fn_state.gs_413179;
        // D s_776_1: write-var gs#413180 <= s_776_0
        fn_state.gs_413180 = s_776_0;
        // N s_776_2: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_777_0: const #10s : i
        let s_777_0: i128 = 10;
        // D s_777_1: read-var u#34287:u32
        let s_777_1: u32 = fn_state.u_34287;
        // D s_777_2: cast zx s_777_1 -> bv
        let s_777_2: Bits = Bits::new(s_777_1 as u128, 32u16);
        // C s_777_3: const #1s : i64
        let s_777_3: i64 = 1;
        // C s_777_4: cast zx s_777_3 -> i
        let s_777_4: i128 = (i128::try_from(s_777_3).unwrap());
        // C s_777_5: const #1s : i
        let s_777_5: i128 = 1;
        // C s_777_6: add s_777_5 s_777_4
        let s_777_6: i128 = (s_777_5 + s_777_4);
        // D s_777_7: bit-extract s_777_2 s_777_0 s_777_6
        let s_777_7: Bits = (Bits::new(
            ((s_777_2) >> (s_777_0)).value(),
            u16::try_from(s_777_6).unwrap(),
        ));
        // D s_777_8: cast reint s_777_7 -> u8
        let s_777_8: u8 = (s_777_7.value() as u8);
        // D s_777_9: cast zx s_777_8 -> bv
        let s_777_9: Bits = Bits::new(s_777_8 as u128, 2u16);
        // C s_777_10: const #2u : u8
        let s_777_10: u8 = 2;
        // C s_777_11: cast zx s_777_10 -> bv
        let s_777_11: Bits = Bits::new(s_777_10 as u128, 2u16);
        // D s_777_12: cmp-eq s_777_9 s_777_11
        let s_777_12: bool = ((s_777_9) == (s_777_11));
        // D s_777_13: write-var gs#413179 <= s_777_12
        fn_state.gs_413179 = s_777_12;
        // N s_777_14: jump b776
        return block_776(state, tracer, fn_state);
    }
    fn block_778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_778_0: const #28s : i
        let s_778_0: i128 = 28;
        // C s_778_1: const #4s : i
        let s_778_1: i128 = 4;
        // D s_778_2: read-var u#34277:u32
        let s_778_2: u32 = fn_state.u_34277;
        // D s_778_3: cast zx s_778_2 -> bv
        let s_778_3: Bits = Bits::new(s_778_2 as u128, 32u16);
        // D s_778_4: bit-extract s_778_3 s_778_0 s_778_1
        let s_778_4: Bits = (Bits::new(
            ((s_778_3) >> (s_778_0)).value(),
            u16::try_from(s_778_1).unwrap(),
        ));
        // D s_778_5: cast reint s_778_4 -> u8
        let s_778_5: u8 = (s_778_4.value() as u8);
        // D s_778_6: cast zx s_778_5 -> bv
        let s_778_6: Bits = Bits::new(s_778_5 as u128, 4u16);
        // C s_778_7: const #15u : u8
        let s_778_7: u8 = 15;
        // C s_778_8: cast zx s_778_7 -> bv
        let s_778_8: Bits = Bits::new(s_778_7 as u128, 4u16);
        // D s_778_9: cmp-ne s_778_6 s_778_8
        let s_778_9: bool = ((s_778_6) != (s_778_8));
        // N s_778_10: branch s_778_9 b781 b779
        if s_778_9 {
            return block_781(state, tracer, fn_state);
        } else {
            return block_779(state, tracer, fn_state);
        };
    }
    fn block_779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_779_0: const #0u : u8
        let s_779_0: bool = false;
        // D s_779_1: write-var gs#413152 <= s_779_0
        fn_state.gs_413152 = s_779_0;
        // N s_779_2: jump b780
        return block_780(state, tracer, fn_state);
    }
    fn block_780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_780_0: read-var gs#413152:u8
        let s_780_0: bool = fn_state.gs_413152;
        // D s_780_1: write-var gs#413153 <= s_780_0
        fn_state.gs_413153 = s_780_0;
        // N s_780_2: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_781_0: const #3733s : i
        let s_781_0: i128 = 3733;
        // C s_781_1: const #14696u : u32
        let s_781_1: u32 = 14696;
        // D s_781_2: read-reg s_781_1:i
        let s_781_2: i128 = {
            let value = state.read_register::<i128>(s_781_1 as isize);
            tracer.read_register(s_781_1 as isize, value);
            value
        };
        // D s_781_3: cmp-lt s_781_2 s_781_0
        let s_781_3: bool = ((s_781_2) < (s_781_0));
        // D s_781_4: write-var gs#413152 <= s_781_3
        fn_state.gs_413152 = s_781_3;
        // N s_781_5: jump b780
        return block_780(state, tracer, fn_state);
    }
    fn block_782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_782_0: const #20s : i
        let s_782_0: i128 = 20;
        // D s_782_1: read-var u#34277:u32
        let s_782_1: u32 = fn_state.u_34277;
        // D s_782_2: cast zx s_782_1 -> bv
        let s_782_2: Bits = Bits::new(s_782_1 as u128, 32u16);
        // C s_782_3: const #1s : i64
        let s_782_3: i64 = 1;
        // C s_782_4: cast zx s_782_3 -> i
        let s_782_4: i128 = (i128::try_from(s_782_3).unwrap());
        // C s_782_5: const #0s : i
        let s_782_5: i128 = 0;
        // C s_782_6: add s_782_5 s_782_4
        let s_782_6: i128 = (s_782_5 + s_782_4);
        // D s_782_7: bit-extract s_782_2 s_782_0 s_782_6
        let s_782_7: Bits = (Bits::new(
            ((s_782_2) >> (s_782_0)).value(),
            u16::try_from(s_782_6).unwrap(),
        ));
        // D s_782_8: cast reint s_782_7 -> u8
        let s_782_8: bool = ((s_782_7.value()) != 0);
        // D s_782_9: cast zx s_782_8 -> bv
        let s_782_9: Bits = Bits::new(s_782_8 as u128, 1u16);
        // C s_782_10: const #0u : u8
        let s_782_10: bool = false;
        // C s_782_11: cast zx s_782_10 -> bv
        let s_782_11: Bits = Bits::new(s_782_10 as u128, 1u16);
        // D s_782_12: cmp-eq s_782_9 s_782_11
        let s_782_12: bool = ((s_782_9) == (s_782_11));
        // N s_782_13: branch s_782_12 b785 b783
        if s_782_12 {
            return block_785(state, tracer, fn_state);
        } else {
            return block_783(state, tracer, fn_state);
        };
    }
    fn block_783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_783_0: const #0u : u8
        let s_783_0: bool = false;
        // D s_783_1: write-var gs#413147 <= s_783_0
        fn_state.gs_413147 = s_783_0;
        // N s_783_2: jump b784
        return block_784(state, tracer, fn_state);
    }
    fn block_784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_784_0: read-var gs#413147:u8
        let s_784_0: bool = fn_state.gs_413147;
        // D s_784_1: write-var gs#413148 <= s_784_0
        fn_state.gs_413148 = s_784_0;
        // N s_784_2: jump b326
        return block_326(state, tracer, fn_state);
    }
    fn block_785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_785_0: const #8s : i
        let s_785_0: i128 = 8;
        // D s_785_1: read-var u#34277:u32
        let s_785_1: u32 = fn_state.u_34277;
        // D s_785_2: cast zx s_785_1 -> bv
        let s_785_2: Bits = Bits::new(s_785_1 as u128, 32u16);
        // C s_785_3: const #1s : i64
        let s_785_3: i64 = 1;
        // C s_785_4: cast zx s_785_3 -> i
        let s_785_4: i128 = (i128::try_from(s_785_3).unwrap());
        // C s_785_5: const #3s : i
        let s_785_5: i128 = 3;
        // C s_785_6: add s_785_5 s_785_4
        let s_785_6: i128 = (s_785_5 + s_785_4);
        // D s_785_7: bit-extract s_785_2 s_785_0 s_785_6
        let s_785_7: Bits = (Bits::new(
            ((s_785_2) >> (s_785_0)).value(),
            u16::try_from(s_785_6).unwrap(),
        ));
        // D s_785_8: cast reint s_785_7 -> u8
        let s_785_8: u8 = (s_785_7.value() as u8);
        // D s_785_9: cast zx s_785_8 -> bv
        let s_785_9: Bits = Bits::new(s_785_8 as u128, 4u16);
        // C s_785_10: const #10u : u8
        let s_785_10: u8 = 10;
        // C s_785_11: cast zx s_785_10 -> bv
        let s_785_11: Bits = Bits::new(s_785_10 as u128, 4u16);
        // D s_785_12: cmp-eq s_785_9 s_785_11
        let s_785_12: bool = ((s_785_9) == (s_785_11));
        // D s_785_13: write-var gs#413147 <= s_785_12
        fn_state.gs_413147 = s_785_12;
        // N s_785_14: jump b784
        return block_784(state, tracer, fn_state);
    }
    fn block_786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_786_0: const #28s : i
        let s_786_0: i128 = 28;
        // C s_786_1: const #4s : i
        let s_786_1: i128 = 4;
        // D s_786_2: read-var u#34267:u32
        let s_786_2: u32 = fn_state.u_34267;
        // D s_786_3: cast zx s_786_2 -> bv
        let s_786_3: Bits = Bits::new(s_786_2 as u128, 32u16);
        // D s_786_4: bit-extract s_786_3 s_786_0 s_786_1
        let s_786_4: Bits = (Bits::new(
            ((s_786_3) >> (s_786_0)).value(),
            u16::try_from(s_786_1).unwrap(),
        ));
        // D s_786_5: cast reint s_786_4 -> u8
        let s_786_5: u8 = (s_786_4.value() as u8);
        // D s_786_6: cast zx s_786_5 -> bv
        let s_786_6: Bits = Bits::new(s_786_5 as u128, 4u16);
        // C s_786_7: const #15u : u8
        let s_786_7: u8 = 15;
        // C s_786_8: cast zx s_786_7 -> bv
        let s_786_8: Bits = Bits::new(s_786_7 as u128, 4u16);
        // D s_786_9: cmp-ne s_786_6 s_786_8
        let s_786_9: bool = ((s_786_6) != (s_786_8));
        // N s_786_10: branch s_786_9 b789 b787
        if s_786_9 {
            return block_789(state, tracer, fn_state);
        } else {
            return block_787(state, tracer, fn_state);
        };
    }
    fn block_787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_787_0: const #0u : u8
        let s_787_0: bool = false;
        // D s_787_1: write-var gs#413120 <= s_787_0
        fn_state.gs_413120 = s_787_0;
        // N s_787_2: jump b788
        return block_788(state, tracer, fn_state);
    }
    fn block_788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_788_0: read-var gs#413120:u8
        let s_788_0: bool = fn_state.gs_413120;
        // D s_788_1: write-var gs#413121 <= s_788_0
        fn_state.gs_413121 = s_788_0;
        // N s_788_2: jump b322
        return block_322(state, tracer, fn_state);
    }
    fn block_789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_789_0: const #3732s : i
        let s_789_0: i128 = 3732;
        // C s_789_1: const #14696u : u32
        let s_789_1: u32 = 14696;
        // D s_789_2: read-reg s_789_1:i
        let s_789_2: i128 = {
            let value = state.read_register::<i128>(s_789_1 as isize);
            tracer.read_register(s_789_1 as isize, value);
            value
        };
        // D s_789_3: cmp-lt s_789_2 s_789_0
        let s_789_3: bool = ((s_789_2) < (s_789_0));
        // D s_789_4: write-var gs#413120 <= s_789_3
        fn_state.gs_413120 = s_789_3;
        // N s_789_5: jump b788
        return block_788(state, tracer, fn_state);
    }
    fn block_790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_790_0: const #20s : i
        let s_790_0: i128 = 20;
        // D s_790_1: read-var u#34267:u32
        let s_790_1: u32 = fn_state.u_34267;
        // D s_790_2: cast zx s_790_1 -> bv
        let s_790_2: Bits = Bits::new(s_790_1 as u128, 32u16);
        // C s_790_3: const #1s : i64
        let s_790_3: i64 = 1;
        // C s_790_4: cast zx s_790_3 -> i
        let s_790_4: i128 = (i128::try_from(s_790_3).unwrap());
        // C s_790_5: const #0s : i
        let s_790_5: i128 = 0;
        // C s_790_6: add s_790_5 s_790_4
        let s_790_6: i128 = (s_790_5 + s_790_4);
        // D s_790_7: bit-extract s_790_2 s_790_0 s_790_6
        let s_790_7: Bits = (Bits::new(
            ((s_790_2) >> (s_790_0)).value(),
            u16::try_from(s_790_6).unwrap(),
        ));
        // D s_790_8: cast reint s_790_7 -> u8
        let s_790_8: bool = ((s_790_7.value()) != 0);
        // D s_790_9: cast zx s_790_8 -> bv
        let s_790_9: Bits = Bits::new(s_790_8 as u128, 1u16);
        // C s_790_10: const #0u : u8
        let s_790_10: bool = false;
        // C s_790_11: cast zx s_790_10 -> bv
        let s_790_11: Bits = Bits::new(s_790_10 as u128, 1u16);
        // D s_790_12: cmp-eq s_790_9 s_790_11
        let s_790_12: bool = ((s_790_9) == (s_790_11));
        // N s_790_13: branch s_790_12 b793 b791
        if s_790_12 {
            return block_793(state, tracer, fn_state);
        } else {
            return block_791(state, tracer, fn_state);
        };
    }
    fn block_791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_791_0: const #0u : u8
        let s_791_0: bool = false;
        // D s_791_1: write-var gs#413115 <= s_791_0
        fn_state.gs_413115 = s_791_0;
        // N s_791_2: jump b792
        return block_792(state, tracer, fn_state);
    }
    fn block_792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_792_0: read-var gs#413115:u8
        let s_792_0: bool = fn_state.gs_413115;
        // D s_792_1: write-var gs#413116 <= s_792_0
        fn_state.gs_413116 = s_792_0;
        // N s_792_2: jump b320
        return block_320(state, tracer, fn_state);
    }
    fn block_793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_793_0: const #8s : i
        let s_793_0: i128 = 8;
        // D s_793_1: read-var u#34267:u32
        let s_793_1: u32 = fn_state.u_34267;
        // D s_793_2: cast zx s_793_1 -> bv
        let s_793_2: Bits = Bits::new(s_793_1 as u128, 32u16);
        // C s_793_3: const #1s : i64
        let s_793_3: i64 = 1;
        // C s_793_4: cast zx s_793_3 -> i
        let s_793_4: i128 = (i128::try_from(s_793_3).unwrap());
        // C s_793_5: const #3s : i
        let s_793_5: i128 = 3;
        // C s_793_6: add s_793_5 s_793_4
        let s_793_6: i128 = (s_793_5 + s_793_4);
        // D s_793_7: bit-extract s_793_2 s_793_0 s_793_6
        let s_793_7: Bits = (Bits::new(
            ((s_793_2) >> (s_793_0)).value(),
            u16::try_from(s_793_6).unwrap(),
        ));
        // D s_793_8: cast reint s_793_7 -> u8
        let s_793_8: u8 = (s_793_7.value() as u8);
        // D s_793_9: cast zx s_793_8 -> bv
        let s_793_9: Bits = Bits::new(s_793_8 as u128, 4u16);
        // C s_793_10: const #11u : u8
        let s_793_10: u8 = 11;
        // C s_793_11: cast zx s_793_10 -> bv
        let s_793_11: Bits = Bits::new(s_793_10 as u128, 4u16);
        // D s_793_12: cmp-eq s_793_9 s_793_11
        let s_793_12: bool = ((s_793_9) == (s_793_11));
        // D s_793_13: write-var gs#413115 <= s_793_12
        fn_state.gs_413115 = s_793_12;
        // N s_793_14: jump b792
        return block_792(state, tracer, fn_state);
    }
    fn block_794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_794_0: const #28s : i
        let s_794_0: i128 = 28;
        // C s_794_1: const #4s : i
        let s_794_1: i128 = 4;
        // D s_794_2: read-var u#34259:u32
        let s_794_2: u32 = fn_state.u_34259;
        // D s_794_3: cast zx s_794_2 -> bv
        let s_794_3: Bits = Bits::new(s_794_2 as u128, 32u16);
        // D s_794_4: bit-extract s_794_3 s_794_0 s_794_1
        let s_794_4: Bits = (Bits::new(
            ((s_794_3) >> (s_794_0)).value(),
            u16::try_from(s_794_1).unwrap(),
        ));
        // D s_794_5: cast reint s_794_4 -> u8
        let s_794_5: u8 = (s_794_4.value() as u8);
        // D s_794_6: cast zx s_794_5 -> bv
        let s_794_6: Bits = Bits::new(s_794_5 as u128, 4u16);
        // C s_794_7: const #15u : u8
        let s_794_7: u8 = 15;
        // C s_794_8: cast zx s_794_7 -> bv
        let s_794_8: Bits = Bits::new(s_794_7 as u128, 4u16);
        // D s_794_9: cmp-ne s_794_6 s_794_8
        let s_794_9: bool = ((s_794_6) != (s_794_8));
        // N s_794_10: branch s_794_9 b797 b795
        if s_794_9 {
            return block_797(state, tracer, fn_state);
        } else {
            return block_795(state, tracer, fn_state);
        };
    }
    fn block_795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_795_0: const #0u : u8
        let s_795_0: bool = false;
        // D s_795_1: write-var gs#413092 <= s_795_0
        fn_state.gs_413092 = s_795_0;
        // N s_795_2: jump b796
        return block_796(state, tracer, fn_state);
    }
    fn block_796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_796_0: read-var gs#413092:u8
        let s_796_0: bool = fn_state.gs_413092;
        // D s_796_1: write-var gs#413093 <= s_796_0
        fn_state.gs_413093 = s_796_0;
        // N s_796_2: jump b316
        return block_316(state, tracer, fn_state);
    }
    fn block_797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_797_0: const #3686s : i
        let s_797_0: i128 = 3686;
        // C s_797_1: const #14696u : u32
        let s_797_1: u32 = 14696;
        // D s_797_2: read-reg s_797_1:i
        let s_797_2: i128 = {
            let value = state.read_register::<i128>(s_797_1 as isize);
            tracer.read_register(s_797_1 as isize, value);
            value
        };
        // D s_797_3: cmp-lt s_797_2 s_797_0
        let s_797_3: bool = ((s_797_2) < (s_797_0));
        // D s_797_4: write-var gs#413092 <= s_797_3
        fn_state.gs_413092 = s_797_3;
        // N s_797_5: jump b796
        return block_796(state, tracer, fn_state);
    }
    fn block_798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_798_0: const #16s : i
        let s_798_0: i128 = 16;
        // D s_798_1: read-var u#34259:u32
        let s_798_1: u32 = fn_state.u_34259;
        // D s_798_2: cast zx s_798_1 -> bv
        let s_798_2: Bits = Bits::new(s_798_1 as u128, 32u16);
        // C s_798_3: const #1s : i64
        let s_798_3: i64 = 1;
        // C s_798_4: cast zx s_798_3 -> i
        let s_798_4: i128 = (i128::try_from(s_798_3).unwrap());
        // C s_798_5: const #5s : i
        let s_798_5: i128 = 5;
        // C s_798_6: add s_798_5 s_798_4
        let s_798_6: i128 = (s_798_5 + s_798_4);
        // D s_798_7: bit-extract s_798_2 s_798_0 s_798_6
        let s_798_7: Bits = (Bits::new(
            ((s_798_2) >> (s_798_0)).value(),
            u16::try_from(s_798_6).unwrap(),
        ));
        // D s_798_8: cast reint s_798_7 -> u8
        let s_798_8: u8 = (s_798_7.value() as u8);
        // D s_798_9: cast zx s_798_8 -> bv
        let s_798_9: Bits = Bits::new(s_798_8 as u128, 6u16);
        // C s_798_10: const #49u : u8
        let s_798_10: u8 = 49;
        // C s_798_11: cast zx s_798_10 -> bv
        let s_798_11: Bits = Bits::new(s_798_10 as u128, 6u16);
        // D s_798_12: cmp-eq s_798_9 s_798_11
        let s_798_12: bool = ((s_798_9) == (s_798_11));
        // N s_798_13: branch s_798_12 b801 b799
        if s_798_12 {
            return block_801(state, tracer, fn_state);
        } else {
            return block_799(state, tracer, fn_state);
        };
    }
    fn block_799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_799_0: const #0u : u8
        let s_799_0: bool = false;
        // D s_799_1: write-var gs#413087 <= s_799_0
        fn_state.gs_413087 = s_799_0;
        // N s_799_2: jump b800
        return block_800(state, tracer, fn_state);
    }
    fn block_800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_800_0: read-var gs#413087:u8
        let s_800_0: bool = fn_state.gs_413087;
        // D s_800_1: write-var gs#413088 <= s_800_0
        fn_state.gs_413088 = s_800_0;
        // N s_800_2: jump b314
        return block_314(state, tracer, fn_state);
    }
    fn block_801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_801_0: const #10s : i
        let s_801_0: i128 = 10;
        // D s_801_1: read-var u#34259:u32
        let s_801_1: u32 = fn_state.u_34259;
        // D s_801_2: cast zx s_801_1 -> bv
        let s_801_2: Bits = Bits::new(s_801_1 as u128, 32u16);
        // C s_801_3: const #1s : i64
        let s_801_3: i64 = 1;
        // C s_801_4: cast zx s_801_3 -> i
        let s_801_4: i128 = (i128::try_from(s_801_3).unwrap());
        // C s_801_5: const #1s : i
        let s_801_5: i128 = 1;
        // C s_801_6: add s_801_5 s_801_4
        let s_801_6: i128 = (s_801_5 + s_801_4);
        // D s_801_7: bit-extract s_801_2 s_801_0 s_801_6
        let s_801_7: Bits = (Bits::new(
            ((s_801_2) >> (s_801_0)).value(),
            u16::try_from(s_801_6).unwrap(),
        ));
        // D s_801_8: cast reint s_801_7 -> u8
        let s_801_8: u8 = (s_801_7.value() as u8);
        // D s_801_9: cast zx s_801_8 -> bv
        let s_801_9: Bits = Bits::new(s_801_8 as u128, 2u16);
        // C s_801_10: const #2u : u8
        let s_801_10: u8 = 2;
        // C s_801_11: cast zx s_801_10 -> bv
        let s_801_11: Bits = Bits::new(s_801_10 as u128, 2u16);
        // D s_801_12: cmp-eq s_801_9 s_801_11
        let s_801_12: bool = ((s_801_9) == (s_801_11));
        // N s_801_13: branch s_801_12 b804 b802
        if s_801_12 {
            return block_804(state, tracer, fn_state);
        } else {
            return block_802(state, tracer, fn_state);
        };
    }
    fn block_802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_802_0: const #0u : u8
        let s_802_0: bool = false;
        // D s_802_1: write-var gs#413086 <= s_802_0
        fn_state.gs_413086 = s_802_0;
        // N s_802_2: jump b803
        return block_803(state, tracer, fn_state);
    }
    fn block_803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_803_0: read-var gs#413086:u8
        let s_803_0: bool = fn_state.gs_413086;
        // D s_803_1: write-var gs#413087 <= s_803_0
        fn_state.gs_413087 = s_803_0;
        // N s_803_2: jump b800
        return block_800(state, tracer, fn_state);
    }
    fn block_804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_804_0: const #6s : i
        let s_804_0: i128 = 6;
        // D s_804_1: read-var u#34259:u32
        let s_804_1: u32 = fn_state.u_34259;
        // D s_804_2: cast zx s_804_1 -> bv
        let s_804_2: Bits = Bits::new(s_804_1 as u128, 32u16);
        // C s_804_3: const #1s : i64
        let s_804_3: i64 = 1;
        // C s_804_4: cast zx s_804_3 -> i
        let s_804_4: i128 = (i128::try_from(s_804_3).unwrap());
        // C s_804_5: const #1s : i
        let s_804_5: i128 = 1;
        // C s_804_6: add s_804_5 s_804_4
        let s_804_6: i128 = (s_804_5 + s_804_4);
        // D s_804_7: bit-extract s_804_2 s_804_0 s_804_6
        let s_804_7: Bits = (Bits::new(
            ((s_804_2) >> (s_804_0)).value(),
            u16::try_from(s_804_6).unwrap(),
        ));
        // D s_804_8: cast reint s_804_7 -> u8
        let s_804_8: u8 = (s_804_7.value() as u8);
        // D s_804_9: cast zx s_804_8 -> bv
        let s_804_9: Bits = Bits::new(s_804_8 as u128, 2u16);
        // C s_804_10: const #3u : u8
        let s_804_10: u8 = 3;
        // C s_804_11: cast zx s_804_10 -> bv
        let s_804_11: Bits = Bits::new(s_804_10 as u128, 2u16);
        // D s_804_12: cmp-eq s_804_9 s_804_11
        let s_804_12: bool = ((s_804_9) == (s_804_11));
        // N s_804_13: branch s_804_12 b807 b805
        if s_804_12 {
            return block_807(state, tracer, fn_state);
        } else {
            return block_805(state, tracer, fn_state);
        };
    }
    fn block_805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_805_0: const #0u : u8
        let s_805_0: bool = false;
        // D s_805_1: write-var gs#413085 <= s_805_0
        fn_state.gs_413085 = s_805_0;
        // N s_805_2: jump b806
        return block_806(state, tracer, fn_state);
    }
    fn block_806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_806_0: read-var gs#413085:u8
        let s_806_0: bool = fn_state.gs_413085;
        // D s_806_1: write-var gs#413086 <= s_806_0
        fn_state.gs_413086 = s_806_0;
        // N s_806_2: jump b803
        return block_803(state, tracer, fn_state);
    }
    fn block_807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_807_0: const #4s : i
        let s_807_0: i128 = 4;
        // D s_807_1: read-var u#34259:u32
        let s_807_1: u32 = fn_state.u_34259;
        // D s_807_2: cast zx s_807_1 -> bv
        let s_807_2: Bits = Bits::new(s_807_1 as u128, 32u16);
        // C s_807_3: const #1s : i64
        let s_807_3: i64 = 1;
        // C s_807_4: cast zx s_807_3 -> i
        let s_807_4: i128 = (i128::try_from(s_807_3).unwrap());
        // C s_807_5: const #0s : i
        let s_807_5: i128 = 0;
        // C s_807_6: add s_807_5 s_807_4
        let s_807_6: i128 = (s_807_5 + s_807_4);
        // D s_807_7: bit-extract s_807_2 s_807_0 s_807_6
        let s_807_7: Bits = (Bits::new(
            ((s_807_2) >> (s_807_0)).value(),
            u16::try_from(s_807_6).unwrap(),
        ));
        // D s_807_8: cast reint s_807_7 -> u8
        let s_807_8: bool = ((s_807_7.value()) != 0);
        // D s_807_9: cast zx s_807_8 -> bv
        let s_807_9: Bits = Bits::new(s_807_8 as u128, 1u16);
        // C s_807_10: const #0u : u8
        let s_807_10: bool = false;
        // C s_807_11: cast zx s_807_10 -> bv
        let s_807_11: Bits = Bits::new(s_807_10 as u128, 1u16);
        // D s_807_12: cmp-eq s_807_9 s_807_11
        let s_807_12: bool = ((s_807_9) == (s_807_11));
        // D s_807_13: write-var gs#413085 <= s_807_12
        fn_state.gs_413085 = s_807_12;
        // N s_807_14: jump b806
        return block_806(state, tracer, fn_state);
    }
    fn block_808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_808_0: const #28s : i
        let s_808_0: i128 = 28;
        // C s_808_1: const #4s : i
        let s_808_1: i128 = 4;
        // D s_808_2: read-var u#34249:u32
        let s_808_2: u32 = fn_state.u_34249;
        // D s_808_3: cast zx s_808_2 -> bv
        let s_808_3: Bits = Bits::new(s_808_2 as u128, 32u16);
        // D s_808_4: bit-extract s_808_3 s_808_0 s_808_1
        let s_808_4: Bits = (Bits::new(
            ((s_808_3) >> (s_808_0)).value(),
            u16::try_from(s_808_1).unwrap(),
        ));
        // D s_808_5: cast reint s_808_4 -> u8
        let s_808_5: u8 = (s_808_4.value() as u8);
        // D s_808_6: cast zx s_808_5 -> bv
        let s_808_6: Bits = Bits::new(s_808_5 as u128, 4u16);
        // C s_808_7: const #15u : u8
        let s_808_7: u8 = 15;
        // C s_808_8: cast zx s_808_7 -> bv
        let s_808_8: Bits = Bits::new(s_808_7 as u128, 4u16);
        // D s_808_9: cmp-ne s_808_6 s_808_8
        let s_808_9: bool = ((s_808_6) != (s_808_8));
        // N s_808_10: branch s_808_9 b811 b809
        if s_808_9 {
            return block_811(state, tracer, fn_state);
        } else {
            return block_809(state, tracer, fn_state);
        };
    }
    fn block_809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_809_0: const #0u : u8
        let s_809_0: bool = false;
        // D s_809_1: write-var gs#413054 <= s_809_0
        fn_state.gs_413054 = s_809_0;
        // N s_809_2: jump b810
        return block_810(state, tracer, fn_state);
    }
    fn block_810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_810_0: read-var gs#413054:u8
        let s_810_0: bool = fn_state.gs_413054;
        // D s_810_1: write-var gs#413055 <= s_810_0
        fn_state.gs_413055 = s_810_0;
        // N s_810_2: jump b310
        return block_310(state, tracer, fn_state);
    }
    fn block_811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_811_0: const #3577s : i
        let s_811_0: i128 = 3577;
        // C s_811_1: const #14696u : u32
        let s_811_1: u32 = 14696;
        // D s_811_2: read-reg s_811_1:i
        let s_811_2: i128 = {
            let value = state.read_register::<i128>(s_811_1 as isize);
            tracer.read_register(s_811_1 as isize, value);
            value
        };
        // D s_811_3: cmp-lt s_811_2 s_811_0
        let s_811_3: bool = ((s_811_2) < (s_811_0));
        // D s_811_4: write-var gs#413054 <= s_811_3
        fn_state.gs_413054 = s_811_3;
        // N s_811_5: jump b810
        return block_810(state, tracer, fn_state);
    }
    fn block_812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_812_0: const #20s : i
        let s_812_0: i128 = 20;
        // D s_812_1: read-var u#34249:u32
        let s_812_1: u32 = fn_state.u_34249;
        // D s_812_2: cast zx s_812_1 -> bv
        let s_812_2: Bits = Bits::new(s_812_1 as u128, 32u16);
        // C s_812_3: const #1s : i64
        let s_812_3: i64 = 1;
        // C s_812_4: cast zx s_812_3 -> i
        let s_812_4: i128 = (i128::try_from(s_812_3).unwrap());
        // C s_812_5: const #1s : i
        let s_812_5: i128 = 1;
        // C s_812_6: add s_812_5 s_812_4
        let s_812_6: i128 = (s_812_5 + s_812_4);
        // D s_812_7: bit-extract s_812_2 s_812_0 s_812_6
        let s_812_7: Bits = (Bits::new(
            ((s_812_2) >> (s_812_0)).value(),
            u16::try_from(s_812_6).unwrap(),
        ));
        // D s_812_8: cast reint s_812_7 -> u8
        let s_812_8: u8 = (s_812_7.value() as u8);
        // D s_812_9: cast zx s_812_8 -> bv
        let s_812_9: Bits = Bits::new(s_812_8 as u128, 2u16);
        // C s_812_10: const #2u : u8
        let s_812_10: u8 = 2;
        // C s_812_11: cast zx s_812_10 -> bv
        let s_812_11: Bits = Bits::new(s_812_10 as u128, 2u16);
        // D s_812_12: cmp-eq s_812_9 s_812_11
        let s_812_12: bool = ((s_812_9) == (s_812_11));
        // N s_812_13: branch s_812_12 b815 b813
        if s_812_12 {
            return block_815(state, tracer, fn_state);
        } else {
            return block_813(state, tracer, fn_state);
        };
    }
    fn block_813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_813_0: const #0u : u8
        let s_813_0: bool = false;
        // D s_813_1: write-var gs#413049 <= s_813_0
        fn_state.gs_413049 = s_813_0;
        // N s_813_2: jump b814
        return block_814(state, tracer, fn_state);
    }
    fn block_814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_814_0: read-var gs#413049:u8
        let s_814_0: bool = fn_state.gs_413049;
        // D s_814_1: write-var gs#413050 <= s_814_0
        fn_state.gs_413050 = s_814_0;
        // N s_814_2: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_815_0: const #10s : i
        let s_815_0: i128 = 10;
        // D s_815_1: read-var u#34249:u32
        let s_815_1: u32 = fn_state.u_34249;
        // D s_815_2: cast zx s_815_1 -> bv
        let s_815_2: Bits = Bits::new(s_815_1 as u128, 32u16);
        // C s_815_3: const #1s : i64
        let s_815_3: i64 = 1;
        // C s_815_4: cast zx s_815_3 -> i
        let s_815_4: i128 = (i128::try_from(s_815_3).unwrap());
        // C s_815_5: const #1s : i
        let s_815_5: i128 = 1;
        // C s_815_6: add s_815_5 s_815_4
        let s_815_6: i128 = (s_815_5 + s_815_4);
        // D s_815_7: bit-extract s_815_2 s_815_0 s_815_6
        let s_815_7: Bits = (Bits::new(
            ((s_815_2) >> (s_815_0)).value(),
            u16::try_from(s_815_6).unwrap(),
        ));
        // D s_815_8: cast reint s_815_7 -> u8
        let s_815_8: u8 = (s_815_7.value() as u8);
        // D s_815_9: cast zx s_815_8 -> bv
        let s_815_9: Bits = Bits::new(s_815_8 as u128, 2u16);
        // C s_815_10: const #2u : u8
        let s_815_10: u8 = 2;
        // C s_815_11: cast zx s_815_10 -> bv
        let s_815_11: Bits = Bits::new(s_815_10 as u128, 2u16);
        // D s_815_12: cmp-eq s_815_9 s_815_11
        let s_815_12: bool = ((s_815_9) == (s_815_11));
        // N s_815_13: branch s_815_12 b818 b816
        if s_815_12 {
            return block_818(state, tracer, fn_state);
        } else {
            return block_816(state, tracer, fn_state);
        };
    }
    fn block_816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_816_0: const #0u : u8
        let s_816_0: bool = false;
        // D s_816_1: write-var gs#413048 <= s_816_0
        fn_state.gs_413048 = s_816_0;
        // N s_816_2: jump b817
        return block_817(state, tracer, fn_state);
    }
    fn block_817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_817_0: read-var gs#413048:u8
        let s_817_0: bool = fn_state.gs_413048;
        // D s_817_1: write-var gs#413049 <= s_817_0
        fn_state.gs_413049 = s_817_0;
        // N s_817_2: jump b814
        return block_814(state, tracer, fn_state);
    }
    fn block_818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_818_0: const #6s : i
        let s_818_0: i128 = 6;
        // D s_818_1: read-var u#34249:u32
        let s_818_1: u32 = fn_state.u_34249;
        // D s_818_2: cast zx s_818_1 -> bv
        let s_818_2: Bits = Bits::new(s_818_1 as u128, 32u16);
        // C s_818_3: const #1s : i64
        let s_818_3: i64 = 1;
        // C s_818_4: cast zx s_818_3 -> i
        let s_818_4: i128 = (i128::try_from(s_818_3).unwrap());
        // C s_818_5: const #0s : i
        let s_818_5: i128 = 0;
        // C s_818_6: add s_818_5 s_818_4
        let s_818_6: i128 = (s_818_5 + s_818_4);
        // D s_818_7: bit-extract s_818_2 s_818_0 s_818_6
        let s_818_7: Bits = (Bits::new(
            ((s_818_2) >> (s_818_0)).value(),
            u16::try_from(s_818_6).unwrap(),
        ));
        // D s_818_8: cast reint s_818_7 -> u8
        let s_818_8: bool = ((s_818_7.value()) != 0);
        // D s_818_9: cast zx s_818_8 -> bv
        let s_818_9: Bits = Bits::new(s_818_8 as u128, 1u16);
        // C s_818_10: const #1u : u8
        let s_818_10: bool = true;
        // C s_818_11: cast zx s_818_10 -> bv
        let s_818_11: Bits = Bits::new(s_818_10 as u128, 1u16);
        // D s_818_12: cmp-eq s_818_9 s_818_11
        let s_818_12: bool = ((s_818_9) == (s_818_11));
        // N s_818_13: branch s_818_12 b821 b819
        if s_818_12 {
            return block_821(state, tracer, fn_state);
        } else {
            return block_819(state, tracer, fn_state);
        };
    }
    fn block_819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_819_0: const #0u : u8
        let s_819_0: bool = false;
        // D s_819_1: write-var gs#413047 <= s_819_0
        fn_state.gs_413047 = s_819_0;
        // N s_819_2: jump b820
        return block_820(state, tracer, fn_state);
    }
    fn block_820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_820_0: read-var gs#413047:u8
        let s_820_0: bool = fn_state.gs_413047;
        // D s_820_1: write-var gs#413048 <= s_820_0
        fn_state.gs_413048 = s_820_0;
        // N s_820_2: jump b817
        return block_817(state, tracer, fn_state);
    }
    fn block_821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_821_0: const #4s : i
        let s_821_0: i128 = 4;
        // D s_821_1: read-var u#34249:u32
        let s_821_1: u32 = fn_state.u_34249;
        // D s_821_2: cast zx s_821_1 -> bv
        let s_821_2: Bits = Bits::new(s_821_1 as u128, 32u16);
        // C s_821_3: const #1s : i64
        let s_821_3: i64 = 1;
        // C s_821_4: cast zx s_821_3 -> i
        let s_821_4: i128 = (i128::try_from(s_821_3).unwrap());
        // C s_821_5: const #0s : i
        let s_821_5: i128 = 0;
        // C s_821_6: add s_821_5 s_821_4
        let s_821_6: i128 = (s_821_5 + s_821_4);
        // D s_821_7: bit-extract s_821_2 s_821_0 s_821_6
        let s_821_7: Bits = (Bits::new(
            ((s_821_2) >> (s_821_0)).value(),
            u16::try_from(s_821_6).unwrap(),
        ));
        // D s_821_8: cast reint s_821_7 -> u8
        let s_821_8: bool = ((s_821_7.value()) != 0);
        // D s_821_9: cast zx s_821_8 -> bv
        let s_821_9: Bits = Bits::new(s_821_8 as u128, 1u16);
        // C s_821_10: const #0u : u8
        let s_821_10: bool = false;
        // C s_821_11: cast zx s_821_10 -> bv
        let s_821_11: Bits = Bits::new(s_821_10 as u128, 1u16);
        // D s_821_12: cmp-eq s_821_9 s_821_11
        let s_821_12: bool = ((s_821_9) == (s_821_11));
        // D s_821_13: write-var gs#413047 <= s_821_12
        fn_state.gs_413047 = s_821_12;
        // N s_821_14: jump b820
        return block_820(state, tracer, fn_state);
    }
    fn block_822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_822_0: const #28s : i
        let s_822_0: i128 = 28;
        // C s_822_1: const #4s : i
        let s_822_1: i128 = 4;
        // D s_822_2: read-var u#34238:u32
        let s_822_2: u32 = fn_state.u_34238;
        // D s_822_3: cast zx s_822_2 -> bv
        let s_822_3: Bits = Bits::new(s_822_2 as u128, 32u16);
        // D s_822_4: bit-extract s_822_3 s_822_0 s_822_1
        let s_822_4: Bits = (Bits::new(
            ((s_822_3) >> (s_822_0)).value(),
            u16::try_from(s_822_1).unwrap(),
        ));
        // D s_822_5: cast reint s_822_4 -> u8
        let s_822_5: u8 = (s_822_4.value() as u8);
        // D s_822_6: cast zx s_822_5 -> bv
        let s_822_6: Bits = Bits::new(s_822_5 as u128, 4u16);
        // C s_822_7: const #15u : u8
        let s_822_7: u8 = 15;
        // C s_822_8: cast zx s_822_7 -> bv
        let s_822_8: Bits = Bits::new(s_822_7 as u128, 4u16);
        // D s_822_9: cmp-ne s_822_6 s_822_8
        let s_822_9: bool = ((s_822_6) != (s_822_8));
        // N s_822_10: branch s_822_9 b825 b823
        if s_822_9 {
            return block_825(state, tracer, fn_state);
        } else {
            return block_823(state, tracer, fn_state);
        };
    }
    fn block_823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_823_0: const #0u : u8
        let s_823_0: bool = false;
        // D s_823_1: write-var gs#413014 <= s_823_0
        fn_state.gs_413014 = s_823_0;
        // N s_823_2: jump b824
        return block_824(state, tracer, fn_state);
    }
    fn block_824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_824_0: read-var gs#413014:u8
        let s_824_0: bool = fn_state.gs_413014;
        // D s_824_1: write-var gs#413015 <= s_824_0
        fn_state.gs_413015 = s_824_0;
        // N s_824_2: jump b304
        return block_304(state, tracer, fn_state);
    }
    fn block_825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_825_0: const #3576s : i
        let s_825_0: i128 = 3576;
        // C s_825_1: const #14696u : u32
        let s_825_1: u32 = 14696;
        // D s_825_2: read-reg s_825_1:i
        let s_825_2: i128 = {
            let value = state.read_register::<i128>(s_825_1 as isize);
            tracer.read_register(s_825_1 as isize, value);
            value
        };
        // D s_825_3: cmp-lt s_825_2 s_825_0
        let s_825_3: bool = ((s_825_2) < (s_825_0));
        // D s_825_4: write-var gs#413014 <= s_825_3
        fn_state.gs_413014 = s_825_3;
        // N s_825_5: jump b824
        return block_824(state, tracer, fn_state);
    }
    fn block_826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_826_0: const #20s : i
        let s_826_0: i128 = 20;
        // D s_826_1: read-var u#34238:u32
        let s_826_1: u32 = fn_state.u_34238;
        // D s_826_2: cast zx s_826_1 -> bv
        let s_826_2: Bits = Bits::new(s_826_1 as u128, 32u16);
        // C s_826_3: const #1s : i64
        let s_826_3: i64 = 1;
        // C s_826_4: cast zx s_826_3 -> i
        let s_826_4: i128 = (i128::try_from(s_826_3).unwrap());
        // C s_826_5: const #1s : i
        let s_826_5: i128 = 1;
        // C s_826_6: add s_826_5 s_826_4
        let s_826_6: i128 = (s_826_5 + s_826_4);
        // D s_826_7: bit-extract s_826_2 s_826_0 s_826_6
        let s_826_7: Bits = (Bits::new(
            ((s_826_2) >> (s_826_0)).value(),
            u16::try_from(s_826_6).unwrap(),
        ));
        // D s_826_8: cast reint s_826_7 -> u8
        let s_826_8: u8 = (s_826_7.value() as u8);
        // D s_826_9: cast zx s_826_8 -> bv
        let s_826_9: Bits = Bits::new(s_826_8 as u128, 2u16);
        // C s_826_10: const #1u : u8
        let s_826_10: u8 = 1;
        // C s_826_11: cast zx s_826_10 -> bv
        let s_826_11: Bits = Bits::new(s_826_10 as u128, 2u16);
        // D s_826_12: cmp-eq s_826_9 s_826_11
        let s_826_12: bool = ((s_826_9) == (s_826_11));
        // N s_826_13: branch s_826_12 b829 b827
        if s_826_12 {
            return block_829(state, tracer, fn_state);
        } else {
            return block_827(state, tracer, fn_state);
        };
    }
    fn block_827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_827_0: const #0u : u8
        let s_827_0: bool = false;
        // D s_827_1: write-var gs#413009 <= s_827_0
        fn_state.gs_413009 = s_827_0;
        // N s_827_2: jump b828
        return block_828(state, tracer, fn_state);
    }
    fn block_828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_828_0: read-var gs#413009:u8
        let s_828_0: bool = fn_state.gs_413009;
        // D s_828_1: write-var gs#413010 <= s_828_0
        fn_state.gs_413010 = s_828_0;
        // N s_828_2: jump b302
        return block_302(state, tracer, fn_state);
    }
    fn block_829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_829_0: const #10s : i
        let s_829_0: i128 = 10;
        // D s_829_1: read-var u#34238:u32
        let s_829_1: u32 = fn_state.u_34238;
        // D s_829_2: cast zx s_829_1 -> bv
        let s_829_2: Bits = Bits::new(s_829_1 as u128, 32u16);
        // C s_829_3: const #1s : i64
        let s_829_3: i64 = 1;
        // C s_829_4: cast zx s_829_3 -> i
        let s_829_4: i128 = (i128::try_from(s_829_3).unwrap());
        // C s_829_5: const #1s : i
        let s_829_5: i128 = 1;
        // C s_829_6: add s_829_5 s_829_4
        let s_829_6: i128 = (s_829_5 + s_829_4);
        // D s_829_7: bit-extract s_829_2 s_829_0 s_829_6
        let s_829_7: Bits = (Bits::new(
            ((s_829_2) >> (s_829_0)).value(),
            u16::try_from(s_829_6).unwrap(),
        ));
        // D s_829_8: cast reint s_829_7 -> u8
        let s_829_8: u8 = (s_829_7.value() as u8);
        // D s_829_9: cast zx s_829_8 -> bv
        let s_829_9: Bits = Bits::new(s_829_8 as u128, 2u16);
        // C s_829_10: const #2u : u8
        let s_829_10: u8 = 2;
        // C s_829_11: cast zx s_829_10 -> bv
        let s_829_11: Bits = Bits::new(s_829_10 as u128, 2u16);
        // D s_829_12: cmp-eq s_829_9 s_829_11
        let s_829_12: bool = ((s_829_9) == (s_829_11));
        // N s_829_13: branch s_829_12 b832 b830
        if s_829_12 {
            return block_832(state, tracer, fn_state);
        } else {
            return block_830(state, tracer, fn_state);
        };
    }
    fn block_830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_830_0: const #0u : u8
        let s_830_0: bool = false;
        // D s_830_1: write-var gs#413008 <= s_830_0
        fn_state.gs_413008 = s_830_0;
        // N s_830_2: jump b831
        return block_831(state, tracer, fn_state);
    }
    fn block_831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_831_0: read-var gs#413008:u8
        let s_831_0: bool = fn_state.gs_413008;
        // D s_831_1: write-var gs#413009 <= s_831_0
        fn_state.gs_413009 = s_831_0;
        // N s_831_2: jump b828
        return block_828(state, tracer, fn_state);
    }
    fn block_832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_832_0: const #4s : i
        let s_832_0: i128 = 4;
        // D s_832_1: read-var u#34238:u32
        let s_832_1: u32 = fn_state.u_34238;
        // D s_832_2: cast zx s_832_1 -> bv
        let s_832_2: Bits = Bits::new(s_832_1 as u128, 32u16);
        // C s_832_3: const #1s : i64
        let s_832_3: i64 = 1;
        // C s_832_4: cast zx s_832_3 -> i
        let s_832_4: i128 = (i128::try_from(s_832_3).unwrap());
        // C s_832_5: const #0s : i
        let s_832_5: i128 = 0;
        // C s_832_6: add s_832_5 s_832_4
        let s_832_6: i128 = (s_832_5 + s_832_4);
        // D s_832_7: bit-extract s_832_2 s_832_0 s_832_6
        let s_832_7: Bits = (Bits::new(
            ((s_832_2) >> (s_832_0)).value(),
            u16::try_from(s_832_6).unwrap(),
        ));
        // D s_832_8: cast reint s_832_7 -> u8
        let s_832_8: bool = ((s_832_7.value()) != 0);
        // D s_832_9: cast zx s_832_8 -> bv
        let s_832_9: Bits = Bits::new(s_832_8 as u128, 1u16);
        // C s_832_10: const #0u : u8
        let s_832_10: bool = false;
        // C s_832_11: cast zx s_832_10 -> bv
        let s_832_11: Bits = Bits::new(s_832_10 as u128, 1u16);
        // D s_832_12: cmp-eq s_832_9 s_832_11
        let s_832_12: bool = ((s_832_9) == (s_832_11));
        // D s_832_13: write-var gs#413008 <= s_832_12
        fn_state.gs_413008 = s_832_12;
        // N s_832_14: jump b831
        return block_831(state, tracer, fn_state);
    }
    fn block_833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_833_0: const #28s : i
        let s_833_0: i128 = 28;
        // C s_833_1: const #4s : i
        let s_833_1: i128 = 4;
        // D s_833_2: read-var u#34230:u32
        let s_833_2: u32 = fn_state.u_34230;
        // D s_833_3: cast zx s_833_2 -> bv
        let s_833_3: Bits = Bits::new(s_833_2 as u128, 32u16);
        // D s_833_4: bit-extract s_833_3 s_833_0 s_833_1
        let s_833_4: Bits = (Bits::new(
            ((s_833_3) >> (s_833_0)).value(),
            u16::try_from(s_833_1).unwrap(),
        ));
        // D s_833_5: cast reint s_833_4 -> u8
        let s_833_5: u8 = (s_833_4.value() as u8);
        // D s_833_6: cast zx s_833_5 -> bv
        let s_833_6: Bits = Bits::new(s_833_5 as u128, 4u16);
        // C s_833_7: const #15u : u8
        let s_833_7: u8 = 15;
        // C s_833_8: cast zx s_833_7 -> bv
        let s_833_8: Bits = Bits::new(s_833_7 as u128, 4u16);
        // D s_833_9: cmp-ne s_833_6 s_833_8
        let s_833_9: bool = ((s_833_6) != (s_833_8));
        // N s_833_10: branch s_833_9 b836 b834
        if s_833_9 {
            return block_836(state, tracer, fn_state);
        } else {
            return block_834(state, tracer, fn_state);
        };
    }
    fn block_834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_834_0: const #0u : u8
        let s_834_0: bool = false;
        // D s_834_1: write-var gs#412983 <= s_834_0
        fn_state.gs_412983 = s_834_0;
        // N s_834_2: jump b835
        return block_835(state, tracer, fn_state);
    }
    fn block_835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_835_0: read-var gs#412983:u8
        let s_835_0: bool = fn_state.gs_412983;
        // D s_835_1: write-var gs#412984 <= s_835_0
        fn_state.gs_412984 = s_835_0;
        // N s_835_2: jump b298
        return block_298(state, tracer, fn_state);
    }
    fn block_836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_836_0: const #3573s : i
        let s_836_0: i128 = 3573;
        // C s_836_1: const #14696u : u32
        let s_836_1: u32 = 14696;
        // D s_836_2: read-reg s_836_1:i
        let s_836_2: i128 = {
            let value = state.read_register::<i128>(s_836_1 as isize);
            tracer.read_register(s_836_1 as isize, value);
            value
        };
        // D s_836_3: cmp-lt s_836_2 s_836_0
        let s_836_3: bool = ((s_836_2) < (s_836_0));
        // D s_836_4: write-var gs#412983 <= s_836_3
        fn_state.gs_412983 = s_836_3;
        // N s_836_5: jump b835
        return block_835(state, tracer, fn_state);
    }
    fn block_837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_837_0: const #16s : i
        let s_837_0: i128 = 16;
        // D s_837_1: read-var u#34230:u32
        let s_837_1: u32 = fn_state.u_34230;
        // D s_837_2: cast zx s_837_1 -> bv
        let s_837_2: Bits = Bits::new(s_837_1 as u128, 32u16);
        // C s_837_3: const #1s : i64
        let s_837_3: i64 = 1;
        // C s_837_4: cast zx s_837_3 -> i
        let s_837_4: i128 = (i128::try_from(s_837_3).unwrap());
        // C s_837_5: const #5s : i
        let s_837_5: i128 = 5;
        // C s_837_6: add s_837_5 s_837_4
        let s_837_6: i128 = (s_837_5 + s_837_4);
        // D s_837_7: bit-extract s_837_2 s_837_0 s_837_6
        let s_837_7: Bits = (Bits::new(
            ((s_837_2) >> (s_837_0)).value(),
            u16::try_from(s_837_6).unwrap(),
        ));
        // D s_837_8: cast reint s_837_7 -> u8
        let s_837_8: u8 = (s_837_7.value() as u8);
        // D s_837_9: cast zx s_837_8 -> bv
        let s_837_9: Bits = Bits::new(s_837_8 as u128, 6u16);
        // C s_837_10: const #49u : u8
        let s_837_10: u8 = 49;
        // C s_837_11: cast zx s_837_10 -> bv
        let s_837_11: Bits = Bits::new(s_837_10 as u128, 6u16);
        // D s_837_12: cmp-eq s_837_9 s_837_11
        let s_837_12: bool = ((s_837_9) == (s_837_11));
        // N s_837_13: branch s_837_12 b840 b838
        if s_837_12 {
            return block_840(state, tracer, fn_state);
        } else {
            return block_838(state, tracer, fn_state);
        };
    }
    fn block_838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_838_0: const #0u : u8
        let s_838_0: bool = false;
        // D s_838_1: write-var gs#412978 <= s_838_0
        fn_state.gs_412978 = s_838_0;
        // N s_838_2: jump b839
        return block_839(state, tracer, fn_state);
    }
    fn block_839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_839_0: read-var gs#412978:u8
        let s_839_0: bool = fn_state.gs_412978;
        // D s_839_1: write-var gs#412979 <= s_839_0
        fn_state.gs_412979 = s_839_0;
        // N s_839_2: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_840_0: const #10s : i
        let s_840_0: i128 = 10;
        // D s_840_1: read-var u#34230:u32
        let s_840_1: u32 = fn_state.u_34230;
        // D s_840_2: cast zx s_840_1 -> bv
        let s_840_2: Bits = Bits::new(s_840_1 as u128, 32u16);
        // C s_840_3: const #1s : i64
        let s_840_3: i64 = 1;
        // C s_840_4: cast zx s_840_3 -> i
        let s_840_4: i128 = (i128::try_from(s_840_3).unwrap());
        // C s_840_5: const #1s : i
        let s_840_5: i128 = 1;
        // C s_840_6: add s_840_5 s_840_4
        let s_840_6: i128 = (s_840_5 + s_840_4);
        // D s_840_7: bit-extract s_840_2 s_840_0 s_840_6
        let s_840_7: Bits = (Bits::new(
            ((s_840_2) >> (s_840_0)).value(),
            u16::try_from(s_840_6).unwrap(),
        ));
        // D s_840_8: cast reint s_840_7 -> u8
        let s_840_8: u8 = (s_840_7.value() as u8);
        // D s_840_9: cast zx s_840_8 -> bv
        let s_840_9: Bits = Bits::new(s_840_8 as u128, 2u16);
        // C s_840_10: const #2u : u8
        let s_840_10: u8 = 2;
        // C s_840_11: cast zx s_840_10 -> bv
        let s_840_11: Bits = Bits::new(s_840_10 as u128, 2u16);
        // D s_840_12: cmp-eq s_840_9 s_840_11
        let s_840_12: bool = ((s_840_9) == (s_840_11));
        // N s_840_13: branch s_840_12 b843 b841
        if s_840_12 {
            return block_843(state, tracer, fn_state);
        } else {
            return block_841(state, tracer, fn_state);
        };
    }
    fn block_841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_841_0: const #0u : u8
        let s_841_0: bool = false;
        // D s_841_1: write-var gs#412977 <= s_841_0
        fn_state.gs_412977 = s_841_0;
        // N s_841_2: jump b842
        return block_842(state, tracer, fn_state);
    }
    fn block_842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_842_0: read-var gs#412977:u8
        let s_842_0: bool = fn_state.gs_412977;
        // D s_842_1: write-var gs#412978 <= s_842_0
        fn_state.gs_412978 = s_842_0;
        // N s_842_2: jump b839
        return block_839(state, tracer, fn_state);
    }
    fn block_843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_843_0: const #6s : i
        let s_843_0: i128 = 6;
        // D s_843_1: read-var u#34230:u32
        let s_843_1: u32 = fn_state.u_34230;
        // D s_843_2: cast zx s_843_1 -> bv
        let s_843_2: Bits = Bits::new(s_843_1 as u128, 32u16);
        // C s_843_3: const #1s : i64
        let s_843_3: i64 = 1;
        // C s_843_4: cast zx s_843_3 -> i
        let s_843_4: i128 = (i128::try_from(s_843_3).unwrap());
        // C s_843_5: const #1s : i
        let s_843_5: i128 = 1;
        // C s_843_6: add s_843_5 s_843_4
        let s_843_6: i128 = (s_843_5 + s_843_4);
        // D s_843_7: bit-extract s_843_2 s_843_0 s_843_6
        let s_843_7: Bits = (Bits::new(
            ((s_843_2) >> (s_843_0)).value(),
            u16::try_from(s_843_6).unwrap(),
        ));
        // D s_843_8: cast reint s_843_7 -> u8
        let s_843_8: u8 = (s_843_7.value() as u8);
        // D s_843_9: cast zx s_843_8 -> bv
        let s_843_9: Bits = Bits::new(s_843_8 as u128, 2u16);
        // C s_843_10: const #1u : u8
        let s_843_10: u8 = 1;
        // C s_843_11: cast zx s_843_10 -> bv
        let s_843_11: Bits = Bits::new(s_843_10 as u128, 2u16);
        // D s_843_12: cmp-eq s_843_9 s_843_11
        let s_843_12: bool = ((s_843_9) == (s_843_11));
        // N s_843_13: branch s_843_12 b846 b844
        if s_843_12 {
            return block_846(state, tracer, fn_state);
        } else {
            return block_844(state, tracer, fn_state);
        };
    }
    fn block_844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_844_0: const #0u : u8
        let s_844_0: bool = false;
        // D s_844_1: write-var gs#412976 <= s_844_0
        fn_state.gs_412976 = s_844_0;
        // N s_844_2: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_845_0: read-var gs#412976:u8
        let s_845_0: bool = fn_state.gs_412976;
        // D s_845_1: write-var gs#412977 <= s_845_0
        fn_state.gs_412977 = s_845_0;
        // N s_845_2: jump b842
        return block_842(state, tracer, fn_state);
    }
    fn block_846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_846_0: const #4s : i
        let s_846_0: i128 = 4;
        // D s_846_1: read-var u#34230:u32
        let s_846_1: u32 = fn_state.u_34230;
        // D s_846_2: cast zx s_846_1 -> bv
        let s_846_2: Bits = Bits::new(s_846_1 as u128, 32u16);
        // C s_846_3: const #1s : i64
        let s_846_3: i64 = 1;
        // C s_846_4: cast zx s_846_3 -> i
        let s_846_4: i128 = (i128::try_from(s_846_3).unwrap());
        // C s_846_5: const #0s : i
        let s_846_5: i128 = 0;
        // C s_846_6: add s_846_5 s_846_4
        let s_846_6: i128 = (s_846_5 + s_846_4);
        // D s_846_7: bit-extract s_846_2 s_846_0 s_846_6
        let s_846_7: Bits = (Bits::new(
            ((s_846_2) >> (s_846_0)).value(),
            u16::try_from(s_846_6).unwrap(),
        ));
        // D s_846_8: cast reint s_846_7 -> u8
        let s_846_8: bool = ((s_846_7.value()) != 0);
        // D s_846_9: cast zx s_846_8 -> bv
        let s_846_9: Bits = Bits::new(s_846_8 as u128, 1u16);
        // C s_846_10: const #0u : u8
        let s_846_10: bool = false;
        // C s_846_11: cast zx s_846_10 -> bv
        let s_846_11: Bits = Bits::new(s_846_10 as u128, 1u16);
        // D s_846_12: cmp-eq s_846_9 s_846_11
        let s_846_12: bool = ((s_846_9) == (s_846_11));
        // D s_846_13: write-var gs#412976 <= s_846_12
        fn_state.gs_412976 = s_846_12;
        // N s_846_14: jump b845
        return block_845(state, tracer, fn_state);
    }
    fn block_847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_847_0: const #28s : i
        let s_847_0: i128 = 28;
        // C s_847_1: const #4s : i
        let s_847_1: i128 = 4;
        // D s_847_2: read-var u#34220:u32
        let s_847_2: u32 = fn_state.u_34220;
        // D s_847_3: cast zx s_847_2 -> bv
        let s_847_3: Bits = Bits::new(s_847_2 as u128, 32u16);
        // D s_847_4: bit-extract s_847_3 s_847_0 s_847_1
        let s_847_4: Bits = (Bits::new(
            ((s_847_3) >> (s_847_0)).value(),
            u16::try_from(s_847_1).unwrap(),
        ));
        // D s_847_5: cast reint s_847_4 -> u8
        let s_847_5: u8 = (s_847_4.value() as u8);
        // D s_847_6: cast zx s_847_5 -> bv
        let s_847_6: Bits = Bits::new(s_847_5 as u128, 4u16);
        // C s_847_7: const #15u : u8
        let s_847_7: u8 = 15;
        // C s_847_8: cast zx s_847_7 -> bv
        let s_847_8: Bits = Bits::new(s_847_7 as u128, 4u16);
        // D s_847_9: cmp-ne s_847_6 s_847_8
        let s_847_9: bool = ((s_847_6) != (s_847_8));
        // N s_847_10: branch s_847_9 b850 b848
        if s_847_9 {
            return block_850(state, tracer, fn_state);
        } else {
            return block_848(state, tracer, fn_state);
        };
    }
    fn block_848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_848_0: const #0u : u8
        let s_848_0: bool = false;
        // D s_848_1: write-var gs#412945 <= s_848_0
        fn_state.gs_412945 = s_848_0;
        // N s_848_2: jump b849
        return block_849(state, tracer, fn_state);
    }
    fn block_849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_849_0: read-var gs#412945:u8
        let s_849_0: bool = fn_state.gs_412945;
        // D s_849_1: write-var gs#412946 <= s_849_0
        fn_state.gs_412946 = s_849_0;
        // N s_849_2: jump b292
        return block_292(state, tracer, fn_state);
    }
    fn block_850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_850_0: const #3553s : i
        let s_850_0: i128 = 3553;
        // C s_850_1: const #14696u : u32
        let s_850_1: u32 = 14696;
        // D s_850_2: read-reg s_850_1:i
        let s_850_2: i128 = {
            let value = state.read_register::<i128>(s_850_1 as isize);
            tracer.read_register(s_850_1 as isize, value);
            value
        };
        // D s_850_3: cmp-lt s_850_2 s_850_0
        let s_850_3: bool = ((s_850_2) < (s_850_0));
        // D s_850_4: write-var gs#412945 <= s_850_3
        fn_state.gs_412945 = s_850_3;
        // N s_850_5: jump b849
        return block_849(state, tracer, fn_state);
    }
    fn block_851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_851_0: const #20s : i
        let s_851_0: i128 = 20;
        // D s_851_1: read-var u#34220:u32
        let s_851_1: u32 = fn_state.u_34220;
        // D s_851_2: cast zx s_851_1 -> bv
        let s_851_2: Bits = Bits::new(s_851_1 as u128, 32u16);
        // C s_851_3: const #1s : i64
        let s_851_3: i64 = 1;
        // C s_851_4: cast zx s_851_3 -> i
        let s_851_4: i128 = (i128::try_from(s_851_3).unwrap());
        // C s_851_5: const #1s : i
        let s_851_5: i128 = 1;
        // C s_851_6: add s_851_5 s_851_4
        let s_851_6: i128 = (s_851_5 + s_851_4);
        // D s_851_7: bit-extract s_851_2 s_851_0 s_851_6
        let s_851_7: Bits = (Bits::new(
            ((s_851_2) >> (s_851_0)).value(),
            u16::try_from(s_851_6).unwrap(),
        ));
        // D s_851_8: cast reint s_851_7 -> u8
        let s_851_8: u8 = (s_851_7.value() as u8);
        // D s_851_9: cast zx s_851_8 -> bv
        let s_851_9: Bits = Bits::new(s_851_8 as u128, 2u16);
        // C s_851_10: const #2u : u8
        let s_851_10: u8 = 2;
        // C s_851_11: cast zx s_851_10 -> bv
        let s_851_11: Bits = Bits::new(s_851_10 as u128, 2u16);
        // D s_851_12: cmp-eq s_851_9 s_851_11
        let s_851_12: bool = ((s_851_9) == (s_851_11));
        // N s_851_13: branch s_851_12 b854 b852
        if s_851_12 {
            return block_854(state, tracer, fn_state);
        } else {
            return block_852(state, tracer, fn_state);
        };
    }
    fn block_852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_852_0: const #0u : u8
        let s_852_0: bool = false;
        // D s_852_1: write-var gs#412940 <= s_852_0
        fn_state.gs_412940 = s_852_0;
        // N s_852_2: jump b853
        return block_853(state, tracer, fn_state);
    }
    fn block_853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_853_0: read-var gs#412940:u8
        let s_853_0: bool = fn_state.gs_412940;
        // D s_853_1: write-var gs#412941 <= s_853_0
        fn_state.gs_412941 = s_853_0;
        // N s_853_2: jump b290
        return block_290(state, tracer, fn_state);
    }
    fn block_854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_854_0: const #10s : i
        let s_854_0: i128 = 10;
        // D s_854_1: read-var u#34220:u32
        let s_854_1: u32 = fn_state.u_34220;
        // D s_854_2: cast zx s_854_1 -> bv
        let s_854_2: Bits = Bits::new(s_854_1 as u128, 32u16);
        // C s_854_3: const #1s : i64
        let s_854_3: i64 = 1;
        // C s_854_4: cast zx s_854_3 -> i
        let s_854_4: i128 = (i128::try_from(s_854_3).unwrap());
        // C s_854_5: const #1s : i
        let s_854_5: i128 = 1;
        // C s_854_6: add s_854_5 s_854_4
        let s_854_6: i128 = (s_854_5 + s_854_4);
        // D s_854_7: bit-extract s_854_2 s_854_0 s_854_6
        let s_854_7: Bits = (Bits::new(
            ((s_854_2) >> (s_854_0)).value(),
            u16::try_from(s_854_6).unwrap(),
        ));
        // D s_854_8: cast reint s_854_7 -> u8
        let s_854_8: u8 = (s_854_7.value() as u8);
        // D s_854_9: cast zx s_854_8 -> bv
        let s_854_9: Bits = Bits::new(s_854_8 as u128, 2u16);
        // C s_854_10: const #2u : u8
        let s_854_10: u8 = 2;
        // C s_854_11: cast zx s_854_10 -> bv
        let s_854_11: Bits = Bits::new(s_854_10 as u128, 2u16);
        // D s_854_12: cmp-eq s_854_9 s_854_11
        let s_854_12: bool = ((s_854_9) == (s_854_11));
        // N s_854_13: branch s_854_12 b857 b855
        if s_854_12 {
            return block_857(state, tracer, fn_state);
        } else {
            return block_855(state, tracer, fn_state);
        };
    }
    fn block_855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_855_0: const #0u : u8
        let s_855_0: bool = false;
        // D s_855_1: write-var gs#412939 <= s_855_0
        fn_state.gs_412939 = s_855_0;
        // N s_855_2: jump b856
        return block_856(state, tracer, fn_state);
    }
    fn block_856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_856_0: read-var gs#412939:u8
        let s_856_0: bool = fn_state.gs_412939;
        // D s_856_1: write-var gs#412940 <= s_856_0
        fn_state.gs_412940 = s_856_0;
        // N s_856_2: jump b853
        return block_853(state, tracer, fn_state);
    }
    fn block_857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_857_0: const #6s : i
        let s_857_0: i128 = 6;
        // D s_857_1: read-var u#34220:u32
        let s_857_1: u32 = fn_state.u_34220;
        // D s_857_2: cast zx s_857_1 -> bv
        let s_857_2: Bits = Bits::new(s_857_1 as u128, 32u16);
        // C s_857_3: const #1s : i64
        let s_857_3: i64 = 1;
        // C s_857_4: cast zx s_857_3 -> i
        let s_857_4: i128 = (i128::try_from(s_857_3).unwrap());
        // C s_857_5: const #0s : i
        let s_857_5: i128 = 0;
        // C s_857_6: add s_857_5 s_857_4
        let s_857_6: i128 = (s_857_5 + s_857_4);
        // D s_857_7: bit-extract s_857_2 s_857_0 s_857_6
        let s_857_7: Bits = (Bits::new(
            ((s_857_2) >> (s_857_0)).value(),
            u16::try_from(s_857_6).unwrap(),
        ));
        // D s_857_8: cast reint s_857_7 -> u8
        let s_857_8: bool = ((s_857_7.value()) != 0);
        // D s_857_9: cast zx s_857_8 -> bv
        let s_857_9: Bits = Bits::new(s_857_8 as u128, 1u16);
        // C s_857_10: const #0u : u8
        let s_857_10: bool = false;
        // C s_857_11: cast zx s_857_10 -> bv
        let s_857_11: Bits = Bits::new(s_857_10 as u128, 1u16);
        // D s_857_12: cmp-eq s_857_9 s_857_11
        let s_857_12: bool = ((s_857_9) == (s_857_11));
        // N s_857_13: branch s_857_12 b860 b858
        if s_857_12 {
            return block_860(state, tracer, fn_state);
        } else {
            return block_858(state, tracer, fn_state);
        };
    }
    fn block_858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_858_0: const #0u : u8
        let s_858_0: bool = false;
        // D s_858_1: write-var gs#412938 <= s_858_0
        fn_state.gs_412938 = s_858_0;
        // N s_858_2: jump b859
        return block_859(state, tracer, fn_state);
    }
    fn block_859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_859_0: read-var gs#412938:u8
        let s_859_0: bool = fn_state.gs_412938;
        // D s_859_1: write-var gs#412939 <= s_859_0
        fn_state.gs_412939 = s_859_0;
        // N s_859_2: jump b856
        return block_856(state, tracer, fn_state);
    }
    fn block_860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_860_0: const #4s : i
        let s_860_0: i128 = 4;
        // D s_860_1: read-var u#34220:u32
        let s_860_1: u32 = fn_state.u_34220;
        // D s_860_2: cast zx s_860_1 -> bv
        let s_860_2: Bits = Bits::new(s_860_1 as u128, 32u16);
        // C s_860_3: const #1s : i64
        let s_860_3: i64 = 1;
        // C s_860_4: cast zx s_860_3 -> i
        let s_860_4: i128 = (i128::try_from(s_860_3).unwrap());
        // C s_860_5: const #0s : i
        let s_860_5: i128 = 0;
        // C s_860_6: add s_860_5 s_860_4
        let s_860_6: i128 = (s_860_5 + s_860_4);
        // D s_860_7: bit-extract s_860_2 s_860_0 s_860_6
        let s_860_7: Bits = (Bits::new(
            ((s_860_2) >> (s_860_0)).value(),
            u16::try_from(s_860_6).unwrap(),
        ));
        // D s_860_8: cast reint s_860_7 -> u8
        let s_860_8: bool = ((s_860_7.value()) != 0);
        // D s_860_9: cast zx s_860_8 -> bv
        let s_860_9: Bits = Bits::new(s_860_8 as u128, 1u16);
        // C s_860_10: const #0u : u8
        let s_860_10: bool = false;
        // C s_860_11: cast zx s_860_10 -> bv
        let s_860_11: Bits = Bits::new(s_860_10 as u128, 1u16);
        // D s_860_12: cmp-eq s_860_9 s_860_11
        let s_860_12: bool = ((s_860_9) == (s_860_11));
        // D s_860_13: write-var gs#412938 <= s_860_12
        fn_state.gs_412938 = s_860_12;
        // N s_860_14: jump b859
        return block_859(state, tracer, fn_state);
    }
    fn block_861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_861_0: const #28s : i
        let s_861_0: i128 = 28;
        // C s_861_1: const #4s : i
        let s_861_1: i128 = 4;
        // D s_861_2: read-var u#34212:u32
        let s_861_2: u32 = fn_state.u_34212;
        // D s_861_3: cast zx s_861_2 -> bv
        let s_861_3: Bits = Bits::new(s_861_2 as u128, 32u16);
        // D s_861_4: bit-extract s_861_3 s_861_0 s_861_1
        let s_861_4: Bits = (Bits::new(
            ((s_861_3) >> (s_861_0)).value(),
            u16::try_from(s_861_1).unwrap(),
        ));
        // D s_861_5: cast reint s_861_4 -> u8
        let s_861_5: u8 = (s_861_4.value() as u8);
        // D s_861_6: cast zx s_861_5 -> bv
        let s_861_6: Bits = Bits::new(s_861_5 as u128, 4u16);
        // C s_861_7: const #15u : u8
        let s_861_7: u8 = 15;
        // C s_861_8: cast zx s_861_7 -> bv
        let s_861_8: Bits = Bits::new(s_861_7 as u128, 4u16);
        // D s_861_9: cmp-ne s_861_6 s_861_8
        let s_861_9: bool = ((s_861_6) != (s_861_8));
        // N s_861_10: branch s_861_9 b864 b862
        if s_861_9 {
            return block_864(state, tracer, fn_state);
        } else {
            return block_862(state, tracer, fn_state);
        };
    }
    fn block_862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_862_0: const #0u : u8
        let s_862_0: bool = false;
        // D s_862_1: write-var gs#412911 <= s_862_0
        fn_state.gs_412911 = s_862_0;
        // N s_862_2: jump b863
        return block_863(state, tracer, fn_state);
    }
    fn block_863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_863_0: read-var gs#412911:u8
        let s_863_0: bool = fn_state.gs_412911;
        // D s_863_1: write-var gs#412912 <= s_863_0
        fn_state.gs_412912 = s_863_0;
        // N s_863_2: jump b286
        return block_286(state, tracer, fn_state);
    }
    fn block_864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_864_0: const #3550s : i
        let s_864_0: i128 = 3550;
        // C s_864_1: const #14696u : u32
        let s_864_1: u32 = 14696;
        // D s_864_2: read-reg s_864_1:i
        let s_864_2: i128 = {
            let value = state.read_register::<i128>(s_864_1 as isize);
            tracer.read_register(s_864_1 as isize, value);
            value
        };
        // D s_864_3: cmp-lt s_864_2 s_864_0
        let s_864_3: bool = ((s_864_2) < (s_864_0));
        // D s_864_4: write-var gs#412911 <= s_864_3
        fn_state.gs_412911 = s_864_3;
        // N s_864_5: jump b863
        return block_863(state, tracer, fn_state);
    }
    fn block_865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_865_0: const #6s : i
        let s_865_0: i128 = 6;
        // D s_865_1: read-var u#34212:u32
        let s_865_1: u32 = fn_state.u_34212;
        // D s_865_2: cast zx s_865_1 -> bv
        let s_865_2: Bits = Bits::new(s_865_1 as u128, 32u16);
        // C s_865_3: const #1s : i64
        let s_865_3: i64 = 1;
        // C s_865_4: cast zx s_865_3 -> i
        let s_865_4: i128 = (i128::try_from(s_865_3).unwrap());
        // C s_865_5: const #5s : i
        let s_865_5: i128 = 5;
        // C s_865_6: add s_865_5 s_865_4
        let s_865_6: i128 = (s_865_5 + s_865_4);
        // D s_865_7: bit-extract s_865_2 s_865_0 s_865_6
        let s_865_7: Bits = (Bits::new(
            ((s_865_2) >> (s_865_0)).value(),
            u16::try_from(s_865_6).unwrap(),
        ));
        // D s_865_8: cast reint s_865_7 -> u8
        let s_865_8: u8 = (s_865_7.value() as u8);
        // D s_865_9: cast zx s_865_8 -> bv
        let s_865_9: Bits = Bits::new(s_865_8 as u128, 6u16);
        // C s_865_10: const #40u : u8
        let s_865_10: u8 = 40;
        // C s_865_11: cast zx s_865_10 -> bv
        let s_865_11: Bits = Bits::new(s_865_10 as u128, 6u16);
        // D s_865_12: cmp-eq s_865_9 s_865_11
        let s_865_12: bool = ((s_865_9) == (s_865_11));
        // N s_865_13: branch s_865_12 b868 b866
        if s_865_12 {
            return block_868(state, tracer, fn_state);
        } else {
            return block_866(state, tracer, fn_state);
        };
    }
    fn block_866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_866_0: const #0u : u8
        let s_866_0: bool = false;
        // D s_866_1: write-var gs#412906 <= s_866_0
        fn_state.gs_412906 = s_866_0;
        // N s_866_2: jump b867
        return block_867(state, tracer, fn_state);
    }
    fn block_867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_867_0: read-var gs#412906:u8
        let s_867_0: bool = fn_state.gs_412906;
        // D s_867_1: write-var gs#412907 <= s_867_0
        fn_state.gs_412907 = s_867_0;
        // N s_867_2: jump b284
        return block_284(state, tracer, fn_state);
    }
    fn block_868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_868_0: const #4s : i
        let s_868_0: i128 = 4;
        // D s_868_1: read-var u#34212:u32
        let s_868_1: u32 = fn_state.u_34212;
        // D s_868_2: cast zx s_868_1 -> bv
        let s_868_2: Bits = Bits::new(s_868_1 as u128, 32u16);
        // C s_868_3: const #1s : i64
        let s_868_3: i64 = 1;
        // C s_868_4: cast zx s_868_3 -> i
        let s_868_4: i128 = (i128::try_from(s_868_3).unwrap());
        // C s_868_5: const #0s : i
        let s_868_5: i128 = 0;
        // C s_868_6: add s_868_5 s_868_4
        let s_868_6: i128 = (s_868_5 + s_868_4);
        // D s_868_7: bit-extract s_868_2 s_868_0 s_868_6
        let s_868_7: Bits = (Bits::new(
            ((s_868_2) >> (s_868_0)).value(),
            u16::try_from(s_868_6).unwrap(),
        ));
        // D s_868_8: cast reint s_868_7 -> u8
        let s_868_8: bool = ((s_868_7.value()) != 0);
        // D s_868_9: cast zx s_868_8 -> bv
        let s_868_9: Bits = Bits::new(s_868_8 as u128, 1u16);
        // C s_868_10: const #1u : u8
        let s_868_10: bool = true;
        // C s_868_11: cast zx s_868_10 -> bv
        let s_868_11: Bits = Bits::new(s_868_10 as u128, 1u16);
        // D s_868_12: cmp-eq s_868_9 s_868_11
        let s_868_12: bool = ((s_868_9) == (s_868_11));
        // D s_868_13: write-var gs#412906 <= s_868_12
        fn_state.gs_412906 = s_868_12;
        // N s_868_14: jump b867
        return block_867(state, tracer, fn_state);
    }
    fn block_869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_869_0: const #28s : i
        let s_869_0: i128 = 28;
        // C s_869_1: const #4s : i
        let s_869_1: i128 = 4;
        // D s_869_2: read-var u#34203:u32
        let s_869_2: u32 = fn_state.u_34203;
        // D s_869_3: cast zx s_869_2 -> bv
        let s_869_3: Bits = Bits::new(s_869_2 as u128, 32u16);
        // D s_869_4: bit-extract s_869_3 s_869_0 s_869_1
        let s_869_4: Bits = (Bits::new(
            ((s_869_3) >> (s_869_0)).value(),
            u16::try_from(s_869_1).unwrap(),
        ));
        // D s_869_5: cast reint s_869_4 -> u8
        let s_869_5: u8 = (s_869_4.value() as u8);
        // D s_869_6: cast zx s_869_5 -> bv
        let s_869_6: Bits = Bits::new(s_869_5 as u128, 4u16);
        // C s_869_7: const #15u : u8
        let s_869_7: u8 = 15;
        // C s_869_8: cast zx s_869_7 -> bv
        let s_869_8: Bits = Bits::new(s_869_7 as u128, 4u16);
        // D s_869_9: cmp-ne s_869_6 s_869_8
        let s_869_9: bool = ((s_869_6) != (s_869_8));
        // N s_869_10: branch s_869_9 b872 b870
        if s_869_9 {
            return block_872(state, tracer, fn_state);
        } else {
            return block_870(state, tracer, fn_state);
        };
    }
    fn block_870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_870_0: const #0u : u8
        let s_870_0: bool = false;
        // D s_870_1: write-var gs#412870 <= s_870_0
        fn_state.gs_412870 = s_870_0;
        // N s_870_2: jump b871
        return block_871(state, tracer, fn_state);
    }
    fn block_871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_871_0: read-var gs#412870:u8
        let s_871_0: bool = fn_state.gs_412870;
        // D s_871_1: write-var gs#412871 <= s_871_0
        fn_state.gs_412871 = s_871_0;
        // N s_871_2: jump b269
        return block_269(state, tracer, fn_state);
    }
    fn block_872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_872_0: const #3548s : i
        let s_872_0: i128 = 3548;
        // C s_872_1: const #14696u : u32
        let s_872_1: u32 = 14696;
        // D s_872_2: read-reg s_872_1:i
        let s_872_2: i128 = {
            let value = state.read_register::<i128>(s_872_1 as isize);
            tracer.read_register(s_872_1 as isize, value);
            value
        };
        // D s_872_3: cmp-lt s_872_2 s_872_0
        let s_872_3: bool = ((s_872_2) < (s_872_0));
        // D s_872_4: write-var gs#412870 <= s_872_3
        fn_state.gs_412870 = s_872_3;
        // N s_872_5: jump b871
        return block_871(state, tracer, fn_state);
    }
    fn block_873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_873_0: const #20s : i
        let s_873_0: i128 = 20;
        // D s_873_1: read-var u#34203:u32
        let s_873_1: u32 = fn_state.u_34203;
        // D s_873_2: cast zx s_873_1 -> bv
        let s_873_2: Bits = Bits::new(s_873_1 as u128, 32u16);
        // C s_873_3: const #1s : i64
        let s_873_3: i64 = 1;
        // C s_873_4: cast zx s_873_3 -> i
        let s_873_4: i128 = (i128::try_from(s_873_3).unwrap());
        // C s_873_5: const #0s : i
        let s_873_5: i128 = 0;
        // C s_873_6: add s_873_5 s_873_4
        let s_873_6: i128 = (s_873_5 + s_873_4);
        // D s_873_7: bit-extract s_873_2 s_873_0 s_873_6
        let s_873_7: Bits = (Bits::new(
            ((s_873_2) >> (s_873_0)).value(),
            u16::try_from(s_873_6).unwrap(),
        ));
        // D s_873_8: cast reint s_873_7 -> u8
        let s_873_8: bool = ((s_873_7.value()) != 0);
        // D s_873_9: cast zx s_873_8 -> bv
        let s_873_9: Bits = Bits::new(s_873_8 as u128, 1u16);
        // C s_873_10: const #1u : u8
        let s_873_10: bool = true;
        // C s_873_11: cast zx s_873_10 -> bv
        let s_873_11: Bits = Bits::new(s_873_10 as u128, 1u16);
        // D s_873_12: cmp-eq s_873_9 s_873_11
        let s_873_12: bool = ((s_873_9) == (s_873_11));
        // N s_873_13: branch s_873_12 b876 b874
        if s_873_12 {
            return block_876(state, tracer, fn_state);
        } else {
            return block_874(state, tracer, fn_state);
        };
    }
    fn block_874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_874_0: const #0u : u8
        let s_874_0: bool = false;
        // D s_874_1: write-var gs#412865 <= s_874_0
        fn_state.gs_412865 = s_874_0;
        // N s_874_2: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_875_0: read-var gs#412865:u8
        let s_875_0: bool = fn_state.gs_412865;
        // D s_875_1: write-var gs#412866 <= s_875_0
        fn_state.gs_412866 = s_875_0;
        // N s_875_2: jump b267
        return block_267(state, tracer, fn_state);
    }
    fn block_876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_876_0: const #8s : i
        let s_876_0: i128 = 8;
        // D s_876_1: read-var u#34203:u32
        let s_876_1: u32 = fn_state.u_34203;
        // D s_876_2: cast zx s_876_1 -> bv
        let s_876_2: Bits = Bits::new(s_876_1 as u128, 32u16);
        // C s_876_3: const #1s : i64
        let s_876_3: i64 = 1;
        // C s_876_4: cast zx s_876_3 -> i
        let s_876_4: i128 = (i128::try_from(s_876_3).unwrap());
        // C s_876_5: const #3s : i
        let s_876_5: i128 = 3;
        // C s_876_6: add s_876_5 s_876_4
        let s_876_6: i128 = (s_876_5 + s_876_4);
        // D s_876_7: bit-extract s_876_2 s_876_0 s_876_6
        let s_876_7: Bits = (Bits::new(
            ((s_876_2) >> (s_876_0)).value(),
            u16::try_from(s_876_6).unwrap(),
        ));
        // D s_876_8: cast reint s_876_7 -> u8
        let s_876_8: u8 = (s_876_7.value() as u8);
        // D s_876_9: cast zx s_876_8 -> bv
        let s_876_9: Bits = Bits::new(s_876_8 as u128, 4u16);
        // C s_876_10: const #11u : u8
        let s_876_10: u8 = 11;
        // C s_876_11: cast zx s_876_10 -> bv
        let s_876_11: Bits = Bits::new(s_876_10 as u128, 4u16);
        // D s_876_12: cmp-eq s_876_9 s_876_11
        let s_876_12: bool = ((s_876_9) == (s_876_11));
        // N s_876_13: branch s_876_12 b879 b877
        if s_876_12 {
            return block_879(state, tracer, fn_state);
        } else {
            return block_877(state, tracer, fn_state);
        };
    }
    fn block_877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_877_0: const #0u : u8
        let s_877_0: bool = false;
        // D s_877_1: write-var gs#412864 <= s_877_0
        fn_state.gs_412864 = s_877_0;
        // N s_877_2: jump b878
        return block_878(state, tracer, fn_state);
    }
    fn block_878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_878_0: read-var gs#412864:u8
        let s_878_0: bool = fn_state.gs_412864;
        // D s_878_1: write-var gs#412865 <= s_878_0
        fn_state.gs_412865 = s_878_0;
        // N s_878_2: jump b875
        return block_875(state, tracer, fn_state);
    }
    fn block_879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_879_0: const #0s : i
        let s_879_0: i128 = 0;
        // D s_879_1: read-var u#34203:u32
        let s_879_1: u32 = fn_state.u_34203;
        // D s_879_2: cast zx s_879_1 -> bv
        let s_879_2: Bits = Bits::new(s_879_1 as u128, 32u16);
        // C s_879_3: const #1s : i64
        let s_879_3: i64 = 1;
        // C s_879_4: cast zx s_879_3 -> i
        let s_879_4: i128 = (i128::try_from(s_879_3).unwrap());
        // C s_879_5: const #4s : i
        let s_879_5: i128 = 4;
        // C s_879_6: add s_879_5 s_879_4
        let s_879_6: i128 = (s_879_5 + s_879_4);
        // D s_879_7: bit-extract s_879_2 s_879_0 s_879_6
        let s_879_7: Bits = (Bits::new(
            ((s_879_2) >> (s_879_0)).value(),
            u16::try_from(s_879_6).unwrap(),
        ));
        // D s_879_8: cast reint s_879_7 -> u8
        let s_879_8: u8 = (s_879_7.value() as u8);
        // D s_879_9: cast zx s_879_8 -> bv
        let s_879_9: Bits = Bits::new(s_879_8 as u128, 5u16);
        // C s_879_10: const #16u : u8
        let s_879_10: u8 = 16;
        // C s_879_11: cast zx s_879_10 -> bv
        let s_879_11: Bits = Bits::new(s_879_10 as u128, 5u16);
        // D s_879_12: cmp-eq s_879_9 s_879_11
        let s_879_12: bool = ((s_879_9) == (s_879_11));
        // D s_879_13: write-var gs#412864 <= s_879_12
        fn_state.gs_412864 = s_879_12;
        // N s_879_14: jump b878
        return block_878(state, tracer, fn_state);
    }
    fn block_880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_880_0: const #28s : i
        let s_880_0: i128 = 28;
        // C s_880_1: const #4s : i
        let s_880_1: i128 = 4;
        // D s_880_2: read-var u#34196:u32
        let s_880_2: u32 = fn_state.u_34196;
        // D s_880_3: cast zx s_880_2 -> bv
        let s_880_3: Bits = Bits::new(s_880_2 as u128, 32u16);
        // D s_880_4: bit-extract s_880_3 s_880_0 s_880_1
        let s_880_4: Bits = (Bits::new(
            ((s_880_3) >> (s_880_0)).value(),
            u16::try_from(s_880_1).unwrap(),
        ));
        // D s_880_5: cast reint s_880_4 -> u8
        let s_880_5: u8 = (s_880_4.value() as u8);
        // D s_880_6: cast zx s_880_5 -> bv
        let s_880_6: Bits = Bits::new(s_880_5 as u128, 4u16);
        // C s_880_7: const #15u : u8
        let s_880_7: u8 = 15;
        // C s_880_8: cast zx s_880_7 -> bv
        let s_880_8: Bits = Bits::new(s_880_7 as u128, 4u16);
        // D s_880_9: cmp-ne s_880_6 s_880_8
        let s_880_9: bool = ((s_880_6) != (s_880_8));
        // N s_880_10: branch s_880_9 b883 b881
        if s_880_9 {
            return block_883(state, tracer, fn_state);
        } else {
            return block_881(state, tracer, fn_state);
        };
    }
    fn block_881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_881_0: const #0u : u8
        let s_881_0: bool = false;
        // D s_881_1: write-var gs#412824 <= s_881_0
        fn_state.gs_412824 = s_881_0;
        // N s_881_2: jump b882
        return block_882(state, tracer, fn_state);
    }
    fn block_882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_882_0: read-var gs#412824:u8
        let s_882_0: bool = fn_state.gs_412824;
        // D s_882_1: write-var gs#412825 <= s_882_0
        fn_state.gs_412825 = s_882_0;
        // N s_882_2: jump b246
        return block_246(state, tracer, fn_state);
    }
    fn block_883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_883_0: const #3546s : i
        let s_883_0: i128 = 3546;
        // C s_883_1: const #14696u : u32
        let s_883_1: u32 = 14696;
        // D s_883_2: read-reg s_883_1:i
        let s_883_2: i128 = {
            let value = state.read_register::<i128>(s_883_1 as isize);
            tracer.read_register(s_883_1 as isize, value);
            value
        };
        // D s_883_3: cmp-lt s_883_2 s_883_0
        let s_883_3: bool = ((s_883_2) < (s_883_0));
        // D s_883_4: write-var gs#412824 <= s_883_3
        fn_state.gs_412824 = s_883_3;
        // N s_883_5: jump b882
        return block_882(state, tracer, fn_state);
    }
    fn block_884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_884_0: const #8s : i
        let s_884_0: i128 = 8;
        // D s_884_1: read-var u#34196:u32
        let s_884_1: u32 = fn_state.u_34196;
        // D s_884_2: cast zx s_884_1 -> bv
        let s_884_2: Bits = Bits::new(s_884_1 as u128, 32u16);
        // C s_884_3: const #1s : i64
        let s_884_3: i64 = 1;
        // C s_884_4: cast zx s_884_3 -> i
        let s_884_4: i128 = (i128::try_from(s_884_3).unwrap());
        // C s_884_5: const #3s : i
        let s_884_5: i128 = 3;
        // C s_884_6: add s_884_5 s_884_4
        let s_884_6: i128 = (s_884_5 + s_884_4);
        // D s_884_7: bit-extract s_884_2 s_884_0 s_884_6
        let s_884_7: Bits = (Bits::new(
            ((s_884_2) >> (s_884_0)).value(),
            u16::try_from(s_884_6).unwrap(),
        ));
        // D s_884_8: cast reint s_884_7 -> u8
        let s_884_8: u8 = (s_884_7.value() as u8);
        // D s_884_9: cast zx s_884_8 -> bv
        let s_884_9: Bits = Bits::new(s_884_8 as u128, 4u16);
        // C s_884_10: const #10u : u8
        let s_884_10: u8 = 10;
        // C s_884_11: cast zx s_884_10 -> bv
        let s_884_11: Bits = Bits::new(s_884_10 as u128, 4u16);
        // D s_884_12: cmp-eq s_884_9 s_884_11
        let s_884_12: bool = ((s_884_9) == (s_884_11));
        // N s_884_13: branch s_884_12 b887 b885
        if s_884_12 {
            return block_887(state, tracer, fn_state);
        } else {
            return block_885(state, tracer, fn_state);
        };
    }
    fn block_885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_885_0: const #0u : u8
        let s_885_0: bool = false;
        // D s_885_1: write-var gs#412819 <= s_885_0
        fn_state.gs_412819 = s_885_0;
        // N s_885_2: jump b886
        return block_886(state, tracer, fn_state);
    }
    fn block_886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_886_0: read-var gs#412819:u8
        let s_886_0: bool = fn_state.gs_412819;
        // D s_886_1: write-var gs#412820 <= s_886_0
        fn_state.gs_412820 = s_886_0;
        // N s_886_2: jump b244
        return block_244(state, tracer, fn_state);
    }
    fn block_887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_887_0: const #0s : i
        let s_887_0: i128 = 0;
        // D s_887_1: read-var u#34196:u32
        let s_887_1: u32 = fn_state.u_34196;
        // D s_887_2: cast zx s_887_1 -> bv
        let s_887_2: Bits = Bits::new(s_887_1 as u128, 32u16);
        // C s_887_3: const #1s : i64
        let s_887_3: i64 = 1;
        // C s_887_4: cast zx s_887_3 -> i
        let s_887_4: i128 = (i128::try_from(s_887_3).unwrap());
        // C s_887_5: const #6s : i
        let s_887_5: i128 = 6;
        // C s_887_6: add s_887_5 s_887_4
        let s_887_6: i128 = (s_887_5 + s_887_4);
        // D s_887_7: bit-extract s_887_2 s_887_0 s_887_6
        let s_887_7: Bits = (Bits::new(
            ((s_887_2) >> (s_887_0)).value(),
            u16::try_from(s_887_6).unwrap(),
        ));
        // D s_887_8: cast reint s_887_7 -> u8
        let s_887_8: u8 = (s_887_7.value() as u8);
        // D s_887_9: cast zx s_887_8 -> bv
        let s_887_9: Bits = Bits::new(s_887_8 as u128, 7u16);
        // C s_887_10: const #16u : u8
        let s_887_10: u8 = 16;
        // C s_887_11: cast zx s_887_10 -> bv
        let s_887_11: Bits = Bits::new(s_887_10 as u128, 7u16);
        // D s_887_12: cmp-eq s_887_9 s_887_11
        let s_887_12: bool = ((s_887_9) == (s_887_11));
        // D s_887_13: write-var gs#412819 <= s_887_12
        fn_state.gs_412819 = s_887_12;
        // N s_887_14: jump b886
        return block_886(state, tracer, fn_state);
    }
    fn block_888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_888_0: const #28s : i
        let s_888_0: i128 = 28;
        // C s_888_1: const #4s : i
        let s_888_1: i128 = 4;
        // D s_888_2: read-var u#34188:u32
        let s_888_2: u32 = fn_state.u_34188;
        // D s_888_3: cast zx s_888_2 -> bv
        let s_888_3: Bits = Bits::new(s_888_2 as u128, 32u16);
        // D s_888_4: bit-extract s_888_3 s_888_0 s_888_1
        let s_888_4: Bits = (Bits::new(
            ((s_888_3) >> (s_888_0)).value(),
            u16::try_from(s_888_1).unwrap(),
        ));
        // D s_888_5: cast reint s_888_4 -> u8
        let s_888_5: u8 = (s_888_4.value() as u8);
        // D s_888_6: cast zx s_888_5 -> bv
        let s_888_6: Bits = Bits::new(s_888_5 as u128, 4u16);
        // C s_888_7: const #15u : u8
        let s_888_7: u8 = 15;
        // C s_888_8: cast zx s_888_7 -> bv
        let s_888_8: Bits = Bits::new(s_888_7 as u128, 4u16);
        // D s_888_9: cmp-ne s_888_6 s_888_8
        let s_888_9: bool = ((s_888_6) != (s_888_8));
        // N s_888_10: branch s_888_9 b891 b889
        if s_888_9 {
            return block_891(state, tracer, fn_state);
        } else {
            return block_889(state, tracer, fn_state);
        };
    }
    fn block_889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_889_0: const #0u : u8
        let s_889_0: bool = false;
        // D s_889_1: write-var gs#412785 <= s_889_0
        fn_state.gs_412785 = s_889_0;
        // N s_889_2: jump b890
        return block_890(state, tracer, fn_state);
    }
    fn block_890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_890_0: read-var gs#412785:u8
        let s_890_0: bool = fn_state.gs_412785;
        // D s_890_1: write-var gs#412786 <= s_890_0
        fn_state.gs_412786 = s_890_0;
        // N s_890_2: jump b229
        return block_229(state, tracer, fn_state);
    }
    fn block_891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_891_0: const #3544s : i
        let s_891_0: i128 = 3544;
        // C s_891_1: const #14696u : u32
        let s_891_1: u32 = 14696;
        // D s_891_2: read-reg s_891_1:i
        let s_891_2: i128 = {
            let value = state.read_register::<i128>(s_891_1 as isize);
            tracer.read_register(s_891_1 as isize, value);
            value
        };
        // D s_891_3: cmp-lt s_891_2 s_891_0
        let s_891_3: bool = ((s_891_2) < (s_891_0));
        // D s_891_4: write-var gs#412785 <= s_891_3
        fn_state.gs_412785 = s_891_3;
        // N s_891_5: jump b890
        return block_890(state, tracer, fn_state);
    }
    fn block_892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_892_0: const #20s : i
        let s_892_0: i128 = 20;
        // D s_892_1: read-var u#34188:u32
        let s_892_1: u32 = fn_state.u_34188;
        // D s_892_2: cast zx s_892_1 -> bv
        let s_892_2: Bits = Bits::new(s_892_1 as u128, 32u16);
        // C s_892_3: const #1s : i64
        let s_892_3: i64 = 1;
        // C s_892_4: cast zx s_892_3 -> i
        let s_892_4: i128 = (i128::try_from(s_892_3).unwrap());
        // C s_892_5: const #0s : i
        let s_892_5: i128 = 0;
        // C s_892_6: add s_892_5 s_892_4
        let s_892_6: i128 = (s_892_5 + s_892_4);
        // D s_892_7: bit-extract s_892_2 s_892_0 s_892_6
        let s_892_7: Bits = (Bits::new(
            ((s_892_2) >> (s_892_0)).value(),
            u16::try_from(s_892_6).unwrap(),
        ));
        // D s_892_8: cast reint s_892_7 -> u8
        let s_892_8: bool = ((s_892_7.value()) != 0);
        // D s_892_9: cast zx s_892_8 -> bv
        let s_892_9: Bits = Bits::new(s_892_8 as u128, 1u16);
        // C s_892_10: const #0u : u8
        let s_892_10: bool = false;
        // C s_892_11: cast zx s_892_10 -> bv
        let s_892_11: Bits = Bits::new(s_892_10 as u128, 1u16);
        // D s_892_12: cmp-eq s_892_9 s_892_11
        let s_892_12: bool = ((s_892_9) == (s_892_11));
        // N s_892_13: branch s_892_12 b895 b893
        if s_892_12 {
            return block_895(state, tracer, fn_state);
        } else {
            return block_893(state, tracer, fn_state);
        };
    }
    fn block_893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_893_0: const #0u : u8
        let s_893_0: bool = false;
        // D s_893_1: write-var gs#412780 <= s_893_0
        fn_state.gs_412780 = s_893_0;
        // N s_893_2: jump b894
        return block_894(state, tracer, fn_state);
    }
    fn block_894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_894_0: read-var gs#412780:u8
        let s_894_0: bool = fn_state.gs_412780;
        // D s_894_1: write-var gs#412781 <= s_894_0
        fn_state.gs_412781 = s_894_0;
        // N s_894_2: jump b227
        return block_227(state, tracer, fn_state);
    }
    fn block_895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_895_0: const #8s : i
        let s_895_0: i128 = 8;
        // D s_895_1: read-var u#34188:u32
        let s_895_1: u32 = fn_state.u_34188;
        // D s_895_2: cast zx s_895_1 -> bv
        let s_895_2: Bits = Bits::new(s_895_1 as u128, 32u16);
        // C s_895_3: const #1s : i64
        let s_895_3: i64 = 1;
        // C s_895_4: cast zx s_895_3 -> i
        let s_895_4: i128 = (i128::try_from(s_895_3).unwrap());
        // C s_895_5: const #3s : i
        let s_895_5: i128 = 3;
        // C s_895_6: add s_895_5 s_895_4
        let s_895_6: i128 = (s_895_5 + s_895_4);
        // D s_895_7: bit-extract s_895_2 s_895_0 s_895_6
        let s_895_7: Bits = (Bits::new(
            ((s_895_2) >> (s_895_0)).value(),
            u16::try_from(s_895_6).unwrap(),
        ));
        // D s_895_8: cast reint s_895_7 -> u8
        let s_895_8: u8 = (s_895_7.value() as u8);
        // D s_895_9: cast zx s_895_8 -> bv
        let s_895_9: Bits = Bits::new(s_895_8 as u128, 4u16);
        // C s_895_10: const #11u : u8
        let s_895_10: u8 = 11;
        // C s_895_11: cast zx s_895_10 -> bv
        let s_895_11: Bits = Bits::new(s_895_10 as u128, 4u16);
        // D s_895_12: cmp-eq s_895_9 s_895_11
        let s_895_12: bool = ((s_895_9) == (s_895_11));
        // N s_895_13: branch s_895_12 b898 b896
        if s_895_12 {
            return block_898(state, tracer, fn_state);
        } else {
            return block_896(state, tracer, fn_state);
        };
    }
    fn block_896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_896_0: const #0u : u8
        let s_896_0: bool = false;
        // D s_896_1: write-var gs#412779 <= s_896_0
        fn_state.gs_412779 = s_896_0;
        // N s_896_2: jump b897
        return block_897(state, tracer, fn_state);
    }
    fn block_897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_897_0: read-var gs#412779:u8
        let s_897_0: bool = fn_state.gs_412779;
        // D s_897_1: write-var gs#412780 <= s_897_0
        fn_state.gs_412780 = s_897_0;
        // N s_897_2: jump b894
        return block_894(state, tracer, fn_state);
    }
    fn block_898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_898_0: const #0s : i
        let s_898_0: i128 = 0;
        // D s_898_1: read-var u#34188:u32
        let s_898_1: u32 = fn_state.u_34188;
        // D s_898_2: cast zx s_898_1 -> bv
        let s_898_2: Bits = Bits::new(s_898_1 as u128, 32u16);
        // C s_898_3: const #1s : i64
        let s_898_3: i64 = 1;
        // C s_898_4: cast zx s_898_3 -> i
        let s_898_4: i128 = (i128::try_from(s_898_3).unwrap());
        // C s_898_5: const #4s : i
        let s_898_5: i128 = 4;
        // C s_898_6: add s_898_5 s_898_4
        let s_898_6: i128 = (s_898_5 + s_898_4);
        // D s_898_7: bit-extract s_898_2 s_898_0 s_898_6
        let s_898_7: Bits = (Bits::new(
            ((s_898_2) >> (s_898_0)).value(),
            u16::try_from(s_898_6).unwrap(),
        ));
        // D s_898_8: cast reint s_898_7 -> u8
        let s_898_8: u8 = (s_898_7.value() as u8);
        // D s_898_9: cast zx s_898_8 -> bv
        let s_898_9: Bits = Bits::new(s_898_8 as u128, 5u16);
        // C s_898_10: const #16u : u8
        let s_898_10: u8 = 16;
        // C s_898_11: cast zx s_898_10 -> bv
        let s_898_11: Bits = Bits::new(s_898_10 as u128, 5u16);
        // D s_898_12: cmp-eq s_898_9 s_898_11
        let s_898_12: bool = ((s_898_9) == (s_898_11));
        // D s_898_13: write-var gs#412779 <= s_898_12
        fn_state.gs_412779 = s_898_12;
        // N s_898_14: jump b897
        return block_897(state, tracer, fn_state);
    }
    fn block_899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_899_0: const #28s : i
        let s_899_0: i128 = 28;
        // C s_899_1: const #4s : i
        let s_899_1: i128 = 4;
        // D s_899_2: read-var u#34180:u32
        let s_899_2: u32 = fn_state.u_34180;
        // D s_899_3: cast zx s_899_2 -> bv
        let s_899_3: Bits = Bits::new(s_899_2 as u128, 32u16);
        // D s_899_4: bit-extract s_899_3 s_899_0 s_899_1
        let s_899_4: Bits = (Bits::new(
            ((s_899_3) >> (s_899_0)).value(),
            u16::try_from(s_899_1).unwrap(),
        ));
        // D s_899_5: cast reint s_899_4 -> u8
        let s_899_5: u8 = (s_899_4.value() as u8);
        // D s_899_6: cast zx s_899_5 -> bv
        let s_899_6: Bits = Bits::new(s_899_5 as u128, 4u16);
        // C s_899_7: const #15u : u8
        let s_899_7: u8 = 15;
        // C s_899_8: cast zx s_899_7 -> bv
        let s_899_8: Bits = Bits::new(s_899_7 as u128, 4u16);
        // D s_899_9: cmp-ne s_899_6 s_899_8
        let s_899_9: bool = ((s_899_6) != (s_899_8));
        // N s_899_10: branch s_899_9 b902 b900
        if s_899_9 {
            return block_902(state, tracer, fn_state);
        } else {
            return block_900(state, tracer, fn_state);
        };
    }
    fn block_900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_900_0: const #0u : u8
        let s_900_0: bool = false;
        // D s_900_1: write-var gs#412754 <= s_900_0
        fn_state.gs_412754 = s_900_0;
        // N s_900_2: jump b901
        return block_901(state, tracer, fn_state);
    }
    fn block_901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_901_0: read-var gs#412754:u8
        let s_901_0: bool = fn_state.gs_412754;
        // D s_901_1: write-var gs#412755 <= s_901_0
        fn_state.gs_412755 = s_901_0;
        // N s_901_2: jump b223
        return block_223(state, tracer, fn_state);
    }
    fn block_902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_902_0: const #3542s : i
        let s_902_0: i128 = 3542;
        // C s_902_1: const #14696u : u32
        let s_902_1: u32 = 14696;
        // D s_902_2: read-reg s_902_1:i
        let s_902_2: i128 = {
            let value = state.read_register::<i128>(s_902_1 as isize);
            tracer.read_register(s_902_1 as isize, value);
            value
        };
        // D s_902_3: cmp-lt s_902_2 s_902_0
        let s_902_3: bool = ((s_902_2) < (s_902_0));
        // D s_902_4: write-var gs#412754 <= s_902_3
        fn_state.gs_412754 = s_902_3;
        // N s_902_5: jump b901
        return block_901(state, tracer, fn_state);
    }
    fn block_903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_903_0: const #16s : i
        let s_903_0: i128 = 16;
        // D s_903_1: read-var u#34180:u32
        let s_903_1: u32 = fn_state.u_34180;
        // D s_903_2: cast zx s_903_1 -> bv
        let s_903_2: Bits = Bits::new(s_903_1 as u128, 32u16);
        // C s_903_3: const #1s : i64
        let s_903_3: i64 = 1;
        // C s_903_4: cast zx s_903_3 -> i
        let s_903_4: i128 = (i128::try_from(s_903_3).unwrap());
        // C s_903_5: const #5s : i
        let s_903_5: i128 = 5;
        // C s_903_6: add s_903_5 s_903_4
        let s_903_6: i128 = (s_903_5 + s_903_4);
        // D s_903_7: bit-extract s_903_2 s_903_0 s_903_6
        let s_903_7: Bits = (Bits::new(
            ((s_903_2) >> (s_903_0)).value(),
            u16::try_from(s_903_6).unwrap(),
        ));
        // D s_903_8: cast reint s_903_7 -> u8
        let s_903_8: u8 = (s_903_7.value() as u8);
        // D s_903_9: cast zx s_903_8 -> bv
        let s_903_9: Bits = Bits::new(s_903_8 as u128, 6u16);
        // C s_903_10: const #48u : u8
        let s_903_10: u8 = 48;
        // C s_903_11: cast zx s_903_10 -> bv
        let s_903_11: Bits = Bits::new(s_903_10 as u128, 6u16);
        // D s_903_12: cmp-eq s_903_9 s_903_11
        let s_903_12: bool = ((s_903_9) == (s_903_11));
        // N s_903_13: branch s_903_12 b906 b904
        if s_903_12 {
            return block_906(state, tracer, fn_state);
        } else {
            return block_904(state, tracer, fn_state);
        };
    }
    fn block_904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_904_0: const #0u : u8
        let s_904_0: bool = false;
        // D s_904_1: write-var gs#412749 <= s_904_0
        fn_state.gs_412749 = s_904_0;
        // N s_904_2: jump b905
        return block_905(state, tracer, fn_state);
    }
    fn block_905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_905_0: read-var gs#412749:u8
        let s_905_0: bool = fn_state.gs_412749;
        // D s_905_1: write-var gs#412750 <= s_905_0
        fn_state.gs_412750 = s_905_0;
        // N s_905_2: jump b221
        return block_221(state, tracer, fn_state);
    }
    fn block_906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_906_0: const #10s : i
        let s_906_0: i128 = 10;
        // D s_906_1: read-var u#34180:u32
        let s_906_1: u32 = fn_state.u_34180;
        // D s_906_2: cast zx s_906_1 -> bv
        let s_906_2: Bits = Bits::new(s_906_1 as u128, 32u16);
        // C s_906_3: const #1s : i64
        let s_906_3: i64 = 1;
        // C s_906_4: cast zx s_906_3 -> i
        let s_906_4: i128 = (i128::try_from(s_906_3).unwrap());
        // C s_906_5: const #1s : i
        let s_906_5: i128 = 1;
        // C s_906_6: add s_906_5 s_906_4
        let s_906_6: i128 = (s_906_5 + s_906_4);
        // D s_906_7: bit-extract s_906_2 s_906_0 s_906_6
        let s_906_7: Bits = (Bits::new(
            ((s_906_2) >> (s_906_0)).value(),
            u16::try_from(s_906_6).unwrap(),
        ));
        // D s_906_8: cast reint s_906_7 -> u8
        let s_906_8: u8 = (s_906_7.value() as u8);
        // D s_906_9: cast zx s_906_8 -> bv
        let s_906_9: Bits = Bits::new(s_906_8 as u128, 2u16);
        // C s_906_10: const #2u : u8
        let s_906_10: u8 = 2;
        // C s_906_11: cast zx s_906_10 -> bv
        let s_906_11: Bits = Bits::new(s_906_10 as u128, 2u16);
        // D s_906_12: cmp-eq s_906_9 s_906_11
        let s_906_12: bool = ((s_906_9) == (s_906_11));
        // N s_906_13: branch s_906_12 b909 b907
        if s_906_12 {
            return block_909(state, tracer, fn_state);
        } else {
            return block_907(state, tracer, fn_state);
        };
    }
    fn block_907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_907_0: const #0u : u8
        let s_907_0: bool = false;
        // D s_907_1: write-var gs#412748 <= s_907_0
        fn_state.gs_412748 = s_907_0;
        // N s_907_2: jump b908
        return block_908(state, tracer, fn_state);
    }
    fn block_908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_908_0: read-var gs#412748:u8
        let s_908_0: bool = fn_state.gs_412748;
        // D s_908_1: write-var gs#412749 <= s_908_0
        fn_state.gs_412749 = s_908_0;
        // N s_908_2: jump b905
        return block_905(state, tracer, fn_state);
    }
    fn block_909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_909_0: const #6s : i
        let s_909_0: i128 = 6;
        // D s_909_1: read-var u#34180:u32
        let s_909_1: u32 = fn_state.u_34180;
        // D s_909_2: cast zx s_909_1 -> bv
        let s_909_2: Bits = Bits::new(s_909_1 as u128, 32u16);
        // C s_909_3: const #1s : i64
        let s_909_3: i64 = 1;
        // C s_909_4: cast zx s_909_3 -> i
        let s_909_4: i128 = (i128::try_from(s_909_3).unwrap());
        // C s_909_5: const #1s : i
        let s_909_5: i128 = 1;
        // C s_909_6: add s_909_5 s_909_4
        let s_909_6: i128 = (s_909_5 + s_909_4);
        // D s_909_7: bit-extract s_909_2 s_909_0 s_909_6
        let s_909_7: Bits = (Bits::new(
            ((s_909_2) >> (s_909_0)).value(),
            u16::try_from(s_909_6).unwrap(),
        ));
        // D s_909_8: cast reint s_909_7 -> u8
        let s_909_8: u8 = (s_909_7.value() as u8);
        // D s_909_9: cast zx s_909_8 -> bv
        let s_909_9: Bits = Bits::new(s_909_8 as u128, 2u16);
        // C s_909_10: const #1u : u8
        let s_909_10: u8 = 1;
        // C s_909_11: cast zx s_909_10 -> bv
        let s_909_11: Bits = Bits::new(s_909_10 as u128, 2u16);
        // D s_909_12: cmp-eq s_909_9 s_909_11
        let s_909_12: bool = ((s_909_9) == (s_909_11));
        // N s_909_13: branch s_909_12 b912 b910
        if s_909_12 {
            return block_912(state, tracer, fn_state);
        } else {
            return block_910(state, tracer, fn_state);
        };
    }
    fn block_910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_910_0: const #0u : u8
        let s_910_0: bool = false;
        // D s_910_1: write-var gs#412747 <= s_910_0
        fn_state.gs_412747 = s_910_0;
        // N s_910_2: jump b911
        return block_911(state, tracer, fn_state);
    }
    fn block_911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_911_0: read-var gs#412747:u8
        let s_911_0: bool = fn_state.gs_412747;
        // D s_911_1: write-var gs#412748 <= s_911_0
        fn_state.gs_412748 = s_911_0;
        // N s_911_2: jump b908
        return block_908(state, tracer, fn_state);
    }
    fn block_912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_912_0: const #4s : i
        let s_912_0: i128 = 4;
        // D s_912_1: read-var u#34180:u32
        let s_912_1: u32 = fn_state.u_34180;
        // D s_912_2: cast zx s_912_1 -> bv
        let s_912_2: Bits = Bits::new(s_912_1 as u128, 32u16);
        // C s_912_3: const #1s : i64
        let s_912_3: i64 = 1;
        // C s_912_4: cast zx s_912_3 -> i
        let s_912_4: i128 = (i128::try_from(s_912_3).unwrap());
        // C s_912_5: const #0s : i
        let s_912_5: i128 = 0;
        // C s_912_6: add s_912_5 s_912_4
        let s_912_6: i128 = (s_912_5 + s_912_4);
        // D s_912_7: bit-extract s_912_2 s_912_0 s_912_6
        let s_912_7: Bits = (Bits::new(
            ((s_912_2) >> (s_912_0)).value(),
            u16::try_from(s_912_6).unwrap(),
        ));
        // D s_912_8: cast reint s_912_7 -> u8
        let s_912_8: bool = ((s_912_7.value()) != 0);
        // D s_912_9: cast zx s_912_8 -> bv
        let s_912_9: Bits = Bits::new(s_912_8 as u128, 1u16);
        // C s_912_10: const #0u : u8
        let s_912_10: bool = false;
        // C s_912_11: cast zx s_912_10 -> bv
        let s_912_11: Bits = Bits::new(s_912_10 as u128, 1u16);
        // D s_912_12: cmp-eq s_912_9 s_912_11
        let s_912_12: bool = ((s_912_9) == (s_912_11));
        // D s_912_13: write-var gs#412747 <= s_912_12
        fn_state.gs_412747 = s_912_12;
        // N s_912_14: jump b911
        return block_911(state, tracer, fn_state);
    }
    fn block_913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_913_0: const #28s : i
        let s_913_0: i128 = 28;
        // C s_913_1: const #4s : i
        let s_913_1: i128 = 4;
        // D s_913_2: read-var u#34173:u32
        let s_913_2: u32 = fn_state.u_34173;
        // D s_913_3: cast zx s_913_2 -> bv
        let s_913_3: Bits = Bits::new(s_913_2 as u128, 32u16);
        // D s_913_4: bit-extract s_913_3 s_913_0 s_913_1
        let s_913_4: Bits = (Bits::new(
            ((s_913_3) >> (s_913_0)).value(),
            u16::try_from(s_913_1).unwrap(),
        ));
        // D s_913_5: cast reint s_913_4 -> u8
        let s_913_5: u8 = (s_913_4.value() as u8);
        // D s_913_6: cast zx s_913_5 -> bv
        let s_913_6: Bits = Bits::new(s_913_5 as u128, 4u16);
        // C s_913_7: const #15u : u8
        let s_913_7: u8 = 15;
        // C s_913_8: cast zx s_913_7 -> bv
        let s_913_8: Bits = Bits::new(s_913_7 as u128, 4u16);
        // D s_913_9: cmp-ne s_913_6 s_913_8
        let s_913_9: bool = ((s_913_6) != (s_913_8));
        // N s_913_10: branch s_913_9 b916 b914
        if s_913_9 {
            return block_916(state, tracer, fn_state);
        } else {
            return block_914(state, tracer, fn_state);
        };
    }
    fn block_914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_914_0: const #0u : u8
        let s_914_0: bool = false;
        // D s_914_1: write-var gs#412705 <= s_914_0
        fn_state.gs_412705 = s_914_0;
        // N s_914_2: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_915_0: read-var gs#412705:u8
        let s_915_0: bool = fn_state.gs_412705;
        // D s_915_1: write-var gs#412706 <= s_915_0
        fn_state.gs_412706 = s_915_0;
        // N s_915_2: jump b200
        return block_200(state, tracer, fn_state);
    }
    fn block_916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_916_0: const #3540s : i
        let s_916_0: i128 = 3540;
        // C s_916_1: const #14696u : u32
        let s_916_1: u32 = 14696;
        // D s_916_2: read-reg s_916_1:i
        let s_916_2: i128 = {
            let value = state.read_register::<i128>(s_916_1 as isize);
            tracer.read_register(s_916_1 as isize, value);
            value
        };
        // D s_916_3: cmp-lt s_916_2 s_916_0
        let s_916_3: bool = ((s_916_2) < (s_916_0));
        // D s_916_4: write-var gs#412705 <= s_916_3
        fn_state.gs_412705 = s_916_3;
        // N s_916_5: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_917_0: const #8s : i
        let s_917_0: i128 = 8;
        // D s_917_1: read-var u#34173:u32
        let s_917_1: u32 = fn_state.u_34173;
        // D s_917_2: cast zx s_917_1 -> bv
        let s_917_2: Bits = Bits::new(s_917_1 as u128, 32u16);
        // C s_917_3: const #1s : i64
        let s_917_3: i64 = 1;
        // C s_917_4: cast zx s_917_3 -> i
        let s_917_4: i128 = (i128::try_from(s_917_3).unwrap());
        // C s_917_5: const #3s : i
        let s_917_5: i128 = 3;
        // C s_917_6: add s_917_5 s_917_4
        let s_917_6: i128 = (s_917_5 + s_917_4);
        // D s_917_7: bit-extract s_917_2 s_917_0 s_917_6
        let s_917_7: Bits = (Bits::new(
            ((s_917_2) >> (s_917_0)).value(),
            u16::try_from(s_917_6).unwrap(),
        ));
        // D s_917_8: cast reint s_917_7 -> u8
        let s_917_8: u8 = (s_917_7.value() as u8);
        // D s_917_9: cast zx s_917_8 -> bv
        let s_917_9: Bits = Bits::new(s_917_8 as u128, 4u16);
        // C s_917_10: const #9u : u8
        let s_917_10: u8 = 9;
        // C s_917_11: cast zx s_917_10 -> bv
        let s_917_11: Bits = Bits::new(s_917_10 as u128, 4u16);
        // D s_917_12: cmp-eq s_917_9 s_917_11
        let s_917_12: bool = ((s_917_9) == (s_917_11));
        // N s_917_13: branch s_917_12 b920 b918
        if s_917_12 {
            return block_920(state, tracer, fn_state);
        } else {
            return block_918(state, tracer, fn_state);
        };
    }
    fn block_918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_918_0: const #0u : u8
        let s_918_0: bool = false;
        // D s_918_1: write-var gs#412700 <= s_918_0
        fn_state.gs_412700 = s_918_0;
        // N s_918_2: jump b919
        return block_919(state, tracer, fn_state);
    }
    fn block_919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_919_0: read-var gs#412700:u8
        let s_919_0: bool = fn_state.gs_412700;
        // D s_919_1: write-var gs#412701 <= s_919_0
        fn_state.gs_412701 = s_919_0;
        // N s_919_2: jump b198
        return block_198(state, tracer, fn_state);
    }
    fn block_920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_920_0: const #0s : i
        let s_920_0: i128 = 0;
        // D s_920_1: read-var u#34173:u32
        let s_920_1: u32 = fn_state.u_34173;
        // D s_920_2: cast zx s_920_1 -> bv
        let s_920_2: Bits = Bits::new(s_920_1 as u128, 32u16);
        // C s_920_3: const #1s : i64
        let s_920_3: i64 = 1;
        // C s_920_4: cast zx s_920_3 -> i
        let s_920_4: i128 = (i128::try_from(s_920_3).unwrap());
        // C s_920_5: const #6s : i
        let s_920_5: i128 = 6;
        // C s_920_6: add s_920_5 s_920_4
        let s_920_6: i128 = (s_920_5 + s_920_4);
        // D s_920_7: bit-extract s_920_2 s_920_0 s_920_6
        let s_920_7: Bits = (Bits::new(
            ((s_920_2) >> (s_920_0)).value(),
            u16::try_from(s_920_6).unwrap(),
        ));
        // D s_920_8: cast reint s_920_7 -> u8
        let s_920_8: u8 = (s_920_7.value() as u8);
        // D s_920_9: cast zx s_920_8 -> bv
        let s_920_9: Bits = Bits::new(s_920_8 as u128, 7u16);
        // C s_920_10: const #16u : u8
        let s_920_10: u8 = 16;
        // C s_920_11: cast zx s_920_10 -> bv
        let s_920_11: Bits = Bits::new(s_920_10 as u128, 7u16);
        // D s_920_12: cmp-eq s_920_9 s_920_11
        let s_920_12: bool = ((s_920_9) == (s_920_11));
        // D s_920_13: write-var gs#412700 <= s_920_12
        fn_state.gs_412700 = s_920_12;
        // N s_920_14: jump b919
        return block_919(state, tracer, fn_state);
    }
    fn block_921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_921_0: const #28s : i
        let s_921_0: i128 = 28;
        // C s_921_1: const #4s : i
        let s_921_1: i128 = 4;
        // D s_921_2: read-var u#34167:u32
        let s_921_2: u32 = fn_state.u_34167;
        // D s_921_3: cast zx s_921_2 -> bv
        let s_921_3: Bits = Bits::new(s_921_2 as u128, 32u16);
        // D s_921_4: bit-extract s_921_3 s_921_0 s_921_1
        let s_921_4: Bits = (Bits::new(
            ((s_921_3) >> (s_921_0)).value(),
            u16::try_from(s_921_1).unwrap(),
        ));
        // D s_921_5: cast reint s_921_4 -> u8
        let s_921_5: u8 = (s_921_4.value() as u8);
        // D s_921_6: cast zx s_921_5 -> bv
        let s_921_6: Bits = Bits::new(s_921_5 as u128, 4u16);
        // C s_921_7: const #15u : u8
        let s_921_7: u8 = 15;
        // C s_921_8: cast zx s_921_7 -> bv
        let s_921_8: Bits = Bits::new(s_921_7 as u128, 4u16);
        // D s_921_9: cmp-ne s_921_6 s_921_8
        let s_921_9: bool = ((s_921_6) != (s_921_8));
        // N s_921_10: branch s_921_9 b924 b922
        if s_921_9 {
            return block_924(state, tracer, fn_state);
        } else {
            return block_922(state, tracer, fn_state);
        };
    }
    fn block_922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_922_0: const #0u : u8
        let s_922_0: bool = false;
        // D s_922_1: write-var gs#412672 <= s_922_0
        fn_state.gs_412672 = s_922_0;
        // N s_922_2: jump b923
        return block_923(state, tracer, fn_state);
    }
    fn block_923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_923_0: read-var gs#412672:u8
        let s_923_0: bool = fn_state.gs_412672;
        // D s_923_1: write-var gs#412673 <= s_923_0
        fn_state.gs_412673 = s_923_0;
        // N s_923_2: jump b189
        return block_189(state, tracer, fn_state);
    }
    fn block_924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_924_0: const #3527s : i
        let s_924_0: i128 = 3527;
        // C s_924_1: const #14696u : u32
        let s_924_1: u32 = 14696;
        // D s_924_2: read-reg s_924_1:i
        let s_924_2: i128 = {
            let value = state.read_register::<i128>(s_924_1 as isize);
            tracer.read_register(s_924_1 as isize, value);
            value
        };
        // D s_924_3: cmp-lt s_924_2 s_924_0
        let s_924_3: bool = ((s_924_2) < (s_924_0));
        // D s_924_4: write-var gs#412672 <= s_924_3
        fn_state.gs_412672 = s_924_3;
        // N s_924_5: jump b923
        return block_923(state, tracer, fn_state);
    }
    fn block_925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_925_0: const #20s : i
        let s_925_0: i128 = 20;
        // D s_925_1: read-var u#34167:u32
        let s_925_1: u32 = fn_state.u_34167;
        // D s_925_2: cast zx s_925_1 -> bv
        let s_925_2: Bits = Bits::new(s_925_1 as u128, 32u16);
        // C s_925_3: const #1s : i64
        let s_925_3: i64 = 1;
        // C s_925_4: cast zx s_925_3 -> i
        let s_925_4: i128 = (i128::try_from(s_925_3).unwrap());
        // C s_925_5: const #1s : i
        let s_925_5: i128 = 1;
        // C s_925_6: add s_925_5 s_925_4
        let s_925_6: i128 = (s_925_5 + s_925_4);
        // D s_925_7: bit-extract s_925_2 s_925_0 s_925_6
        let s_925_7: Bits = (Bits::new(
            ((s_925_2) >> (s_925_0)).value(),
            u16::try_from(s_925_6).unwrap(),
        ));
        // D s_925_8: cast reint s_925_7 -> u8
        let s_925_8: u8 = (s_925_7.value() as u8);
        // D s_925_9: cast zx s_925_8 -> bv
        let s_925_9: Bits = Bits::new(s_925_8 as u128, 2u16);
        // C s_925_10: const #3u : u8
        let s_925_10: u8 = 3;
        // C s_925_11: cast zx s_925_10 -> bv
        let s_925_11: Bits = Bits::new(s_925_10 as u128, 2u16);
        // D s_925_12: cmp-eq s_925_9 s_925_11
        let s_925_12: bool = ((s_925_9) == (s_925_11));
        // N s_925_13: branch s_925_12 b928 b926
        if s_925_12 {
            return block_928(state, tracer, fn_state);
        } else {
            return block_926(state, tracer, fn_state);
        };
    }
    fn block_926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_926_0: const #0u : u8
        let s_926_0: bool = false;
        // D s_926_1: write-var gs#412667 <= s_926_0
        fn_state.gs_412667 = s_926_0;
        // N s_926_2: jump b927
        return block_927(state, tracer, fn_state);
    }
    fn block_927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_927_0: read-var gs#412667:u8
        let s_927_0: bool = fn_state.gs_412667;
        // D s_927_1: write-var gs#412668 <= s_927_0
        fn_state.gs_412668 = s_927_0;
        // N s_927_2: jump b187
        return block_187(state, tracer, fn_state);
    }
    fn block_928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_928_0: const #10s : i
        let s_928_0: i128 = 10;
        // D s_928_1: read-var u#34167:u32
        let s_928_1: u32 = fn_state.u_34167;
        // D s_928_2: cast zx s_928_1 -> bv
        let s_928_2: Bits = Bits::new(s_928_1 as u128, 32u16);
        // C s_928_3: const #1s : i64
        let s_928_3: i64 = 1;
        // C s_928_4: cast zx s_928_3 -> i
        let s_928_4: i128 = (i128::try_from(s_928_3).unwrap());
        // C s_928_5: const #1s : i
        let s_928_5: i128 = 1;
        // C s_928_6: add s_928_5 s_928_4
        let s_928_6: i128 = (s_928_5 + s_928_4);
        // D s_928_7: bit-extract s_928_2 s_928_0 s_928_6
        let s_928_7: Bits = (Bits::new(
            ((s_928_2) >> (s_928_0)).value(),
            u16::try_from(s_928_6).unwrap(),
        ));
        // D s_928_8: cast reint s_928_7 -> u8
        let s_928_8: u8 = (s_928_7.value() as u8);
        // D s_928_9: cast zx s_928_8 -> bv
        let s_928_9: Bits = Bits::new(s_928_8 as u128, 2u16);
        // C s_928_10: const #2u : u8
        let s_928_10: u8 = 2;
        // C s_928_11: cast zx s_928_10 -> bv
        let s_928_11: Bits = Bits::new(s_928_10 as u128, 2u16);
        // D s_928_12: cmp-eq s_928_9 s_928_11
        let s_928_12: bool = ((s_928_9) == (s_928_11));
        // N s_928_13: branch s_928_12 b931 b929
        if s_928_12 {
            return block_931(state, tracer, fn_state);
        } else {
            return block_929(state, tracer, fn_state);
        };
    }
    fn block_929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_929_0: const #0u : u8
        let s_929_0: bool = false;
        // D s_929_1: write-var gs#412666 <= s_929_0
        fn_state.gs_412666 = s_929_0;
        // N s_929_2: jump b930
        return block_930(state, tracer, fn_state);
    }
    fn block_930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_930_0: read-var gs#412666:u8
        let s_930_0: bool = fn_state.gs_412666;
        // D s_930_1: write-var gs#412667 <= s_930_0
        fn_state.gs_412667 = s_930_0;
        // N s_930_2: jump b927
        return block_927(state, tracer, fn_state);
    }
    fn block_931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_931_0: const #4s : i
        let s_931_0: i128 = 4;
        // D s_931_1: read-var u#34167:u32
        let s_931_1: u32 = fn_state.u_34167;
        // D s_931_2: cast zx s_931_1 -> bv
        let s_931_2: Bits = Bits::new(s_931_1 as u128, 32u16);
        // C s_931_3: const #1s : i64
        let s_931_3: i64 = 1;
        // C s_931_4: cast zx s_931_3 -> i
        let s_931_4: i128 = (i128::try_from(s_931_3).unwrap());
        // C s_931_5: const #3s : i
        let s_931_5: i128 = 3;
        // C s_931_6: add s_931_5 s_931_4
        let s_931_6: i128 = (s_931_5 + s_931_4);
        // D s_931_7: bit-extract s_931_2 s_931_0 s_931_6
        let s_931_7: Bits = (Bits::new(
            ((s_931_2) >> (s_931_0)).value(),
            u16::try_from(s_931_6).unwrap(),
        ));
        // D s_931_8: cast reint s_931_7 -> u8
        let s_931_8: u8 = (s_931_7.value() as u8);
        // D s_931_9: cast zx s_931_8 -> bv
        let s_931_9: Bits = Bits::new(s_931_8 as u128, 4u16);
        // C s_931_10: const #0u : u8
        let s_931_10: u8 = 0;
        // C s_931_11: cast zx s_931_10 -> bv
        let s_931_11: Bits = Bits::new(s_931_10 as u128, 4u16);
        // D s_931_12: cmp-eq s_931_9 s_931_11
        let s_931_12: bool = ((s_931_9) == (s_931_11));
        // D s_931_13: write-var gs#412666 <= s_931_12
        fn_state.gs_412666 = s_931_12;
        // N s_931_14: jump b930
        return block_930(state, tracer, fn_state);
    }
    fn block_932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_932_0: const #28s : i
        let s_932_0: i128 = 28;
        // C s_932_1: const #4s : i
        let s_932_1: i128 = 4;
        // D s_932_2: read-var u#34159:u32
        let s_932_2: u32 = fn_state.u_34159;
        // D s_932_3: cast zx s_932_2 -> bv
        let s_932_3: Bits = Bits::new(s_932_2 as u128, 32u16);
        // D s_932_4: bit-extract s_932_3 s_932_0 s_932_1
        let s_932_4: Bits = (Bits::new(
            ((s_932_3) >> (s_932_0)).value(),
            u16::try_from(s_932_1).unwrap(),
        ));
        // D s_932_5: cast reint s_932_4 -> u8
        let s_932_5: u8 = (s_932_4.value() as u8);
        // D s_932_6: cast zx s_932_5 -> bv
        let s_932_6: Bits = Bits::new(s_932_5 as u128, 4u16);
        // C s_932_7: const #15u : u8
        let s_932_7: u8 = 15;
        // C s_932_8: cast zx s_932_7 -> bv
        let s_932_8: Bits = Bits::new(s_932_7 as u128, 4u16);
        // D s_932_9: cmp-ne s_932_6 s_932_8
        let s_932_9: bool = ((s_932_6) != (s_932_8));
        // N s_932_10: branch s_932_9 b935 b933
        if s_932_9 {
            return block_935(state, tracer, fn_state);
        } else {
            return block_933(state, tracer, fn_state);
        };
    }
    fn block_933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_933_0: const #0u : u8
        let s_933_0: bool = false;
        // D s_933_1: write-var gs#412641 <= s_933_0
        fn_state.gs_412641 = s_933_0;
        // N s_933_2: jump b934
        return block_934(state, tracer, fn_state);
    }
    fn block_934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_934_0: read-var gs#412641:u8
        let s_934_0: bool = fn_state.gs_412641;
        // D s_934_1: write-var gs#412642 <= s_934_0
        fn_state.gs_412642 = s_934_0;
        // N s_934_2: jump b183
        return block_183(state, tracer, fn_state);
    }
    fn block_935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_935_0: const #3524s : i
        let s_935_0: i128 = 3524;
        // C s_935_1: const #14696u : u32
        let s_935_1: u32 = 14696;
        // D s_935_2: read-reg s_935_1:i
        let s_935_2: i128 = {
            let value = state.read_register::<i128>(s_935_1 as isize);
            tracer.read_register(s_935_1 as isize, value);
            value
        };
        // D s_935_3: cmp-lt s_935_2 s_935_0
        let s_935_3: bool = ((s_935_2) < (s_935_0));
        // D s_935_4: write-var gs#412641 <= s_935_3
        fn_state.gs_412641 = s_935_3;
        // N s_935_5: jump b934
        return block_934(state, tracer, fn_state);
    }
    fn block_936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_936_0: const #6s : i
        let s_936_0: i128 = 6;
        // D s_936_1: read-var u#34159:u32
        let s_936_1: u32 = fn_state.u_34159;
        // D s_936_2: cast zx s_936_1 -> bv
        let s_936_2: Bits = Bits::new(s_936_1 as u128, 32u16);
        // C s_936_3: const #1s : i64
        let s_936_3: i64 = 1;
        // C s_936_4: cast zx s_936_3 -> i
        let s_936_4: i128 = (i128::try_from(s_936_3).unwrap());
        // C s_936_5: const #5s : i
        let s_936_5: i128 = 5;
        // C s_936_6: add s_936_5 s_936_4
        let s_936_6: i128 = (s_936_5 + s_936_4);
        // D s_936_7: bit-extract s_936_2 s_936_0 s_936_6
        let s_936_7: Bits = (Bits::new(
            ((s_936_2) >> (s_936_0)).value(),
            u16::try_from(s_936_6).unwrap(),
        ));
        // D s_936_8: cast reint s_936_7 -> u8
        let s_936_8: u8 = (s_936_7.value() as u8);
        // D s_936_9: cast zx s_936_8 -> bv
        let s_936_9: Bits = Bits::new(s_936_8 as u128, 6u16);
        // C s_936_10: const #44u : u8
        let s_936_10: u8 = 44;
        // C s_936_11: cast zx s_936_10 -> bv
        let s_936_11: Bits = Bits::new(s_936_10 as u128, 6u16);
        // D s_936_12: cmp-eq s_936_9 s_936_11
        let s_936_12: bool = ((s_936_9) == (s_936_11));
        // N s_936_13: branch s_936_12 b939 b937
        if s_936_12 {
            return block_939(state, tracer, fn_state);
        } else {
            return block_937(state, tracer, fn_state);
        };
    }
    fn block_937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_937_0: const #0u : u8
        let s_937_0: bool = false;
        // D s_937_1: write-var gs#412636 <= s_937_0
        fn_state.gs_412636 = s_937_0;
        // N s_937_2: jump b938
        return block_938(state, tracer, fn_state);
    }
    fn block_938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_938_0: read-var gs#412636:u8
        let s_938_0: bool = fn_state.gs_412636;
        // D s_938_1: write-var gs#412637 <= s_938_0
        fn_state.gs_412637 = s_938_0;
        // N s_938_2: jump b181
        return block_181(state, tracer, fn_state);
    }
    fn block_939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_939_0: const #4s : i
        let s_939_0: i128 = 4;
        // D s_939_1: read-var u#34159:u32
        let s_939_1: u32 = fn_state.u_34159;
        // D s_939_2: cast zx s_939_1 -> bv
        let s_939_2: Bits = Bits::new(s_939_1 as u128, 32u16);
        // C s_939_3: const #1s : i64
        let s_939_3: i64 = 1;
        // C s_939_4: cast zx s_939_3 -> i
        let s_939_4: i128 = (i128::try_from(s_939_3).unwrap());
        // C s_939_5: const #0s : i
        let s_939_5: i128 = 0;
        // C s_939_6: add s_939_5 s_939_4
        let s_939_6: i128 = (s_939_5 + s_939_4);
        // D s_939_7: bit-extract s_939_2 s_939_0 s_939_6
        let s_939_7: Bits = (Bits::new(
            ((s_939_2) >> (s_939_0)).value(),
            u16::try_from(s_939_6).unwrap(),
        ));
        // D s_939_8: cast reint s_939_7 -> u8
        let s_939_8: bool = ((s_939_7.value()) != 0);
        // D s_939_9: cast zx s_939_8 -> bv
        let s_939_9: Bits = Bits::new(s_939_8 as u128, 1u16);
        // C s_939_10: const #1u : u8
        let s_939_10: bool = true;
        // C s_939_11: cast zx s_939_10 -> bv
        let s_939_11: Bits = Bits::new(s_939_10 as u128, 1u16);
        // D s_939_12: cmp-eq s_939_9 s_939_11
        let s_939_12: bool = ((s_939_9) == (s_939_11));
        // D s_939_13: write-var gs#412636 <= s_939_12
        fn_state.gs_412636 = s_939_12;
        // N s_939_14: jump b938
        return block_938(state, tracer, fn_state);
    }
    fn block_940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_940_0: const #3522s : i
        let s_940_0: i128 = 3522;
        // C s_940_1: const #14696u : u32
        let s_940_1: u32 = 14696;
        // D s_940_2: read-reg s_940_1:i
        let s_940_2: i128 = {
            let value = state.read_register::<i128>(s_940_1 as isize);
            tracer.read_register(s_940_1 as isize, value);
            value
        };
        // D s_940_3: cmp-lt s_940_2 s_940_0
        let s_940_3: bool = ((s_940_2) < (s_940_0));
        // D s_940_4: write-var gs#412618 <= s_940_3
        fn_state.gs_412618 = s_940_3;
        // N s_940_5: jump b177
        return block_177(state, tracer, fn_state);
    }
    fn block_941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_941_0: const #16s : i
        let s_941_0: i128 = 16;
        // D s_941_1: read-var u#34153:u32
        let s_941_1: u32 = fn_state.u_34153;
        // D s_941_2: cast zx s_941_1 -> bv
        let s_941_2: Bits = Bits::new(s_941_1 as u128, 32u16);
        // C s_941_3: const #1s : i64
        let s_941_3: i64 = 1;
        // C s_941_4: cast zx s_941_3 -> i
        let s_941_4: i128 = (i128::try_from(s_941_3).unwrap());
        // C s_941_5: const #5s : i
        let s_941_5: i128 = 5;
        // C s_941_6: add s_941_5 s_941_4
        let s_941_6: i128 = (s_941_5 + s_941_4);
        // D s_941_7: bit-extract s_941_2 s_941_0 s_941_6
        let s_941_7: Bits = (Bits::new(
            ((s_941_2) >> (s_941_0)).value(),
            u16::try_from(s_941_6).unwrap(),
        ));
        // D s_941_8: cast reint s_941_7 -> u8
        let s_941_8: u8 = (s_941_7.value() as u8);
        // D s_941_9: cast zx s_941_8 -> bv
        let s_941_9: Bits = Bits::new(s_941_8 as u128, 6u16);
        // C s_941_10: const #48u : u8
        let s_941_10: u8 = 48;
        // C s_941_11: cast zx s_941_10 -> bv
        let s_941_11: Bits = Bits::new(s_941_10 as u128, 6u16);
        // D s_941_12: cmp-eq s_941_9 s_941_11
        let s_941_12: bool = ((s_941_9) == (s_941_11));
        // N s_941_13: branch s_941_12 b944 b942
        if s_941_12 {
            return block_944(state, tracer, fn_state);
        } else {
            return block_942(state, tracer, fn_state);
        };
    }
    fn block_942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_942_0: const #0u : u8
        let s_942_0: bool = false;
        // D s_942_1: write-var gs#412615 <= s_942_0
        fn_state.gs_412615 = s_942_0;
        // N s_942_2: jump b943
        return block_943(state, tracer, fn_state);
    }
    fn block_943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_943_0: read-var gs#412615:u8
        let s_943_0: bool = fn_state.gs_412615;
        // D s_943_1: write-var gs#412616 <= s_943_0
        fn_state.gs_412616 = s_943_0;
        // N s_943_2: jump b175
        return block_175(state, tracer, fn_state);
    }
    fn block_944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_944_0: const #6s : i
        let s_944_0: i128 = 6;
        // D s_944_1: read-var u#34153:u32
        let s_944_1: u32 = fn_state.u_34153;
        // D s_944_2: cast zx s_944_1 -> bv
        let s_944_2: Bits = Bits::new(s_944_1 as u128, 32u16);
        // C s_944_3: const #1s : i64
        let s_944_3: i64 = 1;
        // C s_944_4: cast zx s_944_3 -> i
        let s_944_4: i128 = (i128::try_from(s_944_3).unwrap());
        // C s_944_5: const #5s : i
        let s_944_5: i128 = 5;
        // C s_944_6: add s_944_5 s_944_4
        let s_944_6: i128 = (s_944_5 + s_944_4);
        // D s_944_7: bit-extract s_944_2 s_944_0 s_944_6
        let s_944_7: Bits = (Bits::new(
            ((s_944_2) >> (s_944_0)).value(),
            u16::try_from(s_944_6).unwrap(),
        ));
        // D s_944_8: cast reint s_944_7 -> u8
        let s_944_8: u8 = (s_944_7.value() as u8);
        // D s_944_9: cast zx s_944_8 -> bv
        let s_944_9: Bits = Bits::new(s_944_8 as u128, 6u16);
        // C s_944_10: const #43u : u8
        let s_944_10: u8 = 43;
        // C s_944_11: cast zx s_944_10 -> bv
        let s_944_11: Bits = Bits::new(s_944_10 as u128, 6u16);
        // D s_944_12: cmp-eq s_944_9 s_944_11
        let s_944_12: bool = ((s_944_9) == (s_944_11));
        // N s_944_13: branch s_944_12 b947 b945
        if s_944_12 {
            return block_947(state, tracer, fn_state);
        } else {
            return block_945(state, tracer, fn_state);
        };
    }
    fn block_945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_945_0: const #0u : u8
        let s_945_0: bool = false;
        // D s_945_1: write-var gs#412614 <= s_945_0
        fn_state.gs_412614 = s_945_0;
        // N s_945_2: jump b946
        return block_946(state, tracer, fn_state);
    }
    fn block_946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_946_0: read-var gs#412614:u8
        let s_946_0: bool = fn_state.gs_412614;
        // D s_946_1: write-var gs#412615 <= s_946_0
        fn_state.gs_412615 = s_946_0;
        // N s_946_2: jump b943
        return block_943(state, tracer, fn_state);
    }
    fn block_947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_947_0: const #4s : i
        let s_947_0: i128 = 4;
        // D s_947_1: read-var u#34153:u32
        let s_947_1: u32 = fn_state.u_34153;
        // D s_947_2: cast zx s_947_1 -> bv
        let s_947_2: Bits = Bits::new(s_947_1 as u128, 32u16);
        // C s_947_3: const #1s : i64
        let s_947_3: i64 = 1;
        // C s_947_4: cast zx s_947_3 -> i
        let s_947_4: i128 = (i128::try_from(s_947_3).unwrap());
        // C s_947_5: const #0s : i
        let s_947_5: i128 = 0;
        // C s_947_6: add s_947_5 s_947_4
        let s_947_6: i128 = (s_947_5 + s_947_4);
        // D s_947_7: bit-extract s_947_2 s_947_0 s_947_6
        let s_947_7: Bits = (Bits::new(
            ((s_947_2) >> (s_947_0)).value(),
            u16::try_from(s_947_6).unwrap(),
        ));
        // D s_947_8: cast reint s_947_7 -> u8
        let s_947_8: bool = ((s_947_7.value()) != 0);
        // D s_947_9: cast zx s_947_8 -> bv
        let s_947_9: Bits = Bits::new(s_947_8 as u128, 1u16);
        // C s_947_10: const #0u : u8
        let s_947_10: bool = false;
        // C s_947_11: cast zx s_947_10 -> bv
        let s_947_11: Bits = Bits::new(s_947_10 as u128, 1u16);
        // D s_947_12: cmp-eq s_947_9 s_947_11
        let s_947_12: bool = ((s_947_9) == (s_947_11));
        // D s_947_13: write-var gs#412614 <= s_947_12
        fn_state.gs_412614 = s_947_12;
        // N s_947_14: jump b946
        return block_946(state, tracer, fn_state);
    }
    fn block_948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_948_0: const #3520s : i
        let s_948_0: i128 = 3520;
        // C s_948_1: const #14696u : u32
        let s_948_1: u32 = 14696;
        // D s_948_2: read-reg s_948_1:i
        let s_948_2: i128 = {
            let value = state.read_register::<i128>(s_948_1 as isize);
            tracer.read_register(s_948_1 as isize, value);
            value
        };
        // D s_948_3: cmp-lt s_948_2 s_948_0
        let s_948_3: bool = ((s_948_2) < (s_948_0));
        // D s_948_4: write-var gs#412594 <= s_948_3
        fn_state.gs_412594 = s_948_3;
        // N s_948_5: jump b171
        return block_171(state, tracer, fn_state);
    }
    fn block_949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_949_0: const #16s : i
        let s_949_0: i128 = 16;
        // D s_949_1: read-var u#34147:u32
        let s_949_1: u32 = fn_state.u_34147;
        // D s_949_2: cast zx s_949_1 -> bv
        let s_949_2: Bits = Bits::new(s_949_1 as u128, 32u16);
        // C s_949_3: const #1s : i64
        let s_949_3: i64 = 1;
        // C s_949_4: cast zx s_949_3 -> i
        let s_949_4: i128 = (i128::try_from(s_949_3).unwrap());
        // C s_949_5: const #5s : i
        let s_949_5: i128 = 5;
        // C s_949_6: add s_949_5 s_949_4
        let s_949_6: i128 = (s_949_5 + s_949_4);
        // D s_949_7: bit-extract s_949_2 s_949_0 s_949_6
        let s_949_7: Bits = (Bits::new(
            ((s_949_2) >> (s_949_0)).value(),
            u16::try_from(s_949_6).unwrap(),
        ));
        // D s_949_8: cast reint s_949_7 -> u8
        let s_949_8: u8 = (s_949_7.value() as u8);
        // D s_949_9: cast zx s_949_8 -> bv
        let s_949_9: Bits = Bits::new(s_949_8 as u128, 6u16);
        // C s_949_10: const #48u : u8
        let s_949_10: u8 = 48;
        // C s_949_11: cast zx s_949_10 -> bv
        let s_949_11: Bits = Bits::new(s_949_10 as u128, 6u16);
        // D s_949_12: cmp-eq s_949_9 s_949_11
        let s_949_12: bool = ((s_949_9) == (s_949_11));
        // N s_949_13: branch s_949_12 b952 b950
        if s_949_12 {
            return block_952(state, tracer, fn_state);
        } else {
            return block_950(state, tracer, fn_state);
        };
    }
    fn block_950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_950_0: const #0u : u8
        let s_950_0: bool = false;
        // D s_950_1: write-var gs#412591 <= s_950_0
        fn_state.gs_412591 = s_950_0;
        // N s_950_2: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_951_0: read-var gs#412591:u8
        let s_951_0: bool = fn_state.gs_412591;
        // D s_951_1: write-var gs#412592 <= s_951_0
        fn_state.gs_412592 = s_951_0;
        // N s_951_2: jump b169
        return block_169(state, tracer, fn_state);
    }
    fn block_952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_952_0: const #6s : i
        let s_952_0: i128 = 6;
        // D s_952_1: read-var u#34147:u32
        let s_952_1: u32 = fn_state.u_34147;
        // D s_952_2: cast zx s_952_1 -> bv
        let s_952_2: Bits = Bits::new(s_952_1 as u128, 32u16);
        // C s_952_3: const #1s : i64
        let s_952_3: i64 = 1;
        // C s_952_4: cast zx s_952_3 -> i
        let s_952_4: i128 = (i128::try_from(s_952_3).unwrap());
        // C s_952_5: const #5s : i
        let s_952_5: i128 = 5;
        // C s_952_6: add s_952_5 s_952_4
        let s_952_6: i128 = (s_952_5 + s_952_4);
        // D s_952_7: bit-extract s_952_2 s_952_0 s_952_6
        let s_952_7: Bits = (Bits::new(
            ((s_952_2) >> (s_952_0)).value(),
            u16::try_from(s_952_6).unwrap(),
        ));
        // D s_952_8: cast reint s_952_7 -> u8
        let s_952_8: u8 = (s_952_7.value() as u8);
        // D s_952_9: cast zx s_952_8 -> bv
        let s_952_9: Bits = Bits::new(s_952_8 as u128, 6u16);
        // C s_952_10: const #41u : u8
        let s_952_10: u8 = 41;
        // C s_952_11: cast zx s_952_10 -> bv
        let s_952_11: Bits = Bits::new(s_952_10 as u128, 6u16);
        // D s_952_12: cmp-eq s_952_9 s_952_11
        let s_952_12: bool = ((s_952_9) == (s_952_11));
        // N s_952_13: branch s_952_12 b955 b953
        if s_952_12 {
            return block_955(state, tracer, fn_state);
        } else {
            return block_953(state, tracer, fn_state);
        };
    }
    fn block_953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_953_0: const #0u : u8
        let s_953_0: bool = false;
        // D s_953_1: write-var gs#412590 <= s_953_0
        fn_state.gs_412590 = s_953_0;
        // N s_953_2: jump b954
        return block_954(state, tracer, fn_state);
    }
    fn block_954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_954_0: read-var gs#412590:u8
        let s_954_0: bool = fn_state.gs_412590;
        // D s_954_1: write-var gs#412591 <= s_954_0
        fn_state.gs_412591 = s_954_0;
        // N s_954_2: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_955_0: const #4s : i
        let s_955_0: i128 = 4;
        // D s_955_1: read-var u#34147:u32
        let s_955_1: u32 = fn_state.u_34147;
        // D s_955_2: cast zx s_955_1 -> bv
        let s_955_2: Bits = Bits::new(s_955_1 as u128, 32u16);
        // C s_955_3: const #1s : i64
        let s_955_3: i64 = 1;
        // C s_955_4: cast zx s_955_3 -> i
        let s_955_4: i128 = (i128::try_from(s_955_3).unwrap());
        // C s_955_5: const #0s : i
        let s_955_5: i128 = 0;
        // C s_955_6: add s_955_5 s_955_4
        let s_955_6: i128 = (s_955_5 + s_955_4);
        // D s_955_7: bit-extract s_955_2 s_955_0 s_955_6
        let s_955_7: Bits = (Bits::new(
            ((s_955_2) >> (s_955_0)).value(),
            u16::try_from(s_955_6).unwrap(),
        ));
        // D s_955_8: cast reint s_955_7 -> u8
        let s_955_8: bool = ((s_955_7.value()) != 0);
        // D s_955_9: cast zx s_955_8 -> bv
        let s_955_9: Bits = Bits::new(s_955_8 as u128, 1u16);
        // C s_955_10: const #0u : u8
        let s_955_10: bool = false;
        // C s_955_11: cast zx s_955_10 -> bv
        let s_955_11: Bits = Bits::new(s_955_10 as u128, 1u16);
        // D s_955_12: cmp-eq s_955_9 s_955_11
        let s_955_12: bool = ((s_955_9) == (s_955_11));
        // D s_955_13: write-var gs#412590 <= s_955_12
        fn_state.gs_412590 = s_955_12;
        // N s_955_14: jump b954
        return block_954(state, tracer, fn_state);
    }
    fn block_956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_956_0: const #28s : i
        let s_956_0: i128 = 28;
        // C s_956_1: const #4s : i
        let s_956_1: i128 = 4;
        // D s_956_2: read-var u#34136:u32
        let s_956_2: u32 = fn_state.u_34136;
        // D s_956_3: cast zx s_956_2 -> bv
        let s_956_3: Bits = Bits::new(s_956_2 as u128, 32u16);
        // D s_956_4: bit-extract s_956_3 s_956_0 s_956_1
        let s_956_4: Bits = (Bits::new(
            ((s_956_3) >> (s_956_0)).value(),
            u16::try_from(s_956_1).unwrap(),
        ));
        // D s_956_5: cast reint s_956_4 -> u8
        let s_956_5: u8 = (s_956_4.value() as u8);
        // D s_956_6: cast zx s_956_5 -> bv
        let s_956_6: Bits = Bits::new(s_956_5 as u128, 4u16);
        // C s_956_7: const #15u : u8
        let s_956_7: u8 = 15;
        // C s_956_8: cast zx s_956_7 -> bv
        let s_956_8: Bits = Bits::new(s_956_7 as u128, 4u16);
        // D s_956_9: cmp-ne s_956_6 s_956_8
        let s_956_9: bool = ((s_956_6) != (s_956_8));
        // N s_956_10: branch s_956_9 b959 b957
        if s_956_9 {
            return block_959(state, tracer, fn_state);
        } else {
            return block_957(state, tracer, fn_state);
        };
    }
    fn block_957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_957_0: const #0u : u8
        let s_957_0: bool = false;
        // D s_957_1: write-var gs#412559 <= s_957_0
        fn_state.gs_412559 = s_957_0;
        // N s_957_2: jump b958
        return block_958(state, tracer, fn_state);
    }
    fn block_958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_958_0: read-var gs#412559:u8
        let s_958_0: bool = fn_state.gs_412559;
        // D s_958_1: write-var gs#412560 <= s_958_0
        fn_state.gs_412560 = s_958_0;
        // N s_958_2: jump b165
        return block_165(state, tracer, fn_state);
    }
    fn block_959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_959_0: const #3509s : i
        let s_959_0: i128 = 3509;
        // C s_959_1: const #14696u : u32
        let s_959_1: u32 = 14696;
        // D s_959_2: read-reg s_959_1:i
        let s_959_2: i128 = {
            let value = state.read_register::<i128>(s_959_1 as isize);
            tracer.read_register(s_959_1 as isize, value);
            value
        };
        // D s_959_3: cmp-lt s_959_2 s_959_0
        let s_959_3: bool = ((s_959_2) < (s_959_0));
        // D s_959_4: write-var gs#412559 <= s_959_3
        fn_state.gs_412559 = s_959_3;
        // N s_959_5: jump b958
        return block_958(state, tracer, fn_state);
    }
    fn block_960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_960_0: const #20s : i
        let s_960_0: i128 = 20;
        // D s_960_1: read-var u#34136:u32
        let s_960_1: u32 = fn_state.u_34136;
        // D s_960_2: cast zx s_960_1 -> bv
        let s_960_2: Bits = Bits::new(s_960_1 as u128, 32u16);
        // C s_960_3: const #1s : i64
        let s_960_3: i64 = 1;
        // C s_960_4: cast zx s_960_3 -> i
        let s_960_4: i128 = (i128::try_from(s_960_3).unwrap());
        // C s_960_5: const #1s : i
        let s_960_5: i128 = 1;
        // C s_960_6: add s_960_5 s_960_4
        let s_960_6: i128 = (s_960_5 + s_960_4);
        // D s_960_7: bit-extract s_960_2 s_960_0 s_960_6
        let s_960_7: Bits = (Bits::new(
            ((s_960_2) >> (s_960_0)).value(),
            u16::try_from(s_960_6).unwrap(),
        ));
        // D s_960_8: cast reint s_960_7 -> u8
        let s_960_8: u8 = (s_960_7.value() as u8);
        // D s_960_9: cast zx s_960_8 -> bv
        let s_960_9: Bits = Bits::new(s_960_8 as u128, 2u16);
        // C s_960_10: const #0u : u8
        let s_960_10: u8 = 0;
        // C s_960_11: cast zx s_960_10 -> bv
        let s_960_11: Bits = Bits::new(s_960_10 as u128, 2u16);
        // D s_960_12: cmp-eq s_960_9 s_960_11
        let s_960_12: bool = ((s_960_9) == (s_960_11));
        // N s_960_13: branch s_960_12 b963 b961
        if s_960_12 {
            return block_963(state, tracer, fn_state);
        } else {
            return block_961(state, tracer, fn_state);
        };
    }
    fn block_961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_961_0: const #0u : u8
        let s_961_0: bool = false;
        // D s_961_1: write-var gs#412554 <= s_961_0
        fn_state.gs_412554 = s_961_0;
        // N s_961_2: jump b962
        return block_962(state, tracer, fn_state);
    }
    fn block_962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_962_0: read-var gs#412554:u8
        let s_962_0: bool = fn_state.gs_412554;
        // D s_962_1: write-var gs#412555 <= s_962_0
        fn_state.gs_412555 = s_962_0;
        // N s_962_2: jump b163
        return block_163(state, tracer, fn_state);
    }
    fn block_963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_963_0: const #10s : i
        let s_963_0: i128 = 10;
        // D s_963_1: read-var u#34136:u32
        let s_963_1: u32 = fn_state.u_34136;
        // D s_963_2: cast zx s_963_1 -> bv
        let s_963_2: Bits = Bits::new(s_963_1 as u128, 32u16);
        // C s_963_3: const #1s : i64
        let s_963_3: i64 = 1;
        // C s_963_4: cast zx s_963_3 -> i
        let s_963_4: i128 = (i128::try_from(s_963_3).unwrap());
        // C s_963_5: const #1s : i
        let s_963_5: i128 = 1;
        // C s_963_6: add s_963_5 s_963_4
        let s_963_6: i128 = (s_963_5 + s_963_4);
        // D s_963_7: bit-extract s_963_2 s_963_0 s_963_6
        let s_963_7: Bits = (Bits::new(
            ((s_963_2) >> (s_963_0)).value(),
            u16::try_from(s_963_6).unwrap(),
        ));
        // D s_963_8: cast reint s_963_7 -> u8
        let s_963_8: u8 = (s_963_7.value() as u8);
        // D s_963_9: cast zx s_963_8 -> bv
        let s_963_9: Bits = Bits::new(s_963_8 as u128, 2u16);
        // C s_963_10: const #2u : u8
        let s_963_10: u8 = 2;
        // C s_963_11: cast zx s_963_10 -> bv
        let s_963_11: Bits = Bits::new(s_963_10 as u128, 2u16);
        // D s_963_12: cmp-eq s_963_9 s_963_11
        let s_963_12: bool = ((s_963_9) == (s_963_11));
        // N s_963_13: branch s_963_12 b966 b964
        if s_963_12 {
            return block_966(state, tracer, fn_state);
        } else {
            return block_964(state, tracer, fn_state);
        };
    }
    fn block_964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_964_0: const #0u : u8
        let s_964_0: bool = false;
        // D s_964_1: write-var gs#412553 <= s_964_0
        fn_state.gs_412553 = s_964_0;
        // N s_964_2: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_965_0: read-var gs#412553:u8
        let s_965_0: bool = fn_state.gs_412553;
        // D s_965_1: write-var gs#412554 <= s_965_0
        fn_state.gs_412554 = s_965_0;
        // N s_965_2: jump b962
        return block_962(state, tracer, fn_state);
    }
    fn block_966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_966_0: const #4s : i
        let s_966_0: i128 = 4;
        // D s_966_1: read-var u#34136:u32
        let s_966_1: u32 = fn_state.u_34136;
        // D s_966_2: cast zx s_966_1 -> bv
        let s_966_2: Bits = Bits::new(s_966_1 as u128, 32u16);
        // C s_966_3: const #1s : i64
        let s_966_3: i64 = 1;
        // C s_966_4: cast zx s_966_3 -> i
        let s_966_4: i128 = (i128::try_from(s_966_3).unwrap());
        // C s_966_5: const #0s : i
        let s_966_5: i128 = 0;
        // C s_966_6: add s_966_5 s_966_4
        let s_966_6: i128 = (s_966_5 + s_966_4);
        // D s_966_7: bit-extract s_966_2 s_966_0 s_966_6
        let s_966_7: Bits = (Bits::new(
            ((s_966_2) >> (s_966_0)).value(),
            u16::try_from(s_966_6).unwrap(),
        ));
        // D s_966_8: cast reint s_966_7 -> u8
        let s_966_8: bool = ((s_966_7.value()) != 0);
        // D s_966_9: cast zx s_966_8 -> bv
        let s_966_9: Bits = Bits::new(s_966_8 as u128, 1u16);
        // C s_966_10: const #0u : u8
        let s_966_10: bool = false;
        // C s_966_11: cast zx s_966_10 -> bv
        let s_966_11: Bits = Bits::new(s_966_10 as u128, 1u16);
        // D s_966_12: cmp-eq s_966_9 s_966_11
        let s_966_12: bool = ((s_966_9) == (s_966_11));
        // D s_966_13: write-var gs#412553 <= s_966_12
        fn_state.gs_412553 = s_966_12;
        // N s_966_14: jump b965
        return block_965(state, tracer, fn_state);
    }
    fn block_967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_967_0: const #28s : i
        let s_967_0: i128 = 28;
        // C s_967_1: const #4s : i
        let s_967_1: i128 = 4;
        // D s_967_2: read-var u#34127:u32
        let s_967_2: u32 = fn_state.u_34127;
        // D s_967_3: cast zx s_967_2 -> bv
        let s_967_3: Bits = Bits::new(s_967_2 as u128, 32u16);
        // D s_967_4: bit-extract s_967_3 s_967_0 s_967_1
        let s_967_4: Bits = (Bits::new(
            ((s_967_3) >> (s_967_0)).value(),
            u16::try_from(s_967_1).unwrap(),
        ));
        // D s_967_5: cast reint s_967_4 -> u8
        let s_967_5: u8 = (s_967_4.value() as u8);
        // D s_967_6: cast zx s_967_5 -> bv
        let s_967_6: Bits = Bits::new(s_967_5 as u128, 4u16);
        // C s_967_7: const #15u : u8
        let s_967_7: u8 = 15;
        // C s_967_8: cast zx s_967_7 -> bv
        let s_967_8: Bits = Bits::new(s_967_7 as u128, 4u16);
        // D s_967_9: cmp-ne s_967_6 s_967_8
        let s_967_9: bool = ((s_967_6) != (s_967_8));
        // N s_967_10: branch s_967_9 b970 b968
        if s_967_9 {
            return block_970(state, tracer, fn_state);
        } else {
            return block_968(state, tracer, fn_state);
        };
    }
    fn block_968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_968_0: const #0u : u8
        let s_968_0: bool = false;
        // D s_968_1: write-var gs#412526 <= s_968_0
        fn_state.gs_412526 = s_968_0;
        // N s_968_2: jump b969
        return block_969(state, tracer, fn_state);
    }
    fn block_969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_969_0: read-var gs#412526:u8
        let s_969_0: bool = fn_state.gs_412526;
        // D s_969_1: write-var gs#412527 <= s_969_0
        fn_state.gs_412527 = s_969_0;
        // N s_969_2: jump b159
        return block_159(state, tracer, fn_state);
    }
    fn block_970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_970_0: const #3502s : i
        let s_970_0: i128 = 3502;
        // C s_970_1: const #14696u : u32
        let s_970_1: u32 = 14696;
        // D s_970_2: read-reg s_970_1:i
        let s_970_2: i128 = {
            let value = state.read_register::<i128>(s_970_1 as isize);
            tracer.read_register(s_970_1 as isize, value);
            value
        };
        // D s_970_3: cmp-lt s_970_2 s_970_0
        let s_970_3: bool = ((s_970_2) < (s_970_0));
        // D s_970_4: write-var gs#412526 <= s_970_3
        fn_state.gs_412526 = s_970_3;
        // N s_970_5: jump b969
        return block_969(state, tracer, fn_state);
    }
    fn block_971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_971_0: const #20s : i
        let s_971_0: i128 = 20;
        // D s_971_1: read-var u#34127:u32
        let s_971_1: u32 = fn_state.u_34127;
        // D s_971_2: cast zx s_971_1 -> bv
        let s_971_2: Bits = Bits::new(s_971_1 as u128, 32u16);
        // C s_971_3: const #1s : i64
        let s_971_3: i64 = 1;
        // C s_971_4: cast zx s_971_3 -> i
        let s_971_4: i128 = (i128::try_from(s_971_3).unwrap());
        // C s_971_5: const #1s : i
        let s_971_5: i128 = 1;
        // C s_971_6: add s_971_5 s_971_4
        let s_971_6: i128 = (s_971_5 + s_971_4);
        // D s_971_7: bit-extract s_971_2 s_971_0 s_971_6
        let s_971_7: Bits = (Bits::new(
            ((s_971_2) >> (s_971_0)).value(),
            u16::try_from(s_971_6).unwrap(),
        ));
        // D s_971_8: cast reint s_971_7 -> u8
        let s_971_8: u8 = (s_971_7.value() as u8);
        // D s_971_9: cast zx s_971_8 -> bv
        let s_971_9: Bits = Bits::new(s_971_8 as u128, 2u16);
        // C s_971_10: const #1u : u8
        let s_971_10: u8 = 1;
        // C s_971_11: cast zx s_971_10 -> bv
        let s_971_11: Bits = Bits::new(s_971_10 as u128, 2u16);
        // D s_971_12: cmp-eq s_971_9 s_971_11
        let s_971_12: bool = ((s_971_9) == (s_971_11));
        // N s_971_13: branch s_971_12 b974 b972
        if s_971_12 {
            return block_974(state, tracer, fn_state);
        } else {
            return block_972(state, tracer, fn_state);
        };
    }
    fn block_972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_972_0: const #0u : u8
        let s_972_0: bool = false;
        // D s_972_1: write-var gs#412521 <= s_972_0
        fn_state.gs_412521 = s_972_0;
        // N s_972_2: jump b973
        return block_973(state, tracer, fn_state);
    }
    fn block_973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_973_0: read-var gs#412521:u8
        let s_973_0: bool = fn_state.gs_412521;
        // D s_973_1: write-var gs#412522 <= s_973_0
        fn_state.gs_412522 = s_973_0;
        // N s_973_2: jump b157
        return block_157(state, tracer, fn_state);
    }
    fn block_974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_974_0: const #10s : i
        let s_974_0: i128 = 10;
        // D s_974_1: read-var u#34127:u32
        let s_974_1: u32 = fn_state.u_34127;
        // D s_974_2: cast zx s_974_1 -> bv
        let s_974_2: Bits = Bits::new(s_974_1 as u128, 32u16);
        // C s_974_3: const #1s : i64
        let s_974_3: i64 = 1;
        // C s_974_4: cast zx s_974_3 -> i
        let s_974_4: i128 = (i128::try_from(s_974_3).unwrap());
        // C s_974_5: const #1s : i
        let s_974_5: i128 = 1;
        // C s_974_6: add s_974_5 s_974_4
        let s_974_6: i128 = (s_974_5 + s_974_4);
        // D s_974_7: bit-extract s_974_2 s_974_0 s_974_6
        let s_974_7: Bits = (Bits::new(
            ((s_974_2) >> (s_974_0)).value(),
            u16::try_from(s_974_6).unwrap(),
        ));
        // D s_974_8: cast reint s_974_7 -> u8
        let s_974_8: u8 = (s_974_7.value() as u8);
        // D s_974_9: cast zx s_974_8 -> bv
        let s_974_9: Bits = Bits::new(s_974_8 as u128, 2u16);
        // C s_974_10: const #2u : u8
        let s_974_10: u8 = 2;
        // C s_974_11: cast zx s_974_10 -> bv
        let s_974_11: Bits = Bits::new(s_974_10 as u128, 2u16);
        // D s_974_12: cmp-eq s_974_9 s_974_11
        let s_974_12: bool = ((s_974_9) == (s_974_11));
        // D s_974_13: write-var gs#412521 <= s_974_12
        fn_state.gs_412521 = s_974_12;
        // N s_974_14: jump b973
        return block_973(state, tracer, fn_state);
    }
    fn block_975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_975_0: const #28s : i
        let s_975_0: i128 = 28;
        // C s_975_1: const #4s : i
        let s_975_1: i128 = 4;
        // D s_975_2: read-var u#34117:u32
        let s_975_2: u32 = fn_state.u_34117;
        // D s_975_3: cast zx s_975_2 -> bv
        let s_975_3: Bits = Bits::new(s_975_2 as u128, 32u16);
        // D s_975_4: bit-extract s_975_3 s_975_0 s_975_1
        let s_975_4: Bits = (Bits::new(
            ((s_975_3) >> (s_975_0)).value(),
            u16::try_from(s_975_1).unwrap(),
        ));
        // D s_975_5: cast reint s_975_4 -> u8
        let s_975_5: u8 = (s_975_4.value() as u8);
        // D s_975_6: cast zx s_975_5 -> bv
        let s_975_6: Bits = Bits::new(s_975_5 as u128, 4u16);
        // C s_975_7: const #15u : u8
        let s_975_7: u8 = 15;
        // C s_975_8: cast zx s_975_7 -> bv
        let s_975_8: Bits = Bits::new(s_975_7 as u128, 4u16);
        // D s_975_9: cmp-ne s_975_6 s_975_8
        let s_975_9: bool = ((s_975_6) != (s_975_8));
        // N s_975_10: branch s_975_9 b978 b976
        if s_975_9 {
            return block_978(state, tracer, fn_state);
        } else {
            return block_976(state, tracer, fn_state);
        };
    }
    fn block_976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_976_0: const #0u : u8
        let s_976_0: bool = false;
        // D s_976_1: write-var gs#412494 <= s_976_0
        fn_state.gs_412494 = s_976_0;
        // N s_976_2: jump b977
        return block_977(state, tracer, fn_state);
    }
    fn block_977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_977_0: read-var gs#412494:u8
        let s_977_0: bool = fn_state.gs_412494;
        // D s_977_1: write-var gs#412495 <= s_977_0
        fn_state.gs_412495 = s_977_0;
        // N s_977_2: jump b153
        return block_153(state, tracer, fn_state);
    }
    fn block_978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_978_0: const #3499s : i
        let s_978_0: i128 = 3499;
        // C s_978_1: const #14696u : u32
        let s_978_1: u32 = 14696;
        // D s_978_2: read-reg s_978_1:i
        let s_978_2: i128 = {
            let value = state.read_register::<i128>(s_978_1 as isize);
            tracer.read_register(s_978_1 as isize, value);
            value
        };
        // D s_978_3: cmp-lt s_978_2 s_978_0
        let s_978_3: bool = ((s_978_2) < (s_978_0));
        // D s_978_4: write-var gs#412494 <= s_978_3
        fn_state.gs_412494 = s_978_3;
        // N s_978_5: jump b977
        return block_977(state, tracer, fn_state);
    }
    fn block_979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_979_0: const #20s : i
        let s_979_0: i128 = 20;
        // D s_979_1: read-var u#34117:u32
        let s_979_1: u32 = fn_state.u_34117;
        // D s_979_2: cast zx s_979_1 -> bv
        let s_979_2: Bits = Bits::new(s_979_1 as u128, 32u16);
        // C s_979_3: const #1s : i64
        let s_979_3: i64 = 1;
        // C s_979_4: cast zx s_979_3 -> i
        let s_979_4: i128 = (i128::try_from(s_979_3).unwrap());
        // C s_979_5: const #0s : i
        let s_979_5: i128 = 0;
        // C s_979_6: add s_979_5 s_979_4
        let s_979_6: i128 = (s_979_5 + s_979_4);
        // D s_979_7: bit-extract s_979_2 s_979_0 s_979_6
        let s_979_7: Bits = (Bits::new(
            ((s_979_2) >> (s_979_0)).value(),
            u16::try_from(s_979_6).unwrap(),
        ));
        // D s_979_8: cast reint s_979_7 -> u8
        let s_979_8: bool = ((s_979_7.value()) != 0);
        // D s_979_9: cast zx s_979_8 -> bv
        let s_979_9: Bits = Bits::new(s_979_8 as u128, 1u16);
        // C s_979_10: const #1u : u8
        let s_979_10: bool = true;
        // C s_979_11: cast zx s_979_10 -> bv
        let s_979_11: Bits = Bits::new(s_979_10 as u128, 1u16);
        // D s_979_12: cmp-eq s_979_9 s_979_11
        let s_979_12: bool = ((s_979_9) == (s_979_11));
        // N s_979_13: branch s_979_12 b982 b980
        if s_979_12 {
            return block_982(state, tracer, fn_state);
        } else {
            return block_980(state, tracer, fn_state);
        };
    }
    fn block_980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_980_0: const #0u : u8
        let s_980_0: bool = false;
        // D s_980_1: write-var gs#412489 <= s_980_0
        fn_state.gs_412489 = s_980_0;
        // N s_980_2: jump b981
        return block_981(state, tracer, fn_state);
    }
    fn block_981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_981_0: read-var gs#412489:u8
        let s_981_0: bool = fn_state.gs_412489;
        // D s_981_1: write-var gs#412490 <= s_981_0
        fn_state.gs_412490 = s_981_0;
        // N s_981_2: jump b151
        return block_151(state, tracer, fn_state);
    }
    fn block_982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_982_0: const #8s : i
        let s_982_0: i128 = 8;
        // D s_982_1: read-var u#34117:u32
        let s_982_1: u32 = fn_state.u_34117;
        // D s_982_2: cast zx s_982_1 -> bv
        let s_982_2: Bits = Bits::new(s_982_1 as u128, 32u16);
        // C s_982_3: const #1s : i64
        let s_982_3: i64 = 1;
        // C s_982_4: cast zx s_982_3 -> i
        let s_982_4: i128 = (i128::try_from(s_982_3).unwrap());
        // C s_982_5: const #3s : i
        let s_982_5: i128 = 3;
        // C s_982_6: add s_982_5 s_982_4
        let s_982_6: i128 = (s_982_5 + s_982_4);
        // D s_982_7: bit-extract s_982_2 s_982_0 s_982_6
        let s_982_7: Bits = (Bits::new(
            ((s_982_2) >> (s_982_0)).value(),
            u16::try_from(s_982_6).unwrap(),
        ));
        // D s_982_8: cast reint s_982_7 -> u8
        let s_982_8: u8 = (s_982_7.value() as u8);
        // D s_982_9: cast zx s_982_8 -> bv
        let s_982_9: Bits = Bits::new(s_982_8 as u128, 4u16);
        // C s_982_10: const #10u : u8
        let s_982_10: u8 = 10;
        // C s_982_11: cast zx s_982_10 -> bv
        let s_982_11: Bits = Bits::new(s_982_10 as u128, 4u16);
        // D s_982_12: cmp-eq s_982_9 s_982_11
        let s_982_12: bool = ((s_982_9) == (s_982_11));
        // D s_982_13: write-var gs#412489 <= s_982_12
        fn_state.gs_412489 = s_982_12;
        // N s_982_14: jump b981
        return block_981(state, tracer, fn_state);
    }
    fn block_983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_983_0: const #28s : i
        let s_983_0: i128 = 28;
        // C s_983_1: const #4s : i
        let s_983_1: i128 = 4;
        // D s_983_2: read-var u#34107:u32
        let s_983_2: u32 = fn_state.u_34107;
        // D s_983_3: cast zx s_983_2 -> bv
        let s_983_3: Bits = Bits::new(s_983_2 as u128, 32u16);
        // D s_983_4: bit-extract s_983_3 s_983_0 s_983_1
        let s_983_4: Bits = (Bits::new(
            ((s_983_3) >> (s_983_0)).value(),
            u16::try_from(s_983_1).unwrap(),
        ));
        // D s_983_5: cast reint s_983_4 -> u8
        let s_983_5: u8 = (s_983_4.value() as u8);
        // D s_983_6: cast zx s_983_5 -> bv
        let s_983_6: Bits = Bits::new(s_983_5 as u128, 4u16);
        // C s_983_7: const #15u : u8
        let s_983_7: u8 = 15;
        // C s_983_8: cast zx s_983_7 -> bv
        let s_983_8: Bits = Bits::new(s_983_7 as u128, 4u16);
        // D s_983_9: cmp-ne s_983_6 s_983_8
        let s_983_9: bool = ((s_983_6) != (s_983_8));
        // N s_983_10: branch s_983_9 b986 b984
        if s_983_9 {
            return block_986(state, tracer, fn_state);
        } else {
            return block_984(state, tracer, fn_state);
        };
    }
    fn block_984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_984_0: const #0u : u8
        let s_984_0: bool = false;
        // D s_984_1: write-var gs#412462 <= s_984_0
        fn_state.gs_412462 = s_984_0;
        // N s_984_2: jump b985
        return block_985(state, tracer, fn_state);
    }
    fn block_985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_985_0: read-var gs#412462:u8
        let s_985_0: bool = fn_state.gs_412462;
        // D s_985_1: write-var gs#412463 <= s_985_0
        fn_state.gs_412463 = s_985_0;
        // N s_985_2: jump b147
        return block_147(state, tracer, fn_state);
    }
    fn block_986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_986_0: const #3498s : i
        let s_986_0: i128 = 3498;
        // C s_986_1: const #14696u : u32
        let s_986_1: u32 = 14696;
        // D s_986_2: read-reg s_986_1:i
        let s_986_2: i128 = {
            let value = state.read_register::<i128>(s_986_1 as isize);
            tracer.read_register(s_986_1 as isize, value);
            value
        };
        // D s_986_3: cmp-lt s_986_2 s_986_0
        let s_986_3: bool = ((s_986_2) < (s_986_0));
        // D s_986_4: write-var gs#412462 <= s_986_3
        fn_state.gs_412462 = s_986_3;
        // N s_986_5: jump b985
        return block_985(state, tracer, fn_state);
    }
    fn block_987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_987_0: const #20s : i
        let s_987_0: i128 = 20;
        // D s_987_1: read-var u#34107:u32
        let s_987_1: u32 = fn_state.u_34107;
        // D s_987_2: cast zx s_987_1 -> bv
        let s_987_2: Bits = Bits::new(s_987_1 as u128, 32u16);
        // C s_987_3: const #1s : i64
        let s_987_3: i64 = 1;
        // C s_987_4: cast zx s_987_3 -> i
        let s_987_4: i128 = (i128::try_from(s_987_3).unwrap());
        // C s_987_5: const #0s : i
        let s_987_5: i128 = 0;
        // C s_987_6: add s_987_5 s_987_4
        let s_987_6: i128 = (s_987_5 + s_987_4);
        // D s_987_7: bit-extract s_987_2 s_987_0 s_987_6
        let s_987_7: Bits = (Bits::new(
            ((s_987_2) >> (s_987_0)).value(),
            u16::try_from(s_987_6).unwrap(),
        ));
        // D s_987_8: cast reint s_987_7 -> u8
        let s_987_8: bool = ((s_987_7.value()) != 0);
        // D s_987_9: cast zx s_987_8 -> bv
        let s_987_9: Bits = Bits::new(s_987_8 as u128, 1u16);
        // C s_987_10: const #1u : u8
        let s_987_10: bool = true;
        // C s_987_11: cast zx s_987_10 -> bv
        let s_987_11: Bits = Bits::new(s_987_10 as u128, 1u16);
        // D s_987_12: cmp-eq s_987_9 s_987_11
        let s_987_12: bool = ((s_987_9) == (s_987_11));
        // N s_987_13: branch s_987_12 b990 b988
        if s_987_12 {
            return block_990(state, tracer, fn_state);
        } else {
            return block_988(state, tracer, fn_state);
        };
    }
    fn block_988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_988_0: const #0u : u8
        let s_988_0: bool = false;
        // D s_988_1: write-var gs#412457 <= s_988_0
        fn_state.gs_412457 = s_988_0;
        // N s_988_2: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_989_0: read-var gs#412457:u8
        let s_989_0: bool = fn_state.gs_412457;
        // D s_989_1: write-var gs#412458 <= s_989_0
        fn_state.gs_412458 = s_989_0;
        // N s_989_2: jump b145
        return block_145(state, tracer, fn_state);
    }
    fn block_990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_990_0: const #8s : i
        let s_990_0: i128 = 8;
        // D s_990_1: read-var u#34107:u32
        let s_990_1: u32 = fn_state.u_34107;
        // D s_990_2: cast zx s_990_1 -> bv
        let s_990_2: Bits = Bits::new(s_990_1 as u128, 32u16);
        // C s_990_3: const #1s : i64
        let s_990_3: i64 = 1;
        // C s_990_4: cast zx s_990_3 -> i
        let s_990_4: i128 = (i128::try_from(s_990_3).unwrap());
        // C s_990_5: const #3s : i
        let s_990_5: i128 = 3;
        // C s_990_6: add s_990_5 s_990_4
        let s_990_6: i128 = (s_990_5 + s_990_4);
        // D s_990_7: bit-extract s_990_2 s_990_0 s_990_6
        let s_990_7: Bits = (Bits::new(
            ((s_990_2) >> (s_990_0)).value(),
            u16::try_from(s_990_6).unwrap(),
        ));
        // D s_990_8: cast reint s_990_7 -> u8
        let s_990_8: u8 = (s_990_7.value() as u8);
        // D s_990_9: cast zx s_990_8 -> bv
        let s_990_9: Bits = Bits::new(s_990_8 as u128, 4u16);
        // C s_990_10: const #11u : u8
        let s_990_10: u8 = 11;
        // C s_990_11: cast zx s_990_10 -> bv
        let s_990_11: Bits = Bits::new(s_990_10 as u128, 4u16);
        // D s_990_12: cmp-eq s_990_9 s_990_11
        let s_990_12: bool = ((s_990_9) == (s_990_11));
        // D s_990_13: write-var gs#412457 <= s_990_12
        fn_state.gs_412457 = s_990_12;
        // N s_990_14: jump b989
        return block_989(state, tracer, fn_state);
    }
    fn block_991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_991_0: const #28s : i
        let s_991_0: i128 = 28;
        // C s_991_1: const #4s : i
        let s_991_1: i128 = 4;
        // D s_991_2: read-var u#34096:u32
        let s_991_2: u32 = fn_state.u_34096;
        // D s_991_3: cast zx s_991_2 -> bv
        let s_991_3: Bits = Bits::new(s_991_2 as u128, 32u16);
        // D s_991_4: bit-extract s_991_3 s_991_0 s_991_1
        let s_991_4: Bits = (Bits::new(
            ((s_991_3) >> (s_991_0)).value(),
            u16::try_from(s_991_1).unwrap(),
        ));
        // D s_991_5: cast reint s_991_4 -> u8
        let s_991_5: u8 = (s_991_4.value() as u8);
        // D s_991_6: cast zx s_991_5 -> bv
        let s_991_6: Bits = Bits::new(s_991_5 as u128, 4u16);
        // C s_991_7: const #15u : u8
        let s_991_7: u8 = 15;
        // C s_991_8: cast zx s_991_7 -> bv
        let s_991_8: Bits = Bits::new(s_991_7 as u128, 4u16);
        // D s_991_9: cmp-ne s_991_6 s_991_8
        let s_991_9: bool = ((s_991_6) != (s_991_8));
        // N s_991_10: branch s_991_9 b994 b992
        if s_991_9 {
            return block_994(state, tracer, fn_state);
        } else {
            return block_992(state, tracer, fn_state);
        };
    }
    fn block_992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_992_0: const #0u : u8
        let s_992_0: bool = false;
        // D s_992_1: write-var gs#412428 <= s_992_0
        fn_state.gs_412428 = s_992_0;
        // N s_992_2: jump b993
        return block_993(state, tracer, fn_state);
    }
    fn block_993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_993_0: read-var gs#412428:u8
        let s_993_0: bool = fn_state.gs_412428;
        // D s_993_1: write-var gs#412429 <= s_993_0
        fn_state.gs_412429 = s_993_0;
        // N s_993_2: jump b141
        return block_141(state, tracer, fn_state);
    }
    fn block_994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_994_0: const #3446s : i
        let s_994_0: i128 = 3446;
        // C s_994_1: const #14696u : u32
        let s_994_1: u32 = 14696;
        // D s_994_2: read-reg s_994_1:i
        let s_994_2: i128 = {
            let value = state.read_register::<i128>(s_994_1 as isize);
            tracer.read_register(s_994_1 as isize, value);
            value
        };
        // D s_994_3: cmp-lt s_994_2 s_994_0
        let s_994_3: bool = ((s_994_2) < (s_994_0));
        // D s_994_4: write-var gs#412428 <= s_994_3
        fn_state.gs_412428 = s_994_3;
        // N s_994_5: jump b993
        return block_993(state, tracer, fn_state);
    }
    fn block_995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_995_0: const #20s : i
        let s_995_0: i128 = 20;
        // D s_995_1: read-var u#34096:u32
        let s_995_1: u32 = fn_state.u_34096;
        // D s_995_2: cast zx s_995_1 -> bv
        let s_995_2: Bits = Bits::new(s_995_1 as u128, 32u16);
        // C s_995_3: const #1s : i64
        let s_995_3: i64 = 1;
        // C s_995_4: cast zx s_995_3 -> i
        let s_995_4: i128 = (i128::try_from(s_995_3).unwrap());
        // C s_995_5: const #1s : i
        let s_995_5: i128 = 1;
        // C s_995_6: add s_995_5 s_995_4
        let s_995_6: i128 = (s_995_5 + s_995_4);
        // D s_995_7: bit-extract s_995_2 s_995_0 s_995_6
        let s_995_7: Bits = (Bits::new(
            ((s_995_2) >> (s_995_0)).value(),
            u16::try_from(s_995_6).unwrap(),
        ));
        // D s_995_8: cast reint s_995_7 -> u8
        let s_995_8: u8 = (s_995_7.value() as u8);
        // D s_995_9: cast zx s_995_8 -> bv
        let s_995_9: Bits = Bits::new(s_995_8 as u128, 2u16);
        // C s_995_10: const #1u : u8
        let s_995_10: u8 = 1;
        // C s_995_11: cast zx s_995_10 -> bv
        let s_995_11: Bits = Bits::new(s_995_10 as u128, 2u16);
        // D s_995_12: cmp-eq s_995_9 s_995_11
        let s_995_12: bool = ((s_995_9) == (s_995_11));
        // N s_995_13: branch s_995_12 b998 b996
        if s_995_12 {
            return block_998(state, tracer, fn_state);
        } else {
            return block_996(state, tracer, fn_state);
        };
    }
    fn block_996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_996_0: const #0u : u8
        let s_996_0: bool = false;
        // D s_996_1: write-var gs#412423 <= s_996_0
        fn_state.gs_412423 = s_996_0;
        // N s_996_2: jump b997
        return block_997(state, tracer, fn_state);
    }
    fn block_997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_997_0: read-var gs#412423:u8
        let s_997_0: bool = fn_state.gs_412423;
        // D s_997_1: write-var gs#412424 <= s_997_0
        fn_state.gs_412424 = s_997_0;
        // N s_997_2: jump b139
        return block_139(state, tracer, fn_state);
    }
    fn block_998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_998_0: const #10s : i
        let s_998_0: i128 = 10;
        // D s_998_1: read-var u#34096:u32
        let s_998_1: u32 = fn_state.u_34096;
        // D s_998_2: cast zx s_998_1 -> bv
        let s_998_2: Bits = Bits::new(s_998_1 as u128, 32u16);
        // C s_998_3: const #1s : i64
        let s_998_3: i64 = 1;
        // C s_998_4: cast zx s_998_3 -> i
        let s_998_4: i128 = (i128::try_from(s_998_3).unwrap());
        // C s_998_5: const #1s : i
        let s_998_5: i128 = 1;
        // C s_998_6: add s_998_5 s_998_4
        let s_998_6: i128 = (s_998_5 + s_998_4);
        // D s_998_7: bit-extract s_998_2 s_998_0 s_998_6
        let s_998_7: Bits = (Bits::new(
            ((s_998_2) >> (s_998_0)).value(),
            u16::try_from(s_998_6).unwrap(),
        ));
        // D s_998_8: cast reint s_998_7 -> u8
        let s_998_8: u8 = (s_998_7.value() as u8);
        // D s_998_9: cast zx s_998_8 -> bv
        let s_998_9: Bits = Bits::new(s_998_8 as u128, 2u16);
        // C s_998_10: const #2u : u8
        let s_998_10: u8 = 2;
        // C s_998_11: cast zx s_998_10 -> bv
        let s_998_11: Bits = Bits::new(s_998_10 as u128, 2u16);
        // D s_998_12: cmp-eq s_998_9 s_998_11
        let s_998_12: bool = ((s_998_9) == (s_998_11));
        // N s_998_13: branch s_998_12 b1001 b999
        if s_998_12 {
            return block_1001(state, tracer, fn_state);
        } else {
            return block_999(state, tracer, fn_state);
        };
    }
    fn block_999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_999_0: const #0u : u8
        let s_999_0: bool = false;
        // D s_999_1: write-var gs#412422 <= s_999_0
        fn_state.gs_412422 = s_999_0;
        // N s_999_2: jump b1000
        return block_1000(state, tracer, fn_state);
    }
    fn block_1000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1000_0: read-var gs#412422:u8
        let s_1000_0: bool = fn_state.gs_412422;
        // D s_1000_1: write-var gs#412423 <= s_1000_0
        fn_state.gs_412423 = s_1000_0;
        // N s_1000_2: jump b997
        return block_997(state, tracer, fn_state);
    }
    fn block_1001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1001_0: const #4s : i
        let s_1001_0: i128 = 4;
        // D s_1001_1: read-var u#34096:u32
        let s_1001_1: u32 = fn_state.u_34096;
        // D s_1001_2: cast zx s_1001_1 -> bv
        let s_1001_2: Bits = Bits::new(s_1001_1 as u128, 32u16);
        // C s_1001_3: const #1s : i64
        let s_1001_3: i64 = 1;
        // C s_1001_4: cast zx s_1001_3 -> i
        let s_1001_4: i128 = (i128::try_from(s_1001_3).unwrap());
        // C s_1001_5: const #0s : i
        let s_1001_5: i128 = 0;
        // C s_1001_6: add s_1001_5 s_1001_4
        let s_1001_6: i128 = (s_1001_5 + s_1001_4);
        // D s_1001_7: bit-extract s_1001_2 s_1001_0 s_1001_6
        let s_1001_7: Bits = (Bits::new(
            ((s_1001_2) >> (s_1001_0)).value(),
            u16::try_from(s_1001_6).unwrap(),
        ));
        // D s_1001_8: cast reint s_1001_7 -> u8
        let s_1001_8: bool = ((s_1001_7.value()) != 0);
        // D s_1001_9: cast zx s_1001_8 -> bv
        let s_1001_9: Bits = Bits::new(s_1001_8 as u128, 1u16);
        // C s_1001_10: const #0u : u8
        let s_1001_10: bool = false;
        // C s_1001_11: cast zx s_1001_10 -> bv
        let s_1001_11: Bits = Bits::new(s_1001_10 as u128, 1u16);
        // D s_1001_12: cmp-eq s_1001_9 s_1001_11
        let s_1001_12: bool = ((s_1001_9) == (s_1001_11));
        // D s_1001_13: write-var gs#412422 <= s_1001_12
        fn_state.gs_412422 = s_1001_12;
        // N s_1001_14: jump b1000
        return block_1000(state, tracer, fn_state);
    }
    fn block_1002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1002_0: const #28s : i
        let s_1002_0: i128 = 28;
        // C s_1002_1: const #4s : i
        let s_1002_1: i128 = 4;
        // D s_1002_2: read-var u#34085:u32
        let s_1002_2: u32 = fn_state.u_34085;
        // D s_1002_3: cast zx s_1002_2 -> bv
        let s_1002_3: Bits = Bits::new(s_1002_2 as u128, 32u16);
        // D s_1002_4: bit-extract s_1002_3 s_1002_0 s_1002_1
        let s_1002_4: Bits = (Bits::new(
            ((s_1002_3) >> (s_1002_0)).value(),
            u16::try_from(s_1002_1).unwrap(),
        ));
        // D s_1002_5: cast reint s_1002_4 -> u8
        let s_1002_5: u8 = (s_1002_4.value() as u8);
        // D s_1002_6: cast zx s_1002_5 -> bv
        let s_1002_6: Bits = Bits::new(s_1002_5 as u128, 4u16);
        // C s_1002_7: const #15u : u8
        let s_1002_7: u8 = 15;
        // C s_1002_8: cast zx s_1002_7 -> bv
        let s_1002_8: Bits = Bits::new(s_1002_7 as u128, 4u16);
        // D s_1002_9: cmp-ne s_1002_6 s_1002_8
        let s_1002_9: bool = ((s_1002_6) != (s_1002_8));
        // N s_1002_10: branch s_1002_9 b1005 b1003
        if s_1002_9 {
            return block_1005(state, tracer, fn_state);
        } else {
            return block_1003(state, tracer, fn_state);
        };
    }
    fn block_1003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1003_0: const #0u : u8
        let s_1003_0: bool = false;
        // D s_1003_1: write-var gs#412391 <= s_1003_0
        fn_state.gs_412391 = s_1003_0;
        // N s_1003_2: jump b1004
        return block_1004(state, tracer, fn_state);
    }
    fn block_1004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1004_0: read-var gs#412391:u8
        let s_1004_0: bool = fn_state.gs_412391;
        // D s_1004_1: write-var gs#412392 <= s_1004_0
        fn_state.gs_412392 = s_1004_0;
        // N s_1004_2: jump b135
        return block_135(state, tracer, fn_state);
    }
    fn block_1005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1005_0: const #3443s : i
        let s_1005_0: i128 = 3443;
        // C s_1005_1: const #14696u : u32
        let s_1005_1: u32 = 14696;
        // D s_1005_2: read-reg s_1005_1:i
        let s_1005_2: i128 = {
            let value = state.read_register::<i128>(s_1005_1 as isize);
            tracer.read_register(s_1005_1 as isize, value);
            value
        };
        // D s_1005_3: cmp-lt s_1005_2 s_1005_0
        let s_1005_3: bool = ((s_1005_2) < (s_1005_0));
        // D s_1005_4: write-var gs#412391 <= s_1005_3
        fn_state.gs_412391 = s_1005_3;
        // N s_1005_5: jump b1004
        return block_1004(state, tracer, fn_state);
    }
    fn block_1006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1006_0: const #20s : i
        let s_1006_0: i128 = 20;
        // D s_1006_1: read-var u#34085:u32
        let s_1006_1: u32 = fn_state.u_34085;
        // D s_1006_2: cast zx s_1006_1 -> bv
        let s_1006_2: Bits = Bits::new(s_1006_1 as u128, 32u16);
        // C s_1006_3: const #1s : i64
        let s_1006_3: i64 = 1;
        // C s_1006_4: cast zx s_1006_3 -> i
        let s_1006_4: i128 = (i128::try_from(s_1006_3).unwrap());
        // C s_1006_5: const #1s : i
        let s_1006_5: i128 = 1;
        // C s_1006_6: add s_1006_5 s_1006_4
        let s_1006_6: i128 = (s_1006_5 + s_1006_4);
        // D s_1006_7: bit-extract s_1006_2 s_1006_0 s_1006_6
        let s_1006_7: Bits = (Bits::new(
            ((s_1006_2) >> (s_1006_0)).value(),
            u16::try_from(s_1006_6).unwrap(),
        ));
        // D s_1006_8: cast reint s_1006_7 -> u8
        let s_1006_8: u8 = (s_1006_7.value() as u8);
        // D s_1006_9: cast zx s_1006_8 -> bv
        let s_1006_9: Bits = Bits::new(s_1006_8 as u128, 2u16);
        // C s_1006_10: const #2u : u8
        let s_1006_10: u8 = 2;
        // C s_1006_11: cast zx s_1006_10 -> bv
        let s_1006_11: Bits = Bits::new(s_1006_10 as u128, 2u16);
        // D s_1006_12: cmp-eq s_1006_9 s_1006_11
        let s_1006_12: bool = ((s_1006_9) == (s_1006_11));
        // N s_1006_13: branch s_1006_12 b1009 b1007
        if s_1006_12 {
            return block_1009(state, tracer, fn_state);
        } else {
            return block_1007(state, tracer, fn_state);
        };
    }
    fn block_1007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1007_0: const #0u : u8
        let s_1007_0: bool = false;
        // D s_1007_1: write-var gs#412386 <= s_1007_0
        fn_state.gs_412386 = s_1007_0;
        // N s_1007_2: jump b1008
        return block_1008(state, tracer, fn_state);
    }
    fn block_1008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1008_0: read-var gs#412386:u8
        let s_1008_0: bool = fn_state.gs_412386;
        // D s_1008_1: write-var gs#412387 <= s_1008_0
        fn_state.gs_412387 = s_1008_0;
        // N s_1008_2: jump b133
        return block_133(state, tracer, fn_state);
    }
    fn block_1009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1009_0: const #10s : i
        let s_1009_0: i128 = 10;
        // D s_1009_1: read-var u#34085:u32
        let s_1009_1: u32 = fn_state.u_34085;
        // D s_1009_2: cast zx s_1009_1 -> bv
        let s_1009_2: Bits = Bits::new(s_1009_1 as u128, 32u16);
        // C s_1009_3: const #1s : i64
        let s_1009_3: i64 = 1;
        // C s_1009_4: cast zx s_1009_3 -> i
        let s_1009_4: i128 = (i128::try_from(s_1009_3).unwrap());
        // C s_1009_5: const #1s : i
        let s_1009_5: i128 = 1;
        // C s_1009_6: add s_1009_5 s_1009_4
        let s_1009_6: i128 = (s_1009_5 + s_1009_4);
        // D s_1009_7: bit-extract s_1009_2 s_1009_0 s_1009_6
        let s_1009_7: Bits = (Bits::new(
            ((s_1009_2) >> (s_1009_0)).value(),
            u16::try_from(s_1009_6).unwrap(),
        ));
        // D s_1009_8: cast reint s_1009_7 -> u8
        let s_1009_8: u8 = (s_1009_7.value() as u8);
        // D s_1009_9: cast zx s_1009_8 -> bv
        let s_1009_9: Bits = Bits::new(s_1009_8 as u128, 2u16);
        // C s_1009_10: const #2u : u8
        let s_1009_10: u8 = 2;
        // C s_1009_11: cast zx s_1009_10 -> bv
        let s_1009_11: Bits = Bits::new(s_1009_10 as u128, 2u16);
        // D s_1009_12: cmp-eq s_1009_9 s_1009_11
        let s_1009_12: bool = ((s_1009_9) == (s_1009_11));
        // N s_1009_13: branch s_1009_12 b1012 b1010
        if s_1009_12 {
            return block_1012(state, tracer, fn_state);
        } else {
            return block_1010(state, tracer, fn_state);
        };
    }
    fn block_1010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1010_0: const #0u : u8
        let s_1010_0: bool = false;
        // D s_1010_1: write-var gs#412385 <= s_1010_0
        fn_state.gs_412385 = s_1010_0;
        // N s_1010_2: jump b1011
        return block_1011(state, tracer, fn_state);
    }
    fn block_1011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1011_0: read-var gs#412385:u8
        let s_1011_0: bool = fn_state.gs_412385;
        // D s_1011_1: write-var gs#412386 <= s_1011_0
        fn_state.gs_412386 = s_1011_0;
        // N s_1011_2: jump b1008
        return block_1008(state, tracer, fn_state);
    }
    fn block_1012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1012_0: const #4s : i
        let s_1012_0: i128 = 4;
        // D s_1012_1: read-var u#34085:u32
        let s_1012_1: u32 = fn_state.u_34085;
        // D s_1012_2: cast zx s_1012_1 -> bv
        let s_1012_2: Bits = Bits::new(s_1012_1 as u128, 32u16);
        // C s_1012_3: const #1s : i64
        let s_1012_3: i64 = 1;
        // C s_1012_4: cast zx s_1012_3 -> i
        let s_1012_4: i128 = (i128::try_from(s_1012_3).unwrap());
        // C s_1012_5: const #0s : i
        let s_1012_5: i128 = 0;
        // C s_1012_6: add s_1012_5 s_1012_4
        let s_1012_6: i128 = (s_1012_5 + s_1012_4);
        // D s_1012_7: bit-extract s_1012_2 s_1012_0 s_1012_6
        let s_1012_7: Bits = (Bits::new(
            ((s_1012_2) >> (s_1012_0)).value(),
            u16::try_from(s_1012_6).unwrap(),
        ));
        // D s_1012_8: cast reint s_1012_7 -> u8
        let s_1012_8: bool = ((s_1012_7.value()) != 0);
        // D s_1012_9: cast zx s_1012_8 -> bv
        let s_1012_9: Bits = Bits::new(s_1012_8 as u128, 1u16);
        // C s_1012_10: const #0u : u8
        let s_1012_10: bool = false;
        // C s_1012_11: cast zx s_1012_10 -> bv
        let s_1012_11: Bits = Bits::new(s_1012_10 as u128, 1u16);
        // D s_1012_12: cmp-eq s_1012_9 s_1012_11
        let s_1012_12: bool = ((s_1012_9) == (s_1012_11));
        // D s_1012_13: write-var gs#412385 <= s_1012_12
        fn_state.gs_412385 = s_1012_12;
        // N s_1012_14: jump b1011
        return block_1011(state, tracer, fn_state);
    }
    fn block_1013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1013_0: const #28s : i
        let s_1013_0: i128 = 28;
        // C s_1013_1: const #4s : i
        let s_1013_1: i128 = 4;
        // D s_1013_2: read-var u#34078:u32
        let s_1013_2: u32 = fn_state.u_34078;
        // D s_1013_3: cast zx s_1013_2 -> bv
        let s_1013_3: Bits = Bits::new(s_1013_2 as u128, 32u16);
        // D s_1013_4: bit-extract s_1013_3 s_1013_0 s_1013_1
        let s_1013_4: Bits = (Bits::new(
            ((s_1013_3) >> (s_1013_0)).value(),
            u16::try_from(s_1013_1).unwrap(),
        ));
        // D s_1013_5: cast reint s_1013_4 -> u8
        let s_1013_5: u8 = (s_1013_4.value() as u8);
        // D s_1013_6: cast zx s_1013_5 -> bv
        let s_1013_6: Bits = Bits::new(s_1013_5 as u128, 4u16);
        // C s_1013_7: const #15u : u8
        let s_1013_7: u8 = 15;
        // C s_1013_8: cast zx s_1013_7 -> bv
        let s_1013_8: Bits = Bits::new(s_1013_7 as u128, 4u16);
        // D s_1013_9: cmp-ne s_1013_6 s_1013_8
        let s_1013_9: bool = ((s_1013_6) != (s_1013_8));
        // N s_1013_10: branch s_1013_9 b1016 b1014
        if s_1013_9 {
            return block_1016(state, tracer, fn_state);
        } else {
            return block_1014(state, tracer, fn_state);
        };
    }
    fn block_1014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1014_0: const #0u : u8
        let s_1014_0: bool = false;
        // D s_1014_1: write-var gs#412347 <= s_1014_0
        fn_state.gs_412347 = s_1014_0;
        // N s_1014_2: jump b1015
        return block_1015(state, tracer, fn_state);
    }
    fn block_1015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1015_0: read-var gs#412347:u8
        let s_1015_0: bool = fn_state.gs_412347;
        // D s_1015_1: write-var gs#412348 <= s_1015_0
        fn_state.gs_412348 = s_1015_0;
        // N s_1015_2: jump b118
        return block_118(state, tracer, fn_state);
    }
    fn block_1016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1016_0: const #3434s : i
        let s_1016_0: i128 = 3434;
        // C s_1016_1: const #14696u : u32
        let s_1016_1: u32 = 14696;
        // D s_1016_2: read-reg s_1016_1:i
        let s_1016_2: i128 = {
            let value = state.read_register::<i128>(s_1016_1 as isize);
            tracer.read_register(s_1016_1 as isize, value);
            value
        };
        // D s_1016_3: cmp-lt s_1016_2 s_1016_0
        let s_1016_3: bool = ((s_1016_2) < (s_1016_0));
        // D s_1016_4: write-var gs#412347 <= s_1016_3
        fn_state.gs_412347 = s_1016_3;
        // N s_1016_5: jump b1015
        return block_1015(state, tracer, fn_state);
    }
    fn block_1017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1017_0: const #20s : i
        let s_1017_0: i128 = 20;
        // D s_1017_1: read-var u#34078:u32
        let s_1017_1: u32 = fn_state.u_34078;
        // D s_1017_2: cast zx s_1017_1 -> bv
        let s_1017_2: Bits = Bits::new(s_1017_1 as u128, 32u16);
        // C s_1017_3: const #1s : i64
        let s_1017_3: i64 = 1;
        // C s_1017_4: cast zx s_1017_3 -> i
        let s_1017_4: i128 = (i128::try_from(s_1017_3).unwrap());
        // C s_1017_5: const #0s : i
        let s_1017_5: i128 = 0;
        // C s_1017_6: add s_1017_5 s_1017_4
        let s_1017_6: i128 = (s_1017_5 + s_1017_4);
        // D s_1017_7: bit-extract s_1017_2 s_1017_0 s_1017_6
        let s_1017_7: Bits = (Bits::new(
            ((s_1017_2) >> (s_1017_0)).value(),
            u16::try_from(s_1017_6).unwrap(),
        ));
        // D s_1017_8: cast reint s_1017_7 -> u8
        let s_1017_8: bool = ((s_1017_7.value()) != 0);
        // D s_1017_9: cast zx s_1017_8 -> bv
        let s_1017_9: Bits = Bits::new(s_1017_8 as u128, 1u16);
        // C s_1017_10: const #0u : u8
        let s_1017_10: bool = false;
        // C s_1017_11: cast zx s_1017_10 -> bv
        let s_1017_11: Bits = Bits::new(s_1017_10 as u128, 1u16);
        // D s_1017_12: cmp-eq s_1017_9 s_1017_11
        let s_1017_12: bool = ((s_1017_9) == (s_1017_11));
        // N s_1017_13: branch s_1017_12 b1020 b1018
        if s_1017_12 {
            return block_1020(state, tracer, fn_state);
        } else {
            return block_1018(state, tracer, fn_state);
        };
    }
    fn block_1018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1018_0: const #0u : u8
        let s_1018_0: bool = false;
        // D s_1018_1: write-var gs#412342 <= s_1018_0
        fn_state.gs_412342 = s_1018_0;
        // N s_1018_2: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1019_0: read-var gs#412342:u8
        let s_1019_0: bool = fn_state.gs_412342;
        // D s_1019_1: write-var gs#412343 <= s_1019_0
        fn_state.gs_412343 = s_1019_0;
        // N s_1019_2: jump b116
        return block_116(state, tracer, fn_state);
    }
    fn block_1020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1020_0: const #8s : i
        let s_1020_0: i128 = 8;
        // D s_1020_1: read-var u#34078:u32
        let s_1020_1: u32 = fn_state.u_34078;
        // D s_1020_2: cast zx s_1020_1 -> bv
        let s_1020_2: Bits = Bits::new(s_1020_1 as u128, 32u16);
        // C s_1020_3: const #1s : i64
        let s_1020_3: i64 = 1;
        // C s_1020_4: cast zx s_1020_3 -> i
        let s_1020_4: i128 = (i128::try_from(s_1020_3).unwrap());
        // C s_1020_5: const #3s : i
        let s_1020_5: i128 = 3;
        // C s_1020_6: add s_1020_5 s_1020_4
        let s_1020_6: i128 = (s_1020_5 + s_1020_4);
        // D s_1020_7: bit-extract s_1020_2 s_1020_0 s_1020_6
        let s_1020_7: Bits = (Bits::new(
            ((s_1020_2) >> (s_1020_0)).value(),
            u16::try_from(s_1020_6).unwrap(),
        ));
        // D s_1020_8: cast reint s_1020_7 -> u8
        let s_1020_8: u8 = (s_1020_7.value() as u8);
        // D s_1020_9: cast zx s_1020_8 -> bv
        let s_1020_9: Bits = Bits::new(s_1020_8 as u128, 4u16);
        // C s_1020_10: const #11u : u8
        let s_1020_10: u8 = 11;
        // C s_1020_11: cast zx s_1020_10 -> bv
        let s_1020_11: Bits = Bits::new(s_1020_10 as u128, 4u16);
        // D s_1020_12: cmp-eq s_1020_9 s_1020_11
        let s_1020_12: bool = ((s_1020_9) == (s_1020_11));
        // N s_1020_13: branch s_1020_12 b1023 b1021
        if s_1020_12 {
            return block_1023(state, tracer, fn_state);
        } else {
            return block_1021(state, tracer, fn_state);
        };
    }
    fn block_1021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1021_0: const #0u : u8
        let s_1021_0: bool = false;
        // D s_1021_1: write-var gs#412341 <= s_1021_0
        fn_state.gs_412341 = s_1021_0;
        // N s_1021_2: jump b1022
        return block_1022(state, tracer, fn_state);
    }
    fn block_1022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1022_0: read-var gs#412341:u8
        let s_1022_0: bool = fn_state.gs_412341;
        // D s_1022_1: write-var gs#412342 <= s_1022_0
        fn_state.gs_412342 = s_1022_0;
        // N s_1022_2: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1023_0: const #6s : i
        let s_1023_0: i128 = 6;
        // D s_1023_1: read-var u#34078:u32
        let s_1023_1: u32 = fn_state.u_34078;
        // D s_1023_2: cast zx s_1023_1 -> bv
        let s_1023_2: Bits = Bits::new(s_1023_1 as u128, 32u16);
        // C s_1023_3: const #1s : i64
        let s_1023_3: i64 = 1;
        // C s_1023_4: cast zx s_1023_3 -> i
        let s_1023_4: i128 = (i128::try_from(s_1023_3).unwrap());
        // C s_1023_5: const #0s : i
        let s_1023_5: i128 = 0;
        // C s_1023_6: add s_1023_5 s_1023_4
        let s_1023_6: i128 = (s_1023_5 + s_1023_4);
        // D s_1023_7: bit-extract s_1023_2 s_1023_0 s_1023_6
        let s_1023_7: Bits = (Bits::new(
            ((s_1023_2) >> (s_1023_0)).value(),
            u16::try_from(s_1023_6).unwrap(),
        ));
        // D s_1023_8: cast reint s_1023_7 -> u8
        let s_1023_8: bool = ((s_1023_7.value()) != 0);
        // D s_1023_9: cast zx s_1023_8 -> bv
        let s_1023_9: Bits = Bits::new(s_1023_8 as u128, 1u16);
        // C s_1023_10: const #0u : u8
        let s_1023_10: bool = false;
        // C s_1023_11: cast zx s_1023_10 -> bv
        let s_1023_11: Bits = Bits::new(s_1023_10 as u128, 1u16);
        // D s_1023_12: cmp-eq s_1023_9 s_1023_11
        let s_1023_12: bool = ((s_1023_9) == (s_1023_11));
        // N s_1023_13: branch s_1023_12 b1026 b1024
        if s_1023_12 {
            return block_1026(state, tracer, fn_state);
        } else {
            return block_1024(state, tracer, fn_state);
        };
    }
    fn block_1024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1024_0: const #0u : u8
        let s_1024_0: bool = false;
        // D s_1024_1: write-var gs#412340 <= s_1024_0
        fn_state.gs_412340 = s_1024_0;
        // N s_1024_2: jump b1025
        return block_1025(state, tracer, fn_state);
    }
    fn block_1025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1025_0: read-var gs#412340:u8
        let s_1025_0: bool = fn_state.gs_412340;
        // D s_1025_1: write-var gs#412341 <= s_1025_0
        fn_state.gs_412341 = s_1025_0;
        // N s_1025_2: jump b1022
        return block_1022(state, tracer, fn_state);
    }
    fn block_1026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1026_0: const #0s : i
        let s_1026_0: i128 = 0;
        // D s_1026_1: read-var u#34078:u32
        let s_1026_1: u32 = fn_state.u_34078;
        // D s_1026_2: cast zx s_1026_1 -> bv
        let s_1026_2: Bits = Bits::new(s_1026_1 as u128, 32u16);
        // C s_1026_3: const #1s : i64
        let s_1026_3: i64 = 1;
        // C s_1026_4: cast zx s_1026_3 -> i
        let s_1026_4: i128 = (i128::try_from(s_1026_3).unwrap());
        // C s_1026_5: const #4s : i
        let s_1026_5: i128 = 4;
        // C s_1026_6: add s_1026_5 s_1026_4
        let s_1026_6: i128 = (s_1026_5 + s_1026_4);
        // D s_1026_7: bit-extract s_1026_2 s_1026_0 s_1026_6
        let s_1026_7: Bits = (Bits::new(
            ((s_1026_2) >> (s_1026_0)).value(),
            u16::try_from(s_1026_6).unwrap(),
        ));
        // D s_1026_8: cast reint s_1026_7 -> u8
        let s_1026_8: u8 = (s_1026_7.value() as u8);
        // D s_1026_9: cast zx s_1026_8 -> bv
        let s_1026_9: Bits = Bits::new(s_1026_8 as u128, 5u16);
        // C s_1026_10: const #16u : u8
        let s_1026_10: u8 = 16;
        // C s_1026_11: cast zx s_1026_10 -> bv
        let s_1026_11: Bits = Bits::new(s_1026_10 as u128, 5u16);
        // D s_1026_12: cmp-eq s_1026_9 s_1026_11
        let s_1026_12: bool = ((s_1026_9) == (s_1026_11));
        // D s_1026_13: write-var gs#412340 <= s_1026_12
        fn_state.gs_412340 = s_1026_12;
        // N s_1026_14: jump b1025
        return block_1025(state, tracer, fn_state);
    }
    fn block_1027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1027_0: const #28s : i
        let s_1027_0: i128 = 28;
        // C s_1027_1: const #4s : i
        let s_1027_1: i128 = 4;
        // D s_1027_2: read-var u#34068:u32
        let s_1027_2: u32 = fn_state.u_34068;
        // D s_1027_3: cast zx s_1027_2 -> bv
        let s_1027_3: Bits = Bits::new(s_1027_2 as u128, 32u16);
        // D s_1027_4: bit-extract s_1027_3 s_1027_0 s_1027_1
        let s_1027_4: Bits = (Bits::new(
            ((s_1027_3) >> (s_1027_0)).value(),
            u16::try_from(s_1027_1).unwrap(),
        ));
        // D s_1027_5: cast reint s_1027_4 -> u8
        let s_1027_5: u8 = (s_1027_4.value() as u8);
        // D s_1027_6: cast zx s_1027_5 -> bv
        let s_1027_6: Bits = Bits::new(s_1027_5 as u128, 4u16);
        // C s_1027_7: const #15u : u8
        let s_1027_7: u8 = 15;
        // C s_1027_8: cast zx s_1027_7 -> bv
        let s_1027_8: Bits = Bits::new(s_1027_7 as u128, 4u16);
        // D s_1027_9: cmp-ne s_1027_6 s_1027_8
        let s_1027_9: bool = ((s_1027_6) != (s_1027_8));
        // N s_1027_10: branch s_1027_9 b1030 b1028
        if s_1027_9 {
            return block_1030(state, tracer, fn_state);
        } else {
            return block_1028(state, tracer, fn_state);
        };
    }
    fn block_1028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1028_0: const #0u : u8
        let s_1028_0: bool = false;
        // D s_1028_1: write-var gs#412309 <= s_1028_0
        fn_state.gs_412309 = s_1028_0;
        // N s_1028_2: jump b1029
        return block_1029(state, tracer, fn_state);
    }
    fn block_1029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1029_0: read-var gs#412309:u8
        let s_1029_0: bool = fn_state.gs_412309;
        // D s_1029_1: write-var gs#412310 <= s_1029_0
        fn_state.gs_412310 = s_1029_0;
        // N s_1029_2: jump b112
        return block_112(state, tracer, fn_state);
    }
    fn block_1030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1030_0: const #3432s : i
        let s_1030_0: i128 = 3432;
        // C s_1030_1: const #14696u : u32
        let s_1030_1: u32 = 14696;
        // D s_1030_2: read-reg s_1030_1:i
        let s_1030_2: i128 = {
            let value = state.read_register::<i128>(s_1030_1 as isize);
            tracer.read_register(s_1030_1 as isize, value);
            value
        };
        // D s_1030_3: cmp-lt s_1030_2 s_1030_0
        let s_1030_3: bool = ((s_1030_2) < (s_1030_0));
        // D s_1030_4: write-var gs#412309 <= s_1030_3
        fn_state.gs_412309 = s_1030_3;
        // N s_1030_5: jump b1029
        return block_1029(state, tracer, fn_state);
    }
    fn block_1031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1031_0: const #20s : i
        let s_1031_0: i128 = 20;
        // D s_1031_1: read-var u#34068:u32
        let s_1031_1: u32 = fn_state.u_34068;
        // D s_1031_2: cast zx s_1031_1 -> bv
        let s_1031_2: Bits = Bits::new(s_1031_1 as u128, 32u16);
        // C s_1031_3: const #1s : i64
        let s_1031_3: i64 = 1;
        // C s_1031_4: cast zx s_1031_3 -> i
        let s_1031_4: i128 = (i128::try_from(s_1031_3).unwrap());
        // C s_1031_5: const #1s : i
        let s_1031_5: i128 = 1;
        // C s_1031_6: add s_1031_5 s_1031_4
        let s_1031_6: i128 = (s_1031_5 + s_1031_4);
        // D s_1031_7: bit-extract s_1031_2 s_1031_0 s_1031_6
        let s_1031_7: Bits = (Bits::new(
            ((s_1031_2) >> (s_1031_0)).value(),
            u16::try_from(s_1031_6).unwrap(),
        ));
        // D s_1031_8: cast reint s_1031_7 -> u8
        let s_1031_8: u8 = (s_1031_7.value() as u8);
        // D s_1031_9: cast zx s_1031_8 -> bv
        let s_1031_9: Bits = Bits::new(s_1031_8 as u128, 2u16);
        // C s_1031_10: const #0u : u8
        let s_1031_10: u8 = 0;
        // C s_1031_11: cast zx s_1031_10 -> bv
        let s_1031_11: Bits = Bits::new(s_1031_10 as u128, 2u16);
        // D s_1031_12: cmp-eq s_1031_9 s_1031_11
        let s_1031_12: bool = ((s_1031_9) == (s_1031_11));
        // N s_1031_13: branch s_1031_12 b1034 b1032
        if s_1031_12 {
            return block_1034(state, tracer, fn_state);
        } else {
            return block_1032(state, tracer, fn_state);
        };
    }
    fn block_1032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1032_0: const #0u : u8
        let s_1032_0: bool = false;
        // D s_1032_1: write-var gs#412304 <= s_1032_0
        fn_state.gs_412304 = s_1032_0;
        // N s_1032_2: jump b1033
        return block_1033(state, tracer, fn_state);
    }
    fn block_1033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1033_0: read-var gs#412304:u8
        let s_1033_0: bool = fn_state.gs_412304;
        // D s_1033_1: write-var gs#412305 <= s_1033_0
        fn_state.gs_412305 = s_1033_0;
        // N s_1033_2: jump b110
        return block_110(state, tracer, fn_state);
    }
    fn block_1034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1034_0: const #10s : i
        let s_1034_0: i128 = 10;
        // D s_1034_1: read-var u#34068:u32
        let s_1034_1: u32 = fn_state.u_34068;
        // D s_1034_2: cast zx s_1034_1 -> bv
        let s_1034_2: Bits = Bits::new(s_1034_1 as u128, 32u16);
        // C s_1034_3: const #1s : i64
        let s_1034_3: i64 = 1;
        // C s_1034_4: cast zx s_1034_3 -> i
        let s_1034_4: i128 = (i128::try_from(s_1034_3).unwrap());
        // C s_1034_5: const #1s : i
        let s_1034_5: i128 = 1;
        // C s_1034_6: add s_1034_5 s_1034_4
        let s_1034_6: i128 = (s_1034_5 + s_1034_4);
        // D s_1034_7: bit-extract s_1034_2 s_1034_0 s_1034_6
        let s_1034_7: Bits = (Bits::new(
            ((s_1034_2) >> (s_1034_0)).value(),
            u16::try_from(s_1034_6).unwrap(),
        ));
        // D s_1034_8: cast reint s_1034_7 -> u8
        let s_1034_8: u8 = (s_1034_7.value() as u8);
        // D s_1034_9: cast zx s_1034_8 -> bv
        let s_1034_9: Bits = Bits::new(s_1034_8 as u128, 2u16);
        // C s_1034_10: const #2u : u8
        let s_1034_10: u8 = 2;
        // C s_1034_11: cast zx s_1034_10 -> bv
        let s_1034_11: Bits = Bits::new(s_1034_10 as u128, 2u16);
        // D s_1034_12: cmp-eq s_1034_9 s_1034_11
        let s_1034_12: bool = ((s_1034_9) == (s_1034_11));
        // N s_1034_13: branch s_1034_12 b1037 b1035
        if s_1034_12 {
            return block_1037(state, tracer, fn_state);
        } else {
            return block_1035(state, tracer, fn_state);
        };
    }
    fn block_1035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1035_0: const #0u : u8
        let s_1035_0: bool = false;
        // D s_1035_1: write-var gs#412303 <= s_1035_0
        fn_state.gs_412303 = s_1035_0;
        // N s_1035_2: jump b1036
        return block_1036(state, tracer, fn_state);
    }
    fn block_1036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1036_0: read-var gs#412303:u8
        let s_1036_0: bool = fn_state.gs_412303;
        // D s_1036_1: write-var gs#412304 <= s_1036_0
        fn_state.gs_412304 = s_1036_0;
        // N s_1036_2: jump b1033
        return block_1033(state, tracer, fn_state);
    }
    fn block_1037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1037_0: const #6s : i
        let s_1037_0: i128 = 6;
        // D s_1037_1: read-var u#34068:u32
        let s_1037_1: u32 = fn_state.u_34068;
        // D s_1037_2: cast zx s_1037_1 -> bv
        let s_1037_2: Bits = Bits::new(s_1037_1 as u128, 32u16);
        // C s_1037_3: const #1s : i64
        let s_1037_3: i64 = 1;
        // C s_1037_4: cast zx s_1037_3 -> i
        let s_1037_4: i128 = (i128::try_from(s_1037_3).unwrap());
        // C s_1037_5: const #0s : i
        let s_1037_5: i128 = 0;
        // C s_1037_6: add s_1037_5 s_1037_4
        let s_1037_6: i128 = (s_1037_5 + s_1037_4);
        // D s_1037_7: bit-extract s_1037_2 s_1037_0 s_1037_6
        let s_1037_7: Bits = (Bits::new(
            ((s_1037_2) >> (s_1037_0)).value(),
            u16::try_from(s_1037_6).unwrap(),
        ));
        // D s_1037_8: cast reint s_1037_7 -> u8
        let s_1037_8: bool = ((s_1037_7.value()) != 0);
        // D s_1037_9: cast zx s_1037_8 -> bv
        let s_1037_9: Bits = Bits::new(s_1037_8 as u128, 1u16);
        // C s_1037_10: const #0u : u8
        let s_1037_10: bool = false;
        // C s_1037_11: cast zx s_1037_10 -> bv
        let s_1037_11: Bits = Bits::new(s_1037_10 as u128, 1u16);
        // D s_1037_12: cmp-eq s_1037_9 s_1037_11
        let s_1037_12: bool = ((s_1037_9) == (s_1037_11));
        // N s_1037_13: branch s_1037_12 b1040 b1038
        if s_1037_12 {
            return block_1040(state, tracer, fn_state);
        } else {
            return block_1038(state, tracer, fn_state);
        };
    }
    fn block_1038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1038_0: const #0u : u8
        let s_1038_0: bool = false;
        // D s_1038_1: write-var gs#412302 <= s_1038_0
        fn_state.gs_412302 = s_1038_0;
        // N s_1038_2: jump b1039
        return block_1039(state, tracer, fn_state);
    }
    fn block_1039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1039_0: read-var gs#412302:u8
        let s_1039_0: bool = fn_state.gs_412302;
        // D s_1039_1: write-var gs#412303 <= s_1039_0
        fn_state.gs_412303 = s_1039_0;
        // N s_1039_2: jump b1036
        return block_1036(state, tracer, fn_state);
    }
    fn block_1040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1040_0: const #4s : i
        let s_1040_0: i128 = 4;
        // D s_1040_1: read-var u#34068:u32
        let s_1040_1: u32 = fn_state.u_34068;
        // D s_1040_2: cast zx s_1040_1 -> bv
        let s_1040_2: Bits = Bits::new(s_1040_1 as u128, 32u16);
        // C s_1040_3: const #1s : i64
        let s_1040_3: i64 = 1;
        // C s_1040_4: cast zx s_1040_3 -> i
        let s_1040_4: i128 = (i128::try_from(s_1040_3).unwrap());
        // C s_1040_5: const #0s : i
        let s_1040_5: i128 = 0;
        // C s_1040_6: add s_1040_5 s_1040_4
        let s_1040_6: i128 = (s_1040_5 + s_1040_4);
        // D s_1040_7: bit-extract s_1040_2 s_1040_0 s_1040_6
        let s_1040_7: Bits = (Bits::new(
            ((s_1040_2) >> (s_1040_0)).value(),
            u16::try_from(s_1040_6).unwrap(),
        ));
        // D s_1040_8: cast reint s_1040_7 -> u8
        let s_1040_8: bool = ((s_1040_7.value()) != 0);
        // D s_1040_9: cast zx s_1040_8 -> bv
        let s_1040_9: Bits = Bits::new(s_1040_8 as u128, 1u16);
        // C s_1040_10: const #0u : u8
        let s_1040_10: bool = false;
        // C s_1040_11: cast zx s_1040_10 -> bv
        let s_1040_11: Bits = Bits::new(s_1040_10 as u128, 1u16);
        // D s_1040_12: cmp-eq s_1040_9 s_1040_11
        let s_1040_12: bool = ((s_1040_9) == (s_1040_11));
        // D s_1040_13: write-var gs#412302 <= s_1040_12
        fn_state.gs_412302 = s_1040_12;
        // N s_1040_14: jump b1039
        return block_1039(state, tracer, fn_state);
    }
    fn block_1041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1041_0: const #28s : i
        let s_1041_0: i128 = 28;
        // C s_1041_1: const #4s : i
        let s_1041_1: i128 = 4;
        // D s_1041_2: read-var u#34061:u32
        let s_1041_2: u32 = fn_state.u_34061;
        // D s_1041_3: cast zx s_1041_2 -> bv
        let s_1041_3: Bits = Bits::new(s_1041_2 as u128, 32u16);
        // D s_1041_4: bit-extract s_1041_3 s_1041_0 s_1041_1
        let s_1041_4: Bits = (Bits::new(
            ((s_1041_3) >> (s_1041_0)).value(),
            u16::try_from(s_1041_1).unwrap(),
        ));
        // D s_1041_5: cast reint s_1041_4 -> u8
        let s_1041_5: u8 = (s_1041_4.value() as u8);
        // D s_1041_6: cast zx s_1041_5 -> bv
        let s_1041_6: Bits = Bits::new(s_1041_5 as u128, 4u16);
        // C s_1041_7: const #15u : u8
        let s_1041_7: u8 = 15;
        // C s_1041_8: cast zx s_1041_7 -> bv
        let s_1041_8: Bits = Bits::new(s_1041_7 as u128, 4u16);
        // D s_1041_9: cmp-ne s_1041_6 s_1041_8
        let s_1041_9: bool = ((s_1041_6) != (s_1041_8));
        // N s_1041_10: branch s_1041_9 b1044 b1042
        if s_1041_9 {
            return block_1044(state, tracer, fn_state);
        } else {
            return block_1042(state, tracer, fn_state);
        };
    }
    fn block_1042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1042_0: const #0u : u8
        let s_1042_0: bool = false;
        // D s_1042_1: write-var gs#412269 <= s_1042_0
        fn_state.gs_412269 = s_1042_0;
        // N s_1042_2: jump b1043
        return block_1043(state, tracer, fn_state);
    }
    fn block_1043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1043_0: read-var gs#412269:u8
        let s_1043_0: bool = fn_state.gs_412269;
        // D s_1043_1: write-var gs#412270 <= s_1043_0
        fn_state.gs_412270 = s_1043_0;
        // N s_1043_2: jump b106
        return block_106(state, tracer, fn_state);
    }
    fn block_1044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1044_0: const #3430s : i
        let s_1044_0: i128 = 3430;
        // C s_1044_1: const #14696u : u32
        let s_1044_1: u32 = 14696;
        // D s_1044_2: read-reg s_1044_1:i
        let s_1044_2: i128 = {
            let value = state.read_register::<i128>(s_1044_1 as isize);
            tracer.read_register(s_1044_1 as isize, value);
            value
        };
        // D s_1044_3: cmp-lt s_1044_2 s_1044_0
        let s_1044_3: bool = ((s_1044_2) < (s_1044_0));
        // D s_1044_4: write-var gs#412269 <= s_1044_3
        fn_state.gs_412269 = s_1044_3;
        // N s_1044_5: jump b1043
        return block_1043(state, tracer, fn_state);
    }
    fn block_1045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1045_0: const #19s : i
        let s_1045_0: i128 = 19;
        // D s_1045_1: read-var u#34061:u32
        let s_1045_1: u32 = fn_state.u_34061;
        // D s_1045_2: cast zx s_1045_1 -> bv
        let s_1045_2: Bits = Bits::new(s_1045_1 as u128, 32u16);
        // C s_1045_3: const #1s : i64
        let s_1045_3: i64 = 1;
        // C s_1045_4: cast zx s_1045_3 -> i
        let s_1045_4: i128 = (i128::try_from(s_1045_3).unwrap());
        // C s_1045_5: const #2s : i
        let s_1045_5: i128 = 2;
        // C s_1045_6: add s_1045_5 s_1045_4
        let s_1045_6: i128 = (s_1045_5 + s_1045_4);
        // D s_1045_7: bit-extract s_1045_2 s_1045_0 s_1045_6
        let s_1045_7: Bits = (Bits::new(
            ((s_1045_2) >> (s_1045_0)).value(),
            u16::try_from(s_1045_6).unwrap(),
        ));
        // D s_1045_8: cast reint s_1045_7 -> u8
        let s_1045_8: u8 = (s_1045_7.value() as u8);
        // D s_1045_9: cast zx s_1045_8 -> bv
        let s_1045_9: Bits = Bits::new(s_1045_8 as u128, 3u16);
        // C s_1045_10: const #7u : u8
        let s_1045_10: u8 = 7;
        // C s_1045_11: cast zx s_1045_10 -> bv
        let s_1045_11: Bits = Bits::new(s_1045_10 as u128, 3u16);
        // D s_1045_12: cmp-eq s_1045_9 s_1045_11
        let s_1045_12: bool = ((s_1045_9) == (s_1045_11));
        // N s_1045_13: branch s_1045_12 b1048 b1046
        if s_1045_12 {
            return block_1048(state, tracer, fn_state);
        } else {
            return block_1046(state, tracer, fn_state);
        };
    }
    fn block_1046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1046_0: const #0u : u8
        let s_1046_0: bool = false;
        // D s_1046_1: write-var gs#412264 <= s_1046_0
        fn_state.gs_412264 = s_1046_0;
        // N s_1046_2: jump b1047
        return block_1047(state, tracer, fn_state);
    }
    fn block_1047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1047_0: read-var gs#412264:u8
        let s_1047_0: bool = fn_state.gs_412264;
        // D s_1047_1: write-var gs#412265 <= s_1047_0
        fn_state.gs_412265 = s_1047_0;
        // N s_1047_2: jump b104
        return block_104(state, tracer, fn_state);
    }
    fn block_1048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1048_0: const #17s : i
        let s_1048_0: i128 = 17;
        // D s_1048_1: read-var u#34061:u32
        let s_1048_1: u32 = fn_state.u_34061;
        // D s_1048_2: cast zx s_1048_1 -> bv
        let s_1048_2: Bits = Bits::new(s_1048_1 as u128, 32u16);
        // C s_1048_3: const #1s : i64
        let s_1048_3: i64 = 1;
        // C s_1048_4: cast zx s_1048_3 -> i
        let s_1048_4: i128 = (i128::try_from(s_1048_3).unwrap());
        // C s_1048_5: const #0s : i
        let s_1048_5: i128 = 0;
        // C s_1048_6: add s_1048_5 s_1048_4
        let s_1048_6: i128 = (s_1048_5 + s_1048_4);
        // D s_1048_7: bit-extract s_1048_2 s_1048_0 s_1048_6
        let s_1048_7: Bits = (Bits::new(
            ((s_1048_2) >> (s_1048_0)).value(),
            u16::try_from(s_1048_6).unwrap(),
        ));
        // D s_1048_8: cast reint s_1048_7 -> u8
        let s_1048_8: bool = ((s_1048_7.value()) != 0);
        // D s_1048_9: cast zx s_1048_8 -> bv
        let s_1048_9: Bits = Bits::new(s_1048_8 as u128, 1u16);
        // C s_1048_10: const #1u : u8
        let s_1048_10: bool = true;
        // C s_1048_11: cast zx s_1048_10 -> bv
        let s_1048_11: Bits = Bits::new(s_1048_10 as u128, 1u16);
        // D s_1048_12: cmp-eq s_1048_9 s_1048_11
        let s_1048_12: bool = ((s_1048_9) == (s_1048_11));
        // N s_1048_13: branch s_1048_12 b1051 b1049
        if s_1048_12 {
            return block_1051(state, tracer, fn_state);
        } else {
            return block_1049(state, tracer, fn_state);
        };
    }
    fn block_1049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1049_0: const #0u : u8
        let s_1049_0: bool = false;
        // D s_1049_1: write-var gs#412263 <= s_1049_0
        fn_state.gs_412263 = s_1049_0;
        // N s_1049_2: jump b1050
        return block_1050(state, tracer, fn_state);
    }
    fn block_1050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1050_0: read-var gs#412263:u8
        let s_1050_0: bool = fn_state.gs_412263;
        // D s_1050_1: write-var gs#412264 <= s_1050_0
        fn_state.gs_412264 = s_1050_0;
        // N s_1050_2: jump b1047
        return block_1047(state, tracer, fn_state);
    }
    fn block_1051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1051_0: const #10s : i
        let s_1051_0: i128 = 10;
        // D s_1051_1: read-var u#34061:u32
        let s_1051_1: u32 = fn_state.u_34061;
        // D s_1051_2: cast zx s_1051_1 -> bv
        let s_1051_2: Bits = Bits::new(s_1051_1 as u128, 32u16);
        // C s_1051_3: const #1s : i64
        let s_1051_3: i64 = 1;
        // C s_1051_4: cast zx s_1051_3 -> i
        let s_1051_4: i128 = (i128::try_from(s_1051_3).unwrap());
        // C s_1051_5: const #1s : i
        let s_1051_5: i128 = 1;
        // C s_1051_6: add s_1051_5 s_1051_4
        let s_1051_6: i128 = (s_1051_5 + s_1051_4);
        // D s_1051_7: bit-extract s_1051_2 s_1051_0 s_1051_6
        let s_1051_7: Bits = (Bits::new(
            ((s_1051_2) >> (s_1051_0)).value(),
            u16::try_from(s_1051_6).unwrap(),
        ));
        // D s_1051_8: cast reint s_1051_7 -> u8
        let s_1051_8: u8 = (s_1051_7.value() as u8);
        // D s_1051_9: cast zx s_1051_8 -> bv
        let s_1051_9: Bits = Bits::new(s_1051_8 as u128, 2u16);
        // C s_1051_10: const #2u : u8
        let s_1051_10: u8 = 2;
        // C s_1051_11: cast zx s_1051_10 -> bv
        let s_1051_11: Bits = Bits::new(s_1051_10 as u128, 2u16);
        // D s_1051_12: cmp-eq s_1051_9 s_1051_11
        let s_1051_12: bool = ((s_1051_9) == (s_1051_11));
        // N s_1051_13: branch s_1051_12 b1054 b1052
        if s_1051_12 {
            return block_1054(state, tracer, fn_state);
        } else {
            return block_1052(state, tracer, fn_state);
        };
    }
    fn block_1052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1052_0: const #0u : u8
        let s_1052_0: bool = false;
        // D s_1052_1: write-var gs#412262 <= s_1052_0
        fn_state.gs_412262 = s_1052_0;
        // N s_1052_2: jump b1053
        return block_1053(state, tracer, fn_state);
    }
    fn block_1053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1053_0: read-var gs#412262:u8
        let s_1053_0: bool = fn_state.gs_412262;
        // D s_1053_1: write-var gs#412263 <= s_1053_0
        fn_state.gs_412263 = s_1053_0;
        // N s_1053_2: jump b1050
        return block_1050(state, tracer, fn_state);
    }
    fn block_1054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1054_0: const #6s : i
        let s_1054_0: i128 = 6;
        // D s_1054_1: read-var u#34061:u32
        let s_1054_1: u32 = fn_state.u_34061;
        // D s_1054_2: cast zx s_1054_1 -> bv
        let s_1054_2: Bits = Bits::new(s_1054_1 as u128, 32u16);
        // C s_1054_3: const #1s : i64
        let s_1054_3: i64 = 1;
        // C s_1054_4: cast zx s_1054_3 -> i
        let s_1054_4: i128 = (i128::try_from(s_1054_3).unwrap());
        // C s_1054_5: const #0s : i
        let s_1054_5: i128 = 0;
        // C s_1054_6: add s_1054_5 s_1054_4
        let s_1054_6: i128 = (s_1054_5 + s_1054_4);
        // D s_1054_7: bit-extract s_1054_2 s_1054_0 s_1054_6
        let s_1054_7: Bits = (Bits::new(
            ((s_1054_2) >> (s_1054_0)).value(),
            u16::try_from(s_1054_6).unwrap(),
        ));
        // D s_1054_8: cast reint s_1054_7 -> u8
        let s_1054_8: bool = ((s_1054_7.value()) != 0);
        // D s_1054_9: cast zx s_1054_8 -> bv
        let s_1054_9: Bits = Bits::new(s_1054_8 as u128, 1u16);
        // C s_1054_10: const #1u : u8
        let s_1054_10: bool = true;
        // C s_1054_11: cast zx s_1054_10 -> bv
        let s_1054_11: Bits = Bits::new(s_1054_10 as u128, 1u16);
        // D s_1054_12: cmp-eq s_1054_9 s_1054_11
        let s_1054_12: bool = ((s_1054_9) == (s_1054_11));
        // N s_1054_13: branch s_1054_12 b1057 b1055
        if s_1054_12 {
            return block_1057(state, tracer, fn_state);
        } else {
            return block_1055(state, tracer, fn_state);
        };
    }
    fn block_1055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1055_0: const #0u : u8
        let s_1055_0: bool = false;
        // D s_1055_1: write-var gs#412261 <= s_1055_0
        fn_state.gs_412261 = s_1055_0;
        // N s_1055_2: jump b1056
        return block_1056(state, tracer, fn_state);
    }
    fn block_1056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1056_0: read-var gs#412261:u8
        let s_1056_0: bool = fn_state.gs_412261;
        // D s_1056_1: write-var gs#412262 <= s_1056_0
        fn_state.gs_412262 = s_1056_0;
        // N s_1056_2: jump b1053
        return block_1053(state, tracer, fn_state);
    }
    fn block_1057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1057_0: const #4s : i
        let s_1057_0: i128 = 4;
        // D s_1057_1: read-var u#34061:u32
        let s_1057_1: u32 = fn_state.u_34061;
        // D s_1057_2: cast zx s_1057_1 -> bv
        let s_1057_2: Bits = Bits::new(s_1057_1 as u128, 32u16);
        // C s_1057_3: const #1s : i64
        let s_1057_3: i64 = 1;
        // C s_1057_4: cast zx s_1057_3 -> i
        let s_1057_4: i128 = (i128::try_from(s_1057_3).unwrap());
        // C s_1057_5: const #0s : i
        let s_1057_5: i128 = 0;
        // C s_1057_6: add s_1057_5 s_1057_4
        let s_1057_6: i128 = (s_1057_5 + s_1057_4);
        // D s_1057_7: bit-extract s_1057_2 s_1057_0 s_1057_6
        let s_1057_7: Bits = (Bits::new(
            ((s_1057_2) >> (s_1057_0)).value(),
            u16::try_from(s_1057_6).unwrap(),
        ));
        // D s_1057_8: cast reint s_1057_7 -> u8
        let s_1057_8: bool = ((s_1057_7.value()) != 0);
        // D s_1057_9: cast zx s_1057_8 -> bv
        let s_1057_9: Bits = Bits::new(s_1057_8 as u128, 1u16);
        // C s_1057_10: const #0u : u8
        let s_1057_10: bool = false;
        // C s_1057_11: cast zx s_1057_10 -> bv
        let s_1057_11: Bits = Bits::new(s_1057_10 as u128, 1u16);
        // D s_1057_12: cmp-eq s_1057_9 s_1057_11
        let s_1057_12: bool = ((s_1057_9) == (s_1057_11));
        // D s_1057_13: write-var gs#412261 <= s_1057_12
        fn_state.gs_412261 = s_1057_12;
        // N s_1057_14: jump b1056
        return block_1056(state, tracer, fn_state);
    }
    fn block_1058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1058_0: const #28s : i
        let s_1058_0: i128 = 28;
        // C s_1058_1: const #4s : i
        let s_1058_1: i128 = 4;
        // D s_1058_2: read-var u#34051:u32
        let s_1058_2: u32 = fn_state.u_34051;
        // D s_1058_3: cast zx s_1058_2 -> bv
        let s_1058_3: Bits = Bits::new(s_1058_2 as u128, 32u16);
        // D s_1058_4: bit-extract s_1058_3 s_1058_0 s_1058_1
        let s_1058_4: Bits = (Bits::new(
            ((s_1058_3) >> (s_1058_0)).value(),
            u16::try_from(s_1058_1).unwrap(),
        ));
        // D s_1058_5: cast reint s_1058_4 -> u8
        let s_1058_5: u8 = (s_1058_4.value() as u8);
        // D s_1058_6: cast zx s_1058_5 -> bv
        let s_1058_6: Bits = Bits::new(s_1058_5 as u128, 4u16);
        // C s_1058_7: const #15u : u8
        let s_1058_7: u8 = 15;
        // C s_1058_8: cast zx s_1058_7 -> bv
        let s_1058_8: Bits = Bits::new(s_1058_7 as u128, 4u16);
        // D s_1058_9: cmp-ne s_1058_6 s_1058_8
        let s_1058_9: bool = ((s_1058_6) != (s_1058_8));
        // N s_1058_10: branch s_1058_9 b1061 b1059
        if s_1058_9 {
            return block_1061(state, tracer, fn_state);
        } else {
            return block_1059(state, tracer, fn_state);
        };
    }
    fn block_1059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1059_0: const #0u : u8
        let s_1059_0: bool = false;
        // D s_1059_1: write-var gs#412228 <= s_1059_0
        fn_state.gs_412228 = s_1059_0;
        // N s_1059_2: jump b1060
        return block_1060(state, tracer, fn_state);
    }
    fn block_1060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1060_0: read-var gs#412228:u8
        let s_1060_0: bool = fn_state.gs_412228;
        // D s_1060_1: write-var gs#412229 <= s_1060_0
        fn_state.gs_412229 = s_1060_0;
        // N s_1060_2: jump b100
        return block_100(state, tracer, fn_state);
    }
    fn block_1061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1061_0: const #3426s : i
        let s_1061_0: i128 = 3426;
        // C s_1061_1: const #14696u : u32
        let s_1061_1: u32 = 14696;
        // D s_1061_2: read-reg s_1061_1:i
        let s_1061_2: i128 = {
            let value = state.read_register::<i128>(s_1061_1 as isize);
            tracer.read_register(s_1061_1 as isize, value);
            value
        };
        // D s_1061_3: cmp-lt s_1061_2 s_1061_0
        let s_1061_3: bool = ((s_1061_2) < (s_1061_0));
        // D s_1061_4: write-var gs#412228 <= s_1061_3
        fn_state.gs_412228 = s_1061_3;
        // N s_1061_5: jump b1060
        return block_1060(state, tracer, fn_state);
    }
    fn block_1062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1062_0: const #19s : i
        let s_1062_0: i128 = 19;
        // D s_1062_1: read-var u#34051:u32
        let s_1062_1: u32 = fn_state.u_34051;
        // D s_1062_2: cast zx s_1062_1 -> bv
        let s_1062_2: Bits = Bits::new(s_1062_1 as u128, 32u16);
        // C s_1062_3: const #1s : i64
        let s_1062_3: i64 = 1;
        // C s_1062_4: cast zx s_1062_3 -> i
        let s_1062_4: i128 = (i128::try_from(s_1062_3).unwrap());
        // C s_1062_5: const #2s : i
        let s_1062_5: i128 = 2;
        // C s_1062_6: add s_1062_5 s_1062_4
        let s_1062_6: i128 = (s_1062_5 + s_1062_4);
        // D s_1062_7: bit-extract s_1062_2 s_1062_0 s_1062_6
        let s_1062_7: Bits = (Bits::new(
            ((s_1062_2) >> (s_1062_0)).value(),
            u16::try_from(s_1062_6).unwrap(),
        ));
        // D s_1062_8: cast reint s_1062_7 -> u8
        let s_1062_8: u8 = (s_1062_7.value() as u8);
        // D s_1062_9: cast zx s_1062_8 -> bv
        let s_1062_9: Bits = Bits::new(s_1062_8 as u128, 3u16);
        // C s_1062_10: const #7u : u8
        let s_1062_10: u8 = 7;
        // C s_1062_11: cast zx s_1062_10 -> bv
        let s_1062_11: Bits = Bits::new(s_1062_10 as u128, 3u16);
        // D s_1062_12: cmp-eq s_1062_9 s_1062_11
        let s_1062_12: bool = ((s_1062_9) == (s_1062_11));
        // N s_1062_13: branch s_1062_12 b1065 b1063
        if s_1062_12 {
            return block_1065(state, tracer, fn_state);
        } else {
            return block_1063(state, tracer, fn_state);
        };
    }
    fn block_1063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1063_0: const #0u : u8
        let s_1063_0: bool = false;
        // D s_1063_1: write-var gs#412223 <= s_1063_0
        fn_state.gs_412223 = s_1063_0;
        // N s_1063_2: jump b1064
        return block_1064(state, tracer, fn_state);
    }
    fn block_1064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1064_0: read-var gs#412223:u8
        let s_1064_0: bool = fn_state.gs_412223;
        // D s_1064_1: write-var gs#412224 <= s_1064_0
        fn_state.gs_412224 = s_1064_0;
        // N s_1064_2: jump b98
        return block_98(state, tracer, fn_state);
    }
    fn block_1065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1065_0: const #10s : i
        let s_1065_0: i128 = 10;
        // D s_1065_1: read-var u#34051:u32
        let s_1065_1: u32 = fn_state.u_34051;
        // D s_1065_2: cast zx s_1065_1 -> bv
        let s_1065_2: Bits = Bits::new(s_1065_1 as u128, 32u16);
        // C s_1065_3: const #1s : i64
        let s_1065_3: i64 = 1;
        // C s_1065_4: cast zx s_1065_3 -> i
        let s_1065_4: i128 = (i128::try_from(s_1065_3).unwrap());
        // C s_1065_5: const #1s : i
        let s_1065_5: i128 = 1;
        // C s_1065_6: add s_1065_5 s_1065_4
        let s_1065_6: i128 = (s_1065_5 + s_1065_4);
        // D s_1065_7: bit-extract s_1065_2 s_1065_0 s_1065_6
        let s_1065_7: Bits = (Bits::new(
            ((s_1065_2) >> (s_1065_0)).value(),
            u16::try_from(s_1065_6).unwrap(),
        ));
        // D s_1065_8: cast reint s_1065_7 -> u8
        let s_1065_8: u8 = (s_1065_7.value() as u8);
        // D s_1065_9: cast zx s_1065_8 -> bv
        let s_1065_9: Bits = Bits::new(s_1065_8 as u128, 2u16);
        // C s_1065_10: const #2u : u8
        let s_1065_10: u8 = 2;
        // C s_1065_11: cast zx s_1065_10 -> bv
        let s_1065_11: Bits = Bits::new(s_1065_10 as u128, 2u16);
        // D s_1065_12: cmp-eq s_1065_9 s_1065_11
        let s_1065_12: bool = ((s_1065_9) == (s_1065_11));
        // N s_1065_13: branch s_1065_12 b1068 b1066
        if s_1065_12 {
            return block_1068(state, tracer, fn_state);
        } else {
            return block_1066(state, tracer, fn_state);
        };
    }
    fn block_1066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1066_0: const #0u : u8
        let s_1066_0: bool = false;
        // D s_1066_1: write-var gs#412222 <= s_1066_0
        fn_state.gs_412222 = s_1066_0;
        // N s_1066_2: jump b1067
        return block_1067(state, tracer, fn_state);
    }
    fn block_1067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1067_0: read-var gs#412222:u8
        let s_1067_0: bool = fn_state.gs_412222;
        // D s_1067_1: write-var gs#412223 <= s_1067_0
        fn_state.gs_412223 = s_1067_0;
        // N s_1067_2: jump b1064
        return block_1064(state, tracer, fn_state);
    }
    fn block_1068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1068_0: const #6s : i
        let s_1068_0: i128 = 6;
        // D s_1068_1: read-var u#34051:u32
        let s_1068_1: u32 = fn_state.u_34051;
        // D s_1068_2: cast zx s_1068_1 -> bv
        let s_1068_2: Bits = Bits::new(s_1068_1 as u128, 32u16);
        // C s_1068_3: const #1s : i64
        let s_1068_3: i64 = 1;
        // C s_1068_4: cast zx s_1068_3 -> i
        let s_1068_4: i128 = (i128::try_from(s_1068_3).unwrap());
        // C s_1068_5: const #0s : i
        let s_1068_5: i128 = 0;
        // C s_1068_6: add s_1068_5 s_1068_4
        let s_1068_6: i128 = (s_1068_5 + s_1068_4);
        // D s_1068_7: bit-extract s_1068_2 s_1068_0 s_1068_6
        let s_1068_7: Bits = (Bits::new(
            ((s_1068_2) >> (s_1068_0)).value(),
            u16::try_from(s_1068_6).unwrap(),
        ));
        // D s_1068_8: cast reint s_1068_7 -> u8
        let s_1068_8: bool = ((s_1068_7.value()) != 0);
        // D s_1068_9: cast zx s_1068_8 -> bv
        let s_1068_9: Bits = Bits::new(s_1068_8 as u128, 1u16);
        // C s_1068_10: const #1u : u8
        let s_1068_10: bool = true;
        // C s_1068_11: cast zx s_1068_10 -> bv
        let s_1068_11: Bits = Bits::new(s_1068_10 as u128, 1u16);
        // D s_1068_12: cmp-eq s_1068_9 s_1068_11
        let s_1068_12: bool = ((s_1068_9) == (s_1068_11));
        // N s_1068_13: branch s_1068_12 b1071 b1069
        if s_1068_12 {
            return block_1071(state, tracer, fn_state);
        } else {
            return block_1069(state, tracer, fn_state);
        };
    }
    fn block_1069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1069_0: const #0u : u8
        let s_1069_0: bool = false;
        // D s_1069_1: write-var gs#412221 <= s_1069_0
        fn_state.gs_412221 = s_1069_0;
        // N s_1069_2: jump b1070
        return block_1070(state, tracer, fn_state);
    }
    fn block_1070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1070_0: read-var gs#412221:u8
        let s_1070_0: bool = fn_state.gs_412221;
        // D s_1070_1: write-var gs#412222 <= s_1070_0
        fn_state.gs_412222 = s_1070_0;
        // N s_1070_2: jump b1067
        return block_1067(state, tracer, fn_state);
    }
    fn block_1071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1071_0: const #4s : i
        let s_1071_0: i128 = 4;
        // D s_1071_1: read-var u#34051:u32
        let s_1071_1: u32 = fn_state.u_34051;
        // D s_1071_2: cast zx s_1071_1 -> bv
        let s_1071_2: Bits = Bits::new(s_1071_1 as u128, 32u16);
        // C s_1071_3: const #1s : i64
        let s_1071_3: i64 = 1;
        // C s_1071_4: cast zx s_1071_3 -> i
        let s_1071_4: i128 = (i128::try_from(s_1071_3).unwrap());
        // C s_1071_5: const #0s : i
        let s_1071_5: i128 = 0;
        // C s_1071_6: add s_1071_5 s_1071_4
        let s_1071_6: i128 = (s_1071_5 + s_1071_4);
        // D s_1071_7: bit-extract s_1071_2 s_1071_0 s_1071_6
        let s_1071_7: Bits = (Bits::new(
            ((s_1071_2) >> (s_1071_0)).value(),
            u16::try_from(s_1071_6).unwrap(),
        ));
        // D s_1071_8: cast reint s_1071_7 -> u8
        let s_1071_8: bool = ((s_1071_7.value()) != 0);
        // D s_1071_9: cast zx s_1071_8 -> bv
        let s_1071_9: Bits = Bits::new(s_1071_8 as u128, 1u16);
        // C s_1071_10: const #0u : u8
        let s_1071_10: bool = false;
        // C s_1071_11: cast zx s_1071_10 -> bv
        let s_1071_11: Bits = Bits::new(s_1071_10 as u128, 1u16);
        // D s_1071_12: cmp-eq s_1071_9 s_1071_11
        let s_1071_12: bool = ((s_1071_9) == (s_1071_11));
        // D s_1071_13: write-var gs#412221 <= s_1071_12
        fn_state.gs_412221 = s_1071_12;
        // N s_1071_14: jump b1070
        return block_1070(state, tracer, fn_state);
    }
    fn block_1072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1072_0: const #28s : i
        let s_1072_0: i128 = 28;
        // C s_1072_1: const #4s : i
        let s_1072_1: i128 = 4;
        // D s_1072_2: read-var u#34043:u32
        let s_1072_2: u32 = fn_state.u_34043;
        // D s_1072_3: cast zx s_1072_2 -> bv
        let s_1072_3: Bits = Bits::new(s_1072_2 as u128, 32u16);
        // D s_1072_4: bit-extract s_1072_3 s_1072_0 s_1072_1
        let s_1072_4: Bits = (Bits::new(
            ((s_1072_3) >> (s_1072_0)).value(),
            u16::try_from(s_1072_1).unwrap(),
        ));
        // D s_1072_5: cast reint s_1072_4 -> u8
        let s_1072_5: u8 = (s_1072_4.value() as u8);
        // D s_1072_6: cast zx s_1072_5 -> bv
        let s_1072_6: Bits = Bits::new(s_1072_5 as u128, 4u16);
        // C s_1072_7: const #15u : u8
        let s_1072_7: u8 = 15;
        // C s_1072_8: cast zx s_1072_7 -> bv
        let s_1072_8: Bits = Bits::new(s_1072_7 as u128, 4u16);
        // D s_1072_9: cmp-ne s_1072_6 s_1072_8
        let s_1072_9: bool = ((s_1072_6) != (s_1072_8));
        // N s_1072_10: branch s_1072_9 b1075 b1073
        if s_1072_9 {
            return block_1075(state, tracer, fn_state);
        } else {
            return block_1073(state, tracer, fn_state);
        };
    }
    fn block_1073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1073_0: const #0u : u8
        let s_1073_0: bool = false;
        // D s_1073_1: write-var gs#412194 <= s_1073_0
        fn_state.gs_412194 = s_1073_0;
        // N s_1073_2: jump b1074
        return block_1074(state, tracer, fn_state);
    }
    fn block_1074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1074_0: read-var gs#412194:u8
        let s_1074_0: bool = fn_state.gs_412194;
        // D s_1074_1: write-var gs#412195 <= s_1074_0
        fn_state.gs_412195 = s_1074_0;
        // N s_1074_2: jump b94
        return block_94(state, tracer, fn_state);
    }
    fn block_1075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1075_0: const #3420s : i
        let s_1075_0: i128 = 3420;
        // C s_1075_1: const #14696u : u32
        let s_1075_1: u32 = 14696;
        // D s_1075_2: read-reg s_1075_1:i
        let s_1075_2: i128 = {
            let value = state.read_register::<i128>(s_1075_1 as isize);
            tracer.read_register(s_1075_1 as isize, value);
            value
        };
        // D s_1075_3: cmp-lt s_1075_2 s_1075_0
        let s_1075_3: bool = ((s_1075_2) < (s_1075_0));
        // D s_1075_4: write-var gs#412194 <= s_1075_3
        fn_state.gs_412194 = s_1075_3;
        // N s_1075_5: jump b1074
        return block_1074(state, tracer, fn_state);
    }
    fn block_1076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1076_0: const #16s : i
        let s_1076_0: i128 = 16;
        // D s_1076_1: read-var u#34043:u32
        let s_1076_1: u32 = fn_state.u_34043;
        // D s_1076_2: cast zx s_1076_1 -> bv
        let s_1076_2: Bits = Bits::new(s_1076_1 as u128, 32u16);
        // C s_1076_3: const #1s : i64
        let s_1076_3: i64 = 1;
        // C s_1076_4: cast zx s_1076_3 -> i
        let s_1076_4: i128 = (i128::try_from(s_1076_3).unwrap());
        // C s_1076_5: const #5s : i
        let s_1076_5: i128 = 5;
        // C s_1076_6: add s_1076_5 s_1076_4
        let s_1076_6: i128 = (s_1076_5 + s_1076_4);
        // D s_1076_7: bit-extract s_1076_2 s_1076_0 s_1076_6
        let s_1076_7: Bits = (Bits::new(
            ((s_1076_2) >> (s_1076_0)).value(),
            u16::try_from(s_1076_6).unwrap(),
        ));
        // D s_1076_8: cast reint s_1076_7 -> u8
        let s_1076_8: u8 = (s_1076_7.value() as u8);
        // D s_1076_9: cast zx s_1076_8 -> bv
        let s_1076_9: Bits = Bits::new(s_1076_8 as u128, 6u16);
        // C s_1076_10: const #55u : u8
        let s_1076_10: u8 = 55;
        // C s_1076_11: cast zx s_1076_10 -> bv
        let s_1076_11: Bits = Bits::new(s_1076_10 as u128, 6u16);
        // D s_1076_12: cmp-eq s_1076_9 s_1076_11
        let s_1076_12: bool = ((s_1076_9) == (s_1076_11));
        // N s_1076_13: branch s_1076_12 b1079 b1077
        if s_1076_12 {
            return block_1079(state, tracer, fn_state);
        } else {
            return block_1077(state, tracer, fn_state);
        };
    }
    fn block_1077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1077_0: const #0u : u8
        let s_1077_0: bool = false;
        // D s_1077_1: write-var gs#412189 <= s_1077_0
        fn_state.gs_412189 = s_1077_0;
        // N s_1077_2: jump b1078
        return block_1078(state, tracer, fn_state);
    }
    fn block_1078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1078_0: read-var gs#412189:u8
        let s_1078_0: bool = fn_state.gs_412189;
        // D s_1078_1: write-var gs#412190 <= s_1078_0
        fn_state.gs_412190 = s_1078_0;
        // N s_1078_2: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_1079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1079_0: const #9s : i
        let s_1079_0: i128 = 9;
        // D s_1079_1: read-var u#34043:u32
        let s_1079_1: u32 = fn_state.u_34043;
        // D s_1079_2: cast zx s_1079_1 -> bv
        let s_1079_2: Bits = Bits::new(s_1079_1 as u128, 32u16);
        // C s_1079_3: const #1s : i64
        let s_1079_3: i64 = 1;
        // C s_1079_4: cast zx s_1079_3 -> i
        let s_1079_4: i128 = (i128::try_from(s_1079_3).unwrap());
        // C s_1079_5: const #2s : i
        let s_1079_5: i128 = 2;
        // C s_1079_6: add s_1079_5 s_1079_4
        let s_1079_6: i128 = (s_1079_5 + s_1079_4);
        // D s_1079_7: bit-extract s_1079_2 s_1079_0 s_1079_6
        let s_1079_7: Bits = (Bits::new(
            ((s_1079_2) >> (s_1079_0)).value(),
            u16::try_from(s_1079_6).unwrap(),
        ));
        // D s_1079_8: cast reint s_1079_7 -> u8
        let s_1079_8: u8 = (s_1079_7.value() as u8);
        // D s_1079_9: cast zx s_1079_8 -> bv
        let s_1079_9: Bits = Bits::new(s_1079_8 as u128, 3u16);
        // C s_1079_10: const #5u : u8
        let s_1079_10: u8 = 5;
        // C s_1079_11: cast zx s_1079_10 -> bv
        let s_1079_11: Bits = Bits::new(s_1079_10 as u128, 3u16);
        // D s_1079_12: cmp-eq s_1079_9 s_1079_11
        let s_1079_12: bool = ((s_1079_9) == (s_1079_11));
        // N s_1079_13: branch s_1079_12 b1082 b1080
        if s_1079_12 {
            return block_1082(state, tracer, fn_state);
        } else {
            return block_1080(state, tracer, fn_state);
        };
    }
    fn block_1080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1080_0: const #0u : u8
        let s_1080_0: bool = false;
        // D s_1080_1: write-var gs#412188 <= s_1080_0
        fn_state.gs_412188 = s_1080_0;
        // N s_1080_2: jump b1081
        return block_1081(state, tracer, fn_state);
    }
    fn block_1081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1081_0: read-var gs#412188:u8
        let s_1081_0: bool = fn_state.gs_412188;
        // D s_1081_1: write-var gs#412189 <= s_1081_0
        fn_state.gs_412189 = s_1081_0;
        // N s_1081_2: jump b1078
        return block_1078(state, tracer, fn_state);
    }
    fn block_1082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1082_0: const #6s : i
        let s_1082_0: i128 = 6;
        // D s_1082_1: read-var u#34043:u32
        let s_1082_1: u32 = fn_state.u_34043;
        // D s_1082_2: cast zx s_1082_1 -> bv
        let s_1082_2: Bits = Bits::new(s_1082_1 as u128, 32u16);
        // C s_1082_3: const #1s : i64
        let s_1082_3: i64 = 1;
        // C s_1082_4: cast zx s_1082_3 -> i
        let s_1082_4: i128 = (i128::try_from(s_1082_3).unwrap());
        // C s_1082_5: const #1s : i
        let s_1082_5: i128 = 1;
        // C s_1082_6: add s_1082_5 s_1082_4
        let s_1082_6: i128 = (s_1082_5 + s_1082_4);
        // D s_1082_7: bit-extract s_1082_2 s_1082_0 s_1082_6
        let s_1082_7: Bits = (Bits::new(
            ((s_1082_2) >> (s_1082_0)).value(),
            u16::try_from(s_1082_6).unwrap(),
        ));
        // D s_1082_8: cast reint s_1082_7 -> u8
        let s_1082_8: u8 = (s_1082_7.value() as u8);
        // D s_1082_9: cast zx s_1082_8 -> bv
        let s_1082_9: Bits = Bits::new(s_1082_8 as u128, 2u16);
        // C s_1082_10: const #3u : u8
        let s_1082_10: u8 = 3;
        // C s_1082_11: cast zx s_1082_10 -> bv
        let s_1082_11: Bits = Bits::new(s_1082_10 as u128, 2u16);
        // D s_1082_12: cmp-eq s_1082_9 s_1082_11
        let s_1082_12: bool = ((s_1082_9) == (s_1082_11));
        // N s_1082_13: branch s_1082_12 b1085 b1083
        if s_1082_12 {
            return block_1085(state, tracer, fn_state);
        } else {
            return block_1083(state, tracer, fn_state);
        };
    }
    fn block_1083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1083_0: const #0u : u8
        let s_1083_0: bool = false;
        // D s_1083_1: write-var gs#412187 <= s_1083_0
        fn_state.gs_412187 = s_1083_0;
        // N s_1083_2: jump b1084
        return block_1084(state, tracer, fn_state);
    }
    fn block_1084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1084_0: read-var gs#412187:u8
        let s_1084_0: bool = fn_state.gs_412187;
        // D s_1084_1: write-var gs#412188 <= s_1084_0
        fn_state.gs_412188 = s_1084_0;
        // N s_1084_2: jump b1081
        return block_1081(state, tracer, fn_state);
    }
    fn block_1085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1085_0: const #4s : i
        let s_1085_0: i128 = 4;
        // D s_1085_1: read-var u#34043:u32
        let s_1085_1: u32 = fn_state.u_34043;
        // D s_1085_2: cast zx s_1085_1 -> bv
        let s_1085_2: Bits = Bits::new(s_1085_1 as u128, 32u16);
        // C s_1085_3: const #1s : i64
        let s_1085_3: i64 = 1;
        // C s_1085_4: cast zx s_1085_3 -> i
        let s_1085_4: i128 = (i128::try_from(s_1085_3).unwrap());
        // C s_1085_5: const #0s : i
        let s_1085_5: i128 = 0;
        // C s_1085_6: add s_1085_5 s_1085_4
        let s_1085_6: i128 = (s_1085_5 + s_1085_4);
        // D s_1085_7: bit-extract s_1085_2 s_1085_0 s_1085_6
        let s_1085_7: Bits = (Bits::new(
            ((s_1085_2) >> (s_1085_0)).value(),
            u16::try_from(s_1085_6).unwrap(),
        ));
        // D s_1085_8: cast reint s_1085_7 -> u8
        let s_1085_8: bool = ((s_1085_7.value()) != 0);
        // D s_1085_9: cast zx s_1085_8 -> bv
        let s_1085_9: Bits = Bits::new(s_1085_8 as u128, 1u16);
        // C s_1085_10: const #0u : u8
        let s_1085_10: bool = false;
        // C s_1085_11: cast zx s_1085_10 -> bv
        let s_1085_11: Bits = Bits::new(s_1085_10 as u128, 1u16);
        // D s_1085_12: cmp-eq s_1085_9 s_1085_11
        let s_1085_12: bool = ((s_1085_9) == (s_1085_11));
        // D s_1085_13: write-var gs#412187 <= s_1085_12
        fn_state.gs_412187 = s_1085_12;
        // N s_1085_14: jump b1084
        return block_1084(state, tracer, fn_state);
    }
    fn block_1086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1086_0: const #28s : i
        let s_1086_0: i128 = 28;
        // C s_1086_1: const #4s : i
        let s_1086_1: i128 = 4;
        // D s_1086_2: read-var u#34036:u32
        let s_1086_2: u32 = fn_state.u_34036;
        // D s_1086_3: cast zx s_1086_2 -> bv
        let s_1086_3: Bits = Bits::new(s_1086_2 as u128, 32u16);
        // D s_1086_4: bit-extract s_1086_3 s_1086_0 s_1086_1
        let s_1086_4: Bits = (Bits::new(
            ((s_1086_3) >> (s_1086_0)).value(),
            u16::try_from(s_1086_1).unwrap(),
        ));
        // D s_1086_5: cast reint s_1086_4 -> u8
        let s_1086_5: u8 = (s_1086_4.value() as u8);
        // D s_1086_6: cast zx s_1086_5 -> bv
        let s_1086_6: Bits = Bits::new(s_1086_5 as u128, 4u16);
        // C s_1086_7: const #15u : u8
        let s_1086_7: u8 = 15;
        // C s_1086_8: cast zx s_1086_7 -> bv
        let s_1086_8: Bits = Bits::new(s_1086_7 as u128, 4u16);
        // D s_1086_9: cmp-ne s_1086_6 s_1086_8
        let s_1086_9: bool = ((s_1086_6) != (s_1086_8));
        // N s_1086_10: branch s_1086_9 b1089 b1087
        if s_1086_9 {
            return block_1089(state, tracer, fn_state);
        } else {
            return block_1087(state, tracer, fn_state);
        };
    }
    fn block_1087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1087_0: const #0u : u8
        let s_1087_0: bool = false;
        // D s_1087_1: write-var gs#412156 <= s_1087_0
        fn_state.gs_412156 = s_1087_0;
        // N s_1087_2: jump b1088
        return block_1088(state, tracer, fn_state);
    }
    fn block_1088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1088_0: read-var gs#412156:u8
        let s_1088_0: bool = fn_state.gs_412156;
        // D s_1088_1: write-var gs#412157 <= s_1088_0
        fn_state.gs_412157 = s_1088_0;
        // N s_1088_2: jump b88
        return block_88(state, tracer, fn_state);
    }
    fn block_1089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1089_0: const #3418s : i
        let s_1089_0: i128 = 3418;
        // C s_1089_1: const #14696u : u32
        let s_1089_1: u32 = 14696;
        // D s_1089_2: read-reg s_1089_1:i
        let s_1089_2: i128 = {
            let value = state.read_register::<i128>(s_1089_1 as isize);
            tracer.read_register(s_1089_1 as isize, value);
            value
        };
        // D s_1089_3: cmp-lt s_1089_2 s_1089_0
        let s_1089_3: bool = ((s_1089_2) < (s_1089_0));
        // D s_1089_4: write-var gs#412156 <= s_1089_3
        fn_state.gs_412156 = s_1089_3;
        // N s_1089_5: jump b1088
        return block_1088(state, tracer, fn_state);
    }
    fn block_1090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1090_0: const #17s : i
        let s_1090_0: i128 = 17;
        // D s_1090_1: read-var u#34036:u32
        let s_1090_1: u32 = fn_state.u_34036;
        // D s_1090_2: cast zx s_1090_1 -> bv
        let s_1090_2: Bits = Bits::new(s_1090_1 as u128, 32u16);
        // C s_1090_3: const #1s : i64
        let s_1090_3: i64 = 1;
        // C s_1090_4: cast zx s_1090_3 -> i
        let s_1090_4: i128 = (i128::try_from(s_1090_3).unwrap());
        // C s_1090_5: const #4s : i
        let s_1090_5: i128 = 4;
        // C s_1090_6: add s_1090_5 s_1090_4
        let s_1090_6: i128 = (s_1090_5 + s_1090_4);
        // D s_1090_7: bit-extract s_1090_2 s_1090_0 s_1090_6
        let s_1090_7: Bits = (Bits::new(
            ((s_1090_2) >> (s_1090_0)).value(),
            u16::try_from(s_1090_6).unwrap(),
        ));
        // D s_1090_8: cast reint s_1090_7 -> u8
        let s_1090_8: u8 = (s_1090_7.value() as u8);
        // D s_1090_9: cast zx s_1090_8 -> bv
        let s_1090_9: Bits = Bits::new(s_1090_8 as u128, 5u16);
        // C s_1090_10: const #25u : u8
        let s_1090_10: u8 = 25;
        // C s_1090_11: cast zx s_1090_10 -> bv
        let s_1090_11: Bits = Bits::new(s_1090_10 as u128, 5u16);
        // D s_1090_12: cmp-eq s_1090_9 s_1090_11
        let s_1090_12: bool = ((s_1090_9) == (s_1090_11));
        // N s_1090_13: branch s_1090_12 b1093 b1091
        if s_1090_12 {
            return block_1093(state, tracer, fn_state);
        } else {
            return block_1091(state, tracer, fn_state);
        };
    }
    fn block_1091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1091_0: const #0u : u8
        let s_1091_0: bool = false;
        // D s_1091_1: write-var gs#412151 <= s_1091_0
        fn_state.gs_412151 = s_1091_0;
        // N s_1091_2: jump b1092
        return block_1092(state, tracer, fn_state);
    }
    fn block_1092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1092_0: read-var gs#412151:u8
        let s_1092_0: bool = fn_state.gs_412151;
        // D s_1092_1: write-var gs#412152 <= s_1092_0
        fn_state.gs_412152 = s_1092_0;
        // N s_1092_2: jump b86
        return block_86(state, tracer, fn_state);
    }
    fn block_1093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1093_0: const #9s : i
        let s_1093_0: i128 = 9;
        // D s_1093_1: read-var u#34036:u32
        let s_1093_1: u32 = fn_state.u_34036;
        // D s_1093_2: cast zx s_1093_1 -> bv
        let s_1093_2: Bits = Bits::new(s_1093_1 as u128, 32u16);
        // C s_1093_3: const #1s : i64
        let s_1093_3: i64 = 1;
        // C s_1093_4: cast zx s_1093_3 -> i
        let s_1093_4: i128 = (i128::try_from(s_1093_3).unwrap());
        // C s_1093_5: const #2s : i
        let s_1093_5: i128 = 2;
        // C s_1093_6: add s_1093_5 s_1093_4
        let s_1093_6: i128 = (s_1093_5 + s_1093_4);
        // D s_1093_7: bit-extract s_1093_2 s_1093_0 s_1093_6
        let s_1093_7: Bits = (Bits::new(
            ((s_1093_2) >> (s_1093_0)).value(),
            u16::try_from(s_1093_6).unwrap(),
        ));
        // D s_1093_8: cast reint s_1093_7 -> u8
        let s_1093_8: u8 = (s_1093_7.value() as u8);
        // D s_1093_9: cast zx s_1093_8 -> bv
        let s_1093_9: Bits = Bits::new(s_1093_8 as u128, 3u16);
        // C s_1093_10: const #5u : u8
        let s_1093_10: u8 = 5;
        // C s_1093_11: cast zx s_1093_10 -> bv
        let s_1093_11: Bits = Bits::new(s_1093_10 as u128, 3u16);
        // D s_1093_12: cmp-eq s_1093_9 s_1093_11
        let s_1093_12: bool = ((s_1093_9) == (s_1093_11));
        // N s_1093_13: branch s_1093_12 b1096 b1094
        if s_1093_12 {
            return block_1096(state, tracer, fn_state);
        } else {
            return block_1094(state, tracer, fn_state);
        };
    }
    fn block_1094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1094_0: const #0u : u8
        let s_1094_0: bool = false;
        // D s_1094_1: write-var gs#412150 <= s_1094_0
        fn_state.gs_412150 = s_1094_0;
        // N s_1094_2: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_1095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1095_0: read-var gs#412150:u8
        let s_1095_0: bool = fn_state.gs_412150;
        // D s_1095_1: write-var gs#412151 <= s_1095_0
        fn_state.gs_412151 = s_1095_0;
        // N s_1095_2: jump b1092
        return block_1092(state, tracer, fn_state);
    }
    fn block_1096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1096_0: const #6s : i
        let s_1096_0: i128 = 6;
        // D s_1096_1: read-var u#34036:u32
        let s_1096_1: u32 = fn_state.u_34036;
        // D s_1096_2: cast zx s_1096_1 -> bv
        let s_1096_2: Bits = Bits::new(s_1096_1 as u128, 32u16);
        // C s_1096_3: const #1s : i64
        let s_1096_3: i64 = 1;
        // C s_1096_4: cast zx s_1096_3 -> i
        let s_1096_4: i128 = (i128::try_from(s_1096_3).unwrap());
        // C s_1096_5: const #0s : i
        let s_1096_5: i128 = 0;
        // C s_1096_6: add s_1096_5 s_1096_4
        let s_1096_6: i128 = (s_1096_5 + s_1096_4);
        // D s_1096_7: bit-extract s_1096_2 s_1096_0 s_1096_6
        let s_1096_7: Bits = (Bits::new(
            ((s_1096_2) >> (s_1096_0)).value(),
            u16::try_from(s_1096_6).unwrap(),
        ));
        // D s_1096_8: cast reint s_1096_7 -> u8
        let s_1096_8: bool = ((s_1096_7.value()) != 0);
        // D s_1096_9: cast zx s_1096_8 -> bv
        let s_1096_9: Bits = Bits::new(s_1096_8 as u128, 1u16);
        // C s_1096_10: const #1u : u8
        let s_1096_10: bool = true;
        // C s_1096_11: cast zx s_1096_10 -> bv
        let s_1096_11: Bits = Bits::new(s_1096_10 as u128, 1u16);
        // D s_1096_12: cmp-eq s_1096_9 s_1096_11
        let s_1096_12: bool = ((s_1096_9) == (s_1096_11));
        // N s_1096_13: branch s_1096_12 b1099 b1097
        if s_1096_12 {
            return block_1099(state, tracer, fn_state);
        } else {
            return block_1097(state, tracer, fn_state);
        };
    }
    fn block_1097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1097_0: const #0u : u8
        let s_1097_0: bool = false;
        // D s_1097_1: write-var gs#412149 <= s_1097_0
        fn_state.gs_412149 = s_1097_0;
        // N s_1097_2: jump b1098
        return block_1098(state, tracer, fn_state);
    }
    fn block_1098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1098_0: read-var gs#412149:u8
        let s_1098_0: bool = fn_state.gs_412149;
        // D s_1098_1: write-var gs#412150 <= s_1098_0
        fn_state.gs_412150 = s_1098_0;
        // N s_1098_2: jump b1095
        return block_1095(state, tracer, fn_state);
    }
    fn block_1099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1099_0: const #4s : i
        let s_1099_0: i128 = 4;
        // D s_1099_1: read-var u#34036:u32
        let s_1099_1: u32 = fn_state.u_34036;
        // D s_1099_2: cast zx s_1099_1 -> bv
        let s_1099_2: Bits = Bits::new(s_1099_1 as u128, 32u16);
        // C s_1099_3: const #1s : i64
        let s_1099_3: i64 = 1;
        // C s_1099_4: cast zx s_1099_3 -> i
        let s_1099_4: i128 = (i128::try_from(s_1099_3).unwrap());
        // C s_1099_5: const #0s : i
        let s_1099_5: i128 = 0;
        // C s_1099_6: add s_1099_5 s_1099_4
        let s_1099_6: i128 = (s_1099_5 + s_1099_4);
        // D s_1099_7: bit-extract s_1099_2 s_1099_0 s_1099_6
        let s_1099_7: Bits = (Bits::new(
            ((s_1099_2) >> (s_1099_0)).value(),
            u16::try_from(s_1099_6).unwrap(),
        ));
        // D s_1099_8: cast reint s_1099_7 -> u8
        let s_1099_8: bool = ((s_1099_7.value()) != 0);
        // D s_1099_9: cast zx s_1099_8 -> bv
        let s_1099_9: Bits = Bits::new(s_1099_8 as u128, 1u16);
        // C s_1099_10: const #0u : u8
        let s_1099_10: bool = false;
        // C s_1099_11: cast zx s_1099_10 -> bv
        let s_1099_11: Bits = Bits::new(s_1099_10 as u128, 1u16);
        // D s_1099_12: cmp-eq s_1099_9 s_1099_11
        let s_1099_12: bool = ((s_1099_9) == (s_1099_11));
        // D s_1099_13: write-var gs#412149 <= s_1099_12
        fn_state.gs_412149 = s_1099_12;
        // N s_1099_14: jump b1098
        return block_1098(state, tracer, fn_state);
    }
    fn block_1100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1100_0: const #28s : i
        let s_1100_0: i128 = 28;
        // C s_1100_1: const #4s : i
        let s_1100_1: i128 = 4;
        // D s_1100_2: read-var u#34029:u32
        let s_1100_2: u32 = fn_state.u_34029;
        // D s_1100_3: cast zx s_1100_2 -> bv
        let s_1100_3: Bits = Bits::new(s_1100_2 as u128, 32u16);
        // D s_1100_4: bit-extract s_1100_3 s_1100_0 s_1100_1
        let s_1100_4: Bits = (Bits::new(
            ((s_1100_3) >> (s_1100_0)).value(),
            u16::try_from(s_1100_1).unwrap(),
        ));
        // D s_1100_5: cast reint s_1100_4 -> u8
        let s_1100_5: u8 = (s_1100_4.value() as u8);
        // D s_1100_6: cast zx s_1100_5 -> bv
        let s_1100_6: Bits = Bits::new(s_1100_5 as u128, 4u16);
        // C s_1100_7: const #15u : u8
        let s_1100_7: u8 = 15;
        // C s_1100_8: cast zx s_1100_7 -> bv
        let s_1100_8: Bits = Bits::new(s_1100_7 as u128, 4u16);
        // D s_1100_9: cmp-ne s_1100_6 s_1100_8
        let s_1100_9: bool = ((s_1100_6) != (s_1100_8));
        // N s_1100_10: branch s_1100_9 b1103 b1101
        if s_1100_9 {
            return block_1103(state, tracer, fn_state);
        } else {
            return block_1101(state, tracer, fn_state);
        };
    }
    fn block_1101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1101_0: const #0u : u8
        let s_1101_0: bool = false;
        // D s_1101_1: write-var gs#412110 <= s_1101_0
        fn_state.gs_412110 = s_1101_0;
        // N s_1101_2: jump b1102
        return block_1102(state, tracer, fn_state);
    }
    fn block_1102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1102_0: read-var gs#412110:u8
        let s_1102_0: bool = fn_state.gs_412110;
        // D s_1102_1: write-var gs#412111 <= s_1102_0
        fn_state.gs_412111 = s_1102_0;
        // N s_1102_2: jump b68
        return block_68(state, tracer, fn_state);
    }
    fn block_1103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1103_0: const #3413s : i
        let s_1103_0: i128 = 3413;
        // C s_1103_1: const #14696u : u32
        let s_1103_1: u32 = 14696;
        // D s_1103_2: read-reg s_1103_1:i
        let s_1103_2: i128 = {
            let value = state.read_register::<i128>(s_1103_1 as isize);
            tracer.read_register(s_1103_1 as isize, value);
            value
        };
        // D s_1103_3: cmp-lt s_1103_2 s_1103_0
        let s_1103_3: bool = ((s_1103_2) < (s_1103_0));
        // D s_1103_4: write-var gs#412110 <= s_1103_3
        fn_state.gs_412110 = s_1103_3;
        // N s_1103_5: jump b1102
        return block_1102(state, tracer, fn_state);
    }
    fn block_1104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1104_0: const #16s : i
        let s_1104_0: i128 = 16;
        // D s_1104_1: read-var u#34029:u32
        let s_1104_1: u32 = fn_state.u_34029;
        // D s_1104_2: cast zx s_1104_1 -> bv
        let s_1104_2: Bits = Bits::new(s_1104_1 as u128, 32u16);
        // C s_1104_3: const #1s : i64
        let s_1104_3: i64 = 1;
        // C s_1104_4: cast zx s_1104_3 -> i
        let s_1104_4: i128 = (i128::try_from(s_1104_3).unwrap());
        // C s_1104_5: const #5s : i
        let s_1104_5: i128 = 5;
        // C s_1104_6: add s_1104_5 s_1104_4
        let s_1104_6: i128 = (s_1104_5 + s_1104_4);
        // D s_1104_7: bit-extract s_1104_2 s_1104_0 s_1104_6
        let s_1104_7: Bits = (Bits::new(
            ((s_1104_2) >> (s_1104_0)).value(),
            u16::try_from(s_1104_6).unwrap(),
        ));
        // D s_1104_8: cast reint s_1104_7 -> u8
        let s_1104_8: u8 = (s_1104_7.value() as u8);
        // D s_1104_9: cast zx s_1104_8 -> bv
        let s_1104_9: Bits = Bits::new(s_1104_8 as u128, 6u16);
        // C s_1104_10: const #53u : u8
        let s_1104_10: u8 = 53;
        // C s_1104_11: cast zx s_1104_10 -> bv
        let s_1104_11: Bits = Bits::new(s_1104_10 as u128, 6u16);
        // D s_1104_12: cmp-eq s_1104_9 s_1104_11
        let s_1104_12: bool = ((s_1104_9) == (s_1104_11));
        // N s_1104_13: branch s_1104_12 b1107 b1105
        if s_1104_12 {
            return block_1107(state, tracer, fn_state);
        } else {
            return block_1105(state, tracer, fn_state);
        };
    }
    fn block_1105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1105_0: const #0u : u8
        let s_1105_0: bool = false;
        // D s_1105_1: write-var gs#412105 <= s_1105_0
        fn_state.gs_412105 = s_1105_0;
        // N s_1105_2: jump b1106
        return block_1106(state, tracer, fn_state);
    }
    fn block_1106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1106_0: read-var gs#412105:u8
        let s_1106_0: bool = fn_state.gs_412105;
        // D s_1106_1: write-var gs#412106 <= s_1106_0
        fn_state.gs_412106 = s_1106_0;
        // N s_1106_2: jump b66
        return block_66(state, tracer, fn_state);
    }
    fn block_1107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1107_0: const #10s : i
        let s_1107_0: i128 = 10;
        // D s_1107_1: read-var u#34029:u32
        let s_1107_1: u32 = fn_state.u_34029;
        // D s_1107_2: cast zx s_1107_1 -> bv
        let s_1107_2: Bits = Bits::new(s_1107_1 as u128, 32u16);
        // C s_1107_3: const #1s : i64
        let s_1107_3: i64 = 1;
        // C s_1107_4: cast zx s_1107_3 -> i
        let s_1107_4: i128 = (i128::try_from(s_1107_3).unwrap());
        // C s_1107_5: const #1s : i
        let s_1107_5: i128 = 1;
        // C s_1107_6: add s_1107_5 s_1107_4
        let s_1107_6: i128 = (s_1107_5 + s_1107_4);
        // D s_1107_7: bit-extract s_1107_2 s_1107_0 s_1107_6
        let s_1107_7: Bits = (Bits::new(
            ((s_1107_2) >> (s_1107_0)).value(),
            u16::try_from(s_1107_6).unwrap(),
        ));
        // D s_1107_8: cast reint s_1107_7 -> u8
        let s_1107_8: u8 = (s_1107_7.value() as u8);
        // D s_1107_9: cast zx s_1107_8 -> bv
        let s_1107_9: Bits = Bits::new(s_1107_8 as u128, 2u16);
        // C s_1107_10: const #2u : u8
        let s_1107_10: u8 = 2;
        // C s_1107_11: cast zx s_1107_10 -> bv
        let s_1107_11: Bits = Bits::new(s_1107_10 as u128, 2u16);
        // D s_1107_12: cmp-eq s_1107_9 s_1107_11
        let s_1107_12: bool = ((s_1107_9) == (s_1107_11));
        // N s_1107_13: branch s_1107_12 b1110 b1108
        if s_1107_12 {
            return block_1110(state, tracer, fn_state);
        } else {
            return block_1108(state, tracer, fn_state);
        };
    }
    fn block_1108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1108_0: const #0u : u8
        let s_1108_0: bool = false;
        // D s_1108_1: write-var gs#412104 <= s_1108_0
        fn_state.gs_412104 = s_1108_0;
        // N s_1108_2: jump b1109
        return block_1109(state, tracer, fn_state);
    }
    fn block_1109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1109_0: read-var gs#412104:u8
        let s_1109_0: bool = fn_state.gs_412104;
        // D s_1109_1: write-var gs#412105 <= s_1109_0
        fn_state.gs_412105 = s_1109_0;
        // N s_1109_2: jump b1106
        return block_1106(state, tracer, fn_state);
    }
    fn block_1110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1110_0: const #0s : i
        let s_1110_0: i128 = 0;
        // D s_1110_1: read-var u#34029:u32
        let s_1110_1: u32 = fn_state.u_34029;
        // D s_1110_2: cast zx s_1110_1 -> bv
        let s_1110_2: Bits = Bits::new(s_1110_1 as u128, 32u16);
        // C s_1110_3: const #1s : i64
        let s_1110_3: i64 = 1;
        // C s_1110_4: cast zx s_1110_3 -> i
        let s_1110_4: i128 = (i128::try_from(s_1110_3).unwrap());
        // C s_1110_5: const #6s : i
        let s_1110_5: i128 = 6;
        // C s_1110_6: add s_1110_5 s_1110_4
        let s_1110_6: i128 = (s_1110_5 + s_1110_4);
        // D s_1110_7: bit-extract s_1110_2 s_1110_0 s_1110_6
        let s_1110_7: Bits = (Bits::new(
            ((s_1110_2) >> (s_1110_0)).value(),
            u16::try_from(s_1110_6).unwrap(),
        ));
        // D s_1110_8: cast reint s_1110_7 -> u8
        let s_1110_8: u8 = (s_1110_7.value() as u8);
        // D s_1110_9: cast zx s_1110_8 -> bv
        let s_1110_9: Bits = Bits::new(s_1110_8 as u128, 7u16);
        // C s_1110_10: const #64u : u8
        let s_1110_10: u8 = 64;
        // C s_1110_11: cast zx s_1110_10 -> bv
        let s_1110_11: Bits = Bits::new(s_1110_10 as u128, 7u16);
        // D s_1110_12: cmp-eq s_1110_9 s_1110_11
        let s_1110_12: bool = ((s_1110_9) == (s_1110_11));
        // D s_1110_13: write-var gs#412104 <= s_1110_12
        fn_state.gs_412104 = s_1110_12;
        // N s_1110_14: jump b1109
        return block_1109(state, tracer, fn_state);
    }
    fn block_1111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1111_0: const #28s : i
        let s_1111_0: i128 = 28;
        // C s_1111_1: const #4s : i
        let s_1111_1: i128 = 4;
        // D s_1111_2: read-var u#34021:u32
        let s_1111_2: u32 = fn_state.u_34021;
        // D s_1111_3: cast zx s_1111_2 -> bv
        let s_1111_3: Bits = Bits::new(s_1111_2 as u128, 32u16);
        // D s_1111_4: bit-extract s_1111_3 s_1111_0 s_1111_1
        let s_1111_4: Bits = (Bits::new(
            ((s_1111_3) >> (s_1111_0)).value(),
            u16::try_from(s_1111_1).unwrap(),
        ));
        // D s_1111_5: cast reint s_1111_4 -> u8
        let s_1111_5: u8 = (s_1111_4.value() as u8);
        // D s_1111_6: cast zx s_1111_5 -> bv
        let s_1111_6: Bits = Bits::new(s_1111_5 as u128, 4u16);
        // C s_1111_7: const #15u : u8
        let s_1111_7: u8 = 15;
        // C s_1111_8: cast zx s_1111_7 -> bv
        let s_1111_8: Bits = Bits::new(s_1111_7 as u128, 4u16);
        // D s_1111_9: cmp-ne s_1111_6 s_1111_8
        let s_1111_9: bool = ((s_1111_6) != (s_1111_8));
        // N s_1111_10: branch s_1111_9 b1114 b1112
        if s_1111_9 {
            return block_1114(state, tracer, fn_state);
        } else {
            return block_1112(state, tracer, fn_state);
        };
    }
    fn block_1112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1112_0: const #0u : u8
        let s_1112_0: bool = false;
        // D s_1112_1: write-var gs#412077 <= s_1112_0
        fn_state.gs_412077 = s_1112_0;
        // N s_1112_2: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_1113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1113_0: read-var gs#412077:u8
        let s_1113_0: bool = fn_state.gs_412077;
        // D s_1113_1: write-var gs#412078 <= s_1113_0
        fn_state.gs_412078 = s_1113_0;
        // N s_1113_2: jump b62
        return block_62(state, tracer, fn_state);
    }
    fn block_1114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1114_0: const #3412s : i
        let s_1114_0: i128 = 3412;
        // C s_1114_1: const #14696u : u32
        let s_1114_1: u32 = 14696;
        // D s_1114_2: read-reg s_1114_1:i
        let s_1114_2: i128 = {
            let value = state.read_register::<i128>(s_1114_1 as isize);
            tracer.read_register(s_1114_1 as isize, value);
            value
        };
        // D s_1114_3: cmp-lt s_1114_2 s_1114_0
        let s_1114_3: bool = ((s_1114_2) < (s_1114_0));
        // D s_1114_4: write-var gs#412077 <= s_1114_3
        fn_state.gs_412077 = s_1114_3;
        // N s_1114_5: jump b1113
        return block_1113(state, tracer, fn_state);
    }
    fn block_1115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1115_0: const #16s : i
        let s_1115_0: i128 = 16;
        // D s_1115_1: read-var u#34021:u32
        let s_1115_1: u32 = fn_state.u_34021;
        // D s_1115_2: cast zx s_1115_1 -> bv
        let s_1115_2: Bits = Bits::new(s_1115_1 as u128, 32u16);
        // C s_1115_3: const #1s : i64
        let s_1115_3: i64 = 1;
        // C s_1115_4: cast zx s_1115_3 -> i
        let s_1115_4: i128 = (i128::try_from(s_1115_3).unwrap());
        // C s_1115_5: const #5s : i
        let s_1115_5: i128 = 5;
        // C s_1115_6: add s_1115_5 s_1115_4
        let s_1115_6: i128 = (s_1115_5 + s_1115_4);
        // D s_1115_7: bit-extract s_1115_2 s_1115_0 s_1115_6
        let s_1115_7: Bits = (Bits::new(
            ((s_1115_2) >> (s_1115_0)).value(),
            u16::try_from(s_1115_6).unwrap(),
        ));
        // D s_1115_8: cast reint s_1115_7 -> u8
        let s_1115_8: u8 = (s_1115_7.value() as u8);
        // D s_1115_9: cast zx s_1115_8 -> bv
        let s_1115_9: Bits = Bits::new(s_1115_8 as u128, 6u16);
        // C s_1115_10: const #52u : u8
        let s_1115_10: u8 = 52;
        // C s_1115_11: cast zx s_1115_10 -> bv
        let s_1115_11: Bits = Bits::new(s_1115_10 as u128, 6u16);
        // D s_1115_12: cmp-eq s_1115_9 s_1115_11
        let s_1115_12: bool = ((s_1115_9) == (s_1115_11));
        // N s_1115_13: branch s_1115_12 b1118 b1116
        if s_1115_12 {
            return block_1118(state, tracer, fn_state);
        } else {
            return block_1116(state, tracer, fn_state);
        };
    }
    fn block_1116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1116_0: const #0u : u8
        let s_1116_0: bool = false;
        // D s_1116_1: write-var gs#412072 <= s_1116_0
        fn_state.gs_412072 = s_1116_0;
        // N s_1116_2: jump b1117
        return block_1117(state, tracer, fn_state);
    }
    fn block_1117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1117_0: read-var gs#412072:u8
        let s_1117_0: bool = fn_state.gs_412072;
        // D s_1117_1: write-var gs#412073 <= s_1117_0
        fn_state.gs_412073 = s_1117_0;
        // N s_1117_2: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_1118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1118_0: const #10s : i
        let s_1118_0: i128 = 10;
        // D s_1118_1: read-var u#34021:u32
        let s_1118_1: u32 = fn_state.u_34021;
        // D s_1118_2: cast zx s_1118_1 -> bv
        let s_1118_2: Bits = Bits::new(s_1118_1 as u128, 32u16);
        // C s_1118_3: const #1s : i64
        let s_1118_3: i64 = 1;
        // C s_1118_4: cast zx s_1118_3 -> i
        let s_1118_4: i128 = (i128::try_from(s_1118_3).unwrap());
        // C s_1118_5: const #1s : i
        let s_1118_5: i128 = 1;
        // C s_1118_6: add s_1118_5 s_1118_4
        let s_1118_6: i128 = (s_1118_5 + s_1118_4);
        // D s_1118_7: bit-extract s_1118_2 s_1118_0 s_1118_6
        let s_1118_7: Bits = (Bits::new(
            ((s_1118_2) >> (s_1118_0)).value(),
            u16::try_from(s_1118_6).unwrap(),
        ));
        // D s_1118_8: cast reint s_1118_7 -> u8
        let s_1118_8: u8 = (s_1118_7.value() as u8);
        // D s_1118_9: cast zx s_1118_8 -> bv
        let s_1118_9: Bits = Bits::new(s_1118_8 as u128, 2u16);
        // C s_1118_10: const #2u : u8
        let s_1118_10: u8 = 2;
        // C s_1118_11: cast zx s_1118_10 -> bv
        let s_1118_11: Bits = Bits::new(s_1118_10 as u128, 2u16);
        // D s_1118_12: cmp-eq s_1118_9 s_1118_11
        let s_1118_12: bool = ((s_1118_9) == (s_1118_11));
        // N s_1118_13: branch s_1118_12 b1121 b1119
        if s_1118_12 {
            return block_1121(state, tracer, fn_state);
        } else {
            return block_1119(state, tracer, fn_state);
        };
    }
    fn block_1119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1119_0: const #0u : u8
        let s_1119_0: bool = false;
        // D s_1119_1: write-var gs#412071 <= s_1119_0
        fn_state.gs_412071 = s_1119_0;
        // N s_1119_2: jump b1120
        return block_1120(state, tracer, fn_state);
    }
    fn block_1120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1120_0: read-var gs#412071:u8
        let s_1120_0: bool = fn_state.gs_412071;
        // D s_1120_1: write-var gs#412072 <= s_1120_0
        fn_state.gs_412072 = s_1120_0;
        // N s_1120_2: jump b1117
        return block_1117(state, tracer, fn_state);
    }
    fn block_1121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1121_0: const #6s : i
        let s_1121_0: i128 = 6;
        // D s_1121_1: read-var u#34021:u32
        let s_1121_1: u32 = fn_state.u_34021;
        // D s_1121_2: cast zx s_1121_1 -> bv
        let s_1121_2: Bits = Bits::new(s_1121_1 as u128, 32u16);
        // C s_1121_3: const #1s : i64
        let s_1121_3: i64 = 1;
        // C s_1121_4: cast zx s_1121_3 -> i
        let s_1121_4: i128 = (i128::try_from(s_1121_3).unwrap());
        // C s_1121_5: const #0s : i
        let s_1121_5: i128 = 0;
        // C s_1121_6: add s_1121_5 s_1121_4
        let s_1121_6: i128 = (s_1121_5 + s_1121_4);
        // D s_1121_7: bit-extract s_1121_2 s_1121_0 s_1121_6
        let s_1121_7: Bits = (Bits::new(
            ((s_1121_2) >> (s_1121_0)).value(),
            u16::try_from(s_1121_6).unwrap(),
        ));
        // D s_1121_8: cast reint s_1121_7 -> u8
        let s_1121_8: bool = ((s_1121_7.value()) != 0);
        // D s_1121_9: cast zx s_1121_8 -> bv
        let s_1121_9: Bits = Bits::new(s_1121_8 as u128, 1u16);
        // C s_1121_10: const #1u : u8
        let s_1121_10: bool = true;
        // C s_1121_11: cast zx s_1121_10 -> bv
        let s_1121_11: Bits = Bits::new(s_1121_10 as u128, 1u16);
        // D s_1121_12: cmp-eq s_1121_9 s_1121_11
        let s_1121_12: bool = ((s_1121_9) == (s_1121_11));
        // N s_1121_13: branch s_1121_12 b1124 b1122
        if s_1121_12 {
            return block_1124(state, tracer, fn_state);
        } else {
            return block_1122(state, tracer, fn_state);
        };
    }
    fn block_1122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1122_0: const #0u : u8
        let s_1122_0: bool = false;
        // D s_1122_1: write-var gs#412070 <= s_1122_0
        fn_state.gs_412070 = s_1122_0;
        // N s_1122_2: jump b1123
        return block_1123(state, tracer, fn_state);
    }
    fn block_1123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1123_0: read-var gs#412070:u8
        let s_1123_0: bool = fn_state.gs_412070;
        // D s_1123_1: write-var gs#412071 <= s_1123_0
        fn_state.gs_412071 = s_1123_0;
        // N s_1123_2: jump b1120
        return block_1120(state, tracer, fn_state);
    }
    fn block_1124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1124_0: const #4s : i
        let s_1124_0: i128 = 4;
        // D s_1124_1: read-var u#34021:u32
        let s_1124_1: u32 = fn_state.u_34021;
        // D s_1124_2: cast zx s_1124_1 -> bv
        let s_1124_2: Bits = Bits::new(s_1124_1 as u128, 32u16);
        // C s_1124_3: const #1s : i64
        let s_1124_3: i64 = 1;
        // C s_1124_4: cast zx s_1124_3 -> i
        let s_1124_4: i128 = (i128::try_from(s_1124_3).unwrap());
        // C s_1124_5: const #0s : i
        let s_1124_5: i128 = 0;
        // C s_1124_6: add s_1124_5 s_1124_4
        let s_1124_6: i128 = (s_1124_5 + s_1124_4);
        // D s_1124_7: bit-extract s_1124_2 s_1124_0 s_1124_6
        let s_1124_7: Bits = (Bits::new(
            ((s_1124_2) >> (s_1124_0)).value(),
            u16::try_from(s_1124_6).unwrap(),
        ));
        // D s_1124_8: cast reint s_1124_7 -> u8
        let s_1124_8: bool = ((s_1124_7.value()) != 0);
        // D s_1124_9: cast zx s_1124_8 -> bv
        let s_1124_9: Bits = Bits::new(s_1124_8 as u128, 1u16);
        // C s_1124_10: const #0u : u8
        let s_1124_10: bool = false;
        // C s_1124_11: cast zx s_1124_10 -> bv
        let s_1124_11: Bits = Bits::new(s_1124_10 as u128, 1u16);
        // D s_1124_12: cmp-eq s_1124_9 s_1124_11
        let s_1124_12: bool = ((s_1124_9) == (s_1124_11));
        // D s_1124_13: write-var gs#412070 <= s_1124_12
        fn_state.gs_412070 = s_1124_12;
        // N s_1124_14: jump b1123
        return block_1123(state, tracer, fn_state);
    }
    fn block_1125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1125_0: const #28s : i
        let s_1125_0: i128 = 28;
        // C s_1125_1: const #4s : i
        let s_1125_1: i128 = 4;
        // D s_1125_2: read-var u#34013:u32
        let s_1125_2: u32 = fn_state.u_34013;
        // D s_1125_3: cast zx s_1125_2 -> bv
        let s_1125_3: Bits = Bits::new(s_1125_2 as u128, 32u16);
        // D s_1125_4: bit-extract s_1125_3 s_1125_0 s_1125_1
        let s_1125_4: Bits = (Bits::new(
            ((s_1125_3) >> (s_1125_0)).value(),
            u16::try_from(s_1125_1).unwrap(),
        ));
        // D s_1125_5: cast reint s_1125_4 -> u8
        let s_1125_5: u8 = (s_1125_4.value() as u8);
        // D s_1125_6: cast zx s_1125_5 -> bv
        let s_1125_6: Bits = Bits::new(s_1125_5 as u128, 4u16);
        // C s_1125_7: const #15u : u8
        let s_1125_7: u8 = 15;
        // C s_1125_8: cast zx s_1125_7 -> bv
        let s_1125_8: Bits = Bits::new(s_1125_7 as u128, 4u16);
        // D s_1125_9: cmp-ne s_1125_6 s_1125_8
        let s_1125_9: bool = ((s_1125_6) != (s_1125_8));
        // N s_1125_10: branch s_1125_9 b1128 b1126
        if s_1125_9 {
            return block_1128(state, tracer, fn_state);
        } else {
            return block_1126(state, tracer, fn_state);
        };
    }
    fn block_1126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1126_0: const #0u : u8
        let s_1126_0: bool = false;
        // D s_1126_1: write-var gs#412039 <= s_1126_0
        fn_state.gs_412039 = s_1126_0;
        // N s_1126_2: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_1127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1127_0: read-var gs#412039:u8
        let s_1127_0: bool = fn_state.gs_412039;
        // D s_1127_1: write-var gs#412040 <= s_1127_0
        fn_state.gs_412040 = s_1127_0;
        // N s_1127_2: jump b56
        return block_56(state, tracer, fn_state);
    }
    fn block_1128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1128_0: const #3367s : i
        let s_1128_0: i128 = 3367;
        // C s_1128_1: const #14696u : u32
        let s_1128_1: u32 = 14696;
        // D s_1128_2: read-reg s_1128_1:i
        let s_1128_2: i128 = {
            let value = state.read_register::<i128>(s_1128_1 as isize);
            tracer.read_register(s_1128_1 as isize, value);
            value
        };
        // D s_1128_3: cmp-lt s_1128_2 s_1128_0
        let s_1128_3: bool = ((s_1128_2) < (s_1128_0));
        // D s_1128_4: write-var gs#412039 <= s_1128_3
        fn_state.gs_412039 = s_1128_3;
        // N s_1128_5: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_1129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1129_0: const #20s : i
        let s_1129_0: i128 = 20;
        // D s_1129_1: read-var u#34013:u32
        let s_1129_1: u32 = fn_state.u_34013;
        // D s_1129_2: cast zx s_1129_1 -> bv
        let s_1129_2: Bits = Bits::new(s_1129_1 as u128, 32u16);
        // C s_1129_3: const #1s : i64
        let s_1129_3: i64 = 1;
        // C s_1129_4: cast zx s_1129_3 -> i
        let s_1129_4: i128 = (i128::try_from(s_1129_3).unwrap());
        // C s_1129_5: const #1s : i
        let s_1129_5: i128 = 1;
        // C s_1129_6: add s_1129_5 s_1129_4
        let s_1129_6: i128 = (s_1129_5 + s_1129_4);
        // D s_1129_7: bit-extract s_1129_2 s_1129_0 s_1129_6
        let s_1129_7: Bits = (Bits::new(
            ((s_1129_2) >> (s_1129_0)).value(),
            u16::try_from(s_1129_6).unwrap(),
        ));
        // D s_1129_8: cast reint s_1129_7 -> u8
        let s_1129_8: u8 = (s_1129_7.value() as u8);
        // D s_1129_9: cast zx s_1129_8 -> bv
        let s_1129_9: Bits = Bits::new(s_1129_8 as u128, 2u16);
        // C s_1129_10: const #3u : u8
        let s_1129_10: u8 = 3;
        // C s_1129_11: cast zx s_1129_10 -> bv
        let s_1129_11: Bits = Bits::new(s_1129_10 as u128, 2u16);
        // D s_1129_12: cmp-eq s_1129_9 s_1129_11
        let s_1129_12: bool = ((s_1129_9) == (s_1129_11));
        // N s_1129_13: branch s_1129_12 b1132 b1130
        if s_1129_12 {
            return block_1132(state, tracer, fn_state);
        } else {
            return block_1130(state, tracer, fn_state);
        };
    }
    fn block_1130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1130_0: const #0u : u8
        let s_1130_0: bool = false;
        // D s_1130_1: write-var gs#412034 <= s_1130_0
        fn_state.gs_412034 = s_1130_0;
        // N s_1130_2: jump b1131
        return block_1131(state, tracer, fn_state);
    }
    fn block_1131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1131_0: read-var gs#412034:u8
        let s_1131_0: bool = fn_state.gs_412034;
        // D s_1131_1: write-var gs#412035 <= s_1131_0
        fn_state.gs_412035 = s_1131_0;
        // N s_1131_2: jump b54
        return block_54(state, tracer, fn_state);
    }
    fn block_1132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1132_0: const #10s : i
        let s_1132_0: i128 = 10;
        // D s_1132_1: read-var u#34013:u32
        let s_1132_1: u32 = fn_state.u_34013;
        // D s_1132_2: cast zx s_1132_1 -> bv
        let s_1132_2: Bits = Bits::new(s_1132_1 as u128, 32u16);
        // C s_1132_3: const #1s : i64
        let s_1132_3: i64 = 1;
        // C s_1132_4: cast zx s_1132_3 -> i
        let s_1132_4: i128 = (i128::try_from(s_1132_3).unwrap());
        // C s_1132_5: const #1s : i
        let s_1132_5: i128 = 1;
        // C s_1132_6: add s_1132_5 s_1132_4
        let s_1132_6: i128 = (s_1132_5 + s_1132_4);
        // D s_1132_7: bit-extract s_1132_2 s_1132_0 s_1132_6
        let s_1132_7: Bits = (Bits::new(
            ((s_1132_2) >> (s_1132_0)).value(),
            u16::try_from(s_1132_6).unwrap(),
        ));
        // D s_1132_8: cast reint s_1132_7 -> u8
        let s_1132_8: u8 = (s_1132_7.value() as u8);
        // D s_1132_9: cast zx s_1132_8 -> bv
        let s_1132_9: Bits = Bits::new(s_1132_8 as u128, 2u16);
        // C s_1132_10: const #2u : u8
        let s_1132_10: u8 = 2;
        // C s_1132_11: cast zx s_1132_10 -> bv
        let s_1132_11: Bits = Bits::new(s_1132_10 as u128, 2u16);
        // D s_1132_12: cmp-eq s_1132_9 s_1132_11
        let s_1132_12: bool = ((s_1132_9) == (s_1132_11));
        // N s_1132_13: branch s_1132_12 b1135 b1133
        if s_1132_12 {
            return block_1135(state, tracer, fn_state);
        } else {
            return block_1133(state, tracer, fn_state);
        };
    }
    fn block_1133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1133_0: const #0u : u8
        let s_1133_0: bool = false;
        // D s_1133_1: write-var gs#412033 <= s_1133_0
        fn_state.gs_412033 = s_1133_0;
        // N s_1133_2: jump b1134
        return block_1134(state, tracer, fn_state);
    }
    fn block_1134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1134_0: read-var gs#412033:u8
        let s_1134_0: bool = fn_state.gs_412033;
        // D s_1134_1: write-var gs#412034 <= s_1134_0
        fn_state.gs_412034 = s_1134_0;
        // N s_1134_2: jump b1131
        return block_1131(state, tracer, fn_state);
    }
    fn block_1135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1135_0: const #6s : i
        let s_1135_0: i128 = 6;
        // D s_1135_1: read-var u#34013:u32
        let s_1135_1: u32 = fn_state.u_34013;
        // D s_1135_2: cast zx s_1135_1 -> bv
        let s_1135_2: Bits = Bits::new(s_1135_1 as u128, 32u16);
        // C s_1135_3: const #1s : i64
        let s_1135_3: i64 = 1;
        // C s_1135_4: cast zx s_1135_3 -> i
        let s_1135_4: i128 = (i128::try_from(s_1135_3).unwrap());
        // C s_1135_5: const #0s : i
        let s_1135_5: i128 = 0;
        // C s_1135_6: add s_1135_5 s_1135_4
        let s_1135_6: i128 = (s_1135_5 + s_1135_4);
        // D s_1135_7: bit-extract s_1135_2 s_1135_0 s_1135_6
        let s_1135_7: Bits = (Bits::new(
            ((s_1135_2) >> (s_1135_0)).value(),
            u16::try_from(s_1135_6).unwrap(),
        ));
        // D s_1135_8: cast reint s_1135_7 -> u8
        let s_1135_8: bool = ((s_1135_7.value()) != 0);
        // D s_1135_9: cast zx s_1135_8 -> bv
        let s_1135_9: Bits = Bits::new(s_1135_8 as u128, 1u16);
        // C s_1135_10: const #0u : u8
        let s_1135_10: bool = false;
        // C s_1135_11: cast zx s_1135_10 -> bv
        let s_1135_11: Bits = Bits::new(s_1135_10 as u128, 1u16);
        // D s_1135_12: cmp-eq s_1135_9 s_1135_11
        let s_1135_12: bool = ((s_1135_9) == (s_1135_11));
        // N s_1135_13: branch s_1135_12 b1138 b1136
        if s_1135_12 {
            return block_1138(state, tracer, fn_state);
        } else {
            return block_1136(state, tracer, fn_state);
        };
    }
    fn block_1136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1136_0: const #0u : u8
        let s_1136_0: bool = false;
        // D s_1136_1: write-var gs#412032 <= s_1136_0
        fn_state.gs_412032 = s_1136_0;
        // N s_1136_2: jump b1137
        return block_1137(state, tracer, fn_state);
    }
    fn block_1137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1137_0: read-var gs#412032:u8
        let s_1137_0: bool = fn_state.gs_412032;
        // D s_1137_1: write-var gs#412033 <= s_1137_0
        fn_state.gs_412033 = s_1137_0;
        // N s_1137_2: jump b1134
        return block_1134(state, tracer, fn_state);
    }
    fn block_1138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1138_0: const #4s : i
        let s_1138_0: i128 = 4;
        // D s_1138_1: read-var u#34013:u32
        let s_1138_1: u32 = fn_state.u_34013;
        // D s_1138_2: cast zx s_1138_1 -> bv
        let s_1138_2: Bits = Bits::new(s_1138_1 as u128, 32u16);
        // C s_1138_3: const #1s : i64
        let s_1138_3: i64 = 1;
        // C s_1138_4: cast zx s_1138_3 -> i
        let s_1138_4: i128 = (i128::try_from(s_1138_3).unwrap());
        // C s_1138_5: const #0s : i
        let s_1138_5: i128 = 0;
        // C s_1138_6: add s_1138_5 s_1138_4
        let s_1138_6: i128 = (s_1138_5 + s_1138_4);
        // D s_1138_7: bit-extract s_1138_2 s_1138_0 s_1138_6
        let s_1138_7: Bits = (Bits::new(
            ((s_1138_2) >> (s_1138_0)).value(),
            u16::try_from(s_1138_6).unwrap(),
        ));
        // D s_1138_8: cast reint s_1138_7 -> u8
        let s_1138_8: bool = ((s_1138_7.value()) != 0);
        // D s_1138_9: cast zx s_1138_8 -> bv
        let s_1138_9: Bits = Bits::new(s_1138_8 as u128, 1u16);
        // C s_1138_10: const #0u : u8
        let s_1138_10: bool = false;
        // C s_1138_11: cast zx s_1138_10 -> bv
        let s_1138_11: Bits = Bits::new(s_1138_10 as u128, 1u16);
        // D s_1138_12: cmp-eq s_1138_9 s_1138_11
        let s_1138_12: bool = ((s_1138_9) == (s_1138_11));
        // D s_1138_13: write-var gs#412032 <= s_1138_12
        fn_state.gs_412032 = s_1138_12;
        // N s_1138_14: jump b1137
        return block_1137(state, tracer, fn_state);
    }
    fn block_1139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1139_0: const #28s : i
        let s_1139_0: i128 = 28;
        // C s_1139_1: const #4s : i
        let s_1139_1: i128 = 4;
        // D s_1139_2: read-var u#34010:u32
        let s_1139_2: u32 = fn_state.u_34010;
        // D s_1139_3: cast zx s_1139_2 -> bv
        let s_1139_3: Bits = Bits::new(s_1139_2 as u128, 32u16);
        // D s_1139_4: bit-extract s_1139_3 s_1139_0 s_1139_1
        let s_1139_4: Bits = (Bits::new(
            ((s_1139_3) >> (s_1139_0)).value(),
            u16::try_from(s_1139_1).unwrap(),
        ));
        // D s_1139_5: cast reint s_1139_4 -> u8
        let s_1139_5: u8 = (s_1139_4.value() as u8);
        // D s_1139_6: cast zx s_1139_5 -> bv
        let s_1139_6: Bits = Bits::new(s_1139_5 as u128, 4u16);
        // C s_1139_7: const #15u : u8
        let s_1139_7: u8 = 15;
        // C s_1139_8: cast zx s_1139_7 -> bv
        let s_1139_8: Bits = Bits::new(s_1139_7 as u128, 4u16);
        // D s_1139_9: cmp-ne s_1139_6 s_1139_8
        let s_1139_9: bool = ((s_1139_6) != (s_1139_8));
        // N s_1139_10: branch s_1139_9 b1142 b1140
        if s_1139_9 {
            return block_1142(state, tracer, fn_state);
        } else {
            return block_1140(state, tracer, fn_state);
        };
    }
    fn block_1140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1140_0: const #0u : u8
        let s_1140_0: bool = false;
        // D s_1140_1: write-var gs#412005 <= s_1140_0
        fn_state.gs_412005 = s_1140_0;
        // N s_1140_2: jump b1141
        return block_1141(state, tracer, fn_state);
    }
    fn block_1141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1141_0: read-var gs#412005:u8
        let s_1141_0: bool = fn_state.gs_412005;
        // D s_1141_1: write-var gs#412006 <= s_1141_0
        fn_state.gs_412006 = s_1141_0;
        // N s_1141_2: jump b50
        return block_50(state, tracer, fn_state);
    }
    fn block_1142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1142_0: const #3361s : i
        let s_1142_0: i128 = 3361;
        // C s_1142_1: const #14696u : u32
        let s_1142_1: u32 = 14696;
        // D s_1142_2: read-reg s_1142_1:i
        let s_1142_2: i128 = {
            let value = state.read_register::<i128>(s_1142_1 as isize);
            tracer.read_register(s_1142_1 as isize, value);
            value
        };
        // D s_1142_3: cmp-lt s_1142_2 s_1142_0
        let s_1142_3: bool = ((s_1142_2) < (s_1142_0));
        // D s_1142_4: write-var gs#412005 <= s_1142_3
        fn_state.gs_412005 = s_1142_3;
        // N s_1142_5: jump b1141
        return block_1141(state, tracer, fn_state);
    }
    fn block_1143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1143_0: const #16s : i
        let s_1143_0: i128 = 16;
        // D s_1143_1: read-var u#34010:u32
        let s_1143_1: u32 = fn_state.u_34010;
        // D s_1143_2: cast zx s_1143_1 -> bv
        let s_1143_2: Bits = Bits::new(s_1143_1 as u128, 32u16);
        // C s_1143_3: const #1s : i64
        let s_1143_3: i64 = 1;
        // C s_1143_4: cast zx s_1143_3 -> i
        let s_1143_4: i128 = (i128::try_from(s_1143_3).unwrap());
        // C s_1143_5: const #5s : i
        let s_1143_5: i128 = 5;
        // C s_1143_6: add s_1143_5 s_1143_4
        let s_1143_6: i128 = (s_1143_5 + s_1143_4);
        // D s_1143_7: bit-extract s_1143_2 s_1143_0 s_1143_6
        let s_1143_7: Bits = (Bits::new(
            ((s_1143_2) >> (s_1143_0)).value(),
            u16::try_from(s_1143_6).unwrap(),
        ));
        // D s_1143_8: cast reint s_1143_7 -> u8
        let s_1143_8: u8 = (s_1143_7.value() as u8);
        // D s_1143_9: cast zx s_1143_8 -> bv
        let s_1143_9: Bits = Bits::new(s_1143_8 as u128, 6u16);
        // C s_1143_10: const #48u : u8
        let s_1143_10: u8 = 48;
        // C s_1143_11: cast zx s_1143_10 -> bv
        let s_1143_11: Bits = Bits::new(s_1143_10 as u128, 6u16);
        // D s_1143_12: cmp-eq s_1143_9 s_1143_11
        let s_1143_12: bool = ((s_1143_9) == (s_1143_11));
        // N s_1143_13: branch s_1143_12 b1146 b1144
        if s_1143_12 {
            return block_1146(state, tracer, fn_state);
        } else {
            return block_1144(state, tracer, fn_state);
        };
    }
    fn block_1144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1144_0: const #0u : u8
        let s_1144_0: bool = false;
        // D s_1144_1: write-var gs#412000 <= s_1144_0
        fn_state.gs_412000 = s_1144_0;
        // N s_1144_2: jump b1145
        return block_1145(state, tracer, fn_state);
    }
    fn block_1145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1145_0: read-var gs#412000:u8
        let s_1145_0: bool = fn_state.gs_412000;
        // D s_1145_1: write-var gs#412001 <= s_1145_0
        fn_state.gs_412001 = s_1145_0;
        // N s_1145_2: jump b48
        return block_48(state, tracer, fn_state);
    }
    fn block_1146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1146_0: const #10s : i
        let s_1146_0: i128 = 10;
        // D s_1146_1: read-var u#34010:u32
        let s_1146_1: u32 = fn_state.u_34010;
        // D s_1146_2: cast zx s_1146_1 -> bv
        let s_1146_2: Bits = Bits::new(s_1146_1 as u128, 32u16);
        // C s_1146_3: const #1s : i64
        let s_1146_3: i64 = 1;
        // C s_1146_4: cast zx s_1146_3 -> i
        let s_1146_4: i128 = (i128::try_from(s_1146_3).unwrap());
        // C s_1146_5: const #1s : i
        let s_1146_5: i128 = 1;
        // C s_1146_6: add s_1146_5 s_1146_4
        let s_1146_6: i128 = (s_1146_5 + s_1146_4);
        // D s_1146_7: bit-extract s_1146_2 s_1146_0 s_1146_6
        let s_1146_7: Bits = (Bits::new(
            ((s_1146_2) >> (s_1146_0)).value(),
            u16::try_from(s_1146_6).unwrap(),
        ));
        // D s_1146_8: cast reint s_1146_7 -> u8
        let s_1146_8: u8 = (s_1146_7.value() as u8);
        // D s_1146_9: cast zx s_1146_8 -> bv
        let s_1146_9: Bits = Bits::new(s_1146_8 as u128, 2u16);
        // C s_1146_10: const #2u : u8
        let s_1146_10: u8 = 2;
        // C s_1146_11: cast zx s_1146_10 -> bv
        let s_1146_11: Bits = Bits::new(s_1146_10 as u128, 2u16);
        // D s_1146_12: cmp-eq s_1146_9 s_1146_11
        let s_1146_12: bool = ((s_1146_9) == (s_1146_11));
        // N s_1146_13: branch s_1146_12 b1149 b1147
        if s_1146_12 {
            return block_1149(state, tracer, fn_state);
        } else {
            return block_1147(state, tracer, fn_state);
        };
    }
    fn block_1147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1147_0: const #0u : u8
        let s_1147_0: bool = false;
        // D s_1147_1: write-var gs#411999 <= s_1147_0
        fn_state.gs_411999 = s_1147_0;
        // N s_1147_2: jump b1148
        return block_1148(state, tracer, fn_state);
    }
    fn block_1148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1148_0: read-var gs#411999:u8
        let s_1148_0: bool = fn_state.gs_411999;
        // D s_1148_1: write-var gs#412000 <= s_1148_0
        fn_state.gs_412000 = s_1148_0;
        // N s_1148_2: jump b1145
        return block_1145(state, tracer, fn_state);
    }
    fn block_1149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1149_0: const #6s : i
        let s_1149_0: i128 = 6;
        // D s_1149_1: read-var u#34010:u32
        let s_1149_1: u32 = fn_state.u_34010;
        // D s_1149_2: cast zx s_1149_1 -> bv
        let s_1149_2: Bits = Bits::new(s_1149_1 as u128, 32u16);
        // C s_1149_3: const #1s : i64
        let s_1149_3: i64 = 1;
        // C s_1149_4: cast zx s_1149_3 -> i
        let s_1149_4: i128 = (i128::try_from(s_1149_3).unwrap());
        // C s_1149_5: const #1s : i
        let s_1149_5: i128 = 1;
        // C s_1149_6: add s_1149_5 s_1149_4
        let s_1149_6: i128 = (s_1149_5 + s_1149_4);
        // D s_1149_7: bit-extract s_1149_2 s_1149_0 s_1149_6
        let s_1149_7: Bits = (Bits::new(
            ((s_1149_2) >> (s_1149_0)).value(),
            u16::try_from(s_1149_6).unwrap(),
        ));
        // D s_1149_8: cast reint s_1149_7 -> u8
        let s_1149_8: u8 = (s_1149_7.value() as u8);
        // D s_1149_9: cast zx s_1149_8 -> bv
        let s_1149_9: Bits = Bits::new(s_1149_8 as u128, 2u16);
        // C s_1149_10: const #3u : u8
        let s_1149_10: u8 = 3;
        // C s_1149_11: cast zx s_1149_10 -> bv
        let s_1149_11: Bits = Bits::new(s_1149_10 as u128, 2u16);
        // D s_1149_12: cmp-eq s_1149_9 s_1149_11
        let s_1149_12: bool = ((s_1149_9) == (s_1149_11));
        // N s_1149_13: branch s_1149_12 b1152 b1150
        if s_1149_12 {
            return block_1152(state, tracer, fn_state);
        } else {
            return block_1150(state, tracer, fn_state);
        };
    }
    fn block_1150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1150_0: const #0u : u8
        let s_1150_0: bool = false;
        // D s_1150_1: write-var gs#411998 <= s_1150_0
        fn_state.gs_411998 = s_1150_0;
        // N s_1150_2: jump b1151
        return block_1151(state, tracer, fn_state);
    }
    fn block_1151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1151_0: read-var gs#411998:u8
        let s_1151_0: bool = fn_state.gs_411998;
        // D s_1151_1: write-var gs#411999 <= s_1151_0
        fn_state.gs_411999 = s_1151_0;
        // N s_1151_2: jump b1148
        return block_1148(state, tracer, fn_state);
    }
    fn block_1152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1152_0: const #4s : i
        let s_1152_0: i128 = 4;
        // D s_1152_1: read-var u#34010:u32
        let s_1152_1: u32 = fn_state.u_34010;
        // D s_1152_2: cast zx s_1152_1 -> bv
        let s_1152_2: Bits = Bits::new(s_1152_1 as u128, 32u16);
        // C s_1152_3: const #1s : i64
        let s_1152_3: i64 = 1;
        // C s_1152_4: cast zx s_1152_3 -> i
        let s_1152_4: i128 = (i128::try_from(s_1152_3).unwrap());
        // C s_1152_5: const #0s : i
        let s_1152_5: i128 = 0;
        // C s_1152_6: add s_1152_5 s_1152_4
        let s_1152_6: i128 = (s_1152_5 + s_1152_4);
        // D s_1152_7: bit-extract s_1152_2 s_1152_0 s_1152_6
        let s_1152_7: Bits = (Bits::new(
            ((s_1152_2) >> (s_1152_0)).value(),
            u16::try_from(s_1152_6).unwrap(),
        ));
        // D s_1152_8: cast reint s_1152_7 -> u8
        let s_1152_8: bool = ((s_1152_7.value()) != 0);
        // D s_1152_9: cast zx s_1152_8 -> bv
        let s_1152_9: Bits = Bits::new(s_1152_8 as u128, 1u16);
        // C s_1152_10: const #0u : u8
        let s_1152_10: bool = false;
        // C s_1152_11: cast zx s_1152_10 -> bv
        let s_1152_11: Bits = Bits::new(s_1152_10 as u128, 1u16);
        // D s_1152_12: cmp-eq s_1152_9 s_1152_11
        let s_1152_12: bool = ((s_1152_9) == (s_1152_11));
        // D s_1152_13: write-var gs#411998 <= s_1152_12
        fn_state.gs_411998 = s_1152_12;
        // N s_1152_14: jump b1151
        return block_1151(state, tracer, fn_state);
    }
    fn block_1153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1153_0: const #28s : i
        let s_1153_0: i128 = 28;
        // C s_1153_1: const #4s : i
        let s_1153_1: i128 = 4;
        // D s_1153_2: read-var u#34007:u32
        let s_1153_2: u32 = fn_state.u_34007;
        // D s_1153_3: cast zx s_1153_2 -> bv
        let s_1153_3: Bits = Bits::new(s_1153_2 as u128, 32u16);
        // D s_1153_4: bit-extract s_1153_3 s_1153_0 s_1153_1
        let s_1153_4: Bits = (Bits::new(
            ((s_1153_3) >> (s_1153_0)).value(),
            u16::try_from(s_1153_1).unwrap(),
        ));
        // D s_1153_5: cast reint s_1153_4 -> u8
        let s_1153_5: u8 = (s_1153_4.value() as u8);
        // D s_1153_6: cast zx s_1153_5 -> bv
        let s_1153_6: Bits = Bits::new(s_1153_5 as u128, 4u16);
        // C s_1153_7: const #15u : u8
        let s_1153_7: u8 = 15;
        // C s_1153_8: cast zx s_1153_7 -> bv
        let s_1153_8: Bits = Bits::new(s_1153_7 as u128, 4u16);
        // D s_1153_9: cmp-ne s_1153_6 s_1153_8
        let s_1153_9: bool = ((s_1153_6) != (s_1153_8));
        // N s_1153_10: branch s_1153_9 b1156 b1154
        if s_1153_9 {
            return block_1156(state, tracer, fn_state);
        } else {
            return block_1154(state, tracer, fn_state);
        };
    }
    fn block_1154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1154_0: const #0u : u8
        let s_1154_0: bool = false;
        // D s_1154_1: write-var gs#411979 <= s_1154_0
        fn_state.gs_411979 = s_1154_0;
        // N s_1154_2: jump b1155
        return block_1155(state, tracer, fn_state);
    }
    fn block_1155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1155_0: read-var gs#411979:u8
        let s_1155_0: bool = fn_state.gs_411979;
        // D s_1155_1: write-var gs#411980 <= s_1155_0
        fn_state.gs_411980 = s_1155_0;
        // N s_1155_2: jump b44
        return block_44(state, tracer, fn_state);
    }
    fn block_1156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1156_0: const #3251s : i
        let s_1156_0: i128 = 3251;
        // C s_1156_1: const #14696u : u32
        let s_1156_1: u32 = 14696;
        // D s_1156_2: read-reg s_1156_1:i
        let s_1156_2: i128 = {
            let value = state.read_register::<i128>(s_1156_1 as isize);
            tracer.read_register(s_1156_1 as isize, value);
            value
        };
        // D s_1156_3: cmp-lt s_1156_2 s_1156_0
        let s_1156_3: bool = ((s_1156_2) < (s_1156_0));
        // D s_1156_4: write-var gs#411979 <= s_1156_3
        fn_state.gs_411979 = s_1156_3;
        // N s_1156_5: jump b1155
        return block_1155(state, tracer, fn_state);
    }
    fn block_1157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1157_0: const #28s : i
        let s_1157_0: i128 = 28;
        // C s_1157_1: const #4s : i
        let s_1157_1: i128 = 4;
        // D s_1157_2: read-var u#33999:u32
        let s_1157_2: u32 = fn_state.u_33999;
        // D s_1157_3: cast zx s_1157_2 -> bv
        let s_1157_3: Bits = Bits::new(s_1157_2 as u128, 32u16);
        // D s_1157_4: bit-extract s_1157_3 s_1157_0 s_1157_1
        let s_1157_4: Bits = (Bits::new(
            ((s_1157_3) >> (s_1157_0)).value(),
            u16::try_from(s_1157_1).unwrap(),
        ));
        // D s_1157_5: cast reint s_1157_4 -> u8
        let s_1157_5: u8 = (s_1157_4.value() as u8);
        // D s_1157_6: cast zx s_1157_5 -> bv
        let s_1157_6: Bits = Bits::new(s_1157_5 as u128, 4u16);
        // C s_1157_7: const #15u : u8
        let s_1157_7: u8 = 15;
        // C s_1157_8: cast zx s_1157_7 -> bv
        let s_1157_8: Bits = Bits::new(s_1157_7 as u128, 4u16);
        // D s_1157_9: cmp-ne s_1157_6 s_1157_8
        let s_1157_9: bool = ((s_1157_6) != (s_1157_8));
        // N s_1157_10: branch s_1157_9 b1160 b1158
        if s_1157_9 {
            return block_1160(state, tracer, fn_state);
        } else {
            return block_1158(state, tracer, fn_state);
        };
    }
    fn block_1158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1158_0: const #0u : u8
        let s_1158_0: bool = false;
        // D s_1158_1: write-var gs#411957 <= s_1158_0
        fn_state.gs_411957 = s_1158_0;
        // N s_1158_2: jump b1159
        return block_1159(state, tracer, fn_state);
    }
    fn block_1159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1159_0: read-var gs#411957:u8
        let s_1159_0: bool = fn_state.gs_411957;
        // D s_1159_1: write-var gs#411958 <= s_1159_0
        fn_state.gs_411958 = s_1159_0;
        // N s_1159_2: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_1160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1160_0: const #3184s : i
        let s_1160_0: i128 = 3184;
        // C s_1160_1: const #14696u : u32
        let s_1160_1: u32 = 14696;
        // D s_1160_2: read-reg s_1160_1:i
        let s_1160_2: i128 = {
            let value = state.read_register::<i128>(s_1160_1 as isize);
            tracer.read_register(s_1160_1 as isize, value);
            value
        };
        // D s_1160_3: cmp-lt s_1160_2 s_1160_0
        let s_1160_3: bool = ((s_1160_2) < (s_1160_0));
        // D s_1160_4: write-var gs#411957 <= s_1160_3
        fn_state.gs_411957 = s_1160_3;
        // N s_1160_5: jump b1159
        return block_1159(state, tracer, fn_state);
    }
    fn block_1161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1161_0: const #22s : i
        let s_1161_0: i128 = 22;
        // D s_1161_1: read-var u#33999:u32
        let s_1161_1: u32 = fn_state.u_33999;
        // D s_1161_2: cast zx s_1161_1 -> bv
        let s_1161_2: Bits = Bits::new(s_1161_1 as u128, 32u16);
        // C s_1161_3: const #1s : i64
        let s_1161_3: i64 = 1;
        // C s_1161_4: cast zx s_1161_3 -> i
        let s_1161_4: i128 = (i128::try_from(s_1161_3).unwrap());
        // C s_1161_5: const #0s : i
        let s_1161_5: i128 = 0;
        // C s_1161_6: add s_1161_5 s_1161_4
        let s_1161_6: i128 = (s_1161_5 + s_1161_4);
        // D s_1161_7: bit-extract s_1161_2 s_1161_0 s_1161_6
        let s_1161_7: Bits = (Bits::new(
            ((s_1161_2) >> (s_1161_0)).value(),
            u16::try_from(s_1161_6).unwrap(),
        ));
        // D s_1161_8: cast reint s_1161_7 -> u8
        let s_1161_8: bool = ((s_1161_7.value()) != 0);
        // D s_1161_9: cast zx s_1161_8 -> bv
        let s_1161_9: Bits = Bits::new(s_1161_8 as u128, 1u16);
        // C s_1161_10: const #0u : u8
        let s_1161_10: bool = false;
        // C s_1161_11: cast zx s_1161_10 -> bv
        let s_1161_11: Bits = Bits::new(s_1161_10 as u128, 1u16);
        // D s_1161_12: cmp-eq s_1161_9 s_1161_11
        let s_1161_12: bool = ((s_1161_9) == (s_1161_11));
        // N s_1161_13: branch s_1161_12 b1164 b1162
        if s_1161_12 {
            return block_1164(state, tracer, fn_state);
        } else {
            return block_1162(state, tracer, fn_state);
        };
    }
    fn block_1162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1162_0: const #0u : u8
        let s_1162_0: bool = false;
        // D s_1162_1: write-var gs#411952 <= s_1162_0
        fn_state.gs_411952 = s_1162_0;
        // N s_1162_2: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_1163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1163_0: read-var gs#411952:u8
        let s_1163_0: bool = fn_state.gs_411952;
        // D s_1163_1: write-var gs#411953 <= s_1163_0
        fn_state.gs_411953 = s_1163_0;
        // N s_1163_2: jump b38
        return block_38(state, tracer, fn_state);
    }
    fn block_1164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1164_0: const #20s : i
        let s_1164_0: i128 = 20;
        // D s_1164_1: read-var u#33999:u32
        let s_1164_1: u32 = fn_state.u_33999;
        // D s_1164_2: cast zx s_1164_1 -> bv
        let s_1164_2: Bits = Bits::new(s_1164_1 as u128, 32u16);
        // C s_1164_3: const #1s : i64
        let s_1164_3: i64 = 1;
        // C s_1164_4: cast zx s_1164_3 -> i
        let s_1164_4: i128 = (i128::try_from(s_1164_3).unwrap());
        // C s_1164_5: const #0s : i
        let s_1164_5: i128 = 0;
        // C s_1164_6: add s_1164_5 s_1164_4
        let s_1164_6: i128 = (s_1164_5 + s_1164_4);
        // D s_1164_7: bit-extract s_1164_2 s_1164_0 s_1164_6
        let s_1164_7: Bits = (Bits::new(
            ((s_1164_2) >> (s_1164_0)).value(),
            u16::try_from(s_1164_6).unwrap(),
        ));
        // D s_1164_8: cast reint s_1164_7 -> u8
        let s_1164_8: bool = ((s_1164_7.value()) != 0);
        // D s_1164_9: cast zx s_1164_8 -> bv
        let s_1164_9: Bits = Bits::new(s_1164_8 as u128, 1u16);
        // C s_1164_10: const #0u : u8
        let s_1164_10: bool = false;
        // C s_1164_11: cast zx s_1164_10 -> bv
        let s_1164_11: Bits = Bits::new(s_1164_10 as u128, 1u16);
        // D s_1164_12: cmp-eq s_1164_9 s_1164_11
        let s_1164_12: bool = ((s_1164_9) == (s_1164_11));
        // N s_1164_13: branch s_1164_12 b1167 b1165
        if s_1164_12 {
            return block_1167(state, tracer, fn_state);
        } else {
            return block_1165(state, tracer, fn_state);
        };
    }
    fn block_1165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1165_0: const #0u : u8
        let s_1165_0: bool = false;
        // D s_1165_1: write-var gs#411951 <= s_1165_0
        fn_state.gs_411951 = s_1165_0;
        // N s_1165_2: jump b1166
        return block_1166(state, tracer, fn_state);
    }
    fn block_1166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1166_0: read-var gs#411951:u8
        let s_1166_0: bool = fn_state.gs_411951;
        // D s_1166_1: write-var gs#411952 <= s_1166_0
        fn_state.gs_411952 = s_1166_0;
        // N s_1166_2: jump b1163
        return block_1163(state, tracer, fn_state);
    }
    fn block_1167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1167_0: const #8s : i
        let s_1167_0: i128 = 8;
        // D s_1167_1: read-var u#33999:u32
        let s_1167_1: u32 = fn_state.u_33999;
        // D s_1167_2: cast zx s_1167_1 -> bv
        let s_1167_2: Bits = Bits::new(s_1167_1 as u128, 32u16);
        // C s_1167_3: const #1s : i64
        let s_1167_3: i64 = 1;
        // C s_1167_4: cast zx s_1167_3 -> i
        let s_1167_4: i128 = (i128::try_from(s_1167_3).unwrap());
        // C s_1167_5: const #7s : i
        let s_1167_5: i128 = 7;
        // C s_1167_6: add s_1167_5 s_1167_4
        let s_1167_6: i128 = (s_1167_5 + s_1167_4);
        // D s_1167_7: bit-extract s_1167_2 s_1167_0 s_1167_6
        let s_1167_7: Bits = (Bits::new(
            ((s_1167_2) >> (s_1167_0)).value(),
            u16::try_from(s_1167_6).unwrap(),
        ));
        // D s_1167_8: cast reint s_1167_7 -> u8
        let s_1167_8: u8 = (s_1167_7.value() as u8);
        // D s_1167_9: cast zx s_1167_8 -> bv
        let s_1167_9: Bits = Bits::new(s_1167_8 as u128, 8u16);
        // C s_1167_10: const #94u : u8
        let s_1167_10: u8 = 94;
        // C s_1167_11: cast zx s_1167_10 -> bv
        let s_1167_11: Bits = Bits::new(s_1167_10 as u128, 8u16);
        // D s_1167_12: cmp-eq s_1167_9 s_1167_11
        let s_1167_12: bool = ((s_1167_9) == (s_1167_11));
        // D s_1167_13: write-var gs#411951 <= s_1167_12
        fn_state.gs_411951 = s_1167_12;
        // N s_1167_14: jump b1166
        return block_1166(state, tracer, fn_state);
    }
    fn block_1168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1168_0: const #28s : i
        let s_1168_0: i128 = 28;
        // C s_1168_1: const #4s : i
        let s_1168_1: i128 = 4;
        // D s_1168_2: read-var u#33991:u32
        let s_1168_2: u32 = fn_state.u_33991;
        // D s_1168_3: cast zx s_1168_2 -> bv
        let s_1168_3: Bits = Bits::new(s_1168_2 as u128, 32u16);
        // D s_1168_4: bit-extract s_1168_3 s_1168_0 s_1168_1
        let s_1168_4: Bits = (Bits::new(
            ((s_1168_3) >> (s_1168_0)).value(),
            u16::try_from(s_1168_1).unwrap(),
        ));
        // D s_1168_5: cast reint s_1168_4 -> u8
        let s_1168_5: u8 = (s_1168_4.value() as u8);
        // D s_1168_6: cast zx s_1168_5 -> bv
        let s_1168_6: Bits = Bits::new(s_1168_5 as u128, 4u16);
        // C s_1168_7: const #15u : u8
        let s_1168_7: u8 = 15;
        // C s_1168_8: cast zx s_1168_7 -> bv
        let s_1168_8: Bits = Bits::new(s_1168_7 as u128, 4u16);
        // D s_1168_9: cmp-ne s_1168_6 s_1168_8
        let s_1168_9: bool = ((s_1168_6) != (s_1168_8));
        // N s_1168_10: branch s_1168_9 b1171 b1169
        if s_1168_9 {
            return block_1171(state, tracer, fn_state);
        } else {
            return block_1169(state, tracer, fn_state);
        };
    }
    fn block_1169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1169_0: const #0u : u8
        let s_1169_0: bool = false;
        // D s_1169_1: write-var gs#411926 <= s_1169_0
        fn_state.gs_411926 = s_1169_0;
        // N s_1169_2: jump b1170
        return block_1170(state, tracer, fn_state);
    }
    fn block_1170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1170_0: read-var gs#411926:u8
        let s_1170_0: bool = fn_state.gs_411926;
        // D s_1170_1: write-var gs#411927 <= s_1170_0
        fn_state.gs_411927 = s_1170_0;
        // N s_1170_2: jump b34
        return block_34(state, tracer, fn_state);
    }
    fn block_1171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1171_0: const #3025s : i
        let s_1171_0: i128 = 3025;
        // C s_1171_1: const #14696u : u32
        let s_1171_1: u32 = 14696;
        // D s_1171_2: read-reg s_1171_1:i
        let s_1171_2: i128 = {
            let value = state.read_register::<i128>(s_1171_1 as isize);
            tracer.read_register(s_1171_1 as isize, value);
            value
        };
        // D s_1171_3: cmp-lt s_1171_2 s_1171_0
        let s_1171_3: bool = ((s_1171_2) < (s_1171_0));
        // D s_1171_4: write-var gs#411926 <= s_1171_3
        fn_state.gs_411926 = s_1171_3;
        // N s_1171_5: jump b1170
        return block_1170(state, tracer, fn_state);
    }
    fn block_1172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1172_0: const #9s : i
        let s_1172_0: i128 = 9;
        // D s_1172_1: read-var u#33991:u32
        let s_1172_1: u32 = fn_state.u_33991;
        // D s_1172_2: cast zx s_1172_1 -> bv
        let s_1172_2: Bits = Bits::new(s_1172_1 as u128, 32u16);
        // C s_1172_3: const #1s : i64
        let s_1172_3: i64 = 1;
        // C s_1172_4: cast zx s_1172_3 -> i
        let s_1172_4: i128 = (i128::try_from(s_1172_3).unwrap());
        // C s_1172_5: const #2s : i
        let s_1172_5: i128 = 2;
        // C s_1172_6: add s_1172_5 s_1172_4
        let s_1172_6: i128 = (s_1172_5 + s_1172_4);
        // D s_1172_7: bit-extract s_1172_2 s_1172_0 s_1172_6
        let s_1172_7: Bits = (Bits::new(
            ((s_1172_2) >> (s_1172_0)).value(),
            u16::try_from(s_1172_6).unwrap(),
        ));
        // D s_1172_8: cast reint s_1172_7 -> u8
        let s_1172_8: u8 = (s_1172_7.value() as u8);
        // D s_1172_9: cast zx s_1172_8 -> bv
        let s_1172_9: Bits = Bits::new(s_1172_8 as u128, 3u16);
        // C s_1172_10: const #7u : u8
        let s_1172_10: u8 = 7;
        // C s_1172_11: cast zx s_1172_10 -> bv
        let s_1172_11: Bits = Bits::new(s_1172_10 as u128, 3u16);
        // D s_1172_12: cmp-eq s_1172_9 s_1172_11
        let s_1172_12: bool = ((s_1172_9) == (s_1172_11));
        // D s_1172_13: write-var gs#411922 <= s_1172_12
        fn_state.gs_411922 = s_1172_12;
        // N s_1172_14: jump b32
        return block_32(state, tracer, fn_state);
    }
    fn block_1173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1173_0: const #28s : i
        let s_1173_0: i128 = 28;
        // C s_1173_1: const #4s : i
        let s_1173_1: i128 = 4;
        // D s_1173_2: read-var u#33982:u32
        let s_1173_2: u32 = fn_state.u_33982;
        // D s_1173_3: cast zx s_1173_2 -> bv
        let s_1173_3: Bits = Bits::new(s_1173_2 as u128, 32u16);
        // D s_1173_4: bit-extract s_1173_3 s_1173_0 s_1173_1
        let s_1173_4: Bits = (Bits::new(
            ((s_1173_3) >> (s_1173_0)).value(),
            u16::try_from(s_1173_1).unwrap(),
        ));
        // D s_1173_5: cast reint s_1173_4 -> u8
        let s_1173_5: u8 = (s_1173_4.value() as u8);
        // D s_1173_6: cast zx s_1173_5 -> bv
        let s_1173_6: Bits = Bits::new(s_1173_5 as u128, 4u16);
        // C s_1173_7: const #15u : u8
        let s_1173_7: u8 = 15;
        // C s_1173_8: cast zx s_1173_7 -> bv
        let s_1173_8: Bits = Bits::new(s_1173_7 as u128, 4u16);
        // D s_1173_9: cmp-ne s_1173_6 s_1173_8
        let s_1173_9: bool = ((s_1173_6) != (s_1173_8));
        // N s_1173_10: branch s_1173_9 b1176 b1174
        if s_1173_9 {
            return block_1176(state, tracer, fn_state);
        } else {
            return block_1174(state, tracer, fn_state);
        };
    }
    fn block_1174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1174_0: const #0u : u8
        let s_1174_0: bool = false;
        // D s_1174_1: write-var gs#411899 <= s_1174_0
        fn_state.gs_411899 = s_1174_0;
        // N s_1174_2: jump b1175
        return block_1175(state, tracer, fn_state);
    }
    fn block_1175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1175_0: read-var gs#411899:u8
        let s_1175_0: bool = fn_state.gs_411899;
        // D s_1175_1: write-var gs#411900 <= s_1175_0
        fn_state.gs_411900 = s_1175_0;
        // N s_1175_2: jump b28
        return block_28(state, tracer, fn_state);
    }
    fn block_1176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1176_0: const #3023s : i
        let s_1176_0: i128 = 3023;
        // C s_1176_1: const #14696u : u32
        let s_1176_1: u32 = 14696;
        // D s_1176_2: read-reg s_1176_1:i
        let s_1176_2: i128 = {
            let value = state.read_register::<i128>(s_1176_1 as isize);
            tracer.read_register(s_1176_1 as isize, value);
            value
        };
        // D s_1176_3: cmp-lt s_1176_2 s_1176_0
        let s_1176_3: bool = ((s_1176_2) < (s_1176_0));
        // D s_1176_4: write-var gs#411899 <= s_1176_3
        fn_state.gs_411899 = s_1176_3;
        // N s_1176_5: jump b1175
        return block_1175(state, tracer, fn_state);
    }
    fn block_1177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1177_0: const #20s : i
        let s_1177_0: i128 = 20;
        // D s_1177_1: read-var u#33982:u32
        let s_1177_1: u32 = fn_state.u_33982;
        // D s_1177_2: cast zx s_1177_1 -> bv
        let s_1177_2: Bits = Bits::new(s_1177_1 as u128, 32u16);
        // C s_1177_3: const #1s : i64
        let s_1177_3: i64 = 1;
        // C s_1177_4: cast zx s_1177_3 -> i
        let s_1177_4: i128 = (i128::try_from(s_1177_3).unwrap());
        // C s_1177_5: const #0s : i
        let s_1177_5: i128 = 0;
        // C s_1177_6: add s_1177_5 s_1177_4
        let s_1177_6: i128 = (s_1177_5 + s_1177_4);
        // D s_1177_7: bit-extract s_1177_2 s_1177_0 s_1177_6
        let s_1177_7: Bits = (Bits::new(
            ((s_1177_2) >> (s_1177_0)).value(),
            u16::try_from(s_1177_6).unwrap(),
        ));
        // D s_1177_8: cast reint s_1177_7 -> u8
        let s_1177_8: bool = ((s_1177_7.value()) != 0);
        // D s_1177_9: cast zx s_1177_8 -> bv
        let s_1177_9: Bits = Bits::new(s_1177_8 as u128, 1u16);
        // C s_1177_10: const #1u : u8
        let s_1177_10: bool = true;
        // C s_1177_11: cast zx s_1177_10 -> bv
        let s_1177_11: Bits = Bits::new(s_1177_10 as u128, 1u16);
        // D s_1177_12: cmp-eq s_1177_9 s_1177_11
        let s_1177_12: bool = ((s_1177_9) == (s_1177_11));
        // N s_1177_13: branch s_1177_12 b1180 b1178
        if s_1177_12 {
            return block_1180(state, tracer, fn_state);
        } else {
            return block_1178(state, tracer, fn_state);
        };
    }
    fn block_1178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1178_0: const #0u : u8
        let s_1178_0: bool = false;
        // D s_1178_1: write-var gs#411894 <= s_1178_0
        fn_state.gs_411894 = s_1178_0;
        // N s_1178_2: jump b1179
        return block_1179(state, tracer, fn_state);
    }
    fn block_1179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1179_0: read-var gs#411894:u8
        let s_1179_0: bool = fn_state.gs_411894;
        // D s_1179_1: write-var gs#411895 <= s_1179_0
        fn_state.gs_411895 = s_1179_0;
        // N s_1179_2: jump b26
        return block_26(state, tracer, fn_state);
    }
    fn block_1180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1180_0: const #9s : i
        let s_1180_0: i128 = 9;
        // D s_1180_1: read-var u#33982:u32
        let s_1180_1: u32 = fn_state.u_33982;
        // D s_1180_2: cast zx s_1180_1 -> bv
        let s_1180_2: Bits = Bits::new(s_1180_1 as u128, 32u16);
        // C s_1180_3: const #1s : i64
        let s_1180_3: i64 = 1;
        // C s_1180_4: cast zx s_1180_3 -> i
        let s_1180_4: i128 = (i128::try_from(s_1180_3).unwrap());
        // C s_1180_5: const #2s : i
        let s_1180_5: i128 = 2;
        // C s_1180_6: add s_1180_5 s_1180_4
        let s_1180_6: i128 = (s_1180_5 + s_1180_4);
        // D s_1180_7: bit-extract s_1180_2 s_1180_0 s_1180_6
        let s_1180_7: Bits = (Bits::new(
            ((s_1180_2) >> (s_1180_0)).value(),
            u16::try_from(s_1180_6).unwrap(),
        ));
        // D s_1180_8: cast reint s_1180_7 -> u8
        let s_1180_8: u8 = (s_1180_7.value() as u8);
        // D s_1180_9: cast zx s_1180_8 -> bv
        let s_1180_9: Bits = Bits::new(s_1180_8 as u128, 3u16);
        // C s_1180_10: const #7u : u8
        let s_1180_10: u8 = 7;
        // C s_1180_11: cast zx s_1180_10 -> bv
        let s_1180_11: Bits = Bits::new(s_1180_10 as u128, 3u16);
        // D s_1180_12: cmp-eq s_1180_9 s_1180_11
        let s_1180_12: bool = ((s_1180_9) == (s_1180_11));
        // N s_1180_13: branch s_1180_12 b1183 b1181
        if s_1180_12 {
            return block_1183(state, tracer, fn_state);
        } else {
            return block_1181(state, tracer, fn_state);
        };
    }
    fn block_1181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1181_0: const #0u : u8
        let s_1181_0: bool = false;
        // D s_1181_1: write-var gs#411893 <= s_1181_0
        fn_state.gs_411893 = s_1181_0;
        // N s_1181_2: jump b1182
        return block_1182(state, tracer, fn_state);
    }
    fn block_1182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1182_0: read-var gs#411893:u8
        let s_1182_0: bool = fn_state.gs_411893;
        // D s_1182_1: write-var gs#411894 <= s_1182_0
        fn_state.gs_411894 = s_1182_0;
        // N s_1182_2: jump b1179
        return block_1179(state, tracer, fn_state);
    }
    fn block_1183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1183_0: const #4s : i
        let s_1183_0: i128 = 4;
        // D s_1183_1: read-var u#33982:u32
        let s_1183_1: u32 = fn_state.u_33982;
        // D s_1183_2: cast zx s_1183_1 -> bv
        let s_1183_2: Bits = Bits::new(s_1183_1 as u128, 32u16);
        // C s_1183_3: const #1s : i64
        let s_1183_3: i64 = 1;
        // C s_1183_4: cast zx s_1183_3 -> i
        let s_1183_4: i128 = (i128::try_from(s_1183_3).unwrap());
        // C s_1183_5: const #0s : i
        let s_1183_5: i128 = 0;
        // C s_1183_6: add s_1183_5 s_1183_4
        let s_1183_6: i128 = (s_1183_5 + s_1183_4);
        // D s_1183_7: bit-extract s_1183_2 s_1183_0 s_1183_6
        let s_1183_7: Bits = (Bits::new(
            ((s_1183_2) >> (s_1183_0)).value(),
            u16::try_from(s_1183_6).unwrap(),
        ));
        // D s_1183_8: cast reint s_1183_7 -> u8
        let s_1183_8: bool = ((s_1183_7.value()) != 0);
        // D s_1183_9: cast zx s_1183_8 -> bv
        let s_1183_9: Bits = Bits::new(s_1183_8 as u128, 1u16);
        // C s_1183_10: const #1u : u8
        let s_1183_10: bool = true;
        // C s_1183_11: cast zx s_1183_10 -> bv
        let s_1183_11: Bits = Bits::new(s_1183_10 as u128, 1u16);
        // D s_1183_12: cmp-eq s_1183_9 s_1183_11
        let s_1183_12: bool = ((s_1183_9) == (s_1183_11));
        // D s_1183_13: write-var gs#411893 <= s_1183_12
        fn_state.gs_411893 = s_1183_12;
        // N s_1183_14: jump b1182
        return block_1182(state, tracer, fn_state);
    }
    fn block_1184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1184_0: const #28s : i
        let s_1184_0: i128 = 28;
        // C s_1184_1: const #4s : i
        let s_1184_1: i128 = 4;
        // D s_1184_2: read-var u#33975:u32
        let s_1184_2: u32 = fn_state.u_33975;
        // D s_1184_3: cast zx s_1184_2 -> bv
        let s_1184_3: Bits = Bits::new(s_1184_2 as u128, 32u16);
        // D s_1184_4: bit-extract s_1184_3 s_1184_0 s_1184_1
        let s_1184_4: Bits = (Bits::new(
            ((s_1184_3) >> (s_1184_0)).value(),
            u16::try_from(s_1184_1).unwrap(),
        ));
        // D s_1184_5: cast reint s_1184_4 -> u8
        let s_1184_5: u8 = (s_1184_4.value() as u8);
        // D s_1184_6: cast zx s_1184_5 -> bv
        let s_1184_6: Bits = Bits::new(s_1184_5 as u128, 4u16);
        // C s_1184_7: const #15u : u8
        let s_1184_7: u8 = 15;
        // C s_1184_8: cast zx s_1184_7 -> bv
        let s_1184_8: Bits = Bits::new(s_1184_7 as u128, 4u16);
        // D s_1184_9: cmp-ne s_1184_6 s_1184_8
        let s_1184_9: bool = ((s_1184_6) != (s_1184_8));
        // N s_1184_10: branch s_1184_9 b1187 b1185
        if s_1184_9 {
            return block_1187(state, tracer, fn_state);
        } else {
            return block_1185(state, tracer, fn_state);
        };
    }
    fn block_1185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1185_0: const #0u : u8
        let s_1185_0: bool = false;
        // D s_1185_1: write-var gs#411868 <= s_1185_0
        fn_state.gs_411868 = s_1185_0;
        // N s_1185_2: jump b1186
        return block_1186(state, tracer, fn_state);
    }
    fn block_1186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1186_0: read-var gs#411868:u8
        let s_1186_0: bool = fn_state.gs_411868;
        // D s_1186_1: write-var gs#411869 <= s_1186_0
        fn_state.gs_411869 = s_1186_0;
        // N s_1186_2: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_1187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1187_0: const #3003s : i
        let s_1187_0: i128 = 3003;
        // C s_1187_1: const #14696u : u32
        let s_1187_1: u32 = 14696;
        // D s_1187_2: read-reg s_1187_1:i
        let s_1187_2: i128 = {
            let value = state.read_register::<i128>(s_1187_1 as isize);
            tracer.read_register(s_1187_1 as isize, value);
            value
        };
        // D s_1187_3: cmp-lt s_1187_2 s_1187_0
        let s_1187_3: bool = ((s_1187_2) < (s_1187_0));
        // D s_1187_4: write-var gs#411868 <= s_1187_3
        fn_state.gs_411868 = s_1187_3;
        // N s_1187_5: jump b1186
        return block_1186(state, tracer, fn_state);
    }
    fn block_1188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1188_0: const #9s : i
        let s_1188_0: i128 = 9;
        // D s_1188_1: read-var u#33975:u32
        let s_1188_1: u32 = fn_state.u_33975;
        // D s_1188_2: cast zx s_1188_1 -> bv
        let s_1188_2: Bits = Bits::new(s_1188_1 as u128, 32u16);
        // C s_1188_3: const #1s : i64
        let s_1188_3: i64 = 1;
        // C s_1188_4: cast zx s_1188_3 -> i
        let s_1188_4: i128 = (i128::try_from(s_1188_3).unwrap());
        // C s_1188_5: const #2s : i
        let s_1188_5: i128 = 2;
        // C s_1188_6: add s_1188_5 s_1188_4
        let s_1188_6: i128 = (s_1188_5 + s_1188_4);
        // D s_1188_7: bit-extract s_1188_2 s_1188_0 s_1188_6
        let s_1188_7: Bits = (Bits::new(
            ((s_1188_2) >> (s_1188_0)).value(),
            u16::try_from(s_1188_6).unwrap(),
        ));
        // D s_1188_8: cast reint s_1188_7 -> u8
        let s_1188_8: u8 = (s_1188_7.value() as u8);
        // D s_1188_9: cast zx s_1188_8 -> bv
        let s_1188_9: Bits = Bits::new(s_1188_8 as u128, 3u16);
        // C s_1188_10: const #7u : u8
        let s_1188_10: u8 = 7;
        // C s_1188_11: cast zx s_1188_10 -> bv
        let s_1188_11: Bits = Bits::new(s_1188_10 as u128, 3u16);
        // D s_1188_12: cmp-eq s_1188_9 s_1188_11
        let s_1188_12: bool = ((s_1188_9) == (s_1188_11));
        // D s_1188_13: write-var gs#411864 <= s_1188_12
        fn_state.gs_411864 = s_1188_12;
        // N s_1188_14: jump b20
        return block_20(state, tracer, fn_state);
    }
    fn block_1189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1189_0: const #28s : i
        let s_1189_0: i128 = 28;
        // C s_1189_1: const #4s : i
        let s_1189_1: i128 = 4;
        // D s_1189_2: read-var u#33972:u32
        let s_1189_2: u32 = fn_state.u_33972;
        // D s_1189_3: cast zx s_1189_2 -> bv
        let s_1189_3: Bits = Bits::new(s_1189_2 as u128, 32u16);
        // D s_1189_4: bit-extract s_1189_3 s_1189_0 s_1189_1
        let s_1189_4: Bits = (Bits::new(
            ((s_1189_3) >> (s_1189_0)).value(),
            u16::try_from(s_1189_1).unwrap(),
        ));
        // D s_1189_5: cast reint s_1189_4 -> u8
        let s_1189_5: u8 = (s_1189_4.value() as u8);
        // D s_1189_6: cast zx s_1189_5 -> bv
        let s_1189_6: Bits = Bits::new(s_1189_5 as u128, 4u16);
        // C s_1189_7: const #15u : u8
        let s_1189_7: u8 = 15;
        // C s_1189_8: cast zx s_1189_7 -> bv
        let s_1189_8: Bits = Bits::new(s_1189_7 as u128, 4u16);
        // D s_1189_9: cmp-ne s_1189_6 s_1189_8
        let s_1189_9: bool = ((s_1189_6) != (s_1189_8));
        // N s_1189_10: branch s_1189_9 b1192 b1190
        if s_1189_9 {
            return block_1192(state, tracer, fn_state);
        } else {
            return block_1190(state, tracer, fn_state);
        };
    }
    fn block_1190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1190_0: const #0u : u8
        let s_1190_0: bool = false;
        // D s_1190_1: write-var gs#411841 <= s_1190_0
        fn_state.gs_411841 = s_1190_0;
        // N s_1190_2: jump b1191
        return block_1191(state, tracer, fn_state);
    }
    fn block_1191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1191_0: read-var gs#411841:u8
        let s_1191_0: bool = fn_state.gs_411841;
        // D s_1191_1: write-var gs#411842 <= s_1191_0
        fn_state.gs_411842 = s_1191_0;
        // N s_1191_2: jump b16
        return block_16(state, tracer, fn_state);
    }
    fn block_1192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1192_0: const #3001s : i
        let s_1192_0: i128 = 3001;
        // C s_1192_1: const #14696u : u32
        let s_1192_1: u32 = 14696;
        // D s_1192_2: read-reg s_1192_1:i
        let s_1192_2: i128 = {
            let value = state.read_register::<i128>(s_1192_1 as isize);
            tracer.read_register(s_1192_1 as isize, value);
            value
        };
        // D s_1192_3: cmp-lt s_1192_2 s_1192_0
        let s_1192_3: bool = ((s_1192_2) < (s_1192_0));
        // D s_1192_4: write-var gs#411841 <= s_1192_3
        fn_state.gs_411841 = s_1192_3;
        // N s_1192_5: jump b1191
        return block_1191(state, tracer, fn_state);
    }
    fn block_1193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1193_0: const #20s : i
        let s_1193_0: i128 = 20;
        // D s_1193_1: read-var u#33972:u32
        let s_1193_1: u32 = fn_state.u_33972;
        // D s_1193_2: cast zx s_1193_1 -> bv
        let s_1193_2: Bits = Bits::new(s_1193_1 as u128, 32u16);
        // C s_1193_3: const #1s : i64
        let s_1193_3: i64 = 1;
        // C s_1193_4: cast zx s_1193_3 -> i
        let s_1193_4: i128 = (i128::try_from(s_1193_3).unwrap());
        // C s_1193_5: const #0s : i
        let s_1193_5: i128 = 0;
        // C s_1193_6: add s_1193_5 s_1193_4
        let s_1193_6: i128 = (s_1193_5 + s_1193_4);
        // D s_1193_7: bit-extract s_1193_2 s_1193_0 s_1193_6
        let s_1193_7: Bits = (Bits::new(
            ((s_1193_2) >> (s_1193_0)).value(),
            u16::try_from(s_1193_6).unwrap(),
        ));
        // D s_1193_8: cast reint s_1193_7 -> u8
        let s_1193_8: bool = ((s_1193_7.value()) != 0);
        // D s_1193_9: cast zx s_1193_8 -> bv
        let s_1193_9: Bits = Bits::new(s_1193_8 as u128, 1u16);
        // C s_1193_10: const #0u : u8
        let s_1193_10: bool = false;
        // C s_1193_11: cast zx s_1193_10 -> bv
        let s_1193_11: Bits = Bits::new(s_1193_10 as u128, 1u16);
        // D s_1193_12: cmp-eq s_1193_9 s_1193_11
        let s_1193_12: bool = ((s_1193_9) == (s_1193_11));
        // N s_1193_13: branch s_1193_12 b1196 b1194
        if s_1193_12 {
            return block_1196(state, tracer, fn_state);
        } else {
            return block_1194(state, tracer, fn_state);
        };
    }
    fn block_1194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1194_0: const #0u : u8
        let s_1194_0: bool = false;
        // D s_1194_1: write-var gs#411836 <= s_1194_0
        fn_state.gs_411836 = s_1194_0;
        // N s_1194_2: jump b1195
        return block_1195(state, tracer, fn_state);
    }
    fn block_1195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1195_0: read-var gs#411836:u8
        let s_1195_0: bool = fn_state.gs_411836;
        // D s_1195_1: write-var gs#411837 <= s_1195_0
        fn_state.gs_411837 = s_1195_0;
        // N s_1195_2: jump b14
        return block_14(state, tracer, fn_state);
    }
    fn block_1196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1196_0: const #9s : i
        let s_1196_0: i128 = 9;
        // D s_1196_1: read-var u#33972:u32
        let s_1196_1: u32 = fn_state.u_33972;
        // D s_1196_2: cast zx s_1196_1 -> bv
        let s_1196_2: Bits = Bits::new(s_1196_1 as u128, 32u16);
        // C s_1196_3: const #1s : i64
        let s_1196_3: i64 = 1;
        // C s_1196_4: cast zx s_1196_3 -> i
        let s_1196_4: i128 = (i128::try_from(s_1196_3).unwrap());
        // C s_1196_5: const #2s : i
        let s_1196_5: i128 = 2;
        // C s_1196_6: add s_1196_5 s_1196_4
        let s_1196_6: i128 = (s_1196_5 + s_1196_4);
        // D s_1196_7: bit-extract s_1196_2 s_1196_0 s_1196_6
        let s_1196_7: Bits = (Bits::new(
            ((s_1196_2) >> (s_1196_0)).value(),
            u16::try_from(s_1196_6).unwrap(),
        ));
        // D s_1196_8: cast reint s_1196_7 -> u8
        let s_1196_8: u8 = (s_1196_7.value() as u8);
        // D s_1196_9: cast zx s_1196_8 -> bv
        let s_1196_9: Bits = Bits::new(s_1196_8 as u128, 3u16);
        // C s_1196_10: const #7u : u8
        let s_1196_10: u8 = 7;
        // C s_1196_11: cast zx s_1196_10 -> bv
        let s_1196_11: Bits = Bits::new(s_1196_10 as u128, 3u16);
        // D s_1196_12: cmp-eq s_1196_9 s_1196_11
        let s_1196_12: bool = ((s_1196_9) == (s_1196_11));
        // N s_1196_13: branch s_1196_12 b1199 b1197
        if s_1196_12 {
            return block_1199(state, tracer, fn_state);
        } else {
            return block_1197(state, tracer, fn_state);
        };
    }
    fn block_1197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1197_0: const #0u : u8
        let s_1197_0: bool = false;
        // D s_1197_1: write-var gs#411835 <= s_1197_0
        fn_state.gs_411835 = s_1197_0;
        // N s_1197_2: jump b1198
        return block_1198(state, tracer, fn_state);
    }
    fn block_1198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1198_0: read-var gs#411835:u8
        let s_1198_0: bool = fn_state.gs_411835;
        // D s_1198_1: write-var gs#411836 <= s_1198_0
        fn_state.gs_411836 = s_1198_0;
        // N s_1198_2: jump b1195
        return block_1195(state, tracer, fn_state);
    }
    fn block_1199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1199_0: const #4s : i
        let s_1199_0: i128 = 4;
        // D s_1199_1: read-var u#33972:u32
        let s_1199_1: u32 = fn_state.u_33972;
        // D s_1199_2: cast zx s_1199_1 -> bv
        let s_1199_2: Bits = Bits::new(s_1199_1 as u128, 32u16);
        // C s_1199_3: const #1s : i64
        let s_1199_3: i64 = 1;
        // C s_1199_4: cast zx s_1199_3 -> i
        let s_1199_4: i128 = (i128::try_from(s_1199_3).unwrap());
        // C s_1199_5: const #0s : i
        let s_1199_5: i128 = 0;
        // C s_1199_6: add s_1199_5 s_1199_4
        let s_1199_6: i128 = (s_1199_5 + s_1199_4);
        // D s_1199_7: bit-extract s_1199_2 s_1199_0 s_1199_6
        let s_1199_7: Bits = (Bits::new(
            ((s_1199_2) >> (s_1199_0)).value(),
            u16::try_from(s_1199_6).unwrap(),
        ));
        // D s_1199_8: cast reint s_1199_7 -> u8
        let s_1199_8: bool = ((s_1199_7.value()) != 0);
        // D s_1199_9: cast zx s_1199_8 -> bv
        let s_1199_9: Bits = Bits::new(s_1199_8 as u128, 1u16);
        // C s_1199_10: const #1u : u8
        let s_1199_10: bool = true;
        // C s_1199_11: cast zx s_1199_10 -> bv
        let s_1199_11: Bits = Bits::new(s_1199_10 as u128, 1u16);
        // D s_1199_12: cmp-eq s_1199_9 s_1199_11
        let s_1199_12: bool = ((s_1199_9) == (s_1199_11));
        // D s_1199_13: write-var gs#411835 <= s_1199_12
        fn_state.gs_411835 = s_1199_12;
        // N s_1199_14: jump b1198
        return block_1198(state, tracer, fn_state);
    }
    fn block_1200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1200_0: const #28s : i
        let s_1200_0: i128 = 28;
        // C s_1200_1: const #4s : i
        let s_1200_1: i128 = 4;
        // D s_1200_2: read-var u#33965:u32
        let s_1200_2: u32 = fn_state.u_33965;
        // D s_1200_3: cast zx s_1200_2 -> bv
        let s_1200_3: Bits = Bits::new(s_1200_2 as u128, 32u16);
        // D s_1200_4: bit-extract s_1200_3 s_1200_0 s_1200_1
        let s_1200_4: Bits = (Bits::new(
            ((s_1200_3) >> (s_1200_0)).value(),
            u16::try_from(s_1200_1).unwrap(),
        ));
        // D s_1200_5: cast reint s_1200_4 -> u8
        let s_1200_5: u8 = (s_1200_4.value() as u8);
        // D s_1200_6: cast zx s_1200_5 -> bv
        let s_1200_6: Bits = Bits::new(s_1200_5 as u128, 4u16);
        // C s_1200_7: const #15u : u8
        let s_1200_7: u8 = 15;
        // C s_1200_8: cast zx s_1200_7 -> bv
        let s_1200_8: Bits = Bits::new(s_1200_7 as u128, 4u16);
        // D s_1200_9: cmp-ne s_1200_6 s_1200_8
        let s_1200_9: bool = ((s_1200_6) != (s_1200_8));
        // N s_1200_10: branch s_1200_9 b1203 b1201
        if s_1200_9 {
            return block_1203(state, tracer, fn_state);
        } else {
            return block_1201(state, tracer, fn_state);
        };
    }
    fn block_1201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1201_0: const #0u : u8
        let s_1201_0: bool = false;
        // D s_1201_1: write-var gs#411812 <= s_1201_0
        fn_state.gs_411812 = s_1201_0;
        // N s_1201_2: jump b1202
        return block_1202(state, tracer, fn_state);
    }
    fn block_1202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1202_0: read-var gs#411812:u8
        let s_1202_0: bool = fn_state.gs_411812;
        // D s_1202_1: write-var gs#411813 <= s_1202_0
        fn_state.gs_411813 = s_1202_0;
        // N s_1202_2: jump b10
        return block_10(state, tracer, fn_state);
    }
    fn block_1203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1203_0: const #2914s : i
        let s_1203_0: i128 = 2914;
        // C s_1203_1: const #14696u : u32
        let s_1203_1: u32 = 14696;
        // D s_1203_2: read-reg s_1203_1:i
        let s_1203_2: i128 = {
            let value = state.read_register::<i128>(s_1203_1 as isize);
            tracer.read_register(s_1203_1 as isize, value);
            value
        };
        // D s_1203_3: cmp-lt s_1203_2 s_1203_0
        let s_1203_3: bool = ((s_1203_2) < (s_1203_0));
        // D s_1203_4: write-var gs#411812 <= s_1203_3
        fn_state.gs_411812 = s_1203_3;
        // N s_1203_5: jump b1202
        return block_1202(state, tracer, fn_state);
    }
    fn block_1204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1204_0: const #22s : i
        let s_1204_0: i128 = 22;
        // D s_1204_1: read-var u#33965:u32
        let s_1204_1: u32 = fn_state.u_33965;
        // D s_1204_2: cast zx s_1204_1 -> bv
        let s_1204_2: Bits = Bits::new(s_1204_1 as u128, 32u16);
        // C s_1204_3: const #1s : i64
        let s_1204_3: i64 = 1;
        // C s_1204_4: cast zx s_1204_3 -> i
        let s_1204_4: i128 = (i128::try_from(s_1204_3).unwrap());
        // C s_1204_5: const #0s : i
        let s_1204_5: i128 = 0;
        // C s_1204_6: add s_1204_5 s_1204_4
        let s_1204_6: i128 = (s_1204_5 + s_1204_4);
        // D s_1204_7: bit-extract s_1204_2 s_1204_0 s_1204_6
        let s_1204_7: Bits = (Bits::new(
            ((s_1204_2) >> (s_1204_0)).value(),
            u16::try_from(s_1204_6).unwrap(),
        ));
        // D s_1204_8: cast reint s_1204_7 -> u8
        let s_1204_8: bool = ((s_1204_7.value()) != 0);
        // D s_1204_9: cast zx s_1204_8 -> bv
        let s_1204_9: Bits = Bits::new(s_1204_8 as u128, 1u16);
        // C s_1204_10: const #0u : u8
        let s_1204_10: bool = false;
        // C s_1204_11: cast zx s_1204_10 -> bv
        let s_1204_11: Bits = Bits::new(s_1204_10 as u128, 1u16);
        // D s_1204_12: cmp-eq s_1204_9 s_1204_11
        let s_1204_12: bool = ((s_1204_9) == (s_1204_11));
        // N s_1204_13: branch s_1204_12 b1207 b1205
        if s_1204_12 {
            return block_1207(state, tracer, fn_state);
        } else {
            return block_1205(state, tracer, fn_state);
        };
    }
    fn block_1205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1205_0: const #0u : u8
        let s_1205_0: bool = false;
        // D s_1205_1: write-var gs#411807 <= s_1205_0
        fn_state.gs_411807 = s_1205_0;
        // N s_1205_2: jump b1206
        return block_1206(state, tracer, fn_state);
    }
    fn block_1206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1206_0: read-var gs#411807:u8
        let s_1206_0: bool = fn_state.gs_411807;
        // D s_1206_1: write-var gs#411808 <= s_1206_0
        fn_state.gs_411808 = s_1206_0;
        // N s_1206_2: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_1207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1207_0: const #8s : i
        let s_1207_0: i128 = 8;
        // D s_1207_1: read-var u#33965:u32
        let s_1207_1: u32 = fn_state.u_33965;
        // D s_1207_2: cast zx s_1207_1 -> bv
        let s_1207_2: Bits = Bits::new(s_1207_1 as u128, 32u16);
        // C s_1207_3: const #1s : i64
        let s_1207_3: i64 = 1;
        // C s_1207_4: cast zx s_1207_3 -> i
        let s_1207_4: i128 = (i128::try_from(s_1207_3).unwrap());
        // C s_1207_5: const #12s : i
        let s_1207_5: i128 = 12;
        // C s_1207_6: add s_1207_5 s_1207_4
        let s_1207_6: i128 = (s_1207_5 + s_1207_4);
        // D s_1207_7: bit-extract s_1207_2 s_1207_0 s_1207_6
        let s_1207_7: Bits = (Bits::new(
            ((s_1207_2) >> (s_1207_0)).value(),
            u16::try_from(s_1207_6).unwrap(),
        ));
        // D s_1207_8: cast reint s_1207_7 -> u13
        let s_1207_8: u16 = (s_1207_7.value() as u16);
        // D s_1207_9: cast zx s_1207_8 -> bv
        let s_1207_9: Bits = Bits::new(s_1207_8 as u128, 13u16);
        // C s_1207_10: const #8030u : u13
        let s_1207_10: u16 = 8030;
        // C s_1207_11: cast zx s_1207_10 -> bv
        let s_1207_11: Bits = Bits::new(s_1207_10 as u128, 13u16);
        // D s_1207_12: cmp-eq s_1207_9 s_1207_11
        let s_1207_12: bool = ((s_1207_9) == (s_1207_11));
        // D s_1207_13: write-var gs#411807 <= s_1207_12
        fn_state.gs_411807 = s_1207_12;
        // N s_1207_14: jump b1206
        return block_1206(state, tracer, fn_state);
    }
    fn block_1208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1208_0: const #28s : i
        let s_1208_0: i128 = 28;
        // C s_1208_1: const #4s : i
        let s_1208_1: i128 = 4;
        // D s_1208_2: read-var __opcode:u32
        let s_1208_2: u32 = fn_state.u__opcode;
        // D s_1208_3: cast zx s_1208_2 -> bv
        let s_1208_3: Bits = Bits::new(s_1208_2 as u128, 32u16);
        // D s_1208_4: bit-extract s_1208_3 s_1208_0 s_1208_1
        let s_1208_4: Bits = (Bits::new(
            ((s_1208_3) >> (s_1208_0)).value(),
            u16::try_from(s_1208_1).unwrap(),
        ));
        // D s_1208_5: cast reint s_1208_4 -> u8
        let s_1208_5: u8 = (s_1208_4.value() as u8);
        // D s_1208_6: cast zx s_1208_5 -> bv
        let s_1208_6: Bits = Bits::new(s_1208_5 as u128, 4u16);
        // C s_1208_7: const #15u : u8
        let s_1208_7: u8 = 15;
        // C s_1208_8: cast zx s_1208_7 -> bv
        let s_1208_8: Bits = Bits::new(s_1208_7 as u128, 4u16);
        // D s_1208_9: cmp-ne s_1208_6 s_1208_8
        let s_1208_9: bool = ((s_1208_6) != (s_1208_8));
        // N s_1208_10: branch s_1208_9 b1211 b1209
        if s_1208_9 {
            return block_1211(state, tracer, fn_state);
        } else {
            return block_1209(state, tracer, fn_state);
        };
    }
    fn block_1209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1209_0: const #0u : u8
        let s_1209_0: bool = false;
        // D s_1209_1: write-var gs#411784 <= s_1209_0
        fn_state.gs_411784 = s_1209_0;
        // N s_1209_2: jump b1210
        return block_1210(state, tracer, fn_state);
    }
    fn block_1210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1210_0: read-var gs#411784:u8
        let s_1210_0: bool = fn_state.gs_411784;
        // D s_1210_1: write-var gs#411785 <= s_1210_0
        fn_state.gs_411785 = s_1210_0;
        // N s_1210_2: jump b4
        return block_4(state, tracer, fn_state);
    }
    fn block_1211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1211_0: const #2912s : i
        let s_1211_0: i128 = 2912;
        // C s_1211_1: const #14696u : u32
        let s_1211_1: u32 = 14696;
        // D s_1211_2: read-reg s_1211_1:i
        let s_1211_2: i128 = {
            let value = state.read_register::<i128>(s_1211_1 as isize);
            tracer.read_register(s_1211_1 as isize, value);
            value
        };
        // D s_1211_3: cmp-lt s_1211_2 s_1211_0
        let s_1211_3: bool = ((s_1211_2) < (s_1211_0));
        // D s_1211_4: write-var gs#411784 <= s_1211_3
        fn_state.gs_411784 = s_1211_3;
        // N s_1211_5: jump b1210
        return block_1210(state, tracer, fn_state);
    }
    fn block_1212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1212_0: const #22s : i
        let s_1212_0: i128 = 22;
        // D s_1212_1: read-var __opcode:u32
        let s_1212_1: u32 = fn_state.u__opcode;
        // D s_1212_2: cast zx s_1212_1 -> bv
        let s_1212_2: Bits = Bits::new(s_1212_1 as u128, 32u16);
        // C s_1212_3: const #1s : i64
        let s_1212_3: i64 = 1;
        // C s_1212_4: cast zx s_1212_3 -> i
        let s_1212_4: i128 = (i128::try_from(s_1212_3).unwrap());
        // C s_1212_5: const #0s : i
        let s_1212_5: i128 = 0;
        // C s_1212_6: add s_1212_5 s_1212_4
        let s_1212_6: i128 = (s_1212_5 + s_1212_4);
        // D s_1212_7: bit-extract s_1212_2 s_1212_0 s_1212_6
        let s_1212_7: Bits = (Bits::new(
            ((s_1212_2) >> (s_1212_0)).value(),
            u16::try_from(s_1212_6).unwrap(),
        ));
        // D s_1212_8: cast reint s_1212_7 -> u8
        let s_1212_8: bool = ((s_1212_7.value()) != 0);
        // D s_1212_9: cast zx s_1212_8 -> bv
        let s_1212_9: Bits = Bits::new(s_1212_8 as u128, 1u16);
        // C s_1212_10: const #0u : u8
        let s_1212_10: bool = false;
        // C s_1212_11: cast zx s_1212_10 -> bv
        let s_1212_11: Bits = Bits::new(s_1212_10 as u128, 1u16);
        // D s_1212_12: cmp-eq s_1212_9 s_1212_11
        let s_1212_12: bool = ((s_1212_9) == (s_1212_11));
        // N s_1212_13: branch s_1212_12 b1215 b1213
        if s_1212_12 {
            return block_1215(state, tracer, fn_state);
        } else {
            return block_1213(state, tracer, fn_state);
        };
    }
    fn block_1213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1213_0: const #0u : u8
        let s_1213_0: bool = false;
        // D s_1213_1: write-var gs#411779 <= s_1213_0
        fn_state.gs_411779 = s_1213_0;
        // N s_1213_2: jump b1214
        return block_1214(state, tracer, fn_state);
    }
    fn block_1214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1214_0: read-var gs#411779:u8
        let s_1214_0: bool = fn_state.gs_411779;
        // D s_1214_1: write-var gs#411780 <= s_1214_0
        fn_state.gs_411780 = s_1214_0;
        // N s_1214_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_1215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1215_0: const #20s : i
        let s_1215_0: i128 = 20;
        // D s_1215_1: read-var __opcode:u32
        let s_1215_1: u32 = fn_state.u__opcode;
        // D s_1215_2: cast zx s_1215_1 -> bv
        let s_1215_2: Bits = Bits::new(s_1215_1 as u128, 32u16);
        // C s_1215_3: const #1s : i64
        let s_1215_3: i64 = 1;
        // C s_1215_4: cast zx s_1215_3 -> i
        let s_1215_4: i128 = (i128::try_from(s_1215_3).unwrap());
        // C s_1215_5: const #0s : i
        let s_1215_5: i128 = 0;
        // C s_1215_6: add s_1215_5 s_1215_4
        let s_1215_6: i128 = (s_1215_5 + s_1215_4);
        // D s_1215_7: bit-extract s_1215_2 s_1215_0 s_1215_6
        let s_1215_7: Bits = (Bits::new(
            ((s_1215_2) >> (s_1215_0)).value(),
            u16::try_from(s_1215_6).unwrap(),
        ));
        // D s_1215_8: cast reint s_1215_7 -> u8
        let s_1215_8: bool = ((s_1215_7.value()) != 0);
        // D s_1215_9: cast zx s_1215_8 -> bv
        let s_1215_9: Bits = Bits::new(s_1215_8 as u128, 1u16);
        // C s_1215_10: const #1u : u8
        let s_1215_10: bool = true;
        // C s_1215_11: cast zx s_1215_10 -> bv
        let s_1215_11: Bits = Bits::new(s_1215_10 as u128, 1u16);
        // D s_1215_12: cmp-eq s_1215_9 s_1215_11
        let s_1215_12: bool = ((s_1215_9) == (s_1215_11));
        // N s_1215_13: branch s_1215_12 b1218 b1216
        if s_1215_12 {
            return block_1218(state, tracer, fn_state);
        } else {
            return block_1216(state, tracer, fn_state);
        };
    }
    fn block_1216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1216_0: const #0u : u8
        let s_1216_0: bool = false;
        // D s_1216_1: write-var gs#411778 <= s_1216_0
        fn_state.gs_411778 = s_1216_0;
        // N s_1216_2: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_1217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1217_0: read-var gs#411778:u8
        let s_1217_0: bool = fn_state.gs_411778;
        // D s_1217_1: write-var gs#411779 <= s_1217_0
        fn_state.gs_411779 = s_1217_0;
        // N s_1217_2: jump b1214
        return block_1214(state, tracer, fn_state);
    }
    fn block_1218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1218_0: const #8s : i
        let s_1218_0: i128 = 8;
        // D s_1218_1: read-var __opcode:u32
        let s_1218_1: u32 = fn_state.u__opcode;
        // D s_1218_2: cast zx s_1218_1 -> bv
        let s_1218_2: Bits = Bits::new(s_1218_1 as u128, 32u16);
        // C s_1218_3: const #1s : i64
        let s_1218_3: i64 = 1;
        // C s_1218_4: cast zx s_1218_3 -> i
        let s_1218_4: i128 = (i128::try_from(s_1218_3).unwrap());
        // C s_1218_5: const #7s : i
        let s_1218_5: i128 = 7;
        // C s_1218_6: add s_1218_5 s_1218_4
        let s_1218_6: i128 = (s_1218_5 + s_1218_4);
        // D s_1218_7: bit-extract s_1218_2 s_1218_0 s_1218_6
        let s_1218_7: Bits = (Bits::new(
            ((s_1218_2) >> (s_1218_0)).value(),
            u16::try_from(s_1218_6).unwrap(),
        ));
        // D s_1218_8: cast reint s_1218_7 -> u8
        let s_1218_8: u8 = (s_1218_7.value() as u8);
        // D s_1218_9: cast zx s_1218_8 -> bv
        let s_1218_9: Bits = Bits::new(s_1218_8 as u128, 8u16);
        // C s_1218_10: const #94u : u8
        let s_1218_10: u8 = 94;
        // C s_1218_11: cast zx s_1218_10 -> bv
        let s_1218_11: Bits = Bits::new(s_1218_10 as u128, 8u16);
        // D s_1218_12: cmp-eq s_1218_9 s_1218_11
        let s_1218_12: bool = ((s_1218_9) == (s_1218_11));
        // D s_1218_13: write-var gs#411778 <= s_1218_12
        fn_state.gs_411778 = s_1218_12;
        // N s_1218_14: jump b1217
        return block_1217(state, tracer, fn_state);
    }
}
