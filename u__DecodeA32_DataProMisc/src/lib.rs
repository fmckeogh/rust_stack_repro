#![no_std]
#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_doc_comments)]
#![allow(non_upper_case_globals)]
//! BOREALIS GENERATED FILE
extern crate alloc;
use decode_aarch32_instrs_SMLALBB_A1enc_A_txt::*;
use decode_aarch32_instrs_EOR_i_A1enc_A_txt::*;
use decode_aarch32_instrs_MOV_i_A2enc_A_txt::*;
use decode_aarch32_instrs_EOR_r_A1enc_A_txt::*;
use decode_aarch32_instrs_SEVL_A1enc_A_txt::*;
use decode_aarch32_instrs_TSB_A1enc_A_txt::*;
use decode_aarch32_instrs_LDAEX_A1enc_A_txt::*;
use decode_aarch32_instrs_MOV_r_A1enc_A_txt::*;
use decode_aarch32_instrs_LDAH_A1enc_A_txt::*;
use decode_aarch32_instrs_BLX_r_A1enc_A_txt::*;
use decode_aarch32_instrs_STREXH_A1enc_A_txt::*;
use decode_aarch32_instrs_STLEXB_A1enc_A_txt::*;
use decode_aarch32_instrs_ERET_A1enc_A_txt::*;
use decode_aarch32_instrs_STL_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSB_i_A1enc_A_txt::*;
use decode_aarch32_instrs_STRHT_A2enc_A_txt::*;
use decode_aarch32_instrs_BKPT_A1enc_A_txt::*;
use decode_aarch32_instrs_QSUB_A1enc_A_txt::*;
use decode_aarch32_instrs_MLS_A1enc_A_txt::*;
use decode_aarch32_instrs_ADR_A2enc_A_txt::*;
use decode_aarch32_instrs_QADD_A1enc_A_txt::*;
use decode_aarch32_instrs_STREXB_A1enc_A_txt::*;
use decode_aarch32_instrs_STREXD_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSBT_A2enc_A_txt::*;
use decode_aarch32_instrs_SMLAWB_A1enc_A_txt::*;
use decode_aarch32_instrs_HLT_A1enc_A_txt::*;
use decode_aarch32_instrs_BXJ_A1enc_A_txt::*;
use decode_aarch32_instrs_CMN_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_QDSUB_A1enc_A_txt::*;
use decode_aarch32_instrs_SBC_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_STRD_i_A1enc_A_txt::*;
use decode_aarch32_instrs_CLZ_A1enc_A_txt::*;
use decode_aarch32_instrs_MOV_i_A1enc_A_txt::*;
use decode_aarch32_instrs_LDREXD_A1enc_A_txt::*;
use decode_aarch32_instrs_SMLAL_A1enc_A_txt::*;
use decode_aarch32_instrs_STLH_A1enc_A_txt::*;
use decode_aarch32_instrs_UMLAL_A1enc_A_txt::*;
use decode_aarch32_instrs_SMULBB_A1enc_A_txt::*;
use decode_aarch32_instrs_CLRBHB_A1enc_A_txt::*;
use decode_aarch32_instrs_TST_i_A1enc_A_txt::*;
use decode_aarch32_instrs_ADD_r_A1enc_A_txt::*;
use decode_aarch32_instrs_LDREX_A1enc_A_txt::*;
use decode_aarch32_instrs_STREX_A1enc_A_txt::*;
use decode_aarch32_instrs_CMP_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_LDAB_A1enc_A_txt::*;
use decode_aarch32_instrs_ADC_i_A1enc_A_txt::*;
use decode_aarch32_instrs_RSB_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_SUB_SP_i_A1enc_A_txt::*;
use decode_aarch32_instrs_RSB_r_A1enc_A_txt::*;
use decode_aarch32_instrs_MRS_br_A1enc_AS_txt::*;
use decode_aarch32_instrs_LDRSB_r_A1enc_A_txt::*;
use decode_aarch32_instrs_UMULL_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRD_r_A1enc_A_txt::*;
use decode_aarch32_instrs_BX_A1enc_A_txt::*;
use decode_aarch32_instrs_BIC_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_STRHT_A1enc_A_txt::*;
use decode_aarch32_instrs_HVC_A1enc_A_txt::*;
use decode_aarch32_instrs_AND_r_A1enc_A_txt::*;
use decode_aarch32_instrs_ORR_i_A1enc_A_txt::*;
use decode_aarch32_instrs_MVN_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_CRC32_A1enc_A_txt::*;
use decode_aarch32_instrs_STLEXD_A1enc_A_txt::*;
use decode_aarch32_instrs_SUB_r_A1enc_A_txt::*;
use decode_aarch32_instrs_TEQ_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_LDAEXH_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSH_r_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRHT_A1enc_A_txt::*;
use decode_aarch32_instrs_RSC_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_STLB_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRD_l_A1enc_A_txt::*;
use decode_aarch32_instrs_MVN_r_A1enc_A_txt::*;
use decode_aarch32_instrs_YIELD_A1enc_A_txt::*;
use decode_aarch32_instrs_CSDB_A1enc_A_txt::*;
use decode_aarch32_instrs_RSB_i_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRH_r_A1enc_A_txt::*;
use decode_aarch32_instrs_MOV_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_SUB_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_SUB_i_A1enc_A_txt::*;
use decode_aarch32_instrs_LDAEXB_A1enc_A_txt::*;
use decode_aarch32_instrs_CMN_r_A1enc_A_txt::*;
use decode_aarch32_instrs_ADD_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_DBG_A1enc_A_txt::*;
use decode_aarch32_instrs_ADC_r_A1enc_A_txt::*;
use decode_aarch32_instrs_BIC_r_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRH_l_A1enc_A_txt::*;
use decode_aarch32_instrs_BIC_i_A1enc_A_txt::*;
use decode_aarch32_instrs_STRH_i_A1enc_A_txt::*;
use decode_aarch32_instrs_LDREXB_A1enc_A_txt::*;
use decode_aarch32_instrs_STRD_r_A1enc_A_txt::*;
use decode_aarch32_instrs_ADD_i_A1enc_A_txt::*;
use decode_aarch32_instrs_SBC_r_A1enc_A_txt::*;
use decode_aarch32_instrs_TEQ_r_A1enc_A_txt::*;
use decode_aarch32_instrs_LDAEXD_A1enc_A_txt::*;
use decode_aarch32_instrs_SMLABB_A1enc_A_txt::*;
use decode_aarch32_instrs_UMAAL_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRHT_A2enc_A_txt::*;
use decode_aarch32_instrs_MOVT_A1enc_A_txt::*;
use decode_aarch32_instrs_AND_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_MVN_i_A1enc_A_txt::*;
use decode_aarch32_instrs_ORR_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_TST_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_MSR_br_A1enc_AS_txt::*;
use decode_aarch32_instrs_LDA_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRD_i_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSHT_A1enc_A_txt::*;
use decode_aarch32_instrs_EOR_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_NOP_A1enc_A_txt::*;
use decode_aarch32_instrs_QDADD_A1enc_A_txt::*;
use decode_aarch32_instrs_TST_r_A1enc_A_txt::*;
use decode_aarch32_instrs_SMULWB_A1enc_A_txt::*;
use decode_aarch32_instrs_MRS_A1enc_AS_txt::*;
use decode_aarch32_instrs_SBC_i_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSH_l_A1enc_A_txt::*;
use decode_aarch32_instrs_MSR_r_A1enc_AS_txt::*;
use decode_aarch32_instrs_WFI_A1enc_A_txt::*;
use decode_aarch32_instrs_ADR_A1enc_A_txt::*;
use decode_aarch32_instrs_RSC_r_A1enc_A_txt::*;
use decode_aarch32_instrs_CMP_i_A1enc_A_txt::*;
use decode_aarch32_instrs_MUL_A1enc_A_txt::*;
use decode_aarch32_instrs_LDREXH_A1enc_A_txt::*;
use decode_aarch32_instrs_SEV_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSBT_A1enc_A_txt::*;
use decode_aarch32_instrs_SMULL_A1enc_A_txt::*;
use decode_aarch32_instrs_STLEX_A1enc_A_txt::*;
use decode_aarch32_instrs_CMP_r_A1enc_A_txt::*;
use decode_aarch32_instrs_ORR_r_A1enc_A_txt::*;
use decode_aarch32_instrs_SUB_SP_r_A1enc_A_txt::*;
use decode_aarch32_instrs_ADC_rr_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRH_i_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSB_l_A1enc_A_txt::*;
use decode_aarch32_instrs_SMC_A1enc_AS_txt::*;
use decode_aarch32_instrs_RSC_i_A1enc_A_txt::*;
use decode_aarch32_instrs_ADD_SP_r_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSHT_A2enc_A_txt::*;
use decode_aarch32_instrs_WFE_A1enc_A_txt::*;
use decode_aarch32_instrs_TEQ_i_A1enc_A_txt::*;
use decode_aarch32_instrs_ESB_A1enc_A_txt::*;
use decode_aarch32_instrs_ADD_SP_i_A1enc_A_txt::*;
use decode_aarch32_instrs_CMN_i_A1enc_A_txt::*;
use decode_aarch32_instrs_LDRSH_i_A1enc_A_txt::*;
use decode_aarch32_instrs_MSR_i_A1enc_AS_txt::*;
use decode_aarch32_instrs_AND_i_A1enc_A_txt::*;
use decode_aarch32_instrs_MLA_A1enc_A_txt::*;
use decode_aarch32_instrs_STRH_r_A1enc_A_txt::*;
use decode_aarch32_instrs_STLEXH_A1enc_A_txt::*;
use common::*;
pub fn u__DecodeA32_DataProMisc<T: Tracer>(
    state: &mut State,
    tracer: &T,
    gs_403864: i128,
    gs_403865: u32,
) -> () {
    #[derive(Default)]
    struct FunctionState {
        gs_404298: bool,
        u_33101: u32,
        gs_408268: bool,
        gs_406270: bool,
        gs_408445: bool,
        u_32818: u8,
        gs_407641: bool,
        gs_403949: bool,
        gs_405835: bool,
        gs_405268: bool,
        gs_406694: bool,
        gs_408071: bool,
        u_32730: bool,
        u_32694: u32,
        gs_407466: bool,
        gs_407895: bool,
        gs_406983: bool,
        gs_406785: bool,
        gs_405655: bool,
        u_33247: u8,
        u_33260: u8,
        u_32495: u8,
        u_33106: u8,
        gs_405892: bool,
        gs_407784: bool,
        gs_407063: bool,
        gs_407309: bool,
        gs_408107: bool,
        u_32873: u32,
        gs_405395: bool,
        gs_407374: bool,
        u_32443: u8,
        gs_408089: bool,
        gs_407711: bool,
        u_32590: u8,
        u_33080: u8,
        u_32948: u8,
        gs_405238: bool,
        gs_407945: bool,
        u_32722: bool,
        u_32563: u8,
        u_33134: u32,
        u_33028: u8,
        u_32459: u32,
        gs_405330: bool,
        gs_407107: bool,
        gs_404301: bool,
        gs_404523: bool,
        gs_404566: bool,
        gs_407856: bool,
        gs_406017: bool,
        u_32995: u8,
        gs_407552: bool,
        gs_407348: bool,
        u_32987: u8,
        gs_408366: bool,
        u_32555: u32,
        gs_406437: bool,
        u_32774: u32,
        u_32648: u8,
        gs_404295: bool,
        gs_406425: bool,
        gs_404774: bool,
        gs_408163: bool,
        u_33143: u32,
        gs_404356: bool,
        gs_408376: bool,
        u_32690: u8,
        gs_405091: bool,
        gs_406842: bool,
        gs_404233: bool,
        gs_406779: bool,
        gs_404264: bool,
        u_32939: u32,
        u_32478: u32,
        gs_404107: bool,
        gs_405198: bool,
        gs_406265: bool,
        u_33102: u8,
        u_32803: u8,
        gs_406764: bool,
        gs_405649: bool,
        gs_403896: bool,
        gs_404501: bool,
        u_33078: u8,
        u_32967: bool,
        gs_408515: bool,
        gs_404265: bool,
        gs_407373: bool,
        gs_405987: bool,
        gs_405849: bool,
        gs_404930: bool,
        gs_405634: bool,
        gs_408396: bool,
        u_32647: u8,
        u_33025: u8,
        gs_407516: bool,
        gs_404947: bool,
        gs_405891: bool,
        gs_407761: bool,
        u_32644: u32,
        gs_407622: bool,
        gs_404966: bool,
        gs_406012: bool,
        gs_407687: bool,
        gs_407162: bool,
        gs_404933: bool,
        gs_408399: bool,
        gs_405056: bool,
        u_33009: bool,
        gs_407580: bool,
        gs_408324: bool,
        gs_404368: bool,
        u_32761: u8,
        gs_407824: bool,
        gs_405409: bool,
        gs_405819: bool,
        u_33257: u32,
        gs_407625: bool,
        gs_404608: bool,
        gs_406223: bool,
        u_33227: u8,
        gs_405347: bool,
        u_33092: u16,
        u_33219: u8,
        u_33208: u8,
        u_33207: u8,
        gs_407972: bool,
        gs_407933: bool,
        gs_406907: bool,
        u_32534: u8,
        gs_404834: bool,
        gs_407534: bool,
        gs_407205: bool,
        gs_406222: bool,
        gs_404468: bool,
        gs_405342: bool,
        gs_404390: bool,
        gs_408053: bool,
        u_32745: u8,
        gs_406577: bool,
        gs_404405: bool,
        u_32493: u8,
        gs_404304: bool,
        gs_407531: bool,
        gs_404092: bool,
        u_32601: u32,
        gs_406491: bool,
        u_32772: u8,
        gs_408250: bool,
        gs_408272: bool,
        gs_404379: bool,
        gs_407549: bool,
        gs_404713: bool,
        gs_407930: bool,
        gs_405610: bool,
        gs_408201: bool,
        gs_405408: bool,
        gs_407086: bool,
        u_33098: u8,
        gs_403972: bool,
        gs_404444: bool,
        gs_404431: bool,
        gs_405781: bool,
        gs_407430: bool,
        gs_405547: bool,
        u_32749: u32,
        gs_406841: bool,
        gs_405510: bool,
        u_32475: u8,
        gs_404430: bool,
        gs_404049: bool,
        gs_404203: bool,
        gs_407219: bool,
        gs_406130: bool,
        u_32633: u8,
        gs_408472: bool,
        gs_407349: bool,
        gs_405169: bool,
        gs_404350: bool,
        gs_406660: bool,
        gs_405018: bool,
        u_32551: u8,
        gs_407369: bool,
        u_33024: u32,
        u_33153: u8,
        gs_404773: bool,
        u_32494: u8,
        gs_405983: bool,
        u_33202: u8,
        u_32936: bool,
        gs_405633: bool,
        gs_405164: bool,
        gs_408419: bool,
        gs_407563: bool,
        u_32474: u8,
        u_33201: u32,
        gs_404411: bool,
        gs_404341: bool,
        u_32848: u32,
        u_32768: u8,
        gs_406923: bool,
        gs_408080: bool,
        u_32603: bool,
        u_32491: u8,
        gs_406527: bool,
        u_33149: u8,
        gs_407286: bool,
        u_33140: u32,
        gs_404344: bool,
        u_33135: u8,
        gs_408350: bool,
        gs_404500: bool,
        gs_405551: bool,
        gs_405123: bool,
        u_32731: u8,
        gs_407058: bool,
        gs_408155: bool,
        gs_404316: bool,
        gs_407179: bool,
        u_33264: u8,
        gs_407446: bool,
        gs_406645: bool,
        gs_404607: bool,
        gs_405478: bool,
        gs_406324: bool,
        u_32497: u32,
        gs_406727: bool,
        gs_406013: bool,
        gs_405035: bool,
        u_32971: u8,
        gs_407890: bool,
        u_32992: u8,
        gs_408422: bool,
        gs_405854: bool,
        gs_407246: bool,
        u_33013: u8,
        gs_404076: bool,
        gs_408058: bool,
        u_33259: u8,
        gs_406659: bool,
        gs_406044: bool,
        u_32721: u8,
        gs_406159: bool,
        gs_404402: bool,
        u_32812: u8,
        u_32720: u32,
        gs_404529: bool,
        gs_405165: bool,
        gs_408074: bool,
        gs_408011: bool,
        gs_404156: bool,
        gs_407449: bool,
        u_33090: u8,
        gs_404744: bool,
        gs_406919: bool,
        u_32899: u8,
        gs_404910: bool,
        gs_407185: bool,
        u_33278: u8,
        gs_404704: bool,
        gs_407208: bool,
        u_32492: u8,
        gs_408460: bool,
        gs_405838: bool,
        u_32550: u32,
        u_32370: u32,
        u_32689: bool,
        gs_407478: bool,
        gs_407168: bool,
        u_32811: u32,
        gs_405611: bool,
        option_name: u8,
        u_32671: u8,
        gs_405002: bool,
        gs_407766: bool,
        u_32677: u8,
        gs_407999: bool,
        gs_407035: bool,
        gs_407894: bool,
        u__opcode: u32,
        u_32627: u32,
        gs_404420: bool,
        gs_404185: bool,
        gs_405546: bool,
        gs_404683: bool,
        gs_404319: bool,
        gs_407981: bool,
        gs_406695: bool,
        gs_407909: bool,
        u_33096: u8,
        u_33182: u8,
        gs_406738: bool,
        gs_406594: bool,
        gs_407431: bool,
        gs_405150: bool,
        gs_406294: bool,
        u_33038: u32,
        gs_407725: bool,
        gs_404539: bool,
        u_32465: u8,
        u_33212: u8,
        gs_404238: bool,
        u_32673: bool,
        u_32977: u8,
        gs_407411: bool,
        gs_405375: bool,
        u_32807: u8,
        u_33217: u8,
        gs_404972: bool,
        gs_406323: bool,
        gs_408390: bool,
        u_32670: u32,
        gs_405061: bool,
        gs_408479: bool,
        u_32932: u8,
        gs_406553: bool,
        gs_404612: bool,
        gs_406347: bool,
        u_33062: u32,
        gs_405569: bool,
        u_33235: u8,
        u_33075: u32,
        gs_404743: bool,
        u_33026: bool,
        u_33170: u32,
        gs_406790: bool,
        gs_405443: bool,
        u_32404: u32,
        u_32864: u32,
        gs_407131: bool,
        gs_407969: bool,
        u_32388: u32,
        u_33241: u8,
        gs_406593: bool,
        gs_407326: bool,
        gs_405170: bool,
        mask: u8,
        gs_404160: bool,
        gs_404329: bool,
        gs_407423: bool,
        gs_407821: bool,
        gs_405482: bool,
        gs_407315: bool,
        gs_404426: bool,
        u_32446: u32,
        gs_407082: bool,
        u_32980: u8,
        gs_408514: bool,
        gs_408273: bool,
        u_33242: u8,
        gs_408002: bool,
        gs_405414: bool,
        gs_405374: bool,
        gs_406904: bool,
        u_33131: u32,
        gs_408190: bool,
        C: bool,
        u_32809: u8,
        gs_405919: bool,
        gs_404489: bool,
        u_32855: u32,
        gs_408294: bool,
        gs_404371: bool,
        gs_406877: bool,
        gs_405897: bool,
        gs_405128: bool,
        u_32781: u32,
        gs_406580: bool,
        gs_408409: bool,
        u_33216: u32,
        gs_408236: bool,
        u_32450: u32,
        u_32764: u8,
        gs_408527: bool,
        gs_407112: bool,
        gs_406063: bool,
        u_32541: u8,
        gs_404866: bool,
        u_32605: u8,
        gs_408093: bool,
        gs_408083: bool,
        u_32589: u8,
        gs_408454: bool,
        gs_403973: bool,
        gs_405346: bool,
        gs_405662: bool,
        gs_405748: bool,
        u_33014: u8,
        u_33277: u32,
        gs_406464: bool,
        gs_407827: bool,
        u_33150: u8,
        u_32975: u8,
        u_32481: u16,
        gs_404506: bool,
        u_33258: u8,
        gs_406551: bool,
        gs_407292: bool,
        gs_405041: bool,
        u_33097: u8,
        gs_404546: bool,
        gs_405761: bool,
        gs_405850: bool,
        gs_407202: bool,
        u_32950: u8,
        u_33073: u16,
        gs_404330: bool,
        gs_408504: bool,
        u_32769: u8,
        u_32966: bool,
        u_32455: u8,
        u_33166: u8,
        u_33104: u8,
        gs_407950: bool,
        gs_405786: bool,
        u_32469: u8,
        gs_407178: bool,
        gs_407417: bool,
        u_32974: u8,
        u_32710: bool,
        u_33248: u8,
        u_32593: u32,
        u_33159: u8,
        u_33180: u32,
        gs_406299: bool,
        gs_405306: bool,
        gs_405809: bool,
        u_32757: bool,
        gs_405706: bool,
        u_32584: u32,
        u_32947: u32,
        u_32747: u8,
        gs_407804: bool,
        gs_406699: bool,
        gs_408021: bool,
        gs_407665: bool,
        u_32604: u8,
        u_33226: u32,
        u_32457: u8,
        u_33160: bool,
        gs_403872: bool,
        gs_406428: bool,
        u_32479: u8,
        gs_404207: bool,
        u_33234: u32,
        gs_406557: bool,
        gs_405055: bool,
        gs_407986: bool,
        gs_408077: bool,
        gs_404310: bool,
        gs_407833: bool,
        u_33095: u8,
        gs_404260: bool,
        u_32631: bool,
        M1: u8,
        gs_405939: bool,
        gs_406619: bool,
        u_32734: u8,
        gs_406805: bool,
        u_33184: u8,
        u_33255: u8,
        gs_407140: bool,
        gs_408533: bool,
        u_32538: bool,
        u_33070: u32,
        gs_405686: bool,
        gs_408146: bool,
        u_32759: u8,
        gs_408035: bool,
        gs_405483: bool,
        gs_408044: bool,
        u_33231: u8,
        gs_405221: bool,
        gs_407604: bool,
        u_32976: u8,
        gs_404906: bool,
        u_32985: u32,
        u_33071: u8,
        gs_406372: bool,
        gs_408536: bool,
        gs_404946: bool,
        gs_404633: bool,
        gs_405762: bool,
        gs_407420: bool,
        gs_404313: bool,
        u_33072: u8,
        u_32970: u8,
        u_32806: u8,
        u_32965: u8,
        gs_405581: bool,
        gs_407291: bool,
        u_32839: u32,
        gs_404003: bool,
        gs_406076: bool,
        gs_406346: bool,
        gs_408372: bool,
        gs_407839: bool,
        gs_405341: bool,
        gs_406192: bool,
        u_33083: u8,
        gs_407519: bool,
        gs_408259: bool,
        gs_404856: bool,
        gs_404232: bool,
        u_32981: u8,
        u_32325: u32,
        u_32725: u8,
        gs_407036: bool,
        gs_404897: bool,
        gs_406552: bool,
        gs_404670: bool,
        gs_405896: bool,
        gs_405450: bool,
        u_32937: u8,
        gs_408393: bool,
        gs_408410: bool,
        u_32355: u32,
        gs_404927: bool,
        gs_404030: bool,
        gs_404833: bool,
        gs_407128: bool,
        gs_407145: bool,
        u_33198: u8,
        gs_407705: bool,
        u_32988: u8,
        gs_406924: bool,
        u_32561: u8,
        gs_407579: bool,
        gs_405038: bool,
        gs_407180: bool,
        gs_406188: bool,
        gs_405398: bool,
        gs_405754: bool,
        u_32923: u32,
        gs_405232: bool,
        u_33031: u32,
        u_33254: u8,
        u_33176: u32,
        gs_405575: bool,
        gs_404396: bool,
        gs_405192: bool,
        gs_407452: bool,
        u_32688: u8,
        gs_406496: bool,
        gs_405032: bool,
        gs_408149: bool,
        u_32383: u32,
        gs_405445: bool,
        gs_408237: bool,
        u_32760: u8,
        gs_406815: bool,
        gs_404868: bool,
        gs_408152: bool,
        gs_404701: bool,
        u_32462: u16,
        u_32982: u8,
        u_33079: u8,
        u_32800: u8,
        gs_408346: bool,
        u_32557: u8,
        gs_404091: bool,
        u_32636: u32,
        gs_405008: bool,
        gs_407752: bool,
        gs_406371: bool,
        gs_406918: bool,
        u_33084: u8,
        gs_406982: bool,
        gs_405629: bool,
        u_32464: u32,
        gs_404399: bool,
        u_32752: u8,
        u_33012: u8,
        u_33204: u8,
        gs_405815: bool,
        gs_405504: bool,
        gs_407321: bool,
        gs_404593: bool,
        gs_407607: bool,
        u_32447: u8,
        gs_407537: bool,
        gs_407031: bool,
        gs_405922: bool,
        u_33082: u32,
        gs_405728: bool,
        gs_404579: bool,
        gs_408143: bool,
        gs_407510: bool,
        u_32608: u32,
        gs_408501: bool,
        u_32540: bool,
        gs_404378: bool,
        u_32969: u8,
        gs_404456: bool,
        gs_405392: bool,
        u_33177: u8,
        gs_405877: bool,
        gs_405507: bool,
        gs_406377: bool,
        gs_407760: bool,
        u_32546: u8,
        u_32973: u32,
        gs_408457: bool,
        u_32983: u8,
        gs_408498: bool,
        gs_407861: bool,
        u_32767: u8,
        u_32585: u8,
        u_33221: u32,
        u_33154: bool,
        u_33239: u32,
        gs_404347: bool,
        gs_406169: bool,
        u_33232: u8,
        gs_407312: bool,
        u_32755: u32,
        u_32531: bool,
        u_32711: u8,
        gs_404707: bool,
        u_32802: u8,
        gs_407818: bool,
        u_32645: u8,
        gs_407619: bool,
        gs_406376: bool,
        gs_407247: bool,
        gs_407881: bool,
        gs_404054: bool,
        gs_408437: bool,
        gs_408262: bool,
        gs_404575: bool,
        u_32732: u8,
        gs_405951: bool,
        gs_405301: bool,
        u_33178: u8,
        u_32756: u8,
        gs_407487: bool,
        u_33218: u8,
        gs_406469: bool,
        gs_405780: bool,
        u_33245: u32,
        u_33123: u32,
        gs_404676: bool,
        gs_404450: bool,
        gs_404029: bool,
        gs_404636: bool,
        gs_405089: bool,
        gs_406045: bool,
        gs_407714: bool,
        gs_404599: bool,
        gs_407562: bool,
        gs_408008: bool,
        gs_407963: bool,
        gs_406060: bool,
        gs_406618: bool,
        gs_407269: bool,
        u_32472: u8,
        gs_408542: bool,
        u_32444: u8,
        gs_404453: bool,
        gs_406492: bool,
        gs_406624: bool,
        gs_407613: bool,
        gs_405988: bool,
        gs_407662: bool,
        gs_405299: bool,
        gs_408507: bool,
        gs_408022: bool,
        gs_408431: bool,
        gs_404393: bool,
        gs_404978: bool,
        u_32486: u8,
        gs_408466: bool,
        u_32968: bool,
        gs_406843: bool,
        gs_404839: bool,
        u_32674: bool,
        gs_407087: bool,
        gs_407287: bool,
        u_32498: u8,
        gs_404108: bool,
        gs_406521: bool,
        gs_407787: bool,
        gs_408017: bool,
        u_32507: u32,
        gs_407144: bool,
        gs_408320: bool,
        gs_407484: bool,
        gs_405266: bool,
        gs_406269: bool,
        u_32771: u32,
        gs_407405: bool,
        gs_406124: bool,
        u_33269: u8,
        gs_407396: bool,
        gs_404802: bool,
        gs_408187: bool,
        gs_405957: bool,
        u_32331: u32,
        gs_407481: bool,
        u_33103: u8,
        gs_404002: bool,
        gs_404569: bool,
        gs_404208: bool,
        gs_404894: bool,
        u_32539: bool,
        u_32821: u8,
        gs_407601: bool,
        u_33268: u32,
        sz: u8,
        gs_407475: bool,
        gs_406072: bool,
        u_33183: u8,
        u_32429: u32,
        gs_405215: bool,
        u_32562: u8,
        u_32742: u32,
        gs_406217: bool,
        u_33191: u32,
        u_32964: u32,
        gs_406468: bool,
        gs_403997: bool,
        gs_406436: bool,
        gs_404322: bool,
        gs_404630: bool,
        gs_407325: bool,
        gs_406095: bool,
        gs_406789: bool,
        u_32951: bool,
        gs_405272: bool,
        gs_407949: bool,
        u_32790: u32,
        gs_406300: bool,
        u_32485: u8,
        gs_408428: bool,
        gs_405305: bool,
        u_32420: u32,
        u_32901: u32,
        gs_404647: bool,
        u_32986: u8,
        u_33224: u8,
        gs_406724: bool,
        u_32461: u8,
        gs_405477: bool,
        gs_403895: bool,
        gs_405709: bool,
        gs_408130: bool,
        gs_406040: bool,
        gs_407815: bool,
        gs_406951: bool,
        u_33261: u8,
        u_32766: u8,
        gs_407635: bool,
        gs_408298: bool,
        gs_408434: bool,
        gs_405572: bool,
        gs_406665: bool,
        u_32687: u32,
        u_33168: u16,
        gs_405806: bool,
        gs_404155: bool,
        gs_408469: bool,
        gs_407522: bool,
        u_32736: u32,
        gs_408181: bool,
        gs_407681: bool,
        gs_408041: bool,
        u_32991: u32,
        u_33243: u8,
        gs_404161: bool,
        gs_408425: bool,
        gs_408129: bool,
        gs_407927: bool,
        u_33236: u8,
        u_33099: u8,
        u_33027: u8,
        gs_404867: bool,
        gs_407252: bool,
        gs_404184: bool,
        gs_404653: bool,
        gs_408351: bool,
        gs_408530: bool,
        gs_405300: bool,
        u_32880: u32,
        gs_406422: bool,
        u_32558: u8,
        gs_408220: bool,
        gs_405712: bool,
        gs_407975: bool,
        u_32542: u8,
        u_33206: u32,
        gs_407855: bool,
        gs_404838: bool,
        R: bool,
        u_33091: u8,
        gs_407914: bool,
        gs_404800: bool,
        u_33085: u8,
        gs_404492: bool,
        u_33162: bool,
        gs_406162: bool,
        gs_405890: bool,
        gs_406737: bool,
        u_33263: u32,
        gs_407546: bool,
        gs_405652: bool,
        gs_407513: bool,
        u_33211: u32,
        gs_407842: bool,
        u_33196: u32,
        gs_407443: bool,
        gs_407985: bool,
        u_32714: u32,
        gs_405237: bool,
        gs_405942: bool,
        u_32602: u8,
        u_32543: u8,
        u_33167: bool,
        gs_406642: bool,
        u_32819: u8,
        u_32989: u8,
        u_33016: u32,
        u_32630: bool,
        gs_408539: bool,
        gs_405954: bool,
        u_32556: u8,
        gs_408125: bool,
        gs_408110: bool,
        gs_407717: bool,
        gs_408214: bool,
        u_32898: u32,
        gs_405524: bool,
        gs_405333: bool,
        u_33209: u8,
        gs_407440: bool,
        gs_406522: bool,
        u_32545: u32,
        gs_405327: bool,
        u_32908: u32,
        gs_407218: bool,
        gs_406558: bool,
        u_32471: u32,
        gs_406658: bool,
        gs_405518: bool,
        gs_406848: bool,
        u_32758: u8,
        u_33203: u8,
        gs_404960: bool,
        gs_404353: bool,
        gs_405948: bool,
        gs_404540: bool,
        gs_407501: bool,
        gs_404982: bool,
        gs_408200: bool,
        u_32933: u8,
        u_32726: u8,
        gs_405724: bool,
        gs_403873: bool,
        u_32733: u8,
        gs_407525: bool,
        u_32606: u8,
        gs_406400: bool,
        gs_408314: bool,
        u_32364: u32,
        gs_405552: bool,
        u_32679: u32,
        gs_405231: bool,
        gs_408119: bool,
        gs_404872: bool,
        gs_407275: bool,
        u_32490: u32,
        gs_406910: bool,
        gs_407125: bool,
        gs_406811: bool,
        gs_404462: bool,
        u_33163: u8,
        gs_406295: bool,
        gs_403998: bool,
        gs_407836: bool,
        gs_406127: bool,
        u_33029: u8,
        u_33008: u8,
        gs_404698: bool,
        gs_408172: bool,
        gs_407585: bool,
        u_33007: u32,
        u_33138: u8,
        u_33274: u32,
        gs_404414: bool,
        u_32536: u32,
        gs_407543: bool,
        u_32813: u8,
        gs_408184: bool,
        gs_406497: bool,
        u_32516: u32,
        gs_405729: bool,
        gs_406104: bool,
        u_33047: u32,
        gs_405523: bool,
        u_32661: u32,
        gs_404646: bool,
        u_33246: u8,
        gs_405415: bool,
        gs_404768: bool,
        gs_406092: bool,
        gs_405687: bool,
        gs_405585: bool,
        gs_408340: bool,
        u_33087: u8,
        gs_404769: bool,
        gs_408162: bool,
        u_33181: u8,
        gs_408175: bool,
        gs_407790: bool,
        gs_406583: bool,
        gs_407414: bool,
        u_33275: u8,
        u_32488: u8,
        u_32575: u32,
        gs_407746: bool,
        u_32448: u8,
        u_32701: u32,
        gs_406098: bool,
        u_32553: u8,
        gs_404963: bool,
        u_33186: u32,
        u_32691: u8,
        u_32799: u32,
        gs_406170: bool,
        u_32672: bool,
        merge_var: ProductType7b8639ca40b2f578,
        u_32823: u32,
        gs_407803: bool,
        u_33132: u8,
        u_32346: u32,
        gs_407493: bool,
        gs_404873: bool,
        u_32997: u32,
        gs_407642: bool,
        gs_405663: bool,
        gs_406193: bool,
        u_33193: u8,
        gs_403920: bool,
        u_32629: bool,
        gs_404486: bool,
        u_32709: u8,
        gs_408299: bool,
        gs_407395: bool,
        gs_407913: bool,
        gs_405803: bool,
        u_32646: bool,
        gs_404652: bool,
        u_33265: u8,
        u_33229: u32,
        u_32467: u8,
        gs_404359: bool,
        gs_406700: bool,
        gs_407731: bool,
        gs_405841: bool,
        gs_407610: bool,
        u_32935: bool,
        gs_406759: bool,
        gs_407001: bool,
        u_33237: u8,
        gs_406625: bool,
        u_33108: u32,
        gs_408288: bool,
        gs_406664: bool,
        u_32979: u32,
        gs_406140: bool,
        gs_404596: bool,
        u_32954: u32,
        gs_406753: bool,
        gs_408057: bool,
        u_32413: u32,
        gs_405965: bool,
        gs_405044: bool,
        gs_404365: bool,
        gs_405153: bool,
        u_32442: u32,
        u_32529: u32,
        u_32765: bool,
        u_32723: u8,
        u_32484: u8,
        gs_404417: bool,
        gs_404280: bool,
        u_33148: u32,
        gs_405519: bool,
        gs_405449: bool,
        u_32468: u8,
        u_32805: u32,
        gs_406342: bool,
        u_32931: u32,
        u_32628: u8,
        gs_408480: bool,
        u_32830: u32,
        gs_406952: bool,
        u_32454: u32,
        gs_404362: bool,
        u_32525: u32,
        gs_404648: bool,
        u_32692: u8,
        u_33192: u8,
        gs_408116: bool,
        u_33173: u8,
        gs_405682: bool,
        gs_406109: bool,
        u_32632: u8,
        u_32751: bool,
        u_32480: u8,
        gs_407344: bool,
        u_32676: u8,
        u_32533: u8,
        gs_405785: bool,
        gs_407749: bool,
        u_33266: u8,
        gs_404053: bool,
        gs_405122: bool,
        gs_407730: bool,
        gs_406883: bool,
        u_32817: u32,
        gs_408377: bool,
        gs_407637: bool,
        u_32532: u8,
        u_33010: bool,
        gs_408256: bool,
        u_32934: u8,
        gs_407408: bool,
        u_33240: u8,
        gs_407939: bool,
        gs_406816: bool,
        gs_407862: bool,
        u_33152: u32,
        u_33223: u8,
        gs_404281: bool,
        gs_406410: bool,
        gs_407165: bool,
        u_32460: u8,
        gs_407062: bool,
        u_33089: u32,
        gs_403925: bool,
        gs_406141: bool,
        gs_405014: bool,
        u_32565: u32,
        gs_408047: bool,
        u_32560: u32,
        gs_406136: bool,
        gs_406441: bool,
        gs_405096: bool,
        gs_406066: bool,
        gs_405930: bool,
        gs_407081: bool,
        gs_408113: bool,
        gs_407936: bool,
        u_32708: u32,
        gs_405090: bool,
        gs_407598: bool,
        gs_408402: bool,
        u_32728: u32,
        gs_407490: bool,
        gs_407005: bool,
        gs_407214: bool,
        gs_404025: bool,
        gs_405060: bool,
        gs_404447: bool,
        u_32451: u8,
        u_32651: u32,
        gs_404472: bool,
        gs_408253: bool,
        u_32438: u32,
        u_32994: u8,
        u_33252: u8,
        gs_406077: bool,
        gs_407830: bool,
        u_32914: u32,
        gs_407793: bool,
        u_32889: u32,
        gs_407500: bool,
        gs_406763: bool,
        u_33222: u8,
        gs_404563: bool,
        gs_407455: bool,
        gs_405197: bool,
        u_33056: u32,
        gs_404900: bool,
        u_32395: u32,
        u_33156: bool,
        gs_405233: bool,
        gs_403950: bool,
        u_33161: u8,
        u_33172: bool,
        gs_404911: bool,
        gs_406442: bool,
        gs_406620: bool,
        gs_406878: bool,
        gs_407139: bool,
        u_33174: u8,
        u_32530: u8,
        gs_407528: bool,
        gs_404721: bool,
        gs_404924: bool,
        gs_406156: bool,
        gs_405681: bool,
        gs_404695: bool,
        gs_408217: bool,
        gs_405129: bool,
        u_32552: u8,
        gs_407232: bool,
        u_32744: bool,
        gs_406648: bool,
        gs_408463: bool,
        gs_404307: bool,
        gs_405820: bool,
        gs_404720: bool,
        gs_405964: bool,
        gs_408492: bool,
        u_33115: u32,
        gs_405476: bool,
        gs_406108: bool,
        gs_406246: bool,
        u_32483: u32,
        gs_405855: bool,
        gs_405005: bool,
        gs_407030: bool,
        gs_407671: bool,
        gs_403891: bool,
        gs_406969: bool,
        gs_406589: bool,
        gs_407668: bool,
        gs_408094: bool,
        gs_406847: bool,
        u_32949: u8,
        gs_404048: bool,
        gs_407845: bool,
        gs_405410: bool,
        gs_405019: bool,
        gs_407272: bool,
        gs_408232: bool,
        u_32750: u8,
        gs_407006: bool,
        gs_406831: bool,
        u_32548: u8,
        gs_406526: bool,
        u_32952: u8,
        gs_406882: bool,
        gs_407708: bool,
        u_33171: u8,
        gs_406416: bool,
        u_32586: bool,
        gs_406401: bool,
        gs_404075: bool,
        gs_404807: bool,
        u_32634: u8,
        gs_407616: bool,
        u_32993: u8,
        u_33155: u8,
        u_33094: u32,
        gs_404237: bool,
        u_32378: u32,
        gs_407682: bool,
        gs_405722: bool,
        u_33165: u32,
        gs_407251: bool,
        u_33253: u8,
        gs_403926: bool,
        gs_406733: bool,
        gs_404408: bool,
        u_33272: u8,
        gs_405273: bool,
        u_33199: u8,
        gs_407285: bool,
        gs_405369: bool,
        gs_407966: bool,
        gs_408444: bool,
        gs_403921: bool,
        gs_407184: bool,
        gs_407465: bool,
        gs_407781: bool,
        u_33137: u32,
        u_33249: u8,
        u_33076: u8,
        gs_404131: bool,
        gs_407857: bool,
        gs_408325: bool,
        u_32456: u8,
        gs_404710: bool,
        u_32588: bool,
        u_32649: u8,
        u_33213: u8,
        gs_407765: bool,
        gs_405916: bool,
        gs_405193: bool,
        u_32476: u8,
        gs_405267: bool,
        gs_404673: bool,
        gs_407235: bool,
        gs_408524: bool,
        gs_407584: bool,
        gs_407796: bool,
        u_33141: u8,
        gs_407238: bool,
        gs_404983: bool,
        gs_406721: bool,
        gs_407458: bool,
        gs_405156: bool,
        u_33197: u8,
        u_32537: u8,
        gs_406218: bool,
        gs_406946: bool,
        gs_404459: bool,
        gs_404473: bool,
        u_32675: u8,
        gs_407111: bool,
        gs_408495: bool,
        gs_404999: bool,
        gs_406975: bool,
        gs_407726: bool,
        u_32487: u8,
        gs_408489: bool,
        gs_406876: bool,
        gs_408226: bool,
        gs_406419: bool,
        gs_405124: bool,
        gs_404806: bool,
        gs_408196: bool,
        gs_404613: bool,
        gs_405751: bool,
        gs_404505: bool,
        gs_406247: bool,
        gs_404936: bool,
        u_33214: u8,
        gs_404801: bool,
        gs_405054: bool,
        gs_407540: bool,
        gs_404969: bool,
        u_32466: u8,
        gs_407688: bool,
        u_32591: u8,
        gs_404130: bool,
        u_32746: u8,
        gs_406972: bool,
        gs_404684: bool,
        gs_407558: bool,
        gs_404292: bool,
        gs_408038: bool,
        gs_405218: bool,
        gs_405874: bool,
        gs_407884: bool,
        u_32724: u8,
        gs_405370: bool,
        gs_405880: bool,
        u_33194: u8,
        gs_404996: bool,
        u_32547: u8,
        gs_403968: bool,
        gs_408178: bool,
        gs_405945: bool,
        gs_406018: bool,
        gs_404545: bool,
        gs_407659: bool,
        gs_404126: bool,
        u_33086: u8,
        u_32743: u8,
        gs_405606: bool,
        u_33230: u8,
        u_32729: u8,
        gs_404942: bool,
        u_32473: u8,
        gs_405723: bool,
        gs_405586: bool,
        u_32587: bool,
        gs_406693: bool,
        u_33077: u8,
        u_32618: u32,
        gs_404541: bool,
        u_32712: u16,
        u_32815: u8,
        u_33011: bool,
        u_32763: u32,
        u_33105: u8,
        u_32753: u16,
        gs_405929: bool,
        u_33271: u32,
        gs_406413: bool,
        gs_405095: bool,
        gs_404739: bool,
        u_33158: u32,
        gs_405444: bool,
        u_32452: u8,
        u_32339: u32,
        gs_404526: bool,
        gs_407683: bool,
        gs_404580: bool,
        gs_408223: bool,
        u_32801: u8,
        u_32814: u8,
        u_32820: u8,
        u_32808: u8,
        u_32500: u32,
        gs_406947: bool,
        u_33251: u32,
        gs_407636: bool,
        gs_408005: bool,
        gs_403864: i128,
        gs_403865: u32,
    }
    let fn_state = FunctionState {
        gs_403864,
        gs_403865,
        ..Default::default()
    };
    return block_0(state, tracer, fn_state);
    fn block_0<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_0_0: read-var gs#403864:i
        let s_0_0: i128 = fn_state.gs_403864;
        // D s_0_1: write-var merge#var.0 <= s_0_0
        fn_state.merge_var._0 = s_0_0;
        // D s_0_2: read-var gs#403865:u32
        let s_0_2: u32 = fn_state.gs_403865;
        // D s_0_3: write-var merge#var.1 <= s_0_2
        fn_state.merge_var._1 = s_0_2;
        // D s_0_4: read-var merge#var.1:struct
        let s_0_4: u32 = fn_state.merge_var._1;
        // D s_0_5: write-var __opcode <= s_0_4
        fn_state.u__opcode = s_0_4;
        // C s_0_6: const #21s : i
        let s_0_6: i128 = 21;
        // D s_0_7: read-var __opcode:u32
        let s_0_7: u32 = fn_state.u__opcode;
        // D s_0_8: cast zx s_0_7 -> bv
        let s_0_8: Bits = Bits::new(s_0_7 as u128, 32u16);
        // C s_0_9: const #1s : i64
        let s_0_9: i64 = 1;
        // C s_0_10: cast zx s_0_9 -> i
        let s_0_10: i128 = (i128::try_from(s_0_9).unwrap());
        // C s_0_11: const #6s : i
        let s_0_11: i128 = 6;
        // C s_0_12: add s_0_11 s_0_10
        let s_0_12: i128 = (s_0_11 + s_0_10);
        // D s_0_13: bit-extract s_0_8 s_0_6 s_0_12
        let s_0_13: Bits = (Bits::new(
            ((s_0_8) >> (s_0_6)).value(),
            u16::try_from(s_0_12).unwrap(),
        ));
        // D s_0_14: cast reint s_0_13 -> u8
        let s_0_14: u8 = (s_0_13.value() as u8);
        // D s_0_15: cast zx s_0_14 -> bv
        let s_0_15: Bits = Bits::new(s_0_14 as u128, 7u16);
        // C s_0_16: const #21u : u8
        let s_0_16: u8 = 21;
        // C s_0_17: cast zx s_0_16 -> bv
        let s_0_17: Bits = Bits::new(s_0_16 as u128, 7u16);
        // D s_0_18: cmp-eq s_0_15 s_0_17
        let s_0_18: bool = ((s_0_15) == (s_0_17));
        // N s_0_19: branch s_0_18 b2996 b1
        if s_0_18 {
            return block_2996(state, tracer, fn_state);
        } else {
            return block_1(state, tracer, fn_state);
        };
    }
    fn block_1<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1_0: const #0u : u8
        let s_1_0: bool = false;
        // D s_1_1: write-var gs#403873 <= s_1_0
        fn_state.gs_403873 = s_1_0;
        // N s_1_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_2<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2_0: read-var gs#403873:u8
        let s_2_0: bool = fn_state.gs_403873;
        // D s_2_1: not s_2_0
        let s_2_1: bool = !s_2_0;
        // N s_2_2: branch s_2_1 b4 b3
        if s_2_1 {
            return block_4(state, tracer, fn_state);
        } else {
            return block_3(state, tracer, fn_state);
        };
    }
    fn block_3<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_3_0: const #2813s : i
        let s_3_0: i128 = 2813;
        // C s_3_1: const #14696u : u32
        let s_3_1: u32 = 14696;
        // N s_3_2: write-reg s_3_1 <= s_3_0
        let s_3_2: () = {
            state.write_register::<i128>(s_3_1 as isize, s_3_0);
            tracer.write_register(s_3_1 as isize, s_3_0);
        };
        // C s_3_3: const #28s : i
        let s_3_3: i128 = 28;
        // C s_3_4: const #4s : i
        let s_3_4: i128 = 4;
        // D s_3_5: read-var __opcode:u32
        let s_3_5: u32 = fn_state.u__opcode;
        // D s_3_6: cast zx s_3_5 -> bv
        let s_3_6: Bits = Bits::new(s_3_5 as u128, 32u16);
        // D s_3_7: bit-extract s_3_6 s_3_3 s_3_4
        let s_3_7: Bits = (Bits::new(
            ((s_3_6) >> (s_3_3)).value(),
            u16::try_from(s_3_4).unwrap(),
        ));
        // D s_3_8: cast reint s_3_7 -> u8
        let s_3_8: u8 = (s_3_7.value() as u8);
        // C s_3_9: const #20s : i
        let s_3_9: i128 = 20;
        // C s_3_10: const #1s : i
        let s_3_10: i128 = 1;
        // D s_3_11: read-var __opcode:u32
        let s_3_11: u32 = fn_state.u__opcode;
        // D s_3_12: cast zx s_3_11 -> bv
        let s_3_12: Bits = Bits::new(s_3_11 as u128, 32u16);
        // D s_3_13: bit-extract s_3_12 s_3_9 s_3_10
        let s_3_13: Bits = (Bits::new(
            ((s_3_12) >> (s_3_9)).value(),
            u16::try_from(s_3_10).unwrap(),
        ));
        // D s_3_14: cast reint s_3_13 -> u8
        let s_3_14: bool = ((s_3_13.value()) != 0);
        // C s_3_15: const #16s : i
        let s_3_15: i128 = 16;
        // C s_3_16: const #4s : i
        let s_3_16: i128 = 4;
        // D s_3_17: read-var __opcode:u32
        let s_3_17: u32 = fn_state.u__opcode;
        // D s_3_18: cast zx s_3_17 -> bv
        let s_3_18: Bits = Bits::new(s_3_17 as u128, 32u16);
        // D s_3_19: bit-extract s_3_18 s_3_15 s_3_16
        let s_3_19: Bits = (Bits::new(
            ((s_3_18) >> (s_3_15)).value(),
            u16::try_from(s_3_16).unwrap(),
        ));
        // D s_3_20: cast reint s_3_19 -> u8
        let s_3_20: u8 = (s_3_19.value() as u8);
        // C s_3_21: const #12s : i
        let s_3_21: i128 = 12;
        // C s_3_22: const #4s : i
        let s_3_22: i128 = 4;
        // D s_3_23: read-var __opcode:u32
        let s_3_23: u32 = fn_state.u__opcode;
        // D s_3_24: cast zx s_3_23 -> bv
        let s_3_24: Bits = Bits::new(s_3_23 as u128, 32u16);
        // D s_3_25: bit-extract s_3_24 s_3_21 s_3_22
        let s_3_25: Bits = (Bits::new(
            ((s_3_24) >> (s_3_21)).value(),
            u16::try_from(s_3_22).unwrap(),
        ));
        // D s_3_26: cast reint s_3_25 -> u8
        let s_3_26: u8 = (s_3_25.value() as u8);
        // C s_3_27: const #0s : i
        let s_3_27: i128 = 0;
        // C s_3_28: const #12s : i
        let s_3_28: i128 = 12;
        // D s_3_29: read-var __opcode:u32
        let s_3_29: u32 = fn_state.u__opcode;
        // D s_3_30: cast zx s_3_29 -> bv
        let s_3_30: Bits = Bits::new(s_3_29 as u128, 32u16);
        // D s_3_31: bit-extract s_3_30 s_3_27 s_3_28
        let s_3_31: Bits = (Bits::new(
            ((s_3_30) >> (s_3_27)).value(),
            u16::try_from(s_3_28).unwrap(),
        ));
        // D s_3_32: cast reint s_3_31 -> u12
        let s_3_32: u16 = (s_3_31.value() as u16);
        // D s_3_33: call decode_aarch32_instrs_ADC_i_A1enc_A_txt(s_3_8, s_3_14, s_3_20, s_3_26, s_3_32)
        let s_3_33: () = decode_aarch32_instrs_ADC_i_A1enc_A_txt(
            state,
            tracer,
            s_3_8,
            s_3_14,
            s_3_20,
            s_3_26,
            s_3_32,
        );
        // N s_3_34: return
        return;
    }
    fn block_4<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_4_0: read-var merge#var.1:struct
        let s_4_0: u32 = fn_state.merge_var._1;
        // D s_4_1: write-var u#32325 <= s_4_0
        fn_state.u_32325 = s_4_0;
        // C s_4_2: const #21s : i
        let s_4_2: i128 = 21;
        // D s_4_3: read-var u#32325:u32
        let s_4_3: u32 = fn_state.u_32325;
        // D s_4_4: cast zx s_4_3 -> bv
        let s_4_4: Bits = Bits::new(s_4_3 as u128, 32u16);
        // C s_4_5: const #1s : i64
        let s_4_5: i64 = 1;
        // C s_4_6: cast zx s_4_5 -> i
        let s_4_6: i128 = (i128::try_from(s_4_5).unwrap());
        // C s_4_7: const #6s : i
        let s_4_7: i128 = 6;
        // C s_4_8: add s_4_7 s_4_6
        let s_4_8: i128 = (s_4_7 + s_4_6);
        // D s_4_9: bit-extract s_4_4 s_4_2 s_4_8
        let s_4_9: Bits = (Bits::new(
            ((s_4_4) >> (s_4_2)).value(),
            u16::try_from(s_4_8).unwrap(),
        ));
        // D s_4_10: cast reint s_4_9 -> u8
        let s_4_10: u8 = (s_4_9.value() as u8);
        // D s_4_11: cast zx s_4_10 -> bv
        let s_4_11: Bits = Bits::new(s_4_10 as u128, 7u16);
        // C s_4_12: const #5u : u8
        let s_4_12: u8 = 5;
        // C s_4_13: cast zx s_4_12 -> bv
        let s_4_13: Bits = Bits::new(s_4_12 as u128, 7u16);
        // D s_4_14: cmp-eq s_4_11 s_4_13
        let s_4_14: bool = ((s_4_11) == (s_4_13));
        // N s_4_15: branch s_4_14 b2995 b5
        if s_4_14 {
            return block_2995(state, tracer, fn_state);
        } else {
            return block_5(state, tracer, fn_state);
        };
    }
    fn block_5<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_5_0: const #0u : u8
        let s_5_0: bool = false;
        // D s_5_1: write-var gs#403891 <= s_5_0
        fn_state.gs_403891 = s_5_0;
        // N s_5_2: jump b6
        return block_6(state, tracer, fn_state);
    }
    fn block_6<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_6_0: read-var gs#403891:u8
        let s_6_0: bool = fn_state.gs_403891;
        // N s_6_1: branch s_6_0 b2991 b7
        if s_6_0 {
            return block_2991(state, tracer, fn_state);
        } else {
            return block_7(state, tracer, fn_state);
        };
    }
    fn block_7<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_7_0: const #0u : u8
        let s_7_0: bool = false;
        // D s_7_1: write-var gs#403896 <= s_7_0
        fn_state.gs_403896 = s_7_0;
        // N s_7_2: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_8<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_8_0: read-var gs#403896:u8
        let s_8_0: bool = fn_state.gs_403896;
        // D s_8_1: not s_8_0
        let s_8_1: bool = !s_8_0;
        // N s_8_2: branch s_8_1 b10 b9
        if s_8_1 {
            return block_10(state, tracer, fn_state);
        } else {
            return block_9(state, tracer, fn_state);
        };
    }
    fn block_9<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_9_0: const #2815s : i
        let s_9_0: i128 = 2815;
        // C s_9_1: const #14696u : u32
        let s_9_1: u32 = 14696;
        // N s_9_2: write-reg s_9_1 <= s_9_0
        let s_9_2: () = {
            state.write_register::<i128>(s_9_1 as isize, s_9_0);
            tracer.write_register(s_9_1 as isize, s_9_0);
        };
        // C s_9_3: const #28s : i
        let s_9_3: i128 = 28;
        // C s_9_4: const #4s : i
        let s_9_4: i128 = 4;
        // D s_9_5: read-var u#32325:u32
        let s_9_5: u32 = fn_state.u_32325;
        // D s_9_6: cast zx s_9_5 -> bv
        let s_9_6: Bits = Bits::new(s_9_5 as u128, 32u16);
        // D s_9_7: bit-extract s_9_6 s_9_3 s_9_4
        let s_9_7: Bits = (Bits::new(
            ((s_9_6) >> (s_9_3)).value(),
            u16::try_from(s_9_4).unwrap(),
        ));
        // D s_9_8: cast reint s_9_7 -> u8
        let s_9_8: u8 = (s_9_7.value() as u8);
        // C s_9_9: const #20s : i
        let s_9_9: i128 = 20;
        // C s_9_10: const #1s : i
        let s_9_10: i128 = 1;
        // D s_9_11: read-var u#32325:u32
        let s_9_11: u32 = fn_state.u_32325;
        // D s_9_12: cast zx s_9_11 -> bv
        let s_9_12: Bits = Bits::new(s_9_11 as u128, 32u16);
        // D s_9_13: bit-extract s_9_12 s_9_9 s_9_10
        let s_9_13: Bits = (Bits::new(
            ((s_9_12) >> (s_9_9)).value(),
            u16::try_from(s_9_10).unwrap(),
        ));
        // D s_9_14: cast reint s_9_13 -> u8
        let s_9_14: bool = ((s_9_13.value()) != 0);
        // C s_9_15: const #16s : i
        let s_9_15: i128 = 16;
        // C s_9_16: const #4s : i
        let s_9_16: i128 = 4;
        // D s_9_17: read-var u#32325:u32
        let s_9_17: u32 = fn_state.u_32325;
        // D s_9_18: cast zx s_9_17 -> bv
        let s_9_18: Bits = Bits::new(s_9_17 as u128, 32u16);
        // D s_9_19: bit-extract s_9_18 s_9_15 s_9_16
        let s_9_19: Bits = (Bits::new(
            ((s_9_18) >> (s_9_15)).value(),
            u16::try_from(s_9_16).unwrap(),
        ));
        // D s_9_20: cast reint s_9_19 -> u8
        let s_9_20: u8 = (s_9_19.value() as u8);
        // C s_9_21: const #12s : i
        let s_9_21: i128 = 12;
        // C s_9_22: const #4s : i
        let s_9_22: i128 = 4;
        // D s_9_23: read-var u#32325:u32
        let s_9_23: u32 = fn_state.u_32325;
        // D s_9_24: cast zx s_9_23 -> bv
        let s_9_24: Bits = Bits::new(s_9_23 as u128, 32u16);
        // D s_9_25: bit-extract s_9_24 s_9_21 s_9_22
        let s_9_25: Bits = (Bits::new(
            ((s_9_24) >> (s_9_21)).value(),
            u16::try_from(s_9_22).unwrap(),
        ));
        // D s_9_26: cast reint s_9_25 -> u8
        let s_9_26: u8 = (s_9_25.value() as u8);
        // C s_9_27: const #7s : i
        let s_9_27: i128 = 7;
        // C s_9_28: const #5s : i
        let s_9_28: i128 = 5;
        // D s_9_29: read-var u#32325:u32
        let s_9_29: u32 = fn_state.u_32325;
        // D s_9_30: cast zx s_9_29 -> bv
        let s_9_30: Bits = Bits::new(s_9_29 as u128, 32u16);
        // D s_9_31: bit-extract s_9_30 s_9_27 s_9_28
        let s_9_31: Bits = (Bits::new(
            ((s_9_30) >> (s_9_27)).value(),
            u16::try_from(s_9_28).unwrap(),
        ));
        // D s_9_32: cast reint s_9_31 -> u8
        let s_9_32: u8 = (s_9_31.value() as u8);
        // C s_9_33: const #5s : i
        let s_9_33: i128 = 5;
        // C s_9_34: const #2s : i
        let s_9_34: i128 = 2;
        // D s_9_35: read-var u#32325:u32
        let s_9_35: u32 = fn_state.u_32325;
        // D s_9_36: cast zx s_9_35 -> bv
        let s_9_36: Bits = Bits::new(s_9_35 as u128, 32u16);
        // D s_9_37: bit-extract s_9_36 s_9_33 s_9_34
        let s_9_37: Bits = (Bits::new(
            ((s_9_36) >> (s_9_33)).value(),
            u16::try_from(s_9_34).unwrap(),
        ));
        // D s_9_38: cast reint s_9_37 -> u8
        let s_9_38: u8 = (s_9_37.value() as u8);
        // C s_9_39: const #0s : i
        let s_9_39: i128 = 0;
        // C s_9_40: const #4s : i
        let s_9_40: i128 = 4;
        // D s_9_41: read-var u#32325:u32
        let s_9_41: u32 = fn_state.u_32325;
        // D s_9_42: cast zx s_9_41 -> bv
        let s_9_42: Bits = Bits::new(s_9_41 as u128, 32u16);
        // D s_9_43: bit-extract s_9_42 s_9_39 s_9_40
        let s_9_43: Bits = (Bits::new(
            ((s_9_42) >> (s_9_39)).value(),
            u16::try_from(s_9_40).unwrap(),
        ));
        // D s_9_44: cast reint s_9_43 -> u8
        let s_9_44: u8 = (s_9_43.value() as u8);
        // D s_9_45: call decode_aarch32_instrs_ADC_r_A1enc_A_txt(s_9_8, s_9_14, s_9_20, s_9_26, s_9_32, s_9_38, s_9_44)
        let s_9_45: () = decode_aarch32_instrs_ADC_r_A1enc_A_txt(
            state,
            tracer,
            s_9_8,
            s_9_14,
            s_9_20,
            s_9_26,
            s_9_32,
            s_9_38,
            s_9_44,
        );
        // N s_9_46: return
        return;
    }
    fn block_10<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_10_0: read-var merge#var.1:struct
        let s_10_0: u32 = fn_state.merge_var._1;
        // D s_10_1: write-var u#32331 <= s_10_0
        fn_state.u_32331 = s_10_0;
        // C s_10_2: const #21s : i
        let s_10_2: i128 = 21;
        // D s_10_3: read-var u#32331:u32
        let s_10_3: u32 = fn_state.u_32331;
        // D s_10_4: cast zx s_10_3 -> bv
        let s_10_4: Bits = Bits::new(s_10_3 as u128, 32u16);
        // C s_10_5: const #1s : i64
        let s_10_5: i64 = 1;
        // C s_10_6: cast zx s_10_5 -> i
        let s_10_6: i128 = (i128::try_from(s_10_5).unwrap());
        // C s_10_7: const #6s : i
        let s_10_7: i128 = 6;
        // C s_10_8: add s_10_7 s_10_6
        let s_10_8: i128 = (s_10_7 + s_10_6);
        // D s_10_9: bit-extract s_10_4 s_10_2 s_10_8
        let s_10_9: Bits = (Bits::new(
            ((s_10_4) >> (s_10_2)).value(),
            u16::try_from(s_10_8).unwrap(),
        ));
        // D s_10_10: cast reint s_10_9 -> u8
        let s_10_10: u8 = (s_10_9.value() as u8);
        // D s_10_11: cast zx s_10_10 -> bv
        let s_10_11: Bits = Bits::new(s_10_10 as u128, 7u16);
        // C s_10_12: const #5u : u8
        let s_10_12: u8 = 5;
        // C s_10_13: cast zx s_10_12 -> bv
        let s_10_13: Bits = Bits::new(s_10_12 as u128, 7u16);
        // D s_10_14: cmp-eq s_10_11 s_10_13
        let s_10_14: bool = ((s_10_11) == (s_10_13));
        // N s_10_15: branch s_10_14 b2987 b11
        if s_10_14 {
            return block_2987(state, tracer, fn_state);
        } else {
            return block_11(state, tracer, fn_state);
        };
    }
    fn block_11<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_11_0: const #0u : u8
        let s_11_0: bool = false;
        // D s_11_1: write-var gs#403921 <= s_11_0
        fn_state.gs_403921 = s_11_0;
        // N s_11_2: jump b12
        return block_12(state, tracer, fn_state);
    }
    fn block_12<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_12_0: read-var gs#403921:u8
        let s_12_0: bool = fn_state.gs_403921;
        // N s_12_1: branch s_12_0 b2983 b13
        if s_12_0 {
            return block_2983(state, tracer, fn_state);
        } else {
            return block_13(state, tracer, fn_state);
        };
    }
    fn block_13<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_13_0: const #0u : u8
        let s_13_0: bool = false;
        // D s_13_1: write-var gs#403926 <= s_13_0
        fn_state.gs_403926 = s_13_0;
        // N s_13_2: jump b14
        return block_14(state, tracer, fn_state);
    }
    fn block_14<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_14_0: read-var gs#403926:u8
        let s_14_0: bool = fn_state.gs_403926;
        // D s_14_1: not s_14_0
        let s_14_1: bool = !s_14_0;
        // N s_14_2: branch s_14_1 b16 b15
        if s_14_1 {
            return block_16(state, tracer, fn_state);
        } else {
            return block_15(state, tracer, fn_state);
        };
    }
    fn block_15<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_15_0: const #2818s : i
        let s_15_0: i128 = 2818;
        // C s_15_1: const #14696u : u32
        let s_15_1: u32 = 14696;
        // N s_15_2: write-reg s_15_1 <= s_15_0
        let s_15_2: () = {
            state.write_register::<i128>(s_15_1 as isize, s_15_0);
            tracer.write_register(s_15_1 as isize, s_15_0);
        };
        // C s_15_3: const #28s : i
        let s_15_3: i128 = 28;
        // C s_15_4: const #4s : i
        let s_15_4: i128 = 4;
        // D s_15_5: read-var u#32331:u32
        let s_15_5: u32 = fn_state.u_32331;
        // D s_15_6: cast zx s_15_5 -> bv
        let s_15_6: Bits = Bits::new(s_15_5 as u128, 32u16);
        // D s_15_7: bit-extract s_15_6 s_15_3 s_15_4
        let s_15_7: Bits = (Bits::new(
            ((s_15_6) >> (s_15_3)).value(),
            u16::try_from(s_15_4).unwrap(),
        ));
        // D s_15_8: cast reint s_15_7 -> u8
        let s_15_8: u8 = (s_15_7.value() as u8);
        // C s_15_9: const #20s : i
        let s_15_9: i128 = 20;
        // C s_15_10: const #1s : i
        let s_15_10: i128 = 1;
        // D s_15_11: read-var u#32331:u32
        let s_15_11: u32 = fn_state.u_32331;
        // D s_15_12: cast zx s_15_11 -> bv
        let s_15_12: Bits = Bits::new(s_15_11 as u128, 32u16);
        // D s_15_13: bit-extract s_15_12 s_15_9 s_15_10
        let s_15_13: Bits = (Bits::new(
            ((s_15_12) >> (s_15_9)).value(),
            u16::try_from(s_15_10).unwrap(),
        ));
        // D s_15_14: cast reint s_15_13 -> u8
        let s_15_14: bool = ((s_15_13.value()) != 0);
        // C s_15_15: const #16s : i
        let s_15_15: i128 = 16;
        // C s_15_16: const #4s : i
        let s_15_16: i128 = 4;
        // D s_15_17: read-var u#32331:u32
        let s_15_17: u32 = fn_state.u_32331;
        // D s_15_18: cast zx s_15_17 -> bv
        let s_15_18: Bits = Bits::new(s_15_17 as u128, 32u16);
        // D s_15_19: bit-extract s_15_18 s_15_15 s_15_16
        let s_15_19: Bits = (Bits::new(
            ((s_15_18) >> (s_15_15)).value(),
            u16::try_from(s_15_16).unwrap(),
        ));
        // D s_15_20: cast reint s_15_19 -> u8
        let s_15_20: u8 = (s_15_19.value() as u8);
        // C s_15_21: const #12s : i
        let s_15_21: i128 = 12;
        // C s_15_22: const #4s : i
        let s_15_22: i128 = 4;
        // D s_15_23: read-var u#32331:u32
        let s_15_23: u32 = fn_state.u_32331;
        // D s_15_24: cast zx s_15_23 -> bv
        let s_15_24: Bits = Bits::new(s_15_23 as u128, 32u16);
        // D s_15_25: bit-extract s_15_24 s_15_21 s_15_22
        let s_15_25: Bits = (Bits::new(
            ((s_15_24) >> (s_15_21)).value(),
            u16::try_from(s_15_22).unwrap(),
        ));
        // D s_15_26: cast reint s_15_25 -> u8
        let s_15_26: u8 = (s_15_25.value() as u8);
        // C s_15_27: const #8s : i
        let s_15_27: i128 = 8;
        // C s_15_28: const #4s : i
        let s_15_28: i128 = 4;
        // D s_15_29: read-var u#32331:u32
        let s_15_29: u32 = fn_state.u_32331;
        // D s_15_30: cast zx s_15_29 -> bv
        let s_15_30: Bits = Bits::new(s_15_29 as u128, 32u16);
        // D s_15_31: bit-extract s_15_30 s_15_27 s_15_28
        let s_15_31: Bits = (Bits::new(
            ((s_15_30) >> (s_15_27)).value(),
            u16::try_from(s_15_28).unwrap(),
        ));
        // D s_15_32: cast reint s_15_31 -> u8
        let s_15_32: u8 = (s_15_31.value() as u8);
        // C s_15_33: const #5s : i
        let s_15_33: i128 = 5;
        // C s_15_34: const #2s : i
        let s_15_34: i128 = 2;
        // D s_15_35: read-var u#32331:u32
        let s_15_35: u32 = fn_state.u_32331;
        // D s_15_36: cast zx s_15_35 -> bv
        let s_15_36: Bits = Bits::new(s_15_35 as u128, 32u16);
        // D s_15_37: bit-extract s_15_36 s_15_33 s_15_34
        let s_15_37: Bits = (Bits::new(
            ((s_15_36) >> (s_15_33)).value(),
            u16::try_from(s_15_34).unwrap(),
        ));
        // D s_15_38: cast reint s_15_37 -> u8
        let s_15_38: u8 = (s_15_37.value() as u8);
        // C s_15_39: const #0s : i
        let s_15_39: i128 = 0;
        // C s_15_40: const #4s : i
        let s_15_40: i128 = 4;
        // D s_15_41: read-var u#32331:u32
        let s_15_41: u32 = fn_state.u_32331;
        // D s_15_42: cast zx s_15_41 -> bv
        let s_15_42: Bits = Bits::new(s_15_41 as u128, 32u16);
        // D s_15_43: bit-extract s_15_42 s_15_39 s_15_40
        let s_15_43: Bits = (Bits::new(
            ((s_15_42) >> (s_15_39)).value(),
            u16::try_from(s_15_40).unwrap(),
        ));
        // D s_15_44: cast reint s_15_43 -> u8
        let s_15_44: u8 = (s_15_43.value() as u8);
        // D s_15_45: call decode_aarch32_instrs_ADC_rr_A1enc_A_txt(s_15_8, s_15_14, s_15_20, s_15_26, s_15_32, s_15_38, s_15_44)
        let s_15_45: () = decode_aarch32_instrs_ADC_rr_A1enc_A_txt(
            state,
            tracer,
            s_15_8,
            s_15_14,
            s_15_20,
            s_15_26,
            s_15_32,
            s_15_38,
            s_15_44,
        );
        // N s_15_46: return
        return;
    }
    fn block_16<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_16_0: read-var merge#var.1:struct
        let s_16_0: u32 = fn_state.merge_var._1;
        // D s_16_1: write-var u#32339 <= s_16_0
        fn_state.u_32339 = s_16_0;
        // C s_16_2: const #21s : i
        let s_16_2: i128 = 21;
        // D s_16_3: read-var u#32339:u32
        let s_16_3: u32 = fn_state.u_32339;
        // D s_16_4: cast zx s_16_3 -> bv
        let s_16_4: Bits = Bits::new(s_16_3 as u128, 32u16);
        // C s_16_5: const #1s : i64
        let s_16_5: i64 = 1;
        // C s_16_6: cast zx s_16_5 -> i
        let s_16_6: i128 = (i128::try_from(s_16_5).unwrap());
        // C s_16_7: const #6s : i
        let s_16_7: i128 = 6;
        // C s_16_8: add s_16_7 s_16_6
        let s_16_8: i128 = (s_16_7 + s_16_6);
        // D s_16_9: bit-extract s_16_4 s_16_2 s_16_8
        let s_16_9: Bits = (Bits::new(
            ((s_16_4) >> (s_16_2)).value(),
            u16::try_from(s_16_8).unwrap(),
        ));
        // D s_16_10: cast reint s_16_9 -> u8
        let s_16_10: u8 = (s_16_9.value() as u8);
        // D s_16_11: cast zx s_16_10 -> bv
        let s_16_11: Bits = Bits::new(s_16_10 as u128, 7u16);
        // C s_16_12: const #20u : u8
        let s_16_12: u8 = 20;
        // C s_16_13: cast zx s_16_12 -> bv
        let s_16_13: Bits = Bits::new(s_16_12 as u128, 7u16);
        // D s_16_14: cmp-eq s_16_11 s_16_13
        let s_16_14: bool = ((s_16_11) == (s_16_13));
        // N s_16_15: branch s_16_14 b2979 b17
        if s_16_14 {
            return block_2979(state, tracer, fn_state);
        } else {
            return block_17(state, tracer, fn_state);
        };
    }
    fn block_17<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_17_0: const #0u : u8
        let s_17_0: bool = false;
        // D s_17_1: write-var gs#403950 <= s_17_0
        fn_state.gs_403950 = s_17_0;
        // N s_17_2: jump b18
        return block_18(state, tracer, fn_state);
    }
    fn block_18<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_18_0: read-var gs#403950:u8
        let s_18_0: bool = fn_state.gs_403950;
        // D s_18_1: not s_18_0
        let s_18_1: bool = !s_18_0;
        // N s_18_2: branch s_18_1 b20 b19
        if s_18_1 {
            return block_20(state, tracer, fn_state);
        } else {
            return block_19(state, tracer, fn_state);
        };
    }
    fn block_19<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_19_0: const #2819s : i
        let s_19_0: i128 = 2819;
        // C s_19_1: const #14696u : u32
        let s_19_1: u32 = 14696;
        // N s_19_2: write-reg s_19_1 <= s_19_0
        let s_19_2: () = {
            state.write_register::<i128>(s_19_1 as isize, s_19_0);
            tracer.write_register(s_19_1 as isize, s_19_0);
        };
        // C s_19_3: const #28s : i
        let s_19_3: i128 = 28;
        // C s_19_4: const #4s : i
        let s_19_4: i128 = 4;
        // D s_19_5: read-var u#32339:u32
        let s_19_5: u32 = fn_state.u_32339;
        // D s_19_6: cast zx s_19_5 -> bv
        let s_19_6: Bits = Bits::new(s_19_5 as u128, 32u16);
        // D s_19_7: bit-extract s_19_6 s_19_3 s_19_4
        let s_19_7: Bits = (Bits::new(
            ((s_19_6) >> (s_19_3)).value(),
            u16::try_from(s_19_4).unwrap(),
        ));
        // D s_19_8: cast reint s_19_7 -> u8
        let s_19_8: u8 = (s_19_7.value() as u8);
        // C s_19_9: const #20s : i
        let s_19_9: i128 = 20;
        // C s_19_10: const #1s : i
        let s_19_10: i128 = 1;
        // D s_19_11: read-var u#32339:u32
        let s_19_11: u32 = fn_state.u_32339;
        // D s_19_12: cast zx s_19_11 -> bv
        let s_19_12: Bits = Bits::new(s_19_11 as u128, 32u16);
        // D s_19_13: bit-extract s_19_12 s_19_9 s_19_10
        let s_19_13: Bits = (Bits::new(
            ((s_19_12) >> (s_19_9)).value(),
            u16::try_from(s_19_10).unwrap(),
        ));
        // D s_19_14: cast reint s_19_13 -> u8
        let s_19_14: bool = ((s_19_13.value()) != 0);
        // C s_19_15: const #16s : i
        let s_19_15: i128 = 16;
        // C s_19_16: const #4s : i
        let s_19_16: i128 = 4;
        // D s_19_17: read-var u#32339:u32
        let s_19_17: u32 = fn_state.u_32339;
        // D s_19_18: cast zx s_19_17 -> bv
        let s_19_18: Bits = Bits::new(s_19_17 as u128, 32u16);
        // D s_19_19: bit-extract s_19_18 s_19_15 s_19_16
        let s_19_19: Bits = (Bits::new(
            ((s_19_18) >> (s_19_15)).value(),
            u16::try_from(s_19_16).unwrap(),
        ));
        // D s_19_20: cast reint s_19_19 -> u8
        let s_19_20: u8 = (s_19_19.value() as u8);
        // C s_19_21: const #12s : i
        let s_19_21: i128 = 12;
        // C s_19_22: const #4s : i
        let s_19_22: i128 = 4;
        // D s_19_23: read-var u#32339:u32
        let s_19_23: u32 = fn_state.u_32339;
        // D s_19_24: cast zx s_19_23 -> bv
        let s_19_24: Bits = Bits::new(s_19_23 as u128, 32u16);
        // D s_19_25: bit-extract s_19_24 s_19_21 s_19_22
        let s_19_25: Bits = (Bits::new(
            ((s_19_24) >> (s_19_21)).value(),
            u16::try_from(s_19_22).unwrap(),
        ));
        // D s_19_26: cast reint s_19_25 -> u8
        let s_19_26: u8 = (s_19_25.value() as u8);
        // C s_19_27: const #0s : i
        let s_19_27: i128 = 0;
        // C s_19_28: const #12s : i
        let s_19_28: i128 = 12;
        // D s_19_29: read-var u#32339:u32
        let s_19_29: u32 = fn_state.u_32339;
        // D s_19_30: cast zx s_19_29 -> bv
        let s_19_30: Bits = Bits::new(s_19_29 as u128, 32u16);
        // D s_19_31: bit-extract s_19_30 s_19_27 s_19_28
        let s_19_31: Bits = (Bits::new(
            ((s_19_30) >> (s_19_27)).value(),
            u16::try_from(s_19_28).unwrap(),
        ));
        // D s_19_32: cast reint s_19_31 -> u12
        let s_19_32: u16 = (s_19_31.value() as u16);
        // D s_19_33: call decode_aarch32_instrs_ADD_i_A1enc_A_txt(s_19_8, s_19_14, s_19_20, s_19_26, s_19_32)
        let s_19_33: () = decode_aarch32_instrs_ADD_i_A1enc_A_txt(
            state,
            tracer,
            s_19_8,
            s_19_14,
            s_19_20,
            s_19_26,
            s_19_32,
        );
        // N s_19_34: return
        return;
    }
    fn block_20<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_20_0: read-var merge#var.1:struct
        let s_20_0: u32 = fn_state.merge_var._1;
        // D s_20_1: write-var u#32346 <= s_20_0
        fn_state.u_32346 = s_20_0;
        // C s_20_2: const #21s : i
        let s_20_2: i128 = 21;
        // D s_20_3: read-var u#32346:u32
        let s_20_3: u32 = fn_state.u_32346;
        // D s_20_4: cast zx s_20_3 -> bv
        let s_20_4: Bits = Bits::new(s_20_3 as u128, 32u16);
        // C s_20_5: const #1s : i64
        let s_20_5: i64 = 1;
        // C s_20_6: cast zx s_20_5 -> i
        let s_20_6: i128 = (i128::try_from(s_20_5).unwrap());
        // C s_20_7: const #6s : i
        let s_20_7: i128 = 6;
        // C s_20_8: add s_20_7 s_20_6
        let s_20_8: i128 = (s_20_7 + s_20_6);
        // D s_20_9: bit-extract s_20_4 s_20_2 s_20_8
        let s_20_9: Bits = (Bits::new(
            ((s_20_4) >> (s_20_2)).value(),
            u16::try_from(s_20_8).unwrap(),
        ));
        // D s_20_10: cast reint s_20_9 -> u8
        let s_20_10: u8 = (s_20_9.value() as u8);
        // D s_20_11: cast zx s_20_10 -> bv
        let s_20_11: Bits = Bits::new(s_20_10 as u128, 7u16);
        // C s_20_12: const #4u : u8
        let s_20_12: u8 = 4;
        // C s_20_13: cast zx s_20_12 -> bv
        let s_20_13: Bits = Bits::new(s_20_12 as u128, 7u16);
        // D s_20_14: cmp-eq s_20_11 s_20_13
        let s_20_14: bool = ((s_20_11) == (s_20_13));
        // N s_20_15: branch s_20_14 b2978 b21
        if s_20_14 {
            return block_2978(state, tracer, fn_state);
        } else {
            return block_21(state, tracer, fn_state);
        };
    }
    fn block_21<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_21_0: const #0u : u8
        let s_21_0: bool = false;
        // D s_21_1: write-var gs#403968 <= s_21_0
        fn_state.gs_403968 = s_21_0;
        // N s_21_2: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_22<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_22_0: read-var gs#403968:u8
        let s_22_0: bool = fn_state.gs_403968;
        // N s_22_1: branch s_22_0 b2974 b23
        if s_22_0 {
            return block_2974(state, tracer, fn_state);
        } else {
            return block_23(state, tracer, fn_state);
        };
    }
    fn block_23<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_23_0: const #0u : u8
        let s_23_0: bool = false;
        // D s_23_1: write-var gs#403973 <= s_23_0
        fn_state.gs_403973 = s_23_0;
        // N s_23_2: jump b24
        return block_24(state, tracer, fn_state);
    }
    fn block_24<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_24_0: read-var gs#403973:u8
        let s_24_0: bool = fn_state.gs_403973;
        // D s_24_1: not s_24_0
        let s_24_1: bool = !s_24_0;
        // N s_24_2: branch s_24_1 b26 b25
        if s_24_1 {
            return block_26(state, tracer, fn_state);
        } else {
            return block_25(state, tracer, fn_state);
        };
    }
    fn block_25<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_25_0: const #2824s : i
        let s_25_0: i128 = 2824;
        // C s_25_1: const #14696u : u32
        let s_25_1: u32 = 14696;
        // N s_25_2: write-reg s_25_1 <= s_25_0
        let s_25_2: () = {
            state.write_register::<i128>(s_25_1 as isize, s_25_0);
            tracer.write_register(s_25_1 as isize, s_25_0);
        };
        // C s_25_3: const #28s : i
        let s_25_3: i128 = 28;
        // C s_25_4: const #4s : i
        let s_25_4: i128 = 4;
        // D s_25_5: read-var u#32346:u32
        let s_25_5: u32 = fn_state.u_32346;
        // D s_25_6: cast zx s_25_5 -> bv
        let s_25_6: Bits = Bits::new(s_25_5 as u128, 32u16);
        // D s_25_7: bit-extract s_25_6 s_25_3 s_25_4
        let s_25_7: Bits = (Bits::new(
            ((s_25_6) >> (s_25_3)).value(),
            u16::try_from(s_25_4).unwrap(),
        ));
        // D s_25_8: cast reint s_25_7 -> u8
        let s_25_8: u8 = (s_25_7.value() as u8);
        // C s_25_9: const #20s : i
        let s_25_9: i128 = 20;
        // C s_25_10: const #1s : i
        let s_25_10: i128 = 1;
        // D s_25_11: read-var u#32346:u32
        let s_25_11: u32 = fn_state.u_32346;
        // D s_25_12: cast zx s_25_11 -> bv
        let s_25_12: Bits = Bits::new(s_25_11 as u128, 32u16);
        // D s_25_13: bit-extract s_25_12 s_25_9 s_25_10
        let s_25_13: Bits = (Bits::new(
            ((s_25_12) >> (s_25_9)).value(),
            u16::try_from(s_25_10).unwrap(),
        ));
        // D s_25_14: cast reint s_25_13 -> u8
        let s_25_14: bool = ((s_25_13.value()) != 0);
        // C s_25_15: const #16s : i
        let s_25_15: i128 = 16;
        // C s_25_16: const #4s : i
        let s_25_16: i128 = 4;
        // D s_25_17: read-var u#32346:u32
        let s_25_17: u32 = fn_state.u_32346;
        // D s_25_18: cast zx s_25_17 -> bv
        let s_25_18: Bits = Bits::new(s_25_17 as u128, 32u16);
        // D s_25_19: bit-extract s_25_18 s_25_15 s_25_16
        let s_25_19: Bits = (Bits::new(
            ((s_25_18) >> (s_25_15)).value(),
            u16::try_from(s_25_16).unwrap(),
        ));
        // D s_25_20: cast reint s_25_19 -> u8
        let s_25_20: u8 = (s_25_19.value() as u8);
        // C s_25_21: const #12s : i
        let s_25_21: i128 = 12;
        // C s_25_22: const #4s : i
        let s_25_22: i128 = 4;
        // D s_25_23: read-var u#32346:u32
        let s_25_23: u32 = fn_state.u_32346;
        // D s_25_24: cast zx s_25_23 -> bv
        let s_25_24: Bits = Bits::new(s_25_23 as u128, 32u16);
        // D s_25_25: bit-extract s_25_24 s_25_21 s_25_22
        let s_25_25: Bits = (Bits::new(
            ((s_25_24) >> (s_25_21)).value(),
            u16::try_from(s_25_22).unwrap(),
        ));
        // D s_25_26: cast reint s_25_25 -> u8
        let s_25_26: u8 = (s_25_25.value() as u8);
        // C s_25_27: const #7s : i
        let s_25_27: i128 = 7;
        // C s_25_28: const #5s : i
        let s_25_28: i128 = 5;
        // D s_25_29: read-var u#32346:u32
        let s_25_29: u32 = fn_state.u_32346;
        // D s_25_30: cast zx s_25_29 -> bv
        let s_25_30: Bits = Bits::new(s_25_29 as u128, 32u16);
        // D s_25_31: bit-extract s_25_30 s_25_27 s_25_28
        let s_25_31: Bits = (Bits::new(
            ((s_25_30) >> (s_25_27)).value(),
            u16::try_from(s_25_28).unwrap(),
        ));
        // D s_25_32: cast reint s_25_31 -> u8
        let s_25_32: u8 = (s_25_31.value() as u8);
        // C s_25_33: const #5s : i
        let s_25_33: i128 = 5;
        // C s_25_34: const #2s : i
        let s_25_34: i128 = 2;
        // D s_25_35: read-var u#32346:u32
        let s_25_35: u32 = fn_state.u_32346;
        // D s_25_36: cast zx s_25_35 -> bv
        let s_25_36: Bits = Bits::new(s_25_35 as u128, 32u16);
        // D s_25_37: bit-extract s_25_36 s_25_33 s_25_34
        let s_25_37: Bits = (Bits::new(
            ((s_25_36) >> (s_25_33)).value(),
            u16::try_from(s_25_34).unwrap(),
        ));
        // D s_25_38: cast reint s_25_37 -> u8
        let s_25_38: u8 = (s_25_37.value() as u8);
        // C s_25_39: const #0s : i
        let s_25_39: i128 = 0;
        // C s_25_40: const #4s : i
        let s_25_40: i128 = 4;
        // D s_25_41: read-var u#32346:u32
        let s_25_41: u32 = fn_state.u_32346;
        // D s_25_42: cast zx s_25_41 -> bv
        let s_25_42: Bits = Bits::new(s_25_41 as u128, 32u16);
        // D s_25_43: bit-extract s_25_42 s_25_39 s_25_40
        let s_25_43: Bits = (Bits::new(
            ((s_25_42) >> (s_25_39)).value(),
            u16::try_from(s_25_40).unwrap(),
        ));
        // D s_25_44: cast reint s_25_43 -> u8
        let s_25_44: u8 = (s_25_43.value() as u8);
        // D s_25_45: call decode_aarch32_instrs_ADD_r_A1enc_A_txt(s_25_8, s_25_14, s_25_20, s_25_26, s_25_32, s_25_38, s_25_44)
        let s_25_45: () = decode_aarch32_instrs_ADD_r_A1enc_A_txt(
            state,
            tracer,
            s_25_8,
            s_25_14,
            s_25_20,
            s_25_26,
            s_25_32,
            s_25_38,
            s_25_44,
        );
        // N s_25_46: return
        return;
    }
    fn block_26<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_26_0: read-var merge#var.1:struct
        let s_26_0: u32 = fn_state.merge_var._1;
        // D s_26_1: write-var u#32355 <= s_26_0
        fn_state.u_32355 = s_26_0;
        // C s_26_2: const #21s : i
        let s_26_2: i128 = 21;
        // D s_26_3: read-var u#32355:u32
        let s_26_3: u32 = fn_state.u_32355;
        // D s_26_4: cast zx s_26_3 -> bv
        let s_26_4: Bits = Bits::new(s_26_3 as u128, 32u16);
        // C s_26_5: const #1s : i64
        let s_26_5: i64 = 1;
        // C s_26_6: cast zx s_26_5 -> i
        let s_26_6: i128 = (i128::try_from(s_26_5).unwrap());
        // C s_26_7: const #6s : i
        let s_26_7: i128 = 6;
        // C s_26_8: add s_26_7 s_26_6
        let s_26_8: i128 = (s_26_7 + s_26_6);
        // D s_26_9: bit-extract s_26_4 s_26_2 s_26_8
        let s_26_9: Bits = (Bits::new(
            ((s_26_4) >> (s_26_2)).value(),
            u16::try_from(s_26_8).unwrap(),
        ));
        // D s_26_10: cast reint s_26_9 -> u8
        let s_26_10: u8 = (s_26_9.value() as u8);
        // D s_26_11: cast zx s_26_10 -> bv
        let s_26_11: Bits = Bits::new(s_26_10 as u128, 7u16);
        // C s_26_12: const #4u : u8
        let s_26_12: u8 = 4;
        // C s_26_13: cast zx s_26_12 -> bv
        let s_26_13: Bits = Bits::new(s_26_12 as u128, 7u16);
        // D s_26_14: cmp-eq s_26_11 s_26_13
        let s_26_14: bool = ((s_26_11) == (s_26_13));
        // N s_26_15: branch s_26_14 b2970 b27
        if s_26_14 {
            return block_2970(state, tracer, fn_state);
        } else {
            return block_27(state, tracer, fn_state);
        };
    }
    fn block_27<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_27_0: const #0u : u8
        let s_27_0: bool = false;
        // D s_27_1: write-var gs#403998 <= s_27_0
        fn_state.gs_403998 = s_27_0;
        // N s_27_2: jump b28
        return block_28(state, tracer, fn_state);
    }
    fn block_28<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_28_0: read-var gs#403998:u8
        let s_28_0: bool = fn_state.gs_403998;
        // N s_28_1: branch s_28_0 b2966 b29
        if s_28_0 {
            return block_2966(state, tracer, fn_state);
        } else {
            return block_29(state, tracer, fn_state);
        };
    }
    fn block_29<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_29_0: const #0u : u8
        let s_29_0: bool = false;
        // D s_29_1: write-var gs#404003 <= s_29_0
        fn_state.gs_404003 = s_29_0;
        // N s_29_2: jump b30
        return block_30(state, tracer, fn_state);
    }
    fn block_30<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_30_0: read-var gs#404003:u8
        let s_30_0: bool = fn_state.gs_404003;
        // D s_30_1: not s_30_0
        let s_30_1: bool = !s_30_0;
        // N s_30_2: branch s_30_1 b32 b31
        if s_30_1 {
            return block_32(state, tracer, fn_state);
        } else {
            return block_31(state, tracer, fn_state);
        };
    }
    fn block_31<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_31_0: const #2828s : i
        let s_31_0: i128 = 2828;
        // C s_31_1: const #14696u : u32
        let s_31_1: u32 = 14696;
        // N s_31_2: write-reg s_31_1 <= s_31_0
        let s_31_2: () = {
            state.write_register::<i128>(s_31_1 as isize, s_31_0);
            tracer.write_register(s_31_1 as isize, s_31_0);
        };
        // C s_31_3: const #28s : i
        let s_31_3: i128 = 28;
        // C s_31_4: const #4s : i
        let s_31_4: i128 = 4;
        // D s_31_5: read-var u#32355:u32
        let s_31_5: u32 = fn_state.u_32355;
        // D s_31_6: cast zx s_31_5 -> bv
        let s_31_6: Bits = Bits::new(s_31_5 as u128, 32u16);
        // D s_31_7: bit-extract s_31_6 s_31_3 s_31_4
        let s_31_7: Bits = (Bits::new(
            ((s_31_6) >> (s_31_3)).value(),
            u16::try_from(s_31_4).unwrap(),
        ));
        // D s_31_8: cast reint s_31_7 -> u8
        let s_31_8: u8 = (s_31_7.value() as u8);
        // C s_31_9: const #20s : i
        let s_31_9: i128 = 20;
        // C s_31_10: const #1s : i
        let s_31_10: i128 = 1;
        // D s_31_11: read-var u#32355:u32
        let s_31_11: u32 = fn_state.u_32355;
        // D s_31_12: cast zx s_31_11 -> bv
        let s_31_12: Bits = Bits::new(s_31_11 as u128, 32u16);
        // D s_31_13: bit-extract s_31_12 s_31_9 s_31_10
        let s_31_13: Bits = (Bits::new(
            ((s_31_12) >> (s_31_9)).value(),
            u16::try_from(s_31_10).unwrap(),
        ));
        // D s_31_14: cast reint s_31_13 -> u8
        let s_31_14: bool = ((s_31_13.value()) != 0);
        // C s_31_15: const #16s : i
        let s_31_15: i128 = 16;
        // C s_31_16: const #4s : i
        let s_31_16: i128 = 4;
        // D s_31_17: read-var u#32355:u32
        let s_31_17: u32 = fn_state.u_32355;
        // D s_31_18: cast zx s_31_17 -> bv
        let s_31_18: Bits = Bits::new(s_31_17 as u128, 32u16);
        // D s_31_19: bit-extract s_31_18 s_31_15 s_31_16
        let s_31_19: Bits = (Bits::new(
            ((s_31_18) >> (s_31_15)).value(),
            u16::try_from(s_31_16).unwrap(),
        ));
        // D s_31_20: cast reint s_31_19 -> u8
        let s_31_20: u8 = (s_31_19.value() as u8);
        // C s_31_21: const #12s : i
        let s_31_21: i128 = 12;
        // C s_31_22: const #4s : i
        let s_31_22: i128 = 4;
        // D s_31_23: read-var u#32355:u32
        let s_31_23: u32 = fn_state.u_32355;
        // D s_31_24: cast zx s_31_23 -> bv
        let s_31_24: Bits = Bits::new(s_31_23 as u128, 32u16);
        // D s_31_25: bit-extract s_31_24 s_31_21 s_31_22
        let s_31_25: Bits = (Bits::new(
            ((s_31_24) >> (s_31_21)).value(),
            u16::try_from(s_31_22).unwrap(),
        ));
        // D s_31_26: cast reint s_31_25 -> u8
        let s_31_26: u8 = (s_31_25.value() as u8);
        // C s_31_27: const #8s : i
        let s_31_27: i128 = 8;
        // C s_31_28: const #4s : i
        let s_31_28: i128 = 4;
        // D s_31_29: read-var u#32355:u32
        let s_31_29: u32 = fn_state.u_32355;
        // D s_31_30: cast zx s_31_29 -> bv
        let s_31_30: Bits = Bits::new(s_31_29 as u128, 32u16);
        // D s_31_31: bit-extract s_31_30 s_31_27 s_31_28
        let s_31_31: Bits = (Bits::new(
            ((s_31_30) >> (s_31_27)).value(),
            u16::try_from(s_31_28).unwrap(),
        ));
        // D s_31_32: cast reint s_31_31 -> u8
        let s_31_32: u8 = (s_31_31.value() as u8);
        // C s_31_33: const #5s : i
        let s_31_33: i128 = 5;
        // C s_31_34: const #2s : i
        let s_31_34: i128 = 2;
        // D s_31_35: read-var u#32355:u32
        let s_31_35: u32 = fn_state.u_32355;
        // D s_31_36: cast zx s_31_35 -> bv
        let s_31_36: Bits = Bits::new(s_31_35 as u128, 32u16);
        // D s_31_37: bit-extract s_31_36 s_31_33 s_31_34
        let s_31_37: Bits = (Bits::new(
            ((s_31_36) >> (s_31_33)).value(),
            u16::try_from(s_31_34).unwrap(),
        ));
        // D s_31_38: cast reint s_31_37 -> u8
        let s_31_38: u8 = (s_31_37.value() as u8);
        // C s_31_39: const #0s : i
        let s_31_39: i128 = 0;
        // C s_31_40: const #4s : i
        let s_31_40: i128 = 4;
        // D s_31_41: read-var u#32355:u32
        let s_31_41: u32 = fn_state.u_32355;
        // D s_31_42: cast zx s_31_41 -> bv
        let s_31_42: Bits = Bits::new(s_31_41 as u128, 32u16);
        // D s_31_43: bit-extract s_31_42 s_31_39 s_31_40
        let s_31_43: Bits = (Bits::new(
            ((s_31_42) >> (s_31_39)).value(),
            u16::try_from(s_31_40).unwrap(),
        ));
        // D s_31_44: cast reint s_31_43 -> u8
        let s_31_44: u8 = (s_31_43.value() as u8);
        // D s_31_45: call decode_aarch32_instrs_ADD_rr_A1enc_A_txt(s_31_8, s_31_14, s_31_20, s_31_26, s_31_32, s_31_38, s_31_44)
        let s_31_45: () = decode_aarch32_instrs_ADD_rr_A1enc_A_txt(
            state,
            tracer,
            s_31_8,
            s_31_14,
            s_31_20,
            s_31_26,
            s_31_32,
            s_31_38,
            s_31_44,
        );
        // N s_31_46: return
        return;
    }
    fn block_32<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_32_0: read-var merge#var.1:struct
        let s_32_0: u32 = fn_state.merge_var._1;
        // D s_32_1: write-var u#32364 <= s_32_0
        fn_state.u_32364 = s_32_0;
        // C s_32_2: const #21s : i
        let s_32_2: i128 = 21;
        // D s_32_3: read-var u#32364:u32
        let s_32_3: u32 = fn_state.u_32364;
        // D s_32_4: cast zx s_32_3 -> bv
        let s_32_4: Bits = Bits::new(s_32_3 as u128, 32u16);
        // C s_32_5: const #1s : i64
        let s_32_5: i64 = 1;
        // C s_32_6: cast zx s_32_5 -> i
        let s_32_6: i128 = (i128::try_from(s_32_5).unwrap());
        // C s_32_7: const #6s : i
        let s_32_7: i128 = 6;
        // C s_32_8: add s_32_7 s_32_6
        let s_32_8: i128 = (s_32_7 + s_32_6);
        // D s_32_9: bit-extract s_32_4 s_32_2 s_32_8
        let s_32_9: Bits = (Bits::new(
            ((s_32_4) >> (s_32_2)).value(),
            u16::try_from(s_32_8).unwrap(),
        ));
        // D s_32_10: cast reint s_32_9 -> u8
        let s_32_10: u8 = (s_32_9.value() as u8);
        // D s_32_11: cast zx s_32_10 -> bv
        let s_32_11: Bits = Bits::new(s_32_10 as u128, 7u16);
        // C s_32_12: const #20u : u8
        let s_32_12: u8 = 20;
        // C s_32_13: cast zx s_32_12 -> bv
        let s_32_13: Bits = Bits::new(s_32_12 as u128, 7u16);
        // D s_32_14: cmp-eq s_32_11 s_32_13
        let s_32_14: bool = ((s_32_11) == (s_32_13));
        // N s_32_15: branch s_32_14 b2965 b33
        if s_32_14 {
            return block_2965(state, tracer, fn_state);
        } else {
            return block_33(state, tracer, fn_state);
        };
    }
    fn block_33<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_33_0: const #0u : u8
        let s_33_0: bool = false;
        // D s_33_1: write-var gs#404025 <= s_33_0
        fn_state.gs_404025 = s_33_0;
        // N s_33_2: jump b34
        return block_34(state, tracer, fn_state);
    }
    fn block_34<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_34_0: read-var gs#404025:u8
        let s_34_0: bool = fn_state.gs_404025;
        // N s_34_1: branch s_34_0 b2961 b35
        if s_34_0 {
            return block_2961(state, tracer, fn_state);
        } else {
            return block_35(state, tracer, fn_state);
        };
    }
    fn block_35<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_35_0: const #0u : u8
        let s_35_0: bool = false;
        // D s_35_1: write-var gs#404030 <= s_35_0
        fn_state.gs_404030 = s_35_0;
        // N s_35_2: jump b36
        return block_36(state, tracer, fn_state);
    }
    fn block_36<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_36_0: read-var gs#404030:u8
        let s_36_0: bool = fn_state.gs_404030;
        // D s_36_1: not s_36_0
        let s_36_1: bool = !s_36_0;
        // N s_36_2: branch s_36_1 b38 b37
        if s_36_1 {
            return block_38(state, tracer, fn_state);
        } else {
            return block_37(state, tracer, fn_state);
        };
    }
    fn block_37<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_37_0: const #2829s : i
        let s_37_0: i128 = 2829;
        // C s_37_1: const #14696u : u32
        let s_37_1: u32 = 14696;
        // N s_37_2: write-reg s_37_1 <= s_37_0
        let s_37_2: () = {
            state.write_register::<i128>(s_37_1 as isize, s_37_0);
            tracer.write_register(s_37_1 as isize, s_37_0);
        };
        // C s_37_3: const #28s : i
        let s_37_3: i128 = 28;
        // C s_37_4: const #4s : i
        let s_37_4: i128 = 4;
        // D s_37_5: read-var u#32364:u32
        let s_37_5: u32 = fn_state.u_32364;
        // D s_37_6: cast zx s_37_5 -> bv
        let s_37_6: Bits = Bits::new(s_37_5 as u128, 32u16);
        // D s_37_7: bit-extract s_37_6 s_37_3 s_37_4
        let s_37_7: Bits = (Bits::new(
            ((s_37_6) >> (s_37_3)).value(),
            u16::try_from(s_37_4).unwrap(),
        ));
        // D s_37_8: cast reint s_37_7 -> u8
        let s_37_8: u8 = (s_37_7.value() as u8);
        // C s_37_9: const #20s : i
        let s_37_9: i128 = 20;
        // C s_37_10: const #1s : i
        let s_37_10: i128 = 1;
        // D s_37_11: read-var u#32364:u32
        let s_37_11: u32 = fn_state.u_32364;
        // D s_37_12: cast zx s_37_11 -> bv
        let s_37_12: Bits = Bits::new(s_37_11 as u128, 32u16);
        // D s_37_13: bit-extract s_37_12 s_37_9 s_37_10
        let s_37_13: Bits = (Bits::new(
            ((s_37_12) >> (s_37_9)).value(),
            u16::try_from(s_37_10).unwrap(),
        ));
        // D s_37_14: cast reint s_37_13 -> u8
        let s_37_14: bool = ((s_37_13.value()) != 0);
        // C s_37_15: const #12s : i
        let s_37_15: i128 = 12;
        // C s_37_16: const #4s : i
        let s_37_16: i128 = 4;
        // D s_37_17: read-var u#32364:u32
        let s_37_17: u32 = fn_state.u_32364;
        // D s_37_18: cast zx s_37_17 -> bv
        let s_37_18: Bits = Bits::new(s_37_17 as u128, 32u16);
        // D s_37_19: bit-extract s_37_18 s_37_15 s_37_16
        let s_37_19: Bits = (Bits::new(
            ((s_37_18) >> (s_37_15)).value(),
            u16::try_from(s_37_16).unwrap(),
        ));
        // D s_37_20: cast reint s_37_19 -> u8
        let s_37_20: u8 = (s_37_19.value() as u8);
        // C s_37_21: const #0s : i
        let s_37_21: i128 = 0;
        // C s_37_22: const #12s : i
        let s_37_22: i128 = 12;
        // D s_37_23: read-var u#32364:u32
        let s_37_23: u32 = fn_state.u_32364;
        // D s_37_24: cast zx s_37_23 -> bv
        let s_37_24: Bits = Bits::new(s_37_23 as u128, 32u16);
        // D s_37_25: bit-extract s_37_24 s_37_21 s_37_22
        let s_37_25: Bits = (Bits::new(
            ((s_37_24) >> (s_37_21)).value(),
            u16::try_from(s_37_22).unwrap(),
        ));
        // D s_37_26: cast reint s_37_25 -> u12
        let s_37_26: u16 = (s_37_25.value() as u16);
        // D s_37_27: call decode_aarch32_instrs_ADD_SP_i_A1enc_A_txt(s_37_8, s_37_14, s_37_20, s_37_26)
        let s_37_27: () = decode_aarch32_instrs_ADD_SP_i_A1enc_A_txt(
            state,
            tracer,
            s_37_8,
            s_37_14,
            s_37_20,
            s_37_26,
        );
        // N s_37_28: return
        return;
    }
    fn block_38<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_38_0: read-var merge#var.1:struct
        let s_38_0: u32 = fn_state.merge_var._1;
        // D s_38_1: write-var u#32370 <= s_38_0
        fn_state.u_32370 = s_38_0;
        // C s_38_2: const #21s : i
        let s_38_2: i128 = 21;
        // D s_38_3: read-var u#32370:u32
        let s_38_3: u32 = fn_state.u_32370;
        // D s_38_4: cast zx s_38_3 -> bv
        let s_38_4: Bits = Bits::new(s_38_3 as u128, 32u16);
        // C s_38_5: const #1s : i64
        let s_38_5: i64 = 1;
        // C s_38_6: cast zx s_38_5 -> i
        let s_38_6: i128 = (i128::try_from(s_38_5).unwrap());
        // C s_38_7: const #6s : i
        let s_38_7: i128 = 6;
        // C s_38_8: add s_38_7 s_38_6
        let s_38_8: i128 = (s_38_7 + s_38_6);
        // D s_38_9: bit-extract s_38_4 s_38_2 s_38_8
        let s_38_9: Bits = (Bits::new(
            ((s_38_4) >> (s_38_2)).value(),
            u16::try_from(s_38_8).unwrap(),
        ));
        // D s_38_10: cast reint s_38_9 -> u8
        let s_38_10: u8 = (s_38_9.value() as u8);
        // D s_38_11: cast zx s_38_10 -> bv
        let s_38_11: Bits = Bits::new(s_38_10 as u128, 7u16);
        // C s_38_12: const #4u : u8
        let s_38_12: u8 = 4;
        // C s_38_13: cast zx s_38_12 -> bv
        let s_38_13: Bits = Bits::new(s_38_12 as u128, 7u16);
        // D s_38_14: cmp-eq s_38_11 s_38_13
        let s_38_14: bool = ((s_38_11) == (s_38_13));
        // N s_38_15: branch s_38_14 b2957 b39
        if s_38_14 {
            return block_2957(state, tracer, fn_state);
        } else {
            return block_39(state, tracer, fn_state);
        };
    }
    fn block_39<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_39_0: const #0u : u8
        let s_39_0: bool = false;
        // D s_39_1: write-var gs#404049 <= s_39_0
        fn_state.gs_404049 = s_39_0;
        // N s_39_2: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_40<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_40_0: read-var gs#404049:u8
        let s_40_0: bool = fn_state.gs_404049;
        // N s_40_1: branch s_40_0 b2953 b41
        if s_40_0 {
            return block_2953(state, tracer, fn_state);
        } else {
            return block_41(state, tracer, fn_state);
        };
    }
    fn block_41<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_41_0: const #0u : u8
        let s_41_0: bool = false;
        // D s_41_1: write-var gs#404054 <= s_41_0
        fn_state.gs_404054 = s_41_0;
        // N s_41_2: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_42<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_42_0: read-var gs#404054:u8
        let s_42_0: bool = fn_state.gs_404054;
        // D s_42_1: not s_42_0
        let s_42_1: bool = !s_42_0;
        // N s_42_2: branch s_42_1 b44 b43
        if s_42_1 {
            return block_44(state, tracer, fn_state);
        } else {
            return block_43(state, tracer, fn_state);
        };
    }
    fn block_43<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_43_0: const #2834s : i
        let s_43_0: i128 = 2834;
        // C s_43_1: const #14696u : u32
        let s_43_1: u32 = 14696;
        // N s_43_2: write-reg s_43_1 <= s_43_0
        let s_43_2: () = {
            state.write_register::<i128>(s_43_1 as isize, s_43_0);
            tracer.write_register(s_43_1 as isize, s_43_0);
        };
        // C s_43_3: const #28s : i
        let s_43_3: i128 = 28;
        // C s_43_4: const #4s : i
        let s_43_4: i128 = 4;
        // D s_43_5: read-var u#32370:u32
        let s_43_5: u32 = fn_state.u_32370;
        // D s_43_6: cast zx s_43_5 -> bv
        let s_43_6: Bits = Bits::new(s_43_5 as u128, 32u16);
        // D s_43_7: bit-extract s_43_6 s_43_3 s_43_4
        let s_43_7: Bits = (Bits::new(
            ((s_43_6) >> (s_43_3)).value(),
            u16::try_from(s_43_4).unwrap(),
        ));
        // D s_43_8: cast reint s_43_7 -> u8
        let s_43_8: u8 = (s_43_7.value() as u8);
        // C s_43_9: const #20s : i
        let s_43_9: i128 = 20;
        // C s_43_10: const #1s : i
        let s_43_10: i128 = 1;
        // D s_43_11: read-var u#32370:u32
        let s_43_11: u32 = fn_state.u_32370;
        // D s_43_12: cast zx s_43_11 -> bv
        let s_43_12: Bits = Bits::new(s_43_11 as u128, 32u16);
        // D s_43_13: bit-extract s_43_12 s_43_9 s_43_10
        let s_43_13: Bits = (Bits::new(
            ((s_43_12) >> (s_43_9)).value(),
            u16::try_from(s_43_10).unwrap(),
        ));
        // D s_43_14: cast reint s_43_13 -> u8
        let s_43_14: bool = ((s_43_13.value()) != 0);
        // C s_43_15: const #12s : i
        let s_43_15: i128 = 12;
        // C s_43_16: const #4s : i
        let s_43_16: i128 = 4;
        // D s_43_17: read-var u#32370:u32
        let s_43_17: u32 = fn_state.u_32370;
        // D s_43_18: cast zx s_43_17 -> bv
        let s_43_18: Bits = Bits::new(s_43_17 as u128, 32u16);
        // D s_43_19: bit-extract s_43_18 s_43_15 s_43_16
        let s_43_19: Bits = (Bits::new(
            ((s_43_18) >> (s_43_15)).value(),
            u16::try_from(s_43_16).unwrap(),
        ));
        // D s_43_20: cast reint s_43_19 -> u8
        let s_43_20: u8 = (s_43_19.value() as u8);
        // C s_43_21: const #7s : i
        let s_43_21: i128 = 7;
        // C s_43_22: const #5s : i
        let s_43_22: i128 = 5;
        // D s_43_23: read-var u#32370:u32
        let s_43_23: u32 = fn_state.u_32370;
        // D s_43_24: cast zx s_43_23 -> bv
        let s_43_24: Bits = Bits::new(s_43_23 as u128, 32u16);
        // D s_43_25: bit-extract s_43_24 s_43_21 s_43_22
        let s_43_25: Bits = (Bits::new(
            ((s_43_24) >> (s_43_21)).value(),
            u16::try_from(s_43_22).unwrap(),
        ));
        // D s_43_26: cast reint s_43_25 -> u8
        let s_43_26: u8 = (s_43_25.value() as u8);
        // C s_43_27: const #5s : i
        let s_43_27: i128 = 5;
        // C s_43_28: const #2s : i
        let s_43_28: i128 = 2;
        // D s_43_29: read-var u#32370:u32
        let s_43_29: u32 = fn_state.u_32370;
        // D s_43_30: cast zx s_43_29 -> bv
        let s_43_30: Bits = Bits::new(s_43_29 as u128, 32u16);
        // D s_43_31: bit-extract s_43_30 s_43_27 s_43_28
        let s_43_31: Bits = (Bits::new(
            ((s_43_30) >> (s_43_27)).value(),
            u16::try_from(s_43_28).unwrap(),
        ));
        // D s_43_32: cast reint s_43_31 -> u8
        let s_43_32: u8 = (s_43_31.value() as u8);
        // C s_43_33: const #0s : i
        let s_43_33: i128 = 0;
        // C s_43_34: const #4s : i
        let s_43_34: i128 = 4;
        // D s_43_35: read-var u#32370:u32
        let s_43_35: u32 = fn_state.u_32370;
        // D s_43_36: cast zx s_43_35 -> bv
        let s_43_36: Bits = Bits::new(s_43_35 as u128, 32u16);
        // D s_43_37: bit-extract s_43_36 s_43_33 s_43_34
        let s_43_37: Bits = (Bits::new(
            ((s_43_36) >> (s_43_33)).value(),
            u16::try_from(s_43_34).unwrap(),
        ));
        // D s_43_38: cast reint s_43_37 -> u8
        let s_43_38: u8 = (s_43_37.value() as u8);
        // D s_43_39: call decode_aarch32_instrs_ADD_SP_r_A1enc_A_txt(s_43_8, s_43_14, s_43_20, s_43_26, s_43_32, s_43_38)
        let s_43_39: () = decode_aarch32_instrs_ADD_SP_r_A1enc_A_txt(
            state,
            tracer,
            s_43_8,
            s_43_14,
            s_43_20,
            s_43_26,
            s_43_32,
            s_43_38,
        );
        // N s_43_40: return
        return;
    }
    fn block_44<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_44_0: read-var merge#var.1:struct
        let s_44_0: u32 = fn_state.merge_var._1;
        // D s_44_1: write-var u#32378 <= s_44_0
        fn_state.u_32378 = s_44_0;
        // C s_44_2: const #16s : i
        let s_44_2: i128 = 16;
        // D s_44_3: read-var u#32378:u32
        let s_44_3: u32 = fn_state.u_32378;
        // D s_44_4: cast zx s_44_3 -> bv
        let s_44_4: Bits = Bits::new(s_44_3 as u128, 32u16);
        // C s_44_5: const #1s : i64
        let s_44_5: i64 = 1;
        // C s_44_6: cast zx s_44_5 -> i
        let s_44_6: i128 = (i128::try_from(s_44_5).unwrap());
        // C s_44_7: const #11s : i
        let s_44_7: i128 = 11;
        // C s_44_8: add s_44_7 s_44_6
        let s_44_8: i128 = (s_44_7 + s_44_6);
        // D s_44_9: bit-extract s_44_4 s_44_2 s_44_8
        let s_44_9: Bits = (Bits::new(
            ((s_44_4) >> (s_44_2)).value(),
            u16::try_from(s_44_8).unwrap(),
        ));
        // D s_44_10: cast reint s_44_9 -> u12
        let s_44_10: u16 = (s_44_9.value() as u16);
        // D s_44_11: cast zx s_44_10 -> bv
        let s_44_11: Bits = Bits::new(s_44_10 as u128, 12u16);
        // C s_44_12: const #655u : u12
        let s_44_12: u16 = 655;
        // C s_44_13: cast zx s_44_12 -> bv
        let s_44_13: Bits = Bits::new(s_44_12 as u128, 12u16);
        // D s_44_14: cmp-eq s_44_11 s_44_13
        let s_44_14: bool = ((s_44_11) == (s_44_13));
        // N s_44_15: branch s_44_14 b2949 b45
        if s_44_14 {
            return block_2949(state, tracer, fn_state);
        } else {
            return block_45(state, tracer, fn_state);
        };
    }
    fn block_45<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_45_0: const #0u : u8
        let s_45_0: bool = false;
        // D s_45_1: write-var gs#404076 <= s_45_0
        fn_state.gs_404076 = s_45_0;
        // N s_45_2: jump b46
        return block_46(state, tracer, fn_state);
    }
    fn block_46<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_46_0: read-var gs#404076:u8
        let s_46_0: bool = fn_state.gs_404076;
        // D s_46_1: not s_46_0
        let s_46_1: bool = !s_46_0;
        // N s_46_2: branch s_46_1 b48 b47
        if s_46_1 {
            return block_48(state, tracer, fn_state);
        } else {
            return block_47(state, tracer, fn_state);
        };
    }
    fn block_47<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_47_0: const #2838s : i
        let s_47_0: i128 = 2838;
        // C s_47_1: const #14696u : u32
        let s_47_1: u32 = 14696;
        // N s_47_2: write-reg s_47_1 <= s_47_0
        let s_47_2: () = {
            state.write_register::<i128>(s_47_1 as isize, s_47_0);
            tracer.write_register(s_47_1 as isize, s_47_0);
        };
        // C s_47_3: const #28s : i
        let s_47_3: i128 = 28;
        // C s_47_4: const #4s : i
        let s_47_4: i128 = 4;
        // D s_47_5: read-var u#32378:u32
        let s_47_5: u32 = fn_state.u_32378;
        // D s_47_6: cast zx s_47_5 -> bv
        let s_47_6: Bits = Bits::new(s_47_5 as u128, 32u16);
        // D s_47_7: bit-extract s_47_6 s_47_3 s_47_4
        let s_47_7: Bits = (Bits::new(
            ((s_47_6) >> (s_47_3)).value(),
            u16::try_from(s_47_4).unwrap(),
        ));
        // D s_47_8: cast reint s_47_7 -> u8
        let s_47_8: u8 = (s_47_7.value() as u8);
        // C s_47_9: const #12s : i
        let s_47_9: i128 = 12;
        // C s_47_10: const #4s : i
        let s_47_10: i128 = 4;
        // D s_47_11: read-var u#32378:u32
        let s_47_11: u32 = fn_state.u_32378;
        // D s_47_12: cast zx s_47_11 -> bv
        let s_47_12: Bits = Bits::new(s_47_11 as u128, 32u16);
        // D s_47_13: bit-extract s_47_12 s_47_9 s_47_10
        let s_47_13: Bits = (Bits::new(
            ((s_47_12) >> (s_47_9)).value(),
            u16::try_from(s_47_10).unwrap(),
        ));
        // D s_47_14: cast reint s_47_13 -> u8
        let s_47_14: u8 = (s_47_13.value() as u8);
        // C s_47_15: const #0s : i
        let s_47_15: i128 = 0;
        // C s_47_16: const #12s : i
        let s_47_16: i128 = 12;
        // D s_47_17: read-var u#32378:u32
        let s_47_17: u32 = fn_state.u_32378;
        // D s_47_18: cast zx s_47_17 -> bv
        let s_47_18: Bits = Bits::new(s_47_17 as u128, 32u16);
        // D s_47_19: bit-extract s_47_18 s_47_15 s_47_16
        let s_47_19: Bits = (Bits::new(
            ((s_47_18) >> (s_47_15)).value(),
            u16::try_from(s_47_16).unwrap(),
        ));
        // D s_47_20: cast reint s_47_19 -> u12
        let s_47_20: u16 = (s_47_19.value() as u16);
        // D s_47_21: call decode_aarch32_instrs_ADR_A1enc_A_txt(s_47_8, s_47_14, s_47_20)
        let s_47_21: () = decode_aarch32_instrs_ADR_A1enc_A_txt(
            state,
            tracer,
            s_47_8,
            s_47_14,
            s_47_20,
        );
        // N s_47_22: return
        return;
    }
    fn block_48<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_48_0: read-var merge#var.1:struct
        let s_48_0: u32 = fn_state.merge_var._1;
        // D s_48_1: write-var u#32383 <= s_48_0
        fn_state.u_32383 = s_48_0;
        // C s_48_2: const #16s : i
        let s_48_2: i128 = 16;
        // D s_48_3: read-var u#32383:u32
        let s_48_3: u32 = fn_state.u_32383;
        // D s_48_4: cast zx s_48_3 -> bv
        let s_48_4: Bits = Bits::new(s_48_3 as u128, 32u16);
        // C s_48_5: const #1s : i64
        let s_48_5: i64 = 1;
        // C s_48_6: cast zx s_48_5 -> i
        let s_48_6: i128 = (i128::try_from(s_48_5).unwrap());
        // C s_48_7: const #11s : i
        let s_48_7: i128 = 11;
        // C s_48_8: add s_48_7 s_48_6
        let s_48_8: i128 = (s_48_7 + s_48_6);
        // D s_48_9: bit-extract s_48_4 s_48_2 s_48_8
        let s_48_9: Bits = (Bits::new(
            ((s_48_4) >> (s_48_2)).value(),
            u16::try_from(s_48_8).unwrap(),
        ));
        // D s_48_10: cast reint s_48_9 -> u12
        let s_48_10: u16 = (s_48_9.value() as u16);
        // D s_48_11: cast zx s_48_10 -> bv
        let s_48_11: Bits = Bits::new(s_48_10 as u128, 12u16);
        // C s_48_12: const #591u : u12
        let s_48_12: u16 = 591;
        // C s_48_13: cast zx s_48_12 -> bv
        let s_48_13: Bits = Bits::new(s_48_12 as u128, 12u16);
        // D s_48_14: cmp-eq s_48_11 s_48_13
        let s_48_14: bool = ((s_48_11) == (s_48_13));
        // N s_48_15: branch s_48_14 b2945 b49
        if s_48_14 {
            return block_2945(state, tracer, fn_state);
        } else {
            return block_49(state, tracer, fn_state);
        };
    }
    fn block_49<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_49_0: const #0u : u8
        let s_49_0: bool = false;
        // D s_49_1: write-var gs#404092 <= s_49_0
        fn_state.gs_404092 = s_49_0;
        // N s_49_2: jump b50
        return block_50(state, tracer, fn_state);
    }
    fn block_50<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_50_0: read-var gs#404092:u8
        let s_50_0: bool = fn_state.gs_404092;
        // D s_50_1: not s_50_0
        let s_50_1: bool = !s_50_0;
        // N s_50_2: branch s_50_1 b52 b51
        if s_50_1 {
            return block_52(state, tracer, fn_state);
        } else {
            return block_51(state, tracer, fn_state);
        };
    }
    fn block_51<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_51_0: const #2839s : i
        let s_51_0: i128 = 2839;
        // C s_51_1: const #14696u : u32
        let s_51_1: u32 = 14696;
        // N s_51_2: write-reg s_51_1 <= s_51_0
        let s_51_2: () = {
            state.write_register::<i128>(s_51_1 as isize, s_51_0);
            tracer.write_register(s_51_1 as isize, s_51_0);
        };
        // C s_51_3: const #28s : i
        let s_51_3: i128 = 28;
        // C s_51_4: const #4s : i
        let s_51_4: i128 = 4;
        // D s_51_5: read-var u#32383:u32
        let s_51_5: u32 = fn_state.u_32383;
        // D s_51_6: cast zx s_51_5 -> bv
        let s_51_6: Bits = Bits::new(s_51_5 as u128, 32u16);
        // D s_51_7: bit-extract s_51_6 s_51_3 s_51_4
        let s_51_7: Bits = (Bits::new(
            ((s_51_6) >> (s_51_3)).value(),
            u16::try_from(s_51_4).unwrap(),
        ));
        // D s_51_8: cast reint s_51_7 -> u8
        let s_51_8: u8 = (s_51_7.value() as u8);
        // C s_51_9: const #12s : i
        let s_51_9: i128 = 12;
        // C s_51_10: const #4s : i
        let s_51_10: i128 = 4;
        // D s_51_11: read-var u#32383:u32
        let s_51_11: u32 = fn_state.u_32383;
        // D s_51_12: cast zx s_51_11 -> bv
        let s_51_12: Bits = Bits::new(s_51_11 as u128, 32u16);
        // D s_51_13: bit-extract s_51_12 s_51_9 s_51_10
        let s_51_13: Bits = (Bits::new(
            ((s_51_12) >> (s_51_9)).value(),
            u16::try_from(s_51_10).unwrap(),
        ));
        // D s_51_14: cast reint s_51_13 -> u8
        let s_51_14: u8 = (s_51_13.value() as u8);
        // C s_51_15: const #0s : i
        let s_51_15: i128 = 0;
        // C s_51_16: const #12s : i
        let s_51_16: i128 = 12;
        // D s_51_17: read-var u#32383:u32
        let s_51_17: u32 = fn_state.u_32383;
        // D s_51_18: cast zx s_51_17 -> bv
        let s_51_18: Bits = Bits::new(s_51_17 as u128, 32u16);
        // D s_51_19: bit-extract s_51_18 s_51_15 s_51_16
        let s_51_19: Bits = (Bits::new(
            ((s_51_18) >> (s_51_15)).value(),
            u16::try_from(s_51_16).unwrap(),
        ));
        // D s_51_20: cast reint s_51_19 -> u12
        let s_51_20: u16 = (s_51_19.value() as u16);
        // D s_51_21: call decode_aarch32_instrs_ADR_A2enc_A_txt(s_51_8, s_51_14, s_51_20)
        let s_51_21: () = decode_aarch32_instrs_ADR_A2enc_A_txt(
            state,
            tracer,
            s_51_8,
            s_51_14,
            s_51_20,
        );
        // N s_51_22: return
        return;
    }
    fn block_52<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_52_0: read-var merge#var.1:struct
        let s_52_0: u32 = fn_state.merge_var._1;
        // D s_52_1: write-var u#32388 <= s_52_0
        fn_state.u_32388 = s_52_0;
        // C s_52_2: const #21s : i
        let s_52_2: i128 = 21;
        // D s_52_3: read-var u#32388:u32
        let s_52_3: u32 = fn_state.u_32388;
        // D s_52_4: cast zx s_52_3 -> bv
        let s_52_4: Bits = Bits::new(s_52_3 as u128, 32u16);
        // C s_52_5: const #1s : i64
        let s_52_5: i64 = 1;
        // C s_52_6: cast zx s_52_5 -> i
        let s_52_6: i128 = (i128::try_from(s_52_5).unwrap());
        // C s_52_7: const #6s : i
        let s_52_7: i128 = 6;
        // C s_52_8: add s_52_7 s_52_6
        let s_52_8: i128 = (s_52_7 + s_52_6);
        // D s_52_9: bit-extract s_52_4 s_52_2 s_52_8
        let s_52_9: Bits = (Bits::new(
            ((s_52_4) >> (s_52_2)).value(),
            u16::try_from(s_52_8).unwrap(),
        ));
        // D s_52_10: cast reint s_52_9 -> u8
        let s_52_10: u8 = (s_52_9.value() as u8);
        // D s_52_11: cast zx s_52_10 -> bv
        let s_52_11: Bits = Bits::new(s_52_10 as u128, 7u16);
        // C s_52_12: const #16u : u8
        let s_52_12: u8 = 16;
        // C s_52_13: cast zx s_52_12 -> bv
        let s_52_13: Bits = Bits::new(s_52_12 as u128, 7u16);
        // D s_52_14: cmp-eq s_52_11 s_52_13
        let s_52_14: bool = ((s_52_11) == (s_52_13));
        // N s_52_15: branch s_52_14 b2941 b53
        if s_52_14 {
            return block_2941(state, tracer, fn_state);
        } else {
            return block_53(state, tracer, fn_state);
        };
    }
    fn block_53<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_53_0: const #0u : u8
        let s_53_0: bool = false;
        // D s_53_1: write-var gs#404108 <= s_53_0
        fn_state.gs_404108 = s_53_0;
        // N s_53_2: jump b54
        return block_54(state, tracer, fn_state);
    }
    fn block_54<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_54_0: read-var gs#404108:u8
        let s_54_0: bool = fn_state.gs_404108;
        // D s_54_1: not s_54_0
        let s_54_1: bool = !s_54_0;
        // N s_54_2: branch s_54_1 b56 b55
        if s_54_1 {
            return block_56(state, tracer, fn_state);
        } else {
            return block_55(state, tracer, fn_state);
        };
    }
    fn block_55<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_55_0: const #2843s : i
        let s_55_0: i128 = 2843;
        // C s_55_1: const #14696u : u32
        let s_55_1: u32 = 14696;
        // N s_55_2: write-reg s_55_1 <= s_55_0
        let s_55_2: () = {
            state.write_register::<i128>(s_55_1 as isize, s_55_0);
            tracer.write_register(s_55_1 as isize, s_55_0);
        };
        // C s_55_3: const #28s : i
        let s_55_3: i128 = 28;
        // C s_55_4: const #4s : i
        let s_55_4: i128 = 4;
        // D s_55_5: read-var u#32388:u32
        let s_55_5: u32 = fn_state.u_32388;
        // D s_55_6: cast zx s_55_5 -> bv
        let s_55_6: Bits = Bits::new(s_55_5 as u128, 32u16);
        // D s_55_7: bit-extract s_55_6 s_55_3 s_55_4
        let s_55_7: Bits = (Bits::new(
            ((s_55_6) >> (s_55_3)).value(),
            u16::try_from(s_55_4).unwrap(),
        ));
        // D s_55_8: cast reint s_55_7 -> u8
        let s_55_8: u8 = (s_55_7.value() as u8);
        // C s_55_9: const #20s : i
        let s_55_9: i128 = 20;
        // C s_55_10: const #1s : i
        let s_55_10: i128 = 1;
        // D s_55_11: read-var u#32388:u32
        let s_55_11: u32 = fn_state.u_32388;
        // D s_55_12: cast zx s_55_11 -> bv
        let s_55_12: Bits = Bits::new(s_55_11 as u128, 32u16);
        // D s_55_13: bit-extract s_55_12 s_55_9 s_55_10
        let s_55_13: Bits = (Bits::new(
            ((s_55_12) >> (s_55_9)).value(),
            u16::try_from(s_55_10).unwrap(),
        ));
        // D s_55_14: cast reint s_55_13 -> u8
        let s_55_14: bool = ((s_55_13.value()) != 0);
        // C s_55_15: const #16s : i
        let s_55_15: i128 = 16;
        // C s_55_16: const #4s : i
        let s_55_16: i128 = 4;
        // D s_55_17: read-var u#32388:u32
        let s_55_17: u32 = fn_state.u_32388;
        // D s_55_18: cast zx s_55_17 -> bv
        let s_55_18: Bits = Bits::new(s_55_17 as u128, 32u16);
        // D s_55_19: bit-extract s_55_18 s_55_15 s_55_16
        let s_55_19: Bits = (Bits::new(
            ((s_55_18) >> (s_55_15)).value(),
            u16::try_from(s_55_16).unwrap(),
        ));
        // D s_55_20: cast reint s_55_19 -> u8
        let s_55_20: u8 = (s_55_19.value() as u8);
        // C s_55_21: const #12s : i
        let s_55_21: i128 = 12;
        // C s_55_22: const #4s : i
        let s_55_22: i128 = 4;
        // D s_55_23: read-var u#32388:u32
        let s_55_23: u32 = fn_state.u_32388;
        // D s_55_24: cast zx s_55_23 -> bv
        let s_55_24: Bits = Bits::new(s_55_23 as u128, 32u16);
        // D s_55_25: bit-extract s_55_24 s_55_21 s_55_22
        let s_55_25: Bits = (Bits::new(
            ((s_55_24) >> (s_55_21)).value(),
            u16::try_from(s_55_22).unwrap(),
        ));
        // D s_55_26: cast reint s_55_25 -> u8
        let s_55_26: u8 = (s_55_25.value() as u8);
        // C s_55_27: const #0s : i
        let s_55_27: i128 = 0;
        // C s_55_28: const #12s : i
        let s_55_28: i128 = 12;
        // D s_55_29: read-var u#32388:u32
        let s_55_29: u32 = fn_state.u_32388;
        // D s_55_30: cast zx s_55_29 -> bv
        let s_55_30: Bits = Bits::new(s_55_29 as u128, 32u16);
        // D s_55_31: bit-extract s_55_30 s_55_27 s_55_28
        let s_55_31: Bits = (Bits::new(
            ((s_55_30) >> (s_55_27)).value(),
            u16::try_from(s_55_28).unwrap(),
        ));
        // D s_55_32: cast reint s_55_31 -> u12
        let s_55_32: u16 = (s_55_31.value() as u16);
        // D s_55_33: call decode_aarch32_instrs_AND_i_A1enc_A_txt(s_55_8, s_55_14, s_55_20, s_55_26, s_55_32)
        let s_55_33: () = decode_aarch32_instrs_AND_i_A1enc_A_txt(
            state,
            tracer,
            s_55_8,
            s_55_14,
            s_55_20,
            s_55_26,
            s_55_32,
        );
        // N s_55_34: return
        return;
    }
    fn block_56<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_56_0: read-var merge#var.1:struct
        let s_56_0: u32 = fn_state.merge_var._1;
        // D s_56_1: write-var u#32395 <= s_56_0
        fn_state.u_32395 = s_56_0;
        // C s_56_2: const #21s : i
        let s_56_2: i128 = 21;
        // D s_56_3: read-var u#32395:u32
        let s_56_3: u32 = fn_state.u_32395;
        // D s_56_4: cast zx s_56_3 -> bv
        let s_56_4: Bits = Bits::new(s_56_3 as u128, 32u16);
        // C s_56_5: const #1s : i64
        let s_56_5: i64 = 1;
        // C s_56_6: cast zx s_56_5 -> i
        let s_56_6: i128 = (i128::try_from(s_56_5).unwrap());
        // C s_56_7: const #6s : i
        let s_56_7: i128 = 6;
        // C s_56_8: add s_56_7 s_56_6
        let s_56_8: i128 = (s_56_7 + s_56_6);
        // D s_56_9: bit-extract s_56_4 s_56_2 s_56_8
        let s_56_9: Bits = (Bits::new(
            ((s_56_4) >> (s_56_2)).value(),
            u16::try_from(s_56_8).unwrap(),
        ));
        // D s_56_10: cast reint s_56_9 -> u8
        let s_56_10: u8 = (s_56_9.value() as u8);
        // D s_56_11: cast zx s_56_10 -> bv
        let s_56_11: Bits = Bits::new(s_56_10 as u128, 7u16);
        // C s_56_12: const #0u : u8
        let s_56_12: u8 = 0;
        // C s_56_13: cast zx s_56_12 -> bv
        let s_56_13: Bits = Bits::new(s_56_12 as u128, 7u16);
        // D s_56_14: cmp-eq s_56_11 s_56_13
        let s_56_14: bool = ((s_56_11) == (s_56_13));
        // N s_56_15: branch s_56_14 b2940 b57
        if s_56_14 {
            return block_2940(state, tracer, fn_state);
        } else {
            return block_57(state, tracer, fn_state);
        };
    }
    fn block_57<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_57_0: const #0u : u8
        let s_57_0: bool = false;
        // D s_57_1: write-var gs#404126 <= s_57_0
        fn_state.gs_404126 = s_57_0;
        // N s_57_2: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_58<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_58_0: read-var gs#404126:u8
        let s_58_0: bool = fn_state.gs_404126;
        // N s_58_1: branch s_58_0 b2936 b59
        if s_58_0 {
            return block_2936(state, tracer, fn_state);
        } else {
            return block_59(state, tracer, fn_state);
        };
    }
    fn block_59<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_59_0: const #0u : u8
        let s_59_0: bool = false;
        // D s_59_1: write-var gs#404131 <= s_59_0
        fn_state.gs_404131 = s_59_0;
        // N s_59_2: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_60<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_60_0: read-var gs#404131:u8
        let s_60_0: bool = fn_state.gs_404131;
        // D s_60_1: not s_60_0
        let s_60_1: bool = !s_60_0;
        // N s_60_2: branch s_60_1 b62 b61
        if s_60_1 {
            return block_62(state, tracer, fn_state);
        } else {
            return block_61(state, tracer, fn_state);
        };
    }
    fn block_61<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_61_0: const #2845s : i
        let s_61_0: i128 = 2845;
        // C s_61_1: const #14696u : u32
        let s_61_1: u32 = 14696;
        // N s_61_2: write-reg s_61_1 <= s_61_0
        let s_61_2: () = {
            state.write_register::<i128>(s_61_1 as isize, s_61_0);
            tracer.write_register(s_61_1 as isize, s_61_0);
        };
        // C s_61_3: const #28s : i
        let s_61_3: i128 = 28;
        // C s_61_4: const #4s : i
        let s_61_4: i128 = 4;
        // D s_61_5: read-var u#32395:u32
        let s_61_5: u32 = fn_state.u_32395;
        // D s_61_6: cast zx s_61_5 -> bv
        let s_61_6: Bits = Bits::new(s_61_5 as u128, 32u16);
        // D s_61_7: bit-extract s_61_6 s_61_3 s_61_4
        let s_61_7: Bits = (Bits::new(
            ((s_61_6) >> (s_61_3)).value(),
            u16::try_from(s_61_4).unwrap(),
        ));
        // D s_61_8: cast reint s_61_7 -> u8
        let s_61_8: u8 = (s_61_7.value() as u8);
        // C s_61_9: const #20s : i
        let s_61_9: i128 = 20;
        // C s_61_10: const #1s : i
        let s_61_10: i128 = 1;
        // D s_61_11: read-var u#32395:u32
        let s_61_11: u32 = fn_state.u_32395;
        // D s_61_12: cast zx s_61_11 -> bv
        let s_61_12: Bits = Bits::new(s_61_11 as u128, 32u16);
        // D s_61_13: bit-extract s_61_12 s_61_9 s_61_10
        let s_61_13: Bits = (Bits::new(
            ((s_61_12) >> (s_61_9)).value(),
            u16::try_from(s_61_10).unwrap(),
        ));
        // D s_61_14: cast reint s_61_13 -> u8
        let s_61_14: bool = ((s_61_13.value()) != 0);
        // C s_61_15: const #16s : i
        let s_61_15: i128 = 16;
        // C s_61_16: const #4s : i
        let s_61_16: i128 = 4;
        // D s_61_17: read-var u#32395:u32
        let s_61_17: u32 = fn_state.u_32395;
        // D s_61_18: cast zx s_61_17 -> bv
        let s_61_18: Bits = Bits::new(s_61_17 as u128, 32u16);
        // D s_61_19: bit-extract s_61_18 s_61_15 s_61_16
        let s_61_19: Bits = (Bits::new(
            ((s_61_18) >> (s_61_15)).value(),
            u16::try_from(s_61_16).unwrap(),
        ));
        // D s_61_20: cast reint s_61_19 -> u8
        let s_61_20: u8 = (s_61_19.value() as u8);
        // C s_61_21: const #12s : i
        let s_61_21: i128 = 12;
        // C s_61_22: const #4s : i
        let s_61_22: i128 = 4;
        // D s_61_23: read-var u#32395:u32
        let s_61_23: u32 = fn_state.u_32395;
        // D s_61_24: cast zx s_61_23 -> bv
        let s_61_24: Bits = Bits::new(s_61_23 as u128, 32u16);
        // D s_61_25: bit-extract s_61_24 s_61_21 s_61_22
        let s_61_25: Bits = (Bits::new(
            ((s_61_24) >> (s_61_21)).value(),
            u16::try_from(s_61_22).unwrap(),
        ));
        // D s_61_26: cast reint s_61_25 -> u8
        let s_61_26: u8 = (s_61_25.value() as u8);
        // C s_61_27: const #7s : i
        let s_61_27: i128 = 7;
        // C s_61_28: const #5s : i
        let s_61_28: i128 = 5;
        // D s_61_29: read-var u#32395:u32
        let s_61_29: u32 = fn_state.u_32395;
        // D s_61_30: cast zx s_61_29 -> bv
        let s_61_30: Bits = Bits::new(s_61_29 as u128, 32u16);
        // D s_61_31: bit-extract s_61_30 s_61_27 s_61_28
        let s_61_31: Bits = (Bits::new(
            ((s_61_30) >> (s_61_27)).value(),
            u16::try_from(s_61_28).unwrap(),
        ));
        // D s_61_32: cast reint s_61_31 -> u8
        let s_61_32: u8 = (s_61_31.value() as u8);
        // C s_61_33: const #5s : i
        let s_61_33: i128 = 5;
        // C s_61_34: const #2s : i
        let s_61_34: i128 = 2;
        // D s_61_35: read-var u#32395:u32
        let s_61_35: u32 = fn_state.u_32395;
        // D s_61_36: cast zx s_61_35 -> bv
        let s_61_36: Bits = Bits::new(s_61_35 as u128, 32u16);
        // D s_61_37: bit-extract s_61_36 s_61_33 s_61_34
        let s_61_37: Bits = (Bits::new(
            ((s_61_36) >> (s_61_33)).value(),
            u16::try_from(s_61_34).unwrap(),
        ));
        // D s_61_38: cast reint s_61_37 -> u8
        let s_61_38: u8 = (s_61_37.value() as u8);
        // C s_61_39: const #0s : i
        let s_61_39: i128 = 0;
        // C s_61_40: const #4s : i
        let s_61_40: i128 = 4;
        // D s_61_41: read-var u#32395:u32
        let s_61_41: u32 = fn_state.u_32395;
        // D s_61_42: cast zx s_61_41 -> bv
        let s_61_42: Bits = Bits::new(s_61_41 as u128, 32u16);
        // D s_61_43: bit-extract s_61_42 s_61_39 s_61_40
        let s_61_43: Bits = (Bits::new(
            ((s_61_42) >> (s_61_39)).value(),
            u16::try_from(s_61_40).unwrap(),
        ));
        // D s_61_44: cast reint s_61_43 -> u8
        let s_61_44: u8 = (s_61_43.value() as u8);
        // D s_61_45: call decode_aarch32_instrs_AND_r_A1enc_A_txt(s_61_8, s_61_14, s_61_20, s_61_26, s_61_32, s_61_38, s_61_44)
        let s_61_45: () = decode_aarch32_instrs_AND_r_A1enc_A_txt(
            state,
            tracer,
            s_61_8,
            s_61_14,
            s_61_20,
            s_61_26,
            s_61_32,
            s_61_38,
            s_61_44,
        );
        // N s_61_46: return
        return;
    }
    fn block_62<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_62_0: read-var merge#var.1:struct
        let s_62_0: u32 = fn_state.merge_var._1;
        // D s_62_1: write-var u#32404 <= s_62_0
        fn_state.u_32404 = s_62_0;
        // C s_62_2: const #21s : i
        let s_62_2: i128 = 21;
        // D s_62_3: read-var u#32404:u32
        let s_62_3: u32 = fn_state.u_32404;
        // D s_62_4: cast zx s_62_3 -> bv
        let s_62_4: Bits = Bits::new(s_62_3 as u128, 32u16);
        // C s_62_5: const #1s : i64
        let s_62_5: i64 = 1;
        // C s_62_6: cast zx s_62_5 -> i
        let s_62_6: i128 = (i128::try_from(s_62_5).unwrap());
        // C s_62_7: const #6s : i
        let s_62_7: i128 = 6;
        // C s_62_8: add s_62_7 s_62_6
        let s_62_8: i128 = (s_62_7 + s_62_6);
        // D s_62_9: bit-extract s_62_4 s_62_2 s_62_8
        let s_62_9: Bits = (Bits::new(
            ((s_62_4) >> (s_62_2)).value(),
            u16::try_from(s_62_8).unwrap(),
        ));
        // D s_62_10: cast reint s_62_9 -> u8
        let s_62_10: u8 = (s_62_9.value() as u8);
        // D s_62_11: cast zx s_62_10 -> bv
        let s_62_11: Bits = Bits::new(s_62_10 as u128, 7u16);
        // C s_62_12: const #0u : u8
        let s_62_12: u8 = 0;
        // C s_62_13: cast zx s_62_12 -> bv
        let s_62_13: Bits = Bits::new(s_62_12 as u128, 7u16);
        // D s_62_14: cmp-eq s_62_11 s_62_13
        let s_62_14: bool = ((s_62_11) == (s_62_13));
        // N s_62_15: branch s_62_14 b2932 b63
        if s_62_14 {
            return block_2932(state, tracer, fn_state);
        } else {
            return block_63(state, tracer, fn_state);
        };
    }
    fn block_63<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_63_0: const #0u : u8
        let s_63_0: bool = false;
        // D s_63_1: write-var gs#404156 <= s_63_0
        fn_state.gs_404156 = s_63_0;
        // N s_63_2: jump b64
        return block_64(state, tracer, fn_state);
    }
    fn block_64<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_64_0: read-var gs#404156:u8
        let s_64_0: bool = fn_state.gs_404156;
        // N s_64_1: branch s_64_0 b2928 b65
        if s_64_0 {
            return block_2928(state, tracer, fn_state);
        } else {
            return block_65(state, tracer, fn_state);
        };
    }
    fn block_65<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_65_0: const #0u : u8
        let s_65_0: bool = false;
        // D s_65_1: write-var gs#404161 <= s_65_0
        fn_state.gs_404161 = s_65_0;
        // N s_65_2: jump b66
        return block_66(state, tracer, fn_state);
    }
    fn block_66<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_66_0: read-var gs#404161:u8
        let s_66_0: bool = fn_state.gs_404161;
        // D s_66_1: not s_66_0
        let s_66_1: bool = !s_66_0;
        // N s_66_2: branch s_66_1 b68 b67
        if s_66_1 {
            return block_68(state, tracer, fn_state);
        } else {
            return block_67(state, tracer, fn_state);
        };
    }
    fn block_67<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_67_0: const #2848s : i
        let s_67_0: i128 = 2848;
        // C s_67_1: const #14696u : u32
        let s_67_1: u32 = 14696;
        // N s_67_2: write-reg s_67_1 <= s_67_0
        let s_67_2: () = {
            state.write_register::<i128>(s_67_1 as isize, s_67_0);
            tracer.write_register(s_67_1 as isize, s_67_0);
        };
        // C s_67_3: const #28s : i
        let s_67_3: i128 = 28;
        // C s_67_4: const #4s : i
        let s_67_4: i128 = 4;
        // D s_67_5: read-var u#32404:u32
        let s_67_5: u32 = fn_state.u_32404;
        // D s_67_6: cast zx s_67_5 -> bv
        let s_67_6: Bits = Bits::new(s_67_5 as u128, 32u16);
        // D s_67_7: bit-extract s_67_6 s_67_3 s_67_4
        let s_67_7: Bits = (Bits::new(
            ((s_67_6) >> (s_67_3)).value(),
            u16::try_from(s_67_4).unwrap(),
        ));
        // D s_67_8: cast reint s_67_7 -> u8
        let s_67_8: u8 = (s_67_7.value() as u8);
        // C s_67_9: const #20s : i
        let s_67_9: i128 = 20;
        // C s_67_10: const #1s : i
        let s_67_10: i128 = 1;
        // D s_67_11: read-var u#32404:u32
        let s_67_11: u32 = fn_state.u_32404;
        // D s_67_12: cast zx s_67_11 -> bv
        let s_67_12: Bits = Bits::new(s_67_11 as u128, 32u16);
        // D s_67_13: bit-extract s_67_12 s_67_9 s_67_10
        let s_67_13: Bits = (Bits::new(
            ((s_67_12) >> (s_67_9)).value(),
            u16::try_from(s_67_10).unwrap(),
        ));
        // D s_67_14: cast reint s_67_13 -> u8
        let s_67_14: bool = ((s_67_13.value()) != 0);
        // C s_67_15: const #16s : i
        let s_67_15: i128 = 16;
        // C s_67_16: const #4s : i
        let s_67_16: i128 = 4;
        // D s_67_17: read-var u#32404:u32
        let s_67_17: u32 = fn_state.u_32404;
        // D s_67_18: cast zx s_67_17 -> bv
        let s_67_18: Bits = Bits::new(s_67_17 as u128, 32u16);
        // D s_67_19: bit-extract s_67_18 s_67_15 s_67_16
        let s_67_19: Bits = (Bits::new(
            ((s_67_18) >> (s_67_15)).value(),
            u16::try_from(s_67_16).unwrap(),
        ));
        // D s_67_20: cast reint s_67_19 -> u8
        let s_67_20: u8 = (s_67_19.value() as u8);
        // C s_67_21: const #12s : i
        let s_67_21: i128 = 12;
        // C s_67_22: const #4s : i
        let s_67_22: i128 = 4;
        // D s_67_23: read-var u#32404:u32
        let s_67_23: u32 = fn_state.u_32404;
        // D s_67_24: cast zx s_67_23 -> bv
        let s_67_24: Bits = Bits::new(s_67_23 as u128, 32u16);
        // D s_67_25: bit-extract s_67_24 s_67_21 s_67_22
        let s_67_25: Bits = (Bits::new(
            ((s_67_24) >> (s_67_21)).value(),
            u16::try_from(s_67_22).unwrap(),
        ));
        // D s_67_26: cast reint s_67_25 -> u8
        let s_67_26: u8 = (s_67_25.value() as u8);
        // C s_67_27: const #8s : i
        let s_67_27: i128 = 8;
        // C s_67_28: const #4s : i
        let s_67_28: i128 = 4;
        // D s_67_29: read-var u#32404:u32
        let s_67_29: u32 = fn_state.u_32404;
        // D s_67_30: cast zx s_67_29 -> bv
        let s_67_30: Bits = Bits::new(s_67_29 as u128, 32u16);
        // D s_67_31: bit-extract s_67_30 s_67_27 s_67_28
        let s_67_31: Bits = (Bits::new(
            ((s_67_30) >> (s_67_27)).value(),
            u16::try_from(s_67_28).unwrap(),
        ));
        // D s_67_32: cast reint s_67_31 -> u8
        let s_67_32: u8 = (s_67_31.value() as u8);
        // C s_67_33: const #5s : i
        let s_67_33: i128 = 5;
        // C s_67_34: const #2s : i
        let s_67_34: i128 = 2;
        // D s_67_35: read-var u#32404:u32
        let s_67_35: u32 = fn_state.u_32404;
        // D s_67_36: cast zx s_67_35 -> bv
        let s_67_36: Bits = Bits::new(s_67_35 as u128, 32u16);
        // D s_67_37: bit-extract s_67_36 s_67_33 s_67_34
        let s_67_37: Bits = (Bits::new(
            ((s_67_36) >> (s_67_33)).value(),
            u16::try_from(s_67_34).unwrap(),
        ));
        // D s_67_38: cast reint s_67_37 -> u8
        let s_67_38: u8 = (s_67_37.value() as u8);
        // C s_67_39: const #0s : i
        let s_67_39: i128 = 0;
        // C s_67_40: const #4s : i
        let s_67_40: i128 = 4;
        // D s_67_41: read-var u#32404:u32
        let s_67_41: u32 = fn_state.u_32404;
        // D s_67_42: cast zx s_67_41 -> bv
        let s_67_42: Bits = Bits::new(s_67_41 as u128, 32u16);
        // D s_67_43: bit-extract s_67_42 s_67_39 s_67_40
        let s_67_43: Bits = (Bits::new(
            ((s_67_42) >> (s_67_39)).value(),
            u16::try_from(s_67_40).unwrap(),
        ));
        // D s_67_44: cast reint s_67_43 -> u8
        let s_67_44: u8 = (s_67_43.value() as u8);
        // D s_67_45: call decode_aarch32_instrs_AND_rr_A1enc_A_txt(s_67_8, s_67_14, s_67_20, s_67_26, s_67_32, s_67_38, s_67_44)
        let s_67_45: () = decode_aarch32_instrs_AND_rr_A1enc_A_txt(
            state,
            tracer,
            s_67_8,
            s_67_14,
            s_67_20,
            s_67_26,
            s_67_32,
            s_67_38,
            s_67_44,
        );
        // N s_67_46: return
        return;
    }
    fn block_68<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_68_0: read-var merge#var.1:struct
        let s_68_0: u32 = fn_state.merge_var._1;
        // D s_68_1: write-var u#32413 <= s_68_0
        fn_state.u_32413 = s_68_0;
        // C s_68_2: const #21s : i
        let s_68_2: i128 = 21;
        // D s_68_3: read-var u#32413:u32
        let s_68_3: u32 = fn_state.u_32413;
        // D s_68_4: cast zx s_68_3 -> bv
        let s_68_4: Bits = Bits::new(s_68_3 as u128, 32u16);
        // C s_68_5: const #1s : i64
        let s_68_5: i64 = 1;
        // C s_68_6: cast zx s_68_5 -> i
        let s_68_6: i128 = (i128::try_from(s_68_5).unwrap());
        // C s_68_7: const #6s : i
        let s_68_7: i128 = 6;
        // C s_68_8: add s_68_7 s_68_6
        let s_68_8: i128 = (s_68_7 + s_68_6);
        // D s_68_9: bit-extract s_68_4 s_68_2 s_68_8
        let s_68_9: Bits = (Bits::new(
            ((s_68_4) >> (s_68_2)).value(),
            u16::try_from(s_68_8).unwrap(),
        ));
        // D s_68_10: cast reint s_68_9 -> u8
        let s_68_10: u8 = (s_68_9.value() as u8);
        // D s_68_11: cast zx s_68_10 -> bv
        let s_68_11: Bits = Bits::new(s_68_10 as u128, 7u16);
        // C s_68_12: const #30u : u8
        let s_68_12: u8 = 30;
        // C s_68_13: cast zx s_68_12 -> bv
        let s_68_13: Bits = Bits::new(s_68_12 as u128, 7u16);
        // D s_68_14: cmp-eq s_68_11 s_68_13
        let s_68_14: bool = ((s_68_11) == (s_68_13));
        // N s_68_15: branch s_68_14 b2924 b69
        if s_68_14 {
            return block_2924(state, tracer, fn_state);
        } else {
            return block_69(state, tracer, fn_state);
        };
    }
    fn block_69<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_69_0: const #0u : u8
        let s_69_0: bool = false;
        // D s_69_1: write-var gs#404185 <= s_69_0
        fn_state.gs_404185 = s_69_0;
        // N s_69_2: jump b70
        return block_70(state, tracer, fn_state);
    }
    fn block_70<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_70_0: read-var gs#404185:u8
        let s_70_0: bool = fn_state.gs_404185;
        // D s_70_1: not s_70_0
        let s_70_1: bool = !s_70_0;
        // N s_70_2: branch s_70_1 b72 b71
        if s_70_1 {
            return block_72(state, tracer, fn_state);
        } else {
            return block_71(state, tracer, fn_state);
        };
    }
    fn block_71<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_71_0: const #2860s : i
        let s_71_0: i128 = 2860;
        // C s_71_1: const #14696u : u32
        let s_71_1: u32 = 14696;
        // N s_71_2: write-reg s_71_1 <= s_71_0
        let s_71_2: () = {
            state.write_register::<i128>(s_71_1 as isize, s_71_0);
            tracer.write_register(s_71_1 as isize, s_71_0);
        };
        // C s_71_3: const #28s : i
        let s_71_3: i128 = 28;
        // C s_71_4: const #4s : i
        let s_71_4: i128 = 4;
        // D s_71_5: read-var u#32413:u32
        let s_71_5: u32 = fn_state.u_32413;
        // D s_71_6: cast zx s_71_5 -> bv
        let s_71_6: Bits = Bits::new(s_71_5 as u128, 32u16);
        // D s_71_7: bit-extract s_71_6 s_71_3 s_71_4
        let s_71_7: Bits = (Bits::new(
            ((s_71_6) >> (s_71_3)).value(),
            u16::try_from(s_71_4).unwrap(),
        ));
        // D s_71_8: cast reint s_71_7 -> u8
        let s_71_8: u8 = (s_71_7.value() as u8);
        // C s_71_9: const #20s : i
        let s_71_9: i128 = 20;
        // C s_71_10: const #1s : i
        let s_71_10: i128 = 1;
        // D s_71_11: read-var u#32413:u32
        let s_71_11: u32 = fn_state.u_32413;
        // D s_71_12: cast zx s_71_11 -> bv
        let s_71_12: Bits = Bits::new(s_71_11 as u128, 32u16);
        // D s_71_13: bit-extract s_71_12 s_71_9 s_71_10
        let s_71_13: Bits = (Bits::new(
            ((s_71_12) >> (s_71_9)).value(),
            u16::try_from(s_71_10).unwrap(),
        ));
        // D s_71_14: cast reint s_71_13 -> u8
        let s_71_14: bool = ((s_71_13.value()) != 0);
        // C s_71_15: const #16s : i
        let s_71_15: i128 = 16;
        // C s_71_16: const #4s : i
        let s_71_16: i128 = 4;
        // D s_71_17: read-var u#32413:u32
        let s_71_17: u32 = fn_state.u_32413;
        // D s_71_18: cast zx s_71_17 -> bv
        let s_71_18: Bits = Bits::new(s_71_17 as u128, 32u16);
        // D s_71_19: bit-extract s_71_18 s_71_15 s_71_16
        let s_71_19: Bits = (Bits::new(
            ((s_71_18) >> (s_71_15)).value(),
            u16::try_from(s_71_16).unwrap(),
        ));
        // D s_71_20: cast reint s_71_19 -> u8
        let s_71_20: u8 = (s_71_19.value() as u8);
        // C s_71_21: const #12s : i
        let s_71_21: i128 = 12;
        // C s_71_22: const #4s : i
        let s_71_22: i128 = 4;
        // D s_71_23: read-var u#32413:u32
        let s_71_23: u32 = fn_state.u_32413;
        // D s_71_24: cast zx s_71_23 -> bv
        let s_71_24: Bits = Bits::new(s_71_23 as u128, 32u16);
        // D s_71_25: bit-extract s_71_24 s_71_21 s_71_22
        let s_71_25: Bits = (Bits::new(
            ((s_71_24) >> (s_71_21)).value(),
            u16::try_from(s_71_22).unwrap(),
        ));
        // D s_71_26: cast reint s_71_25 -> u8
        let s_71_26: u8 = (s_71_25.value() as u8);
        // C s_71_27: const #0s : i
        let s_71_27: i128 = 0;
        // C s_71_28: const #12s : i
        let s_71_28: i128 = 12;
        // D s_71_29: read-var u#32413:u32
        let s_71_29: u32 = fn_state.u_32413;
        // D s_71_30: cast zx s_71_29 -> bv
        let s_71_30: Bits = Bits::new(s_71_29 as u128, 32u16);
        // D s_71_31: bit-extract s_71_30 s_71_27 s_71_28
        let s_71_31: Bits = (Bits::new(
            ((s_71_30) >> (s_71_27)).value(),
            u16::try_from(s_71_28).unwrap(),
        ));
        // D s_71_32: cast reint s_71_31 -> u12
        let s_71_32: u16 = (s_71_31.value() as u16);
        // D s_71_33: call decode_aarch32_instrs_BIC_i_A1enc_A_txt(s_71_8, s_71_14, s_71_20, s_71_26, s_71_32)
        let s_71_33: () = decode_aarch32_instrs_BIC_i_A1enc_A_txt(
            state,
            tracer,
            s_71_8,
            s_71_14,
            s_71_20,
            s_71_26,
            s_71_32,
        );
        // N s_71_34: return
        return;
    }
    fn block_72<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_72_0: read-var merge#var.1:struct
        let s_72_0: u32 = fn_state.merge_var._1;
        // D s_72_1: write-var u#32420 <= s_72_0
        fn_state.u_32420 = s_72_0;
        // C s_72_2: const #21s : i
        let s_72_2: i128 = 21;
        // D s_72_3: read-var u#32420:u32
        let s_72_3: u32 = fn_state.u_32420;
        // D s_72_4: cast zx s_72_3 -> bv
        let s_72_4: Bits = Bits::new(s_72_3 as u128, 32u16);
        // C s_72_5: const #1s : i64
        let s_72_5: i64 = 1;
        // C s_72_6: cast zx s_72_5 -> i
        let s_72_6: i128 = (i128::try_from(s_72_5).unwrap());
        // C s_72_7: const #6s : i
        let s_72_7: i128 = 6;
        // C s_72_8: add s_72_7 s_72_6
        let s_72_8: i128 = (s_72_7 + s_72_6);
        // D s_72_9: bit-extract s_72_4 s_72_2 s_72_8
        let s_72_9: Bits = (Bits::new(
            ((s_72_4) >> (s_72_2)).value(),
            u16::try_from(s_72_8).unwrap(),
        ));
        // D s_72_10: cast reint s_72_9 -> u8
        let s_72_10: u8 = (s_72_9.value() as u8);
        // D s_72_11: cast zx s_72_10 -> bv
        let s_72_11: Bits = Bits::new(s_72_10 as u128, 7u16);
        // C s_72_12: const #14u : u8
        let s_72_12: u8 = 14;
        // C s_72_13: cast zx s_72_12 -> bv
        let s_72_13: Bits = Bits::new(s_72_12 as u128, 7u16);
        // D s_72_14: cmp-eq s_72_11 s_72_13
        let s_72_14: bool = ((s_72_11) == (s_72_13));
        // N s_72_15: branch s_72_14 b2923 b73
        if s_72_14 {
            return block_2923(state, tracer, fn_state);
        } else {
            return block_73(state, tracer, fn_state);
        };
    }
    fn block_73<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_73_0: const #0u : u8
        let s_73_0: bool = false;
        // D s_73_1: write-var gs#404203 <= s_73_0
        fn_state.gs_404203 = s_73_0;
        // N s_73_2: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_74<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_74_0: read-var gs#404203:u8
        let s_74_0: bool = fn_state.gs_404203;
        // N s_74_1: branch s_74_0 b2919 b75
        if s_74_0 {
            return block_2919(state, tracer, fn_state);
        } else {
            return block_75(state, tracer, fn_state);
        };
    }
    fn block_75<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_75_0: const #0u : u8
        let s_75_0: bool = false;
        // D s_75_1: write-var gs#404208 <= s_75_0
        fn_state.gs_404208 = s_75_0;
        // N s_75_2: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_76<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_76_0: read-var gs#404208:u8
        let s_76_0: bool = fn_state.gs_404208;
        // D s_76_1: not s_76_0
        let s_76_1: bool = !s_76_0;
        // N s_76_2: branch s_76_1 b78 b77
        if s_76_1 {
            return block_78(state, tracer, fn_state);
        } else {
            return block_77(state, tracer, fn_state);
        };
    }
    fn block_77<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_77_0: const #2862s : i
        let s_77_0: i128 = 2862;
        // C s_77_1: const #14696u : u32
        let s_77_1: u32 = 14696;
        // N s_77_2: write-reg s_77_1 <= s_77_0
        let s_77_2: () = {
            state.write_register::<i128>(s_77_1 as isize, s_77_0);
            tracer.write_register(s_77_1 as isize, s_77_0);
        };
        // C s_77_3: const #28s : i
        let s_77_3: i128 = 28;
        // C s_77_4: const #4s : i
        let s_77_4: i128 = 4;
        // D s_77_5: read-var u#32420:u32
        let s_77_5: u32 = fn_state.u_32420;
        // D s_77_6: cast zx s_77_5 -> bv
        let s_77_6: Bits = Bits::new(s_77_5 as u128, 32u16);
        // D s_77_7: bit-extract s_77_6 s_77_3 s_77_4
        let s_77_7: Bits = (Bits::new(
            ((s_77_6) >> (s_77_3)).value(),
            u16::try_from(s_77_4).unwrap(),
        ));
        // D s_77_8: cast reint s_77_7 -> u8
        let s_77_8: u8 = (s_77_7.value() as u8);
        // C s_77_9: const #20s : i
        let s_77_9: i128 = 20;
        // C s_77_10: const #1s : i
        let s_77_10: i128 = 1;
        // D s_77_11: read-var u#32420:u32
        let s_77_11: u32 = fn_state.u_32420;
        // D s_77_12: cast zx s_77_11 -> bv
        let s_77_12: Bits = Bits::new(s_77_11 as u128, 32u16);
        // D s_77_13: bit-extract s_77_12 s_77_9 s_77_10
        let s_77_13: Bits = (Bits::new(
            ((s_77_12) >> (s_77_9)).value(),
            u16::try_from(s_77_10).unwrap(),
        ));
        // D s_77_14: cast reint s_77_13 -> u8
        let s_77_14: bool = ((s_77_13.value()) != 0);
        // C s_77_15: const #16s : i
        let s_77_15: i128 = 16;
        // C s_77_16: const #4s : i
        let s_77_16: i128 = 4;
        // D s_77_17: read-var u#32420:u32
        let s_77_17: u32 = fn_state.u_32420;
        // D s_77_18: cast zx s_77_17 -> bv
        let s_77_18: Bits = Bits::new(s_77_17 as u128, 32u16);
        // D s_77_19: bit-extract s_77_18 s_77_15 s_77_16
        let s_77_19: Bits = (Bits::new(
            ((s_77_18) >> (s_77_15)).value(),
            u16::try_from(s_77_16).unwrap(),
        ));
        // D s_77_20: cast reint s_77_19 -> u8
        let s_77_20: u8 = (s_77_19.value() as u8);
        // C s_77_21: const #12s : i
        let s_77_21: i128 = 12;
        // C s_77_22: const #4s : i
        let s_77_22: i128 = 4;
        // D s_77_23: read-var u#32420:u32
        let s_77_23: u32 = fn_state.u_32420;
        // D s_77_24: cast zx s_77_23 -> bv
        let s_77_24: Bits = Bits::new(s_77_23 as u128, 32u16);
        // D s_77_25: bit-extract s_77_24 s_77_21 s_77_22
        let s_77_25: Bits = (Bits::new(
            ((s_77_24) >> (s_77_21)).value(),
            u16::try_from(s_77_22).unwrap(),
        ));
        // D s_77_26: cast reint s_77_25 -> u8
        let s_77_26: u8 = (s_77_25.value() as u8);
        // C s_77_27: const #7s : i
        let s_77_27: i128 = 7;
        // C s_77_28: const #5s : i
        let s_77_28: i128 = 5;
        // D s_77_29: read-var u#32420:u32
        let s_77_29: u32 = fn_state.u_32420;
        // D s_77_30: cast zx s_77_29 -> bv
        let s_77_30: Bits = Bits::new(s_77_29 as u128, 32u16);
        // D s_77_31: bit-extract s_77_30 s_77_27 s_77_28
        let s_77_31: Bits = (Bits::new(
            ((s_77_30) >> (s_77_27)).value(),
            u16::try_from(s_77_28).unwrap(),
        ));
        // D s_77_32: cast reint s_77_31 -> u8
        let s_77_32: u8 = (s_77_31.value() as u8);
        // C s_77_33: const #5s : i
        let s_77_33: i128 = 5;
        // C s_77_34: const #2s : i
        let s_77_34: i128 = 2;
        // D s_77_35: read-var u#32420:u32
        let s_77_35: u32 = fn_state.u_32420;
        // D s_77_36: cast zx s_77_35 -> bv
        let s_77_36: Bits = Bits::new(s_77_35 as u128, 32u16);
        // D s_77_37: bit-extract s_77_36 s_77_33 s_77_34
        let s_77_37: Bits = (Bits::new(
            ((s_77_36) >> (s_77_33)).value(),
            u16::try_from(s_77_34).unwrap(),
        ));
        // D s_77_38: cast reint s_77_37 -> u8
        let s_77_38: u8 = (s_77_37.value() as u8);
        // C s_77_39: const #0s : i
        let s_77_39: i128 = 0;
        // C s_77_40: const #4s : i
        let s_77_40: i128 = 4;
        // D s_77_41: read-var u#32420:u32
        let s_77_41: u32 = fn_state.u_32420;
        // D s_77_42: cast zx s_77_41 -> bv
        let s_77_42: Bits = Bits::new(s_77_41 as u128, 32u16);
        // D s_77_43: bit-extract s_77_42 s_77_39 s_77_40
        let s_77_43: Bits = (Bits::new(
            ((s_77_42) >> (s_77_39)).value(),
            u16::try_from(s_77_40).unwrap(),
        ));
        // D s_77_44: cast reint s_77_43 -> u8
        let s_77_44: u8 = (s_77_43.value() as u8);
        // D s_77_45: call decode_aarch32_instrs_BIC_r_A1enc_A_txt(s_77_8, s_77_14, s_77_20, s_77_26, s_77_32, s_77_38, s_77_44)
        let s_77_45: () = decode_aarch32_instrs_BIC_r_A1enc_A_txt(
            state,
            tracer,
            s_77_8,
            s_77_14,
            s_77_20,
            s_77_26,
            s_77_32,
            s_77_38,
            s_77_44,
        );
        // N s_77_46: return
        return;
    }
    fn block_78<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_78_0: read-var merge#var.1:struct
        let s_78_0: u32 = fn_state.merge_var._1;
        // D s_78_1: write-var u#32429 <= s_78_0
        fn_state.u_32429 = s_78_0;
        // C s_78_2: const #21s : i
        let s_78_2: i128 = 21;
        // D s_78_3: read-var u#32429:u32
        let s_78_3: u32 = fn_state.u_32429;
        // D s_78_4: cast zx s_78_3 -> bv
        let s_78_4: Bits = Bits::new(s_78_3 as u128, 32u16);
        // C s_78_5: const #1s : i64
        let s_78_5: i64 = 1;
        // C s_78_6: cast zx s_78_5 -> i
        let s_78_6: i128 = (i128::try_from(s_78_5).unwrap());
        // C s_78_7: const #6s : i
        let s_78_7: i128 = 6;
        // C s_78_8: add s_78_7 s_78_6
        let s_78_8: i128 = (s_78_7 + s_78_6);
        // D s_78_9: bit-extract s_78_4 s_78_2 s_78_8
        let s_78_9: Bits = (Bits::new(
            ((s_78_4) >> (s_78_2)).value(),
            u16::try_from(s_78_8).unwrap(),
        ));
        // D s_78_10: cast reint s_78_9 -> u8
        let s_78_10: u8 = (s_78_9.value() as u8);
        // D s_78_11: cast zx s_78_10 -> bv
        let s_78_11: Bits = Bits::new(s_78_10 as u128, 7u16);
        // C s_78_12: const #14u : u8
        let s_78_12: u8 = 14;
        // C s_78_13: cast zx s_78_12 -> bv
        let s_78_13: Bits = Bits::new(s_78_12 as u128, 7u16);
        // D s_78_14: cmp-eq s_78_11 s_78_13
        let s_78_14: bool = ((s_78_11) == (s_78_13));
        // N s_78_15: branch s_78_14 b2915 b79
        if s_78_14 {
            return block_2915(state, tracer, fn_state);
        } else {
            return block_79(state, tracer, fn_state);
        };
    }
    fn block_79<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_79_0: const #0u : u8
        let s_79_0: bool = false;
        // D s_79_1: write-var gs#404233 <= s_79_0
        fn_state.gs_404233 = s_79_0;
        // N s_79_2: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_80<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_80_0: read-var gs#404233:u8
        let s_80_0: bool = fn_state.gs_404233;
        // N s_80_1: branch s_80_0 b2911 b81
        if s_80_0 {
            return block_2911(state, tracer, fn_state);
        } else {
            return block_81(state, tracer, fn_state);
        };
    }
    fn block_81<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_81_0: const #0u : u8
        let s_81_0: bool = false;
        // D s_81_1: write-var gs#404238 <= s_81_0
        fn_state.gs_404238 = s_81_0;
        // N s_81_2: jump b82
        return block_82(state, tracer, fn_state);
    }
    fn block_82<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_82_0: read-var gs#404238:u8
        let s_82_0: bool = fn_state.gs_404238;
        // D s_82_1: not s_82_0
        let s_82_1: bool = !s_82_0;
        // N s_82_2: branch s_82_1 b84 b83
        if s_82_1 {
            return block_84(state, tracer, fn_state);
        } else {
            return block_83(state, tracer, fn_state);
        };
    }
    fn block_83<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_83_0: const #2865s : i
        let s_83_0: i128 = 2865;
        // C s_83_1: const #14696u : u32
        let s_83_1: u32 = 14696;
        // N s_83_2: write-reg s_83_1 <= s_83_0
        let s_83_2: () = {
            state.write_register::<i128>(s_83_1 as isize, s_83_0);
            tracer.write_register(s_83_1 as isize, s_83_0);
        };
        // C s_83_3: const #28s : i
        let s_83_3: i128 = 28;
        // C s_83_4: const #4s : i
        let s_83_4: i128 = 4;
        // D s_83_5: read-var u#32429:u32
        let s_83_5: u32 = fn_state.u_32429;
        // D s_83_6: cast zx s_83_5 -> bv
        let s_83_6: Bits = Bits::new(s_83_5 as u128, 32u16);
        // D s_83_7: bit-extract s_83_6 s_83_3 s_83_4
        let s_83_7: Bits = (Bits::new(
            ((s_83_6) >> (s_83_3)).value(),
            u16::try_from(s_83_4).unwrap(),
        ));
        // D s_83_8: cast reint s_83_7 -> u8
        let s_83_8: u8 = (s_83_7.value() as u8);
        // C s_83_9: const #20s : i
        let s_83_9: i128 = 20;
        // C s_83_10: const #1s : i
        let s_83_10: i128 = 1;
        // D s_83_11: read-var u#32429:u32
        let s_83_11: u32 = fn_state.u_32429;
        // D s_83_12: cast zx s_83_11 -> bv
        let s_83_12: Bits = Bits::new(s_83_11 as u128, 32u16);
        // D s_83_13: bit-extract s_83_12 s_83_9 s_83_10
        let s_83_13: Bits = (Bits::new(
            ((s_83_12) >> (s_83_9)).value(),
            u16::try_from(s_83_10).unwrap(),
        ));
        // D s_83_14: cast reint s_83_13 -> u8
        let s_83_14: bool = ((s_83_13.value()) != 0);
        // C s_83_15: const #16s : i
        let s_83_15: i128 = 16;
        // C s_83_16: const #4s : i
        let s_83_16: i128 = 4;
        // D s_83_17: read-var u#32429:u32
        let s_83_17: u32 = fn_state.u_32429;
        // D s_83_18: cast zx s_83_17 -> bv
        let s_83_18: Bits = Bits::new(s_83_17 as u128, 32u16);
        // D s_83_19: bit-extract s_83_18 s_83_15 s_83_16
        let s_83_19: Bits = (Bits::new(
            ((s_83_18) >> (s_83_15)).value(),
            u16::try_from(s_83_16).unwrap(),
        ));
        // D s_83_20: cast reint s_83_19 -> u8
        let s_83_20: u8 = (s_83_19.value() as u8);
        // C s_83_21: const #12s : i
        let s_83_21: i128 = 12;
        // C s_83_22: const #4s : i
        let s_83_22: i128 = 4;
        // D s_83_23: read-var u#32429:u32
        let s_83_23: u32 = fn_state.u_32429;
        // D s_83_24: cast zx s_83_23 -> bv
        let s_83_24: Bits = Bits::new(s_83_23 as u128, 32u16);
        // D s_83_25: bit-extract s_83_24 s_83_21 s_83_22
        let s_83_25: Bits = (Bits::new(
            ((s_83_24) >> (s_83_21)).value(),
            u16::try_from(s_83_22).unwrap(),
        ));
        // D s_83_26: cast reint s_83_25 -> u8
        let s_83_26: u8 = (s_83_25.value() as u8);
        // C s_83_27: const #8s : i
        let s_83_27: i128 = 8;
        // C s_83_28: const #4s : i
        let s_83_28: i128 = 4;
        // D s_83_29: read-var u#32429:u32
        let s_83_29: u32 = fn_state.u_32429;
        // D s_83_30: cast zx s_83_29 -> bv
        let s_83_30: Bits = Bits::new(s_83_29 as u128, 32u16);
        // D s_83_31: bit-extract s_83_30 s_83_27 s_83_28
        let s_83_31: Bits = (Bits::new(
            ((s_83_30) >> (s_83_27)).value(),
            u16::try_from(s_83_28).unwrap(),
        ));
        // D s_83_32: cast reint s_83_31 -> u8
        let s_83_32: u8 = (s_83_31.value() as u8);
        // C s_83_33: const #5s : i
        let s_83_33: i128 = 5;
        // C s_83_34: const #2s : i
        let s_83_34: i128 = 2;
        // D s_83_35: read-var u#32429:u32
        let s_83_35: u32 = fn_state.u_32429;
        // D s_83_36: cast zx s_83_35 -> bv
        let s_83_36: Bits = Bits::new(s_83_35 as u128, 32u16);
        // D s_83_37: bit-extract s_83_36 s_83_33 s_83_34
        let s_83_37: Bits = (Bits::new(
            ((s_83_36) >> (s_83_33)).value(),
            u16::try_from(s_83_34).unwrap(),
        ));
        // D s_83_38: cast reint s_83_37 -> u8
        let s_83_38: u8 = (s_83_37.value() as u8);
        // C s_83_39: const #0s : i
        let s_83_39: i128 = 0;
        // C s_83_40: const #4s : i
        let s_83_40: i128 = 4;
        // D s_83_41: read-var u#32429:u32
        let s_83_41: u32 = fn_state.u_32429;
        // D s_83_42: cast zx s_83_41 -> bv
        let s_83_42: Bits = Bits::new(s_83_41 as u128, 32u16);
        // D s_83_43: bit-extract s_83_42 s_83_39 s_83_40
        let s_83_43: Bits = (Bits::new(
            ((s_83_42) >> (s_83_39)).value(),
            u16::try_from(s_83_40).unwrap(),
        ));
        // D s_83_44: cast reint s_83_43 -> u8
        let s_83_44: u8 = (s_83_43.value() as u8);
        // D s_83_45: call decode_aarch32_instrs_BIC_rr_A1enc_A_txt(s_83_8, s_83_14, s_83_20, s_83_26, s_83_32, s_83_38, s_83_44)
        let s_83_45: () = decode_aarch32_instrs_BIC_rr_A1enc_A_txt(
            state,
            tracer,
            s_83_8,
            s_83_14,
            s_83_20,
            s_83_26,
            s_83_32,
            s_83_38,
            s_83_44,
        );
        // N s_83_46: return
        return;
    }
    fn block_84<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_84_0: read-var merge#var.1:struct
        let s_84_0: u32 = fn_state.merge_var._1;
        // D s_84_1: write-var u#32438 <= s_84_0
        fn_state.u_32438 = s_84_0;
        // C s_84_2: const #20s : i
        let s_84_2: i128 = 20;
        // D s_84_3: read-var u#32438:u32
        let s_84_3: u32 = fn_state.u_32438;
        // D s_84_4: cast zx s_84_3 -> bv
        let s_84_4: Bits = Bits::new(s_84_3 as u128, 32u16);
        // C s_84_5: const #1s : i64
        let s_84_5: i64 = 1;
        // C s_84_6: cast zx s_84_5 -> i
        let s_84_6: i128 = (i128::try_from(s_84_5).unwrap());
        // C s_84_7: const #7s : i
        let s_84_7: i128 = 7;
        // C s_84_8: add s_84_7 s_84_6
        let s_84_8: i128 = (s_84_7 + s_84_6);
        // D s_84_9: bit-extract s_84_4 s_84_2 s_84_8
        let s_84_9: Bits = (Bits::new(
            ((s_84_4) >> (s_84_2)).value(),
            u16::try_from(s_84_8).unwrap(),
        ));
        // D s_84_10: cast reint s_84_9 -> u8
        let s_84_10: u8 = (s_84_9.value() as u8);
        // D s_84_11: cast zx s_84_10 -> bv
        let s_84_11: Bits = Bits::new(s_84_10 as u128, 8u16);
        // C s_84_12: const #18u : u8
        let s_84_12: u8 = 18;
        // C s_84_13: cast zx s_84_12 -> bv
        let s_84_13: Bits = Bits::new(s_84_12 as u128, 8u16);
        // D s_84_14: cmp-eq s_84_11 s_84_13
        let s_84_14: bool = ((s_84_11) == (s_84_13));
        // N s_84_15: branch s_84_14 b2910 b85
        if s_84_14 {
            return block_2910(state, tracer, fn_state);
        } else {
            return block_85(state, tracer, fn_state);
        };
    }
    fn block_85<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_85_0: const #0u : u8
        let s_85_0: bool = false;
        // D s_85_1: write-var gs#404260 <= s_85_0
        fn_state.gs_404260 = s_85_0;
        // N s_85_2: jump b86
        return block_86(state, tracer, fn_state);
    }
    fn block_86<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_86_0: read-var gs#404260:u8
        let s_86_0: bool = fn_state.gs_404260;
        // N s_86_1: branch s_86_0 b2906 b87
        if s_86_0 {
            return block_2906(state, tracer, fn_state);
        } else {
            return block_87(state, tracer, fn_state);
        };
    }
    fn block_87<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_87_0: const #0u : u8
        let s_87_0: bool = false;
        // D s_87_1: write-var gs#404265 <= s_87_0
        fn_state.gs_404265 = s_87_0;
        // N s_87_2: jump b88
        return block_88(state, tracer, fn_state);
    }
    fn block_88<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_88_0: read-var gs#404265:u8
        let s_88_0: bool = fn_state.gs_404265;
        // D s_88_1: not s_88_0
        let s_88_1: bool = !s_88_0;
        // N s_88_2: branch s_88_1 b90 b89
        if s_88_1 {
            return block_90(state, tracer, fn_state);
        } else {
            return block_89(state, tracer, fn_state);
        };
    }
    fn block_89<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_89_0: const #2866s : i
        let s_89_0: i128 = 2866;
        // C s_89_1: const #14696u : u32
        let s_89_1: u32 = 14696;
        // N s_89_2: write-reg s_89_1 <= s_89_0
        let s_89_2: () = {
            state.write_register::<i128>(s_89_1 as isize, s_89_0);
            tracer.write_register(s_89_1 as isize, s_89_0);
        };
        // C s_89_3: const #28s : i
        let s_89_3: i128 = 28;
        // C s_89_4: const #4s : i
        let s_89_4: i128 = 4;
        // D s_89_5: read-var u#32438:u32
        let s_89_5: u32 = fn_state.u_32438;
        // D s_89_6: cast zx s_89_5 -> bv
        let s_89_6: Bits = Bits::new(s_89_5 as u128, 32u16);
        // D s_89_7: bit-extract s_89_6 s_89_3 s_89_4
        let s_89_7: Bits = (Bits::new(
            ((s_89_6) >> (s_89_3)).value(),
            u16::try_from(s_89_4).unwrap(),
        ));
        // D s_89_8: cast reint s_89_7 -> u8
        let s_89_8: u8 = (s_89_7.value() as u8);
        // C s_89_9: const #8s : i
        let s_89_9: i128 = 8;
        // C s_89_10: const #12s : i
        let s_89_10: i128 = 12;
        // D s_89_11: read-var u#32438:u32
        let s_89_11: u32 = fn_state.u_32438;
        // D s_89_12: cast zx s_89_11 -> bv
        let s_89_12: Bits = Bits::new(s_89_11 as u128, 32u16);
        // D s_89_13: bit-extract s_89_12 s_89_9 s_89_10
        let s_89_13: Bits = (Bits::new(
            ((s_89_12) >> (s_89_9)).value(),
            u16::try_from(s_89_10).unwrap(),
        ));
        // D s_89_14: cast reint s_89_13 -> u12
        let s_89_14: u16 = (s_89_13.value() as u16);
        // C s_89_15: const #0s : i
        let s_89_15: i128 = 0;
        // C s_89_16: const #4s : i
        let s_89_16: i128 = 4;
        // D s_89_17: read-var u#32438:u32
        let s_89_17: u32 = fn_state.u_32438;
        // D s_89_18: cast zx s_89_17 -> bv
        let s_89_18: Bits = Bits::new(s_89_17 as u128, 32u16);
        // D s_89_19: bit-extract s_89_18 s_89_15 s_89_16
        let s_89_19: Bits = (Bits::new(
            ((s_89_18) >> (s_89_15)).value(),
            u16::try_from(s_89_16).unwrap(),
        ));
        // D s_89_20: cast reint s_89_19 -> u8
        let s_89_20: u8 = (s_89_19.value() as u8);
        // D s_89_21: call decode_aarch32_instrs_BKPT_A1enc_A_txt(s_89_8, s_89_14, s_89_20)
        let s_89_21: () = decode_aarch32_instrs_BKPT_A1enc_A_txt(
            state,
            tracer,
            s_89_8,
            s_89_14,
            s_89_20,
        );
        // N s_89_22: return
        return;
    }
    fn block_90<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_90_0: read-var merge#var.1:struct
        let s_90_0: u32 = fn_state.merge_var._1;
        // D s_90_1: write-var u#32442 <= s_90_0
        fn_state.u_32442 = s_90_0;
        // C s_90_2: const #4s : i
        let s_90_2: i128 = 4;
        // D s_90_3: read-var u#32442:u32
        let s_90_3: u32 = fn_state.u_32442;
        // D s_90_4: cast zx s_90_3 -> bv
        let s_90_4: Bits = Bits::new(s_90_3 as u128, 32u16);
        // C s_90_5: const #1s : i64
        let s_90_5: i64 = 1;
        // C s_90_6: cast zx s_90_5 -> i
        let s_90_6: i128 = (i128::try_from(s_90_5).unwrap());
        // C s_90_7: const #23s : i
        let s_90_7: i128 = 23;
        // C s_90_8: add s_90_7 s_90_6
        let s_90_8: i128 = (s_90_7 + s_90_6);
        // D s_90_9: bit-extract s_90_4 s_90_2 s_90_8
        let s_90_9: Bits = (Bits::new(
            ((s_90_4) >> (s_90_2)).value(),
            u16::try_from(s_90_8).unwrap(),
        ));
        // D s_90_10: cast reint s_90_9 -> u24
        let s_90_10: u32 = (s_90_9.value() as u32);
        // D s_90_11: cast zx s_90_10 -> bv
        let s_90_11: Bits = Bits::new(s_90_10 as u128, 24u16);
        // C s_90_12: const #1245171u : u24
        let s_90_12: u32 = 1245171;
        // C s_90_13: cast zx s_90_12 -> bv
        let s_90_13: Bits = Bits::new(s_90_12 as u128, 24u16);
        // D s_90_14: cmp-eq s_90_11 s_90_13
        let s_90_14: bool = ((s_90_11) == (s_90_13));
        // N s_90_15: branch s_90_14 b2902 b91
        if s_90_14 {
            return block_2902(state, tracer, fn_state);
        } else {
            return block_91(state, tracer, fn_state);
        };
    }
    fn block_91<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_91_0: const #0u : u8
        let s_91_0: bool = false;
        // D s_91_1: write-var gs#404281 <= s_91_0
        fn_state.gs_404281 = s_91_0;
        // N s_91_2: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_92<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_92_0: read-var gs#404281:u8
        let s_92_0: bool = fn_state.gs_404281;
        // D s_92_1: not s_92_0
        let s_92_1: bool = !s_92_0;
        // N s_92_2: branch s_92_1 b129 b93
        if s_92_1 {
            return block_129(state, tracer, fn_state);
        } else {
            return block_93(state, tracer, fn_state);
        };
    }
    fn block_93<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_93_0: const #2872s : i
        let s_93_0: i128 = 2872;
        // C s_93_1: const #14696u : u32
        let s_93_1: u32 = 14696;
        // N s_93_2: write-reg s_93_1 <= s_93_0
        let s_93_2: () = {
            state.write_register::<i128>(s_93_1 as isize, s_93_0);
            tracer.write_register(s_93_1 as isize, s_93_0);
        };
        // C s_93_3: const #28s : i
        let s_93_3: i128 = 28;
        // C s_93_4: const #4s : i
        let s_93_4: i128 = 4;
        // D s_93_5: read-var u#32442:u32
        let s_93_5: u32 = fn_state.u_32442;
        // D s_93_6: cast zx s_93_5 -> bv
        let s_93_6: Bits = Bits::new(s_93_5 as u128, 32u16);
        // D s_93_7: bit-extract s_93_6 s_93_3 s_93_4
        let s_93_7: Bits = (Bits::new(
            ((s_93_6) >> (s_93_3)).value(),
            u16::try_from(s_93_4).unwrap(),
        ));
        // D s_93_8: cast reint s_93_7 -> u8
        let s_93_8: u8 = (s_93_7.value() as u8);
        // D s_93_9: write-var u#32443 <= s_93_8
        fn_state.u_32443 = s_93_8;
        // C s_93_10: const #0s : i
        let s_93_10: i128 = 0;
        // C s_93_11: const #4s : i
        let s_93_11: i128 = 4;
        // D s_93_12: read-var u#32442:u32
        let s_93_12: u32 = fn_state.u_32442;
        // D s_93_13: cast zx s_93_12 -> bv
        let s_93_13: Bits = Bits::new(s_93_12 as u128, 32u16);
        // D s_93_14: bit-extract s_93_13 s_93_10 s_93_11
        let s_93_14: Bits = (Bits::new(
            ((s_93_13) >> (s_93_10)).value(),
            u16::try_from(s_93_11).unwrap(),
        ));
        // D s_93_15: cast reint s_93_14 -> u8
        let s_93_15: u8 = (s_93_14.value() as u8);
        // D s_93_16: write-var u#32444 <= s_93_15
        fn_state.u_32444 = s_93_15;
        // C s_93_17: const #16s : i
        let s_93_17: i128 = 16;
        // D s_93_18: read-var u#32442:u32
        let s_93_18: u32 = fn_state.u_32442;
        // D s_93_19: cast zx s_93_18 -> bv
        let s_93_19: Bits = Bits::new(s_93_18 as u128, 32u16);
        // C s_93_20: const #1u : u64
        let s_93_20: u64 = 1;
        // D s_93_21: bit-extract s_93_19 s_93_17 s_93_20
        let s_93_21: Bits = (Bits::new(
            ((s_93_19) >> (s_93_17)).value(),
            u16::try_from(s_93_20).unwrap(),
        ));
        // D s_93_22: cast reint s_93_21 -> u8
        let s_93_22: bool = ((s_93_21.value()) != 0);
        // C s_93_23: const #0s : i
        let s_93_23: i128 = 0;
        // C s_93_24: const #0u : u64
        let s_93_24: u64 = 0;
        // D s_93_25: cast zx s_93_22 -> u64
        let s_93_25: u64 = (s_93_22 as u64);
        // C s_93_26: const #1u : u64
        let s_93_26: u64 = 1;
        // D s_93_27: and s_93_25 s_93_26
        let s_93_27: u64 = ((s_93_25) & (s_93_26));
        // D s_93_28: cmp-eq s_93_27 s_93_26
        let s_93_28: bool = ((s_93_27) == (s_93_26));
        // D s_93_29: lsl s_93_25 s_93_23
        let s_93_29: u64 = s_93_25 << s_93_23;
        // D s_93_30: or s_93_24 s_93_29
        let s_93_30: u64 = ((s_93_24) | (s_93_29));
        // D s_93_31: cmpl s_93_29
        let s_93_31: u64 = !s_93_29;
        // D s_93_32: and s_93_24 s_93_31
        let s_93_32: u64 = ((s_93_24) & (s_93_31));
        // D s_93_33: select s_93_28 s_93_30 s_93_32
        let s_93_33: u64 = if s_93_28 { s_93_30 } else { s_93_32 };
        // D s_93_34: cast trunc s_93_33 -> u8
        let s_93_34: bool = ((s_93_33) != 0);
        // D s_93_35: cast zx s_93_34 -> bv
        let s_93_35: Bits = Bits::new(s_93_34 as u128, 1u16);
        // C s_93_36: const #1u : u8
        let s_93_36: bool = true;
        // C s_93_37: cast zx s_93_36 -> bv
        let s_93_37: Bits = Bits::new(s_93_36 as u128, 1u16);
        // D s_93_38: cmp-ne s_93_35 s_93_37
        let s_93_38: bool = ((s_93_35) != (s_93_37));
        // N s_93_39: branch s_93_38 b128 b94
        if s_93_38 {
            return block_128(state, tracer, fn_state);
        } else {
            return block_94(state, tracer, fn_state);
        };
    }
    fn block_94<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_94_0: const #17s : i
        let s_94_0: i128 = 17;
        // D s_94_1: read-var u#32442:u32
        let s_94_1: u32 = fn_state.u_32442;
        // D s_94_2: cast zx s_94_1 -> bv
        let s_94_2: Bits = Bits::new(s_94_1 as u128, 32u16);
        // C s_94_3: const #1u : u64
        let s_94_3: u64 = 1;
        // D s_94_4: bit-extract s_94_2 s_94_0 s_94_3
        let s_94_4: Bits = (Bits::new(
            ((s_94_2) >> (s_94_0)).value(),
            u16::try_from(s_94_3).unwrap(),
        ));
        // D s_94_5: cast reint s_94_4 -> u8
        let s_94_5: bool = ((s_94_4.value()) != 0);
        // C s_94_6: const #0s : i
        let s_94_6: i128 = 0;
        // C s_94_7: const #0u : u64
        let s_94_7: u64 = 0;
        // D s_94_8: cast zx s_94_5 -> u64
        let s_94_8: u64 = (s_94_5 as u64);
        // C s_94_9: const #1u : u64
        let s_94_9: u64 = 1;
        // D s_94_10: and s_94_8 s_94_9
        let s_94_10: u64 = ((s_94_8) & (s_94_9));
        // D s_94_11: cmp-eq s_94_10 s_94_9
        let s_94_11: bool = ((s_94_10) == (s_94_9));
        // D s_94_12: lsl s_94_8 s_94_6
        let s_94_12: u64 = s_94_8 << s_94_6;
        // D s_94_13: or s_94_7 s_94_12
        let s_94_13: u64 = ((s_94_7) | (s_94_12));
        // D s_94_14: cmpl s_94_12
        let s_94_14: u64 = !s_94_12;
        // D s_94_15: and s_94_7 s_94_14
        let s_94_15: u64 = ((s_94_7) & (s_94_14));
        // D s_94_16: select s_94_11 s_94_13 s_94_15
        let s_94_16: u64 = if s_94_11 { s_94_13 } else { s_94_15 };
        // D s_94_17: cast trunc s_94_16 -> u8
        let s_94_17: bool = ((s_94_16) != 0);
        // D s_94_18: cast zx s_94_17 -> bv
        let s_94_18: Bits = Bits::new(s_94_17 as u128, 1u16);
        // C s_94_19: const #1u : u8
        let s_94_19: bool = true;
        // C s_94_20: cast zx s_94_19 -> bv
        let s_94_20: Bits = Bits::new(s_94_19 as u128, 1u16);
        // D s_94_21: cmp-ne s_94_18 s_94_20
        let s_94_21: bool = ((s_94_18) != (s_94_20));
        // D s_94_22: write-var gs#404292 <= s_94_21
        fn_state.gs_404292 = s_94_21;
        // N s_94_23: jump b95
        return block_95(state, tracer, fn_state);
    }
    fn block_95<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_95_0: read-var gs#404292:u8
        let s_95_0: bool = fn_state.gs_404292;
        // N s_95_1: branch s_95_0 b127 b96
        if s_95_0 {
            return block_127(state, tracer, fn_state);
        } else {
            return block_96(state, tracer, fn_state);
        };
    }
    fn block_96<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_96_0: const #18s : i
        let s_96_0: i128 = 18;
        // D s_96_1: read-var u#32442:u32
        let s_96_1: u32 = fn_state.u_32442;
        // D s_96_2: cast zx s_96_1 -> bv
        let s_96_2: Bits = Bits::new(s_96_1 as u128, 32u16);
        // C s_96_3: const #1u : u64
        let s_96_3: u64 = 1;
        // D s_96_4: bit-extract s_96_2 s_96_0 s_96_3
        let s_96_4: Bits = (Bits::new(
            ((s_96_2) >> (s_96_0)).value(),
            u16::try_from(s_96_3).unwrap(),
        ));
        // D s_96_5: cast reint s_96_4 -> u8
        let s_96_5: bool = ((s_96_4.value()) != 0);
        // C s_96_6: const #0s : i
        let s_96_6: i128 = 0;
        // C s_96_7: const #0u : u64
        let s_96_7: u64 = 0;
        // D s_96_8: cast zx s_96_5 -> u64
        let s_96_8: u64 = (s_96_5 as u64);
        // C s_96_9: const #1u : u64
        let s_96_9: u64 = 1;
        // D s_96_10: and s_96_8 s_96_9
        let s_96_10: u64 = ((s_96_8) & (s_96_9));
        // D s_96_11: cmp-eq s_96_10 s_96_9
        let s_96_11: bool = ((s_96_10) == (s_96_9));
        // D s_96_12: lsl s_96_8 s_96_6
        let s_96_12: u64 = s_96_8 << s_96_6;
        // D s_96_13: or s_96_7 s_96_12
        let s_96_13: u64 = ((s_96_7) | (s_96_12));
        // D s_96_14: cmpl s_96_12
        let s_96_14: u64 = !s_96_12;
        // D s_96_15: and s_96_7 s_96_14
        let s_96_15: u64 = ((s_96_7) & (s_96_14));
        // D s_96_16: select s_96_11 s_96_13 s_96_15
        let s_96_16: u64 = if s_96_11 { s_96_13 } else { s_96_15 };
        // D s_96_17: cast trunc s_96_16 -> u8
        let s_96_17: bool = ((s_96_16) != 0);
        // D s_96_18: cast zx s_96_17 -> bv
        let s_96_18: Bits = Bits::new(s_96_17 as u128, 1u16);
        // C s_96_19: const #1u : u8
        let s_96_19: bool = true;
        // C s_96_20: cast zx s_96_19 -> bv
        let s_96_20: Bits = Bits::new(s_96_19 as u128, 1u16);
        // D s_96_21: cmp-ne s_96_18 s_96_20
        let s_96_21: bool = ((s_96_18) != (s_96_20));
        // D s_96_22: write-var gs#404295 <= s_96_21
        fn_state.gs_404295 = s_96_21;
        // N s_96_23: jump b97
        return block_97(state, tracer, fn_state);
    }
    fn block_97<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_97_0: read-var gs#404295:u8
        let s_97_0: bool = fn_state.gs_404295;
        // N s_97_1: branch s_97_0 b126 b98
        if s_97_0 {
            return block_126(state, tracer, fn_state);
        } else {
            return block_98(state, tracer, fn_state);
        };
    }
    fn block_98<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_98_0: const #19s : i
        let s_98_0: i128 = 19;
        // D s_98_1: read-var u#32442:u32
        let s_98_1: u32 = fn_state.u_32442;
        // D s_98_2: cast zx s_98_1 -> bv
        let s_98_2: Bits = Bits::new(s_98_1 as u128, 32u16);
        // C s_98_3: const #1u : u64
        let s_98_3: u64 = 1;
        // D s_98_4: bit-extract s_98_2 s_98_0 s_98_3
        let s_98_4: Bits = (Bits::new(
            ((s_98_2) >> (s_98_0)).value(),
            u16::try_from(s_98_3).unwrap(),
        ));
        // D s_98_5: cast reint s_98_4 -> u8
        let s_98_5: bool = ((s_98_4.value()) != 0);
        // C s_98_6: const #0s : i
        let s_98_6: i128 = 0;
        // C s_98_7: const #0u : u64
        let s_98_7: u64 = 0;
        // D s_98_8: cast zx s_98_5 -> u64
        let s_98_8: u64 = (s_98_5 as u64);
        // C s_98_9: const #1u : u64
        let s_98_9: u64 = 1;
        // D s_98_10: and s_98_8 s_98_9
        let s_98_10: u64 = ((s_98_8) & (s_98_9));
        // D s_98_11: cmp-eq s_98_10 s_98_9
        let s_98_11: bool = ((s_98_10) == (s_98_9));
        // D s_98_12: lsl s_98_8 s_98_6
        let s_98_12: u64 = s_98_8 << s_98_6;
        // D s_98_13: or s_98_7 s_98_12
        let s_98_13: u64 = ((s_98_7) | (s_98_12));
        // D s_98_14: cmpl s_98_12
        let s_98_14: u64 = !s_98_12;
        // D s_98_15: and s_98_7 s_98_14
        let s_98_15: u64 = ((s_98_7) & (s_98_14));
        // D s_98_16: select s_98_11 s_98_13 s_98_15
        let s_98_16: u64 = if s_98_11 { s_98_13 } else { s_98_15 };
        // D s_98_17: cast trunc s_98_16 -> u8
        let s_98_17: bool = ((s_98_16) != 0);
        // D s_98_18: cast zx s_98_17 -> bv
        let s_98_18: Bits = Bits::new(s_98_17 as u128, 1u16);
        // C s_98_19: const #1u : u8
        let s_98_19: bool = true;
        // C s_98_20: cast zx s_98_19 -> bv
        let s_98_20: Bits = Bits::new(s_98_19 as u128, 1u16);
        // D s_98_21: cmp-ne s_98_18 s_98_20
        let s_98_21: bool = ((s_98_18) != (s_98_20));
        // D s_98_22: write-var gs#404298 <= s_98_21
        fn_state.gs_404298 = s_98_21;
        // N s_98_23: jump b99
        return block_99(state, tracer, fn_state);
    }
    fn block_99<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_99_0: read-var gs#404298:u8
        let s_99_0: bool = fn_state.gs_404298;
        // N s_99_1: branch s_99_0 b125 b100
        if s_99_0 {
            return block_125(state, tracer, fn_state);
        } else {
            return block_100(state, tracer, fn_state);
        };
    }
    fn block_100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_100_0: const #12s : i
        let s_100_0: i128 = 12;
        // D s_100_1: read-var u#32442:u32
        let s_100_1: u32 = fn_state.u_32442;
        // D s_100_2: cast zx s_100_1 -> bv
        let s_100_2: Bits = Bits::new(s_100_1 as u128, 32u16);
        // C s_100_3: const #1u : u64
        let s_100_3: u64 = 1;
        // D s_100_4: bit-extract s_100_2 s_100_0 s_100_3
        let s_100_4: Bits = (Bits::new(
            ((s_100_2) >> (s_100_0)).value(),
            u16::try_from(s_100_3).unwrap(),
        ));
        // D s_100_5: cast reint s_100_4 -> u8
        let s_100_5: bool = ((s_100_4.value()) != 0);
        // C s_100_6: const #0s : i
        let s_100_6: i128 = 0;
        // C s_100_7: const #0u : u64
        let s_100_7: u64 = 0;
        // D s_100_8: cast zx s_100_5 -> u64
        let s_100_8: u64 = (s_100_5 as u64);
        // C s_100_9: const #1u : u64
        let s_100_9: u64 = 1;
        // D s_100_10: and s_100_8 s_100_9
        let s_100_10: u64 = ((s_100_8) & (s_100_9));
        // D s_100_11: cmp-eq s_100_10 s_100_9
        let s_100_11: bool = ((s_100_10) == (s_100_9));
        // D s_100_12: lsl s_100_8 s_100_6
        let s_100_12: u64 = s_100_8 << s_100_6;
        // D s_100_13: or s_100_7 s_100_12
        let s_100_13: u64 = ((s_100_7) | (s_100_12));
        // D s_100_14: cmpl s_100_12
        let s_100_14: u64 = !s_100_12;
        // D s_100_15: and s_100_7 s_100_14
        let s_100_15: u64 = ((s_100_7) & (s_100_14));
        // D s_100_16: select s_100_11 s_100_13 s_100_15
        let s_100_16: u64 = if s_100_11 { s_100_13 } else { s_100_15 };
        // D s_100_17: cast trunc s_100_16 -> u8
        let s_100_17: bool = ((s_100_16) != 0);
        // D s_100_18: cast zx s_100_17 -> bv
        let s_100_18: Bits = Bits::new(s_100_17 as u128, 1u16);
        // C s_100_19: const #1u : u8
        let s_100_19: bool = true;
        // C s_100_20: cast zx s_100_19 -> bv
        let s_100_20: Bits = Bits::new(s_100_19 as u128, 1u16);
        // D s_100_21: cmp-ne s_100_18 s_100_20
        let s_100_21: bool = ((s_100_18) != (s_100_20));
        // D s_100_22: write-var gs#404301 <= s_100_21
        fn_state.gs_404301 = s_100_21;
        // N s_100_23: jump b101
        return block_101(state, tracer, fn_state);
    }
    fn block_101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_101_0: read-var gs#404301:u8
        let s_101_0: bool = fn_state.gs_404301;
        // N s_101_1: branch s_101_0 b124 b102
        if s_101_0 {
            return block_124(state, tracer, fn_state);
        } else {
            return block_102(state, tracer, fn_state);
        };
    }
    fn block_102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_102_0: const #13s : i
        let s_102_0: i128 = 13;
        // D s_102_1: read-var u#32442:u32
        let s_102_1: u32 = fn_state.u_32442;
        // D s_102_2: cast zx s_102_1 -> bv
        let s_102_2: Bits = Bits::new(s_102_1 as u128, 32u16);
        // C s_102_3: const #1u : u64
        let s_102_3: u64 = 1;
        // D s_102_4: bit-extract s_102_2 s_102_0 s_102_3
        let s_102_4: Bits = (Bits::new(
            ((s_102_2) >> (s_102_0)).value(),
            u16::try_from(s_102_3).unwrap(),
        ));
        // D s_102_5: cast reint s_102_4 -> u8
        let s_102_5: bool = ((s_102_4.value()) != 0);
        // C s_102_6: const #0s : i
        let s_102_6: i128 = 0;
        // C s_102_7: const #0u : u64
        let s_102_7: u64 = 0;
        // D s_102_8: cast zx s_102_5 -> u64
        let s_102_8: u64 = (s_102_5 as u64);
        // C s_102_9: const #1u : u64
        let s_102_9: u64 = 1;
        // D s_102_10: and s_102_8 s_102_9
        let s_102_10: u64 = ((s_102_8) & (s_102_9));
        // D s_102_11: cmp-eq s_102_10 s_102_9
        let s_102_11: bool = ((s_102_10) == (s_102_9));
        // D s_102_12: lsl s_102_8 s_102_6
        let s_102_12: u64 = s_102_8 << s_102_6;
        // D s_102_13: or s_102_7 s_102_12
        let s_102_13: u64 = ((s_102_7) | (s_102_12));
        // D s_102_14: cmpl s_102_12
        let s_102_14: u64 = !s_102_12;
        // D s_102_15: and s_102_7 s_102_14
        let s_102_15: u64 = ((s_102_7) & (s_102_14));
        // D s_102_16: select s_102_11 s_102_13 s_102_15
        let s_102_16: u64 = if s_102_11 { s_102_13 } else { s_102_15 };
        // D s_102_17: cast trunc s_102_16 -> u8
        let s_102_17: bool = ((s_102_16) != 0);
        // D s_102_18: cast zx s_102_17 -> bv
        let s_102_18: Bits = Bits::new(s_102_17 as u128, 1u16);
        // C s_102_19: const #1u : u8
        let s_102_19: bool = true;
        // C s_102_20: cast zx s_102_19 -> bv
        let s_102_20: Bits = Bits::new(s_102_19 as u128, 1u16);
        // D s_102_21: cmp-ne s_102_18 s_102_20
        let s_102_21: bool = ((s_102_18) != (s_102_20));
        // D s_102_22: write-var gs#404304 <= s_102_21
        fn_state.gs_404304 = s_102_21;
        // N s_102_23: jump b103
        return block_103(state, tracer, fn_state);
    }
    fn block_103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_103_0: read-var gs#404304:u8
        let s_103_0: bool = fn_state.gs_404304;
        // N s_103_1: branch s_103_0 b123 b104
        if s_103_0 {
            return block_123(state, tracer, fn_state);
        } else {
            return block_104(state, tracer, fn_state);
        };
    }
    fn block_104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_104_0: const #14s : i
        let s_104_0: i128 = 14;
        // D s_104_1: read-var u#32442:u32
        let s_104_1: u32 = fn_state.u_32442;
        // D s_104_2: cast zx s_104_1 -> bv
        let s_104_2: Bits = Bits::new(s_104_1 as u128, 32u16);
        // C s_104_3: const #1u : u64
        let s_104_3: u64 = 1;
        // D s_104_4: bit-extract s_104_2 s_104_0 s_104_3
        let s_104_4: Bits = (Bits::new(
            ((s_104_2) >> (s_104_0)).value(),
            u16::try_from(s_104_3).unwrap(),
        ));
        // D s_104_5: cast reint s_104_4 -> u8
        let s_104_5: bool = ((s_104_4.value()) != 0);
        // C s_104_6: const #0s : i
        let s_104_6: i128 = 0;
        // C s_104_7: const #0u : u64
        let s_104_7: u64 = 0;
        // D s_104_8: cast zx s_104_5 -> u64
        let s_104_8: u64 = (s_104_5 as u64);
        // C s_104_9: const #1u : u64
        let s_104_9: u64 = 1;
        // D s_104_10: and s_104_8 s_104_9
        let s_104_10: u64 = ((s_104_8) & (s_104_9));
        // D s_104_11: cmp-eq s_104_10 s_104_9
        let s_104_11: bool = ((s_104_10) == (s_104_9));
        // D s_104_12: lsl s_104_8 s_104_6
        let s_104_12: u64 = s_104_8 << s_104_6;
        // D s_104_13: or s_104_7 s_104_12
        let s_104_13: u64 = ((s_104_7) | (s_104_12));
        // D s_104_14: cmpl s_104_12
        let s_104_14: u64 = !s_104_12;
        // D s_104_15: and s_104_7 s_104_14
        let s_104_15: u64 = ((s_104_7) & (s_104_14));
        // D s_104_16: select s_104_11 s_104_13 s_104_15
        let s_104_16: u64 = if s_104_11 { s_104_13 } else { s_104_15 };
        // D s_104_17: cast trunc s_104_16 -> u8
        let s_104_17: bool = ((s_104_16) != 0);
        // D s_104_18: cast zx s_104_17 -> bv
        let s_104_18: Bits = Bits::new(s_104_17 as u128, 1u16);
        // C s_104_19: const #1u : u8
        let s_104_19: bool = true;
        // C s_104_20: cast zx s_104_19 -> bv
        let s_104_20: Bits = Bits::new(s_104_19 as u128, 1u16);
        // D s_104_21: cmp-ne s_104_18 s_104_20
        let s_104_21: bool = ((s_104_18) != (s_104_20));
        // D s_104_22: write-var gs#404307 <= s_104_21
        fn_state.gs_404307 = s_104_21;
        // N s_104_23: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_105_0: read-var gs#404307:u8
        let s_105_0: bool = fn_state.gs_404307;
        // N s_105_1: branch s_105_0 b122 b106
        if s_105_0 {
            return block_122(state, tracer, fn_state);
        } else {
            return block_106(state, tracer, fn_state);
        };
    }
    fn block_106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_106_0: const #15s : i
        let s_106_0: i128 = 15;
        // D s_106_1: read-var u#32442:u32
        let s_106_1: u32 = fn_state.u_32442;
        // D s_106_2: cast zx s_106_1 -> bv
        let s_106_2: Bits = Bits::new(s_106_1 as u128, 32u16);
        // C s_106_3: const #1u : u64
        let s_106_3: u64 = 1;
        // D s_106_4: bit-extract s_106_2 s_106_0 s_106_3
        let s_106_4: Bits = (Bits::new(
            ((s_106_2) >> (s_106_0)).value(),
            u16::try_from(s_106_3).unwrap(),
        ));
        // D s_106_5: cast reint s_106_4 -> u8
        let s_106_5: bool = ((s_106_4.value()) != 0);
        // C s_106_6: const #0s : i
        let s_106_6: i128 = 0;
        // C s_106_7: const #0u : u64
        let s_106_7: u64 = 0;
        // D s_106_8: cast zx s_106_5 -> u64
        let s_106_8: u64 = (s_106_5 as u64);
        // C s_106_9: const #1u : u64
        let s_106_9: u64 = 1;
        // D s_106_10: and s_106_8 s_106_9
        let s_106_10: u64 = ((s_106_8) & (s_106_9));
        // D s_106_11: cmp-eq s_106_10 s_106_9
        let s_106_11: bool = ((s_106_10) == (s_106_9));
        // D s_106_12: lsl s_106_8 s_106_6
        let s_106_12: u64 = s_106_8 << s_106_6;
        // D s_106_13: or s_106_7 s_106_12
        let s_106_13: u64 = ((s_106_7) | (s_106_12));
        // D s_106_14: cmpl s_106_12
        let s_106_14: u64 = !s_106_12;
        // D s_106_15: and s_106_7 s_106_14
        let s_106_15: u64 = ((s_106_7) & (s_106_14));
        // D s_106_16: select s_106_11 s_106_13 s_106_15
        let s_106_16: u64 = if s_106_11 { s_106_13 } else { s_106_15 };
        // D s_106_17: cast trunc s_106_16 -> u8
        let s_106_17: bool = ((s_106_16) != 0);
        // D s_106_18: cast zx s_106_17 -> bv
        let s_106_18: Bits = Bits::new(s_106_17 as u128, 1u16);
        // C s_106_19: const #1u : u8
        let s_106_19: bool = true;
        // C s_106_20: cast zx s_106_19 -> bv
        let s_106_20: Bits = Bits::new(s_106_19 as u128, 1u16);
        // D s_106_21: cmp-ne s_106_18 s_106_20
        let s_106_21: bool = ((s_106_18) != (s_106_20));
        // D s_106_22: write-var gs#404310 <= s_106_21
        fn_state.gs_404310 = s_106_21;
        // N s_106_23: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_107_0: read-var gs#404310:u8
        let s_107_0: bool = fn_state.gs_404310;
        // N s_107_1: branch s_107_0 b121 b108
        if s_107_0 {
            return block_121(state, tracer, fn_state);
        } else {
            return block_108(state, tracer, fn_state);
        };
    }
    fn block_108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_108_0: const #8s : i
        let s_108_0: i128 = 8;
        // D s_108_1: read-var u#32442:u32
        let s_108_1: u32 = fn_state.u_32442;
        // D s_108_2: cast zx s_108_1 -> bv
        let s_108_2: Bits = Bits::new(s_108_1 as u128, 32u16);
        // C s_108_3: const #1u : u64
        let s_108_3: u64 = 1;
        // D s_108_4: bit-extract s_108_2 s_108_0 s_108_3
        let s_108_4: Bits = (Bits::new(
            ((s_108_2) >> (s_108_0)).value(),
            u16::try_from(s_108_3).unwrap(),
        ));
        // D s_108_5: cast reint s_108_4 -> u8
        let s_108_5: bool = ((s_108_4.value()) != 0);
        // C s_108_6: const #0s : i
        let s_108_6: i128 = 0;
        // C s_108_7: const #0u : u64
        let s_108_7: u64 = 0;
        // D s_108_8: cast zx s_108_5 -> u64
        let s_108_8: u64 = (s_108_5 as u64);
        // C s_108_9: const #1u : u64
        let s_108_9: u64 = 1;
        // D s_108_10: and s_108_8 s_108_9
        let s_108_10: u64 = ((s_108_8) & (s_108_9));
        // D s_108_11: cmp-eq s_108_10 s_108_9
        let s_108_11: bool = ((s_108_10) == (s_108_9));
        // D s_108_12: lsl s_108_8 s_108_6
        let s_108_12: u64 = s_108_8 << s_108_6;
        // D s_108_13: or s_108_7 s_108_12
        let s_108_13: u64 = ((s_108_7) | (s_108_12));
        // D s_108_14: cmpl s_108_12
        let s_108_14: u64 = !s_108_12;
        // D s_108_15: and s_108_7 s_108_14
        let s_108_15: u64 = ((s_108_7) & (s_108_14));
        // D s_108_16: select s_108_11 s_108_13 s_108_15
        let s_108_16: u64 = if s_108_11 { s_108_13 } else { s_108_15 };
        // D s_108_17: cast trunc s_108_16 -> u8
        let s_108_17: bool = ((s_108_16) != 0);
        // D s_108_18: cast zx s_108_17 -> bv
        let s_108_18: Bits = Bits::new(s_108_17 as u128, 1u16);
        // C s_108_19: const #1u : u8
        let s_108_19: bool = true;
        // C s_108_20: cast zx s_108_19 -> bv
        let s_108_20: Bits = Bits::new(s_108_19 as u128, 1u16);
        // D s_108_21: cmp-ne s_108_18 s_108_20
        let s_108_21: bool = ((s_108_18) != (s_108_20));
        // D s_108_22: write-var gs#404313 <= s_108_21
        fn_state.gs_404313 = s_108_21;
        // N s_108_23: jump b109
        return block_109(state, tracer, fn_state);
    }
    fn block_109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_109_0: read-var gs#404313:u8
        let s_109_0: bool = fn_state.gs_404313;
        // N s_109_1: branch s_109_0 b120 b110
        if s_109_0 {
            return block_120(state, tracer, fn_state);
        } else {
            return block_110(state, tracer, fn_state);
        };
    }
    fn block_110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_110_0: const #9s : i
        let s_110_0: i128 = 9;
        // D s_110_1: read-var u#32442:u32
        let s_110_1: u32 = fn_state.u_32442;
        // D s_110_2: cast zx s_110_1 -> bv
        let s_110_2: Bits = Bits::new(s_110_1 as u128, 32u16);
        // C s_110_3: const #1u : u64
        let s_110_3: u64 = 1;
        // D s_110_4: bit-extract s_110_2 s_110_0 s_110_3
        let s_110_4: Bits = (Bits::new(
            ((s_110_2) >> (s_110_0)).value(),
            u16::try_from(s_110_3).unwrap(),
        ));
        // D s_110_5: cast reint s_110_4 -> u8
        let s_110_5: bool = ((s_110_4.value()) != 0);
        // C s_110_6: const #0s : i
        let s_110_6: i128 = 0;
        // C s_110_7: const #0u : u64
        let s_110_7: u64 = 0;
        // D s_110_8: cast zx s_110_5 -> u64
        let s_110_8: u64 = (s_110_5 as u64);
        // C s_110_9: const #1u : u64
        let s_110_9: u64 = 1;
        // D s_110_10: and s_110_8 s_110_9
        let s_110_10: u64 = ((s_110_8) & (s_110_9));
        // D s_110_11: cmp-eq s_110_10 s_110_9
        let s_110_11: bool = ((s_110_10) == (s_110_9));
        // D s_110_12: lsl s_110_8 s_110_6
        let s_110_12: u64 = s_110_8 << s_110_6;
        // D s_110_13: or s_110_7 s_110_12
        let s_110_13: u64 = ((s_110_7) | (s_110_12));
        // D s_110_14: cmpl s_110_12
        let s_110_14: u64 = !s_110_12;
        // D s_110_15: and s_110_7 s_110_14
        let s_110_15: u64 = ((s_110_7) & (s_110_14));
        // D s_110_16: select s_110_11 s_110_13 s_110_15
        let s_110_16: u64 = if s_110_11 { s_110_13 } else { s_110_15 };
        // D s_110_17: cast trunc s_110_16 -> u8
        let s_110_17: bool = ((s_110_16) != 0);
        // D s_110_18: cast zx s_110_17 -> bv
        let s_110_18: Bits = Bits::new(s_110_17 as u128, 1u16);
        // C s_110_19: const #1u : u8
        let s_110_19: bool = true;
        // C s_110_20: cast zx s_110_19 -> bv
        let s_110_20: Bits = Bits::new(s_110_19 as u128, 1u16);
        // D s_110_21: cmp-ne s_110_18 s_110_20
        let s_110_21: bool = ((s_110_18) != (s_110_20));
        // D s_110_22: write-var gs#404316 <= s_110_21
        fn_state.gs_404316 = s_110_21;
        // N s_110_23: jump b111
        return block_111(state, tracer, fn_state);
    }
    fn block_111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_111_0: read-var gs#404316:u8
        let s_111_0: bool = fn_state.gs_404316;
        // N s_111_1: branch s_111_0 b119 b112
        if s_111_0 {
            return block_119(state, tracer, fn_state);
        } else {
            return block_112(state, tracer, fn_state);
        };
    }
    fn block_112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_112_0: const #10s : i
        let s_112_0: i128 = 10;
        // D s_112_1: read-var u#32442:u32
        let s_112_1: u32 = fn_state.u_32442;
        // D s_112_2: cast zx s_112_1 -> bv
        let s_112_2: Bits = Bits::new(s_112_1 as u128, 32u16);
        // C s_112_3: const #1u : u64
        let s_112_3: u64 = 1;
        // D s_112_4: bit-extract s_112_2 s_112_0 s_112_3
        let s_112_4: Bits = (Bits::new(
            ((s_112_2) >> (s_112_0)).value(),
            u16::try_from(s_112_3).unwrap(),
        ));
        // D s_112_5: cast reint s_112_4 -> u8
        let s_112_5: bool = ((s_112_4.value()) != 0);
        // C s_112_6: const #0s : i
        let s_112_6: i128 = 0;
        // C s_112_7: const #0u : u64
        let s_112_7: u64 = 0;
        // D s_112_8: cast zx s_112_5 -> u64
        let s_112_8: u64 = (s_112_5 as u64);
        // C s_112_9: const #1u : u64
        let s_112_9: u64 = 1;
        // D s_112_10: and s_112_8 s_112_9
        let s_112_10: u64 = ((s_112_8) & (s_112_9));
        // D s_112_11: cmp-eq s_112_10 s_112_9
        let s_112_11: bool = ((s_112_10) == (s_112_9));
        // D s_112_12: lsl s_112_8 s_112_6
        let s_112_12: u64 = s_112_8 << s_112_6;
        // D s_112_13: or s_112_7 s_112_12
        let s_112_13: u64 = ((s_112_7) | (s_112_12));
        // D s_112_14: cmpl s_112_12
        let s_112_14: u64 = !s_112_12;
        // D s_112_15: and s_112_7 s_112_14
        let s_112_15: u64 = ((s_112_7) & (s_112_14));
        // D s_112_16: select s_112_11 s_112_13 s_112_15
        let s_112_16: u64 = if s_112_11 { s_112_13 } else { s_112_15 };
        // D s_112_17: cast trunc s_112_16 -> u8
        let s_112_17: bool = ((s_112_16) != 0);
        // D s_112_18: cast zx s_112_17 -> bv
        let s_112_18: Bits = Bits::new(s_112_17 as u128, 1u16);
        // C s_112_19: const #1u : u8
        let s_112_19: bool = true;
        // C s_112_20: cast zx s_112_19 -> bv
        let s_112_20: Bits = Bits::new(s_112_19 as u128, 1u16);
        // D s_112_21: cmp-ne s_112_18 s_112_20
        let s_112_21: bool = ((s_112_18) != (s_112_20));
        // D s_112_22: write-var gs#404319 <= s_112_21
        fn_state.gs_404319 = s_112_21;
        // N s_112_23: jump b113
        return block_113(state, tracer, fn_state);
    }
    fn block_113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_113_0: read-var gs#404319:u8
        let s_113_0: bool = fn_state.gs_404319;
        // N s_113_1: branch s_113_0 b118 b114
        if s_113_0 {
            return block_118(state, tracer, fn_state);
        } else {
            return block_114(state, tracer, fn_state);
        };
    }
    fn block_114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_114_0: const #11s : i
        let s_114_0: i128 = 11;
        // D s_114_1: read-var u#32442:u32
        let s_114_1: u32 = fn_state.u_32442;
        // D s_114_2: cast zx s_114_1 -> bv
        let s_114_2: Bits = Bits::new(s_114_1 as u128, 32u16);
        // C s_114_3: const #1u : u64
        let s_114_3: u64 = 1;
        // D s_114_4: bit-extract s_114_2 s_114_0 s_114_3
        let s_114_4: Bits = (Bits::new(
            ((s_114_2) >> (s_114_0)).value(),
            u16::try_from(s_114_3).unwrap(),
        ));
        // D s_114_5: cast reint s_114_4 -> u8
        let s_114_5: bool = ((s_114_4.value()) != 0);
        // C s_114_6: const #0s : i
        let s_114_6: i128 = 0;
        // C s_114_7: const #0u : u64
        let s_114_7: u64 = 0;
        // D s_114_8: cast zx s_114_5 -> u64
        let s_114_8: u64 = (s_114_5 as u64);
        // C s_114_9: const #1u : u64
        let s_114_9: u64 = 1;
        // D s_114_10: and s_114_8 s_114_9
        let s_114_10: u64 = ((s_114_8) & (s_114_9));
        // D s_114_11: cmp-eq s_114_10 s_114_9
        let s_114_11: bool = ((s_114_10) == (s_114_9));
        // D s_114_12: lsl s_114_8 s_114_6
        let s_114_12: u64 = s_114_8 << s_114_6;
        // D s_114_13: or s_114_7 s_114_12
        let s_114_13: u64 = ((s_114_7) | (s_114_12));
        // D s_114_14: cmpl s_114_12
        let s_114_14: u64 = !s_114_12;
        // D s_114_15: and s_114_7 s_114_14
        let s_114_15: u64 = ((s_114_7) & (s_114_14));
        // D s_114_16: select s_114_11 s_114_13 s_114_15
        let s_114_16: u64 = if s_114_11 { s_114_13 } else { s_114_15 };
        // D s_114_17: cast trunc s_114_16 -> u8
        let s_114_17: bool = ((s_114_16) != 0);
        // D s_114_18: cast zx s_114_17 -> bv
        let s_114_18: Bits = Bits::new(s_114_17 as u128, 1u16);
        // C s_114_19: const #1u : u8
        let s_114_19: bool = true;
        // C s_114_20: cast zx s_114_19 -> bv
        let s_114_20: Bits = Bits::new(s_114_19 as u128, 1u16);
        // D s_114_21: cmp-ne s_114_18 s_114_20
        let s_114_21: bool = ((s_114_18) != (s_114_20));
        // D s_114_22: write-var gs#404322 <= s_114_21
        fn_state.gs_404322 = s_114_21;
        // N s_114_23: jump b115
        return block_115(state, tracer, fn_state);
    }
    fn block_115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_115_0: read-var gs#404322:u8
        let s_115_0: bool = fn_state.gs_404322;
        // N s_115_1: branch s_115_0 b117 b116
        if s_115_0 {
            return block_117(state, tracer, fn_state);
        } else {
            return block_116(state, tracer, fn_state);
        };
    }
    fn block_116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_116_0: read-var u#32443:u8
        let s_116_0: u8 = fn_state.u_32443;
        // D s_116_1: read-var u#32444:u8
        let s_116_1: u8 = fn_state.u_32444;
        // D s_116_2: call decode_aarch32_instrs_BLX_r_A1enc_A_txt(s_116_0, s_116_1)
        let s_116_2: () = decode_aarch32_instrs_BLX_r_A1enc_A_txt(
            state,
            tracer,
            s_116_0,
            s_116_1,
        );
        // N s_116_3: return
        return;
    }
    fn block_117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_117_0: panic
        panic!("{:?}", ());
        // N s_117_1: return
        return;
    }
    fn block_118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_118_0: const #1u : u8
        let s_118_0: bool = true;
        // D s_118_1: write-var gs#404322 <= s_118_0
        fn_state.gs_404322 = s_118_0;
        // N s_118_2: jump b115
        return block_115(state, tracer, fn_state);
    }
    fn block_119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_119_0: const #1u : u8
        let s_119_0: bool = true;
        // D s_119_1: write-var gs#404319 <= s_119_0
        fn_state.gs_404319 = s_119_0;
        // N s_119_2: jump b113
        return block_113(state, tracer, fn_state);
    }
    fn block_120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_120_0: const #1u : u8
        let s_120_0: bool = true;
        // D s_120_1: write-var gs#404316 <= s_120_0
        fn_state.gs_404316 = s_120_0;
        // N s_120_2: jump b111
        return block_111(state, tracer, fn_state);
    }
    fn block_121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_121_0: const #1u : u8
        let s_121_0: bool = true;
        // D s_121_1: write-var gs#404313 <= s_121_0
        fn_state.gs_404313 = s_121_0;
        // N s_121_2: jump b109
        return block_109(state, tracer, fn_state);
    }
    fn block_122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_122_0: const #1u : u8
        let s_122_0: bool = true;
        // D s_122_1: write-var gs#404310 <= s_122_0
        fn_state.gs_404310 = s_122_0;
        // N s_122_2: jump b107
        return block_107(state, tracer, fn_state);
    }
    fn block_123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_123_0: const #1u : u8
        let s_123_0: bool = true;
        // D s_123_1: write-var gs#404307 <= s_123_0
        fn_state.gs_404307 = s_123_0;
        // N s_123_2: jump b105
        return block_105(state, tracer, fn_state);
    }
    fn block_124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_124_0: const #1u : u8
        let s_124_0: bool = true;
        // D s_124_1: write-var gs#404304 <= s_124_0
        fn_state.gs_404304 = s_124_0;
        // N s_124_2: jump b103
        return block_103(state, tracer, fn_state);
    }
    fn block_125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_125_0: const #1u : u8
        let s_125_0: bool = true;
        // D s_125_1: write-var gs#404301 <= s_125_0
        fn_state.gs_404301 = s_125_0;
        // N s_125_2: jump b101
        return block_101(state, tracer, fn_state);
    }
    fn block_126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_126_0: const #1u : u8
        let s_126_0: bool = true;
        // D s_126_1: write-var gs#404298 <= s_126_0
        fn_state.gs_404298 = s_126_0;
        // N s_126_2: jump b99
        return block_99(state, tracer, fn_state);
    }
    fn block_127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_127_0: const #1u : u8
        let s_127_0: bool = true;
        // D s_127_1: write-var gs#404295 <= s_127_0
        fn_state.gs_404295 = s_127_0;
        // N s_127_2: jump b97
        return block_97(state, tracer, fn_state);
    }
    fn block_128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_128_0: const #1u : u8
        let s_128_0: bool = true;
        // D s_128_1: write-var gs#404292 <= s_128_0
        fn_state.gs_404292 = s_128_0;
        // N s_128_2: jump b95
        return block_95(state, tracer, fn_state);
    }
    fn block_129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_129_0: read-var merge#var.1:struct
        let s_129_0: u32 = fn_state.merge_var._1;
        // D s_129_1: write-var u#32446 <= s_129_0
        fn_state.u_32446 = s_129_0;
        // C s_129_2: const #4s : i
        let s_129_2: i128 = 4;
        // D s_129_3: read-var u#32446:u32
        let s_129_3: u32 = fn_state.u_32446;
        // D s_129_4: cast zx s_129_3 -> bv
        let s_129_4: Bits = Bits::new(s_129_3 as u128, 32u16);
        // C s_129_5: const #1s : i64
        let s_129_5: i64 = 1;
        // C s_129_6: cast zx s_129_5 -> i
        let s_129_6: i128 = (i128::try_from(s_129_5).unwrap());
        // C s_129_7: const #23s : i
        let s_129_7: i128 = 23;
        // C s_129_8: add s_129_7 s_129_6
        let s_129_8: i128 = (s_129_7 + s_129_6);
        // D s_129_9: bit-extract s_129_4 s_129_2 s_129_8
        let s_129_9: Bits = (Bits::new(
            ((s_129_4) >> (s_129_2)).value(),
            u16::try_from(s_129_8).unwrap(),
        ));
        // D s_129_10: cast reint s_129_9 -> u24
        let s_129_10: u32 = (s_129_9.value() as u32);
        // D s_129_11: cast zx s_129_10 -> bv
        let s_129_11: Bits = Bits::new(s_129_10 as u128, 24u16);
        // C s_129_12: const #1245169u : u24
        let s_129_12: u32 = 1245169;
        // C s_129_13: cast zx s_129_12 -> bv
        let s_129_13: Bits = Bits::new(s_129_12 as u128, 24u16);
        // D s_129_14: cmp-eq s_129_11 s_129_13
        let s_129_14: bool = ((s_129_11) == (s_129_13));
        // N s_129_15: branch s_129_14 b2898 b130
        if s_129_14 {
            return block_2898(state, tracer, fn_state);
        } else {
            return block_130(state, tracer, fn_state);
        };
    }
    fn block_130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_130_0: const #0u : u8
        let s_130_0: bool = false;
        // D s_130_1: write-var gs#404330 <= s_130_0
        fn_state.gs_404330 = s_130_0;
        // N s_130_2: jump b131
        return block_131(state, tracer, fn_state);
    }
    fn block_131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_131_0: read-var gs#404330:u8
        let s_131_0: bool = fn_state.gs_404330;
        // D s_131_1: not s_131_0
        let s_131_1: bool = !s_131_0;
        // N s_131_2: branch s_131_1 b168 b132
        if s_131_1 {
            return block_168(state, tracer, fn_state);
        } else {
            return block_132(state, tracer, fn_state);
        };
    }
    fn block_132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_132_0: const #2874s : i
        let s_132_0: i128 = 2874;
        // C s_132_1: const #14696u : u32
        let s_132_1: u32 = 14696;
        // N s_132_2: write-reg s_132_1 <= s_132_0
        let s_132_2: () = {
            state.write_register::<i128>(s_132_1 as isize, s_132_0);
            tracer.write_register(s_132_1 as isize, s_132_0);
        };
        // C s_132_3: const #28s : i
        let s_132_3: i128 = 28;
        // C s_132_4: const #4s : i
        let s_132_4: i128 = 4;
        // D s_132_5: read-var u#32446:u32
        let s_132_5: u32 = fn_state.u_32446;
        // D s_132_6: cast zx s_132_5 -> bv
        let s_132_6: Bits = Bits::new(s_132_5 as u128, 32u16);
        // D s_132_7: bit-extract s_132_6 s_132_3 s_132_4
        let s_132_7: Bits = (Bits::new(
            ((s_132_6) >> (s_132_3)).value(),
            u16::try_from(s_132_4).unwrap(),
        ));
        // D s_132_8: cast reint s_132_7 -> u8
        let s_132_8: u8 = (s_132_7.value() as u8);
        // D s_132_9: write-var u#32447 <= s_132_8
        fn_state.u_32447 = s_132_8;
        // C s_132_10: const #0s : i
        let s_132_10: i128 = 0;
        // C s_132_11: const #4s : i
        let s_132_11: i128 = 4;
        // D s_132_12: read-var u#32446:u32
        let s_132_12: u32 = fn_state.u_32446;
        // D s_132_13: cast zx s_132_12 -> bv
        let s_132_13: Bits = Bits::new(s_132_12 as u128, 32u16);
        // D s_132_14: bit-extract s_132_13 s_132_10 s_132_11
        let s_132_14: Bits = (Bits::new(
            ((s_132_13) >> (s_132_10)).value(),
            u16::try_from(s_132_11).unwrap(),
        ));
        // D s_132_15: cast reint s_132_14 -> u8
        let s_132_15: u8 = (s_132_14.value() as u8);
        // D s_132_16: write-var u#32448 <= s_132_15
        fn_state.u_32448 = s_132_15;
        // C s_132_17: const #16s : i
        let s_132_17: i128 = 16;
        // D s_132_18: read-var u#32446:u32
        let s_132_18: u32 = fn_state.u_32446;
        // D s_132_19: cast zx s_132_18 -> bv
        let s_132_19: Bits = Bits::new(s_132_18 as u128, 32u16);
        // C s_132_20: const #1u : u64
        let s_132_20: u64 = 1;
        // D s_132_21: bit-extract s_132_19 s_132_17 s_132_20
        let s_132_21: Bits = (Bits::new(
            ((s_132_19) >> (s_132_17)).value(),
            u16::try_from(s_132_20).unwrap(),
        ));
        // D s_132_22: cast reint s_132_21 -> u8
        let s_132_22: bool = ((s_132_21.value()) != 0);
        // C s_132_23: const #0s : i
        let s_132_23: i128 = 0;
        // C s_132_24: const #0u : u64
        let s_132_24: u64 = 0;
        // D s_132_25: cast zx s_132_22 -> u64
        let s_132_25: u64 = (s_132_22 as u64);
        // C s_132_26: const #1u : u64
        let s_132_26: u64 = 1;
        // D s_132_27: and s_132_25 s_132_26
        let s_132_27: u64 = ((s_132_25) & (s_132_26));
        // D s_132_28: cmp-eq s_132_27 s_132_26
        let s_132_28: bool = ((s_132_27) == (s_132_26));
        // D s_132_29: lsl s_132_25 s_132_23
        let s_132_29: u64 = s_132_25 << s_132_23;
        // D s_132_30: or s_132_24 s_132_29
        let s_132_30: u64 = ((s_132_24) | (s_132_29));
        // D s_132_31: cmpl s_132_29
        let s_132_31: u64 = !s_132_29;
        // D s_132_32: and s_132_24 s_132_31
        let s_132_32: u64 = ((s_132_24) & (s_132_31));
        // D s_132_33: select s_132_28 s_132_30 s_132_32
        let s_132_33: u64 = if s_132_28 { s_132_30 } else { s_132_32 };
        // D s_132_34: cast trunc s_132_33 -> u8
        let s_132_34: bool = ((s_132_33) != 0);
        // D s_132_35: cast zx s_132_34 -> bv
        let s_132_35: Bits = Bits::new(s_132_34 as u128, 1u16);
        // C s_132_36: const #1u : u8
        let s_132_36: bool = true;
        // C s_132_37: cast zx s_132_36 -> bv
        let s_132_37: Bits = Bits::new(s_132_36 as u128, 1u16);
        // D s_132_38: cmp-ne s_132_35 s_132_37
        let s_132_38: bool = ((s_132_35) != (s_132_37));
        // N s_132_39: branch s_132_38 b167 b133
        if s_132_38 {
            return block_167(state, tracer, fn_state);
        } else {
            return block_133(state, tracer, fn_state);
        };
    }
    fn block_133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_133_0: const #17s : i
        let s_133_0: i128 = 17;
        // D s_133_1: read-var u#32446:u32
        let s_133_1: u32 = fn_state.u_32446;
        // D s_133_2: cast zx s_133_1 -> bv
        let s_133_2: Bits = Bits::new(s_133_1 as u128, 32u16);
        // C s_133_3: const #1u : u64
        let s_133_3: u64 = 1;
        // D s_133_4: bit-extract s_133_2 s_133_0 s_133_3
        let s_133_4: Bits = (Bits::new(
            ((s_133_2) >> (s_133_0)).value(),
            u16::try_from(s_133_3).unwrap(),
        ));
        // D s_133_5: cast reint s_133_4 -> u8
        let s_133_5: bool = ((s_133_4.value()) != 0);
        // C s_133_6: const #0s : i
        let s_133_6: i128 = 0;
        // C s_133_7: const #0u : u64
        let s_133_7: u64 = 0;
        // D s_133_8: cast zx s_133_5 -> u64
        let s_133_8: u64 = (s_133_5 as u64);
        // C s_133_9: const #1u : u64
        let s_133_9: u64 = 1;
        // D s_133_10: and s_133_8 s_133_9
        let s_133_10: u64 = ((s_133_8) & (s_133_9));
        // D s_133_11: cmp-eq s_133_10 s_133_9
        let s_133_11: bool = ((s_133_10) == (s_133_9));
        // D s_133_12: lsl s_133_8 s_133_6
        let s_133_12: u64 = s_133_8 << s_133_6;
        // D s_133_13: or s_133_7 s_133_12
        let s_133_13: u64 = ((s_133_7) | (s_133_12));
        // D s_133_14: cmpl s_133_12
        let s_133_14: u64 = !s_133_12;
        // D s_133_15: and s_133_7 s_133_14
        let s_133_15: u64 = ((s_133_7) & (s_133_14));
        // D s_133_16: select s_133_11 s_133_13 s_133_15
        let s_133_16: u64 = if s_133_11 { s_133_13 } else { s_133_15 };
        // D s_133_17: cast trunc s_133_16 -> u8
        let s_133_17: bool = ((s_133_16) != 0);
        // D s_133_18: cast zx s_133_17 -> bv
        let s_133_18: Bits = Bits::new(s_133_17 as u128, 1u16);
        // C s_133_19: const #1u : u8
        let s_133_19: bool = true;
        // C s_133_20: cast zx s_133_19 -> bv
        let s_133_20: Bits = Bits::new(s_133_19 as u128, 1u16);
        // D s_133_21: cmp-ne s_133_18 s_133_20
        let s_133_21: bool = ((s_133_18) != (s_133_20));
        // D s_133_22: write-var gs#404341 <= s_133_21
        fn_state.gs_404341 = s_133_21;
        // N s_133_23: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_134_0: read-var gs#404341:u8
        let s_134_0: bool = fn_state.gs_404341;
        // N s_134_1: branch s_134_0 b166 b135
        if s_134_0 {
            return block_166(state, tracer, fn_state);
        } else {
            return block_135(state, tracer, fn_state);
        };
    }
    fn block_135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_135_0: const #18s : i
        let s_135_0: i128 = 18;
        // D s_135_1: read-var u#32446:u32
        let s_135_1: u32 = fn_state.u_32446;
        // D s_135_2: cast zx s_135_1 -> bv
        let s_135_2: Bits = Bits::new(s_135_1 as u128, 32u16);
        // C s_135_3: const #1u : u64
        let s_135_3: u64 = 1;
        // D s_135_4: bit-extract s_135_2 s_135_0 s_135_3
        let s_135_4: Bits = (Bits::new(
            ((s_135_2) >> (s_135_0)).value(),
            u16::try_from(s_135_3).unwrap(),
        ));
        // D s_135_5: cast reint s_135_4 -> u8
        let s_135_5: bool = ((s_135_4.value()) != 0);
        // C s_135_6: const #0s : i
        let s_135_6: i128 = 0;
        // C s_135_7: const #0u : u64
        let s_135_7: u64 = 0;
        // D s_135_8: cast zx s_135_5 -> u64
        let s_135_8: u64 = (s_135_5 as u64);
        // C s_135_9: const #1u : u64
        let s_135_9: u64 = 1;
        // D s_135_10: and s_135_8 s_135_9
        let s_135_10: u64 = ((s_135_8) & (s_135_9));
        // D s_135_11: cmp-eq s_135_10 s_135_9
        let s_135_11: bool = ((s_135_10) == (s_135_9));
        // D s_135_12: lsl s_135_8 s_135_6
        let s_135_12: u64 = s_135_8 << s_135_6;
        // D s_135_13: or s_135_7 s_135_12
        let s_135_13: u64 = ((s_135_7) | (s_135_12));
        // D s_135_14: cmpl s_135_12
        let s_135_14: u64 = !s_135_12;
        // D s_135_15: and s_135_7 s_135_14
        let s_135_15: u64 = ((s_135_7) & (s_135_14));
        // D s_135_16: select s_135_11 s_135_13 s_135_15
        let s_135_16: u64 = if s_135_11 { s_135_13 } else { s_135_15 };
        // D s_135_17: cast trunc s_135_16 -> u8
        let s_135_17: bool = ((s_135_16) != 0);
        // D s_135_18: cast zx s_135_17 -> bv
        let s_135_18: Bits = Bits::new(s_135_17 as u128, 1u16);
        // C s_135_19: const #1u : u8
        let s_135_19: bool = true;
        // C s_135_20: cast zx s_135_19 -> bv
        let s_135_20: Bits = Bits::new(s_135_19 as u128, 1u16);
        // D s_135_21: cmp-ne s_135_18 s_135_20
        let s_135_21: bool = ((s_135_18) != (s_135_20));
        // D s_135_22: write-var gs#404344 <= s_135_21
        fn_state.gs_404344 = s_135_21;
        // N s_135_23: jump b136
        return block_136(state, tracer, fn_state);
    }
    fn block_136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_136_0: read-var gs#404344:u8
        let s_136_0: bool = fn_state.gs_404344;
        // N s_136_1: branch s_136_0 b165 b137
        if s_136_0 {
            return block_165(state, tracer, fn_state);
        } else {
            return block_137(state, tracer, fn_state);
        };
    }
    fn block_137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_137_0: const #19s : i
        let s_137_0: i128 = 19;
        // D s_137_1: read-var u#32446:u32
        let s_137_1: u32 = fn_state.u_32446;
        // D s_137_2: cast zx s_137_1 -> bv
        let s_137_2: Bits = Bits::new(s_137_1 as u128, 32u16);
        // C s_137_3: const #1u : u64
        let s_137_3: u64 = 1;
        // D s_137_4: bit-extract s_137_2 s_137_0 s_137_3
        let s_137_4: Bits = (Bits::new(
            ((s_137_2) >> (s_137_0)).value(),
            u16::try_from(s_137_3).unwrap(),
        ));
        // D s_137_5: cast reint s_137_4 -> u8
        let s_137_5: bool = ((s_137_4.value()) != 0);
        // C s_137_6: const #0s : i
        let s_137_6: i128 = 0;
        // C s_137_7: const #0u : u64
        let s_137_7: u64 = 0;
        // D s_137_8: cast zx s_137_5 -> u64
        let s_137_8: u64 = (s_137_5 as u64);
        // C s_137_9: const #1u : u64
        let s_137_9: u64 = 1;
        // D s_137_10: and s_137_8 s_137_9
        let s_137_10: u64 = ((s_137_8) & (s_137_9));
        // D s_137_11: cmp-eq s_137_10 s_137_9
        let s_137_11: bool = ((s_137_10) == (s_137_9));
        // D s_137_12: lsl s_137_8 s_137_6
        let s_137_12: u64 = s_137_8 << s_137_6;
        // D s_137_13: or s_137_7 s_137_12
        let s_137_13: u64 = ((s_137_7) | (s_137_12));
        // D s_137_14: cmpl s_137_12
        let s_137_14: u64 = !s_137_12;
        // D s_137_15: and s_137_7 s_137_14
        let s_137_15: u64 = ((s_137_7) & (s_137_14));
        // D s_137_16: select s_137_11 s_137_13 s_137_15
        let s_137_16: u64 = if s_137_11 { s_137_13 } else { s_137_15 };
        // D s_137_17: cast trunc s_137_16 -> u8
        let s_137_17: bool = ((s_137_16) != 0);
        // D s_137_18: cast zx s_137_17 -> bv
        let s_137_18: Bits = Bits::new(s_137_17 as u128, 1u16);
        // C s_137_19: const #1u : u8
        let s_137_19: bool = true;
        // C s_137_20: cast zx s_137_19 -> bv
        let s_137_20: Bits = Bits::new(s_137_19 as u128, 1u16);
        // D s_137_21: cmp-ne s_137_18 s_137_20
        let s_137_21: bool = ((s_137_18) != (s_137_20));
        // D s_137_22: write-var gs#404347 <= s_137_21
        fn_state.gs_404347 = s_137_21;
        // N s_137_23: jump b138
        return block_138(state, tracer, fn_state);
    }
    fn block_138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_138_0: read-var gs#404347:u8
        let s_138_0: bool = fn_state.gs_404347;
        // N s_138_1: branch s_138_0 b164 b139
        if s_138_0 {
            return block_164(state, tracer, fn_state);
        } else {
            return block_139(state, tracer, fn_state);
        };
    }
    fn block_139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_139_0: const #12s : i
        let s_139_0: i128 = 12;
        // D s_139_1: read-var u#32446:u32
        let s_139_1: u32 = fn_state.u_32446;
        // D s_139_2: cast zx s_139_1 -> bv
        let s_139_2: Bits = Bits::new(s_139_1 as u128, 32u16);
        // C s_139_3: const #1u : u64
        let s_139_3: u64 = 1;
        // D s_139_4: bit-extract s_139_2 s_139_0 s_139_3
        let s_139_4: Bits = (Bits::new(
            ((s_139_2) >> (s_139_0)).value(),
            u16::try_from(s_139_3).unwrap(),
        ));
        // D s_139_5: cast reint s_139_4 -> u8
        let s_139_5: bool = ((s_139_4.value()) != 0);
        // C s_139_6: const #0s : i
        let s_139_6: i128 = 0;
        // C s_139_7: const #0u : u64
        let s_139_7: u64 = 0;
        // D s_139_8: cast zx s_139_5 -> u64
        let s_139_8: u64 = (s_139_5 as u64);
        // C s_139_9: const #1u : u64
        let s_139_9: u64 = 1;
        // D s_139_10: and s_139_8 s_139_9
        let s_139_10: u64 = ((s_139_8) & (s_139_9));
        // D s_139_11: cmp-eq s_139_10 s_139_9
        let s_139_11: bool = ((s_139_10) == (s_139_9));
        // D s_139_12: lsl s_139_8 s_139_6
        let s_139_12: u64 = s_139_8 << s_139_6;
        // D s_139_13: or s_139_7 s_139_12
        let s_139_13: u64 = ((s_139_7) | (s_139_12));
        // D s_139_14: cmpl s_139_12
        let s_139_14: u64 = !s_139_12;
        // D s_139_15: and s_139_7 s_139_14
        let s_139_15: u64 = ((s_139_7) & (s_139_14));
        // D s_139_16: select s_139_11 s_139_13 s_139_15
        let s_139_16: u64 = if s_139_11 { s_139_13 } else { s_139_15 };
        // D s_139_17: cast trunc s_139_16 -> u8
        let s_139_17: bool = ((s_139_16) != 0);
        // D s_139_18: cast zx s_139_17 -> bv
        let s_139_18: Bits = Bits::new(s_139_17 as u128, 1u16);
        // C s_139_19: const #1u : u8
        let s_139_19: bool = true;
        // C s_139_20: cast zx s_139_19 -> bv
        let s_139_20: Bits = Bits::new(s_139_19 as u128, 1u16);
        // D s_139_21: cmp-ne s_139_18 s_139_20
        let s_139_21: bool = ((s_139_18) != (s_139_20));
        // D s_139_22: write-var gs#404350 <= s_139_21
        fn_state.gs_404350 = s_139_21;
        // N s_139_23: jump b140
        return block_140(state, tracer, fn_state);
    }
    fn block_140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_140_0: read-var gs#404350:u8
        let s_140_0: bool = fn_state.gs_404350;
        // N s_140_1: branch s_140_0 b163 b141
        if s_140_0 {
            return block_163(state, tracer, fn_state);
        } else {
            return block_141(state, tracer, fn_state);
        };
    }
    fn block_141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_141_0: const #13s : i
        let s_141_0: i128 = 13;
        // D s_141_1: read-var u#32446:u32
        let s_141_1: u32 = fn_state.u_32446;
        // D s_141_2: cast zx s_141_1 -> bv
        let s_141_2: Bits = Bits::new(s_141_1 as u128, 32u16);
        // C s_141_3: const #1u : u64
        let s_141_3: u64 = 1;
        // D s_141_4: bit-extract s_141_2 s_141_0 s_141_3
        let s_141_4: Bits = (Bits::new(
            ((s_141_2) >> (s_141_0)).value(),
            u16::try_from(s_141_3).unwrap(),
        ));
        // D s_141_5: cast reint s_141_4 -> u8
        let s_141_5: bool = ((s_141_4.value()) != 0);
        // C s_141_6: const #0s : i
        let s_141_6: i128 = 0;
        // C s_141_7: const #0u : u64
        let s_141_7: u64 = 0;
        // D s_141_8: cast zx s_141_5 -> u64
        let s_141_8: u64 = (s_141_5 as u64);
        // C s_141_9: const #1u : u64
        let s_141_9: u64 = 1;
        // D s_141_10: and s_141_8 s_141_9
        let s_141_10: u64 = ((s_141_8) & (s_141_9));
        // D s_141_11: cmp-eq s_141_10 s_141_9
        let s_141_11: bool = ((s_141_10) == (s_141_9));
        // D s_141_12: lsl s_141_8 s_141_6
        let s_141_12: u64 = s_141_8 << s_141_6;
        // D s_141_13: or s_141_7 s_141_12
        let s_141_13: u64 = ((s_141_7) | (s_141_12));
        // D s_141_14: cmpl s_141_12
        let s_141_14: u64 = !s_141_12;
        // D s_141_15: and s_141_7 s_141_14
        let s_141_15: u64 = ((s_141_7) & (s_141_14));
        // D s_141_16: select s_141_11 s_141_13 s_141_15
        let s_141_16: u64 = if s_141_11 { s_141_13 } else { s_141_15 };
        // D s_141_17: cast trunc s_141_16 -> u8
        let s_141_17: bool = ((s_141_16) != 0);
        // D s_141_18: cast zx s_141_17 -> bv
        let s_141_18: Bits = Bits::new(s_141_17 as u128, 1u16);
        // C s_141_19: const #1u : u8
        let s_141_19: bool = true;
        // C s_141_20: cast zx s_141_19 -> bv
        let s_141_20: Bits = Bits::new(s_141_19 as u128, 1u16);
        // D s_141_21: cmp-ne s_141_18 s_141_20
        let s_141_21: bool = ((s_141_18) != (s_141_20));
        // D s_141_22: write-var gs#404353 <= s_141_21
        fn_state.gs_404353 = s_141_21;
        // N s_141_23: jump b142
        return block_142(state, tracer, fn_state);
    }
    fn block_142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_142_0: read-var gs#404353:u8
        let s_142_0: bool = fn_state.gs_404353;
        // N s_142_1: branch s_142_0 b162 b143
        if s_142_0 {
            return block_162(state, tracer, fn_state);
        } else {
            return block_143(state, tracer, fn_state);
        };
    }
    fn block_143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_143_0: const #14s : i
        let s_143_0: i128 = 14;
        // D s_143_1: read-var u#32446:u32
        let s_143_1: u32 = fn_state.u_32446;
        // D s_143_2: cast zx s_143_1 -> bv
        let s_143_2: Bits = Bits::new(s_143_1 as u128, 32u16);
        // C s_143_3: const #1u : u64
        let s_143_3: u64 = 1;
        // D s_143_4: bit-extract s_143_2 s_143_0 s_143_3
        let s_143_4: Bits = (Bits::new(
            ((s_143_2) >> (s_143_0)).value(),
            u16::try_from(s_143_3).unwrap(),
        ));
        // D s_143_5: cast reint s_143_4 -> u8
        let s_143_5: bool = ((s_143_4.value()) != 0);
        // C s_143_6: const #0s : i
        let s_143_6: i128 = 0;
        // C s_143_7: const #0u : u64
        let s_143_7: u64 = 0;
        // D s_143_8: cast zx s_143_5 -> u64
        let s_143_8: u64 = (s_143_5 as u64);
        // C s_143_9: const #1u : u64
        let s_143_9: u64 = 1;
        // D s_143_10: and s_143_8 s_143_9
        let s_143_10: u64 = ((s_143_8) & (s_143_9));
        // D s_143_11: cmp-eq s_143_10 s_143_9
        let s_143_11: bool = ((s_143_10) == (s_143_9));
        // D s_143_12: lsl s_143_8 s_143_6
        let s_143_12: u64 = s_143_8 << s_143_6;
        // D s_143_13: or s_143_7 s_143_12
        let s_143_13: u64 = ((s_143_7) | (s_143_12));
        // D s_143_14: cmpl s_143_12
        let s_143_14: u64 = !s_143_12;
        // D s_143_15: and s_143_7 s_143_14
        let s_143_15: u64 = ((s_143_7) & (s_143_14));
        // D s_143_16: select s_143_11 s_143_13 s_143_15
        let s_143_16: u64 = if s_143_11 { s_143_13 } else { s_143_15 };
        // D s_143_17: cast trunc s_143_16 -> u8
        let s_143_17: bool = ((s_143_16) != 0);
        // D s_143_18: cast zx s_143_17 -> bv
        let s_143_18: Bits = Bits::new(s_143_17 as u128, 1u16);
        // C s_143_19: const #1u : u8
        let s_143_19: bool = true;
        // C s_143_20: cast zx s_143_19 -> bv
        let s_143_20: Bits = Bits::new(s_143_19 as u128, 1u16);
        // D s_143_21: cmp-ne s_143_18 s_143_20
        let s_143_21: bool = ((s_143_18) != (s_143_20));
        // D s_143_22: write-var gs#404356 <= s_143_21
        fn_state.gs_404356 = s_143_21;
        // N s_143_23: jump b144
        return block_144(state, tracer, fn_state);
    }
    fn block_144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_144_0: read-var gs#404356:u8
        let s_144_0: bool = fn_state.gs_404356;
        // N s_144_1: branch s_144_0 b161 b145
        if s_144_0 {
            return block_161(state, tracer, fn_state);
        } else {
            return block_145(state, tracer, fn_state);
        };
    }
    fn block_145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_145_0: const #15s : i
        let s_145_0: i128 = 15;
        // D s_145_1: read-var u#32446:u32
        let s_145_1: u32 = fn_state.u_32446;
        // D s_145_2: cast zx s_145_1 -> bv
        let s_145_2: Bits = Bits::new(s_145_1 as u128, 32u16);
        // C s_145_3: const #1u : u64
        let s_145_3: u64 = 1;
        // D s_145_4: bit-extract s_145_2 s_145_0 s_145_3
        let s_145_4: Bits = (Bits::new(
            ((s_145_2) >> (s_145_0)).value(),
            u16::try_from(s_145_3).unwrap(),
        ));
        // D s_145_5: cast reint s_145_4 -> u8
        let s_145_5: bool = ((s_145_4.value()) != 0);
        // C s_145_6: const #0s : i
        let s_145_6: i128 = 0;
        // C s_145_7: const #0u : u64
        let s_145_7: u64 = 0;
        // D s_145_8: cast zx s_145_5 -> u64
        let s_145_8: u64 = (s_145_5 as u64);
        // C s_145_9: const #1u : u64
        let s_145_9: u64 = 1;
        // D s_145_10: and s_145_8 s_145_9
        let s_145_10: u64 = ((s_145_8) & (s_145_9));
        // D s_145_11: cmp-eq s_145_10 s_145_9
        let s_145_11: bool = ((s_145_10) == (s_145_9));
        // D s_145_12: lsl s_145_8 s_145_6
        let s_145_12: u64 = s_145_8 << s_145_6;
        // D s_145_13: or s_145_7 s_145_12
        let s_145_13: u64 = ((s_145_7) | (s_145_12));
        // D s_145_14: cmpl s_145_12
        let s_145_14: u64 = !s_145_12;
        // D s_145_15: and s_145_7 s_145_14
        let s_145_15: u64 = ((s_145_7) & (s_145_14));
        // D s_145_16: select s_145_11 s_145_13 s_145_15
        let s_145_16: u64 = if s_145_11 { s_145_13 } else { s_145_15 };
        // D s_145_17: cast trunc s_145_16 -> u8
        let s_145_17: bool = ((s_145_16) != 0);
        // D s_145_18: cast zx s_145_17 -> bv
        let s_145_18: Bits = Bits::new(s_145_17 as u128, 1u16);
        // C s_145_19: const #1u : u8
        let s_145_19: bool = true;
        // C s_145_20: cast zx s_145_19 -> bv
        let s_145_20: Bits = Bits::new(s_145_19 as u128, 1u16);
        // D s_145_21: cmp-ne s_145_18 s_145_20
        let s_145_21: bool = ((s_145_18) != (s_145_20));
        // D s_145_22: write-var gs#404359 <= s_145_21
        fn_state.gs_404359 = s_145_21;
        // N s_145_23: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_146_0: read-var gs#404359:u8
        let s_146_0: bool = fn_state.gs_404359;
        // N s_146_1: branch s_146_0 b160 b147
        if s_146_0 {
            return block_160(state, tracer, fn_state);
        } else {
            return block_147(state, tracer, fn_state);
        };
    }
    fn block_147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_147_0: const #8s : i
        let s_147_0: i128 = 8;
        // D s_147_1: read-var u#32446:u32
        let s_147_1: u32 = fn_state.u_32446;
        // D s_147_2: cast zx s_147_1 -> bv
        let s_147_2: Bits = Bits::new(s_147_1 as u128, 32u16);
        // C s_147_3: const #1u : u64
        let s_147_3: u64 = 1;
        // D s_147_4: bit-extract s_147_2 s_147_0 s_147_3
        let s_147_4: Bits = (Bits::new(
            ((s_147_2) >> (s_147_0)).value(),
            u16::try_from(s_147_3).unwrap(),
        ));
        // D s_147_5: cast reint s_147_4 -> u8
        let s_147_5: bool = ((s_147_4.value()) != 0);
        // C s_147_6: const #0s : i
        let s_147_6: i128 = 0;
        // C s_147_7: const #0u : u64
        let s_147_7: u64 = 0;
        // D s_147_8: cast zx s_147_5 -> u64
        let s_147_8: u64 = (s_147_5 as u64);
        // C s_147_9: const #1u : u64
        let s_147_9: u64 = 1;
        // D s_147_10: and s_147_8 s_147_9
        let s_147_10: u64 = ((s_147_8) & (s_147_9));
        // D s_147_11: cmp-eq s_147_10 s_147_9
        let s_147_11: bool = ((s_147_10) == (s_147_9));
        // D s_147_12: lsl s_147_8 s_147_6
        let s_147_12: u64 = s_147_8 << s_147_6;
        // D s_147_13: or s_147_7 s_147_12
        let s_147_13: u64 = ((s_147_7) | (s_147_12));
        // D s_147_14: cmpl s_147_12
        let s_147_14: u64 = !s_147_12;
        // D s_147_15: and s_147_7 s_147_14
        let s_147_15: u64 = ((s_147_7) & (s_147_14));
        // D s_147_16: select s_147_11 s_147_13 s_147_15
        let s_147_16: u64 = if s_147_11 { s_147_13 } else { s_147_15 };
        // D s_147_17: cast trunc s_147_16 -> u8
        let s_147_17: bool = ((s_147_16) != 0);
        // D s_147_18: cast zx s_147_17 -> bv
        let s_147_18: Bits = Bits::new(s_147_17 as u128, 1u16);
        // C s_147_19: const #1u : u8
        let s_147_19: bool = true;
        // C s_147_20: cast zx s_147_19 -> bv
        let s_147_20: Bits = Bits::new(s_147_19 as u128, 1u16);
        // D s_147_21: cmp-ne s_147_18 s_147_20
        let s_147_21: bool = ((s_147_18) != (s_147_20));
        // D s_147_22: write-var gs#404362 <= s_147_21
        fn_state.gs_404362 = s_147_21;
        // N s_147_23: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_148_0: read-var gs#404362:u8
        let s_148_0: bool = fn_state.gs_404362;
        // N s_148_1: branch s_148_0 b159 b149
        if s_148_0 {
            return block_159(state, tracer, fn_state);
        } else {
            return block_149(state, tracer, fn_state);
        };
    }
    fn block_149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_149_0: const #9s : i
        let s_149_0: i128 = 9;
        // D s_149_1: read-var u#32446:u32
        let s_149_1: u32 = fn_state.u_32446;
        // D s_149_2: cast zx s_149_1 -> bv
        let s_149_2: Bits = Bits::new(s_149_1 as u128, 32u16);
        // C s_149_3: const #1u : u64
        let s_149_3: u64 = 1;
        // D s_149_4: bit-extract s_149_2 s_149_0 s_149_3
        let s_149_4: Bits = (Bits::new(
            ((s_149_2) >> (s_149_0)).value(),
            u16::try_from(s_149_3).unwrap(),
        ));
        // D s_149_5: cast reint s_149_4 -> u8
        let s_149_5: bool = ((s_149_4.value()) != 0);
        // C s_149_6: const #0s : i
        let s_149_6: i128 = 0;
        // C s_149_7: const #0u : u64
        let s_149_7: u64 = 0;
        // D s_149_8: cast zx s_149_5 -> u64
        let s_149_8: u64 = (s_149_5 as u64);
        // C s_149_9: const #1u : u64
        let s_149_9: u64 = 1;
        // D s_149_10: and s_149_8 s_149_9
        let s_149_10: u64 = ((s_149_8) & (s_149_9));
        // D s_149_11: cmp-eq s_149_10 s_149_9
        let s_149_11: bool = ((s_149_10) == (s_149_9));
        // D s_149_12: lsl s_149_8 s_149_6
        let s_149_12: u64 = s_149_8 << s_149_6;
        // D s_149_13: or s_149_7 s_149_12
        let s_149_13: u64 = ((s_149_7) | (s_149_12));
        // D s_149_14: cmpl s_149_12
        let s_149_14: u64 = !s_149_12;
        // D s_149_15: and s_149_7 s_149_14
        let s_149_15: u64 = ((s_149_7) & (s_149_14));
        // D s_149_16: select s_149_11 s_149_13 s_149_15
        let s_149_16: u64 = if s_149_11 { s_149_13 } else { s_149_15 };
        // D s_149_17: cast trunc s_149_16 -> u8
        let s_149_17: bool = ((s_149_16) != 0);
        // D s_149_18: cast zx s_149_17 -> bv
        let s_149_18: Bits = Bits::new(s_149_17 as u128, 1u16);
        // C s_149_19: const #1u : u8
        let s_149_19: bool = true;
        // C s_149_20: cast zx s_149_19 -> bv
        let s_149_20: Bits = Bits::new(s_149_19 as u128, 1u16);
        // D s_149_21: cmp-ne s_149_18 s_149_20
        let s_149_21: bool = ((s_149_18) != (s_149_20));
        // D s_149_22: write-var gs#404365 <= s_149_21
        fn_state.gs_404365 = s_149_21;
        // N s_149_23: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_150_0: read-var gs#404365:u8
        let s_150_0: bool = fn_state.gs_404365;
        // N s_150_1: branch s_150_0 b158 b151
        if s_150_0 {
            return block_158(state, tracer, fn_state);
        } else {
            return block_151(state, tracer, fn_state);
        };
    }
    fn block_151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_151_0: const #10s : i
        let s_151_0: i128 = 10;
        // D s_151_1: read-var u#32446:u32
        let s_151_1: u32 = fn_state.u_32446;
        // D s_151_2: cast zx s_151_1 -> bv
        let s_151_2: Bits = Bits::new(s_151_1 as u128, 32u16);
        // C s_151_3: const #1u : u64
        let s_151_3: u64 = 1;
        // D s_151_4: bit-extract s_151_2 s_151_0 s_151_3
        let s_151_4: Bits = (Bits::new(
            ((s_151_2) >> (s_151_0)).value(),
            u16::try_from(s_151_3).unwrap(),
        ));
        // D s_151_5: cast reint s_151_4 -> u8
        let s_151_5: bool = ((s_151_4.value()) != 0);
        // C s_151_6: const #0s : i
        let s_151_6: i128 = 0;
        // C s_151_7: const #0u : u64
        let s_151_7: u64 = 0;
        // D s_151_8: cast zx s_151_5 -> u64
        let s_151_8: u64 = (s_151_5 as u64);
        // C s_151_9: const #1u : u64
        let s_151_9: u64 = 1;
        // D s_151_10: and s_151_8 s_151_9
        let s_151_10: u64 = ((s_151_8) & (s_151_9));
        // D s_151_11: cmp-eq s_151_10 s_151_9
        let s_151_11: bool = ((s_151_10) == (s_151_9));
        // D s_151_12: lsl s_151_8 s_151_6
        let s_151_12: u64 = s_151_8 << s_151_6;
        // D s_151_13: or s_151_7 s_151_12
        let s_151_13: u64 = ((s_151_7) | (s_151_12));
        // D s_151_14: cmpl s_151_12
        let s_151_14: u64 = !s_151_12;
        // D s_151_15: and s_151_7 s_151_14
        let s_151_15: u64 = ((s_151_7) & (s_151_14));
        // D s_151_16: select s_151_11 s_151_13 s_151_15
        let s_151_16: u64 = if s_151_11 { s_151_13 } else { s_151_15 };
        // D s_151_17: cast trunc s_151_16 -> u8
        let s_151_17: bool = ((s_151_16) != 0);
        // D s_151_18: cast zx s_151_17 -> bv
        let s_151_18: Bits = Bits::new(s_151_17 as u128, 1u16);
        // C s_151_19: const #1u : u8
        let s_151_19: bool = true;
        // C s_151_20: cast zx s_151_19 -> bv
        let s_151_20: Bits = Bits::new(s_151_19 as u128, 1u16);
        // D s_151_21: cmp-ne s_151_18 s_151_20
        let s_151_21: bool = ((s_151_18) != (s_151_20));
        // D s_151_22: write-var gs#404368 <= s_151_21
        fn_state.gs_404368 = s_151_21;
        // N s_151_23: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_152_0: read-var gs#404368:u8
        let s_152_0: bool = fn_state.gs_404368;
        // N s_152_1: branch s_152_0 b157 b153
        if s_152_0 {
            return block_157(state, tracer, fn_state);
        } else {
            return block_153(state, tracer, fn_state);
        };
    }
    fn block_153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_153_0: const #11s : i
        let s_153_0: i128 = 11;
        // D s_153_1: read-var u#32446:u32
        let s_153_1: u32 = fn_state.u_32446;
        // D s_153_2: cast zx s_153_1 -> bv
        let s_153_2: Bits = Bits::new(s_153_1 as u128, 32u16);
        // C s_153_3: const #1u : u64
        let s_153_3: u64 = 1;
        // D s_153_4: bit-extract s_153_2 s_153_0 s_153_3
        let s_153_4: Bits = (Bits::new(
            ((s_153_2) >> (s_153_0)).value(),
            u16::try_from(s_153_3).unwrap(),
        ));
        // D s_153_5: cast reint s_153_4 -> u8
        let s_153_5: bool = ((s_153_4.value()) != 0);
        // C s_153_6: const #0s : i
        let s_153_6: i128 = 0;
        // C s_153_7: const #0u : u64
        let s_153_7: u64 = 0;
        // D s_153_8: cast zx s_153_5 -> u64
        let s_153_8: u64 = (s_153_5 as u64);
        // C s_153_9: const #1u : u64
        let s_153_9: u64 = 1;
        // D s_153_10: and s_153_8 s_153_9
        let s_153_10: u64 = ((s_153_8) & (s_153_9));
        // D s_153_11: cmp-eq s_153_10 s_153_9
        let s_153_11: bool = ((s_153_10) == (s_153_9));
        // D s_153_12: lsl s_153_8 s_153_6
        let s_153_12: u64 = s_153_8 << s_153_6;
        // D s_153_13: or s_153_7 s_153_12
        let s_153_13: u64 = ((s_153_7) | (s_153_12));
        // D s_153_14: cmpl s_153_12
        let s_153_14: u64 = !s_153_12;
        // D s_153_15: and s_153_7 s_153_14
        let s_153_15: u64 = ((s_153_7) & (s_153_14));
        // D s_153_16: select s_153_11 s_153_13 s_153_15
        let s_153_16: u64 = if s_153_11 { s_153_13 } else { s_153_15 };
        // D s_153_17: cast trunc s_153_16 -> u8
        let s_153_17: bool = ((s_153_16) != 0);
        // D s_153_18: cast zx s_153_17 -> bv
        let s_153_18: Bits = Bits::new(s_153_17 as u128, 1u16);
        // C s_153_19: const #1u : u8
        let s_153_19: bool = true;
        // C s_153_20: cast zx s_153_19 -> bv
        let s_153_20: Bits = Bits::new(s_153_19 as u128, 1u16);
        // D s_153_21: cmp-ne s_153_18 s_153_20
        let s_153_21: bool = ((s_153_18) != (s_153_20));
        // D s_153_22: write-var gs#404371 <= s_153_21
        fn_state.gs_404371 = s_153_21;
        // N s_153_23: jump b154
        return block_154(state, tracer, fn_state);
    }
    fn block_154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_154_0: read-var gs#404371:u8
        let s_154_0: bool = fn_state.gs_404371;
        // N s_154_1: branch s_154_0 b156 b155
        if s_154_0 {
            return block_156(state, tracer, fn_state);
        } else {
            return block_155(state, tracer, fn_state);
        };
    }
    fn block_155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_155_0: read-var u#32447:u8
        let s_155_0: u8 = fn_state.u_32447;
        // D s_155_1: read-var u#32448:u8
        let s_155_1: u8 = fn_state.u_32448;
        // D s_155_2: call decode_aarch32_instrs_BX_A1enc_A_txt(s_155_0, s_155_1)
        let s_155_2: () = decode_aarch32_instrs_BX_A1enc_A_txt(
            state,
            tracer,
            s_155_0,
            s_155_1,
        );
        // N s_155_3: return
        return;
    }
    fn block_156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_156_0: panic
        panic!("{:?}", ());
        // N s_156_1: return
        return;
    }
    fn block_157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_157_0: const #1u : u8
        let s_157_0: bool = true;
        // D s_157_1: write-var gs#404371 <= s_157_0
        fn_state.gs_404371 = s_157_0;
        // N s_157_2: jump b154
        return block_154(state, tracer, fn_state);
    }
    fn block_158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_158_0: const #1u : u8
        let s_158_0: bool = true;
        // D s_158_1: write-var gs#404368 <= s_158_0
        fn_state.gs_404368 = s_158_0;
        // N s_158_2: jump b152
        return block_152(state, tracer, fn_state);
    }
    fn block_159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_159_0: const #1u : u8
        let s_159_0: bool = true;
        // D s_159_1: write-var gs#404365 <= s_159_0
        fn_state.gs_404365 = s_159_0;
        // N s_159_2: jump b150
        return block_150(state, tracer, fn_state);
    }
    fn block_160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_160_0: const #1u : u8
        let s_160_0: bool = true;
        // D s_160_1: write-var gs#404362 <= s_160_0
        fn_state.gs_404362 = s_160_0;
        // N s_160_2: jump b148
        return block_148(state, tracer, fn_state);
    }
    fn block_161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_161_0: const #1u : u8
        let s_161_0: bool = true;
        // D s_161_1: write-var gs#404359 <= s_161_0
        fn_state.gs_404359 = s_161_0;
        // N s_161_2: jump b146
        return block_146(state, tracer, fn_state);
    }
    fn block_162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_162_0: const #1u : u8
        let s_162_0: bool = true;
        // D s_162_1: write-var gs#404356 <= s_162_0
        fn_state.gs_404356 = s_162_0;
        // N s_162_2: jump b144
        return block_144(state, tracer, fn_state);
    }
    fn block_163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_163_0: const #1u : u8
        let s_163_0: bool = true;
        // D s_163_1: write-var gs#404353 <= s_163_0
        fn_state.gs_404353 = s_163_0;
        // N s_163_2: jump b142
        return block_142(state, tracer, fn_state);
    }
    fn block_164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_164_0: const #1u : u8
        let s_164_0: bool = true;
        // D s_164_1: write-var gs#404350 <= s_164_0
        fn_state.gs_404350 = s_164_0;
        // N s_164_2: jump b140
        return block_140(state, tracer, fn_state);
    }
    fn block_165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_165_0: const #1u : u8
        let s_165_0: bool = true;
        // D s_165_1: write-var gs#404347 <= s_165_0
        fn_state.gs_404347 = s_165_0;
        // N s_165_2: jump b138
        return block_138(state, tracer, fn_state);
    }
    fn block_166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_166_0: const #1u : u8
        let s_166_0: bool = true;
        // D s_166_1: write-var gs#404344 <= s_166_0
        fn_state.gs_404344 = s_166_0;
        // N s_166_2: jump b136
        return block_136(state, tracer, fn_state);
    }
    fn block_167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_167_0: const #1u : u8
        let s_167_0: bool = true;
        // D s_167_1: write-var gs#404341 <= s_167_0
        fn_state.gs_404341 = s_167_0;
        // N s_167_2: jump b134
        return block_134(state, tracer, fn_state);
    }
    fn block_168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_168_0: read-var merge#var.1:struct
        let s_168_0: u32 = fn_state.merge_var._1;
        // D s_168_1: write-var u#32450 <= s_168_0
        fn_state.u_32450 = s_168_0;
        // C s_168_2: const #4s : i
        let s_168_2: i128 = 4;
        // D s_168_3: read-var u#32450:u32
        let s_168_3: u32 = fn_state.u_32450;
        // D s_168_4: cast zx s_168_3 -> bv
        let s_168_4: Bits = Bits::new(s_168_3 as u128, 32u16);
        // C s_168_5: const #1s : i64
        let s_168_5: i64 = 1;
        // C s_168_6: cast zx s_168_5 -> i
        let s_168_6: i128 = (i128::try_from(s_168_5).unwrap());
        // C s_168_7: const #23s : i
        let s_168_7: i128 = 23;
        // C s_168_8: add s_168_7 s_168_6
        let s_168_8: i128 = (s_168_7 + s_168_6);
        // D s_168_9: bit-extract s_168_4 s_168_2 s_168_8
        let s_168_9: Bits = (Bits::new(
            ((s_168_4) >> (s_168_2)).value(),
            u16::try_from(s_168_8).unwrap(),
        ));
        // D s_168_10: cast reint s_168_9 -> u24
        let s_168_10: u32 = (s_168_9.value() as u32);
        // D s_168_11: cast zx s_168_10 -> bv
        let s_168_11: Bits = Bits::new(s_168_10 as u128, 24u16);
        // C s_168_12: const #1245170u : u24
        let s_168_12: u32 = 1245170;
        // C s_168_13: cast zx s_168_12 -> bv
        let s_168_13: Bits = Bits::new(s_168_12 as u128, 24u16);
        // D s_168_14: cmp-eq s_168_11 s_168_13
        let s_168_14: bool = ((s_168_11) == (s_168_13));
        // N s_168_15: branch s_168_14 b2894 b169
        if s_168_14 {
            return block_2894(state, tracer, fn_state);
        } else {
            return block_169(state, tracer, fn_state);
        };
    }
    fn block_169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_169_0: const #0u : u8
        let s_169_0: bool = false;
        // D s_169_1: write-var gs#404379 <= s_169_0
        fn_state.gs_404379 = s_169_0;
        // N s_169_2: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_170_0: read-var gs#404379:u8
        let s_170_0: bool = fn_state.gs_404379;
        // D s_170_1: not s_170_0
        let s_170_1: bool = !s_170_0;
        // N s_170_2: branch s_170_1 b207 b171
        if s_170_1 {
            return block_207(state, tracer, fn_state);
        } else {
            return block_171(state, tracer, fn_state);
        };
    }
    fn block_171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_171_0: const #2876s : i
        let s_171_0: i128 = 2876;
        // C s_171_1: const #14696u : u32
        let s_171_1: u32 = 14696;
        // N s_171_2: write-reg s_171_1 <= s_171_0
        let s_171_2: () = {
            state.write_register::<i128>(s_171_1 as isize, s_171_0);
            tracer.write_register(s_171_1 as isize, s_171_0);
        };
        // C s_171_3: const #28s : i
        let s_171_3: i128 = 28;
        // C s_171_4: const #4s : i
        let s_171_4: i128 = 4;
        // D s_171_5: read-var u#32450:u32
        let s_171_5: u32 = fn_state.u_32450;
        // D s_171_6: cast zx s_171_5 -> bv
        let s_171_6: Bits = Bits::new(s_171_5 as u128, 32u16);
        // D s_171_7: bit-extract s_171_6 s_171_3 s_171_4
        let s_171_7: Bits = (Bits::new(
            ((s_171_6) >> (s_171_3)).value(),
            u16::try_from(s_171_4).unwrap(),
        ));
        // D s_171_8: cast reint s_171_7 -> u8
        let s_171_8: u8 = (s_171_7.value() as u8);
        // D s_171_9: write-var u#32451 <= s_171_8
        fn_state.u_32451 = s_171_8;
        // C s_171_10: const #0s : i
        let s_171_10: i128 = 0;
        // C s_171_11: const #4s : i
        let s_171_11: i128 = 4;
        // D s_171_12: read-var u#32450:u32
        let s_171_12: u32 = fn_state.u_32450;
        // D s_171_13: cast zx s_171_12 -> bv
        let s_171_13: Bits = Bits::new(s_171_12 as u128, 32u16);
        // D s_171_14: bit-extract s_171_13 s_171_10 s_171_11
        let s_171_14: Bits = (Bits::new(
            ((s_171_13) >> (s_171_10)).value(),
            u16::try_from(s_171_11).unwrap(),
        ));
        // D s_171_15: cast reint s_171_14 -> u8
        let s_171_15: u8 = (s_171_14.value() as u8);
        // D s_171_16: write-var u#32452 <= s_171_15
        fn_state.u_32452 = s_171_15;
        // C s_171_17: const #16s : i
        let s_171_17: i128 = 16;
        // D s_171_18: read-var u#32450:u32
        let s_171_18: u32 = fn_state.u_32450;
        // D s_171_19: cast zx s_171_18 -> bv
        let s_171_19: Bits = Bits::new(s_171_18 as u128, 32u16);
        // C s_171_20: const #1u : u64
        let s_171_20: u64 = 1;
        // D s_171_21: bit-extract s_171_19 s_171_17 s_171_20
        let s_171_21: Bits = (Bits::new(
            ((s_171_19) >> (s_171_17)).value(),
            u16::try_from(s_171_20).unwrap(),
        ));
        // D s_171_22: cast reint s_171_21 -> u8
        let s_171_22: bool = ((s_171_21.value()) != 0);
        // C s_171_23: const #0s : i
        let s_171_23: i128 = 0;
        // C s_171_24: const #0u : u64
        let s_171_24: u64 = 0;
        // D s_171_25: cast zx s_171_22 -> u64
        let s_171_25: u64 = (s_171_22 as u64);
        // C s_171_26: const #1u : u64
        let s_171_26: u64 = 1;
        // D s_171_27: and s_171_25 s_171_26
        let s_171_27: u64 = ((s_171_25) & (s_171_26));
        // D s_171_28: cmp-eq s_171_27 s_171_26
        let s_171_28: bool = ((s_171_27) == (s_171_26));
        // D s_171_29: lsl s_171_25 s_171_23
        let s_171_29: u64 = s_171_25 << s_171_23;
        // D s_171_30: or s_171_24 s_171_29
        let s_171_30: u64 = ((s_171_24) | (s_171_29));
        // D s_171_31: cmpl s_171_29
        let s_171_31: u64 = !s_171_29;
        // D s_171_32: and s_171_24 s_171_31
        let s_171_32: u64 = ((s_171_24) & (s_171_31));
        // D s_171_33: select s_171_28 s_171_30 s_171_32
        let s_171_33: u64 = if s_171_28 { s_171_30 } else { s_171_32 };
        // D s_171_34: cast trunc s_171_33 -> u8
        let s_171_34: bool = ((s_171_33) != 0);
        // D s_171_35: cast zx s_171_34 -> bv
        let s_171_35: Bits = Bits::new(s_171_34 as u128, 1u16);
        // C s_171_36: const #1u : u8
        let s_171_36: bool = true;
        // C s_171_37: cast zx s_171_36 -> bv
        let s_171_37: Bits = Bits::new(s_171_36 as u128, 1u16);
        // D s_171_38: cmp-ne s_171_35 s_171_37
        let s_171_38: bool = ((s_171_35) != (s_171_37));
        // N s_171_39: branch s_171_38 b206 b172
        if s_171_38 {
            return block_206(state, tracer, fn_state);
        } else {
            return block_172(state, tracer, fn_state);
        };
    }
    fn block_172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_172_0: const #17s : i
        let s_172_0: i128 = 17;
        // D s_172_1: read-var u#32450:u32
        let s_172_1: u32 = fn_state.u_32450;
        // D s_172_2: cast zx s_172_1 -> bv
        let s_172_2: Bits = Bits::new(s_172_1 as u128, 32u16);
        // C s_172_3: const #1u : u64
        let s_172_3: u64 = 1;
        // D s_172_4: bit-extract s_172_2 s_172_0 s_172_3
        let s_172_4: Bits = (Bits::new(
            ((s_172_2) >> (s_172_0)).value(),
            u16::try_from(s_172_3).unwrap(),
        ));
        // D s_172_5: cast reint s_172_4 -> u8
        let s_172_5: bool = ((s_172_4.value()) != 0);
        // C s_172_6: const #0s : i
        let s_172_6: i128 = 0;
        // C s_172_7: const #0u : u64
        let s_172_7: u64 = 0;
        // D s_172_8: cast zx s_172_5 -> u64
        let s_172_8: u64 = (s_172_5 as u64);
        // C s_172_9: const #1u : u64
        let s_172_9: u64 = 1;
        // D s_172_10: and s_172_8 s_172_9
        let s_172_10: u64 = ((s_172_8) & (s_172_9));
        // D s_172_11: cmp-eq s_172_10 s_172_9
        let s_172_11: bool = ((s_172_10) == (s_172_9));
        // D s_172_12: lsl s_172_8 s_172_6
        let s_172_12: u64 = s_172_8 << s_172_6;
        // D s_172_13: or s_172_7 s_172_12
        let s_172_13: u64 = ((s_172_7) | (s_172_12));
        // D s_172_14: cmpl s_172_12
        let s_172_14: u64 = !s_172_12;
        // D s_172_15: and s_172_7 s_172_14
        let s_172_15: u64 = ((s_172_7) & (s_172_14));
        // D s_172_16: select s_172_11 s_172_13 s_172_15
        let s_172_16: u64 = if s_172_11 { s_172_13 } else { s_172_15 };
        // D s_172_17: cast trunc s_172_16 -> u8
        let s_172_17: bool = ((s_172_16) != 0);
        // D s_172_18: cast zx s_172_17 -> bv
        let s_172_18: Bits = Bits::new(s_172_17 as u128, 1u16);
        // C s_172_19: const #1u : u8
        let s_172_19: bool = true;
        // C s_172_20: cast zx s_172_19 -> bv
        let s_172_20: Bits = Bits::new(s_172_19 as u128, 1u16);
        // D s_172_21: cmp-ne s_172_18 s_172_20
        let s_172_21: bool = ((s_172_18) != (s_172_20));
        // D s_172_22: write-var gs#404390 <= s_172_21
        fn_state.gs_404390 = s_172_21;
        // N s_172_23: jump b173
        return block_173(state, tracer, fn_state);
    }
    fn block_173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_173_0: read-var gs#404390:u8
        let s_173_0: bool = fn_state.gs_404390;
        // N s_173_1: branch s_173_0 b205 b174
        if s_173_0 {
            return block_205(state, tracer, fn_state);
        } else {
            return block_174(state, tracer, fn_state);
        };
    }
    fn block_174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_174_0: const #18s : i
        let s_174_0: i128 = 18;
        // D s_174_1: read-var u#32450:u32
        let s_174_1: u32 = fn_state.u_32450;
        // D s_174_2: cast zx s_174_1 -> bv
        let s_174_2: Bits = Bits::new(s_174_1 as u128, 32u16);
        // C s_174_3: const #1u : u64
        let s_174_3: u64 = 1;
        // D s_174_4: bit-extract s_174_2 s_174_0 s_174_3
        let s_174_4: Bits = (Bits::new(
            ((s_174_2) >> (s_174_0)).value(),
            u16::try_from(s_174_3).unwrap(),
        ));
        // D s_174_5: cast reint s_174_4 -> u8
        let s_174_5: bool = ((s_174_4.value()) != 0);
        // C s_174_6: const #0s : i
        let s_174_6: i128 = 0;
        // C s_174_7: const #0u : u64
        let s_174_7: u64 = 0;
        // D s_174_8: cast zx s_174_5 -> u64
        let s_174_8: u64 = (s_174_5 as u64);
        // C s_174_9: const #1u : u64
        let s_174_9: u64 = 1;
        // D s_174_10: and s_174_8 s_174_9
        let s_174_10: u64 = ((s_174_8) & (s_174_9));
        // D s_174_11: cmp-eq s_174_10 s_174_9
        let s_174_11: bool = ((s_174_10) == (s_174_9));
        // D s_174_12: lsl s_174_8 s_174_6
        let s_174_12: u64 = s_174_8 << s_174_6;
        // D s_174_13: or s_174_7 s_174_12
        let s_174_13: u64 = ((s_174_7) | (s_174_12));
        // D s_174_14: cmpl s_174_12
        let s_174_14: u64 = !s_174_12;
        // D s_174_15: and s_174_7 s_174_14
        let s_174_15: u64 = ((s_174_7) & (s_174_14));
        // D s_174_16: select s_174_11 s_174_13 s_174_15
        let s_174_16: u64 = if s_174_11 { s_174_13 } else { s_174_15 };
        // D s_174_17: cast trunc s_174_16 -> u8
        let s_174_17: bool = ((s_174_16) != 0);
        // D s_174_18: cast zx s_174_17 -> bv
        let s_174_18: Bits = Bits::new(s_174_17 as u128, 1u16);
        // C s_174_19: const #1u : u8
        let s_174_19: bool = true;
        // C s_174_20: cast zx s_174_19 -> bv
        let s_174_20: Bits = Bits::new(s_174_19 as u128, 1u16);
        // D s_174_21: cmp-ne s_174_18 s_174_20
        let s_174_21: bool = ((s_174_18) != (s_174_20));
        // D s_174_22: write-var gs#404393 <= s_174_21
        fn_state.gs_404393 = s_174_21;
        // N s_174_23: jump b175
        return block_175(state, tracer, fn_state);
    }
    fn block_175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_175_0: read-var gs#404393:u8
        let s_175_0: bool = fn_state.gs_404393;
        // N s_175_1: branch s_175_0 b204 b176
        if s_175_0 {
            return block_204(state, tracer, fn_state);
        } else {
            return block_176(state, tracer, fn_state);
        };
    }
    fn block_176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_176_0: const #19s : i
        let s_176_0: i128 = 19;
        // D s_176_1: read-var u#32450:u32
        let s_176_1: u32 = fn_state.u_32450;
        // D s_176_2: cast zx s_176_1 -> bv
        let s_176_2: Bits = Bits::new(s_176_1 as u128, 32u16);
        // C s_176_3: const #1u : u64
        let s_176_3: u64 = 1;
        // D s_176_4: bit-extract s_176_2 s_176_0 s_176_3
        let s_176_4: Bits = (Bits::new(
            ((s_176_2) >> (s_176_0)).value(),
            u16::try_from(s_176_3).unwrap(),
        ));
        // D s_176_5: cast reint s_176_4 -> u8
        let s_176_5: bool = ((s_176_4.value()) != 0);
        // C s_176_6: const #0s : i
        let s_176_6: i128 = 0;
        // C s_176_7: const #0u : u64
        let s_176_7: u64 = 0;
        // D s_176_8: cast zx s_176_5 -> u64
        let s_176_8: u64 = (s_176_5 as u64);
        // C s_176_9: const #1u : u64
        let s_176_9: u64 = 1;
        // D s_176_10: and s_176_8 s_176_9
        let s_176_10: u64 = ((s_176_8) & (s_176_9));
        // D s_176_11: cmp-eq s_176_10 s_176_9
        let s_176_11: bool = ((s_176_10) == (s_176_9));
        // D s_176_12: lsl s_176_8 s_176_6
        let s_176_12: u64 = s_176_8 << s_176_6;
        // D s_176_13: or s_176_7 s_176_12
        let s_176_13: u64 = ((s_176_7) | (s_176_12));
        // D s_176_14: cmpl s_176_12
        let s_176_14: u64 = !s_176_12;
        // D s_176_15: and s_176_7 s_176_14
        let s_176_15: u64 = ((s_176_7) & (s_176_14));
        // D s_176_16: select s_176_11 s_176_13 s_176_15
        let s_176_16: u64 = if s_176_11 { s_176_13 } else { s_176_15 };
        // D s_176_17: cast trunc s_176_16 -> u8
        let s_176_17: bool = ((s_176_16) != 0);
        // D s_176_18: cast zx s_176_17 -> bv
        let s_176_18: Bits = Bits::new(s_176_17 as u128, 1u16);
        // C s_176_19: const #1u : u8
        let s_176_19: bool = true;
        // C s_176_20: cast zx s_176_19 -> bv
        let s_176_20: Bits = Bits::new(s_176_19 as u128, 1u16);
        // D s_176_21: cmp-ne s_176_18 s_176_20
        let s_176_21: bool = ((s_176_18) != (s_176_20));
        // D s_176_22: write-var gs#404396 <= s_176_21
        fn_state.gs_404396 = s_176_21;
        // N s_176_23: jump b177
        return block_177(state, tracer, fn_state);
    }
    fn block_177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_177_0: read-var gs#404396:u8
        let s_177_0: bool = fn_state.gs_404396;
        // N s_177_1: branch s_177_0 b203 b178
        if s_177_0 {
            return block_203(state, tracer, fn_state);
        } else {
            return block_178(state, tracer, fn_state);
        };
    }
    fn block_178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_178_0: const #12s : i
        let s_178_0: i128 = 12;
        // D s_178_1: read-var u#32450:u32
        let s_178_1: u32 = fn_state.u_32450;
        // D s_178_2: cast zx s_178_1 -> bv
        let s_178_2: Bits = Bits::new(s_178_1 as u128, 32u16);
        // C s_178_3: const #1u : u64
        let s_178_3: u64 = 1;
        // D s_178_4: bit-extract s_178_2 s_178_0 s_178_3
        let s_178_4: Bits = (Bits::new(
            ((s_178_2) >> (s_178_0)).value(),
            u16::try_from(s_178_3).unwrap(),
        ));
        // D s_178_5: cast reint s_178_4 -> u8
        let s_178_5: bool = ((s_178_4.value()) != 0);
        // C s_178_6: const #0s : i
        let s_178_6: i128 = 0;
        // C s_178_7: const #0u : u64
        let s_178_7: u64 = 0;
        // D s_178_8: cast zx s_178_5 -> u64
        let s_178_8: u64 = (s_178_5 as u64);
        // C s_178_9: const #1u : u64
        let s_178_9: u64 = 1;
        // D s_178_10: and s_178_8 s_178_9
        let s_178_10: u64 = ((s_178_8) & (s_178_9));
        // D s_178_11: cmp-eq s_178_10 s_178_9
        let s_178_11: bool = ((s_178_10) == (s_178_9));
        // D s_178_12: lsl s_178_8 s_178_6
        let s_178_12: u64 = s_178_8 << s_178_6;
        // D s_178_13: or s_178_7 s_178_12
        let s_178_13: u64 = ((s_178_7) | (s_178_12));
        // D s_178_14: cmpl s_178_12
        let s_178_14: u64 = !s_178_12;
        // D s_178_15: and s_178_7 s_178_14
        let s_178_15: u64 = ((s_178_7) & (s_178_14));
        // D s_178_16: select s_178_11 s_178_13 s_178_15
        let s_178_16: u64 = if s_178_11 { s_178_13 } else { s_178_15 };
        // D s_178_17: cast trunc s_178_16 -> u8
        let s_178_17: bool = ((s_178_16) != 0);
        // D s_178_18: cast zx s_178_17 -> bv
        let s_178_18: Bits = Bits::new(s_178_17 as u128, 1u16);
        // C s_178_19: const #1u : u8
        let s_178_19: bool = true;
        // C s_178_20: cast zx s_178_19 -> bv
        let s_178_20: Bits = Bits::new(s_178_19 as u128, 1u16);
        // D s_178_21: cmp-ne s_178_18 s_178_20
        let s_178_21: bool = ((s_178_18) != (s_178_20));
        // D s_178_22: write-var gs#404399 <= s_178_21
        fn_state.gs_404399 = s_178_21;
        // N s_178_23: jump b179
        return block_179(state, tracer, fn_state);
    }
    fn block_179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_179_0: read-var gs#404399:u8
        let s_179_0: bool = fn_state.gs_404399;
        // N s_179_1: branch s_179_0 b202 b180
        if s_179_0 {
            return block_202(state, tracer, fn_state);
        } else {
            return block_180(state, tracer, fn_state);
        };
    }
    fn block_180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_180_0: const #13s : i
        let s_180_0: i128 = 13;
        // D s_180_1: read-var u#32450:u32
        let s_180_1: u32 = fn_state.u_32450;
        // D s_180_2: cast zx s_180_1 -> bv
        let s_180_2: Bits = Bits::new(s_180_1 as u128, 32u16);
        // C s_180_3: const #1u : u64
        let s_180_3: u64 = 1;
        // D s_180_4: bit-extract s_180_2 s_180_0 s_180_3
        let s_180_4: Bits = (Bits::new(
            ((s_180_2) >> (s_180_0)).value(),
            u16::try_from(s_180_3).unwrap(),
        ));
        // D s_180_5: cast reint s_180_4 -> u8
        let s_180_5: bool = ((s_180_4.value()) != 0);
        // C s_180_6: const #0s : i
        let s_180_6: i128 = 0;
        // C s_180_7: const #0u : u64
        let s_180_7: u64 = 0;
        // D s_180_8: cast zx s_180_5 -> u64
        let s_180_8: u64 = (s_180_5 as u64);
        // C s_180_9: const #1u : u64
        let s_180_9: u64 = 1;
        // D s_180_10: and s_180_8 s_180_9
        let s_180_10: u64 = ((s_180_8) & (s_180_9));
        // D s_180_11: cmp-eq s_180_10 s_180_9
        let s_180_11: bool = ((s_180_10) == (s_180_9));
        // D s_180_12: lsl s_180_8 s_180_6
        let s_180_12: u64 = s_180_8 << s_180_6;
        // D s_180_13: or s_180_7 s_180_12
        let s_180_13: u64 = ((s_180_7) | (s_180_12));
        // D s_180_14: cmpl s_180_12
        let s_180_14: u64 = !s_180_12;
        // D s_180_15: and s_180_7 s_180_14
        let s_180_15: u64 = ((s_180_7) & (s_180_14));
        // D s_180_16: select s_180_11 s_180_13 s_180_15
        let s_180_16: u64 = if s_180_11 { s_180_13 } else { s_180_15 };
        // D s_180_17: cast trunc s_180_16 -> u8
        let s_180_17: bool = ((s_180_16) != 0);
        // D s_180_18: cast zx s_180_17 -> bv
        let s_180_18: Bits = Bits::new(s_180_17 as u128, 1u16);
        // C s_180_19: const #1u : u8
        let s_180_19: bool = true;
        // C s_180_20: cast zx s_180_19 -> bv
        let s_180_20: Bits = Bits::new(s_180_19 as u128, 1u16);
        // D s_180_21: cmp-ne s_180_18 s_180_20
        let s_180_21: bool = ((s_180_18) != (s_180_20));
        // D s_180_22: write-var gs#404402 <= s_180_21
        fn_state.gs_404402 = s_180_21;
        // N s_180_23: jump b181
        return block_181(state, tracer, fn_state);
    }
    fn block_181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_181_0: read-var gs#404402:u8
        let s_181_0: bool = fn_state.gs_404402;
        // N s_181_1: branch s_181_0 b201 b182
        if s_181_0 {
            return block_201(state, tracer, fn_state);
        } else {
            return block_182(state, tracer, fn_state);
        };
    }
    fn block_182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_182_0: const #14s : i
        let s_182_0: i128 = 14;
        // D s_182_1: read-var u#32450:u32
        let s_182_1: u32 = fn_state.u_32450;
        // D s_182_2: cast zx s_182_1 -> bv
        let s_182_2: Bits = Bits::new(s_182_1 as u128, 32u16);
        // C s_182_3: const #1u : u64
        let s_182_3: u64 = 1;
        // D s_182_4: bit-extract s_182_2 s_182_0 s_182_3
        let s_182_4: Bits = (Bits::new(
            ((s_182_2) >> (s_182_0)).value(),
            u16::try_from(s_182_3).unwrap(),
        ));
        // D s_182_5: cast reint s_182_4 -> u8
        let s_182_5: bool = ((s_182_4.value()) != 0);
        // C s_182_6: const #0s : i
        let s_182_6: i128 = 0;
        // C s_182_7: const #0u : u64
        let s_182_7: u64 = 0;
        // D s_182_8: cast zx s_182_5 -> u64
        let s_182_8: u64 = (s_182_5 as u64);
        // C s_182_9: const #1u : u64
        let s_182_9: u64 = 1;
        // D s_182_10: and s_182_8 s_182_9
        let s_182_10: u64 = ((s_182_8) & (s_182_9));
        // D s_182_11: cmp-eq s_182_10 s_182_9
        let s_182_11: bool = ((s_182_10) == (s_182_9));
        // D s_182_12: lsl s_182_8 s_182_6
        let s_182_12: u64 = s_182_8 << s_182_6;
        // D s_182_13: or s_182_7 s_182_12
        let s_182_13: u64 = ((s_182_7) | (s_182_12));
        // D s_182_14: cmpl s_182_12
        let s_182_14: u64 = !s_182_12;
        // D s_182_15: and s_182_7 s_182_14
        let s_182_15: u64 = ((s_182_7) & (s_182_14));
        // D s_182_16: select s_182_11 s_182_13 s_182_15
        let s_182_16: u64 = if s_182_11 { s_182_13 } else { s_182_15 };
        // D s_182_17: cast trunc s_182_16 -> u8
        let s_182_17: bool = ((s_182_16) != 0);
        // D s_182_18: cast zx s_182_17 -> bv
        let s_182_18: Bits = Bits::new(s_182_17 as u128, 1u16);
        // C s_182_19: const #1u : u8
        let s_182_19: bool = true;
        // C s_182_20: cast zx s_182_19 -> bv
        let s_182_20: Bits = Bits::new(s_182_19 as u128, 1u16);
        // D s_182_21: cmp-ne s_182_18 s_182_20
        let s_182_21: bool = ((s_182_18) != (s_182_20));
        // D s_182_22: write-var gs#404405 <= s_182_21
        fn_state.gs_404405 = s_182_21;
        // N s_182_23: jump b183
        return block_183(state, tracer, fn_state);
    }
    fn block_183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_183_0: read-var gs#404405:u8
        let s_183_0: bool = fn_state.gs_404405;
        // N s_183_1: branch s_183_0 b200 b184
        if s_183_0 {
            return block_200(state, tracer, fn_state);
        } else {
            return block_184(state, tracer, fn_state);
        };
    }
    fn block_184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_184_0: const #15s : i
        let s_184_0: i128 = 15;
        // D s_184_1: read-var u#32450:u32
        let s_184_1: u32 = fn_state.u_32450;
        // D s_184_2: cast zx s_184_1 -> bv
        let s_184_2: Bits = Bits::new(s_184_1 as u128, 32u16);
        // C s_184_3: const #1u : u64
        let s_184_3: u64 = 1;
        // D s_184_4: bit-extract s_184_2 s_184_0 s_184_3
        let s_184_4: Bits = (Bits::new(
            ((s_184_2) >> (s_184_0)).value(),
            u16::try_from(s_184_3).unwrap(),
        ));
        // D s_184_5: cast reint s_184_4 -> u8
        let s_184_5: bool = ((s_184_4.value()) != 0);
        // C s_184_6: const #0s : i
        let s_184_6: i128 = 0;
        // C s_184_7: const #0u : u64
        let s_184_7: u64 = 0;
        // D s_184_8: cast zx s_184_5 -> u64
        let s_184_8: u64 = (s_184_5 as u64);
        // C s_184_9: const #1u : u64
        let s_184_9: u64 = 1;
        // D s_184_10: and s_184_8 s_184_9
        let s_184_10: u64 = ((s_184_8) & (s_184_9));
        // D s_184_11: cmp-eq s_184_10 s_184_9
        let s_184_11: bool = ((s_184_10) == (s_184_9));
        // D s_184_12: lsl s_184_8 s_184_6
        let s_184_12: u64 = s_184_8 << s_184_6;
        // D s_184_13: or s_184_7 s_184_12
        let s_184_13: u64 = ((s_184_7) | (s_184_12));
        // D s_184_14: cmpl s_184_12
        let s_184_14: u64 = !s_184_12;
        // D s_184_15: and s_184_7 s_184_14
        let s_184_15: u64 = ((s_184_7) & (s_184_14));
        // D s_184_16: select s_184_11 s_184_13 s_184_15
        let s_184_16: u64 = if s_184_11 { s_184_13 } else { s_184_15 };
        // D s_184_17: cast trunc s_184_16 -> u8
        let s_184_17: bool = ((s_184_16) != 0);
        // D s_184_18: cast zx s_184_17 -> bv
        let s_184_18: Bits = Bits::new(s_184_17 as u128, 1u16);
        // C s_184_19: const #1u : u8
        let s_184_19: bool = true;
        // C s_184_20: cast zx s_184_19 -> bv
        let s_184_20: Bits = Bits::new(s_184_19 as u128, 1u16);
        // D s_184_21: cmp-ne s_184_18 s_184_20
        let s_184_21: bool = ((s_184_18) != (s_184_20));
        // D s_184_22: write-var gs#404408 <= s_184_21
        fn_state.gs_404408 = s_184_21;
        // N s_184_23: jump b185
        return block_185(state, tracer, fn_state);
    }
    fn block_185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_185_0: read-var gs#404408:u8
        let s_185_0: bool = fn_state.gs_404408;
        // N s_185_1: branch s_185_0 b199 b186
        if s_185_0 {
            return block_199(state, tracer, fn_state);
        } else {
            return block_186(state, tracer, fn_state);
        };
    }
    fn block_186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_186_0: const #8s : i
        let s_186_0: i128 = 8;
        // D s_186_1: read-var u#32450:u32
        let s_186_1: u32 = fn_state.u_32450;
        // D s_186_2: cast zx s_186_1 -> bv
        let s_186_2: Bits = Bits::new(s_186_1 as u128, 32u16);
        // C s_186_3: const #1u : u64
        let s_186_3: u64 = 1;
        // D s_186_4: bit-extract s_186_2 s_186_0 s_186_3
        let s_186_4: Bits = (Bits::new(
            ((s_186_2) >> (s_186_0)).value(),
            u16::try_from(s_186_3).unwrap(),
        ));
        // D s_186_5: cast reint s_186_4 -> u8
        let s_186_5: bool = ((s_186_4.value()) != 0);
        // C s_186_6: const #0s : i
        let s_186_6: i128 = 0;
        // C s_186_7: const #0u : u64
        let s_186_7: u64 = 0;
        // D s_186_8: cast zx s_186_5 -> u64
        let s_186_8: u64 = (s_186_5 as u64);
        // C s_186_9: const #1u : u64
        let s_186_9: u64 = 1;
        // D s_186_10: and s_186_8 s_186_9
        let s_186_10: u64 = ((s_186_8) & (s_186_9));
        // D s_186_11: cmp-eq s_186_10 s_186_9
        let s_186_11: bool = ((s_186_10) == (s_186_9));
        // D s_186_12: lsl s_186_8 s_186_6
        let s_186_12: u64 = s_186_8 << s_186_6;
        // D s_186_13: or s_186_7 s_186_12
        let s_186_13: u64 = ((s_186_7) | (s_186_12));
        // D s_186_14: cmpl s_186_12
        let s_186_14: u64 = !s_186_12;
        // D s_186_15: and s_186_7 s_186_14
        let s_186_15: u64 = ((s_186_7) & (s_186_14));
        // D s_186_16: select s_186_11 s_186_13 s_186_15
        let s_186_16: u64 = if s_186_11 { s_186_13 } else { s_186_15 };
        // D s_186_17: cast trunc s_186_16 -> u8
        let s_186_17: bool = ((s_186_16) != 0);
        // D s_186_18: cast zx s_186_17 -> bv
        let s_186_18: Bits = Bits::new(s_186_17 as u128, 1u16);
        // C s_186_19: const #1u : u8
        let s_186_19: bool = true;
        // C s_186_20: cast zx s_186_19 -> bv
        let s_186_20: Bits = Bits::new(s_186_19 as u128, 1u16);
        // D s_186_21: cmp-ne s_186_18 s_186_20
        let s_186_21: bool = ((s_186_18) != (s_186_20));
        // D s_186_22: write-var gs#404411 <= s_186_21
        fn_state.gs_404411 = s_186_21;
        // N s_186_23: jump b187
        return block_187(state, tracer, fn_state);
    }
    fn block_187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_187_0: read-var gs#404411:u8
        let s_187_0: bool = fn_state.gs_404411;
        // N s_187_1: branch s_187_0 b198 b188
        if s_187_0 {
            return block_198(state, tracer, fn_state);
        } else {
            return block_188(state, tracer, fn_state);
        };
    }
    fn block_188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_188_0: const #9s : i
        let s_188_0: i128 = 9;
        // D s_188_1: read-var u#32450:u32
        let s_188_1: u32 = fn_state.u_32450;
        // D s_188_2: cast zx s_188_1 -> bv
        let s_188_2: Bits = Bits::new(s_188_1 as u128, 32u16);
        // C s_188_3: const #1u : u64
        let s_188_3: u64 = 1;
        // D s_188_4: bit-extract s_188_2 s_188_0 s_188_3
        let s_188_4: Bits = (Bits::new(
            ((s_188_2) >> (s_188_0)).value(),
            u16::try_from(s_188_3).unwrap(),
        ));
        // D s_188_5: cast reint s_188_4 -> u8
        let s_188_5: bool = ((s_188_4.value()) != 0);
        // C s_188_6: const #0s : i
        let s_188_6: i128 = 0;
        // C s_188_7: const #0u : u64
        let s_188_7: u64 = 0;
        // D s_188_8: cast zx s_188_5 -> u64
        let s_188_8: u64 = (s_188_5 as u64);
        // C s_188_9: const #1u : u64
        let s_188_9: u64 = 1;
        // D s_188_10: and s_188_8 s_188_9
        let s_188_10: u64 = ((s_188_8) & (s_188_9));
        // D s_188_11: cmp-eq s_188_10 s_188_9
        let s_188_11: bool = ((s_188_10) == (s_188_9));
        // D s_188_12: lsl s_188_8 s_188_6
        let s_188_12: u64 = s_188_8 << s_188_6;
        // D s_188_13: or s_188_7 s_188_12
        let s_188_13: u64 = ((s_188_7) | (s_188_12));
        // D s_188_14: cmpl s_188_12
        let s_188_14: u64 = !s_188_12;
        // D s_188_15: and s_188_7 s_188_14
        let s_188_15: u64 = ((s_188_7) & (s_188_14));
        // D s_188_16: select s_188_11 s_188_13 s_188_15
        let s_188_16: u64 = if s_188_11 { s_188_13 } else { s_188_15 };
        // D s_188_17: cast trunc s_188_16 -> u8
        let s_188_17: bool = ((s_188_16) != 0);
        // D s_188_18: cast zx s_188_17 -> bv
        let s_188_18: Bits = Bits::new(s_188_17 as u128, 1u16);
        // C s_188_19: const #1u : u8
        let s_188_19: bool = true;
        // C s_188_20: cast zx s_188_19 -> bv
        let s_188_20: Bits = Bits::new(s_188_19 as u128, 1u16);
        // D s_188_21: cmp-ne s_188_18 s_188_20
        let s_188_21: bool = ((s_188_18) != (s_188_20));
        // D s_188_22: write-var gs#404414 <= s_188_21
        fn_state.gs_404414 = s_188_21;
        // N s_188_23: jump b189
        return block_189(state, tracer, fn_state);
    }
    fn block_189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_189_0: read-var gs#404414:u8
        let s_189_0: bool = fn_state.gs_404414;
        // N s_189_1: branch s_189_0 b197 b190
        if s_189_0 {
            return block_197(state, tracer, fn_state);
        } else {
            return block_190(state, tracer, fn_state);
        };
    }
    fn block_190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_190_0: const #10s : i
        let s_190_0: i128 = 10;
        // D s_190_1: read-var u#32450:u32
        let s_190_1: u32 = fn_state.u_32450;
        // D s_190_2: cast zx s_190_1 -> bv
        let s_190_2: Bits = Bits::new(s_190_1 as u128, 32u16);
        // C s_190_3: const #1u : u64
        let s_190_3: u64 = 1;
        // D s_190_4: bit-extract s_190_2 s_190_0 s_190_3
        let s_190_4: Bits = (Bits::new(
            ((s_190_2) >> (s_190_0)).value(),
            u16::try_from(s_190_3).unwrap(),
        ));
        // D s_190_5: cast reint s_190_4 -> u8
        let s_190_5: bool = ((s_190_4.value()) != 0);
        // C s_190_6: const #0s : i
        let s_190_6: i128 = 0;
        // C s_190_7: const #0u : u64
        let s_190_7: u64 = 0;
        // D s_190_8: cast zx s_190_5 -> u64
        let s_190_8: u64 = (s_190_5 as u64);
        // C s_190_9: const #1u : u64
        let s_190_9: u64 = 1;
        // D s_190_10: and s_190_8 s_190_9
        let s_190_10: u64 = ((s_190_8) & (s_190_9));
        // D s_190_11: cmp-eq s_190_10 s_190_9
        let s_190_11: bool = ((s_190_10) == (s_190_9));
        // D s_190_12: lsl s_190_8 s_190_6
        let s_190_12: u64 = s_190_8 << s_190_6;
        // D s_190_13: or s_190_7 s_190_12
        let s_190_13: u64 = ((s_190_7) | (s_190_12));
        // D s_190_14: cmpl s_190_12
        let s_190_14: u64 = !s_190_12;
        // D s_190_15: and s_190_7 s_190_14
        let s_190_15: u64 = ((s_190_7) & (s_190_14));
        // D s_190_16: select s_190_11 s_190_13 s_190_15
        let s_190_16: u64 = if s_190_11 { s_190_13 } else { s_190_15 };
        // D s_190_17: cast trunc s_190_16 -> u8
        let s_190_17: bool = ((s_190_16) != 0);
        // D s_190_18: cast zx s_190_17 -> bv
        let s_190_18: Bits = Bits::new(s_190_17 as u128, 1u16);
        // C s_190_19: const #1u : u8
        let s_190_19: bool = true;
        // C s_190_20: cast zx s_190_19 -> bv
        let s_190_20: Bits = Bits::new(s_190_19 as u128, 1u16);
        // D s_190_21: cmp-ne s_190_18 s_190_20
        let s_190_21: bool = ((s_190_18) != (s_190_20));
        // D s_190_22: write-var gs#404417 <= s_190_21
        fn_state.gs_404417 = s_190_21;
        // N s_190_23: jump b191
        return block_191(state, tracer, fn_state);
    }
    fn block_191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_191_0: read-var gs#404417:u8
        let s_191_0: bool = fn_state.gs_404417;
        // N s_191_1: branch s_191_0 b196 b192
        if s_191_0 {
            return block_196(state, tracer, fn_state);
        } else {
            return block_192(state, tracer, fn_state);
        };
    }
    fn block_192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_192_0: const #11s : i
        let s_192_0: i128 = 11;
        // D s_192_1: read-var u#32450:u32
        let s_192_1: u32 = fn_state.u_32450;
        // D s_192_2: cast zx s_192_1 -> bv
        let s_192_2: Bits = Bits::new(s_192_1 as u128, 32u16);
        // C s_192_3: const #1u : u64
        let s_192_3: u64 = 1;
        // D s_192_4: bit-extract s_192_2 s_192_0 s_192_3
        let s_192_4: Bits = (Bits::new(
            ((s_192_2) >> (s_192_0)).value(),
            u16::try_from(s_192_3).unwrap(),
        ));
        // D s_192_5: cast reint s_192_4 -> u8
        let s_192_5: bool = ((s_192_4.value()) != 0);
        // C s_192_6: const #0s : i
        let s_192_6: i128 = 0;
        // C s_192_7: const #0u : u64
        let s_192_7: u64 = 0;
        // D s_192_8: cast zx s_192_5 -> u64
        let s_192_8: u64 = (s_192_5 as u64);
        // C s_192_9: const #1u : u64
        let s_192_9: u64 = 1;
        // D s_192_10: and s_192_8 s_192_9
        let s_192_10: u64 = ((s_192_8) & (s_192_9));
        // D s_192_11: cmp-eq s_192_10 s_192_9
        let s_192_11: bool = ((s_192_10) == (s_192_9));
        // D s_192_12: lsl s_192_8 s_192_6
        let s_192_12: u64 = s_192_8 << s_192_6;
        // D s_192_13: or s_192_7 s_192_12
        let s_192_13: u64 = ((s_192_7) | (s_192_12));
        // D s_192_14: cmpl s_192_12
        let s_192_14: u64 = !s_192_12;
        // D s_192_15: and s_192_7 s_192_14
        let s_192_15: u64 = ((s_192_7) & (s_192_14));
        // D s_192_16: select s_192_11 s_192_13 s_192_15
        let s_192_16: u64 = if s_192_11 { s_192_13 } else { s_192_15 };
        // D s_192_17: cast trunc s_192_16 -> u8
        let s_192_17: bool = ((s_192_16) != 0);
        // D s_192_18: cast zx s_192_17 -> bv
        let s_192_18: Bits = Bits::new(s_192_17 as u128, 1u16);
        // C s_192_19: const #1u : u8
        let s_192_19: bool = true;
        // C s_192_20: cast zx s_192_19 -> bv
        let s_192_20: Bits = Bits::new(s_192_19 as u128, 1u16);
        // D s_192_21: cmp-ne s_192_18 s_192_20
        let s_192_21: bool = ((s_192_18) != (s_192_20));
        // D s_192_22: write-var gs#404420 <= s_192_21
        fn_state.gs_404420 = s_192_21;
        // N s_192_23: jump b193
        return block_193(state, tracer, fn_state);
    }
    fn block_193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_193_0: read-var gs#404420:u8
        let s_193_0: bool = fn_state.gs_404420;
        // N s_193_1: branch s_193_0 b195 b194
        if s_193_0 {
            return block_195(state, tracer, fn_state);
        } else {
            return block_194(state, tracer, fn_state);
        };
    }
    fn block_194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_194_0: read-var u#32451:u8
        let s_194_0: u8 = fn_state.u_32451;
        // D s_194_1: read-var u#32452:u8
        let s_194_1: u8 = fn_state.u_32452;
        // D s_194_2: call decode_aarch32_instrs_BXJ_A1enc_A_txt(s_194_0, s_194_1)
        let s_194_2: () = decode_aarch32_instrs_BXJ_A1enc_A_txt(
            state,
            tracer,
            s_194_0,
            s_194_1,
        );
        // N s_194_3: return
        return;
    }
    fn block_195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_195_0: panic
        panic!("{:?}", ());
        // N s_195_1: return
        return;
    }
    fn block_196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_196_0: const #1u : u8
        let s_196_0: bool = true;
        // D s_196_1: write-var gs#404420 <= s_196_0
        fn_state.gs_404420 = s_196_0;
        // N s_196_2: jump b193
        return block_193(state, tracer, fn_state);
    }
    fn block_197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_197_0: const #1u : u8
        let s_197_0: bool = true;
        // D s_197_1: write-var gs#404417 <= s_197_0
        fn_state.gs_404417 = s_197_0;
        // N s_197_2: jump b191
        return block_191(state, tracer, fn_state);
    }
    fn block_198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_198_0: const #1u : u8
        let s_198_0: bool = true;
        // D s_198_1: write-var gs#404414 <= s_198_0
        fn_state.gs_404414 = s_198_0;
        // N s_198_2: jump b189
        return block_189(state, tracer, fn_state);
    }
    fn block_199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_199_0: const #1u : u8
        let s_199_0: bool = true;
        // D s_199_1: write-var gs#404411 <= s_199_0
        fn_state.gs_404411 = s_199_0;
        // N s_199_2: jump b187
        return block_187(state, tracer, fn_state);
    }
    fn block_200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_200_0: const #1u : u8
        let s_200_0: bool = true;
        // D s_200_1: write-var gs#404408 <= s_200_0
        fn_state.gs_404408 = s_200_0;
        // N s_200_2: jump b185
        return block_185(state, tracer, fn_state);
    }
    fn block_201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_201_0: const #1u : u8
        let s_201_0: bool = true;
        // D s_201_1: write-var gs#404405 <= s_201_0
        fn_state.gs_404405 = s_201_0;
        // N s_201_2: jump b183
        return block_183(state, tracer, fn_state);
    }
    fn block_202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_202_0: const #1u : u8
        let s_202_0: bool = true;
        // D s_202_1: write-var gs#404402 <= s_202_0
        fn_state.gs_404402 = s_202_0;
        // N s_202_2: jump b181
        return block_181(state, tracer, fn_state);
    }
    fn block_203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_203_0: const #1u : u8
        let s_203_0: bool = true;
        // D s_203_1: write-var gs#404399 <= s_203_0
        fn_state.gs_404399 = s_203_0;
        // N s_203_2: jump b179
        return block_179(state, tracer, fn_state);
    }
    fn block_204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_204_0: const #1u : u8
        let s_204_0: bool = true;
        // D s_204_1: write-var gs#404396 <= s_204_0
        fn_state.gs_404396 = s_204_0;
        // N s_204_2: jump b177
        return block_177(state, tracer, fn_state);
    }
    fn block_205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_205_0: const #1u : u8
        let s_205_0: bool = true;
        // D s_205_1: write-var gs#404393 <= s_205_0
        fn_state.gs_404393 = s_205_0;
        // N s_205_2: jump b175
        return block_175(state, tracer, fn_state);
    }
    fn block_206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_206_0: const #1u : u8
        let s_206_0: bool = true;
        // D s_206_1: write-var gs#404390 <= s_206_0
        fn_state.gs_404390 = s_206_0;
        // N s_206_2: jump b173
        return block_173(state, tracer, fn_state);
    }
    fn block_207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_207_0: read-var merge#var.1:struct
        let s_207_0: u32 = fn_state.merge_var._1;
        // D s_207_1: write-var u#32454 <= s_207_0
        fn_state.u_32454 = s_207_0;
        // C s_207_2: const #16s : i
        let s_207_2: i128 = 16;
        // D s_207_3: read-var u#32454:u32
        let s_207_3: u32 = fn_state.u_32454;
        // D s_207_4: cast zx s_207_3 -> bv
        let s_207_4: Bits = Bits::new(s_207_3 as u128, 32u16);
        // C s_207_5: const #1s : i64
        let s_207_5: i64 = 1;
        // C s_207_6: cast zx s_207_5 -> i
        let s_207_6: i128 = (i128::try_from(s_207_5).unwrap());
        // C s_207_7: const #11s : i
        let s_207_7: i128 = 11;
        // C s_207_8: add s_207_7 s_207_6
        let s_207_8: i128 = (s_207_7 + s_207_6);
        // D s_207_9: bit-extract s_207_4 s_207_2 s_207_8
        let s_207_9: Bits = (Bits::new(
            ((s_207_4) >> (s_207_2)).value(),
            u16::try_from(s_207_8).unwrap(),
        ));
        // D s_207_10: cast reint s_207_9 -> u12
        let s_207_10: u16 = (s_207_9.value() as u16);
        // D s_207_11: cast zx s_207_10 -> bv
        let s_207_11: Bits = Bits::new(s_207_10 as u128, 12u16);
        // C s_207_12: const #367u : u12
        let s_207_12: u16 = 367;
        // C s_207_13: cast zx s_207_12 -> bv
        let s_207_13: Bits = Bits::new(s_207_12 as u128, 12u16);
        // D s_207_14: cmp-eq s_207_11 s_207_13
        let s_207_14: bool = ((s_207_11) == (s_207_13));
        // N s_207_15: branch s_207_14 b2893 b208
        if s_207_14 {
            return block_2893(state, tracer, fn_state);
        } else {
            return block_208(state, tracer, fn_state);
        };
    }
    fn block_208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_208_0: const #0u : u8
        let s_208_0: bool = false;
        // D s_208_1: write-var gs#404426 <= s_208_0
        fn_state.gs_404426 = s_208_0;
        // N s_208_2: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_209_0: read-var gs#404426:u8
        let s_209_0: bool = fn_state.gs_404426;
        // N s_209_1: branch s_209_0 b2889 b210
        if s_209_0 {
            return block_2889(state, tracer, fn_state);
        } else {
            return block_210(state, tracer, fn_state);
        };
    }
    fn block_210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_210_0: const #0u : u8
        let s_210_0: bool = false;
        // D s_210_1: write-var gs#404431 <= s_210_0
        fn_state.gs_404431 = s_210_0;
        // N s_210_2: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_211_0: read-var gs#404431:u8
        let s_211_0: bool = fn_state.gs_404431;
        // D s_211_1: not s_211_0
        let s_211_1: bool = !s_211_0;
        // N s_211_2: branch s_211_1 b236 b212
        if s_211_1 {
            return block_236(state, tracer, fn_state);
        } else {
            return block_212(state, tracer, fn_state);
        };
    }
    fn block_212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_212_0: const #2881s : i
        let s_212_0: i128 = 2881;
        // C s_212_1: const #14696u : u32
        let s_212_1: u32 = 14696;
        // N s_212_2: write-reg s_212_1 <= s_212_0
        let s_212_2: () = {
            state.write_register::<i128>(s_212_1 as isize, s_212_0);
            tracer.write_register(s_212_1 as isize, s_212_0);
        };
        // C s_212_3: const #28s : i
        let s_212_3: i128 = 28;
        // C s_212_4: const #4s : i
        let s_212_4: i128 = 4;
        // D s_212_5: read-var u#32454:u32
        let s_212_5: u32 = fn_state.u_32454;
        // D s_212_6: cast zx s_212_5 -> bv
        let s_212_6: Bits = Bits::new(s_212_5 as u128, 32u16);
        // D s_212_7: bit-extract s_212_6 s_212_3 s_212_4
        let s_212_7: Bits = (Bits::new(
            ((s_212_6) >> (s_212_3)).value(),
            u16::try_from(s_212_4).unwrap(),
        ));
        // D s_212_8: cast reint s_212_7 -> u8
        let s_212_8: u8 = (s_212_7.value() as u8);
        // D s_212_9: write-var u#32455 <= s_212_8
        fn_state.u_32455 = s_212_8;
        // C s_212_10: const #12s : i
        let s_212_10: i128 = 12;
        // C s_212_11: const #4s : i
        let s_212_11: i128 = 4;
        // D s_212_12: read-var u#32454:u32
        let s_212_12: u32 = fn_state.u_32454;
        // D s_212_13: cast zx s_212_12 -> bv
        let s_212_13: Bits = Bits::new(s_212_12 as u128, 32u16);
        // D s_212_14: bit-extract s_212_13 s_212_10 s_212_11
        let s_212_14: Bits = (Bits::new(
            ((s_212_13) >> (s_212_10)).value(),
            u16::try_from(s_212_11).unwrap(),
        ));
        // D s_212_15: cast reint s_212_14 -> u8
        let s_212_15: u8 = (s_212_14.value() as u8);
        // D s_212_16: write-var u#32456 <= s_212_15
        fn_state.u_32456 = s_212_15;
        // C s_212_17: const #0s : i
        let s_212_17: i128 = 0;
        // C s_212_18: const #4s : i
        let s_212_18: i128 = 4;
        // D s_212_19: read-var u#32454:u32
        let s_212_19: u32 = fn_state.u_32454;
        // D s_212_20: cast zx s_212_19 -> bv
        let s_212_20: Bits = Bits::new(s_212_19 as u128, 32u16);
        // D s_212_21: bit-extract s_212_20 s_212_17 s_212_18
        let s_212_21: Bits = (Bits::new(
            ((s_212_20) >> (s_212_17)).value(),
            u16::try_from(s_212_18).unwrap(),
        ));
        // D s_212_22: cast reint s_212_21 -> u8
        let s_212_22: u8 = (s_212_21.value() as u8);
        // D s_212_23: write-var u#32457 <= s_212_22
        fn_state.u_32457 = s_212_22;
        // C s_212_24: const #16s : i
        let s_212_24: i128 = 16;
        // D s_212_25: read-var u#32454:u32
        let s_212_25: u32 = fn_state.u_32454;
        // D s_212_26: cast zx s_212_25 -> bv
        let s_212_26: Bits = Bits::new(s_212_25 as u128, 32u16);
        // C s_212_27: const #1u : u64
        let s_212_27: u64 = 1;
        // D s_212_28: bit-extract s_212_26 s_212_24 s_212_27
        let s_212_28: Bits = (Bits::new(
            ((s_212_26) >> (s_212_24)).value(),
            u16::try_from(s_212_27).unwrap(),
        ));
        // D s_212_29: cast reint s_212_28 -> u8
        let s_212_29: bool = ((s_212_28.value()) != 0);
        // C s_212_30: const #0s : i
        let s_212_30: i128 = 0;
        // C s_212_31: const #0u : u64
        let s_212_31: u64 = 0;
        // D s_212_32: cast zx s_212_29 -> u64
        let s_212_32: u64 = (s_212_29 as u64);
        // C s_212_33: const #1u : u64
        let s_212_33: u64 = 1;
        // D s_212_34: and s_212_32 s_212_33
        let s_212_34: u64 = ((s_212_32) & (s_212_33));
        // D s_212_35: cmp-eq s_212_34 s_212_33
        let s_212_35: bool = ((s_212_34) == (s_212_33));
        // D s_212_36: lsl s_212_32 s_212_30
        let s_212_36: u64 = s_212_32 << s_212_30;
        // D s_212_37: or s_212_31 s_212_36
        let s_212_37: u64 = ((s_212_31) | (s_212_36));
        // D s_212_38: cmpl s_212_36
        let s_212_38: u64 = !s_212_36;
        // D s_212_39: and s_212_31 s_212_38
        let s_212_39: u64 = ((s_212_31) & (s_212_38));
        // D s_212_40: select s_212_35 s_212_37 s_212_39
        let s_212_40: u64 = if s_212_35 { s_212_37 } else { s_212_39 };
        // D s_212_41: cast trunc s_212_40 -> u8
        let s_212_41: bool = ((s_212_40) != 0);
        // D s_212_42: cast zx s_212_41 -> bv
        let s_212_42: Bits = Bits::new(s_212_41 as u128, 1u16);
        // C s_212_43: const #1u : u8
        let s_212_43: bool = true;
        // C s_212_44: cast zx s_212_43 -> bv
        let s_212_44: Bits = Bits::new(s_212_43 as u128, 1u16);
        // D s_212_45: cmp-ne s_212_42 s_212_44
        let s_212_45: bool = ((s_212_42) != (s_212_44));
        // N s_212_46: branch s_212_45 b235 b213
        if s_212_45 {
            return block_235(state, tracer, fn_state);
        } else {
            return block_213(state, tracer, fn_state);
        };
    }
    fn block_213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_213_0: const #17s : i
        let s_213_0: i128 = 17;
        // D s_213_1: read-var u#32454:u32
        let s_213_1: u32 = fn_state.u_32454;
        // D s_213_2: cast zx s_213_1 -> bv
        let s_213_2: Bits = Bits::new(s_213_1 as u128, 32u16);
        // C s_213_3: const #1u : u64
        let s_213_3: u64 = 1;
        // D s_213_4: bit-extract s_213_2 s_213_0 s_213_3
        let s_213_4: Bits = (Bits::new(
            ((s_213_2) >> (s_213_0)).value(),
            u16::try_from(s_213_3).unwrap(),
        ));
        // D s_213_5: cast reint s_213_4 -> u8
        let s_213_5: bool = ((s_213_4.value()) != 0);
        // C s_213_6: const #0s : i
        let s_213_6: i128 = 0;
        // C s_213_7: const #0u : u64
        let s_213_7: u64 = 0;
        // D s_213_8: cast zx s_213_5 -> u64
        let s_213_8: u64 = (s_213_5 as u64);
        // C s_213_9: const #1u : u64
        let s_213_9: u64 = 1;
        // D s_213_10: and s_213_8 s_213_9
        let s_213_10: u64 = ((s_213_8) & (s_213_9));
        // D s_213_11: cmp-eq s_213_10 s_213_9
        let s_213_11: bool = ((s_213_10) == (s_213_9));
        // D s_213_12: lsl s_213_8 s_213_6
        let s_213_12: u64 = s_213_8 << s_213_6;
        // D s_213_13: or s_213_7 s_213_12
        let s_213_13: u64 = ((s_213_7) | (s_213_12));
        // D s_213_14: cmpl s_213_12
        let s_213_14: u64 = !s_213_12;
        // D s_213_15: and s_213_7 s_213_14
        let s_213_15: u64 = ((s_213_7) & (s_213_14));
        // D s_213_16: select s_213_11 s_213_13 s_213_15
        let s_213_16: u64 = if s_213_11 { s_213_13 } else { s_213_15 };
        // D s_213_17: cast trunc s_213_16 -> u8
        let s_213_17: bool = ((s_213_16) != 0);
        // D s_213_18: cast zx s_213_17 -> bv
        let s_213_18: Bits = Bits::new(s_213_17 as u128, 1u16);
        // C s_213_19: const #1u : u8
        let s_213_19: bool = true;
        // C s_213_20: cast zx s_213_19 -> bv
        let s_213_20: Bits = Bits::new(s_213_19 as u128, 1u16);
        // D s_213_21: cmp-ne s_213_18 s_213_20
        let s_213_21: bool = ((s_213_18) != (s_213_20));
        // D s_213_22: write-var gs#404444 <= s_213_21
        fn_state.gs_404444 = s_213_21;
        // N s_213_23: jump b214
        return block_214(state, tracer, fn_state);
    }
    fn block_214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_214_0: read-var gs#404444:u8
        let s_214_0: bool = fn_state.gs_404444;
        // N s_214_1: branch s_214_0 b234 b215
        if s_214_0 {
            return block_234(state, tracer, fn_state);
        } else {
            return block_215(state, tracer, fn_state);
        };
    }
    fn block_215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_215_0: const #18s : i
        let s_215_0: i128 = 18;
        // D s_215_1: read-var u#32454:u32
        let s_215_1: u32 = fn_state.u_32454;
        // D s_215_2: cast zx s_215_1 -> bv
        let s_215_2: Bits = Bits::new(s_215_1 as u128, 32u16);
        // C s_215_3: const #1u : u64
        let s_215_3: u64 = 1;
        // D s_215_4: bit-extract s_215_2 s_215_0 s_215_3
        let s_215_4: Bits = (Bits::new(
            ((s_215_2) >> (s_215_0)).value(),
            u16::try_from(s_215_3).unwrap(),
        ));
        // D s_215_5: cast reint s_215_4 -> u8
        let s_215_5: bool = ((s_215_4.value()) != 0);
        // C s_215_6: const #0s : i
        let s_215_6: i128 = 0;
        // C s_215_7: const #0u : u64
        let s_215_7: u64 = 0;
        // D s_215_8: cast zx s_215_5 -> u64
        let s_215_8: u64 = (s_215_5 as u64);
        // C s_215_9: const #1u : u64
        let s_215_9: u64 = 1;
        // D s_215_10: and s_215_8 s_215_9
        let s_215_10: u64 = ((s_215_8) & (s_215_9));
        // D s_215_11: cmp-eq s_215_10 s_215_9
        let s_215_11: bool = ((s_215_10) == (s_215_9));
        // D s_215_12: lsl s_215_8 s_215_6
        let s_215_12: u64 = s_215_8 << s_215_6;
        // D s_215_13: or s_215_7 s_215_12
        let s_215_13: u64 = ((s_215_7) | (s_215_12));
        // D s_215_14: cmpl s_215_12
        let s_215_14: u64 = !s_215_12;
        // D s_215_15: and s_215_7 s_215_14
        let s_215_15: u64 = ((s_215_7) & (s_215_14));
        // D s_215_16: select s_215_11 s_215_13 s_215_15
        let s_215_16: u64 = if s_215_11 { s_215_13 } else { s_215_15 };
        // D s_215_17: cast trunc s_215_16 -> u8
        let s_215_17: bool = ((s_215_16) != 0);
        // D s_215_18: cast zx s_215_17 -> bv
        let s_215_18: Bits = Bits::new(s_215_17 as u128, 1u16);
        // C s_215_19: const #1u : u8
        let s_215_19: bool = true;
        // C s_215_20: cast zx s_215_19 -> bv
        let s_215_20: Bits = Bits::new(s_215_19 as u128, 1u16);
        // D s_215_21: cmp-ne s_215_18 s_215_20
        let s_215_21: bool = ((s_215_18) != (s_215_20));
        // D s_215_22: write-var gs#404447 <= s_215_21
        fn_state.gs_404447 = s_215_21;
        // N s_215_23: jump b216
        return block_216(state, tracer, fn_state);
    }
    fn block_216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_216_0: read-var gs#404447:u8
        let s_216_0: bool = fn_state.gs_404447;
        // N s_216_1: branch s_216_0 b233 b217
        if s_216_0 {
            return block_233(state, tracer, fn_state);
        } else {
            return block_217(state, tracer, fn_state);
        };
    }
    fn block_217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_217_0: const #19s : i
        let s_217_0: i128 = 19;
        // D s_217_1: read-var u#32454:u32
        let s_217_1: u32 = fn_state.u_32454;
        // D s_217_2: cast zx s_217_1 -> bv
        let s_217_2: Bits = Bits::new(s_217_1 as u128, 32u16);
        // C s_217_3: const #1u : u64
        let s_217_3: u64 = 1;
        // D s_217_4: bit-extract s_217_2 s_217_0 s_217_3
        let s_217_4: Bits = (Bits::new(
            ((s_217_2) >> (s_217_0)).value(),
            u16::try_from(s_217_3).unwrap(),
        ));
        // D s_217_5: cast reint s_217_4 -> u8
        let s_217_5: bool = ((s_217_4.value()) != 0);
        // C s_217_6: const #0s : i
        let s_217_6: i128 = 0;
        // C s_217_7: const #0u : u64
        let s_217_7: u64 = 0;
        // D s_217_8: cast zx s_217_5 -> u64
        let s_217_8: u64 = (s_217_5 as u64);
        // C s_217_9: const #1u : u64
        let s_217_9: u64 = 1;
        // D s_217_10: and s_217_8 s_217_9
        let s_217_10: u64 = ((s_217_8) & (s_217_9));
        // D s_217_11: cmp-eq s_217_10 s_217_9
        let s_217_11: bool = ((s_217_10) == (s_217_9));
        // D s_217_12: lsl s_217_8 s_217_6
        let s_217_12: u64 = s_217_8 << s_217_6;
        // D s_217_13: or s_217_7 s_217_12
        let s_217_13: u64 = ((s_217_7) | (s_217_12));
        // D s_217_14: cmpl s_217_12
        let s_217_14: u64 = !s_217_12;
        // D s_217_15: and s_217_7 s_217_14
        let s_217_15: u64 = ((s_217_7) & (s_217_14));
        // D s_217_16: select s_217_11 s_217_13 s_217_15
        let s_217_16: u64 = if s_217_11 { s_217_13 } else { s_217_15 };
        // D s_217_17: cast trunc s_217_16 -> u8
        let s_217_17: bool = ((s_217_16) != 0);
        // D s_217_18: cast zx s_217_17 -> bv
        let s_217_18: Bits = Bits::new(s_217_17 as u128, 1u16);
        // C s_217_19: const #1u : u8
        let s_217_19: bool = true;
        // C s_217_20: cast zx s_217_19 -> bv
        let s_217_20: Bits = Bits::new(s_217_19 as u128, 1u16);
        // D s_217_21: cmp-ne s_217_18 s_217_20
        let s_217_21: bool = ((s_217_18) != (s_217_20));
        // D s_217_22: write-var gs#404450 <= s_217_21
        fn_state.gs_404450 = s_217_21;
        // N s_217_23: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_218_0: read-var gs#404450:u8
        let s_218_0: bool = fn_state.gs_404450;
        // N s_218_1: branch s_218_0 b232 b219
        if s_218_0 {
            return block_232(state, tracer, fn_state);
        } else {
            return block_219(state, tracer, fn_state);
        };
    }
    fn block_219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_219_0: const #8s : i
        let s_219_0: i128 = 8;
        // D s_219_1: read-var u#32454:u32
        let s_219_1: u32 = fn_state.u_32454;
        // D s_219_2: cast zx s_219_1 -> bv
        let s_219_2: Bits = Bits::new(s_219_1 as u128, 32u16);
        // C s_219_3: const #1u : u64
        let s_219_3: u64 = 1;
        // D s_219_4: bit-extract s_219_2 s_219_0 s_219_3
        let s_219_4: Bits = (Bits::new(
            ((s_219_2) >> (s_219_0)).value(),
            u16::try_from(s_219_3).unwrap(),
        ));
        // D s_219_5: cast reint s_219_4 -> u8
        let s_219_5: bool = ((s_219_4.value()) != 0);
        // C s_219_6: const #0s : i
        let s_219_6: i128 = 0;
        // C s_219_7: const #0u : u64
        let s_219_7: u64 = 0;
        // D s_219_8: cast zx s_219_5 -> u64
        let s_219_8: u64 = (s_219_5 as u64);
        // C s_219_9: const #1u : u64
        let s_219_9: u64 = 1;
        // D s_219_10: and s_219_8 s_219_9
        let s_219_10: u64 = ((s_219_8) & (s_219_9));
        // D s_219_11: cmp-eq s_219_10 s_219_9
        let s_219_11: bool = ((s_219_10) == (s_219_9));
        // D s_219_12: lsl s_219_8 s_219_6
        let s_219_12: u64 = s_219_8 << s_219_6;
        // D s_219_13: or s_219_7 s_219_12
        let s_219_13: u64 = ((s_219_7) | (s_219_12));
        // D s_219_14: cmpl s_219_12
        let s_219_14: u64 = !s_219_12;
        // D s_219_15: and s_219_7 s_219_14
        let s_219_15: u64 = ((s_219_7) & (s_219_14));
        // D s_219_16: select s_219_11 s_219_13 s_219_15
        let s_219_16: u64 = if s_219_11 { s_219_13 } else { s_219_15 };
        // D s_219_17: cast trunc s_219_16 -> u8
        let s_219_17: bool = ((s_219_16) != 0);
        // D s_219_18: cast zx s_219_17 -> bv
        let s_219_18: Bits = Bits::new(s_219_17 as u128, 1u16);
        // C s_219_19: const #1u : u8
        let s_219_19: bool = true;
        // C s_219_20: cast zx s_219_19 -> bv
        let s_219_20: Bits = Bits::new(s_219_19 as u128, 1u16);
        // D s_219_21: cmp-ne s_219_18 s_219_20
        let s_219_21: bool = ((s_219_18) != (s_219_20));
        // D s_219_22: write-var gs#404453 <= s_219_21
        fn_state.gs_404453 = s_219_21;
        // N s_219_23: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_220_0: read-var gs#404453:u8
        let s_220_0: bool = fn_state.gs_404453;
        // N s_220_1: branch s_220_0 b231 b221
        if s_220_0 {
            return block_231(state, tracer, fn_state);
        } else {
            return block_221(state, tracer, fn_state);
        };
    }
    fn block_221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_221_0: const #9s : i
        let s_221_0: i128 = 9;
        // D s_221_1: read-var u#32454:u32
        let s_221_1: u32 = fn_state.u_32454;
        // D s_221_2: cast zx s_221_1 -> bv
        let s_221_2: Bits = Bits::new(s_221_1 as u128, 32u16);
        // C s_221_3: const #1u : u64
        let s_221_3: u64 = 1;
        // D s_221_4: bit-extract s_221_2 s_221_0 s_221_3
        let s_221_4: Bits = (Bits::new(
            ((s_221_2) >> (s_221_0)).value(),
            u16::try_from(s_221_3).unwrap(),
        ));
        // D s_221_5: cast reint s_221_4 -> u8
        let s_221_5: bool = ((s_221_4.value()) != 0);
        // C s_221_6: const #0s : i
        let s_221_6: i128 = 0;
        // C s_221_7: const #0u : u64
        let s_221_7: u64 = 0;
        // D s_221_8: cast zx s_221_5 -> u64
        let s_221_8: u64 = (s_221_5 as u64);
        // C s_221_9: const #1u : u64
        let s_221_9: u64 = 1;
        // D s_221_10: and s_221_8 s_221_9
        let s_221_10: u64 = ((s_221_8) & (s_221_9));
        // D s_221_11: cmp-eq s_221_10 s_221_9
        let s_221_11: bool = ((s_221_10) == (s_221_9));
        // D s_221_12: lsl s_221_8 s_221_6
        let s_221_12: u64 = s_221_8 << s_221_6;
        // D s_221_13: or s_221_7 s_221_12
        let s_221_13: u64 = ((s_221_7) | (s_221_12));
        // D s_221_14: cmpl s_221_12
        let s_221_14: u64 = !s_221_12;
        // D s_221_15: and s_221_7 s_221_14
        let s_221_15: u64 = ((s_221_7) & (s_221_14));
        // D s_221_16: select s_221_11 s_221_13 s_221_15
        let s_221_16: u64 = if s_221_11 { s_221_13 } else { s_221_15 };
        // D s_221_17: cast trunc s_221_16 -> u8
        let s_221_17: bool = ((s_221_16) != 0);
        // D s_221_18: cast zx s_221_17 -> bv
        let s_221_18: Bits = Bits::new(s_221_17 as u128, 1u16);
        // C s_221_19: const #1u : u8
        let s_221_19: bool = true;
        // C s_221_20: cast zx s_221_19 -> bv
        let s_221_20: Bits = Bits::new(s_221_19 as u128, 1u16);
        // D s_221_21: cmp-ne s_221_18 s_221_20
        let s_221_21: bool = ((s_221_18) != (s_221_20));
        // D s_221_22: write-var gs#404456 <= s_221_21
        fn_state.gs_404456 = s_221_21;
        // N s_221_23: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_222_0: read-var gs#404456:u8
        let s_222_0: bool = fn_state.gs_404456;
        // N s_222_1: branch s_222_0 b230 b223
        if s_222_0 {
            return block_230(state, tracer, fn_state);
        } else {
            return block_223(state, tracer, fn_state);
        };
    }
    fn block_223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_223_0: const #10s : i
        let s_223_0: i128 = 10;
        // D s_223_1: read-var u#32454:u32
        let s_223_1: u32 = fn_state.u_32454;
        // D s_223_2: cast zx s_223_1 -> bv
        let s_223_2: Bits = Bits::new(s_223_1 as u128, 32u16);
        // C s_223_3: const #1u : u64
        let s_223_3: u64 = 1;
        // D s_223_4: bit-extract s_223_2 s_223_0 s_223_3
        let s_223_4: Bits = (Bits::new(
            ((s_223_2) >> (s_223_0)).value(),
            u16::try_from(s_223_3).unwrap(),
        ));
        // D s_223_5: cast reint s_223_4 -> u8
        let s_223_5: bool = ((s_223_4.value()) != 0);
        // C s_223_6: const #0s : i
        let s_223_6: i128 = 0;
        // C s_223_7: const #0u : u64
        let s_223_7: u64 = 0;
        // D s_223_8: cast zx s_223_5 -> u64
        let s_223_8: u64 = (s_223_5 as u64);
        // C s_223_9: const #1u : u64
        let s_223_9: u64 = 1;
        // D s_223_10: and s_223_8 s_223_9
        let s_223_10: u64 = ((s_223_8) & (s_223_9));
        // D s_223_11: cmp-eq s_223_10 s_223_9
        let s_223_11: bool = ((s_223_10) == (s_223_9));
        // D s_223_12: lsl s_223_8 s_223_6
        let s_223_12: u64 = s_223_8 << s_223_6;
        // D s_223_13: or s_223_7 s_223_12
        let s_223_13: u64 = ((s_223_7) | (s_223_12));
        // D s_223_14: cmpl s_223_12
        let s_223_14: u64 = !s_223_12;
        // D s_223_15: and s_223_7 s_223_14
        let s_223_15: u64 = ((s_223_7) & (s_223_14));
        // D s_223_16: select s_223_11 s_223_13 s_223_15
        let s_223_16: u64 = if s_223_11 { s_223_13 } else { s_223_15 };
        // D s_223_17: cast trunc s_223_16 -> u8
        let s_223_17: bool = ((s_223_16) != 0);
        // D s_223_18: cast zx s_223_17 -> bv
        let s_223_18: Bits = Bits::new(s_223_17 as u128, 1u16);
        // C s_223_19: const #1u : u8
        let s_223_19: bool = true;
        // C s_223_20: cast zx s_223_19 -> bv
        let s_223_20: Bits = Bits::new(s_223_19 as u128, 1u16);
        // D s_223_21: cmp-ne s_223_18 s_223_20
        let s_223_21: bool = ((s_223_18) != (s_223_20));
        // D s_223_22: write-var gs#404459 <= s_223_21
        fn_state.gs_404459 = s_223_21;
        // N s_223_23: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_224_0: read-var gs#404459:u8
        let s_224_0: bool = fn_state.gs_404459;
        // N s_224_1: branch s_224_0 b229 b225
        if s_224_0 {
            return block_229(state, tracer, fn_state);
        } else {
            return block_225(state, tracer, fn_state);
        };
    }
    fn block_225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_225_0: const #11s : i
        let s_225_0: i128 = 11;
        // D s_225_1: read-var u#32454:u32
        let s_225_1: u32 = fn_state.u_32454;
        // D s_225_2: cast zx s_225_1 -> bv
        let s_225_2: Bits = Bits::new(s_225_1 as u128, 32u16);
        // C s_225_3: const #1u : u64
        let s_225_3: u64 = 1;
        // D s_225_4: bit-extract s_225_2 s_225_0 s_225_3
        let s_225_4: Bits = (Bits::new(
            ((s_225_2) >> (s_225_0)).value(),
            u16::try_from(s_225_3).unwrap(),
        ));
        // D s_225_5: cast reint s_225_4 -> u8
        let s_225_5: bool = ((s_225_4.value()) != 0);
        // C s_225_6: const #0s : i
        let s_225_6: i128 = 0;
        // C s_225_7: const #0u : u64
        let s_225_7: u64 = 0;
        // D s_225_8: cast zx s_225_5 -> u64
        let s_225_8: u64 = (s_225_5 as u64);
        // C s_225_9: const #1u : u64
        let s_225_9: u64 = 1;
        // D s_225_10: and s_225_8 s_225_9
        let s_225_10: u64 = ((s_225_8) & (s_225_9));
        // D s_225_11: cmp-eq s_225_10 s_225_9
        let s_225_11: bool = ((s_225_10) == (s_225_9));
        // D s_225_12: lsl s_225_8 s_225_6
        let s_225_12: u64 = s_225_8 << s_225_6;
        // D s_225_13: or s_225_7 s_225_12
        let s_225_13: u64 = ((s_225_7) | (s_225_12));
        // D s_225_14: cmpl s_225_12
        let s_225_14: u64 = !s_225_12;
        // D s_225_15: and s_225_7 s_225_14
        let s_225_15: u64 = ((s_225_7) & (s_225_14));
        // D s_225_16: select s_225_11 s_225_13 s_225_15
        let s_225_16: u64 = if s_225_11 { s_225_13 } else { s_225_15 };
        // D s_225_17: cast trunc s_225_16 -> u8
        let s_225_17: bool = ((s_225_16) != 0);
        // D s_225_18: cast zx s_225_17 -> bv
        let s_225_18: Bits = Bits::new(s_225_17 as u128, 1u16);
        // C s_225_19: const #1u : u8
        let s_225_19: bool = true;
        // C s_225_20: cast zx s_225_19 -> bv
        let s_225_20: Bits = Bits::new(s_225_19 as u128, 1u16);
        // D s_225_21: cmp-ne s_225_18 s_225_20
        let s_225_21: bool = ((s_225_18) != (s_225_20));
        // D s_225_22: write-var gs#404462 <= s_225_21
        fn_state.gs_404462 = s_225_21;
        // N s_225_23: jump b226
        return block_226(state, tracer, fn_state);
    }
    fn block_226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_226_0: read-var gs#404462:u8
        let s_226_0: bool = fn_state.gs_404462;
        // N s_226_1: branch s_226_0 b228 b227
        if s_226_0 {
            return block_228(state, tracer, fn_state);
        } else {
            return block_227(state, tracer, fn_state);
        };
    }
    fn block_227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_227_0: read-var u#32455:u8
        let s_227_0: u8 = fn_state.u_32455;
        // D s_227_1: read-var u#32456:u8
        let s_227_1: u8 = fn_state.u_32456;
        // D s_227_2: read-var u#32457:u8
        let s_227_2: u8 = fn_state.u_32457;
        // D s_227_3: call decode_aarch32_instrs_CLZ_A1enc_A_txt(s_227_0, s_227_1, s_227_2)
        let s_227_3: () = decode_aarch32_instrs_CLZ_A1enc_A_txt(
            state,
            tracer,
            s_227_0,
            s_227_1,
            s_227_2,
        );
        // N s_227_4: return
        return;
    }
    fn block_228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_228_0: panic
        panic!("{:?}", ());
        // N s_228_1: return
        return;
    }
    fn block_229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_229_0: const #1u : u8
        let s_229_0: bool = true;
        // D s_229_1: write-var gs#404462 <= s_229_0
        fn_state.gs_404462 = s_229_0;
        // N s_229_2: jump b226
        return block_226(state, tracer, fn_state);
    }
    fn block_230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_230_0: const #1u : u8
        let s_230_0: bool = true;
        // D s_230_1: write-var gs#404459 <= s_230_0
        fn_state.gs_404459 = s_230_0;
        // N s_230_2: jump b224
        return block_224(state, tracer, fn_state);
    }
    fn block_231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_231_0: const #1u : u8
        let s_231_0: bool = true;
        // D s_231_1: write-var gs#404456 <= s_231_0
        fn_state.gs_404456 = s_231_0;
        // N s_231_2: jump b222
        return block_222(state, tracer, fn_state);
    }
    fn block_232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_232_0: const #1u : u8
        let s_232_0: bool = true;
        // D s_232_1: write-var gs#404453 <= s_232_0
        fn_state.gs_404453 = s_232_0;
        // N s_232_2: jump b220
        return block_220(state, tracer, fn_state);
    }
    fn block_233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_233_0: const #1u : u8
        let s_233_0: bool = true;
        // D s_233_1: write-var gs#404450 <= s_233_0
        fn_state.gs_404450 = s_233_0;
        // N s_233_2: jump b218
        return block_218(state, tracer, fn_state);
    }
    fn block_234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_234_0: const #1u : u8
        let s_234_0: bool = true;
        // D s_234_1: write-var gs#404447 <= s_234_0
        fn_state.gs_404447 = s_234_0;
        // N s_234_2: jump b216
        return block_216(state, tracer, fn_state);
    }
    fn block_235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_235_0: const #1u : u8
        let s_235_0: bool = true;
        // D s_235_1: write-var gs#404444 <= s_235_0
        fn_state.gs_404444 = s_235_0;
        // N s_235_2: jump b214
        return block_214(state, tracer, fn_state);
    }
    fn block_236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_236_0: read-var merge#var.1:struct
        let s_236_0: u32 = fn_state.merge_var._1;
        // D s_236_1: write-var u#32459 <= s_236_0
        fn_state.u_32459 = s_236_0;
        // C s_236_2: const #20s : i
        let s_236_2: i128 = 20;
        // D s_236_3: read-var u#32459:u32
        let s_236_3: u32 = fn_state.u_32459;
        // D s_236_4: cast zx s_236_3 -> bv
        let s_236_4: Bits = Bits::new(s_236_3 as u128, 32u16);
        // C s_236_5: const #1s : i64
        let s_236_5: i64 = 1;
        // C s_236_6: cast zx s_236_5 -> i
        let s_236_6: i128 = (i128::try_from(s_236_5).unwrap());
        // C s_236_7: const #7s : i
        let s_236_7: i128 = 7;
        // C s_236_8: add s_236_7 s_236_6
        let s_236_8: i128 = (s_236_7 + s_236_6);
        // D s_236_9: bit-extract s_236_4 s_236_2 s_236_8
        let s_236_9: Bits = (Bits::new(
            ((s_236_4) >> (s_236_2)).value(),
            u16::try_from(s_236_8).unwrap(),
        ));
        // D s_236_10: cast reint s_236_9 -> u8
        let s_236_10: u8 = (s_236_9.value() as u8);
        // D s_236_11: cast zx s_236_10 -> bv
        let s_236_11: Bits = Bits::new(s_236_10 as u128, 8u16);
        // C s_236_12: const #55u : u8
        let s_236_12: u8 = 55;
        // C s_236_13: cast zx s_236_12 -> bv
        let s_236_13: Bits = Bits::new(s_236_12 as u128, 8u16);
        // D s_236_14: cmp-eq s_236_11 s_236_13
        let s_236_14: bool = ((s_236_11) == (s_236_13));
        // N s_236_15: branch s_236_14 b2888 b237
        if s_236_14 {
            return block_2888(state, tracer, fn_state);
        } else {
            return block_237(state, tracer, fn_state);
        };
    }
    fn block_237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_237_0: const #0u : u8
        let s_237_0: bool = false;
        // D s_237_1: write-var gs#404468 <= s_237_0
        fn_state.gs_404468 = s_237_0;
        // N s_237_2: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_238_0: read-var gs#404468:u8
        let s_238_0: bool = fn_state.gs_404468;
        // N s_238_1: branch s_238_0 b2884 b239
        if s_238_0 {
            return block_2884(state, tracer, fn_state);
        } else {
            return block_239(state, tracer, fn_state);
        };
    }
    fn block_239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_239_0: const #0u : u8
        let s_239_0: bool = false;
        // D s_239_1: write-var gs#404473 <= s_239_0
        fn_state.gs_404473 = s_239_0;
        // N s_239_2: jump b240
        return block_240(state, tracer, fn_state);
    }
    fn block_240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_240_0: read-var gs#404473:u8
        let s_240_0: bool = fn_state.gs_404473;
        // D s_240_1: not s_240_0
        let s_240_1: bool = !s_240_0;
        // N s_240_2: branch s_240_1 b253 b241
        if s_240_1 {
            return block_253(state, tracer, fn_state);
        } else {
            return block_241(state, tracer, fn_state);
        };
    }
    fn block_241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_241_0: const #2883s : i
        let s_241_0: i128 = 2883;
        // C s_241_1: const #14696u : u32
        let s_241_1: u32 = 14696;
        // N s_241_2: write-reg s_241_1 <= s_241_0
        let s_241_2: () = {
            state.write_register::<i128>(s_241_1 as isize, s_241_0);
            tracer.write_register(s_241_1 as isize, s_241_0);
        };
        // C s_241_3: const #28s : i
        let s_241_3: i128 = 28;
        // C s_241_4: const #4s : i
        let s_241_4: i128 = 4;
        // D s_241_5: read-var u#32459:u32
        let s_241_5: u32 = fn_state.u_32459;
        // D s_241_6: cast zx s_241_5 -> bv
        let s_241_6: Bits = Bits::new(s_241_5 as u128, 32u16);
        // D s_241_7: bit-extract s_241_6 s_241_3 s_241_4
        let s_241_7: Bits = (Bits::new(
            ((s_241_6) >> (s_241_3)).value(),
            u16::try_from(s_241_4).unwrap(),
        ));
        // D s_241_8: cast reint s_241_7 -> u8
        let s_241_8: u8 = (s_241_7.value() as u8);
        // D s_241_9: write-var u#32460 <= s_241_8
        fn_state.u_32460 = s_241_8;
        // C s_241_10: const #16s : i
        let s_241_10: i128 = 16;
        // C s_241_11: const #4s : i
        let s_241_11: i128 = 4;
        // D s_241_12: read-var u#32459:u32
        let s_241_12: u32 = fn_state.u_32459;
        // D s_241_13: cast zx s_241_12 -> bv
        let s_241_13: Bits = Bits::new(s_241_12 as u128, 32u16);
        // D s_241_14: bit-extract s_241_13 s_241_10 s_241_11
        let s_241_14: Bits = (Bits::new(
            ((s_241_13) >> (s_241_10)).value(),
            u16::try_from(s_241_11).unwrap(),
        ));
        // D s_241_15: cast reint s_241_14 -> u8
        let s_241_15: u8 = (s_241_14.value() as u8);
        // D s_241_16: write-var u#32461 <= s_241_15
        fn_state.u_32461 = s_241_15;
        // C s_241_17: const #0s : i
        let s_241_17: i128 = 0;
        // C s_241_18: const #12s : i
        let s_241_18: i128 = 12;
        // D s_241_19: read-var u#32459:u32
        let s_241_19: u32 = fn_state.u_32459;
        // D s_241_20: cast zx s_241_19 -> bv
        let s_241_20: Bits = Bits::new(s_241_19 as u128, 32u16);
        // D s_241_21: bit-extract s_241_20 s_241_17 s_241_18
        let s_241_21: Bits = (Bits::new(
            ((s_241_20) >> (s_241_17)).value(),
            u16::try_from(s_241_18).unwrap(),
        ));
        // D s_241_22: cast reint s_241_21 -> u12
        let s_241_22: u16 = (s_241_21.value() as u16);
        // D s_241_23: write-var u#32462 <= s_241_22
        fn_state.u_32462 = s_241_22;
        // C s_241_24: const #12s : i
        let s_241_24: i128 = 12;
        // D s_241_25: read-var u#32459:u32
        let s_241_25: u32 = fn_state.u_32459;
        // D s_241_26: cast zx s_241_25 -> bv
        let s_241_26: Bits = Bits::new(s_241_25 as u128, 32u16);
        // C s_241_27: const #1u : u64
        let s_241_27: u64 = 1;
        // D s_241_28: bit-extract s_241_26 s_241_24 s_241_27
        let s_241_28: Bits = (Bits::new(
            ((s_241_26) >> (s_241_24)).value(),
            u16::try_from(s_241_27).unwrap(),
        ));
        // D s_241_29: cast reint s_241_28 -> u8
        let s_241_29: bool = ((s_241_28.value()) != 0);
        // C s_241_30: const #0s : i
        let s_241_30: i128 = 0;
        // C s_241_31: const #0u : u64
        let s_241_31: u64 = 0;
        // D s_241_32: cast zx s_241_29 -> u64
        let s_241_32: u64 = (s_241_29 as u64);
        // C s_241_33: const #1u : u64
        let s_241_33: u64 = 1;
        // D s_241_34: and s_241_32 s_241_33
        let s_241_34: u64 = ((s_241_32) & (s_241_33));
        // D s_241_35: cmp-eq s_241_34 s_241_33
        let s_241_35: bool = ((s_241_34) == (s_241_33));
        // D s_241_36: lsl s_241_32 s_241_30
        let s_241_36: u64 = s_241_32 << s_241_30;
        // D s_241_37: or s_241_31 s_241_36
        let s_241_37: u64 = ((s_241_31) | (s_241_36));
        // D s_241_38: cmpl s_241_36
        let s_241_38: u64 = !s_241_36;
        // D s_241_39: and s_241_31 s_241_38
        let s_241_39: u64 = ((s_241_31) & (s_241_38));
        // D s_241_40: select s_241_35 s_241_37 s_241_39
        let s_241_40: u64 = if s_241_35 { s_241_37 } else { s_241_39 };
        // D s_241_41: cast trunc s_241_40 -> u8
        let s_241_41: bool = ((s_241_40) != 0);
        // D s_241_42: cast zx s_241_41 -> bv
        let s_241_42: Bits = Bits::new(s_241_41 as u128, 1u16);
        // C s_241_43: const #0u : u8
        let s_241_43: bool = false;
        // C s_241_44: cast zx s_241_43 -> bv
        let s_241_44: Bits = Bits::new(s_241_43 as u128, 1u16);
        // D s_241_45: cmp-ne s_241_42 s_241_44
        let s_241_45: bool = ((s_241_42) != (s_241_44));
        // N s_241_46: branch s_241_45 b252 b242
        if s_241_45 {
            return block_252(state, tracer, fn_state);
        } else {
            return block_242(state, tracer, fn_state);
        };
    }
    fn block_242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_242_0: const #13s : i
        let s_242_0: i128 = 13;
        // D s_242_1: read-var u#32459:u32
        let s_242_1: u32 = fn_state.u_32459;
        // D s_242_2: cast zx s_242_1 -> bv
        let s_242_2: Bits = Bits::new(s_242_1 as u128, 32u16);
        // C s_242_3: const #1u : u64
        let s_242_3: u64 = 1;
        // D s_242_4: bit-extract s_242_2 s_242_0 s_242_3
        let s_242_4: Bits = (Bits::new(
            ((s_242_2) >> (s_242_0)).value(),
            u16::try_from(s_242_3).unwrap(),
        ));
        // D s_242_5: cast reint s_242_4 -> u8
        let s_242_5: bool = ((s_242_4.value()) != 0);
        // C s_242_6: const #0s : i
        let s_242_6: i128 = 0;
        // C s_242_7: const #0u : u64
        let s_242_7: u64 = 0;
        // D s_242_8: cast zx s_242_5 -> u64
        let s_242_8: u64 = (s_242_5 as u64);
        // C s_242_9: const #1u : u64
        let s_242_9: u64 = 1;
        // D s_242_10: and s_242_8 s_242_9
        let s_242_10: u64 = ((s_242_8) & (s_242_9));
        // D s_242_11: cmp-eq s_242_10 s_242_9
        let s_242_11: bool = ((s_242_10) == (s_242_9));
        // D s_242_12: lsl s_242_8 s_242_6
        let s_242_12: u64 = s_242_8 << s_242_6;
        // D s_242_13: or s_242_7 s_242_12
        let s_242_13: u64 = ((s_242_7) | (s_242_12));
        // D s_242_14: cmpl s_242_12
        let s_242_14: u64 = !s_242_12;
        // D s_242_15: and s_242_7 s_242_14
        let s_242_15: u64 = ((s_242_7) & (s_242_14));
        // D s_242_16: select s_242_11 s_242_13 s_242_15
        let s_242_16: u64 = if s_242_11 { s_242_13 } else { s_242_15 };
        // D s_242_17: cast trunc s_242_16 -> u8
        let s_242_17: bool = ((s_242_16) != 0);
        // D s_242_18: cast zx s_242_17 -> bv
        let s_242_18: Bits = Bits::new(s_242_17 as u128, 1u16);
        // C s_242_19: const #0u : u8
        let s_242_19: bool = false;
        // C s_242_20: cast zx s_242_19 -> bv
        let s_242_20: Bits = Bits::new(s_242_19 as u128, 1u16);
        // D s_242_21: cmp-ne s_242_18 s_242_20
        let s_242_21: bool = ((s_242_18) != (s_242_20));
        // D s_242_22: write-var gs#404486 <= s_242_21
        fn_state.gs_404486 = s_242_21;
        // N s_242_23: jump b243
        return block_243(state, tracer, fn_state);
    }
    fn block_243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_243_0: read-var gs#404486:u8
        let s_243_0: bool = fn_state.gs_404486;
        // N s_243_1: branch s_243_0 b251 b244
        if s_243_0 {
            return block_251(state, tracer, fn_state);
        } else {
            return block_244(state, tracer, fn_state);
        };
    }
    fn block_244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_244_0: const #14s : i
        let s_244_0: i128 = 14;
        // D s_244_1: read-var u#32459:u32
        let s_244_1: u32 = fn_state.u_32459;
        // D s_244_2: cast zx s_244_1 -> bv
        let s_244_2: Bits = Bits::new(s_244_1 as u128, 32u16);
        // C s_244_3: const #1u : u64
        let s_244_3: u64 = 1;
        // D s_244_4: bit-extract s_244_2 s_244_0 s_244_3
        let s_244_4: Bits = (Bits::new(
            ((s_244_2) >> (s_244_0)).value(),
            u16::try_from(s_244_3).unwrap(),
        ));
        // D s_244_5: cast reint s_244_4 -> u8
        let s_244_5: bool = ((s_244_4.value()) != 0);
        // C s_244_6: const #0s : i
        let s_244_6: i128 = 0;
        // C s_244_7: const #0u : u64
        let s_244_7: u64 = 0;
        // D s_244_8: cast zx s_244_5 -> u64
        let s_244_8: u64 = (s_244_5 as u64);
        // C s_244_9: const #1u : u64
        let s_244_9: u64 = 1;
        // D s_244_10: and s_244_8 s_244_9
        let s_244_10: u64 = ((s_244_8) & (s_244_9));
        // D s_244_11: cmp-eq s_244_10 s_244_9
        let s_244_11: bool = ((s_244_10) == (s_244_9));
        // D s_244_12: lsl s_244_8 s_244_6
        let s_244_12: u64 = s_244_8 << s_244_6;
        // D s_244_13: or s_244_7 s_244_12
        let s_244_13: u64 = ((s_244_7) | (s_244_12));
        // D s_244_14: cmpl s_244_12
        let s_244_14: u64 = !s_244_12;
        // D s_244_15: and s_244_7 s_244_14
        let s_244_15: u64 = ((s_244_7) & (s_244_14));
        // D s_244_16: select s_244_11 s_244_13 s_244_15
        let s_244_16: u64 = if s_244_11 { s_244_13 } else { s_244_15 };
        // D s_244_17: cast trunc s_244_16 -> u8
        let s_244_17: bool = ((s_244_16) != 0);
        // D s_244_18: cast zx s_244_17 -> bv
        let s_244_18: Bits = Bits::new(s_244_17 as u128, 1u16);
        // C s_244_19: const #0u : u8
        let s_244_19: bool = false;
        // C s_244_20: cast zx s_244_19 -> bv
        let s_244_20: Bits = Bits::new(s_244_19 as u128, 1u16);
        // D s_244_21: cmp-ne s_244_18 s_244_20
        let s_244_21: bool = ((s_244_18) != (s_244_20));
        // D s_244_22: write-var gs#404489 <= s_244_21
        fn_state.gs_404489 = s_244_21;
        // N s_244_23: jump b245
        return block_245(state, tracer, fn_state);
    }
    fn block_245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_245_0: read-var gs#404489:u8
        let s_245_0: bool = fn_state.gs_404489;
        // N s_245_1: branch s_245_0 b250 b246
        if s_245_0 {
            return block_250(state, tracer, fn_state);
        } else {
            return block_246(state, tracer, fn_state);
        };
    }
    fn block_246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_246_0: const #15s : i
        let s_246_0: i128 = 15;
        // D s_246_1: read-var u#32459:u32
        let s_246_1: u32 = fn_state.u_32459;
        // D s_246_2: cast zx s_246_1 -> bv
        let s_246_2: Bits = Bits::new(s_246_1 as u128, 32u16);
        // C s_246_3: const #1u : u64
        let s_246_3: u64 = 1;
        // D s_246_4: bit-extract s_246_2 s_246_0 s_246_3
        let s_246_4: Bits = (Bits::new(
            ((s_246_2) >> (s_246_0)).value(),
            u16::try_from(s_246_3).unwrap(),
        ));
        // D s_246_5: cast reint s_246_4 -> u8
        let s_246_5: bool = ((s_246_4.value()) != 0);
        // C s_246_6: const #0s : i
        let s_246_6: i128 = 0;
        // C s_246_7: const #0u : u64
        let s_246_7: u64 = 0;
        // D s_246_8: cast zx s_246_5 -> u64
        let s_246_8: u64 = (s_246_5 as u64);
        // C s_246_9: const #1u : u64
        let s_246_9: u64 = 1;
        // D s_246_10: and s_246_8 s_246_9
        let s_246_10: u64 = ((s_246_8) & (s_246_9));
        // D s_246_11: cmp-eq s_246_10 s_246_9
        let s_246_11: bool = ((s_246_10) == (s_246_9));
        // D s_246_12: lsl s_246_8 s_246_6
        let s_246_12: u64 = s_246_8 << s_246_6;
        // D s_246_13: or s_246_7 s_246_12
        let s_246_13: u64 = ((s_246_7) | (s_246_12));
        // D s_246_14: cmpl s_246_12
        let s_246_14: u64 = !s_246_12;
        // D s_246_15: and s_246_7 s_246_14
        let s_246_15: u64 = ((s_246_7) & (s_246_14));
        // D s_246_16: select s_246_11 s_246_13 s_246_15
        let s_246_16: u64 = if s_246_11 { s_246_13 } else { s_246_15 };
        // D s_246_17: cast trunc s_246_16 -> u8
        let s_246_17: bool = ((s_246_16) != 0);
        // D s_246_18: cast zx s_246_17 -> bv
        let s_246_18: Bits = Bits::new(s_246_17 as u128, 1u16);
        // C s_246_19: const #0u : u8
        let s_246_19: bool = false;
        // C s_246_20: cast zx s_246_19 -> bv
        let s_246_20: Bits = Bits::new(s_246_19 as u128, 1u16);
        // D s_246_21: cmp-ne s_246_18 s_246_20
        let s_246_21: bool = ((s_246_18) != (s_246_20));
        // D s_246_22: write-var gs#404492 <= s_246_21
        fn_state.gs_404492 = s_246_21;
        // N s_246_23: jump b247
        return block_247(state, tracer, fn_state);
    }
    fn block_247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_247_0: read-var gs#404492:u8
        let s_247_0: bool = fn_state.gs_404492;
        // N s_247_1: branch s_247_0 b249 b248
        if s_247_0 {
            return block_249(state, tracer, fn_state);
        } else {
            return block_248(state, tracer, fn_state);
        };
    }
    fn block_248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_248_0: read-var u#32460:u8
        let s_248_0: u8 = fn_state.u_32460;
        // D s_248_1: read-var u#32461:u8
        let s_248_1: u8 = fn_state.u_32461;
        // D s_248_2: read-var u#32462:u12
        let s_248_2: u16 = fn_state.u_32462;
        // D s_248_3: call decode_aarch32_instrs_CMN_i_A1enc_A_txt(s_248_0, s_248_1, s_248_2)
        let s_248_3: () = decode_aarch32_instrs_CMN_i_A1enc_A_txt(
            state,
            tracer,
            s_248_0,
            s_248_1,
            s_248_2,
        );
        // N s_248_4: return
        return;
    }
    fn block_249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_249_0: panic
        panic!("{:?}", ());
        // N s_249_1: return
        return;
    }
    fn block_250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_250_0: const #1u : u8
        let s_250_0: bool = true;
        // D s_250_1: write-var gs#404492 <= s_250_0
        fn_state.gs_404492 = s_250_0;
        // N s_250_2: jump b247
        return block_247(state, tracer, fn_state);
    }
    fn block_251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_251_0: const #1u : u8
        let s_251_0: bool = true;
        // D s_251_1: write-var gs#404489 <= s_251_0
        fn_state.gs_404489 = s_251_0;
        // N s_251_2: jump b245
        return block_245(state, tracer, fn_state);
    }
    fn block_252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_252_0: const #1u : u8
        let s_252_0: bool = true;
        // D s_252_1: write-var gs#404486 <= s_252_0
        fn_state.gs_404486 = s_252_0;
        // N s_252_2: jump b243
        return block_243(state, tracer, fn_state);
    }
    fn block_253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_253_0: read-var merge#var.1:struct
        let s_253_0: u32 = fn_state.merge_var._1;
        // D s_253_1: write-var u#32464 <= s_253_0
        fn_state.u_32464 = s_253_0;
        // C s_253_2: const #20s : i
        let s_253_2: i128 = 20;
        // D s_253_3: read-var u#32464:u32
        let s_253_3: u32 = fn_state.u_32464;
        // D s_253_4: cast zx s_253_3 -> bv
        let s_253_4: Bits = Bits::new(s_253_3 as u128, 32u16);
        // C s_253_5: const #1s : i64
        let s_253_5: i64 = 1;
        // C s_253_6: cast zx s_253_5 -> i
        let s_253_6: i128 = (i128::try_from(s_253_5).unwrap());
        // C s_253_7: const #7s : i
        let s_253_7: i128 = 7;
        // C s_253_8: add s_253_7 s_253_6
        let s_253_8: i128 = (s_253_7 + s_253_6);
        // D s_253_9: bit-extract s_253_4 s_253_2 s_253_8
        let s_253_9: Bits = (Bits::new(
            ((s_253_4) >> (s_253_2)).value(),
            u16::try_from(s_253_8).unwrap(),
        ));
        // D s_253_10: cast reint s_253_9 -> u8
        let s_253_10: u8 = (s_253_9.value() as u8);
        // D s_253_11: cast zx s_253_10 -> bv
        let s_253_11: Bits = Bits::new(s_253_10 as u128, 8u16);
        // C s_253_12: const #23u : u8
        let s_253_12: u8 = 23;
        // C s_253_13: cast zx s_253_12 -> bv
        let s_253_13: Bits = Bits::new(s_253_12 as u128, 8u16);
        // D s_253_14: cmp-eq s_253_11 s_253_13
        let s_253_14: bool = ((s_253_11) == (s_253_13));
        // N s_253_15: branch s_253_14 b2880 b254
        if s_253_14 {
            return block_2880(state, tracer, fn_state);
        } else {
            return block_254(state, tracer, fn_state);
        };
    }
    fn block_254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_254_0: const #0u : u8
        let s_254_0: bool = false;
        // D s_254_1: write-var gs#404501 <= s_254_0
        fn_state.gs_404501 = s_254_0;
        // N s_254_2: jump b255
        return block_255(state, tracer, fn_state);
    }
    fn block_255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_255_0: read-var gs#404501:u8
        let s_255_0: bool = fn_state.gs_404501;
        // N s_255_1: branch s_255_0 b2876 b256
        if s_255_0 {
            return block_2876(state, tracer, fn_state);
        } else {
            return block_256(state, tracer, fn_state);
        };
    }
    fn block_256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_256_0: const #0u : u8
        let s_256_0: bool = false;
        // D s_256_1: write-var gs#404506 <= s_256_0
        fn_state.gs_404506 = s_256_0;
        // N s_256_2: jump b257
        return block_257(state, tracer, fn_state);
    }
    fn block_257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_257_0: read-var gs#404506:u8
        let s_257_0: bool = fn_state.gs_404506;
        // D s_257_1: not s_257_0
        let s_257_1: bool = !s_257_0;
        // N s_257_2: branch s_257_1 b270 b258
        if s_257_1 {
            return block_270(state, tracer, fn_state);
        } else {
            return block_258(state, tracer, fn_state);
        };
    }
    fn block_258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_258_0: const #2885s : i
        let s_258_0: i128 = 2885;
        // C s_258_1: const #14696u : u32
        let s_258_1: u32 = 14696;
        // N s_258_2: write-reg s_258_1 <= s_258_0
        let s_258_2: () = {
            state.write_register::<i128>(s_258_1 as isize, s_258_0);
            tracer.write_register(s_258_1 as isize, s_258_0);
        };
        // C s_258_3: const #28s : i
        let s_258_3: i128 = 28;
        // C s_258_4: const #4s : i
        let s_258_4: i128 = 4;
        // D s_258_5: read-var u#32464:u32
        let s_258_5: u32 = fn_state.u_32464;
        // D s_258_6: cast zx s_258_5 -> bv
        let s_258_6: Bits = Bits::new(s_258_5 as u128, 32u16);
        // D s_258_7: bit-extract s_258_6 s_258_3 s_258_4
        let s_258_7: Bits = (Bits::new(
            ((s_258_6) >> (s_258_3)).value(),
            u16::try_from(s_258_4).unwrap(),
        ));
        // D s_258_8: cast reint s_258_7 -> u8
        let s_258_8: u8 = (s_258_7.value() as u8);
        // D s_258_9: write-var u#32465 <= s_258_8
        fn_state.u_32465 = s_258_8;
        // C s_258_10: const #16s : i
        let s_258_10: i128 = 16;
        // C s_258_11: const #4s : i
        let s_258_11: i128 = 4;
        // D s_258_12: read-var u#32464:u32
        let s_258_12: u32 = fn_state.u_32464;
        // D s_258_13: cast zx s_258_12 -> bv
        let s_258_13: Bits = Bits::new(s_258_12 as u128, 32u16);
        // D s_258_14: bit-extract s_258_13 s_258_10 s_258_11
        let s_258_14: Bits = (Bits::new(
            ((s_258_13) >> (s_258_10)).value(),
            u16::try_from(s_258_11).unwrap(),
        ));
        // D s_258_15: cast reint s_258_14 -> u8
        let s_258_15: u8 = (s_258_14.value() as u8);
        // D s_258_16: write-var u#32466 <= s_258_15
        fn_state.u_32466 = s_258_15;
        // C s_258_17: const #7s : i
        let s_258_17: i128 = 7;
        // C s_258_18: const #5s : i
        let s_258_18: i128 = 5;
        // D s_258_19: read-var u#32464:u32
        let s_258_19: u32 = fn_state.u_32464;
        // D s_258_20: cast zx s_258_19 -> bv
        let s_258_20: Bits = Bits::new(s_258_19 as u128, 32u16);
        // D s_258_21: bit-extract s_258_20 s_258_17 s_258_18
        let s_258_21: Bits = (Bits::new(
            ((s_258_20) >> (s_258_17)).value(),
            u16::try_from(s_258_18).unwrap(),
        ));
        // D s_258_22: cast reint s_258_21 -> u8
        let s_258_22: u8 = (s_258_21.value() as u8);
        // D s_258_23: write-var u#32467 <= s_258_22
        fn_state.u_32467 = s_258_22;
        // C s_258_24: const #5s : i
        let s_258_24: i128 = 5;
        // C s_258_25: const #2s : i
        let s_258_25: i128 = 2;
        // D s_258_26: read-var u#32464:u32
        let s_258_26: u32 = fn_state.u_32464;
        // D s_258_27: cast zx s_258_26 -> bv
        let s_258_27: Bits = Bits::new(s_258_26 as u128, 32u16);
        // D s_258_28: bit-extract s_258_27 s_258_24 s_258_25
        let s_258_28: Bits = (Bits::new(
            ((s_258_27) >> (s_258_24)).value(),
            u16::try_from(s_258_25).unwrap(),
        ));
        // D s_258_29: cast reint s_258_28 -> u8
        let s_258_29: u8 = (s_258_28.value() as u8);
        // D s_258_30: write-var u#32468 <= s_258_29
        fn_state.u_32468 = s_258_29;
        // C s_258_31: const #0s : i
        let s_258_31: i128 = 0;
        // C s_258_32: const #4s : i
        let s_258_32: i128 = 4;
        // D s_258_33: read-var u#32464:u32
        let s_258_33: u32 = fn_state.u_32464;
        // D s_258_34: cast zx s_258_33 -> bv
        let s_258_34: Bits = Bits::new(s_258_33 as u128, 32u16);
        // D s_258_35: bit-extract s_258_34 s_258_31 s_258_32
        let s_258_35: Bits = (Bits::new(
            ((s_258_34) >> (s_258_31)).value(),
            u16::try_from(s_258_32).unwrap(),
        ));
        // D s_258_36: cast reint s_258_35 -> u8
        let s_258_36: u8 = (s_258_35.value() as u8);
        // D s_258_37: write-var u#32469 <= s_258_36
        fn_state.u_32469 = s_258_36;
        // C s_258_38: const #12s : i
        let s_258_38: i128 = 12;
        // D s_258_39: read-var u#32464:u32
        let s_258_39: u32 = fn_state.u_32464;
        // D s_258_40: cast zx s_258_39 -> bv
        let s_258_40: Bits = Bits::new(s_258_39 as u128, 32u16);
        // C s_258_41: const #1u : u64
        let s_258_41: u64 = 1;
        // D s_258_42: bit-extract s_258_40 s_258_38 s_258_41
        let s_258_42: Bits = (Bits::new(
            ((s_258_40) >> (s_258_38)).value(),
            u16::try_from(s_258_41).unwrap(),
        ));
        // D s_258_43: cast reint s_258_42 -> u8
        let s_258_43: bool = ((s_258_42.value()) != 0);
        // C s_258_44: const #0s : i
        let s_258_44: i128 = 0;
        // C s_258_45: const #0u : u64
        let s_258_45: u64 = 0;
        // D s_258_46: cast zx s_258_43 -> u64
        let s_258_46: u64 = (s_258_43 as u64);
        // C s_258_47: const #1u : u64
        let s_258_47: u64 = 1;
        // D s_258_48: and s_258_46 s_258_47
        let s_258_48: u64 = ((s_258_46) & (s_258_47));
        // D s_258_49: cmp-eq s_258_48 s_258_47
        let s_258_49: bool = ((s_258_48) == (s_258_47));
        // D s_258_50: lsl s_258_46 s_258_44
        let s_258_50: u64 = s_258_46 << s_258_44;
        // D s_258_51: or s_258_45 s_258_50
        let s_258_51: u64 = ((s_258_45) | (s_258_50));
        // D s_258_52: cmpl s_258_50
        let s_258_52: u64 = !s_258_50;
        // D s_258_53: and s_258_45 s_258_52
        let s_258_53: u64 = ((s_258_45) & (s_258_52));
        // D s_258_54: select s_258_49 s_258_51 s_258_53
        let s_258_54: u64 = if s_258_49 { s_258_51 } else { s_258_53 };
        // D s_258_55: cast trunc s_258_54 -> u8
        let s_258_55: bool = ((s_258_54) != 0);
        // D s_258_56: cast zx s_258_55 -> bv
        let s_258_56: Bits = Bits::new(s_258_55 as u128, 1u16);
        // C s_258_57: const #0u : u8
        let s_258_57: bool = false;
        // C s_258_58: cast zx s_258_57 -> bv
        let s_258_58: Bits = Bits::new(s_258_57 as u128, 1u16);
        // D s_258_59: cmp-ne s_258_56 s_258_58
        let s_258_59: bool = ((s_258_56) != (s_258_58));
        // N s_258_60: branch s_258_59 b269 b259
        if s_258_59 {
            return block_269(state, tracer, fn_state);
        } else {
            return block_259(state, tracer, fn_state);
        };
    }
    fn block_259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_259_0: const #13s : i
        let s_259_0: i128 = 13;
        // D s_259_1: read-var u#32464:u32
        let s_259_1: u32 = fn_state.u_32464;
        // D s_259_2: cast zx s_259_1 -> bv
        let s_259_2: Bits = Bits::new(s_259_1 as u128, 32u16);
        // C s_259_3: const #1u : u64
        let s_259_3: u64 = 1;
        // D s_259_4: bit-extract s_259_2 s_259_0 s_259_3
        let s_259_4: Bits = (Bits::new(
            ((s_259_2) >> (s_259_0)).value(),
            u16::try_from(s_259_3).unwrap(),
        ));
        // D s_259_5: cast reint s_259_4 -> u8
        let s_259_5: bool = ((s_259_4.value()) != 0);
        // C s_259_6: const #0s : i
        let s_259_6: i128 = 0;
        // C s_259_7: const #0u : u64
        let s_259_7: u64 = 0;
        // D s_259_8: cast zx s_259_5 -> u64
        let s_259_8: u64 = (s_259_5 as u64);
        // C s_259_9: const #1u : u64
        let s_259_9: u64 = 1;
        // D s_259_10: and s_259_8 s_259_9
        let s_259_10: u64 = ((s_259_8) & (s_259_9));
        // D s_259_11: cmp-eq s_259_10 s_259_9
        let s_259_11: bool = ((s_259_10) == (s_259_9));
        // D s_259_12: lsl s_259_8 s_259_6
        let s_259_12: u64 = s_259_8 << s_259_6;
        // D s_259_13: or s_259_7 s_259_12
        let s_259_13: u64 = ((s_259_7) | (s_259_12));
        // D s_259_14: cmpl s_259_12
        let s_259_14: u64 = !s_259_12;
        // D s_259_15: and s_259_7 s_259_14
        let s_259_15: u64 = ((s_259_7) & (s_259_14));
        // D s_259_16: select s_259_11 s_259_13 s_259_15
        let s_259_16: u64 = if s_259_11 { s_259_13 } else { s_259_15 };
        // D s_259_17: cast trunc s_259_16 -> u8
        let s_259_17: bool = ((s_259_16) != 0);
        // D s_259_18: cast zx s_259_17 -> bv
        let s_259_18: Bits = Bits::new(s_259_17 as u128, 1u16);
        // C s_259_19: const #0u : u8
        let s_259_19: bool = false;
        // C s_259_20: cast zx s_259_19 -> bv
        let s_259_20: Bits = Bits::new(s_259_19 as u128, 1u16);
        // D s_259_21: cmp-ne s_259_18 s_259_20
        let s_259_21: bool = ((s_259_18) != (s_259_20));
        // D s_259_22: write-var gs#404523 <= s_259_21
        fn_state.gs_404523 = s_259_21;
        // N s_259_23: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_260_0: read-var gs#404523:u8
        let s_260_0: bool = fn_state.gs_404523;
        // N s_260_1: branch s_260_0 b268 b261
        if s_260_0 {
            return block_268(state, tracer, fn_state);
        } else {
            return block_261(state, tracer, fn_state);
        };
    }
    fn block_261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_261_0: const #14s : i
        let s_261_0: i128 = 14;
        // D s_261_1: read-var u#32464:u32
        let s_261_1: u32 = fn_state.u_32464;
        // D s_261_2: cast zx s_261_1 -> bv
        let s_261_2: Bits = Bits::new(s_261_1 as u128, 32u16);
        // C s_261_3: const #1u : u64
        let s_261_3: u64 = 1;
        // D s_261_4: bit-extract s_261_2 s_261_0 s_261_3
        let s_261_4: Bits = (Bits::new(
            ((s_261_2) >> (s_261_0)).value(),
            u16::try_from(s_261_3).unwrap(),
        ));
        // D s_261_5: cast reint s_261_4 -> u8
        let s_261_5: bool = ((s_261_4.value()) != 0);
        // C s_261_6: const #0s : i
        let s_261_6: i128 = 0;
        // C s_261_7: const #0u : u64
        let s_261_7: u64 = 0;
        // D s_261_8: cast zx s_261_5 -> u64
        let s_261_8: u64 = (s_261_5 as u64);
        // C s_261_9: const #1u : u64
        let s_261_9: u64 = 1;
        // D s_261_10: and s_261_8 s_261_9
        let s_261_10: u64 = ((s_261_8) & (s_261_9));
        // D s_261_11: cmp-eq s_261_10 s_261_9
        let s_261_11: bool = ((s_261_10) == (s_261_9));
        // D s_261_12: lsl s_261_8 s_261_6
        let s_261_12: u64 = s_261_8 << s_261_6;
        // D s_261_13: or s_261_7 s_261_12
        let s_261_13: u64 = ((s_261_7) | (s_261_12));
        // D s_261_14: cmpl s_261_12
        let s_261_14: u64 = !s_261_12;
        // D s_261_15: and s_261_7 s_261_14
        let s_261_15: u64 = ((s_261_7) & (s_261_14));
        // D s_261_16: select s_261_11 s_261_13 s_261_15
        let s_261_16: u64 = if s_261_11 { s_261_13 } else { s_261_15 };
        // D s_261_17: cast trunc s_261_16 -> u8
        let s_261_17: bool = ((s_261_16) != 0);
        // D s_261_18: cast zx s_261_17 -> bv
        let s_261_18: Bits = Bits::new(s_261_17 as u128, 1u16);
        // C s_261_19: const #0u : u8
        let s_261_19: bool = false;
        // C s_261_20: cast zx s_261_19 -> bv
        let s_261_20: Bits = Bits::new(s_261_19 as u128, 1u16);
        // D s_261_21: cmp-ne s_261_18 s_261_20
        let s_261_21: bool = ((s_261_18) != (s_261_20));
        // D s_261_22: write-var gs#404526 <= s_261_21
        fn_state.gs_404526 = s_261_21;
        // N s_261_23: jump b262
        return block_262(state, tracer, fn_state);
    }
    fn block_262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_262_0: read-var gs#404526:u8
        let s_262_0: bool = fn_state.gs_404526;
        // N s_262_1: branch s_262_0 b267 b263
        if s_262_0 {
            return block_267(state, tracer, fn_state);
        } else {
            return block_263(state, tracer, fn_state);
        };
    }
    fn block_263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_263_0: const #15s : i
        let s_263_0: i128 = 15;
        // D s_263_1: read-var u#32464:u32
        let s_263_1: u32 = fn_state.u_32464;
        // D s_263_2: cast zx s_263_1 -> bv
        let s_263_2: Bits = Bits::new(s_263_1 as u128, 32u16);
        // C s_263_3: const #1u : u64
        let s_263_3: u64 = 1;
        // D s_263_4: bit-extract s_263_2 s_263_0 s_263_3
        let s_263_4: Bits = (Bits::new(
            ((s_263_2) >> (s_263_0)).value(),
            u16::try_from(s_263_3).unwrap(),
        ));
        // D s_263_5: cast reint s_263_4 -> u8
        let s_263_5: bool = ((s_263_4.value()) != 0);
        // C s_263_6: const #0s : i
        let s_263_6: i128 = 0;
        // C s_263_7: const #0u : u64
        let s_263_7: u64 = 0;
        // D s_263_8: cast zx s_263_5 -> u64
        let s_263_8: u64 = (s_263_5 as u64);
        // C s_263_9: const #1u : u64
        let s_263_9: u64 = 1;
        // D s_263_10: and s_263_8 s_263_9
        let s_263_10: u64 = ((s_263_8) & (s_263_9));
        // D s_263_11: cmp-eq s_263_10 s_263_9
        let s_263_11: bool = ((s_263_10) == (s_263_9));
        // D s_263_12: lsl s_263_8 s_263_6
        let s_263_12: u64 = s_263_8 << s_263_6;
        // D s_263_13: or s_263_7 s_263_12
        let s_263_13: u64 = ((s_263_7) | (s_263_12));
        // D s_263_14: cmpl s_263_12
        let s_263_14: u64 = !s_263_12;
        // D s_263_15: and s_263_7 s_263_14
        let s_263_15: u64 = ((s_263_7) & (s_263_14));
        // D s_263_16: select s_263_11 s_263_13 s_263_15
        let s_263_16: u64 = if s_263_11 { s_263_13 } else { s_263_15 };
        // D s_263_17: cast trunc s_263_16 -> u8
        let s_263_17: bool = ((s_263_16) != 0);
        // D s_263_18: cast zx s_263_17 -> bv
        let s_263_18: Bits = Bits::new(s_263_17 as u128, 1u16);
        // C s_263_19: const #0u : u8
        let s_263_19: bool = false;
        // C s_263_20: cast zx s_263_19 -> bv
        let s_263_20: Bits = Bits::new(s_263_19 as u128, 1u16);
        // D s_263_21: cmp-ne s_263_18 s_263_20
        let s_263_21: bool = ((s_263_18) != (s_263_20));
        // D s_263_22: write-var gs#404529 <= s_263_21
        fn_state.gs_404529 = s_263_21;
        // N s_263_23: jump b264
        return block_264(state, tracer, fn_state);
    }
    fn block_264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_264_0: read-var gs#404529:u8
        let s_264_0: bool = fn_state.gs_404529;
        // N s_264_1: branch s_264_0 b266 b265
        if s_264_0 {
            return block_266(state, tracer, fn_state);
        } else {
            return block_265(state, tracer, fn_state);
        };
    }
    fn block_265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_265_0: read-var u#32465:u8
        let s_265_0: u8 = fn_state.u_32465;
        // D s_265_1: read-var u#32466:u8
        let s_265_1: u8 = fn_state.u_32466;
        // D s_265_2: read-var u#32467:u8
        let s_265_2: u8 = fn_state.u_32467;
        // D s_265_3: read-var u#32468:u8
        let s_265_3: u8 = fn_state.u_32468;
        // D s_265_4: read-var u#32469:u8
        let s_265_4: u8 = fn_state.u_32469;
        // D s_265_5: call decode_aarch32_instrs_CMN_r_A1enc_A_txt(s_265_0, s_265_1, s_265_2, s_265_3, s_265_4)
        let s_265_5: () = decode_aarch32_instrs_CMN_r_A1enc_A_txt(
            state,
            tracer,
            s_265_0,
            s_265_1,
            s_265_2,
            s_265_3,
            s_265_4,
        );
        // N s_265_6: return
        return;
    }
    fn block_266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_266_0: panic
        panic!("{:?}", ());
        // N s_266_1: return
        return;
    }
    fn block_267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_267_0: const #1u : u8
        let s_267_0: bool = true;
        // D s_267_1: write-var gs#404529 <= s_267_0
        fn_state.gs_404529 = s_267_0;
        // N s_267_2: jump b264
        return block_264(state, tracer, fn_state);
    }
    fn block_268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_268_0: const #1u : u8
        let s_268_0: bool = true;
        // D s_268_1: write-var gs#404526 <= s_268_0
        fn_state.gs_404526 = s_268_0;
        // N s_268_2: jump b262
        return block_262(state, tracer, fn_state);
    }
    fn block_269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_269_0: const #1u : u8
        let s_269_0: bool = true;
        // D s_269_1: write-var gs#404523 <= s_269_0
        fn_state.gs_404523 = s_269_0;
        // N s_269_2: jump b260
        return block_260(state, tracer, fn_state);
    }
    fn block_270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_270_0: read-var merge#var.1:struct
        let s_270_0: u32 = fn_state.merge_var._1;
        // D s_270_1: write-var u#32471 <= s_270_0
        fn_state.u_32471 = s_270_0;
        // C s_270_2: const #20s : i
        let s_270_2: i128 = 20;
        // D s_270_3: read-var u#32471:u32
        let s_270_3: u32 = fn_state.u_32471;
        // D s_270_4: cast zx s_270_3 -> bv
        let s_270_4: Bits = Bits::new(s_270_3 as u128, 32u16);
        // C s_270_5: const #1s : i64
        let s_270_5: i64 = 1;
        // C s_270_6: cast zx s_270_5 -> i
        let s_270_6: i128 = (i128::try_from(s_270_5).unwrap());
        // C s_270_7: const #7s : i
        let s_270_7: i128 = 7;
        // C s_270_8: add s_270_7 s_270_6
        let s_270_8: i128 = (s_270_7 + s_270_6);
        // D s_270_9: bit-extract s_270_4 s_270_2 s_270_8
        let s_270_9: Bits = (Bits::new(
            ((s_270_4) >> (s_270_2)).value(),
            u16::try_from(s_270_8).unwrap(),
        ));
        // D s_270_10: cast reint s_270_9 -> u8
        let s_270_10: u8 = (s_270_9.value() as u8);
        // D s_270_11: cast zx s_270_10 -> bv
        let s_270_11: Bits = Bits::new(s_270_10 as u128, 8u16);
        // C s_270_12: const #23u : u8
        let s_270_12: u8 = 23;
        // C s_270_13: cast zx s_270_12 -> bv
        let s_270_13: Bits = Bits::new(s_270_12 as u128, 8u16);
        // D s_270_14: cmp-eq s_270_11 s_270_13
        let s_270_14: bool = ((s_270_11) == (s_270_13));
        // N s_270_15: branch s_270_14 b2869 b271
        if s_270_14 {
            return block_2869(state, tracer, fn_state);
        } else {
            return block_271(state, tracer, fn_state);
        };
    }
    fn block_271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_271_0: const #0u : u8
        let s_271_0: bool = false;
        // D s_271_1: write-var gs#404541 <= s_271_0
        fn_state.gs_404541 = s_271_0;
        // N s_271_2: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_272_0: read-var gs#404541:u8
        let s_272_0: bool = fn_state.gs_404541;
        // N s_272_1: branch s_272_0 b2865 b273
        if s_272_0 {
            return block_2865(state, tracer, fn_state);
        } else {
            return block_273(state, tracer, fn_state);
        };
    }
    fn block_273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_273_0: const #0u : u8
        let s_273_0: bool = false;
        // D s_273_1: write-var gs#404546 <= s_273_0
        fn_state.gs_404546 = s_273_0;
        // N s_273_2: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_274_0: read-var gs#404546:u8
        let s_274_0: bool = fn_state.gs_404546;
        // D s_274_1: not s_274_0
        let s_274_1: bool = !s_274_0;
        // N s_274_2: branch s_274_1 b287 b275
        if s_274_1 {
            return block_287(state, tracer, fn_state);
        } else {
            return block_275(state, tracer, fn_state);
        };
    }
    fn block_275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_275_0: const #2888s : i
        let s_275_0: i128 = 2888;
        // C s_275_1: const #14696u : u32
        let s_275_1: u32 = 14696;
        // N s_275_2: write-reg s_275_1 <= s_275_0
        let s_275_2: () = {
            state.write_register::<i128>(s_275_1 as isize, s_275_0);
            tracer.write_register(s_275_1 as isize, s_275_0);
        };
        // C s_275_3: const #28s : i
        let s_275_3: i128 = 28;
        // C s_275_4: const #4s : i
        let s_275_4: i128 = 4;
        // D s_275_5: read-var u#32471:u32
        let s_275_5: u32 = fn_state.u_32471;
        // D s_275_6: cast zx s_275_5 -> bv
        let s_275_6: Bits = Bits::new(s_275_5 as u128, 32u16);
        // D s_275_7: bit-extract s_275_6 s_275_3 s_275_4
        let s_275_7: Bits = (Bits::new(
            ((s_275_6) >> (s_275_3)).value(),
            u16::try_from(s_275_4).unwrap(),
        ));
        // D s_275_8: cast reint s_275_7 -> u8
        let s_275_8: u8 = (s_275_7.value() as u8);
        // D s_275_9: write-var u#32472 <= s_275_8
        fn_state.u_32472 = s_275_8;
        // C s_275_10: const #16s : i
        let s_275_10: i128 = 16;
        // C s_275_11: const #4s : i
        let s_275_11: i128 = 4;
        // D s_275_12: read-var u#32471:u32
        let s_275_12: u32 = fn_state.u_32471;
        // D s_275_13: cast zx s_275_12 -> bv
        let s_275_13: Bits = Bits::new(s_275_12 as u128, 32u16);
        // D s_275_14: bit-extract s_275_13 s_275_10 s_275_11
        let s_275_14: Bits = (Bits::new(
            ((s_275_13) >> (s_275_10)).value(),
            u16::try_from(s_275_11).unwrap(),
        ));
        // D s_275_15: cast reint s_275_14 -> u8
        let s_275_15: u8 = (s_275_14.value() as u8);
        // D s_275_16: write-var u#32473 <= s_275_15
        fn_state.u_32473 = s_275_15;
        // C s_275_17: const #8s : i
        let s_275_17: i128 = 8;
        // C s_275_18: const #4s : i
        let s_275_18: i128 = 4;
        // D s_275_19: read-var u#32471:u32
        let s_275_19: u32 = fn_state.u_32471;
        // D s_275_20: cast zx s_275_19 -> bv
        let s_275_20: Bits = Bits::new(s_275_19 as u128, 32u16);
        // D s_275_21: bit-extract s_275_20 s_275_17 s_275_18
        let s_275_21: Bits = (Bits::new(
            ((s_275_20) >> (s_275_17)).value(),
            u16::try_from(s_275_18).unwrap(),
        ));
        // D s_275_22: cast reint s_275_21 -> u8
        let s_275_22: u8 = (s_275_21.value() as u8);
        // D s_275_23: write-var u#32474 <= s_275_22
        fn_state.u_32474 = s_275_22;
        // C s_275_24: const #5s : i
        let s_275_24: i128 = 5;
        // C s_275_25: const #2s : i
        let s_275_25: i128 = 2;
        // D s_275_26: read-var u#32471:u32
        let s_275_26: u32 = fn_state.u_32471;
        // D s_275_27: cast zx s_275_26 -> bv
        let s_275_27: Bits = Bits::new(s_275_26 as u128, 32u16);
        // D s_275_28: bit-extract s_275_27 s_275_24 s_275_25
        let s_275_28: Bits = (Bits::new(
            ((s_275_27) >> (s_275_24)).value(),
            u16::try_from(s_275_25).unwrap(),
        ));
        // D s_275_29: cast reint s_275_28 -> u8
        let s_275_29: u8 = (s_275_28.value() as u8);
        // D s_275_30: write-var u#32475 <= s_275_29
        fn_state.u_32475 = s_275_29;
        // C s_275_31: const #0s : i
        let s_275_31: i128 = 0;
        // C s_275_32: const #4s : i
        let s_275_32: i128 = 4;
        // D s_275_33: read-var u#32471:u32
        let s_275_33: u32 = fn_state.u_32471;
        // D s_275_34: cast zx s_275_33 -> bv
        let s_275_34: Bits = Bits::new(s_275_33 as u128, 32u16);
        // D s_275_35: bit-extract s_275_34 s_275_31 s_275_32
        let s_275_35: Bits = (Bits::new(
            ((s_275_34) >> (s_275_31)).value(),
            u16::try_from(s_275_32).unwrap(),
        ));
        // D s_275_36: cast reint s_275_35 -> u8
        let s_275_36: u8 = (s_275_35.value() as u8);
        // D s_275_37: write-var u#32476 <= s_275_36
        fn_state.u_32476 = s_275_36;
        // C s_275_38: const #12s : i
        let s_275_38: i128 = 12;
        // D s_275_39: read-var u#32471:u32
        let s_275_39: u32 = fn_state.u_32471;
        // D s_275_40: cast zx s_275_39 -> bv
        let s_275_40: Bits = Bits::new(s_275_39 as u128, 32u16);
        // C s_275_41: const #1u : u64
        let s_275_41: u64 = 1;
        // D s_275_42: bit-extract s_275_40 s_275_38 s_275_41
        let s_275_42: Bits = (Bits::new(
            ((s_275_40) >> (s_275_38)).value(),
            u16::try_from(s_275_41).unwrap(),
        ));
        // D s_275_43: cast reint s_275_42 -> u8
        let s_275_43: bool = ((s_275_42.value()) != 0);
        // C s_275_44: const #0s : i
        let s_275_44: i128 = 0;
        // C s_275_45: const #0u : u64
        let s_275_45: u64 = 0;
        // D s_275_46: cast zx s_275_43 -> u64
        let s_275_46: u64 = (s_275_43 as u64);
        // C s_275_47: const #1u : u64
        let s_275_47: u64 = 1;
        // D s_275_48: and s_275_46 s_275_47
        let s_275_48: u64 = ((s_275_46) & (s_275_47));
        // D s_275_49: cmp-eq s_275_48 s_275_47
        let s_275_49: bool = ((s_275_48) == (s_275_47));
        // D s_275_50: lsl s_275_46 s_275_44
        let s_275_50: u64 = s_275_46 << s_275_44;
        // D s_275_51: or s_275_45 s_275_50
        let s_275_51: u64 = ((s_275_45) | (s_275_50));
        // D s_275_52: cmpl s_275_50
        let s_275_52: u64 = !s_275_50;
        // D s_275_53: and s_275_45 s_275_52
        let s_275_53: u64 = ((s_275_45) & (s_275_52));
        // D s_275_54: select s_275_49 s_275_51 s_275_53
        let s_275_54: u64 = if s_275_49 { s_275_51 } else { s_275_53 };
        // D s_275_55: cast trunc s_275_54 -> u8
        let s_275_55: bool = ((s_275_54) != 0);
        // D s_275_56: cast zx s_275_55 -> bv
        let s_275_56: Bits = Bits::new(s_275_55 as u128, 1u16);
        // C s_275_57: const #0u : u8
        let s_275_57: bool = false;
        // C s_275_58: cast zx s_275_57 -> bv
        let s_275_58: Bits = Bits::new(s_275_57 as u128, 1u16);
        // D s_275_59: cmp-ne s_275_56 s_275_58
        let s_275_59: bool = ((s_275_56) != (s_275_58));
        // N s_275_60: branch s_275_59 b286 b276
        if s_275_59 {
            return block_286(state, tracer, fn_state);
        } else {
            return block_276(state, tracer, fn_state);
        };
    }
    fn block_276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_276_0: const #13s : i
        let s_276_0: i128 = 13;
        // D s_276_1: read-var u#32471:u32
        let s_276_1: u32 = fn_state.u_32471;
        // D s_276_2: cast zx s_276_1 -> bv
        let s_276_2: Bits = Bits::new(s_276_1 as u128, 32u16);
        // C s_276_3: const #1u : u64
        let s_276_3: u64 = 1;
        // D s_276_4: bit-extract s_276_2 s_276_0 s_276_3
        let s_276_4: Bits = (Bits::new(
            ((s_276_2) >> (s_276_0)).value(),
            u16::try_from(s_276_3).unwrap(),
        ));
        // D s_276_5: cast reint s_276_4 -> u8
        let s_276_5: bool = ((s_276_4.value()) != 0);
        // C s_276_6: const #0s : i
        let s_276_6: i128 = 0;
        // C s_276_7: const #0u : u64
        let s_276_7: u64 = 0;
        // D s_276_8: cast zx s_276_5 -> u64
        let s_276_8: u64 = (s_276_5 as u64);
        // C s_276_9: const #1u : u64
        let s_276_9: u64 = 1;
        // D s_276_10: and s_276_8 s_276_9
        let s_276_10: u64 = ((s_276_8) & (s_276_9));
        // D s_276_11: cmp-eq s_276_10 s_276_9
        let s_276_11: bool = ((s_276_10) == (s_276_9));
        // D s_276_12: lsl s_276_8 s_276_6
        let s_276_12: u64 = s_276_8 << s_276_6;
        // D s_276_13: or s_276_7 s_276_12
        let s_276_13: u64 = ((s_276_7) | (s_276_12));
        // D s_276_14: cmpl s_276_12
        let s_276_14: u64 = !s_276_12;
        // D s_276_15: and s_276_7 s_276_14
        let s_276_15: u64 = ((s_276_7) & (s_276_14));
        // D s_276_16: select s_276_11 s_276_13 s_276_15
        let s_276_16: u64 = if s_276_11 { s_276_13 } else { s_276_15 };
        // D s_276_17: cast trunc s_276_16 -> u8
        let s_276_17: bool = ((s_276_16) != 0);
        // D s_276_18: cast zx s_276_17 -> bv
        let s_276_18: Bits = Bits::new(s_276_17 as u128, 1u16);
        // C s_276_19: const #0u : u8
        let s_276_19: bool = false;
        // C s_276_20: cast zx s_276_19 -> bv
        let s_276_20: Bits = Bits::new(s_276_19 as u128, 1u16);
        // D s_276_21: cmp-ne s_276_18 s_276_20
        let s_276_21: bool = ((s_276_18) != (s_276_20));
        // D s_276_22: write-var gs#404563 <= s_276_21
        fn_state.gs_404563 = s_276_21;
        // N s_276_23: jump b277
        return block_277(state, tracer, fn_state);
    }
    fn block_277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_277_0: read-var gs#404563:u8
        let s_277_0: bool = fn_state.gs_404563;
        // N s_277_1: branch s_277_0 b285 b278
        if s_277_0 {
            return block_285(state, tracer, fn_state);
        } else {
            return block_278(state, tracer, fn_state);
        };
    }
    fn block_278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_278_0: const #14s : i
        let s_278_0: i128 = 14;
        // D s_278_1: read-var u#32471:u32
        let s_278_1: u32 = fn_state.u_32471;
        // D s_278_2: cast zx s_278_1 -> bv
        let s_278_2: Bits = Bits::new(s_278_1 as u128, 32u16);
        // C s_278_3: const #1u : u64
        let s_278_3: u64 = 1;
        // D s_278_4: bit-extract s_278_2 s_278_0 s_278_3
        let s_278_4: Bits = (Bits::new(
            ((s_278_2) >> (s_278_0)).value(),
            u16::try_from(s_278_3).unwrap(),
        ));
        // D s_278_5: cast reint s_278_4 -> u8
        let s_278_5: bool = ((s_278_4.value()) != 0);
        // C s_278_6: const #0s : i
        let s_278_6: i128 = 0;
        // C s_278_7: const #0u : u64
        let s_278_7: u64 = 0;
        // D s_278_8: cast zx s_278_5 -> u64
        let s_278_8: u64 = (s_278_5 as u64);
        // C s_278_9: const #1u : u64
        let s_278_9: u64 = 1;
        // D s_278_10: and s_278_8 s_278_9
        let s_278_10: u64 = ((s_278_8) & (s_278_9));
        // D s_278_11: cmp-eq s_278_10 s_278_9
        let s_278_11: bool = ((s_278_10) == (s_278_9));
        // D s_278_12: lsl s_278_8 s_278_6
        let s_278_12: u64 = s_278_8 << s_278_6;
        // D s_278_13: or s_278_7 s_278_12
        let s_278_13: u64 = ((s_278_7) | (s_278_12));
        // D s_278_14: cmpl s_278_12
        let s_278_14: u64 = !s_278_12;
        // D s_278_15: and s_278_7 s_278_14
        let s_278_15: u64 = ((s_278_7) & (s_278_14));
        // D s_278_16: select s_278_11 s_278_13 s_278_15
        let s_278_16: u64 = if s_278_11 { s_278_13 } else { s_278_15 };
        // D s_278_17: cast trunc s_278_16 -> u8
        let s_278_17: bool = ((s_278_16) != 0);
        // D s_278_18: cast zx s_278_17 -> bv
        let s_278_18: Bits = Bits::new(s_278_17 as u128, 1u16);
        // C s_278_19: const #0u : u8
        let s_278_19: bool = false;
        // C s_278_20: cast zx s_278_19 -> bv
        let s_278_20: Bits = Bits::new(s_278_19 as u128, 1u16);
        // D s_278_21: cmp-ne s_278_18 s_278_20
        let s_278_21: bool = ((s_278_18) != (s_278_20));
        // D s_278_22: write-var gs#404566 <= s_278_21
        fn_state.gs_404566 = s_278_21;
        // N s_278_23: jump b279
        return block_279(state, tracer, fn_state);
    }
    fn block_279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_279_0: read-var gs#404566:u8
        let s_279_0: bool = fn_state.gs_404566;
        // N s_279_1: branch s_279_0 b284 b280
        if s_279_0 {
            return block_284(state, tracer, fn_state);
        } else {
            return block_280(state, tracer, fn_state);
        };
    }
    fn block_280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_280_0: const #15s : i
        let s_280_0: i128 = 15;
        // D s_280_1: read-var u#32471:u32
        let s_280_1: u32 = fn_state.u_32471;
        // D s_280_2: cast zx s_280_1 -> bv
        let s_280_2: Bits = Bits::new(s_280_1 as u128, 32u16);
        // C s_280_3: const #1u : u64
        let s_280_3: u64 = 1;
        // D s_280_4: bit-extract s_280_2 s_280_0 s_280_3
        let s_280_4: Bits = (Bits::new(
            ((s_280_2) >> (s_280_0)).value(),
            u16::try_from(s_280_3).unwrap(),
        ));
        // D s_280_5: cast reint s_280_4 -> u8
        let s_280_5: bool = ((s_280_4.value()) != 0);
        // C s_280_6: const #0s : i
        let s_280_6: i128 = 0;
        // C s_280_7: const #0u : u64
        let s_280_7: u64 = 0;
        // D s_280_8: cast zx s_280_5 -> u64
        let s_280_8: u64 = (s_280_5 as u64);
        // C s_280_9: const #1u : u64
        let s_280_9: u64 = 1;
        // D s_280_10: and s_280_8 s_280_9
        let s_280_10: u64 = ((s_280_8) & (s_280_9));
        // D s_280_11: cmp-eq s_280_10 s_280_9
        let s_280_11: bool = ((s_280_10) == (s_280_9));
        // D s_280_12: lsl s_280_8 s_280_6
        let s_280_12: u64 = s_280_8 << s_280_6;
        // D s_280_13: or s_280_7 s_280_12
        let s_280_13: u64 = ((s_280_7) | (s_280_12));
        // D s_280_14: cmpl s_280_12
        let s_280_14: u64 = !s_280_12;
        // D s_280_15: and s_280_7 s_280_14
        let s_280_15: u64 = ((s_280_7) & (s_280_14));
        // D s_280_16: select s_280_11 s_280_13 s_280_15
        let s_280_16: u64 = if s_280_11 { s_280_13 } else { s_280_15 };
        // D s_280_17: cast trunc s_280_16 -> u8
        let s_280_17: bool = ((s_280_16) != 0);
        // D s_280_18: cast zx s_280_17 -> bv
        let s_280_18: Bits = Bits::new(s_280_17 as u128, 1u16);
        // C s_280_19: const #0u : u8
        let s_280_19: bool = false;
        // C s_280_20: cast zx s_280_19 -> bv
        let s_280_20: Bits = Bits::new(s_280_19 as u128, 1u16);
        // D s_280_21: cmp-ne s_280_18 s_280_20
        let s_280_21: bool = ((s_280_18) != (s_280_20));
        // D s_280_22: write-var gs#404569 <= s_280_21
        fn_state.gs_404569 = s_280_21;
        // N s_280_23: jump b281
        return block_281(state, tracer, fn_state);
    }
    fn block_281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_281_0: read-var gs#404569:u8
        let s_281_0: bool = fn_state.gs_404569;
        // N s_281_1: branch s_281_0 b283 b282
        if s_281_0 {
            return block_283(state, tracer, fn_state);
        } else {
            return block_282(state, tracer, fn_state);
        };
    }
    fn block_282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_282_0: read-var u#32472:u8
        let s_282_0: u8 = fn_state.u_32472;
        // D s_282_1: read-var u#32473:u8
        let s_282_1: u8 = fn_state.u_32473;
        // D s_282_2: read-var u#32474:u8
        let s_282_2: u8 = fn_state.u_32474;
        // D s_282_3: read-var u#32475:u8
        let s_282_3: u8 = fn_state.u_32475;
        // D s_282_4: read-var u#32476:u8
        let s_282_4: u8 = fn_state.u_32476;
        // D s_282_5: call decode_aarch32_instrs_CMN_rr_A1enc_A_txt(s_282_0, s_282_1, s_282_2, s_282_3, s_282_4)
        let s_282_5: () = decode_aarch32_instrs_CMN_rr_A1enc_A_txt(
            state,
            tracer,
            s_282_0,
            s_282_1,
            s_282_2,
            s_282_3,
            s_282_4,
        );
        // N s_282_6: return
        return;
    }
    fn block_283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_283_0: panic
        panic!("{:?}", ());
        // N s_283_1: return
        return;
    }
    fn block_284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_284_0: const #1u : u8
        let s_284_0: bool = true;
        // D s_284_1: write-var gs#404569 <= s_284_0
        fn_state.gs_404569 = s_284_0;
        // N s_284_2: jump b281
        return block_281(state, tracer, fn_state);
    }
    fn block_285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_285_0: const #1u : u8
        let s_285_0: bool = true;
        // D s_285_1: write-var gs#404566 <= s_285_0
        fn_state.gs_404566 = s_285_0;
        // N s_285_2: jump b279
        return block_279(state, tracer, fn_state);
    }
    fn block_286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_286_0: const #1u : u8
        let s_286_0: bool = true;
        // D s_286_1: write-var gs#404563 <= s_286_0
        fn_state.gs_404563 = s_286_0;
        // N s_286_2: jump b277
        return block_277(state, tracer, fn_state);
    }
    fn block_287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_287_0: read-var merge#var.1:struct
        let s_287_0: u32 = fn_state.merge_var._1;
        // D s_287_1: write-var u#32478 <= s_287_0
        fn_state.u_32478 = s_287_0;
        // C s_287_2: const #20s : i
        let s_287_2: i128 = 20;
        // D s_287_3: read-var u#32478:u32
        let s_287_3: u32 = fn_state.u_32478;
        // D s_287_4: cast zx s_287_3 -> bv
        let s_287_4: Bits = Bits::new(s_287_3 as u128, 32u16);
        // C s_287_5: const #1s : i64
        let s_287_5: i64 = 1;
        // C s_287_6: cast zx s_287_5 -> i
        let s_287_6: i128 = (i128::try_from(s_287_5).unwrap());
        // C s_287_7: const #7s : i
        let s_287_7: i128 = 7;
        // C s_287_8: add s_287_7 s_287_6
        let s_287_8: i128 = (s_287_7 + s_287_6);
        // D s_287_9: bit-extract s_287_4 s_287_2 s_287_8
        let s_287_9: Bits = (Bits::new(
            ((s_287_4) >> (s_287_2)).value(),
            u16::try_from(s_287_8).unwrap(),
        ));
        // D s_287_10: cast reint s_287_9 -> u8
        let s_287_10: u8 = (s_287_9.value() as u8);
        // D s_287_11: cast zx s_287_10 -> bv
        let s_287_11: Bits = Bits::new(s_287_10 as u128, 8u16);
        // C s_287_12: const #53u : u8
        let s_287_12: u8 = 53;
        // C s_287_13: cast zx s_287_12 -> bv
        let s_287_13: Bits = Bits::new(s_287_12 as u128, 8u16);
        // D s_287_14: cmp-eq s_287_11 s_287_13
        let s_287_14: bool = ((s_287_11) == (s_287_13));
        // N s_287_15: branch s_287_14 b2864 b288
        if s_287_14 {
            return block_2864(state, tracer, fn_state);
        } else {
            return block_288(state, tracer, fn_state);
        };
    }
    fn block_288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_288_0: const #0u : u8
        let s_288_0: bool = false;
        // D s_288_1: write-var gs#404575 <= s_288_0
        fn_state.gs_404575 = s_288_0;
        // N s_288_2: jump b289
        return block_289(state, tracer, fn_state);
    }
    fn block_289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_289_0: read-var gs#404575:u8
        let s_289_0: bool = fn_state.gs_404575;
        // N s_289_1: branch s_289_0 b2860 b290
        if s_289_0 {
            return block_2860(state, tracer, fn_state);
        } else {
            return block_290(state, tracer, fn_state);
        };
    }
    fn block_290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_290_0: const #0u : u8
        let s_290_0: bool = false;
        // D s_290_1: write-var gs#404580 <= s_290_0
        fn_state.gs_404580 = s_290_0;
        // N s_290_2: jump b291
        return block_291(state, tracer, fn_state);
    }
    fn block_291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_291_0: read-var gs#404580:u8
        let s_291_0: bool = fn_state.gs_404580;
        // D s_291_1: not s_291_0
        let s_291_1: bool = !s_291_0;
        // N s_291_2: branch s_291_1 b304 b292
        if s_291_1 {
            return block_304(state, tracer, fn_state);
        } else {
            return block_292(state, tracer, fn_state);
        };
    }
    fn block_292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_292_0: const #2889s : i
        let s_292_0: i128 = 2889;
        // C s_292_1: const #14696u : u32
        let s_292_1: u32 = 14696;
        // N s_292_2: write-reg s_292_1 <= s_292_0
        let s_292_2: () = {
            state.write_register::<i128>(s_292_1 as isize, s_292_0);
            tracer.write_register(s_292_1 as isize, s_292_0);
        };
        // C s_292_3: const #28s : i
        let s_292_3: i128 = 28;
        // C s_292_4: const #4s : i
        let s_292_4: i128 = 4;
        // D s_292_5: read-var u#32478:u32
        let s_292_5: u32 = fn_state.u_32478;
        // D s_292_6: cast zx s_292_5 -> bv
        let s_292_6: Bits = Bits::new(s_292_5 as u128, 32u16);
        // D s_292_7: bit-extract s_292_6 s_292_3 s_292_4
        let s_292_7: Bits = (Bits::new(
            ((s_292_6) >> (s_292_3)).value(),
            u16::try_from(s_292_4).unwrap(),
        ));
        // D s_292_8: cast reint s_292_7 -> u8
        let s_292_8: u8 = (s_292_7.value() as u8);
        // D s_292_9: write-var u#32479 <= s_292_8
        fn_state.u_32479 = s_292_8;
        // C s_292_10: const #16s : i
        let s_292_10: i128 = 16;
        // C s_292_11: const #4s : i
        let s_292_11: i128 = 4;
        // D s_292_12: read-var u#32478:u32
        let s_292_12: u32 = fn_state.u_32478;
        // D s_292_13: cast zx s_292_12 -> bv
        let s_292_13: Bits = Bits::new(s_292_12 as u128, 32u16);
        // D s_292_14: bit-extract s_292_13 s_292_10 s_292_11
        let s_292_14: Bits = (Bits::new(
            ((s_292_13) >> (s_292_10)).value(),
            u16::try_from(s_292_11).unwrap(),
        ));
        // D s_292_15: cast reint s_292_14 -> u8
        let s_292_15: u8 = (s_292_14.value() as u8);
        // D s_292_16: write-var u#32480 <= s_292_15
        fn_state.u_32480 = s_292_15;
        // C s_292_17: const #0s : i
        let s_292_17: i128 = 0;
        // C s_292_18: const #12s : i
        let s_292_18: i128 = 12;
        // D s_292_19: read-var u#32478:u32
        let s_292_19: u32 = fn_state.u_32478;
        // D s_292_20: cast zx s_292_19 -> bv
        let s_292_20: Bits = Bits::new(s_292_19 as u128, 32u16);
        // D s_292_21: bit-extract s_292_20 s_292_17 s_292_18
        let s_292_21: Bits = (Bits::new(
            ((s_292_20) >> (s_292_17)).value(),
            u16::try_from(s_292_18).unwrap(),
        ));
        // D s_292_22: cast reint s_292_21 -> u12
        let s_292_22: u16 = (s_292_21.value() as u16);
        // D s_292_23: write-var u#32481 <= s_292_22
        fn_state.u_32481 = s_292_22;
        // C s_292_24: const #12s : i
        let s_292_24: i128 = 12;
        // D s_292_25: read-var u#32478:u32
        let s_292_25: u32 = fn_state.u_32478;
        // D s_292_26: cast zx s_292_25 -> bv
        let s_292_26: Bits = Bits::new(s_292_25 as u128, 32u16);
        // C s_292_27: const #1u : u64
        let s_292_27: u64 = 1;
        // D s_292_28: bit-extract s_292_26 s_292_24 s_292_27
        let s_292_28: Bits = (Bits::new(
            ((s_292_26) >> (s_292_24)).value(),
            u16::try_from(s_292_27).unwrap(),
        ));
        // D s_292_29: cast reint s_292_28 -> u8
        let s_292_29: bool = ((s_292_28.value()) != 0);
        // C s_292_30: const #0s : i
        let s_292_30: i128 = 0;
        // C s_292_31: const #0u : u64
        let s_292_31: u64 = 0;
        // D s_292_32: cast zx s_292_29 -> u64
        let s_292_32: u64 = (s_292_29 as u64);
        // C s_292_33: const #1u : u64
        let s_292_33: u64 = 1;
        // D s_292_34: and s_292_32 s_292_33
        let s_292_34: u64 = ((s_292_32) & (s_292_33));
        // D s_292_35: cmp-eq s_292_34 s_292_33
        let s_292_35: bool = ((s_292_34) == (s_292_33));
        // D s_292_36: lsl s_292_32 s_292_30
        let s_292_36: u64 = s_292_32 << s_292_30;
        // D s_292_37: or s_292_31 s_292_36
        let s_292_37: u64 = ((s_292_31) | (s_292_36));
        // D s_292_38: cmpl s_292_36
        let s_292_38: u64 = !s_292_36;
        // D s_292_39: and s_292_31 s_292_38
        let s_292_39: u64 = ((s_292_31) & (s_292_38));
        // D s_292_40: select s_292_35 s_292_37 s_292_39
        let s_292_40: u64 = if s_292_35 { s_292_37 } else { s_292_39 };
        // D s_292_41: cast trunc s_292_40 -> u8
        let s_292_41: bool = ((s_292_40) != 0);
        // D s_292_42: cast zx s_292_41 -> bv
        let s_292_42: Bits = Bits::new(s_292_41 as u128, 1u16);
        // C s_292_43: const #0u : u8
        let s_292_43: bool = false;
        // C s_292_44: cast zx s_292_43 -> bv
        let s_292_44: Bits = Bits::new(s_292_43 as u128, 1u16);
        // D s_292_45: cmp-ne s_292_42 s_292_44
        let s_292_45: bool = ((s_292_42) != (s_292_44));
        // N s_292_46: branch s_292_45 b303 b293
        if s_292_45 {
            return block_303(state, tracer, fn_state);
        } else {
            return block_293(state, tracer, fn_state);
        };
    }
    fn block_293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_293_0: const #13s : i
        let s_293_0: i128 = 13;
        // D s_293_1: read-var u#32478:u32
        let s_293_1: u32 = fn_state.u_32478;
        // D s_293_2: cast zx s_293_1 -> bv
        let s_293_2: Bits = Bits::new(s_293_1 as u128, 32u16);
        // C s_293_3: const #1u : u64
        let s_293_3: u64 = 1;
        // D s_293_4: bit-extract s_293_2 s_293_0 s_293_3
        let s_293_4: Bits = (Bits::new(
            ((s_293_2) >> (s_293_0)).value(),
            u16::try_from(s_293_3).unwrap(),
        ));
        // D s_293_5: cast reint s_293_4 -> u8
        let s_293_5: bool = ((s_293_4.value()) != 0);
        // C s_293_6: const #0s : i
        let s_293_6: i128 = 0;
        // C s_293_7: const #0u : u64
        let s_293_7: u64 = 0;
        // D s_293_8: cast zx s_293_5 -> u64
        let s_293_8: u64 = (s_293_5 as u64);
        // C s_293_9: const #1u : u64
        let s_293_9: u64 = 1;
        // D s_293_10: and s_293_8 s_293_9
        let s_293_10: u64 = ((s_293_8) & (s_293_9));
        // D s_293_11: cmp-eq s_293_10 s_293_9
        let s_293_11: bool = ((s_293_10) == (s_293_9));
        // D s_293_12: lsl s_293_8 s_293_6
        let s_293_12: u64 = s_293_8 << s_293_6;
        // D s_293_13: or s_293_7 s_293_12
        let s_293_13: u64 = ((s_293_7) | (s_293_12));
        // D s_293_14: cmpl s_293_12
        let s_293_14: u64 = !s_293_12;
        // D s_293_15: and s_293_7 s_293_14
        let s_293_15: u64 = ((s_293_7) & (s_293_14));
        // D s_293_16: select s_293_11 s_293_13 s_293_15
        let s_293_16: u64 = if s_293_11 { s_293_13 } else { s_293_15 };
        // D s_293_17: cast trunc s_293_16 -> u8
        let s_293_17: bool = ((s_293_16) != 0);
        // D s_293_18: cast zx s_293_17 -> bv
        let s_293_18: Bits = Bits::new(s_293_17 as u128, 1u16);
        // C s_293_19: const #0u : u8
        let s_293_19: bool = false;
        // C s_293_20: cast zx s_293_19 -> bv
        let s_293_20: Bits = Bits::new(s_293_19 as u128, 1u16);
        // D s_293_21: cmp-ne s_293_18 s_293_20
        let s_293_21: bool = ((s_293_18) != (s_293_20));
        // D s_293_22: write-var gs#404593 <= s_293_21
        fn_state.gs_404593 = s_293_21;
        // N s_293_23: jump b294
        return block_294(state, tracer, fn_state);
    }
    fn block_294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_294_0: read-var gs#404593:u8
        let s_294_0: bool = fn_state.gs_404593;
        // N s_294_1: branch s_294_0 b302 b295
        if s_294_0 {
            return block_302(state, tracer, fn_state);
        } else {
            return block_295(state, tracer, fn_state);
        };
    }
    fn block_295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_295_0: const #14s : i
        let s_295_0: i128 = 14;
        // D s_295_1: read-var u#32478:u32
        let s_295_1: u32 = fn_state.u_32478;
        // D s_295_2: cast zx s_295_1 -> bv
        let s_295_2: Bits = Bits::new(s_295_1 as u128, 32u16);
        // C s_295_3: const #1u : u64
        let s_295_3: u64 = 1;
        // D s_295_4: bit-extract s_295_2 s_295_0 s_295_3
        let s_295_4: Bits = (Bits::new(
            ((s_295_2) >> (s_295_0)).value(),
            u16::try_from(s_295_3).unwrap(),
        ));
        // D s_295_5: cast reint s_295_4 -> u8
        let s_295_5: bool = ((s_295_4.value()) != 0);
        // C s_295_6: const #0s : i
        let s_295_6: i128 = 0;
        // C s_295_7: const #0u : u64
        let s_295_7: u64 = 0;
        // D s_295_8: cast zx s_295_5 -> u64
        let s_295_8: u64 = (s_295_5 as u64);
        // C s_295_9: const #1u : u64
        let s_295_9: u64 = 1;
        // D s_295_10: and s_295_8 s_295_9
        let s_295_10: u64 = ((s_295_8) & (s_295_9));
        // D s_295_11: cmp-eq s_295_10 s_295_9
        let s_295_11: bool = ((s_295_10) == (s_295_9));
        // D s_295_12: lsl s_295_8 s_295_6
        let s_295_12: u64 = s_295_8 << s_295_6;
        // D s_295_13: or s_295_7 s_295_12
        let s_295_13: u64 = ((s_295_7) | (s_295_12));
        // D s_295_14: cmpl s_295_12
        let s_295_14: u64 = !s_295_12;
        // D s_295_15: and s_295_7 s_295_14
        let s_295_15: u64 = ((s_295_7) & (s_295_14));
        // D s_295_16: select s_295_11 s_295_13 s_295_15
        let s_295_16: u64 = if s_295_11 { s_295_13 } else { s_295_15 };
        // D s_295_17: cast trunc s_295_16 -> u8
        let s_295_17: bool = ((s_295_16) != 0);
        // D s_295_18: cast zx s_295_17 -> bv
        let s_295_18: Bits = Bits::new(s_295_17 as u128, 1u16);
        // C s_295_19: const #0u : u8
        let s_295_19: bool = false;
        // C s_295_20: cast zx s_295_19 -> bv
        let s_295_20: Bits = Bits::new(s_295_19 as u128, 1u16);
        // D s_295_21: cmp-ne s_295_18 s_295_20
        let s_295_21: bool = ((s_295_18) != (s_295_20));
        // D s_295_22: write-var gs#404596 <= s_295_21
        fn_state.gs_404596 = s_295_21;
        // N s_295_23: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_296_0: read-var gs#404596:u8
        let s_296_0: bool = fn_state.gs_404596;
        // N s_296_1: branch s_296_0 b301 b297
        if s_296_0 {
            return block_301(state, tracer, fn_state);
        } else {
            return block_297(state, tracer, fn_state);
        };
    }
    fn block_297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_297_0: const #15s : i
        let s_297_0: i128 = 15;
        // D s_297_1: read-var u#32478:u32
        let s_297_1: u32 = fn_state.u_32478;
        // D s_297_2: cast zx s_297_1 -> bv
        let s_297_2: Bits = Bits::new(s_297_1 as u128, 32u16);
        // C s_297_3: const #1u : u64
        let s_297_3: u64 = 1;
        // D s_297_4: bit-extract s_297_2 s_297_0 s_297_3
        let s_297_4: Bits = (Bits::new(
            ((s_297_2) >> (s_297_0)).value(),
            u16::try_from(s_297_3).unwrap(),
        ));
        // D s_297_5: cast reint s_297_4 -> u8
        let s_297_5: bool = ((s_297_4.value()) != 0);
        // C s_297_6: const #0s : i
        let s_297_6: i128 = 0;
        // C s_297_7: const #0u : u64
        let s_297_7: u64 = 0;
        // D s_297_8: cast zx s_297_5 -> u64
        let s_297_8: u64 = (s_297_5 as u64);
        // C s_297_9: const #1u : u64
        let s_297_9: u64 = 1;
        // D s_297_10: and s_297_8 s_297_9
        let s_297_10: u64 = ((s_297_8) & (s_297_9));
        // D s_297_11: cmp-eq s_297_10 s_297_9
        let s_297_11: bool = ((s_297_10) == (s_297_9));
        // D s_297_12: lsl s_297_8 s_297_6
        let s_297_12: u64 = s_297_8 << s_297_6;
        // D s_297_13: or s_297_7 s_297_12
        let s_297_13: u64 = ((s_297_7) | (s_297_12));
        // D s_297_14: cmpl s_297_12
        let s_297_14: u64 = !s_297_12;
        // D s_297_15: and s_297_7 s_297_14
        let s_297_15: u64 = ((s_297_7) & (s_297_14));
        // D s_297_16: select s_297_11 s_297_13 s_297_15
        let s_297_16: u64 = if s_297_11 { s_297_13 } else { s_297_15 };
        // D s_297_17: cast trunc s_297_16 -> u8
        let s_297_17: bool = ((s_297_16) != 0);
        // D s_297_18: cast zx s_297_17 -> bv
        let s_297_18: Bits = Bits::new(s_297_17 as u128, 1u16);
        // C s_297_19: const #0u : u8
        let s_297_19: bool = false;
        // C s_297_20: cast zx s_297_19 -> bv
        let s_297_20: Bits = Bits::new(s_297_19 as u128, 1u16);
        // D s_297_21: cmp-ne s_297_18 s_297_20
        let s_297_21: bool = ((s_297_18) != (s_297_20));
        // D s_297_22: write-var gs#404599 <= s_297_21
        fn_state.gs_404599 = s_297_21;
        // N s_297_23: jump b298
        return block_298(state, tracer, fn_state);
    }
    fn block_298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_298_0: read-var gs#404599:u8
        let s_298_0: bool = fn_state.gs_404599;
        // N s_298_1: branch s_298_0 b300 b299
        if s_298_0 {
            return block_300(state, tracer, fn_state);
        } else {
            return block_299(state, tracer, fn_state);
        };
    }
    fn block_299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_299_0: read-var u#32479:u8
        let s_299_0: u8 = fn_state.u_32479;
        // D s_299_1: read-var u#32480:u8
        let s_299_1: u8 = fn_state.u_32480;
        // D s_299_2: read-var u#32481:u12
        let s_299_2: u16 = fn_state.u_32481;
        // D s_299_3: call decode_aarch32_instrs_CMP_i_A1enc_A_txt(s_299_0, s_299_1, s_299_2)
        let s_299_3: () = decode_aarch32_instrs_CMP_i_A1enc_A_txt(
            state,
            tracer,
            s_299_0,
            s_299_1,
            s_299_2,
        );
        // N s_299_4: return
        return;
    }
    fn block_300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_300_0: panic
        panic!("{:?}", ());
        // N s_300_1: return
        return;
    }
    fn block_301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_301_0: const #1u : u8
        let s_301_0: bool = true;
        // D s_301_1: write-var gs#404599 <= s_301_0
        fn_state.gs_404599 = s_301_0;
        // N s_301_2: jump b298
        return block_298(state, tracer, fn_state);
    }
    fn block_302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_302_0: const #1u : u8
        let s_302_0: bool = true;
        // D s_302_1: write-var gs#404596 <= s_302_0
        fn_state.gs_404596 = s_302_0;
        // N s_302_2: jump b296
        return block_296(state, tracer, fn_state);
    }
    fn block_303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_303_0: const #1u : u8
        let s_303_0: bool = true;
        // D s_303_1: write-var gs#404593 <= s_303_0
        fn_state.gs_404593 = s_303_0;
        // N s_303_2: jump b294
        return block_294(state, tracer, fn_state);
    }
    fn block_304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_304_0: read-var merge#var.1:struct
        let s_304_0: u32 = fn_state.merge_var._1;
        // D s_304_1: write-var u#32483 <= s_304_0
        fn_state.u_32483 = s_304_0;
        // C s_304_2: const #20s : i
        let s_304_2: i128 = 20;
        // D s_304_3: read-var u#32483:u32
        let s_304_3: u32 = fn_state.u_32483;
        // D s_304_4: cast zx s_304_3 -> bv
        let s_304_4: Bits = Bits::new(s_304_3 as u128, 32u16);
        // C s_304_5: const #1s : i64
        let s_304_5: i64 = 1;
        // C s_304_6: cast zx s_304_5 -> i
        let s_304_6: i128 = (i128::try_from(s_304_5).unwrap());
        // C s_304_7: const #7s : i
        let s_304_7: i128 = 7;
        // C s_304_8: add s_304_7 s_304_6
        let s_304_8: i128 = (s_304_7 + s_304_6);
        // D s_304_9: bit-extract s_304_4 s_304_2 s_304_8
        let s_304_9: Bits = (Bits::new(
            ((s_304_4) >> (s_304_2)).value(),
            u16::try_from(s_304_8).unwrap(),
        ));
        // D s_304_10: cast reint s_304_9 -> u8
        let s_304_10: u8 = (s_304_9.value() as u8);
        // D s_304_11: cast zx s_304_10 -> bv
        let s_304_11: Bits = Bits::new(s_304_10 as u128, 8u16);
        // C s_304_12: const #21u : u8
        let s_304_12: u8 = 21;
        // C s_304_13: cast zx s_304_12 -> bv
        let s_304_13: Bits = Bits::new(s_304_12 as u128, 8u16);
        // D s_304_14: cmp-eq s_304_11 s_304_13
        let s_304_14: bool = ((s_304_11) == (s_304_13));
        // N s_304_15: branch s_304_14 b2856 b305
        if s_304_14 {
            return block_2856(state, tracer, fn_state);
        } else {
            return block_305(state, tracer, fn_state);
        };
    }
    fn block_305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_305_0: const #0u : u8
        let s_305_0: bool = false;
        // D s_305_1: write-var gs#404608 <= s_305_0
        fn_state.gs_404608 = s_305_0;
        // N s_305_2: jump b306
        return block_306(state, tracer, fn_state);
    }
    fn block_306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_306_0: read-var gs#404608:u8
        let s_306_0: bool = fn_state.gs_404608;
        // N s_306_1: branch s_306_0 b2852 b307
        if s_306_0 {
            return block_2852(state, tracer, fn_state);
        } else {
            return block_307(state, tracer, fn_state);
        };
    }
    fn block_307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_307_0: const #0u : u8
        let s_307_0: bool = false;
        // D s_307_1: write-var gs#404613 <= s_307_0
        fn_state.gs_404613 = s_307_0;
        // N s_307_2: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_308_0: read-var gs#404613:u8
        let s_308_0: bool = fn_state.gs_404613;
        // D s_308_1: not s_308_0
        let s_308_1: bool = !s_308_0;
        // N s_308_2: branch s_308_1 b321 b309
        if s_308_1 {
            return block_321(state, tracer, fn_state);
        } else {
            return block_309(state, tracer, fn_state);
        };
    }
    fn block_309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_309_0: const #2892s : i
        let s_309_0: i128 = 2892;
        // C s_309_1: const #14696u : u32
        let s_309_1: u32 = 14696;
        // N s_309_2: write-reg s_309_1 <= s_309_0
        let s_309_2: () = {
            state.write_register::<i128>(s_309_1 as isize, s_309_0);
            tracer.write_register(s_309_1 as isize, s_309_0);
        };
        // C s_309_3: const #28s : i
        let s_309_3: i128 = 28;
        // C s_309_4: const #4s : i
        let s_309_4: i128 = 4;
        // D s_309_5: read-var u#32483:u32
        let s_309_5: u32 = fn_state.u_32483;
        // D s_309_6: cast zx s_309_5 -> bv
        let s_309_6: Bits = Bits::new(s_309_5 as u128, 32u16);
        // D s_309_7: bit-extract s_309_6 s_309_3 s_309_4
        let s_309_7: Bits = (Bits::new(
            ((s_309_6) >> (s_309_3)).value(),
            u16::try_from(s_309_4).unwrap(),
        ));
        // D s_309_8: cast reint s_309_7 -> u8
        let s_309_8: u8 = (s_309_7.value() as u8);
        // D s_309_9: write-var u#32484 <= s_309_8
        fn_state.u_32484 = s_309_8;
        // C s_309_10: const #16s : i
        let s_309_10: i128 = 16;
        // C s_309_11: const #4s : i
        let s_309_11: i128 = 4;
        // D s_309_12: read-var u#32483:u32
        let s_309_12: u32 = fn_state.u_32483;
        // D s_309_13: cast zx s_309_12 -> bv
        let s_309_13: Bits = Bits::new(s_309_12 as u128, 32u16);
        // D s_309_14: bit-extract s_309_13 s_309_10 s_309_11
        let s_309_14: Bits = (Bits::new(
            ((s_309_13) >> (s_309_10)).value(),
            u16::try_from(s_309_11).unwrap(),
        ));
        // D s_309_15: cast reint s_309_14 -> u8
        let s_309_15: u8 = (s_309_14.value() as u8);
        // D s_309_16: write-var u#32485 <= s_309_15
        fn_state.u_32485 = s_309_15;
        // C s_309_17: const #7s : i
        let s_309_17: i128 = 7;
        // C s_309_18: const #5s : i
        let s_309_18: i128 = 5;
        // D s_309_19: read-var u#32483:u32
        let s_309_19: u32 = fn_state.u_32483;
        // D s_309_20: cast zx s_309_19 -> bv
        let s_309_20: Bits = Bits::new(s_309_19 as u128, 32u16);
        // D s_309_21: bit-extract s_309_20 s_309_17 s_309_18
        let s_309_21: Bits = (Bits::new(
            ((s_309_20) >> (s_309_17)).value(),
            u16::try_from(s_309_18).unwrap(),
        ));
        // D s_309_22: cast reint s_309_21 -> u8
        let s_309_22: u8 = (s_309_21.value() as u8);
        // D s_309_23: write-var u#32486 <= s_309_22
        fn_state.u_32486 = s_309_22;
        // C s_309_24: const #5s : i
        let s_309_24: i128 = 5;
        // C s_309_25: const #2s : i
        let s_309_25: i128 = 2;
        // D s_309_26: read-var u#32483:u32
        let s_309_26: u32 = fn_state.u_32483;
        // D s_309_27: cast zx s_309_26 -> bv
        let s_309_27: Bits = Bits::new(s_309_26 as u128, 32u16);
        // D s_309_28: bit-extract s_309_27 s_309_24 s_309_25
        let s_309_28: Bits = (Bits::new(
            ((s_309_27) >> (s_309_24)).value(),
            u16::try_from(s_309_25).unwrap(),
        ));
        // D s_309_29: cast reint s_309_28 -> u8
        let s_309_29: u8 = (s_309_28.value() as u8);
        // D s_309_30: write-var u#32487 <= s_309_29
        fn_state.u_32487 = s_309_29;
        // C s_309_31: const #0s : i
        let s_309_31: i128 = 0;
        // C s_309_32: const #4s : i
        let s_309_32: i128 = 4;
        // D s_309_33: read-var u#32483:u32
        let s_309_33: u32 = fn_state.u_32483;
        // D s_309_34: cast zx s_309_33 -> bv
        let s_309_34: Bits = Bits::new(s_309_33 as u128, 32u16);
        // D s_309_35: bit-extract s_309_34 s_309_31 s_309_32
        let s_309_35: Bits = (Bits::new(
            ((s_309_34) >> (s_309_31)).value(),
            u16::try_from(s_309_32).unwrap(),
        ));
        // D s_309_36: cast reint s_309_35 -> u8
        let s_309_36: u8 = (s_309_35.value() as u8);
        // D s_309_37: write-var u#32488 <= s_309_36
        fn_state.u_32488 = s_309_36;
        // C s_309_38: const #12s : i
        let s_309_38: i128 = 12;
        // D s_309_39: read-var u#32483:u32
        let s_309_39: u32 = fn_state.u_32483;
        // D s_309_40: cast zx s_309_39 -> bv
        let s_309_40: Bits = Bits::new(s_309_39 as u128, 32u16);
        // C s_309_41: const #1u : u64
        let s_309_41: u64 = 1;
        // D s_309_42: bit-extract s_309_40 s_309_38 s_309_41
        let s_309_42: Bits = (Bits::new(
            ((s_309_40) >> (s_309_38)).value(),
            u16::try_from(s_309_41).unwrap(),
        ));
        // D s_309_43: cast reint s_309_42 -> u8
        let s_309_43: bool = ((s_309_42.value()) != 0);
        // C s_309_44: const #0s : i
        let s_309_44: i128 = 0;
        // C s_309_45: const #0u : u64
        let s_309_45: u64 = 0;
        // D s_309_46: cast zx s_309_43 -> u64
        let s_309_46: u64 = (s_309_43 as u64);
        // C s_309_47: const #1u : u64
        let s_309_47: u64 = 1;
        // D s_309_48: and s_309_46 s_309_47
        let s_309_48: u64 = ((s_309_46) & (s_309_47));
        // D s_309_49: cmp-eq s_309_48 s_309_47
        let s_309_49: bool = ((s_309_48) == (s_309_47));
        // D s_309_50: lsl s_309_46 s_309_44
        let s_309_50: u64 = s_309_46 << s_309_44;
        // D s_309_51: or s_309_45 s_309_50
        let s_309_51: u64 = ((s_309_45) | (s_309_50));
        // D s_309_52: cmpl s_309_50
        let s_309_52: u64 = !s_309_50;
        // D s_309_53: and s_309_45 s_309_52
        let s_309_53: u64 = ((s_309_45) & (s_309_52));
        // D s_309_54: select s_309_49 s_309_51 s_309_53
        let s_309_54: u64 = if s_309_49 { s_309_51 } else { s_309_53 };
        // D s_309_55: cast trunc s_309_54 -> u8
        let s_309_55: bool = ((s_309_54) != 0);
        // D s_309_56: cast zx s_309_55 -> bv
        let s_309_56: Bits = Bits::new(s_309_55 as u128, 1u16);
        // C s_309_57: const #0u : u8
        let s_309_57: bool = false;
        // C s_309_58: cast zx s_309_57 -> bv
        let s_309_58: Bits = Bits::new(s_309_57 as u128, 1u16);
        // D s_309_59: cmp-ne s_309_56 s_309_58
        let s_309_59: bool = ((s_309_56) != (s_309_58));
        // N s_309_60: branch s_309_59 b320 b310
        if s_309_59 {
            return block_320(state, tracer, fn_state);
        } else {
            return block_310(state, tracer, fn_state);
        };
    }
    fn block_310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_310_0: const #13s : i
        let s_310_0: i128 = 13;
        // D s_310_1: read-var u#32483:u32
        let s_310_1: u32 = fn_state.u_32483;
        // D s_310_2: cast zx s_310_1 -> bv
        let s_310_2: Bits = Bits::new(s_310_1 as u128, 32u16);
        // C s_310_3: const #1u : u64
        let s_310_3: u64 = 1;
        // D s_310_4: bit-extract s_310_2 s_310_0 s_310_3
        let s_310_4: Bits = (Bits::new(
            ((s_310_2) >> (s_310_0)).value(),
            u16::try_from(s_310_3).unwrap(),
        ));
        // D s_310_5: cast reint s_310_4 -> u8
        let s_310_5: bool = ((s_310_4.value()) != 0);
        // C s_310_6: const #0s : i
        let s_310_6: i128 = 0;
        // C s_310_7: const #0u : u64
        let s_310_7: u64 = 0;
        // D s_310_8: cast zx s_310_5 -> u64
        let s_310_8: u64 = (s_310_5 as u64);
        // C s_310_9: const #1u : u64
        let s_310_9: u64 = 1;
        // D s_310_10: and s_310_8 s_310_9
        let s_310_10: u64 = ((s_310_8) & (s_310_9));
        // D s_310_11: cmp-eq s_310_10 s_310_9
        let s_310_11: bool = ((s_310_10) == (s_310_9));
        // D s_310_12: lsl s_310_8 s_310_6
        let s_310_12: u64 = s_310_8 << s_310_6;
        // D s_310_13: or s_310_7 s_310_12
        let s_310_13: u64 = ((s_310_7) | (s_310_12));
        // D s_310_14: cmpl s_310_12
        let s_310_14: u64 = !s_310_12;
        // D s_310_15: and s_310_7 s_310_14
        let s_310_15: u64 = ((s_310_7) & (s_310_14));
        // D s_310_16: select s_310_11 s_310_13 s_310_15
        let s_310_16: u64 = if s_310_11 { s_310_13 } else { s_310_15 };
        // D s_310_17: cast trunc s_310_16 -> u8
        let s_310_17: bool = ((s_310_16) != 0);
        // D s_310_18: cast zx s_310_17 -> bv
        let s_310_18: Bits = Bits::new(s_310_17 as u128, 1u16);
        // C s_310_19: const #0u : u8
        let s_310_19: bool = false;
        // C s_310_20: cast zx s_310_19 -> bv
        let s_310_20: Bits = Bits::new(s_310_19 as u128, 1u16);
        // D s_310_21: cmp-ne s_310_18 s_310_20
        let s_310_21: bool = ((s_310_18) != (s_310_20));
        // D s_310_22: write-var gs#404630 <= s_310_21
        fn_state.gs_404630 = s_310_21;
        // N s_310_23: jump b311
        return block_311(state, tracer, fn_state);
    }
    fn block_311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_311_0: read-var gs#404630:u8
        let s_311_0: bool = fn_state.gs_404630;
        // N s_311_1: branch s_311_0 b319 b312
        if s_311_0 {
            return block_319(state, tracer, fn_state);
        } else {
            return block_312(state, tracer, fn_state);
        };
    }
    fn block_312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_312_0: const #14s : i
        let s_312_0: i128 = 14;
        // D s_312_1: read-var u#32483:u32
        let s_312_1: u32 = fn_state.u_32483;
        // D s_312_2: cast zx s_312_1 -> bv
        let s_312_2: Bits = Bits::new(s_312_1 as u128, 32u16);
        // C s_312_3: const #1u : u64
        let s_312_3: u64 = 1;
        // D s_312_4: bit-extract s_312_2 s_312_0 s_312_3
        let s_312_4: Bits = (Bits::new(
            ((s_312_2) >> (s_312_0)).value(),
            u16::try_from(s_312_3).unwrap(),
        ));
        // D s_312_5: cast reint s_312_4 -> u8
        let s_312_5: bool = ((s_312_4.value()) != 0);
        // C s_312_6: const #0s : i
        let s_312_6: i128 = 0;
        // C s_312_7: const #0u : u64
        let s_312_7: u64 = 0;
        // D s_312_8: cast zx s_312_5 -> u64
        let s_312_8: u64 = (s_312_5 as u64);
        // C s_312_9: const #1u : u64
        let s_312_9: u64 = 1;
        // D s_312_10: and s_312_8 s_312_9
        let s_312_10: u64 = ((s_312_8) & (s_312_9));
        // D s_312_11: cmp-eq s_312_10 s_312_9
        let s_312_11: bool = ((s_312_10) == (s_312_9));
        // D s_312_12: lsl s_312_8 s_312_6
        let s_312_12: u64 = s_312_8 << s_312_6;
        // D s_312_13: or s_312_7 s_312_12
        let s_312_13: u64 = ((s_312_7) | (s_312_12));
        // D s_312_14: cmpl s_312_12
        let s_312_14: u64 = !s_312_12;
        // D s_312_15: and s_312_7 s_312_14
        let s_312_15: u64 = ((s_312_7) & (s_312_14));
        // D s_312_16: select s_312_11 s_312_13 s_312_15
        let s_312_16: u64 = if s_312_11 { s_312_13 } else { s_312_15 };
        // D s_312_17: cast trunc s_312_16 -> u8
        let s_312_17: bool = ((s_312_16) != 0);
        // D s_312_18: cast zx s_312_17 -> bv
        let s_312_18: Bits = Bits::new(s_312_17 as u128, 1u16);
        // C s_312_19: const #0u : u8
        let s_312_19: bool = false;
        // C s_312_20: cast zx s_312_19 -> bv
        let s_312_20: Bits = Bits::new(s_312_19 as u128, 1u16);
        // D s_312_21: cmp-ne s_312_18 s_312_20
        let s_312_21: bool = ((s_312_18) != (s_312_20));
        // D s_312_22: write-var gs#404633 <= s_312_21
        fn_state.gs_404633 = s_312_21;
        // N s_312_23: jump b313
        return block_313(state, tracer, fn_state);
    }
    fn block_313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_313_0: read-var gs#404633:u8
        let s_313_0: bool = fn_state.gs_404633;
        // N s_313_1: branch s_313_0 b318 b314
        if s_313_0 {
            return block_318(state, tracer, fn_state);
        } else {
            return block_314(state, tracer, fn_state);
        };
    }
    fn block_314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_314_0: const #15s : i
        let s_314_0: i128 = 15;
        // D s_314_1: read-var u#32483:u32
        let s_314_1: u32 = fn_state.u_32483;
        // D s_314_2: cast zx s_314_1 -> bv
        let s_314_2: Bits = Bits::new(s_314_1 as u128, 32u16);
        // C s_314_3: const #1u : u64
        let s_314_3: u64 = 1;
        // D s_314_4: bit-extract s_314_2 s_314_0 s_314_3
        let s_314_4: Bits = (Bits::new(
            ((s_314_2) >> (s_314_0)).value(),
            u16::try_from(s_314_3).unwrap(),
        ));
        // D s_314_5: cast reint s_314_4 -> u8
        let s_314_5: bool = ((s_314_4.value()) != 0);
        // C s_314_6: const #0s : i
        let s_314_6: i128 = 0;
        // C s_314_7: const #0u : u64
        let s_314_7: u64 = 0;
        // D s_314_8: cast zx s_314_5 -> u64
        let s_314_8: u64 = (s_314_5 as u64);
        // C s_314_9: const #1u : u64
        let s_314_9: u64 = 1;
        // D s_314_10: and s_314_8 s_314_9
        let s_314_10: u64 = ((s_314_8) & (s_314_9));
        // D s_314_11: cmp-eq s_314_10 s_314_9
        let s_314_11: bool = ((s_314_10) == (s_314_9));
        // D s_314_12: lsl s_314_8 s_314_6
        let s_314_12: u64 = s_314_8 << s_314_6;
        // D s_314_13: or s_314_7 s_314_12
        let s_314_13: u64 = ((s_314_7) | (s_314_12));
        // D s_314_14: cmpl s_314_12
        let s_314_14: u64 = !s_314_12;
        // D s_314_15: and s_314_7 s_314_14
        let s_314_15: u64 = ((s_314_7) & (s_314_14));
        // D s_314_16: select s_314_11 s_314_13 s_314_15
        let s_314_16: u64 = if s_314_11 { s_314_13 } else { s_314_15 };
        // D s_314_17: cast trunc s_314_16 -> u8
        let s_314_17: bool = ((s_314_16) != 0);
        // D s_314_18: cast zx s_314_17 -> bv
        let s_314_18: Bits = Bits::new(s_314_17 as u128, 1u16);
        // C s_314_19: const #0u : u8
        let s_314_19: bool = false;
        // C s_314_20: cast zx s_314_19 -> bv
        let s_314_20: Bits = Bits::new(s_314_19 as u128, 1u16);
        // D s_314_21: cmp-ne s_314_18 s_314_20
        let s_314_21: bool = ((s_314_18) != (s_314_20));
        // D s_314_22: write-var gs#404636 <= s_314_21
        fn_state.gs_404636 = s_314_21;
        // N s_314_23: jump b315
        return block_315(state, tracer, fn_state);
    }
    fn block_315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_315_0: read-var gs#404636:u8
        let s_315_0: bool = fn_state.gs_404636;
        // N s_315_1: branch s_315_0 b317 b316
        if s_315_0 {
            return block_317(state, tracer, fn_state);
        } else {
            return block_316(state, tracer, fn_state);
        };
    }
    fn block_316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_316_0: read-var u#32484:u8
        let s_316_0: u8 = fn_state.u_32484;
        // D s_316_1: read-var u#32485:u8
        let s_316_1: u8 = fn_state.u_32485;
        // D s_316_2: read-var u#32486:u8
        let s_316_2: u8 = fn_state.u_32486;
        // D s_316_3: read-var u#32487:u8
        let s_316_3: u8 = fn_state.u_32487;
        // D s_316_4: read-var u#32488:u8
        let s_316_4: u8 = fn_state.u_32488;
        // D s_316_5: call decode_aarch32_instrs_CMP_r_A1enc_A_txt(s_316_0, s_316_1, s_316_2, s_316_3, s_316_4)
        let s_316_5: () = decode_aarch32_instrs_CMP_r_A1enc_A_txt(
            state,
            tracer,
            s_316_0,
            s_316_1,
            s_316_2,
            s_316_3,
            s_316_4,
        );
        // N s_316_6: return
        return;
    }
    fn block_317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_317_0: panic
        panic!("{:?}", ());
        // N s_317_1: return
        return;
    }
    fn block_318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_318_0: const #1u : u8
        let s_318_0: bool = true;
        // D s_318_1: write-var gs#404636 <= s_318_0
        fn_state.gs_404636 = s_318_0;
        // N s_318_2: jump b315
        return block_315(state, tracer, fn_state);
    }
    fn block_319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_319_0: const #1u : u8
        let s_319_0: bool = true;
        // D s_319_1: write-var gs#404633 <= s_319_0
        fn_state.gs_404633 = s_319_0;
        // N s_319_2: jump b313
        return block_313(state, tracer, fn_state);
    }
    fn block_320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_320_0: const #1u : u8
        let s_320_0: bool = true;
        // D s_320_1: write-var gs#404630 <= s_320_0
        fn_state.gs_404630 = s_320_0;
        // N s_320_2: jump b311
        return block_311(state, tracer, fn_state);
    }
    fn block_321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_321_0: read-var merge#var.1:struct
        let s_321_0: u32 = fn_state.merge_var._1;
        // D s_321_1: write-var u#32490 <= s_321_0
        fn_state.u_32490 = s_321_0;
        // C s_321_2: const #20s : i
        let s_321_2: i128 = 20;
        // D s_321_3: read-var u#32490:u32
        let s_321_3: u32 = fn_state.u_32490;
        // D s_321_4: cast zx s_321_3 -> bv
        let s_321_4: Bits = Bits::new(s_321_3 as u128, 32u16);
        // C s_321_5: const #1s : i64
        let s_321_5: i64 = 1;
        // C s_321_6: cast zx s_321_5 -> i
        let s_321_6: i128 = (i128::try_from(s_321_5).unwrap());
        // C s_321_7: const #7s : i
        let s_321_7: i128 = 7;
        // C s_321_8: add s_321_7 s_321_6
        let s_321_8: i128 = (s_321_7 + s_321_6);
        // D s_321_9: bit-extract s_321_4 s_321_2 s_321_8
        let s_321_9: Bits = (Bits::new(
            ((s_321_4) >> (s_321_2)).value(),
            u16::try_from(s_321_8).unwrap(),
        ));
        // D s_321_10: cast reint s_321_9 -> u8
        let s_321_10: u8 = (s_321_9.value() as u8);
        // D s_321_11: cast zx s_321_10 -> bv
        let s_321_11: Bits = Bits::new(s_321_10 as u128, 8u16);
        // C s_321_12: const #21u : u8
        let s_321_12: u8 = 21;
        // C s_321_13: cast zx s_321_12 -> bv
        let s_321_13: Bits = Bits::new(s_321_12 as u128, 8u16);
        // D s_321_14: cmp-eq s_321_11 s_321_13
        let s_321_14: bool = ((s_321_11) == (s_321_13));
        // N s_321_15: branch s_321_14 b2845 b322
        if s_321_14 {
            return block_2845(state, tracer, fn_state);
        } else {
            return block_322(state, tracer, fn_state);
        };
    }
    fn block_322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_322_0: const #0u : u8
        let s_322_0: bool = false;
        // D s_322_1: write-var gs#404648 <= s_322_0
        fn_state.gs_404648 = s_322_0;
        // N s_322_2: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_323_0: read-var gs#404648:u8
        let s_323_0: bool = fn_state.gs_404648;
        // N s_323_1: branch s_323_0 b2841 b324
        if s_323_0 {
            return block_2841(state, tracer, fn_state);
        } else {
            return block_324(state, tracer, fn_state);
        };
    }
    fn block_324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_324_0: const #0u : u8
        let s_324_0: bool = false;
        // D s_324_1: write-var gs#404653 <= s_324_0
        fn_state.gs_404653 = s_324_0;
        // N s_324_2: jump b325
        return block_325(state, tracer, fn_state);
    }
    fn block_325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_325_0: read-var gs#404653:u8
        let s_325_0: bool = fn_state.gs_404653;
        // D s_325_1: not s_325_0
        let s_325_1: bool = !s_325_0;
        // N s_325_2: branch s_325_1 b338 b326
        if s_325_1 {
            return block_338(state, tracer, fn_state);
        } else {
            return block_326(state, tracer, fn_state);
        };
    }
    fn block_326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_326_0: const #2896s : i
        let s_326_0: i128 = 2896;
        // C s_326_1: const #14696u : u32
        let s_326_1: u32 = 14696;
        // N s_326_2: write-reg s_326_1 <= s_326_0
        let s_326_2: () = {
            state.write_register::<i128>(s_326_1 as isize, s_326_0);
            tracer.write_register(s_326_1 as isize, s_326_0);
        };
        // C s_326_3: const #28s : i
        let s_326_3: i128 = 28;
        // C s_326_4: const #4s : i
        let s_326_4: i128 = 4;
        // D s_326_5: read-var u#32490:u32
        let s_326_5: u32 = fn_state.u_32490;
        // D s_326_6: cast zx s_326_5 -> bv
        let s_326_6: Bits = Bits::new(s_326_5 as u128, 32u16);
        // D s_326_7: bit-extract s_326_6 s_326_3 s_326_4
        let s_326_7: Bits = (Bits::new(
            ((s_326_6) >> (s_326_3)).value(),
            u16::try_from(s_326_4).unwrap(),
        ));
        // D s_326_8: cast reint s_326_7 -> u8
        let s_326_8: u8 = (s_326_7.value() as u8);
        // D s_326_9: write-var u#32491 <= s_326_8
        fn_state.u_32491 = s_326_8;
        // C s_326_10: const #16s : i
        let s_326_10: i128 = 16;
        // C s_326_11: const #4s : i
        let s_326_11: i128 = 4;
        // D s_326_12: read-var u#32490:u32
        let s_326_12: u32 = fn_state.u_32490;
        // D s_326_13: cast zx s_326_12 -> bv
        let s_326_13: Bits = Bits::new(s_326_12 as u128, 32u16);
        // D s_326_14: bit-extract s_326_13 s_326_10 s_326_11
        let s_326_14: Bits = (Bits::new(
            ((s_326_13) >> (s_326_10)).value(),
            u16::try_from(s_326_11).unwrap(),
        ));
        // D s_326_15: cast reint s_326_14 -> u8
        let s_326_15: u8 = (s_326_14.value() as u8);
        // D s_326_16: write-var u#32492 <= s_326_15
        fn_state.u_32492 = s_326_15;
        // C s_326_17: const #8s : i
        let s_326_17: i128 = 8;
        // C s_326_18: const #4s : i
        let s_326_18: i128 = 4;
        // D s_326_19: read-var u#32490:u32
        let s_326_19: u32 = fn_state.u_32490;
        // D s_326_20: cast zx s_326_19 -> bv
        let s_326_20: Bits = Bits::new(s_326_19 as u128, 32u16);
        // D s_326_21: bit-extract s_326_20 s_326_17 s_326_18
        let s_326_21: Bits = (Bits::new(
            ((s_326_20) >> (s_326_17)).value(),
            u16::try_from(s_326_18).unwrap(),
        ));
        // D s_326_22: cast reint s_326_21 -> u8
        let s_326_22: u8 = (s_326_21.value() as u8);
        // D s_326_23: write-var u#32493 <= s_326_22
        fn_state.u_32493 = s_326_22;
        // C s_326_24: const #5s : i
        let s_326_24: i128 = 5;
        // C s_326_25: const #2s : i
        let s_326_25: i128 = 2;
        // D s_326_26: read-var u#32490:u32
        let s_326_26: u32 = fn_state.u_32490;
        // D s_326_27: cast zx s_326_26 -> bv
        let s_326_27: Bits = Bits::new(s_326_26 as u128, 32u16);
        // D s_326_28: bit-extract s_326_27 s_326_24 s_326_25
        let s_326_28: Bits = (Bits::new(
            ((s_326_27) >> (s_326_24)).value(),
            u16::try_from(s_326_25).unwrap(),
        ));
        // D s_326_29: cast reint s_326_28 -> u8
        let s_326_29: u8 = (s_326_28.value() as u8);
        // D s_326_30: write-var u#32494 <= s_326_29
        fn_state.u_32494 = s_326_29;
        // C s_326_31: const #0s : i
        let s_326_31: i128 = 0;
        // C s_326_32: const #4s : i
        let s_326_32: i128 = 4;
        // D s_326_33: read-var u#32490:u32
        let s_326_33: u32 = fn_state.u_32490;
        // D s_326_34: cast zx s_326_33 -> bv
        let s_326_34: Bits = Bits::new(s_326_33 as u128, 32u16);
        // D s_326_35: bit-extract s_326_34 s_326_31 s_326_32
        let s_326_35: Bits = (Bits::new(
            ((s_326_34) >> (s_326_31)).value(),
            u16::try_from(s_326_32).unwrap(),
        ));
        // D s_326_36: cast reint s_326_35 -> u8
        let s_326_36: u8 = (s_326_35.value() as u8);
        // D s_326_37: write-var u#32495 <= s_326_36
        fn_state.u_32495 = s_326_36;
        // C s_326_38: const #12s : i
        let s_326_38: i128 = 12;
        // D s_326_39: read-var u#32490:u32
        let s_326_39: u32 = fn_state.u_32490;
        // D s_326_40: cast zx s_326_39 -> bv
        let s_326_40: Bits = Bits::new(s_326_39 as u128, 32u16);
        // C s_326_41: const #1u : u64
        let s_326_41: u64 = 1;
        // D s_326_42: bit-extract s_326_40 s_326_38 s_326_41
        let s_326_42: Bits = (Bits::new(
            ((s_326_40) >> (s_326_38)).value(),
            u16::try_from(s_326_41).unwrap(),
        ));
        // D s_326_43: cast reint s_326_42 -> u8
        let s_326_43: bool = ((s_326_42.value()) != 0);
        // C s_326_44: const #0s : i
        let s_326_44: i128 = 0;
        // C s_326_45: const #0u : u64
        let s_326_45: u64 = 0;
        // D s_326_46: cast zx s_326_43 -> u64
        let s_326_46: u64 = (s_326_43 as u64);
        // C s_326_47: const #1u : u64
        let s_326_47: u64 = 1;
        // D s_326_48: and s_326_46 s_326_47
        let s_326_48: u64 = ((s_326_46) & (s_326_47));
        // D s_326_49: cmp-eq s_326_48 s_326_47
        let s_326_49: bool = ((s_326_48) == (s_326_47));
        // D s_326_50: lsl s_326_46 s_326_44
        let s_326_50: u64 = s_326_46 << s_326_44;
        // D s_326_51: or s_326_45 s_326_50
        let s_326_51: u64 = ((s_326_45) | (s_326_50));
        // D s_326_52: cmpl s_326_50
        let s_326_52: u64 = !s_326_50;
        // D s_326_53: and s_326_45 s_326_52
        let s_326_53: u64 = ((s_326_45) & (s_326_52));
        // D s_326_54: select s_326_49 s_326_51 s_326_53
        let s_326_54: u64 = if s_326_49 { s_326_51 } else { s_326_53 };
        // D s_326_55: cast trunc s_326_54 -> u8
        let s_326_55: bool = ((s_326_54) != 0);
        // D s_326_56: cast zx s_326_55 -> bv
        let s_326_56: Bits = Bits::new(s_326_55 as u128, 1u16);
        // C s_326_57: const #0u : u8
        let s_326_57: bool = false;
        // C s_326_58: cast zx s_326_57 -> bv
        let s_326_58: Bits = Bits::new(s_326_57 as u128, 1u16);
        // D s_326_59: cmp-ne s_326_56 s_326_58
        let s_326_59: bool = ((s_326_56) != (s_326_58));
        // N s_326_60: branch s_326_59 b337 b327
        if s_326_59 {
            return block_337(state, tracer, fn_state);
        } else {
            return block_327(state, tracer, fn_state);
        };
    }
    fn block_327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_327_0: const #13s : i
        let s_327_0: i128 = 13;
        // D s_327_1: read-var u#32490:u32
        let s_327_1: u32 = fn_state.u_32490;
        // D s_327_2: cast zx s_327_1 -> bv
        let s_327_2: Bits = Bits::new(s_327_1 as u128, 32u16);
        // C s_327_3: const #1u : u64
        let s_327_3: u64 = 1;
        // D s_327_4: bit-extract s_327_2 s_327_0 s_327_3
        let s_327_4: Bits = (Bits::new(
            ((s_327_2) >> (s_327_0)).value(),
            u16::try_from(s_327_3).unwrap(),
        ));
        // D s_327_5: cast reint s_327_4 -> u8
        let s_327_5: bool = ((s_327_4.value()) != 0);
        // C s_327_6: const #0s : i
        let s_327_6: i128 = 0;
        // C s_327_7: const #0u : u64
        let s_327_7: u64 = 0;
        // D s_327_8: cast zx s_327_5 -> u64
        let s_327_8: u64 = (s_327_5 as u64);
        // C s_327_9: const #1u : u64
        let s_327_9: u64 = 1;
        // D s_327_10: and s_327_8 s_327_9
        let s_327_10: u64 = ((s_327_8) & (s_327_9));
        // D s_327_11: cmp-eq s_327_10 s_327_9
        let s_327_11: bool = ((s_327_10) == (s_327_9));
        // D s_327_12: lsl s_327_8 s_327_6
        let s_327_12: u64 = s_327_8 << s_327_6;
        // D s_327_13: or s_327_7 s_327_12
        let s_327_13: u64 = ((s_327_7) | (s_327_12));
        // D s_327_14: cmpl s_327_12
        let s_327_14: u64 = !s_327_12;
        // D s_327_15: and s_327_7 s_327_14
        let s_327_15: u64 = ((s_327_7) & (s_327_14));
        // D s_327_16: select s_327_11 s_327_13 s_327_15
        let s_327_16: u64 = if s_327_11 { s_327_13 } else { s_327_15 };
        // D s_327_17: cast trunc s_327_16 -> u8
        let s_327_17: bool = ((s_327_16) != 0);
        // D s_327_18: cast zx s_327_17 -> bv
        let s_327_18: Bits = Bits::new(s_327_17 as u128, 1u16);
        // C s_327_19: const #0u : u8
        let s_327_19: bool = false;
        // C s_327_20: cast zx s_327_19 -> bv
        let s_327_20: Bits = Bits::new(s_327_19 as u128, 1u16);
        // D s_327_21: cmp-ne s_327_18 s_327_20
        let s_327_21: bool = ((s_327_18) != (s_327_20));
        // D s_327_22: write-var gs#404670 <= s_327_21
        fn_state.gs_404670 = s_327_21;
        // N s_327_23: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_328_0: read-var gs#404670:u8
        let s_328_0: bool = fn_state.gs_404670;
        // N s_328_1: branch s_328_0 b336 b329
        if s_328_0 {
            return block_336(state, tracer, fn_state);
        } else {
            return block_329(state, tracer, fn_state);
        };
    }
    fn block_329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_329_0: const #14s : i
        let s_329_0: i128 = 14;
        // D s_329_1: read-var u#32490:u32
        let s_329_1: u32 = fn_state.u_32490;
        // D s_329_2: cast zx s_329_1 -> bv
        let s_329_2: Bits = Bits::new(s_329_1 as u128, 32u16);
        // C s_329_3: const #1u : u64
        let s_329_3: u64 = 1;
        // D s_329_4: bit-extract s_329_2 s_329_0 s_329_3
        let s_329_4: Bits = (Bits::new(
            ((s_329_2) >> (s_329_0)).value(),
            u16::try_from(s_329_3).unwrap(),
        ));
        // D s_329_5: cast reint s_329_4 -> u8
        let s_329_5: bool = ((s_329_4.value()) != 0);
        // C s_329_6: const #0s : i
        let s_329_6: i128 = 0;
        // C s_329_7: const #0u : u64
        let s_329_7: u64 = 0;
        // D s_329_8: cast zx s_329_5 -> u64
        let s_329_8: u64 = (s_329_5 as u64);
        // C s_329_9: const #1u : u64
        let s_329_9: u64 = 1;
        // D s_329_10: and s_329_8 s_329_9
        let s_329_10: u64 = ((s_329_8) & (s_329_9));
        // D s_329_11: cmp-eq s_329_10 s_329_9
        let s_329_11: bool = ((s_329_10) == (s_329_9));
        // D s_329_12: lsl s_329_8 s_329_6
        let s_329_12: u64 = s_329_8 << s_329_6;
        // D s_329_13: or s_329_7 s_329_12
        let s_329_13: u64 = ((s_329_7) | (s_329_12));
        // D s_329_14: cmpl s_329_12
        let s_329_14: u64 = !s_329_12;
        // D s_329_15: and s_329_7 s_329_14
        let s_329_15: u64 = ((s_329_7) & (s_329_14));
        // D s_329_16: select s_329_11 s_329_13 s_329_15
        let s_329_16: u64 = if s_329_11 { s_329_13 } else { s_329_15 };
        // D s_329_17: cast trunc s_329_16 -> u8
        let s_329_17: bool = ((s_329_16) != 0);
        // D s_329_18: cast zx s_329_17 -> bv
        let s_329_18: Bits = Bits::new(s_329_17 as u128, 1u16);
        // C s_329_19: const #0u : u8
        let s_329_19: bool = false;
        // C s_329_20: cast zx s_329_19 -> bv
        let s_329_20: Bits = Bits::new(s_329_19 as u128, 1u16);
        // D s_329_21: cmp-ne s_329_18 s_329_20
        let s_329_21: bool = ((s_329_18) != (s_329_20));
        // D s_329_22: write-var gs#404673 <= s_329_21
        fn_state.gs_404673 = s_329_21;
        // N s_329_23: jump b330
        return block_330(state, tracer, fn_state);
    }
    fn block_330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_330_0: read-var gs#404673:u8
        let s_330_0: bool = fn_state.gs_404673;
        // N s_330_1: branch s_330_0 b335 b331
        if s_330_0 {
            return block_335(state, tracer, fn_state);
        } else {
            return block_331(state, tracer, fn_state);
        };
    }
    fn block_331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_331_0: const #15s : i
        let s_331_0: i128 = 15;
        // D s_331_1: read-var u#32490:u32
        let s_331_1: u32 = fn_state.u_32490;
        // D s_331_2: cast zx s_331_1 -> bv
        let s_331_2: Bits = Bits::new(s_331_1 as u128, 32u16);
        // C s_331_3: const #1u : u64
        let s_331_3: u64 = 1;
        // D s_331_4: bit-extract s_331_2 s_331_0 s_331_3
        let s_331_4: Bits = (Bits::new(
            ((s_331_2) >> (s_331_0)).value(),
            u16::try_from(s_331_3).unwrap(),
        ));
        // D s_331_5: cast reint s_331_4 -> u8
        let s_331_5: bool = ((s_331_4.value()) != 0);
        // C s_331_6: const #0s : i
        let s_331_6: i128 = 0;
        // C s_331_7: const #0u : u64
        let s_331_7: u64 = 0;
        // D s_331_8: cast zx s_331_5 -> u64
        let s_331_8: u64 = (s_331_5 as u64);
        // C s_331_9: const #1u : u64
        let s_331_9: u64 = 1;
        // D s_331_10: and s_331_8 s_331_9
        let s_331_10: u64 = ((s_331_8) & (s_331_9));
        // D s_331_11: cmp-eq s_331_10 s_331_9
        let s_331_11: bool = ((s_331_10) == (s_331_9));
        // D s_331_12: lsl s_331_8 s_331_6
        let s_331_12: u64 = s_331_8 << s_331_6;
        // D s_331_13: or s_331_7 s_331_12
        let s_331_13: u64 = ((s_331_7) | (s_331_12));
        // D s_331_14: cmpl s_331_12
        let s_331_14: u64 = !s_331_12;
        // D s_331_15: and s_331_7 s_331_14
        let s_331_15: u64 = ((s_331_7) & (s_331_14));
        // D s_331_16: select s_331_11 s_331_13 s_331_15
        let s_331_16: u64 = if s_331_11 { s_331_13 } else { s_331_15 };
        // D s_331_17: cast trunc s_331_16 -> u8
        let s_331_17: bool = ((s_331_16) != 0);
        // D s_331_18: cast zx s_331_17 -> bv
        let s_331_18: Bits = Bits::new(s_331_17 as u128, 1u16);
        // C s_331_19: const #0u : u8
        let s_331_19: bool = false;
        // C s_331_20: cast zx s_331_19 -> bv
        let s_331_20: Bits = Bits::new(s_331_19 as u128, 1u16);
        // D s_331_21: cmp-ne s_331_18 s_331_20
        let s_331_21: bool = ((s_331_18) != (s_331_20));
        // D s_331_22: write-var gs#404676 <= s_331_21
        fn_state.gs_404676 = s_331_21;
        // N s_331_23: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_332_0: read-var gs#404676:u8
        let s_332_0: bool = fn_state.gs_404676;
        // N s_332_1: branch s_332_0 b334 b333
        if s_332_0 {
            return block_334(state, tracer, fn_state);
        } else {
            return block_333(state, tracer, fn_state);
        };
    }
    fn block_333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_333_0: read-var u#32491:u8
        let s_333_0: u8 = fn_state.u_32491;
        // D s_333_1: read-var u#32492:u8
        let s_333_1: u8 = fn_state.u_32492;
        // D s_333_2: read-var u#32493:u8
        let s_333_2: u8 = fn_state.u_32493;
        // D s_333_3: read-var u#32494:u8
        let s_333_3: u8 = fn_state.u_32494;
        // D s_333_4: read-var u#32495:u8
        let s_333_4: u8 = fn_state.u_32495;
        // D s_333_5: call decode_aarch32_instrs_CMP_rr_A1enc_A_txt(s_333_0, s_333_1, s_333_2, s_333_3, s_333_4)
        let s_333_5: () = decode_aarch32_instrs_CMP_rr_A1enc_A_txt(
            state,
            tracer,
            s_333_0,
            s_333_1,
            s_333_2,
            s_333_3,
            s_333_4,
        );
        // N s_333_6: return
        return;
    }
    fn block_334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_334_0: panic
        panic!("{:?}", ());
        // N s_334_1: return
        return;
    }
    fn block_335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_335_0: const #1u : u8
        let s_335_0: bool = true;
        // D s_335_1: write-var gs#404676 <= s_335_0
        fn_state.gs_404676 = s_335_0;
        // N s_335_2: jump b332
        return block_332(state, tracer, fn_state);
    }
    fn block_336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_336_0: const #1u : u8
        let s_336_0: bool = true;
        // D s_336_1: write-var gs#404673 <= s_336_0
        fn_state.gs_404673 = s_336_0;
        // N s_336_2: jump b330
        return block_330(state, tracer, fn_state);
    }
    fn block_337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_337_0: const #1u : u8
        let s_337_0: bool = true;
        // D s_337_1: write-var gs#404670 <= s_337_0
        fn_state.gs_404670 = s_337_0;
        // N s_337_2: jump b328
        return block_328(state, tracer, fn_state);
    }
    fn block_338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_338_0: read-var merge#var.1:struct
        let s_338_0: u32 = fn_state.merge_var._1;
        // D s_338_1: write-var u#32497 <= s_338_0
        fn_state.u_32497 = s_338_0;
        // C s_338_2: const #4s : i
        let s_338_2: i128 = 4;
        // D s_338_3: read-var u#32497:u32
        let s_338_3: u32 = fn_state.u_32497;
        // D s_338_4: cast zx s_338_3 -> bv
        let s_338_4: Bits = Bits::new(s_338_3 as u128, 32u16);
        // C s_338_5: const #1s : i64
        let s_338_5: i64 = 1;
        // C s_338_6: cast zx s_338_5 -> i
        let s_338_6: i128 = (i128::try_from(s_338_5).unwrap());
        // C s_338_7: const #23s : i
        let s_338_7: i128 = 23;
        // C s_338_8: add s_338_7 s_338_6
        let s_338_8: i128 = (s_338_7 + s_338_6);
        // D s_338_9: bit-extract s_338_4 s_338_2 s_338_8
        let s_338_9: Bits = (Bits::new(
            ((s_338_4) >> (s_338_2)).value(),
            u16::try_from(s_338_8).unwrap(),
        ));
        // D s_338_10: cast reint s_338_9 -> u24
        let s_338_10: u32 = (s_338_9.value() as u32);
        // D s_338_11: cast zx s_338_10 -> bv
        let s_338_11: Bits = Bits::new(s_338_10 as u128, 24u16);
        // C s_338_12: const #3280655u : u24
        let s_338_12: u32 = 3280655;
        // C s_338_13: cast zx s_338_12 -> bv
        let s_338_13: Bits = Bits::new(s_338_12 as u128, 24u16);
        // D s_338_14: cmp-eq s_338_11 s_338_13
        let s_338_14: bool = ((s_338_11) == (s_338_13));
        // N s_338_15: branch s_338_14 b2837 b339
        if s_338_14 {
            return block_2837(state, tracer, fn_state);
        } else {
            return block_339(state, tracer, fn_state);
        };
    }
    fn block_339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_339_0: const #0u : u8
        let s_339_0: bool = false;
        // D s_339_1: write-var gs#404684 <= s_339_0
        fn_state.gs_404684 = s_339_0;
        // N s_339_2: jump b340
        return block_340(state, tracer, fn_state);
    }
    fn block_340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_340_0: read-var gs#404684:u8
        let s_340_0: bool = fn_state.gs_404684;
        // D s_340_1: not s_340_0
        let s_340_1: bool = !s_340_0;
        // N s_340_2: branch s_340_1 b365 b341
        if s_340_1 {
            return block_365(state, tracer, fn_state);
        } else {
            return block_341(state, tracer, fn_state);
        };
    }
    fn block_341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_341_0: const #2897s : i
        let s_341_0: i128 = 2897;
        // C s_341_1: const #14696u : u32
        let s_341_1: u32 = 14696;
        // N s_341_2: write-reg s_341_1 <= s_341_0
        let s_341_2: () = {
            state.write_register::<i128>(s_341_1 as isize, s_341_0);
            tracer.write_register(s_341_1 as isize, s_341_0);
        };
        // C s_341_3: const #28s : i
        let s_341_3: i128 = 28;
        // C s_341_4: const #4s : i
        let s_341_4: i128 = 4;
        // D s_341_5: read-var u#32497:u32
        let s_341_5: u32 = fn_state.u_32497;
        // D s_341_6: cast zx s_341_5 -> bv
        let s_341_6: Bits = Bits::new(s_341_5 as u128, 32u16);
        // D s_341_7: bit-extract s_341_6 s_341_3 s_341_4
        let s_341_7: Bits = (Bits::new(
            ((s_341_6) >> (s_341_3)).value(),
            u16::try_from(s_341_4).unwrap(),
        ));
        // D s_341_8: cast reint s_341_7 -> u8
        let s_341_8: u8 = (s_341_7.value() as u8);
        // D s_341_9: write-var u#32498 <= s_341_8
        fn_state.u_32498 = s_341_8;
        // C s_341_10: const #0s : i
        let s_341_10: i128 = 0;
        // C s_341_11: const #4s : i
        let s_341_11: i128 = 4;
        // D s_341_12: read-var u#32497:u32
        let s_341_12: u32 = fn_state.u_32497;
        // D s_341_13: cast zx s_341_12 -> bv
        let s_341_13: Bits = Bits::new(s_341_12 as u128, 32u16);
        // D s_341_14: bit-extract s_341_13 s_341_10 s_341_11
        let s_341_14: Bits = (Bits::new(
            ((s_341_13) >> (s_341_10)).value(),
            u16::try_from(s_341_11).unwrap(),
        ));
        // D s_341_15: cast reint s_341_14 -> u8
        let s_341_15: u8 = (s_341_14.value() as u8);
        // D s_341_16: write-var option_name <= s_341_15
        fn_state.option_name = s_341_15;
        // C s_341_17: const #12s : i
        let s_341_17: i128 = 12;
        // D s_341_18: read-var u#32497:u32
        let s_341_18: u32 = fn_state.u_32497;
        // D s_341_19: cast zx s_341_18 -> bv
        let s_341_19: Bits = Bits::new(s_341_18 as u128, 32u16);
        // C s_341_20: const #1u : u64
        let s_341_20: u64 = 1;
        // D s_341_21: bit-extract s_341_19 s_341_17 s_341_20
        let s_341_21: Bits = (Bits::new(
            ((s_341_19) >> (s_341_17)).value(),
            u16::try_from(s_341_20).unwrap(),
        ));
        // D s_341_22: cast reint s_341_21 -> u8
        let s_341_22: bool = ((s_341_21.value()) != 0);
        // C s_341_23: const #0s : i
        let s_341_23: i128 = 0;
        // C s_341_24: const #0u : u64
        let s_341_24: u64 = 0;
        // D s_341_25: cast zx s_341_22 -> u64
        let s_341_25: u64 = (s_341_22 as u64);
        // C s_341_26: const #1u : u64
        let s_341_26: u64 = 1;
        // D s_341_27: and s_341_25 s_341_26
        let s_341_27: u64 = ((s_341_25) & (s_341_26));
        // D s_341_28: cmp-eq s_341_27 s_341_26
        let s_341_28: bool = ((s_341_27) == (s_341_26));
        // D s_341_29: lsl s_341_25 s_341_23
        let s_341_29: u64 = s_341_25 << s_341_23;
        // D s_341_30: or s_341_24 s_341_29
        let s_341_30: u64 = ((s_341_24) | (s_341_29));
        // D s_341_31: cmpl s_341_29
        let s_341_31: u64 = !s_341_29;
        // D s_341_32: and s_341_24 s_341_31
        let s_341_32: u64 = ((s_341_24) & (s_341_31));
        // D s_341_33: select s_341_28 s_341_30 s_341_32
        let s_341_33: u64 = if s_341_28 { s_341_30 } else { s_341_32 };
        // D s_341_34: cast trunc s_341_33 -> u8
        let s_341_34: bool = ((s_341_33) != 0);
        // D s_341_35: cast zx s_341_34 -> bv
        let s_341_35: Bits = Bits::new(s_341_34 as u128, 1u16);
        // C s_341_36: const #1u : u8
        let s_341_36: bool = true;
        // C s_341_37: cast zx s_341_36 -> bv
        let s_341_37: Bits = Bits::new(s_341_36 as u128, 1u16);
        // D s_341_38: cmp-ne s_341_35 s_341_37
        let s_341_38: bool = ((s_341_35) != (s_341_37));
        // N s_341_39: branch s_341_38 b364 b342
        if s_341_38 {
            return block_364(state, tracer, fn_state);
        } else {
            return block_342(state, tracer, fn_state);
        };
    }
    fn block_342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_342_0: const #13s : i
        let s_342_0: i128 = 13;
        // D s_342_1: read-var u#32497:u32
        let s_342_1: u32 = fn_state.u_32497;
        // D s_342_2: cast zx s_342_1 -> bv
        let s_342_2: Bits = Bits::new(s_342_1 as u128, 32u16);
        // C s_342_3: const #1u : u64
        let s_342_3: u64 = 1;
        // D s_342_4: bit-extract s_342_2 s_342_0 s_342_3
        let s_342_4: Bits = (Bits::new(
            ((s_342_2) >> (s_342_0)).value(),
            u16::try_from(s_342_3).unwrap(),
        ));
        // D s_342_5: cast reint s_342_4 -> u8
        let s_342_5: bool = ((s_342_4.value()) != 0);
        // C s_342_6: const #0s : i
        let s_342_6: i128 = 0;
        // C s_342_7: const #0u : u64
        let s_342_7: u64 = 0;
        // D s_342_8: cast zx s_342_5 -> u64
        let s_342_8: u64 = (s_342_5 as u64);
        // C s_342_9: const #1u : u64
        let s_342_9: u64 = 1;
        // D s_342_10: and s_342_8 s_342_9
        let s_342_10: u64 = ((s_342_8) & (s_342_9));
        // D s_342_11: cmp-eq s_342_10 s_342_9
        let s_342_11: bool = ((s_342_10) == (s_342_9));
        // D s_342_12: lsl s_342_8 s_342_6
        let s_342_12: u64 = s_342_8 << s_342_6;
        // D s_342_13: or s_342_7 s_342_12
        let s_342_13: u64 = ((s_342_7) | (s_342_12));
        // D s_342_14: cmpl s_342_12
        let s_342_14: u64 = !s_342_12;
        // D s_342_15: and s_342_7 s_342_14
        let s_342_15: u64 = ((s_342_7) & (s_342_14));
        // D s_342_16: select s_342_11 s_342_13 s_342_15
        let s_342_16: u64 = if s_342_11 { s_342_13 } else { s_342_15 };
        // D s_342_17: cast trunc s_342_16 -> u8
        let s_342_17: bool = ((s_342_16) != 0);
        // D s_342_18: cast zx s_342_17 -> bv
        let s_342_18: Bits = Bits::new(s_342_17 as u128, 1u16);
        // C s_342_19: const #1u : u8
        let s_342_19: bool = true;
        // C s_342_20: cast zx s_342_19 -> bv
        let s_342_20: Bits = Bits::new(s_342_19 as u128, 1u16);
        // D s_342_21: cmp-ne s_342_18 s_342_20
        let s_342_21: bool = ((s_342_18) != (s_342_20));
        // D s_342_22: write-var gs#404695 <= s_342_21
        fn_state.gs_404695 = s_342_21;
        // N s_342_23: jump b343
        return block_343(state, tracer, fn_state);
    }
    fn block_343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_343_0: read-var gs#404695:u8
        let s_343_0: bool = fn_state.gs_404695;
        // N s_343_1: branch s_343_0 b363 b344
        if s_343_0 {
            return block_363(state, tracer, fn_state);
        } else {
            return block_344(state, tracer, fn_state);
        };
    }
    fn block_344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_344_0: const #14s : i
        let s_344_0: i128 = 14;
        // D s_344_1: read-var u#32497:u32
        let s_344_1: u32 = fn_state.u_32497;
        // D s_344_2: cast zx s_344_1 -> bv
        let s_344_2: Bits = Bits::new(s_344_1 as u128, 32u16);
        // C s_344_3: const #1u : u64
        let s_344_3: u64 = 1;
        // D s_344_4: bit-extract s_344_2 s_344_0 s_344_3
        let s_344_4: Bits = (Bits::new(
            ((s_344_2) >> (s_344_0)).value(),
            u16::try_from(s_344_3).unwrap(),
        ));
        // D s_344_5: cast reint s_344_4 -> u8
        let s_344_5: bool = ((s_344_4.value()) != 0);
        // C s_344_6: const #0s : i
        let s_344_6: i128 = 0;
        // C s_344_7: const #0u : u64
        let s_344_7: u64 = 0;
        // D s_344_8: cast zx s_344_5 -> u64
        let s_344_8: u64 = (s_344_5 as u64);
        // C s_344_9: const #1u : u64
        let s_344_9: u64 = 1;
        // D s_344_10: and s_344_8 s_344_9
        let s_344_10: u64 = ((s_344_8) & (s_344_9));
        // D s_344_11: cmp-eq s_344_10 s_344_9
        let s_344_11: bool = ((s_344_10) == (s_344_9));
        // D s_344_12: lsl s_344_8 s_344_6
        let s_344_12: u64 = s_344_8 << s_344_6;
        // D s_344_13: or s_344_7 s_344_12
        let s_344_13: u64 = ((s_344_7) | (s_344_12));
        // D s_344_14: cmpl s_344_12
        let s_344_14: u64 = !s_344_12;
        // D s_344_15: and s_344_7 s_344_14
        let s_344_15: u64 = ((s_344_7) & (s_344_14));
        // D s_344_16: select s_344_11 s_344_13 s_344_15
        let s_344_16: u64 = if s_344_11 { s_344_13 } else { s_344_15 };
        // D s_344_17: cast trunc s_344_16 -> u8
        let s_344_17: bool = ((s_344_16) != 0);
        // D s_344_18: cast zx s_344_17 -> bv
        let s_344_18: Bits = Bits::new(s_344_17 as u128, 1u16);
        // C s_344_19: const #1u : u8
        let s_344_19: bool = true;
        // C s_344_20: cast zx s_344_19 -> bv
        let s_344_20: Bits = Bits::new(s_344_19 as u128, 1u16);
        // D s_344_21: cmp-ne s_344_18 s_344_20
        let s_344_21: bool = ((s_344_18) != (s_344_20));
        // D s_344_22: write-var gs#404698 <= s_344_21
        fn_state.gs_404698 = s_344_21;
        // N s_344_23: jump b345
        return block_345(state, tracer, fn_state);
    }
    fn block_345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_345_0: read-var gs#404698:u8
        let s_345_0: bool = fn_state.gs_404698;
        // N s_345_1: branch s_345_0 b362 b346
        if s_345_0 {
            return block_362(state, tracer, fn_state);
        } else {
            return block_346(state, tracer, fn_state);
        };
    }
    fn block_346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_346_0: const #15s : i
        let s_346_0: i128 = 15;
        // D s_346_1: read-var u#32497:u32
        let s_346_1: u32 = fn_state.u_32497;
        // D s_346_2: cast zx s_346_1 -> bv
        let s_346_2: Bits = Bits::new(s_346_1 as u128, 32u16);
        // C s_346_3: const #1u : u64
        let s_346_3: u64 = 1;
        // D s_346_4: bit-extract s_346_2 s_346_0 s_346_3
        let s_346_4: Bits = (Bits::new(
            ((s_346_2) >> (s_346_0)).value(),
            u16::try_from(s_346_3).unwrap(),
        ));
        // D s_346_5: cast reint s_346_4 -> u8
        let s_346_5: bool = ((s_346_4.value()) != 0);
        // C s_346_6: const #0s : i
        let s_346_6: i128 = 0;
        // C s_346_7: const #0u : u64
        let s_346_7: u64 = 0;
        // D s_346_8: cast zx s_346_5 -> u64
        let s_346_8: u64 = (s_346_5 as u64);
        // C s_346_9: const #1u : u64
        let s_346_9: u64 = 1;
        // D s_346_10: and s_346_8 s_346_9
        let s_346_10: u64 = ((s_346_8) & (s_346_9));
        // D s_346_11: cmp-eq s_346_10 s_346_9
        let s_346_11: bool = ((s_346_10) == (s_346_9));
        // D s_346_12: lsl s_346_8 s_346_6
        let s_346_12: u64 = s_346_8 << s_346_6;
        // D s_346_13: or s_346_7 s_346_12
        let s_346_13: u64 = ((s_346_7) | (s_346_12));
        // D s_346_14: cmpl s_346_12
        let s_346_14: u64 = !s_346_12;
        // D s_346_15: and s_346_7 s_346_14
        let s_346_15: u64 = ((s_346_7) & (s_346_14));
        // D s_346_16: select s_346_11 s_346_13 s_346_15
        let s_346_16: u64 = if s_346_11 { s_346_13 } else { s_346_15 };
        // D s_346_17: cast trunc s_346_16 -> u8
        let s_346_17: bool = ((s_346_16) != 0);
        // D s_346_18: cast zx s_346_17 -> bv
        let s_346_18: Bits = Bits::new(s_346_17 as u128, 1u16);
        // C s_346_19: const #1u : u8
        let s_346_19: bool = true;
        // C s_346_20: cast zx s_346_19 -> bv
        let s_346_20: Bits = Bits::new(s_346_19 as u128, 1u16);
        // D s_346_21: cmp-ne s_346_18 s_346_20
        let s_346_21: bool = ((s_346_18) != (s_346_20));
        // D s_346_22: write-var gs#404701 <= s_346_21
        fn_state.gs_404701 = s_346_21;
        // N s_346_23: jump b347
        return block_347(state, tracer, fn_state);
    }
    fn block_347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_347_0: read-var gs#404701:u8
        let s_347_0: bool = fn_state.gs_404701;
        // N s_347_1: branch s_347_0 b361 b348
        if s_347_0 {
            return block_361(state, tracer, fn_state);
        } else {
            return block_348(state, tracer, fn_state);
        };
    }
    fn block_348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_348_0: const #8s : i
        let s_348_0: i128 = 8;
        // D s_348_1: read-var u#32497:u32
        let s_348_1: u32 = fn_state.u_32497;
        // D s_348_2: cast zx s_348_1 -> bv
        let s_348_2: Bits = Bits::new(s_348_1 as u128, 32u16);
        // C s_348_3: const #1u : u64
        let s_348_3: u64 = 1;
        // D s_348_4: bit-extract s_348_2 s_348_0 s_348_3
        let s_348_4: Bits = (Bits::new(
            ((s_348_2) >> (s_348_0)).value(),
            u16::try_from(s_348_3).unwrap(),
        ));
        // D s_348_5: cast reint s_348_4 -> u8
        let s_348_5: bool = ((s_348_4.value()) != 0);
        // C s_348_6: const #0s : i
        let s_348_6: i128 = 0;
        // C s_348_7: const #0u : u64
        let s_348_7: u64 = 0;
        // D s_348_8: cast zx s_348_5 -> u64
        let s_348_8: u64 = (s_348_5 as u64);
        // C s_348_9: const #1u : u64
        let s_348_9: u64 = 1;
        // D s_348_10: and s_348_8 s_348_9
        let s_348_10: u64 = ((s_348_8) & (s_348_9));
        // D s_348_11: cmp-eq s_348_10 s_348_9
        let s_348_11: bool = ((s_348_10) == (s_348_9));
        // D s_348_12: lsl s_348_8 s_348_6
        let s_348_12: u64 = s_348_8 << s_348_6;
        // D s_348_13: or s_348_7 s_348_12
        let s_348_13: u64 = ((s_348_7) | (s_348_12));
        // D s_348_14: cmpl s_348_12
        let s_348_14: u64 = !s_348_12;
        // D s_348_15: and s_348_7 s_348_14
        let s_348_15: u64 = ((s_348_7) & (s_348_14));
        // D s_348_16: select s_348_11 s_348_13 s_348_15
        let s_348_16: u64 = if s_348_11 { s_348_13 } else { s_348_15 };
        // D s_348_17: cast trunc s_348_16 -> u8
        let s_348_17: bool = ((s_348_16) != 0);
        // D s_348_18: cast zx s_348_17 -> bv
        let s_348_18: Bits = Bits::new(s_348_17 as u128, 1u16);
        // C s_348_19: const #0u : u8
        let s_348_19: bool = false;
        // C s_348_20: cast zx s_348_19 -> bv
        let s_348_20: Bits = Bits::new(s_348_19 as u128, 1u16);
        // D s_348_21: cmp-ne s_348_18 s_348_20
        let s_348_21: bool = ((s_348_18) != (s_348_20));
        // D s_348_22: write-var gs#404704 <= s_348_21
        fn_state.gs_404704 = s_348_21;
        // N s_348_23: jump b349
        return block_349(state, tracer, fn_state);
    }
    fn block_349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_349_0: read-var gs#404704:u8
        let s_349_0: bool = fn_state.gs_404704;
        // N s_349_1: branch s_349_0 b360 b350
        if s_349_0 {
            return block_360(state, tracer, fn_state);
        } else {
            return block_350(state, tracer, fn_state);
        };
    }
    fn block_350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_350_0: const #9s : i
        let s_350_0: i128 = 9;
        // D s_350_1: read-var u#32497:u32
        let s_350_1: u32 = fn_state.u_32497;
        // D s_350_2: cast zx s_350_1 -> bv
        let s_350_2: Bits = Bits::new(s_350_1 as u128, 32u16);
        // C s_350_3: const #1u : u64
        let s_350_3: u64 = 1;
        // D s_350_4: bit-extract s_350_2 s_350_0 s_350_3
        let s_350_4: Bits = (Bits::new(
            ((s_350_2) >> (s_350_0)).value(),
            u16::try_from(s_350_3).unwrap(),
        ));
        // D s_350_5: cast reint s_350_4 -> u8
        let s_350_5: bool = ((s_350_4.value()) != 0);
        // C s_350_6: const #0s : i
        let s_350_6: i128 = 0;
        // C s_350_7: const #0u : u64
        let s_350_7: u64 = 0;
        // D s_350_8: cast zx s_350_5 -> u64
        let s_350_8: u64 = (s_350_5 as u64);
        // C s_350_9: const #1u : u64
        let s_350_9: u64 = 1;
        // D s_350_10: and s_350_8 s_350_9
        let s_350_10: u64 = ((s_350_8) & (s_350_9));
        // D s_350_11: cmp-eq s_350_10 s_350_9
        let s_350_11: bool = ((s_350_10) == (s_350_9));
        // D s_350_12: lsl s_350_8 s_350_6
        let s_350_12: u64 = s_350_8 << s_350_6;
        // D s_350_13: or s_350_7 s_350_12
        let s_350_13: u64 = ((s_350_7) | (s_350_12));
        // D s_350_14: cmpl s_350_12
        let s_350_14: u64 = !s_350_12;
        // D s_350_15: and s_350_7 s_350_14
        let s_350_15: u64 = ((s_350_7) & (s_350_14));
        // D s_350_16: select s_350_11 s_350_13 s_350_15
        let s_350_16: u64 = if s_350_11 { s_350_13 } else { s_350_15 };
        // D s_350_17: cast trunc s_350_16 -> u8
        let s_350_17: bool = ((s_350_16) != 0);
        // D s_350_18: cast zx s_350_17 -> bv
        let s_350_18: Bits = Bits::new(s_350_17 as u128, 1u16);
        // C s_350_19: const #0u : u8
        let s_350_19: bool = false;
        // C s_350_20: cast zx s_350_19 -> bv
        let s_350_20: Bits = Bits::new(s_350_19 as u128, 1u16);
        // D s_350_21: cmp-ne s_350_18 s_350_20
        let s_350_21: bool = ((s_350_18) != (s_350_20));
        // D s_350_22: write-var gs#404707 <= s_350_21
        fn_state.gs_404707 = s_350_21;
        // N s_350_23: jump b351
        return block_351(state, tracer, fn_state);
    }
    fn block_351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_351_0: read-var gs#404707:u8
        let s_351_0: bool = fn_state.gs_404707;
        // N s_351_1: branch s_351_0 b359 b352
        if s_351_0 {
            return block_359(state, tracer, fn_state);
        } else {
            return block_352(state, tracer, fn_state);
        };
    }
    fn block_352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_352_0: const #10s : i
        let s_352_0: i128 = 10;
        // D s_352_1: read-var u#32497:u32
        let s_352_1: u32 = fn_state.u_32497;
        // D s_352_2: cast zx s_352_1 -> bv
        let s_352_2: Bits = Bits::new(s_352_1 as u128, 32u16);
        // C s_352_3: const #1u : u64
        let s_352_3: u64 = 1;
        // D s_352_4: bit-extract s_352_2 s_352_0 s_352_3
        let s_352_4: Bits = (Bits::new(
            ((s_352_2) >> (s_352_0)).value(),
            u16::try_from(s_352_3).unwrap(),
        ));
        // D s_352_5: cast reint s_352_4 -> u8
        let s_352_5: bool = ((s_352_4.value()) != 0);
        // C s_352_6: const #0s : i
        let s_352_6: i128 = 0;
        // C s_352_7: const #0u : u64
        let s_352_7: u64 = 0;
        // D s_352_8: cast zx s_352_5 -> u64
        let s_352_8: u64 = (s_352_5 as u64);
        // C s_352_9: const #1u : u64
        let s_352_9: u64 = 1;
        // D s_352_10: and s_352_8 s_352_9
        let s_352_10: u64 = ((s_352_8) & (s_352_9));
        // D s_352_11: cmp-eq s_352_10 s_352_9
        let s_352_11: bool = ((s_352_10) == (s_352_9));
        // D s_352_12: lsl s_352_8 s_352_6
        let s_352_12: u64 = s_352_8 << s_352_6;
        // D s_352_13: or s_352_7 s_352_12
        let s_352_13: u64 = ((s_352_7) | (s_352_12));
        // D s_352_14: cmpl s_352_12
        let s_352_14: u64 = !s_352_12;
        // D s_352_15: and s_352_7 s_352_14
        let s_352_15: u64 = ((s_352_7) & (s_352_14));
        // D s_352_16: select s_352_11 s_352_13 s_352_15
        let s_352_16: u64 = if s_352_11 { s_352_13 } else { s_352_15 };
        // D s_352_17: cast trunc s_352_16 -> u8
        let s_352_17: bool = ((s_352_16) != 0);
        // D s_352_18: cast zx s_352_17 -> bv
        let s_352_18: Bits = Bits::new(s_352_17 as u128, 1u16);
        // C s_352_19: const #0u : u8
        let s_352_19: bool = false;
        // C s_352_20: cast zx s_352_19 -> bv
        let s_352_20: Bits = Bits::new(s_352_19 as u128, 1u16);
        // D s_352_21: cmp-ne s_352_18 s_352_20
        let s_352_21: bool = ((s_352_18) != (s_352_20));
        // D s_352_22: write-var gs#404710 <= s_352_21
        fn_state.gs_404710 = s_352_21;
        // N s_352_23: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_353_0: read-var gs#404710:u8
        let s_353_0: bool = fn_state.gs_404710;
        // N s_353_1: branch s_353_0 b358 b354
        if s_353_0 {
            return block_358(state, tracer, fn_state);
        } else {
            return block_354(state, tracer, fn_state);
        };
    }
    fn block_354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_354_0: const #11s : i
        let s_354_0: i128 = 11;
        // D s_354_1: read-var u#32497:u32
        let s_354_1: u32 = fn_state.u_32497;
        // D s_354_2: cast zx s_354_1 -> bv
        let s_354_2: Bits = Bits::new(s_354_1 as u128, 32u16);
        // C s_354_3: const #1u : u64
        let s_354_3: u64 = 1;
        // D s_354_4: bit-extract s_354_2 s_354_0 s_354_3
        let s_354_4: Bits = (Bits::new(
            ((s_354_2) >> (s_354_0)).value(),
            u16::try_from(s_354_3).unwrap(),
        ));
        // D s_354_5: cast reint s_354_4 -> u8
        let s_354_5: bool = ((s_354_4.value()) != 0);
        // C s_354_6: const #0s : i
        let s_354_6: i128 = 0;
        // C s_354_7: const #0u : u64
        let s_354_7: u64 = 0;
        // D s_354_8: cast zx s_354_5 -> u64
        let s_354_8: u64 = (s_354_5 as u64);
        // C s_354_9: const #1u : u64
        let s_354_9: u64 = 1;
        // D s_354_10: and s_354_8 s_354_9
        let s_354_10: u64 = ((s_354_8) & (s_354_9));
        // D s_354_11: cmp-eq s_354_10 s_354_9
        let s_354_11: bool = ((s_354_10) == (s_354_9));
        // D s_354_12: lsl s_354_8 s_354_6
        let s_354_12: u64 = s_354_8 << s_354_6;
        // D s_354_13: or s_354_7 s_354_12
        let s_354_13: u64 = ((s_354_7) | (s_354_12));
        // D s_354_14: cmpl s_354_12
        let s_354_14: u64 = !s_354_12;
        // D s_354_15: and s_354_7 s_354_14
        let s_354_15: u64 = ((s_354_7) & (s_354_14));
        // D s_354_16: select s_354_11 s_354_13 s_354_15
        let s_354_16: u64 = if s_354_11 { s_354_13 } else { s_354_15 };
        // D s_354_17: cast trunc s_354_16 -> u8
        let s_354_17: bool = ((s_354_16) != 0);
        // D s_354_18: cast zx s_354_17 -> bv
        let s_354_18: Bits = Bits::new(s_354_17 as u128, 1u16);
        // C s_354_19: const #0u : u8
        let s_354_19: bool = false;
        // C s_354_20: cast zx s_354_19 -> bv
        let s_354_20: Bits = Bits::new(s_354_19 as u128, 1u16);
        // D s_354_21: cmp-ne s_354_18 s_354_20
        let s_354_21: bool = ((s_354_18) != (s_354_20));
        // D s_354_22: write-var gs#404713 <= s_354_21
        fn_state.gs_404713 = s_354_21;
        // N s_354_23: jump b355
        return block_355(state, tracer, fn_state);
    }
    fn block_355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_355_0: read-var gs#404713:u8
        let s_355_0: bool = fn_state.gs_404713;
        // N s_355_1: branch s_355_0 b357 b356
        if s_355_0 {
            return block_357(state, tracer, fn_state);
        } else {
            return block_356(state, tracer, fn_state);
        };
    }
    fn block_356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_356_0: read-var u#32498:u8
        let s_356_0: u8 = fn_state.u_32498;
        // D s_356_1: read-var option_name:u8
        let s_356_1: u8 = fn_state.option_name;
        // D s_356_2: call decode_aarch32_instrs_DBG_A1enc_A_txt(s_356_0, s_356_1)
        let s_356_2: () = decode_aarch32_instrs_DBG_A1enc_A_txt(
            state,
            tracer,
            s_356_0,
            s_356_1,
        );
        // N s_356_3: return
        return;
    }
    fn block_357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_357_0: panic
        panic!("{:?}", ());
        // N s_357_1: return
        return;
    }
    fn block_358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_358_0: const #1u : u8
        let s_358_0: bool = true;
        // D s_358_1: write-var gs#404713 <= s_358_0
        fn_state.gs_404713 = s_358_0;
        // N s_358_2: jump b355
        return block_355(state, tracer, fn_state);
    }
    fn block_359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_359_0: const #1u : u8
        let s_359_0: bool = true;
        // D s_359_1: write-var gs#404710 <= s_359_0
        fn_state.gs_404710 = s_359_0;
        // N s_359_2: jump b353
        return block_353(state, tracer, fn_state);
    }
    fn block_360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_360_0: const #1u : u8
        let s_360_0: bool = true;
        // D s_360_1: write-var gs#404707 <= s_360_0
        fn_state.gs_404707 = s_360_0;
        // N s_360_2: jump b351
        return block_351(state, tracer, fn_state);
    }
    fn block_361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_361_0: const #1u : u8
        let s_361_0: bool = true;
        // D s_361_1: write-var gs#404704 <= s_361_0
        fn_state.gs_404704 = s_361_0;
        // N s_361_2: jump b349
        return block_349(state, tracer, fn_state);
    }
    fn block_362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_362_0: const #1u : u8
        let s_362_0: bool = true;
        // D s_362_1: write-var gs#404701 <= s_362_0
        fn_state.gs_404701 = s_362_0;
        // N s_362_2: jump b347
        return block_347(state, tracer, fn_state);
    }
    fn block_363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_363_0: const #1u : u8
        let s_363_0: bool = true;
        // D s_363_1: write-var gs#404698 <= s_363_0
        fn_state.gs_404698 = s_363_0;
        // N s_363_2: jump b345
        return block_345(state, tracer, fn_state);
    }
    fn block_364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_364_0: const #1u : u8
        let s_364_0: bool = true;
        // D s_364_1: write-var gs#404695 <= s_364_0
        fn_state.gs_404695 = s_364_0;
        // N s_364_2: jump b343
        return block_343(state, tracer, fn_state);
    }
    fn block_365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_365_0: read-var merge#var.1:struct
        let s_365_0: u32 = fn_state.merge_var._1;
        // D s_365_1: write-var u#32500 <= s_365_0
        fn_state.u_32500 = s_365_0;
        // C s_365_2: const #21s : i
        let s_365_2: i128 = 21;
        // D s_365_3: read-var u#32500:u32
        let s_365_3: u32 = fn_state.u_32500;
        // D s_365_4: cast zx s_365_3 -> bv
        let s_365_4: Bits = Bits::new(s_365_3 as u128, 32u16);
        // C s_365_5: const #1s : i64
        let s_365_5: i64 = 1;
        // C s_365_6: cast zx s_365_5 -> i
        let s_365_6: i128 = (i128::try_from(s_365_5).unwrap());
        // C s_365_7: const #6s : i
        let s_365_7: i128 = 6;
        // C s_365_8: add s_365_7 s_365_6
        let s_365_8: i128 = (s_365_7 + s_365_6);
        // D s_365_9: bit-extract s_365_4 s_365_2 s_365_8
        let s_365_9: Bits = (Bits::new(
            ((s_365_4) >> (s_365_2)).value(),
            u16::try_from(s_365_8).unwrap(),
        ));
        // D s_365_10: cast reint s_365_9 -> u8
        let s_365_10: u8 = (s_365_9.value() as u8);
        // D s_365_11: cast zx s_365_10 -> bv
        let s_365_11: Bits = Bits::new(s_365_10 as u128, 7u16);
        // C s_365_12: const #17u : u8
        let s_365_12: u8 = 17;
        // C s_365_13: cast zx s_365_12 -> bv
        let s_365_13: Bits = Bits::new(s_365_12 as u128, 7u16);
        // D s_365_14: cmp-eq s_365_11 s_365_13
        let s_365_14: bool = ((s_365_11) == (s_365_13));
        // N s_365_15: branch s_365_14 b2833 b366
        if s_365_14 {
            return block_2833(state, tracer, fn_state);
        } else {
            return block_366(state, tracer, fn_state);
        };
    }
    fn block_366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_366_0: const #0u : u8
        let s_366_0: bool = false;
        // D s_366_1: write-var gs#404721 <= s_366_0
        fn_state.gs_404721 = s_366_0;
        // N s_366_2: jump b367
        return block_367(state, tracer, fn_state);
    }
    fn block_367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_367_0: read-var gs#404721:u8
        let s_367_0: bool = fn_state.gs_404721;
        // D s_367_1: not s_367_0
        let s_367_1: bool = !s_367_0;
        // N s_367_2: branch s_367_1 b369 b368
        if s_367_1 {
            return block_369(state, tracer, fn_state);
        } else {
            return block_368(state, tracer, fn_state);
        };
    }
    fn block_368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_368_0: const #2903s : i
        let s_368_0: i128 = 2903;
        // C s_368_1: const #14696u : u32
        let s_368_1: u32 = 14696;
        // N s_368_2: write-reg s_368_1 <= s_368_0
        let s_368_2: () = {
            state.write_register::<i128>(s_368_1 as isize, s_368_0);
            tracer.write_register(s_368_1 as isize, s_368_0);
        };
        // C s_368_3: const #28s : i
        let s_368_3: i128 = 28;
        // C s_368_4: const #4s : i
        let s_368_4: i128 = 4;
        // D s_368_5: read-var u#32500:u32
        let s_368_5: u32 = fn_state.u_32500;
        // D s_368_6: cast zx s_368_5 -> bv
        let s_368_6: Bits = Bits::new(s_368_5 as u128, 32u16);
        // D s_368_7: bit-extract s_368_6 s_368_3 s_368_4
        let s_368_7: Bits = (Bits::new(
            ((s_368_6) >> (s_368_3)).value(),
            u16::try_from(s_368_4).unwrap(),
        ));
        // D s_368_8: cast reint s_368_7 -> u8
        let s_368_8: u8 = (s_368_7.value() as u8);
        // C s_368_9: const #20s : i
        let s_368_9: i128 = 20;
        // C s_368_10: const #1s : i
        let s_368_10: i128 = 1;
        // D s_368_11: read-var u#32500:u32
        let s_368_11: u32 = fn_state.u_32500;
        // D s_368_12: cast zx s_368_11 -> bv
        let s_368_12: Bits = Bits::new(s_368_11 as u128, 32u16);
        // D s_368_13: bit-extract s_368_12 s_368_9 s_368_10
        let s_368_13: Bits = (Bits::new(
            ((s_368_12) >> (s_368_9)).value(),
            u16::try_from(s_368_10).unwrap(),
        ));
        // D s_368_14: cast reint s_368_13 -> u8
        let s_368_14: bool = ((s_368_13.value()) != 0);
        // C s_368_15: const #16s : i
        let s_368_15: i128 = 16;
        // C s_368_16: const #4s : i
        let s_368_16: i128 = 4;
        // D s_368_17: read-var u#32500:u32
        let s_368_17: u32 = fn_state.u_32500;
        // D s_368_18: cast zx s_368_17 -> bv
        let s_368_18: Bits = Bits::new(s_368_17 as u128, 32u16);
        // D s_368_19: bit-extract s_368_18 s_368_15 s_368_16
        let s_368_19: Bits = (Bits::new(
            ((s_368_18) >> (s_368_15)).value(),
            u16::try_from(s_368_16).unwrap(),
        ));
        // D s_368_20: cast reint s_368_19 -> u8
        let s_368_20: u8 = (s_368_19.value() as u8);
        // C s_368_21: const #12s : i
        let s_368_21: i128 = 12;
        // C s_368_22: const #4s : i
        let s_368_22: i128 = 4;
        // D s_368_23: read-var u#32500:u32
        let s_368_23: u32 = fn_state.u_32500;
        // D s_368_24: cast zx s_368_23 -> bv
        let s_368_24: Bits = Bits::new(s_368_23 as u128, 32u16);
        // D s_368_25: bit-extract s_368_24 s_368_21 s_368_22
        let s_368_25: Bits = (Bits::new(
            ((s_368_24) >> (s_368_21)).value(),
            u16::try_from(s_368_22).unwrap(),
        ));
        // D s_368_26: cast reint s_368_25 -> u8
        let s_368_26: u8 = (s_368_25.value() as u8);
        // C s_368_27: const #0s : i
        let s_368_27: i128 = 0;
        // C s_368_28: const #12s : i
        let s_368_28: i128 = 12;
        // D s_368_29: read-var u#32500:u32
        let s_368_29: u32 = fn_state.u_32500;
        // D s_368_30: cast zx s_368_29 -> bv
        let s_368_30: Bits = Bits::new(s_368_29 as u128, 32u16);
        // D s_368_31: bit-extract s_368_30 s_368_27 s_368_28
        let s_368_31: Bits = (Bits::new(
            ((s_368_30) >> (s_368_27)).value(),
            u16::try_from(s_368_28).unwrap(),
        ));
        // D s_368_32: cast reint s_368_31 -> u12
        let s_368_32: u16 = (s_368_31.value() as u16);
        // D s_368_33: call decode_aarch32_instrs_EOR_i_A1enc_A_txt(s_368_8, s_368_14, s_368_20, s_368_26, s_368_32)
        let s_368_33: () = decode_aarch32_instrs_EOR_i_A1enc_A_txt(
            state,
            tracer,
            s_368_8,
            s_368_14,
            s_368_20,
            s_368_26,
            s_368_32,
        );
        // N s_368_34: return
        return;
    }
    fn block_369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_369_0: read-var merge#var.1:struct
        let s_369_0: u32 = fn_state.merge_var._1;
        // D s_369_1: write-var u#32507 <= s_369_0
        fn_state.u_32507 = s_369_0;
        // C s_369_2: const #21s : i
        let s_369_2: i128 = 21;
        // D s_369_3: read-var u#32507:u32
        let s_369_3: u32 = fn_state.u_32507;
        // D s_369_4: cast zx s_369_3 -> bv
        let s_369_4: Bits = Bits::new(s_369_3 as u128, 32u16);
        // C s_369_5: const #1s : i64
        let s_369_5: i64 = 1;
        // C s_369_6: cast zx s_369_5 -> i
        let s_369_6: i128 = (i128::try_from(s_369_5).unwrap());
        // C s_369_7: const #6s : i
        let s_369_7: i128 = 6;
        // C s_369_8: add s_369_7 s_369_6
        let s_369_8: i128 = (s_369_7 + s_369_6);
        // D s_369_9: bit-extract s_369_4 s_369_2 s_369_8
        let s_369_9: Bits = (Bits::new(
            ((s_369_4) >> (s_369_2)).value(),
            u16::try_from(s_369_8).unwrap(),
        ));
        // D s_369_10: cast reint s_369_9 -> u8
        let s_369_10: u8 = (s_369_9.value() as u8);
        // D s_369_11: cast zx s_369_10 -> bv
        let s_369_11: Bits = Bits::new(s_369_10 as u128, 7u16);
        // C s_369_12: const #1u : u8
        let s_369_12: u8 = 1;
        // C s_369_13: cast zx s_369_12 -> bv
        let s_369_13: Bits = Bits::new(s_369_12 as u128, 7u16);
        // D s_369_14: cmp-eq s_369_11 s_369_13
        let s_369_14: bool = ((s_369_11) == (s_369_13));
        // N s_369_15: branch s_369_14 b2832 b370
        if s_369_14 {
            return block_2832(state, tracer, fn_state);
        } else {
            return block_370(state, tracer, fn_state);
        };
    }
    fn block_370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_370_0: const #0u : u8
        let s_370_0: bool = false;
        // D s_370_1: write-var gs#404739 <= s_370_0
        fn_state.gs_404739 = s_370_0;
        // N s_370_2: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_371_0: read-var gs#404739:u8
        let s_371_0: bool = fn_state.gs_404739;
        // N s_371_1: branch s_371_0 b2828 b372
        if s_371_0 {
            return block_2828(state, tracer, fn_state);
        } else {
            return block_372(state, tracer, fn_state);
        };
    }
    fn block_372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_372_0: const #0u : u8
        let s_372_0: bool = false;
        // D s_372_1: write-var gs#404744 <= s_372_0
        fn_state.gs_404744 = s_372_0;
        // N s_372_2: jump b373
        return block_373(state, tracer, fn_state);
    }
    fn block_373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_373_0: read-var gs#404744:u8
        let s_373_0: bool = fn_state.gs_404744;
        // D s_373_1: not s_373_0
        let s_373_1: bool = !s_373_0;
        // N s_373_2: branch s_373_1 b375 b374
        if s_373_1 {
            return block_375(state, tracer, fn_state);
        } else {
            return block_374(state, tracer, fn_state);
        };
    }
    fn block_374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_374_0: const #2905s : i
        let s_374_0: i128 = 2905;
        // C s_374_1: const #14696u : u32
        let s_374_1: u32 = 14696;
        // N s_374_2: write-reg s_374_1 <= s_374_0
        let s_374_2: () = {
            state.write_register::<i128>(s_374_1 as isize, s_374_0);
            tracer.write_register(s_374_1 as isize, s_374_0);
        };
        // C s_374_3: const #28s : i
        let s_374_3: i128 = 28;
        // C s_374_4: const #4s : i
        let s_374_4: i128 = 4;
        // D s_374_5: read-var u#32507:u32
        let s_374_5: u32 = fn_state.u_32507;
        // D s_374_6: cast zx s_374_5 -> bv
        let s_374_6: Bits = Bits::new(s_374_5 as u128, 32u16);
        // D s_374_7: bit-extract s_374_6 s_374_3 s_374_4
        let s_374_7: Bits = (Bits::new(
            ((s_374_6) >> (s_374_3)).value(),
            u16::try_from(s_374_4).unwrap(),
        ));
        // D s_374_8: cast reint s_374_7 -> u8
        let s_374_8: u8 = (s_374_7.value() as u8);
        // C s_374_9: const #20s : i
        let s_374_9: i128 = 20;
        // C s_374_10: const #1s : i
        let s_374_10: i128 = 1;
        // D s_374_11: read-var u#32507:u32
        let s_374_11: u32 = fn_state.u_32507;
        // D s_374_12: cast zx s_374_11 -> bv
        let s_374_12: Bits = Bits::new(s_374_11 as u128, 32u16);
        // D s_374_13: bit-extract s_374_12 s_374_9 s_374_10
        let s_374_13: Bits = (Bits::new(
            ((s_374_12) >> (s_374_9)).value(),
            u16::try_from(s_374_10).unwrap(),
        ));
        // D s_374_14: cast reint s_374_13 -> u8
        let s_374_14: bool = ((s_374_13.value()) != 0);
        // C s_374_15: const #16s : i
        let s_374_15: i128 = 16;
        // C s_374_16: const #4s : i
        let s_374_16: i128 = 4;
        // D s_374_17: read-var u#32507:u32
        let s_374_17: u32 = fn_state.u_32507;
        // D s_374_18: cast zx s_374_17 -> bv
        let s_374_18: Bits = Bits::new(s_374_17 as u128, 32u16);
        // D s_374_19: bit-extract s_374_18 s_374_15 s_374_16
        let s_374_19: Bits = (Bits::new(
            ((s_374_18) >> (s_374_15)).value(),
            u16::try_from(s_374_16).unwrap(),
        ));
        // D s_374_20: cast reint s_374_19 -> u8
        let s_374_20: u8 = (s_374_19.value() as u8);
        // C s_374_21: const #12s : i
        let s_374_21: i128 = 12;
        // C s_374_22: const #4s : i
        let s_374_22: i128 = 4;
        // D s_374_23: read-var u#32507:u32
        let s_374_23: u32 = fn_state.u_32507;
        // D s_374_24: cast zx s_374_23 -> bv
        let s_374_24: Bits = Bits::new(s_374_23 as u128, 32u16);
        // D s_374_25: bit-extract s_374_24 s_374_21 s_374_22
        let s_374_25: Bits = (Bits::new(
            ((s_374_24) >> (s_374_21)).value(),
            u16::try_from(s_374_22).unwrap(),
        ));
        // D s_374_26: cast reint s_374_25 -> u8
        let s_374_26: u8 = (s_374_25.value() as u8);
        // C s_374_27: const #7s : i
        let s_374_27: i128 = 7;
        // C s_374_28: const #5s : i
        let s_374_28: i128 = 5;
        // D s_374_29: read-var u#32507:u32
        let s_374_29: u32 = fn_state.u_32507;
        // D s_374_30: cast zx s_374_29 -> bv
        let s_374_30: Bits = Bits::new(s_374_29 as u128, 32u16);
        // D s_374_31: bit-extract s_374_30 s_374_27 s_374_28
        let s_374_31: Bits = (Bits::new(
            ((s_374_30) >> (s_374_27)).value(),
            u16::try_from(s_374_28).unwrap(),
        ));
        // D s_374_32: cast reint s_374_31 -> u8
        let s_374_32: u8 = (s_374_31.value() as u8);
        // C s_374_33: const #5s : i
        let s_374_33: i128 = 5;
        // C s_374_34: const #2s : i
        let s_374_34: i128 = 2;
        // D s_374_35: read-var u#32507:u32
        let s_374_35: u32 = fn_state.u_32507;
        // D s_374_36: cast zx s_374_35 -> bv
        let s_374_36: Bits = Bits::new(s_374_35 as u128, 32u16);
        // D s_374_37: bit-extract s_374_36 s_374_33 s_374_34
        let s_374_37: Bits = (Bits::new(
            ((s_374_36) >> (s_374_33)).value(),
            u16::try_from(s_374_34).unwrap(),
        ));
        // D s_374_38: cast reint s_374_37 -> u8
        let s_374_38: u8 = (s_374_37.value() as u8);
        // C s_374_39: const #0s : i
        let s_374_39: i128 = 0;
        // C s_374_40: const #4s : i
        let s_374_40: i128 = 4;
        // D s_374_41: read-var u#32507:u32
        let s_374_41: u32 = fn_state.u_32507;
        // D s_374_42: cast zx s_374_41 -> bv
        let s_374_42: Bits = Bits::new(s_374_41 as u128, 32u16);
        // D s_374_43: bit-extract s_374_42 s_374_39 s_374_40
        let s_374_43: Bits = (Bits::new(
            ((s_374_42) >> (s_374_39)).value(),
            u16::try_from(s_374_40).unwrap(),
        ));
        // D s_374_44: cast reint s_374_43 -> u8
        let s_374_44: u8 = (s_374_43.value() as u8);
        // D s_374_45: call decode_aarch32_instrs_EOR_r_A1enc_A_txt(s_374_8, s_374_14, s_374_20, s_374_26, s_374_32, s_374_38, s_374_44)
        let s_374_45: () = decode_aarch32_instrs_EOR_r_A1enc_A_txt(
            state,
            tracer,
            s_374_8,
            s_374_14,
            s_374_20,
            s_374_26,
            s_374_32,
            s_374_38,
            s_374_44,
        );
        // N s_374_46: return
        return;
    }
    fn block_375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_375_0: read-var merge#var.1:struct
        let s_375_0: u32 = fn_state.merge_var._1;
        // D s_375_1: write-var u#32516 <= s_375_0
        fn_state.u_32516 = s_375_0;
        // C s_375_2: const #21s : i
        let s_375_2: i128 = 21;
        // D s_375_3: read-var u#32516:u32
        let s_375_3: u32 = fn_state.u_32516;
        // D s_375_4: cast zx s_375_3 -> bv
        let s_375_4: Bits = Bits::new(s_375_3 as u128, 32u16);
        // C s_375_5: const #1s : i64
        let s_375_5: i64 = 1;
        // C s_375_6: cast zx s_375_5 -> i
        let s_375_6: i128 = (i128::try_from(s_375_5).unwrap());
        // C s_375_7: const #6s : i
        let s_375_7: i128 = 6;
        // C s_375_8: add s_375_7 s_375_6
        let s_375_8: i128 = (s_375_7 + s_375_6);
        // D s_375_9: bit-extract s_375_4 s_375_2 s_375_8
        let s_375_9: Bits = (Bits::new(
            ((s_375_4) >> (s_375_2)).value(),
            u16::try_from(s_375_8).unwrap(),
        ));
        // D s_375_10: cast reint s_375_9 -> u8
        let s_375_10: u8 = (s_375_9.value() as u8);
        // D s_375_11: cast zx s_375_10 -> bv
        let s_375_11: Bits = Bits::new(s_375_10 as u128, 7u16);
        // C s_375_12: const #1u : u8
        let s_375_12: u8 = 1;
        // C s_375_13: cast zx s_375_12 -> bv
        let s_375_13: Bits = Bits::new(s_375_12 as u128, 7u16);
        // D s_375_14: cmp-eq s_375_11 s_375_13
        let s_375_14: bool = ((s_375_11) == (s_375_13));
        // N s_375_15: branch s_375_14 b2824 b376
        if s_375_14 {
            return block_2824(state, tracer, fn_state);
        } else {
            return block_376(state, tracer, fn_state);
        };
    }
    fn block_376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_376_0: const #0u : u8
        let s_376_0: bool = false;
        // D s_376_1: write-var gs#404769 <= s_376_0
        fn_state.gs_404769 = s_376_0;
        // N s_376_2: jump b377
        return block_377(state, tracer, fn_state);
    }
    fn block_377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_377_0: read-var gs#404769:u8
        let s_377_0: bool = fn_state.gs_404769;
        // N s_377_1: branch s_377_0 b2820 b378
        if s_377_0 {
            return block_2820(state, tracer, fn_state);
        } else {
            return block_378(state, tracer, fn_state);
        };
    }
    fn block_378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_378_0: const #0u : u8
        let s_378_0: bool = false;
        // D s_378_1: write-var gs#404774 <= s_378_0
        fn_state.gs_404774 = s_378_0;
        // N s_378_2: jump b379
        return block_379(state, tracer, fn_state);
    }
    fn block_379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_379_0: read-var gs#404774:u8
        let s_379_0: bool = fn_state.gs_404774;
        // D s_379_1: not s_379_0
        let s_379_1: bool = !s_379_0;
        // N s_379_2: branch s_379_1 b381 b380
        if s_379_1 {
            return block_381(state, tracer, fn_state);
        } else {
            return block_380(state, tracer, fn_state);
        };
    }
    fn block_380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_380_0: const #2908s : i
        let s_380_0: i128 = 2908;
        // C s_380_1: const #14696u : u32
        let s_380_1: u32 = 14696;
        // N s_380_2: write-reg s_380_1 <= s_380_0
        let s_380_2: () = {
            state.write_register::<i128>(s_380_1 as isize, s_380_0);
            tracer.write_register(s_380_1 as isize, s_380_0);
        };
        // C s_380_3: const #28s : i
        let s_380_3: i128 = 28;
        // C s_380_4: const #4s : i
        let s_380_4: i128 = 4;
        // D s_380_5: read-var u#32516:u32
        let s_380_5: u32 = fn_state.u_32516;
        // D s_380_6: cast zx s_380_5 -> bv
        let s_380_6: Bits = Bits::new(s_380_5 as u128, 32u16);
        // D s_380_7: bit-extract s_380_6 s_380_3 s_380_4
        let s_380_7: Bits = (Bits::new(
            ((s_380_6) >> (s_380_3)).value(),
            u16::try_from(s_380_4).unwrap(),
        ));
        // D s_380_8: cast reint s_380_7 -> u8
        let s_380_8: u8 = (s_380_7.value() as u8);
        // C s_380_9: const #20s : i
        let s_380_9: i128 = 20;
        // C s_380_10: const #1s : i
        let s_380_10: i128 = 1;
        // D s_380_11: read-var u#32516:u32
        let s_380_11: u32 = fn_state.u_32516;
        // D s_380_12: cast zx s_380_11 -> bv
        let s_380_12: Bits = Bits::new(s_380_11 as u128, 32u16);
        // D s_380_13: bit-extract s_380_12 s_380_9 s_380_10
        let s_380_13: Bits = (Bits::new(
            ((s_380_12) >> (s_380_9)).value(),
            u16::try_from(s_380_10).unwrap(),
        ));
        // D s_380_14: cast reint s_380_13 -> u8
        let s_380_14: bool = ((s_380_13.value()) != 0);
        // C s_380_15: const #16s : i
        let s_380_15: i128 = 16;
        // C s_380_16: const #4s : i
        let s_380_16: i128 = 4;
        // D s_380_17: read-var u#32516:u32
        let s_380_17: u32 = fn_state.u_32516;
        // D s_380_18: cast zx s_380_17 -> bv
        let s_380_18: Bits = Bits::new(s_380_17 as u128, 32u16);
        // D s_380_19: bit-extract s_380_18 s_380_15 s_380_16
        let s_380_19: Bits = (Bits::new(
            ((s_380_18) >> (s_380_15)).value(),
            u16::try_from(s_380_16).unwrap(),
        ));
        // D s_380_20: cast reint s_380_19 -> u8
        let s_380_20: u8 = (s_380_19.value() as u8);
        // C s_380_21: const #12s : i
        let s_380_21: i128 = 12;
        // C s_380_22: const #4s : i
        let s_380_22: i128 = 4;
        // D s_380_23: read-var u#32516:u32
        let s_380_23: u32 = fn_state.u_32516;
        // D s_380_24: cast zx s_380_23 -> bv
        let s_380_24: Bits = Bits::new(s_380_23 as u128, 32u16);
        // D s_380_25: bit-extract s_380_24 s_380_21 s_380_22
        let s_380_25: Bits = (Bits::new(
            ((s_380_24) >> (s_380_21)).value(),
            u16::try_from(s_380_22).unwrap(),
        ));
        // D s_380_26: cast reint s_380_25 -> u8
        let s_380_26: u8 = (s_380_25.value() as u8);
        // C s_380_27: const #8s : i
        let s_380_27: i128 = 8;
        // C s_380_28: const #4s : i
        let s_380_28: i128 = 4;
        // D s_380_29: read-var u#32516:u32
        let s_380_29: u32 = fn_state.u_32516;
        // D s_380_30: cast zx s_380_29 -> bv
        let s_380_30: Bits = Bits::new(s_380_29 as u128, 32u16);
        // D s_380_31: bit-extract s_380_30 s_380_27 s_380_28
        let s_380_31: Bits = (Bits::new(
            ((s_380_30) >> (s_380_27)).value(),
            u16::try_from(s_380_28).unwrap(),
        ));
        // D s_380_32: cast reint s_380_31 -> u8
        let s_380_32: u8 = (s_380_31.value() as u8);
        // C s_380_33: const #5s : i
        let s_380_33: i128 = 5;
        // C s_380_34: const #2s : i
        let s_380_34: i128 = 2;
        // D s_380_35: read-var u#32516:u32
        let s_380_35: u32 = fn_state.u_32516;
        // D s_380_36: cast zx s_380_35 -> bv
        let s_380_36: Bits = Bits::new(s_380_35 as u128, 32u16);
        // D s_380_37: bit-extract s_380_36 s_380_33 s_380_34
        let s_380_37: Bits = (Bits::new(
            ((s_380_36) >> (s_380_33)).value(),
            u16::try_from(s_380_34).unwrap(),
        ));
        // D s_380_38: cast reint s_380_37 -> u8
        let s_380_38: u8 = (s_380_37.value() as u8);
        // C s_380_39: const #0s : i
        let s_380_39: i128 = 0;
        // C s_380_40: const #4s : i
        let s_380_40: i128 = 4;
        // D s_380_41: read-var u#32516:u32
        let s_380_41: u32 = fn_state.u_32516;
        // D s_380_42: cast zx s_380_41 -> bv
        let s_380_42: Bits = Bits::new(s_380_41 as u128, 32u16);
        // D s_380_43: bit-extract s_380_42 s_380_39 s_380_40
        let s_380_43: Bits = (Bits::new(
            ((s_380_42) >> (s_380_39)).value(),
            u16::try_from(s_380_40).unwrap(),
        ));
        // D s_380_44: cast reint s_380_43 -> u8
        let s_380_44: u8 = (s_380_43.value() as u8);
        // D s_380_45: call decode_aarch32_instrs_EOR_rr_A1enc_A_txt(s_380_8, s_380_14, s_380_20, s_380_26, s_380_32, s_380_38, s_380_44)
        let s_380_45: () = decode_aarch32_instrs_EOR_rr_A1enc_A_txt(
            state,
            tracer,
            s_380_8,
            s_380_14,
            s_380_20,
            s_380_26,
            s_380_32,
            s_380_38,
            s_380_44,
        );
        // N s_380_46: return
        return;
    }
    fn block_381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_381_0: read-var merge#var.1:struct
        let s_381_0: u32 = fn_state.merge_var._1;
        // D s_381_1: write-var u#32525 <= s_381_0
        fn_state.u_32525 = s_381_0;
        // C s_381_2: const #25s : i
        let s_381_2: i128 = 25;
        // D s_381_3: read-var u#32525:u32
        let s_381_3: u32 = fn_state.u_32525;
        // D s_381_4: cast zx s_381_3 -> bv
        let s_381_4: Bits = Bits::new(s_381_3 as u128, 32u16);
        // C s_381_5: const #1s : i64
        let s_381_5: i64 = 1;
        // C s_381_6: cast zx s_381_5 -> i
        let s_381_6: i128 = (i128::try_from(s_381_5).unwrap());
        // C s_381_7: const #2s : i
        let s_381_7: i128 = 2;
        // C s_381_8: add s_381_7 s_381_6
        let s_381_8: i128 = (s_381_7 + s_381_6);
        // D s_381_9: bit-extract s_381_4 s_381_2 s_381_8
        let s_381_9: Bits = (Bits::new(
            ((s_381_4) >> (s_381_2)).value(),
            u16::try_from(s_381_8).unwrap(),
        ));
        // D s_381_10: cast reint s_381_9 -> u8
        let s_381_10: u8 = (s_381_9.value() as u8);
        // D s_381_11: cast zx s_381_10 -> bv
        let s_381_11: Bits = Bits::new(s_381_10 as u128, 3u16);
        // C s_381_12: const #0u : u8
        let s_381_12: u8 = 0;
        // C s_381_13: cast zx s_381_12 -> bv
        let s_381_13: Bits = Bits::new(s_381_12 as u128, 3u16);
        // D s_381_14: cmp-eq s_381_11 s_381_13
        let s_381_14: bool = ((s_381_11) == (s_381_13));
        // N s_381_15: branch s_381_14 b2813 b382
        if s_381_14 {
            return block_2813(state, tracer, fn_state);
        } else {
            return block_382(state, tracer, fn_state);
        };
    }
    fn block_382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_382_0: const #0u : u8
        let s_382_0: bool = false;
        // D s_382_1: write-var gs#404802 <= s_382_0
        fn_state.gs_404802 = s_382_0;
        // N s_382_2: jump b383
        return block_383(state, tracer, fn_state);
    }
    fn block_383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_383_0: read-var gs#404802:u8
        let s_383_0: bool = fn_state.gs_404802;
        // N s_383_1: branch s_383_0 b2809 b384
        if s_383_0 {
            return block_2809(state, tracer, fn_state);
        } else {
            return block_384(state, tracer, fn_state);
        };
    }
    fn block_384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_384_0: const #0u : u8
        let s_384_0: bool = false;
        // D s_384_1: write-var gs#404807 <= s_384_0
        fn_state.gs_404807 = s_384_0;
        // N s_384_2: jump b385
        return block_385(state, tracer, fn_state);
    }
    fn block_385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_385_0: read-var gs#404807:u8
        let s_385_0: bool = fn_state.gs_404807;
        // D s_385_1: not s_385_0
        let s_385_1: bool = !s_385_0;
        // N s_385_2: branch s_385_1 b387 b386
        if s_385_1 {
            return block_387(state, tracer, fn_state);
        } else {
            return block_386(state, tracer, fn_state);
        };
    }
    fn block_386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_386_0: const #2935s : i
        let s_386_0: i128 = 2935;
        // C s_386_1: const #14696u : u32
        let s_386_1: u32 = 14696;
        // N s_386_2: write-reg s_386_1 <= s_386_0
        let s_386_2: () = {
            state.write_register::<i128>(s_386_1 as isize, s_386_0);
            tracer.write_register(s_386_1 as isize, s_386_0);
        };
        // C s_386_3: const #28s : i
        let s_386_3: i128 = 28;
        // C s_386_4: const #4s : i
        let s_386_4: i128 = 4;
        // D s_386_5: read-var u#32525:u32
        let s_386_5: u32 = fn_state.u_32525;
        // D s_386_6: cast zx s_386_5 -> bv
        let s_386_6: Bits = Bits::new(s_386_5 as u128, 32u16);
        // D s_386_7: bit-extract s_386_6 s_386_3 s_386_4
        let s_386_7: Bits = (Bits::new(
            ((s_386_6) >> (s_386_3)).value(),
            u16::try_from(s_386_4).unwrap(),
        ));
        // D s_386_8: cast reint s_386_7 -> u8
        let s_386_8: u8 = (s_386_7.value() as u8);
        // C s_386_9: const #24s : i
        let s_386_9: i128 = 24;
        // C s_386_10: const #1s : i
        let s_386_10: i128 = 1;
        // D s_386_11: read-var u#32525:u32
        let s_386_11: u32 = fn_state.u_32525;
        // D s_386_12: cast zx s_386_11 -> bv
        let s_386_12: Bits = Bits::new(s_386_11 as u128, 32u16);
        // D s_386_13: bit-extract s_386_12 s_386_9 s_386_10
        let s_386_13: Bits = (Bits::new(
            ((s_386_12) >> (s_386_9)).value(),
            u16::try_from(s_386_10).unwrap(),
        ));
        // D s_386_14: cast reint s_386_13 -> u8
        let s_386_14: bool = ((s_386_13.value()) != 0);
        // C s_386_15: const #23s : i
        let s_386_15: i128 = 23;
        // C s_386_16: const #1s : i
        let s_386_16: i128 = 1;
        // D s_386_17: read-var u#32525:u32
        let s_386_17: u32 = fn_state.u_32525;
        // D s_386_18: cast zx s_386_17 -> bv
        let s_386_18: Bits = Bits::new(s_386_17 as u128, 32u16);
        // D s_386_19: bit-extract s_386_18 s_386_15 s_386_16
        let s_386_19: Bits = (Bits::new(
            ((s_386_18) >> (s_386_15)).value(),
            u16::try_from(s_386_16).unwrap(),
        ));
        // D s_386_20: cast reint s_386_19 -> u8
        let s_386_20: bool = ((s_386_19.value()) != 0);
        // C s_386_21: const #21s : i
        let s_386_21: i128 = 21;
        // C s_386_22: const #1s : i
        let s_386_22: i128 = 1;
        // D s_386_23: read-var u#32525:u32
        let s_386_23: u32 = fn_state.u_32525;
        // D s_386_24: cast zx s_386_23 -> bv
        let s_386_24: Bits = Bits::new(s_386_23 as u128, 32u16);
        // D s_386_25: bit-extract s_386_24 s_386_21 s_386_22
        let s_386_25: Bits = (Bits::new(
            ((s_386_24) >> (s_386_21)).value(),
            u16::try_from(s_386_22).unwrap(),
        ));
        // D s_386_26: cast reint s_386_25 -> u8
        let s_386_26: bool = ((s_386_25.value()) != 0);
        // C s_386_27: const #16s : i
        let s_386_27: i128 = 16;
        // C s_386_28: const #4s : i
        let s_386_28: i128 = 4;
        // D s_386_29: read-var u#32525:u32
        let s_386_29: u32 = fn_state.u_32525;
        // D s_386_30: cast zx s_386_29 -> bv
        let s_386_30: Bits = Bits::new(s_386_29 as u128, 32u16);
        // D s_386_31: bit-extract s_386_30 s_386_27 s_386_28
        let s_386_31: Bits = (Bits::new(
            ((s_386_30) >> (s_386_27)).value(),
            u16::try_from(s_386_28).unwrap(),
        ));
        // D s_386_32: cast reint s_386_31 -> u8
        let s_386_32: u8 = (s_386_31.value() as u8);
        // C s_386_33: const #12s : i
        let s_386_33: i128 = 12;
        // C s_386_34: const #4s : i
        let s_386_34: i128 = 4;
        // D s_386_35: read-var u#32525:u32
        let s_386_35: u32 = fn_state.u_32525;
        // D s_386_36: cast zx s_386_35 -> bv
        let s_386_36: Bits = Bits::new(s_386_35 as u128, 32u16);
        // D s_386_37: bit-extract s_386_36 s_386_33 s_386_34
        let s_386_37: Bits = (Bits::new(
            ((s_386_36) >> (s_386_33)).value(),
            u16::try_from(s_386_34).unwrap(),
        ));
        // D s_386_38: cast reint s_386_37 -> u8
        let s_386_38: u8 = (s_386_37.value() as u8);
        // C s_386_39: const #8s : i
        let s_386_39: i128 = 8;
        // C s_386_40: const #4s : i
        let s_386_40: i128 = 4;
        // D s_386_41: read-var u#32525:u32
        let s_386_41: u32 = fn_state.u_32525;
        // D s_386_42: cast zx s_386_41 -> bv
        let s_386_42: Bits = Bits::new(s_386_41 as u128, 32u16);
        // D s_386_43: bit-extract s_386_42 s_386_39 s_386_40
        let s_386_43: Bits = (Bits::new(
            ((s_386_42) >> (s_386_39)).value(),
            u16::try_from(s_386_40).unwrap(),
        ));
        // D s_386_44: cast reint s_386_43 -> u8
        let s_386_44: u8 = (s_386_43.value() as u8);
        // C s_386_45: const #0s : i
        let s_386_45: i128 = 0;
        // C s_386_46: const #4s : i
        let s_386_46: i128 = 4;
        // D s_386_47: read-var u#32525:u32
        let s_386_47: u32 = fn_state.u_32525;
        // D s_386_48: cast zx s_386_47 -> bv
        let s_386_48: Bits = Bits::new(s_386_47 as u128, 32u16);
        // D s_386_49: bit-extract s_386_48 s_386_45 s_386_46
        let s_386_49: Bits = (Bits::new(
            ((s_386_48) >> (s_386_45)).value(),
            u16::try_from(s_386_46).unwrap(),
        ));
        // D s_386_50: cast reint s_386_49 -> u8
        let s_386_50: u8 = (s_386_49.value() as u8);
        // D s_386_51: call decode_aarch32_instrs_LDRD_i_A1enc_A_txt(s_386_8, s_386_14, s_386_20, s_386_26, s_386_32, s_386_38, s_386_44, s_386_50)
        let s_386_51: () = decode_aarch32_instrs_LDRD_i_A1enc_A_txt(
            state,
            tracer,
            s_386_8,
            s_386_14,
            s_386_20,
            s_386_26,
            s_386_32,
            s_386_38,
            s_386_44,
            s_386_50,
        );
        // N s_386_52: return
        return;
    }
    fn block_387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_387_0: read-var merge#var.1:struct
        let s_387_0: u32 = fn_state.merge_var._1;
        // D s_387_1: write-var u#32529 <= s_387_0
        fn_state.u_32529 = s_387_0;
        // C s_387_2: const #24s : i
        let s_387_2: i128 = 24;
        // D s_387_3: read-var u#32529:u32
        let s_387_3: u32 = fn_state.u_32529;
        // D s_387_4: cast zx s_387_3 -> bv
        let s_387_4: Bits = Bits::new(s_387_3 as u128, 32u16);
        // C s_387_5: const #1s : i64
        let s_387_5: i64 = 1;
        // C s_387_6: cast zx s_387_5 -> i
        let s_387_6: i128 = (i128::try_from(s_387_5).unwrap());
        // C s_387_7: const #3s : i
        let s_387_7: i128 = 3;
        // C s_387_8: add s_387_7 s_387_6
        let s_387_8: i128 = (s_387_7 + s_387_6);
        // D s_387_9: bit-extract s_387_4 s_387_2 s_387_8
        let s_387_9: Bits = (Bits::new(
            ((s_387_4) >> (s_387_2)).value(),
            u16::try_from(s_387_8).unwrap(),
        ));
        // D s_387_10: cast reint s_387_9 -> u8
        let s_387_10: u8 = (s_387_9.value() as u8);
        // D s_387_11: cast zx s_387_10 -> bv
        let s_387_11: Bits = Bits::new(s_387_10 as u128, 4u16);
        // C s_387_12: const #1u : u8
        let s_387_12: u8 = 1;
        // C s_387_13: cast zx s_387_12 -> bv
        let s_387_13: Bits = Bits::new(s_387_12 as u128, 4u16);
        // D s_387_14: cmp-eq s_387_11 s_387_13
        let s_387_14: bool = ((s_387_11) == (s_387_13));
        // N s_387_15: branch s_387_14 b2805 b388
        if s_387_14 {
            return block_2805(state, tracer, fn_state);
        } else {
            return block_388(state, tracer, fn_state);
        };
    }
    fn block_388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_388_0: const #0u : u8
        let s_388_0: bool = false;
        // D s_388_1: write-var gs#404834 <= s_388_0
        fn_state.gs_404834 = s_388_0;
        // N s_388_2: jump b389
        return block_389(state, tracer, fn_state);
    }
    fn block_389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_389_0: read-var gs#404834:u8
        let s_389_0: bool = fn_state.gs_404834;
        // N s_389_1: branch s_389_0 b2801 b390
        if s_389_0 {
            return block_2801(state, tracer, fn_state);
        } else {
            return block_390(state, tracer, fn_state);
        };
    }
    fn block_390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_390_0: const #0u : u8
        let s_390_0: bool = false;
        // D s_390_1: write-var gs#404839 <= s_390_0
        fn_state.gs_404839 = s_390_0;
        // N s_390_2: jump b391
        return block_391(state, tracer, fn_state);
    }
    fn block_391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_391_0: read-var gs#404839:u8
        let s_391_0: bool = fn_state.gs_404839;
        // D s_391_1: not s_391_0
        let s_391_1: bool = !s_391_0;
        // N s_391_2: branch s_391_1 b398 b392
        if s_391_1 {
            return block_398(state, tracer, fn_state);
        } else {
            return block_392(state, tracer, fn_state);
        };
    }
    fn block_392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_392_0: const #2937s : i
        let s_392_0: i128 = 2937;
        // C s_392_1: const #14696u : u32
        let s_392_1: u32 = 14696;
        // N s_392_2: write-reg s_392_1 <= s_392_0
        let s_392_2: () = {
            state.write_register::<i128>(s_392_1 as isize, s_392_0);
            tracer.write_register(s_392_1 as isize, s_392_0);
        };
        // C s_392_3: const #28s : i
        let s_392_3: i128 = 28;
        // C s_392_4: const #4s : i
        let s_392_4: i128 = 4;
        // D s_392_5: read-var u#32529:u32
        let s_392_5: u32 = fn_state.u_32529;
        // D s_392_6: cast zx s_392_5 -> bv
        let s_392_6: Bits = Bits::new(s_392_5 as u128, 32u16);
        // D s_392_7: bit-extract s_392_6 s_392_3 s_392_4
        let s_392_7: Bits = (Bits::new(
            ((s_392_6) >> (s_392_3)).value(),
            u16::try_from(s_392_4).unwrap(),
        ));
        // D s_392_8: cast reint s_392_7 -> u8
        let s_392_8: u8 = (s_392_7.value() as u8);
        // D s_392_9: write-var u#32530 <= s_392_8
        fn_state.u_32530 = s_392_8;
        // C s_392_10: const #23s : i
        let s_392_10: i128 = 23;
        // C s_392_11: const #1s : i
        let s_392_11: i128 = 1;
        // D s_392_12: read-var u#32529:u32
        let s_392_12: u32 = fn_state.u_32529;
        // D s_392_13: cast zx s_392_12 -> bv
        let s_392_13: Bits = Bits::new(s_392_12 as u128, 32u16);
        // D s_392_14: bit-extract s_392_13 s_392_10 s_392_11
        let s_392_14: Bits = (Bits::new(
            ((s_392_13) >> (s_392_10)).value(),
            u16::try_from(s_392_11).unwrap(),
        ));
        // D s_392_15: cast reint s_392_14 -> u8
        let s_392_15: bool = ((s_392_14.value()) != 0);
        // D s_392_16: write-var u#32531 <= s_392_15
        fn_state.u_32531 = s_392_15;
        // C s_392_17: const #12s : i
        let s_392_17: i128 = 12;
        // C s_392_18: const #4s : i
        let s_392_18: i128 = 4;
        // D s_392_19: read-var u#32529:u32
        let s_392_19: u32 = fn_state.u_32529;
        // D s_392_20: cast zx s_392_19 -> bv
        let s_392_20: Bits = Bits::new(s_392_19 as u128, 32u16);
        // D s_392_21: bit-extract s_392_20 s_392_17 s_392_18
        let s_392_21: Bits = (Bits::new(
            ((s_392_20) >> (s_392_17)).value(),
            u16::try_from(s_392_18).unwrap(),
        ));
        // D s_392_22: cast reint s_392_21 -> u8
        let s_392_22: u8 = (s_392_21.value() as u8);
        // D s_392_23: write-var u#32532 <= s_392_22
        fn_state.u_32532 = s_392_22;
        // C s_392_24: const #8s : i
        let s_392_24: i128 = 8;
        // C s_392_25: const #4s : i
        let s_392_25: i128 = 4;
        // D s_392_26: read-var u#32529:u32
        let s_392_26: u32 = fn_state.u_32529;
        // D s_392_27: cast zx s_392_26 -> bv
        let s_392_27: Bits = Bits::new(s_392_26 as u128, 32u16);
        // D s_392_28: bit-extract s_392_27 s_392_24 s_392_25
        let s_392_28: Bits = (Bits::new(
            ((s_392_27) >> (s_392_24)).value(),
            u16::try_from(s_392_25).unwrap(),
        ));
        // D s_392_29: cast reint s_392_28 -> u8
        let s_392_29: u8 = (s_392_28.value() as u8);
        // D s_392_30: write-var u#32533 <= s_392_29
        fn_state.u_32533 = s_392_29;
        // C s_392_31: const #0s : i
        let s_392_31: i128 = 0;
        // C s_392_32: const #4s : i
        let s_392_32: i128 = 4;
        // D s_392_33: read-var u#32529:u32
        let s_392_33: u32 = fn_state.u_32529;
        // D s_392_34: cast zx s_392_33 -> bv
        let s_392_34: Bits = Bits::new(s_392_33 as u128, 32u16);
        // D s_392_35: bit-extract s_392_34 s_392_31 s_392_32
        let s_392_35: Bits = (Bits::new(
            ((s_392_34) >> (s_392_31)).value(),
            u16::try_from(s_392_32).unwrap(),
        ));
        // D s_392_36: cast reint s_392_35 -> u8
        let s_392_36: u8 = (s_392_35.value() as u8);
        // D s_392_37: write-var u#32534 <= s_392_36
        fn_state.u_32534 = s_392_36;
        // C s_392_38: const #24s : i
        let s_392_38: i128 = 24;
        // D s_392_39: read-var u#32529:u32
        let s_392_39: u32 = fn_state.u_32529;
        // D s_392_40: cast zx s_392_39 -> bv
        let s_392_40: Bits = Bits::new(s_392_39 as u128, 32u16);
        // C s_392_41: const #1u : u64
        let s_392_41: u64 = 1;
        // D s_392_42: bit-extract s_392_40 s_392_38 s_392_41
        let s_392_42: Bits = (Bits::new(
            ((s_392_40) >> (s_392_38)).value(),
            u16::try_from(s_392_41).unwrap(),
        ));
        // D s_392_43: cast reint s_392_42 -> u8
        let s_392_43: bool = ((s_392_42.value()) != 0);
        // C s_392_44: const #0s : i
        let s_392_44: i128 = 0;
        // C s_392_45: const #0u : u64
        let s_392_45: u64 = 0;
        // D s_392_46: cast zx s_392_43 -> u64
        let s_392_46: u64 = (s_392_43 as u64);
        // C s_392_47: const #1u : u64
        let s_392_47: u64 = 1;
        // D s_392_48: and s_392_46 s_392_47
        let s_392_48: u64 = ((s_392_46) & (s_392_47));
        // D s_392_49: cmp-eq s_392_48 s_392_47
        let s_392_49: bool = ((s_392_48) == (s_392_47));
        // D s_392_50: lsl s_392_46 s_392_44
        let s_392_50: u64 = s_392_46 << s_392_44;
        // D s_392_51: or s_392_45 s_392_50
        let s_392_51: u64 = ((s_392_45) | (s_392_50));
        // D s_392_52: cmpl s_392_50
        let s_392_52: u64 = !s_392_50;
        // D s_392_53: and s_392_45 s_392_52
        let s_392_53: u64 = ((s_392_45) & (s_392_52));
        // D s_392_54: select s_392_49 s_392_51 s_392_53
        let s_392_54: u64 = if s_392_49 { s_392_51 } else { s_392_53 };
        // D s_392_55: cast trunc s_392_54 -> u8
        let s_392_55: bool = ((s_392_54) != 0);
        // D s_392_56: cast zx s_392_55 -> bv
        let s_392_56: Bits = Bits::new(s_392_55 as u128, 1u16);
        // C s_392_57: const #1u : u8
        let s_392_57: bool = true;
        // C s_392_58: cast zx s_392_57 -> bv
        let s_392_58: Bits = Bits::new(s_392_57 as u128, 1u16);
        // D s_392_59: cmp-ne s_392_56 s_392_58
        let s_392_59: bool = ((s_392_56) != (s_392_58));
        // N s_392_60: branch s_392_59 b397 b393
        if s_392_59 {
            return block_397(state, tracer, fn_state);
        } else {
            return block_393(state, tracer, fn_state);
        };
    }
    fn block_393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_393_0: const #21s : i
        let s_393_0: i128 = 21;
        // D s_393_1: read-var u#32529:u32
        let s_393_1: u32 = fn_state.u_32529;
        // D s_393_2: cast zx s_393_1 -> bv
        let s_393_2: Bits = Bits::new(s_393_1 as u128, 32u16);
        // C s_393_3: const #1u : u64
        let s_393_3: u64 = 1;
        // D s_393_4: bit-extract s_393_2 s_393_0 s_393_3
        let s_393_4: Bits = (Bits::new(
            ((s_393_2) >> (s_393_0)).value(),
            u16::try_from(s_393_3).unwrap(),
        ));
        // D s_393_5: cast reint s_393_4 -> u8
        let s_393_5: bool = ((s_393_4.value()) != 0);
        // C s_393_6: const #0s : i
        let s_393_6: i128 = 0;
        // C s_393_7: const #0u : u64
        let s_393_7: u64 = 0;
        // D s_393_8: cast zx s_393_5 -> u64
        let s_393_8: u64 = (s_393_5 as u64);
        // C s_393_9: const #1u : u64
        let s_393_9: u64 = 1;
        // D s_393_10: and s_393_8 s_393_9
        let s_393_10: u64 = ((s_393_8) & (s_393_9));
        // D s_393_11: cmp-eq s_393_10 s_393_9
        let s_393_11: bool = ((s_393_10) == (s_393_9));
        // D s_393_12: lsl s_393_8 s_393_6
        let s_393_12: u64 = s_393_8 << s_393_6;
        // D s_393_13: or s_393_7 s_393_12
        let s_393_13: u64 = ((s_393_7) | (s_393_12));
        // D s_393_14: cmpl s_393_12
        let s_393_14: u64 = !s_393_12;
        // D s_393_15: and s_393_7 s_393_14
        let s_393_15: u64 = ((s_393_7) & (s_393_14));
        // D s_393_16: select s_393_11 s_393_13 s_393_15
        let s_393_16: u64 = if s_393_11 { s_393_13 } else { s_393_15 };
        // D s_393_17: cast trunc s_393_16 -> u8
        let s_393_17: bool = ((s_393_16) != 0);
        // D s_393_18: cast zx s_393_17 -> bv
        let s_393_18: Bits = Bits::new(s_393_17 as u128, 1u16);
        // C s_393_19: const #0u : u8
        let s_393_19: bool = false;
        // C s_393_20: cast zx s_393_19 -> bv
        let s_393_20: Bits = Bits::new(s_393_19 as u128, 1u16);
        // D s_393_21: cmp-ne s_393_18 s_393_20
        let s_393_21: bool = ((s_393_18) != (s_393_20));
        // D s_393_22: write-var gs#404856 <= s_393_21
        fn_state.gs_404856 = s_393_21;
        // N s_393_23: jump b394
        return block_394(state, tracer, fn_state);
    }
    fn block_394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_394_0: read-var gs#404856:u8
        let s_394_0: bool = fn_state.gs_404856;
        // N s_394_1: branch s_394_0 b396 b395
        if s_394_0 {
            return block_396(state, tracer, fn_state);
        } else {
            return block_395(state, tracer, fn_state);
        };
    }
    fn block_395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_395_0: read-var u#32530:u8
        let s_395_0: u8 = fn_state.u_32530;
        // D s_395_1: read-var u#32531:u8
        let s_395_1: bool = fn_state.u_32531;
        // D s_395_2: read-var u#32532:u8
        let s_395_2: u8 = fn_state.u_32532;
        // D s_395_3: read-var u#32533:u8
        let s_395_3: u8 = fn_state.u_32533;
        // D s_395_4: read-var u#32534:u8
        let s_395_4: u8 = fn_state.u_32534;
        // D s_395_5: call decode_aarch32_instrs_LDRD_l_A1enc_A_txt(s_395_0, s_395_1, s_395_2, s_395_3, s_395_4)
        let s_395_5: () = decode_aarch32_instrs_LDRD_l_A1enc_A_txt(
            state,
            tracer,
            s_395_0,
            s_395_1,
            s_395_2,
            s_395_3,
            s_395_4,
        );
        // N s_395_6: return
        return;
    }
    fn block_396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_396_0: panic
        panic!("{:?}", ());
        // N s_396_1: return
        return;
    }
    fn block_397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_397_0: const #1u : u8
        let s_397_0: bool = true;
        // D s_397_1: write-var gs#404856 <= s_397_0
        fn_state.gs_404856 = s_397_0;
        // N s_397_2: jump b394
        return block_394(state, tracer, fn_state);
    }
    fn block_398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_398_0: read-var merge#var.1:struct
        let s_398_0: u32 = fn_state.merge_var._1;
        // D s_398_1: write-var u#32536 <= s_398_0
        fn_state.u_32536 = s_398_0;
        // C s_398_2: const #25s : i
        let s_398_2: i128 = 25;
        // D s_398_3: read-var u#32536:u32
        let s_398_3: u32 = fn_state.u_32536;
        // D s_398_4: cast zx s_398_3 -> bv
        let s_398_4: Bits = Bits::new(s_398_3 as u128, 32u16);
        // C s_398_5: const #1s : i64
        let s_398_5: i64 = 1;
        // C s_398_6: cast zx s_398_5 -> i
        let s_398_6: i128 = (i128::try_from(s_398_5).unwrap());
        // C s_398_7: const #2s : i
        let s_398_7: i128 = 2;
        // C s_398_8: add s_398_7 s_398_6
        let s_398_8: i128 = (s_398_7 + s_398_6);
        // D s_398_9: bit-extract s_398_4 s_398_2 s_398_8
        let s_398_9: Bits = (Bits::new(
            ((s_398_4) >> (s_398_2)).value(),
            u16::try_from(s_398_8).unwrap(),
        ));
        // D s_398_10: cast reint s_398_9 -> u8
        let s_398_10: u8 = (s_398_9.value() as u8);
        // D s_398_11: cast zx s_398_10 -> bv
        let s_398_11: Bits = Bits::new(s_398_10 as u128, 3u16);
        // C s_398_12: const #0u : u8
        let s_398_12: u8 = 0;
        // C s_398_13: cast zx s_398_12 -> bv
        let s_398_13: Bits = Bits::new(s_398_12 as u128, 3u16);
        // D s_398_14: cmp-eq s_398_11 s_398_13
        let s_398_14: bool = ((s_398_11) == (s_398_13));
        // N s_398_15: branch s_398_14 b2794 b399
        if s_398_14 {
            return block_2794(state, tracer, fn_state);
        } else {
            return block_399(state, tracer, fn_state);
        };
    }
    fn block_399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_399_0: const #0u : u8
        let s_399_0: bool = false;
        // D s_399_1: write-var gs#404868 <= s_399_0
        fn_state.gs_404868 = s_399_0;
        // N s_399_2: jump b400
        return block_400(state, tracer, fn_state);
    }
    fn block_400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_400_0: read-var gs#404868:u8
        let s_400_0: bool = fn_state.gs_404868;
        // N s_400_1: branch s_400_0 b2790 b401
        if s_400_0 {
            return block_2790(state, tracer, fn_state);
        } else {
            return block_401(state, tracer, fn_state);
        };
    }
    fn block_401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_401_0: const #0u : u8
        let s_401_0: bool = false;
        // D s_401_1: write-var gs#404873 <= s_401_0
        fn_state.gs_404873 = s_401_0;
        // N s_401_2: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_402_0: read-var gs#404873:u8
        let s_402_0: bool = fn_state.gs_404873;
        // D s_402_1: not s_402_0
        let s_402_1: bool = !s_402_0;
        // N s_402_2: branch s_402_1 b415 b403
        if s_402_1 {
            return block_415(state, tracer, fn_state);
        } else {
            return block_403(state, tracer, fn_state);
        };
    }
    fn block_403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_403_0: const #2939s : i
        let s_403_0: i128 = 2939;
        // C s_403_1: const #14696u : u32
        let s_403_1: u32 = 14696;
        // N s_403_2: write-reg s_403_1 <= s_403_0
        let s_403_2: () = {
            state.write_register::<i128>(s_403_1 as isize, s_403_0);
            tracer.write_register(s_403_1 as isize, s_403_0);
        };
        // C s_403_3: const #28s : i
        let s_403_3: i128 = 28;
        // C s_403_4: const #4s : i
        let s_403_4: i128 = 4;
        // D s_403_5: read-var u#32536:u32
        let s_403_5: u32 = fn_state.u_32536;
        // D s_403_6: cast zx s_403_5 -> bv
        let s_403_6: Bits = Bits::new(s_403_5 as u128, 32u16);
        // D s_403_7: bit-extract s_403_6 s_403_3 s_403_4
        let s_403_7: Bits = (Bits::new(
            ((s_403_6) >> (s_403_3)).value(),
            u16::try_from(s_403_4).unwrap(),
        ));
        // D s_403_8: cast reint s_403_7 -> u8
        let s_403_8: u8 = (s_403_7.value() as u8);
        // D s_403_9: write-var u#32537 <= s_403_8
        fn_state.u_32537 = s_403_8;
        // C s_403_10: const #24s : i
        let s_403_10: i128 = 24;
        // C s_403_11: const #1s : i
        let s_403_11: i128 = 1;
        // D s_403_12: read-var u#32536:u32
        let s_403_12: u32 = fn_state.u_32536;
        // D s_403_13: cast zx s_403_12 -> bv
        let s_403_13: Bits = Bits::new(s_403_12 as u128, 32u16);
        // D s_403_14: bit-extract s_403_13 s_403_10 s_403_11
        let s_403_14: Bits = (Bits::new(
            ((s_403_13) >> (s_403_10)).value(),
            u16::try_from(s_403_11).unwrap(),
        ));
        // D s_403_15: cast reint s_403_14 -> u8
        let s_403_15: bool = ((s_403_14.value()) != 0);
        // D s_403_16: write-var u#32538 <= s_403_15
        fn_state.u_32538 = s_403_15;
        // C s_403_17: const #23s : i
        let s_403_17: i128 = 23;
        // C s_403_18: const #1s : i
        let s_403_18: i128 = 1;
        // D s_403_19: read-var u#32536:u32
        let s_403_19: u32 = fn_state.u_32536;
        // D s_403_20: cast zx s_403_19 -> bv
        let s_403_20: Bits = Bits::new(s_403_19 as u128, 32u16);
        // D s_403_21: bit-extract s_403_20 s_403_17 s_403_18
        let s_403_21: Bits = (Bits::new(
            ((s_403_20) >> (s_403_17)).value(),
            u16::try_from(s_403_18).unwrap(),
        ));
        // D s_403_22: cast reint s_403_21 -> u8
        let s_403_22: bool = ((s_403_21.value()) != 0);
        // D s_403_23: write-var u#32539 <= s_403_22
        fn_state.u_32539 = s_403_22;
        // C s_403_24: const #21s : i
        let s_403_24: i128 = 21;
        // C s_403_25: const #1s : i
        let s_403_25: i128 = 1;
        // D s_403_26: read-var u#32536:u32
        let s_403_26: u32 = fn_state.u_32536;
        // D s_403_27: cast zx s_403_26 -> bv
        let s_403_27: Bits = Bits::new(s_403_26 as u128, 32u16);
        // D s_403_28: bit-extract s_403_27 s_403_24 s_403_25
        let s_403_28: Bits = (Bits::new(
            ((s_403_27) >> (s_403_24)).value(),
            u16::try_from(s_403_25).unwrap(),
        ));
        // D s_403_29: cast reint s_403_28 -> u8
        let s_403_29: bool = ((s_403_28.value()) != 0);
        // D s_403_30: write-var u#32540 <= s_403_29
        fn_state.u_32540 = s_403_29;
        // C s_403_31: const #16s : i
        let s_403_31: i128 = 16;
        // C s_403_32: const #4s : i
        let s_403_32: i128 = 4;
        // D s_403_33: read-var u#32536:u32
        let s_403_33: u32 = fn_state.u_32536;
        // D s_403_34: cast zx s_403_33 -> bv
        let s_403_34: Bits = Bits::new(s_403_33 as u128, 32u16);
        // D s_403_35: bit-extract s_403_34 s_403_31 s_403_32
        let s_403_35: Bits = (Bits::new(
            ((s_403_34) >> (s_403_31)).value(),
            u16::try_from(s_403_32).unwrap(),
        ));
        // D s_403_36: cast reint s_403_35 -> u8
        let s_403_36: u8 = (s_403_35.value() as u8);
        // D s_403_37: write-var u#32541 <= s_403_36
        fn_state.u_32541 = s_403_36;
        // C s_403_38: const #12s : i
        let s_403_38: i128 = 12;
        // C s_403_39: const #4s : i
        let s_403_39: i128 = 4;
        // D s_403_40: read-var u#32536:u32
        let s_403_40: u32 = fn_state.u_32536;
        // D s_403_41: cast zx s_403_40 -> bv
        let s_403_41: Bits = Bits::new(s_403_40 as u128, 32u16);
        // D s_403_42: bit-extract s_403_41 s_403_38 s_403_39
        let s_403_42: Bits = (Bits::new(
            ((s_403_41) >> (s_403_38)).value(),
            u16::try_from(s_403_39).unwrap(),
        ));
        // D s_403_43: cast reint s_403_42 -> u8
        let s_403_43: u8 = (s_403_42.value() as u8);
        // D s_403_44: write-var u#32542 <= s_403_43
        fn_state.u_32542 = s_403_43;
        // C s_403_45: const #0s : i
        let s_403_45: i128 = 0;
        // C s_403_46: const #4s : i
        let s_403_46: i128 = 4;
        // D s_403_47: read-var u#32536:u32
        let s_403_47: u32 = fn_state.u_32536;
        // D s_403_48: cast zx s_403_47 -> bv
        let s_403_48: Bits = Bits::new(s_403_47 as u128, 32u16);
        // D s_403_49: bit-extract s_403_48 s_403_45 s_403_46
        let s_403_49: Bits = (Bits::new(
            ((s_403_48) >> (s_403_45)).value(),
            u16::try_from(s_403_46).unwrap(),
        ));
        // D s_403_50: cast reint s_403_49 -> u8
        let s_403_50: u8 = (s_403_49.value() as u8);
        // D s_403_51: write-var u#32543 <= s_403_50
        fn_state.u_32543 = s_403_50;
        // C s_403_52: const #8s : i
        let s_403_52: i128 = 8;
        // D s_403_53: read-var u#32536:u32
        let s_403_53: u32 = fn_state.u_32536;
        // D s_403_54: cast zx s_403_53 -> bv
        let s_403_54: Bits = Bits::new(s_403_53 as u128, 32u16);
        // C s_403_55: const #1u : u64
        let s_403_55: u64 = 1;
        // D s_403_56: bit-extract s_403_54 s_403_52 s_403_55
        let s_403_56: Bits = (Bits::new(
            ((s_403_54) >> (s_403_52)).value(),
            u16::try_from(s_403_55).unwrap(),
        ));
        // D s_403_57: cast reint s_403_56 -> u8
        let s_403_57: bool = ((s_403_56.value()) != 0);
        // C s_403_58: const #0s : i
        let s_403_58: i128 = 0;
        // C s_403_59: const #0u : u64
        let s_403_59: u64 = 0;
        // D s_403_60: cast zx s_403_57 -> u64
        let s_403_60: u64 = (s_403_57 as u64);
        // C s_403_61: const #1u : u64
        let s_403_61: u64 = 1;
        // D s_403_62: and s_403_60 s_403_61
        let s_403_62: u64 = ((s_403_60) & (s_403_61));
        // D s_403_63: cmp-eq s_403_62 s_403_61
        let s_403_63: bool = ((s_403_62) == (s_403_61));
        // D s_403_64: lsl s_403_60 s_403_58
        let s_403_64: u64 = s_403_60 << s_403_58;
        // D s_403_65: or s_403_59 s_403_64
        let s_403_65: u64 = ((s_403_59) | (s_403_64));
        // D s_403_66: cmpl s_403_64
        let s_403_66: u64 = !s_403_64;
        // D s_403_67: and s_403_59 s_403_66
        let s_403_67: u64 = ((s_403_59) & (s_403_66));
        // D s_403_68: select s_403_63 s_403_65 s_403_67
        let s_403_68: u64 = if s_403_63 { s_403_65 } else { s_403_67 };
        // D s_403_69: cast trunc s_403_68 -> u8
        let s_403_69: bool = ((s_403_68) != 0);
        // D s_403_70: cast zx s_403_69 -> bv
        let s_403_70: Bits = Bits::new(s_403_69 as u128, 1u16);
        // C s_403_71: const #0u : u8
        let s_403_71: bool = false;
        // C s_403_72: cast zx s_403_71 -> bv
        let s_403_72: Bits = Bits::new(s_403_71 as u128, 1u16);
        // D s_403_73: cmp-ne s_403_70 s_403_72
        let s_403_73: bool = ((s_403_70) != (s_403_72));
        // N s_403_74: branch s_403_73 b414 b404
        if s_403_73 {
            return block_414(state, tracer, fn_state);
        } else {
            return block_404(state, tracer, fn_state);
        };
    }
    fn block_404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_404_0: const #9s : i
        let s_404_0: i128 = 9;
        // D s_404_1: read-var u#32536:u32
        let s_404_1: u32 = fn_state.u_32536;
        // D s_404_2: cast zx s_404_1 -> bv
        let s_404_2: Bits = Bits::new(s_404_1 as u128, 32u16);
        // C s_404_3: const #1u : u64
        let s_404_3: u64 = 1;
        // D s_404_4: bit-extract s_404_2 s_404_0 s_404_3
        let s_404_4: Bits = (Bits::new(
            ((s_404_2) >> (s_404_0)).value(),
            u16::try_from(s_404_3).unwrap(),
        ));
        // D s_404_5: cast reint s_404_4 -> u8
        let s_404_5: bool = ((s_404_4.value()) != 0);
        // C s_404_6: const #0s : i
        let s_404_6: i128 = 0;
        // C s_404_7: const #0u : u64
        let s_404_7: u64 = 0;
        // D s_404_8: cast zx s_404_5 -> u64
        let s_404_8: u64 = (s_404_5 as u64);
        // C s_404_9: const #1u : u64
        let s_404_9: u64 = 1;
        // D s_404_10: and s_404_8 s_404_9
        let s_404_10: u64 = ((s_404_8) & (s_404_9));
        // D s_404_11: cmp-eq s_404_10 s_404_9
        let s_404_11: bool = ((s_404_10) == (s_404_9));
        // D s_404_12: lsl s_404_8 s_404_6
        let s_404_12: u64 = s_404_8 << s_404_6;
        // D s_404_13: or s_404_7 s_404_12
        let s_404_13: u64 = ((s_404_7) | (s_404_12));
        // D s_404_14: cmpl s_404_12
        let s_404_14: u64 = !s_404_12;
        // D s_404_15: and s_404_7 s_404_14
        let s_404_15: u64 = ((s_404_7) & (s_404_14));
        // D s_404_16: select s_404_11 s_404_13 s_404_15
        let s_404_16: u64 = if s_404_11 { s_404_13 } else { s_404_15 };
        // D s_404_17: cast trunc s_404_16 -> u8
        let s_404_17: bool = ((s_404_16) != 0);
        // D s_404_18: cast zx s_404_17 -> bv
        let s_404_18: Bits = Bits::new(s_404_17 as u128, 1u16);
        // C s_404_19: const #0u : u8
        let s_404_19: bool = false;
        // C s_404_20: cast zx s_404_19 -> bv
        let s_404_20: Bits = Bits::new(s_404_19 as u128, 1u16);
        // D s_404_21: cmp-ne s_404_18 s_404_20
        let s_404_21: bool = ((s_404_18) != (s_404_20));
        // D s_404_22: write-var gs#404894 <= s_404_21
        fn_state.gs_404894 = s_404_21;
        // N s_404_23: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_405_0: read-var gs#404894:u8
        let s_405_0: bool = fn_state.gs_404894;
        // N s_405_1: branch s_405_0 b413 b406
        if s_405_0 {
            return block_413(state, tracer, fn_state);
        } else {
            return block_406(state, tracer, fn_state);
        };
    }
    fn block_406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_406_0: const #10s : i
        let s_406_0: i128 = 10;
        // D s_406_1: read-var u#32536:u32
        let s_406_1: u32 = fn_state.u_32536;
        // D s_406_2: cast zx s_406_1 -> bv
        let s_406_2: Bits = Bits::new(s_406_1 as u128, 32u16);
        // C s_406_3: const #1u : u64
        let s_406_3: u64 = 1;
        // D s_406_4: bit-extract s_406_2 s_406_0 s_406_3
        let s_406_4: Bits = (Bits::new(
            ((s_406_2) >> (s_406_0)).value(),
            u16::try_from(s_406_3).unwrap(),
        ));
        // D s_406_5: cast reint s_406_4 -> u8
        let s_406_5: bool = ((s_406_4.value()) != 0);
        // C s_406_6: const #0s : i
        let s_406_6: i128 = 0;
        // C s_406_7: const #0u : u64
        let s_406_7: u64 = 0;
        // D s_406_8: cast zx s_406_5 -> u64
        let s_406_8: u64 = (s_406_5 as u64);
        // C s_406_9: const #1u : u64
        let s_406_9: u64 = 1;
        // D s_406_10: and s_406_8 s_406_9
        let s_406_10: u64 = ((s_406_8) & (s_406_9));
        // D s_406_11: cmp-eq s_406_10 s_406_9
        let s_406_11: bool = ((s_406_10) == (s_406_9));
        // D s_406_12: lsl s_406_8 s_406_6
        let s_406_12: u64 = s_406_8 << s_406_6;
        // D s_406_13: or s_406_7 s_406_12
        let s_406_13: u64 = ((s_406_7) | (s_406_12));
        // D s_406_14: cmpl s_406_12
        let s_406_14: u64 = !s_406_12;
        // D s_406_15: and s_406_7 s_406_14
        let s_406_15: u64 = ((s_406_7) & (s_406_14));
        // D s_406_16: select s_406_11 s_406_13 s_406_15
        let s_406_16: u64 = if s_406_11 { s_406_13 } else { s_406_15 };
        // D s_406_17: cast trunc s_406_16 -> u8
        let s_406_17: bool = ((s_406_16) != 0);
        // D s_406_18: cast zx s_406_17 -> bv
        let s_406_18: Bits = Bits::new(s_406_17 as u128, 1u16);
        // C s_406_19: const #0u : u8
        let s_406_19: bool = false;
        // C s_406_20: cast zx s_406_19 -> bv
        let s_406_20: Bits = Bits::new(s_406_19 as u128, 1u16);
        // D s_406_21: cmp-ne s_406_18 s_406_20
        let s_406_21: bool = ((s_406_18) != (s_406_20));
        // D s_406_22: write-var gs#404897 <= s_406_21
        fn_state.gs_404897 = s_406_21;
        // N s_406_23: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_407_0: read-var gs#404897:u8
        let s_407_0: bool = fn_state.gs_404897;
        // N s_407_1: branch s_407_0 b412 b408
        if s_407_0 {
            return block_412(state, tracer, fn_state);
        } else {
            return block_408(state, tracer, fn_state);
        };
    }
    fn block_408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_408_0: const #11s : i
        let s_408_0: i128 = 11;
        // D s_408_1: read-var u#32536:u32
        let s_408_1: u32 = fn_state.u_32536;
        // D s_408_2: cast zx s_408_1 -> bv
        let s_408_2: Bits = Bits::new(s_408_1 as u128, 32u16);
        // C s_408_3: const #1u : u64
        let s_408_3: u64 = 1;
        // D s_408_4: bit-extract s_408_2 s_408_0 s_408_3
        let s_408_4: Bits = (Bits::new(
            ((s_408_2) >> (s_408_0)).value(),
            u16::try_from(s_408_3).unwrap(),
        ));
        // D s_408_5: cast reint s_408_4 -> u8
        let s_408_5: bool = ((s_408_4.value()) != 0);
        // C s_408_6: const #0s : i
        let s_408_6: i128 = 0;
        // C s_408_7: const #0u : u64
        let s_408_7: u64 = 0;
        // D s_408_8: cast zx s_408_5 -> u64
        let s_408_8: u64 = (s_408_5 as u64);
        // C s_408_9: const #1u : u64
        let s_408_9: u64 = 1;
        // D s_408_10: and s_408_8 s_408_9
        let s_408_10: u64 = ((s_408_8) & (s_408_9));
        // D s_408_11: cmp-eq s_408_10 s_408_9
        let s_408_11: bool = ((s_408_10) == (s_408_9));
        // D s_408_12: lsl s_408_8 s_408_6
        let s_408_12: u64 = s_408_8 << s_408_6;
        // D s_408_13: or s_408_7 s_408_12
        let s_408_13: u64 = ((s_408_7) | (s_408_12));
        // D s_408_14: cmpl s_408_12
        let s_408_14: u64 = !s_408_12;
        // D s_408_15: and s_408_7 s_408_14
        let s_408_15: u64 = ((s_408_7) & (s_408_14));
        // D s_408_16: select s_408_11 s_408_13 s_408_15
        let s_408_16: u64 = if s_408_11 { s_408_13 } else { s_408_15 };
        // D s_408_17: cast trunc s_408_16 -> u8
        let s_408_17: bool = ((s_408_16) != 0);
        // D s_408_18: cast zx s_408_17 -> bv
        let s_408_18: Bits = Bits::new(s_408_17 as u128, 1u16);
        // C s_408_19: const #0u : u8
        let s_408_19: bool = false;
        // C s_408_20: cast zx s_408_19 -> bv
        let s_408_20: Bits = Bits::new(s_408_19 as u128, 1u16);
        // D s_408_21: cmp-ne s_408_18 s_408_20
        let s_408_21: bool = ((s_408_18) != (s_408_20));
        // D s_408_22: write-var gs#404900 <= s_408_21
        fn_state.gs_404900 = s_408_21;
        // N s_408_23: jump b409
        return block_409(state, tracer, fn_state);
    }
    fn block_409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_409_0: read-var gs#404900:u8
        let s_409_0: bool = fn_state.gs_404900;
        // N s_409_1: branch s_409_0 b411 b410
        if s_409_0 {
            return block_411(state, tracer, fn_state);
        } else {
            return block_410(state, tracer, fn_state);
        };
    }
    fn block_410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_410_0: read-var u#32537:u8
        let s_410_0: u8 = fn_state.u_32537;
        // D s_410_1: read-var u#32538:u8
        let s_410_1: bool = fn_state.u_32538;
        // D s_410_2: read-var u#32539:u8
        let s_410_2: bool = fn_state.u_32539;
        // D s_410_3: read-var u#32540:u8
        let s_410_3: bool = fn_state.u_32540;
        // D s_410_4: read-var u#32541:u8
        let s_410_4: u8 = fn_state.u_32541;
        // D s_410_5: read-var u#32542:u8
        let s_410_5: u8 = fn_state.u_32542;
        // D s_410_6: read-var u#32543:u8
        let s_410_6: u8 = fn_state.u_32543;
        // D s_410_7: call decode_aarch32_instrs_LDRD_r_A1enc_A_txt(s_410_0, s_410_1, s_410_2, s_410_3, s_410_4, s_410_5, s_410_6)
        let s_410_7: () = decode_aarch32_instrs_LDRD_r_A1enc_A_txt(
            state,
            tracer,
            s_410_0,
            s_410_1,
            s_410_2,
            s_410_3,
            s_410_4,
            s_410_5,
            s_410_6,
        );
        // N s_410_8: return
        return;
    }
    fn block_411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_411_0: panic
        panic!("{:?}", ());
        // N s_411_1: return
        return;
    }
    fn block_412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_412_0: const #1u : u8
        let s_412_0: bool = true;
        // D s_412_1: write-var gs#404900 <= s_412_0
        fn_state.gs_404900 = s_412_0;
        // N s_412_2: jump b409
        return block_409(state, tracer, fn_state);
    }
    fn block_413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_413_0: const #1u : u8
        let s_413_0: bool = true;
        // D s_413_1: write-var gs#404897 <= s_413_0
        fn_state.gs_404897 = s_413_0;
        // N s_413_2: jump b407
        return block_407(state, tracer, fn_state);
    }
    fn block_414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_414_0: const #1u : u8
        let s_414_0: bool = true;
        // D s_414_1: write-var gs#404894 <= s_414_0
        fn_state.gs_404894 = s_414_0;
        // N s_414_2: jump b405
        return block_405(state, tracer, fn_state);
    }
    fn block_415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_415_0: read-var merge#var.1:struct
        let s_415_0: u32 = fn_state.merge_var._1;
        // D s_415_1: write-var u#32545 <= s_415_0
        fn_state.u_32545 = s_415_0;
        // C s_415_2: const #20s : i
        let s_415_2: i128 = 20;
        // D s_415_3: read-var u#32545:u32
        let s_415_3: u32 = fn_state.u_32545;
        // D s_415_4: cast zx s_415_3 -> bv
        let s_415_4: Bits = Bits::new(s_415_3 as u128, 32u16);
        // C s_415_5: const #1s : i64
        let s_415_5: i64 = 1;
        // C s_415_6: cast zx s_415_5 -> i
        let s_415_6: i128 = (i128::try_from(s_415_5).unwrap());
        // C s_415_7: const #7s : i
        let s_415_7: i128 = 7;
        // C s_415_8: add s_415_7 s_415_6
        let s_415_8: i128 = (s_415_7 + s_415_6);
        // D s_415_9: bit-extract s_415_4 s_415_2 s_415_8
        let s_415_9: Bits = (Bits::new(
            ((s_415_4) >> (s_415_2)).value(),
            u16::try_from(s_415_8).unwrap(),
        ));
        // D s_415_10: cast reint s_415_9 -> u8
        let s_415_10: u8 = (s_415_9.value() as u8);
        // D s_415_11: cast zx s_415_10 -> bv
        let s_415_11: Bits = Bits::new(s_415_10 as u128, 8u16);
        // C s_415_12: const #25u : u8
        let s_415_12: u8 = 25;
        // C s_415_13: cast zx s_415_12 -> bv
        let s_415_13: Bits = Bits::new(s_415_12 as u128, 8u16);
        // D s_415_14: cmp-eq s_415_11 s_415_13
        let s_415_14: bool = ((s_415_11) == (s_415_13));
        // N s_415_15: branch s_415_14 b2789 b416
        if s_415_14 {
            return block_2789(state, tracer, fn_state);
        } else {
            return block_416(state, tracer, fn_state);
        };
    }
    fn block_416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_416_0: const #0u : u8
        let s_416_0: bool = false;
        // D s_416_1: write-var gs#404906 <= s_416_0
        fn_state.gs_404906 = s_416_0;
        // N s_416_2: jump b417
        return block_417(state, tracer, fn_state);
    }
    fn block_417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_417_0: read-var gs#404906:u8
        let s_417_0: bool = fn_state.gs_404906;
        // N s_417_1: branch s_417_0 b2785 b418
        if s_417_0 {
            return block_2785(state, tracer, fn_state);
        } else {
            return block_418(state, tracer, fn_state);
        };
    }
    fn block_418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_418_0: const #0u : u8
        let s_418_0: bool = false;
        // D s_418_1: write-var gs#404911 <= s_418_0
        fn_state.gs_404911 = s_418_0;
        // N s_418_2: jump b419
        return block_419(state, tracer, fn_state);
    }
    fn block_419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_419_0: read-var gs#404911:u8
        let s_419_0: bool = fn_state.gs_404911;
        // D s_419_1: not s_419_0
        let s_419_1: bool = !s_419_0;
        // N s_419_2: branch s_419_1 b438 b420
        if s_419_1 {
            return block_438(state, tracer, fn_state);
        } else {
            return block_420(state, tracer, fn_state);
        };
    }
    fn block_420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_420_0: const #2940s : i
        let s_420_0: i128 = 2940;
        // C s_420_1: const #14696u : u32
        let s_420_1: u32 = 14696;
        // N s_420_2: write-reg s_420_1 <= s_420_0
        let s_420_2: () = {
            state.write_register::<i128>(s_420_1 as isize, s_420_0);
            tracer.write_register(s_420_1 as isize, s_420_0);
        };
        // C s_420_3: const #28s : i
        let s_420_3: i128 = 28;
        // C s_420_4: const #4s : i
        let s_420_4: i128 = 4;
        // D s_420_5: read-var u#32545:u32
        let s_420_5: u32 = fn_state.u_32545;
        // D s_420_6: cast zx s_420_5 -> bv
        let s_420_6: Bits = Bits::new(s_420_5 as u128, 32u16);
        // D s_420_7: bit-extract s_420_6 s_420_3 s_420_4
        let s_420_7: Bits = (Bits::new(
            ((s_420_6) >> (s_420_3)).value(),
            u16::try_from(s_420_4).unwrap(),
        ));
        // D s_420_8: cast reint s_420_7 -> u8
        let s_420_8: u8 = (s_420_7.value() as u8);
        // D s_420_9: write-var u#32546 <= s_420_8
        fn_state.u_32546 = s_420_8;
        // C s_420_10: const #16s : i
        let s_420_10: i128 = 16;
        // C s_420_11: const #4s : i
        let s_420_11: i128 = 4;
        // D s_420_12: read-var u#32545:u32
        let s_420_12: u32 = fn_state.u_32545;
        // D s_420_13: cast zx s_420_12 -> bv
        let s_420_13: Bits = Bits::new(s_420_12 as u128, 32u16);
        // D s_420_14: bit-extract s_420_13 s_420_10 s_420_11
        let s_420_14: Bits = (Bits::new(
            ((s_420_13) >> (s_420_10)).value(),
            u16::try_from(s_420_11).unwrap(),
        ));
        // D s_420_15: cast reint s_420_14 -> u8
        let s_420_15: u8 = (s_420_14.value() as u8);
        // D s_420_16: write-var u#32547 <= s_420_15
        fn_state.u_32547 = s_420_15;
        // C s_420_17: const #12s : i
        let s_420_17: i128 = 12;
        // C s_420_18: const #4s : i
        let s_420_18: i128 = 4;
        // D s_420_19: read-var u#32545:u32
        let s_420_19: u32 = fn_state.u_32545;
        // D s_420_20: cast zx s_420_19 -> bv
        let s_420_20: Bits = Bits::new(s_420_19 as u128, 32u16);
        // D s_420_21: bit-extract s_420_20 s_420_17 s_420_18
        let s_420_21: Bits = (Bits::new(
            ((s_420_20) >> (s_420_17)).value(),
            u16::try_from(s_420_18).unwrap(),
        ));
        // D s_420_22: cast reint s_420_21 -> u8
        let s_420_22: u8 = (s_420_21.value() as u8);
        // D s_420_23: write-var u#32548 <= s_420_22
        fn_state.u_32548 = s_420_22;
        // C s_420_24: const #8s : i
        let s_420_24: i128 = 8;
        // D s_420_25: read-var u#32545:u32
        let s_420_25: u32 = fn_state.u_32545;
        // D s_420_26: cast zx s_420_25 -> bv
        let s_420_26: Bits = Bits::new(s_420_25 as u128, 32u16);
        // C s_420_27: const #1u : u64
        let s_420_27: u64 = 1;
        // D s_420_28: bit-extract s_420_26 s_420_24 s_420_27
        let s_420_28: Bits = (Bits::new(
            ((s_420_26) >> (s_420_24)).value(),
            u16::try_from(s_420_27).unwrap(),
        ));
        // D s_420_29: cast reint s_420_28 -> u8
        let s_420_29: bool = ((s_420_28.value()) != 0);
        // C s_420_30: const #0s : i
        let s_420_30: i128 = 0;
        // C s_420_31: const #0u : u64
        let s_420_31: u64 = 0;
        // D s_420_32: cast zx s_420_29 -> u64
        let s_420_32: u64 = (s_420_29 as u64);
        // C s_420_33: const #1u : u64
        let s_420_33: u64 = 1;
        // D s_420_34: and s_420_32 s_420_33
        let s_420_34: u64 = ((s_420_32) & (s_420_33));
        // D s_420_35: cmp-eq s_420_34 s_420_33
        let s_420_35: bool = ((s_420_34) == (s_420_33));
        // D s_420_36: lsl s_420_32 s_420_30
        let s_420_36: u64 = s_420_32 << s_420_30;
        // D s_420_37: or s_420_31 s_420_36
        let s_420_37: u64 = ((s_420_31) | (s_420_36));
        // D s_420_38: cmpl s_420_36
        let s_420_38: u64 = !s_420_36;
        // D s_420_39: and s_420_31 s_420_38
        let s_420_39: u64 = ((s_420_31) & (s_420_38));
        // D s_420_40: select s_420_35 s_420_37 s_420_39
        let s_420_40: u64 = if s_420_35 { s_420_37 } else { s_420_39 };
        // D s_420_41: cast trunc s_420_40 -> u8
        let s_420_41: bool = ((s_420_40) != 0);
        // D s_420_42: cast zx s_420_41 -> bv
        let s_420_42: Bits = Bits::new(s_420_41 as u128, 1u16);
        // C s_420_43: const #1u : u8
        let s_420_43: bool = true;
        // C s_420_44: cast zx s_420_43 -> bv
        let s_420_44: Bits = Bits::new(s_420_43 as u128, 1u16);
        // D s_420_45: cmp-ne s_420_42 s_420_44
        let s_420_45: bool = ((s_420_42) != (s_420_44));
        // N s_420_46: branch s_420_45 b437 b421
        if s_420_45 {
            return block_437(state, tracer, fn_state);
        } else {
            return block_421(state, tracer, fn_state);
        };
    }
    fn block_421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_421_0: const #9s : i
        let s_421_0: i128 = 9;
        // D s_421_1: read-var u#32545:u32
        let s_421_1: u32 = fn_state.u_32545;
        // D s_421_2: cast zx s_421_1 -> bv
        let s_421_2: Bits = Bits::new(s_421_1 as u128, 32u16);
        // C s_421_3: const #1u : u64
        let s_421_3: u64 = 1;
        // D s_421_4: bit-extract s_421_2 s_421_0 s_421_3
        let s_421_4: Bits = (Bits::new(
            ((s_421_2) >> (s_421_0)).value(),
            u16::try_from(s_421_3).unwrap(),
        ));
        // D s_421_5: cast reint s_421_4 -> u8
        let s_421_5: bool = ((s_421_4.value()) != 0);
        // C s_421_6: const #0s : i
        let s_421_6: i128 = 0;
        // C s_421_7: const #0u : u64
        let s_421_7: u64 = 0;
        // D s_421_8: cast zx s_421_5 -> u64
        let s_421_8: u64 = (s_421_5 as u64);
        // C s_421_9: const #1u : u64
        let s_421_9: u64 = 1;
        // D s_421_10: and s_421_8 s_421_9
        let s_421_10: u64 = ((s_421_8) & (s_421_9));
        // D s_421_11: cmp-eq s_421_10 s_421_9
        let s_421_11: bool = ((s_421_10) == (s_421_9));
        // D s_421_12: lsl s_421_8 s_421_6
        let s_421_12: u64 = s_421_8 << s_421_6;
        // D s_421_13: or s_421_7 s_421_12
        let s_421_13: u64 = ((s_421_7) | (s_421_12));
        // D s_421_14: cmpl s_421_12
        let s_421_14: u64 = !s_421_12;
        // D s_421_15: and s_421_7 s_421_14
        let s_421_15: u64 = ((s_421_7) & (s_421_14));
        // D s_421_16: select s_421_11 s_421_13 s_421_15
        let s_421_16: u64 = if s_421_11 { s_421_13 } else { s_421_15 };
        // D s_421_17: cast trunc s_421_16 -> u8
        let s_421_17: bool = ((s_421_16) != 0);
        // D s_421_18: cast zx s_421_17 -> bv
        let s_421_18: Bits = Bits::new(s_421_17 as u128, 1u16);
        // C s_421_19: const #1u : u8
        let s_421_19: bool = true;
        // C s_421_20: cast zx s_421_19 -> bv
        let s_421_20: Bits = Bits::new(s_421_19 as u128, 1u16);
        // D s_421_21: cmp-ne s_421_18 s_421_20
        let s_421_21: bool = ((s_421_18) != (s_421_20));
        // D s_421_22: write-var gs#404924 <= s_421_21
        fn_state.gs_404924 = s_421_21;
        // N s_421_23: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_422_0: read-var gs#404924:u8
        let s_422_0: bool = fn_state.gs_404924;
        // N s_422_1: branch s_422_0 b436 b423
        if s_422_0 {
            return block_436(state, tracer, fn_state);
        } else {
            return block_423(state, tracer, fn_state);
        };
    }
    fn block_423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_423_0: const #0s : i
        let s_423_0: i128 = 0;
        // D s_423_1: read-var u#32545:u32
        let s_423_1: u32 = fn_state.u_32545;
        // D s_423_2: cast zx s_423_1 -> bv
        let s_423_2: Bits = Bits::new(s_423_1 as u128, 32u16);
        // C s_423_3: const #1u : u64
        let s_423_3: u64 = 1;
        // D s_423_4: bit-extract s_423_2 s_423_0 s_423_3
        let s_423_4: Bits = (Bits::new(
            ((s_423_2) >> (s_423_0)).value(),
            u16::try_from(s_423_3).unwrap(),
        ));
        // D s_423_5: cast reint s_423_4 -> u8
        let s_423_5: bool = ((s_423_4.value()) != 0);
        // C s_423_6: const #0s : i
        let s_423_6: i128 = 0;
        // C s_423_7: const #0u : u64
        let s_423_7: u64 = 0;
        // D s_423_8: cast zx s_423_5 -> u64
        let s_423_8: u64 = (s_423_5 as u64);
        // C s_423_9: const #1u : u64
        let s_423_9: u64 = 1;
        // D s_423_10: and s_423_8 s_423_9
        let s_423_10: u64 = ((s_423_8) & (s_423_9));
        // D s_423_11: cmp-eq s_423_10 s_423_9
        let s_423_11: bool = ((s_423_10) == (s_423_9));
        // D s_423_12: lsl s_423_8 s_423_6
        let s_423_12: u64 = s_423_8 << s_423_6;
        // D s_423_13: or s_423_7 s_423_12
        let s_423_13: u64 = ((s_423_7) | (s_423_12));
        // D s_423_14: cmpl s_423_12
        let s_423_14: u64 = !s_423_12;
        // D s_423_15: and s_423_7 s_423_14
        let s_423_15: u64 = ((s_423_7) & (s_423_14));
        // D s_423_16: select s_423_11 s_423_13 s_423_15
        let s_423_16: u64 = if s_423_11 { s_423_13 } else { s_423_15 };
        // D s_423_17: cast trunc s_423_16 -> u8
        let s_423_17: bool = ((s_423_16) != 0);
        // D s_423_18: cast zx s_423_17 -> bv
        let s_423_18: Bits = Bits::new(s_423_17 as u128, 1u16);
        // C s_423_19: const #1u : u8
        let s_423_19: bool = true;
        // C s_423_20: cast zx s_423_19 -> bv
        let s_423_20: Bits = Bits::new(s_423_19 as u128, 1u16);
        // D s_423_21: cmp-ne s_423_18 s_423_20
        let s_423_21: bool = ((s_423_18) != (s_423_20));
        // D s_423_22: write-var gs#404927 <= s_423_21
        fn_state.gs_404927 = s_423_21;
        // N s_423_23: jump b424
        return block_424(state, tracer, fn_state);
    }
    fn block_424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_424_0: read-var gs#404927:u8
        let s_424_0: bool = fn_state.gs_404927;
        // N s_424_1: branch s_424_0 b435 b425
        if s_424_0 {
            return block_435(state, tracer, fn_state);
        } else {
            return block_425(state, tracer, fn_state);
        };
    }
    fn block_425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_425_0: const #1s : i
        let s_425_0: i128 = 1;
        // D s_425_1: read-var u#32545:u32
        let s_425_1: u32 = fn_state.u_32545;
        // D s_425_2: cast zx s_425_1 -> bv
        let s_425_2: Bits = Bits::new(s_425_1 as u128, 32u16);
        // C s_425_3: const #1u : u64
        let s_425_3: u64 = 1;
        // D s_425_4: bit-extract s_425_2 s_425_0 s_425_3
        let s_425_4: Bits = (Bits::new(
            ((s_425_2) >> (s_425_0)).value(),
            u16::try_from(s_425_3).unwrap(),
        ));
        // D s_425_5: cast reint s_425_4 -> u8
        let s_425_5: bool = ((s_425_4.value()) != 0);
        // C s_425_6: const #0s : i
        let s_425_6: i128 = 0;
        // C s_425_7: const #0u : u64
        let s_425_7: u64 = 0;
        // D s_425_8: cast zx s_425_5 -> u64
        let s_425_8: u64 = (s_425_5 as u64);
        // C s_425_9: const #1u : u64
        let s_425_9: u64 = 1;
        // D s_425_10: and s_425_8 s_425_9
        let s_425_10: u64 = ((s_425_8) & (s_425_9));
        // D s_425_11: cmp-eq s_425_10 s_425_9
        let s_425_11: bool = ((s_425_10) == (s_425_9));
        // D s_425_12: lsl s_425_8 s_425_6
        let s_425_12: u64 = s_425_8 << s_425_6;
        // D s_425_13: or s_425_7 s_425_12
        let s_425_13: u64 = ((s_425_7) | (s_425_12));
        // D s_425_14: cmpl s_425_12
        let s_425_14: u64 = !s_425_12;
        // D s_425_15: and s_425_7 s_425_14
        let s_425_15: u64 = ((s_425_7) & (s_425_14));
        // D s_425_16: select s_425_11 s_425_13 s_425_15
        let s_425_16: u64 = if s_425_11 { s_425_13 } else { s_425_15 };
        // D s_425_17: cast trunc s_425_16 -> u8
        let s_425_17: bool = ((s_425_16) != 0);
        // D s_425_18: cast zx s_425_17 -> bv
        let s_425_18: Bits = Bits::new(s_425_17 as u128, 1u16);
        // C s_425_19: const #1u : u8
        let s_425_19: bool = true;
        // C s_425_20: cast zx s_425_19 -> bv
        let s_425_20: Bits = Bits::new(s_425_19 as u128, 1u16);
        // D s_425_21: cmp-ne s_425_18 s_425_20
        let s_425_21: bool = ((s_425_18) != (s_425_20));
        // D s_425_22: write-var gs#404930 <= s_425_21
        fn_state.gs_404930 = s_425_21;
        // N s_425_23: jump b426
        return block_426(state, tracer, fn_state);
    }
    fn block_426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_426_0: read-var gs#404930:u8
        let s_426_0: bool = fn_state.gs_404930;
        // N s_426_1: branch s_426_0 b434 b427
        if s_426_0 {
            return block_434(state, tracer, fn_state);
        } else {
            return block_427(state, tracer, fn_state);
        };
    }
    fn block_427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_427_0: const #2s : i
        let s_427_0: i128 = 2;
        // D s_427_1: read-var u#32545:u32
        let s_427_1: u32 = fn_state.u_32545;
        // D s_427_2: cast zx s_427_1 -> bv
        let s_427_2: Bits = Bits::new(s_427_1 as u128, 32u16);
        // C s_427_3: const #1u : u64
        let s_427_3: u64 = 1;
        // D s_427_4: bit-extract s_427_2 s_427_0 s_427_3
        let s_427_4: Bits = (Bits::new(
            ((s_427_2) >> (s_427_0)).value(),
            u16::try_from(s_427_3).unwrap(),
        ));
        // D s_427_5: cast reint s_427_4 -> u8
        let s_427_5: bool = ((s_427_4.value()) != 0);
        // C s_427_6: const #0s : i
        let s_427_6: i128 = 0;
        // C s_427_7: const #0u : u64
        let s_427_7: u64 = 0;
        // D s_427_8: cast zx s_427_5 -> u64
        let s_427_8: u64 = (s_427_5 as u64);
        // C s_427_9: const #1u : u64
        let s_427_9: u64 = 1;
        // D s_427_10: and s_427_8 s_427_9
        let s_427_10: u64 = ((s_427_8) & (s_427_9));
        // D s_427_11: cmp-eq s_427_10 s_427_9
        let s_427_11: bool = ((s_427_10) == (s_427_9));
        // D s_427_12: lsl s_427_8 s_427_6
        let s_427_12: u64 = s_427_8 << s_427_6;
        // D s_427_13: or s_427_7 s_427_12
        let s_427_13: u64 = ((s_427_7) | (s_427_12));
        // D s_427_14: cmpl s_427_12
        let s_427_14: u64 = !s_427_12;
        // D s_427_15: and s_427_7 s_427_14
        let s_427_15: u64 = ((s_427_7) & (s_427_14));
        // D s_427_16: select s_427_11 s_427_13 s_427_15
        let s_427_16: u64 = if s_427_11 { s_427_13 } else { s_427_15 };
        // D s_427_17: cast trunc s_427_16 -> u8
        let s_427_17: bool = ((s_427_16) != 0);
        // D s_427_18: cast zx s_427_17 -> bv
        let s_427_18: Bits = Bits::new(s_427_17 as u128, 1u16);
        // C s_427_19: const #1u : u8
        let s_427_19: bool = true;
        // C s_427_20: cast zx s_427_19 -> bv
        let s_427_20: Bits = Bits::new(s_427_19 as u128, 1u16);
        // D s_427_21: cmp-ne s_427_18 s_427_20
        let s_427_21: bool = ((s_427_18) != (s_427_20));
        // D s_427_22: write-var gs#404933 <= s_427_21
        fn_state.gs_404933 = s_427_21;
        // N s_427_23: jump b428
        return block_428(state, tracer, fn_state);
    }
    fn block_428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_428_0: read-var gs#404933:u8
        let s_428_0: bool = fn_state.gs_404933;
        // N s_428_1: branch s_428_0 b433 b429
        if s_428_0 {
            return block_433(state, tracer, fn_state);
        } else {
            return block_429(state, tracer, fn_state);
        };
    }
    fn block_429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_429_0: const #3s : i
        let s_429_0: i128 = 3;
        // D s_429_1: read-var u#32545:u32
        let s_429_1: u32 = fn_state.u_32545;
        // D s_429_2: cast zx s_429_1 -> bv
        let s_429_2: Bits = Bits::new(s_429_1 as u128, 32u16);
        // C s_429_3: const #1u : u64
        let s_429_3: u64 = 1;
        // D s_429_4: bit-extract s_429_2 s_429_0 s_429_3
        let s_429_4: Bits = (Bits::new(
            ((s_429_2) >> (s_429_0)).value(),
            u16::try_from(s_429_3).unwrap(),
        ));
        // D s_429_5: cast reint s_429_4 -> u8
        let s_429_5: bool = ((s_429_4.value()) != 0);
        // C s_429_6: const #0s : i
        let s_429_6: i128 = 0;
        // C s_429_7: const #0u : u64
        let s_429_7: u64 = 0;
        // D s_429_8: cast zx s_429_5 -> u64
        let s_429_8: u64 = (s_429_5 as u64);
        // C s_429_9: const #1u : u64
        let s_429_9: u64 = 1;
        // D s_429_10: and s_429_8 s_429_9
        let s_429_10: u64 = ((s_429_8) & (s_429_9));
        // D s_429_11: cmp-eq s_429_10 s_429_9
        let s_429_11: bool = ((s_429_10) == (s_429_9));
        // D s_429_12: lsl s_429_8 s_429_6
        let s_429_12: u64 = s_429_8 << s_429_6;
        // D s_429_13: or s_429_7 s_429_12
        let s_429_13: u64 = ((s_429_7) | (s_429_12));
        // D s_429_14: cmpl s_429_12
        let s_429_14: u64 = !s_429_12;
        // D s_429_15: and s_429_7 s_429_14
        let s_429_15: u64 = ((s_429_7) & (s_429_14));
        // D s_429_16: select s_429_11 s_429_13 s_429_15
        let s_429_16: u64 = if s_429_11 { s_429_13 } else { s_429_15 };
        // D s_429_17: cast trunc s_429_16 -> u8
        let s_429_17: bool = ((s_429_16) != 0);
        // D s_429_18: cast zx s_429_17 -> bv
        let s_429_18: Bits = Bits::new(s_429_17 as u128, 1u16);
        // C s_429_19: const #1u : u8
        let s_429_19: bool = true;
        // C s_429_20: cast zx s_429_19 -> bv
        let s_429_20: Bits = Bits::new(s_429_19 as u128, 1u16);
        // D s_429_21: cmp-ne s_429_18 s_429_20
        let s_429_21: bool = ((s_429_18) != (s_429_20));
        // D s_429_22: write-var gs#404936 <= s_429_21
        fn_state.gs_404936 = s_429_21;
        // N s_429_23: jump b430
        return block_430(state, tracer, fn_state);
    }
    fn block_430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_430_0: read-var gs#404936:u8
        let s_430_0: bool = fn_state.gs_404936;
        // N s_430_1: branch s_430_0 b432 b431
        if s_430_0 {
            return block_432(state, tracer, fn_state);
        } else {
            return block_431(state, tracer, fn_state);
        };
    }
    fn block_431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_431_0: read-var u#32546:u8
        let s_431_0: u8 = fn_state.u_32546;
        // D s_431_1: read-var u#32547:u8
        let s_431_1: u8 = fn_state.u_32547;
        // D s_431_2: read-var u#32548:u8
        let s_431_2: u8 = fn_state.u_32548;
        // D s_431_3: call decode_aarch32_instrs_LDREX_A1enc_A_txt(s_431_0, s_431_1, s_431_2)
        let s_431_3: () = decode_aarch32_instrs_LDREX_A1enc_A_txt(
            state,
            tracer,
            s_431_0,
            s_431_1,
            s_431_2,
        );
        // N s_431_4: return
        return;
    }
    fn block_432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_432_0: panic
        panic!("{:?}", ());
        // N s_432_1: return
        return;
    }
    fn block_433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_433_0: const #1u : u8
        let s_433_0: bool = true;
        // D s_433_1: write-var gs#404936 <= s_433_0
        fn_state.gs_404936 = s_433_0;
        // N s_433_2: jump b430
        return block_430(state, tracer, fn_state);
    }
    fn block_434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_434_0: const #1u : u8
        let s_434_0: bool = true;
        // D s_434_1: write-var gs#404933 <= s_434_0
        fn_state.gs_404933 = s_434_0;
        // N s_434_2: jump b428
        return block_428(state, tracer, fn_state);
    }
    fn block_435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_435_0: const #1u : u8
        let s_435_0: bool = true;
        // D s_435_1: write-var gs#404930 <= s_435_0
        fn_state.gs_404930 = s_435_0;
        // N s_435_2: jump b426
        return block_426(state, tracer, fn_state);
    }
    fn block_436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_436_0: const #1u : u8
        let s_436_0: bool = true;
        // D s_436_1: write-var gs#404927 <= s_436_0
        fn_state.gs_404927 = s_436_0;
        // N s_436_2: jump b424
        return block_424(state, tracer, fn_state);
    }
    fn block_437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_437_0: const #1u : u8
        let s_437_0: bool = true;
        // D s_437_1: write-var gs#404924 <= s_437_0
        fn_state.gs_404924 = s_437_0;
        // N s_437_2: jump b422
        return block_422(state, tracer, fn_state);
    }
    fn block_438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_438_0: read-var merge#var.1:struct
        let s_438_0: u32 = fn_state.merge_var._1;
        // D s_438_1: write-var u#32550 <= s_438_0
        fn_state.u_32550 = s_438_0;
        // C s_438_2: const #20s : i
        let s_438_2: i128 = 20;
        // D s_438_3: read-var u#32550:u32
        let s_438_3: u32 = fn_state.u_32550;
        // D s_438_4: cast zx s_438_3 -> bv
        let s_438_4: Bits = Bits::new(s_438_3 as u128, 32u16);
        // C s_438_5: const #1s : i64
        let s_438_5: i64 = 1;
        // C s_438_6: cast zx s_438_5 -> i
        let s_438_6: i128 = (i128::try_from(s_438_5).unwrap());
        // C s_438_7: const #7s : i
        let s_438_7: i128 = 7;
        // C s_438_8: add s_438_7 s_438_6
        let s_438_8: i128 = (s_438_7 + s_438_6);
        // D s_438_9: bit-extract s_438_4 s_438_2 s_438_8
        let s_438_9: Bits = (Bits::new(
            ((s_438_4) >> (s_438_2)).value(),
            u16::try_from(s_438_8).unwrap(),
        ));
        // D s_438_10: cast reint s_438_9 -> u8
        let s_438_10: u8 = (s_438_9.value() as u8);
        // D s_438_11: cast zx s_438_10 -> bv
        let s_438_11: Bits = Bits::new(s_438_10 as u128, 8u16);
        // C s_438_12: const #29u : u8
        let s_438_12: u8 = 29;
        // C s_438_13: cast zx s_438_12 -> bv
        let s_438_13: Bits = Bits::new(s_438_12 as u128, 8u16);
        // D s_438_14: cmp-eq s_438_11 s_438_13
        let s_438_14: bool = ((s_438_11) == (s_438_13));
        // N s_438_15: branch s_438_14 b2784 b439
        if s_438_14 {
            return block_2784(state, tracer, fn_state);
        } else {
            return block_439(state, tracer, fn_state);
        };
    }
    fn block_439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_439_0: const #0u : u8
        let s_439_0: bool = false;
        // D s_439_1: write-var gs#404942 <= s_439_0
        fn_state.gs_404942 = s_439_0;
        // N s_439_2: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_440_0: read-var gs#404942:u8
        let s_440_0: bool = fn_state.gs_404942;
        // N s_440_1: branch s_440_0 b2780 b441
        if s_440_0 {
            return block_2780(state, tracer, fn_state);
        } else {
            return block_441(state, tracer, fn_state);
        };
    }
    fn block_441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_441_0: const #0u : u8
        let s_441_0: bool = false;
        // D s_441_1: write-var gs#404947 <= s_441_0
        fn_state.gs_404947 = s_441_0;
        // N s_441_2: jump b442
        return block_442(state, tracer, fn_state);
    }
    fn block_442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_442_0: read-var gs#404947:u8
        let s_442_0: bool = fn_state.gs_404947;
        // D s_442_1: not s_442_0
        let s_442_1: bool = !s_442_0;
        // N s_442_2: branch s_442_1 b461 b443
        if s_442_1 {
            return block_461(state, tracer, fn_state);
        } else {
            return block_443(state, tracer, fn_state);
        };
    }
    fn block_443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_443_0: const #2942s : i
        let s_443_0: i128 = 2942;
        // C s_443_1: const #14696u : u32
        let s_443_1: u32 = 14696;
        // N s_443_2: write-reg s_443_1 <= s_443_0
        let s_443_2: () = {
            state.write_register::<i128>(s_443_1 as isize, s_443_0);
            tracer.write_register(s_443_1 as isize, s_443_0);
        };
        // C s_443_3: const #28s : i
        let s_443_3: i128 = 28;
        // C s_443_4: const #4s : i
        let s_443_4: i128 = 4;
        // D s_443_5: read-var u#32550:u32
        let s_443_5: u32 = fn_state.u_32550;
        // D s_443_6: cast zx s_443_5 -> bv
        let s_443_6: Bits = Bits::new(s_443_5 as u128, 32u16);
        // D s_443_7: bit-extract s_443_6 s_443_3 s_443_4
        let s_443_7: Bits = (Bits::new(
            ((s_443_6) >> (s_443_3)).value(),
            u16::try_from(s_443_4).unwrap(),
        ));
        // D s_443_8: cast reint s_443_7 -> u8
        let s_443_8: u8 = (s_443_7.value() as u8);
        // D s_443_9: write-var u#32551 <= s_443_8
        fn_state.u_32551 = s_443_8;
        // C s_443_10: const #16s : i
        let s_443_10: i128 = 16;
        // C s_443_11: const #4s : i
        let s_443_11: i128 = 4;
        // D s_443_12: read-var u#32550:u32
        let s_443_12: u32 = fn_state.u_32550;
        // D s_443_13: cast zx s_443_12 -> bv
        let s_443_13: Bits = Bits::new(s_443_12 as u128, 32u16);
        // D s_443_14: bit-extract s_443_13 s_443_10 s_443_11
        let s_443_14: Bits = (Bits::new(
            ((s_443_13) >> (s_443_10)).value(),
            u16::try_from(s_443_11).unwrap(),
        ));
        // D s_443_15: cast reint s_443_14 -> u8
        let s_443_15: u8 = (s_443_14.value() as u8);
        // D s_443_16: write-var u#32552 <= s_443_15
        fn_state.u_32552 = s_443_15;
        // C s_443_17: const #12s : i
        let s_443_17: i128 = 12;
        // C s_443_18: const #4s : i
        let s_443_18: i128 = 4;
        // D s_443_19: read-var u#32550:u32
        let s_443_19: u32 = fn_state.u_32550;
        // D s_443_20: cast zx s_443_19 -> bv
        let s_443_20: Bits = Bits::new(s_443_19 as u128, 32u16);
        // D s_443_21: bit-extract s_443_20 s_443_17 s_443_18
        let s_443_21: Bits = (Bits::new(
            ((s_443_20) >> (s_443_17)).value(),
            u16::try_from(s_443_18).unwrap(),
        ));
        // D s_443_22: cast reint s_443_21 -> u8
        let s_443_22: u8 = (s_443_21.value() as u8);
        // D s_443_23: write-var u#32553 <= s_443_22
        fn_state.u_32553 = s_443_22;
        // C s_443_24: const #8s : i
        let s_443_24: i128 = 8;
        // D s_443_25: read-var u#32550:u32
        let s_443_25: u32 = fn_state.u_32550;
        // D s_443_26: cast zx s_443_25 -> bv
        let s_443_26: Bits = Bits::new(s_443_25 as u128, 32u16);
        // C s_443_27: const #1u : u64
        let s_443_27: u64 = 1;
        // D s_443_28: bit-extract s_443_26 s_443_24 s_443_27
        let s_443_28: Bits = (Bits::new(
            ((s_443_26) >> (s_443_24)).value(),
            u16::try_from(s_443_27).unwrap(),
        ));
        // D s_443_29: cast reint s_443_28 -> u8
        let s_443_29: bool = ((s_443_28.value()) != 0);
        // C s_443_30: const #0s : i
        let s_443_30: i128 = 0;
        // C s_443_31: const #0u : u64
        let s_443_31: u64 = 0;
        // D s_443_32: cast zx s_443_29 -> u64
        let s_443_32: u64 = (s_443_29 as u64);
        // C s_443_33: const #1u : u64
        let s_443_33: u64 = 1;
        // D s_443_34: and s_443_32 s_443_33
        let s_443_34: u64 = ((s_443_32) & (s_443_33));
        // D s_443_35: cmp-eq s_443_34 s_443_33
        let s_443_35: bool = ((s_443_34) == (s_443_33));
        // D s_443_36: lsl s_443_32 s_443_30
        let s_443_36: u64 = s_443_32 << s_443_30;
        // D s_443_37: or s_443_31 s_443_36
        let s_443_37: u64 = ((s_443_31) | (s_443_36));
        // D s_443_38: cmpl s_443_36
        let s_443_38: u64 = !s_443_36;
        // D s_443_39: and s_443_31 s_443_38
        let s_443_39: u64 = ((s_443_31) & (s_443_38));
        // D s_443_40: select s_443_35 s_443_37 s_443_39
        let s_443_40: u64 = if s_443_35 { s_443_37 } else { s_443_39 };
        // D s_443_41: cast trunc s_443_40 -> u8
        let s_443_41: bool = ((s_443_40) != 0);
        // D s_443_42: cast zx s_443_41 -> bv
        let s_443_42: Bits = Bits::new(s_443_41 as u128, 1u16);
        // C s_443_43: const #1u : u8
        let s_443_43: bool = true;
        // C s_443_44: cast zx s_443_43 -> bv
        let s_443_44: Bits = Bits::new(s_443_43 as u128, 1u16);
        // D s_443_45: cmp-ne s_443_42 s_443_44
        let s_443_45: bool = ((s_443_42) != (s_443_44));
        // N s_443_46: branch s_443_45 b460 b444
        if s_443_45 {
            return block_460(state, tracer, fn_state);
        } else {
            return block_444(state, tracer, fn_state);
        };
    }
    fn block_444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_444_0: const #9s : i
        let s_444_0: i128 = 9;
        // D s_444_1: read-var u#32550:u32
        let s_444_1: u32 = fn_state.u_32550;
        // D s_444_2: cast zx s_444_1 -> bv
        let s_444_2: Bits = Bits::new(s_444_1 as u128, 32u16);
        // C s_444_3: const #1u : u64
        let s_444_3: u64 = 1;
        // D s_444_4: bit-extract s_444_2 s_444_0 s_444_3
        let s_444_4: Bits = (Bits::new(
            ((s_444_2) >> (s_444_0)).value(),
            u16::try_from(s_444_3).unwrap(),
        ));
        // D s_444_5: cast reint s_444_4 -> u8
        let s_444_5: bool = ((s_444_4.value()) != 0);
        // C s_444_6: const #0s : i
        let s_444_6: i128 = 0;
        // C s_444_7: const #0u : u64
        let s_444_7: u64 = 0;
        // D s_444_8: cast zx s_444_5 -> u64
        let s_444_8: u64 = (s_444_5 as u64);
        // C s_444_9: const #1u : u64
        let s_444_9: u64 = 1;
        // D s_444_10: and s_444_8 s_444_9
        let s_444_10: u64 = ((s_444_8) & (s_444_9));
        // D s_444_11: cmp-eq s_444_10 s_444_9
        let s_444_11: bool = ((s_444_10) == (s_444_9));
        // D s_444_12: lsl s_444_8 s_444_6
        let s_444_12: u64 = s_444_8 << s_444_6;
        // D s_444_13: or s_444_7 s_444_12
        let s_444_13: u64 = ((s_444_7) | (s_444_12));
        // D s_444_14: cmpl s_444_12
        let s_444_14: u64 = !s_444_12;
        // D s_444_15: and s_444_7 s_444_14
        let s_444_15: u64 = ((s_444_7) & (s_444_14));
        // D s_444_16: select s_444_11 s_444_13 s_444_15
        let s_444_16: u64 = if s_444_11 { s_444_13 } else { s_444_15 };
        // D s_444_17: cast trunc s_444_16 -> u8
        let s_444_17: bool = ((s_444_16) != 0);
        // D s_444_18: cast zx s_444_17 -> bv
        let s_444_18: Bits = Bits::new(s_444_17 as u128, 1u16);
        // C s_444_19: const #1u : u8
        let s_444_19: bool = true;
        // C s_444_20: cast zx s_444_19 -> bv
        let s_444_20: Bits = Bits::new(s_444_19 as u128, 1u16);
        // D s_444_21: cmp-ne s_444_18 s_444_20
        let s_444_21: bool = ((s_444_18) != (s_444_20));
        // D s_444_22: write-var gs#404960 <= s_444_21
        fn_state.gs_404960 = s_444_21;
        // N s_444_23: jump b445
        return block_445(state, tracer, fn_state);
    }
    fn block_445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_445_0: read-var gs#404960:u8
        let s_445_0: bool = fn_state.gs_404960;
        // N s_445_1: branch s_445_0 b459 b446
        if s_445_0 {
            return block_459(state, tracer, fn_state);
        } else {
            return block_446(state, tracer, fn_state);
        };
    }
    fn block_446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_446_0: const #0s : i
        let s_446_0: i128 = 0;
        // D s_446_1: read-var u#32550:u32
        let s_446_1: u32 = fn_state.u_32550;
        // D s_446_2: cast zx s_446_1 -> bv
        let s_446_2: Bits = Bits::new(s_446_1 as u128, 32u16);
        // C s_446_3: const #1u : u64
        let s_446_3: u64 = 1;
        // D s_446_4: bit-extract s_446_2 s_446_0 s_446_3
        let s_446_4: Bits = (Bits::new(
            ((s_446_2) >> (s_446_0)).value(),
            u16::try_from(s_446_3).unwrap(),
        ));
        // D s_446_5: cast reint s_446_4 -> u8
        let s_446_5: bool = ((s_446_4.value()) != 0);
        // C s_446_6: const #0s : i
        let s_446_6: i128 = 0;
        // C s_446_7: const #0u : u64
        let s_446_7: u64 = 0;
        // D s_446_8: cast zx s_446_5 -> u64
        let s_446_8: u64 = (s_446_5 as u64);
        // C s_446_9: const #1u : u64
        let s_446_9: u64 = 1;
        // D s_446_10: and s_446_8 s_446_9
        let s_446_10: u64 = ((s_446_8) & (s_446_9));
        // D s_446_11: cmp-eq s_446_10 s_446_9
        let s_446_11: bool = ((s_446_10) == (s_446_9));
        // D s_446_12: lsl s_446_8 s_446_6
        let s_446_12: u64 = s_446_8 << s_446_6;
        // D s_446_13: or s_446_7 s_446_12
        let s_446_13: u64 = ((s_446_7) | (s_446_12));
        // D s_446_14: cmpl s_446_12
        let s_446_14: u64 = !s_446_12;
        // D s_446_15: and s_446_7 s_446_14
        let s_446_15: u64 = ((s_446_7) & (s_446_14));
        // D s_446_16: select s_446_11 s_446_13 s_446_15
        let s_446_16: u64 = if s_446_11 { s_446_13 } else { s_446_15 };
        // D s_446_17: cast trunc s_446_16 -> u8
        let s_446_17: bool = ((s_446_16) != 0);
        // D s_446_18: cast zx s_446_17 -> bv
        let s_446_18: Bits = Bits::new(s_446_17 as u128, 1u16);
        // C s_446_19: const #1u : u8
        let s_446_19: bool = true;
        // C s_446_20: cast zx s_446_19 -> bv
        let s_446_20: Bits = Bits::new(s_446_19 as u128, 1u16);
        // D s_446_21: cmp-ne s_446_18 s_446_20
        let s_446_21: bool = ((s_446_18) != (s_446_20));
        // D s_446_22: write-var gs#404963 <= s_446_21
        fn_state.gs_404963 = s_446_21;
        // N s_446_23: jump b447
        return block_447(state, tracer, fn_state);
    }
    fn block_447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_447_0: read-var gs#404963:u8
        let s_447_0: bool = fn_state.gs_404963;
        // N s_447_1: branch s_447_0 b458 b448
        if s_447_0 {
            return block_458(state, tracer, fn_state);
        } else {
            return block_448(state, tracer, fn_state);
        };
    }
    fn block_448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_448_0: const #1s : i
        let s_448_0: i128 = 1;
        // D s_448_1: read-var u#32550:u32
        let s_448_1: u32 = fn_state.u_32550;
        // D s_448_2: cast zx s_448_1 -> bv
        let s_448_2: Bits = Bits::new(s_448_1 as u128, 32u16);
        // C s_448_3: const #1u : u64
        let s_448_3: u64 = 1;
        // D s_448_4: bit-extract s_448_2 s_448_0 s_448_3
        let s_448_4: Bits = (Bits::new(
            ((s_448_2) >> (s_448_0)).value(),
            u16::try_from(s_448_3).unwrap(),
        ));
        // D s_448_5: cast reint s_448_4 -> u8
        let s_448_5: bool = ((s_448_4.value()) != 0);
        // C s_448_6: const #0s : i
        let s_448_6: i128 = 0;
        // C s_448_7: const #0u : u64
        let s_448_7: u64 = 0;
        // D s_448_8: cast zx s_448_5 -> u64
        let s_448_8: u64 = (s_448_5 as u64);
        // C s_448_9: const #1u : u64
        let s_448_9: u64 = 1;
        // D s_448_10: and s_448_8 s_448_9
        let s_448_10: u64 = ((s_448_8) & (s_448_9));
        // D s_448_11: cmp-eq s_448_10 s_448_9
        let s_448_11: bool = ((s_448_10) == (s_448_9));
        // D s_448_12: lsl s_448_8 s_448_6
        let s_448_12: u64 = s_448_8 << s_448_6;
        // D s_448_13: or s_448_7 s_448_12
        let s_448_13: u64 = ((s_448_7) | (s_448_12));
        // D s_448_14: cmpl s_448_12
        let s_448_14: u64 = !s_448_12;
        // D s_448_15: and s_448_7 s_448_14
        let s_448_15: u64 = ((s_448_7) & (s_448_14));
        // D s_448_16: select s_448_11 s_448_13 s_448_15
        let s_448_16: u64 = if s_448_11 { s_448_13 } else { s_448_15 };
        // D s_448_17: cast trunc s_448_16 -> u8
        let s_448_17: bool = ((s_448_16) != 0);
        // D s_448_18: cast zx s_448_17 -> bv
        let s_448_18: Bits = Bits::new(s_448_17 as u128, 1u16);
        // C s_448_19: const #1u : u8
        let s_448_19: bool = true;
        // C s_448_20: cast zx s_448_19 -> bv
        let s_448_20: Bits = Bits::new(s_448_19 as u128, 1u16);
        // D s_448_21: cmp-ne s_448_18 s_448_20
        let s_448_21: bool = ((s_448_18) != (s_448_20));
        // D s_448_22: write-var gs#404966 <= s_448_21
        fn_state.gs_404966 = s_448_21;
        // N s_448_23: jump b449
        return block_449(state, tracer, fn_state);
    }
    fn block_449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_449_0: read-var gs#404966:u8
        let s_449_0: bool = fn_state.gs_404966;
        // N s_449_1: branch s_449_0 b457 b450
        if s_449_0 {
            return block_457(state, tracer, fn_state);
        } else {
            return block_450(state, tracer, fn_state);
        };
    }
    fn block_450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_450_0: const #2s : i
        let s_450_0: i128 = 2;
        // D s_450_1: read-var u#32550:u32
        let s_450_1: u32 = fn_state.u_32550;
        // D s_450_2: cast zx s_450_1 -> bv
        let s_450_2: Bits = Bits::new(s_450_1 as u128, 32u16);
        // C s_450_3: const #1u : u64
        let s_450_3: u64 = 1;
        // D s_450_4: bit-extract s_450_2 s_450_0 s_450_3
        let s_450_4: Bits = (Bits::new(
            ((s_450_2) >> (s_450_0)).value(),
            u16::try_from(s_450_3).unwrap(),
        ));
        // D s_450_5: cast reint s_450_4 -> u8
        let s_450_5: bool = ((s_450_4.value()) != 0);
        // C s_450_6: const #0s : i
        let s_450_6: i128 = 0;
        // C s_450_7: const #0u : u64
        let s_450_7: u64 = 0;
        // D s_450_8: cast zx s_450_5 -> u64
        let s_450_8: u64 = (s_450_5 as u64);
        // C s_450_9: const #1u : u64
        let s_450_9: u64 = 1;
        // D s_450_10: and s_450_8 s_450_9
        let s_450_10: u64 = ((s_450_8) & (s_450_9));
        // D s_450_11: cmp-eq s_450_10 s_450_9
        let s_450_11: bool = ((s_450_10) == (s_450_9));
        // D s_450_12: lsl s_450_8 s_450_6
        let s_450_12: u64 = s_450_8 << s_450_6;
        // D s_450_13: or s_450_7 s_450_12
        let s_450_13: u64 = ((s_450_7) | (s_450_12));
        // D s_450_14: cmpl s_450_12
        let s_450_14: u64 = !s_450_12;
        // D s_450_15: and s_450_7 s_450_14
        let s_450_15: u64 = ((s_450_7) & (s_450_14));
        // D s_450_16: select s_450_11 s_450_13 s_450_15
        let s_450_16: u64 = if s_450_11 { s_450_13 } else { s_450_15 };
        // D s_450_17: cast trunc s_450_16 -> u8
        let s_450_17: bool = ((s_450_16) != 0);
        // D s_450_18: cast zx s_450_17 -> bv
        let s_450_18: Bits = Bits::new(s_450_17 as u128, 1u16);
        // C s_450_19: const #1u : u8
        let s_450_19: bool = true;
        // C s_450_20: cast zx s_450_19 -> bv
        let s_450_20: Bits = Bits::new(s_450_19 as u128, 1u16);
        // D s_450_21: cmp-ne s_450_18 s_450_20
        let s_450_21: bool = ((s_450_18) != (s_450_20));
        // D s_450_22: write-var gs#404969 <= s_450_21
        fn_state.gs_404969 = s_450_21;
        // N s_450_23: jump b451
        return block_451(state, tracer, fn_state);
    }
    fn block_451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_451_0: read-var gs#404969:u8
        let s_451_0: bool = fn_state.gs_404969;
        // N s_451_1: branch s_451_0 b456 b452
        if s_451_0 {
            return block_456(state, tracer, fn_state);
        } else {
            return block_452(state, tracer, fn_state);
        };
    }
    fn block_452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_452_0: const #3s : i
        let s_452_0: i128 = 3;
        // D s_452_1: read-var u#32550:u32
        let s_452_1: u32 = fn_state.u_32550;
        // D s_452_2: cast zx s_452_1 -> bv
        let s_452_2: Bits = Bits::new(s_452_1 as u128, 32u16);
        // C s_452_3: const #1u : u64
        let s_452_3: u64 = 1;
        // D s_452_4: bit-extract s_452_2 s_452_0 s_452_3
        let s_452_4: Bits = (Bits::new(
            ((s_452_2) >> (s_452_0)).value(),
            u16::try_from(s_452_3).unwrap(),
        ));
        // D s_452_5: cast reint s_452_4 -> u8
        let s_452_5: bool = ((s_452_4.value()) != 0);
        // C s_452_6: const #0s : i
        let s_452_6: i128 = 0;
        // C s_452_7: const #0u : u64
        let s_452_7: u64 = 0;
        // D s_452_8: cast zx s_452_5 -> u64
        let s_452_8: u64 = (s_452_5 as u64);
        // C s_452_9: const #1u : u64
        let s_452_9: u64 = 1;
        // D s_452_10: and s_452_8 s_452_9
        let s_452_10: u64 = ((s_452_8) & (s_452_9));
        // D s_452_11: cmp-eq s_452_10 s_452_9
        let s_452_11: bool = ((s_452_10) == (s_452_9));
        // D s_452_12: lsl s_452_8 s_452_6
        let s_452_12: u64 = s_452_8 << s_452_6;
        // D s_452_13: or s_452_7 s_452_12
        let s_452_13: u64 = ((s_452_7) | (s_452_12));
        // D s_452_14: cmpl s_452_12
        let s_452_14: u64 = !s_452_12;
        // D s_452_15: and s_452_7 s_452_14
        let s_452_15: u64 = ((s_452_7) & (s_452_14));
        // D s_452_16: select s_452_11 s_452_13 s_452_15
        let s_452_16: u64 = if s_452_11 { s_452_13 } else { s_452_15 };
        // D s_452_17: cast trunc s_452_16 -> u8
        let s_452_17: bool = ((s_452_16) != 0);
        // D s_452_18: cast zx s_452_17 -> bv
        let s_452_18: Bits = Bits::new(s_452_17 as u128, 1u16);
        // C s_452_19: const #1u : u8
        let s_452_19: bool = true;
        // C s_452_20: cast zx s_452_19 -> bv
        let s_452_20: Bits = Bits::new(s_452_19 as u128, 1u16);
        // D s_452_21: cmp-ne s_452_18 s_452_20
        let s_452_21: bool = ((s_452_18) != (s_452_20));
        // D s_452_22: write-var gs#404972 <= s_452_21
        fn_state.gs_404972 = s_452_21;
        // N s_452_23: jump b453
        return block_453(state, tracer, fn_state);
    }
    fn block_453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_453_0: read-var gs#404972:u8
        let s_453_0: bool = fn_state.gs_404972;
        // N s_453_1: branch s_453_0 b455 b454
        if s_453_0 {
            return block_455(state, tracer, fn_state);
        } else {
            return block_454(state, tracer, fn_state);
        };
    }
    fn block_454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_454_0: read-var u#32551:u8
        let s_454_0: u8 = fn_state.u_32551;
        // D s_454_1: read-var u#32552:u8
        let s_454_1: u8 = fn_state.u_32552;
        // D s_454_2: read-var u#32553:u8
        let s_454_2: u8 = fn_state.u_32553;
        // D s_454_3: call decode_aarch32_instrs_LDREXB_A1enc_A_txt(s_454_0, s_454_1, s_454_2)
        let s_454_3: () = decode_aarch32_instrs_LDREXB_A1enc_A_txt(
            state,
            tracer,
            s_454_0,
            s_454_1,
            s_454_2,
        );
        // N s_454_4: return
        return;
    }
    fn block_455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_455_0: panic
        panic!("{:?}", ());
        // N s_455_1: return
        return;
    }
    fn block_456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_456_0: const #1u : u8
        let s_456_0: bool = true;
        // D s_456_1: write-var gs#404972 <= s_456_0
        fn_state.gs_404972 = s_456_0;
        // N s_456_2: jump b453
        return block_453(state, tracer, fn_state);
    }
    fn block_457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_457_0: const #1u : u8
        let s_457_0: bool = true;
        // D s_457_1: write-var gs#404969 <= s_457_0
        fn_state.gs_404969 = s_457_0;
        // N s_457_2: jump b451
        return block_451(state, tracer, fn_state);
    }
    fn block_458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_458_0: const #1u : u8
        let s_458_0: bool = true;
        // D s_458_1: write-var gs#404966 <= s_458_0
        fn_state.gs_404966 = s_458_0;
        // N s_458_2: jump b449
        return block_449(state, tracer, fn_state);
    }
    fn block_459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_459_0: const #1u : u8
        let s_459_0: bool = true;
        // D s_459_1: write-var gs#404963 <= s_459_0
        fn_state.gs_404963 = s_459_0;
        // N s_459_2: jump b447
        return block_447(state, tracer, fn_state);
    }
    fn block_460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_460_0: const #1u : u8
        let s_460_0: bool = true;
        // D s_460_1: write-var gs#404960 <= s_460_0
        fn_state.gs_404960 = s_460_0;
        // N s_460_2: jump b445
        return block_445(state, tracer, fn_state);
    }
    fn block_461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_461_0: read-var merge#var.1:struct
        let s_461_0: u32 = fn_state.merge_var._1;
        // D s_461_1: write-var u#32555 <= s_461_0
        fn_state.u_32555 = s_461_0;
        // C s_461_2: const #20s : i
        let s_461_2: i128 = 20;
        // D s_461_3: read-var u#32555:u32
        let s_461_3: u32 = fn_state.u_32555;
        // D s_461_4: cast zx s_461_3 -> bv
        let s_461_4: Bits = Bits::new(s_461_3 as u128, 32u16);
        // C s_461_5: const #1s : i64
        let s_461_5: i64 = 1;
        // C s_461_6: cast zx s_461_5 -> i
        let s_461_6: i128 = (i128::try_from(s_461_5).unwrap());
        // C s_461_7: const #7s : i
        let s_461_7: i128 = 7;
        // C s_461_8: add s_461_7 s_461_6
        let s_461_8: i128 = (s_461_7 + s_461_6);
        // D s_461_9: bit-extract s_461_4 s_461_2 s_461_8
        let s_461_9: Bits = (Bits::new(
            ((s_461_4) >> (s_461_2)).value(),
            u16::try_from(s_461_8).unwrap(),
        ));
        // D s_461_10: cast reint s_461_9 -> u8
        let s_461_10: u8 = (s_461_9.value() as u8);
        // D s_461_11: cast zx s_461_10 -> bv
        let s_461_11: Bits = Bits::new(s_461_10 as u128, 8u16);
        // C s_461_12: const #27u : u8
        let s_461_12: u8 = 27;
        // C s_461_13: cast zx s_461_12 -> bv
        let s_461_13: Bits = Bits::new(s_461_12 as u128, 8u16);
        // D s_461_14: cmp-eq s_461_11 s_461_13
        let s_461_14: bool = ((s_461_11) == (s_461_13));
        // N s_461_15: branch s_461_14 b2779 b462
        if s_461_14 {
            return block_2779(state, tracer, fn_state);
        } else {
            return block_462(state, tracer, fn_state);
        };
    }
    fn block_462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_462_0: const #0u : u8
        let s_462_0: bool = false;
        // D s_462_1: write-var gs#404978 <= s_462_0
        fn_state.gs_404978 = s_462_0;
        // N s_462_2: jump b463
        return block_463(state, tracer, fn_state);
    }
    fn block_463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_463_0: read-var gs#404978:u8
        let s_463_0: bool = fn_state.gs_404978;
        // N s_463_1: branch s_463_0 b2775 b464
        if s_463_0 {
            return block_2775(state, tracer, fn_state);
        } else {
            return block_464(state, tracer, fn_state);
        };
    }
    fn block_464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_464_0: const #0u : u8
        let s_464_0: bool = false;
        // D s_464_1: write-var gs#404983 <= s_464_0
        fn_state.gs_404983 = s_464_0;
        // N s_464_2: jump b465
        return block_465(state, tracer, fn_state);
    }
    fn block_465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_465_0: read-var gs#404983:u8
        let s_465_0: bool = fn_state.gs_404983;
        // D s_465_1: not s_465_0
        let s_465_1: bool = !s_465_0;
        // N s_465_2: branch s_465_1 b484 b466
        if s_465_1 {
            return block_484(state, tracer, fn_state);
        } else {
            return block_466(state, tracer, fn_state);
        };
    }
    fn block_466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_466_0: const #2944s : i
        let s_466_0: i128 = 2944;
        // C s_466_1: const #14696u : u32
        let s_466_1: u32 = 14696;
        // N s_466_2: write-reg s_466_1 <= s_466_0
        let s_466_2: () = {
            state.write_register::<i128>(s_466_1 as isize, s_466_0);
            tracer.write_register(s_466_1 as isize, s_466_0);
        };
        // C s_466_3: const #28s : i
        let s_466_3: i128 = 28;
        // C s_466_4: const #4s : i
        let s_466_4: i128 = 4;
        // D s_466_5: read-var u#32555:u32
        let s_466_5: u32 = fn_state.u_32555;
        // D s_466_6: cast zx s_466_5 -> bv
        let s_466_6: Bits = Bits::new(s_466_5 as u128, 32u16);
        // D s_466_7: bit-extract s_466_6 s_466_3 s_466_4
        let s_466_7: Bits = (Bits::new(
            ((s_466_6) >> (s_466_3)).value(),
            u16::try_from(s_466_4).unwrap(),
        ));
        // D s_466_8: cast reint s_466_7 -> u8
        let s_466_8: u8 = (s_466_7.value() as u8);
        // D s_466_9: write-var u#32556 <= s_466_8
        fn_state.u_32556 = s_466_8;
        // C s_466_10: const #16s : i
        let s_466_10: i128 = 16;
        // C s_466_11: const #4s : i
        let s_466_11: i128 = 4;
        // D s_466_12: read-var u#32555:u32
        let s_466_12: u32 = fn_state.u_32555;
        // D s_466_13: cast zx s_466_12 -> bv
        let s_466_13: Bits = Bits::new(s_466_12 as u128, 32u16);
        // D s_466_14: bit-extract s_466_13 s_466_10 s_466_11
        let s_466_14: Bits = (Bits::new(
            ((s_466_13) >> (s_466_10)).value(),
            u16::try_from(s_466_11).unwrap(),
        ));
        // D s_466_15: cast reint s_466_14 -> u8
        let s_466_15: u8 = (s_466_14.value() as u8);
        // D s_466_16: write-var u#32557 <= s_466_15
        fn_state.u_32557 = s_466_15;
        // C s_466_17: const #12s : i
        let s_466_17: i128 = 12;
        // C s_466_18: const #4s : i
        let s_466_18: i128 = 4;
        // D s_466_19: read-var u#32555:u32
        let s_466_19: u32 = fn_state.u_32555;
        // D s_466_20: cast zx s_466_19 -> bv
        let s_466_20: Bits = Bits::new(s_466_19 as u128, 32u16);
        // D s_466_21: bit-extract s_466_20 s_466_17 s_466_18
        let s_466_21: Bits = (Bits::new(
            ((s_466_20) >> (s_466_17)).value(),
            u16::try_from(s_466_18).unwrap(),
        ));
        // D s_466_22: cast reint s_466_21 -> u8
        let s_466_22: u8 = (s_466_21.value() as u8);
        // D s_466_23: write-var u#32558 <= s_466_22
        fn_state.u_32558 = s_466_22;
        // C s_466_24: const #8s : i
        let s_466_24: i128 = 8;
        // D s_466_25: read-var u#32555:u32
        let s_466_25: u32 = fn_state.u_32555;
        // D s_466_26: cast zx s_466_25 -> bv
        let s_466_26: Bits = Bits::new(s_466_25 as u128, 32u16);
        // C s_466_27: const #1u : u64
        let s_466_27: u64 = 1;
        // D s_466_28: bit-extract s_466_26 s_466_24 s_466_27
        let s_466_28: Bits = (Bits::new(
            ((s_466_26) >> (s_466_24)).value(),
            u16::try_from(s_466_27).unwrap(),
        ));
        // D s_466_29: cast reint s_466_28 -> u8
        let s_466_29: bool = ((s_466_28.value()) != 0);
        // C s_466_30: const #0s : i
        let s_466_30: i128 = 0;
        // C s_466_31: const #0u : u64
        let s_466_31: u64 = 0;
        // D s_466_32: cast zx s_466_29 -> u64
        let s_466_32: u64 = (s_466_29 as u64);
        // C s_466_33: const #1u : u64
        let s_466_33: u64 = 1;
        // D s_466_34: and s_466_32 s_466_33
        let s_466_34: u64 = ((s_466_32) & (s_466_33));
        // D s_466_35: cmp-eq s_466_34 s_466_33
        let s_466_35: bool = ((s_466_34) == (s_466_33));
        // D s_466_36: lsl s_466_32 s_466_30
        let s_466_36: u64 = s_466_32 << s_466_30;
        // D s_466_37: or s_466_31 s_466_36
        let s_466_37: u64 = ((s_466_31) | (s_466_36));
        // D s_466_38: cmpl s_466_36
        let s_466_38: u64 = !s_466_36;
        // D s_466_39: and s_466_31 s_466_38
        let s_466_39: u64 = ((s_466_31) & (s_466_38));
        // D s_466_40: select s_466_35 s_466_37 s_466_39
        let s_466_40: u64 = if s_466_35 { s_466_37 } else { s_466_39 };
        // D s_466_41: cast trunc s_466_40 -> u8
        let s_466_41: bool = ((s_466_40) != 0);
        // D s_466_42: cast zx s_466_41 -> bv
        let s_466_42: Bits = Bits::new(s_466_41 as u128, 1u16);
        // C s_466_43: const #1u : u8
        let s_466_43: bool = true;
        // C s_466_44: cast zx s_466_43 -> bv
        let s_466_44: Bits = Bits::new(s_466_43 as u128, 1u16);
        // D s_466_45: cmp-ne s_466_42 s_466_44
        let s_466_45: bool = ((s_466_42) != (s_466_44));
        // N s_466_46: branch s_466_45 b483 b467
        if s_466_45 {
            return block_483(state, tracer, fn_state);
        } else {
            return block_467(state, tracer, fn_state);
        };
    }
    fn block_467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_467_0: const #9s : i
        let s_467_0: i128 = 9;
        // D s_467_1: read-var u#32555:u32
        let s_467_1: u32 = fn_state.u_32555;
        // D s_467_2: cast zx s_467_1 -> bv
        let s_467_2: Bits = Bits::new(s_467_1 as u128, 32u16);
        // C s_467_3: const #1u : u64
        let s_467_3: u64 = 1;
        // D s_467_4: bit-extract s_467_2 s_467_0 s_467_3
        let s_467_4: Bits = (Bits::new(
            ((s_467_2) >> (s_467_0)).value(),
            u16::try_from(s_467_3).unwrap(),
        ));
        // D s_467_5: cast reint s_467_4 -> u8
        let s_467_5: bool = ((s_467_4.value()) != 0);
        // C s_467_6: const #0s : i
        let s_467_6: i128 = 0;
        // C s_467_7: const #0u : u64
        let s_467_7: u64 = 0;
        // D s_467_8: cast zx s_467_5 -> u64
        let s_467_8: u64 = (s_467_5 as u64);
        // C s_467_9: const #1u : u64
        let s_467_9: u64 = 1;
        // D s_467_10: and s_467_8 s_467_9
        let s_467_10: u64 = ((s_467_8) & (s_467_9));
        // D s_467_11: cmp-eq s_467_10 s_467_9
        let s_467_11: bool = ((s_467_10) == (s_467_9));
        // D s_467_12: lsl s_467_8 s_467_6
        let s_467_12: u64 = s_467_8 << s_467_6;
        // D s_467_13: or s_467_7 s_467_12
        let s_467_13: u64 = ((s_467_7) | (s_467_12));
        // D s_467_14: cmpl s_467_12
        let s_467_14: u64 = !s_467_12;
        // D s_467_15: and s_467_7 s_467_14
        let s_467_15: u64 = ((s_467_7) & (s_467_14));
        // D s_467_16: select s_467_11 s_467_13 s_467_15
        let s_467_16: u64 = if s_467_11 { s_467_13 } else { s_467_15 };
        // D s_467_17: cast trunc s_467_16 -> u8
        let s_467_17: bool = ((s_467_16) != 0);
        // D s_467_18: cast zx s_467_17 -> bv
        let s_467_18: Bits = Bits::new(s_467_17 as u128, 1u16);
        // C s_467_19: const #1u : u8
        let s_467_19: bool = true;
        // C s_467_20: cast zx s_467_19 -> bv
        let s_467_20: Bits = Bits::new(s_467_19 as u128, 1u16);
        // D s_467_21: cmp-ne s_467_18 s_467_20
        let s_467_21: bool = ((s_467_18) != (s_467_20));
        // D s_467_22: write-var gs#404996 <= s_467_21
        fn_state.gs_404996 = s_467_21;
        // N s_467_23: jump b468
        return block_468(state, tracer, fn_state);
    }
    fn block_468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_468_0: read-var gs#404996:u8
        let s_468_0: bool = fn_state.gs_404996;
        // N s_468_1: branch s_468_0 b482 b469
        if s_468_0 {
            return block_482(state, tracer, fn_state);
        } else {
            return block_469(state, tracer, fn_state);
        };
    }
    fn block_469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_469_0: const #0s : i
        let s_469_0: i128 = 0;
        // D s_469_1: read-var u#32555:u32
        let s_469_1: u32 = fn_state.u_32555;
        // D s_469_2: cast zx s_469_1 -> bv
        let s_469_2: Bits = Bits::new(s_469_1 as u128, 32u16);
        // C s_469_3: const #1u : u64
        let s_469_3: u64 = 1;
        // D s_469_4: bit-extract s_469_2 s_469_0 s_469_3
        let s_469_4: Bits = (Bits::new(
            ((s_469_2) >> (s_469_0)).value(),
            u16::try_from(s_469_3).unwrap(),
        ));
        // D s_469_5: cast reint s_469_4 -> u8
        let s_469_5: bool = ((s_469_4.value()) != 0);
        // C s_469_6: const #0s : i
        let s_469_6: i128 = 0;
        // C s_469_7: const #0u : u64
        let s_469_7: u64 = 0;
        // D s_469_8: cast zx s_469_5 -> u64
        let s_469_8: u64 = (s_469_5 as u64);
        // C s_469_9: const #1u : u64
        let s_469_9: u64 = 1;
        // D s_469_10: and s_469_8 s_469_9
        let s_469_10: u64 = ((s_469_8) & (s_469_9));
        // D s_469_11: cmp-eq s_469_10 s_469_9
        let s_469_11: bool = ((s_469_10) == (s_469_9));
        // D s_469_12: lsl s_469_8 s_469_6
        let s_469_12: u64 = s_469_8 << s_469_6;
        // D s_469_13: or s_469_7 s_469_12
        let s_469_13: u64 = ((s_469_7) | (s_469_12));
        // D s_469_14: cmpl s_469_12
        let s_469_14: u64 = !s_469_12;
        // D s_469_15: and s_469_7 s_469_14
        let s_469_15: u64 = ((s_469_7) & (s_469_14));
        // D s_469_16: select s_469_11 s_469_13 s_469_15
        let s_469_16: u64 = if s_469_11 { s_469_13 } else { s_469_15 };
        // D s_469_17: cast trunc s_469_16 -> u8
        let s_469_17: bool = ((s_469_16) != 0);
        // D s_469_18: cast zx s_469_17 -> bv
        let s_469_18: Bits = Bits::new(s_469_17 as u128, 1u16);
        // C s_469_19: const #1u : u8
        let s_469_19: bool = true;
        // C s_469_20: cast zx s_469_19 -> bv
        let s_469_20: Bits = Bits::new(s_469_19 as u128, 1u16);
        // D s_469_21: cmp-ne s_469_18 s_469_20
        let s_469_21: bool = ((s_469_18) != (s_469_20));
        // D s_469_22: write-var gs#404999 <= s_469_21
        fn_state.gs_404999 = s_469_21;
        // N s_469_23: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_470_0: read-var gs#404999:u8
        let s_470_0: bool = fn_state.gs_404999;
        // N s_470_1: branch s_470_0 b481 b471
        if s_470_0 {
            return block_481(state, tracer, fn_state);
        } else {
            return block_471(state, tracer, fn_state);
        };
    }
    fn block_471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_471_0: const #1s : i
        let s_471_0: i128 = 1;
        // D s_471_1: read-var u#32555:u32
        let s_471_1: u32 = fn_state.u_32555;
        // D s_471_2: cast zx s_471_1 -> bv
        let s_471_2: Bits = Bits::new(s_471_1 as u128, 32u16);
        // C s_471_3: const #1u : u64
        let s_471_3: u64 = 1;
        // D s_471_4: bit-extract s_471_2 s_471_0 s_471_3
        let s_471_4: Bits = (Bits::new(
            ((s_471_2) >> (s_471_0)).value(),
            u16::try_from(s_471_3).unwrap(),
        ));
        // D s_471_5: cast reint s_471_4 -> u8
        let s_471_5: bool = ((s_471_4.value()) != 0);
        // C s_471_6: const #0s : i
        let s_471_6: i128 = 0;
        // C s_471_7: const #0u : u64
        let s_471_7: u64 = 0;
        // D s_471_8: cast zx s_471_5 -> u64
        let s_471_8: u64 = (s_471_5 as u64);
        // C s_471_9: const #1u : u64
        let s_471_9: u64 = 1;
        // D s_471_10: and s_471_8 s_471_9
        let s_471_10: u64 = ((s_471_8) & (s_471_9));
        // D s_471_11: cmp-eq s_471_10 s_471_9
        let s_471_11: bool = ((s_471_10) == (s_471_9));
        // D s_471_12: lsl s_471_8 s_471_6
        let s_471_12: u64 = s_471_8 << s_471_6;
        // D s_471_13: or s_471_7 s_471_12
        let s_471_13: u64 = ((s_471_7) | (s_471_12));
        // D s_471_14: cmpl s_471_12
        let s_471_14: u64 = !s_471_12;
        // D s_471_15: and s_471_7 s_471_14
        let s_471_15: u64 = ((s_471_7) & (s_471_14));
        // D s_471_16: select s_471_11 s_471_13 s_471_15
        let s_471_16: u64 = if s_471_11 { s_471_13 } else { s_471_15 };
        // D s_471_17: cast trunc s_471_16 -> u8
        let s_471_17: bool = ((s_471_16) != 0);
        // D s_471_18: cast zx s_471_17 -> bv
        let s_471_18: Bits = Bits::new(s_471_17 as u128, 1u16);
        // C s_471_19: const #1u : u8
        let s_471_19: bool = true;
        // C s_471_20: cast zx s_471_19 -> bv
        let s_471_20: Bits = Bits::new(s_471_19 as u128, 1u16);
        // D s_471_21: cmp-ne s_471_18 s_471_20
        let s_471_21: bool = ((s_471_18) != (s_471_20));
        // D s_471_22: write-var gs#405002 <= s_471_21
        fn_state.gs_405002 = s_471_21;
        // N s_471_23: jump b472
        return block_472(state, tracer, fn_state);
    }
    fn block_472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_472_0: read-var gs#405002:u8
        let s_472_0: bool = fn_state.gs_405002;
        // N s_472_1: branch s_472_0 b480 b473
        if s_472_0 {
            return block_480(state, tracer, fn_state);
        } else {
            return block_473(state, tracer, fn_state);
        };
    }
    fn block_473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_473_0: const #2s : i
        let s_473_0: i128 = 2;
        // D s_473_1: read-var u#32555:u32
        let s_473_1: u32 = fn_state.u_32555;
        // D s_473_2: cast zx s_473_1 -> bv
        let s_473_2: Bits = Bits::new(s_473_1 as u128, 32u16);
        // C s_473_3: const #1u : u64
        let s_473_3: u64 = 1;
        // D s_473_4: bit-extract s_473_2 s_473_0 s_473_3
        let s_473_4: Bits = (Bits::new(
            ((s_473_2) >> (s_473_0)).value(),
            u16::try_from(s_473_3).unwrap(),
        ));
        // D s_473_5: cast reint s_473_4 -> u8
        let s_473_5: bool = ((s_473_4.value()) != 0);
        // C s_473_6: const #0s : i
        let s_473_6: i128 = 0;
        // C s_473_7: const #0u : u64
        let s_473_7: u64 = 0;
        // D s_473_8: cast zx s_473_5 -> u64
        let s_473_8: u64 = (s_473_5 as u64);
        // C s_473_9: const #1u : u64
        let s_473_9: u64 = 1;
        // D s_473_10: and s_473_8 s_473_9
        let s_473_10: u64 = ((s_473_8) & (s_473_9));
        // D s_473_11: cmp-eq s_473_10 s_473_9
        let s_473_11: bool = ((s_473_10) == (s_473_9));
        // D s_473_12: lsl s_473_8 s_473_6
        let s_473_12: u64 = s_473_8 << s_473_6;
        // D s_473_13: or s_473_7 s_473_12
        let s_473_13: u64 = ((s_473_7) | (s_473_12));
        // D s_473_14: cmpl s_473_12
        let s_473_14: u64 = !s_473_12;
        // D s_473_15: and s_473_7 s_473_14
        let s_473_15: u64 = ((s_473_7) & (s_473_14));
        // D s_473_16: select s_473_11 s_473_13 s_473_15
        let s_473_16: u64 = if s_473_11 { s_473_13 } else { s_473_15 };
        // D s_473_17: cast trunc s_473_16 -> u8
        let s_473_17: bool = ((s_473_16) != 0);
        // D s_473_18: cast zx s_473_17 -> bv
        let s_473_18: Bits = Bits::new(s_473_17 as u128, 1u16);
        // C s_473_19: const #1u : u8
        let s_473_19: bool = true;
        // C s_473_20: cast zx s_473_19 -> bv
        let s_473_20: Bits = Bits::new(s_473_19 as u128, 1u16);
        // D s_473_21: cmp-ne s_473_18 s_473_20
        let s_473_21: bool = ((s_473_18) != (s_473_20));
        // D s_473_22: write-var gs#405005 <= s_473_21
        fn_state.gs_405005 = s_473_21;
        // N s_473_23: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_474_0: read-var gs#405005:u8
        let s_474_0: bool = fn_state.gs_405005;
        // N s_474_1: branch s_474_0 b479 b475
        if s_474_0 {
            return block_479(state, tracer, fn_state);
        } else {
            return block_475(state, tracer, fn_state);
        };
    }
    fn block_475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_475_0: const #3s : i
        let s_475_0: i128 = 3;
        // D s_475_1: read-var u#32555:u32
        let s_475_1: u32 = fn_state.u_32555;
        // D s_475_2: cast zx s_475_1 -> bv
        let s_475_2: Bits = Bits::new(s_475_1 as u128, 32u16);
        // C s_475_3: const #1u : u64
        let s_475_3: u64 = 1;
        // D s_475_4: bit-extract s_475_2 s_475_0 s_475_3
        let s_475_4: Bits = (Bits::new(
            ((s_475_2) >> (s_475_0)).value(),
            u16::try_from(s_475_3).unwrap(),
        ));
        // D s_475_5: cast reint s_475_4 -> u8
        let s_475_5: bool = ((s_475_4.value()) != 0);
        // C s_475_6: const #0s : i
        let s_475_6: i128 = 0;
        // C s_475_7: const #0u : u64
        let s_475_7: u64 = 0;
        // D s_475_8: cast zx s_475_5 -> u64
        let s_475_8: u64 = (s_475_5 as u64);
        // C s_475_9: const #1u : u64
        let s_475_9: u64 = 1;
        // D s_475_10: and s_475_8 s_475_9
        let s_475_10: u64 = ((s_475_8) & (s_475_9));
        // D s_475_11: cmp-eq s_475_10 s_475_9
        let s_475_11: bool = ((s_475_10) == (s_475_9));
        // D s_475_12: lsl s_475_8 s_475_6
        let s_475_12: u64 = s_475_8 << s_475_6;
        // D s_475_13: or s_475_7 s_475_12
        let s_475_13: u64 = ((s_475_7) | (s_475_12));
        // D s_475_14: cmpl s_475_12
        let s_475_14: u64 = !s_475_12;
        // D s_475_15: and s_475_7 s_475_14
        let s_475_15: u64 = ((s_475_7) & (s_475_14));
        // D s_475_16: select s_475_11 s_475_13 s_475_15
        let s_475_16: u64 = if s_475_11 { s_475_13 } else { s_475_15 };
        // D s_475_17: cast trunc s_475_16 -> u8
        let s_475_17: bool = ((s_475_16) != 0);
        // D s_475_18: cast zx s_475_17 -> bv
        let s_475_18: Bits = Bits::new(s_475_17 as u128, 1u16);
        // C s_475_19: const #1u : u8
        let s_475_19: bool = true;
        // C s_475_20: cast zx s_475_19 -> bv
        let s_475_20: Bits = Bits::new(s_475_19 as u128, 1u16);
        // D s_475_21: cmp-ne s_475_18 s_475_20
        let s_475_21: bool = ((s_475_18) != (s_475_20));
        // D s_475_22: write-var gs#405008 <= s_475_21
        fn_state.gs_405008 = s_475_21;
        // N s_475_23: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_476_0: read-var gs#405008:u8
        let s_476_0: bool = fn_state.gs_405008;
        // N s_476_1: branch s_476_0 b478 b477
        if s_476_0 {
            return block_478(state, tracer, fn_state);
        } else {
            return block_477(state, tracer, fn_state);
        };
    }
    fn block_477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_477_0: read-var u#32556:u8
        let s_477_0: u8 = fn_state.u_32556;
        // D s_477_1: read-var u#32557:u8
        let s_477_1: u8 = fn_state.u_32557;
        // D s_477_2: read-var u#32558:u8
        let s_477_2: u8 = fn_state.u_32558;
        // D s_477_3: call decode_aarch32_instrs_LDREXD_A1enc_A_txt(s_477_0, s_477_1, s_477_2)
        let s_477_3: () = decode_aarch32_instrs_LDREXD_A1enc_A_txt(
            state,
            tracer,
            s_477_0,
            s_477_1,
            s_477_2,
        );
        // N s_477_4: return
        return;
    }
    fn block_478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_478_0: panic
        panic!("{:?}", ());
        // N s_478_1: return
        return;
    }
    fn block_479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_479_0: const #1u : u8
        let s_479_0: bool = true;
        // D s_479_1: write-var gs#405008 <= s_479_0
        fn_state.gs_405008 = s_479_0;
        // N s_479_2: jump b476
        return block_476(state, tracer, fn_state);
    }
    fn block_480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_480_0: const #1u : u8
        let s_480_0: bool = true;
        // D s_480_1: write-var gs#405005 <= s_480_0
        fn_state.gs_405005 = s_480_0;
        // N s_480_2: jump b474
        return block_474(state, tracer, fn_state);
    }
    fn block_481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_481_0: const #1u : u8
        let s_481_0: bool = true;
        // D s_481_1: write-var gs#405002 <= s_481_0
        fn_state.gs_405002 = s_481_0;
        // N s_481_2: jump b472
        return block_472(state, tracer, fn_state);
    }
    fn block_482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_482_0: const #1u : u8
        let s_482_0: bool = true;
        // D s_482_1: write-var gs#404999 <= s_482_0
        fn_state.gs_404999 = s_482_0;
        // N s_482_2: jump b470
        return block_470(state, tracer, fn_state);
    }
    fn block_483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_483_0: const #1u : u8
        let s_483_0: bool = true;
        // D s_483_1: write-var gs#404996 <= s_483_0
        fn_state.gs_404996 = s_483_0;
        // N s_483_2: jump b468
        return block_468(state, tracer, fn_state);
    }
    fn block_484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_484_0: read-var merge#var.1:struct
        let s_484_0: u32 = fn_state.merge_var._1;
        // D s_484_1: write-var u#32560 <= s_484_0
        fn_state.u_32560 = s_484_0;
        // C s_484_2: const #20s : i
        let s_484_2: i128 = 20;
        // D s_484_3: read-var u#32560:u32
        let s_484_3: u32 = fn_state.u_32560;
        // D s_484_4: cast zx s_484_3 -> bv
        let s_484_4: Bits = Bits::new(s_484_3 as u128, 32u16);
        // C s_484_5: const #1s : i64
        let s_484_5: i64 = 1;
        // C s_484_6: cast zx s_484_5 -> i
        let s_484_6: i128 = (i128::try_from(s_484_5).unwrap());
        // C s_484_7: const #7s : i
        let s_484_7: i128 = 7;
        // C s_484_8: add s_484_7 s_484_6
        let s_484_8: i128 = (s_484_7 + s_484_6);
        // D s_484_9: bit-extract s_484_4 s_484_2 s_484_8
        let s_484_9: Bits = (Bits::new(
            ((s_484_4) >> (s_484_2)).value(),
            u16::try_from(s_484_8).unwrap(),
        ));
        // D s_484_10: cast reint s_484_9 -> u8
        let s_484_10: u8 = (s_484_9.value() as u8);
        // D s_484_11: cast zx s_484_10 -> bv
        let s_484_11: Bits = Bits::new(s_484_10 as u128, 8u16);
        // C s_484_12: const #31u : u8
        let s_484_12: u8 = 31;
        // C s_484_13: cast zx s_484_12 -> bv
        let s_484_13: Bits = Bits::new(s_484_12 as u128, 8u16);
        // D s_484_14: cmp-eq s_484_11 s_484_13
        let s_484_14: bool = ((s_484_11) == (s_484_13));
        // N s_484_15: branch s_484_14 b2774 b485
        if s_484_14 {
            return block_2774(state, tracer, fn_state);
        } else {
            return block_485(state, tracer, fn_state);
        };
    }
    fn block_485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_485_0: const #0u : u8
        let s_485_0: bool = false;
        // D s_485_1: write-var gs#405014 <= s_485_0
        fn_state.gs_405014 = s_485_0;
        // N s_485_2: jump b486
        return block_486(state, tracer, fn_state);
    }
    fn block_486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_486_0: read-var gs#405014:u8
        let s_486_0: bool = fn_state.gs_405014;
        // N s_486_1: branch s_486_0 b2770 b487
        if s_486_0 {
            return block_2770(state, tracer, fn_state);
        } else {
            return block_487(state, tracer, fn_state);
        };
    }
    fn block_487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_487_0: const #0u : u8
        let s_487_0: bool = false;
        // D s_487_1: write-var gs#405019 <= s_487_0
        fn_state.gs_405019 = s_487_0;
        // N s_487_2: jump b488
        return block_488(state, tracer, fn_state);
    }
    fn block_488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_488_0: read-var gs#405019:u8
        let s_488_0: bool = fn_state.gs_405019;
        // D s_488_1: not s_488_0
        let s_488_1: bool = !s_488_0;
        // N s_488_2: branch s_488_1 b507 b489
        if s_488_1 {
            return block_507(state, tracer, fn_state);
        } else {
            return block_489(state, tracer, fn_state);
        };
    }
    fn block_489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_489_0: const #2946s : i
        let s_489_0: i128 = 2946;
        // C s_489_1: const #14696u : u32
        let s_489_1: u32 = 14696;
        // N s_489_2: write-reg s_489_1 <= s_489_0
        let s_489_2: () = {
            state.write_register::<i128>(s_489_1 as isize, s_489_0);
            tracer.write_register(s_489_1 as isize, s_489_0);
        };
        // C s_489_3: const #28s : i
        let s_489_3: i128 = 28;
        // C s_489_4: const #4s : i
        let s_489_4: i128 = 4;
        // D s_489_5: read-var u#32560:u32
        let s_489_5: u32 = fn_state.u_32560;
        // D s_489_6: cast zx s_489_5 -> bv
        let s_489_6: Bits = Bits::new(s_489_5 as u128, 32u16);
        // D s_489_7: bit-extract s_489_6 s_489_3 s_489_4
        let s_489_7: Bits = (Bits::new(
            ((s_489_6) >> (s_489_3)).value(),
            u16::try_from(s_489_4).unwrap(),
        ));
        // D s_489_8: cast reint s_489_7 -> u8
        let s_489_8: u8 = (s_489_7.value() as u8);
        // D s_489_9: write-var u#32561 <= s_489_8
        fn_state.u_32561 = s_489_8;
        // C s_489_10: const #16s : i
        let s_489_10: i128 = 16;
        // C s_489_11: const #4s : i
        let s_489_11: i128 = 4;
        // D s_489_12: read-var u#32560:u32
        let s_489_12: u32 = fn_state.u_32560;
        // D s_489_13: cast zx s_489_12 -> bv
        let s_489_13: Bits = Bits::new(s_489_12 as u128, 32u16);
        // D s_489_14: bit-extract s_489_13 s_489_10 s_489_11
        let s_489_14: Bits = (Bits::new(
            ((s_489_13) >> (s_489_10)).value(),
            u16::try_from(s_489_11).unwrap(),
        ));
        // D s_489_15: cast reint s_489_14 -> u8
        let s_489_15: u8 = (s_489_14.value() as u8);
        // D s_489_16: write-var u#32562 <= s_489_15
        fn_state.u_32562 = s_489_15;
        // C s_489_17: const #12s : i
        let s_489_17: i128 = 12;
        // C s_489_18: const #4s : i
        let s_489_18: i128 = 4;
        // D s_489_19: read-var u#32560:u32
        let s_489_19: u32 = fn_state.u_32560;
        // D s_489_20: cast zx s_489_19 -> bv
        let s_489_20: Bits = Bits::new(s_489_19 as u128, 32u16);
        // D s_489_21: bit-extract s_489_20 s_489_17 s_489_18
        let s_489_21: Bits = (Bits::new(
            ((s_489_20) >> (s_489_17)).value(),
            u16::try_from(s_489_18).unwrap(),
        ));
        // D s_489_22: cast reint s_489_21 -> u8
        let s_489_22: u8 = (s_489_21.value() as u8);
        // D s_489_23: write-var u#32563 <= s_489_22
        fn_state.u_32563 = s_489_22;
        // C s_489_24: const #8s : i
        let s_489_24: i128 = 8;
        // D s_489_25: read-var u#32560:u32
        let s_489_25: u32 = fn_state.u_32560;
        // D s_489_26: cast zx s_489_25 -> bv
        let s_489_26: Bits = Bits::new(s_489_25 as u128, 32u16);
        // C s_489_27: const #1u : u64
        let s_489_27: u64 = 1;
        // D s_489_28: bit-extract s_489_26 s_489_24 s_489_27
        let s_489_28: Bits = (Bits::new(
            ((s_489_26) >> (s_489_24)).value(),
            u16::try_from(s_489_27).unwrap(),
        ));
        // D s_489_29: cast reint s_489_28 -> u8
        let s_489_29: bool = ((s_489_28.value()) != 0);
        // C s_489_30: const #0s : i
        let s_489_30: i128 = 0;
        // C s_489_31: const #0u : u64
        let s_489_31: u64 = 0;
        // D s_489_32: cast zx s_489_29 -> u64
        let s_489_32: u64 = (s_489_29 as u64);
        // C s_489_33: const #1u : u64
        let s_489_33: u64 = 1;
        // D s_489_34: and s_489_32 s_489_33
        let s_489_34: u64 = ((s_489_32) & (s_489_33));
        // D s_489_35: cmp-eq s_489_34 s_489_33
        let s_489_35: bool = ((s_489_34) == (s_489_33));
        // D s_489_36: lsl s_489_32 s_489_30
        let s_489_36: u64 = s_489_32 << s_489_30;
        // D s_489_37: or s_489_31 s_489_36
        let s_489_37: u64 = ((s_489_31) | (s_489_36));
        // D s_489_38: cmpl s_489_36
        let s_489_38: u64 = !s_489_36;
        // D s_489_39: and s_489_31 s_489_38
        let s_489_39: u64 = ((s_489_31) & (s_489_38));
        // D s_489_40: select s_489_35 s_489_37 s_489_39
        let s_489_40: u64 = if s_489_35 { s_489_37 } else { s_489_39 };
        // D s_489_41: cast trunc s_489_40 -> u8
        let s_489_41: bool = ((s_489_40) != 0);
        // D s_489_42: cast zx s_489_41 -> bv
        let s_489_42: Bits = Bits::new(s_489_41 as u128, 1u16);
        // C s_489_43: const #1u : u8
        let s_489_43: bool = true;
        // C s_489_44: cast zx s_489_43 -> bv
        let s_489_44: Bits = Bits::new(s_489_43 as u128, 1u16);
        // D s_489_45: cmp-ne s_489_42 s_489_44
        let s_489_45: bool = ((s_489_42) != (s_489_44));
        // N s_489_46: branch s_489_45 b506 b490
        if s_489_45 {
            return block_506(state, tracer, fn_state);
        } else {
            return block_490(state, tracer, fn_state);
        };
    }
    fn block_490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_490_0: const #9s : i
        let s_490_0: i128 = 9;
        // D s_490_1: read-var u#32560:u32
        let s_490_1: u32 = fn_state.u_32560;
        // D s_490_2: cast zx s_490_1 -> bv
        let s_490_2: Bits = Bits::new(s_490_1 as u128, 32u16);
        // C s_490_3: const #1u : u64
        let s_490_3: u64 = 1;
        // D s_490_4: bit-extract s_490_2 s_490_0 s_490_3
        let s_490_4: Bits = (Bits::new(
            ((s_490_2) >> (s_490_0)).value(),
            u16::try_from(s_490_3).unwrap(),
        ));
        // D s_490_5: cast reint s_490_4 -> u8
        let s_490_5: bool = ((s_490_4.value()) != 0);
        // C s_490_6: const #0s : i
        let s_490_6: i128 = 0;
        // C s_490_7: const #0u : u64
        let s_490_7: u64 = 0;
        // D s_490_8: cast zx s_490_5 -> u64
        let s_490_8: u64 = (s_490_5 as u64);
        // C s_490_9: const #1u : u64
        let s_490_9: u64 = 1;
        // D s_490_10: and s_490_8 s_490_9
        let s_490_10: u64 = ((s_490_8) & (s_490_9));
        // D s_490_11: cmp-eq s_490_10 s_490_9
        let s_490_11: bool = ((s_490_10) == (s_490_9));
        // D s_490_12: lsl s_490_8 s_490_6
        let s_490_12: u64 = s_490_8 << s_490_6;
        // D s_490_13: or s_490_7 s_490_12
        let s_490_13: u64 = ((s_490_7) | (s_490_12));
        // D s_490_14: cmpl s_490_12
        let s_490_14: u64 = !s_490_12;
        // D s_490_15: and s_490_7 s_490_14
        let s_490_15: u64 = ((s_490_7) & (s_490_14));
        // D s_490_16: select s_490_11 s_490_13 s_490_15
        let s_490_16: u64 = if s_490_11 { s_490_13 } else { s_490_15 };
        // D s_490_17: cast trunc s_490_16 -> u8
        let s_490_17: bool = ((s_490_16) != 0);
        // D s_490_18: cast zx s_490_17 -> bv
        let s_490_18: Bits = Bits::new(s_490_17 as u128, 1u16);
        // C s_490_19: const #1u : u8
        let s_490_19: bool = true;
        // C s_490_20: cast zx s_490_19 -> bv
        let s_490_20: Bits = Bits::new(s_490_19 as u128, 1u16);
        // D s_490_21: cmp-ne s_490_18 s_490_20
        let s_490_21: bool = ((s_490_18) != (s_490_20));
        // D s_490_22: write-var gs#405032 <= s_490_21
        fn_state.gs_405032 = s_490_21;
        // N s_490_23: jump b491
        return block_491(state, tracer, fn_state);
    }
    fn block_491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_491_0: read-var gs#405032:u8
        let s_491_0: bool = fn_state.gs_405032;
        // N s_491_1: branch s_491_0 b505 b492
        if s_491_0 {
            return block_505(state, tracer, fn_state);
        } else {
            return block_492(state, tracer, fn_state);
        };
    }
    fn block_492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_492_0: const #0s : i
        let s_492_0: i128 = 0;
        // D s_492_1: read-var u#32560:u32
        let s_492_1: u32 = fn_state.u_32560;
        // D s_492_2: cast zx s_492_1 -> bv
        let s_492_2: Bits = Bits::new(s_492_1 as u128, 32u16);
        // C s_492_3: const #1u : u64
        let s_492_3: u64 = 1;
        // D s_492_4: bit-extract s_492_2 s_492_0 s_492_3
        let s_492_4: Bits = (Bits::new(
            ((s_492_2) >> (s_492_0)).value(),
            u16::try_from(s_492_3).unwrap(),
        ));
        // D s_492_5: cast reint s_492_4 -> u8
        let s_492_5: bool = ((s_492_4.value()) != 0);
        // C s_492_6: const #0s : i
        let s_492_6: i128 = 0;
        // C s_492_7: const #0u : u64
        let s_492_7: u64 = 0;
        // D s_492_8: cast zx s_492_5 -> u64
        let s_492_8: u64 = (s_492_5 as u64);
        // C s_492_9: const #1u : u64
        let s_492_9: u64 = 1;
        // D s_492_10: and s_492_8 s_492_9
        let s_492_10: u64 = ((s_492_8) & (s_492_9));
        // D s_492_11: cmp-eq s_492_10 s_492_9
        let s_492_11: bool = ((s_492_10) == (s_492_9));
        // D s_492_12: lsl s_492_8 s_492_6
        let s_492_12: u64 = s_492_8 << s_492_6;
        // D s_492_13: or s_492_7 s_492_12
        let s_492_13: u64 = ((s_492_7) | (s_492_12));
        // D s_492_14: cmpl s_492_12
        let s_492_14: u64 = !s_492_12;
        // D s_492_15: and s_492_7 s_492_14
        let s_492_15: u64 = ((s_492_7) & (s_492_14));
        // D s_492_16: select s_492_11 s_492_13 s_492_15
        let s_492_16: u64 = if s_492_11 { s_492_13 } else { s_492_15 };
        // D s_492_17: cast trunc s_492_16 -> u8
        let s_492_17: bool = ((s_492_16) != 0);
        // D s_492_18: cast zx s_492_17 -> bv
        let s_492_18: Bits = Bits::new(s_492_17 as u128, 1u16);
        // C s_492_19: const #1u : u8
        let s_492_19: bool = true;
        // C s_492_20: cast zx s_492_19 -> bv
        let s_492_20: Bits = Bits::new(s_492_19 as u128, 1u16);
        // D s_492_21: cmp-ne s_492_18 s_492_20
        let s_492_21: bool = ((s_492_18) != (s_492_20));
        // D s_492_22: write-var gs#405035 <= s_492_21
        fn_state.gs_405035 = s_492_21;
        // N s_492_23: jump b493
        return block_493(state, tracer, fn_state);
    }
    fn block_493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_493_0: read-var gs#405035:u8
        let s_493_0: bool = fn_state.gs_405035;
        // N s_493_1: branch s_493_0 b504 b494
        if s_493_0 {
            return block_504(state, tracer, fn_state);
        } else {
            return block_494(state, tracer, fn_state);
        };
    }
    fn block_494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_494_0: const #1s : i
        let s_494_0: i128 = 1;
        // D s_494_1: read-var u#32560:u32
        let s_494_1: u32 = fn_state.u_32560;
        // D s_494_2: cast zx s_494_1 -> bv
        let s_494_2: Bits = Bits::new(s_494_1 as u128, 32u16);
        // C s_494_3: const #1u : u64
        let s_494_3: u64 = 1;
        // D s_494_4: bit-extract s_494_2 s_494_0 s_494_3
        let s_494_4: Bits = (Bits::new(
            ((s_494_2) >> (s_494_0)).value(),
            u16::try_from(s_494_3).unwrap(),
        ));
        // D s_494_5: cast reint s_494_4 -> u8
        let s_494_5: bool = ((s_494_4.value()) != 0);
        // C s_494_6: const #0s : i
        let s_494_6: i128 = 0;
        // C s_494_7: const #0u : u64
        let s_494_7: u64 = 0;
        // D s_494_8: cast zx s_494_5 -> u64
        let s_494_8: u64 = (s_494_5 as u64);
        // C s_494_9: const #1u : u64
        let s_494_9: u64 = 1;
        // D s_494_10: and s_494_8 s_494_9
        let s_494_10: u64 = ((s_494_8) & (s_494_9));
        // D s_494_11: cmp-eq s_494_10 s_494_9
        let s_494_11: bool = ((s_494_10) == (s_494_9));
        // D s_494_12: lsl s_494_8 s_494_6
        let s_494_12: u64 = s_494_8 << s_494_6;
        // D s_494_13: or s_494_7 s_494_12
        let s_494_13: u64 = ((s_494_7) | (s_494_12));
        // D s_494_14: cmpl s_494_12
        let s_494_14: u64 = !s_494_12;
        // D s_494_15: and s_494_7 s_494_14
        let s_494_15: u64 = ((s_494_7) & (s_494_14));
        // D s_494_16: select s_494_11 s_494_13 s_494_15
        let s_494_16: u64 = if s_494_11 { s_494_13 } else { s_494_15 };
        // D s_494_17: cast trunc s_494_16 -> u8
        let s_494_17: bool = ((s_494_16) != 0);
        // D s_494_18: cast zx s_494_17 -> bv
        let s_494_18: Bits = Bits::new(s_494_17 as u128, 1u16);
        // C s_494_19: const #1u : u8
        let s_494_19: bool = true;
        // C s_494_20: cast zx s_494_19 -> bv
        let s_494_20: Bits = Bits::new(s_494_19 as u128, 1u16);
        // D s_494_21: cmp-ne s_494_18 s_494_20
        let s_494_21: bool = ((s_494_18) != (s_494_20));
        // D s_494_22: write-var gs#405038 <= s_494_21
        fn_state.gs_405038 = s_494_21;
        // N s_494_23: jump b495
        return block_495(state, tracer, fn_state);
    }
    fn block_495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_495_0: read-var gs#405038:u8
        let s_495_0: bool = fn_state.gs_405038;
        // N s_495_1: branch s_495_0 b503 b496
        if s_495_0 {
            return block_503(state, tracer, fn_state);
        } else {
            return block_496(state, tracer, fn_state);
        };
    }
    fn block_496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_496_0: const #2s : i
        let s_496_0: i128 = 2;
        // D s_496_1: read-var u#32560:u32
        let s_496_1: u32 = fn_state.u_32560;
        // D s_496_2: cast zx s_496_1 -> bv
        let s_496_2: Bits = Bits::new(s_496_1 as u128, 32u16);
        // C s_496_3: const #1u : u64
        let s_496_3: u64 = 1;
        // D s_496_4: bit-extract s_496_2 s_496_0 s_496_3
        let s_496_4: Bits = (Bits::new(
            ((s_496_2) >> (s_496_0)).value(),
            u16::try_from(s_496_3).unwrap(),
        ));
        // D s_496_5: cast reint s_496_4 -> u8
        let s_496_5: bool = ((s_496_4.value()) != 0);
        // C s_496_6: const #0s : i
        let s_496_6: i128 = 0;
        // C s_496_7: const #0u : u64
        let s_496_7: u64 = 0;
        // D s_496_8: cast zx s_496_5 -> u64
        let s_496_8: u64 = (s_496_5 as u64);
        // C s_496_9: const #1u : u64
        let s_496_9: u64 = 1;
        // D s_496_10: and s_496_8 s_496_9
        let s_496_10: u64 = ((s_496_8) & (s_496_9));
        // D s_496_11: cmp-eq s_496_10 s_496_9
        let s_496_11: bool = ((s_496_10) == (s_496_9));
        // D s_496_12: lsl s_496_8 s_496_6
        let s_496_12: u64 = s_496_8 << s_496_6;
        // D s_496_13: or s_496_7 s_496_12
        let s_496_13: u64 = ((s_496_7) | (s_496_12));
        // D s_496_14: cmpl s_496_12
        let s_496_14: u64 = !s_496_12;
        // D s_496_15: and s_496_7 s_496_14
        let s_496_15: u64 = ((s_496_7) & (s_496_14));
        // D s_496_16: select s_496_11 s_496_13 s_496_15
        let s_496_16: u64 = if s_496_11 { s_496_13 } else { s_496_15 };
        // D s_496_17: cast trunc s_496_16 -> u8
        let s_496_17: bool = ((s_496_16) != 0);
        // D s_496_18: cast zx s_496_17 -> bv
        let s_496_18: Bits = Bits::new(s_496_17 as u128, 1u16);
        // C s_496_19: const #1u : u8
        let s_496_19: bool = true;
        // C s_496_20: cast zx s_496_19 -> bv
        let s_496_20: Bits = Bits::new(s_496_19 as u128, 1u16);
        // D s_496_21: cmp-ne s_496_18 s_496_20
        let s_496_21: bool = ((s_496_18) != (s_496_20));
        // D s_496_22: write-var gs#405041 <= s_496_21
        fn_state.gs_405041 = s_496_21;
        // N s_496_23: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_497_0: read-var gs#405041:u8
        let s_497_0: bool = fn_state.gs_405041;
        // N s_497_1: branch s_497_0 b502 b498
        if s_497_0 {
            return block_502(state, tracer, fn_state);
        } else {
            return block_498(state, tracer, fn_state);
        };
    }
    fn block_498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_498_0: const #3s : i
        let s_498_0: i128 = 3;
        // D s_498_1: read-var u#32560:u32
        let s_498_1: u32 = fn_state.u_32560;
        // D s_498_2: cast zx s_498_1 -> bv
        let s_498_2: Bits = Bits::new(s_498_1 as u128, 32u16);
        // C s_498_3: const #1u : u64
        let s_498_3: u64 = 1;
        // D s_498_4: bit-extract s_498_2 s_498_0 s_498_3
        let s_498_4: Bits = (Bits::new(
            ((s_498_2) >> (s_498_0)).value(),
            u16::try_from(s_498_3).unwrap(),
        ));
        // D s_498_5: cast reint s_498_4 -> u8
        let s_498_5: bool = ((s_498_4.value()) != 0);
        // C s_498_6: const #0s : i
        let s_498_6: i128 = 0;
        // C s_498_7: const #0u : u64
        let s_498_7: u64 = 0;
        // D s_498_8: cast zx s_498_5 -> u64
        let s_498_8: u64 = (s_498_5 as u64);
        // C s_498_9: const #1u : u64
        let s_498_9: u64 = 1;
        // D s_498_10: and s_498_8 s_498_9
        let s_498_10: u64 = ((s_498_8) & (s_498_9));
        // D s_498_11: cmp-eq s_498_10 s_498_9
        let s_498_11: bool = ((s_498_10) == (s_498_9));
        // D s_498_12: lsl s_498_8 s_498_6
        let s_498_12: u64 = s_498_8 << s_498_6;
        // D s_498_13: or s_498_7 s_498_12
        let s_498_13: u64 = ((s_498_7) | (s_498_12));
        // D s_498_14: cmpl s_498_12
        let s_498_14: u64 = !s_498_12;
        // D s_498_15: and s_498_7 s_498_14
        let s_498_15: u64 = ((s_498_7) & (s_498_14));
        // D s_498_16: select s_498_11 s_498_13 s_498_15
        let s_498_16: u64 = if s_498_11 { s_498_13 } else { s_498_15 };
        // D s_498_17: cast trunc s_498_16 -> u8
        let s_498_17: bool = ((s_498_16) != 0);
        // D s_498_18: cast zx s_498_17 -> bv
        let s_498_18: Bits = Bits::new(s_498_17 as u128, 1u16);
        // C s_498_19: const #1u : u8
        let s_498_19: bool = true;
        // C s_498_20: cast zx s_498_19 -> bv
        let s_498_20: Bits = Bits::new(s_498_19 as u128, 1u16);
        // D s_498_21: cmp-ne s_498_18 s_498_20
        let s_498_21: bool = ((s_498_18) != (s_498_20));
        // D s_498_22: write-var gs#405044 <= s_498_21
        fn_state.gs_405044 = s_498_21;
        // N s_498_23: jump b499
        return block_499(state, tracer, fn_state);
    }
    fn block_499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_499_0: read-var gs#405044:u8
        let s_499_0: bool = fn_state.gs_405044;
        // N s_499_1: branch s_499_0 b501 b500
        if s_499_0 {
            return block_501(state, tracer, fn_state);
        } else {
            return block_500(state, tracer, fn_state);
        };
    }
    fn block_500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_500_0: read-var u#32561:u8
        let s_500_0: u8 = fn_state.u_32561;
        // D s_500_1: read-var u#32562:u8
        let s_500_1: u8 = fn_state.u_32562;
        // D s_500_2: read-var u#32563:u8
        let s_500_2: u8 = fn_state.u_32563;
        // D s_500_3: call decode_aarch32_instrs_LDREXH_A1enc_A_txt(s_500_0, s_500_1, s_500_2)
        let s_500_3: () = decode_aarch32_instrs_LDREXH_A1enc_A_txt(
            state,
            tracer,
            s_500_0,
            s_500_1,
            s_500_2,
        );
        // N s_500_4: return
        return;
    }
    fn block_501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_501_0: panic
        panic!("{:?}", ());
        // N s_501_1: return
        return;
    }
    fn block_502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_502_0: const #1u : u8
        let s_502_0: bool = true;
        // D s_502_1: write-var gs#405044 <= s_502_0
        fn_state.gs_405044 = s_502_0;
        // N s_502_2: jump b499
        return block_499(state, tracer, fn_state);
    }
    fn block_503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_503_0: const #1u : u8
        let s_503_0: bool = true;
        // D s_503_1: write-var gs#405041 <= s_503_0
        fn_state.gs_405041 = s_503_0;
        // N s_503_2: jump b497
        return block_497(state, tracer, fn_state);
    }
    fn block_504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_504_0: const #1u : u8
        let s_504_0: bool = true;
        // D s_504_1: write-var gs#405038 <= s_504_0
        fn_state.gs_405038 = s_504_0;
        // N s_504_2: jump b495
        return block_495(state, tracer, fn_state);
    }
    fn block_505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_505_0: const #1u : u8
        let s_505_0: bool = true;
        // D s_505_1: write-var gs#405035 <= s_505_0
        fn_state.gs_405035 = s_505_0;
        // N s_505_2: jump b493
        return block_493(state, tracer, fn_state);
    }
    fn block_506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_506_0: const #1u : u8
        let s_506_0: bool = true;
        // D s_506_1: write-var gs#405032 <= s_506_0
        fn_state.gs_405032 = s_506_0;
        // N s_506_2: jump b491
        return block_491(state, tracer, fn_state);
    }
    fn block_507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_507_0: read-var merge#var.1:struct
        let s_507_0: u32 = fn_state.merge_var._1;
        // D s_507_1: write-var u#32565 <= s_507_0
        fn_state.u_32565 = s_507_0;
        // C s_507_2: const #25s : i
        let s_507_2: i128 = 25;
        // D s_507_3: read-var u#32565:u32
        let s_507_3: u32 = fn_state.u_32565;
        // D s_507_4: cast zx s_507_3 -> bv
        let s_507_4: Bits = Bits::new(s_507_3 as u128, 32u16);
        // C s_507_5: const #1s : i64
        let s_507_5: i64 = 1;
        // C s_507_6: cast zx s_507_5 -> i
        let s_507_6: i128 = (i128::try_from(s_507_5).unwrap());
        // C s_507_7: const #2s : i
        let s_507_7: i128 = 2;
        // C s_507_8: add s_507_7 s_507_6
        let s_507_8: i128 = (s_507_7 + s_507_6);
        // D s_507_9: bit-extract s_507_4 s_507_2 s_507_8
        let s_507_9: Bits = (Bits::new(
            ((s_507_4) >> (s_507_2)).value(),
            u16::try_from(s_507_8).unwrap(),
        ));
        // D s_507_10: cast reint s_507_9 -> u8
        let s_507_10: u8 = (s_507_9.value() as u8);
        // D s_507_11: cast zx s_507_10 -> bv
        let s_507_11: Bits = Bits::new(s_507_10 as u128, 3u16);
        // C s_507_12: const #0u : u8
        let s_507_12: u8 = 0;
        // C s_507_13: cast zx s_507_12 -> bv
        let s_507_13: Bits = Bits::new(s_507_12 as u128, 3u16);
        // D s_507_14: cmp-eq s_507_11 s_507_13
        let s_507_14: bool = ((s_507_11) == (s_507_13));
        // N s_507_15: branch s_507_14 b2763 b508
        if s_507_14 {
            return block_2763(state, tracer, fn_state);
        } else {
            return block_508(state, tracer, fn_state);
        };
    }
    fn block_508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_508_0: const #0u : u8
        let s_508_0: bool = false;
        // D s_508_1: write-var gs#405056 <= s_508_0
        fn_state.gs_405056 = s_508_0;
        // N s_508_2: jump b509
        return block_509(state, tracer, fn_state);
    }
    fn block_509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_509_0: read-var gs#405056:u8
        let s_509_0: bool = fn_state.gs_405056;
        // N s_509_1: branch s_509_0 b2759 b510
        if s_509_0 {
            return block_2759(state, tracer, fn_state);
        } else {
            return block_510(state, tracer, fn_state);
        };
    }
    fn block_510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_510_0: const #0u : u8
        let s_510_0: bool = false;
        // D s_510_1: write-var gs#405061 <= s_510_0
        fn_state.gs_405061 = s_510_0;
        // N s_510_2: jump b511
        return block_511(state, tracer, fn_state);
    }
    fn block_511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_511_0: read-var gs#405061:u8
        let s_511_0: bool = fn_state.gs_405061;
        // D s_511_1: not s_511_0
        let s_511_1: bool = !s_511_0;
        // N s_511_2: branch s_511_1 b513 b512
        if s_511_1 {
            return block_513(state, tracer, fn_state);
        } else {
            return block_512(state, tracer, fn_state);
        };
    }
    fn block_512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_512_0: const #2948s : i
        let s_512_0: i128 = 2948;
        // C s_512_1: const #14696u : u32
        let s_512_1: u32 = 14696;
        // N s_512_2: write-reg s_512_1 <= s_512_0
        let s_512_2: () = {
            state.write_register::<i128>(s_512_1 as isize, s_512_0);
            tracer.write_register(s_512_1 as isize, s_512_0);
        };
        // C s_512_3: const #28s : i
        let s_512_3: i128 = 28;
        // C s_512_4: const #4s : i
        let s_512_4: i128 = 4;
        // D s_512_5: read-var u#32565:u32
        let s_512_5: u32 = fn_state.u_32565;
        // D s_512_6: cast zx s_512_5 -> bv
        let s_512_6: Bits = Bits::new(s_512_5 as u128, 32u16);
        // D s_512_7: bit-extract s_512_6 s_512_3 s_512_4
        let s_512_7: Bits = (Bits::new(
            ((s_512_6) >> (s_512_3)).value(),
            u16::try_from(s_512_4).unwrap(),
        ));
        // D s_512_8: cast reint s_512_7 -> u8
        let s_512_8: u8 = (s_512_7.value() as u8);
        // C s_512_9: const #24s : i
        let s_512_9: i128 = 24;
        // C s_512_10: const #1s : i
        let s_512_10: i128 = 1;
        // D s_512_11: read-var u#32565:u32
        let s_512_11: u32 = fn_state.u_32565;
        // D s_512_12: cast zx s_512_11 -> bv
        let s_512_12: Bits = Bits::new(s_512_11 as u128, 32u16);
        // D s_512_13: bit-extract s_512_12 s_512_9 s_512_10
        let s_512_13: Bits = (Bits::new(
            ((s_512_12) >> (s_512_9)).value(),
            u16::try_from(s_512_10).unwrap(),
        ));
        // D s_512_14: cast reint s_512_13 -> u8
        let s_512_14: bool = ((s_512_13.value()) != 0);
        // C s_512_15: const #23s : i
        let s_512_15: i128 = 23;
        // C s_512_16: const #1s : i
        let s_512_16: i128 = 1;
        // D s_512_17: read-var u#32565:u32
        let s_512_17: u32 = fn_state.u_32565;
        // D s_512_18: cast zx s_512_17 -> bv
        let s_512_18: Bits = Bits::new(s_512_17 as u128, 32u16);
        // D s_512_19: bit-extract s_512_18 s_512_15 s_512_16
        let s_512_19: Bits = (Bits::new(
            ((s_512_18) >> (s_512_15)).value(),
            u16::try_from(s_512_16).unwrap(),
        ));
        // D s_512_20: cast reint s_512_19 -> u8
        let s_512_20: bool = ((s_512_19.value()) != 0);
        // C s_512_21: const #21s : i
        let s_512_21: i128 = 21;
        // C s_512_22: const #1s : i
        let s_512_22: i128 = 1;
        // D s_512_23: read-var u#32565:u32
        let s_512_23: u32 = fn_state.u_32565;
        // D s_512_24: cast zx s_512_23 -> bv
        let s_512_24: Bits = Bits::new(s_512_23 as u128, 32u16);
        // D s_512_25: bit-extract s_512_24 s_512_21 s_512_22
        let s_512_25: Bits = (Bits::new(
            ((s_512_24) >> (s_512_21)).value(),
            u16::try_from(s_512_22).unwrap(),
        ));
        // D s_512_26: cast reint s_512_25 -> u8
        let s_512_26: bool = ((s_512_25.value()) != 0);
        // C s_512_27: const #16s : i
        let s_512_27: i128 = 16;
        // C s_512_28: const #4s : i
        let s_512_28: i128 = 4;
        // D s_512_29: read-var u#32565:u32
        let s_512_29: u32 = fn_state.u_32565;
        // D s_512_30: cast zx s_512_29 -> bv
        let s_512_30: Bits = Bits::new(s_512_29 as u128, 32u16);
        // D s_512_31: bit-extract s_512_30 s_512_27 s_512_28
        let s_512_31: Bits = (Bits::new(
            ((s_512_30) >> (s_512_27)).value(),
            u16::try_from(s_512_28).unwrap(),
        ));
        // D s_512_32: cast reint s_512_31 -> u8
        let s_512_32: u8 = (s_512_31.value() as u8);
        // C s_512_33: const #12s : i
        let s_512_33: i128 = 12;
        // C s_512_34: const #4s : i
        let s_512_34: i128 = 4;
        // D s_512_35: read-var u#32565:u32
        let s_512_35: u32 = fn_state.u_32565;
        // D s_512_36: cast zx s_512_35 -> bv
        let s_512_36: Bits = Bits::new(s_512_35 as u128, 32u16);
        // D s_512_37: bit-extract s_512_36 s_512_33 s_512_34
        let s_512_37: Bits = (Bits::new(
            ((s_512_36) >> (s_512_33)).value(),
            u16::try_from(s_512_34).unwrap(),
        ));
        // D s_512_38: cast reint s_512_37 -> u8
        let s_512_38: u8 = (s_512_37.value() as u8);
        // C s_512_39: const #8s : i
        let s_512_39: i128 = 8;
        // C s_512_40: const #4s : i
        let s_512_40: i128 = 4;
        // D s_512_41: read-var u#32565:u32
        let s_512_41: u32 = fn_state.u_32565;
        // D s_512_42: cast zx s_512_41 -> bv
        let s_512_42: Bits = Bits::new(s_512_41 as u128, 32u16);
        // D s_512_43: bit-extract s_512_42 s_512_39 s_512_40
        let s_512_43: Bits = (Bits::new(
            ((s_512_42) >> (s_512_39)).value(),
            u16::try_from(s_512_40).unwrap(),
        ));
        // D s_512_44: cast reint s_512_43 -> u8
        let s_512_44: u8 = (s_512_43.value() as u8);
        // C s_512_45: const #0s : i
        let s_512_45: i128 = 0;
        // C s_512_46: const #4s : i
        let s_512_46: i128 = 4;
        // D s_512_47: read-var u#32565:u32
        let s_512_47: u32 = fn_state.u_32565;
        // D s_512_48: cast zx s_512_47 -> bv
        let s_512_48: Bits = Bits::new(s_512_47 as u128, 32u16);
        // D s_512_49: bit-extract s_512_48 s_512_45 s_512_46
        let s_512_49: Bits = (Bits::new(
            ((s_512_48) >> (s_512_45)).value(),
            u16::try_from(s_512_46).unwrap(),
        ));
        // D s_512_50: cast reint s_512_49 -> u8
        let s_512_50: u8 = (s_512_49.value() as u8);
        // D s_512_51: call decode_aarch32_instrs_LDRH_i_A1enc_A_txt(s_512_8, s_512_14, s_512_20, s_512_26, s_512_32, s_512_38, s_512_44, s_512_50)
        let s_512_51: () = decode_aarch32_instrs_LDRH_i_A1enc_A_txt(
            state,
            tracer,
            s_512_8,
            s_512_14,
            s_512_20,
            s_512_26,
            s_512_32,
            s_512_38,
            s_512_44,
            s_512_50,
        );
        // N s_512_52: return
        return;
    }
    fn block_513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_513_0: read-var merge#var.1:struct
        let s_513_0: u32 = fn_state.merge_var._1;
        // D s_513_1: write-var u#32575 <= s_513_0
        fn_state.u_32575 = s_513_0;
        // C s_513_2: const #25s : i
        let s_513_2: i128 = 25;
        // D s_513_3: read-var u#32575:u32
        let s_513_3: u32 = fn_state.u_32575;
        // D s_513_4: cast zx s_513_3 -> bv
        let s_513_4: Bits = Bits::new(s_513_3 as u128, 32u16);
        // C s_513_5: const #1s : i64
        let s_513_5: i64 = 1;
        // C s_513_6: cast zx s_513_5 -> i
        let s_513_6: i128 = (i128::try_from(s_513_5).unwrap());
        // C s_513_7: const #2s : i
        let s_513_7: i128 = 2;
        // C s_513_8: add s_513_7 s_513_6
        let s_513_8: i128 = (s_513_7 + s_513_6);
        // D s_513_9: bit-extract s_513_4 s_513_2 s_513_8
        let s_513_9: Bits = (Bits::new(
            ((s_513_4) >> (s_513_2)).value(),
            u16::try_from(s_513_8).unwrap(),
        ));
        // D s_513_10: cast reint s_513_9 -> u8
        let s_513_10: u8 = (s_513_9.value() as u8);
        // D s_513_11: cast zx s_513_10 -> bv
        let s_513_11: Bits = Bits::new(s_513_10 as u128, 3u16);
        // C s_513_12: const #0u : u8
        let s_513_12: u8 = 0;
        // C s_513_13: cast zx s_513_12 -> bv
        let s_513_13: Bits = Bits::new(s_513_12 as u128, 3u16);
        // D s_513_14: cmp-eq s_513_11 s_513_13
        let s_513_14: bool = ((s_513_11) == (s_513_13));
        // N s_513_15: branch s_513_14 b2752 b514
        if s_513_14 {
            return block_2752(state, tracer, fn_state);
        } else {
            return block_514(state, tracer, fn_state);
        };
    }
    fn block_514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_514_0: const #0u : u8
        let s_514_0: bool = false;
        // D s_514_1: write-var gs#405091 <= s_514_0
        fn_state.gs_405091 = s_514_0;
        // N s_514_2: jump b515
        return block_515(state, tracer, fn_state);
    }
    fn block_515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_515_0: read-var gs#405091:u8
        let s_515_0: bool = fn_state.gs_405091;
        // N s_515_1: branch s_515_0 b2748 b516
        if s_515_0 {
            return block_2748(state, tracer, fn_state);
        } else {
            return block_516(state, tracer, fn_state);
        };
    }
    fn block_516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_516_0: const #0u : u8
        let s_516_0: bool = false;
        // D s_516_1: write-var gs#405096 <= s_516_0
        fn_state.gs_405096 = s_516_0;
        // N s_516_2: jump b517
        return block_517(state, tracer, fn_state);
    }
    fn block_517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_517_0: read-var gs#405096:u8
        let s_517_0: bool = fn_state.gs_405096;
        // D s_517_1: not s_517_0
        let s_517_1: bool = !s_517_0;
        // N s_517_2: branch s_517_1 b519 b518
        if s_517_1 {
            return block_519(state, tracer, fn_state);
        } else {
            return block_518(state, tracer, fn_state);
        };
    }
    fn block_518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_518_0: const #2952s : i
        let s_518_0: i128 = 2952;
        // C s_518_1: const #14696u : u32
        let s_518_1: u32 = 14696;
        // N s_518_2: write-reg s_518_1 <= s_518_0
        let s_518_2: () = {
            state.write_register::<i128>(s_518_1 as isize, s_518_0);
            tracer.write_register(s_518_1 as isize, s_518_0);
        };
        // C s_518_3: const #28s : i
        let s_518_3: i128 = 28;
        // C s_518_4: const #4s : i
        let s_518_4: i128 = 4;
        // D s_518_5: read-var u#32575:u32
        let s_518_5: u32 = fn_state.u_32575;
        // D s_518_6: cast zx s_518_5 -> bv
        let s_518_6: Bits = Bits::new(s_518_5 as u128, 32u16);
        // D s_518_7: bit-extract s_518_6 s_518_3 s_518_4
        let s_518_7: Bits = (Bits::new(
            ((s_518_6) >> (s_518_3)).value(),
            u16::try_from(s_518_4).unwrap(),
        ));
        // D s_518_8: cast reint s_518_7 -> u8
        let s_518_8: u8 = (s_518_7.value() as u8);
        // C s_518_9: const #24s : i
        let s_518_9: i128 = 24;
        // C s_518_10: const #1s : i
        let s_518_10: i128 = 1;
        // D s_518_11: read-var u#32575:u32
        let s_518_11: u32 = fn_state.u_32575;
        // D s_518_12: cast zx s_518_11 -> bv
        let s_518_12: Bits = Bits::new(s_518_11 as u128, 32u16);
        // D s_518_13: bit-extract s_518_12 s_518_9 s_518_10
        let s_518_13: Bits = (Bits::new(
            ((s_518_12) >> (s_518_9)).value(),
            u16::try_from(s_518_10).unwrap(),
        ));
        // D s_518_14: cast reint s_518_13 -> u8
        let s_518_14: bool = ((s_518_13.value()) != 0);
        // C s_518_15: const #23s : i
        let s_518_15: i128 = 23;
        // C s_518_16: const #1s : i
        let s_518_16: i128 = 1;
        // D s_518_17: read-var u#32575:u32
        let s_518_17: u32 = fn_state.u_32575;
        // D s_518_18: cast zx s_518_17 -> bv
        let s_518_18: Bits = Bits::new(s_518_17 as u128, 32u16);
        // D s_518_19: bit-extract s_518_18 s_518_15 s_518_16
        let s_518_19: Bits = (Bits::new(
            ((s_518_18) >> (s_518_15)).value(),
            u16::try_from(s_518_16).unwrap(),
        ));
        // D s_518_20: cast reint s_518_19 -> u8
        let s_518_20: bool = ((s_518_19.value()) != 0);
        // C s_518_21: const #21s : i
        let s_518_21: i128 = 21;
        // C s_518_22: const #1s : i
        let s_518_22: i128 = 1;
        // D s_518_23: read-var u#32575:u32
        let s_518_23: u32 = fn_state.u_32575;
        // D s_518_24: cast zx s_518_23 -> bv
        let s_518_24: Bits = Bits::new(s_518_23 as u128, 32u16);
        // D s_518_25: bit-extract s_518_24 s_518_21 s_518_22
        let s_518_25: Bits = (Bits::new(
            ((s_518_24) >> (s_518_21)).value(),
            u16::try_from(s_518_22).unwrap(),
        ));
        // D s_518_26: cast reint s_518_25 -> u8
        let s_518_26: bool = ((s_518_25.value()) != 0);
        // C s_518_27: const #12s : i
        let s_518_27: i128 = 12;
        // C s_518_28: const #4s : i
        let s_518_28: i128 = 4;
        // D s_518_29: read-var u#32575:u32
        let s_518_29: u32 = fn_state.u_32575;
        // D s_518_30: cast zx s_518_29 -> bv
        let s_518_30: Bits = Bits::new(s_518_29 as u128, 32u16);
        // D s_518_31: bit-extract s_518_30 s_518_27 s_518_28
        let s_518_31: Bits = (Bits::new(
            ((s_518_30) >> (s_518_27)).value(),
            u16::try_from(s_518_28).unwrap(),
        ));
        // D s_518_32: cast reint s_518_31 -> u8
        let s_518_32: u8 = (s_518_31.value() as u8);
        // C s_518_33: const #8s : i
        let s_518_33: i128 = 8;
        // C s_518_34: const #4s : i
        let s_518_34: i128 = 4;
        // D s_518_35: read-var u#32575:u32
        let s_518_35: u32 = fn_state.u_32575;
        // D s_518_36: cast zx s_518_35 -> bv
        let s_518_36: Bits = Bits::new(s_518_35 as u128, 32u16);
        // D s_518_37: bit-extract s_518_36 s_518_33 s_518_34
        let s_518_37: Bits = (Bits::new(
            ((s_518_36) >> (s_518_33)).value(),
            u16::try_from(s_518_34).unwrap(),
        ));
        // D s_518_38: cast reint s_518_37 -> u8
        let s_518_38: u8 = (s_518_37.value() as u8);
        // C s_518_39: const #0s : i
        let s_518_39: i128 = 0;
        // C s_518_40: const #4s : i
        let s_518_40: i128 = 4;
        // D s_518_41: read-var u#32575:u32
        let s_518_41: u32 = fn_state.u_32575;
        // D s_518_42: cast zx s_518_41 -> bv
        let s_518_42: Bits = Bits::new(s_518_41 as u128, 32u16);
        // D s_518_43: bit-extract s_518_42 s_518_39 s_518_40
        let s_518_43: Bits = (Bits::new(
            ((s_518_42) >> (s_518_39)).value(),
            u16::try_from(s_518_40).unwrap(),
        ));
        // D s_518_44: cast reint s_518_43 -> u8
        let s_518_44: u8 = (s_518_43.value() as u8);
        // D s_518_45: call decode_aarch32_instrs_LDRH_l_A1enc_A_txt(s_518_8, s_518_14, s_518_20, s_518_26, s_518_32, s_518_38, s_518_44)
        let s_518_45: () = decode_aarch32_instrs_LDRH_l_A1enc_A_txt(
            state,
            tracer,
            s_518_8,
            s_518_14,
            s_518_20,
            s_518_26,
            s_518_32,
            s_518_38,
            s_518_44,
        );
        // N s_518_46: return
        return;
    }
    fn block_519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_519_0: read-var merge#var.1:struct
        let s_519_0: u32 = fn_state.merge_var._1;
        // D s_519_1: write-var u#32584 <= s_519_0
        fn_state.u_32584 = s_519_0;
        // C s_519_2: const #25s : i
        let s_519_2: i128 = 25;
        // D s_519_3: read-var u#32584:u32
        let s_519_3: u32 = fn_state.u_32584;
        // D s_519_4: cast zx s_519_3 -> bv
        let s_519_4: Bits = Bits::new(s_519_3 as u128, 32u16);
        // C s_519_5: const #1s : i64
        let s_519_5: i64 = 1;
        // C s_519_6: cast zx s_519_5 -> i
        let s_519_6: i128 = (i128::try_from(s_519_5).unwrap());
        // C s_519_7: const #2s : i
        let s_519_7: i128 = 2;
        // C s_519_8: add s_519_7 s_519_6
        let s_519_8: i128 = (s_519_7 + s_519_6);
        // D s_519_9: bit-extract s_519_4 s_519_2 s_519_8
        let s_519_9: Bits = (Bits::new(
            ((s_519_4) >> (s_519_2)).value(),
            u16::try_from(s_519_8).unwrap(),
        ));
        // D s_519_10: cast reint s_519_9 -> u8
        let s_519_10: u8 = (s_519_9.value() as u8);
        // D s_519_11: cast zx s_519_10 -> bv
        let s_519_11: Bits = Bits::new(s_519_10 as u128, 3u16);
        // C s_519_12: const #0u : u8
        let s_519_12: u8 = 0;
        // C s_519_13: cast zx s_519_12 -> bv
        let s_519_13: Bits = Bits::new(s_519_12 as u128, 3u16);
        // D s_519_14: cmp-eq s_519_11 s_519_13
        let s_519_14: bool = ((s_519_11) == (s_519_13));
        // N s_519_15: branch s_519_14 b2741 b520
        if s_519_14 {
            return block_2741(state, tracer, fn_state);
        } else {
            return block_520(state, tracer, fn_state);
        };
    }
    fn block_520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_520_0: const #0u : u8
        let s_520_0: bool = false;
        // D s_520_1: write-var gs#405124 <= s_520_0
        fn_state.gs_405124 = s_520_0;
        // N s_520_2: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_521_0: read-var gs#405124:u8
        let s_521_0: bool = fn_state.gs_405124;
        // N s_521_1: branch s_521_0 b2737 b522
        if s_521_0 {
            return block_2737(state, tracer, fn_state);
        } else {
            return block_522(state, tracer, fn_state);
        };
    }
    fn block_522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_522_0: const #0u : u8
        let s_522_0: bool = false;
        // D s_522_1: write-var gs#405129 <= s_522_0
        fn_state.gs_405129 = s_522_0;
        // N s_522_2: jump b523
        return block_523(state, tracer, fn_state);
    }
    fn block_523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_523_0: read-var gs#405129:u8
        let s_523_0: bool = fn_state.gs_405129;
        // D s_523_1: not s_523_0
        let s_523_1: bool = !s_523_0;
        // N s_523_2: branch s_523_1 b536 b524
        if s_523_1 {
            return block_536(state, tracer, fn_state);
        } else {
            return block_524(state, tracer, fn_state);
        };
    }
    fn block_524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_524_0: const #2954s : i
        let s_524_0: i128 = 2954;
        // C s_524_1: const #14696u : u32
        let s_524_1: u32 = 14696;
        // N s_524_2: write-reg s_524_1 <= s_524_0
        let s_524_2: () = {
            state.write_register::<i128>(s_524_1 as isize, s_524_0);
            tracer.write_register(s_524_1 as isize, s_524_0);
        };
        // C s_524_3: const #28s : i
        let s_524_3: i128 = 28;
        // C s_524_4: const #4s : i
        let s_524_4: i128 = 4;
        // D s_524_5: read-var u#32584:u32
        let s_524_5: u32 = fn_state.u_32584;
        // D s_524_6: cast zx s_524_5 -> bv
        let s_524_6: Bits = Bits::new(s_524_5 as u128, 32u16);
        // D s_524_7: bit-extract s_524_6 s_524_3 s_524_4
        let s_524_7: Bits = (Bits::new(
            ((s_524_6) >> (s_524_3)).value(),
            u16::try_from(s_524_4).unwrap(),
        ));
        // D s_524_8: cast reint s_524_7 -> u8
        let s_524_8: u8 = (s_524_7.value() as u8);
        // D s_524_9: write-var u#32585 <= s_524_8
        fn_state.u_32585 = s_524_8;
        // C s_524_10: const #24s : i
        let s_524_10: i128 = 24;
        // C s_524_11: const #1s : i
        let s_524_11: i128 = 1;
        // D s_524_12: read-var u#32584:u32
        let s_524_12: u32 = fn_state.u_32584;
        // D s_524_13: cast zx s_524_12 -> bv
        let s_524_13: Bits = Bits::new(s_524_12 as u128, 32u16);
        // D s_524_14: bit-extract s_524_13 s_524_10 s_524_11
        let s_524_14: Bits = (Bits::new(
            ((s_524_13) >> (s_524_10)).value(),
            u16::try_from(s_524_11).unwrap(),
        ));
        // D s_524_15: cast reint s_524_14 -> u8
        let s_524_15: bool = ((s_524_14.value()) != 0);
        // D s_524_16: write-var u#32586 <= s_524_15
        fn_state.u_32586 = s_524_15;
        // C s_524_17: const #23s : i
        let s_524_17: i128 = 23;
        // C s_524_18: const #1s : i
        let s_524_18: i128 = 1;
        // D s_524_19: read-var u#32584:u32
        let s_524_19: u32 = fn_state.u_32584;
        // D s_524_20: cast zx s_524_19 -> bv
        let s_524_20: Bits = Bits::new(s_524_19 as u128, 32u16);
        // D s_524_21: bit-extract s_524_20 s_524_17 s_524_18
        let s_524_21: Bits = (Bits::new(
            ((s_524_20) >> (s_524_17)).value(),
            u16::try_from(s_524_18).unwrap(),
        ));
        // D s_524_22: cast reint s_524_21 -> u8
        let s_524_22: bool = ((s_524_21.value()) != 0);
        // D s_524_23: write-var u#32587 <= s_524_22
        fn_state.u_32587 = s_524_22;
        // C s_524_24: const #21s : i
        let s_524_24: i128 = 21;
        // C s_524_25: const #1s : i
        let s_524_25: i128 = 1;
        // D s_524_26: read-var u#32584:u32
        let s_524_26: u32 = fn_state.u_32584;
        // D s_524_27: cast zx s_524_26 -> bv
        let s_524_27: Bits = Bits::new(s_524_26 as u128, 32u16);
        // D s_524_28: bit-extract s_524_27 s_524_24 s_524_25
        let s_524_28: Bits = (Bits::new(
            ((s_524_27) >> (s_524_24)).value(),
            u16::try_from(s_524_25).unwrap(),
        ));
        // D s_524_29: cast reint s_524_28 -> u8
        let s_524_29: bool = ((s_524_28.value()) != 0);
        // D s_524_30: write-var u#32588 <= s_524_29
        fn_state.u_32588 = s_524_29;
        // C s_524_31: const #16s : i
        let s_524_31: i128 = 16;
        // C s_524_32: const #4s : i
        let s_524_32: i128 = 4;
        // D s_524_33: read-var u#32584:u32
        let s_524_33: u32 = fn_state.u_32584;
        // D s_524_34: cast zx s_524_33 -> bv
        let s_524_34: Bits = Bits::new(s_524_33 as u128, 32u16);
        // D s_524_35: bit-extract s_524_34 s_524_31 s_524_32
        let s_524_35: Bits = (Bits::new(
            ((s_524_34) >> (s_524_31)).value(),
            u16::try_from(s_524_32).unwrap(),
        ));
        // D s_524_36: cast reint s_524_35 -> u8
        let s_524_36: u8 = (s_524_35.value() as u8);
        // D s_524_37: write-var u#32589 <= s_524_36
        fn_state.u_32589 = s_524_36;
        // C s_524_38: const #12s : i
        let s_524_38: i128 = 12;
        // C s_524_39: const #4s : i
        let s_524_39: i128 = 4;
        // D s_524_40: read-var u#32584:u32
        let s_524_40: u32 = fn_state.u_32584;
        // D s_524_41: cast zx s_524_40 -> bv
        let s_524_41: Bits = Bits::new(s_524_40 as u128, 32u16);
        // D s_524_42: bit-extract s_524_41 s_524_38 s_524_39
        let s_524_42: Bits = (Bits::new(
            ((s_524_41) >> (s_524_38)).value(),
            u16::try_from(s_524_39).unwrap(),
        ));
        // D s_524_43: cast reint s_524_42 -> u8
        let s_524_43: u8 = (s_524_42.value() as u8);
        // D s_524_44: write-var u#32590 <= s_524_43
        fn_state.u_32590 = s_524_43;
        // C s_524_45: const #0s : i
        let s_524_45: i128 = 0;
        // C s_524_46: const #4s : i
        let s_524_46: i128 = 4;
        // D s_524_47: read-var u#32584:u32
        let s_524_47: u32 = fn_state.u_32584;
        // D s_524_48: cast zx s_524_47 -> bv
        let s_524_48: Bits = Bits::new(s_524_47 as u128, 32u16);
        // D s_524_49: bit-extract s_524_48 s_524_45 s_524_46
        let s_524_49: Bits = (Bits::new(
            ((s_524_48) >> (s_524_45)).value(),
            u16::try_from(s_524_46).unwrap(),
        ));
        // D s_524_50: cast reint s_524_49 -> u8
        let s_524_50: u8 = (s_524_49.value() as u8);
        // D s_524_51: write-var u#32591 <= s_524_50
        fn_state.u_32591 = s_524_50;
        // C s_524_52: const #8s : i
        let s_524_52: i128 = 8;
        // D s_524_53: read-var u#32584:u32
        let s_524_53: u32 = fn_state.u_32584;
        // D s_524_54: cast zx s_524_53 -> bv
        let s_524_54: Bits = Bits::new(s_524_53 as u128, 32u16);
        // C s_524_55: const #1u : u64
        let s_524_55: u64 = 1;
        // D s_524_56: bit-extract s_524_54 s_524_52 s_524_55
        let s_524_56: Bits = (Bits::new(
            ((s_524_54) >> (s_524_52)).value(),
            u16::try_from(s_524_55).unwrap(),
        ));
        // D s_524_57: cast reint s_524_56 -> u8
        let s_524_57: bool = ((s_524_56.value()) != 0);
        // C s_524_58: const #0s : i
        let s_524_58: i128 = 0;
        // C s_524_59: const #0u : u64
        let s_524_59: u64 = 0;
        // D s_524_60: cast zx s_524_57 -> u64
        let s_524_60: u64 = (s_524_57 as u64);
        // C s_524_61: const #1u : u64
        let s_524_61: u64 = 1;
        // D s_524_62: and s_524_60 s_524_61
        let s_524_62: u64 = ((s_524_60) & (s_524_61));
        // D s_524_63: cmp-eq s_524_62 s_524_61
        let s_524_63: bool = ((s_524_62) == (s_524_61));
        // D s_524_64: lsl s_524_60 s_524_58
        let s_524_64: u64 = s_524_60 << s_524_58;
        // D s_524_65: or s_524_59 s_524_64
        let s_524_65: u64 = ((s_524_59) | (s_524_64));
        // D s_524_66: cmpl s_524_64
        let s_524_66: u64 = !s_524_64;
        // D s_524_67: and s_524_59 s_524_66
        let s_524_67: u64 = ((s_524_59) & (s_524_66));
        // D s_524_68: select s_524_63 s_524_65 s_524_67
        let s_524_68: u64 = if s_524_63 { s_524_65 } else { s_524_67 };
        // D s_524_69: cast trunc s_524_68 -> u8
        let s_524_69: bool = ((s_524_68) != 0);
        // D s_524_70: cast zx s_524_69 -> bv
        let s_524_70: Bits = Bits::new(s_524_69 as u128, 1u16);
        // C s_524_71: const #0u : u8
        let s_524_71: bool = false;
        // C s_524_72: cast zx s_524_71 -> bv
        let s_524_72: Bits = Bits::new(s_524_71 as u128, 1u16);
        // D s_524_73: cmp-ne s_524_70 s_524_72
        let s_524_73: bool = ((s_524_70) != (s_524_72));
        // N s_524_74: branch s_524_73 b535 b525
        if s_524_73 {
            return block_535(state, tracer, fn_state);
        } else {
            return block_525(state, tracer, fn_state);
        };
    }
    fn block_525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_525_0: const #9s : i
        let s_525_0: i128 = 9;
        // D s_525_1: read-var u#32584:u32
        let s_525_1: u32 = fn_state.u_32584;
        // D s_525_2: cast zx s_525_1 -> bv
        let s_525_2: Bits = Bits::new(s_525_1 as u128, 32u16);
        // C s_525_3: const #1u : u64
        let s_525_3: u64 = 1;
        // D s_525_4: bit-extract s_525_2 s_525_0 s_525_3
        let s_525_4: Bits = (Bits::new(
            ((s_525_2) >> (s_525_0)).value(),
            u16::try_from(s_525_3).unwrap(),
        ));
        // D s_525_5: cast reint s_525_4 -> u8
        let s_525_5: bool = ((s_525_4.value()) != 0);
        // C s_525_6: const #0s : i
        let s_525_6: i128 = 0;
        // C s_525_7: const #0u : u64
        let s_525_7: u64 = 0;
        // D s_525_8: cast zx s_525_5 -> u64
        let s_525_8: u64 = (s_525_5 as u64);
        // C s_525_9: const #1u : u64
        let s_525_9: u64 = 1;
        // D s_525_10: and s_525_8 s_525_9
        let s_525_10: u64 = ((s_525_8) & (s_525_9));
        // D s_525_11: cmp-eq s_525_10 s_525_9
        let s_525_11: bool = ((s_525_10) == (s_525_9));
        // D s_525_12: lsl s_525_8 s_525_6
        let s_525_12: u64 = s_525_8 << s_525_6;
        // D s_525_13: or s_525_7 s_525_12
        let s_525_13: u64 = ((s_525_7) | (s_525_12));
        // D s_525_14: cmpl s_525_12
        let s_525_14: u64 = !s_525_12;
        // D s_525_15: and s_525_7 s_525_14
        let s_525_15: u64 = ((s_525_7) & (s_525_14));
        // D s_525_16: select s_525_11 s_525_13 s_525_15
        let s_525_16: u64 = if s_525_11 { s_525_13 } else { s_525_15 };
        // D s_525_17: cast trunc s_525_16 -> u8
        let s_525_17: bool = ((s_525_16) != 0);
        // D s_525_18: cast zx s_525_17 -> bv
        let s_525_18: Bits = Bits::new(s_525_17 as u128, 1u16);
        // C s_525_19: const #0u : u8
        let s_525_19: bool = false;
        // C s_525_20: cast zx s_525_19 -> bv
        let s_525_20: Bits = Bits::new(s_525_19 as u128, 1u16);
        // D s_525_21: cmp-ne s_525_18 s_525_20
        let s_525_21: bool = ((s_525_18) != (s_525_20));
        // D s_525_22: write-var gs#405150 <= s_525_21
        fn_state.gs_405150 = s_525_21;
        // N s_525_23: jump b526
        return block_526(state, tracer, fn_state);
    }
    fn block_526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_526_0: read-var gs#405150:u8
        let s_526_0: bool = fn_state.gs_405150;
        // N s_526_1: branch s_526_0 b534 b527
        if s_526_0 {
            return block_534(state, tracer, fn_state);
        } else {
            return block_527(state, tracer, fn_state);
        };
    }
    fn block_527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_527_0: const #10s : i
        let s_527_0: i128 = 10;
        // D s_527_1: read-var u#32584:u32
        let s_527_1: u32 = fn_state.u_32584;
        // D s_527_2: cast zx s_527_1 -> bv
        let s_527_2: Bits = Bits::new(s_527_1 as u128, 32u16);
        // C s_527_3: const #1u : u64
        let s_527_3: u64 = 1;
        // D s_527_4: bit-extract s_527_2 s_527_0 s_527_3
        let s_527_4: Bits = (Bits::new(
            ((s_527_2) >> (s_527_0)).value(),
            u16::try_from(s_527_3).unwrap(),
        ));
        // D s_527_5: cast reint s_527_4 -> u8
        let s_527_5: bool = ((s_527_4.value()) != 0);
        // C s_527_6: const #0s : i
        let s_527_6: i128 = 0;
        // C s_527_7: const #0u : u64
        let s_527_7: u64 = 0;
        // D s_527_8: cast zx s_527_5 -> u64
        let s_527_8: u64 = (s_527_5 as u64);
        // C s_527_9: const #1u : u64
        let s_527_9: u64 = 1;
        // D s_527_10: and s_527_8 s_527_9
        let s_527_10: u64 = ((s_527_8) & (s_527_9));
        // D s_527_11: cmp-eq s_527_10 s_527_9
        let s_527_11: bool = ((s_527_10) == (s_527_9));
        // D s_527_12: lsl s_527_8 s_527_6
        let s_527_12: u64 = s_527_8 << s_527_6;
        // D s_527_13: or s_527_7 s_527_12
        let s_527_13: u64 = ((s_527_7) | (s_527_12));
        // D s_527_14: cmpl s_527_12
        let s_527_14: u64 = !s_527_12;
        // D s_527_15: and s_527_7 s_527_14
        let s_527_15: u64 = ((s_527_7) & (s_527_14));
        // D s_527_16: select s_527_11 s_527_13 s_527_15
        let s_527_16: u64 = if s_527_11 { s_527_13 } else { s_527_15 };
        // D s_527_17: cast trunc s_527_16 -> u8
        let s_527_17: bool = ((s_527_16) != 0);
        // D s_527_18: cast zx s_527_17 -> bv
        let s_527_18: Bits = Bits::new(s_527_17 as u128, 1u16);
        // C s_527_19: const #0u : u8
        let s_527_19: bool = false;
        // C s_527_20: cast zx s_527_19 -> bv
        let s_527_20: Bits = Bits::new(s_527_19 as u128, 1u16);
        // D s_527_21: cmp-ne s_527_18 s_527_20
        let s_527_21: bool = ((s_527_18) != (s_527_20));
        // D s_527_22: write-var gs#405153 <= s_527_21
        fn_state.gs_405153 = s_527_21;
        // N s_527_23: jump b528
        return block_528(state, tracer, fn_state);
    }
    fn block_528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_528_0: read-var gs#405153:u8
        let s_528_0: bool = fn_state.gs_405153;
        // N s_528_1: branch s_528_0 b533 b529
        if s_528_0 {
            return block_533(state, tracer, fn_state);
        } else {
            return block_529(state, tracer, fn_state);
        };
    }
    fn block_529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_529_0: const #11s : i
        let s_529_0: i128 = 11;
        // D s_529_1: read-var u#32584:u32
        let s_529_1: u32 = fn_state.u_32584;
        // D s_529_2: cast zx s_529_1 -> bv
        let s_529_2: Bits = Bits::new(s_529_1 as u128, 32u16);
        // C s_529_3: const #1u : u64
        let s_529_3: u64 = 1;
        // D s_529_4: bit-extract s_529_2 s_529_0 s_529_3
        let s_529_4: Bits = (Bits::new(
            ((s_529_2) >> (s_529_0)).value(),
            u16::try_from(s_529_3).unwrap(),
        ));
        // D s_529_5: cast reint s_529_4 -> u8
        let s_529_5: bool = ((s_529_4.value()) != 0);
        // C s_529_6: const #0s : i
        let s_529_6: i128 = 0;
        // C s_529_7: const #0u : u64
        let s_529_7: u64 = 0;
        // D s_529_8: cast zx s_529_5 -> u64
        let s_529_8: u64 = (s_529_5 as u64);
        // C s_529_9: const #1u : u64
        let s_529_9: u64 = 1;
        // D s_529_10: and s_529_8 s_529_9
        let s_529_10: u64 = ((s_529_8) & (s_529_9));
        // D s_529_11: cmp-eq s_529_10 s_529_9
        let s_529_11: bool = ((s_529_10) == (s_529_9));
        // D s_529_12: lsl s_529_8 s_529_6
        let s_529_12: u64 = s_529_8 << s_529_6;
        // D s_529_13: or s_529_7 s_529_12
        let s_529_13: u64 = ((s_529_7) | (s_529_12));
        // D s_529_14: cmpl s_529_12
        let s_529_14: u64 = !s_529_12;
        // D s_529_15: and s_529_7 s_529_14
        let s_529_15: u64 = ((s_529_7) & (s_529_14));
        // D s_529_16: select s_529_11 s_529_13 s_529_15
        let s_529_16: u64 = if s_529_11 { s_529_13 } else { s_529_15 };
        // D s_529_17: cast trunc s_529_16 -> u8
        let s_529_17: bool = ((s_529_16) != 0);
        // D s_529_18: cast zx s_529_17 -> bv
        let s_529_18: Bits = Bits::new(s_529_17 as u128, 1u16);
        // C s_529_19: const #0u : u8
        let s_529_19: bool = false;
        // C s_529_20: cast zx s_529_19 -> bv
        let s_529_20: Bits = Bits::new(s_529_19 as u128, 1u16);
        // D s_529_21: cmp-ne s_529_18 s_529_20
        let s_529_21: bool = ((s_529_18) != (s_529_20));
        // D s_529_22: write-var gs#405156 <= s_529_21
        fn_state.gs_405156 = s_529_21;
        // N s_529_23: jump b530
        return block_530(state, tracer, fn_state);
    }
    fn block_530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_530_0: read-var gs#405156:u8
        let s_530_0: bool = fn_state.gs_405156;
        // N s_530_1: branch s_530_0 b532 b531
        if s_530_0 {
            return block_532(state, tracer, fn_state);
        } else {
            return block_531(state, tracer, fn_state);
        };
    }
    fn block_531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_531_0: read-var u#32585:u8
        let s_531_0: u8 = fn_state.u_32585;
        // D s_531_1: read-var u#32586:u8
        let s_531_1: bool = fn_state.u_32586;
        // D s_531_2: read-var u#32587:u8
        let s_531_2: bool = fn_state.u_32587;
        // D s_531_3: read-var u#32588:u8
        let s_531_3: bool = fn_state.u_32588;
        // D s_531_4: read-var u#32589:u8
        let s_531_4: u8 = fn_state.u_32589;
        // D s_531_5: read-var u#32590:u8
        let s_531_5: u8 = fn_state.u_32590;
        // D s_531_6: read-var u#32591:u8
        let s_531_6: u8 = fn_state.u_32591;
        // D s_531_7: call decode_aarch32_instrs_LDRH_r_A1enc_A_txt(s_531_0, s_531_1, s_531_2, s_531_3, s_531_4, s_531_5, s_531_6)
        let s_531_7: () = decode_aarch32_instrs_LDRH_r_A1enc_A_txt(
            state,
            tracer,
            s_531_0,
            s_531_1,
            s_531_2,
            s_531_3,
            s_531_4,
            s_531_5,
            s_531_6,
        );
        // N s_531_8: return
        return;
    }
    fn block_532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_532_0: panic
        panic!("{:?}", ());
        // N s_532_1: return
        return;
    }
    fn block_533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_533_0: const #1u : u8
        let s_533_0: bool = true;
        // D s_533_1: write-var gs#405156 <= s_533_0
        fn_state.gs_405156 = s_533_0;
        // N s_533_2: jump b530
        return block_530(state, tracer, fn_state);
    }
    fn block_534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_534_0: const #1u : u8
        let s_534_0: bool = true;
        // D s_534_1: write-var gs#405153 <= s_534_0
        fn_state.gs_405153 = s_534_0;
        // N s_534_2: jump b528
        return block_528(state, tracer, fn_state);
    }
    fn block_535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_535_0: const #1u : u8
        let s_535_0: bool = true;
        // D s_535_1: write-var gs#405150 <= s_535_0
        fn_state.gs_405150 = s_535_0;
        // N s_535_2: jump b526
        return block_526(state, tracer, fn_state);
    }
    fn block_536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_536_0: read-var merge#var.1:struct
        let s_536_0: u32 = fn_state.merge_var._1;
        // D s_536_1: write-var u#32593 <= s_536_0
        fn_state.u_32593 = s_536_0;
        // C s_536_2: const #24s : i
        let s_536_2: i128 = 24;
        // D s_536_3: read-var u#32593:u32
        let s_536_3: u32 = fn_state.u_32593;
        // D s_536_4: cast zx s_536_3 -> bv
        let s_536_4: Bits = Bits::new(s_536_3 as u128, 32u16);
        // C s_536_5: const #1s : i64
        let s_536_5: i64 = 1;
        // C s_536_6: cast zx s_536_5 -> i
        let s_536_6: i128 = (i128::try_from(s_536_5).unwrap());
        // C s_536_7: const #3s : i
        let s_536_7: i128 = 3;
        // C s_536_8: add s_536_7 s_536_6
        let s_536_8: i128 = (s_536_7 + s_536_6);
        // D s_536_9: bit-extract s_536_4 s_536_2 s_536_8
        let s_536_9: Bits = (Bits::new(
            ((s_536_4) >> (s_536_2)).value(),
            u16::try_from(s_536_8).unwrap(),
        ));
        // D s_536_10: cast reint s_536_9 -> u8
        let s_536_10: u8 = (s_536_9.value() as u8);
        // D s_536_11: cast zx s_536_10 -> bv
        let s_536_11: Bits = Bits::new(s_536_10 as u128, 4u16);
        // C s_536_12: const #0u : u8
        let s_536_12: u8 = 0;
        // C s_536_13: cast zx s_536_12 -> bv
        let s_536_13: Bits = Bits::new(s_536_12 as u128, 4u16);
        // D s_536_14: cmp-eq s_536_11 s_536_13
        let s_536_14: bool = ((s_536_11) == (s_536_13));
        // N s_536_15: branch s_536_14 b2733 b537
        if s_536_14 {
            return block_2733(state, tracer, fn_state);
        } else {
            return block_537(state, tracer, fn_state);
        };
    }
    fn block_537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_537_0: const #0u : u8
        let s_537_0: bool = false;
        // D s_537_1: write-var gs#405165 <= s_537_0
        fn_state.gs_405165 = s_537_0;
        // N s_537_2: jump b538
        return block_538(state, tracer, fn_state);
    }
    fn block_538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_538_0: read-var gs#405165:u8
        let s_538_0: bool = fn_state.gs_405165;
        // N s_538_1: branch s_538_0 b2729 b539
        if s_538_0 {
            return block_2729(state, tracer, fn_state);
        } else {
            return block_539(state, tracer, fn_state);
        };
    }
    fn block_539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_539_0: const #0u : u8
        let s_539_0: bool = false;
        // D s_539_1: write-var gs#405170 <= s_539_0
        fn_state.gs_405170 = s_539_0;
        // N s_539_2: jump b540
        return block_540(state, tracer, fn_state);
    }
    fn block_540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_540_0: read-var gs#405170:u8
        let s_540_0: bool = fn_state.gs_405170;
        // D s_540_1: not s_540_0
        let s_540_1: bool = !s_540_0;
        // N s_540_2: branch s_540_1 b542 b541
        if s_540_1 {
            return block_542(state, tracer, fn_state);
        } else {
            return block_541(state, tracer, fn_state);
        };
    }
    fn block_541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_541_0: const #2957s : i
        let s_541_0: i128 = 2957;
        // C s_541_1: const #14696u : u32
        let s_541_1: u32 = 14696;
        // N s_541_2: write-reg s_541_1 <= s_541_0
        let s_541_2: () = {
            state.write_register::<i128>(s_541_1 as isize, s_541_0);
            tracer.write_register(s_541_1 as isize, s_541_0);
        };
        // C s_541_3: const #28s : i
        let s_541_3: i128 = 28;
        // C s_541_4: const #4s : i
        let s_541_4: i128 = 4;
        // D s_541_5: read-var u#32593:u32
        let s_541_5: u32 = fn_state.u_32593;
        // D s_541_6: cast zx s_541_5 -> bv
        let s_541_6: Bits = Bits::new(s_541_5 as u128, 32u16);
        // D s_541_7: bit-extract s_541_6 s_541_3 s_541_4
        let s_541_7: Bits = (Bits::new(
            ((s_541_6) >> (s_541_3)).value(),
            u16::try_from(s_541_4).unwrap(),
        ));
        // D s_541_8: cast reint s_541_7 -> u8
        let s_541_8: u8 = (s_541_7.value() as u8);
        // C s_541_9: const #23s : i
        let s_541_9: i128 = 23;
        // C s_541_10: const #1s : i
        let s_541_10: i128 = 1;
        // D s_541_11: read-var u#32593:u32
        let s_541_11: u32 = fn_state.u_32593;
        // D s_541_12: cast zx s_541_11 -> bv
        let s_541_12: Bits = Bits::new(s_541_11 as u128, 32u16);
        // D s_541_13: bit-extract s_541_12 s_541_9 s_541_10
        let s_541_13: Bits = (Bits::new(
            ((s_541_12) >> (s_541_9)).value(),
            u16::try_from(s_541_10).unwrap(),
        ));
        // D s_541_14: cast reint s_541_13 -> u8
        let s_541_14: bool = ((s_541_13.value()) != 0);
        // C s_541_15: const #16s : i
        let s_541_15: i128 = 16;
        // C s_541_16: const #4s : i
        let s_541_16: i128 = 4;
        // D s_541_17: read-var u#32593:u32
        let s_541_17: u32 = fn_state.u_32593;
        // D s_541_18: cast zx s_541_17 -> bv
        let s_541_18: Bits = Bits::new(s_541_17 as u128, 32u16);
        // D s_541_19: bit-extract s_541_18 s_541_15 s_541_16
        let s_541_19: Bits = (Bits::new(
            ((s_541_18) >> (s_541_15)).value(),
            u16::try_from(s_541_16).unwrap(),
        ));
        // D s_541_20: cast reint s_541_19 -> u8
        let s_541_20: u8 = (s_541_19.value() as u8);
        // C s_541_21: const #12s : i
        let s_541_21: i128 = 12;
        // C s_541_22: const #4s : i
        let s_541_22: i128 = 4;
        // D s_541_23: read-var u#32593:u32
        let s_541_23: u32 = fn_state.u_32593;
        // D s_541_24: cast zx s_541_23 -> bv
        let s_541_24: Bits = Bits::new(s_541_23 as u128, 32u16);
        // D s_541_25: bit-extract s_541_24 s_541_21 s_541_22
        let s_541_25: Bits = (Bits::new(
            ((s_541_24) >> (s_541_21)).value(),
            u16::try_from(s_541_22).unwrap(),
        ));
        // D s_541_26: cast reint s_541_25 -> u8
        let s_541_26: u8 = (s_541_25.value() as u8);
        // C s_541_27: const #8s : i
        let s_541_27: i128 = 8;
        // C s_541_28: const #4s : i
        let s_541_28: i128 = 4;
        // D s_541_29: read-var u#32593:u32
        let s_541_29: u32 = fn_state.u_32593;
        // D s_541_30: cast zx s_541_29 -> bv
        let s_541_30: Bits = Bits::new(s_541_29 as u128, 32u16);
        // D s_541_31: bit-extract s_541_30 s_541_27 s_541_28
        let s_541_31: Bits = (Bits::new(
            ((s_541_30) >> (s_541_27)).value(),
            u16::try_from(s_541_28).unwrap(),
        ));
        // D s_541_32: cast reint s_541_31 -> u8
        let s_541_32: u8 = (s_541_31.value() as u8);
        // C s_541_33: const #0s : i
        let s_541_33: i128 = 0;
        // C s_541_34: const #4s : i
        let s_541_34: i128 = 4;
        // D s_541_35: read-var u#32593:u32
        let s_541_35: u32 = fn_state.u_32593;
        // D s_541_36: cast zx s_541_35 -> bv
        let s_541_36: Bits = Bits::new(s_541_35 as u128, 32u16);
        // D s_541_37: bit-extract s_541_36 s_541_33 s_541_34
        let s_541_37: Bits = (Bits::new(
            ((s_541_36) >> (s_541_33)).value(),
            u16::try_from(s_541_34).unwrap(),
        ));
        // D s_541_38: cast reint s_541_37 -> u8
        let s_541_38: u8 = (s_541_37.value() as u8);
        // D s_541_39: call decode_aarch32_instrs_LDRHT_A1enc_A_txt(s_541_8, s_541_14, s_541_20, s_541_26, s_541_32, s_541_38)
        let s_541_39: () = decode_aarch32_instrs_LDRHT_A1enc_A_txt(
            state,
            tracer,
            s_541_8,
            s_541_14,
            s_541_20,
            s_541_26,
            s_541_32,
            s_541_38,
        );
        // N s_541_40: return
        return;
    }
    fn block_542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_542_0: read-var merge#var.1:struct
        let s_542_0: u32 = fn_state.merge_var._1;
        // D s_542_1: write-var u#32601 <= s_542_0
        fn_state.u_32601 = s_542_0;
        // C s_542_2: const #24s : i
        let s_542_2: i128 = 24;
        // D s_542_3: read-var u#32601:u32
        let s_542_3: u32 = fn_state.u_32601;
        // D s_542_4: cast zx s_542_3 -> bv
        let s_542_4: Bits = Bits::new(s_542_3 as u128, 32u16);
        // C s_542_5: const #1s : i64
        let s_542_5: i64 = 1;
        // C s_542_6: cast zx s_542_5 -> i
        let s_542_6: i128 = (i128::try_from(s_542_5).unwrap());
        // C s_542_7: const #3s : i
        let s_542_7: i128 = 3;
        // C s_542_8: add s_542_7 s_542_6
        let s_542_8: i128 = (s_542_7 + s_542_6);
        // D s_542_9: bit-extract s_542_4 s_542_2 s_542_8
        let s_542_9: Bits = (Bits::new(
            ((s_542_4) >> (s_542_2)).value(),
            u16::try_from(s_542_8).unwrap(),
        ));
        // D s_542_10: cast reint s_542_9 -> u8
        let s_542_10: u8 = (s_542_9.value() as u8);
        // D s_542_11: cast zx s_542_10 -> bv
        let s_542_11: Bits = Bits::new(s_542_10 as u128, 4u16);
        // C s_542_12: const #0u : u8
        let s_542_12: u8 = 0;
        // C s_542_13: cast zx s_542_12 -> bv
        let s_542_13: Bits = Bits::new(s_542_12 as u128, 4u16);
        // D s_542_14: cmp-eq s_542_11 s_542_13
        let s_542_14: bool = ((s_542_11) == (s_542_13));
        // N s_542_15: branch s_542_14 b2725 b543
        if s_542_14 {
            return block_2725(state, tracer, fn_state);
        } else {
            return block_543(state, tracer, fn_state);
        };
    }
    fn block_543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_543_0: const #0u : u8
        let s_543_0: bool = false;
        // D s_543_1: write-var gs#405193 <= s_543_0
        fn_state.gs_405193 = s_543_0;
        // N s_543_2: jump b544
        return block_544(state, tracer, fn_state);
    }
    fn block_544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_544_0: read-var gs#405193:u8
        let s_544_0: bool = fn_state.gs_405193;
        // N s_544_1: branch s_544_0 b2721 b545
        if s_544_0 {
            return block_2721(state, tracer, fn_state);
        } else {
            return block_545(state, tracer, fn_state);
        };
    }
    fn block_545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_545_0: const #0u : u8
        let s_545_0: bool = false;
        // D s_545_1: write-var gs#405198 <= s_545_0
        fn_state.gs_405198 = s_545_0;
        // N s_545_2: jump b546
        return block_546(state, tracer, fn_state);
    }
    fn block_546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_546_0: read-var gs#405198:u8
        let s_546_0: bool = fn_state.gs_405198;
        // D s_546_1: not s_546_0
        let s_546_1: bool = !s_546_0;
        // N s_546_2: branch s_546_1 b559 b547
        if s_546_1 {
            return block_559(state, tracer, fn_state);
        } else {
            return block_547(state, tracer, fn_state);
        };
    }
    fn block_547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_547_0: const #2958s : i
        let s_547_0: i128 = 2958;
        // C s_547_1: const #14696u : u32
        let s_547_1: u32 = 14696;
        // N s_547_2: write-reg s_547_1 <= s_547_0
        let s_547_2: () = {
            state.write_register::<i128>(s_547_1 as isize, s_547_0);
            tracer.write_register(s_547_1 as isize, s_547_0);
        };
        // C s_547_3: const #28s : i
        let s_547_3: i128 = 28;
        // C s_547_4: const #4s : i
        let s_547_4: i128 = 4;
        // D s_547_5: read-var u#32601:u32
        let s_547_5: u32 = fn_state.u_32601;
        // D s_547_6: cast zx s_547_5 -> bv
        let s_547_6: Bits = Bits::new(s_547_5 as u128, 32u16);
        // D s_547_7: bit-extract s_547_6 s_547_3 s_547_4
        let s_547_7: Bits = (Bits::new(
            ((s_547_6) >> (s_547_3)).value(),
            u16::try_from(s_547_4).unwrap(),
        ));
        // D s_547_8: cast reint s_547_7 -> u8
        let s_547_8: u8 = (s_547_7.value() as u8);
        // D s_547_9: write-var u#32602 <= s_547_8
        fn_state.u_32602 = s_547_8;
        // C s_547_10: const #23s : i
        let s_547_10: i128 = 23;
        // C s_547_11: const #1s : i
        let s_547_11: i128 = 1;
        // D s_547_12: read-var u#32601:u32
        let s_547_12: u32 = fn_state.u_32601;
        // D s_547_13: cast zx s_547_12 -> bv
        let s_547_13: Bits = Bits::new(s_547_12 as u128, 32u16);
        // D s_547_14: bit-extract s_547_13 s_547_10 s_547_11
        let s_547_14: Bits = (Bits::new(
            ((s_547_13) >> (s_547_10)).value(),
            u16::try_from(s_547_11).unwrap(),
        ));
        // D s_547_15: cast reint s_547_14 -> u8
        let s_547_15: bool = ((s_547_14.value()) != 0);
        // D s_547_16: write-var u#32603 <= s_547_15
        fn_state.u_32603 = s_547_15;
        // C s_547_17: const #16s : i
        let s_547_17: i128 = 16;
        // C s_547_18: const #4s : i
        let s_547_18: i128 = 4;
        // D s_547_19: read-var u#32601:u32
        let s_547_19: u32 = fn_state.u_32601;
        // D s_547_20: cast zx s_547_19 -> bv
        let s_547_20: Bits = Bits::new(s_547_19 as u128, 32u16);
        // D s_547_21: bit-extract s_547_20 s_547_17 s_547_18
        let s_547_21: Bits = (Bits::new(
            ((s_547_20) >> (s_547_17)).value(),
            u16::try_from(s_547_18).unwrap(),
        ));
        // D s_547_22: cast reint s_547_21 -> u8
        let s_547_22: u8 = (s_547_21.value() as u8);
        // D s_547_23: write-var u#32604 <= s_547_22
        fn_state.u_32604 = s_547_22;
        // C s_547_24: const #12s : i
        let s_547_24: i128 = 12;
        // C s_547_25: const #4s : i
        let s_547_25: i128 = 4;
        // D s_547_26: read-var u#32601:u32
        let s_547_26: u32 = fn_state.u_32601;
        // D s_547_27: cast zx s_547_26 -> bv
        let s_547_27: Bits = Bits::new(s_547_26 as u128, 32u16);
        // D s_547_28: bit-extract s_547_27 s_547_24 s_547_25
        let s_547_28: Bits = (Bits::new(
            ((s_547_27) >> (s_547_24)).value(),
            u16::try_from(s_547_25).unwrap(),
        ));
        // D s_547_29: cast reint s_547_28 -> u8
        let s_547_29: u8 = (s_547_28.value() as u8);
        // D s_547_30: write-var u#32605 <= s_547_29
        fn_state.u_32605 = s_547_29;
        // C s_547_31: const #0s : i
        let s_547_31: i128 = 0;
        // C s_547_32: const #4s : i
        let s_547_32: i128 = 4;
        // D s_547_33: read-var u#32601:u32
        let s_547_33: u32 = fn_state.u_32601;
        // D s_547_34: cast zx s_547_33 -> bv
        let s_547_34: Bits = Bits::new(s_547_33 as u128, 32u16);
        // D s_547_35: bit-extract s_547_34 s_547_31 s_547_32
        let s_547_35: Bits = (Bits::new(
            ((s_547_34) >> (s_547_31)).value(),
            u16::try_from(s_547_32).unwrap(),
        ));
        // D s_547_36: cast reint s_547_35 -> u8
        let s_547_36: u8 = (s_547_35.value() as u8);
        // D s_547_37: write-var u#32606 <= s_547_36
        fn_state.u_32606 = s_547_36;
        // C s_547_38: const #8s : i
        let s_547_38: i128 = 8;
        // D s_547_39: read-var u#32601:u32
        let s_547_39: u32 = fn_state.u_32601;
        // D s_547_40: cast zx s_547_39 -> bv
        let s_547_40: Bits = Bits::new(s_547_39 as u128, 32u16);
        // C s_547_41: const #1u : u64
        let s_547_41: u64 = 1;
        // D s_547_42: bit-extract s_547_40 s_547_38 s_547_41
        let s_547_42: Bits = (Bits::new(
            ((s_547_40) >> (s_547_38)).value(),
            u16::try_from(s_547_41).unwrap(),
        ));
        // D s_547_43: cast reint s_547_42 -> u8
        let s_547_43: bool = ((s_547_42.value()) != 0);
        // C s_547_44: const #0s : i
        let s_547_44: i128 = 0;
        // C s_547_45: const #0u : u64
        let s_547_45: u64 = 0;
        // D s_547_46: cast zx s_547_43 -> u64
        let s_547_46: u64 = (s_547_43 as u64);
        // C s_547_47: const #1u : u64
        let s_547_47: u64 = 1;
        // D s_547_48: and s_547_46 s_547_47
        let s_547_48: u64 = ((s_547_46) & (s_547_47));
        // D s_547_49: cmp-eq s_547_48 s_547_47
        let s_547_49: bool = ((s_547_48) == (s_547_47));
        // D s_547_50: lsl s_547_46 s_547_44
        let s_547_50: u64 = s_547_46 << s_547_44;
        // D s_547_51: or s_547_45 s_547_50
        let s_547_51: u64 = ((s_547_45) | (s_547_50));
        // D s_547_52: cmpl s_547_50
        let s_547_52: u64 = !s_547_50;
        // D s_547_53: and s_547_45 s_547_52
        let s_547_53: u64 = ((s_547_45) & (s_547_52));
        // D s_547_54: select s_547_49 s_547_51 s_547_53
        let s_547_54: u64 = if s_547_49 { s_547_51 } else { s_547_53 };
        // D s_547_55: cast trunc s_547_54 -> u8
        let s_547_55: bool = ((s_547_54) != 0);
        // D s_547_56: cast zx s_547_55 -> bv
        let s_547_56: Bits = Bits::new(s_547_55 as u128, 1u16);
        // C s_547_57: const #0u : u8
        let s_547_57: bool = false;
        // C s_547_58: cast zx s_547_57 -> bv
        let s_547_58: Bits = Bits::new(s_547_57 as u128, 1u16);
        // D s_547_59: cmp-ne s_547_56 s_547_58
        let s_547_59: bool = ((s_547_56) != (s_547_58));
        // N s_547_60: branch s_547_59 b558 b548
        if s_547_59 {
            return block_558(state, tracer, fn_state);
        } else {
            return block_548(state, tracer, fn_state);
        };
    }
    fn block_548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_548_0: const #9s : i
        let s_548_0: i128 = 9;
        // D s_548_1: read-var u#32601:u32
        let s_548_1: u32 = fn_state.u_32601;
        // D s_548_2: cast zx s_548_1 -> bv
        let s_548_2: Bits = Bits::new(s_548_1 as u128, 32u16);
        // C s_548_3: const #1u : u64
        let s_548_3: u64 = 1;
        // D s_548_4: bit-extract s_548_2 s_548_0 s_548_3
        let s_548_4: Bits = (Bits::new(
            ((s_548_2) >> (s_548_0)).value(),
            u16::try_from(s_548_3).unwrap(),
        ));
        // D s_548_5: cast reint s_548_4 -> u8
        let s_548_5: bool = ((s_548_4.value()) != 0);
        // C s_548_6: const #0s : i
        let s_548_6: i128 = 0;
        // C s_548_7: const #0u : u64
        let s_548_7: u64 = 0;
        // D s_548_8: cast zx s_548_5 -> u64
        let s_548_8: u64 = (s_548_5 as u64);
        // C s_548_9: const #1u : u64
        let s_548_9: u64 = 1;
        // D s_548_10: and s_548_8 s_548_9
        let s_548_10: u64 = ((s_548_8) & (s_548_9));
        // D s_548_11: cmp-eq s_548_10 s_548_9
        let s_548_11: bool = ((s_548_10) == (s_548_9));
        // D s_548_12: lsl s_548_8 s_548_6
        let s_548_12: u64 = s_548_8 << s_548_6;
        // D s_548_13: or s_548_7 s_548_12
        let s_548_13: u64 = ((s_548_7) | (s_548_12));
        // D s_548_14: cmpl s_548_12
        let s_548_14: u64 = !s_548_12;
        // D s_548_15: and s_548_7 s_548_14
        let s_548_15: u64 = ((s_548_7) & (s_548_14));
        // D s_548_16: select s_548_11 s_548_13 s_548_15
        let s_548_16: u64 = if s_548_11 { s_548_13 } else { s_548_15 };
        // D s_548_17: cast trunc s_548_16 -> u8
        let s_548_17: bool = ((s_548_16) != 0);
        // D s_548_18: cast zx s_548_17 -> bv
        let s_548_18: Bits = Bits::new(s_548_17 as u128, 1u16);
        // C s_548_19: const #0u : u8
        let s_548_19: bool = false;
        // C s_548_20: cast zx s_548_19 -> bv
        let s_548_20: Bits = Bits::new(s_548_19 as u128, 1u16);
        // D s_548_21: cmp-ne s_548_18 s_548_20
        let s_548_21: bool = ((s_548_18) != (s_548_20));
        // D s_548_22: write-var gs#405215 <= s_548_21
        fn_state.gs_405215 = s_548_21;
        // N s_548_23: jump b549
        return block_549(state, tracer, fn_state);
    }
    fn block_549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_549_0: read-var gs#405215:u8
        let s_549_0: bool = fn_state.gs_405215;
        // N s_549_1: branch s_549_0 b557 b550
        if s_549_0 {
            return block_557(state, tracer, fn_state);
        } else {
            return block_550(state, tracer, fn_state);
        };
    }
    fn block_550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_550_0: const #10s : i
        let s_550_0: i128 = 10;
        // D s_550_1: read-var u#32601:u32
        let s_550_1: u32 = fn_state.u_32601;
        // D s_550_2: cast zx s_550_1 -> bv
        let s_550_2: Bits = Bits::new(s_550_1 as u128, 32u16);
        // C s_550_3: const #1u : u64
        let s_550_3: u64 = 1;
        // D s_550_4: bit-extract s_550_2 s_550_0 s_550_3
        let s_550_4: Bits = (Bits::new(
            ((s_550_2) >> (s_550_0)).value(),
            u16::try_from(s_550_3).unwrap(),
        ));
        // D s_550_5: cast reint s_550_4 -> u8
        let s_550_5: bool = ((s_550_4.value()) != 0);
        // C s_550_6: const #0s : i
        let s_550_6: i128 = 0;
        // C s_550_7: const #0u : u64
        let s_550_7: u64 = 0;
        // D s_550_8: cast zx s_550_5 -> u64
        let s_550_8: u64 = (s_550_5 as u64);
        // C s_550_9: const #1u : u64
        let s_550_9: u64 = 1;
        // D s_550_10: and s_550_8 s_550_9
        let s_550_10: u64 = ((s_550_8) & (s_550_9));
        // D s_550_11: cmp-eq s_550_10 s_550_9
        let s_550_11: bool = ((s_550_10) == (s_550_9));
        // D s_550_12: lsl s_550_8 s_550_6
        let s_550_12: u64 = s_550_8 << s_550_6;
        // D s_550_13: or s_550_7 s_550_12
        let s_550_13: u64 = ((s_550_7) | (s_550_12));
        // D s_550_14: cmpl s_550_12
        let s_550_14: u64 = !s_550_12;
        // D s_550_15: and s_550_7 s_550_14
        let s_550_15: u64 = ((s_550_7) & (s_550_14));
        // D s_550_16: select s_550_11 s_550_13 s_550_15
        let s_550_16: u64 = if s_550_11 { s_550_13 } else { s_550_15 };
        // D s_550_17: cast trunc s_550_16 -> u8
        let s_550_17: bool = ((s_550_16) != 0);
        // D s_550_18: cast zx s_550_17 -> bv
        let s_550_18: Bits = Bits::new(s_550_17 as u128, 1u16);
        // C s_550_19: const #0u : u8
        let s_550_19: bool = false;
        // C s_550_20: cast zx s_550_19 -> bv
        let s_550_20: Bits = Bits::new(s_550_19 as u128, 1u16);
        // D s_550_21: cmp-ne s_550_18 s_550_20
        let s_550_21: bool = ((s_550_18) != (s_550_20));
        // D s_550_22: write-var gs#405218 <= s_550_21
        fn_state.gs_405218 = s_550_21;
        // N s_550_23: jump b551
        return block_551(state, tracer, fn_state);
    }
    fn block_551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_551_0: read-var gs#405218:u8
        let s_551_0: bool = fn_state.gs_405218;
        // N s_551_1: branch s_551_0 b556 b552
        if s_551_0 {
            return block_556(state, tracer, fn_state);
        } else {
            return block_552(state, tracer, fn_state);
        };
    }
    fn block_552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_552_0: const #11s : i
        let s_552_0: i128 = 11;
        // D s_552_1: read-var u#32601:u32
        let s_552_1: u32 = fn_state.u_32601;
        // D s_552_2: cast zx s_552_1 -> bv
        let s_552_2: Bits = Bits::new(s_552_1 as u128, 32u16);
        // C s_552_3: const #1u : u64
        let s_552_3: u64 = 1;
        // D s_552_4: bit-extract s_552_2 s_552_0 s_552_3
        let s_552_4: Bits = (Bits::new(
            ((s_552_2) >> (s_552_0)).value(),
            u16::try_from(s_552_3).unwrap(),
        ));
        // D s_552_5: cast reint s_552_4 -> u8
        let s_552_5: bool = ((s_552_4.value()) != 0);
        // C s_552_6: const #0s : i
        let s_552_6: i128 = 0;
        // C s_552_7: const #0u : u64
        let s_552_7: u64 = 0;
        // D s_552_8: cast zx s_552_5 -> u64
        let s_552_8: u64 = (s_552_5 as u64);
        // C s_552_9: const #1u : u64
        let s_552_9: u64 = 1;
        // D s_552_10: and s_552_8 s_552_9
        let s_552_10: u64 = ((s_552_8) & (s_552_9));
        // D s_552_11: cmp-eq s_552_10 s_552_9
        let s_552_11: bool = ((s_552_10) == (s_552_9));
        // D s_552_12: lsl s_552_8 s_552_6
        let s_552_12: u64 = s_552_8 << s_552_6;
        // D s_552_13: or s_552_7 s_552_12
        let s_552_13: u64 = ((s_552_7) | (s_552_12));
        // D s_552_14: cmpl s_552_12
        let s_552_14: u64 = !s_552_12;
        // D s_552_15: and s_552_7 s_552_14
        let s_552_15: u64 = ((s_552_7) & (s_552_14));
        // D s_552_16: select s_552_11 s_552_13 s_552_15
        let s_552_16: u64 = if s_552_11 { s_552_13 } else { s_552_15 };
        // D s_552_17: cast trunc s_552_16 -> u8
        let s_552_17: bool = ((s_552_16) != 0);
        // D s_552_18: cast zx s_552_17 -> bv
        let s_552_18: Bits = Bits::new(s_552_17 as u128, 1u16);
        // C s_552_19: const #0u : u8
        let s_552_19: bool = false;
        // C s_552_20: cast zx s_552_19 -> bv
        let s_552_20: Bits = Bits::new(s_552_19 as u128, 1u16);
        // D s_552_21: cmp-ne s_552_18 s_552_20
        let s_552_21: bool = ((s_552_18) != (s_552_20));
        // D s_552_22: write-var gs#405221 <= s_552_21
        fn_state.gs_405221 = s_552_21;
        // N s_552_23: jump b553
        return block_553(state, tracer, fn_state);
    }
    fn block_553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_553_0: read-var gs#405221:u8
        let s_553_0: bool = fn_state.gs_405221;
        // N s_553_1: branch s_553_0 b555 b554
        if s_553_0 {
            return block_555(state, tracer, fn_state);
        } else {
            return block_554(state, tracer, fn_state);
        };
    }
    fn block_554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_554_0: read-var u#32602:u8
        let s_554_0: u8 = fn_state.u_32602;
        // D s_554_1: read-var u#32603:u8
        let s_554_1: bool = fn_state.u_32603;
        // D s_554_2: read-var u#32604:u8
        let s_554_2: u8 = fn_state.u_32604;
        // D s_554_3: read-var u#32605:u8
        let s_554_3: u8 = fn_state.u_32605;
        // D s_554_4: read-var u#32606:u8
        let s_554_4: u8 = fn_state.u_32606;
        // D s_554_5: call decode_aarch32_instrs_LDRHT_A2enc_A_txt(s_554_0, s_554_1, s_554_2, s_554_3, s_554_4)
        let s_554_5: () = decode_aarch32_instrs_LDRHT_A2enc_A_txt(
            state,
            tracer,
            s_554_0,
            s_554_1,
            s_554_2,
            s_554_3,
            s_554_4,
        );
        // N s_554_6: return
        return;
    }
    fn block_555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_555_0: panic
        panic!("{:?}", ());
        // N s_555_1: return
        return;
    }
    fn block_556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_556_0: const #1u : u8
        let s_556_0: bool = true;
        // D s_556_1: write-var gs#405221 <= s_556_0
        fn_state.gs_405221 = s_556_0;
        // N s_556_2: jump b553
        return block_553(state, tracer, fn_state);
    }
    fn block_557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_557_0: const #1u : u8
        let s_557_0: bool = true;
        // D s_557_1: write-var gs#405218 <= s_557_0
        fn_state.gs_405218 = s_557_0;
        // N s_557_2: jump b551
        return block_551(state, tracer, fn_state);
    }
    fn block_558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_558_0: const #1u : u8
        let s_558_0: bool = true;
        // D s_558_1: write-var gs#405215 <= s_558_0
        fn_state.gs_405215 = s_558_0;
        // N s_558_2: jump b549
        return block_549(state, tracer, fn_state);
    }
    fn block_559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_559_0: read-var merge#var.1:struct
        let s_559_0: u32 = fn_state.merge_var._1;
        // D s_559_1: write-var u#32608 <= s_559_0
        fn_state.u_32608 = s_559_0;
        // C s_559_2: const #25s : i
        let s_559_2: i128 = 25;
        // D s_559_3: read-var u#32608:u32
        let s_559_3: u32 = fn_state.u_32608;
        // D s_559_4: cast zx s_559_3 -> bv
        let s_559_4: Bits = Bits::new(s_559_3 as u128, 32u16);
        // C s_559_5: const #1s : i64
        let s_559_5: i64 = 1;
        // C s_559_6: cast zx s_559_5 -> i
        let s_559_6: i128 = (i128::try_from(s_559_5).unwrap());
        // C s_559_7: const #2s : i
        let s_559_7: i128 = 2;
        // C s_559_8: add s_559_7 s_559_6
        let s_559_8: i128 = (s_559_7 + s_559_6);
        // D s_559_9: bit-extract s_559_4 s_559_2 s_559_8
        let s_559_9: Bits = (Bits::new(
            ((s_559_4) >> (s_559_2)).value(),
            u16::try_from(s_559_8).unwrap(),
        ));
        // D s_559_10: cast reint s_559_9 -> u8
        let s_559_10: u8 = (s_559_9.value() as u8);
        // D s_559_11: cast zx s_559_10 -> bv
        let s_559_11: Bits = Bits::new(s_559_10 as u128, 3u16);
        // C s_559_12: const #0u : u8
        let s_559_12: u8 = 0;
        // C s_559_13: cast zx s_559_12 -> bv
        let s_559_13: Bits = Bits::new(s_559_12 as u128, 3u16);
        // D s_559_14: cmp-eq s_559_11 s_559_13
        let s_559_14: bool = ((s_559_11) == (s_559_13));
        // N s_559_15: branch s_559_14 b2714 b560
        if s_559_14 {
            return block_2714(state, tracer, fn_state);
        } else {
            return block_560(state, tracer, fn_state);
        };
    }
    fn block_560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_560_0: const #0u : u8
        let s_560_0: bool = false;
        // D s_560_1: write-var gs#405233 <= s_560_0
        fn_state.gs_405233 = s_560_0;
        // N s_560_2: jump b561
        return block_561(state, tracer, fn_state);
    }
    fn block_561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_561_0: read-var gs#405233:u8
        let s_561_0: bool = fn_state.gs_405233;
        // N s_561_1: branch s_561_0 b2710 b562
        if s_561_0 {
            return block_2710(state, tracer, fn_state);
        } else {
            return block_562(state, tracer, fn_state);
        };
    }
    fn block_562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_562_0: const #0u : u8
        let s_562_0: bool = false;
        // D s_562_1: write-var gs#405238 <= s_562_0
        fn_state.gs_405238 = s_562_0;
        // N s_562_2: jump b563
        return block_563(state, tracer, fn_state);
    }
    fn block_563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_563_0: read-var gs#405238:u8
        let s_563_0: bool = fn_state.gs_405238;
        // D s_563_1: not s_563_0
        let s_563_1: bool = !s_563_0;
        // N s_563_2: branch s_563_1 b565 b564
        if s_563_1 {
            return block_565(state, tracer, fn_state);
        } else {
            return block_564(state, tracer, fn_state);
        };
    }
    fn block_564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_564_0: const #2971s : i
        let s_564_0: i128 = 2971;
        // C s_564_1: const #14696u : u32
        let s_564_1: u32 = 14696;
        // N s_564_2: write-reg s_564_1 <= s_564_0
        let s_564_2: () = {
            state.write_register::<i128>(s_564_1 as isize, s_564_0);
            tracer.write_register(s_564_1 as isize, s_564_0);
        };
        // C s_564_3: const #28s : i
        let s_564_3: i128 = 28;
        // C s_564_4: const #4s : i
        let s_564_4: i128 = 4;
        // D s_564_5: read-var u#32608:u32
        let s_564_5: u32 = fn_state.u_32608;
        // D s_564_6: cast zx s_564_5 -> bv
        let s_564_6: Bits = Bits::new(s_564_5 as u128, 32u16);
        // D s_564_7: bit-extract s_564_6 s_564_3 s_564_4
        let s_564_7: Bits = (Bits::new(
            ((s_564_6) >> (s_564_3)).value(),
            u16::try_from(s_564_4).unwrap(),
        ));
        // D s_564_8: cast reint s_564_7 -> u8
        let s_564_8: u8 = (s_564_7.value() as u8);
        // C s_564_9: const #24s : i
        let s_564_9: i128 = 24;
        // C s_564_10: const #1s : i
        let s_564_10: i128 = 1;
        // D s_564_11: read-var u#32608:u32
        let s_564_11: u32 = fn_state.u_32608;
        // D s_564_12: cast zx s_564_11 -> bv
        let s_564_12: Bits = Bits::new(s_564_11 as u128, 32u16);
        // D s_564_13: bit-extract s_564_12 s_564_9 s_564_10
        let s_564_13: Bits = (Bits::new(
            ((s_564_12) >> (s_564_9)).value(),
            u16::try_from(s_564_10).unwrap(),
        ));
        // D s_564_14: cast reint s_564_13 -> u8
        let s_564_14: bool = ((s_564_13.value()) != 0);
        // C s_564_15: const #23s : i
        let s_564_15: i128 = 23;
        // C s_564_16: const #1s : i
        let s_564_16: i128 = 1;
        // D s_564_17: read-var u#32608:u32
        let s_564_17: u32 = fn_state.u_32608;
        // D s_564_18: cast zx s_564_17 -> bv
        let s_564_18: Bits = Bits::new(s_564_17 as u128, 32u16);
        // D s_564_19: bit-extract s_564_18 s_564_15 s_564_16
        let s_564_19: Bits = (Bits::new(
            ((s_564_18) >> (s_564_15)).value(),
            u16::try_from(s_564_16).unwrap(),
        ));
        // D s_564_20: cast reint s_564_19 -> u8
        let s_564_20: bool = ((s_564_19.value()) != 0);
        // C s_564_21: const #21s : i
        let s_564_21: i128 = 21;
        // C s_564_22: const #1s : i
        let s_564_22: i128 = 1;
        // D s_564_23: read-var u#32608:u32
        let s_564_23: u32 = fn_state.u_32608;
        // D s_564_24: cast zx s_564_23 -> bv
        let s_564_24: Bits = Bits::new(s_564_23 as u128, 32u16);
        // D s_564_25: bit-extract s_564_24 s_564_21 s_564_22
        let s_564_25: Bits = (Bits::new(
            ((s_564_24) >> (s_564_21)).value(),
            u16::try_from(s_564_22).unwrap(),
        ));
        // D s_564_26: cast reint s_564_25 -> u8
        let s_564_26: bool = ((s_564_25.value()) != 0);
        // C s_564_27: const #16s : i
        let s_564_27: i128 = 16;
        // C s_564_28: const #4s : i
        let s_564_28: i128 = 4;
        // D s_564_29: read-var u#32608:u32
        let s_564_29: u32 = fn_state.u_32608;
        // D s_564_30: cast zx s_564_29 -> bv
        let s_564_30: Bits = Bits::new(s_564_29 as u128, 32u16);
        // D s_564_31: bit-extract s_564_30 s_564_27 s_564_28
        let s_564_31: Bits = (Bits::new(
            ((s_564_30) >> (s_564_27)).value(),
            u16::try_from(s_564_28).unwrap(),
        ));
        // D s_564_32: cast reint s_564_31 -> u8
        let s_564_32: u8 = (s_564_31.value() as u8);
        // C s_564_33: const #12s : i
        let s_564_33: i128 = 12;
        // C s_564_34: const #4s : i
        let s_564_34: i128 = 4;
        // D s_564_35: read-var u#32608:u32
        let s_564_35: u32 = fn_state.u_32608;
        // D s_564_36: cast zx s_564_35 -> bv
        let s_564_36: Bits = Bits::new(s_564_35 as u128, 32u16);
        // D s_564_37: bit-extract s_564_36 s_564_33 s_564_34
        let s_564_37: Bits = (Bits::new(
            ((s_564_36) >> (s_564_33)).value(),
            u16::try_from(s_564_34).unwrap(),
        ));
        // D s_564_38: cast reint s_564_37 -> u8
        let s_564_38: u8 = (s_564_37.value() as u8);
        // C s_564_39: const #8s : i
        let s_564_39: i128 = 8;
        // C s_564_40: const #4s : i
        let s_564_40: i128 = 4;
        // D s_564_41: read-var u#32608:u32
        let s_564_41: u32 = fn_state.u_32608;
        // D s_564_42: cast zx s_564_41 -> bv
        let s_564_42: Bits = Bits::new(s_564_41 as u128, 32u16);
        // D s_564_43: bit-extract s_564_42 s_564_39 s_564_40
        let s_564_43: Bits = (Bits::new(
            ((s_564_42) >> (s_564_39)).value(),
            u16::try_from(s_564_40).unwrap(),
        ));
        // D s_564_44: cast reint s_564_43 -> u8
        let s_564_44: u8 = (s_564_43.value() as u8);
        // C s_564_45: const #0s : i
        let s_564_45: i128 = 0;
        // C s_564_46: const #4s : i
        let s_564_46: i128 = 4;
        // D s_564_47: read-var u#32608:u32
        let s_564_47: u32 = fn_state.u_32608;
        // D s_564_48: cast zx s_564_47 -> bv
        let s_564_48: Bits = Bits::new(s_564_47 as u128, 32u16);
        // D s_564_49: bit-extract s_564_48 s_564_45 s_564_46
        let s_564_49: Bits = (Bits::new(
            ((s_564_48) >> (s_564_45)).value(),
            u16::try_from(s_564_46).unwrap(),
        ));
        // D s_564_50: cast reint s_564_49 -> u8
        let s_564_50: u8 = (s_564_49.value() as u8);
        // D s_564_51: call decode_aarch32_instrs_LDRSB_i_A1enc_A_txt(s_564_8, s_564_14, s_564_20, s_564_26, s_564_32, s_564_38, s_564_44, s_564_50)
        let s_564_51: () = decode_aarch32_instrs_LDRSB_i_A1enc_A_txt(
            state,
            tracer,
            s_564_8,
            s_564_14,
            s_564_20,
            s_564_26,
            s_564_32,
            s_564_38,
            s_564_44,
            s_564_50,
        );
        // N s_564_52: return
        return;
    }
    fn block_565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_565_0: read-var merge#var.1:struct
        let s_565_0: u32 = fn_state.merge_var._1;
        // D s_565_1: write-var u#32618 <= s_565_0
        fn_state.u_32618 = s_565_0;
        // C s_565_2: const #25s : i
        let s_565_2: i128 = 25;
        // D s_565_3: read-var u#32618:u32
        let s_565_3: u32 = fn_state.u_32618;
        // D s_565_4: cast zx s_565_3 -> bv
        let s_565_4: Bits = Bits::new(s_565_3 as u128, 32u16);
        // C s_565_5: const #1s : i64
        let s_565_5: i64 = 1;
        // C s_565_6: cast zx s_565_5 -> i
        let s_565_6: i128 = (i128::try_from(s_565_5).unwrap());
        // C s_565_7: const #2s : i
        let s_565_7: i128 = 2;
        // C s_565_8: add s_565_7 s_565_6
        let s_565_8: i128 = (s_565_7 + s_565_6);
        // D s_565_9: bit-extract s_565_4 s_565_2 s_565_8
        let s_565_9: Bits = (Bits::new(
            ((s_565_4) >> (s_565_2)).value(),
            u16::try_from(s_565_8).unwrap(),
        ));
        // D s_565_10: cast reint s_565_9 -> u8
        let s_565_10: u8 = (s_565_9.value() as u8);
        // D s_565_11: cast zx s_565_10 -> bv
        let s_565_11: Bits = Bits::new(s_565_10 as u128, 3u16);
        // C s_565_12: const #0u : u8
        let s_565_12: u8 = 0;
        // C s_565_13: cast zx s_565_12 -> bv
        let s_565_13: Bits = Bits::new(s_565_12 as u128, 3u16);
        // D s_565_14: cmp-eq s_565_11 s_565_13
        let s_565_14: bool = ((s_565_11) == (s_565_13));
        // N s_565_15: branch s_565_14 b2703 b566
        if s_565_14 {
            return block_2703(state, tracer, fn_state);
        } else {
            return block_566(state, tracer, fn_state);
        };
    }
    fn block_566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_566_0: const #0u : u8
        let s_566_0: bool = false;
        // D s_566_1: write-var gs#405268 <= s_566_0
        fn_state.gs_405268 = s_566_0;
        // N s_566_2: jump b567
        return block_567(state, tracer, fn_state);
    }
    fn block_567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_567_0: read-var gs#405268:u8
        let s_567_0: bool = fn_state.gs_405268;
        // N s_567_1: branch s_567_0 b2699 b568
        if s_567_0 {
            return block_2699(state, tracer, fn_state);
        } else {
            return block_568(state, tracer, fn_state);
        };
    }
    fn block_568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_568_0: const #0u : u8
        let s_568_0: bool = false;
        // D s_568_1: write-var gs#405273 <= s_568_0
        fn_state.gs_405273 = s_568_0;
        // N s_568_2: jump b569
        return block_569(state, tracer, fn_state);
    }
    fn block_569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_569_0: read-var gs#405273:u8
        let s_569_0: bool = fn_state.gs_405273;
        // D s_569_1: not s_569_0
        let s_569_1: bool = !s_569_0;
        // N s_569_2: branch s_569_1 b571 b570
        if s_569_1 {
            return block_571(state, tracer, fn_state);
        } else {
            return block_570(state, tracer, fn_state);
        };
    }
    fn block_570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_570_0: const #2974s : i
        let s_570_0: i128 = 2974;
        // C s_570_1: const #14696u : u32
        let s_570_1: u32 = 14696;
        // N s_570_2: write-reg s_570_1 <= s_570_0
        let s_570_2: () = {
            state.write_register::<i128>(s_570_1 as isize, s_570_0);
            tracer.write_register(s_570_1 as isize, s_570_0);
        };
        // C s_570_3: const #28s : i
        let s_570_3: i128 = 28;
        // C s_570_4: const #4s : i
        let s_570_4: i128 = 4;
        // D s_570_5: read-var u#32618:u32
        let s_570_5: u32 = fn_state.u_32618;
        // D s_570_6: cast zx s_570_5 -> bv
        let s_570_6: Bits = Bits::new(s_570_5 as u128, 32u16);
        // D s_570_7: bit-extract s_570_6 s_570_3 s_570_4
        let s_570_7: Bits = (Bits::new(
            ((s_570_6) >> (s_570_3)).value(),
            u16::try_from(s_570_4).unwrap(),
        ));
        // D s_570_8: cast reint s_570_7 -> u8
        let s_570_8: u8 = (s_570_7.value() as u8);
        // C s_570_9: const #24s : i
        let s_570_9: i128 = 24;
        // C s_570_10: const #1s : i
        let s_570_10: i128 = 1;
        // D s_570_11: read-var u#32618:u32
        let s_570_11: u32 = fn_state.u_32618;
        // D s_570_12: cast zx s_570_11 -> bv
        let s_570_12: Bits = Bits::new(s_570_11 as u128, 32u16);
        // D s_570_13: bit-extract s_570_12 s_570_9 s_570_10
        let s_570_13: Bits = (Bits::new(
            ((s_570_12) >> (s_570_9)).value(),
            u16::try_from(s_570_10).unwrap(),
        ));
        // D s_570_14: cast reint s_570_13 -> u8
        let s_570_14: bool = ((s_570_13.value()) != 0);
        // C s_570_15: const #23s : i
        let s_570_15: i128 = 23;
        // C s_570_16: const #1s : i
        let s_570_16: i128 = 1;
        // D s_570_17: read-var u#32618:u32
        let s_570_17: u32 = fn_state.u_32618;
        // D s_570_18: cast zx s_570_17 -> bv
        let s_570_18: Bits = Bits::new(s_570_17 as u128, 32u16);
        // D s_570_19: bit-extract s_570_18 s_570_15 s_570_16
        let s_570_19: Bits = (Bits::new(
            ((s_570_18) >> (s_570_15)).value(),
            u16::try_from(s_570_16).unwrap(),
        ));
        // D s_570_20: cast reint s_570_19 -> u8
        let s_570_20: bool = ((s_570_19.value()) != 0);
        // C s_570_21: const #21s : i
        let s_570_21: i128 = 21;
        // C s_570_22: const #1s : i
        let s_570_22: i128 = 1;
        // D s_570_23: read-var u#32618:u32
        let s_570_23: u32 = fn_state.u_32618;
        // D s_570_24: cast zx s_570_23 -> bv
        let s_570_24: Bits = Bits::new(s_570_23 as u128, 32u16);
        // D s_570_25: bit-extract s_570_24 s_570_21 s_570_22
        let s_570_25: Bits = (Bits::new(
            ((s_570_24) >> (s_570_21)).value(),
            u16::try_from(s_570_22).unwrap(),
        ));
        // D s_570_26: cast reint s_570_25 -> u8
        let s_570_26: bool = ((s_570_25.value()) != 0);
        // C s_570_27: const #12s : i
        let s_570_27: i128 = 12;
        // C s_570_28: const #4s : i
        let s_570_28: i128 = 4;
        // D s_570_29: read-var u#32618:u32
        let s_570_29: u32 = fn_state.u_32618;
        // D s_570_30: cast zx s_570_29 -> bv
        let s_570_30: Bits = Bits::new(s_570_29 as u128, 32u16);
        // D s_570_31: bit-extract s_570_30 s_570_27 s_570_28
        let s_570_31: Bits = (Bits::new(
            ((s_570_30) >> (s_570_27)).value(),
            u16::try_from(s_570_28).unwrap(),
        ));
        // D s_570_32: cast reint s_570_31 -> u8
        let s_570_32: u8 = (s_570_31.value() as u8);
        // C s_570_33: const #8s : i
        let s_570_33: i128 = 8;
        // C s_570_34: const #4s : i
        let s_570_34: i128 = 4;
        // D s_570_35: read-var u#32618:u32
        let s_570_35: u32 = fn_state.u_32618;
        // D s_570_36: cast zx s_570_35 -> bv
        let s_570_36: Bits = Bits::new(s_570_35 as u128, 32u16);
        // D s_570_37: bit-extract s_570_36 s_570_33 s_570_34
        let s_570_37: Bits = (Bits::new(
            ((s_570_36) >> (s_570_33)).value(),
            u16::try_from(s_570_34).unwrap(),
        ));
        // D s_570_38: cast reint s_570_37 -> u8
        let s_570_38: u8 = (s_570_37.value() as u8);
        // C s_570_39: const #0s : i
        let s_570_39: i128 = 0;
        // C s_570_40: const #4s : i
        let s_570_40: i128 = 4;
        // D s_570_41: read-var u#32618:u32
        let s_570_41: u32 = fn_state.u_32618;
        // D s_570_42: cast zx s_570_41 -> bv
        let s_570_42: Bits = Bits::new(s_570_41 as u128, 32u16);
        // D s_570_43: bit-extract s_570_42 s_570_39 s_570_40
        let s_570_43: Bits = (Bits::new(
            ((s_570_42) >> (s_570_39)).value(),
            u16::try_from(s_570_40).unwrap(),
        ));
        // D s_570_44: cast reint s_570_43 -> u8
        let s_570_44: u8 = (s_570_43.value() as u8);
        // D s_570_45: call decode_aarch32_instrs_LDRSB_l_A1enc_A_txt(s_570_8, s_570_14, s_570_20, s_570_26, s_570_32, s_570_38, s_570_44)
        let s_570_45: () = decode_aarch32_instrs_LDRSB_l_A1enc_A_txt(
            state,
            tracer,
            s_570_8,
            s_570_14,
            s_570_20,
            s_570_26,
            s_570_32,
            s_570_38,
            s_570_44,
        );
        // N s_570_46: return
        return;
    }
    fn block_571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_571_0: read-var merge#var.1:struct
        let s_571_0: u32 = fn_state.merge_var._1;
        // D s_571_1: write-var u#32627 <= s_571_0
        fn_state.u_32627 = s_571_0;
        // C s_571_2: const #25s : i
        let s_571_2: i128 = 25;
        // D s_571_3: read-var u#32627:u32
        let s_571_3: u32 = fn_state.u_32627;
        // D s_571_4: cast zx s_571_3 -> bv
        let s_571_4: Bits = Bits::new(s_571_3 as u128, 32u16);
        // C s_571_5: const #1s : i64
        let s_571_5: i64 = 1;
        // C s_571_6: cast zx s_571_5 -> i
        let s_571_6: i128 = (i128::try_from(s_571_5).unwrap());
        // C s_571_7: const #2s : i
        let s_571_7: i128 = 2;
        // C s_571_8: add s_571_7 s_571_6
        let s_571_8: i128 = (s_571_7 + s_571_6);
        // D s_571_9: bit-extract s_571_4 s_571_2 s_571_8
        let s_571_9: Bits = (Bits::new(
            ((s_571_4) >> (s_571_2)).value(),
            u16::try_from(s_571_8).unwrap(),
        ));
        // D s_571_10: cast reint s_571_9 -> u8
        let s_571_10: u8 = (s_571_9.value() as u8);
        // D s_571_11: cast zx s_571_10 -> bv
        let s_571_11: Bits = Bits::new(s_571_10 as u128, 3u16);
        // C s_571_12: const #0u : u8
        let s_571_12: u8 = 0;
        // C s_571_13: cast zx s_571_12 -> bv
        let s_571_13: Bits = Bits::new(s_571_12 as u128, 3u16);
        // D s_571_14: cmp-eq s_571_11 s_571_13
        let s_571_14: bool = ((s_571_11) == (s_571_13));
        // N s_571_15: branch s_571_14 b2692 b572
        if s_571_14 {
            return block_2692(state, tracer, fn_state);
        } else {
            return block_572(state, tracer, fn_state);
        };
    }
    fn block_572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_572_0: const #0u : u8
        let s_572_0: bool = false;
        // D s_572_1: write-var gs#405301 <= s_572_0
        fn_state.gs_405301 = s_572_0;
        // N s_572_2: jump b573
        return block_573(state, tracer, fn_state);
    }
    fn block_573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_573_0: read-var gs#405301:u8
        let s_573_0: bool = fn_state.gs_405301;
        // N s_573_1: branch s_573_0 b2688 b574
        if s_573_0 {
            return block_2688(state, tracer, fn_state);
        } else {
            return block_574(state, tracer, fn_state);
        };
    }
    fn block_574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_574_0: const #0u : u8
        let s_574_0: bool = false;
        // D s_574_1: write-var gs#405306 <= s_574_0
        fn_state.gs_405306 = s_574_0;
        // N s_574_2: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_575_0: read-var gs#405306:u8
        let s_575_0: bool = fn_state.gs_405306;
        // D s_575_1: not s_575_0
        let s_575_1: bool = !s_575_0;
        // N s_575_2: branch s_575_1 b588 b576
        if s_575_1 {
            return block_588(state, tracer, fn_state);
        } else {
            return block_576(state, tracer, fn_state);
        };
    }
    fn block_576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_576_0: const #2976s : i
        let s_576_0: i128 = 2976;
        // C s_576_1: const #14696u : u32
        let s_576_1: u32 = 14696;
        // N s_576_2: write-reg s_576_1 <= s_576_0
        let s_576_2: () = {
            state.write_register::<i128>(s_576_1 as isize, s_576_0);
            tracer.write_register(s_576_1 as isize, s_576_0);
        };
        // C s_576_3: const #28s : i
        let s_576_3: i128 = 28;
        // C s_576_4: const #4s : i
        let s_576_4: i128 = 4;
        // D s_576_5: read-var u#32627:u32
        let s_576_5: u32 = fn_state.u_32627;
        // D s_576_6: cast zx s_576_5 -> bv
        let s_576_6: Bits = Bits::new(s_576_5 as u128, 32u16);
        // D s_576_7: bit-extract s_576_6 s_576_3 s_576_4
        let s_576_7: Bits = (Bits::new(
            ((s_576_6) >> (s_576_3)).value(),
            u16::try_from(s_576_4).unwrap(),
        ));
        // D s_576_8: cast reint s_576_7 -> u8
        let s_576_8: u8 = (s_576_7.value() as u8);
        // D s_576_9: write-var u#32628 <= s_576_8
        fn_state.u_32628 = s_576_8;
        // C s_576_10: const #24s : i
        let s_576_10: i128 = 24;
        // C s_576_11: const #1s : i
        let s_576_11: i128 = 1;
        // D s_576_12: read-var u#32627:u32
        let s_576_12: u32 = fn_state.u_32627;
        // D s_576_13: cast zx s_576_12 -> bv
        let s_576_13: Bits = Bits::new(s_576_12 as u128, 32u16);
        // D s_576_14: bit-extract s_576_13 s_576_10 s_576_11
        let s_576_14: Bits = (Bits::new(
            ((s_576_13) >> (s_576_10)).value(),
            u16::try_from(s_576_11).unwrap(),
        ));
        // D s_576_15: cast reint s_576_14 -> u8
        let s_576_15: bool = ((s_576_14.value()) != 0);
        // D s_576_16: write-var u#32629 <= s_576_15
        fn_state.u_32629 = s_576_15;
        // C s_576_17: const #23s : i
        let s_576_17: i128 = 23;
        // C s_576_18: const #1s : i
        let s_576_18: i128 = 1;
        // D s_576_19: read-var u#32627:u32
        let s_576_19: u32 = fn_state.u_32627;
        // D s_576_20: cast zx s_576_19 -> bv
        let s_576_20: Bits = Bits::new(s_576_19 as u128, 32u16);
        // D s_576_21: bit-extract s_576_20 s_576_17 s_576_18
        let s_576_21: Bits = (Bits::new(
            ((s_576_20) >> (s_576_17)).value(),
            u16::try_from(s_576_18).unwrap(),
        ));
        // D s_576_22: cast reint s_576_21 -> u8
        let s_576_22: bool = ((s_576_21.value()) != 0);
        // D s_576_23: write-var u#32630 <= s_576_22
        fn_state.u_32630 = s_576_22;
        // C s_576_24: const #21s : i
        let s_576_24: i128 = 21;
        // C s_576_25: const #1s : i
        let s_576_25: i128 = 1;
        // D s_576_26: read-var u#32627:u32
        let s_576_26: u32 = fn_state.u_32627;
        // D s_576_27: cast zx s_576_26 -> bv
        let s_576_27: Bits = Bits::new(s_576_26 as u128, 32u16);
        // D s_576_28: bit-extract s_576_27 s_576_24 s_576_25
        let s_576_28: Bits = (Bits::new(
            ((s_576_27) >> (s_576_24)).value(),
            u16::try_from(s_576_25).unwrap(),
        ));
        // D s_576_29: cast reint s_576_28 -> u8
        let s_576_29: bool = ((s_576_28.value()) != 0);
        // D s_576_30: write-var u#32631 <= s_576_29
        fn_state.u_32631 = s_576_29;
        // C s_576_31: const #16s : i
        let s_576_31: i128 = 16;
        // C s_576_32: const #4s : i
        let s_576_32: i128 = 4;
        // D s_576_33: read-var u#32627:u32
        let s_576_33: u32 = fn_state.u_32627;
        // D s_576_34: cast zx s_576_33 -> bv
        let s_576_34: Bits = Bits::new(s_576_33 as u128, 32u16);
        // D s_576_35: bit-extract s_576_34 s_576_31 s_576_32
        let s_576_35: Bits = (Bits::new(
            ((s_576_34) >> (s_576_31)).value(),
            u16::try_from(s_576_32).unwrap(),
        ));
        // D s_576_36: cast reint s_576_35 -> u8
        let s_576_36: u8 = (s_576_35.value() as u8);
        // D s_576_37: write-var u#32632 <= s_576_36
        fn_state.u_32632 = s_576_36;
        // C s_576_38: const #12s : i
        let s_576_38: i128 = 12;
        // C s_576_39: const #4s : i
        let s_576_39: i128 = 4;
        // D s_576_40: read-var u#32627:u32
        let s_576_40: u32 = fn_state.u_32627;
        // D s_576_41: cast zx s_576_40 -> bv
        let s_576_41: Bits = Bits::new(s_576_40 as u128, 32u16);
        // D s_576_42: bit-extract s_576_41 s_576_38 s_576_39
        let s_576_42: Bits = (Bits::new(
            ((s_576_41) >> (s_576_38)).value(),
            u16::try_from(s_576_39).unwrap(),
        ));
        // D s_576_43: cast reint s_576_42 -> u8
        let s_576_43: u8 = (s_576_42.value() as u8);
        // D s_576_44: write-var u#32633 <= s_576_43
        fn_state.u_32633 = s_576_43;
        // C s_576_45: const #0s : i
        let s_576_45: i128 = 0;
        // C s_576_46: const #4s : i
        let s_576_46: i128 = 4;
        // D s_576_47: read-var u#32627:u32
        let s_576_47: u32 = fn_state.u_32627;
        // D s_576_48: cast zx s_576_47 -> bv
        let s_576_48: Bits = Bits::new(s_576_47 as u128, 32u16);
        // D s_576_49: bit-extract s_576_48 s_576_45 s_576_46
        let s_576_49: Bits = (Bits::new(
            ((s_576_48) >> (s_576_45)).value(),
            u16::try_from(s_576_46).unwrap(),
        ));
        // D s_576_50: cast reint s_576_49 -> u8
        let s_576_50: u8 = (s_576_49.value() as u8);
        // D s_576_51: write-var u#32634 <= s_576_50
        fn_state.u_32634 = s_576_50;
        // C s_576_52: const #8s : i
        let s_576_52: i128 = 8;
        // D s_576_53: read-var u#32627:u32
        let s_576_53: u32 = fn_state.u_32627;
        // D s_576_54: cast zx s_576_53 -> bv
        let s_576_54: Bits = Bits::new(s_576_53 as u128, 32u16);
        // C s_576_55: const #1u : u64
        let s_576_55: u64 = 1;
        // D s_576_56: bit-extract s_576_54 s_576_52 s_576_55
        let s_576_56: Bits = (Bits::new(
            ((s_576_54) >> (s_576_52)).value(),
            u16::try_from(s_576_55).unwrap(),
        ));
        // D s_576_57: cast reint s_576_56 -> u8
        let s_576_57: bool = ((s_576_56.value()) != 0);
        // C s_576_58: const #0s : i
        let s_576_58: i128 = 0;
        // C s_576_59: const #0u : u64
        let s_576_59: u64 = 0;
        // D s_576_60: cast zx s_576_57 -> u64
        let s_576_60: u64 = (s_576_57 as u64);
        // C s_576_61: const #1u : u64
        let s_576_61: u64 = 1;
        // D s_576_62: and s_576_60 s_576_61
        let s_576_62: u64 = ((s_576_60) & (s_576_61));
        // D s_576_63: cmp-eq s_576_62 s_576_61
        let s_576_63: bool = ((s_576_62) == (s_576_61));
        // D s_576_64: lsl s_576_60 s_576_58
        let s_576_64: u64 = s_576_60 << s_576_58;
        // D s_576_65: or s_576_59 s_576_64
        let s_576_65: u64 = ((s_576_59) | (s_576_64));
        // D s_576_66: cmpl s_576_64
        let s_576_66: u64 = !s_576_64;
        // D s_576_67: and s_576_59 s_576_66
        let s_576_67: u64 = ((s_576_59) & (s_576_66));
        // D s_576_68: select s_576_63 s_576_65 s_576_67
        let s_576_68: u64 = if s_576_63 { s_576_65 } else { s_576_67 };
        // D s_576_69: cast trunc s_576_68 -> u8
        let s_576_69: bool = ((s_576_68) != 0);
        // D s_576_70: cast zx s_576_69 -> bv
        let s_576_70: Bits = Bits::new(s_576_69 as u128, 1u16);
        // C s_576_71: const #0u : u8
        let s_576_71: bool = false;
        // C s_576_72: cast zx s_576_71 -> bv
        let s_576_72: Bits = Bits::new(s_576_71 as u128, 1u16);
        // D s_576_73: cmp-ne s_576_70 s_576_72
        let s_576_73: bool = ((s_576_70) != (s_576_72));
        // N s_576_74: branch s_576_73 b587 b577
        if s_576_73 {
            return block_587(state, tracer, fn_state);
        } else {
            return block_577(state, tracer, fn_state);
        };
    }
    fn block_577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_577_0: const #9s : i
        let s_577_0: i128 = 9;
        // D s_577_1: read-var u#32627:u32
        let s_577_1: u32 = fn_state.u_32627;
        // D s_577_2: cast zx s_577_1 -> bv
        let s_577_2: Bits = Bits::new(s_577_1 as u128, 32u16);
        // C s_577_3: const #1u : u64
        let s_577_3: u64 = 1;
        // D s_577_4: bit-extract s_577_2 s_577_0 s_577_3
        let s_577_4: Bits = (Bits::new(
            ((s_577_2) >> (s_577_0)).value(),
            u16::try_from(s_577_3).unwrap(),
        ));
        // D s_577_5: cast reint s_577_4 -> u8
        let s_577_5: bool = ((s_577_4.value()) != 0);
        // C s_577_6: const #0s : i
        let s_577_6: i128 = 0;
        // C s_577_7: const #0u : u64
        let s_577_7: u64 = 0;
        // D s_577_8: cast zx s_577_5 -> u64
        let s_577_8: u64 = (s_577_5 as u64);
        // C s_577_9: const #1u : u64
        let s_577_9: u64 = 1;
        // D s_577_10: and s_577_8 s_577_9
        let s_577_10: u64 = ((s_577_8) & (s_577_9));
        // D s_577_11: cmp-eq s_577_10 s_577_9
        let s_577_11: bool = ((s_577_10) == (s_577_9));
        // D s_577_12: lsl s_577_8 s_577_6
        let s_577_12: u64 = s_577_8 << s_577_6;
        // D s_577_13: or s_577_7 s_577_12
        let s_577_13: u64 = ((s_577_7) | (s_577_12));
        // D s_577_14: cmpl s_577_12
        let s_577_14: u64 = !s_577_12;
        // D s_577_15: and s_577_7 s_577_14
        let s_577_15: u64 = ((s_577_7) & (s_577_14));
        // D s_577_16: select s_577_11 s_577_13 s_577_15
        let s_577_16: u64 = if s_577_11 { s_577_13 } else { s_577_15 };
        // D s_577_17: cast trunc s_577_16 -> u8
        let s_577_17: bool = ((s_577_16) != 0);
        // D s_577_18: cast zx s_577_17 -> bv
        let s_577_18: Bits = Bits::new(s_577_17 as u128, 1u16);
        // C s_577_19: const #0u : u8
        let s_577_19: bool = false;
        // C s_577_20: cast zx s_577_19 -> bv
        let s_577_20: Bits = Bits::new(s_577_19 as u128, 1u16);
        // D s_577_21: cmp-ne s_577_18 s_577_20
        let s_577_21: bool = ((s_577_18) != (s_577_20));
        // D s_577_22: write-var gs#405327 <= s_577_21
        fn_state.gs_405327 = s_577_21;
        // N s_577_23: jump b578
        return block_578(state, tracer, fn_state);
    }
    fn block_578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_578_0: read-var gs#405327:u8
        let s_578_0: bool = fn_state.gs_405327;
        // N s_578_1: branch s_578_0 b586 b579
        if s_578_0 {
            return block_586(state, tracer, fn_state);
        } else {
            return block_579(state, tracer, fn_state);
        };
    }
    fn block_579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_579_0: const #10s : i
        let s_579_0: i128 = 10;
        // D s_579_1: read-var u#32627:u32
        let s_579_1: u32 = fn_state.u_32627;
        // D s_579_2: cast zx s_579_1 -> bv
        let s_579_2: Bits = Bits::new(s_579_1 as u128, 32u16);
        // C s_579_3: const #1u : u64
        let s_579_3: u64 = 1;
        // D s_579_4: bit-extract s_579_2 s_579_0 s_579_3
        let s_579_4: Bits = (Bits::new(
            ((s_579_2) >> (s_579_0)).value(),
            u16::try_from(s_579_3).unwrap(),
        ));
        // D s_579_5: cast reint s_579_4 -> u8
        let s_579_5: bool = ((s_579_4.value()) != 0);
        // C s_579_6: const #0s : i
        let s_579_6: i128 = 0;
        // C s_579_7: const #0u : u64
        let s_579_7: u64 = 0;
        // D s_579_8: cast zx s_579_5 -> u64
        let s_579_8: u64 = (s_579_5 as u64);
        // C s_579_9: const #1u : u64
        let s_579_9: u64 = 1;
        // D s_579_10: and s_579_8 s_579_9
        let s_579_10: u64 = ((s_579_8) & (s_579_9));
        // D s_579_11: cmp-eq s_579_10 s_579_9
        let s_579_11: bool = ((s_579_10) == (s_579_9));
        // D s_579_12: lsl s_579_8 s_579_6
        let s_579_12: u64 = s_579_8 << s_579_6;
        // D s_579_13: or s_579_7 s_579_12
        let s_579_13: u64 = ((s_579_7) | (s_579_12));
        // D s_579_14: cmpl s_579_12
        let s_579_14: u64 = !s_579_12;
        // D s_579_15: and s_579_7 s_579_14
        let s_579_15: u64 = ((s_579_7) & (s_579_14));
        // D s_579_16: select s_579_11 s_579_13 s_579_15
        let s_579_16: u64 = if s_579_11 { s_579_13 } else { s_579_15 };
        // D s_579_17: cast trunc s_579_16 -> u8
        let s_579_17: bool = ((s_579_16) != 0);
        // D s_579_18: cast zx s_579_17 -> bv
        let s_579_18: Bits = Bits::new(s_579_17 as u128, 1u16);
        // C s_579_19: const #0u : u8
        let s_579_19: bool = false;
        // C s_579_20: cast zx s_579_19 -> bv
        let s_579_20: Bits = Bits::new(s_579_19 as u128, 1u16);
        // D s_579_21: cmp-ne s_579_18 s_579_20
        let s_579_21: bool = ((s_579_18) != (s_579_20));
        // D s_579_22: write-var gs#405330 <= s_579_21
        fn_state.gs_405330 = s_579_21;
        // N s_579_23: jump b580
        return block_580(state, tracer, fn_state);
    }
    fn block_580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_580_0: read-var gs#405330:u8
        let s_580_0: bool = fn_state.gs_405330;
        // N s_580_1: branch s_580_0 b585 b581
        if s_580_0 {
            return block_585(state, tracer, fn_state);
        } else {
            return block_581(state, tracer, fn_state);
        };
    }
    fn block_581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_581_0: const #11s : i
        let s_581_0: i128 = 11;
        // D s_581_1: read-var u#32627:u32
        let s_581_1: u32 = fn_state.u_32627;
        // D s_581_2: cast zx s_581_1 -> bv
        let s_581_2: Bits = Bits::new(s_581_1 as u128, 32u16);
        // C s_581_3: const #1u : u64
        let s_581_3: u64 = 1;
        // D s_581_4: bit-extract s_581_2 s_581_0 s_581_3
        let s_581_4: Bits = (Bits::new(
            ((s_581_2) >> (s_581_0)).value(),
            u16::try_from(s_581_3).unwrap(),
        ));
        // D s_581_5: cast reint s_581_4 -> u8
        let s_581_5: bool = ((s_581_4.value()) != 0);
        // C s_581_6: const #0s : i
        let s_581_6: i128 = 0;
        // C s_581_7: const #0u : u64
        let s_581_7: u64 = 0;
        // D s_581_8: cast zx s_581_5 -> u64
        let s_581_8: u64 = (s_581_5 as u64);
        // C s_581_9: const #1u : u64
        let s_581_9: u64 = 1;
        // D s_581_10: and s_581_8 s_581_9
        let s_581_10: u64 = ((s_581_8) & (s_581_9));
        // D s_581_11: cmp-eq s_581_10 s_581_9
        let s_581_11: bool = ((s_581_10) == (s_581_9));
        // D s_581_12: lsl s_581_8 s_581_6
        let s_581_12: u64 = s_581_8 << s_581_6;
        // D s_581_13: or s_581_7 s_581_12
        let s_581_13: u64 = ((s_581_7) | (s_581_12));
        // D s_581_14: cmpl s_581_12
        let s_581_14: u64 = !s_581_12;
        // D s_581_15: and s_581_7 s_581_14
        let s_581_15: u64 = ((s_581_7) & (s_581_14));
        // D s_581_16: select s_581_11 s_581_13 s_581_15
        let s_581_16: u64 = if s_581_11 { s_581_13 } else { s_581_15 };
        // D s_581_17: cast trunc s_581_16 -> u8
        let s_581_17: bool = ((s_581_16) != 0);
        // D s_581_18: cast zx s_581_17 -> bv
        let s_581_18: Bits = Bits::new(s_581_17 as u128, 1u16);
        // C s_581_19: const #0u : u8
        let s_581_19: bool = false;
        // C s_581_20: cast zx s_581_19 -> bv
        let s_581_20: Bits = Bits::new(s_581_19 as u128, 1u16);
        // D s_581_21: cmp-ne s_581_18 s_581_20
        let s_581_21: bool = ((s_581_18) != (s_581_20));
        // D s_581_22: write-var gs#405333 <= s_581_21
        fn_state.gs_405333 = s_581_21;
        // N s_581_23: jump b582
        return block_582(state, tracer, fn_state);
    }
    fn block_582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_582_0: read-var gs#405333:u8
        let s_582_0: bool = fn_state.gs_405333;
        // N s_582_1: branch s_582_0 b584 b583
        if s_582_0 {
            return block_584(state, tracer, fn_state);
        } else {
            return block_583(state, tracer, fn_state);
        };
    }
    fn block_583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_583_0: read-var u#32628:u8
        let s_583_0: u8 = fn_state.u_32628;
        // D s_583_1: read-var u#32629:u8
        let s_583_1: bool = fn_state.u_32629;
        // D s_583_2: read-var u#32630:u8
        let s_583_2: bool = fn_state.u_32630;
        // D s_583_3: read-var u#32631:u8
        let s_583_3: bool = fn_state.u_32631;
        // D s_583_4: read-var u#32632:u8
        let s_583_4: u8 = fn_state.u_32632;
        // D s_583_5: read-var u#32633:u8
        let s_583_5: u8 = fn_state.u_32633;
        // D s_583_6: read-var u#32634:u8
        let s_583_6: u8 = fn_state.u_32634;
        // D s_583_7: call decode_aarch32_instrs_LDRSB_r_A1enc_A_txt(s_583_0, s_583_1, s_583_2, s_583_3, s_583_4, s_583_5, s_583_6)
        let s_583_7: () = decode_aarch32_instrs_LDRSB_r_A1enc_A_txt(
            state,
            tracer,
            s_583_0,
            s_583_1,
            s_583_2,
            s_583_3,
            s_583_4,
            s_583_5,
            s_583_6,
        );
        // N s_583_8: return
        return;
    }
    fn block_584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_584_0: panic
        panic!("{:?}", ());
        // N s_584_1: return
        return;
    }
    fn block_585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_585_0: const #1u : u8
        let s_585_0: bool = true;
        // D s_585_1: write-var gs#405333 <= s_585_0
        fn_state.gs_405333 = s_585_0;
        // N s_585_2: jump b582
        return block_582(state, tracer, fn_state);
    }
    fn block_586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_586_0: const #1u : u8
        let s_586_0: bool = true;
        // D s_586_1: write-var gs#405330 <= s_586_0
        fn_state.gs_405330 = s_586_0;
        // N s_586_2: jump b580
        return block_580(state, tracer, fn_state);
    }
    fn block_587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_587_0: const #1u : u8
        let s_587_0: bool = true;
        // D s_587_1: write-var gs#405327 <= s_587_0
        fn_state.gs_405327 = s_587_0;
        // N s_587_2: jump b578
        return block_578(state, tracer, fn_state);
    }
    fn block_588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_588_0: read-var merge#var.1:struct
        let s_588_0: u32 = fn_state.merge_var._1;
        // D s_588_1: write-var u#32636 <= s_588_0
        fn_state.u_32636 = s_588_0;
        // C s_588_2: const #24s : i
        let s_588_2: i128 = 24;
        // D s_588_3: read-var u#32636:u32
        let s_588_3: u32 = fn_state.u_32636;
        // D s_588_4: cast zx s_588_3 -> bv
        let s_588_4: Bits = Bits::new(s_588_3 as u128, 32u16);
        // C s_588_5: const #1s : i64
        let s_588_5: i64 = 1;
        // C s_588_6: cast zx s_588_5 -> i
        let s_588_6: i128 = (i128::try_from(s_588_5).unwrap());
        // C s_588_7: const #3s : i
        let s_588_7: i128 = 3;
        // C s_588_8: add s_588_7 s_588_6
        let s_588_8: i128 = (s_588_7 + s_588_6);
        // D s_588_9: bit-extract s_588_4 s_588_2 s_588_8
        let s_588_9: Bits = (Bits::new(
            ((s_588_4) >> (s_588_2)).value(),
            u16::try_from(s_588_8).unwrap(),
        ));
        // D s_588_10: cast reint s_588_9 -> u8
        let s_588_10: u8 = (s_588_9.value() as u8);
        // D s_588_11: cast zx s_588_10 -> bv
        let s_588_11: Bits = Bits::new(s_588_10 as u128, 4u16);
        // C s_588_12: const #0u : u8
        let s_588_12: u8 = 0;
        // C s_588_13: cast zx s_588_12 -> bv
        let s_588_13: Bits = Bits::new(s_588_12 as u128, 4u16);
        // D s_588_14: cmp-eq s_588_11 s_588_13
        let s_588_14: bool = ((s_588_11) == (s_588_13));
        // N s_588_15: branch s_588_14 b2684 b589
        if s_588_14 {
            return block_2684(state, tracer, fn_state);
        } else {
            return block_589(state, tracer, fn_state);
        };
    }
    fn block_589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_589_0: const #0u : u8
        let s_589_0: bool = false;
        // D s_589_1: write-var gs#405342 <= s_589_0
        fn_state.gs_405342 = s_589_0;
        // N s_589_2: jump b590
        return block_590(state, tracer, fn_state);
    }
    fn block_590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_590_0: read-var gs#405342:u8
        let s_590_0: bool = fn_state.gs_405342;
        // N s_590_1: branch s_590_0 b2680 b591
        if s_590_0 {
            return block_2680(state, tracer, fn_state);
        } else {
            return block_591(state, tracer, fn_state);
        };
    }
    fn block_591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_591_0: const #0u : u8
        let s_591_0: bool = false;
        // D s_591_1: write-var gs#405347 <= s_591_0
        fn_state.gs_405347 = s_591_0;
        // N s_591_2: jump b592
        return block_592(state, tracer, fn_state);
    }
    fn block_592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_592_0: read-var gs#405347:u8
        let s_592_0: bool = fn_state.gs_405347;
        // D s_592_1: not s_592_0
        let s_592_1: bool = !s_592_0;
        // N s_592_2: branch s_592_1 b594 b593
        if s_592_1 {
            return block_594(state, tracer, fn_state);
        } else {
            return block_593(state, tracer, fn_state);
        };
    }
    fn block_593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_593_0: const #2979s : i
        let s_593_0: i128 = 2979;
        // C s_593_1: const #14696u : u32
        let s_593_1: u32 = 14696;
        // N s_593_2: write-reg s_593_1 <= s_593_0
        let s_593_2: () = {
            state.write_register::<i128>(s_593_1 as isize, s_593_0);
            tracer.write_register(s_593_1 as isize, s_593_0);
        };
        // C s_593_3: const #28s : i
        let s_593_3: i128 = 28;
        // C s_593_4: const #4s : i
        let s_593_4: i128 = 4;
        // D s_593_5: read-var u#32636:u32
        let s_593_5: u32 = fn_state.u_32636;
        // D s_593_6: cast zx s_593_5 -> bv
        let s_593_6: Bits = Bits::new(s_593_5 as u128, 32u16);
        // D s_593_7: bit-extract s_593_6 s_593_3 s_593_4
        let s_593_7: Bits = (Bits::new(
            ((s_593_6) >> (s_593_3)).value(),
            u16::try_from(s_593_4).unwrap(),
        ));
        // D s_593_8: cast reint s_593_7 -> u8
        let s_593_8: u8 = (s_593_7.value() as u8);
        // C s_593_9: const #23s : i
        let s_593_9: i128 = 23;
        // C s_593_10: const #1s : i
        let s_593_10: i128 = 1;
        // D s_593_11: read-var u#32636:u32
        let s_593_11: u32 = fn_state.u_32636;
        // D s_593_12: cast zx s_593_11 -> bv
        let s_593_12: Bits = Bits::new(s_593_11 as u128, 32u16);
        // D s_593_13: bit-extract s_593_12 s_593_9 s_593_10
        let s_593_13: Bits = (Bits::new(
            ((s_593_12) >> (s_593_9)).value(),
            u16::try_from(s_593_10).unwrap(),
        ));
        // D s_593_14: cast reint s_593_13 -> u8
        let s_593_14: bool = ((s_593_13.value()) != 0);
        // C s_593_15: const #16s : i
        let s_593_15: i128 = 16;
        // C s_593_16: const #4s : i
        let s_593_16: i128 = 4;
        // D s_593_17: read-var u#32636:u32
        let s_593_17: u32 = fn_state.u_32636;
        // D s_593_18: cast zx s_593_17 -> bv
        let s_593_18: Bits = Bits::new(s_593_17 as u128, 32u16);
        // D s_593_19: bit-extract s_593_18 s_593_15 s_593_16
        let s_593_19: Bits = (Bits::new(
            ((s_593_18) >> (s_593_15)).value(),
            u16::try_from(s_593_16).unwrap(),
        ));
        // D s_593_20: cast reint s_593_19 -> u8
        let s_593_20: u8 = (s_593_19.value() as u8);
        // C s_593_21: const #12s : i
        let s_593_21: i128 = 12;
        // C s_593_22: const #4s : i
        let s_593_22: i128 = 4;
        // D s_593_23: read-var u#32636:u32
        let s_593_23: u32 = fn_state.u_32636;
        // D s_593_24: cast zx s_593_23 -> bv
        let s_593_24: Bits = Bits::new(s_593_23 as u128, 32u16);
        // D s_593_25: bit-extract s_593_24 s_593_21 s_593_22
        let s_593_25: Bits = (Bits::new(
            ((s_593_24) >> (s_593_21)).value(),
            u16::try_from(s_593_22).unwrap(),
        ));
        // D s_593_26: cast reint s_593_25 -> u8
        let s_593_26: u8 = (s_593_25.value() as u8);
        // C s_593_27: const #8s : i
        let s_593_27: i128 = 8;
        // C s_593_28: const #4s : i
        let s_593_28: i128 = 4;
        // D s_593_29: read-var u#32636:u32
        let s_593_29: u32 = fn_state.u_32636;
        // D s_593_30: cast zx s_593_29 -> bv
        let s_593_30: Bits = Bits::new(s_593_29 as u128, 32u16);
        // D s_593_31: bit-extract s_593_30 s_593_27 s_593_28
        let s_593_31: Bits = (Bits::new(
            ((s_593_30) >> (s_593_27)).value(),
            u16::try_from(s_593_28).unwrap(),
        ));
        // D s_593_32: cast reint s_593_31 -> u8
        let s_593_32: u8 = (s_593_31.value() as u8);
        // C s_593_33: const #0s : i
        let s_593_33: i128 = 0;
        // C s_593_34: const #4s : i
        let s_593_34: i128 = 4;
        // D s_593_35: read-var u#32636:u32
        let s_593_35: u32 = fn_state.u_32636;
        // D s_593_36: cast zx s_593_35 -> bv
        let s_593_36: Bits = Bits::new(s_593_35 as u128, 32u16);
        // D s_593_37: bit-extract s_593_36 s_593_33 s_593_34
        let s_593_37: Bits = (Bits::new(
            ((s_593_36) >> (s_593_33)).value(),
            u16::try_from(s_593_34).unwrap(),
        ));
        // D s_593_38: cast reint s_593_37 -> u8
        let s_593_38: u8 = (s_593_37.value() as u8);
        // D s_593_39: call decode_aarch32_instrs_LDRSBT_A1enc_A_txt(s_593_8, s_593_14, s_593_20, s_593_26, s_593_32, s_593_38)
        let s_593_39: () = decode_aarch32_instrs_LDRSBT_A1enc_A_txt(
            state,
            tracer,
            s_593_8,
            s_593_14,
            s_593_20,
            s_593_26,
            s_593_32,
            s_593_38,
        );
        // N s_593_40: return
        return;
    }
    fn block_594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_594_0: read-var merge#var.1:struct
        let s_594_0: u32 = fn_state.merge_var._1;
        // D s_594_1: write-var u#32644 <= s_594_0
        fn_state.u_32644 = s_594_0;
        // C s_594_2: const #24s : i
        let s_594_2: i128 = 24;
        // D s_594_3: read-var u#32644:u32
        let s_594_3: u32 = fn_state.u_32644;
        // D s_594_4: cast zx s_594_3 -> bv
        let s_594_4: Bits = Bits::new(s_594_3 as u128, 32u16);
        // C s_594_5: const #1s : i64
        let s_594_5: i64 = 1;
        // C s_594_6: cast zx s_594_5 -> i
        let s_594_6: i128 = (i128::try_from(s_594_5).unwrap());
        // C s_594_7: const #3s : i
        let s_594_7: i128 = 3;
        // C s_594_8: add s_594_7 s_594_6
        let s_594_8: i128 = (s_594_7 + s_594_6);
        // D s_594_9: bit-extract s_594_4 s_594_2 s_594_8
        let s_594_9: Bits = (Bits::new(
            ((s_594_4) >> (s_594_2)).value(),
            u16::try_from(s_594_8).unwrap(),
        ));
        // D s_594_10: cast reint s_594_9 -> u8
        let s_594_10: u8 = (s_594_9.value() as u8);
        // D s_594_11: cast zx s_594_10 -> bv
        let s_594_11: Bits = Bits::new(s_594_10 as u128, 4u16);
        // C s_594_12: const #0u : u8
        let s_594_12: u8 = 0;
        // C s_594_13: cast zx s_594_12 -> bv
        let s_594_13: Bits = Bits::new(s_594_12 as u128, 4u16);
        // D s_594_14: cmp-eq s_594_11 s_594_13
        let s_594_14: bool = ((s_594_11) == (s_594_13));
        // N s_594_15: branch s_594_14 b2676 b595
        if s_594_14 {
            return block_2676(state, tracer, fn_state);
        } else {
            return block_595(state, tracer, fn_state);
        };
    }
    fn block_595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_595_0: const #0u : u8
        let s_595_0: bool = false;
        // D s_595_1: write-var gs#405370 <= s_595_0
        fn_state.gs_405370 = s_595_0;
        // N s_595_2: jump b596
        return block_596(state, tracer, fn_state);
    }
    fn block_596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_596_0: read-var gs#405370:u8
        let s_596_0: bool = fn_state.gs_405370;
        // N s_596_1: branch s_596_0 b2672 b597
        if s_596_0 {
            return block_2672(state, tracer, fn_state);
        } else {
            return block_597(state, tracer, fn_state);
        };
    }
    fn block_597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_597_0: const #0u : u8
        let s_597_0: bool = false;
        // D s_597_1: write-var gs#405375 <= s_597_0
        fn_state.gs_405375 = s_597_0;
        // N s_597_2: jump b598
        return block_598(state, tracer, fn_state);
    }
    fn block_598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_598_0: read-var gs#405375:u8
        let s_598_0: bool = fn_state.gs_405375;
        // D s_598_1: not s_598_0
        let s_598_1: bool = !s_598_0;
        // N s_598_2: branch s_598_1 b611 b599
        if s_598_1 {
            return block_611(state, tracer, fn_state);
        } else {
            return block_599(state, tracer, fn_state);
        };
    }
    fn block_599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_599_0: const #2980s : i
        let s_599_0: i128 = 2980;
        // C s_599_1: const #14696u : u32
        let s_599_1: u32 = 14696;
        // N s_599_2: write-reg s_599_1 <= s_599_0
        let s_599_2: () = {
            state.write_register::<i128>(s_599_1 as isize, s_599_0);
            tracer.write_register(s_599_1 as isize, s_599_0);
        };
        // C s_599_3: const #28s : i
        let s_599_3: i128 = 28;
        // C s_599_4: const #4s : i
        let s_599_4: i128 = 4;
        // D s_599_5: read-var u#32644:u32
        let s_599_5: u32 = fn_state.u_32644;
        // D s_599_6: cast zx s_599_5 -> bv
        let s_599_6: Bits = Bits::new(s_599_5 as u128, 32u16);
        // D s_599_7: bit-extract s_599_6 s_599_3 s_599_4
        let s_599_7: Bits = (Bits::new(
            ((s_599_6) >> (s_599_3)).value(),
            u16::try_from(s_599_4).unwrap(),
        ));
        // D s_599_8: cast reint s_599_7 -> u8
        let s_599_8: u8 = (s_599_7.value() as u8);
        // D s_599_9: write-var u#32645 <= s_599_8
        fn_state.u_32645 = s_599_8;
        // C s_599_10: const #23s : i
        let s_599_10: i128 = 23;
        // C s_599_11: const #1s : i
        let s_599_11: i128 = 1;
        // D s_599_12: read-var u#32644:u32
        let s_599_12: u32 = fn_state.u_32644;
        // D s_599_13: cast zx s_599_12 -> bv
        let s_599_13: Bits = Bits::new(s_599_12 as u128, 32u16);
        // D s_599_14: bit-extract s_599_13 s_599_10 s_599_11
        let s_599_14: Bits = (Bits::new(
            ((s_599_13) >> (s_599_10)).value(),
            u16::try_from(s_599_11).unwrap(),
        ));
        // D s_599_15: cast reint s_599_14 -> u8
        let s_599_15: bool = ((s_599_14.value()) != 0);
        // D s_599_16: write-var u#32646 <= s_599_15
        fn_state.u_32646 = s_599_15;
        // C s_599_17: const #16s : i
        let s_599_17: i128 = 16;
        // C s_599_18: const #4s : i
        let s_599_18: i128 = 4;
        // D s_599_19: read-var u#32644:u32
        let s_599_19: u32 = fn_state.u_32644;
        // D s_599_20: cast zx s_599_19 -> bv
        let s_599_20: Bits = Bits::new(s_599_19 as u128, 32u16);
        // D s_599_21: bit-extract s_599_20 s_599_17 s_599_18
        let s_599_21: Bits = (Bits::new(
            ((s_599_20) >> (s_599_17)).value(),
            u16::try_from(s_599_18).unwrap(),
        ));
        // D s_599_22: cast reint s_599_21 -> u8
        let s_599_22: u8 = (s_599_21.value() as u8);
        // D s_599_23: write-var u#32647 <= s_599_22
        fn_state.u_32647 = s_599_22;
        // C s_599_24: const #12s : i
        let s_599_24: i128 = 12;
        // C s_599_25: const #4s : i
        let s_599_25: i128 = 4;
        // D s_599_26: read-var u#32644:u32
        let s_599_26: u32 = fn_state.u_32644;
        // D s_599_27: cast zx s_599_26 -> bv
        let s_599_27: Bits = Bits::new(s_599_26 as u128, 32u16);
        // D s_599_28: bit-extract s_599_27 s_599_24 s_599_25
        let s_599_28: Bits = (Bits::new(
            ((s_599_27) >> (s_599_24)).value(),
            u16::try_from(s_599_25).unwrap(),
        ));
        // D s_599_29: cast reint s_599_28 -> u8
        let s_599_29: u8 = (s_599_28.value() as u8);
        // D s_599_30: write-var u#32648 <= s_599_29
        fn_state.u_32648 = s_599_29;
        // C s_599_31: const #0s : i
        let s_599_31: i128 = 0;
        // C s_599_32: const #4s : i
        let s_599_32: i128 = 4;
        // D s_599_33: read-var u#32644:u32
        let s_599_33: u32 = fn_state.u_32644;
        // D s_599_34: cast zx s_599_33 -> bv
        let s_599_34: Bits = Bits::new(s_599_33 as u128, 32u16);
        // D s_599_35: bit-extract s_599_34 s_599_31 s_599_32
        let s_599_35: Bits = (Bits::new(
            ((s_599_34) >> (s_599_31)).value(),
            u16::try_from(s_599_32).unwrap(),
        ));
        // D s_599_36: cast reint s_599_35 -> u8
        let s_599_36: u8 = (s_599_35.value() as u8);
        // D s_599_37: write-var u#32649 <= s_599_36
        fn_state.u_32649 = s_599_36;
        // C s_599_38: const #8s : i
        let s_599_38: i128 = 8;
        // D s_599_39: read-var u#32644:u32
        let s_599_39: u32 = fn_state.u_32644;
        // D s_599_40: cast zx s_599_39 -> bv
        let s_599_40: Bits = Bits::new(s_599_39 as u128, 32u16);
        // C s_599_41: const #1u : u64
        let s_599_41: u64 = 1;
        // D s_599_42: bit-extract s_599_40 s_599_38 s_599_41
        let s_599_42: Bits = (Bits::new(
            ((s_599_40) >> (s_599_38)).value(),
            u16::try_from(s_599_41).unwrap(),
        ));
        // D s_599_43: cast reint s_599_42 -> u8
        let s_599_43: bool = ((s_599_42.value()) != 0);
        // C s_599_44: const #0s : i
        let s_599_44: i128 = 0;
        // C s_599_45: const #0u : u64
        let s_599_45: u64 = 0;
        // D s_599_46: cast zx s_599_43 -> u64
        let s_599_46: u64 = (s_599_43 as u64);
        // C s_599_47: const #1u : u64
        let s_599_47: u64 = 1;
        // D s_599_48: and s_599_46 s_599_47
        let s_599_48: u64 = ((s_599_46) & (s_599_47));
        // D s_599_49: cmp-eq s_599_48 s_599_47
        let s_599_49: bool = ((s_599_48) == (s_599_47));
        // D s_599_50: lsl s_599_46 s_599_44
        let s_599_50: u64 = s_599_46 << s_599_44;
        // D s_599_51: or s_599_45 s_599_50
        let s_599_51: u64 = ((s_599_45) | (s_599_50));
        // D s_599_52: cmpl s_599_50
        let s_599_52: u64 = !s_599_50;
        // D s_599_53: and s_599_45 s_599_52
        let s_599_53: u64 = ((s_599_45) & (s_599_52));
        // D s_599_54: select s_599_49 s_599_51 s_599_53
        let s_599_54: u64 = if s_599_49 { s_599_51 } else { s_599_53 };
        // D s_599_55: cast trunc s_599_54 -> u8
        let s_599_55: bool = ((s_599_54) != 0);
        // D s_599_56: cast zx s_599_55 -> bv
        let s_599_56: Bits = Bits::new(s_599_55 as u128, 1u16);
        // C s_599_57: const #0u : u8
        let s_599_57: bool = false;
        // C s_599_58: cast zx s_599_57 -> bv
        let s_599_58: Bits = Bits::new(s_599_57 as u128, 1u16);
        // D s_599_59: cmp-ne s_599_56 s_599_58
        let s_599_59: bool = ((s_599_56) != (s_599_58));
        // N s_599_60: branch s_599_59 b610 b600
        if s_599_59 {
            return block_610(state, tracer, fn_state);
        } else {
            return block_600(state, tracer, fn_state);
        };
    }
    fn block_600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_600_0: const #9s : i
        let s_600_0: i128 = 9;
        // D s_600_1: read-var u#32644:u32
        let s_600_1: u32 = fn_state.u_32644;
        // D s_600_2: cast zx s_600_1 -> bv
        let s_600_2: Bits = Bits::new(s_600_1 as u128, 32u16);
        // C s_600_3: const #1u : u64
        let s_600_3: u64 = 1;
        // D s_600_4: bit-extract s_600_2 s_600_0 s_600_3
        let s_600_4: Bits = (Bits::new(
            ((s_600_2) >> (s_600_0)).value(),
            u16::try_from(s_600_3).unwrap(),
        ));
        // D s_600_5: cast reint s_600_4 -> u8
        let s_600_5: bool = ((s_600_4.value()) != 0);
        // C s_600_6: const #0s : i
        let s_600_6: i128 = 0;
        // C s_600_7: const #0u : u64
        let s_600_7: u64 = 0;
        // D s_600_8: cast zx s_600_5 -> u64
        let s_600_8: u64 = (s_600_5 as u64);
        // C s_600_9: const #1u : u64
        let s_600_9: u64 = 1;
        // D s_600_10: and s_600_8 s_600_9
        let s_600_10: u64 = ((s_600_8) & (s_600_9));
        // D s_600_11: cmp-eq s_600_10 s_600_9
        let s_600_11: bool = ((s_600_10) == (s_600_9));
        // D s_600_12: lsl s_600_8 s_600_6
        let s_600_12: u64 = s_600_8 << s_600_6;
        // D s_600_13: or s_600_7 s_600_12
        let s_600_13: u64 = ((s_600_7) | (s_600_12));
        // D s_600_14: cmpl s_600_12
        let s_600_14: u64 = !s_600_12;
        // D s_600_15: and s_600_7 s_600_14
        let s_600_15: u64 = ((s_600_7) & (s_600_14));
        // D s_600_16: select s_600_11 s_600_13 s_600_15
        let s_600_16: u64 = if s_600_11 { s_600_13 } else { s_600_15 };
        // D s_600_17: cast trunc s_600_16 -> u8
        let s_600_17: bool = ((s_600_16) != 0);
        // D s_600_18: cast zx s_600_17 -> bv
        let s_600_18: Bits = Bits::new(s_600_17 as u128, 1u16);
        // C s_600_19: const #0u : u8
        let s_600_19: bool = false;
        // C s_600_20: cast zx s_600_19 -> bv
        let s_600_20: Bits = Bits::new(s_600_19 as u128, 1u16);
        // D s_600_21: cmp-ne s_600_18 s_600_20
        let s_600_21: bool = ((s_600_18) != (s_600_20));
        // D s_600_22: write-var gs#405392 <= s_600_21
        fn_state.gs_405392 = s_600_21;
        // N s_600_23: jump b601
        return block_601(state, tracer, fn_state);
    }
    fn block_601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_601_0: read-var gs#405392:u8
        let s_601_0: bool = fn_state.gs_405392;
        // N s_601_1: branch s_601_0 b609 b602
        if s_601_0 {
            return block_609(state, tracer, fn_state);
        } else {
            return block_602(state, tracer, fn_state);
        };
    }
    fn block_602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_602_0: const #10s : i
        let s_602_0: i128 = 10;
        // D s_602_1: read-var u#32644:u32
        let s_602_1: u32 = fn_state.u_32644;
        // D s_602_2: cast zx s_602_1 -> bv
        let s_602_2: Bits = Bits::new(s_602_1 as u128, 32u16);
        // C s_602_3: const #1u : u64
        let s_602_3: u64 = 1;
        // D s_602_4: bit-extract s_602_2 s_602_0 s_602_3
        let s_602_4: Bits = (Bits::new(
            ((s_602_2) >> (s_602_0)).value(),
            u16::try_from(s_602_3).unwrap(),
        ));
        // D s_602_5: cast reint s_602_4 -> u8
        let s_602_5: bool = ((s_602_4.value()) != 0);
        // C s_602_6: const #0s : i
        let s_602_6: i128 = 0;
        // C s_602_7: const #0u : u64
        let s_602_7: u64 = 0;
        // D s_602_8: cast zx s_602_5 -> u64
        let s_602_8: u64 = (s_602_5 as u64);
        // C s_602_9: const #1u : u64
        let s_602_9: u64 = 1;
        // D s_602_10: and s_602_8 s_602_9
        let s_602_10: u64 = ((s_602_8) & (s_602_9));
        // D s_602_11: cmp-eq s_602_10 s_602_9
        let s_602_11: bool = ((s_602_10) == (s_602_9));
        // D s_602_12: lsl s_602_8 s_602_6
        let s_602_12: u64 = s_602_8 << s_602_6;
        // D s_602_13: or s_602_7 s_602_12
        let s_602_13: u64 = ((s_602_7) | (s_602_12));
        // D s_602_14: cmpl s_602_12
        let s_602_14: u64 = !s_602_12;
        // D s_602_15: and s_602_7 s_602_14
        let s_602_15: u64 = ((s_602_7) & (s_602_14));
        // D s_602_16: select s_602_11 s_602_13 s_602_15
        let s_602_16: u64 = if s_602_11 { s_602_13 } else { s_602_15 };
        // D s_602_17: cast trunc s_602_16 -> u8
        let s_602_17: bool = ((s_602_16) != 0);
        // D s_602_18: cast zx s_602_17 -> bv
        let s_602_18: Bits = Bits::new(s_602_17 as u128, 1u16);
        // C s_602_19: const #0u : u8
        let s_602_19: bool = false;
        // C s_602_20: cast zx s_602_19 -> bv
        let s_602_20: Bits = Bits::new(s_602_19 as u128, 1u16);
        // D s_602_21: cmp-ne s_602_18 s_602_20
        let s_602_21: bool = ((s_602_18) != (s_602_20));
        // D s_602_22: write-var gs#405395 <= s_602_21
        fn_state.gs_405395 = s_602_21;
        // N s_602_23: jump b603
        return block_603(state, tracer, fn_state);
    }
    fn block_603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_603_0: read-var gs#405395:u8
        let s_603_0: bool = fn_state.gs_405395;
        // N s_603_1: branch s_603_0 b608 b604
        if s_603_0 {
            return block_608(state, tracer, fn_state);
        } else {
            return block_604(state, tracer, fn_state);
        };
    }
    fn block_604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_604_0: const #11s : i
        let s_604_0: i128 = 11;
        // D s_604_1: read-var u#32644:u32
        let s_604_1: u32 = fn_state.u_32644;
        // D s_604_2: cast zx s_604_1 -> bv
        let s_604_2: Bits = Bits::new(s_604_1 as u128, 32u16);
        // C s_604_3: const #1u : u64
        let s_604_3: u64 = 1;
        // D s_604_4: bit-extract s_604_2 s_604_0 s_604_3
        let s_604_4: Bits = (Bits::new(
            ((s_604_2) >> (s_604_0)).value(),
            u16::try_from(s_604_3).unwrap(),
        ));
        // D s_604_5: cast reint s_604_4 -> u8
        let s_604_5: bool = ((s_604_4.value()) != 0);
        // C s_604_6: const #0s : i
        let s_604_6: i128 = 0;
        // C s_604_7: const #0u : u64
        let s_604_7: u64 = 0;
        // D s_604_8: cast zx s_604_5 -> u64
        let s_604_8: u64 = (s_604_5 as u64);
        // C s_604_9: const #1u : u64
        let s_604_9: u64 = 1;
        // D s_604_10: and s_604_8 s_604_9
        let s_604_10: u64 = ((s_604_8) & (s_604_9));
        // D s_604_11: cmp-eq s_604_10 s_604_9
        let s_604_11: bool = ((s_604_10) == (s_604_9));
        // D s_604_12: lsl s_604_8 s_604_6
        let s_604_12: u64 = s_604_8 << s_604_6;
        // D s_604_13: or s_604_7 s_604_12
        let s_604_13: u64 = ((s_604_7) | (s_604_12));
        // D s_604_14: cmpl s_604_12
        let s_604_14: u64 = !s_604_12;
        // D s_604_15: and s_604_7 s_604_14
        let s_604_15: u64 = ((s_604_7) & (s_604_14));
        // D s_604_16: select s_604_11 s_604_13 s_604_15
        let s_604_16: u64 = if s_604_11 { s_604_13 } else { s_604_15 };
        // D s_604_17: cast trunc s_604_16 -> u8
        let s_604_17: bool = ((s_604_16) != 0);
        // D s_604_18: cast zx s_604_17 -> bv
        let s_604_18: Bits = Bits::new(s_604_17 as u128, 1u16);
        // C s_604_19: const #0u : u8
        let s_604_19: bool = false;
        // C s_604_20: cast zx s_604_19 -> bv
        let s_604_20: Bits = Bits::new(s_604_19 as u128, 1u16);
        // D s_604_21: cmp-ne s_604_18 s_604_20
        let s_604_21: bool = ((s_604_18) != (s_604_20));
        // D s_604_22: write-var gs#405398 <= s_604_21
        fn_state.gs_405398 = s_604_21;
        // N s_604_23: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_605_0: read-var gs#405398:u8
        let s_605_0: bool = fn_state.gs_405398;
        // N s_605_1: branch s_605_0 b607 b606
        if s_605_0 {
            return block_607(state, tracer, fn_state);
        } else {
            return block_606(state, tracer, fn_state);
        };
    }
    fn block_606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_606_0: read-var u#32645:u8
        let s_606_0: u8 = fn_state.u_32645;
        // D s_606_1: read-var u#32646:u8
        let s_606_1: bool = fn_state.u_32646;
        // D s_606_2: read-var u#32647:u8
        let s_606_2: u8 = fn_state.u_32647;
        // D s_606_3: read-var u#32648:u8
        let s_606_3: u8 = fn_state.u_32648;
        // D s_606_4: read-var u#32649:u8
        let s_606_4: u8 = fn_state.u_32649;
        // D s_606_5: call decode_aarch32_instrs_LDRSBT_A2enc_A_txt(s_606_0, s_606_1, s_606_2, s_606_3, s_606_4)
        let s_606_5: () = decode_aarch32_instrs_LDRSBT_A2enc_A_txt(
            state,
            tracer,
            s_606_0,
            s_606_1,
            s_606_2,
            s_606_3,
            s_606_4,
        );
        // N s_606_6: return
        return;
    }
    fn block_607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_607_0: panic
        panic!("{:?}", ());
        // N s_607_1: return
        return;
    }
    fn block_608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_608_0: const #1u : u8
        let s_608_0: bool = true;
        // D s_608_1: write-var gs#405398 <= s_608_0
        fn_state.gs_405398 = s_608_0;
        // N s_608_2: jump b605
        return block_605(state, tracer, fn_state);
    }
    fn block_609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_609_0: const #1u : u8
        let s_609_0: bool = true;
        // D s_609_1: write-var gs#405395 <= s_609_0
        fn_state.gs_405395 = s_609_0;
        // N s_609_2: jump b603
        return block_603(state, tracer, fn_state);
    }
    fn block_610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_610_0: const #1u : u8
        let s_610_0: bool = true;
        // D s_610_1: write-var gs#405392 <= s_610_0
        fn_state.gs_405392 = s_610_0;
        // N s_610_2: jump b601
        return block_601(state, tracer, fn_state);
    }
    fn block_611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_611_0: read-var merge#var.1:struct
        let s_611_0: u32 = fn_state.merge_var._1;
        // D s_611_1: write-var u#32651 <= s_611_0
        fn_state.u_32651 = s_611_0;
        // C s_611_2: const #25s : i
        let s_611_2: i128 = 25;
        // D s_611_3: read-var u#32651:u32
        let s_611_3: u32 = fn_state.u_32651;
        // D s_611_4: cast zx s_611_3 -> bv
        let s_611_4: Bits = Bits::new(s_611_3 as u128, 32u16);
        // C s_611_5: const #1s : i64
        let s_611_5: i64 = 1;
        // C s_611_6: cast zx s_611_5 -> i
        let s_611_6: i128 = (i128::try_from(s_611_5).unwrap());
        // C s_611_7: const #2s : i
        let s_611_7: i128 = 2;
        // C s_611_8: add s_611_7 s_611_6
        let s_611_8: i128 = (s_611_7 + s_611_6);
        // D s_611_9: bit-extract s_611_4 s_611_2 s_611_8
        let s_611_9: Bits = (Bits::new(
            ((s_611_4) >> (s_611_2)).value(),
            u16::try_from(s_611_8).unwrap(),
        ));
        // D s_611_10: cast reint s_611_9 -> u8
        let s_611_10: u8 = (s_611_9.value() as u8);
        // D s_611_11: cast zx s_611_10 -> bv
        let s_611_11: Bits = Bits::new(s_611_10 as u128, 3u16);
        // C s_611_12: const #0u : u8
        let s_611_12: u8 = 0;
        // C s_611_13: cast zx s_611_12 -> bv
        let s_611_13: Bits = Bits::new(s_611_12 as u128, 3u16);
        // D s_611_14: cmp-eq s_611_11 s_611_13
        let s_611_14: bool = ((s_611_11) == (s_611_13));
        // N s_611_15: branch s_611_14 b2665 b612
        if s_611_14 {
            return block_2665(state, tracer, fn_state);
        } else {
            return block_612(state, tracer, fn_state);
        };
    }
    fn block_612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_612_0: const #0u : u8
        let s_612_0: bool = false;
        // D s_612_1: write-var gs#405410 <= s_612_0
        fn_state.gs_405410 = s_612_0;
        // N s_612_2: jump b613
        return block_613(state, tracer, fn_state);
    }
    fn block_613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_613_0: read-var gs#405410:u8
        let s_613_0: bool = fn_state.gs_405410;
        // N s_613_1: branch s_613_0 b2661 b614
        if s_613_0 {
            return block_2661(state, tracer, fn_state);
        } else {
            return block_614(state, tracer, fn_state);
        };
    }
    fn block_614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_614_0: const #0u : u8
        let s_614_0: bool = false;
        // D s_614_1: write-var gs#405415 <= s_614_0
        fn_state.gs_405415 = s_614_0;
        // N s_614_2: jump b615
        return block_615(state, tracer, fn_state);
    }
    fn block_615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_615_0: read-var gs#405415:u8
        let s_615_0: bool = fn_state.gs_405415;
        // D s_615_1: not s_615_0
        let s_615_1: bool = !s_615_0;
        // N s_615_2: branch s_615_1 b617 b616
        if s_615_1 {
            return block_617(state, tracer, fn_state);
        } else {
            return block_616(state, tracer, fn_state);
        };
    }
    fn block_616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_616_0: const #2982s : i
        let s_616_0: i128 = 2982;
        // C s_616_1: const #14696u : u32
        let s_616_1: u32 = 14696;
        // N s_616_2: write-reg s_616_1 <= s_616_0
        let s_616_2: () = {
            state.write_register::<i128>(s_616_1 as isize, s_616_0);
            tracer.write_register(s_616_1 as isize, s_616_0);
        };
        // C s_616_3: const #28s : i
        let s_616_3: i128 = 28;
        // C s_616_4: const #4s : i
        let s_616_4: i128 = 4;
        // D s_616_5: read-var u#32651:u32
        let s_616_5: u32 = fn_state.u_32651;
        // D s_616_6: cast zx s_616_5 -> bv
        let s_616_6: Bits = Bits::new(s_616_5 as u128, 32u16);
        // D s_616_7: bit-extract s_616_6 s_616_3 s_616_4
        let s_616_7: Bits = (Bits::new(
            ((s_616_6) >> (s_616_3)).value(),
            u16::try_from(s_616_4).unwrap(),
        ));
        // D s_616_8: cast reint s_616_7 -> u8
        let s_616_8: u8 = (s_616_7.value() as u8);
        // C s_616_9: const #24s : i
        let s_616_9: i128 = 24;
        // C s_616_10: const #1s : i
        let s_616_10: i128 = 1;
        // D s_616_11: read-var u#32651:u32
        let s_616_11: u32 = fn_state.u_32651;
        // D s_616_12: cast zx s_616_11 -> bv
        let s_616_12: Bits = Bits::new(s_616_11 as u128, 32u16);
        // D s_616_13: bit-extract s_616_12 s_616_9 s_616_10
        let s_616_13: Bits = (Bits::new(
            ((s_616_12) >> (s_616_9)).value(),
            u16::try_from(s_616_10).unwrap(),
        ));
        // D s_616_14: cast reint s_616_13 -> u8
        let s_616_14: bool = ((s_616_13.value()) != 0);
        // C s_616_15: const #23s : i
        let s_616_15: i128 = 23;
        // C s_616_16: const #1s : i
        let s_616_16: i128 = 1;
        // D s_616_17: read-var u#32651:u32
        let s_616_17: u32 = fn_state.u_32651;
        // D s_616_18: cast zx s_616_17 -> bv
        let s_616_18: Bits = Bits::new(s_616_17 as u128, 32u16);
        // D s_616_19: bit-extract s_616_18 s_616_15 s_616_16
        let s_616_19: Bits = (Bits::new(
            ((s_616_18) >> (s_616_15)).value(),
            u16::try_from(s_616_16).unwrap(),
        ));
        // D s_616_20: cast reint s_616_19 -> u8
        let s_616_20: bool = ((s_616_19.value()) != 0);
        // C s_616_21: const #21s : i
        let s_616_21: i128 = 21;
        // C s_616_22: const #1s : i
        let s_616_22: i128 = 1;
        // D s_616_23: read-var u#32651:u32
        let s_616_23: u32 = fn_state.u_32651;
        // D s_616_24: cast zx s_616_23 -> bv
        let s_616_24: Bits = Bits::new(s_616_23 as u128, 32u16);
        // D s_616_25: bit-extract s_616_24 s_616_21 s_616_22
        let s_616_25: Bits = (Bits::new(
            ((s_616_24) >> (s_616_21)).value(),
            u16::try_from(s_616_22).unwrap(),
        ));
        // D s_616_26: cast reint s_616_25 -> u8
        let s_616_26: bool = ((s_616_25.value()) != 0);
        // C s_616_27: const #16s : i
        let s_616_27: i128 = 16;
        // C s_616_28: const #4s : i
        let s_616_28: i128 = 4;
        // D s_616_29: read-var u#32651:u32
        let s_616_29: u32 = fn_state.u_32651;
        // D s_616_30: cast zx s_616_29 -> bv
        let s_616_30: Bits = Bits::new(s_616_29 as u128, 32u16);
        // D s_616_31: bit-extract s_616_30 s_616_27 s_616_28
        let s_616_31: Bits = (Bits::new(
            ((s_616_30) >> (s_616_27)).value(),
            u16::try_from(s_616_28).unwrap(),
        ));
        // D s_616_32: cast reint s_616_31 -> u8
        let s_616_32: u8 = (s_616_31.value() as u8);
        // C s_616_33: const #12s : i
        let s_616_33: i128 = 12;
        // C s_616_34: const #4s : i
        let s_616_34: i128 = 4;
        // D s_616_35: read-var u#32651:u32
        let s_616_35: u32 = fn_state.u_32651;
        // D s_616_36: cast zx s_616_35 -> bv
        let s_616_36: Bits = Bits::new(s_616_35 as u128, 32u16);
        // D s_616_37: bit-extract s_616_36 s_616_33 s_616_34
        let s_616_37: Bits = (Bits::new(
            ((s_616_36) >> (s_616_33)).value(),
            u16::try_from(s_616_34).unwrap(),
        ));
        // D s_616_38: cast reint s_616_37 -> u8
        let s_616_38: u8 = (s_616_37.value() as u8);
        // C s_616_39: const #8s : i
        let s_616_39: i128 = 8;
        // C s_616_40: const #4s : i
        let s_616_40: i128 = 4;
        // D s_616_41: read-var u#32651:u32
        let s_616_41: u32 = fn_state.u_32651;
        // D s_616_42: cast zx s_616_41 -> bv
        let s_616_42: Bits = Bits::new(s_616_41 as u128, 32u16);
        // D s_616_43: bit-extract s_616_42 s_616_39 s_616_40
        let s_616_43: Bits = (Bits::new(
            ((s_616_42) >> (s_616_39)).value(),
            u16::try_from(s_616_40).unwrap(),
        ));
        // D s_616_44: cast reint s_616_43 -> u8
        let s_616_44: u8 = (s_616_43.value() as u8);
        // C s_616_45: const #0s : i
        let s_616_45: i128 = 0;
        // C s_616_46: const #4s : i
        let s_616_46: i128 = 4;
        // D s_616_47: read-var u#32651:u32
        let s_616_47: u32 = fn_state.u_32651;
        // D s_616_48: cast zx s_616_47 -> bv
        let s_616_48: Bits = Bits::new(s_616_47 as u128, 32u16);
        // D s_616_49: bit-extract s_616_48 s_616_45 s_616_46
        let s_616_49: Bits = (Bits::new(
            ((s_616_48) >> (s_616_45)).value(),
            u16::try_from(s_616_46).unwrap(),
        ));
        // D s_616_50: cast reint s_616_49 -> u8
        let s_616_50: u8 = (s_616_49.value() as u8);
        // D s_616_51: call decode_aarch32_instrs_LDRSH_i_A1enc_A_txt(s_616_8, s_616_14, s_616_20, s_616_26, s_616_32, s_616_38, s_616_44, s_616_50)
        let s_616_51: () = decode_aarch32_instrs_LDRSH_i_A1enc_A_txt(
            state,
            tracer,
            s_616_8,
            s_616_14,
            s_616_20,
            s_616_26,
            s_616_32,
            s_616_38,
            s_616_44,
            s_616_50,
        );
        // N s_616_52: return
        return;
    }
    fn block_617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_617_0: read-var merge#var.1:struct
        let s_617_0: u32 = fn_state.merge_var._1;
        // D s_617_1: write-var u#32661 <= s_617_0
        fn_state.u_32661 = s_617_0;
        // C s_617_2: const #25s : i
        let s_617_2: i128 = 25;
        // D s_617_3: read-var u#32661:u32
        let s_617_3: u32 = fn_state.u_32661;
        // D s_617_4: cast zx s_617_3 -> bv
        let s_617_4: Bits = Bits::new(s_617_3 as u128, 32u16);
        // C s_617_5: const #1s : i64
        let s_617_5: i64 = 1;
        // C s_617_6: cast zx s_617_5 -> i
        let s_617_6: i128 = (i128::try_from(s_617_5).unwrap());
        // C s_617_7: const #2s : i
        let s_617_7: i128 = 2;
        // C s_617_8: add s_617_7 s_617_6
        let s_617_8: i128 = (s_617_7 + s_617_6);
        // D s_617_9: bit-extract s_617_4 s_617_2 s_617_8
        let s_617_9: Bits = (Bits::new(
            ((s_617_4) >> (s_617_2)).value(),
            u16::try_from(s_617_8).unwrap(),
        ));
        // D s_617_10: cast reint s_617_9 -> u8
        let s_617_10: u8 = (s_617_9.value() as u8);
        // D s_617_11: cast zx s_617_10 -> bv
        let s_617_11: Bits = Bits::new(s_617_10 as u128, 3u16);
        // C s_617_12: const #0u : u8
        let s_617_12: u8 = 0;
        // C s_617_13: cast zx s_617_12 -> bv
        let s_617_13: Bits = Bits::new(s_617_12 as u128, 3u16);
        // D s_617_14: cmp-eq s_617_11 s_617_13
        let s_617_14: bool = ((s_617_11) == (s_617_13));
        // N s_617_15: branch s_617_14 b2654 b618
        if s_617_14 {
            return block_2654(state, tracer, fn_state);
        } else {
            return block_618(state, tracer, fn_state);
        };
    }
    fn block_618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_618_0: const #0u : u8
        let s_618_0: bool = false;
        // D s_618_1: write-var gs#405445 <= s_618_0
        fn_state.gs_405445 = s_618_0;
        // N s_618_2: jump b619
        return block_619(state, tracer, fn_state);
    }
    fn block_619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_619_0: read-var gs#405445:u8
        let s_619_0: bool = fn_state.gs_405445;
        // N s_619_1: branch s_619_0 b2650 b620
        if s_619_0 {
            return block_2650(state, tracer, fn_state);
        } else {
            return block_620(state, tracer, fn_state);
        };
    }
    fn block_620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_620_0: const #0u : u8
        let s_620_0: bool = false;
        // D s_620_1: write-var gs#405450 <= s_620_0
        fn_state.gs_405450 = s_620_0;
        // N s_620_2: jump b621
        return block_621(state, tracer, fn_state);
    }
    fn block_621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_621_0: read-var gs#405450:u8
        let s_621_0: bool = fn_state.gs_405450;
        // D s_621_1: not s_621_0
        let s_621_1: bool = !s_621_0;
        // N s_621_2: branch s_621_1 b623 b622
        if s_621_1 {
            return block_623(state, tracer, fn_state);
        } else {
            return block_622(state, tracer, fn_state);
        };
    }
    fn block_622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_622_0: const #2985s : i
        let s_622_0: i128 = 2985;
        // C s_622_1: const #14696u : u32
        let s_622_1: u32 = 14696;
        // N s_622_2: write-reg s_622_1 <= s_622_0
        let s_622_2: () = {
            state.write_register::<i128>(s_622_1 as isize, s_622_0);
            tracer.write_register(s_622_1 as isize, s_622_0);
        };
        // C s_622_3: const #28s : i
        let s_622_3: i128 = 28;
        // C s_622_4: const #4s : i
        let s_622_4: i128 = 4;
        // D s_622_5: read-var u#32661:u32
        let s_622_5: u32 = fn_state.u_32661;
        // D s_622_6: cast zx s_622_5 -> bv
        let s_622_6: Bits = Bits::new(s_622_5 as u128, 32u16);
        // D s_622_7: bit-extract s_622_6 s_622_3 s_622_4
        let s_622_7: Bits = (Bits::new(
            ((s_622_6) >> (s_622_3)).value(),
            u16::try_from(s_622_4).unwrap(),
        ));
        // D s_622_8: cast reint s_622_7 -> u8
        let s_622_8: u8 = (s_622_7.value() as u8);
        // C s_622_9: const #24s : i
        let s_622_9: i128 = 24;
        // C s_622_10: const #1s : i
        let s_622_10: i128 = 1;
        // D s_622_11: read-var u#32661:u32
        let s_622_11: u32 = fn_state.u_32661;
        // D s_622_12: cast zx s_622_11 -> bv
        let s_622_12: Bits = Bits::new(s_622_11 as u128, 32u16);
        // D s_622_13: bit-extract s_622_12 s_622_9 s_622_10
        let s_622_13: Bits = (Bits::new(
            ((s_622_12) >> (s_622_9)).value(),
            u16::try_from(s_622_10).unwrap(),
        ));
        // D s_622_14: cast reint s_622_13 -> u8
        let s_622_14: bool = ((s_622_13.value()) != 0);
        // C s_622_15: const #23s : i
        let s_622_15: i128 = 23;
        // C s_622_16: const #1s : i
        let s_622_16: i128 = 1;
        // D s_622_17: read-var u#32661:u32
        let s_622_17: u32 = fn_state.u_32661;
        // D s_622_18: cast zx s_622_17 -> bv
        let s_622_18: Bits = Bits::new(s_622_17 as u128, 32u16);
        // D s_622_19: bit-extract s_622_18 s_622_15 s_622_16
        let s_622_19: Bits = (Bits::new(
            ((s_622_18) >> (s_622_15)).value(),
            u16::try_from(s_622_16).unwrap(),
        ));
        // D s_622_20: cast reint s_622_19 -> u8
        let s_622_20: bool = ((s_622_19.value()) != 0);
        // C s_622_21: const #21s : i
        let s_622_21: i128 = 21;
        // C s_622_22: const #1s : i
        let s_622_22: i128 = 1;
        // D s_622_23: read-var u#32661:u32
        let s_622_23: u32 = fn_state.u_32661;
        // D s_622_24: cast zx s_622_23 -> bv
        let s_622_24: Bits = Bits::new(s_622_23 as u128, 32u16);
        // D s_622_25: bit-extract s_622_24 s_622_21 s_622_22
        let s_622_25: Bits = (Bits::new(
            ((s_622_24) >> (s_622_21)).value(),
            u16::try_from(s_622_22).unwrap(),
        ));
        // D s_622_26: cast reint s_622_25 -> u8
        let s_622_26: bool = ((s_622_25.value()) != 0);
        // C s_622_27: const #12s : i
        let s_622_27: i128 = 12;
        // C s_622_28: const #4s : i
        let s_622_28: i128 = 4;
        // D s_622_29: read-var u#32661:u32
        let s_622_29: u32 = fn_state.u_32661;
        // D s_622_30: cast zx s_622_29 -> bv
        let s_622_30: Bits = Bits::new(s_622_29 as u128, 32u16);
        // D s_622_31: bit-extract s_622_30 s_622_27 s_622_28
        let s_622_31: Bits = (Bits::new(
            ((s_622_30) >> (s_622_27)).value(),
            u16::try_from(s_622_28).unwrap(),
        ));
        // D s_622_32: cast reint s_622_31 -> u8
        let s_622_32: u8 = (s_622_31.value() as u8);
        // C s_622_33: const #8s : i
        let s_622_33: i128 = 8;
        // C s_622_34: const #4s : i
        let s_622_34: i128 = 4;
        // D s_622_35: read-var u#32661:u32
        let s_622_35: u32 = fn_state.u_32661;
        // D s_622_36: cast zx s_622_35 -> bv
        let s_622_36: Bits = Bits::new(s_622_35 as u128, 32u16);
        // D s_622_37: bit-extract s_622_36 s_622_33 s_622_34
        let s_622_37: Bits = (Bits::new(
            ((s_622_36) >> (s_622_33)).value(),
            u16::try_from(s_622_34).unwrap(),
        ));
        // D s_622_38: cast reint s_622_37 -> u8
        let s_622_38: u8 = (s_622_37.value() as u8);
        // C s_622_39: const #0s : i
        let s_622_39: i128 = 0;
        // C s_622_40: const #4s : i
        let s_622_40: i128 = 4;
        // D s_622_41: read-var u#32661:u32
        let s_622_41: u32 = fn_state.u_32661;
        // D s_622_42: cast zx s_622_41 -> bv
        let s_622_42: Bits = Bits::new(s_622_41 as u128, 32u16);
        // D s_622_43: bit-extract s_622_42 s_622_39 s_622_40
        let s_622_43: Bits = (Bits::new(
            ((s_622_42) >> (s_622_39)).value(),
            u16::try_from(s_622_40).unwrap(),
        ));
        // D s_622_44: cast reint s_622_43 -> u8
        let s_622_44: u8 = (s_622_43.value() as u8);
        // D s_622_45: call decode_aarch32_instrs_LDRSH_l_A1enc_A_txt(s_622_8, s_622_14, s_622_20, s_622_26, s_622_32, s_622_38, s_622_44)
        let s_622_45: () = decode_aarch32_instrs_LDRSH_l_A1enc_A_txt(
            state,
            tracer,
            s_622_8,
            s_622_14,
            s_622_20,
            s_622_26,
            s_622_32,
            s_622_38,
            s_622_44,
        );
        // N s_622_46: return
        return;
    }
    fn block_623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_623_0: read-var merge#var.1:struct
        let s_623_0: u32 = fn_state.merge_var._1;
        // D s_623_1: write-var u#32670 <= s_623_0
        fn_state.u_32670 = s_623_0;
        // C s_623_2: const #25s : i
        let s_623_2: i128 = 25;
        // D s_623_3: read-var u#32670:u32
        let s_623_3: u32 = fn_state.u_32670;
        // D s_623_4: cast zx s_623_3 -> bv
        let s_623_4: Bits = Bits::new(s_623_3 as u128, 32u16);
        // C s_623_5: const #1s : i64
        let s_623_5: i64 = 1;
        // C s_623_6: cast zx s_623_5 -> i
        let s_623_6: i128 = (i128::try_from(s_623_5).unwrap());
        // C s_623_7: const #2s : i
        let s_623_7: i128 = 2;
        // C s_623_8: add s_623_7 s_623_6
        let s_623_8: i128 = (s_623_7 + s_623_6);
        // D s_623_9: bit-extract s_623_4 s_623_2 s_623_8
        let s_623_9: Bits = (Bits::new(
            ((s_623_4) >> (s_623_2)).value(),
            u16::try_from(s_623_8).unwrap(),
        ));
        // D s_623_10: cast reint s_623_9 -> u8
        let s_623_10: u8 = (s_623_9.value() as u8);
        // D s_623_11: cast zx s_623_10 -> bv
        let s_623_11: Bits = Bits::new(s_623_10 as u128, 3u16);
        // C s_623_12: const #0u : u8
        let s_623_12: u8 = 0;
        // C s_623_13: cast zx s_623_12 -> bv
        let s_623_13: Bits = Bits::new(s_623_12 as u128, 3u16);
        // D s_623_14: cmp-eq s_623_11 s_623_13
        let s_623_14: bool = ((s_623_11) == (s_623_13));
        // N s_623_15: branch s_623_14 b2643 b624
        if s_623_14 {
            return block_2643(state, tracer, fn_state);
        } else {
            return block_624(state, tracer, fn_state);
        };
    }
    fn block_624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_624_0: const #0u : u8
        let s_624_0: bool = false;
        // D s_624_1: write-var gs#405478 <= s_624_0
        fn_state.gs_405478 = s_624_0;
        // N s_624_2: jump b625
        return block_625(state, tracer, fn_state);
    }
    fn block_625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_625_0: read-var gs#405478:u8
        let s_625_0: bool = fn_state.gs_405478;
        // N s_625_1: branch s_625_0 b2639 b626
        if s_625_0 {
            return block_2639(state, tracer, fn_state);
        } else {
            return block_626(state, tracer, fn_state);
        };
    }
    fn block_626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_626_0: const #0u : u8
        let s_626_0: bool = false;
        // D s_626_1: write-var gs#405483 <= s_626_0
        fn_state.gs_405483 = s_626_0;
        // N s_626_2: jump b627
        return block_627(state, tracer, fn_state);
    }
    fn block_627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_627_0: read-var gs#405483:u8
        let s_627_0: bool = fn_state.gs_405483;
        // D s_627_1: not s_627_0
        let s_627_1: bool = !s_627_0;
        // N s_627_2: branch s_627_1 b640 b628
        if s_627_1 {
            return block_640(state, tracer, fn_state);
        } else {
            return block_628(state, tracer, fn_state);
        };
    }
    fn block_628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_628_0: const #2987s : i
        let s_628_0: i128 = 2987;
        // C s_628_1: const #14696u : u32
        let s_628_1: u32 = 14696;
        // N s_628_2: write-reg s_628_1 <= s_628_0
        let s_628_2: () = {
            state.write_register::<i128>(s_628_1 as isize, s_628_0);
            tracer.write_register(s_628_1 as isize, s_628_0);
        };
        // C s_628_3: const #28s : i
        let s_628_3: i128 = 28;
        // C s_628_4: const #4s : i
        let s_628_4: i128 = 4;
        // D s_628_5: read-var u#32670:u32
        let s_628_5: u32 = fn_state.u_32670;
        // D s_628_6: cast zx s_628_5 -> bv
        let s_628_6: Bits = Bits::new(s_628_5 as u128, 32u16);
        // D s_628_7: bit-extract s_628_6 s_628_3 s_628_4
        let s_628_7: Bits = (Bits::new(
            ((s_628_6) >> (s_628_3)).value(),
            u16::try_from(s_628_4).unwrap(),
        ));
        // D s_628_8: cast reint s_628_7 -> u8
        let s_628_8: u8 = (s_628_7.value() as u8);
        // D s_628_9: write-var u#32671 <= s_628_8
        fn_state.u_32671 = s_628_8;
        // C s_628_10: const #24s : i
        let s_628_10: i128 = 24;
        // C s_628_11: const #1s : i
        let s_628_11: i128 = 1;
        // D s_628_12: read-var u#32670:u32
        let s_628_12: u32 = fn_state.u_32670;
        // D s_628_13: cast zx s_628_12 -> bv
        let s_628_13: Bits = Bits::new(s_628_12 as u128, 32u16);
        // D s_628_14: bit-extract s_628_13 s_628_10 s_628_11
        let s_628_14: Bits = (Bits::new(
            ((s_628_13) >> (s_628_10)).value(),
            u16::try_from(s_628_11).unwrap(),
        ));
        // D s_628_15: cast reint s_628_14 -> u8
        let s_628_15: bool = ((s_628_14.value()) != 0);
        // D s_628_16: write-var u#32672 <= s_628_15
        fn_state.u_32672 = s_628_15;
        // C s_628_17: const #23s : i
        let s_628_17: i128 = 23;
        // C s_628_18: const #1s : i
        let s_628_18: i128 = 1;
        // D s_628_19: read-var u#32670:u32
        let s_628_19: u32 = fn_state.u_32670;
        // D s_628_20: cast zx s_628_19 -> bv
        let s_628_20: Bits = Bits::new(s_628_19 as u128, 32u16);
        // D s_628_21: bit-extract s_628_20 s_628_17 s_628_18
        let s_628_21: Bits = (Bits::new(
            ((s_628_20) >> (s_628_17)).value(),
            u16::try_from(s_628_18).unwrap(),
        ));
        // D s_628_22: cast reint s_628_21 -> u8
        let s_628_22: bool = ((s_628_21.value()) != 0);
        // D s_628_23: write-var u#32673 <= s_628_22
        fn_state.u_32673 = s_628_22;
        // C s_628_24: const #21s : i
        let s_628_24: i128 = 21;
        // C s_628_25: const #1s : i
        let s_628_25: i128 = 1;
        // D s_628_26: read-var u#32670:u32
        let s_628_26: u32 = fn_state.u_32670;
        // D s_628_27: cast zx s_628_26 -> bv
        let s_628_27: Bits = Bits::new(s_628_26 as u128, 32u16);
        // D s_628_28: bit-extract s_628_27 s_628_24 s_628_25
        let s_628_28: Bits = (Bits::new(
            ((s_628_27) >> (s_628_24)).value(),
            u16::try_from(s_628_25).unwrap(),
        ));
        // D s_628_29: cast reint s_628_28 -> u8
        let s_628_29: bool = ((s_628_28.value()) != 0);
        // D s_628_30: write-var u#32674 <= s_628_29
        fn_state.u_32674 = s_628_29;
        // C s_628_31: const #16s : i
        let s_628_31: i128 = 16;
        // C s_628_32: const #4s : i
        let s_628_32: i128 = 4;
        // D s_628_33: read-var u#32670:u32
        let s_628_33: u32 = fn_state.u_32670;
        // D s_628_34: cast zx s_628_33 -> bv
        let s_628_34: Bits = Bits::new(s_628_33 as u128, 32u16);
        // D s_628_35: bit-extract s_628_34 s_628_31 s_628_32
        let s_628_35: Bits = (Bits::new(
            ((s_628_34) >> (s_628_31)).value(),
            u16::try_from(s_628_32).unwrap(),
        ));
        // D s_628_36: cast reint s_628_35 -> u8
        let s_628_36: u8 = (s_628_35.value() as u8);
        // D s_628_37: write-var u#32675 <= s_628_36
        fn_state.u_32675 = s_628_36;
        // C s_628_38: const #12s : i
        let s_628_38: i128 = 12;
        // C s_628_39: const #4s : i
        let s_628_39: i128 = 4;
        // D s_628_40: read-var u#32670:u32
        let s_628_40: u32 = fn_state.u_32670;
        // D s_628_41: cast zx s_628_40 -> bv
        let s_628_41: Bits = Bits::new(s_628_40 as u128, 32u16);
        // D s_628_42: bit-extract s_628_41 s_628_38 s_628_39
        let s_628_42: Bits = (Bits::new(
            ((s_628_41) >> (s_628_38)).value(),
            u16::try_from(s_628_39).unwrap(),
        ));
        // D s_628_43: cast reint s_628_42 -> u8
        let s_628_43: u8 = (s_628_42.value() as u8);
        // D s_628_44: write-var u#32676 <= s_628_43
        fn_state.u_32676 = s_628_43;
        // C s_628_45: const #0s : i
        let s_628_45: i128 = 0;
        // C s_628_46: const #4s : i
        let s_628_46: i128 = 4;
        // D s_628_47: read-var u#32670:u32
        let s_628_47: u32 = fn_state.u_32670;
        // D s_628_48: cast zx s_628_47 -> bv
        let s_628_48: Bits = Bits::new(s_628_47 as u128, 32u16);
        // D s_628_49: bit-extract s_628_48 s_628_45 s_628_46
        let s_628_49: Bits = (Bits::new(
            ((s_628_48) >> (s_628_45)).value(),
            u16::try_from(s_628_46).unwrap(),
        ));
        // D s_628_50: cast reint s_628_49 -> u8
        let s_628_50: u8 = (s_628_49.value() as u8);
        // D s_628_51: write-var u#32677 <= s_628_50
        fn_state.u_32677 = s_628_50;
        // C s_628_52: const #8s : i
        let s_628_52: i128 = 8;
        // D s_628_53: read-var u#32670:u32
        let s_628_53: u32 = fn_state.u_32670;
        // D s_628_54: cast zx s_628_53 -> bv
        let s_628_54: Bits = Bits::new(s_628_53 as u128, 32u16);
        // C s_628_55: const #1u : u64
        let s_628_55: u64 = 1;
        // D s_628_56: bit-extract s_628_54 s_628_52 s_628_55
        let s_628_56: Bits = (Bits::new(
            ((s_628_54) >> (s_628_52)).value(),
            u16::try_from(s_628_55).unwrap(),
        ));
        // D s_628_57: cast reint s_628_56 -> u8
        let s_628_57: bool = ((s_628_56.value()) != 0);
        // C s_628_58: const #0s : i
        let s_628_58: i128 = 0;
        // C s_628_59: const #0u : u64
        let s_628_59: u64 = 0;
        // D s_628_60: cast zx s_628_57 -> u64
        let s_628_60: u64 = (s_628_57 as u64);
        // C s_628_61: const #1u : u64
        let s_628_61: u64 = 1;
        // D s_628_62: and s_628_60 s_628_61
        let s_628_62: u64 = ((s_628_60) & (s_628_61));
        // D s_628_63: cmp-eq s_628_62 s_628_61
        let s_628_63: bool = ((s_628_62) == (s_628_61));
        // D s_628_64: lsl s_628_60 s_628_58
        let s_628_64: u64 = s_628_60 << s_628_58;
        // D s_628_65: or s_628_59 s_628_64
        let s_628_65: u64 = ((s_628_59) | (s_628_64));
        // D s_628_66: cmpl s_628_64
        let s_628_66: u64 = !s_628_64;
        // D s_628_67: and s_628_59 s_628_66
        let s_628_67: u64 = ((s_628_59) & (s_628_66));
        // D s_628_68: select s_628_63 s_628_65 s_628_67
        let s_628_68: u64 = if s_628_63 { s_628_65 } else { s_628_67 };
        // D s_628_69: cast trunc s_628_68 -> u8
        let s_628_69: bool = ((s_628_68) != 0);
        // D s_628_70: cast zx s_628_69 -> bv
        let s_628_70: Bits = Bits::new(s_628_69 as u128, 1u16);
        // C s_628_71: const #0u : u8
        let s_628_71: bool = false;
        // C s_628_72: cast zx s_628_71 -> bv
        let s_628_72: Bits = Bits::new(s_628_71 as u128, 1u16);
        // D s_628_73: cmp-ne s_628_70 s_628_72
        let s_628_73: bool = ((s_628_70) != (s_628_72));
        // N s_628_74: branch s_628_73 b639 b629
        if s_628_73 {
            return block_639(state, tracer, fn_state);
        } else {
            return block_629(state, tracer, fn_state);
        };
    }
    fn block_629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_629_0: const #9s : i
        let s_629_0: i128 = 9;
        // D s_629_1: read-var u#32670:u32
        let s_629_1: u32 = fn_state.u_32670;
        // D s_629_2: cast zx s_629_1 -> bv
        let s_629_2: Bits = Bits::new(s_629_1 as u128, 32u16);
        // C s_629_3: const #1u : u64
        let s_629_3: u64 = 1;
        // D s_629_4: bit-extract s_629_2 s_629_0 s_629_3
        let s_629_4: Bits = (Bits::new(
            ((s_629_2) >> (s_629_0)).value(),
            u16::try_from(s_629_3).unwrap(),
        ));
        // D s_629_5: cast reint s_629_4 -> u8
        let s_629_5: bool = ((s_629_4.value()) != 0);
        // C s_629_6: const #0s : i
        let s_629_6: i128 = 0;
        // C s_629_7: const #0u : u64
        let s_629_7: u64 = 0;
        // D s_629_8: cast zx s_629_5 -> u64
        let s_629_8: u64 = (s_629_5 as u64);
        // C s_629_9: const #1u : u64
        let s_629_9: u64 = 1;
        // D s_629_10: and s_629_8 s_629_9
        let s_629_10: u64 = ((s_629_8) & (s_629_9));
        // D s_629_11: cmp-eq s_629_10 s_629_9
        let s_629_11: bool = ((s_629_10) == (s_629_9));
        // D s_629_12: lsl s_629_8 s_629_6
        let s_629_12: u64 = s_629_8 << s_629_6;
        // D s_629_13: or s_629_7 s_629_12
        let s_629_13: u64 = ((s_629_7) | (s_629_12));
        // D s_629_14: cmpl s_629_12
        let s_629_14: u64 = !s_629_12;
        // D s_629_15: and s_629_7 s_629_14
        let s_629_15: u64 = ((s_629_7) & (s_629_14));
        // D s_629_16: select s_629_11 s_629_13 s_629_15
        let s_629_16: u64 = if s_629_11 { s_629_13 } else { s_629_15 };
        // D s_629_17: cast trunc s_629_16 -> u8
        let s_629_17: bool = ((s_629_16) != 0);
        // D s_629_18: cast zx s_629_17 -> bv
        let s_629_18: Bits = Bits::new(s_629_17 as u128, 1u16);
        // C s_629_19: const #0u : u8
        let s_629_19: bool = false;
        // C s_629_20: cast zx s_629_19 -> bv
        let s_629_20: Bits = Bits::new(s_629_19 as u128, 1u16);
        // D s_629_21: cmp-ne s_629_18 s_629_20
        let s_629_21: bool = ((s_629_18) != (s_629_20));
        // D s_629_22: write-var gs#405504 <= s_629_21
        fn_state.gs_405504 = s_629_21;
        // N s_629_23: jump b630
        return block_630(state, tracer, fn_state);
    }
    fn block_630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_630_0: read-var gs#405504:u8
        let s_630_0: bool = fn_state.gs_405504;
        // N s_630_1: branch s_630_0 b638 b631
        if s_630_0 {
            return block_638(state, tracer, fn_state);
        } else {
            return block_631(state, tracer, fn_state);
        };
    }
    fn block_631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_631_0: const #10s : i
        let s_631_0: i128 = 10;
        // D s_631_1: read-var u#32670:u32
        let s_631_1: u32 = fn_state.u_32670;
        // D s_631_2: cast zx s_631_1 -> bv
        let s_631_2: Bits = Bits::new(s_631_1 as u128, 32u16);
        // C s_631_3: const #1u : u64
        let s_631_3: u64 = 1;
        // D s_631_4: bit-extract s_631_2 s_631_0 s_631_3
        let s_631_4: Bits = (Bits::new(
            ((s_631_2) >> (s_631_0)).value(),
            u16::try_from(s_631_3).unwrap(),
        ));
        // D s_631_5: cast reint s_631_4 -> u8
        let s_631_5: bool = ((s_631_4.value()) != 0);
        // C s_631_6: const #0s : i
        let s_631_6: i128 = 0;
        // C s_631_7: const #0u : u64
        let s_631_7: u64 = 0;
        // D s_631_8: cast zx s_631_5 -> u64
        let s_631_8: u64 = (s_631_5 as u64);
        // C s_631_9: const #1u : u64
        let s_631_9: u64 = 1;
        // D s_631_10: and s_631_8 s_631_9
        let s_631_10: u64 = ((s_631_8) & (s_631_9));
        // D s_631_11: cmp-eq s_631_10 s_631_9
        let s_631_11: bool = ((s_631_10) == (s_631_9));
        // D s_631_12: lsl s_631_8 s_631_6
        let s_631_12: u64 = s_631_8 << s_631_6;
        // D s_631_13: or s_631_7 s_631_12
        let s_631_13: u64 = ((s_631_7) | (s_631_12));
        // D s_631_14: cmpl s_631_12
        let s_631_14: u64 = !s_631_12;
        // D s_631_15: and s_631_7 s_631_14
        let s_631_15: u64 = ((s_631_7) & (s_631_14));
        // D s_631_16: select s_631_11 s_631_13 s_631_15
        let s_631_16: u64 = if s_631_11 { s_631_13 } else { s_631_15 };
        // D s_631_17: cast trunc s_631_16 -> u8
        let s_631_17: bool = ((s_631_16) != 0);
        // D s_631_18: cast zx s_631_17 -> bv
        let s_631_18: Bits = Bits::new(s_631_17 as u128, 1u16);
        // C s_631_19: const #0u : u8
        let s_631_19: bool = false;
        // C s_631_20: cast zx s_631_19 -> bv
        let s_631_20: Bits = Bits::new(s_631_19 as u128, 1u16);
        // D s_631_21: cmp-ne s_631_18 s_631_20
        let s_631_21: bool = ((s_631_18) != (s_631_20));
        // D s_631_22: write-var gs#405507 <= s_631_21
        fn_state.gs_405507 = s_631_21;
        // N s_631_23: jump b632
        return block_632(state, tracer, fn_state);
    }
    fn block_632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_632_0: read-var gs#405507:u8
        let s_632_0: bool = fn_state.gs_405507;
        // N s_632_1: branch s_632_0 b637 b633
        if s_632_0 {
            return block_637(state, tracer, fn_state);
        } else {
            return block_633(state, tracer, fn_state);
        };
    }
    fn block_633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_633_0: const #11s : i
        let s_633_0: i128 = 11;
        // D s_633_1: read-var u#32670:u32
        let s_633_1: u32 = fn_state.u_32670;
        // D s_633_2: cast zx s_633_1 -> bv
        let s_633_2: Bits = Bits::new(s_633_1 as u128, 32u16);
        // C s_633_3: const #1u : u64
        let s_633_3: u64 = 1;
        // D s_633_4: bit-extract s_633_2 s_633_0 s_633_3
        let s_633_4: Bits = (Bits::new(
            ((s_633_2) >> (s_633_0)).value(),
            u16::try_from(s_633_3).unwrap(),
        ));
        // D s_633_5: cast reint s_633_4 -> u8
        let s_633_5: bool = ((s_633_4.value()) != 0);
        // C s_633_6: const #0s : i
        let s_633_6: i128 = 0;
        // C s_633_7: const #0u : u64
        let s_633_7: u64 = 0;
        // D s_633_8: cast zx s_633_5 -> u64
        let s_633_8: u64 = (s_633_5 as u64);
        // C s_633_9: const #1u : u64
        let s_633_9: u64 = 1;
        // D s_633_10: and s_633_8 s_633_9
        let s_633_10: u64 = ((s_633_8) & (s_633_9));
        // D s_633_11: cmp-eq s_633_10 s_633_9
        let s_633_11: bool = ((s_633_10) == (s_633_9));
        // D s_633_12: lsl s_633_8 s_633_6
        let s_633_12: u64 = s_633_8 << s_633_6;
        // D s_633_13: or s_633_7 s_633_12
        let s_633_13: u64 = ((s_633_7) | (s_633_12));
        // D s_633_14: cmpl s_633_12
        let s_633_14: u64 = !s_633_12;
        // D s_633_15: and s_633_7 s_633_14
        let s_633_15: u64 = ((s_633_7) & (s_633_14));
        // D s_633_16: select s_633_11 s_633_13 s_633_15
        let s_633_16: u64 = if s_633_11 { s_633_13 } else { s_633_15 };
        // D s_633_17: cast trunc s_633_16 -> u8
        let s_633_17: bool = ((s_633_16) != 0);
        // D s_633_18: cast zx s_633_17 -> bv
        let s_633_18: Bits = Bits::new(s_633_17 as u128, 1u16);
        // C s_633_19: const #0u : u8
        let s_633_19: bool = false;
        // C s_633_20: cast zx s_633_19 -> bv
        let s_633_20: Bits = Bits::new(s_633_19 as u128, 1u16);
        // D s_633_21: cmp-ne s_633_18 s_633_20
        let s_633_21: bool = ((s_633_18) != (s_633_20));
        // D s_633_22: write-var gs#405510 <= s_633_21
        fn_state.gs_405510 = s_633_21;
        // N s_633_23: jump b634
        return block_634(state, tracer, fn_state);
    }
    fn block_634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_634_0: read-var gs#405510:u8
        let s_634_0: bool = fn_state.gs_405510;
        // N s_634_1: branch s_634_0 b636 b635
        if s_634_0 {
            return block_636(state, tracer, fn_state);
        } else {
            return block_635(state, tracer, fn_state);
        };
    }
    fn block_635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_635_0: read-var u#32671:u8
        let s_635_0: u8 = fn_state.u_32671;
        // D s_635_1: read-var u#32672:u8
        let s_635_1: bool = fn_state.u_32672;
        // D s_635_2: read-var u#32673:u8
        let s_635_2: bool = fn_state.u_32673;
        // D s_635_3: read-var u#32674:u8
        let s_635_3: bool = fn_state.u_32674;
        // D s_635_4: read-var u#32675:u8
        let s_635_4: u8 = fn_state.u_32675;
        // D s_635_5: read-var u#32676:u8
        let s_635_5: u8 = fn_state.u_32676;
        // D s_635_6: read-var u#32677:u8
        let s_635_6: u8 = fn_state.u_32677;
        // D s_635_7: call decode_aarch32_instrs_LDRSH_r_A1enc_A_txt(s_635_0, s_635_1, s_635_2, s_635_3, s_635_4, s_635_5, s_635_6)
        let s_635_7: () = decode_aarch32_instrs_LDRSH_r_A1enc_A_txt(
            state,
            tracer,
            s_635_0,
            s_635_1,
            s_635_2,
            s_635_3,
            s_635_4,
            s_635_5,
            s_635_6,
        );
        // N s_635_8: return
        return;
    }
    fn block_636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_636_0: panic
        panic!("{:?}", ());
        // N s_636_1: return
        return;
    }
    fn block_637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_637_0: const #1u : u8
        let s_637_0: bool = true;
        // D s_637_1: write-var gs#405510 <= s_637_0
        fn_state.gs_405510 = s_637_0;
        // N s_637_2: jump b634
        return block_634(state, tracer, fn_state);
    }
    fn block_638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_638_0: const #1u : u8
        let s_638_0: bool = true;
        // D s_638_1: write-var gs#405507 <= s_638_0
        fn_state.gs_405507 = s_638_0;
        // N s_638_2: jump b632
        return block_632(state, tracer, fn_state);
    }
    fn block_639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_639_0: const #1u : u8
        let s_639_0: bool = true;
        // D s_639_1: write-var gs#405504 <= s_639_0
        fn_state.gs_405504 = s_639_0;
        // N s_639_2: jump b630
        return block_630(state, tracer, fn_state);
    }
    fn block_640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_640_0: read-var merge#var.1:struct
        let s_640_0: u32 = fn_state.merge_var._1;
        // D s_640_1: write-var u#32679 <= s_640_0
        fn_state.u_32679 = s_640_0;
        // C s_640_2: const #24s : i
        let s_640_2: i128 = 24;
        // D s_640_3: read-var u#32679:u32
        let s_640_3: u32 = fn_state.u_32679;
        // D s_640_4: cast zx s_640_3 -> bv
        let s_640_4: Bits = Bits::new(s_640_3 as u128, 32u16);
        // C s_640_5: const #1s : i64
        let s_640_5: i64 = 1;
        // C s_640_6: cast zx s_640_5 -> i
        let s_640_6: i128 = (i128::try_from(s_640_5).unwrap());
        // C s_640_7: const #3s : i
        let s_640_7: i128 = 3;
        // C s_640_8: add s_640_7 s_640_6
        let s_640_8: i128 = (s_640_7 + s_640_6);
        // D s_640_9: bit-extract s_640_4 s_640_2 s_640_8
        let s_640_9: Bits = (Bits::new(
            ((s_640_4) >> (s_640_2)).value(),
            u16::try_from(s_640_8).unwrap(),
        ));
        // D s_640_10: cast reint s_640_9 -> u8
        let s_640_10: u8 = (s_640_9.value() as u8);
        // D s_640_11: cast zx s_640_10 -> bv
        let s_640_11: Bits = Bits::new(s_640_10 as u128, 4u16);
        // C s_640_12: const #0u : u8
        let s_640_12: u8 = 0;
        // C s_640_13: cast zx s_640_12 -> bv
        let s_640_13: Bits = Bits::new(s_640_12 as u128, 4u16);
        // D s_640_14: cmp-eq s_640_11 s_640_13
        let s_640_14: bool = ((s_640_11) == (s_640_13));
        // N s_640_15: branch s_640_14 b2635 b641
        if s_640_14 {
            return block_2635(state, tracer, fn_state);
        } else {
            return block_641(state, tracer, fn_state);
        };
    }
    fn block_641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_641_0: const #0u : u8
        let s_641_0: bool = false;
        // D s_641_1: write-var gs#405519 <= s_641_0
        fn_state.gs_405519 = s_641_0;
        // N s_641_2: jump b642
        return block_642(state, tracer, fn_state);
    }
    fn block_642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_642_0: read-var gs#405519:u8
        let s_642_0: bool = fn_state.gs_405519;
        // N s_642_1: branch s_642_0 b2631 b643
        if s_642_0 {
            return block_2631(state, tracer, fn_state);
        } else {
            return block_643(state, tracer, fn_state);
        };
    }
    fn block_643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_643_0: const #0u : u8
        let s_643_0: bool = false;
        // D s_643_1: write-var gs#405524 <= s_643_0
        fn_state.gs_405524 = s_643_0;
        // N s_643_2: jump b644
        return block_644(state, tracer, fn_state);
    }
    fn block_644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_644_0: read-var gs#405524:u8
        let s_644_0: bool = fn_state.gs_405524;
        // D s_644_1: not s_644_0
        let s_644_1: bool = !s_644_0;
        // N s_644_2: branch s_644_1 b646 b645
        if s_644_1 {
            return block_646(state, tracer, fn_state);
        } else {
            return block_645(state, tracer, fn_state);
        };
    }
    fn block_645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_645_0: const #2990s : i
        let s_645_0: i128 = 2990;
        // C s_645_1: const #14696u : u32
        let s_645_1: u32 = 14696;
        // N s_645_2: write-reg s_645_1 <= s_645_0
        let s_645_2: () = {
            state.write_register::<i128>(s_645_1 as isize, s_645_0);
            tracer.write_register(s_645_1 as isize, s_645_0);
        };
        // C s_645_3: const #28s : i
        let s_645_3: i128 = 28;
        // C s_645_4: const #4s : i
        let s_645_4: i128 = 4;
        // D s_645_5: read-var u#32679:u32
        let s_645_5: u32 = fn_state.u_32679;
        // D s_645_6: cast zx s_645_5 -> bv
        let s_645_6: Bits = Bits::new(s_645_5 as u128, 32u16);
        // D s_645_7: bit-extract s_645_6 s_645_3 s_645_4
        let s_645_7: Bits = (Bits::new(
            ((s_645_6) >> (s_645_3)).value(),
            u16::try_from(s_645_4).unwrap(),
        ));
        // D s_645_8: cast reint s_645_7 -> u8
        let s_645_8: u8 = (s_645_7.value() as u8);
        // C s_645_9: const #23s : i
        let s_645_9: i128 = 23;
        // C s_645_10: const #1s : i
        let s_645_10: i128 = 1;
        // D s_645_11: read-var u#32679:u32
        let s_645_11: u32 = fn_state.u_32679;
        // D s_645_12: cast zx s_645_11 -> bv
        let s_645_12: Bits = Bits::new(s_645_11 as u128, 32u16);
        // D s_645_13: bit-extract s_645_12 s_645_9 s_645_10
        let s_645_13: Bits = (Bits::new(
            ((s_645_12) >> (s_645_9)).value(),
            u16::try_from(s_645_10).unwrap(),
        ));
        // D s_645_14: cast reint s_645_13 -> u8
        let s_645_14: bool = ((s_645_13.value()) != 0);
        // C s_645_15: const #16s : i
        let s_645_15: i128 = 16;
        // C s_645_16: const #4s : i
        let s_645_16: i128 = 4;
        // D s_645_17: read-var u#32679:u32
        let s_645_17: u32 = fn_state.u_32679;
        // D s_645_18: cast zx s_645_17 -> bv
        let s_645_18: Bits = Bits::new(s_645_17 as u128, 32u16);
        // D s_645_19: bit-extract s_645_18 s_645_15 s_645_16
        let s_645_19: Bits = (Bits::new(
            ((s_645_18) >> (s_645_15)).value(),
            u16::try_from(s_645_16).unwrap(),
        ));
        // D s_645_20: cast reint s_645_19 -> u8
        let s_645_20: u8 = (s_645_19.value() as u8);
        // C s_645_21: const #12s : i
        let s_645_21: i128 = 12;
        // C s_645_22: const #4s : i
        let s_645_22: i128 = 4;
        // D s_645_23: read-var u#32679:u32
        let s_645_23: u32 = fn_state.u_32679;
        // D s_645_24: cast zx s_645_23 -> bv
        let s_645_24: Bits = Bits::new(s_645_23 as u128, 32u16);
        // D s_645_25: bit-extract s_645_24 s_645_21 s_645_22
        let s_645_25: Bits = (Bits::new(
            ((s_645_24) >> (s_645_21)).value(),
            u16::try_from(s_645_22).unwrap(),
        ));
        // D s_645_26: cast reint s_645_25 -> u8
        let s_645_26: u8 = (s_645_25.value() as u8);
        // C s_645_27: const #8s : i
        let s_645_27: i128 = 8;
        // C s_645_28: const #4s : i
        let s_645_28: i128 = 4;
        // D s_645_29: read-var u#32679:u32
        let s_645_29: u32 = fn_state.u_32679;
        // D s_645_30: cast zx s_645_29 -> bv
        let s_645_30: Bits = Bits::new(s_645_29 as u128, 32u16);
        // D s_645_31: bit-extract s_645_30 s_645_27 s_645_28
        let s_645_31: Bits = (Bits::new(
            ((s_645_30) >> (s_645_27)).value(),
            u16::try_from(s_645_28).unwrap(),
        ));
        // D s_645_32: cast reint s_645_31 -> u8
        let s_645_32: u8 = (s_645_31.value() as u8);
        // C s_645_33: const #0s : i
        let s_645_33: i128 = 0;
        // C s_645_34: const #4s : i
        let s_645_34: i128 = 4;
        // D s_645_35: read-var u#32679:u32
        let s_645_35: u32 = fn_state.u_32679;
        // D s_645_36: cast zx s_645_35 -> bv
        let s_645_36: Bits = Bits::new(s_645_35 as u128, 32u16);
        // D s_645_37: bit-extract s_645_36 s_645_33 s_645_34
        let s_645_37: Bits = (Bits::new(
            ((s_645_36) >> (s_645_33)).value(),
            u16::try_from(s_645_34).unwrap(),
        ));
        // D s_645_38: cast reint s_645_37 -> u8
        let s_645_38: u8 = (s_645_37.value() as u8);
        // D s_645_39: call decode_aarch32_instrs_LDRSHT_A1enc_A_txt(s_645_8, s_645_14, s_645_20, s_645_26, s_645_32, s_645_38)
        let s_645_39: () = decode_aarch32_instrs_LDRSHT_A1enc_A_txt(
            state,
            tracer,
            s_645_8,
            s_645_14,
            s_645_20,
            s_645_26,
            s_645_32,
            s_645_38,
        );
        // N s_645_40: return
        return;
    }
    fn block_646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_646_0: read-var merge#var.1:struct
        let s_646_0: u32 = fn_state.merge_var._1;
        // D s_646_1: write-var u#32687 <= s_646_0
        fn_state.u_32687 = s_646_0;
        // C s_646_2: const #24s : i
        let s_646_2: i128 = 24;
        // D s_646_3: read-var u#32687:u32
        let s_646_3: u32 = fn_state.u_32687;
        // D s_646_4: cast zx s_646_3 -> bv
        let s_646_4: Bits = Bits::new(s_646_3 as u128, 32u16);
        // C s_646_5: const #1s : i64
        let s_646_5: i64 = 1;
        // C s_646_6: cast zx s_646_5 -> i
        let s_646_6: i128 = (i128::try_from(s_646_5).unwrap());
        // C s_646_7: const #3s : i
        let s_646_7: i128 = 3;
        // C s_646_8: add s_646_7 s_646_6
        let s_646_8: i128 = (s_646_7 + s_646_6);
        // D s_646_9: bit-extract s_646_4 s_646_2 s_646_8
        let s_646_9: Bits = (Bits::new(
            ((s_646_4) >> (s_646_2)).value(),
            u16::try_from(s_646_8).unwrap(),
        ));
        // D s_646_10: cast reint s_646_9 -> u8
        let s_646_10: u8 = (s_646_9.value() as u8);
        // D s_646_11: cast zx s_646_10 -> bv
        let s_646_11: Bits = Bits::new(s_646_10 as u128, 4u16);
        // C s_646_12: const #0u : u8
        let s_646_12: u8 = 0;
        // C s_646_13: cast zx s_646_12 -> bv
        let s_646_13: Bits = Bits::new(s_646_12 as u128, 4u16);
        // D s_646_14: cmp-eq s_646_11 s_646_13
        let s_646_14: bool = ((s_646_11) == (s_646_13));
        // N s_646_15: branch s_646_14 b2627 b647
        if s_646_14 {
            return block_2627(state, tracer, fn_state);
        } else {
            return block_647(state, tracer, fn_state);
        };
    }
    fn block_647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_647_0: const #0u : u8
        let s_647_0: bool = false;
        // D s_647_1: write-var gs#405547 <= s_647_0
        fn_state.gs_405547 = s_647_0;
        // N s_647_2: jump b648
        return block_648(state, tracer, fn_state);
    }
    fn block_648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_648_0: read-var gs#405547:u8
        let s_648_0: bool = fn_state.gs_405547;
        // N s_648_1: branch s_648_0 b2623 b649
        if s_648_0 {
            return block_2623(state, tracer, fn_state);
        } else {
            return block_649(state, tracer, fn_state);
        };
    }
    fn block_649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_649_0: const #0u : u8
        let s_649_0: bool = false;
        // D s_649_1: write-var gs#405552 <= s_649_0
        fn_state.gs_405552 = s_649_0;
        // N s_649_2: jump b650
        return block_650(state, tracer, fn_state);
    }
    fn block_650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_650_0: read-var gs#405552:u8
        let s_650_0: bool = fn_state.gs_405552;
        // D s_650_1: not s_650_0
        let s_650_1: bool = !s_650_0;
        // N s_650_2: branch s_650_1 b663 b651
        if s_650_1 {
            return block_663(state, tracer, fn_state);
        } else {
            return block_651(state, tracer, fn_state);
        };
    }
    fn block_651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_651_0: const #2991s : i
        let s_651_0: i128 = 2991;
        // C s_651_1: const #14696u : u32
        let s_651_1: u32 = 14696;
        // N s_651_2: write-reg s_651_1 <= s_651_0
        let s_651_2: () = {
            state.write_register::<i128>(s_651_1 as isize, s_651_0);
            tracer.write_register(s_651_1 as isize, s_651_0);
        };
        // C s_651_3: const #28s : i
        let s_651_3: i128 = 28;
        // C s_651_4: const #4s : i
        let s_651_4: i128 = 4;
        // D s_651_5: read-var u#32687:u32
        let s_651_5: u32 = fn_state.u_32687;
        // D s_651_6: cast zx s_651_5 -> bv
        let s_651_6: Bits = Bits::new(s_651_5 as u128, 32u16);
        // D s_651_7: bit-extract s_651_6 s_651_3 s_651_4
        let s_651_7: Bits = (Bits::new(
            ((s_651_6) >> (s_651_3)).value(),
            u16::try_from(s_651_4).unwrap(),
        ));
        // D s_651_8: cast reint s_651_7 -> u8
        let s_651_8: u8 = (s_651_7.value() as u8);
        // D s_651_9: write-var u#32688 <= s_651_8
        fn_state.u_32688 = s_651_8;
        // C s_651_10: const #23s : i
        let s_651_10: i128 = 23;
        // C s_651_11: const #1s : i
        let s_651_11: i128 = 1;
        // D s_651_12: read-var u#32687:u32
        let s_651_12: u32 = fn_state.u_32687;
        // D s_651_13: cast zx s_651_12 -> bv
        let s_651_13: Bits = Bits::new(s_651_12 as u128, 32u16);
        // D s_651_14: bit-extract s_651_13 s_651_10 s_651_11
        let s_651_14: Bits = (Bits::new(
            ((s_651_13) >> (s_651_10)).value(),
            u16::try_from(s_651_11).unwrap(),
        ));
        // D s_651_15: cast reint s_651_14 -> u8
        let s_651_15: bool = ((s_651_14.value()) != 0);
        // D s_651_16: write-var u#32689 <= s_651_15
        fn_state.u_32689 = s_651_15;
        // C s_651_17: const #16s : i
        let s_651_17: i128 = 16;
        // C s_651_18: const #4s : i
        let s_651_18: i128 = 4;
        // D s_651_19: read-var u#32687:u32
        let s_651_19: u32 = fn_state.u_32687;
        // D s_651_20: cast zx s_651_19 -> bv
        let s_651_20: Bits = Bits::new(s_651_19 as u128, 32u16);
        // D s_651_21: bit-extract s_651_20 s_651_17 s_651_18
        let s_651_21: Bits = (Bits::new(
            ((s_651_20) >> (s_651_17)).value(),
            u16::try_from(s_651_18).unwrap(),
        ));
        // D s_651_22: cast reint s_651_21 -> u8
        let s_651_22: u8 = (s_651_21.value() as u8);
        // D s_651_23: write-var u#32690 <= s_651_22
        fn_state.u_32690 = s_651_22;
        // C s_651_24: const #12s : i
        let s_651_24: i128 = 12;
        // C s_651_25: const #4s : i
        let s_651_25: i128 = 4;
        // D s_651_26: read-var u#32687:u32
        let s_651_26: u32 = fn_state.u_32687;
        // D s_651_27: cast zx s_651_26 -> bv
        let s_651_27: Bits = Bits::new(s_651_26 as u128, 32u16);
        // D s_651_28: bit-extract s_651_27 s_651_24 s_651_25
        let s_651_28: Bits = (Bits::new(
            ((s_651_27) >> (s_651_24)).value(),
            u16::try_from(s_651_25).unwrap(),
        ));
        // D s_651_29: cast reint s_651_28 -> u8
        let s_651_29: u8 = (s_651_28.value() as u8);
        // D s_651_30: write-var u#32691 <= s_651_29
        fn_state.u_32691 = s_651_29;
        // C s_651_31: const #0s : i
        let s_651_31: i128 = 0;
        // C s_651_32: const #4s : i
        let s_651_32: i128 = 4;
        // D s_651_33: read-var u#32687:u32
        let s_651_33: u32 = fn_state.u_32687;
        // D s_651_34: cast zx s_651_33 -> bv
        let s_651_34: Bits = Bits::new(s_651_33 as u128, 32u16);
        // D s_651_35: bit-extract s_651_34 s_651_31 s_651_32
        let s_651_35: Bits = (Bits::new(
            ((s_651_34) >> (s_651_31)).value(),
            u16::try_from(s_651_32).unwrap(),
        ));
        // D s_651_36: cast reint s_651_35 -> u8
        let s_651_36: u8 = (s_651_35.value() as u8);
        // D s_651_37: write-var u#32692 <= s_651_36
        fn_state.u_32692 = s_651_36;
        // C s_651_38: const #8s : i
        let s_651_38: i128 = 8;
        // D s_651_39: read-var u#32687:u32
        let s_651_39: u32 = fn_state.u_32687;
        // D s_651_40: cast zx s_651_39 -> bv
        let s_651_40: Bits = Bits::new(s_651_39 as u128, 32u16);
        // C s_651_41: const #1u : u64
        let s_651_41: u64 = 1;
        // D s_651_42: bit-extract s_651_40 s_651_38 s_651_41
        let s_651_42: Bits = (Bits::new(
            ((s_651_40) >> (s_651_38)).value(),
            u16::try_from(s_651_41).unwrap(),
        ));
        // D s_651_43: cast reint s_651_42 -> u8
        let s_651_43: bool = ((s_651_42.value()) != 0);
        // C s_651_44: const #0s : i
        let s_651_44: i128 = 0;
        // C s_651_45: const #0u : u64
        let s_651_45: u64 = 0;
        // D s_651_46: cast zx s_651_43 -> u64
        let s_651_46: u64 = (s_651_43 as u64);
        // C s_651_47: const #1u : u64
        let s_651_47: u64 = 1;
        // D s_651_48: and s_651_46 s_651_47
        let s_651_48: u64 = ((s_651_46) & (s_651_47));
        // D s_651_49: cmp-eq s_651_48 s_651_47
        let s_651_49: bool = ((s_651_48) == (s_651_47));
        // D s_651_50: lsl s_651_46 s_651_44
        let s_651_50: u64 = s_651_46 << s_651_44;
        // D s_651_51: or s_651_45 s_651_50
        let s_651_51: u64 = ((s_651_45) | (s_651_50));
        // D s_651_52: cmpl s_651_50
        let s_651_52: u64 = !s_651_50;
        // D s_651_53: and s_651_45 s_651_52
        let s_651_53: u64 = ((s_651_45) & (s_651_52));
        // D s_651_54: select s_651_49 s_651_51 s_651_53
        let s_651_54: u64 = if s_651_49 { s_651_51 } else { s_651_53 };
        // D s_651_55: cast trunc s_651_54 -> u8
        let s_651_55: bool = ((s_651_54) != 0);
        // D s_651_56: cast zx s_651_55 -> bv
        let s_651_56: Bits = Bits::new(s_651_55 as u128, 1u16);
        // C s_651_57: const #0u : u8
        let s_651_57: bool = false;
        // C s_651_58: cast zx s_651_57 -> bv
        let s_651_58: Bits = Bits::new(s_651_57 as u128, 1u16);
        // D s_651_59: cmp-ne s_651_56 s_651_58
        let s_651_59: bool = ((s_651_56) != (s_651_58));
        // N s_651_60: branch s_651_59 b662 b652
        if s_651_59 {
            return block_662(state, tracer, fn_state);
        } else {
            return block_652(state, tracer, fn_state);
        };
    }
    fn block_652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_652_0: const #9s : i
        let s_652_0: i128 = 9;
        // D s_652_1: read-var u#32687:u32
        let s_652_1: u32 = fn_state.u_32687;
        // D s_652_2: cast zx s_652_1 -> bv
        let s_652_2: Bits = Bits::new(s_652_1 as u128, 32u16);
        // C s_652_3: const #1u : u64
        let s_652_3: u64 = 1;
        // D s_652_4: bit-extract s_652_2 s_652_0 s_652_3
        let s_652_4: Bits = (Bits::new(
            ((s_652_2) >> (s_652_0)).value(),
            u16::try_from(s_652_3).unwrap(),
        ));
        // D s_652_5: cast reint s_652_4 -> u8
        let s_652_5: bool = ((s_652_4.value()) != 0);
        // C s_652_6: const #0s : i
        let s_652_6: i128 = 0;
        // C s_652_7: const #0u : u64
        let s_652_7: u64 = 0;
        // D s_652_8: cast zx s_652_5 -> u64
        let s_652_8: u64 = (s_652_5 as u64);
        // C s_652_9: const #1u : u64
        let s_652_9: u64 = 1;
        // D s_652_10: and s_652_8 s_652_9
        let s_652_10: u64 = ((s_652_8) & (s_652_9));
        // D s_652_11: cmp-eq s_652_10 s_652_9
        let s_652_11: bool = ((s_652_10) == (s_652_9));
        // D s_652_12: lsl s_652_8 s_652_6
        let s_652_12: u64 = s_652_8 << s_652_6;
        // D s_652_13: or s_652_7 s_652_12
        let s_652_13: u64 = ((s_652_7) | (s_652_12));
        // D s_652_14: cmpl s_652_12
        let s_652_14: u64 = !s_652_12;
        // D s_652_15: and s_652_7 s_652_14
        let s_652_15: u64 = ((s_652_7) & (s_652_14));
        // D s_652_16: select s_652_11 s_652_13 s_652_15
        let s_652_16: u64 = if s_652_11 { s_652_13 } else { s_652_15 };
        // D s_652_17: cast trunc s_652_16 -> u8
        let s_652_17: bool = ((s_652_16) != 0);
        // D s_652_18: cast zx s_652_17 -> bv
        let s_652_18: Bits = Bits::new(s_652_17 as u128, 1u16);
        // C s_652_19: const #0u : u8
        let s_652_19: bool = false;
        // C s_652_20: cast zx s_652_19 -> bv
        let s_652_20: Bits = Bits::new(s_652_19 as u128, 1u16);
        // D s_652_21: cmp-ne s_652_18 s_652_20
        let s_652_21: bool = ((s_652_18) != (s_652_20));
        // D s_652_22: write-var gs#405569 <= s_652_21
        fn_state.gs_405569 = s_652_21;
        // N s_652_23: jump b653
        return block_653(state, tracer, fn_state);
    }
    fn block_653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_653_0: read-var gs#405569:u8
        let s_653_0: bool = fn_state.gs_405569;
        // N s_653_1: branch s_653_0 b661 b654
        if s_653_0 {
            return block_661(state, tracer, fn_state);
        } else {
            return block_654(state, tracer, fn_state);
        };
    }
    fn block_654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_654_0: const #10s : i
        let s_654_0: i128 = 10;
        // D s_654_1: read-var u#32687:u32
        let s_654_1: u32 = fn_state.u_32687;
        // D s_654_2: cast zx s_654_1 -> bv
        let s_654_2: Bits = Bits::new(s_654_1 as u128, 32u16);
        // C s_654_3: const #1u : u64
        let s_654_3: u64 = 1;
        // D s_654_4: bit-extract s_654_2 s_654_0 s_654_3
        let s_654_4: Bits = (Bits::new(
            ((s_654_2) >> (s_654_0)).value(),
            u16::try_from(s_654_3).unwrap(),
        ));
        // D s_654_5: cast reint s_654_4 -> u8
        let s_654_5: bool = ((s_654_4.value()) != 0);
        // C s_654_6: const #0s : i
        let s_654_6: i128 = 0;
        // C s_654_7: const #0u : u64
        let s_654_7: u64 = 0;
        // D s_654_8: cast zx s_654_5 -> u64
        let s_654_8: u64 = (s_654_5 as u64);
        // C s_654_9: const #1u : u64
        let s_654_9: u64 = 1;
        // D s_654_10: and s_654_8 s_654_9
        let s_654_10: u64 = ((s_654_8) & (s_654_9));
        // D s_654_11: cmp-eq s_654_10 s_654_9
        let s_654_11: bool = ((s_654_10) == (s_654_9));
        // D s_654_12: lsl s_654_8 s_654_6
        let s_654_12: u64 = s_654_8 << s_654_6;
        // D s_654_13: or s_654_7 s_654_12
        let s_654_13: u64 = ((s_654_7) | (s_654_12));
        // D s_654_14: cmpl s_654_12
        let s_654_14: u64 = !s_654_12;
        // D s_654_15: and s_654_7 s_654_14
        let s_654_15: u64 = ((s_654_7) & (s_654_14));
        // D s_654_16: select s_654_11 s_654_13 s_654_15
        let s_654_16: u64 = if s_654_11 { s_654_13 } else { s_654_15 };
        // D s_654_17: cast trunc s_654_16 -> u8
        let s_654_17: bool = ((s_654_16) != 0);
        // D s_654_18: cast zx s_654_17 -> bv
        let s_654_18: Bits = Bits::new(s_654_17 as u128, 1u16);
        // C s_654_19: const #0u : u8
        let s_654_19: bool = false;
        // C s_654_20: cast zx s_654_19 -> bv
        let s_654_20: Bits = Bits::new(s_654_19 as u128, 1u16);
        // D s_654_21: cmp-ne s_654_18 s_654_20
        let s_654_21: bool = ((s_654_18) != (s_654_20));
        // D s_654_22: write-var gs#405572 <= s_654_21
        fn_state.gs_405572 = s_654_21;
        // N s_654_23: jump b655
        return block_655(state, tracer, fn_state);
    }
    fn block_655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_655_0: read-var gs#405572:u8
        let s_655_0: bool = fn_state.gs_405572;
        // N s_655_1: branch s_655_0 b660 b656
        if s_655_0 {
            return block_660(state, tracer, fn_state);
        } else {
            return block_656(state, tracer, fn_state);
        };
    }
    fn block_656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_656_0: const #11s : i
        let s_656_0: i128 = 11;
        // D s_656_1: read-var u#32687:u32
        let s_656_1: u32 = fn_state.u_32687;
        // D s_656_2: cast zx s_656_1 -> bv
        let s_656_2: Bits = Bits::new(s_656_1 as u128, 32u16);
        // C s_656_3: const #1u : u64
        let s_656_3: u64 = 1;
        // D s_656_4: bit-extract s_656_2 s_656_0 s_656_3
        let s_656_4: Bits = (Bits::new(
            ((s_656_2) >> (s_656_0)).value(),
            u16::try_from(s_656_3).unwrap(),
        ));
        // D s_656_5: cast reint s_656_4 -> u8
        let s_656_5: bool = ((s_656_4.value()) != 0);
        // C s_656_6: const #0s : i
        let s_656_6: i128 = 0;
        // C s_656_7: const #0u : u64
        let s_656_7: u64 = 0;
        // D s_656_8: cast zx s_656_5 -> u64
        let s_656_8: u64 = (s_656_5 as u64);
        // C s_656_9: const #1u : u64
        let s_656_9: u64 = 1;
        // D s_656_10: and s_656_8 s_656_9
        let s_656_10: u64 = ((s_656_8) & (s_656_9));
        // D s_656_11: cmp-eq s_656_10 s_656_9
        let s_656_11: bool = ((s_656_10) == (s_656_9));
        // D s_656_12: lsl s_656_8 s_656_6
        let s_656_12: u64 = s_656_8 << s_656_6;
        // D s_656_13: or s_656_7 s_656_12
        let s_656_13: u64 = ((s_656_7) | (s_656_12));
        // D s_656_14: cmpl s_656_12
        let s_656_14: u64 = !s_656_12;
        // D s_656_15: and s_656_7 s_656_14
        let s_656_15: u64 = ((s_656_7) & (s_656_14));
        // D s_656_16: select s_656_11 s_656_13 s_656_15
        let s_656_16: u64 = if s_656_11 { s_656_13 } else { s_656_15 };
        // D s_656_17: cast trunc s_656_16 -> u8
        let s_656_17: bool = ((s_656_16) != 0);
        // D s_656_18: cast zx s_656_17 -> bv
        let s_656_18: Bits = Bits::new(s_656_17 as u128, 1u16);
        // C s_656_19: const #0u : u8
        let s_656_19: bool = false;
        // C s_656_20: cast zx s_656_19 -> bv
        let s_656_20: Bits = Bits::new(s_656_19 as u128, 1u16);
        // D s_656_21: cmp-ne s_656_18 s_656_20
        let s_656_21: bool = ((s_656_18) != (s_656_20));
        // D s_656_22: write-var gs#405575 <= s_656_21
        fn_state.gs_405575 = s_656_21;
        // N s_656_23: jump b657
        return block_657(state, tracer, fn_state);
    }
    fn block_657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_657_0: read-var gs#405575:u8
        let s_657_0: bool = fn_state.gs_405575;
        // N s_657_1: branch s_657_0 b659 b658
        if s_657_0 {
            return block_659(state, tracer, fn_state);
        } else {
            return block_658(state, tracer, fn_state);
        };
    }
    fn block_658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_658_0: read-var u#32688:u8
        let s_658_0: u8 = fn_state.u_32688;
        // D s_658_1: read-var u#32689:u8
        let s_658_1: bool = fn_state.u_32689;
        // D s_658_2: read-var u#32690:u8
        let s_658_2: u8 = fn_state.u_32690;
        // D s_658_3: read-var u#32691:u8
        let s_658_3: u8 = fn_state.u_32691;
        // D s_658_4: read-var u#32692:u8
        let s_658_4: u8 = fn_state.u_32692;
        // D s_658_5: call decode_aarch32_instrs_LDRSHT_A2enc_A_txt(s_658_0, s_658_1, s_658_2, s_658_3, s_658_4)
        let s_658_5: () = decode_aarch32_instrs_LDRSHT_A2enc_A_txt(
            state,
            tracer,
            s_658_0,
            s_658_1,
            s_658_2,
            s_658_3,
            s_658_4,
        );
        // N s_658_6: return
        return;
    }
    fn block_659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_659_0: panic
        panic!("{:?}", ());
        // N s_659_1: return
        return;
    }
    fn block_660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_660_0: const #1u : u8
        let s_660_0: bool = true;
        // D s_660_1: write-var gs#405575 <= s_660_0
        fn_state.gs_405575 = s_660_0;
        // N s_660_2: jump b657
        return block_657(state, tracer, fn_state);
    }
    fn block_661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_661_0: const #1u : u8
        let s_661_0: bool = true;
        // D s_661_1: write-var gs#405572 <= s_661_0
        fn_state.gs_405572 = s_661_0;
        // N s_661_2: jump b655
        return block_655(state, tracer, fn_state);
    }
    fn block_662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_662_0: const #1u : u8
        let s_662_0: bool = true;
        // D s_662_1: write-var gs#405569 <= s_662_0
        fn_state.gs_405569 = s_662_0;
        // N s_662_2: jump b653
        return block_653(state, tracer, fn_state);
    }
    fn block_663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_663_0: read-var merge#var.1:struct
        let s_663_0: u32 = fn_state.merge_var._1;
        // D s_663_1: write-var u#32694 <= s_663_0
        fn_state.u_32694 = s_663_0;
        // C s_663_2: const #21s : i
        let s_663_2: i128 = 21;
        // D s_663_3: read-var u#32694:u32
        let s_663_3: u32 = fn_state.u_32694;
        // D s_663_4: cast zx s_663_3 -> bv
        let s_663_4: Bits = Bits::new(s_663_3 as u128, 32u16);
        // C s_663_5: const #1s : i64
        let s_663_5: i64 = 1;
        // C s_663_6: cast zx s_663_5 -> i
        let s_663_6: i128 = (i128::try_from(s_663_5).unwrap());
        // C s_663_7: const #6s : i
        let s_663_7: i128 = 6;
        // C s_663_8: add s_663_7 s_663_6
        let s_663_8: i128 = (s_663_7 + s_663_6);
        // D s_663_9: bit-extract s_663_4 s_663_2 s_663_8
        let s_663_9: Bits = (Bits::new(
            ((s_663_4) >> (s_663_2)).value(),
            u16::try_from(s_663_8).unwrap(),
        ));
        // D s_663_10: cast reint s_663_9 -> u8
        let s_663_10: u8 = (s_663_9.value() as u8);
        // D s_663_11: cast zx s_663_10 -> bv
        let s_663_11: Bits = Bits::new(s_663_10 as u128, 7u16);
        // C s_663_12: const #1u : u8
        let s_663_12: u8 = 1;
        // C s_663_13: cast zx s_663_12 -> bv
        let s_663_13: Bits = Bits::new(s_663_12 as u128, 7u16);
        // D s_663_14: cmp-eq s_663_11 s_663_13
        let s_663_14: bool = ((s_663_11) == (s_663_13));
        // N s_663_15: branch s_663_14 b2622 b664
        if s_663_14 {
            return block_2622(state, tracer, fn_state);
        } else {
            return block_664(state, tracer, fn_state);
        };
    }
    fn block_664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_664_0: const #0u : u8
        let s_664_0: bool = false;
        // D s_664_1: write-var gs#405581 <= s_664_0
        fn_state.gs_405581 = s_664_0;
        // N s_664_2: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_665_0: read-var gs#405581:u8
        let s_665_0: bool = fn_state.gs_405581;
        // N s_665_1: branch s_665_0 b2618 b666
        if s_665_0 {
            return block_2618(state, tracer, fn_state);
        } else {
            return block_666(state, tracer, fn_state);
        };
    }
    fn block_666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_666_0: const #0u : u8
        let s_666_0: bool = false;
        // D s_666_1: write-var gs#405586 <= s_666_0
        fn_state.gs_405586 = s_666_0;
        // N s_666_2: jump b667
        return block_667(state, tracer, fn_state);
    }
    fn block_667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_667_0: read-var gs#405586:u8
        let s_667_0: bool = fn_state.gs_405586;
        // D s_667_1: not s_667_0
        let s_667_1: bool = !s_667_0;
        // N s_667_2: branch s_667_1 b669 b668
        if s_667_1 {
            return block_669(state, tracer, fn_state);
        } else {
            return block_668(state, tracer, fn_state);
        };
    }
    fn block_668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_668_0: const #3005s : i
        let s_668_0: i128 = 3005;
        // C s_668_1: const #14696u : u32
        let s_668_1: u32 = 14696;
        // N s_668_2: write-reg s_668_1 <= s_668_0
        let s_668_2: () = {
            state.write_register::<i128>(s_668_1 as isize, s_668_0);
            tracer.write_register(s_668_1 as isize, s_668_0);
        };
        // C s_668_3: const #28s : i
        let s_668_3: i128 = 28;
        // C s_668_4: const #4s : i
        let s_668_4: i128 = 4;
        // D s_668_5: read-var u#32694:u32
        let s_668_5: u32 = fn_state.u_32694;
        // D s_668_6: cast zx s_668_5 -> bv
        let s_668_6: Bits = Bits::new(s_668_5 as u128, 32u16);
        // D s_668_7: bit-extract s_668_6 s_668_3 s_668_4
        let s_668_7: Bits = (Bits::new(
            ((s_668_6) >> (s_668_3)).value(),
            u16::try_from(s_668_4).unwrap(),
        ));
        // D s_668_8: cast reint s_668_7 -> u8
        let s_668_8: u8 = (s_668_7.value() as u8);
        // C s_668_9: const #20s : i
        let s_668_9: i128 = 20;
        // C s_668_10: const #1s : i
        let s_668_10: i128 = 1;
        // D s_668_11: read-var u#32694:u32
        let s_668_11: u32 = fn_state.u_32694;
        // D s_668_12: cast zx s_668_11 -> bv
        let s_668_12: Bits = Bits::new(s_668_11 as u128, 32u16);
        // D s_668_13: bit-extract s_668_12 s_668_9 s_668_10
        let s_668_13: Bits = (Bits::new(
            ((s_668_12) >> (s_668_9)).value(),
            u16::try_from(s_668_10).unwrap(),
        ));
        // D s_668_14: cast reint s_668_13 -> u8
        let s_668_14: bool = ((s_668_13.value()) != 0);
        // C s_668_15: const #16s : i
        let s_668_15: i128 = 16;
        // C s_668_16: const #4s : i
        let s_668_16: i128 = 4;
        // D s_668_17: read-var u#32694:u32
        let s_668_17: u32 = fn_state.u_32694;
        // D s_668_18: cast zx s_668_17 -> bv
        let s_668_18: Bits = Bits::new(s_668_17 as u128, 32u16);
        // D s_668_19: bit-extract s_668_18 s_668_15 s_668_16
        let s_668_19: Bits = (Bits::new(
            ((s_668_18) >> (s_668_15)).value(),
            u16::try_from(s_668_16).unwrap(),
        ));
        // D s_668_20: cast reint s_668_19 -> u8
        let s_668_20: u8 = (s_668_19.value() as u8);
        // C s_668_21: const #12s : i
        let s_668_21: i128 = 12;
        // C s_668_22: const #4s : i
        let s_668_22: i128 = 4;
        // D s_668_23: read-var u#32694:u32
        let s_668_23: u32 = fn_state.u_32694;
        // D s_668_24: cast zx s_668_23 -> bv
        let s_668_24: Bits = Bits::new(s_668_23 as u128, 32u16);
        // D s_668_25: bit-extract s_668_24 s_668_21 s_668_22
        let s_668_25: Bits = (Bits::new(
            ((s_668_24) >> (s_668_21)).value(),
            u16::try_from(s_668_22).unwrap(),
        ));
        // D s_668_26: cast reint s_668_25 -> u8
        let s_668_26: u8 = (s_668_25.value() as u8);
        // C s_668_27: const #8s : i
        let s_668_27: i128 = 8;
        // C s_668_28: const #4s : i
        let s_668_28: i128 = 4;
        // D s_668_29: read-var u#32694:u32
        let s_668_29: u32 = fn_state.u_32694;
        // D s_668_30: cast zx s_668_29 -> bv
        let s_668_30: Bits = Bits::new(s_668_29 as u128, 32u16);
        // D s_668_31: bit-extract s_668_30 s_668_27 s_668_28
        let s_668_31: Bits = (Bits::new(
            ((s_668_30) >> (s_668_27)).value(),
            u16::try_from(s_668_28).unwrap(),
        ));
        // D s_668_32: cast reint s_668_31 -> u8
        let s_668_32: u8 = (s_668_31.value() as u8);
        // C s_668_33: const #0s : i
        let s_668_33: i128 = 0;
        // C s_668_34: const #4s : i
        let s_668_34: i128 = 4;
        // D s_668_35: read-var u#32694:u32
        let s_668_35: u32 = fn_state.u_32694;
        // D s_668_36: cast zx s_668_35 -> bv
        let s_668_36: Bits = Bits::new(s_668_35 as u128, 32u16);
        // D s_668_37: bit-extract s_668_36 s_668_33 s_668_34
        let s_668_37: Bits = (Bits::new(
            ((s_668_36) >> (s_668_33)).value(),
            u16::try_from(s_668_34).unwrap(),
        ));
        // D s_668_38: cast reint s_668_37 -> u8
        let s_668_38: u8 = (s_668_37.value() as u8);
        // D s_668_39: call decode_aarch32_instrs_MLA_A1enc_A_txt(s_668_8, s_668_14, s_668_20, s_668_26, s_668_32, s_668_38)
        let s_668_39: () = decode_aarch32_instrs_MLA_A1enc_A_txt(
            state,
            tracer,
            s_668_8,
            s_668_14,
            s_668_20,
            s_668_26,
            s_668_32,
            s_668_38,
        );
        // N s_668_40: return
        return;
    }
    fn block_669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_669_0: read-var merge#var.1:struct
        let s_669_0: u32 = fn_state.merge_var._1;
        // D s_669_1: write-var u#32701 <= s_669_0
        fn_state.u_32701 = s_669_0;
        // C s_669_2: const #20s : i
        let s_669_2: i128 = 20;
        // D s_669_3: read-var u#32701:u32
        let s_669_3: u32 = fn_state.u_32701;
        // D s_669_4: cast zx s_669_3 -> bv
        let s_669_4: Bits = Bits::new(s_669_3 as u128, 32u16);
        // C s_669_5: const #1s : i64
        let s_669_5: i64 = 1;
        // C s_669_6: cast zx s_669_5 -> i
        let s_669_6: i128 = (i128::try_from(s_669_5).unwrap());
        // C s_669_7: const #7s : i
        let s_669_7: i128 = 7;
        // C s_669_8: add s_669_7 s_669_6
        let s_669_8: i128 = (s_669_7 + s_669_6);
        // D s_669_9: bit-extract s_669_4 s_669_2 s_669_8
        let s_669_9: Bits = (Bits::new(
            ((s_669_4) >> (s_669_2)).value(),
            u16::try_from(s_669_8).unwrap(),
        ));
        // D s_669_10: cast reint s_669_9 -> u8
        let s_669_10: u8 = (s_669_9.value() as u8);
        // D s_669_11: cast zx s_669_10 -> bv
        let s_669_11: Bits = Bits::new(s_669_10 as u128, 8u16);
        // C s_669_12: const #6u : u8
        let s_669_12: u8 = 6;
        // C s_669_13: cast zx s_669_12 -> bv
        let s_669_13: Bits = Bits::new(s_669_12 as u128, 8u16);
        // D s_669_14: cmp-eq s_669_11 s_669_13
        let s_669_14: bool = ((s_669_11) == (s_669_13));
        // N s_669_15: branch s_669_14 b2617 b670
        if s_669_14 {
            return block_2617(state, tracer, fn_state);
        } else {
            return block_670(state, tracer, fn_state);
        };
    }
    fn block_670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_670_0: const #0u : u8
        let s_670_0: bool = false;
        // D s_670_1: write-var gs#405606 <= s_670_0
        fn_state.gs_405606 = s_670_0;
        // N s_670_2: jump b671
        return block_671(state, tracer, fn_state);
    }
    fn block_671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_671_0: read-var gs#405606:u8
        let s_671_0: bool = fn_state.gs_405606;
        // N s_671_1: branch s_671_0 b2613 b672
        if s_671_0 {
            return block_2613(state, tracer, fn_state);
        } else {
            return block_672(state, tracer, fn_state);
        };
    }
    fn block_672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_672_0: const #0u : u8
        let s_672_0: bool = false;
        // D s_672_1: write-var gs#405611 <= s_672_0
        fn_state.gs_405611 = s_672_0;
        // N s_672_2: jump b673
        return block_673(state, tracer, fn_state);
    }
    fn block_673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_673_0: read-var gs#405611:u8
        let s_673_0: bool = fn_state.gs_405611;
        // D s_673_1: not s_673_0
        let s_673_1: bool = !s_673_0;
        // N s_673_2: branch s_673_1 b675 b674
        if s_673_1 {
            return block_675(state, tracer, fn_state);
        } else {
            return block_674(state, tracer, fn_state);
        };
    }
    fn block_674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_674_0: const #3007s : i
        let s_674_0: i128 = 3007;
        // C s_674_1: const #14696u : u32
        let s_674_1: u32 = 14696;
        // N s_674_2: write-reg s_674_1 <= s_674_0
        let s_674_2: () = {
            state.write_register::<i128>(s_674_1 as isize, s_674_0);
            tracer.write_register(s_674_1 as isize, s_674_0);
        };
        // C s_674_3: const #28s : i
        let s_674_3: i128 = 28;
        // C s_674_4: const #4s : i
        let s_674_4: i128 = 4;
        // D s_674_5: read-var u#32701:u32
        let s_674_5: u32 = fn_state.u_32701;
        // D s_674_6: cast zx s_674_5 -> bv
        let s_674_6: Bits = Bits::new(s_674_5 as u128, 32u16);
        // D s_674_7: bit-extract s_674_6 s_674_3 s_674_4
        let s_674_7: Bits = (Bits::new(
            ((s_674_6) >> (s_674_3)).value(),
            u16::try_from(s_674_4).unwrap(),
        ));
        // D s_674_8: cast reint s_674_7 -> u8
        let s_674_8: u8 = (s_674_7.value() as u8);
        // C s_674_9: const #16s : i
        let s_674_9: i128 = 16;
        // C s_674_10: const #4s : i
        let s_674_10: i128 = 4;
        // D s_674_11: read-var u#32701:u32
        let s_674_11: u32 = fn_state.u_32701;
        // D s_674_12: cast zx s_674_11 -> bv
        let s_674_12: Bits = Bits::new(s_674_11 as u128, 32u16);
        // D s_674_13: bit-extract s_674_12 s_674_9 s_674_10
        let s_674_13: Bits = (Bits::new(
            ((s_674_12) >> (s_674_9)).value(),
            u16::try_from(s_674_10).unwrap(),
        ));
        // D s_674_14: cast reint s_674_13 -> u8
        let s_674_14: u8 = (s_674_13.value() as u8);
        // C s_674_15: const #12s : i
        let s_674_15: i128 = 12;
        // C s_674_16: const #4s : i
        let s_674_16: i128 = 4;
        // D s_674_17: read-var u#32701:u32
        let s_674_17: u32 = fn_state.u_32701;
        // D s_674_18: cast zx s_674_17 -> bv
        let s_674_18: Bits = Bits::new(s_674_17 as u128, 32u16);
        // D s_674_19: bit-extract s_674_18 s_674_15 s_674_16
        let s_674_19: Bits = (Bits::new(
            ((s_674_18) >> (s_674_15)).value(),
            u16::try_from(s_674_16).unwrap(),
        ));
        // D s_674_20: cast reint s_674_19 -> u8
        let s_674_20: u8 = (s_674_19.value() as u8);
        // C s_674_21: const #8s : i
        let s_674_21: i128 = 8;
        // C s_674_22: const #4s : i
        let s_674_22: i128 = 4;
        // D s_674_23: read-var u#32701:u32
        let s_674_23: u32 = fn_state.u_32701;
        // D s_674_24: cast zx s_674_23 -> bv
        let s_674_24: Bits = Bits::new(s_674_23 as u128, 32u16);
        // D s_674_25: bit-extract s_674_24 s_674_21 s_674_22
        let s_674_25: Bits = (Bits::new(
            ((s_674_24) >> (s_674_21)).value(),
            u16::try_from(s_674_22).unwrap(),
        ));
        // D s_674_26: cast reint s_674_25 -> u8
        let s_674_26: u8 = (s_674_25.value() as u8);
        // C s_674_27: const #0s : i
        let s_674_27: i128 = 0;
        // C s_674_28: const #4s : i
        let s_674_28: i128 = 4;
        // D s_674_29: read-var u#32701:u32
        let s_674_29: u32 = fn_state.u_32701;
        // D s_674_30: cast zx s_674_29 -> bv
        let s_674_30: Bits = Bits::new(s_674_29 as u128, 32u16);
        // D s_674_31: bit-extract s_674_30 s_674_27 s_674_28
        let s_674_31: Bits = (Bits::new(
            ((s_674_30) >> (s_674_27)).value(),
            u16::try_from(s_674_28).unwrap(),
        ));
        // D s_674_32: cast reint s_674_31 -> u8
        let s_674_32: u8 = (s_674_31.value() as u8);
        // D s_674_33: call decode_aarch32_instrs_MLS_A1enc_A_txt(s_674_8, s_674_14, s_674_20, s_674_26, s_674_32)
        let s_674_33: () = decode_aarch32_instrs_MLS_A1enc_A_txt(
            state,
            tracer,
            s_674_8,
            s_674_14,
            s_674_20,
            s_674_26,
            s_674_32,
        );
        // N s_674_34: return
        return;
    }
    fn block_675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_675_0: read-var merge#var.1:struct
        let s_675_0: u32 = fn_state.merge_var._1;
        // D s_675_1: write-var u#32708 <= s_675_0
        fn_state.u_32708 = s_675_0;
        // C s_675_2: const #21s : i
        let s_675_2: i128 = 21;
        // D s_675_3: read-var u#32708:u32
        let s_675_3: u32 = fn_state.u_32708;
        // D s_675_4: cast zx s_675_3 -> bv
        let s_675_4: Bits = Bits::new(s_675_3 as u128, 32u16);
        // C s_675_5: const #1s : i64
        let s_675_5: i64 = 1;
        // C s_675_6: cast zx s_675_5 -> i
        let s_675_6: i128 = (i128::try_from(s_675_5).unwrap());
        // C s_675_7: const #6s : i
        let s_675_7: i128 = 6;
        // C s_675_8: add s_675_7 s_675_6
        let s_675_8: i128 = (s_675_7 + s_675_6);
        // D s_675_9: bit-extract s_675_4 s_675_2 s_675_8
        let s_675_9: Bits = (Bits::new(
            ((s_675_4) >> (s_675_2)).value(),
            u16::try_from(s_675_8).unwrap(),
        ));
        // D s_675_10: cast reint s_675_9 -> u8
        let s_675_10: u8 = (s_675_9.value() as u8);
        // D s_675_11: cast zx s_675_10 -> bv
        let s_675_11: Bits = Bits::new(s_675_10 as u128, 7u16);
        // C s_675_12: const #29u : u8
        let s_675_12: u8 = 29;
        // C s_675_13: cast zx s_675_12 -> bv
        let s_675_13: Bits = Bits::new(s_675_12 as u128, 7u16);
        // D s_675_14: cmp-eq s_675_11 s_675_13
        let s_675_14: bool = ((s_675_11) == (s_675_13));
        // N s_675_15: branch s_675_14 b2612 b676
        if s_675_14 {
            return block_2612(state, tracer, fn_state);
        } else {
            return block_676(state, tracer, fn_state);
        };
    }
    fn block_676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_676_0: const #0u : u8
        let s_676_0: bool = false;
        // D s_676_1: write-var gs#405629 <= s_676_0
        fn_state.gs_405629 = s_676_0;
        // N s_676_2: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_677_0: read-var gs#405629:u8
        let s_677_0: bool = fn_state.gs_405629;
        // N s_677_1: branch s_677_0 b2608 b678
        if s_677_0 {
            return block_2608(state, tracer, fn_state);
        } else {
            return block_678(state, tracer, fn_state);
        };
    }
    fn block_678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_678_0: const #0u : u8
        let s_678_0: bool = false;
        // D s_678_1: write-var gs#405634 <= s_678_0
        fn_state.gs_405634 = s_678_0;
        // N s_678_2: jump b679
        return block_679(state, tracer, fn_state);
    }
    fn block_679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_679_0: read-var gs#405634:u8
        let s_679_0: bool = fn_state.gs_405634;
        // D s_679_1: not s_679_0
        let s_679_1: bool = !s_679_0;
        // N s_679_2: branch s_679_1 b692 b680
        if s_679_1 {
            return block_692(state, tracer, fn_state);
        } else {
            return block_680(state, tracer, fn_state);
        };
    }
    fn block_680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_680_0: const #3009s : i
        let s_680_0: i128 = 3009;
        // C s_680_1: const #14696u : u32
        let s_680_1: u32 = 14696;
        // N s_680_2: write-reg s_680_1 <= s_680_0
        let s_680_2: () = {
            state.write_register::<i128>(s_680_1 as isize, s_680_0);
            tracer.write_register(s_680_1 as isize, s_680_0);
        };
        // C s_680_3: const #28s : i
        let s_680_3: i128 = 28;
        // C s_680_4: const #4s : i
        let s_680_4: i128 = 4;
        // D s_680_5: read-var u#32708:u32
        let s_680_5: u32 = fn_state.u_32708;
        // D s_680_6: cast zx s_680_5 -> bv
        let s_680_6: Bits = Bits::new(s_680_5 as u128, 32u16);
        // D s_680_7: bit-extract s_680_6 s_680_3 s_680_4
        let s_680_7: Bits = (Bits::new(
            ((s_680_6) >> (s_680_3)).value(),
            u16::try_from(s_680_4).unwrap(),
        ));
        // D s_680_8: cast reint s_680_7 -> u8
        let s_680_8: u8 = (s_680_7.value() as u8);
        // D s_680_9: write-var u#32709 <= s_680_8
        fn_state.u_32709 = s_680_8;
        // C s_680_10: const #20s : i
        let s_680_10: i128 = 20;
        // C s_680_11: const #1s : i
        let s_680_11: i128 = 1;
        // D s_680_12: read-var u#32708:u32
        let s_680_12: u32 = fn_state.u_32708;
        // D s_680_13: cast zx s_680_12 -> bv
        let s_680_13: Bits = Bits::new(s_680_12 as u128, 32u16);
        // D s_680_14: bit-extract s_680_13 s_680_10 s_680_11
        let s_680_14: Bits = (Bits::new(
            ((s_680_13) >> (s_680_10)).value(),
            u16::try_from(s_680_11).unwrap(),
        ));
        // D s_680_15: cast reint s_680_14 -> u8
        let s_680_15: bool = ((s_680_14.value()) != 0);
        // D s_680_16: write-var u#32710 <= s_680_15
        fn_state.u_32710 = s_680_15;
        // C s_680_17: const #12s : i
        let s_680_17: i128 = 12;
        // C s_680_18: const #4s : i
        let s_680_18: i128 = 4;
        // D s_680_19: read-var u#32708:u32
        let s_680_19: u32 = fn_state.u_32708;
        // D s_680_20: cast zx s_680_19 -> bv
        let s_680_20: Bits = Bits::new(s_680_19 as u128, 32u16);
        // D s_680_21: bit-extract s_680_20 s_680_17 s_680_18
        let s_680_21: Bits = (Bits::new(
            ((s_680_20) >> (s_680_17)).value(),
            u16::try_from(s_680_18).unwrap(),
        ));
        // D s_680_22: cast reint s_680_21 -> u8
        let s_680_22: u8 = (s_680_21.value() as u8);
        // D s_680_23: write-var u#32711 <= s_680_22
        fn_state.u_32711 = s_680_22;
        // C s_680_24: const #0s : i
        let s_680_24: i128 = 0;
        // C s_680_25: const #12s : i
        let s_680_25: i128 = 12;
        // D s_680_26: read-var u#32708:u32
        let s_680_26: u32 = fn_state.u_32708;
        // D s_680_27: cast zx s_680_26 -> bv
        let s_680_27: Bits = Bits::new(s_680_26 as u128, 32u16);
        // D s_680_28: bit-extract s_680_27 s_680_24 s_680_25
        let s_680_28: Bits = (Bits::new(
            ((s_680_27) >> (s_680_24)).value(),
            u16::try_from(s_680_25).unwrap(),
        ));
        // D s_680_29: cast reint s_680_28 -> u12
        let s_680_29: u16 = (s_680_28.value() as u16);
        // D s_680_30: write-var u#32712 <= s_680_29
        fn_state.u_32712 = s_680_29;
        // C s_680_31: const #16s : i
        let s_680_31: i128 = 16;
        // D s_680_32: read-var u#32708:u32
        let s_680_32: u32 = fn_state.u_32708;
        // D s_680_33: cast zx s_680_32 -> bv
        let s_680_33: Bits = Bits::new(s_680_32 as u128, 32u16);
        // C s_680_34: const #1u : u64
        let s_680_34: u64 = 1;
        // D s_680_35: bit-extract s_680_33 s_680_31 s_680_34
        let s_680_35: Bits = (Bits::new(
            ((s_680_33) >> (s_680_31)).value(),
            u16::try_from(s_680_34).unwrap(),
        ));
        // D s_680_36: cast reint s_680_35 -> u8
        let s_680_36: bool = ((s_680_35.value()) != 0);
        // C s_680_37: const #0s : i
        let s_680_37: i128 = 0;
        // C s_680_38: const #0u : u64
        let s_680_38: u64 = 0;
        // D s_680_39: cast zx s_680_36 -> u64
        let s_680_39: u64 = (s_680_36 as u64);
        // C s_680_40: const #1u : u64
        let s_680_40: u64 = 1;
        // D s_680_41: and s_680_39 s_680_40
        let s_680_41: u64 = ((s_680_39) & (s_680_40));
        // D s_680_42: cmp-eq s_680_41 s_680_40
        let s_680_42: bool = ((s_680_41) == (s_680_40));
        // D s_680_43: lsl s_680_39 s_680_37
        let s_680_43: u64 = s_680_39 << s_680_37;
        // D s_680_44: or s_680_38 s_680_43
        let s_680_44: u64 = ((s_680_38) | (s_680_43));
        // D s_680_45: cmpl s_680_43
        let s_680_45: u64 = !s_680_43;
        // D s_680_46: and s_680_38 s_680_45
        let s_680_46: u64 = ((s_680_38) & (s_680_45));
        // D s_680_47: select s_680_42 s_680_44 s_680_46
        let s_680_47: u64 = if s_680_42 { s_680_44 } else { s_680_46 };
        // D s_680_48: cast trunc s_680_47 -> u8
        let s_680_48: bool = ((s_680_47) != 0);
        // D s_680_49: cast zx s_680_48 -> bv
        let s_680_49: Bits = Bits::new(s_680_48 as u128, 1u16);
        // C s_680_50: const #0u : u8
        let s_680_50: bool = false;
        // C s_680_51: cast zx s_680_50 -> bv
        let s_680_51: Bits = Bits::new(s_680_50 as u128, 1u16);
        // D s_680_52: cmp-ne s_680_49 s_680_51
        let s_680_52: bool = ((s_680_49) != (s_680_51));
        // N s_680_53: branch s_680_52 b691 b681
        if s_680_52 {
            return block_691(state, tracer, fn_state);
        } else {
            return block_681(state, tracer, fn_state);
        };
    }
    fn block_681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_681_0: const #17s : i
        let s_681_0: i128 = 17;
        // D s_681_1: read-var u#32708:u32
        let s_681_1: u32 = fn_state.u_32708;
        // D s_681_2: cast zx s_681_1 -> bv
        let s_681_2: Bits = Bits::new(s_681_1 as u128, 32u16);
        // C s_681_3: const #1u : u64
        let s_681_3: u64 = 1;
        // D s_681_4: bit-extract s_681_2 s_681_0 s_681_3
        let s_681_4: Bits = (Bits::new(
            ((s_681_2) >> (s_681_0)).value(),
            u16::try_from(s_681_3).unwrap(),
        ));
        // D s_681_5: cast reint s_681_4 -> u8
        let s_681_5: bool = ((s_681_4.value()) != 0);
        // C s_681_6: const #0s : i
        let s_681_6: i128 = 0;
        // C s_681_7: const #0u : u64
        let s_681_7: u64 = 0;
        // D s_681_8: cast zx s_681_5 -> u64
        let s_681_8: u64 = (s_681_5 as u64);
        // C s_681_9: const #1u : u64
        let s_681_9: u64 = 1;
        // D s_681_10: and s_681_8 s_681_9
        let s_681_10: u64 = ((s_681_8) & (s_681_9));
        // D s_681_11: cmp-eq s_681_10 s_681_9
        let s_681_11: bool = ((s_681_10) == (s_681_9));
        // D s_681_12: lsl s_681_8 s_681_6
        let s_681_12: u64 = s_681_8 << s_681_6;
        // D s_681_13: or s_681_7 s_681_12
        let s_681_13: u64 = ((s_681_7) | (s_681_12));
        // D s_681_14: cmpl s_681_12
        let s_681_14: u64 = !s_681_12;
        // D s_681_15: and s_681_7 s_681_14
        let s_681_15: u64 = ((s_681_7) & (s_681_14));
        // D s_681_16: select s_681_11 s_681_13 s_681_15
        let s_681_16: u64 = if s_681_11 { s_681_13 } else { s_681_15 };
        // D s_681_17: cast trunc s_681_16 -> u8
        let s_681_17: bool = ((s_681_16) != 0);
        // D s_681_18: cast zx s_681_17 -> bv
        let s_681_18: Bits = Bits::new(s_681_17 as u128, 1u16);
        // C s_681_19: const #0u : u8
        let s_681_19: bool = false;
        // C s_681_20: cast zx s_681_19 -> bv
        let s_681_20: Bits = Bits::new(s_681_19 as u128, 1u16);
        // D s_681_21: cmp-ne s_681_18 s_681_20
        let s_681_21: bool = ((s_681_18) != (s_681_20));
        // D s_681_22: write-var gs#405649 <= s_681_21
        fn_state.gs_405649 = s_681_21;
        // N s_681_23: jump b682
        return block_682(state, tracer, fn_state);
    }
    fn block_682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_682_0: read-var gs#405649:u8
        let s_682_0: bool = fn_state.gs_405649;
        // N s_682_1: branch s_682_0 b690 b683
        if s_682_0 {
            return block_690(state, tracer, fn_state);
        } else {
            return block_683(state, tracer, fn_state);
        };
    }
    fn block_683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_683_0: const #18s : i
        let s_683_0: i128 = 18;
        // D s_683_1: read-var u#32708:u32
        let s_683_1: u32 = fn_state.u_32708;
        // D s_683_2: cast zx s_683_1 -> bv
        let s_683_2: Bits = Bits::new(s_683_1 as u128, 32u16);
        // C s_683_3: const #1u : u64
        let s_683_3: u64 = 1;
        // D s_683_4: bit-extract s_683_2 s_683_0 s_683_3
        let s_683_4: Bits = (Bits::new(
            ((s_683_2) >> (s_683_0)).value(),
            u16::try_from(s_683_3).unwrap(),
        ));
        // D s_683_5: cast reint s_683_4 -> u8
        let s_683_5: bool = ((s_683_4.value()) != 0);
        // C s_683_6: const #0s : i
        let s_683_6: i128 = 0;
        // C s_683_7: const #0u : u64
        let s_683_7: u64 = 0;
        // D s_683_8: cast zx s_683_5 -> u64
        let s_683_8: u64 = (s_683_5 as u64);
        // C s_683_9: const #1u : u64
        let s_683_9: u64 = 1;
        // D s_683_10: and s_683_8 s_683_9
        let s_683_10: u64 = ((s_683_8) & (s_683_9));
        // D s_683_11: cmp-eq s_683_10 s_683_9
        let s_683_11: bool = ((s_683_10) == (s_683_9));
        // D s_683_12: lsl s_683_8 s_683_6
        let s_683_12: u64 = s_683_8 << s_683_6;
        // D s_683_13: or s_683_7 s_683_12
        let s_683_13: u64 = ((s_683_7) | (s_683_12));
        // D s_683_14: cmpl s_683_12
        let s_683_14: u64 = !s_683_12;
        // D s_683_15: and s_683_7 s_683_14
        let s_683_15: u64 = ((s_683_7) & (s_683_14));
        // D s_683_16: select s_683_11 s_683_13 s_683_15
        let s_683_16: u64 = if s_683_11 { s_683_13 } else { s_683_15 };
        // D s_683_17: cast trunc s_683_16 -> u8
        let s_683_17: bool = ((s_683_16) != 0);
        // D s_683_18: cast zx s_683_17 -> bv
        let s_683_18: Bits = Bits::new(s_683_17 as u128, 1u16);
        // C s_683_19: const #0u : u8
        let s_683_19: bool = false;
        // C s_683_20: cast zx s_683_19 -> bv
        let s_683_20: Bits = Bits::new(s_683_19 as u128, 1u16);
        // D s_683_21: cmp-ne s_683_18 s_683_20
        let s_683_21: bool = ((s_683_18) != (s_683_20));
        // D s_683_22: write-var gs#405652 <= s_683_21
        fn_state.gs_405652 = s_683_21;
        // N s_683_23: jump b684
        return block_684(state, tracer, fn_state);
    }
    fn block_684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_684_0: read-var gs#405652:u8
        let s_684_0: bool = fn_state.gs_405652;
        // N s_684_1: branch s_684_0 b689 b685
        if s_684_0 {
            return block_689(state, tracer, fn_state);
        } else {
            return block_685(state, tracer, fn_state);
        };
    }
    fn block_685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_685_0: const #19s : i
        let s_685_0: i128 = 19;
        // D s_685_1: read-var u#32708:u32
        let s_685_1: u32 = fn_state.u_32708;
        // D s_685_2: cast zx s_685_1 -> bv
        let s_685_2: Bits = Bits::new(s_685_1 as u128, 32u16);
        // C s_685_3: const #1u : u64
        let s_685_3: u64 = 1;
        // D s_685_4: bit-extract s_685_2 s_685_0 s_685_3
        let s_685_4: Bits = (Bits::new(
            ((s_685_2) >> (s_685_0)).value(),
            u16::try_from(s_685_3).unwrap(),
        ));
        // D s_685_5: cast reint s_685_4 -> u8
        let s_685_5: bool = ((s_685_4.value()) != 0);
        // C s_685_6: const #0s : i
        let s_685_6: i128 = 0;
        // C s_685_7: const #0u : u64
        let s_685_7: u64 = 0;
        // D s_685_8: cast zx s_685_5 -> u64
        let s_685_8: u64 = (s_685_5 as u64);
        // C s_685_9: const #1u : u64
        let s_685_9: u64 = 1;
        // D s_685_10: and s_685_8 s_685_9
        let s_685_10: u64 = ((s_685_8) & (s_685_9));
        // D s_685_11: cmp-eq s_685_10 s_685_9
        let s_685_11: bool = ((s_685_10) == (s_685_9));
        // D s_685_12: lsl s_685_8 s_685_6
        let s_685_12: u64 = s_685_8 << s_685_6;
        // D s_685_13: or s_685_7 s_685_12
        let s_685_13: u64 = ((s_685_7) | (s_685_12));
        // D s_685_14: cmpl s_685_12
        let s_685_14: u64 = !s_685_12;
        // D s_685_15: and s_685_7 s_685_14
        let s_685_15: u64 = ((s_685_7) & (s_685_14));
        // D s_685_16: select s_685_11 s_685_13 s_685_15
        let s_685_16: u64 = if s_685_11 { s_685_13 } else { s_685_15 };
        // D s_685_17: cast trunc s_685_16 -> u8
        let s_685_17: bool = ((s_685_16) != 0);
        // D s_685_18: cast zx s_685_17 -> bv
        let s_685_18: Bits = Bits::new(s_685_17 as u128, 1u16);
        // C s_685_19: const #0u : u8
        let s_685_19: bool = false;
        // C s_685_20: cast zx s_685_19 -> bv
        let s_685_20: Bits = Bits::new(s_685_19 as u128, 1u16);
        // D s_685_21: cmp-ne s_685_18 s_685_20
        let s_685_21: bool = ((s_685_18) != (s_685_20));
        // D s_685_22: write-var gs#405655 <= s_685_21
        fn_state.gs_405655 = s_685_21;
        // N s_685_23: jump b686
        return block_686(state, tracer, fn_state);
    }
    fn block_686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_686_0: read-var gs#405655:u8
        let s_686_0: bool = fn_state.gs_405655;
        // N s_686_1: branch s_686_0 b688 b687
        if s_686_0 {
            return block_688(state, tracer, fn_state);
        } else {
            return block_687(state, tracer, fn_state);
        };
    }
    fn block_687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_687_0: read-var u#32709:u8
        let s_687_0: u8 = fn_state.u_32709;
        // D s_687_1: read-var u#32710:u8
        let s_687_1: bool = fn_state.u_32710;
        // D s_687_2: read-var u#32711:u8
        let s_687_2: u8 = fn_state.u_32711;
        // D s_687_3: read-var u#32712:u12
        let s_687_3: u16 = fn_state.u_32712;
        // D s_687_4: call decode_aarch32_instrs_MOV_i_A1enc_A_txt(s_687_0, s_687_1, s_687_2, s_687_3)
        let s_687_4: () = decode_aarch32_instrs_MOV_i_A1enc_A_txt(
            state,
            tracer,
            s_687_0,
            s_687_1,
            s_687_2,
            s_687_3,
        );
        // N s_687_5: return
        return;
    }
    fn block_688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_688_0: panic
        panic!("{:?}", ());
        // N s_688_1: return
        return;
    }
    fn block_689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_689_0: const #1u : u8
        let s_689_0: bool = true;
        // D s_689_1: write-var gs#405655 <= s_689_0
        fn_state.gs_405655 = s_689_0;
        // N s_689_2: jump b686
        return block_686(state, tracer, fn_state);
    }
    fn block_690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_690_0: const #1u : u8
        let s_690_0: bool = true;
        // D s_690_1: write-var gs#405652 <= s_690_0
        fn_state.gs_405652 = s_690_0;
        // N s_690_2: jump b684
        return block_684(state, tracer, fn_state);
    }
    fn block_691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_691_0: const #1u : u8
        let s_691_0: bool = true;
        // D s_691_1: write-var gs#405649 <= s_691_0
        fn_state.gs_405649 = s_691_0;
        // N s_691_2: jump b682
        return block_682(state, tracer, fn_state);
    }
    fn block_692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_692_0: read-var merge#var.1:struct
        let s_692_0: u32 = fn_state.merge_var._1;
        // D s_692_1: write-var u#32714 <= s_692_0
        fn_state.u_32714 = s_692_0;
        // C s_692_2: const #20s : i
        let s_692_2: i128 = 20;
        // D s_692_3: read-var u#32714:u32
        let s_692_3: u32 = fn_state.u_32714;
        // D s_692_4: cast zx s_692_3 -> bv
        let s_692_4: Bits = Bits::new(s_692_3 as u128, 32u16);
        // C s_692_5: const #1s : i64
        let s_692_5: i64 = 1;
        // C s_692_6: cast zx s_692_5 -> i
        let s_692_6: i128 = (i128::try_from(s_692_5).unwrap());
        // C s_692_7: const #7s : i
        let s_692_7: i128 = 7;
        // C s_692_8: add s_692_7 s_692_6
        let s_692_8: i128 = (s_692_7 + s_692_6);
        // D s_692_9: bit-extract s_692_4 s_692_2 s_692_8
        let s_692_9: Bits = (Bits::new(
            ((s_692_4) >> (s_692_2)).value(),
            u16::try_from(s_692_8).unwrap(),
        ));
        // D s_692_10: cast reint s_692_9 -> u8
        let s_692_10: u8 = (s_692_9.value() as u8);
        // D s_692_11: cast zx s_692_10 -> bv
        let s_692_11: Bits = Bits::new(s_692_10 as u128, 8u16);
        // C s_692_12: const #48u : u8
        let s_692_12: u8 = 48;
        // C s_692_13: cast zx s_692_12 -> bv
        let s_692_13: Bits = Bits::new(s_692_12 as u128, 8u16);
        // D s_692_14: cmp-eq s_692_11 s_692_13
        let s_692_14: bool = ((s_692_11) == (s_692_13));
        // N s_692_15: branch s_692_14 b2604 b693
        if s_692_14 {
            return block_2604(state, tracer, fn_state);
        } else {
            return block_693(state, tracer, fn_state);
        };
    }
    fn block_693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_693_0: const #0u : u8
        let s_693_0: bool = false;
        // D s_693_1: write-var gs#405663 <= s_693_0
        fn_state.gs_405663 = s_693_0;
        // N s_693_2: jump b694
        return block_694(state, tracer, fn_state);
    }
    fn block_694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_694_0: read-var gs#405663:u8
        let s_694_0: bool = fn_state.gs_405663;
        // D s_694_1: not s_694_0
        let s_694_1: bool = !s_694_0;
        // N s_694_2: branch s_694_1 b696 b695
        if s_694_1 {
            return block_696(state, tracer, fn_state);
        } else {
            return block_695(state, tracer, fn_state);
        };
    }
    fn block_695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_695_0: const #3010s : i
        let s_695_0: i128 = 3010;
        // C s_695_1: const #14696u : u32
        let s_695_1: u32 = 14696;
        // N s_695_2: write-reg s_695_1 <= s_695_0
        let s_695_2: () = {
            state.write_register::<i128>(s_695_1 as isize, s_695_0);
            tracer.write_register(s_695_1 as isize, s_695_0);
        };
        // C s_695_3: const #28s : i
        let s_695_3: i128 = 28;
        // C s_695_4: const #4s : i
        let s_695_4: i128 = 4;
        // D s_695_5: read-var u#32714:u32
        let s_695_5: u32 = fn_state.u_32714;
        // D s_695_6: cast zx s_695_5 -> bv
        let s_695_6: Bits = Bits::new(s_695_5 as u128, 32u16);
        // D s_695_7: bit-extract s_695_6 s_695_3 s_695_4
        let s_695_7: Bits = (Bits::new(
            ((s_695_6) >> (s_695_3)).value(),
            u16::try_from(s_695_4).unwrap(),
        ));
        // D s_695_8: cast reint s_695_7 -> u8
        let s_695_8: u8 = (s_695_7.value() as u8);
        // C s_695_9: const #16s : i
        let s_695_9: i128 = 16;
        // C s_695_10: const #4s : i
        let s_695_10: i128 = 4;
        // D s_695_11: read-var u#32714:u32
        let s_695_11: u32 = fn_state.u_32714;
        // D s_695_12: cast zx s_695_11 -> bv
        let s_695_12: Bits = Bits::new(s_695_11 as u128, 32u16);
        // D s_695_13: bit-extract s_695_12 s_695_9 s_695_10
        let s_695_13: Bits = (Bits::new(
            ((s_695_12) >> (s_695_9)).value(),
            u16::try_from(s_695_10).unwrap(),
        ));
        // D s_695_14: cast reint s_695_13 -> u8
        let s_695_14: u8 = (s_695_13.value() as u8);
        // C s_695_15: const #12s : i
        let s_695_15: i128 = 12;
        // C s_695_16: const #4s : i
        let s_695_16: i128 = 4;
        // D s_695_17: read-var u#32714:u32
        let s_695_17: u32 = fn_state.u_32714;
        // D s_695_18: cast zx s_695_17 -> bv
        let s_695_18: Bits = Bits::new(s_695_17 as u128, 32u16);
        // D s_695_19: bit-extract s_695_18 s_695_15 s_695_16
        let s_695_19: Bits = (Bits::new(
            ((s_695_18) >> (s_695_15)).value(),
            u16::try_from(s_695_16).unwrap(),
        ));
        // D s_695_20: cast reint s_695_19 -> u8
        let s_695_20: u8 = (s_695_19.value() as u8);
        // C s_695_21: const #0s : i
        let s_695_21: i128 = 0;
        // C s_695_22: const #12s : i
        let s_695_22: i128 = 12;
        // D s_695_23: read-var u#32714:u32
        let s_695_23: u32 = fn_state.u_32714;
        // D s_695_24: cast zx s_695_23 -> bv
        let s_695_24: Bits = Bits::new(s_695_23 as u128, 32u16);
        // D s_695_25: bit-extract s_695_24 s_695_21 s_695_22
        let s_695_25: Bits = (Bits::new(
            ((s_695_24) >> (s_695_21)).value(),
            u16::try_from(s_695_22).unwrap(),
        ));
        // D s_695_26: cast reint s_695_25 -> u12
        let s_695_26: u16 = (s_695_25.value() as u16);
        // D s_695_27: call decode_aarch32_instrs_MOV_i_A2enc_A_txt(s_695_8, s_695_14, s_695_20, s_695_26)
        let s_695_27: () = decode_aarch32_instrs_MOV_i_A2enc_A_txt(
            state,
            tracer,
            s_695_8,
            s_695_14,
            s_695_20,
            s_695_26,
        );
        // N s_695_28: return
        return;
    }
    fn block_696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_696_0: read-var merge#var.1:struct
        let s_696_0: u32 = fn_state.merge_var._1;
        // D s_696_1: write-var u#32720 <= s_696_0
        fn_state.u_32720 = s_696_0;
        // C s_696_2: const #21s : i
        let s_696_2: i128 = 21;
        // D s_696_3: read-var u#32720:u32
        let s_696_3: u32 = fn_state.u_32720;
        // D s_696_4: cast zx s_696_3 -> bv
        let s_696_4: Bits = Bits::new(s_696_3 as u128, 32u16);
        // C s_696_5: const #1s : i64
        let s_696_5: i64 = 1;
        // C s_696_6: cast zx s_696_5 -> i
        let s_696_6: i128 = (i128::try_from(s_696_5).unwrap());
        // C s_696_7: const #6s : i
        let s_696_7: i128 = 6;
        // C s_696_8: add s_696_7 s_696_6
        let s_696_8: i128 = (s_696_7 + s_696_6);
        // D s_696_9: bit-extract s_696_4 s_696_2 s_696_8
        let s_696_9: Bits = (Bits::new(
            ((s_696_4) >> (s_696_2)).value(),
            u16::try_from(s_696_8).unwrap(),
        ));
        // D s_696_10: cast reint s_696_9 -> u8
        let s_696_10: u8 = (s_696_9.value() as u8);
        // D s_696_11: cast zx s_696_10 -> bv
        let s_696_11: Bits = Bits::new(s_696_10 as u128, 7u16);
        // C s_696_12: const #13u : u8
        let s_696_12: u8 = 13;
        // C s_696_13: cast zx s_696_12 -> bv
        let s_696_13: Bits = Bits::new(s_696_12 as u128, 7u16);
        // D s_696_14: cmp-eq s_696_11 s_696_13
        let s_696_14: bool = ((s_696_11) == (s_696_13));
        // N s_696_15: branch s_696_14 b2600 b697
        if s_696_14 {
            return block_2600(state, tracer, fn_state);
        } else {
            return block_697(state, tracer, fn_state);
        };
    }
    fn block_697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_697_0: const #0u : u8
        let s_697_0: bool = false;
        // D s_697_1: write-var gs#405682 <= s_697_0
        fn_state.gs_405682 = s_697_0;
        // N s_697_2: jump b698
        return block_698(state, tracer, fn_state);
    }
    fn block_698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_698_0: read-var gs#405682:u8
        let s_698_0: bool = fn_state.gs_405682;
        // N s_698_1: branch s_698_0 b2596 b699
        if s_698_0 {
            return block_2596(state, tracer, fn_state);
        } else {
            return block_699(state, tracer, fn_state);
        };
    }
    fn block_699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_699_0: const #0u : u8
        let s_699_0: bool = false;
        // D s_699_1: write-var gs#405687 <= s_699_0
        fn_state.gs_405687 = s_699_0;
        // N s_699_2: jump b700
        return block_700(state, tracer, fn_state);
    }
    fn block_700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_700_0: read-var gs#405687:u8
        let s_700_0: bool = fn_state.gs_405687;
        // D s_700_1: not s_700_0
        let s_700_1: bool = !s_700_0;
        // N s_700_2: branch s_700_1 b713 b701
        if s_700_1 {
            return block_713(state, tracer, fn_state);
        } else {
            return block_701(state, tracer, fn_state);
        };
    }
    fn block_701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_701_0: const #3014s : i
        let s_701_0: i128 = 3014;
        // C s_701_1: const #14696u : u32
        let s_701_1: u32 = 14696;
        // N s_701_2: write-reg s_701_1 <= s_701_0
        let s_701_2: () = {
            state.write_register::<i128>(s_701_1 as isize, s_701_0);
            tracer.write_register(s_701_1 as isize, s_701_0);
        };
        // C s_701_3: const #28s : i
        let s_701_3: i128 = 28;
        // C s_701_4: const #4s : i
        let s_701_4: i128 = 4;
        // D s_701_5: read-var u#32720:u32
        let s_701_5: u32 = fn_state.u_32720;
        // D s_701_6: cast zx s_701_5 -> bv
        let s_701_6: Bits = Bits::new(s_701_5 as u128, 32u16);
        // D s_701_7: bit-extract s_701_6 s_701_3 s_701_4
        let s_701_7: Bits = (Bits::new(
            ((s_701_6) >> (s_701_3)).value(),
            u16::try_from(s_701_4).unwrap(),
        ));
        // D s_701_8: cast reint s_701_7 -> u8
        let s_701_8: u8 = (s_701_7.value() as u8);
        // D s_701_9: write-var u#32721 <= s_701_8
        fn_state.u_32721 = s_701_8;
        // C s_701_10: const #20s : i
        let s_701_10: i128 = 20;
        // C s_701_11: const #1s : i
        let s_701_11: i128 = 1;
        // D s_701_12: read-var u#32720:u32
        let s_701_12: u32 = fn_state.u_32720;
        // D s_701_13: cast zx s_701_12 -> bv
        let s_701_13: Bits = Bits::new(s_701_12 as u128, 32u16);
        // D s_701_14: bit-extract s_701_13 s_701_10 s_701_11
        let s_701_14: Bits = (Bits::new(
            ((s_701_13) >> (s_701_10)).value(),
            u16::try_from(s_701_11).unwrap(),
        ));
        // D s_701_15: cast reint s_701_14 -> u8
        let s_701_15: bool = ((s_701_14.value()) != 0);
        // D s_701_16: write-var u#32722 <= s_701_15
        fn_state.u_32722 = s_701_15;
        // C s_701_17: const #12s : i
        let s_701_17: i128 = 12;
        // C s_701_18: const #4s : i
        let s_701_18: i128 = 4;
        // D s_701_19: read-var u#32720:u32
        let s_701_19: u32 = fn_state.u_32720;
        // D s_701_20: cast zx s_701_19 -> bv
        let s_701_20: Bits = Bits::new(s_701_19 as u128, 32u16);
        // D s_701_21: bit-extract s_701_20 s_701_17 s_701_18
        let s_701_21: Bits = (Bits::new(
            ((s_701_20) >> (s_701_17)).value(),
            u16::try_from(s_701_18).unwrap(),
        ));
        // D s_701_22: cast reint s_701_21 -> u8
        let s_701_22: u8 = (s_701_21.value() as u8);
        // D s_701_23: write-var u#32723 <= s_701_22
        fn_state.u_32723 = s_701_22;
        // C s_701_24: const #7s : i
        let s_701_24: i128 = 7;
        // C s_701_25: const #5s : i
        let s_701_25: i128 = 5;
        // D s_701_26: read-var u#32720:u32
        let s_701_26: u32 = fn_state.u_32720;
        // D s_701_27: cast zx s_701_26 -> bv
        let s_701_27: Bits = Bits::new(s_701_26 as u128, 32u16);
        // D s_701_28: bit-extract s_701_27 s_701_24 s_701_25
        let s_701_28: Bits = (Bits::new(
            ((s_701_27) >> (s_701_24)).value(),
            u16::try_from(s_701_25).unwrap(),
        ));
        // D s_701_29: cast reint s_701_28 -> u8
        let s_701_29: u8 = (s_701_28.value() as u8);
        // D s_701_30: write-var u#32724 <= s_701_29
        fn_state.u_32724 = s_701_29;
        // C s_701_31: const #5s : i
        let s_701_31: i128 = 5;
        // C s_701_32: const #2s : i
        let s_701_32: i128 = 2;
        // D s_701_33: read-var u#32720:u32
        let s_701_33: u32 = fn_state.u_32720;
        // D s_701_34: cast zx s_701_33 -> bv
        let s_701_34: Bits = Bits::new(s_701_33 as u128, 32u16);
        // D s_701_35: bit-extract s_701_34 s_701_31 s_701_32
        let s_701_35: Bits = (Bits::new(
            ((s_701_34) >> (s_701_31)).value(),
            u16::try_from(s_701_32).unwrap(),
        ));
        // D s_701_36: cast reint s_701_35 -> u8
        let s_701_36: u8 = (s_701_35.value() as u8);
        // D s_701_37: write-var u#32725 <= s_701_36
        fn_state.u_32725 = s_701_36;
        // C s_701_38: const #0s : i
        let s_701_38: i128 = 0;
        // C s_701_39: const #4s : i
        let s_701_39: i128 = 4;
        // D s_701_40: read-var u#32720:u32
        let s_701_40: u32 = fn_state.u_32720;
        // D s_701_41: cast zx s_701_40 -> bv
        let s_701_41: Bits = Bits::new(s_701_40 as u128, 32u16);
        // D s_701_42: bit-extract s_701_41 s_701_38 s_701_39
        let s_701_42: Bits = (Bits::new(
            ((s_701_41) >> (s_701_38)).value(),
            u16::try_from(s_701_39).unwrap(),
        ));
        // D s_701_43: cast reint s_701_42 -> u8
        let s_701_43: u8 = (s_701_42.value() as u8);
        // D s_701_44: write-var u#32726 <= s_701_43
        fn_state.u_32726 = s_701_43;
        // C s_701_45: const #16s : i
        let s_701_45: i128 = 16;
        // D s_701_46: read-var u#32720:u32
        let s_701_46: u32 = fn_state.u_32720;
        // D s_701_47: cast zx s_701_46 -> bv
        let s_701_47: Bits = Bits::new(s_701_46 as u128, 32u16);
        // C s_701_48: const #1u : u64
        let s_701_48: u64 = 1;
        // D s_701_49: bit-extract s_701_47 s_701_45 s_701_48
        let s_701_49: Bits = (Bits::new(
            ((s_701_47) >> (s_701_45)).value(),
            u16::try_from(s_701_48).unwrap(),
        ));
        // D s_701_50: cast reint s_701_49 -> u8
        let s_701_50: bool = ((s_701_49.value()) != 0);
        // C s_701_51: const #0s : i
        let s_701_51: i128 = 0;
        // C s_701_52: const #0u : u64
        let s_701_52: u64 = 0;
        // D s_701_53: cast zx s_701_50 -> u64
        let s_701_53: u64 = (s_701_50 as u64);
        // C s_701_54: const #1u : u64
        let s_701_54: u64 = 1;
        // D s_701_55: and s_701_53 s_701_54
        let s_701_55: u64 = ((s_701_53) & (s_701_54));
        // D s_701_56: cmp-eq s_701_55 s_701_54
        let s_701_56: bool = ((s_701_55) == (s_701_54));
        // D s_701_57: lsl s_701_53 s_701_51
        let s_701_57: u64 = s_701_53 << s_701_51;
        // D s_701_58: or s_701_52 s_701_57
        let s_701_58: u64 = ((s_701_52) | (s_701_57));
        // D s_701_59: cmpl s_701_57
        let s_701_59: u64 = !s_701_57;
        // D s_701_60: and s_701_52 s_701_59
        let s_701_60: u64 = ((s_701_52) & (s_701_59));
        // D s_701_61: select s_701_56 s_701_58 s_701_60
        let s_701_61: u64 = if s_701_56 { s_701_58 } else { s_701_60 };
        // D s_701_62: cast trunc s_701_61 -> u8
        let s_701_62: bool = ((s_701_61) != 0);
        // D s_701_63: cast zx s_701_62 -> bv
        let s_701_63: Bits = Bits::new(s_701_62 as u128, 1u16);
        // C s_701_64: const #0u : u8
        let s_701_64: bool = false;
        // C s_701_65: cast zx s_701_64 -> bv
        let s_701_65: Bits = Bits::new(s_701_64 as u128, 1u16);
        // D s_701_66: cmp-ne s_701_63 s_701_65
        let s_701_66: bool = ((s_701_63) != (s_701_65));
        // N s_701_67: branch s_701_66 b712 b702
        if s_701_66 {
            return block_712(state, tracer, fn_state);
        } else {
            return block_702(state, tracer, fn_state);
        };
    }
    fn block_702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_702_0: const #17s : i
        let s_702_0: i128 = 17;
        // D s_702_1: read-var u#32720:u32
        let s_702_1: u32 = fn_state.u_32720;
        // D s_702_2: cast zx s_702_1 -> bv
        let s_702_2: Bits = Bits::new(s_702_1 as u128, 32u16);
        // C s_702_3: const #1u : u64
        let s_702_3: u64 = 1;
        // D s_702_4: bit-extract s_702_2 s_702_0 s_702_3
        let s_702_4: Bits = (Bits::new(
            ((s_702_2) >> (s_702_0)).value(),
            u16::try_from(s_702_3).unwrap(),
        ));
        // D s_702_5: cast reint s_702_4 -> u8
        let s_702_5: bool = ((s_702_4.value()) != 0);
        // C s_702_6: const #0s : i
        let s_702_6: i128 = 0;
        // C s_702_7: const #0u : u64
        let s_702_7: u64 = 0;
        // D s_702_8: cast zx s_702_5 -> u64
        let s_702_8: u64 = (s_702_5 as u64);
        // C s_702_9: const #1u : u64
        let s_702_9: u64 = 1;
        // D s_702_10: and s_702_8 s_702_9
        let s_702_10: u64 = ((s_702_8) & (s_702_9));
        // D s_702_11: cmp-eq s_702_10 s_702_9
        let s_702_11: bool = ((s_702_10) == (s_702_9));
        // D s_702_12: lsl s_702_8 s_702_6
        let s_702_12: u64 = s_702_8 << s_702_6;
        // D s_702_13: or s_702_7 s_702_12
        let s_702_13: u64 = ((s_702_7) | (s_702_12));
        // D s_702_14: cmpl s_702_12
        let s_702_14: u64 = !s_702_12;
        // D s_702_15: and s_702_7 s_702_14
        let s_702_15: u64 = ((s_702_7) & (s_702_14));
        // D s_702_16: select s_702_11 s_702_13 s_702_15
        let s_702_16: u64 = if s_702_11 { s_702_13 } else { s_702_15 };
        // D s_702_17: cast trunc s_702_16 -> u8
        let s_702_17: bool = ((s_702_16) != 0);
        // D s_702_18: cast zx s_702_17 -> bv
        let s_702_18: Bits = Bits::new(s_702_17 as u128, 1u16);
        // C s_702_19: const #0u : u8
        let s_702_19: bool = false;
        // C s_702_20: cast zx s_702_19 -> bv
        let s_702_20: Bits = Bits::new(s_702_19 as u128, 1u16);
        // D s_702_21: cmp-ne s_702_18 s_702_20
        let s_702_21: bool = ((s_702_18) != (s_702_20));
        // D s_702_22: write-var gs#405706 <= s_702_21
        fn_state.gs_405706 = s_702_21;
        // N s_702_23: jump b703
        return block_703(state, tracer, fn_state);
    }
    fn block_703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_703_0: read-var gs#405706:u8
        let s_703_0: bool = fn_state.gs_405706;
        // N s_703_1: branch s_703_0 b711 b704
        if s_703_0 {
            return block_711(state, tracer, fn_state);
        } else {
            return block_704(state, tracer, fn_state);
        };
    }
    fn block_704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_704_0: const #18s : i
        let s_704_0: i128 = 18;
        // D s_704_1: read-var u#32720:u32
        let s_704_1: u32 = fn_state.u_32720;
        // D s_704_2: cast zx s_704_1 -> bv
        let s_704_2: Bits = Bits::new(s_704_1 as u128, 32u16);
        // C s_704_3: const #1u : u64
        let s_704_3: u64 = 1;
        // D s_704_4: bit-extract s_704_2 s_704_0 s_704_3
        let s_704_4: Bits = (Bits::new(
            ((s_704_2) >> (s_704_0)).value(),
            u16::try_from(s_704_3).unwrap(),
        ));
        // D s_704_5: cast reint s_704_4 -> u8
        let s_704_5: bool = ((s_704_4.value()) != 0);
        // C s_704_6: const #0s : i
        let s_704_6: i128 = 0;
        // C s_704_7: const #0u : u64
        let s_704_7: u64 = 0;
        // D s_704_8: cast zx s_704_5 -> u64
        let s_704_8: u64 = (s_704_5 as u64);
        // C s_704_9: const #1u : u64
        let s_704_9: u64 = 1;
        // D s_704_10: and s_704_8 s_704_9
        let s_704_10: u64 = ((s_704_8) & (s_704_9));
        // D s_704_11: cmp-eq s_704_10 s_704_9
        let s_704_11: bool = ((s_704_10) == (s_704_9));
        // D s_704_12: lsl s_704_8 s_704_6
        let s_704_12: u64 = s_704_8 << s_704_6;
        // D s_704_13: or s_704_7 s_704_12
        let s_704_13: u64 = ((s_704_7) | (s_704_12));
        // D s_704_14: cmpl s_704_12
        let s_704_14: u64 = !s_704_12;
        // D s_704_15: and s_704_7 s_704_14
        let s_704_15: u64 = ((s_704_7) & (s_704_14));
        // D s_704_16: select s_704_11 s_704_13 s_704_15
        let s_704_16: u64 = if s_704_11 { s_704_13 } else { s_704_15 };
        // D s_704_17: cast trunc s_704_16 -> u8
        let s_704_17: bool = ((s_704_16) != 0);
        // D s_704_18: cast zx s_704_17 -> bv
        let s_704_18: Bits = Bits::new(s_704_17 as u128, 1u16);
        // C s_704_19: const #0u : u8
        let s_704_19: bool = false;
        // C s_704_20: cast zx s_704_19 -> bv
        let s_704_20: Bits = Bits::new(s_704_19 as u128, 1u16);
        // D s_704_21: cmp-ne s_704_18 s_704_20
        let s_704_21: bool = ((s_704_18) != (s_704_20));
        // D s_704_22: write-var gs#405709 <= s_704_21
        fn_state.gs_405709 = s_704_21;
        // N s_704_23: jump b705
        return block_705(state, tracer, fn_state);
    }
    fn block_705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_705_0: read-var gs#405709:u8
        let s_705_0: bool = fn_state.gs_405709;
        // N s_705_1: branch s_705_0 b710 b706
        if s_705_0 {
            return block_710(state, tracer, fn_state);
        } else {
            return block_706(state, tracer, fn_state);
        };
    }
    fn block_706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_706_0: const #19s : i
        let s_706_0: i128 = 19;
        // D s_706_1: read-var u#32720:u32
        let s_706_1: u32 = fn_state.u_32720;
        // D s_706_2: cast zx s_706_1 -> bv
        let s_706_2: Bits = Bits::new(s_706_1 as u128, 32u16);
        // C s_706_3: const #1u : u64
        let s_706_3: u64 = 1;
        // D s_706_4: bit-extract s_706_2 s_706_0 s_706_3
        let s_706_4: Bits = (Bits::new(
            ((s_706_2) >> (s_706_0)).value(),
            u16::try_from(s_706_3).unwrap(),
        ));
        // D s_706_5: cast reint s_706_4 -> u8
        let s_706_5: bool = ((s_706_4.value()) != 0);
        // C s_706_6: const #0s : i
        let s_706_6: i128 = 0;
        // C s_706_7: const #0u : u64
        let s_706_7: u64 = 0;
        // D s_706_8: cast zx s_706_5 -> u64
        let s_706_8: u64 = (s_706_5 as u64);
        // C s_706_9: const #1u : u64
        let s_706_9: u64 = 1;
        // D s_706_10: and s_706_8 s_706_9
        let s_706_10: u64 = ((s_706_8) & (s_706_9));
        // D s_706_11: cmp-eq s_706_10 s_706_9
        let s_706_11: bool = ((s_706_10) == (s_706_9));
        // D s_706_12: lsl s_706_8 s_706_6
        let s_706_12: u64 = s_706_8 << s_706_6;
        // D s_706_13: or s_706_7 s_706_12
        let s_706_13: u64 = ((s_706_7) | (s_706_12));
        // D s_706_14: cmpl s_706_12
        let s_706_14: u64 = !s_706_12;
        // D s_706_15: and s_706_7 s_706_14
        let s_706_15: u64 = ((s_706_7) & (s_706_14));
        // D s_706_16: select s_706_11 s_706_13 s_706_15
        let s_706_16: u64 = if s_706_11 { s_706_13 } else { s_706_15 };
        // D s_706_17: cast trunc s_706_16 -> u8
        let s_706_17: bool = ((s_706_16) != 0);
        // D s_706_18: cast zx s_706_17 -> bv
        let s_706_18: Bits = Bits::new(s_706_17 as u128, 1u16);
        // C s_706_19: const #0u : u8
        let s_706_19: bool = false;
        // C s_706_20: cast zx s_706_19 -> bv
        let s_706_20: Bits = Bits::new(s_706_19 as u128, 1u16);
        // D s_706_21: cmp-ne s_706_18 s_706_20
        let s_706_21: bool = ((s_706_18) != (s_706_20));
        // D s_706_22: write-var gs#405712 <= s_706_21
        fn_state.gs_405712 = s_706_21;
        // N s_706_23: jump b707
        return block_707(state, tracer, fn_state);
    }
    fn block_707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_707_0: read-var gs#405712:u8
        let s_707_0: bool = fn_state.gs_405712;
        // N s_707_1: branch s_707_0 b709 b708
        if s_707_0 {
            return block_709(state, tracer, fn_state);
        } else {
            return block_708(state, tracer, fn_state);
        };
    }
    fn block_708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_708_0: read-var u#32721:u8
        let s_708_0: u8 = fn_state.u_32721;
        // D s_708_1: read-var u#32722:u8
        let s_708_1: bool = fn_state.u_32722;
        // D s_708_2: read-var u#32723:u8
        let s_708_2: u8 = fn_state.u_32723;
        // D s_708_3: read-var u#32724:u8
        let s_708_3: u8 = fn_state.u_32724;
        // D s_708_4: read-var u#32725:u8
        let s_708_4: u8 = fn_state.u_32725;
        // D s_708_5: read-var u#32726:u8
        let s_708_5: u8 = fn_state.u_32726;
        // D s_708_6: call decode_aarch32_instrs_MOV_r_A1enc_A_txt(s_708_0, s_708_1, s_708_2, s_708_3, s_708_4, s_708_5)
        let s_708_6: () = decode_aarch32_instrs_MOV_r_A1enc_A_txt(
            state,
            tracer,
            s_708_0,
            s_708_1,
            s_708_2,
            s_708_3,
            s_708_4,
            s_708_5,
        );
        // N s_708_7: return
        return;
    }
    fn block_709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_709_0: panic
        panic!("{:?}", ());
        // N s_709_1: return
        return;
    }
    fn block_710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_710_0: const #1u : u8
        let s_710_0: bool = true;
        // D s_710_1: write-var gs#405712 <= s_710_0
        fn_state.gs_405712 = s_710_0;
        // N s_710_2: jump b707
        return block_707(state, tracer, fn_state);
    }
    fn block_711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_711_0: const #1u : u8
        let s_711_0: bool = true;
        // D s_711_1: write-var gs#405709 <= s_711_0
        fn_state.gs_405709 = s_711_0;
        // N s_711_2: jump b705
        return block_705(state, tracer, fn_state);
    }
    fn block_712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_712_0: const #1u : u8
        let s_712_0: bool = true;
        // D s_712_1: write-var gs#405706 <= s_712_0
        fn_state.gs_405706 = s_712_0;
        // N s_712_2: jump b703
        return block_703(state, tracer, fn_state);
    }
    fn block_713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_713_0: read-var merge#var.1:struct
        let s_713_0: u32 = fn_state.merge_var._1;
        // D s_713_1: write-var u#32728 <= s_713_0
        fn_state.u_32728 = s_713_0;
        // C s_713_2: const #21s : i
        let s_713_2: i128 = 21;
        // D s_713_3: read-var u#32728:u32
        let s_713_3: u32 = fn_state.u_32728;
        // D s_713_4: cast zx s_713_3 -> bv
        let s_713_4: Bits = Bits::new(s_713_3 as u128, 32u16);
        // C s_713_5: const #1s : i64
        let s_713_5: i64 = 1;
        // C s_713_6: cast zx s_713_5 -> i
        let s_713_6: i128 = (i128::try_from(s_713_5).unwrap());
        // C s_713_7: const #6s : i
        let s_713_7: i128 = 6;
        // C s_713_8: add s_713_7 s_713_6
        let s_713_8: i128 = (s_713_7 + s_713_6);
        // D s_713_9: bit-extract s_713_4 s_713_2 s_713_8
        let s_713_9: Bits = (Bits::new(
            ((s_713_4) >> (s_713_2)).value(),
            u16::try_from(s_713_8).unwrap(),
        ));
        // D s_713_10: cast reint s_713_9 -> u8
        let s_713_10: u8 = (s_713_9.value() as u8);
        // D s_713_11: cast zx s_713_10 -> bv
        let s_713_11: Bits = Bits::new(s_713_10 as u128, 7u16);
        // C s_713_12: const #13u : u8
        let s_713_12: u8 = 13;
        // C s_713_13: cast zx s_713_12 -> bv
        let s_713_13: Bits = Bits::new(s_713_12 as u128, 7u16);
        // D s_713_14: cmp-eq s_713_11 s_713_13
        let s_713_14: bool = ((s_713_11) == (s_713_13));
        // N s_713_15: branch s_713_14 b2589 b714
        if s_713_14 {
            return block_2589(state, tracer, fn_state);
        } else {
            return block_714(state, tracer, fn_state);
        };
    }
    fn block_714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_714_0: const #0u : u8
        let s_714_0: bool = false;
        // D s_714_1: write-var gs#405724 <= s_714_0
        fn_state.gs_405724 = s_714_0;
        // N s_714_2: jump b715
        return block_715(state, tracer, fn_state);
    }
    fn block_715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_715_0: read-var gs#405724:u8
        let s_715_0: bool = fn_state.gs_405724;
        // N s_715_1: branch s_715_0 b2585 b716
        if s_715_0 {
            return block_2585(state, tracer, fn_state);
        } else {
            return block_716(state, tracer, fn_state);
        };
    }
    fn block_716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_716_0: const #0u : u8
        let s_716_0: bool = false;
        // D s_716_1: write-var gs#405729 <= s_716_0
        fn_state.gs_405729 = s_716_0;
        // N s_716_2: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_717_0: read-var gs#405729:u8
        let s_717_0: bool = fn_state.gs_405729;
        // D s_717_1: not s_717_0
        let s_717_1: bool = !s_717_0;
        // N s_717_2: branch s_717_1 b730 b718
        if s_717_1 {
            return block_730(state, tracer, fn_state);
        } else {
            return block_718(state, tracer, fn_state);
        };
    }
    fn block_718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_718_0: const #3018s : i
        let s_718_0: i128 = 3018;
        // C s_718_1: const #14696u : u32
        let s_718_1: u32 = 14696;
        // N s_718_2: write-reg s_718_1 <= s_718_0
        let s_718_2: () = {
            state.write_register::<i128>(s_718_1 as isize, s_718_0);
            tracer.write_register(s_718_1 as isize, s_718_0);
        };
        // C s_718_3: const #28s : i
        let s_718_3: i128 = 28;
        // C s_718_4: const #4s : i
        let s_718_4: i128 = 4;
        // D s_718_5: read-var u#32728:u32
        let s_718_5: u32 = fn_state.u_32728;
        // D s_718_6: cast zx s_718_5 -> bv
        let s_718_6: Bits = Bits::new(s_718_5 as u128, 32u16);
        // D s_718_7: bit-extract s_718_6 s_718_3 s_718_4
        let s_718_7: Bits = (Bits::new(
            ((s_718_6) >> (s_718_3)).value(),
            u16::try_from(s_718_4).unwrap(),
        ));
        // D s_718_8: cast reint s_718_7 -> u8
        let s_718_8: u8 = (s_718_7.value() as u8);
        // D s_718_9: write-var u#32729 <= s_718_8
        fn_state.u_32729 = s_718_8;
        // C s_718_10: const #20s : i
        let s_718_10: i128 = 20;
        // C s_718_11: const #1s : i
        let s_718_11: i128 = 1;
        // D s_718_12: read-var u#32728:u32
        let s_718_12: u32 = fn_state.u_32728;
        // D s_718_13: cast zx s_718_12 -> bv
        let s_718_13: Bits = Bits::new(s_718_12 as u128, 32u16);
        // D s_718_14: bit-extract s_718_13 s_718_10 s_718_11
        let s_718_14: Bits = (Bits::new(
            ((s_718_13) >> (s_718_10)).value(),
            u16::try_from(s_718_11).unwrap(),
        ));
        // D s_718_15: cast reint s_718_14 -> u8
        let s_718_15: bool = ((s_718_14.value()) != 0);
        // D s_718_16: write-var u#32730 <= s_718_15
        fn_state.u_32730 = s_718_15;
        // C s_718_17: const #12s : i
        let s_718_17: i128 = 12;
        // C s_718_18: const #4s : i
        let s_718_18: i128 = 4;
        // D s_718_19: read-var u#32728:u32
        let s_718_19: u32 = fn_state.u_32728;
        // D s_718_20: cast zx s_718_19 -> bv
        let s_718_20: Bits = Bits::new(s_718_19 as u128, 32u16);
        // D s_718_21: bit-extract s_718_20 s_718_17 s_718_18
        let s_718_21: Bits = (Bits::new(
            ((s_718_20) >> (s_718_17)).value(),
            u16::try_from(s_718_18).unwrap(),
        ));
        // D s_718_22: cast reint s_718_21 -> u8
        let s_718_22: u8 = (s_718_21.value() as u8);
        // D s_718_23: write-var u#32731 <= s_718_22
        fn_state.u_32731 = s_718_22;
        // C s_718_24: const #8s : i
        let s_718_24: i128 = 8;
        // C s_718_25: const #4s : i
        let s_718_25: i128 = 4;
        // D s_718_26: read-var u#32728:u32
        let s_718_26: u32 = fn_state.u_32728;
        // D s_718_27: cast zx s_718_26 -> bv
        let s_718_27: Bits = Bits::new(s_718_26 as u128, 32u16);
        // D s_718_28: bit-extract s_718_27 s_718_24 s_718_25
        let s_718_28: Bits = (Bits::new(
            ((s_718_27) >> (s_718_24)).value(),
            u16::try_from(s_718_25).unwrap(),
        ));
        // D s_718_29: cast reint s_718_28 -> u8
        let s_718_29: u8 = (s_718_28.value() as u8);
        // D s_718_30: write-var u#32732 <= s_718_29
        fn_state.u_32732 = s_718_29;
        // C s_718_31: const #5s : i
        let s_718_31: i128 = 5;
        // C s_718_32: const #2s : i
        let s_718_32: i128 = 2;
        // D s_718_33: read-var u#32728:u32
        let s_718_33: u32 = fn_state.u_32728;
        // D s_718_34: cast zx s_718_33 -> bv
        let s_718_34: Bits = Bits::new(s_718_33 as u128, 32u16);
        // D s_718_35: bit-extract s_718_34 s_718_31 s_718_32
        let s_718_35: Bits = (Bits::new(
            ((s_718_34) >> (s_718_31)).value(),
            u16::try_from(s_718_32).unwrap(),
        ));
        // D s_718_36: cast reint s_718_35 -> u8
        let s_718_36: u8 = (s_718_35.value() as u8);
        // D s_718_37: write-var u#32733 <= s_718_36
        fn_state.u_32733 = s_718_36;
        // C s_718_38: const #0s : i
        let s_718_38: i128 = 0;
        // C s_718_39: const #4s : i
        let s_718_39: i128 = 4;
        // D s_718_40: read-var u#32728:u32
        let s_718_40: u32 = fn_state.u_32728;
        // D s_718_41: cast zx s_718_40 -> bv
        let s_718_41: Bits = Bits::new(s_718_40 as u128, 32u16);
        // D s_718_42: bit-extract s_718_41 s_718_38 s_718_39
        let s_718_42: Bits = (Bits::new(
            ((s_718_41) >> (s_718_38)).value(),
            u16::try_from(s_718_39).unwrap(),
        ));
        // D s_718_43: cast reint s_718_42 -> u8
        let s_718_43: u8 = (s_718_42.value() as u8);
        // D s_718_44: write-var u#32734 <= s_718_43
        fn_state.u_32734 = s_718_43;
        // C s_718_45: const #16s : i
        let s_718_45: i128 = 16;
        // D s_718_46: read-var u#32728:u32
        let s_718_46: u32 = fn_state.u_32728;
        // D s_718_47: cast zx s_718_46 -> bv
        let s_718_47: Bits = Bits::new(s_718_46 as u128, 32u16);
        // C s_718_48: const #1u : u64
        let s_718_48: u64 = 1;
        // D s_718_49: bit-extract s_718_47 s_718_45 s_718_48
        let s_718_49: Bits = (Bits::new(
            ((s_718_47) >> (s_718_45)).value(),
            u16::try_from(s_718_48).unwrap(),
        ));
        // D s_718_50: cast reint s_718_49 -> u8
        let s_718_50: bool = ((s_718_49.value()) != 0);
        // C s_718_51: const #0s : i
        let s_718_51: i128 = 0;
        // C s_718_52: const #0u : u64
        let s_718_52: u64 = 0;
        // D s_718_53: cast zx s_718_50 -> u64
        let s_718_53: u64 = (s_718_50 as u64);
        // C s_718_54: const #1u : u64
        let s_718_54: u64 = 1;
        // D s_718_55: and s_718_53 s_718_54
        let s_718_55: u64 = ((s_718_53) & (s_718_54));
        // D s_718_56: cmp-eq s_718_55 s_718_54
        let s_718_56: bool = ((s_718_55) == (s_718_54));
        // D s_718_57: lsl s_718_53 s_718_51
        let s_718_57: u64 = s_718_53 << s_718_51;
        // D s_718_58: or s_718_52 s_718_57
        let s_718_58: u64 = ((s_718_52) | (s_718_57));
        // D s_718_59: cmpl s_718_57
        let s_718_59: u64 = !s_718_57;
        // D s_718_60: and s_718_52 s_718_59
        let s_718_60: u64 = ((s_718_52) & (s_718_59));
        // D s_718_61: select s_718_56 s_718_58 s_718_60
        let s_718_61: u64 = if s_718_56 { s_718_58 } else { s_718_60 };
        // D s_718_62: cast trunc s_718_61 -> u8
        let s_718_62: bool = ((s_718_61) != 0);
        // D s_718_63: cast zx s_718_62 -> bv
        let s_718_63: Bits = Bits::new(s_718_62 as u128, 1u16);
        // C s_718_64: const #0u : u8
        let s_718_64: bool = false;
        // C s_718_65: cast zx s_718_64 -> bv
        let s_718_65: Bits = Bits::new(s_718_64 as u128, 1u16);
        // D s_718_66: cmp-ne s_718_63 s_718_65
        let s_718_66: bool = ((s_718_63) != (s_718_65));
        // N s_718_67: branch s_718_66 b729 b719
        if s_718_66 {
            return block_729(state, tracer, fn_state);
        } else {
            return block_719(state, tracer, fn_state);
        };
    }
    fn block_719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_719_0: const #17s : i
        let s_719_0: i128 = 17;
        // D s_719_1: read-var u#32728:u32
        let s_719_1: u32 = fn_state.u_32728;
        // D s_719_2: cast zx s_719_1 -> bv
        let s_719_2: Bits = Bits::new(s_719_1 as u128, 32u16);
        // C s_719_3: const #1u : u64
        let s_719_3: u64 = 1;
        // D s_719_4: bit-extract s_719_2 s_719_0 s_719_3
        let s_719_4: Bits = (Bits::new(
            ((s_719_2) >> (s_719_0)).value(),
            u16::try_from(s_719_3).unwrap(),
        ));
        // D s_719_5: cast reint s_719_4 -> u8
        let s_719_5: bool = ((s_719_4.value()) != 0);
        // C s_719_6: const #0s : i
        let s_719_6: i128 = 0;
        // C s_719_7: const #0u : u64
        let s_719_7: u64 = 0;
        // D s_719_8: cast zx s_719_5 -> u64
        let s_719_8: u64 = (s_719_5 as u64);
        // C s_719_9: const #1u : u64
        let s_719_9: u64 = 1;
        // D s_719_10: and s_719_8 s_719_9
        let s_719_10: u64 = ((s_719_8) & (s_719_9));
        // D s_719_11: cmp-eq s_719_10 s_719_9
        let s_719_11: bool = ((s_719_10) == (s_719_9));
        // D s_719_12: lsl s_719_8 s_719_6
        let s_719_12: u64 = s_719_8 << s_719_6;
        // D s_719_13: or s_719_7 s_719_12
        let s_719_13: u64 = ((s_719_7) | (s_719_12));
        // D s_719_14: cmpl s_719_12
        let s_719_14: u64 = !s_719_12;
        // D s_719_15: and s_719_7 s_719_14
        let s_719_15: u64 = ((s_719_7) & (s_719_14));
        // D s_719_16: select s_719_11 s_719_13 s_719_15
        let s_719_16: u64 = if s_719_11 { s_719_13 } else { s_719_15 };
        // D s_719_17: cast trunc s_719_16 -> u8
        let s_719_17: bool = ((s_719_16) != 0);
        // D s_719_18: cast zx s_719_17 -> bv
        let s_719_18: Bits = Bits::new(s_719_17 as u128, 1u16);
        // C s_719_19: const #0u : u8
        let s_719_19: bool = false;
        // C s_719_20: cast zx s_719_19 -> bv
        let s_719_20: Bits = Bits::new(s_719_19 as u128, 1u16);
        // D s_719_21: cmp-ne s_719_18 s_719_20
        let s_719_21: bool = ((s_719_18) != (s_719_20));
        // D s_719_22: write-var gs#405748 <= s_719_21
        fn_state.gs_405748 = s_719_21;
        // N s_719_23: jump b720
        return block_720(state, tracer, fn_state);
    }
    fn block_720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_720_0: read-var gs#405748:u8
        let s_720_0: bool = fn_state.gs_405748;
        // N s_720_1: branch s_720_0 b728 b721
        if s_720_0 {
            return block_728(state, tracer, fn_state);
        } else {
            return block_721(state, tracer, fn_state);
        };
    }
    fn block_721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_721_0: const #18s : i
        let s_721_0: i128 = 18;
        // D s_721_1: read-var u#32728:u32
        let s_721_1: u32 = fn_state.u_32728;
        // D s_721_2: cast zx s_721_1 -> bv
        let s_721_2: Bits = Bits::new(s_721_1 as u128, 32u16);
        // C s_721_3: const #1u : u64
        let s_721_3: u64 = 1;
        // D s_721_4: bit-extract s_721_2 s_721_0 s_721_3
        let s_721_4: Bits = (Bits::new(
            ((s_721_2) >> (s_721_0)).value(),
            u16::try_from(s_721_3).unwrap(),
        ));
        // D s_721_5: cast reint s_721_4 -> u8
        let s_721_5: bool = ((s_721_4.value()) != 0);
        // C s_721_6: const #0s : i
        let s_721_6: i128 = 0;
        // C s_721_7: const #0u : u64
        let s_721_7: u64 = 0;
        // D s_721_8: cast zx s_721_5 -> u64
        let s_721_8: u64 = (s_721_5 as u64);
        // C s_721_9: const #1u : u64
        let s_721_9: u64 = 1;
        // D s_721_10: and s_721_8 s_721_9
        let s_721_10: u64 = ((s_721_8) & (s_721_9));
        // D s_721_11: cmp-eq s_721_10 s_721_9
        let s_721_11: bool = ((s_721_10) == (s_721_9));
        // D s_721_12: lsl s_721_8 s_721_6
        let s_721_12: u64 = s_721_8 << s_721_6;
        // D s_721_13: or s_721_7 s_721_12
        let s_721_13: u64 = ((s_721_7) | (s_721_12));
        // D s_721_14: cmpl s_721_12
        let s_721_14: u64 = !s_721_12;
        // D s_721_15: and s_721_7 s_721_14
        let s_721_15: u64 = ((s_721_7) & (s_721_14));
        // D s_721_16: select s_721_11 s_721_13 s_721_15
        let s_721_16: u64 = if s_721_11 { s_721_13 } else { s_721_15 };
        // D s_721_17: cast trunc s_721_16 -> u8
        let s_721_17: bool = ((s_721_16) != 0);
        // D s_721_18: cast zx s_721_17 -> bv
        let s_721_18: Bits = Bits::new(s_721_17 as u128, 1u16);
        // C s_721_19: const #0u : u8
        let s_721_19: bool = false;
        // C s_721_20: cast zx s_721_19 -> bv
        let s_721_20: Bits = Bits::new(s_721_19 as u128, 1u16);
        // D s_721_21: cmp-ne s_721_18 s_721_20
        let s_721_21: bool = ((s_721_18) != (s_721_20));
        // D s_721_22: write-var gs#405751 <= s_721_21
        fn_state.gs_405751 = s_721_21;
        // N s_721_23: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_722_0: read-var gs#405751:u8
        let s_722_0: bool = fn_state.gs_405751;
        // N s_722_1: branch s_722_0 b727 b723
        if s_722_0 {
            return block_727(state, tracer, fn_state);
        } else {
            return block_723(state, tracer, fn_state);
        };
    }
    fn block_723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_723_0: const #19s : i
        let s_723_0: i128 = 19;
        // D s_723_1: read-var u#32728:u32
        let s_723_1: u32 = fn_state.u_32728;
        // D s_723_2: cast zx s_723_1 -> bv
        let s_723_2: Bits = Bits::new(s_723_1 as u128, 32u16);
        // C s_723_3: const #1u : u64
        let s_723_3: u64 = 1;
        // D s_723_4: bit-extract s_723_2 s_723_0 s_723_3
        let s_723_4: Bits = (Bits::new(
            ((s_723_2) >> (s_723_0)).value(),
            u16::try_from(s_723_3).unwrap(),
        ));
        // D s_723_5: cast reint s_723_4 -> u8
        let s_723_5: bool = ((s_723_4.value()) != 0);
        // C s_723_6: const #0s : i
        let s_723_6: i128 = 0;
        // C s_723_7: const #0u : u64
        let s_723_7: u64 = 0;
        // D s_723_8: cast zx s_723_5 -> u64
        let s_723_8: u64 = (s_723_5 as u64);
        // C s_723_9: const #1u : u64
        let s_723_9: u64 = 1;
        // D s_723_10: and s_723_8 s_723_9
        let s_723_10: u64 = ((s_723_8) & (s_723_9));
        // D s_723_11: cmp-eq s_723_10 s_723_9
        let s_723_11: bool = ((s_723_10) == (s_723_9));
        // D s_723_12: lsl s_723_8 s_723_6
        let s_723_12: u64 = s_723_8 << s_723_6;
        // D s_723_13: or s_723_7 s_723_12
        let s_723_13: u64 = ((s_723_7) | (s_723_12));
        // D s_723_14: cmpl s_723_12
        let s_723_14: u64 = !s_723_12;
        // D s_723_15: and s_723_7 s_723_14
        let s_723_15: u64 = ((s_723_7) & (s_723_14));
        // D s_723_16: select s_723_11 s_723_13 s_723_15
        let s_723_16: u64 = if s_723_11 { s_723_13 } else { s_723_15 };
        // D s_723_17: cast trunc s_723_16 -> u8
        let s_723_17: bool = ((s_723_16) != 0);
        // D s_723_18: cast zx s_723_17 -> bv
        let s_723_18: Bits = Bits::new(s_723_17 as u128, 1u16);
        // C s_723_19: const #0u : u8
        let s_723_19: bool = false;
        // C s_723_20: cast zx s_723_19 -> bv
        let s_723_20: Bits = Bits::new(s_723_19 as u128, 1u16);
        // D s_723_21: cmp-ne s_723_18 s_723_20
        let s_723_21: bool = ((s_723_18) != (s_723_20));
        // D s_723_22: write-var gs#405754 <= s_723_21
        fn_state.gs_405754 = s_723_21;
        // N s_723_23: jump b724
        return block_724(state, tracer, fn_state);
    }
    fn block_724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_724_0: read-var gs#405754:u8
        let s_724_0: bool = fn_state.gs_405754;
        // N s_724_1: branch s_724_0 b726 b725
        if s_724_0 {
            return block_726(state, tracer, fn_state);
        } else {
            return block_725(state, tracer, fn_state);
        };
    }
    fn block_725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_725_0: read-var u#32729:u8
        let s_725_0: u8 = fn_state.u_32729;
        // D s_725_1: read-var u#32730:u8
        let s_725_1: bool = fn_state.u_32730;
        // D s_725_2: read-var u#32731:u8
        let s_725_2: u8 = fn_state.u_32731;
        // D s_725_3: read-var u#32732:u8
        let s_725_3: u8 = fn_state.u_32732;
        // D s_725_4: read-var u#32733:u8
        let s_725_4: u8 = fn_state.u_32733;
        // D s_725_5: read-var u#32734:u8
        let s_725_5: u8 = fn_state.u_32734;
        // D s_725_6: call decode_aarch32_instrs_MOV_rr_A1enc_A_txt(s_725_0, s_725_1, s_725_2, s_725_3, s_725_4, s_725_5)
        let s_725_6: () = decode_aarch32_instrs_MOV_rr_A1enc_A_txt(
            state,
            tracer,
            s_725_0,
            s_725_1,
            s_725_2,
            s_725_3,
            s_725_4,
            s_725_5,
        );
        // N s_725_7: return
        return;
    }
    fn block_726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_726_0: panic
        panic!("{:?}", ());
        // N s_726_1: return
        return;
    }
    fn block_727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_727_0: const #1u : u8
        let s_727_0: bool = true;
        // D s_727_1: write-var gs#405754 <= s_727_0
        fn_state.gs_405754 = s_727_0;
        // N s_727_2: jump b724
        return block_724(state, tracer, fn_state);
    }
    fn block_728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_728_0: const #1u : u8
        let s_728_0: bool = true;
        // D s_728_1: write-var gs#405751 <= s_728_0
        fn_state.gs_405751 = s_728_0;
        // N s_728_2: jump b722
        return block_722(state, tracer, fn_state);
    }
    fn block_729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_729_0: const #1u : u8
        let s_729_0: bool = true;
        // D s_729_1: write-var gs#405748 <= s_729_0
        fn_state.gs_405748 = s_729_0;
        // N s_729_2: jump b720
        return block_720(state, tracer, fn_state);
    }
    fn block_730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_730_0: read-var merge#var.1:struct
        let s_730_0: u32 = fn_state.merge_var._1;
        // D s_730_1: write-var u#32736 <= s_730_0
        fn_state.u_32736 = s_730_0;
        // C s_730_2: const #20s : i
        let s_730_2: i128 = 20;
        // D s_730_3: read-var u#32736:u32
        let s_730_3: u32 = fn_state.u_32736;
        // D s_730_4: cast zx s_730_3 -> bv
        let s_730_4: Bits = Bits::new(s_730_3 as u128, 32u16);
        // C s_730_5: const #1s : i64
        let s_730_5: i64 = 1;
        // C s_730_6: cast zx s_730_5 -> i
        let s_730_6: i128 = (i128::try_from(s_730_5).unwrap());
        // C s_730_7: const #7s : i
        let s_730_7: i128 = 7;
        // C s_730_8: add s_730_7 s_730_6
        let s_730_8: i128 = (s_730_7 + s_730_6);
        // D s_730_9: bit-extract s_730_4 s_730_2 s_730_8
        let s_730_9: Bits = (Bits::new(
            ((s_730_4) >> (s_730_2)).value(),
            u16::try_from(s_730_8).unwrap(),
        ));
        // D s_730_10: cast reint s_730_9 -> u8
        let s_730_10: u8 = (s_730_9.value() as u8);
        // D s_730_11: cast zx s_730_10 -> bv
        let s_730_11: Bits = Bits::new(s_730_10 as u128, 8u16);
        // C s_730_12: const #52u : u8
        let s_730_12: u8 = 52;
        // C s_730_13: cast zx s_730_12 -> bv
        let s_730_13: Bits = Bits::new(s_730_12 as u128, 8u16);
        // D s_730_14: cmp-eq s_730_11 s_730_13
        let s_730_14: bool = ((s_730_11) == (s_730_13));
        // N s_730_15: branch s_730_14 b2581 b731
        if s_730_14 {
            return block_2581(state, tracer, fn_state);
        } else {
            return block_731(state, tracer, fn_state);
        };
    }
    fn block_731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_731_0: const #0u : u8
        let s_731_0: bool = false;
        // D s_731_1: write-var gs#405762 <= s_731_0
        fn_state.gs_405762 = s_731_0;
        // N s_731_2: jump b732
        return block_732(state, tracer, fn_state);
    }
    fn block_732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_732_0: read-var gs#405762:u8
        let s_732_0: bool = fn_state.gs_405762;
        // D s_732_1: not s_732_0
        let s_732_1: bool = !s_732_0;
        // N s_732_2: branch s_732_1 b734 b733
        if s_732_1 {
            return block_734(state, tracer, fn_state);
        } else {
            return block_733(state, tracer, fn_state);
        };
    }
    fn block_733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_733_0: const #3021s : i
        let s_733_0: i128 = 3021;
        // C s_733_1: const #14696u : u32
        let s_733_1: u32 = 14696;
        // N s_733_2: write-reg s_733_1 <= s_733_0
        let s_733_2: () = {
            state.write_register::<i128>(s_733_1 as isize, s_733_0);
            tracer.write_register(s_733_1 as isize, s_733_0);
        };
        // C s_733_3: const #28s : i
        let s_733_3: i128 = 28;
        // C s_733_4: const #4s : i
        let s_733_4: i128 = 4;
        // D s_733_5: read-var u#32736:u32
        let s_733_5: u32 = fn_state.u_32736;
        // D s_733_6: cast zx s_733_5 -> bv
        let s_733_6: Bits = Bits::new(s_733_5 as u128, 32u16);
        // D s_733_7: bit-extract s_733_6 s_733_3 s_733_4
        let s_733_7: Bits = (Bits::new(
            ((s_733_6) >> (s_733_3)).value(),
            u16::try_from(s_733_4).unwrap(),
        ));
        // D s_733_8: cast reint s_733_7 -> u8
        let s_733_8: u8 = (s_733_7.value() as u8);
        // C s_733_9: const #16s : i
        let s_733_9: i128 = 16;
        // C s_733_10: const #4s : i
        let s_733_10: i128 = 4;
        // D s_733_11: read-var u#32736:u32
        let s_733_11: u32 = fn_state.u_32736;
        // D s_733_12: cast zx s_733_11 -> bv
        let s_733_12: Bits = Bits::new(s_733_11 as u128, 32u16);
        // D s_733_13: bit-extract s_733_12 s_733_9 s_733_10
        let s_733_13: Bits = (Bits::new(
            ((s_733_12) >> (s_733_9)).value(),
            u16::try_from(s_733_10).unwrap(),
        ));
        // D s_733_14: cast reint s_733_13 -> u8
        let s_733_14: u8 = (s_733_13.value() as u8);
        // C s_733_15: const #12s : i
        let s_733_15: i128 = 12;
        // C s_733_16: const #4s : i
        let s_733_16: i128 = 4;
        // D s_733_17: read-var u#32736:u32
        let s_733_17: u32 = fn_state.u_32736;
        // D s_733_18: cast zx s_733_17 -> bv
        let s_733_18: Bits = Bits::new(s_733_17 as u128, 32u16);
        // D s_733_19: bit-extract s_733_18 s_733_15 s_733_16
        let s_733_19: Bits = (Bits::new(
            ((s_733_18) >> (s_733_15)).value(),
            u16::try_from(s_733_16).unwrap(),
        ));
        // D s_733_20: cast reint s_733_19 -> u8
        let s_733_20: u8 = (s_733_19.value() as u8);
        // C s_733_21: const #0s : i
        let s_733_21: i128 = 0;
        // C s_733_22: const #12s : i
        let s_733_22: i128 = 12;
        // D s_733_23: read-var u#32736:u32
        let s_733_23: u32 = fn_state.u_32736;
        // D s_733_24: cast zx s_733_23 -> bv
        let s_733_24: Bits = Bits::new(s_733_23 as u128, 32u16);
        // D s_733_25: bit-extract s_733_24 s_733_21 s_733_22
        let s_733_25: Bits = (Bits::new(
            ((s_733_24) >> (s_733_21)).value(),
            u16::try_from(s_733_22).unwrap(),
        ));
        // D s_733_26: cast reint s_733_25 -> u12
        let s_733_26: u16 = (s_733_25.value() as u16);
        // D s_733_27: call decode_aarch32_instrs_MOVT_A1enc_A_txt(s_733_8, s_733_14, s_733_20, s_733_26)
        let s_733_27: () = decode_aarch32_instrs_MOVT_A1enc_A_txt(
            state,
            tracer,
            s_733_8,
            s_733_14,
            s_733_20,
            s_733_26,
        );
        // N s_733_28: return
        return;
    }
    fn block_734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_734_0: read-var merge#var.1:struct
        let s_734_0: u32 = fn_state.merge_var._1;
        // D s_734_1: write-var u#32742 <= s_734_0
        fn_state.u_32742 = s_734_0;
        // C s_734_2: const #21s : i
        let s_734_2: i128 = 21;
        // D s_734_3: read-var u#32742:u32
        let s_734_3: u32 = fn_state.u_32742;
        // D s_734_4: cast zx s_734_3 -> bv
        let s_734_4: Bits = Bits::new(s_734_3 as u128, 32u16);
        // C s_734_5: const #1s : i64
        let s_734_5: i64 = 1;
        // C s_734_6: cast zx s_734_5 -> i
        let s_734_6: i128 = (i128::try_from(s_734_5).unwrap());
        // C s_734_7: const #6s : i
        let s_734_7: i128 = 6;
        // C s_734_8: add s_734_7 s_734_6
        let s_734_8: i128 = (s_734_7 + s_734_6);
        // D s_734_9: bit-extract s_734_4 s_734_2 s_734_8
        let s_734_9: Bits = (Bits::new(
            ((s_734_4) >> (s_734_2)).value(),
            u16::try_from(s_734_8).unwrap(),
        ));
        // D s_734_10: cast reint s_734_9 -> u8
        let s_734_10: u8 = (s_734_9.value() as u8);
        // D s_734_11: cast zx s_734_10 -> bv
        let s_734_11: Bits = Bits::new(s_734_10 as u128, 7u16);
        // C s_734_12: const #0u : u8
        let s_734_12: u8 = 0;
        // C s_734_13: cast zx s_734_12 -> bv
        let s_734_13: Bits = Bits::new(s_734_12 as u128, 7u16);
        // D s_734_14: cmp-eq s_734_11 s_734_13
        let s_734_14: bool = ((s_734_11) == (s_734_13));
        // N s_734_15: branch s_734_14 b2577 b735
        if s_734_14 {
            return block_2577(state, tracer, fn_state);
        } else {
            return block_735(state, tracer, fn_state);
        };
    }
    fn block_735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_735_0: const #0u : u8
        let s_735_0: bool = false;
        // D s_735_1: write-var gs#405781 <= s_735_0
        fn_state.gs_405781 = s_735_0;
        // N s_735_2: jump b736
        return block_736(state, tracer, fn_state);
    }
    fn block_736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_736_0: read-var gs#405781:u8
        let s_736_0: bool = fn_state.gs_405781;
        // N s_736_1: branch s_736_0 b2573 b737
        if s_736_0 {
            return block_2573(state, tracer, fn_state);
        } else {
            return block_737(state, tracer, fn_state);
        };
    }
    fn block_737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_737_0: const #0u : u8
        let s_737_0: bool = false;
        // D s_737_1: write-var gs#405786 <= s_737_0
        fn_state.gs_405786 = s_737_0;
        // N s_737_2: jump b738
        return block_738(state, tracer, fn_state);
    }
    fn block_738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_738_0: read-var gs#405786:u8
        let s_738_0: bool = fn_state.gs_405786;
        // D s_738_1: not s_738_0
        let s_738_1: bool = !s_738_0;
        // N s_738_2: branch s_738_1 b751 b739
        if s_738_1 {
            return block_751(state, tracer, fn_state);
        } else {
            return block_739(state, tracer, fn_state);
        };
    }
    fn block_739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_739_0: const #3027s : i
        let s_739_0: i128 = 3027;
        // C s_739_1: const #14696u : u32
        let s_739_1: u32 = 14696;
        // N s_739_2: write-reg s_739_1 <= s_739_0
        let s_739_2: () = {
            state.write_register::<i128>(s_739_1 as isize, s_739_0);
            tracer.write_register(s_739_1 as isize, s_739_0);
        };
        // C s_739_3: const #28s : i
        let s_739_3: i128 = 28;
        // C s_739_4: const #4s : i
        let s_739_4: i128 = 4;
        // D s_739_5: read-var u#32742:u32
        let s_739_5: u32 = fn_state.u_32742;
        // D s_739_6: cast zx s_739_5 -> bv
        let s_739_6: Bits = Bits::new(s_739_5 as u128, 32u16);
        // D s_739_7: bit-extract s_739_6 s_739_3 s_739_4
        let s_739_7: Bits = (Bits::new(
            ((s_739_6) >> (s_739_3)).value(),
            u16::try_from(s_739_4).unwrap(),
        ));
        // D s_739_8: cast reint s_739_7 -> u8
        let s_739_8: u8 = (s_739_7.value() as u8);
        // D s_739_9: write-var u#32743 <= s_739_8
        fn_state.u_32743 = s_739_8;
        // C s_739_10: const #20s : i
        let s_739_10: i128 = 20;
        // C s_739_11: const #1s : i
        let s_739_11: i128 = 1;
        // D s_739_12: read-var u#32742:u32
        let s_739_12: u32 = fn_state.u_32742;
        // D s_739_13: cast zx s_739_12 -> bv
        let s_739_13: Bits = Bits::new(s_739_12 as u128, 32u16);
        // D s_739_14: bit-extract s_739_13 s_739_10 s_739_11
        let s_739_14: Bits = (Bits::new(
            ((s_739_13) >> (s_739_10)).value(),
            u16::try_from(s_739_11).unwrap(),
        ));
        // D s_739_15: cast reint s_739_14 -> u8
        let s_739_15: bool = ((s_739_14.value()) != 0);
        // D s_739_16: write-var u#32744 <= s_739_15
        fn_state.u_32744 = s_739_15;
        // C s_739_17: const #16s : i
        let s_739_17: i128 = 16;
        // C s_739_18: const #4s : i
        let s_739_18: i128 = 4;
        // D s_739_19: read-var u#32742:u32
        let s_739_19: u32 = fn_state.u_32742;
        // D s_739_20: cast zx s_739_19 -> bv
        let s_739_20: Bits = Bits::new(s_739_19 as u128, 32u16);
        // D s_739_21: bit-extract s_739_20 s_739_17 s_739_18
        let s_739_21: Bits = (Bits::new(
            ((s_739_20) >> (s_739_17)).value(),
            u16::try_from(s_739_18).unwrap(),
        ));
        // D s_739_22: cast reint s_739_21 -> u8
        let s_739_22: u8 = (s_739_21.value() as u8);
        // D s_739_23: write-var u#32745 <= s_739_22
        fn_state.u_32745 = s_739_22;
        // C s_739_24: const #8s : i
        let s_739_24: i128 = 8;
        // C s_739_25: const #4s : i
        let s_739_25: i128 = 4;
        // D s_739_26: read-var u#32742:u32
        let s_739_26: u32 = fn_state.u_32742;
        // D s_739_27: cast zx s_739_26 -> bv
        let s_739_27: Bits = Bits::new(s_739_26 as u128, 32u16);
        // D s_739_28: bit-extract s_739_27 s_739_24 s_739_25
        let s_739_28: Bits = (Bits::new(
            ((s_739_27) >> (s_739_24)).value(),
            u16::try_from(s_739_25).unwrap(),
        ));
        // D s_739_29: cast reint s_739_28 -> u8
        let s_739_29: u8 = (s_739_28.value() as u8);
        // D s_739_30: write-var u#32746 <= s_739_29
        fn_state.u_32746 = s_739_29;
        // C s_739_31: const #0s : i
        let s_739_31: i128 = 0;
        // C s_739_32: const #4s : i
        let s_739_32: i128 = 4;
        // D s_739_33: read-var u#32742:u32
        let s_739_33: u32 = fn_state.u_32742;
        // D s_739_34: cast zx s_739_33 -> bv
        let s_739_34: Bits = Bits::new(s_739_33 as u128, 32u16);
        // D s_739_35: bit-extract s_739_34 s_739_31 s_739_32
        let s_739_35: Bits = (Bits::new(
            ((s_739_34) >> (s_739_31)).value(),
            u16::try_from(s_739_32).unwrap(),
        ));
        // D s_739_36: cast reint s_739_35 -> u8
        let s_739_36: u8 = (s_739_35.value() as u8);
        // D s_739_37: write-var u#32747 <= s_739_36
        fn_state.u_32747 = s_739_36;
        // C s_739_38: const #12s : i
        let s_739_38: i128 = 12;
        // D s_739_39: read-var u#32742:u32
        let s_739_39: u32 = fn_state.u_32742;
        // D s_739_40: cast zx s_739_39 -> bv
        let s_739_40: Bits = Bits::new(s_739_39 as u128, 32u16);
        // C s_739_41: const #1u : u64
        let s_739_41: u64 = 1;
        // D s_739_42: bit-extract s_739_40 s_739_38 s_739_41
        let s_739_42: Bits = (Bits::new(
            ((s_739_40) >> (s_739_38)).value(),
            u16::try_from(s_739_41).unwrap(),
        ));
        // D s_739_43: cast reint s_739_42 -> u8
        let s_739_43: bool = ((s_739_42.value()) != 0);
        // C s_739_44: const #0s : i
        let s_739_44: i128 = 0;
        // C s_739_45: const #0u : u64
        let s_739_45: u64 = 0;
        // D s_739_46: cast zx s_739_43 -> u64
        let s_739_46: u64 = (s_739_43 as u64);
        // C s_739_47: const #1u : u64
        let s_739_47: u64 = 1;
        // D s_739_48: and s_739_46 s_739_47
        let s_739_48: u64 = ((s_739_46) & (s_739_47));
        // D s_739_49: cmp-eq s_739_48 s_739_47
        let s_739_49: bool = ((s_739_48) == (s_739_47));
        // D s_739_50: lsl s_739_46 s_739_44
        let s_739_50: u64 = s_739_46 << s_739_44;
        // D s_739_51: or s_739_45 s_739_50
        let s_739_51: u64 = ((s_739_45) | (s_739_50));
        // D s_739_52: cmpl s_739_50
        let s_739_52: u64 = !s_739_50;
        // D s_739_53: and s_739_45 s_739_52
        let s_739_53: u64 = ((s_739_45) & (s_739_52));
        // D s_739_54: select s_739_49 s_739_51 s_739_53
        let s_739_54: u64 = if s_739_49 { s_739_51 } else { s_739_53 };
        // D s_739_55: cast trunc s_739_54 -> u8
        let s_739_55: bool = ((s_739_54) != 0);
        // D s_739_56: cast zx s_739_55 -> bv
        let s_739_56: Bits = Bits::new(s_739_55 as u128, 1u16);
        // C s_739_57: const #0u : u8
        let s_739_57: bool = false;
        // C s_739_58: cast zx s_739_57 -> bv
        let s_739_58: Bits = Bits::new(s_739_57 as u128, 1u16);
        // D s_739_59: cmp-ne s_739_56 s_739_58
        let s_739_59: bool = ((s_739_56) != (s_739_58));
        // N s_739_60: branch s_739_59 b750 b740
        if s_739_59 {
            return block_750(state, tracer, fn_state);
        } else {
            return block_740(state, tracer, fn_state);
        };
    }
    fn block_740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_740_0: const #13s : i
        let s_740_0: i128 = 13;
        // D s_740_1: read-var u#32742:u32
        let s_740_1: u32 = fn_state.u_32742;
        // D s_740_2: cast zx s_740_1 -> bv
        let s_740_2: Bits = Bits::new(s_740_1 as u128, 32u16);
        // C s_740_3: const #1u : u64
        let s_740_3: u64 = 1;
        // D s_740_4: bit-extract s_740_2 s_740_0 s_740_3
        let s_740_4: Bits = (Bits::new(
            ((s_740_2) >> (s_740_0)).value(),
            u16::try_from(s_740_3).unwrap(),
        ));
        // D s_740_5: cast reint s_740_4 -> u8
        let s_740_5: bool = ((s_740_4.value()) != 0);
        // C s_740_6: const #0s : i
        let s_740_6: i128 = 0;
        // C s_740_7: const #0u : u64
        let s_740_7: u64 = 0;
        // D s_740_8: cast zx s_740_5 -> u64
        let s_740_8: u64 = (s_740_5 as u64);
        // C s_740_9: const #1u : u64
        let s_740_9: u64 = 1;
        // D s_740_10: and s_740_8 s_740_9
        let s_740_10: u64 = ((s_740_8) & (s_740_9));
        // D s_740_11: cmp-eq s_740_10 s_740_9
        let s_740_11: bool = ((s_740_10) == (s_740_9));
        // D s_740_12: lsl s_740_8 s_740_6
        let s_740_12: u64 = s_740_8 << s_740_6;
        // D s_740_13: or s_740_7 s_740_12
        let s_740_13: u64 = ((s_740_7) | (s_740_12));
        // D s_740_14: cmpl s_740_12
        let s_740_14: u64 = !s_740_12;
        // D s_740_15: and s_740_7 s_740_14
        let s_740_15: u64 = ((s_740_7) & (s_740_14));
        // D s_740_16: select s_740_11 s_740_13 s_740_15
        let s_740_16: u64 = if s_740_11 { s_740_13 } else { s_740_15 };
        // D s_740_17: cast trunc s_740_16 -> u8
        let s_740_17: bool = ((s_740_16) != 0);
        // D s_740_18: cast zx s_740_17 -> bv
        let s_740_18: Bits = Bits::new(s_740_17 as u128, 1u16);
        // C s_740_19: const #0u : u8
        let s_740_19: bool = false;
        // C s_740_20: cast zx s_740_19 -> bv
        let s_740_20: Bits = Bits::new(s_740_19 as u128, 1u16);
        // D s_740_21: cmp-ne s_740_18 s_740_20
        let s_740_21: bool = ((s_740_18) != (s_740_20));
        // D s_740_22: write-var gs#405803 <= s_740_21
        fn_state.gs_405803 = s_740_21;
        // N s_740_23: jump b741
        return block_741(state, tracer, fn_state);
    }
    fn block_741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_741_0: read-var gs#405803:u8
        let s_741_0: bool = fn_state.gs_405803;
        // N s_741_1: branch s_741_0 b749 b742
        if s_741_0 {
            return block_749(state, tracer, fn_state);
        } else {
            return block_742(state, tracer, fn_state);
        };
    }
    fn block_742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_742_0: const #14s : i
        let s_742_0: i128 = 14;
        // D s_742_1: read-var u#32742:u32
        let s_742_1: u32 = fn_state.u_32742;
        // D s_742_2: cast zx s_742_1 -> bv
        let s_742_2: Bits = Bits::new(s_742_1 as u128, 32u16);
        // C s_742_3: const #1u : u64
        let s_742_3: u64 = 1;
        // D s_742_4: bit-extract s_742_2 s_742_0 s_742_3
        let s_742_4: Bits = (Bits::new(
            ((s_742_2) >> (s_742_0)).value(),
            u16::try_from(s_742_3).unwrap(),
        ));
        // D s_742_5: cast reint s_742_4 -> u8
        let s_742_5: bool = ((s_742_4.value()) != 0);
        // C s_742_6: const #0s : i
        let s_742_6: i128 = 0;
        // C s_742_7: const #0u : u64
        let s_742_7: u64 = 0;
        // D s_742_8: cast zx s_742_5 -> u64
        let s_742_8: u64 = (s_742_5 as u64);
        // C s_742_9: const #1u : u64
        let s_742_9: u64 = 1;
        // D s_742_10: and s_742_8 s_742_9
        let s_742_10: u64 = ((s_742_8) & (s_742_9));
        // D s_742_11: cmp-eq s_742_10 s_742_9
        let s_742_11: bool = ((s_742_10) == (s_742_9));
        // D s_742_12: lsl s_742_8 s_742_6
        let s_742_12: u64 = s_742_8 << s_742_6;
        // D s_742_13: or s_742_7 s_742_12
        let s_742_13: u64 = ((s_742_7) | (s_742_12));
        // D s_742_14: cmpl s_742_12
        let s_742_14: u64 = !s_742_12;
        // D s_742_15: and s_742_7 s_742_14
        let s_742_15: u64 = ((s_742_7) & (s_742_14));
        // D s_742_16: select s_742_11 s_742_13 s_742_15
        let s_742_16: u64 = if s_742_11 { s_742_13 } else { s_742_15 };
        // D s_742_17: cast trunc s_742_16 -> u8
        let s_742_17: bool = ((s_742_16) != 0);
        // D s_742_18: cast zx s_742_17 -> bv
        let s_742_18: Bits = Bits::new(s_742_17 as u128, 1u16);
        // C s_742_19: const #0u : u8
        let s_742_19: bool = false;
        // C s_742_20: cast zx s_742_19 -> bv
        let s_742_20: Bits = Bits::new(s_742_19 as u128, 1u16);
        // D s_742_21: cmp-ne s_742_18 s_742_20
        let s_742_21: bool = ((s_742_18) != (s_742_20));
        // D s_742_22: write-var gs#405806 <= s_742_21
        fn_state.gs_405806 = s_742_21;
        // N s_742_23: jump b743
        return block_743(state, tracer, fn_state);
    }
    fn block_743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_743_0: read-var gs#405806:u8
        let s_743_0: bool = fn_state.gs_405806;
        // N s_743_1: branch s_743_0 b748 b744
        if s_743_0 {
            return block_748(state, tracer, fn_state);
        } else {
            return block_744(state, tracer, fn_state);
        };
    }
    fn block_744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_744_0: const #15s : i
        let s_744_0: i128 = 15;
        // D s_744_1: read-var u#32742:u32
        let s_744_1: u32 = fn_state.u_32742;
        // D s_744_2: cast zx s_744_1 -> bv
        let s_744_2: Bits = Bits::new(s_744_1 as u128, 32u16);
        // C s_744_3: const #1u : u64
        let s_744_3: u64 = 1;
        // D s_744_4: bit-extract s_744_2 s_744_0 s_744_3
        let s_744_4: Bits = (Bits::new(
            ((s_744_2) >> (s_744_0)).value(),
            u16::try_from(s_744_3).unwrap(),
        ));
        // D s_744_5: cast reint s_744_4 -> u8
        let s_744_5: bool = ((s_744_4.value()) != 0);
        // C s_744_6: const #0s : i
        let s_744_6: i128 = 0;
        // C s_744_7: const #0u : u64
        let s_744_7: u64 = 0;
        // D s_744_8: cast zx s_744_5 -> u64
        let s_744_8: u64 = (s_744_5 as u64);
        // C s_744_9: const #1u : u64
        let s_744_9: u64 = 1;
        // D s_744_10: and s_744_8 s_744_9
        let s_744_10: u64 = ((s_744_8) & (s_744_9));
        // D s_744_11: cmp-eq s_744_10 s_744_9
        let s_744_11: bool = ((s_744_10) == (s_744_9));
        // D s_744_12: lsl s_744_8 s_744_6
        let s_744_12: u64 = s_744_8 << s_744_6;
        // D s_744_13: or s_744_7 s_744_12
        let s_744_13: u64 = ((s_744_7) | (s_744_12));
        // D s_744_14: cmpl s_744_12
        let s_744_14: u64 = !s_744_12;
        // D s_744_15: and s_744_7 s_744_14
        let s_744_15: u64 = ((s_744_7) & (s_744_14));
        // D s_744_16: select s_744_11 s_744_13 s_744_15
        let s_744_16: u64 = if s_744_11 { s_744_13 } else { s_744_15 };
        // D s_744_17: cast trunc s_744_16 -> u8
        let s_744_17: bool = ((s_744_16) != 0);
        // D s_744_18: cast zx s_744_17 -> bv
        let s_744_18: Bits = Bits::new(s_744_17 as u128, 1u16);
        // C s_744_19: const #0u : u8
        let s_744_19: bool = false;
        // C s_744_20: cast zx s_744_19 -> bv
        let s_744_20: Bits = Bits::new(s_744_19 as u128, 1u16);
        // D s_744_21: cmp-ne s_744_18 s_744_20
        let s_744_21: bool = ((s_744_18) != (s_744_20));
        // D s_744_22: write-var gs#405809 <= s_744_21
        fn_state.gs_405809 = s_744_21;
        // N s_744_23: jump b745
        return block_745(state, tracer, fn_state);
    }
    fn block_745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_745_0: read-var gs#405809:u8
        let s_745_0: bool = fn_state.gs_405809;
        // N s_745_1: branch s_745_0 b747 b746
        if s_745_0 {
            return block_747(state, tracer, fn_state);
        } else {
            return block_746(state, tracer, fn_state);
        };
    }
    fn block_746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_746_0: read-var u#32743:u8
        let s_746_0: u8 = fn_state.u_32743;
        // D s_746_1: read-var u#32744:u8
        let s_746_1: bool = fn_state.u_32744;
        // D s_746_2: read-var u#32745:u8
        let s_746_2: u8 = fn_state.u_32745;
        // D s_746_3: read-var u#32746:u8
        let s_746_3: u8 = fn_state.u_32746;
        // D s_746_4: read-var u#32747:u8
        let s_746_4: u8 = fn_state.u_32747;
        // D s_746_5: call decode_aarch32_instrs_MUL_A1enc_A_txt(s_746_0, s_746_1, s_746_2, s_746_3, s_746_4)
        let s_746_5: () = decode_aarch32_instrs_MUL_A1enc_A_txt(
            state,
            tracer,
            s_746_0,
            s_746_1,
            s_746_2,
            s_746_3,
            s_746_4,
        );
        // N s_746_6: return
        return;
    }
    fn block_747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_747_0: panic
        panic!("{:?}", ());
        // N s_747_1: return
        return;
    }
    fn block_748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_748_0: const #1u : u8
        let s_748_0: bool = true;
        // D s_748_1: write-var gs#405809 <= s_748_0
        fn_state.gs_405809 = s_748_0;
        // N s_748_2: jump b745
        return block_745(state, tracer, fn_state);
    }
    fn block_749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_749_0: const #1u : u8
        let s_749_0: bool = true;
        // D s_749_1: write-var gs#405806 <= s_749_0
        fn_state.gs_405806 = s_749_0;
        // N s_749_2: jump b743
        return block_743(state, tracer, fn_state);
    }
    fn block_750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_750_0: const #1u : u8
        let s_750_0: bool = true;
        // D s_750_1: write-var gs#405803 <= s_750_0
        fn_state.gs_405803 = s_750_0;
        // N s_750_2: jump b741
        return block_741(state, tracer, fn_state);
    }
    fn block_751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_751_0: read-var merge#var.1:struct
        let s_751_0: u32 = fn_state.merge_var._1;
        // D s_751_1: write-var u#32749 <= s_751_0
        fn_state.u_32749 = s_751_0;
        // C s_751_2: const #21s : i
        let s_751_2: i128 = 21;
        // D s_751_3: read-var u#32749:u32
        let s_751_3: u32 = fn_state.u_32749;
        // D s_751_4: cast zx s_751_3 -> bv
        let s_751_4: Bits = Bits::new(s_751_3 as u128, 32u16);
        // C s_751_5: const #1s : i64
        let s_751_5: i64 = 1;
        // C s_751_6: cast zx s_751_5 -> i
        let s_751_6: i128 = (i128::try_from(s_751_5).unwrap());
        // C s_751_7: const #6s : i
        let s_751_7: i128 = 6;
        // C s_751_8: add s_751_7 s_751_6
        let s_751_8: i128 = (s_751_7 + s_751_6);
        // D s_751_9: bit-extract s_751_4 s_751_2 s_751_8
        let s_751_9: Bits = (Bits::new(
            ((s_751_4) >> (s_751_2)).value(),
            u16::try_from(s_751_8).unwrap(),
        ));
        // D s_751_10: cast reint s_751_9 -> u8
        let s_751_10: u8 = (s_751_9.value() as u8);
        // D s_751_11: cast zx s_751_10 -> bv
        let s_751_11: Bits = Bits::new(s_751_10 as u128, 7u16);
        // C s_751_12: const #31u : u8
        let s_751_12: u8 = 31;
        // C s_751_13: cast zx s_751_12 -> bv
        let s_751_13: Bits = Bits::new(s_751_12 as u128, 7u16);
        // D s_751_14: cmp-eq s_751_11 s_751_13
        let s_751_14: bool = ((s_751_11) == (s_751_13));
        // N s_751_15: branch s_751_14 b2572 b752
        if s_751_14 {
            return block_2572(state, tracer, fn_state);
        } else {
            return block_752(state, tracer, fn_state);
        };
    }
    fn block_752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_752_0: const #0u : u8
        let s_752_0: bool = false;
        // D s_752_1: write-var gs#405815 <= s_752_0
        fn_state.gs_405815 = s_752_0;
        // N s_752_2: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_753_0: read-var gs#405815:u8
        let s_753_0: bool = fn_state.gs_405815;
        // N s_753_1: branch s_753_0 b2568 b754
        if s_753_0 {
            return block_2568(state, tracer, fn_state);
        } else {
            return block_754(state, tracer, fn_state);
        };
    }
    fn block_754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_754_0: const #0u : u8
        let s_754_0: bool = false;
        // D s_754_1: write-var gs#405820 <= s_754_0
        fn_state.gs_405820 = s_754_0;
        // N s_754_2: jump b755
        return block_755(state, tracer, fn_state);
    }
    fn block_755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_755_0: read-var gs#405820:u8
        let s_755_0: bool = fn_state.gs_405820;
        // D s_755_1: not s_755_0
        let s_755_1: bool = !s_755_0;
        // N s_755_2: branch s_755_1 b768 b756
        if s_755_1 {
            return block_768(state, tracer, fn_state);
        } else {
            return block_756(state, tracer, fn_state);
        };
    }
    fn block_756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_756_0: const #3030s : i
        let s_756_0: i128 = 3030;
        // C s_756_1: const #14696u : u32
        let s_756_1: u32 = 14696;
        // N s_756_2: write-reg s_756_1 <= s_756_0
        let s_756_2: () = {
            state.write_register::<i128>(s_756_1 as isize, s_756_0);
            tracer.write_register(s_756_1 as isize, s_756_0);
        };
        // C s_756_3: const #28s : i
        let s_756_3: i128 = 28;
        // C s_756_4: const #4s : i
        let s_756_4: i128 = 4;
        // D s_756_5: read-var u#32749:u32
        let s_756_5: u32 = fn_state.u_32749;
        // D s_756_6: cast zx s_756_5 -> bv
        let s_756_6: Bits = Bits::new(s_756_5 as u128, 32u16);
        // D s_756_7: bit-extract s_756_6 s_756_3 s_756_4
        let s_756_7: Bits = (Bits::new(
            ((s_756_6) >> (s_756_3)).value(),
            u16::try_from(s_756_4).unwrap(),
        ));
        // D s_756_8: cast reint s_756_7 -> u8
        let s_756_8: u8 = (s_756_7.value() as u8);
        // D s_756_9: write-var u#32750 <= s_756_8
        fn_state.u_32750 = s_756_8;
        // C s_756_10: const #20s : i
        let s_756_10: i128 = 20;
        // C s_756_11: const #1s : i
        let s_756_11: i128 = 1;
        // D s_756_12: read-var u#32749:u32
        let s_756_12: u32 = fn_state.u_32749;
        // D s_756_13: cast zx s_756_12 -> bv
        let s_756_13: Bits = Bits::new(s_756_12 as u128, 32u16);
        // D s_756_14: bit-extract s_756_13 s_756_10 s_756_11
        let s_756_14: Bits = (Bits::new(
            ((s_756_13) >> (s_756_10)).value(),
            u16::try_from(s_756_11).unwrap(),
        ));
        // D s_756_15: cast reint s_756_14 -> u8
        let s_756_15: bool = ((s_756_14.value()) != 0);
        // D s_756_16: write-var u#32751 <= s_756_15
        fn_state.u_32751 = s_756_15;
        // C s_756_17: const #12s : i
        let s_756_17: i128 = 12;
        // C s_756_18: const #4s : i
        let s_756_18: i128 = 4;
        // D s_756_19: read-var u#32749:u32
        let s_756_19: u32 = fn_state.u_32749;
        // D s_756_20: cast zx s_756_19 -> bv
        let s_756_20: Bits = Bits::new(s_756_19 as u128, 32u16);
        // D s_756_21: bit-extract s_756_20 s_756_17 s_756_18
        let s_756_21: Bits = (Bits::new(
            ((s_756_20) >> (s_756_17)).value(),
            u16::try_from(s_756_18).unwrap(),
        ));
        // D s_756_22: cast reint s_756_21 -> u8
        let s_756_22: u8 = (s_756_21.value() as u8);
        // D s_756_23: write-var u#32752 <= s_756_22
        fn_state.u_32752 = s_756_22;
        // C s_756_24: const #0s : i
        let s_756_24: i128 = 0;
        // C s_756_25: const #12s : i
        let s_756_25: i128 = 12;
        // D s_756_26: read-var u#32749:u32
        let s_756_26: u32 = fn_state.u_32749;
        // D s_756_27: cast zx s_756_26 -> bv
        let s_756_27: Bits = Bits::new(s_756_26 as u128, 32u16);
        // D s_756_28: bit-extract s_756_27 s_756_24 s_756_25
        let s_756_28: Bits = (Bits::new(
            ((s_756_27) >> (s_756_24)).value(),
            u16::try_from(s_756_25).unwrap(),
        ));
        // D s_756_29: cast reint s_756_28 -> u12
        let s_756_29: u16 = (s_756_28.value() as u16);
        // D s_756_30: write-var u#32753 <= s_756_29
        fn_state.u_32753 = s_756_29;
        // C s_756_31: const #16s : i
        let s_756_31: i128 = 16;
        // D s_756_32: read-var u#32749:u32
        let s_756_32: u32 = fn_state.u_32749;
        // D s_756_33: cast zx s_756_32 -> bv
        let s_756_33: Bits = Bits::new(s_756_32 as u128, 32u16);
        // C s_756_34: const #1u : u64
        let s_756_34: u64 = 1;
        // D s_756_35: bit-extract s_756_33 s_756_31 s_756_34
        let s_756_35: Bits = (Bits::new(
            ((s_756_33) >> (s_756_31)).value(),
            u16::try_from(s_756_34).unwrap(),
        ));
        // D s_756_36: cast reint s_756_35 -> u8
        let s_756_36: bool = ((s_756_35.value()) != 0);
        // C s_756_37: const #0s : i
        let s_756_37: i128 = 0;
        // C s_756_38: const #0u : u64
        let s_756_38: u64 = 0;
        // D s_756_39: cast zx s_756_36 -> u64
        let s_756_39: u64 = (s_756_36 as u64);
        // C s_756_40: const #1u : u64
        let s_756_40: u64 = 1;
        // D s_756_41: and s_756_39 s_756_40
        let s_756_41: u64 = ((s_756_39) & (s_756_40));
        // D s_756_42: cmp-eq s_756_41 s_756_40
        let s_756_42: bool = ((s_756_41) == (s_756_40));
        // D s_756_43: lsl s_756_39 s_756_37
        let s_756_43: u64 = s_756_39 << s_756_37;
        // D s_756_44: or s_756_38 s_756_43
        let s_756_44: u64 = ((s_756_38) | (s_756_43));
        // D s_756_45: cmpl s_756_43
        let s_756_45: u64 = !s_756_43;
        // D s_756_46: and s_756_38 s_756_45
        let s_756_46: u64 = ((s_756_38) & (s_756_45));
        // D s_756_47: select s_756_42 s_756_44 s_756_46
        let s_756_47: u64 = if s_756_42 { s_756_44 } else { s_756_46 };
        // D s_756_48: cast trunc s_756_47 -> u8
        let s_756_48: bool = ((s_756_47) != 0);
        // D s_756_49: cast zx s_756_48 -> bv
        let s_756_49: Bits = Bits::new(s_756_48 as u128, 1u16);
        // C s_756_50: const #0u : u8
        let s_756_50: bool = false;
        // C s_756_51: cast zx s_756_50 -> bv
        let s_756_51: Bits = Bits::new(s_756_50 as u128, 1u16);
        // D s_756_52: cmp-ne s_756_49 s_756_51
        let s_756_52: bool = ((s_756_49) != (s_756_51));
        // N s_756_53: branch s_756_52 b767 b757
        if s_756_52 {
            return block_767(state, tracer, fn_state);
        } else {
            return block_757(state, tracer, fn_state);
        };
    }
    fn block_757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_757_0: const #17s : i
        let s_757_0: i128 = 17;
        // D s_757_1: read-var u#32749:u32
        let s_757_1: u32 = fn_state.u_32749;
        // D s_757_2: cast zx s_757_1 -> bv
        let s_757_2: Bits = Bits::new(s_757_1 as u128, 32u16);
        // C s_757_3: const #1u : u64
        let s_757_3: u64 = 1;
        // D s_757_4: bit-extract s_757_2 s_757_0 s_757_3
        let s_757_4: Bits = (Bits::new(
            ((s_757_2) >> (s_757_0)).value(),
            u16::try_from(s_757_3).unwrap(),
        ));
        // D s_757_5: cast reint s_757_4 -> u8
        let s_757_5: bool = ((s_757_4.value()) != 0);
        // C s_757_6: const #0s : i
        let s_757_6: i128 = 0;
        // C s_757_7: const #0u : u64
        let s_757_7: u64 = 0;
        // D s_757_8: cast zx s_757_5 -> u64
        let s_757_8: u64 = (s_757_5 as u64);
        // C s_757_9: const #1u : u64
        let s_757_9: u64 = 1;
        // D s_757_10: and s_757_8 s_757_9
        let s_757_10: u64 = ((s_757_8) & (s_757_9));
        // D s_757_11: cmp-eq s_757_10 s_757_9
        let s_757_11: bool = ((s_757_10) == (s_757_9));
        // D s_757_12: lsl s_757_8 s_757_6
        let s_757_12: u64 = s_757_8 << s_757_6;
        // D s_757_13: or s_757_7 s_757_12
        let s_757_13: u64 = ((s_757_7) | (s_757_12));
        // D s_757_14: cmpl s_757_12
        let s_757_14: u64 = !s_757_12;
        // D s_757_15: and s_757_7 s_757_14
        let s_757_15: u64 = ((s_757_7) & (s_757_14));
        // D s_757_16: select s_757_11 s_757_13 s_757_15
        let s_757_16: u64 = if s_757_11 { s_757_13 } else { s_757_15 };
        // D s_757_17: cast trunc s_757_16 -> u8
        let s_757_17: bool = ((s_757_16) != 0);
        // D s_757_18: cast zx s_757_17 -> bv
        let s_757_18: Bits = Bits::new(s_757_17 as u128, 1u16);
        // C s_757_19: const #0u : u8
        let s_757_19: bool = false;
        // C s_757_20: cast zx s_757_19 -> bv
        let s_757_20: Bits = Bits::new(s_757_19 as u128, 1u16);
        // D s_757_21: cmp-ne s_757_18 s_757_20
        let s_757_21: bool = ((s_757_18) != (s_757_20));
        // D s_757_22: write-var gs#405835 <= s_757_21
        fn_state.gs_405835 = s_757_21;
        // N s_757_23: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_758_0: read-var gs#405835:u8
        let s_758_0: bool = fn_state.gs_405835;
        // N s_758_1: branch s_758_0 b766 b759
        if s_758_0 {
            return block_766(state, tracer, fn_state);
        } else {
            return block_759(state, tracer, fn_state);
        };
    }
    fn block_759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_759_0: const #18s : i
        let s_759_0: i128 = 18;
        // D s_759_1: read-var u#32749:u32
        let s_759_1: u32 = fn_state.u_32749;
        // D s_759_2: cast zx s_759_1 -> bv
        let s_759_2: Bits = Bits::new(s_759_1 as u128, 32u16);
        // C s_759_3: const #1u : u64
        let s_759_3: u64 = 1;
        // D s_759_4: bit-extract s_759_2 s_759_0 s_759_3
        let s_759_4: Bits = (Bits::new(
            ((s_759_2) >> (s_759_0)).value(),
            u16::try_from(s_759_3).unwrap(),
        ));
        // D s_759_5: cast reint s_759_4 -> u8
        let s_759_5: bool = ((s_759_4.value()) != 0);
        // C s_759_6: const #0s : i
        let s_759_6: i128 = 0;
        // C s_759_7: const #0u : u64
        let s_759_7: u64 = 0;
        // D s_759_8: cast zx s_759_5 -> u64
        let s_759_8: u64 = (s_759_5 as u64);
        // C s_759_9: const #1u : u64
        let s_759_9: u64 = 1;
        // D s_759_10: and s_759_8 s_759_9
        let s_759_10: u64 = ((s_759_8) & (s_759_9));
        // D s_759_11: cmp-eq s_759_10 s_759_9
        let s_759_11: bool = ((s_759_10) == (s_759_9));
        // D s_759_12: lsl s_759_8 s_759_6
        let s_759_12: u64 = s_759_8 << s_759_6;
        // D s_759_13: or s_759_7 s_759_12
        let s_759_13: u64 = ((s_759_7) | (s_759_12));
        // D s_759_14: cmpl s_759_12
        let s_759_14: u64 = !s_759_12;
        // D s_759_15: and s_759_7 s_759_14
        let s_759_15: u64 = ((s_759_7) & (s_759_14));
        // D s_759_16: select s_759_11 s_759_13 s_759_15
        let s_759_16: u64 = if s_759_11 { s_759_13 } else { s_759_15 };
        // D s_759_17: cast trunc s_759_16 -> u8
        let s_759_17: bool = ((s_759_16) != 0);
        // D s_759_18: cast zx s_759_17 -> bv
        let s_759_18: Bits = Bits::new(s_759_17 as u128, 1u16);
        // C s_759_19: const #0u : u8
        let s_759_19: bool = false;
        // C s_759_20: cast zx s_759_19 -> bv
        let s_759_20: Bits = Bits::new(s_759_19 as u128, 1u16);
        // D s_759_21: cmp-ne s_759_18 s_759_20
        let s_759_21: bool = ((s_759_18) != (s_759_20));
        // D s_759_22: write-var gs#405838 <= s_759_21
        fn_state.gs_405838 = s_759_21;
        // N s_759_23: jump b760
        return block_760(state, tracer, fn_state);
    }
    fn block_760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_760_0: read-var gs#405838:u8
        let s_760_0: bool = fn_state.gs_405838;
        // N s_760_1: branch s_760_0 b765 b761
        if s_760_0 {
            return block_765(state, tracer, fn_state);
        } else {
            return block_761(state, tracer, fn_state);
        };
    }
    fn block_761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_761_0: const #19s : i
        let s_761_0: i128 = 19;
        // D s_761_1: read-var u#32749:u32
        let s_761_1: u32 = fn_state.u_32749;
        // D s_761_2: cast zx s_761_1 -> bv
        let s_761_2: Bits = Bits::new(s_761_1 as u128, 32u16);
        // C s_761_3: const #1u : u64
        let s_761_3: u64 = 1;
        // D s_761_4: bit-extract s_761_2 s_761_0 s_761_3
        let s_761_4: Bits = (Bits::new(
            ((s_761_2) >> (s_761_0)).value(),
            u16::try_from(s_761_3).unwrap(),
        ));
        // D s_761_5: cast reint s_761_4 -> u8
        let s_761_5: bool = ((s_761_4.value()) != 0);
        // C s_761_6: const #0s : i
        let s_761_6: i128 = 0;
        // C s_761_7: const #0u : u64
        let s_761_7: u64 = 0;
        // D s_761_8: cast zx s_761_5 -> u64
        let s_761_8: u64 = (s_761_5 as u64);
        // C s_761_9: const #1u : u64
        let s_761_9: u64 = 1;
        // D s_761_10: and s_761_8 s_761_9
        let s_761_10: u64 = ((s_761_8) & (s_761_9));
        // D s_761_11: cmp-eq s_761_10 s_761_9
        let s_761_11: bool = ((s_761_10) == (s_761_9));
        // D s_761_12: lsl s_761_8 s_761_6
        let s_761_12: u64 = s_761_8 << s_761_6;
        // D s_761_13: or s_761_7 s_761_12
        let s_761_13: u64 = ((s_761_7) | (s_761_12));
        // D s_761_14: cmpl s_761_12
        let s_761_14: u64 = !s_761_12;
        // D s_761_15: and s_761_7 s_761_14
        let s_761_15: u64 = ((s_761_7) & (s_761_14));
        // D s_761_16: select s_761_11 s_761_13 s_761_15
        let s_761_16: u64 = if s_761_11 { s_761_13 } else { s_761_15 };
        // D s_761_17: cast trunc s_761_16 -> u8
        let s_761_17: bool = ((s_761_16) != 0);
        // D s_761_18: cast zx s_761_17 -> bv
        let s_761_18: Bits = Bits::new(s_761_17 as u128, 1u16);
        // C s_761_19: const #0u : u8
        let s_761_19: bool = false;
        // C s_761_20: cast zx s_761_19 -> bv
        let s_761_20: Bits = Bits::new(s_761_19 as u128, 1u16);
        // D s_761_21: cmp-ne s_761_18 s_761_20
        let s_761_21: bool = ((s_761_18) != (s_761_20));
        // D s_761_22: write-var gs#405841 <= s_761_21
        fn_state.gs_405841 = s_761_21;
        // N s_761_23: jump b762
        return block_762(state, tracer, fn_state);
    }
    fn block_762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_762_0: read-var gs#405841:u8
        let s_762_0: bool = fn_state.gs_405841;
        // N s_762_1: branch s_762_0 b764 b763
        if s_762_0 {
            return block_764(state, tracer, fn_state);
        } else {
            return block_763(state, tracer, fn_state);
        };
    }
    fn block_763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_763_0: read-var u#32750:u8
        let s_763_0: u8 = fn_state.u_32750;
        // D s_763_1: read-var u#32751:u8
        let s_763_1: bool = fn_state.u_32751;
        // D s_763_2: read-var u#32752:u8
        let s_763_2: u8 = fn_state.u_32752;
        // D s_763_3: read-var u#32753:u12
        let s_763_3: u16 = fn_state.u_32753;
        // D s_763_4: call decode_aarch32_instrs_MVN_i_A1enc_A_txt(s_763_0, s_763_1, s_763_2, s_763_3)
        let s_763_4: () = decode_aarch32_instrs_MVN_i_A1enc_A_txt(
            state,
            tracer,
            s_763_0,
            s_763_1,
            s_763_2,
            s_763_3,
        );
        // N s_763_5: return
        return;
    }
    fn block_764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_764_0: panic
        panic!("{:?}", ());
        // N s_764_1: return
        return;
    }
    fn block_765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_765_0: const #1u : u8
        let s_765_0: bool = true;
        // D s_765_1: write-var gs#405841 <= s_765_0
        fn_state.gs_405841 = s_765_0;
        // N s_765_2: jump b762
        return block_762(state, tracer, fn_state);
    }
    fn block_766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_766_0: const #1u : u8
        let s_766_0: bool = true;
        // D s_766_1: write-var gs#405838 <= s_766_0
        fn_state.gs_405838 = s_766_0;
        // N s_766_2: jump b760
        return block_760(state, tracer, fn_state);
    }
    fn block_767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_767_0: const #1u : u8
        let s_767_0: bool = true;
        // D s_767_1: write-var gs#405835 <= s_767_0
        fn_state.gs_405835 = s_767_0;
        // N s_767_2: jump b758
        return block_758(state, tracer, fn_state);
    }
    fn block_768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_768_0: read-var merge#var.1:struct
        let s_768_0: u32 = fn_state.merge_var._1;
        // D s_768_1: write-var u#32755 <= s_768_0
        fn_state.u_32755 = s_768_0;
        // C s_768_2: const #21s : i
        let s_768_2: i128 = 21;
        // D s_768_3: read-var u#32755:u32
        let s_768_3: u32 = fn_state.u_32755;
        // D s_768_4: cast zx s_768_3 -> bv
        let s_768_4: Bits = Bits::new(s_768_3 as u128, 32u16);
        // C s_768_5: const #1s : i64
        let s_768_5: i64 = 1;
        // C s_768_6: cast zx s_768_5 -> i
        let s_768_6: i128 = (i128::try_from(s_768_5).unwrap());
        // C s_768_7: const #6s : i
        let s_768_7: i128 = 6;
        // C s_768_8: add s_768_7 s_768_6
        let s_768_8: i128 = (s_768_7 + s_768_6);
        // D s_768_9: bit-extract s_768_4 s_768_2 s_768_8
        let s_768_9: Bits = (Bits::new(
            ((s_768_4) >> (s_768_2)).value(),
            u16::try_from(s_768_8).unwrap(),
        ));
        // D s_768_10: cast reint s_768_9 -> u8
        let s_768_10: u8 = (s_768_9.value() as u8);
        // D s_768_11: cast zx s_768_10 -> bv
        let s_768_11: Bits = Bits::new(s_768_10 as u128, 7u16);
        // C s_768_12: const #15u : u8
        let s_768_12: u8 = 15;
        // C s_768_13: cast zx s_768_12 -> bv
        let s_768_13: Bits = Bits::new(s_768_12 as u128, 7u16);
        // D s_768_14: cmp-eq s_768_11 s_768_13
        let s_768_14: bool = ((s_768_11) == (s_768_13));
        // N s_768_15: branch s_768_14 b2564 b769
        if s_768_14 {
            return block_2564(state, tracer, fn_state);
        } else {
            return block_769(state, tracer, fn_state);
        };
    }
    fn block_769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_769_0: const #0u : u8
        let s_769_0: bool = false;
        // D s_769_1: write-var gs#405850 <= s_769_0
        fn_state.gs_405850 = s_769_0;
        // N s_769_2: jump b770
        return block_770(state, tracer, fn_state);
    }
    fn block_770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_770_0: read-var gs#405850:u8
        let s_770_0: bool = fn_state.gs_405850;
        // N s_770_1: branch s_770_0 b2560 b771
        if s_770_0 {
            return block_2560(state, tracer, fn_state);
        } else {
            return block_771(state, tracer, fn_state);
        };
    }
    fn block_771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_771_0: const #0u : u8
        let s_771_0: bool = false;
        // D s_771_1: write-var gs#405855 <= s_771_0
        fn_state.gs_405855 = s_771_0;
        // N s_771_2: jump b772
        return block_772(state, tracer, fn_state);
    }
    fn block_772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_772_0: read-var gs#405855:u8
        let s_772_0: bool = fn_state.gs_405855;
        // D s_772_1: not s_772_0
        let s_772_1: bool = !s_772_0;
        // N s_772_2: branch s_772_1 b785 b773
        if s_772_1 {
            return block_785(state, tracer, fn_state);
        } else {
            return block_773(state, tracer, fn_state);
        };
    }
    fn block_773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_773_0: const #3032s : i
        let s_773_0: i128 = 3032;
        // C s_773_1: const #14696u : u32
        let s_773_1: u32 = 14696;
        // N s_773_2: write-reg s_773_1 <= s_773_0
        let s_773_2: () = {
            state.write_register::<i128>(s_773_1 as isize, s_773_0);
            tracer.write_register(s_773_1 as isize, s_773_0);
        };
        // C s_773_3: const #28s : i
        let s_773_3: i128 = 28;
        // C s_773_4: const #4s : i
        let s_773_4: i128 = 4;
        // D s_773_5: read-var u#32755:u32
        let s_773_5: u32 = fn_state.u_32755;
        // D s_773_6: cast zx s_773_5 -> bv
        let s_773_6: Bits = Bits::new(s_773_5 as u128, 32u16);
        // D s_773_7: bit-extract s_773_6 s_773_3 s_773_4
        let s_773_7: Bits = (Bits::new(
            ((s_773_6) >> (s_773_3)).value(),
            u16::try_from(s_773_4).unwrap(),
        ));
        // D s_773_8: cast reint s_773_7 -> u8
        let s_773_8: u8 = (s_773_7.value() as u8);
        // D s_773_9: write-var u#32756 <= s_773_8
        fn_state.u_32756 = s_773_8;
        // C s_773_10: const #20s : i
        let s_773_10: i128 = 20;
        // C s_773_11: const #1s : i
        let s_773_11: i128 = 1;
        // D s_773_12: read-var u#32755:u32
        let s_773_12: u32 = fn_state.u_32755;
        // D s_773_13: cast zx s_773_12 -> bv
        let s_773_13: Bits = Bits::new(s_773_12 as u128, 32u16);
        // D s_773_14: bit-extract s_773_13 s_773_10 s_773_11
        let s_773_14: Bits = (Bits::new(
            ((s_773_13) >> (s_773_10)).value(),
            u16::try_from(s_773_11).unwrap(),
        ));
        // D s_773_15: cast reint s_773_14 -> u8
        let s_773_15: bool = ((s_773_14.value()) != 0);
        // D s_773_16: write-var u#32757 <= s_773_15
        fn_state.u_32757 = s_773_15;
        // C s_773_17: const #12s : i
        let s_773_17: i128 = 12;
        // C s_773_18: const #4s : i
        let s_773_18: i128 = 4;
        // D s_773_19: read-var u#32755:u32
        let s_773_19: u32 = fn_state.u_32755;
        // D s_773_20: cast zx s_773_19 -> bv
        let s_773_20: Bits = Bits::new(s_773_19 as u128, 32u16);
        // D s_773_21: bit-extract s_773_20 s_773_17 s_773_18
        let s_773_21: Bits = (Bits::new(
            ((s_773_20) >> (s_773_17)).value(),
            u16::try_from(s_773_18).unwrap(),
        ));
        // D s_773_22: cast reint s_773_21 -> u8
        let s_773_22: u8 = (s_773_21.value() as u8);
        // D s_773_23: write-var u#32758 <= s_773_22
        fn_state.u_32758 = s_773_22;
        // C s_773_24: const #7s : i
        let s_773_24: i128 = 7;
        // C s_773_25: const #5s : i
        let s_773_25: i128 = 5;
        // D s_773_26: read-var u#32755:u32
        let s_773_26: u32 = fn_state.u_32755;
        // D s_773_27: cast zx s_773_26 -> bv
        let s_773_27: Bits = Bits::new(s_773_26 as u128, 32u16);
        // D s_773_28: bit-extract s_773_27 s_773_24 s_773_25
        let s_773_28: Bits = (Bits::new(
            ((s_773_27) >> (s_773_24)).value(),
            u16::try_from(s_773_25).unwrap(),
        ));
        // D s_773_29: cast reint s_773_28 -> u8
        let s_773_29: u8 = (s_773_28.value() as u8);
        // D s_773_30: write-var u#32759 <= s_773_29
        fn_state.u_32759 = s_773_29;
        // C s_773_31: const #5s : i
        let s_773_31: i128 = 5;
        // C s_773_32: const #2s : i
        let s_773_32: i128 = 2;
        // D s_773_33: read-var u#32755:u32
        let s_773_33: u32 = fn_state.u_32755;
        // D s_773_34: cast zx s_773_33 -> bv
        let s_773_34: Bits = Bits::new(s_773_33 as u128, 32u16);
        // D s_773_35: bit-extract s_773_34 s_773_31 s_773_32
        let s_773_35: Bits = (Bits::new(
            ((s_773_34) >> (s_773_31)).value(),
            u16::try_from(s_773_32).unwrap(),
        ));
        // D s_773_36: cast reint s_773_35 -> u8
        let s_773_36: u8 = (s_773_35.value() as u8);
        // D s_773_37: write-var u#32760 <= s_773_36
        fn_state.u_32760 = s_773_36;
        // C s_773_38: const #0s : i
        let s_773_38: i128 = 0;
        // C s_773_39: const #4s : i
        let s_773_39: i128 = 4;
        // D s_773_40: read-var u#32755:u32
        let s_773_40: u32 = fn_state.u_32755;
        // D s_773_41: cast zx s_773_40 -> bv
        let s_773_41: Bits = Bits::new(s_773_40 as u128, 32u16);
        // D s_773_42: bit-extract s_773_41 s_773_38 s_773_39
        let s_773_42: Bits = (Bits::new(
            ((s_773_41) >> (s_773_38)).value(),
            u16::try_from(s_773_39).unwrap(),
        ));
        // D s_773_43: cast reint s_773_42 -> u8
        let s_773_43: u8 = (s_773_42.value() as u8);
        // D s_773_44: write-var u#32761 <= s_773_43
        fn_state.u_32761 = s_773_43;
        // C s_773_45: const #16s : i
        let s_773_45: i128 = 16;
        // D s_773_46: read-var u#32755:u32
        let s_773_46: u32 = fn_state.u_32755;
        // D s_773_47: cast zx s_773_46 -> bv
        let s_773_47: Bits = Bits::new(s_773_46 as u128, 32u16);
        // C s_773_48: const #1u : u64
        let s_773_48: u64 = 1;
        // D s_773_49: bit-extract s_773_47 s_773_45 s_773_48
        let s_773_49: Bits = (Bits::new(
            ((s_773_47) >> (s_773_45)).value(),
            u16::try_from(s_773_48).unwrap(),
        ));
        // D s_773_50: cast reint s_773_49 -> u8
        let s_773_50: bool = ((s_773_49.value()) != 0);
        // C s_773_51: const #0s : i
        let s_773_51: i128 = 0;
        // C s_773_52: const #0u : u64
        let s_773_52: u64 = 0;
        // D s_773_53: cast zx s_773_50 -> u64
        let s_773_53: u64 = (s_773_50 as u64);
        // C s_773_54: const #1u : u64
        let s_773_54: u64 = 1;
        // D s_773_55: and s_773_53 s_773_54
        let s_773_55: u64 = ((s_773_53) & (s_773_54));
        // D s_773_56: cmp-eq s_773_55 s_773_54
        let s_773_56: bool = ((s_773_55) == (s_773_54));
        // D s_773_57: lsl s_773_53 s_773_51
        let s_773_57: u64 = s_773_53 << s_773_51;
        // D s_773_58: or s_773_52 s_773_57
        let s_773_58: u64 = ((s_773_52) | (s_773_57));
        // D s_773_59: cmpl s_773_57
        let s_773_59: u64 = !s_773_57;
        // D s_773_60: and s_773_52 s_773_59
        let s_773_60: u64 = ((s_773_52) & (s_773_59));
        // D s_773_61: select s_773_56 s_773_58 s_773_60
        let s_773_61: u64 = if s_773_56 { s_773_58 } else { s_773_60 };
        // D s_773_62: cast trunc s_773_61 -> u8
        let s_773_62: bool = ((s_773_61) != 0);
        // D s_773_63: cast zx s_773_62 -> bv
        let s_773_63: Bits = Bits::new(s_773_62 as u128, 1u16);
        // C s_773_64: const #0u : u8
        let s_773_64: bool = false;
        // C s_773_65: cast zx s_773_64 -> bv
        let s_773_65: Bits = Bits::new(s_773_64 as u128, 1u16);
        // D s_773_66: cmp-ne s_773_63 s_773_65
        let s_773_66: bool = ((s_773_63) != (s_773_65));
        // N s_773_67: branch s_773_66 b784 b774
        if s_773_66 {
            return block_784(state, tracer, fn_state);
        } else {
            return block_774(state, tracer, fn_state);
        };
    }
    fn block_774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_774_0: const #17s : i
        let s_774_0: i128 = 17;
        // D s_774_1: read-var u#32755:u32
        let s_774_1: u32 = fn_state.u_32755;
        // D s_774_2: cast zx s_774_1 -> bv
        let s_774_2: Bits = Bits::new(s_774_1 as u128, 32u16);
        // C s_774_3: const #1u : u64
        let s_774_3: u64 = 1;
        // D s_774_4: bit-extract s_774_2 s_774_0 s_774_3
        let s_774_4: Bits = (Bits::new(
            ((s_774_2) >> (s_774_0)).value(),
            u16::try_from(s_774_3).unwrap(),
        ));
        // D s_774_5: cast reint s_774_4 -> u8
        let s_774_5: bool = ((s_774_4.value()) != 0);
        // C s_774_6: const #0s : i
        let s_774_6: i128 = 0;
        // C s_774_7: const #0u : u64
        let s_774_7: u64 = 0;
        // D s_774_8: cast zx s_774_5 -> u64
        let s_774_8: u64 = (s_774_5 as u64);
        // C s_774_9: const #1u : u64
        let s_774_9: u64 = 1;
        // D s_774_10: and s_774_8 s_774_9
        let s_774_10: u64 = ((s_774_8) & (s_774_9));
        // D s_774_11: cmp-eq s_774_10 s_774_9
        let s_774_11: bool = ((s_774_10) == (s_774_9));
        // D s_774_12: lsl s_774_8 s_774_6
        let s_774_12: u64 = s_774_8 << s_774_6;
        // D s_774_13: or s_774_7 s_774_12
        let s_774_13: u64 = ((s_774_7) | (s_774_12));
        // D s_774_14: cmpl s_774_12
        let s_774_14: u64 = !s_774_12;
        // D s_774_15: and s_774_7 s_774_14
        let s_774_15: u64 = ((s_774_7) & (s_774_14));
        // D s_774_16: select s_774_11 s_774_13 s_774_15
        let s_774_16: u64 = if s_774_11 { s_774_13 } else { s_774_15 };
        // D s_774_17: cast trunc s_774_16 -> u8
        let s_774_17: bool = ((s_774_16) != 0);
        // D s_774_18: cast zx s_774_17 -> bv
        let s_774_18: Bits = Bits::new(s_774_17 as u128, 1u16);
        // C s_774_19: const #0u : u8
        let s_774_19: bool = false;
        // C s_774_20: cast zx s_774_19 -> bv
        let s_774_20: Bits = Bits::new(s_774_19 as u128, 1u16);
        // D s_774_21: cmp-ne s_774_18 s_774_20
        let s_774_21: bool = ((s_774_18) != (s_774_20));
        // D s_774_22: write-var gs#405874 <= s_774_21
        fn_state.gs_405874 = s_774_21;
        // N s_774_23: jump b775
        return block_775(state, tracer, fn_state);
    }
    fn block_775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_775_0: read-var gs#405874:u8
        let s_775_0: bool = fn_state.gs_405874;
        // N s_775_1: branch s_775_0 b783 b776
        if s_775_0 {
            return block_783(state, tracer, fn_state);
        } else {
            return block_776(state, tracer, fn_state);
        };
    }
    fn block_776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_776_0: const #18s : i
        let s_776_0: i128 = 18;
        // D s_776_1: read-var u#32755:u32
        let s_776_1: u32 = fn_state.u_32755;
        // D s_776_2: cast zx s_776_1 -> bv
        let s_776_2: Bits = Bits::new(s_776_1 as u128, 32u16);
        // C s_776_3: const #1u : u64
        let s_776_3: u64 = 1;
        // D s_776_4: bit-extract s_776_2 s_776_0 s_776_3
        let s_776_4: Bits = (Bits::new(
            ((s_776_2) >> (s_776_0)).value(),
            u16::try_from(s_776_3).unwrap(),
        ));
        // D s_776_5: cast reint s_776_4 -> u8
        let s_776_5: bool = ((s_776_4.value()) != 0);
        // C s_776_6: const #0s : i
        let s_776_6: i128 = 0;
        // C s_776_7: const #0u : u64
        let s_776_7: u64 = 0;
        // D s_776_8: cast zx s_776_5 -> u64
        let s_776_8: u64 = (s_776_5 as u64);
        // C s_776_9: const #1u : u64
        let s_776_9: u64 = 1;
        // D s_776_10: and s_776_8 s_776_9
        let s_776_10: u64 = ((s_776_8) & (s_776_9));
        // D s_776_11: cmp-eq s_776_10 s_776_9
        let s_776_11: bool = ((s_776_10) == (s_776_9));
        // D s_776_12: lsl s_776_8 s_776_6
        let s_776_12: u64 = s_776_8 << s_776_6;
        // D s_776_13: or s_776_7 s_776_12
        let s_776_13: u64 = ((s_776_7) | (s_776_12));
        // D s_776_14: cmpl s_776_12
        let s_776_14: u64 = !s_776_12;
        // D s_776_15: and s_776_7 s_776_14
        let s_776_15: u64 = ((s_776_7) & (s_776_14));
        // D s_776_16: select s_776_11 s_776_13 s_776_15
        let s_776_16: u64 = if s_776_11 { s_776_13 } else { s_776_15 };
        // D s_776_17: cast trunc s_776_16 -> u8
        let s_776_17: bool = ((s_776_16) != 0);
        // D s_776_18: cast zx s_776_17 -> bv
        let s_776_18: Bits = Bits::new(s_776_17 as u128, 1u16);
        // C s_776_19: const #0u : u8
        let s_776_19: bool = false;
        // C s_776_20: cast zx s_776_19 -> bv
        let s_776_20: Bits = Bits::new(s_776_19 as u128, 1u16);
        // D s_776_21: cmp-ne s_776_18 s_776_20
        let s_776_21: bool = ((s_776_18) != (s_776_20));
        // D s_776_22: write-var gs#405877 <= s_776_21
        fn_state.gs_405877 = s_776_21;
        // N s_776_23: jump b777
        return block_777(state, tracer, fn_state);
    }
    fn block_777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_777_0: read-var gs#405877:u8
        let s_777_0: bool = fn_state.gs_405877;
        // N s_777_1: branch s_777_0 b782 b778
        if s_777_0 {
            return block_782(state, tracer, fn_state);
        } else {
            return block_778(state, tracer, fn_state);
        };
    }
    fn block_778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_778_0: const #19s : i
        let s_778_0: i128 = 19;
        // D s_778_1: read-var u#32755:u32
        let s_778_1: u32 = fn_state.u_32755;
        // D s_778_2: cast zx s_778_1 -> bv
        let s_778_2: Bits = Bits::new(s_778_1 as u128, 32u16);
        // C s_778_3: const #1u : u64
        let s_778_3: u64 = 1;
        // D s_778_4: bit-extract s_778_2 s_778_0 s_778_3
        let s_778_4: Bits = (Bits::new(
            ((s_778_2) >> (s_778_0)).value(),
            u16::try_from(s_778_3).unwrap(),
        ));
        // D s_778_5: cast reint s_778_4 -> u8
        let s_778_5: bool = ((s_778_4.value()) != 0);
        // C s_778_6: const #0s : i
        let s_778_6: i128 = 0;
        // C s_778_7: const #0u : u64
        let s_778_7: u64 = 0;
        // D s_778_8: cast zx s_778_5 -> u64
        let s_778_8: u64 = (s_778_5 as u64);
        // C s_778_9: const #1u : u64
        let s_778_9: u64 = 1;
        // D s_778_10: and s_778_8 s_778_9
        let s_778_10: u64 = ((s_778_8) & (s_778_9));
        // D s_778_11: cmp-eq s_778_10 s_778_9
        let s_778_11: bool = ((s_778_10) == (s_778_9));
        // D s_778_12: lsl s_778_8 s_778_6
        let s_778_12: u64 = s_778_8 << s_778_6;
        // D s_778_13: or s_778_7 s_778_12
        let s_778_13: u64 = ((s_778_7) | (s_778_12));
        // D s_778_14: cmpl s_778_12
        let s_778_14: u64 = !s_778_12;
        // D s_778_15: and s_778_7 s_778_14
        let s_778_15: u64 = ((s_778_7) & (s_778_14));
        // D s_778_16: select s_778_11 s_778_13 s_778_15
        let s_778_16: u64 = if s_778_11 { s_778_13 } else { s_778_15 };
        // D s_778_17: cast trunc s_778_16 -> u8
        let s_778_17: bool = ((s_778_16) != 0);
        // D s_778_18: cast zx s_778_17 -> bv
        let s_778_18: Bits = Bits::new(s_778_17 as u128, 1u16);
        // C s_778_19: const #0u : u8
        let s_778_19: bool = false;
        // C s_778_20: cast zx s_778_19 -> bv
        let s_778_20: Bits = Bits::new(s_778_19 as u128, 1u16);
        // D s_778_21: cmp-ne s_778_18 s_778_20
        let s_778_21: bool = ((s_778_18) != (s_778_20));
        // D s_778_22: write-var gs#405880 <= s_778_21
        fn_state.gs_405880 = s_778_21;
        // N s_778_23: jump b779
        return block_779(state, tracer, fn_state);
    }
    fn block_779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_779_0: read-var gs#405880:u8
        let s_779_0: bool = fn_state.gs_405880;
        // N s_779_1: branch s_779_0 b781 b780
        if s_779_0 {
            return block_781(state, tracer, fn_state);
        } else {
            return block_780(state, tracer, fn_state);
        };
    }
    fn block_780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_780_0: read-var u#32756:u8
        let s_780_0: u8 = fn_state.u_32756;
        // D s_780_1: read-var u#32757:u8
        let s_780_1: bool = fn_state.u_32757;
        // D s_780_2: read-var u#32758:u8
        let s_780_2: u8 = fn_state.u_32758;
        // D s_780_3: read-var u#32759:u8
        let s_780_3: u8 = fn_state.u_32759;
        // D s_780_4: read-var u#32760:u8
        let s_780_4: u8 = fn_state.u_32760;
        // D s_780_5: read-var u#32761:u8
        let s_780_5: u8 = fn_state.u_32761;
        // D s_780_6: call decode_aarch32_instrs_MVN_r_A1enc_A_txt(s_780_0, s_780_1, s_780_2, s_780_3, s_780_4, s_780_5)
        let s_780_6: () = decode_aarch32_instrs_MVN_r_A1enc_A_txt(
            state,
            tracer,
            s_780_0,
            s_780_1,
            s_780_2,
            s_780_3,
            s_780_4,
            s_780_5,
        );
        // N s_780_7: return
        return;
    }
    fn block_781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_781_0: panic
        panic!("{:?}", ());
        // N s_781_1: return
        return;
    }
    fn block_782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_782_0: const #1u : u8
        let s_782_0: bool = true;
        // D s_782_1: write-var gs#405880 <= s_782_0
        fn_state.gs_405880 = s_782_0;
        // N s_782_2: jump b779
        return block_779(state, tracer, fn_state);
    }
    fn block_783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_783_0: const #1u : u8
        let s_783_0: bool = true;
        // D s_783_1: write-var gs#405877 <= s_783_0
        fn_state.gs_405877 = s_783_0;
        // N s_783_2: jump b777
        return block_777(state, tracer, fn_state);
    }
    fn block_784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_784_0: const #1u : u8
        let s_784_0: bool = true;
        // D s_784_1: write-var gs#405874 <= s_784_0
        fn_state.gs_405874 = s_784_0;
        // N s_784_2: jump b775
        return block_775(state, tracer, fn_state);
    }
    fn block_785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_785_0: read-var merge#var.1:struct
        let s_785_0: u32 = fn_state.merge_var._1;
        // D s_785_1: write-var u#32763 <= s_785_0
        fn_state.u_32763 = s_785_0;
        // C s_785_2: const #21s : i
        let s_785_2: i128 = 21;
        // D s_785_3: read-var u#32763:u32
        let s_785_3: u32 = fn_state.u_32763;
        // D s_785_4: cast zx s_785_3 -> bv
        let s_785_4: Bits = Bits::new(s_785_3 as u128, 32u16);
        // C s_785_5: const #1s : i64
        let s_785_5: i64 = 1;
        // C s_785_6: cast zx s_785_5 -> i
        let s_785_6: i128 = (i128::try_from(s_785_5).unwrap());
        // C s_785_7: const #6s : i
        let s_785_7: i128 = 6;
        // C s_785_8: add s_785_7 s_785_6
        let s_785_8: i128 = (s_785_7 + s_785_6);
        // D s_785_9: bit-extract s_785_4 s_785_2 s_785_8
        let s_785_9: Bits = (Bits::new(
            ((s_785_4) >> (s_785_2)).value(),
            u16::try_from(s_785_8).unwrap(),
        ));
        // D s_785_10: cast reint s_785_9 -> u8
        let s_785_10: u8 = (s_785_9.value() as u8);
        // D s_785_11: cast zx s_785_10 -> bv
        let s_785_11: Bits = Bits::new(s_785_10 as u128, 7u16);
        // C s_785_12: const #15u : u8
        let s_785_12: u8 = 15;
        // C s_785_13: cast zx s_785_12 -> bv
        let s_785_13: Bits = Bits::new(s_785_12 as u128, 7u16);
        // D s_785_14: cmp-eq s_785_11 s_785_13
        let s_785_14: bool = ((s_785_11) == (s_785_13));
        // N s_785_15: branch s_785_14 b2553 b786
        if s_785_14 {
            return block_2553(state, tracer, fn_state);
        } else {
            return block_786(state, tracer, fn_state);
        };
    }
    fn block_786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_786_0: const #0u : u8
        let s_786_0: bool = false;
        // D s_786_1: write-var gs#405892 <= s_786_0
        fn_state.gs_405892 = s_786_0;
        // N s_786_2: jump b787
        return block_787(state, tracer, fn_state);
    }
    fn block_787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_787_0: read-var gs#405892:u8
        let s_787_0: bool = fn_state.gs_405892;
        // N s_787_1: branch s_787_0 b2549 b788
        if s_787_0 {
            return block_2549(state, tracer, fn_state);
        } else {
            return block_788(state, tracer, fn_state);
        };
    }
    fn block_788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_788_0: const #0u : u8
        let s_788_0: bool = false;
        // D s_788_1: write-var gs#405897 <= s_788_0
        fn_state.gs_405897 = s_788_0;
        // N s_788_2: jump b789
        return block_789(state, tracer, fn_state);
    }
    fn block_789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_789_0: read-var gs#405897:u8
        let s_789_0: bool = fn_state.gs_405897;
        // D s_789_1: not s_789_0
        let s_789_1: bool = !s_789_0;
        // N s_789_2: branch s_789_1 b802 b790
        if s_789_1 {
            return block_802(state, tracer, fn_state);
        } else {
            return block_790(state, tracer, fn_state);
        };
    }
    fn block_790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_790_0: const #3035s : i
        let s_790_0: i128 = 3035;
        // C s_790_1: const #14696u : u32
        let s_790_1: u32 = 14696;
        // N s_790_2: write-reg s_790_1 <= s_790_0
        let s_790_2: () = {
            state.write_register::<i128>(s_790_1 as isize, s_790_0);
            tracer.write_register(s_790_1 as isize, s_790_0);
        };
        // C s_790_3: const #28s : i
        let s_790_3: i128 = 28;
        // C s_790_4: const #4s : i
        let s_790_4: i128 = 4;
        // D s_790_5: read-var u#32763:u32
        let s_790_5: u32 = fn_state.u_32763;
        // D s_790_6: cast zx s_790_5 -> bv
        let s_790_6: Bits = Bits::new(s_790_5 as u128, 32u16);
        // D s_790_7: bit-extract s_790_6 s_790_3 s_790_4
        let s_790_7: Bits = (Bits::new(
            ((s_790_6) >> (s_790_3)).value(),
            u16::try_from(s_790_4).unwrap(),
        ));
        // D s_790_8: cast reint s_790_7 -> u8
        let s_790_8: u8 = (s_790_7.value() as u8);
        // D s_790_9: write-var u#32764 <= s_790_8
        fn_state.u_32764 = s_790_8;
        // C s_790_10: const #20s : i
        let s_790_10: i128 = 20;
        // C s_790_11: const #1s : i
        let s_790_11: i128 = 1;
        // D s_790_12: read-var u#32763:u32
        let s_790_12: u32 = fn_state.u_32763;
        // D s_790_13: cast zx s_790_12 -> bv
        let s_790_13: Bits = Bits::new(s_790_12 as u128, 32u16);
        // D s_790_14: bit-extract s_790_13 s_790_10 s_790_11
        let s_790_14: Bits = (Bits::new(
            ((s_790_13) >> (s_790_10)).value(),
            u16::try_from(s_790_11).unwrap(),
        ));
        // D s_790_15: cast reint s_790_14 -> u8
        let s_790_15: bool = ((s_790_14.value()) != 0);
        // D s_790_16: write-var u#32765 <= s_790_15
        fn_state.u_32765 = s_790_15;
        // C s_790_17: const #12s : i
        let s_790_17: i128 = 12;
        // C s_790_18: const #4s : i
        let s_790_18: i128 = 4;
        // D s_790_19: read-var u#32763:u32
        let s_790_19: u32 = fn_state.u_32763;
        // D s_790_20: cast zx s_790_19 -> bv
        let s_790_20: Bits = Bits::new(s_790_19 as u128, 32u16);
        // D s_790_21: bit-extract s_790_20 s_790_17 s_790_18
        let s_790_21: Bits = (Bits::new(
            ((s_790_20) >> (s_790_17)).value(),
            u16::try_from(s_790_18).unwrap(),
        ));
        // D s_790_22: cast reint s_790_21 -> u8
        let s_790_22: u8 = (s_790_21.value() as u8);
        // D s_790_23: write-var u#32766 <= s_790_22
        fn_state.u_32766 = s_790_22;
        // C s_790_24: const #8s : i
        let s_790_24: i128 = 8;
        // C s_790_25: const #4s : i
        let s_790_25: i128 = 4;
        // D s_790_26: read-var u#32763:u32
        let s_790_26: u32 = fn_state.u_32763;
        // D s_790_27: cast zx s_790_26 -> bv
        let s_790_27: Bits = Bits::new(s_790_26 as u128, 32u16);
        // D s_790_28: bit-extract s_790_27 s_790_24 s_790_25
        let s_790_28: Bits = (Bits::new(
            ((s_790_27) >> (s_790_24)).value(),
            u16::try_from(s_790_25).unwrap(),
        ));
        // D s_790_29: cast reint s_790_28 -> u8
        let s_790_29: u8 = (s_790_28.value() as u8);
        // D s_790_30: write-var u#32767 <= s_790_29
        fn_state.u_32767 = s_790_29;
        // C s_790_31: const #5s : i
        let s_790_31: i128 = 5;
        // C s_790_32: const #2s : i
        let s_790_32: i128 = 2;
        // D s_790_33: read-var u#32763:u32
        let s_790_33: u32 = fn_state.u_32763;
        // D s_790_34: cast zx s_790_33 -> bv
        let s_790_34: Bits = Bits::new(s_790_33 as u128, 32u16);
        // D s_790_35: bit-extract s_790_34 s_790_31 s_790_32
        let s_790_35: Bits = (Bits::new(
            ((s_790_34) >> (s_790_31)).value(),
            u16::try_from(s_790_32).unwrap(),
        ));
        // D s_790_36: cast reint s_790_35 -> u8
        let s_790_36: u8 = (s_790_35.value() as u8);
        // D s_790_37: write-var u#32768 <= s_790_36
        fn_state.u_32768 = s_790_36;
        // C s_790_38: const #0s : i
        let s_790_38: i128 = 0;
        // C s_790_39: const #4s : i
        let s_790_39: i128 = 4;
        // D s_790_40: read-var u#32763:u32
        let s_790_40: u32 = fn_state.u_32763;
        // D s_790_41: cast zx s_790_40 -> bv
        let s_790_41: Bits = Bits::new(s_790_40 as u128, 32u16);
        // D s_790_42: bit-extract s_790_41 s_790_38 s_790_39
        let s_790_42: Bits = (Bits::new(
            ((s_790_41) >> (s_790_38)).value(),
            u16::try_from(s_790_39).unwrap(),
        ));
        // D s_790_43: cast reint s_790_42 -> u8
        let s_790_43: u8 = (s_790_42.value() as u8);
        // D s_790_44: write-var u#32769 <= s_790_43
        fn_state.u_32769 = s_790_43;
        // C s_790_45: const #16s : i
        let s_790_45: i128 = 16;
        // D s_790_46: read-var u#32763:u32
        let s_790_46: u32 = fn_state.u_32763;
        // D s_790_47: cast zx s_790_46 -> bv
        let s_790_47: Bits = Bits::new(s_790_46 as u128, 32u16);
        // C s_790_48: const #1u : u64
        let s_790_48: u64 = 1;
        // D s_790_49: bit-extract s_790_47 s_790_45 s_790_48
        let s_790_49: Bits = (Bits::new(
            ((s_790_47) >> (s_790_45)).value(),
            u16::try_from(s_790_48).unwrap(),
        ));
        // D s_790_50: cast reint s_790_49 -> u8
        let s_790_50: bool = ((s_790_49.value()) != 0);
        // C s_790_51: const #0s : i
        let s_790_51: i128 = 0;
        // C s_790_52: const #0u : u64
        let s_790_52: u64 = 0;
        // D s_790_53: cast zx s_790_50 -> u64
        let s_790_53: u64 = (s_790_50 as u64);
        // C s_790_54: const #1u : u64
        let s_790_54: u64 = 1;
        // D s_790_55: and s_790_53 s_790_54
        let s_790_55: u64 = ((s_790_53) & (s_790_54));
        // D s_790_56: cmp-eq s_790_55 s_790_54
        let s_790_56: bool = ((s_790_55) == (s_790_54));
        // D s_790_57: lsl s_790_53 s_790_51
        let s_790_57: u64 = s_790_53 << s_790_51;
        // D s_790_58: or s_790_52 s_790_57
        let s_790_58: u64 = ((s_790_52) | (s_790_57));
        // D s_790_59: cmpl s_790_57
        let s_790_59: u64 = !s_790_57;
        // D s_790_60: and s_790_52 s_790_59
        let s_790_60: u64 = ((s_790_52) & (s_790_59));
        // D s_790_61: select s_790_56 s_790_58 s_790_60
        let s_790_61: u64 = if s_790_56 { s_790_58 } else { s_790_60 };
        // D s_790_62: cast trunc s_790_61 -> u8
        let s_790_62: bool = ((s_790_61) != 0);
        // D s_790_63: cast zx s_790_62 -> bv
        let s_790_63: Bits = Bits::new(s_790_62 as u128, 1u16);
        // C s_790_64: const #0u : u8
        let s_790_64: bool = false;
        // C s_790_65: cast zx s_790_64 -> bv
        let s_790_65: Bits = Bits::new(s_790_64 as u128, 1u16);
        // D s_790_66: cmp-ne s_790_63 s_790_65
        let s_790_66: bool = ((s_790_63) != (s_790_65));
        // N s_790_67: branch s_790_66 b801 b791
        if s_790_66 {
            return block_801(state, tracer, fn_state);
        } else {
            return block_791(state, tracer, fn_state);
        };
    }
    fn block_791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_791_0: const #17s : i
        let s_791_0: i128 = 17;
        // D s_791_1: read-var u#32763:u32
        let s_791_1: u32 = fn_state.u_32763;
        // D s_791_2: cast zx s_791_1 -> bv
        let s_791_2: Bits = Bits::new(s_791_1 as u128, 32u16);
        // C s_791_3: const #1u : u64
        let s_791_3: u64 = 1;
        // D s_791_4: bit-extract s_791_2 s_791_0 s_791_3
        let s_791_4: Bits = (Bits::new(
            ((s_791_2) >> (s_791_0)).value(),
            u16::try_from(s_791_3).unwrap(),
        ));
        // D s_791_5: cast reint s_791_4 -> u8
        let s_791_5: bool = ((s_791_4.value()) != 0);
        // C s_791_6: const #0s : i
        let s_791_6: i128 = 0;
        // C s_791_7: const #0u : u64
        let s_791_7: u64 = 0;
        // D s_791_8: cast zx s_791_5 -> u64
        let s_791_8: u64 = (s_791_5 as u64);
        // C s_791_9: const #1u : u64
        let s_791_9: u64 = 1;
        // D s_791_10: and s_791_8 s_791_9
        let s_791_10: u64 = ((s_791_8) & (s_791_9));
        // D s_791_11: cmp-eq s_791_10 s_791_9
        let s_791_11: bool = ((s_791_10) == (s_791_9));
        // D s_791_12: lsl s_791_8 s_791_6
        let s_791_12: u64 = s_791_8 << s_791_6;
        // D s_791_13: or s_791_7 s_791_12
        let s_791_13: u64 = ((s_791_7) | (s_791_12));
        // D s_791_14: cmpl s_791_12
        let s_791_14: u64 = !s_791_12;
        // D s_791_15: and s_791_7 s_791_14
        let s_791_15: u64 = ((s_791_7) & (s_791_14));
        // D s_791_16: select s_791_11 s_791_13 s_791_15
        let s_791_16: u64 = if s_791_11 { s_791_13 } else { s_791_15 };
        // D s_791_17: cast trunc s_791_16 -> u8
        let s_791_17: bool = ((s_791_16) != 0);
        // D s_791_18: cast zx s_791_17 -> bv
        let s_791_18: Bits = Bits::new(s_791_17 as u128, 1u16);
        // C s_791_19: const #0u : u8
        let s_791_19: bool = false;
        // C s_791_20: cast zx s_791_19 -> bv
        let s_791_20: Bits = Bits::new(s_791_19 as u128, 1u16);
        // D s_791_21: cmp-ne s_791_18 s_791_20
        let s_791_21: bool = ((s_791_18) != (s_791_20));
        // D s_791_22: write-var gs#405916 <= s_791_21
        fn_state.gs_405916 = s_791_21;
        // N s_791_23: jump b792
        return block_792(state, tracer, fn_state);
    }
    fn block_792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_792_0: read-var gs#405916:u8
        let s_792_0: bool = fn_state.gs_405916;
        // N s_792_1: branch s_792_0 b800 b793
        if s_792_0 {
            return block_800(state, tracer, fn_state);
        } else {
            return block_793(state, tracer, fn_state);
        };
    }
    fn block_793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_793_0: const #18s : i
        let s_793_0: i128 = 18;
        // D s_793_1: read-var u#32763:u32
        let s_793_1: u32 = fn_state.u_32763;
        // D s_793_2: cast zx s_793_1 -> bv
        let s_793_2: Bits = Bits::new(s_793_1 as u128, 32u16);
        // C s_793_3: const #1u : u64
        let s_793_3: u64 = 1;
        // D s_793_4: bit-extract s_793_2 s_793_0 s_793_3
        let s_793_4: Bits = (Bits::new(
            ((s_793_2) >> (s_793_0)).value(),
            u16::try_from(s_793_3).unwrap(),
        ));
        // D s_793_5: cast reint s_793_4 -> u8
        let s_793_5: bool = ((s_793_4.value()) != 0);
        // C s_793_6: const #0s : i
        let s_793_6: i128 = 0;
        // C s_793_7: const #0u : u64
        let s_793_7: u64 = 0;
        // D s_793_8: cast zx s_793_5 -> u64
        let s_793_8: u64 = (s_793_5 as u64);
        // C s_793_9: const #1u : u64
        let s_793_9: u64 = 1;
        // D s_793_10: and s_793_8 s_793_9
        let s_793_10: u64 = ((s_793_8) & (s_793_9));
        // D s_793_11: cmp-eq s_793_10 s_793_9
        let s_793_11: bool = ((s_793_10) == (s_793_9));
        // D s_793_12: lsl s_793_8 s_793_6
        let s_793_12: u64 = s_793_8 << s_793_6;
        // D s_793_13: or s_793_7 s_793_12
        let s_793_13: u64 = ((s_793_7) | (s_793_12));
        // D s_793_14: cmpl s_793_12
        let s_793_14: u64 = !s_793_12;
        // D s_793_15: and s_793_7 s_793_14
        let s_793_15: u64 = ((s_793_7) & (s_793_14));
        // D s_793_16: select s_793_11 s_793_13 s_793_15
        let s_793_16: u64 = if s_793_11 { s_793_13 } else { s_793_15 };
        // D s_793_17: cast trunc s_793_16 -> u8
        let s_793_17: bool = ((s_793_16) != 0);
        // D s_793_18: cast zx s_793_17 -> bv
        let s_793_18: Bits = Bits::new(s_793_17 as u128, 1u16);
        // C s_793_19: const #0u : u8
        let s_793_19: bool = false;
        // C s_793_20: cast zx s_793_19 -> bv
        let s_793_20: Bits = Bits::new(s_793_19 as u128, 1u16);
        // D s_793_21: cmp-ne s_793_18 s_793_20
        let s_793_21: bool = ((s_793_18) != (s_793_20));
        // D s_793_22: write-var gs#405919 <= s_793_21
        fn_state.gs_405919 = s_793_21;
        // N s_793_23: jump b794
        return block_794(state, tracer, fn_state);
    }
    fn block_794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_794_0: read-var gs#405919:u8
        let s_794_0: bool = fn_state.gs_405919;
        // N s_794_1: branch s_794_0 b799 b795
        if s_794_0 {
            return block_799(state, tracer, fn_state);
        } else {
            return block_795(state, tracer, fn_state);
        };
    }
    fn block_795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_795_0: const #19s : i
        let s_795_0: i128 = 19;
        // D s_795_1: read-var u#32763:u32
        let s_795_1: u32 = fn_state.u_32763;
        // D s_795_2: cast zx s_795_1 -> bv
        let s_795_2: Bits = Bits::new(s_795_1 as u128, 32u16);
        // C s_795_3: const #1u : u64
        let s_795_3: u64 = 1;
        // D s_795_4: bit-extract s_795_2 s_795_0 s_795_3
        let s_795_4: Bits = (Bits::new(
            ((s_795_2) >> (s_795_0)).value(),
            u16::try_from(s_795_3).unwrap(),
        ));
        // D s_795_5: cast reint s_795_4 -> u8
        let s_795_5: bool = ((s_795_4.value()) != 0);
        // C s_795_6: const #0s : i
        let s_795_6: i128 = 0;
        // C s_795_7: const #0u : u64
        let s_795_7: u64 = 0;
        // D s_795_8: cast zx s_795_5 -> u64
        let s_795_8: u64 = (s_795_5 as u64);
        // C s_795_9: const #1u : u64
        let s_795_9: u64 = 1;
        // D s_795_10: and s_795_8 s_795_9
        let s_795_10: u64 = ((s_795_8) & (s_795_9));
        // D s_795_11: cmp-eq s_795_10 s_795_9
        let s_795_11: bool = ((s_795_10) == (s_795_9));
        // D s_795_12: lsl s_795_8 s_795_6
        let s_795_12: u64 = s_795_8 << s_795_6;
        // D s_795_13: or s_795_7 s_795_12
        let s_795_13: u64 = ((s_795_7) | (s_795_12));
        // D s_795_14: cmpl s_795_12
        let s_795_14: u64 = !s_795_12;
        // D s_795_15: and s_795_7 s_795_14
        let s_795_15: u64 = ((s_795_7) & (s_795_14));
        // D s_795_16: select s_795_11 s_795_13 s_795_15
        let s_795_16: u64 = if s_795_11 { s_795_13 } else { s_795_15 };
        // D s_795_17: cast trunc s_795_16 -> u8
        let s_795_17: bool = ((s_795_16) != 0);
        // D s_795_18: cast zx s_795_17 -> bv
        let s_795_18: Bits = Bits::new(s_795_17 as u128, 1u16);
        // C s_795_19: const #0u : u8
        let s_795_19: bool = false;
        // C s_795_20: cast zx s_795_19 -> bv
        let s_795_20: Bits = Bits::new(s_795_19 as u128, 1u16);
        // D s_795_21: cmp-ne s_795_18 s_795_20
        let s_795_21: bool = ((s_795_18) != (s_795_20));
        // D s_795_22: write-var gs#405922 <= s_795_21
        fn_state.gs_405922 = s_795_21;
        // N s_795_23: jump b796
        return block_796(state, tracer, fn_state);
    }
    fn block_796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_796_0: read-var gs#405922:u8
        let s_796_0: bool = fn_state.gs_405922;
        // N s_796_1: branch s_796_0 b798 b797
        if s_796_0 {
            return block_798(state, tracer, fn_state);
        } else {
            return block_797(state, tracer, fn_state);
        };
    }
    fn block_797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_797_0: read-var u#32764:u8
        let s_797_0: u8 = fn_state.u_32764;
        // D s_797_1: read-var u#32765:u8
        let s_797_1: bool = fn_state.u_32765;
        // D s_797_2: read-var u#32766:u8
        let s_797_2: u8 = fn_state.u_32766;
        // D s_797_3: read-var u#32767:u8
        let s_797_3: u8 = fn_state.u_32767;
        // D s_797_4: read-var u#32768:u8
        let s_797_4: u8 = fn_state.u_32768;
        // D s_797_5: read-var u#32769:u8
        let s_797_5: u8 = fn_state.u_32769;
        // D s_797_6: call decode_aarch32_instrs_MVN_rr_A1enc_A_txt(s_797_0, s_797_1, s_797_2, s_797_3, s_797_4, s_797_5)
        let s_797_6: () = decode_aarch32_instrs_MVN_rr_A1enc_A_txt(
            state,
            tracer,
            s_797_0,
            s_797_1,
            s_797_2,
            s_797_3,
            s_797_4,
            s_797_5,
        );
        // N s_797_7: return
        return;
    }
    fn block_798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_798_0: panic
        panic!("{:?}", ());
        // N s_798_1: return
        return;
    }
    fn block_799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_799_0: const #1u : u8
        let s_799_0: bool = true;
        // D s_799_1: write-var gs#405922 <= s_799_0
        fn_state.gs_405922 = s_799_0;
        // N s_799_2: jump b796
        return block_796(state, tracer, fn_state);
    }
    fn block_800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_800_0: const #1u : u8
        let s_800_0: bool = true;
        // D s_800_1: write-var gs#405919 <= s_800_0
        fn_state.gs_405919 = s_800_0;
        // N s_800_2: jump b794
        return block_794(state, tracer, fn_state);
    }
    fn block_801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_801_0: const #1u : u8
        let s_801_0: bool = true;
        // D s_801_1: write-var gs#405916 <= s_801_0
        fn_state.gs_405916 = s_801_0;
        // N s_801_2: jump b792
        return block_792(state, tracer, fn_state);
    }
    fn block_802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_802_0: read-var merge#var.1:struct
        let s_802_0: u32 = fn_state.merge_var._1;
        // D s_802_1: write-var u#32771 <= s_802_0
        fn_state.u_32771 = s_802_0;
        // C s_802_2: const #0s : i
        let s_802_2: i128 = 0;
        // D s_802_3: read-var u#32771:u32
        let s_802_3: u32 = fn_state.u_32771;
        // D s_802_4: cast zx s_802_3 -> bv
        let s_802_4: Bits = Bits::new(s_802_3 as u128, 32u16);
        // C s_802_5: const #1s : i64
        let s_802_5: i64 = 1;
        // C s_802_6: cast zx s_802_5 -> i
        let s_802_6: i128 = (i128::try_from(s_802_5).unwrap());
        // C s_802_7: const #27s : i
        let s_802_7: i128 = 27;
        // C s_802_8: add s_802_7 s_802_6
        let s_802_8: i128 = (s_802_7 + s_802_6);
        // D s_802_9: bit-extract s_802_4 s_802_2 s_802_8
        let s_802_9: Bits = (Bits::new(
            ((s_802_4) >> (s_802_2)).value(),
            u16::try_from(s_802_8).unwrap(),
        ));
        // D s_802_10: cast reint s_802_9 -> u28
        let s_802_10: u32 = (s_802_9.value() as u32);
        // D s_802_11: cast zx s_802_10 -> bv
        let s_802_11: Bits = Bits::new(s_802_10 as u128, 28u16);
        // C s_802_12: const #52490240u : u28
        let s_802_12: u32 = 52490240;
        // C s_802_13: cast zx s_802_12 -> bv
        let s_802_13: Bits = Bits::new(s_802_12 as u128, 28u16);
        // D s_802_14: cmp-eq s_802_11 s_802_13
        let s_802_14: bool = ((s_802_11) == (s_802_13));
        // N s_802_15: branch s_802_14 b2545 b803
        if s_802_14 {
            return block_2545(state, tracer, fn_state);
        } else {
            return block_803(state, tracer, fn_state);
        };
    }
    fn block_803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_803_0: const #0u : u8
        let s_803_0: bool = false;
        // D s_803_1: write-var gs#405930 <= s_803_0
        fn_state.gs_405930 = s_803_0;
        // N s_803_2: jump b804
        return block_804(state, tracer, fn_state);
    }
    fn block_804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_804_0: read-var gs#405930:u8
        let s_804_0: bool = fn_state.gs_405930;
        // D s_804_1: not s_804_0
        let s_804_1: bool = !s_804_0;
        // N s_804_2: branch s_804_1 b829 b805
        if s_804_1 {
            return block_829(state, tracer, fn_state);
        } else {
            return block_805(state, tracer, fn_state);
        };
    }
    fn block_805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_805_0: const #3036s : i
        let s_805_0: i128 = 3036;
        // C s_805_1: const #14696u : u32
        let s_805_1: u32 = 14696;
        // N s_805_2: write-reg s_805_1 <= s_805_0
        let s_805_2: () = {
            state.write_register::<i128>(s_805_1 as isize, s_805_0);
            tracer.write_register(s_805_1 as isize, s_805_0);
        };
        // C s_805_3: const #28s : i
        let s_805_3: i128 = 28;
        // C s_805_4: const #4s : i
        let s_805_4: i128 = 4;
        // D s_805_5: read-var u#32771:u32
        let s_805_5: u32 = fn_state.u_32771;
        // D s_805_6: cast zx s_805_5 -> bv
        let s_805_6: Bits = Bits::new(s_805_5 as u128, 32u16);
        // D s_805_7: bit-extract s_805_6 s_805_3 s_805_4
        let s_805_7: Bits = (Bits::new(
            ((s_805_6) >> (s_805_3)).value(),
            u16::try_from(s_805_4).unwrap(),
        ));
        // D s_805_8: cast reint s_805_7 -> u8
        let s_805_8: u8 = (s_805_7.value() as u8);
        // D s_805_9: write-var u#32772 <= s_805_8
        fn_state.u_32772 = s_805_8;
        // C s_805_10: const #12s : i
        let s_805_10: i128 = 12;
        // D s_805_11: read-var u#32771:u32
        let s_805_11: u32 = fn_state.u_32771;
        // D s_805_12: cast zx s_805_11 -> bv
        let s_805_12: Bits = Bits::new(s_805_11 as u128, 32u16);
        // C s_805_13: const #1u : u64
        let s_805_13: u64 = 1;
        // D s_805_14: bit-extract s_805_12 s_805_10 s_805_13
        let s_805_14: Bits = (Bits::new(
            ((s_805_12) >> (s_805_10)).value(),
            u16::try_from(s_805_13).unwrap(),
        ));
        // D s_805_15: cast reint s_805_14 -> u8
        let s_805_15: bool = ((s_805_14.value()) != 0);
        // C s_805_16: const #0s : i
        let s_805_16: i128 = 0;
        // C s_805_17: const #0u : u64
        let s_805_17: u64 = 0;
        // D s_805_18: cast zx s_805_15 -> u64
        let s_805_18: u64 = (s_805_15 as u64);
        // C s_805_19: const #1u : u64
        let s_805_19: u64 = 1;
        // D s_805_20: and s_805_18 s_805_19
        let s_805_20: u64 = ((s_805_18) & (s_805_19));
        // D s_805_21: cmp-eq s_805_20 s_805_19
        let s_805_21: bool = ((s_805_20) == (s_805_19));
        // D s_805_22: lsl s_805_18 s_805_16
        let s_805_22: u64 = s_805_18 << s_805_16;
        // D s_805_23: or s_805_17 s_805_22
        let s_805_23: u64 = ((s_805_17) | (s_805_22));
        // D s_805_24: cmpl s_805_22
        let s_805_24: u64 = !s_805_22;
        // D s_805_25: and s_805_17 s_805_24
        let s_805_25: u64 = ((s_805_17) & (s_805_24));
        // D s_805_26: select s_805_21 s_805_23 s_805_25
        let s_805_26: u64 = if s_805_21 { s_805_23 } else { s_805_25 };
        // D s_805_27: cast trunc s_805_26 -> u8
        let s_805_27: bool = ((s_805_26) != 0);
        // D s_805_28: cast zx s_805_27 -> bv
        let s_805_28: Bits = Bits::new(s_805_27 as u128, 1u16);
        // C s_805_29: const #1u : u8
        let s_805_29: bool = true;
        // C s_805_30: cast zx s_805_29 -> bv
        let s_805_30: Bits = Bits::new(s_805_29 as u128, 1u16);
        // D s_805_31: cmp-ne s_805_28 s_805_30
        let s_805_31: bool = ((s_805_28) != (s_805_30));
        // N s_805_32: branch s_805_31 b828 b806
        if s_805_31 {
            return block_828(state, tracer, fn_state);
        } else {
            return block_806(state, tracer, fn_state);
        };
    }
    fn block_806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_806_0: const #13s : i
        let s_806_0: i128 = 13;
        // D s_806_1: read-var u#32771:u32
        let s_806_1: u32 = fn_state.u_32771;
        // D s_806_2: cast zx s_806_1 -> bv
        let s_806_2: Bits = Bits::new(s_806_1 as u128, 32u16);
        // C s_806_3: const #1u : u64
        let s_806_3: u64 = 1;
        // D s_806_4: bit-extract s_806_2 s_806_0 s_806_3
        let s_806_4: Bits = (Bits::new(
            ((s_806_2) >> (s_806_0)).value(),
            u16::try_from(s_806_3).unwrap(),
        ));
        // D s_806_5: cast reint s_806_4 -> u8
        let s_806_5: bool = ((s_806_4.value()) != 0);
        // C s_806_6: const #0s : i
        let s_806_6: i128 = 0;
        // C s_806_7: const #0u : u64
        let s_806_7: u64 = 0;
        // D s_806_8: cast zx s_806_5 -> u64
        let s_806_8: u64 = (s_806_5 as u64);
        // C s_806_9: const #1u : u64
        let s_806_9: u64 = 1;
        // D s_806_10: and s_806_8 s_806_9
        let s_806_10: u64 = ((s_806_8) & (s_806_9));
        // D s_806_11: cmp-eq s_806_10 s_806_9
        let s_806_11: bool = ((s_806_10) == (s_806_9));
        // D s_806_12: lsl s_806_8 s_806_6
        let s_806_12: u64 = s_806_8 << s_806_6;
        // D s_806_13: or s_806_7 s_806_12
        let s_806_13: u64 = ((s_806_7) | (s_806_12));
        // D s_806_14: cmpl s_806_12
        let s_806_14: u64 = !s_806_12;
        // D s_806_15: and s_806_7 s_806_14
        let s_806_15: u64 = ((s_806_7) & (s_806_14));
        // D s_806_16: select s_806_11 s_806_13 s_806_15
        let s_806_16: u64 = if s_806_11 { s_806_13 } else { s_806_15 };
        // D s_806_17: cast trunc s_806_16 -> u8
        let s_806_17: bool = ((s_806_16) != 0);
        // D s_806_18: cast zx s_806_17 -> bv
        let s_806_18: Bits = Bits::new(s_806_17 as u128, 1u16);
        // C s_806_19: const #1u : u8
        let s_806_19: bool = true;
        // C s_806_20: cast zx s_806_19 -> bv
        let s_806_20: Bits = Bits::new(s_806_19 as u128, 1u16);
        // D s_806_21: cmp-ne s_806_18 s_806_20
        let s_806_21: bool = ((s_806_18) != (s_806_20));
        // D s_806_22: write-var gs#405939 <= s_806_21
        fn_state.gs_405939 = s_806_21;
        // N s_806_23: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_807_0: read-var gs#405939:u8
        let s_807_0: bool = fn_state.gs_405939;
        // N s_807_1: branch s_807_0 b827 b808
        if s_807_0 {
            return block_827(state, tracer, fn_state);
        } else {
            return block_808(state, tracer, fn_state);
        };
    }
    fn block_808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_808_0: const #14s : i
        let s_808_0: i128 = 14;
        // D s_808_1: read-var u#32771:u32
        let s_808_1: u32 = fn_state.u_32771;
        // D s_808_2: cast zx s_808_1 -> bv
        let s_808_2: Bits = Bits::new(s_808_1 as u128, 32u16);
        // C s_808_3: const #1u : u64
        let s_808_3: u64 = 1;
        // D s_808_4: bit-extract s_808_2 s_808_0 s_808_3
        let s_808_4: Bits = (Bits::new(
            ((s_808_2) >> (s_808_0)).value(),
            u16::try_from(s_808_3).unwrap(),
        ));
        // D s_808_5: cast reint s_808_4 -> u8
        let s_808_5: bool = ((s_808_4.value()) != 0);
        // C s_808_6: const #0s : i
        let s_808_6: i128 = 0;
        // C s_808_7: const #0u : u64
        let s_808_7: u64 = 0;
        // D s_808_8: cast zx s_808_5 -> u64
        let s_808_8: u64 = (s_808_5 as u64);
        // C s_808_9: const #1u : u64
        let s_808_9: u64 = 1;
        // D s_808_10: and s_808_8 s_808_9
        let s_808_10: u64 = ((s_808_8) & (s_808_9));
        // D s_808_11: cmp-eq s_808_10 s_808_9
        let s_808_11: bool = ((s_808_10) == (s_808_9));
        // D s_808_12: lsl s_808_8 s_808_6
        let s_808_12: u64 = s_808_8 << s_808_6;
        // D s_808_13: or s_808_7 s_808_12
        let s_808_13: u64 = ((s_808_7) | (s_808_12));
        // D s_808_14: cmpl s_808_12
        let s_808_14: u64 = !s_808_12;
        // D s_808_15: and s_808_7 s_808_14
        let s_808_15: u64 = ((s_808_7) & (s_808_14));
        // D s_808_16: select s_808_11 s_808_13 s_808_15
        let s_808_16: u64 = if s_808_11 { s_808_13 } else { s_808_15 };
        // D s_808_17: cast trunc s_808_16 -> u8
        let s_808_17: bool = ((s_808_16) != 0);
        // D s_808_18: cast zx s_808_17 -> bv
        let s_808_18: Bits = Bits::new(s_808_17 as u128, 1u16);
        // C s_808_19: const #1u : u8
        let s_808_19: bool = true;
        // C s_808_20: cast zx s_808_19 -> bv
        let s_808_20: Bits = Bits::new(s_808_19 as u128, 1u16);
        // D s_808_21: cmp-ne s_808_18 s_808_20
        let s_808_21: bool = ((s_808_18) != (s_808_20));
        // D s_808_22: write-var gs#405942 <= s_808_21
        fn_state.gs_405942 = s_808_21;
        // N s_808_23: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_809_0: read-var gs#405942:u8
        let s_809_0: bool = fn_state.gs_405942;
        // N s_809_1: branch s_809_0 b826 b810
        if s_809_0 {
            return block_826(state, tracer, fn_state);
        } else {
            return block_810(state, tracer, fn_state);
        };
    }
    fn block_810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_810_0: const #15s : i
        let s_810_0: i128 = 15;
        // D s_810_1: read-var u#32771:u32
        let s_810_1: u32 = fn_state.u_32771;
        // D s_810_2: cast zx s_810_1 -> bv
        let s_810_2: Bits = Bits::new(s_810_1 as u128, 32u16);
        // C s_810_3: const #1u : u64
        let s_810_3: u64 = 1;
        // D s_810_4: bit-extract s_810_2 s_810_0 s_810_3
        let s_810_4: Bits = (Bits::new(
            ((s_810_2) >> (s_810_0)).value(),
            u16::try_from(s_810_3).unwrap(),
        ));
        // D s_810_5: cast reint s_810_4 -> u8
        let s_810_5: bool = ((s_810_4.value()) != 0);
        // C s_810_6: const #0s : i
        let s_810_6: i128 = 0;
        // C s_810_7: const #0u : u64
        let s_810_7: u64 = 0;
        // D s_810_8: cast zx s_810_5 -> u64
        let s_810_8: u64 = (s_810_5 as u64);
        // C s_810_9: const #1u : u64
        let s_810_9: u64 = 1;
        // D s_810_10: and s_810_8 s_810_9
        let s_810_10: u64 = ((s_810_8) & (s_810_9));
        // D s_810_11: cmp-eq s_810_10 s_810_9
        let s_810_11: bool = ((s_810_10) == (s_810_9));
        // D s_810_12: lsl s_810_8 s_810_6
        let s_810_12: u64 = s_810_8 << s_810_6;
        // D s_810_13: or s_810_7 s_810_12
        let s_810_13: u64 = ((s_810_7) | (s_810_12));
        // D s_810_14: cmpl s_810_12
        let s_810_14: u64 = !s_810_12;
        // D s_810_15: and s_810_7 s_810_14
        let s_810_15: u64 = ((s_810_7) & (s_810_14));
        // D s_810_16: select s_810_11 s_810_13 s_810_15
        let s_810_16: u64 = if s_810_11 { s_810_13 } else { s_810_15 };
        // D s_810_17: cast trunc s_810_16 -> u8
        let s_810_17: bool = ((s_810_16) != 0);
        // D s_810_18: cast zx s_810_17 -> bv
        let s_810_18: Bits = Bits::new(s_810_17 as u128, 1u16);
        // C s_810_19: const #1u : u8
        let s_810_19: bool = true;
        // C s_810_20: cast zx s_810_19 -> bv
        let s_810_20: Bits = Bits::new(s_810_19 as u128, 1u16);
        // D s_810_21: cmp-ne s_810_18 s_810_20
        let s_810_21: bool = ((s_810_18) != (s_810_20));
        // D s_810_22: write-var gs#405945 <= s_810_21
        fn_state.gs_405945 = s_810_21;
        // N s_810_23: jump b811
        return block_811(state, tracer, fn_state);
    }
    fn block_811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_811_0: read-var gs#405945:u8
        let s_811_0: bool = fn_state.gs_405945;
        // N s_811_1: branch s_811_0 b825 b812
        if s_811_0 {
            return block_825(state, tracer, fn_state);
        } else {
            return block_812(state, tracer, fn_state);
        };
    }
    fn block_812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_812_0: const #8s : i
        let s_812_0: i128 = 8;
        // D s_812_1: read-var u#32771:u32
        let s_812_1: u32 = fn_state.u_32771;
        // D s_812_2: cast zx s_812_1 -> bv
        let s_812_2: Bits = Bits::new(s_812_1 as u128, 32u16);
        // C s_812_3: const #1u : u64
        let s_812_3: u64 = 1;
        // D s_812_4: bit-extract s_812_2 s_812_0 s_812_3
        let s_812_4: Bits = (Bits::new(
            ((s_812_2) >> (s_812_0)).value(),
            u16::try_from(s_812_3).unwrap(),
        ));
        // D s_812_5: cast reint s_812_4 -> u8
        let s_812_5: bool = ((s_812_4.value()) != 0);
        // C s_812_6: const #0s : i
        let s_812_6: i128 = 0;
        // C s_812_7: const #0u : u64
        let s_812_7: u64 = 0;
        // D s_812_8: cast zx s_812_5 -> u64
        let s_812_8: u64 = (s_812_5 as u64);
        // C s_812_9: const #1u : u64
        let s_812_9: u64 = 1;
        // D s_812_10: and s_812_8 s_812_9
        let s_812_10: u64 = ((s_812_8) & (s_812_9));
        // D s_812_11: cmp-eq s_812_10 s_812_9
        let s_812_11: bool = ((s_812_10) == (s_812_9));
        // D s_812_12: lsl s_812_8 s_812_6
        let s_812_12: u64 = s_812_8 << s_812_6;
        // D s_812_13: or s_812_7 s_812_12
        let s_812_13: u64 = ((s_812_7) | (s_812_12));
        // D s_812_14: cmpl s_812_12
        let s_812_14: u64 = !s_812_12;
        // D s_812_15: and s_812_7 s_812_14
        let s_812_15: u64 = ((s_812_7) & (s_812_14));
        // D s_812_16: select s_812_11 s_812_13 s_812_15
        let s_812_16: u64 = if s_812_11 { s_812_13 } else { s_812_15 };
        // D s_812_17: cast trunc s_812_16 -> u8
        let s_812_17: bool = ((s_812_16) != 0);
        // D s_812_18: cast zx s_812_17 -> bv
        let s_812_18: Bits = Bits::new(s_812_17 as u128, 1u16);
        // C s_812_19: const #0u : u8
        let s_812_19: bool = false;
        // C s_812_20: cast zx s_812_19 -> bv
        let s_812_20: Bits = Bits::new(s_812_19 as u128, 1u16);
        // D s_812_21: cmp-ne s_812_18 s_812_20
        let s_812_21: bool = ((s_812_18) != (s_812_20));
        // D s_812_22: write-var gs#405948 <= s_812_21
        fn_state.gs_405948 = s_812_21;
        // N s_812_23: jump b813
        return block_813(state, tracer, fn_state);
    }
    fn block_813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_813_0: read-var gs#405948:u8
        let s_813_0: bool = fn_state.gs_405948;
        // N s_813_1: branch s_813_0 b824 b814
        if s_813_0 {
            return block_824(state, tracer, fn_state);
        } else {
            return block_814(state, tracer, fn_state);
        };
    }
    fn block_814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_814_0: const #9s : i
        let s_814_0: i128 = 9;
        // D s_814_1: read-var u#32771:u32
        let s_814_1: u32 = fn_state.u_32771;
        // D s_814_2: cast zx s_814_1 -> bv
        let s_814_2: Bits = Bits::new(s_814_1 as u128, 32u16);
        // C s_814_3: const #1u : u64
        let s_814_3: u64 = 1;
        // D s_814_4: bit-extract s_814_2 s_814_0 s_814_3
        let s_814_4: Bits = (Bits::new(
            ((s_814_2) >> (s_814_0)).value(),
            u16::try_from(s_814_3).unwrap(),
        ));
        // D s_814_5: cast reint s_814_4 -> u8
        let s_814_5: bool = ((s_814_4.value()) != 0);
        // C s_814_6: const #0s : i
        let s_814_6: i128 = 0;
        // C s_814_7: const #0u : u64
        let s_814_7: u64 = 0;
        // D s_814_8: cast zx s_814_5 -> u64
        let s_814_8: u64 = (s_814_5 as u64);
        // C s_814_9: const #1u : u64
        let s_814_9: u64 = 1;
        // D s_814_10: and s_814_8 s_814_9
        let s_814_10: u64 = ((s_814_8) & (s_814_9));
        // D s_814_11: cmp-eq s_814_10 s_814_9
        let s_814_11: bool = ((s_814_10) == (s_814_9));
        // D s_814_12: lsl s_814_8 s_814_6
        let s_814_12: u64 = s_814_8 << s_814_6;
        // D s_814_13: or s_814_7 s_814_12
        let s_814_13: u64 = ((s_814_7) | (s_814_12));
        // D s_814_14: cmpl s_814_12
        let s_814_14: u64 = !s_814_12;
        // D s_814_15: and s_814_7 s_814_14
        let s_814_15: u64 = ((s_814_7) & (s_814_14));
        // D s_814_16: select s_814_11 s_814_13 s_814_15
        let s_814_16: u64 = if s_814_11 { s_814_13 } else { s_814_15 };
        // D s_814_17: cast trunc s_814_16 -> u8
        let s_814_17: bool = ((s_814_16) != 0);
        // D s_814_18: cast zx s_814_17 -> bv
        let s_814_18: Bits = Bits::new(s_814_17 as u128, 1u16);
        // C s_814_19: const #0u : u8
        let s_814_19: bool = false;
        // C s_814_20: cast zx s_814_19 -> bv
        let s_814_20: Bits = Bits::new(s_814_19 as u128, 1u16);
        // D s_814_21: cmp-ne s_814_18 s_814_20
        let s_814_21: bool = ((s_814_18) != (s_814_20));
        // D s_814_22: write-var gs#405951 <= s_814_21
        fn_state.gs_405951 = s_814_21;
        // N s_814_23: jump b815
        return block_815(state, tracer, fn_state);
    }
    fn block_815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_815_0: read-var gs#405951:u8
        let s_815_0: bool = fn_state.gs_405951;
        // N s_815_1: branch s_815_0 b823 b816
        if s_815_0 {
            return block_823(state, tracer, fn_state);
        } else {
            return block_816(state, tracer, fn_state);
        };
    }
    fn block_816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_816_0: const #10s : i
        let s_816_0: i128 = 10;
        // D s_816_1: read-var u#32771:u32
        let s_816_1: u32 = fn_state.u_32771;
        // D s_816_2: cast zx s_816_1 -> bv
        let s_816_2: Bits = Bits::new(s_816_1 as u128, 32u16);
        // C s_816_3: const #1u : u64
        let s_816_3: u64 = 1;
        // D s_816_4: bit-extract s_816_2 s_816_0 s_816_3
        let s_816_4: Bits = (Bits::new(
            ((s_816_2) >> (s_816_0)).value(),
            u16::try_from(s_816_3).unwrap(),
        ));
        // D s_816_5: cast reint s_816_4 -> u8
        let s_816_5: bool = ((s_816_4.value()) != 0);
        // C s_816_6: const #0s : i
        let s_816_6: i128 = 0;
        // C s_816_7: const #0u : u64
        let s_816_7: u64 = 0;
        // D s_816_8: cast zx s_816_5 -> u64
        let s_816_8: u64 = (s_816_5 as u64);
        // C s_816_9: const #1u : u64
        let s_816_9: u64 = 1;
        // D s_816_10: and s_816_8 s_816_9
        let s_816_10: u64 = ((s_816_8) & (s_816_9));
        // D s_816_11: cmp-eq s_816_10 s_816_9
        let s_816_11: bool = ((s_816_10) == (s_816_9));
        // D s_816_12: lsl s_816_8 s_816_6
        let s_816_12: u64 = s_816_8 << s_816_6;
        // D s_816_13: or s_816_7 s_816_12
        let s_816_13: u64 = ((s_816_7) | (s_816_12));
        // D s_816_14: cmpl s_816_12
        let s_816_14: u64 = !s_816_12;
        // D s_816_15: and s_816_7 s_816_14
        let s_816_15: u64 = ((s_816_7) & (s_816_14));
        // D s_816_16: select s_816_11 s_816_13 s_816_15
        let s_816_16: u64 = if s_816_11 { s_816_13 } else { s_816_15 };
        // D s_816_17: cast trunc s_816_16 -> u8
        let s_816_17: bool = ((s_816_16) != 0);
        // D s_816_18: cast zx s_816_17 -> bv
        let s_816_18: Bits = Bits::new(s_816_17 as u128, 1u16);
        // C s_816_19: const #0u : u8
        let s_816_19: bool = false;
        // C s_816_20: cast zx s_816_19 -> bv
        let s_816_20: Bits = Bits::new(s_816_19 as u128, 1u16);
        // D s_816_21: cmp-ne s_816_18 s_816_20
        let s_816_21: bool = ((s_816_18) != (s_816_20));
        // D s_816_22: write-var gs#405954 <= s_816_21
        fn_state.gs_405954 = s_816_21;
        // N s_816_23: jump b817
        return block_817(state, tracer, fn_state);
    }
    fn block_817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_817_0: read-var gs#405954:u8
        let s_817_0: bool = fn_state.gs_405954;
        // N s_817_1: branch s_817_0 b822 b818
        if s_817_0 {
            return block_822(state, tracer, fn_state);
        } else {
            return block_818(state, tracer, fn_state);
        };
    }
    fn block_818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_818_0: const #11s : i
        let s_818_0: i128 = 11;
        // D s_818_1: read-var u#32771:u32
        let s_818_1: u32 = fn_state.u_32771;
        // D s_818_2: cast zx s_818_1 -> bv
        let s_818_2: Bits = Bits::new(s_818_1 as u128, 32u16);
        // C s_818_3: const #1u : u64
        let s_818_3: u64 = 1;
        // D s_818_4: bit-extract s_818_2 s_818_0 s_818_3
        let s_818_4: Bits = (Bits::new(
            ((s_818_2) >> (s_818_0)).value(),
            u16::try_from(s_818_3).unwrap(),
        ));
        // D s_818_5: cast reint s_818_4 -> u8
        let s_818_5: bool = ((s_818_4.value()) != 0);
        // C s_818_6: const #0s : i
        let s_818_6: i128 = 0;
        // C s_818_7: const #0u : u64
        let s_818_7: u64 = 0;
        // D s_818_8: cast zx s_818_5 -> u64
        let s_818_8: u64 = (s_818_5 as u64);
        // C s_818_9: const #1u : u64
        let s_818_9: u64 = 1;
        // D s_818_10: and s_818_8 s_818_9
        let s_818_10: u64 = ((s_818_8) & (s_818_9));
        // D s_818_11: cmp-eq s_818_10 s_818_9
        let s_818_11: bool = ((s_818_10) == (s_818_9));
        // D s_818_12: lsl s_818_8 s_818_6
        let s_818_12: u64 = s_818_8 << s_818_6;
        // D s_818_13: or s_818_7 s_818_12
        let s_818_13: u64 = ((s_818_7) | (s_818_12));
        // D s_818_14: cmpl s_818_12
        let s_818_14: u64 = !s_818_12;
        // D s_818_15: and s_818_7 s_818_14
        let s_818_15: u64 = ((s_818_7) & (s_818_14));
        // D s_818_16: select s_818_11 s_818_13 s_818_15
        let s_818_16: u64 = if s_818_11 { s_818_13 } else { s_818_15 };
        // D s_818_17: cast trunc s_818_16 -> u8
        let s_818_17: bool = ((s_818_16) != 0);
        // D s_818_18: cast zx s_818_17 -> bv
        let s_818_18: Bits = Bits::new(s_818_17 as u128, 1u16);
        // C s_818_19: const #0u : u8
        let s_818_19: bool = false;
        // C s_818_20: cast zx s_818_19 -> bv
        let s_818_20: Bits = Bits::new(s_818_19 as u128, 1u16);
        // D s_818_21: cmp-ne s_818_18 s_818_20
        let s_818_21: bool = ((s_818_18) != (s_818_20));
        // D s_818_22: write-var gs#405957 <= s_818_21
        fn_state.gs_405957 = s_818_21;
        // N s_818_23: jump b819
        return block_819(state, tracer, fn_state);
    }
    fn block_819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_819_0: read-var gs#405957:u8
        let s_819_0: bool = fn_state.gs_405957;
        // N s_819_1: branch s_819_0 b821 b820
        if s_819_0 {
            return block_821(state, tracer, fn_state);
        } else {
            return block_820(state, tracer, fn_state);
        };
    }
    fn block_820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_820_0: read-var u#32772:u8
        let s_820_0: u8 = fn_state.u_32772;
        // D s_820_1: call decode_aarch32_instrs_NOP_A1enc_A_txt(s_820_0)
        let s_820_1: () = decode_aarch32_instrs_NOP_A1enc_A_txt(state, tracer, s_820_0);
        // N s_820_2: return
        return;
    }
    fn block_821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_821_0: panic
        panic!("{:?}", ());
        // N s_821_1: return
        return;
    }
    fn block_822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_822_0: const #1u : u8
        let s_822_0: bool = true;
        // D s_822_1: write-var gs#405957 <= s_822_0
        fn_state.gs_405957 = s_822_0;
        // N s_822_2: jump b819
        return block_819(state, tracer, fn_state);
    }
    fn block_823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_823_0: const #1u : u8
        let s_823_0: bool = true;
        // D s_823_1: write-var gs#405954 <= s_823_0
        fn_state.gs_405954 = s_823_0;
        // N s_823_2: jump b817
        return block_817(state, tracer, fn_state);
    }
    fn block_824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_824_0: const #1u : u8
        let s_824_0: bool = true;
        // D s_824_1: write-var gs#405951 <= s_824_0
        fn_state.gs_405951 = s_824_0;
        // N s_824_2: jump b815
        return block_815(state, tracer, fn_state);
    }
    fn block_825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_825_0: const #1u : u8
        let s_825_0: bool = true;
        // D s_825_1: write-var gs#405948 <= s_825_0
        fn_state.gs_405948 = s_825_0;
        // N s_825_2: jump b813
        return block_813(state, tracer, fn_state);
    }
    fn block_826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_826_0: const #1u : u8
        let s_826_0: bool = true;
        // D s_826_1: write-var gs#405945 <= s_826_0
        fn_state.gs_405945 = s_826_0;
        // N s_826_2: jump b811
        return block_811(state, tracer, fn_state);
    }
    fn block_827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_827_0: const #1u : u8
        let s_827_0: bool = true;
        // D s_827_1: write-var gs#405942 <= s_827_0
        fn_state.gs_405942 = s_827_0;
        // N s_827_2: jump b809
        return block_809(state, tracer, fn_state);
    }
    fn block_828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_828_0: const #1u : u8
        let s_828_0: bool = true;
        // D s_828_1: write-var gs#405939 <= s_828_0
        fn_state.gs_405939 = s_828_0;
        // N s_828_2: jump b807
        return block_807(state, tracer, fn_state);
    }
    fn block_829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_829_0: read-var merge#var.1:struct
        let s_829_0: u32 = fn_state.merge_var._1;
        // D s_829_1: write-var u#32774 <= s_829_0
        fn_state.u_32774 = s_829_0;
        // C s_829_2: const #21s : i
        let s_829_2: i128 = 21;
        // D s_829_3: read-var u#32774:u32
        let s_829_3: u32 = fn_state.u_32774;
        // D s_829_4: cast zx s_829_3 -> bv
        let s_829_4: Bits = Bits::new(s_829_3 as u128, 32u16);
        // C s_829_5: const #1s : i64
        let s_829_5: i64 = 1;
        // C s_829_6: cast zx s_829_5 -> i
        let s_829_6: i128 = (i128::try_from(s_829_5).unwrap());
        // C s_829_7: const #6s : i
        let s_829_7: i128 = 6;
        // C s_829_8: add s_829_7 s_829_6
        let s_829_8: i128 = (s_829_7 + s_829_6);
        // D s_829_9: bit-extract s_829_4 s_829_2 s_829_8
        let s_829_9: Bits = (Bits::new(
            ((s_829_4) >> (s_829_2)).value(),
            u16::try_from(s_829_8).unwrap(),
        ));
        // D s_829_10: cast reint s_829_9 -> u8
        let s_829_10: u8 = (s_829_9.value() as u8);
        // D s_829_11: cast zx s_829_10 -> bv
        let s_829_11: Bits = Bits::new(s_829_10 as u128, 7u16);
        // C s_829_12: const #28u : u8
        let s_829_12: u8 = 28;
        // C s_829_13: cast zx s_829_12 -> bv
        let s_829_13: Bits = Bits::new(s_829_12 as u128, 7u16);
        // D s_829_14: cmp-eq s_829_11 s_829_13
        let s_829_14: bool = ((s_829_11) == (s_829_13));
        // N s_829_15: branch s_829_14 b2541 b830
        if s_829_14 {
            return block_2541(state, tracer, fn_state);
        } else {
            return block_830(state, tracer, fn_state);
        };
    }
    fn block_830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_830_0: const #0u : u8
        let s_830_0: bool = false;
        // D s_830_1: write-var gs#405965 <= s_830_0
        fn_state.gs_405965 = s_830_0;
        // N s_830_2: jump b831
        return block_831(state, tracer, fn_state);
    }
    fn block_831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_831_0: read-var gs#405965:u8
        let s_831_0: bool = fn_state.gs_405965;
        // D s_831_1: not s_831_0
        let s_831_1: bool = !s_831_0;
        // N s_831_2: branch s_831_1 b833 b832
        if s_831_1 {
            return block_833(state, tracer, fn_state);
        } else {
            return block_832(state, tracer, fn_state);
        };
    }
    fn block_832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_832_0: const #3041s : i
        let s_832_0: i128 = 3041;
        // C s_832_1: const #14696u : u32
        let s_832_1: u32 = 14696;
        // N s_832_2: write-reg s_832_1 <= s_832_0
        let s_832_2: () = {
            state.write_register::<i128>(s_832_1 as isize, s_832_0);
            tracer.write_register(s_832_1 as isize, s_832_0);
        };
        // C s_832_3: const #28s : i
        let s_832_3: i128 = 28;
        // C s_832_4: const #4s : i
        let s_832_4: i128 = 4;
        // D s_832_5: read-var u#32774:u32
        let s_832_5: u32 = fn_state.u_32774;
        // D s_832_6: cast zx s_832_5 -> bv
        let s_832_6: Bits = Bits::new(s_832_5 as u128, 32u16);
        // D s_832_7: bit-extract s_832_6 s_832_3 s_832_4
        let s_832_7: Bits = (Bits::new(
            ((s_832_6) >> (s_832_3)).value(),
            u16::try_from(s_832_4).unwrap(),
        ));
        // D s_832_8: cast reint s_832_7 -> u8
        let s_832_8: u8 = (s_832_7.value() as u8);
        // C s_832_9: const #20s : i
        let s_832_9: i128 = 20;
        // C s_832_10: const #1s : i
        let s_832_10: i128 = 1;
        // D s_832_11: read-var u#32774:u32
        let s_832_11: u32 = fn_state.u_32774;
        // D s_832_12: cast zx s_832_11 -> bv
        let s_832_12: Bits = Bits::new(s_832_11 as u128, 32u16);
        // D s_832_13: bit-extract s_832_12 s_832_9 s_832_10
        let s_832_13: Bits = (Bits::new(
            ((s_832_12) >> (s_832_9)).value(),
            u16::try_from(s_832_10).unwrap(),
        ));
        // D s_832_14: cast reint s_832_13 -> u8
        let s_832_14: bool = ((s_832_13.value()) != 0);
        // C s_832_15: const #16s : i
        let s_832_15: i128 = 16;
        // C s_832_16: const #4s : i
        let s_832_16: i128 = 4;
        // D s_832_17: read-var u#32774:u32
        let s_832_17: u32 = fn_state.u_32774;
        // D s_832_18: cast zx s_832_17 -> bv
        let s_832_18: Bits = Bits::new(s_832_17 as u128, 32u16);
        // D s_832_19: bit-extract s_832_18 s_832_15 s_832_16
        let s_832_19: Bits = (Bits::new(
            ((s_832_18) >> (s_832_15)).value(),
            u16::try_from(s_832_16).unwrap(),
        ));
        // D s_832_20: cast reint s_832_19 -> u8
        let s_832_20: u8 = (s_832_19.value() as u8);
        // C s_832_21: const #12s : i
        let s_832_21: i128 = 12;
        // C s_832_22: const #4s : i
        let s_832_22: i128 = 4;
        // D s_832_23: read-var u#32774:u32
        let s_832_23: u32 = fn_state.u_32774;
        // D s_832_24: cast zx s_832_23 -> bv
        let s_832_24: Bits = Bits::new(s_832_23 as u128, 32u16);
        // D s_832_25: bit-extract s_832_24 s_832_21 s_832_22
        let s_832_25: Bits = (Bits::new(
            ((s_832_24) >> (s_832_21)).value(),
            u16::try_from(s_832_22).unwrap(),
        ));
        // D s_832_26: cast reint s_832_25 -> u8
        let s_832_26: u8 = (s_832_25.value() as u8);
        // C s_832_27: const #0s : i
        let s_832_27: i128 = 0;
        // C s_832_28: const #12s : i
        let s_832_28: i128 = 12;
        // D s_832_29: read-var u#32774:u32
        let s_832_29: u32 = fn_state.u_32774;
        // D s_832_30: cast zx s_832_29 -> bv
        let s_832_30: Bits = Bits::new(s_832_29 as u128, 32u16);
        // D s_832_31: bit-extract s_832_30 s_832_27 s_832_28
        let s_832_31: Bits = (Bits::new(
            ((s_832_30) >> (s_832_27)).value(),
            u16::try_from(s_832_28).unwrap(),
        ));
        // D s_832_32: cast reint s_832_31 -> u12
        let s_832_32: u16 = (s_832_31.value() as u16);
        // D s_832_33: call decode_aarch32_instrs_ORR_i_A1enc_A_txt(s_832_8, s_832_14, s_832_20, s_832_26, s_832_32)
        let s_832_33: () = decode_aarch32_instrs_ORR_i_A1enc_A_txt(
            state,
            tracer,
            s_832_8,
            s_832_14,
            s_832_20,
            s_832_26,
            s_832_32,
        );
        // N s_832_34: return
        return;
    }
    fn block_833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_833_0: read-var merge#var.1:struct
        let s_833_0: u32 = fn_state.merge_var._1;
        // D s_833_1: write-var u#32781 <= s_833_0
        fn_state.u_32781 = s_833_0;
        // C s_833_2: const #21s : i
        let s_833_2: i128 = 21;
        // D s_833_3: read-var u#32781:u32
        let s_833_3: u32 = fn_state.u_32781;
        // D s_833_4: cast zx s_833_3 -> bv
        let s_833_4: Bits = Bits::new(s_833_3 as u128, 32u16);
        // C s_833_5: const #1s : i64
        let s_833_5: i64 = 1;
        // C s_833_6: cast zx s_833_5 -> i
        let s_833_6: i128 = (i128::try_from(s_833_5).unwrap());
        // C s_833_7: const #6s : i
        let s_833_7: i128 = 6;
        // C s_833_8: add s_833_7 s_833_6
        let s_833_8: i128 = (s_833_7 + s_833_6);
        // D s_833_9: bit-extract s_833_4 s_833_2 s_833_8
        let s_833_9: Bits = (Bits::new(
            ((s_833_4) >> (s_833_2)).value(),
            u16::try_from(s_833_8).unwrap(),
        ));
        // D s_833_10: cast reint s_833_9 -> u8
        let s_833_10: u8 = (s_833_9.value() as u8);
        // D s_833_11: cast zx s_833_10 -> bv
        let s_833_11: Bits = Bits::new(s_833_10 as u128, 7u16);
        // C s_833_12: const #12u : u8
        let s_833_12: u8 = 12;
        // C s_833_13: cast zx s_833_12 -> bv
        let s_833_13: Bits = Bits::new(s_833_12 as u128, 7u16);
        // D s_833_14: cmp-eq s_833_11 s_833_13
        let s_833_14: bool = ((s_833_11) == (s_833_13));
        // N s_833_15: branch s_833_14 b2540 b834
        if s_833_14 {
            return block_2540(state, tracer, fn_state);
        } else {
            return block_834(state, tracer, fn_state);
        };
    }
    fn block_834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_834_0: const #0u : u8
        let s_834_0: bool = false;
        // D s_834_1: write-var gs#405983 <= s_834_0
        fn_state.gs_405983 = s_834_0;
        // N s_834_2: jump b835
        return block_835(state, tracer, fn_state);
    }
    fn block_835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_835_0: read-var gs#405983:u8
        let s_835_0: bool = fn_state.gs_405983;
        // N s_835_1: branch s_835_0 b2536 b836
        if s_835_0 {
            return block_2536(state, tracer, fn_state);
        } else {
            return block_836(state, tracer, fn_state);
        };
    }
    fn block_836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_836_0: const #0u : u8
        let s_836_0: bool = false;
        // D s_836_1: write-var gs#405988 <= s_836_0
        fn_state.gs_405988 = s_836_0;
        // N s_836_2: jump b837
        return block_837(state, tracer, fn_state);
    }
    fn block_837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_837_0: read-var gs#405988:u8
        let s_837_0: bool = fn_state.gs_405988;
        // D s_837_1: not s_837_0
        let s_837_1: bool = !s_837_0;
        // N s_837_2: branch s_837_1 b839 b838
        if s_837_1 {
            return block_839(state, tracer, fn_state);
        } else {
            return block_838(state, tracer, fn_state);
        };
    }
    fn block_838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_838_0: const #3043s : i
        let s_838_0: i128 = 3043;
        // C s_838_1: const #14696u : u32
        let s_838_1: u32 = 14696;
        // N s_838_2: write-reg s_838_1 <= s_838_0
        let s_838_2: () = {
            state.write_register::<i128>(s_838_1 as isize, s_838_0);
            tracer.write_register(s_838_1 as isize, s_838_0);
        };
        // C s_838_3: const #28s : i
        let s_838_3: i128 = 28;
        // C s_838_4: const #4s : i
        let s_838_4: i128 = 4;
        // D s_838_5: read-var u#32781:u32
        let s_838_5: u32 = fn_state.u_32781;
        // D s_838_6: cast zx s_838_5 -> bv
        let s_838_6: Bits = Bits::new(s_838_5 as u128, 32u16);
        // D s_838_7: bit-extract s_838_6 s_838_3 s_838_4
        let s_838_7: Bits = (Bits::new(
            ((s_838_6) >> (s_838_3)).value(),
            u16::try_from(s_838_4).unwrap(),
        ));
        // D s_838_8: cast reint s_838_7 -> u8
        let s_838_8: u8 = (s_838_7.value() as u8);
        // C s_838_9: const #20s : i
        let s_838_9: i128 = 20;
        // C s_838_10: const #1s : i
        let s_838_10: i128 = 1;
        // D s_838_11: read-var u#32781:u32
        let s_838_11: u32 = fn_state.u_32781;
        // D s_838_12: cast zx s_838_11 -> bv
        let s_838_12: Bits = Bits::new(s_838_11 as u128, 32u16);
        // D s_838_13: bit-extract s_838_12 s_838_9 s_838_10
        let s_838_13: Bits = (Bits::new(
            ((s_838_12) >> (s_838_9)).value(),
            u16::try_from(s_838_10).unwrap(),
        ));
        // D s_838_14: cast reint s_838_13 -> u8
        let s_838_14: bool = ((s_838_13.value()) != 0);
        // C s_838_15: const #16s : i
        let s_838_15: i128 = 16;
        // C s_838_16: const #4s : i
        let s_838_16: i128 = 4;
        // D s_838_17: read-var u#32781:u32
        let s_838_17: u32 = fn_state.u_32781;
        // D s_838_18: cast zx s_838_17 -> bv
        let s_838_18: Bits = Bits::new(s_838_17 as u128, 32u16);
        // D s_838_19: bit-extract s_838_18 s_838_15 s_838_16
        let s_838_19: Bits = (Bits::new(
            ((s_838_18) >> (s_838_15)).value(),
            u16::try_from(s_838_16).unwrap(),
        ));
        // D s_838_20: cast reint s_838_19 -> u8
        let s_838_20: u8 = (s_838_19.value() as u8);
        // C s_838_21: const #12s : i
        let s_838_21: i128 = 12;
        // C s_838_22: const #4s : i
        let s_838_22: i128 = 4;
        // D s_838_23: read-var u#32781:u32
        let s_838_23: u32 = fn_state.u_32781;
        // D s_838_24: cast zx s_838_23 -> bv
        let s_838_24: Bits = Bits::new(s_838_23 as u128, 32u16);
        // D s_838_25: bit-extract s_838_24 s_838_21 s_838_22
        let s_838_25: Bits = (Bits::new(
            ((s_838_24) >> (s_838_21)).value(),
            u16::try_from(s_838_22).unwrap(),
        ));
        // D s_838_26: cast reint s_838_25 -> u8
        let s_838_26: u8 = (s_838_25.value() as u8);
        // C s_838_27: const #7s : i
        let s_838_27: i128 = 7;
        // C s_838_28: const #5s : i
        let s_838_28: i128 = 5;
        // D s_838_29: read-var u#32781:u32
        let s_838_29: u32 = fn_state.u_32781;
        // D s_838_30: cast zx s_838_29 -> bv
        let s_838_30: Bits = Bits::new(s_838_29 as u128, 32u16);
        // D s_838_31: bit-extract s_838_30 s_838_27 s_838_28
        let s_838_31: Bits = (Bits::new(
            ((s_838_30) >> (s_838_27)).value(),
            u16::try_from(s_838_28).unwrap(),
        ));
        // D s_838_32: cast reint s_838_31 -> u8
        let s_838_32: u8 = (s_838_31.value() as u8);
        // C s_838_33: const #5s : i
        let s_838_33: i128 = 5;
        // C s_838_34: const #2s : i
        let s_838_34: i128 = 2;
        // D s_838_35: read-var u#32781:u32
        let s_838_35: u32 = fn_state.u_32781;
        // D s_838_36: cast zx s_838_35 -> bv
        let s_838_36: Bits = Bits::new(s_838_35 as u128, 32u16);
        // D s_838_37: bit-extract s_838_36 s_838_33 s_838_34
        let s_838_37: Bits = (Bits::new(
            ((s_838_36) >> (s_838_33)).value(),
            u16::try_from(s_838_34).unwrap(),
        ));
        // D s_838_38: cast reint s_838_37 -> u8
        let s_838_38: u8 = (s_838_37.value() as u8);
        // C s_838_39: const #0s : i
        let s_838_39: i128 = 0;
        // C s_838_40: const #4s : i
        let s_838_40: i128 = 4;
        // D s_838_41: read-var u#32781:u32
        let s_838_41: u32 = fn_state.u_32781;
        // D s_838_42: cast zx s_838_41 -> bv
        let s_838_42: Bits = Bits::new(s_838_41 as u128, 32u16);
        // D s_838_43: bit-extract s_838_42 s_838_39 s_838_40
        let s_838_43: Bits = (Bits::new(
            ((s_838_42) >> (s_838_39)).value(),
            u16::try_from(s_838_40).unwrap(),
        ));
        // D s_838_44: cast reint s_838_43 -> u8
        let s_838_44: u8 = (s_838_43.value() as u8);
        // D s_838_45: call decode_aarch32_instrs_ORR_r_A1enc_A_txt(s_838_8, s_838_14, s_838_20, s_838_26, s_838_32, s_838_38, s_838_44)
        let s_838_45: () = decode_aarch32_instrs_ORR_r_A1enc_A_txt(
            state,
            tracer,
            s_838_8,
            s_838_14,
            s_838_20,
            s_838_26,
            s_838_32,
            s_838_38,
            s_838_44,
        );
        // N s_838_46: return
        return;
    }
    fn block_839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_839_0: read-var merge#var.1:struct
        let s_839_0: u32 = fn_state.merge_var._1;
        // D s_839_1: write-var u#32790 <= s_839_0
        fn_state.u_32790 = s_839_0;
        // C s_839_2: const #21s : i
        let s_839_2: i128 = 21;
        // D s_839_3: read-var u#32790:u32
        let s_839_3: u32 = fn_state.u_32790;
        // D s_839_4: cast zx s_839_3 -> bv
        let s_839_4: Bits = Bits::new(s_839_3 as u128, 32u16);
        // C s_839_5: const #1s : i64
        let s_839_5: i64 = 1;
        // C s_839_6: cast zx s_839_5 -> i
        let s_839_6: i128 = (i128::try_from(s_839_5).unwrap());
        // C s_839_7: const #6s : i
        let s_839_7: i128 = 6;
        // C s_839_8: add s_839_7 s_839_6
        let s_839_8: i128 = (s_839_7 + s_839_6);
        // D s_839_9: bit-extract s_839_4 s_839_2 s_839_8
        let s_839_9: Bits = (Bits::new(
            ((s_839_4) >> (s_839_2)).value(),
            u16::try_from(s_839_8).unwrap(),
        ));
        // D s_839_10: cast reint s_839_9 -> u8
        let s_839_10: u8 = (s_839_9.value() as u8);
        // D s_839_11: cast zx s_839_10 -> bv
        let s_839_11: Bits = Bits::new(s_839_10 as u128, 7u16);
        // C s_839_12: const #12u : u8
        let s_839_12: u8 = 12;
        // C s_839_13: cast zx s_839_12 -> bv
        let s_839_13: Bits = Bits::new(s_839_12 as u128, 7u16);
        // D s_839_14: cmp-eq s_839_11 s_839_13
        let s_839_14: bool = ((s_839_11) == (s_839_13));
        // N s_839_15: branch s_839_14 b2532 b840
        if s_839_14 {
            return block_2532(state, tracer, fn_state);
        } else {
            return block_840(state, tracer, fn_state);
        };
    }
    fn block_840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_840_0: const #0u : u8
        let s_840_0: bool = false;
        // D s_840_1: write-var gs#406013 <= s_840_0
        fn_state.gs_406013 = s_840_0;
        // N s_840_2: jump b841
        return block_841(state, tracer, fn_state);
    }
    fn block_841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_841_0: read-var gs#406013:u8
        let s_841_0: bool = fn_state.gs_406013;
        // N s_841_1: branch s_841_0 b2528 b842
        if s_841_0 {
            return block_2528(state, tracer, fn_state);
        } else {
            return block_842(state, tracer, fn_state);
        };
    }
    fn block_842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_842_0: const #0u : u8
        let s_842_0: bool = false;
        // D s_842_1: write-var gs#406018 <= s_842_0
        fn_state.gs_406018 = s_842_0;
        // N s_842_2: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_843_0: read-var gs#406018:u8
        let s_843_0: bool = fn_state.gs_406018;
        // D s_843_1: not s_843_0
        let s_843_1: bool = !s_843_0;
        // N s_843_2: branch s_843_1 b845 b844
        if s_843_1 {
            return block_845(state, tracer, fn_state);
        } else {
            return block_844(state, tracer, fn_state);
        };
    }
    fn block_844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_844_0: const #3046s : i
        let s_844_0: i128 = 3046;
        // C s_844_1: const #14696u : u32
        let s_844_1: u32 = 14696;
        // N s_844_2: write-reg s_844_1 <= s_844_0
        let s_844_2: () = {
            state.write_register::<i128>(s_844_1 as isize, s_844_0);
            tracer.write_register(s_844_1 as isize, s_844_0);
        };
        // C s_844_3: const #28s : i
        let s_844_3: i128 = 28;
        // C s_844_4: const #4s : i
        let s_844_4: i128 = 4;
        // D s_844_5: read-var u#32790:u32
        let s_844_5: u32 = fn_state.u_32790;
        // D s_844_6: cast zx s_844_5 -> bv
        let s_844_6: Bits = Bits::new(s_844_5 as u128, 32u16);
        // D s_844_7: bit-extract s_844_6 s_844_3 s_844_4
        let s_844_7: Bits = (Bits::new(
            ((s_844_6) >> (s_844_3)).value(),
            u16::try_from(s_844_4).unwrap(),
        ));
        // D s_844_8: cast reint s_844_7 -> u8
        let s_844_8: u8 = (s_844_7.value() as u8);
        // C s_844_9: const #20s : i
        let s_844_9: i128 = 20;
        // C s_844_10: const #1s : i
        let s_844_10: i128 = 1;
        // D s_844_11: read-var u#32790:u32
        let s_844_11: u32 = fn_state.u_32790;
        // D s_844_12: cast zx s_844_11 -> bv
        let s_844_12: Bits = Bits::new(s_844_11 as u128, 32u16);
        // D s_844_13: bit-extract s_844_12 s_844_9 s_844_10
        let s_844_13: Bits = (Bits::new(
            ((s_844_12) >> (s_844_9)).value(),
            u16::try_from(s_844_10).unwrap(),
        ));
        // D s_844_14: cast reint s_844_13 -> u8
        let s_844_14: bool = ((s_844_13.value()) != 0);
        // C s_844_15: const #16s : i
        let s_844_15: i128 = 16;
        // C s_844_16: const #4s : i
        let s_844_16: i128 = 4;
        // D s_844_17: read-var u#32790:u32
        let s_844_17: u32 = fn_state.u_32790;
        // D s_844_18: cast zx s_844_17 -> bv
        let s_844_18: Bits = Bits::new(s_844_17 as u128, 32u16);
        // D s_844_19: bit-extract s_844_18 s_844_15 s_844_16
        let s_844_19: Bits = (Bits::new(
            ((s_844_18) >> (s_844_15)).value(),
            u16::try_from(s_844_16).unwrap(),
        ));
        // D s_844_20: cast reint s_844_19 -> u8
        let s_844_20: u8 = (s_844_19.value() as u8);
        // C s_844_21: const #12s : i
        let s_844_21: i128 = 12;
        // C s_844_22: const #4s : i
        let s_844_22: i128 = 4;
        // D s_844_23: read-var u#32790:u32
        let s_844_23: u32 = fn_state.u_32790;
        // D s_844_24: cast zx s_844_23 -> bv
        let s_844_24: Bits = Bits::new(s_844_23 as u128, 32u16);
        // D s_844_25: bit-extract s_844_24 s_844_21 s_844_22
        let s_844_25: Bits = (Bits::new(
            ((s_844_24) >> (s_844_21)).value(),
            u16::try_from(s_844_22).unwrap(),
        ));
        // D s_844_26: cast reint s_844_25 -> u8
        let s_844_26: u8 = (s_844_25.value() as u8);
        // C s_844_27: const #8s : i
        let s_844_27: i128 = 8;
        // C s_844_28: const #4s : i
        let s_844_28: i128 = 4;
        // D s_844_29: read-var u#32790:u32
        let s_844_29: u32 = fn_state.u_32790;
        // D s_844_30: cast zx s_844_29 -> bv
        let s_844_30: Bits = Bits::new(s_844_29 as u128, 32u16);
        // D s_844_31: bit-extract s_844_30 s_844_27 s_844_28
        let s_844_31: Bits = (Bits::new(
            ((s_844_30) >> (s_844_27)).value(),
            u16::try_from(s_844_28).unwrap(),
        ));
        // D s_844_32: cast reint s_844_31 -> u8
        let s_844_32: u8 = (s_844_31.value() as u8);
        // C s_844_33: const #5s : i
        let s_844_33: i128 = 5;
        // C s_844_34: const #2s : i
        let s_844_34: i128 = 2;
        // D s_844_35: read-var u#32790:u32
        let s_844_35: u32 = fn_state.u_32790;
        // D s_844_36: cast zx s_844_35 -> bv
        let s_844_36: Bits = Bits::new(s_844_35 as u128, 32u16);
        // D s_844_37: bit-extract s_844_36 s_844_33 s_844_34
        let s_844_37: Bits = (Bits::new(
            ((s_844_36) >> (s_844_33)).value(),
            u16::try_from(s_844_34).unwrap(),
        ));
        // D s_844_38: cast reint s_844_37 -> u8
        let s_844_38: u8 = (s_844_37.value() as u8);
        // C s_844_39: const #0s : i
        let s_844_39: i128 = 0;
        // C s_844_40: const #4s : i
        let s_844_40: i128 = 4;
        // D s_844_41: read-var u#32790:u32
        let s_844_41: u32 = fn_state.u_32790;
        // D s_844_42: cast zx s_844_41 -> bv
        let s_844_42: Bits = Bits::new(s_844_41 as u128, 32u16);
        // D s_844_43: bit-extract s_844_42 s_844_39 s_844_40
        let s_844_43: Bits = (Bits::new(
            ((s_844_42) >> (s_844_39)).value(),
            u16::try_from(s_844_40).unwrap(),
        ));
        // D s_844_44: cast reint s_844_43 -> u8
        let s_844_44: u8 = (s_844_43.value() as u8);
        // D s_844_45: call decode_aarch32_instrs_ORR_rr_A1enc_A_txt(s_844_8, s_844_14, s_844_20, s_844_26, s_844_32, s_844_38, s_844_44)
        let s_844_45: () = decode_aarch32_instrs_ORR_rr_A1enc_A_txt(
            state,
            tracer,
            s_844_8,
            s_844_14,
            s_844_20,
            s_844_26,
            s_844_32,
            s_844_38,
            s_844_44,
        );
        // N s_844_46: return
        return;
    }
    fn block_845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_845_0: read-var merge#var.1:struct
        let s_845_0: u32 = fn_state.merge_var._1;
        // D s_845_1: write-var u#32799 <= s_845_0
        fn_state.u_32799 = s_845_0;
        // C s_845_2: const #20s : i
        let s_845_2: i128 = 20;
        // D s_845_3: read-var u#32799:u32
        let s_845_3: u32 = fn_state.u_32799;
        // D s_845_4: cast zx s_845_3 -> bv
        let s_845_4: Bits = Bits::new(s_845_3 as u128, 32u16);
        // C s_845_5: const #1s : i64
        let s_845_5: i64 = 1;
        // C s_845_6: cast zx s_845_5 -> i
        let s_845_6: i128 = (i128::try_from(s_845_5).unwrap());
        // C s_845_7: const #7s : i
        let s_845_7: i128 = 7;
        // C s_845_8: add s_845_7 s_845_6
        let s_845_8: i128 = (s_845_7 + s_845_6);
        // D s_845_9: bit-extract s_845_4 s_845_2 s_845_8
        let s_845_9: Bits = (Bits::new(
            ((s_845_4) >> (s_845_2)).value(),
            u16::try_from(s_845_8).unwrap(),
        ));
        // D s_845_10: cast reint s_845_9 -> u8
        let s_845_10: u8 = (s_845_9.value() as u8);
        // D s_845_11: cast zx s_845_10 -> bv
        let s_845_11: Bits = Bits::new(s_845_10 as u128, 8u16);
        // C s_845_12: const #16u : u8
        let s_845_12: u8 = 16;
        // C s_845_13: cast zx s_845_12 -> bv
        let s_845_13: Bits = Bits::new(s_845_12 as u128, 8u16);
        // D s_845_14: cmp-eq s_845_11 s_845_13
        let s_845_14: bool = ((s_845_11) == (s_845_13));
        // N s_845_15: branch s_845_14 b2527 b846
        if s_845_14 {
            return block_2527(state, tracer, fn_state);
        } else {
            return block_846(state, tracer, fn_state);
        };
    }
    fn block_846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_846_0: const #0u : u8
        let s_846_0: bool = false;
        // D s_846_1: write-var gs#406040 <= s_846_0
        fn_state.gs_406040 = s_846_0;
        // N s_846_2: jump b847
        return block_847(state, tracer, fn_state);
    }
    fn block_847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_847_0: read-var gs#406040:u8
        let s_847_0: bool = fn_state.gs_406040;
        // N s_847_1: branch s_847_0 b2523 b848
        if s_847_0 {
            return block_2523(state, tracer, fn_state);
        } else {
            return block_848(state, tracer, fn_state);
        };
    }
    fn block_848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_848_0: const #0u : u8
        let s_848_0: bool = false;
        // D s_848_1: write-var gs#406045 <= s_848_0
        fn_state.gs_406045 = s_848_0;
        // N s_848_2: jump b849
        return block_849(state, tracer, fn_state);
    }
    fn block_849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_849_0: read-var gs#406045:u8
        let s_849_0: bool = fn_state.gs_406045;
        // D s_849_1: not s_849_0
        let s_849_1: bool = !s_849_0;
        // N s_849_2: branch s_849_1 b862 b850
        if s_849_1 {
            return block_862(state, tracer, fn_state);
        } else {
            return block_850(state, tracer, fn_state);
        };
    }
    fn block_850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_850_0: const #3068s : i
        let s_850_0: i128 = 3068;
        // C s_850_1: const #14696u : u32
        let s_850_1: u32 = 14696;
        // N s_850_2: write-reg s_850_1 <= s_850_0
        let s_850_2: () = {
            state.write_register::<i128>(s_850_1 as isize, s_850_0);
            tracer.write_register(s_850_1 as isize, s_850_0);
        };
        // C s_850_3: const #28s : i
        let s_850_3: i128 = 28;
        // C s_850_4: const #4s : i
        let s_850_4: i128 = 4;
        // D s_850_5: read-var u#32799:u32
        let s_850_5: u32 = fn_state.u_32799;
        // D s_850_6: cast zx s_850_5 -> bv
        let s_850_6: Bits = Bits::new(s_850_5 as u128, 32u16);
        // D s_850_7: bit-extract s_850_6 s_850_3 s_850_4
        let s_850_7: Bits = (Bits::new(
            ((s_850_6) >> (s_850_3)).value(),
            u16::try_from(s_850_4).unwrap(),
        ));
        // D s_850_8: cast reint s_850_7 -> u8
        let s_850_8: u8 = (s_850_7.value() as u8);
        // D s_850_9: write-var u#32800 <= s_850_8
        fn_state.u_32800 = s_850_8;
        // C s_850_10: const #16s : i
        let s_850_10: i128 = 16;
        // C s_850_11: const #4s : i
        let s_850_11: i128 = 4;
        // D s_850_12: read-var u#32799:u32
        let s_850_12: u32 = fn_state.u_32799;
        // D s_850_13: cast zx s_850_12 -> bv
        let s_850_13: Bits = Bits::new(s_850_12 as u128, 32u16);
        // D s_850_14: bit-extract s_850_13 s_850_10 s_850_11
        let s_850_14: Bits = (Bits::new(
            ((s_850_13) >> (s_850_10)).value(),
            u16::try_from(s_850_11).unwrap(),
        ));
        // D s_850_15: cast reint s_850_14 -> u8
        let s_850_15: u8 = (s_850_14.value() as u8);
        // D s_850_16: write-var u#32801 <= s_850_15
        fn_state.u_32801 = s_850_15;
        // C s_850_17: const #12s : i
        let s_850_17: i128 = 12;
        // C s_850_18: const #4s : i
        let s_850_18: i128 = 4;
        // D s_850_19: read-var u#32799:u32
        let s_850_19: u32 = fn_state.u_32799;
        // D s_850_20: cast zx s_850_19 -> bv
        let s_850_20: Bits = Bits::new(s_850_19 as u128, 32u16);
        // D s_850_21: bit-extract s_850_20 s_850_17 s_850_18
        let s_850_21: Bits = (Bits::new(
            ((s_850_20) >> (s_850_17)).value(),
            u16::try_from(s_850_18).unwrap(),
        ));
        // D s_850_22: cast reint s_850_21 -> u8
        let s_850_22: u8 = (s_850_21.value() as u8);
        // D s_850_23: write-var u#32802 <= s_850_22
        fn_state.u_32802 = s_850_22;
        // C s_850_24: const #0s : i
        let s_850_24: i128 = 0;
        // C s_850_25: const #4s : i
        let s_850_25: i128 = 4;
        // D s_850_26: read-var u#32799:u32
        let s_850_26: u32 = fn_state.u_32799;
        // D s_850_27: cast zx s_850_26 -> bv
        let s_850_27: Bits = Bits::new(s_850_26 as u128, 32u16);
        // D s_850_28: bit-extract s_850_27 s_850_24 s_850_25
        let s_850_28: Bits = (Bits::new(
            ((s_850_27) >> (s_850_24)).value(),
            u16::try_from(s_850_25).unwrap(),
        ));
        // D s_850_29: cast reint s_850_28 -> u8
        let s_850_29: u8 = (s_850_28.value() as u8);
        // D s_850_30: write-var u#32803 <= s_850_29
        fn_state.u_32803 = s_850_29;
        // C s_850_31: const #8s : i
        let s_850_31: i128 = 8;
        // D s_850_32: read-var u#32799:u32
        let s_850_32: u32 = fn_state.u_32799;
        // D s_850_33: cast zx s_850_32 -> bv
        let s_850_33: Bits = Bits::new(s_850_32 as u128, 32u16);
        // C s_850_34: const #1u : u64
        let s_850_34: u64 = 1;
        // D s_850_35: bit-extract s_850_33 s_850_31 s_850_34
        let s_850_35: Bits = (Bits::new(
            ((s_850_33) >> (s_850_31)).value(),
            u16::try_from(s_850_34).unwrap(),
        ));
        // D s_850_36: cast reint s_850_35 -> u8
        let s_850_36: bool = ((s_850_35.value()) != 0);
        // C s_850_37: const #0s : i
        let s_850_37: i128 = 0;
        // C s_850_38: const #0u : u64
        let s_850_38: u64 = 0;
        // D s_850_39: cast zx s_850_36 -> u64
        let s_850_39: u64 = (s_850_36 as u64);
        // C s_850_40: const #1u : u64
        let s_850_40: u64 = 1;
        // D s_850_41: and s_850_39 s_850_40
        let s_850_41: u64 = ((s_850_39) & (s_850_40));
        // D s_850_42: cmp-eq s_850_41 s_850_40
        let s_850_42: bool = ((s_850_41) == (s_850_40));
        // D s_850_43: lsl s_850_39 s_850_37
        let s_850_43: u64 = s_850_39 << s_850_37;
        // D s_850_44: or s_850_38 s_850_43
        let s_850_44: u64 = ((s_850_38) | (s_850_43));
        // D s_850_45: cmpl s_850_43
        let s_850_45: u64 = !s_850_43;
        // D s_850_46: and s_850_38 s_850_45
        let s_850_46: u64 = ((s_850_38) & (s_850_45));
        // D s_850_47: select s_850_42 s_850_44 s_850_46
        let s_850_47: u64 = if s_850_42 { s_850_44 } else { s_850_46 };
        // D s_850_48: cast trunc s_850_47 -> u8
        let s_850_48: bool = ((s_850_47) != 0);
        // D s_850_49: cast zx s_850_48 -> bv
        let s_850_49: Bits = Bits::new(s_850_48 as u128, 1u16);
        // C s_850_50: const #0u : u8
        let s_850_50: bool = false;
        // C s_850_51: cast zx s_850_50 -> bv
        let s_850_51: Bits = Bits::new(s_850_50 as u128, 1u16);
        // D s_850_52: cmp-ne s_850_49 s_850_51
        let s_850_52: bool = ((s_850_49) != (s_850_51));
        // N s_850_53: branch s_850_52 b861 b851
        if s_850_52 {
            return block_861(state, tracer, fn_state);
        } else {
            return block_851(state, tracer, fn_state);
        };
    }
    fn block_851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_851_0: const #9s : i
        let s_851_0: i128 = 9;
        // D s_851_1: read-var u#32799:u32
        let s_851_1: u32 = fn_state.u_32799;
        // D s_851_2: cast zx s_851_1 -> bv
        let s_851_2: Bits = Bits::new(s_851_1 as u128, 32u16);
        // C s_851_3: const #1u : u64
        let s_851_3: u64 = 1;
        // D s_851_4: bit-extract s_851_2 s_851_0 s_851_3
        let s_851_4: Bits = (Bits::new(
            ((s_851_2) >> (s_851_0)).value(),
            u16::try_from(s_851_3).unwrap(),
        ));
        // D s_851_5: cast reint s_851_4 -> u8
        let s_851_5: bool = ((s_851_4.value()) != 0);
        // C s_851_6: const #0s : i
        let s_851_6: i128 = 0;
        // C s_851_7: const #0u : u64
        let s_851_7: u64 = 0;
        // D s_851_8: cast zx s_851_5 -> u64
        let s_851_8: u64 = (s_851_5 as u64);
        // C s_851_9: const #1u : u64
        let s_851_9: u64 = 1;
        // D s_851_10: and s_851_8 s_851_9
        let s_851_10: u64 = ((s_851_8) & (s_851_9));
        // D s_851_11: cmp-eq s_851_10 s_851_9
        let s_851_11: bool = ((s_851_10) == (s_851_9));
        // D s_851_12: lsl s_851_8 s_851_6
        let s_851_12: u64 = s_851_8 << s_851_6;
        // D s_851_13: or s_851_7 s_851_12
        let s_851_13: u64 = ((s_851_7) | (s_851_12));
        // D s_851_14: cmpl s_851_12
        let s_851_14: u64 = !s_851_12;
        // D s_851_15: and s_851_7 s_851_14
        let s_851_15: u64 = ((s_851_7) & (s_851_14));
        // D s_851_16: select s_851_11 s_851_13 s_851_15
        let s_851_16: u64 = if s_851_11 { s_851_13 } else { s_851_15 };
        // D s_851_17: cast trunc s_851_16 -> u8
        let s_851_17: bool = ((s_851_16) != 0);
        // D s_851_18: cast zx s_851_17 -> bv
        let s_851_18: Bits = Bits::new(s_851_17 as u128, 1u16);
        // C s_851_19: const #0u : u8
        let s_851_19: bool = false;
        // C s_851_20: cast zx s_851_19 -> bv
        let s_851_20: Bits = Bits::new(s_851_19 as u128, 1u16);
        // D s_851_21: cmp-ne s_851_18 s_851_20
        let s_851_21: bool = ((s_851_18) != (s_851_20));
        // D s_851_22: write-var gs#406060 <= s_851_21
        fn_state.gs_406060 = s_851_21;
        // N s_851_23: jump b852
        return block_852(state, tracer, fn_state);
    }
    fn block_852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_852_0: read-var gs#406060:u8
        let s_852_0: bool = fn_state.gs_406060;
        // N s_852_1: branch s_852_0 b860 b853
        if s_852_0 {
            return block_860(state, tracer, fn_state);
        } else {
            return block_853(state, tracer, fn_state);
        };
    }
    fn block_853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_853_0: const #10s : i
        let s_853_0: i128 = 10;
        // D s_853_1: read-var u#32799:u32
        let s_853_1: u32 = fn_state.u_32799;
        // D s_853_2: cast zx s_853_1 -> bv
        let s_853_2: Bits = Bits::new(s_853_1 as u128, 32u16);
        // C s_853_3: const #1u : u64
        let s_853_3: u64 = 1;
        // D s_853_4: bit-extract s_853_2 s_853_0 s_853_3
        let s_853_4: Bits = (Bits::new(
            ((s_853_2) >> (s_853_0)).value(),
            u16::try_from(s_853_3).unwrap(),
        ));
        // D s_853_5: cast reint s_853_4 -> u8
        let s_853_5: bool = ((s_853_4.value()) != 0);
        // C s_853_6: const #0s : i
        let s_853_6: i128 = 0;
        // C s_853_7: const #0u : u64
        let s_853_7: u64 = 0;
        // D s_853_8: cast zx s_853_5 -> u64
        let s_853_8: u64 = (s_853_5 as u64);
        // C s_853_9: const #1u : u64
        let s_853_9: u64 = 1;
        // D s_853_10: and s_853_8 s_853_9
        let s_853_10: u64 = ((s_853_8) & (s_853_9));
        // D s_853_11: cmp-eq s_853_10 s_853_9
        let s_853_11: bool = ((s_853_10) == (s_853_9));
        // D s_853_12: lsl s_853_8 s_853_6
        let s_853_12: u64 = s_853_8 << s_853_6;
        // D s_853_13: or s_853_7 s_853_12
        let s_853_13: u64 = ((s_853_7) | (s_853_12));
        // D s_853_14: cmpl s_853_12
        let s_853_14: u64 = !s_853_12;
        // D s_853_15: and s_853_7 s_853_14
        let s_853_15: u64 = ((s_853_7) & (s_853_14));
        // D s_853_16: select s_853_11 s_853_13 s_853_15
        let s_853_16: u64 = if s_853_11 { s_853_13 } else { s_853_15 };
        // D s_853_17: cast trunc s_853_16 -> u8
        let s_853_17: bool = ((s_853_16) != 0);
        // D s_853_18: cast zx s_853_17 -> bv
        let s_853_18: Bits = Bits::new(s_853_17 as u128, 1u16);
        // C s_853_19: const #0u : u8
        let s_853_19: bool = false;
        // C s_853_20: cast zx s_853_19 -> bv
        let s_853_20: Bits = Bits::new(s_853_19 as u128, 1u16);
        // D s_853_21: cmp-ne s_853_18 s_853_20
        let s_853_21: bool = ((s_853_18) != (s_853_20));
        // D s_853_22: write-var gs#406063 <= s_853_21
        fn_state.gs_406063 = s_853_21;
        // N s_853_23: jump b854
        return block_854(state, tracer, fn_state);
    }
    fn block_854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_854_0: read-var gs#406063:u8
        let s_854_0: bool = fn_state.gs_406063;
        // N s_854_1: branch s_854_0 b859 b855
        if s_854_0 {
            return block_859(state, tracer, fn_state);
        } else {
            return block_855(state, tracer, fn_state);
        };
    }
    fn block_855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_855_0: const #11s : i
        let s_855_0: i128 = 11;
        // D s_855_1: read-var u#32799:u32
        let s_855_1: u32 = fn_state.u_32799;
        // D s_855_2: cast zx s_855_1 -> bv
        let s_855_2: Bits = Bits::new(s_855_1 as u128, 32u16);
        // C s_855_3: const #1u : u64
        let s_855_3: u64 = 1;
        // D s_855_4: bit-extract s_855_2 s_855_0 s_855_3
        let s_855_4: Bits = (Bits::new(
            ((s_855_2) >> (s_855_0)).value(),
            u16::try_from(s_855_3).unwrap(),
        ));
        // D s_855_5: cast reint s_855_4 -> u8
        let s_855_5: bool = ((s_855_4.value()) != 0);
        // C s_855_6: const #0s : i
        let s_855_6: i128 = 0;
        // C s_855_7: const #0u : u64
        let s_855_7: u64 = 0;
        // D s_855_8: cast zx s_855_5 -> u64
        let s_855_8: u64 = (s_855_5 as u64);
        // C s_855_9: const #1u : u64
        let s_855_9: u64 = 1;
        // D s_855_10: and s_855_8 s_855_9
        let s_855_10: u64 = ((s_855_8) & (s_855_9));
        // D s_855_11: cmp-eq s_855_10 s_855_9
        let s_855_11: bool = ((s_855_10) == (s_855_9));
        // D s_855_12: lsl s_855_8 s_855_6
        let s_855_12: u64 = s_855_8 << s_855_6;
        // D s_855_13: or s_855_7 s_855_12
        let s_855_13: u64 = ((s_855_7) | (s_855_12));
        // D s_855_14: cmpl s_855_12
        let s_855_14: u64 = !s_855_12;
        // D s_855_15: and s_855_7 s_855_14
        let s_855_15: u64 = ((s_855_7) & (s_855_14));
        // D s_855_16: select s_855_11 s_855_13 s_855_15
        let s_855_16: u64 = if s_855_11 { s_855_13 } else { s_855_15 };
        // D s_855_17: cast trunc s_855_16 -> u8
        let s_855_17: bool = ((s_855_16) != 0);
        // D s_855_18: cast zx s_855_17 -> bv
        let s_855_18: Bits = Bits::new(s_855_17 as u128, 1u16);
        // C s_855_19: const #0u : u8
        let s_855_19: bool = false;
        // C s_855_20: cast zx s_855_19 -> bv
        let s_855_20: Bits = Bits::new(s_855_19 as u128, 1u16);
        // D s_855_21: cmp-ne s_855_18 s_855_20
        let s_855_21: bool = ((s_855_18) != (s_855_20));
        // D s_855_22: write-var gs#406066 <= s_855_21
        fn_state.gs_406066 = s_855_21;
        // N s_855_23: jump b856
        return block_856(state, tracer, fn_state);
    }
    fn block_856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_856_0: read-var gs#406066:u8
        let s_856_0: bool = fn_state.gs_406066;
        // N s_856_1: branch s_856_0 b858 b857
        if s_856_0 {
            return block_858(state, tracer, fn_state);
        } else {
            return block_857(state, tracer, fn_state);
        };
    }
    fn block_857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_857_0: read-var u#32800:u8
        let s_857_0: u8 = fn_state.u_32800;
        // D s_857_1: read-var u#32801:u8
        let s_857_1: u8 = fn_state.u_32801;
        // D s_857_2: read-var u#32802:u8
        let s_857_2: u8 = fn_state.u_32802;
        // D s_857_3: read-var u#32803:u8
        let s_857_3: u8 = fn_state.u_32803;
        // D s_857_4: call decode_aarch32_instrs_QADD_A1enc_A_txt(s_857_0, s_857_1, s_857_2, s_857_3)
        let s_857_4: () = decode_aarch32_instrs_QADD_A1enc_A_txt(
            state,
            tracer,
            s_857_0,
            s_857_1,
            s_857_2,
            s_857_3,
        );
        // N s_857_5: return
        return;
    }
    fn block_858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_858_0: panic
        panic!("{:?}", ());
        // N s_858_1: return
        return;
    }
    fn block_859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_859_0: const #1u : u8
        let s_859_0: bool = true;
        // D s_859_1: write-var gs#406066 <= s_859_0
        fn_state.gs_406066 = s_859_0;
        // N s_859_2: jump b856
        return block_856(state, tracer, fn_state);
    }
    fn block_860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_860_0: const #1u : u8
        let s_860_0: bool = true;
        // D s_860_1: write-var gs#406063 <= s_860_0
        fn_state.gs_406063 = s_860_0;
        // N s_860_2: jump b854
        return block_854(state, tracer, fn_state);
    }
    fn block_861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_861_0: const #1u : u8
        let s_861_0: bool = true;
        // D s_861_1: write-var gs#406060 <= s_861_0
        fn_state.gs_406060 = s_861_0;
        // N s_861_2: jump b852
        return block_852(state, tracer, fn_state);
    }
    fn block_862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_862_0: read-var merge#var.1:struct
        let s_862_0: u32 = fn_state.merge_var._1;
        // D s_862_1: write-var u#32805 <= s_862_0
        fn_state.u_32805 = s_862_0;
        // C s_862_2: const #20s : i
        let s_862_2: i128 = 20;
        // D s_862_3: read-var u#32805:u32
        let s_862_3: u32 = fn_state.u_32805;
        // D s_862_4: cast zx s_862_3 -> bv
        let s_862_4: Bits = Bits::new(s_862_3 as u128, 32u16);
        // C s_862_5: const #1s : i64
        let s_862_5: i64 = 1;
        // C s_862_6: cast zx s_862_5 -> i
        let s_862_6: i128 = (i128::try_from(s_862_5).unwrap());
        // C s_862_7: const #7s : i
        let s_862_7: i128 = 7;
        // C s_862_8: add s_862_7 s_862_6
        let s_862_8: i128 = (s_862_7 + s_862_6);
        // D s_862_9: bit-extract s_862_4 s_862_2 s_862_8
        let s_862_9: Bits = (Bits::new(
            ((s_862_4) >> (s_862_2)).value(),
            u16::try_from(s_862_8).unwrap(),
        ));
        // D s_862_10: cast reint s_862_9 -> u8
        let s_862_10: u8 = (s_862_9.value() as u8);
        // D s_862_11: cast zx s_862_10 -> bv
        let s_862_11: Bits = Bits::new(s_862_10 as u128, 8u16);
        // C s_862_12: const #20u : u8
        let s_862_12: u8 = 20;
        // C s_862_13: cast zx s_862_12 -> bv
        let s_862_13: Bits = Bits::new(s_862_12 as u128, 8u16);
        // D s_862_14: cmp-eq s_862_11 s_862_13
        let s_862_14: bool = ((s_862_11) == (s_862_13));
        // N s_862_15: branch s_862_14 b2522 b863
        if s_862_14 {
            return block_2522(state, tracer, fn_state);
        } else {
            return block_863(state, tracer, fn_state);
        };
    }
    fn block_863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_863_0: const #0u : u8
        let s_863_0: bool = false;
        // D s_863_1: write-var gs#406072 <= s_863_0
        fn_state.gs_406072 = s_863_0;
        // N s_863_2: jump b864
        return block_864(state, tracer, fn_state);
    }
    fn block_864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_864_0: read-var gs#406072:u8
        let s_864_0: bool = fn_state.gs_406072;
        // N s_864_1: branch s_864_0 b2518 b865
        if s_864_0 {
            return block_2518(state, tracer, fn_state);
        } else {
            return block_865(state, tracer, fn_state);
        };
    }
    fn block_865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_865_0: const #0u : u8
        let s_865_0: bool = false;
        // D s_865_1: write-var gs#406077 <= s_865_0
        fn_state.gs_406077 = s_865_0;
        // N s_865_2: jump b866
        return block_866(state, tracer, fn_state);
    }
    fn block_866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_866_0: read-var gs#406077:u8
        let s_866_0: bool = fn_state.gs_406077;
        // D s_866_1: not s_866_0
        let s_866_1: bool = !s_866_0;
        // N s_866_2: branch s_866_1 b879 b867
        if s_866_1 {
            return block_879(state, tracer, fn_state);
        } else {
            return block_867(state, tracer, fn_state);
        };
    }
    fn block_867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_867_0: const #3072s : i
        let s_867_0: i128 = 3072;
        // C s_867_1: const #14696u : u32
        let s_867_1: u32 = 14696;
        // N s_867_2: write-reg s_867_1 <= s_867_0
        let s_867_2: () = {
            state.write_register::<i128>(s_867_1 as isize, s_867_0);
            tracer.write_register(s_867_1 as isize, s_867_0);
        };
        // C s_867_3: const #28s : i
        let s_867_3: i128 = 28;
        // C s_867_4: const #4s : i
        let s_867_4: i128 = 4;
        // D s_867_5: read-var u#32805:u32
        let s_867_5: u32 = fn_state.u_32805;
        // D s_867_6: cast zx s_867_5 -> bv
        let s_867_6: Bits = Bits::new(s_867_5 as u128, 32u16);
        // D s_867_7: bit-extract s_867_6 s_867_3 s_867_4
        let s_867_7: Bits = (Bits::new(
            ((s_867_6) >> (s_867_3)).value(),
            u16::try_from(s_867_4).unwrap(),
        ));
        // D s_867_8: cast reint s_867_7 -> u8
        let s_867_8: u8 = (s_867_7.value() as u8);
        // D s_867_9: write-var u#32806 <= s_867_8
        fn_state.u_32806 = s_867_8;
        // C s_867_10: const #16s : i
        let s_867_10: i128 = 16;
        // C s_867_11: const #4s : i
        let s_867_11: i128 = 4;
        // D s_867_12: read-var u#32805:u32
        let s_867_12: u32 = fn_state.u_32805;
        // D s_867_13: cast zx s_867_12 -> bv
        let s_867_13: Bits = Bits::new(s_867_12 as u128, 32u16);
        // D s_867_14: bit-extract s_867_13 s_867_10 s_867_11
        let s_867_14: Bits = (Bits::new(
            ((s_867_13) >> (s_867_10)).value(),
            u16::try_from(s_867_11).unwrap(),
        ));
        // D s_867_15: cast reint s_867_14 -> u8
        let s_867_15: u8 = (s_867_14.value() as u8);
        // D s_867_16: write-var u#32807 <= s_867_15
        fn_state.u_32807 = s_867_15;
        // C s_867_17: const #12s : i
        let s_867_17: i128 = 12;
        // C s_867_18: const #4s : i
        let s_867_18: i128 = 4;
        // D s_867_19: read-var u#32805:u32
        let s_867_19: u32 = fn_state.u_32805;
        // D s_867_20: cast zx s_867_19 -> bv
        let s_867_20: Bits = Bits::new(s_867_19 as u128, 32u16);
        // D s_867_21: bit-extract s_867_20 s_867_17 s_867_18
        let s_867_21: Bits = (Bits::new(
            ((s_867_20) >> (s_867_17)).value(),
            u16::try_from(s_867_18).unwrap(),
        ));
        // D s_867_22: cast reint s_867_21 -> u8
        let s_867_22: u8 = (s_867_21.value() as u8);
        // D s_867_23: write-var u#32808 <= s_867_22
        fn_state.u_32808 = s_867_22;
        // C s_867_24: const #0s : i
        let s_867_24: i128 = 0;
        // C s_867_25: const #4s : i
        let s_867_25: i128 = 4;
        // D s_867_26: read-var u#32805:u32
        let s_867_26: u32 = fn_state.u_32805;
        // D s_867_27: cast zx s_867_26 -> bv
        let s_867_27: Bits = Bits::new(s_867_26 as u128, 32u16);
        // D s_867_28: bit-extract s_867_27 s_867_24 s_867_25
        let s_867_28: Bits = (Bits::new(
            ((s_867_27) >> (s_867_24)).value(),
            u16::try_from(s_867_25).unwrap(),
        ));
        // D s_867_29: cast reint s_867_28 -> u8
        let s_867_29: u8 = (s_867_28.value() as u8);
        // D s_867_30: write-var u#32809 <= s_867_29
        fn_state.u_32809 = s_867_29;
        // C s_867_31: const #8s : i
        let s_867_31: i128 = 8;
        // D s_867_32: read-var u#32805:u32
        let s_867_32: u32 = fn_state.u_32805;
        // D s_867_33: cast zx s_867_32 -> bv
        let s_867_33: Bits = Bits::new(s_867_32 as u128, 32u16);
        // C s_867_34: const #1u : u64
        let s_867_34: u64 = 1;
        // D s_867_35: bit-extract s_867_33 s_867_31 s_867_34
        let s_867_35: Bits = (Bits::new(
            ((s_867_33) >> (s_867_31)).value(),
            u16::try_from(s_867_34).unwrap(),
        ));
        // D s_867_36: cast reint s_867_35 -> u8
        let s_867_36: bool = ((s_867_35.value()) != 0);
        // C s_867_37: const #0s : i
        let s_867_37: i128 = 0;
        // C s_867_38: const #0u : u64
        let s_867_38: u64 = 0;
        // D s_867_39: cast zx s_867_36 -> u64
        let s_867_39: u64 = (s_867_36 as u64);
        // C s_867_40: const #1u : u64
        let s_867_40: u64 = 1;
        // D s_867_41: and s_867_39 s_867_40
        let s_867_41: u64 = ((s_867_39) & (s_867_40));
        // D s_867_42: cmp-eq s_867_41 s_867_40
        let s_867_42: bool = ((s_867_41) == (s_867_40));
        // D s_867_43: lsl s_867_39 s_867_37
        let s_867_43: u64 = s_867_39 << s_867_37;
        // D s_867_44: or s_867_38 s_867_43
        let s_867_44: u64 = ((s_867_38) | (s_867_43));
        // D s_867_45: cmpl s_867_43
        let s_867_45: u64 = !s_867_43;
        // D s_867_46: and s_867_38 s_867_45
        let s_867_46: u64 = ((s_867_38) & (s_867_45));
        // D s_867_47: select s_867_42 s_867_44 s_867_46
        let s_867_47: u64 = if s_867_42 { s_867_44 } else { s_867_46 };
        // D s_867_48: cast trunc s_867_47 -> u8
        let s_867_48: bool = ((s_867_47) != 0);
        // D s_867_49: cast zx s_867_48 -> bv
        let s_867_49: Bits = Bits::new(s_867_48 as u128, 1u16);
        // C s_867_50: const #0u : u8
        let s_867_50: bool = false;
        // C s_867_51: cast zx s_867_50 -> bv
        let s_867_51: Bits = Bits::new(s_867_50 as u128, 1u16);
        // D s_867_52: cmp-ne s_867_49 s_867_51
        let s_867_52: bool = ((s_867_49) != (s_867_51));
        // N s_867_53: branch s_867_52 b878 b868
        if s_867_52 {
            return block_878(state, tracer, fn_state);
        } else {
            return block_868(state, tracer, fn_state);
        };
    }
    fn block_868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_868_0: const #9s : i
        let s_868_0: i128 = 9;
        // D s_868_1: read-var u#32805:u32
        let s_868_1: u32 = fn_state.u_32805;
        // D s_868_2: cast zx s_868_1 -> bv
        let s_868_2: Bits = Bits::new(s_868_1 as u128, 32u16);
        // C s_868_3: const #1u : u64
        let s_868_3: u64 = 1;
        // D s_868_4: bit-extract s_868_2 s_868_0 s_868_3
        let s_868_4: Bits = (Bits::new(
            ((s_868_2) >> (s_868_0)).value(),
            u16::try_from(s_868_3).unwrap(),
        ));
        // D s_868_5: cast reint s_868_4 -> u8
        let s_868_5: bool = ((s_868_4.value()) != 0);
        // C s_868_6: const #0s : i
        let s_868_6: i128 = 0;
        // C s_868_7: const #0u : u64
        let s_868_7: u64 = 0;
        // D s_868_8: cast zx s_868_5 -> u64
        let s_868_8: u64 = (s_868_5 as u64);
        // C s_868_9: const #1u : u64
        let s_868_9: u64 = 1;
        // D s_868_10: and s_868_8 s_868_9
        let s_868_10: u64 = ((s_868_8) & (s_868_9));
        // D s_868_11: cmp-eq s_868_10 s_868_9
        let s_868_11: bool = ((s_868_10) == (s_868_9));
        // D s_868_12: lsl s_868_8 s_868_6
        let s_868_12: u64 = s_868_8 << s_868_6;
        // D s_868_13: or s_868_7 s_868_12
        let s_868_13: u64 = ((s_868_7) | (s_868_12));
        // D s_868_14: cmpl s_868_12
        let s_868_14: u64 = !s_868_12;
        // D s_868_15: and s_868_7 s_868_14
        let s_868_15: u64 = ((s_868_7) & (s_868_14));
        // D s_868_16: select s_868_11 s_868_13 s_868_15
        let s_868_16: u64 = if s_868_11 { s_868_13 } else { s_868_15 };
        // D s_868_17: cast trunc s_868_16 -> u8
        let s_868_17: bool = ((s_868_16) != 0);
        // D s_868_18: cast zx s_868_17 -> bv
        let s_868_18: Bits = Bits::new(s_868_17 as u128, 1u16);
        // C s_868_19: const #0u : u8
        let s_868_19: bool = false;
        // C s_868_20: cast zx s_868_19 -> bv
        let s_868_20: Bits = Bits::new(s_868_19 as u128, 1u16);
        // D s_868_21: cmp-ne s_868_18 s_868_20
        let s_868_21: bool = ((s_868_18) != (s_868_20));
        // D s_868_22: write-var gs#406092 <= s_868_21
        fn_state.gs_406092 = s_868_21;
        // N s_868_23: jump b869
        return block_869(state, tracer, fn_state);
    }
    fn block_869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_869_0: read-var gs#406092:u8
        let s_869_0: bool = fn_state.gs_406092;
        // N s_869_1: branch s_869_0 b877 b870
        if s_869_0 {
            return block_877(state, tracer, fn_state);
        } else {
            return block_870(state, tracer, fn_state);
        };
    }
    fn block_870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_870_0: const #10s : i
        let s_870_0: i128 = 10;
        // D s_870_1: read-var u#32805:u32
        let s_870_1: u32 = fn_state.u_32805;
        // D s_870_2: cast zx s_870_1 -> bv
        let s_870_2: Bits = Bits::new(s_870_1 as u128, 32u16);
        // C s_870_3: const #1u : u64
        let s_870_3: u64 = 1;
        // D s_870_4: bit-extract s_870_2 s_870_0 s_870_3
        let s_870_4: Bits = (Bits::new(
            ((s_870_2) >> (s_870_0)).value(),
            u16::try_from(s_870_3).unwrap(),
        ));
        // D s_870_5: cast reint s_870_4 -> u8
        let s_870_5: bool = ((s_870_4.value()) != 0);
        // C s_870_6: const #0s : i
        let s_870_6: i128 = 0;
        // C s_870_7: const #0u : u64
        let s_870_7: u64 = 0;
        // D s_870_8: cast zx s_870_5 -> u64
        let s_870_8: u64 = (s_870_5 as u64);
        // C s_870_9: const #1u : u64
        let s_870_9: u64 = 1;
        // D s_870_10: and s_870_8 s_870_9
        let s_870_10: u64 = ((s_870_8) & (s_870_9));
        // D s_870_11: cmp-eq s_870_10 s_870_9
        let s_870_11: bool = ((s_870_10) == (s_870_9));
        // D s_870_12: lsl s_870_8 s_870_6
        let s_870_12: u64 = s_870_8 << s_870_6;
        // D s_870_13: or s_870_7 s_870_12
        let s_870_13: u64 = ((s_870_7) | (s_870_12));
        // D s_870_14: cmpl s_870_12
        let s_870_14: u64 = !s_870_12;
        // D s_870_15: and s_870_7 s_870_14
        let s_870_15: u64 = ((s_870_7) & (s_870_14));
        // D s_870_16: select s_870_11 s_870_13 s_870_15
        let s_870_16: u64 = if s_870_11 { s_870_13 } else { s_870_15 };
        // D s_870_17: cast trunc s_870_16 -> u8
        let s_870_17: bool = ((s_870_16) != 0);
        // D s_870_18: cast zx s_870_17 -> bv
        let s_870_18: Bits = Bits::new(s_870_17 as u128, 1u16);
        // C s_870_19: const #0u : u8
        let s_870_19: bool = false;
        // C s_870_20: cast zx s_870_19 -> bv
        let s_870_20: Bits = Bits::new(s_870_19 as u128, 1u16);
        // D s_870_21: cmp-ne s_870_18 s_870_20
        let s_870_21: bool = ((s_870_18) != (s_870_20));
        // D s_870_22: write-var gs#406095 <= s_870_21
        fn_state.gs_406095 = s_870_21;
        // N s_870_23: jump b871
        return block_871(state, tracer, fn_state);
    }
    fn block_871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_871_0: read-var gs#406095:u8
        let s_871_0: bool = fn_state.gs_406095;
        // N s_871_1: branch s_871_0 b876 b872
        if s_871_0 {
            return block_876(state, tracer, fn_state);
        } else {
            return block_872(state, tracer, fn_state);
        };
    }
    fn block_872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_872_0: const #11s : i
        let s_872_0: i128 = 11;
        // D s_872_1: read-var u#32805:u32
        let s_872_1: u32 = fn_state.u_32805;
        // D s_872_2: cast zx s_872_1 -> bv
        let s_872_2: Bits = Bits::new(s_872_1 as u128, 32u16);
        // C s_872_3: const #1u : u64
        let s_872_3: u64 = 1;
        // D s_872_4: bit-extract s_872_2 s_872_0 s_872_3
        let s_872_4: Bits = (Bits::new(
            ((s_872_2) >> (s_872_0)).value(),
            u16::try_from(s_872_3).unwrap(),
        ));
        // D s_872_5: cast reint s_872_4 -> u8
        let s_872_5: bool = ((s_872_4.value()) != 0);
        // C s_872_6: const #0s : i
        let s_872_6: i128 = 0;
        // C s_872_7: const #0u : u64
        let s_872_7: u64 = 0;
        // D s_872_8: cast zx s_872_5 -> u64
        let s_872_8: u64 = (s_872_5 as u64);
        // C s_872_9: const #1u : u64
        let s_872_9: u64 = 1;
        // D s_872_10: and s_872_8 s_872_9
        let s_872_10: u64 = ((s_872_8) & (s_872_9));
        // D s_872_11: cmp-eq s_872_10 s_872_9
        let s_872_11: bool = ((s_872_10) == (s_872_9));
        // D s_872_12: lsl s_872_8 s_872_6
        let s_872_12: u64 = s_872_8 << s_872_6;
        // D s_872_13: or s_872_7 s_872_12
        let s_872_13: u64 = ((s_872_7) | (s_872_12));
        // D s_872_14: cmpl s_872_12
        let s_872_14: u64 = !s_872_12;
        // D s_872_15: and s_872_7 s_872_14
        let s_872_15: u64 = ((s_872_7) & (s_872_14));
        // D s_872_16: select s_872_11 s_872_13 s_872_15
        let s_872_16: u64 = if s_872_11 { s_872_13 } else { s_872_15 };
        // D s_872_17: cast trunc s_872_16 -> u8
        let s_872_17: bool = ((s_872_16) != 0);
        // D s_872_18: cast zx s_872_17 -> bv
        let s_872_18: Bits = Bits::new(s_872_17 as u128, 1u16);
        // C s_872_19: const #0u : u8
        let s_872_19: bool = false;
        // C s_872_20: cast zx s_872_19 -> bv
        let s_872_20: Bits = Bits::new(s_872_19 as u128, 1u16);
        // D s_872_21: cmp-ne s_872_18 s_872_20
        let s_872_21: bool = ((s_872_18) != (s_872_20));
        // D s_872_22: write-var gs#406098 <= s_872_21
        fn_state.gs_406098 = s_872_21;
        // N s_872_23: jump b873
        return block_873(state, tracer, fn_state);
    }
    fn block_873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_873_0: read-var gs#406098:u8
        let s_873_0: bool = fn_state.gs_406098;
        // N s_873_1: branch s_873_0 b875 b874
        if s_873_0 {
            return block_875(state, tracer, fn_state);
        } else {
            return block_874(state, tracer, fn_state);
        };
    }
    fn block_874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_874_0: read-var u#32806:u8
        let s_874_0: u8 = fn_state.u_32806;
        // D s_874_1: read-var u#32807:u8
        let s_874_1: u8 = fn_state.u_32807;
        // D s_874_2: read-var u#32808:u8
        let s_874_2: u8 = fn_state.u_32808;
        // D s_874_3: read-var u#32809:u8
        let s_874_3: u8 = fn_state.u_32809;
        // D s_874_4: call decode_aarch32_instrs_QDADD_A1enc_A_txt(s_874_0, s_874_1, s_874_2, s_874_3)
        let s_874_4: () = decode_aarch32_instrs_QDADD_A1enc_A_txt(
            state,
            tracer,
            s_874_0,
            s_874_1,
            s_874_2,
            s_874_3,
        );
        // N s_874_5: return
        return;
    }
    fn block_875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_875_0: panic
        panic!("{:?}", ());
        // N s_875_1: return
        return;
    }
    fn block_876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_876_0: const #1u : u8
        let s_876_0: bool = true;
        // D s_876_1: write-var gs#406098 <= s_876_0
        fn_state.gs_406098 = s_876_0;
        // N s_876_2: jump b873
        return block_873(state, tracer, fn_state);
    }
    fn block_877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_877_0: const #1u : u8
        let s_877_0: bool = true;
        // D s_877_1: write-var gs#406095 <= s_877_0
        fn_state.gs_406095 = s_877_0;
        // N s_877_2: jump b871
        return block_871(state, tracer, fn_state);
    }
    fn block_878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_878_0: const #1u : u8
        let s_878_0: bool = true;
        // D s_878_1: write-var gs#406092 <= s_878_0
        fn_state.gs_406092 = s_878_0;
        // N s_878_2: jump b869
        return block_869(state, tracer, fn_state);
    }
    fn block_879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_879_0: read-var merge#var.1:struct
        let s_879_0: u32 = fn_state.merge_var._1;
        // D s_879_1: write-var u#32811 <= s_879_0
        fn_state.u_32811 = s_879_0;
        // C s_879_2: const #20s : i
        let s_879_2: i128 = 20;
        // D s_879_3: read-var u#32811:u32
        let s_879_3: u32 = fn_state.u_32811;
        // D s_879_4: cast zx s_879_3 -> bv
        let s_879_4: Bits = Bits::new(s_879_3 as u128, 32u16);
        // C s_879_5: const #1s : i64
        let s_879_5: i64 = 1;
        // C s_879_6: cast zx s_879_5 -> i
        let s_879_6: i128 = (i128::try_from(s_879_5).unwrap());
        // C s_879_7: const #7s : i
        let s_879_7: i128 = 7;
        // C s_879_8: add s_879_7 s_879_6
        let s_879_8: i128 = (s_879_7 + s_879_6);
        // D s_879_9: bit-extract s_879_4 s_879_2 s_879_8
        let s_879_9: Bits = (Bits::new(
            ((s_879_4) >> (s_879_2)).value(),
            u16::try_from(s_879_8).unwrap(),
        ));
        // D s_879_10: cast reint s_879_9 -> u8
        let s_879_10: u8 = (s_879_9.value() as u8);
        // D s_879_11: cast zx s_879_10 -> bv
        let s_879_11: Bits = Bits::new(s_879_10 as u128, 8u16);
        // C s_879_12: const #22u : u8
        let s_879_12: u8 = 22;
        // C s_879_13: cast zx s_879_12 -> bv
        let s_879_13: Bits = Bits::new(s_879_12 as u128, 8u16);
        // D s_879_14: cmp-eq s_879_11 s_879_13
        let s_879_14: bool = ((s_879_11) == (s_879_13));
        // N s_879_15: branch s_879_14 b2517 b880
        if s_879_14 {
            return block_2517(state, tracer, fn_state);
        } else {
            return block_880(state, tracer, fn_state);
        };
    }
    fn block_880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_880_0: const #0u : u8
        let s_880_0: bool = false;
        // D s_880_1: write-var gs#406104 <= s_880_0
        fn_state.gs_406104 = s_880_0;
        // N s_880_2: jump b881
        return block_881(state, tracer, fn_state);
    }
    fn block_881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_881_0: read-var gs#406104:u8
        let s_881_0: bool = fn_state.gs_406104;
        // N s_881_1: branch s_881_0 b2513 b882
        if s_881_0 {
            return block_2513(state, tracer, fn_state);
        } else {
            return block_882(state, tracer, fn_state);
        };
    }
    fn block_882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_882_0: const #0u : u8
        let s_882_0: bool = false;
        // D s_882_1: write-var gs#406109 <= s_882_0
        fn_state.gs_406109 = s_882_0;
        // N s_882_2: jump b883
        return block_883(state, tracer, fn_state);
    }
    fn block_883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_883_0: read-var gs#406109:u8
        let s_883_0: bool = fn_state.gs_406109;
        // D s_883_1: not s_883_0
        let s_883_1: bool = !s_883_0;
        // N s_883_2: branch s_883_1 b896 b884
        if s_883_1 {
            return block_896(state, tracer, fn_state);
        } else {
            return block_884(state, tracer, fn_state);
        };
    }
    fn block_884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_884_0: const #3074s : i
        let s_884_0: i128 = 3074;
        // C s_884_1: const #14696u : u32
        let s_884_1: u32 = 14696;
        // N s_884_2: write-reg s_884_1 <= s_884_0
        let s_884_2: () = {
            state.write_register::<i128>(s_884_1 as isize, s_884_0);
            tracer.write_register(s_884_1 as isize, s_884_0);
        };
        // C s_884_3: const #28s : i
        let s_884_3: i128 = 28;
        // C s_884_4: const #4s : i
        let s_884_4: i128 = 4;
        // D s_884_5: read-var u#32811:u32
        let s_884_5: u32 = fn_state.u_32811;
        // D s_884_6: cast zx s_884_5 -> bv
        let s_884_6: Bits = Bits::new(s_884_5 as u128, 32u16);
        // D s_884_7: bit-extract s_884_6 s_884_3 s_884_4
        let s_884_7: Bits = (Bits::new(
            ((s_884_6) >> (s_884_3)).value(),
            u16::try_from(s_884_4).unwrap(),
        ));
        // D s_884_8: cast reint s_884_7 -> u8
        let s_884_8: u8 = (s_884_7.value() as u8);
        // D s_884_9: write-var u#32812 <= s_884_8
        fn_state.u_32812 = s_884_8;
        // C s_884_10: const #16s : i
        let s_884_10: i128 = 16;
        // C s_884_11: const #4s : i
        let s_884_11: i128 = 4;
        // D s_884_12: read-var u#32811:u32
        let s_884_12: u32 = fn_state.u_32811;
        // D s_884_13: cast zx s_884_12 -> bv
        let s_884_13: Bits = Bits::new(s_884_12 as u128, 32u16);
        // D s_884_14: bit-extract s_884_13 s_884_10 s_884_11
        let s_884_14: Bits = (Bits::new(
            ((s_884_13) >> (s_884_10)).value(),
            u16::try_from(s_884_11).unwrap(),
        ));
        // D s_884_15: cast reint s_884_14 -> u8
        let s_884_15: u8 = (s_884_14.value() as u8);
        // D s_884_16: write-var u#32813 <= s_884_15
        fn_state.u_32813 = s_884_15;
        // C s_884_17: const #12s : i
        let s_884_17: i128 = 12;
        // C s_884_18: const #4s : i
        let s_884_18: i128 = 4;
        // D s_884_19: read-var u#32811:u32
        let s_884_19: u32 = fn_state.u_32811;
        // D s_884_20: cast zx s_884_19 -> bv
        let s_884_20: Bits = Bits::new(s_884_19 as u128, 32u16);
        // D s_884_21: bit-extract s_884_20 s_884_17 s_884_18
        let s_884_21: Bits = (Bits::new(
            ((s_884_20) >> (s_884_17)).value(),
            u16::try_from(s_884_18).unwrap(),
        ));
        // D s_884_22: cast reint s_884_21 -> u8
        let s_884_22: u8 = (s_884_21.value() as u8);
        // D s_884_23: write-var u#32814 <= s_884_22
        fn_state.u_32814 = s_884_22;
        // C s_884_24: const #0s : i
        let s_884_24: i128 = 0;
        // C s_884_25: const #4s : i
        let s_884_25: i128 = 4;
        // D s_884_26: read-var u#32811:u32
        let s_884_26: u32 = fn_state.u_32811;
        // D s_884_27: cast zx s_884_26 -> bv
        let s_884_27: Bits = Bits::new(s_884_26 as u128, 32u16);
        // D s_884_28: bit-extract s_884_27 s_884_24 s_884_25
        let s_884_28: Bits = (Bits::new(
            ((s_884_27) >> (s_884_24)).value(),
            u16::try_from(s_884_25).unwrap(),
        ));
        // D s_884_29: cast reint s_884_28 -> u8
        let s_884_29: u8 = (s_884_28.value() as u8);
        // D s_884_30: write-var u#32815 <= s_884_29
        fn_state.u_32815 = s_884_29;
        // C s_884_31: const #8s : i
        let s_884_31: i128 = 8;
        // D s_884_32: read-var u#32811:u32
        let s_884_32: u32 = fn_state.u_32811;
        // D s_884_33: cast zx s_884_32 -> bv
        let s_884_33: Bits = Bits::new(s_884_32 as u128, 32u16);
        // C s_884_34: const #1u : u64
        let s_884_34: u64 = 1;
        // D s_884_35: bit-extract s_884_33 s_884_31 s_884_34
        let s_884_35: Bits = (Bits::new(
            ((s_884_33) >> (s_884_31)).value(),
            u16::try_from(s_884_34).unwrap(),
        ));
        // D s_884_36: cast reint s_884_35 -> u8
        let s_884_36: bool = ((s_884_35.value()) != 0);
        // C s_884_37: const #0s : i
        let s_884_37: i128 = 0;
        // C s_884_38: const #0u : u64
        let s_884_38: u64 = 0;
        // D s_884_39: cast zx s_884_36 -> u64
        let s_884_39: u64 = (s_884_36 as u64);
        // C s_884_40: const #1u : u64
        let s_884_40: u64 = 1;
        // D s_884_41: and s_884_39 s_884_40
        let s_884_41: u64 = ((s_884_39) & (s_884_40));
        // D s_884_42: cmp-eq s_884_41 s_884_40
        let s_884_42: bool = ((s_884_41) == (s_884_40));
        // D s_884_43: lsl s_884_39 s_884_37
        let s_884_43: u64 = s_884_39 << s_884_37;
        // D s_884_44: or s_884_38 s_884_43
        let s_884_44: u64 = ((s_884_38) | (s_884_43));
        // D s_884_45: cmpl s_884_43
        let s_884_45: u64 = !s_884_43;
        // D s_884_46: and s_884_38 s_884_45
        let s_884_46: u64 = ((s_884_38) & (s_884_45));
        // D s_884_47: select s_884_42 s_884_44 s_884_46
        let s_884_47: u64 = if s_884_42 { s_884_44 } else { s_884_46 };
        // D s_884_48: cast trunc s_884_47 -> u8
        let s_884_48: bool = ((s_884_47) != 0);
        // D s_884_49: cast zx s_884_48 -> bv
        let s_884_49: Bits = Bits::new(s_884_48 as u128, 1u16);
        // C s_884_50: const #0u : u8
        let s_884_50: bool = false;
        // C s_884_51: cast zx s_884_50 -> bv
        let s_884_51: Bits = Bits::new(s_884_50 as u128, 1u16);
        // D s_884_52: cmp-ne s_884_49 s_884_51
        let s_884_52: bool = ((s_884_49) != (s_884_51));
        // N s_884_53: branch s_884_52 b895 b885
        if s_884_52 {
            return block_895(state, tracer, fn_state);
        } else {
            return block_885(state, tracer, fn_state);
        };
    }
    fn block_885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_885_0: const #9s : i
        let s_885_0: i128 = 9;
        // D s_885_1: read-var u#32811:u32
        let s_885_1: u32 = fn_state.u_32811;
        // D s_885_2: cast zx s_885_1 -> bv
        let s_885_2: Bits = Bits::new(s_885_1 as u128, 32u16);
        // C s_885_3: const #1u : u64
        let s_885_3: u64 = 1;
        // D s_885_4: bit-extract s_885_2 s_885_0 s_885_3
        let s_885_4: Bits = (Bits::new(
            ((s_885_2) >> (s_885_0)).value(),
            u16::try_from(s_885_3).unwrap(),
        ));
        // D s_885_5: cast reint s_885_4 -> u8
        let s_885_5: bool = ((s_885_4.value()) != 0);
        // C s_885_6: const #0s : i
        let s_885_6: i128 = 0;
        // C s_885_7: const #0u : u64
        let s_885_7: u64 = 0;
        // D s_885_8: cast zx s_885_5 -> u64
        let s_885_8: u64 = (s_885_5 as u64);
        // C s_885_9: const #1u : u64
        let s_885_9: u64 = 1;
        // D s_885_10: and s_885_8 s_885_9
        let s_885_10: u64 = ((s_885_8) & (s_885_9));
        // D s_885_11: cmp-eq s_885_10 s_885_9
        let s_885_11: bool = ((s_885_10) == (s_885_9));
        // D s_885_12: lsl s_885_8 s_885_6
        let s_885_12: u64 = s_885_8 << s_885_6;
        // D s_885_13: or s_885_7 s_885_12
        let s_885_13: u64 = ((s_885_7) | (s_885_12));
        // D s_885_14: cmpl s_885_12
        let s_885_14: u64 = !s_885_12;
        // D s_885_15: and s_885_7 s_885_14
        let s_885_15: u64 = ((s_885_7) & (s_885_14));
        // D s_885_16: select s_885_11 s_885_13 s_885_15
        let s_885_16: u64 = if s_885_11 { s_885_13 } else { s_885_15 };
        // D s_885_17: cast trunc s_885_16 -> u8
        let s_885_17: bool = ((s_885_16) != 0);
        // D s_885_18: cast zx s_885_17 -> bv
        let s_885_18: Bits = Bits::new(s_885_17 as u128, 1u16);
        // C s_885_19: const #0u : u8
        let s_885_19: bool = false;
        // C s_885_20: cast zx s_885_19 -> bv
        let s_885_20: Bits = Bits::new(s_885_19 as u128, 1u16);
        // D s_885_21: cmp-ne s_885_18 s_885_20
        let s_885_21: bool = ((s_885_18) != (s_885_20));
        // D s_885_22: write-var gs#406124 <= s_885_21
        fn_state.gs_406124 = s_885_21;
        // N s_885_23: jump b886
        return block_886(state, tracer, fn_state);
    }
    fn block_886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_886_0: read-var gs#406124:u8
        let s_886_0: bool = fn_state.gs_406124;
        // N s_886_1: branch s_886_0 b894 b887
        if s_886_0 {
            return block_894(state, tracer, fn_state);
        } else {
            return block_887(state, tracer, fn_state);
        };
    }
    fn block_887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_887_0: const #10s : i
        let s_887_0: i128 = 10;
        // D s_887_1: read-var u#32811:u32
        let s_887_1: u32 = fn_state.u_32811;
        // D s_887_2: cast zx s_887_1 -> bv
        let s_887_2: Bits = Bits::new(s_887_1 as u128, 32u16);
        // C s_887_3: const #1u : u64
        let s_887_3: u64 = 1;
        // D s_887_4: bit-extract s_887_2 s_887_0 s_887_3
        let s_887_4: Bits = (Bits::new(
            ((s_887_2) >> (s_887_0)).value(),
            u16::try_from(s_887_3).unwrap(),
        ));
        // D s_887_5: cast reint s_887_4 -> u8
        let s_887_5: bool = ((s_887_4.value()) != 0);
        // C s_887_6: const #0s : i
        let s_887_6: i128 = 0;
        // C s_887_7: const #0u : u64
        let s_887_7: u64 = 0;
        // D s_887_8: cast zx s_887_5 -> u64
        let s_887_8: u64 = (s_887_5 as u64);
        // C s_887_9: const #1u : u64
        let s_887_9: u64 = 1;
        // D s_887_10: and s_887_8 s_887_9
        let s_887_10: u64 = ((s_887_8) & (s_887_9));
        // D s_887_11: cmp-eq s_887_10 s_887_9
        let s_887_11: bool = ((s_887_10) == (s_887_9));
        // D s_887_12: lsl s_887_8 s_887_6
        let s_887_12: u64 = s_887_8 << s_887_6;
        // D s_887_13: or s_887_7 s_887_12
        let s_887_13: u64 = ((s_887_7) | (s_887_12));
        // D s_887_14: cmpl s_887_12
        let s_887_14: u64 = !s_887_12;
        // D s_887_15: and s_887_7 s_887_14
        let s_887_15: u64 = ((s_887_7) & (s_887_14));
        // D s_887_16: select s_887_11 s_887_13 s_887_15
        let s_887_16: u64 = if s_887_11 { s_887_13 } else { s_887_15 };
        // D s_887_17: cast trunc s_887_16 -> u8
        let s_887_17: bool = ((s_887_16) != 0);
        // D s_887_18: cast zx s_887_17 -> bv
        let s_887_18: Bits = Bits::new(s_887_17 as u128, 1u16);
        // C s_887_19: const #0u : u8
        let s_887_19: bool = false;
        // C s_887_20: cast zx s_887_19 -> bv
        let s_887_20: Bits = Bits::new(s_887_19 as u128, 1u16);
        // D s_887_21: cmp-ne s_887_18 s_887_20
        let s_887_21: bool = ((s_887_18) != (s_887_20));
        // D s_887_22: write-var gs#406127 <= s_887_21
        fn_state.gs_406127 = s_887_21;
        // N s_887_23: jump b888
        return block_888(state, tracer, fn_state);
    }
    fn block_888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_888_0: read-var gs#406127:u8
        let s_888_0: bool = fn_state.gs_406127;
        // N s_888_1: branch s_888_0 b893 b889
        if s_888_0 {
            return block_893(state, tracer, fn_state);
        } else {
            return block_889(state, tracer, fn_state);
        };
    }
    fn block_889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_889_0: const #11s : i
        let s_889_0: i128 = 11;
        // D s_889_1: read-var u#32811:u32
        let s_889_1: u32 = fn_state.u_32811;
        // D s_889_2: cast zx s_889_1 -> bv
        let s_889_2: Bits = Bits::new(s_889_1 as u128, 32u16);
        // C s_889_3: const #1u : u64
        let s_889_3: u64 = 1;
        // D s_889_4: bit-extract s_889_2 s_889_0 s_889_3
        let s_889_4: Bits = (Bits::new(
            ((s_889_2) >> (s_889_0)).value(),
            u16::try_from(s_889_3).unwrap(),
        ));
        // D s_889_5: cast reint s_889_4 -> u8
        let s_889_5: bool = ((s_889_4.value()) != 0);
        // C s_889_6: const #0s : i
        let s_889_6: i128 = 0;
        // C s_889_7: const #0u : u64
        let s_889_7: u64 = 0;
        // D s_889_8: cast zx s_889_5 -> u64
        let s_889_8: u64 = (s_889_5 as u64);
        // C s_889_9: const #1u : u64
        let s_889_9: u64 = 1;
        // D s_889_10: and s_889_8 s_889_9
        let s_889_10: u64 = ((s_889_8) & (s_889_9));
        // D s_889_11: cmp-eq s_889_10 s_889_9
        let s_889_11: bool = ((s_889_10) == (s_889_9));
        // D s_889_12: lsl s_889_8 s_889_6
        let s_889_12: u64 = s_889_8 << s_889_6;
        // D s_889_13: or s_889_7 s_889_12
        let s_889_13: u64 = ((s_889_7) | (s_889_12));
        // D s_889_14: cmpl s_889_12
        let s_889_14: u64 = !s_889_12;
        // D s_889_15: and s_889_7 s_889_14
        let s_889_15: u64 = ((s_889_7) & (s_889_14));
        // D s_889_16: select s_889_11 s_889_13 s_889_15
        let s_889_16: u64 = if s_889_11 { s_889_13 } else { s_889_15 };
        // D s_889_17: cast trunc s_889_16 -> u8
        let s_889_17: bool = ((s_889_16) != 0);
        // D s_889_18: cast zx s_889_17 -> bv
        let s_889_18: Bits = Bits::new(s_889_17 as u128, 1u16);
        // C s_889_19: const #0u : u8
        let s_889_19: bool = false;
        // C s_889_20: cast zx s_889_19 -> bv
        let s_889_20: Bits = Bits::new(s_889_19 as u128, 1u16);
        // D s_889_21: cmp-ne s_889_18 s_889_20
        let s_889_21: bool = ((s_889_18) != (s_889_20));
        // D s_889_22: write-var gs#406130 <= s_889_21
        fn_state.gs_406130 = s_889_21;
        // N s_889_23: jump b890
        return block_890(state, tracer, fn_state);
    }
    fn block_890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_890_0: read-var gs#406130:u8
        let s_890_0: bool = fn_state.gs_406130;
        // N s_890_1: branch s_890_0 b892 b891
        if s_890_0 {
            return block_892(state, tracer, fn_state);
        } else {
            return block_891(state, tracer, fn_state);
        };
    }
    fn block_891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_891_0: read-var u#32812:u8
        let s_891_0: u8 = fn_state.u_32812;
        // D s_891_1: read-var u#32813:u8
        let s_891_1: u8 = fn_state.u_32813;
        // D s_891_2: read-var u#32814:u8
        let s_891_2: u8 = fn_state.u_32814;
        // D s_891_3: read-var u#32815:u8
        let s_891_3: u8 = fn_state.u_32815;
        // D s_891_4: call decode_aarch32_instrs_QDSUB_A1enc_A_txt(s_891_0, s_891_1, s_891_2, s_891_3)
        let s_891_4: () = decode_aarch32_instrs_QDSUB_A1enc_A_txt(
            state,
            tracer,
            s_891_0,
            s_891_1,
            s_891_2,
            s_891_3,
        );
        // N s_891_5: return
        return;
    }
    fn block_892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_892_0: panic
        panic!("{:?}", ());
        // N s_892_1: return
        return;
    }
    fn block_893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_893_0: const #1u : u8
        let s_893_0: bool = true;
        // D s_893_1: write-var gs#406130 <= s_893_0
        fn_state.gs_406130 = s_893_0;
        // N s_893_2: jump b890
        return block_890(state, tracer, fn_state);
    }
    fn block_894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_894_0: const #1u : u8
        let s_894_0: bool = true;
        // D s_894_1: write-var gs#406127 <= s_894_0
        fn_state.gs_406127 = s_894_0;
        // N s_894_2: jump b888
        return block_888(state, tracer, fn_state);
    }
    fn block_895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_895_0: const #1u : u8
        let s_895_0: bool = true;
        // D s_895_1: write-var gs#406124 <= s_895_0
        fn_state.gs_406124 = s_895_0;
        // N s_895_2: jump b886
        return block_886(state, tracer, fn_state);
    }
    fn block_896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_896_0: read-var merge#var.1:struct
        let s_896_0: u32 = fn_state.merge_var._1;
        // D s_896_1: write-var u#32817 <= s_896_0
        fn_state.u_32817 = s_896_0;
        // C s_896_2: const #20s : i
        let s_896_2: i128 = 20;
        // D s_896_3: read-var u#32817:u32
        let s_896_3: u32 = fn_state.u_32817;
        // D s_896_4: cast zx s_896_3 -> bv
        let s_896_4: Bits = Bits::new(s_896_3 as u128, 32u16);
        // C s_896_5: const #1s : i64
        let s_896_5: i64 = 1;
        // C s_896_6: cast zx s_896_5 -> i
        let s_896_6: i128 = (i128::try_from(s_896_5).unwrap());
        // C s_896_7: const #7s : i
        let s_896_7: i128 = 7;
        // C s_896_8: add s_896_7 s_896_6
        let s_896_8: i128 = (s_896_7 + s_896_6);
        // D s_896_9: bit-extract s_896_4 s_896_2 s_896_8
        let s_896_9: Bits = (Bits::new(
            ((s_896_4) >> (s_896_2)).value(),
            u16::try_from(s_896_8).unwrap(),
        ));
        // D s_896_10: cast reint s_896_9 -> u8
        let s_896_10: u8 = (s_896_9.value() as u8);
        // D s_896_11: cast zx s_896_10 -> bv
        let s_896_11: Bits = Bits::new(s_896_10 as u128, 8u16);
        // C s_896_12: const #18u : u8
        let s_896_12: u8 = 18;
        // C s_896_13: cast zx s_896_12 -> bv
        let s_896_13: Bits = Bits::new(s_896_12 as u128, 8u16);
        // D s_896_14: cmp-eq s_896_11 s_896_13
        let s_896_14: bool = ((s_896_11) == (s_896_13));
        // N s_896_15: branch s_896_14 b2512 b897
        if s_896_14 {
            return block_2512(state, tracer, fn_state);
        } else {
            return block_897(state, tracer, fn_state);
        };
    }
    fn block_897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_897_0: const #0u : u8
        let s_897_0: bool = false;
        // D s_897_1: write-var gs#406136 <= s_897_0
        fn_state.gs_406136 = s_897_0;
        // N s_897_2: jump b898
        return block_898(state, tracer, fn_state);
    }
    fn block_898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_898_0: read-var gs#406136:u8
        let s_898_0: bool = fn_state.gs_406136;
        // N s_898_1: branch s_898_0 b2508 b899
        if s_898_0 {
            return block_2508(state, tracer, fn_state);
        } else {
            return block_899(state, tracer, fn_state);
        };
    }
    fn block_899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_899_0: const #0u : u8
        let s_899_0: bool = false;
        // D s_899_1: write-var gs#406141 <= s_899_0
        fn_state.gs_406141 = s_899_0;
        // N s_899_2: jump b900
        return block_900(state, tracer, fn_state);
    }
    fn block_900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_900_0: read-var gs#406141:u8
        let s_900_0: bool = fn_state.gs_406141;
        // D s_900_1: not s_900_0
        let s_900_1: bool = !s_900_0;
        // N s_900_2: branch s_900_1 b913 b901
        if s_900_1 {
            return block_913(state, tracer, fn_state);
        } else {
            return block_901(state, tracer, fn_state);
        };
    }
    fn block_901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_901_0: const #3082s : i
        let s_901_0: i128 = 3082;
        // C s_901_1: const #14696u : u32
        let s_901_1: u32 = 14696;
        // N s_901_2: write-reg s_901_1 <= s_901_0
        let s_901_2: () = {
            state.write_register::<i128>(s_901_1 as isize, s_901_0);
            tracer.write_register(s_901_1 as isize, s_901_0);
        };
        // C s_901_3: const #28s : i
        let s_901_3: i128 = 28;
        // C s_901_4: const #4s : i
        let s_901_4: i128 = 4;
        // D s_901_5: read-var u#32817:u32
        let s_901_5: u32 = fn_state.u_32817;
        // D s_901_6: cast zx s_901_5 -> bv
        let s_901_6: Bits = Bits::new(s_901_5 as u128, 32u16);
        // D s_901_7: bit-extract s_901_6 s_901_3 s_901_4
        let s_901_7: Bits = (Bits::new(
            ((s_901_6) >> (s_901_3)).value(),
            u16::try_from(s_901_4).unwrap(),
        ));
        // D s_901_8: cast reint s_901_7 -> u8
        let s_901_8: u8 = (s_901_7.value() as u8);
        // D s_901_9: write-var u#32818 <= s_901_8
        fn_state.u_32818 = s_901_8;
        // C s_901_10: const #16s : i
        let s_901_10: i128 = 16;
        // C s_901_11: const #4s : i
        let s_901_11: i128 = 4;
        // D s_901_12: read-var u#32817:u32
        let s_901_12: u32 = fn_state.u_32817;
        // D s_901_13: cast zx s_901_12 -> bv
        let s_901_13: Bits = Bits::new(s_901_12 as u128, 32u16);
        // D s_901_14: bit-extract s_901_13 s_901_10 s_901_11
        let s_901_14: Bits = (Bits::new(
            ((s_901_13) >> (s_901_10)).value(),
            u16::try_from(s_901_11).unwrap(),
        ));
        // D s_901_15: cast reint s_901_14 -> u8
        let s_901_15: u8 = (s_901_14.value() as u8);
        // D s_901_16: write-var u#32819 <= s_901_15
        fn_state.u_32819 = s_901_15;
        // C s_901_17: const #12s : i
        let s_901_17: i128 = 12;
        // C s_901_18: const #4s : i
        let s_901_18: i128 = 4;
        // D s_901_19: read-var u#32817:u32
        let s_901_19: u32 = fn_state.u_32817;
        // D s_901_20: cast zx s_901_19 -> bv
        let s_901_20: Bits = Bits::new(s_901_19 as u128, 32u16);
        // D s_901_21: bit-extract s_901_20 s_901_17 s_901_18
        let s_901_21: Bits = (Bits::new(
            ((s_901_20) >> (s_901_17)).value(),
            u16::try_from(s_901_18).unwrap(),
        ));
        // D s_901_22: cast reint s_901_21 -> u8
        let s_901_22: u8 = (s_901_21.value() as u8);
        // D s_901_23: write-var u#32820 <= s_901_22
        fn_state.u_32820 = s_901_22;
        // C s_901_24: const #0s : i
        let s_901_24: i128 = 0;
        // C s_901_25: const #4s : i
        let s_901_25: i128 = 4;
        // D s_901_26: read-var u#32817:u32
        let s_901_26: u32 = fn_state.u_32817;
        // D s_901_27: cast zx s_901_26 -> bv
        let s_901_27: Bits = Bits::new(s_901_26 as u128, 32u16);
        // D s_901_28: bit-extract s_901_27 s_901_24 s_901_25
        let s_901_28: Bits = (Bits::new(
            ((s_901_27) >> (s_901_24)).value(),
            u16::try_from(s_901_25).unwrap(),
        ));
        // D s_901_29: cast reint s_901_28 -> u8
        let s_901_29: u8 = (s_901_28.value() as u8);
        // D s_901_30: write-var u#32821 <= s_901_29
        fn_state.u_32821 = s_901_29;
        // C s_901_31: const #8s : i
        let s_901_31: i128 = 8;
        // D s_901_32: read-var u#32817:u32
        let s_901_32: u32 = fn_state.u_32817;
        // D s_901_33: cast zx s_901_32 -> bv
        let s_901_33: Bits = Bits::new(s_901_32 as u128, 32u16);
        // C s_901_34: const #1u : u64
        let s_901_34: u64 = 1;
        // D s_901_35: bit-extract s_901_33 s_901_31 s_901_34
        let s_901_35: Bits = (Bits::new(
            ((s_901_33) >> (s_901_31)).value(),
            u16::try_from(s_901_34).unwrap(),
        ));
        // D s_901_36: cast reint s_901_35 -> u8
        let s_901_36: bool = ((s_901_35.value()) != 0);
        // C s_901_37: const #0s : i
        let s_901_37: i128 = 0;
        // C s_901_38: const #0u : u64
        let s_901_38: u64 = 0;
        // D s_901_39: cast zx s_901_36 -> u64
        let s_901_39: u64 = (s_901_36 as u64);
        // C s_901_40: const #1u : u64
        let s_901_40: u64 = 1;
        // D s_901_41: and s_901_39 s_901_40
        let s_901_41: u64 = ((s_901_39) & (s_901_40));
        // D s_901_42: cmp-eq s_901_41 s_901_40
        let s_901_42: bool = ((s_901_41) == (s_901_40));
        // D s_901_43: lsl s_901_39 s_901_37
        let s_901_43: u64 = s_901_39 << s_901_37;
        // D s_901_44: or s_901_38 s_901_43
        let s_901_44: u64 = ((s_901_38) | (s_901_43));
        // D s_901_45: cmpl s_901_43
        let s_901_45: u64 = !s_901_43;
        // D s_901_46: and s_901_38 s_901_45
        let s_901_46: u64 = ((s_901_38) & (s_901_45));
        // D s_901_47: select s_901_42 s_901_44 s_901_46
        let s_901_47: u64 = if s_901_42 { s_901_44 } else { s_901_46 };
        // D s_901_48: cast trunc s_901_47 -> u8
        let s_901_48: bool = ((s_901_47) != 0);
        // D s_901_49: cast zx s_901_48 -> bv
        let s_901_49: Bits = Bits::new(s_901_48 as u128, 1u16);
        // C s_901_50: const #0u : u8
        let s_901_50: bool = false;
        // C s_901_51: cast zx s_901_50 -> bv
        let s_901_51: Bits = Bits::new(s_901_50 as u128, 1u16);
        // D s_901_52: cmp-ne s_901_49 s_901_51
        let s_901_52: bool = ((s_901_49) != (s_901_51));
        // N s_901_53: branch s_901_52 b912 b902
        if s_901_52 {
            return block_912(state, tracer, fn_state);
        } else {
            return block_902(state, tracer, fn_state);
        };
    }
    fn block_902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_902_0: const #9s : i
        let s_902_0: i128 = 9;
        // D s_902_1: read-var u#32817:u32
        let s_902_1: u32 = fn_state.u_32817;
        // D s_902_2: cast zx s_902_1 -> bv
        let s_902_2: Bits = Bits::new(s_902_1 as u128, 32u16);
        // C s_902_3: const #1u : u64
        let s_902_3: u64 = 1;
        // D s_902_4: bit-extract s_902_2 s_902_0 s_902_3
        let s_902_4: Bits = (Bits::new(
            ((s_902_2) >> (s_902_0)).value(),
            u16::try_from(s_902_3).unwrap(),
        ));
        // D s_902_5: cast reint s_902_4 -> u8
        let s_902_5: bool = ((s_902_4.value()) != 0);
        // C s_902_6: const #0s : i
        let s_902_6: i128 = 0;
        // C s_902_7: const #0u : u64
        let s_902_7: u64 = 0;
        // D s_902_8: cast zx s_902_5 -> u64
        let s_902_8: u64 = (s_902_5 as u64);
        // C s_902_9: const #1u : u64
        let s_902_9: u64 = 1;
        // D s_902_10: and s_902_8 s_902_9
        let s_902_10: u64 = ((s_902_8) & (s_902_9));
        // D s_902_11: cmp-eq s_902_10 s_902_9
        let s_902_11: bool = ((s_902_10) == (s_902_9));
        // D s_902_12: lsl s_902_8 s_902_6
        let s_902_12: u64 = s_902_8 << s_902_6;
        // D s_902_13: or s_902_7 s_902_12
        let s_902_13: u64 = ((s_902_7) | (s_902_12));
        // D s_902_14: cmpl s_902_12
        let s_902_14: u64 = !s_902_12;
        // D s_902_15: and s_902_7 s_902_14
        let s_902_15: u64 = ((s_902_7) & (s_902_14));
        // D s_902_16: select s_902_11 s_902_13 s_902_15
        let s_902_16: u64 = if s_902_11 { s_902_13 } else { s_902_15 };
        // D s_902_17: cast trunc s_902_16 -> u8
        let s_902_17: bool = ((s_902_16) != 0);
        // D s_902_18: cast zx s_902_17 -> bv
        let s_902_18: Bits = Bits::new(s_902_17 as u128, 1u16);
        // C s_902_19: const #0u : u8
        let s_902_19: bool = false;
        // C s_902_20: cast zx s_902_19 -> bv
        let s_902_20: Bits = Bits::new(s_902_19 as u128, 1u16);
        // D s_902_21: cmp-ne s_902_18 s_902_20
        let s_902_21: bool = ((s_902_18) != (s_902_20));
        // D s_902_22: write-var gs#406156 <= s_902_21
        fn_state.gs_406156 = s_902_21;
        // N s_902_23: jump b903
        return block_903(state, tracer, fn_state);
    }
    fn block_903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_903_0: read-var gs#406156:u8
        let s_903_0: bool = fn_state.gs_406156;
        // N s_903_1: branch s_903_0 b911 b904
        if s_903_0 {
            return block_911(state, tracer, fn_state);
        } else {
            return block_904(state, tracer, fn_state);
        };
    }
    fn block_904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_904_0: const #10s : i
        let s_904_0: i128 = 10;
        // D s_904_1: read-var u#32817:u32
        let s_904_1: u32 = fn_state.u_32817;
        // D s_904_2: cast zx s_904_1 -> bv
        let s_904_2: Bits = Bits::new(s_904_1 as u128, 32u16);
        // C s_904_3: const #1u : u64
        let s_904_3: u64 = 1;
        // D s_904_4: bit-extract s_904_2 s_904_0 s_904_3
        let s_904_4: Bits = (Bits::new(
            ((s_904_2) >> (s_904_0)).value(),
            u16::try_from(s_904_3).unwrap(),
        ));
        // D s_904_5: cast reint s_904_4 -> u8
        let s_904_5: bool = ((s_904_4.value()) != 0);
        // C s_904_6: const #0s : i
        let s_904_6: i128 = 0;
        // C s_904_7: const #0u : u64
        let s_904_7: u64 = 0;
        // D s_904_8: cast zx s_904_5 -> u64
        let s_904_8: u64 = (s_904_5 as u64);
        // C s_904_9: const #1u : u64
        let s_904_9: u64 = 1;
        // D s_904_10: and s_904_8 s_904_9
        let s_904_10: u64 = ((s_904_8) & (s_904_9));
        // D s_904_11: cmp-eq s_904_10 s_904_9
        let s_904_11: bool = ((s_904_10) == (s_904_9));
        // D s_904_12: lsl s_904_8 s_904_6
        let s_904_12: u64 = s_904_8 << s_904_6;
        // D s_904_13: or s_904_7 s_904_12
        let s_904_13: u64 = ((s_904_7) | (s_904_12));
        // D s_904_14: cmpl s_904_12
        let s_904_14: u64 = !s_904_12;
        // D s_904_15: and s_904_7 s_904_14
        let s_904_15: u64 = ((s_904_7) & (s_904_14));
        // D s_904_16: select s_904_11 s_904_13 s_904_15
        let s_904_16: u64 = if s_904_11 { s_904_13 } else { s_904_15 };
        // D s_904_17: cast trunc s_904_16 -> u8
        let s_904_17: bool = ((s_904_16) != 0);
        // D s_904_18: cast zx s_904_17 -> bv
        let s_904_18: Bits = Bits::new(s_904_17 as u128, 1u16);
        // C s_904_19: const #0u : u8
        let s_904_19: bool = false;
        // C s_904_20: cast zx s_904_19 -> bv
        let s_904_20: Bits = Bits::new(s_904_19 as u128, 1u16);
        // D s_904_21: cmp-ne s_904_18 s_904_20
        let s_904_21: bool = ((s_904_18) != (s_904_20));
        // D s_904_22: write-var gs#406159 <= s_904_21
        fn_state.gs_406159 = s_904_21;
        // N s_904_23: jump b905
        return block_905(state, tracer, fn_state);
    }
    fn block_905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_905_0: read-var gs#406159:u8
        let s_905_0: bool = fn_state.gs_406159;
        // N s_905_1: branch s_905_0 b910 b906
        if s_905_0 {
            return block_910(state, tracer, fn_state);
        } else {
            return block_906(state, tracer, fn_state);
        };
    }
    fn block_906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_906_0: const #11s : i
        let s_906_0: i128 = 11;
        // D s_906_1: read-var u#32817:u32
        let s_906_1: u32 = fn_state.u_32817;
        // D s_906_2: cast zx s_906_1 -> bv
        let s_906_2: Bits = Bits::new(s_906_1 as u128, 32u16);
        // C s_906_3: const #1u : u64
        let s_906_3: u64 = 1;
        // D s_906_4: bit-extract s_906_2 s_906_0 s_906_3
        let s_906_4: Bits = (Bits::new(
            ((s_906_2) >> (s_906_0)).value(),
            u16::try_from(s_906_3).unwrap(),
        ));
        // D s_906_5: cast reint s_906_4 -> u8
        let s_906_5: bool = ((s_906_4.value()) != 0);
        // C s_906_6: const #0s : i
        let s_906_6: i128 = 0;
        // C s_906_7: const #0u : u64
        let s_906_7: u64 = 0;
        // D s_906_8: cast zx s_906_5 -> u64
        let s_906_8: u64 = (s_906_5 as u64);
        // C s_906_9: const #1u : u64
        let s_906_9: u64 = 1;
        // D s_906_10: and s_906_8 s_906_9
        let s_906_10: u64 = ((s_906_8) & (s_906_9));
        // D s_906_11: cmp-eq s_906_10 s_906_9
        let s_906_11: bool = ((s_906_10) == (s_906_9));
        // D s_906_12: lsl s_906_8 s_906_6
        let s_906_12: u64 = s_906_8 << s_906_6;
        // D s_906_13: or s_906_7 s_906_12
        let s_906_13: u64 = ((s_906_7) | (s_906_12));
        // D s_906_14: cmpl s_906_12
        let s_906_14: u64 = !s_906_12;
        // D s_906_15: and s_906_7 s_906_14
        let s_906_15: u64 = ((s_906_7) & (s_906_14));
        // D s_906_16: select s_906_11 s_906_13 s_906_15
        let s_906_16: u64 = if s_906_11 { s_906_13 } else { s_906_15 };
        // D s_906_17: cast trunc s_906_16 -> u8
        let s_906_17: bool = ((s_906_16) != 0);
        // D s_906_18: cast zx s_906_17 -> bv
        let s_906_18: Bits = Bits::new(s_906_17 as u128, 1u16);
        // C s_906_19: const #0u : u8
        let s_906_19: bool = false;
        // C s_906_20: cast zx s_906_19 -> bv
        let s_906_20: Bits = Bits::new(s_906_19 as u128, 1u16);
        // D s_906_21: cmp-ne s_906_18 s_906_20
        let s_906_21: bool = ((s_906_18) != (s_906_20));
        // D s_906_22: write-var gs#406162 <= s_906_21
        fn_state.gs_406162 = s_906_21;
        // N s_906_23: jump b907
        return block_907(state, tracer, fn_state);
    }
    fn block_907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_907_0: read-var gs#406162:u8
        let s_907_0: bool = fn_state.gs_406162;
        // N s_907_1: branch s_907_0 b909 b908
        if s_907_0 {
            return block_909(state, tracer, fn_state);
        } else {
            return block_908(state, tracer, fn_state);
        };
    }
    fn block_908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_908_0: read-var u#32818:u8
        let s_908_0: u8 = fn_state.u_32818;
        // D s_908_1: read-var u#32819:u8
        let s_908_1: u8 = fn_state.u_32819;
        // D s_908_2: read-var u#32820:u8
        let s_908_2: u8 = fn_state.u_32820;
        // D s_908_3: read-var u#32821:u8
        let s_908_3: u8 = fn_state.u_32821;
        // D s_908_4: call decode_aarch32_instrs_QSUB_A1enc_A_txt(s_908_0, s_908_1, s_908_2, s_908_3)
        let s_908_4: () = decode_aarch32_instrs_QSUB_A1enc_A_txt(
            state,
            tracer,
            s_908_0,
            s_908_1,
            s_908_2,
            s_908_3,
        );
        // N s_908_5: return
        return;
    }
    fn block_909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_909_0: panic
        panic!("{:?}", ());
        // N s_909_1: return
        return;
    }
    fn block_910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_910_0: const #1u : u8
        let s_910_0: bool = true;
        // D s_910_1: write-var gs#406162 <= s_910_0
        fn_state.gs_406162 = s_910_0;
        // N s_910_2: jump b907
        return block_907(state, tracer, fn_state);
    }
    fn block_911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_911_0: const #1u : u8
        let s_911_0: bool = true;
        // D s_911_1: write-var gs#406159 <= s_911_0
        fn_state.gs_406159 = s_911_0;
        // N s_911_2: jump b905
        return block_905(state, tracer, fn_state);
    }
    fn block_912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_912_0: const #1u : u8
        let s_912_0: bool = true;
        // D s_912_1: write-var gs#406156 <= s_912_0
        fn_state.gs_406156 = s_912_0;
        // N s_912_2: jump b903
        return block_903(state, tracer, fn_state);
    }
    fn block_913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_913_0: read-var merge#var.1:struct
        let s_913_0: u32 = fn_state.merge_var._1;
        // D s_913_1: write-var u#32823 <= s_913_0
        fn_state.u_32823 = s_913_0;
        // C s_913_2: const #21s : i
        let s_913_2: i128 = 21;
        // D s_913_3: read-var u#32823:u32
        let s_913_3: u32 = fn_state.u_32823;
        // D s_913_4: cast zx s_913_3 -> bv
        let s_913_4: Bits = Bits::new(s_913_3 as u128, 32u16);
        // C s_913_5: const #1s : i64
        let s_913_5: i64 = 1;
        // C s_913_6: cast zx s_913_5 -> i
        let s_913_6: i128 = (i128::try_from(s_913_5).unwrap());
        // C s_913_7: const #6s : i
        let s_913_7: i128 = 6;
        // C s_913_8: add s_913_7 s_913_6
        let s_913_8: i128 = (s_913_7 + s_913_6);
        // D s_913_9: bit-extract s_913_4 s_913_2 s_913_8
        let s_913_9: Bits = (Bits::new(
            ((s_913_4) >> (s_913_2)).value(),
            u16::try_from(s_913_8).unwrap(),
        ));
        // D s_913_10: cast reint s_913_9 -> u8
        let s_913_10: u8 = (s_913_9.value() as u8);
        // D s_913_11: cast zx s_913_10 -> bv
        let s_913_11: Bits = Bits::new(s_913_10 as u128, 7u16);
        // C s_913_12: const #19u : u8
        let s_913_12: u8 = 19;
        // C s_913_13: cast zx s_913_12 -> bv
        let s_913_13: Bits = Bits::new(s_913_12 as u128, 7u16);
        // D s_913_14: cmp-eq s_913_11 s_913_13
        let s_913_14: bool = ((s_913_11) == (s_913_13));
        // N s_913_15: branch s_913_14 b2504 b914
        if s_913_14 {
            return block_2504(state, tracer, fn_state);
        } else {
            return block_914(state, tracer, fn_state);
        };
    }
    fn block_914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_914_0: const #0u : u8
        let s_914_0: bool = false;
        // D s_914_1: write-var gs#406170 <= s_914_0
        fn_state.gs_406170 = s_914_0;
        // N s_914_2: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_915_0: read-var gs#406170:u8
        let s_915_0: bool = fn_state.gs_406170;
        // D s_915_1: not s_915_0
        let s_915_1: bool = !s_915_0;
        // N s_915_2: branch s_915_1 b917 b916
        if s_915_1 {
            return block_917(state, tracer, fn_state);
        } else {
            return block_916(state, tracer, fn_state);
        };
    }
    fn block_916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_916_0: const #3096s : i
        let s_916_0: i128 = 3096;
        // C s_916_1: const #14696u : u32
        let s_916_1: u32 = 14696;
        // N s_916_2: write-reg s_916_1 <= s_916_0
        let s_916_2: () = {
            state.write_register::<i128>(s_916_1 as isize, s_916_0);
            tracer.write_register(s_916_1 as isize, s_916_0);
        };
        // C s_916_3: const #28s : i
        let s_916_3: i128 = 28;
        // C s_916_4: const #4s : i
        let s_916_4: i128 = 4;
        // D s_916_5: read-var u#32823:u32
        let s_916_5: u32 = fn_state.u_32823;
        // D s_916_6: cast zx s_916_5 -> bv
        let s_916_6: Bits = Bits::new(s_916_5 as u128, 32u16);
        // D s_916_7: bit-extract s_916_6 s_916_3 s_916_4
        let s_916_7: Bits = (Bits::new(
            ((s_916_6) >> (s_916_3)).value(),
            u16::try_from(s_916_4).unwrap(),
        ));
        // D s_916_8: cast reint s_916_7 -> u8
        let s_916_8: u8 = (s_916_7.value() as u8);
        // C s_916_9: const #20s : i
        let s_916_9: i128 = 20;
        // C s_916_10: const #1s : i
        let s_916_10: i128 = 1;
        // D s_916_11: read-var u#32823:u32
        let s_916_11: u32 = fn_state.u_32823;
        // D s_916_12: cast zx s_916_11 -> bv
        let s_916_12: Bits = Bits::new(s_916_11 as u128, 32u16);
        // D s_916_13: bit-extract s_916_12 s_916_9 s_916_10
        let s_916_13: Bits = (Bits::new(
            ((s_916_12) >> (s_916_9)).value(),
            u16::try_from(s_916_10).unwrap(),
        ));
        // D s_916_14: cast reint s_916_13 -> u8
        let s_916_14: bool = ((s_916_13.value()) != 0);
        // C s_916_15: const #16s : i
        let s_916_15: i128 = 16;
        // C s_916_16: const #4s : i
        let s_916_16: i128 = 4;
        // D s_916_17: read-var u#32823:u32
        let s_916_17: u32 = fn_state.u_32823;
        // D s_916_18: cast zx s_916_17 -> bv
        let s_916_18: Bits = Bits::new(s_916_17 as u128, 32u16);
        // D s_916_19: bit-extract s_916_18 s_916_15 s_916_16
        let s_916_19: Bits = (Bits::new(
            ((s_916_18) >> (s_916_15)).value(),
            u16::try_from(s_916_16).unwrap(),
        ));
        // D s_916_20: cast reint s_916_19 -> u8
        let s_916_20: u8 = (s_916_19.value() as u8);
        // C s_916_21: const #12s : i
        let s_916_21: i128 = 12;
        // C s_916_22: const #4s : i
        let s_916_22: i128 = 4;
        // D s_916_23: read-var u#32823:u32
        let s_916_23: u32 = fn_state.u_32823;
        // D s_916_24: cast zx s_916_23 -> bv
        let s_916_24: Bits = Bits::new(s_916_23 as u128, 32u16);
        // D s_916_25: bit-extract s_916_24 s_916_21 s_916_22
        let s_916_25: Bits = (Bits::new(
            ((s_916_24) >> (s_916_21)).value(),
            u16::try_from(s_916_22).unwrap(),
        ));
        // D s_916_26: cast reint s_916_25 -> u8
        let s_916_26: u8 = (s_916_25.value() as u8);
        // C s_916_27: const #0s : i
        let s_916_27: i128 = 0;
        // C s_916_28: const #12s : i
        let s_916_28: i128 = 12;
        // D s_916_29: read-var u#32823:u32
        let s_916_29: u32 = fn_state.u_32823;
        // D s_916_30: cast zx s_916_29 -> bv
        let s_916_30: Bits = Bits::new(s_916_29 as u128, 32u16);
        // D s_916_31: bit-extract s_916_30 s_916_27 s_916_28
        let s_916_31: Bits = (Bits::new(
            ((s_916_30) >> (s_916_27)).value(),
            u16::try_from(s_916_28).unwrap(),
        ));
        // D s_916_32: cast reint s_916_31 -> u12
        let s_916_32: u16 = (s_916_31.value() as u16);
        // D s_916_33: call decode_aarch32_instrs_RSB_i_A1enc_A_txt(s_916_8, s_916_14, s_916_20, s_916_26, s_916_32)
        let s_916_33: () = decode_aarch32_instrs_RSB_i_A1enc_A_txt(
            state,
            tracer,
            s_916_8,
            s_916_14,
            s_916_20,
            s_916_26,
            s_916_32,
        );
        // N s_916_34: return
        return;
    }
    fn block_917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_917_0: read-var merge#var.1:struct
        let s_917_0: u32 = fn_state.merge_var._1;
        // D s_917_1: write-var u#32830 <= s_917_0
        fn_state.u_32830 = s_917_0;
        // C s_917_2: const #21s : i
        let s_917_2: i128 = 21;
        // D s_917_3: read-var u#32830:u32
        let s_917_3: u32 = fn_state.u_32830;
        // D s_917_4: cast zx s_917_3 -> bv
        let s_917_4: Bits = Bits::new(s_917_3 as u128, 32u16);
        // C s_917_5: const #1s : i64
        let s_917_5: i64 = 1;
        // C s_917_6: cast zx s_917_5 -> i
        let s_917_6: i128 = (i128::try_from(s_917_5).unwrap());
        // C s_917_7: const #6s : i
        let s_917_7: i128 = 6;
        // C s_917_8: add s_917_7 s_917_6
        let s_917_8: i128 = (s_917_7 + s_917_6);
        // D s_917_9: bit-extract s_917_4 s_917_2 s_917_8
        let s_917_9: Bits = (Bits::new(
            ((s_917_4) >> (s_917_2)).value(),
            u16::try_from(s_917_8).unwrap(),
        ));
        // D s_917_10: cast reint s_917_9 -> u8
        let s_917_10: u8 = (s_917_9.value() as u8);
        // D s_917_11: cast zx s_917_10 -> bv
        let s_917_11: Bits = Bits::new(s_917_10 as u128, 7u16);
        // C s_917_12: const #3u : u8
        let s_917_12: u8 = 3;
        // C s_917_13: cast zx s_917_12 -> bv
        let s_917_13: Bits = Bits::new(s_917_12 as u128, 7u16);
        // D s_917_14: cmp-eq s_917_11 s_917_13
        let s_917_14: bool = ((s_917_11) == (s_917_13));
        // N s_917_15: branch s_917_14 b2503 b918
        if s_917_14 {
            return block_2503(state, tracer, fn_state);
        } else {
            return block_918(state, tracer, fn_state);
        };
    }
    fn block_918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_918_0: const #0u : u8
        let s_918_0: bool = false;
        // D s_918_1: write-var gs#406188 <= s_918_0
        fn_state.gs_406188 = s_918_0;
        // N s_918_2: jump b919
        return block_919(state, tracer, fn_state);
    }
    fn block_919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_919_0: read-var gs#406188:u8
        let s_919_0: bool = fn_state.gs_406188;
        // N s_919_1: branch s_919_0 b2499 b920
        if s_919_0 {
            return block_2499(state, tracer, fn_state);
        } else {
            return block_920(state, tracer, fn_state);
        };
    }
    fn block_920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_920_0: const #0u : u8
        let s_920_0: bool = false;
        // D s_920_1: write-var gs#406193 <= s_920_0
        fn_state.gs_406193 = s_920_0;
        // N s_920_2: jump b921
        return block_921(state, tracer, fn_state);
    }
    fn block_921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_921_0: read-var gs#406193:u8
        let s_921_0: bool = fn_state.gs_406193;
        // D s_921_1: not s_921_0
        let s_921_1: bool = !s_921_0;
        // N s_921_2: branch s_921_1 b923 b922
        if s_921_1 {
            return block_923(state, tracer, fn_state);
        } else {
            return block_922(state, tracer, fn_state);
        };
    }
    fn block_922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_922_0: const #3099s : i
        let s_922_0: i128 = 3099;
        // C s_922_1: const #14696u : u32
        let s_922_1: u32 = 14696;
        // N s_922_2: write-reg s_922_1 <= s_922_0
        let s_922_2: () = {
            state.write_register::<i128>(s_922_1 as isize, s_922_0);
            tracer.write_register(s_922_1 as isize, s_922_0);
        };
        // C s_922_3: const #28s : i
        let s_922_3: i128 = 28;
        // C s_922_4: const #4s : i
        let s_922_4: i128 = 4;
        // D s_922_5: read-var u#32830:u32
        let s_922_5: u32 = fn_state.u_32830;
        // D s_922_6: cast zx s_922_5 -> bv
        let s_922_6: Bits = Bits::new(s_922_5 as u128, 32u16);
        // D s_922_7: bit-extract s_922_6 s_922_3 s_922_4
        let s_922_7: Bits = (Bits::new(
            ((s_922_6) >> (s_922_3)).value(),
            u16::try_from(s_922_4).unwrap(),
        ));
        // D s_922_8: cast reint s_922_7 -> u8
        let s_922_8: u8 = (s_922_7.value() as u8);
        // C s_922_9: const #20s : i
        let s_922_9: i128 = 20;
        // C s_922_10: const #1s : i
        let s_922_10: i128 = 1;
        // D s_922_11: read-var u#32830:u32
        let s_922_11: u32 = fn_state.u_32830;
        // D s_922_12: cast zx s_922_11 -> bv
        let s_922_12: Bits = Bits::new(s_922_11 as u128, 32u16);
        // D s_922_13: bit-extract s_922_12 s_922_9 s_922_10
        let s_922_13: Bits = (Bits::new(
            ((s_922_12) >> (s_922_9)).value(),
            u16::try_from(s_922_10).unwrap(),
        ));
        // D s_922_14: cast reint s_922_13 -> u8
        let s_922_14: bool = ((s_922_13.value()) != 0);
        // C s_922_15: const #16s : i
        let s_922_15: i128 = 16;
        // C s_922_16: const #4s : i
        let s_922_16: i128 = 4;
        // D s_922_17: read-var u#32830:u32
        let s_922_17: u32 = fn_state.u_32830;
        // D s_922_18: cast zx s_922_17 -> bv
        let s_922_18: Bits = Bits::new(s_922_17 as u128, 32u16);
        // D s_922_19: bit-extract s_922_18 s_922_15 s_922_16
        let s_922_19: Bits = (Bits::new(
            ((s_922_18) >> (s_922_15)).value(),
            u16::try_from(s_922_16).unwrap(),
        ));
        // D s_922_20: cast reint s_922_19 -> u8
        let s_922_20: u8 = (s_922_19.value() as u8);
        // C s_922_21: const #12s : i
        let s_922_21: i128 = 12;
        // C s_922_22: const #4s : i
        let s_922_22: i128 = 4;
        // D s_922_23: read-var u#32830:u32
        let s_922_23: u32 = fn_state.u_32830;
        // D s_922_24: cast zx s_922_23 -> bv
        let s_922_24: Bits = Bits::new(s_922_23 as u128, 32u16);
        // D s_922_25: bit-extract s_922_24 s_922_21 s_922_22
        let s_922_25: Bits = (Bits::new(
            ((s_922_24) >> (s_922_21)).value(),
            u16::try_from(s_922_22).unwrap(),
        ));
        // D s_922_26: cast reint s_922_25 -> u8
        let s_922_26: u8 = (s_922_25.value() as u8);
        // C s_922_27: const #7s : i
        let s_922_27: i128 = 7;
        // C s_922_28: const #5s : i
        let s_922_28: i128 = 5;
        // D s_922_29: read-var u#32830:u32
        let s_922_29: u32 = fn_state.u_32830;
        // D s_922_30: cast zx s_922_29 -> bv
        let s_922_30: Bits = Bits::new(s_922_29 as u128, 32u16);
        // D s_922_31: bit-extract s_922_30 s_922_27 s_922_28
        let s_922_31: Bits = (Bits::new(
            ((s_922_30) >> (s_922_27)).value(),
            u16::try_from(s_922_28).unwrap(),
        ));
        // D s_922_32: cast reint s_922_31 -> u8
        let s_922_32: u8 = (s_922_31.value() as u8);
        // C s_922_33: const #5s : i
        let s_922_33: i128 = 5;
        // C s_922_34: const #2s : i
        let s_922_34: i128 = 2;
        // D s_922_35: read-var u#32830:u32
        let s_922_35: u32 = fn_state.u_32830;
        // D s_922_36: cast zx s_922_35 -> bv
        let s_922_36: Bits = Bits::new(s_922_35 as u128, 32u16);
        // D s_922_37: bit-extract s_922_36 s_922_33 s_922_34
        let s_922_37: Bits = (Bits::new(
            ((s_922_36) >> (s_922_33)).value(),
            u16::try_from(s_922_34).unwrap(),
        ));
        // D s_922_38: cast reint s_922_37 -> u8
        let s_922_38: u8 = (s_922_37.value() as u8);
        // C s_922_39: const #0s : i
        let s_922_39: i128 = 0;
        // C s_922_40: const #4s : i
        let s_922_40: i128 = 4;
        // D s_922_41: read-var u#32830:u32
        let s_922_41: u32 = fn_state.u_32830;
        // D s_922_42: cast zx s_922_41 -> bv
        let s_922_42: Bits = Bits::new(s_922_41 as u128, 32u16);
        // D s_922_43: bit-extract s_922_42 s_922_39 s_922_40
        let s_922_43: Bits = (Bits::new(
            ((s_922_42) >> (s_922_39)).value(),
            u16::try_from(s_922_40).unwrap(),
        ));
        // D s_922_44: cast reint s_922_43 -> u8
        let s_922_44: u8 = (s_922_43.value() as u8);
        // D s_922_45: call decode_aarch32_instrs_RSB_r_A1enc_A_txt(s_922_8, s_922_14, s_922_20, s_922_26, s_922_32, s_922_38, s_922_44)
        let s_922_45: () = decode_aarch32_instrs_RSB_r_A1enc_A_txt(
            state,
            tracer,
            s_922_8,
            s_922_14,
            s_922_20,
            s_922_26,
            s_922_32,
            s_922_38,
            s_922_44,
        );
        // N s_922_46: return
        return;
    }
    fn block_923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_923_0: read-var merge#var.1:struct
        let s_923_0: u32 = fn_state.merge_var._1;
        // D s_923_1: write-var u#32839 <= s_923_0
        fn_state.u_32839 = s_923_0;
        // C s_923_2: const #21s : i
        let s_923_2: i128 = 21;
        // D s_923_3: read-var u#32839:u32
        let s_923_3: u32 = fn_state.u_32839;
        // D s_923_4: cast zx s_923_3 -> bv
        let s_923_4: Bits = Bits::new(s_923_3 as u128, 32u16);
        // C s_923_5: const #1s : i64
        let s_923_5: i64 = 1;
        // C s_923_6: cast zx s_923_5 -> i
        let s_923_6: i128 = (i128::try_from(s_923_5).unwrap());
        // C s_923_7: const #6s : i
        let s_923_7: i128 = 6;
        // C s_923_8: add s_923_7 s_923_6
        let s_923_8: i128 = (s_923_7 + s_923_6);
        // D s_923_9: bit-extract s_923_4 s_923_2 s_923_8
        let s_923_9: Bits = (Bits::new(
            ((s_923_4) >> (s_923_2)).value(),
            u16::try_from(s_923_8).unwrap(),
        ));
        // D s_923_10: cast reint s_923_9 -> u8
        let s_923_10: u8 = (s_923_9.value() as u8);
        // D s_923_11: cast zx s_923_10 -> bv
        let s_923_11: Bits = Bits::new(s_923_10 as u128, 7u16);
        // C s_923_12: const #3u : u8
        let s_923_12: u8 = 3;
        // C s_923_13: cast zx s_923_12 -> bv
        let s_923_13: Bits = Bits::new(s_923_12 as u128, 7u16);
        // D s_923_14: cmp-eq s_923_11 s_923_13
        let s_923_14: bool = ((s_923_11) == (s_923_13));
        // N s_923_15: branch s_923_14 b2495 b924
        if s_923_14 {
            return block_2495(state, tracer, fn_state);
        } else {
            return block_924(state, tracer, fn_state);
        };
    }
    fn block_924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_924_0: const #0u : u8
        let s_924_0: bool = false;
        // D s_924_1: write-var gs#406218 <= s_924_0
        fn_state.gs_406218 = s_924_0;
        // N s_924_2: jump b925
        return block_925(state, tracer, fn_state);
    }
    fn block_925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_925_0: read-var gs#406218:u8
        let s_925_0: bool = fn_state.gs_406218;
        // N s_925_1: branch s_925_0 b2491 b926
        if s_925_0 {
            return block_2491(state, tracer, fn_state);
        } else {
            return block_926(state, tracer, fn_state);
        };
    }
    fn block_926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_926_0: const #0u : u8
        let s_926_0: bool = false;
        // D s_926_1: write-var gs#406223 <= s_926_0
        fn_state.gs_406223 = s_926_0;
        // N s_926_2: jump b927
        return block_927(state, tracer, fn_state);
    }
    fn block_927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_927_0: read-var gs#406223:u8
        let s_927_0: bool = fn_state.gs_406223;
        // D s_927_1: not s_927_0
        let s_927_1: bool = !s_927_0;
        // N s_927_2: branch s_927_1 b929 b928
        if s_927_1 {
            return block_929(state, tracer, fn_state);
        } else {
            return block_928(state, tracer, fn_state);
        };
    }
    fn block_928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_928_0: const #3101s : i
        let s_928_0: i128 = 3101;
        // C s_928_1: const #14696u : u32
        let s_928_1: u32 = 14696;
        // N s_928_2: write-reg s_928_1 <= s_928_0
        let s_928_2: () = {
            state.write_register::<i128>(s_928_1 as isize, s_928_0);
            tracer.write_register(s_928_1 as isize, s_928_0);
        };
        // C s_928_3: const #28s : i
        let s_928_3: i128 = 28;
        // C s_928_4: const #4s : i
        let s_928_4: i128 = 4;
        // D s_928_5: read-var u#32839:u32
        let s_928_5: u32 = fn_state.u_32839;
        // D s_928_6: cast zx s_928_5 -> bv
        let s_928_6: Bits = Bits::new(s_928_5 as u128, 32u16);
        // D s_928_7: bit-extract s_928_6 s_928_3 s_928_4
        let s_928_7: Bits = (Bits::new(
            ((s_928_6) >> (s_928_3)).value(),
            u16::try_from(s_928_4).unwrap(),
        ));
        // D s_928_8: cast reint s_928_7 -> u8
        let s_928_8: u8 = (s_928_7.value() as u8);
        // C s_928_9: const #20s : i
        let s_928_9: i128 = 20;
        // C s_928_10: const #1s : i
        let s_928_10: i128 = 1;
        // D s_928_11: read-var u#32839:u32
        let s_928_11: u32 = fn_state.u_32839;
        // D s_928_12: cast zx s_928_11 -> bv
        let s_928_12: Bits = Bits::new(s_928_11 as u128, 32u16);
        // D s_928_13: bit-extract s_928_12 s_928_9 s_928_10
        let s_928_13: Bits = (Bits::new(
            ((s_928_12) >> (s_928_9)).value(),
            u16::try_from(s_928_10).unwrap(),
        ));
        // D s_928_14: cast reint s_928_13 -> u8
        let s_928_14: bool = ((s_928_13.value()) != 0);
        // C s_928_15: const #16s : i
        let s_928_15: i128 = 16;
        // C s_928_16: const #4s : i
        let s_928_16: i128 = 4;
        // D s_928_17: read-var u#32839:u32
        let s_928_17: u32 = fn_state.u_32839;
        // D s_928_18: cast zx s_928_17 -> bv
        let s_928_18: Bits = Bits::new(s_928_17 as u128, 32u16);
        // D s_928_19: bit-extract s_928_18 s_928_15 s_928_16
        let s_928_19: Bits = (Bits::new(
            ((s_928_18) >> (s_928_15)).value(),
            u16::try_from(s_928_16).unwrap(),
        ));
        // D s_928_20: cast reint s_928_19 -> u8
        let s_928_20: u8 = (s_928_19.value() as u8);
        // C s_928_21: const #12s : i
        let s_928_21: i128 = 12;
        // C s_928_22: const #4s : i
        let s_928_22: i128 = 4;
        // D s_928_23: read-var u#32839:u32
        let s_928_23: u32 = fn_state.u_32839;
        // D s_928_24: cast zx s_928_23 -> bv
        let s_928_24: Bits = Bits::new(s_928_23 as u128, 32u16);
        // D s_928_25: bit-extract s_928_24 s_928_21 s_928_22
        let s_928_25: Bits = (Bits::new(
            ((s_928_24) >> (s_928_21)).value(),
            u16::try_from(s_928_22).unwrap(),
        ));
        // D s_928_26: cast reint s_928_25 -> u8
        let s_928_26: u8 = (s_928_25.value() as u8);
        // C s_928_27: const #8s : i
        let s_928_27: i128 = 8;
        // C s_928_28: const #4s : i
        let s_928_28: i128 = 4;
        // D s_928_29: read-var u#32839:u32
        let s_928_29: u32 = fn_state.u_32839;
        // D s_928_30: cast zx s_928_29 -> bv
        let s_928_30: Bits = Bits::new(s_928_29 as u128, 32u16);
        // D s_928_31: bit-extract s_928_30 s_928_27 s_928_28
        let s_928_31: Bits = (Bits::new(
            ((s_928_30) >> (s_928_27)).value(),
            u16::try_from(s_928_28).unwrap(),
        ));
        // D s_928_32: cast reint s_928_31 -> u8
        let s_928_32: u8 = (s_928_31.value() as u8);
        // C s_928_33: const #5s : i
        let s_928_33: i128 = 5;
        // C s_928_34: const #2s : i
        let s_928_34: i128 = 2;
        // D s_928_35: read-var u#32839:u32
        let s_928_35: u32 = fn_state.u_32839;
        // D s_928_36: cast zx s_928_35 -> bv
        let s_928_36: Bits = Bits::new(s_928_35 as u128, 32u16);
        // D s_928_37: bit-extract s_928_36 s_928_33 s_928_34
        let s_928_37: Bits = (Bits::new(
            ((s_928_36) >> (s_928_33)).value(),
            u16::try_from(s_928_34).unwrap(),
        ));
        // D s_928_38: cast reint s_928_37 -> u8
        let s_928_38: u8 = (s_928_37.value() as u8);
        // C s_928_39: const #0s : i
        let s_928_39: i128 = 0;
        // C s_928_40: const #4s : i
        let s_928_40: i128 = 4;
        // D s_928_41: read-var u#32839:u32
        let s_928_41: u32 = fn_state.u_32839;
        // D s_928_42: cast zx s_928_41 -> bv
        let s_928_42: Bits = Bits::new(s_928_41 as u128, 32u16);
        // D s_928_43: bit-extract s_928_42 s_928_39 s_928_40
        let s_928_43: Bits = (Bits::new(
            ((s_928_42) >> (s_928_39)).value(),
            u16::try_from(s_928_40).unwrap(),
        ));
        // D s_928_44: cast reint s_928_43 -> u8
        let s_928_44: u8 = (s_928_43.value() as u8);
        // D s_928_45: call decode_aarch32_instrs_RSB_rr_A1enc_A_txt(s_928_8, s_928_14, s_928_20, s_928_26, s_928_32, s_928_38, s_928_44)
        let s_928_45: () = decode_aarch32_instrs_RSB_rr_A1enc_A_txt(
            state,
            tracer,
            s_928_8,
            s_928_14,
            s_928_20,
            s_928_26,
            s_928_32,
            s_928_38,
            s_928_44,
        );
        // N s_928_46: return
        return;
    }
    fn block_929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_929_0: read-var merge#var.1:struct
        let s_929_0: u32 = fn_state.merge_var._1;
        // D s_929_1: write-var u#32848 <= s_929_0
        fn_state.u_32848 = s_929_0;
        // C s_929_2: const #21s : i
        let s_929_2: i128 = 21;
        // D s_929_3: read-var u#32848:u32
        let s_929_3: u32 = fn_state.u_32848;
        // D s_929_4: cast zx s_929_3 -> bv
        let s_929_4: Bits = Bits::new(s_929_3 as u128, 32u16);
        // C s_929_5: const #1s : i64
        let s_929_5: i64 = 1;
        // C s_929_6: cast zx s_929_5 -> i
        let s_929_6: i128 = (i128::try_from(s_929_5).unwrap());
        // C s_929_7: const #6s : i
        let s_929_7: i128 = 6;
        // C s_929_8: add s_929_7 s_929_6
        let s_929_8: i128 = (s_929_7 + s_929_6);
        // D s_929_9: bit-extract s_929_4 s_929_2 s_929_8
        let s_929_9: Bits = (Bits::new(
            ((s_929_4) >> (s_929_2)).value(),
            u16::try_from(s_929_8).unwrap(),
        ));
        // D s_929_10: cast reint s_929_9 -> u8
        let s_929_10: u8 = (s_929_9.value() as u8);
        // D s_929_11: cast zx s_929_10 -> bv
        let s_929_11: Bits = Bits::new(s_929_10 as u128, 7u16);
        // C s_929_12: const #23u : u8
        let s_929_12: u8 = 23;
        // C s_929_13: cast zx s_929_12 -> bv
        let s_929_13: Bits = Bits::new(s_929_12 as u128, 7u16);
        // D s_929_14: cmp-eq s_929_11 s_929_13
        let s_929_14: bool = ((s_929_11) == (s_929_13));
        // N s_929_15: branch s_929_14 b2487 b930
        if s_929_14 {
            return block_2487(state, tracer, fn_state);
        } else {
            return block_930(state, tracer, fn_state);
        };
    }
    fn block_930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_930_0: const #0u : u8
        let s_930_0: bool = false;
        // D s_930_1: write-var gs#406247 <= s_930_0
        fn_state.gs_406247 = s_930_0;
        // N s_930_2: jump b931
        return block_931(state, tracer, fn_state);
    }
    fn block_931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_931_0: read-var gs#406247:u8
        let s_931_0: bool = fn_state.gs_406247;
        // D s_931_1: not s_931_0
        let s_931_1: bool = !s_931_0;
        // N s_931_2: branch s_931_1 b933 b932
        if s_931_1 {
            return block_933(state, tracer, fn_state);
        } else {
            return block_932(state, tracer, fn_state);
        };
    }
    fn block_932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_932_0: const #3102s : i
        let s_932_0: i128 = 3102;
        // C s_932_1: const #14696u : u32
        let s_932_1: u32 = 14696;
        // N s_932_2: write-reg s_932_1 <= s_932_0
        let s_932_2: () = {
            state.write_register::<i128>(s_932_1 as isize, s_932_0);
            tracer.write_register(s_932_1 as isize, s_932_0);
        };
        // C s_932_3: const #28s : i
        let s_932_3: i128 = 28;
        // C s_932_4: const #4s : i
        let s_932_4: i128 = 4;
        // D s_932_5: read-var u#32848:u32
        let s_932_5: u32 = fn_state.u_32848;
        // D s_932_6: cast zx s_932_5 -> bv
        let s_932_6: Bits = Bits::new(s_932_5 as u128, 32u16);
        // D s_932_7: bit-extract s_932_6 s_932_3 s_932_4
        let s_932_7: Bits = (Bits::new(
            ((s_932_6) >> (s_932_3)).value(),
            u16::try_from(s_932_4).unwrap(),
        ));
        // D s_932_8: cast reint s_932_7 -> u8
        let s_932_8: u8 = (s_932_7.value() as u8);
        // C s_932_9: const #20s : i
        let s_932_9: i128 = 20;
        // C s_932_10: const #1s : i
        let s_932_10: i128 = 1;
        // D s_932_11: read-var u#32848:u32
        let s_932_11: u32 = fn_state.u_32848;
        // D s_932_12: cast zx s_932_11 -> bv
        let s_932_12: Bits = Bits::new(s_932_11 as u128, 32u16);
        // D s_932_13: bit-extract s_932_12 s_932_9 s_932_10
        let s_932_13: Bits = (Bits::new(
            ((s_932_12) >> (s_932_9)).value(),
            u16::try_from(s_932_10).unwrap(),
        ));
        // D s_932_14: cast reint s_932_13 -> u8
        let s_932_14: bool = ((s_932_13.value()) != 0);
        // C s_932_15: const #16s : i
        let s_932_15: i128 = 16;
        // C s_932_16: const #4s : i
        let s_932_16: i128 = 4;
        // D s_932_17: read-var u#32848:u32
        let s_932_17: u32 = fn_state.u_32848;
        // D s_932_18: cast zx s_932_17 -> bv
        let s_932_18: Bits = Bits::new(s_932_17 as u128, 32u16);
        // D s_932_19: bit-extract s_932_18 s_932_15 s_932_16
        let s_932_19: Bits = (Bits::new(
            ((s_932_18) >> (s_932_15)).value(),
            u16::try_from(s_932_16).unwrap(),
        ));
        // D s_932_20: cast reint s_932_19 -> u8
        let s_932_20: u8 = (s_932_19.value() as u8);
        // C s_932_21: const #12s : i
        let s_932_21: i128 = 12;
        // C s_932_22: const #4s : i
        let s_932_22: i128 = 4;
        // D s_932_23: read-var u#32848:u32
        let s_932_23: u32 = fn_state.u_32848;
        // D s_932_24: cast zx s_932_23 -> bv
        let s_932_24: Bits = Bits::new(s_932_23 as u128, 32u16);
        // D s_932_25: bit-extract s_932_24 s_932_21 s_932_22
        let s_932_25: Bits = (Bits::new(
            ((s_932_24) >> (s_932_21)).value(),
            u16::try_from(s_932_22).unwrap(),
        ));
        // D s_932_26: cast reint s_932_25 -> u8
        let s_932_26: u8 = (s_932_25.value() as u8);
        // C s_932_27: const #0s : i
        let s_932_27: i128 = 0;
        // C s_932_28: const #12s : i
        let s_932_28: i128 = 12;
        // D s_932_29: read-var u#32848:u32
        let s_932_29: u32 = fn_state.u_32848;
        // D s_932_30: cast zx s_932_29 -> bv
        let s_932_30: Bits = Bits::new(s_932_29 as u128, 32u16);
        // D s_932_31: bit-extract s_932_30 s_932_27 s_932_28
        let s_932_31: Bits = (Bits::new(
            ((s_932_30) >> (s_932_27)).value(),
            u16::try_from(s_932_28).unwrap(),
        ));
        // D s_932_32: cast reint s_932_31 -> u12
        let s_932_32: u16 = (s_932_31.value() as u16);
        // D s_932_33: call decode_aarch32_instrs_RSC_i_A1enc_A_txt(s_932_8, s_932_14, s_932_20, s_932_26, s_932_32)
        let s_932_33: () = decode_aarch32_instrs_RSC_i_A1enc_A_txt(
            state,
            tracer,
            s_932_8,
            s_932_14,
            s_932_20,
            s_932_26,
            s_932_32,
        );
        // N s_932_34: return
        return;
    }
    fn block_933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_933_0: read-var merge#var.1:struct
        let s_933_0: u32 = fn_state.merge_var._1;
        // D s_933_1: write-var u#32855 <= s_933_0
        fn_state.u_32855 = s_933_0;
        // C s_933_2: const #21s : i
        let s_933_2: i128 = 21;
        // D s_933_3: read-var u#32855:u32
        let s_933_3: u32 = fn_state.u_32855;
        // D s_933_4: cast zx s_933_3 -> bv
        let s_933_4: Bits = Bits::new(s_933_3 as u128, 32u16);
        // C s_933_5: const #1s : i64
        let s_933_5: i64 = 1;
        // C s_933_6: cast zx s_933_5 -> i
        let s_933_6: i128 = (i128::try_from(s_933_5).unwrap());
        // C s_933_7: const #6s : i
        let s_933_7: i128 = 6;
        // C s_933_8: add s_933_7 s_933_6
        let s_933_8: i128 = (s_933_7 + s_933_6);
        // D s_933_9: bit-extract s_933_4 s_933_2 s_933_8
        let s_933_9: Bits = (Bits::new(
            ((s_933_4) >> (s_933_2)).value(),
            u16::try_from(s_933_8).unwrap(),
        ));
        // D s_933_10: cast reint s_933_9 -> u8
        let s_933_10: u8 = (s_933_9.value() as u8);
        // D s_933_11: cast zx s_933_10 -> bv
        let s_933_11: Bits = Bits::new(s_933_10 as u128, 7u16);
        // C s_933_12: const #7u : u8
        let s_933_12: u8 = 7;
        // C s_933_13: cast zx s_933_12 -> bv
        let s_933_13: Bits = Bits::new(s_933_12 as u128, 7u16);
        // D s_933_14: cmp-eq s_933_11 s_933_13
        let s_933_14: bool = ((s_933_11) == (s_933_13));
        // N s_933_15: branch s_933_14 b2486 b934
        if s_933_14 {
            return block_2486(state, tracer, fn_state);
        } else {
            return block_934(state, tracer, fn_state);
        };
    }
    fn block_934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_934_0: const #0u : u8
        let s_934_0: bool = false;
        // D s_934_1: write-var gs#406265 <= s_934_0
        fn_state.gs_406265 = s_934_0;
        // N s_934_2: jump b935
        return block_935(state, tracer, fn_state);
    }
    fn block_935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_935_0: read-var gs#406265:u8
        let s_935_0: bool = fn_state.gs_406265;
        // N s_935_1: branch s_935_0 b2482 b936
        if s_935_0 {
            return block_2482(state, tracer, fn_state);
        } else {
            return block_936(state, tracer, fn_state);
        };
    }
    fn block_936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_936_0: const #0u : u8
        let s_936_0: bool = false;
        // D s_936_1: write-var gs#406270 <= s_936_0
        fn_state.gs_406270 = s_936_0;
        // N s_936_2: jump b937
        return block_937(state, tracer, fn_state);
    }
    fn block_937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_937_0: read-var gs#406270:u8
        let s_937_0: bool = fn_state.gs_406270;
        // D s_937_1: not s_937_0
        let s_937_1: bool = !s_937_0;
        // N s_937_2: branch s_937_1 b939 b938
        if s_937_1 {
            return block_939(state, tracer, fn_state);
        } else {
            return block_938(state, tracer, fn_state);
        };
    }
    fn block_938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_938_0: const #3103s : i
        let s_938_0: i128 = 3103;
        // C s_938_1: const #14696u : u32
        let s_938_1: u32 = 14696;
        // N s_938_2: write-reg s_938_1 <= s_938_0
        let s_938_2: () = {
            state.write_register::<i128>(s_938_1 as isize, s_938_0);
            tracer.write_register(s_938_1 as isize, s_938_0);
        };
        // C s_938_3: const #28s : i
        let s_938_3: i128 = 28;
        // C s_938_4: const #4s : i
        let s_938_4: i128 = 4;
        // D s_938_5: read-var u#32855:u32
        let s_938_5: u32 = fn_state.u_32855;
        // D s_938_6: cast zx s_938_5 -> bv
        let s_938_6: Bits = Bits::new(s_938_5 as u128, 32u16);
        // D s_938_7: bit-extract s_938_6 s_938_3 s_938_4
        let s_938_7: Bits = (Bits::new(
            ((s_938_6) >> (s_938_3)).value(),
            u16::try_from(s_938_4).unwrap(),
        ));
        // D s_938_8: cast reint s_938_7 -> u8
        let s_938_8: u8 = (s_938_7.value() as u8);
        // C s_938_9: const #20s : i
        let s_938_9: i128 = 20;
        // C s_938_10: const #1s : i
        let s_938_10: i128 = 1;
        // D s_938_11: read-var u#32855:u32
        let s_938_11: u32 = fn_state.u_32855;
        // D s_938_12: cast zx s_938_11 -> bv
        let s_938_12: Bits = Bits::new(s_938_11 as u128, 32u16);
        // D s_938_13: bit-extract s_938_12 s_938_9 s_938_10
        let s_938_13: Bits = (Bits::new(
            ((s_938_12) >> (s_938_9)).value(),
            u16::try_from(s_938_10).unwrap(),
        ));
        // D s_938_14: cast reint s_938_13 -> u8
        let s_938_14: bool = ((s_938_13.value()) != 0);
        // C s_938_15: const #16s : i
        let s_938_15: i128 = 16;
        // C s_938_16: const #4s : i
        let s_938_16: i128 = 4;
        // D s_938_17: read-var u#32855:u32
        let s_938_17: u32 = fn_state.u_32855;
        // D s_938_18: cast zx s_938_17 -> bv
        let s_938_18: Bits = Bits::new(s_938_17 as u128, 32u16);
        // D s_938_19: bit-extract s_938_18 s_938_15 s_938_16
        let s_938_19: Bits = (Bits::new(
            ((s_938_18) >> (s_938_15)).value(),
            u16::try_from(s_938_16).unwrap(),
        ));
        // D s_938_20: cast reint s_938_19 -> u8
        let s_938_20: u8 = (s_938_19.value() as u8);
        // C s_938_21: const #12s : i
        let s_938_21: i128 = 12;
        // C s_938_22: const #4s : i
        let s_938_22: i128 = 4;
        // D s_938_23: read-var u#32855:u32
        let s_938_23: u32 = fn_state.u_32855;
        // D s_938_24: cast zx s_938_23 -> bv
        let s_938_24: Bits = Bits::new(s_938_23 as u128, 32u16);
        // D s_938_25: bit-extract s_938_24 s_938_21 s_938_22
        let s_938_25: Bits = (Bits::new(
            ((s_938_24) >> (s_938_21)).value(),
            u16::try_from(s_938_22).unwrap(),
        ));
        // D s_938_26: cast reint s_938_25 -> u8
        let s_938_26: u8 = (s_938_25.value() as u8);
        // C s_938_27: const #7s : i
        let s_938_27: i128 = 7;
        // C s_938_28: const #5s : i
        let s_938_28: i128 = 5;
        // D s_938_29: read-var u#32855:u32
        let s_938_29: u32 = fn_state.u_32855;
        // D s_938_30: cast zx s_938_29 -> bv
        let s_938_30: Bits = Bits::new(s_938_29 as u128, 32u16);
        // D s_938_31: bit-extract s_938_30 s_938_27 s_938_28
        let s_938_31: Bits = (Bits::new(
            ((s_938_30) >> (s_938_27)).value(),
            u16::try_from(s_938_28).unwrap(),
        ));
        // D s_938_32: cast reint s_938_31 -> u8
        let s_938_32: u8 = (s_938_31.value() as u8);
        // C s_938_33: const #5s : i
        let s_938_33: i128 = 5;
        // C s_938_34: const #2s : i
        let s_938_34: i128 = 2;
        // D s_938_35: read-var u#32855:u32
        let s_938_35: u32 = fn_state.u_32855;
        // D s_938_36: cast zx s_938_35 -> bv
        let s_938_36: Bits = Bits::new(s_938_35 as u128, 32u16);
        // D s_938_37: bit-extract s_938_36 s_938_33 s_938_34
        let s_938_37: Bits = (Bits::new(
            ((s_938_36) >> (s_938_33)).value(),
            u16::try_from(s_938_34).unwrap(),
        ));
        // D s_938_38: cast reint s_938_37 -> u8
        let s_938_38: u8 = (s_938_37.value() as u8);
        // C s_938_39: const #0s : i
        let s_938_39: i128 = 0;
        // C s_938_40: const #4s : i
        let s_938_40: i128 = 4;
        // D s_938_41: read-var u#32855:u32
        let s_938_41: u32 = fn_state.u_32855;
        // D s_938_42: cast zx s_938_41 -> bv
        let s_938_42: Bits = Bits::new(s_938_41 as u128, 32u16);
        // D s_938_43: bit-extract s_938_42 s_938_39 s_938_40
        let s_938_43: Bits = (Bits::new(
            ((s_938_42) >> (s_938_39)).value(),
            u16::try_from(s_938_40).unwrap(),
        ));
        // D s_938_44: cast reint s_938_43 -> u8
        let s_938_44: u8 = (s_938_43.value() as u8);
        // D s_938_45: call decode_aarch32_instrs_RSC_r_A1enc_A_txt(s_938_8, s_938_14, s_938_20, s_938_26, s_938_32, s_938_38, s_938_44)
        let s_938_45: () = decode_aarch32_instrs_RSC_r_A1enc_A_txt(
            state,
            tracer,
            s_938_8,
            s_938_14,
            s_938_20,
            s_938_26,
            s_938_32,
            s_938_38,
            s_938_44,
        );
        // N s_938_46: return
        return;
    }
    fn block_939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_939_0: read-var merge#var.1:struct
        let s_939_0: u32 = fn_state.merge_var._1;
        // D s_939_1: write-var u#32864 <= s_939_0
        fn_state.u_32864 = s_939_0;
        // C s_939_2: const #21s : i
        let s_939_2: i128 = 21;
        // D s_939_3: read-var u#32864:u32
        let s_939_3: u32 = fn_state.u_32864;
        // D s_939_4: cast zx s_939_3 -> bv
        let s_939_4: Bits = Bits::new(s_939_3 as u128, 32u16);
        // C s_939_5: const #1s : i64
        let s_939_5: i64 = 1;
        // C s_939_6: cast zx s_939_5 -> i
        let s_939_6: i128 = (i128::try_from(s_939_5).unwrap());
        // C s_939_7: const #6s : i
        let s_939_7: i128 = 6;
        // C s_939_8: add s_939_7 s_939_6
        let s_939_8: i128 = (s_939_7 + s_939_6);
        // D s_939_9: bit-extract s_939_4 s_939_2 s_939_8
        let s_939_9: Bits = (Bits::new(
            ((s_939_4) >> (s_939_2)).value(),
            u16::try_from(s_939_8).unwrap(),
        ));
        // D s_939_10: cast reint s_939_9 -> u8
        let s_939_10: u8 = (s_939_9.value() as u8);
        // D s_939_11: cast zx s_939_10 -> bv
        let s_939_11: Bits = Bits::new(s_939_10 as u128, 7u16);
        // C s_939_12: const #7u : u8
        let s_939_12: u8 = 7;
        // C s_939_13: cast zx s_939_12 -> bv
        let s_939_13: Bits = Bits::new(s_939_12 as u128, 7u16);
        // D s_939_14: cmp-eq s_939_11 s_939_13
        let s_939_14: bool = ((s_939_11) == (s_939_13));
        // N s_939_15: branch s_939_14 b2478 b940
        if s_939_14 {
            return block_2478(state, tracer, fn_state);
        } else {
            return block_940(state, tracer, fn_state);
        };
    }
    fn block_940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_940_0: const #0u : u8
        let s_940_0: bool = false;
        // D s_940_1: write-var gs#406295 <= s_940_0
        fn_state.gs_406295 = s_940_0;
        // N s_940_2: jump b941
        return block_941(state, tracer, fn_state);
    }
    fn block_941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_941_0: read-var gs#406295:u8
        let s_941_0: bool = fn_state.gs_406295;
        // N s_941_1: branch s_941_0 b2474 b942
        if s_941_0 {
            return block_2474(state, tracer, fn_state);
        } else {
            return block_942(state, tracer, fn_state);
        };
    }
    fn block_942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_942_0: const #0u : u8
        let s_942_0: bool = false;
        // D s_942_1: write-var gs#406300 <= s_942_0
        fn_state.gs_406300 = s_942_0;
        // N s_942_2: jump b943
        return block_943(state, tracer, fn_state);
    }
    fn block_943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_943_0: read-var gs#406300:u8
        let s_943_0: bool = fn_state.gs_406300;
        // D s_943_1: not s_943_0
        let s_943_1: bool = !s_943_0;
        // N s_943_2: branch s_943_1 b945 b944
        if s_943_1 {
            return block_945(state, tracer, fn_state);
        } else {
            return block_944(state, tracer, fn_state);
        };
    }
    fn block_944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_944_0: const #3104s : i
        let s_944_0: i128 = 3104;
        // C s_944_1: const #14696u : u32
        let s_944_1: u32 = 14696;
        // N s_944_2: write-reg s_944_1 <= s_944_0
        let s_944_2: () = {
            state.write_register::<i128>(s_944_1 as isize, s_944_0);
            tracer.write_register(s_944_1 as isize, s_944_0);
        };
        // C s_944_3: const #28s : i
        let s_944_3: i128 = 28;
        // C s_944_4: const #4s : i
        let s_944_4: i128 = 4;
        // D s_944_5: read-var u#32864:u32
        let s_944_5: u32 = fn_state.u_32864;
        // D s_944_6: cast zx s_944_5 -> bv
        let s_944_6: Bits = Bits::new(s_944_5 as u128, 32u16);
        // D s_944_7: bit-extract s_944_6 s_944_3 s_944_4
        let s_944_7: Bits = (Bits::new(
            ((s_944_6) >> (s_944_3)).value(),
            u16::try_from(s_944_4).unwrap(),
        ));
        // D s_944_8: cast reint s_944_7 -> u8
        let s_944_8: u8 = (s_944_7.value() as u8);
        // C s_944_9: const #20s : i
        let s_944_9: i128 = 20;
        // C s_944_10: const #1s : i
        let s_944_10: i128 = 1;
        // D s_944_11: read-var u#32864:u32
        let s_944_11: u32 = fn_state.u_32864;
        // D s_944_12: cast zx s_944_11 -> bv
        let s_944_12: Bits = Bits::new(s_944_11 as u128, 32u16);
        // D s_944_13: bit-extract s_944_12 s_944_9 s_944_10
        let s_944_13: Bits = (Bits::new(
            ((s_944_12) >> (s_944_9)).value(),
            u16::try_from(s_944_10).unwrap(),
        ));
        // D s_944_14: cast reint s_944_13 -> u8
        let s_944_14: bool = ((s_944_13.value()) != 0);
        // C s_944_15: const #16s : i
        let s_944_15: i128 = 16;
        // C s_944_16: const #4s : i
        let s_944_16: i128 = 4;
        // D s_944_17: read-var u#32864:u32
        let s_944_17: u32 = fn_state.u_32864;
        // D s_944_18: cast zx s_944_17 -> bv
        let s_944_18: Bits = Bits::new(s_944_17 as u128, 32u16);
        // D s_944_19: bit-extract s_944_18 s_944_15 s_944_16
        let s_944_19: Bits = (Bits::new(
            ((s_944_18) >> (s_944_15)).value(),
            u16::try_from(s_944_16).unwrap(),
        ));
        // D s_944_20: cast reint s_944_19 -> u8
        let s_944_20: u8 = (s_944_19.value() as u8);
        // C s_944_21: const #12s : i
        let s_944_21: i128 = 12;
        // C s_944_22: const #4s : i
        let s_944_22: i128 = 4;
        // D s_944_23: read-var u#32864:u32
        let s_944_23: u32 = fn_state.u_32864;
        // D s_944_24: cast zx s_944_23 -> bv
        let s_944_24: Bits = Bits::new(s_944_23 as u128, 32u16);
        // D s_944_25: bit-extract s_944_24 s_944_21 s_944_22
        let s_944_25: Bits = (Bits::new(
            ((s_944_24) >> (s_944_21)).value(),
            u16::try_from(s_944_22).unwrap(),
        ));
        // D s_944_26: cast reint s_944_25 -> u8
        let s_944_26: u8 = (s_944_25.value() as u8);
        // C s_944_27: const #8s : i
        let s_944_27: i128 = 8;
        // C s_944_28: const #4s : i
        let s_944_28: i128 = 4;
        // D s_944_29: read-var u#32864:u32
        let s_944_29: u32 = fn_state.u_32864;
        // D s_944_30: cast zx s_944_29 -> bv
        let s_944_30: Bits = Bits::new(s_944_29 as u128, 32u16);
        // D s_944_31: bit-extract s_944_30 s_944_27 s_944_28
        let s_944_31: Bits = (Bits::new(
            ((s_944_30) >> (s_944_27)).value(),
            u16::try_from(s_944_28).unwrap(),
        ));
        // D s_944_32: cast reint s_944_31 -> u8
        let s_944_32: u8 = (s_944_31.value() as u8);
        // C s_944_33: const #5s : i
        let s_944_33: i128 = 5;
        // C s_944_34: const #2s : i
        let s_944_34: i128 = 2;
        // D s_944_35: read-var u#32864:u32
        let s_944_35: u32 = fn_state.u_32864;
        // D s_944_36: cast zx s_944_35 -> bv
        let s_944_36: Bits = Bits::new(s_944_35 as u128, 32u16);
        // D s_944_37: bit-extract s_944_36 s_944_33 s_944_34
        let s_944_37: Bits = (Bits::new(
            ((s_944_36) >> (s_944_33)).value(),
            u16::try_from(s_944_34).unwrap(),
        ));
        // D s_944_38: cast reint s_944_37 -> u8
        let s_944_38: u8 = (s_944_37.value() as u8);
        // C s_944_39: const #0s : i
        let s_944_39: i128 = 0;
        // C s_944_40: const #4s : i
        let s_944_40: i128 = 4;
        // D s_944_41: read-var u#32864:u32
        let s_944_41: u32 = fn_state.u_32864;
        // D s_944_42: cast zx s_944_41 -> bv
        let s_944_42: Bits = Bits::new(s_944_41 as u128, 32u16);
        // D s_944_43: bit-extract s_944_42 s_944_39 s_944_40
        let s_944_43: Bits = (Bits::new(
            ((s_944_42) >> (s_944_39)).value(),
            u16::try_from(s_944_40).unwrap(),
        ));
        // D s_944_44: cast reint s_944_43 -> u8
        let s_944_44: u8 = (s_944_43.value() as u8);
        // D s_944_45: call decode_aarch32_instrs_RSC_rr_A1enc_A_txt(s_944_8, s_944_14, s_944_20, s_944_26, s_944_32, s_944_38, s_944_44)
        let s_944_45: () = decode_aarch32_instrs_RSC_rr_A1enc_A_txt(
            state,
            tracer,
            s_944_8,
            s_944_14,
            s_944_20,
            s_944_26,
            s_944_32,
            s_944_38,
            s_944_44,
        );
        // N s_944_46: return
        return;
    }
    fn block_945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_945_0: read-var merge#var.1:struct
        let s_945_0: u32 = fn_state.merge_var._1;
        // D s_945_1: write-var u#32873 <= s_945_0
        fn_state.u_32873 = s_945_0;
        // C s_945_2: const #21s : i
        let s_945_2: i128 = 21;
        // D s_945_3: read-var u#32873:u32
        let s_945_3: u32 = fn_state.u_32873;
        // D s_945_4: cast zx s_945_3 -> bv
        let s_945_4: Bits = Bits::new(s_945_3 as u128, 32u16);
        // C s_945_5: const #1s : i64
        let s_945_5: i64 = 1;
        // C s_945_6: cast zx s_945_5 -> i
        let s_945_6: i128 = (i128::try_from(s_945_5).unwrap());
        // C s_945_7: const #6s : i
        let s_945_7: i128 = 6;
        // C s_945_8: add s_945_7 s_945_6
        let s_945_8: i128 = (s_945_7 + s_945_6);
        // D s_945_9: bit-extract s_945_4 s_945_2 s_945_8
        let s_945_9: Bits = (Bits::new(
            ((s_945_4) >> (s_945_2)).value(),
            u16::try_from(s_945_8).unwrap(),
        ));
        // D s_945_10: cast reint s_945_9 -> u8
        let s_945_10: u8 = (s_945_9.value() as u8);
        // D s_945_11: cast zx s_945_10 -> bv
        let s_945_11: Bits = Bits::new(s_945_10 as u128, 7u16);
        // C s_945_12: const #22u : u8
        let s_945_12: u8 = 22;
        // C s_945_13: cast zx s_945_12 -> bv
        let s_945_13: Bits = Bits::new(s_945_12 as u128, 7u16);
        // D s_945_14: cmp-eq s_945_11 s_945_13
        let s_945_14: bool = ((s_945_11) == (s_945_13));
        // N s_945_15: branch s_945_14 b2470 b946
        if s_945_14 {
            return block_2470(state, tracer, fn_state);
        } else {
            return block_946(state, tracer, fn_state);
        };
    }
    fn block_946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_946_0: const #0u : u8
        let s_946_0: bool = false;
        // D s_946_1: write-var gs#406324 <= s_946_0
        fn_state.gs_406324 = s_946_0;
        // N s_946_2: jump b947
        return block_947(state, tracer, fn_state);
    }
    fn block_947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_947_0: read-var gs#406324:u8
        let s_947_0: bool = fn_state.gs_406324;
        // D s_947_1: not s_947_0
        let s_947_1: bool = !s_947_0;
        // N s_947_2: branch s_947_1 b949 b948
        if s_947_1 {
            return block_949(state, tracer, fn_state);
        } else {
            return block_948(state, tracer, fn_state);
        };
    }
    fn block_948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_948_0: const #3113s : i
        let s_948_0: i128 = 3113;
        // C s_948_1: const #14696u : u32
        let s_948_1: u32 = 14696;
        // N s_948_2: write-reg s_948_1 <= s_948_0
        let s_948_2: () = {
            state.write_register::<i128>(s_948_1 as isize, s_948_0);
            tracer.write_register(s_948_1 as isize, s_948_0);
        };
        // C s_948_3: const #28s : i
        let s_948_3: i128 = 28;
        // C s_948_4: const #4s : i
        let s_948_4: i128 = 4;
        // D s_948_5: read-var u#32873:u32
        let s_948_5: u32 = fn_state.u_32873;
        // D s_948_6: cast zx s_948_5 -> bv
        let s_948_6: Bits = Bits::new(s_948_5 as u128, 32u16);
        // D s_948_7: bit-extract s_948_6 s_948_3 s_948_4
        let s_948_7: Bits = (Bits::new(
            ((s_948_6) >> (s_948_3)).value(),
            u16::try_from(s_948_4).unwrap(),
        ));
        // D s_948_8: cast reint s_948_7 -> u8
        let s_948_8: u8 = (s_948_7.value() as u8);
        // C s_948_9: const #20s : i
        let s_948_9: i128 = 20;
        // C s_948_10: const #1s : i
        let s_948_10: i128 = 1;
        // D s_948_11: read-var u#32873:u32
        let s_948_11: u32 = fn_state.u_32873;
        // D s_948_12: cast zx s_948_11 -> bv
        let s_948_12: Bits = Bits::new(s_948_11 as u128, 32u16);
        // D s_948_13: bit-extract s_948_12 s_948_9 s_948_10
        let s_948_13: Bits = (Bits::new(
            ((s_948_12) >> (s_948_9)).value(),
            u16::try_from(s_948_10).unwrap(),
        ));
        // D s_948_14: cast reint s_948_13 -> u8
        let s_948_14: bool = ((s_948_13.value()) != 0);
        // C s_948_15: const #16s : i
        let s_948_15: i128 = 16;
        // C s_948_16: const #4s : i
        let s_948_16: i128 = 4;
        // D s_948_17: read-var u#32873:u32
        let s_948_17: u32 = fn_state.u_32873;
        // D s_948_18: cast zx s_948_17 -> bv
        let s_948_18: Bits = Bits::new(s_948_17 as u128, 32u16);
        // D s_948_19: bit-extract s_948_18 s_948_15 s_948_16
        let s_948_19: Bits = (Bits::new(
            ((s_948_18) >> (s_948_15)).value(),
            u16::try_from(s_948_16).unwrap(),
        ));
        // D s_948_20: cast reint s_948_19 -> u8
        let s_948_20: u8 = (s_948_19.value() as u8);
        // C s_948_21: const #12s : i
        let s_948_21: i128 = 12;
        // C s_948_22: const #4s : i
        let s_948_22: i128 = 4;
        // D s_948_23: read-var u#32873:u32
        let s_948_23: u32 = fn_state.u_32873;
        // D s_948_24: cast zx s_948_23 -> bv
        let s_948_24: Bits = Bits::new(s_948_23 as u128, 32u16);
        // D s_948_25: bit-extract s_948_24 s_948_21 s_948_22
        let s_948_25: Bits = (Bits::new(
            ((s_948_24) >> (s_948_21)).value(),
            u16::try_from(s_948_22).unwrap(),
        ));
        // D s_948_26: cast reint s_948_25 -> u8
        let s_948_26: u8 = (s_948_25.value() as u8);
        // C s_948_27: const #0s : i
        let s_948_27: i128 = 0;
        // C s_948_28: const #12s : i
        let s_948_28: i128 = 12;
        // D s_948_29: read-var u#32873:u32
        let s_948_29: u32 = fn_state.u_32873;
        // D s_948_30: cast zx s_948_29 -> bv
        let s_948_30: Bits = Bits::new(s_948_29 as u128, 32u16);
        // D s_948_31: bit-extract s_948_30 s_948_27 s_948_28
        let s_948_31: Bits = (Bits::new(
            ((s_948_30) >> (s_948_27)).value(),
            u16::try_from(s_948_28).unwrap(),
        ));
        // D s_948_32: cast reint s_948_31 -> u12
        let s_948_32: u16 = (s_948_31.value() as u16);
        // D s_948_33: call decode_aarch32_instrs_SBC_i_A1enc_A_txt(s_948_8, s_948_14, s_948_20, s_948_26, s_948_32)
        let s_948_33: () = decode_aarch32_instrs_SBC_i_A1enc_A_txt(
            state,
            tracer,
            s_948_8,
            s_948_14,
            s_948_20,
            s_948_26,
            s_948_32,
        );
        // N s_948_34: return
        return;
    }
    fn block_949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_949_0: read-var merge#var.1:struct
        let s_949_0: u32 = fn_state.merge_var._1;
        // D s_949_1: write-var u#32880 <= s_949_0
        fn_state.u_32880 = s_949_0;
        // C s_949_2: const #21s : i
        let s_949_2: i128 = 21;
        // D s_949_3: read-var u#32880:u32
        let s_949_3: u32 = fn_state.u_32880;
        // D s_949_4: cast zx s_949_3 -> bv
        let s_949_4: Bits = Bits::new(s_949_3 as u128, 32u16);
        // C s_949_5: const #1s : i64
        let s_949_5: i64 = 1;
        // C s_949_6: cast zx s_949_5 -> i
        let s_949_6: i128 = (i128::try_from(s_949_5).unwrap());
        // C s_949_7: const #6s : i
        let s_949_7: i128 = 6;
        // C s_949_8: add s_949_7 s_949_6
        let s_949_8: i128 = (s_949_7 + s_949_6);
        // D s_949_9: bit-extract s_949_4 s_949_2 s_949_8
        let s_949_9: Bits = (Bits::new(
            ((s_949_4) >> (s_949_2)).value(),
            u16::try_from(s_949_8).unwrap(),
        ));
        // D s_949_10: cast reint s_949_9 -> u8
        let s_949_10: u8 = (s_949_9.value() as u8);
        // D s_949_11: cast zx s_949_10 -> bv
        let s_949_11: Bits = Bits::new(s_949_10 as u128, 7u16);
        // C s_949_12: const #6u : u8
        let s_949_12: u8 = 6;
        // C s_949_13: cast zx s_949_12 -> bv
        let s_949_13: Bits = Bits::new(s_949_12 as u128, 7u16);
        // D s_949_14: cmp-eq s_949_11 s_949_13
        let s_949_14: bool = ((s_949_11) == (s_949_13));
        // N s_949_15: branch s_949_14 b2469 b950
        if s_949_14 {
            return block_2469(state, tracer, fn_state);
        } else {
            return block_950(state, tracer, fn_state);
        };
    }
    fn block_950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_950_0: const #0u : u8
        let s_950_0: bool = false;
        // D s_950_1: write-var gs#406342 <= s_950_0
        fn_state.gs_406342 = s_950_0;
        // N s_950_2: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_951_0: read-var gs#406342:u8
        let s_951_0: bool = fn_state.gs_406342;
        // N s_951_1: branch s_951_0 b2465 b952
        if s_951_0 {
            return block_2465(state, tracer, fn_state);
        } else {
            return block_952(state, tracer, fn_state);
        };
    }
    fn block_952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_952_0: const #0u : u8
        let s_952_0: bool = false;
        // D s_952_1: write-var gs#406347 <= s_952_0
        fn_state.gs_406347 = s_952_0;
        // N s_952_2: jump b953
        return block_953(state, tracer, fn_state);
    }
    fn block_953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_953_0: read-var gs#406347:u8
        let s_953_0: bool = fn_state.gs_406347;
        // D s_953_1: not s_953_0
        let s_953_1: bool = !s_953_0;
        // N s_953_2: branch s_953_1 b955 b954
        if s_953_1 {
            return block_955(state, tracer, fn_state);
        } else {
            return block_954(state, tracer, fn_state);
        };
    }
    fn block_954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_954_0: const #3115s : i
        let s_954_0: i128 = 3115;
        // C s_954_1: const #14696u : u32
        let s_954_1: u32 = 14696;
        // N s_954_2: write-reg s_954_1 <= s_954_0
        let s_954_2: () = {
            state.write_register::<i128>(s_954_1 as isize, s_954_0);
            tracer.write_register(s_954_1 as isize, s_954_0);
        };
        // C s_954_3: const #28s : i
        let s_954_3: i128 = 28;
        // C s_954_4: const #4s : i
        let s_954_4: i128 = 4;
        // D s_954_5: read-var u#32880:u32
        let s_954_5: u32 = fn_state.u_32880;
        // D s_954_6: cast zx s_954_5 -> bv
        let s_954_6: Bits = Bits::new(s_954_5 as u128, 32u16);
        // D s_954_7: bit-extract s_954_6 s_954_3 s_954_4
        let s_954_7: Bits = (Bits::new(
            ((s_954_6) >> (s_954_3)).value(),
            u16::try_from(s_954_4).unwrap(),
        ));
        // D s_954_8: cast reint s_954_7 -> u8
        let s_954_8: u8 = (s_954_7.value() as u8);
        // C s_954_9: const #20s : i
        let s_954_9: i128 = 20;
        // C s_954_10: const #1s : i
        let s_954_10: i128 = 1;
        // D s_954_11: read-var u#32880:u32
        let s_954_11: u32 = fn_state.u_32880;
        // D s_954_12: cast zx s_954_11 -> bv
        let s_954_12: Bits = Bits::new(s_954_11 as u128, 32u16);
        // D s_954_13: bit-extract s_954_12 s_954_9 s_954_10
        let s_954_13: Bits = (Bits::new(
            ((s_954_12) >> (s_954_9)).value(),
            u16::try_from(s_954_10).unwrap(),
        ));
        // D s_954_14: cast reint s_954_13 -> u8
        let s_954_14: bool = ((s_954_13.value()) != 0);
        // C s_954_15: const #16s : i
        let s_954_15: i128 = 16;
        // C s_954_16: const #4s : i
        let s_954_16: i128 = 4;
        // D s_954_17: read-var u#32880:u32
        let s_954_17: u32 = fn_state.u_32880;
        // D s_954_18: cast zx s_954_17 -> bv
        let s_954_18: Bits = Bits::new(s_954_17 as u128, 32u16);
        // D s_954_19: bit-extract s_954_18 s_954_15 s_954_16
        let s_954_19: Bits = (Bits::new(
            ((s_954_18) >> (s_954_15)).value(),
            u16::try_from(s_954_16).unwrap(),
        ));
        // D s_954_20: cast reint s_954_19 -> u8
        let s_954_20: u8 = (s_954_19.value() as u8);
        // C s_954_21: const #12s : i
        let s_954_21: i128 = 12;
        // C s_954_22: const #4s : i
        let s_954_22: i128 = 4;
        // D s_954_23: read-var u#32880:u32
        let s_954_23: u32 = fn_state.u_32880;
        // D s_954_24: cast zx s_954_23 -> bv
        let s_954_24: Bits = Bits::new(s_954_23 as u128, 32u16);
        // D s_954_25: bit-extract s_954_24 s_954_21 s_954_22
        let s_954_25: Bits = (Bits::new(
            ((s_954_24) >> (s_954_21)).value(),
            u16::try_from(s_954_22).unwrap(),
        ));
        // D s_954_26: cast reint s_954_25 -> u8
        let s_954_26: u8 = (s_954_25.value() as u8);
        // C s_954_27: const #7s : i
        let s_954_27: i128 = 7;
        // C s_954_28: const #5s : i
        let s_954_28: i128 = 5;
        // D s_954_29: read-var u#32880:u32
        let s_954_29: u32 = fn_state.u_32880;
        // D s_954_30: cast zx s_954_29 -> bv
        let s_954_30: Bits = Bits::new(s_954_29 as u128, 32u16);
        // D s_954_31: bit-extract s_954_30 s_954_27 s_954_28
        let s_954_31: Bits = (Bits::new(
            ((s_954_30) >> (s_954_27)).value(),
            u16::try_from(s_954_28).unwrap(),
        ));
        // D s_954_32: cast reint s_954_31 -> u8
        let s_954_32: u8 = (s_954_31.value() as u8);
        // C s_954_33: const #5s : i
        let s_954_33: i128 = 5;
        // C s_954_34: const #2s : i
        let s_954_34: i128 = 2;
        // D s_954_35: read-var u#32880:u32
        let s_954_35: u32 = fn_state.u_32880;
        // D s_954_36: cast zx s_954_35 -> bv
        let s_954_36: Bits = Bits::new(s_954_35 as u128, 32u16);
        // D s_954_37: bit-extract s_954_36 s_954_33 s_954_34
        let s_954_37: Bits = (Bits::new(
            ((s_954_36) >> (s_954_33)).value(),
            u16::try_from(s_954_34).unwrap(),
        ));
        // D s_954_38: cast reint s_954_37 -> u8
        let s_954_38: u8 = (s_954_37.value() as u8);
        // C s_954_39: const #0s : i
        let s_954_39: i128 = 0;
        // C s_954_40: const #4s : i
        let s_954_40: i128 = 4;
        // D s_954_41: read-var u#32880:u32
        let s_954_41: u32 = fn_state.u_32880;
        // D s_954_42: cast zx s_954_41 -> bv
        let s_954_42: Bits = Bits::new(s_954_41 as u128, 32u16);
        // D s_954_43: bit-extract s_954_42 s_954_39 s_954_40
        let s_954_43: Bits = (Bits::new(
            ((s_954_42) >> (s_954_39)).value(),
            u16::try_from(s_954_40).unwrap(),
        ));
        // D s_954_44: cast reint s_954_43 -> u8
        let s_954_44: u8 = (s_954_43.value() as u8);
        // D s_954_45: call decode_aarch32_instrs_SBC_r_A1enc_A_txt(s_954_8, s_954_14, s_954_20, s_954_26, s_954_32, s_954_38, s_954_44)
        let s_954_45: () = decode_aarch32_instrs_SBC_r_A1enc_A_txt(
            state,
            tracer,
            s_954_8,
            s_954_14,
            s_954_20,
            s_954_26,
            s_954_32,
            s_954_38,
            s_954_44,
        );
        // N s_954_46: return
        return;
    }
    fn block_955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_955_0: read-var merge#var.1:struct
        let s_955_0: u32 = fn_state.merge_var._1;
        // D s_955_1: write-var u#32889 <= s_955_0
        fn_state.u_32889 = s_955_0;
        // C s_955_2: const #21s : i
        let s_955_2: i128 = 21;
        // D s_955_3: read-var u#32889:u32
        let s_955_3: u32 = fn_state.u_32889;
        // D s_955_4: cast zx s_955_3 -> bv
        let s_955_4: Bits = Bits::new(s_955_3 as u128, 32u16);
        // C s_955_5: const #1s : i64
        let s_955_5: i64 = 1;
        // C s_955_6: cast zx s_955_5 -> i
        let s_955_6: i128 = (i128::try_from(s_955_5).unwrap());
        // C s_955_7: const #6s : i
        let s_955_7: i128 = 6;
        // C s_955_8: add s_955_7 s_955_6
        let s_955_8: i128 = (s_955_7 + s_955_6);
        // D s_955_9: bit-extract s_955_4 s_955_2 s_955_8
        let s_955_9: Bits = (Bits::new(
            ((s_955_4) >> (s_955_2)).value(),
            u16::try_from(s_955_8).unwrap(),
        ));
        // D s_955_10: cast reint s_955_9 -> u8
        let s_955_10: u8 = (s_955_9.value() as u8);
        // D s_955_11: cast zx s_955_10 -> bv
        let s_955_11: Bits = Bits::new(s_955_10 as u128, 7u16);
        // C s_955_12: const #6u : u8
        let s_955_12: u8 = 6;
        // C s_955_13: cast zx s_955_12 -> bv
        let s_955_13: Bits = Bits::new(s_955_12 as u128, 7u16);
        // D s_955_14: cmp-eq s_955_11 s_955_13
        let s_955_14: bool = ((s_955_11) == (s_955_13));
        // N s_955_15: branch s_955_14 b2461 b956
        if s_955_14 {
            return block_2461(state, tracer, fn_state);
        } else {
            return block_956(state, tracer, fn_state);
        };
    }
    fn block_956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_956_0: const #0u : u8
        let s_956_0: bool = false;
        // D s_956_1: write-var gs#406372 <= s_956_0
        fn_state.gs_406372 = s_956_0;
        // N s_956_2: jump b957
        return block_957(state, tracer, fn_state);
    }
    fn block_957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_957_0: read-var gs#406372:u8
        let s_957_0: bool = fn_state.gs_406372;
        // N s_957_1: branch s_957_0 b2457 b958
        if s_957_0 {
            return block_2457(state, tracer, fn_state);
        } else {
            return block_958(state, tracer, fn_state);
        };
    }
    fn block_958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_958_0: const #0u : u8
        let s_958_0: bool = false;
        // D s_958_1: write-var gs#406377 <= s_958_0
        fn_state.gs_406377 = s_958_0;
        // N s_958_2: jump b959
        return block_959(state, tracer, fn_state);
    }
    fn block_959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_959_0: read-var gs#406377:u8
        let s_959_0: bool = fn_state.gs_406377;
        // D s_959_1: not s_959_0
        let s_959_1: bool = !s_959_0;
        // N s_959_2: branch s_959_1 b961 b960
        if s_959_1 {
            return block_961(state, tracer, fn_state);
        } else {
            return block_960(state, tracer, fn_state);
        };
    }
    fn block_960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_960_0: const #3118s : i
        let s_960_0: i128 = 3118;
        // C s_960_1: const #14696u : u32
        let s_960_1: u32 = 14696;
        // N s_960_2: write-reg s_960_1 <= s_960_0
        let s_960_2: () = {
            state.write_register::<i128>(s_960_1 as isize, s_960_0);
            tracer.write_register(s_960_1 as isize, s_960_0);
        };
        // C s_960_3: const #28s : i
        let s_960_3: i128 = 28;
        // C s_960_4: const #4s : i
        let s_960_4: i128 = 4;
        // D s_960_5: read-var u#32889:u32
        let s_960_5: u32 = fn_state.u_32889;
        // D s_960_6: cast zx s_960_5 -> bv
        let s_960_6: Bits = Bits::new(s_960_5 as u128, 32u16);
        // D s_960_7: bit-extract s_960_6 s_960_3 s_960_4
        let s_960_7: Bits = (Bits::new(
            ((s_960_6) >> (s_960_3)).value(),
            u16::try_from(s_960_4).unwrap(),
        ));
        // D s_960_8: cast reint s_960_7 -> u8
        let s_960_8: u8 = (s_960_7.value() as u8);
        // C s_960_9: const #20s : i
        let s_960_9: i128 = 20;
        // C s_960_10: const #1s : i
        let s_960_10: i128 = 1;
        // D s_960_11: read-var u#32889:u32
        let s_960_11: u32 = fn_state.u_32889;
        // D s_960_12: cast zx s_960_11 -> bv
        let s_960_12: Bits = Bits::new(s_960_11 as u128, 32u16);
        // D s_960_13: bit-extract s_960_12 s_960_9 s_960_10
        let s_960_13: Bits = (Bits::new(
            ((s_960_12) >> (s_960_9)).value(),
            u16::try_from(s_960_10).unwrap(),
        ));
        // D s_960_14: cast reint s_960_13 -> u8
        let s_960_14: bool = ((s_960_13.value()) != 0);
        // C s_960_15: const #16s : i
        let s_960_15: i128 = 16;
        // C s_960_16: const #4s : i
        let s_960_16: i128 = 4;
        // D s_960_17: read-var u#32889:u32
        let s_960_17: u32 = fn_state.u_32889;
        // D s_960_18: cast zx s_960_17 -> bv
        let s_960_18: Bits = Bits::new(s_960_17 as u128, 32u16);
        // D s_960_19: bit-extract s_960_18 s_960_15 s_960_16
        let s_960_19: Bits = (Bits::new(
            ((s_960_18) >> (s_960_15)).value(),
            u16::try_from(s_960_16).unwrap(),
        ));
        // D s_960_20: cast reint s_960_19 -> u8
        let s_960_20: u8 = (s_960_19.value() as u8);
        // C s_960_21: const #12s : i
        let s_960_21: i128 = 12;
        // C s_960_22: const #4s : i
        let s_960_22: i128 = 4;
        // D s_960_23: read-var u#32889:u32
        let s_960_23: u32 = fn_state.u_32889;
        // D s_960_24: cast zx s_960_23 -> bv
        let s_960_24: Bits = Bits::new(s_960_23 as u128, 32u16);
        // D s_960_25: bit-extract s_960_24 s_960_21 s_960_22
        let s_960_25: Bits = (Bits::new(
            ((s_960_24) >> (s_960_21)).value(),
            u16::try_from(s_960_22).unwrap(),
        ));
        // D s_960_26: cast reint s_960_25 -> u8
        let s_960_26: u8 = (s_960_25.value() as u8);
        // C s_960_27: const #8s : i
        let s_960_27: i128 = 8;
        // C s_960_28: const #4s : i
        let s_960_28: i128 = 4;
        // D s_960_29: read-var u#32889:u32
        let s_960_29: u32 = fn_state.u_32889;
        // D s_960_30: cast zx s_960_29 -> bv
        let s_960_30: Bits = Bits::new(s_960_29 as u128, 32u16);
        // D s_960_31: bit-extract s_960_30 s_960_27 s_960_28
        let s_960_31: Bits = (Bits::new(
            ((s_960_30) >> (s_960_27)).value(),
            u16::try_from(s_960_28).unwrap(),
        ));
        // D s_960_32: cast reint s_960_31 -> u8
        let s_960_32: u8 = (s_960_31.value() as u8);
        // C s_960_33: const #5s : i
        let s_960_33: i128 = 5;
        // C s_960_34: const #2s : i
        let s_960_34: i128 = 2;
        // D s_960_35: read-var u#32889:u32
        let s_960_35: u32 = fn_state.u_32889;
        // D s_960_36: cast zx s_960_35 -> bv
        let s_960_36: Bits = Bits::new(s_960_35 as u128, 32u16);
        // D s_960_37: bit-extract s_960_36 s_960_33 s_960_34
        let s_960_37: Bits = (Bits::new(
            ((s_960_36) >> (s_960_33)).value(),
            u16::try_from(s_960_34).unwrap(),
        ));
        // D s_960_38: cast reint s_960_37 -> u8
        let s_960_38: u8 = (s_960_37.value() as u8);
        // C s_960_39: const #0s : i
        let s_960_39: i128 = 0;
        // C s_960_40: const #4s : i
        let s_960_40: i128 = 4;
        // D s_960_41: read-var u#32889:u32
        let s_960_41: u32 = fn_state.u_32889;
        // D s_960_42: cast zx s_960_41 -> bv
        let s_960_42: Bits = Bits::new(s_960_41 as u128, 32u16);
        // D s_960_43: bit-extract s_960_42 s_960_39 s_960_40
        let s_960_43: Bits = (Bits::new(
            ((s_960_42) >> (s_960_39)).value(),
            u16::try_from(s_960_40).unwrap(),
        ));
        // D s_960_44: cast reint s_960_43 -> u8
        let s_960_44: u8 = (s_960_43.value() as u8);
        // D s_960_45: call decode_aarch32_instrs_SBC_rr_A1enc_A_txt(s_960_8, s_960_14, s_960_20, s_960_26, s_960_32, s_960_38, s_960_44)
        let s_960_45: () = decode_aarch32_instrs_SBC_rr_A1enc_A_txt(
            state,
            tracer,
            s_960_8,
            s_960_14,
            s_960_20,
            s_960_26,
            s_960_32,
            s_960_38,
            s_960_44,
        );
        // N s_960_46: return
        return;
    }
    fn block_961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_961_0: read-var merge#var.1:struct
        let s_961_0: u32 = fn_state.merge_var._1;
        // D s_961_1: write-var u#32898 <= s_961_0
        fn_state.u_32898 = s_961_0;
        // C s_961_2: const #0s : i
        let s_961_2: i128 = 0;
        // D s_961_3: read-var u#32898:u32
        let s_961_3: u32 = fn_state.u_32898;
        // D s_961_4: cast zx s_961_3 -> bv
        let s_961_4: Bits = Bits::new(s_961_3 as u128, 32u16);
        // C s_961_5: const #1s : i64
        let s_961_5: i64 = 1;
        // C s_961_6: cast zx s_961_5 -> i
        let s_961_6: i128 = (i128::try_from(s_961_5).unwrap());
        // C s_961_7: const #27s : i
        let s_961_7: i128 = 27;
        // C s_961_8: add s_961_7 s_961_6
        let s_961_8: i128 = (s_961_7 + s_961_6);
        // D s_961_9: bit-extract s_961_4 s_961_2 s_961_8
        let s_961_9: Bits = (Bits::new(
            ((s_961_4) >> (s_961_2)).value(),
            u16::try_from(s_961_8).unwrap(),
        ));
        // D s_961_10: cast reint s_961_9 -> u28
        let s_961_10: u32 = (s_961_9.value() as u32);
        // D s_961_11: cast zx s_961_10 -> bv
        let s_961_11: Bits = Bits::new(s_961_10 as u128, 28u16);
        // C s_961_12: const #52490244u : u28
        let s_961_12: u32 = 52490244;
        // C s_961_13: cast zx s_961_12 -> bv
        let s_961_13: Bits = Bits::new(s_961_12 as u128, 28u16);
        // D s_961_14: cmp-eq s_961_11 s_961_13
        let s_961_14: bool = ((s_961_11) == (s_961_13));
        // N s_961_15: branch s_961_14 b2453 b962
        if s_961_14 {
            return block_2453(state, tracer, fn_state);
        } else {
            return block_962(state, tracer, fn_state);
        };
    }
    fn block_962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_962_0: const #0u : u8
        let s_962_0: bool = false;
        // D s_962_1: write-var gs#406401 <= s_962_0
        fn_state.gs_406401 = s_962_0;
        // N s_962_2: jump b963
        return block_963(state, tracer, fn_state);
    }
    fn block_963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_963_0: read-var gs#406401:u8
        let s_963_0: bool = fn_state.gs_406401;
        // D s_963_1: not s_963_0
        let s_963_1: bool = !s_963_0;
        // N s_963_2: branch s_963_1 b988 b964
        if s_963_1 {
            return block_988(state, tracer, fn_state);
        } else {
            return block_964(state, tracer, fn_state);
        };
    }
    fn block_964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_964_0: const #3127s : i
        let s_964_0: i128 = 3127;
        // C s_964_1: const #14696u : u32
        let s_964_1: u32 = 14696;
        // N s_964_2: write-reg s_964_1 <= s_964_0
        let s_964_2: () = {
            state.write_register::<i128>(s_964_1 as isize, s_964_0);
            tracer.write_register(s_964_1 as isize, s_964_0);
        };
        // C s_964_3: const #28s : i
        let s_964_3: i128 = 28;
        // C s_964_4: const #4s : i
        let s_964_4: i128 = 4;
        // D s_964_5: read-var u#32898:u32
        let s_964_5: u32 = fn_state.u_32898;
        // D s_964_6: cast zx s_964_5 -> bv
        let s_964_6: Bits = Bits::new(s_964_5 as u128, 32u16);
        // D s_964_7: bit-extract s_964_6 s_964_3 s_964_4
        let s_964_7: Bits = (Bits::new(
            ((s_964_6) >> (s_964_3)).value(),
            u16::try_from(s_964_4).unwrap(),
        ));
        // D s_964_8: cast reint s_964_7 -> u8
        let s_964_8: u8 = (s_964_7.value() as u8);
        // D s_964_9: write-var u#32899 <= s_964_8
        fn_state.u_32899 = s_964_8;
        // C s_964_10: const #12s : i
        let s_964_10: i128 = 12;
        // D s_964_11: read-var u#32898:u32
        let s_964_11: u32 = fn_state.u_32898;
        // D s_964_12: cast zx s_964_11 -> bv
        let s_964_12: Bits = Bits::new(s_964_11 as u128, 32u16);
        // C s_964_13: const #1u : u64
        let s_964_13: u64 = 1;
        // D s_964_14: bit-extract s_964_12 s_964_10 s_964_13
        let s_964_14: Bits = (Bits::new(
            ((s_964_12) >> (s_964_10)).value(),
            u16::try_from(s_964_13).unwrap(),
        ));
        // D s_964_15: cast reint s_964_14 -> u8
        let s_964_15: bool = ((s_964_14.value()) != 0);
        // C s_964_16: const #0s : i
        let s_964_16: i128 = 0;
        // C s_964_17: const #0u : u64
        let s_964_17: u64 = 0;
        // D s_964_18: cast zx s_964_15 -> u64
        let s_964_18: u64 = (s_964_15 as u64);
        // C s_964_19: const #1u : u64
        let s_964_19: u64 = 1;
        // D s_964_20: and s_964_18 s_964_19
        let s_964_20: u64 = ((s_964_18) & (s_964_19));
        // D s_964_21: cmp-eq s_964_20 s_964_19
        let s_964_21: bool = ((s_964_20) == (s_964_19));
        // D s_964_22: lsl s_964_18 s_964_16
        let s_964_22: u64 = s_964_18 << s_964_16;
        // D s_964_23: or s_964_17 s_964_22
        let s_964_23: u64 = ((s_964_17) | (s_964_22));
        // D s_964_24: cmpl s_964_22
        let s_964_24: u64 = !s_964_22;
        // D s_964_25: and s_964_17 s_964_24
        let s_964_25: u64 = ((s_964_17) & (s_964_24));
        // D s_964_26: select s_964_21 s_964_23 s_964_25
        let s_964_26: u64 = if s_964_21 { s_964_23 } else { s_964_25 };
        // D s_964_27: cast trunc s_964_26 -> u8
        let s_964_27: bool = ((s_964_26) != 0);
        // D s_964_28: cast zx s_964_27 -> bv
        let s_964_28: Bits = Bits::new(s_964_27 as u128, 1u16);
        // C s_964_29: const #1u : u8
        let s_964_29: bool = true;
        // C s_964_30: cast zx s_964_29 -> bv
        let s_964_30: Bits = Bits::new(s_964_29 as u128, 1u16);
        // D s_964_31: cmp-ne s_964_28 s_964_30
        let s_964_31: bool = ((s_964_28) != (s_964_30));
        // N s_964_32: branch s_964_31 b987 b965
        if s_964_31 {
            return block_987(state, tracer, fn_state);
        } else {
            return block_965(state, tracer, fn_state);
        };
    }
    fn block_965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_965_0: const #13s : i
        let s_965_0: i128 = 13;
        // D s_965_1: read-var u#32898:u32
        let s_965_1: u32 = fn_state.u_32898;
        // D s_965_2: cast zx s_965_1 -> bv
        let s_965_2: Bits = Bits::new(s_965_1 as u128, 32u16);
        // C s_965_3: const #1u : u64
        let s_965_3: u64 = 1;
        // D s_965_4: bit-extract s_965_2 s_965_0 s_965_3
        let s_965_4: Bits = (Bits::new(
            ((s_965_2) >> (s_965_0)).value(),
            u16::try_from(s_965_3).unwrap(),
        ));
        // D s_965_5: cast reint s_965_4 -> u8
        let s_965_5: bool = ((s_965_4.value()) != 0);
        // C s_965_6: const #0s : i
        let s_965_6: i128 = 0;
        // C s_965_7: const #0u : u64
        let s_965_7: u64 = 0;
        // D s_965_8: cast zx s_965_5 -> u64
        let s_965_8: u64 = (s_965_5 as u64);
        // C s_965_9: const #1u : u64
        let s_965_9: u64 = 1;
        // D s_965_10: and s_965_8 s_965_9
        let s_965_10: u64 = ((s_965_8) & (s_965_9));
        // D s_965_11: cmp-eq s_965_10 s_965_9
        let s_965_11: bool = ((s_965_10) == (s_965_9));
        // D s_965_12: lsl s_965_8 s_965_6
        let s_965_12: u64 = s_965_8 << s_965_6;
        // D s_965_13: or s_965_7 s_965_12
        let s_965_13: u64 = ((s_965_7) | (s_965_12));
        // D s_965_14: cmpl s_965_12
        let s_965_14: u64 = !s_965_12;
        // D s_965_15: and s_965_7 s_965_14
        let s_965_15: u64 = ((s_965_7) & (s_965_14));
        // D s_965_16: select s_965_11 s_965_13 s_965_15
        let s_965_16: u64 = if s_965_11 { s_965_13 } else { s_965_15 };
        // D s_965_17: cast trunc s_965_16 -> u8
        let s_965_17: bool = ((s_965_16) != 0);
        // D s_965_18: cast zx s_965_17 -> bv
        let s_965_18: Bits = Bits::new(s_965_17 as u128, 1u16);
        // C s_965_19: const #1u : u8
        let s_965_19: bool = true;
        // C s_965_20: cast zx s_965_19 -> bv
        let s_965_20: Bits = Bits::new(s_965_19 as u128, 1u16);
        // D s_965_21: cmp-ne s_965_18 s_965_20
        let s_965_21: bool = ((s_965_18) != (s_965_20));
        // D s_965_22: write-var gs#406410 <= s_965_21
        fn_state.gs_406410 = s_965_21;
        // N s_965_23: jump b966
        return block_966(state, tracer, fn_state);
    }
    fn block_966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_966_0: read-var gs#406410:u8
        let s_966_0: bool = fn_state.gs_406410;
        // N s_966_1: branch s_966_0 b986 b967
        if s_966_0 {
            return block_986(state, tracer, fn_state);
        } else {
            return block_967(state, tracer, fn_state);
        };
    }
    fn block_967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_967_0: const #14s : i
        let s_967_0: i128 = 14;
        // D s_967_1: read-var u#32898:u32
        let s_967_1: u32 = fn_state.u_32898;
        // D s_967_2: cast zx s_967_1 -> bv
        let s_967_2: Bits = Bits::new(s_967_1 as u128, 32u16);
        // C s_967_3: const #1u : u64
        let s_967_3: u64 = 1;
        // D s_967_4: bit-extract s_967_2 s_967_0 s_967_3
        let s_967_4: Bits = (Bits::new(
            ((s_967_2) >> (s_967_0)).value(),
            u16::try_from(s_967_3).unwrap(),
        ));
        // D s_967_5: cast reint s_967_4 -> u8
        let s_967_5: bool = ((s_967_4.value()) != 0);
        // C s_967_6: const #0s : i
        let s_967_6: i128 = 0;
        // C s_967_7: const #0u : u64
        let s_967_7: u64 = 0;
        // D s_967_8: cast zx s_967_5 -> u64
        let s_967_8: u64 = (s_967_5 as u64);
        // C s_967_9: const #1u : u64
        let s_967_9: u64 = 1;
        // D s_967_10: and s_967_8 s_967_9
        let s_967_10: u64 = ((s_967_8) & (s_967_9));
        // D s_967_11: cmp-eq s_967_10 s_967_9
        let s_967_11: bool = ((s_967_10) == (s_967_9));
        // D s_967_12: lsl s_967_8 s_967_6
        let s_967_12: u64 = s_967_8 << s_967_6;
        // D s_967_13: or s_967_7 s_967_12
        let s_967_13: u64 = ((s_967_7) | (s_967_12));
        // D s_967_14: cmpl s_967_12
        let s_967_14: u64 = !s_967_12;
        // D s_967_15: and s_967_7 s_967_14
        let s_967_15: u64 = ((s_967_7) & (s_967_14));
        // D s_967_16: select s_967_11 s_967_13 s_967_15
        let s_967_16: u64 = if s_967_11 { s_967_13 } else { s_967_15 };
        // D s_967_17: cast trunc s_967_16 -> u8
        let s_967_17: bool = ((s_967_16) != 0);
        // D s_967_18: cast zx s_967_17 -> bv
        let s_967_18: Bits = Bits::new(s_967_17 as u128, 1u16);
        // C s_967_19: const #1u : u8
        let s_967_19: bool = true;
        // C s_967_20: cast zx s_967_19 -> bv
        let s_967_20: Bits = Bits::new(s_967_19 as u128, 1u16);
        // D s_967_21: cmp-ne s_967_18 s_967_20
        let s_967_21: bool = ((s_967_18) != (s_967_20));
        // D s_967_22: write-var gs#406413 <= s_967_21
        fn_state.gs_406413 = s_967_21;
        // N s_967_23: jump b968
        return block_968(state, tracer, fn_state);
    }
    fn block_968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_968_0: read-var gs#406413:u8
        let s_968_0: bool = fn_state.gs_406413;
        // N s_968_1: branch s_968_0 b985 b969
        if s_968_0 {
            return block_985(state, tracer, fn_state);
        } else {
            return block_969(state, tracer, fn_state);
        };
    }
    fn block_969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_969_0: const #15s : i
        let s_969_0: i128 = 15;
        // D s_969_1: read-var u#32898:u32
        let s_969_1: u32 = fn_state.u_32898;
        // D s_969_2: cast zx s_969_1 -> bv
        let s_969_2: Bits = Bits::new(s_969_1 as u128, 32u16);
        // C s_969_3: const #1u : u64
        let s_969_3: u64 = 1;
        // D s_969_4: bit-extract s_969_2 s_969_0 s_969_3
        let s_969_4: Bits = (Bits::new(
            ((s_969_2) >> (s_969_0)).value(),
            u16::try_from(s_969_3).unwrap(),
        ));
        // D s_969_5: cast reint s_969_4 -> u8
        let s_969_5: bool = ((s_969_4.value()) != 0);
        // C s_969_6: const #0s : i
        let s_969_6: i128 = 0;
        // C s_969_7: const #0u : u64
        let s_969_7: u64 = 0;
        // D s_969_8: cast zx s_969_5 -> u64
        let s_969_8: u64 = (s_969_5 as u64);
        // C s_969_9: const #1u : u64
        let s_969_9: u64 = 1;
        // D s_969_10: and s_969_8 s_969_9
        let s_969_10: u64 = ((s_969_8) & (s_969_9));
        // D s_969_11: cmp-eq s_969_10 s_969_9
        let s_969_11: bool = ((s_969_10) == (s_969_9));
        // D s_969_12: lsl s_969_8 s_969_6
        let s_969_12: u64 = s_969_8 << s_969_6;
        // D s_969_13: or s_969_7 s_969_12
        let s_969_13: u64 = ((s_969_7) | (s_969_12));
        // D s_969_14: cmpl s_969_12
        let s_969_14: u64 = !s_969_12;
        // D s_969_15: and s_969_7 s_969_14
        let s_969_15: u64 = ((s_969_7) & (s_969_14));
        // D s_969_16: select s_969_11 s_969_13 s_969_15
        let s_969_16: u64 = if s_969_11 { s_969_13 } else { s_969_15 };
        // D s_969_17: cast trunc s_969_16 -> u8
        let s_969_17: bool = ((s_969_16) != 0);
        // D s_969_18: cast zx s_969_17 -> bv
        let s_969_18: Bits = Bits::new(s_969_17 as u128, 1u16);
        // C s_969_19: const #1u : u8
        let s_969_19: bool = true;
        // C s_969_20: cast zx s_969_19 -> bv
        let s_969_20: Bits = Bits::new(s_969_19 as u128, 1u16);
        // D s_969_21: cmp-ne s_969_18 s_969_20
        let s_969_21: bool = ((s_969_18) != (s_969_20));
        // D s_969_22: write-var gs#406416 <= s_969_21
        fn_state.gs_406416 = s_969_21;
        // N s_969_23: jump b970
        return block_970(state, tracer, fn_state);
    }
    fn block_970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_970_0: read-var gs#406416:u8
        let s_970_0: bool = fn_state.gs_406416;
        // N s_970_1: branch s_970_0 b984 b971
        if s_970_0 {
            return block_984(state, tracer, fn_state);
        } else {
            return block_971(state, tracer, fn_state);
        };
    }
    fn block_971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_971_0: const #8s : i
        let s_971_0: i128 = 8;
        // D s_971_1: read-var u#32898:u32
        let s_971_1: u32 = fn_state.u_32898;
        // D s_971_2: cast zx s_971_1 -> bv
        let s_971_2: Bits = Bits::new(s_971_1 as u128, 32u16);
        // C s_971_3: const #1u : u64
        let s_971_3: u64 = 1;
        // D s_971_4: bit-extract s_971_2 s_971_0 s_971_3
        let s_971_4: Bits = (Bits::new(
            ((s_971_2) >> (s_971_0)).value(),
            u16::try_from(s_971_3).unwrap(),
        ));
        // D s_971_5: cast reint s_971_4 -> u8
        let s_971_5: bool = ((s_971_4.value()) != 0);
        // C s_971_6: const #0s : i
        let s_971_6: i128 = 0;
        // C s_971_7: const #0u : u64
        let s_971_7: u64 = 0;
        // D s_971_8: cast zx s_971_5 -> u64
        let s_971_8: u64 = (s_971_5 as u64);
        // C s_971_9: const #1u : u64
        let s_971_9: u64 = 1;
        // D s_971_10: and s_971_8 s_971_9
        let s_971_10: u64 = ((s_971_8) & (s_971_9));
        // D s_971_11: cmp-eq s_971_10 s_971_9
        let s_971_11: bool = ((s_971_10) == (s_971_9));
        // D s_971_12: lsl s_971_8 s_971_6
        let s_971_12: u64 = s_971_8 << s_971_6;
        // D s_971_13: or s_971_7 s_971_12
        let s_971_13: u64 = ((s_971_7) | (s_971_12));
        // D s_971_14: cmpl s_971_12
        let s_971_14: u64 = !s_971_12;
        // D s_971_15: and s_971_7 s_971_14
        let s_971_15: u64 = ((s_971_7) & (s_971_14));
        // D s_971_16: select s_971_11 s_971_13 s_971_15
        let s_971_16: u64 = if s_971_11 { s_971_13 } else { s_971_15 };
        // D s_971_17: cast trunc s_971_16 -> u8
        let s_971_17: bool = ((s_971_16) != 0);
        // D s_971_18: cast zx s_971_17 -> bv
        let s_971_18: Bits = Bits::new(s_971_17 as u128, 1u16);
        // C s_971_19: const #0u : u8
        let s_971_19: bool = false;
        // C s_971_20: cast zx s_971_19 -> bv
        let s_971_20: Bits = Bits::new(s_971_19 as u128, 1u16);
        // D s_971_21: cmp-ne s_971_18 s_971_20
        let s_971_21: bool = ((s_971_18) != (s_971_20));
        // D s_971_22: write-var gs#406419 <= s_971_21
        fn_state.gs_406419 = s_971_21;
        // N s_971_23: jump b972
        return block_972(state, tracer, fn_state);
    }
    fn block_972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_972_0: read-var gs#406419:u8
        let s_972_0: bool = fn_state.gs_406419;
        // N s_972_1: branch s_972_0 b983 b973
        if s_972_0 {
            return block_983(state, tracer, fn_state);
        } else {
            return block_973(state, tracer, fn_state);
        };
    }
    fn block_973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_973_0: const #9s : i
        let s_973_0: i128 = 9;
        // D s_973_1: read-var u#32898:u32
        let s_973_1: u32 = fn_state.u_32898;
        // D s_973_2: cast zx s_973_1 -> bv
        let s_973_2: Bits = Bits::new(s_973_1 as u128, 32u16);
        // C s_973_3: const #1u : u64
        let s_973_3: u64 = 1;
        // D s_973_4: bit-extract s_973_2 s_973_0 s_973_3
        let s_973_4: Bits = (Bits::new(
            ((s_973_2) >> (s_973_0)).value(),
            u16::try_from(s_973_3).unwrap(),
        ));
        // D s_973_5: cast reint s_973_4 -> u8
        let s_973_5: bool = ((s_973_4.value()) != 0);
        // C s_973_6: const #0s : i
        let s_973_6: i128 = 0;
        // C s_973_7: const #0u : u64
        let s_973_7: u64 = 0;
        // D s_973_8: cast zx s_973_5 -> u64
        let s_973_8: u64 = (s_973_5 as u64);
        // C s_973_9: const #1u : u64
        let s_973_9: u64 = 1;
        // D s_973_10: and s_973_8 s_973_9
        let s_973_10: u64 = ((s_973_8) & (s_973_9));
        // D s_973_11: cmp-eq s_973_10 s_973_9
        let s_973_11: bool = ((s_973_10) == (s_973_9));
        // D s_973_12: lsl s_973_8 s_973_6
        let s_973_12: u64 = s_973_8 << s_973_6;
        // D s_973_13: or s_973_7 s_973_12
        let s_973_13: u64 = ((s_973_7) | (s_973_12));
        // D s_973_14: cmpl s_973_12
        let s_973_14: u64 = !s_973_12;
        // D s_973_15: and s_973_7 s_973_14
        let s_973_15: u64 = ((s_973_7) & (s_973_14));
        // D s_973_16: select s_973_11 s_973_13 s_973_15
        let s_973_16: u64 = if s_973_11 { s_973_13 } else { s_973_15 };
        // D s_973_17: cast trunc s_973_16 -> u8
        let s_973_17: bool = ((s_973_16) != 0);
        // D s_973_18: cast zx s_973_17 -> bv
        let s_973_18: Bits = Bits::new(s_973_17 as u128, 1u16);
        // C s_973_19: const #0u : u8
        let s_973_19: bool = false;
        // C s_973_20: cast zx s_973_19 -> bv
        let s_973_20: Bits = Bits::new(s_973_19 as u128, 1u16);
        // D s_973_21: cmp-ne s_973_18 s_973_20
        let s_973_21: bool = ((s_973_18) != (s_973_20));
        // D s_973_22: write-var gs#406422 <= s_973_21
        fn_state.gs_406422 = s_973_21;
        // N s_973_23: jump b974
        return block_974(state, tracer, fn_state);
    }
    fn block_974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_974_0: read-var gs#406422:u8
        let s_974_0: bool = fn_state.gs_406422;
        // N s_974_1: branch s_974_0 b982 b975
        if s_974_0 {
            return block_982(state, tracer, fn_state);
        } else {
            return block_975(state, tracer, fn_state);
        };
    }
    fn block_975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_975_0: const #10s : i
        let s_975_0: i128 = 10;
        // D s_975_1: read-var u#32898:u32
        let s_975_1: u32 = fn_state.u_32898;
        // D s_975_2: cast zx s_975_1 -> bv
        let s_975_2: Bits = Bits::new(s_975_1 as u128, 32u16);
        // C s_975_3: const #1u : u64
        let s_975_3: u64 = 1;
        // D s_975_4: bit-extract s_975_2 s_975_0 s_975_3
        let s_975_4: Bits = (Bits::new(
            ((s_975_2) >> (s_975_0)).value(),
            u16::try_from(s_975_3).unwrap(),
        ));
        // D s_975_5: cast reint s_975_4 -> u8
        let s_975_5: bool = ((s_975_4.value()) != 0);
        // C s_975_6: const #0s : i
        let s_975_6: i128 = 0;
        // C s_975_7: const #0u : u64
        let s_975_7: u64 = 0;
        // D s_975_8: cast zx s_975_5 -> u64
        let s_975_8: u64 = (s_975_5 as u64);
        // C s_975_9: const #1u : u64
        let s_975_9: u64 = 1;
        // D s_975_10: and s_975_8 s_975_9
        let s_975_10: u64 = ((s_975_8) & (s_975_9));
        // D s_975_11: cmp-eq s_975_10 s_975_9
        let s_975_11: bool = ((s_975_10) == (s_975_9));
        // D s_975_12: lsl s_975_8 s_975_6
        let s_975_12: u64 = s_975_8 << s_975_6;
        // D s_975_13: or s_975_7 s_975_12
        let s_975_13: u64 = ((s_975_7) | (s_975_12));
        // D s_975_14: cmpl s_975_12
        let s_975_14: u64 = !s_975_12;
        // D s_975_15: and s_975_7 s_975_14
        let s_975_15: u64 = ((s_975_7) & (s_975_14));
        // D s_975_16: select s_975_11 s_975_13 s_975_15
        let s_975_16: u64 = if s_975_11 { s_975_13 } else { s_975_15 };
        // D s_975_17: cast trunc s_975_16 -> u8
        let s_975_17: bool = ((s_975_16) != 0);
        // D s_975_18: cast zx s_975_17 -> bv
        let s_975_18: Bits = Bits::new(s_975_17 as u128, 1u16);
        // C s_975_19: const #0u : u8
        let s_975_19: bool = false;
        // C s_975_20: cast zx s_975_19 -> bv
        let s_975_20: Bits = Bits::new(s_975_19 as u128, 1u16);
        // D s_975_21: cmp-ne s_975_18 s_975_20
        let s_975_21: bool = ((s_975_18) != (s_975_20));
        // D s_975_22: write-var gs#406425 <= s_975_21
        fn_state.gs_406425 = s_975_21;
        // N s_975_23: jump b976
        return block_976(state, tracer, fn_state);
    }
    fn block_976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_976_0: read-var gs#406425:u8
        let s_976_0: bool = fn_state.gs_406425;
        // N s_976_1: branch s_976_0 b981 b977
        if s_976_0 {
            return block_981(state, tracer, fn_state);
        } else {
            return block_977(state, tracer, fn_state);
        };
    }
    fn block_977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_977_0: const #11s : i
        let s_977_0: i128 = 11;
        // D s_977_1: read-var u#32898:u32
        let s_977_1: u32 = fn_state.u_32898;
        // D s_977_2: cast zx s_977_1 -> bv
        let s_977_2: Bits = Bits::new(s_977_1 as u128, 32u16);
        // C s_977_3: const #1u : u64
        let s_977_3: u64 = 1;
        // D s_977_4: bit-extract s_977_2 s_977_0 s_977_3
        let s_977_4: Bits = (Bits::new(
            ((s_977_2) >> (s_977_0)).value(),
            u16::try_from(s_977_3).unwrap(),
        ));
        // D s_977_5: cast reint s_977_4 -> u8
        let s_977_5: bool = ((s_977_4.value()) != 0);
        // C s_977_6: const #0s : i
        let s_977_6: i128 = 0;
        // C s_977_7: const #0u : u64
        let s_977_7: u64 = 0;
        // D s_977_8: cast zx s_977_5 -> u64
        let s_977_8: u64 = (s_977_5 as u64);
        // C s_977_9: const #1u : u64
        let s_977_9: u64 = 1;
        // D s_977_10: and s_977_8 s_977_9
        let s_977_10: u64 = ((s_977_8) & (s_977_9));
        // D s_977_11: cmp-eq s_977_10 s_977_9
        let s_977_11: bool = ((s_977_10) == (s_977_9));
        // D s_977_12: lsl s_977_8 s_977_6
        let s_977_12: u64 = s_977_8 << s_977_6;
        // D s_977_13: or s_977_7 s_977_12
        let s_977_13: u64 = ((s_977_7) | (s_977_12));
        // D s_977_14: cmpl s_977_12
        let s_977_14: u64 = !s_977_12;
        // D s_977_15: and s_977_7 s_977_14
        let s_977_15: u64 = ((s_977_7) & (s_977_14));
        // D s_977_16: select s_977_11 s_977_13 s_977_15
        let s_977_16: u64 = if s_977_11 { s_977_13 } else { s_977_15 };
        // D s_977_17: cast trunc s_977_16 -> u8
        let s_977_17: bool = ((s_977_16) != 0);
        // D s_977_18: cast zx s_977_17 -> bv
        let s_977_18: Bits = Bits::new(s_977_17 as u128, 1u16);
        // C s_977_19: const #0u : u8
        let s_977_19: bool = false;
        // C s_977_20: cast zx s_977_19 -> bv
        let s_977_20: Bits = Bits::new(s_977_19 as u128, 1u16);
        // D s_977_21: cmp-ne s_977_18 s_977_20
        let s_977_21: bool = ((s_977_18) != (s_977_20));
        // D s_977_22: write-var gs#406428 <= s_977_21
        fn_state.gs_406428 = s_977_21;
        // N s_977_23: jump b978
        return block_978(state, tracer, fn_state);
    }
    fn block_978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_978_0: read-var gs#406428:u8
        let s_978_0: bool = fn_state.gs_406428;
        // N s_978_1: branch s_978_0 b980 b979
        if s_978_0 {
            return block_980(state, tracer, fn_state);
        } else {
            return block_979(state, tracer, fn_state);
        };
    }
    fn block_979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_979_0: read-var u#32899:u8
        let s_979_0: u8 = fn_state.u_32899;
        // D s_979_1: call decode_aarch32_instrs_SEV_A1enc_A_txt(s_979_0)
        let s_979_1: () = decode_aarch32_instrs_SEV_A1enc_A_txt(state, tracer, s_979_0);
        // N s_979_2: return
        return;
    }
    fn block_980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_980_0: panic
        panic!("{:?}", ());
        // N s_980_1: return
        return;
    }
    fn block_981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_981_0: const #1u : u8
        let s_981_0: bool = true;
        // D s_981_1: write-var gs#406428 <= s_981_0
        fn_state.gs_406428 = s_981_0;
        // N s_981_2: jump b978
        return block_978(state, tracer, fn_state);
    }
    fn block_982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_982_0: const #1u : u8
        let s_982_0: bool = true;
        // D s_982_1: write-var gs#406425 <= s_982_0
        fn_state.gs_406425 = s_982_0;
        // N s_982_2: jump b976
        return block_976(state, tracer, fn_state);
    }
    fn block_983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_983_0: const #1u : u8
        let s_983_0: bool = true;
        // D s_983_1: write-var gs#406422 <= s_983_0
        fn_state.gs_406422 = s_983_0;
        // N s_983_2: jump b974
        return block_974(state, tracer, fn_state);
    }
    fn block_984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_984_0: const #1u : u8
        let s_984_0: bool = true;
        // D s_984_1: write-var gs#406419 <= s_984_0
        fn_state.gs_406419 = s_984_0;
        // N s_984_2: jump b972
        return block_972(state, tracer, fn_state);
    }
    fn block_985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_985_0: const #1u : u8
        let s_985_0: bool = true;
        // D s_985_1: write-var gs#406416 <= s_985_0
        fn_state.gs_406416 = s_985_0;
        // N s_985_2: jump b970
        return block_970(state, tracer, fn_state);
    }
    fn block_986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_986_0: const #1u : u8
        let s_986_0: bool = true;
        // D s_986_1: write-var gs#406413 <= s_986_0
        fn_state.gs_406413 = s_986_0;
        // N s_986_2: jump b968
        return block_968(state, tracer, fn_state);
    }
    fn block_987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_987_0: const #1u : u8
        let s_987_0: bool = true;
        // D s_987_1: write-var gs#406410 <= s_987_0
        fn_state.gs_406410 = s_987_0;
        // N s_987_2: jump b966
        return block_966(state, tracer, fn_state);
    }
    fn block_988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_988_0: read-var merge#var.1:struct
        let s_988_0: u32 = fn_state.merge_var._1;
        // D s_988_1: write-var u#32901 <= s_988_0
        fn_state.u_32901 = s_988_0;
        // C s_988_2: const #20s : i
        let s_988_2: i128 = 20;
        // D s_988_3: read-var u#32901:u32
        let s_988_3: u32 = fn_state.u_32901;
        // D s_988_4: cast zx s_988_3 -> bv
        let s_988_4: Bits = Bits::new(s_988_3 as u128, 32u16);
        // C s_988_5: const #1s : i64
        let s_988_5: i64 = 1;
        // C s_988_6: cast zx s_988_5 -> i
        let s_988_6: i128 = (i128::try_from(s_988_5).unwrap());
        // C s_988_7: const #7s : i
        let s_988_7: i128 = 7;
        // C s_988_8: add s_988_7 s_988_6
        let s_988_8: i128 = (s_988_7 + s_988_6);
        // D s_988_9: bit-extract s_988_4 s_988_2 s_988_8
        let s_988_9: Bits = (Bits::new(
            ((s_988_4) >> (s_988_2)).value(),
            u16::try_from(s_988_8).unwrap(),
        ));
        // D s_988_10: cast reint s_988_9 -> u8
        let s_988_10: u8 = (s_988_9.value() as u8);
        // D s_988_11: cast zx s_988_10 -> bv
        let s_988_11: Bits = Bits::new(s_988_10 as u128, 8u16);
        // C s_988_12: const #16u : u8
        let s_988_12: u8 = 16;
        // C s_988_13: cast zx s_988_12 -> bv
        let s_988_13: Bits = Bits::new(s_988_12 as u128, 8u16);
        // D s_988_14: cmp-eq s_988_11 s_988_13
        let s_988_14: bool = ((s_988_11) == (s_988_13));
        // N s_988_15: branch s_988_14 b2449 b989
        if s_988_14 {
            return block_2449(state, tracer, fn_state);
        } else {
            return block_989(state, tracer, fn_state);
        };
    }
    fn block_989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_989_0: const #0u : u8
        let s_989_0: bool = false;
        // D s_989_1: write-var gs#406437 <= s_989_0
        fn_state.gs_406437 = s_989_0;
        // N s_989_2: jump b990
        return block_990(state, tracer, fn_state);
    }
    fn block_990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_990_0: read-var gs#406437:u8
        let s_990_0: bool = fn_state.gs_406437;
        // N s_990_1: branch s_990_0 b2445 b991
        if s_990_0 {
            return block_2445(state, tracer, fn_state);
        } else {
            return block_991(state, tracer, fn_state);
        };
    }
    fn block_991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_991_0: const #0u : u8
        let s_991_0: bool = false;
        // D s_991_1: write-var gs#406442 <= s_991_0
        fn_state.gs_406442 = s_991_0;
        // N s_991_2: jump b992
        return block_992(state, tracer, fn_state);
    }
    fn block_992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_992_0: read-var gs#406442:u8
        let s_992_0: bool = fn_state.gs_406442;
        // D s_992_1: not s_992_0
        let s_992_1: bool = !s_992_0;
        // N s_992_2: branch s_992_1 b994 b993
        if s_992_1 {
            return block_994(state, tracer, fn_state);
        } else {
            return block_993(state, tracer, fn_state);
        };
    }
    fn block_993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_993_0: const #3142s : i
        let s_993_0: i128 = 3142;
        // C s_993_1: const #14696u : u32
        let s_993_1: u32 = 14696;
        // N s_993_2: write-reg s_993_1 <= s_993_0
        let s_993_2: () = {
            state.write_register::<i128>(s_993_1 as isize, s_993_0);
            tracer.write_register(s_993_1 as isize, s_993_0);
        };
        // C s_993_3: const #28s : i
        let s_993_3: i128 = 28;
        // C s_993_4: const #4s : i
        let s_993_4: i128 = 4;
        // D s_993_5: read-var u#32901:u32
        let s_993_5: u32 = fn_state.u_32901;
        // D s_993_6: cast zx s_993_5 -> bv
        let s_993_6: Bits = Bits::new(s_993_5 as u128, 32u16);
        // D s_993_7: bit-extract s_993_6 s_993_3 s_993_4
        let s_993_7: Bits = (Bits::new(
            ((s_993_6) >> (s_993_3)).value(),
            u16::try_from(s_993_4).unwrap(),
        ));
        // D s_993_8: cast reint s_993_7 -> u8
        let s_993_8: u8 = (s_993_7.value() as u8);
        // C s_993_9: const #16s : i
        let s_993_9: i128 = 16;
        // C s_993_10: const #4s : i
        let s_993_10: i128 = 4;
        // D s_993_11: read-var u#32901:u32
        let s_993_11: u32 = fn_state.u_32901;
        // D s_993_12: cast zx s_993_11 -> bv
        let s_993_12: Bits = Bits::new(s_993_11 as u128, 32u16);
        // D s_993_13: bit-extract s_993_12 s_993_9 s_993_10
        let s_993_13: Bits = (Bits::new(
            ((s_993_12) >> (s_993_9)).value(),
            u16::try_from(s_993_10).unwrap(),
        ));
        // D s_993_14: cast reint s_993_13 -> u8
        let s_993_14: u8 = (s_993_13.value() as u8);
        // C s_993_15: const #12s : i
        let s_993_15: i128 = 12;
        // C s_993_16: const #4s : i
        let s_993_16: i128 = 4;
        // D s_993_17: read-var u#32901:u32
        let s_993_17: u32 = fn_state.u_32901;
        // D s_993_18: cast zx s_993_17 -> bv
        let s_993_18: Bits = Bits::new(s_993_17 as u128, 32u16);
        // D s_993_19: bit-extract s_993_18 s_993_15 s_993_16
        let s_993_19: Bits = (Bits::new(
            ((s_993_18) >> (s_993_15)).value(),
            u16::try_from(s_993_16).unwrap(),
        ));
        // D s_993_20: cast reint s_993_19 -> u8
        let s_993_20: u8 = (s_993_19.value() as u8);
        // C s_993_21: const #8s : i
        let s_993_21: i128 = 8;
        // C s_993_22: const #4s : i
        let s_993_22: i128 = 4;
        // D s_993_23: read-var u#32901:u32
        let s_993_23: u32 = fn_state.u_32901;
        // D s_993_24: cast zx s_993_23 -> bv
        let s_993_24: Bits = Bits::new(s_993_23 as u128, 32u16);
        // D s_993_25: bit-extract s_993_24 s_993_21 s_993_22
        let s_993_25: Bits = (Bits::new(
            ((s_993_24) >> (s_993_21)).value(),
            u16::try_from(s_993_22).unwrap(),
        ));
        // D s_993_26: cast reint s_993_25 -> u8
        let s_993_26: u8 = (s_993_25.value() as u8);
        // C s_993_27: const #6s : i
        let s_993_27: i128 = 6;
        // C s_993_28: const #1s : i
        let s_993_28: i128 = 1;
        // D s_993_29: read-var u#32901:u32
        let s_993_29: u32 = fn_state.u_32901;
        // D s_993_30: cast zx s_993_29 -> bv
        let s_993_30: Bits = Bits::new(s_993_29 as u128, 32u16);
        // D s_993_31: bit-extract s_993_30 s_993_27 s_993_28
        let s_993_31: Bits = (Bits::new(
            ((s_993_30) >> (s_993_27)).value(),
            u16::try_from(s_993_28).unwrap(),
        ));
        // D s_993_32: cast reint s_993_31 -> u8
        let s_993_32: bool = ((s_993_31.value()) != 0);
        // C s_993_33: const #5s : i
        let s_993_33: i128 = 5;
        // C s_993_34: const #1s : i
        let s_993_34: i128 = 1;
        // D s_993_35: read-var u#32901:u32
        let s_993_35: u32 = fn_state.u_32901;
        // D s_993_36: cast zx s_993_35 -> bv
        let s_993_36: Bits = Bits::new(s_993_35 as u128, 32u16);
        // D s_993_37: bit-extract s_993_36 s_993_33 s_993_34
        let s_993_37: Bits = (Bits::new(
            ((s_993_36) >> (s_993_33)).value(),
            u16::try_from(s_993_34).unwrap(),
        ));
        // D s_993_38: cast reint s_993_37 -> u8
        let s_993_38: bool = ((s_993_37.value()) != 0);
        // C s_993_39: const #0s : i
        let s_993_39: i128 = 0;
        // C s_993_40: const #4s : i
        let s_993_40: i128 = 4;
        // D s_993_41: read-var u#32901:u32
        let s_993_41: u32 = fn_state.u_32901;
        // D s_993_42: cast zx s_993_41 -> bv
        let s_993_42: Bits = Bits::new(s_993_41 as u128, 32u16);
        // D s_993_43: bit-extract s_993_42 s_993_39 s_993_40
        let s_993_43: Bits = (Bits::new(
            ((s_993_42) >> (s_993_39)).value(),
            u16::try_from(s_993_40).unwrap(),
        ));
        // D s_993_44: cast reint s_993_43 -> u8
        let s_993_44: u8 = (s_993_43.value() as u8);
        // D s_993_45: call decode_aarch32_instrs_SMLABB_A1enc_A_txt(s_993_8, s_993_14, s_993_20, s_993_26, s_993_32, s_993_38, s_993_44)
        let s_993_45: () = decode_aarch32_instrs_SMLABB_A1enc_A_txt(
            state,
            tracer,
            s_993_8,
            s_993_14,
            s_993_20,
            s_993_26,
            s_993_32,
            s_993_38,
            s_993_44,
        );
        // N s_993_46: return
        return;
    }
    fn block_994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_994_0: read-var merge#var.1:struct
        let s_994_0: u32 = fn_state.merge_var._1;
        // D s_994_1: write-var u#32908 <= s_994_0
        fn_state.u_32908 = s_994_0;
        // C s_994_2: const #21s : i
        let s_994_2: i128 = 21;
        // D s_994_3: read-var u#32908:u32
        let s_994_3: u32 = fn_state.u_32908;
        // D s_994_4: cast zx s_994_3 -> bv
        let s_994_4: Bits = Bits::new(s_994_3 as u128, 32u16);
        // C s_994_5: const #1s : i64
        let s_994_5: i64 = 1;
        // C s_994_6: cast zx s_994_5 -> i
        let s_994_6: i128 = (i128::try_from(s_994_5).unwrap());
        // C s_994_7: const #6s : i
        let s_994_7: i128 = 6;
        // C s_994_8: add s_994_7 s_994_6
        let s_994_8: i128 = (s_994_7 + s_994_6);
        // D s_994_9: bit-extract s_994_4 s_994_2 s_994_8
        let s_994_9: Bits = (Bits::new(
            ((s_994_4) >> (s_994_2)).value(),
            u16::try_from(s_994_8).unwrap(),
        ));
        // D s_994_10: cast reint s_994_9 -> u8
        let s_994_10: u8 = (s_994_9.value() as u8);
        // D s_994_11: cast zx s_994_10 -> bv
        let s_994_11: Bits = Bits::new(s_994_10 as u128, 7u16);
        // C s_994_12: const #7u : u8
        let s_994_12: u8 = 7;
        // C s_994_13: cast zx s_994_12 -> bv
        let s_994_13: Bits = Bits::new(s_994_12 as u128, 7u16);
        // D s_994_14: cmp-eq s_994_11 s_994_13
        let s_994_14: bool = ((s_994_11) == (s_994_13));
        // N s_994_15: branch s_994_14 b2444 b995
        if s_994_14 {
            return block_2444(state, tracer, fn_state);
        } else {
            return block_995(state, tracer, fn_state);
        };
    }
    fn block_995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_995_0: const #0u : u8
        let s_995_0: bool = false;
        // D s_995_1: write-var gs#406464 <= s_995_0
        fn_state.gs_406464 = s_995_0;
        // N s_995_2: jump b996
        return block_996(state, tracer, fn_state);
    }
    fn block_996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_996_0: read-var gs#406464:u8
        let s_996_0: bool = fn_state.gs_406464;
        // N s_996_1: branch s_996_0 b2440 b997
        if s_996_0 {
            return block_2440(state, tracer, fn_state);
        } else {
            return block_997(state, tracer, fn_state);
        };
    }
    fn block_997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_997_0: const #0u : u8
        let s_997_0: bool = false;
        // D s_997_1: write-var gs#406469 <= s_997_0
        fn_state.gs_406469 = s_997_0;
        // N s_997_2: jump b998
        return block_998(state, tracer, fn_state);
    }
    fn block_998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_998_0: read-var gs#406469:u8
        let s_998_0: bool = fn_state.gs_406469;
        // D s_998_1: not s_998_0
        let s_998_1: bool = !s_998_0;
        // N s_998_2: branch s_998_1 b1000 b999
        if s_998_1 {
            return block_1000(state, tracer, fn_state);
        } else {
            return block_999(state, tracer, fn_state);
        };
    }
    fn block_999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_999_0: const #3146s : i
        let s_999_0: i128 = 3146;
        // C s_999_1: const #14696u : u32
        let s_999_1: u32 = 14696;
        // N s_999_2: write-reg s_999_1 <= s_999_0
        let s_999_2: () = {
            state.write_register::<i128>(s_999_1 as isize, s_999_0);
            tracer.write_register(s_999_1 as isize, s_999_0);
        };
        // C s_999_3: const #28s : i
        let s_999_3: i128 = 28;
        // C s_999_4: const #4s : i
        let s_999_4: i128 = 4;
        // D s_999_5: read-var u#32908:u32
        let s_999_5: u32 = fn_state.u_32908;
        // D s_999_6: cast zx s_999_5 -> bv
        let s_999_6: Bits = Bits::new(s_999_5 as u128, 32u16);
        // D s_999_7: bit-extract s_999_6 s_999_3 s_999_4
        let s_999_7: Bits = (Bits::new(
            ((s_999_6) >> (s_999_3)).value(),
            u16::try_from(s_999_4).unwrap(),
        ));
        // D s_999_8: cast reint s_999_7 -> u8
        let s_999_8: u8 = (s_999_7.value() as u8);
        // C s_999_9: const #20s : i
        let s_999_9: i128 = 20;
        // C s_999_10: const #1s : i
        let s_999_10: i128 = 1;
        // D s_999_11: read-var u#32908:u32
        let s_999_11: u32 = fn_state.u_32908;
        // D s_999_12: cast zx s_999_11 -> bv
        let s_999_12: Bits = Bits::new(s_999_11 as u128, 32u16);
        // D s_999_13: bit-extract s_999_12 s_999_9 s_999_10
        let s_999_13: Bits = (Bits::new(
            ((s_999_12) >> (s_999_9)).value(),
            u16::try_from(s_999_10).unwrap(),
        ));
        // D s_999_14: cast reint s_999_13 -> u8
        let s_999_14: bool = ((s_999_13.value()) != 0);
        // C s_999_15: const #16s : i
        let s_999_15: i128 = 16;
        // C s_999_16: const #4s : i
        let s_999_16: i128 = 4;
        // D s_999_17: read-var u#32908:u32
        let s_999_17: u32 = fn_state.u_32908;
        // D s_999_18: cast zx s_999_17 -> bv
        let s_999_18: Bits = Bits::new(s_999_17 as u128, 32u16);
        // D s_999_19: bit-extract s_999_18 s_999_15 s_999_16
        let s_999_19: Bits = (Bits::new(
            ((s_999_18) >> (s_999_15)).value(),
            u16::try_from(s_999_16).unwrap(),
        ));
        // D s_999_20: cast reint s_999_19 -> u8
        let s_999_20: u8 = (s_999_19.value() as u8);
        // C s_999_21: const #12s : i
        let s_999_21: i128 = 12;
        // C s_999_22: const #4s : i
        let s_999_22: i128 = 4;
        // D s_999_23: read-var u#32908:u32
        let s_999_23: u32 = fn_state.u_32908;
        // D s_999_24: cast zx s_999_23 -> bv
        let s_999_24: Bits = Bits::new(s_999_23 as u128, 32u16);
        // D s_999_25: bit-extract s_999_24 s_999_21 s_999_22
        let s_999_25: Bits = (Bits::new(
            ((s_999_24) >> (s_999_21)).value(),
            u16::try_from(s_999_22).unwrap(),
        ));
        // D s_999_26: cast reint s_999_25 -> u8
        let s_999_26: u8 = (s_999_25.value() as u8);
        // C s_999_27: const #8s : i
        let s_999_27: i128 = 8;
        // C s_999_28: const #4s : i
        let s_999_28: i128 = 4;
        // D s_999_29: read-var u#32908:u32
        let s_999_29: u32 = fn_state.u_32908;
        // D s_999_30: cast zx s_999_29 -> bv
        let s_999_30: Bits = Bits::new(s_999_29 as u128, 32u16);
        // D s_999_31: bit-extract s_999_30 s_999_27 s_999_28
        let s_999_31: Bits = (Bits::new(
            ((s_999_30) >> (s_999_27)).value(),
            u16::try_from(s_999_28).unwrap(),
        ));
        // D s_999_32: cast reint s_999_31 -> u8
        let s_999_32: u8 = (s_999_31.value() as u8);
        // C s_999_33: const #0s : i
        let s_999_33: i128 = 0;
        // C s_999_34: const #4s : i
        let s_999_34: i128 = 4;
        // D s_999_35: read-var u#32908:u32
        let s_999_35: u32 = fn_state.u_32908;
        // D s_999_36: cast zx s_999_35 -> bv
        let s_999_36: Bits = Bits::new(s_999_35 as u128, 32u16);
        // D s_999_37: bit-extract s_999_36 s_999_33 s_999_34
        let s_999_37: Bits = (Bits::new(
            ((s_999_36) >> (s_999_33)).value(),
            u16::try_from(s_999_34).unwrap(),
        ));
        // D s_999_38: cast reint s_999_37 -> u8
        let s_999_38: u8 = (s_999_37.value() as u8);
        // D s_999_39: call decode_aarch32_instrs_SMLAL_A1enc_A_txt(s_999_8, s_999_14, s_999_20, s_999_26, s_999_32, s_999_38)
        let s_999_39: () = decode_aarch32_instrs_SMLAL_A1enc_A_txt(
            state,
            tracer,
            s_999_8,
            s_999_14,
            s_999_20,
            s_999_26,
            s_999_32,
            s_999_38,
        );
        // N s_999_40: return
        return;
    }
    fn block_1000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1000_0: read-var merge#var.1:struct
        let s_1000_0: u32 = fn_state.merge_var._1;
        // D s_1000_1: write-var u#32914 <= s_1000_0
        fn_state.u_32914 = s_1000_0;
        // C s_1000_2: const #20s : i
        let s_1000_2: i128 = 20;
        // D s_1000_3: read-var u#32914:u32
        let s_1000_3: u32 = fn_state.u_32914;
        // D s_1000_4: cast zx s_1000_3 -> bv
        let s_1000_4: Bits = Bits::new(s_1000_3 as u128, 32u16);
        // C s_1000_5: const #1s : i64
        let s_1000_5: i64 = 1;
        // C s_1000_6: cast zx s_1000_5 -> i
        let s_1000_6: i128 = (i128::try_from(s_1000_5).unwrap());
        // C s_1000_7: const #7s : i
        let s_1000_7: i128 = 7;
        // C s_1000_8: add s_1000_7 s_1000_6
        let s_1000_8: i128 = (s_1000_7 + s_1000_6);
        // D s_1000_9: bit-extract s_1000_4 s_1000_2 s_1000_8
        let s_1000_9: Bits = (Bits::new(
            ((s_1000_4) >> (s_1000_2)).value(),
            u16::try_from(s_1000_8).unwrap(),
        ));
        // D s_1000_10: cast reint s_1000_9 -> u8
        let s_1000_10: u8 = (s_1000_9.value() as u8);
        // D s_1000_11: cast zx s_1000_10 -> bv
        let s_1000_11: Bits = Bits::new(s_1000_10 as u128, 8u16);
        // C s_1000_12: const #20u : u8
        let s_1000_12: u8 = 20;
        // C s_1000_13: cast zx s_1000_12 -> bv
        let s_1000_13: Bits = Bits::new(s_1000_12 as u128, 8u16);
        // D s_1000_14: cmp-eq s_1000_11 s_1000_13
        let s_1000_14: bool = ((s_1000_11) == (s_1000_13));
        // N s_1000_15: branch s_1000_14 b2436 b1001
        if s_1000_14 {
            return block_2436(state, tracer, fn_state);
        } else {
            return block_1001(state, tracer, fn_state);
        };
    }
    fn block_1001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1001_0: const #0u : u8
        let s_1001_0: bool = false;
        // D s_1001_1: write-var gs#406492 <= s_1001_0
        fn_state.gs_406492 = s_1001_0;
        // N s_1001_2: jump b1002
        return block_1002(state, tracer, fn_state);
    }
    fn block_1002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1002_0: read-var gs#406492:u8
        let s_1002_0: bool = fn_state.gs_406492;
        // N s_1002_1: branch s_1002_0 b2432 b1003
        if s_1002_0 {
            return block_2432(state, tracer, fn_state);
        } else {
            return block_1003(state, tracer, fn_state);
        };
    }
    fn block_1003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1003_0: const #0u : u8
        let s_1003_0: bool = false;
        // D s_1003_1: write-var gs#406497 <= s_1003_0
        fn_state.gs_406497 = s_1003_0;
        // N s_1003_2: jump b1004
        return block_1004(state, tracer, fn_state);
    }
    fn block_1004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1004_0: read-var gs#406497:u8
        let s_1004_0: bool = fn_state.gs_406497;
        // D s_1004_1: not s_1004_0
        let s_1004_1: bool = !s_1004_0;
        // N s_1004_2: branch s_1004_1 b1006 b1005
        if s_1004_1 {
            return block_1006(state, tracer, fn_state);
        } else {
            return block_1005(state, tracer, fn_state);
        };
    }
    fn block_1005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1005_0: const #3148s : i
        let s_1005_0: i128 = 3148;
        // C s_1005_1: const #14696u : u32
        let s_1005_1: u32 = 14696;
        // N s_1005_2: write-reg s_1005_1 <= s_1005_0
        let s_1005_2: () = {
            state.write_register::<i128>(s_1005_1 as isize, s_1005_0);
            tracer.write_register(s_1005_1 as isize, s_1005_0);
        };
        // C s_1005_3: const #28s : i
        let s_1005_3: i128 = 28;
        // C s_1005_4: const #4s : i
        let s_1005_4: i128 = 4;
        // D s_1005_5: read-var u#32914:u32
        let s_1005_5: u32 = fn_state.u_32914;
        // D s_1005_6: cast zx s_1005_5 -> bv
        let s_1005_6: Bits = Bits::new(s_1005_5 as u128, 32u16);
        // D s_1005_7: bit-extract s_1005_6 s_1005_3 s_1005_4
        let s_1005_7: Bits = (Bits::new(
            ((s_1005_6) >> (s_1005_3)).value(),
            u16::try_from(s_1005_4).unwrap(),
        ));
        // D s_1005_8: cast reint s_1005_7 -> u8
        let s_1005_8: u8 = (s_1005_7.value() as u8);
        // C s_1005_9: const #16s : i
        let s_1005_9: i128 = 16;
        // C s_1005_10: const #4s : i
        let s_1005_10: i128 = 4;
        // D s_1005_11: read-var u#32914:u32
        let s_1005_11: u32 = fn_state.u_32914;
        // D s_1005_12: cast zx s_1005_11 -> bv
        let s_1005_12: Bits = Bits::new(s_1005_11 as u128, 32u16);
        // D s_1005_13: bit-extract s_1005_12 s_1005_9 s_1005_10
        let s_1005_13: Bits = (Bits::new(
            ((s_1005_12) >> (s_1005_9)).value(),
            u16::try_from(s_1005_10).unwrap(),
        ));
        // D s_1005_14: cast reint s_1005_13 -> u8
        let s_1005_14: u8 = (s_1005_13.value() as u8);
        // C s_1005_15: const #12s : i
        let s_1005_15: i128 = 12;
        // C s_1005_16: const #4s : i
        let s_1005_16: i128 = 4;
        // D s_1005_17: read-var u#32914:u32
        let s_1005_17: u32 = fn_state.u_32914;
        // D s_1005_18: cast zx s_1005_17 -> bv
        let s_1005_18: Bits = Bits::new(s_1005_17 as u128, 32u16);
        // D s_1005_19: bit-extract s_1005_18 s_1005_15 s_1005_16
        let s_1005_19: Bits = (Bits::new(
            ((s_1005_18) >> (s_1005_15)).value(),
            u16::try_from(s_1005_16).unwrap(),
        ));
        // D s_1005_20: cast reint s_1005_19 -> u8
        let s_1005_20: u8 = (s_1005_19.value() as u8);
        // C s_1005_21: const #8s : i
        let s_1005_21: i128 = 8;
        // C s_1005_22: const #4s : i
        let s_1005_22: i128 = 4;
        // D s_1005_23: read-var u#32914:u32
        let s_1005_23: u32 = fn_state.u_32914;
        // D s_1005_24: cast zx s_1005_23 -> bv
        let s_1005_24: Bits = Bits::new(s_1005_23 as u128, 32u16);
        // D s_1005_25: bit-extract s_1005_24 s_1005_21 s_1005_22
        let s_1005_25: Bits = (Bits::new(
            ((s_1005_24) >> (s_1005_21)).value(),
            u16::try_from(s_1005_22).unwrap(),
        ));
        // D s_1005_26: cast reint s_1005_25 -> u8
        let s_1005_26: u8 = (s_1005_25.value() as u8);
        // C s_1005_27: const #6s : i
        let s_1005_27: i128 = 6;
        // C s_1005_28: const #1s : i
        let s_1005_28: i128 = 1;
        // D s_1005_29: read-var u#32914:u32
        let s_1005_29: u32 = fn_state.u_32914;
        // D s_1005_30: cast zx s_1005_29 -> bv
        let s_1005_30: Bits = Bits::new(s_1005_29 as u128, 32u16);
        // D s_1005_31: bit-extract s_1005_30 s_1005_27 s_1005_28
        let s_1005_31: Bits = (Bits::new(
            ((s_1005_30) >> (s_1005_27)).value(),
            u16::try_from(s_1005_28).unwrap(),
        ));
        // D s_1005_32: cast reint s_1005_31 -> u8
        let s_1005_32: bool = ((s_1005_31.value()) != 0);
        // C s_1005_33: const #5s : i
        let s_1005_33: i128 = 5;
        // C s_1005_34: const #1s : i
        let s_1005_34: i128 = 1;
        // D s_1005_35: read-var u#32914:u32
        let s_1005_35: u32 = fn_state.u_32914;
        // D s_1005_36: cast zx s_1005_35 -> bv
        let s_1005_36: Bits = Bits::new(s_1005_35 as u128, 32u16);
        // D s_1005_37: bit-extract s_1005_36 s_1005_33 s_1005_34
        let s_1005_37: Bits = (Bits::new(
            ((s_1005_36) >> (s_1005_33)).value(),
            u16::try_from(s_1005_34).unwrap(),
        ));
        // D s_1005_38: cast reint s_1005_37 -> u8
        let s_1005_38: bool = ((s_1005_37.value()) != 0);
        // C s_1005_39: const #0s : i
        let s_1005_39: i128 = 0;
        // C s_1005_40: const #4s : i
        let s_1005_40: i128 = 4;
        // D s_1005_41: read-var u#32914:u32
        let s_1005_41: u32 = fn_state.u_32914;
        // D s_1005_42: cast zx s_1005_41 -> bv
        let s_1005_42: Bits = Bits::new(s_1005_41 as u128, 32u16);
        // D s_1005_43: bit-extract s_1005_42 s_1005_39 s_1005_40
        let s_1005_43: Bits = (Bits::new(
            ((s_1005_42) >> (s_1005_39)).value(),
            u16::try_from(s_1005_40).unwrap(),
        ));
        // D s_1005_44: cast reint s_1005_43 -> u8
        let s_1005_44: u8 = (s_1005_43.value() as u8);
        // D s_1005_45: call decode_aarch32_instrs_SMLALBB_A1enc_A_txt(s_1005_8, s_1005_14, s_1005_20, s_1005_26, s_1005_32, s_1005_38, s_1005_44)
        let s_1005_45: () = decode_aarch32_instrs_SMLALBB_A1enc_A_txt(
            state,
            tracer,
            s_1005_8,
            s_1005_14,
            s_1005_20,
            s_1005_26,
            s_1005_32,
            s_1005_38,
            s_1005_44,
        );
        // N s_1005_46: return
        return;
    }
    fn block_1006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1006_0: read-var merge#var.1:struct
        let s_1006_0: u32 = fn_state.merge_var._1;
        // D s_1006_1: write-var u#32923 <= s_1006_0
        fn_state.u_32923 = s_1006_0;
        // C s_1006_2: const #20s : i
        let s_1006_2: i128 = 20;
        // D s_1006_3: read-var u#32923:u32
        let s_1006_3: u32 = fn_state.u_32923;
        // D s_1006_4: cast zx s_1006_3 -> bv
        let s_1006_4: Bits = Bits::new(s_1006_3 as u128, 32u16);
        // C s_1006_5: const #1s : i64
        let s_1006_5: i64 = 1;
        // C s_1006_6: cast zx s_1006_5 -> i
        let s_1006_6: i128 = (i128::try_from(s_1006_5).unwrap());
        // C s_1006_7: const #7s : i
        let s_1006_7: i128 = 7;
        // C s_1006_8: add s_1006_7 s_1006_6
        let s_1006_8: i128 = (s_1006_7 + s_1006_6);
        // D s_1006_9: bit-extract s_1006_4 s_1006_2 s_1006_8
        let s_1006_9: Bits = (Bits::new(
            ((s_1006_4) >> (s_1006_2)).value(),
            u16::try_from(s_1006_8).unwrap(),
        ));
        // D s_1006_10: cast reint s_1006_9 -> u8
        let s_1006_10: u8 = (s_1006_9.value() as u8);
        // D s_1006_11: cast zx s_1006_10 -> bv
        let s_1006_11: Bits = Bits::new(s_1006_10 as u128, 8u16);
        // C s_1006_12: const #18u : u8
        let s_1006_12: u8 = 18;
        // C s_1006_13: cast zx s_1006_12 -> bv
        let s_1006_13: Bits = Bits::new(s_1006_12 as u128, 8u16);
        // D s_1006_14: cmp-eq s_1006_11 s_1006_13
        let s_1006_14: bool = ((s_1006_11) == (s_1006_13));
        // N s_1006_15: branch s_1006_14 b2428 b1007
        if s_1006_14 {
            return block_2428(state, tracer, fn_state);
        } else {
            return block_1007(state, tracer, fn_state);
        };
    }
    fn block_1007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1007_0: const #0u : u8
        let s_1007_0: bool = false;
        // D s_1007_1: write-var gs#406522 <= s_1007_0
        fn_state.gs_406522 = s_1007_0;
        // N s_1007_2: jump b1008
        return block_1008(state, tracer, fn_state);
    }
    fn block_1008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1008_0: read-var gs#406522:u8
        let s_1008_0: bool = fn_state.gs_406522;
        // N s_1008_1: branch s_1008_0 b2424 b1009
        if s_1008_0 {
            return block_2424(state, tracer, fn_state);
        } else {
            return block_1009(state, tracer, fn_state);
        };
    }
    fn block_1009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1009_0: const #0u : u8
        let s_1009_0: bool = false;
        // D s_1009_1: write-var gs#406527 <= s_1009_0
        fn_state.gs_406527 = s_1009_0;
        // N s_1009_2: jump b1010
        return block_1010(state, tracer, fn_state);
    }
    fn block_1010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1010_0: read-var gs#406527:u8
        let s_1010_0: bool = fn_state.gs_406527;
        // D s_1010_1: not s_1010_0
        let s_1010_1: bool = !s_1010_0;
        // N s_1010_2: branch s_1010_1 b1012 b1011
        if s_1010_1 {
            return block_1012(state, tracer, fn_state);
        } else {
            return block_1011(state, tracer, fn_state);
        };
    }
    fn block_1011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1011_0: const #3152s : i
        let s_1011_0: i128 = 3152;
        // C s_1011_1: const #14696u : u32
        let s_1011_1: u32 = 14696;
        // N s_1011_2: write-reg s_1011_1 <= s_1011_0
        let s_1011_2: () = {
            state.write_register::<i128>(s_1011_1 as isize, s_1011_0);
            tracer.write_register(s_1011_1 as isize, s_1011_0);
        };
        // C s_1011_3: const #28s : i
        let s_1011_3: i128 = 28;
        // C s_1011_4: const #4s : i
        let s_1011_4: i128 = 4;
        // D s_1011_5: read-var u#32923:u32
        let s_1011_5: u32 = fn_state.u_32923;
        // D s_1011_6: cast zx s_1011_5 -> bv
        let s_1011_6: Bits = Bits::new(s_1011_5 as u128, 32u16);
        // D s_1011_7: bit-extract s_1011_6 s_1011_3 s_1011_4
        let s_1011_7: Bits = (Bits::new(
            ((s_1011_6) >> (s_1011_3)).value(),
            u16::try_from(s_1011_4).unwrap(),
        ));
        // D s_1011_8: cast reint s_1011_7 -> u8
        let s_1011_8: u8 = (s_1011_7.value() as u8);
        // C s_1011_9: const #16s : i
        let s_1011_9: i128 = 16;
        // C s_1011_10: const #4s : i
        let s_1011_10: i128 = 4;
        // D s_1011_11: read-var u#32923:u32
        let s_1011_11: u32 = fn_state.u_32923;
        // D s_1011_12: cast zx s_1011_11 -> bv
        let s_1011_12: Bits = Bits::new(s_1011_11 as u128, 32u16);
        // D s_1011_13: bit-extract s_1011_12 s_1011_9 s_1011_10
        let s_1011_13: Bits = (Bits::new(
            ((s_1011_12) >> (s_1011_9)).value(),
            u16::try_from(s_1011_10).unwrap(),
        ));
        // D s_1011_14: cast reint s_1011_13 -> u8
        let s_1011_14: u8 = (s_1011_13.value() as u8);
        // C s_1011_15: const #12s : i
        let s_1011_15: i128 = 12;
        // C s_1011_16: const #4s : i
        let s_1011_16: i128 = 4;
        // D s_1011_17: read-var u#32923:u32
        let s_1011_17: u32 = fn_state.u_32923;
        // D s_1011_18: cast zx s_1011_17 -> bv
        let s_1011_18: Bits = Bits::new(s_1011_17 as u128, 32u16);
        // D s_1011_19: bit-extract s_1011_18 s_1011_15 s_1011_16
        let s_1011_19: Bits = (Bits::new(
            ((s_1011_18) >> (s_1011_15)).value(),
            u16::try_from(s_1011_16).unwrap(),
        ));
        // D s_1011_20: cast reint s_1011_19 -> u8
        let s_1011_20: u8 = (s_1011_19.value() as u8);
        // C s_1011_21: const #8s : i
        let s_1011_21: i128 = 8;
        // C s_1011_22: const #4s : i
        let s_1011_22: i128 = 4;
        // D s_1011_23: read-var u#32923:u32
        let s_1011_23: u32 = fn_state.u_32923;
        // D s_1011_24: cast zx s_1011_23 -> bv
        let s_1011_24: Bits = Bits::new(s_1011_23 as u128, 32u16);
        // D s_1011_25: bit-extract s_1011_24 s_1011_21 s_1011_22
        let s_1011_25: Bits = (Bits::new(
            ((s_1011_24) >> (s_1011_21)).value(),
            u16::try_from(s_1011_22).unwrap(),
        ));
        // D s_1011_26: cast reint s_1011_25 -> u8
        let s_1011_26: u8 = (s_1011_25.value() as u8);
        // C s_1011_27: const #6s : i
        let s_1011_27: i128 = 6;
        // C s_1011_28: const #1s : i
        let s_1011_28: i128 = 1;
        // D s_1011_29: read-var u#32923:u32
        let s_1011_29: u32 = fn_state.u_32923;
        // D s_1011_30: cast zx s_1011_29 -> bv
        let s_1011_30: Bits = Bits::new(s_1011_29 as u128, 32u16);
        // D s_1011_31: bit-extract s_1011_30 s_1011_27 s_1011_28
        let s_1011_31: Bits = (Bits::new(
            ((s_1011_30) >> (s_1011_27)).value(),
            u16::try_from(s_1011_28).unwrap(),
        ));
        // D s_1011_32: cast reint s_1011_31 -> u8
        let s_1011_32: bool = ((s_1011_31.value()) != 0);
        // C s_1011_33: const #0s : i
        let s_1011_33: i128 = 0;
        // C s_1011_34: const #4s : i
        let s_1011_34: i128 = 4;
        // D s_1011_35: read-var u#32923:u32
        let s_1011_35: u32 = fn_state.u_32923;
        // D s_1011_36: cast zx s_1011_35 -> bv
        let s_1011_36: Bits = Bits::new(s_1011_35 as u128, 32u16);
        // D s_1011_37: bit-extract s_1011_36 s_1011_33 s_1011_34
        let s_1011_37: Bits = (Bits::new(
            ((s_1011_36) >> (s_1011_33)).value(),
            u16::try_from(s_1011_34).unwrap(),
        ));
        // D s_1011_38: cast reint s_1011_37 -> u8
        let s_1011_38: u8 = (s_1011_37.value() as u8);
        // D s_1011_39: call decode_aarch32_instrs_SMLAWB_A1enc_A_txt(s_1011_8, s_1011_14, s_1011_20, s_1011_26, s_1011_32, s_1011_38)
        let s_1011_39: () = decode_aarch32_instrs_SMLAWB_A1enc_A_txt(
            state,
            tracer,
            s_1011_8,
            s_1011_14,
            s_1011_20,
            s_1011_26,
            s_1011_32,
            s_1011_38,
        );
        // N s_1011_40: return
        return;
    }
    fn block_1012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1012_0: read-var merge#var.1:struct
        let s_1012_0: u32 = fn_state.merge_var._1;
        // D s_1012_1: write-var u#32931 <= s_1012_0
        fn_state.u_32931 = s_1012_0;
        // C s_1012_2: const #20s : i
        let s_1012_2: i128 = 20;
        // D s_1012_3: read-var u#32931:u32
        let s_1012_3: u32 = fn_state.u_32931;
        // D s_1012_4: cast zx s_1012_3 -> bv
        let s_1012_4: Bits = Bits::new(s_1012_3 as u128, 32u16);
        // C s_1012_5: const #1s : i64
        let s_1012_5: i64 = 1;
        // C s_1012_6: cast zx s_1012_5 -> i
        let s_1012_6: i128 = (i128::try_from(s_1012_5).unwrap());
        // C s_1012_7: const #7s : i
        let s_1012_7: i128 = 7;
        // C s_1012_8: add s_1012_7 s_1012_6
        let s_1012_8: i128 = (s_1012_7 + s_1012_6);
        // D s_1012_9: bit-extract s_1012_4 s_1012_2 s_1012_8
        let s_1012_9: Bits = (Bits::new(
            ((s_1012_4) >> (s_1012_2)).value(),
            u16::try_from(s_1012_8).unwrap(),
        ));
        // D s_1012_10: cast reint s_1012_9 -> u8
        let s_1012_10: u8 = (s_1012_9.value() as u8);
        // D s_1012_11: cast zx s_1012_10 -> bv
        let s_1012_11: Bits = Bits::new(s_1012_10 as u128, 8u16);
        // C s_1012_12: const #22u : u8
        let s_1012_12: u8 = 22;
        // C s_1012_13: cast zx s_1012_12 -> bv
        let s_1012_13: Bits = Bits::new(s_1012_12 as u128, 8u16);
        // D s_1012_14: cmp-eq s_1012_11 s_1012_13
        let s_1012_14: bool = ((s_1012_11) == (s_1012_13));
        // N s_1012_15: branch s_1012_14 b2417 b1013
        if s_1012_14 {
            return block_2417(state, tracer, fn_state);
        } else {
            return block_1013(state, tracer, fn_state);
        };
    }
    fn block_1013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1013_0: const #0u : u8
        let s_1013_0: bool = false;
        // D s_1013_1: write-var gs#406553 <= s_1013_0
        fn_state.gs_406553 = s_1013_0;
        // N s_1013_2: jump b1014
        return block_1014(state, tracer, fn_state);
    }
    fn block_1014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1014_0: read-var gs#406553:u8
        let s_1014_0: bool = fn_state.gs_406553;
        // N s_1014_1: branch s_1014_0 b2413 b1015
        if s_1014_0 {
            return block_2413(state, tracer, fn_state);
        } else {
            return block_1015(state, tracer, fn_state);
        };
    }
    fn block_1015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1015_0: const #0u : u8
        let s_1015_0: bool = false;
        // D s_1015_1: write-var gs#406558 <= s_1015_0
        fn_state.gs_406558 = s_1015_0;
        // N s_1015_2: jump b1016
        return block_1016(state, tracer, fn_state);
    }
    fn block_1016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1016_0: read-var gs#406558:u8
        let s_1016_0: bool = fn_state.gs_406558;
        // D s_1016_1: not s_1016_0
        let s_1016_1: bool = !s_1016_0;
        // N s_1016_2: branch s_1016_1 b1029 b1017
        if s_1016_1 {
            return block_1029(state, tracer, fn_state);
        } else {
            return block_1017(state, tracer, fn_state);
        };
    }
    fn block_1017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1017_0: const #3166s : i
        let s_1017_0: i128 = 3166;
        // C s_1017_1: const #14696u : u32
        let s_1017_1: u32 = 14696;
        // N s_1017_2: write-reg s_1017_1 <= s_1017_0
        let s_1017_2: () = {
            state.write_register::<i128>(s_1017_1 as isize, s_1017_0);
            tracer.write_register(s_1017_1 as isize, s_1017_0);
        };
        // C s_1017_3: const #28s : i
        let s_1017_3: i128 = 28;
        // C s_1017_4: const #4s : i
        let s_1017_4: i128 = 4;
        // D s_1017_5: read-var u#32931:u32
        let s_1017_5: u32 = fn_state.u_32931;
        // D s_1017_6: cast zx s_1017_5 -> bv
        let s_1017_6: Bits = Bits::new(s_1017_5 as u128, 32u16);
        // D s_1017_7: bit-extract s_1017_6 s_1017_3 s_1017_4
        let s_1017_7: Bits = (Bits::new(
            ((s_1017_6) >> (s_1017_3)).value(),
            u16::try_from(s_1017_4).unwrap(),
        ));
        // D s_1017_8: cast reint s_1017_7 -> u8
        let s_1017_8: u8 = (s_1017_7.value() as u8);
        // D s_1017_9: write-var u#32932 <= s_1017_8
        fn_state.u_32932 = s_1017_8;
        // C s_1017_10: const #16s : i
        let s_1017_10: i128 = 16;
        // C s_1017_11: const #4s : i
        let s_1017_11: i128 = 4;
        // D s_1017_12: read-var u#32931:u32
        let s_1017_12: u32 = fn_state.u_32931;
        // D s_1017_13: cast zx s_1017_12 -> bv
        let s_1017_13: Bits = Bits::new(s_1017_12 as u128, 32u16);
        // D s_1017_14: bit-extract s_1017_13 s_1017_10 s_1017_11
        let s_1017_14: Bits = (Bits::new(
            ((s_1017_13) >> (s_1017_10)).value(),
            u16::try_from(s_1017_11).unwrap(),
        ));
        // D s_1017_15: cast reint s_1017_14 -> u8
        let s_1017_15: u8 = (s_1017_14.value() as u8);
        // D s_1017_16: write-var u#32933 <= s_1017_15
        fn_state.u_32933 = s_1017_15;
        // C s_1017_17: const #8s : i
        let s_1017_17: i128 = 8;
        // C s_1017_18: const #4s : i
        let s_1017_18: i128 = 4;
        // D s_1017_19: read-var u#32931:u32
        let s_1017_19: u32 = fn_state.u_32931;
        // D s_1017_20: cast zx s_1017_19 -> bv
        let s_1017_20: Bits = Bits::new(s_1017_19 as u128, 32u16);
        // D s_1017_21: bit-extract s_1017_20 s_1017_17 s_1017_18
        let s_1017_21: Bits = (Bits::new(
            ((s_1017_20) >> (s_1017_17)).value(),
            u16::try_from(s_1017_18).unwrap(),
        ));
        // D s_1017_22: cast reint s_1017_21 -> u8
        let s_1017_22: u8 = (s_1017_21.value() as u8);
        // D s_1017_23: write-var u#32934 <= s_1017_22
        fn_state.u_32934 = s_1017_22;
        // C s_1017_24: const #6s : i
        let s_1017_24: i128 = 6;
        // C s_1017_25: const #1s : i
        let s_1017_25: i128 = 1;
        // D s_1017_26: read-var u#32931:u32
        let s_1017_26: u32 = fn_state.u_32931;
        // D s_1017_27: cast zx s_1017_26 -> bv
        let s_1017_27: Bits = Bits::new(s_1017_26 as u128, 32u16);
        // D s_1017_28: bit-extract s_1017_27 s_1017_24 s_1017_25
        let s_1017_28: Bits = (Bits::new(
            ((s_1017_27) >> (s_1017_24)).value(),
            u16::try_from(s_1017_25).unwrap(),
        ));
        // D s_1017_29: cast reint s_1017_28 -> u8
        let s_1017_29: bool = ((s_1017_28.value()) != 0);
        // D s_1017_30: write-var u#32935 <= s_1017_29
        fn_state.u_32935 = s_1017_29;
        // C s_1017_31: const #5s : i
        let s_1017_31: i128 = 5;
        // C s_1017_32: const #1s : i
        let s_1017_32: i128 = 1;
        // D s_1017_33: read-var u#32931:u32
        let s_1017_33: u32 = fn_state.u_32931;
        // D s_1017_34: cast zx s_1017_33 -> bv
        let s_1017_34: Bits = Bits::new(s_1017_33 as u128, 32u16);
        // D s_1017_35: bit-extract s_1017_34 s_1017_31 s_1017_32
        let s_1017_35: Bits = (Bits::new(
            ((s_1017_34) >> (s_1017_31)).value(),
            u16::try_from(s_1017_32).unwrap(),
        ));
        // D s_1017_36: cast reint s_1017_35 -> u8
        let s_1017_36: bool = ((s_1017_35.value()) != 0);
        // D s_1017_37: write-var u#32936 <= s_1017_36
        fn_state.u_32936 = s_1017_36;
        // C s_1017_38: const #0s : i
        let s_1017_38: i128 = 0;
        // C s_1017_39: const #4s : i
        let s_1017_39: i128 = 4;
        // D s_1017_40: read-var u#32931:u32
        let s_1017_40: u32 = fn_state.u_32931;
        // D s_1017_41: cast zx s_1017_40 -> bv
        let s_1017_41: Bits = Bits::new(s_1017_40 as u128, 32u16);
        // D s_1017_42: bit-extract s_1017_41 s_1017_38 s_1017_39
        let s_1017_42: Bits = (Bits::new(
            ((s_1017_41) >> (s_1017_38)).value(),
            u16::try_from(s_1017_39).unwrap(),
        ));
        // D s_1017_43: cast reint s_1017_42 -> u8
        let s_1017_43: u8 = (s_1017_42.value() as u8);
        // D s_1017_44: write-var u#32937 <= s_1017_43
        fn_state.u_32937 = s_1017_43;
        // C s_1017_45: const #12s : i
        let s_1017_45: i128 = 12;
        // D s_1017_46: read-var u#32931:u32
        let s_1017_46: u32 = fn_state.u_32931;
        // D s_1017_47: cast zx s_1017_46 -> bv
        let s_1017_47: Bits = Bits::new(s_1017_46 as u128, 32u16);
        // C s_1017_48: const #1u : u64
        let s_1017_48: u64 = 1;
        // D s_1017_49: bit-extract s_1017_47 s_1017_45 s_1017_48
        let s_1017_49: Bits = (Bits::new(
            ((s_1017_47) >> (s_1017_45)).value(),
            u16::try_from(s_1017_48).unwrap(),
        ));
        // D s_1017_50: cast reint s_1017_49 -> u8
        let s_1017_50: bool = ((s_1017_49.value()) != 0);
        // C s_1017_51: const #0s : i
        let s_1017_51: i128 = 0;
        // C s_1017_52: const #0u : u64
        let s_1017_52: u64 = 0;
        // D s_1017_53: cast zx s_1017_50 -> u64
        let s_1017_53: u64 = (s_1017_50 as u64);
        // C s_1017_54: const #1u : u64
        let s_1017_54: u64 = 1;
        // D s_1017_55: and s_1017_53 s_1017_54
        let s_1017_55: u64 = ((s_1017_53) & (s_1017_54));
        // D s_1017_56: cmp-eq s_1017_55 s_1017_54
        let s_1017_56: bool = ((s_1017_55) == (s_1017_54));
        // D s_1017_57: lsl s_1017_53 s_1017_51
        let s_1017_57: u64 = s_1017_53 << s_1017_51;
        // D s_1017_58: or s_1017_52 s_1017_57
        let s_1017_58: u64 = ((s_1017_52) | (s_1017_57));
        // D s_1017_59: cmpl s_1017_57
        let s_1017_59: u64 = !s_1017_57;
        // D s_1017_60: and s_1017_52 s_1017_59
        let s_1017_60: u64 = ((s_1017_52) & (s_1017_59));
        // D s_1017_61: select s_1017_56 s_1017_58 s_1017_60
        let s_1017_61: u64 = if s_1017_56 { s_1017_58 } else { s_1017_60 };
        // D s_1017_62: cast trunc s_1017_61 -> u8
        let s_1017_62: bool = ((s_1017_61) != 0);
        // D s_1017_63: cast zx s_1017_62 -> bv
        let s_1017_63: Bits = Bits::new(s_1017_62 as u128, 1u16);
        // C s_1017_64: const #0u : u8
        let s_1017_64: bool = false;
        // C s_1017_65: cast zx s_1017_64 -> bv
        let s_1017_65: Bits = Bits::new(s_1017_64 as u128, 1u16);
        // D s_1017_66: cmp-ne s_1017_63 s_1017_65
        let s_1017_66: bool = ((s_1017_63) != (s_1017_65));
        // N s_1017_67: branch s_1017_66 b1028 b1018
        if s_1017_66 {
            return block_1028(state, tracer, fn_state);
        } else {
            return block_1018(state, tracer, fn_state);
        };
    }
    fn block_1018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1018_0: const #13s : i
        let s_1018_0: i128 = 13;
        // D s_1018_1: read-var u#32931:u32
        let s_1018_1: u32 = fn_state.u_32931;
        // D s_1018_2: cast zx s_1018_1 -> bv
        let s_1018_2: Bits = Bits::new(s_1018_1 as u128, 32u16);
        // C s_1018_3: const #1u : u64
        let s_1018_3: u64 = 1;
        // D s_1018_4: bit-extract s_1018_2 s_1018_0 s_1018_3
        let s_1018_4: Bits = (Bits::new(
            ((s_1018_2) >> (s_1018_0)).value(),
            u16::try_from(s_1018_3).unwrap(),
        ));
        // D s_1018_5: cast reint s_1018_4 -> u8
        let s_1018_5: bool = ((s_1018_4.value()) != 0);
        // C s_1018_6: const #0s : i
        let s_1018_6: i128 = 0;
        // C s_1018_7: const #0u : u64
        let s_1018_7: u64 = 0;
        // D s_1018_8: cast zx s_1018_5 -> u64
        let s_1018_8: u64 = (s_1018_5 as u64);
        // C s_1018_9: const #1u : u64
        let s_1018_9: u64 = 1;
        // D s_1018_10: and s_1018_8 s_1018_9
        let s_1018_10: u64 = ((s_1018_8) & (s_1018_9));
        // D s_1018_11: cmp-eq s_1018_10 s_1018_9
        let s_1018_11: bool = ((s_1018_10) == (s_1018_9));
        // D s_1018_12: lsl s_1018_8 s_1018_6
        let s_1018_12: u64 = s_1018_8 << s_1018_6;
        // D s_1018_13: or s_1018_7 s_1018_12
        let s_1018_13: u64 = ((s_1018_7) | (s_1018_12));
        // D s_1018_14: cmpl s_1018_12
        let s_1018_14: u64 = !s_1018_12;
        // D s_1018_15: and s_1018_7 s_1018_14
        let s_1018_15: u64 = ((s_1018_7) & (s_1018_14));
        // D s_1018_16: select s_1018_11 s_1018_13 s_1018_15
        let s_1018_16: u64 = if s_1018_11 { s_1018_13 } else { s_1018_15 };
        // D s_1018_17: cast trunc s_1018_16 -> u8
        let s_1018_17: bool = ((s_1018_16) != 0);
        // D s_1018_18: cast zx s_1018_17 -> bv
        let s_1018_18: Bits = Bits::new(s_1018_17 as u128, 1u16);
        // C s_1018_19: const #0u : u8
        let s_1018_19: bool = false;
        // C s_1018_20: cast zx s_1018_19 -> bv
        let s_1018_20: Bits = Bits::new(s_1018_19 as u128, 1u16);
        // D s_1018_21: cmp-ne s_1018_18 s_1018_20
        let s_1018_21: bool = ((s_1018_18) != (s_1018_20));
        // D s_1018_22: write-var gs#406577 <= s_1018_21
        fn_state.gs_406577 = s_1018_21;
        // N s_1018_23: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1019_0: read-var gs#406577:u8
        let s_1019_0: bool = fn_state.gs_406577;
        // N s_1019_1: branch s_1019_0 b1027 b1020
        if s_1019_0 {
            return block_1027(state, tracer, fn_state);
        } else {
            return block_1020(state, tracer, fn_state);
        };
    }
    fn block_1020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1020_0: const #14s : i
        let s_1020_0: i128 = 14;
        // D s_1020_1: read-var u#32931:u32
        let s_1020_1: u32 = fn_state.u_32931;
        // D s_1020_2: cast zx s_1020_1 -> bv
        let s_1020_2: Bits = Bits::new(s_1020_1 as u128, 32u16);
        // C s_1020_3: const #1u : u64
        let s_1020_3: u64 = 1;
        // D s_1020_4: bit-extract s_1020_2 s_1020_0 s_1020_3
        let s_1020_4: Bits = (Bits::new(
            ((s_1020_2) >> (s_1020_0)).value(),
            u16::try_from(s_1020_3).unwrap(),
        ));
        // D s_1020_5: cast reint s_1020_4 -> u8
        let s_1020_5: bool = ((s_1020_4.value()) != 0);
        // C s_1020_6: const #0s : i
        let s_1020_6: i128 = 0;
        // C s_1020_7: const #0u : u64
        let s_1020_7: u64 = 0;
        // D s_1020_8: cast zx s_1020_5 -> u64
        let s_1020_8: u64 = (s_1020_5 as u64);
        // C s_1020_9: const #1u : u64
        let s_1020_9: u64 = 1;
        // D s_1020_10: and s_1020_8 s_1020_9
        let s_1020_10: u64 = ((s_1020_8) & (s_1020_9));
        // D s_1020_11: cmp-eq s_1020_10 s_1020_9
        let s_1020_11: bool = ((s_1020_10) == (s_1020_9));
        // D s_1020_12: lsl s_1020_8 s_1020_6
        let s_1020_12: u64 = s_1020_8 << s_1020_6;
        // D s_1020_13: or s_1020_7 s_1020_12
        let s_1020_13: u64 = ((s_1020_7) | (s_1020_12));
        // D s_1020_14: cmpl s_1020_12
        let s_1020_14: u64 = !s_1020_12;
        // D s_1020_15: and s_1020_7 s_1020_14
        let s_1020_15: u64 = ((s_1020_7) & (s_1020_14));
        // D s_1020_16: select s_1020_11 s_1020_13 s_1020_15
        let s_1020_16: u64 = if s_1020_11 { s_1020_13 } else { s_1020_15 };
        // D s_1020_17: cast trunc s_1020_16 -> u8
        let s_1020_17: bool = ((s_1020_16) != 0);
        // D s_1020_18: cast zx s_1020_17 -> bv
        let s_1020_18: Bits = Bits::new(s_1020_17 as u128, 1u16);
        // C s_1020_19: const #0u : u8
        let s_1020_19: bool = false;
        // C s_1020_20: cast zx s_1020_19 -> bv
        let s_1020_20: Bits = Bits::new(s_1020_19 as u128, 1u16);
        // D s_1020_21: cmp-ne s_1020_18 s_1020_20
        let s_1020_21: bool = ((s_1020_18) != (s_1020_20));
        // D s_1020_22: write-var gs#406580 <= s_1020_21
        fn_state.gs_406580 = s_1020_21;
        // N s_1020_23: jump b1021
        return block_1021(state, tracer, fn_state);
    }
    fn block_1021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1021_0: read-var gs#406580:u8
        let s_1021_0: bool = fn_state.gs_406580;
        // N s_1021_1: branch s_1021_0 b1026 b1022
        if s_1021_0 {
            return block_1026(state, tracer, fn_state);
        } else {
            return block_1022(state, tracer, fn_state);
        };
    }
    fn block_1022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1022_0: const #15s : i
        let s_1022_0: i128 = 15;
        // D s_1022_1: read-var u#32931:u32
        let s_1022_1: u32 = fn_state.u_32931;
        // D s_1022_2: cast zx s_1022_1 -> bv
        let s_1022_2: Bits = Bits::new(s_1022_1 as u128, 32u16);
        // C s_1022_3: const #1u : u64
        let s_1022_3: u64 = 1;
        // D s_1022_4: bit-extract s_1022_2 s_1022_0 s_1022_3
        let s_1022_4: Bits = (Bits::new(
            ((s_1022_2) >> (s_1022_0)).value(),
            u16::try_from(s_1022_3).unwrap(),
        ));
        // D s_1022_5: cast reint s_1022_4 -> u8
        let s_1022_5: bool = ((s_1022_4.value()) != 0);
        // C s_1022_6: const #0s : i
        let s_1022_6: i128 = 0;
        // C s_1022_7: const #0u : u64
        let s_1022_7: u64 = 0;
        // D s_1022_8: cast zx s_1022_5 -> u64
        let s_1022_8: u64 = (s_1022_5 as u64);
        // C s_1022_9: const #1u : u64
        let s_1022_9: u64 = 1;
        // D s_1022_10: and s_1022_8 s_1022_9
        let s_1022_10: u64 = ((s_1022_8) & (s_1022_9));
        // D s_1022_11: cmp-eq s_1022_10 s_1022_9
        let s_1022_11: bool = ((s_1022_10) == (s_1022_9));
        // D s_1022_12: lsl s_1022_8 s_1022_6
        let s_1022_12: u64 = s_1022_8 << s_1022_6;
        // D s_1022_13: or s_1022_7 s_1022_12
        let s_1022_13: u64 = ((s_1022_7) | (s_1022_12));
        // D s_1022_14: cmpl s_1022_12
        let s_1022_14: u64 = !s_1022_12;
        // D s_1022_15: and s_1022_7 s_1022_14
        let s_1022_15: u64 = ((s_1022_7) & (s_1022_14));
        // D s_1022_16: select s_1022_11 s_1022_13 s_1022_15
        let s_1022_16: u64 = if s_1022_11 { s_1022_13 } else { s_1022_15 };
        // D s_1022_17: cast trunc s_1022_16 -> u8
        let s_1022_17: bool = ((s_1022_16) != 0);
        // D s_1022_18: cast zx s_1022_17 -> bv
        let s_1022_18: Bits = Bits::new(s_1022_17 as u128, 1u16);
        // C s_1022_19: const #0u : u8
        let s_1022_19: bool = false;
        // C s_1022_20: cast zx s_1022_19 -> bv
        let s_1022_20: Bits = Bits::new(s_1022_19 as u128, 1u16);
        // D s_1022_21: cmp-ne s_1022_18 s_1022_20
        let s_1022_21: bool = ((s_1022_18) != (s_1022_20));
        // D s_1022_22: write-var gs#406583 <= s_1022_21
        fn_state.gs_406583 = s_1022_21;
        // N s_1022_23: jump b1023
        return block_1023(state, tracer, fn_state);
    }
    fn block_1023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1023_0: read-var gs#406583:u8
        let s_1023_0: bool = fn_state.gs_406583;
        // N s_1023_1: branch s_1023_0 b1025 b1024
        if s_1023_0 {
            return block_1025(state, tracer, fn_state);
        } else {
            return block_1024(state, tracer, fn_state);
        };
    }
    fn block_1024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1024_0: read-var u#32932:u8
        let s_1024_0: u8 = fn_state.u_32932;
        // D s_1024_1: read-var u#32933:u8
        let s_1024_1: u8 = fn_state.u_32933;
        // D s_1024_2: read-var u#32934:u8
        let s_1024_2: u8 = fn_state.u_32934;
        // D s_1024_3: read-var u#32935:u8
        let s_1024_3: bool = fn_state.u_32935;
        // D s_1024_4: read-var u#32936:u8
        let s_1024_4: bool = fn_state.u_32936;
        // D s_1024_5: read-var u#32937:u8
        let s_1024_5: u8 = fn_state.u_32937;
        // D s_1024_6: call decode_aarch32_instrs_SMULBB_A1enc_A_txt(s_1024_0, s_1024_1, s_1024_2, s_1024_3, s_1024_4, s_1024_5)
        let s_1024_6: () = decode_aarch32_instrs_SMULBB_A1enc_A_txt(
            state,
            tracer,
            s_1024_0,
            s_1024_1,
            s_1024_2,
            s_1024_3,
            s_1024_4,
            s_1024_5,
        );
        // N s_1024_7: return
        return;
    }
    fn block_1025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1025_0: panic
        panic!("{:?}", ());
        // N s_1025_1: return
        return;
    }
    fn block_1026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1026_0: const #1u : u8
        let s_1026_0: bool = true;
        // D s_1026_1: write-var gs#406583 <= s_1026_0
        fn_state.gs_406583 = s_1026_0;
        // N s_1026_2: jump b1023
        return block_1023(state, tracer, fn_state);
    }
    fn block_1027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1027_0: const #1u : u8
        let s_1027_0: bool = true;
        // D s_1027_1: write-var gs#406580 <= s_1027_0
        fn_state.gs_406580 = s_1027_0;
        // N s_1027_2: jump b1021
        return block_1021(state, tracer, fn_state);
    }
    fn block_1028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1028_0: const #1u : u8
        let s_1028_0: bool = true;
        // D s_1028_1: write-var gs#406577 <= s_1028_0
        fn_state.gs_406577 = s_1028_0;
        // N s_1028_2: jump b1019
        return block_1019(state, tracer, fn_state);
    }
    fn block_1029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1029_0: read-var merge#var.1:struct
        let s_1029_0: u32 = fn_state.merge_var._1;
        // D s_1029_1: write-var u#32939 <= s_1029_0
        fn_state.u_32939 = s_1029_0;
        // C s_1029_2: const #21s : i
        let s_1029_2: i128 = 21;
        // D s_1029_3: read-var u#32939:u32
        let s_1029_3: u32 = fn_state.u_32939;
        // D s_1029_4: cast zx s_1029_3 -> bv
        let s_1029_4: Bits = Bits::new(s_1029_3 as u128, 32u16);
        // C s_1029_5: const #1s : i64
        let s_1029_5: i64 = 1;
        // C s_1029_6: cast zx s_1029_5 -> i
        let s_1029_6: i128 = (i128::try_from(s_1029_5).unwrap());
        // C s_1029_7: const #6s : i
        let s_1029_7: i128 = 6;
        // C s_1029_8: add s_1029_7 s_1029_6
        let s_1029_8: i128 = (s_1029_7 + s_1029_6);
        // D s_1029_9: bit-extract s_1029_4 s_1029_2 s_1029_8
        let s_1029_9: Bits = (Bits::new(
            ((s_1029_4) >> (s_1029_2)).value(),
            u16::try_from(s_1029_8).unwrap(),
        ));
        // D s_1029_10: cast reint s_1029_9 -> u8
        let s_1029_10: u8 = (s_1029_9.value() as u8);
        // D s_1029_11: cast zx s_1029_10 -> bv
        let s_1029_11: Bits = Bits::new(s_1029_10 as u128, 7u16);
        // C s_1029_12: const #6u : u8
        let s_1029_12: u8 = 6;
        // C s_1029_13: cast zx s_1029_12 -> bv
        let s_1029_13: Bits = Bits::new(s_1029_12 as u128, 7u16);
        // D s_1029_14: cmp-eq s_1029_11 s_1029_13
        let s_1029_14: bool = ((s_1029_11) == (s_1029_13));
        // N s_1029_15: branch s_1029_14 b2412 b1030
        if s_1029_14 {
            return block_2412(state, tracer, fn_state);
        } else {
            return block_1030(state, tracer, fn_state);
        };
    }
    fn block_1030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1030_0: const #0u : u8
        let s_1030_0: bool = false;
        // D s_1030_1: write-var gs#406589 <= s_1030_0
        fn_state.gs_406589 = s_1030_0;
        // N s_1030_2: jump b1031
        return block_1031(state, tracer, fn_state);
    }
    fn block_1031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1031_0: read-var gs#406589:u8
        let s_1031_0: bool = fn_state.gs_406589;
        // N s_1031_1: branch s_1031_0 b2408 b1032
        if s_1031_0 {
            return block_2408(state, tracer, fn_state);
        } else {
            return block_1032(state, tracer, fn_state);
        };
    }
    fn block_1032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1032_0: const #0u : u8
        let s_1032_0: bool = false;
        // D s_1032_1: write-var gs#406594 <= s_1032_0
        fn_state.gs_406594 = s_1032_0;
        // N s_1032_2: jump b1033
        return block_1033(state, tracer, fn_state);
    }
    fn block_1033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1033_0: read-var gs#406594:u8
        let s_1033_0: bool = fn_state.gs_406594;
        // D s_1033_1: not s_1033_0
        let s_1033_1: bool = !s_1033_0;
        // N s_1033_2: branch s_1033_1 b1035 b1034
        if s_1033_1 {
            return block_1035(state, tracer, fn_state);
        } else {
            return block_1034(state, tracer, fn_state);
        };
    }
    fn block_1034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1034_0: const #3168s : i
        let s_1034_0: i128 = 3168;
        // C s_1034_1: const #14696u : u32
        let s_1034_1: u32 = 14696;
        // N s_1034_2: write-reg s_1034_1 <= s_1034_0
        let s_1034_2: () = {
            state.write_register::<i128>(s_1034_1 as isize, s_1034_0);
            tracer.write_register(s_1034_1 as isize, s_1034_0);
        };
        // C s_1034_3: const #28s : i
        let s_1034_3: i128 = 28;
        // C s_1034_4: const #4s : i
        let s_1034_4: i128 = 4;
        // D s_1034_5: read-var u#32939:u32
        let s_1034_5: u32 = fn_state.u_32939;
        // D s_1034_6: cast zx s_1034_5 -> bv
        let s_1034_6: Bits = Bits::new(s_1034_5 as u128, 32u16);
        // D s_1034_7: bit-extract s_1034_6 s_1034_3 s_1034_4
        let s_1034_7: Bits = (Bits::new(
            ((s_1034_6) >> (s_1034_3)).value(),
            u16::try_from(s_1034_4).unwrap(),
        ));
        // D s_1034_8: cast reint s_1034_7 -> u8
        let s_1034_8: u8 = (s_1034_7.value() as u8);
        // C s_1034_9: const #20s : i
        let s_1034_9: i128 = 20;
        // C s_1034_10: const #1s : i
        let s_1034_10: i128 = 1;
        // D s_1034_11: read-var u#32939:u32
        let s_1034_11: u32 = fn_state.u_32939;
        // D s_1034_12: cast zx s_1034_11 -> bv
        let s_1034_12: Bits = Bits::new(s_1034_11 as u128, 32u16);
        // D s_1034_13: bit-extract s_1034_12 s_1034_9 s_1034_10
        let s_1034_13: Bits = (Bits::new(
            ((s_1034_12) >> (s_1034_9)).value(),
            u16::try_from(s_1034_10).unwrap(),
        ));
        // D s_1034_14: cast reint s_1034_13 -> u8
        let s_1034_14: bool = ((s_1034_13.value()) != 0);
        // C s_1034_15: const #16s : i
        let s_1034_15: i128 = 16;
        // C s_1034_16: const #4s : i
        let s_1034_16: i128 = 4;
        // D s_1034_17: read-var u#32939:u32
        let s_1034_17: u32 = fn_state.u_32939;
        // D s_1034_18: cast zx s_1034_17 -> bv
        let s_1034_18: Bits = Bits::new(s_1034_17 as u128, 32u16);
        // D s_1034_19: bit-extract s_1034_18 s_1034_15 s_1034_16
        let s_1034_19: Bits = (Bits::new(
            ((s_1034_18) >> (s_1034_15)).value(),
            u16::try_from(s_1034_16).unwrap(),
        ));
        // D s_1034_20: cast reint s_1034_19 -> u8
        let s_1034_20: u8 = (s_1034_19.value() as u8);
        // C s_1034_21: const #12s : i
        let s_1034_21: i128 = 12;
        // C s_1034_22: const #4s : i
        let s_1034_22: i128 = 4;
        // D s_1034_23: read-var u#32939:u32
        let s_1034_23: u32 = fn_state.u_32939;
        // D s_1034_24: cast zx s_1034_23 -> bv
        let s_1034_24: Bits = Bits::new(s_1034_23 as u128, 32u16);
        // D s_1034_25: bit-extract s_1034_24 s_1034_21 s_1034_22
        let s_1034_25: Bits = (Bits::new(
            ((s_1034_24) >> (s_1034_21)).value(),
            u16::try_from(s_1034_22).unwrap(),
        ));
        // D s_1034_26: cast reint s_1034_25 -> u8
        let s_1034_26: u8 = (s_1034_25.value() as u8);
        // C s_1034_27: const #8s : i
        let s_1034_27: i128 = 8;
        // C s_1034_28: const #4s : i
        let s_1034_28: i128 = 4;
        // D s_1034_29: read-var u#32939:u32
        let s_1034_29: u32 = fn_state.u_32939;
        // D s_1034_30: cast zx s_1034_29 -> bv
        let s_1034_30: Bits = Bits::new(s_1034_29 as u128, 32u16);
        // D s_1034_31: bit-extract s_1034_30 s_1034_27 s_1034_28
        let s_1034_31: Bits = (Bits::new(
            ((s_1034_30) >> (s_1034_27)).value(),
            u16::try_from(s_1034_28).unwrap(),
        ));
        // D s_1034_32: cast reint s_1034_31 -> u8
        let s_1034_32: u8 = (s_1034_31.value() as u8);
        // C s_1034_33: const #0s : i
        let s_1034_33: i128 = 0;
        // C s_1034_34: const #4s : i
        let s_1034_34: i128 = 4;
        // D s_1034_35: read-var u#32939:u32
        let s_1034_35: u32 = fn_state.u_32939;
        // D s_1034_36: cast zx s_1034_35 -> bv
        let s_1034_36: Bits = Bits::new(s_1034_35 as u128, 32u16);
        // D s_1034_37: bit-extract s_1034_36 s_1034_33 s_1034_34
        let s_1034_37: Bits = (Bits::new(
            ((s_1034_36) >> (s_1034_33)).value(),
            u16::try_from(s_1034_34).unwrap(),
        ));
        // D s_1034_38: cast reint s_1034_37 -> u8
        let s_1034_38: u8 = (s_1034_37.value() as u8);
        // D s_1034_39: call decode_aarch32_instrs_SMULL_A1enc_A_txt(s_1034_8, s_1034_14, s_1034_20, s_1034_26, s_1034_32, s_1034_38)
        let s_1034_39: () = decode_aarch32_instrs_SMULL_A1enc_A_txt(
            state,
            tracer,
            s_1034_8,
            s_1034_14,
            s_1034_20,
            s_1034_26,
            s_1034_32,
            s_1034_38,
        );
        // N s_1034_40: return
        return;
    }
    fn block_1035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1035_0: read-var merge#var.1:struct
        let s_1035_0: u32 = fn_state.merge_var._1;
        // D s_1035_1: write-var u#32947 <= s_1035_0
        fn_state.u_32947 = s_1035_0;
        // C s_1035_2: const #20s : i
        let s_1035_2: i128 = 20;
        // D s_1035_3: read-var u#32947:u32
        let s_1035_3: u32 = fn_state.u_32947;
        // D s_1035_4: cast zx s_1035_3 -> bv
        let s_1035_4: Bits = Bits::new(s_1035_3 as u128, 32u16);
        // C s_1035_5: const #1s : i64
        let s_1035_5: i64 = 1;
        // C s_1035_6: cast zx s_1035_5 -> i
        let s_1035_6: i128 = (i128::try_from(s_1035_5).unwrap());
        // C s_1035_7: const #7s : i
        let s_1035_7: i128 = 7;
        // C s_1035_8: add s_1035_7 s_1035_6
        let s_1035_8: i128 = (s_1035_7 + s_1035_6);
        // D s_1035_9: bit-extract s_1035_4 s_1035_2 s_1035_8
        let s_1035_9: Bits = (Bits::new(
            ((s_1035_4) >> (s_1035_2)).value(),
            u16::try_from(s_1035_8).unwrap(),
        ));
        // D s_1035_10: cast reint s_1035_9 -> u8
        let s_1035_10: u8 = (s_1035_9.value() as u8);
        // D s_1035_11: cast zx s_1035_10 -> bv
        let s_1035_11: Bits = Bits::new(s_1035_10 as u128, 8u16);
        // C s_1035_12: const #18u : u8
        let s_1035_12: u8 = 18;
        // C s_1035_13: cast zx s_1035_12 -> bv
        let s_1035_13: Bits = Bits::new(s_1035_12 as u128, 8u16);
        // D s_1035_14: cmp-eq s_1035_11 s_1035_13
        let s_1035_14: bool = ((s_1035_11) == (s_1035_13));
        // N s_1035_15: branch s_1035_14 b2401 b1036
        if s_1035_14 {
            return block_2401(state, tracer, fn_state);
        } else {
            return block_1036(state, tracer, fn_state);
        };
    }
    fn block_1036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1036_0: const #0u : u8
        let s_1036_0: bool = false;
        // D s_1036_1: write-var gs#406620 <= s_1036_0
        fn_state.gs_406620 = s_1036_0;
        // N s_1036_2: jump b1037
        return block_1037(state, tracer, fn_state);
    }
    fn block_1037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1037_0: read-var gs#406620:u8
        let s_1037_0: bool = fn_state.gs_406620;
        // N s_1037_1: branch s_1037_0 b2397 b1038
        if s_1037_0 {
            return block_2397(state, tracer, fn_state);
        } else {
            return block_1038(state, tracer, fn_state);
        };
    }
    fn block_1038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1038_0: const #0u : u8
        let s_1038_0: bool = false;
        // D s_1038_1: write-var gs#406625 <= s_1038_0
        fn_state.gs_406625 = s_1038_0;
        // N s_1038_2: jump b1039
        return block_1039(state, tracer, fn_state);
    }
    fn block_1039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1039_0: read-var gs#406625:u8
        let s_1039_0: bool = fn_state.gs_406625;
        // D s_1039_1: not s_1039_0
        let s_1039_1: bool = !s_1039_0;
        // N s_1039_2: branch s_1039_1 b1052 b1040
        if s_1039_1 {
            return block_1052(state, tracer, fn_state);
        } else {
            return block_1040(state, tracer, fn_state);
        };
    }
    fn block_1040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1040_0: const #3170s : i
        let s_1040_0: i128 = 3170;
        // C s_1040_1: const #14696u : u32
        let s_1040_1: u32 = 14696;
        // N s_1040_2: write-reg s_1040_1 <= s_1040_0
        let s_1040_2: () = {
            state.write_register::<i128>(s_1040_1 as isize, s_1040_0);
            tracer.write_register(s_1040_1 as isize, s_1040_0);
        };
        // C s_1040_3: const #28s : i
        let s_1040_3: i128 = 28;
        // C s_1040_4: const #4s : i
        let s_1040_4: i128 = 4;
        // D s_1040_5: read-var u#32947:u32
        let s_1040_5: u32 = fn_state.u_32947;
        // D s_1040_6: cast zx s_1040_5 -> bv
        let s_1040_6: Bits = Bits::new(s_1040_5 as u128, 32u16);
        // D s_1040_7: bit-extract s_1040_6 s_1040_3 s_1040_4
        let s_1040_7: Bits = (Bits::new(
            ((s_1040_6) >> (s_1040_3)).value(),
            u16::try_from(s_1040_4).unwrap(),
        ));
        // D s_1040_8: cast reint s_1040_7 -> u8
        let s_1040_8: u8 = (s_1040_7.value() as u8);
        // D s_1040_9: write-var u#32948 <= s_1040_8
        fn_state.u_32948 = s_1040_8;
        // C s_1040_10: const #16s : i
        let s_1040_10: i128 = 16;
        // C s_1040_11: const #4s : i
        let s_1040_11: i128 = 4;
        // D s_1040_12: read-var u#32947:u32
        let s_1040_12: u32 = fn_state.u_32947;
        // D s_1040_13: cast zx s_1040_12 -> bv
        let s_1040_13: Bits = Bits::new(s_1040_12 as u128, 32u16);
        // D s_1040_14: bit-extract s_1040_13 s_1040_10 s_1040_11
        let s_1040_14: Bits = (Bits::new(
            ((s_1040_13) >> (s_1040_10)).value(),
            u16::try_from(s_1040_11).unwrap(),
        ));
        // D s_1040_15: cast reint s_1040_14 -> u8
        let s_1040_15: u8 = (s_1040_14.value() as u8);
        // D s_1040_16: write-var u#32949 <= s_1040_15
        fn_state.u_32949 = s_1040_15;
        // C s_1040_17: const #8s : i
        let s_1040_17: i128 = 8;
        // C s_1040_18: const #4s : i
        let s_1040_18: i128 = 4;
        // D s_1040_19: read-var u#32947:u32
        let s_1040_19: u32 = fn_state.u_32947;
        // D s_1040_20: cast zx s_1040_19 -> bv
        let s_1040_20: Bits = Bits::new(s_1040_19 as u128, 32u16);
        // D s_1040_21: bit-extract s_1040_20 s_1040_17 s_1040_18
        let s_1040_21: Bits = (Bits::new(
            ((s_1040_20) >> (s_1040_17)).value(),
            u16::try_from(s_1040_18).unwrap(),
        ));
        // D s_1040_22: cast reint s_1040_21 -> u8
        let s_1040_22: u8 = (s_1040_21.value() as u8);
        // D s_1040_23: write-var u#32950 <= s_1040_22
        fn_state.u_32950 = s_1040_22;
        // C s_1040_24: const #6s : i
        let s_1040_24: i128 = 6;
        // C s_1040_25: const #1s : i
        let s_1040_25: i128 = 1;
        // D s_1040_26: read-var u#32947:u32
        let s_1040_26: u32 = fn_state.u_32947;
        // D s_1040_27: cast zx s_1040_26 -> bv
        let s_1040_27: Bits = Bits::new(s_1040_26 as u128, 32u16);
        // D s_1040_28: bit-extract s_1040_27 s_1040_24 s_1040_25
        let s_1040_28: Bits = (Bits::new(
            ((s_1040_27) >> (s_1040_24)).value(),
            u16::try_from(s_1040_25).unwrap(),
        ));
        // D s_1040_29: cast reint s_1040_28 -> u8
        let s_1040_29: bool = ((s_1040_28.value()) != 0);
        // D s_1040_30: write-var u#32951 <= s_1040_29
        fn_state.u_32951 = s_1040_29;
        // C s_1040_31: const #0s : i
        let s_1040_31: i128 = 0;
        // C s_1040_32: const #4s : i
        let s_1040_32: i128 = 4;
        // D s_1040_33: read-var u#32947:u32
        let s_1040_33: u32 = fn_state.u_32947;
        // D s_1040_34: cast zx s_1040_33 -> bv
        let s_1040_34: Bits = Bits::new(s_1040_33 as u128, 32u16);
        // D s_1040_35: bit-extract s_1040_34 s_1040_31 s_1040_32
        let s_1040_35: Bits = (Bits::new(
            ((s_1040_34) >> (s_1040_31)).value(),
            u16::try_from(s_1040_32).unwrap(),
        ));
        // D s_1040_36: cast reint s_1040_35 -> u8
        let s_1040_36: u8 = (s_1040_35.value() as u8);
        // D s_1040_37: write-var u#32952 <= s_1040_36
        fn_state.u_32952 = s_1040_36;
        // C s_1040_38: const #12s : i
        let s_1040_38: i128 = 12;
        // D s_1040_39: read-var u#32947:u32
        let s_1040_39: u32 = fn_state.u_32947;
        // D s_1040_40: cast zx s_1040_39 -> bv
        let s_1040_40: Bits = Bits::new(s_1040_39 as u128, 32u16);
        // C s_1040_41: const #1u : u64
        let s_1040_41: u64 = 1;
        // D s_1040_42: bit-extract s_1040_40 s_1040_38 s_1040_41
        let s_1040_42: Bits = (Bits::new(
            ((s_1040_40) >> (s_1040_38)).value(),
            u16::try_from(s_1040_41).unwrap(),
        ));
        // D s_1040_43: cast reint s_1040_42 -> u8
        let s_1040_43: bool = ((s_1040_42.value()) != 0);
        // C s_1040_44: const #0s : i
        let s_1040_44: i128 = 0;
        // C s_1040_45: const #0u : u64
        let s_1040_45: u64 = 0;
        // D s_1040_46: cast zx s_1040_43 -> u64
        let s_1040_46: u64 = (s_1040_43 as u64);
        // C s_1040_47: const #1u : u64
        let s_1040_47: u64 = 1;
        // D s_1040_48: and s_1040_46 s_1040_47
        let s_1040_48: u64 = ((s_1040_46) & (s_1040_47));
        // D s_1040_49: cmp-eq s_1040_48 s_1040_47
        let s_1040_49: bool = ((s_1040_48) == (s_1040_47));
        // D s_1040_50: lsl s_1040_46 s_1040_44
        let s_1040_50: u64 = s_1040_46 << s_1040_44;
        // D s_1040_51: or s_1040_45 s_1040_50
        let s_1040_51: u64 = ((s_1040_45) | (s_1040_50));
        // D s_1040_52: cmpl s_1040_50
        let s_1040_52: u64 = !s_1040_50;
        // D s_1040_53: and s_1040_45 s_1040_52
        let s_1040_53: u64 = ((s_1040_45) & (s_1040_52));
        // D s_1040_54: select s_1040_49 s_1040_51 s_1040_53
        let s_1040_54: u64 = if s_1040_49 { s_1040_51 } else { s_1040_53 };
        // D s_1040_55: cast trunc s_1040_54 -> u8
        let s_1040_55: bool = ((s_1040_54) != 0);
        // D s_1040_56: cast zx s_1040_55 -> bv
        let s_1040_56: Bits = Bits::new(s_1040_55 as u128, 1u16);
        // C s_1040_57: const #0u : u8
        let s_1040_57: bool = false;
        // C s_1040_58: cast zx s_1040_57 -> bv
        let s_1040_58: Bits = Bits::new(s_1040_57 as u128, 1u16);
        // D s_1040_59: cmp-ne s_1040_56 s_1040_58
        let s_1040_59: bool = ((s_1040_56) != (s_1040_58));
        // N s_1040_60: branch s_1040_59 b1051 b1041
        if s_1040_59 {
            return block_1051(state, tracer, fn_state);
        } else {
            return block_1041(state, tracer, fn_state);
        };
    }
    fn block_1041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1041_0: const #13s : i
        let s_1041_0: i128 = 13;
        // D s_1041_1: read-var u#32947:u32
        let s_1041_1: u32 = fn_state.u_32947;
        // D s_1041_2: cast zx s_1041_1 -> bv
        let s_1041_2: Bits = Bits::new(s_1041_1 as u128, 32u16);
        // C s_1041_3: const #1u : u64
        let s_1041_3: u64 = 1;
        // D s_1041_4: bit-extract s_1041_2 s_1041_0 s_1041_3
        let s_1041_4: Bits = (Bits::new(
            ((s_1041_2) >> (s_1041_0)).value(),
            u16::try_from(s_1041_3).unwrap(),
        ));
        // D s_1041_5: cast reint s_1041_4 -> u8
        let s_1041_5: bool = ((s_1041_4.value()) != 0);
        // C s_1041_6: const #0s : i
        let s_1041_6: i128 = 0;
        // C s_1041_7: const #0u : u64
        let s_1041_7: u64 = 0;
        // D s_1041_8: cast zx s_1041_5 -> u64
        let s_1041_8: u64 = (s_1041_5 as u64);
        // C s_1041_9: const #1u : u64
        let s_1041_9: u64 = 1;
        // D s_1041_10: and s_1041_8 s_1041_9
        let s_1041_10: u64 = ((s_1041_8) & (s_1041_9));
        // D s_1041_11: cmp-eq s_1041_10 s_1041_9
        let s_1041_11: bool = ((s_1041_10) == (s_1041_9));
        // D s_1041_12: lsl s_1041_8 s_1041_6
        let s_1041_12: u64 = s_1041_8 << s_1041_6;
        // D s_1041_13: or s_1041_7 s_1041_12
        let s_1041_13: u64 = ((s_1041_7) | (s_1041_12));
        // D s_1041_14: cmpl s_1041_12
        let s_1041_14: u64 = !s_1041_12;
        // D s_1041_15: and s_1041_7 s_1041_14
        let s_1041_15: u64 = ((s_1041_7) & (s_1041_14));
        // D s_1041_16: select s_1041_11 s_1041_13 s_1041_15
        let s_1041_16: u64 = if s_1041_11 { s_1041_13 } else { s_1041_15 };
        // D s_1041_17: cast trunc s_1041_16 -> u8
        let s_1041_17: bool = ((s_1041_16) != 0);
        // D s_1041_18: cast zx s_1041_17 -> bv
        let s_1041_18: Bits = Bits::new(s_1041_17 as u128, 1u16);
        // C s_1041_19: const #0u : u8
        let s_1041_19: bool = false;
        // C s_1041_20: cast zx s_1041_19 -> bv
        let s_1041_20: Bits = Bits::new(s_1041_19 as u128, 1u16);
        // D s_1041_21: cmp-ne s_1041_18 s_1041_20
        let s_1041_21: bool = ((s_1041_18) != (s_1041_20));
        // D s_1041_22: write-var gs#406642 <= s_1041_21
        fn_state.gs_406642 = s_1041_21;
        // N s_1041_23: jump b1042
        return block_1042(state, tracer, fn_state);
    }
    fn block_1042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1042_0: read-var gs#406642:u8
        let s_1042_0: bool = fn_state.gs_406642;
        // N s_1042_1: branch s_1042_0 b1050 b1043
        if s_1042_0 {
            return block_1050(state, tracer, fn_state);
        } else {
            return block_1043(state, tracer, fn_state);
        };
    }
    fn block_1043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1043_0: const #14s : i
        let s_1043_0: i128 = 14;
        // D s_1043_1: read-var u#32947:u32
        let s_1043_1: u32 = fn_state.u_32947;
        // D s_1043_2: cast zx s_1043_1 -> bv
        let s_1043_2: Bits = Bits::new(s_1043_1 as u128, 32u16);
        // C s_1043_3: const #1u : u64
        let s_1043_3: u64 = 1;
        // D s_1043_4: bit-extract s_1043_2 s_1043_0 s_1043_3
        let s_1043_4: Bits = (Bits::new(
            ((s_1043_2) >> (s_1043_0)).value(),
            u16::try_from(s_1043_3).unwrap(),
        ));
        // D s_1043_5: cast reint s_1043_4 -> u8
        let s_1043_5: bool = ((s_1043_4.value()) != 0);
        // C s_1043_6: const #0s : i
        let s_1043_6: i128 = 0;
        // C s_1043_7: const #0u : u64
        let s_1043_7: u64 = 0;
        // D s_1043_8: cast zx s_1043_5 -> u64
        let s_1043_8: u64 = (s_1043_5 as u64);
        // C s_1043_9: const #1u : u64
        let s_1043_9: u64 = 1;
        // D s_1043_10: and s_1043_8 s_1043_9
        let s_1043_10: u64 = ((s_1043_8) & (s_1043_9));
        // D s_1043_11: cmp-eq s_1043_10 s_1043_9
        let s_1043_11: bool = ((s_1043_10) == (s_1043_9));
        // D s_1043_12: lsl s_1043_8 s_1043_6
        let s_1043_12: u64 = s_1043_8 << s_1043_6;
        // D s_1043_13: or s_1043_7 s_1043_12
        let s_1043_13: u64 = ((s_1043_7) | (s_1043_12));
        // D s_1043_14: cmpl s_1043_12
        let s_1043_14: u64 = !s_1043_12;
        // D s_1043_15: and s_1043_7 s_1043_14
        let s_1043_15: u64 = ((s_1043_7) & (s_1043_14));
        // D s_1043_16: select s_1043_11 s_1043_13 s_1043_15
        let s_1043_16: u64 = if s_1043_11 { s_1043_13 } else { s_1043_15 };
        // D s_1043_17: cast trunc s_1043_16 -> u8
        let s_1043_17: bool = ((s_1043_16) != 0);
        // D s_1043_18: cast zx s_1043_17 -> bv
        let s_1043_18: Bits = Bits::new(s_1043_17 as u128, 1u16);
        // C s_1043_19: const #0u : u8
        let s_1043_19: bool = false;
        // C s_1043_20: cast zx s_1043_19 -> bv
        let s_1043_20: Bits = Bits::new(s_1043_19 as u128, 1u16);
        // D s_1043_21: cmp-ne s_1043_18 s_1043_20
        let s_1043_21: bool = ((s_1043_18) != (s_1043_20));
        // D s_1043_22: write-var gs#406645 <= s_1043_21
        fn_state.gs_406645 = s_1043_21;
        // N s_1043_23: jump b1044
        return block_1044(state, tracer, fn_state);
    }
    fn block_1044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1044_0: read-var gs#406645:u8
        let s_1044_0: bool = fn_state.gs_406645;
        // N s_1044_1: branch s_1044_0 b1049 b1045
        if s_1044_0 {
            return block_1049(state, tracer, fn_state);
        } else {
            return block_1045(state, tracer, fn_state);
        };
    }
    fn block_1045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1045_0: const #15s : i
        let s_1045_0: i128 = 15;
        // D s_1045_1: read-var u#32947:u32
        let s_1045_1: u32 = fn_state.u_32947;
        // D s_1045_2: cast zx s_1045_1 -> bv
        let s_1045_2: Bits = Bits::new(s_1045_1 as u128, 32u16);
        // C s_1045_3: const #1u : u64
        let s_1045_3: u64 = 1;
        // D s_1045_4: bit-extract s_1045_2 s_1045_0 s_1045_3
        let s_1045_4: Bits = (Bits::new(
            ((s_1045_2) >> (s_1045_0)).value(),
            u16::try_from(s_1045_3).unwrap(),
        ));
        // D s_1045_5: cast reint s_1045_4 -> u8
        let s_1045_5: bool = ((s_1045_4.value()) != 0);
        // C s_1045_6: const #0s : i
        let s_1045_6: i128 = 0;
        // C s_1045_7: const #0u : u64
        let s_1045_7: u64 = 0;
        // D s_1045_8: cast zx s_1045_5 -> u64
        let s_1045_8: u64 = (s_1045_5 as u64);
        // C s_1045_9: const #1u : u64
        let s_1045_9: u64 = 1;
        // D s_1045_10: and s_1045_8 s_1045_9
        let s_1045_10: u64 = ((s_1045_8) & (s_1045_9));
        // D s_1045_11: cmp-eq s_1045_10 s_1045_9
        let s_1045_11: bool = ((s_1045_10) == (s_1045_9));
        // D s_1045_12: lsl s_1045_8 s_1045_6
        let s_1045_12: u64 = s_1045_8 << s_1045_6;
        // D s_1045_13: or s_1045_7 s_1045_12
        let s_1045_13: u64 = ((s_1045_7) | (s_1045_12));
        // D s_1045_14: cmpl s_1045_12
        let s_1045_14: u64 = !s_1045_12;
        // D s_1045_15: and s_1045_7 s_1045_14
        let s_1045_15: u64 = ((s_1045_7) & (s_1045_14));
        // D s_1045_16: select s_1045_11 s_1045_13 s_1045_15
        let s_1045_16: u64 = if s_1045_11 { s_1045_13 } else { s_1045_15 };
        // D s_1045_17: cast trunc s_1045_16 -> u8
        let s_1045_17: bool = ((s_1045_16) != 0);
        // D s_1045_18: cast zx s_1045_17 -> bv
        let s_1045_18: Bits = Bits::new(s_1045_17 as u128, 1u16);
        // C s_1045_19: const #0u : u8
        let s_1045_19: bool = false;
        // C s_1045_20: cast zx s_1045_19 -> bv
        let s_1045_20: Bits = Bits::new(s_1045_19 as u128, 1u16);
        // D s_1045_21: cmp-ne s_1045_18 s_1045_20
        let s_1045_21: bool = ((s_1045_18) != (s_1045_20));
        // D s_1045_22: write-var gs#406648 <= s_1045_21
        fn_state.gs_406648 = s_1045_21;
        // N s_1045_23: jump b1046
        return block_1046(state, tracer, fn_state);
    }
    fn block_1046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1046_0: read-var gs#406648:u8
        let s_1046_0: bool = fn_state.gs_406648;
        // N s_1046_1: branch s_1046_0 b1048 b1047
        if s_1046_0 {
            return block_1048(state, tracer, fn_state);
        } else {
            return block_1047(state, tracer, fn_state);
        };
    }
    fn block_1047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1047_0: read-var u#32948:u8
        let s_1047_0: u8 = fn_state.u_32948;
        // D s_1047_1: read-var u#32949:u8
        let s_1047_1: u8 = fn_state.u_32949;
        // D s_1047_2: read-var u#32950:u8
        let s_1047_2: u8 = fn_state.u_32950;
        // D s_1047_3: read-var u#32951:u8
        let s_1047_3: bool = fn_state.u_32951;
        // D s_1047_4: read-var u#32952:u8
        let s_1047_4: u8 = fn_state.u_32952;
        // D s_1047_5: call decode_aarch32_instrs_SMULWB_A1enc_A_txt(s_1047_0, s_1047_1, s_1047_2, s_1047_3, s_1047_4)
        let s_1047_5: () = decode_aarch32_instrs_SMULWB_A1enc_A_txt(
            state,
            tracer,
            s_1047_0,
            s_1047_1,
            s_1047_2,
            s_1047_3,
            s_1047_4,
        );
        // N s_1047_6: return
        return;
    }
    fn block_1048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1048_0: panic
        panic!("{:?}", ());
        // N s_1048_1: return
        return;
    }
    fn block_1049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1049_0: const #1u : u8
        let s_1049_0: bool = true;
        // D s_1049_1: write-var gs#406648 <= s_1049_0
        fn_state.gs_406648 = s_1049_0;
        // N s_1049_2: jump b1046
        return block_1046(state, tracer, fn_state);
    }
    fn block_1050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1050_0: const #1u : u8
        let s_1050_0: bool = true;
        // D s_1050_1: write-var gs#406645 <= s_1050_0
        fn_state.gs_406645 = s_1050_0;
        // N s_1050_2: jump b1044
        return block_1044(state, tracer, fn_state);
    }
    fn block_1051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1051_0: const #1u : u8
        let s_1051_0: bool = true;
        // D s_1051_1: write-var gs#406642 <= s_1051_0
        fn_state.gs_406642 = s_1051_0;
        // N s_1051_2: jump b1042
        return block_1042(state, tracer, fn_state);
    }
    fn block_1052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1052_0: read-var merge#var.1:struct
        let s_1052_0: u32 = fn_state.merge_var._1;
        // D s_1052_1: write-var u#32954 <= s_1052_0
        fn_state.u_32954 = s_1052_0;
        // C s_1052_2: const #25s : i
        let s_1052_2: i128 = 25;
        // D s_1052_3: read-var u#32954:u32
        let s_1052_3: u32 = fn_state.u_32954;
        // D s_1052_4: cast zx s_1052_3 -> bv
        let s_1052_4: Bits = Bits::new(s_1052_3 as u128, 32u16);
        // C s_1052_5: const #1s : i64
        let s_1052_5: i64 = 1;
        // C s_1052_6: cast zx s_1052_5 -> i
        let s_1052_6: i128 = (i128::try_from(s_1052_5).unwrap());
        // C s_1052_7: const #2s : i
        let s_1052_7: i128 = 2;
        // C s_1052_8: add s_1052_7 s_1052_6
        let s_1052_8: i128 = (s_1052_7 + s_1052_6);
        // D s_1052_9: bit-extract s_1052_4 s_1052_2 s_1052_8
        let s_1052_9: Bits = (Bits::new(
            ((s_1052_4) >> (s_1052_2)).value(),
            u16::try_from(s_1052_8).unwrap(),
        ));
        // D s_1052_10: cast reint s_1052_9 -> u8
        let s_1052_10: u8 = (s_1052_9.value() as u8);
        // D s_1052_11: cast zx s_1052_10 -> bv
        let s_1052_11: Bits = Bits::new(s_1052_10 as u128, 3u16);
        // C s_1052_12: const #0u : u8
        let s_1052_12: u8 = 0;
        // C s_1052_13: cast zx s_1052_12 -> bv
        let s_1052_13: Bits = Bits::new(s_1052_12 as u128, 3u16);
        // D s_1052_14: cmp-eq s_1052_11 s_1052_13
        let s_1052_14: bool = ((s_1052_11) == (s_1052_13));
        // N s_1052_15: branch s_1052_14 b2390 b1053
        if s_1052_14 {
            return block_2390(state, tracer, fn_state);
        } else {
            return block_1053(state, tracer, fn_state);
        };
    }
    fn block_1053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1053_0: const #0u : u8
        let s_1053_0: bool = false;
        // D s_1053_1: write-var gs#406660 <= s_1053_0
        fn_state.gs_406660 = s_1053_0;
        // N s_1053_2: jump b1054
        return block_1054(state, tracer, fn_state);
    }
    fn block_1054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1054_0: read-var gs#406660:u8
        let s_1054_0: bool = fn_state.gs_406660;
        // N s_1054_1: branch s_1054_0 b2386 b1055
        if s_1054_0 {
            return block_2386(state, tracer, fn_state);
        } else {
            return block_1055(state, tracer, fn_state);
        };
    }
    fn block_1055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1055_0: const #0u : u8
        let s_1055_0: bool = false;
        // D s_1055_1: write-var gs#406665 <= s_1055_0
        fn_state.gs_406665 = s_1055_0;
        // N s_1055_2: jump b1056
        return block_1056(state, tracer, fn_state);
    }
    fn block_1056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1056_0: read-var gs#406665:u8
        let s_1056_0: bool = fn_state.gs_406665;
        // D s_1056_1: not s_1056_0
        let s_1056_1: bool = !s_1056_0;
        // N s_1056_2: branch s_1056_1 b1058 b1057
        if s_1056_1 {
            return block_1058(state, tracer, fn_state);
        } else {
            return block_1057(state, tracer, fn_state);
        };
    }
    fn block_1057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1057_0: const #3203s : i
        let s_1057_0: i128 = 3203;
        // C s_1057_1: const #14696u : u32
        let s_1057_1: u32 = 14696;
        // N s_1057_2: write-reg s_1057_1 <= s_1057_0
        let s_1057_2: () = {
            state.write_register::<i128>(s_1057_1 as isize, s_1057_0);
            tracer.write_register(s_1057_1 as isize, s_1057_0);
        };
        // C s_1057_3: const #28s : i
        let s_1057_3: i128 = 28;
        // C s_1057_4: const #4s : i
        let s_1057_4: i128 = 4;
        // D s_1057_5: read-var u#32954:u32
        let s_1057_5: u32 = fn_state.u_32954;
        // D s_1057_6: cast zx s_1057_5 -> bv
        let s_1057_6: Bits = Bits::new(s_1057_5 as u128, 32u16);
        // D s_1057_7: bit-extract s_1057_6 s_1057_3 s_1057_4
        let s_1057_7: Bits = (Bits::new(
            ((s_1057_6) >> (s_1057_3)).value(),
            u16::try_from(s_1057_4).unwrap(),
        ));
        // D s_1057_8: cast reint s_1057_7 -> u8
        let s_1057_8: u8 = (s_1057_7.value() as u8);
        // C s_1057_9: const #24s : i
        let s_1057_9: i128 = 24;
        // C s_1057_10: const #1s : i
        let s_1057_10: i128 = 1;
        // D s_1057_11: read-var u#32954:u32
        let s_1057_11: u32 = fn_state.u_32954;
        // D s_1057_12: cast zx s_1057_11 -> bv
        let s_1057_12: Bits = Bits::new(s_1057_11 as u128, 32u16);
        // D s_1057_13: bit-extract s_1057_12 s_1057_9 s_1057_10
        let s_1057_13: Bits = (Bits::new(
            ((s_1057_12) >> (s_1057_9)).value(),
            u16::try_from(s_1057_10).unwrap(),
        ));
        // D s_1057_14: cast reint s_1057_13 -> u8
        let s_1057_14: bool = ((s_1057_13.value()) != 0);
        // C s_1057_15: const #23s : i
        let s_1057_15: i128 = 23;
        // C s_1057_16: const #1s : i
        let s_1057_16: i128 = 1;
        // D s_1057_17: read-var u#32954:u32
        let s_1057_17: u32 = fn_state.u_32954;
        // D s_1057_18: cast zx s_1057_17 -> bv
        let s_1057_18: Bits = Bits::new(s_1057_17 as u128, 32u16);
        // D s_1057_19: bit-extract s_1057_18 s_1057_15 s_1057_16
        let s_1057_19: Bits = (Bits::new(
            ((s_1057_18) >> (s_1057_15)).value(),
            u16::try_from(s_1057_16).unwrap(),
        ));
        // D s_1057_20: cast reint s_1057_19 -> u8
        let s_1057_20: bool = ((s_1057_19.value()) != 0);
        // C s_1057_21: const #21s : i
        let s_1057_21: i128 = 21;
        // C s_1057_22: const #1s : i
        let s_1057_22: i128 = 1;
        // D s_1057_23: read-var u#32954:u32
        let s_1057_23: u32 = fn_state.u_32954;
        // D s_1057_24: cast zx s_1057_23 -> bv
        let s_1057_24: Bits = Bits::new(s_1057_23 as u128, 32u16);
        // D s_1057_25: bit-extract s_1057_24 s_1057_21 s_1057_22
        let s_1057_25: Bits = (Bits::new(
            ((s_1057_24) >> (s_1057_21)).value(),
            u16::try_from(s_1057_22).unwrap(),
        ));
        // D s_1057_26: cast reint s_1057_25 -> u8
        let s_1057_26: bool = ((s_1057_25.value()) != 0);
        // C s_1057_27: const #16s : i
        let s_1057_27: i128 = 16;
        // C s_1057_28: const #4s : i
        let s_1057_28: i128 = 4;
        // D s_1057_29: read-var u#32954:u32
        let s_1057_29: u32 = fn_state.u_32954;
        // D s_1057_30: cast zx s_1057_29 -> bv
        let s_1057_30: Bits = Bits::new(s_1057_29 as u128, 32u16);
        // D s_1057_31: bit-extract s_1057_30 s_1057_27 s_1057_28
        let s_1057_31: Bits = (Bits::new(
            ((s_1057_30) >> (s_1057_27)).value(),
            u16::try_from(s_1057_28).unwrap(),
        ));
        // D s_1057_32: cast reint s_1057_31 -> u8
        let s_1057_32: u8 = (s_1057_31.value() as u8);
        // C s_1057_33: const #12s : i
        let s_1057_33: i128 = 12;
        // C s_1057_34: const #4s : i
        let s_1057_34: i128 = 4;
        // D s_1057_35: read-var u#32954:u32
        let s_1057_35: u32 = fn_state.u_32954;
        // D s_1057_36: cast zx s_1057_35 -> bv
        let s_1057_36: Bits = Bits::new(s_1057_35 as u128, 32u16);
        // D s_1057_37: bit-extract s_1057_36 s_1057_33 s_1057_34
        let s_1057_37: Bits = (Bits::new(
            ((s_1057_36) >> (s_1057_33)).value(),
            u16::try_from(s_1057_34).unwrap(),
        ));
        // D s_1057_38: cast reint s_1057_37 -> u8
        let s_1057_38: u8 = (s_1057_37.value() as u8);
        // C s_1057_39: const #8s : i
        let s_1057_39: i128 = 8;
        // C s_1057_40: const #4s : i
        let s_1057_40: i128 = 4;
        // D s_1057_41: read-var u#32954:u32
        let s_1057_41: u32 = fn_state.u_32954;
        // D s_1057_42: cast zx s_1057_41 -> bv
        let s_1057_42: Bits = Bits::new(s_1057_41 as u128, 32u16);
        // D s_1057_43: bit-extract s_1057_42 s_1057_39 s_1057_40
        let s_1057_43: Bits = (Bits::new(
            ((s_1057_42) >> (s_1057_39)).value(),
            u16::try_from(s_1057_40).unwrap(),
        ));
        // D s_1057_44: cast reint s_1057_43 -> u8
        let s_1057_44: u8 = (s_1057_43.value() as u8);
        // C s_1057_45: const #0s : i
        let s_1057_45: i128 = 0;
        // C s_1057_46: const #4s : i
        let s_1057_46: i128 = 4;
        // D s_1057_47: read-var u#32954:u32
        let s_1057_47: u32 = fn_state.u_32954;
        // D s_1057_48: cast zx s_1057_47 -> bv
        let s_1057_48: Bits = Bits::new(s_1057_47 as u128, 32u16);
        // D s_1057_49: bit-extract s_1057_48 s_1057_45 s_1057_46
        let s_1057_49: Bits = (Bits::new(
            ((s_1057_48) >> (s_1057_45)).value(),
            u16::try_from(s_1057_46).unwrap(),
        ));
        // D s_1057_50: cast reint s_1057_49 -> u8
        let s_1057_50: u8 = (s_1057_49.value() as u8);
        // D s_1057_51: call decode_aarch32_instrs_STRD_i_A1enc_A_txt(s_1057_8, s_1057_14, s_1057_20, s_1057_26, s_1057_32, s_1057_38, s_1057_44, s_1057_50)
        let s_1057_51: () = decode_aarch32_instrs_STRD_i_A1enc_A_txt(
            state,
            tracer,
            s_1057_8,
            s_1057_14,
            s_1057_20,
            s_1057_26,
            s_1057_32,
            s_1057_38,
            s_1057_44,
            s_1057_50,
        );
        // N s_1057_52: return
        return;
    }
    fn block_1058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1058_0: read-var merge#var.1:struct
        let s_1058_0: u32 = fn_state.merge_var._1;
        // D s_1058_1: write-var u#32964 <= s_1058_0
        fn_state.u_32964 = s_1058_0;
        // C s_1058_2: const #25s : i
        let s_1058_2: i128 = 25;
        // D s_1058_3: read-var u#32964:u32
        let s_1058_3: u32 = fn_state.u_32964;
        // D s_1058_4: cast zx s_1058_3 -> bv
        let s_1058_4: Bits = Bits::new(s_1058_3 as u128, 32u16);
        // C s_1058_5: const #1s : i64
        let s_1058_5: i64 = 1;
        // C s_1058_6: cast zx s_1058_5 -> i
        let s_1058_6: i128 = (i128::try_from(s_1058_5).unwrap());
        // C s_1058_7: const #2s : i
        let s_1058_7: i128 = 2;
        // C s_1058_8: add s_1058_7 s_1058_6
        let s_1058_8: i128 = (s_1058_7 + s_1058_6);
        // D s_1058_9: bit-extract s_1058_4 s_1058_2 s_1058_8
        let s_1058_9: Bits = (Bits::new(
            ((s_1058_4) >> (s_1058_2)).value(),
            u16::try_from(s_1058_8).unwrap(),
        ));
        // D s_1058_10: cast reint s_1058_9 -> u8
        let s_1058_10: u8 = (s_1058_9.value() as u8);
        // D s_1058_11: cast zx s_1058_10 -> bv
        let s_1058_11: Bits = Bits::new(s_1058_10 as u128, 3u16);
        // C s_1058_12: const #0u : u8
        let s_1058_12: u8 = 0;
        // C s_1058_13: cast zx s_1058_12 -> bv
        let s_1058_13: Bits = Bits::new(s_1058_12 as u128, 3u16);
        // D s_1058_14: cmp-eq s_1058_11 s_1058_13
        let s_1058_14: bool = ((s_1058_11) == (s_1058_13));
        // N s_1058_15: branch s_1058_14 b2379 b1059
        if s_1058_14 {
            return block_2379(state, tracer, fn_state);
        } else {
            return block_1059(state, tracer, fn_state);
        };
    }
    fn block_1059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1059_0: const #0u : u8
        let s_1059_0: bool = false;
        // D s_1059_1: write-var gs#406695 <= s_1059_0
        fn_state.gs_406695 = s_1059_0;
        // N s_1059_2: jump b1060
        return block_1060(state, tracer, fn_state);
    }
    fn block_1060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1060_0: read-var gs#406695:u8
        let s_1060_0: bool = fn_state.gs_406695;
        // N s_1060_1: branch s_1060_0 b2375 b1061
        if s_1060_0 {
            return block_2375(state, tracer, fn_state);
        } else {
            return block_1061(state, tracer, fn_state);
        };
    }
    fn block_1061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1061_0: const #0u : u8
        let s_1061_0: bool = false;
        // D s_1061_1: write-var gs#406700 <= s_1061_0
        fn_state.gs_406700 = s_1061_0;
        // N s_1061_2: jump b1062
        return block_1062(state, tracer, fn_state);
    }
    fn block_1062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1062_0: read-var gs#406700:u8
        let s_1062_0: bool = fn_state.gs_406700;
        // D s_1062_1: not s_1062_0
        let s_1062_1: bool = !s_1062_0;
        // N s_1062_2: branch s_1062_1 b1075 b1063
        if s_1062_1 {
            return block_1075(state, tracer, fn_state);
        } else {
            return block_1063(state, tracer, fn_state);
        };
    }
    fn block_1063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1063_0: const #3205s : i
        let s_1063_0: i128 = 3205;
        // C s_1063_1: const #14696u : u32
        let s_1063_1: u32 = 14696;
        // N s_1063_2: write-reg s_1063_1 <= s_1063_0
        let s_1063_2: () = {
            state.write_register::<i128>(s_1063_1 as isize, s_1063_0);
            tracer.write_register(s_1063_1 as isize, s_1063_0);
        };
        // C s_1063_3: const #28s : i
        let s_1063_3: i128 = 28;
        // C s_1063_4: const #4s : i
        let s_1063_4: i128 = 4;
        // D s_1063_5: read-var u#32964:u32
        let s_1063_5: u32 = fn_state.u_32964;
        // D s_1063_6: cast zx s_1063_5 -> bv
        let s_1063_6: Bits = Bits::new(s_1063_5 as u128, 32u16);
        // D s_1063_7: bit-extract s_1063_6 s_1063_3 s_1063_4
        let s_1063_7: Bits = (Bits::new(
            ((s_1063_6) >> (s_1063_3)).value(),
            u16::try_from(s_1063_4).unwrap(),
        ));
        // D s_1063_8: cast reint s_1063_7 -> u8
        let s_1063_8: u8 = (s_1063_7.value() as u8);
        // D s_1063_9: write-var u#32965 <= s_1063_8
        fn_state.u_32965 = s_1063_8;
        // C s_1063_10: const #24s : i
        let s_1063_10: i128 = 24;
        // C s_1063_11: const #1s : i
        let s_1063_11: i128 = 1;
        // D s_1063_12: read-var u#32964:u32
        let s_1063_12: u32 = fn_state.u_32964;
        // D s_1063_13: cast zx s_1063_12 -> bv
        let s_1063_13: Bits = Bits::new(s_1063_12 as u128, 32u16);
        // D s_1063_14: bit-extract s_1063_13 s_1063_10 s_1063_11
        let s_1063_14: Bits = (Bits::new(
            ((s_1063_13) >> (s_1063_10)).value(),
            u16::try_from(s_1063_11).unwrap(),
        ));
        // D s_1063_15: cast reint s_1063_14 -> u8
        let s_1063_15: bool = ((s_1063_14.value()) != 0);
        // D s_1063_16: write-var u#32966 <= s_1063_15
        fn_state.u_32966 = s_1063_15;
        // C s_1063_17: const #23s : i
        let s_1063_17: i128 = 23;
        // C s_1063_18: const #1s : i
        let s_1063_18: i128 = 1;
        // D s_1063_19: read-var u#32964:u32
        let s_1063_19: u32 = fn_state.u_32964;
        // D s_1063_20: cast zx s_1063_19 -> bv
        let s_1063_20: Bits = Bits::new(s_1063_19 as u128, 32u16);
        // D s_1063_21: bit-extract s_1063_20 s_1063_17 s_1063_18
        let s_1063_21: Bits = (Bits::new(
            ((s_1063_20) >> (s_1063_17)).value(),
            u16::try_from(s_1063_18).unwrap(),
        ));
        // D s_1063_22: cast reint s_1063_21 -> u8
        let s_1063_22: bool = ((s_1063_21.value()) != 0);
        // D s_1063_23: write-var u#32967 <= s_1063_22
        fn_state.u_32967 = s_1063_22;
        // C s_1063_24: const #21s : i
        let s_1063_24: i128 = 21;
        // C s_1063_25: const #1s : i
        let s_1063_25: i128 = 1;
        // D s_1063_26: read-var u#32964:u32
        let s_1063_26: u32 = fn_state.u_32964;
        // D s_1063_27: cast zx s_1063_26 -> bv
        let s_1063_27: Bits = Bits::new(s_1063_26 as u128, 32u16);
        // D s_1063_28: bit-extract s_1063_27 s_1063_24 s_1063_25
        let s_1063_28: Bits = (Bits::new(
            ((s_1063_27) >> (s_1063_24)).value(),
            u16::try_from(s_1063_25).unwrap(),
        ));
        // D s_1063_29: cast reint s_1063_28 -> u8
        let s_1063_29: bool = ((s_1063_28.value()) != 0);
        // D s_1063_30: write-var u#32968 <= s_1063_29
        fn_state.u_32968 = s_1063_29;
        // C s_1063_31: const #16s : i
        let s_1063_31: i128 = 16;
        // C s_1063_32: const #4s : i
        let s_1063_32: i128 = 4;
        // D s_1063_33: read-var u#32964:u32
        let s_1063_33: u32 = fn_state.u_32964;
        // D s_1063_34: cast zx s_1063_33 -> bv
        let s_1063_34: Bits = Bits::new(s_1063_33 as u128, 32u16);
        // D s_1063_35: bit-extract s_1063_34 s_1063_31 s_1063_32
        let s_1063_35: Bits = (Bits::new(
            ((s_1063_34) >> (s_1063_31)).value(),
            u16::try_from(s_1063_32).unwrap(),
        ));
        // D s_1063_36: cast reint s_1063_35 -> u8
        let s_1063_36: u8 = (s_1063_35.value() as u8);
        // D s_1063_37: write-var u#32969 <= s_1063_36
        fn_state.u_32969 = s_1063_36;
        // C s_1063_38: const #12s : i
        let s_1063_38: i128 = 12;
        // C s_1063_39: const #4s : i
        let s_1063_39: i128 = 4;
        // D s_1063_40: read-var u#32964:u32
        let s_1063_40: u32 = fn_state.u_32964;
        // D s_1063_41: cast zx s_1063_40 -> bv
        let s_1063_41: Bits = Bits::new(s_1063_40 as u128, 32u16);
        // D s_1063_42: bit-extract s_1063_41 s_1063_38 s_1063_39
        let s_1063_42: Bits = (Bits::new(
            ((s_1063_41) >> (s_1063_38)).value(),
            u16::try_from(s_1063_39).unwrap(),
        ));
        // D s_1063_43: cast reint s_1063_42 -> u8
        let s_1063_43: u8 = (s_1063_42.value() as u8);
        // D s_1063_44: write-var u#32970 <= s_1063_43
        fn_state.u_32970 = s_1063_43;
        // C s_1063_45: const #0s : i
        let s_1063_45: i128 = 0;
        // C s_1063_46: const #4s : i
        let s_1063_46: i128 = 4;
        // D s_1063_47: read-var u#32964:u32
        let s_1063_47: u32 = fn_state.u_32964;
        // D s_1063_48: cast zx s_1063_47 -> bv
        let s_1063_48: Bits = Bits::new(s_1063_47 as u128, 32u16);
        // D s_1063_49: bit-extract s_1063_48 s_1063_45 s_1063_46
        let s_1063_49: Bits = (Bits::new(
            ((s_1063_48) >> (s_1063_45)).value(),
            u16::try_from(s_1063_46).unwrap(),
        ));
        // D s_1063_50: cast reint s_1063_49 -> u8
        let s_1063_50: u8 = (s_1063_49.value() as u8);
        // D s_1063_51: write-var u#32971 <= s_1063_50
        fn_state.u_32971 = s_1063_50;
        // C s_1063_52: const #8s : i
        let s_1063_52: i128 = 8;
        // D s_1063_53: read-var u#32964:u32
        let s_1063_53: u32 = fn_state.u_32964;
        // D s_1063_54: cast zx s_1063_53 -> bv
        let s_1063_54: Bits = Bits::new(s_1063_53 as u128, 32u16);
        // C s_1063_55: const #1u : u64
        let s_1063_55: u64 = 1;
        // D s_1063_56: bit-extract s_1063_54 s_1063_52 s_1063_55
        let s_1063_56: Bits = (Bits::new(
            ((s_1063_54) >> (s_1063_52)).value(),
            u16::try_from(s_1063_55).unwrap(),
        ));
        // D s_1063_57: cast reint s_1063_56 -> u8
        let s_1063_57: bool = ((s_1063_56.value()) != 0);
        // C s_1063_58: const #0s : i
        let s_1063_58: i128 = 0;
        // C s_1063_59: const #0u : u64
        let s_1063_59: u64 = 0;
        // D s_1063_60: cast zx s_1063_57 -> u64
        let s_1063_60: u64 = (s_1063_57 as u64);
        // C s_1063_61: const #1u : u64
        let s_1063_61: u64 = 1;
        // D s_1063_62: and s_1063_60 s_1063_61
        let s_1063_62: u64 = ((s_1063_60) & (s_1063_61));
        // D s_1063_63: cmp-eq s_1063_62 s_1063_61
        let s_1063_63: bool = ((s_1063_62) == (s_1063_61));
        // D s_1063_64: lsl s_1063_60 s_1063_58
        let s_1063_64: u64 = s_1063_60 << s_1063_58;
        // D s_1063_65: or s_1063_59 s_1063_64
        let s_1063_65: u64 = ((s_1063_59) | (s_1063_64));
        // D s_1063_66: cmpl s_1063_64
        let s_1063_66: u64 = !s_1063_64;
        // D s_1063_67: and s_1063_59 s_1063_66
        let s_1063_67: u64 = ((s_1063_59) & (s_1063_66));
        // D s_1063_68: select s_1063_63 s_1063_65 s_1063_67
        let s_1063_68: u64 = if s_1063_63 { s_1063_65 } else { s_1063_67 };
        // D s_1063_69: cast trunc s_1063_68 -> u8
        let s_1063_69: bool = ((s_1063_68) != 0);
        // D s_1063_70: cast zx s_1063_69 -> bv
        let s_1063_70: Bits = Bits::new(s_1063_69 as u128, 1u16);
        // C s_1063_71: const #0u : u8
        let s_1063_71: bool = false;
        // C s_1063_72: cast zx s_1063_71 -> bv
        let s_1063_72: Bits = Bits::new(s_1063_71 as u128, 1u16);
        // D s_1063_73: cmp-ne s_1063_70 s_1063_72
        let s_1063_73: bool = ((s_1063_70) != (s_1063_72));
        // N s_1063_74: branch s_1063_73 b1074 b1064
        if s_1063_73 {
            return block_1074(state, tracer, fn_state);
        } else {
            return block_1064(state, tracer, fn_state);
        };
    }
    fn block_1064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1064_0: const #9s : i
        let s_1064_0: i128 = 9;
        // D s_1064_1: read-var u#32964:u32
        let s_1064_1: u32 = fn_state.u_32964;
        // D s_1064_2: cast zx s_1064_1 -> bv
        let s_1064_2: Bits = Bits::new(s_1064_1 as u128, 32u16);
        // C s_1064_3: const #1u : u64
        let s_1064_3: u64 = 1;
        // D s_1064_4: bit-extract s_1064_2 s_1064_0 s_1064_3
        let s_1064_4: Bits = (Bits::new(
            ((s_1064_2) >> (s_1064_0)).value(),
            u16::try_from(s_1064_3).unwrap(),
        ));
        // D s_1064_5: cast reint s_1064_4 -> u8
        let s_1064_5: bool = ((s_1064_4.value()) != 0);
        // C s_1064_6: const #0s : i
        let s_1064_6: i128 = 0;
        // C s_1064_7: const #0u : u64
        let s_1064_7: u64 = 0;
        // D s_1064_8: cast zx s_1064_5 -> u64
        let s_1064_8: u64 = (s_1064_5 as u64);
        // C s_1064_9: const #1u : u64
        let s_1064_9: u64 = 1;
        // D s_1064_10: and s_1064_8 s_1064_9
        let s_1064_10: u64 = ((s_1064_8) & (s_1064_9));
        // D s_1064_11: cmp-eq s_1064_10 s_1064_9
        let s_1064_11: bool = ((s_1064_10) == (s_1064_9));
        // D s_1064_12: lsl s_1064_8 s_1064_6
        let s_1064_12: u64 = s_1064_8 << s_1064_6;
        // D s_1064_13: or s_1064_7 s_1064_12
        let s_1064_13: u64 = ((s_1064_7) | (s_1064_12));
        // D s_1064_14: cmpl s_1064_12
        let s_1064_14: u64 = !s_1064_12;
        // D s_1064_15: and s_1064_7 s_1064_14
        let s_1064_15: u64 = ((s_1064_7) & (s_1064_14));
        // D s_1064_16: select s_1064_11 s_1064_13 s_1064_15
        let s_1064_16: u64 = if s_1064_11 { s_1064_13 } else { s_1064_15 };
        // D s_1064_17: cast trunc s_1064_16 -> u8
        let s_1064_17: bool = ((s_1064_16) != 0);
        // D s_1064_18: cast zx s_1064_17 -> bv
        let s_1064_18: Bits = Bits::new(s_1064_17 as u128, 1u16);
        // C s_1064_19: const #0u : u8
        let s_1064_19: bool = false;
        // C s_1064_20: cast zx s_1064_19 -> bv
        let s_1064_20: Bits = Bits::new(s_1064_19 as u128, 1u16);
        // D s_1064_21: cmp-ne s_1064_18 s_1064_20
        let s_1064_21: bool = ((s_1064_18) != (s_1064_20));
        // D s_1064_22: write-var gs#406721 <= s_1064_21
        fn_state.gs_406721 = s_1064_21;
        // N s_1064_23: jump b1065
        return block_1065(state, tracer, fn_state);
    }
    fn block_1065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1065_0: read-var gs#406721:u8
        let s_1065_0: bool = fn_state.gs_406721;
        // N s_1065_1: branch s_1065_0 b1073 b1066
        if s_1065_0 {
            return block_1073(state, tracer, fn_state);
        } else {
            return block_1066(state, tracer, fn_state);
        };
    }
    fn block_1066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1066_0: const #10s : i
        let s_1066_0: i128 = 10;
        // D s_1066_1: read-var u#32964:u32
        let s_1066_1: u32 = fn_state.u_32964;
        // D s_1066_2: cast zx s_1066_1 -> bv
        let s_1066_2: Bits = Bits::new(s_1066_1 as u128, 32u16);
        // C s_1066_3: const #1u : u64
        let s_1066_3: u64 = 1;
        // D s_1066_4: bit-extract s_1066_2 s_1066_0 s_1066_3
        let s_1066_4: Bits = (Bits::new(
            ((s_1066_2) >> (s_1066_0)).value(),
            u16::try_from(s_1066_3).unwrap(),
        ));
        // D s_1066_5: cast reint s_1066_4 -> u8
        let s_1066_5: bool = ((s_1066_4.value()) != 0);
        // C s_1066_6: const #0s : i
        let s_1066_6: i128 = 0;
        // C s_1066_7: const #0u : u64
        let s_1066_7: u64 = 0;
        // D s_1066_8: cast zx s_1066_5 -> u64
        let s_1066_8: u64 = (s_1066_5 as u64);
        // C s_1066_9: const #1u : u64
        let s_1066_9: u64 = 1;
        // D s_1066_10: and s_1066_8 s_1066_9
        let s_1066_10: u64 = ((s_1066_8) & (s_1066_9));
        // D s_1066_11: cmp-eq s_1066_10 s_1066_9
        let s_1066_11: bool = ((s_1066_10) == (s_1066_9));
        // D s_1066_12: lsl s_1066_8 s_1066_6
        let s_1066_12: u64 = s_1066_8 << s_1066_6;
        // D s_1066_13: or s_1066_7 s_1066_12
        let s_1066_13: u64 = ((s_1066_7) | (s_1066_12));
        // D s_1066_14: cmpl s_1066_12
        let s_1066_14: u64 = !s_1066_12;
        // D s_1066_15: and s_1066_7 s_1066_14
        let s_1066_15: u64 = ((s_1066_7) & (s_1066_14));
        // D s_1066_16: select s_1066_11 s_1066_13 s_1066_15
        let s_1066_16: u64 = if s_1066_11 { s_1066_13 } else { s_1066_15 };
        // D s_1066_17: cast trunc s_1066_16 -> u8
        let s_1066_17: bool = ((s_1066_16) != 0);
        // D s_1066_18: cast zx s_1066_17 -> bv
        let s_1066_18: Bits = Bits::new(s_1066_17 as u128, 1u16);
        // C s_1066_19: const #0u : u8
        let s_1066_19: bool = false;
        // C s_1066_20: cast zx s_1066_19 -> bv
        let s_1066_20: Bits = Bits::new(s_1066_19 as u128, 1u16);
        // D s_1066_21: cmp-ne s_1066_18 s_1066_20
        let s_1066_21: bool = ((s_1066_18) != (s_1066_20));
        // D s_1066_22: write-var gs#406724 <= s_1066_21
        fn_state.gs_406724 = s_1066_21;
        // N s_1066_23: jump b1067
        return block_1067(state, tracer, fn_state);
    }
    fn block_1067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1067_0: read-var gs#406724:u8
        let s_1067_0: bool = fn_state.gs_406724;
        // N s_1067_1: branch s_1067_0 b1072 b1068
        if s_1067_0 {
            return block_1072(state, tracer, fn_state);
        } else {
            return block_1068(state, tracer, fn_state);
        };
    }
    fn block_1068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1068_0: const #11s : i
        let s_1068_0: i128 = 11;
        // D s_1068_1: read-var u#32964:u32
        let s_1068_1: u32 = fn_state.u_32964;
        // D s_1068_2: cast zx s_1068_1 -> bv
        let s_1068_2: Bits = Bits::new(s_1068_1 as u128, 32u16);
        // C s_1068_3: const #1u : u64
        let s_1068_3: u64 = 1;
        // D s_1068_4: bit-extract s_1068_2 s_1068_0 s_1068_3
        let s_1068_4: Bits = (Bits::new(
            ((s_1068_2) >> (s_1068_0)).value(),
            u16::try_from(s_1068_3).unwrap(),
        ));
        // D s_1068_5: cast reint s_1068_4 -> u8
        let s_1068_5: bool = ((s_1068_4.value()) != 0);
        // C s_1068_6: const #0s : i
        let s_1068_6: i128 = 0;
        // C s_1068_7: const #0u : u64
        let s_1068_7: u64 = 0;
        // D s_1068_8: cast zx s_1068_5 -> u64
        let s_1068_8: u64 = (s_1068_5 as u64);
        // C s_1068_9: const #1u : u64
        let s_1068_9: u64 = 1;
        // D s_1068_10: and s_1068_8 s_1068_9
        let s_1068_10: u64 = ((s_1068_8) & (s_1068_9));
        // D s_1068_11: cmp-eq s_1068_10 s_1068_9
        let s_1068_11: bool = ((s_1068_10) == (s_1068_9));
        // D s_1068_12: lsl s_1068_8 s_1068_6
        let s_1068_12: u64 = s_1068_8 << s_1068_6;
        // D s_1068_13: or s_1068_7 s_1068_12
        let s_1068_13: u64 = ((s_1068_7) | (s_1068_12));
        // D s_1068_14: cmpl s_1068_12
        let s_1068_14: u64 = !s_1068_12;
        // D s_1068_15: and s_1068_7 s_1068_14
        let s_1068_15: u64 = ((s_1068_7) & (s_1068_14));
        // D s_1068_16: select s_1068_11 s_1068_13 s_1068_15
        let s_1068_16: u64 = if s_1068_11 { s_1068_13 } else { s_1068_15 };
        // D s_1068_17: cast trunc s_1068_16 -> u8
        let s_1068_17: bool = ((s_1068_16) != 0);
        // D s_1068_18: cast zx s_1068_17 -> bv
        let s_1068_18: Bits = Bits::new(s_1068_17 as u128, 1u16);
        // C s_1068_19: const #0u : u8
        let s_1068_19: bool = false;
        // C s_1068_20: cast zx s_1068_19 -> bv
        let s_1068_20: Bits = Bits::new(s_1068_19 as u128, 1u16);
        // D s_1068_21: cmp-ne s_1068_18 s_1068_20
        let s_1068_21: bool = ((s_1068_18) != (s_1068_20));
        // D s_1068_22: write-var gs#406727 <= s_1068_21
        fn_state.gs_406727 = s_1068_21;
        // N s_1068_23: jump b1069
        return block_1069(state, tracer, fn_state);
    }
    fn block_1069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1069_0: read-var gs#406727:u8
        let s_1069_0: bool = fn_state.gs_406727;
        // N s_1069_1: branch s_1069_0 b1071 b1070
        if s_1069_0 {
            return block_1071(state, tracer, fn_state);
        } else {
            return block_1070(state, tracer, fn_state);
        };
    }
    fn block_1070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1070_0: read-var u#32965:u8
        let s_1070_0: u8 = fn_state.u_32965;
        // D s_1070_1: read-var u#32966:u8
        let s_1070_1: bool = fn_state.u_32966;
        // D s_1070_2: read-var u#32967:u8
        let s_1070_2: bool = fn_state.u_32967;
        // D s_1070_3: read-var u#32968:u8
        let s_1070_3: bool = fn_state.u_32968;
        // D s_1070_4: read-var u#32969:u8
        let s_1070_4: u8 = fn_state.u_32969;
        // D s_1070_5: read-var u#32970:u8
        let s_1070_5: u8 = fn_state.u_32970;
        // D s_1070_6: read-var u#32971:u8
        let s_1070_6: u8 = fn_state.u_32971;
        // D s_1070_7: call decode_aarch32_instrs_STRD_r_A1enc_A_txt(s_1070_0, s_1070_1, s_1070_2, s_1070_3, s_1070_4, s_1070_5, s_1070_6)
        let s_1070_7: () = decode_aarch32_instrs_STRD_r_A1enc_A_txt(
            state,
            tracer,
            s_1070_0,
            s_1070_1,
            s_1070_2,
            s_1070_3,
            s_1070_4,
            s_1070_5,
            s_1070_6,
        );
        // N s_1070_8: return
        return;
    }
    fn block_1071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1071_0: panic
        panic!("{:?}", ());
        // N s_1071_1: return
        return;
    }
    fn block_1072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1072_0: const #1u : u8
        let s_1072_0: bool = true;
        // D s_1072_1: write-var gs#406727 <= s_1072_0
        fn_state.gs_406727 = s_1072_0;
        // N s_1072_2: jump b1069
        return block_1069(state, tracer, fn_state);
    }
    fn block_1073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1073_0: const #1u : u8
        let s_1073_0: bool = true;
        // D s_1073_1: write-var gs#406724 <= s_1073_0
        fn_state.gs_406724 = s_1073_0;
        // N s_1073_2: jump b1067
        return block_1067(state, tracer, fn_state);
    }
    fn block_1074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1074_0: const #1u : u8
        let s_1074_0: bool = true;
        // D s_1074_1: write-var gs#406721 <= s_1074_0
        fn_state.gs_406721 = s_1074_0;
        // N s_1074_2: jump b1065
        return block_1065(state, tracer, fn_state);
    }
    fn block_1075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1075_0: read-var merge#var.1:struct
        let s_1075_0: u32 = fn_state.merge_var._1;
        // D s_1075_1: write-var u#32973 <= s_1075_0
        fn_state.u_32973 = s_1075_0;
        // C s_1075_2: const #20s : i
        let s_1075_2: i128 = 20;
        // D s_1075_3: read-var u#32973:u32
        let s_1075_3: u32 = fn_state.u_32973;
        // D s_1075_4: cast zx s_1075_3 -> bv
        let s_1075_4: Bits = Bits::new(s_1075_3 as u128, 32u16);
        // C s_1075_5: const #1s : i64
        let s_1075_5: i64 = 1;
        // C s_1075_6: cast zx s_1075_5 -> i
        let s_1075_6: i128 = (i128::try_from(s_1075_5).unwrap());
        // C s_1075_7: const #7s : i
        let s_1075_7: i128 = 7;
        // C s_1075_8: add s_1075_7 s_1075_6
        let s_1075_8: i128 = (s_1075_7 + s_1075_6);
        // D s_1075_9: bit-extract s_1075_4 s_1075_2 s_1075_8
        let s_1075_9: Bits = (Bits::new(
            ((s_1075_4) >> (s_1075_2)).value(),
            u16::try_from(s_1075_8).unwrap(),
        ));
        // D s_1075_10: cast reint s_1075_9 -> u8
        let s_1075_10: u8 = (s_1075_9.value() as u8);
        // D s_1075_11: cast zx s_1075_10 -> bv
        let s_1075_11: Bits = Bits::new(s_1075_10 as u128, 8u16);
        // C s_1075_12: const #24u : u8
        let s_1075_12: u8 = 24;
        // C s_1075_13: cast zx s_1075_12 -> bv
        let s_1075_13: Bits = Bits::new(s_1075_12 as u128, 8u16);
        // D s_1075_14: cmp-eq s_1075_11 s_1075_13
        let s_1075_14: bool = ((s_1075_11) == (s_1075_13));
        // N s_1075_15: branch s_1075_14 b2374 b1076
        if s_1075_14 {
            return block_2374(state, tracer, fn_state);
        } else {
            return block_1076(state, tracer, fn_state);
        };
    }
    fn block_1076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1076_0: const #0u : u8
        let s_1076_0: bool = false;
        // D s_1076_1: write-var gs#406733 <= s_1076_0
        fn_state.gs_406733 = s_1076_0;
        // N s_1076_2: jump b1077
        return block_1077(state, tracer, fn_state);
    }
    fn block_1077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1077_0: read-var gs#406733:u8
        let s_1077_0: bool = fn_state.gs_406733;
        // N s_1077_1: branch s_1077_0 b2370 b1078
        if s_1077_0 {
            return block_2370(state, tracer, fn_state);
        } else {
            return block_1078(state, tracer, fn_state);
        };
    }
    fn block_1078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1078_0: const #0u : u8
        let s_1078_0: bool = false;
        // D s_1078_1: write-var gs#406738 <= s_1078_0
        fn_state.gs_406738 = s_1078_0;
        // N s_1078_2: jump b1079
        return block_1079(state, tracer, fn_state);
    }
    fn block_1079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1079_0: read-var gs#406738:u8
        let s_1079_0: bool = fn_state.gs_406738;
        // D s_1079_1: not s_1079_0
        let s_1079_1: bool = !s_1079_0;
        // N s_1079_2: branch s_1079_1 b1086 b1080
        if s_1079_1 {
            return block_1086(state, tracer, fn_state);
        } else {
            return block_1080(state, tracer, fn_state);
        };
    }
    fn block_1080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1080_0: const #3206s : i
        let s_1080_0: i128 = 3206;
        // C s_1080_1: const #14696u : u32
        let s_1080_1: u32 = 14696;
        // N s_1080_2: write-reg s_1080_1 <= s_1080_0
        let s_1080_2: () = {
            state.write_register::<i128>(s_1080_1 as isize, s_1080_0);
            tracer.write_register(s_1080_1 as isize, s_1080_0);
        };
        // C s_1080_3: const #28s : i
        let s_1080_3: i128 = 28;
        // C s_1080_4: const #4s : i
        let s_1080_4: i128 = 4;
        // D s_1080_5: read-var u#32973:u32
        let s_1080_5: u32 = fn_state.u_32973;
        // D s_1080_6: cast zx s_1080_5 -> bv
        let s_1080_6: Bits = Bits::new(s_1080_5 as u128, 32u16);
        // D s_1080_7: bit-extract s_1080_6 s_1080_3 s_1080_4
        let s_1080_7: Bits = (Bits::new(
            ((s_1080_6) >> (s_1080_3)).value(),
            u16::try_from(s_1080_4).unwrap(),
        ));
        // D s_1080_8: cast reint s_1080_7 -> u8
        let s_1080_8: u8 = (s_1080_7.value() as u8);
        // D s_1080_9: write-var u#32974 <= s_1080_8
        fn_state.u_32974 = s_1080_8;
        // C s_1080_10: const #16s : i
        let s_1080_10: i128 = 16;
        // C s_1080_11: const #4s : i
        let s_1080_11: i128 = 4;
        // D s_1080_12: read-var u#32973:u32
        let s_1080_12: u32 = fn_state.u_32973;
        // D s_1080_13: cast zx s_1080_12 -> bv
        let s_1080_13: Bits = Bits::new(s_1080_12 as u128, 32u16);
        // D s_1080_14: bit-extract s_1080_13 s_1080_10 s_1080_11
        let s_1080_14: Bits = (Bits::new(
            ((s_1080_13) >> (s_1080_10)).value(),
            u16::try_from(s_1080_11).unwrap(),
        ));
        // D s_1080_15: cast reint s_1080_14 -> u8
        let s_1080_15: u8 = (s_1080_14.value() as u8);
        // D s_1080_16: write-var u#32975 <= s_1080_15
        fn_state.u_32975 = s_1080_15;
        // C s_1080_17: const #12s : i
        let s_1080_17: i128 = 12;
        // C s_1080_18: const #4s : i
        let s_1080_18: i128 = 4;
        // D s_1080_19: read-var u#32973:u32
        let s_1080_19: u32 = fn_state.u_32973;
        // D s_1080_20: cast zx s_1080_19 -> bv
        let s_1080_20: Bits = Bits::new(s_1080_19 as u128, 32u16);
        // D s_1080_21: bit-extract s_1080_20 s_1080_17 s_1080_18
        let s_1080_21: Bits = (Bits::new(
            ((s_1080_20) >> (s_1080_17)).value(),
            u16::try_from(s_1080_18).unwrap(),
        ));
        // D s_1080_22: cast reint s_1080_21 -> u8
        let s_1080_22: u8 = (s_1080_21.value() as u8);
        // D s_1080_23: write-var u#32976 <= s_1080_22
        fn_state.u_32976 = s_1080_22;
        // C s_1080_24: const #0s : i
        let s_1080_24: i128 = 0;
        // C s_1080_25: const #4s : i
        let s_1080_25: i128 = 4;
        // D s_1080_26: read-var u#32973:u32
        let s_1080_26: u32 = fn_state.u_32973;
        // D s_1080_27: cast zx s_1080_26 -> bv
        let s_1080_27: Bits = Bits::new(s_1080_26 as u128, 32u16);
        // D s_1080_28: bit-extract s_1080_27 s_1080_24 s_1080_25
        let s_1080_28: Bits = (Bits::new(
            ((s_1080_27) >> (s_1080_24)).value(),
            u16::try_from(s_1080_25).unwrap(),
        ));
        // D s_1080_29: cast reint s_1080_28 -> u8
        let s_1080_29: u8 = (s_1080_28.value() as u8);
        // D s_1080_30: write-var u#32977 <= s_1080_29
        fn_state.u_32977 = s_1080_29;
        // C s_1080_31: const #8s : i
        let s_1080_31: i128 = 8;
        // D s_1080_32: read-var u#32973:u32
        let s_1080_32: u32 = fn_state.u_32973;
        // D s_1080_33: cast zx s_1080_32 -> bv
        let s_1080_33: Bits = Bits::new(s_1080_32 as u128, 32u16);
        // C s_1080_34: const #1u : u64
        let s_1080_34: u64 = 1;
        // D s_1080_35: bit-extract s_1080_33 s_1080_31 s_1080_34
        let s_1080_35: Bits = (Bits::new(
            ((s_1080_33) >> (s_1080_31)).value(),
            u16::try_from(s_1080_34).unwrap(),
        ));
        // D s_1080_36: cast reint s_1080_35 -> u8
        let s_1080_36: bool = ((s_1080_35.value()) != 0);
        // C s_1080_37: const #0s : i
        let s_1080_37: i128 = 0;
        // C s_1080_38: const #0u : u64
        let s_1080_38: u64 = 0;
        // D s_1080_39: cast zx s_1080_36 -> u64
        let s_1080_39: u64 = (s_1080_36 as u64);
        // C s_1080_40: const #1u : u64
        let s_1080_40: u64 = 1;
        // D s_1080_41: and s_1080_39 s_1080_40
        let s_1080_41: u64 = ((s_1080_39) & (s_1080_40));
        // D s_1080_42: cmp-eq s_1080_41 s_1080_40
        let s_1080_42: bool = ((s_1080_41) == (s_1080_40));
        // D s_1080_43: lsl s_1080_39 s_1080_37
        let s_1080_43: u64 = s_1080_39 << s_1080_37;
        // D s_1080_44: or s_1080_38 s_1080_43
        let s_1080_44: u64 = ((s_1080_38) | (s_1080_43));
        // D s_1080_45: cmpl s_1080_43
        let s_1080_45: u64 = !s_1080_43;
        // D s_1080_46: and s_1080_38 s_1080_45
        let s_1080_46: u64 = ((s_1080_38) & (s_1080_45));
        // D s_1080_47: select s_1080_42 s_1080_44 s_1080_46
        let s_1080_47: u64 = if s_1080_42 { s_1080_44 } else { s_1080_46 };
        // D s_1080_48: cast trunc s_1080_47 -> u8
        let s_1080_48: bool = ((s_1080_47) != 0);
        // D s_1080_49: cast zx s_1080_48 -> bv
        let s_1080_49: Bits = Bits::new(s_1080_48 as u128, 1u16);
        // C s_1080_50: const #1u : u8
        let s_1080_50: bool = true;
        // C s_1080_51: cast zx s_1080_50 -> bv
        let s_1080_51: Bits = Bits::new(s_1080_50 as u128, 1u16);
        // D s_1080_52: cmp-ne s_1080_49 s_1080_51
        let s_1080_52: bool = ((s_1080_49) != (s_1080_51));
        // N s_1080_53: branch s_1080_52 b1085 b1081
        if s_1080_52 {
            return block_1085(state, tracer, fn_state);
        } else {
            return block_1081(state, tracer, fn_state);
        };
    }
    fn block_1081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1081_0: const #9s : i
        let s_1081_0: i128 = 9;
        // D s_1081_1: read-var u#32973:u32
        let s_1081_1: u32 = fn_state.u_32973;
        // D s_1081_2: cast zx s_1081_1 -> bv
        let s_1081_2: Bits = Bits::new(s_1081_1 as u128, 32u16);
        // C s_1081_3: const #1u : u64
        let s_1081_3: u64 = 1;
        // D s_1081_4: bit-extract s_1081_2 s_1081_0 s_1081_3
        let s_1081_4: Bits = (Bits::new(
            ((s_1081_2) >> (s_1081_0)).value(),
            u16::try_from(s_1081_3).unwrap(),
        ));
        // D s_1081_5: cast reint s_1081_4 -> u8
        let s_1081_5: bool = ((s_1081_4.value()) != 0);
        // C s_1081_6: const #0s : i
        let s_1081_6: i128 = 0;
        // C s_1081_7: const #0u : u64
        let s_1081_7: u64 = 0;
        // D s_1081_8: cast zx s_1081_5 -> u64
        let s_1081_8: u64 = (s_1081_5 as u64);
        // C s_1081_9: const #1u : u64
        let s_1081_9: u64 = 1;
        // D s_1081_10: and s_1081_8 s_1081_9
        let s_1081_10: u64 = ((s_1081_8) & (s_1081_9));
        // D s_1081_11: cmp-eq s_1081_10 s_1081_9
        let s_1081_11: bool = ((s_1081_10) == (s_1081_9));
        // D s_1081_12: lsl s_1081_8 s_1081_6
        let s_1081_12: u64 = s_1081_8 << s_1081_6;
        // D s_1081_13: or s_1081_7 s_1081_12
        let s_1081_13: u64 = ((s_1081_7) | (s_1081_12));
        // D s_1081_14: cmpl s_1081_12
        let s_1081_14: u64 = !s_1081_12;
        // D s_1081_15: and s_1081_7 s_1081_14
        let s_1081_15: u64 = ((s_1081_7) & (s_1081_14));
        // D s_1081_16: select s_1081_11 s_1081_13 s_1081_15
        let s_1081_16: u64 = if s_1081_11 { s_1081_13 } else { s_1081_15 };
        // D s_1081_17: cast trunc s_1081_16 -> u8
        let s_1081_17: bool = ((s_1081_16) != 0);
        // D s_1081_18: cast zx s_1081_17 -> bv
        let s_1081_18: Bits = Bits::new(s_1081_17 as u128, 1u16);
        // C s_1081_19: const #1u : u8
        let s_1081_19: bool = true;
        // C s_1081_20: cast zx s_1081_19 -> bv
        let s_1081_20: Bits = Bits::new(s_1081_19 as u128, 1u16);
        // D s_1081_21: cmp-ne s_1081_18 s_1081_20
        let s_1081_21: bool = ((s_1081_18) != (s_1081_20));
        // D s_1081_22: write-var gs#406753 <= s_1081_21
        fn_state.gs_406753 = s_1081_21;
        // N s_1081_23: jump b1082
        return block_1082(state, tracer, fn_state);
    }
    fn block_1082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1082_0: read-var gs#406753:u8
        let s_1082_0: bool = fn_state.gs_406753;
        // N s_1082_1: branch s_1082_0 b1084 b1083
        if s_1082_0 {
            return block_1084(state, tracer, fn_state);
        } else {
            return block_1083(state, tracer, fn_state);
        };
    }
    fn block_1083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1083_0: read-var u#32974:u8
        let s_1083_0: u8 = fn_state.u_32974;
        // D s_1083_1: read-var u#32975:u8
        let s_1083_1: u8 = fn_state.u_32975;
        // D s_1083_2: read-var u#32976:u8
        let s_1083_2: u8 = fn_state.u_32976;
        // D s_1083_3: read-var u#32977:u8
        let s_1083_3: u8 = fn_state.u_32977;
        // D s_1083_4: call decode_aarch32_instrs_STREX_A1enc_A_txt(s_1083_0, s_1083_1, s_1083_2, s_1083_3)
        let s_1083_4: () = decode_aarch32_instrs_STREX_A1enc_A_txt(
            state,
            tracer,
            s_1083_0,
            s_1083_1,
            s_1083_2,
            s_1083_3,
        );
        // N s_1083_5: return
        return;
    }
    fn block_1084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1084_0: panic
        panic!("{:?}", ());
        // N s_1084_1: return
        return;
    }
    fn block_1085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1085_0: const #1u : u8
        let s_1085_0: bool = true;
        // D s_1085_1: write-var gs#406753 <= s_1085_0
        fn_state.gs_406753 = s_1085_0;
        // N s_1085_2: jump b1082
        return block_1082(state, tracer, fn_state);
    }
    fn block_1086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1086_0: read-var merge#var.1:struct
        let s_1086_0: u32 = fn_state.merge_var._1;
        // D s_1086_1: write-var u#32979 <= s_1086_0
        fn_state.u_32979 = s_1086_0;
        // C s_1086_2: const #20s : i
        let s_1086_2: i128 = 20;
        // D s_1086_3: read-var u#32979:u32
        let s_1086_3: u32 = fn_state.u_32979;
        // D s_1086_4: cast zx s_1086_3 -> bv
        let s_1086_4: Bits = Bits::new(s_1086_3 as u128, 32u16);
        // C s_1086_5: const #1s : i64
        let s_1086_5: i64 = 1;
        // C s_1086_6: cast zx s_1086_5 -> i
        let s_1086_6: i128 = (i128::try_from(s_1086_5).unwrap());
        // C s_1086_7: const #7s : i
        let s_1086_7: i128 = 7;
        // C s_1086_8: add s_1086_7 s_1086_6
        let s_1086_8: i128 = (s_1086_7 + s_1086_6);
        // D s_1086_9: bit-extract s_1086_4 s_1086_2 s_1086_8
        let s_1086_9: Bits = (Bits::new(
            ((s_1086_4) >> (s_1086_2)).value(),
            u16::try_from(s_1086_8).unwrap(),
        ));
        // D s_1086_10: cast reint s_1086_9 -> u8
        let s_1086_10: u8 = (s_1086_9.value() as u8);
        // D s_1086_11: cast zx s_1086_10 -> bv
        let s_1086_11: Bits = Bits::new(s_1086_10 as u128, 8u16);
        // C s_1086_12: const #28u : u8
        let s_1086_12: u8 = 28;
        // C s_1086_13: cast zx s_1086_12 -> bv
        let s_1086_13: Bits = Bits::new(s_1086_12 as u128, 8u16);
        // D s_1086_14: cmp-eq s_1086_11 s_1086_13
        let s_1086_14: bool = ((s_1086_11) == (s_1086_13));
        // N s_1086_15: branch s_1086_14 b2369 b1087
        if s_1086_14 {
            return block_2369(state, tracer, fn_state);
        } else {
            return block_1087(state, tracer, fn_state);
        };
    }
    fn block_1087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1087_0: const #0u : u8
        let s_1087_0: bool = false;
        // D s_1087_1: write-var gs#406759 <= s_1087_0
        fn_state.gs_406759 = s_1087_0;
        // N s_1087_2: jump b1088
        return block_1088(state, tracer, fn_state);
    }
    fn block_1088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1088_0: read-var gs#406759:u8
        let s_1088_0: bool = fn_state.gs_406759;
        // N s_1088_1: branch s_1088_0 b2365 b1089
        if s_1088_0 {
            return block_2365(state, tracer, fn_state);
        } else {
            return block_1089(state, tracer, fn_state);
        };
    }
    fn block_1089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1089_0: const #0u : u8
        let s_1089_0: bool = false;
        // D s_1089_1: write-var gs#406764 <= s_1089_0
        fn_state.gs_406764 = s_1089_0;
        // N s_1089_2: jump b1090
        return block_1090(state, tracer, fn_state);
    }
    fn block_1090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1090_0: read-var gs#406764:u8
        let s_1090_0: bool = fn_state.gs_406764;
        // D s_1090_1: not s_1090_0
        let s_1090_1: bool = !s_1090_0;
        // N s_1090_2: branch s_1090_1 b1097 b1091
        if s_1090_1 {
            return block_1097(state, tracer, fn_state);
        } else {
            return block_1091(state, tracer, fn_state);
        };
    }
    fn block_1091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1091_0: const #3208s : i
        let s_1091_0: i128 = 3208;
        // C s_1091_1: const #14696u : u32
        let s_1091_1: u32 = 14696;
        // N s_1091_2: write-reg s_1091_1 <= s_1091_0
        let s_1091_2: () = {
            state.write_register::<i128>(s_1091_1 as isize, s_1091_0);
            tracer.write_register(s_1091_1 as isize, s_1091_0);
        };
        // C s_1091_3: const #28s : i
        let s_1091_3: i128 = 28;
        // C s_1091_4: const #4s : i
        let s_1091_4: i128 = 4;
        // D s_1091_5: read-var u#32979:u32
        let s_1091_5: u32 = fn_state.u_32979;
        // D s_1091_6: cast zx s_1091_5 -> bv
        let s_1091_6: Bits = Bits::new(s_1091_5 as u128, 32u16);
        // D s_1091_7: bit-extract s_1091_6 s_1091_3 s_1091_4
        let s_1091_7: Bits = (Bits::new(
            ((s_1091_6) >> (s_1091_3)).value(),
            u16::try_from(s_1091_4).unwrap(),
        ));
        // D s_1091_8: cast reint s_1091_7 -> u8
        let s_1091_8: u8 = (s_1091_7.value() as u8);
        // D s_1091_9: write-var u#32980 <= s_1091_8
        fn_state.u_32980 = s_1091_8;
        // C s_1091_10: const #16s : i
        let s_1091_10: i128 = 16;
        // C s_1091_11: const #4s : i
        let s_1091_11: i128 = 4;
        // D s_1091_12: read-var u#32979:u32
        let s_1091_12: u32 = fn_state.u_32979;
        // D s_1091_13: cast zx s_1091_12 -> bv
        let s_1091_13: Bits = Bits::new(s_1091_12 as u128, 32u16);
        // D s_1091_14: bit-extract s_1091_13 s_1091_10 s_1091_11
        let s_1091_14: Bits = (Bits::new(
            ((s_1091_13) >> (s_1091_10)).value(),
            u16::try_from(s_1091_11).unwrap(),
        ));
        // D s_1091_15: cast reint s_1091_14 -> u8
        let s_1091_15: u8 = (s_1091_14.value() as u8);
        // D s_1091_16: write-var u#32981 <= s_1091_15
        fn_state.u_32981 = s_1091_15;
        // C s_1091_17: const #12s : i
        let s_1091_17: i128 = 12;
        // C s_1091_18: const #4s : i
        let s_1091_18: i128 = 4;
        // D s_1091_19: read-var u#32979:u32
        let s_1091_19: u32 = fn_state.u_32979;
        // D s_1091_20: cast zx s_1091_19 -> bv
        let s_1091_20: Bits = Bits::new(s_1091_19 as u128, 32u16);
        // D s_1091_21: bit-extract s_1091_20 s_1091_17 s_1091_18
        let s_1091_21: Bits = (Bits::new(
            ((s_1091_20) >> (s_1091_17)).value(),
            u16::try_from(s_1091_18).unwrap(),
        ));
        // D s_1091_22: cast reint s_1091_21 -> u8
        let s_1091_22: u8 = (s_1091_21.value() as u8);
        // D s_1091_23: write-var u#32982 <= s_1091_22
        fn_state.u_32982 = s_1091_22;
        // C s_1091_24: const #0s : i
        let s_1091_24: i128 = 0;
        // C s_1091_25: const #4s : i
        let s_1091_25: i128 = 4;
        // D s_1091_26: read-var u#32979:u32
        let s_1091_26: u32 = fn_state.u_32979;
        // D s_1091_27: cast zx s_1091_26 -> bv
        let s_1091_27: Bits = Bits::new(s_1091_26 as u128, 32u16);
        // D s_1091_28: bit-extract s_1091_27 s_1091_24 s_1091_25
        let s_1091_28: Bits = (Bits::new(
            ((s_1091_27) >> (s_1091_24)).value(),
            u16::try_from(s_1091_25).unwrap(),
        ));
        // D s_1091_29: cast reint s_1091_28 -> u8
        let s_1091_29: u8 = (s_1091_28.value() as u8);
        // D s_1091_30: write-var u#32983 <= s_1091_29
        fn_state.u_32983 = s_1091_29;
        // C s_1091_31: const #8s : i
        let s_1091_31: i128 = 8;
        // D s_1091_32: read-var u#32979:u32
        let s_1091_32: u32 = fn_state.u_32979;
        // D s_1091_33: cast zx s_1091_32 -> bv
        let s_1091_33: Bits = Bits::new(s_1091_32 as u128, 32u16);
        // C s_1091_34: const #1u : u64
        let s_1091_34: u64 = 1;
        // D s_1091_35: bit-extract s_1091_33 s_1091_31 s_1091_34
        let s_1091_35: Bits = (Bits::new(
            ((s_1091_33) >> (s_1091_31)).value(),
            u16::try_from(s_1091_34).unwrap(),
        ));
        // D s_1091_36: cast reint s_1091_35 -> u8
        let s_1091_36: bool = ((s_1091_35.value()) != 0);
        // C s_1091_37: const #0s : i
        let s_1091_37: i128 = 0;
        // C s_1091_38: const #0u : u64
        let s_1091_38: u64 = 0;
        // D s_1091_39: cast zx s_1091_36 -> u64
        let s_1091_39: u64 = (s_1091_36 as u64);
        // C s_1091_40: const #1u : u64
        let s_1091_40: u64 = 1;
        // D s_1091_41: and s_1091_39 s_1091_40
        let s_1091_41: u64 = ((s_1091_39) & (s_1091_40));
        // D s_1091_42: cmp-eq s_1091_41 s_1091_40
        let s_1091_42: bool = ((s_1091_41) == (s_1091_40));
        // D s_1091_43: lsl s_1091_39 s_1091_37
        let s_1091_43: u64 = s_1091_39 << s_1091_37;
        // D s_1091_44: or s_1091_38 s_1091_43
        let s_1091_44: u64 = ((s_1091_38) | (s_1091_43));
        // D s_1091_45: cmpl s_1091_43
        let s_1091_45: u64 = !s_1091_43;
        // D s_1091_46: and s_1091_38 s_1091_45
        let s_1091_46: u64 = ((s_1091_38) & (s_1091_45));
        // D s_1091_47: select s_1091_42 s_1091_44 s_1091_46
        let s_1091_47: u64 = if s_1091_42 { s_1091_44 } else { s_1091_46 };
        // D s_1091_48: cast trunc s_1091_47 -> u8
        let s_1091_48: bool = ((s_1091_47) != 0);
        // D s_1091_49: cast zx s_1091_48 -> bv
        let s_1091_49: Bits = Bits::new(s_1091_48 as u128, 1u16);
        // C s_1091_50: const #1u : u8
        let s_1091_50: bool = true;
        // C s_1091_51: cast zx s_1091_50 -> bv
        let s_1091_51: Bits = Bits::new(s_1091_50 as u128, 1u16);
        // D s_1091_52: cmp-ne s_1091_49 s_1091_51
        let s_1091_52: bool = ((s_1091_49) != (s_1091_51));
        // N s_1091_53: branch s_1091_52 b1096 b1092
        if s_1091_52 {
            return block_1096(state, tracer, fn_state);
        } else {
            return block_1092(state, tracer, fn_state);
        };
    }
    fn block_1092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1092_0: const #9s : i
        let s_1092_0: i128 = 9;
        // D s_1092_1: read-var u#32979:u32
        let s_1092_1: u32 = fn_state.u_32979;
        // D s_1092_2: cast zx s_1092_1 -> bv
        let s_1092_2: Bits = Bits::new(s_1092_1 as u128, 32u16);
        // C s_1092_3: const #1u : u64
        let s_1092_3: u64 = 1;
        // D s_1092_4: bit-extract s_1092_2 s_1092_0 s_1092_3
        let s_1092_4: Bits = (Bits::new(
            ((s_1092_2) >> (s_1092_0)).value(),
            u16::try_from(s_1092_3).unwrap(),
        ));
        // D s_1092_5: cast reint s_1092_4 -> u8
        let s_1092_5: bool = ((s_1092_4.value()) != 0);
        // C s_1092_6: const #0s : i
        let s_1092_6: i128 = 0;
        // C s_1092_7: const #0u : u64
        let s_1092_7: u64 = 0;
        // D s_1092_8: cast zx s_1092_5 -> u64
        let s_1092_8: u64 = (s_1092_5 as u64);
        // C s_1092_9: const #1u : u64
        let s_1092_9: u64 = 1;
        // D s_1092_10: and s_1092_8 s_1092_9
        let s_1092_10: u64 = ((s_1092_8) & (s_1092_9));
        // D s_1092_11: cmp-eq s_1092_10 s_1092_9
        let s_1092_11: bool = ((s_1092_10) == (s_1092_9));
        // D s_1092_12: lsl s_1092_8 s_1092_6
        let s_1092_12: u64 = s_1092_8 << s_1092_6;
        // D s_1092_13: or s_1092_7 s_1092_12
        let s_1092_13: u64 = ((s_1092_7) | (s_1092_12));
        // D s_1092_14: cmpl s_1092_12
        let s_1092_14: u64 = !s_1092_12;
        // D s_1092_15: and s_1092_7 s_1092_14
        let s_1092_15: u64 = ((s_1092_7) & (s_1092_14));
        // D s_1092_16: select s_1092_11 s_1092_13 s_1092_15
        let s_1092_16: u64 = if s_1092_11 { s_1092_13 } else { s_1092_15 };
        // D s_1092_17: cast trunc s_1092_16 -> u8
        let s_1092_17: bool = ((s_1092_16) != 0);
        // D s_1092_18: cast zx s_1092_17 -> bv
        let s_1092_18: Bits = Bits::new(s_1092_17 as u128, 1u16);
        // C s_1092_19: const #1u : u8
        let s_1092_19: bool = true;
        // C s_1092_20: cast zx s_1092_19 -> bv
        let s_1092_20: Bits = Bits::new(s_1092_19 as u128, 1u16);
        // D s_1092_21: cmp-ne s_1092_18 s_1092_20
        let s_1092_21: bool = ((s_1092_18) != (s_1092_20));
        // D s_1092_22: write-var gs#406779 <= s_1092_21
        fn_state.gs_406779 = s_1092_21;
        // N s_1092_23: jump b1093
        return block_1093(state, tracer, fn_state);
    }
    fn block_1093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1093_0: read-var gs#406779:u8
        let s_1093_0: bool = fn_state.gs_406779;
        // N s_1093_1: branch s_1093_0 b1095 b1094
        if s_1093_0 {
            return block_1095(state, tracer, fn_state);
        } else {
            return block_1094(state, tracer, fn_state);
        };
    }
    fn block_1094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1094_0: read-var u#32980:u8
        let s_1094_0: u8 = fn_state.u_32980;
        // D s_1094_1: read-var u#32981:u8
        let s_1094_1: u8 = fn_state.u_32981;
        // D s_1094_2: read-var u#32982:u8
        let s_1094_2: u8 = fn_state.u_32982;
        // D s_1094_3: read-var u#32983:u8
        let s_1094_3: u8 = fn_state.u_32983;
        // D s_1094_4: call decode_aarch32_instrs_STREXB_A1enc_A_txt(s_1094_0, s_1094_1, s_1094_2, s_1094_3)
        let s_1094_4: () = decode_aarch32_instrs_STREXB_A1enc_A_txt(
            state,
            tracer,
            s_1094_0,
            s_1094_1,
            s_1094_2,
            s_1094_3,
        );
        // N s_1094_5: return
        return;
    }
    fn block_1095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1095_0: panic
        panic!("{:?}", ());
        // N s_1095_1: return
        return;
    }
    fn block_1096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1096_0: const #1u : u8
        let s_1096_0: bool = true;
        // D s_1096_1: write-var gs#406779 <= s_1096_0
        fn_state.gs_406779 = s_1096_0;
        // N s_1096_2: jump b1093
        return block_1093(state, tracer, fn_state);
    }
    fn block_1097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1097_0: read-var merge#var.1:struct
        let s_1097_0: u32 = fn_state.merge_var._1;
        // D s_1097_1: write-var u#32985 <= s_1097_0
        fn_state.u_32985 = s_1097_0;
        // C s_1097_2: const #20s : i
        let s_1097_2: i128 = 20;
        // D s_1097_3: read-var u#32985:u32
        let s_1097_3: u32 = fn_state.u_32985;
        // D s_1097_4: cast zx s_1097_3 -> bv
        let s_1097_4: Bits = Bits::new(s_1097_3 as u128, 32u16);
        // C s_1097_5: const #1s : i64
        let s_1097_5: i64 = 1;
        // C s_1097_6: cast zx s_1097_5 -> i
        let s_1097_6: i128 = (i128::try_from(s_1097_5).unwrap());
        // C s_1097_7: const #7s : i
        let s_1097_7: i128 = 7;
        // C s_1097_8: add s_1097_7 s_1097_6
        let s_1097_8: i128 = (s_1097_7 + s_1097_6);
        // D s_1097_9: bit-extract s_1097_4 s_1097_2 s_1097_8
        let s_1097_9: Bits = (Bits::new(
            ((s_1097_4) >> (s_1097_2)).value(),
            u16::try_from(s_1097_8).unwrap(),
        ));
        // D s_1097_10: cast reint s_1097_9 -> u8
        let s_1097_10: u8 = (s_1097_9.value() as u8);
        // D s_1097_11: cast zx s_1097_10 -> bv
        let s_1097_11: Bits = Bits::new(s_1097_10 as u128, 8u16);
        // C s_1097_12: const #26u : u8
        let s_1097_12: u8 = 26;
        // C s_1097_13: cast zx s_1097_12 -> bv
        let s_1097_13: Bits = Bits::new(s_1097_12 as u128, 8u16);
        // D s_1097_14: cmp-eq s_1097_11 s_1097_13
        let s_1097_14: bool = ((s_1097_11) == (s_1097_13));
        // N s_1097_15: branch s_1097_14 b2364 b1098
        if s_1097_14 {
            return block_2364(state, tracer, fn_state);
        } else {
            return block_1098(state, tracer, fn_state);
        };
    }
    fn block_1098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1098_0: const #0u : u8
        let s_1098_0: bool = false;
        // D s_1098_1: write-var gs#406785 <= s_1098_0
        fn_state.gs_406785 = s_1098_0;
        // N s_1098_2: jump b1099
        return block_1099(state, tracer, fn_state);
    }
    fn block_1099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1099_0: read-var gs#406785:u8
        let s_1099_0: bool = fn_state.gs_406785;
        // N s_1099_1: branch s_1099_0 b2360 b1100
        if s_1099_0 {
            return block_2360(state, tracer, fn_state);
        } else {
            return block_1100(state, tracer, fn_state);
        };
    }
    fn block_1100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1100_0: const #0u : u8
        let s_1100_0: bool = false;
        // D s_1100_1: write-var gs#406790 <= s_1100_0
        fn_state.gs_406790 = s_1100_0;
        // N s_1100_2: jump b1101
        return block_1101(state, tracer, fn_state);
    }
    fn block_1101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1101_0: read-var gs#406790:u8
        let s_1101_0: bool = fn_state.gs_406790;
        // D s_1101_1: not s_1101_0
        let s_1101_1: bool = !s_1101_0;
        // N s_1101_2: branch s_1101_1 b1108 b1102
        if s_1101_1 {
            return block_1108(state, tracer, fn_state);
        } else {
            return block_1102(state, tracer, fn_state);
        };
    }
    fn block_1102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1102_0: const #3210s : i
        let s_1102_0: i128 = 3210;
        // C s_1102_1: const #14696u : u32
        let s_1102_1: u32 = 14696;
        // N s_1102_2: write-reg s_1102_1 <= s_1102_0
        let s_1102_2: () = {
            state.write_register::<i128>(s_1102_1 as isize, s_1102_0);
            tracer.write_register(s_1102_1 as isize, s_1102_0);
        };
        // C s_1102_3: const #28s : i
        let s_1102_3: i128 = 28;
        // C s_1102_4: const #4s : i
        let s_1102_4: i128 = 4;
        // D s_1102_5: read-var u#32985:u32
        let s_1102_5: u32 = fn_state.u_32985;
        // D s_1102_6: cast zx s_1102_5 -> bv
        let s_1102_6: Bits = Bits::new(s_1102_5 as u128, 32u16);
        // D s_1102_7: bit-extract s_1102_6 s_1102_3 s_1102_4
        let s_1102_7: Bits = (Bits::new(
            ((s_1102_6) >> (s_1102_3)).value(),
            u16::try_from(s_1102_4).unwrap(),
        ));
        // D s_1102_8: cast reint s_1102_7 -> u8
        let s_1102_8: u8 = (s_1102_7.value() as u8);
        // D s_1102_9: write-var u#32986 <= s_1102_8
        fn_state.u_32986 = s_1102_8;
        // C s_1102_10: const #16s : i
        let s_1102_10: i128 = 16;
        // C s_1102_11: const #4s : i
        let s_1102_11: i128 = 4;
        // D s_1102_12: read-var u#32985:u32
        let s_1102_12: u32 = fn_state.u_32985;
        // D s_1102_13: cast zx s_1102_12 -> bv
        let s_1102_13: Bits = Bits::new(s_1102_12 as u128, 32u16);
        // D s_1102_14: bit-extract s_1102_13 s_1102_10 s_1102_11
        let s_1102_14: Bits = (Bits::new(
            ((s_1102_13) >> (s_1102_10)).value(),
            u16::try_from(s_1102_11).unwrap(),
        ));
        // D s_1102_15: cast reint s_1102_14 -> u8
        let s_1102_15: u8 = (s_1102_14.value() as u8);
        // D s_1102_16: write-var u#32987 <= s_1102_15
        fn_state.u_32987 = s_1102_15;
        // C s_1102_17: const #12s : i
        let s_1102_17: i128 = 12;
        // C s_1102_18: const #4s : i
        let s_1102_18: i128 = 4;
        // D s_1102_19: read-var u#32985:u32
        let s_1102_19: u32 = fn_state.u_32985;
        // D s_1102_20: cast zx s_1102_19 -> bv
        let s_1102_20: Bits = Bits::new(s_1102_19 as u128, 32u16);
        // D s_1102_21: bit-extract s_1102_20 s_1102_17 s_1102_18
        let s_1102_21: Bits = (Bits::new(
            ((s_1102_20) >> (s_1102_17)).value(),
            u16::try_from(s_1102_18).unwrap(),
        ));
        // D s_1102_22: cast reint s_1102_21 -> u8
        let s_1102_22: u8 = (s_1102_21.value() as u8);
        // D s_1102_23: write-var u#32988 <= s_1102_22
        fn_state.u_32988 = s_1102_22;
        // C s_1102_24: const #0s : i
        let s_1102_24: i128 = 0;
        // C s_1102_25: const #4s : i
        let s_1102_25: i128 = 4;
        // D s_1102_26: read-var u#32985:u32
        let s_1102_26: u32 = fn_state.u_32985;
        // D s_1102_27: cast zx s_1102_26 -> bv
        let s_1102_27: Bits = Bits::new(s_1102_26 as u128, 32u16);
        // D s_1102_28: bit-extract s_1102_27 s_1102_24 s_1102_25
        let s_1102_28: Bits = (Bits::new(
            ((s_1102_27) >> (s_1102_24)).value(),
            u16::try_from(s_1102_25).unwrap(),
        ));
        // D s_1102_29: cast reint s_1102_28 -> u8
        let s_1102_29: u8 = (s_1102_28.value() as u8);
        // D s_1102_30: write-var u#32989 <= s_1102_29
        fn_state.u_32989 = s_1102_29;
        // C s_1102_31: const #8s : i
        let s_1102_31: i128 = 8;
        // D s_1102_32: read-var u#32985:u32
        let s_1102_32: u32 = fn_state.u_32985;
        // D s_1102_33: cast zx s_1102_32 -> bv
        let s_1102_33: Bits = Bits::new(s_1102_32 as u128, 32u16);
        // C s_1102_34: const #1u : u64
        let s_1102_34: u64 = 1;
        // D s_1102_35: bit-extract s_1102_33 s_1102_31 s_1102_34
        let s_1102_35: Bits = (Bits::new(
            ((s_1102_33) >> (s_1102_31)).value(),
            u16::try_from(s_1102_34).unwrap(),
        ));
        // D s_1102_36: cast reint s_1102_35 -> u8
        let s_1102_36: bool = ((s_1102_35.value()) != 0);
        // C s_1102_37: const #0s : i
        let s_1102_37: i128 = 0;
        // C s_1102_38: const #0u : u64
        let s_1102_38: u64 = 0;
        // D s_1102_39: cast zx s_1102_36 -> u64
        let s_1102_39: u64 = (s_1102_36 as u64);
        // C s_1102_40: const #1u : u64
        let s_1102_40: u64 = 1;
        // D s_1102_41: and s_1102_39 s_1102_40
        let s_1102_41: u64 = ((s_1102_39) & (s_1102_40));
        // D s_1102_42: cmp-eq s_1102_41 s_1102_40
        let s_1102_42: bool = ((s_1102_41) == (s_1102_40));
        // D s_1102_43: lsl s_1102_39 s_1102_37
        let s_1102_43: u64 = s_1102_39 << s_1102_37;
        // D s_1102_44: or s_1102_38 s_1102_43
        let s_1102_44: u64 = ((s_1102_38) | (s_1102_43));
        // D s_1102_45: cmpl s_1102_43
        let s_1102_45: u64 = !s_1102_43;
        // D s_1102_46: and s_1102_38 s_1102_45
        let s_1102_46: u64 = ((s_1102_38) & (s_1102_45));
        // D s_1102_47: select s_1102_42 s_1102_44 s_1102_46
        let s_1102_47: u64 = if s_1102_42 { s_1102_44 } else { s_1102_46 };
        // D s_1102_48: cast trunc s_1102_47 -> u8
        let s_1102_48: bool = ((s_1102_47) != 0);
        // D s_1102_49: cast zx s_1102_48 -> bv
        let s_1102_49: Bits = Bits::new(s_1102_48 as u128, 1u16);
        // C s_1102_50: const #1u : u8
        let s_1102_50: bool = true;
        // C s_1102_51: cast zx s_1102_50 -> bv
        let s_1102_51: Bits = Bits::new(s_1102_50 as u128, 1u16);
        // D s_1102_52: cmp-ne s_1102_49 s_1102_51
        let s_1102_52: bool = ((s_1102_49) != (s_1102_51));
        // N s_1102_53: branch s_1102_52 b1107 b1103
        if s_1102_52 {
            return block_1107(state, tracer, fn_state);
        } else {
            return block_1103(state, tracer, fn_state);
        };
    }
    fn block_1103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1103_0: const #9s : i
        let s_1103_0: i128 = 9;
        // D s_1103_1: read-var u#32985:u32
        let s_1103_1: u32 = fn_state.u_32985;
        // D s_1103_2: cast zx s_1103_1 -> bv
        let s_1103_2: Bits = Bits::new(s_1103_1 as u128, 32u16);
        // C s_1103_3: const #1u : u64
        let s_1103_3: u64 = 1;
        // D s_1103_4: bit-extract s_1103_2 s_1103_0 s_1103_3
        let s_1103_4: Bits = (Bits::new(
            ((s_1103_2) >> (s_1103_0)).value(),
            u16::try_from(s_1103_3).unwrap(),
        ));
        // D s_1103_5: cast reint s_1103_4 -> u8
        let s_1103_5: bool = ((s_1103_4.value()) != 0);
        // C s_1103_6: const #0s : i
        let s_1103_6: i128 = 0;
        // C s_1103_7: const #0u : u64
        let s_1103_7: u64 = 0;
        // D s_1103_8: cast zx s_1103_5 -> u64
        let s_1103_8: u64 = (s_1103_5 as u64);
        // C s_1103_9: const #1u : u64
        let s_1103_9: u64 = 1;
        // D s_1103_10: and s_1103_8 s_1103_9
        let s_1103_10: u64 = ((s_1103_8) & (s_1103_9));
        // D s_1103_11: cmp-eq s_1103_10 s_1103_9
        let s_1103_11: bool = ((s_1103_10) == (s_1103_9));
        // D s_1103_12: lsl s_1103_8 s_1103_6
        let s_1103_12: u64 = s_1103_8 << s_1103_6;
        // D s_1103_13: or s_1103_7 s_1103_12
        let s_1103_13: u64 = ((s_1103_7) | (s_1103_12));
        // D s_1103_14: cmpl s_1103_12
        let s_1103_14: u64 = !s_1103_12;
        // D s_1103_15: and s_1103_7 s_1103_14
        let s_1103_15: u64 = ((s_1103_7) & (s_1103_14));
        // D s_1103_16: select s_1103_11 s_1103_13 s_1103_15
        let s_1103_16: u64 = if s_1103_11 { s_1103_13 } else { s_1103_15 };
        // D s_1103_17: cast trunc s_1103_16 -> u8
        let s_1103_17: bool = ((s_1103_16) != 0);
        // D s_1103_18: cast zx s_1103_17 -> bv
        let s_1103_18: Bits = Bits::new(s_1103_17 as u128, 1u16);
        // C s_1103_19: const #1u : u8
        let s_1103_19: bool = true;
        // C s_1103_20: cast zx s_1103_19 -> bv
        let s_1103_20: Bits = Bits::new(s_1103_19 as u128, 1u16);
        // D s_1103_21: cmp-ne s_1103_18 s_1103_20
        let s_1103_21: bool = ((s_1103_18) != (s_1103_20));
        // D s_1103_22: write-var gs#406805 <= s_1103_21
        fn_state.gs_406805 = s_1103_21;
        // N s_1103_23: jump b1104
        return block_1104(state, tracer, fn_state);
    }
    fn block_1104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1104_0: read-var gs#406805:u8
        let s_1104_0: bool = fn_state.gs_406805;
        // N s_1104_1: branch s_1104_0 b1106 b1105
        if s_1104_0 {
            return block_1106(state, tracer, fn_state);
        } else {
            return block_1105(state, tracer, fn_state);
        };
    }
    fn block_1105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1105_0: read-var u#32986:u8
        let s_1105_0: u8 = fn_state.u_32986;
        // D s_1105_1: read-var u#32987:u8
        let s_1105_1: u8 = fn_state.u_32987;
        // D s_1105_2: read-var u#32988:u8
        let s_1105_2: u8 = fn_state.u_32988;
        // D s_1105_3: read-var u#32989:u8
        let s_1105_3: u8 = fn_state.u_32989;
        // D s_1105_4: call decode_aarch32_instrs_STREXD_A1enc_A_txt(s_1105_0, s_1105_1, s_1105_2, s_1105_3)
        let s_1105_4: () = decode_aarch32_instrs_STREXD_A1enc_A_txt(
            state,
            tracer,
            s_1105_0,
            s_1105_1,
            s_1105_2,
            s_1105_3,
        );
        // N s_1105_5: return
        return;
    }
    fn block_1106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1106_0: panic
        panic!("{:?}", ());
        // N s_1106_1: return
        return;
    }
    fn block_1107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1107_0: const #1u : u8
        let s_1107_0: bool = true;
        // D s_1107_1: write-var gs#406805 <= s_1107_0
        fn_state.gs_406805 = s_1107_0;
        // N s_1107_2: jump b1104
        return block_1104(state, tracer, fn_state);
    }
    fn block_1108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1108_0: read-var merge#var.1:struct
        let s_1108_0: u32 = fn_state.merge_var._1;
        // D s_1108_1: write-var u#32991 <= s_1108_0
        fn_state.u_32991 = s_1108_0;
        // C s_1108_2: const #20s : i
        let s_1108_2: i128 = 20;
        // D s_1108_3: read-var u#32991:u32
        let s_1108_3: u32 = fn_state.u_32991;
        // D s_1108_4: cast zx s_1108_3 -> bv
        let s_1108_4: Bits = Bits::new(s_1108_3 as u128, 32u16);
        // C s_1108_5: const #1s : i64
        let s_1108_5: i64 = 1;
        // C s_1108_6: cast zx s_1108_5 -> i
        let s_1108_6: i128 = (i128::try_from(s_1108_5).unwrap());
        // C s_1108_7: const #7s : i
        let s_1108_7: i128 = 7;
        // C s_1108_8: add s_1108_7 s_1108_6
        let s_1108_8: i128 = (s_1108_7 + s_1108_6);
        // D s_1108_9: bit-extract s_1108_4 s_1108_2 s_1108_8
        let s_1108_9: Bits = (Bits::new(
            ((s_1108_4) >> (s_1108_2)).value(),
            u16::try_from(s_1108_8).unwrap(),
        ));
        // D s_1108_10: cast reint s_1108_9 -> u8
        let s_1108_10: u8 = (s_1108_9.value() as u8);
        // D s_1108_11: cast zx s_1108_10 -> bv
        let s_1108_11: Bits = Bits::new(s_1108_10 as u128, 8u16);
        // C s_1108_12: const #30u : u8
        let s_1108_12: u8 = 30;
        // C s_1108_13: cast zx s_1108_12 -> bv
        let s_1108_13: Bits = Bits::new(s_1108_12 as u128, 8u16);
        // D s_1108_14: cmp-eq s_1108_11 s_1108_13
        let s_1108_14: bool = ((s_1108_11) == (s_1108_13));
        // N s_1108_15: branch s_1108_14 b2359 b1109
        if s_1108_14 {
            return block_2359(state, tracer, fn_state);
        } else {
            return block_1109(state, tracer, fn_state);
        };
    }
    fn block_1109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1109_0: const #0u : u8
        let s_1109_0: bool = false;
        // D s_1109_1: write-var gs#406811 <= s_1109_0
        fn_state.gs_406811 = s_1109_0;
        // N s_1109_2: jump b1110
        return block_1110(state, tracer, fn_state);
    }
    fn block_1110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1110_0: read-var gs#406811:u8
        let s_1110_0: bool = fn_state.gs_406811;
        // N s_1110_1: branch s_1110_0 b2355 b1111
        if s_1110_0 {
            return block_2355(state, tracer, fn_state);
        } else {
            return block_1111(state, tracer, fn_state);
        };
    }
    fn block_1111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1111_0: const #0u : u8
        let s_1111_0: bool = false;
        // D s_1111_1: write-var gs#406816 <= s_1111_0
        fn_state.gs_406816 = s_1111_0;
        // N s_1111_2: jump b1112
        return block_1112(state, tracer, fn_state);
    }
    fn block_1112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1112_0: read-var gs#406816:u8
        let s_1112_0: bool = fn_state.gs_406816;
        // D s_1112_1: not s_1112_0
        let s_1112_1: bool = !s_1112_0;
        // N s_1112_2: branch s_1112_1 b1119 b1113
        if s_1112_1 {
            return block_1119(state, tracer, fn_state);
        } else {
            return block_1113(state, tracer, fn_state);
        };
    }
    fn block_1113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1113_0: const #3212s : i
        let s_1113_0: i128 = 3212;
        // C s_1113_1: const #14696u : u32
        let s_1113_1: u32 = 14696;
        // N s_1113_2: write-reg s_1113_1 <= s_1113_0
        let s_1113_2: () = {
            state.write_register::<i128>(s_1113_1 as isize, s_1113_0);
            tracer.write_register(s_1113_1 as isize, s_1113_0);
        };
        // C s_1113_3: const #28s : i
        let s_1113_3: i128 = 28;
        // C s_1113_4: const #4s : i
        let s_1113_4: i128 = 4;
        // D s_1113_5: read-var u#32991:u32
        let s_1113_5: u32 = fn_state.u_32991;
        // D s_1113_6: cast zx s_1113_5 -> bv
        let s_1113_6: Bits = Bits::new(s_1113_5 as u128, 32u16);
        // D s_1113_7: bit-extract s_1113_6 s_1113_3 s_1113_4
        let s_1113_7: Bits = (Bits::new(
            ((s_1113_6) >> (s_1113_3)).value(),
            u16::try_from(s_1113_4).unwrap(),
        ));
        // D s_1113_8: cast reint s_1113_7 -> u8
        let s_1113_8: u8 = (s_1113_7.value() as u8);
        // D s_1113_9: write-var u#32992 <= s_1113_8
        fn_state.u_32992 = s_1113_8;
        // C s_1113_10: const #16s : i
        let s_1113_10: i128 = 16;
        // C s_1113_11: const #4s : i
        let s_1113_11: i128 = 4;
        // D s_1113_12: read-var u#32991:u32
        let s_1113_12: u32 = fn_state.u_32991;
        // D s_1113_13: cast zx s_1113_12 -> bv
        let s_1113_13: Bits = Bits::new(s_1113_12 as u128, 32u16);
        // D s_1113_14: bit-extract s_1113_13 s_1113_10 s_1113_11
        let s_1113_14: Bits = (Bits::new(
            ((s_1113_13) >> (s_1113_10)).value(),
            u16::try_from(s_1113_11).unwrap(),
        ));
        // D s_1113_15: cast reint s_1113_14 -> u8
        let s_1113_15: u8 = (s_1113_14.value() as u8);
        // D s_1113_16: write-var u#32993 <= s_1113_15
        fn_state.u_32993 = s_1113_15;
        // C s_1113_17: const #12s : i
        let s_1113_17: i128 = 12;
        // C s_1113_18: const #4s : i
        let s_1113_18: i128 = 4;
        // D s_1113_19: read-var u#32991:u32
        let s_1113_19: u32 = fn_state.u_32991;
        // D s_1113_20: cast zx s_1113_19 -> bv
        let s_1113_20: Bits = Bits::new(s_1113_19 as u128, 32u16);
        // D s_1113_21: bit-extract s_1113_20 s_1113_17 s_1113_18
        let s_1113_21: Bits = (Bits::new(
            ((s_1113_20) >> (s_1113_17)).value(),
            u16::try_from(s_1113_18).unwrap(),
        ));
        // D s_1113_22: cast reint s_1113_21 -> u8
        let s_1113_22: u8 = (s_1113_21.value() as u8);
        // D s_1113_23: write-var u#32994 <= s_1113_22
        fn_state.u_32994 = s_1113_22;
        // C s_1113_24: const #0s : i
        let s_1113_24: i128 = 0;
        // C s_1113_25: const #4s : i
        let s_1113_25: i128 = 4;
        // D s_1113_26: read-var u#32991:u32
        let s_1113_26: u32 = fn_state.u_32991;
        // D s_1113_27: cast zx s_1113_26 -> bv
        let s_1113_27: Bits = Bits::new(s_1113_26 as u128, 32u16);
        // D s_1113_28: bit-extract s_1113_27 s_1113_24 s_1113_25
        let s_1113_28: Bits = (Bits::new(
            ((s_1113_27) >> (s_1113_24)).value(),
            u16::try_from(s_1113_25).unwrap(),
        ));
        // D s_1113_29: cast reint s_1113_28 -> u8
        let s_1113_29: u8 = (s_1113_28.value() as u8);
        // D s_1113_30: write-var u#32995 <= s_1113_29
        fn_state.u_32995 = s_1113_29;
        // C s_1113_31: const #8s : i
        let s_1113_31: i128 = 8;
        // D s_1113_32: read-var u#32991:u32
        let s_1113_32: u32 = fn_state.u_32991;
        // D s_1113_33: cast zx s_1113_32 -> bv
        let s_1113_33: Bits = Bits::new(s_1113_32 as u128, 32u16);
        // C s_1113_34: const #1u : u64
        let s_1113_34: u64 = 1;
        // D s_1113_35: bit-extract s_1113_33 s_1113_31 s_1113_34
        let s_1113_35: Bits = (Bits::new(
            ((s_1113_33) >> (s_1113_31)).value(),
            u16::try_from(s_1113_34).unwrap(),
        ));
        // D s_1113_36: cast reint s_1113_35 -> u8
        let s_1113_36: bool = ((s_1113_35.value()) != 0);
        // C s_1113_37: const #0s : i
        let s_1113_37: i128 = 0;
        // C s_1113_38: const #0u : u64
        let s_1113_38: u64 = 0;
        // D s_1113_39: cast zx s_1113_36 -> u64
        let s_1113_39: u64 = (s_1113_36 as u64);
        // C s_1113_40: const #1u : u64
        let s_1113_40: u64 = 1;
        // D s_1113_41: and s_1113_39 s_1113_40
        let s_1113_41: u64 = ((s_1113_39) & (s_1113_40));
        // D s_1113_42: cmp-eq s_1113_41 s_1113_40
        let s_1113_42: bool = ((s_1113_41) == (s_1113_40));
        // D s_1113_43: lsl s_1113_39 s_1113_37
        let s_1113_43: u64 = s_1113_39 << s_1113_37;
        // D s_1113_44: or s_1113_38 s_1113_43
        let s_1113_44: u64 = ((s_1113_38) | (s_1113_43));
        // D s_1113_45: cmpl s_1113_43
        let s_1113_45: u64 = !s_1113_43;
        // D s_1113_46: and s_1113_38 s_1113_45
        let s_1113_46: u64 = ((s_1113_38) & (s_1113_45));
        // D s_1113_47: select s_1113_42 s_1113_44 s_1113_46
        let s_1113_47: u64 = if s_1113_42 { s_1113_44 } else { s_1113_46 };
        // D s_1113_48: cast trunc s_1113_47 -> u8
        let s_1113_48: bool = ((s_1113_47) != 0);
        // D s_1113_49: cast zx s_1113_48 -> bv
        let s_1113_49: Bits = Bits::new(s_1113_48 as u128, 1u16);
        // C s_1113_50: const #1u : u8
        let s_1113_50: bool = true;
        // C s_1113_51: cast zx s_1113_50 -> bv
        let s_1113_51: Bits = Bits::new(s_1113_50 as u128, 1u16);
        // D s_1113_52: cmp-ne s_1113_49 s_1113_51
        let s_1113_52: bool = ((s_1113_49) != (s_1113_51));
        // N s_1113_53: branch s_1113_52 b1118 b1114
        if s_1113_52 {
            return block_1118(state, tracer, fn_state);
        } else {
            return block_1114(state, tracer, fn_state);
        };
    }
    fn block_1114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1114_0: const #9s : i
        let s_1114_0: i128 = 9;
        // D s_1114_1: read-var u#32991:u32
        let s_1114_1: u32 = fn_state.u_32991;
        // D s_1114_2: cast zx s_1114_1 -> bv
        let s_1114_2: Bits = Bits::new(s_1114_1 as u128, 32u16);
        // C s_1114_3: const #1u : u64
        let s_1114_3: u64 = 1;
        // D s_1114_4: bit-extract s_1114_2 s_1114_0 s_1114_3
        let s_1114_4: Bits = (Bits::new(
            ((s_1114_2) >> (s_1114_0)).value(),
            u16::try_from(s_1114_3).unwrap(),
        ));
        // D s_1114_5: cast reint s_1114_4 -> u8
        let s_1114_5: bool = ((s_1114_4.value()) != 0);
        // C s_1114_6: const #0s : i
        let s_1114_6: i128 = 0;
        // C s_1114_7: const #0u : u64
        let s_1114_7: u64 = 0;
        // D s_1114_8: cast zx s_1114_5 -> u64
        let s_1114_8: u64 = (s_1114_5 as u64);
        // C s_1114_9: const #1u : u64
        let s_1114_9: u64 = 1;
        // D s_1114_10: and s_1114_8 s_1114_9
        let s_1114_10: u64 = ((s_1114_8) & (s_1114_9));
        // D s_1114_11: cmp-eq s_1114_10 s_1114_9
        let s_1114_11: bool = ((s_1114_10) == (s_1114_9));
        // D s_1114_12: lsl s_1114_8 s_1114_6
        let s_1114_12: u64 = s_1114_8 << s_1114_6;
        // D s_1114_13: or s_1114_7 s_1114_12
        let s_1114_13: u64 = ((s_1114_7) | (s_1114_12));
        // D s_1114_14: cmpl s_1114_12
        let s_1114_14: u64 = !s_1114_12;
        // D s_1114_15: and s_1114_7 s_1114_14
        let s_1114_15: u64 = ((s_1114_7) & (s_1114_14));
        // D s_1114_16: select s_1114_11 s_1114_13 s_1114_15
        let s_1114_16: u64 = if s_1114_11 { s_1114_13 } else { s_1114_15 };
        // D s_1114_17: cast trunc s_1114_16 -> u8
        let s_1114_17: bool = ((s_1114_16) != 0);
        // D s_1114_18: cast zx s_1114_17 -> bv
        let s_1114_18: Bits = Bits::new(s_1114_17 as u128, 1u16);
        // C s_1114_19: const #1u : u8
        let s_1114_19: bool = true;
        // C s_1114_20: cast zx s_1114_19 -> bv
        let s_1114_20: Bits = Bits::new(s_1114_19 as u128, 1u16);
        // D s_1114_21: cmp-ne s_1114_18 s_1114_20
        let s_1114_21: bool = ((s_1114_18) != (s_1114_20));
        // D s_1114_22: write-var gs#406831 <= s_1114_21
        fn_state.gs_406831 = s_1114_21;
        // N s_1114_23: jump b1115
        return block_1115(state, tracer, fn_state);
    }
    fn block_1115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1115_0: read-var gs#406831:u8
        let s_1115_0: bool = fn_state.gs_406831;
        // N s_1115_1: branch s_1115_0 b1117 b1116
        if s_1115_0 {
            return block_1117(state, tracer, fn_state);
        } else {
            return block_1116(state, tracer, fn_state);
        };
    }
    fn block_1116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1116_0: read-var u#32992:u8
        let s_1116_0: u8 = fn_state.u_32992;
        // D s_1116_1: read-var u#32993:u8
        let s_1116_1: u8 = fn_state.u_32993;
        // D s_1116_2: read-var u#32994:u8
        let s_1116_2: u8 = fn_state.u_32994;
        // D s_1116_3: read-var u#32995:u8
        let s_1116_3: u8 = fn_state.u_32995;
        // D s_1116_4: call decode_aarch32_instrs_STREXH_A1enc_A_txt(s_1116_0, s_1116_1, s_1116_2, s_1116_3)
        let s_1116_4: () = decode_aarch32_instrs_STREXH_A1enc_A_txt(
            state,
            tracer,
            s_1116_0,
            s_1116_1,
            s_1116_2,
            s_1116_3,
        );
        // N s_1116_5: return
        return;
    }
    fn block_1117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1117_0: panic
        panic!("{:?}", ());
        // N s_1117_1: return
        return;
    }
    fn block_1118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1118_0: const #1u : u8
        let s_1118_0: bool = true;
        // D s_1118_1: write-var gs#406831 <= s_1118_0
        fn_state.gs_406831 = s_1118_0;
        // N s_1118_2: jump b1115
        return block_1115(state, tracer, fn_state);
    }
    fn block_1119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1119_0: read-var merge#var.1:struct
        let s_1119_0: u32 = fn_state.merge_var._1;
        // D s_1119_1: write-var u#32997 <= s_1119_0
        fn_state.u_32997 = s_1119_0;
        // C s_1119_2: const #25s : i
        let s_1119_2: i128 = 25;
        // D s_1119_3: read-var u#32997:u32
        let s_1119_3: u32 = fn_state.u_32997;
        // D s_1119_4: cast zx s_1119_3 -> bv
        let s_1119_4: Bits = Bits::new(s_1119_3 as u128, 32u16);
        // C s_1119_5: const #1s : i64
        let s_1119_5: i64 = 1;
        // C s_1119_6: cast zx s_1119_5 -> i
        let s_1119_6: i128 = (i128::try_from(s_1119_5).unwrap());
        // C s_1119_7: const #2s : i
        let s_1119_7: i128 = 2;
        // C s_1119_8: add s_1119_7 s_1119_6
        let s_1119_8: i128 = (s_1119_7 + s_1119_6);
        // D s_1119_9: bit-extract s_1119_4 s_1119_2 s_1119_8
        let s_1119_9: Bits = (Bits::new(
            ((s_1119_4) >> (s_1119_2)).value(),
            u16::try_from(s_1119_8).unwrap(),
        ));
        // D s_1119_10: cast reint s_1119_9 -> u8
        let s_1119_10: u8 = (s_1119_9.value() as u8);
        // D s_1119_11: cast zx s_1119_10 -> bv
        let s_1119_11: Bits = Bits::new(s_1119_10 as u128, 3u16);
        // C s_1119_12: const #0u : u8
        let s_1119_12: u8 = 0;
        // C s_1119_13: cast zx s_1119_12 -> bv
        let s_1119_13: Bits = Bits::new(s_1119_12 as u128, 3u16);
        // D s_1119_14: cmp-eq s_1119_11 s_1119_13
        let s_1119_14: bool = ((s_1119_11) == (s_1119_13));
        // N s_1119_15: branch s_1119_14 b2348 b1120
        if s_1119_14 {
            return block_2348(state, tracer, fn_state);
        } else {
            return block_1120(state, tracer, fn_state);
        };
    }
    fn block_1120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1120_0: const #0u : u8
        let s_1120_0: bool = false;
        // D s_1120_1: write-var gs#406843 <= s_1120_0
        fn_state.gs_406843 = s_1120_0;
        // N s_1120_2: jump b1121
        return block_1121(state, tracer, fn_state);
    }
    fn block_1121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1121_0: read-var gs#406843:u8
        let s_1121_0: bool = fn_state.gs_406843;
        // N s_1121_1: branch s_1121_0 b2344 b1122
        if s_1121_0 {
            return block_2344(state, tracer, fn_state);
        } else {
            return block_1122(state, tracer, fn_state);
        };
    }
    fn block_1122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1122_0: const #0u : u8
        let s_1122_0: bool = false;
        // D s_1122_1: write-var gs#406848 <= s_1122_0
        fn_state.gs_406848 = s_1122_0;
        // N s_1122_2: jump b1123
        return block_1123(state, tracer, fn_state);
    }
    fn block_1123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1123_0: read-var gs#406848:u8
        let s_1123_0: bool = fn_state.gs_406848;
        // D s_1123_1: not s_1123_0
        let s_1123_1: bool = !s_1123_0;
        // N s_1123_2: branch s_1123_1 b1125 b1124
        if s_1123_1 {
            return block_1125(state, tracer, fn_state);
        } else {
            return block_1124(state, tracer, fn_state);
        };
    }
    fn block_1124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1124_0: const #3214s : i
        let s_1124_0: i128 = 3214;
        // C s_1124_1: const #14696u : u32
        let s_1124_1: u32 = 14696;
        // N s_1124_2: write-reg s_1124_1 <= s_1124_0
        let s_1124_2: () = {
            state.write_register::<i128>(s_1124_1 as isize, s_1124_0);
            tracer.write_register(s_1124_1 as isize, s_1124_0);
        };
        // C s_1124_3: const #28s : i
        let s_1124_3: i128 = 28;
        // C s_1124_4: const #4s : i
        let s_1124_4: i128 = 4;
        // D s_1124_5: read-var u#32997:u32
        let s_1124_5: u32 = fn_state.u_32997;
        // D s_1124_6: cast zx s_1124_5 -> bv
        let s_1124_6: Bits = Bits::new(s_1124_5 as u128, 32u16);
        // D s_1124_7: bit-extract s_1124_6 s_1124_3 s_1124_4
        let s_1124_7: Bits = (Bits::new(
            ((s_1124_6) >> (s_1124_3)).value(),
            u16::try_from(s_1124_4).unwrap(),
        ));
        // D s_1124_8: cast reint s_1124_7 -> u8
        let s_1124_8: u8 = (s_1124_7.value() as u8);
        // C s_1124_9: const #24s : i
        let s_1124_9: i128 = 24;
        // C s_1124_10: const #1s : i
        let s_1124_10: i128 = 1;
        // D s_1124_11: read-var u#32997:u32
        let s_1124_11: u32 = fn_state.u_32997;
        // D s_1124_12: cast zx s_1124_11 -> bv
        let s_1124_12: Bits = Bits::new(s_1124_11 as u128, 32u16);
        // D s_1124_13: bit-extract s_1124_12 s_1124_9 s_1124_10
        let s_1124_13: Bits = (Bits::new(
            ((s_1124_12) >> (s_1124_9)).value(),
            u16::try_from(s_1124_10).unwrap(),
        ));
        // D s_1124_14: cast reint s_1124_13 -> u8
        let s_1124_14: bool = ((s_1124_13.value()) != 0);
        // C s_1124_15: const #23s : i
        let s_1124_15: i128 = 23;
        // C s_1124_16: const #1s : i
        let s_1124_16: i128 = 1;
        // D s_1124_17: read-var u#32997:u32
        let s_1124_17: u32 = fn_state.u_32997;
        // D s_1124_18: cast zx s_1124_17 -> bv
        let s_1124_18: Bits = Bits::new(s_1124_17 as u128, 32u16);
        // D s_1124_19: bit-extract s_1124_18 s_1124_15 s_1124_16
        let s_1124_19: Bits = (Bits::new(
            ((s_1124_18) >> (s_1124_15)).value(),
            u16::try_from(s_1124_16).unwrap(),
        ));
        // D s_1124_20: cast reint s_1124_19 -> u8
        let s_1124_20: bool = ((s_1124_19.value()) != 0);
        // C s_1124_21: const #21s : i
        let s_1124_21: i128 = 21;
        // C s_1124_22: const #1s : i
        let s_1124_22: i128 = 1;
        // D s_1124_23: read-var u#32997:u32
        let s_1124_23: u32 = fn_state.u_32997;
        // D s_1124_24: cast zx s_1124_23 -> bv
        let s_1124_24: Bits = Bits::new(s_1124_23 as u128, 32u16);
        // D s_1124_25: bit-extract s_1124_24 s_1124_21 s_1124_22
        let s_1124_25: Bits = (Bits::new(
            ((s_1124_24) >> (s_1124_21)).value(),
            u16::try_from(s_1124_22).unwrap(),
        ));
        // D s_1124_26: cast reint s_1124_25 -> u8
        let s_1124_26: bool = ((s_1124_25.value()) != 0);
        // C s_1124_27: const #16s : i
        let s_1124_27: i128 = 16;
        // C s_1124_28: const #4s : i
        let s_1124_28: i128 = 4;
        // D s_1124_29: read-var u#32997:u32
        let s_1124_29: u32 = fn_state.u_32997;
        // D s_1124_30: cast zx s_1124_29 -> bv
        let s_1124_30: Bits = Bits::new(s_1124_29 as u128, 32u16);
        // D s_1124_31: bit-extract s_1124_30 s_1124_27 s_1124_28
        let s_1124_31: Bits = (Bits::new(
            ((s_1124_30) >> (s_1124_27)).value(),
            u16::try_from(s_1124_28).unwrap(),
        ));
        // D s_1124_32: cast reint s_1124_31 -> u8
        let s_1124_32: u8 = (s_1124_31.value() as u8);
        // C s_1124_33: const #12s : i
        let s_1124_33: i128 = 12;
        // C s_1124_34: const #4s : i
        let s_1124_34: i128 = 4;
        // D s_1124_35: read-var u#32997:u32
        let s_1124_35: u32 = fn_state.u_32997;
        // D s_1124_36: cast zx s_1124_35 -> bv
        let s_1124_36: Bits = Bits::new(s_1124_35 as u128, 32u16);
        // D s_1124_37: bit-extract s_1124_36 s_1124_33 s_1124_34
        let s_1124_37: Bits = (Bits::new(
            ((s_1124_36) >> (s_1124_33)).value(),
            u16::try_from(s_1124_34).unwrap(),
        ));
        // D s_1124_38: cast reint s_1124_37 -> u8
        let s_1124_38: u8 = (s_1124_37.value() as u8);
        // C s_1124_39: const #8s : i
        let s_1124_39: i128 = 8;
        // C s_1124_40: const #4s : i
        let s_1124_40: i128 = 4;
        // D s_1124_41: read-var u#32997:u32
        let s_1124_41: u32 = fn_state.u_32997;
        // D s_1124_42: cast zx s_1124_41 -> bv
        let s_1124_42: Bits = Bits::new(s_1124_41 as u128, 32u16);
        // D s_1124_43: bit-extract s_1124_42 s_1124_39 s_1124_40
        let s_1124_43: Bits = (Bits::new(
            ((s_1124_42) >> (s_1124_39)).value(),
            u16::try_from(s_1124_40).unwrap(),
        ));
        // D s_1124_44: cast reint s_1124_43 -> u8
        let s_1124_44: u8 = (s_1124_43.value() as u8);
        // C s_1124_45: const #0s : i
        let s_1124_45: i128 = 0;
        // C s_1124_46: const #4s : i
        let s_1124_46: i128 = 4;
        // D s_1124_47: read-var u#32997:u32
        let s_1124_47: u32 = fn_state.u_32997;
        // D s_1124_48: cast zx s_1124_47 -> bv
        let s_1124_48: Bits = Bits::new(s_1124_47 as u128, 32u16);
        // D s_1124_49: bit-extract s_1124_48 s_1124_45 s_1124_46
        let s_1124_49: Bits = (Bits::new(
            ((s_1124_48) >> (s_1124_45)).value(),
            u16::try_from(s_1124_46).unwrap(),
        ));
        // D s_1124_50: cast reint s_1124_49 -> u8
        let s_1124_50: u8 = (s_1124_49.value() as u8);
        // D s_1124_51: call decode_aarch32_instrs_STRH_i_A1enc_A_txt(s_1124_8, s_1124_14, s_1124_20, s_1124_26, s_1124_32, s_1124_38, s_1124_44, s_1124_50)
        let s_1124_51: () = decode_aarch32_instrs_STRH_i_A1enc_A_txt(
            state,
            tracer,
            s_1124_8,
            s_1124_14,
            s_1124_20,
            s_1124_26,
            s_1124_32,
            s_1124_38,
            s_1124_44,
            s_1124_50,
        );
        // N s_1124_52: return
        return;
    }
    fn block_1125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1125_0: read-var merge#var.1:struct
        let s_1125_0: u32 = fn_state.merge_var._1;
        // D s_1125_1: write-var u#33007 <= s_1125_0
        fn_state.u_33007 = s_1125_0;
        // C s_1125_2: const #25s : i
        let s_1125_2: i128 = 25;
        // D s_1125_3: read-var u#33007:u32
        let s_1125_3: u32 = fn_state.u_33007;
        // D s_1125_4: cast zx s_1125_3 -> bv
        let s_1125_4: Bits = Bits::new(s_1125_3 as u128, 32u16);
        // C s_1125_5: const #1s : i64
        let s_1125_5: i64 = 1;
        // C s_1125_6: cast zx s_1125_5 -> i
        let s_1125_6: i128 = (i128::try_from(s_1125_5).unwrap());
        // C s_1125_7: const #2s : i
        let s_1125_7: i128 = 2;
        // C s_1125_8: add s_1125_7 s_1125_6
        let s_1125_8: i128 = (s_1125_7 + s_1125_6);
        // D s_1125_9: bit-extract s_1125_4 s_1125_2 s_1125_8
        let s_1125_9: Bits = (Bits::new(
            ((s_1125_4) >> (s_1125_2)).value(),
            u16::try_from(s_1125_8).unwrap(),
        ));
        // D s_1125_10: cast reint s_1125_9 -> u8
        let s_1125_10: u8 = (s_1125_9.value() as u8);
        // D s_1125_11: cast zx s_1125_10 -> bv
        let s_1125_11: Bits = Bits::new(s_1125_10 as u128, 3u16);
        // C s_1125_12: const #0u : u8
        let s_1125_12: u8 = 0;
        // C s_1125_13: cast zx s_1125_12 -> bv
        let s_1125_13: Bits = Bits::new(s_1125_12 as u128, 3u16);
        // D s_1125_14: cmp-eq s_1125_11 s_1125_13
        let s_1125_14: bool = ((s_1125_11) == (s_1125_13));
        // N s_1125_15: branch s_1125_14 b2337 b1126
        if s_1125_14 {
            return block_2337(state, tracer, fn_state);
        } else {
            return block_1126(state, tracer, fn_state);
        };
    }
    fn block_1126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1126_0: const #0u : u8
        let s_1126_0: bool = false;
        // D s_1126_1: write-var gs#406878 <= s_1126_0
        fn_state.gs_406878 = s_1126_0;
        // N s_1126_2: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_1127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1127_0: read-var gs#406878:u8
        let s_1127_0: bool = fn_state.gs_406878;
        // N s_1127_1: branch s_1127_0 b2333 b1128
        if s_1127_0 {
            return block_2333(state, tracer, fn_state);
        } else {
            return block_1128(state, tracer, fn_state);
        };
    }
    fn block_1128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1128_0: const #0u : u8
        let s_1128_0: bool = false;
        // D s_1128_1: write-var gs#406883 <= s_1128_0
        fn_state.gs_406883 = s_1128_0;
        // N s_1128_2: jump b1129
        return block_1129(state, tracer, fn_state);
    }
    fn block_1129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1129_0: read-var gs#406883:u8
        let s_1129_0: bool = fn_state.gs_406883;
        // D s_1129_1: not s_1129_0
        let s_1129_1: bool = !s_1129_0;
        // N s_1129_2: branch s_1129_1 b1142 b1130
        if s_1129_1 {
            return block_1142(state, tracer, fn_state);
        } else {
            return block_1130(state, tracer, fn_state);
        };
    }
    fn block_1130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1130_0: const #3218s : i
        let s_1130_0: i128 = 3218;
        // C s_1130_1: const #14696u : u32
        let s_1130_1: u32 = 14696;
        // N s_1130_2: write-reg s_1130_1 <= s_1130_0
        let s_1130_2: () = {
            state.write_register::<i128>(s_1130_1 as isize, s_1130_0);
            tracer.write_register(s_1130_1 as isize, s_1130_0);
        };
        // C s_1130_3: const #28s : i
        let s_1130_3: i128 = 28;
        // C s_1130_4: const #4s : i
        let s_1130_4: i128 = 4;
        // D s_1130_5: read-var u#33007:u32
        let s_1130_5: u32 = fn_state.u_33007;
        // D s_1130_6: cast zx s_1130_5 -> bv
        let s_1130_6: Bits = Bits::new(s_1130_5 as u128, 32u16);
        // D s_1130_7: bit-extract s_1130_6 s_1130_3 s_1130_4
        let s_1130_7: Bits = (Bits::new(
            ((s_1130_6) >> (s_1130_3)).value(),
            u16::try_from(s_1130_4).unwrap(),
        ));
        // D s_1130_8: cast reint s_1130_7 -> u8
        let s_1130_8: u8 = (s_1130_7.value() as u8);
        // D s_1130_9: write-var u#33008 <= s_1130_8
        fn_state.u_33008 = s_1130_8;
        // C s_1130_10: const #24s : i
        let s_1130_10: i128 = 24;
        // C s_1130_11: const #1s : i
        let s_1130_11: i128 = 1;
        // D s_1130_12: read-var u#33007:u32
        let s_1130_12: u32 = fn_state.u_33007;
        // D s_1130_13: cast zx s_1130_12 -> bv
        let s_1130_13: Bits = Bits::new(s_1130_12 as u128, 32u16);
        // D s_1130_14: bit-extract s_1130_13 s_1130_10 s_1130_11
        let s_1130_14: Bits = (Bits::new(
            ((s_1130_13) >> (s_1130_10)).value(),
            u16::try_from(s_1130_11).unwrap(),
        ));
        // D s_1130_15: cast reint s_1130_14 -> u8
        let s_1130_15: bool = ((s_1130_14.value()) != 0);
        // D s_1130_16: write-var u#33009 <= s_1130_15
        fn_state.u_33009 = s_1130_15;
        // C s_1130_17: const #23s : i
        let s_1130_17: i128 = 23;
        // C s_1130_18: const #1s : i
        let s_1130_18: i128 = 1;
        // D s_1130_19: read-var u#33007:u32
        let s_1130_19: u32 = fn_state.u_33007;
        // D s_1130_20: cast zx s_1130_19 -> bv
        let s_1130_20: Bits = Bits::new(s_1130_19 as u128, 32u16);
        // D s_1130_21: bit-extract s_1130_20 s_1130_17 s_1130_18
        let s_1130_21: Bits = (Bits::new(
            ((s_1130_20) >> (s_1130_17)).value(),
            u16::try_from(s_1130_18).unwrap(),
        ));
        // D s_1130_22: cast reint s_1130_21 -> u8
        let s_1130_22: bool = ((s_1130_21.value()) != 0);
        // D s_1130_23: write-var u#33010 <= s_1130_22
        fn_state.u_33010 = s_1130_22;
        // C s_1130_24: const #21s : i
        let s_1130_24: i128 = 21;
        // C s_1130_25: const #1s : i
        let s_1130_25: i128 = 1;
        // D s_1130_26: read-var u#33007:u32
        let s_1130_26: u32 = fn_state.u_33007;
        // D s_1130_27: cast zx s_1130_26 -> bv
        let s_1130_27: Bits = Bits::new(s_1130_26 as u128, 32u16);
        // D s_1130_28: bit-extract s_1130_27 s_1130_24 s_1130_25
        let s_1130_28: Bits = (Bits::new(
            ((s_1130_27) >> (s_1130_24)).value(),
            u16::try_from(s_1130_25).unwrap(),
        ));
        // D s_1130_29: cast reint s_1130_28 -> u8
        let s_1130_29: bool = ((s_1130_28.value()) != 0);
        // D s_1130_30: write-var u#33011 <= s_1130_29
        fn_state.u_33011 = s_1130_29;
        // C s_1130_31: const #16s : i
        let s_1130_31: i128 = 16;
        // C s_1130_32: const #4s : i
        let s_1130_32: i128 = 4;
        // D s_1130_33: read-var u#33007:u32
        let s_1130_33: u32 = fn_state.u_33007;
        // D s_1130_34: cast zx s_1130_33 -> bv
        let s_1130_34: Bits = Bits::new(s_1130_33 as u128, 32u16);
        // D s_1130_35: bit-extract s_1130_34 s_1130_31 s_1130_32
        let s_1130_35: Bits = (Bits::new(
            ((s_1130_34) >> (s_1130_31)).value(),
            u16::try_from(s_1130_32).unwrap(),
        ));
        // D s_1130_36: cast reint s_1130_35 -> u8
        let s_1130_36: u8 = (s_1130_35.value() as u8);
        // D s_1130_37: write-var u#33012 <= s_1130_36
        fn_state.u_33012 = s_1130_36;
        // C s_1130_38: const #12s : i
        let s_1130_38: i128 = 12;
        // C s_1130_39: const #4s : i
        let s_1130_39: i128 = 4;
        // D s_1130_40: read-var u#33007:u32
        let s_1130_40: u32 = fn_state.u_33007;
        // D s_1130_41: cast zx s_1130_40 -> bv
        let s_1130_41: Bits = Bits::new(s_1130_40 as u128, 32u16);
        // D s_1130_42: bit-extract s_1130_41 s_1130_38 s_1130_39
        let s_1130_42: Bits = (Bits::new(
            ((s_1130_41) >> (s_1130_38)).value(),
            u16::try_from(s_1130_39).unwrap(),
        ));
        // D s_1130_43: cast reint s_1130_42 -> u8
        let s_1130_43: u8 = (s_1130_42.value() as u8);
        // D s_1130_44: write-var u#33013 <= s_1130_43
        fn_state.u_33013 = s_1130_43;
        // C s_1130_45: const #0s : i
        let s_1130_45: i128 = 0;
        // C s_1130_46: const #4s : i
        let s_1130_46: i128 = 4;
        // D s_1130_47: read-var u#33007:u32
        let s_1130_47: u32 = fn_state.u_33007;
        // D s_1130_48: cast zx s_1130_47 -> bv
        let s_1130_48: Bits = Bits::new(s_1130_47 as u128, 32u16);
        // D s_1130_49: bit-extract s_1130_48 s_1130_45 s_1130_46
        let s_1130_49: Bits = (Bits::new(
            ((s_1130_48) >> (s_1130_45)).value(),
            u16::try_from(s_1130_46).unwrap(),
        ));
        // D s_1130_50: cast reint s_1130_49 -> u8
        let s_1130_50: u8 = (s_1130_49.value() as u8);
        // D s_1130_51: write-var u#33014 <= s_1130_50
        fn_state.u_33014 = s_1130_50;
        // C s_1130_52: const #8s : i
        let s_1130_52: i128 = 8;
        // D s_1130_53: read-var u#33007:u32
        let s_1130_53: u32 = fn_state.u_33007;
        // D s_1130_54: cast zx s_1130_53 -> bv
        let s_1130_54: Bits = Bits::new(s_1130_53 as u128, 32u16);
        // C s_1130_55: const #1u : u64
        let s_1130_55: u64 = 1;
        // D s_1130_56: bit-extract s_1130_54 s_1130_52 s_1130_55
        let s_1130_56: Bits = (Bits::new(
            ((s_1130_54) >> (s_1130_52)).value(),
            u16::try_from(s_1130_55).unwrap(),
        ));
        // D s_1130_57: cast reint s_1130_56 -> u8
        let s_1130_57: bool = ((s_1130_56.value()) != 0);
        // C s_1130_58: const #0s : i
        let s_1130_58: i128 = 0;
        // C s_1130_59: const #0u : u64
        let s_1130_59: u64 = 0;
        // D s_1130_60: cast zx s_1130_57 -> u64
        let s_1130_60: u64 = (s_1130_57 as u64);
        // C s_1130_61: const #1u : u64
        let s_1130_61: u64 = 1;
        // D s_1130_62: and s_1130_60 s_1130_61
        let s_1130_62: u64 = ((s_1130_60) & (s_1130_61));
        // D s_1130_63: cmp-eq s_1130_62 s_1130_61
        let s_1130_63: bool = ((s_1130_62) == (s_1130_61));
        // D s_1130_64: lsl s_1130_60 s_1130_58
        let s_1130_64: u64 = s_1130_60 << s_1130_58;
        // D s_1130_65: or s_1130_59 s_1130_64
        let s_1130_65: u64 = ((s_1130_59) | (s_1130_64));
        // D s_1130_66: cmpl s_1130_64
        let s_1130_66: u64 = !s_1130_64;
        // D s_1130_67: and s_1130_59 s_1130_66
        let s_1130_67: u64 = ((s_1130_59) & (s_1130_66));
        // D s_1130_68: select s_1130_63 s_1130_65 s_1130_67
        let s_1130_68: u64 = if s_1130_63 { s_1130_65 } else { s_1130_67 };
        // D s_1130_69: cast trunc s_1130_68 -> u8
        let s_1130_69: bool = ((s_1130_68) != 0);
        // D s_1130_70: cast zx s_1130_69 -> bv
        let s_1130_70: Bits = Bits::new(s_1130_69 as u128, 1u16);
        // C s_1130_71: const #0u : u8
        let s_1130_71: bool = false;
        // C s_1130_72: cast zx s_1130_71 -> bv
        let s_1130_72: Bits = Bits::new(s_1130_71 as u128, 1u16);
        // D s_1130_73: cmp-ne s_1130_70 s_1130_72
        let s_1130_73: bool = ((s_1130_70) != (s_1130_72));
        // N s_1130_74: branch s_1130_73 b1141 b1131
        if s_1130_73 {
            return block_1141(state, tracer, fn_state);
        } else {
            return block_1131(state, tracer, fn_state);
        };
    }
    fn block_1131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1131_0: const #9s : i
        let s_1131_0: i128 = 9;
        // D s_1131_1: read-var u#33007:u32
        let s_1131_1: u32 = fn_state.u_33007;
        // D s_1131_2: cast zx s_1131_1 -> bv
        let s_1131_2: Bits = Bits::new(s_1131_1 as u128, 32u16);
        // C s_1131_3: const #1u : u64
        let s_1131_3: u64 = 1;
        // D s_1131_4: bit-extract s_1131_2 s_1131_0 s_1131_3
        let s_1131_4: Bits = (Bits::new(
            ((s_1131_2) >> (s_1131_0)).value(),
            u16::try_from(s_1131_3).unwrap(),
        ));
        // D s_1131_5: cast reint s_1131_4 -> u8
        let s_1131_5: bool = ((s_1131_4.value()) != 0);
        // C s_1131_6: const #0s : i
        let s_1131_6: i128 = 0;
        // C s_1131_7: const #0u : u64
        let s_1131_7: u64 = 0;
        // D s_1131_8: cast zx s_1131_5 -> u64
        let s_1131_8: u64 = (s_1131_5 as u64);
        // C s_1131_9: const #1u : u64
        let s_1131_9: u64 = 1;
        // D s_1131_10: and s_1131_8 s_1131_9
        let s_1131_10: u64 = ((s_1131_8) & (s_1131_9));
        // D s_1131_11: cmp-eq s_1131_10 s_1131_9
        let s_1131_11: bool = ((s_1131_10) == (s_1131_9));
        // D s_1131_12: lsl s_1131_8 s_1131_6
        let s_1131_12: u64 = s_1131_8 << s_1131_6;
        // D s_1131_13: or s_1131_7 s_1131_12
        let s_1131_13: u64 = ((s_1131_7) | (s_1131_12));
        // D s_1131_14: cmpl s_1131_12
        let s_1131_14: u64 = !s_1131_12;
        // D s_1131_15: and s_1131_7 s_1131_14
        let s_1131_15: u64 = ((s_1131_7) & (s_1131_14));
        // D s_1131_16: select s_1131_11 s_1131_13 s_1131_15
        let s_1131_16: u64 = if s_1131_11 { s_1131_13 } else { s_1131_15 };
        // D s_1131_17: cast trunc s_1131_16 -> u8
        let s_1131_17: bool = ((s_1131_16) != 0);
        // D s_1131_18: cast zx s_1131_17 -> bv
        let s_1131_18: Bits = Bits::new(s_1131_17 as u128, 1u16);
        // C s_1131_19: const #0u : u8
        let s_1131_19: bool = false;
        // C s_1131_20: cast zx s_1131_19 -> bv
        let s_1131_20: Bits = Bits::new(s_1131_19 as u128, 1u16);
        // D s_1131_21: cmp-ne s_1131_18 s_1131_20
        let s_1131_21: bool = ((s_1131_18) != (s_1131_20));
        // D s_1131_22: write-var gs#406904 <= s_1131_21
        fn_state.gs_406904 = s_1131_21;
        // N s_1131_23: jump b1132
        return block_1132(state, tracer, fn_state);
    }
    fn block_1132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1132_0: read-var gs#406904:u8
        let s_1132_0: bool = fn_state.gs_406904;
        // N s_1132_1: branch s_1132_0 b1140 b1133
        if s_1132_0 {
            return block_1140(state, tracer, fn_state);
        } else {
            return block_1133(state, tracer, fn_state);
        };
    }
    fn block_1133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1133_0: const #10s : i
        let s_1133_0: i128 = 10;
        // D s_1133_1: read-var u#33007:u32
        let s_1133_1: u32 = fn_state.u_33007;
        // D s_1133_2: cast zx s_1133_1 -> bv
        let s_1133_2: Bits = Bits::new(s_1133_1 as u128, 32u16);
        // C s_1133_3: const #1u : u64
        let s_1133_3: u64 = 1;
        // D s_1133_4: bit-extract s_1133_2 s_1133_0 s_1133_3
        let s_1133_4: Bits = (Bits::new(
            ((s_1133_2) >> (s_1133_0)).value(),
            u16::try_from(s_1133_3).unwrap(),
        ));
        // D s_1133_5: cast reint s_1133_4 -> u8
        let s_1133_5: bool = ((s_1133_4.value()) != 0);
        // C s_1133_6: const #0s : i
        let s_1133_6: i128 = 0;
        // C s_1133_7: const #0u : u64
        let s_1133_7: u64 = 0;
        // D s_1133_8: cast zx s_1133_5 -> u64
        let s_1133_8: u64 = (s_1133_5 as u64);
        // C s_1133_9: const #1u : u64
        let s_1133_9: u64 = 1;
        // D s_1133_10: and s_1133_8 s_1133_9
        let s_1133_10: u64 = ((s_1133_8) & (s_1133_9));
        // D s_1133_11: cmp-eq s_1133_10 s_1133_9
        let s_1133_11: bool = ((s_1133_10) == (s_1133_9));
        // D s_1133_12: lsl s_1133_8 s_1133_6
        let s_1133_12: u64 = s_1133_8 << s_1133_6;
        // D s_1133_13: or s_1133_7 s_1133_12
        let s_1133_13: u64 = ((s_1133_7) | (s_1133_12));
        // D s_1133_14: cmpl s_1133_12
        let s_1133_14: u64 = !s_1133_12;
        // D s_1133_15: and s_1133_7 s_1133_14
        let s_1133_15: u64 = ((s_1133_7) & (s_1133_14));
        // D s_1133_16: select s_1133_11 s_1133_13 s_1133_15
        let s_1133_16: u64 = if s_1133_11 { s_1133_13 } else { s_1133_15 };
        // D s_1133_17: cast trunc s_1133_16 -> u8
        let s_1133_17: bool = ((s_1133_16) != 0);
        // D s_1133_18: cast zx s_1133_17 -> bv
        let s_1133_18: Bits = Bits::new(s_1133_17 as u128, 1u16);
        // C s_1133_19: const #0u : u8
        let s_1133_19: bool = false;
        // C s_1133_20: cast zx s_1133_19 -> bv
        let s_1133_20: Bits = Bits::new(s_1133_19 as u128, 1u16);
        // D s_1133_21: cmp-ne s_1133_18 s_1133_20
        let s_1133_21: bool = ((s_1133_18) != (s_1133_20));
        // D s_1133_22: write-var gs#406907 <= s_1133_21
        fn_state.gs_406907 = s_1133_21;
        // N s_1133_23: jump b1134
        return block_1134(state, tracer, fn_state);
    }
    fn block_1134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1134_0: read-var gs#406907:u8
        let s_1134_0: bool = fn_state.gs_406907;
        // N s_1134_1: branch s_1134_0 b1139 b1135
        if s_1134_0 {
            return block_1139(state, tracer, fn_state);
        } else {
            return block_1135(state, tracer, fn_state);
        };
    }
    fn block_1135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1135_0: const #11s : i
        let s_1135_0: i128 = 11;
        // D s_1135_1: read-var u#33007:u32
        let s_1135_1: u32 = fn_state.u_33007;
        // D s_1135_2: cast zx s_1135_1 -> bv
        let s_1135_2: Bits = Bits::new(s_1135_1 as u128, 32u16);
        // C s_1135_3: const #1u : u64
        let s_1135_3: u64 = 1;
        // D s_1135_4: bit-extract s_1135_2 s_1135_0 s_1135_3
        let s_1135_4: Bits = (Bits::new(
            ((s_1135_2) >> (s_1135_0)).value(),
            u16::try_from(s_1135_3).unwrap(),
        ));
        // D s_1135_5: cast reint s_1135_4 -> u8
        let s_1135_5: bool = ((s_1135_4.value()) != 0);
        // C s_1135_6: const #0s : i
        let s_1135_6: i128 = 0;
        // C s_1135_7: const #0u : u64
        let s_1135_7: u64 = 0;
        // D s_1135_8: cast zx s_1135_5 -> u64
        let s_1135_8: u64 = (s_1135_5 as u64);
        // C s_1135_9: const #1u : u64
        let s_1135_9: u64 = 1;
        // D s_1135_10: and s_1135_8 s_1135_9
        let s_1135_10: u64 = ((s_1135_8) & (s_1135_9));
        // D s_1135_11: cmp-eq s_1135_10 s_1135_9
        let s_1135_11: bool = ((s_1135_10) == (s_1135_9));
        // D s_1135_12: lsl s_1135_8 s_1135_6
        let s_1135_12: u64 = s_1135_8 << s_1135_6;
        // D s_1135_13: or s_1135_7 s_1135_12
        let s_1135_13: u64 = ((s_1135_7) | (s_1135_12));
        // D s_1135_14: cmpl s_1135_12
        let s_1135_14: u64 = !s_1135_12;
        // D s_1135_15: and s_1135_7 s_1135_14
        let s_1135_15: u64 = ((s_1135_7) & (s_1135_14));
        // D s_1135_16: select s_1135_11 s_1135_13 s_1135_15
        let s_1135_16: u64 = if s_1135_11 { s_1135_13 } else { s_1135_15 };
        // D s_1135_17: cast trunc s_1135_16 -> u8
        let s_1135_17: bool = ((s_1135_16) != 0);
        // D s_1135_18: cast zx s_1135_17 -> bv
        let s_1135_18: Bits = Bits::new(s_1135_17 as u128, 1u16);
        // C s_1135_19: const #0u : u8
        let s_1135_19: bool = false;
        // C s_1135_20: cast zx s_1135_19 -> bv
        let s_1135_20: Bits = Bits::new(s_1135_19 as u128, 1u16);
        // D s_1135_21: cmp-ne s_1135_18 s_1135_20
        let s_1135_21: bool = ((s_1135_18) != (s_1135_20));
        // D s_1135_22: write-var gs#406910 <= s_1135_21
        fn_state.gs_406910 = s_1135_21;
        // N s_1135_23: jump b1136
        return block_1136(state, tracer, fn_state);
    }
    fn block_1136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1136_0: read-var gs#406910:u8
        let s_1136_0: bool = fn_state.gs_406910;
        // N s_1136_1: branch s_1136_0 b1138 b1137
        if s_1136_0 {
            return block_1138(state, tracer, fn_state);
        } else {
            return block_1137(state, tracer, fn_state);
        };
    }
    fn block_1137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1137_0: read-var u#33008:u8
        let s_1137_0: u8 = fn_state.u_33008;
        // D s_1137_1: read-var u#33009:u8
        let s_1137_1: bool = fn_state.u_33009;
        // D s_1137_2: read-var u#33010:u8
        let s_1137_2: bool = fn_state.u_33010;
        // D s_1137_3: read-var u#33011:u8
        let s_1137_3: bool = fn_state.u_33011;
        // D s_1137_4: read-var u#33012:u8
        let s_1137_4: u8 = fn_state.u_33012;
        // D s_1137_5: read-var u#33013:u8
        let s_1137_5: u8 = fn_state.u_33013;
        // D s_1137_6: read-var u#33014:u8
        let s_1137_6: u8 = fn_state.u_33014;
        // D s_1137_7: call decode_aarch32_instrs_STRH_r_A1enc_A_txt(s_1137_0, s_1137_1, s_1137_2, s_1137_3, s_1137_4, s_1137_5, s_1137_6)
        let s_1137_7: () = decode_aarch32_instrs_STRH_r_A1enc_A_txt(
            state,
            tracer,
            s_1137_0,
            s_1137_1,
            s_1137_2,
            s_1137_3,
            s_1137_4,
            s_1137_5,
            s_1137_6,
        );
        // N s_1137_8: return
        return;
    }
    fn block_1138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1138_0: panic
        panic!("{:?}", ());
        // N s_1138_1: return
        return;
    }
    fn block_1139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1139_0: const #1u : u8
        let s_1139_0: bool = true;
        // D s_1139_1: write-var gs#406910 <= s_1139_0
        fn_state.gs_406910 = s_1139_0;
        // N s_1139_2: jump b1136
        return block_1136(state, tracer, fn_state);
    }
    fn block_1140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1140_0: const #1u : u8
        let s_1140_0: bool = true;
        // D s_1140_1: write-var gs#406907 <= s_1140_0
        fn_state.gs_406907 = s_1140_0;
        // N s_1140_2: jump b1134
        return block_1134(state, tracer, fn_state);
    }
    fn block_1141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1141_0: const #1u : u8
        let s_1141_0: bool = true;
        // D s_1141_1: write-var gs#406904 <= s_1141_0
        fn_state.gs_406904 = s_1141_0;
        // N s_1141_2: jump b1132
        return block_1132(state, tracer, fn_state);
    }
    fn block_1142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1142_0: read-var merge#var.1:struct
        let s_1142_0: u32 = fn_state.merge_var._1;
        // D s_1142_1: write-var u#33016 <= s_1142_0
        fn_state.u_33016 = s_1142_0;
        // C s_1142_2: const #24s : i
        let s_1142_2: i128 = 24;
        // D s_1142_3: read-var u#33016:u32
        let s_1142_3: u32 = fn_state.u_33016;
        // D s_1142_4: cast zx s_1142_3 -> bv
        let s_1142_4: Bits = Bits::new(s_1142_3 as u128, 32u16);
        // C s_1142_5: const #1s : i64
        let s_1142_5: i64 = 1;
        // C s_1142_6: cast zx s_1142_5 -> i
        let s_1142_6: i128 = (i128::try_from(s_1142_5).unwrap());
        // C s_1142_7: const #3s : i
        let s_1142_7: i128 = 3;
        // C s_1142_8: add s_1142_7 s_1142_6
        let s_1142_8: i128 = (s_1142_7 + s_1142_6);
        // D s_1142_9: bit-extract s_1142_4 s_1142_2 s_1142_8
        let s_1142_9: Bits = (Bits::new(
            ((s_1142_4) >> (s_1142_2)).value(),
            u16::try_from(s_1142_8).unwrap(),
        ));
        // D s_1142_10: cast reint s_1142_9 -> u8
        let s_1142_10: u8 = (s_1142_9.value() as u8);
        // D s_1142_11: cast zx s_1142_10 -> bv
        let s_1142_11: Bits = Bits::new(s_1142_10 as u128, 4u16);
        // C s_1142_12: const #0u : u8
        let s_1142_12: u8 = 0;
        // C s_1142_13: cast zx s_1142_12 -> bv
        let s_1142_13: Bits = Bits::new(s_1142_12 as u128, 4u16);
        // D s_1142_14: cmp-eq s_1142_11 s_1142_13
        let s_1142_14: bool = ((s_1142_11) == (s_1142_13));
        // N s_1142_15: branch s_1142_14 b2329 b1143
        if s_1142_14 {
            return block_2329(state, tracer, fn_state);
        } else {
            return block_1143(state, tracer, fn_state);
        };
    }
    fn block_1143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1143_0: const #0u : u8
        let s_1143_0: bool = false;
        // D s_1143_1: write-var gs#406919 <= s_1143_0
        fn_state.gs_406919 = s_1143_0;
        // N s_1143_2: jump b1144
        return block_1144(state, tracer, fn_state);
    }
    fn block_1144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1144_0: read-var gs#406919:u8
        let s_1144_0: bool = fn_state.gs_406919;
        // N s_1144_1: branch s_1144_0 b2325 b1145
        if s_1144_0 {
            return block_2325(state, tracer, fn_state);
        } else {
            return block_1145(state, tracer, fn_state);
        };
    }
    fn block_1145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1145_0: const #0u : u8
        let s_1145_0: bool = false;
        // D s_1145_1: write-var gs#406924 <= s_1145_0
        fn_state.gs_406924 = s_1145_0;
        // N s_1145_2: jump b1146
        return block_1146(state, tracer, fn_state);
    }
    fn block_1146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1146_0: read-var gs#406924:u8
        let s_1146_0: bool = fn_state.gs_406924;
        // D s_1146_1: not s_1146_0
        let s_1146_1: bool = !s_1146_0;
        // N s_1146_2: branch s_1146_1 b1148 b1147
        if s_1146_1 {
            return block_1148(state, tracer, fn_state);
        } else {
            return block_1147(state, tracer, fn_state);
        };
    }
    fn block_1147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1147_0: const #3221s : i
        let s_1147_0: i128 = 3221;
        // C s_1147_1: const #14696u : u32
        let s_1147_1: u32 = 14696;
        // N s_1147_2: write-reg s_1147_1 <= s_1147_0
        let s_1147_2: () = {
            state.write_register::<i128>(s_1147_1 as isize, s_1147_0);
            tracer.write_register(s_1147_1 as isize, s_1147_0);
        };
        // C s_1147_3: const #28s : i
        let s_1147_3: i128 = 28;
        // C s_1147_4: const #4s : i
        let s_1147_4: i128 = 4;
        // D s_1147_5: read-var u#33016:u32
        let s_1147_5: u32 = fn_state.u_33016;
        // D s_1147_6: cast zx s_1147_5 -> bv
        let s_1147_6: Bits = Bits::new(s_1147_5 as u128, 32u16);
        // D s_1147_7: bit-extract s_1147_6 s_1147_3 s_1147_4
        let s_1147_7: Bits = (Bits::new(
            ((s_1147_6) >> (s_1147_3)).value(),
            u16::try_from(s_1147_4).unwrap(),
        ));
        // D s_1147_8: cast reint s_1147_7 -> u8
        let s_1147_8: u8 = (s_1147_7.value() as u8);
        // C s_1147_9: const #23s : i
        let s_1147_9: i128 = 23;
        // C s_1147_10: const #1s : i
        let s_1147_10: i128 = 1;
        // D s_1147_11: read-var u#33016:u32
        let s_1147_11: u32 = fn_state.u_33016;
        // D s_1147_12: cast zx s_1147_11 -> bv
        let s_1147_12: Bits = Bits::new(s_1147_11 as u128, 32u16);
        // D s_1147_13: bit-extract s_1147_12 s_1147_9 s_1147_10
        let s_1147_13: Bits = (Bits::new(
            ((s_1147_12) >> (s_1147_9)).value(),
            u16::try_from(s_1147_10).unwrap(),
        ));
        // D s_1147_14: cast reint s_1147_13 -> u8
        let s_1147_14: bool = ((s_1147_13.value()) != 0);
        // C s_1147_15: const #16s : i
        let s_1147_15: i128 = 16;
        // C s_1147_16: const #4s : i
        let s_1147_16: i128 = 4;
        // D s_1147_17: read-var u#33016:u32
        let s_1147_17: u32 = fn_state.u_33016;
        // D s_1147_18: cast zx s_1147_17 -> bv
        let s_1147_18: Bits = Bits::new(s_1147_17 as u128, 32u16);
        // D s_1147_19: bit-extract s_1147_18 s_1147_15 s_1147_16
        let s_1147_19: Bits = (Bits::new(
            ((s_1147_18) >> (s_1147_15)).value(),
            u16::try_from(s_1147_16).unwrap(),
        ));
        // D s_1147_20: cast reint s_1147_19 -> u8
        let s_1147_20: u8 = (s_1147_19.value() as u8);
        // C s_1147_21: const #12s : i
        let s_1147_21: i128 = 12;
        // C s_1147_22: const #4s : i
        let s_1147_22: i128 = 4;
        // D s_1147_23: read-var u#33016:u32
        let s_1147_23: u32 = fn_state.u_33016;
        // D s_1147_24: cast zx s_1147_23 -> bv
        let s_1147_24: Bits = Bits::new(s_1147_23 as u128, 32u16);
        // D s_1147_25: bit-extract s_1147_24 s_1147_21 s_1147_22
        let s_1147_25: Bits = (Bits::new(
            ((s_1147_24) >> (s_1147_21)).value(),
            u16::try_from(s_1147_22).unwrap(),
        ));
        // D s_1147_26: cast reint s_1147_25 -> u8
        let s_1147_26: u8 = (s_1147_25.value() as u8);
        // C s_1147_27: const #8s : i
        let s_1147_27: i128 = 8;
        // C s_1147_28: const #4s : i
        let s_1147_28: i128 = 4;
        // D s_1147_29: read-var u#33016:u32
        let s_1147_29: u32 = fn_state.u_33016;
        // D s_1147_30: cast zx s_1147_29 -> bv
        let s_1147_30: Bits = Bits::new(s_1147_29 as u128, 32u16);
        // D s_1147_31: bit-extract s_1147_30 s_1147_27 s_1147_28
        let s_1147_31: Bits = (Bits::new(
            ((s_1147_30) >> (s_1147_27)).value(),
            u16::try_from(s_1147_28).unwrap(),
        ));
        // D s_1147_32: cast reint s_1147_31 -> u8
        let s_1147_32: u8 = (s_1147_31.value() as u8);
        // C s_1147_33: const #0s : i
        let s_1147_33: i128 = 0;
        // C s_1147_34: const #4s : i
        let s_1147_34: i128 = 4;
        // D s_1147_35: read-var u#33016:u32
        let s_1147_35: u32 = fn_state.u_33016;
        // D s_1147_36: cast zx s_1147_35 -> bv
        let s_1147_36: Bits = Bits::new(s_1147_35 as u128, 32u16);
        // D s_1147_37: bit-extract s_1147_36 s_1147_33 s_1147_34
        let s_1147_37: Bits = (Bits::new(
            ((s_1147_36) >> (s_1147_33)).value(),
            u16::try_from(s_1147_34).unwrap(),
        ));
        // D s_1147_38: cast reint s_1147_37 -> u8
        let s_1147_38: u8 = (s_1147_37.value() as u8);
        // D s_1147_39: call decode_aarch32_instrs_STRHT_A1enc_A_txt(s_1147_8, s_1147_14, s_1147_20, s_1147_26, s_1147_32, s_1147_38)
        let s_1147_39: () = decode_aarch32_instrs_STRHT_A1enc_A_txt(
            state,
            tracer,
            s_1147_8,
            s_1147_14,
            s_1147_20,
            s_1147_26,
            s_1147_32,
            s_1147_38,
        );
        // N s_1147_40: return
        return;
    }
    fn block_1148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1148_0: read-var merge#var.1:struct
        let s_1148_0: u32 = fn_state.merge_var._1;
        // D s_1148_1: write-var u#33024 <= s_1148_0
        fn_state.u_33024 = s_1148_0;
        // C s_1148_2: const #24s : i
        let s_1148_2: i128 = 24;
        // D s_1148_3: read-var u#33024:u32
        let s_1148_3: u32 = fn_state.u_33024;
        // D s_1148_4: cast zx s_1148_3 -> bv
        let s_1148_4: Bits = Bits::new(s_1148_3 as u128, 32u16);
        // C s_1148_5: const #1s : i64
        let s_1148_5: i64 = 1;
        // C s_1148_6: cast zx s_1148_5 -> i
        let s_1148_6: i128 = (i128::try_from(s_1148_5).unwrap());
        // C s_1148_7: const #3s : i
        let s_1148_7: i128 = 3;
        // C s_1148_8: add s_1148_7 s_1148_6
        let s_1148_8: i128 = (s_1148_7 + s_1148_6);
        // D s_1148_9: bit-extract s_1148_4 s_1148_2 s_1148_8
        let s_1148_9: Bits = (Bits::new(
            ((s_1148_4) >> (s_1148_2)).value(),
            u16::try_from(s_1148_8).unwrap(),
        ));
        // D s_1148_10: cast reint s_1148_9 -> u8
        let s_1148_10: u8 = (s_1148_9.value() as u8);
        // D s_1148_11: cast zx s_1148_10 -> bv
        let s_1148_11: Bits = Bits::new(s_1148_10 as u128, 4u16);
        // C s_1148_12: const #0u : u8
        let s_1148_12: u8 = 0;
        // C s_1148_13: cast zx s_1148_12 -> bv
        let s_1148_13: Bits = Bits::new(s_1148_12 as u128, 4u16);
        // D s_1148_14: cmp-eq s_1148_11 s_1148_13
        let s_1148_14: bool = ((s_1148_11) == (s_1148_13));
        // N s_1148_15: branch s_1148_14 b2321 b1149
        if s_1148_14 {
            return block_2321(state, tracer, fn_state);
        } else {
            return block_1149(state, tracer, fn_state);
        };
    }
    fn block_1149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1149_0: const #0u : u8
        let s_1149_0: bool = false;
        // D s_1149_1: write-var gs#406947 <= s_1149_0
        fn_state.gs_406947 = s_1149_0;
        // N s_1149_2: jump b1150
        return block_1150(state, tracer, fn_state);
    }
    fn block_1150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1150_0: read-var gs#406947:u8
        let s_1150_0: bool = fn_state.gs_406947;
        // N s_1150_1: branch s_1150_0 b2317 b1151
        if s_1150_0 {
            return block_2317(state, tracer, fn_state);
        } else {
            return block_1151(state, tracer, fn_state);
        };
    }
    fn block_1151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1151_0: const #0u : u8
        let s_1151_0: bool = false;
        // D s_1151_1: write-var gs#406952 <= s_1151_0
        fn_state.gs_406952 = s_1151_0;
        // N s_1151_2: jump b1152
        return block_1152(state, tracer, fn_state);
    }
    fn block_1152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1152_0: read-var gs#406952:u8
        let s_1152_0: bool = fn_state.gs_406952;
        // D s_1152_1: not s_1152_0
        let s_1152_1: bool = !s_1152_0;
        // N s_1152_2: branch s_1152_1 b1165 b1153
        if s_1152_1 {
            return block_1165(state, tracer, fn_state);
        } else {
            return block_1153(state, tracer, fn_state);
        };
    }
    fn block_1153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1153_0: const #3222s : i
        let s_1153_0: i128 = 3222;
        // C s_1153_1: const #14696u : u32
        let s_1153_1: u32 = 14696;
        // N s_1153_2: write-reg s_1153_1 <= s_1153_0
        let s_1153_2: () = {
            state.write_register::<i128>(s_1153_1 as isize, s_1153_0);
            tracer.write_register(s_1153_1 as isize, s_1153_0);
        };
        // C s_1153_3: const #28s : i
        let s_1153_3: i128 = 28;
        // C s_1153_4: const #4s : i
        let s_1153_4: i128 = 4;
        // D s_1153_5: read-var u#33024:u32
        let s_1153_5: u32 = fn_state.u_33024;
        // D s_1153_6: cast zx s_1153_5 -> bv
        let s_1153_6: Bits = Bits::new(s_1153_5 as u128, 32u16);
        // D s_1153_7: bit-extract s_1153_6 s_1153_3 s_1153_4
        let s_1153_7: Bits = (Bits::new(
            ((s_1153_6) >> (s_1153_3)).value(),
            u16::try_from(s_1153_4).unwrap(),
        ));
        // D s_1153_8: cast reint s_1153_7 -> u8
        let s_1153_8: u8 = (s_1153_7.value() as u8);
        // D s_1153_9: write-var u#33025 <= s_1153_8
        fn_state.u_33025 = s_1153_8;
        // C s_1153_10: const #23s : i
        let s_1153_10: i128 = 23;
        // C s_1153_11: const #1s : i
        let s_1153_11: i128 = 1;
        // D s_1153_12: read-var u#33024:u32
        let s_1153_12: u32 = fn_state.u_33024;
        // D s_1153_13: cast zx s_1153_12 -> bv
        let s_1153_13: Bits = Bits::new(s_1153_12 as u128, 32u16);
        // D s_1153_14: bit-extract s_1153_13 s_1153_10 s_1153_11
        let s_1153_14: Bits = (Bits::new(
            ((s_1153_13) >> (s_1153_10)).value(),
            u16::try_from(s_1153_11).unwrap(),
        ));
        // D s_1153_15: cast reint s_1153_14 -> u8
        let s_1153_15: bool = ((s_1153_14.value()) != 0);
        // D s_1153_16: write-var u#33026 <= s_1153_15
        fn_state.u_33026 = s_1153_15;
        // C s_1153_17: const #16s : i
        let s_1153_17: i128 = 16;
        // C s_1153_18: const #4s : i
        let s_1153_18: i128 = 4;
        // D s_1153_19: read-var u#33024:u32
        let s_1153_19: u32 = fn_state.u_33024;
        // D s_1153_20: cast zx s_1153_19 -> bv
        let s_1153_20: Bits = Bits::new(s_1153_19 as u128, 32u16);
        // D s_1153_21: bit-extract s_1153_20 s_1153_17 s_1153_18
        let s_1153_21: Bits = (Bits::new(
            ((s_1153_20) >> (s_1153_17)).value(),
            u16::try_from(s_1153_18).unwrap(),
        ));
        // D s_1153_22: cast reint s_1153_21 -> u8
        let s_1153_22: u8 = (s_1153_21.value() as u8);
        // D s_1153_23: write-var u#33027 <= s_1153_22
        fn_state.u_33027 = s_1153_22;
        // C s_1153_24: const #12s : i
        let s_1153_24: i128 = 12;
        // C s_1153_25: const #4s : i
        let s_1153_25: i128 = 4;
        // D s_1153_26: read-var u#33024:u32
        let s_1153_26: u32 = fn_state.u_33024;
        // D s_1153_27: cast zx s_1153_26 -> bv
        let s_1153_27: Bits = Bits::new(s_1153_26 as u128, 32u16);
        // D s_1153_28: bit-extract s_1153_27 s_1153_24 s_1153_25
        let s_1153_28: Bits = (Bits::new(
            ((s_1153_27) >> (s_1153_24)).value(),
            u16::try_from(s_1153_25).unwrap(),
        ));
        // D s_1153_29: cast reint s_1153_28 -> u8
        let s_1153_29: u8 = (s_1153_28.value() as u8);
        // D s_1153_30: write-var u#33028 <= s_1153_29
        fn_state.u_33028 = s_1153_29;
        // C s_1153_31: const #0s : i
        let s_1153_31: i128 = 0;
        // C s_1153_32: const #4s : i
        let s_1153_32: i128 = 4;
        // D s_1153_33: read-var u#33024:u32
        let s_1153_33: u32 = fn_state.u_33024;
        // D s_1153_34: cast zx s_1153_33 -> bv
        let s_1153_34: Bits = Bits::new(s_1153_33 as u128, 32u16);
        // D s_1153_35: bit-extract s_1153_34 s_1153_31 s_1153_32
        let s_1153_35: Bits = (Bits::new(
            ((s_1153_34) >> (s_1153_31)).value(),
            u16::try_from(s_1153_32).unwrap(),
        ));
        // D s_1153_36: cast reint s_1153_35 -> u8
        let s_1153_36: u8 = (s_1153_35.value() as u8);
        // D s_1153_37: write-var u#33029 <= s_1153_36
        fn_state.u_33029 = s_1153_36;
        // C s_1153_38: const #8s : i
        let s_1153_38: i128 = 8;
        // D s_1153_39: read-var u#33024:u32
        let s_1153_39: u32 = fn_state.u_33024;
        // D s_1153_40: cast zx s_1153_39 -> bv
        let s_1153_40: Bits = Bits::new(s_1153_39 as u128, 32u16);
        // C s_1153_41: const #1u : u64
        let s_1153_41: u64 = 1;
        // D s_1153_42: bit-extract s_1153_40 s_1153_38 s_1153_41
        let s_1153_42: Bits = (Bits::new(
            ((s_1153_40) >> (s_1153_38)).value(),
            u16::try_from(s_1153_41).unwrap(),
        ));
        // D s_1153_43: cast reint s_1153_42 -> u8
        let s_1153_43: bool = ((s_1153_42.value()) != 0);
        // C s_1153_44: const #0s : i
        let s_1153_44: i128 = 0;
        // C s_1153_45: const #0u : u64
        let s_1153_45: u64 = 0;
        // D s_1153_46: cast zx s_1153_43 -> u64
        let s_1153_46: u64 = (s_1153_43 as u64);
        // C s_1153_47: const #1u : u64
        let s_1153_47: u64 = 1;
        // D s_1153_48: and s_1153_46 s_1153_47
        let s_1153_48: u64 = ((s_1153_46) & (s_1153_47));
        // D s_1153_49: cmp-eq s_1153_48 s_1153_47
        let s_1153_49: bool = ((s_1153_48) == (s_1153_47));
        // D s_1153_50: lsl s_1153_46 s_1153_44
        let s_1153_50: u64 = s_1153_46 << s_1153_44;
        // D s_1153_51: or s_1153_45 s_1153_50
        let s_1153_51: u64 = ((s_1153_45) | (s_1153_50));
        // D s_1153_52: cmpl s_1153_50
        let s_1153_52: u64 = !s_1153_50;
        // D s_1153_53: and s_1153_45 s_1153_52
        let s_1153_53: u64 = ((s_1153_45) & (s_1153_52));
        // D s_1153_54: select s_1153_49 s_1153_51 s_1153_53
        let s_1153_54: u64 = if s_1153_49 { s_1153_51 } else { s_1153_53 };
        // D s_1153_55: cast trunc s_1153_54 -> u8
        let s_1153_55: bool = ((s_1153_54) != 0);
        // D s_1153_56: cast zx s_1153_55 -> bv
        let s_1153_56: Bits = Bits::new(s_1153_55 as u128, 1u16);
        // C s_1153_57: const #0u : u8
        let s_1153_57: bool = false;
        // C s_1153_58: cast zx s_1153_57 -> bv
        let s_1153_58: Bits = Bits::new(s_1153_57 as u128, 1u16);
        // D s_1153_59: cmp-ne s_1153_56 s_1153_58
        let s_1153_59: bool = ((s_1153_56) != (s_1153_58));
        // N s_1153_60: branch s_1153_59 b1164 b1154
        if s_1153_59 {
            return block_1164(state, tracer, fn_state);
        } else {
            return block_1154(state, tracer, fn_state);
        };
    }
    fn block_1154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1154_0: const #9s : i
        let s_1154_0: i128 = 9;
        // D s_1154_1: read-var u#33024:u32
        let s_1154_1: u32 = fn_state.u_33024;
        // D s_1154_2: cast zx s_1154_1 -> bv
        let s_1154_2: Bits = Bits::new(s_1154_1 as u128, 32u16);
        // C s_1154_3: const #1u : u64
        let s_1154_3: u64 = 1;
        // D s_1154_4: bit-extract s_1154_2 s_1154_0 s_1154_3
        let s_1154_4: Bits = (Bits::new(
            ((s_1154_2) >> (s_1154_0)).value(),
            u16::try_from(s_1154_3).unwrap(),
        ));
        // D s_1154_5: cast reint s_1154_4 -> u8
        let s_1154_5: bool = ((s_1154_4.value()) != 0);
        // C s_1154_6: const #0s : i
        let s_1154_6: i128 = 0;
        // C s_1154_7: const #0u : u64
        let s_1154_7: u64 = 0;
        // D s_1154_8: cast zx s_1154_5 -> u64
        let s_1154_8: u64 = (s_1154_5 as u64);
        // C s_1154_9: const #1u : u64
        let s_1154_9: u64 = 1;
        // D s_1154_10: and s_1154_8 s_1154_9
        let s_1154_10: u64 = ((s_1154_8) & (s_1154_9));
        // D s_1154_11: cmp-eq s_1154_10 s_1154_9
        let s_1154_11: bool = ((s_1154_10) == (s_1154_9));
        // D s_1154_12: lsl s_1154_8 s_1154_6
        let s_1154_12: u64 = s_1154_8 << s_1154_6;
        // D s_1154_13: or s_1154_7 s_1154_12
        let s_1154_13: u64 = ((s_1154_7) | (s_1154_12));
        // D s_1154_14: cmpl s_1154_12
        let s_1154_14: u64 = !s_1154_12;
        // D s_1154_15: and s_1154_7 s_1154_14
        let s_1154_15: u64 = ((s_1154_7) & (s_1154_14));
        // D s_1154_16: select s_1154_11 s_1154_13 s_1154_15
        let s_1154_16: u64 = if s_1154_11 { s_1154_13 } else { s_1154_15 };
        // D s_1154_17: cast trunc s_1154_16 -> u8
        let s_1154_17: bool = ((s_1154_16) != 0);
        // D s_1154_18: cast zx s_1154_17 -> bv
        let s_1154_18: Bits = Bits::new(s_1154_17 as u128, 1u16);
        // C s_1154_19: const #0u : u8
        let s_1154_19: bool = false;
        // C s_1154_20: cast zx s_1154_19 -> bv
        let s_1154_20: Bits = Bits::new(s_1154_19 as u128, 1u16);
        // D s_1154_21: cmp-ne s_1154_18 s_1154_20
        let s_1154_21: bool = ((s_1154_18) != (s_1154_20));
        // D s_1154_22: write-var gs#406969 <= s_1154_21
        fn_state.gs_406969 = s_1154_21;
        // N s_1154_23: jump b1155
        return block_1155(state, tracer, fn_state);
    }
    fn block_1155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1155_0: read-var gs#406969:u8
        let s_1155_0: bool = fn_state.gs_406969;
        // N s_1155_1: branch s_1155_0 b1163 b1156
        if s_1155_0 {
            return block_1163(state, tracer, fn_state);
        } else {
            return block_1156(state, tracer, fn_state);
        };
    }
    fn block_1156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1156_0: const #10s : i
        let s_1156_0: i128 = 10;
        // D s_1156_1: read-var u#33024:u32
        let s_1156_1: u32 = fn_state.u_33024;
        // D s_1156_2: cast zx s_1156_1 -> bv
        let s_1156_2: Bits = Bits::new(s_1156_1 as u128, 32u16);
        // C s_1156_3: const #1u : u64
        let s_1156_3: u64 = 1;
        // D s_1156_4: bit-extract s_1156_2 s_1156_0 s_1156_3
        let s_1156_4: Bits = (Bits::new(
            ((s_1156_2) >> (s_1156_0)).value(),
            u16::try_from(s_1156_3).unwrap(),
        ));
        // D s_1156_5: cast reint s_1156_4 -> u8
        let s_1156_5: bool = ((s_1156_4.value()) != 0);
        // C s_1156_6: const #0s : i
        let s_1156_6: i128 = 0;
        // C s_1156_7: const #0u : u64
        let s_1156_7: u64 = 0;
        // D s_1156_8: cast zx s_1156_5 -> u64
        let s_1156_8: u64 = (s_1156_5 as u64);
        // C s_1156_9: const #1u : u64
        let s_1156_9: u64 = 1;
        // D s_1156_10: and s_1156_8 s_1156_9
        let s_1156_10: u64 = ((s_1156_8) & (s_1156_9));
        // D s_1156_11: cmp-eq s_1156_10 s_1156_9
        let s_1156_11: bool = ((s_1156_10) == (s_1156_9));
        // D s_1156_12: lsl s_1156_8 s_1156_6
        let s_1156_12: u64 = s_1156_8 << s_1156_6;
        // D s_1156_13: or s_1156_7 s_1156_12
        let s_1156_13: u64 = ((s_1156_7) | (s_1156_12));
        // D s_1156_14: cmpl s_1156_12
        let s_1156_14: u64 = !s_1156_12;
        // D s_1156_15: and s_1156_7 s_1156_14
        let s_1156_15: u64 = ((s_1156_7) & (s_1156_14));
        // D s_1156_16: select s_1156_11 s_1156_13 s_1156_15
        let s_1156_16: u64 = if s_1156_11 { s_1156_13 } else { s_1156_15 };
        // D s_1156_17: cast trunc s_1156_16 -> u8
        let s_1156_17: bool = ((s_1156_16) != 0);
        // D s_1156_18: cast zx s_1156_17 -> bv
        let s_1156_18: Bits = Bits::new(s_1156_17 as u128, 1u16);
        // C s_1156_19: const #0u : u8
        let s_1156_19: bool = false;
        // C s_1156_20: cast zx s_1156_19 -> bv
        let s_1156_20: Bits = Bits::new(s_1156_19 as u128, 1u16);
        // D s_1156_21: cmp-ne s_1156_18 s_1156_20
        let s_1156_21: bool = ((s_1156_18) != (s_1156_20));
        // D s_1156_22: write-var gs#406972 <= s_1156_21
        fn_state.gs_406972 = s_1156_21;
        // N s_1156_23: jump b1157
        return block_1157(state, tracer, fn_state);
    }
    fn block_1157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1157_0: read-var gs#406972:u8
        let s_1157_0: bool = fn_state.gs_406972;
        // N s_1157_1: branch s_1157_0 b1162 b1158
        if s_1157_0 {
            return block_1162(state, tracer, fn_state);
        } else {
            return block_1158(state, tracer, fn_state);
        };
    }
    fn block_1158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1158_0: const #11s : i
        let s_1158_0: i128 = 11;
        // D s_1158_1: read-var u#33024:u32
        let s_1158_1: u32 = fn_state.u_33024;
        // D s_1158_2: cast zx s_1158_1 -> bv
        let s_1158_2: Bits = Bits::new(s_1158_1 as u128, 32u16);
        // C s_1158_3: const #1u : u64
        let s_1158_3: u64 = 1;
        // D s_1158_4: bit-extract s_1158_2 s_1158_0 s_1158_3
        let s_1158_4: Bits = (Bits::new(
            ((s_1158_2) >> (s_1158_0)).value(),
            u16::try_from(s_1158_3).unwrap(),
        ));
        // D s_1158_5: cast reint s_1158_4 -> u8
        let s_1158_5: bool = ((s_1158_4.value()) != 0);
        // C s_1158_6: const #0s : i
        let s_1158_6: i128 = 0;
        // C s_1158_7: const #0u : u64
        let s_1158_7: u64 = 0;
        // D s_1158_8: cast zx s_1158_5 -> u64
        let s_1158_8: u64 = (s_1158_5 as u64);
        // C s_1158_9: const #1u : u64
        let s_1158_9: u64 = 1;
        // D s_1158_10: and s_1158_8 s_1158_9
        let s_1158_10: u64 = ((s_1158_8) & (s_1158_9));
        // D s_1158_11: cmp-eq s_1158_10 s_1158_9
        let s_1158_11: bool = ((s_1158_10) == (s_1158_9));
        // D s_1158_12: lsl s_1158_8 s_1158_6
        let s_1158_12: u64 = s_1158_8 << s_1158_6;
        // D s_1158_13: or s_1158_7 s_1158_12
        let s_1158_13: u64 = ((s_1158_7) | (s_1158_12));
        // D s_1158_14: cmpl s_1158_12
        let s_1158_14: u64 = !s_1158_12;
        // D s_1158_15: and s_1158_7 s_1158_14
        let s_1158_15: u64 = ((s_1158_7) & (s_1158_14));
        // D s_1158_16: select s_1158_11 s_1158_13 s_1158_15
        let s_1158_16: u64 = if s_1158_11 { s_1158_13 } else { s_1158_15 };
        // D s_1158_17: cast trunc s_1158_16 -> u8
        let s_1158_17: bool = ((s_1158_16) != 0);
        // D s_1158_18: cast zx s_1158_17 -> bv
        let s_1158_18: Bits = Bits::new(s_1158_17 as u128, 1u16);
        // C s_1158_19: const #0u : u8
        let s_1158_19: bool = false;
        // C s_1158_20: cast zx s_1158_19 -> bv
        let s_1158_20: Bits = Bits::new(s_1158_19 as u128, 1u16);
        // D s_1158_21: cmp-ne s_1158_18 s_1158_20
        let s_1158_21: bool = ((s_1158_18) != (s_1158_20));
        // D s_1158_22: write-var gs#406975 <= s_1158_21
        fn_state.gs_406975 = s_1158_21;
        // N s_1158_23: jump b1159
        return block_1159(state, tracer, fn_state);
    }
    fn block_1159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1159_0: read-var gs#406975:u8
        let s_1159_0: bool = fn_state.gs_406975;
        // N s_1159_1: branch s_1159_0 b1161 b1160
        if s_1159_0 {
            return block_1161(state, tracer, fn_state);
        } else {
            return block_1160(state, tracer, fn_state);
        };
    }
    fn block_1160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1160_0: read-var u#33025:u8
        let s_1160_0: u8 = fn_state.u_33025;
        // D s_1160_1: read-var u#33026:u8
        let s_1160_1: bool = fn_state.u_33026;
        // D s_1160_2: read-var u#33027:u8
        let s_1160_2: u8 = fn_state.u_33027;
        // D s_1160_3: read-var u#33028:u8
        let s_1160_3: u8 = fn_state.u_33028;
        // D s_1160_4: read-var u#33029:u8
        let s_1160_4: u8 = fn_state.u_33029;
        // D s_1160_5: call decode_aarch32_instrs_STRHT_A2enc_A_txt(s_1160_0, s_1160_1, s_1160_2, s_1160_3, s_1160_4)
        let s_1160_5: () = decode_aarch32_instrs_STRHT_A2enc_A_txt(
            state,
            tracer,
            s_1160_0,
            s_1160_1,
            s_1160_2,
            s_1160_3,
            s_1160_4,
        );
        // N s_1160_6: return
        return;
    }
    fn block_1161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1161_0: panic
        panic!("{:?}", ());
        // N s_1161_1: return
        return;
    }
    fn block_1162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1162_0: const #1u : u8
        let s_1162_0: bool = true;
        // D s_1162_1: write-var gs#406975 <= s_1162_0
        fn_state.gs_406975 = s_1162_0;
        // N s_1162_2: jump b1159
        return block_1159(state, tracer, fn_state);
    }
    fn block_1163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1163_0: const #1u : u8
        let s_1163_0: bool = true;
        // D s_1163_1: write-var gs#406972 <= s_1163_0
        fn_state.gs_406972 = s_1163_0;
        // N s_1163_2: jump b1157
        return block_1157(state, tracer, fn_state);
    }
    fn block_1164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1164_0: const #1u : u8
        let s_1164_0: bool = true;
        // D s_1164_1: write-var gs#406969 <= s_1164_0
        fn_state.gs_406969 = s_1164_0;
        // N s_1164_2: jump b1155
        return block_1155(state, tracer, fn_state);
    }
    fn block_1165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1165_0: read-var merge#var.1:struct
        let s_1165_0: u32 = fn_state.merge_var._1;
        // D s_1165_1: write-var u#33031 <= s_1165_0
        fn_state.u_33031 = s_1165_0;
        // C s_1165_2: const #21s : i
        let s_1165_2: i128 = 21;
        // D s_1165_3: read-var u#33031:u32
        let s_1165_3: u32 = fn_state.u_33031;
        // D s_1165_4: cast zx s_1165_3 -> bv
        let s_1165_4: Bits = Bits::new(s_1165_3 as u128, 32u16);
        // C s_1165_5: const #1s : i64
        let s_1165_5: i64 = 1;
        // C s_1165_6: cast zx s_1165_5 -> i
        let s_1165_6: i128 = (i128::try_from(s_1165_5).unwrap());
        // C s_1165_7: const #6s : i
        let s_1165_7: i128 = 6;
        // C s_1165_8: add s_1165_7 s_1165_6
        let s_1165_8: i128 = (s_1165_7 + s_1165_6);
        // D s_1165_9: bit-extract s_1165_4 s_1165_2 s_1165_8
        let s_1165_9: Bits = (Bits::new(
            ((s_1165_4) >> (s_1165_2)).value(),
            u16::try_from(s_1165_8).unwrap(),
        ));
        // D s_1165_10: cast reint s_1165_9 -> u8
        let s_1165_10: u8 = (s_1165_9.value() as u8);
        // D s_1165_11: cast zx s_1165_10 -> bv
        let s_1165_11: Bits = Bits::new(s_1165_10 as u128, 7u16);
        // C s_1165_12: const #18u : u8
        let s_1165_12: u8 = 18;
        // C s_1165_13: cast zx s_1165_12 -> bv
        let s_1165_13: Bits = Bits::new(s_1165_12 as u128, 7u16);
        // D s_1165_14: cmp-eq s_1165_11 s_1165_13
        let s_1165_14: bool = ((s_1165_11) == (s_1165_13));
        // N s_1165_15: branch s_1165_14 b2313 b1166
        if s_1165_14 {
            return block_2313(state, tracer, fn_state);
        } else {
            return block_1166(state, tracer, fn_state);
        };
    }
    fn block_1166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1166_0: const #0u : u8
        let s_1166_0: bool = false;
        // D s_1166_1: write-var gs#406983 <= s_1166_0
        fn_state.gs_406983 = s_1166_0;
        // N s_1166_2: jump b1167
        return block_1167(state, tracer, fn_state);
    }
    fn block_1167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1167_0: read-var gs#406983:u8
        let s_1167_0: bool = fn_state.gs_406983;
        // D s_1167_1: not s_1167_0
        let s_1167_1: bool = !s_1167_0;
        // N s_1167_2: branch s_1167_1 b1169 b1168
        if s_1167_1 {
            return block_1169(state, tracer, fn_state);
        } else {
            return block_1168(state, tracer, fn_state);
        };
    }
    fn block_1168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1168_0: const #3235s : i
        let s_1168_0: i128 = 3235;
        // C s_1168_1: const #14696u : u32
        let s_1168_1: u32 = 14696;
        // N s_1168_2: write-reg s_1168_1 <= s_1168_0
        let s_1168_2: () = {
            state.write_register::<i128>(s_1168_1 as isize, s_1168_0);
            tracer.write_register(s_1168_1 as isize, s_1168_0);
        };
        // C s_1168_3: const #28s : i
        let s_1168_3: i128 = 28;
        // C s_1168_4: const #4s : i
        let s_1168_4: i128 = 4;
        // D s_1168_5: read-var u#33031:u32
        let s_1168_5: u32 = fn_state.u_33031;
        // D s_1168_6: cast zx s_1168_5 -> bv
        let s_1168_6: Bits = Bits::new(s_1168_5 as u128, 32u16);
        // D s_1168_7: bit-extract s_1168_6 s_1168_3 s_1168_4
        let s_1168_7: Bits = (Bits::new(
            ((s_1168_6) >> (s_1168_3)).value(),
            u16::try_from(s_1168_4).unwrap(),
        ));
        // D s_1168_8: cast reint s_1168_7 -> u8
        let s_1168_8: u8 = (s_1168_7.value() as u8);
        // C s_1168_9: const #20s : i
        let s_1168_9: i128 = 20;
        // C s_1168_10: const #1s : i
        let s_1168_10: i128 = 1;
        // D s_1168_11: read-var u#33031:u32
        let s_1168_11: u32 = fn_state.u_33031;
        // D s_1168_12: cast zx s_1168_11 -> bv
        let s_1168_12: Bits = Bits::new(s_1168_11 as u128, 32u16);
        // D s_1168_13: bit-extract s_1168_12 s_1168_9 s_1168_10
        let s_1168_13: Bits = (Bits::new(
            ((s_1168_12) >> (s_1168_9)).value(),
            u16::try_from(s_1168_10).unwrap(),
        ));
        // D s_1168_14: cast reint s_1168_13 -> u8
        let s_1168_14: bool = ((s_1168_13.value()) != 0);
        // C s_1168_15: const #16s : i
        let s_1168_15: i128 = 16;
        // C s_1168_16: const #4s : i
        let s_1168_16: i128 = 4;
        // D s_1168_17: read-var u#33031:u32
        let s_1168_17: u32 = fn_state.u_33031;
        // D s_1168_18: cast zx s_1168_17 -> bv
        let s_1168_18: Bits = Bits::new(s_1168_17 as u128, 32u16);
        // D s_1168_19: bit-extract s_1168_18 s_1168_15 s_1168_16
        let s_1168_19: Bits = (Bits::new(
            ((s_1168_18) >> (s_1168_15)).value(),
            u16::try_from(s_1168_16).unwrap(),
        ));
        // D s_1168_20: cast reint s_1168_19 -> u8
        let s_1168_20: u8 = (s_1168_19.value() as u8);
        // C s_1168_21: const #12s : i
        let s_1168_21: i128 = 12;
        // C s_1168_22: const #4s : i
        let s_1168_22: i128 = 4;
        // D s_1168_23: read-var u#33031:u32
        let s_1168_23: u32 = fn_state.u_33031;
        // D s_1168_24: cast zx s_1168_23 -> bv
        let s_1168_24: Bits = Bits::new(s_1168_23 as u128, 32u16);
        // D s_1168_25: bit-extract s_1168_24 s_1168_21 s_1168_22
        let s_1168_25: Bits = (Bits::new(
            ((s_1168_24) >> (s_1168_21)).value(),
            u16::try_from(s_1168_22).unwrap(),
        ));
        // D s_1168_26: cast reint s_1168_25 -> u8
        let s_1168_26: u8 = (s_1168_25.value() as u8);
        // C s_1168_27: const #0s : i
        let s_1168_27: i128 = 0;
        // C s_1168_28: const #12s : i
        let s_1168_28: i128 = 12;
        // D s_1168_29: read-var u#33031:u32
        let s_1168_29: u32 = fn_state.u_33031;
        // D s_1168_30: cast zx s_1168_29 -> bv
        let s_1168_30: Bits = Bits::new(s_1168_29 as u128, 32u16);
        // D s_1168_31: bit-extract s_1168_30 s_1168_27 s_1168_28
        let s_1168_31: Bits = (Bits::new(
            ((s_1168_30) >> (s_1168_27)).value(),
            u16::try_from(s_1168_28).unwrap(),
        ));
        // D s_1168_32: cast reint s_1168_31 -> u12
        let s_1168_32: u16 = (s_1168_31.value() as u16);
        // D s_1168_33: call decode_aarch32_instrs_SUB_i_A1enc_A_txt(s_1168_8, s_1168_14, s_1168_20, s_1168_26, s_1168_32)
        let s_1168_33: () = decode_aarch32_instrs_SUB_i_A1enc_A_txt(
            state,
            tracer,
            s_1168_8,
            s_1168_14,
            s_1168_20,
            s_1168_26,
            s_1168_32,
        );
        // N s_1168_34: return
        return;
    }
    fn block_1169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1169_0: read-var merge#var.1:struct
        let s_1169_0: u32 = fn_state.merge_var._1;
        // D s_1169_1: write-var u#33038 <= s_1169_0
        fn_state.u_33038 = s_1169_0;
        // C s_1169_2: const #21s : i
        let s_1169_2: i128 = 21;
        // D s_1169_3: read-var u#33038:u32
        let s_1169_3: u32 = fn_state.u_33038;
        // D s_1169_4: cast zx s_1169_3 -> bv
        let s_1169_4: Bits = Bits::new(s_1169_3 as u128, 32u16);
        // C s_1169_5: const #1s : i64
        let s_1169_5: i64 = 1;
        // C s_1169_6: cast zx s_1169_5 -> i
        let s_1169_6: i128 = (i128::try_from(s_1169_5).unwrap());
        // C s_1169_7: const #6s : i
        let s_1169_7: i128 = 6;
        // C s_1169_8: add s_1169_7 s_1169_6
        let s_1169_8: i128 = (s_1169_7 + s_1169_6);
        // D s_1169_9: bit-extract s_1169_4 s_1169_2 s_1169_8
        let s_1169_9: Bits = (Bits::new(
            ((s_1169_4) >> (s_1169_2)).value(),
            u16::try_from(s_1169_8).unwrap(),
        ));
        // D s_1169_10: cast reint s_1169_9 -> u8
        let s_1169_10: u8 = (s_1169_9.value() as u8);
        // D s_1169_11: cast zx s_1169_10 -> bv
        let s_1169_11: Bits = Bits::new(s_1169_10 as u128, 7u16);
        // C s_1169_12: const #2u : u8
        let s_1169_12: u8 = 2;
        // C s_1169_13: cast zx s_1169_12 -> bv
        let s_1169_13: Bits = Bits::new(s_1169_12 as u128, 7u16);
        // D s_1169_14: cmp-eq s_1169_11 s_1169_13
        let s_1169_14: bool = ((s_1169_11) == (s_1169_13));
        // N s_1169_15: branch s_1169_14 b2312 b1170
        if s_1169_14 {
            return block_2312(state, tracer, fn_state);
        } else {
            return block_1170(state, tracer, fn_state);
        };
    }
    fn block_1170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1170_0: const #0u : u8
        let s_1170_0: bool = false;
        // D s_1170_1: write-var gs#407001 <= s_1170_0
        fn_state.gs_407001 = s_1170_0;
        // N s_1170_2: jump b1171
        return block_1171(state, tracer, fn_state);
    }
    fn block_1171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1171_0: read-var gs#407001:u8
        let s_1171_0: bool = fn_state.gs_407001;
        // N s_1171_1: branch s_1171_0 b2308 b1172
        if s_1171_0 {
            return block_2308(state, tracer, fn_state);
        } else {
            return block_1172(state, tracer, fn_state);
        };
    }
    fn block_1172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1172_0: const #0u : u8
        let s_1172_0: bool = false;
        // D s_1172_1: write-var gs#407006 <= s_1172_0
        fn_state.gs_407006 = s_1172_0;
        // N s_1172_2: jump b1173
        return block_1173(state, tracer, fn_state);
    }
    fn block_1173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1173_0: read-var gs#407006:u8
        let s_1173_0: bool = fn_state.gs_407006;
        // D s_1173_1: not s_1173_0
        let s_1173_1: bool = !s_1173_0;
        // N s_1173_2: branch s_1173_1 b1175 b1174
        if s_1173_1 {
            return block_1175(state, tracer, fn_state);
        } else {
            return block_1174(state, tracer, fn_state);
        };
    }
    fn block_1174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1174_0: const #3241s : i
        let s_1174_0: i128 = 3241;
        // C s_1174_1: const #14696u : u32
        let s_1174_1: u32 = 14696;
        // N s_1174_2: write-reg s_1174_1 <= s_1174_0
        let s_1174_2: () = {
            state.write_register::<i128>(s_1174_1 as isize, s_1174_0);
            tracer.write_register(s_1174_1 as isize, s_1174_0);
        };
        // C s_1174_3: const #28s : i
        let s_1174_3: i128 = 28;
        // C s_1174_4: const #4s : i
        let s_1174_4: i128 = 4;
        // D s_1174_5: read-var u#33038:u32
        let s_1174_5: u32 = fn_state.u_33038;
        // D s_1174_6: cast zx s_1174_5 -> bv
        let s_1174_6: Bits = Bits::new(s_1174_5 as u128, 32u16);
        // D s_1174_7: bit-extract s_1174_6 s_1174_3 s_1174_4
        let s_1174_7: Bits = (Bits::new(
            ((s_1174_6) >> (s_1174_3)).value(),
            u16::try_from(s_1174_4).unwrap(),
        ));
        // D s_1174_8: cast reint s_1174_7 -> u8
        let s_1174_8: u8 = (s_1174_7.value() as u8);
        // C s_1174_9: const #20s : i
        let s_1174_9: i128 = 20;
        // C s_1174_10: const #1s : i
        let s_1174_10: i128 = 1;
        // D s_1174_11: read-var u#33038:u32
        let s_1174_11: u32 = fn_state.u_33038;
        // D s_1174_12: cast zx s_1174_11 -> bv
        let s_1174_12: Bits = Bits::new(s_1174_11 as u128, 32u16);
        // D s_1174_13: bit-extract s_1174_12 s_1174_9 s_1174_10
        let s_1174_13: Bits = (Bits::new(
            ((s_1174_12) >> (s_1174_9)).value(),
            u16::try_from(s_1174_10).unwrap(),
        ));
        // D s_1174_14: cast reint s_1174_13 -> u8
        let s_1174_14: bool = ((s_1174_13.value()) != 0);
        // C s_1174_15: const #16s : i
        let s_1174_15: i128 = 16;
        // C s_1174_16: const #4s : i
        let s_1174_16: i128 = 4;
        // D s_1174_17: read-var u#33038:u32
        let s_1174_17: u32 = fn_state.u_33038;
        // D s_1174_18: cast zx s_1174_17 -> bv
        let s_1174_18: Bits = Bits::new(s_1174_17 as u128, 32u16);
        // D s_1174_19: bit-extract s_1174_18 s_1174_15 s_1174_16
        let s_1174_19: Bits = (Bits::new(
            ((s_1174_18) >> (s_1174_15)).value(),
            u16::try_from(s_1174_16).unwrap(),
        ));
        // D s_1174_20: cast reint s_1174_19 -> u8
        let s_1174_20: u8 = (s_1174_19.value() as u8);
        // C s_1174_21: const #12s : i
        let s_1174_21: i128 = 12;
        // C s_1174_22: const #4s : i
        let s_1174_22: i128 = 4;
        // D s_1174_23: read-var u#33038:u32
        let s_1174_23: u32 = fn_state.u_33038;
        // D s_1174_24: cast zx s_1174_23 -> bv
        let s_1174_24: Bits = Bits::new(s_1174_23 as u128, 32u16);
        // D s_1174_25: bit-extract s_1174_24 s_1174_21 s_1174_22
        let s_1174_25: Bits = (Bits::new(
            ((s_1174_24) >> (s_1174_21)).value(),
            u16::try_from(s_1174_22).unwrap(),
        ));
        // D s_1174_26: cast reint s_1174_25 -> u8
        let s_1174_26: u8 = (s_1174_25.value() as u8);
        // C s_1174_27: const #7s : i
        let s_1174_27: i128 = 7;
        // C s_1174_28: const #5s : i
        let s_1174_28: i128 = 5;
        // D s_1174_29: read-var u#33038:u32
        let s_1174_29: u32 = fn_state.u_33038;
        // D s_1174_30: cast zx s_1174_29 -> bv
        let s_1174_30: Bits = Bits::new(s_1174_29 as u128, 32u16);
        // D s_1174_31: bit-extract s_1174_30 s_1174_27 s_1174_28
        let s_1174_31: Bits = (Bits::new(
            ((s_1174_30) >> (s_1174_27)).value(),
            u16::try_from(s_1174_28).unwrap(),
        ));
        // D s_1174_32: cast reint s_1174_31 -> u8
        let s_1174_32: u8 = (s_1174_31.value() as u8);
        // C s_1174_33: const #5s : i
        let s_1174_33: i128 = 5;
        // C s_1174_34: const #2s : i
        let s_1174_34: i128 = 2;
        // D s_1174_35: read-var u#33038:u32
        let s_1174_35: u32 = fn_state.u_33038;
        // D s_1174_36: cast zx s_1174_35 -> bv
        let s_1174_36: Bits = Bits::new(s_1174_35 as u128, 32u16);
        // D s_1174_37: bit-extract s_1174_36 s_1174_33 s_1174_34
        let s_1174_37: Bits = (Bits::new(
            ((s_1174_36) >> (s_1174_33)).value(),
            u16::try_from(s_1174_34).unwrap(),
        ));
        // D s_1174_38: cast reint s_1174_37 -> u8
        let s_1174_38: u8 = (s_1174_37.value() as u8);
        // C s_1174_39: const #0s : i
        let s_1174_39: i128 = 0;
        // C s_1174_40: const #4s : i
        let s_1174_40: i128 = 4;
        // D s_1174_41: read-var u#33038:u32
        let s_1174_41: u32 = fn_state.u_33038;
        // D s_1174_42: cast zx s_1174_41 -> bv
        let s_1174_42: Bits = Bits::new(s_1174_41 as u128, 32u16);
        // D s_1174_43: bit-extract s_1174_42 s_1174_39 s_1174_40
        let s_1174_43: Bits = (Bits::new(
            ((s_1174_42) >> (s_1174_39)).value(),
            u16::try_from(s_1174_40).unwrap(),
        ));
        // D s_1174_44: cast reint s_1174_43 -> u8
        let s_1174_44: u8 = (s_1174_43.value() as u8);
        // D s_1174_45: call decode_aarch32_instrs_SUB_r_A1enc_A_txt(s_1174_8, s_1174_14, s_1174_20, s_1174_26, s_1174_32, s_1174_38, s_1174_44)
        let s_1174_45: () = decode_aarch32_instrs_SUB_r_A1enc_A_txt(
            state,
            tracer,
            s_1174_8,
            s_1174_14,
            s_1174_20,
            s_1174_26,
            s_1174_32,
            s_1174_38,
            s_1174_44,
        );
        // N s_1174_46: return
        return;
    }
    fn block_1175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1175_0: read-var merge#var.1:struct
        let s_1175_0: u32 = fn_state.merge_var._1;
        // D s_1175_1: write-var u#33047 <= s_1175_0
        fn_state.u_33047 = s_1175_0;
        // C s_1175_2: const #21s : i
        let s_1175_2: i128 = 21;
        // D s_1175_3: read-var u#33047:u32
        let s_1175_3: u32 = fn_state.u_33047;
        // D s_1175_4: cast zx s_1175_3 -> bv
        let s_1175_4: Bits = Bits::new(s_1175_3 as u128, 32u16);
        // C s_1175_5: const #1s : i64
        let s_1175_5: i64 = 1;
        // C s_1175_6: cast zx s_1175_5 -> i
        let s_1175_6: i128 = (i128::try_from(s_1175_5).unwrap());
        // C s_1175_7: const #6s : i
        let s_1175_7: i128 = 6;
        // C s_1175_8: add s_1175_7 s_1175_6
        let s_1175_8: i128 = (s_1175_7 + s_1175_6);
        // D s_1175_9: bit-extract s_1175_4 s_1175_2 s_1175_8
        let s_1175_9: Bits = (Bits::new(
            ((s_1175_4) >> (s_1175_2)).value(),
            u16::try_from(s_1175_8).unwrap(),
        ));
        // D s_1175_10: cast reint s_1175_9 -> u8
        let s_1175_10: u8 = (s_1175_9.value() as u8);
        // D s_1175_11: cast zx s_1175_10 -> bv
        let s_1175_11: Bits = Bits::new(s_1175_10 as u128, 7u16);
        // C s_1175_12: const #2u : u8
        let s_1175_12: u8 = 2;
        // C s_1175_13: cast zx s_1175_12 -> bv
        let s_1175_13: Bits = Bits::new(s_1175_12 as u128, 7u16);
        // D s_1175_14: cmp-eq s_1175_11 s_1175_13
        let s_1175_14: bool = ((s_1175_11) == (s_1175_13));
        // N s_1175_15: branch s_1175_14 b2304 b1176
        if s_1175_14 {
            return block_2304(state, tracer, fn_state);
        } else {
            return block_1176(state, tracer, fn_state);
        };
    }
    fn block_1176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1176_0: const #0u : u8
        let s_1176_0: bool = false;
        // D s_1176_1: write-var gs#407031 <= s_1176_0
        fn_state.gs_407031 = s_1176_0;
        // N s_1176_2: jump b1177
        return block_1177(state, tracer, fn_state);
    }
    fn block_1177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1177_0: read-var gs#407031:u8
        let s_1177_0: bool = fn_state.gs_407031;
        // N s_1177_1: branch s_1177_0 b2300 b1178
        if s_1177_0 {
            return block_2300(state, tracer, fn_state);
        } else {
            return block_1178(state, tracer, fn_state);
        };
    }
    fn block_1178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1178_0: const #0u : u8
        let s_1178_0: bool = false;
        // D s_1178_1: write-var gs#407036 <= s_1178_0
        fn_state.gs_407036 = s_1178_0;
        // N s_1178_2: jump b1179
        return block_1179(state, tracer, fn_state);
    }
    fn block_1179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1179_0: read-var gs#407036:u8
        let s_1179_0: bool = fn_state.gs_407036;
        // D s_1179_1: not s_1179_0
        let s_1179_1: bool = !s_1179_0;
        // N s_1179_2: branch s_1179_1 b1181 b1180
        if s_1179_1 {
            return block_1181(state, tracer, fn_state);
        } else {
            return block_1180(state, tracer, fn_state);
        };
    }
    fn block_1180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1180_0: const #3244s : i
        let s_1180_0: i128 = 3244;
        // C s_1180_1: const #14696u : u32
        let s_1180_1: u32 = 14696;
        // N s_1180_2: write-reg s_1180_1 <= s_1180_0
        let s_1180_2: () = {
            state.write_register::<i128>(s_1180_1 as isize, s_1180_0);
            tracer.write_register(s_1180_1 as isize, s_1180_0);
        };
        // C s_1180_3: const #28s : i
        let s_1180_3: i128 = 28;
        // C s_1180_4: const #4s : i
        let s_1180_4: i128 = 4;
        // D s_1180_5: read-var u#33047:u32
        let s_1180_5: u32 = fn_state.u_33047;
        // D s_1180_6: cast zx s_1180_5 -> bv
        let s_1180_6: Bits = Bits::new(s_1180_5 as u128, 32u16);
        // D s_1180_7: bit-extract s_1180_6 s_1180_3 s_1180_4
        let s_1180_7: Bits = (Bits::new(
            ((s_1180_6) >> (s_1180_3)).value(),
            u16::try_from(s_1180_4).unwrap(),
        ));
        // D s_1180_8: cast reint s_1180_7 -> u8
        let s_1180_8: u8 = (s_1180_7.value() as u8);
        // C s_1180_9: const #20s : i
        let s_1180_9: i128 = 20;
        // C s_1180_10: const #1s : i
        let s_1180_10: i128 = 1;
        // D s_1180_11: read-var u#33047:u32
        let s_1180_11: u32 = fn_state.u_33047;
        // D s_1180_12: cast zx s_1180_11 -> bv
        let s_1180_12: Bits = Bits::new(s_1180_11 as u128, 32u16);
        // D s_1180_13: bit-extract s_1180_12 s_1180_9 s_1180_10
        let s_1180_13: Bits = (Bits::new(
            ((s_1180_12) >> (s_1180_9)).value(),
            u16::try_from(s_1180_10).unwrap(),
        ));
        // D s_1180_14: cast reint s_1180_13 -> u8
        let s_1180_14: bool = ((s_1180_13.value()) != 0);
        // C s_1180_15: const #16s : i
        let s_1180_15: i128 = 16;
        // C s_1180_16: const #4s : i
        let s_1180_16: i128 = 4;
        // D s_1180_17: read-var u#33047:u32
        let s_1180_17: u32 = fn_state.u_33047;
        // D s_1180_18: cast zx s_1180_17 -> bv
        let s_1180_18: Bits = Bits::new(s_1180_17 as u128, 32u16);
        // D s_1180_19: bit-extract s_1180_18 s_1180_15 s_1180_16
        let s_1180_19: Bits = (Bits::new(
            ((s_1180_18) >> (s_1180_15)).value(),
            u16::try_from(s_1180_16).unwrap(),
        ));
        // D s_1180_20: cast reint s_1180_19 -> u8
        let s_1180_20: u8 = (s_1180_19.value() as u8);
        // C s_1180_21: const #12s : i
        let s_1180_21: i128 = 12;
        // C s_1180_22: const #4s : i
        let s_1180_22: i128 = 4;
        // D s_1180_23: read-var u#33047:u32
        let s_1180_23: u32 = fn_state.u_33047;
        // D s_1180_24: cast zx s_1180_23 -> bv
        let s_1180_24: Bits = Bits::new(s_1180_23 as u128, 32u16);
        // D s_1180_25: bit-extract s_1180_24 s_1180_21 s_1180_22
        let s_1180_25: Bits = (Bits::new(
            ((s_1180_24) >> (s_1180_21)).value(),
            u16::try_from(s_1180_22).unwrap(),
        ));
        // D s_1180_26: cast reint s_1180_25 -> u8
        let s_1180_26: u8 = (s_1180_25.value() as u8);
        // C s_1180_27: const #8s : i
        let s_1180_27: i128 = 8;
        // C s_1180_28: const #4s : i
        let s_1180_28: i128 = 4;
        // D s_1180_29: read-var u#33047:u32
        let s_1180_29: u32 = fn_state.u_33047;
        // D s_1180_30: cast zx s_1180_29 -> bv
        let s_1180_30: Bits = Bits::new(s_1180_29 as u128, 32u16);
        // D s_1180_31: bit-extract s_1180_30 s_1180_27 s_1180_28
        let s_1180_31: Bits = (Bits::new(
            ((s_1180_30) >> (s_1180_27)).value(),
            u16::try_from(s_1180_28).unwrap(),
        ));
        // D s_1180_32: cast reint s_1180_31 -> u8
        let s_1180_32: u8 = (s_1180_31.value() as u8);
        // C s_1180_33: const #5s : i
        let s_1180_33: i128 = 5;
        // C s_1180_34: const #2s : i
        let s_1180_34: i128 = 2;
        // D s_1180_35: read-var u#33047:u32
        let s_1180_35: u32 = fn_state.u_33047;
        // D s_1180_36: cast zx s_1180_35 -> bv
        let s_1180_36: Bits = Bits::new(s_1180_35 as u128, 32u16);
        // D s_1180_37: bit-extract s_1180_36 s_1180_33 s_1180_34
        let s_1180_37: Bits = (Bits::new(
            ((s_1180_36) >> (s_1180_33)).value(),
            u16::try_from(s_1180_34).unwrap(),
        ));
        // D s_1180_38: cast reint s_1180_37 -> u8
        let s_1180_38: u8 = (s_1180_37.value() as u8);
        // C s_1180_39: const #0s : i
        let s_1180_39: i128 = 0;
        // C s_1180_40: const #4s : i
        let s_1180_40: i128 = 4;
        // D s_1180_41: read-var u#33047:u32
        let s_1180_41: u32 = fn_state.u_33047;
        // D s_1180_42: cast zx s_1180_41 -> bv
        let s_1180_42: Bits = Bits::new(s_1180_41 as u128, 32u16);
        // D s_1180_43: bit-extract s_1180_42 s_1180_39 s_1180_40
        let s_1180_43: Bits = (Bits::new(
            ((s_1180_42) >> (s_1180_39)).value(),
            u16::try_from(s_1180_40).unwrap(),
        ));
        // D s_1180_44: cast reint s_1180_43 -> u8
        let s_1180_44: u8 = (s_1180_43.value() as u8);
        // D s_1180_45: call decode_aarch32_instrs_SUB_rr_A1enc_A_txt(s_1180_8, s_1180_14, s_1180_20, s_1180_26, s_1180_32, s_1180_38, s_1180_44)
        let s_1180_45: () = decode_aarch32_instrs_SUB_rr_A1enc_A_txt(
            state,
            tracer,
            s_1180_8,
            s_1180_14,
            s_1180_20,
            s_1180_26,
            s_1180_32,
            s_1180_38,
            s_1180_44,
        );
        // N s_1180_46: return
        return;
    }
    fn block_1181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1181_0: read-var merge#var.1:struct
        let s_1181_0: u32 = fn_state.merge_var._1;
        // D s_1181_1: write-var u#33056 <= s_1181_0
        fn_state.u_33056 = s_1181_0;
        // C s_1181_2: const #21s : i
        let s_1181_2: i128 = 21;
        // D s_1181_3: read-var u#33056:u32
        let s_1181_3: u32 = fn_state.u_33056;
        // D s_1181_4: cast zx s_1181_3 -> bv
        let s_1181_4: Bits = Bits::new(s_1181_3 as u128, 32u16);
        // C s_1181_5: const #1s : i64
        let s_1181_5: i64 = 1;
        // C s_1181_6: cast zx s_1181_5 -> i
        let s_1181_6: i128 = (i128::try_from(s_1181_5).unwrap());
        // C s_1181_7: const #6s : i
        let s_1181_7: i128 = 6;
        // C s_1181_8: add s_1181_7 s_1181_6
        let s_1181_8: i128 = (s_1181_7 + s_1181_6);
        // D s_1181_9: bit-extract s_1181_4 s_1181_2 s_1181_8
        let s_1181_9: Bits = (Bits::new(
            ((s_1181_4) >> (s_1181_2)).value(),
            u16::try_from(s_1181_8).unwrap(),
        ));
        // D s_1181_10: cast reint s_1181_9 -> u8
        let s_1181_10: u8 = (s_1181_9.value() as u8);
        // D s_1181_11: cast zx s_1181_10 -> bv
        let s_1181_11: Bits = Bits::new(s_1181_10 as u128, 7u16);
        // C s_1181_12: const #18u : u8
        let s_1181_12: u8 = 18;
        // C s_1181_13: cast zx s_1181_12 -> bv
        let s_1181_13: Bits = Bits::new(s_1181_12 as u128, 7u16);
        // D s_1181_14: cmp-eq s_1181_11 s_1181_13
        let s_1181_14: bool = ((s_1181_11) == (s_1181_13));
        // N s_1181_15: branch s_1181_14 b2299 b1182
        if s_1181_14 {
            return block_2299(state, tracer, fn_state);
        } else {
            return block_1182(state, tracer, fn_state);
        };
    }
    fn block_1182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1182_0: const #0u : u8
        let s_1182_0: bool = false;
        // D s_1182_1: write-var gs#407058 <= s_1182_0
        fn_state.gs_407058 = s_1182_0;
        // N s_1182_2: jump b1183
        return block_1183(state, tracer, fn_state);
    }
    fn block_1183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1183_0: read-var gs#407058:u8
        let s_1183_0: bool = fn_state.gs_407058;
        // N s_1183_1: branch s_1183_0 b2295 b1184
        if s_1183_0 {
            return block_2295(state, tracer, fn_state);
        } else {
            return block_1184(state, tracer, fn_state);
        };
    }
    fn block_1184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1184_0: const #0u : u8
        let s_1184_0: bool = false;
        // D s_1184_1: write-var gs#407063 <= s_1184_0
        fn_state.gs_407063 = s_1184_0;
        // N s_1184_2: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_1185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1185_0: read-var gs#407063:u8
        let s_1185_0: bool = fn_state.gs_407063;
        // D s_1185_1: not s_1185_0
        let s_1185_1: bool = !s_1185_0;
        // N s_1185_2: branch s_1185_1 b1187 b1186
        if s_1185_1 {
            return block_1187(state, tracer, fn_state);
        } else {
            return block_1186(state, tracer, fn_state);
        };
    }
    fn block_1186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1186_0: const #3245s : i
        let s_1186_0: i128 = 3245;
        // C s_1186_1: const #14696u : u32
        let s_1186_1: u32 = 14696;
        // N s_1186_2: write-reg s_1186_1 <= s_1186_0
        let s_1186_2: () = {
            state.write_register::<i128>(s_1186_1 as isize, s_1186_0);
            tracer.write_register(s_1186_1 as isize, s_1186_0);
        };
        // C s_1186_3: const #28s : i
        let s_1186_3: i128 = 28;
        // C s_1186_4: const #4s : i
        let s_1186_4: i128 = 4;
        // D s_1186_5: read-var u#33056:u32
        let s_1186_5: u32 = fn_state.u_33056;
        // D s_1186_6: cast zx s_1186_5 -> bv
        let s_1186_6: Bits = Bits::new(s_1186_5 as u128, 32u16);
        // D s_1186_7: bit-extract s_1186_6 s_1186_3 s_1186_4
        let s_1186_7: Bits = (Bits::new(
            ((s_1186_6) >> (s_1186_3)).value(),
            u16::try_from(s_1186_4).unwrap(),
        ));
        // D s_1186_8: cast reint s_1186_7 -> u8
        let s_1186_8: u8 = (s_1186_7.value() as u8);
        // C s_1186_9: const #20s : i
        let s_1186_9: i128 = 20;
        // C s_1186_10: const #1s : i
        let s_1186_10: i128 = 1;
        // D s_1186_11: read-var u#33056:u32
        let s_1186_11: u32 = fn_state.u_33056;
        // D s_1186_12: cast zx s_1186_11 -> bv
        let s_1186_12: Bits = Bits::new(s_1186_11 as u128, 32u16);
        // D s_1186_13: bit-extract s_1186_12 s_1186_9 s_1186_10
        let s_1186_13: Bits = (Bits::new(
            ((s_1186_12) >> (s_1186_9)).value(),
            u16::try_from(s_1186_10).unwrap(),
        ));
        // D s_1186_14: cast reint s_1186_13 -> u8
        let s_1186_14: bool = ((s_1186_13.value()) != 0);
        // C s_1186_15: const #12s : i
        let s_1186_15: i128 = 12;
        // C s_1186_16: const #4s : i
        let s_1186_16: i128 = 4;
        // D s_1186_17: read-var u#33056:u32
        let s_1186_17: u32 = fn_state.u_33056;
        // D s_1186_18: cast zx s_1186_17 -> bv
        let s_1186_18: Bits = Bits::new(s_1186_17 as u128, 32u16);
        // D s_1186_19: bit-extract s_1186_18 s_1186_15 s_1186_16
        let s_1186_19: Bits = (Bits::new(
            ((s_1186_18) >> (s_1186_15)).value(),
            u16::try_from(s_1186_16).unwrap(),
        ));
        // D s_1186_20: cast reint s_1186_19 -> u8
        let s_1186_20: u8 = (s_1186_19.value() as u8);
        // C s_1186_21: const #0s : i
        let s_1186_21: i128 = 0;
        // C s_1186_22: const #12s : i
        let s_1186_22: i128 = 12;
        // D s_1186_23: read-var u#33056:u32
        let s_1186_23: u32 = fn_state.u_33056;
        // D s_1186_24: cast zx s_1186_23 -> bv
        let s_1186_24: Bits = Bits::new(s_1186_23 as u128, 32u16);
        // D s_1186_25: bit-extract s_1186_24 s_1186_21 s_1186_22
        let s_1186_25: Bits = (Bits::new(
            ((s_1186_24) >> (s_1186_21)).value(),
            u16::try_from(s_1186_22).unwrap(),
        ));
        // D s_1186_26: cast reint s_1186_25 -> u12
        let s_1186_26: u16 = (s_1186_25.value() as u16);
        // D s_1186_27: call decode_aarch32_instrs_SUB_SP_i_A1enc_A_txt(s_1186_8, s_1186_14, s_1186_20, s_1186_26)
        let s_1186_27: () = decode_aarch32_instrs_SUB_SP_i_A1enc_A_txt(
            state,
            tracer,
            s_1186_8,
            s_1186_14,
            s_1186_20,
            s_1186_26,
        );
        // N s_1186_28: return
        return;
    }
    fn block_1187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1187_0: read-var merge#var.1:struct
        let s_1187_0: u32 = fn_state.merge_var._1;
        // D s_1187_1: write-var u#33062 <= s_1187_0
        fn_state.u_33062 = s_1187_0;
        // C s_1187_2: const #21s : i
        let s_1187_2: i128 = 21;
        // D s_1187_3: read-var u#33062:u32
        let s_1187_3: u32 = fn_state.u_33062;
        // D s_1187_4: cast zx s_1187_3 -> bv
        let s_1187_4: Bits = Bits::new(s_1187_3 as u128, 32u16);
        // C s_1187_5: const #1s : i64
        let s_1187_5: i64 = 1;
        // C s_1187_6: cast zx s_1187_5 -> i
        let s_1187_6: i128 = (i128::try_from(s_1187_5).unwrap());
        // C s_1187_7: const #6s : i
        let s_1187_7: i128 = 6;
        // C s_1187_8: add s_1187_7 s_1187_6
        let s_1187_8: i128 = (s_1187_7 + s_1187_6);
        // D s_1187_9: bit-extract s_1187_4 s_1187_2 s_1187_8
        let s_1187_9: Bits = (Bits::new(
            ((s_1187_4) >> (s_1187_2)).value(),
            u16::try_from(s_1187_8).unwrap(),
        ));
        // D s_1187_10: cast reint s_1187_9 -> u8
        let s_1187_10: u8 = (s_1187_9.value() as u8);
        // D s_1187_11: cast zx s_1187_10 -> bv
        let s_1187_11: Bits = Bits::new(s_1187_10 as u128, 7u16);
        // C s_1187_12: const #2u : u8
        let s_1187_12: u8 = 2;
        // C s_1187_13: cast zx s_1187_12 -> bv
        let s_1187_13: Bits = Bits::new(s_1187_12 as u128, 7u16);
        // D s_1187_14: cmp-eq s_1187_11 s_1187_13
        let s_1187_14: bool = ((s_1187_11) == (s_1187_13));
        // N s_1187_15: branch s_1187_14 b2291 b1188
        if s_1187_14 {
            return block_2291(state, tracer, fn_state);
        } else {
            return block_1188(state, tracer, fn_state);
        };
    }
    fn block_1188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1188_0: const #0u : u8
        let s_1188_0: bool = false;
        // D s_1188_1: write-var gs#407082 <= s_1188_0
        fn_state.gs_407082 = s_1188_0;
        // N s_1188_2: jump b1189
        return block_1189(state, tracer, fn_state);
    }
    fn block_1189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1189_0: read-var gs#407082:u8
        let s_1189_0: bool = fn_state.gs_407082;
        // N s_1189_1: branch s_1189_0 b2287 b1190
        if s_1189_0 {
            return block_2287(state, tracer, fn_state);
        } else {
            return block_1190(state, tracer, fn_state);
        };
    }
    fn block_1190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1190_0: const #0u : u8
        let s_1190_0: bool = false;
        // D s_1190_1: write-var gs#407087 <= s_1190_0
        fn_state.gs_407087 = s_1190_0;
        // N s_1190_2: jump b1191
        return block_1191(state, tracer, fn_state);
    }
    fn block_1191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1191_0: read-var gs#407087:u8
        let s_1191_0: bool = fn_state.gs_407087;
        // D s_1191_1: not s_1191_0
        let s_1191_1: bool = !s_1191_0;
        // N s_1191_2: branch s_1191_1 b1193 b1192
        if s_1191_1 {
            return block_1193(state, tracer, fn_state);
        } else {
            return block_1192(state, tracer, fn_state);
        };
    }
    fn block_1192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1192_0: const #3249s : i
        let s_1192_0: i128 = 3249;
        // C s_1192_1: const #14696u : u32
        let s_1192_1: u32 = 14696;
        // N s_1192_2: write-reg s_1192_1 <= s_1192_0
        let s_1192_2: () = {
            state.write_register::<i128>(s_1192_1 as isize, s_1192_0);
            tracer.write_register(s_1192_1 as isize, s_1192_0);
        };
        // C s_1192_3: const #28s : i
        let s_1192_3: i128 = 28;
        // C s_1192_4: const #4s : i
        let s_1192_4: i128 = 4;
        // D s_1192_5: read-var u#33062:u32
        let s_1192_5: u32 = fn_state.u_33062;
        // D s_1192_6: cast zx s_1192_5 -> bv
        let s_1192_6: Bits = Bits::new(s_1192_5 as u128, 32u16);
        // D s_1192_7: bit-extract s_1192_6 s_1192_3 s_1192_4
        let s_1192_7: Bits = (Bits::new(
            ((s_1192_6) >> (s_1192_3)).value(),
            u16::try_from(s_1192_4).unwrap(),
        ));
        // D s_1192_8: cast reint s_1192_7 -> u8
        let s_1192_8: u8 = (s_1192_7.value() as u8);
        // C s_1192_9: const #20s : i
        let s_1192_9: i128 = 20;
        // C s_1192_10: const #1s : i
        let s_1192_10: i128 = 1;
        // D s_1192_11: read-var u#33062:u32
        let s_1192_11: u32 = fn_state.u_33062;
        // D s_1192_12: cast zx s_1192_11 -> bv
        let s_1192_12: Bits = Bits::new(s_1192_11 as u128, 32u16);
        // D s_1192_13: bit-extract s_1192_12 s_1192_9 s_1192_10
        let s_1192_13: Bits = (Bits::new(
            ((s_1192_12) >> (s_1192_9)).value(),
            u16::try_from(s_1192_10).unwrap(),
        ));
        // D s_1192_14: cast reint s_1192_13 -> u8
        let s_1192_14: bool = ((s_1192_13.value()) != 0);
        // C s_1192_15: const #12s : i
        let s_1192_15: i128 = 12;
        // C s_1192_16: const #4s : i
        let s_1192_16: i128 = 4;
        // D s_1192_17: read-var u#33062:u32
        let s_1192_17: u32 = fn_state.u_33062;
        // D s_1192_18: cast zx s_1192_17 -> bv
        let s_1192_18: Bits = Bits::new(s_1192_17 as u128, 32u16);
        // D s_1192_19: bit-extract s_1192_18 s_1192_15 s_1192_16
        let s_1192_19: Bits = (Bits::new(
            ((s_1192_18) >> (s_1192_15)).value(),
            u16::try_from(s_1192_16).unwrap(),
        ));
        // D s_1192_20: cast reint s_1192_19 -> u8
        let s_1192_20: u8 = (s_1192_19.value() as u8);
        // C s_1192_21: const #7s : i
        let s_1192_21: i128 = 7;
        // C s_1192_22: const #5s : i
        let s_1192_22: i128 = 5;
        // D s_1192_23: read-var u#33062:u32
        let s_1192_23: u32 = fn_state.u_33062;
        // D s_1192_24: cast zx s_1192_23 -> bv
        let s_1192_24: Bits = Bits::new(s_1192_23 as u128, 32u16);
        // D s_1192_25: bit-extract s_1192_24 s_1192_21 s_1192_22
        let s_1192_25: Bits = (Bits::new(
            ((s_1192_24) >> (s_1192_21)).value(),
            u16::try_from(s_1192_22).unwrap(),
        ));
        // D s_1192_26: cast reint s_1192_25 -> u8
        let s_1192_26: u8 = (s_1192_25.value() as u8);
        // C s_1192_27: const #5s : i
        let s_1192_27: i128 = 5;
        // C s_1192_28: const #2s : i
        let s_1192_28: i128 = 2;
        // D s_1192_29: read-var u#33062:u32
        let s_1192_29: u32 = fn_state.u_33062;
        // D s_1192_30: cast zx s_1192_29 -> bv
        let s_1192_30: Bits = Bits::new(s_1192_29 as u128, 32u16);
        // D s_1192_31: bit-extract s_1192_30 s_1192_27 s_1192_28
        let s_1192_31: Bits = (Bits::new(
            ((s_1192_30) >> (s_1192_27)).value(),
            u16::try_from(s_1192_28).unwrap(),
        ));
        // D s_1192_32: cast reint s_1192_31 -> u8
        let s_1192_32: u8 = (s_1192_31.value() as u8);
        // C s_1192_33: const #0s : i
        let s_1192_33: i128 = 0;
        // C s_1192_34: const #4s : i
        let s_1192_34: i128 = 4;
        // D s_1192_35: read-var u#33062:u32
        let s_1192_35: u32 = fn_state.u_33062;
        // D s_1192_36: cast zx s_1192_35 -> bv
        let s_1192_36: Bits = Bits::new(s_1192_35 as u128, 32u16);
        // D s_1192_37: bit-extract s_1192_36 s_1192_33 s_1192_34
        let s_1192_37: Bits = (Bits::new(
            ((s_1192_36) >> (s_1192_33)).value(),
            u16::try_from(s_1192_34).unwrap(),
        ));
        // D s_1192_38: cast reint s_1192_37 -> u8
        let s_1192_38: u8 = (s_1192_37.value() as u8);
        // D s_1192_39: call decode_aarch32_instrs_SUB_SP_r_A1enc_A_txt(s_1192_8, s_1192_14, s_1192_20, s_1192_26, s_1192_32, s_1192_38)
        let s_1192_39: () = decode_aarch32_instrs_SUB_SP_r_A1enc_A_txt(
            state,
            tracer,
            s_1192_8,
            s_1192_14,
            s_1192_20,
            s_1192_26,
            s_1192_32,
            s_1192_38,
        );
        // N s_1192_40: return
        return;
    }
    fn block_1193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1193_0: read-var merge#var.1:struct
        let s_1193_0: u32 = fn_state.merge_var._1;
        // D s_1193_1: write-var u#33070 <= s_1193_0
        fn_state.u_33070 = s_1193_0;
        // C s_1193_2: const #20s : i
        let s_1193_2: i128 = 20;
        // D s_1193_3: read-var u#33070:u32
        let s_1193_3: u32 = fn_state.u_33070;
        // D s_1193_4: cast zx s_1193_3 -> bv
        let s_1193_4: Bits = Bits::new(s_1193_3 as u128, 32u16);
        // C s_1193_5: const #1s : i64
        let s_1193_5: i64 = 1;
        // C s_1193_6: cast zx s_1193_5 -> i
        let s_1193_6: i128 = (i128::try_from(s_1193_5).unwrap());
        // C s_1193_7: const #7s : i
        let s_1193_7: i128 = 7;
        // C s_1193_8: add s_1193_7 s_1193_6
        let s_1193_8: i128 = (s_1193_7 + s_1193_6);
        // D s_1193_9: bit-extract s_1193_4 s_1193_2 s_1193_8
        let s_1193_9: Bits = (Bits::new(
            ((s_1193_4) >> (s_1193_2)).value(),
            u16::try_from(s_1193_8).unwrap(),
        ));
        // D s_1193_10: cast reint s_1193_9 -> u8
        let s_1193_10: u8 = (s_1193_9.value() as u8);
        // D s_1193_11: cast zx s_1193_10 -> bv
        let s_1193_11: Bits = Bits::new(s_1193_10 as u128, 8u16);
        // C s_1193_12: const #51u : u8
        let s_1193_12: u8 = 51;
        // C s_1193_13: cast zx s_1193_12 -> bv
        let s_1193_13: Bits = Bits::new(s_1193_12 as u128, 8u16);
        // D s_1193_14: cmp-eq s_1193_11 s_1193_13
        let s_1193_14: bool = ((s_1193_11) == (s_1193_13));
        // N s_1193_15: branch s_1193_14 b2286 b1194
        if s_1193_14 {
            return block_2286(state, tracer, fn_state);
        } else {
            return block_1194(state, tracer, fn_state);
        };
    }
    fn block_1194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1194_0: const #0u : u8
        let s_1194_0: bool = false;
        // D s_1194_1: write-var gs#407107 <= s_1194_0
        fn_state.gs_407107 = s_1194_0;
        // N s_1194_2: jump b1195
        return block_1195(state, tracer, fn_state);
    }
    fn block_1195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1195_0: read-var gs#407107:u8
        let s_1195_0: bool = fn_state.gs_407107;
        // N s_1195_1: branch s_1195_0 b2282 b1196
        if s_1195_0 {
            return block_2282(state, tracer, fn_state);
        } else {
            return block_1196(state, tracer, fn_state);
        };
    }
    fn block_1196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1196_0: const #0u : u8
        let s_1196_0: bool = false;
        // D s_1196_1: write-var gs#407112 <= s_1196_0
        fn_state.gs_407112 = s_1196_0;
        // N s_1196_2: jump b1197
        return block_1197(state, tracer, fn_state);
    }
    fn block_1197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1197_0: read-var gs#407112:u8
        let s_1197_0: bool = fn_state.gs_407112;
        // D s_1197_1: not s_1197_0
        let s_1197_1: bool = !s_1197_0;
        // N s_1197_2: branch s_1197_1 b1210 b1198
        if s_1197_1 {
            return block_1210(state, tracer, fn_state);
        } else {
            return block_1198(state, tracer, fn_state);
        };
    }
    fn block_1198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1198_0: const #3268s : i
        let s_1198_0: i128 = 3268;
        // C s_1198_1: const #14696u : u32
        let s_1198_1: u32 = 14696;
        // N s_1198_2: write-reg s_1198_1 <= s_1198_0
        let s_1198_2: () = {
            state.write_register::<i128>(s_1198_1 as isize, s_1198_0);
            tracer.write_register(s_1198_1 as isize, s_1198_0);
        };
        // C s_1198_3: const #28s : i
        let s_1198_3: i128 = 28;
        // C s_1198_4: const #4s : i
        let s_1198_4: i128 = 4;
        // D s_1198_5: read-var u#33070:u32
        let s_1198_5: u32 = fn_state.u_33070;
        // D s_1198_6: cast zx s_1198_5 -> bv
        let s_1198_6: Bits = Bits::new(s_1198_5 as u128, 32u16);
        // D s_1198_7: bit-extract s_1198_6 s_1198_3 s_1198_4
        let s_1198_7: Bits = (Bits::new(
            ((s_1198_6) >> (s_1198_3)).value(),
            u16::try_from(s_1198_4).unwrap(),
        ));
        // D s_1198_8: cast reint s_1198_7 -> u8
        let s_1198_8: u8 = (s_1198_7.value() as u8);
        // D s_1198_9: write-var u#33071 <= s_1198_8
        fn_state.u_33071 = s_1198_8;
        // C s_1198_10: const #16s : i
        let s_1198_10: i128 = 16;
        // C s_1198_11: const #4s : i
        let s_1198_11: i128 = 4;
        // D s_1198_12: read-var u#33070:u32
        let s_1198_12: u32 = fn_state.u_33070;
        // D s_1198_13: cast zx s_1198_12 -> bv
        let s_1198_13: Bits = Bits::new(s_1198_12 as u128, 32u16);
        // D s_1198_14: bit-extract s_1198_13 s_1198_10 s_1198_11
        let s_1198_14: Bits = (Bits::new(
            ((s_1198_13) >> (s_1198_10)).value(),
            u16::try_from(s_1198_11).unwrap(),
        ));
        // D s_1198_15: cast reint s_1198_14 -> u8
        let s_1198_15: u8 = (s_1198_14.value() as u8);
        // D s_1198_16: write-var u#33072 <= s_1198_15
        fn_state.u_33072 = s_1198_15;
        // C s_1198_17: const #0s : i
        let s_1198_17: i128 = 0;
        // C s_1198_18: const #12s : i
        let s_1198_18: i128 = 12;
        // D s_1198_19: read-var u#33070:u32
        let s_1198_19: u32 = fn_state.u_33070;
        // D s_1198_20: cast zx s_1198_19 -> bv
        let s_1198_20: Bits = Bits::new(s_1198_19 as u128, 32u16);
        // D s_1198_21: bit-extract s_1198_20 s_1198_17 s_1198_18
        let s_1198_21: Bits = (Bits::new(
            ((s_1198_20) >> (s_1198_17)).value(),
            u16::try_from(s_1198_18).unwrap(),
        ));
        // D s_1198_22: cast reint s_1198_21 -> u12
        let s_1198_22: u16 = (s_1198_21.value() as u16);
        // D s_1198_23: write-var u#33073 <= s_1198_22
        fn_state.u_33073 = s_1198_22;
        // C s_1198_24: const #12s : i
        let s_1198_24: i128 = 12;
        // D s_1198_25: read-var u#33070:u32
        let s_1198_25: u32 = fn_state.u_33070;
        // D s_1198_26: cast zx s_1198_25 -> bv
        let s_1198_26: Bits = Bits::new(s_1198_25 as u128, 32u16);
        // C s_1198_27: const #1u : u64
        let s_1198_27: u64 = 1;
        // D s_1198_28: bit-extract s_1198_26 s_1198_24 s_1198_27
        let s_1198_28: Bits = (Bits::new(
            ((s_1198_26) >> (s_1198_24)).value(),
            u16::try_from(s_1198_27).unwrap(),
        ));
        // D s_1198_29: cast reint s_1198_28 -> u8
        let s_1198_29: bool = ((s_1198_28.value()) != 0);
        // C s_1198_30: const #0s : i
        let s_1198_30: i128 = 0;
        // C s_1198_31: const #0u : u64
        let s_1198_31: u64 = 0;
        // D s_1198_32: cast zx s_1198_29 -> u64
        let s_1198_32: u64 = (s_1198_29 as u64);
        // C s_1198_33: const #1u : u64
        let s_1198_33: u64 = 1;
        // D s_1198_34: and s_1198_32 s_1198_33
        let s_1198_34: u64 = ((s_1198_32) & (s_1198_33));
        // D s_1198_35: cmp-eq s_1198_34 s_1198_33
        let s_1198_35: bool = ((s_1198_34) == (s_1198_33));
        // D s_1198_36: lsl s_1198_32 s_1198_30
        let s_1198_36: u64 = s_1198_32 << s_1198_30;
        // D s_1198_37: or s_1198_31 s_1198_36
        let s_1198_37: u64 = ((s_1198_31) | (s_1198_36));
        // D s_1198_38: cmpl s_1198_36
        let s_1198_38: u64 = !s_1198_36;
        // D s_1198_39: and s_1198_31 s_1198_38
        let s_1198_39: u64 = ((s_1198_31) & (s_1198_38));
        // D s_1198_40: select s_1198_35 s_1198_37 s_1198_39
        let s_1198_40: u64 = if s_1198_35 { s_1198_37 } else { s_1198_39 };
        // D s_1198_41: cast trunc s_1198_40 -> u8
        let s_1198_41: bool = ((s_1198_40) != 0);
        // D s_1198_42: cast zx s_1198_41 -> bv
        let s_1198_42: Bits = Bits::new(s_1198_41 as u128, 1u16);
        // C s_1198_43: const #0u : u8
        let s_1198_43: bool = false;
        // C s_1198_44: cast zx s_1198_43 -> bv
        let s_1198_44: Bits = Bits::new(s_1198_43 as u128, 1u16);
        // D s_1198_45: cmp-ne s_1198_42 s_1198_44
        let s_1198_45: bool = ((s_1198_42) != (s_1198_44));
        // N s_1198_46: branch s_1198_45 b1209 b1199
        if s_1198_45 {
            return block_1209(state, tracer, fn_state);
        } else {
            return block_1199(state, tracer, fn_state);
        };
    }
    fn block_1199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1199_0: const #13s : i
        let s_1199_0: i128 = 13;
        // D s_1199_1: read-var u#33070:u32
        let s_1199_1: u32 = fn_state.u_33070;
        // D s_1199_2: cast zx s_1199_1 -> bv
        let s_1199_2: Bits = Bits::new(s_1199_1 as u128, 32u16);
        // C s_1199_3: const #1u : u64
        let s_1199_3: u64 = 1;
        // D s_1199_4: bit-extract s_1199_2 s_1199_0 s_1199_3
        let s_1199_4: Bits = (Bits::new(
            ((s_1199_2) >> (s_1199_0)).value(),
            u16::try_from(s_1199_3).unwrap(),
        ));
        // D s_1199_5: cast reint s_1199_4 -> u8
        let s_1199_5: bool = ((s_1199_4.value()) != 0);
        // C s_1199_6: const #0s : i
        let s_1199_6: i128 = 0;
        // C s_1199_7: const #0u : u64
        let s_1199_7: u64 = 0;
        // D s_1199_8: cast zx s_1199_5 -> u64
        let s_1199_8: u64 = (s_1199_5 as u64);
        // C s_1199_9: const #1u : u64
        let s_1199_9: u64 = 1;
        // D s_1199_10: and s_1199_8 s_1199_9
        let s_1199_10: u64 = ((s_1199_8) & (s_1199_9));
        // D s_1199_11: cmp-eq s_1199_10 s_1199_9
        let s_1199_11: bool = ((s_1199_10) == (s_1199_9));
        // D s_1199_12: lsl s_1199_8 s_1199_6
        let s_1199_12: u64 = s_1199_8 << s_1199_6;
        // D s_1199_13: or s_1199_7 s_1199_12
        let s_1199_13: u64 = ((s_1199_7) | (s_1199_12));
        // D s_1199_14: cmpl s_1199_12
        let s_1199_14: u64 = !s_1199_12;
        // D s_1199_15: and s_1199_7 s_1199_14
        let s_1199_15: u64 = ((s_1199_7) & (s_1199_14));
        // D s_1199_16: select s_1199_11 s_1199_13 s_1199_15
        let s_1199_16: u64 = if s_1199_11 { s_1199_13 } else { s_1199_15 };
        // D s_1199_17: cast trunc s_1199_16 -> u8
        let s_1199_17: bool = ((s_1199_16) != 0);
        // D s_1199_18: cast zx s_1199_17 -> bv
        let s_1199_18: Bits = Bits::new(s_1199_17 as u128, 1u16);
        // C s_1199_19: const #0u : u8
        let s_1199_19: bool = false;
        // C s_1199_20: cast zx s_1199_19 -> bv
        let s_1199_20: Bits = Bits::new(s_1199_19 as u128, 1u16);
        // D s_1199_21: cmp-ne s_1199_18 s_1199_20
        let s_1199_21: bool = ((s_1199_18) != (s_1199_20));
        // D s_1199_22: write-var gs#407125 <= s_1199_21
        fn_state.gs_407125 = s_1199_21;
        // N s_1199_23: jump b1200
        return block_1200(state, tracer, fn_state);
    }
    fn block_1200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1200_0: read-var gs#407125:u8
        let s_1200_0: bool = fn_state.gs_407125;
        // N s_1200_1: branch s_1200_0 b1208 b1201
        if s_1200_0 {
            return block_1208(state, tracer, fn_state);
        } else {
            return block_1201(state, tracer, fn_state);
        };
    }
    fn block_1201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1201_0: const #14s : i
        let s_1201_0: i128 = 14;
        // D s_1201_1: read-var u#33070:u32
        let s_1201_1: u32 = fn_state.u_33070;
        // D s_1201_2: cast zx s_1201_1 -> bv
        let s_1201_2: Bits = Bits::new(s_1201_1 as u128, 32u16);
        // C s_1201_3: const #1u : u64
        let s_1201_3: u64 = 1;
        // D s_1201_4: bit-extract s_1201_2 s_1201_0 s_1201_3
        let s_1201_4: Bits = (Bits::new(
            ((s_1201_2) >> (s_1201_0)).value(),
            u16::try_from(s_1201_3).unwrap(),
        ));
        // D s_1201_5: cast reint s_1201_4 -> u8
        let s_1201_5: bool = ((s_1201_4.value()) != 0);
        // C s_1201_6: const #0s : i
        let s_1201_6: i128 = 0;
        // C s_1201_7: const #0u : u64
        let s_1201_7: u64 = 0;
        // D s_1201_8: cast zx s_1201_5 -> u64
        let s_1201_8: u64 = (s_1201_5 as u64);
        // C s_1201_9: const #1u : u64
        let s_1201_9: u64 = 1;
        // D s_1201_10: and s_1201_8 s_1201_9
        let s_1201_10: u64 = ((s_1201_8) & (s_1201_9));
        // D s_1201_11: cmp-eq s_1201_10 s_1201_9
        let s_1201_11: bool = ((s_1201_10) == (s_1201_9));
        // D s_1201_12: lsl s_1201_8 s_1201_6
        let s_1201_12: u64 = s_1201_8 << s_1201_6;
        // D s_1201_13: or s_1201_7 s_1201_12
        let s_1201_13: u64 = ((s_1201_7) | (s_1201_12));
        // D s_1201_14: cmpl s_1201_12
        let s_1201_14: u64 = !s_1201_12;
        // D s_1201_15: and s_1201_7 s_1201_14
        let s_1201_15: u64 = ((s_1201_7) & (s_1201_14));
        // D s_1201_16: select s_1201_11 s_1201_13 s_1201_15
        let s_1201_16: u64 = if s_1201_11 { s_1201_13 } else { s_1201_15 };
        // D s_1201_17: cast trunc s_1201_16 -> u8
        let s_1201_17: bool = ((s_1201_16) != 0);
        // D s_1201_18: cast zx s_1201_17 -> bv
        let s_1201_18: Bits = Bits::new(s_1201_17 as u128, 1u16);
        // C s_1201_19: const #0u : u8
        let s_1201_19: bool = false;
        // C s_1201_20: cast zx s_1201_19 -> bv
        let s_1201_20: Bits = Bits::new(s_1201_19 as u128, 1u16);
        // D s_1201_21: cmp-ne s_1201_18 s_1201_20
        let s_1201_21: bool = ((s_1201_18) != (s_1201_20));
        // D s_1201_22: write-var gs#407128 <= s_1201_21
        fn_state.gs_407128 = s_1201_21;
        // N s_1201_23: jump b1202
        return block_1202(state, tracer, fn_state);
    }
    fn block_1202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1202_0: read-var gs#407128:u8
        let s_1202_0: bool = fn_state.gs_407128;
        // N s_1202_1: branch s_1202_0 b1207 b1203
        if s_1202_0 {
            return block_1207(state, tracer, fn_state);
        } else {
            return block_1203(state, tracer, fn_state);
        };
    }
    fn block_1203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1203_0: const #15s : i
        let s_1203_0: i128 = 15;
        // D s_1203_1: read-var u#33070:u32
        let s_1203_1: u32 = fn_state.u_33070;
        // D s_1203_2: cast zx s_1203_1 -> bv
        let s_1203_2: Bits = Bits::new(s_1203_1 as u128, 32u16);
        // C s_1203_3: const #1u : u64
        let s_1203_3: u64 = 1;
        // D s_1203_4: bit-extract s_1203_2 s_1203_0 s_1203_3
        let s_1203_4: Bits = (Bits::new(
            ((s_1203_2) >> (s_1203_0)).value(),
            u16::try_from(s_1203_3).unwrap(),
        ));
        // D s_1203_5: cast reint s_1203_4 -> u8
        let s_1203_5: bool = ((s_1203_4.value()) != 0);
        // C s_1203_6: const #0s : i
        let s_1203_6: i128 = 0;
        // C s_1203_7: const #0u : u64
        let s_1203_7: u64 = 0;
        // D s_1203_8: cast zx s_1203_5 -> u64
        let s_1203_8: u64 = (s_1203_5 as u64);
        // C s_1203_9: const #1u : u64
        let s_1203_9: u64 = 1;
        // D s_1203_10: and s_1203_8 s_1203_9
        let s_1203_10: u64 = ((s_1203_8) & (s_1203_9));
        // D s_1203_11: cmp-eq s_1203_10 s_1203_9
        let s_1203_11: bool = ((s_1203_10) == (s_1203_9));
        // D s_1203_12: lsl s_1203_8 s_1203_6
        let s_1203_12: u64 = s_1203_8 << s_1203_6;
        // D s_1203_13: or s_1203_7 s_1203_12
        let s_1203_13: u64 = ((s_1203_7) | (s_1203_12));
        // D s_1203_14: cmpl s_1203_12
        let s_1203_14: u64 = !s_1203_12;
        // D s_1203_15: and s_1203_7 s_1203_14
        let s_1203_15: u64 = ((s_1203_7) & (s_1203_14));
        // D s_1203_16: select s_1203_11 s_1203_13 s_1203_15
        let s_1203_16: u64 = if s_1203_11 { s_1203_13 } else { s_1203_15 };
        // D s_1203_17: cast trunc s_1203_16 -> u8
        let s_1203_17: bool = ((s_1203_16) != 0);
        // D s_1203_18: cast zx s_1203_17 -> bv
        let s_1203_18: Bits = Bits::new(s_1203_17 as u128, 1u16);
        // C s_1203_19: const #0u : u8
        let s_1203_19: bool = false;
        // C s_1203_20: cast zx s_1203_19 -> bv
        let s_1203_20: Bits = Bits::new(s_1203_19 as u128, 1u16);
        // D s_1203_21: cmp-ne s_1203_18 s_1203_20
        let s_1203_21: bool = ((s_1203_18) != (s_1203_20));
        // D s_1203_22: write-var gs#407131 <= s_1203_21
        fn_state.gs_407131 = s_1203_21;
        // N s_1203_23: jump b1204
        return block_1204(state, tracer, fn_state);
    }
    fn block_1204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1204_0: read-var gs#407131:u8
        let s_1204_0: bool = fn_state.gs_407131;
        // N s_1204_1: branch s_1204_0 b1206 b1205
        if s_1204_0 {
            return block_1206(state, tracer, fn_state);
        } else {
            return block_1205(state, tracer, fn_state);
        };
    }
    fn block_1205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1205_0: read-var u#33071:u8
        let s_1205_0: u8 = fn_state.u_33071;
        // D s_1205_1: read-var u#33072:u8
        let s_1205_1: u8 = fn_state.u_33072;
        // D s_1205_2: read-var u#33073:u12
        let s_1205_2: u16 = fn_state.u_33073;
        // D s_1205_3: call decode_aarch32_instrs_TEQ_i_A1enc_A_txt(s_1205_0, s_1205_1, s_1205_2)
        let s_1205_3: () = decode_aarch32_instrs_TEQ_i_A1enc_A_txt(
            state,
            tracer,
            s_1205_0,
            s_1205_1,
            s_1205_2,
        );
        // N s_1205_4: return
        return;
    }
    fn block_1206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1206_0: panic
        panic!("{:?}", ());
        // N s_1206_1: return
        return;
    }
    fn block_1207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1207_0: const #1u : u8
        let s_1207_0: bool = true;
        // D s_1207_1: write-var gs#407131 <= s_1207_0
        fn_state.gs_407131 = s_1207_0;
        // N s_1207_2: jump b1204
        return block_1204(state, tracer, fn_state);
    }
    fn block_1208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1208_0: const #1u : u8
        let s_1208_0: bool = true;
        // D s_1208_1: write-var gs#407128 <= s_1208_0
        fn_state.gs_407128 = s_1208_0;
        // N s_1208_2: jump b1202
        return block_1202(state, tracer, fn_state);
    }
    fn block_1209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1209_0: const #1u : u8
        let s_1209_0: bool = true;
        // D s_1209_1: write-var gs#407125 <= s_1209_0
        fn_state.gs_407125 = s_1209_0;
        // N s_1209_2: jump b1200
        return block_1200(state, tracer, fn_state);
    }
    fn block_1210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1210_0: read-var merge#var.1:struct
        let s_1210_0: u32 = fn_state.merge_var._1;
        // D s_1210_1: write-var u#33075 <= s_1210_0
        fn_state.u_33075 = s_1210_0;
        // C s_1210_2: const #20s : i
        let s_1210_2: i128 = 20;
        // D s_1210_3: read-var u#33075:u32
        let s_1210_3: u32 = fn_state.u_33075;
        // D s_1210_4: cast zx s_1210_3 -> bv
        let s_1210_4: Bits = Bits::new(s_1210_3 as u128, 32u16);
        // C s_1210_5: const #1s : i64
        let s_1210_5: i64 = 1;
        // C s_1210_6: cast zx s_1210_5 -> i
        let s_1210_6: i128 = (i128::try_from(s_1210_5).unwrap());
        // C s_1210_7: const #7s : i
        let s_1210_7: i128 = 7;
        // C s_1210_8: add s_1210_7 s_1210_6
        let s_1210_8: i128 = (s_1210_7 + s_1210_6);
        // D s_1210_9: bit-extract s_1210_4 s_1210_2 s_1210_8
        let s_1210_9: Bits = (Bits::new(
            ((s_1210_4) >> (s_1210_2)).value(),
            u16::try_from(s_1210_8).unwrap(),
        ));
        // D s_1210_10: cast reint s_1210_9 -> u8
        let s_1210_10: u8 = (s_1210_9.value() as u8);
        // D s_1210_11: cast zx s_1210_10 -> bv
        let s_1210_11: Bits = Bits::new(s_1210_10 as u128, 8u16);
        // C s_1210_12: const #19u : u8
        let s_1210_12: u8 = 19;
        // C s_1210_13: cast zx s_1210_12 -> bv
        let s_1210_13: Bits = Bits::new(s_1210_12 as u128, 8u16);
        // D s_1210_14: cmp-eq s_1210_11 s_1210_13
        let s_1210_14: bool = ((s_1210_11) == (s_1210_13));
        // N s_1210_15: branch s_1210_14 b2278 b1211
        if s_1210_14 {
            return block_2278(state, tracer, fn_state);
        } else {
            return block_1211(state, tracer, fn_state);
        };
    }
    fn block_1211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1211_0: const #0u : u8
        let s_1211_0: bool = false;
        // D s_1211_1: write-var gs#407140 <= s_1211_0
        fn_state.gs_407140 = s_1211_0;
        // N s_1211_2: jump b1212
        return block_1212(state, tracer, fn_state);
    }
    fn block_1212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1212_0: read-var gs#407140:u8
        let s_1212_0: bool = fn_state.gs_407140;
        // N s_1212_1: branch s_1212_0 b2274 b1213
        if s_1212_0 {
            return block_2274(state, tracer, fn_state);
        } else {
            return block_1213(state, tracer, fn_state);
        };
    }
    fn block_1213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1213_0: const #0u : u8
        let s_1213_0: bool = false;
        // D s_1213_1: write-var gs#407145 <= s_1213_0
        fn_state.gs_407145 = s_1213_0;
        // N s_1213_2: jump b1214
        return block_1214(state, tracer, fn_state);
    }
    fn block_1214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1214_0: read-var gs#407145:u8
        let s_1214_0: bool = fn_state.gs_407145;
        // D s_1214_1: not s_1214_0
        let s_1214_1: bool = !s_1214_0;
        // N s_1214_2: branch s_1214_1 b1227 b1215
        if s_1214_1 {
            return block_1227(state, tracer, fn_state);
        } else {
            return block_1215(state, tracer, fn_state);
        };
    }
    fn block_1215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1215_0: const #3270s : i
        let s_1215_0: i128 = 3270;
        // C s_1215_1: const #14696u : u32
        let s_1215_1: u32 = 14696;
        // N s_1215_2: write-reg s_1215_1 <= s_1215_0
        let s_1215_2: () = {
            state.write_register::<i128>(s_1215_1 as isize, s_1215_0);
            tracer.write_register(s_1215_1 as isize, s_1215_0);
        };
        // C s_1215_3: const #28s : i
        let s_1215_3: i128 = 28;
        // C s_1215_4: const #4s : i
        let s_1215_4: i128 = 4;
        // D s_1215_5: read-var u#33075:u32
        let s_1215_5: u32 = fn_state.u_33075;
        // D s_1215_6: cast zx s_1215_5 -> bv
        let s_1215_6: Bits = Bits::new(s_1215_5 as u128, 32u16);
        // D s_1215_7: bit-extract s_1215_6 s_1215_3 s_1215_4
        let s_1215_7: Bits = (Bits::new(
            ((s_1215_6) >> (s_1215_3)).value(),
            u16::try_from(s_1215_4).unwrap(),
        ));
        // D s_1215_8: cast reint s_1215_7 -> u8
        let s_1215_8: u8 = (s_1215_7.value() as u8);
        // D s_1215_9: write-var u#33076 <= s_1215_8
        fn_state.u_33076 = s_1215_8;
        // C s_1215_10: const #16s : i
        let s_1215_10: i128 = 16;
        // C s_1215_11: const #4s : i
        let s_1215_11: i128 = 4;
        // D s_1215_12: read-var u#33075:u32
        let s_1215_12: u32 = fn_state.u_33075;
        // D s_1215_13: cast zx s_1215_12 -> bv
        let s_1215_13: Bits = Bits::new(s_1215_12 as u128, 32u16);
        // D s_1215_14: bit-extract s_1215_13 s_1215_10 s_1215_11
        let s_1215_14: Bits = (Bits::new(
            ((s_1215_13) >> (s_1215_10)).value(),
            u16::try_from(s_1215_11).unwrap(),
        ));
        // D s_1215_15: cast reint s_1215_14 -> u8
        let s_1215_15: u8 = (s_1215_14.value() as u8);
        // D s_1215_16: write-var u#33077 <= s_1215_15
        fn_state.u_33077 = s_1215_15;
        // C s_1215_17: const #7s : i
        let s_1215_17: i128 = 7;
        // C s_1215_18: const #5s : i
        let s_1215_18: i128 = 5;
        // D s_1215_19: read-var u#33075:u32
        let s_1215_19: u32 = fn_state.u_33075;
        // D s_1215_20: cast zx s_1215_19 -> bv
        let s_1215_20: Bits = Bits::new(s_1215_19 as u128, 32u16);
        // D s_1215_21: bit-extract s_1215_20 s_1215_17 s_1215_18
        let s_1215_21: Bits = (Bits::new(
            ((s_1215_20) >> (s_1215_17)).value(),
            u16::try_from(s_1215_18).unwrap(),
        ));
        // D s_1215_22: cast reint s_1215_21 -> u8
        let s_1215_22: u8 = (s_1215_21.value() as u8);
        // D s_1215_23: write-var u#33078 <= s_1215_22
        fn_state.u_33078 = s_1215_22;
        // C s_1215_24: const #5s : i
        let s_1215_24: i128 = 5;
        // C s_1215_25: const #2s : i
        let s_1215_25: i128 = 2;
        // D s_1215_26: read-var u#33075:u32
        let s_1215_26: u32 = fn_state.u_33075;
        // D s_1215_27: cast zx s_1215_26 -> bv
        let s_1215_27: Bits = Bits::new(s_1215_26 as u128, 32u16);
        // D s_1215_28: bit-extract s_1215_27 s_1215_24 s_1215_25
        let s_1215_28: Bits = (Bits::new(
            ((s_1215_27) >> (s_1215_24)).value(),
            u16::try_from(s_1215_25).unwrap(),
        ));
        // D s_1215_29: cast reint s_1215_28 -> u8
        let s_1215_29: u8 = (s_1215_28.value() as u8);
        // D s_1215_30: write-var u#33079 <= s_1215_29
        fn_state.u_33079 = s_1215_29;
        // C s_1215_31: const #0s : i
        let s_1215_31: i128 = 0;
        // C s_1215_32: const #4s : i
        let s_1215_32: i128 = 4;
        // D s_1215_33: read-var u#33075:u32
        let s_1215_33: u32 = fn_state.u_33075;
        // D s_1215_34: cast zx s_1215_33 -> bv
        let s_1215_34: Bits = Bits::new(s_1215_33 as u128, 32u16);
        // D s_1215_35: bit-extract s_1215_34 s_1215_31 s_1215_32
        let s_1215_35: Bits = (Bits::new(
            ((s_1215_34) >> (s_1215_31)).value(),
            u16::try_from(s_1215_32).unwrap(),
        ));
        // D s_1215_36: cast reint s_1215_35 -> u8
        let s_1215_36: u8 = (s_1215_35.value() as u8);
        // D s_1215_37: write-var u#33080 <= s_1215_36
        fn_state.u_33080 = s_1215_36;
        // C s_1215_38: const #12s : i
        let s_1215_38: i128 = 12;
        // D s_1215_39: read-var u#33075:u32
        let s_1215_39: u32 = fn_state.u_33075;
        // D s_1215_40: cast zx s_1215_39 -> bv
        let s_1215_40: Bits = Bits::new(s_1215_39 as u128, 32u16);
        // C s_1215_41: const #1u : u64
        let s_1215_41: u64 = 1;
        // D s_1215_42: bit-extract s_1215_40 s_1215_38 s_1215_41
        let s_1215_42: Bits = (Bits::new(
            ((s_1215_40) >> (s_1215_38)).value(),
            u16::try_from(s_1215_41).unwrap(),
        ));
        // D s_1215_43: cast reint s_1215_42 -> u8
        let s_1215_43: bool = ((s_1215_42.value()) != 0);
        // C s_1215_44: const #0s : i
        let s_1215_44: i128 = 0;
        // C s_1215_45: const #0u : u64
        let s_1215_45: u64 = 0;
        // D s_1215_46: cast zx s_1215_43 -> u64
        let s_1215_46: u64 = (s_1215_43 as u64);
        // C s_1215_47: const #1u : u64
        let s_1215_47: u64 = 1;
        // D s_1215_48: and s_1215_46 s_1215_47
        let s_1215_48: u64 = ((s_1215_46) & (s_1215_47));
        // D s_1215_49: cmp-eq s_1215_48 s_1215_47
        let s_1215_49: bool = ((s_1215_48) == (s_1215_47));
        // D s_1215_50: lsl s_1215_46 s_1215_44
        let s_1215_50: u64 = s_1215_46 << s_1215_44;
        // D s_1215_51: or s_1215_45 s_1215_50
        let s_1215_51: u64 = ((s_1215_45) | (s_1215_50));
        // D s_1215_52: cmpl s_1215_50
        let s_1215_52: u64 = !s_1215_50;
        // D s_1215_53: and s_1215_45 s_1215_52
        let s_1215_53: u64 = ((s_1215_45) & (s_1215_52));
        // D s_1215_54: select s_1215_49 s_1215_51 s_1215_53
        let s_1215_54: u64 = if s_1215_49 { s_1215_51 } else { s_1215_53 };
        // D s_1215_55: cast trunc s_1215_54 -> u8
        let s_1215_55: bool = ((s_1215_54) != 0);
        // D s_1215_56: cast zx s_1215_55 -> bv
        let s_1215_56: Bits = Bits::new(s_1215_55 as u128, 1u16);
        // C s_1215_57: const #0u : u8
        let s_1215_57: bool = false;
        // C s_1215_58: cast zx s_1215_57 -> bv
        let s_1215_58: Bits = Bits::new(s_1215_57 as u128, 1u16);
        // D s_1215_59: cmp-ne s_1215_56 s_1215_58
        let s_1215_59: bool = ((s_1215_56) != (s_1215_58));
        // N s_1215_60: branch s_1215_59 b1226 b1216
        if s_1215_59 {
            return block_1226(state, tracer, fn_state);
        } else {
            return block_1216(state, tracer, fn_state);
        };
    }
    fn block_1216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1216_0: const #13s : i
        let s_1216_0: i128 = 13;
        // D s_1216_1: read-var u#33075:u32
        let s_1216_1: u32 = fn_state.u_33075;
        // D s_1216_2: cast zx s_1216_1 -> bv
        let s_1216_2: Bits = Bits::new(s_1216_1 as u128, 32u16);
        // C s_1216_3: const #1u : u64
        let s_1216_3: u64 = 1;
        // D s_1216_4: bit-extract s_1216_2 s_1216_0 s_1216_3
        let s_1216_4: Bits = (Bits::new(
            ((s_1216_2) >> (s_1216_0)).value(),
            u16::try_from(s_1216_3).unwrap(),
        ));
        // D s_1216_5: cast reint s_1216_4 -> u8
        let s_1216_5: bool = ((s_1216_4.value()) != 0);
        // C s_1216_6: const #0s : i
        let s_1216_6: i128 = 0;
        // C s_1216_7: const #0u : u64
        let s_1216_7: u64 = 0;
        // D s_1216_8: cast zx s_1216_5 -> u64
        let s_1216_8: u64 = (s_1216_5 as u64);
        // C s_1216_9: const #1u : u64
        let s_1216_9: u64 = 1;
        // D s_1216_10: and s_1216_8 s_1216_9
        let s_1216_10: u64 = ((s_1216_8) & (s_1216_9));
        // D s_1216_11: cmp-eq s_1216_10 s_1216_9
        let s_1216_11: bool = ((s_1216_10) == (s_1216_9));
        // D s_1216_12: lsl s_1216_8 s_1216_6
        let s_1216_12: u64 = s_1216_8 << s_1216_6;
        // D s_1216_13: or s_1216_7 s_1216_12
        let s_1216_13: u64 = ((s_1216_7) | (s_1216_12));
        // D s_1216_14: cmpl s_1216_12
        let s_1216_14: u64 = !s_1216_12;
        // D s_1216_15: and s_1216_7 s_1216_14
        let s_1216_15: u64 = ((s_1216_7) & (s_1216_14));
        // D s_1216_16: select s_1216_11 s_1216_13 s_1216_15
        let s_1216_16: u64 = if s_1216_11 { s_1216_13 } else { s_1216_15 };
        // D s_1216_17: cast trunc s_1216_16 -> u8
        let s_1216_17: bool = ((s_1216_16) != 0);
        // D s_1216_18: cast zx s_1216_17 -> bv
        let s_1216_18: Bits = Bits::new(s_1216_17 as u128, 1u16);
        // C s_1216_19: const #0u : u8
        let s_1216_19: bool = false;
        // C s_1216_20: cast zx s_1216_19 -> bv
        let s_1216_20: Bits = Bits::new(s_1216_19 as u128, 1u16);
        // D s_1216_21: cmp-ne s_1216_18 s_1216_20
        let s_1216_21: bool = ((s_1216_18) != (s_1216_20));
        // D s_1216_22: write-var gs#407162 <= s_1216_21
        fn_state.gs_407162 = s_1216_21;
        // N s_1216_23: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_1217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1217_0: read-var gs#407162:u8
        let s_1217_0: bool = fn_state.gs_407162;
        // N s_1217_1: branch s_1217_0 b1225 b1218
        if s_1217_0 {
            return block_1225(state, tracer, fn_state);
        } else {
            return block_1218(state, tracer, fn_state);
        };
    }
    fn block_1218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1218_0: const #14s : i
        let s_1218_0: i128 = 14;
        // D s_1218_1: read-var u#33075:u32
        let s_1218_1: u32 = fn_state.u_33075;
        // D s_1218_2: cast zx s_1218_1 -> bv
        let s_1218_2: Bits = Bits::new(s_1218_1 as u128, 32u16);
        // C s_1218_3: const #1u : u64
        let s_1218_3: u64 = 1;
        // D s_1218_4: bit-extract s_1218_2 s_1218_0 s_1218_3
        let s_1218_4: Bits = (Bits::new(
            ((s_1218_2) >> (s_1218_0)).value(),
            u16::try_from(s_1218_3).unwrap(),
        ));
        // D s_1218_5: cast reint s_1218_4 -> u8
        let s_1218_5: bool = ((s_1218_4.value()) != 0);
        // C s_1218_6: const #0s : i
        let s_1218_6: i128 = 0;
        // C s_1218_7: const #0u : u64
        let s_1218_7: u64 = 0;
        // D s_1218_8: cast zx s_1218_5 -> u64
        let s_1218_8: u64 = (s_1218_5 as u64);
        // C s_1218_9: const #1u : u64
        let s_1218_9: u64 = 1;
        // D s_1218_10: and s_1218_8 s_1218_9
        let s_1218_10: u64 = ((s_1218_8) & (s_1218_9));
        // D s_1218_11: cmp-eq s_1218_10 s_1218_9
        let s_1218_11: bool = ((s_1218_10) == (s_1218_9));
        // D s_1218_12: lsl s_1218_8 s_1218_6
        let s_1218_12: u64 = s_1218_8 << s_1218_6;
        // D s_1218_13: or s_1218_7 s_1218_12
        let s_1218_13: u64 = ((s_1218_7) | (s_1218_12));
        // D s_1218_14: cmpl s_1218_12
        let s_1218_14: u64 = !s_1218_12;
        // D s_1218_15: and s_1218_7 s_1218_14
        let s_1218_15: u64 = ((s_1218_7) & (s_1218_14));
        // D s_1218_16: select s_1218_11 s_1218_13 s_1218_15
        let s_1218_16: u64 = if s_1218_11 { s_1218_13 } else { s_1218_15 };
        // D s_1218_17: cast trunc s_1218_16 -> u8
        let s_1218_17: bool = ((s_1218_16) != 0);
        // D s_1218_18: cast zx s_1218_17 -> bv
        let s_1218_18: Bits = Bits::new(s_1218_17 as u128, 1u16);
        // C s_1218_19: const #0u : u8
        let s_1218_19: bool = false;
        // C s_1218_20: cast zx s_1218_19 -> bv
        let s_1218_20: Bits = Bits::new(s_1218_19 as u128, 1u16);
        // D s_1218_21: cmp-ne s_1218_18 s_1218_20
        let s_1218_21: bool = ((s_1218_18) != (s_1218_20));
        // D s_1218_22: write-var gs#407165 <= s_1218_21
        fn_state.gs_407165 = s_1218_21;
        // N s_1218_23: jump b1219
        return block_1219(state, tracer, fn_state);
    }
    fn block_1219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1219_0: read-var gs#407165:u8
        let s_1219_0: bool = fn_state.gs_407165;
        // N s_1219_1: branch s_1219_0 b1224 b1220
        if s_1219_0 {
            return block_1224(state, tracer, fn_state);
        } else {
            return block_1220(state, tracer, fn_state);
        };
    }
    fn block_1220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1220_0: const #15s : i
        let s_1220_0: i128 = 15;
        // D s_1220_1: read-var u#33075:u32
        let s_1220_1: u32 = fn_state.u_33075;
        // D s_1220_2: cast zx s_1220_1 -> bv
        let s_1220_2: Bits = Bits::new(s_1220_1 as u128, 32u16);
        // C s_1220_3: const #1u : u64
        let s_1220_3: u64 = 1;
        // D s_1220_4: bit-extract s_1220_2 s_1220_0 s_1220_3
        let s_1220_4: Bits = (Bits::new(
            ((s_1220_2) >> (s_1220_0)).value(),
            u16::try_from(s_1220_3).unwrap(),
        ));
        // D s_1220_5: cast reint s_1220_4 -> u8
        let s_1220_5: bool = ((s_1220_4.value()) != 0);
        // C s_1220_6: const #0s : i
        let s_1220_6: i128 = 0;
        // C s_1220_7: const #0u : u64
        let s_1220_7: u64 = 0;
        // D s_1220_8: cast zx s_1220_5 -> u64
        let s_1220_8: u64 = (s_1220_5 as u64);
        // C s_1220_9: const #1u : u64
        let s_1220_9: u64 = 1;
        // D s_1220_10: and s_1220_8 s_1220_9
        let s_1220_10: u64 = ((s_1220_8) & (s_1220_9));
        // D s_1220_11: cmp-eq s_1220_10 s_1220_9
        let s_1220_11: bool = ((s_1220_10) == (s_1220_9));
        // D s_1220_12: lsl s_1220_8 s_1220_6
        let s_1220_12: u64 = s_1220_8 << s_1220_6;
        // D s_1220_13: or s_1220_7 s_1220_12
        let s_1220_13: u64 = ((s_1220_7) | (s_1220_12));
        // D s_1220_14: cmpl s_1220_12
        let s_1220_14: u64 = !s_1220_12;
        // D s_1220_15: and s_1220_7 s_1220_14
        let s_1220_15: u64 = ((s_1220_7) & (s_1220_14));
        // D s_1220_16: select s_1220_11 s_1220_13 s_1220_15
        let s_1220_16: u64 = if s_1220_11 { s_1220_13 } else { s_1220_15 };
        // D s_1220_17: cast trunc s_1220_16 -> u8
        let s_1220_17: bool = ((s_1220_16) != 0);
        // D s_1220_18: cast zx s_1220_17 -> bv
        let s_1220_18: Bits = Bits::new(s_1220_17 as u128, 1u16);
        // C s_1220_19: const #0u : u8
        let s_1220_19: bool = false;
        // C s_1220_20: cast zx s_1220_19 -> bv
        let s_1220_20: Bits = Bits::new(s_1220_19 as u128, 1u16);
        // D s_1220_21: cmp-ne s_1220_18 s_1220_20
        let s_1220_21: bool = ((s_1220_18) != (s_1220_20));
        // D s_1220_22: write-var gs#407168 <= s_1220_21
        fn_state.gs_407168 = s_1220_21;
        // N s_1220_23: jump b1221
        return block_1221(state, tracer, fn_state);
    }
    fn block_1221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1221_0: read-var gs#407168:u8
        let s_1221_0: bool = fn_state.gs_407168;
        // N s_1221_1: branch s_1221_0 b1223 b1222
        if s_1221_0 {
            return block_1223(state, tracer, fn_state);
        } else {
            return block_1222(state, tracer, fn_state);
        };
    }
    fn block_1222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1222_0: read-var u#33076:u8
        let s_1222_0: u8 = fn_state.u_33076;
        // D s_1222_1: read-var u#33077:u8
        let s_1222_1: u8 = fn_state.u_33077;
        // D s_1222_2: read-var u#33078:u8
        let s_1222_2: u8 = fn_state.u_33078;
        // D s_1222_3: read-var u#33079:u8
        let s_1222_3: u8 = fn_state.u_33079;
        // D s_1222_4: read-var u#33080:u8
        let s_1222_4: u8 = fn_state.u_33080;
        // D s_1222_5: call decode_aarch32_instrs_TEQ_r_A1enc_A_txt(s_1222_0, s_1222_1, s_1222_2, s_1222_3, s_1222_4)
        let s_1222_5: () = decode_aarch32_instrs_TEQ_r_A1enc_A_txt(
            state,
            tracer,
            s_1222_0,
            s_1222_1,
            s_1222_2,
            s_1222_3,
            s_1222_4,
        );
        // N s_1222_6: return
        return;
    }
    fn block_1223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1223_0: panic
        panic!("{:?}", ());
        // N s_1223_1: return
        return;
    }
    fn block_1224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1224_0: const #1u : u8
        let s_1224_0: bool = true;
        // D s_1224_1: write-var gs#407168 <= s_1224_0
        fn_state.gs_407168 = s_1224_0;
        // N s_1224_2: jump b1221
        return block_1221(state, tracer, fn_state);
    }
    fn block_1225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1225_0: const #1u : u8
        let s_1225_0: bool = true;
        // D s_1225_1: write-var gs#407165 <= s_1225_0
        fn_state.gs_407165 = s_1225_0;
        // N s_1225_2: jump b1219
        return block_1219(state, tracer, fn_state);
    }
    fn block_1226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1226_0: const #1u : u8
        let s_1226_0: bool = true;
        // D s_1226_1: write-var gs#407162 <= s_1226_0
        fn_state.gs_407162 = s_1226_0;
        // N s_1226_2: jump b1217
        return block_1217(state, tracer, fn_state);
    }
    fn block_1227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1227_0: read-var merge#var.1:struct
        let s_1227_0: u32 = fn_state.merge_var._1;
        // D s_1227_1: write-var u#33082 <= s_1227_0
        fn_state.u_33082 = s_1227_0;
        // C s_1227_2: const #20s : i
        let s_1227_2: i128 = 20;
        // D s_1227_3: read-var u#33082:u32
        let s_1227_3: u32 = fn_state.u_33082;
        // D s_1227_4: cast zx s_1227_3 -> bv
        let s_1227_4: Bits = Bits::new(s_1227_3 as u128, 32u16);
        // C s_1227_5: const #1s : i64
        let s_1227_5: i64 = 1;
        // C s_1227_6: cast zx s_1227_5 -> i
        let s_1227_6: i128 = (i128::try_from(s_1227_5).unwrap());
        // C s_1227_7: const #7s : i
        let s_1227_7: i128 = 7;
        // C s_1227_8: add s_1227_7 s_1227_6
        let s_1227_8: i128 = (s_1227_7 + s_1227_6);
        // D s_1227_9: bit-extract s_1227_4 s_1227_2 s_1227_8
        let s_1227_9: Bits = (Bits::new(
            ((s_1227_4) >> (s_1227_2)).value(),
            u16::try_from(s_1227_8).unwrap(),
        ));
        // D s_1227_10: cast reint s_1227_9 -> u8
        let s_1227_10: u8 = (s_1227_9.value() as u8);
        // D s_1227_11: cast zx s_1227_10 -> bv
        let s_1227_11: Bits = Bits::new(s_1227_10 as u128, 8u16);
        // C s_1227_12: const #19u : u8
        let s_1227_12: u8 = 19;
        // C s_1227_13: cast zx s_1227_12 -> bv
        let s_1227_13: Bits = Bits::new(s_1227_12 as u128, 8u16);
        // D s_1227_14: cmp-eq s_1227_11 s_1227_13
        let s_1227_14: bool = ((s_1227_11) == (s_1227_13));
        // N s_1227_15: branch s_1227_14 b2267 b1228
        if s_1227_14 {
            return block_2267(state, tracer, fn_state);
        } else {
            return block_1228(state, tracer, fn_state);
        };
    }
    fn block_1228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1228_0: const #0u : u8
        let s_1228_0: bool = false;
        // D s_1228_1: write-var gs#407180 <= s_1228_0
        fn_state.gs_407180 = s_1228_0;
        // N s_1228_2: jump b1229
        return block_1229(state, tracer, fn_state);
    }
    fn block_1229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1229_0: read-var gs#407180:u8
        let s_1229_0: bool = fn_state.gs_407180;
        // N s_1229_1: branch s_1229_0 b2263 b1230
        if s_1229_0 {
            return block_2263(state, tracer, fn_state);
        } else {
            return block_1230(state, tracer, fn_state);
        };
    }
    fn block_1230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1230_0: const #0u : u8
        let s_1230_0: bool = false;
        // D s_1230_1: write-var gs#407185 <= s_1230_0
        fn_state.gs_407185 = s_1230_0;
        // N s_1230_2: jump b1231
        return block_1231(state, tracer, fn_state);
    }
    fn block_1231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1231_0: read-var gs#407185:u8
        let s_1231_0: bool = fn_state.gs_407185;
        // D s_1231_1: not s_1231_0
        let s_1231_1: bool = !s_1231_0;
        // N s_1231_2: branch s_1231_1 b1244 b1232
        if s_1231_1 {
            return block_1244(state, tracer, fn_state);
        } else {
            return block_1232(state, tracer, fn_state);
        };
    }
    fn block_1232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1232_0: const #3272s : i
        let s_1232_0: i128 = 3272;
        // C s_1232_1: const #14696u : u32
        let s_1232_1: u32 = 14696;
        // N s_1232_2: write-reg s_1232_1 <= s_1232_0
        let s_1232_2: () = {
            state.write_register::<i128>(s_1232_1 as isize, s_1232_0);
            tracer.write_register(s_1232_1 as isize, s_1232_0);
        };
        // C s_1232_3: const #28s : i
        let s_1232_3: i128 = 28;
        // C s_1232_4: const #4s : i
        let s_1232_4: i128 = 4;
        // D s_1232_5: read-var u#33082:u32
        let s_1232_5: u32 = fn_state.u_33082;
        // D s_1232_6: cast zx s_1232_5 -> bv
        let s_1232_6: Bits = Bits::new(s_1232_5 as u128, 32u16);
        // D s_1232_7: bit-extract s_1232_6 s_1232_3 s_1232_4
        let s_1232_7: Bits = (Bits::new(
            ((s_1232_6) >> (s_1232_3)).value(),
            u16::try_from(s_1232_4).unwrap(),
        ));
        // D s_1232_8: cast reint s_1232_7 -> u8
        let s_1232_8: u8 = (s_1232_7.value() as u8);
        // D s_1232_9: write-var u#33083 <= s_1232_8
        fn_state.u_33083 = s_1232_8;
        // C s_1232_10: const #16s : i
        let s_1232_10: i128 = 16;
        // C s_1232_11: const #4s : i
        let s_1232_11: i128 = 4;
        // D s_1232_12: read-var u#33082:u32
        let s_1232_12: u32 = fn_state.u_33082;
        // D s_1232_13: cast zx s_1232_12 -> bv
        let s_1232_13: Bits = Bits::new(s_1232_12 as u128, 32u16);
        // D s_1232_14: bit-extract s_1232_13 s_1232_10 s_1232_11
        let s_1232_14: Bits = (Bits::new(
            ((s_1232_13) >> (s_1232_10)).value(),
            u16::try_from(s_1232_11).unwrap(),
        ));
        // D s_1232_15: cast reint s_1232_14 -> u8
        let s_1232_15: u8 = (s_1232_14.value() as u8);
        // D s_1232_16: write-var u#33084 <= s_1232_15
        fn_state.u_33084 = s_1232_15;
        // C s_1232_17: const #8s : i
        let s_1232_17: i128 = 8;
        // C s_1232_18: const #4s : i
        let s_1232_18: i128 = 4;
        // D s_1232_19: read-var u#33082:u32
        let s_1232_19: u32 = fn_state.u_33082;
        // D s_1232_20: cast zx s_1232_19 -> bv
        let s_1232_20: Bits = Bits::new(s_1232_19 as u128, 32u16);
        // D s_1232_21: bit-extract s_1232_20 s_1232_17 s_1232_18
        let s_1232_21: Bits = (Bits::new(
            ((s_1232_20) >> (s_1232_17)).value(),
            u16::try_from(s_1232_18).unwrap(),
        ));
        // D s_1232_22: cast reint s_1232_21 -> u8
        let s_1232_22: u8 = (s_1232_21.value() as u8);
        // D s_1232_23: write-var u#33085 <= s_1232_22
        fn_state.u_33085 = s_1232_22;
        // C s_1232_24: const #5s : i
        let s_1232_24: i128 = 5;
        // C s_1232_25: const #2s : i
        let s_1232_25: i128 = 2;
        // D s_1232_26: read-var u#33082:u32
        let s_1232_26: u32 = fn_state.u_33082;
        // D s_1232_27: cast zx s_1232_26 -> bv
        let s_1232_27: Bits = Bits::new(s_1232_26 as u128, 32u16);
        // D s_1232_28: bit-extract s_1232_27 s_1232_24 s_1232_25
        let s_1232_28: Bits = (Bits::new(
            ((s_1232_27) >> (s_1232_24)).value(),
            u16::try_from(s_1232_25).unwrap(),
        ));
        // D s_1232_29: cast reint s_1232_28 -> u8
        let s_1232_29: u8 = (s_1232_28.value() as u8);
        // D s_1232_30: write-var u#33086 <= s_1232_29
        fn_state.u_33086 = s_1232_29;
        // C s_1232_31: const #0s : i
        let s_1232_31: i128 = 0;
        // C s_1232_32: const #4s : i
        let s_1232_32: i128 = 4;
        // D s_1232_33: read-var u#33082:u32
        let s_1232_33: u32 = fn_state.u_33082;
        // D s_1232_34: cast zx s_1232_33 -> bv
        let s_1232_34: Bits = Bits::new(s_1232_33 as u128, 32u16);
        // D s_1232_35: bit-extract s_1232_34 s_1232_31 s_1232_32
        let s_1232_35: Bits = (Bits::new(
            ((s_1232_34) >> (s_1232_31)).value(),
            u16::try_from(s_1232_32).unwrap(),
        ));
        // D s_1232_36: cast reint s_1232_35 -> u8
        let s_1232_36: u8 = (s_1232_35.value() as u8);
        // D s_1232_37: write-var u#33087 <= s_1232_36
        fn_state.u_33087 = s_1232_36;
        // C s_1232_38: const #12s : i
        let s_1232_38: i128 = 12;
        // D s_1232_39: read-var u#33082:u32
        let s_1232_39: u32 = fn_state.u_33082;
        // D s_1232_40: cast zx s_1232_39 -> bv
        let s_1232_40: Bits = Bits::new(s_1232_39 as u128, 32u16);
        // C s_1232_41: const #1u : u64
        let s_1232_41: u64 = 1;
        // D s_1232_42: bit-extract s_1232_40 s_1232_38 s_1232_41
        let s_1232_42: Bits = (Bits::new(
            ((s_1232_40) >> (s_1232_38)).value(),
            u16::try_from(s_1232_41).unwrap(),
        ));
        // D s_1232_43: cast reint s_1232_42 -> u8
        let s_1232_43: bool = ((s_1232_42.value()) != 0);
        // C s_1232_44: const #0s : i
        let s_1232_44: i128 = 0;
        // C s_1232_45: const #0u : u64
        let s_1232_45: u64 = 0;
        // D s_1232_46: cast zx s_1232_43 -> u64
        let s_1232_46: u64 = (s_1232_43 as u64);
        // C s_1232_47: const #1u : u64
        let s_1232_47: u64 = 1;
        // D s_1232_48: and s_1232_46 s_1232_47
        let s_1232_48: u64 = ((s_1232_46) & (s_1232_47));
        // D s_1232_49: cmp-eq s_1232_48 s_1232_47
        let s_1232_49: bool = ((s_1232_48) == (s_1232_47));
        // D s_1232_50: lsl s_1232_46 s_1232_44
        let s_1232_50: u64 = s_1232_46 << s_1232_44;
        // D s_1232_51: or s_1232_45 s_1232_50
        let s_1232_51: u64 = ((s_1232_45) | (s_1232_50));
        // D s_1232_52: cmpl s_1232_50
        let s_1232_52: u64 = !s_1232_50;
        // D s_1232_53: and s_1232_45 s_1232_52
        let s_1232_53: u64 = ((s_1232_45) & (s_1232_52));
        // D s_1232_54: select s_1232_49 s_1232_51 s_1232_53
        let s_1232_54: u64 = if s_1232_49 { s_1232_51 } else { s_1232_53 };
        // D s_1232_55: cast trunc s_1232_54 -> u8
        let s_1232_55: bool = ((s_1232_54) != 0);
        // D s_1232_56: cast zx s_1232_55 -> bv
        let s_1232_56: Bits = Bits::new(s_1232_55 as u128, 1u16);
        // C s_1232_57: const #0u : u8
        let s_1232_57: bool = false;
        // C s_1232_58: cast zx s_1232_57 -> bv
        let s_1232_58: Bits = Bits::new(s_1232_57 as u128, 1u16);
        // D s_1232_59: cmp-ne s_1232_56 s_1232_58
        let s_1232_59: bool = ((s_1232_56) != (s_1232_58));
        // N s_1232_60: branch s_1232_59 b1243 b1233
        if s_1232_59 {
            return block_1243(state, tracer, fn_state);
        } else {
            return block_1233(state, tracer, fn_state);
        };
    }
    fn block_1233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1233_0: const #13s : i
        let s_1233_0: i128 = 13;
        // D s_1233_1: read-var u#33082:u32
        let s_1233_1: u32 = fn_state.u_33082;
        // D s_1233_2: cast zx s_1233_1 -> bv
        let s_1233_2: Bits = Bits::new(s_1233_1 as u128, 32u16);
        // C s_1233_3: const #1u : u64
        let s_1233_3: u64 = 1;
        // D s_1233_4: bit-extract s_1233_2 s_1233_0 s_1233_3
        let s_1233_4: Bits = (Bits::new(
            ((s_1233_2) >> (s_1233_0)).value(),
            u16::try_from(s_1233_3).unwrap(),
        ));
        // D s_1233_5: cast reint s_1233_4 -> u8
        let s_1233_5: bool = ((s_1233_4.value()) != 0);
        // C s_1233_6: const #0s : i
        let s_1233_6: i128 = 0;
        // C s_1233_7: const #0u : u64
        let s_1233_7: u64 = 0;
        // D s_1233_8: cast zx s_1233_5 -> u64
        let s_1233_8: u64 = (s_1233_5 as u64);
        // C s_1233_9: const #1u : u64
        let s_1233_9: u64 = 1;
        // D s_1233_10: and s_1233_8 s_1233_9
        let s_1233_10: u64 = ((s_1233_8) & (s_1233_9));
        // D s_1233_11: cmp-eq s_1233_10 s_1233_9
        let s_1233_11: bool = ((s_1233_10) == (s_1233_9));
        // D s_1233_12: lsl s_1233_8 s_1233_6
        let s_1233_12: u64 = s_1233_8 << s_1233_6;
        // D s_1233_13: or s_1233_7 s_1233_12
        let s_1233_13: u64 = ((s_1233_7) | (s_1233_12));
        // D s_1233_14: cmpl s_1233_12
        let s_1233_14: u64 = !s_1233_12;
        // D s_1233_15: and s_1233_7 s_1233_14
        let s_1233_15: u64 = ((s_1233_7) & (s_1233_14));
        // D s_1233_16: select s_1233_11 s_1233_13 s_1233_15
        let s_1233_16: u64 = if s_1233_11 { s_1233_13 } else { s_1233_15 };
        // D s_1233_17: cast trunc s_1233_16 -> u8
        let s_1233_17: bool = ((s_1233_16) != 0);
        // D s_1233_18: cast zx s_1233_17 -> bv
        let s_1233_18: Bits = Bits::new(s_1233_17 as u128, 1u16);
        // C s_1233_19: const #0u : u8
        let s_1233_19: bool = false;
        // C s_1233_20: cast zx s_1233_19 -> bv
        let s_1233_20: Bits = Bits::new(s_1233_19 as u128, 1u16);
        // D s_1233_21: cmp-ne s_1233_18 s_1233_20
        let s_1233_21: bool = ((s_1233_18) != (s_1233_20));
        // D s_1233_22: write-var gs#407202 <= s_1233_21
        fn_state.gs_407202 = s_1233_21;
        // N s_1233_23: jump b1234
        return block_1234(state, tracer, fn_state);
    }
    fn block_1234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1234_0: read-var gs#407202:u8
        let s_1234_0: bool = fn_state.gs_407202;
        // N s_1234_1: branch s_1234_0 b1242 b1235
        if s_1234_0 {
            return block_1242(state, tracer, fn_state);
        } else {
            return block_1235(state, tracer, fn_state);
        };
    }
    fn block_1235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1235_0: const #14s : i
        let s_1235_0: i128 = 14;
        // D s_1235_1: read-var u#33082:u32
        let s_1235_1: u32 = fn_state.u_33082;
        // D s_1235_2: cast zx s_1235_1 -> bv
        let s_1235_2: Bits = Bits::new(s_1235_1 as u128, 32u16);
        // C s_1235_3: const #1u : u64
        let s_1235_3: u64 = 1;
        // D s_1235_4: bit-extract s_1235_2 s_1235_0 s_1235_3
        let s_1235_4: Bits = (Bits::new(
            ((s_1235_2) >> (s_1235_0)).value(),
            u16::try_from(s_1235_3).unwrap(),
        ));
        // D s_1235_5: cast reint s_1235_4 -> u8
        let s_1235_5: bool = ((s_1235_4.value()) != 0);
        // C s_1235_6: const #0s : i
        let s_1235_6: i128 = 0;
        // C s_1235_7: const #0u : u64
        let s_1235_7: u64 = 0;
        // D s_1235_8: cast zx s_1235_5 -> u64
        let s_1235_8: u64 = (s_1235_5 as u64);
        // C s_1235_9: const #1u : u64
        let s_1235_9: u64 = 1;
        // D s_1235_10: and s_1235_8 s_1235_9
        let s_1235_10: u64 = ((s_1235_8) & (s_1235_9));
        // D s_1235_11: cmp-eq s_1235_10 s_1235_9
        let s_1235_11: bool = ((s_1235_10) == (s_1235_9));
        // D s_1235_12: lsl s_1235_8 s_1235_6
        let s_1235_12: u64 = s_1235_8 << s_1235_6;
        // D s_1235_13: or s_1235_7 s_1235_12
        let s_1235_13: u64 = ((s_1235_7) | (s_1235_12));
        // D s_1235_14: cmpl s_1235_12
        let s_1235_14: u64 = !s_1235_12;
        // D s_1235_15: and s_1235_7 s_1235_14
        let s_1235_15: u64 = ((s_1235_7) & (s_1235_14));
        // D s_1235_16: select s_1235_11 s_1235_13 s_1235_15
        let s_1235_16: u64 = if s_1235_11 { s_1235_13 } else { s_1235_15 };
        // D s_1235_17: cast trunc s_1235_16 -> u8
        let s_1235_17: bool = ((s_1235_16) != 0);
        // D s_1235_18: cast zx s_1235_17 -> bv
        let s_1235_18: Bits = Bits::new(s_1235_17 as u128, 1u16);
        // C s_1235_19: const #0u : u8
        let s_1235_19: bool = false;
        // C s_1235_20: cast zx s_1235_19 -> bv
        let s_1235_20: Bits = Bits::new(s_1235_19 as u128, 1u16);
        // D s_1235_21: cmp-ne s_1235_18 s_1235_20
        let s_1235_21: bool = ((s_1235_18) != (s_1235_20));
        // D s_1235_22: write-var gs#407205 <= s_1235_21
        fn_state.gs_407205 = s_1235_21;
        // N s_1235_23: jump b1236
        return block_1236(state, tracer, fn_state);
    }
    fn block_1236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1236_0: read-var gs#407205:u8
        let s_1236_0: bool = fn_state.gs_407205;
        // N s_1236_1: branch s_1236_0 b1241 b1237
        if s_1236_0 {
            return block_1241(state, tracer, fn_state);
        } else {
            return block_1237(state, tracer, fn_state);
        };
    }
    fn block_1237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1237_0: const #15s : i
        let s_1237_0: i128 = 15;
        // D s_1237_1: read-var u#33082:u32
        let s_1237_1: u32 = fn_state.u_33082;
        // D s_1237_2: cast zx s_1237_1 -> bv
        let s_1237_2: Bits = Bits::new(s_1237_1 as u128, 32u16);
        // C s_1237_3: const #1u : u64
        let s_1237_3: u64 = 1;
        // D s_1237_4: bit-extract s_1237_2 s_1237_0 s_1237_3
        let s_1237_4: Bits = (Bits::new(
            ((s_1237_2) >> (s_1237_0)).value(),
            u16::try_from(s_1237_3).unwrap(),
        ));
        // D s_1237_5: cast reint s_1237_4 -> u8
        let s_1237_5: bool = ((s_1237_4.value()) != 0);
        // C s_1237_6: const #0s : i
        let s_1237_6: i128 = 0;
        // C s_1237_7: const #0u : u64
        let s_1237_7: u64 = 0;
        // D s_1237_8: cast zx s_1237_5 -> u64
        let s_1237_8: u64 = (s_1237_5 as u64);
        // C s_1237_9: const #1u : u64
        let s_1237_9: u64 = 1;
        // D s_1237_10: and s_1237_8 s_1237_9
        let s_1237_10: u64 = ((s_1237_8) & (s_1237_9));
        // D s_1237_11: cmp-eq s_1237_10 s_1237_9
        let s_1237_11: bool = ((s_1237_10) == (s_1237_9));
        // D s_1237_12: lsl s_1237_8 s_1237_6
        let s_1237_12: u64 = s_1237_8 << s_1237_6;
        // D s_1237_13: or s_1237_7 s_1237_12
        let s_1237_13: u64 = ((s_1237_7) | (s_1237_12));
        // D s_1237_14: cmpl s_1237_12
        let s_1237_14: u64 = !s_1237_12;
        // D s_1237_15: and s_1237_7 s_1237_14
        let s_1237_15: u64 = ((s_1237_7) & (s_1237_14));
        // D s_1237_16: select s_1237_11 s_1237_13 s_1237_15
        let s_1237_16: u64 = if s_1237_11 { s_1237_13 } else { s_1237_15 };
        // D s_1237_17: cast trunc s_1237_16 -> u8
        let s_1237_17: bool = ((s_1237_16) != 0);
        // D s_1237_18: cast zx s_1237_17 -> bv
        let s_1237_18: Bits = Bits::new(s_1237_17 as u128, 1u16);
        // C s_1237_19: const #0u : u8
        let s_1237_19: bool = false;
        // C s_1237_20: cast zx s_1237_19 -> bv
        let s_1237_20: Bits = Bits::new(s_1237_19 as u128, 1u16);
        // D s_1237_21: cmp-ne s_1237_18 s_1237_20
        let s_1237_21: bool = ((s_1237_18) != (s_1237_20));
        // D s_1237_22: write-var gs#407208 <= s_1237_21
        fn_state.gs_407208 = s_1237_21;
        // N s_1237_23: jump b1238
        return block_1238(state, tracer, fn_state);
    }
    fn block_1238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1238_0: read-var gs#407208:u8
        let s_1238_0: bool = fn_state.gs_407208;
        // N s_1238_1: branch s_1238_0 b1240 b1239
        if s_1238_0 {
            return block_1240(state, tracer, fn_state);
        } else {
            return block_1239(state, tracer, fn_state);
        };
    }
    fn block_1239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1239_0: read-var u#33083:u8
        let s_1239_0: u8 = fn_state.u_33083;
        // D s_1239_1: read-var u#33084:u8
        let s_1239_1: u8 = fn_state.u_33084;
        // D s_1239_2: read-var u#33085:u8
        let s_1239_2: u8 = fn_state.u_33085;
        // D s_1239_3: read-var u#33086:u8
        let s_1239_3: u8 = fn_state.u_33086;
        // D s_1239_4: read-var u#33087:u8
        let s_1239_4: u8 = fn_state.u_33087;
        // D s_1239_5: call decode_aarch32_instrs_TEQ_rr_A1enc_A_txt(s_1239_0, s_1239_1, s_1239_2, s_1239_3, s_1239_4)
        let s_1239_5: () = decode_aarch32_instrs_TEQ_rr_A1enc_A_txt(
            state,
            tracer,
            s_1239_0,
            s_1239_1,
            s_1239_2,
            s_1239_3,
            s_1239_4,
        );
        // N s_1239_6: return
        return;
    }
    fn block_1240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1240_0: panic
        panic!("{:?}", ());
        // N s_1240_1: return
        return;
    }
    fn block_1241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1241_0: const #1u : u8
        let s_1241_0: bool = true;
        // D s_1241_1: write-var gs#407208 <= s_1241_0
        fn_state.gs_407208 = s_1241_0;
        // N s_1241_2: jump b1238
        return block_1238(state, tracer, fn_state);
    }
    fn block_1242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1242_0: const #1u : u8
        let s_1242_0: bool = true;
        // D s_1242_1: write-var gs#407205 <= s_1242_0
        fn_state.gs_407205 = s_1242_0;
        // N s_1242_2: jump b1236
        return block_1236(state, tracer, fn_state);
    }
    fn block_1243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1243_0: const #1u : u8
        let s_1243_0: bool = true;
        // D s_1243_1: write-var gs#407202 <= s_1243_0
        fn_state.gs_407202 = s_1243_0;
        // N s_1243_2: jump b1234
        return block_1234(state, tracer, fn_state);
    }
    fn block_1244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1244_0: read-var merge#var.1:struct
        let s_1244_0: u32 = fn_state.merge_var._1;
        // D s_1244_1: write-var u#33089 <= s_1244_0
        fn_state.u_33089 = s_1244_0;
        // C s_1244_2: const #20s : i
        let s_1244_2: i128 = 20;
        // D s_1244_3: read-var u#33089:u32
        let s_1244_3: u32 = fn_state.u_33089;
        // D s_1244_4: cast zx s_1244_3 -> bv
        let s_1244_4: Bits = Bits::new(s_1244_3 as u128, 32u16);
        // C s_1244_5: const #1s : i64
        let s_1244_5: i64 = 1;
        // C s_1244_6: cast zx s_1244_5 -> i
        let s_1244_6: i128 = (i128::try_from(s_1244_5).unwrap());
        // C s_1244_7: const #7s : i
        let s_1244_7: i128 = 7;
        // C s_1244_8: add s_1244_7 s_1244_6
        let s_1244_8: i128 = (s_1244_7 + s_1244_6);
        // D s_1244_9: bit-extract s_1244_4 s_1244_2 s_1244_8
        let s_1244_9: Bits = (Bits::new(
            ((s_1244_4) >> (s_1244_2)).value(),
            u16::try_from(s_1244_8).unwrap(),
        ));
        // D s_1244_10: cast reint s_1244_9 -> u8
        let s_1244_10: u8 = (s_1244_9.value() as u8);
        // D s_1244_11: cast zx s_1244_10 -> bv
        let s_1244_11: Bits = Bits::new(s_1244_10 as u128, 8u16);
        // C s_1244_12: const #49u : u8
        let s_1244_12: u8 = 49;
        // C s_1244_13: cast zx s_1244_12 -> bv
        let s_1244_13: Bits = Bits::new(s_1244_12 as u128, 8u16);
        // D s_1244_14: cmp-eq s_1244_11 s_1244_13
        let s_1244_14: bool = ((s_1244_11) == (s_1244_13));
        // N s_1244_15: branch s_1244_14 b2262 b1245
        if s_1244_14 {
            return block_2262(state, tracer, fn_state);
        } else {
            return block_1245(state, tracer, fn_state);
        };
    }
    fn block_1245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1245_0: const #0u : u8
        let s_1245_0: bool = false;
        // D s_1245_1: write-var gs#407214 <= s_1245_0
        fn_state.gs_407214 = s_1245_0;
        // N s_1245_2: jump b1246
        return block_1246(state, tracer, fn_state);
    }
    fn block_1246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1246_0: read-var gs#407214:u8
        let s_1246_0: bool = fn_state.gs_407214;
        // N s_1246_1: branch s_1246_0 b2258 b1247
        if s_1246_0 {
            return block_2258(state, tracer, fn_state);
        } else {
            return block_1247(state, tracer, fn_state);
        };
    }
    fn block_1247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1247_0: const #0u : u8
        let s_1247_0: bool = false;
        // D s_1247_1: write-var gs#407219 <= s_1247_0
        fn_state.gs_407219 = s_1247_0;
        // N s_1247_2: jump b1248
        return block_1248(state, tracer, fn_state);
    }
    fn block_1248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1248_0: read-var gs#407219:u8
        let s_1248_0: bool = fn_state.gs_407219;
        // D s_1248_1: not s_1248_0
        let s_1248_1: bool = !s_1248_0;
        // N s_1248_2: branch s_1248_1 b1261 b1249
        if s_1248_1 {
            return block_1261(state, tracer, fn_state);
        } else {
            return block_1249(state, tracer, fn_state);
        };
    }
    fn block_1249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1249_0: const #3273s : i
        let s_1249_0: i128 = 3273;
        // C s_1249_1: const #14696u : u32
        let s_1249_1: u32 = 14696;
        // N s_1249_2: write-reg s_1249_1 <= s_1249_0
        let s_1249_2: () = {
            state.write_register::<i128>(s_1249_1 as isize, s_1249_0);
            tracer.write_register(s_1249_1 as isize, s_1249_0);
        };
        // C s_1249_3: const #28s : i
        let s_1249_3: i128 = 28;
        // C s_1249_4: const #4s : i
        let s_1249_4: i128 = 4;
        // D s_1249_5: read-var u#33089:u32
        let s_1249_5: u32 = fn_state.u_33089;
        // D s_1249_6: cast zx s_1249_5 -> bv
        let s_1249_6: Bits = Bits::new(s_1249_5 as u128, 32u16);
        // D s_1249_7: bit-extract s_1249_6 s_1249_3 s_1249_4
        let s_1249_7: Bits = (Bits::new(
            ((s_1249_6) >> (s_1249_3)).value(),
            u16::try_from(s_1249_4).unwrap(),
        ));
        // D s_1249_8: cast reint s_1249_7 -> u8
        let s_1249_8: u8 = (s_1249_7.value() as u8);
        // D s_1249_9: write-var u#33090 <= s_1249_8
        fn_state.u_33090 = s_1249_8;
        // C s_1249_10: const #16s : i
        let s_1249_10: i128 = 16;
        // C s_1249_11: const #4s : i
        let s_1249_11: i128 = 4;
        // D s_1249_12: read-var u#33089:u32
        let s_1249_12: u32 = fn_state.u_33089;
        // D s_1249_13: cast zx s_1249_12 -> bv
        let s_1249_13: Bits = Bits::new(s_1249_12 as u128, 32u16);
        // D s_1249_14: bit-extract s_1249_13 s_1249_10 s_1249_11
        let s_1249_14: Bits = (Bits::new(
            ((s_1249_13) >> (s_1249_10)).value(),
            u16::try_from(s_1249_11).unwrap(),
        ));
        // D s_1249_15: cast reint s_1249_14 -> u8
        let s_1249_15: u8 = (s_1249_14.value() as u8);
        // D s_1249_16: write-var u#33091 <= s_1249_15
        fn_state.u_33091 = s_1249_15;
        // C s_1249_17: const #0s : i
        let s_1249_17: i128 = 0;
        // C s_1249_18: const #12s : i
        let s_1249_18: i128 = 12;
        // D s_1249_19: read-var u#33089:u32
        let s_1249_19: u32 = fn_state.u_33089;
        // D s_1249_20: cast zx s_1249_19 -> bv
        let s_1249_20: Bits = Bits::new(s_1249_19 as u128, 32u16);
        // D s_1249_21: bit-extract s_1249_20 s_1249_17 s_1249_18
        let s_1249_21: Bits = (Bits::new(
            ((s_1249_20) >> (s_1249_17)).value(),
            u16::try_from(s_1249_18).unwrap(),
        ));
        // D s_1249_22: cast reint s_1249_21 -> u12
        let s_1249_22: u16 = (s_1249_21.value() as u16);
        // D s_1249_23: write-var u#33092 <= s_1249_22
        fn_state.u_33092 = s_1249_22;
        // C s_1249_24: const #12s : i
        let s_1249_24: i128 = 12;
        // D s_1249_25: read-var u#33089:u32
        let s_1249_25: u32 = fn_state.u_33089;
        // D s_1249_26: cast zx s_1249_25 -> bv
        let s_1249_26: Bits = Bits::new(s_1249_25 as u128, 32u16);
        // C s_1249_27: const #1u : u64
        let s_1249_27: u64 = 1;
        // D s_1249_28: bit-extract s_1249_26 s_1249_24 s_1249_27
        let s_1249_28: Bits = (Bits::new(
            ((s_1249_26) >> (s_1249_24)).value(),
            u16::try_from(s_1249_27).unwrap(),
        ));
        // D s_1249_29: cast reint s_1249_28 -> u8
        let s_1249_29: bool = ((s_1249_28.value()) != 0);
        // C s_1249_30: const #0s : i
        let s_1249_30: i128 = 0;
        // C s_1249_31: const #0u : u64
        let s_1249_31: u64 = 0;
        // D s_1249_32: cast zx s_1249_29 -> u64
        let s_1249_32: u64 = (s_1249_29 as u64);
        // C s_1249_33: const #1u : u64
        let s_1249_33: u64 = 1;
        // D s_1249_34: and s_1249_32 s_1249_33
        let s_1249_34: u64 = ((s_1249_32) & (s_1249_33));
        // D s_1249_35: cmp-eq s_1249_34 s_1249_33
        let s_1249_35: bool = ((s_1249_34) == (s_1249_33));
        // D s_1249_36: lsl s_1249_32 s_1249_30
        let s_1249_36: u64 = s_1249_32 << s_1249_30;
        // D s_1249_37: or s_1249_31 s_1249_36
        let s_1249_37: u64 = ((s_1249_31) | (s_1249_36));
        // D s_1249_38: cmpl s_1249_36
        let s_1249_38: u64 = !s_1249_36;
        // D s_1249_39: and s_1249_31 s_1249_38
        let s_1249_39: u64 = ((s_1249_31) & (s_1249_38));
        // D s_1249_40: select s_1249_35 s_1249_37 s_1249_39
        let s_1249_40: u64 = if s_1249_35 { s_1249_37 } else { s_1249_39 };
        // D s_1249_41: cast trunc s_1249_40 -> u8
        let s_1249_41: bool = ((s_1249_40) != 0);
        // D s_1249_42: cast zx s_1249_41 -> bv
        let s_1249_42: Bits = Bits::new(s_1249_41 as u128, 1u16);
        // C s_1249_43: const #0u : u8
        let s_1249_43: bool = false;
        // C s_1249_44: cast zx s_1249_43 -> bv
        let s_1249_44: Bits = Bits::new(s_1249_43 as u128, 1u16);
        // D s_1249_45: cmp-ne s_1249_42 s_1249_44
        let s_1249_45: bool = ((s_1249_42) != (s_1249_44));
        // N s_1249_46: branch s_1249_45 b1260 b1250
        if s_1249_45 {
            return block_1260(state, tracer, fn_state);
        } else {
            return block_1250(state, tracer, fn_state);
        };
    }
    fn block_1250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1250_0: const #13s : i
        let s_1250_0: i128 = 13;
        // D s_1250_1: read-var u#33089:u32
        let s_1250_1: u32 = fn_state.u_33089;
        // D s_1250_2: cast zx s_1250_1 -> bv
        let s_1250_2: Bits = Bits::new(s_1250_1 as u128, 32u16);
        // C s_1250_3: const #1u : u64
        let s_1250_3: u64 = 1;
        // D s_1250_4: bit-extract s_1250_2 s_1250_0 s_1250_3
        let s_1250_4: Bits = (Bits::new(
            ((s_1250_2) >> (s_1250_0)).value(),
            u16::try_from(s_1250_3).unwrap(),
        ));
        // D s_1250_5: cast reint s_1250_4 -> u8
        let s_1250_5: bool = ((s_1250_4.value()) != 0);
        // C s_1250_6: const #0s : i
        let s_1250_6: i128 = 0;
        // C s_1250_7: const #0u : u64
        let s_1250_7: u64 = 0;
        // D s_1250_8: cast zx s_1250_5 -> u64
        let s_1250_8: u64 = (s_1250_5 as u64);
        // C s_1250_9: const #1u : u64
        let s_1250_9: u64 = 1;
        // D s_1250_10: and s_1250_8 s_1250_9
        let s_1250_10: u64 = ((s_1250_8) & (s_1250_9));
        // D s_1250_11: cmp-eq s_1250_10 s_1250_9
        let s_1250_11: bool = ((s_1250_10) == (s_1250_9));
        // D s_1250_12: lsl s_1250_8 s_1250_6
        let s_1250_12: u64 = s_1250_8 << s_1250_6;
        // D s_1250_13: or s_1250_7 s_1250_12
        let s_1250_13: u64 = ((s_1250_7) | (s_1250_12));
        // D s_1250_14: cmpl s_1250_12
        let s_1250_14: u64 = !s_1250_12;
        // D s_1250_15: and s_1250_7 s_1250_14
        let s_1250_15: u64 = ((s_1250_7) & (s_1250_14));
        // D s_1250_16: select s_1250_11 s_1250_13 s_1250_15
        let s_1250_16: u64 = if s_1250_11 { s_1250_13 } else { s_1250_15 };
        // D s_1250_17: cast trunc s_1250_16 -> u8
        let s_1250_17: bool = ((s_1250_16) != 0);
        // D s_1250_18: cast zx s_1250_17 -> bv
        let s_1250_18: Bits = Bits::new(s_1250_17 as u128, 1u16);
        // C s_1250_19: const #0u : u8
        let s_1250_19: bool = false;
        // C s_1250_20: cast zx s_1250_19 -> bv
        let s_1250_20: Bits = Bits::new(s_1250_19 as u128, 1u16);
        // D s_1250_21: cmp-ne s_1250_18 s_1250_20
        let s_1250_21: bool = ((s_1250_18) != (s_1250_20));
        // D s_1250_22: write-var gs#407232 <= s_1250_21
        fn_state.gs_407232 = s_1250_21;
        // N s_1250_23: jump b1251
        return block_1251(state, tracer, fn_state);
    }
    fn block_1251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1251_0: read-var gs#407232:u8
        let s_1251_0: bool = fn_state.gs_407232;
        // N s_1251_1: branch s_1251_0 b1259 b1252
        if s_1251_0 {
            return block_1259(state, tracer, fn_state);
        } else {
            return block_1252(state, tracer, fn_state);
        };
    }
    fn block_1252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1252_0: const #14s : i
        let s_1252_0: i128 = 14;
        // D s_1252_1: read-var u#33089:u32
        let s_1252_1: u32 = fn_state.u_33089;
        // D s_1252_2: cast zx s_1252_1 -> bv
        let s_1252_2: Bits = Bits::new(s_1252_1 as u128, 32u16);
        // C s_1252_3: const #1u : u64
        let s_1252_3: u64 = 1;
        // D s_1252_4: bit-extract s_1252_2 s_1252_0 s_1252_3
        let s_1252_4: Bits = (Bits::new(
            ((s_1252_2) >> (s_1252_0)).value(),
            u16::try_from(s_1252_3).unwrap(),
        ));
        // D s_1252_5: cast reint s_1252_4 -> u8
        let s_1252_5: bool = ((s_1252_4.value()) != 0);
        // C s_1252_6: const #0s : i
        let s_1252_6: i128 = 0;
        // C s_1252_7: const #0u : u64
        let s_1252_7: u64 = 0;
        // D s_1252_8: cast zx s_1252_5 -> u64
        let s_1252_8: u64 = (s_1252_5 as u64);
        // C s_1252_9: const #1u : u64
        let s_1252_9: u64 = 1;
        // D s_1252_10: and s_1252_8 s_1252_9
        let s_1252_10: u64 = ((s_1252_8) & (s_1252_9));
        // D s_1252_11: cmp-eq s_1252_10 s_1252_9
        let s_1252_11: bool = ((s_1252_10) == (s_1252_9));
        // D s_1252_12: lsl s_1252_8 s_1252_6
        let s_1252_12: u64 = s_1252_8 << s_1252_6;
        // D s_1252_13: or s_1252_7 s_1252_12
        let s_1252_13: u64 = ((s_1252_7) | (s_1252_12));
        // D s_1252_14: cmpl s_1252_12
        let s_1252_14: u64 = !s_1252_12;
        // D s_1252_15: and s_1252_7 s_1252_14
        let s_1252_15: u64 = ((s_1252_7) & (s_1252_14));
        // D s_1252_16: select s_1252_11 s_1252_13 s_1252_15
        let s_1252_16: u64 = if s_1252_11 { s_1252_13 } else { s_1252_15 };
        // D s_1252_17: cast trunc s_1252_16 -> u8
        let s_1252_17: bool = ((s_1252_16) != 0);
        // D s_1252_18: cast zx s_1252_17 -> bv
        let s_1252_18: Bits = Bits::new(s_1252_17 as u128, 1u16);
        // C s_1252_19: const #0u : u8
        let s_1252_19: bool = false;
        // C s_1252_20: cast zx s_1252_19 -> bv
        let s_1252_20: Bits = Bits::new(s_1252_19 as u128, 1u16);
        // D s_1252_21: cmp-ne s_1252_18 s_1252_20
        let s_1252_21: bool = ((s_1252_18) != (s_1252_20));
        // D s_1252_22: write-var gs#407235 <= s_1252_21
        fn_state.gs_407235 = s_1252_21;
        // N s_1252_23: jump b1253
        return block_1253(state, tracer, fn_state);
    }
    fn block_1253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1253_0: read-var gs#407235:u8
        let s_1253_0: bool = fn_state.gs_407235;
        // N s_1253_1: branch s_1253_0 b1258 b1254
        if s_1253_0 {
            return block_1258(state, tracer, fn_state);
        } else {
            return block_1254(state, tracer, fn_state);
        };
    }
    fn block_1254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1254_0: const #15s : i
        let s_1254_0: i128 = 15;
        // D s_1254_1: read-var u#33089:u32
        let s_1254_1: u32 = fn_state.u_33089;
        // D s_1254_2: cast zx s_1254_1 -> bv
        let s_1254_2: Bits = Bits::new(s_1254_1 as u128, 32u16);
        // C s_1254_3: const #1u : u64
        let s_1254_3: u64 = 1;
        // D s_1254_4: bit-extract s_1254_2 s_1254_0 s_1254_3
        let s_1254_4: Bits = (Bits::new(
            ((s_1254_2) >> (s_1254_0)).value(),
            u16::try_from(s_1254_3).unwrap(),
        ));
        // D s_1254_5: cast reint s_1254_4 -> u8
        let s_1254_5: bool = ((s_1254_4.value()) != 0);
        // C s_1254_6: const #0s : i
        let s_1254_6: i128 = 0;
        // C s_1254_7: const #0u : u64
        let s_1254_7: u64 = 0;
        // D s_1254_8: cast zx s_1254_5 -> u64
        let s_1254_8: u64 = (s_1254_5 as u64);
        // C s_1254_9: const #1u : u64
        let s_1254_9: u64 = 1;
        // D s_1254_10: and s_1254_8 s_1254_9
        let s_1254_10: u64 = ((s_1254_8) & (s_1254_9));
        // D s_1254_11: cmp-eq s_1254_10 s_1254_9
        let s_1254_11: bool = ((s_1254_10) == (s_1254_9));
        // D s_1254_12: lsl s_1254_8 s_1254_6
        let s_1254_12: u64 = s_1254_8 << s_1254_6;
        // D s_1254_13: or s_1254_7 s_1254_12
        let s_1254_13: u64 = ((s_1254_7) | (s_1254_12));
        // D s_1254_14: cmpl s_1254_12
        let s_1254_14: u64 = !s_1254_12;
        // D s_1254_15: and s_1254_7 s_1254_14
        let s_1254_15: u64 = ((s_1254_7) & (s_1254_14));
        // D s_1254_16: select s_1254_11 s_1254_13 s_1254_15
        let s_1254_16: u64 = if s_1254_11 { s_1254_13 } else { s_1254_15 };
        // D s_1254_17: cast trunc s_1254_16 -> u8
        let s_1254_17: bool = ((s_1254_16) != 0);
        // D s_1254_18: cast zx s_1254_17 -> bv
        let s_1254_18: Bits = Bits::new(s_1254_17 as u128, 1u16);
        // C s_1254_19: const #0u : u8
        let s_1254_19: bool = false;
        // C s_1254_20: cast zx s_1254_19 -> bv
        let s_1254_20: Bits = Bits::new(s_1254_19 as u128, 1u16);
        // D s_1254_21: cmp-ne s_1254_18 s_1254_20
        let s_1254_21: bool = ((s_1254_18) != (s_1254_20));
        // D s_1254_22: write-var gs#407238 <= s_1254_21
        fn_state.gs_407238 = s_1254_21;
        // N s_1254_23: jump b1255
        return block_1255(state, tracer, fn_state);
    }
    fn block_1255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1255_0: read-var gs#407238:u8
        let s_1255_0: bool = fn_state.gs_407238;
        // N s_1255_1: branch s_1255_0 b1257 b1256
        if s_1255_0 {
            return block_1257(state, tracer, fn_state);
        } else {
            return block_1256(state, tracer, fn_state);
        };
    }
    fn block_1256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1256_0: read-var u#33090:u8
        let s_1256_0: u8 = fn_state.u_33090;
        // D s_1256_1: read-var u#33091:u8
        let s_1256_1: u8 = fn_state.u_33091;
        // D s_1256_2: read-var u#33092:u12
        let s_1256_2: u16 = fn_state.u_33092;
        // D s_1256_3: call decode_aarch32_instrs_TST_i_A1enc_A_txt(s_1256_0, s_1256_1, s_1256_2)
        let s_1256_3: () = decode_aarch32_instrs_TST_i_A1enc_A_txt(
            state,
            tracer,
            s_1256_0,
            s_1256_1,
            s_1256_2,
        );
        // N s_1256_4: return
        return;
    }
    fn block_1257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1257_0: panic
        panic!("{:?}", ());
        // N s_1257_1: return
        return;
    }
    fn block_1258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1258_0: const #1u : u8
        let s_1258_0: bool = true;
        // D s_1258_1: write-var gs#407238 <= s_1258_0
        fn_state.gs_407238 = s_1258_0;
        // N s_1258_2: jump b1255
        return block_1255(state, tracer, fn_state);
    }
    fn block_1259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1259_0: const #1u : u8
        let s_1259_0: bool = true;
        // D s_1259_1: write-var gs#407235 <= s_1259_0
        fn_state.gs_407235 = s_1259_0;
        // N s_1259_2: jump b1253
        return block_1253(state, tracer, fn_state);
    }
    fn block_1260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1260_0: const #1u : u8
        let s_1260_0: bool = true;
        // D s_1260_1: write-var gs#407232 <= s_1260_0
        fn_state.gs_407232 = s_1260_0;
        // N s_1260_2: jump b1251
        return block_1251(state, tracer, fn_state);
    }
    fn block_1261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1261_0: read-var merge#var.1:struct
        let s_1261_0: u32 = fn_state.merge_var._1;
        // D s_1261_1: write-var u#33094 <= s_1261_0
        fn_state.u_33094 = s_1261_0;
        // C s_1261_2: const #20s : i
        let s_1261_2: i128 = 20;
        // D s_1261_3: read-var u#33094:u32
        let s_1261_3: u32 = fn_state.u_33094;
        // D s_1261_4: cast zx s_1261_3 -> bv
        let s_1261_4: Bits = Bits::new(s_1261_3 as u128, 32u16);
        // C s_1261_5: const #1s : i64
        let s_1261_5: i64 = 1;
        // C s_1261_6: cast zx s_1261_5 -> i
        let s_1261_6: i128 = (i128::try_from(s_1261_5).unwrap());
        // C s_1261_7: const #7s : i
        let s_1261_7: i128 = 7;
        // C s_1261_8: add s_1261_7 s_1261_6
        let s_1261_8: i128 = (s_1261_7 + s_1261_6);
        // D s_1261_9: bit-extract s_1261_4 s_1261_2 s_1261_8
        let s_1261_9: Bits = (Bits::new(
            ((s_1261_4) >> (s_1261_2)).value(),
            u16::try_from(s_1261_8).unwrap(),
        ));
        // D s_1261_10: cast reint s_1261_9 -> u8
        let s_1261_10: u8 = (s_1261_9.value() as u8);
        // D s_1261_11: cast zx s_1261_10 -> bv
        let s_1261_11: Bits = Bits::new(s_1261_10 as u128, 8u16);
        // C s_1261_12: const #17u : u8
        let s_1261_12: u8 = 17;
        // C s_1261_13: cast zx s_1261_12 -> bv
        let s_1261_13: Bits = Bits::new(s_1261_12 as u128, 8u16);
        // D s_1261_14: cmp-eq s_1261_11 s_1261_13
        let s_1261_14: bool = ((s_1261_11) == (s_1261_13));
        // N s_1261_15: branch s_1261_14 b2254 b1262
        if s_1261_14 {
            return block_2254(state, tracer, fn_state);
        } else {
            return block_1262(state, tracer, fn_state);
        };
    }
    fn block_1262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1262_0: const #0u : u8
        let s_1262_0: bool = false;
        // D s_1262_1: write-var gs#407247 <= s_1262_0
        fn_state.gs_407247 = s_1262_0;
        // N s_1262_2: jump b1263
        return block_1263(state, tracer, fn_state);
    }
    fn block_1263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1263_0: read-var gs#407247:u8
        let s_1263_0: bool = fn_state.gs_407247;
        // N s_1263_1: branch s_1263_0 b2250 b1264
        if s_1263_0 {
            return block_2250(state, tracer, fn_state);
        } else {
            return block_1264(state, tracer, fn_state);
        };
    }
    fn block_1264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1264_0: const #0u : u8
        let s_1264_0: bool = false;
        // D s_1264_1: write-var gs#407252 <= s_1264_0
        fn_state.gs_407252 = s_1264_0;
        // N s_1264_2: jump b1265
        return block_1265(state, tracer, fn_state);
    }
    fn block_1265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1265_0: read-var gs#407252:u8
        let s_1265_0: bool = fn_state.gs_407252;
        // D s_1265_1: not s_1265_0
        let s_1265_1: bool = !s_1265_0;
        // N s_1265_2: branch s_1265_1 b1278 b1266
        if s_1265_1 {
            return block_1278(state, tracer, fn_state);
        } else {
            return block_1266(state, tracer, fn_state);
        };
    }
    fn block_1266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1266_0: const #3275s : i
        let s_1266_0: i128 = 3275;
        // C s_1266_1: const #14696u : u32
        let s_1266_1: u32 = 14696;
        // N s_1266_2: write-reg s_1266_1 <= s_1266_0
        let s_1266_2: () = {
            state.write_register::<i128>(s_1266_1 as isize, s_1266_0);
            tracer.write_register(s_1266_1 as isize, s_1266_0);
        };
        // C s_1266_3: const #28s : i
        let s_1266_3: i128 = 28;
        // C s_1266_4: const #4s : i
        let s_1266_4: i128 = 4;
        // D s_1266_5: read-var u#33094:u32
        let s_1266_5: u32 = fn_state.u_33094;
        // D s_1266_6: cast zx s_1266_5 -> bv
        let s_1266_6: Bits = Bits::new(s_1266_5 as u128, 32u16);
        // D s_1266_7: bit-extract s_1266_6 s_1266_3 s_1266_4
        let s_1266_7: Bits = (Bits::new(
            ((s_1266_6) >> (s_1266_3)).value(),
            u16::try_from(s_1266_4).unwrap(),
        ));
        // D s_1266_8: cast reint s_1266_7 -> u8
        let s_1266_8: u8 = (s_1266_7.value() as u8);
        // D s_1266_9: write-var u#33095 <= s_1266_8
        fn_state.u_33095 = s_1266_8;
        // C s_1266_10: const #16s : i
        let s_1266_10: i128 = 16;
        // C s_1266_11: const #4s : i
        let s_1266_11: i128 = 4;
        // D s_1266_12: read-var u#33094:u32
        let s_1266_12: u32 = fn_state.u_33094;
        // D s_1266_13: cast zx s_1266_12 -> bv
        let s_1266_13: Bits = Bits::new(s_1266_12 as u128, 32u16);
        // D s_1266_14: bit-extract s_1266_13 s_1266_10 s_1266_11
        let s_1266_14: Bits = (Bits::new(
            ((s_1266_13) >> (s_1266_10)).value(),
            u16::try_from(s_1266_11).unwrap(),
        ));
        // D s_1266_15: cast reint s_1266_14 -> u8
        let s_1266_15: u8 = (s_1266_14.value() as u8);
        // D s_1266_16: write-var u#33096 <= s_1266_15
        fn_state.u_33096 = s_1266_15;
        // C s_1266_17: const #7s : i
        let s_1266_17: i128 = 7;
        // C s_1266_18: const #5s : i
        let s_1266_18: i128 = 5;
        // D s_1266_19: read-var u#33094:u32
        let s_1266_19: u32 = fn_state.u_33094;
        // D s_1266_20: cast zx s_1266_19 -> bv
        let s_1266_20: Bits = Bits::new(s_1266_19 as u128, 32u16);
        // D s_1266_21: bit-extract s_1266_20 s_1266_17 s_1266_18
        let s_1266_21: Bits = (Bits::new(
            ((s_1266_20) >> (s_1266_17)).value(),
            u16::try_from(s_1266_18).unwrap(),
        ));
        // D s_1266_22: cast reint s_1266_21 -> u8
        let s_1266_22: u8 = (s_1266_21.value() as u8);
        // D s_1266_23: write-var u#33097 <= s_1266_22
        fn_state.u_33097 = s_1266_22;
        // C s_1266_24: const #5s : i
        let s_1266_24: i128 = 5;
        // C s_1266_25: const #2s : i
        let s_1266_25: i128 = 2;
        // D s_1266_26: read-var u#33094:u32
        let s_1266_26: u32 = fn_state.u_33094;
        // D s_1266_27: cast zx s_1266_26 -> bv
        let s_1266_27: Bits = Bits::new(s_1266_26 as u128, 32u16);
        // D s_1266_28: bit-extract s_1266_27 s_1266_24 s_1266_25
        let s_1266_28: Bits = (Bits::new(
            ((s_1266_27) >> (s_1266_24)).value(),
            u16::try_from(s_1266_25).unwrap(),
        ));
        // D s_1266_29: cast reint s_1266_28 -> u8
        let s_1266_29: u8 = (s_1266_28.value() as u8);
        // D s_1266_30: write-var u#33098 <= s_1266_29
        fn_state.u_33098 = s_1266_29;
        // C s_1266_31: const #0s : i
        let s_1266_31: i128 = 0;
        // C s_1266_32: const #4s : i
        let s_1266_32: i128 = 4;
        // D s_1266_33: read-var u#33094:u32
        let s_1266_33: u32 = fn_state.u_33094;
        // D s_1266_34: cast zx s_1266_33 -> bv
        let s_1266_34: Bits = Bits::new(s_1266_33 as u128, 32u16);
        // D s_1266_35: bit-extract s_1266_34 s_1266_31 s_1266_32
        let s_1266_35: Bits = (Bits::new(
            ((s_1266_34) >> (s_1266_31)).value(),
            u16::try_from(s_1266_32).unwrap(),
        ));
        // D s_1266_36: cast reint s_1266_35 -> u8
        let s_1266_36: u8 = (s_1266_35.value() as u8);
        // D s_1266_37: write-var u#33099 <= s_1266_36
        fn_state.u_33099 = s_1266_36;
        // C s_1266_38: const #12s : i
        let s_1266_38: i128 = 12;
        // D s_1266_39: read-var u#33094:u32
        let s_1266_39: u32 = fn_state.u_33094;
        // D s_1266_40: cast zx s_1266_39 -> bv
        let s_1266_40: Bits = Bits::new(s_1266_39 as u128, 32u16);
        // C s_1266_41: const #1u : u64
        let s_1266_41: u64 = 1;
        // D s_1266_42: bit-extract s_1266_40 s_1266_38 s_1266_41
        let s_1266_42: Bits = (Bits::new(
            ((s_1266_40) >> (s_1266_38)).value(),
            u16::try_from(s_1266_41).unwrap(),
        ));
        // D s_1266_43: cast reint s_1266_42 -> u8
        let s_1266_43: bool = ((s_1266_42.value()) != 0);
        // C s_1266_44: const #0s : i
        let s_1266_44: i128 = 0;
        // C s_1266_45: const #0u : u64
        let s_1266_45: u64 = 0;
        // D s_1266_46: cast zx s_1266_43 -> u64
        let s_1266_46: u64 = (s_1266_43 as u64);
        // C s_1266_47: const #1u : u64
        let s_1266_47: u64 = 1;
        // D s_1266_48: and s_1266_46 s_1266_47
        let s_1266_48: u64 = ((s_1266_46) & (s_1266_47));
        // D s_1266_49: cmp-eq s_1266_48 s_1266_47
        let s_1266_49: bool = ((s_1266_48) == (s_1266_47));
        // D s_1266_50: lsl s_1266_46 s_1266_44
        let s_1266_50: u64 = s_1266_46 << s_1266_44;
        // D s_1266_51: or s_1266_45 s_1266_50
        let s_1266_51: u64 = ((s_1266_45) | (s_1266_50));
        // D s_1266_52: cmpl s_1266_50
        let s_1266_52: u64 = !s_1266_50;
        // D s_1266_53: and s_1266_45 s_1266_52
        let s_1266_53: u64 = ((s_1266_45) & (s_1266_52));
        // D s_1266_54: select s_1266_49 s_1266_51 s_1266_53
        let s_1266_54: u64 = if s_1266_49 { s_1266_51 } else { s_1266_53 };
        // D s_1266_55: cast trunc s_1266_54 -> u8
        let s_1266_55: bool = ((s_1266_54) != 0);
        // D s_1266_56: cast zx s_1266_55 -> bv
        let s_1266_56: Bits = Bits::new(s_1266_55 as u128, 1u16);
        // C s_1266_57: const #0u : u8
        let s_1266_57: bool = false;
        // C s_1266_58: cast zx s_1266_57 -> bv
        let s_1266_58: Bits = Bits::new(s_1266_57 as u128, 1u16);
        // D s_1266_59: cmp-ne s_1266_56 s_1266_58
        let s_1266_59: bool = ((s_1266_56) != (s_1266_58));
        // N s_1266_60: branch s_1266_59 b1277 b1267
        if s_1266_59 {
            return block_1277(state, tracer, fn_state);
        } else {
            return block_1267(state, tracer, fn_state);
        };
    }
    fn block_1267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1267_0: const #13s : i
        let s_1267_0: i128 = 13;
        // D s_1267_1: read-var u#33094:u32
        let s_1267_1: u32 = fn_state.u_33094;
        // D s_1267_2: cast zx s_1267_1 -> bv
        let s_1267_2: Bits = Bits::new(s_1267_1 as u128, 32u16);
        // C s_1267_3: const #1u : u64
        let s_1267_3: u64 = 1;
        // D s_1267_4: bit-extract s_1267_2 s_1267_0 s_1267_3
        let s_1267_4: Bits = (Bits::new(
            ((s_1267_2) >> (s_1267_0)).value(),
            u16::try_from(s_1267_3).unwrap(),
        ));
        // D s_1267_5: cast reint s_1267_4 -> u8
        let s_1267_5: bool = ((s_1267_4.value()) != 0);
        // C s_1267_6: const #0s : i
        let s_1267_6: i128 = 0;
        // C s_1267_7: const #0u : u64
        let s_1267_7: u64 = 0;
        // D s_1267_8: cast zx s_1267_5 -> u64
        let s_1267_8: u64 = (s_1267_5 as u64);
        // C s_1267_9: const #1u : u64
        let s_1267_9: u64 = 1;
        // D s_1267_10: and s_1267_8 s_1267_9
        let s_1267_10: u64 = ((s_1267_8) & (s_1267_9));
        // D s_1267_11: cmp-eq s_1267_10 s_1267_9
        let s_1267_11: bool = ((s_1267_10) == (s_1267_9));
        // D s_1267_12: lsl s_1267_8 s_1267_6
        let s_1267_12: u64 = s_1267_8 << s_1267_6;
        // D s_1267_13: or s_1267_7 s_1267_12
        let s_1267_13: u64 = ((s_1267_7) | (s_1267_12));
        // D s_1267_14: cmpl s_1267_12
        let s_1267_14: u64 = !s_1267_12;
        // D s_1267_15: and s_1267_7 s_1267_14
        let s_1267_15: u64 = ((s_1267_7) & (s_1267_14));
        // D s_1267_16: select s_1267_11 s_1267_13 s_1267_15
        let s_1267_16: u64 = if s_1267_11 { s_1267_13 } else { s_1267_15 };
        // D s_1267_17: cast trunc s_1267_16 -> u8
        let s_1267_17: bool = ((s_1267_16) != 0);
        // D s_1267_18: cast zx s_1267_17 -> bv
        let s_1267_18: Bits = Bits::new(s_1267_17 as u128, 1u16);
        // C s_1267_19: const #0u : u8
        let s_1267_19: bool = false;
        // C s_1267_20: cast zx s_1267_19 -> bv
        let s_1267_20: Bits = Bits::new(s_1267_19 as u128, 1u16);
        // D s_1267_21: cmp-ne s_1267_18 s_1267_20
        let s_1267_21: bool = ((s_1267_18) != (s_1267_20));
        // D s_1267_22: write-var gs#407269 <= s_1267_21
        fn_state.gs_407269 = s_1267_21;
        // N s_1267_23: jump b1268
        return block_1268(state, tracer, fn_state);
    }
    fn block_1268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1268_0: read-var gs#407269:u8
        let s_1268_0: bool = fn_state.gs_407269;
        // N s_1268_1: branch s_1268_0 b1276 b1269
        if s_1268_0 {
            return block_1276(state, tracer, fn_state);
        } else {
            return block_1269(state, tracer, fn_state);
        };
    }
    fn block_1269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1269_0: const #14s : i
        let s_1269_0: i128 = 14;
        // D s_1269_1: read-var u#33094:u32
        let s_1269_1: u32 = fn_state.u_33094;
        // D s_1269_2: cast zx s_1269_1 -> bv
        let s_1269_2: Bits = Bits::new(s_1269_1 as u128, 32u16);
        // C s_1269_3: const #1u : u64
        let s_1269_3: u64 = 1;
        // D s_1269_4: bit-extract s_1269_2 s_1269_0 s_1269_3
        let s_1269_4: Bits = (Bits::new(
            ((s_1269_2) >> (s_1269_0)).value(),
            u16::try_from(s_1269_3).unwrap(),
        ));
        // D s_1269_5: cast reint s_1269_4 -> u8
        let s_1269_5: bool = ((s_1269_4.value()) != 0);
        // C s_1269_6: const #0s : i
        let s_1269_6: i128 = 0;
        // C s_1269_7: const #0u : u64
        let s_1269_7: u64 = 0;
        // D s_1269_8: cast zx s_1269_5 -> u64
        let s_1269_8: u64 = (s_1269_5 as u64);
        // C s_1269_9: const #1u : u64
        let s_1269_9: u64 = 1;
        // D s_1269_10: and s_1269_8 s_1269_9
        let s_1269_10: u64 = ((s_1269_8) & (s_1269_9));
        // D s_1269_11: cmp-eq s_1269_10 s_1269_9
        let s_1269_11: bool = ((s_1269_10) == (s_1269_9));
        // D s_1269_12: lsl s_1269_8 s_1269_6
        let s_1269_12: u64 = s_1269_8 << s_1269_6;
        // D s_1269_13: or s_1269_7 s_1269_12
        let s_1269_13: u64 = ((s_1269_7) | (s_1269_12));
        // D s_1269_14: cmpl s_1269_12
        let s_1269_14: u64 = !s_1269_12;
        // D s_1269_15: and s_1269_7 s_1269_14
        let s_1269_15: u64 = ((s_1269_7) & (s_1269_14));
        // D s_1269_16: select s_1269_11 s_1269_13 s_1269_15
        let s_1269_16: u64 = if s_1269_11 { s_1269_13 } else { s_1269_15 };
        // D s_1269_17: cast trunc s_1269_16 -> u8
        let s_1269_17: bool = ((s_1269_16) != 0);
        // D s_1269_18: cast zx s_1269_17 -> bv
        let s_1269_18: Bits = Bits::new(s_1269_17 as u128, 1u16);
        // C s_1269_19: const #0u : u8
        let s_1269_19: bool = false;
        // C s_1269_20: cast zx s_1269_19 -> bv
        let s_1269_20: Bits = Bits::new(s_1269_19 as u128, 1u16);
        // D s_1269_21: cmp-ne s_1269_18 s_1269_20
        let s_1269_21: bool = ((s_1269_18) != (s_1269_20));
        // D s_1269_22: write-var gs#407272 <= s_1269_21
        fn_state.gs_407272 = s_1269_21;
        // N s_1269_23: jump b1270
        return block_1270(state, tracer, fn_state);
    }
    fn block_1270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1270_0: read-var gs#407272:u8
        let s_1270_0: bool = fn_state.gs_407272;
        // N s_1270_1: branch s_1270_0 b1275 b1271
        if s_1270_0 {
            return block_1275(state, tracer, fn_state);
        } else {
            return block_1271(state, tracer, fn_state);
        };
    }
    fn block_1271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1271_0: const #15s : i
        let s_1271_0: i128 = 15;
        // D s_1271_1: read-var u#33094:u32
        let s_1271_1: u32 = fn_state.u_33094;
        // D s_1271_2: cast zx s_1271_1 -> bv
        let s_1271_2: Bits = Bits::new(s_1271_1 as u128, 32u16);
        // C s_1271_3: const #1u : u64
        let s_1271_3: u64 = 1;
        // D s_1271_4: bit-extract s_1271_2 s_1271_0 s_1271_3
        let s_1271_4: Bits = (Bits::new(
            ((s_1271_2) >> (s_1271_0)).value(),
            u16::try_from(s_1271_3).unwrap(),
        ));
        // D s_1271_5: cast reint s_1271_4 -> u8
        let s_1271_5: bool = ((s_1271_4.value()) != 0);
        // C s_1271_6: const #0s : i
        let s_1271_6: i128 = 0;
        // C s_1271_7: const #0u : u64
        let s_1271_7: u64 = 0;
        // D s_1271_8: cast zx s_1271_5 -> u64
        let s_1271_8: u64 = (s_1271_5 as u64);
        // C s_1271_9: const #1u : u64
        let s_1271_9: u64 = 1;
        // D s_1271_10: and s_1271_8 s_1271_9
        let s_1271_10: u64 = ((s_1271_8) & (s_1271_9));
        // D s_1271_11: cmp-eq s_1271_10 s_1271_9
        let s_1271_11: bool = ((s_1271_10) == (s_1271_9));
        // D s_1271_12: lsl s_1271_8 s_1271_6
        let s_1271_12: u64 = s_1271_8 << s_1271_6;
        // D s_1271_13: or s_1271_7 s_1271_12
        let s_1271_13: u64 = ((s_1271_7) | (s_1271_12));
        // D s_1271_14: cmpl s_1271_12
        let s_1271_14: u64 = !s_1271_12;
        // D s_1271_15: and s_1271_7 s_1271_14
        let s_1271_15: u64 = ((s_1271_7) & (s_1271_14));
        // D s_1271_16: select s_1271_11 s_1271_13 s_1271_15
        let s_1271_16: u64 = if s_1271_11 { s_1271_13 } else { s_1271_15 };
        // D s_1271_17: cast trunc s_1271_16 -> u8
        let s_1271_17: bool = ((s_1271_16) != 0);
        // D s_1271_18: cast zx s_1271_17 -> bv
        let s_1271_18: Bits = Bits::new(s_1271_17 as u128, 1u16);
        // C s_1271_19: const #0u : u8
        let s_1271_19: bool = false;
        // C s_1271_20: cast zx s_1271_19 -> bv
        let s_1271_20: Bits = Bits::new(s_1271_19 as u128, 1u16);
        // D s_1271_21: cmp-ne s_1271_18 s_1271_20
        let s_1271_21: bool = ((s_1271_18) != (s_1271_20));
        // D s_1271_22: write-var gs#407275 <= s_1271_21
        fn_state.gs_407275 = s_1271_21;
        // N s_1271_23: jump b1272
        return block_1272(state, tracer, fn_state);
    }
    fn block_1272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1272_0: read-var gs#407275:u8
        let s_1272_0: bool = fn_state.gs_407275;
        // N s_1272_1: branch s_1272_0 b1274 b1273
        if s_1272_0 {
            return block_1274(state, tracer, fn_state);
        } else {
            return block_1273(state, tracer, fn_state);
        };
    }
    fn block_1273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1273_0: read-var u#33095:u8
        let s_1273_0: u8 = fn_state.u_33095;
        // D s_1273_1: read-var u#33096:u8
        let s_1273_1: u8 = fn_state.u_33096;
        // D s_1273_2: read-var u#33097:u8
        let s_1273_2: u8 = fn_state.u_33097;
        // D s_1273_3: read-var u#33098:u8
        let s_1273_3: u8 = fn_state.u_33098;
        // D s_1273_4: read-var u#33099:u8
        let s_1273_4: u8 = fn_state.u_33099;
        // D s_1273_5: call decode_aarch32_instrs_TST_r_A1enc_A_txt(s_1273_0, s_1273_1, s_1273_2, s_1273_3, s_1273_4)
        let s_1273_5: () = decode_aarch32_instrs_TST_r_A1enc_A_txt(
            state,
            tracer,
            s_1273_0,
            s_1273_1,
            s_1273_2,
            s_1273_3,
            s_1273_4,
        );
        // N s_1273_6: return
        return;
    }
    fn block_1274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1274_0: panic
        panic!("{:?}", ());
        // N s_1274_1: return
        return;
    }
    fn block_1275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1275_0: const #1u : u8
        let s_1275_0: bool = true;
        // D s_1275_1: write-var gs#407275 <= s_1275_0
        fn_state.gs_407275 = s_1275_0;
        // N s_1275_2: jump b1272
        return block_1272(state, tracer, fn_state);
    }
    fn block_1276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1276_0: const #1u : u8
        let s_1276_0: bool = true;
        // D s_1276_1: write-var gs#407272 <= s_1276_0
        fn_state.gs_407272 = s_1276_0;
        // N s_1276_2: jump b1270
        return block_1270(state, tracer, fn_state);
    }
    fn block_1277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1277_0: const #1u : u8
        let s_1277_0: bool = true;
        // D s_1277_1: write-var gs#407269 <= s_1277_0
        fn_state.gs_407269 = s_1277_0;
        // N s_1277_2: jump b1268
        return block_1268(state, tracer, fn_state);
    }
    fn block_1278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1278_0: read-var merge#var.1:struct
        let s_1278_0: u32 = fn_state.merge_var._1;
        // D s_1278_1: write-var u#33101 <= s_1278_0
        fn_state.u_33101 = s_1278_0;
        // C s_1278_2: const #20s : i
        let s_1278_2: i128 = 20;
        // D s_1278_3: read-var u#33101:u32
        let s_1278_3: u32 = fn_state.u_33101;
        // D s_1278_4: cast zx s_1278_3 -> bv
        let s_1278_4: Bits = Bits::new(s_1278_3 as u128, 32u16);
        // C s_1278_5: const #1s : i64
        let s_1278_5: i64 = 1;
        // C s_1278_6: cast zx s_1278_5 -> i
        let s_1278_6: i128 = (i128::try_from(s_1278_5).unwrap());
        // C s_1278_7: const #7s : i
        let s_1278_7: i128 = 7;
        // C s_1278_8: add s_1278_7 s_1278_6
        let s_1278_8: i128 = (s_1278_7 + s_1278_6);
        // D s_1278_9: bit-extract s_1278_4 s_1278_2 s_1278_8
        let s_1278_9: Bits = (Bits::new(
            ((s_1278_4) >> (s_1278_2)).value(),
            u16::try_from(s_1278_8).unwrap(),
        ));
        // D s_1278_10: cast reint s_1278_9 -> u8
        let s_1278_10: u8 = (s_1278_9.value() as u8);
        // D s_1278_11: cast zx s_1278_10 -> bv
        let s_1278_11: Bits = Bits::new(s_1278_10 as u128, 8u16);
        // C s_1278_12: const #17u : u8
        let s_1278_12: u8 = 17;
        // C s_1278_13: cast zx s_1278_12 -> bv
        let s_1278_13: Bits = Bits::new(s_1278_12 as u128, 8u16);
        // D s_1278_14: cmp-eq s_1278_11 s_1278_13
        let s_1278_14: bool = ((s_1278_11) == (s_1278_13));
        // N s_1278_15: branch s_1278_14 b2243 b1279
        if s_1278_14 {
            return block_2243(state, tracer, fn_state);
        } else {
            return block_1279(state, tracer, fn_state);
        };
    }
    fn block_1279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1279_0: const #0u : u8
        let s_1279_0: bool = false;
        // D s_1279_1: write-var gs#407287 <= s_1279_0
        fn_state.gs_407287 = s_1279_0;
        // N s_1279_2: jump b1280
        return block_1280(state, tracer, fn_state);
    }
    fn block_1280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1280_0: read-var gs#407287:u8
        let s_1280_0: bool = fn_state.gs_407287;
        // N s_1280_1: branch s_1280_0 b2239 b1281
        if s_1280_0 {
            return block_2239(state, tracer, fn_state);
        } else {
            return block_1281(state, tracer, fn_state);
        };
    }
    fn block_1281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1281_0: const #0u : u8
        let s_1281_0: bool = false;
        // D s_1281_1: write-var gs#407292 <= s_1281_0
        fn_state.gs_407292 = s_1281_0;
        // N s_1281_2: jump b1282
        return block_1282(state, tracer, fn_state);
    }
    fn block_1282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1282_0: read-var gs#407292:u8
        let s_1282_0: bool = fn_state.gs_407292;
        // D s_1282_1: not s_1282_0
        let s_1282_1: bool = !s_1282_0;
        // N s_1282_2: branch s_1282_1 b1295 b1283
        if s_1282_1 {
            return block_1295(state, tracer, fn_state);
        } else {
            return block_1283(state, tracer, fn_state);
        };
    }
    fn block_1283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1283_0: const #3278s : i
        let s_1283_0: i128 = 3278;
        // C s_1283_1: const #14696u : u32
        let s_1283_1: u32 = 14696;
        // N s_1283_2: write-reg s_1283_1 <= s_1283_0
        let s_1283_2: () = {
            state.write_register::<i128>(s_1283_1 as isize, s_1283_0);
            tracer.write_register(s_1283_1 as isize, s_1283_0);
        };
        // C s_1283_3: const #28s : i
        let s_1283_3: i128 = 28;
        // C s_1283_4: const #4s : i
        let s_1283_4: i128 = 4;
        // D s_1283_5: read-var u#33101:u32
        let s_1283_5: u32 = fn_state.u_33101;
        // D s_1283_6: cast zx s_1283_5 -> bv
        let s_1283_6: Bits = Bits::new(s_1283_5 as u128, 32u16);
        // D s_1283_7: bit-extract s_1283_6 s_1283_3 s_1283_4
        let s_1283_7: Bits = (Bits::new(
            ((s_1283_6) >> (s_1283_3)).value(),
            u16::try_from(s_1283_4).unwrap(),
        ));
        // D s_1283_8: cast reint s_1283_7 -> u8
        let s_1283_8: u8 = (s_1283_7.value() as u8);
        // D s_1283_9: write-var u#33102 <= s_1283_8
        fn_state.u_33102 = s_1283_8;
        // C s_1283_10: const #16s : i
        let s_1283_10: i128 = 16;
        // C s_1283_11: const #4s : i
        let s_1283_11: i128 = 4;
        // D s_1283_12: read-var u#33101:u32
        let s_1283_12: u32 = fn_state.u_33101;
        // D s_1283_13: cast zx s_1283_12 -> bv
        let s_1283_13: Bits = Bits::new(s_1283_12 as u128, 32u16);
        // D s_1283_14: bit-extract s_1283_13 s_1283_10 s_1283_11
        let s_1283_14: Bits = (Bits::new(
            ((s_1283_13) >> (s_1283_10)).value(),
            u16::try_from(s_1283_11).unwrap(),
        ));
        // D s_1283_15: cast reint s_1283_14 -> u8
        let s_1283_15: u8 = (s_1283_14.value() as u8);
        // D s_1283_16: write-var u#33103 <= s_1283_15
        fn_state.u_33103 = s_1283_15;
        // C s_1283_17: const #8s : i
        let s_1283_17: i128 = 8;
        // C s_1283_18: const #4s : i
        let s_1283_18: i128 = 4;
        // D s_1283_19: read-var u#33101:u32
        let s_1283_19: u32 = fn_state.u_33101;
        // D s_1283_20: cast zx s_1283_19 -> bv
        let s_1283_20: Bits = Bits::new(s_1283_19 as u128, 32u16);
        // D s_1283_21: bit-extract s_1283_20 s_1283_17 s_1283_18
        let s_1283_21: Bits = (Bits::new(
            ((s_1283_20) >> (s_1283_17)).value(),
            u16::try_from(s_1283_18).unwrap(),
        ));
        // D s_1283_22: cast reint s_1283_21 -> u8
        let s_1283_22: u8 = (s_1283_21.value() as u8);
        // D s_1283_23: write-var u#33104 <= s_1283_22
        fn_state.u_33104 = s_1283_22;
        // C s_1283_24: const #5s : i
        let s_1283_24: i128 = 5;
        // C s_1283_25: const #2s : i
        let s_1283_25: i128 = 2;
        // D s_1283_26: read-var u#33101:u32
        let s_1283_26: u32 = fn_state.u_33101;
        // D s_1283_27: cast zx s_1283_26 -> bv
        let s_1283_27: Bits = Bits::new(s_1283_26 as u128, 32u16);
        // D s_1283_28: bit-extract s_1283_27 s_1283_24 s_1283_25
        let s_1283_28: Bits = (Bits::new(
            ((s_1283_27) >> (s_1283_24)).value(),
            u16::try_from(s_1283_25).unwrap(),
        ));
        // D s_1283_29: cast reint s_1283_28 -> u8
        let s_1283_29: u8 = (s_1283_28.value() as u8);
        // D s_1283_30: write-var u#33105 <= s_1283_29
        fn_state.u_33105 = s_1283_29;
        // C s_1283_31: const #0s : i
        let s_1283_31: i128 = 0;
        // C s_1283_32: const #4s : i
        let s_1283_32: i128 = 4;
        // D s_1283_33: read-var u#33101:u32
        let s_1283_33: u32 = fn_state.u_33101;
        // D s_1283_34: cast zx s_1283_33 -> bv
        let s_1283_34: Bits = Bits::new(s_1283_33 as u128, 32u16);
        // D s_1283_35: bit-extract s_1283_34 s_1283_31 s_1283_32
        let s_1283_35: Bits = (Bits::new(
            ((s_1283_34) >> (s_1283_31)).value(),
            u16::try_from(s_1283_32).unwrap(),
        ));
        // D s_1283_36: cast reint s_1283_35 -> u8
        let s_1283_36: u8 = (s_1283_35.value() as u8);
        // D s_1283_37: write-var u#33106 <= s_1283_36
        fn_state.u_33106 = s_1283_36;
        // C s_1283_38: const #12s : i
        let s_1283_38: i128 = 12;
        // D s_1283_39: read-var u#33101:u32
        let s_1283_39: u32 = fn_state.u_33101;
        // D s_1283_40: cast zx s_1283_39 -> bv
        let s_1283_40: Bits = Bits::new(s_1283_39 as u128, 32u16);
        // C s_1283_41: const #1u : u64
        let s_1283_41: u64 = 1;
        // D s_1283_42: bit-extract s_1283_40 s_1283_38 s_1283_41
        let s_1283_42: Bits = (Bits::new(
            ((s_1283_40) >> (s_1283_38)).value(),
            u16::try_from(s_1283_41).unwrap(),
        ));
        // D s_1283_43: cast reint s_1283_42 -> u8
        let s_1283_43: bool = ((s_1283_42.value()) != 0);
        // C s_1283_44: const #0s : i
        let s_1283_44: i128 = 0;
        // C s_1283_45: const #0u : u64
        let s_1283_45: u64 = 0;
        // D s_1283_46: cast zx s_1283_43 -> u64
        let s_1283_46: u64 = (s_1283_43 as u64);
        // C s_1283_47: const #1u : u64
        let s_1283_47: u64 = 1;
        // D s_1283_48: and s_1283_46 s_1283_47
        let s_1283_48: u64 = ((s_1283_46) & (s_1283_47));
        // D s_1283_49: cmp-eq s_1283_48 s_1283_47
        let s_1283_49: bool = ((s_1283_48) == (s_1283_47));
        // D s_1283_50: lsl s_1283_46 s_1283_44
        let s_1283_50: u64 = s_1283_46 << s_1283_44;
        // D s_1283_51: or s_1283_45 s_1283_50
        let s_1283_51: u64 = ((s_1283_45) | (s_1283_50));
        // D s_1283_52: cmpl s_1283_50
        let s_1283_52: u64 = !s_1283_50;
        // D s_1283_53: and s_1283_45 s_1283_52
        let s_1283_53: u64 = ((s_1283_45) & (s_1283_52));
        // D s_1283_54: select s_1283_49 s_1283_51 s_1283_53
        let s_1283_54: u64 = if s_1283_49 { s_1283_51 } else { s_1283_53 };
        // D s_1283_55: cast trunc s_1283_54 -> u8
        let s_1283_55: bool = ((s_1283_54) != 0);
        // D s_1283_56: cast zx s_1283_55 -> bv
        let s_1283_56: Bits = Bits::new(s_1283_55 as u128, 1u16);
        // C s_1283_57: const #0u : u8
        let s_1283_57: bool = false;
        // C s_1283_58: cast zx s_1283_57 -> bv
        let s_1283_58: Bits = Bits::new(s_1283_57 as u128, 1u16);
        // D s_1283_59: cmp-ne s_1283_56 s_1283_58
        let s_1283_59: bool = ((s_1283_56) != (s_1283_58));
        // N s_1283_60: branch s_1283_59 b1294 b1284
        if s_1283_59 {
            return block_1294(state, tracer, fn_state);
        } else {
            return block_1284(state, tracer, fn_state);
        };
    }
    fn block_1284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1284_0: const #13s : i
        let s_1284_0: i128 = 13;
        // D s_1284_1: read-var u#33101:u32
        let s_1284_1: u32 = fn_state.u_33101;
        // D s_1284_2: cast zx s_1284_1 -> bv
        let s_1284_2: Bits = Bits::new(s_1284_1 as u128, 32u16);
        // C s_1284_3: const #1u : u64
        let s_1284_3: u64 = 1;
        // D s_1284_4: bit-extract s_1284_2 s_1284_0 s_1284_3
        let s_1284_4: Bits = (Bits::new(
            ((s_1284_2) >> (s_1284_0)).value(),
            u16::try_from(s_1284_3).unwrap(),
        ));
        // D s_1284_5: cast reint s_1284_4 -> u8
        let s_1284_5: bool = ((s_1284_4.value()) != 0);
        // C s_1284_6: const #0s : i
        let s_1284_6: i128 = 0;
        // C s_1284_7: const #0u : u64
        let s_1284_7: u64 = 0;
        // D s_1284_8: cast zx s_1284_5 -> u64
        let s_1284_8: u64 = (s_1284_5 as u64);
        // C s_1284_9: const #1u : u64
        let s_1284_9: u64 = 1;
        // D s_1284_10: and s_1284_8 s_1284_9
        let s_1284_10: u64 = ((s_1284_8) & (s_1284_9));
        // D s_1284_11: cmp-eq s_1284_10 s_1284_9
        let s_1284_11: bool = ((s_1284_10) == (s_1284_9));
        // D s_1284_12: lsl s_1284_8 s_1284_6
        let s_1284_12: u64 = s_1284_8 << s_1284_6;
        // D s_1284_13: or s_1284_7 s_1284_12
        let s_1284_13: u64 = ((s_1284_7) | (s_1284_12));
        // D s_1284_14: cmpl s_1284_12
        let s_1284_14: u64 = !s_1284_12;
        // D s_1284_15: and s_1284_7 s_1284_14
        let s_1284_15: u64 = ((s_1284_7) & (s_1284_14));
        // D s_1284_16: select s_1284_11 s_1284_13 s_1284_15
        let s_1284_16: u64 = if s_1284_11 { s_1284_13 } else { s_1284_15 };
        // D s_1284_17: cast trunc s_1284_16 -> u8
        let s_1284_17: bool = ((s_1284_16) != 0);
        // D s_1284_18: cast zx s_1284_17 -> bv
        let s_1284_18: Bits = Bits::new(s_1284_17 as u128, 1u16);
        // C s_1284_19: const #0u : u8
        let s_1284_19: bool = false;
        // C s_1284_20: cast zx s_1284_19 -> bv
        let s_1284_20: Bits = Bits::new(s_1284_19 as u128, 1u16);
        // D s_1284_21: cmp-ne s_1284_18 s_1284_20
        let s_1284_21: bool = ((s_1284_18) != (s_1284_20));
        // D s_1284_22: write-var gs#407309 <= s_1284_21
        fn_state.gs_407309 = s_1284_21;
        // N s_1284_23: jump b1285
        return block_1285(state, tracer, fn_state);
    }
    fn block_1285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1285_0: read-var gs#407309:u8
        let s_1285_0: bool = fn_state.gs_407309;
        // N s_1285_1: branch s_1285_0 b1293 b1286
        if s_1285_0 {
            return block_1293(state, tracer, fn_state);
        } else {
            return block_1286(state, tracer, fn_state);
        };
    }
    fn block_1286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1286_0: const #14s : i
        let s_1286_0: i128 = 14;
        // D s_1286_1: read-var u#33101:u32
        let s_1286_1: u32 = fn_state.u_33101;
        // D s_1286_2: cast zx s_1286_1 -> bv
        let s_1286_2: Bits = Bits::new(s_1286_1 as u128, 32u16);
        // C s_1286_3: const #1u : u64
        let s_1286_3: u64 = 1;
        // D s_1286_4: bit-extract s_1286_2 s_1286_0 s_1286_3
        let s_1286_4: Bits = (Bits::new(
            ((s_1286_2) >> (s_1286_0)).value(),
            u16::try_from(s_1286_3).unwrap(),
        ));
        // D s_1286_5: cast reint s_1286_4 -> u8
        let s_1286_5: bool = ((s_1286_4.value()) != 0);
        // C s_1286_6: const #0s : i
        let s_1286_6: i128 = 0;
        // C s_1286_7: const #0u : u64
        let s_1286_7: u64 = 0;
        // D s_1286_8: cast zx s_1286_5 -> u64
        let s_1286_8: u64 = (s_1286_5 as u64);
        // C s_1286_9: const #1u : u64
        let s_1286_9: u64 = 1;
        // D s_1286_10: and s_1286_8 s_1286_9
        let s_1286_10: u64 = ((s_1286_8) & (s_1286_9));
        // D s_1286_11: cmp-eq s_1286_10 s_1286_9
        let s_1286_11: bool = ((s_1286_10) == (s_1286_9));
        // D s_1286_12: lsl s_1286_8 s_1286_6
        let s_1286_12: u64 = s_1286_8 << s_1286_6;
        // D s_1286_13: or s_1286_7 s_1286_12
        let s_1286_13: u64 = ((s_1286_7) | (s_1286_12));
        // D s_1286_14: cmpl s_1286_12
        let s_1286_14: u64 = !s_1286_12;
        // D s_1286_15: and s_1286_7 s_1286_14
        let s_1286_15: u64 = ((s_1286_7) & (s_1286_14));
        // D s_1286_16: select s_1286_11 s_1286_13 s_1286_15
        let s_1286_16: u64 = if s_1286_11 { s_1286_13 } else { s_1286_15 };
        // D s_1286_17: cast trunc s_1286_16 -> u8
        let s_1286_17: bool = ((s_1286_16) != 0);
        // D s_1286_18: cast zx s_1286_17 -> bv
        let s_1286_18: Bits = Bits::new(s_1286_17 as u128, 1u16);
        // C s_1286_19: const #0u : u8
        let s_1286_19: bool = false;
        // C s_1286_20: cast zx s_1286_19 -> bv
        let s_1286_20: Bits = Bits::new(s_1286_19 as u128, 1u16);
        // D s_1286_21: cmp-ne s_1286_18 s_1286_20
        let s_1286_21: bool = ((s_1286_18) != (s_1286_20));
        // D s_1286_22: write-var gs#407312 <= s_1286_21
        fn_state.gs_407312 = s_1286_21;
        // N s_1286_23: jump b1287
        return block_1287(state, tracer, fn_state);
    }
    fn block_1287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1287_0: read-var gs#407312:u8
        let s_1287_0: bool = fn_state.gs_407312;
        // N s_1287_1: branch s_1287_0 b1292 b1288
        if s_1287_0 {
            return block_1292(state, tracer, fn_state);
        } else {
            return block_1288(state, tracer, fn_state);
        };
    }
    fn block_1288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1288_0: const #15s : i
        let s_1288_0: i128 = 15;
        // D s_1288_1: read-var u#33101:u32
        let s_1288_1: u32 = fn_state.u_33101;
        // D s_1288_2: cast zx s_1288_1 -> bv
        let s_1288_2: Bits = Bits::new(s_1288_1 as u128, 32u16);
        // C s_1288_3: const #1u : u64
        let s_1288_3: u64 = 1;
        // D s_1288_4: bit-extract s_1288_2 s_1288_0 s_1288_3
        let s_1288_4: Bits = (Bits::new(
            ((s_1288_2) >> (s_1288_0)).value(),
            u16::try_from(s_1288_3).unwrap(),
        ));
        // D s_1288_5: cast reint s_1288_4 -> u8
        let s_1288_5: bool = ((s_1288_4.value()) != 0);
        // C s_1288_6: const #0s : i
        let s_1288_6: i128 = 0;
        // C s_1288_7: const #0u : u64
        let s_1288_7: u64 = 0;
        // D s_1288_8: cast zx s_1288_5 -> u64
        let s_1288_8: u64 = (s_1288_5 as u64);
        // C s_1288_9: const #1u : u64
        let s_1288_9: u64 = 1;
        // D s_1288_10: and s_1288_8 s_1288_9
        let s_1288_10: u64 = ((s_1288_8) & (s_1288_9));
        // D s_1288_11: cmp-eq s_1288_10 s_1288_9
        let s_1288_11: bool = ((s_1288_10) == (s_1288_9));
        // D s_1288_12: lsl s_1288_8 s_1288_6
        let s_1288_12: u64 = s_1288_8 << s_1288_6;
        // D s_1288_13: or s_1288_7 s_1288_12
        let s_1288_13: u64 = ((s_1288_7) | (s_1288_12));
        // D s_1288_14: cmpl s_1288_12
        let s_1288_14: u64 = !s_1288_12;
        // D s_1288_15: and s_1288_7 s_1288_14
        let s_1288_15: u64 = ((s_1288_7) & (s_1288_14));
        // D s_1288_16: select s_1288_11 s_1288_13 s_1288_15
        let s_1288_16: u64 = if s_1288_11 { s_1288_13 } else { s_1288_15 };
        // D s_1288_17: cast trunc s_1288_16 -> u8
        let s_1288_17: bool = ((s_1288_16) != 0);
        // D s_1288_18: cast zx s_1288_17 -> bv
        let s_1288_18: Bits = Bits::new(s_1288_17 as u128, 1u16);
        // C s_1288_19: const #0u : u8
        let s_1288_19: bool = false;
        // C s_1288_20: cast zx s_1288_19 -> bv
        let s_1288_20: Bits = Bits::new(s_1288_19 as u128, 1u16);
        // D s_1288_21: cmp-ne s_1288_18 s_1288_20
        let s_1288_21: bool = ((s_1288_18) != (s_1288_20));
        // D s_1288_22: write-var gs#407315 <= s_1288_21
        fn_state.gs_407315 = s_1288_21;
        // N s_1288_23: jump b1289
        return block_1289(state, tracer, fn_state);
    }
    fn block_1289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1289_0: read-var gs#407315:u8
        let s_1289_0: bool = fn_state.gs_407315;
        // N s_1289_1: branch s_1289_0 b1291 b1290
        if s_1289_0 {
            return block_1291(state, tracer, fn_state);
        } else {
            return block_1290(state, tracer, fn_state);
        };
    }
    fn block_1290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1290_0: read-var u#33102:u8
        let s_1290_0: u8 = fn_state.u_33102;
        // D s_1290_1: read-var u#33103:u8
        let s_1290_1: u8 = fn_state.u_33103;
        // D s_1290_2: read-var u#33104:u8
        let s_1290_2: u8 = fn_state.u_33104;
        // D s_1290_3: read-var u#33105:u8
        let s_1290_3: u8 = fn_state.u_33105;
        // D s_1290_4: read-var u#33106:u8
        let s_1290_4: u8 = fn_state.u_33106;
        // D s_1290_5: call decode_aarch32_instrs_TST_rr_A1enc_A_txt(s_1290_0, s_1290_1, s_1290_2, s_1290_3, s_1290_4)
        let s_1290_5: () = decode_aarch32_instrs_TST_rr_A1enc_A_txt(
            state,
            tracer,
            s_1290_0,
            s_1290_1,
            s_1290_2,
            s_1290_3,
            s_1290_4,
        );
        // N s_1290_6: return
        return;
    }
    fn block_1291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1291_0: panic
        panic!("{:?}", ());
        // N s_1291_1: return
        return;
    }
    fn block_1292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1292_0: const #1u : u8
        let s_1292_0: bool = true;
        // D s_1292_1: write-var gs#407315 <= s_1292_0
        fn_state.gs_407315 = s_1292_0;
        // N s_1292_2: jump b1289
        return block_1289(state, tracer, fn_state);
    }
    fn block_1293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1293_0: const #1u : u8
        let s_1293_0: bool = true;
        // D s_1293_1: write-var gs#407312 <= s_1293_0
        fn_state.gs_407312 = s_1293_0;
        // N s_1293_2: jump b1287
        return block_1287(state, tracer, fn_state);
    }
    fn block_1294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1294_0: const #1u : u8
        let s_1294_0: bool = true;
        // D s_1294_1: write-var gs#407309 <= s_1294_0
        fn_state.gs_407309 = s_1294_0;
        // N s_1294_2: jump b1285
        return block_1285(state, tracer, fn_state);
    }
    fn block_1295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1295_0: read-var merge#var.1:struct
        let s_1295_0: u32 = fn_state.merge_var._1;
        // D s_1295_1: write-var u#33108 <= s_1295_0
        fn_state.u_33108 = s_1295_0;
        // C s_1295_2: const #20s : i
        let s_1295_2: i128 = 20;
        // D s_1295_3: read-var u#33108:u32
        let s_1295_3: u32 = fn_state.u_33108;
        // D s_1295_4: cast zx s_1295_3 -> bv
        let s_1295_4: Bits = Bits::new(s_1295_3 as u128, 32u16);
        // C s_1295_5: const #1s : i64
        let s_1295_5: i64 = 1;
        // C s_1295_6: cast zx s_1295_5 -> i
        let s_1295_6: i128 = (i128::try_from(s_1295_5).unwrap());
        // C s_1295_7: const #7s : i
        let s_1295_7: i128 = 7;
        // C s_1295_8: add s_1295_7 s_1295_6
        let s_1295_8: i128 = (s_1295_7 + s_1295_6);
        // D s_1295_9: bit-extract s_1295_4 s_1295_2 s_1295_8
        let s_1295_9: Bits = (Bits::new(
            ((s_1295_4) >> (s_1295_2)).value(),
            u16::try_from(s_1295_8).unwrap(),
        ));
        // D s_1295_10: cast reint s_1295_9 -> u8
        let s_1295_10: u8 = (s_1295_9.value() as u8);
        // D s_1295_11: cast zx s_1295_10 -> bv
        let s_1295_11: Bits = Bits::new(s_1295_10 as u128, 8u16);
        // C s_1295_12: const #4u : u8
        let s_1295_12: u8 = 4;
        // C s_1295_13: cast zx s_1295_12 -> bv
        let s_1295_13: Bits = Bits::new(s_1295_12 as u128, 8u16);
        // D s_1295_14: cmp-eq s_1295_11 s_1295_13
        let s_1295_14: bool = ((s_1295_11) == (s_1295_13));
        // N s_1295_15: branch s_1295_14 b2238 b1296
        if s_1295_14 {
            return block_2238(state, tracer, fn_state);
        } else {
            return block_1296(state, tracer, fn_state);
        };
    }
    fn block_1296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1296_0: const #0u : u8
        let s_1296_0: bool = false;
        // D s_1296_1: write-var gs#407321 <= s_1296_0
        fn_state.gs_407321 = s_1296_0;
        // N s_1296_2: jump b1297
        return block_1297(state, tracer, fn_state);
    }
    fn block_1297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1297_0: read-var gs#407321:u8
        let s_1297_0: bool = fn_state.gs_407321;
        // N s_1297_1: branch s_1297_0 b2234 b1298
        if s_1297_0 {
            return block_2234(state, tracer, fn_state);
        } else {
            return block_1298(state, tracer, fn_state);
        };
    }
    fn block_1298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1298_0: const #0u : u8
        let s_1298_0: bool = false;
        // D s_1298_1: write-var gs#407326 <= s_1298_0
        fn_state.gs_407326 = s_1298_0;
        // N s_1298_2: jump b1299
        return block_1299(state, tracer, fn_state);
    }
    fn block_1299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1299_0: read-var gs#407326:u8
        let s_1299_0: bool = fn_state.gs_407326;
        // D s_1299_1: not s_1299_0
        let s_1299_1: bool = !s_1299_0;
        // N s_1299_2: branch s_1299_1 b1301 b1300
        if s_1299_1 {
            return block_1301(state, tracer, fn_state);
        } else {
            return block_1300(state, tracer, fn_state);
        };
    }
    fn block_1300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1300_0: const #3304s : i
        let s_1300_0: i128 = 3304;
        // C s_1300_1: const #14696u : u32
        let s_1300_1: u32 = 14696;
        // N s_1300_2: write-reg s_1300_1 <= s_1300_0
        let s_1300_2: () = {
            state.write_register::<i128>(s_1300_1 as isize, s_1300_0);
            tracer.write_register(s_1300_1 as isize, s_1300_0);
        };
        // C s_1300_3: const #28s : i
        let s_1300_3: i128 = 28;
        // C s_1300_4: const #4s : i
        let s_1300_4: i128 = 4;
        // D s_1300_5: read-var u#33108:u32
        let s_1300_5: u32 = fn_state.u_33108;
        // D s_1300_6: cast zx s_1300_5 -> bv
        let s_1300_6: Bits = Bits::new(s_1300_5 as u128, 32u16);
        // D s_1300_7: bit-extract s_1300_6 s_1300_3 s_1300_4
        let s_1300_7: Bits = (Bits::new(
            ((s_1300_6) >> (s_1300_3)).value(),
            u16::try_from(s_1300_4).unwrap(),
        ));
        // D s_1300_8: cast reint s_1300_7 -> u8
        let s_1300_8: u8 = (s_1300_7.value() as u8);
        // C s_1300_9: const #16s : i
        let s_1300_9: i128 = 16;
        // C s_1300_10: const #4s : i
        let s_1300_10: i128 = 4;
        // D s_1300_11: read-var u#33108:u32
        let s_1300_11: u32 = fn_state.u_33108;
        // D s_1300_12: cast zx s_1300_11 -> bv
        let s_1300_12: Bits = Bits::new(s_1300_11 as u128, 32u16);
        // D s_1300_13: bit-extract s_1300_12 s_1300_9 s_1300_10
        let s_1300_13: Bits = (Bits::new(
            ((s_1300_12) >> (s_1300_9)).value(),
            u16::try_from(s_1300_10).unwrap(),
        ));
        // D s_1300_14: cast reint s_1300_13 -> u8
        let s_1300_14: u8 = (s_1300_13.value() as u8);
        // C s_1300_15: const #12s : i
        let s_1300_15: i128 = 12;
        // C s_1300_16: const #4s : i
        let s_1300_16: i128 = 4;
        // D s_1300_17: read-var u#33108:u32
        let s_1300_17: u32 = fn_state.u_33108;
        // D s_1300_18: cast zx s_1300_17 -> bv
        let s_1300_18: Bits = Bits::new(s_1300_17 as u128, 32u16);
        // D s_1300_19: bit-extract s_1300_18 s_1300_15 s_1300_16
        let s_1300_19: Bits = (Bits::new(
            ((s_1300_18) >> (s_1300_15)).value(),
            u16::try_from(s_1300_16).unwrap(),
        ));
        // D s_1300_20: cast reint s_1300_19 -> u8
        let s_1300_20: u8 = (s_1300_19.value() as u8);
        // C s_1300_21: const #8s : i
        let s_1300_21: i128 = 8;
        // C s_1300_22: const #4s : i
        let s_1300_22: i128 = 4;
        // D s_1300_23: read-var u#33108:u32
        let s_1300_23: u32 = fn_state.u_33108;
        // D s_1300_24: cast zx s_1300_23 -> bv
        let s_1300_24: Bits = Bits::new(s_1300_23 as u128, 32u16);
        // D s_1300_25: bit-extract s_1300_24 s_1300_21 s_1300_22
        let s_1300_25: Bits = (Bits::new(
            ((s_1300_24) >> (s_1300_21)).value(),
            u16::try_from(s_1300_22).unwrap(),
        ));
        // D s_1300_26: cast reint s_1300_25 -> u8
        let s_1300_26: u8 = (s_1300_25.value() as u8);
        // C s_1300_27: const #0s : i
        let s_1300_27: i128 = 0;
        // C s_1300_28: const #4s : i
        let s_1300_28: i128 = 4;
        // D s_1300_29: read-var u#33108:u32
        let s_1300_29: u32 = fn_state.u_33108;
        // D s_1300_30: cast zx s_1300_29 -> bv
        let s_1300_30: Bits = Bits::new(s_1300_29 as u128, 32u16);
        // D s_1300_31: bit-extract s_1300_30 s_1300_27 s_1300_28
        let s_1300_31: Bits = (Bits::new(
            ((s_1300_30) >> (s_1300_27)).value(),
            u16::try_from(s_1300_28).unwrap(),
        ));
        // D s_1300_32: cast reint s_1300_31 -> u8
        let s_1300_32: u8 = (s_1300_31.value() as u8);
        // D s_1300_33: call decode_aarch32_instrs_UMAAL_A1enc_A_txt(s_1300_8, s_1300_14, s_1300_20, s_1300_26, s_1300_32)
        let s_1300_33: () = decode_aarch32_instrs_UMAAL_A1enc_A_txt(
            state,
            tracer,
            s_1300_8,
            s_1300_14,
            s_1300_20,
            s_1300_26,
            s_1300_32,
        );
        // N s_1300_34: return
        return;
    }
    fn block_1301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1301_0: read-var merge#var.1:struct
        let s_1301_0: u32 = fn_state.merge_var._1;
        // D s_1301_1: write-var u#33115 <= s_1301_0
        fn_state.u_33115 = s_1301_0;
        // C s_1301_2: const #21s : i
        let s_1301_2: i128 = 21;
        // D s_1301_3: read-var u#33115:u32
        let s_1301_3: u32 = fn_state.u_33115;
        // D s_1301_4: cast zx s_1301_3 -> bv
        let s_1301_4: Bits = Bits::new(s_1301_3 as u128, 32u16);
        // C s_1301_5: const #1s : i64
        let s_1301_5: i64 = 1;
        // C s_1301_6: cast zx s_1301_5 -> i
        let s_1301_6: i128 = (i128::try_from(s_1301_5).unwrap());
        // C s_1301_7: const #6s : i
        let s_1301_7: i128 = 6;
        // C s_1301_8: add s_1301_7 s_1301_6
        let s_1301_8: i128 = (s_1301_7 + s_1301_6);
        // D s_1301_9: bit-extract s_1301_4 s_1301_2 s_1301_8
        let s_1301_9: Bits = (Bits::new(
            ((s_1301_4) >> (s_1301_2)).value(),
            u16::try_from(s_1301_8).unwrap(),
        ));
        // D s_1301_10: cast reint s_1301_9 -> u8
        let s_1301_10: u8 = (s_1301_9.value() as u8);
        // D s_1301_11: cast zx s_1301_10 -> bv
        let s_1301_11: Bits = Bits::new(s_1301_10 as u128, 7u16);
        // C s_1301_12: const #5u : u8
        let s_1301_12: u8 = 5;
        // C s_1301_13: cast zx s_1301_12 -> bv
        let s_1301_13: Bits = Bits::new(s_1301_12 as u128, 7u16);
        // D s_1301_14: cmp-eq s_1301_11 s_1301_13
        let s_1301_14: bool = ((s_1301_11) == (s_1301_13));
        // N s_1301_15: branch s_1301_14 b2233 b1302
        if s_1301_14 {
            return block_2233(state, tracer, fn_state);
        } else {
            return block_1302(state, tracer, fn_state);
        };
    }
    fn block_1302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1302_0: const #0u : u8
        let s_1302_0: bool = false;
        // D s_1302_1: write-var gs#407344 <= s_1302_0
        fn_state.gs_407344 = s_1302_0;
        // N s_1302_2: jump b1303
        return block_1303(state, tracer, fn_state);
    }
    fn block_1303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1303_0: read-var gs#407344:u8
        let s_1303_0: bool = fn_state.gs_407344;
        // N s_1303_1: branch s_1303_0 b2229 b1304
        if s_1303_0 {
            return block_2229(state, tracer, fn_state);
        } else {
            return block_1304(state, tracer, fn_state);
        };
    }
    fn block_1304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1304_0: const #0u : u8
        let s_1304_0: bool = false;
        // D s_1304_1: write-var gs#407349 <= s_1304_0
        fn_state.gs_407349 = s_1304_0;
        // N s_1304_2: jump b1305
        return block_1305(state, tracer, fn_state);
    }
    fn block_1305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1305_0: read-var gs#407349:u8
        let s_1305_0: bool = fn_state.gs_407349;
        // D s_1305_1: not s_1305_0
        let s_1305_1: bool = !s_1305_0;
        // N s_1305_2: branch s_1305_1 b1307 b1306
        if s_1305_1 {
            return block_1307(state, tracer, fn_state);
        } else {
            return block_1306(state, tracer, fn_state);
        };
    }
    fn block_1306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1306_0: const #3306s : i
        let s_1306_0: i128 = 3306;
        // C s_1306_1: const #14696u : u32
        let s_1306_1: u32 = 14696;
        // N s_1306_2: write-reg s_1306_1 <= s_1306_0
        let s_1306_2: () = {
            state.write_register::<i128>(s_1306_1 as isize, s_1306_0);
            tracer.write_register(s_1306_1 as isize, s_1306_0);
        };
        // C s_1306_3: const #28s : i
        let s_1306_3: i128 = 28;
        // C s_1306_4: const #4s : i
        let s_1306_4: i128 = 4;
        // D s_1306_5: read-var u#33115:u32
        let s_1306_5: u32 = fn_state.u_33115;
        // D s_1306_6: cast zx s_1306_5 -> bv
        let s_1306_6: Bits = Bits::new(s_1306_5 as u128, 32u16);
        // D s_1306_7: bit-extract s_1306_6 s_1306_3 s_1306_4
        let s_1306_7: Bits = (Bits::new(
            ((s_1306_6) >> (s_1306_3)).value(),
            u16::try_from(s_1306_4).unwrap(),
        ));
        // D s_1306_8: cast reint s_1306_7 -> u8
        let s_1306_8: u8 = (s_1306_7.value() as u8);
        // C s_1306_9: const #20s : i
        let s_1306_9: i128 = 20;
        // C s_1306_10: const #1s : i
        let s_1306_10: i128 = 1;
        // D s_1306_11: read-var u#33115:u32
        let s_1306_11: u32 = fn_state.u_33115;
        // D s_1306_12: cast zx s_1306_11 -> bv
        let s_1306_12: Bits = Bits::new(s_1306_11 as u128, 32u16);
        // D s_1306_13: bit-extract s_1306_12 s_1306_9 s_1306_10
        let s_1306_13: Bits = (Bits::new(
            ((s_1306_12) >> (s_1306_9)).value(),
            u16::try_from(s_1306_10).unwrap(),
        ));
        // D s_1306_14: cast reint s_1306_13 -> u8
        let s_1306_14: bool = ((s_1306_13.value()) != 0);
        // C s_1306_15: const #16s : i
        let s_1306_15: i128 = 16;
        // C s_1306_16: const #4s : i
        let s_1306_16: i128 = 4;
        // D s_1306_17: read-var u#33115:u32
        let s_1306_17: u32 = fn_state.u_33115;
        // D s_1306_18: cast zx s_1306_17 -> bv
        let s_1306_18: Bits = Bits::new(s_1306_17 as u128, 32u16);
        // D s_1306_19: bit-extract s_1306_18 s_1306_15 s_1306_16
        let s_1306_19: Bits = (Bits::new(
            ((s_1306_18) >> (s_1306_15)).value(),
            u16::try_from(s_1306_16).unwrap(),
        ));
        // D s_1306_20: cast reint s_1306_19 -> u8
        let s_1306_20: u8 = (s_1306_19.value() as u8);
        // C s_1306_21: const #12s : i
        let s_1306_21: i128 = 12;
        // C s_1306_22: const #4s : i
        let s_1306_22: i128 = 4;
        // D s_1306_23: read-var u#33115:u32
        let s_1306_23: u32 = fn_state.u_33115;
        // D s_1306_24: cast zx s_1306_23 -> bv
        let s_1306_24: Bits = Bits::new(s_1306_23 as u128, 32u16);
        // D s_1306_25: bit-extract s_1306_24 s_1306_21 s_1306_22
        let s_1306_25: Bits = (Bits::new(
            ((s_1306_24) >> (s_1306_21)).value(),
            u16::try_from(s_1306_22).unwrap(),
        ));
        // D s_1306_26: cast reint s_1306_25 -> u8
        let s_1306_26: u8 = (s_1306_25.value() as u8);
        // C s_1306_27: const #8s : i
        let s_1306_27: i128 = 8;
        // C s_1306_28: const #4s : i
        let s_1306_28: i128 = 4;
        // D s_1306_29: read-var u#33115:u32
        let s_1306_29: u32 = fn_state.u_33115;
        // D s_1306_30: cast zx s_1306_29 -> bv
        let s_1306_30: Bits = Bits::new(s_1306_29 as u128, 32u16);
        // D s_1306_31: bit-extract s_1306_30 s_1306_27 s_1306_28
        let s_1306_31: Bits = (Bits::new(
            ((s_1306_30) >> (s_1306_27)).value(),
            u16::try_from(s_1306_28).unwrap(),
        ));
        // D s_1306_32: cast reint s_1306_31 -> u8
        let s_1306_32: u8 = (s_1306_31.value() as u8);
        // C s_1306_33: const #0s : i
        let s_1306_33: i128 = 0;
        // C s_1306_34: const #4s : i
        let s_1306_34: i128 = 4;
        // D s_1306_35: read-var u#33115:u32
        let s_1306_35: u32 = fn_state.u_33115;
        // D s_1306_36: cast zx s_1306_35 -> bv
        let s_1306_36: Bits = Bits::new(s_1306_35 as u128, 32u16);
        // D s_1306_37: bit-extract s_1306_36 s_1306_33 s_1306_34
        let s_1306_37: Bits = (Bits::new(
            ((s_1306_36) >> (s_1306_33)).value(),
            u16::try_from(s_1306_34).unwrap(),
        ));
        // D s_1306_38: cast reint s_1306_37 -> u8
        let s_1306_38: u8 = (s_1306_37.value() as u8);
        // D s_1306_39: call decode_aarch32_instrs_UMLAL_A1enc_A_txt(s_1306_8, s_1306_14, s_1306_20, s_1306_26, s_1306_32, s_1306_38)
        let s_1306_39: () = decode_aarch32_instrs_UMLAL_A1enc_A_txt(
            state,
            tracer,
            s_1306_8,
            s_1306_14,
            s_1306_20,
            s_1306_26,
            s_1306_32,
            s_1306_38,
        );
        // N s_1306_40: return
        return;
    }
    fn block_1307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1307_0: read-var merge#var.1:struct
        let s_1307_0: u32 = fn_state.merge_var._1;
        // D s_1307_1: write-var u#33123 <= s_1307_0
        fn_state.u_33123 = s_1307_0;
        // C s_1307_2: const #21s : i
        let s_1307_2: i128 = 21;
        // D s_1307_3: read-var u#33123:u32
        let s_1307_3: u32 = fn_state.u_33123;
        // D s_1307_4: cast zx s_1307_3 -> bv
        let s_1307_4: Bits = Bits::new(s_1307_3 as u128, 32u16);
        // C s_1307_5: const #1s : i64
        let s_1307_5: i64 = 1;
        // C s_1307_6: cast zx s_1307_5 -> i
        let s_1307_6: i128 = (i128::try_from(s_1307_5).unwrap());
        // C s_1307_7: const #6s : i
        let s_1307_7: i128 = 6;
        // C s_1307_8: add s_1307_7 s_1307_6
        let s_1307_8: i128 = (s_1307_7 + s_1307_6);
        // D s_1307_9: bit-extract s_1307_4 s_1307_2 s_1307_8
        let s_1307_9: Bits = (Bits::new(
            ((s_1307_4) >> (s_1307_2)).value(),
            u16::try_from(s_1307_8).unwrap(),
        ));
        // D s_1307_10: cast reint s_1307_9 -> u8
        let s_1307_10: u8 = (s_1307_9.value() as u8);
        // D s_1307_11: cast zx s_1307_10 -> bv
        let s_1307_11: Bits = Bits::new(s_1307_10 as u128, 7u16);
        // C s_1307_12: const #4u : u8
        let s_1307_12: u8 = 4;
        // C s_1307_13: cast zx s_1307_12 -> bv
        let s_1307_13: Bits = Bits::new(s_1307_12 as u128, 7u16);
        // D s_1307_14: cmp-eq s_1307_11 s_1307_13
        let s_1307_14: bool = ((s_1307_11) == (s_1307_13));
        // N s_1307_15: branch s_1307_14 b2228 b1308
        if s_1307_14 {
            return block_2228(state, tracer, fn_state);
        } else {
            return block_1308(state, tracer, fn_state);
        };
    }
    fn block_1308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1308_0: const #0u : u8
        let s_1308_0: bool = false;
        // D s_1308_1: write-var gs#407369 <= s_1308_0
        fn_state.gs_407369 = s_1308_0;
        // N s_1308_2: jump b1309
        return block_1309(state, tracer, fn_state);
    }
    fn block_1309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1309_0: read-var gs#407369:u8
        let s_1309_0: bool = fn_state.gs_407369;
        // N s_1309_1: branch s_1309_0 b2224 b1310
        if s_1309_0 {
            return block_2224(state, tracer, fn_state);
        } else {
            return block_1310(state, tracer, fn_state);
        };
    }
    fn block_1310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1310_0: const #0u : u8
        let s_1310_0: bool = false;
        // D s_1310_1: write-var gs#407374 <= s_1310_0
        fn_state.gs_407374 = s_1310_0;
        // N s_1310_2: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_1311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1311_0: read-var gs#407374:u8
        let s_1311_0: bool = fn_state.gs_407374;
        // D s_1311_1: not s_1311_0
        let s_1311_1: bool = !s_1311_0;
        // N s_1311_2: branch s_1311_1 b1313 b1312
        if s_1311_1 {
            return block_1313(state, tracer, fn_state);
        } else {
            return block_1312(state, tracer, fn_state);
        };
    }
    fn block_1312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1312_0: const #3308s : i
        let s_1312_0: i128 = 3308;
        // C s_1312_1: const #14696u : u32
        let s_1312_1: u32 = 14696;
        // N s_1312_2: write-reg s_1312_1 <= s_1312_0
        let s_1312_2: () = {
            state.write_register::<i128>(s_1312_1 as isize, s_1312_0);
            tracer.write_register(s_1312_1 as isize, s_1312_0);
        };
        // C s_1312_3: const #28s : i
        let s_1312_3: i128 = 28;
        // C s_1312_4: const #4s : i
        let s_1312_4: i128 = 4;
        // D s_1312_5: read-var u#33123:u32
        let s_1312_5: u32 = fn_state.u_33123;
        // D s_1312_6: cast zx s_1312_5 -> bv
        let s_1312_6: Bits = Bits::new(s_1312_5 as u128, 32u16);
        // D s_1312_7: bit-extract s_1312_6 s_1312_3 s_1312_4
        let s_1312_7: Bits = (Bits::new(
            ((s_1312_6) >> (s_1312_3)).value(),
            u16::try_from(s_1312_4).unwrap(),
        ));
        // D s_1312_8: cast reint s_1312_7 -> u8
        let s_1312_8: u8 = (s_1312_7.value() as u8);
        // C s_1312_9: const #20s : i
        let s_1312_9: i128 = 20;
        // C s_1312_10: const #1s : i
        let s_1312_10: i128 = 1;
        // D s_1312_11: read-var u#33123:u32
        let s_1312_11: u32 = fn_state.u_33123;
        // D s_1312_12: cast zx s_1312_11 -> bv
        let s_1312_12: Bits = Bits::new(s_1312_11 as u128, 32u16);
        // D s_1312_13: bit-extract s_1312_12 s_1312_9 s_1312_10
        let s_1312_13: Bits = (Bits::new(
            ((s_1312_12) >> (s_1312_9)).value(),
            u16::try_from(s_1312_10).unwrap(),
        ));
        // D s_1312_14: cast reint s_1312_13 -> u8
        let s_1312_14: bool = ((s_1312_13.value()) != 0);
        // C s_1312_15: const #16s : i
        let s_1312_15: i128 = 16;
        // C s_1312_16: const #4s : i
        let s_1312_16: i128 = 4;
        // D s_1312_17: read-var u#33123:u32
        let s_1312_17: u32 = fn_state.u_33123;
        // D s_1312_18: cast zx s_1312_17 -> bv
        let s_1312_18: Bits = Bits::new(s_1312_17 as u128, 32u16);
        // D s_1312_19: bit-extract s_1312_18 s_1312_15 s_1312_16
        let s_1312_19: Bits = (Bits::new(
            ((s_1312_18) >> (s_1312_15)).value(),
            u16::try_from(s_1312_16).unwrap(),
        ));
        // D s_1312_20: cast reint s_1312_19 -> u8
        let s_1312_20: u8 = (s_1312_19.value() as u8);
        // C s_1312_21: const #12s : i
        let s_1312_21: i128 = 12;
        // C s_1312_22: const #4s : i
        let s_1312_22: i128 = 4;
        // D s_1312_23: read-var u#33123:u32
        let s_1312_23: u32 = fn_state.u_33123;
        // D s_1312_24: cast zx s_1312_23 -> bv
        let s_1312_24: Bits = Bits::new(s_1312_23 as u128, 32u16);
        // D s_1312_25: bit-extract s_1312_24 s_1312_21 s_1312_22
        let s_1312_25: Bits = (Bits::new(
            ((s_1312_24) >> (s_1312_21)).value(),
            u16::try_from(s_1312_22).unwrap(),
        ));
        // D s_1312_26: cast reint s_1312_25 -> u8
        let s_1312_26: u8 = (s_1312_25.value() as u8);
        // C s_1312_27: const #8s : i
        let s_1312_27: i128 = 8;
        // C s_1312_28: const #4s : i
        let s_1312_28: i128 = 4;
        // D s_1312_29: read-var u#33123:u32
        let s_1312_29: u32 = fn_state.u_33123;
        // D s_1312_30: cast zx s_1312_29 -> bv
        let s_1312_30: Bits = Bits::new(s_1312_29 as u128, 32u16);
        // D s_1312_31: bit-extract s_1312_30 s_1312_27 s_1312_28
        let s_1312_31: Bits = (Bits::new(
            ((s_1312_30) >> (s_1312_27)).value(),
            u16::try_from(s_1312_28).unwrap(),
        ));
        // D s_1312_32: cast reint s_1312_31 -> u8
        let s_1312_32: u8 = (s_1312_31.value() as u8);
        // C s_1312_33: const #0s : i
        let s_1312_33: i128 = 0;
        // C s_1312_34: const #4s : i
        let s_1312_34: i128 = 4;
        // D s_1312_35: read-var u#33123:u32
        let s_1312_35: u32 = fn_state.u_33123;
        // D s_1312_36: cast zx s_1312_35 -> bv
        let s_1312_36: Bits = Bits::new(s_1312_35 as u128, 32u16);
        // D s_1312_37: bit-extract s_1312_36 s_1312_33 s_1312_34
        let s_1312_37: Bits = (Bits::new(
            ((s_1312_36) >> (s_1312_33)).value(),
            u16::try_from(s_1312_34).unwrap(),
        ));
        // D s_1312_38: cast reint s_1312_37 -> u8
        let s_1312_38: u8 = (s_1312_37.value() as u8);
        // D s_1312_39: call decode_aarch32_instrs_UMULL_A1enc_A_txt(s_1312_8, s_1312_14, s_1312_20, s_1312_26, s_1312_32, s_1312_38)
        let s_1312_39: () = decode_aarch32_instrs_UMULL_A1enc_A_txt(
            state,
            tracer,
            s_1312_8,
            s_1312_14,
            s_1312_20,
            s_1312_26,
            s_1312_32,
            s_1312_38,
        );
        // N s_1312_40: return
        return;
    }
    fn block_1313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1313_0: read-var merge#var.1:struct
        let s_1313_0: u32 = fn_state.merge_var._1;
        // D s_1313_1: write-var u#33131 <= s_1313_0
        fn_state.u_33131 = s_1313_0;
        // C s_1313_2: const #0s : i
        let s_1313_2: i128 = 0;
        // D s_1313_3: read-var u#33131:u32
        let s_1313_3: u32 = fn_state.u_33131;
        // D s_1313_4: cast zx s_1313_3 -> bv
        let s_1313_4: Bits = Bits::new(s_1313_3 as u128, 32u16);
        // C s_1313_5: const #1s : i64
        let s_1313_5: i64 = 1;
        // C s_1313_6: cast zx s_1313_5 -> i
        let s_1313_6: i128 = (i128::try_from(s_1313_5).unwrap());
        // C s_1313_7: const #27s : i
        let s_1313_7: i128 = 27;
        // C s_1313_8: add s_1313_7 s_1313_6
        let s_1313_8: i128 = (s_1313_7 + s_1313_6);
        // D s_1313_9: bit-extract s_1313_4 s_1313_2 s_1313_8
        let s_1313_9: Bits = (Bits::new(
            ((s_1313_4) >> (s_1313_2)).value(),
            u16::try_from(s_1313_8).unwrap(),
        ));
        // D s_1313_10: cast reint s_1313_9 -> u28
        let s_1313_10: u32 = (s_1313_9.value() as u32);
        // D s_1313_11: cast zx s_1313_10 -> bv
        let s_1313_11: Bits = Bits::new(s_1313_10 as u128, 28u16);
        // C s_1313_12: const #52490242u : u28
        let s_1313_12: u32 = 52490242;
        // C s_1313_13: cast zx s_1313_12 -> bv
        let s_1313_13: Bits = Bits::new(s_1313_12 as u128, 28u16);
        // D s_1313_14: cmp-eq s_1313_11 s_1313_13
        let s_1313_14: bool = ((s_1313_11) == (s_1313_13));
        // N s_1313_15: branch s_1313_14 b2220 b1314
        if s_1313_14 {
            return block_2220(state, tracer, fn_state);
        } else {
            return block_1314(state, tracer, fn_state);
        };
    }
    fn block_1314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1314_0: const #0u : u8
        let s_1314_0: bool = false;
        // D s_1314_1: write-var gs#407396 <= s_1314_0
        fn_state.gs_407396 = s_1314_0;
        // N s_1314_2: jump b1315
        return block_1315(state, tracer, fn_state);
    }
    fn block_1315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1315_0: read-var gs#407396:u8
        let s_1315_0: bool = fn_state.gs_407396;
        // D s_1315_1: not s_1315_0
        let s_1315_1: bool = !s_1315_0;
        // N s_1315_2: branch s_1315_1 b1340 b1316
        if s_1315_1 {
            return block_1340(state, tracer, fn_state);
        } else {
            return block_1316(state, tracer, fn_state);
        };
    }
    fn block_1316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1316_0: const #3760s : i
        let s_1316_0: i128 = 3760;
        // C s_1316_1: const #14696u : u32
        let s_1316_1: u32 = 14696;
        // N s_1316_2: write-reg s_1316_1 <= s_1316_0
        let s_1316_2: () = {
            state.write_register::<i128>(s_1316_1 as isize, s_1316_0);
            tracer.write_register(s_1316_1 as isize, s_1316_0);
        };
        // C s_1316_3: const #28s : i
        let s_1316_3: i128 = 28;
        // C s_1316_4: const #4s : i
        let s_1316_4: i128 = 4;
        // D s_1316_5: read-var u#33131:u32
        let s_1316_5: u32 = fn_state.u_33131;
        // D s_1316_6: cast zx s_1316_5 -> bv
        let s_1316_6: Bits = Bits::new(s_1316_5 as u128, 32u16);
        // D s_1316_7: bit-extract s_1316_6 s_1316_3 s_1316_4
        let s_1316_7: Bits = (Bits::new(
            ((s_1316_6) >> (s_1316_3)).value(),
            u16::try_from(s_1316_4).unwrap(),
        ));
        // D s_1316_8: cast reint s_1316_7 -> u8
        let s_1316_8: u8 = (s_1316_7.value() as u8);
        // D s_1316_9: write-var u#33132 <= s_1316_8
        fn_state.u_33132 = s_1316_8;
        // C s_1316_10: const #12s : i
        let s_1316_10: i128 = 12;
        // D s_1316_11: read-var u#33131:u32
        let s_1316_11: u32 = fn_state.u_33131;
        // D s_1316_12: cast zx s_1316_11 -> bv
        let s_1316_12: Bits = Bits::new(s_1316_11 as u128, 32u16);
        // C s_1316_13: const #1u : u64
        let s_1316_13: u64 = 1;
        // D s_1316_14: bit-extract s_1316_12 s_1316_10 s_1316_13
        let s_1316_14: Bits = (Bits::new(
            ((s_1316_12) >> (s_1316_10)).value(),
            u16::try_from(s_1316_13).unwrap(),
        ));
        // D s_1316_15: cast reint s_1316_14 -> u8
        let s_1316_15: bool = ((s_1316_14.value()) != 0);
        // C s_1316_16: const #0s : i
        let s_1316_16: i128 = 0;
        // C s_1316_17: const #0u : u64
        let s_1316_17: u64 = 0;
        // D s_1316_18: cast zx s_1316_15 -> u64
        let s_1316_18: u64 = (s_1316_15 as u64);
        // C s_1316_19: const #1u : u64
        let s_1316_19: u64 = 1;
        // D s_1316_20: and s_1316_18 s_1316_19
        let s_1316_20: u64 = ((s_1316_18) & (s_1316_19));
        // D s_1316_21: cmp-eq s_1316_20 s_1316_19
        let s_1316_21: bool = ((s_1316_20) == (s_1316_19));
        // D s_1316_22: lsl s_1316_18 s_1316_16
        let s_1316_22: u64 = s_1316_18 << s_1316_16;
        // D s_1316_23: or s_1316_17 s_1316_22
        let s_1316_23: u64 = ((s_1316_17) | (s_1316_22));
        // D s_1316_24: cmpl s_1316_22
        let s_1316_24: u64 = !s_1316_22;
        // D s_1316_25: and s_1316_17 s_1316_24
        let s_1316_25: u64 = ((s_1316_17) & (s_1316_24));
        // D s_1316_26: select s_1316_21 s_1316_23 s_1316_25
        let s_1316_26: u64 = if s_1316_21 { s_1316_23 } else { s_1316_25 };
        // D s_1316_27: cast trunc s_1316_26 -> u8
        let s_1316_27: bool = ((s_1316_26) != 0);
        // D s_1316_28: cast zx s_1316_27 -> bv
        let s_1316_28: Bits = Bits::new(s_1316_27 as u128, 1u16);
        // C s_1316_29: const #1u : u8
        let s_1316_29: bool = true;
        // C s_1316_30: cast zx s_1316_29 -> bv
        let s_1316_30: Bits = Bits::new(s_1316_29 as u128, 1u16);
        // D s_1316_31: cmp-ne s_1316_28 s_1316_30
        let s_1316_31: bool = ((s_1316_28) != (s_1316_30));
        // N s_1316_32: branch s_1316_31 b1339 b1317
        if s_1316_31 {
            return block_1339(state, tracer, fn_state);
        } else {
            return block_1317(state, tracer, fn_state);
        };
    }
    fn block_1317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1317_0: const #13s : i
        let s_1317_0: i128 = 13;
        // D s_1317_1: read-var u#33131:u32
        let s_1317_1: u32 = fn_state.u_33131;
        // D s_1317_2: cast zx s_1317_1 -> bv
        let s_1317_2: Bits = Bits::new(s_1317_1 as u128, 32u16);
        // C s_1317_3: const #1u : u64
        let s_1317_3: u64 = 1;
        // D s_1317_4: bit-extract s_1317_2 s_1317_0 s_1317_3
        let s_1317_4: Bits = (Bits::new(
            ((s_1317_2) >> (s_1317_0)).value(),
            u16::try_from(s_1317_3).unwrap(),
        ));
        // D s_1317_5: cast reint s_1317_4 -> u8
        let s_1317_5: bool = ((s_1317_4.value()) != 0);
        // C s_1317_6: const #0s : i
        let s_1317_6: i128 = 0;
        // C s_1317_7: const #0u : u64
        let s_1317_7: u64 = 0;
        // D s_1317_8: cast zx s_1317_5 -> u64
        let s_1317_8: u64 = (s_1317_5 as u64);
        // C s_1317_9: const #1u : u64
        let s_1317_9: u64 = 1;
        // D s_1317_10: and s_1317_8 s_1317_9
        let s_1317_10: u64 = ((s_1317_8) & (s_1317_9));
        // D s_1317_11: cmp-eq s_1317_10 s_1317_9
        let s_1317_11: bool = ((s_1317_10) == (s_1317_9));
        // D s_1317_12: lsl s_1317_8 s_1317_6
        let s_1317_12: u64 = s_1317_8 << s_1317_6;
        // D s_1317_13: or s_1317_7 s_1317_12
        let s_1317_13: u64 = ((s_1317_7) | (s_1317_12));
        // D s_1317_14: cmpl s_1317_12
        let s_1317_14: u64 = !s_1317_12;
        // D s_1317_15: and s_1317_7 s_1317_14
        let s_1317_15: u64 = ((s_1317_7) & (s_1317_14));
        // D s_1317_16: select s_1317_11 s_1317_13 s_1317_15
        let s_1317_16: u64 = if s_1317_11 { s_1317_13 } else { s_1317_15 };
        // D s_1317_17: cast trunc s_1317_16 -> u8
        let s_1317_17: bool = ((s_1317_16) != 0);
        // D s_1317_18: cast zx s_1317_17 -> bv
        let s_1317_18: Bits = Bits::new(s_1317_17 as u128, 1u16);
        // C s_1317_19: const #1u : u8
        let s_1317_19: bool = true;
        // C s_1317_20: cast zx s_1317_19 -> bv
        let s_1317_20: Bits = Bits::new(s_1317_19 as u128, 1u16);
        // D s_1317_21: cmp-ne s_1317_18 s_1317_20
        let s_1317_21: bool = ((s_1317_18) != (s_1317_20));
        // D s_1317_22: write-var gs#407405 <= s_1317_21
        fn_state.gs_407405 = s_1317_21;
        // N s_1317_23: jump b1318
        return block_1318(state, tracer, fn_state);
    }
    fn block_1318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1318_0: read-var gs#407405:u8
        let s_1318_0: bool = fn_state.gs_407405;
        // N s_1318_1: branch s_1318_0 b1338 b1319
        if s_1318_0 {
            return block_1338(state, tracer, fn_state);
        } else {
            return block_1319(state, tracer, fn_state);
        };
    }
    fn block_1319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1319_0: const #14s : i
        let s_1319_0: i128 = 14;
        // D s_1319_1: read-var u#33131:u32
        let s_1319_1: u32 = fn_state.u_33131;
        // D s_1319_2: cast zx s_1319_1 -> bv
        let s_1319_2: Bits = Bits::new(s_1319_1 as u128, 32u16);
        // C s_1319_3: const #1u : u64
        let s_1319_3: u64 = 1;
        // D s_1319_4: bit-extract s_1319_2 s_1319_0 s_1319_3
        let s_1319_4: Bits = (Bits::new(
            ((s_1319_2) >> (s_1319_0)).value(),
            u16::try_from(s_1319_3).unwrap(),
        ));
        // D s_1319_5: cast reint s_1319_4 -> u8
        let s_1319_5: bool = ((s_1319_4.value()) != 0);
        // C s_1319_6: const #0s : i
        let s_1319_6: i128 = 0;
        // C s_1319_7: const #0u : u64
        let s_1319_7: u64 = 0;
        // D s_1319_8: cast zx s_1319_5 -> u64
        let s_1319_8: u64 = (s_1319_5 as u64);
        // C s_1319_9: const #1u : u64
        let s_1319_9: u64 = 1;
        // D s_1319_10: and s_1319_8 s_1319_9
        let s_1319_10: u64 = ((s_1319_8) & (s_1319_9));
        // D s_1319_11: cmp-eq s_1319_10 s_1319_9
        let s_1319_11: bool = ((s_1319_10) == (s_1319_9));
        // D s_1319_12: lsl s_1319_8 s_1319_6
        let s_1319_12: u64 = s_1319_8 << s_1319_6;
        // D s_1319_13: or s_1319_7 s_1319_12
        let s_1319_13: u64 = ((s_1319_7) | (s_1319_12));
        // D s_1319_14: cmpl s_1319_12
        let s_1319_14: u64 = !s_1319_12;
        // D s_1319_15: and s_1319_7 s_1319_14
        let s_1319_15: u64 = ((s_1319_7) & (s_1319_14));
        // D s_1319_16: select s_1319_11 s_1319_13 s_1319_15
        let s_1319_16: u64 = if s_1319_11 { s_1319_13 } else { s_1319_15 };
        // D s_1319_17: cast trunc s_1319_16 -> u8
        let s_1319_17: bool = ((s_1319_16) != 0);
        // D s_1319_18: cast zx s_1319_17 -> bv
        let s_1319_18: Bits = Bits::new(s_1319_17 as u128, 1u16);
        // C s_1319_19: const #1u : u8
        let s_1319_19: bool = true;
        // C s_1319_20: cast zx s_1319_19 -> bv
        let s_1319_20: Bits = Bits::new(s_1319_19 as u128, 1u16);
        // D s_1319_21: cmp-ne s_1319_18 s_1319_20
        let s_1319_21: bool = ((s_1319_18) != (s_1319_20));
        // D s_1319_22: write-var gs#407408 <= s_1319_21
        fn_state.gs_407408 = s_1319_21;
        // N s_1319_23: jump b1320
        return block_1320(state, tracer, fn_state);
    }
    fn block_1320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1320_0: read-var gs#407408:u8
        let s_1320_0: bool = fn_state.gs_407408;
        // N s_1320_1: branch s_1320_0 b1337 b1321
        if s_1320_0 {
            return block_1337(state, tracer, fn_state);
        } else {
            return block_1321(state, tracer, fn_state);
        };
    }
    fn block_1321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1321_0: const #15s : i
        let s_1321_0: i128 = 15;
        // D s_1321_1: read-var u#33131:u32
        let s_1321_1: u32 = fn_state.u_33131;
        // D s_1321_2: cast zx s_1321_1 -> bv
        let s_1321_2: Bits = Bits::new(s_1321_1 as u128, 32u16);
        // C s_1321_3: const #1u : u64
        let s_1321_3: u64 = 1;
        // D s_1321_4: bit-extract s_1321_2 s_1321_0 s_1321_3
        let s_1321_4: Bits = (Bits::new(
            ((s_1321_2) >> (s_1321_0)).value(),
            u16::try_from(s_1321_3).unwrap(),
        ));
        // D s_1321_5: cast reint s_1321_4 -> u8
        let s_1321_5: bool = ((s_1321_4.value()) != 0);
        // C s_1321_6: const #0s : i
        let s_1321_6: i128 = 0;
        // C s_1321_7: const #0u : u64
        let s_1321_7: u64 = 0;
        // D s_1321_8: cast zx s_1321_5 -> u64
        let s_1321_8: u64 = (s_1321_5 as u64);
        // C s_1321_9: const #1u : u64
        let s_1321_9: u64 = 1;
        // D s_1321_10: and s_1321_8 s_1321_9
        let s_1321_10: u64 = ((s_1321_8) & (s_1321_9));
        // D s_1321_11: cmp-eq s_1321_10 s_1321_9
        let s_1321_11: bool = ((s_1321_10) == (s_1321_9));
        // D s_1321_12: lsl s_1321_8 s_1321_6
        let s_1321_12: u64 = s_1321_8 << s_1321_6;
        // D s_1321_13: or s_1321_7 s_1321_12
        let s_1321_13: u64 = ((s_1321_7) | (s_1321_12));
        // D s_1321_14: cmpl s_1321_12
        let s_1321_14: u64 = !s_1321_12;
        // D s_1321_15: and s_1321_7 s_1321_14
        let s_1321_15: u64 = ((s_1321_7) & (s_1321_14));
        // D s_1321_16: select s_1321_11 s_1321_13 s_1321_15
        let s_1321_16: u64 = if s_1321_11 { s_1321_13 } else { s_1321_15 };
        // D s_1321_17: cast trunc s_1321_16 -> u8
        let s_1321_17: bool = ((s_1321_16) != 0);
        // D s_1321_18: cast zx s_1321_17 -> bv
        let s_1321_18: Bits = Bits::new(s_1321_17 as u128, 1u16);
        // C s_1321_19: const #1u : u8
        let s_1321_19: bool = true;
        // C s_1321_20: cast zx s_1321_19 -> bv
        let s_1321_20: Bits = Bits::new(s_1321_19 as u128, 1u16);
        // D s_1321_21: cmp-ne s_1321_18 s_1321_20
        let s_1321_21: bool = ((s_1321_18) != (s_1321_20));
        // D s_1321_22: write-var gs#407411 <= s_1321_21
        fn_state.gs_407411 = s_1321_21;
        // N s_1321_23: jump b1322
        return block_1322(state, tracer, fn_state);
    }
    fn block_1322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1322_0: read-var gs#407411:u8
        let s_1322_0: bool = fn_state.gs_407411;
        // N s_1322_1: branch s_1322_0 b1336 b1323
        if s_1322_0 {
            return block_1336(state, tracer, fn_state);
        } else {
            return block_1323(state, tracer, fn_state);
        };
    }
    fn block_1323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1323_0: const #8s : i
        let s_1323_0: i128 = 8;
        // D s_1323_1: read-var u#33131:u32
        let s_1323_1: u32 = fn_state.u_33131;
        // D s_1323_2: cast zx s_1323_1 -> bv
        let s_1323_2: Bits = Bits::new(s_1323_1 as u128, 32u16);
        // C s_1323_3: const #1u : u64
        let s_1323_3: u64 = 1;
        // D s_1323_4: bit-extract s_1323_2 s_1323_0 s_1323_3
        let s_1323_4: Bits = (Bits::new(
            ((s_1323_2) >> (s_1323_0)).value(),
            u16::try_from(s_1323_3).unwrap(),
        ));
        // D s_1323_5: cast reint s_1323_4 -> u8
        let s_1323_5: bool = ((s_1323_4.value()) != 0);
        // C s_1323_6: const #0s : i
        let s_1323_6: i128 = 0;
        // C s_1323_7: const #0u : u64
        let s_1323_7: u64 = 0;
        // D s_1323_8: cast zx s_1323_5 -> u64
        let s_1323_8: u64 = (s_1323_5 as u64);
        // C s_1323_9: const #1u : u64
        let s_1323_9: u64 = 1;
        // D s_1323_10: and s_1323_8 s_1323_9
        let s_1323_10: u64 = ((s_1323_8) & (s_1323_9));
        // D s_1323_11: cmp-eq s_1323_10 s_1323_9
        let s_1323_11: bool = ((s_1323_10) == (s_1323_9));
        // D s_1323_12: lsl s_1323_8 s_1323_6
        let s_1323_12: u64 = s_1323_8 << s_1323_6;
        // D s_1323_13: or s_1323_7 s_1323_12
        let s_1323_13: u64 = ((s_1323_7) | (s_1323_12));
        // D s_1323_14: cmpl s_1323_12
        let s_1323_14: u64 = !s_1323_12;
        // D s_1323_15: and s_1323_7 s_1323_14
        let s_1323_15: u64 = ((s_1323_7) & (s_1323_14));
        // D s_1323_16: select s_1323_11 s_1323_13 s_1323_15
        let s_1323_16: u64 = if s_1323_11 { s_1323_13 } else { s_1323_15 };
        // D s_1323_17: cast trunc s_1323_16 -> u8
        let s_1323_17: bool = ((s_1323_16) != 0);
        // D s_1323_18: cast zx s_1323_17 -> bv
        let s_1323_18: Bits = Bits::new(s_1323_17 as u128, 1u16);
        // C s_1323_19: const #0u : u8
        let s_1323_19: bool = false;
        // C s_1323_20: cast zx s_1323_19 -> bv
        let s_1323_20: Bits = Bits::new(s_1323_19 as u128, 1u16);
        // D s_1323_21: cmp-ne s_1323_18 s_1323_20
        let s_1323_21: bool = ((s_1323_18) != (s_1323_20));
        // D s_1323_22: write-var gs#407414 <= s_1323_21
        fn_state.gs_407414 = s_1323_21;
        // N s_1323_23: jump b1324
        return block_1324(state, tracer, fn_state);
    }
    fn block_1324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1324_0: read-var gs#407414:u8
        let s_1324_0: bool = fn_state.gs_407414;
        // N s_1324_1: branch s_1324_0 b1335 b1325
        if s_1324_0 {
            return block_1335(state, tracer, fn_state);
        } else {
            return block_1325(state, tracer, fn_state);
        };
    }
    fn block_1325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1325_0: const #9s : i
        let s_1325_0: i128 = 9;
        // D s_1325_1: read-var u#33131:u32
        let s_1325_1: u32 = fn_state.u_33131;
        // D s_1325_2: cast zx s_1325_1 -> bv
        let s_1325_2: Bits = Bits::new(s_1325_1 as u128, 32u16);
        // C s_1325_3: const #1u : u64
        let s_1325_3: u64 = 1;
        // D s_1325_4: bit-extract s_1325_2 s_1325_0 s_1325_3
        let s_1325_4: Bits = (Bits::new(
            ((s_1325_2) >> (s_1325_0)).value(),
            u16::try_from(s_1325_3).unwrap(),
        ));
        // D s_1325_5: cast reint s_1325_4 -> u8
        let s_1325_5: bool = ((s_1325_4.value()) != 0);
        // C s_1325_6: const #0s : i
        let s_1325_6: i128 = 0;
        // C s_1325_7: const #0u : u64
        let s_1325_7: u64 = 0;
        // D s_1325_8: cast zx s_1325_5 -> u64
        let s_1325_8: u64 = (s_1325_5 as u64);
        // C s_1325_9: const #1u : u64
        let s_1325_9: u64 = 1;
        // D s_1325_10: and s_1325_8 s_1325_9
        let s_1325_10: u64 = ((s_1325_8) & (s_1325_9));
        // D s_1325_11: cmp-eq s_1325_10 s_1325_9
        let s_1325_11: bool = ((s_1325_10) == (s_1325_9));
        // D s_1325_12: lsl s_1325_8 s_1325_6
        let s_1325_12: u64 = s_1325_8 << s_1325_6;
        // D s_1325_13: or s_1325_7 s_1325_12
        let s_1325_13: u64 = ((s_1325_7) | (s_1325_12));
        // D s_1325_14: cmpl s_1325_12
        let s_1325_14: u64 = !s_1325_12;
        // D s_1325_15: and s_1325_7 s_1325_14
        let s_1325_15: u64 = ((s_1325_7) & (s_1325_14));
        // D s_1325_16: select s_1325_11 s_1325_13 s_1325_15
        let s_1325_16: u64 = if s_1325_11 { s_1325_13 } else { s_1325_15 };
        // D s_1325_17: cast trunc s_1325_16 -> u8
        let s_1325_17: bool = ((s_1325_16) != 0);
        // D s_1325_18: cast zx s_1325_17 -> bv
        let s_1325_18: Bits = Bits::new(s_1325_17 as u128, 1u16);
        // C s_1325_19: const #0u : u8
        let s_1325_19: bool = false;
        // C s_1325_20: cast zx s_1325_19 -> bv
        let s_1325_20: Bits = Bits::new(s_1325_19 as u128, 1u16);
        // D s_1325_21: cmp-ne s_1325_18 s_1325_20
        let s_1325_21: bool = ((s_1325_18) != (s_1325_20));
        // D s_1325_22: write-var gs#407417 <= s_1325_21
        fn_state.gs_407417 = s_1325_21;
        // N s_1325_23: jump b1326
        return block_1326(state, tracer, fn_state);
    }
    fn block_1326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1326_0: read-var gs#407417:u8
        let s_1326_0: bool = fn_state.gs_407417;
        // N s_1326_1: branch s_1326_0 b1334 b1327
        if s_1326_0 {
            return block_1334(state, tracer, fn_state);
        } else {
            return block_1327(state, tracer, fn_state);
        };
    }
    fn block_1327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1327_0: const #10s : i
        let s_1327_0: i128 = 10;
        // D s_1327_1: read-var u#33131:u32
        let s_1327_1: u32 = fn_state.u_33131;
        // D s_1327_2: cast zx s_1327_1 -> bv
        let s_1327_2: Bits = Bits::new(s_1327_1 as u128, 32u16);
        // C s_1327_3: const #1u : u64
        let s_1327_3: u64 = 1;
        // D s_1327_4: bit-extract s_1327_2 s_1327_0 s_1327_3
        let s_1327_4: Bits = (Bits::new(
            ((s_1327_2) >> (s_1327_0)).value(),
            u16::try_from(s_1327_3).unwrap(),
        ));
        // D s_1327_5: cast reint s_1327_4 -> u8
        let s_1327_5: bool = ((s_1327_4.value()) != 0);
        // C s_1327_6: const #0s : i
        let s_1327_6: i128 = 0;
        // C s_1327_7: const #0u : u64
        let s_1327_7: u64 = 0;
        // D s_1327_8: cast zx s_1327_5 -> u64
        let s_1327_8: u64 = (s_1327_5 as u64);
        // C s_1327_9: const #1u : u64
        let s_1327_9: u64 = 1;
        // D s_1327_10: and s_1327_8 s_1327_9
        let s_1327_10: u64 = ((s_1327_8) & (s_1327_9));
        // D s_1327_11: cmp-eq s_1327_10 s_1327_9
        let s_1327_11: bool = ((s_1327_10) == (s_1327_9));
        // D s_1327_12: lsl s_1327_8 s_1327_6
        let s_1327_12: u64 = s_1327_8 << s_1327_6;
        // D s_1327_13: or s_1327_7 s_1327_12
        let s_1327_13: u64 = ((s_1327_7) | (s_1327_12));
        // D s_1327_14: cmpl s_1327_12
        let s_1327_14: u64 = !s_1327_12;
        // D s_1327_15: and s_1327_7 s_1327_14
        let s_1327_15: u64 = ((s_1327_7) & (s_1327_14));
        // D s_1327_16: select s_1327_11 s_1327_13 s_1327_15
        let s_1327_16: u64 = if s_1327_11 { s_1327_13 } else { s_1327_15 };
        // D s_1327_17: cast trunc s_1327_16 -> u8
        let s_1327_17: bool = ((s_1327_16) != 0);
        // D s_1327_18: cast zx s_1327_17 -> bv
        let s_1327_18: Bits = Bits::new(s_1327_17 as u128, 1u16);
        // C s_1327_19: const #0u : u8
        let s_1327_19: bool = false;
        // C s_1327_20: cast zx s_1327_19 -> bv
        let s_1327_20: Bits = Bits::new(s_1327_19 as u128, 1u16);
        // D s_1327_21: cmp-ne s_1327_18 s_1327_20
        let s_1327_21: bool = ((s_1327_18) != (s_1327_20));
        // D s_1327_22: write-var gs#407420 <= s_1327_21
        fn_state.gs_407420 = s_1327_21;
        // N s_1327_23: jump b1328
        return block_1328(state, tracer, fn_state);
    }
    fn block_1328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1328_0: read-var gs#407420:u8
        let s_1328_0: bool = fn_state.gs_407420;
        // N s_1328_1: branch s_1328_0 b1333 b1329
        if s_1328_0 {
            return block_1333(state, tracer, fn_state);
        } else {
            return block_1329(state, tracer, fn_state);
        };
    }
    fn block_1329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1329_0: const #11s : i
        let s_1329_0: i128 = 11;
        // D s_1329_1: read-var u#33131:u32
        let s_1329_1: u32 = fn_state.u_33131;
        // D s_1329_2: cast zx s_1329_1 -> bv
        let s_1329_2: Bits = Bits::new(s_1329_1 as u128, 32u16);
        // C s_1329_3: const #1u : u64
        let s_1329_3: u64 = 1;
        // D s_1329_4: bit-extract s_1329_2 s_1329_0 s_1329_3
        let s_1329_4: Bits = (Bits::new(
            ((s_1329_2) >> (s_1329_0)).value(),
            u16::try_from(s_1329_3).unwrap(),
        ));
        // D s_1329_5: cast reint s_1329_4 -> u8
        let s_1329_5: bool = ((s_1329_4.value()) != 0);
        // C s_1329_6: const #0s : i
        let s_1329_6: i128 = 0;
        // C s_1329_7: const #0u : u64
        let s_1329_7: u64 = 0;
        // D s_1329_8: cast zx s_1329_5 -> u64
        let s_1329_8: u64 = (s_1329_5 as u64);
        // C s_1329_9: const #1u : u64
        let s_1329_9: u64 = 1;
        // D s_1329_10: and s_1329_8 s_1329_9
        let s_1329_10: u64 = ((s_1329_8) & (s_1329_9));
        // D s_1329_11: cmp-eq s_1329_10 s_1329_9
        let s_1329_11: bool = ((s_1329_10) == (s_1329_9));
        // D s_1329_12: lsl s_1329_8 s_1329_6
        let s_1329_12: u64 = s_1329_8 << s_1329_6;
        // D s_1329_13: or s_1329_7 s_1329_12
        let s_1329_13: u64 = ((s_1329_7) | (s_1329_12));
        // D s_1329_14: cmpl s_1329_12
        let s_1329_14: u64 = !s_1329_12;
        // D s_1329_15: and s_1329_7 s_1329_14
        let s_1329_15: u64 = ((s_1329_7) & (s_1329_14));
        // D s_1329_16: select s_1329_11 s_1329_13 s_1329_15
        let s_1329_16: u64 = if s_1329_11 { s_1329_13 } else { s_1329_15 };
        // D s_1329_17: cast trunc s_1329_16 -> u8
        let s_1329_17: bool = ((s_1329_16) != 0);
        // D s_1329_18: cast zx s_1329_17 -> bv
        let s_1329_18: Bits = Bits::new(s_1329_17 as u128, 1u16);
        // C s_1329_19: const #0u : u8
        let s_1329_19: bool = false;
        // C s_1329_20: cast zx s_1329_19 -> bv
        let s_1329_20: Bits = Bits::new(s_1329_19 as u128, 1u16);
        // D s_1329_21: cmp-ne s_1329_18 s_1329_20
        let s_1329_21: bool = ((s_1329_18) != (s_1329_20));
        // D s_1329_22: write-var gs#407423 <= s_1329_21
        fn_state.gs_407423 = s_1329_21;
        // N s_1329_23: jump b1330
        return block_1330(state, tracer, fn_state);
    }
    fn block_1330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1330_0: read-var gs#407423:u8
        let s_1330_0: bool = fn_state.gs_407423;
        // N s_1330_1: branch s_1330_0 b1332 b1331
        if s_1330_0 {
            return block_1332(state, tracer, fn_state);
        } else {
            return block_1331(state, tracer, fn_state);
        };
    }
    fn block_1331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1331_0: read-var u#33132:u8
        let s_1331_0: u8 = fn_state.u_33132;
        // D s_1331_1: call decode_aarch32_instrs_WFE_A1enc_A_txt(s_1331_0)
        let s_1331_1: () = decode_aarch32_instrs_WFE_A1enc_A_txt(
            state,
            tracer,
            s_1331_0,
        );
        // N s_1331_2: return
        return;
    }
    fn block_1332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1332_0: panic
        panic!("{:?}", ());
        // N s_1332_1: return
        return;
    }
    fn block_1333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1333_0: const #1u : u8
        let s_1333_0: bool = true;
        // D s_1333_1: write-var gs#407423 <= s_1333_0
        fn_state.gs_407423 = s_1333_0;
        // N s_1333_2: jump b1330
        return block_1330(state, tracer, fn_state);
    }
    fn block_1334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1334_0: const #1u : u8
        let s_1334_0: bool = true;
        // D s_1334_1: write-var gs#407420 <= s_1334_0
        fn_state.gs_407420 = s_1334_0;
        // N s_1334_2: jump b1328
        return block_1328(state, tracer, fn_state);
    }
    fn block_1335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1335_0: const #1u : u8
        let s_1335_0: bool = true;
        // D s_1335_1: write-var gs#407417 <= s_1335_0
        fn_state.gs_407417 = s_1335_0;
        // N s_1335_2: jump b1326
        return block_1326(state, tracer, fn_state);
    }
    fn block_1336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1336_0: const #1u : u8
        let s_1336_0: bool = true;
        // D s_1336_1: write-var gs#407414 <= s_1336_0
        fn_state.gs_407414 = s_1336_0;
        // N s_1336_2: jump b1324
        return block_1324(state, tracer, fn_state);
    }
    fn block_1337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1337_0: const #1u : u8
        let s_1337_0: bool = true;
        // D s_1337_1: write-var gs#407411 <= s_1337_0
        fn_state.gs_407411 = s_1337_0;
        // N s_1337_2: jump b1322
        return block_1322(state, tracer, fn_state);
    }
    fn block_1338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1338_0: const #1u : u8
        let s_1338_0: bool = true;
        // D s_1338_1: write-var gs#407408 <= s_1338_0
        fn_state.gs_407408 = s_1338_0;
        // N s_1338_2: jump b1320
        return block_1320(state, tracer, fn_state);
    }
    fn block_1339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1339_0: const #1u : u8
        let s_1339_0: bool = true;
        // D s_1339_1: write-var gs#407405 <= s_1339_0
        fn_state.gs_407405 = s_1339_0;
        // N s_1339_2: jump b1318
        return block_1318(state, tracer, fn_state);
    }
    fn block_1340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1340_0: read-var merge#var.1:struct
        let s_1340_0: u32 = fn_state.merge_var._1;
        // D s_1340_1: write-var u#33134 <= s_1340_0
        fn_state.u_33134 = s_1340_0;
        // C s_1340_2: const #0s : i
        let s_1340_2: i128 = 0;
        // D s_1340_3: read-var u#33134:u32
        let s_1340_3: u32 = fn_state.u_33134;
        // D s_1340_4: cast zx s_1340_3 -> bv
        let s_1340_4: Bits = Bits::new(s_1340_3 as u128, 32u16);
        // C s_1340_5: const #1s : i64
        let s_1340_5: i64 = 1;
        // C s_1340_6: cast zx s_1340_5 -> i
        let s_1340_6: i128 = (i128::try_from(s_1340_5).unwrap());
        // C s_1340_7: const #27s : i
        let s_1340_7: i128 = 27;
        // C s_1340_8: add s_1340_7 s_1340_6
        let s_1340_8: i128 = (s_1340_7 + s_1340_6);
        // D s_1340_9: bit-extract s_1340_4 s_1340_2 s_1340_8
        let s_1340_9: Bits = (Bits::new(
            ((s_1340_4) >> (s_1340_2)).value(),
            u16::try_from(s_1340_8).unwrap(),
        ));
        // D s_1340_10: cast reint s_1340_9 -> u28
        let s_1340_10: u32 = (s_1340_9.value() as u32);
        // D s_1340_11: cast zx s_1340_10 -> bv
        let s_1340_11: Bits = Bits::new(s_1340_10 as u128, 28u16);
        // C s_1340_12: const #52490243u : u28
        let s_1340_12: u32 = 52490243;
        // C s_1340_13: cast zx s_1340_12 -> bv
        let s_1340_13: Bits = Bits::new(s_1340_12 as u128, 28u16);
        // D s_1340_14: cmp-eq s_1340_11 s_1340_13
        let s_1340_14: bool = ((s_1340_11) == (s_1340_13));
        // N s_1340_15: branch s_1340_14 b2216 b1341
        if s_1340_14 {
            return block_2216(state, tracer, fn_state);
        } else {
            return block_1341(state, tracer, fn_state);
        };
    }
    fn block_1341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1341_0: const #0u : u8
        let s_1341_0: bool = false;
        // D s_1341_1: write-var gs#407431 <= s_1341_0
        fn_state.gs_407431 = s_1341_0;
        // N s_1341_2: jump b1342
        return block_1342(state, tracer, fn_state);
    }
    fn block_1342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1342_0: read-var gs#407431:u8
        let s_1342_0: bool = fn_state.gs_407431;
        // D s_1342_1: not s_1342_0
        let s_1342_1: bool = !s_1342_0;
        // N s_1342_2: branch s_1342_1 b1367 b1343
        if s_1342_1 {
            return block_1367(state, tracer, fn_state);
        } else {
            return block_1343(state, tracer, fn_state);
        };
    }
    fn block_1343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1343_0: const #3763s : i
        let s_1343_0: i128 = 3763;
        // C s_1343_1: const #14696u : u32
        let s_1343_1: u32 = 14696;
        // N s_1343_2: write-reg s_1343_1 <= s_1343_0
        let s_1343_2: () = {
            state.write_register::<i128>(s_1343_1 as isize, s_1343_0);
            tracer.write_register(s_1343_1 as isize, s_1343_0);
        };
        // C s_1343_3: const #28s : i
        let s_1343_3: i128 = 28;
        // C s_1343_4: const #4s : i
        let s_1343_4: i128 = 4;
        // D s_1343_5: read-var u#33134:u32
        let s_1343_5: u32 = fn_state.u_33134;
        // D s_1343_6: cast zx s_1343_5 -> bv
        let s_1343_6: Bits = Bits::new(s_1343_5 as u128, 32u16);
        // D s_1343_7: bit-extract s_1343_6 s_1343_3 s_1343_4
        let s_1343_7: Bits = (Bits::new(
            ((s_1343_6) >> (s_1343_3)).value(),
            u16::try_from(s_1343_4).unwrap(),
        ));
        // D s_1343_8: cast reint s_1343_7 -> u8
        let s_1343_8: u8 = (s_1343_7.value() as u8);
        // D s_1343_9: write-var u#33135 <= s_1343_8
        fn_state.u_33135 = s_1343_8;
        // C s_1343_10: const #12s : i
        let s_1343_10: i128 = 12;
        // D s_1343_11: read-var u#33134:u32
        let s_1343_11: u32 = fn_state.u_33134;
        // D s_1343_12: cast zx s_1343_11 -> bv
        let s_1343_12: Bits = Bits::new(s_1343_11 as u128, 32u16);
        // C s_1343_13: const #1u : u64
        let s_1343_13: u64 = 1;
        // D s_1343_14: bit-extract s_1343_12 s_1343_10 s_1343_13
        let s_1343_14: Bits = (Bits::new(
            ((s_1343_12) >> (s_1343_10)).value(),
            u16::try_from(s_1343_13).unwrap(),
        ));
        // D s_1343_15: cast reint s_1343_14 -> u8
        let s_1343_15: bool = ((s_1343_14.value()) != 0);
        // C s_1343_16: const #0s : i
        let s_1343_16: i128 = 0;
        // C s_1343_17: const #0u : u64
        let s_1343_17: u64 = 0;
        // D s_1343_18: cast zx s_1343_15 -> u64
        let s_1343_18: u64 = (s_1343_15 as u64);
        // C s_1343_19: const #1u : u64
        let s_1343_19: u64 = 1;
        // D s_1343_20: and s_1343_18 s_1343_19
        let s_1343_20: u64 = ((s_1343_18) & (s_1343_19));
        // D s_1343_21: cmp-eq s_1343_20 s_1343_19
        let s_1343_21: bool = ((s_1343_20) == (s_1343_19));
        // D s_1343_22: lsl s_1343_18 s_1343_16
        let s_1343_22: u64 = s_1343_18 << s_1343_16;
        // D s_1343_23: or s_1343_17 s_1343_22
        let s_1343_23: u64 = ((s_1343_17) | (s_1343_22));
        // D s_1343_24: cmpl s_1343_22
        let s_1343_24: u64 = !s_1343_22;
        // D s_1343_25: and s_1343_17 s_1343_24
        let s_1343_25: u64 = ((s_1343_17) & (s_1343_24));
        // D s_1343_26: select s_1343_21 s_1343_23 s_1343_25
        let s_1343_26: u64 = if s_1343_21 { s_1343_23 } else { s_1343_25 };
        // D s_1343_27: cast trunc s_1343_26 -> u8
        let s_1343_27: bool = ((s_1343_26) != 0);
        // D s_1343_28: cast zx s_1343_27 -> bv
        let s_1343_28: Bits = Bits::new(s_1343_27 as u128, 1u16);
        // C s_1343_29: const #1u : u8
        let s_1343_29: bool = true;
        // C s_1343_30: cast zx s_1343_29 -> bv
        let s_1343_30: Bits = Bits::new(s_1343_29 as u128, 1u16);
        // D s_1343_31: cmp-ne s_1343_28 s_1343_30
        let s_1343_31: bool = ((s_1343_28) != (s_1343_30));
        // N s_1343_32: branch s_1343_31 b1366 b1344
        if s_1343_31 {
            return block_1366(state, tracer, fn_state);
        } else {
            return block_1344(state, tracer, fn_state);
        };
    }
    fn block_1344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1344_0: const #13s : i
        let s_1344_0: i128 = 13;
        // D s_1344_1: read-var u#33134:u32
        let s_1344_1: u32 = fn_state.u_33134;
        // D s_1344_2: cast zx s_1344_1 -> bv
        let s_1344_2: Bits = Bits::new(s_1344_1 as u128, 32u16);
        // C s_1344_3: const #1u : u64
        let s_1344_3: u64 = 1;
        // D s_1344_4: bit-extract s_1344_2 s_1344_0 s_1344_3
        let s_1344_4: Bits = (Bits::new(
            ((s_1344_2) >> (s_1344_0)).value(),
            u16::try_from(s_1344_3).unwrap(),
        ));
        // D s_1344_5: cast reint s_1344_4 -> u8
        let s_1344_5: bool = ((s_1344_4.value()) != 0);
        // C s_1344_6: const #0s : i
        let s_1344_6: i128 = 0;
        // C s_1344_7: const #0u : u64
        let s_1344_7: u64 = 0;
        // D s_1344_8: cast zx s_1344_5 -> u64
        let s_1344_8: u64 = (s_1344_5 as u64);
        // C s_1344_9: const #1u : u64
        let s_1344_9: u64 = 1;
        // D s_1344_10: and s_1344_8 s_1344_9
        let s_1344_10: u64 = ((s_1344_8) & (s_1344_9));
        // D s_1344_11: cmp-eq s_1344_10 s_1344_9
        let s_1344_11: bool = ((s_1344_10) == (s_1344_9));
        // D s_1344_12: lsl s_1344_8 s_1344_6
        let s_1344_12: u64 = s_1344_8 << s_1344_6;
        // D s_1344_13: or s_1344_7 s_1344_12
        let s_1344_13: u64 = ((s_1344_7) | (s_1344_12));
        // D s_1344_14: cmpl s_1344_12
        let s_1344_14: u64 = !s_1344_12;
        // D s_1344_15: and s_1344_7 s_1344_14
        let s_1344_15: u64 = ((s_1344_7) & (s_1344_14));
        // D s_1344_16: select s_1344_11 s_1344_13 s_1344_15
        let s_1344_16: u64 = if s_1344_11 { s_1344_13 } else { s_1344_15 };
        // D s_1344_17: cast trunc s_1344_16 -> u8
        let s_1344_17: bool = ((s_1344_16) != 0);
        // D s_1344_18: cast zx s_1344_17 -> bv
        let s_1344_18: Bits = Bits::new(s_1344_17 as u128, 1u16);
        // C s_1344_19: const #1u : u8
        let s_1344_19: bool = true;
        // C s_1344_20: cast zx s_1344_19 -> bv
        let s_1344_20: Bits = Bits::new(s_1344_19 as u128, 1u16);
        // D s_1344_21: cmp-ne s_1344_18 s_1344_20
        let s_1344_21: bool = ((s_1344_18) != (s_1344_20));
        // D s_1344_22: write-var gs#407440 <= s_1344_21
        fn_state.gs_407440 = s_1344_21;
        // N s_1344_23: jump b1345
        return block_1345(state, tracer, fn_state);
    }
    fn block_1345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1345_0: read-var gs#407440:u8
        let s_1345_0: bool = fn_state.gs_407440;
        // N s_1345_1: branch s_1345_0 b1365 b1346
        if s_1345_0 {
            return block_1365(state, tracer, fn_state);
        } else {
            return block_1346(state, tracer, fn_state);
        };
    }
    fn block_1346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1346_0: const #14s : i
        let s_1346_0: i128 = 14;
        // D s_1346_1: read-var u#33134:u32
        let s_1346_1: u32 = fn_state.u_33134;
        // D s_1346_2: cast zx s_1346_1 -> bv
        let s_1346_2: Bits = Bits::new(s_1346_1 as u128, 32u16);
        // C s_1346_3: const #1u : u64
        let s_1346_3: u64 = 1;
        // D s_1346_4: bit-extract s_1346_2 s_1346_0 s_1346_3
        let s_1346_4: Bits = (Bits::new(
            ((s_1346_2) >> (s_1346_0)).value(),
            u16::try_from(s_1346_3).unwrap(),
        ));
        // D s_1346_5: cast reint s_1346_4 -> u8
        let s_1346_5: bool = ((s_1346_4.value()) != 0);
        // C s_1346_6: const #0s : i
        let s_1346_6: i128 = 0;
        // C s_1346_7: const #0u : u64
        let s_1346_7: u64 = 0;
        // D s_1346_8: cast zx s_1346_5 -> u64
        let s_1346_8: u64 = (s_1346_5 as u64);
        // C s_1346_9: const #1u : u64
        let s_1346_9: u64 = 1;
        // D s_1346_10: and s_1346_8 s_1346_9
        let s_1346_10: u64 = ((s_1346_8) & (s_1346_9));
        // D s_1346_11: cmp-eq s_1346_10 s_1346_9
        let s_1346_11: bool = ((s_1346_10) == (s_1346_9));
        // D s_1346_12: lsl s_1346_8 s_1346_6
        let s_1346_12: u64 = s_1346_8 << s_1346_6;
        // D s_1346_13: or s_1346_7 s_1346_12
        let s_1346_13: u64 = ((s_1346_7) | (s_1346_12));
        // D s_1346_14: cmpl s_1346_12
        let s_1346_14: u64 = !s_1346_12;
        // D s_1346_15: and s_1346_7 s_1346_14
        let s_1346_15: u64 = ((s_1346_7) & (s_1346_14));
        // D s_1346_16: select s_1346_11 s_1346_13 s_1346_15
        let s_1346_16: u64 = if s_1346_11 { s_1346_13 } else { s_1346_15 };
        // D s_1346_17: cast trunc s_1346_16 -> u8
        let s_1346_17: bool = ((s_1346_16) != 0);
        // D s_1346_18: cast zx s_1346_17 -> bv
        let s_1346_18: Bits = Bits::new(s_1346_17 as u128, 1u16);
        // C s_1346_19: const #1u : u8
        let s_1346_19: bool = true;
        // C s_1346_20: cast zx s_1346_19 -> bv
        let s_1346_20: Bits = Bits::new(s_1346_19 as u128, 1u16);
        // D s_1346_21: cmp-ne s_1346_18 s_1346_20
        let s_1346_21: bool = ((s_1346_18) != (s_1346_20));
        // D s_1346_22: write-var gs#407443 <= s_1346_21
        fn_state.gs_407443 = s_1346_21;
        // N s_1346_23: jump b1347
        return block_1347(state, tracer, fn_state);
    }
    fn block_1347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1347_0: read-var gs#407443:u8
        let s_1347_0: bool = fn_state.gs_407443;
        // N s_1347_1: branch s_1347_0 b1364 b1348
        if s_1347_0 {
            return block_1364(state, tracer, fn_state);
        } else {
            return block_1348(state, tracer, fn_state);
        };
    }
    fn block_1348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1348_0: const #15s : i
        let s_1348_0: i128 = 15;
        // D s_1348_1: read-var u#33134:u32
        let s_1348_1: u32 = fn_state.u_33134;
        // D s_1348_2: cast zx s_1348_1 -> bv
        let s_1348_2: Bits = Bits::new(s_1348_1 as u128, 32u16);
        // C s_1348_3: const #1u : u64
        let s_1348_3: u64 = 1;
        // D s_1348_4: bit-extract s_1348_2 s_1348_0 s_1348_3
        let s_1348_4: Bits = (Bits::new(
            ((s_1348_2) >> (s_1348_0)).value(),
            u16::try_from(s_1348_3).unwrap(),
        ));
        // D s_1348_5: cast reint s_1348_4 -> u8
        let s_1348_5: bool = ((s_1348_4.value()) != 0);
        // C s_1348_6: const #0s : i
        let s_1348_6: i128 = 0;
        // C s_1348_7: const #0u : u64
        let s_1348_7: u64 = 0;
        // D s_1348_8: cast zx s_1348_5 -> u64
        let s_1348_8: u64 = (s_1348_5 as u64);
        // C s_1348_9: const #1u : u64
        let s_1348_9: u64 = 1;
        // D s_1348_10: and s_1348_8 s_1348_9
        let s_1348_10: u64 = ((s_1348_8) & (s_1348_9));
        // D s_1348_11: cmp-eq s_1348_10 s_1348_9
        let s_1348_11: bool = ((s_1348_10) == (s_1348_9));
        // D s_1348_12: lsl s_1348_8 s_1348_6
        let s_1348_12: u64 = s_1348_8 << s_1348_6;
        // D s_1348_13: or s_1348_7 s_1348_12
        let s_1348_13: u64 = ((s_1348_7) | (s_1348_12));
        // D s_1348_14: cmpl s_1348_12
        let s_1348_14: u64 = !s_1348_12;
        // D s_1348_15: and s_1348_7 s_1348_14
        let s_1348_15: u64 = ((s_1348_7) & (s_1348_14));
        // D s_1348_16: select s_1348_11 s_1348_13 s_1348_15
        let s_1348_16: u64 = if s_1348_11 { s_1348_13 } else { s_1348_15 };
        // D s_1348_17: cast trunc s_1348_16 -> u8
        let s_1348_17: bool = ((s_1348_16) != 0);
        // D s_1348_18: cast zx s_1348_17 -> bv
        let s_1348_18: Bits = Bits::new(s_1348_17 as u128, 1u16);
        // C s_1348_19: const #1u : u8
        let s_1348_19: bool = true;
        // C s_1348_20: cast zx s_1348_19 -> bv
        let s_1348_20: Bits = Bits::new(s_1348_19 as u128, 1u16);
        // D s_1348_21: cmp-ne s_1348_18 s_1348_20
        let s_1348_21: bool = ((s_1348_18) != (s_1348_20));
        // D s_1348_22: write-var gs#407446 <= s_1348_21
        fn_state.gs_407446 = s_1348_21;
        // N s_1348_23: jump b1349
        return block_1349(state, tracer, fn_state);
    }
    fn block_1349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1349_0: read-var gs#407446:u8
        let s_1349_0: bool = fn_state.gs_407446;
        // N s_1349_1: branch s_1349_0 b1363 b1350
        if s_1349_0 {
            return block_1363(state, tracer, fn_state);
        } else {
            return block_1350(state, tracer, fn_state);
        };
    }
    fn block_1350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1350_0: const #8s : i
        let s_1350_0: i128 = 8;
        // D s_1350_1: read-var u#33134:u32
        let s_1350_1: u32 = fn_state.u_33134;
        // D s_1350_2: cast zx s_1350_1 -> bv
        let s_1350_2: Bits = Bits::new(s_1350_1 as u128, 32u16);
        // C s_1350_3: const #1u : u64
        let s_1350_3: u64 = 1;
        // D s_1350_4: bit-extract s_1350_2 s_1350_0 s_1350_3
        let s_1350_4: Bits = (Bits::new(
            ((s_1350_2) >> (s_1350_0)).value(),
            u16::try_from(s_1350_3).unwrap(),
        ));
        // D s_1350_5: cast reint s_1350_4 -> u8
        let s_1350_5: bool = ((s_1350_4.value()) != 0);
        // C s_1350_6: const #0s : i
        let s_1350_6: i128 = 0;
        // C s_1350_7: const #0u : u64
        let s_1350_7: u64 = 0;
        // D s_1350_8: cast zx s_1350_5 -> u64
        let s_1350_8: u64 = (s_1350_5 as u64);
        // C s_1350_9: const #1u : u64
        let s_1350_9: u64 = 1;
        // D s_1350_10: and s_1350_8 s_1350_9
        let s_1350_10: u64 = ((s_1350_8) & (s_1350_9));
        // D s_1350_11: cmp-eq s_1350_10 s_1350_9
        let s_1350_11: bool = ((s_1350_10) == (s_1350_9));
        // D s_1350_12: lsl s_1350_8 s_1350_6
        let s_1350_12: u64 = s_1350_8 << s_1350_6;
        // D s_1350_13: or s_1350_7 s_1350_12
        let s_1350_13: u64 = ((s_1350_7) | (s_1350_12));
        // D s_1350_14: cmpl s_1350_12
        let s_1350_14: u64 = !s_1350_12;
        // D s_1350_15: and s_1350_7 s_1350_14
        let s_1350_15: u64 = ((s_1350_7) & (s_1350_14));
        // D s_1350_16: select s_1350_11 s_1350_13 s_1350_15
        let s_1350_16: u64 = if s_1350_11 { s_1350_13 } else { s_1350_15 };
        // D s_1350_17: cast trunc s_1350_16 -> u8
        let s_1350_17: bool = ((s_1350_16) != 0);
        // D s_1350_18: cast zx s_1350_17 -> bv
        let s_1350_18: Bits = Bits::new(s_1350_17 as u128, 1u16);
        // C s_1350_19: const #0u : u8
        let s_1350_19: bool = false;
        // C s_1350_20: cast zx s_1350_19 -> bv
        let s_1350_20: Bits = Bits::new(s_1350_19 as u128, 1u16);
        // D s_1350_21: cmp-ne s_1350_18 s_1350_20
        let s_1350_21: bool = ((s_1350_18) != (s_1350_20));
        // D s_1350_22: write-var gs#407449 <= s_1350_21
        fn_state.gs_407449 = s_1350_21;
        // N s_1350_23: jump b1351
        return block_1351(state, tracer, fn_state);
    }
    fn block_1351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1351_0: read-var gs#407449:u8
        let s_1351_0: bool = fn_state.gs_407449;
        // N s_1351_1: branch s_1351_0 b1362 b1352
        if s_1351_0 {
            return block_1362(state, tracer, fn_state);
        } else {
            return block_1352(state, tracer, fn_state);
        };
    }
    fn block_1352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1352_0: const #9s : i
        let s_1352_0: i128 = 9;
        // D s_1352_1: read-var u#33134:u32
        let s_1352_1: u32 = fn_state.u_33134;
        // D s_1352_2: cast zx s_1352_1 -> bv
        let s_1352_2: Bits = Bits::new(s_1352_1 as u128, 32u16);
        // C s_1352_3: const #1u : u64
        let s_1352_3: u64 = 1;
        // D s_1352_4: bit-extract s_1352_2 s_1352_0 s_1352_3
        let s_1352_4: Bits = (Bits::new(
            ((s_1352_2) >> (s_1352_0)).value(),
            u16::try_from(s_1352_3).unwrap(),
        ));
        // D s_1352_5: cast reint s_1352_4 -> u8
        let s_1352_5: bool = ((s_1352_4.value()) != 0);
        // C s_1352_6: const #0s : i
        let s_1352_6: i128 = 0;
        // C s_1352_7: const #0u : u64
        let s_1352_7: u64 = 0;
        // D s_1352_8: cast zx s_1352_5 -> u64
        let s_1352_8: u64 = (s_1352_5 as u64);
        // C s_1352_9: const #1u : u64
        let s_1352_9: u64 = 1;
        // D s_1352_10: and s_1352_8 s_1352_9
        let s_1352_10: u64 = ((s_1352_8) & (s_1352_9));
        // D s_1352_11: cmp-eq s_1352_10 s_1352_9
        let s_1352_11: bool = ((s_1352_10) == (s_1352_9));
        // D s_1352_12: lsl s_1352_8 s_1352_6
        let s_1352_12: u64 = s_1352_8 << s_1352_6;
        // D s_1352_13: or s_1352_7 s_1352_12
        let s_1352_13: u64 = ((s_1352_7) | (s_1352_12));
        // D s_1352_14: cmpl s_1352_12
        let s_1352_14: u64 = !s_1352_12;
        // D s_1352_15: and s_1352_7 s_1352_14
        let s_1352_15: u64 = ((s_1352_7) & (s_1352_14));
        // D s_1352_16: select s_1352_11 s_1352_13 s_1352_15
        let s_1352_16: u64 = if s_1352_11 { s_1352_13 } else { s_1352_15 };
        // D s_1352_17: cast trunc s_1352_16 -> u8
        let s_1352_17: bool = ((s_1352_16) != 0);
        // D s_1352_18: cast zx s_1352_17 -> bv
        let s_1352_18: Bits = Bits::new(s_1352_17 as u128, 1u16);
        // C s_1352_19: const #0u : u8
        let s_1352_19: bool = false;
        // C s_1352_20: cast zx s_1352_19 -> bv
        let s_1352_20: Bits = Bits::new(s_1352_19 as u128, 1u16);
        // D s_1352_21: cmp-ne s_1352_18 s_1352_20
        let s_1352_21: bool = ((s_1352_18) != (s_1352_20));
        // D s_1352_22: write-var gs#407452 <= s_1352_21
        fn_state.gs_407452 = s_1352_21;
        // N s_1352_23: jump b1353
        return block_1353(state, tracer, fn_state);
    }
    fn block_1353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1353_0: read-var gs#407452:u8
        let s_1353_0: bool = fn_state.gs_407452;
        // N s_1353_1: branch s_1353_0 b1361 b1354
        if s_1353_0 {
            return block_1361(state, tracer, fn_state);
        } else {
            return block_1354(state, tracer, fn_state);
        };
    }
    fn block_1354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1354_0: const #10s : i
        let s_1354_0: i128 = 10;
        // D s_1354_1: read-var u#33134:u32
        let s_1354_1: u32 = fn_state.u_33134;
        // D s_1354_2: cast zx s_1354_1 -> bv
        let s_1354_2: Bits = Bits::new(s_1354_1 as u128, 32u16);
        // C s_1354_3: const #1u : u64
        let s_1354_3: u64 = 1;
        // D s_1354_4: bit-extract s_1354_2 s_1354_0 s_1354_3
        let s_1354_4: Bits = (Bits::new(
            ((s_1354_2) >> (s_1354_0)).value(),
            u16::try_from(s_1354_3).unwrap(),
        ));
        // D s_1354_5: cast reint s_1354_4 -> u8
        let s_1354_5: bool = ((s_1354_4.value()) != 0);
        // C s_1354_6: const #0s : i
        let s_1354_6: i128 = 0;
        // C s_1354_7: const #0u : u64
        let s_1354_7: u64 = 0;
        // D s_1354_8: cast zx s_1354_5 -> u64
        let s_1354_8: u64 = (s_1354_5 as u64);
        // C s_1354_9: const #1u : u64
        let s_1354_9: u64 = 1;
        // D s_1354_10: and s_1354_8 s_1354_9
        let s_1354_10: u64 = ((s_1354_8) & (s_1354_9));
        // D s_1354_11: cmp-eq s_1354_10 s_1354_9
        let s_1354_11: bool = ((s_1354_10) == (s_1354_9));
        // D s_1354_12: lsl s_1354_8 s_1354_6
        let s_1354_12: u64 = s_1354_8 << s_1354_6;
        // D s_1354_13: or s_1354_7 s_1354_12
        let s_1354_13: u64 = ((s_1354_7) | (s_1354_12));
        // D s_1354_14: cmpl s_1354_12
        let s_1354_14: u64 = !s_1354_12;
        // D s_1354_15: and s_1354_7 s_1354_14
        let s_1354_15: u64 = ((s_1354_7) & (s_1354_14));
        // D s_1354_16: select s_1354_11 s_1354_13 s_1354_15
        let s_1354_16: u64 = if s_1354_11 { s_1354_13 } else { s_1354_15 };
        // D s_1354_17: cast trunc s_1354_16 -> u8
        let s_1354_17: bool = ((s_1354_16) != 0);
        // D s_1354_18: cast zx s_1354_17 -> bv
        let s_1354_18: Bits = Bits::new(s_1354_17 as u128, 1u16);
        // C s_1354_19: const #0u : u8
        let s_1354_19: bool = false;
        // C s_1354_20: cast zx s_1354_19 -> bv
        let s_1354_20: Bits = Bits::new(s_1354_19 as u128, 1u16);
        // D s_1354_21: cmp-ne s_1354_18 s_1354_20
        let s_1354_21: bool = ((s_1354_18) != (s_1354_20));
        // D s_1354_22: write-var gs#407455 <= s_1354_21
        fn_state.gs_407455 = s_1354_21;
        // N s_1354_23: jump b1355
        return block_1355(state, tracer, fn_state);
    }
    fn block_1355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1355_0: read-var gs#407455:u8
        let s_1355_0: bool = fn_state.gs_407455;
        // N s_1355_1: branch s_1355_0 b1360 b1356
        if s_1355_0 {
            return block_1360(state, tracer, fn_state);
        } else {
            return block_1356(state, tracer, fn_state);
        };
    }
    fn block_1356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1356_0: const #11s : i
        let s_1356_0: i128 = 11;
        // D s_1356_1: read-var u#33134:u32
        let s_1356_1: u32 = fn_state.u_33134;
        // D s_1356_2: cast zx s_1356_1 -> bv
        let s_1356_2: Bits = Bits::new(s_1356_1 as u128, 32u16);
        // C s_1356_3: const #1u : u64
        let s_1356_3: u64 = 1;
        // D s_1356_4: bit-extract s_1356_2 s_1356_0 s_1356_3
        let s_1356_4: Bits = (Bits::new(
            ((s_1356_2) >> (s_1356_0)).value(),
            u16::try_from(s_1356_3).unwrap(),
        ));
        // D s_1356_5: cast reint s_1356_4 -> u8
        let s_1356_5: bool = ((s_1356_4.value()) != 0);
        // C s_1356_6: const #0s : i
        let s_1356_6: i128 = 0;
        // C s_1356_7: const #0u : u64
        let s_1356_7: u64 = 0;
        // D s_1356_8: cast zx s_1356_5 -> u64
        let s_1356_8: u64 = (s_1356_5 as u64);
        // C s_1356_9: const #1u : u64
        let s_1356_9: u64 = 1;
        // D s_1356_10: and s_1356_8 s_1356_9
        let s_1356_10: u64 = ((s_1356_8) & (s_1356_9));
        // D s_1356_11: cmp-eq s_1356_10 s_1356_9
        let s_1356_11: bool = ((s_1356_10) == (s_1356_9));
        // D s_1356_12: lsl s_1356_8 s_1356_6
        let s_1356_12: u64 = s_1356_8 << s_1356_6;
        // D s_1356_13: or s_1356_7 s_1356_12
        let s_1356_13: u64 = ((s_1356_7) | (s_1356_12));
        // D s_1356_14: cmpl s_1356_12
        let s_1356_14: u64 = !s_1356_12;
        // D s_1356_15: and s_1356_7 s_1356_14
        let s_1356_15: u64 = ((s_1356_7) & (s_1356_14));
        // D s_1356_16: select s_1356_11 s_1356_13 s_1356_15
        let s_1356_16: u64 = if s_1356_11 { s_1356_13 } else { s_1356_15 };
        // D s_1356_17: cast trunc s_1356_16 -> u8
        let s_1356_17: bool = ((s_1356_16) != 0);
        // D s_1356_18: cast zx s_1356_17 -> bv
        let s_1356_18: Bits = Bits::new(s_1356_17 as u128, 1u16);
        // C s_1356_19: const #0u : u8
        let s_1356_19: bool = false;
        // C s_1356_20: cast zx s_1356_19 -> bv
        let s_1356_20: Bits = Bits::new(s_1356_19 as u128, 1u16);
        // D s_1356_21: cmp-ne s_1356_18 s_1356_20
        let s_1356_21: bool = ((s_1356_18) != (s_1356_20));
        // D s_1356_22: write-var gs#407458 <= s_1356_21
        fn_state.gs_407458 = s_1356_21;
        // N s_1356_23: jump b1357
        return block_1357(state, tracer, fn_state);
    }
    fn block_1357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1357_0: read-var gs#407458:u8
        let s_1357_0: bool = fn_state.gs_407458;
        // N s_1357_1: branch s_1357_0 b1359 b1358
        if s_1357_0 {
            return block_1359(state, tracer, fn_state);
        } else {
            return block_1358(state, tracer, fn_state);
        };
    }
    fn block_1358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1358_0: read-var u#33135:u8
        let s_1358_0: u8 = fn_state.u_33135;
        // D s_1358_1: call decode_aarch32_instrs_WFI_A1enc_A_txt(s_1358_0)
        let s_1358_1: () = decode_aarch32_instrs_WFI_A1enc_A_txt(
            state,
            tracer,
            s_1358_0,
        );
        // N s_1358_2: return
        return;
    }
    fn block_1359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1359_0: panic
        panic!("{:?}", ());
        // N s_1359_1: return
        return;
    }
    fn block_1360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1360_0: const #1u : u8
        let s_1360_0: bool = true;
        // D s_1360_1: write-var gs#407458 <= s_1360_0
        fn_state.gs_407458 = s_1360_0;
        // N s_1360_2: jump b1357
        return block_1357(state, tracer, fn_state);
    }
    fn block_1361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1361_0: const #1u : u8
        let s_1361_0: bool = true;
        // D s_1361_1: write-var gs#407455 <= s_1361_0
        fn_state.gs_407455 = s_1361_0;
        // N s_1361_2: jump b1355
        return block_1355(state, tracer, fn_state);
    }
    fn block_1362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1362_0: const #1u : u8
        let s_1362_0: bool = true;
        // D s_1362_1: write-var gs#407452 <= s_1362_0
        fn_state.gs_407452 = s_1362_0;
        // N s_1362_2: jump b1353
        return block_1353(state, tracer, fn_state);
    }
    fn block_1363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1363_0: const #1u : u8
        let s_1363_0: bool = true;
        // D s_1363_1: write-var gs#407449 <= s_1363_0
        fn_state.gs_407449 = s_1363_0;
        // N s_1363_2: jump b1351
        return block_1351(state, tracer, fn_state);
    }
    fn block_1364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1364_0: const #1u : u8
        let s_1364_0: bool = true;
        // D s_1364_1: write-var gs#407446 <= s_1364_0
        fn_state.gs_407446 = s_1364_0;
        // N s_1364_2: jump b1349
        return block_1349(state, tracer, fn_state);
    }
    fn block_1365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1365_0: const #1u : u8
        let s_1365_0: bool = true;
        // D s_1365_1: write-var gs#407443 <= s_1365_0
        fn_state.gs_407443 = s_1365_0;
        // N s_1365_2: jump b1347
        return block_1347(state, tracer, fn_state);
    }
    fn block_1366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1366_0: const #1u : u8
        let s_1366_0: bool = true;
        // D s_1366_1: write-var gs#407440 <= s_1366_0
        fn_state.gs_407440 = s_1366_0;
        // N s_1366_2: jump b1345
        return block_1345(state, tracer, fn_state);
    }
    fn block_1367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1367_0: read-var merge#var.1:struct
        let s_1367_0: u32 = fn_state.merge_var._1;
        // D s_1367_1: write-var u#33137 <= s_1367_0
        fn_state.u_33137 = s_1367_0;
        // C s_1367_2: const #0s : i
        let s_1367_2: i128 = 0;
        // D s_1367_3: read-var u#33137:u32
        let s_1367_3: u32 = fn_state.u_33137;
        // D s_1367_4: cast zx s_1367_3 -> bv
        let s_1367_4: Bits = Bits::new(s_1367_3 as u128, 32u16);
        // C s_1367_5: const #1s : i64
        let s_1367_5: i64 = 1;
        // C s_1367_6: cast zx s_1367_5 -> i
        let s_1367_6: i128 = (i128::try_from(s_1367_5).unwrap());
        // C s_1367_7: const #27s : i
        let s_1367_7: i128 = 27;
        // C s_1367_8: add s_1367_7 s_1367_6
        let s_1367_8: i128 = (s_1367_7 + s_1367_6);
        // D s_1367_9: bit-extract s_1367_4 s_1367_2 s_1367_8
        let s_1367_9: Bits = (Bits::new(
            ((s_1367_4) >> (s_1367_2)).value(),
            u16::try_from(s_1367_8).unwrap(),
        ));
        // D s_1367_10: cast reint s_1367_9 -> u28
        let s_1367_10: u32 = (s_1367_9.value() as u32);
        // D s_1367_11: cast zx s_1367_10 -> bv
        let s_1367_11: Bits = Bits::new(s_1367_10 as u128, 28u16);
        // C s_1367_12: const #52490241u : u28
        let s_1367_12: u32 = 52490241;
        // C s_1367_13: cast zx s_1367_12 -> bv
        let s_1367_13: Bits = Bits::new(s_1367_12 as u128, 28u16);
        // D s_1367_14: cmp-eq s_1367_11 s_1367_13
        let s_1367_14: bool = ((s_1367_11) == (s_1367_13));
        // N s_1367_15: branch s_1367_14 b2212 b1368
        if s_1367_14 {
            return block_2212(state, tracer, fn_state);
        } else {
            return block_1368(state, tracer, fn_state);
        };
    }
    fn block_1368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1368_0: const #0u : u8
        let s_1368_0: bool = false;
        // D s_1368_1: write-var gs#407466 <= s_1368_0
        fn_state.gs_407466 = s_1368_0;
        // N s_1368_2: jump b1369
        return block_1369(state, tracer, fn_state);
    }
    fn block_1369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1369_0: read-var gs#407466:u8
        let s_1369_0: bool = fn_state.gs_407466;
        // D s_1369_1: not s_1369_0
        let s_1369_1: bool = !s_1369_0;
        // N s_1369_2: branch s_1369_1 b1394 b1370
        if s_1369_1 {
            return block_1394(state, tracer, fn_state);
        } else {
            return block_1370(state, tracer, fn_state);
        };
    }
    fn block_1370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1370_0: const #3766s : i
        let s_1370_0: i128 = 3766;
        // C s_1370_1: const #14696u : u32
        let s_1370_1: u32 = 14696;
        // N s_1370_2: write-reg s_1370_1 <= s_1370_0
        let s_1370_2: () = {
            state.write_register::<i128>(s_1370_1 as isize, s_1370_0);
            tracer.write_register(s_1370_1 as isize, s_1370_0);
        };
        // C s_1370_3: const #28s : i
        let s_1370_3: i128 = 28;
        // C s_1370_4: const #4s : i
        let s_1370_4: i128 = 4;
        // D s_1370_5: read-var u#33137:u32
        let s_1370_5: u32 = fn_state.u_33137;
        // D s_1370_6: cast zx s_1370_5 -> bv
        let s_1370_6: Bits = Bits::new(s_1370_5 as u128, 32u16);
        // D s_1370_7: bit-extract s_1370_6 s_1370_3 s_1370_4
        let s_1370_7: Bits = (Bits::new(
            ((s_1370_6) >> (s_1370_3)).value(),
            u16::try_from(s_1370_4).unwrap(),
        ));
        // D s_1370_8: cast reint s_1370_7 -> u8
        let s_1370_8: u8 = (s_1370_7.value() as u8);
        // D s_1370_9: write-var u#33138 <= s_1370_8
        fn_state.u_33138 = s_1370_8;
        // C s_1370_10: const #12s : i
        let s_1370_10: i128 = 12;
        // D s_1370_11: read-var u#33137:u32
        let s_1370_11: u32 = fn_state.u_33137;
        // D s_1370_12: cast zx s_1370_11 -> bv
        let s_1370_12: Bits = Bits::new(s_1370_11 as u128, 32u16);
        // C s_1370_13: const #1u : u64
        let s_1370_13: u64 = 1;
        // D s_1370_14: bit-extract s_1370_12 s_1370_10 s_1370_13
        let s_1370_14: Bits = (Bits::new(
            ((s_1370_12) >> (s_1370_10)).value(),
            u16::try_from(s_1370_13).unwrap(),
        ));
        // D s_1370_15: cast reint s_1370_14 -> u8
        let s_1370_15: bool = ((s_1370_14.value()) != 0);
        // C s_1370_16: const #0s : i
        let s_1370_16: i128 = 0;
        // C s_1370_17: const #0u : u64
        let s_1370_17: u64 = 0;
        // D s_1370_18: cast zx s_1370_15 -> u64
        let s_1370_18: u64 = (s_1370_15 as u64);
        // C s_1370_19: const #1u : u64
        let s_1370_19: u64 = 1;
        // D s_1370_20: and s_1370_18 s_1370_19
        let s_1370_20: u64 = ((s_1370_18) & (s_1370_19));
        // D s_1370_21: cmp-eq s_1370_20 s_1370_19
        let s_1370_21: bool = ((s_1370_20) == (s_1370_19));
        // D s_1370_22: lsl s_1370_18 s_1370_16
        let s_1370_22: u64 = s_1370_18 << s_1370_16;
        // D s_1370_23: or s_1370_17 s_1370_22
        let s_1370_23: u64 = ((s_1370_17) | (s_1370_22));
        // D s_1370_24: cmpl s_1370_22
        let s_1370_24: u64 = !s_1370_22;
        // D s_1370_25: and s_1370_17 s_1370_24
        let s_1370_25: u64 = ((s_1370_17) & (s_1370_24));
        // D s_1370_26: select s_1370_21 s_1370_23 s_1370_25
        let s_1370_26: u64 = if s_1370_21 { s_1370_23 } else { s_1370_25 };
        // D s_1370_27: cast trunc s_1370_26 -> u8
        let s_1370_27: bool = ((s_1370_26) != 0);
        // D s_1370_28: cast zx s_1370_27 -> bv
        let s_1370_28: Bits = Bits::new(s_1370_27 as u128, 1u16);
        // C s_1370_29: const #1u : u8
        let s_1370_29: bool = true;
        // C s_1370_30: cast zx s_1370_29 -> bv
        let s_1370_30: Bits = Bits::new(s_1370_29 as u128, 1u16);
        // D s_1370_31: cmp-ne s_1370_28 s_1370_30
        let s_1370_31: bool = ((s_1370_28) != (s_1370_30));
        // N s_1370_32: branch s_1370_31 b1393 b1371
        if s_1370_31 {
            return block_1393(state, tracer, fn_state);
        } else {
            return block_1371(state, tracer, fn_state);
        };
    }
    fn block_1371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1371_0: const #13s : i
        let s_1371_0: i128 = 13;
        // D s_1371_1: read-var u#33137:u32
        let s_1371_1: u32 = fn_state.u_33137;
        // D s_1371_2: cast zx s_1371_1 -> bv
        let s_1371_2: Bits = Bits::new(s_1371_1 as u128, 32u16);
        // C s_1371_3: const #1u : u64
        let s_1371_3: u64 = 1;
        // D s_1371_4: bit-extract s_1371_2 s_1371_0 s_1371_3
        let s_1371_4: Bits = (Bits::new(
            ((s_1371_2) >> (s_1371_0)).value(),
            u16::try_from(s_1371_3).unwrap(),
        ));
        // D s_1371_5: cast reint s_1371_4 -> u8
        let s_1371_5: bool = ((s_1371_4.value()) != 0);
        // C s_1371_6: const #0s : i
        let s_1371_6: i128 = 0;
        // C s_1371_7: const #0u : u64
        let s_1371_7: u64 = 0;
        // D s_1371_8: cast zx s_1371_5 -> u64
        let s_1371_8: u64 = (s_1371_5 as u64);
        // C s_1371_9: const #1u : u64
        let s_1371_9: u64 = 1;
        // D s_1371_10: and s_1371_8 s_1371_9
        let s_1371_10: u64 = ((s_1371_8) & (s_1371_9));
        // D s_1371_11: cmp-eq s_1371_10 s_1371_9
        let s_1371_11: bool = ((s_1371_10) == (s_1371_9));
        // D s_1371_12: lsl s_1371_8 s_1371_6
        let s_1371_12: u64 = s_1371_8 << s_1371_6;
        // D s_1371_13: or s_1371_7 s_1371_12
        let s_1371_13: u64 = ((s_1371_7) | (s_1371_12));
        // D s_1371_14: cmpl s_1371_12
        let s_1371_14: u64 = !s_1371_12;
        // D s_1371_15: and s_1371_7 s_1371_14
        let s_1371_15: u64 = ((s_1371_7) & (s_1371_14));
        // D s_1371_16: select s_1371_11 s_1371_13 s_1371_15
        let s_1371_16: u64 = if s_1371_11 { s_1371_13 } else { s_1371_15 };
        // D s_1371_17: cast trunc s_1371_16 -> u8
        let s_1371_17: bool = ((s_1371_16) != 0);
        // D s_1371_18: cast zx s_1371_17 -> bv
        let s_1371_18: Bits = Bits::new(s_1371_17 as u128, 1u16);
        // C s_1371_19: const #1u : u8
        let s_1371_19: bool = true;
        // C s_1371_20: cast zx s_1371_19 -> bv
        let s_1371_20: Bits = Bits::new(s_1371_19 as u128, 1u16);
        // D s_1371_21: cmp-ne s_1371_18 s_1371_20
        let s_1371_21: bool = ((s_1371_18) != (s_1371_20));
        // D s_1371_22: write-var gs#407475 <= s_1371_21
        fn_state.gs_407475 = s_1371_21;
        // N s_1371_23: jump b1372
        return block_1372(state, tracer, fn_state);
    }
    fn block_1372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1372_0: read-var gs#407475:u8
        let s_1372_0: bool = fn_state.gs_407475;
        // N s_1372_1: branch s_1372_0 b1392 b1373
        if s_1372_0 {
            return block_1392(state, tracer, fn_state);
        } else {
            return block_1373(state, tracer, fn_state);
        };
    }
    fn block_1373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1373_0: const #14s : i
        let s_1373_0: i128 = 14;
        // D s_1373_1: read-var u#33137:u32
        let s_1373_1: u32 = fn_state.u_33137;
        // D s_1373_2: cast zx s_1373_1 -> bv
        let s_1373_2: Bits = Bits::new(s_1373_1 as u128, 32u16);
        // C s_1373_3: const #1u : u64
        let s_1373_3: u64 = 1;
        // D s_1373_4: bit-extract s_1373_2 s_1373_0 s_1373_3
        let s_1373_4: Bits = (Bits::new(
            ((s_1373_2) >> (s_1373_0)).value(),
            u16::try_from(s_1373_3).unwrap(),
        ));
        // D s_1373_5: cast reint s_1373_4 -> u8
        let s_1373_5: bool = ((s_1373_4.value()) != 0);
        // C s_1373_6: const #0s : i
        let s_1373_6: i128 = 0;
        // C s_1373_7: const #0u : u64
        let s_1373_7: u64 = 0;
        // D s_1373_8: cast zx s_1373_5 -> u64
        let s_1373_8: u64 = (s_1373_5 as u64);
        // C s_1373_9: const #1u : u64
        let s_1373_9: u64 = 1;
        // D s_1373_10: and s_1373_8 s_1373_9
        let s_1373_10: u64 = ((s_1373_8) & (s_1373_9));
        // D s_1373_11: cmp-eq s_1373_10 s_1373_9
        let s_1373_11: bool = ((s_1373_10) == (s_1373_9));
        // D s_1373_12: lsl s_1373_8 s_1373_6
        let s_1373_12: u64 = s_1373_8 << s_1373_6;
        // D s_1373_13: or s_1373_7 s_1373_12
        let s_1373_13: u64 = ((s_1373_7) | (s_1373_12));
        // D s_1373_14: cmpl s_1373_12
        let s_1373_14: u64 = !s_1373_12;
        // D s_1373_15: and s_1373_7 s_1373_14
        let s_1373_15: u64 = ((s_1373_7) & (s_1373_14));
        // D s_1373_16: select s_1373_11 s_1373_13 s_1373_15
        let s_1373_16: u64 = if s_1373_11 { s_1373_13 } else { s_1373_15 };
        // D s_1373_17: cast trunc s_1373_16 -> u8
        let s_1373_17: bool = ((s_1373_16) != 0);
        // D s_1373_18: cast zx s_1373_17 -> bv
        let s_1373_18: Bits = Bits::new(s_1373_17 as u128, 1u16);
        // C s_1373_19: const #1u : u8
        let s_1373_19: bool = true;
        // C s_1373_20: cast zx s_1373_19 -> bv
        let s_1373_20: Bits = Bits::new(s_1373_19 as u128, 1u16);
        // D s_1373_21: cmp-ne s_1373_18 s_1373_20
        let s_1373_21: bool = ((s_1373_18) != (s_1373_20));
        // D s_1373_22: write-var gs#407478 <= s_1373_21
        fn_state.gs_407478 = s_1373_21;
        // N s_1373_23: jump b1374
        return block_1374(state, tracer, fn_state);
    }
    fn block_1374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1374_0: read-var gs#407478:u8
        let s_1374_0: bool = fn_state.gs_407478;
        // N s_1374_1: branch s_1374_0 b1391 b1375
        if s_1374_0 {
            return block_1391(state, tracer, fn_state);
        } else {
            return block_1375(state, tracer, fn_state);
        };
    }
    fn block_1375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1375_0: const #15s : i
        let s_1375_0: i128 = 15;
        // D s_1375_1: read-var u#33137:u32
        let s_1375_1: u32 = fn_state.u_33137;
        // D s_1375_2: cast zx s_1375_1 -> bv
        let s_1375_2: Bits = Bits::new(s_1375_1 as u128, 32u16);
        // C s_1375_3: const #1u : u64
        let s_1375_3: u64 = 1;
        // D s_1375_4: bit-extract s_1375_2 s_1375_0 s_1375_3
        let s_1375_4: Bits = (Bits::new(
            ((s_1375_2) >> (s_1375_0)).value(),
            u16::try_from(s_1375_3).unwrap(),
        ));
        // D s_1375_5: cast reint s_1375_4 -> u8
        let s_1375_5: bool = ((s_1375_4.value()) != 0);
        // C s_1375_6: const #0s : i
        let s_1375_6: i128 = 0;
        // C s_1375_7: const #0u : u64
        let s_1375_7: u64 = 0;
        // D s_1375_8: cast zx s_1375_5 -> u64
        let s_1375_8: u64 = (s_1375_5 as u64);
        // C s_1375_9: const #1u : u64
        let s_1375_9: u64 = 1;
        // D s_1375_10: and s_1375_8 s_1375_9
        let s_1375_10: u64 = ((s_1375_8) & (s_1375_9));
        // D s_1375_11: cmp-eq s_1375_10 s_1375_9
        let s_1375_11: bool = ((s_1375_10) == (s_1375_9));
        // D s_1375_12: lsl s_1375_8 s_1375_6
        let s_1375_12: u64 = s_1375_8 << s_1375_6;
        // D s_1375_13: or s_1375_7 s_1375_12
        let s_1375_13: u64 = ((s_1375_7) | (s_1375_12));
        // D s_1375_14: cmpl s_1375_12
        let s_1375_14: u64 = !s_1375_12;
        // D s_1375_15: and s_1375_7 s_1375_14
        let s_1375_15: u64 = ((s_1375_7) & (s_1375_14));
        // D s_1375_16: select s_1375_11 s_1375_13 s_1375_15
        let s_1375_16: u64 = if s_1375_11 { s_1375_13 } else { s_1375_15 };
        // D s_1375_17: cast trunc s_1375_16 -> u8
        let s_1375_17: bool = ((s_1375_16) != 0);
        // D s_1375_18: cast zx s_1375_17 -> bv
        let s_1375_18: Bits = Bits::new(s_1375_17 as u128, 1u16);
        // C s_1375_19: const #1u : u8
        let s_1375_19: bool = true;
        // C s_1375_20: cast zx s_1375_19 -> bv
        let s_1375_20: Bits = Bits::new(s_1375_19 as u128, 1u16);
        // D s_1375_21: cmp-ne s_1375_18 s_1375_20
        let s_1375_21: bool = ((s_1375_18) != (s_1375_20));
        // D s_1375_22: write-var gs#407481 <= s_1375_21
        fn_state.gs_407481 = s_1375_21;
        // N s_1375_23: jump b1376
        return block_1376(state, tracer, fn_state);
    }
    fn block_1376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1376_0: read-var gs#407481:u8
        let s_1376_0: bool = fn_state.gs_407481;
        // N s_1376_1: branch s_1376_0 b1390 b1377
        if s_1376_0 {
            return block_1390(state, tracer, fn_state);
        } else {
            return block_1377(state, tracer, fn_state);
        };
    }
    fn block_1377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1377_0: const #8s : i
        let s_1377_0: i128 = 8;
        // D s_1377_1: read-var u#33137:u32
        let s_1377_1: u32 = fn_state.u_33137;
        // D s_1377_2: cast zx s_1377_1 -> bv
        let s_1377_2: Bits = Bits::new(s_1377_1 as u128, 32u16);
        // C s_1377_3: const #1u : u64
        let s_1377_3: u64 = 1;
        // D s_1377_4: bit-extract s_1377_2 s_1377_0 s_1377_3
        let s_1377_4: Bits = (Bits::new(
            ((s_1377_2) >> (s_1377_0)).value(),
            u16::try_from(s_1377_3).unwrap(),
        ));
        // D s_1377_5: cast reint s_1377_4 -> u8
        let s_1377_5: bool = ((s_1377_4.value()) != 0);
        // C s_1377_6: const #0s : i
        let s_1377_6: i128 = 0;
        // C s_1377_7: const #0u : u64
        let s_1377_7: u64 = 0;
        // D s_1377_8: cast zx s_1377_5 -> u64
        let s_1377_8: u64 = (s_1377_5 as u64);
        // C s_1377_9: const #1u : u64
        let s_1377_9: u64 = 1;
        // D s_1377_10: and s_1377_8 s_1377_9
        let s_1377_10: u64 = ((s_1377_8) & (s_1377_9));
        // D s_1377_11: cmp-eq s_1377_10 s_1377_9
        let s_1377_11: bool = ((s_1377_10) == (s_1377_9));
        // D s_1377_12: lsl s_1377_8 s_1377_6
        let s_1377_12: u64 = s_1377_8 << s_1377_6;
        // D s_1377_13: or s_1377_7 s_1377_12
        let s_1377_13: u64 = ((s_1377_7) | (s_1377_12));
        // D s_1377_14: cmpl s_1377_12
        let s_1377_14: u64 = !s_1377_12;
        // D s_1377_15: and s_1377_7 s_1377_14
        let s_1377_15: u64 = ((s_1377_7) & (s_1377_14));
        // D s_1377_16: select s_1377_11 s_1377_13 s_1377_15
        let s_1377_16: u64 = if s_1377_11 { s_1377_13 } else { s_1377_15 };
        // D s_1377_17: cast trunc s_1377_16 -> u8
        let s_1377_17: bool = ((s_1377_16) != 0);
        // D s_1377_18: cast zx s_1377_17 -> bv
        let s_1377_18: Bits = Bits::new(s_1377_17 as u128, 1u16);
        // C s_1377_19: const #0u : u8
        let s_1377_19: bool = false;
        // C s_1377_20: cast zx s_1377_19 -> bv
        let s_1377_20: Bits = Bits::new(s_1377_19 as u128, 1u16);
        // D s_1377_21: cmp-ne s_1377_18 s_1377_20
        let s_1377_21: bool = ((s_1377_18) != (s_1377_20));
        // D s_1377_22: write-var gs#407484 <= s_1377_21
        fn_state.gs_407484 = s_1377_21;
        // N s_1377_23: jump b1378
        return block_1378(state, tracer, fn_state);
    }
    fn block_1378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1378_0: read-var gs#407484:u8
        let s_1378_0: bool = fn_state.gs_407484;
        // N s_1378_1: branch s_1378_0 b1389 b1379
        if s_1378_0 {
            return block_1389(state, tracer, fn_state);
        } else {
            return block_1379(state, tracer, fn_state);
        };
    }
    fn block_1379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1379_0: const #9s : i
        let s_1379_0: i128 = 9;
        // D s_1379_1: read-var u#33137:u32
        let s_1379_1: u32 = fn_state.u_33137;
        // D s_1379_2: cast zx s_1379_1 -> bv
        let s_1379_2: Bits = Bits::new(s_1379_1 as u128, 32u16);
        // C s_1379_3: const #1u : u64
        let s_1379_3: u64 = 1;
        // D s_1379_4: bit-extract s_1379_2 s_1379_0 s_1379_3
        let s_1379_4: Bits = (Bits::new(
            ((s_1379_2) >> (s_1379_0)).value(),
            u16::try_from(s_1379_3).unwrap(),
        ));
        // D s_1379_5: cast reint s_1379_4 -> u8
        let s_1379_5: bool = ((s_1379_4.value()) != 0);
        // C s_1379_6: const #0s : i
        let s_1379_6: i128 = 0;
        // C s_1379_7: const #0u : u64
        let s_1379_7: u64 = 0;
        // D s_1379_8: cast zx s_1379_5 -> u64
        let s_1379_8: u64 = (s_1379_5 as u64);
        // C s_1379_9: const #1u : u64
        let s_1379_9: u64 = 1;
        // D s_1379_10: and s_1379_8 s_1379_9
        let s_1379_10: u64 = ((s_1379_8) & (s_1379_9));
        // D s_1379_11: cmp-eq s_1379_10 s_1379_9
        let s_1379_11: bool = ((s_1379_10) == (s_1379_9));
        // D s_1379_12: lsl s_1379_8 s_1379_6
        let s_1379_12: u64 = s_1379_8 << s_1379_6;
        // D s_1379_13: or s_1379_7 s_1379_12
        let s_1379_13: u64 = ((s_1379_7) | (s_1379_12));
        // D s_1379_14: cmpl s_1379_12
        let s_1379_14: u64 = !s_1379_12;
        // D s_1379_15: and s_1379_7 s_1379_14
        let s_1379_15: u64 = ((s_1379_7) & (s_1379_14));
        // D s_1379_16: select s_1379_11 s_1379_13 s_1379_15
        let s_1379_16: u64 = if s_1379_11 { s_1379_13 } else { s_1379_15 };
        // D s_1379_17: cast trunc s_1379_16 -> u8
        let s_1379_17: bool = ((s_1379_16) != 0);
        // D s_1379_18: cast zx s_1379_17 -> bv
        let s_1379_18: Bits = Bits::new(s_1379_17 as u128, 1u16);
        // C s_1379_19: const #0u : u8
        let s_1379_19: bool = false;
        // C s_1379_20: cast zx s_1379_19 -> bv
        let s_1379_20: Bits = Bits::new(s_1379_19 as u128, 1u16);
        // D s_1379_21: cmp-ne s_1379_18 s_1379_20
        let s_1379_21: bool = ((s_1379_18) != (s_1379_20));
        // D s_1379_22: write-var gs#407487 <= s_1379_21
        fn_state.gs_407487 = s_1379_21;
        // N s_1379_23: jump b1380
        return block_1380(state, tracer, fn_state);
    }
    fn block_1380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1380_0: read-var gs#407487:u8
        let s_1380_0: bool = fn_state.gs_407487;
        // N s_1380_1: branch s_1380_0 b1388 b1381
        if s_1380_0 {
            return block_1388(state, tracer, fn_state);
        } else {
            return block_1381(state, tracer, fn_state);
        };
    }
    fn block_1381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1381_0: const #10s : i
        let s_1381_0: i128 = 10;
        // D s_1381_1: read-var u#33137:u32
        let s_1381_1: u32 = fn_state.u_33137;
        // D s_1381_2: cast zx s_1381_1 -> bv
        let s_1381_2: Bits = Bits::new(s_1381_1 as u128, 32u16);
        // C s_1381_3: const #1u : u64
        let s_1381_3: u64 = 1;
        // D s_1381_4: bit-extract s_1381_2 s_1381_0 s_1381_3
        let s_1381_4: Bits = (Bits::new(
            ((s_1381_2) >> (s_1381_0)).value(),
            u16::try_from(s_1381_3).unwrap(),
        ));
        // D s_1381_5: cast reint s_1381_4 -> u8
        let s_1381_5: bool = ((s_1381_4.value()) != 0);
        // C s_1381_6: const #0s : i
        let s_1381_6: i128 = 0;
        // C s_1381_7: const #0u : u64
        let s_1381_7: u64 = 0;
        // D s_1381_8: cast zx s_1381_5 -> u64
        let s_1381_8: u64 = (s_1381_5 as u64);
        // C s_1381_9: const #1u : u64
        let s_1381_9: u64 = 1;
        // D s_1381_10: and s_1381_8 s_1381_9
        let s_1381_10: u64 = ((s_1381_8) & (s_1381_9));
        // D s_1381_11: cmp-eq s_1381_10 s_1381_9
        let s_1381_11: bool = ((s_1381_10) == (s_1381_9));
        // D s_1381_12: lsl s_1381_8 s_1381_6
        let s_1381_12: u64 = s_1381_8 << s_1381_6;
        // D s_1381_13: or s_1381_7 s_1381_12
        let s_1381_13: u64 = ((s_1381_7) | (s_1381_12));
        // D s_1381_14: cmpl s_1381_12
        let s_1381_14: u64 = !s_1381_12;
        // D s_1381_15: and s_1381_7 s_1381_14
        let s_1381_15: u64 = ((s_1381_7) & (s_1381_14));
        // D s_1381_16: select s_1381_11 s_1381_13 s_1381_15
        let s_1381_16: u64 = if s_1381_11 { s_1381_13 } else { s_1381_15 };
        // D s_1381_17: cast trunc s_1381_16 -> u8
        let s_1381_17: bool = ((s_1381_16) != 0);
        // D s_1381_18: cast zx s_1381_17 -> bv
        let s_1381_18: Bits = Bits::new(s_1381_17 as u128, 1u16);
        // C s_1381_19: const #0u : u8
        let s_1381_19: bool = false;
        // C s_1381_20: cast zx s_1381_19 -> bv
        let s_1381_20: Bits = Bits::new(s_1381_19 as u128, 1u16);
        // D s_1381_21: cmp-ne s_1381_18 s_1381_20
        let s_1381_21: bool = ((s_1381_18) != (s_1381_20));
        // D s_1381_22: write-var gs#407490 <= s_1381_21
        fn_state.gs_407490 = s_1381_21;
        // N s_1381_23: jump b1382
        return block_1382(state, tracer, fn_state);
    }
    fn block_1382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1382_0: read-var gs#407490:u8
        let s_1382_0: bool = fn_state.gs_407490;
        // N s_1382_1: branch s_1382_0 b1387 b1383
        if s_1382_0 {
            return block_1387(state, tracer, fn_state);
        } else {
            return block_1383(state, tracer, fn_state);
        };
    }
    fn block_1383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1383_0: const #11s : i
        let s_1383_0: i128 = 11;
        // D s_1383_1: read-var u#33137:u32
        let s_1383_1: u32 = fn_state.u_33137;
        // D s_1383_2: cast zx s_1383_1 -> bv
        let s_1383_2: Bits = Bits::new(s_1383_1 as u128, 32u16);
        // C s_1383_3: const #1u : u64
        let s_1383_3: u64 = 1;
        // D s_1383_4: bit-extract s_1383_2 s_1383_0 s_1383_3
        let s_1383_4: Bits = (Bits::new(
            ((s_1383_2) >> (s_1383_0)).value(),
            u16::try_from(s_1383_3).unwrap(),
        ));
        // D s_1383_5: cast reint s_1383_4 -> u8
        let s_1383_5: bool = ((s_1383_4.value()) != 0);
        // C s_1383_6: const #0s : i
        let s_1383_6: i128 = 0;
        // C s_1383_7: const #0u : u64
        let s_1383_7: u64 = 0;
        // D s_1383_8: cast zx s_1383_5 -> u64
        let s_1383_8: u64 = (s_1383_5 as u64);
        // C s_1383_9: const #1u : u64
        let s_1383_9: u64 = 1;
        // D s_1383_10: and s_1383_8 s_1383_9
        let s_1383_10: u64 = ((s_1383_8) & (s_1383_9));
        // D s_1383_11: cmp-eq s_1383_10 s_1383_9
        let s_1383_11: bool = ((s_1383_10) == (s_1383_9));
        // D s_1383_12: lsl s_1383_8 s_1383_6
        let s_1383_12: u64 = s_1383_8 << s_1383_6;
        // D s_1383_13: or s_1383_7 s_1383_12
        let s_1383_13: u64 = ((s_1383_7) | (s_1383_12));
        // D s_1383_14: cmpl s_1383_12
        let s_1383_14: u64 = !s_1383_12;
        // D s_1383_15: and s_1383_7 s_1383_14
        let s_1383_15: u64 = ((s_1383_7) & (s_1383_14));
        // D s_1383_16: select s_1383_11 s_1383_13 s_1383_15
        let s_1383_16: u64 = if s_1383_11 { s_1383_13 } else { s_1383_15 };
        // D s_1383_17: cast trunc s_1383_16 -> u8
        let s_1383_17: bool = ((s_1383_16) != 0);
        // D s_1383_18: cast zx s_1383_17 -> bv
        let s_1383_18: Bits = Bits::new(s_1383_17 as u128, 1u16);
        // C s_1383_19: const #0u : u8
        let s_1383_19: bool = false;
        // C s_1383_20: cast zx s_1383_19 -> bv
        let s_1383_20: Bits = Bits::new(s_1383_19 as u128, 1u16);
        // D s_1383_21: cmp-ne s_1383_18 s_1383_20
        let s_1383_21: bool = ((s_1383_18) != (s_1383_20));
        // D s_1383_22: write-var gs#407493 <= s_1383_21
        fn_state.gs_407493 = s_1383_21;
        // N s_1383_23: jump b1384
        return block_1384(state, tracer, fn_state);
    }
    fn block_1384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1384_0: read-var gs#407493:u8
        let s_1384_0: bool = fn_state.gs_407493;
        // N s_1384_1: branch s_1384_0 b1386 b1385
        if s_1384_0 {
            return block_1386(state, tracer, fn_state);
        } else {
            return block_1385(state, tracer, fn_state);
        };
    }
    fn block_1385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1385_0: read-var u#33138:u8
        let s_1385_0: u8 = fn_state.u_33138;
        // D s_1385_1: call decode_aarch32_instrs_YIELD_A1enc_A_txt(s_1385_0)
        let s_1385_1: () = decode_aarch32_instrs_YIELD_A1enc_A_txt(
            state,
            tracer,
            s_1385_0,
        );
        // N s_1385_2: return
        return;
    }
    fn block_1386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1386_0: panic
        panic!("{:?}", ());
        // N s_1386_1: return
        return;
    }
    fn block_1387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1387_0: const #1u : u8
        let s_1387_0: bool = true;
        // D s_1387_1: write-var gs#407493 <= s_1387_0
        fn_state.gs_407493 = s_1387_0;
        // N s_1387_2: jump b1384
        return block_1384(state, tracer, fn_state);
    }
    fn block_1388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1388_0: const #1u : u8
        let s_1388_0: bool = true;
        // D s_1388_1: write-var gs#407490 <= s_1388_0
        fn_state.gs_407490 = s_1388_0;
        // N s_1388_2: jump b1382
        return block_1382(state, tracer, fn_state);
    }
    fn block_1389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1389_0: const #1u : u8
        let s_1389_0: bool = true;
        // D s_1389_1: write-var gs#407487 <= s_1389_0
        fn_state.gs_407487 = s_1389_0;
        // N s_1389_2: jump b1380
        return block_1380(state, tracer, fn_state);
    }
    fn block_1390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1390_0: const #1u : u8
        let s_1390_0: bool = true;
        // D s_1390_1: write-var gs#407484 <= s_1390_0
        fn_state.gs_407484 = s_1390_0;
        // N s_1390_2: jump b1378
        return block_1378(state, tracer, fn_state);
    }
    fn block_1391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1391_0: const #1u : u8
        let s_1391_0: bool = true;
        // D s_1391_1: write-var gs#407481 <= s_1391_0
        fn_state.gs_407481 = s_1391_0;
        // N s_1391_2: jump b1376
        return block_1376(state, tracer, fn_state);
    }
    fn block_1392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1392_0: const #1u : u8
        let s_1392_0: bool = true;
        // D s_1392_1: write-var gs#407478 <= s_1392_0
        fn_state.gs_407478 = s_1392_0;
        // N s_1392_2: jump b1374
        return block_1374(state, tracer, fn_state);
    }
    fn block_1393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1393_0: const #1u : u8
        let s_1393_0: bool = true;
        // D s_1393_1: write-var gs#407475 <= s_1393_0
        fn_state.gs_407475 = s_1393_0;
        // N s_1393_2: jump b1372
        return block_1372(state, tracer, fn_state);
    }
    fn block_1394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1394_0: read-var merge#var.1:struct
        let s_1394_0: u32 = fn_state.merge_var._1;
        // D s_1394_1: write-var u#33140 <= s_1394_0
        fn_state.u_33140 = s_1394_0;
        // C s_1394_2: const #0s : i
        let s_1394_2: i128 = 0;
        // D s_1394_3: read-var u#33140:u32
        let s_1394_3: u32 = fn_state.u_33140;
        // D s_1394_4: cast zx s_1394_3 -> bv
        let s_1394_4: Bits = Bits::new(s_1394_3 as u128, 32u16);
        // C s_1394_5: const #1s : i64
        let s_1394_5: i64 = 1;
        // C s_1394_6: cast zx s_1394_5 -> i
        let s_1394_6: i128 = (i128::try_from(s_1394_5).unwrap());
        // C s_1394_7: const #27s : i
        let s_1394_7: i128 = 27;
        // C s_1394_8: add s_1394_7 s_1394_6
        let s_1394_8: i128 = (s_1394_7 + s_1394_6);
        // D s_1394_9: bit-extract s_1394_4 s_1394_2 s_1394_8
        let s_1394_9: Bits = (Bits::new(
            ((s_1394_4) >> (s_1394_2)).value(),
            u16::try_from(s_1394_8).unwrap(),
        ));
        // D s_1394_10: cast reint s_1394_9 -> u28
        let s_1394_10: u32 = (s_1394_9.value() as u32);
        // D s_1394_11: cast zx s_1394_10 -> bv
        let s_1394_11: Bits = Bits::new(s_1394_10 as u128, 28u16);
        // C s_1394_12: const #23068782u : u28
        let s_1394_12: u32 = 23068782;
        // C s_1394_13: cast zx s_1394_12 -> bv
        let s_1394_13: Bits = Bits::new(s_1394_12 as u128, 28u16);
        // D s_1394_14: cmp-eq s_1394_11 s_1394_13
        let s_1394_14: bool = ((s_1394_11) == (s_1394_13));
        // N s_1394_15: branch s_1394_14 b2208 b1395
        if s_1394_14 {
            return block_2208(state, tracer, fn_state);
        } else {
            return block_1395(state, tracer, fn_state);
        };
    }
    fn block_1395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1395_0: const #0u : u8
        let s_1395_0: bool = false;
        // D s_1395_1: write-var gs#407501 <= s_1395_0
        fn_state.gs_407501 = s_1395_0;
        // N s_1395_2: jump b1396
        return block_1396(state, tracer, fn_state);
    }
    fn block_1396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1396_0: read-var gs#407501:u8
        let s_1396_0: bool = fn_state.gs_407501;
        // D s_1396_1: not s_1396_0
        let s_1396_1: bool = !s_1396_0;
        // N s_1396_2: branch s_1396_1 b1445 b1397
        if s_1396_1 {
            return block_1445(state, tracer, fn_state);
        } else {
            return block_1397(state, tracer, fn_state);
        };
    }
    fn block_1397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1397_0: const #3772s : i
        let s_1397_0: i128 = 3772;
        // C s_1397_1: const #14696u : u32
        let s_1397_1: u32 = 14696;
        // N s_1397_2: write-reg s_1397_1 <= s_1397_0
        let s_1397_2: () = {
            state.write_register::<i128>(s_1397_1 as isize, s_1397_0);
            tracer.write_register(s_1397_1 as isize, s_1397_0);
        };
        // C s_1397_3: const #28s : i
        let s_1397_3: i128 = 28;
        // C s_1397_4: const #4s : i
        let s_1397_4: i128 = 4;
        // D s_1397_5: read-var u#33140:u32
        let s_1397_5: u32 = fn_state.u_33140;
        // D s_1397_6: cast zx s_1397_5 -> bv
        let s_1397_6: Bits = Bits::new(s_1397_5 as u128, 32u16);
        // D s_1397_7: bit-extract s_1397_6 s_1397_3 s_1397_4
        let s_1397_7: Bits = (Bits::new(
            ((s_1397_6) >> (s_1397_3)).value(),
            u16::try_from(s_1397_4).unwrap(),
        ));
        // D s_1397_8: cast reint s_1397_7 -> u8
        let s_1397_8: u8 = (s_1397_7.value() as u8);
        // D s_1397_9: write-var u#33141 <= s_1397_8
        fn_state.u_33141 = s_1397_8;
        // C s_1397_10: const #8s : i
        let s_1397_10: i128 = 8;
        // D s_1397_11: read-var u#33140:u32
        let s_1397_11: u32 = fn_state.u_33140;
        // D s_1397_12: cast zx s_1397_11 -> bv
        let s_1397_12: Bits = Bits::new(s_1397_11 as u128, 32u16);
        // C s_1397_13: const #1u : u64
        let s_1397_13: u64 = 1;
        // D s_1397_14: bit-extract s_1397_12 s_1397_10 s_1397_13
        let s_1397_14: Bits = (Bits::new(
            ((s_1397_12) >> (s_1397_10)).value(),
            u16::try_from(s_1397_13).unwrap(),
        ));
        // D s_1397_15: cast reint s_1397_14 -> u8
        let s_1397_15: bool = ((s_1397_14.value()) != 0);
        // C s_1397_16: const #0s : i
        let s_1397_16: i128 = 0;
        // C s_1397_17: const #0u : u64
        let s_1397_17: u64 = 0;
        // D s_1397_18: cast zx s_1397_15 -> u64
        let s_1397_18: u64 = (s_1397_15 as u64);
        // C s_1397_19: const #1u : u64
        let s_1397_19: u64 = 1;
        // D s_1397_20: and s_1397_18 s_1397_19
        let s_1397_20: u64 = ((s_1397_18) & (s_1397_19));
        // D s_1397_21: cmp-eq s_1397_20 s_1397_19
        let s_1397_21: bool = ((s_1397_20) == (s_1397_19));
        // D s_1397_22: lsl s_1397_18 s_1397_16
        let s_1397_22: u64 = s_1397_18 << s_1397_16;
        // D s_1397_23: or s_1397_17 s_1397_22
        let s_1397_23: u64 = ((s_1397_17) | (s_1397_22));
        // D s_1397_24: cmpl s_1397_22
        let s_1397_24: u64 = !s_1397_22;
        // D s_1397_25: and s_1397_17 s_1397_24
        let s_1397_25: u64 = ((s_1397_17) & (s_1397_24));
        // D s_1397_26: select s_1397_21 s_1397_23 s_1397_25
        let s_1397_26: u64 = if s_1397_21 { s_1397_23 } else { s_1397_25 };
        // D s_1397_27: cast trunc s_1397_26 -> u8
        let s_1397_27: bool = ((s_1397_26) != 0);
        // D s_1397_28: cast zx s_1397_27 -> bv
        let s_1397_28: Bits = Bits::new(s_1397_27 as u128, 1u16);
        // C s_1397_29: const #0u : u8
        let s_1397_29: bool = false;
        // C s_1397_30: cast zx s_1397_29 -> bv
        let s_1397_30: Bits = Bits::new(s_1397_29 as u128, 1u16);
        // D s_1397_31: cmp-ne s_1397_28 s_1397_30
        let s_1397_31: bool = ((s_1397_28) != (s_1397_30));
        // N s_1397_32: branch s_1397_31 b1444 b1398
        if s_1397_31 {
            return block_1444(state, tracer, fn_state);
        } else {
            return block_1398(state, tracer, fn_state);
        };
    }
    fn block_1398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1398_0: const #9s : i
        let s_1398_0: i128 = 9;
        // D s_1398_1: read-var u#33140:u32
        let s_1398_1: u32 = fn_state.u_33140;
        // D s_1398_2: cast zx s_1398_1 -> bv
        let s_1398_2: Bits = Bits::new(s_1398_1 as u128, 32u16);
        // C s_1398_3: const #1u : u64
        let s_1398_3: u64 = 1;
        // D s_1398_4: bit-extract s_1398_2 s_1398_0 s_1398_3
        let s_1398_4: Bits = (Bits::new(
            ((s_1398_2) >> (s_1398_0)).value(),
            u16::try_from(s_1398_3).unwrap(),
        ));
        // D s_1398_5: cast reint s_1398_4 -> u8
        let s_1398_5: bool = ((s_1398_4.value()) != 0);
        // C s_1398_6: const #0s : i
        let s_1398_6: i128 = 0;
        // C s_1398_7: const #0u : u64
        let s_1398_7: u64 = 0;
        // D s_1398_8: cast zx s_1398_5 -> u64
        let s_1398_8: u64 = (s_1398_5 as u64);
        // C s_1398_9: const #1u : u64
        let s_1398_9: u64 = 1;
        // D s_1398_10: and s_1398_8 s_1398_9
        let s_1398_10: u64 = ((s_1398_8) & (s_1398_9));
        // D s_1398_11: cmp-eq s_1398_10 s_1398_9
        let s_1398_11: bool = ((s_1398_10) == (s_1398_9));
        // D s_1398_12: lsl s_1398_8 s_1398_6
        let s_1398_12: u64 = s_1398_8 << s_1398_6;
        // D s_1398_13: or s_1398_7 s_1398_12
        let s_1398_13: u64 = ((s_1398_7) | (s_1398_12));
        // D s_1398_14: cmpl s_1398_12
        let s_1398_14: u64 = !s_1398_12;
        // D s_1398_15: and s_1398_7 s_1398_14
        let s_1398_15: u64 = ((s_1398_7) & (s_1398_14));
        // D s_1398_16: select s_1398_11 s_1398_13 s_1398_15
        let s_1398_16: u64 = if s_1398_11 { s_1398_13 } else { s_1398_15 };
        // D s_1398_17: cast trunc s_1398_16 -> u8
        let s_1398_17: bool = ((s_1398_16) != 0);
        // D s_1398_18: cast zx s_1398_17 -> bv
        let s_1398_18: Bits = Bits::new(s_1398_17 as u128, 1u16);
        // C s_1398_19: const #0u : u8
        let s_1398_19: bool = false;
        // C s_1398_20: cast zx s_1398_19 -> bv
        let s_1398_20: Bits = Bits::new(s_1398_19 as u128, 1u16);
        // D s_1398_21: cmp-ne s_1398_18 s_1398_20
        let s_1398_21: bool = ((s_1398_18) != (s_1398_20));
        // D s_1398_22: write-var gs#407510 <= s_1398_21
        fn_state.gs_407510 = s_1398_21;
        // N s_1398_23: jump b1399
        return block_1399(state, tracer, fn_state);
    }
    fn block_1399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1399_0: read-var gs#407510:u8
        let s_1399_0: bool = fn_state.gs_407510;
        // N s_1399_1: branch s_1399_0 b1443 b1400
        if s_1399_0 {
            return block_1443(state, tracer, fn_state);
        } else {
            return block_1400(state, tracer, fn_state);
        };
    }
    fn block_1400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1400_0: const #10s : i
        let s_1400_0: i128 = 10;
        // D s_1400_1: read-var u#33140:u32
        let s_1400_1: u32 = fn_state.u_33140;
        // D s_1400_2: cast zx s_1400_1 -> bv
        let s_1400_2: Bits = Bits::new(s_1400_1 as u128, 32u16);
        // C s_1400_3: const #1u : u64
        let s_1400_3: u64 = 1;
        // D s_1400_4: bit-extract s_1400_2 s_1400_0 s_1400_3
        let s_1400_4: Bits = (Bits::new(
            ((s_1400_2) >> (s_1400_0)).value(),
            u16::try_from(s_1400_3).unwrap(),
        ));
        // D s_1400_5: cast reint s_1400_4 -> u8
        let s_1400_5: bool = ((s_1400_4.value()) != 0);
        // C s_1400_6: const #0s : i
        let s_1400_6: i128 = 0;
        // C s_1400_7: const #0u : u64
        let s_1400_7: u64 = 0;
        // D s_1400_8: cast zx s_1400_5 -> u64
        let s_1400_8: u64 = (s_1400_5 as u64);
        // C s_1400_9: const #1u : u64
        let s_1400_9: u64 = 1;
        // D s_1400_10: and s_1400_8 s_1400_9
        let s_1400_10: u64 = ((s_1400_8) & (s_1400_9));
        // D s_1400_11: cmp-eq s_1400_10 s_1400_9
        let s_1400_11: bool = ((s_1400_10) == (s_1400_9));
        // D s_1400_12: lsl s_1400_8 s_1400_6
        let s_1400_12: u64 = s_1400_8 << s_1400_6;
        // D s_1400_13: or s_1400_7 s_1400_12
        let s_1400_13: u64 = ((s_1400_7) | (s_1400_12));
        // D s_1400_14: cmpl s_1400_12
        let s_1400_14: u64 = !s_1400_12;
        // D s_1400_15: and s_1400_7 s_1400_14
        let s_1400_15: u64 = ((s_1400_7) & (s_1400_14));
        // D s_1400_16: select s_1400_11 s_1400_13 s_1400_15
        let s_1400_16: u64 = if s_1400_11 { s_1400_13 } else { s_1400_15 };
        // D s_1400_17: cast trunc s_1400_16 -> u8
        let s_1400_17: bool = ((s_1400_16) != 0);
        // D s_1400_18: cast zx s_1400_17 -> bv
        let s_1400_18: Bits = Bits::new(s_1400_17 as u128, 1u16);
        // C s_1400_19: const #0u : u8
        let s_1400_19: bool = false;
        // C s_1400_20: cast zx s_1400_19 -> bv
        let s_1400_20: Bits = Bits::new(s_1400_19 as u128, 1u16);
        // D s_1400_21: cmp-ne s_1400_18 s_1400_20
        let s_1400_21: bool = ((s_1400_18) != (s_1400_20));
        // D s_1400_22: write-var gs#407513 <= s_1400_21
        fn_state.gs_407513 = s_1400_21;
        // N s_1400_23: jump b1401
        return block_1401(state, tracer, fn_state);
    }
    fn block_1401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1401_0: read-var gs#407513:u8
        let s_1401_0: bool = fn_state.gs_407513;
        // N s_1401_1: branch s_1401_0 b1442 b1402
        if s_1401_0 {
            return block_1442(state, tracer, fn_state);
        } else {
            return block_1402(state, tracer, fn_state);
        };
    }
    fn block_1402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1402_0: const #11s : i
        let s_1402_0: i128 = 11;
        // D s_1402_1: read-var u#33140:u32
        let s_1402_1: u32 = fn_state.u_33140;
        // D s_1402_2: cast zx s_1402_1 -> bv
        let s_1402_2: Bits = Bits::new(s_1402_1 as u128, 32u16);
        // C s_1402_3: const #1u : u64
        let s_1402_3: u64 = 1;
        // D s_1402_4: bit-extract s_1402_2 s_1402_0 s_1402_3
        let s_1402_4: Bits = (Bits::new(
            ((s_1402_2) >> (s_1402_0)).value(),
            u16::try_from(s_1402_3).unwrap(),
        ));
        // D s_1402_5: cast reint s_1402_4 -> u8
        let s_1402_5: bool = ((s_1402_4.value()) != 0);
        // C s_1402_6: const #0s : i
        let s_1402_6: i128 = 0;
        // C s_1402_7: const #0u : u64
        let s_1402_7: u64 = 0;
        // D s_1402_8: cast zx s_1402_5 -> u64
        let s_1402_8: u64 = (s_1402_5 as u64);
        // C s_1402_9: const #1u : u64
        let s_1402_9: u64 = 1;
        // D s_1402_10: and s_1402_8 s_1402_9
        let s_1402_10: u64 = ((s_1402_8) & (s_1402_9));
        // D s_1402_11: cmp-eq s_1402_10 s_1402_9
        let s_1402_11: bool = ((s_1402_10) == (s_1402_9));
        // D s_1402_12: lsl s_1402_8 s_1402_6
        let s_1402_12: u64 = s_1402_8 << s_1402_6;
        // D s_1402_13: or s_1402_7 s_1402_12
        let s_1402_13: u64 = ((s_1402_7) | (s_1402_12));
        // D s_1402_14: cmpl s_1402_12
        let s_1402_14: u64 = !s_1402_12;
        // D s_1402_15: and s_1402_7 s_1402_14
        let s_1402_15: u64 = ((s_1402_7) & (s_1402_14));
        // D s_1402_16: select s_1402_11 s_1402_13 s_1402_15
        let s_1402_16: u64 = if s_1402_11 { s_1402_13 } else { s_1402_15 };
        // D s_1402_17: cast trunc s_1402_16 -> u8
        let s_1402_17: bool = ((s_1402_16) != 0);
        // D s_1402_18: cast zx s_1402_17 -> bv
        let s_1402_18: Bits = Bits::new(s_1402_17 as u128, 1u16);
        // C s_1402_19: const #0u : u8
        let s_1402_19: bool = false;
        // C s_1402_20: cast zx s_1402_19 -> bv
        let s_1402_20: Bits = Bits::new(s_1402_19 as u128, 1u16);
        // D s_1402_21: cmp-ne s_1402_18 s_1402_20
        let s_1402_21: bool = ((s_1402_18) != (s_1402_20));
        // D s_1402_22: write-var gs#407516 <= s_1402_21
        fn_state.gs_407516 = s_1402_21;
        // N s_1402_23: jump b1403
        return block_1403(state, tracer, fn_state);
    }
    fn block_1403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1403_0: read-var gs#407516:u8
        let s_1403_0: bool = fn_state.gs_407516;
        // N s_1403_1: branch s_1403_0 b1441 b1404
        if s_1403_0 {
            return block_1441(state, tracer, fn_state);
        } else {
            return block_1404(state, tracer, fn_state);
        };
    }
    fn block_1404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1404_0: const #12s : i
        let s_1404_0: i128 = 12;
        // D s_1404_1: read-var u#33140:u32
        let s_1404_1: u32 = fn_state.u_33140;
        // D s_1404_2: cast zx s_1404_1 -> bv
        let s_1404_2: Bits = Bits::new(s_1404_1 as u128, 32u16);
        // C s_1404_3: const #1u : u64
        let s_1404_3: u64 = 1;
        // D s_1404_4: bit-extract s_1404_2 s_1404_0 s_1404_3
        let s_1404_4: Bits = (Bits::new(
            ((s_1404_2) >> (s_1404_0)).value(),
            u16::try_from(s_1404_3).unwrap(),
        ));
        // D s_1404_5: cast reint s_1404_4 -> u8
        let s_1404_5: bool = ((s_1404_4.value()) != 0);
        // C s_1404_6: const #0s : i
        let s_1404_6: i128 = 0;
        // C s_1404_7: const #0u : u64
        let s_1404_7: u64 = 0;
        // D s_1404_8: cast zx s_1404_5 -> u64
        let s_1404_8: u64 = (s_1404_5 as u64);
        // C s_1404_9: const #1u : u64
        let s_1404_9: u64 = 1;
        // D s_1404_10: and s_1404_8 s_1404_9
        let s_1404_10: u64 = ((s_1404_8) & (s_1404_9));
        // D s_1404_11: cmp-eq s_1404_10 s_1404_9
        let s_1404_11: bool = ((s_1404_10) == (s_1404_9));
        // D s_1404_12: lsl s_1404_8 s_1404_6
        let s_1404_12: u64 = s_1404_8 << s_1404_6;
        // D s_1404_13: or s_1404_7 s_1404_12
        let s_1404_13: u64 = ((s_1404_7) | (s_1404_12));
        // D s_1404_14: cmpl s_1404_12
        let s_1404_14: u64 = !s_1404_12;
        // D s_1404_15: and s_1404_7 s_1404_14
        let s_1404_15: u64 = ((s_1404_7) & (s_1404_14));
        // D s_1404_16: select s_1404_11 s_1404_13 s_1404_15
        let s_1404_16: u64 = if s_1404_11 { s_1404_13 } else { s_1404_15 };
        // D s_1404_17: cast trunc s_1404_16 -> u8
        let s_1404_17: bool = ((s_1404_16) != 0);
        // D s_1404_18: cast zx s_1404_17 -> bv
        let s_1404_18: Bits = Bits::new(s_1404_17 as u128, 1u16);
        // C s_1404_19: const #0u : u8
        let s_1404_19: bool = false;
        // C s_1404_20: cast zx s_1404_19 -> bv
        let s_1404_20: Bits = Bits::new(s_1404_19 as u128, 1u16);
        // D s_1404_21: cmp-ne s_1404_18 s_1404_20
        let s_1404_21: bool = ((s_1404_18) != (s_1404_20));
        // D s_1404_22: write-var gs#407519 <= s_1404_21
        fn_state.gs_407519 = s_1404_21;
        // N s_1404_23: jump b1405
        return block_1405(state, tracer, fn_state);
    }
    fn block_1405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1405_0: read-var gs#407519:u8
        let s_1405_0: bool = fn_state.gs_407519;
        // N s_1405_1: branch s_1405_0 b1440 b1406
        if s_1405_0 {
            return block_1440(state, tracer, fn_state);
        } else {
            return block_1406(state, tracer, fn_state);
        };
    }
    fn block_1406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1406_0: const #13s : i
        let s_1406_0: i128 = 13;
        // D s_1406_1: read-var u#33140:u32
        let s_1406_1: u32 = fn_state.u_33140;
        // D s_1406_2: cast zx s_1406_1 -> bv
        let s_1406_2: Bits = Bits::new(s_1406_1 as u128, 32u16);
        // C s_1406_3: const #1u : u64
        let s_1406_3: u64 = 1;
        // D s_1406_4: bit-extract s_1406_2 s_1406_0 s_1406_3
        let s_1406_4: Bits = (Bits::new(
            ((s_1406_2) >> (s_1406_0)).value(),
            u16::try_from(s_1406_3).unwrap(),
        ));
        // D s_1406_5: cast reint s_1406_4 -> u8
        let s_1406_5: bool = ((s_1406_4.value()) != 0);
        // C s_1406_6: const #0s : i
        let s_1406_6: i128 = 0;
        // C s_1406_7: const #0u : u64
        let s_1406_7: u64 = 0;
        // D s_1406_8: cast zx s_1406_5 -> u64
        let s_1406_8: u64 = (s_1406_5 as u64);
        // C s_1406_9: const #1u : u64
        let s_1406_9: u64 = 1;
        // D s_1406_10: and s_1406_8 s_1406_9
        let s_1406_10: u64 = ((s_1406_8) & (s_1406_9));
        // D s_1406_11: cmp-eq s_1406_10 s_1406_9
        let s_1406_11: bool = ((s_1406_10) == (s_1406_9));
        // D s_1406_12: lsl s_1406_8 s_1406_6
        let s_1406_12: u64 = s_1406_8 << s_1406_6;
        // D s_1406_13: or s_1406_7 s_1406_12
        let s_1406_13: u64 = ((s_1406_7) | (s_1406_12));
        // D s_1406_14: cmpl s_1406_12
        let s_1406_14: u64 = !s_1406_12;
        // D s_1406_15: and s_1406_7 s_1406_14
        let s_1406_15: u64 = ((s_1406_7) & (s_1406_14));
        // D s_1406_16: select s_1406_11 s_1406_13 s_1406_15
        let s_1406_16: u64 = if s_1406_11 { s_1406_13 } else { s_1406_15 };
        // D s_1406_17: cast trunc s_1406_16 -> u8
        let s_1406_17: bool = ((s_1406_16) != 0);
        // D s_1406_18: cast zx s_1406_17 -> bv
        let s_1406_18: Bits = Bits::new(s_1406_17 as u128, 1u16);
        // C s_1406_19: const #0u : u8
        let s_1406_19: bool = false;
        // C s_1406_20: cast zx s_1406_19 -> bv
        let s_1406_20: Bits = Bits::new(s_1406_19 as u128, 1u16);
        // D s_1406_21: cmp-ne s_1406_18 s_1406_20
        let s_1406_21: bool = ((s_1406_18) != (s_1406_20));
        // D s_1406_22: write-var gs#407522 <= s_1406_21
        fn_state.gs_407522 = s_1406_21;
        // N s_1406_23: jump b1407
        return block_1407(state, tracer, fn_state);
    }
    fn block_1407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1407_0: read-var gs#407522:u8
        let s_1407_0: bool = fn_state.gs_407522;
        // N s_1407_1: branch s_1407_0 b1439 b1408
        if s_1407_0 {
            return block_1439(state, tracer, fn_state);
        } else {
            return block_1408(state, tracer, fn_state);
        };
    }
    fn block_1408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1408_0: const #14s : i
        let s_1408_0: i128 = 14;
        // D s_1408_1: read-var u#33140:u32
        let s_1408_1: u32 = fn_state.u_33140;
        // D s_1408_2: cast zx s_1408_1 -> bv
        let s_1408_2: Bits = Bits::new(s_1408_1 as u128, 32u16);
        // C s_1408_3: const #1u : u64
        let s_1408_3: u64 = 1;
        // D s_1408_4: bit-extract s_1408_2 s_1408_0 s_1408_3
        let s_1408_4: Bits = (Bits::new(
            ((s_1408_2) >> (s_1408_0)).value(),
            u16::try_from(s_1408_3).unwrap(),
        ));
        // D s_1408_5: cast reint s_1408_4 -> u8
        let s_1408_5: bool = ((s_1408_4.value()) != 0);
        // C s_1408_6: const #0s : i
        let s_1408_6: i128 = 0;
        // C s_1408_7: const #0u : u64
        let s_1408_7: u64 = 0;
        // D s_1408_8: cast zx s_1408_5 -> u64
        let s_1408_8: u64 = (s_1408_5 as u64);
        // C s_1408_9: const #1u : u64
        let s_1408_9: u64 = 1;
        // D s_1408_10: and s_1408_8 s_1408_9
        let s_1408_10: u64 = ((s_1408_8) & (s_1408_9));
        // D s_1408_11: cmp-eq s_1408_10 s_1408_9
        let s_1408_11: bool = ((s_1408_10) == (s_1408_9));
        // D s_1408_12: lsl s_1408_8 s_1408_6
        let s_1408_12: u64 = s_1408_8 << s_1408_6;
        // D s_1408_13: or s_1408_7 s_1408_12
        let s_1408_13: u64 = ((s_1408_7) | (s_1408_12));
        // D s_1408_14: cmpl s_1408_12
        let s_1408_14: u64 = !s_1408_12;
        // D s_1408_15: and s_1408_7 s_1408_14
        let s_1408_15: u64 = ((s_1408_7) & (s_1408_14));
        // D s_1408_16: select s_1408_11 s_1408_13 s_1408_15
        let s_1408_16: u64 = if s_1408_11 { s_1408_13 } else { s_1408_15 };
        // D s_1408_17: cast trunc s_1408_16 -> u8
        let s_1408_17: bool = ((s_1408_16) != 0);
        // D s_1408_18: cast zx s_1408_17 -> bv
        let s_1408_18: Bits = Bits::new(s_1408_17 as u128, 1u16);
        // C s_1408_19: const #0u : u8
        let s_1408_19: bool = false;
        // C s_1408_20: cast zx s_1408_19 -> bv
        let s_1408_20: Bits = Bits::new(s_1408_19 as u128, 1u16);
        // D s_1408_21: cmp-ne s_1408_18 s_1408_20
        let s_1408_21: bool = ((s_1408_18) != (s_1408_20));
        // D s_1408_22: write-var gs#407525 <= s_1408_21
        fn_state.gs_407525 = s_1408_21;
        // N s_1408_23: jump b1409
        return block_1409(state, tracer, fn_state);
    }
    fn block_1409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1409_0: read-var gs#407525:u8
        let s_1409_0: bool = fn_state.gs_407525;
        // N s_1409_1: branch s_1409_0 b1438 b1410
        if s_1409_0 {
            return block_1438(state, tracer, fn_state);
        } else {
            return block_1410(state, tracer, fn_state);
        };
    }
    fn block_1410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1410_0: const #15s : i
        let s_1410_0: i128 = 15;
        // D s_1410_1: read-var u#33140:u32
        let s_1410_1: u32 = fn_state.u_33140;
        // D s_1410_2: cast zx s_1410_1 -> bv
        let s_1410_2: Bits = Bits::new(s_1410_1 as u128, 32u16);
        // C s_1410_3: const #1u : u64
        let s_1410_3: u64 = 1;
        // D s_1410_4: bit-extract s_1410_2 s_1410_0 s_1410_3
        let s_1410_4: Bits = (Bits::new(
            ((s_1410_2) >> (s_1410_0)).value(),
            u16::try_from(s_1410_3).unwrap(),
        ));
        // D s_1410_5: cast reint s_1410_4 -> u8
        let s_1410_5: bool = ((s_1410_4.value()) != 0);
        // C s_1410_6: const #0s : i
        let s_1410_6: i128 = 0;
        // C s_1410_7: const #0u : u64
        let s_1410_7: u64 = 0;
        // D s_1410_8: cast zx s_1410_5 -> u64
        let s_1410_8: u64 = (s_1410_5 as u64);
        // C s_1410_9: const #1u : u64
        let s_1410_9: u64 = 1;
        // D s_1410_10: and s_1410_8 s_1410_9
        let s_1410_10: u64 = ((s_1410_8) & (s_1410_9));
        // D s_1410_11: cmp-eq s_1410_10 s_1410_9
        let s_1410_11: bool = ((s_1410_10) == (s_1410_9));
        // D s_1410_12: lsl s_1410_8 s_1410_6
        let s_1410_12: u64 = s_1410_8 << s_1410_6;
        // D s_1410_13: or s_1410_7 s_1410_12
        let s_1410_13: u64 = ((s_1410_7) | (s_1410_12));
        // D s_1410_14: cmpl s_1410_12
        let s_1410_14: u64 = !s_1410_12;
        // D s_1410_15: and s_1410_7 s_1410_14
        let s_1410_15: u64 = ((s_1410_7) & (s_1410_14));
        // D s_1410_16: select s_1410_11 s_1410_13 s_1410_15
        let s_1410_16: u64 = if s_1410_11 { s_1410_13 } else { s_1410_15 };
        // D s_1410_17: cast trunc s_1410_16 -> u8
        let s_1410_17: bool = ((s_1410_16) != 0);
        // D s_1410_18: cast zx s_1410_17 -> bv
        let s_1410_18: Bits = Bits::new(s_1410_17 as u128, 1u16);
        // C s_1410_19: const #0u : u8
        let s_1410_19: bool = false;
        // C s_1410_20: cast zx s_1410_19 -> bv
        let s_1410_20: Bits = Bits::new(s_1410_19 as u128, 1u16);
        // D s_1410_21: cmp-ne s_1410_18 s_1410_20
        let s_1410_21: bool = ((s_1410_18) != (s_1410_20));
        // D s_1410_22: write-var gs#407528 <= s_1410_21
        fn_state.gs_407528 = s_1410_21;
        // N s_1410_23: jump b1411
        return block_1411(state, tracer, fn_state);
    }
    fn block_1411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1411_0: read-var gs#407528:u8
        let s_1411_0: bool = fn_state.gs_407528;
        // N s_1411_1: branch s_1411_0 b1437 b1412
        if s_1411_0 {
            return block_1437(state, tracer, fn_state);
        } else {
            return block_1412(state, tracer, fn_state);
        };
    }
    fn block_1412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1412_0: const #16s : i
        let s_1412_0: i128 = 16;
        // D s_1412_1: read-var u#33140:u32
        let s_1412_1: u32 = fn_state.u_33140;
        // D s_1412_2: cast zx s_1412_1 -> bv
        let s_1412_2: Bits = Bits::new(s_1412_1 as u128, 32u16);
        // C s_1412_3: const #1u : u64
        let s_1412_3: u64 = 1;
        // D s_1412_4: bit-extract s_1412_2 s_1412_0 s_1412_3
        let s_1412_4: Bits = (Bits::new(
            ((s_1412_2) >> (s_1412_0)).value(),
            u16::try_from(s_1412_3).unwrap(),
        ));
        // D s_1412_5: cast reint s_1412_4 -> u8
        let s_1412_5: bool = ((s_1412_4.value()) != 0);
        // C s_1412_6: const #0s : i
        let s_1412_6: i128 = 0;
        // C s_1412_7: const #0u : u64
        let s_1412_7: u64 = 0;
        // D s_1412_8: cast zx s_1412_5 -> u64
        let s_1412_8: u64 = (s_1412_5 as u64);
        // C s_1412_9: const #1u : u64
        let s_1412_9: u64 = 1;
        // D s_1412_10: and s_1412_8 s_1412_9
        let s_1412_10: u64 = ((s_1412_8) & (s_1412_9));
        // D s_1412_11: cmp-eq s_1412_10 s_1412_9
        let s_1412_11: bool = ((s_1412_10) == (s_1412_9));
        // D s_1412_12: lsl s_1412_8 s_1412_6
        let s_1412_12: u64 = s_1412_8 << s_1412_6;
        // D s_1412_13: or s_1412_7 s_1412_12
        let s_1412_13: u64 = ((s_1412_7) | (s_1412_12));
        // D s_1412_14: cmpl s_1412_12
        let s_1412_14: u64 = !s_1412_12;
        // D s_1412_15: and s_1412_7 s_1412_14
        let s_1412_15: u64 = ((s_1412_7) & (s_1412_14));
        // D s_1412_16: select s_1412_11 s_1412_13 s_1412_15
        let s_1412_16: u64 = if s_1412_11 { s_1412_13 } else { s_1412_15 };
        // D s_1412_17: cast trunc s_1412_16 -> u8
        let s_1412_17: bool = ((s_1412_16) != 0);
        // D s_1412_18: cast zx s_1412_17 -> bv
        let s_1412_18: Bits = Bits::new(s_1412_17 as u128, 1u16);
        // C s_1412_19: const #0u : u8
        let s_1412_19: bool = false;
        // C s_1412_20: cast zx s_1412_19 -> bv
        let s_1412_20: Bits = Bits::new(s_1412_19 as u128, 1u16);
        // D s_1412_21: cmp-ne s_1412_18 s_1412_20
        let s_1412_21: bool = ((s_1412_18) != (s_1412_20));
        // D s_1412_22: write-var gs#407531 <= s_1412_21
        fn_state.gs_407531 = s_1412_21;
        // N s_1412_23: jump b1413
        return block_1413(state, tracer, fn_state);
    }
    fn block_1413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1413_0: read-var gs#407531:u8
        let s_1413_0: bool = fn_state.gs_407531;
        // N s_1413_1: branch s_1413_0 b1436 b1414
        if s_1413_0 {
            return block_1436(state, tracer, fn_state);
        } else {
            return block_1414(state, tracer, fn_state);
        };
    }
    fn block_1414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1414_0: const #17s : i
        let s_1414_0: i128 = 17;
        // D s_1414_1: read-var u#33140:u32
        let s_1414_1: u32 = fn_state.u_33140;
        // D s_1414_2: cast zx s_1414_1 -> bv
        let s_1414_2: Bits = Bits::new(s_1414_1 as u128, 32u16);
        // C s_1414_3: const #1u : u64
        let s_1414_3: u64 = 1;
        // D s_1414_4: bit-extract s_1414_2 s_1414_0 s_1414_3
        let s_1414_4: Bits = (Bits::new(
            ((s_1414_2) >> (s_1414_0)).value(),
            u16::try_from(s_1414_3).unwrap(),
        ));
        // D s_1414_5: cast reint s_1414_4 -> u8
        let s_1414_5: bool = ((s_1414_4.value()) != 0);
        // C s_1414_6: const #0s : i
        let s_1414_6: i128 = 0;
        // C s_1414_7: const #0u : u64
        let s_1414_7: u64 = 0;
        // D s_1414_8: cast zx s_1414_5 -> u64
        let s_1414_8: u64 = (s_1414_5 as u64);
        // C s_1414_9: const #1u : u64
        let s_1414_9: u64 = 1;
        // D s_1414_10: and s_1414_8 s_1414_9
        let s_1414_10: u64 = ((s_1414_8) & (s_1414_9));
        // D s_1414_11: cmp-eq s_1414_10 s_1414_9
        let s_1414_11: bool = ((s_1414_10) == (s_1414_9));
        // D s_1414_12: lsl s_1414_8 s_1414_6
        let s_1414_12: u64 = s_1414_8 << s_1414_6;
        // D s_1414_13: or s_1414_7 s_1414_12
        let s_1414_13: u64 = ((s_1414_7) | (s_1414_12));
        // D s_1414_14: cmpl s_1414_12
        let s_1414_14: u64 = !s_1414_12;
        // D s_1414_15: and s_1414_7 s_1414_14
        let s_1414_15: u64 = ((s_1414_7) & (s_1414_14));
        // D s_1414_16: select s_1414_11 s_1414_13 s_1414_15
        let s_1414_16: u64 = if s_1414_11 { s_1414_13 } else { s_1414_15 };
        // D s_1414_17: cast trunc s_1414_16 -> u8
        let s_1414_17: bool = ((s_1414_16) != 0);
        // D s_1414_18: cast zx s_1414_17 -> bv
        let s_1414_18: Bits = Bits::new(s_1414_17 as u128, 1u16);
        // C s_1414_19: const #0u : u8
        let s_1414_19: bool = false;
        // C s_1414_20: cast zx s_1414_19 -> bv
        let s_1414_20: Bits = Bits::new(s_1414_19 as u128, 1u16);
        // D s_1414_21: cmp-ne s_1414_18 s_1414_20
        let s_1414_21: bool = ((s_1414_18) != (s_1414_20));
        // D s_1414_22: write-var gs#407534 <= s_1414_21
        fn_state.gs_407534 = s_1414_21;
        // N s_1414_23: jump b1415
        return block_1415(state, tracer, fn_state);
    }
    fn block_1415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1415_0: read-var gs#407534:u8
        let s_1415_0: bool = fn_state.gs_407534;
        // N s_1415_1: branch s_1415_0 b1435 b1416
        if s_1415_0 {
            return block_1435(state, tracer, fn_state);
        } else {
            return block_1416(state, tracer, fn_state);
        };
    }
    fn block_1416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1416_0: const #18s : i
        let s_1416_0: i128 = 18;
        // D s_1416_1: read-var u#33140:u32
        let s_1416_1: u32 = fn_state.u_33140;
        // D s_1416_2: cast zx s_1416_1 -> bv
        let s_1416_2: Bits = Bits::new(s_1416_1 as u128, 32u16);
        // C s_1416_3: const #1u : u64
        let s_1416_3: u64 = 1;
        // D s_1416_4: bit-extract s_1416_2 s_1416_0 s_1416_3
        let s_1416_4: Bits = (Bits::new(
            ((s_1416_2) >> (s_1416_0)).value(),
            u16::try_from(s_1416_3).unwrap(),
        ));
        // D s_1416_5: cast reint s_1416_4 -> u8
        let s_1416_5: bool = ((s_1416_4.value()) != 0);
        // C s_1416_6: const #0s : i
        let s_1416_6: i128 = 0;
        // C s_1416_7: const #0u : u64
        let s_1416_7: u64 = 0;
        // D s_1416_8: cast zx s_1416_5 -> u64
        let s_1416_8: u64 = (s_1416_5 as u64);
        // C s_1416_9: const #1u : u64
        let s_1416_9: u64 = 1;
        // D s_1416_10: and s_1416_8 s_1416_9
        let s_1416_10: u64 = ((s_1416_8) & (s_1416_9));
        // D s_1416_11: cmp-eq s_1416_10 s_1416_9
        let s_1416_11: bool = ((s_1416_10) == (s_1416_9));
        // D s_1416_12: lsl s_1416_8 s_1416_6
        let s_1416_12: u64 = s_1416_8 << s_1416_6;
        // D s_1416_13: or s_1416_7 s_1416_12
        let s_1416_13: u64 = ((s_1416_7) | (s_1416_12));
        // D s_1416_14: cmpl s_1416_12
        let s_1416_14: u64 = !s_1416_12;
        // D s_1416_15: and s_1416_7 s_1416_14
        let s_1416_15: u64 = ((s_1416_7) & (s_1416_14));
        // D s_1416_16: select s_1416_11 s_1416_13 s_1416_15
        let s_1416_16: u64 = if s_1416_11 { s_1416_13 } else { s_1416_15 };
        // D s_1416_17: cast trunc s_1416_16 -> u8
        let s_1416_17: bool = ((s_1416_16) != 0);
        // D s_1416_18: cast zx s_1416_17 -> bv
        let s_1416_18: Bits = Bits::new(s_1416_17 as u128, 1u16);
        // C s_1416_19: const #0u : u8
        let s_1416_19: bool = false;
        // C s_1416_20: cast zx s_1416_19 -> bv
        let s_1416_20: Bits = Bits::new(s_1416_19 as u128, 1u16);
        // D s_1416_21: cmp-ne s_1416_18 s_1416_20
        let s_1416_21: bool = ((s_1416_18) != (s_1416_20));
        // D s_1416_22: write-var gs#407537 <= s_1416_21
        fn_state.gs_407537 = s_1416_21;
        // N s_1416_23: jump b1417
        return block_1417(state, tracer, fn_state);
    }
    fn block_1417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1417_0: read-var gs#407537:u8
        let s_1417_0: bool = fn_state.gs_407537;
        // N s_1417_1: branch s_1417_0 b1434 b1418
        if s_1417_0 {
            return block_1434(state, tracer, fn_state);
        } else {
            return block_1418(state, tracer, fn_state);
        };
    }
    fn block_1418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1418_0: const #19s : i
        let s_1418_0: i128 = 19;
        // D s_1418_1: read-var u#33140:u32
        let s_1418_1: u32 = fn_state.u_33140;
        // D s_1418_2: cast zx s_1418_1 -> bv
        let s_1418_2: Bits = Bits::new(s_1418_1 as u128, 32u16);
        // C s_1418_3: const #1u : u64
        let s_1418_3: u64 = 1;
        // D s_1418_4: bit-extract s_1418_2 s_1418_0 s_1418_3
        let s_1418_4: Bits = (Bits::new(
            ((s_1418_2) >> (s_1418_0)).value(),
            u16::try_from(s_1418_3).unwrap(),
        ));
        // D s_1418_5: cast reint s_1418_4 -> u8
        let s_1418_5: bool = ((s_1418_4.value()) != 0);
        // C s_1418_6: const #0s : i
        let s_1418_6: i128 = 0;
        // C s_1418_7: const #0u : u64
        let s_1418_7: u64 = 0;
        // D s_1418_8: cast zx s_1418_5 -> u64
        let s_1418_8: u64 = (s_1418_5 as u64);
        // C s_1418_9: const #1u : u64
        let s_1418_9: u64 = 1;
        // D s_1418_10: and s_1418_8 s_1418_9
        let s_1418_10: u64 = ((s_1418_8) & (s_1418_9));
        // D s_1418_11: cmp-eq s_1418_10 s_1418_9
        let s_1418_11: bool = ((s_1418_10) == (s_1418_9));
        // D s_1418_12: lsl s_1418_8 s_1418_6
        let s_1418_12: u64 = s_1418_8 << s_1418_6;
        // D s_1418_13: or s_1418_7 s_1418_12
        let s_1418_13: u64 = ((s_1418_7) | (s_1418_12));
        // D s_1418_14: cmpl s_1418_12
        let s_1418_14: u64 = !s_1418_12;
        // D s_1418_15: and s_1418_7 s_1418_14
        let s_1418_15: u64 = ((s_1418_7) & (s_1418_14));
        // D s_1418_16: select s_1418_11 s_1418_13 s_1418_15
        let s_1418_16: u64 = if s_1418_11 { s_1418_13 } else { s_1418_15 };
        // D s_1418_17: cast trunc s_1418_16 -> u8
        let s_1418_17: bool = ((s_1418_16) != 0);
        // D s_1418_18: cast zx s_1418_17 -> bv
        let s_1418_18: Bits = Bits::new(s_1418_17 as u128, 1u16);
        // C s_1418_19: const #0u : u8
        let s_1418_19: bool = false;
        // C s_1418_20: cast zx s_1418_19 -> bv
        let s_1418_20: Bits = Bits::new(s_1418_19 as u128, 1u16);
        // D s_1418_21: cmp-ne s_1418_18 s_1418_20
        let s_1418_21: bool = ((s_1418_18) != (s_1418_20));
        // D s_1418_22: write-var gs#407540 <= s_1418_21
        fn_state.gs_407540 = s_1418_21;
        // N s_1418_23: jump b1419
        return block_1419(state, tracer, fn_state);
    }
    fn block_1419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1419_0: read-var gs#407540:u8
        let s_1419_0: bool = fn_state.gs_407540;
        // N s_1419_1: branch s_1419_0 b1433 b1420
        if s_1419_0 {
            return block_1433(state, tracer, fn_state);
        } else {
            return block_1420(state, tracer, fn_state);
        };
    }
    fn block_1420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1420_0: const #0s : i
        let s_1420_0: i128 = 0;
        // D s_1420_1: read-var u#33140:u32
        let s_1420_1: u32 = fn_state.u_33140;
        // D s_1420_2: cast zx s_1420_1 -> bv
        let s_1420_2: Bits = Bits::new(s_1420_1 as u128, 32u16);
        // C s_1420_3: const #1u : u64
        let s_1420_3: u64 = 1;
        // D s_1420_4: bit-extract s_1420_2 s_1420_0 s_1420_3
        let s_1420_4: Bits = (Bits::new(
            ((s_1420_2) >> (s_1420_0)).value(),
            u16::try_from(s_1420_3).unwrap(),
        ));
        // D s_1420_5: cast reint s_1420_4 -> u8
        let s_1420_5: bool = ((s_1420_4.value()) != 0);
        // C s_1420_6: const #0s : i
        let s_1420_6: i128 = 0;
        // C s_1420_7: const #0u : u64
        let s_1420_7: u64 = 0;
        // D s_1420_8: cast zx s_1420_5 -> u64
        let s_1420_8: u64 = (s_1420_5 as u64);
        // C s_1420_9: const #1u : u64
        let s_1420_9: u64 = 1;
        // D s_1420_10: and s_1420_8 s_1420_9
        let s_1420_10: u64 = ((s_1420_8) & (s_1420_9));
        // D s_1420_11: cmp-eq s_1420_10 s_1420_9
        let s_1420_11: bool = ((s_1420_10) == (s_1420_9));
        // D s_1420_12: lsl s_1420_8 s_1420_6
        let s_1420_12: u64 = s_1420_8 << s_1420_6;
        // D s_1420_13: or s_1420_7 s_1420_12
        let s_1420_13: u64 = ((s_1420_7) | (s_1420_12));
        // D s_1420_14: cmpl s_1420_12
        let s_1420_14: u64 = !s_1420_12;
        // D s_1420_15: and s_1420_7 s_1420_14
        let s_1420_15: u64 = ((s_1420_7) & (s_1420_14));
        // D s_1420_16: select s_1420_11 s_1420_13 s_1420_15
        let s_1420_16: u64 = if s_1420_11 { s_1420_13 } else { s_1420_15 };
        // D s_1420_17: cast trunc s_1420_16 -> u8
        let s_1420_17: bool = ((s_1420_16) != 0);
        // D s_1420_18: cast zx s_1420_17 -> bv
        let s_1420_18: Bits = Bits::new(s_1420_17 as u128, 1u16);
        // C s_1420_19: const #1u : u8
        let s_1420_19: bool = true;
        // C s_1420_20: cast zx s_1420_19 -> bv
        let s_1420_20: Bits = Bits::new(s_1420_19 as u128, 1u16);
        // D s_1420_21: cmp-ne s_1420_18 s_1420_20
        let s_1420_21: bool = ((s_1420_18) != (s_1420_20));
        // D s_1420_22: write-var gs#407543 <= s_1420_21
        fn_state.gs_407543 = s_1420_21;
        // N s_1420_23: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_1421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1421_0: read-var gs#407543:u8
        let s_1421_0: bool = fn_state.gs_407543;
        // N s_1421_1: branch s_1421_0 b1432 b1422
        if s_1421_0 {
            return block_1432(state, tracer, fn_state);
        } else {
            return block_1422(state, tracer, fn_state);
        };
    }
    fn block_1422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1422_0: const #1s : i
        let s_1422_0: i128 = 1;
        // D s_1422_1: read-var u#33140:u32
        let s_1422_1: u32 = fn_state.u_33140;
        // D s_1422_2: cast zx s_1422_1 -> bv
        let s_1422_2: Bits = Bits::new(s_1422_1 as u128, 32u16);
        // C s_1422_3: const #1u : u64
        let s_1422_3: u64 = 1;
        // D s_1422_4: bit-extract s_1422_2 s_1422_0 s_1422_3
        let s_1422_4: Bits = (Bits::new(
            ((s_1422_2) >> (s_1422_0)).value(),
            u16::try_from(s_1422_3).unwrap(),
        ));
        // D s_1422_5: cast reint s_1422_4 -> u8
        let s_1422_5: bool = ((s_1422_4.value()) != 0);
        // C s_1422_6: const #0s : i
        let s_1422_6: i128 = 0;
        // C s_1422_7: const #0u : u64
        let s_1422_7: u64 = 0;
        // D s_1422_8: cast zx s_1422_5 -> u64
        let s_1422_8: u64 = (s_1422_5 as u64);
        // C s_1422_9: const #1u : u64
        let s_1422_9: u64 = 1;
        // D s_1422_10: and s_1422_8 s_1422_9
        let s_1422_10: u64 = ((s_1422_8) & (s_1422_9));
        // D s_1422_11: cmp-eq s_1422_10 s_1422_9
        let s_1422_11: bool = ((s_1422_10) == (s_1422_9));
        // D s_1422_12: lsl s_1422_8 s_1422_6
        let s_1422_12: u64 = s_1422_8 << s_1422_6;
        // D s_1422_13: or s_1422_7 s_1422_12
        let s_1422_13: u64 = ((s_1422_7) | (s_1422_12));
        // D s_1422_14: cmpl s_1422_12
        let s_1422_14: u64 = !s_1422_12;
        // D s_1422_15: and s_1422_7 s_1422_14
        let s_1422_15: u64 = ((s_1422_7) & (s_1422_14));
        // D s_1422_16: select s_1422_11 s_1422_13 s_1422_15
        let s_1422_16: u64 = if s_1422_11 { s_1422_13 } else { s_1422_15 };
        // D s_1422_17: cast trunc s_1422_16 -> u8
        let s_1422_17: bool = ((s_1422_16) != 0);
        // D s_1422_18: cast zx s_1422_17 -> bv
        let s_1422_18: Bits = Bits::new(s_1422_17 as u128, 1u16);
        // C s_1422_19: const #1u : u8
        let s_1422_19: bool = true;
        // C s_1422_20: cast zx s_1422_19 -> bv
        let s_1422_20: Bits = Bits::new(s_1422_19 as u128, 1u16);
        // D s_1422_21: cmp-ne s_1422_18 s_1422_20
        let s_1422_21: bool = ((s_1422_18) != (s_1422_20));
        // D s_1422_22: write-var gs#407546 <= s_1422_21
        fn_state.gs_407546 = s_1422_21;
        // N s_1422_23: jump b1423
        return block_1423(state, tracer, fn_state);
    }
    fn block_1423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1423_0: read-var gs#407546:u8
        let s_1423_0: bool = fn_state.gs_407546;
        // N s_1423_1: branch s_1423_0 b1431 b1424
        if s_1423_0 {
            return block_1431(state, tracer, fn_state);
        } else {
            return block_1424(state, tracer, fn_state);
        };
    }
    fn block_1424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1424_0: const #2s : i
        let s_1424_0: i128 = 2;
        // D s_1424_1: read-var u#33140:u32
        let s_1424_1: u32 = fn_state.u_33140;
        // D s_1424_2: cast zx s_1424_1 -> bv
        let s_1424_2: Bits = Bits::new(s_1424_1 as u128, 32u16);
        // C s_1424_3: const #1u : u64
        let s_1424_3: u64 = 1;
        // D s_1424_4: bit-extract s_1424_2 s_1424_0 s_1424_3
        let s_1424_4: Bits = (Bits::new(
            ((s_1424_2) >> (s_1424_0)).value(),
            u16::try_from(s_1424_3).unwrap(),
        ));
        // D s_1424_5: cast reint s_1424_4 -> u8
        let s_1424_5: bool = ((s_1424_4.value()) != 0);
        // C s_1424_6: const #0s : i
        let s_1424_6: i128 = 0;
        // C s_1424_7: const #0u : u64
        let s_1424_7: u64 = 0;
        // D s_1424_8: cast zx s_1424_5 -> u64
        let s_1424_8: u64 = (s_1424_5 as u64);
        // C s_1424_9: const #1u : u64
        let s_1424_9: u64 = 1;
        // D s_1424_10: and s_1424_8 s_1424_9
        let s_1424_10: u64 = ((s_1424_8) & (s_1424_9));
        // D s_1424_11: cmp-eq s_1424_10 s_1424_9
        let s_1424_11: bool = ((s_1424_10) == (s_1424_9));
        // D s_1424_12: lsl s_1424_8 s_1424_6
        let s_1424_12: u64 = s_1424_8 << s_1424_6;
        // D s_1424_13: or s_1424_7 s_1424_12
        let s_1424_13: u64 = ((s_1424_7) | (s_1424_12));
        // D s_1424_14: cmpl s_1424_12
        let s_1424_14: u64 = !s_1424_12;
        // D s_1424_15: and s_1424_7 s_1424_14
        let s_1424_15: u64 = ((s_1424_7) & (s_1424_14));
        // D s_1424_16: select s_1424_11 s_1424_13 s_1424_15
        let s_1424_16: u64 = if s_1424_11 { s_1424_13 } else { s_1424_15 };
        // D s_1424_17: cast trunc s_1424_16 -> u8
        let s_1424_17: bool = ((s_1424_16) != 0);
        // D s_1424_18: cast zx s_1424_17 -> bv
        let s_1424_18: Bits = Bits::new(s_1424_17 as u128, 1u16);
        // C s_1424_19: const #1u : u8
        let s_1424_19: bool = true;
        // C s_1424_20: cast zx s_1424_19 -> bv
        let s_1424_20: Bits = Bits::new(s_1424_19 as u128, 1u16);
        // D s_1424_21: cmp-ne s_1424_18 s_1424_20
        let s_1424_21: bool = ((s_1424_18) != (s_1424_20));
        // D s_1424_22: write-var gs#407549 <= s_1424_21
        fn_state.gs_407549 = s_1424_21;
        // N s_1424_23: jump b1425
        return block_1425(state, tracer, fn_state);
    }
    fn block_1425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1425_0: read-var gs#407549:u8
        let s_1425_0: bool = fn_state.gs_407549;
        // N s_1425_1: branch s_1425_0 b1430 b1426
        if s_1425_0 {
            return block_1430(state, tracer, fn_state);
        } else {
            return block_1426(state, tracer, fn_state);
        };
    }
    fn block_1426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1426_0: const #3s : i
        let s_1426_0: i128 = 3;
        // D s_1426_1: read-var u#33140:u32
        let s_1426_1: u32 = fn_state.u_33140;
        // D s_1426_2: cast zx s_1426_1 -> bv
        let s_1426_2: Bits = Bits::new(s_1426_1 as u128, 32u16);
        // C s_1426_3: const #1u : u64
        let s_1426_3: u64 = 1;
        // D s_1426_4: bit-extract s_1426_2 s_1426_0 s_1426_3
        let s_1426_4: Bits = (Bits::new(
            ((s_1426_2) >> (s_1426_0)).value(),
            u16::try_from(s_1426_3).unwrap(),
        ));
        // D s_1426_5: cast reint s_1426_4 -> u8
        let s_1426_5: bool = ((s_1426_4.value()) != 0);
        // C s_1426_6: const #0s : i
        let s_1426_6: i128 = 0;
        // C s_1426_7: const #0u : u64
        let s_1426_7: u64 = 0;
        // D s_1426_8: cast zx s_1426_5 -> u64
        let s_1426_8: u64 = (s_1426_5 as u64);
        // C s_1426_9: const #1u : u64
        let s_1426_9: u64 = 1;
        // D s_1426_10: and s_1426_8 s_1426_9
        let s_1426_10: u64 = ((s_1426_8) & (s_1426_9));
        // D s_1426_11: cmp-eq s_1426_10 s_1426_9
        let s_1426_11: bool = ((s_1426_10) == (s_1426_9));
        // D s_1426_12: lsl s_1426_8 s_1426_6
        let s_1426_12: u64 = s_1426_8 << s_1426_6;
        // D s_1426_13: or s_1426_7 s_1426_12
        let s_1426_13: u64 = ((s_1426_7) | (s_1426_12));
        // D s_1426_14: cmpl s_1426_12
        let s_1426_14: u64 = !s_1426_12;
        // D s_1426_15: and s_1426_7 s_1426_14
        let s_1426_15: u64 = ((s_1426_7) & (s_1426_14));
        // D s_1426_16: select s_1426_11 s_1426_13 s_1426_15
        let s_1426_16: u64 = if s_1426_11 { s_1426_13 } else { s_1426_15 };
        // D s_1426_17: cast trunc s_1426_16 -> u8
        let s_1426_17: bool = ((s_1426_16) != 0);
        // D s_1426_18: cast zx s_1426_17 -> bv
        let s_1426_18: Bits = Bits::new(s_1426_17 as u128, 1u16);
        // C s_1426_19: const #0u : u8
        let s_1426_19: bool = false;
        // C s_1426_20: cast zx s_1426_19 -> bv
        let s_1426_20: Bits = Bits::new(s_1426_19 as u128, 1u16);
        // D s_1426_21: cmp-ne s_1426_18 s_1426_20
        let s_1426_21: bool = ((s_1426_18) != (s_1426_20));
        // D s_1426_22: write-var gs#407552 <= s_1426_21
        fn_state.gs_407552 = s_1426_21;
        // N s_1426_23: jump b1427
        return block_1427(state, tracer, fn_state);
    }
    fn block_1427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1427_0: read-var gs#407552:u8
        let s_1427_0: bool = fn_state.gs_407552;
        // N s_1427_1: branch s_1427_0 b1429 b1428
        if s_1427_0 {
            return block_1429(state, tracer, fn_state);
        } else {
            return block_1428(state, tracer, fn_state);
        };
    }
    fn block_1428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1428_0: read-var u#33141:u8
        let s_1428_0: u8 = fn_state.u_33141;
        // D s_1428_1: call decode_aarch32_instrs_ERET_A1enc_A_txt(s_1428_0)
        let s_1428_1: () = decode_aarch32_instrs_ERET_A1enc_A_txt(
            state,
            tracer,
            s_1428_0,
        );
        // N s_1428_2: return
        return;
    }
    fn block_1429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1429_0: panic
        panic!("{:?}", ());
        // N s_1429_1: return
        return;
    }
    fn block_1430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1430_0: const #1u : u8
        let s_1430_0: bool = true;
        // D s_1430_1: write-var gs#407552 <= s_1430_0
        fn_state.gs_407552 = s_1430_0;
        // N s_1430_2: jump b1427
        return block_1427(state, tracer, fn_state);
    }
    fn block_1431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1431_0: const #1u : u8
        let s_1431_0: bool = true;
        // D s_1431_1: write-var gs#407549 <= s_1431_0
        fn_state.gs_407549 = s_1431_0;
        // N s_1431_2: jump b1425
        return block_1425(state, tracer, fn_state);
    }
    fn block_1432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1432_0: const #1u : u8
        let s_1432_0: bool = true;
        // D s_1432_1: write-var gs#407546 <= s_1432_0
        fn_state.gs_407546 = s_1432_0;
        // N s_1432_2: jump b1423
        return block_1423(state, tracer, fn_state);
    }
    fn block_1433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1433_0: const #1u : u8
        let s_1433_0: bool = true;
        // D s_1433_1: write-var gs#407543 <= s_1433_0
        fn_state.gs_407543 = s_1433_0;
        // N s_1433_2: jump b1421
        return block_1421(state, tracer, fn_state);
    }
    fn block_1434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1434_0: const #1u : u8
        let s_1434_0: bool = true;
        // D s_1434_1: write-var gs#407540 <= s_1434_0
        fn_state.gs_407540 = s_1434_0;
        // N s_1434_2: jump b1419
        return block_1419(state, tracer, fn_state);
    }
    fn block_1435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1435_0: const #1u : u8
        let s_1435_0: bool = true;
        // D s_1435_1: write-var gs#407537 <= s_1435_0
        fn_state.gs_407537 = s_1435_0;
        // N s_1435_2: jump b1417
        return block_1417(state, tracer, fn_state);
    }
    fn block_1436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1436_0: const #1u : u8
        let s_1436_0: bool = true;
        // D s_1436_1: write-var gs#407534 <= s_1436_0
        fn_state.gs_407534 = s_1436_0;
        // N s_1436_2: jump b1415
        return block_1415(state, tracer, fn_state);
    }
    fn block_1437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1437_0: const #1u : u8
        let s_1437_0: bool = true;
        // D s_1437_1: write-var gs#407531 <= s_1437_0
        fn_state.gs_407531 = s_1437_0;
        // N s_1437_2: jump b1413
        return block_1413(state, tracer, fn_state);
    }
    fn block_1438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1438_0: const #1u : u8
        let s_1438_0: bool = true;
        // D s_1438_1: write-var gs#407528 <= s_1438_0
        fn_state.gs_407528 = s_1438_0;
        // N s_1438_2: jump b1411
        return block_1411(state, tracer, fn_state);
    }
    fn block_1439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1439_0: const #1u : u8
        let s_1439_0: bool = true;
        // D s_1439_1: write-var gs#407525 <= s_1439_0
        fn_state.gs_407525 = s_1439_0;
        // N s_1439_2: jump b1409
        return block_1409(state, tracer, fn_state);
    }
    fn block_1440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1440_0: const #1u : u8
        let s_1440_0: bool = true;
        // D s_1440_1: write-var gs#407522 <= s_1440_0
        fn_state.gs_407522 = s_1440_0;
        // N s_1440_2: jump b1407
        return block_1407(state, tracer, fn_state);
    }
    fn block_1441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1441_0: const #1u : u8
        let s_1441_0: bool = true;
        // D s_1441_1: write-var gs#407519 <= s_1441_0
        fn_state.gs_407519 = s_1441_0;
        // N s_1441_2: jump b1405
        return block_1405(state, tracer, fn_state);
    }
    fn block_1442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1442_0: const #1u : u8
        let s_1442_0: bool = true;
        // D s_1442_1: write-var gs#407516 <= s_1442_0
        fn_state.gs_407516 = s_1442_0;
        // N s_1442_2: jump b1403
        return block_1403(state, tracer, fn_state);
    }
    fn block_1443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1443_0: const #1u : u8
        let s_1443_0: bool = true;
        // D s_1443_1: write-var gs#407513 <= s_1443_0
        fn_state.gs_407513 = s_1443_0;
        // N s_1443_2: jump b1401
        return block_1401(state, tracer, fn_state);
    }
    fn block_1444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1444_0: const #1u : u8
        let s_1444_0: bool = true;
        // D s_1444_1: write-var gs#407510 <= s_1444_0
        fn_state.gs_407510 = s_1444_0;
        // N s_1444_2: jump b1399
        return block_1399(state, tracer, fn_state);
    }
    fn block_1445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1445_0: read-var merge#var.1:struct
        let s_1445_0: u32 = fn_state.merge_var._1;
        // D s_1445_1: write-var u#33143 <= s_1445_0
        fn_state.u_33143 = s_1445_0;
        // C s_1445_2: const #20s : i
        let s_1445_2: i128 = 20;
        // D s_1445_3: read-var u#33143:u32
        let s_1445_3: u32 = fn_state.u_33143;
        // D s_1445_4: cast zx s_1445_3 -> bv
        let s_1445_4: Bits = Bits::new(s_1445_3 as u128, 32u16);
        // C s_1445_5: const #1s : i64
        let s_1445_5: i64 = 1;
        // C s_1445_6: cast zx s_1445_5 -> i
        let s_1445_6: i128 = (i128::try_from(s_1445_5).unwrap());
        // C s_1445_7: const #7s : i
        let s_1445_7: i128 = 7;
        // C s_1445_8: add s_1445_7 s_1445_6
        let s_1445_8: i128 = (s_1445_7 + s_1445_6);
        // D s_1445_9: bit-extract s_1445_4 s_1445_2 s_1445_8
        let s_1445_9: Bits = (Bits::new(
            ((s_1445_4) >> (s_1445_2)).value(),
            u16::try_from(s_1445_8).unwrap(),
        ));
        // D s_1445_10: cast reint s_1445_9 -> u8
        let s_1445_10: u8 = (s_1445_9.value() as u8);
        // D s_1445_11: cast zx s_1445_10 -> bv
        let s_1445_11: Bits = Bits::new(s_1445_10 as u128, 8u16);
        // C s_1445_12: const #20u : u8
        let s_1445_12: u8 = 20;
        // C s_1445_13: cast zx s_1445_12 -> bv
        let s_1445_13: Bits = Bits::new(s_1445_12 as u128, 8u16);
        // D s_1445_14: cmp-eq s_1445_11 s_1445_13
        let s_1445_14: bool = ((s_1445_11) == (s_1445_13));
        // N s_1445_15: branch s_1445_14 b2207 b1446
        if s_1445_14 {
            return block_2207(state, tracer, fn_state);
        } else {
            return block_1446(state, tracer, fn_state);
        };
    }
    fn block_1446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1446_0: const #0u : u8
        let s_1446_0: bool = false;
        // D s_1446_1: write-var gs#407558 <= s_1446_0
        fn_state.gs_407558 = s_1446_0;
        // N s_1446_2: jump b1447
        return block_1447(state, tracer, fn_state);
    }
    fn block_1447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1447_0: read-var gs#407558:u8
        let s_1447_0: bool = fn_state.gs_407558;
        // N s_1447_1: branch s_1447_0 b2203 b1448
        if s_1447_0 {
            return block_2203(state, tracer, fn_state);
        } else {
            return block_1448(state, tracer, fn_state);
        };
    }
    fn block_1448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1448_0: const #0u : u8
        let s_1448_0: bool = false;
        // D s_1448_1: write-var gs#407563 <= s_1448_0
        fn_state.gs_407563 = s_1448_0;
        // N s_1448_2: jump b1449
        return block_1449(state, tracer, fn_state);
    }
    fn block_1449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1449_0: read-var gs#407563:u8
        let s_1449_0: bool = fn_state.gs_407563;
        // D s_1449_1: not s_1449_0
        let s_1449_1: bool = !s_1449_0;
        // N s_1449_2: branch s_1449_1 b1451 b1450
        if s_1449_1 {
            return block_1451(state, tracer, fn_state);
        } else {
            return block_1450(state, tracer, fn_state);
        };
    }
    fn block_1450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1450_0: const #3774s : i
        let s_1450_0: i128 = 3774;
        // C s_1450_1: const #14696u : u32
        let s_1450_1: u32 = 14696;
        // N s_1450_2: write-reg s_1450_1 <= s_1450_0
        let s_1450_2: () = {
            state.write_register::<i128>(s_1450_1 as isize, s_1450_0);
            tracer.write_register(s_1450_1 as isize, s_1450_0);
        };
        // C s_1450_3: const #28s : i
        let s_1450_3: i128 = 28;
        // C s_1450_4: const #4s : i
        let s_1450_4: i128 = 4;
        // D s_1450_5: read-var u#33143:u32
        let s_1450_5: u32 = fn_state.u_33143;
        // D s_1450_6: cast zx s_1450_5 -> bv
        let s_1450_6: Bits = Bits::new(s_1450_5 as u128, 32u16);
        // D s_1450_7: bit-extract s_1450_6 s_1450_3 s_1450_4
        let s_1450_7: Bits = (Bits::new(
            ((s_1450_6) >> (s_1450_3)).value(),
            u16::try_from(s_1450_4).unwrap(),
        ));
        // D s_1450_8: cast reint s_1450_7 -> u8
        let s_1450_8: u8 = (s_1450_7.value() as u8);
        // C s_1450_9: const #8s : i
        let s_1450_9: i128 = 8;
        // C s_1450_10: const #12s : i
        let s_1450_10: i128 = 12;
        // D s_1450_11: read-var u#33143:u32
        let s_1450_11: u32 = fn_state.u_33143;
        // D s_1450_12: cast zx s_1450_11 -> bv
        let s_1450_12: Bits = Bits::new(s_1450_11 as u128, 32u16);
        // D s_1450_13: bit-extract s_1450_12 s_1450_9 s_1450_10
        let s_1450_13: Bits = (Bits::new(
            ((s_1450_12) >> (s_1450_9)).value(),
            u16::try_from(s_1450_10).unwrap(),
        ));
        // D s_1450_14: cast reint s_1450_13 -> u12
        let s_1450_14: u16 = (s_1450_13.value() as u16);
        // C s_1450_15: const #0s : i
        let s_1450_15: i128 = 0;
        // C s_1450_16: const #4s : i
        let s_1450_16: i128 = 4;
        // D s_1450_17: read-var u#33143:u32
        let s_1450_17: u32 = fn_state.u_33143;
        // D s_1450_18: cast zx s_1450_17 -> bv
        let s_1450_18: Bits = Bits::new(s_1450_17 as u128, 32u16);
        // D s_1450_19: bit-extract s_1450_18 s_1450_15 s_1450_16
        let s_1450_19: Bits = (Bits::new(
            ((s_1450_18) >> (s_1450_15)).value(),
            u16::try_from(s_1450_16).unwrap(),
        ));
        // D s_1450_20: cast reint s_1450_19 -> u8
        let s_1450_20: u8 = (s_1450_19.value() as u8);
        // D s_1450_21: call decode_aarch32_instrs_HVC_A1enc_A_txt(s_1450_8, s_1450_14, s_1450_20)
        let s_1450_21: () = decode_aarch32_instrs_HVC_A1enc_A_txt(
            state,
            tracer,
            s_1450_8,
            s_1450_14,
            s_1450_20,
        );
        // N s_1450_22: return
        return;
    }
    fn block_1451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1451_0: read-var merge#var.1:struct
        let s_1451_0: u32 = fn_state.merge_var._1;
        // D s_1451_1: write-var u#33148 <= s_1451_0
        fn_state.u_33148 = s_1451_0;
        // C s_1451_2: const #23s : i
        let s_1451_2: i128 = 23;
        // D s_1451_3: read-var u#33148:u32
        let s_1451_3: u32 = fn_state.u_33148;
        // D s_1451_4: cast zx s_1451_3 -> bv
        let s_1451_4: Bits = Bits::new(s_1451_3 as u128, 32u16);
        // C s_1451_5: const #1s : i64
        let s_1451_5: i64 = 1;
        // C s_1451_6: cast zx s_1451_5 -> i
        let s_1451_6: i128 = (i128::try_from(s_1451_5).unwrap());
        // C s_1451_7: const #4s : i
        let s_1451_7: i128 = 4;
        // C s_1451_8: add s_1451_7 s_1451_6
        let s_1451_8: i128 = (s_1451_7 + s_1451_6);
        // D s_1451_9: bit-extract s_1451_4 s_1451_2 s_1451_8
        let s_1451_9: Bits = (Bits::new(
            ((s_1451_4) >> (s_1451_2)).value(),
            u16::try_from(s_1451_8).unwrap(),
        ));
        // D s_1451_10: cast reint s_1451_9 -> u8
        let s_1451_10: u8 = (s_1451_9.value() as u8);
        // D s_1451_11: cast zx s_1451_10 -> bv
        let s_1451_11: Bits = Bits::new(s_1451_10 as u128, 5u16);
        // C s_1451_12: const #2u : u8
        let s_1451_12: u8 = 2;
        // C s_1451_13: cast zx s_1451_12 -> bv
        let s_1451_13: Bits = Bits::new(s_1451_12 as u128, 5u16);
        // D s_1451_14: cmp-eq s_1451_11 s_1451_13
        let s_1451_14: bool = ((s_1451_11) == (s_1451_13));
        // N s_1451_15: branch s_1451_14 b2199 b1452
        if s_1451_14 {
            return block_2199(state, tracer, fn_state);
        } else {
            return block_1452(state, tracer, fn_state);
        };
    }
    fn block_1452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1452_0: const #0u : u8
        let s_1452_0: bool = false;
        // D s_1452_1: write-var gs#407580 <= s_1452_0
        fn_state.gs_407580 = s_1452_0;
        // N s_1452_2: jump b1453
        return block_1453(state, tracer, fn_state);
    }
    fn block_1453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1453_0: read-var gs#407580:u8
        let s_1453_0: bool = fn_state.gs_407580;
        // N s_1453_1: branch s_1453_0 b2195 b1454
        if s_1453_0 {
            return block_2195(state, tracer, fn_state);
        } else {
            return block_1454(state, tracer, fn_state);
        };
    }
    fn block_1454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1454_0: const #0u : u8
        let s_1454_0: bool = false;
        // D s_1454_1: write-var gs#407585 <= s_1454_0
        fn_state.gs_407585 = s_1454_0;
        // N s_1454_2: jump b1455
        return block_1455(state, tracer, fn_state);
    }
    fn block_1455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1455_0: read-var gs#407585:u8
        let s_1455_0: bool = fn_state.gs_407585;
        // D s_1455_1: not s_1455_0
        let s_1455_1: bool = !s_1455_0;
        // N s_1455_2: branch s_1455_1 b1489 b1456
        if s_1455_1 {
            return block_1489(state, tracer, fn_state);
        } else {
            return block_1456(state, tracer, fn_state);
        };
    }
    fn block_1456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1456_0: const #3778s : i
        let s_1456_0: i128 = 3778;
        // C s_1456_1: const #14696u : u32
        let s_1456_1: u32 = 14696;
        // N s_1456_2: write-reg s_1456_1 <= s_1456_0
        let s_1456_2: () = {
            state.write_register::<i128>(s_1456_1 as isize, s_1456_0);
            tracer.write_register(s_1456_1 as isize, s_1456_0);
        };
        // C s_1456_3: const #28s : i
        let s_1456_3: i128 = 28;
        // C s_1456_4: const #4s : i
        let s_1456_4: i128 = 4;
        // D s_1456_5: read-var u#33148:u32
        let s_1456_5: u32 = fn_state.u_33148;
        // D s_1456_6: cast zx s_1456_5 -> bv
        let s_1456_6: Bits = Bits::new(s_1456_5 as u128, 32u16);
        // D s_1456_7: bit-extract s_1456_6 s_1456_3 s_1456_4
        let s_1456_7: Bits = (Bits::new(
            ((s_1456_6) >> (s_1456_3)).value(),
            u16::try_from(s_1456_4).unwrap(),
        ));
        // D s_1456_8: cast reint s_1456_7 -> u8
        let s_1456_8: u8 = (s_1456_7.value() as u8);
        // D s_1456_9: write-var u#33149 <= s_1456_8
        fn_state.u_33149 = s_1456_8;
        // C s_1456_10: const #22s : i
        let s_1456_10: i128 = 22;
        // C s_1456_11: const #1s : i
        let s_1456_11: i128 = 1;
        // D s_1456_12: read-var u#33148:u32
        let s_1456_12: u32 = fn_state.u_33148;
        // D s_1456_13: cast zx s_1456_12 -> bv
        let s_1456_13: Bits = Bits::new(s_1456_12 as u128, 32u16);
        // D s_1456_14: bit-extract s_1456_13 s_1456_10 s_1456_11
        let s_1456_14: Bits = (Bits::new(
            ((s_1456_13) >> (s_1456_10)).value(),
            u16::try_from(s_1456_11).unwrap(),
        ));
        // D s_1456_15: cast reint s_1456_14 -> u8
        let s_1456_15: bool = ((s_1456_14.value()) != 0);
        // D s_1456_16: write-var R <= s_1456_15
        fn_state.R = s_1456_15;
        // C s_1456_17: const #12s : i
        let s_1456_17: i128 = 12;
        // C s_1456_18: const #4s : i
        let s_1456_18: i128 = 4;
        // D s_1456_19: read-var u#33148:u32
        let s_1456_19: u32 = fn_state.u_33148;
        // D s_1456_20: cast zx s_1456_19 -> bv
        let s_1456_20: Bits = Bits::new(s_1456_19 as u128, 32u16);
        // D s_1456_21: bit-extract s_1456_20 s_1456_17 s_1456_18
        let s_1456_21: Bits = (Bits::new(
            ((s_1456_20) >> (s_1456_17)).value(),
            u16::try_from(s_1456_18).unwrap(),
        ));
        // D s_1456_22: cast reint s_1456_21 -> u8
        let s_1456_22: u8 = (s_1456_21.value() as u8);
        // D s_1456_23: write-var u#33150 <= s_1456_22
        fn_state.u_33150 = s_1456_22;
        // C s_1456_24: const #16s : i
        let s_1456_24: i128 = 16;
        // D s_1456_25: read-var u#33148:u32
        let s_1456_25: u32 = fn_state.u_33148;
        // D s_1456_26: cast zx s_1456_25 -> bv
        let s_1456_26: Bits = Bits::new(s_1456_25 as u128, 32u16);
        // C s_1456_27: const #1u : u64
        let s_1456_27: u64 = 1;
        // D s_1456_28: bit-extract s_1456_26 s_1456_24 s_1456_27
        let s_1456_28: Bits = (Bits::new(
            ((s_1456_26) >> (s_1456_24)).value(),
            u16::try_from(s_1456_27).unwrap(),
        ));
        // D s_1456_29: cast reint s_1456_28 -> u8
        let s_1456_29: bool = ((s_1456_28.value()) != 0);
        // C s_1456_30: const #0s : i
        let s_1456_30: i128 = 0;
        // C s_1456_31: const #0u : u64
        let s_1456_31: u64 = 0;
        // D s_1456_32: cast zx s_1456_29 -> u64
        let s_1456_32: u64 = (s_1456_29 as u64);
        // C s_1456_33: const #1u : u64
        let s_1456_33: u64 = 1;
        // D s_1456_34: and s_1456_32 s_1456_33
        let s_1456_34: u64 = ((s_1456_32) & (s_1456_33));
        // D s_1456_35: cmp-eq s_1456_34 s_1456_33
        let s_1456_35: bool = ((s_1456_34) == (s_1456_33));
        // D s_1456_36: lsl s_1456_32 s_1456_30
        let s_1456_36: u64 = s_1456_32 << s_1456_30;
        // D s_1456_37: or s_1456_31 s_1456_36
        let s_1456_37: u64 = ((s_1456_31) | (s_1456_36));
        // D s_1456_38: cmpl s_1456_36
        let s_1456_38: u64 = !s_1456_36;
        // D s_1456_39: and s_1456_31 s_1456_38
        let s_1456_39: u64 = ((s_1456_31) & (s_1456_38));
        // D s_1456_40: select s_1456_35 s_1456_37 s_1456_39
        let s_1456_40: u64 = if s_1456_35 { s_1456_37 } else { s_1456_39 };
        // D s_1456_41: cast trunc s_1456_40 -> u8
        let s_1456_41: bool = ((s_1456_40) != 0);
        // D s_1456_42: cast zx s_1456_41 -> bv
        let s_1456_42: Bits = Bits::new(s_1456_41 as u128, 1u16);
        // C s_1456_43: const #1u : u8
        let s_1456_43: bool = true;
        // C s_1456_44: cast zx s_1456_43 -> bv
        let s_1456_44: Bits = Bits::new(s_1456_43 as u128, 1u16);
        // D s_1456_45: cmp-ne s_1456_42 s_1456_44
        let s_1456_45: bool = ((s_1456_42) != (s_1456_44));
        // N s_1456_46: branch s_1456_45 b1488 b1457
        if s_1456_45 {
            return block_1488(state, tracer, fn_state);
        } else {
            return block_1457(state, tracer, fn_state);
        };
    }
    fn block_1457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1457_0: const #17s : i
        let s_1457_0: i128 = 17;
        // D s_1457_1: read-var u#33148:u32
        let s_1457_1: u32 = fn_state.u_33148;
        // D s_1457_2: cast zx s_1457_1 -> bv
        let s_1457_2: Bits = Bits::new(s_1457_1 as u128, 32u16);
        // C s_1457_3: const #1u : u64
        let s_1457_3: u64 = 1;
        // D s_1457_4: bit-extract s_1457_2 s_1457_0 s_1457_3
        let s_1457_4: Bits = (Bits::new(
            ((s_1457_2) >> (s_1457_0)).value(),
            u16::try_from(s_1457_3).unwrap(),
        ));
        // D s_1457_5: cast reint s_1457_4 -> u8
        let s_1457_5: bool = ((s_1457_4.value()) != 0);
        // C s_1457_6: const #0s : i
        let s_1457_6: i128 = 0;
        // C s_1457_7: const #0u : u64
        let s_1457_7: u64 = 0;
        // D s_1457_8: cast zx s_1457_5 -> u64
        let s_1457_8: u64 = (s_1457_5 as u64);
        // C s_1457_9: const #1u : u64
        let s_1457_9: u64 = 1;
        // D s_1457_10: and s_1457_8 s_1457_9
        let s_1457_10: u64 = ((s_1457_8) & (s_1457_9));
        // D s_1457_11: cmp-eq s_1457_10 s_1457_9
        let s_1457_11: bool = ((s_1457_10) == (s_1457_9));
        // D s_1457_12: lsl s_1457_8 s_1457_6
        let s_1457_12: u64 = s_1457_8 << s_1457_6;
        // D s_1457_13: or s_1457_7 s_1457_12
        let s_1457_13: u64 = ((s_1457_7) | (s_1457_12));
        // D s_1457_14: cmpl s_1457_12
        let s_1457_14: u64 = !s_1457_12;
        // D s_1457_15: and s_1457_7 s_1457_14
        let s_1457_15: u64 = ((s_1457_7) & (s_1457_14));
        // D s_1457_16: select s_1457_11 s_1457_13 s_1457_15
        let s_1457_16: u64 = if s_1457_11 { s_1457_13 } else { s_1457_15 };
        // D s_1457_17: cast trunc s_1457_16 -> u8
        let s_1457_17: bool = ((s_1457_16) != 0);
        // D s_1457_18: cast zx s_1457_17 -> bv
        let s_1457_18: Bits = Bits::new(s_1457_17 as u128, 1u16);
        // C s_1457_19: const #1u : u8
        let s_1457_19: bool = true;
        // C s_1457_20: cast zx s_1457_19 -> bv
        let s_1457_20: Bits = Bits::new(s_1457_19 as u128, 1u16);
        // D s_1457_21: cmp-ne s_1457_18 s_1457_20
        let s_1457_21: bool = ((s_1457_18) != (s_1457_20));
        // D s_1457_22: write-var gs#407598 <= s_1457_21
        fn_state.gs_407598 = s_1457_21;
        // N s_1457_23: jump b1458
        return block_1458(state, tracer, fn_state);
    }
    fn block_1458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1458_0: read-var gs#407598:u8
        let s_1458_0: bool = fn_state.gs_407598;
        // N s_1458_1: branch s_1458_0 b1487 b1459
        if s_1458_0 {
            return block_1487(state, tracer, fn_state);
        } else {
            return block_1459(state, tracer, fn_state);
        };
    }
    fn block_1459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1459_0: const #18s : i
        let s_1459_0: i128 = 18;
        // D s_1459_1: read-var u#33148:u32
        let s_1459_1: u32 = fn_state.u_33148;
        // D s_1459_2: cast zx s_1459_1 -> bv
        let s_1459_2: Bits = Bits::new(s_1459_1 as u128, 32u16);
        // C s_1459_3: const #1u : u64
        let s_1459_3: u64 = 1;
        // D s_1459_4: bit-extract s_1459_2 s_1459_0 s_1459_3
        let s_1459_4: Bits = (Bits::new(
            ((s_1459_2) >> (s_1459_0)).value(),
            u16::try_from(s_1459_3).unwrap(),
        ));
        // D s_1459_5: cast reint s_1459_4 -> u8
        let s_1459_5: bool = ((s_1459_4.value()) != 0);
        // C s_1459_6: const #0s : i
        let s_1459_6: i128 = 0;
        // C s_1459_7: const #0u : u64
        let s_1459_7: u64 = 0;
        // D s_1459_8: cast zx s_1459_5 -> u64
        let s_1459_8: u64 = (s_1459_5 as u64);
        // C s_1459_9: const #1u : u64
        let s_1459_9: u64 = 1;
        // D s_1459_10: and s_1459_8 s_1459_9
        let s_1459_10: u64 = ((s_1459_8) & (s_1459_9));
        // D s_1459_11: cmp-eq s_1459_10 s_1459_9
        let s_1459_11: bool = ((s_1459_10) == (s_1459_9));
        // D s_1459_12: lsl s_1459_8 s_1459_6
        let s_1459_12: u64 = s_1459_8 << s_1459_6;
        // D s_1459_13: or s_1459_7 s_1459_12
        let s_1459_13: u64 = ((s_1459_7) | (s_1459_12));
        // D s_1459_14: cmpl s_1459_12
        let s_1459_14: u64 = !s_1459_12;
        // D s_1459_15: and s_1459_7 s_1459_14
        let s_1459_15: u64 = ((s_1459_7) & (s_1459_14));
        // D s_1459_16: select s_1459_11 s_1459_13 s_1459_15
        let s_1459_16: u64 = if s_1459_11 { s_1459_13 } else { s_1459_15 };
        // D s_1459_17: cast trunc s_1459_16 -> u8
        let s_1459_17: bool = ((s_1459_16) != 0);
        // D s_1459_18: cast zx s_1459_17 -> bv
        let s_1459_18: Bits = Bits::new(s_1459_17 as u128, 1u16);
        // C s_1459_19: const #1u : u8
        let s_1459_19: bool = true;
        // C s_1459_20: cast zx s_1459_19 -> bv
        let s_1459_20: Bits = Bits::new(s_1459_19 as u128, 1u16);
        // D s_1459_21: cmp-ne s_1459_18 s_1459_20
        let s_1459_21: bool = ((s_1459_18) != (s_1459_20));
        // D s_1459_22: write-var gs#407601 <= s_1459_21
        fn_state.gs_407601 = s_1459_21;
        // N s_1459_23: jump b1460
        return block_1460(state, tracer, fn_state);
    }
    fn block_1460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1460_0: read-var gs#407601:u8
        let s_1460_0: bool = fn_state.gs_407601;
        // N s_1460_1: branch s_1460_0 b1486 b1461
        if s_1460_0 {
            return block_1486(state, tracer, fn_state);
        } else {
            return block_1461(state, tracer, fn_state);
        };
    }
    fn block_1461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1461_0: const #19s : i
        let s_1461_0: i128 = 19;
        // D s_1461_1: read-var u#33148:u32
        let s_1461_1: u32 = fn_state.u_33148;
        // D s_1461_2: cast zx s_1461_1 -> bv
        let s_1461_2: Bits = Bits::new(s_1461_1 as u128, 32u16);
        // C s_1461_3: const #1u : u64
        let s_1461_3: u64 = 1;
        // D s_1461_4: bit-extract s_1461_2 s_1461_0 s_1461_3
        let s_1461_4: Bits = (Bits::new(
            ((s_1461_2) >> (s_1461_0)).value(),
            u16::try_from(s_1461_3).unwrap(),
        ));
        // D s_1461_5: cast reint s_1461_4 -> u8
        let s_1461_5: bool = ((s_1461_4.value()) != 0);
        // C s_1461_6: const #0s : i
        let s_1461_6: i128 = 0;
        // C s_1461_7: const #0u : u64
        let s_1461_7: u64 = 0;
        // D s_1461_8: cast zx s_1461_5 -> u64
        let s_1461_8: u64 = (s_1461_5 as u64);
        // C s_1461_9: const #1u : u64
        let s_1461_9: u64 = 1;
        // D s_1461_10: and s_1461_8 s_1461_9
        let s_1461_10: u64 = ((s_1461_8) & (s_1461_9));
        // D s_1461_11: cmp-eq s_1461_10 s_1461_9
        let s_1461_11: bool = ((s_1461_10) == (s_1461_9));
        // D s_1461_12: lsl s_1461_8 s_1461_6
        let s_1461_12: u64 = s_1461_8 << s_1461_6;
        // D s_1461_13: or s_1461_7 s_1461_12
        let s_1461_13: u64 = ((s_1461_7) | (s_1461_12));
        // D s_1461_14: cmpl s_1461_12
        let s_1461_14: u64 = !s_1461_12;
        // D s_1461_15: and s_1461_7 s_1461_14
        let s_1461_15: u64 = ((s_1461_7) & (s_1461_14));
        // D s_1461_16: select s_1461_11 s_1461_13 s_1461_15
        let s_1461_16: u64 = if s_1461_11 { s_1461_13 } else { s_1461_15 };
        // D s_1461_17: cast trunc s_1461_16 -> u8
        let s_1461_17: bool = ((s_1461_16) != 0);
        // D s_1461_18: cast zx s_1461_17 -> bv
        let s_1461_18: Bits = Bits::new(s_1461_17 as u128, 1u16);
        // C s_1461_19: const #1u : u8
        let s_1461_19: bool = true;
        // C s_1461_20: cast zx s_1461_19 -> bv
        let s_1461_20: Bits = Bits::new(s_1461_19 as u128, 1u16);
        // D s_1461_21: cmp-ne s_1461_18 s_1461_20
        let s_1461_21: bool = ((s_1461_18) != (s_1461_20));
        // D s_1461_22: write-var gs#407604 <= s_1461_21
        fn_state.gs_407604 = s_1461_21;
        // N s_1461_23: jump b1462
        return block_1462(state, tracer, fn_state);
    }
    fn block_1462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1462_0: read-var gs#407604:u8
        let s_1462_0: bool = fn_state.gs_407604;
        // N s_1462_1: branch s_1462_0 b1485 b1463
        if s_1462_0 {
            return block_1485(state, tracer, fn_state);
        } else {
            return block_1463(state, tracer, fn_state);
        };
    }
    fn block_1463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1463_0: const #10s : i
        let s_1463_0: i128 = 10;
        // D s_1463_1: read-var u#33148:u32
        let s_1463_1: u32 = fn_state.u_33148;
        // D s_1463_2: cast zx s_1463_1 -> bv
        let s_1463_2: Bits = Bits::new(s_1463_1 as u128, 32u16);
        // C s_1463_3: const #1u : u64
        let s_1463_3: u64 = 1;
        // D s_1463_4: bit-extract s_1463_2 s_1463_0 s_1463_3
        let s_1463_4: Bits = (Bits::new(
            ((s_1463_2) >> (s_1463_0)).value(),
            u16::try_from(s_1463_3).unwrap(),
        ));
        // D s_1463_5: cast reint s_1463_4 -> u8
        let s_1463_5: bool = ((s_1463_4.value()) != 0);
        // C s_1463_6: const #0s : i
        let s_1463_6: i128 = 0;
        // C s_1463_7: const #0u : u64
        let s_1463_7: u64 = 0;
        // D s_1463_8: cast zx s_1463_5 -> u64
        let s_1463_8: u64 = (s_1463_5 as u64);
        // C s_1463_9: const #1u : u64
        let s_1463_9: u64 = 1;
        // D s_1463_10: and s_1463_8 s_1463_9
        let s_1463_10: u64 = ((s_1463_8) & (s_1463_9));
        // D s_1463_11: cmp-eq s_1463_10 s_1463_9
        let s_1463_11: bool = ((s_1463_10) == (s_1463_9));
        // D s_1463_12: lsl s_1463_8 s_1463_6
        let s_1463_12: u64 = s_1463_8 << s_1463_6;
        // D s_1463_13: or s_1463_7 s_1463_12
        let s_1463_13: u64 = ((s_1463_7) | (s_1463_12));
        // D s_1463_14: cmpl s_1463_12
        let s_1463_14: u64 = !s_1463_12;
        // D s_1463_15: and s_1463_7 s_1463_14
        let s_1463_15: u64 = ((s_1463_7) & (s_1463_14));
        // D s_1463_16: select s_1463_11 s_1463_13 s_1463_15
        let s_1463_16: u64 = if s_1463_11 { s_1463_13 } else { s_1463_15 };
        // D s_1463_17: cast trunc s_1463_16 -> u8
        let s_1463_17: bool = ((s_1463_16) != 0);
        // D s_1463_18: cast zx s_1463_17 -> bv
        let s_1463_18: Bits = Bits::new(s_1463_17 as u128, 1u16);
        // C s_1463_19: const #0u : u8
        let s_1463_19: bool = false;
        // C s_1463_20: cast zx s_1463_19 -> bv
        let s_1463_20: Bits = Bits::new(s_1463_19 as u128, 1u16);
        // D s_1463_21: cmp-ne s_1463_18 s_1463_20
        let s_1463_21: bool = ((s_1463_18) != (s_1463_20));
        // D s_1463_22: write-var gs#407607 <= s_1463_21
        fn_state.gs_407607 = s_1463_21;
        // N s_1463_23: jump b1464
        return block_1464(state, tracer, fn_state);
    }
    fn block_1464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1464_0: read-var gs#407607:u8
        let s_1464_0: bool = fn_state.gs_407607;
        // N s_1464_1: branch s_1464_0 b1484 b1465
        if s_1464_0 {
            return block_1484(state, tracer, fn_state);
        } else {
            return block_1465(state, tracer, fn_state);
        };
    }
    fn block_1465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1465_0: const #11s : i
        let s_1465_0: i128 = 11;
        // D s_1465_1: read-var u#33148:u32
        let s_1465_1: u32 = fn_state.u_33148;
        // D s_1465_2: cast zx s_1465_1 -> bv
        let s_1465_2: Bits = Bits::new(s_1465_1 as u128, 32u16);
        // C s_1465_3: const #1u : u64
        let s_1465_3: u64 = 1;
        // D s_1465_4: bit-extract s_1465_2 s_1465_0 s_1465_3
        let s_1465_4: Bits = (Bits::new(
            ((s_1465_2) >> (s_1465_0)).value(),
            u16::try_from(s_1465_3).unwrap(),
        ));
        // D s_1465_5: cast reint s_1465_4 -> u8
        let s_1465_5: bool = ((s_1465_4.value()) != 0);
        // C s_1465_6: const #0s : i
        let s_1465_6: i128 = 0;
        // C s_1465_7: const #0u : u64
        let s_1465_7: u64 = 0;
        // D s_1465_8: cast zx s_1465_5 -> u64
        let s_1465_8: u64 = (s_1465_5 as u64);
        // C s_1465_9: const #1u : u64
        let s_1465_9: u64 = 1;
        // D s_1465_10: and s_1465_8 s_1465_9
        let s_1465_10: u64 = ((s_1465_8) & (s_1465_9));
        // D s_1465_11: cmp-eq s_1465_10 s_1465_9
        let s_1465_11: bool = ((s_1465_10) == (s_1465_9));
        // D s_1465_12: lsl s_1465_8 s_1465_6
        let s_1465_12: u64 = s_1465_8 << s_1465_6;
        // D s_1465_13: or s_1465_7 s_1465_12
        let s_1465_13: u64 = ((s_1465_7) | (s_1465_12));
        // D s_1465_14: cmpl s_1465_12
        let s_1465_14: u64 = !s_1465_12;
        // D s_1465_15: and s_1465_7 s_1465_14
        let s_1465_15: u64 = ((s_1465_7) & (s_1465_14));
        // D s_1465_16: select s_1465_11 s_1465_13 s_1465_15
        let s_1465_16: u64 = if s_1465_11 { s_1465_13 } else { s_1465_15 };
        // D s_1465_17: cast trunc s_1465_16 -> u8
        let s_1465_17: bool = ((s_1465_16) != 0);
        // D s_1465_18: cast zx s_1465_17 -> bv
        let s_1465_18: Bits = Bits::new(s_1465_17 as u128, 1u16);
        // C s_1465_19: const #0u : u8
        let s_1465_19: bool = false;
        // C s_1465_20: cast zx s_1465_19 -> bv
        let s_1465_20: Bits = Bits::new(s_1465_19 as u128, 1u16);
        // D s_1465_21: cmp-ne s_1465_18 s_1465_20
        let s_1465_21: bool = ((s_1465_18) != (s_1465_20));
        // D s_1465_22: write-var gs#407610 <= s_1465_21
        fn_state.gs_407610 = s_1465_21;
        // N s_1465_23: jump b1466
        return block_1466(state, tracer, fn_state);
    }
    fn block_1466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1466_0: read-var gs#407610:u8
        let s_1466_0: bool = fn_state.gs_407610;
        // N s_1466_1: branch s_1466_0 b1483 b1467
        if s_1466_0 {
            return block_1483(state, tracer, fn_state);
        } else {
            return block_1467(state, tracer, fn_state);
        };
    }
    fn block_1467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1467_0: const #8s : i
        let s_1467_0: i128 = 8;
        // D s_1467_1: read-var u#33148:u32
        let s_1467_1: u32 = fn_state.u_33148;
        // D s_1467_2: cast zx s_1467_1 -> bv
        let s_1467_2: Bits = Bits::new(s_1467_1 as u128, 32u16);
        // C s_1467_3: const #1u : u64
        let s_1467_3: u64 = 1;
        // D s_1467_4: bit-extract s_1467_2 s_1467_0 s_1467_3
        let s_1467_4: Bits = (Bits::new(
            ((s_1467_2) >> (s_1467_0)).value(),
            u16::try_from(s_1467_3).unwrap(),
        ));
        // D s_1467_5: cast reint s_1467_4 -> u8
        let s_1467_5: bool = ((s_1467_4.value()) != 0);
        // C s_1467_6: const #0s : i
        let s_1467_6: i128 = 0;
        // C s_1467_7: const #0u : u64
        let s_1467_7: u64 = 0;
        // D s_1467_8: cast zx s_1467_5 -> u64
        let s_1467_8: u64 = (s_1467_5 as u64);
        // C s_1467_9: const #1u : u64
        let s_1467_9: u64 = 1;
        // D s_1467_10: and s_1467_8 s_1467_9
        let s_1467_10: u64 = ((s_1467_8) & (s_1467_9));
        // D s_1467_11: cmp-eq s_1467_10 s_1467_9
        let s_1467_11: bool = ((s_1467_10) == (s_1467_9));
        // D s_1467_12: lsl s_1467_8 s_1467_6
        let s_1467_12: u64 = s_1467_8 << s_1467_6;
        // D s_1467_13: or s_1467_7 s_1467_12
        let s_1467_13: u64 = ((s_1467_7) | (s_1467_12));
        // D s_1467_14: cmpl s_1467_12
        let s_1467_14: u64 = !s_1467_12;
        // D s_1467_15: and s_1467_7 s_1467_14
        let s_1467_15: u64 = ((s_1467_7) & (s_1467_14));
        // D s_1467_16: select s_1467_11 s_1467_13 s_1467_15
        let s_1467_16: u64 = if s_1467_11 { s_1467_13 } else { s_1467_15 };
        // D s_1467_17: cast trunc s_1467_16 -> u8
        let s_1467_17: bool = ((s_1467_16) != 0);
        // D s_1467_18: cast zx s_1467_17 -> bv
        let s_1467_18: Bits = Bits::new(s_1467_17 as u128, 1u16);
        // C s_1467_19: const #0u : u8
        let s_1467_19: bool = false;
        // C s_1467_20: cast zx s_1467_19 -> bv
        let s_1467_20: Bits = Bits::new(s_1467_19 as u128, 1u16);
        // D s_1467_21: cmp-ne s_1467_18 s_1467_20
        let s_1467_21: bool = ((s_1467_18) != (s_1467_20));
        // D s_1467_22: write-var gs#407613 <= s_1467_21
        fn_state.gs_407613 = s_1467_21;
        // N s_1467_23: jump b1468
        return block_1468(state, tracer, fn_state);
    }
    fn block_1468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1468_0: read-var gs#407613:u8
        let s_1468_0: bool = fn_state.gs_407613;
        // N s_1468_1: branch s_1468_0 b1482 b1469
        if s_1468_0 {
            return block_1482(state, tracer, fn_state);
        } else {
            return block_1469(state, tracer, fn_state);
        };
    }
    fn block_1469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1469_0: const #0s : i
        let s_1469_0: i128 = 0;
        // D s_1469_1: read-var u#33148:u32
        let s_1469_1: u32 = fn_state.u_33148;
        // D s_1469_2: cast zx s_1469_1 -> bv
        let s_1469_2: Bits = Bits::new(s_1469_1 as u128, 32u16);
        // C s_1469_3: const #1u : u64
        let s_1469_3: u64 = 1;
        // D s_1469_4: bit-extract s_1469_2 s_1469_0 s_1469_3
        let s_1469_4: Bits = (Bits::new(
            ((s_1469_2) >> (s_1469_0)).value(),
            u16::try_from(s_1469_3).unwrap(),
        ));
        // D s_1469_5: cast reint s_1469_4 -> u8
        let s_1469_5: bool = ((s_1469_4.value()) != 0);
        // C s_1469_6: const #0s : i
        let s_1469_6: i128 = 0;
        // C s_1469_7: const #0u : u64
        let s_1469_7: u64 = 0;
        // D s_1469_8: cast zx s_1469_5 -> u64
        let s_1469_8: u64 = (s_1469_5 as u64);
        // C s_1469_9: const #1u : u64
        let s_1469_9: u64 = 1;
        // D s_1469_10: and s_1469_8 s_1469_9
        let s_1469_10: u64 = ((s_1469_8) & (s_1469_9));
        // D s_1469_11: cmp-eq s_1469_10 s_1469_9
        let s_1469_11: bool = ((s_1469_10) == (s_1469_9));
        // D s_1469_12: lsl s_1469_8 s_1469_6
        let s_1469_12: u64 = s_1469_8 << s_1469_6;
        // D s_1469_13: or s_1469_7 s_1469_12
        let s_1469_13: u64 = ((s_1469_7) | (s_1469_12));
        // D s_1469_14: cmpl s_1469_12
        let s_1469_14: u64 = !s_1469_12;
        // D s_1469_15: and s_1469_7 s_1469_14
        let s_1469_15: u64 = ((s_1469_7) & (s_1469_14));
        // D s_1469_16: select s_1469_11 s_1469_13 s_1469_15
        let s_1469_16: u64 = if s_1469_11 { s_1469_13 } else { s_1469_15 };
        // D s_1469_17: cast trunc s_1469_16 -> u8
        let s_1469_17: bool = ((s_1469_16) != 0);
        // D s_1469_18: cast zx s_1469_17 -> bv
        let s_1469_18: Bits = Bits::new(s_1469_17 as u128, 1u16);
        // C s_1469_19: const #0u : u8
        let s_1469_19: bool = false;
        // C s_1469_20: cast zx s_1469_19 -> bv
        let s_1469_20: Bits = Bits::new(s_1469_19 as u128, 1u16);
        // D s_1469_21: cmp-ne s_1469_18 s_1469_20
        let s_1469_21: bool = ((s_1469_18) != (s_1469_20));
        // D s_1469_22: write-var gs#407616 <= s_1469_21
        fn_state.gs_407616 = s_1469_21;
        // N s_1469_23: jump b1470
        return block_1470(state, tracer, fn_state);
    }
    fn block_1470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1470_0: read-var gs#407616:u8
        let s_1470_0: bool = fn_state.gs_407616;
        // N s_1470_1: branch s_1470_0 b1481 b1471
        if s_1470_0 {
            return block_1481(state, tracer, fn_state);
        } else {
            return block_1471(state, tracer, fn_state);
        };
    }
    fn block_1471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1471_0: const #1s : i
        let s_1471_0: i128 = 1;
        // D s_1471_1: read-var u#33148:u32
        let s_1471_1: u32 = fn_state.u_33148;
        // D s_1471_2: cast zx s_1471_1 -> bv
        let s_1471_2: Bits = Bits::new(s_1471_1 as u128, 32u16);
        // C s_1471_3: const #1u : u64
        let s_1471_3: u64 = 1;
        // D s_1471_4: bit-extract s_1471_2 s_1471_0 s_1471_3
        let s_1471_4: Bits = (Bits::new(
            ((s_1471_2) >> (s_1471_0)).value(),
            u16::try_from(s_1471_3).unwrap(),
        ));
        // D s_1471_5: cast reint s_1471_4 -> u8
        let s_1471_5: bool = ((s_1471_4.value()) != 0);
        // C s_1471_6: const #0s : i
        let s_1471_6: i128 = 0;
        // C s_1471_7: const #0u : u64
        let s_1471_7: u64 = 0;
        // D s_1471_8: cast zx s_1471_5 -> u64
        let s_1471_8: u64 = (s_1471_5 as u64);
        // C s_1471_9: const #1u : u64
        let s_1471_9: u64 = 1;
        // D s_1471_10: and s_1471_8 s_1471_9
        let s_1471_10: u64 = ((s_1471_8) & (s_1471_9));
        // D s_1471_11: cmp-eq s_1471_10 s_1471_9
        let s_1471_11: bool = ((s_1471_10) == (s_1471_9));
        // D s_1471_12: lsl s_1471_8 s_1471_6
        let s_1471_12: u64 = s_1471_8 << s_1471_6;
        // D s_1471_13: or s_1471_7 s_1471_12
        let s_1471_13: u64 = ((s_1471_7) | (s_1471_12));
        // D s_1471_14: cmpl s_1471_12
        let s_1471_14: u64 = !s_1471_12;
        // D s_1471_15: and s_1471_7 s_1471_14
        let s_1471_15: u64 = ((s_1471_7) & (s_1471_14));
        // D s_1471_16: select s_1471_11 s_1471_13 s_1471_15
        let s_1471_16: u64 = if s_1471_11 { s_1471_13 } else { s_1471_15 };
        // D s_1471_17: cast trunc s_1471_16 -> u8
        let s_1471_17: bool = ((s_1471_16) != 0);
        // D s_1471_18: cast zx s_1471_17 -> bv
        let s_1471_18: Bits = Bits::new(s_1471_17 as u128, 1u16);
        // C s_1471_19: const #0u : u8
        let s_1471_19: bool = false;
        // C s_1471_20: cast zx s_1471_19 -> bv
        let s_1471_20: Bits = Bits::new(s_1471_19 as u128, 1u16);
        // D s_1471_21: cmp-ne s_1471_18 s_1471_20
        let s_1471_21: bool = ((s_1471_18) != (s_1471_20));
        // D s_1471_22: write-var gs#407619 <= s_1471_21
        fn_state.gs_407619 = s_1471_21;
        // N s_1471_23: jump b1472
        return block_1472(state, tracer, fn_state);
    }
    fn block_1472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1472_0: read-var gs#407619:u8
        let s_1472_0: bool = fn_state.gs_407619;
        // N s_1472_1: branch s_1472_0 b1480 b1473
        if s_1472_0 {
            return block_1480(state, tracer, fn_state);
        } else {
            return block_1473(state, tracer, fn_state);
        };
    }
    fn block_1473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1473_0: const #2s : i
        let s_1473_0: i128 = 2;
        // D s_1473_1: read-var u#33148:u32
        let s_1473_1: u32 = fn_state.u_33148;
        // D s_1473_2: cast zx s_1473_1 -> bv
        let s_1473_2: Bits = Bits::new(s_1473_1 as u128, 32u16);
        // C s_1473_3: const #1u : u64
        let s_1473_3: u64 = 1;
        // D s_1473_4: bit-extract s_1473_2 s_1473_0 s_1473_3
        let s_1473_4: Bits = (Bits::new(
            ((s_1473_2) >> (s_1473_0)).value(),
            u16::try_from(s_1473_3).unwrap(),
        ));
        // D s_1473_5: cast reint s_1473_4 -> u8
        let s_1473_5: bool = ((s_1473_4.value()) != 0);
        // C s_1473_6: const #0s : i
        let s_1473_6: i128 = 0;
        // C s_1473_7: const #0u : u64
        let s_1473_7: u64 = 0;
        // D s_1473_8: cast zx s_1473_5 -> u64
        let s_1473_8: u64 = (s_1473_5 as u64);
        // C s_1473_9: const #1u : u64
        let s_1473_9: u64 = 1;
        // D s_1473_10: and s_1473_8 s_1473_9
        let s_1473_10: u64 = ((s_1473_8) & (s_1473_9));
        // D s_1473_11: cmp-eq s_1473_10 s_1473_9
        let s_1473_11: bool = ((s_1473_10) == (s_1473_9));
        // D s_1473_12: lsl s_1473_8 s_1473_6
        let s_1473_12: u64 = s_1473_8 << s_1473_6;
        // D s_1473_13: or s_1473_7 s_1473_12
        let s_1473_13: u64 = ((s_1473_7) | (s_1473_12));
        // D s_1473_14: cmpl s_1473_12
        let s_1473_14: u64 = !s_1473_12;
        // D s_1473_15: and s_1473_7 s_1473_14
        let s_1473_15: u64 = ((s_1473_7) & (s_1473_14));
        // D s_1473_16: select s_1473_11 s_1473_13 s_1473_15
        let s_1473_16: u64 = if s_1473_11 { s_1473_13 } else { s_1473_15 };
        // D s_1473_17: cast trunc s_1473_16 -> u8
        let s_1473_17: bool = ((s_1473_16) != 0);
        // D s_1473_18: cast zx s_1473_17 -> bv
        let s_1473_18: Bits = Bits::new(s_1473_17 as u128, 1u16);
        // C s_1473_19: const #0u : u8
        let s_1473_19: bool = false;
        // C s_1473_20: cast zx s_1473_19 -> bv
        let s_1473_20: Bits = Bits::new(s_1473_19 as u128, 1u16);
        // D s_1473_21: cmp-ne s_1473_18 s_1473_20
        let s_1473_21: bool = ((s_1473_18) != (s_1473_20));
        // D s_1473_22: write-var gs#407622 <= s_1473_21
        fn_state.gs_407622 = s_1473_21;
        // N s_1473_23: jump b1474
        return block_1474(state, tracer, fn_state);
    }
    fn block_1474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1474_0: read-var gs#407622:u8
        let s_1474_0: bool = fn_state.gs_407622;
        // N s_1474_1: branch s_1474_0 b1479 b1475
        if s_1474_0 {
            return block_1479(state, tracer, fn_state);
        } else {
            return block_1475(state, tracer, fn_state);
        };
    }
    fn block_1475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1475_0: const #3s : i
        let s_1475_0: i128 = 3;
        // D s_1475_1: read-var u#33148:u32
        let s_1475_1: u32 = fn_state.u_33148;
        // D s_1475_2: cast zx s_1475_1 -> bv
        let s_1475_2: Bits = Bits::new(s_1475_1 as u128, 32u16);
        // C s_1475_3: const #1u : u64
        let s_1475_3: u64 = 1;
        // D s_1475_4: bit-extract s_1475_2 s_1475_0 s_1475_3
        let s_1475_4: Bits = (Bits::new(
            ((s_1475_2) >> (s_1475_0)).value(),
            u16::try_from(s_1475_3).unwrap(),
        ));
        // D s_1475_5: cast reint s_1475_4 -> u8
        let s_1475_5: bool = ((s_1475_4.value()) != 0);
        // C s_1475_6: const #0s : i
        let s_1475_6: i128 = 0;
        // C s_1475_7: const #0u : u64
        let s_1475_7: u64 = 0;
        // D s_1475_8: cast zx s_1475_5 -> u64
        let s_1475_8: u64 = (s_1475_5 as u64);
        // C s_1475_9: const #1u : u64
        let s_1475_9: u64 = 1;
        // D s_1475_10: and s_1475_8 s_1475_9
        let s_1475_10: u64 = ((s_1475_8) & (s_1475_9));
        // D s_1475_11: cmp-eq s_1475_10 s_1475_9
        let s_1475_11: bool = ((s_1475_10) == (s_1475_9));
        // D s_1475_12: lsl s_1475_8 s_1475_6
        let s_1475_12: u64 = s_1475_8 << s_1475_6;
        // D s_1475_13: or s_1475_7 s_1475_12
        let s_1475_13: u64 = ((s_1475_7) | (s_1475_12));
        // D s_1475_14: cmpl s_1475_12
        let s_1475_14: u64 = !s_1475_12;
        // D s_1475_15: and s_1475_7 s_1475_14
        let s_1475_15: u64 = ((s_1475_7) & (s_1475_14));
        // D s_1475_16: select s_1475_11 s_1475_13 s_1475_15
        let s_1475_16: u64 = if s_1475_11 { s_1475_13 } else { s_1475_15 };
        // D s_1475_17: cast trunc s_1475_16 -> u8
        let s_1475_17: bool = ((s_1475_16) != 0);
        // D s_1475_18: cast zx s_1475_17 -> bv
        let s_1475_18: Bits = Bits::new(s_1475_17 as u128, 1u16);
        // C s_1475_19: const #0u : u8
        let s_1475_19: bool = false;
        // C s_1475_20: cast zx s_1475_19 -> bv
        let s_1475_20: Bits = Bits::new(s_1475_19 as u128, 1u16);
        // D s_1475_21: cmp-ne s_1475_18 s_1475_20
        let s_1475_21: bool = ((s_1475_18) != (s_1475_20));
        // D s_1475_22: write-var gs#407625 <= s_1475_21
        fn_state.gs_407625 = s_1475_21;
        // N s_1475_23: jump b1476
        return block_1476(state, tracer, fn_state);
    }
    fn block_1476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1476_0: read-var gs#407625:u8
        let s_1476_0: bool = fn_state.gs_407625;
        // N s_1476_1: branch s_1476_0 b1478 b1477
        if s_1476_0 {
            return block_1478(state, tracer, fn_state);
        } else {
            return block_1477(state, tracer, fn_state);
        };
    }
    fn block_1477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1477_0: read-var u#33149:u8
        let s_1477_0: u8 = fn_state.u_33149;
        // D s_1477_1: read-var R:u8
        let s_1477_1: bool = fn_state.R;
        // D s_1477_2: read-var u#33150:u8
        let s_1477_2: u8 = fn_state.u_33150;
        // D s_1477_3: call decode_aarch32_instrs_MRS_A1enc_AS_txt(s_1477_0, s_1477_1, s_1477_2)
        let s_1477_3: () = decode_aarch32_instrs_MRS_A1enc_AS_txt(
            state,
            tracer,
            s_1477_0,
            s_1477_1,
            s_1477_2,
        );
        // N s_1477_4: return
        return;
    }
    fn block_1478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1478_0: panic
        panic!("{:?}", ());
        // N s_1478_1: return
        return;
    }
    fn block_1479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1479_0: const #1u : u8
        let s_1479_0: bool = true;
        // D s_1479_1: write-var gs#407625 <= s_1479_0
        fn_state.gs_407625 = s_1479_0;
        // N s_1479_2: jump b1476
        return block_1476(state, tracer, fn_state);
    }
    fn block_1480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1480_0: const #1u : u8
        let s_1480_0: bool = true;
        // D s_1480_1: write-var gs#407622 <= s_1480_0
        fn_state.gs_407622 = s_1480_0;
        // N s_1480_2: jump b1474
        return block_1474(state, tracer, fn_state);
    }
    fn block_1481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1481_0: const #1u : u8
        let s_1481_0: bool = true;
        // D s_1481_1: write-var gs#407619 <= s_1481_0
        fn_state.gs_407619 = s_1481_0;
        // N s_1481_2: jump b1472
        return block_1472(state, tracer, fn_state);
    }
    fn block_1482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1482_0: const #1u : u8
        let s_1482_0: bool = true;
        // D s_1482_1: write-var gs#407616 <= s_1482_0
        fn_state.gs_407616 = s_1482_0;
        // N s_1482_2: jump b1470
        return block_1470(state, tracer, fn_state);
    }
    fn block_1483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1483_0: const #1u : u8
        let s_1483_0: bool = true;
        // D s_1483_1: write-var gs#407613 <= s_1483_0
        fn_state.gs_407613 = s_1483_0;
        // N s_1483_2: jump b1468
        return block_1468(state, tracer, fn_state);
    }
    fn block_1484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1484_0: const #1u : u8
        let s_1484_0: bool = true;
        // D s_1484_1: write-var gs#407610 <= s_1484_0
        fn_state.gs_407610 = s_1484_0;
        // N s_1484_2: jump b1466
        return block_1466(state, tracer, fn_state);
    }
    fn block_1485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1485_0: const #1u : u8
        let s_1485_0: bool = true;
        // D s_1485_1: write-var gs#407607 <= s_1485_0
        fn_state.gs_407607 = s_1485_0;
        // N s_1485_2: jump b1464
        return block_1464(state, tracer, fn_state);
    }
    fn block_1486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1486_0: const #1u : u8
        let s_1486_0: bool = true;
        // D s_1486_1: write-var gs#407604 <= s_1486_0
        fn_state.gs_407604 = s_1486_0;
        // N s_1486_2: jump b1462
        return block_1462(state, tracer, fn_state);
    }
    fn block_1487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1487_0: const #1u : u8
        let s_1487_0: bool = true;
        // D s_1487_1: write-var gs#407601 <= s_1487_0
        fn_state.gs_407601 = s_1487_0;
        // N s_1487_2: jump b1460
        return block_1460(state, tracer, fn_state);
    }
    fn block_1488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1488_0: const #1u : u8
        let s_1488_0: bool = true;
        // D s_1488_1: write-var gs#407598 <= s_1488_0
        fn_state.gs_407598 = s_1488_0;
        // N s_1488_2: jump b1458
        return block_1458(state, tracer, fn_state);
    }
    fn block_1489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1489_0: read-var merge#var.1:struct
        let s_1489_0: u32 = fn_state.merge_var._1;
        // D s_1489_1: write-var u#33152 <= s_1489_0
        fn_state.u_33152 = s_1489_0;
        // C s_1489_2: const #23s : i
        let s_1489_2: i128 = 23;
        // D s_1489_3: read-var u#33152:u32
        let s_1489_3: u32 = fn_state.u_33152;
        // D s_1489_4: cast zx s_1489_3 -> bv
        let s_1489_4: Bits = Bits::new(s_1489_3 as u128, 32u16);
        // C s_1489_5: const #1s : i64
        let s_1489_5: i64 = 1;
        // C s_1489_6: cast zx s_1489_5 -> i
        let s_1489_6: i128 = (i128::try_from(s_1489_5).unwrap());
        // C s_1489_7: const #4s : i
        let s_1489_7: i128 = 4;
        // C s_1489_8: add s_1489_7 s_1489_6
        let s_1489_8: i128 = (s_1489_7 + s_1489_6);
        // D s_1489_9: bit-extract s_1489_4 s_1489_2 s_1489_8
        let s_1489_9: Bits = (Bits::new(
            ((s_1489_4) >> (s_1489_2)).value(),
            u16::try_from(s_1489_8).unwrap(),
        ));
        // D s_1489_10: cast reint s_1489_9 -> u8
        let s_1489_10: u8 = (s_1489_9.value() as u8);
        // D s_1489_11: cast zx s_1489_10 -> bv
        let s_1489_11: Bits = Bits::new(s_1489_10 as u128, 5u16);
        // C s_1489_12: const #2u : u8
        let s_1489_12: u8 = 2;
        // C s_1489_13: cast zx s_1489_12 -> bv
        let s_1489_13: Bits = Bits::new(s_1489_12 as u128, 5u16);
        // D s_1489_14: cmp-eq s_1489_11 s_1489_13
        let s_1489_14: bool = ((s_1489_11) == (s_1489_13));
        // N s_1489_15: branch s_1489_14 b2188 b1490
        if s_1489_14 {
            return block_2188(state, tracer, fn_state);
        } else {
            return block_1490(state, tracer, fn_state);
        };
    }
    fn block_1490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1490_0: const #0u : u8
        let s_1490_0: bool = false;
        // D s_1490_1: write-var gs#407637 <= s_1490_0
        fn_state.gs_407637 = s_1490_0;
        // N s_1490_2: jump b1491
        return block_1491(state, tracer, fn_state);
    }
    fn block_1491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1491_0: read-var gs#407637:u8
        let s_1491_0: bool = fn_state.gs_407637;
        // N s_1491_1: branch s_1491_0 b2184 b1492
        if s_1491_0 {
            return block_2184(state, tracer, fn_state);
        } else {
            return block_1492(state, tracer, fn_state);
        };
    }
    fn block_1492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1492_0: const #0u : u8
        let s_1492_0: bool = false;
        // D s_1492_1: write-var gs#407642 <= s_1492_0
        fn_state.gs_407642 = s_1492_0;
        // N s_1492_2: jump b1493
        return block_1493(state, tracer, fn_state);
    }
    fn block_1493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1493_0: read-var gs#407642:u8
        let s_1493_0: bool = fn_state.gs_407642;
        // D s_1493_1: not s_1493_0
        let s_1493_1: bool = !s_1493_0;
        // N s_1493_2: branch s_1493_1 b1512 b1494
        if s_1493_1 {
            return block_1512(state, tracer, fn_state);
        } else {
            return block_1494(state, tracer, fn_state);
        };
    }
    fn block_1494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1494_0: const #3780s : i
        let s_1494_0: i128 = 3780;
        // C s_1494_1: const #14696u : u32
        let s_1494_1: u32 = 14696;
        // N s_1494_2: write-reg s_1494_1 <= s_1494_0
        let s_1494_2: () = {
            state.write_register::<i128>(s_1494_1 as isize, s_1494_0);
            tracer.write_register(s_1494_1 as isize, s_1494_0);
        };
        // C s_1494_3: const #28s : i
        let s_1494_3: i128 = 28;
        // C s_1494_4: const #4s : i
        let s_1494_4: i128 = 4;
        // D s_1494_5: read-var u#33152:u32
        let s_1494_5: u32 = fn_state.u_33152;
        // D s_1494_6: cast zx s_1494_5 -> bv
        let s_1494_6: Bits = Bits::new(s_1494_5 as u128, 32u16);
        // D s_1494_7: bit-extract s_1494_6 s_1494_3 s_1494_4
        let s_1494_7: Bits = (Bits::new(
            ((s_1494_6) >> (s_1494_3)).value(),
            u16::try_from(s_1494_4).unwrap(),
        ));
        // D s_1494_8: cast reint s_1494_7 -> u8
        let s_1494_8: u8 = (s_1494_7.value() as u8);
        // D s_1494_9: write-var u#33153 <= s_1494_8
        fn_state.u_33153 = s_1494_8;
        // C s_1494_10: const #22s : i
        let s_1494_10: i128 = 22;
        // C s_1494_11: const #1s : i
        let s_1494_11: i128 = 1;
        // D s_1494_12: read-var u#33152:u32
        let s_1494_12: u32 = fn_state.u_33152;
        // D s_1494_13: cast zx s_1494_12 -> bv
        let s_1494_13: Bits = Bits::new(s_1494_12 as u128, 32u16);
        // D s_1494_14: bit-extract s_1494_13 s_1494_10 s_1494_11
        let s_1494_14: Bits = (Bits::new(
            ((s_1494_13) >> (s_1494_10)).value(),
            u16::try_from(s_1494_11).unwrap(),
        ));
        // D s_1494_15: cast reint s_1494_14 -> u8
        let s_1494_15: bool = ((s_1494_14.value()) != 0);
        // D s_1494_16: write-var u#33154 <= s_1494_15
        fn_state.u_33154 = s_1494_15;
        // C s_1494_17: const #16s : i
        let s_1494_17: i128 = 16;
        // C s_1494_18: const #4s : i
        let s_1494_18: i128 = 4;
        // D s_1494_19: read-var u#33152:u32
        let s_1494_19: u32 = fn_state.u_33152;
        // D s_1494_20: cast zx s_1494_19 -> bv
        let s_1494_20: Bits = Bits::new(s_1494_19 as u128, 32u16);
        // D s_1494_21: bit-extract s_1494_20 s_1494_17 s_1494_18
        let s_1494_21: Bits = (Bits::new(
            ((s_1494_20) >> (s_1494_17)).value(),
            u16::try_from(s_1494_18).unwrap(),
        ));
        // D s_1494_22: cast reint s_1494_21 -> u8
        let s_1494_22: u8 = (s_1494_21.value() as u8);
        // D s_1494_23: write-var M1 <= s_1494_22
        fn_state.M1 = s_1494_22;
        // C s_1494_24: const #12s : i
        let s_1494_24: i128 = 12;
        // C s_1494_25: const #4s : i
        let s_1494_25: i128 = 4;
        // D s_1494_26: read-var u#33152:u32
        let s_1494_26: u32 = fn_state.u_33152;
        // D s_1494_27: cast zx s_1494_26 -> bv
        let s_1494_27: Bits = Bits::new(s_1494_26 as u128, 32u16);
        // D s_1494_28: bit-extract s_1494_27 s_1494_24 s_1494_25
        let s_1494_28: Bits = (Bits::new(
            ((s_1494_27) >> (s_1494_24)).value(),
            u16::try_from(s_1494_25).unwrap(),
        ));
        // D s_1494_29: cast reint s_1494_28 -> u8
        let s_1494_29: u8 = (s_1494_28.value() as u8);
        // D s_1494_30: write-var u#33155 <= s_1494_29
        fn_state.u_33155 = s_1494_29;
        // C s_1494_31: const #8s : i
        let s_1494_31: i128 = 8;
        // C s_1494_32: const #1s : i
        let s_1494_32: i128 = 1;
        // D s_1494_33: read-var u#33152:u32
        let s_1494_33: u32 = fn_state.u_33152;
        // D s_1494_34: cast zx s_1494_33 -> bv
        let s_1494_34: Bits = Bits::new(s_1494_33 as u128, 32u16);
        // D s_1494_35: bit-extract s_1494_34 s_1494_31 s_1494_32
        let s_1494_35: Bits = (Bits::new(
            ((s_1494_34) >> (s_1494_31)).value(),
            u16::try_from(s_1494_32).unwrap(),
        ));
        // D s_1494_36: cast reint s_1494_35 -> u8
        let s_1494_36: bool = ((s_1494_35.value()) != 0);
        // D s_1494_37: write-var u#33156 <= s_1494_36
        fn_state.u_33156 = s_1494_36;
        // C s_1494_38: const #10s : i
        let s_1494_38: i128 = 10;
        // D s_1494_39: read-var u#33152:u32
        let s_1494_39: u32 = fn_state.u_33152;
        // D s_1494_40: cast zx s_1494_39 -> bv
        let s_1494_40: Bits = Bits::new(s_1494_39 as u128, 32u16);
        // C s_1494_41: const #1u : u64
        let s_1494_41: u64 = 1;
        // D s_1494_42: bit-extract s_1494_40 s_1494_38 s_1494_41
        let s_1494_42: Bits = (Bits::new(
            ((s_1494_40) >> (s_1494_38)).value(),
            u16::try_from(s_1494_41).unwrap(),
        ));
        // D s_1494_43: cast reint s_1494_42 -> u8
        let s_1494_43: bool = ((s_1494_42.value()) != 0);
        // C s_1494_44: const #0s : i
        let s_1494_44: i128 = 0;
        // C s_1494_45: const #0u : u64
        let s_1494_45: u64 = 0;
        // D s_1494_46: cast zx s_1494_43 -> u64
        let s_1494_46: u64 = (s_1494_43 as u64);
        // C s_1494_47: const #1u : u64
        let s_1494_47: u64 = 1;
        // D s_1494_48: and s_1494_46 s_1494_47
        let s_1494_48: u64 = ((s_1494_46) & (s_1494_47));
        // D s_1494_49: cmp-eq s_1494_48 s_1494_47
        let s_1494_49: bool = ((s_1494_48) == (s_1494_47));
        // D s_1494_50: lsl s_1494_46 s_1494_44
        let s_1494_50: u64 = s_1494_46 << s_1494_44;
        // D s_1494_51: or s_1494_45 s_1494_50
        let s_1494_51: u64 = ((s_1494_45) | (s_1494_50));
        // D s_1494_52: cmpl s_1494_50
        let s_1494_52: u64 = !s_1494_50;
        // D s_1494_53: and s_1494_45 s_1494_52
        let s_1494_53: u64 = ((s_1494_45) & (s_1494_52));
        // D s_1494_54: select s_1494_49 s_1494_51 s_1494_53
        let s_1494_54: u64 = if s_1494_49 { s_1494_51 } else { s_1494_53 };
        // D s_1494_55: cast trunc s_1494_54 -> u8
        let s_1494_55: bool = ((s_1494_54) != 0);
        // D s_1494_56: cast zx s_1494_55 -> bv
        let s_1494_56: Bits = Bits::new(s_1494_55 as u128, 1u16);
        // C s_1494_57: const #0u : u8
        let s_1494_57: bool = false;
        // C s_1494_58: cast zx s_1494_57 -> bv
        let s_1494_58: Bits = Bits::new(s_1494_57 as u128, 1u16);
        // D s_1494_59: cmp-ne s_1494_56 s_1494_58
        let s_1494_59: bool = ((s_1494_56) != (s_1494_58));
        // N s_1494_60: branch s_1494_59 b1511 b1495
        if s_1494_59 {
            return block_1511(state, tracer, fn_state);
        } else {
            return block_1495(state, tracer, fn_state);
        };
    }
    fn block_1495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1495_0: const #11s : i
        let s_1495_0: i128 = 11;
        // D s_1495_1: read-var u#33152:u32
        let s_1495_1: u32 = fn_state.u_33152;
        // D s_1495_2: cast zx s_1495_1 -> bv
        let s_1495_2: Bits = Bits::new(s_1495_1 as u128, 32u16);
        // C s_1495_3: const #1u : u64
        let s_1495_3: u64 = 1;
        // D s_1495_4: bit-extract s_1495_2 s_1495_0 s_1495_3
        let s_1495_4: Bits = (Bits::new(
            ((s_1495_2) >> (s_1495_0)).value(),
            u16::try_from(s_1495_3).unwrap(),
        ));
        // D s_1495_5: cast reint s_1495_4 -> u8
        let s_1495_5: bool = ((s_1495_4.value()) != 0);
        // C s_1495_6: const #0s : i
        let s_1495_6: i128 = 0;
        // C s_1495_7: const #0u : u64
        let s_1495_7: u64 = 0;
        // D s_1495_8: cast zx s_1495_5 -> u64
        let s_1495_8: u64 = (s_1495_5 as u64);
        // C s_1495_9: const #1u : u64
        let s_1495_9: u64 = 1;
        // D s_1495_10: and s_1495_8 s_1495_9
        let s_1495_10: u64 = ((s_1495_8) & (s_1495_9));
        // D s_1495_11: cmp-eq s_1495_10 s_1495_9
        let s_1495_11: bool = ((s_1495_10) == (s_1495_9));
        // D s_1495_12: lsl s_1495_8 s_1495_6
        let s_1495_12: u64 = s_1495_8 << s_1495_6;
        // D s_1495_13: or s_1495_7 s_1495_12
        let s_1495_13: u64 = ((s_1495_7) | (s_1495_12));
        // D s_1495_14: cmpl s_1495_12
        let s_1495_14: u64 = !s_1495_12;
        // D s_1495_15: and s_1495_7 s_1495_14
        let s_1495_15: u64 = ((s_1495_7) & (s_1495_14));
        // D s_1495_16: select s_1495_11 s_1495_13 s_1495_15
        let s_1495_16: u64 = if s_1495_11 { s_1495_13 } else { s_1495_15 };
        // D s_1495_17: cast trunc s_1495_16 -> u8
        let s_1495_17: bool = ((s_1495_16) != 0);
        // D s_1495_18: cast zx s_1495_17 -> bv
        let s_1495_18: Bits = Bits::new(s_1495_17 as u128, 1u16);
        // C s_1495_19: const #0u : u8
        let s_1495_19: bool = false;
        // C s_1495_20: cast zx s_1495_19 -> bv
        let s_1495_20: Bits = Bits::new(s_1495_19 as u128, 1u16);
        // D s_1495_21: cmp-ne s_1495_18 s_1495_20
        let s_1495_21: bool = ((s_1495_18) != (s_1495_20));
        // D s_1495_22: write-var gs#407659 <= s_1495_21
        fn_state.gs_407659 = s_1495_21;
        // N s_1495_23: jump b1496
        return block_1496(state, tracer, fn_state);
    }
    fn block_1496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1496_0: read-var gs#407659:u8
        let s_1496_0: bool = fn_state.gs_407659;
        // N s_1496_1: branch s_1496_0 b1510 b1497
        if s_1496_0 {
            return block_1510(state, tracer, fn_state);
        } else {
            return block_1497(state, tracer, fn_state);
        };
    }
    fn block_1497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1497_0: const #0s : i
        let s_1497_0: i128 = 0;
        // D s_1497_1: read-var u#33152:u32
        let s_1497_1: u32 = fn_state.u_33152;
        // D s_1497_2: cast zx s_1497_1 -> bv
        let s_1497_2: Bits = Bits::new(s_1497_1 as u128, 32u16);
        // C s_1497_3: const #1u : u64
        let s_1497_3: u64 = 1;
        // D s_1497_4: bit-extract s_1497_2 s_1497_0 s_1497_3
        let s_1497_4: Bits = (Bits::new(
            ((s_1497_2) >> (s_1497_0)).value(),
            u16::try_from(s_1497_3).unwrap(),
        ));
        // D s_1497_5: cast reint s_1497_4 -> u8
        let s_1497_5: bool = ((s_1497_4.value()) != 0);
        // C s_1497_6: const #0s : i
        let s_1497_6: i128 = 0;
        // C s_1497_7: const #0u : u64
        let s_1497_7: u64 = 0;
        // D s_1497_8: cast zx s_1497_5 -> u64
        let s_1497_8: u64 = (s_1497_5 as u64);
        // C s_1497_9: const #1u : u64
        let s_1497_9: u64 = 1;
        // D s_1497_10: and s_1497_8 s_1497_9
        let s_1497_10: u64 = ((s_1497_8) & (s_1497_9));
        // D s_1497_11: cmp-eq s_1497_10 s_1497_9
        let s_1497_11: bool = ((s_1497_10) == (s_1497_9));
        // D s_1497_12: lsl s_1497_8 s_1497_6
        let s_1497_12: u64 = s_1497_8 << s_1497_6;
        // D s_1497_13: or s_1497_7 s_1497_12
        let s_1497_13: u64 = ((s_1497_7) | (s_1497_12));
        // D s_1497_14: cmpl s_1497_12
        let s_1497_14: u64 = !s_1497_12;
        // D s_1497_15: and s_1497_7 s_1497_14
        let s_1497_15: u64 = ((s_1497_7) & (s_1497_14));
        // D s_1497_16: select s_1497_11 s_1497_13 s_1497_15
        let s_1497_16: u64 = if s_1497_11 { s_1497_13 } else { s_1497_15 };
        // D s_1497_17: cast trunc s_1497_16 -> u8
        let s_1497_17: bool = ((s_1497_16) != 0);
        // D s_1497_18: cast zx s_1497_17 -> bv
        let s_1497_18: Bits = Bits::new(s_1497_17 as u128, 1u16);
        // C s_1497_19: const #0u : u8
        let s_1497_19: bool = false;
        // C s_1497_20: cast zx s_1497_19 -> bv
        let s_1497_20: Bits = Bits::new(s_1497_19 as u128, 1u16);
        // D s_1497_21: cmp-ne s_1497_18 s_1497_20
        let s_1497_21: bool = ((s_1497_18) != (s_1497_20));
        // D s_1497_22: write-var gs#407662 <= s_1497_21
        fn_state.gs_407662 = s_1497_21;
        // N s_1497_23: jump b1498
        return block_1498(state, tracer, fn_state);
    }
    fn block_1498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1498_0: read-var gs#407662:u8
        let s_1498_0: bool = fn_state.gs_407662;
        // N s_1498_1: branch s_1498_0 b1509 b1499
        if s_1498_0 {
            return block_1509(state, tracer, fn_state);
        } else {
            return block_1499(state, tracer, fn_state);
        };
    }
    fn block_1499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1499_0: const #1s : i
        let s_1499_0: i128 = 1;
        // D s_1499_1: read-var u#33152:u32
        let s_1499_1: u32 = fn_state.u_33152;
        // D s_1499_2: cast zx s_1499_1 -> bv
        let s_1499_2: Bits = Bits::new(s_1499_1 as u128, 32u16);
        // C s_1499_3: const #1u : u64
        let s_1499_3: u64 = 1;
        // D s_1499_4: bit-extract s_1499_2 s_1499_0 s_1499_3
        let s_1499_4: Bits = (Bits::new(
            ((s_1499_2) >> (s_1499_0)).value(),
            u16::try_from(s_1499_3).unwrap(),
        ));
        // D s_1499_5: cast reint s_1499_4 -> u8
        let s_1499_5: bool = ((s_1499_4.value()) != 0);
        // C s_1499_6: const #0s : i
        let s_1499_6: i128 = 0;
        // C s_1499_7: const #0u : u64
        let s_1499_7: u64 = 0;
        // D s_1499_8: cast zx s_1499_5 -> u64
        let s_1499_8: u64 = (s_1499_5 as u64);
        // C s_1499_9: const #1u : u64
        let s_1499_9: u64 = 1;
        // D s_1499_10: and s_1499_8 s_1499_9
        let s_1499_10: u64 = ((s_1499_8) & (s_1499_9));
        // D s_1499_11: cmp-eq s_1499_10 s_1499_9
        let s_1499_11: bool = ((s_1499_10) == (s_1499_9));
        // D s_1499_12: lsl s_1499_8 s_1499_6
        let s_1499_12: u64 = s_1499_8 << s_1499_6;
        // D s_1499_13: or s_1499_7 s_1499_12
        let s_1499_13: u64 = ((s_1499_7) | (s_1499_12));
        // D s_1499_14: cmpl s_1499_12
        let s_1499_14: u64 = !s_1499_12;
        // D s_1499_15: and s_1499_7 s_1499_14
        let s_1499_15: u64 = ((s_1499_7) & (s_1499_14));
        // D s_1499_16: select s_1499_11 s_1499_13 s_1499_15
        let s_1499_16: u64 = if s_1499_11 { s_1499_13 } else { s_1499_15 };
        // D s_1499_17: cast trunc s_1499_16 -> u8
        let s_1499_17: bool = ((s_1499_16) != 0);
        // D s_1499_18: cast zx s_1499_17 -> bv
        let s_1499_18: Bits = Bits::new(s_1499_17 as u128, 1u16);
        // C s_1499_19: const #0u : u8
        let s_1499_19: bool = false;
        // C s_1499_20: cast zx s_1499_19 -> bv
        let s_1499_20: Bits = Bits::new(s_1499_19 as u128, 1u16);
        // D s_1499_21: cmp-ne s_1499_18 s_1499_20
        let s_1499_21: bool = ((s_1499_18) != (s_1499_20));
        // D s_1499_22: write-var gs#407665 <= s_1499_21
        fn_state.gs_407665 = s_1499_21;
        // N s_1499_23: jump b1500
        return block_1500(state, tracer, fn_state);
    }
    fn block_1500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1500_0: read-var gs#407665:u8
        let s_1500_0: bool = fn_state.gs_407665;
        // N s_1500_1: branch s_1500_0 b1508 b1501
        if s_1500_0 {
            return block_1508(state, tracer, fn_state);
        } else {
            return block_1501(state, tracer, fn_state);
        };
    }
    fn block_1501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1501_0: const #2s : i
        let s_1501_0: i128 = 2;
        // D s_1501_1: read-var u#33152:u32
        let s_1501_1: u32 = fn_state.u_33152;
        // D s_1501_2: cast zx s_1501_1 -> bv
        let s_1501_2: Bits = Bits::new(s_1501_1 as u128, 32u16);
        // C s_1501_3: const #1u : u64
        let s_1501_3: u64 = 1;
        // D s_1501_4: bit-extract s_1501_2 s_1501_0 s_1501_3
        let s_1501_4: Bits = (Bits::new(
            ((s_1501_2) >> (s_1501_0)).value(),
            u16::try_from(s_1501_3).unwrap(),
        ));
        // D s_1501_5: cast reint s_1501_4 -> u8
        let s_1501_5: bool = ((s_1501_4.value()) != 0);
        // C s_1501_6: const #0s : i
        let s_1501_6: i128 = 0;
        // C s_1501_7: const #0u : u64
        let s_1501_7: u64 = 0;
        // D s_1501_8: cast zx s_1501_5 -> u64
        let s_1501_8: u64 = (s_1501_5 as u64);
        // C s_1501_9: const #1u : u64
        let s_1501_9: u64 = 1;
        // D s_1501_10: and s_1501_8 s_1501_9
        let s_1501_10: u64 = ((s_1501_8) & (s_1501_9));
        // D s_1501_11: cmp-eq s_1501_10 s_1501_9
        let s_1501_11: bool = ((s_1501_10) == (s_1501_9));
        // D s_1501_12: lsl s_1501_8 s_1501_6
        let s_1501_12: u64 = s_1501_8 << s_1501_6;
        // D s_1501_13: or s_1501_7 s_1501_12
        let s_1501_13: u64 = ((s_1501_7) | (s_1501_12));
        // D s_1501_14: cmpl s_1501_12
        let s_1501_14: u64 = !s_1501_12;
        // D s_1501_15: and s_1501_7 s_1501_14
        let s_1501_15: u64 = ((s_1501_7) & (s_1501_14));
        // D s_1501_16: select s_1501_11 s_1501_13 s_1501_15
        let s_1501_16: u64 = if s_1501_11 { s_1501_13 } else { s_1501_15 };
        // D s_1501_17: cast trunc s_1501_16 -> u8
        let s_1501_17: bool = ((s_1501_16) != 0);
        // D s_1501_18: cast zx s_1501_17 -> bv
        let s_1501_18: Bits = Bits::new(s_1501_17 as u128, 1u16);
        // C s_1501_19: const #0u : u8
        let s_1501_19: bool = false;
        // C s_1501_20: cast zx s_1501_19 -> bv
        let s_1501_20: Bits = Bits::new(s_1501_19 as u128, 1u16);
        // D s_1501_21: cmp-ne s_1501_18 s_1501_20
        let s_1501_21: bool = ((s_1501_18) != (s_1501_20));
        // D s_1501_22: write-var gs#407668 <= s_1501_21
        fn_state.gs_407668 = s_1501_21;
        // N s_1501_23: jump b1502
        return block_1502(state, tracer, fn_state);
    }
    fn block_1502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1502_0: read-var gs#407668:u8
        let s_1502_0: bool = fn_state.gs_407668;
        // N s_1502_1: branch s_1502_0 b1507 b1503
        if s_1502_0 {
            return block_1507(state, tracer, fn_state);
        } else {
            return block_1503(state, tracer, fn_state);
        };
    }
    fn block_1503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1503_0: const #3s : i
        let s_1503_0: i128 = 3;
        // D s_1503_1: read-var u#33152:u32
        let s_1503_1: u32 = fn_state.u_33152;
        // D s_1503_2: cast zx s_1503_1 -> bv
        let s_1503_2: Bits = Bits::new(s_1503_1 as u128, 32u16);
        // C s_1503_3: const #1u : u64
        let s_1503_3: u64 = 1;
        // D s_1503_4: bit-extract s_1503_2 s_1503_0 s_1503_3
        let s_1503_4: Bits = (Bits::new(
            ((s_1503_2) >> (s_1503_0)).value(),
            u16::try_from(s_1503_3).unwrap(),
        ));
        // D s_1503_5: cast reint s_1503_4 -> u8
        let s_1503_5: bool = ((s_1503_4.value()) != 0);
        // C s_1503_6: const #0s : i
        let s_1503_6: i128 = 0;
        // C s_1503_7: const #0u : u64
        let s_1503_7: u64 = 0;
        // D s_1503_8: cast zx s_1503_5 -> u64
        let s_1503_8: u64 = (s_1503_5 as u64);
        // C s_1503_9: const #1u : u64
        let s_1503_9: u64 = 1;
        // D s_1503_10: and s_1503_8 s_1503_9
        let s_1503_10: u64 = ((s_1503_8) & (s_1503_9));
        // D s_1503_11: cmp-eq s_1503_10 s_1503_9
        let s_1503_11: bool = ((s_1503_10) == (s_1503_9));
        // D s_1503_12: lsl s_1503_8 s_1503_6
        let s_1503_12: u64 = s_1503_8 << s_1503_6;
        // D s_1503_13: or s_1503_7 s_1503_12
        let s_1503_13: u64 = ((s_1503_7) | (s_1503_12));
        // D s_1503_14: cmpl s_1503_12
        let s_1503_14: u64 = !s_1503_12;
        // D s_1503_15: and s_1503_7 s_1503_14
        let s_1503_15: u64 = ((s_1503_7) & (s_1503_14));
        // D s_1503_16: select s_1503_11 s_1503_13 s_1503_15
        let s_1503_16: u64 = if s_1503_11 { s_1503_13 } else { s_1503_15 };
        // D s_1503_17: cast trunc s_1503_16 -> u8
        let s_1503_17: bool = ((s_1503_16) != 0);
        // D s_1503_18: cast zx s_1503_17 -> bv
        let s_1503_18: Bits = Bits::new(s_1503_17 as u128, 1u16);
        // C s_1503_19: const #0u : u8
        let s_1503_19: bool = false;
        // C s_1503_20: cast zx s_1503_19 -> bv
        let s_1503_20: Bits = Bits::new(s_1503_19 as u128, 1u16);
        // D s_1503_21: cmp-ne s_1503_18 s_1503_20
        let s_1503_21: bool = ((s_1503_18) != (s_1503_20));
        // D s_1503_22: write-var gs#407671 <= s_1503_21
        fn_state.gs_407671 = s_1503_21;
        // N s_1503_23: jump b1504
        return block_1504(state, tracer, fn_state);
    }
    fn block_1504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1504_0: read-var gs#407671:u8
        let s_1504_0: bool = fn_state.gs_407671;
        // N s_1504_1: branch s_1504_0 b1506 b1505
        if s_1504_0 {
            return block_1506(state, tracer, fn_state);
        } else {
            return block_1505(state, tracer, fn_state);
        };
    }
    fn block_1505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1505_0: read-var u#33153:u8
        let s_1505_0: u8 = fn_state.u_33153;
        // D s_1505_1: read-var u#33154:u8
        let s_1505_1: bool = fn_state.u_33154;
        // D s_1505_2: read-var M1:u8
        let s_1505_2: u8 = fn_state.M1;
        // D s_1505_3: read-var u#33155:u8
        let s_1505_3: u8 = fn_state.u_33155;
        // D s_1505_4: read-var u#33156:u8
        let s_1505_4: bool = fn_state.u_33156;
        // D s_1505_5: call decode_aarch32_instrs_MRS_br_A1enc_AS_txt(s_1505_0, s_1505_1, s_1505_2, s_1505_3, s_1505_4)
        let s_1505_5: () = decode_aarch32_instrs_MRS_br_A1enc_AS_txt(
            state,
            tracer,
            s_1505_0,
            s_1505_1,
            s_1505_2,
            s_1505_3,
            s_1505_4,
        );
        // N s_1505_6: return
        return;
    }
    fn block_1506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1506_0: panic
        panic!("{:?}", ());
        // N s_1506_1: return
        return;
    }
    fn block_1507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1507_0: const #1u : u8
        let s_1507_0: bool = true;
        // D s_1507_1: write-var gs#407671 <= s_1507_0
        fn_state.gs_407671 = s_1507_0;
        // N s_1507_2: jump b1504
        return block_1504(state, tracer, fn_state);
    }
    fn block_1508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1508_0: const #1u : u8
        let s_1508_0: bool = true;
        // D s_1508_1: write-var gs#407668 <= s_1508_0
        fn_state.gs_407668 = s_1508_0;
        // N s_1508_2: jump b1502
        return block_1502(state, tracer, fn_state);
    }
    fn block_1509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1509_0: const #1u : u8
        let s_1509_0: bool = true;
        // D s_1509_1: write-var gs#407665 <= s_1509_0
        fn_state.gs_407665 = s_1509_0;
        // N s_1509_2: jump b1500
        return block_1500(state, tracer, fn_state);
    }
    fn block_1510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1510_0: const #1u : u8
        let s_1510_0: bool = true;
        // D s_1510_1: write-var gs#407662 <= s_1510_0
        fn_state.gs_407662 = s_1510_0;
        // N s_1510_2: jump b1498
        return block_1498(state, tracer, fn_state);
    }
    fn block_1511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1511_0: const #1u : u8
        let s_1511_0: bool = true;
        // D s_1511_1: write-var gs#407659 <= s_1511_0
        fn_state.gs_407659 = s_1511_0;
        // N s_1511_2: jump b1496
        return block_1496(state, tracer, fn_state);
    }
    fn block_1512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1512_0: read-var merge#var.1:struct
        let s_1512_0: u32 = fn_state.merge_var._1;
        // D s_1512_1: write-var u#33158 <= s_1512_0
        fn_state.u_33158 = s_1512_0;
        // C s_1512_2: const #23s : i
        let s_1512_2: i128 = 23;
        // D s_1512_3: read-var u#33158:u32
        let s_1512_3: u32 = fn_state.u_33158;
        // D s_1512_4: cast zx s_1512_3 -> bv
        let s_1512_4: Bits = Bits::new(s_1512_3 as u128, 32u16);
        // C s_1512_5: const #1s : i64
        let s_1512_5: i64 = 1;
        // C s_1512_6: cast zx s_1512_5 -> i
        let s_1512_6: i128 = (i128::try_from(s_1512_5).unwrap());
        // C s_1512_7: const #4s : i
        let s_1512_7: i128 = 4;
        // C s_1512_8: add s_1512_7 s_1512_6
        let s_1512_8: i128 = (s_1512_7 + s_1512_6);
        // D s_1512_9: bit-extract s_1512_4 s_1512_2 s_1512_8
        let s_1512_9: Bits = (Bits::new(
            ((s_1512_4) >> (s_1512_2)).value(),
            u16::try_from(s_1512_8).unwrap(),
        ));
        // D s_1512_10: cast reint s_1512_9 -> u8
        let s_1512_10: u8 = (s_1512_9.value() as u8);
        // D s_1512_11: cast zx s_1512_10 -> bv
        let s_1512_11: Bits = Bits::new(s_1512_10 as u128, 5u16);
        // C s_1512_12: const #2u : u8
        let s_1512_12: u8 = 2;
        // C s_1512_13: cast zx s_1512_12 -> bv
        let s_1512_13: Bits = Bits::new(s_1512_12 as u128, 5u16);
        // D s_1512_14: cmp-eq s_1512_11 s_1512_13
        let s_1512_14: bool = ((s_1512_11) == (s_1512_13));
        // N s_1512_15: branch s_1512_14 b2177 b1513
        if s_1512_14 {
            return block_2177(state, tracer, fn_state);
        } else {
            return block_1513(state, tracer, fn_state);
        };
    }
    fn block_1513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1513_0: const #0u : u8
        let s_1513_0: bool = false;
        // D s_1513_1: write-var gs#407683 <= s_1513_0
        fn_state.gs_407683 = s_1513_0;
        // N s_1513_2: jump b1514
        return block_1514(state, tracer, fn_state);
    }
    fn block_1514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1514_0: read-var gs#407683:u8
        let s_1514_0: bool = fn_state.gs_407683;
        // N s_1514_1: branch s_1514_0 b2173 b1515
        if s_1514_0 {
            return block_2173(state, tracer, fn_state);
        } else {
            return block_1515(state, tracer, fn_state);
        };
    }
    fn block_1515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1515_0: const #0u : u8
        let s_1515_0: bool = false;
        // D s_1515_1: write-var gs#407688 <= s_1515_0
        fn_state.gs_407688 = s_1515_0;
        // N s_1515_2: jump b1516
        return block_1516(state, tracer, fn_state);
    }
    fn block_1516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1516_0: read-var gs#407688:u8
        let s_1516_0: bool = fn_state.gs_407688;
        // D s_1516_1: not s_1516_0
        let s_1516_1: bool = !s_1516_0;
        // N s_1516_2: branch s_1516_1 b1535 b1517
        if s_1516_1 {
            return block_1535(state, tracer, fn_state);
        } else {
            return block_1517(state, tracer, fn_state);
        };
    }
    fn block_1517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1517_0: const #3782s : i
        let s_1517_0: i128 = 3782;
        // C s_1517_1: const #14696u : u32
        let s_1517_1: u32 = 14696;
        // N s_1517_2: write-reg s_1517_1 <= s_1517_0
        let s_1517_2: () = {
            state.write_register::<i128>(s_1517_1 as isize, s_1517_0);
            tracer.write_register(s_1517_1 as isize, s_1517_0);
        };
        // C s_1517_3: const #28s : i
        let s_1517_3: i128 = 28;
        // C s_1517_4: const #4s : i
        let s_1517_4: i128 = 4;
        // D s_1517_5: read-var u#33158:u32
        let s_1517_5: u32 = fn_state.u_33158;
        // D s_1517_6: cast zx s_1517_5 -> bv
        let s_1517_6: Bits = Bits::new(s_1517_5 as u128, 32u16);
        // D s_1517_7: bit-extract s_1517_6 s_1517_3 s_1517_4
        let s_1517_7: Bits = (Bits::new(
            ((s_1517_6) >> (s_1517_3)).value(),
            u16::try_from(s_1517_4).unwrap(),
        ));
        // D s_1517_8: cast reint s_1517_7 -> u8
        let s_1517_8: u8 = (s_1517_7.value() as u8);
        // D s_1517_9: write-var u#33159 <= s_1517_8
        fn_state.u_33159 = s_1517_8;
        // C s_1517_10: const #22s : i
        let s_1517_10: i128 = 22;
        // C s_1517_11: const #1s : i
        let s_1517_11: i128 = 1;
        // D s_1517_12: read-var u#33158:u32
        let s_1517_12: u32 = fn_state.u_33158;
        // D s_1517_13: cast zx s_1517_12 -> bv
        let s_1517_13: Bits = Bits::new(s_1517_12 as u128, 32u16);
        // D s_1517_14: bit-extract s_1517_13 s_1517_10 s_1517_11
        let s_1517_14: Bits = (Bits::new(
            ((s_1517_13) >> (s_1517_10)).value(),
            u16::try_from(s_1517_11).unwrap(),
        ));
        // D s_1517_15: cast reint s_1517_14 -> u8
        let s_1517_15: bool = ((s_1517_14.value()) != 0);
        // D s_1517_16: write-var u#33160 <= s_1517_15
        fn_state.u_33160 = s_1517_15;
        // C s_1517_17: const #16s : i
        let s_1517_17: i128 = 16;
        // C s_1517_18: const #4s : i
        let s_1517_18: i128 = 4;
        // D s_1517_19: read-var u#33158:u32
        let s_1517_19: u32 = fn_state.u_33158;
        // D s_1517_20: cast zx s_1517_19 -> bv
        let s_1517_20: Bits = Bits::new(s_1517_19 as u128, 32u16);
        // D s_1517_21: bit-extract s_1517_20 s_1517_17 s_1517_18
        let s_1517_21: Bits = (Bits::new(
            ((s_1517_20) >> (s_1517_17)).value(),
            u16::try_from(s_1517_18).unwrap(),
        ));
        // D s_1517_22: cast reint s_1517_21 -> u8
        let s_1517_22: u8 = (s_1517_21.value() as u8);
        // D s_1517_23: write-var u#33161 <= s_1517_22
        fn_state.u_33161 = s_1517_22;
        // C s_1517_24: const #8s : i
        let s_1517_24: i128 = 8;
        // C s_1517_25: const #1s : i
        let s_1517_25: i128 = 1;
        // D s_1517_26: read-var u#33158:u32
        let s_1517_26: u32 = fn_state.u_33158;
        // D s_1517_27: cast zx s_1517_26 -> bv
        let s_1517_27: Bits = Bits::new(s_1517_26 as u128, 32u16);
        // D s_1517_28: bit-extract s_1517_27 s_1517_24 s_1517_25
        let s_1517_28: Bits = (Bits::new(
            ((s_1517_27) >> (s_1517_24)).value(),
            u16::try_from(s_1517_25).unwrap(),
        ));
        // D s_1517_29: cast reint s_1517_28 -> u8
        let s_1517_29: bool = ((s_1517_28.value()) != 0);
        // D s_1517_30: write-var u#33162 <= s_1517_29
        fn_state.u_33162 = s_1517_29;
        // C s_1517_31: const #0s : i
        let s_1517_31: i128 = 0;
        // C s_1517_32: const #4s : i
        let s_1517_32: i128 = 4;
        // D s_1517_33: read-var u#33158:u32
        let s_1517_33: u32 = fn_state.u_33158;
        // D s_1517_34: cast zx s_1517_33 -> bv
        let s_1517_34: Bits = Bits::new(s_1517_33 as u128, 32u16);
        // D s_1517_35: bit-extract s_1517_34 s_1517_31 s_1517_32
        let s_1517_35: Bits = (Bits::new(
            ((s_1517_34) >> (s_1517_31)).value(),
            u16::try_from(s_1517_32).unwrap(),
        ));
        // D s_1517_36: cast reint s_1517_35 -> u8
        let s_1517_36: u8 = (s_1517_35.value() as u8);
        // D s_1517_37: write-var u#33163 <= s_1517_36
        fn_state.u_33163 = s_1517_36;
        // C s_1517_38: const #12s : i
        let s_1517_38: i128 = 12;
        // D s_1517_39: read-var u#33158:u32
        let s_1517_39: u32 = fn_state.u_33158;
        // D s_1517_40: cast zx s_1517_39 -> bv
        let s_1517_40: Bits = Bits::new(s_1517_39 as u128, 32u16);
        // C s_1517_41: const #1u : u64
        let s_1517_41: u64 = 1;
        // D s_1517_42: bit-extract s_1517_40 s_1517_38 s_1517_41
        let s_1517_42: Bits = (Bits::new(
            ((s_1517_40) >> (s_1517_38)).value(),
            u16::try_from(s_1517_41).unwrap(),
        ));
        // D s_1517_43: cast reint s_1517_42 -> u8
        let s_1517_43: bool = ((s_1517_42.value()) != 0);
        // C s_1517_44: const #0s : i
        let s_1517_44: i128 = 0;
        // C s_1517_45: const #0u : u64
        let s_1517_45: u64 = 0;
        // D s_1517_46: cast zx s_1517_43 -> u64
        let s_1517_46: u64 = (s_1517_43 as u64);
        // C s_1517_47: const #1u : u64
        let s_1517_47: u64 = 1;
        // D s_1517_48: and s_1517_46 s_1517_47
        let s_1517_48: u64 = ((s_1517_46) & (s_1517_47));
        // D s_1517_49: cmp-eq s_1517_48 s_1517_47
        let s_1517_49: bool = ((s_1517_48) == (s_1517_47));
        // D s_1517_50: lsl s_1517_46 s_1517_44
        let s_1517_50: u64 = s_1517_46 << s_1517_44;
        // D s_1517_51: or s_1517_45 s_1517_50
        let s_1517_51: u64 = ((s_1517_45) | (s_1517_50));
        // D s_1517_52: cmpl s_1517_50
        let s_1517_52: u64 = !s_1517_50;
        // D s_1517_53: and s_1517_45 s_1517_52
        let s_1517_53: u64 = ((s_1517_45) & (s_1517_52));
        // D s_1517_54: select s_1517_49 s_1517_51 s_1517_53
        let s_1517_54: u64 = if s_1517_49 { s_1517_51 } else { s_1517_53 };
        // D s_1517_55: cast trunc s_1517_54 -> u8
        let s_1517_55: bool = ((s_1517_54) != 0);
        // D s_1517_56: cast zx s_1517_55 -> bv
        let s_1517_56: Bits = Bits::new(s_1517_55 as u128, 1u16);
        // C s_1517_57: const #1u : u8
        let s_1517_57: bool = true;
        // C s_1517_58: cast zx s_1517_57 -> bv
        let s_1517_58: Bits = Bits::new(s_1517_57 as u128, 1u16);
        // D s_1517_59: cmp-ne s_1517_56 s_1517_58
        let s_1517_59: bool = ((s_1517_56) != (s_1517_58));
        // N s_1517_60: branch s_1517_59 b1534 b1518
        if s_1517_59 {
            return block_1534(state, tracer, fn_state);
        } else {
            return block_1518(state, tracer, fn_state);
        };
    }
    fn block_1518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1518_0: const #13s : i
        let s_1518_0: i128 = 13;
        // D s_1518_1: read-var u#33158:u32
        let s_1518_1: u32 = fn_state.u_33158;
        // D s_1518_2: cast zx s_1518_1 -> bv
        let s_1518_2: Bits = Bits::new(s_1518_1 as u128, 32u16);
        // C s_1518_3: const #1u : u64
        let s_1518_3: u64 = 1;
        // D s_1518_4: bit-extract s_1518_2 s_1518_0 s_1518_3
        let s_1518_4: Bits = (Bits::new(
            ((s_1518_2) >> (s_1518_0)).value(),
            u16::try_from(s_1518_3).unwrap(),
        ));
        // D s_1518_5: cast reint s_1518_4 -> u8
        let s_1518_5: bool = ((s_1518_4.value()) != 0);
        // C s_1518_6: const #0s : i
        let s_1518_6: i128 = 0;
        // C s_1518_7: const #0u : u64
        let s_1518_7: u64 = 0;
        // D s_1518_8: cast zx s_1518_5 -> u64
        let s_1518_8: u64 = (s_1518_5 as u64);
        // C s_1518_9: const #1u : u64
        let s_1518_9: u64 = 1;
        // D s_1518_10: and s_1518_8 s_1518_9
        let s_1518_10: u64 = ((s_1518_8) & (s_1518_9));
        // D s_1518_11: cmp-eq s_1518_10 s_1518_9
        let s_1518_11: bool = ((s_1518_10) == (s_1518_9));
        // D s_1518_12: lsl s_1518_8 s_1518_6
        let s_1518_12: u64 = s_1518_8 << s_1518_6;
        // D s_1518_13: or s_1518_7 s_1518_12
        let s_1518_13: u64 = ((s_1518_7) | (s_1518_12));
        // D s_1518_14: cmpl s_1518_12
        let s_1518_14: u64 = !s_1518_12;
        // D s_1518_15: and s_1518_7 s_1518_14
        let s_1518_15: u64 = ((s_1518_7) & (s_1518_14));
        // D s_1518_16: select s_1518_11 s_1518_13 s_1518_15
        let s_1518_16: u64 = if s_1518_11 { s_1518_13 } else { s_1518_15 };
        // D s_1518_17: cast trunc s_1518_16 -> u8
        let s_1518_17: bool = ((s_1518_16) != 0);
        // D s_1518_18: cast zx s_1518_17 -> bv
        let s_1518_18: Bits = Bits::new(s_1518_17 as u128, 1u16);
        // C s_1518_19: const #1u : u8
        let s_1518_19: bool = true;
        // C s_1518_20: cast zx s_1518_19 -> bv
        let s_1518_20: Bits = Bits::new(s_1518_19 as u128, 1u16);
        // D s_1518_21: cmp-ne s_1518_18 s_1518_20
        let s_1518_21: bool = ((s_1518_18) != (s_1518_20));
        // D s_1518_22: write-var gs#407705 <= s_1518_21
        fn_state.gs_407705 = s_1518_21;
        // N s_1518_23: jump b1519
        return block_1519(state, tracer, fn_state);
    }
    fn block_1519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1519_0: read-var gs#407705:u8
        let s_1519_0: bool = fn_state.gs_407705;
        // N s_1519_1: branch s_1519_0 b1533 b1520
        if s_1519_0 {
            return block_1533(state, tracer, fn_state);
        } else {
            return block_1520(state, tracer, fn_state);
        };
    }
    fn block_1520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1520_0: const #14s : i
        let s_1520_0: i128 = 14;
        // D s_1520_1: read-var u#33158:u32
        let s_1520_1: u32 = fn_state.u_33158;
        // D s_1520_2: cast zx s_1520_1 -> bv
        let s_1520_2: Bits = Bits::new(s_1520_1 as u128, 32u16);
        // C s_1520_3: const #1u : u64
        let s_1520_3: u64 = 1;
        // D s_1520_4: bit-extract s_1520_2 s_1520_0 s_1520_3
        let s_1520_4: Bits = (Bits::new(
            ((s_1520_2) >> (s_1520_0)).value(),
            u16::try_from(s_1520_3).unwrap(),
        ));
        // D s_1520_5: cast reint s_1520_4 -> u8
        let s_1520_5: bool = ((s_1520_4.value()) != 0);
        // C s_1520_6: const #0s : i
        let s_1520_6: i128 = 0;
        // C s_1520_7: const #0u : u64
        let s_1520_7: u64 = 0;
        // D s_1520_8: cast zx s_1520_5 -> u64
        let s_1520_8: u64 = (s_1520_5 as u64);
        // C s_1520_9: const #1u : u64
        let s_1520_9: u64 = 1;
        // D s_1520_10: and s_1520_8 s_1520_9
        let s_1520_10: u64 = ((s_1520_8) & (s_1520_9));
        // D s_1520_11: cmp-eq s_1520_10 s_1520_9
        let s_1520_11: bool = ((s_1520_10) == (s_1520_9));
        // D s_1520_12: lsl s_1520_8 s_1520_6
        let s_1520_12: u64 = s_1520_8 << s_1520_6;
        // D s_1520_13: or s_1520_7 s_1520_12
        let s_1520_13: u64 = ((s_1520_7) | (s_1520_12));
        // D s_1520_14: cmpl s_1520_12
        let s_1520_14: u64 = !s_1520_12;
        // D s_1520_15: and s_1520_7 s_1520_14
        let s_1520_15: u64 = ((s_1520_7) & (s_1520_14));
        // D s_1520_16: select s_1520_11 s_1520_13 s_1520_15
        let s_1520_16: u64 = if s_1520_11 { s_1520_13 } else { s_1520_15 };
        // D s_1520_17: cast trunc s_1520_16 -> u8
        let s_1520_17: bool = ((s_1520_16) != 0);
        // D s_1520_18: cast zx s_1520_17 -> bv
        let s_1520_18: Bits = Bits::new(s_1520_17 as u128, 1u16);
        // C s_1520_19: const #1u : u8
        let s_1520_19: bool = true;
        // C s_1520_20: cast zx s_1520_19 -> bv
        let s_1520_20: Bits = Bits::new(s_1520_19 as u128, 1u16);
        // D s_1520_21: cmp-ne s_1520_18 s_1520_20
        let s_1520_21: bool = ((s_1520_18) != (s_1520_20));
        // D s_1520_22: write-var gs#407708 <= s_1520_21
        fn_state.gs_407708 = s_1520_21;
        // N s_1520_23: jump b1521
        return block_1521(state, tracer, fn_state);
    }
    fn block_1521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1521_0: read-var gs#407708:u8
        let s_1521_0: bool = fn_state.gs_407708;
        // N s_1521_1: branch s_1521_0 b1532 b1522
        if s_1521_0 {
            return block_1532(state, tracer, fn_state);
        } else {
            return block_1522(state, tracer, fn_state);
        };
    }
    fn block_1522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1522_0: const #15s : i
        let s_1522_0: i128 = 15;
        // D s_1522_1: read-var u#33158:u32
        let s_1522_1: u32 = fn_state.u_33158;
        // D s_1522_2: cast zx s_1522_1 -> bv
        let s_1522_2: Bits = Bits::new(s_1522_1 as u128, 32u16);
        // C s_1522_3: const #1u : u64
        let s_1522_3: u64 = 1;
        // D s_1522_4: bit-extract s_1522_2 s_1522_0 s_1522_3
        let s_1522_4: Bits = (Bits::new(
            ((s_1522_2) >> (s_1522_0)).value(),
            u16::try_from(s_1522_3).unwrap(),
        ));
        // D s_1522_5: cast reint s_1522_4 -> u8
        let s_1522_5: bool = ((s_1522_4.value()) != 0);
        // C s_1522_6: const #0s : i
        let s_1522_6: i128 = 0;
        // C s_1522_7: const #0u : u64
        let s_1522_7: u64 = 0;
        // D s_1522_8: cast zx s_1522_5 -> u64
        let s_1522_8: u64 = (s_1522_5 as u64);
        // C s_1522_9: const #1u : u64
        let s_1522_9: u64 = 1;
        // D s_1522_10: and s_1522_8 s_1522_9
        let s_1522_10: u64 = ((s_1522_8) & (s_1522_9));
        // D s_1522_11: cmp-eq s_1522_10 s_1522_9
        let s_1522_11: bool = ((s_1522_10) == (s_1522_9));
        // D s_1522_12: lsl s_1522_8 s_1522_6
        let s_1522_12: u64 = s_1522_8 << s_1522_6;
        // D s_1522_13: or s_1522_7 s_1522_12
        let s_1522_13: u64 = ((s_1522_7) | (s_1522_12));
        // D s_1522_14: cmpl s_1522_12
        let s_1522_14: u64 = !s_1522_12;
        // D s_1522_15: and s_1522_7 s_1522_14
        let s_1522_15: u64 = ((s_1522_7) & (s_1522_14));
        // D s_1522_16: select s_1522_11 s_1522_13 s_1522_15
        let s_1522_16: u64 = if s_1522_11 { s_1522_13 } else { s_1522_15 };
        // D s_1522_17: cast trunc s_1522_16 -> u8
        let s_1522_17: bool = ((s_1522_16) != 0);
        // D s_1522_18: cast zx s_1522_17 -> bv
        let s_1522_18: Bits = Bits::new(s_1522_17 as u128, 1u16);
        // C s_1522_19: const #1u : u8
        let s_1522_19: bool = true;
        // C s_1522_20: cast zx s_1522_19 -> bv
        let s_1522_20: Bits = Bits::new(s_1522_19 as u128, 1u16);
        // D s_1522_21: cmp-ne s_1522_18 s_1522_20
        let s_1522_21: bool = ((s_1522_18) != (s_1522_20));
        // D s_1522_22: write-var gs#407711 <= s_1522_21
        fn_state.gs_407711 = s_1522_21;
        // N s_1522_23: jump b1523
        return block_1523(state, tracer, fn_state);
    }
    fn block_1523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1523_0: read-var gs#407711:u8
        let s_1523_0: bool = fn_state.gs_407711;
        // N s_1523_1: branch s_1523_0 b1531 b1524
        if s_1523_0 {
            return block_1531(state, tracer, fn_state);
        } else {
            return block_1524(state, tracer, fn_state);
        };
    }
    fn block_1524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1524_0: const #10s : i
        let s_1524_0: i128 = 10;
        // D s_1524_1: read-var u#33158:u32
        let s_1524_1: u32 = fn_state.u_33158;
        // D s_1524_2: cast zx s_1524_1 -> bv
        let s_1524_2: Bits = Bits::new(s_1524_1 as u128, 32u16);
        // C s_1524_3: const #1u : u64
        let s_1524_3: u64 = 1;
        // D s_1524_4: bit-extract s_1524_2 s_1524_0 s_1524_3
        let s_1524_4: Bits = (Bits::new(
            ((s_1524_2) >> (s_1524_0)).value(),
            u16::try_from(s_1524_3).unwrap(),
        ));
        // D s_1524_5: cast reint s_1524_4 -> u8
        let s_1524_5: bool = ((s_1524_4.value()) != 0);
        // C s_1524_6: const #0s : i
        let s_1524_6: i128 = 0;
        // C s_1524_7: const #0u : u64
        let s_1524_7: u64 = 0;
        // D s_1524_8: cast zx s_1524_5 -> u64
        let s_1524_8: u64 = (s_1524_5 as u64);
        // C s_1524_9: const #1u : u64
        let s_1524_9: u64 = 1;
        // D s_1524_10: and s_1524_8 s_1524_9
        let s_1524_10: u64 = ((s_1524_8) & (s_1524_9));
        // D s_1524_11: cmp-eq s_1524_10 s_1524_9
        let s_1524_11: bool = ((s_1524_10) == (s_1524_9));
        // D s_1524_12: lsl s_1524_8 s_1524_6
        let s_1524_12: u64 = s_1524_8 << s_1524_6;
        // D s_1524_13: or s_1524_7 s_1524_12
        let s_1524_13: u64 = ((s_1524_7) | (s_1524_12));
        // D s_1524_14: cmpl s_1524_12
        let s_1524_14: u64 = !s_1524_12;
        // D s_1524_15: and s_1524_7 s_1524_14
        let s_1524_15: u64 = ((s_1524_7) & (s_1524_14));
        // D s_1524_16: select s_1524_11 s_1524_13 s_1524_15
        let s_1524_16: u64 = if s_1524_11 { s_1524_13 } else { s_1524_15 };
        // D s_1524_17: cast trunc s_1524_16 -> u8
        let s_1524_17: bool = ((s_1524_16) != 0);
        // D s_1524_18: cast zx s_1524_17 -> bv
        let s_1524_18: Bits = Bits::new(s_1524_17 as u128, 1u16);
        // C s_1524_19: const #0u : u8
        let s_1524_19: bool = false;
        // C s_1524_20: cast zx s_1524_19 -> bv
        let s_1524_20: Bits = Bits::new(s_1524_19 as u128, 1u16);
        // D s_1524_21: cmp-ne s_1524_18 s_1524_20
        let s_1524_21: bool = ((s_1524_18) != (s_1524_20));
        // D s_1524_22: write-var gs#407714 <= s_1524_21
        fn_state.gs_407714 = s_1524_21;
        // N s_1524_23: jump b1525
        return block_1525(state, tracer, fn_state);
    }
    fn block_1525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1525_0: read-var gs#407714:u8
        let s_1525_0: bool = fn_state.gs_407714;
        // N s_1525_1: branch s_1525_0 b1530 b1526
        if s_1525_0 {
            return block_1530(state, tracer, fn_state);
        } else {
            return block_1526(state, tracer, fn_state);
        };
    }
    fn block_1526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1526_0: const #11s : i
        let s_1526_0: i128 = 11;
        // D s_1526_1: read-var u#33158:u32
        let s_1526_1: u32 = fn_state.u_33158;
        // D s_1526_2: cast zx s_1526_1 -> bv
        let s_1526_2: Bits = Bits::new(s_1526_1 as u128, 32u16);
        // C s_1526_3: const #1u : u64
        let s_1526_3: u64 = 1;
        // D s_1526_4: bit-extract s_1526_2 s_1526_0 s_1526_3
        let s_1526_4: Bits = (Bits::new(
            ((s_1526_2) >> (s_1526_0)).value(),
            u16::try_from(s_1526_3).unwrap(),
        ));
        // D s_1526_5: cast reint s_1526_4 -> u8
        let s_1526_5: bool = ((s_1526_4.value()) != 0);
        // C s_1526_6: const #0s : i
        let s_1526_6: i128 = 0;
        // C s_1526_7: const #0u : u64
        let s_1526_7: u64 = 0;
        // D s_1526_8: cast zx s_1526_5 -> u64
        let s_1526_8: u64 = (s_1526_5 as u64);
        // C s_1526_9: const #1u : u64
        let s_1526_9: u64 = 1;
        // D s_1526_10: and s_1526_8 s_1526_9
        let s_1526_10: u64 = ((s_1526_8) & (s_1526_9));
        // D s_1526_11: cmp-eq s_1526_10 s_1526_9
        let s_1526_11: bool = ((s_1526_10) == (s_1526_9));
        // D s_1526_12: lsl s_1526_8 s_1526_6
        let s_1526_12: u64 = s_1526_8 << s_1526_6;
        // D s_1526_13: or s_1526_7 s_1526_12
        let s_1526_13: u64 = ((s_1526_7) | (s_1526_12));
        // D s_1526_14: cmpl s_1526_12
        let s_1526_14: u64 = !s_1526_12;
        // D s_1526_15: and s_1526_7 s_1526_14
        let s_1526_15: u64 = ((s_1526_7) & (s_1526_14));
        // D s_1526_16: select s_1526_11 s_1526_13 s_1526_15
        let s_1526_16: u64 = if s_1526_11 { s_1526_13 } else { s_1526_15 };
        // D s_1526_17: cast trunc s_1526_16 -> u8
        let s_1526_17: bool = ((s_1526_16) != 0);
        // D s_1526_18: cast zx s_1526_17 -> bv
        let s_1526_18: Bits = Bits::new(s_1526_17 as u128, 1u16);
        // C s_1526_19: const #0u : u8
        let s_1526_19: bool = false;
        // C s_1526_20: cast zx s_1526_19 -> bv
        let s_1526_20: Bits = Bits::new(s_1526_19 as u128, 1u16);
        // D s_1526_21: cmp-ne s_1526_18 s_1526_20
        let s_1526_21: bool = ((s_1526_18) != (s_1526_20));
        // D s_1526_22: write-var gs#407717 <= s_1526_21
        fn_state.gs_407717 = s_1526_21;
        // N s_1526_23: jump b1527
        return block_1527(state, tracer, fn_state);
    }
    fn block_1527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1527_0: read-var gs#407717:u8
        let s_1527_0: bool = fn_state.gs_407717;
        // N s_1527_1: branch s_1527_0 b1529 b1528
        if s_1527_0 {
            return block_1529(state, tracer, fn_state);
        } else {
            return block_1528(state, tracer, fn_state);
        };
    }
    fn block_1528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1528_0: read-var u#33159:u8
        let s_1528_0: u8 = fn_state.u_33159;
        // D s_1528_1: read-var u#33160:u8
        let s_1528_1: bool = fn_state.u_33160;
        // D s_1528_2: read-var u#33161:u8
        let s_1528_2: u8 = fn_state.u_33161;
        // D s_1528_3: read-var u#33162:u8
        let s_1528_3: bool = fn_state.u_33162;
        // D s_1528_4: read-var u#33163:u8
        let s_1528_4: u8 = fn_state.u_33163;
        // D s_1528_5: call decode_aarch32_instrs_MSR_br_A1enc_AS_txt(s_1528_0, s_1528_1, s_1528_2, s_1528_3, s_1528_4)
        let s_1528_5: () = decode_aarch32_instrs_MSR_br_A1enc_AS_txt(
            state,
            tracer,
            s_1528_0,
            s_1528_1,
            s_1528_2,
            s_1528_3,
            s_1528_4,
        );
        // N s_1528_6: return
        return;
    }
    fn block_1529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1529_0: panic
        panic!("{:?}", ());
        // N s_1529_1: return
        return;
    }
    fn block_1530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1530_0: const #1u : u8
        let s_1530_0: bool = true;
        // D s_1530_1: write-var gs#407717 <= s_1530_0
        fn_state.gs_407717 = s_1530_0;
        // N s_1530_2: jump b1527
        return block_1527(state, tracer, fn_state);
    }
    fn block_1531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1531_0: const #1u : u8
        let s_1531_0: bool = true;
        // D s_1531_1: write-var gs#407714 <= s_1531_0
        fn_state.gs_407714 = s_1531_0;
        // N s_1531_2: jump b1525
        return block_1525(state, tracer, fn_state);
    }
    fn block_1532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1532_0: const #1u : u8
        let s_1532_0: bool = true;
        // D s_1532_1: write-var gs#407711 <= s_1532_0
        fn_state.gs_407711 = s_1532_0;
        // N s_1532_2: jump b1523
        return block_1523(state, tracer, fn_state);
    }
    fn block_1533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1533_0: const #1u : u8
        let s_1533_0: bool = true;
        // D s_1533_1: write-var gs#407708 <= s_1533_0
        fn_state.gs_407708 = s_1533_0;
        // N s_1533_2: jump b1521
        return block_1521(state, tracer, fn_state);
    }
    fn block_1534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1534_0: const #1u : u8
        let s_1534_0: bool = true;
        // D s_1534_1: write-var gs#407705 <= s_1534_0
        fn_state.gs_407705 = s_1534_0;
        // N s_1534_2: jump b1519
        return block_1519(state, tracer, fn_state);
    }
    fn block_1535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1535_0: read-var merge#var.1:struct
        let s_1535_0: u32 = fn_state.merge_var._1;
        // D s_1535_1: write-var u#33165 <= s_1535_0
        fn_state.u_33165 = s_1535_0;
        // C s_1535_2: const #23s : i
        let s_1535_2: i128 = 23;
        // D s_1535_3: read-var u#33165:u32
        let s_1535_3: u32 = fn_state.u_33165;
        // D s_1535_4: cast zx s_1535_3 -> bv
        let s_1535_4: Bits = Bits::new(s_1535_3 as u128, 32u16);
        // C s_1535_5: const #1s : i64
        let s_1535_5: i64 = 1;
        // C s_1535_6: cast zx s_1535_5 -> i
        let s_1535_6: i128 = (i128::try_from(s_1535_5).unwrap());
        // C s_1535_7: const #4s : i
        let s_1535_7: i128 = 4;
        // C s_1535_8: add s_1535_7 s_1535_6
        let s_1535_8: i128 = (s_1535_7 + s_1535_6);
        // D s_1535_9: bit-extract s_1535_4 s_1535_2 s_1535_8
        let s_1535_9: Bits = (Bits::new(
            ((s_1535_4) >> (s_1535_2)).value(),
            u16::try_from(s_1535_8).unwrap(),
        ));
        // D s_1535_10: cast reint s_1535_9 -> u8
        let s_1535_10: u8 = (s_1535_9.value() as u8);
        // D s_1535_11: cast zx s_1535_10 -> bv
        let s_1535_11: Bits = Bits::new(s_1535_10 as u128, 5u16);
        // C s_1535_12: const #6u : u8
        let s_1535_12: u8 = 6;
        // C s_1535_13: cast zx s_1535_12 -> bv
        let s_1535_13: Bits = Bits::new(s_1535_12 as u128, 5u16);
        // D s_1535_14: cmp-eq s_1535_11 s_1535_13
        let s_1535_14: bool = ((s_1535_11) == (s_1535_13));
        // N s_1535_15: branch s_1535_14 b2169 b1536
        if s_1535_14 {
            return block_2169(state, tracer, fn_state);
        } else {
            return block_1536(state, tracer, fn_state);
        };
    }
    fn block_1536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1536_0: const #0u : u8
        let s_1536_0: bool = false;
        // D s_1536_1: write-var gs#407726 <= s_1536_0
        fn_state.gs_407726 = s_1536_0;
        // N s_1536_2: jump b1537
        return block_1537(state, tracer, fn_state);
    }
    fn block_1537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1537_0: read-var gs#407726:u8
        let s_1537_0: bool = fn_state.gs_407726;
        // N s_1537_1: branch s_1537_0 b2165 b1538
        if s_1537_0 {
            return block_2165(state, tracer, fn_state);
        } else {
            return block_1538(state, tracer, fn_state);
        };
    }
    fn block_1538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1538_0: const #0u : u8
        let s_1538_0: bool = false;
        // D s_1538_1: write-var gs#407731 <= s_1538_0
        fn_state.gs_407731 = s_1538_0;
        // N s_1538_2: jump b1539
        return block_1539(state, tracer, fn_state);
    }
    fn block_1539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1539_0: read-var gs#407731:u8
        let s_1539_0: bool = fn_state.gs_407731;
        // D s_1539_1: not s_1539_0
        let s_1539_1: bool = !s_1539_0;
        // N s_1539_2: branch s_1539_1 b1552 b1540
        if s_1539_1 {
            return block_1552(state, tracer, fn_state);
        } else {
            return block_1540(state, tracer, fn_state);
        };
    }
    fn block_1540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1540_0: const #3784s : i
        let s_1540_0: i128 = 3784;
        // C s_1540_1: const #14696u : u32
        let s_1540_1: u32 = 14696;
        // N s_1540_2: write-reg s_1540_1 <= s_1540_0
        let s_1540_2: () = {
            state.write_register::<i128>(s_1540_1 as isize, s_1540_0);
            tracer.write_register(s_1540_1 as isize, s_1540_0);
        };
        // C s_1540_3: const #28s : i
        let s_1540_3: i128 = 28;
        // C s_1540_4: const #4s : i
        let s_1540_4: i128 = 4;
        // D s_1540_5: read-var u#33165:u32
        let s_1540_5: u32 = fn_state.u_33165;
        // D s_1540_6: cast zx s_1540_5 -> bv
        let s_1540_6: Bits = Bits::new(s_1540_5 as u128, 32u16);
        // D s_1540_7: bit-extract s_1540_6 s_1540_3 s_1540_4
        let s_1540_7: Bits = (Bits::new(
            ((s_1540_6) >> (s_1540_3)).value(),
            u16::try_from(s_1540_4).unwrap(),
        ));
        // D s_1540_8: cast reint s_1540_7 -> u8
        let s_1540_8: u8 = (s_1540_7.value() as u8);
        // D s_1540_9: write-var u#33166 <= s_1540_8
        fn_state.u_33166 = s_1540_8;
        // C s_1540_10: const #22s : i
        let s_1540_10: i128 = 22;
        // C s_1540_11: const #1s : i
        let s_1540_11: i128 = 1;
        // D s_1540_12: read-var u#33165:u32
        let s_1540_12: u32 = fn_state.u_33165;
        // D s_1540_13: cast zx s_1540_12 -> bv
        let s_1540_13: Bits = Bits::new(s_1540_12 as u128, 32u16);
        // D s_1540_14: bit-extract s_1540_13 s_1540_10 s_1540_11
        let s_1540_14: Bits = (Bits::new(
            ((s_1540_13) >> (s_1540_10)).value(),
            u16::try_from(s_1540_11).unwrap(),
        ));
        // D s_1540_15: cast reint s_1540_14 -> u8
        let s_1540_15: bool = ((s_1540_14.value()) != 0);
        // D s_1540_16: write-var u#33167 <= s_1540_15
        fn_state.u_33167 = s_1540_15;
        // C s_1540_17: const #16s : i
        let s_1540_17: i128 = 16;
        // C s_1540_18: const #4s : i
        let s_1540_18: i128 = 4;
        // D s_1540_19: read-var u#33165:u32
        let s_1540_19: u32 = fn_state.u_33165;
        // D s_1540_20: cast zx s_1540_19 -> bv
        let s_1540_20: Bits = Bits::new(s_1540_19 as u128, 32u16);
        // D s_1540_21: bit-extract s_1540_20 s_1540_17 s_1540_18
        let s_1540_21: Bits = (Bits::new(
            ((s_1540_20) >> (s_1540_17)).value(),
            u16::try_from(s_1540_18).unwrap(),
        ));
        // D s_1540_22: cast reint s_1540_21 -> u8
        let s_1540_22: u8 = (s_1540_21.value() as u8);
        // D s_1540_23: write-var mask <= s_1540_22
        fn_state.mask = s_1540_22;
        // C s_1540_24: const #0s : i
        let s_1540_24: i128 = 0;
        // C s_1540_25: const #12s : i
        let s_1540_25: i128 = 12;
        // D s_1540_26: read-var u#33165:u32
        let s_1540_26: u32 = fn_state.u_33165;
        // D s_1540_27: cast zx s_1540_26 -> bv
        let s_1540_27: Bits = Bits::new(s_1540_26 as u128, 32u16);
        // D s_1540_28: bit-extract s_1540_27 s_1540_24 s_1540_25
        let s_1540_28: Bits = (Bits::new(
            ((s_1540_27) >> (s_1540_24)).value(),
            u16::try_from(s_1540_25).unwrap(),
        ));
        // D s_1540_29: cast reint s_1540_28 -> u12
        let s_1540_29: u16 = (s_1540_28.value() as u16);
        // D s_1540_30: write-var u#33168 <= s_1540_29
        fn_state.u_33168 = s_1540_29;
        // C s_1540_31: const #12s : i
        let s_1540_31: i128 = 12;
        // D s_1540_32: read-var u#33165:u32
        let s_1540_32: u32 = fn_state.u_33165;
        // D s_1540_33: cast zx s_1540_32 -> bv
        let s_1540_33: Bits = Bits::new(s_1540_32 as u128, 32u16);
        // C s_1540_34: const #1u : u64
        let s_1540_34: u64 = 1;
        // D s_1540_35: bit-extract s_1540_33 s_1540_31 s_1540_34
        let s_1540_35: Bits = (Bits::new(
            ((s_1540_33) >> (s_1540_31)).value(),
            u16::try_from(s_1540_34).unwrap(),
        ));
        // D s_1540_36: cast reint s_1540_35 -> u8
        let s_1540_36: bool = ((s_1540_35.value()) != 0);
        // C s_1540_37: const #0s : i
        let s_1540_37: i128 = 0;
        // C s_1540_38: const #0u : u64
        let s_1540_38: u64 = 0;
        // D s_1540_39: cast zx s_1540_36 -> u64
        let s_1540_39: u64 = (s_1540_36 as u64);
        // C s_1540_40: const #1u : u64
        let s_1540_40: u64 = 1;
        // D s_1540_41: and s_1540_39 s_1540_40
        let s_1540_41: u64 = ((s_1540_39) & (s_1540_40));
        // D s_1540_42: cmp-eq s_1540_41 s_1540_40
        let s_1540_42: bool = ((s_1540_41) == (s_1540_40));
        // D s_1540_43: lsl s_1540_39 s_1540_37
        let s_1540_43: u64 = s_1540_39 << s_1540_37;
        // D s_1540_44: or s_1540_38 s_1540_43
        let s_1540_44: u64 = ((s_1540_38) | (s_1540_43));
        // D s_1540_45: cmpl s_1540_43
        let s_1540_45: u64 = !s_1540_43;
        // D s_1540_46: and s_1540_38 s_1540_45
        let s_1540_46: u64 = ((s_1540_38) & (s_1540_45));
        // D s_1540_47: select s_1540_42 s_1540_44 s_1540_46
        let s_1540_47: u64 = if s_1540_42 { s_1540_44 } else { s_1540_46 };
        // D s_1540_48: cast trunc s_1540_47 -> u8
        let s_1540_48: bool = ((s_1540_47) != 0);
        // D s_1540_49: cast zx s_1540_48 -> bv
        let s_1540_49: Bits = Bits::new(s_1540_48 as u128, 1u16);
        // C s_1540_50: const #1u : u8
        let s_1540_50: bool = true;
        // C s_1540_51: cast zx s_1540_50 -> bv
        let s_1540_51: Bits = Bits::new(s_1540_50 as u128, 1u16);
        // D s_1540_52: cmp-ne s_1540_49 s_1540_51
        let s_1540_52: bool = ((s_1540_49) != (s_1540_51));
        // N s_1540_53: branch s_1540_52 b1551 b1541
        if s_1540_52 {
            return block_1551(state, tracer, fn_state);
        } else {
            return block_1541(state, tracer, fn_state);
        };
    }
    fn block_1541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1541_0: const #13s : i
        let s_1541_0: i128 = 13;
        // D s_1541_1: read-var u#33165:u32
        let s_1541_1: u32 = fn_state.u_33165;
        // D s_1541_2: cast zx s_1541_1 -> bv
        let s_1541_2: Bits = Bits::new(s_1541_1 as u128, 32u16);
        // C s_1541_3: const #1u : u64
        let s_1541_3: u64 = 1;
        // D s_1541_4: bit-extract s_1541_2 s_1541_0 s_1541_3
        let s_1541_4: Bits = (Bits::new(
            ((s_1541_2) >> (s_1541_0)).value(),
            u16::try_from(s_1541_3).unwrap(),
        ));
        // D s_1541_5: cast reint s_1541_4 -> u8
        let s_1541_5: bool = ((s_1541_4.value()) != 0);
        // C s_1541_6: const #0s : i
        let s_1541_6: i128 = 0;
        // C s_1541_7: const #0u : u64
        let s_1541_7: u64 = 0;
        // D s_1541_8: cast zx s_1541_5 -> u64
        let s_1541_8: u64 = (s_1541_5 as u64);
        // C s_1541_9: const #1u : u64
        let s_1541_9: u64 = 1;
        // D s_1541_10: and s_1541_8 s_1541_9
        let s_1541_10: u64 = ((s_1541_8) & (s_1541_9));
        // D s_1541_11: cmp-eq s_1541_10 s_1541_9
        let s_1541_11: bool = ((s_1541_10) == (s_1541_9));
        // D s_1541_12: lsl s_1541_8 s_1541_6
        let s_1541_12: u64 = s_1541_8 << s_1541_6;
        // D s_1541_13: or s_1541_7 s_1541_12
        let s_1541_13: u64 = ((s_1541_7) | (s_1541_12));
        // D s_1541_14: cmpl s_1541_12
        let s_1541_14: u64 = !s_1541_12;
        // D s_1541_15: and s_1541_7 s_1541_14
        let s_1541_15: u64 = ((s_1541_7) & (s_1541_14));
        // D s_1541_16: select s_1541_11 s_1541_13 s_1541_15
        let s_1541_16: u64 = if s_1541_11 { s_1541_13 } else { s_1541_15 };
        // D s_1541_17: cast trunc s_1541_16 -> u8
        let s_1541_17: bool = ((s_1541_16) != 0);
        // D s_1541_18: cast zx s_1541_17 -> bv
        let s_1541_18: Bits = Bits::new(s_1541_17 as u128, 1u16);
        // C s_1541_19: const #1u : u8
        let s_1541_19: bool = true;
        // C s_1541_20: cast zx s_1541_19 -> bv
        let s_1541_20: Bits = Bits::new(s_1541_19 as u128, 1u16);
        // D s_1541_21: cmp-ne s_1541_18 s_1541_20
        let s_1541_21: bool = ((s_1541_18) != (s_1541_20));
        // D s_1541_22: write-var gs#407746 <= s_1541_21
        fn_state.gs_407746 = s_1541_21;
        // N s_1541_23: jump b1542
        return block_1542(state, tracer, fn_state);
    }
    fn block_1542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1542_0: read-var gs#407746:u8
        let s_1542_0: bool = fn_state.gs_407746;
        // N s_1542_1: branch s_1542_0 b1550 b1543
        if s_1542_0 {
            return block_1550(state, tracer, fn_state);
        } else {
            return block_1543(state, tracer, fn_state);
        };
    }
    fn block_1543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1543_0: const #14s : i
        let s_1543_0: i128 = 14;
        // D s_1543_1: read-var u#33165:u32
        let s_1543_1: u32 = fn_state.u_33165;
        // D s_1543_2: cast zx s_1543_1 -> bv
        let s_1543_2: Bits = Bits::new(s_1543_1 as u128, 32u16);
        // C s_1543_3: const #1u : u64
        let s_1543_3: u64 = 1;
        // D s_1543_4: bit-extract s_1543_2 s_1543_0 s_1543_3
        let s_1543_4: Bits = (Bits::new(
            ((s_1543_2) >> (s_1543_0)).value(),
            u16::try_from(s_1543_3).unwrap(),
        ));
        // D s_1543_5: cast reint s_1543_4 -> u8
        let s_1543_5: bool = ((s_1543_4.value()) != 0);
        // C s_1543_6: const #0s : i
        let s_1543_6: i128 = 0;
        // C s_1543_7: const #0u : u64
        let s_1543_7: u64 = 0;
        // D s_1543_8: cast zx s_1543_5 -> u64
        let s_1543_8: u64 = (s_1543_5 as u64);
        // C s_1543_9: const #1u : u64
        let s_1543_9: u64 = 1;
        // D s_1543_10: and s_1543_8 s_1543_9
        let s_1543_10: u64 = ((s_1543_8) & (s_1543_9));
        // D s_1543_11: cmp-eq s_1543_10 s_1543_9
        let s_1543_11: bool = ((s_1543_10) == (s_1543_9));
        // D s_1543_12: lsl s_1543_8 s_1543_6
        let s_1543_12: u64 = s_1543_8 << s_1543_6;
        // D s_1543_13: or s_1543_7 s_1543_12
        let s_1543_13: u64 = ((s_1543_7) | (s_1543_12));
        // D s_1543_14: cmpl s_1543_12
        let s_1543_14: u64 = !s_1543_12;
        // D s_1543_15: and s_1543_7 s_1543_14
        let s_1543_15: u64 = ((s_1543_7) & (s_1543_14));
        // D s_1543_16: select s_1543_11 s_1543_13 s_1543_15
        let s_1543_16: u64 = if s_1543_11 { s_1543_13 } else { s_1543_15 };
        // D s_1543_17: cast trunc s_1543_16 -> u8
        let s_1543_17: bool = ((s_1543_16) != 0);
        // D s_1543_18: cast zx s_1543_17 -> bv
        let s_1543_18: Bits = Bits::new(s_1543_17 as u128, 1u16);
        // C s_1543_19: const #1u : u8
        let s_1543_19: bool = true;
        // C s_1543_20: cast zx s_1543_19 -> bv
        let s_1543_20: Bits = Bits::new(s_1543_19 as u128, 1u16);
        // D s_1543_21: cmp-ne s_1543_18 s_1543_20
        let s_1543_21: bool = ((s_1543_18) != (s_1543_20));
        // D s_1543_22: write-var gs#407749 <= s_1543_21
        fn_state.gs_407749 = s_1543_21;
        // N s_1543_23: jump b1544
        return block_1544(state, tracer, fn_state);
    }
    fn block_1544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1544_0: read-var gs#407749:u8
        let s_1544_0: bool = fn_state.gs_407749;
        // N s_1544_1: branch s_1544_0 b1549 b1545
        if s_1544_0 {
            return block_1549(state, tracer, fn_state);
        } else {
            return block_1545(state, tracer, fn_state);
        };
    }
    fn block_1545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1545_0: const #15s : i
        let s_1545_0: i128 = 15;
        // D s_1545_1: read-var u#33165:u32
        let s_1545_1: u32 = fn_state.u_33165;
        // D s_1545_2: cast zx s_1545_1 -> bv
        let s_1545_2: Bits = Bits::new(s_1545_1 as u128, 32u16);
        // C s_1545_3: const #1u : u64
        let s_1545_3: u64 = 1;
        // D s_1545_4: bit-extract s_1545_2 s_1545_0 s_1545_3
        let s_1545_4: Bits = (Bits::new(
            ((s_1545_2) >> (s_1545_0)).value(),
            u16::try_from(s_1545_3).unwrap(),
        ));
        // D s_1545_5: cast reint s_1545_4 -> u8
        let s_1545_5: bool = ((s_1545_4.value()) != 0);
        // C s_1545_6: const #0s : i
        let s_1545_6: i128 = 0;
        // C s_1545_7: const #0u : u64
        let s_1545_7: u64 = 0;
        // D s_1545_8: cast zx s_1545_5 -> u64
        let s_1545_8: u64 = (s_1545_5 as u64);
        // C s_1545_9: const #1u : u64
        let s_1545_9: u64 = 1;
        // D s_1545_10: and s_1545_8 s_1545_9
        let s_1545_10: u64 = ((s_1545_8) & (s_1545_9));
        // D s_1545_11: cmp-eq s_1545_10 s_1545_9
        let s_1545_11: bool = ((s_1545_10) == (s_1545_9));
        // D s_1545_12: lsl s_1545_8 s_1545_6
        let s_1545_12: u64 = s_1545_8 << s_1545_6;
        // D s_1545_13: or s_1545_7 s_1545_12
        let s_1545_13: u64 = ((s_1545_7) | (s_1545_12));
        // D s_1545_14: cmpl s_1545_12
        let s_1545_14: u64 = !s_1545_12;
        // D s_1545_15: and s_1545_7 s_1545_14
        let s_1545_15: u64 = ((s_1545_7) & (s_1545_14));
        // D s_1545_16: select s_1545_11 s_1545_13 s_1545_15
        let s_1545_16: u64 = if s_1545_11 { s_1545_13 } else { s_1545_15 };
        // D s_1545_17: cast trunc s_1545_16 -> u8
        let s_1545_17: bool = ((s_1545_16) != 0);
        // D s_1545_18: cast zx s_1545_17 -> bv
        let s_1545_18: Bits = Bits::new(s_1545_17 as u128, 1u16);
        // C s_1545_19: const #1u : u8
        let s_1545_19: bool = true;
        // C s_1545_20: cast zx s_1545_19 -> bv
        let s_1545_20: Bits = Bits::new(s_1545_19 as u128, 1u16);
        // D s_1545_21: cmp-ne s_1545_18 s_1545_20
        let s_1545_21: bool = ((s_1545_18) != (s_1545_20));
        // D s_1545_22: write-var gs#407752 <= s_1545_21
        fn_state.gs_407752 = s_1545_21;
        // N s_1545_23: jump b1546
        return block_1546(state, tracer, fn_state);
    }
    fn block_1546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1546_0: read-var gs#407752:u8
        let s_1546_0: bool = fn_state.gs_407752;
        // N s_1546_1: branch s_1546_0 b1548 b1547
        if s_1546_0 {
            return block_1548(state, tracer, fn_state);
        } else {
            return block_1547(state, tracer, fn_state);
        };
    }
    fn block_1547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1547_0: read-var u#33166:u8
        let s_1547_0: u8 = fn_state.u_33166;
        // D s_1547_1: read-var u#33167:u8
        let s_1547_1: bool = fn_state.u_33167;
        // D s_1547_2: read-var mask:u8
        let s_1547_2: u8 = fn_state.mask;
        // D s_1547_3: read-var u#33168:u12
        let s_1547_3: u16 = fn_state.u_33168;
        // D s_1547_4: call decode_aarch32_instrs_MSR_i_A1enc_AS_txt(s_1547_0, s_1547_1, s_1547_2, s_1547_3)
        let s_1547_4: () = decode_aarch32_instrs_MSR_i_A1enc_AS_txt(
            state,
            tracer,
            s_1547_0,
            s_1547_1,
            s_1547_2,
            s_1547_3,
        );
        // N s_1547_5: return
        return;
    }
    fn block_1548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1548_0: panic
        panic!("{:?}", ());
        // N s_1548_1: return
        return;
    }
    fn block_1549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1549_0: const #1u : u8
        let s_1549_0: bool = true;
        // D s_1549_1: write-var gs#407752 <= s_1549_0
        fn_state.gs_407752 = s_1549_0;
        // N s_1549_2: jump b1546
        return block_1546(state, tracer, fn_state);
    }
    fn block_1550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1550_0: const #1u : u8
        let s_1550_0: bool = true;
        // D s_1550_1: write-var gs#407749 <= s_1550_0
        fn_state.gs_407749 = s_1550_0;
        // N s_1550_2: jump b1544
        return block_1544(state, tracer, fn_state);
    }
    fn block_1551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1551_0: const #1u : u8
        let s_1551_0: bool = true;
        // D s_1551_1: write-var gs#407746 <= s_1551_0
        fn_state.gs_407746 = s_1551_0;
        // N s_1551_2: jump b1542
        return block_1542(state, tracer, fn_state);
    }
    fn block_1552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1552_0: read-var merge#var.1:struct
        let s_1552_0: u32 = fn_state.merge_var._1;
        // D s_1552_1: write-var u#33170 <= s_1552_0
        fn_state.u_33170 = s_1552_0;
        // C s_1552_2: const #23s : i
        let s_1552_2: i128 = 23;
        // D s_1552_3: read-var u#33170:u32
        let s_1552_3: u32 = fn_state.u_33170;
        // D s_1552_4: cast zx s_1552_3 -> bv
        let s_1552_4: Bits = Bits::new(s_1552_3 as u128, 32u16);
        // C s_1552_5: const #1s : i64
        let s_1552_5: i64 = 1;
        // C s_1552_6: cast zx s_1552_5 -> i
        let s_1552_6: i128 = (i128::try_from(s_1552_5).unwrap());
        // C s_1552_7: const #4s : i
        let s_1552_7: i128 = 4;
        // C s_1552_8: add s_1552_7 s_1552_6
        let s_1552_8: i128 = (s_1552_7 + s_1552_6);
        // D s_1552_9: bit-extract s_1552_4 s_1552_2 s_1552_8
        let s_1552_9: Bits = (Bits::new(
            ((s_1552_4) >> (s_1552_2)).value(),
            u16::try_from(s_1552_8).unwrap(),
        ));
        // D s_1552_10: cast reint s_1552_9 -> u8
        let s_1552_10: u8 = (s_1552_9.value() as u8);
        // D s_1552_11: cast zx s_1552_10 -> bv
        let s_1552_11: Bits = Bits::new(s_1552_10 as u128, 5u16);
        // C s_1552_12: const #2u : u8
        let s_1552_12: u8 = 2;
        // C s_1552_13: cast zx s_1552_12 -> bv
        let s_1552_13: Bits = Bits::new(s_1552_12 as u128, 5u16);
        // D s_1552_14: cmp-eq s_1552_11 s_1552_13
        let s_1552_14: bool = ((s_1552_11) == (s_1552_13));
        // N s_1552_15: branch s_1552_14 b2161 b1553
        if s_1552_14 {
            return block_2161(state, tracer, fn_state);
        } else {
            return block_1553(state, tracer, fn_state);
        };
    }
    fn block_1553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1553_0: const #0u : u8
        let s_1553_0: bool = false;
        // D s_1553_1: write-var gs#407761 <= s_1553_0
        fn_state.gs_407761 = s_1553_0;
        // N s_1553_2: jump b1554
        return block_1554(state, tracer, fn_state);
    }
    fn block_1554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1554_0: read-var gs#407761:u8
        let s_1554_0: bool = fn_state.gs_407761;
        // N s_1554_1: branch s_1554_0 b2157 b1555
        if s_1554_0 {
            return block_2157(state, tracer, fn_state);
        } else {
            return block_1555(state, tracer, fn_state);
        };
    }
    fn block_1555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1555_0: const #0u : u8
        let s_1555_0: bool = false;
        // D s_1555_1: write-var gs#407766 <= s_1555_0
        fn_state.gs_407766 = s_1555_0;
        // N s_1555_2: jump b1556
        return block_1556(state, tracer, fn_state);
    }
    fn block_1556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1556_0: read-var gs#407766:u8
        let s_1556_0: bool = fn_state.gs_407766;
        // D s_1556_1: not s_1556_0
        let s_1556_1: bool = !s_1556_0;
        // N s_1556_2: branch s_1556_1 b1578 b1557
        if s_1556_1 {
            return block_1578(state, tracer, fn_state);
        } else {
            return block_1557(state, tracer, fn_state);
        };
    }
    fn block_1557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1557_0: const #3785s : i
        let s_1557_0: i128 = 3785;
        // C s_1557_1: const #14696u : u32
        let s_1557_1: u32 = 14696;
        // N s_1557_2: write-reg s_1557_1 <= s_1557_0
        let s_1557_2: () = {
            state.write_register::<i128>(s_1557_1 as isize, s_1557_0);
            tracer.write_register(s_1557_1 as isize, s_1557_0);
        };
        // C s_1557_3: const #28s : i
        let s_1557_3: i128 = 28;
        // C s_1557_4: const #4s : i
        let s_1557_4: i128 = 4;
        // D s_1557_5: read-var u#33170:u32
        let s_1557_5: u32 = fn_state.u_33170;
        // D s_1557_6: cast zx s_1557_5 -> bv
        let s_1557_6: Bits = Bits::new(s_1557_5 as u128, 32u16);
        // D s_1557_7: bit-extract s_1557_6 s_1557_3 s_1557_4
        let s_1557_7: Bits = (Bits::new(
            ((s_1557_6) >> (s_1557_3)).value(),
            u16::try_from(s_1557_4).unwrap(),
        ));
        // D s_1557_8: cast reint s_1557_7 -> u8
        let s_1557_8: u8 = (s_1557_7.value() as u8);
        // D s_1557_9: write-var u#33171 <= s_1557_8
        fn_state.u_33171 = s_1557_8;
        // C s_1557_10: const #22s : i
        let s_1557_10: i128 = 22;
        // C s_1557_11: const #1s : i
        let s_1557_11: i128 = 1;
        // D s_1557_12: read-var u#33170:u32
        let s_1557_12: u32 = fn_state.u_33170;
        // D s_1557_13: cast zx s_1557_12 -> bv
        let s_1557_13: Bits = Bits::new(s_1557_12 as u128, 32u16);
        // D s_1557_14: bit-extract s_1557_13 s_1557_10 s_1557_11
        let s_1557_14: Bits = (Bits::new(
            ((s_1557_13) >> (s_1557_10)).value(),
            u16::try_from(s_1557_11).unwrap(),
        ));
        // D s_1557_15: cast reint s_1557_14 -> u8
        let s_1557_15: bool = ((s_1557_14.value()) != 0);
        // D s_1557_16: write-var u#33172 <= s_1557_15
        fn_state.u_33172 = s_1557_15;
        // C s_1557_17: const #16s : i
        let s_1557_17: i128 = 16;
        // C s_1557_18: const #4s : i
        let s_1557_18: i128 = 4;
        // D s_1557_19: read-var u#33170:u32
        let s_1557_19: u32 = fn_state.u_33170;
        // D s_1557_20: cast zx s_1557_19 -> bv
        let s_1557_20: Bits = Bits::new(s_1557_19 as u128, 32u16);
        // D s_1557_21: bit-extract s_1557_20 s_1557_17 s_1557_18
        let s_1557_21: Bits = (Bits::new(
            ((s_1557_20) >> (s_1557_17)).value(),
            u16::try_from(s_1557_18).unwrap(),
        ));
        // D s_1557_22: cast reint s_1557_21 -> u8
        let s_1557_22: u8 = (s_1557_21.value() as u8);
        // D s_1557_23: write-var u#33173 <= s_1557_22
        fn_state.u_33173 = s_1557_22;
        // C s_1557_24: const #0s : i
        let s_1557_24: i128 = 0;
        // C s_1557_25: const #4s : i
        let s_1557_25: i128 = 4;
        // D s_1557_26: read-var u#33170:u32
        let s_1557_26: u32 = fn_state.u_33170;
        // D s_1557_27: cast zx s_1557_26 -> bv
        let s_1557_27: Bits = Bits::new(s_1557_26 as u128, 32u16);
        // D s_1557_28: bit-extract s_1557_27 s_1557_24 s_1557_25
        let s_1557_28: Bits = (Bits::new(
            ((s_1557_27) >> (s_1557_24)).value(),
            u16::try_from(s_1557_25).unwrap(),
        ));
        // D s_1557_29: cast reint s_1557_28 -> u8
        let s_1557_29: u8 = (s_1557_28.value() as u8);
        // D s_1557_30: write-var u#33174 <= s_1557_29
        fn_state.u_33174 = s_1557_29;
        // C s_1557_31: const #12s : i
        let s_1557_31: i128 = 12;
        // D s_1557_32: read-var u#33170:u32
        let s_1557_32: u32 = fn_state.u_33170;
        // D s_1557_33: cast zx s_1557_32 -> bv
        let s_1557_33: Bits = Bits::new(s_1557_32 as u128, 32u16);
        // C s_1557_34: const #1u : u64
        let s_1557_34: u64 = 1;
        // D s_1557_35: bit-extract s_1557_33 s_1557_31 s_1557_34
        let s_1557_35: Bits = (Bits::new(
            ((s_1557_33) >> (s_1557_31)).value(),
            u16::try_from(s_1557_34).unwrap(),
        ));
        // D s_1557_36: cast reint s_1557_35 -> u8
        let s_1557_36: bool = ((s_1557_35.value()) != 0);
        // C s_1557_37: const #0s : i
        let s_1557_37: i128 = 0;
        // C s_1557_38: const #0u : u64
        let s_1557_38: u64 = 0;
        // D s_1557_39: cast zx s_1557_36 -> u64
        let s_1557_39: u64 = (s_1557_36 as u64);
        // C s_1557_40: const #1u : u64
        let s_1557_40: u64 = 1;
        // D s_1557_41: and s_1557_39 s_1557_40
        let s_1557_41: u64 = ((s_1557_39) & (s_1557_40));
        // D s_1557_42: cmp-eq s_1557_41 s_1557_40
        let s_1557_42: bool = ((s_1557_41) == (s_1557_40));
        // D s_1557_43: lsl s_1557_39 s_1557_37
        let s_1557_43: u64 = s_1557_39 << s_1557_37;
        // D s_1557_44: or s_1557_38 s_1557_43
        let s_1557_44: u64 = ((s_1557_38) | (s_1557_43));
        // D s_1557_45: cmpl s_1557_43
        let s_1557_45: u64 = !s_1557_43;
        // D s_1557_46: and s_1557_38 s_1557_45
        let s_1557_46: u64 = ((s_1557_38) & (s_1557_45));
        // D s_1557_47: select s_1557_42 s_1557_44 s_1557_46
        let s_1557_47: u64 = if s_1557_42 { s_1557_44 } else { s_1557_46 };
        // D s_1557_48: cast trunc s_1557_47 -> u8
        let s_1557_48: bool = ((s_1557_47) != 0);
        // D s_1557_49: cast zx s_1557_48 -> bv
        let s_1557_49: Bits = Bits::new(s_1557_48 as u128, 1u16);
        // C s_1557_50: const #1u : u8
        let s_1557_50: bool = true;
        // C s_1557_51: cast zx s_1557_50 -> bv
        let s_1557_51: Bits = Bits::new(s_1557_50 as u128, 1u16);
        // D s_1557_52: cmp-ne s_1557_49 s_1557_51
        let s_1557_52: bool = ((s_1557_49) != (s_1557_51));
        // N s_1557_53: branch s_1557_52 b1577 b1558
        if s_1557_52 {
            return block_1577(state, tracer, fn_state);
        } else {
            return block_1558(state, tracer, fn_state);
        };
    }
    fn block_1558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1558_0: const #13s : i
        let s_1558_0: i128 = 13;
        // D s_1558_1: read-var u#33170:u32
        let s_1558_1: u32 = fn_state.u_33170;
        // D s_1558_2: cast zx s_1558_1 -> bv
        let s_1558_2: Bits = Bits::new(s_1558_1 as u128, 32u16);
        // C s_1558_3: const #1u : u64
        let s_1558_3: u64 = 1;
        // D s_1558_4: bit-extract s_1558_2 s_1558_0 s_1558_3
        let s_1558_4: Bits = (Bits::new(
            ((s_1558_2) >> (s_1558_0)).value(),
            u16::try_from(s_1558_3).unwrap(),
        ));
        // D s_1558_5: cast reint s_1558_4 -> u8
        let s_1558_5: bool = ((s_1558_4.value()) != 0);
        // C s_1558_6: const #0s : i
        let s_1558_6: i128 = 0;
        // C s_1558_7: const #0u : u64
        let s_1558_7: u64 = 0;
        // D s_1558_8: cast zx s_1558_5 -> u64
        let s_1558_8: u64 = (s_1558_5 as u64);
        // C s_1558_9: const #1u : u64
        let s_1558_9: u64 = 1;
        // D s_1558_10: and s_1558_8 s_1558_9
        let s_1558_10: u64 = ((s_1558_8) & (s_1558_9));
        // D s_1558_11: cmp-eq s_1558_10 s_1558_9
        let s_1558_11: bool = ((s_1558_10) == (s_1558_9));
        // D s_1558_12: lsl s_1558_8 s_1558_6
        let s_1558_12: u64 = s_1558_8 << s_1558_6;
        // D s_1558_13: or s_1558_7 s_1558_12
        let s_1558_13: u64 = ((s_1558_7) | (s_1558_12));
        // D s_1558_14: cmpl s_1558_12
        let s_1558_14: u64 = !s_1558_12;
        // D s_1558_15: and s_1558_7 s_1558_14
        let s_1558_15: u64 = ((s_1558_7) & (s_1558_14));
        // D s_1558_16: select s_1558_11 s_1558_13 s_1558_15
        let s_1558_16: u64 = if s_1558_11 { s_1558_13 } else { s_1558_15 };
        // D s_1558_17: cast trunc s_1558_16 -> u8
        let s_1558_17: bool = ((s_1558_16) != 0);
        // D s_1558_18: cast zx s_1558_17 -> bv
        let s_1558_18: Bits = Bits::new(s_1558_17 as u128, 1u16);
        // C s_1558_19: const #1u : u8
        let s_1558_19: bool = true;
        // C s_1558_20: cast zx s_1558_19 -> bv
        let s_1558_20: Bits = Bits::new(s_1558_19 as u128, 1u16);
        // D s_1558_21: cmp-ne s_1558_18 s_1558_20
        let s_1558_21: bool = ((s_1558_18) != (s_1558_20));
        // D s_1558_22: write-var gs#407781 <= s_1558_21
        fn_state.gs_407781 = s_1558_21;
        // N s_1558_23: jump b1559
        return block_1559(state, tracer, fn_state);
    }
    fn block_1559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1559_0: read-var gs#407781:u8
        let s_1559_0: bool = fn_state.gs_407781;
        // N s_1559_1: branch s_1559_0 b1576 b1560
        if s_1559_0 {
            return block_1576(state, tracer, fn_state);
        } else {
            return block_1560(state, tracer, fn_state);
        };
    }
    fn block_1560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1560_0: const #14s : i
        let s_1560_0: i128 = 14;
        // D s_1560_1: read-var u#33170:u32
        let s_1560_1: u32 = fn_state.u_33170;
        // D s_1560_2: cast zx s_1560_1 -> bv
        let s_1560_2: Bits = Bits::new(s_1560_1 as u128, 32u16);
        // C s_1560_3: const #1u : u64
        let s_1560_3: u64 = 1;
        // D s_1560_4: bit-extract s_1560_2 s_1560_0 s_1560_3
        let s_1560_4: Bits = (Bits::new(
            ((s_1560_2) >> (s_1560_0)).value(),
            u16::try_from(s_1560_3).unwrap(),
        ));
        // D s_1560_5: cast reint s_1560_4 -> u8
        let s_1560_5: bool = ((s_1560_4.value()) != 0);
        // C s_1560_6: const #0s : i
        let s_1560_6: i128 = 0;
        // C s_1560_7: const #0u : u64
        let s_1560_7: u64 = 0;
        // D s_1560_8: cast zx s_1560_5 -> u64
        let s_1560_8: u64 = (s_1560_5 as u64);
        // C s_1560_9: const #1u : u64
        let s_1560_9: u64 = 1;
        // D s_1560_10: and s_1560_8 s_1560_9
        let s_1560_10: u64 = ((s_1560_8) & (s_1560_9));
        // D s_1560_11: cmp-eq s_1560_10 s_1560_9
        let s_1560_11: bool = ((s_1560_10) == (s_1560_9));
        // D s_1560_12: lsl s_1560_8 s_1560_6
        let s_1560_12: u64 = s_1560_8 << s_1560_6;
        // D s_1560_13: or s_1560_7 s_1560_12
        let s_1560_13: u64 = ((s_1560_7) | (s_1560_12));
        // D s_1560_14: cmpl s_1560_12
        let s_1560_14: u64 = !s_1560_12;
        // D s_1560_15: and s_1560_7 s_1560_14
        let s_1560_15: u64 = ((s_1560_7) & (s_1560_14));
        // D s_1560_16: select s_1560_11 s_1560_13 s_1560_15
        let s_1560_16: u64 = if s_1560_11 { s_1560_13 } else { s_1560_15 };
        // D s_1560_17: cast trunc s_1560_16 -> u8
        let s_1560_17: bool = ((s_1560_16) != 0);
        // D s_1560_18: cast zx s_1560_17 -> bv
        let s_1560_18: Bits = Bits::new(s_1560_17 as u128, 1u16);
        // C s_1560_19: const #1u : u8
        let s_1560_19: bool = true;
        // C s_1560_20: cast zx s_1560_19 -> bv
        let s_1560_20: Bits = Bits::new(s_1560_19 as u128, 1u16);
        // D s_1560_21: cmp-ne s_1560_18 s_1560_20
        let s_1560_21: bool = ((s_1560_18) != (s_1560_20));
        // D s_1560_22: write-var gs#407784 <= s_1560_21
        fn_state.gs_407784 = s_1560_21;
        // N s_1560_23: jump b1561
        return block_1561(state, tracer, fn_state);
    }
    fn block_1561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1561_0: read-var gs#407784:u8
        let s_1561_0: bool = fn_state.gs_407784;
        // N s_1561_1: branch s_1561_0 b1575 b1562
        if s_1561_0 {
            return block_1575(state, tracer, fn_state);
        } else {
            return block_1562(state, tracer, fn_state);
        };
    }
    fn block_1562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1562_0: const #15s : i
        let s_1562_0: i128 = 15;
        // D s_1562_1: read-var u#33170:u32
        let s_1562_1: u32 = fn_state.u_33170;
        // D s_1562_2: cast zx s_1562_1 -> bv
        let s_1562_2: Bits = Bits::new(s_1562_1 as u128, 32u16);
        // C s_1562_3: const #1u : u64
        let s_1562_3: u64 = 1;
        // D s_1562_4: bit-extract s_1562_2 s_1562_0 s_1562_3
        let s_1562_4: Bits = (Bits::new(
            ((s_1562_2) >> (s_1562_0)).value(),
            u16::try_from(s_1562_3).unwrap(),
        ));
        // D s_1562_5: cast reint s_1562_4 -> u8
        let s_1562_5: bool = ((s_1562_4.value()) != 0);
        // C s_1562_6: const #0s : i
        let s_1562_6: i128 = 0;
        // C s_1562_7: const #0u : u64
        let s_1562_7: u64 = 0;
        // D s_1562_8: cast zx s_1562_5 -> u64
        let s_1562_8: u64 = (s_1562_5 as u64);
        // C s_1562_9: const #1u : u64
        let s_1562_9: u64 = 1;
        // D s_1562_10: and s_1562_8 s_1562_9
        let s_1562_10: u64 = ((s_1562_8) & (s_1562_9));
        // D s_1562_11: cmp-eq s_1562_10 s_1562_9
        let s_1562_11: bool = ((s_1562_10) == (s_1562_9));
        // D s_1562_12: lsl s_1562_8 s_1562_6
        let s_1562_12: u64 = s_1562_8 << s_1562_6;
        // D s_1562_13: or s_1562_7 s_1562_12
        let s_1562_13: u64 = ((s_1562_7) | (s_1562_12));
        // D s_1562_14: cmpl s_1562_12
        let s_1562_14: u64 = !s_1562_12;
        // D s_1562_15: and s_1562_7 s_1562_14
        let s_1562_15: u64 = ((s_1562_7) & (s_1562_14));
        // D s_1562_16: select s_1562_11 s_1562_13 s_1562_15
        let s_1562_16: u64 = if s_1562_11 { s_1562_13 } else { s_1562_15 };
        // D s_1562_17: cast trunc s_1562_16 -> u8
        let s_1562_17: bool = ((s_1562_16) != 0);
        // D s_1562_18: cast zx s_1562_17 -> bv
        let s_1562_18: Bits = Bits::new(s_1562_17 as u128, 1u16);
        // C s_1562_19: const #1u : u8
        let s_1562_19: bool = true;
        // C s_1562_20: cast zx s_1562_19 -> bv
        let s_1562_20: Bits = Bits::new(s_1562_19 as u128, 1u16);
        // D s_1562_21: cmp-ne s_1562_18 s_1562_20
        let s_1562_21: bool = ((s_1562_18) != (s_1562_20));
        // D s_1562_22: write-var gs#407787 <= s_1562_21
        fn_state.gs_407787 = s_1562_21;
        // N s_1562_23: jump b1563
        return block_1563(state, tracer, fn_state);
    }
    fn block_1563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1563_0: read-var gs#407787:u8
        let s_1563_0: bool = fn_state.gs_407787;
        // N s_1563_1: branch s_1563_0 b1574 b1564
        if s_1563_0 {
            return block_1574(state, tracer, fn_state);
        } else {
            return block_1564(state, tracer, fn_state);
        };
    }
    fn block_1564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1564_0: const #10s : i
        let s_1564_0: i128 = 10;
        // D s_1564_1: read-var u#33170:u32
        let s_1564_1: u32 = fn_state.u_33170;
        // D s_1564_2: cast zx s_1564_1 -> bv
        let s_1564_2: Bits = Bits::new(s_1564_1 as u128, 32u16);
        // C s_1564_3: const #1u : u64
        let s_1564_3: u64 = 1;
        // D s_1564_4: bit-extract s_1564_2 s_1564_0 s_1564_3
        let s_1564_4: Bits = (Bits::new(
            ((s_1564_2) >> (s_1564_0)).value(),
            u16::try_from(s_1564_3).unwrap(),
        ));
        // D s_1564_5: cast reint s_1564_4 -> u8
        let s_1564_5: bool = ((s_1564_4.value()) != 0);
        // C s_1564_6: const #0s : i
        let s_1564_6: i128 = 0;
        // C s_1564_7: const #0u : u64
        let s_1564_7: u64 = 0;
        // D s_1564_8: cast zx s_1564_5 -> u64
        let s_1564_8: u64 = (s_1564_5 as u64);
        // C s_1564_9: const #1u : u64
        let s_1564_9: u64 = 1;
        // D s_1564_10: and s_1564_8 s_1564_9
        let s_1564_10: u64 = ((s_1564_8) & (s_1564_9));
        // D s_1564_11: cmp-eq s_1564_10 s_1564_9
        let s_1564_11: bool = ((s_1564_10) == (s_1564_9));
        // D s_1564_12: lsl s_1564_8 s_1564_6
        let s_1564_12: u64 = s_1564_8 << s_1564_6;
        // D s_1564_13: or s_1564_7 s_1564_12
        let s_1564_13: u64 = ((s_1564_7) | (s_1564_12));
        // D s_1564_14: cmpl s_1564_12
        let s_1564_14: u64 = !s_1564_12;
        // D s_1564_15: and s_1564_7 s_1564_14
        let s_1564_15: u64 = ((s_1564_7) & (s_1564_14));
        // D s_1564_16: select s_1564_11 s_1564_13 s_1564_15
        let s_1564_16: u64 = if s_1564_11 { s_1564_13 } else { s_1564_15 };
        // D s_1564_17: cast trunc s_1564_16 -> u8
        let s_1564_17: bool = ((s_1564_16) != 0);
        // D s_1564_18: cast zx s_1564_17 -> bv
        let s_1564_18: Bits = Bits::new(s_1564_17 as u128, 1u16);
        // C s_1564_19: const #0u : u8
        let s_1564_19: bool = false;
        // C s_1564_20: cast zx s_1564_19 -> bv
        let s_1564_20: Bits = Bits::new(s_1564_19 as u128, 1u16);
        // D s_1564_21: cmp-ne s_1564_18 s_1564_20
        let s_1564_21: bool = ((s_1564_18) != (s_1564_20));
        // D s_1564_22: write-var gs#407790 <= s_1564_21
        fn_state.gs_407790 = s_1564_21;
        // N s_1564_23: jump b1565
        return block_1565(state, tracer, fn_state);
    }
    fn block_1565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1565_0: read-var gs#407790:u8
        let s_1565_0: bool = fn_state.gs_407790;
        // N s_1565_1: branch s_1565_0 b1573 b1566
        if s_1565_0 {
            return block_1573(state, tracer, fn_state);
        } else {
            return block_1566(state, tracer, fn_state);
        };
    }
    fn block_1566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1566_0: const #11s : i
        let s_1566_0: i128 = 11;
        // D s_1566_1: read-var u#33170:u32
        let s_1566_1: u32 = fn_state.u_33170;
        // D s_1566_2: cast zx s_1566_1 -> bv
        let s_1566_2: Bits = Bits::new(s_1566_1 as u128, 32u16);
        // C s_1566_3: const #1u : u64
        let s_1566_3: u64 = 1;
        // D s_1566_4: bit-extract s_1566_2 s_1566_0 s_1566_3
        let s_1566_4: Bits = (Bits::new(
            ((s_1566_2) >> (s_1566_0)).value(),
            u16::try_from(s_1566_3).unwrap(),
        ));
        // D s_1566_5: cast reint s_1566_4 -> u8
        let s_1566_5: bool = ((s_1566_4.value()) != 0);
        // C s_1566_6: const #0s : i
        let s_1566_6: i128 = 0;
        // C s_1566_7: const #0u : u64
        let s_1566_7: u64 = 0;
        // D s_1566_8: cast zx s_1566_5 -> u64
        let s_1566_8: u64 = (s_1566_5 as u64);
        // C s_1566_9: const #1u : u64
        let s_1566_9: u64 = 1;
        // D s_1566_10: and s_1566_8 s_1566_9
        let s_1566_10: u64 = ((s_1566_8) & (s_1566_9));
        // D s_1566_11: cmp-eq s_1566_10 s_1566_9
        let s_1566_11: bool = ((s_1566_10) == (s_1566_9));
        // D s_1566_12: lsl s_1566_8 s_1566_6
        let s_1566_12: u64 = s_1566_8 << s_1566_6;
        // D s_1566_13: or s_1566_7 s_1566_12
        let s_1566_13: u64 = ((s_1566_7) | (s_1566_12));
        // D s_1566_14: cmpl s_1566_12
        let s_1566_14: u64 = !s_1566_12;
        // D s_1566_15: and s_1566_7 s_1566_14
        let s_1566_15: u64 = ((s_1566_7) & (s_1566_14));
        // D s_1566_16: select s_1566_11 s_1566_13 s_1566_15
        let s_1566_16: u64 = if s_1566_11 { s_1566_13 } else { s_1566_15 };
        // D s_1566_17: cast trunc s_1566_16 -> u8
        let s_1566_17: bool = ((s_1566_16) != 0);
        // D s_1566_18: cast zx s_1566_17 -> bv
        let s_1566_18: Bits = Bits::new(s_1566_17 as u128, 1u16);
        // C s_1566_19: const #0u : u8
        let s_1566_19: bool = false;
        // C s_1566_20: cast zx s_1566_19 -> bv
        let s_1566_20: Bits = Bits::new(s_1566_19 as u128, 1u16);
        // D s_1566_21: cmp-ne s_1566_18 s_1566_20
        let s_1566_21: bool = ((s_1566_18) != (s_1566_20));
        // D s_1566_22: write-var gs#407793 <= s_1566_21
        fn_state.gs_407793 = s_1566_21;
        // N s_1566_23: jump b1567
        return block_1567(state, tracer, fn_state);
    }
    fn block_1567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1567_0: read-var gs#407793:u8
        let s_1567_0: bool = fn_state.gs_407793;
        // N s_1567_1: branch s_1567_0 b1572 b1568
        if s_1567_0 {
            return block_1572(state, tracer, fn_state);
        } else {
            return block_1568(state, tracer, fn_state);
        };
    }
    fn block_1568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1568_0: const #8s : i
        let s_1568_0: i128 = 8;
        // D s_1568_1: read-var u#33170:u32
        let s_1568_1: u32 = fn_state.u_33170;
        // D s_1568_2: cast zx s_1568_1 -> bv
        let s_1568_2: Bits = Bits::new(s_1568_1 as u128, 32u16);
        // C s_1568_3: const #1u : u64
        let s_1568_3: u64 = 1;
        // D s_1568_4: bit-extract s_1568_2 s_1568_0 s_1568_3
        let s_1568_4: Bits = (Bits::new(
            ((s_1568_2) >> (s_1568_0)).value(),
            u16::try_from(s_1568_3).unwrap(),
        ));
        // D s_1568_5: cast reint s_1568_4 -> u8
        let s_1568_5: bool = ((s_1568_4.value()) != 0);
        // C s_1568_6: const #0s : i
        let s_1568_6: i128 = 0;
        // C s_1568_7: const #0u : u64
        let s_1568_7: u64 = 0;
        // D s_1568_8: cast zx s_1568_5 -> u64
        let s_1568_8: u64 = (s_1568_5 as u64);
        // C s_1568_9: const #1u : u64
        let s_1568_9: u64 = 1;
        // D s_1568_10: and s_1568_8 s_1568_9
        let s_1568_10: u64 = ((s_1568_8) & (s_1568_9));
        // D s_1568_11: cmp-eq s_1568_10 s_1568_9
        let s_1568_11: bool = ((s_1568_10) == (s_1568_9));
        // D s_1568_12: lsl s_1568_8 s_1568_6
        let s_1568_12: u64 = s_1568_8 << s_1568_6;
        // D s_1568_13: or s_1568_7 s_1568_12
        let s_1568_13: u64 = ((s_1568_7) | (s_1568_12));
        // D s_1568_14: cmpl s_1568_12
        let s_1568_14: u64 = !s_1568_12;
        // D s_1568_15: and s_1568_7 s_1568_14
        let s_1568_15: u64 = ((s_1568_7) & (s_1568_14));
        // D s_1568_16: select s_1568_11 s_1568_13 s_1568_15
        let s_1568_16: u64 = if s_1568_11 { s_1568_13 } else { s_1568_15 };
        // D s_1568_17: cast trunc s_1568_16 -> u8
        let s_1568_17: bool = ((s_1568_16) != 0);
        // D s_1568_18: cast zx s_1568_17 -> bv
        let s_1568_18: Bits = Bits::new(s_1568_17 as u128, 1u16);
        // C s_1568_19: const #0u : u8
        let s_1568_19: bool = false;
        // C s_1568_20: cast zx s_1568_19 -> bv
        let s_1568_20: Bits = Bits::new(s_1568_19 as u128, 1u16);
        // D s_1568_21: cmp-ne s_1568_18 s_1568_20
        let s_1568_21: bool = ((s_1568_18) != (s_1568_20));
        // D s_1568_22: write-var gs#407796 <= s_1568_21
        fn_state.gs_407796 = s_1568_21;
        // N s_1568_23: jump b1569
        return block_1569(state, tracer, fn_state);
    }
    fn block_1569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1569_0: read-var gs#407796:u8
        let s_1569_0: bool = fn_state.gs_407796;
        // N s_1569_1: branch s_1569_0 b1571 b1570
        if s_1569_0 {
            return block_1571(state, tracer, fn_state);
        } else {
            return block_1570(state, tracer, fn_state);
        };
    }
    fn block_1570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1570_0: read-var u#33171:u8
        let s_1570_0: u8 = fn_state.u_33171;
        // D s_1570_1: read-var u#33172:u8
        let s_1570_1: bool = fn_state.u_33172;
        // D s_1570_2: read-var u#33173:u8
        let s_1570_2: u8 = fn_state.u_33173;
        // D s_1570_3: read-var u#33174:u8
        let s_1570_3: u8 = fn_state.u_33174;
        // D s_1570_4: call decode_aarch32_instrs_MSR_r_A1enc_AS_txt(s_1570_0, s_1570_1, s_1570_2, s_1570_3)
        let s_1570_4: () = decode_aarch32_instrs_MSR_r_A1enc_AS_txt(
            state,
            tracer,
            s_1570_0,
            s_1570_1,
            s_1570_2,
            s_1570_3,
        );
        // N s_1570_5: return
        return;
    }
    fn block_1571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1571_0: panic
        panic!("{:?}", ());
        // N s_1571_1: return
        return;
    }
    fn block_1572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1572_0: const #1u : u8
        let s_1572_0: bool = true;
        // D s_1572_1: write-var gs#407796 <= s_1572_0
        fn_state.gs_407796 = s_1572_0;
        // N s_1572_2: jump b1569
        return block_1569(state, tracer, fn_state);
    }
    fn block_1573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1573_0: const #1u : u8
        let s_1573_0: bool = true;
        // D s_1573_1: write-var gs#407793 <= s_1573_0
        fn_state.gs_407793 = s_1573_0;
        // N s_1573_2: jump b1567
        return block_1567(state, tracer, fn_state);
    }
    fn block_1574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1574_0: const #1u : u8
        let s_1574_0: bool = true;
        // D s_1574_1: write-var gs#407790 <= s_1574_0
        fn_state.gs_407790 = s_1574_0;
        // N s_1574_2: jump b1565
        return block_1565(state, tracer, fn_state);
    }
    fn block_1575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1575_0: const #1u : u8
        let s_1575_0: bool = true;
        // D s_1575_1: write-var gs#407787 <= s_1575_0
        fn_state.gs_407787 = s_1575_0;
        // N s_1575_2: jump b1563
        return block_1563(state, tracer, fn_state);
    }
    fn block_1576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1576_0: const #1u : u8
        let s_1576_0: bool = true;
        // D s_1576_1: write-var gs#407784 <= s_1576_0
        fn_state.gs_407784 = s_1576_0;
        // N s_1576_2: jump b1561
        return block_1561(state, tracer, fn_state);
    }
    fn block_1577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1577_0: const #1u : u8
        let s_1577_0: bool = true;
        // D s_1577_1: write-var gs#407781 <= s_1577_0
        fn_state.gs_407781 = s_1577_0;
        // N s_1577_2: jump b1559
        return block_1559(state, tracer, fn_state);
    }
    fn block_1578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1578_0: read-var merge#var.1:struct
        let s_1578_0: u32 = fn_state.merge_var._1;
        // D s_1578_1: write-var u#33176 <= s_1578_0
        fn_state.u_33176 = s_1578_0;
        // C s_1578_2: const #4s : i
        let s_1578_2: i128 = 4;
        // D s_1578_3: read-var u#33176:u32
        let s_1578_3: u32 = fn_state.u_33176;
        // D s_1578_4: cast zx s_1578_3 -> bv
        let s_1578_4: Bits = Bits::new(s_1578_3 as u128, 32u16);
        // C s_1578_5: const #1s : i64
        let s_1578_5: i64 = 1;
        // C s_1578_6: cast zx s_1578_5 -> i
        let s_1578_6: i128 = (i128::try_from(s_1578_5).unwrap());
        // C s_1578_7: const #23s : i
        let s_1578_7: i128 = 23;
        // C s_1578_8: add s_1578_7 s_1578_6
        let s_1578_8: i128 = (s_1578_7 + s_1578_6);
        // D s_1578_9: bit-extract s_1578_4 s_1578_2 s_1578_8
        let s_1578_9: Bits = (Bits::new(
            ((s_1578_4) >> (s_1578_2)).value(),
            u16::try_from(s_1578_8).unwrap(),
        ));
        // D s_1578_10: cast reint s_1578_9 -> u24
        let s_1578_10: u32 = (s_1578_9.value() as u32);
        // D s_1578_11: cast zx s_1578_10 -> bv
        let s_1578_11: Bits = Bits::new(s_1578_10 as u128, 24u16);
        // C s_1578_12: const #1441799u : u24
        let s_1578_12: u32 = 1441799;
        // C s_1578_13: cast zx s_1578_12 -> bv
        let s_1578_13: Bits = Bits::new(s_1578_12 as u128, 24u16);
        // D s_1578_14: cmp-eq s_1578_11 s_1578_13
        let s_1578_14: bool = ((s_1578_11) == (s_1578_13));
        // N s_1578_15: branch s_1578_14 b2153 b1579
        if s_1578_14 {
            return block_2153(state, tracer, fn_state);
        } else {
            return block_1579(state, tracer, fn_state);
        };
    }
    fn block_1579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1579_0: const #0u : u8
        let s_1579_0: bool = false;
        // D s_1579_1: write-var gs#407804 <= s_1579_0
        fn_state.gs_407804 = s_1579_0;
        // N s_1579_2: jump b1580
        return block_1580(state, tracer, fn_state);
    }
    fn block_1580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1580_0: read-var gs#407804:u8
        let s_1580_0: bool = fn_state.gs_407804;
        // D s_1580_1: not s_1580_0
        let s_1580_1: bool = !s_1580_0;
        // N s_1580_2: branch s_1580_1 b1617 b1581
        if s_1580_1 {
            return block_1617(state, tracer, fn_state);
        } else {
            return block_1581(state, tracer, fn_state);
        };
    }
    fn block_1581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1581_0: const #3790s : i
        let s_1581_0: i128 = 3790;
        // C s_1581_1: const #14696u : u32
        let s_1581_1: u32 = 14696;
        // N s_1581_2: write-reg s_1581_1 <= s_1581_0
        let s_1581_2: () = {
            state.write_register::<i128>(s_1581_1 as isize, s_1581_0);
            tracer.write_register(s_1581_1 as isize, s_1581_0);
        };
        // C s_1581_3: const #28s : i
        let s_1581_3: i128 = 28;
        // C s_1581_4: const #4s : i
        let s_1581_4: i128 = 4;
        // D s_1581_5: read-var u#33176:u32
        let s_1581_5: u32 = fn_state.u_33176;
        // D s_1581_6: cast zx s_1581_5 -> bv
        let s_1581_6: Bits = Bits::new(s_1581_5 as u128, 32u16);
        // D s_1581_7: bit-extract s_1581_6 s_1581_3 s_1581_4
        let s_1581_7: Bits = (Bits::new(
            ((s_1581_6) >> (s_1581_3)).value(),
            u16::try_from(s_1581_4).unwrap(),
        ));
        // D s_1581_8: cast reint s_1581_7 -> u8
        let s_1581_8: u8 = (s_1581_7.value() as u8);
        // D s_1581_9: write-var u#33177 <= s_1581_8
        fn_state.u_33177 = s_1581_8;
        // C s_1581_10: const #0s : i
        let s_1581_10: i128 = 0;
        // C s_1581_11: const #4s : i
        let s_1581_11: i128 = 4;
        // D s_1581_12: read-var u#33176:u32
        let s_1581_12: u32 = fn_state.u_33176;
        // D s_1581_13: cast zx s_1581_12 -> bv
        let s_1581_13: Bits = Bits::new(s_1581_12 as u128, 32u16);
        // D s_1581_14: bit-extract s_1581_13 s_1581_10 s_1581_11
        let s_1581_14: Bits = (Bits::new(
            ((s_1581_13) >> (s_1581_10)).value(),
            u16::try_from(s_1581_11).unwrap(),
        ));
        // D s_1581_15: cast reint s_1581_14 -> u8
        let s_1581_15: u8 = (s_1581_14.value() as u8);
        // D s_1581_16: write-var u#33178 <= s_1581_15
        fn_state.u_33178 = s_1581_15;
        // C s_1581_17: const #8s : i
        let s_1581_17: i128 = 8;
        // D s_1581_18: read-var u#33176:u32
        let s_1581_18: u32 = fn_state.u_33176;
        // D s_1581_19: cast zx s_1581_18 -> bv
        let s_1581_19: Bits = Bits::new(s_1581_18 as u128, 32u16);
        // C s_1581_20: const #1u : u64
        let s_1581_20: u64 = 1;
        // D s_1581_21: bit-extract s_1581_19 s_1581_17 s_1581_20
        let s_1581_21: Bits = (Bits::new(
            ((s_1581_19) >> (s_1581_17)).value(),
            u16::try_from(s_1581_20).unwrap(),
        ));
        // D s_1581_22: cast reint s_1581_21 -> u8
        let s_1581_22: bool = ((s_1581_21.value()) != 0);
        // C s_1581_23: const #0s : i
        let s_1581_23: i128 = 0;
        // C s_1581_24: const #0u : u64
        let s_1581_24: u64 = 0;
        // D s_1581_25: cast zx s_1581_22 -> u64
        let s_1581_25: u64 = (s_1581_22 as u64);
        // C s_1581_26: const #1u : u64
        let s_1581_26: u64 = 1;
        // D s_1581_27: and s_1581_25 s_1581_26
        let s_1581_27: u64 = ((s_1581_25) & (s_1581_26));
        // D s_1581_28: cmp-eq s_1581_27 s_1581_26
        let s_1581_28: bool = ((s_1581_27) == (s_1581_26));
        // D s_1581_29: lsl s_1581_25 s_1581_23
        let s_1581_29: u64 = s_1581_25 << s_1581_23;
        // D s_1581_30: or s_1581_24 s_1581_29
        let s_1581_30: u64 = ((s_1581_24) | (s_1581_29));
        // D s_1581_31: cmpl s_1581_29
        let s_1581_31: u64 = !s_1581_29;
        // D s_1581_32: and s_1581_24 s_1581_31
        let s_1581_32: u64 = ((s_1581_24) & (s_1581_31));
        // D s_1581_33: select s_1581_28 s_1581_30 s_1581_32
        let s_1581_33: u64 = if s_1581_28 { s_1581_30 } else { s_1581_32 };
        // D s_1581_34: cast trunc s_1581_33 -> u8
        let s_1581_34: bool = ((s_1581_33) != 0);
        // D s_1581_35: cast zx s_1581_34 -> bv
        let s_1581_35: Bits = Bits::new(s_1581_34 as u128, 1u16);
        // C s_1581_36: const #0u : u8
        let s_1581_36: bool = false;
        // C s_1581_37: cast zx s_1581_36 -> bv
        let s_1581_37: Bits = Bits::new(s_1581_36 as u128, 1u16);
        // D s_1581_38: cmp-ne s_1581_35 s_1581_37
        let s_1581_38: bool = ((s_1581_35) != (s_1581_37));
        // N s_1581_39: branch s_1581_38 b1616 b1582
        if s_1581_38 {
            return block_1616(state, tracer, fn_state);
        } else {
            return block_1582(state, tracer, fn_state);
        };
    }
    fn block_1582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1582_0: const #9s : i
        let s_1582_0: i128 = 9;
        // D s_1582_1: read-var u#33176:u32
        let s_1582_1: u32 = fn_state.u_33176;
        // D s_1582_2: cast zx s_1582_1 -> bv
        let s_1582_2: Bits = Bits::new(s_1582_1 as u128, 32u16);
        // C s_1582_3: const #1u : u64
        let s_1582_3: u64 = 1;
        // D s_1582_4: bit-extract s_1582_2 s_1582_0 s_1582_3
        let s_1582_4: Bits = (Bits::new(
            ((s_1582_2) >> (s_1582_0)).value(),
            u16::try_from(s_1582_3).unwrap(),
        ));
        // D s_1582_5: cast reint s_1582_4 -> u8
        let s_1582_5: bool = ((s_1582_4.value()) != 0);
        // C s_1582_6: const #0s : i
        let s_1582_6: i128 = 0;
        // C s_1582_7: const #0u : u64
        let s_1582_7: u64 = 0;
        // D s_1582_8: cast zx s_1582_5 -> u64
        let s_1582_8: u64 = (s_1582_5 as u64);
        // C s_1582_9: const #1u : u64
        let s_1582_9: u64 = 1;
        // D s_1582_10: and s_1582_8 s_1582_9
        let s_1582_10: u64 = ((s_1582_8) & (s_1582_9));
        // D s_1582_11: cmp-eq s_1582_10 s_1582_9
        let s_1582_11: bool = ((s_1582_10) == (s_1582_9));
        // D s_1582_12: lsl s_1582_8 s_1582_6
        let s_1582_12: u64 = s_1582_8 << s_1582_6;
        // D s_1582_13: or s_1582_7 s_1582_12
        let s_1582_13: u64 = ((s_1582_7) | (s_1582_12));
        // D s_1582_14: cmpl s_1582_12
        let s_1582_14: u64 = !s_1582_12;
        // D s_1582_15: and s_1582_7 s_1582_14
        let s_1582_15: u64 = ((s_1582_7) & (s_1582_14));
        // D s_1582_16: select s_1582_11 s_1582_13 s_1582_15
        let s_1582_16: u64 = if s_1582_11 { s_1582_13 } else { s_1582_15 };
        // D s_1582_17: cast trunc s_1582_16 -> u8
        let s_1582_17: bool = ((s_1582_16) != 0);
        // D s_1582_18: cast zx s_1582_17 -> bv
        let s_1582_18: Bits = Bits::new(s_1582_17 as u128, 1u16);
        // C s_1582_19: const #0u : u8
        let s_1582_19: bool = false;
        // C s_1582_20: cast zx s_1582_19 -> bv
        let s_1582_20: Bits = Bits::new(s_1582_19 as u128, 1u16);
        // D s_1582_21: cmp-ne s_1582_18 s_1582_20
        let s_1582_21: bool = ((s_1582_18) != (s_1582_20));
        // D s_1582_22: write-var gs#407815 <= s_1582_21
        fn_state.gs_407815 = s_1582_21;
        // N s_1582_23: jump b1583
        return block_1583(state, tracer, fn_state);
    }
    fn block_1583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1583_0: read-var gs#407815:u8
        let s_1583_0: bool = fn_state.gs_407815;
        // N s_1583_1: branch s_1583_0 b1615 b1584
        if s_1583_0 {
            return block_1615(state, tracer, fn_state);
        } else {
            return block_1584(state, tracer, fn_state);
        };
    }
    fn block_1584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1584_0: const #10s : i
        let s_1584_0: i128 = 10;
        // D s_1584_1: read-var u#33176:u32
        let s_1584_1: u32 = fn_state.u_33176;
        // D s_1584_2: cast zx s_1584_1 -> bv
        let s_1584_2: Bits = Bits::new(s_1584_1 as u128, 32u16);
        // C s_1584_3: const #1u : u64
        let s_1584_3: u64 = 1;
        // D s_1584_4: bit-extract s_1584_2 s_1584_0 s_1584_3
        let s_1584_4: Bits = (Bits::new(
            ((s_1584_2) >> (s_1584_0)).value(),
            u16::try_from(s_1584_3).unwrap(),
        ));
        // D s_1584_5: cast reint s_1584_4 -> u8
        let s_1584_5: bool = ((s_1584_4.value()) != 0);
        // C s_1584_6: const #0s : i
        let s_1584_6: i128 = 0;
        // C s_1584_7: const #0u : u64
        let s_1584_7: u64 = 0;
        // D s_1584_8: cast zx s_1584_5 -> u64
        let s_1584_8: u64 = (s_1584_5 as u64);
        // C s_1584_9: const #1u : u64
        let s_1584_9: u64 = 1;
        // D s_1584_10: and s_1584_8 s_1584_9
        let s_1584_10: u64 = ((s_1584_8) & (s_1584_9));
        // D s_1584_11: cmp-eq s_1584_10 s_1584_9
        let s_1584_11: bool = ((s_1584_10) == (s_1584_9));
        // D s_1584_12: lsl s_1584_8 s_1584_6
        let s_1584_12: u64 = s_1584_8 << s_1584_6;
        // D s_1584_13: or s_1584_7 s_1584_12
        let s_1584_13: u64 = ((s_1584_7) | (s_1584_12));
        // D s_1584_14: cmpl s_1584_12
        let s_1584_14: u64 = !s_1584_12;
        // D s_1584_15: and s_1584_7 s_1584_14
        let s_1584_15: u64 = ((s_1584_7) & (s_1584_14));
        // D s_1584_16: select s_1584_11 s_1584_13 s_1584_15
        let s_1584_16: u64 = if s_1584_11 { s_1584_13 } else { s_1584_15 };
        // D s_1584_17: cast trunc s_1584_16 -> u8
        let s_1584_17: bool = ((s_1584_16) != 0);
        // D s_1584_18: cast zx s_1584_17 -> bv
        let s_1584_18: Bits = Bits::new(s_1584_17 as u128, 1u16);
        // C s_1584_19: const #0u : u8
        let s_1584_19: bool = false;
        // C s_1584_20: cast zx s_1584_19 -> bv
        let s_1584_20: Bits = Bits::new(s_1584_19 as u128, 1u16);
        // D s_1584_21: cmp-ne s_1584_18 s_1584_20
        let s_1584_21: bool = ((s_1584_18) != (s_1584_20));
        // D s_1584_22: write-var gs#407818 <= s_1584_21
        fn_state.gs_407818 = s_1584_21;
        // N s_1584_23: jump b1585
        return block_1585(state, tracer, fn_state);
    }
    fn block_1585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1585_0: read-var gs#407818:u8
        let s_1585_0: bool = fn_state.gs_407818;
        // N s_1585_1: branch s_1585_0 b1614 b1586
        if s_1585_0 {
            return block_1614(state, tracer, fn_state);
        } else {
            return block_1586(state, tracer, fn_state);
        };
    }
    fn block_1586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1586_0: const #11s : i
        let s_1586_0: i128 = 11;
        // D s_1586_1: read-var u#33176:u32
        let s_1586_1: u32 = fn_state.u_33176;
        // D s_1586_2: cast zx s_1586_1 -> bv
        let s_1586_2: Bits = Bits::new(s_1586_1 as u128, 32u16);
        // C s_1586_3: const #1u : u64
        let s_1586_3: u64 = 1;
        // D s_1586_4: bit-extract s_1586_2 s_1586_0 s_1586_3
        let s_1586_4: Bits = (Bits::new(
            ((s_1586_2) >> (s_1586_0)).value(),
            u16::try_from(s_1586_3).unwrap(),
        ));
        // D s_1586_5: cast reint s_1586_4 -> u8
        let s_1586_5: bool = ((s_1586_4.value()) != 0);
        // C s_1586_6: const #0s : i
        let s_1586_6: i128 = 0;
        // C s_1586_7: const #0u : u64
        let s_1586_7: u64 = 0;
        // D s_1586_8: cast zx s_1586_5 -> u64
        let s_1586_8: u64 = (s_1586_5 as u64);
        // C s_1586_9: const #1u : u64
        let s_1586_9: u64 = 1;
        // D s_1586_10: and s_1586_8 s_1586_9
        let s_1586_10: u64 = ((s_1586_8) & (s_1586_9));
        // D s_1586_11: cmp-eq s_1586_10 s_1586_9
        let s_1586_11: bool = ((s_1586_10) == (s_1586_9));
        // D s_1586_12: lsl s_1586_8 s_1586_6
        let s_1586_12: u64 = s_1586_8 << s_1586_6;
        // D s_1586_13: or s_1586_7 s_1586_12
        let s_1586_13: u64 = ((s_1586_7) | (s_1586_12));
        // D s_1586_14: cmpl s_1586_12
        let s_1586_14: u64 = !s_1586_12;
        // D s_1586_15: and s_1586_7 s_1586_14
        let s_1586_15: u64 = ((s_1586_7) & (s_1586_14));
        // D s_1586_16: select s_1586_11 s_1586_13 s_1586_15
        let s_1586_16: u64 = if s_1586_11 { s_1586_13 } else { s_1586_15 };
        // D s_1586_17: cast trunc s_1586_16 -> u8
        let s_1586_17: bool = ((s_1586_16) != 0);
        // D s_1586_18: cast zx s_1586_17 -> bv
        let s_1586_18: Bits = Bits::new(s_1586_17 as u128, 1u16);
        // C s_1586_19: const #0u : u8
        let s_1586_19: bool = false;
        // C s_1586_20: cast zx s_1586_19 -> bv
        let s_1586_20: Bits = Bits::new(s_1586_19 as u128, 1u16);
        // D s_1586_21: cmp-ne s_1586_18 s_1586_20
        let s_1586_21: bool = ((s_1586_18) != (s_1586_20));
        // D s_1586_22: write-var gs#407821 <= s_1586_21
        fn_state.gs_407821 = s_1586_21;
        // N s_1586_23: jump b1587
        return block_1587(state, tracer, fn_state);
    }
    fn block_1587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1587_0: read-var gs#407821:u8
        let s_1587_0: bool = fn_state.gs_407821;
        // N s_1587_1: branch s_1587_0 b1613 b1588
        if s_1587_0 {
            return block_1613(state, tracer, fn_state);
        } else {
            return block_1588(state, tracer, fn_state);
        };
    }
    fn block_1588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1588_0: const #12s : i
        let s_1588_0: i128 = 12;
        // D s_1588_1: read-var u#33176:u32
        let s_1588_1: u32 = fn_state.u_33176;
        // D s_1588_2: cast zx s_1588_1 -> bv
        let s_1588_2: Bits = Bits::new(s_1588_1 as u128, 32u16);
        // C s_1588_3: const #1u : u64
        let s_1588_3: u64 = 1;
        // D s_1588_4: bit-extract s_1588_2 s_1588_0 s_1588_3
        let s_1588_4: Bits = (Bits::new(
            ((s_1588_2) >> (s_1588_0)).value(),
            u16::try_from(s_1588_3).unwrap(),
        ));
        // D s_1588_5: cast reint s_1588_4 -> u8
        let s_1588_5: bool = ((s_1588_4.value()) != 0);
        // C s_1588_6: const #0s : i
        let s_1588_6: i128 = 0;
        // C s_1588_7: const #0u : u64
        let s_1588_7: u64 = 0;
        // D s_1588_8: cast zx s_1588_5 -> u64
        let s_1588_8: u64 = (s_1588_5 as u64);
        // C s_1588_9: const #1u : u64
        let s_1588_9: u64 = 1;
        // D s_1588_10: and s_1588_8 s_1588_9
        let s_1588_10: u64 = ((s_1588_8) & (s_1588_9));
        // D s_1588_11: cmp-eq s_1588_10 s_1588_9
        let s_1588_11: bool = ((s_1588_10) == (s_1588_9));
        // D s_1588_12: lsl s_1588_8 s_1588_6
        let s_1588_12: u64 = s_1588_8 << s_1588_6;
        // D s_1588_13: or s_1588_7 s_1588_12
        let s_1588_13: u64 = ((s_1588_7) | (s_1588_12));
        // D s_1588_14: cmpl s_1588_12
        let s_1588_14: u64 = !s_1588_12;
        // D s_1588_15: and s_1588_7 s_1588_14
        let s_1588_15: u64 = ((s_1588_7) & (s_1588_14));
        // D s_1588_16: select s_1588_11 s_1588_13 s_1588_15
        let s_1588_16: u64 = if s_1588_11 { s_1588_13 } else { s_1588_15 };
        // D s_1588_17: cast trunc s_1588_16 -> u8
        let s_1588_17: bool = ((s_1588_16) != 0);
        // D s_1588_18: cast zx s_1588_17 -> bv
        let s_1588_18: Bits = Bits::new(s_1588_17 as u128, 1u16);
        // C s_1588_19: const #0u : u8
        let s_1588_19: bool = false;
        // C s_1588_20: cast zx s_1588_19 -> bv
        let s_1588_20: Bits = Bits::new(s_1588_19 as u128, 1u16);
        // D s_1588_21: cmp-ne s_1588_18 s_1588_20
        let s_1588_21: bool = ((s_1588_18) != (s_1588_20));
        // D s_1588_22: write-var gs#407824 <= s_1588_21
        fn_state.gs_407824 = s_1588_21;
        // N s_1588_23: jump b1589
        return block_1589(state, tracer, fn_state);
    }
    fn block_1589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1589_0: read-var gs#407824:u8
        let s_1589_0: bool = fn_state.gs_407824;
        // N s_1589_1: branch s_1589_0 b1612 b1590
        if s_1589_0 {
            return block_1612(state, tracer, fn_state);
        } else {
            return block_1590(state, tracer, fn_state);
        };
    }
    fn block_1590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1590_0: const #13s : i
        let s_1590_0: i128 = 13;
        // D s_1590_1: read-var u#33176:u32
        let s_1590_1: u32 = fn_state.u_33176;
        // D s_1590_2: cast zx s_1590_1 -> bv
        let s_1590_2: Bits = Bits::new(s_1590_1 as u128, 32u16);
        // C s_1590_3: const #1u : u64
        let s_1590_3: u64 = 1;
        // D s_1590_4: bit-extract s_1590_2 s_1590_0 s_1590_3
        let s_1590_4: Bits = (Bits::new(
            ((s_1590_2) >> (s_1590_0)).value(),
            u16::try_from(s_1590_3).unwrap(),
        ));
        // D s_1590_5: cast reint s_1590_4 -> u8
        let s_1590_5: bool = ((s_1590_4.value()) != 0);
        // C s_1590_6: const #0s : i
        let s_1590_6: i128 = 0;
        // C s_1590_7: const #0u : u64
        let s_1590_7: u64 = 0;
        // D s_1590_8: cast zx s_1590_5 -> u64
        let s_1590_8: u64 = (s_1590_5 as u64);
        // C s_1590_9: const #1u : u64
        let s_1590_9: u64 = 1;
        // D s_1590_10: and s_1590_8 s_1590_9
        let s_1590_10: u64 = ((s_1590_8) & (s_1590_9));
        // D s_1590_11: cmp-eq s_1590_10 s_1590_9
        let s_1590_11: bool = ((s_1590_10) == (s_1590_9));
        // D s_1590_12: lsl s_1590_8 s_1590_6
        let s_1590_12: u64 = s_1590_8 << s_1590_6;
        // D s_1590_13: or s_1590_7 s_1590_12
        let s_1590_13: u64 = ((s_1590_7) | (s_1590_12));
        // D s_1590_14: cmpl s_1590_12
        let s_1590_14: u64 = !s_1590_12;
        // D s_1590_15: and s_1590_7 s_1590_14
        let s_1590_15: u64 = ((s_1590_7) & (s_1590_14));
        // D s_1590_16: select s_1590_11 s_1590_13 s_1590_15
        let s_1590_16: u64 = if s_1590_11 { s_1590_13 } else { s_1590_15 };
        // D s_1590_17: cast trunc s_1590_16 -> u8
        let s_1590_17: bool = ((s_1590_16) != 0);
        // D s_1590_18: cast zx s_1590_17 -> bv
        let s_1590_18: Bits = Bits::new(s_1590_17 as u128, 1u16);
        // C s_1590_19: const #0u : u8
        let s_1590_19: bool = false;
        // C s_1590_20: cast zx s_1590_19 -> bv
        let s_1590_20: Bits = Bits::new(s_1590_19 as u128, 1u16);
        // D s_1590_21: cmp-ne s_1590_18 s_1590_20
        let s_1590_21: bool = ((s_1590_18) != (s_1590_20));
        // D s_1590_22: write-var gs#407827 <= s_1590_21
        fn_state.gs_407827 = s_1590_21;
        // N s_1590_23: jump b1591
        return block_1591(state, tracer, fn_state);
    }
    fn block_1591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1591_0: read-var gs#407827:u8
        let s_1591_0: bool = fn_state.gs_407827;
        // N s_1591_1: branch s_1591_0 b1611 b1592
        if s_1591_0 {
            return block_1611(state, tracer, fn_state);
        } else {
            return block_1592(state, tracer, fn_state);
        };
    }
    fn block_1592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1592_0: const #14s : i
        let s_1592_0: i128 = 14;
        // D s_1592_1: read-var u#33176:u32
        let s_1592_1: u32 = fn_state.u_33176;
        // D s_1592_2: cast zx s_1592_1 -> bv
        let s_1592_2: Bits = Bits::new(s_1592_1 as u128, 32u16);
        // C s_1592_3: const #1u : u64
        let s_1592_3: u64 = 1;
        // D s_1592_4: bit-extract s_1592_2 s_1592_0 s_1592_3
        let s_1592_4: Bits = (Bits::new(
            ((s_1592_2) >> (s_1592_0)).value(),
            u16::try_from(s_1592_3).unwrap(),
        ));
        // D s_1592_5: cast reint s_1592_4 -> u8
        let s_1592_5: bool = ((s_1592_4.value()) != 0);
        // C s_1592_6: const #0s : i
        let s_1592_6: i128 = 0;
        // C s_1592_7: const #0u : u64
        let s_1592_7: u64 = 0;
        // D s_1592_8: cast zx s_1592_5 -> u64
        let s_1592_8: u64 = (s_1592_5 as u64);
        // C s_1592_9: const #1u : u64
        let s_1592_9: u64 = 1;
        // D s_1592_10: and s_1592_8 s_1592_9
        let s_1592_10: u64 = ((s_1592_8) & (s_1592_9));
        // D s_1592_11: cmp-eq s_1592_10 s_1592_9
        let s_1592_11: bool = ((s_1592_10) == (s_1592_9));
        // D s_1592_12: lsl s_1592_8 s_1592_6
        let s_1592_12: u64 = s_1592_8 << s_1592_6;
        // D s_1592_13: or s_1592_7 s_1592_12
        let s_1592_13: u64 = ((s_1592_7) | (s_1592_12));
        // D s_1592_14: cmpl s_1592_12
        let s_1592_14: u64 = !s_1592_12;
        // D s_1592_15: and s_1592_7 s_1592_14
        let s_1592_15: u64 = ((s_1592_7) & (s_1592_14));
        // D s_1592_16: select s_1592_11 s_1592_13 s_1592_15
        let s_1592_16: u64 = if s_1592_11 { s_1592_13 } else { s_1592_15 };
        // D s_1592_17: cast trunc s_1592_16 -> u8
        let s_1592_17: bool = ((s_1592_16) != 0);
        // D s_1592_18: cast zx s_1592_17 -> bv
        let s_1592_18: Bits = Bits::new(s_1592_17 as u128, 1u16);
        // C s_1592_19: const #0u : u8
        let s_1592_19: bool = false;
        // C s_1592_20: cast zx s_1592_19 -> bv
        let s_1592_20: Bits = Bits::new(s_1592_19 as u128, 1u16);
        // D s_1592_21: cmp-ne s_1592_18 s_1592_20
        let s_1592_21: bool = ((s_1592_18) != (s_1592_20));
        // D s_1592_22: write-var gs#407830 <= s_1592_21
        fn_state.gs_407830 = s_1592_21;
        // N s_1592_23: jump b1593
        return block_1593(state, tracer, fn_state);
    }
    fn block_1593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1593_0: read-var gs#407830:u8
        let s_1593_0: bool = fn_state.gs_407830;
        // N s_1593_1: branch s_1593_0 b1610 b1594
        if s_1593_0 {
            return block_1610(state, tracer, fn_state);
        } else {
            return block_1594(state, tracer, fn_state);
        };
    }
    fn block_1594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1594_0: const #15s : i
        let s_1594_0: i128 = 15;
        // D s_1594_1: read-var u#33176:u32
        let s_1594_1: u32 = fn_state.u_33176;
        // D s_1594_2: cast zx s_1594_1 -> bv
        let s_1594_2: Bits = Bits::new(s_1594_1 as u128, 32u16);
        // C s_1594_3: const #1u : u64
        let s_1594_3: u64 = 1;
        // D s_1594_4: bit-extract s_1594_2 s_1594_0 s_1594_3
        let s_1594_4: Bits = (Bits::new(
            ((s_1594_2) >> (s_1594_0)).value(),
            u16::try_from(s_1594_3).unwrap(),
        ));
        // D s_1594_5: cast reint s_1594_4 -> u8
        let s_1594_5: bool = ((s_1594_4.value()) != 0);
        // C s_1594_6: const #0s : i
        let s_1594_6: i128 = 0;
        // C s_1594_7: const #0u : u64
        let s_1594_7: u64 = 0;
        // D s_1594_8: cast zx s_1594_5 -> u64
        let s_1594_8: u64 = (s_1594_5 as u64);
        // C s_1594_9: const #1u : u64
        let s_1594_9: u64 = 1;
        // D s_1594_10: and s_1594_8 s_1594_9
        let s_1594_10: u64 = ((s_1594_8) & (s_1594_9));
        // D s_1594_11: cmp-eq s_1594_10 s_1594_9
        let s_1594_11: bool = ((s_1594_10) == (s_1594_9));
        // D s_1594_12: lsl s_1594_8 s_1594_6
        let s_1594_12: u64 = s_1594_8 << s_1594_6;
        // D s_1594_13: or s_1594_7 s_1594_12
        let s_1594_13: u64 = ((s_1594_7) | (s_1594_12));
        // D s_1594_14: cmpl s_1594_12
        let s_1594_14: u64 = !s_1594_12;
        // D s_1594_15: and s_1594_7 s_1594_14
        let s_1594_15: u64 = ((s_1594_7) & (s_1594_14));
        // D s_1594_16: select s_1594_11 s_1594_13 s_1594_15
        let s_1594_16: u64 = if s_1594_11 { s_1594_13 } else { s_1594_15 };
        // D s_1594_17: cast trunc s_1594_16 -> u8
        let s_1594_17: bool = ((s_1594_16) != 0);
        // D s_1594_18: cast zx s_1594_17 -> bv
        let s_1594_18: Bits = Bits::new(s_1594_17 as u128, 1u16);
        // C s_1594_19: const #0u : u8
        let s_1594_19: bool = false;
        // C s_1594_20: cast zx s_1594_19 -> bv
        let s_1594_20: Bits = Bits::new(s_1594_19 as u128, 1u16);
        // D s_1594_21: cmp-ne s_1594_18 s_1594_20
        let s_1594_21: bool = ((s_1594_18) != (s_1594_20));
        // D s_1594_22: write-var gs#407833 <= s_1594_21
        fn_state.gs_407833 = s_1594_21;
        // N s_1594_23: jump b1595
        return block_1595(state, tracer, fn_state);
    }
    fn block_1595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1595_0: read-var gs#407833:u8
        let s_1595_0: bool = fn_state.gs_407833;
        // N s_1595_1: branch s_1595_0 b1609 b1596
        if s_1595_0 {
            return block_1609(state, tracer, fn_state);
        } else {
            return block_1596(state, tracer, fn_state);
        };
    }
    fn block_1596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1596_0: const #16s : i
        let s_1596_0: i128 = 16;
        // D s_1596_1: read-var u#33176:u32
        let s_1596_1: u32 = fn_state.u_33176;
        // D s_1596_2: cast zx s_1596_1 -> bv
        let s_1596_2: Bits = Bits::new(s_1596_1 as u128, 32u16);
        // C s_1596_3: const #1u : u64
        let s_1596_3: u64 = 1;
        // D s_1596_4: bit-extract s_1596_2 s_1596_0 s_1596_3
        let s_1596_4: Bits = (Bits::new(
            ((s_1596_2) >> (s_1596_0)).value(),
            u16::try_from(s_1596_3).unwrap(),
        ));
        // D s_1596_5: cast reint s_1596_4 -> u8
        let s_1596_5: bool = ((s_1596_4.value()) != 0);
        // C s_1596_6: const #0s : i
        let s_1596_6: i128 = 0;
        // C s_1596_7: const #0u : u64
        let s_1596_7: u64 = 0;
        // D s_1596_8: cast zx s_1596_5 -> u64
        let s_1596_8: u64 = (s_1596_5 as u64);
        // C s_1596_9: const #1u : u64
        let s_1596_9: u64 = 1;
        // D s_1596_10: and s_1596_8 s_1596_9
        let s_1596_10: u64 = ((s_1596_8) & (s_1596_9));
        // D s_1596_11: cmp-eq s_1596_10 s_1596_9
        let s_1596_11: bool = ((s_1596_10) == (s_1596_9));
        // D s_1596_12: lsl s_1596_8 s_1596_6
        let s_1596_12: u64 = s_1596_8 << s_1596_6;
        // D s_1596_13: or s_1596_7 s_1596_12
        let s_1596_13: u64 = ((s_1596_7) | (s_1596_12));
        // D s_1596_14: cmpl s_1596_12
        let s_1596_14: u64 = !s_1596_12;
        // D s_1596_15: and s_1596_7 s_1596_14
        let s_1596_15: u64 = ((s_1596_7) & (s_1596_14));
        // D s_1596_16: select s_1596_11 s_1596_13 s_1596_15
        let s_1596_16: u64 = if s_1596_11 { s_1596_13 } else { s_1596_15 };
        // D s_1596_17: cast trunc s_1596_16 -> u8
        let s_1596_17: bool = ((s_1596_16) != 0);
        // D s_1596_18: cast zx s_1596_17 -> bv
        let s_1596_18: Bits = Bits::new(s_1596_17 as u128, 1u16);
        // C s_1596_19: const #0u : u8
        let s_1596_19: bool = false;
        // C s_1596_20: cast zx s_1596_19 -> bv
        let s_1596_20: Bits = Bits::new(s_1596_19 as u128, 1u16);
        // D s_1596_21: cmp-ne s_1596_18 s_1596_20
        let s_1596_21: bool = ((s_1596_18) != (s_1596_20));
        // D s_1596_22: write-var gs#407836 <= s_1596_21
        fn_state.gs_407836 = s_1596_21;
        // N s_1596_23: jump b1597
        return block_1597(state, tracer, fn_state);
    }
    fn block_1597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1597_0: read-var gs#407836:u8
        let s_1597_0: bool = fn_state.gs_407836;
        // N s_1597_1: branch s_1597_0 b1608 b1598
        if s_1597_0 {
            return block_1608(state, tracer, fn_state);
        } else {
            return block_1598(state, tracer, fn_state);
        };
    }
    fn block_1598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1598_0: const #17s : i
        let s_1598_0: i128 = 17;
        // D s_1598_1: read-var u#33176:u32
        let s_1598_1: u32 = fn_state.u_33176;
        // D s_1598_2: cast zx s_1598_1 -> bv
        let s_1598_2: Bits = Bits::new(s_1598_1 as u128, 32u16);
        // C s_1598_3: const #1u : u64
        let s_1598_3: u64 = 1;
        // D s_1598_4: bit-extract s_1598_2 s_1598_0 s_1598_3
        let s_1598_4: Bits = (Bits::new(
            ((s_1598_2) >> (s_1598_0)).value(),
            u16::try_from(s_1598_3).unwrap(),
        ));
        // D s_1598_5: cast reint s_1598_4 -> u8
        let s_1598_5: bool = ((s_1598_4.value()) != 0);
        // C s_1598_6: const #0s : i
        let s_1598_6: i128 = 0;
        // C s_1598_7: const #0u : u64
        let s_1598_7: u64 = 0;
        // D s_1598_8: cast zx s_1598_5 -> u64
        let s_1598_8: u64 = (s_1598_5 as u64);
        // C s_1598_9: const #1u : u64
        let s_1598_9: u64 = 1;
        // D s_1598_10: and s_1598_8 s_1598_9
        let s_1598_10: u64 = ((s_1598_8) & (s_1598_9));
        // D s_1598_11: cmp-eq s_1598_10 s_1598_9
        let s_1598_11: bool = ((s_1598_10) == (s_1598_9));
        // D s_1598_12: lsl s_1598_8 s_1598_6
        let s_1598_12: u64 = s_1598_8 << s_1598_6;
        // D s_1598_13: or s_1598_7 s_1598_12
        let s_1598_13: u64 = ((s_1598_7) | (s_1598_12));
        // D s_1598_14: cmpl s_1598_12
        let s_1598_14: u64 = !s_1598_12;
        // D s_1598_15: and s_1598_7 s_1598_14
        let s_1598_15: u64 = ((s_1598_7) & (s_1598_14));
        // D s_1598_16: select s_1598_11 s_1598_13 s_1598_15
        let s_1598_16: u64 = if s_1598_11 { s_1598_13 } else { s_1598_15 };
        // D s_1598_17: cast trunc s_1598_16 -> u8
        let s_1598_17: bool = ((s_1598_16) != 0);
        // D s_1598_18: cast zx s_1598_17 -> bv
        let s_1598_18: Bits = Bits::new(s_1598_17 as u128, 1u16);
        // C s_1598_19: const #0u : u8
        let s_1598_19: bool = false;
        // C s_1598_20: cast zx s_1598_19 -> bv
        let s_1598_20: Bits = Bits::new(s_1598_19 as u128, 1u16);
        // D s_1598_21: cmp-ne s_1598_18 s_1598_20
        let s_1598_21: bool = ((s_1598_18) != (s_1598_20));
        // D s_1598_22: write-var gs#407839 <= s_1598_21
        fn_state.gs_407839 = s_1598_21;
        // N s_1598_23: jump b1599
        return block_1599(state, tracer, fn_state);
    }
    fn block_1599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1599_0: read-var gs#407839:u8
        let s_1599_0: bool = fn_state.gs_407839;
        // N s_1599_1: branch s_1599_0 b1607 b1600
        if s_1599_0 {
            return block_1607(state, tracer, fn_state);
        } else {
            return block_1600(state, tracer, fn_state);
        };
    }
    fn block_1600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1600_0: const #18s : i
        let s_1600_0: i128 = 18;
        // D s_1600_1: read-var u#33176:u32
        let s_1600_1: u32 = fn_state.u_33176;
        // D s_1600_2: cast zx s_1600_1 -> bv
        let s_1600_2: Bits = Bits::new(s_1600_1 as u128, 32u16);
        // C s_1600_3: const #1u : u64
        let s_1600_3: u64 = 1;
        // D s_1600_4: bit-extract s_1600_2 s_1600_0 s_1600_3
        let s_1600_4: Bits = (Bits::new(
            ((s_1600_2) >> (s_1600_0)).value(),
            u16::try_from(s_1600_3).unwrap(),
        ));
        // D s_1600_5: cast reint s_1600_4 -> u8
        let s_1600_5: bool = ((s_1600_4.value()) != 0);
        // C s_1600_6: const #0s : i
        let s_1600_6: i128 = 0;
        // C s_1600_7: const #0u : u64
        let s_1600_7: u64 = 0;
        // D s_1600_8: cast zx s_1600_5 -> u64
        let s_1600_8: u64 = (s_1600_5 as u64);
        // C s_1600_9: const #1u : u64
        let s_1600_9: u64 = 1;
        // D s_1600_10: and s_1600_8 s_1600_9
        let s_1600_10: u64 = ((s_1600_8) & (s_1600_9));
        // D s_1600_11: cmp-eq s_1600_10 s_1600_9
        let s_1600_11: bool = ((s_1600_10) == (s_1600_9));
        // D s_1600_12: lsl s_1600_8 s_1600_6
        let s_1600_12: u64 = s_1600_8 << s_1600_6;
        // D s_1600_13: or s_1600_7 s_1600_12
        let s_1600_13: u64 = ((s_1600_7) | (s_1600_12));
        // D s_1600_14: cmpl s_1600_12
        let s_1600_14: u64 = !s_1600_12;
        // D s_1600_15: and s_1600_7 s_1600_14
        let s_1600_15: u64 = ((s_1600_7) & (s_1600_14));
        // D s_1600_16: select s_1600_11 s_1600_13 s_1600_15
        let s_1600_16: u64 = if s_1600_11 { s_1600_13 } else { s_1600_15 };
        // D s_1600_17: cast trunc s_1600_16 -> u8
        let s_1600_17: bool = ((s_1600_16) != 0);
        // D s_1600_18: cast zx s_1600_17 -> bv
        let s_1600_18: Bits = Bits::new(s_1600_17 as u128, 1u16);
        // C s_1600_19: const #0u : u8
        let s_1600_19: bool = false;
        // C s_1600_20: cast zx s_1600_19 -> bv
        let s_1600_20: Bits = Bits::new(s_1600_19 as u128, 1u16);
        // D s_1600_21: cmp-ne s_1600_18 s_1600_20
        let s_1600_21: bool = ((s_1600_18) != (s_1600_20));
        // D s_1600_22: write-var gs#407842 <= s_1600_21
        fn_state.gs_407842 = s_1600_21;
        // N s_1600_23: jump b1601
        return block_1601(state, tracer, fn_state);
    }
    fn block_1601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1601_0: read-var gs#407842:u8
        let s_1601_0: bool = fn_state.gs_407842;
        // N s_1601_1: branch s_1601_0 b1606 b1602
        if s_1601_0 {
            return block_1606(state, tracer, fn_state);
        } else {
            return block_1602(state, tracer, fn_state);
        };
    }
    fn block_1602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1602_0: const #19s : i
        let s_1602_0: i128 = 19;
        // D s_1602_1: read-var u#33176:u32
        let s_1602_1: u32 = fn_state.u_33176;
        // D s_1602_2: cast zx s_1602_1 -> bv
        let s_1602_2: Bits = Bits::new(s_1602_1 as u128, 32u16);
        // C s_1602_3: const #1u : u64
        let s_1602_3: u64 = 1;
        // D s_1602_4: bit-extract s_1602_2 s_1602_0 s_1602_3
        let s_1602_4: Bits = (Bits::new(
            ((s_1602_2) >> (s_1602_0)).value(),
            u16::try_from(s_1602_3).unwrap(),
        ));
        // D s_1602_5: cast reint s_1602_4 -> u8
        let s_1602_5: bool = ((s_1602_4.value()) != 0);
        // C s_1602_6: const #0s : i
        let s_1602_6: i128 = 0;
        // C s_1602_7: const #0u : u64
        let s_1602_7: u64 = 0;
        // D s_1602_8: cast zx s_1602_5 -> u64
        let s_1602_8: u64 = (s_1602_5 as u64);
        // C s_1602_9: const #1u : u64
        let s_1602_9: u64 = 1;
        // D s_1602_10: and s_1602_8 s_1602_9
        let s_1602_10: u64 = ((s_1602_8) & (s_1602_9));
        // D s_1602_11: cmp-eq s_1602_10 s_1602_9
        let s_1602_11: bool = ((s_1602_10) == (s_1602_9));
        // D s_1602_12: lsl s_1602_8 s_1602_6
        let s_1602_12: u64 = s_1602_8 << s_1602_6;
        // D s_1602_13: or s_1602_7 s_1602_12
        let s_1602_13: u64 = ((s_1602_7) | (s_1602_12));
        // D s_1602_14: cmpl s_1602_12
        let s_1602_14: u64 = !s_1602_12;
        // D s_1602_15: and s_1602_7 s_1602_14
        let s_1602_15: u64 = ((s_1602_7) & (s_1602_14));
        // D s_1602_16: select s_1602_11 s_1602_13 s_1602_15
        let s_1602_16: u64 = if s_1602_11 { s_1602_13 } else { s_1602_15 };
        // D s_1602_17: cast trunc s_1602_16 -> u8
        let s_1602_17: bool = ((s_1602_16) != 0);
        // D s_1602_18: cast zx s_1602_17 -> bv
        let s_1602_18: Bits = Bits::new(s_1602_17 as u128, 1u16);
        // C s_1602_19: const #0u : u8
        let s_1602_19: bool = false;
        // C s_1602_20: cast zx s_1602_19 -> bv
        let s_1602_20: Bits = Bits::new(s_1602_19 as u128, 1u16);
        // D s_1602_21: cmp-ne s_1602_18 s_1602_20
        let s_1602_21: bool = ((s_1602_18) != (s_1602_20));
        // D s_1602_22: write-var gs#407845 <= s_1602_21
        fn_state.gs_407845 = s_1602_21;
        // N s_1602_23: jump b1603
        return block_1603(state, tracer, fn_state);
    }
    fn block_1603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1603_0: read-var gs#407845:u8
        let s_1603_0: bool = fn_state.gs_407845;
        // N s_1603_1: branch s_1603_0 b1605 b1604
        if s_1603_0 {
            return block_1605(state, tracer, fn_state);
        } else {
            return block_1604(state, tracer, fn_state);
        };
    }
    fn block_1604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1604_0: read-var u#33177:u8
        let s_1604_0: u8 = fn_state.u_33177;
        // D s_1604_1: read-var u#33178:u8
        let s_1604_1: u8 = fn_state.u_33178;
        // D s_1604_2: call decode_aarch32_instrs_SMC_A1enc_AS_txt(s_1604_0, s_1604_1)
        let s_1604_2: () = decode_aarch32_instrs_SMC_A1enc_AS_txt(
            state,
            tracer,
            s_1604_0,
            s_1604_1,
        );
        // N s_1604_3: return
        return;
    }
    fn block_1605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1605_0: panic
        panic!("{:?}", ());
        // N s_1605_1: return
        return;
    }
    fn block_1606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1606_0: const #1u : u8
        let s_1606_0: bool = true;
        // D s_1606_1: write-var gs#407845 <= s_1606_0
        fn_state.gs_407845 = s_1606_0;
        // N s_1606_2: jump b1603
        return block_1603(state, tracer, fn_state);
    }
    fn block_1607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1607_0: const #1u : u8
        let s_1607_0: bool = true;
        // D s_1607_1: write-var gs#407842 <= s_1607_0
        fn_state.gs_407842 = s_1607_0;
        // N s_1607_2: jump b1601
        return block_1601(state, tracer, fn_state);
    }
    fn block_1608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1608_0: const #1u : u8
        let s_1608_0: bool = true;
        // D s_1608_1: write-var gs#407839 <= s_1608_0
        fn_state.gs_407839 = s_1608_0;
        // N s_1608_2: jump b1599
        return block_1599(state, tracer, fn_state);
    }
    fn block_1609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1609_0: const #1u : u8
        let s_1609_0: bool = true;
        // D s_1609_1: write-var gs#407836 <= s_1609_0
        fn_state.gs_407836 = s_1609_0;
        // N s_1609_2: jump b1597
        return block_1597(state, tracer, fn_state);
    }
    fn block_1610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1610_0: const #1u : u8
        let s_1610_0: bool = true;
        // D s_1610_1: write-var gs#407833 <= s_1610_0
        fn_state.gs_407833 = s_1610_0;
        // N s_1610_2: jump b1595
        return block_1595(state, tracer, fn_state);
    }
    fn block_1611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1611_0: const #1u : u8
        let s_1611_0: bool = true;
        // D s_1611_1: write-var gs#407830 <= s_1611_0
        fn_state.gs_407830 = s_1611_0;
        // N s_1611_2: jump b1593
        return block_1593(state, tracer, fn_state);
    }
    fn block_1612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1612_0: const #1u : u8
        let s_1612_0: bool = true;
        // D s_1612_1: write-var gs#407827 <= s_1612_0
        fn_state.gs_407827 = s_1612_0;
        // N s_1612_2: jump b1591
        return block_1591(state, tracer, fn_state);
    }
    fn block_1613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1613_0: const #1u : u8
        let s_1613_0: bool = true;
        // D s_1613_1: write-var gs#407824 <= s_1613_0
        fn_state.gs_407824 = s_1613_0;
        // N s_1613_2: jump b1589
        return block_1589(state, tracer, fn_state);
    }
    fn block_1614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1614_0: const #1u : u8
        let s_1614_0: bool = true;
        // D s_1614_1: write-var gs#407821 <= s_1614_0
        fn_state.gs_407821 = s_1614_0;
        // N s_1614_2: jump b1587
        return block_1587(state, tracer, fn_state);
    }
    fn block_1615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1615_0: const #1u : u8
        let s_1615_0: bool = true;
        // D s_1615_1: write-var gs#407818 <= s_1615_0
        fn_state.gs_407818 = s_1615_0;
        // N s_1615_2: jump b1585
        return block_1585(state, tracer, fn_state);
    }
    fn block_1616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1616_0: const #1u : u8
        let s_1616_0: bool = true;
        // D s_1616_1: write-var gs#407815 <= s_1616_0
        fn_state.gs_407815 = s_1616_0;
        // N s_1616_2: jump b1583
        return block_1583(state, tracer, fn_state);
    }
    fn block_1617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1617_0: read-var merge#var.1:struct
        let s_1617_0: u32 = fn_state.merge_var._1;
        // D s_1617_1: write-var u#33180 <= s_1617_0
        fn_state.u_33180 = s_1617_0;
        // C s_1617_2: const #23s : i
        let s_1617_2: i128 = 23;
        // D s_1617_3: read-var u#33180:u32
        let s_1617_3: u32 = fn_state.u_33180;
        // D s_1617_4: cast zx s_1617_3 -> bv
        let s_1617_4: Bits = Bits::new(s_1617_3 as u128, 32u16);
        // C s_1617_5: const #1s : i64
        let s_1617_5: i64 = 1;
        // C s_1617_6: cast zx s_1617_5 -> i
        let s_1617_6: i128 = (i128::try_from(s_1617_5).unwrap());
        // C s_1617_7: const #4s : i
        let s_1617_7: i128 = 4;
        // C s_1617_8: add s_1617_7 s_1617_6
        let s_1617_8: i128 = (s_1617_7 + s_1617_6);
        // D s_1617_9: bit-extract s_1617_4 s_1617_2 s_1617_8
        let s_1617_9: Bits = (Bits::new(
            ((s_1617_4) >> (s_1617_2)).value(),
            u16::try_from(s_1617_8).unwrap(),
        ));
        // D s_1617_10: cast reint s_1617_9 -> u8
        let s_1617_10: u8 = (s_1617_9.value() as u8);
        // D s_1617_11: cast zx s_1617_10 -> bv
        let s_1617_11: Bits = Bits::new(s_1617_10 as u128, 5u16);
        // C s_1617_12: const #2u : u8
        let s_1617_12: u8 = 2;
        // C s_1617_13: cast zx s_1617_12 -> bv
        let s_1617_13: Bits = Bits::new(s_1617_12 as u128, 5u16);
        // D s_1617_14: cmp-eq s_1617_11 s_1617_13
        let s_1617_14: bool = ((s_1617_11) == (s_1617_13));
        // N s_1617_15: branch s_1617_14 b2146 b1618
        if s_1617_14 {
            return block_2146(state, tracer, fn_state);
        } else {
            return block_1618(state, tracer, fn_state);
        };
    }
    fn block_1618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1618_0: const #0u : u8
        let s_1618_0: bool = false;
        // D s_1618_1: write-var gs#407857 <= s_1618_0
        fn_state.gs_407857 = s_1618_0;
        // N s_1618_2: jump b1619
        return block_1619(state, tracer, fn_state);
    }
    fn block_1619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1619_0: read-var gs#407857:u8
        let s_1619_0: bool = fn_state.gs_407857;
        // N s_1619_1: branch s_1619_0 b2142 b1620
        if s_1619_0 {
            return block_2142(state, tracer, fn_state);
        } else {
            return block_1620(state, tracer, fn_state);
        };
    }
    fn block_1620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1620_0: const #0u : u8
        let s_1620_0: bool = false;
        // D s_1620_1: write-var gs#407862 <= s_1620_0
        fn_state.gs_407862 = s_1620_0;
        // N s_1620_2: jump b1621
        return block_1621(state, tracer, fn_state);
    }
    fn block_1621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1621_0: read-var gs#407862:u8
        let s_1621_0: bool = fn_state.gs_407862;
        // D s_1621_1: not s_1621_0
        let s_1621_1: bool = !s_1621_0;
        // N s_1621_2: branch s_1621_1 b1631 b1622
        if s_1621_1 {
            return block_1631(state, tracer, fn_state);
        } else {
            return block_1622(state, tracer, fn_state);
        };
    }
    fn block_1622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1622_0: const #3808s : i
        let s_1622_0: i128 = 3808;
        // C s_1622_1: const #14696u : u32
        let s_1622_1: u32 = 14696;
        // N s_1622_2: write-reg s_1622_1 <= s_1622_0
        let s_1622_2: () = {
            state.write_register::<i128>(s_1622_1 as isize, s_1622_0);
            tracer.write_register(s_1622_1 as isize, s_1622_0);
        };
        // C s_1622_3: const #28s : i
        let s_1622_3: i128 = 28;
        // C s_1622_4: const #4s : i
        let s_1622_4: i128 = 4;
        // D s_1622_5: read-var u#33180:u32
        let s_1622_5: u32 = fn_state.u_33180;
        // D s_1622_6: cast zx s_1622_5 -> bv
        let s_1622_6: Bits = Bits::new(s_1622_5 as u128, 32u16);
        // D s_1622_7: bit-extract s_1622_6 s_1622_3 s_1622_4
        let s_1622_7: Bits = (Bits::new(
            ((s_1622_6) >> (s_1622_3)).value(),
            u16::try_from(s_1622_4).unwrap(),
        ));
        // D s_1622_8: cast reint s_1622_7 -> u8
        let s_1622_8: u8 = (s_1622_7.value() as u8);
        // D s_1622_9: write-var u#33181 <= s_1622_8
        fn_state.u_33181 = s_1622_8;
        // C s_1622_10: const #21s : i
        let s_1622_10: i128 = 21;
        // C s_1622_11: const #2s : i
        let s_1622_11: i128 = 2;
        // D s_1622_12: read-var u#33180:u32
        let s_1622_12: u32 = fn_state.u_33180;
        // D s_1622_13: cast zx s_1622_12 -> bv
        let s_1622_13: Bits = Bits::new(s_1622_12 as u128, 32u16);
        // D s_1622_14: bit-extract s_1622_13 s_1622_10 s_1622_11
        let s_1622_14: Bits = (Bits::new(
            ((s_1622_13) >> (s_1622_10)).value(),
            u16::try_from(s_1622_11).unwrap(),
        ));
        // D s_1622_15: cast reint s_1622_14 -> u8
        let s_1622_15: u8 = (s_1622_14.value() as u8);
        // D s_1622_16: write-var sz <= s_1622_15
        fn_state.sz = s_1622_15;
        // C s_1622_17: const #16s : i
        let s_1622_17: i128 = 16;
        // C s_1622_18: const #4s : i
        let s_1622_18: i128 = 4;
        // D s_1622_19: read-var u#33180:u32
        let s_1622_19: u32 = fn_state.u_33180;
        // D s_1622_20: cast zx s_1622_19 -> bv
        let s_1622_20: Bits = Bits::new(s_1622_19 as u128, 32u16);
        // D s_1622_21: bit-extract s_1622_20 s_1622_17 s_1622_18
        let s_1622_21: Bits = (Bits::new(
            ((s_1622_20) >> (s_1622_17)).value(),
            u16::try_from(s_1622_18).unwrap(),
        ));
        // D s_1622_22: cast reint s_1622_21 -> u8
        let s_1622_22: u8 = (s_1622_21.value() as u8);
        // D s_1622_23: write-var u#33182 <= s_1622_22
        fn_state.u_33182 = s_1622_22;
        // C s_1622_24: const #12s : i
        let s_1622_24: i128 = 12;
        // C s_1622_25: const #4s : i
        let s_1622_25: i128 = 4;
        // D s_1622_26: read-var u#33180:u32
        let s_1622_26: u32 = fn_state.u_33180;
        // D s_1622_27: cast zx s_1622_26 -> bv
        let s_1622_27: Bits = Bits::new(s_1622_26 as u128, 32u16);
        // D s_1622_28: bit-extract s_1622_27 s_1622_24 s_1622_25
        let s_1622_28: Bits = (Bits::new(
            ((s_1622_27) >> (s_1622_24)).value(),
            u16::try_from(s_1622_25).unwrap(),
        ));
        // D s_1622_29: cast reint s_1622_28 -> u8
        let s_1622_29: u8 = (s_1622_28.value() as u8);
        // D s_1622_30: write-var u#33183 <= s_1622_29
        fn_state.u_33183 = s_1622_29;
        // C s_1622_31: const #9s : i
        let s_1622_31: i128 = 9;
        // C s_1622_32: const #1s : i
        let s_1622_32: i128 = 1;
        // D s_1622_33: read-var u#33180:u32
        let s_1622_33: u32 = fn_state.u_33180;
        // D s_1622_34: cast zx s_1622_33 -> bv
        let s_1622_34: Bits = Bits::new(s_1622_33 as u128, 32u16);
        // D s_1622_35: bit-extract s_1622_34 s_1622_31 s_1622_32
        let s_1622_35: Bits = (Bits::new(
            ((s_1622_34) >> (s_1622_31)).value(),
            u16::try_from(s_1622_32).unwrap(),
        ));
        // D s_1622_36: cast reint s_1622_35 -> u8
        let s_1622_36: bool = ((s_1622_35.value()) != 0);
        // D s_1622_37: write-var C <= s_1622_36
        fn_state.C = s_1622_36;
        // C s_1622_38: const #0s : i
        let s_1622_38: i128 = 0;
        // C s_1622_39: const #4s : i
        let s_1622_39: i128 = 4;
        // D s_1622_40: read-var u#33180:u32
        let s_1622_40: u32 = fn_state.u_33180;
        // D s_1622_41: cast zx s_1622_40 -> bv
        let s_1622_41: Bits = Bits::new(s_1622_40 as u128, 32u16);
        // D s_1622_42: bit-extract s_1622_41 s_1622_38 s_1622_39
        let s_1622_42: Bits = (Bits::new(
            ((s_1622_41) >> (s_1622_38)).value(),
            u16::try_from(s_1622_39).unwrap(),
        ));
        // D s_1622_43: cast reint s_1622_42 -> u8
        let s_1622_43: u8 = (s_1622_42.value() as u8);
        // D s_1622_44: write-var u#33184 <= s_1622_43
        fn_state.u_33184 = s_1622_43;
        // C s_1622_45: const #10s : i
        let s_1622_45: i128 = 10;
        // D s_1622_46: read-var u#33180:u32
        let s_1622_46: u32 = fn_state.u_33180;
        // D s_1622_47: cast zx s_1622_46 -> bv
        let s_1622_47: Bits = Bits::new(s_1622_46 as u128, 32u16);
        // C s_1622_48: const #1u : u64
        let s_1622_48: u64 = 1;
        // D s_1622_49: bit-extract s_1622_47 s_1622_45 s_1622_48
        let s_1622_49: Bits = (Bits::new(
            ((s_1622_47) >> (s_1622_45)).value(),
            u16::try_from(s_1622_48).unwrap(),
        ));
        // D s_1622_50: cast reint s_1622_49 -> u8
        let s_1622_50: bool = ((s_1622_49.value()) != 0);
        // C s_1622_51: const #0s : i
        let s_1622_51: i128 = 0;
        // C s_1622_52: const #0u : u64
        let s_1622_52: u64 = 0;
        // D s_1622_53: cast zx s_1622_50 -> u64
        let s_1622_53: u64 = (s_1622_50 as u64);
        // C s_1622_54: const #1u : u64
        let s_1622_54: u64 = 1;
        // D s_1622_55: and s_1622_53 s_1622_54
        let s_1622_55: u64 = ((s_1622_53) & (s_1622_54));
        // D s_1622_56: cmp-eq s_1622_55 s_1622_54
        let s_1622_56: bool = ((s_1622_55) == (s_1622_54));
        // D s_1622_57: lsl s_1622_53 s_1622_51
        let s_1622_57: u64 = s_1622_53 << s_1622_51;
        // D s_1622_58: or s_1622_52 s_1622_57
        let s_1622_58: u64 = ((s_1622_52) | (s_1622_57));
        // D s_1622_59: cmpl s_1622_57
        let s_1622_59: u64 = !s_1622_57;
        // D s_1622_60: and s_1622_52 s_1622_59
        let s_1622_60: u64 = ((s_1622_52) & (s_1622_59));
        // D s_1622_61: select s_1622_56 s_1622_58 s_1622_60
        let s_1622_61: u64 = if s_1622_56 { s_1622_58 } else { s_1622_60 };
        // D s_1622_62: cast trunc s_1622_61 -> u8
        let s_1622_62: bool = ((s_1622_61) != 0);
        // D s_1622_63: cast zx s_1622_62 -> bv
        let s_1622_63: Bits = Bits::new(s_1622_62 as u128, 1u16);
        // C s_1622_64: const #0u : u8
        let s_1622_64: bool = false;
        // C s_1622_65: cast zx s_1622_64 -> bv
        let s_1622_65: Bits = Bits::new(s_1622_64 as u128, 1u16);
        // D s_1622_66: cmp-ne s_1622_63 s_1622_65
        let s_1622_66: bool = ((s_1622_63) != (s_1622_65));
        // N s_1622_67: branch s_1622_66 b1630 b1623
        if s_1622_66 {
            return block_1630(state, tracer, fn_state);
        } else {
            return block_1623(state, tracer, fn_state);
        };
    }
    fn block_1623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1623_0: const #11s : i
        let s_1623_0: i128 = 11;
        // D s_1623_1: read-var u#33180:u32
        let s_1623_1: u32 = fn_state.u_33180;
        // D s_1623_2: cast zx s_1623_1 -> bv
        let s_1623_2: Bits = Bits::new(s_1623_1 as u128, 32u16);
        // C s_1623_3: const #1u : u64
        let s_1623_3: u64 = 1;
        // D s_1623_4: bit-extract s_1623_2 s_1623_0 s_1623_3
        let s_1623_4: Bits = (Bits::new(
            ((s_1623_2) >> (s_1623_0)).value(),
            u16::try_from(s_1623_3).unwrap(),
        ));
        // D s_1623_5: cast reint s_1623_4 -> u8
        let s_1623_5: bool = ((s_1623_4.value()) != 0);
        // C s_1623_6: const #0s : i
        let s_1623_6: i128 = 0;
        // C s_1623_7: const #0u : u64
        let s_1623_7: u64 = 0;
        // D s_1623_8: cast zx s_1623_5 -> u64
        let s_1623_8: u64 = (s_1623_5 as u64);
        // C s_1623_9: const #1u : u64
        let s_1623_9: u64 = 1;
        // D s_1623_10: and s_1623_8 s_1623_9
        let s_1623_10: u64 = ((s_1623_8) & (s_1623_9));
        // D s_1623_11: cmp-eq s_1623_10 s_1623_9
        let s_1623_11: bool = ((s_1623_10) == (s_1623_9));
        // D s_1623_12: lsl s_1623_8 s_1623_6
        let s_1623_12: u64 = s_1623_8 << s_1623_6;
        // D s_1623_13: or s_1623_7 s_1623_12
        let s_1623_13: u64 = ((s_1623_7) | (s_1623_12));
        // D s_1623_14: cmpl s_1623_12
        let s_1623_14: u64 = !s_1623_12;
        // D s_1623_15: and s_1623_7 s_1623_14
        let s_1623_15: u64 = ((s_1623_7) & (s_1623_14));
        // D s_1623_16: select s_1623_11 s_1623_13 s_1623_15
        let s_1623_16: u64 = if s_1623_11 { s_1623_13 } else { s_1623_15 };
        // D s_1623_17: cast trunc s_1623_16 -> u8
        let s_1623_17: bool = ((s_1623_16) != 0);
        // D s_1623_18: cast zx s_1623_17 -> bv
        let s_1623_18: Bits = Bits::new(s_1623_17 as u128, 1u16);
        // C s_1623_19: const #0u : u8
        let s_1623_19: bool = false;
        // C s_1623_20: cast zx s_1623_19 -> bv
        let s_1623_20: Bits = Bits::new(s_1623_19 as u128, 1u16);
        // D s_1623_21: cmp-ne s_1623_18 s_1623_20
        let s_1623_21: bool = ((s_1623_18) != (s_1623_20));
        // D s_1623_22: write-var gs#407881 <= s_1623_21
        fn_state.gs_407881 = s_1623_21;
        // N s_1623_23: jump b1624
        return block_1624(state, tracer, fn_state);
    }
    fn block_1624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1624_0: read-var gs#407881:u8
        let s_1624_0: bool = fn_state.gs_407881;
        // N s_1624_1: branch s_1624_0 b1629 b1625
        if s_1624_0 {
            return block_1629(state, tracer, fn_state);
        } else {
            return block_1625(state, tracer, fn_state);
        };
    }
    fn block_1625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1625_0: const #8s : i
        let s_1625_0: i128 = 8;
        // D s_1625_1: read-var u#33180:u32
        let s_1625_1: u32 = fn_state.u_33180;
        // D s_1625_2: cast zx s_1625_1 -> bv
        let s_1625_2: Bits = Bits::new(s_1625_1 as u128, 32u16);
        // C s_1625_3: const #1u : u64
        let s_1625_3: u64 = 1;
        // D s_1625_4: bit-extract s_1625_2 s_1625_0 s_1625_3
        let s_1625_4: Bits = (Bits::new(
            ((s_1625_2) >> (s_1625_0)).value(),
            u16::try_from(s_1625_3).unwrap(),
        ));
        // D s_1625_5: cast reint s_1625_4 -> u8
        let s_1625_5: bool = ((s_1625_4.value()) != 0);
        // C s_1625_6: const #0s : i
        let s_1625_6: i128 = 0;
        // C s_1625_7: const #0u : u64
        let s_1625_7: u64 = 0;
        // D s_1625_8: cast zx s_1625_5 -> u64
        let s_1625_8: u64 = (s_1625_5 as u64);
        // C s_1625_9: const #1u : u64
        let s_1625_9: u64 = 1;
        // D s_1625_10: and s_1625_8 s_1625_9
        let s_1625_10: u64 = ((s_1625_8) & (s_1625_9));
        // D s_1625_11: cmp-eq s_1625_10 s_1625_9
        let s_1625_11: bool = ((s_1625_10) == (s_1625_9));
        // D s_1625_12: lsl s_1625_8 s_1625_6
        let s_1625_12: u64 = s_1625_8 << s_1625_6;
        // D s_1625_13: or s_1625_7 s_1625_12
        let s_1625_13: u64 = ((s_1625_7) | (s_1625_12));
        // D s_1625_14: cmpl s_1625_12
        let s_1625_14: u64 = !s_1625_12;
        // D s_1625_15: and s_1625_7 s_1625_14
        let s_1625_15: u64 = ((s_1625_7) & (s_1625_14));
        // D s_1625_16: select s_1625_11 s_1625_13 s_1625_15
        let s_1625_16: u64 = if s_1625_11 { s_1625_13 } else { s_1625_15 };
        // D s_1625_17: cast trunc s_1625_16 -> u8
        let s_1625_17: bool = ((s_1625_16) != 0);
        // D s_1625_18: cast zx s_1625_17 -> bv
        let s_1625_18: Bits = Bits::new(s_1625_17 as u128, 1u16);
        // C s_1625_19: const #0u : u8
        let s_1625_19: bool = false;
        // C s_1625_20: cast zx s_1625_19 -> bv
        let s_1625_20: Bits = Bits::new(s_1625_19 as u128, 1u16);
        // D s_1625_21: cmp-ne s_1625_18 s_1625_20
        let s_1625_21: bool = ((s_1625_18) != (s_1625_20));
        // D s_1625_22: write-var gs#407884 <= s_1625_21
        fn_state.gs_407884 = s_1625_21;
        // N s_1625_23: jump b1626
        return block_1626(state, tracer, fn_state);
    }
    fn block_1626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1626_0: read-var gs#407884:u8
        let s_1626_0: bool = fn_state.gs_407884;
        // N s_1626_1: branch s_1626_0 b1628 b1627
        if s_1626_0 {
            return block_1628(state, tracer, fn_state);
        } else {
            return block_1627(state, tracer, fn_state);
        };
    }
    fn block_1627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1627_0: read-var u#33181:u8
        let s_1627_0: u8 = fn_state.u_33181;
        // D s_1627_1: read-var sz:u8
        let s_1627_1: u8 = fn_state.sz;
        // D s_1627_2: read-var u#33182:u8
        let s_1627_2: u8 = fn_state.u_33182;
        // D s_1627_3: read-var u#33183:u8
        let s_1627_3: u8 = fn_state.u_33183;
        // D s_1627_4: read-var C:u8
        let s_1627_4: bool = fn_state.C;
        // D s_1627_5: read-var u#33184:u8
        let s_1627_5: u8 = fn_state.u_33184;
        // D s_1627_6: call decode_aarch32_instrs_CRC32_A1enc_A_txt(s_1627_0, s_1627_1, s_1627_2, s_1627_3, s_1627_4, s_1627_5)
        let s_1627_6: () = decode_aarch32_instrs_CRC32_A1enc_A_txt(
            state,
            tracer,
            s_1627_0,
            s_1627_1,
            s_1627_2,
            s_1627_3,
            s_1627_4,
            s_1627_5,
        );
        // N s_1627_7: return
        return;
    }
    fn block_1628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1628_0: panic
        panic!("{:?}", ());
        // N s_1628_1: return
        return;
    }
    fn block_1629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1629_0: const #1u : u8
        let s_1629_0: bool = true;
        // D s_1629_1: write-var gs#407884 <= s_1629_0
        fn_state.gs_407884 = s_1629_0;
        // N s_1629_2: jump b1626
        return block_1626(state, tracer, fn_state);
    }
    fn block_1630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1630_0: const #1u : u8
        let s_1630_0: bool = true;
        // D s_1630_1: write-var gs#407881 <= s_1630_0
        fn_state.gs_407881 = s_1630_0;
        // N s_1630_2: jump b1624
        return block_1624(state, tracer, fn_state);
    }
    fn block_1631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1631_0: read-var merge#var.1:struct
        let s_1631_0: u32 = fn_state.merge_var._1;
        // D s_1631_1: write-var u#33186 <= s_1631_0
        fn_state.u_33186 = s_1631_0;
        // C s_1631_2: const #20s : i
        let s_1631_2: i128 = 20;
        // D s_1631_3: read-var u#33186:u32
        let s_1631_3: u32 = fn_state.u_33186;
        // D s_1631_4: cast zx s_1631_3 -> bv
        let s_1631_4: Bits = Bits::new(s_1631_3 as u128, 32u16);
        // C s_1631_5: const #1s : i64
        let s_1631_5: i64 = 1;
        // C s_1631_6: cast zx s_1631_5 -> i
        let s_1631_6: i128 = (i128::try_from(s_1631_5).unwrap());
        // C s_1631_7: const #7s : i
        let s_1631_7: i128 = 7;
        // C s_1631_8: add s_1631_7 s_1631_6
        let s_1631_8: i128 = (s_1631_7 + s_1631_6);
        // D s_1631_9: bit-extract s_1631_4 s_1631_2 s_1631_8
        let s_1631_9: Bits = (Bits::new(
            ((s_1631_4) >> (s_1631_2)).value(),
            u16::try_from(s_1631_8).unwrap(),
        ));
        // D s_1631_10: cast reint s_1631_9 -> u8
        let s_1631_10: u8 = (s_1631_9.value() as u8);
        // D s_1631_11: cast zx s_1631_10 -> bv
        let s_1631_11: Bits = Bits::new(s_1631_10 as u128, 8u16);
        // C s_1631_12: const #16u : u8
        let s_1631_12: u8 = 16;
        // C s_1631_13: cast zx s_1631_12 -> bv
        let s_1631_13: Bits = Bits::new(s_1631_12 as u128, 8u16);
        // D s_1631_14: cmp-eq s_1631_11 s_1631_13
        let s_1631_14: bool = ((s_1631_11) == (s_1631_13));
        // N s_1631_15: branch s_1631_14 b2141 b1632
        if s_1631_14 {
            return block_2141(state, tracer, fn_state);
        } else {
            return block_1632(state, tracer, fn_state);
        };
    }
    fn block_1632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1632_0: const #0u : u8
        let s_1632_0: bool = false;
        // D s_1632_1: write-var gs#407890 <= s_1632_0
        fn_state.gs_407890 = s_1632_0;
        // N s_1632_2: jump b1633
        return block_1633(state, tracer, fn_state);
    }
    fn block_1633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1633_0: read-var gs#407890:u8
        let s_1633_0: bool = fn_state.gs_407890;
        // N s_1633_1: branch s_1633_0 b2137 b1634
        if s_1633_0 {
            return block_2137(state, tracer, fn_state);
        } else {
            return block_1634(state, tracer, fn_state);
        };
    }
    fn block_1634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1634_0: const #0u : u8
        let s_1634_0: bool = false;
        // D s_1634_1: write-var gs#407895 <= s_1634_0
        fn_state.gs_407895 = s_1634_0;
        // N s_1634_2: jump b1635
        return block_1635(state, tracer, fn_state);
    }
    fn block_1635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1635_0: read-var gs#407895:u8
        let s_1635_0: bool = fn_state.gs_407895;
        // D s_1635_1: not s_1635_0
        let s_1635_1: bool = !s_1635_0;
        // N s_1635_2: branch s_1635_1 b1637 b1636
        if s_1635_1 {
            return block_1637(state, tracer, fn_state);
        } else {
            return block_1636(state, tracer, fn_state);
        };
    }
    fn block_1636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1636_0: const #3813s : i
        let s_1636_0: i128 = 3813;
        // C s_1636_1: const #14696u : u32
        let s_1636_1: u32 = 14696;
        // N s_1636_2: write-reg s_1636_1 <= s_1636_0
        let s_1636_2: () = {
            state.write_register::<i128>(s_1636_1 as isize, s_1636_0);
            tracer.write_register(s_1636_1 as isize, s_1636_0);
        };
        // C s_1636_3: const #28s : i
        let s_1636_3: i128 = 28;
        // C s_1636_4: const #4s : i
        let s_1636_4: i128 = 4;
        // D s_1636_5: read-var u#33186:u32
        let s_1636_5: u32 = fn_state.u_33186;
        // D s_1636_6: cast zx s_1636_5 -> bv
        let s_1636_6: Bits = Bits::new(s_1636_5 as u128, 32u16);
        // D s_1636_7: bit-extract s_1636_6 s_1636_3 s_1636_4
        let s_1636_7: Bits = (Bits::new(
            ((s_1636_6) >> (s_1636_3)).value(),
            u16::try_from(s_1636_4).unwrap(),
        ));
        // D s_1636_8: cast reint s_1636_7 -> u8
        let s_1636_8: u8 = (s_1636_7.value() as u8);
        // C s_1636_9: const #8s : i
        let s_1636_9: i128 = 8;
        // C s_1636_10: const #12s : i
        let s_1636_10: i128 = 12;
        // D s_1636_11: read-var u#33186:u32
        let s_1636_11: u32 = fn_state.u_33186;
        // D s_1636_12: cast zx s_1636_11 -> bv
        let s_1636_12: Bits = Bits::new(s_1636_11 as u128, 32u16);
        // D s_1636_13: bit-extract s_1636_12 s_1636_9 s_1636_10
        let s_1636_13: Bits = (Bits::new(
            ((s_1636_12) >> (s_1636_9)).value(),
            u16::try_from(s_1636_10).unwrap(),
        ));
        // D s_1636_14: cast reint s_1636_13 -> u12
        let s_1636_14: u16 = (s_1636_13.value() as u16);
        // C s_1636_15: const #0s : i
        let s_1636_15: i128 = 0;
        // C s_1636_16: const #4s : i
        let s_1636_16: i128 = 4;
        // D s_1636_17: read-var u#33186:u32
        let s_1636_17: u32 = fn_state.u_33186;
        // D s_1636_18: cast zx s_1636_17 -> bv
        let s_1636_18: Bits = Bits::new(s_1636_17 as u128, 32u16);
        // D s_1636_19: bit-extract s_1636_18 s_1636_15 s_1636_16
        let s_1636_19: Bits = (Bits::new(
            ((s_1636_18) >> (s_1636_15)).value(),
            u16::try_from(s_1636_16).unwrap(),
        ));
        // D s_1636_20: cast reint s_1636_19 -> u8
        let s_1636_20: u8 = (s_1636_19.value() as u8);
        // D s_1636_21: call decode_aarch32_instrs_HLT_A1enc_A_txt(s_1636_8, s_1636_14, s_1636_20)
        let s_1636_21: () = decode_aarch32_instrs_HLT_A1enc_A_txt(
            state,
            tracer,
            s_1636_8,
            s_1636_14,
            s_1636_20,
        );
        // N s_1636_22: return
        return;
    }
    fn block_1637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1637_0: read-var merge#var.1:struct
        let s_1637_0: u32 = fn_state.merge_var._1;
        // D s_1637_1: write-var u#33191 <= s_1637_0
        fn_state.u_33191 = s_1637_0;
        // C s_1637_2: const #20s : i
        let s_1637_2: i128 = 20;
        // D s_1637_3: read-var u#33191:u32
        let s_1637_3: u32 = fn_state.u_33191;
        // D s_1637_4: cast zx s_1637_3 -> bv
        let s_1637_4: Bits = Bits::new(s_1637_3 as u128, 32u16);
        // C s_1637_5: const #1s : i64
        let s_1637_5: i64 = 1;
        // C s_1637_6: cast zx s_1637_5 -> i
        let s_1637_6: i128 = (i128::try_from(s_1637_5).unwrap());
        // C s_1637_7: const #7s : i
        let s_1637_7: i128 = 7;
        // C s_1637_8: add s_1637_7 s_1637_6
        let s_1637_8: i128 = (s_1637_7 + s_1637_6);
        // D s_1637_9: bit-extract s_1637_4 s_1637_2 s_1637_8
        let s_1637_9: Bits = (Bits::new(
            ((s_1637_4) >> (s_1637_2)).value(),
            u16::try_from(s_1637_8).unwrap(),
        ));
        // D s_1637_10: cast reint s_1637_9 -> u8
        let s_1637_10: u8 = (s_1637_9.value() as u8);
        // D s_1637_11: cast zx s_1637_10 -> bv
        let s_1637_11: Bits = Bits::new(s_1637_10 as u128, 8u16);
        // C s_1637_12: const #25u : u8
        let s_1637_12: u8 = 25;
        // C s_1637_13: cast zx s_1637_12 -> bv
        let s_1637_13: Bits = Bits::new(s_1637_12 as u128, 8u16);
        // D s_1637_14: cmp-eq s_1637_11 s_1637_13
        let s_1637_14: bool = ((s_1637_11) == (s_1637_13));
        // N s_1637_15: branch s_1637_14 b2136 b1638
        if s_1637_14 {
            return block_2136(state, tracer, fn_state);
        } else {
            return block_1638(state, tracer, fn_state);
        };
    }
    fn block_1638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1638_0: const #0u : u8
        let s_1638_0: bool = false;
        // D s_1638_1: write-var gs#407909 <= s_1638_0
        fn_state.gs_407909 = s_1638_0;
        // N s_1638_2: jump b1639
        return block_1639(state, tracer, fn_state);
    }
    fn block_1639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1639_0: read-var gs#407909:u8
        let s_1639_0: bool = fn_state.gs_407909;
        // N s_1639_1: branch s_1639_0 b2132 b1640
        if s_1639_0 {
            return block_2132(state, tracer, fn_state);
        } else {
            return block_1640(state, tracer, fn_state);
        };
    }
    fn block_1640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1640_0: const #0u : u8
        let s_1640_0: bool = false;
        // D s_1640_1: write-var gs#407914 <= s_1640_0
        fn_state.gs_407914 = s_1640_0;
        // N s_1640_2: jump b1641
        return block_1641(state, tracer, fn_state);
    }
    fn block_1641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1641_0: read-var gs#407914:u8
        let s_1641_0: bool = fn_state.gs_407914;
        // D s_1641_1: not s_1641_0
        let s_1641_1: bool = !s_1641_0;
        // N s_1641_2: branch s_1641_1 b1660 b1642
        if s_1641_1 {
            return block_1660(state, tracer, fn_state);
        } else {
            return block_1642(state, tracer, fn_state);
        };
    }
    fn block_1642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1642_0: const #3815s : i
        let s_1642_0: i128 = 3815;
        // C s_1642_1: const #14696u : u32
        let s_1642_1: u32 = 14696;
        // N s_1642_2: write-reg s_1642_1 <= s_1642_0
        let s_1642_2: () = {
            state.write_register::<i128>(s_1642_1 as isize, s_1642_0);
            tracer.write_register(s_1642_1 as isize, s_1642_0);
        };
        // C s_1642_3: const #28s : i
        let s_1642_3: i128 = 28;
        // C s_1642_4: const #4s : i
        let s_1642_4: i128 = 4;
        // D s_1642_5: read-var u#33191:u32
        let s_1642_5: u32 = fn_state.u_33191;
        // D s_1642_6: cast zx s_1642_5 -> bv
        let s_1642_6: Bits = Bits::new(s_1642_5 as u128, 32u16);
        // D s_1642_7: bit-extract s_1642_6 s_1642_3 s_1642_4
        let s_1642_7: Bits = (Bits::new(
            ((s_1642_6) >> (s_1642_3)).value(),
            u16::try_from(s_1642_4).unwrap(),
        ));
        // D s_1642_8: cast reint s_1642_7 -> u8
        let s_1642_8: u8 = (s_1642_7.value() as u8);
        // D s_1642_9: write-var u#33192 <= s_1642_8
        fn_state.u_33192 = s_1642_8;
        // C s_1642_10: const #16s : i
        let s_1642_10: i128 = 16;
        // C s_1642_11: const #4s : i
        let s_1642_11: i128 = 4;
        // D s_1642_12: read-var u#33191:u32
        let s_1642_12: u32 = fn_state.u_33191;
        // D s_1642_13: cast zx s_1642_12 -> bv
        let s_1642_13: Bits = Bits::new(s_1642_12 as u128, 32u16);
        // D s_1642_14: bit-extract s_1642_13 s_1642_10 s_1642_11
        let s_1642_14: Bits = (Bits::new(
            ((s_1642_13) >> (s_1642_10)).value(),
            u16::try_from(s_1642_11).unwrap(),
        ));
        // D s_1642_15: cast reint s_1642_14 -> u8
        let s_1642_15: u8 = (s_1642_14.value() as u8);
        // D s_1642_16: write-var u#33193 <= s_1642_15
        fn_state.u_33193 = s_1642_15;
        // C s_1642_17: const #12s : i
        let s_1642_17: i128 = 12;
        // C s_1642_18: const #4s : i
        let s_1642_18: i128 = 4;
        // D s_1642_19: read-var u#33191:u32
        let s_1642_19: u32 = fn_state.u_33191;
        // D s_1642_20: cast zx s_1642_19 -> bv
        let s_1642_20: Bits = Bits::new(s_1642_19 as u128, 32u16);
        // D s_1642_21: bit-extract s_1642_20 s_1642_17 s_1642_18
        let s_1642_21: Bits = (Bits::new(
            ((s_1642_20) >> (s_1642_17)).value(),
            u16::try_from(s_1642_18).unwrap(),
        ));
        // D s_1642_22: cast reint s_1642_21 -> u8
        let s_1642_22: u8 = (s_1642_21.value() as u8);
        // D s_1642_23: write-var u#33194 <= s_1642_22
        fn_state.u_33194 = s_1642_22;
        // C s_1642_24: const #8s : i
        let s_1642_24: i128 = 8;
        // D s_1642_25: read-var u#33191:u32
        let s_1642_25: u32 = fn_state.u_33191;
        // D s_1642_26: cast zx s_1642_25 -> bv
        let s_1642_26: Bits = Bits::new(s_1642_25 as u128, 32u16);
        // C s_1642_27: const #1u : u64
        let s_1642_27: u64 = 1;
        // D s_1642_28: bit-extract s_1642_26 s_1642_24 s_1642_27
        let s_1642_28: Bits = (Bits::new(
            ((s_1642_26) >> (s_1642_24)).value(),
            u16::try_from(s_1642_27).unwrap(),
        ));
        // D s_1642_29: cast reint s_1642_28 -> u8
        let s_1642_29: bool = ((s_1642_28.value()) != 0);
        // C s_1642_30: const #0s : i
        let s_1642_30: i128 = 0;
        // C s_1642_31: const #0u : u64
        let s_1642_31: u64 = 0;
        // D s_1642_32: cast zx s_1642_29 -> u64
        let s_1642_32: u64 = (s_1642_29 as u64);
        // C s_1642_33: const #1u : u64
        let s_1642_33: u64 = 1;
        // D s_1642_34: and s_1642_32 s_1642_33
        let s_1642_34: u64 = ((s_1642_32) & (s_1642_33));
        // D s_1642_35: cmp-eq s_1642_34 s_1642_33
        let s_1642_35: bool = ((s_1642_34) == (s_1642_33));
        // D s_1642_36: lsl s_1642_32 s_1642_30
        let s_1642_36: u64 = s_1642_32 << s_1642_30;
        // D s_1642_37: or s_1642_31 s_1642_36
        let s_1642_37: u64 = ((s_1642_31) | (s_1642_36));
        // D s_1642_38: cmpl s_1642_36
        let s_1642_38: u64 = !s_1642_36;
        // D s_1642_39: and s_1642_31 s_1642_38
        let s_1642_39: u64 = ((s_1642_31) & (s_1642_38));
        // D s_1642_40: select s_1642_35 s_1642_37 s_1642_39
        let s_1642_40: u64 = if s_1642_35 { s_1642_37 } else { s_1642_39 };
        // D s_1642_41: cast trunc s_1642_40 -> u8
        let s_1642_41: bool = ((s_1642_40) != 0);
        // D s_1642_42: cast zx s_1642_41 -> bv
        let s_1642_42: Bits = Bits::new(s_1642_41 as u128, 1u16);
        // C s_1642_43: const #1u : u8
        let s_1642_43: bool = true;
        // C s_1642_44: cast zx s_1642_43 -> bv
        let s_1642_44: Bits = Bits::new(s_1642_43 as u128, 1u16);
        // D s_1642_45: cmp-ne s_1642_42 s_1642_44
        let s_1642_45: bool = ((s_1642_42) != (s_1642_44));
        // N s_1642_46: branch s_1642_45 b1659 b1643
        if s_1642_45 {
            return block_1659(state, tracer, fn_state);
        } else {
            return block_1643(state, tracer, fn_state);
        };
    }
    fn block_1643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1643_0: const #9s : i
        let s_1643_0: i128 = 9;
        // D s_1643_1: read-var u#33191:u32
        let s_1643_1: u32 = fn_state.u_33191;
        // D s_1643_2: cast zx s_1643_1 -> bv
        let s_1643_2: Bits = Bits::new(s_1643_1 as u128, 32u16);
        // C s_1643_3: const #1u : u64
        let s_1643_3: u64 = 1;
        // D s_1643_4: bit-extract s_1643_2 s_1643_0 s_1643_3
        let s_1643_4: Bits = (Bits::new(
            ((s_1643_2) >> (s_1643_0)).value(),
            u16::try_from(s_1643_3).unwrap(),
        ));
        // D s_1643_5: cast reint s_1643_4 -> u8
        let s_1643_5: bool = ((s_1643_4.value()) != 0);
        // C s_1643_6: const #0s : i
        let s_1643_6: i128 = 0;
        // C s_1643_7: const #0u : u64
        let s_1643_7: u64 = 0;
        // D s_1643_8: cast zx s_1643_5 -> u64
        let s_1643_8: u64 = (s_1643_5 as u64);
        // C s_1643_9: const #1u : u64
        let s_1643_9: u64 = 1;
        // D s_1643_10: and s_1643_8 s_1643_9
        let s_1643_10: u64 = ((s_1643_8) & (s_1643_9));
        // D s_1643_11: cmp-eq s_1643_10 s_1643_9
        let s_1643_11: bool = ((s_1643_10) == (s_1643_9));
        // D s_1643_12: lsl s_1643_8 s_1643_6
        let s_1643_12: u64 = s_1643_8 << s_1643_6;
        // D s_1643_13: or s_1643_7 s_1643_12
        let s_1643_13: u64 = ((s_1643_7) | (s_1643_12));
        // D s_1643_14: cmpl s_1643_12
        let s_1643_14: u64 = !s_1643_12;
        // D s_1643_15: and s_1643_7 s_1643_14
        let s_1643_15: u64 = ((s_1643_7) & (s_1643_14));
        // D s_1643_16: select s_1643_11 s_1643_13 s_1643_15
        let s_1643_16: u64 = if s_1643_11 { s_1643_13 } else { s_1643_15 };
        // D s_1643_17: cast trunc s_1643_16 -> u8
        let s_1643_17: bool = ((s_1643_16) != 0);
        // D s_1643_18: cast zx s_1643_17 -> bv
        let s_1643_18: Bits = Bits::new(s_1643_17 as u128, 1u16);
        // C s_1643_19: const #1u : u8
        let s_1643_19: bool = true;
        // C s_1643_20: cast zx s_1643_19 -> bv
        let s_1643_20: Bits = Bits::new(s_1643_19 as u128, 1u16);
        // D s_1643_21: cmp-ne s_1643_18 s_1643_20
        let s_1643_21: bool = ((s_1643_18) != (s_1643_20));
        // D s_1643_22: write-var gs#407927 <= s_1643_21
        fn_state.gs_407927 = s_1643_21;
        // N s_1643_23: jump b1644
        return block_1644(state, tracer, fn_state);
    }
    fn block_1644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1644_0: read-var gs#407927:u8
        let s_1644_0: bool = fn_state.gs_407927;
        // N s_1644_1: branch s_1644_0 b1658 b1645
        if s_1644_0 {
            return block_1658(state, tracer, fn_state);
        } else {
            return block_1645(state, tracer, fn_state);
        };
    }
    fn block_1645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1645_0: const #0s : i
        let s_1645_0: i128 = 0;
        // D s_1645_1: read-var u#33191:u32
        let s_1645_1: u32 = fn_state.u_33191;
        // D s_1645_2: cast zx s_1645_1 -> bv
        let s_1645_2: Bits = Bits::new(s_1645_1 as u128, 32u16);
        // C s_1645_3: const #1u : u64
        let s_1645_3: u64 = 1;
        // D s_1645_4: bit-extract s_1645_2 s_1645_0 s_1645_3
        let s_1645_4: Bits = (Bits::new(
            ((s_1645_2) >> (s_1645_0)).value(),
            u16::try_from(s_1645_3).unwrap(),
        ));
        // D s_1645_5: cast reint s_1645_4 -> u8
        let s_1645_5: bool = ((s_1645_4.value()) != 0);
        // C s_1645_6: const #0s : i
        let s_1645_6: i128 = 0;
        // C s_1645_7: const #0u : u64
        let s_1645_7: u64 = 0;
        // D s_1645_8: cast zx s_1645_5 -> u64
        let s_1645_8: u64 = (s_1645_5 as u64);
        // C s_1645_9: const #1u : u64
        let s_1645_9: u64 = 1;
        // D s_1645_10: and s_1645_8 s_1645_9
        let s_1645_10: u64 = ((s_1645_8) & (s_1645_9));
        // D s_1645_11: cmp-eq s_1645_10 s_1645_9
        let s_1645_11: bool = ((s_1645_10) == (s_1645_9));
        // D s_1645_12: lsl s_1645_8 s_1645_6
        let s_1645_12: u64 = s_1645_8 << s_1645_6;
        // D s_1645_13: or s_1645_7 s_1645_12
        let s_1645_13: u64 = ((s_1645_7) | (s_1645_12));
        // D s_1645_14: cmpl s_1645_12
        let s_1645_14: u64 = !s_1645_12;
        // D s_1645_15: and s_1645_7 s_1645_14
        let s_1645_15: u64 = ((s_1645_7) & (s_1645_14));
        // D s_1645_16: select s_1645_11 s_1645_13 s_1645_15
        let s_1645_16: u64 = if s_1645_11 { s_1645_13 } else { s_1645_15 };
        // D s_1645_17: cast trunc s_1645_16 -> u8
        let s_1645_17: bool = ((s_1645_16) != 0);
        // D s_1645_18: cast zx s_1645_17 -> bv
        let s_1645_18: Bits = Bits::new(s_1645_17 as u128, 1u16);
        // C s_1645_19: const #1u : u8
        let s_1645_19: bool = true;
        // C s_1645_20: cast zx s_1645_19 -> bv
        let s_1645_20: Bits = Bits::new(s_1645_19 as u128, 1u16);
        // D s_1645_21: cmp-ne s_1645_18 s_1645_20
        let s_1645_21: bool = ((s_1645_18) != (s_1645_20));
        // D s_1645_22: write-var gs#407930 <= s_1645_21
        fn_state.gs_407930 = s_1645_21;
        // N s_1645_23: jump b1646
        return block_1646(state, tracer, fn_state);
    }
    fn block_1646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1646_0: read-var gs#407930:u8
        let s_1646_0: bool = fn_state.gs_407930;
        // N s_1646_1: branch s_1646_0 b1657 b1647
        if s_1646_0 {
            return block_1657(state, tracer, fn_state);
        } else {
            return block_1647(state, tracer, fn_state);
        };
    }
    fn block_1647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1647_0: const #1s : i
        let s_1647_0: i128 = 1;
        // D s_1647_1: read-var u#33191:u32
        let s_1647_1: u32 = fn_state.u_33191;
        // D s_1647_2: cast zx s_1647_1 -> bv
        let s_1647_2: Bits = Bits::new(s_1647_1 as u128, 32u16);
        // C s_1647_3: const #1u : u64
        let s_1647_3: u64 = 1;
        // D s_1647_4: bit-extract s_1647_2 s_1647_0 s_1647_3
        let s_1647_4: Bits = (Bits::new(
            ((s_1647_2) >> (s_1647_0)).value(),
            u16::try_from(s_1647_3).unwrap(),
        ));
        // D s_1647_5: cast reint s_1647_4 -> u8
        let s_1647_5: bool = ((s_1647_4.value()) != 0);
        // C s_1647_6: const #0s : i
        let s_1647_6: i128 = 0;
        // C s_1647_7: const #0u : u64
        let s_1647_7: u64 = 0;
        // D s_1647_8: cast zx s_1647_5 -> u64
        let s_1647_8: u64 = (s_1647_5 as u64);
        // C s_1647_9: const #1u : u64
        let s_1647_9: u64 = 1;
        // D s_1647_10: and s_1647_8 s_1647_9
        let s_1647_10: u64 = ((s_1647_8) & (s_1647_9));
        // D s_1647_11: cmp-eq s_1647_10 s_1647_9
        let s_1647_11: bool = ((s_1647_10) == (s_1647_9));
        // D s_1647_12: lsl s_1647_8 s_1647_6
        let s_1647_12: u64 = s_1647_8 << s_1647_6;
        // D s_1647_13: or s_1647_7 s_1647_12
        let s_1647_13: u64 = ((s_1647_7) | (s_1647_12));
        // D s_1647_14: cmpl s_1647_12
        let s_1647_14: u64 = !s_1647_12;
        // D s_1647_15: and s_1647_7 s_1647_14
        let s_1647_15: u64 = ((s_1647_7) & (s_1647_14));
        // D s_1647_16: select s_1647_11 s_1647_13 s_1647_15
        let s_1647_16: u64 = if s_1647_11 { s_1647_13 } else { s_1647_15 };
        // D s_1647_17: cast trunc s_1647_16 -> u8
        let s_1647_17: bool = ((s_1647_16) != 0);
        // D s_1647_18: cast zx s_1647_17 -> bv
        let s_1647_18: Bits = Bits::new(s_1647_17 as u128, 1u16);
        // C s_1647_19: const #1u : u8
        let s_1647_19: bool = true;
        // C s_1647_20: cast zx s_1647_19 -> bv
        let s_1647_20: Bits = Bits::new(s_1647_19 as u128, 1u16);
        // D s_1647_21: cmp-ne s_1647_18 s_1647_20
        let s_1647_21: bool = ((s_1647_18) != (s_1647_20));
        // D s_1647_22: write-var gs#407933 <= s_1647_21
        fn_state.gs_407933 = s_1647_21;
        // N s_1647_23: jump b1648
        return block_1648(state, tracer, fn_state);
    }
    fn block_1648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1648_0: read-var gs#407933:u8
        let s_1648_0: bool = fn_state.gs_407933;
        // N s_1648_1: branch s_1648_0 b1656 b1649
        if s_1648_0 {
            return block_1656(state, tracer, fn_state);
        } else {
            return block_1649(state, tracer, fn_state);
        };
    }
    fn block_1649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1649_0: const #2s : i
        let s_1649_0: i128 = 2;
        // D s_1649_1: read-var u#33191:u32
        let s_1649_1: u32 = fn_state.u_33191;
        // D s_1649_2: cast zx s_1649_1 -> bv
        let s_1649_2: Bits = Bits::new(s_1649_1 as u128, 32u16);
        // C s_1649_3: const #1u : u64
        let s_1649_3: u64 = 1;
        // D s_1649_4: bit-extract s_1649_2 s_1649_0 s_1649_3
        let s_1649_4: Bits = (Bits::new(
            ((s_1649_2) >> (s_1649_0)).value(),
            u16::try_from(s_1649_3).unwrap(),
        ));
        // D s_1649_5: cast reint s_1649_4 -> u8
        let s_1649_5: bool = ((s_1649_4.value()) != 0);
        // C s_1649_6: const #0s : i
        let s_1649_6: i128 = 0;
        // C s_1649_7: const #0u : u64
        let s_1649_7: u64 = 0;
        // D s_1649_8: cast zx s_1649_5 -> u64
        let s_1649_8: u64 = (s_1649_5 as u64);
        // C s_1649_9: const #1u : u64
        let s_1649_9: u64 = 1;
        // D s_1649_10: and s_1649_8 s_1649_9
        let s_1649_10: u64 = ((s_1649_8) & (s_1649_9));
        // D s_1649_11: cmp-eq s_1649_10 s_1649_9
        let s_1649_11: bool = ((s_1649_10) == (s_1649_9));
        // D s_1649_12: lsl s_1649_8 s_1649_6
        let s_1649_12: u64 = s_1649_8 << s_1649_6;
        // D s_1649_13: or s_1649_7 s_1649_12
        let s_1649_13: u64 = ((s_1649_7) | (s_1649_12));
        // D s_1649_14: cmpl s_1649_12
        let s_1649_14: u64 = !s_1649_12;
        // D s_1649_15: and s_1649_7 s_1649_14
        let s_1649_15: u64 = ((s_1649_7) & (s_1649_14));
        // D s_1649_16: select s_1649_11 s_1649_13 s_1649_15
        let s_1649_16: u64 = if s_1649_11 { s_1649_13 } else { s_1649_15 };
        // D s_1649_17: cast trunc s_1649_16 -> u8
        let s_1649_17: bool = ((s_1649_16) != 0);
        // D s_1649_18: cast zx s_1649_17 -> bv
        let s_1649_18: Bits = Bits::new(s_1649_17 as u128, 1u16);
        // C s_1649_19: const #1u : u8
        let s_1649_19: bool = true;
        // C s_1649_20: cast zx s_1649_19 -> bv
        let s_1649_20: Bits = Bits::new(s_1649_19 as u128, 1u16);
        // D s_1649_21: cmp-ne s_1649_18 s_1649_20
        let s_1649_21: bool = ((s_1649_18) != (s_1649_20));
        // D s_1649_22: write-var gs#407936 <= s_1649_21
        fn_state.gs_407936 = s_1649_21;
        // N s_1649_23: jump b1650
        return block_1650(state, tracer, fn_state);
    }
    fn block_1650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1650_0: read-var gs#407936:u8
        let s_1650_0: bool = fn_state.gs_407936;
        // N s_1650_1: branch s_1650_0 b1655 b1651
        if s_1650_0 {
            return block_1655(state, tracer, fn_state);
        } else {
            return block_1651(state, tracer, fn_state);
        };
    }
    fn block_1651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1651_0: const #3s : i
        let s_1651_0: i128 = 3;
        // D s_1651_1: read-var u#33191:u32
        let s_1651_1: u32 = fn_state.u_33191;
        // D s_1651_2: cast zx s_1651_1 -> bv
        let s_1651_2: Bits = Bits::new(s_1651_1 as u128, 32u16);
        // C s_1651_3: const #1u : u64
        let s_1651_3: u64 = 1;
        // D s_1651_4: bit-extract s_1651_2 s_1651_0 s_1651_3
        let s_1651_4: Bits = (Bits::new(
            ((s_1651_2) >> (s_1651_0)).value(),
            u16::try_from(s_1651_3).unwrap(),
        ));
        // D s_1651_5: cast reint s_1651_4 -> u8
        let s_1651_5: bool = ((s_1651_4.value()) != 0);
        // C s_1651_6: const #0s : i
        let s_1651_6: i128 = 0;
        // C s_1651_7: const #0u : u64
        let s_1651_7: u64 = 0;
        // D s_1651_8: cast zx s_1651_5 -> u64
        let s_1651_8: u64 = (s_1651_5 as u64);
        // C s_1651_9: const #1u : u64
        let s_1651_9: u64 = 1;
        // D s_1651_10: and s_1651_8 s_1651_9
        let s_1651_10: u64 = ((s_1651_8) & (s_1651_9));
        // D s_1651_11: cmp-eq s_1651_10 s_1651_9
        let s_1651_11: bool = ((s_1651_10) == (s_1651_9));
        // D s_1651_12: lsl s_1651_8 s_1651_6
        let s_1651_12: u64 = s_1651_8 << s_1651_6;
        // D s_1651_13: or s_1651_7 s_1651_12
        let s_1651_13: u64 = ((s_1651_7) | (s_1651_12));
        // D s_1651_14: cmpl s_1651_12
        let s_1651_14: u64 = !s_1651_12;
        // D s_1651_15: and s_1651_7 s_1651_14
        let s_1651_15: u64 = ((s_1651_7) & (s_1651_14));
        // D s_1651_16: select s_1651_11 s_1651_13 s_1651_15
        let s_1651_16: u64 = if s_1651_11 { s_1651_13 } else { s_1651_15 };
        // D s_1651_17: cast trunc s_1651_16 -> u8
        let s_1651_17: bool = ((s_1651_16) != 0);
        // D s_1651_18: cast zx s_1651_17 -> bv
        let s_1651_18: Bits = Bits::new(s_1651_17 as u128, 1u16);
        // C s_1651_19: const #1u : u8
        let s_1651_19: bool = true;
        // C s_1651_20: cast zx s_1651_19 -> bv
        let s_1651_20: Bits = Bits::new(s_1651_19 as u128, 1u16);
        // D s_1651_21: cmp-ne s_1651_18 s_1651_20
        let s_1651_21: bool = ((s_1651_18) != (s_1651_20));
        // D s_1651_22: write-var gs#407939 <= s_1651_21
        fn_state.gs_407939 = s_1651_21;
        // N s_1651_23: jump b1652
        return block_1652(state, tracer, fn_state);
    }
    fn block_1652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1652_0: read-var gs#407939:u8
        let s_1652_0: bool = fn_state.gs_407939;
        // N s_1652_1: branch s_1652_0 b1654 b1653
        if s_1652_0 {
            return block_1654(state, tracer, fn_state);
        } else {
            return block_1653(state, tracer, fn_state);
        };
    }
    fn block_1653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1653_0: read-var u#33192:u8
        let s_1653_0: u8 = fn_state.u_33192;
        // D s_1653_1: read-var u#33193:u8
        let s_1653_1: u8 = fn_state.u_33193;
        // D s_1653_2: read-var u#33194:u8
        let s_1653_2: u8 = fn_state.u_33194;
        // D s_1653_3: call decode_aarch32_instrs_LDA_A1enc_A_txt(s_1653_0, s_1653_1, s_1653_2)
        let s_1653_3: () = decode_aarch32_instrs_LDA_A1enc_A_txt(
            state,
            tracer,
            s_1653_0,
            s_1653_1,
            s_1653_2,
        );
        // N s_1653_4: return
        return;
    }
    fn block_1654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1654_0: panic
        panic!("{:?}", ());
        // N s_1654_1: return
        return;
    }
    fn block_1655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1655_0: const #1u : u8
        let s_1655_0: bool = true;
        // D s_1655_1: write-var gs#407939 <= s_1655_0
        fn_state.gs_407939 = s_1655_0;
        // N s_1655_2: jump b1652
        return block_1652(state, tracer, fn_state);
    }
    fn block_1656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1656_0: const #1u : u8
        let s_1656_0: bool = true;
        // D s_1656_1: write-var gs#407936 <= s_1656_0
        fn_state.gs_407936 = s_1656_0;
        // N s_1656_2: jump b1650
        return block_1650(state, tracer, fn_state);
    }
    fn block_1657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1657_0: const #1u : u8
        let s_1657_0: bool = true;
        // D s_1657_1: write-var gs#407933 <= s_1657_0
        fn_state.gs_407933 = s_1657_0;
        // N s_1657_2: jump b1648
        return block_1648(state, tracer, fn_state);
    }
    fn block_1658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1658_0: const #1u : u8
        let s_1658_0: bool = true;
        // D s_1658_1: write-var gs#407930 <= s_1658_0
        fn_state.gs_407930 = s_1658_0;
        // N s_1658_2: jump b1646
        return block_1646(state, tracer, fn_state);
    }
    fn block_1659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1659_0: const #1u : u8
        let s_1659_0: bool = true;
        // D s_1659_1: write-var gs#407927 <= s_1659_0
        fn_state.gs_407927 = s_1659_0;
        // N s_1659_2: jump b1644
        return block_1644(state, tracer, fn_state);
    }
    fn block_1660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1660_0: read-var merge#var.1:struct
        let s_1660_0: u32 = fn_state.merge_var._1;
        // D s_1660_1: write-var u#33196 <= s_1660_0
        fn_state.u_33196 = s_1660_0;
        // C s_1660_2: const #20s : i
        let s_1660_2: i128 = 20;
        // D s_1660_3: read-var u#33196:u32
        let s_1660_3: u32 = fn_state.u_33196;
        // D s_1660_4: cast zx s_1660_3 -> bv
        let s_1660_4: Bits = Bits::new(s_1660_3 as u128, 32u16);
        // C s_1660_5: const #1s : i64
        let s_1660_5: i64 = 1;
        // C s_1660_6: cast zx s_1660_5 -> i
        let s_1660_6: i128 = (i128::try_from(s_1660_5).unwrap());
        // C s_1660_7: const #7s : i
        let s_1660_7: i128 = 7;
        // C s_1660_8: add s_1660_7 s_1660_6
        let s_1660_8: i128 = (s_1660_7 + s_1660_6);
        // D s_1660_9: bit-extract s_1660_4 s_1660_2 s_1660_8
        let s_1660_9: Bits = (Bits::new(
            ((s_1660_4) >> (s_1660_2)).value(),
            u16::try_from(s_1660_8).unwrap(),
        ));
        // D s_1660_10: cast reint s_1660_9 -> u8
        let s_1660_10: u8 = (s_1660_9.value() as u8);
        // D s_1660_11: cast zx s_1660_10 -> bv
        let s_1660_11: Bits = Bits::new(s_1660_10 as u128, 8u16);
        // C s_1660_12: const #29u : u8
        let s_1660_12: u8 = 29;
        // C s_1660_13: cast zx s_1660_12 -> bv
        let s_1660_13: Bits = Bits::new(s_1660_12 as u128, 8u16);
        // D s_1660_14: cmp-eq s_1660_11 s_1660_13
        let s_1660_14: bool = ((s_1660_11) == (s_1660_13));
        // N s_1660_15: branch s_1660_14 b2131 b1661
        if s_1660_14 {
            return block_2131(state, tracer, fn_state);
        } else {
            return block_1661(state, tracer, fn_state);
        };
    }
    fn block_1661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1661_0: const #0u : u8
        let s_1661_0: bool = false;
        // D s_1661_1: write-var gs#407945 <= s_1661_0
        fn_state.gs_407945 = s_1661_0;
        // N s_1661_2: jump b1662
        return block_1662(state, tracer, fn_state);
    }
    fn block_1662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1662_0: read-var gs#407945:u8
        let s_1662_0: bool = fn_state.gs_407945;
        // N s_1662_1: branch s_1662_0 b2127 b1663
        if s_1662_0 {
            return block_2127(state, tracer, fn_state);
        } else {
            return block_1663(state, tracer, fn_state);
        };
    }
    fn block_1663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1663_0: const #0u : u8
        let s_1663_0: bool = false;
        // D s_1663_1: write-var gs#407950 <= s_1663_0
        fn_state.gs_407950 = s_1663_0;
        // N s_1663_2: jump b1664
        return block_1664(state, tracer, fn_state);
    }
    fn block_1664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1664_0: read-var gs#407950:u8
        let s_1664_0: bool = fn_state.gs_407950;
        // D s_1664_1: not s_1664_0
        let s_1664_1: bool = !s_1664_0;
        // N s_1664_2: branch s_1664_1 b1683 b1665
        if s_1664_1 {
            return block_1683(state, tracer, fn_state);
        } else {
            return block_1665(state, tracer, fn_state);
        };
    }
    fn block_1665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1665_0: const #3817s : i
        let s_1665_0: i128 = 3817;
        // C s_1665_1: const #14696u : u32
        let s_1665_1: u32 = 14696;
        // N s_1665_2: write-reg s_1665_1 <= s_1665_0
        let s_1665_2: () = {
            state.write_register::<i128>(s_1665_1 as isize, s_1665_0);
            tracer.write_register(s_1665_1 as isize, s_1665_0);
        };
        // C s_1665_3: const #28s : i
        let s_1665_3: i128 = 28;
        // C s_1665_4: const #4s : i
        let s_1665_4: i128 = 4;
        // D s_1665_5: read-var u#33196:u32
        let s_1665_5: u32 = fn_state.u_33196;
        // D s_1665_6: cast zx s_1665_5 -> bv
        let s_1665_6: Bits = Bits::new(s_1665_5 as u128, 32u16);
        // D s_1665_7: bit-extract s_1665_6 s_1665_3 s_1665_4
        let s_1665_7: Bits = (Bits::new(
            ((s_1665_6) >> (s_1665_3)).value(),
            u16::try_from(s_1665_4).unwrap(),
        ));
        // D s_1665_8: cast reint s_1665_7 -> u8
        let s_1665_8: u8 = (s_1665_7.value() as u8);
        // D s_1665_9: write-var u#33197 <= s_1665_8
        fn_state.u_33197 = s_1665_8;
        // C s_1665_10: const #16s : i
        let s_1665_10: i128 = 16;
        // C s_1665_11: const #4s : i
        let s_1665_11: i128 = 4;
        // D s_1665_12: read-var u#33196:u32
        let s_1665_12: u32 = fn_state.u_33196;
        // D s_1665_13: cast zx s_1665_12 -> bv
        let s_1665_13: Bits = Bits::new(s_1665_12 as u128, 32u16);
        // D s_1665_14: bit-extract s_1665_13 s_1665_10 s_1665_11
        let s_1665_14: Bits = (Bits::new(
            ((s_1665_13) >> (s_1665_10)).value(),
            u16::try_from(s_1665_11).unwrap(),
        ));
        // D s_1665_15: cast reint s_1665_14 -> u8
        let s_1665_15: u8 = (s_1665_14.value() as u8);
        // D s_1665_16: write-var u#33198 <= s_1665_15
        fn_state.u_33198 = s_1665_15;
        // C s_1665_17: const #12s : i
        let s_1665_17: i128 = 12;
        // C s_1665_18: const #4s : i
        let s_1665_18: i128 = 4;
        // D s_1665_19: read-var u#33196:u32
        let s_1665_19: u32 = fn_state.u_33196;
        // D s_1665_20: cast zx s_1665_19 -> bv
        let s_1665_20: Bits = Bits::new(s_1665_19 as u128, 32u16);
        // D s_1665_21: bit-extract s_1665_20 s_1665_17 s_1665_18
        let s_1665_21: Bits = (Bits::new(
            ((s_1665_20) >> (s_1665_17)).value(),
            u16::try_from(s_1665_18).unwrap(),
        ));
        // D s_1665_22: cast reint s_1665_21 -> u8
        let s_1665_22: u8 = (s_1665_21.value() as u8);
        // D s_1665_23: write-var u#33199 <= s_1665_22
        fn_state.u_33199 = s_1665_22;
        // C s_1665_24: const #8s : i
        let s_1665_24: i128 = 8;
        // D s_1665_25: read-var u#33196:u32
        let s_1665_25: u32 = fn_state.u_33196;
        // D s_1665_26: cast zx s_1665_25 -> bv
        let s_1665_26: Bits = Bits::new(s_1665_25 as u128, 32u16);
        // C s_1665_27: const #1u : u64
        let s_1665_27: u64 = 1;
        // D s_1665_28: bit-extract s_1665_26 s_1665_24 s_1665_27
        let s_1665_28: Bits = (Bits::new(
            ((s_1665_26) >> (s_1665_24)).value(),
            u16::try_from(s_1665_27).unwrap(),
        ));
        // D s_1665_29: cast reint s_1665_28 -> u8
        let s_1665_29: bool = ((s_1665_28.value()) != 0);
        // C s_1665_30: const #0s : i
        let s_1665_30: i128 = 0;
        // C s_1665_31: const #0u : u64
        let s_1665_31: u64 = 0;
        // D s_1665_32: cast zx s_1665_29 -> u64
        let s_1665_32: u64 = (s_1665_29 as u64);
        // C s_1665_33: const #1u : u64
        let s_1665_33: u64 = 1;
        // D s_1665_34: and s_1665_32 s_1665_33
        let s_1665_34: u64 = ((s_1665_32) & (s_1665_33));
        // D s_1665_35: cmp-eq s_1665_34 s_1665_33
        let s_1665_35: bool = ((s_1665_34) == (s_1665_33));
        // D s_1665_36: lsl s_1665_32 s_1665_30
        let s_1665_36: u64 = s_1665_32 << s_1665_30;
        // D s_1665_37: or s_1665_31 s_1665_36
        let s_1665_37: u64 = ((s_1665_31) | (s_1665_36));
        // D s_1665_38: cmpl s_1665_36
        let s_1665_38: u64 = !s_1665_36;
        // D s_1665_39: and s_1665_31 s_1665_38
        let s_1665_39: u64 = ((s_1665_31) & (s_1665_38));
        // D s_1665_40: select s_1665_35 s_1665_37 s_1665_39
        let s_1665_40: u64 = if s_1665_35 { s_1665_37 } else { s_1665_39 };
        // D s_1665_41: cast trunc s_1665_40 -> u8
        let s_1665_41: bool = ((s_1665_40) != 0);
        // D s_1665_42: cast zx s_1665_41 -> bv
        let s_1665_42: Bits = Bits::new(s_1665_41 as u128, 1u16);
        // C s_1665_43: const #1u : u8
        let s_1665_43: bool = true;
        // C s_1665_44: cast zx s_1665_43 -> bv
        let s_1665_44: Bits = Bits::new(s_1665_43 as u128, 1u16);
        // D s_1665_45: cmp-ne s_1665_42 s_1665_44
        let s_1665_45: bool = ((s_1665_42) != (s_1665_44));
        // N s_1665_46: branch s_1665_45 b1682 b1666
        if s_1665_45 {
            return block_1682(state, tracer, fn_state);
        } else {
            return block_1666(state, tracer, fn_state);
        };
    }
    fn block_1666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1666_0: const #9s : i
        let s_1666_0: i128 = 9;
        // D s_1666_1: read-var u#33196:u32
        let s_1666_1: u32 = fn_state.u_33196;
        // D s_1666_2: cast zx s_1666_1 -> bv
        let s_1666_2: Bits = Bits::new(s_1666_1 as u128, 32u16);
        // C s_1666_3: const #1u : u64
        let s_1666_3: u64 = 1;
        // D s_1666_4: bit-extract s_1666_2 s_1666_0 s_1666_3
        let s_1666_4: Bits = (Bits::new(
            ((s_1666_2) >> (s_1666_0)).value(),
            u16::try_from(s_1666_3).unwrap(),
        ));
        // D s_1666_5: cast reint s_1666_4 -> u8
        let s_1666_5: bool = ((s_1666_4.value()) != 0);
        // C s_1666_6: const #0s : i
        let s_1666_6: i128 = 0;
        // C s_1666_7: const #0u : u64
        let s_1666_7: u64 = 0;
        // D s_1666_8: cast zx s_1666_5 -> u64
        let s_1666_8: u64 = (s_1666_5 as u64);
        // C s_1666_9: const #1u : u64
        let s_1666_9: u64 = 1;
        // D s_1666_10: and s_1666_8 s_1666_9
        let s_1666_10: u64 = ((s_1666_8) & (s_1666_9));
        // D s_1666_11: cmp-eq s_1666_10 s_1666_9
        let s_1666_11: bool = ((s_1666_10) == (s_1666_9));
        // D s_1666_12: lsl s_1666_8 s_1666_6
        let s_1666_12: u64 = s_1666_8 << s_1666_6;
        // D s_1666_13: or s_1666_7 s_1666_12
        let s_1666_13: u64 = ((s_1666_7) | (s_1666_12));
        // D s_1666_14: cmpl s_1666_12
        let s_1666_14: u64 = !s_1666_12;
        // D s_1666_15: and s_1666_7 s_1666_14
        let s_1666_15: u64 = ((s_1666_7) & (s_1666_14));
        // D s_1666_16: select s_1666_11 s_1666_13 s_1666_15
        let s_1666_16: u64 = if s_1666_11 { s_1666_13 } else { s_1666_15 };
        // D s_1666_17: cast trunc s_1666_16 -> u8
        let s_1666_17: bool = ((s_1666_16) != 0);
        // D s_1666_18: cast zx s_1666_17 -> bv
        let s_1666_18: Bits = Bits::new(s_1666_17 as u128, 1u16);
        // C s_1666_19: const #1u : u8
        let s_1666_19: bool = true;
        // C s_1666_20: cast zx s_1666_19 -> bv
        let s_1666_20: Bits = Bits::new(s_1666_19 as u128, 1u16);
        // D s_1666_21: cmp-ne s_1666_18 s_1666_20
        let s_1666_21: bool = ((s_1666_18) != (s_1666_20));
        // D s_1666_22: write-var gs#407963 <= s_1666_21
        fn_state.gs_407963 = s_1666_21;
        // N s_1666_23: jump b1667
        return block_1667(state, tracer, fn_state);
    }
    fn block_1667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1667_0: read-var gs#407963:u8
        let s_1667_0: bool = fn_state.gs_407963;
        // N s_1667_1: branch s_1667_0 b1681 b1668
        if s_1667_0 {
            return block_1681(state, tracer, fn_state);
        } else {
            return block_1668(state, tracer, fn_state);
        };
    }
    fn block_1668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1668_0: const #0s : i
        let s_1668_0: i128 = 0;
        // D s_1668_1: read-var u#33196:u32
        let s_1668_1: u32 = fn_state.u_33196;
        // D s_1668_2: cast zx s_1668_1 -> bv
        let s_1668_2: Bits = Bits::new(s_1668_1 as u128, 32u16);
        // C s_1668_3: const #1u : u64
        let s_1668_3: u64 = 1;
        // D s_1668_4: bit-extract s_1668_2 s_1668_0 s_1668_3
        let s_1668_4: Bits = (Bits::new(
            ((s_1668_2) >> (s_1668_0)).value(),
            u16::try_from(s_1668_3).unwrap(),
        ));
        // D s_1668_5: cast reint s_1668_4 -> u8
        let s_1668_5: bool = ((s_1668_4.value()) != 0);
        // C s_1668_6: const #0s : i
        let s_1668_6: i128 = 0;
        // C s_1668_7: const #0u : u64
        let s_1668_7: u64 = 0;
        // D s_1668_8: cast zx s_1668_5 -> u64
        let s_1668_8: u64 = (s_1668_5 as u64);
        // C s_1668_9: const #1u : u64
        let s_1668_9: u64 = 1;
        // D s_1668_10: and s_1668_8 s_1668_9
        let s_1668_10: u64 = ((s_1668_8) & (s_1668_9));
        // D s_1668_11: cmp-eq s_1668_10 s_1668_9
        let s_1668_11: bool = ((s_1668_10) == (s_1668_9));
        // D s_1668_12: lsl s_1668_8 s_1668_6
        let s_1668_12: u64 = s_1668_8 << s_1668_6;
        // D s_1668_13: or s_1668_7 s_1668_12
        let s_1668_13: u64 = ((s_1668_7) | (s_1668_12));
        // D s_1668_14: cmpl s_1668_12
        let s_1668_14: u64 = !s_1668_12;
        // D s_1668_15: and s_1668_7 s_1668_14
        let s_1668_15: u64 = ((s_1668_7) & (s_1668_14));
        // D s_1668_16: select s_1668_11 s_1668_13 s_1668_15
        let s_1668_16: u64 = if s_1668_11 { s_1668_13 } else { s_1668_15 };
        // D s_1668_17: cast trunc s_1668_16 -> u8
        let s_1668_17: bool = ((s_1668_16) != 0);
        // D s_1668_18: cast zx s_1668_17 -> bv
        let s_1668_18: Bits = Bits::new(s_1668_17 as u128, 1u16);
        // C s_1668_19: const #1u : u8
        let s_1668_19: bool = true;
        // C s_1668_20: cast zx s_1668_19 -> bv
        let s_1668_20: Bits = Bits::new(s_1668_19 as u128, 1u16);
        // D s_1668_21: cmp-ne s_1668_18 s_1668_20
        let s_1668_21: bool = ((s_1668_18) != (s_1668_20));
        // D s_1668_22: write-var gs#407966 <= s_1668_21
        fn_state.gs_407966 = s_1668_21;
        // N s_1668_23: jump b1669
        return block_1669(state, tracer, fn_state);
    }
    fn block_1669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1669_0: read-var gs#407966:u8
        let s_1669_0: bool = fn_state.gs_407966;
        // N s_1669_1: branch s_1669_0 b1680 b1670
        if s_1669_0 {
            return block_1680(state, tracer, fn_state);
        } else {
            return block_1670(state, tracer, fn_state);
        };
    }
    fn block_1670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1670_0: const #1s : i
        let s_1670_0: i128 = 1;
        // D s_1670_1: read-var u#33196:u32
        let s_1670_1: u32 = fn_state.u_33196;
        // D s_1670_2: cast zx s_1670_1 -> bv
        let s_1670_2: Bits = Bits::new(s_1670_1 as u128, 32u16);
        // C s_1670_3: const #1u : u64
        let s_1670_3: u64 = 1;
        // D s_1670_4: bit-extract s_1670_2 s_1670_0 s_1670_3
        let s_1670_4: Bits = (Bits::new(
            ((s_1670_2) >> (s_1670_0)).value(),
            u16::try_from(s_1670_3).unwrap(),
        ));
        // D s_1670_5: cast reint s_1670_4 -> u8
        let s_1670_5: bool = ((s_1670_4.value()) != 0);
        // C s_1670_6: const #0s : i
        let s_1670_6: i128 = 0;
        // C s_1670_7: const #0u : u64
        let s_1670_7: u64 = 0;
        // D s_1670_8: cast zx s_1670_5 -> u64
        let s_1670_8: u64 = (s_1670_5 as u64);
        // C s_1670_9: const #1u : u64
        let s_1670_9: u64 = 1;
        // D s_1670_10: and s_1670_8 s_1670_9
        let s_1670_10: u64 = ((s_1670_8) & (s_1670_9));
        // D s_1670_11: cmp-eq s_1670_10 s_1670_9
        let s_1670_11: bool = ((s_1670_10) == (s_1670_9));
        // D s_1670_12: lsl s_1670_8 s_1670_6
        let s_1670_12: u64 = s_1670_8 << s_1670_6;
        // D s_1670_13: or s_1670_7 s_1670_12
        let s_1670_13: u64 = ((s_1670_7) | (s_1670_12));
        // D s_1670_14: cmpl s_1670_12
        let s_1670_14: u64 = !s_1670_12;
        // D s_1670_15: and s_1670_7 s_1670_14
        let s_1670_15: u64 = ((s_1670_7) & (s_1670_14));
        // D s_1670_16: select s_1670_11 s_1670_13 s_1670_15
        let s_1670_16: u64 = if s_1670_11 { s_1670_13 } else { s_1670_15 };
        // D s_1670_17: cast trunc s_1670_16 -> u8
        let s_1670_17: bool = ((s_1670_16) != 0);
        // D s_1670_18: cast zx s_1670_17 -> bv
        let s_1670_18: Bits = Bits::new(s_1670_17 as u128, 1u16);
        // C s_1670_19: const #1u : u8
        let s_1670_19: bool = true;
        // C s_1670_20: cast zx s_1670_19 -> bv
        let s_1670_20: Bits = Bits::new(s_1670_19 as u128, 1u16);
        // D s_1670_21: cmp-ne s_1670_18 s_1670_20
        let s_1670_21: bool = ((s_1670_18) != (s_1670_20));
        // D s_1670_22: write-var gs#407969 <= s_1670_21
        fn_state.gs_407969 = s_1670_21;
        // N s_1670_23: jump b1671
        return block_1671(state, tracer, fn_state);
    }
    fn block_1671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1671_0: read-var gs#407969:u8
        let s_1671_0: bool = fn_state.gs_407969;
        // N s_1671_1: branch s_1671_0 b1679 b1672
        if s_1671_0 {
            return block_1679(state, tracer, fn_state);
        } else {
            return block_1672(state, tracer, fn_state);
        };
    }
    fn block_1672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1672_0: const #2s : i
        let s_1672_0: i128 = 2;
        // D s_1672_1: read-var u#33196:u32
        let s_1672_1: u32 = fn_state.u_33196;
        // D s_1672_2: cast zx s_1672_1 -> bv
        let s_1672_2: Bits = Bits::new(s_1672_1 as u128, 32u16);
        // C s_1672_3: const #1u : u64
        let s_1672_3: u64 = 1;
        // D s_1672_4: bit-extract s_1672_2 s_1672_0 s_1672_3
        let s_1672_4: Bits = (Bits::new(
            ((s_1672_2) >> (s_1672_0)).value(),
            u16::try_from(s_1672_3).unwrap(),
        ));
        // D s_1672_5: cast reint s_1672_4 -> u8
        let s_1672_5: bool = ((s_1672_4.value()) != 0);
        // C s_1672_6: const #0s : i
        let s_1672_6: i128 = 0;
        // C s_1672_7: const #0u : u64
        let s_1672_7: u64 = 0;
        // D s_1672_8: cast zx s_1672_5 -> u64
        let s_1672_8: u64 = (s_1672_5 as u64);
        // C s_1672_9: const #1u : u64
        let s_1672_9: u64 = 1;
        // D s_1672_10: and s_1672_8 s_1672_9
        let s_1672_10: u64 = ((s_1672_8) & (s_1672_9));
        // D s_1672_11: cmp-eq s_1672_10 s_1672_9
        let s_1672_11: bool = ((s_1672_10) == (s_1672_9));
        // D s_1672_12: lsl s_1672_8 s_1672_6
        let s_1672_12: u64 = s_1672_8 << s_1672_6;
        // D s_1672_13: or s_1672_7 s_1672_12
        let s_1672_13: u64 = ((s_1672_7) | (s_1672_12));
        // D s_1672_14: cmpl s_1672_12
        let s_1672_14: u64 = !s_1672_12;
        // D s_1672_15: and s_1672_7 s_1672_14
        let s_1672_15: u64 = ((s_1672_7) & (s_1672_14));
        // D s_1672_16: select s_1672_11 s_1672_13 s_1672_15
        let s_1672_16: u64 = if s_1672_11 { s_1672_13 } else { s_1672_15 };
        // D s_1672_17: cast trunc s_1672_16 -> u8
        let s_1672_17: bool = ((s_1672_16) != 0);
        // D s_1672_18: cast zx s_1672_17 -> bv
        let s_1672_18: Bits = Bits::new(s_1672_17 as u128, 1u16);
        // C s_1672_19: const #1u : u8
        let s_1672_19: bool = true;
        // C s_1672_20: cast zx s_1672_19 -> bv
        let s_1672_20: Bits = Bits::new(s_1672_19 as u128, 1u16);
        // D s_1672_21: cmp-ne s_1672_18 s_1672_20
        let s_1672_21: bool = ((s_1672_18) != (s_1672_20));
        // D s_1672_22: write-var gs#407972 <= s_1672_21
        fn_state.gs_407972 = s_1672_21;
        // N s_1672_23: jump b1673
        return block_1673(state, tracer, fn_state);
    }
    fn block_1673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1673_0: read-var gs#407972:u8
        let s_1673_0: bool = fn_state.gs_407972;
        // N s_1673_1: branch s_1673_0 b1678 b1674
        if s_1673_0 {
            return block_1678(state, tracer, fn_state);
        } else {
            return block_1674(state, tracer, fn_state);
        };
    }
    fn block_1674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1674_0: const #3s : i
        let s_1674_0: i128 = 3;
        // D s_1674_1: read-var u#33196:u32
        let s_1674_1: u32 = fn_state.u_33196;
        // D s_1674_2: cast zx s_1674_1 -> bv
        let s_1674_2: Bits = Bits::new(s_1674_1 as u128, 32u16);
        // C s_1674_3: const #1u : u64
        let s_1674_3: u64 = 1;
        // D s_1674_4: bit-extract s_1674_2 s_1674_0 s_1674_3
        let s_1674_4: Bits = (Bits::new(
            ((s_1674_2) >> (s_1674_0)).value(),
            u16::try_from(s_1674_3).unwrap(),
        ));
        // D s_1674_5: cast reint s_1674_4 -> u8
        let s_1674_5: bool = ((s_1674_4.value()) != 0);
        // C s_1674_6: const #0s : i
        let s_1674_6: i128 = 0;
        // C s_1674_7: const #0u : u64
        let s_1674_7: u64 = 0;
        // D s_1674_8: cast zx s_1674_5 -> u64
        let s_1674_8: u64 = (s_1674_5 as u64);
        // C s_1674_9: const #1u : u64
        let s_1674_9: u64 = 1;
        // D s_1674_10: and s_1674_8 s_1674_9
        let s_1674_10: u64 = ((s_1674_8) & (s_1674_9));
        // D s_1674_11: cmp-eq s_1674_10 s_1674_9
        let s_1674_11: bool = ((s_1674_10) == (s_1674_9));
        // D s_1674_12: lsl s_1674_8 s_1674_6
        let s_1674_12: u64 = s_1674_8 << s_1674_6;
        // D s_1674_13: or s_1674_7 s_1674_12
        let s_1674_13: u64 = ((s_1674_7) | (s_1674_12));
        // D s_1674_14: cmpl s_1674_12
        let s_1674_14: u64 = !s_1674_12;
        // D s_1674_15: and s_1674_7 s_1674_14
        let s_1674_15: u64 = ((s_1674_7) & (s_1674_14));
        // D s_1674_16: select s_1674_11 s_1674_13 s_1674_15
        let s_1674_16: u64 = if s_1674_11 { s_1674_13 } else { s_1674_15 };
        // D s_1674_17: cast trunc s_1674_16 -> u8
        let s_1674_17: bool = ((s_1674_16) != 0);
        // D s_1674_18: cast zx s_1674_17 -> bv
        let s_1674_18: Bits = Bits::new(s_1674_17 as u128, 1u16);
        // C s_1674_19: const #1u : u8
        let s_1674_19: bool = true;
        // C s_1674_20: cast zx s_1674_19 -> bv
        let s_1674_20: Bits = Bits::new(s_1674_19 as u128, 1u16);
        // D s_1674_21: cmp-ne s_1674_18 s_1674_20
        let s_1674_21: bool = ((s_1674_18) != (s_1674_20));
        // D s_1674_22: write-var gs#407975 <= s_1674_21
        fn_state.gs_407975 = s_1674_21;
        // N s_1674_23: jump b1675
        return block_1675(state, tracer, fn_state);
    }
    fn block_1675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1675_0: read-var gs#407975:u8
        let s_1675_0: bool = fn_state.gs_407975;
        // N s_1675_1: branch s_1675_0 b1677 b1676
        if s_1675_0 {
            return block_1677(state, tracer, fn_state);
        } else {
            return block_1676(state, tracer, fn_state);
        };
    }
    fn block_1676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1676_0: read-var u#33197:u8
        let s_1676_0: u8 = fn_state.u_33197;
        // D s_1676_1: read-var u#33198:u8
        let s_1676_1: u8 = fn_state.u_33198;
        // D s_1676_2: read-var u#33199:u8
        let s_1676_2: u8 = fn_state.u_33199;
        // D s_1676_3: call decode_aarch32_instrs_LDAB_A1enc_A_txt(s_1676_0, s_1676_1, s_1676_2)
        let s_1676_3: () = decode_aarch32_instrs_LDAB_A1enc_A_txt(
            state,
            tracer,
            s_1676_0,
            s_1676_1,
            s_1676_2,
        );
        // N s_1676_4: return
        return;
    }
    fn block_1677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1677_0: panic
        panic!("{:?}", ());
        // N s_1677_1: return
        return;
    }
    fn block_1678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1678_0: const #1u : u8
        let s_1678_0: bool = true;
        // D s_1678_1: write-var gs#407975 <= s_1678_0
        fn_state.gs_407975 = s_1678_0;
        // N s_1678_2: jump b1675
        return block_1675(state, tracer, fn_state);
    }
    fn block_1679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1679_0: const #1u : u8
        let s_1679_0: bool = true;
        // D s_1679_1: write-var gs#407972 <= s_1679_0
        fn_state.gs_407972 = s_1679_0;
        // N s_1679_2: jump b1673
        return block_1673(state, tracer, fn_state);
    }
    fn block_1680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1680_0: const #1u : u8
        let s_1680_0: bool = true;
        // D s_1680_1: write-var gs#407969 <= s_1680_0
        fn_state.gs_407969 = s_1680_0;
        // N s_1680_2: jump b1671
        return block_1671(state, tracer, fn_state);
    }
    fn block_1681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1681_0: const #1u : u8
        let s_1681_0: bool = true;
        // D s_1681_1: write-var gs#407966 <= s_1681_0
        fn_state.gs_407966 = s_1681_0;
        // N s_1681_2: jump b1669
        return block_1669(state, tracer, fn_state);
    }
    fn block_1682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1682_0: const #1u : u8
        let s_1682_0: bool = true;
        // D s_1682_1: write-var gs#407963 <= s_1682_0
        fn_state.gs_407963 = s_1682_0;
        // N s_1682_2: jump b1667
        return block_1667(state, tracer, fn_state);
    }
    fn block_1683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1683_0: read-var merge#var.1:struct
        let s_1683_0: u32 = fn_state.merge_var._1;
        // D s_1683_1: write-var u#33201 <= s_1683_0
        fn_state.u_33201 = s_1683_0;
        // C s_1683_2: const #20s : i
        let s_1683_2: i128 = 20;
        // D s_1683_3: read-var u#33201:u32
        let s_1683_3: u32 = fn_state.u_33201;
        // D s_1683_4: cast zx s_1683_3 -> bv
        let s_1683_4: Bits = Bits::new(s_1683_3 as u128, 32u16);
        // C s_1683_5: const #1s : i64
        let s_1683_5: i64 = 1;
        // C s_1683_6: cast zx s_1683_5 -> i
        let s_1683_6: i128 = (i128::try_from(s_1683_5).unwrap());
        // C s_1683_7: const #7s : i
        let s_1683_7: i128 = 7;
        // C s_1683_8: add s_1683_7 s_1683_6
        let s_1683_8: i128 = (s_1683_7 + s_1683_6);
        // D s_1683_9: bit-extract s_1683_4 s_1683_2 s_1683_8
        let s_1683_9: Bits = (Bits::new(
            ((s_1683_4) >> (s_1683_2)).value(),
            u16::try_from(s_1683_8).unwrap(),
        ));
        // D s_1683_10: cast reint s_1683_9 -> u8
        let s_1683_10: u8 = (s_1683_9.value() as u8);
        // D s_1683_11: cast zx s_1683_10 -> bv
        let s_1683_11: Bits = Bits::new(s_1683_10 as u128, 8u16);
        // C s_1683_12: const #25u : u8
        let s_1683_12: u8 = 25;
        // C s_1683_13: cast zx s_1683_12 -> bv
        let s_1683_13: Bits = Bits::new(s_1683_12 as u128, 8u16);
        // D s_1683_14: cmp-eq s_1683_11 s_1683_13
        let s_1683_14: bool = ((s_1683_11) == (s_1683_13));
        // N s_1683_15: branch s_1683_14 b2126 b1684
        if s_1683_14 {
            return block_2126(state, tracer, fn_state);
        } else {
            return block_1684(state, tracer, fn_state);
        };
    }
    fn block_1684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1684_0: const #0u : u8
        let s_1684_0: bool = false;
        // D s_1684_1: write-var gs#407981 <= s_1684_0
        fn_state.gs_407981 = s_1684_0;
        // N s_1684_2: jump b1685
        return block_1685(state, tracer, fn_state);
    }
    fn block_1685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1685_0: read-var gs#407981:u8
        let s_1685_0: bool = fn_state.gs_407981;
        // N s_1685_1: branch s_1685_0 b2122 b1686
        if s_1685_0 {
            return block_2122(state, tracer, fn_state);
        } else {
            return block_1686(state, tracer, fn_state);
        };
    }
    fn block_1686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1686_0: const #0u : u8
        let s_1686_0: bool = false;
        // D s_1686_1: write-var gs#407986 <= s_1686_0
        fn_state.gs_407986 = s_1686_0;
        // N s_1686_2: jump b1687
        return block_1687(state, tracer, fn_state);
    }
    fn block_1687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1687_0: read-var gs#407986:u8
        let s_1687_0: bool = fn_state.gs_407986;
        // D s_1687_1: not s_1687_0
        let s_1687_1: bool = !s_1687_0;
        // N s_1687_2: branch s_1687_1 b1706 b1688
        if s_1687_1 {
            return block_1706(state, tracer, fn_state);
        } else {
            return block_1688(state, tracer, fn_state);
        };
    }
    fn block_1688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1688_0: const #3819s : i
        let s_1688_0: i128 = 3819;
        // C s_1688_1: const #14696u : u32
        let s_1688_1: u32 = 14696;
        // N s_1688_2: write-reg s_1688_1 <= s_1688_0
        let s_1688_2: () = {
            state.write_register::<i128>(s_1688_1 as isize, s_1688_0);
            tracer.write_register(s_1688_1 as isize, s_1688_0);
        };
        // C s_1688_3: const #28s : i
        let s_1688_3: i128 = 28;
        // C s_1688_4: const #4s : i
        let s_1688_4: i128 = 4;
        // D s_1688_5: read-var u#33201:u32
        let s_1688_5: u32 = fn_state.u_33201;
        // D s_1688_6: cast zx s_1688_5 -> bv
        let s_1688_6: Bits = Bits::new(s_1688_5 as u128, 32u16);
        // D s_1688_7: bit-extract s_1688_6 s_1688_3 s_1688_4
        let s_1688_7: Bits = (Bits::new(
            ((s_1688_6) >> (s_1688_3)).value(),
            u16::try_from(s_1688_4).unwrap(),
        ));
        // D s_1688_8: cast reint s_1688_7 -> u8
        let s_1688_8: u8 = (s_1688_7.value() as u8);
        // D s_1688_9: write-var u#33202 <= s_1688_8
        fn_state.u_33202 = s_1688_8;
        // C s_1688_10: const #16s : i
        let s_1688_10: i128 = 16;
        // C s_1688_11: const #4s : i
        let s_1688_11: i128 = 4;
        // D s_1688_12: read-var u#33201:u32
        let s_1688_12: u32 = fn_state.u_33201;
        // D s_1688_13: cast zx s_1688_12 -> bv
        let s_1688_13: Bits = Bits::new(s_1688_12 as u128, 32u16);
        // D s_1688_14: bit-extract s_1688_13 s_1688_10 s_1688_11
        let s_1688_14: Bits = (Bits::new(
            ((s_1688_13) >> (s_1688_10)).value(),
            u16::try_from(s_1688_11).unwrap(),
        ));
        // D s_1688_15: cast reint s_1688_14 -> u8
        let s_1688_15: u8 = (s_1688_14.value() as u8);
        // D s_1688_16: write-var u#33203 <= s_1688_15
        fn_state.u_33203 = s_1688_15;
        // C s_1688_17: const #12s : i
        let s_1688_17: i128 = 12;
        // C s_1688_18: const #4s : i
        let s_1688_18: i128 = 4;
        // D s_1688_19: read-var u#33201:u32
        let s_1688_19: u32 = fn_state.u_33201;
        // D s_1688_20: cast zx s_1688_19 -> bv
        let s_1688_20: Bits = Bits::new(s_1688_19 as u128, 32u16);
        // D s_1688_21: bit-extract s_1688_20 s_1688_17 s_1688_18
        let s_1688_21: Bits = (Bits::new(
            ((s_1688_20) >> (s_1688_17)).value(),
            u16::try_from(s_1688_18).unwrap(),
        ));
        // D s_1688_22: cast reint s_1688_21 -> u8
        let s_1688_22: u8 = (s_1688_21.value() as u8);
        // D s_1688_23: write-var u#33204 <= s_1688_22
        fn_state.u_33204 = s_1688_22;
        // C s_1688_24: const #8s : i
        let s_1688_24: i128 = 8;
        // D s_1688_25: read-var u#33201:u32
        let s_1688_25: u32 = fn_state.u_33201;
        // D s_1688_26: cast zx s_1688_25 -> bv
        let s_1688_26: Bits = Bits::new(s_1688_25 as u128, 32u16);
        // C s_1688_27: const #1u : u64
        let s_1688_27: u64 = 1;
        // D s_1688_28: bit-extract s_1688_26 s_1688_24 s_1688_27
        let s_1688_28: Bits = (Bits::new(
            ((s_1688_26) >> (s_1688_24)).value(),
            u16::try_from(s_1688_27).unwrap(),
        ));
        // D s_1688_29: cast reint s_1688_28 -> u8
        let s_1688_29: bool = ((s_1688_28.value()) != 0);
        // C s_1688_30: const #0s : i
        let s_1688_30: i128 = 0;
        // C s_1688_31: const #0u : u64
        let s_1688_31: u64 = 0;
        // D s_1688_32: cast zx s_1688_29 -> u64
        let s_1688_32: u64 = (s_1688_29 as u64);
        // C s_1688_33: const #1u : u64
        let s_1688_33: u64 = 1;
        // D s_1688_34: and s_1688_32 s_1688_33
        let s_1688_34: u64 = ((s_1688_32) & (s_1688_33));
        // D s_1688_35: cmp-eq s_1688_34 s_1688_33
        let s_1688_35: bool = ((s_1688_34) == (s_1688_33));
        // D s_1688_36: lsl s_1688_32 s_1688_30
        let s_1688_36: u64 = s_1688_32 << s_1688_30;
        // D s_1688_37: or s_1688_31 s_1688_36
        let s_1688_37: u64 = ((s_1688_31) | (s_1688_36));
        // D s_1688_38: cmpl s_1688_36
        let s_1688_38: u64 = !s_1688_36;
        // D s_1688_39: and s_1688_31 s_1688_38
        let s_1688_39: u64 = ((s_1688_31) & (s_1688_38));
        // D s_1688_40: select s_1688_35 s_1688_37 s_1688_39
        let s_1688_40: u64 = if s_1688_35 { s_1688_37 } else { s_1688_39 };
        // D s_1688_41: cast trunc s_1688_40 -> u8
        let s_1688_41: bool = ((s_1688_40) != 0);
        // D s_1688_42: cast zx s_1688_41 -> bv
        let s_1688_42: Bits = Bits::new(s_1688_41 as u128, 1u16);
        // C s_1688_43: const #1u : u8
        let s_1688_43: bool = true;
        // C s_1688_44: cast zx s_1688_43 -> bv
        let s_1688_44: Bits = Bits::new(s_1688_43 as u128, 1u16);
        // D s_1688_45: cmp-ne s_1688_42 s_1688_44
        let s_1688_45: bool = ((s_1688_42) != (s_1688_44));
        // N s_1688_46: branch s_1688_45 b1705 b1689
        if s_1688_45 {
            return block_1705(state, tracer, fn_state);
        } else {
            return block_1689(state, tracer, fn_state);
        };
    }
    fn block_1689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1689_0: const #9s : i
        let s_1689_0: i128 = 9;
        // D s_1689_1: read-var u#33201:u32
        let s_1689_1: u32 = fn_state.u_33201;
        // D s_1689_2: cast zx s_1689_1 -> bv
        let s_1689_2: Bits = Bits::new(s_1689_1 as u128, 32u16);
        // C s_1689_3: const #1u : u64
        let s_1689_3: u64 = 1;
        // D s_1689_4: bit-extract s_1689_2 s_1689_0 s_1689_3
        let s_1689_4: Bits = (Bits::new(
            ((s_1689_2) >> (s_1689_0)).value(),
            u16::try_from(s_1689_3).unwrap(),
        ));
        // D s_1689_5: cast reint s_1689_4 -> u8
        let s_1689_5: bool = ((s_1689_4.value()) != 0);
        // C s_1689_6: const #0s : i
        let s_1689_6: i128 = 0;
        // C s_1689_7: const #0u : u64
        let s_1689_7: u64 = 0;
        // D s_1689_8: cast zx s_1689_5 -> u64
        let s_1689_8: u64 = (s_1689_5 as u64);
        // C s_1689_9: const #1u : u64
        let s_1689_9: u64 = 1;
        // D s_1689_10: and s_1689_8 s_1689_9
        let s_1689_10: u64 = ((s_1689_8) & (s_1689_9));
        // D s_1689_11: cmp-eq s_1689_10 s_1689_9
        let s_1689_11: bool = ((s_1689_10) == (s_1689_9));
        // D s_1689_12: lsl s_1689_8 s_1689_6
        let s_1689_12: u64 = s_1689_8 << s_1689_6;
        // D s_1689_13: or s_1689_7 s_1689_12
        let s_1689_13: u64 = ((s_1689_7) | (s_1689_12));
        // D s_1689_14: cmpl s_1689_12
        let s_1689_14: u64 = !s_1689_12;
        // D s_1689_15: and s_1689_7 s_1689_14
        let s_1689_15: u64 = ((s_1689_7) & (s_1689_14));
        // D s_1689_16: select s_1689_11 s_1689_13 s_1689_15
        let s_1689_16: u64 = if s_1689_11 { s_1689_13 } else { s_1689_15 };
        // D s_1689_17: cast trunc s_1689_16 -> u8
        let s_1689_17: bool = ((s_1689_16) != 0);
        // D s_1689_18: cast zx s_1689_17 -> bv
        let s_1689_18: Bits = Bits::new(s_1689_17 as u128, 1u16);
        // C s_1689_19: const #1u : u8
        let s_1689_19: bool = true;
        // C s_1689_20: cast zx s_1689_19 -> bv
        let s_1689_20: Bits = Bits::new(s_1689_19 as u128, 1u16);
        // D s_1689_21: cmp-ne s_1689_18 s_1689_20
        let s_1689_21: bool = ((s_1689_18) != (s_1689_20));
        // D s_1689_22: write-var gs#407999 <= s_1689_21
        fn_state.gs_407999 = s_1689_21;
        // N s_1689_23: jump b1690
        return block_1690(state, tracer, fn_state);
    }
    fn block_1690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1690_0: read-var gs#407999:u8
        let s_1690_0: bool = fn_state.gs_407999;
        // N s_1690_1: branch s_1690_0 b1704 b1691
        if s_1690_0 {
            return block_1704(state, tracer, fn_state);
        } else {
            return block_1691(state, tracer, fn_state);
        };
    }
    fn block_1691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1691_0: const #0s : i
        let s_1691_0: i128 = 0;
        // D s_1691_1: read-var u#33201:u32
        let s_1691_1: u32 = fn_state.u_33201;
        // D s_1691_2: cast zx s_1691_1 -> bv
        let s_1691_2: Bits = Bits::new(s_1691_1 as u128, 32u16);
        // C s_1691_3: const #1u : u64
        let s_1691_3: u64 = 1;
        // D s_1691_4: bit-extract s_1691_2 s_1691_0 s_1691_3
        let s_1691_4: Bits = (Bits::new(
            ((s_1691_2) >> (s_1691_0)).value(),
            u16::try_from(s_1691_3).unwrap(),
        ));
        // D s_1691_5: cast reint s_1691_4 -> u8
        let s_1691_5: bool = ((s_1691_4.value()) != 0);
        // C s_1691_6: const #0s : i
        let s_1691_6: i128 = 0;
        // C s_1691_7: const #0u : u64
        let s_1691_7: u64 = 0;
        // D s_1691_8: cast zx s_1691_5 -> u64
        let s_1691_8: u64 = (s_1691_5 as u64);
        // C s_1691_9: const #1u : u64
        let s_1691_9: u64 = 1;
        // D s_1691_10: and s_1691_8 s_1691_9
        let s_1691_10: u64 = ((s_1691_8) & (s_1691_9));
        // D s_1691_11: cmp-eq s_1691_10 s_1691_9
        let s_1691_11: bool = ((s_1691_10) == (s_1691_9));
        // D s_1691_12: lsl s_1691_8 s_1691_6
        let s_1691_12: u64 = s_1691_8 << s_1691_6;
        // D s_1691_13: or s_1691_7 s_1691_12
        let s_1691_13: u64 = ((s_1691_7) | (s_1691_12));
        // D s_1691_14: cmpl s_1691_12
        let s_1691_14: u64 = !s_1691_12;
        // D s_1691_15: and s_1691_7 s_1691_14
        let s_1691_15: u64 = ((s_1691_7) & (s_1691_14));
        // D s_1691_16: select s_1691_11 s_1691_13 s_1691_15
        let s_1691_16: u64 = if s_1691_11 { s_1691_13 } else { s_1691_15 };
        // D s_1691_17: cast trunc s_1691_16 -> u8
        let s_1691_17: bool = ((s_1691_16) != 0);
        // D s_1691_18: cast zx s_1691_17 -> bv
        let s_1691_18: Bits = Bits::new(s_1691_17 as u128, 1u16);
        // C s_1691_19: const #1u : u8
        let s_1691_19: bool = true;
        // C s_1691_20: cast zx s_1691_19 -> bv
        let s_1691_20: Bits = Bits::new(s_1691_19 as u128, 1u16);
        // D s_1691_21: cmp-ne s_1691_18 s_1691_20
        let s_1691_21: bool = ((s_1691_18) != (s_1691_20));
        // D s_1691_22: write-var gs#408002 <= s_1691_21
        fn_state.gs_408002 = s_1691_21;
        // N s_1691_23: jump b1692
        return block_1692(state, tracer, fn_state);
    }
    fn block_1692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1692_0: read-var gs#408002:u8
        let s_1692_0: bool = fn_state.gs_408002;
        // N s_1692_1: branch s_1692_0 b1703 b1693
        if s_1692_0 {
            return block_1703(state, tracer, fn_state);
        } else {
            return block_1693(state, tracer, fn_state);
        };
    }
    fn block_1693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1693_0: const #1s : i
        let s_1693_0: i128 = 1;
        // D s_1693_1: read-var u#33201:u32
        let s_1693_1: u32 = fn_state.u_33201;
        // D s_1693_2: cast zx s_1693_1 -> bv
        let s_1693_2: Bits = Bits::new(s_1693_1 as u128, 32u16);
        // C s_1693_3: const #1u : u64
        let s_1693_3: u64 = 1;
        // D s_1693_4: bit-extract s_1693_2 s_1693_0 s_1693_3
        let s_1693_4: Bits = (Bits::new(
            ((s_1693_2) >> (s_1693_0)).value(),
            u16::try_from(s_1693_3).unwrap(),
        ));
        // D s_1693_5: cast reint s_1693_4 -> u8
        let s_1693_5: bool = ((s_1693_4.value()) != 0);
        // C s_1693_6: const #0s : i
        let s_1693_6: i128 = 0;
        // C s_1693_7: const #0u : u64
        let s_1693_7: u64 = 0;
        // D s_1693_8: cast zx s_1693_5 -> u64
        let s_1693_8: u64 = (s_1693_5 as u64);
        // C s_1693_9: const #1u : u64
        let s_1693_9: u64 = 1;
        // D s_1693_10: and s_1693_8 s_1693_9
        let s_1693_10: u64 = ((s_1693_8) & (s_1693_9));
        // D s_1693_11: cmp-eq s_1693_10 s_1693_9
        let s_1693_11: bool = ((s_1693_10) == (s_1693_9));
        // D s_1693_12: lsl s_1693_8 s_1693_6
        let s_1693_12: u64 = s_1693_8 << s_1693_6;
        // D s_1693_13: or s_1693_7 s_1693_12
        let s_1693_13: u64 = ((s_1693_7) | (s_1693_12));
        // D s_1693_14: cmpl s_1693_12
        let s_1693_14: u64 = !s_1693_12;
        // D s_1693_15: and s_1693_7 s_1693_14
        let s_1693_15: u64 = ((s_1693_7) & (s_1693_14));
        // D s_1693_16: select s_1693_11 s_1693_13 s_1693_15
        let s_1693_16: u64 = if s_1693_11 { s_1693_13 } else { s_1693_15 };
        // D s_1693_17: cast trunc s_1693_16 -> u8
        let s_1693_17: bool = ((s_1693_16) != 0);
        // D s_1693_18: cast zx s_1693_17 -> bv
        let s_1693_18: Bits = Bits::new(s_1693_17 as u128, 1u16);
        // C s_1693_19: const #1u : u8
        let s_1693_19: bool = true;
        // C s_1693_20: cast zx s_1693_19 -> bv
        let s_1693_20: Bits = Bits::new(s_1693_19 as u128, 1u16);
        // D s_1693_21: cmp-ne s_1693_18 s_1693_20
        let s_1693_21: bool = ((s_1693_18) != (s_1693_20));
        // D s_1693_22: write-var gs#408005 <= s_1693_21
        fn_state.gs_408005 = s_1693_21;
        // N s_1693_23: jump b1694
        return block_1694(state, tracer, fn_state);
    }
    fn block_1694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1694_0: read-var gs#408005:u8
        let s_1694_0: bool = fn_state.gs_408005;
        // N s_1694_1: branch s_1694_0 b1702 b1695
        if s_1694_0 {
            return block_1702(state, tracer, fn_state);
        } else {
            return block_1695(state, tracer, fn_state);
        };
    }
    fn block_1695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1695_0: const #2s : i
        let s_1695_0: i128 = 2;
        // D s_1695_1: read-var u#33201:u32
        let s_1695_1: u32 = fn_state.u_33201;
        // D s_1695_2: cast zx s_1695_1 -> bv
        let s_1695_2: Bits = Bits::new(s_1695_1 as u128, 32u16);
        // C s_1695_3: const #1u : u64
        let s_1695_3: u64 = 1;
        // D s_1695_4: bit-extract s_1695_2 s_1695_0 s_1695_3
        let s_1695_4: Bits = (Bits::new(
            ((s_1695_2) >> (s_1695_0)).value(),
            u16::try_from(s_1695_3).unwrap(),
        ));
        // D s_1695_5: cast reint s_1695_4 -> u8
        let s_1695_5: bool = ((s_1695_4.value()) != 0);
        // C s_1695_6: const #0s : i
        let s_1695_6: i128 = 0;
        // C s_1695_7: const #0u : u64
        let s_1695_7: u64 = 0;
        // D s_1695_8: cast zx s_1695_5 -> u64
        let s_1695_8: u64 = (s_1695_5 as u64);
        // C s_1695_9: const #1u : u64
        let s_1695_9: u64 = 1;
        // D s_1695_10: and s_1695_8 s_1695_9
        let s_1695_10: u64 = ((s_1695_8) & (s_1695_9));
        // D s_1695_11: cmp-eq s_1695_10 s_1695_9
        let s_1695_11: bool = ((s_1695_10) == (s_1695_9));
        // D s_1695_12: lsl s_1695_8 s_1695_6
        let s_1695_12: u64 = s_1695_8 << s_1695_6;
        // D s_1695_13: or s_1695_7 s_1695_12
        let s_1695_13: u64 = ((s_1695_7) | (s_1695_12));
        // D s_1695_14: cmpl s_1695_12
        let s_1695_14: u64 = !s_1695_12;
        // D s_1695_15: and s_1695_7 s_1695_14
        let s_1695_15: u64 = ((s_1695_7) & (s_1695_14));
        // D s_1695_16: select s_1695_11 s_1695_13 s_1695_15
        let s_1695_16: u64 = if s_1695_11 { s_1695_13 } else { s_1695_15 };
        // D s_1695_17: cast trunc s_1695_16 -> u8
        let s_1695_17: bool = ((s_1695_16) != 0);
        // D s_1695_18: cast zx s_1695_17 -> bv
        let s_1695_18: Bits = Bits::new(s_1695_17 as u128, 1u16);
        // C s_1695_19: const #1u : u8
        let s_1695_19: bool = true;
        // C s_1695_20: cast zx s_1695_19 -> bv
        let s_1695_20: Bits = Bits::new(s_1695_19 as u128, 1u16);
        // D s_1695_21: cmp-ne s_1695_18 s_1695_20
        let s_1695_21: bool = ((s_1695_18) != (s_1695_20));
        // D s_1695_22: write-var gs#408008 <= s_1695_21
        fn_state.gs_408008 = s_1695_21;
        // N s_1695_23: jump b1696
        return block_1696(state, tracer, fn_state);
    }
    fn block_1696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1696_0: read-var gs#408008:u8
        let s_1696_0: bool = fn_state.gs_408008;
        // N s_1696_1: branch s_1696_0 b1701 b1697
        if s_1696_0 {
            return block_1701(state, tracer, fn_state);
        } else {
            return block_1697(state, tracer, fn_state);
        };
    }
    fn block_1697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1697_0: const #3s : i
        let s_1697_0: i128 = 3;
        // D s_1697_1: read-var u#33201:u32
        let s_1697_1: u32 = fn_state.u_33201;
        // D s_1697_2: cast zx s_1697_1 -> bv
        let s_1697_2: Bits = Bits::new(s_1697_1 as u128, 32u16);
        // C s_1697_3: const #1u : u64
        let s_1697_3: u64 = 1;
        // D s_1697_4: bit-extract s_1697_2 s_1697_0 s_1697_3
        let s_1697_4: Bits = (Bits::new(
            ((s_1697_2) >> (s_1697_0)).value(),
            u16::try_from(s_1697_3).unwrap(),
        ));
        // D s_1697_5: cast reint s_1697_4 -> u8
        let s_1697_5: bool = ((s_1697_4.value()) != 0);
        // C s_1697_6: const #0s : i
        let s_1697_6: i128 = 0;
        // C s_1697_7: const #0u : u64
        let s_1697_7: u64 = 0;
        // D s_1697_8: cast zx s_1697_5 -> u64
        let s_1697_8: u64 = (s_1697_5 as u64);
        // C s_1697_9: const #1u : u64
        let s_1697_9: u64 = 1;
        // D s_1697_10: and s_1697_8 s_1697_9
        let s_1697_10: u64 = ((s_1697_8) & (s_1697_9));
        // D s_1697_11: cmp-eq s_1697_10 s_1697_9
        let s_1697_11: bool = ((s_1697_10) == (s_1697_9));
        // D s_1697_12: lsl s_1697_8 s_1697_6
        let s_1697_12: u64 = s_1697_8 << s_1697_6;
        // D s_1697_13: or s_1697_7 s_1697_12
        let s_1697_13: u64 = ((s_1697_7) | (s_1697_12));
        // D s_1697_14: cmpl s_1697_12
        let s_1697_14: u64 = !s_1697_12;
        // D s_1697_15: and s_1697_7 s_1697_14
        let s_1697_15: u64 = ((s_1697_7) & (s_1697_14));
        // D s_1697_16: select s_1697_11 s_1697_13 s_1697_15
        let s_1697_16: u64 = if s_1697_11 { s_1697_13 } else { s_1697_15 };
        // D s_1697_17: cast trunc s_1697_16 -> u8
        let s_1697_17: bool = ((s_1697_16) != 0);
        // D s_1697_18: cast zx s_1697_17 -> bv
        let s_1697_18: Bits = Bits::new(s_1697_17 as u128, 1u16);
        // C s_1697_19: const #1u : u8
        let s_1697_19: bool = true;
        // C s_1697_20: cast zx s_1697_19 -> bv
        let s_1697_20: Bits = Bits::new(s_1697_19 as u128, 1u16);
        // D s_1697_21: cmp-ne s_1697_18 s_1697_20
        let s_1697_21: bool = ((s_1697_18) != (s_1697_20));
        // D s_1697_22: write-var gs#408011 <= s_1697_21
        fn_state.gs_408011 = s_1697_21;
        // N s_1697_23: jump b1698
        return block_1698(state, tracer, fn_state);
    }
    fn block_1698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1698_0: read-var gs#408011:u8
        let s_1698_0: bool = fn_state.gs_408011;
        // N s_1698_1: branch s_1698_0 b1700 b1699
        if s_1698_0 {
            return block_1700(state, tracer, fn_state);
        } else {
            return block_1699(state, tracer, fn_state);
        };
    }
    fn block_1699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1699_0: read-var u#33202:u8
        let s_1699_0: u8 = fn_state.u_33202;
        // D s_1699_1: read-var u#33203:u8
        let s_1699_1: u8 = fn_state.u_33203;
        // D s_1699_2: read-var u#33204:u8
        let s_1699_2: u8 = fn_state.u_33204;
        // D s_1699_3: call decode_aarch32_instrs_LDAEX_A1enc_A_txt(s_1699_0, s_1699_1, s_1699_2)
        let s_1699_3: () = decode_aarch32_instrs_LDAEX_A1enc_A_txt(
            state,
            tracer,
            s_1699_0,
            s_1699_1,
            s_1699_2,
        );
        // N s_1699_4: return
        return;
    }
    fn block_1700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1700_0: panic
        panic!("{:?}", ());
        // N s_1700_1: return
        return;
    }
    fn block_1701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1701_0: const #1u : u8
        let s_1701_0: bool = true;
        // D s_1701_1: write-var gs#408011 <= s_1701_0
        fn_state.gs_408011 = s_1701_0;
        // N s_1701_2: jump b1698
        return block_1698(state, tracer, fn_state);
    }
    fn block_1702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1702_0: const #1u : u8
        let s_1702_0: bool = true;
        // D s_1702_1: write-var gs#408008 <= s_1702_0
        fn_state.gs_408008 = s_1702_0;
        // N s_1702_2: jump b1696
        return block_1696(state, tracer, fn_state);
    }
    fn block_1703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1703_0: const #1u : u8
        let s_1703_0: bool = true;
        // D s_1703_1: write-var gs#408005 <= s_1703_0
        fn_state.gs_408005 = s_1703_0;
        // N s_1703_2: jump b1694
        return block_1694(state, tracer, fn_state);
    }
    fn block_1704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1704_0: const #1u : u8
        let s_1704_0: bool = true;
        // D s_1704_1: write-var gs#408002 <= s_1704_0
        fn_state.gs_408002 = s_1704_0;
        // N s_1704_2: jump b1692
        return block_1692(state, tracer, fn_state);
    }
    fn block_1705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1705_0: const #1u : u8
        let s_1705_0: bool = true;
        // D s_1705_1: write-var gs#407999 <= s_1705_0
        fn_state.gs_407999 = s_1705_0;
        // N s_1705_2: jump b1690
        return block_1690(state, tracer, fn_state);
    }
    fn block_1706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1706_0: read-var merge#var.1:struct
        let s_1706_0: u32 = fn_state.merge_var._1;
        // D s_1706_1: write-var u#33206 <= s_1706_0
        fn_state.u_33206 = s_1706_0;
        // C s_1706_2: const #20s : i
        let s_1706_2: i128 = 20;
        // D s_1706_3: read-var u#33206:u32
        let s_1706_3: u32 = fn_state.u_33206;
        // D s_1706_4: cast zx s_1706_3 -> bv
        let s_1706_4: Bits = Bits::new(s_1706_3 as u128, 32u16);
        // C s_1706_5: const #1s : i64
        let s_1706_5: i64 = 1;
        // C s_1706_6: cast zx s_1706_5 -> i
        let s_1706_6: i128 = (i128::try_from(s_1706_5).unwrap());
        // C s_1706_7: const #7s : i
        let s_1706_7: i128 = 7;
        // C s_1706_8: add s_1706_7 s_1706_6
        let s_1706_8: i128 = (s_1706_7 + s_1706_6);
        // D s_1706_9: bit-extract s_1706_4 s_1706_2 s_1706_8
        let s_1706_9: Bits = (Bits::new(
            ((s_1706_4) >> (s_1706_2)).value(),
            u16::try_from(s_1706_8).unwrap(),
        ));
        // D s_1706_10: cast reint s_1706_9 -> u8
        let s_1706_10: u8 = (s_1706_9.value() as u8);
        // D s_1706_11: cast zx s_1706_10 -> bv
        let s_1706_11: Bits = Bits::new(s_1706_10 as u128, 8u16);
        // C s_1706_12: const #29u : u8
        let s_1706_12: u8 = 29;
        // C s_1706_13: cast zx s_1706_12 -> bv
        let s_1706_13: Bits = Bits::new(s_1706_12 as u128, 8u16);
        // D s_1706_14: cmp-eq s_1706_11 s_1706_13
        let s_1706_14: bool = ((s_1706_11) == (s_1706_13));
        // N s_1706_15: branch s_1706_14 b2121 b1707
        if s_1706_14 {
            return block_2121(state, tracer, fn_state);
        } else {
            return block_1707(state, tracer, fn_state);
        };
    }
    fn block_1707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1707_0: const #0u : u8
        let s_1707_0: bool = false;
        // D s_1707_1: write-var gs#408017 <= s_1707_0
        fn_state.gs_408017 = s_1707_0;
        // N s_1707_2: jump b1708
        return block_1708(state, tracer, fn_state);
    }
    fn block_1708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1708_0: read-var gs#408017:u8
        let s_1708_0: bool = fn_state.gs_408017;
        // N s_1708_1: branch s_1708_0 b2117 b1709
        if s_1708_0 {
            return block_2117(state, tracer, fn_state);
        } else {
            return block_1709(state, tracer, fn_state);
        };
    }
    fn block_1709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1709_0: const #0u : u8
        let s_1709_0: bool = false;
        // D s_1709_1: write-var gs#408022 <= s_1709_0
        fn_state.gs_408022 = s_1709_0;
        // N s_1709_2: jump b1710
        return block_1710(state, tracer, fn_state);
    }
    fn block_1710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1710_0: read-var gs#408022:u8
        let s_1710_0: bool = fn_state.gs_408022;
        // D s_1710_1: not s_1710_0
        let s_1710_1: bool = !s_1710_0;
        // N s_1710_2: branch s_1710_1 b1729 b1711
        if s_1710_1 {
            return block_1729(state, tracer, fn_state);
        } else {
            return block_1711(state, tracer, fn_state);
        };
    }
    fn block_1711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1711_0: const #3821s : i
        let s_1711_0: i128 = 3821;
        // C s_1711_1: const #14696u : u32
        let s_1711_1: u32 = 14696;
        // N s_1711_2: write-reg s_1711_1 <= s_1711_0
        let s_1711_2: () = {
            state.write_register::<i128>(s_1711_1 as isize, s_1711_0);
            tracer.write_register(s_1711_1 as isize, s_1711_0);
        };
        // C s_1711_3: const #28s : i
        let s_1711_3: i128 = 28;
        // C s_1711_4: const #4s : i
        let s_1711_4: i128 = 4;
        // D s_1711_5: read-var u#33206:u32
        let s_1711_5: u32 = fn_state.u_33206;
        // D s_1711_6: cast zx s_1711_5 -> bv
        let s_1711_6: Bits = Bits::new(s_1711_5 as u128, 32u16);
        // D s_1711_7: bit-extract s_1711_6 s_1711_3 s_1711_4
        let s_1711_7: Bits = (Bits::new(
            ((s_1711_6) >> (s_1711_3)).value(),
            u16::try_from(s_1711_4).unwrap(),
        ));
        // D s_1711_8: cast reint s_1711_7 -> u8
        let s_1711_8: u8 = (s_1711_7.value() as u8);
        // D s_1711_9: write-var u#33207 <= s_1711_8
        fn_state.u_33207 = s_1711_8;
        // C s_1711_10: const #16s : i
        let s_1711_10: i128 = 16;
        // C s_1711_11: const #4s : i
        let s_1711_11: i128 = 4;
        // D s_1711_12: read-var u#33206:u32
        let s_1711_12: u32 = fn_state.u_33206;
        // D s_1711_13: cast zx s_1711_12 -> bv
        let s_1711_13: Bits = Bits::new(s_1711_12 as u128, 32u16);
        // D s_1711_14: bit-extract s_1711_13 s_1711_10 s_1711_11
        let s_1711_14: Bits = (Bits::new(
            ((s_1711_13) >> (s_1711_10)).value(),
            u16::try_from(s_1711_11).unwrap(),
        ));
        // D s_1711_15: cast reint s_1711_14 -> u8
        let s_1711_15: u8 = (s_1711_14.value() as u8);
        // D s_1711_16: write-var u#33208 <= s_1711_15
        fn_state.u_33208 = s_1711_15;
        // C s_1711_17: const #12s : i
        let s_1711_17: i128 = 12;
        // C s_1711_18: const #4s : i
        let s_1711_18: i128 = 4;
        // D s_1711_19: read-var u#33206:u32
        let s_1711_19: u32 = fn_state.u_33206;
        // D s_1711_20: cast zx s_1711_19 -> bv
        let s_1711_20: Bits = Bits::new(s_1711_19 as u128, 32u16);
        // D s_1711_21: bit-extract s_1711_20 s_1711_17 s_1711_18
        let s_1711_21: Bits = (Bits::new(
            ((s_1711_20) >> (s_1711_17)).value(),
            u16::try_from(s_1711_18).unwrap(),
        ));
        // D s_1711_22: cast reint s_1711_21 -> u8
        let s_1711_22: u8 = (s_1711_21.value() as u8);
        // D s_1711_23: write-var u#33209 <= s_1711_22
        fn_state.u_33209 = s_1711_22;
        // C s_1711_24: const #8s : i
        let s_1711_24: i128 = 8;
        // D s_1711_25: read-var u#33206:u32
        let s_1711_25: u32 = fn_state.u_33206;
        // D s_1711_26: cast zx s_1711_25 -> bv
        let s_1711_26: Bits = Bits::new(s_1711_25 as u128, 32u16);
        // C s_1711_27: const #1u : u64
        let s_1711_27: u64 = 1;
        // D s_1711_28: bit-extract s_1711_26 s_1711_24 s_1711_27
        let s_1711_28: Bits = (Bits::new(
            ((s_1711_26) >> (s_1711_24)).value(),
            u16::try_from(s_1711_27).unwrap(),
        ));
        // D s_1711_29: cast reint s_1711_28 -> u8
        let s_1711_29: bool = ((s_1711_28.value()) != 0);
        // C s_1711_30: const #0s : i
        let s_1711_30: i128 = 0;
        // C s_1711_31: const #0u : u64
        let s_1711_31: u64 = 0;
        // D s_1711_32: cast zx s_1711_29 -> u64
        let s_1711_32: u64 = (s_1711_29 as u64);
        // C s_1711_33: const #1u : u64
        let s_1711_33: u64 = 1;
        // D s_1711_34: and s_1711_32 s_1711_33
        let s_1711_34: u64 = ((s_1711_32) & (s_1711_33));
        // D s_1711_35: cmp-eq s_1711_34 s_1711_33
        let s_1711_35: bool = ((s_1711_34) == (s_1711_33));
        // D s_1711_36: lsl s_1711_32 s_1711_30
        let s_1711_36: u64 = s_1711_32 << s_1711_30;
        // D s_1711_37: or s_1711_31 s_1711_36
        let s_1711_37: u64 = ((s_1711_31) | (s_1711_36));
        // D s_1711_38: cmpl s_1711_36
        let s_1711_38: u64 = !s_1711_36;
        // D s_1711_39: and s_1711_31 s_1711_38
        let s_1711_39: u64 = ((s_1711_31) & (s_1711_38));
        // D s_1711_40: select s_1711_35 s_1711_37 s_1711_39
        let s_1711_40: u64 = if s_1711_35 { s_1711_37 } else { s_1711_39 };
        // D s_1711_41: cast trunc s_1711_40 -> u8
        let s_1711_41: bool = ((s_1711_40) != 0);
        // D s_1711_42: cast zx s_1711_41 -> bv
        let s_1711_42: Bits = Bits::new(s_1711_41 as u128, 1u16);
        // C s_1711_43: const #1u : u8
        let s_1711_43: bool = true;
        // C s_1711_44: cast zx s_1711_43 -> bv
        let s_1711_44: Bits = Bits::new(s_1711_43 as u128, 1u16);
        // D s_1711_45: cmp-ne s_1711_42 s_1711_44
        let s_1711_45: bool = ((s_1711_42) != (s_1711_44));
        // N s_1711_46: branch s_1711_45 b1728 b1712
        if s_1711_45 {
            return block_1728(state, tracer, fn_state);
        } else {
            return block_1712(state, tracer, fn_state);
        };
    }
    fn block_1712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1712_0: const #9s : i
        let s_1712_0: i128 = 9;
        // D s_1712_1: read-var u#33206:u32
        let s_1712_1: u32 = fn_state.u_33206;
        // D s_1712_2: cast zx s_1712_1 -> bv
        let s_1712_2: Bits = Bits::new(s_1712_1 as u128, 32u16);
        // C s_1712_3: const #1u : u64
        let s_1712_3: u64 = 1;
        // D s_1712_4: bit-extract s_1712_2 s_1712_0 s_1712_3
        let s_1712_4: Bits = (Bits::new(
            ((s_1712_2) >> (s_1712_0)).value(),
            u16::try_from(s_1712_3).unwrap(),
        ));
        // D s_1712_5: cast reint s_1712_4 -> u8
        let s_1712_5: bool = ((s_1712_4.value()) != 0);
        // C s_1712_6: const #0s : i
        let s_1712_6: i128 = 0;
        // C s_1712_7: const #0u : u64
        let s_1712_7: u64 = 0;
        // D s_1712_8: cast zx s_1712_5 -> u64
        let s_1712_8: u64 = (s_1712_5 as u64);
        // C s_1712_9: const #1u : u64
        let s_1712_9: u64 = 1;
        // D s_1712_10: and s_1712_8 s_1712_9
        let s_1712_10: u64 = ((s_1712_8) & (s_1712_9));
        // D s_1712_11: cmp-eq s_1712_10 s_1712_9
        let s_1712_11: bool = ((s_1712_10) == (s_1712_9));
        // D s_1712_12: lsl s_1712_8 s_1712_6
        let s_1712_12: u64 = s_1712_8 << s_1712_6;
        // D s_1712_13: or s_1712_7 s_1712_12
        let s_1712_13: u64 = ((s_1712_7) | (s_1712_12));
        // D s_1712_14: cmpl s_1712_12
        let s_1712_14: u64 = !s_1712_12;
        // D s_1712_15: and s_1712_7 s_1712_14
        let s_1712_15: u64 = ((s_1712_7) & (s_1712_14));
        // D s_1712_16: select s_1712_11 s_1712_13 s_1712_15
        let s_1712_16: u64 = if s_1712_11 { s_1712_13 } else { s_1712_15 };
        // D s_1712_17: cast trunc s_1712_16 -> u8
        let s_1712_17: bool = ((s_1712_16) != 0);
        // D s_1712_18: cast zx s_1712_17 -> bv
        let s_1712_18: Bits = Bits::new(s_1712_17 as u128, 1u16);
        // C s_1712_19: const #1u : u8
        let s_1712_19: bool = true;
        // C s_1712_20: cast zx s_1712_19 -> bv
        let s_1712_20: Bits = Bits::new(s_1712_19 as u128, 1u16);
        // D s_1712_21: cmp-ne s_1712_18 s_1712_20
        let s_1712_21: bool = ((s_1712_18) != (s_1712_20));
        // D s_1712_22: write-var gs#408035 <= s_1712_21
        fn_state.gs_408035 = s_1712_21;
        // N s_1712_23: jump b1713
        return block_1713(state, tracer, fn_state);
    }
    fn block_1713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1713_0: read-var gs#408035:u8
        let s_1713_0: bool = fn_state.gs_408035;
        // N s_1713_1: branch s_1713_0 b1727 b1714
        if s_1713_0 {
            return block_1727(state, tracer, fn_state);
        } else {
            return block_1714(state, tracer, fn_state);
        };
    }
    fn block_1714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1714_0: const #0s : i
        let s_1714_0: i128 = 0;
        // D s_1714_1: read-var u#33206:u32
        let s_1714_1: u32 = fn_state.u_33206;
        // D s_1714_2: cast zx s_1714_1 -> bv
        let s_1714_2: Bits = Bits::new(s_1714_1 as u128, 32u16);
        // C s_1714_3: const #1u : u64
        let s_1714_3: u64 = 1;
        // D s_1714_4: bit-extract s_1714_2 s_1714_0 s_1714_3
        let s_1714_4: Bits = (Bits::new(
            ((s_1714_2) >> (s_1714_0)).value(),
            u16::try_from(s_1714_3).unwrap(),
        ));
        // D s_1714_5: cast reint s_1714_4 -> u8
        let s_1714_5: bool = ((s_1714_4.value()) != 0);
        // C s_1714_6: const #0s : i
        let s_1714_6: i128 = 0;
        // C s_1714_7: const #0u : u64
        let s_1714_7: u64 = 0;
        // D s_1714_8: cast zx s_1714_5 -> u64
        let s_1714_8: u64 = (s_1714_5 as u64);
        // C s_1714_9: const #1u : u64
        let s_1714_9: u64 = 1;
        // D s_1714_10: and s_1714_8 s_1714_9
        let s_1714_10: u64 = ((s_1714_8) & (s_1714_9));
        // D s_1714_11: cmp-eq s_1714_10 s_1714_9
        let s_1714_11: bool = ((s_1714_10) == (s_1714_9));
        // D s_1714_12: lsl s_1714_8 s_1714_6
        let s_1714_12: u64 = s_1714_8 << s_1714_6;
        // D s_1714_13: or s_1714_7 s_1714_12
        let s_1714_13: u64 = ((s_1714_7) | (s_1714_12));
        // D s_1714_14: cmpl s_1714_12
        let s_1714_14: u64 = !s_1714_12;
        // D s_1714_15: and s_1714_7 s_1714_14
        let s_1714_15: u64 = ((s_1714_7) & (s_1714_14));
        // D s_1714_16: select s_1714_11 s_1714_13 s_1714_15
        let s_1714_16: u64 = if s_1714_11 { s_1714_13 } else { s_1714_15 };
        // D s_1714_17: cast trunc s_1714_16 -> u8
        let s_1714_17: bool = ((s_1714_16) != 0);
        // D s_1714_18: cast zx s_1714_17 -> bv
        let s_1714_18: Bits = Bits::new(s_1714_17 as u128, 1u16);
        // C s_1714_19: const #1u : u8
        let s_1714_19: bool = true;
        // C s_1714_20: cast zx s_1714_19 -> bv
        let s_1714_20: Bits = Bits::new(s_1714_19 as u128, 1u16);
        // D s_1714_21: cmp-ne s_1714_18 s_1714_20
        let s_1714_21: bool = ((s_1714_18) != (s_1714_20));
        // D s_1714_22: write-var gs#408038 <= s_1714_21
        fn_state.gs_408038 = s_1714_21;
        // N s_1714_23: jump b1715
        return block_1715(state, tracer, fn_state);
    }
    fn block_1715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1715_0: read-var gs#408038:u8
        let s_1715_0: bool = fn_state.gs_408038;
        // N s_1715_1: branch s_1715_0 b1726 b1716
        if s_1715_0 {
            return block_1726(state, tracer, fn_state);
        } else {
            return block_1716(state, tracer, fn_state);
        };
    }
    fn block_1716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1716_0: const #1s : i
        let s_1716_0: i128 = 1;
        // D s_1716_1: read-var u#33206:u32
        let s_1716_1: u32 = fn_state.u_33206;
        // D s_1716_2: cast zx s_1716_1 -> bv
        let s_1716_2: Bits = Bits::new(s_1716_1 as u128, 32u16);
        // C s_1716_3: const #1u : u64
        let s_1716_3: u64 = 1;
        // D s_1716_4: bit-extract s_1716_2 s_1716_0 s_1716_3
        let s_1716_4: Bits = (Bits::new(
            ((s_1716_2) >> (s_1716_0)).value(),
            u16::try_from(s_1716_3).unwrap(),
        ));
        // D s_1716_5: cast reint s_1716_4 -> u8
        let s_1716_5: bool = ((s_1716_4.value()) != 0);
        // C s_1716_6: const #0s : i
        let s_1716_6: i128 = 0;
        // C s_1716_7: const #0u : u64
        let s_1716_7: u64 = 0;
        // D s_1716_8: cast zx s_1716_5 -> u64
        let s_1716_8: u64 = (s_1716_5 as u64);
        // C s_1716_9: const #1u : u64
        let s_1716_9: u64 = 1;
        // D s_1716_10: and s_1716_8 s_1716_9
        let s_1716_10: u64 = ((s_1716_8) & (s_1716_9));
        // D s_1716_11: cmp-eq s_1716_10 s_1716_9
        let s_1716_11: bool = ((s_1716_10) == (s_1716_9));
        // D s_1716_12: lsl s_1716_8 s_1716_6
        let s_1716_12: u64 = s_1716_8 << s_1716_6;
        // D s_1716_13: or s_1716_7 s_1716_12
        let s_1716_13: u64 = ((s_1716_7) | (s_1716_12));
        // D s_1716_14: cmpl s_1716_12
        let s_1716_14: u64 = !s_1716_12;
        // D s_1716_15: and s_1716_7 s_1716_14
        let s_1716_15: u64 = ((s_1716_7) & (s_1716_14));
        // D s_1716_16: select s_1716_11 s_1716_13 s_1716_15
        let s_1716_16: u64 = if s_1716_11 { s_1716_13 } else { s_1716_15 };
        // D s_1716_17: cast trunc s_1716_16 -> u8
        let s_1716_17: bool = ((s_1716_16) != 0);
        // D s_1716_18: cast zx s_1716_17 -> bv
        let s_1716_18: Bits = Bits::new(s_1716_17 as u128, 1u16);
        // C s_1716_19: const #1u : u8
        let s_1716_19: bool = true;
        // C s_1716_20: cast zx s_1716_19 -> bv
        let s_1716_20: Bits = Bits::new(s_1716_19 as u128, 1u16);
        // D s_1716_21: cmp-ne s_1716_18 s_1716_20
        let s_1716_21: bool = ((s_1716_18) != (s_1716_20));
        // D s_1716_22: write-var gs#408041 <= s_1716_21
        fn_state.gs_408041 = s_1716_21;
        // N s_1716_23: jump b1717
        return block_1717(state, tracer, fn_state);
    }
    fn block_1717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1717_0: read-var gs#408041:u8
        let s_1717_0: bool = fn_state.gs_408041;
        // N s_1717_1: branch s_1717_0 b1725 b1718
        if s_1717_0 {
            return block_1725(state, tracer, fn_state);
        } else {
            return block_1718(state, tracer, fn_state);
        };
    }
    fn block_1718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1718_0: const #2s : i
        let s_1718_0: i128 = 2;
        // D s_1718_1: read-var u#33206:u32
        let s_1718_1: u32 = fn_state.u_33206;
        // D s_1718_2: cast zx s_1718_1 -> bv
        let s_1718_2: Bits = Bits::new(s_1718_1 as u128, 32u16);
        // C s_1718_3: const #1u : u64
        let s_1718_3: u64 = 1;
        // D s_1718_4: bit-extract s_1718_2 s_1718_0 s_1718_3
        let s_1718_4: Bits = (Bits::new(
            ((s_1718_2) >> (s_1718_0)).value(),
            u16::try_from(s_1718_3).unwrap(),
        ));
        // D s_1718_5: cast reint s_1718_4 -> u8
        let s_1718_5: bool = ((s_1718_4.value()) != 0);
        // C s_1718_6: const #0s : i
        let s_1718_6: i128 = 0;
        // C s_1718_7: const #0u : u64
        let s_1718_7: u64 = 0;
        // D s_1718_8: cast zx s_1718_5 -> u64
        let s_1718_8: u64 = (s_1718_5 as u64);
        // C s_1718_9: const #1u : u64
        let s_1718_9: u64 = 1;
        // D s_1718_10: and s_1718_8 s_1718_9
        let s_1718_10: u64 = ((s_1718_8) & (s_1718_9));
        // D s_1718_11: cmp-eq s_1718_10 s_1718_9
        let s_1718_11: bool = ((s_1718_10) == (s_1718_9));
        // D s_1718_12: lsl s_1718_8 s_1718_6
        let s_1718_12: u64 = s_1718_8 << s_1718_6;
        // D s_1718_13: or s_1718_7 s_1718_12
        let s_1718_13: u64 = ((s_1718_7) | (s_1718_12));
        // D s_1718_14: cmpl s_1718_12
        let s_1718_14: u64 = !s_1718_12;
        // D s_1718_15: and s_1718_7 s_1718_14
        let s_1718_15: u64 = ((s_1718_7) & (s_1718_14));
        // D s_1718_16: select s_1718_11 s_1718_13 s_1718_15
        let s_1718_16: u64 = if s_1718_11 { s_1718_13 } else { s_1718_15 };
        // D s_1718_17: cast trunc s_1718_16 -> u8
        let s_1718_17: bool = ((s_1718_16) != 0);
        // D s_1718_18: cast zx s_1718_17 -> bv
        let s_1718_18: Bits = Bits::new(s_1718_17 as u128, 1u16);
        // C s_1718_19: const #1u : u8
        let s_1718_19: bool = true;
        // C s_1718_20: cast zx s_1718_19 -> bv
        let s_1718_20: Bits = Bits::new(s_1718_19 as u128, 1u16);
        // D s_1718_21: cmp-ne s_1718_18 s_1718_20
        let s_1718_21: bool = ((s_1718_18) != (s_1718_20));
        // D s_1718_22: write-var gs#408044 <= s_1718_21
        fn_state.gs_408044 = s_1718_21;
        // N s_1718_23: jump b1719
        return block_1719(state, tracer, fn_state);
    }
    fn block_1719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1719_0: read-var gs#408044:u8
        let s_1719_0: bool = fn_state.gs_408044;
        // N s_1719_1: branch s_1719_0 b1724 b1720
        if s_1719_0 {
            return block_1724(state, tracer, fn_state);
        } else {
            return block_1720(state, tracer, fn_state);
        };
    }
    fn block_1720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1720_0: const #3s : i
        let s_1720_0: i128 = 3;
        // D s_1720_1: read-var u#33206:u32
        let s_1720_1: u32 = fn_state.u_33206;
        // D s_1720_2: cast zx s_1720_1 -> bv
        let s_1720_2: Bits = Bits::new(s_1720_1 as u128, 32u16);
        // C s_1720_3: const #1u : u64
        let s_1720_3: u64 = 1;
        // D s_1720_4: bit-extract s_1720_2 s_1720_0 s_1720_3
        let s_1720_4: Bits = (Bits::new(
            ((s_1720_2) >> (s_1720_0)).value(),
            u16::try_from(s_1720_3).unwrap(),
        ));
        // D s_1720_5: cast reint s_1720_4 -> u8
        let s_1720_5: bool = ((s_1720_4.value()) != 0);
        // C s_1720_6: const #0s : i
        let s_1720_6: i128 = 0;
        // C s_1720_7: const #0u : u64
        let s_1720_7: u64 = 0;
        // D s_1720_8: cast zx s_1720_5 -> u64
        let s_1720_8: u64 = (s_1720_5 as u64);
        // C s_1720_9: const #1u : u64
        let s_1720_9: u64 = 1;
        // D s_1720_10: and s_1720_8 s_1720_9
        let s_1720_10: u64 = ((s_1720_8) & (s_1720_9));
        // D s_1720_11: cmp-eq s_1720_10 s_1720_9
        let s_1720_11: bool = ((s_1720_10) == (s_1720_9));
        // D s_1720_12: lsl s_1720_8 s_1720_6
        let s_1720_12: u64 = s_1720_8 << s_1720_6;
        // D s_1720_13: or s_1720_7 s_1720_12
        let s_1720_13: u64 = ((s_1720_7) | (s_1720_12));
        // D s_1720_14: cmpl s_1720_12
        let s_1720_14: u64 = !s_1720_12;
        // D s_1720_15: and s_1720_7 s_1720_14
        let s_1720_15: u64 = ((s_1720_7) & (s_1720_14));
        // D s_1720_16: select s_1720_11 s_1720_13 s_1720_15
        let s_1720_16: u64 = if s_1720_11 { s_1720_13 } else { s_1720_15 };
        // D s_1720_17: cast trunc s_1720_16 -> u8
        let s_1720_17: bool = ((s_1720_16) != 0);
        // D s_1720_18: cast zx s_1720_17 -> bv
        let s_1720_18: Bits = Bits::new(s_1720_17 as u128, 1u16);
        // C s_1720_19: const #1u : u8
        let s_1720_19: bool = true;
        // C s_1720_20: cast zx s_1720_19 -> bv
        let s_1720_20: Bits = Bits::new(s_1720_19 as u128, 1u16);
        // D s_1720_21: cmp-ne s_1720_18 s_1720_20
        let s_1720_21: bool = ((s_1720_18) != (s_1720_20));
        // D s_1720_22: write-var gs#408047 <= s_1720_21
        fn_state.gs_408047 = s_1720_21;
        // N s_1720_23: jump b1721
        return block_1721(state, tracer, fn_state);
    }
    fn block_1721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1721_0: read-var gs#408047:u8
        let s_1721_0: bool = fn_state.gs_408047;
        // N s_1721_1: branch s_1721_0 b1723 b1722
        if s_1721_0 {
            return block_1723(state, tracer, fn_state);
        } else {
            return block_1722(state, tracer, fn_state);
        };
    }
    fn block_1722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1722_0: read-var u#33207:u8
        let s_1722_0: u8 = fn_state.u_33207;
        // D s_1722_1: read-var u#33208:u8
        let s_1722_1: u8 = fn_state.u_33208;
        // D s_1722_2: read-var u#33209:u8
        let s_1722_2: u8 = fn_state.u_33209;
        // D s_1722_3: call decode_aarch32_instrs_LDAEXB_A1enc_A_txt(s_1722_0, s_1722_1, s_1722_2)
        let s_1722_3: () = decode_aarch32_instrs_LDAEXB_A1enc_A_txt(
            state,
            tracer,
            s_1722_0,
            s_1722_1,
            s_1722_2,
        );
        // N s_1722_4: return
        return;
    }
    fn block_1723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1723_0: panic
        panic!("{:?}", ());
        // N s_1723_1: return
        return;
    }
    fn block_1724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1724_0: const #1u : u8
        let s_1724_0: bool = true;
        // D s_1724_1: write-var gs#408047 <= s_1724_0
        fn_state.gs_408047 = s_1724_0;
        // N s_1724_2: jump b1721
        return block_1721(state, tracer, fn_state);
    }
    fn block_1725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1725_0: const #1u : u8
        let s_1725_0: bool = true;
        // D s_1725_1: write-var gs#408044 <= s_1725_0
        fn_state.gs_408044 = s_1725_0;
        // N s_1725_2: jump b1719
        return block_1719(state, tracer, fn_state);
    }
    fn block_1726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1726_0: const #1u : u8
        let s_1726_0: bool = true;
        // D s_1726_1: write-var gs#408041 <= s_1726_0
        fn_state.gs_408041 = s_1726_0;
        // N s_1726_2: jump b1717
        return block_1717(state, tracer, fn_state);
    }
    fn block_1727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1727_0: const #1u : u8
        let s_1727_0: bool = true;
        // D s_1727_1: write-var gs#408038 <= s_1727_0
        fn_state.gs_408038 = s_1727_0;
        // N s_1727_2: jump b1715
        return block_1715(state, tracer, fn_state);
    }
    fn block_1728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1728_0: const #1u : u8
        let s_1728_0: bool = true;
        // D s_1728_1: write-var gs#408035 <= s_1728_0
        fn_state.gs_408035 = s_1728_0;
        // N s_1728_2: jump b1713
        return block_1713(state, tracer, fn_state);
    }
    fn block_1729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1729_0: read-var merge#var.1:struct
        let s_1729_0: u32 = fn_state.merge_var._1;
        // D s_1729_1: write-var u#33211 <= s_1729_0
        fn_state.u_33211 = s_1729_0;
        // C s_1729_2: const #20s : i
        let s_1729_2: i128 = 20;
        // D s_1729_3: read-var u#33211:u32
        let s_1729_3: u32 = fn_state.u_33211;
        // D s_1729_4: cast zx s_1729_3 -> bv
        let s_1729_4: Bits = Bits::new(s_1729_3 as u128, 32u16);
        // C s_1729_5: const #1s : i64
        let s_1729_5: i64 = 1;
        // C s_1729_6: cast zx s_1729_5 -> i
        let s_1729_6: i128 = (i128::try_from(s_1729_5).unwrap());
        // C s_1729_7: const #7s : i
        let s_1729_7: i128 = 7;
        // C s_1729_8: add s_1729_7 s_1729_6
        let s_1729_8: i128 = (s_1729_7 + s_1729_6);
        // D s_1729_9: bit-extract s_1729_4 s_1729_2 s_1729_8
        let s_1729_9: Bits = (Bits::new(
            ((s_1729_4) >> (s_1729_2)).value(),
            u16::try_from(s_1729_8).unwrap(),
        ));
        // D s_1729_10: cast reint s_1729_9 -> u8
        let s_1729_10: u8 = (s_1729_9.value() as u8);
        // D s_1729_11: cast zx s_1729_10 -> bv
        let s_1729_11: Bits = Bits::new(s_1729_10 as u128, 8u16);
        // C s_1729_12: const #27u : u8
        let s_1729_12: u8 = 27;
        // C s_1729_13: cast zx s_1729_12 -> bv
        let s_1729_13: Bits = Bits::new(s_1729_12 as u128, 8u16);
        // D s_1729_14: cmp-eq s_1729_11 s_1729_13
        let s_1729_14: bool = ((s_1729_11) == (s_1729_13));
        // N s_1729_15: branch s_1729_14 b2116 b1730
        if s_1729_14 {
            return block_2116(state, tracer, fn_state);
        } else {
            return block_1730(state, tracer, fn_state);
        };
    }
    fn block_1730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1730_0: const #0u : u8
        let s_1730_0: bool = false;
        // D s_1730_1: write-var gs#408053 <= s_1730_0
        fn_state.gs_408053 = s_1730_0;
        // N s_1730_2: jump b1731
        return block_1731(state, tracer, fn_state);
    }
    fn block_1731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1731_0: read-var gs#408053:u8
        let s_1731_0: bool = fn_state.gs_408053;
        // N s_1731_1: branch s_1731_0 b2112 b1732
        if s_1731_0 {
            return block_2112(state, tracer, fn_state);
        } else {
            return block_1732(state, tracer, fn_state);
        };
    }
    fn block_1732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1732_0: const #0u : u8
        let s_1732_0: bool = false;
        // D s_1732_1: write-var gs#408058 <= s_1732_0
        fn_state.gs_408058 = s_1732_0;
        // N s_1732_2: jump b1733
        return block_1733(state, tracer, fn_state);
    }
    fn block_1733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1733_0: read-var gs#408058:u8
        let s_1733_0: bool = fn_state.gs_408058;
        // D s_1733_1: not s_1733_0
        let s_1733_1: bool = !s_1733_0;
        // N s_1733_2: branch s_1733_1 b1752 b1734
        if s_1733_1 {
            return block_1752(state, tracer, fn_state);
        } else {
            return block_1734(state, tracer, fn_state);
        };
    }
    fn block_1734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1734_0: const #3823s : i
        let s_1734_0: i128 = 3823;
        // C s_1734_1: const #14696u : u32
        let s_1734_1: u32 = 14696;
        // N s_1734_2: write-reg s_1734_1 <= s_1734_0
        let s_1734_2: () = {
            state.write_register::<i128>(s_1734_1 as isize, s_1734_0);
            tracer.write_register(s_1734_1 as isize, s_1734_0);
        };
        // C s_1734_3: const #28s : i
        let s_1734_3: i128 = 28;
        // C s_1734_4: const #4s : i
        let s_1734_4: i128 = 4;
        // D s_1734_5: read-var u#33211:u32
        let s_1734_5: u32 = fn_state.u_33211;
        // D s_1734_6: cast zx s_1734_5 -> bv
        let s_1734_6: Bits = Bits::new(s_1734_5 as u128, 32u16);
        // D s_1734_7: bit-extract s_1734_6 s_1734_3 s_1734_4
        let s_1734_7: Bits = (Bits::new(
            ((s_1734_6) >> (s_1734_3)).value(),
            u16::try_from(s_1734_4).unwrap(),
        ));
        // D s_1734_8: cast reint s_1734_7 -> u8
        let s_1734_8: u8 = (s_1734_7.value() as u8);
        // D s_1734_9: write-var u#33212 <= s_1734_8
        fn_state.u_33212 = s_1734_8;
        // C s_1734_10: const #16s : i
        let s_1734_10: i128 = 16;
        // C s_1734_11: const #4s : i
        let s_1734_11: i128 = 4;
        // D s_1734_12: read-var u#33211:u32
        let s_1734_12: u32 = fn_state.u_33211;
        // D s_1734_13: cast zx s_1734_12 -> bv
        let s_1734_13: Bits = Bits::new(s_1734_12 as u128, 32u16);
        // D s_1734_14: bit-extract s_1734_13 s_1734_10 s_1734_11
        let s_1734_14: Bits = (Bits::new(
            ((s_1734_13) >> (s_1734_10)).value(),
            u16::try_from(s_1734_11).unwrap(),
        ));
        // D s_1734_15: cast reint s_1734_14 -> u8
        let s_1734_15: u8 = (s_1734_14.value() as u8);
        // D s_1734_16: write-var u#33213 <= s_1734_15
        fn_state.u_33213 = s_1734_15;
        // C s_1734_17: const #12s : i
        let s_1734_17: i128 = 12;
        // C s_1734_18: const #4s : i
        let s_1734_18: i128 = 4;
        // D s_1734_19: read-var u#33211:u32
        let s_1734_19: u32 = fn_state.u_33211;
        // D s_1734_20: cast zx s_1734_19 -> bv
        let s_1734_20: Bits = Bits::new(s_1734_19 as u128, 32u16);
        // D s_1734_21: bit-extract s_1734_20 s_1734_17 s_1734_18
        let s_1734_21: Bits = (Bits::new(
            ((s_1734_20) >> (s_1734_17)).value(),
            u16::try_from(s_1734_18).unwrap(),
        ));
        // D s_1734_22: cast reint s_1734_21 -> u8
        let s_1734_22: u8 = (s_1734_21.value() as u8);
        // D s_1734_23: write-var u#33214 <= s_1734_22
        fn_state.u_33214 = s_1734_22;
        // C s_1734_24: const #8s : i
        let s_1734_24: i128 = 8;
        // D s_1734_25: read-var u#33211:u32
        let s_1734_25: u32 = fn_state.u_33211;
        // D s_1734_26: cast zx s_1734_25 -> bv
        let s_1734_26: Bits = Bits::new(s_1734_25 as u128, 32u16);
        // C s_1734_27: const #1u : u64
        let s_1734_27: u64 = 1;
        // D s_1734_28: bit-extract s_1734_26 s_1734_24 s_1734_27
        let s_1734_28: Bits = (Bits::new(
            ((s_1734_26) >> (s_1734_24)).value(),
            u16::try_from(s_1734_27).unwrap(),
        ));
        // D s_1734_29: cast reint s_1734_28 -> u8
        let s_1734_29: bool = ((s_1734_28.value()) != 0);
        // C s_1734_30: const #0s : i
        let s_1734_30: i128 = 0;
        // C s_1734_31: const #0u : u64
        let s_1734_31: u64 = 0;
        // D s_1734_32: cast zx s_1734_29 -> u64
        let s_1734_32: u64 = (s_1734_29 as u64);
        // C s_1734_33: const #1u : u64
        let s_1734_33: u64 = 1;
        // D s_1734_34: and s_1734_32 s_1734_33
        let s_1734_34: u64 = ((s_1734_32) & (s_1734_33));
        // D s_1734_35: cmp-eq s_1734_34 s_1734_33
        let s_1734_35: bool = ((s_1734_34) == (s_1734_33));
        // D s_1734_36: lsl s_1734_32 s_1734_30
        let s_1734_36: u64 = s_1734_32 << s_1734_30;
        // D s_1734_37: or s_1734_31 s_1734_36
        let s_1734_37: u64 = ((s_1734_31) | (s_1734_36));
        // D s_1734_38: cmpl s_1734_36
        let s_1734_38: u64 = !s_1734_36;
        // D s_1734_39: and s_1734_31 s_1734_38
        let s_1734_39: u64 = ((s_1734_31) & (s_1734_38));
        // D s_1734_40: select s_1734_35 s_1734_37 s_1734_39
        let s_1734_40: u64 = if s_1734_35 { s_1734_37 } else { s_1734_39 };
        // D s_1734_41: cast trunc s_1734_40 -> u8
        let s_1734_41: bool = ((s_1734_40) != 0);
        // D s_1734_42: cast zx s_1734_41 -> bv
        let s_1734_42: Bits = Bits::new(s_1734_41 as u128, 1u16);
        // C s_1734_43: const #1u : u8
        let s_1734_43: bool = true;
        // C s_1734_44: cast zx s_1734_43 -> bv
        let s_1734_44: Bits = Bits::new(s_1734_43 as u128, 1u16);
        // D s_1734_45: cmp-ne s_1734_42 s_1734_44
        let s_1734_45: bool = ((s_1734_42) != (s_1734_44));
        // N s_1734_46: branch s_1734_45 b1751 b1735
        if s_1734_45 {
            return block_1751(state, tracer, fn_state);
        } else {
            return block_1735(state, tracer, fn_state);
        };
    }
    fn block_1735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1735_0: const #9s : i
        let s_1735_0: i128 = 9;
        // D s_1735_1: read-var u#33211:u32
        let s_1735_1: u32 = fn_state.u_33211;
        // D s_1735_2: cast zx s_1735_1 -> bv
        let s_1735_2: Bits = Bits::new(s_1735_1 as u128, 32u16);
        // C s_1735_3: const #1u : u64
        let s_1735_3: u64 = 1;
        // D s_1735_4: bit-extract s_1735_2 s_1735_0 s_1735_3
        let s_1735_4: Bits = (Bits::new(
            ((s_1735_2) >> (s_1735_0)).value(),
            u16::try_from(s_1735_3).unwrap(),
        ));
        // D s_1735_5: cast reint s_1735_4 -> u8
        let s_1735_5: bool = ((s_1735_4.value()) != 0);
        // C s_1735_6: const #0s : i
        let s_1735_6: i128 = 0;
        // C s_1735_7: const #0u : u64
        let s_1735_7: u64 = 0;
        // D s_1735_8: cast zx s_1735_5 -> u64
        let s_1735_8: u64 = (s_1735_5 as u64);
        // C s_1735_9: const #1u : u64
        let s_1735_9: u64 = 1;
        // D s_1735_10: and s_1735_8 s_1735_9
        let s_1735_10: u64 = ((s_1735_8) & (s_1735_9));
        // D s_1735_11: cmp-eq s_1735_10 s_1735_9
        let s_1735_11: bool = ((s_1735_10) == (s_1735_9));
        // D s_1735_12: lsl s_1735_8 s_1735_6
        let s_1735_12: u64 = s_1735_8 << s_1735_6;
        // D s_1735_13: or s_1735_7 s_1735_12
        let s_1735_13: u64 = ((s_1735_7) | (s_1735_12));
        // D s_1735_14: cmpl s_1735_12
        let s_1735_14: u64 = !s_1735_12;
        // D s_1735_15: and s_1735_7 s_1735_14
        let s_1735_15: u64 = ((s_1735_7) & (s_1735_14));
        // D s_1735_16: select s_1735_11 s_1735_13 s_1735_15
        let s_1735_16: u64 = if s_1735_11 { s_1735_13 } else { s_1735_15 };
        // D s_1735_17: cast trunc s_1735_16 -> u8
        let s_1735_17: bool = ((s_1735_16) != 0);
        // D s_1735_18: cast zx s_1735_17 -> bv
        let s_1735_18: Bits = Bits::new(s_1735_17 as u128, 1u16);
        // C s_1735_19: const #1u : u8
        let s_1735_19: bool = true;
        // C s_1735_20: cast zx s_1735_19 -> bv
        let s_1735_20: Bits = Bits::new(s_1735_19 as u128, 1u16);
        // D s_1735_21: cmp-ne s_1735_18 s_1735_20
        let s_1735_21: bool = ((s_1735_18) != (s_1735_20));
        // D s_1735_22: write-var gs#408071 <= s_1735_21
        fn_state.gs_408071 = s_1735_21;
        // N s_1735_23: jump b1736
        return block_1736(state, tracer, fn_state);
    }
    fn block_1736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1736_0: read-var gs#408071:u8
        let s_1736_0: bool = fn_state.gs_408071;
        // N s_1736_1: branch s_1736_0 b1750 b1737
        if s_1736_0 {
            return block_1750(state, tracer, fn_state);
        } else {
            return block_1737(state, tracer, fn_state);
        };
    }
    fn block_1737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1737_0: const #0s : i
        let s_1737_0: i128 = 0;
        // D s_1737_1: read-var u#33211:u32
        let s_1737_1: u32 = fn_state.u_33211;
        // D s_1737_2: cast zx s_1737_1 -> bv
        let s_1737_2: Bits = Bits::new(s_1737_1 as u128, 32u16);
        // C s_1737_3: const #1u : u64
        let s_1737_3: u64 = 1;
        // D s_1737_4: bit-extract s_1737_2 s_1737_0 s_1737_3
        let s_1737_4: Bits = (Bits::new(
            ((s_1737_2) >> (s_1737_0)).value(),
            u16::try_from(s_1737_3).unwrap(),
        ));
        // D s_1737_5: cast reint s_1737_4 -> u8
        let s_1737_5: bool = ((s_1737_4.value()) != 0);
        // C s_1737_6: const #0s : i
        let s_1737_6: i128 = 0;
        // C s_1737_7: const #0u : u64
        let s_1737_7: u64 = 0;
        // D s_1737_8: cast zx s_1737_5 -> u64
        let s_1737_8: u64 = (s_1737_5 as u64);
        // C s_1737_9: const #1u : u64
        let s_1737_9: u64 = 1;
        // D s_1737_10: and s_1737_8 s_1737_9
        let s_1737_10: u64 = ((s_1737_8) & (s_1737_9));
        // D s_1737_11: cmp-eq s_1737_10 s_1737_9
        let s_1737_11: bool = ((s_1737_10) == (s_1737_9));
        // D s_1737_12: lsl s_1737_8 s_1737_6
        let s_1737_12: u64 = s_1737_8 << s_1737_6;
        // D s_1737_13: or s_1737_7 s_1737_12
        let s_1737_13: u64 = ((s_1737_7) | (s_1737_12));
        // D s_1737_14: cmpl s_1737_12
        let s_1737_14: u64 = !s_1737_12;
        // D s_1737_15: and s_1737_7 s_1737_14
        let s_1737_15: u64 = ((s_1737_7) & (s_1737_14));
        // D s_1737_16: select s_1737_11 s_1737_13 s_1737_15
        let s_1737_16: u64 = if s_1737_11 { s_1737_13 } else { s_1737_15 };
        // D s_1737_17: cast trunc s_1737_16 -> u8
        let s_1737_17: bool = ((s_1737_16) != 0);
        // D s_1737_18: cast zx s_1737_17 -> bv
        let s_1737_18: Bits = Bits::new(s_1737_17 as u128, 1u16);
        // C s_1737_19: const #1u : u8
        let s_1737_19: bool = true;
        // C s_1737_20: cast zx s_1737_19 -> bv
        let s_1737_20: Bits = Bits::new(s_1737_19 as u128, 1u16);
        // D s_1737_21: cmp-ne s_1737_18 s_1737_20
        let s_1737_21: bool = ((s_1737_18) != (s_1737_20));
        // D s_1737_22: write-var gs#408074 <= s_1737_21
        fn_state.gs_408074 = s_1737_21;
        // N s_1737_23: jump b1738
        return block_1738(state, tracer, fn_state);
    }
    fn block_1738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1738_0: read-var gs#408074:u8
        let s_1738_0: bool = fn_state.gs_408074;
        // N s_1738_1: branch s_1738_0 b1749 b1739
        if s_1738_0 {
            return block_1749(state, tracer, fn_state);
        } else {
            return block_1739(state, tracer, fn_state);
        };
    }
    fn block_1739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1739_0: const #1s : i
        let s_1739_0: i128 = 1;
        // D s_1739_1: read-var u#33211:u32
        let s_1739_1: u32 = fn_state.u_33211;
        // D s_1739_2: cast zx s_1739_1 -> bv
        let s_1739_2: Bits = Bits::new(s_1739_1 as u128, 32u16);
        // C s_1739_3: const #1u : u64
        let s_1739_3: u64 = 1;
        // D s_1739_4: bit-extract s_1739_2 s_1739_0 s_1739_3
        let s_1739_4: Bits = (Bits::new(
            ((s_1739_2) >> (s_1739_0)).value(),
            u16::try_from(s_1739_3).unwrap(),
        ));
        // D s_1739_5: cast reint s_1739_4 -> u8
        let s_1739_5: bool = ((s_1739_4.value()) != 0);
        // C s_1739_6: const #0s : i
        let s_1739_6: i128 = 0;
        // C s_1739_7: const #0u : u64
        let s_1739_7: u64 = 0;
        // D s_1739_8: cast zx s_1739_5 -> u64
        let s_1739_8: u64 = (s_1739_5 as u64);
        // C s_1739_9: const #1u : u64
        let s_1739_9: u64 = 1;
        // D s_1739_10: and s_1739_8 s_1739_9
        let s_1739_10: u64 = ((s_1739_8) & (s_1739_9));
        // D s_1739_11: cmp-eq s_1739_10 s_1739_9
        let s_1739_11: bool = ((s_1739_10) == (s_1739_9));
        // D s_1739_12: lsl s_1739_8 s_1739_6
        let s_1739_12: u64 = s_1739_8 << s_1739_6;
        // D s_1739_13: or s_1739_7 s_1739_12
        let s_1739_13: u64 = ((s_1739_7) | (s_1739_12));
        // D s_1739_14: cmpl s_1739_12
        let s_1739_14: u64 = !s_1739_12;
        // D s_1739_15: and s_1739_7 s_1739_14
        let s_1739_15: u64 = ((s_1739_7) & (s_1739_14));
        // D s_1739_16: select s_1739_11 s_1739_13 s_1739_15
        let s_1739_16: u64 = if s_1739_11 { s_1739_13 } else { s_1739_15 };
        // D s_1739_17: cast trunc s_1739_16 -> u8
        let s_1739_17: bool = ((s_1739_16) != 0);
        // D s_1739_18: cast zx s_1739_17 -> bv
        let s_1739_18: Bits = Bits::new(s_1739_17 as u128, 1u16);
        // C s_1739_19: const #1u : u8
        let s_1739_19: bool = true;
        // C s_1739_20: cast zx s_1739_19 -> bv
        let s_1739_20: Bits = Bits::new(s_1739_19 as u128, 1u16);
        // D s_1739_21: cmp-ne s_1739_18 s_1739_20
        let s_1739_21: bool = ((s_1739_18) != (s_1739_20));
        // D s_1739_22: write-var gs#408077 <= s_1739_21
        fn_state.gs_408077 = s_1739_21;
        // N s_1739_23: jump b1740
        return block_1740(state, tracer, fn_state);
    }
    fn block_1740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1740_0: read-var gs#408077:u8
        let s_1740_0: bool = fn_state.gs_408077;
        // N s_1740_1: branch s_1740_0 b1748 b1741
        if s_1740_0 {
            return block_1748(state, tracer, fn_state);
        } else {
            return block_1741(state, tracer, fn_state);
        };
    }
    fn block_1741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1741_0: const #2s : i
        let s_1741_0: i128 = 2;
        // D s_1741_1: read-var u#33211:u32
        let s_1741_1: u32 = fn_state.u_33211;
        // D s_1741_2: cast zx s_1741_1 -> bv
        let s_1741_2: Bits = Bits::new(s_1741_1 as u128, 32u16);
        // C s_1741_3: const #1u : u64
        let s_1741_3: u64 = 1;
        // D s_1741_4: bit-extract s_1741_2 s_1741_0 s_1741_3
        let s_1741_4: Bits = (Bits::new(
            ((s_1741_2) >> (s_1741_0)).value(),
            u16::try_from(s_1741_3).unwrap(),
        ));
        // D s_1741_5: cast reint s_1741_4 -> u8
        let s_1741_5: bool = ((s_1741_4.value()) != 0);
        // C s_1741_6: const #0s : i
        let s_1741_6: i128 = 0;
        // C s_1741_7: const #0u : u64
        let s_1741_7: u64 = 0;
        // D s_1741_8: cast zx s_1741_5 -> u64
        let s_1741_8: u64 = (s_1741_5 as u64);
        // C s_1741_9: const #1u : u64
        let s_1741_9: u64 = 1;
        // D s_1741_10: and s_1741_8 s_1741_9
        let s_1741_10: u64 = ((s_1741_8) & (s_1741_9));
        // D s_1741_11: cmp-eq s_1741_10 s_1741_9
        let s_1741_11: bool = ((s_1741_10) == (s_1741_9));
        // D s_1741_12: lsl s_1741_8 s_1741_6
        let s_1741_12: u64 = s_1741_8 << s_1741_6;
        // D s_1741_13: or s_1741_7 s_1741_12
        let s_1741_13: u64 = ((s_1741_7) | (s_1741_12));
        // D s_1741_14: cmpl s_1741_12
        let s_1741_14: u64 = !s_1741_12;
        // D s_1741_15: and s_1741_7 s_1741_14
        let s_1741_15: u64 = ((s_1741_7) & (s_1741_14));
        // D s_1741_16: select s_1741_11 s_1741_13 s_1741_15
        let s_1741_16: u64 = if s_1741_11 { s_1741_13 } else { s_1741_15 };
        // D s_1741_17: cast trunc s_1741_16 -> u8
        let s_1741_17: bool = ((s_1741_16) != 0);
        // D s_1741_18: cast zx s_1741_17 -> bv
        let s_1741_18: Bits = Bits::new(s_1741_17 as u128, 1u16);
        // C s_1741_19: const #1u : u8
        let s_1741_19: bool = true;
        // C s_1741_20: cast zx s_1741_19 -> bv
        let s_1741_20: Bits = Bits::new(s_1741_19 as u128, 1u16);
        // D s_1741_21: cmp-ne s_1741_18 s_1741_20
        let s_1741_21: bool = ((s_1741_18) != (s_1741_20));
        // D s_1741_22: write-var gs#408080 <= s_1741_21
        fn_state.gs_408080 = s_1741_21;
        // N s_1741_23: jump b1742
        return block_1742(state, tracer, fn_state);
    }
    fn block_1742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1742_0: read-var gs#408080:u8
        let s_1742_0: bool = fn_state.gs_408080;
        // N s_1742_1: branch s_1742_0 b1747 b1743
        if s_1742_0 {
            return block_1747(state, tracer, fn_state);
        } else {
            return block_1743(state, tracer, fn_state);
        };
    }
    fn block_1743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1743_0: const #3s : i
        let s_1743_0: i128 = 3;
        // D s_1743_1: read-var u#33211:u32
        let s_1743_1: u32 = fn_state.u_33211;
        // D s_1743_2: cast zx s_1743_1 -> bv
        let s_1743_2: Bits = Bits::new(s_1743_1 as u128, 32u16);
        // C s_1743_3: const #1u : u64
        let s_1743_3: u64 = 1;
        // D s_1743_4: bit-extract s_1743_2 s_1743_0 s_1743_3
        let s_1743_4: Bits = (Bits::new(
            ((s_1743_2) >> (s_1743_0)).value(),
            u16::try_from(s_1743_3).unwrap(),
        ));
        // D s_1743_5: cast reint s_1743_4 -> u8
        let s_1743_5: bool = ((s_1743_4.value()) != 0);
        // C s_1743_6: const #0s : i
        let s_1743_6: i128 = 0;
        // C s_1743_7: const #0u : u64
        let s_1743_7: u64 = 0;
        // D s_1743_8: cast zx s_1743_5 -> u64
        let s_1743_8: u64 = (s_1743_5 as u64);
        // C s_1743_9: const #1u : u64
        let s_1743_9: u64 = 1;
        // D s_1743_10: and s_1743_8 s_1743_9
        let s_1743_10: u64 = ((s_1743_8) & (s_1743_9));
        // D s_1743_11: cmp-eq s_1743_10 s_1743_9
        let s_1743_11: bool = ((s_1743_10) == (s_1743_9));
        // D s_1743_12: lsl s_1743_8 s_1743_6
        let s_1743_12: u64 = s_1743_8 << s_1743_6;
        // D s_1743_13: or s_1743_7 s_1743_12
        let s_1743_13: u64 = ((s_1743_7) | (s_1743_12));
        // D s_1743_14: cmpl s_1743_12
        let s_1743_14: u64 = !s_1743_12;
        // D s_1743_15: and s_1743_7 s_1743_14
        let s_1743_15: u64 = ((s_1743_7) & (s_1743_14));
        // D s_1743_16: select s_1743_11 s_1743_13 s_1743_15
        let s_1743_16: u64 = if s_1743_11 { s_1743_13 } else { s_1743_15 };
        // D s_1743_17: cast trunc s_1743_16 -> u8
        let s_1743_17: bool = ((s_1743_16) != 0);
        // D s_1743_18: cast zx s_1743_17 -> bv
        let s_1743_18: Bits = Bits::new(s_1743_17 as u128, 1u16);
        // C s_1743_19: const #1u : u8
        let s_1743_19: bool = true;
        // C s_1743_20: cast zx s_1743_19 -> bv
        let s_1743_20: Bits = Bits::new(s_1743_19 as u128, 1u16);
        // D s_1743_21: cmp-ne s_1743_18 s_1743_20
        let s_1743_21: bool = ((s_1743_18) != (s_1743_20));
        // D s_1743_22: write-var gs#408083 <= s_1743_21
        fn_state.gs_408083 = s_1743_21;
        // N s_1743_23: jump b1744
        return block_1744(state, tracer, fn_state);
    }
    fn block_1744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1744_0: read-var gs#408083:u8
        let s_1744_0: bool = fn_state.gs_408083;
        // N s_1744_1: branch s_1744_0 b1746 b1745
        if s_1744_0 {
            return block_1746(state, tracer, fn_state);
        } else {
            return block_1745(state, tracer, fn_state);
        };
    }
    fn block_1745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1745_0: read-var u#33212:u8
        let s_1745_0: u8 = fn_state.u_33212;
        // D s_1745_1: read-var u#33213:u8
        let s_1745_1: u8 = fn_state.u_33213;
        // D s_1745_2: read-var u#33214:u8
        let s_1745_2: u8 = fn_state.u_33214;
        // D s_1745_3: call decode_aarch32_instrs_LDAEXD_A1enc_A_txt(s_1745_0, s_1745_1, s_1745_2)
        let s_1745_3: () = decode_aarch32_instrs_LDAEXD_A1enc_A_txt(
            state,
            tracer,
            s_1745_0,
            s_1745_1,
            s_1745_2,
        );
        // N s_1745_4: return
        return;
    }
    fn block_1746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1746_0: panic
        panic!("{:?}", ());
        // N s_1746_1: return
        return;
    }
    fn block_1747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1747_0: const #1u : u8
        let s_1747_0: bool = true;
        // D s_1747_1: write-var gs#408083 <= s_1747_0
        fn_state.gs_408083 = s_1747_0;
        // N s_1747_2: jump b1744
        return block_1744(state, tracer, fn_state);
    }
    fn block_1748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1748_0: const #1u : u8
        let s_1748_0: bool = true;
        // D s_1748_1: write-var gs#408080 <= s_1748_0
        fn_state.gs_408080 = s_1748_0;
        // N s_1748_2: jump b1742
        return block_1742(state, tracer, fn_state);
    }
    fn block_1749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1749_0: const #1u : u8
        let s_1749_0: bool = true;
        // D s_1749_1: write-var gs#408077 <= s_1749_0
        fn_state.gs_408077 = s_1749_0;
        // N s_1749_2: jump b1740
        return block_1740(state, tracer, fn_state);
    }
    fn block_1750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1750_0: const #1u : u8
        let s_1750_0: bool = true;
        // D s_1750_1: write-var gs#408074 <= s_1750_0
        fn_state.gs_408074 = s_1750_0;
        // N s_1750_2: jump b1738
        return block_1738(state, tracer, fn_state);
    }
    fn block_1751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1751_0: const #1u : u8
        let s_1751_0: bool = true;
        // D s_1751_1: write-var gs#408071 <= s_1751_0
        fn_state.gs_408071 = s_1751_0;
        // N s_1751_2: jump b1736
        return block_1736(state, tracer, fn_state);
    }
    fn block_1752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1752_0: read-var merge#var.1:struct
        let s_1752_0: u32 = fn_state.merge_var._1;
        // D s_1752_1: write-var u#33216 <= s_1752_0
        fn_state.u_33216 = s_1752_0;
        // C s_1752_2: const #20s : i
        let s_1752_2: i128 = 20;
        // D s_1752_3: read-var u#33216:u32
        let s_1752_3: u32 = fn_state.u_33216;
        // D s_1752_4: cast zx s_1752_3 -> bv
        let s_1752_4: Bits = Bits::new(s_1752_3 as u128, 32u16);
        // C s_1752_5: const #1s : i64
        let s_1752_5: i64 = 1;
        // C s_1752_6: cast zx s_1752_5 -> i
        let s_1752_6: i128 = (i128::try_from(s_1752_5).unwrap());
        // C s_1752_7: const #7s : i
        let s_1752_7: i128 = 7;
        // C s_1752_8: add s_1752_7 s_1752_6
        let s_1752_8: i128 = (s_1752_7 + s_1752_6);
        // D s_1752_9: bit-extract s_1752_4 s_1752_2 s_1752_8
        let s_1752_9: Bits = (Bits::new(
            ((s_1752_4) >> (s_1752_2)).value(),
            u16::try_from(s_1752_8).unwrap(),
        ));
        // D s_1752_10: cast reint s_1752_9 -> u8
        let s_1752_10: u8 = (s_1752_9.value() as u8);
        // D s_1752_11: cast zx s_1752_10 -> bv
        let s_1752_11: Bits = Bits::new(s_1752_10 as u128, 8u16);
        // C s_1752_12: const #31u : u8
        let s_1752_12: u8 = 31;
        // C s_1752_13: cast zx s_1752_12 -> bv
        let s_1752_13: Bits = Bits::new(s_1752_12 as u128, 8u16);
        // D s_1752_14: cmp-eq s_1752_11 s_1752_13
        let s_1752_14: bool = ((s_1752_11) == (s_1752_13));
        // N s_1752_15: branch s_1752_14 b2111 b1753
        if s_1752_14 {
            return block_2111(state, tracer, fn_state);
        } else {
            return block_1753(state, tracer, fn_state);
        };
    }
    fn block_1753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1753_0: const #0u : u8
        let s_1753_0: bool = false;
        // D s_1753_1: write-var gs#408089 <= s_1753_0
        fn_state.gs_408089 = s_1753_0;
        // N s_1753_2: jump b1754
        return block_1754(state, tracer, fn_state);
    }
    fn block_1754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1754_0: read-var gs#408089:u8
        let s_1754_0: bool = fn_state.gs_408089;
        // N s_1754_1: branch s_1754_0 b2107 b1755
        if s_1754_0 {
            return block_2107(state, tracer, fn_state);
        } else {
            return block_1755(state, tracer, fn_state);
        };
    }
    fn block_1755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1755_0: const #0u : u8
        let s_1755_0: bool = false;
        // D s_1755_1: write-var gs#408094 <= s_1755_0
        fn_state.gs_408094 = s_1755_0;
        // N s_1755_2: jump b1756
        return block_1756(state, tracer, fn_state);
    }
    fn block_1756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1756_0: read-var gs#408094:u8
        let s_1756_0: bool = fn_state.gs_408094;
        // D s_1756_1: not s_1756_0
        let s_1756_1: bool = !s_1756_0;
        // N s_1756_2: branch s_1756_1 b1775 b1757
        if s_1756_1 {
            return block_1775(state, tracer, fn_state);
        } else {
            return block_1757(state, tracer, fn_state);
        };
    }
    fn block_1757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1757_0: const #3825s : i
        let s_1757_0: i128 = 3825;
        // C s_1757_1: const #14696u : u32
        let s_1757_1: u32 = 14696;
        // N s_1757_2: write-reg s_1757_1 <= s_1757_0
        let s_1757_2: () = {
            state.write_register::<i128>(s_1757_1 as isize, s_1757_0);
            tracer.write_register(s_1757_1 as isize, s_1757_0);
        };
        // C s_1757_3: const #28s : i
        let s_1757_3: i128 = 28;
        // C s_1757_4: const #4s : i
        let s_1757_4: i128 = 4;
        // D s_1757_5: read-var u#33216:u32
        let s_1757_5: u32 = fn_state.u_33216;
        // D s_1757_6: cast zx s_1757_5 -> bv
        let s_1757_6: Bits = Bits::new(s_1757_5 as u128, 32u16);
        // D s_1757_7: bit-extract s_1757_6 s_1757_3 s_1757_4
        let s_1757_7: Bits = (Bits::new(
            ((s_1757_6) >> (s_1757_3)).value(),
            u16::try_from(s_1757_4).unwrap(),
        ));
        // D s_1757_8: cast reint s_1757_7 -> u8
        let s_1757_8: u8 = (s_1757_7.value() as u8);
        // D s_1757_9: write-var u#33217 <= s_1757_8
        fn_state.u_33217 = s_1757_8;
        // C s_1757_10: const #16s : i
        let s_1757_10: i128 = 16;
        // C s_1757_11: const #4s : i
        let s_1757_11: i128 = 4;
        // D s_1757_12: read-var u#33216:u32
        let s_1757_12: u32 = fn_state.u_33216;
        // D s_1757_13: cast zx s_1757_12 -> bv
        let s_1757_13: Bits = Bits::new(s_1757_12 as u128, 32u16);
        // D s_1757_14: bit-extract s_1757_13 s_1757_10 s_1757_11
        let s_1757_14: Bits = (Bits::new(
            ((s_1757_13) >> (s_1757_10)).value(),
            u16::try_from(s_1757_11).unwrap(),
        ));
        // D s_1757_15: cast reint s_1757_14 -> u8
        let s_1757_15: u8 = (s_1757_14.value() as u8);
        // D s_1757_16: write-var u#33218 <= s_1757_15
        fn_state.u_33218 = s_1757_15;
        // C s_1757_17: const #12s : i
        let s_1757_17: i128 = 12;
        // C s_1757_18: const #4s : i
        let s_1757_18: i128 = 4;
        // D s_1757_19: read-var u#33216:u32
        let s_1757_19: u32 = fn_state.u_33216;
        // D s_1757_20: cast zx s_1757_19 -> bv
        let s_1757_20: Bits = Bits::new(s_1757_19 as u128, 32u16);
        // D s_1757_21: bit-extract s_1757_20 s_1757_17 s_1757_18
        let s_1757_21: Bits = (Bits::new(
            ((s_1757_20) >> (s_1757_17)).value(),
            u16::try_from(s_1757_18).unwrap(),
        ));
        // D s_1757_22: cast reint s_1757_21 -> u8
        let s_1757_22: u8 = (s_1757_21.value() as u8);
        // D s_1757_23: write-var u#33219 <= s_1757_22
        fn_state.u_33219 = s_1757_22;
        // C s_1757_24: const #8s : i
        let s_1757_24: i128 = 8;
        // D s_1757_25: read-var u#33216:u32
        let s_1757_25: u32 = fn_state.u_33216;
        // D s_1757_26: cast zx s_1757_25 -> bv
        let s_1757_26: Bits = Bits::new(s_1757_25 as u128, 32u16);
        // C s_1757_27: const #1u : u64
        let s_1757_27: u64 = 1;
        // D s_1757_28: bit-extract s_1757_26 s_1757_24 s_1757_27
        let s_1757_28: Bits = (Bits::new(
            ((s_1757_26) >> (s_1757_24)).value(),
            u16::try_from(s_1757_27).unwrap(),
        ));
        // D s_1757_29: cast reint s_1757_28 -> u8
        let s_1757_29: bool = ((s_1757_28.value()) != 0);
        // C s_1757_30: const #0s : i
        let s_1757_30: i128 = 0;
        // C s_1757_31: const #0u : u64
        let s_1757_31: u64 = 0;
        // D s_1757_32: cast zx s_1757_29 -> u64
        let s_1757_32: u64 = (s_1757_29 as u64);
        // C s_1757_33: const #1u : u64
        let s_1757_33: u64 = 1;
        // D s_1757_34: and s_1757_32 s_1757_33
        let s_1757_34: u64 = ((s_1757_32) & (s_1757_33));
        // D s_1757_35: cmp-eq s_1757_34 s_1757_33
        let s_1757_35: bool = ((s_1757_34) == (s_1757_33));
        // D s_1757_36: lsl s_1757_32 s_1757_30
        let s_1757_36: u64 = s_1757_32 << s_1757_30;
        // D s_1757_37: or s_1757_31 s_1757_36
        let s_1757_37: u64 = ((s_1757_31) | (s_1757_36));
        // D s_1757_38: cmpl s_1757_36
        let s_1757_38: u64 = !s_1757_36;
        // D s_1757_39: and s_1757_31 s_1757_38
        let s_1757_39: u64 = ((s_1757_31) & (s_1757_38));
        // D s_1757_40: select s_1757_35 s_1757_37 s_1757_39
        let s_1757_40: u64 = if s_1757_35 { s_1757_37 } else { s_1757_39 };
        // D s_1757_41: cast trunc s_1757_40 -> u8
        let s_1757_41: bool = ((s_1757_40) != 0);
        // D s_1757_42: cast zx s_1757_41 -> bv
        let s_1757_42: Bits = Bits::new(s_1757_41 as u128, 1u16);
        // C s_1757_43: const #1u : u8
        let s_1757_43: bool = true;
        // C s_1757_44: cast zx s_1757_43 -> bv
        let s_1757_44: Bits = Bits::new(s_1757_43 as u128, 1u16);
        // D s_1757_45: cmp-ne s_1757_42 s_1757_44
        let s_1757_45: bool = ((s_1757_42) != (s_1757_44));
        // N s_1757_46: branch s_1757_45 b1774 b1758
        if s_1757_45 {
            return block_1774(state, tracer, fn_state);
        } else {
            return block_1758(state, tracer, fn_state);
        };
    }
    fn block_1758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1758_0: const #9s : i
        let s_1758_0: i128 = 9;
        // D s_1758_1: read-var u#33216:u32
        let s_1758_1: u32 = fn_state.u_33216;
        // D s_1758_2: cast zx s_1758_1 -> bv
        let s_1758_2: Bits = Bits::new(s_1758_1 as u128, 32u16);
        // C s_1758_3: const #1u : u64
        let s_1758_3: u64 = 1;
        // D s_1758_4: bit-extract s_1758_2 s_1758_0 s_1758_3
        let s_1758_4: Bits = (Bits::new(
            ((s_1758_2) >> (s_1758_0)).value(),
            u16::try_from(s_1758_3).unwrap(),
        ));
        // D s_1758_5: cast reint s_1758_4 -> u8
        let s_1758_5: bool = ((s_1758_4.value()) != 0);
        // C s_1758_6: const #0s : i
        let s_1758_6: i128 = 0;
        // C s_1758_7: const #0u : u64
        let s_1758_7: u64 = 0;
        // D s_1758_8: cast zx s_1758_5 -> u64
        let s_1758_8: u64 = (s_1758_5 as u64);
        // C s_1758_9: const #1u : u64
        let s_1758_9: u64 = 1;
        // D s_1758_10: and s_1758_8 s_1758_9
        let s_1758_10: u64 = ((s_1758_8) & (s_1758_9));
        // D s_1758_11: cmp-eq s_1758_10 s_1758_9
        let s_1758_11: bool = ((s_1758_10) == (s_1758_9));
        // D s_1758_12: lsl s_1758_8 s_1758_6
        let s_1758_12: u64 = s_1758_8 << s_1758_6;
        // D s_1758_13: or s_1758_7 s_1758_12
        let s_1758_13: u64 = ((s_1758_7) | (s_1758_12));
        // D s_1758_14: cmpl s_1758_12
        let s_1758_14: u64 = !s_1758_12;
        // D s_1758_15: and s_1758_7 s_1758_14
        let s_1758_15: u64 = ((s_1758_7) & (s_1758_14));
        // D s_1758_16: select s_1758_11 s_1758_13 s_1758_15
        let s_1758_16: u64 = if s_1758_11 { s_1758_13 } else { s_1758_15 };
        // D s_1758_17: cast trunc s_1758_16 -> u8
        let s_1758_17: bool = ((s_1758_16) != 0);
        // D s_1758_18: cast zx s_1758_17 -> bv
        let s_1758_18: Bits = Bits::new(s_1758_17 as u128, 1u16);
        // C s_1758_19: const #1u : u8
        let s_1758_19: bool = true;
        // C s_1758_20: cast zx s_1758_19 -> bv
        let s_1758_20: Bits = Bits::new(s_1758_19 as u128, 1u16);
        // D s_1758_21: cmp-ne s_1758_18 s_1758_20
        let s_1758_21: bool = ((s_1758_18) != (s_1758_20));
        // D s_1758_22: write-var gs#408107 <= s_1758_21
        fn_state.gs_408107 = s_1758_21;
        // N s_1758_23: jump b1759
        return block_1759(state, tracer, fn_state);
    }
    fn block_1759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1759_0: read-var gs#408107:u8
        let s_1759_0: bool = fn_state.gs_408107;
        // N s_1759_1: branch s_1759_0 b1773 b1760
        if s_1759_0 {
            return block_1773(state, tracer, fn_state);
        } else {
            return block_1760(state, tracer, fn_state);
        };
    }
    fn block_1760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1760_0: const #0s : i
        let s_1760_0: i128 = 0;
        // D s_1760_1: read-var u#33216:u32
        let s_1760_1: u32 = fn_state.u_33216;
        // D s_1760_2: cast zx s_1760_1 -> bv
        let s_1760_2: Bits = Bits::new(s_1760_1 as u128, 32u16);
        // C s_1760_3: const #1u : u64
        let s_1760_3: u64 = 1;
        // D s_1760_4: bit-extract s_1760_2 s_1760_0 s_1760_3
        let s_1760_4: Bits = (Bits::new(
            ((s_1760_2) >> (s_1760_0)).value(),
            u16::try_from(s_1760_3).unwrap(),
        ));
        // D s_1760_5: cast reint s_1760_4 -> u8
        let s_1760_5: bool = ((s_1760_4.value()) != 0);
        // C s_1760_6: const #0s : i
        let s_1760_6: i128 = 0;
        // C s_1760_7: const #0u : u64
        let s_1760_7: u64 = 0;
        // D s_1760_8: cast zx s_1760_5 -> u64
        let s_1760_8: u64 = (s_1760_5 as u64);
        // C s_1760_9: const #1u : u64
        let s_1760_9: u64 = 1;
        // D s_1760_10: and s_1760_8 s_1760_9
        let s_1760_10: u64 = ((s_1760_8) & (s_1760_9));
        // D s_1760_11: cmp-eq s_1760_10 s_1760_9
        let s_1760_11: bool = ((s_1760_10) == (s_1760_9));
        // D s_1760_12: lsl s_1760_8 s_1760_6
        let s_1760_12: u64 = s_1760_8 << s_1760_6;
        // D s_1760_13: or s_1760_7 s_1760_12
        let s_1760_13: u64 = ((s_1760_7) | (s_1760_12));
        // D s_1760_14: cmpl s_1760_12
        let s_1760_14: u64 = !s_1760_12;
        // D s_1760_15: and s_1760_7 s_1760_14
        let s_1760_15: u64 = ((s_1760_7) & (s_1760_14));
        // D s_1760_16: select s_1760_11 s_1760_13 s_1760_15
        let s_1760_16: u64 = if s_1760_11 { s_1760_13 } else { s_1760_15 };
        // D s_1760_17: cast trunc s_1760_16 -> u8
        let s_1760_17: bool = ((s_1760_16) != 0);
        // D s_1760_18: cast zx s_1760_17 -> bv
        let s_1760_18: Bits = Bits::new(s_1760_17 as u128, 1u16);
        // C s_1760_19: const #1u : u8
        let s_1760_19: bool = true;
        // C s_1760_20: cast zx s_1760_19 -> bv
        let s_1760_20: Bits = Bits::new(s_1760_19 as u128, 1u16);
        // D s_1760_21: cmp-ne s_1760_18 s_1760_20
        let s_1760_21: bool = ((s_1760_18) != (s_1760_20));
        // D s_1760_22: write-var gs#408110 <= s_1760_21
        fn_state.gs_408110 = s_1760_21;
        // N s_1760_23: jump b1761
        return block_1761(state, tracer, fn_state);
    }
    fn block_1761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1761_0: read-var gs#408110:u8
        let s_1761_0: bool = fn_state.gs_408110;
        // N s_1761_1: branch s_1761_0 b1772 b1762
        if s_1761_0 {
            return block_1772(state, tracer, fn_state);
        } else {
            return block_1762(state, tracer, fn_state);
        };
    }
    fn block_1762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1762_0: const #1s : i
        let s_1762_0: i128 = 1;
        // D s_1762_1: read-var u#33216:u32
        let s_1762_1: u32 = fn_state.u_33216;
        // D s_1762_2: cast zx s_1762_1 -> bv
        let s_1762_2: Bits = Bits::new(s_1762_1 as u128, 32u16);
        // C s_1762_3: const #1u : u64
        let s_1762_3: u64 = 1;
        // D s_1762_4: bit-extract s_1762_2 s_1762_0 s_1762_3
        let s_1762_4: Bits = (Bits::new(
            ((s_1762_2) >> (s_1762_0)).value(),
            u16::try_from(s_1762_3).unwrap(),
        ));
        // D s_1762_5: cast reint s_1762_4 -> u8
        let s_1762_5: bool = ((s_1762_4.value()) != 0);
        // C s_1762_6: const #0s : i
        let s_1762_6: i128 = 0;
        // C s_1762_7: const #0u : u64
        let s_1762_7: u64 = 0;
        // D s_1762_8: cast zx s_1762_5 -> u64
        let s_1762_8: u64 = (s_1762_5 as u64);
        // C s_1762_9: const #1u : u64
        let s_1762_9: u64 = 1;
        // D s_1762_10: and s_1762_8 s_1762_9
        let s_1762_10: u64 = ((s_1762_8) & (s_1762_9));
        // D s_1762_11: cmp-eq s_1762_10 s_1762_9
        let s_1762_11: bool = ((s_1762_10) == (s_1762_9));
        // D s_1762_12: lsl s_1762_8 s_1762_6
        let s_1762_12: u64 = s_1762_8 << s_1762_6;
        // D s_1762_13: or s_1762_7 s_1762_12
        let s_1762_13: u64 = ((s_1762_7) | (s_1762_12));
        // D s_1762_14: cmpl s_1762_12
        let s_1762_14: u64 = !s_1762_12;
        // D s_1762_15: and s_1762_7 s_1762_14
        let s_1762_15: u64 = ((s_1762_7) & (s_1762_14));
        // D s_1762_16: select s_1762_11 s_1762_13 s_1762_15
        let s_1762_16: u64 = if s_1762_11 { s_1762_13 } else { s_1762_15 };
        // D s_1762_17: cast trunc s_1762_16 -> u8
        let s_1762_17: bool = ((s_1762_16) != 0);
        // D s_1762_18: cast zx s_1762_17 -> bv
        let s_1762_18: Bits = Bits::new(s_1762_17 as u128, 1u16);
        // C s_1762_19: const #1u : u8
        let s_1762_19: bool = true;
        // C s_1762_20: cast zx s_1762_19 -> bv
        let s_1762_20: Bits = Bits::new(s_1762_19 as u128, 1u16);
        // D s_1762_21: cmp-ne s_1762_18 s_1762_20
        let s_1762_21: bool = ((s_1762_18) != (s_1762_20));
        // D s_1762_22: write-var gs#408113 <= s_1762_21
        fn_state.gs_408113 = s_1762_21;
        // N s_1762_23: jump b1763
        return block_1763(state, tracer, fn_state);
    }
    fn block_1763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1763_0: read-var gs#408113:u8
        let s_1763_0: bool = fn_state.gs_408113;
        // N s_1763_1: branch s_1763_0 b1771 b1764
        if s_1763_0 {
            return block_1771(state, tracer, fn_state);
        } else {
            return block_1764(state, tracer, fn_state);
        };
    }
    fn block_1764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1764_0: const #2s : i
        let s_1764_0: i128 = 2;
        // D s_1764_1: read-var u#33216:u32
        let s_1764_1: u32 = fn_state.u_33216;
        // D s_1764_2: cast zx s_1764_1 -> bv
        let s_1764_2: Bits = Bits::new(s_1764_1 as u128, 32u16);
        // C s_1764_3: const #1u : u64
        let s_1764_3: u64 = 1;
        // D s_1764_4: bit-extract s_1764_2 s_1764_0 s_1764_3
        let s_1764_4: Bits = (Bits::new(
            ((s_1764_2) >> (s_1764_0)).value(),
            u16::try_from(s_1764_3).unwrap(),
        ));
        // D s_1764_5: cast reint s_1764_4 -> u8
        let s_1764_5: bool = ((s_1764_4.value()) != 0);
        // C s_1764_6: const #0s : i
        let s_1764_6: i128 = 0;
        // C s_1764_7: const #0u : u64
        let s_1764_7: u64 = 0;
        // D s_1764_8: cast zx s_1764_5 -> u64
        let s_1764_8: u64 = (s_1764_5 as u64);
        // C s_1764_9: const #1u : u64
        let s_1764_9: u64 = 1;
        // D s_1764_10: and s_1764_8 s_1764_9
        let s_1764_10: u64 = ((s_1764_8) & (s_1764_9));
        // D s_1764_11: cmp-eq s_1764_10 s_1764_9
        let s_1764_11: bool = ((s_1764_10) == (s_1764_9));
        // D s_1764_12: lsl s_1764_8 s_1764_6
        let s_1764_12: u64 = s_1764_8 << s_1764_6;
        // D s_1764_13: or s_1764_7 s_1764_12
        let s_1764_13: u64 = ((s_1764_7) | (s_1764_12));
        // D s_1764_14: cmpl s_1764_12
        let s_1764_14: u64 = !s_1764_12;
        // D s_1764_15: and s_1764_7 s_1764_14
        let s_1764_15: u64 = ((s_1764_7) & (s_1764_14));
        // D s_1764_16: select s_1764_11 s_1764_13 s_1764_15
        let s_1764_16: u64 = if s_1764_11 { s_1764_13 } else { s_1764_15 };
        // D s_1764_17: cast trunc s_1764_16 -> u8
        let s_1764_17: bool = ((s_1764_16) != 0);
        // D s_1764_18: cast zx s_1764_17 -> bv
        let s_1764_18: Bits = Bits::new(s_1764_17 as u128, 1u16);
        // C s_1764_19: const #1u : u8
        let s_1764_19: bool = true;
        // C s_1764_20: cast zx s_1764_19 -> bv
        let s_1764_20: Bits = Bits::new(s_1764_19 as u128, 1u16);
        // D s_1764_21: cmp-ne s_1764_18 s_1764_20
        let s_1764_21: bool = ((s_1764_18) != (s_1764_20));
        // D s_1764_22: write-var gs#408116 <= s_1764_21
        fn_state.gs_408116 = s_1764_21;
        // N s_1764_23: jump b1765
        return block_1765(state, tracer, fn_state);
    }
    fn block_1765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1765_0: read-var gs#408116:u8
        let s_1765_0: bool = fn_state.gs_408116;
        // N s_1765_1: branch s_1765_0 b1770 b1766
        if s_1765_0 {
            return block_1770(state, tracer, fn_state);
        } else {
            return block_1766(state, tracer, fn_state);
        };
    }
    fn block_1766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1766_0: const #3s : i
        let s_1766_0: i128 = 3;
        // D s_1766_1: read-var u#33216:u32
        let s_1766_1: u32 = fn_state.u_33216;
        // D s_1766_2: cast zx s_1766_1 -> bv
        let s_1766_2: Bits = Bits::new(s_1766_1 as u128, 32u16);
        // C s_1766_3: const #1u : u64
        let s_1766_3: u64 = 1;
        // D s_1766_4: bit-extract s_1766_2 s_1766_0 s_1766_3
        let s_1766_4: Bits = (Bits::new(
            ((s_1766_2) >> (s_1766_0)).value(),
            u16::try_from(s_1766_3).unwrap(),
        ));
        // D s_1766_5: cast reint s_1766_4 -> u8
        let s_1766_5: bool = ((s_1766_4.value()) != 0);
        // C s_1766_6: const #0s : i
        let s_1766_6: i128 = 0;
        // C s_1766_7: const #0u : u64
        let s_1766_7: u64 = 0;
        // D s_1766_8: cast zx s_1766_5 -> u64
        let s_1766_8: u64 = (s_1766_5 as u64);
        // C s_1766_9: const #1u : u64
        let s_1766_9: u64 = 1;
        // D s_1766_10: and s_1766_8 s_1766_9
        let s_1766_10: u64 = ((s_1766_8) & (s_1766_9));
        // D s_1766_11: cmp-eq s_1766_10 s_1766_9
        let s_1766_11: bool = ((s_1766_10) == (s_1766_9));
        // D s_1766_12: lsl s_1766_8 s_1766_6
        let s_1766_12: u64 = s_1766_8 << s_1766_6;
        // D s_1766_13: or s_1766_7 s_1766_12
        let s_1766_13: u64 = ((s_1766_7) | (s_1766_12));
        // D s_1766_14: cmpl s_1766_12
        let s_1766_14: u64 = !s_1766_12;
        // D s_1766_15: and s_1766_7 s_1766_14
        let s_1766_15: u64 = ((s_1766_7) & (s_1766_14));
        // D s_1766_16: select s_1766_11 s_1766_13 s_1766_15
        let s_1766_16: u64 = if s_1766_11 { s_1766_13 } else { s_1766_15 };
        // D s_1766_17: cast trunc s_1766_16 -> u8
        let s_1766_17: bool = ((s_1766_16) != 0);
        // D s_1766_18: cast zx s_1766_17 -> bv
        let s_1766_18: Bits = Bits::new(s_1766_17 as u128, 1u16);
        // C s_1766_19: const #1u : u8
        let s_1766_19: bool = true;
        // C s_1766_20: cast zx s_1766_19 -> bv
        let s_1766_20: Bits = Bits::new(s_1766_19 as u128, 1u16);
        // D s_1766_21: cmp-ne s_1766_18 s_1766_20
        let s_1766_21: bool = ((s_1766_18) != (s_1766_20));
        // D s_1766_22: write-var gs#408119 <= s_1766_21
        fn_state.gs_408119 = s_1766_21;
        // N s_1766_23: jump b1767
        return block_1767(state, tracer, fn_state);
    }
    fn block_1767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1767_0: read-var gs#408119:u8
        let s_1767_0: bool = fn_state.gs_408119;
        // N s_1767_1: branch s_1767_0 b1769 b1768
        if s_1767_0 {
            return block_1769(state, tracer, fn_state);
        } else {
            return block_1768(state, tracer, fn_state);
        };
    }
    fn block_1768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1768_0: read-var u#33217:u8
        let s_1768_0: u8 = fn_state.u_33217;
        // D s_1768_1: read-var u#33218:u8
        let s_1768_1: u8 = fn_state.u_33218;
        // D s_1768_2: read-var u#33219:u8
        let s_1768_2: u8 = fn_state.u_33219;
        // D s_1768_3: call decode_aarch32_instrs_LDAEXH_A1enc_A_txt(s_1768_0, s_1768_1, s_1768_2)
        let s_1768_3: () = decode_aarch32_instrs_LDAEXH_A1enc_A_txt(
            state,
            tracer,
            s_1768_0,
            s_1768_1,
            s_1768_2,
        );
        // N s_1768_4: return
        return;
    }
    fn block_1769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1769_0: panic
        panic!("{:?}", ());
        // N s_1769_1: return
        return;
    }
    fn block_1770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1770_0: const #1u : u8
        let s_1770_0: bool = true;
        // D s_1770_1: write-var gs#408119 <= s_1770_0
        fn_state.gs_408119 = s_1770_0;
        // N s_1770_2: jump b1767
        return block_1767(state, tracer, fn_state);
    }
    fn block_1771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1771_0: const #1u : u8
        let s_1771_0: bool = true;
        // D s_1771_1: write-var gs#408116 <= s_1771_0
        fn_state.gs_408116 = s_1771_0;
        // N s_1771_2: jump b1765
        return block_1765(state, tracer, fn_state);
    }
    fn block_1772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1772_0: const #1u : u8
        let s_1772_0: bool = true;
        // D s_1772_1: write-var gs#408113 <= s_1772_0
        fn_state.gs_408113 = s_1772_0;
        // N s_1772_2: jump b1763
        return block_1763(state, tracer, fn_state);
    }
    fn block_1773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1773_0: const #1u : u8
        let s_1773_0: bool = true;
        // D s_1773_1: write-var gs#408110 <= s_1773_0
        fn_state.gs_408110 = s_1773_0;
        // N s_1773_2: jump b1761
        return block_1761(state, tracer, fn_state);
    }
    fn block_1774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1774_0: const #1u : u8
        let s_1774_0: bool = true;
        // D s_1774_1: write-var gs#408107 <= s_1774_0
        fn_state.gs_408107 = s_1774_0;
        // N s_1774_2: jump b1759
        return block_1759(state, tracer, fn_state);
    }
    fn block_1775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1775_0: read-var merge#var.1:struct
        let s_1775_0: u32 = fn_state.merge_var._1;
        // D s_1775_1: write-var u#33221 <= s_1775_0
        fn_state.u_33221 = s_1775_0;
        // C s_1775_2: const #20s : i
        let s_1775_2: i128 = 20;
        // D s_1775_3: read-var u#33221:u32
        let s_1775_3: u32 = fn_state.u_33221;
        // D s_1775_4: cast zx s_1775_3 -> bv
        let s_1775_4: Bits = Bits::new(s_1775_3 as u128, 32u16);
        // C s_1775_5: const #1s : i64
        let s_1775_5: i64 = 1;
        // C s_1775_6: cast zx s_1775_5 -> i
        let s_1775_6: i128 = (i128::try_from(s_1775_5).unwrap());
        // C s_1775_7: const #7s : i
        let s_1775_7: i128 = 7;
        // C s_1775_8: add s_1775_7 s_1775_6
        let s_1775_8: i128 = (s_1775_7 + s_1775_6);
        // D s_1775_9: bit-extract s_1775_4 s_1775_2 s_1775_8
        let s_1775_9: Bits = (Bits::new(
            ((s_1775_4) >> (s_1775_2)).value(),
            u16::try_from(s_1775_8).unwrap(),
        ));
        // D s_1775_10: cast reint s_1775_9 -> u8
        let s_1775_10: u8 = (s_1775_9.value() as u8);
        // D s_1775_11: cast zx s_1775_10 -> bv
        let s_1775_11: Bits = Bits::new(s_1775_10 as u128, 8u16);
        // C s_1775_12: const #31u : u8
        let s_1775_12: u8 = 31;
        // C s_1775_13: cast zx s_1775_12 -> bv
        let s_1775_13: Bits = Bits::new(s_1775_12 as u128, 8u16);
        // D s_1775_14: cmp-eq s_1775_11 s_1775_13
        let s_1775_14: bool = ((s_1775_11) == (s_1775_13));
        // N s_1775_15: branch s_1775_14 b2106 b1776
        if s_1775_14 {
            return block_2106(state, tracer, fn_state);
        } else {
            return block_1776(state, tracer, fn_state);
        };
    }
    fn block_1776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1776_0: const #0u : u8
        let s_1776_0: bool = false;
        // D s_1776_1: write-var gs#408125 <= s_1776_0
        fn_state.gs_408125 = s_1776_0;
        // N s_1776_2: jump b1777
        return block_1777(state, tracer, fn_state);
    }
    fn block_1777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1777_0: read-var gs#408125:u8
        let s_1777_0: bool = fn_state.gs_408125;
        // N s_1777_1: branch s_1777_0 b2102 b1778
        if s_1777_0 {
            return block_2102(state, tracer, fn_state);
        } else {
            return block_1778(state, tracer, fn_state);
        };
    }
    fn block_1778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1778_0: const #0u : u8
        let s_1778_0: bool = false;
        // D s_1778_1: write-var gs#408130 <= s_1778_0
        fn_state.gs_408130 = s_1778_0;
        // N s_1778_2: jump b1779
        return block_1779(state, tracer, fn_state);
    }
    fn block_1779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1779_0: read-var gs#408130:u8
        let s_1779_0: bool = fn_state.gs_408130;
        // D s_1779_1: not s_1779_0
        let s_1779_1: bool = !s_1779_0;
        // N s_1779_2: branch s_1779_1 b1798 b1780
        if s_1779_1 {
            return block_1798(state, tracer, fn_state);
        } else {
            return block_1780(state, tracer, fn_state);
        };
    }
    fn block_1780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1780_0: const #3827s : i
        let s_1780_0: i128 = 3827;
        // C s_1780_1: const #14696u : u32
        let s_1780_1: u32 = 14696;
        // N s_1780_2: write-reg s_1780_1 <= s_1780_0
        let s_1780_2: () = {
            state.write_register::<i128>(s_1780_1 as isize, s_1780_0);
            tracer.write_register(s_1780_1 as isize, s_1780_0);
        };
        // C s_1780_3: const #28s : i
        let s_1780_3: i128 = 28;
        // C s_1780_4: const #4s : i
        let s_1780_4: i128 = 4;
        // D s_1780_5: read-var u#33221:u32
        let s_1780_5: u32 = fn_state.u_33221;
        // D s_1780_6: cast zx s_1780_5 -> bv
        let s_1780_6: Bits = Bits::new(s_1780_5 as u128, 32u16);
        // D s_1780_7: bit-extract s_1780_6 s_1780_3 s_1780_4
        let s_1780_7: Bits = (Bits::new(
            ((s_1780_6) >> (s_1780_3)).value(),
            u16::try_from(s_1780_4).unwrap(),
        ));
        // D s_1780_8: cast reint s_1780_7 -> u8
        let s_1780_8: u8 = (s_1780_7.value() as u8);
        // D s_1780_9: write-var u#33222 <= s_1780_8
        fn_state.u_33222 = s_1780_8;
        // C s_1780_10: const #16s : i
        let s_1780_10: i128 = 16;
        // C s_1780_11: const #4s : i
        let s_1780_11: i128 = 4;
        // D s_1780_12: read-var u#33221:u32
        let s_1780_12: u32 = fn_state.u_33221;
        // D s_1780_13: cast zx s_1780_12 -> bv
        let s_1780_13: Bits = Bits::new(s_1780_12 as u128, 32u16);
        // D s_1780_14: bit-extract s_1780_13 s_1780_10 s_1780_11
        let s_1780_14: Bits = (Bits::new(
            ((s_1780_13) >> (s_1780_10)).value(),
            u16::try_from(s_1780_11).unwrap(),
        ));
        // D s_1780_15: cast reint s_1780_14 -> u8
        let s_1780_15: u8 = (s_1780_14.value() as u8);
        // D s_1780_16: write-var u#33223 <= s_1780_15
        fn_state.u_33223 = s_1780_15;
        // C s_1780_17: const #12s : i
        let s_1780_17: i128 = 12;
        // C s_1780_18: const #4s : i
        let s_1780_18: i128 = 4;
        // D s_1780_19: read-var u#33221:u32
        let s_1780_19: u32 = fn_state.u_33221;
        // D s_1780_20: cast zx s_1780_19 -> bv
        let s_1780_20: Bits = Bits::new(s_1780_19 as u128, 32u16);
        // D s_1780_21: bit-extract s_1780_20 s_1780_17 s_1780_18
        let s_1780_21: Bits = (Bits::new(
            ((s_1780_20) >> (s_1780_17)).value(),
            u16::try_from(s_1780_18).unwrap(),
        ));
        // D s_1780_22: cast reint s_1780_21 -> u8
        let s_1780_22: u8 = (s_1780_21.value() as u8);
        // D s_1780_23: write-var u#33224 <= s_1780_22
        fn_state.u_33224 = s_1780_22;
        // C s_1780_24: const #8s : i
        let s_1780_24: i128 = 8;
        // D s_1780_25: read-var u#33221:u32
        let s_1780_25: u32 = fn_state.u_33221;
        // D s_1780_26: cast zx s_1780_25 -> bv
        let s_1780_26: Bits = Bits::new(s_1780_25 as u128, 32u16);
        // C s_1780_27: const #1u : u64
        let s_1780_27: u64 = 1;
        // D s_1780_28: bit-extract s_1780_26 s_1780_24 s_1780_27
        let s_1780_28: Bits = (Bits::new(
            ((s_1780_26) >> (s_1780_24)).value(),
            u16::try_from(s_1780_27).unwrap(),
        ));
        // D s_1780_29: cast reint s_1780_28 -> u8
        let s_1780_29: bool = ((s_1780_28.value()) != 0);
        // C s_1780_30: const #0s : i
        let s_1780_30: i128 = 0;
        // C s_1780_31: const #0u : u64
        let s_1780_31: u64 = 0;
        // D s_1780_32: cast zx s_1780_29 -> u64
        let s_1780_32: u64 = (s_1780_29 as u64);
        // C s_1780_33: const #1u : u64
        let s_1780_33: u64 = 1;
        // D s_1780_34: and s_1780_32 s_1780_33
        let s_1780_34: u64 = ((s_1780_32) & (s_1780_33));
        // D s_1780_35: cmp-eq s_1780_34 s_1780_33
        let s_1780_35: bool = ((s_1780_34) == (s_1780_33));
        // D s_1780_36: lsl s_1780_32 s_1780_30
        let s_1780_36: u64 = s_1780_32 << s_1780_30;
        // D s_1780_37: or s_1780_31 s_1780_36
        let s_1780_37: u64 = ((s_1780_31) | (s_1780_36));
        // D s_1780_38: cmpl s_1780_36
        let s_1780_38: u64 = !s_1780_36;
        // D s_1780_39: and s_1780_31 s_1780_38
        let s_1780_39: u64 = ((s_1780_31) & (s_1780_38));
        // D s_1780_40: select s_1780_35 s_1780_37 s_1780_39
        let s_1780_40: u64 = if s_1780_35 { s_1780_37 } else { s_1780_39 };
        // D s_1780_41: cast trunc s_1780_40 -> u8
        let s_1780_41: bool = ((s_1780_40) != 0);
        // D s_1780_42: cast zx s_1780_41 -> bv
        let s_1780_42: Bits = Bits::new(s_1780_41 as u128, 1u16);
        // C s_1780_43: const #1u : u8
        let s_1780_43: bool = true;
        // C s_1780_44: cast zx s_1780_43 -> bv
        let s_1780_44: Bits = Bits::new(s_1780_43 as u128, 1u16);
        // D s_1780_45: cmp-ne s_1780_42 s_1780_44
        let s_1780_45: bool = ((s_1780_42) != (s_1780_44));
        // N s_1780_46: branch s_1780_45 b1797 b1781
        if s_1780_45 {
            return block_1797(state, tracer, fn_state);
        } else {
            return block_1781(state, tracer, fn_state);
        };
    }
    fn block_1781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1781_0: const #9s : i
        let s_1781_0: i128 = 9;
        // D s_1781_1: read-var u#33221:u32
        let s_1781_1: u32 = fn_state.u_33221;
        // D s_1781_2: cast zx s_1781_1 -> bv
        let s_1781_2: Bits = Bits::new(s_1781_1 as u128, 32u16);
        // C s_1781_3: const #1u : u64
        let s_1781_3: u64 = 1;
        // D s_1781_4: bit-extract s_1781_2 s_1781_0 s_1781_3
        let s_1781_4: Bits = (Bits::new(
            ((s_1781_2) >> (s_1781_0)).value(),
            u16::try_from(s_1781_3).unwrap(),
        ));
        // D s_1781_5: cast reint s_1781_4 -> u8
        let s_1781_5: bool = ((s_1781_4.value()) != 0);
        // C s_1781_6: const #0s : i
        let s_1781_6: i128 = 0;
        // C s_1781_7: const #0u : u64
        let s_1781_7: u64 = 0;
        // D s_1781_8: cast zx s_1781_5 -> u64
        let s_1781_8: u64 = (s_1781_5 as u64);
        // C s_1781_9: const #1u : u64
        let s_1781_9: u64 = 1;
        // D s_1781_10: and s_1781_8 s_1781_9
        let s_1781_10: u64 = ((s_1781_8) & (s_1781_9));
        // D s_1781_11: cmp-eq s_1781_10 s_1781_9
        let s_1781_11: bool = ((s_1781_10) == (s_1781_9));
        // D s_1781_12: lsl s_1781_8 s_1781_6
        let s_1781_12: u64 = s_1781_8 << s_1781_6;
        // D s_1781_13: or s_1781_7 s_1781_12
        let s_1781_13: u64 = ((s_1781_7) | (s_1781_12));
        // D s_1781_14: cmpl s_1781_12
        let s_1781_14: u64 = !s_1781_12;
        // D s_1781_15: and s_1781_7 s_1781_14
        let s_1781_15: u64 = ((s_1781_7) & (s_1781_14));
        // D s_1781_16: select s_1781_11 s_1781_13 s_1781_15
        let s_1781_16: u64 = if s_1781_11 { s_1781_13 } else { s_1781_15 };
        // D s_1781_17: cast trunc s_1781_16 -> u8
        let s_1781_17: bool = ((s_1781_16) != 0);
        // D s_1781_18: cast zx s_1781_17 -> bv
        let s_1781_18: Bits = Bits::new(s_1781_17 as u128, 1u16);
        // C s_1781_19: const #1u : u8
        let s_1781_19: bool = true;
        // C s_1781_20: cast zx s_1781_19 -> bv
        let s_1781_20: Bits = Bits::new(s_1781_19 as u128, 1u16);
        // D s_1781_21: cmp-ne s_1781_18 s_1781_20
        let s_1781_21: bool = ((s_1781_18) != (s_1781_20));
        // D s_1781_22: write-var gs#408143 <= s_1781_21
        fn_state.gs_408143 = s_1781_21;
        // N s_1781_23: jump b1782
        return block_1782(state, tracer, fn_state);
    }
    fn block_1782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1782_0: read-var gs#408143:u8
        let s_1782_0: bool = fn_state.gs_408143;
        // N s_1782_1: branch s_1782_0 b1796 b1783
        if s_1782_0 {
            return block_1796(state, tracer, fn_state);
        } else {
            return block_1783(state, tracer, fn_state);
        };
    }
    fn block_1783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1783_0: const #0s : i
        let s_1783_0: i128 = 0;
        // D s_1783_1: read-var u#33221:u32
        let s_1783_1: u32 = fn_state.u_33221;
        // D s_1783_2: cast zx s_1783_1 -> bv
        let s_1783_2: Bits = Bits::new(s_1783_1 as u128, 32u16);
        // C s_1783_3: const #1u : u64
        let s_1783_3: u64 = 1;
        // D s_1783_4: bit-extract s_1783_2 s_1783_0 s_1783_3
        let s_1783_4: Bits = (Bits::new(
            ((s_1783_2) >> (s_1783_0)).value(),
            u16::try_from(s_1783_3).unwrap(),
        ));
        // D s_1783_5: cast reint s_1783_4 -> u8
        let s_1783_5: bool = ((s_1783_4.value()) != 0);
        // C s_1783_6: const #0s : i
        let s_1783_6: i128 = 0;
        // C s_1783_7: const #0u : u64
        let s_1783_7: u64 = 0;
        // D s_1783_8: cast zx s_1783_5 -> u64
        let s_1783_8: u64 = (s_1783_5 as u64);
        // C s_1783_9: const #1u : u64
        let s_1783_9: u64 = 1;
        // D s_1783_10: and s_1783_8 s_1783_9
        let s_1783_10: u64 = ((s_1783_8) & (s_1783_9));
        // D s_1783_11: cmp-eq s_1783_10 s_1783_9
        let s_1783_11: bool = ((s_1783_10) == (s_1783_9));
        // D s_1783_12: lsl s_1783_8 s_1783_6
        let s_1783_12: u64 = s_1783_8 << s_1783_6;
        // D s_1783_13: or s_1783_7 s_1783_12
        let s_1783_13: u64 = ((s_1783_7) | (s_1783_12));
        // D s_1783_14: cmpl s_1783_12
        let s_1783_14: u64 = !s_1783_12;
        // D s_1783_15: and s_1783_7 s_1783_14
        let s_1783_15: u64 = ((s_1783_7) & (s_1783_14));
        // D s_1783_16: select s_1783_11 s_1783_13 s_1783_15
        let s_1783_16: u64 = if s_1783_11 { s_1783_13 } else { s_1783_15 };
        // D s_1783_17: cast trunc s_1783_16 -> u8
        let s_1783_17: bool = ((s_1783_16) != 0);
        // D s_1783_18: cast zx s_1783_17 -> bv
        let s_1783_18: Bits = Bits::new(s_1783_17 as u128, 1u16);
        // C s_1783_19: const #1u : u8
        let s_1783_19: bool = true;
        // C s_1783_20: cast zx s_1783_19 -> bv
        let s_1783_20: Bits = Bits::new(s_1783_19 as u128, 1u16);
        // D s_1783_21: cmp-ne s_1783_18 s_1783_20
        let s_1783_21: bool = ((s_1783_18) != (s_1783_20));
        // D s_1783_22: write-var gs#408146 <= s_1783_21
        fn_state.gs_408146 = s_1783_21;
        // N s_1783_23: jump b1784
        return block_1784(state, tracer, fn_state);
    }
    fn block_1784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1784_0: read-var gs#408146:u8
        let s_1784_0: bool = fn_state.gs_408146;
        // N s_1784_1: branch s_1784_0 b1795 b1785
        if s_1784_0 {
            return block_1795(state, tracer, fn_state);
        } else {
            return block_1785(state, tracer, fn_state);
        };
    }
    fn block_1785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1785_0: const #1s : i
        let s_1785_0: i128 = 1;
        // D s_1785_1: read-var u#33221:u32
        let s_1785_1: u32 = fn_state.u_33221;
        // D s_1785_2: cast zx s_1785_1 -> bv
        let s_1785_2: Bits = Bits::new(s_1785_1 as u128, 32u16);
        // C s_1785_3: const #1u : u64
        let s_1785_3: u64 = 1;
        // D s_1785_4: bit-extract s_1785_2 s_1785_0 s_1785_3
        let s_1785_4: Bits = (Bits::new(
            ((s_1785_2) >> (s_1785_0)).value(),
            u16::try_from(s_1785_3).unwrap(),
        ));
        // D s_1785_5: cast reint s_1785_4 -> u8
        let s_1785_5: bool = ((s_1785_4.value()) != 0);
        // C s_1785_6: const #0s : i
        let s_1785_6: i128 = 0;
        // C s_1785_7: const #0u : u64
        let s_1785_7: u64 = 0;
        // D s_1785_8: cast zx s_1785_5 -> u64
        let s_1785_8: u64 = (s_1785_5 as u64);
        // C s_1785_9: const #1u : u64
        let s_1785_9: u64 = 1;
        // D s_1785_10: and s_1785_8 s_1785_9
        let s_1785_10: u64 = ((s_1785_8) & (s_1785_9));
        // D s_1785_11: cmp-eq s_1785_10 s_1785_9
        let s_1785_11: bool = ((s_1785_10) == (s_1785_9));
        // D s_1785_12: lsl s_1785_8 s_1785_6
        let s_1785_12: u64 = s_1785_8 << s_1785_6;
        // D s_1785_13: or s_1785_7 s_1785_12
        let s_1785_13: u64 = ((s_1785_7) | (s_1785_12));
        // D s_1785_14: cmpl s_1785_12
        let s_1785_14: u64 = !s_1785_12;
        // D s_1785_15: and s_1785_7 s_1785_14
        let s_1785_15: u64 = ((s_1785_7) & (s_1785_14));
        // D s_1785_16: select s_1785_11 s_1785_13 s_1785_15
        let s_1785_16: u64 = if s_1785_11 { s_1785_13 } else { s_1785_15 };
        // D s_1785_17: cast trunc s_1785_16 -> u8
        let s_1785_17: bool = ((s_1785_16) != 0);
        // D s_1785_18: cast zx s_1785_17 -> bv
        let s_1785_18: Bits = Bits::new(s_1785_17 as u128, 1u16);
        // C s_1785_19: const #1u : u8
        let s_1785_19: bool = true;
        // C s_1785_20: cast zx s_1785_19 -> bv
        let s_1785_20: Bits = Bits::new(s_1785_19 as u128, 1u16);
        // D s_1785_21: cmp-ne s_1785_18 s_1785_20
        let s_1785_21: bool = ((s_1785_18) != (s_1785_20));
        // D s_1785_22: write-var gs#408149 <= s_1785_21
        fn_state.gs_408149 = s_1785_21;
        // N s_1785_23: jump b1786
        return block_1786(state, tracer, fn_state);
    }
    fn block_1786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1786_0: read-var gs#408149:u8
        let s_1786_0: bool = fn_state.gs_408149;
        // N s_1786_1: branch s_1786_0 b1794 b1787
        if s_1786_0 {
            return block_1794(state, tracer, fn_state);
        } else {
            return block_1787(state, tracer, fn_state);
        };
    }
    fn block_1787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1787_0: const #2s : i
        let s_1787_0: i128 = 2;
        // D s_1787_1: read-var u#33221:u32
        let s_1787_1: u32 = fn_state.u_33221;
        // D s_1787_2: cast zx s_1787_1 -> bv
        let s_1787_2: Bits = Bits::new(s_1787_1 as u128, 32u16);
        // C s_1787_3: const #1u : u64
        let s_1787_3: u64 = 1;
        // D s_1787_4: bit-extract s_1787_2 s_1787_0 s_1787_3
        let s_1787_4: Bits = (Bits::new(
            ((s_1787_2) >> (s_1787_0)).value(),
            u16::try_from(s_1787_3).unwrap(),
        ));
        // D s_1787_5: cast reint s_1787_4 -> u8
        let s_1787_5: bool = ((s_1787_4.value()) != 0);
        // C s_1787_6: const #0s : i
        let s_1787_6: i128 = 0;
        // C s_1787_7: const #0u : u64
        let s_1787_7: u64 = 0;
        // D s_1787_8: cast zx s_1787_5 -> u64
        let s_1787_8: u64 = (s_1787_5 as u64);
        // C s_1787_9: const #1u : u64
        let s_1787_9: u64 = 1;
        // D s_1787_10: and s_1787_8 s_1787_9
        let s_1787_10: u64 = ((s_1787_8) & (s_1787_9));
        // D s_1787_11: cmp-eq s_1787_10 s_1787_9
        let s_1787_11: bool = ((s_1787_10) == (s_1787_9));
        // D s_1787_12: lsl s_1787_8 s_1787_6
        let s_1787_12: u64 = s_1787_8 << s_1787_6;
        // D s_1787_13: or s_1787_7 s_1787_12
        let s_1787_13: u64 = ((s_1787_7) | (s_1787_12));
        // D s_1787_14: cmpl s_1787_12
        let s_1787_14: u64 = !s_1787_12;
        // D s_1787_15: and s_1787_7 s_1787_14
        let s_1787_15: u64 = ((s_1787_7) & (s_1787_14));
        // D s_1787_16: select s_1787_11 s_1787_13 s_1787_15
        let s_1787_16: u64 = if s_1787_11 { s_1787_13 } else { s_1787_15 };
        // D s_1787_17: cast trunc s_1787_16 -> u8
        let s_1787_17: bool = ((s_1787_16) != 0);
        // D s_1787_18: cast zx s_1787_17 -> bv
        let s_1787_18: Bits = Bits::new(s_1787_17 as u128, 1u16);
        // C s_1787_19: const #1u : u8
        let s_1787_19: bool = true;
        // C s_1787_20: cast zx s_1787_19 -> bv
        let s_1787_20: Bits = Bits::new(s_1787_19 as u128, 1u16);
        // D s_1787_21: cmp-ne s_1787_18 s_1787_20
        let s_1787_21: bool = ((s_1787_18) != (s_1787_20));
        // D s_1787_22: write-var gs#408152 <= s_1787_21
        fn_state.gs_408152 = s_1787_21;
        // N s_1787_23: jump b1788
        return block_1788(state, tracer, fn_state);
    }
    fn block_1788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1788_0: read-var gs#408152:u8
        let s_1788_0: bool = fn_state.gs_408152;
        // N s_1788_1: branch s_1788_0 b1793 b1789
        if s_1788_0 {
            return block_1793(state, tracer, fn_state);
        } else {
            return block_1789(state, tracer, fn_state);
        };
    }
    fn block_1789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1789_0: const #3s : i
        let s_1789_0: i128 = 3;
        // D s_1789_1: read-var u#33221:u32
        let s_1789_1: u32 = fn_state.u_33221;
        // D s_1789_2: cast zx s_1789_1 -> bv
        let s_1789_2: Bits = Bits::new(s_1789_1 as u128, 32u16);
        // C s_1789_3: const #1u : u64
        let s_1789_3: u64 = 1;
        // D s_1789_4: bit-extract s_1789_2 s_1789_0 s_1789_3
        let s_1789_4: Bits = (Bits::new(
            ((s_1789_2) >> (s_1789_0)).value(),
            u16::try_from(s_1789_3).unwrap(),
        ));
        // D s_1789_5: cast reint s_1789_4 -> u8
        let s_1789_5: bool = ((s_1789_4.value()) != 0);
        // C s_1789_6: const #0s : i
        let s_1789_6: i128 = 0;
        // C s_1789_7: const #0u : u64
        let s_1789_7: u64 = 0;
        // D s_1789_8: cast zx s_1789_5 -> u64
        let s_1789_8: u64 = (s_1789_5 as u64);
        // C s_1789_9: const #1u : u64
        let s_1789_9: u64 = 1;
        // D s_1789_10: and s_1789_8 s_1789_9
        let s_1789_10: u64 = ((s_1789_8) & (s_1789_9));
        // D s_1789_11: cmp-eq s_1789_10 s_1789_9
        let s_1789_11: bool = ((s_1789_10) == (s_1789_9));
        // D s_1789_12: lsl s_1789_8 s_1789_6
        let s_1789_12: u64 = s_1789_8 << s_1789_6;
        // D s_1789_13: or s_1789_7 s_1789_12
        let s_1789_13: u64 = ((s_1789_7) | (s_1789_12));
        // D s_1789_14: cmpl s_1789_12
        let s_1789_14: u64 = !s_1789_12;
        // D s_1789_15: and s_1789_7 s_1789_14
        let s_1789_15: u64 = ((s_1789_7) & (s_1789_14));
        // D s_1789_16: select s_1789_11 s_1789_13 s_1789_15
        let s_1789_16: u64 = if s_1789_11 { s_1789_13 } else { s_1789_15 };
        // D s_1789_17: cast trunc s_1789_16 -> u8
        let s_1789_17: bool = ((s_1789_16) != 0);
        // D s_1789_18: cast zx s_1789_17 -> bv
        let s_1789_18: Bits = Bits::new(s_1789_17 as u128, 1u16);
        // C s_1789_19: const #1u : u8
        let s_1789_19: bool = true;
        // C s_1789_20: cast zx s_1789_19 -> bv
        let s_1789_20: Bits = Bits::new(s_1789_19 as u128, 1u16);
        // D s_1789_21: cmp-ne s_1789_18 s_1789_20
        let s_1789_21: bool = ((s_1789_18) != (s_1789_20));
        // D s_1789_22: write-var gs#408155 <= s_1789_21
        fn_state.gs_408155 = s_1789_21;
        // N s_1789_23: jump b1790
        return block_1790(state, tracer, fn_state);
    }
    fn block_1790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1790_0: read-var gs#408155:u8
        let s_1790_0: bool = fn_state.gs_408155;
        // N s_1790_1: branch s_1790_0 b1792 b1791
        if s_1790_0 {
            return block_1792(state, tracer, fn_state);
        } else {
            return block_1791(state, tracer, fn_state);
        };
    }
    fn block_1791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1791_0: read-var u#33222:u8
        let s_1791_0: u8 = fn_state.u_33222;
        // D s_1791_1: read-var u#33223:u8
        let s_1791_1: u8 = fn_state.u_33223;
        // D s_1791_2: read-var u#33224:u8
        let s_1791_2: u8 = fn_state.u_33224;
        // D s_1791_3: call decode_aarch32_instrs_LDAH_A1enc_A_txt(s_1791_0, s_1791_1, s_1791_2)
        let s_1791_3: () = decode_aarch32_instrs_LDAH_A1enc_A_txt(
            state,
            tracer,
            s_1791_0,
            s_1791_1,
            s_1791_2,
        );
        // N s_1791_4: return
        return;
    }
    fn block_1792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1792_0: panic
        panic!("{:?}", ());
        // N s_1792_1: return
        return;
    }
    fn block_1793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1793_0: const #1u : u8
        let s_1793_0: bool = true;
        // D s_1793_1: write-var gs#408155 <= s_1793_0
        fn_state.gs_408155 = s_1793_0;
        // N s_1793_2: jump b1790
        return block_1790(state, tracer, fn_state);
    }
    fn block_1794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1794_0: const #1u : u8
        let s_1794_0: bool = true;
        // D s_1794_1: write-var gs#408152 <= s_1794_0
        fn_state.gs_408152 = s_1794_0;
        // N s_1794_2: jump b1788
        return block_1788(state, tracer, fn_state);
    }
    fn block_1795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1795_0: const #1u : u8
        let s_1795_0: bool = true;
        // D s_1795_1: write-var gs#408149 <= s_1795_0
        fn_state.gs_408149 = s_1795_0;
        // N s_1795_2: jump b1786
        return block_1786(state, tracer, fn_state);
    }
    fn block_1796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1796_0: const #1u : u8
        let s_1796_0: bool = true;
        // D s_1796_1: write-var gs#408146 <= s_1796_0
        fn_state.gs_408146 = s_1796_0;
        // N s_1796_2: jump b1784
        return block_1784(state, tracer, fn_state);
    }
    fn block_1797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1797_0: const #1u : u8
        let s_1797_0: bool = true;
        // D s_1797_1: write-var gs#408143 <= s_1797_0
        fn_state.gs_408143 = s_1797_0;
        // N s_1797_2: jump b1782
        return block_1782(state, tracer, fn_state);
    }
    fn block_1798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1798_0: read-var merge#var.1:struct
        let s_1798_0: u32 = fn_state.merge_var._1;
        // D s_1798_1: write-var u#33226 <= s_1798_0
        fn_state.u_33226 = s_1798_0;
        // C s_1798_2: const #0s : i
        let s_1798_2: i128 = 0;
        // D s_1798_3: read-var u#33226:u32
        let s_1798_3: u32 = fn_state.u_33226;
        // D s_1798_4: cast zx s_1798_3 -> bv
        let s_1798_4: Bits = Bits::new(s_1798_3 as u128, 32u16);
        // C s_1798_5: const #1s : i64
        let s_1798_5: i64 = 1;
        // C s_1798_6: cast zx s_1798_5 -> i
        let s_1798_6: i128 = (i128::try_from(s_1798_5).unwrap());
        // C s_1798_7: const #27s : i
        let s_1798_7: i128 = 27;
        // C s_1798_8: add s_1798_7 s_1798_6
        let s_1798_8: i128 = (s_1798_7 + s_1798_6);
        // D s_1798_9: bit-extract s_1798_4 s_1798_2 s_1798_8
        let s_1798_9: Bits = (Bits::new(
            ((s_1798_4) >> (s_1798_2)).value(),
            u16::try_from(s_1798_8).unwrap(),
        ));
        // D s_1798_10: cast reint s_1798_9 -> u28
        let s_1798_10: u32 = (s_1798_9.value() as u32);
        // D s_1798_11: cast zx s_1798_10 -> bv
        let s_1798_11: Bits = Bits::new(s_1798_10 as u128, 28u16);
        // C s_1798_12: const #52490245u : u28
        let s_1798_12: u32 = 52490245;
        // C s_1798_13: cast zx s_1798_12 -> bv
        let s_1798_13: Bits = Bits::new(s_1798_12 as u128, 28u16);
        // D s_1798_14: cmp-eq s_1798_11 s_1798_13
        let s_1798_14: bool = ((s_1798_11) == (s_1798_13));
        // N s_1798_15: branch s_1798_14 b2098 b1799
        if s_1798_14 {
            return block_2098(state, tracer, fn_state);
        } else {
            return block_1799(state, tracer, fn_state);
        };
    }
    fn block_1799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1799_0: const #0u : u8
        let s_1799_0: bool = false;
        // D s_1799_1: write-var gs#408163 <= s_1799_0
        fn_state.gs_408163 = s_1799_0;
        // N s_1799_2: jump b1800
        return block_1800(state, tracer, fn_state);
    }
    fn block_1800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1800_0: read-var gs#408163:u8
        let s_1800_0: bool = fn_state.gs_408163;
        // D s_1800_1: not s_1800_0
        let s_1800_1: bool = !s_1800_0;
        // N s_1800_2: branch s_1800_1 b1825 b1801
        if s_1800_1 {
            return block_1825(state, tracer, fn_state);
        } else {
            return block_1801(state, tracer, fn_state);
        };
    }
    fn block_1801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1801_0: const #3829s : i
        let s_1801_0: i128 = 3829;
        // C s_1801_1: const #14696u : u32
        let s_1801_1: u32 = 14696;
        // N s_1801_2: write-reg s_1801_1 <= s_1801_0
        let s_1801_2: () = {
            state.write_register::<i128>(s_1801_1 as isize, s_1801_0);
            tracer.write_register(s_1801_1 as isize, s_1801_0);
        };
        // C s_1801_3: const #28s : i
        let s_1801_3: i128 = 28;
        // C s_1801_4: const #4s : i
        let s_1801_4: i128 = 4;
        // D s_1801_5: read-var u#33226:u32
        let s_1801_5: u32 = fn_state.u_33226;
        // D s_1801_6: cast zx s_1801_5 -> bv
        let s_1801_6: Bits = Bits::new(s_1801_5 as u128, 32u16);
        // D s_1801_7: bit-extract s_1801_6 s_1801_3 s_1801_4
        let s_1801_7: Bits = (Bits::new(
            ((s_1801_6) >> (s_1801_3)).value(),
            u16::try_from(s_1801_4).unwrap(),
        ));
        // D s_1801_8: cast reint s_1801_7 -> u8
        let s_1801_8: u8 = (s_1801_7.value() as u8);
        // D s_1801_9: write-var u#33227 <= s_1801_8
        fn_state.u_33227 = s_1801_8;
        // C s_1801_10: const #12s : i
        let s_1801_10: i128 = 12;
        // D s_1801_11: read-var u#33226:u32
        let s_1801_11: u32 = fn_state.u_33226;
        // D s_1801_12: cast zx s_1801_11 -> bv
        let s_1801_12: Bits = Bits::new(s_1801_11 as u128, 32u16);
        // C s_1801_13: const #1u : u64
        let s_1801_13: u64 = 1;
        // D s_1801_14: bit-extract s_1801_12 s_1801_10 s_1801_13
        let s_1801_14: Bits = (Bits::new(
            ((s_1801_12) >> (s_1801_10)).value(),
            u16::try_from(s_1801_13).unwrap(),
        ));
        // D s_1801_15: cast reint s_1801_14 -> u8
        let s_1801_15: bool = ((s_1801_14.value()) != 0);
        // C s_1801_16: const #0s : i
        let s_1801_16: i128 = 0;
        // C s_1801_17: const #0u : u64
        let s_1801_17: u64 = 0;
        // D s_1801_18: cast zx s_1801_15 -> u64
        let s_1801_18: u64 = (s_1801_15 as u64);
        // C s_1801_19: const #1u : u64
        let s_1801_19: u64 = 1;
        // D s_1801_20: and s_1801_18 s_1801_19
        let s_1801_20: u64 = ((s_1801_18) & (s_1801_19));
        // D s_1801_21: cmp-eq s_1801_20 s_1801_19
        let s_1801_21: bool = ((s_1801_20) == (s_1801_19));
        // D s_1801_22: lsl s_1801_18 s_1801_16
        let s_1801_22: u64 = s_1801_18 << s_1801_16;
        // D s_1801_23: or s_1801_17 s_1801_22
        let s_1801_23: u64 = ((s_1801_17) | (s_1801_22));
        // D s_1801_24: cmpl s_1801_22
        let s_1801_24: u64 = !s_1801_22;
        // D s_1801_25: and s_1801_17 s_1801_24
        let s_1801_25: u64 = ((s_1801_17) & (s_1801_24));
        // D s_1801_26: select s_1801_21 s_1801_23 s_1801_25
        let s_1801_26: u64 = if s_1801_21 { s_1801_23 } else { s_1801_25 };
        // D s_1801_27: cast trunc s_1801_26 -> u8
        let s_1801_27: bool = ((s_1801_26) != 0);
        // D s_1801_28: cast zx s_1801_27 -> bv
        let s_1801_28: Bits = Bits::new(s_1801_27 as u128, 1u16);
        // C s_1801_29: const #1u : u8
        let s_1801_29: bool = true;
        // C s_1801_30: cast zx s_1801_29 -> bv
        let s_1801_30: Bits = Bits::new(s_1801_29 as u128, 1u16);
        // D s_1801_31: cmp-ne s_1801_28 s_1801_30
        let s_1801_31: bool = ((s_1801_28) != (s_1801_30));
        // N s_1801_32: branch s_1801_31 b1824 b1802
        if s_1801_31 {
            return block_1824(state, tracer, fn_state);
        } else {
            return block_1802(state, tracer, fn_state);
        };
    }
    fn block_1802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1802_0: const #13s : i
        let s_1802_0: i128 = 13;
        // D s_1802_1: read-var u#33226:u32
        let s_1802_1: u32 = fn_state.u_33226;
        // D s_1802_2: cast zx s_1802_1 -> bv
        let s_1802_2: Bits = Bits::new(s_1802_1 as u128, 32u16);
        // C s_1802_3: const #1u : u64
        let s_1802_3: u64 = 1;
        // D s_1802_4: bit-extract s_1802_2 s_1802_0 s_1802_3
        let s_1802_4: Bits = (Bits::new(
            ((s_1802_2) >> (s_1802_0)).value(),
            u16::try_from(s_1802_3).unwrap(),
        ));
        // D s_1802_5: cast reint s_1802_4 -> u8
        let s_1802_5: bool = ((s_1802_4.value()) != 0);
        // C s_1802_6: const #0s : i
        let s_1802_6: i128 = 0;
        // C s_1802_7: const #0u : u64
        let s_1802_7: u64 = 0;
        // D s_1802_8: cast zx s_1802_5 -> u64
        let s_1802_8: u64 = (s_1802_5 as u64);
        // C s_1802_9: const #1u : u64
        let s_1802_9: u64 = 1;
        // D s_1802_10: and s_1802_8 s_1802_9
        let s_1802_10: u64 = ((s_1802_8) & (s_1802_9));
        // D s_1802_11: cmp-eq s_1802_10 s_1802_9
        let s_1802_11: bool = ((s_1802_10) == (s_1802_9));
        // D s_1802_12: lsl s_1802_8 s_1802_6
        let s_1802_12: u64 = s_1802_8 << s_1802_6;
        // D s_1802_13: or s_1802_7 s_1802_12
        let s_1802_13: u64 = ((s_1802_7) | (s_1802_12));
        // D s_1802_14: cmpl s_1802_12
        let s_1802_14: u64 = !s_1802_12;
        // D s_1802_15: and s_1802_7 s_1802_14
        let s_1802_15: u64 = ((s_1802_7) & (s_1802_14));
        // D s_1802_16: select s_1802_11 s_1802_13 s_1802_15
        let s_1802_16: u64 = if s_1802_11 { s_1802_13 } else { s_1802_15 };
        // D s_1802_17: cast trunc s_1802_16 -> u8
        let s_1802_17: bool = ((s_1802_16) != 0);
        // D s_1802_18: cast zx s_1802_17 -> bv
        let s_1802_18: Bits = Bits::new(s_1802_17 as u128, 1u16);
        // C s_1802_19: const #1u : u8
        let s_1802_19: bool = true;
        // C s_1802_20: cast zx s_1802_19 -> bv
        let s_1802_20: Bits = Bits::new(s_1802_19 as u128, 1u16);
        // D s_1802_21: cmp-ne s_1802_18 s_1802_20
        let s_1802_21: bool = ((s_1802_18) != (s_1802_20));
        // D s_1802_22: write-var gs#408172 <= s_1802_21
        fn_state.gs_408172 = s_1802_21;
        // N s_1802_23: jump b1803
        return block_1803(state, tracer, fn_state);
    }
    fn block_1803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1803_0: read-var gs#408172:u8
        let s_1803_0: bool = fn_state.gs_408172;
        // N s_1803_1: branch s_1803_0 b1823 b1804
        if s_1803_0 {
            return block_1823(state, tracer, fn_state);
        } else {
            return block_1804(state, tracer, fn_state);
        };
    }
    fn block_1804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1804_0: const #14s : i
        let s_1804_0: i128 = 14;
        // D s_1804_1: read-var u#33226:u32
        let s_1804_1: u32 = fn_state.u_33226;
        // D s_1804_2: cast zx s_1804_1 -> bv
        let s_1804_2: Bits = Bits::new(s_1804_1 as u128, 32u16);
        // C s_1804_3: const #1u : u64
        let s_1804_3: u64 = 1;
        // D s_1804_4: bit-extract s_1804_2 s_1804_0 s_1804_3
        let s_1804_4: Bits = (Bits::new(
            ((s_1804_2) >> (s_1804_0)).value(),
            u16::try_from(s_1804_3).unwrap(),
        ));
        // D s_1804_5: cast reint s_1804_4 -> u8
        let s_1804_5: bool = ((s_1804_4.value()) != 0);
        // C s_1804_6: const #0s : i
        let s_1804_6: i128 = 0;
        // C s_1804_7: const #0u : u64
        let s_1804_7: u64 = 0;
        // D s_1804_8: cast zx s_1804_5 -> u64
        let s_1804_8: u64 = (s_1804_5 as u64);
        // C s_1804_9: const #1u : u64
        let s_1804_9: u64 = 1;
        // D s_1804_10: and s_1804_8 s_1804_9
        let s_1804_10: u64 = ((s_1804_8) & (s_1804_9));
        // D s_1804_11: cmp-eq s_1804_10 s_1804_9
        let s_1804_11: bool = ((s_1804_10) == (s_1804_9));
        // D s_1804_12: lsl s_1804_8 s_1804_6
        let s_1804_12: u64 = s_1804_8 << s_1804_6;
        // D s_1804_13: or s_1804_7 s_1804_12
        let s_1804_13: u64 = ((s_1804_7) | (s_1804_12));
        // D s_1804_14: cmpl s_1804_12
        let s_1804_14: u64 = !s_1804_12;
        // D s_1804_15: and s_1804_7 s_1804_14
        let s_1804_15: u64 = ((s_1804_7) & (s_1804_14));
        // D s_1804_16: select s_1804_11 s_1804_13 s_1804_15
        let s_1804_16: u64 = if s_1804_11 { s_1804_13 } else { s_1804_15 };
        // D s_1804_17: cast trunc s_1804_16 -> u8
        let s_1804_17: bool = ((s_1804_16) != 0);
        // D s_1804_18: cast zx s_1804_17 -> bv
        let s_1804_18: Bits = Bits::new(s_1804_17 as u128, 1u16);
        // C s_1804_19: const #1u : u8
        let s_1804_19: bool = true;
        // C s_1804_20: cast zx s_1804_19 -> bv
        let s_1804_20: Bits = Bits::new(s_1804_19 as u128, 1u16);
        // D s_1804_21: cmp-ne s_1804_18 s_1804_20
        let s_1804_21: bool = ((s_1804_18) != (s_1804_20));
        // D s_1804_22: write-var gs#408175 <= s_1804_21
        fn_state.gs_408175 = s_1804_21;
        // N s_1804_23: jump b1805
        return block_1805(state, tracer, fn_state);
    }
    fn block_1805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1805_0: read-var gs#408175:u8
        let s_1805_0: bool = fn_state.gs_408175;
        // N s_1805_1: branch s_1805_0 b1822 b1806
        if s_1805_0 {
            return block_1822(state, tracer, fn_state);
        } else {
            return block_1806(state, tracer, fn_state);
        };
    }
    fn block_1806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1806_0: const #15s : i
        let s_1806_0: i128 = 15;
        // D s_1806_1: read-var u#33226:u32
        let s_1806_1: u32 = fn_state.u_33226;
        // D s_1806_2: cast zx s_1806_1 -> bv
        let s_1806_2: Bits = Bits::new(s_1806_1 as u128, 32u16);
        // C s_1806_3: const #1u : u64
        let s_1806_3: u64 = 1;
        // D s_1806_4: bit-extract s_1806_2 s_1806_0 s_1806_3
        let s_1806_4: Bits = (Bits::new(
            ((s_1806_2) >> (s_1806_0)).value(),
            u16::try_from(s_1806_3).unwrap(),
        ));
        // D s_1806_5: cast reint s_1806_4 -> u8
        let s_1806_5: bool = ((s_1806_4.value()) != 0);
        // C s_1806_6: const #0s : i
        let s_1806_6: i128 = 0;
        // C s_1806_7: const #0u : u64
        let s_1806_7: u64 = 0;
        // D s_1806_8: cast zx s_1806_5 -> u64
        let s_1806_8: u64 = (s_1806_5 as u64);
        // C s_1806_9: const #1u : u64
        let s_1806_9: u64 = 1;
        // D s_1806_10: and s_1806_8 s_1806_9
        let s_1806_10: u64 = ((s_1806_8) & (s_1806_9));
        // D s_1806_11: cmp-eq s_1806_10 s_1806_9
        let s_1806_11: bool = ((s_1806_10) == (s_1806_9));
        // D s_1806_12: lsl s_1806_8 s_1806_6
        let s_1806_12: u64 = s_1806_8 << s_1806_6;
        // D s_1806_13: or s_1806_7 s_1806_12
        let s_1806_13: u64 = ((s_1806_7) | (s_1806_12));
        // D s_1806_14: cmpl s_1806_12
        let s_1806_14: u64 = !s_1806_12;
        // D s_1806_15: and s_1806_7 s_1806_14
        let s_1806_15: u64 = ((s_1806_7) & (s_1806_14));
        // D s_1806_16: select s_1806_11 s_1806_13 s_1806_15
        let s_1806_16: u64 = if s_1806_11 { s_1806_13 } else { s_1806_15 };
        // D s_1806_17: cast trunc s_1806_16 -> u8
        let s_1806_17: bool = ((s_1806_16) != 0);
        // D s_1806_18: cast zx s_1806_17 -> bv
        let s_1806_18: Bits = Bits::new(s_1806_17 as u128, 1u16);
        // C s_1806_19: const #1u : u8
        let s_1806_19: bool = true;
        // C s_1806_20: cast zx s_1806_19 -> bv
        let s_1806_20: Bits = Bits::new(s_1806_19 as u128, 1u16);
        // D s_1806_21: cmp-ne s_1806_18 s_1806_20
        let s_1806_21: bool = ((s_1806_18) != (s_1806_20));
        // D s_1806_22: write-var gs#408178 <= s_1806_21
        fn_state.gs_408178 = s_1806_21;
        // N s_1806_23: jump b1807
        return block_1807(state, tracer, fn_state);
    }
    fn block_1807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1807_0: read-var gs#408178:u8
        let s_1807_0: bool = fn_state.gs_408178;
        // N s_1807_1: branch s_1807_0 b1821 b1808
        if s_1807_0 {
            return block_1821(state, tracer, fn_state);
        } else {
            return block_1808(state, tracer, fn_state);
        };
    }
    fn block_1808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1808_0: const #8s : i
        let s_1808_0: i128 = 8;
        // D s_1808_1: read-var u#33226:u32
        let s_1808_1: u32 = fn_state.u_33226;
        // D s_1808_2: cast zx s_1808_1 -> bv
        let s_1808_2: Bits = Bits::new(s_1808_1 as u128, 32u16);
        // C s_1808_3: const #1u : u64
        let s_1808_3: u64 = 1;
        // D s_1808_4: bit-extract s_1808_2 s_1808_0 s_1808_3
        let s_1808_4: Bits = (Bits::new(
            ((s_1808_2) >> (s_1808_0)).value(),
            u16::try_from(s_1808_3).unwrap(),
        ));
        // D s_1808_5: cast reint s_1808_4 -> u8
        let s_1808_5: bool = ((s_1808_4.value()) != 0);
        // C s_1808_6: const #0s : i
        let s_1808_6: i128 = 0;
        // C s_1808_7: const #0u : u64
        let s_1808_7: u64 = 0;
        // D s_1808_8: cast zx s_1808_5 -> u64
        let s_1808_8: u64 = (s_1808_5 as u64);
        // C s_1808_9: const #1u : u64
        let s_1808_9: u64 = 1;
        // D s_1808_10: and s_1808_8 s_1808_9
        let s_1808_10: u64 = ((s_1808_8) & (s_1808_9));
        // D s_1808_11: cmp-eq s_1808_10 s_1808_9
        let s_1808_11: bool = ((s_1808_10) == (s_1808_9));
        // D s_1808_12: lsl s_1808_8 s_1808_6
        let s_1808_12: u64 = s_1808_8 << s_1808_6;
        // D s_1808_13: or s_1808_7 s_1808_12
        let s_1808_13: u64 = ((s_1808_7) | (s_1808_12));
        // D s_1808_14: cmpl s_1808_12
        let s_1808_14: u64 = !s_1808_12;
        // D s_1808_15: and s_1808_7 s_1808_14
        let s_1808_15: u64 = ((s_1808_7) & (s_1808_14));
        // D s_1808_16: select s_1808_11 s_1808_13 s_1808_15
        let s_1808_16: u64 = if s_1808_11 { s_1808_13 } else { s_1808_15 };
        // D s_1808_17: cast trunc s_1808_16 -> u8
        let s_1808_17: bool = ((s_1808_16) != 0);
        // D s_1808_18: cast zx s_1808_17 -> bv
        let s_1808_18: Bits = Bits::new(s_1808_17 as u128, 1u16);
        // C s_1808_19: const #0u : u8
        let s_1808_19: bool = false;
        // C s_1808_20: cast zx s_1808_19 -> bv
        let s_1808_20: Bits = Bits::new(s_1808_19 as u128, 1u16);
        // D s_1808_21: cmp-ne s_1808_18 s_1808_20
        let s_1808_21: bool = ((s_1808_18) != (s_1808_20));
        // D s_1808_22: write-var gs#408181 <= s_1808_21
        fn_state.gs_408181 = s_1808_21;
        // N s_1808_23: jump b1809
        return block_1809(state, tracer, fn_state);
    }
    fn block_1809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1809_0: read-var gs#408181:u8
        let s_1809_0: bool = fn_state.gs_408181;
        // N s_1809_1: branch s_1809_0 b1820 b1810
        if s_1809_0 {
            return block_1820(state, tracer, fn_state);
        } else {
            return block_1810(state, tracer, fn_state);
        };
    }
    fn block_1810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1810_0: const #9s : i
        let s_1810_0: i128 = 9;
        // D s_1810_1: read-var u#33226:u32
        let s_1810_1: u32 = fn_state.u_33226;
        // D s_1810_2: cast zx s_1810_1 -> bv
        let s_1810_2: Bits = Bits::new(s_1810_1 as u128, 32u16);
        // C s_1810_3: const #1u : u64
        let s_1810_3: u64 = 1;
        // D s_1810_4: bit-extract s_1810_2 s_1810_0 s_1810_3
        let s_1810_4: Bits = (Bits::new(
            ((s_1810_2) >> (s_1810_0)).value(),
            u16::try_from(s_1810_3).unwrap(),
        ));
        // D s_1810_5: cast reint s_1810_4 -> u8
        let s_1810_5: bool = ((s_1810_4.value()) != 0);
        // C s_1810_6: const #0s : i
        let s_1810_6: i128 = 0;
        // C s_1810_7: const #0u : u64
        let s_1810_7: u64 = 0;
        // D s_1810_8: cast zx s_1810_5 -> u64
        let s_1810_8: u64 = (s_1810_5 as u64);
        // C s_1810_9: const #1u : u64
        let s_1810_9: u64 = 1;
        // D s_1810_10: and s_1810_8 s_1810_9
        let s_1810_10: u64 = ((s_1810_8) & (s_1810_9));
        // D s_1810_11: cmp-eq s_1810_10 s_1810_9
        let s_1810_11: bool = ((s_1810_10) == (s_1810_9));
        // D s_1810_12: lsl s_1810_8 s_1810_6
        let s_1810_12: u64 = s_1810_8 << s_1810_6;
        // D s_1810_13: or s_1810_7 s_1810_12
        let s_1810_13: u64 = ((s_1810_7) | (s_1810_12));
        // D s_1810_14: cmpl s_1810_12
        let s_1810_14: u64 = !s_1810_12;
        // D s_1810_15: and s_1810_7 s_1810_14
        let s_1810_15: u64 = ((s_1810_7) & (s_1810_14));
        // D s_1810_16: select s_1810_11 s_1810_13 s_1810_15
        let s_1810_16: u64 = if s_1810_11 { s_1810_13 } else { s_1810_15 };
        // D s_1810_17: cast trunc s_1810_16 -> u8
        let s_1810_17: bool = ((s_1810_16) != 0);
        // D s_1810_18: cast zx s_1810_17 -> bv
        let s_1810_18: Bits = Bits::new(s_1810_17 as u128, 1u16);
        // C s_1810_19: const #0u : u8
        let s_1810_19: bool = false;
        // C s_1810_20: cast zx s_1810_19 -> bv
        let s_1810_20: Bits = Bits::new(s_1810_19 as u128, 1u16);
        // D s_1810_21: cmp-ne s_1810_18 s_1810_20
        let s_1810_21: bool = ((s_1810_18) != (s_1810_20));
        // D s_1810_22: write-var gs#408184 <= s_1810_21
        fn_state.gs_408184 = s_1810_21;
        // N s_1810_23: jump b1811
        return block_1811(state, tracer, fn_state);
    }
    fn block_1811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1811_0: read-var gs#408184:u8
        let s_1811_0: bool = fn_state.gs_408184;
        // N s_1811_1: branch s_1811_0 b1819 b1812
        if s_1811_0 {
            return block_1819(state, tracer, fn_state);
        } else {
            return block_1812(state, tracer, fn_state);
        };
    }
    fn block_1812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1812_0: const #10s : i
        let s_1812_0: i128 = 10;
        // D s_1812_1: read-var u#33226:u32
        let s_1812_1: u32 = fn_state.u_33226;
        // D s_1812_2: cast zx s_1812_1 -> bv
        let s_1812_2: Bits = Bits::new(s_1812_1 as u128, 32u16);
        // C s_1812_3: const #1u : u64
        let s_1812_3: u64 = 1;
        // D s_1812_4: bit-extract s_1812_2 s_1812_0 s_1812_3
        let s_1812_4: Bits = (Bits::new(
            ((s_1812_2) >> (s_1812_0)).value(),
            u16::try_from(s_1812_3).unwrap(),
        ));
        // D s_1812_5: cast reint s_1812_4 -> u8
        let s_1812_5: bool = ((s_1812_4.value()) != 0);
        // C s_1812_6: const #0s : i
        let s_1812_6: i128 = 0;
        // C s_1812_7: const #0u : u64
        let s_1812_7: u64 = 0;
        // D s_1812_8: cast zx s_1812_5 -> u64
        let s_1812_8: u64 = (s_1812_5 as u64);
        // C s_1812_9: const #1u : u64
        let s_1812_9: u64 = 1;
        // D s_1812_10: and s_1812_8 s_1812_9
        let s_1812_10: u64 = ((s_1812_8) & (s_1812_9));
        // D s_1812_11: cmp-eq s_1812_10 s_1812_9
        let s_1812_11: bool = ((s_1812_10) == (s_1812_9));
        // D s_1812_12: lsl s_1812_8 s_1812_6
        let s_1812_12: u64 = s_1812_8 << s_1812_6;
        // D s_1812_13: or s_1812_7 s_1812_12
        let s_1812_13: u64 = ((s_1812_7) | (s_1812_12));
        // D s_1812_14: cmpl s_1812_12
        let s_1812_14: u64 = !s_1812_12;
        // D s_1812_15: and s_1812_7 s_1812_14
        let s_1812_15: u64 = ((s_1812_7) & (s_1812_14));
        // D s_1812_16: select s_1812_11 s_1812_13 s_1812_15
        let s_1812_16: u64 = if s_1812_11 { s_1812_13 } else { s_1812_15 };
        // D s_1812_17: cast trunc s_1812_16 -> u8
        let s_1812_17: bool = ((s_1812_16) != 0);
        // D s_1812_18: cast zx s_1812_17 -> bv
        let s_1812_18: Bits = Bits::new(s_1812_17 as u128, 1u16);
        // C s_1812_19: const #0u : u8
        let s_1812_19: bool = false;
        // C s_1812_20: cast zx s_1812_19 -> bv
        let s_1812_20: Bits = Bits::new(s_1812_19 as u128, 1u16);
        // D s_1812_21: cmp-ne s_1812_18 s_1812_20
        let s_1812_21: bool = ((s_1812_18) != (s_1812_20));
        // D s_1812_22: write-var gs#408187 <= s_1812_21
        fn_state.gs_408187 = s_1812_21;
        // N s_1812_23: jump b1813
        return block_1813(state, tracer, fn_state);
    }
    fn block_1813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1813_0: read-var gs#408187:u8
        let s_1813_0: bool = fn_state.gs_408187;
        // N s_1813_1: branch s_1813_0 b1818 b1814
        if s_1813_0 {
            return block_1818(state, tracer, fn_state);
        } else {
            return block_1814(state, tracer, fn_state);
        };
    }
    fn block_1814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1814_0: const #11s : i
        let s_1814_0: i128 = 11;
        // D s_1814_1: read-var u#33226:u32
        let s_1814_1: u32 = fn_state.u_33226;
        // D s_1814_2: cast zx s_1814_1 -> bv
        let s_1814_2: Bits = Bits::new(s_1814_1 as u128, 32u16);
        // C s_1814_3: const #1u : u64
        let s_1814_3: u64 = 1;
        // D s_1814_4: bit-extract s_1814_2 s_1814_0 s_1814_3
        let s_1814_4: Bits = (Bits::new(
            ((s_1814_2) >> (s_1814_0)).value(),
            u16::try_from(s_1814_3).unwrap(),
        ));
        // D s_1814_5: cast reint s_1814_4 -> u8
        let s_1814_5: bool = ((s_1814_4.value()) != 0);
        // C s_1814_6: const #0s : i
        let s_1814_6: i128 = 0;
        // C s_1814_7: const #0u : u64
        let s_1814_7: u64 = 0;
        // D s_1814_8: cast zx s_1814_5 -> u64
        let s_1814_8: u64 = (s_1814_5 as u64);
        // C s_1814_9: const #1u : u64
        let s_1814_9: u64 = 1;
        // D s_1814_10: and s_1814_8 s_1814_9
        let s_1814_10: u64 = ((s_1814_8) & (s_1814_9));
        // D s_1814_11: cmp-eq s_1814_10 s_1814_9
        let s_1814_11: bool = ((s_1814_10) == (s_1814_9));
        // D s_1814_12: lsl s_1814_8 s_1814_6
        let s_1814_12: u64 = s_1814_8 << s_1814_6;
        // D s_1814_13: or s_1814_7 s_1814_12
        let s_1814_13: u64 = ((s_1814_7) | (s_1814_12));
        // D s_1814_14: cmpl s_1814_12
        let s_1814_14: u64 = !s_1814_12;
        // D s_1814_15: and s_1814_7 s_1814_14
        let s_1814_15: u64 = ((s_1814_7) & (s_1814_14));
        // D s_1814_16: select s_1814_11 s_1814_13 s_1814_15
        let s_1814_16: u64 = if s_1814_11 { s_1814_13 } else { s_1814_15 };
        // D s_1814_17: cast trunc s_1814_16 -> u8
        let s_1814_17: bool = ((s_1814_16) != 0);
        // D s_1814_18: cast zx s_1814_17 -> bv
        let s_1814_18: Bits = Bits::new(s_1814_17 as u128, 1u16);
        // C s_1814_19: const #0u : u8
        let s_1814_19: bool = false;
        // C s_1814_20: cast zx s_1814_19 -> bv
        let s_1814_20: Bits = Bits::new(s_1814_19 as u128, 1u16);
        // D s_1814_21: cmp-ne s_1814_18 s_1814_20
        let s_1814_21: bool = ((s_1814_18) != (s_1814_20));
        // D s_1814_22: write-var gs#408190 <= s_1814_21
        fn_state.gs_408190 = s_1814_21;
        // N s_1814_23: jump b1815
        return block_1815(state, tracer, fn_state);
    }
    fn block_1815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1815_0: read-var gs#408190:u8
        let s_1815_0: bool = fn_state.gs_408190;
        // N s_1815_1: branch s_1815_0 b1817 b1816
        if s_1815_0 {
            return block_1817(state, tracer, fn_state);
        } else {
            return block_1816(state, tracer, fn_state);
        };
    }
    fn block_1816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1816_0: read-var u#33227:u8
        let s_1816_0: u8 = fn_state.u_33227;
        // D s_1816_1: call decode_aarch32_instrs_SEVL_A1enc_A_txt(s_1816_0)
        let s_1816_1: () = decode_aarch32_instrs_SEVL_A1enc_A_txt(
            state,
            tracer,
            s_1816_0,
        );
        // N s_1816_2: return
        return;
    }
    fn block_1817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1817_0: panic
        panic!("{:?}", ());
        // N s_1817_1: return
        return;
    }
    fn block_1818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1818_0: const #1u : u8
        let s_1818_0: bool = true;
        // D s_1818_1: write-var gs#408190 <= s_1818_0
        fn_state.gs_408190 = s_1818_0;
        // N s_1818_2: jump b1815
        return block_1815(state, tracer, fn_state);
    }
    fn block_1819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1819_0: const #1u : u8
        let s_1819_0: bool = true;
        // D s_1819_1: write-var gs#408187 <= s_1819_0
        fn_state.gs_408187 = s_1819_0;
        // N s_1819_2: jump b1813
        return block_1813(state, tracer, fn_state);
    }
    fn block_1820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1820_0: const #1u : u8
        let s_1820_0: bool = true;
        // D s_1820_1: write-var gs#408184 <= s_1820_0
        fn_state.gs_408184 = s_1820_0;
        // N s_1820_2: jump b1811
        return block_1811(state, tracer, fn_state);
    }
    fn block_1821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1821_0: const #1u : u8
        let s_1821_0: bool = true;
        // D s_1821_1: write-var gs#408181 <= s_1821_0
        fn_state.gs_408181 = s_1821_0;
        // N s_1821_2: jump b1809
        return block_1809(state, tracer, fn_state);
    }
    fn block_1822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1822_0: const #1u : u8
        let s_1822_0: bool = true;
        // D s_1822_1: write-var gs#408178 <= s_1822_0
        fn_state.gs_408178 = s_1822_0;
        // N s_1822_2: jump b1807
        return block_1807(state, tracer, fn_state);
    }
    fn block_1823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1823_0: const #1u : u8
        let s_1823_0: bool = true;
        // D s_1823_1: write-var gs#408175 <= s_1823_0
        fn_state.gs_408175 = s_1823_0;
        // N s_1823_2: jump b1805
        return block_1805(state, tracer, fn_state);
    }
    fn block_1824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1824_0: const #1u : u8
        let s_1824_0: bool = true;
        // D s_1824_1: write-var gs#408172 <= s_1824_0
        fn_state.gs_408172 = s_1824_0;
        // N s_1824_2: jump b1803
        return block_1803(state, tracer, fn_state);
    }
    fn block_1825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1825_0: read-var merge#var.1:struct
        let s_1825_0: u32 = fn_state.merge_var._1;
        // D s_1825_1: write-var u#33229 <= s_1825_0
        fn_state.u_33229 = s_1825_0;
        // C s_1825_2: const #20s : i
        let s_1825_2: i128 = 20;
        // D s_1825_3: read-var u#33229:u32
        let s_1825_3: u32 = fn_state.u_33229;
        // D s_1825_4: cast zx s_1825_3 -> bv
        let s_1825_4: Bits = Bits::new(s_1825_3 as u128, 32u16);
        // C s_1825_5: const #1s : i64
        let s_1825_5: i64 = 1;
        // C s_1825_6: cast zx s_1825_5 -> i
        let s_1825_6: i128 = (i128::try_from(s_1825_5).unwrap());
        // C s_1825_7: const #7s : i
        let s_1825_7: i128 = 7;
        // C s_1825_8: add s_1825_7 s_1825_6
        let s_1825_8: i128 = (s_1825_7 + s_1825_6);
        // D s_1825_9: bit-extract s_1825_4 s_1825_2 s_1825_8
        let s_1825_9: Bits = (Bits::new(
            ((s_1825_4) >> (s_1825_2)).value(),
            u16::try_from(s_1825_8).unwrap(),
        ));
        // D s_1825_10: cast reint s_1825_9 -> u8
        let s_1825_10: u8 = (s_1825_9.value() as u8);
        // D s_1825_11: cast zx s_1825_10 -> bv
        let s_1825_11: Bits = Bits::new(s_1825_10 as u128, 8u16);
        // C s_1825_12: const #24u : u8
        let s_1825_12: u8 = 24;
        // C s_1825_13: cast zx s_1825_12 -> bv
        let s_1825_13: Bits = Bits::new(s_1825_12 as u128, 8u16);
        // D s_1825_14: cmp-eq s_1825_11 s_1825_13
        let s_1825_14: bool = ((s_1825_11) == (s_1825_13));
        // N s_1825_15: branch s_1825_14 b2097 b1826
        if s_1825_14 {
            return block_2097(state, tracer, fn_state);
        } else {
            return block_1826(state, tracer, fn_state);
        };
    }
    fn block_1826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1826_0: const #0u : u8
        let s_1826_0: bool = false;
        // D s_1826_1: write-var gs#408196 <= s_1826_0
        fn_state.gs_408196 = s_1826_0;
        // N s_1826_2: jump b1827
        return block_1827(state, tracer, fn_state);
    }
    fn block_1827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1827_0: read-var gs#408196:u8
        let s_1827_0: bool = fn_state.gs_408196;
        // N s_1827_1: branch s_1827_0 b2093 b1828
        if s_1827_0 {
            return block_2093(state, tracer, fn_state);
        } else {
            return block_1828(state, tracer, fn_state);
        };
    }
    fn block_1828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1828_0: const #0u : u8
        let s_1828_0: bool = false;
        // D s_1828_1: write-var gs#408201 <= s_1828_0
        fn_state.gs_408201 = s_1828_0;
        // N s_1828_2: jump b1829
        return block_1829(state, tracer, fn_state);
    }
    fn block_1829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1829_0: read-var gs#408201:u8
        let s_1829_0: bool = fn_state.gs_408201;
        // D s_1829_1: not s_1829_0
        let s_1829_1: bool = !s_1829_0;
        // N s_1829_2: branch s_1829_1 b1848 b1830
        if s_1829_1 {
            return block_1848(state, tracer, fn_state);
        } else {
            return block_1830(state, tracer, fn_state);
        };
    }
    fn block_1830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1830_0: const #3852s : i
        let s_1830_0: i128 = 3852;
        // C s_1830_1: const #14696u : u32
        let s_1830_1: u32 = 14696;
        // N s_1830_2: write-reg s_1830_1 <= s_1830_0
        let s_1830_2: () = {
            state.write_register::<i128>(s_1830_1 as isize, s_1830_0);
            tracer.write_register(s_1830_1 as isize, s_1830_0);
        };
        // C s_1830_3: const #28s : i
        let s_1830_3: i128 = 28;
        // C s_1830_4: const #4s : i
        let s_1830_4: i128 = 4;
        // D s_1830_5: read-var u#33229:u32
        let s_1830_5: u32 = fn_state.u_33229;
        // D s_1830_6: cast zx s_1830_5 -> bv
        let s_1830_6: Bits = Bits::new(s_1830_5 as u128, 32u16);
        // D s_1830_7: bit-extract s_1830_6 s_1830_3 s_1830_4
        let s_1830_7: Bits = (Bits::new(
            ((s_1830_6) >> (s_1830_3)).value(),
            u16::try_from(s_1830_4).unwrap(),
        ));
        // D s_1830_8: cast reint s_1830_7 -> u8
        let s_1830_8: u8 = (s_1830_7.value() as u8);
        // D s_1830_9: write-var u#33230 <= s_1830_8
        fn_state.u_33230 = s_1830_8;
        // C s_1830_10: const #16s : i
        let s_1830_10: i128 = 16;
        // C s_1830_11: const #4s : i
        let s_1830_11: i128 = 4;
        // D s_1830_12: read-var u#33229:u32
        let s_1830_12: u32 = fn_state.u_33229;
        // D s_1830_13: cast zx s_1830_12 -> bv
        let s_1830_13: Bits = Bits::new(s_1830_12 as u128, 32u16);
        // D s_1830_14: bit-extract s_1830_13 s_1830_10 s_1830_11
        let s_1830_14: Bits = (Bits::new(
            ((s_1830_13) >> (s_1830_10)).value(),
            u16::try_from(s_1830_11).unwrap(),
        ));
        // D s_1830_15: cast reint s_1830_14 -> u8
        let s_1830_15: u8 = (s_1830_14.value() as u8);
        // D s_1830_16: write-var u#33231 <= s_1830_15
        fn_state.u_33231 = s_1830_15;
        // C s_1830_17: const #0s : i
        let s_1830_17: i128 = 0;
        // C s_1830_18: const #4s : i
        let s_1830_18: i128 = 4;
        // D s_1830_19: read-var u#33229:u32
        let s_1830_19: u32 = fn_state.u_33229;
        // D s_1830_20: cast zx s_1830_19 -> bv
        let s_1830_20: Bits = Bits::new(s_1830_19 as u128, 32u16);
        // D s_1830_21: bit-extract s_1830_20 s_1830_17 s_1830_18
        let s_1830_21: Bits = (Bits::new(
            ((s_1830_20) >> (s_1830_17)).value(),
            u16::try_from(s_1830_18).unwrap(),
        ));
        // D s_1830_22: cast reint s_1830_21 -> u8
        let s_1830_22: u8 = (s_1830_21.value() as u8);
        // D s_1830_23: write-var u#33232 <= s_1830_22
        fn_state.u_33232 = s_1830_22;
        // C s_1830_24: const #12s : i
        let s_1830_24: i128 = 12;
        // D s_1830_25: read-var u#33229:u32
        let s_1830_25: u32 = fn_state.u_33229;
        // D s_1830_26: cast zx s_1830_25 -> bv
        let s_1830_26: Bits = Bits::new(s_1830_25 as u128, 32u16);
        // C s_1830_27: const #1u : u64
        let s_1830_27: u64 = 1;
        // D s_1830_28: bit-extract s_1830_26 s_1830_24 s_1830_27
        let s_1830_28: Bits = (Bits::new(
            ((s_1830_26) >> (s_1830_24)).value(),
            u16::try_from(s_1830_27).unwrap(),
        ));
        // D s_1830_29: cast reint s_1830_28 -> u8
        let s_1830_29: bool = ((s_1830_28.value()) != 0);
        // C s_1830_30: const #0s : i
        let s_1830_30: i128 = 0;
        // C s_1830_31: const #0u : u64
        let s_1830_31: u64 = 0;
        // D s_1830_32: cast zx s_1830_29 -> u64
        let s_1830_32: u64 = (s_1830_29 as u64);
        // C s_1830_33: const #1u : u64
        let s_1830_33: u64 = 1;
        // D s_1830_34: and s_1830_32 s_1830_33
        let s_1830_34: u64 = ((s_1830_32) & (s_1830_33));
        // D s_1830_35: cmp-eq s_1830_34 s_1830_33
        let s_1830_35: bool = ((s_1830_34) == (s_1830_33));
        // D s_1830_36: lsl s_1830_32 s_1830_30
        let s_1830_36: u64 = s_1830_32 << s_1830_30;
        // D s_1830_37: or s_1830_31 s_1830_36
        let s_1830_37: u64 = ((s_1830_31) | (s_1830_36));
        // D s_1830_38: cmpl s_1830_36
        let s_1830_38: u64 = !s_1830_36;
        // D s_1830_39: and s_1830_31 s_1830_38
        let s_1830_39: u64 = ((s_1830_31) & (s_1830_38));
        // D s_1830_40: select s_1830_35 s_1830_37 s_1830_39
        let s_1830_40: u64 = if s_1830_35 { s_1830_37 } else { s_1830_39 };
        // D s_1830_41: cast trunc s_1830_40 -> u8
        let s_1830_41: bool = ((s_1830_40) != 0);
        // D s_1830_42: cast zx s_1830_41 -> bv
        let s_1830_42: Bits = Bits::new(s_1830_41 as u128, 1u16);
        // C s_1830_43: const #1u : u8
        let s_1830_43: bool = true;
        // C s_1830_44: cast zx s_1830_43 -> bv
        let s_1830_44: Bits = Bits::new(s_1830_43 as u128, 1u16);
        // D s_1830_45: cmp-ne s_1830_42 s_1830_44
        let s_1830_45: bool = ((s_1830_42) != (s_1830_44));
        // N s_1830_46: branch s_1830_45 b1847 b1831
        if s_1830_45 {
            return block_1847(state, tracer, fn_state);
        } else {
            return block_1831(state, tracer, fn_state);
        };
    }
    fn block_1831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1831_0: const #13s : i
        let s_1831_0: i128 = 13;
        // D s_1831_1: read-var u#33229:u32
        let s_1831_1: u32 = fn_state.u_33229;
        // D s_1831_2: cast zx s_1831_1 -> bv
        let s_1831_2: Bits = Bits::new(s_1831_1 as u128, 32u16);
        // C s_1831_3: const #1u : u64
        let s_1831_3: u64 = 1;
        // D s_1831_4: bit-extract s_1831_2 s_1831_0 s_1831_3
        let s_1831_4: Bits = (Bits::new(
            ((s_1831_2) >> (s_1831_0)).value(),
            u16::try_from(s_1831_3).unwrap(),
        ));
        // D s_1831_5: cast reint s_1831_4 -> u8
        let s_1831_5: bool = ((s_1831_4.value()) != 0);
        // C s_1831_6: const #0s : i
        let s_1831_6: i128 = 0;
        // C s_1831_7: const #0u : u64
        let s_1831_7: u64 = 0;
        // D s_1831_8: cast zx s_1831_5 -> u64
        let s_1831_8: u64 = (s_1831_5 as u64);
        // C s_1831_9: const #1u : u64
        let s_1831_9: u64 = 1;
        // D s_1831_10: and s_1831_8 s_1831_9
        let s_1831_10: u64 = ((s_1831_8) & (s_1831_9));
        // D s_1831_11: cmp-eq s_1831_10 s_1831_9
        let s_1831_11: bool = ((s_1831_10) == (s_1831_9));
        // D s_1831_12: lsl s_1831_8 s_1831_6
        let s_1831_12: u64 = s_1831_8 << s_1831_6;
        // D s_1831_13: or s_1831_7 s_1831_12
        let s_1831_13: u64 = ((s_1831_7) | (s_1831_12));
        // D s_1831_14: cmpl s_1831_12
        let s_1831_14: u64 = !s_1831_12;
        // D s_1831_15: and s_1831_7 s_1831_14
        let s_1831_15: u64 = ((s_1831_7) & (s_1831_14));
        // D s_1831_16: select s_1831_11 s_1831_13 s_1831_15
        let s_1831_16: u64 = if s_1831_11 { s_1831_13 } else { s_1831_15 };
        // D s_1831_17: cast trunc s_1831_16 -> u8
        let s_1831_17: bool = ((s_1831_16) != 0);
        // D s_1831_18: cast zx s_1831_17 -> bv
        let s_1831_18: Bits = Bits::new(s_1831_17 as u128, 1u16);
        // C s_1831_19: const #1u : u8
        let s_1831_19: bool = true;
        // C s_1831_20: cast zx s_1831_19 -> bv
        let s_1831_20: Bits = Bits::new(s_1831_19 as u128, 1u16);
        // D s_1831_21: cmp-ne s_1831_18 s_1831_20
        let s_1831_21: bool = ((s_1831_18) != (s_1831_20));
        // D s_1831_22: write-var gs#408214 <= s_1831_21
        fn_state.gs_408214 = s_1831_21;
        // N s_1831_23: jump b1832
        return block_1832(state, tracer, fn_state);
    }
    fn block_1832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1832_0: read-var gs#408214:u8
        let s_1832_0: bool = fn_state.gs_408214;
        // N s_1832_1: branch s_1832_0 b1846 b1833
        if s_1832_0 {
            return block_1846(state, tracer, fn_state);
        } else {
            return block_1833(state, tracer, fn_state);
        };
    }
    fn block_1833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1833_0: const #14s : i
        let s_1833_0: i128 = 14;
        // D s_1833_1: read-var u#33229:u32
        let s_1833_1: u32 = fn_state.u_33229;
        // D s_1833_2: cast zx s_1833_1 -> bv
        let s_1833_2: Bits = Bits::new(s_1833_1 as u128, 32u16);
        // C s_1833_3: const #1u : u64
        let s_1833_3: u64 = 1;
        // D s_1833_4: bit-extract s_1833_2 s_1833_0 s_1833_3
        let s_1833_4: Bits = (Bits::new(
            ((s_1833_2) >> (s_1833_0)).value(),
            u16::try_from(s_1833_3).unwrap(),
        ));
        // D s_1833_5: cast reint s_1833_4 -> u8
        let s_1833_5: bool = ((s_1833_4.value()) != 0);
        // C s_1833_6: const #0s : i
        let s_1833_6: i128 = 0;
        // C s_1833_7: const #0u : u64
        let s_1833_7: u64 = 0;
        // D s_1833_8: cast zx s_1833_5 -> u64
        let s_1833_8: u64 = (s_1833_5 as u64);
        // C s_1833_9: const #1u : u64
        let s_1833_9: u64 = 1;
        // D s_1833_10: and s_1833_8 s_1833_9
        let s_1833_10: u64 = ((s_1833_8) & (s_1833_9));
        // D s_1833_11: cmp-eq s_1833_10 s_1833_9
        let s_1833_11: bool = ((s_1833_10) == (s_1833_9));
        // D s_1833_12: lsl s_1833_8 s_1833_6
        let s_1833_12: u64 = s_1833_8 << s_1833_6;
        // D s_1833_13: or s_1833_7 s_1833_12
        let s_1833_13: u64 = ((s_1833_7) | (s_1833_12));
        // D s_1833_14: cmpl s_1833_12
        let s_1833_14: u64 = !s_1833_12;
        // D s_1833_15: and s_1833_7 s_1833_14
        let s_1833_15: u64 = ((s_1833_7) & (s_1833_14));
        // D s_1833_16: select s_1833_11 s_1833_13 s_1833_15
        let s_1833_16: u64 = if s_1833_11 { s_1833_13 } else { s_1833_15 };
        // D s_1833_17: cast trunc s_1833_16 -> u8
        let s_1833_17: bool = ((s_1833_16) != 0);
        // D s_1833_18: cast zx s_1833_17 -> bv
        let s_1833_18: Bits = Bits::new(s_1833_17 as u128, 1u16);
        // C s_1833_19: const #1u : u8
        let s_1833_19: bool = true;
        // C s_1833_20: cast zx s_1833_19 -> bv
        let s_1833_20: Bits = Bits::new(s_1833_19 as u128, 1u16);
        // D s_1833_21: cmp-ne s_1833_18 s_1833_20
        let s_1833_21: bool = ((s_1833_18) != (s_1833_20));
        // D s_1833_22: write-var gs#408217 <= s_1833_21
        fn_state.gs_408217 = s_1833_21;
        // N s_1833_23: jump b1834
        return block_1834(state, tracer, fn_state);
    }
    fn block_1834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1834_0: read-var gs#408217:u8
        let s_1834_0: bool = fn_state.gs_408217;
        // N s_1834_1: branch s_1834_0 b1845 b1835
        if s_1834_0 {
            return block_1845(state, tracer, fn_state);
        } else {
            return block_1835(state, tracer, fn_state);
        };
    }
    fn block_1835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1835_0: const #15s : i
        let s_1835_0: i128 = 15;
        // D s_1835_1: read-var u#33229:u32
        let s_1835_1: u32 = fn_state.u_33229;
        // D s_1835_2: cast zx s_1835_1 -> bv
        let s_1835_2: Bits = Bits::new(s_1835_1 as u128, 32u16);
        // C s_1835_3: const #1u : u64
        let s_1835_3: u64 = 1;
        // D s_1835_4: bit-extract s_1835_2 s_1835_0 s_1835_3
        let s_1835_4: Bits = (Bits::new(
            ((s_1835_2) >> (s_1835_0)).value(),
            u16::try_from(s_1835_3).unwrap(),
        ));
        // D s_1835_5: cast reint s_1835_4 -> u8
        let s_1835_5: bool = ((s_1835_4.value()) != 0);
        // C s_1835_6: const #0s : i
        let s_1835_6: i128 = 0;
        // C s_1835_7: const #0u : u64
        let s_1835_7: u64 = 0;
        // D s_1835_8: cast zx s_1835_5 -> u64
        let s_1835_8: u64 = (s_1835_5 as u64);
        // C s_1835_9: const #1u : u64
        let s_1835_9: u64 = 1;
        // D s_1835_10: and s_1835_8 s_1835_9
        let s_1835_10: u64 = ((s_1835_8) & (s_1835_9));
        // D s_1835_11: cmp-eq s_1835_10 s_1835_9
        let s_1835_11: bool = ((s_1835_10) == (s_1835_9));
        // D s_1835_12: lsl s_1835_8 s_1835_6
        let s_1835_12: u64 = s_1835_8 << s_1835_6;
        // D s_1835_13: or s_1835_7 s_1835_12
        let s_1835_13: u64 = ((s_1835_7) | (s_1835_12));
        // D s_1835_14: cmpl s_1835_12
        let s_1835_14: u64 = !s_1835_12;
        // D s_1835_15: and s_1835_7 s_1835_14
        let s_1835_15: u64 = ((s_1835_7) & (s_1835_14));
        // D s_1835_16: select s_1835_11 s_1835_13 s_1835_15
        let s_1835_16: u64 = if s_1835_11 { s_1835_13 } else { s_1835_15 };
        // D s_1835_17: cast trunc s_1835_16 -> u8
        let s_1835_17: bool = ((s_1835_16) != 0);
        // D s_1835_18: cast zx s_1835_17 -> bv
        let s_1835_18: Bits = Bits::new(s_1835_17 as u128, 1u16);
        // C s_1835_19: const #1u : u8
        let s_1835_19: bool = true;
        // C s_1835_20: cast zx s_1835_19 -> bv
        let s_1835_20: Bits = Bits::new(s_1835_19 as u128, 1u16);
        // D s_1835_21: cmp-ne s_1835_18 s_1835_20
        let s_1835_21: bool = ((s_1835_18) != (s_1835_20));
        // D s_1835_22: write-var gs#408220 <= s_1835_21
        fn_state.gs_408220 = s_1835_21;
        // N s_1835_23: jump b1836
        return block_1836(state, tracer, fn_state);
    }
    fn block_1836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1836_0: read-var gs#408220:u8
        let s_1836_0: bool = fn_state.gs_408220;
        // N s_1836_1: branch s_1836_0 b1844 b1837
        if s_1836_0 {
            return block_1844(state, tracer, fn_state);
        } else {
            return block_1837(state, tracer, fn_state);
        };
    }
    fn block_1837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1837_0: const #8s : i
        let s_1837_0: i128 = 8;
        // D s_1837_1: read-var u#33229:u32
        let s_1837_1: u32 = fn_state.u_33229;
        // D s_1837_2: cast zx s_1837_1 -> bv
        let s_1837_2: Bits = Bits::new(s_1837_1 as u128, 32u16);
        // C s_1837_3: const #1u : u64
        let s_1837_3: u64 = 1;
        // D s_1837_4: bit-extract s_1837_2 s_1837_0 s_1837_3
        let s_1837_4: Bits = (Bits::new(
            ((s_1837_2) >> (s_1837_0)).value(),
            u16::try_from(s_1837_3).unwrap(),
        ));
        // D s_1837_5: cast reint s_1837_4 -> u8
        let s_1837_5: bool = ((s_1837_4.value()) != 0);
        // C s_1837_6: const #0s : i
        let s_1837_6: i128 = 0;
        // C s_1837_7: const #0u : u64
        let s_1837_7: u64 = 0;
        // D s_1837_8: cast zx s_1837_5 -> u64
        let s_1837_8: u64 = (s_1837_5 as u64);
        // C s_1837_9: const #1u : u64
        let s_1837_9: u64 = 1;
        // D s_1837_10: and s_1837_8 s_1837_9
        let s_1837_10: u64 = ((s_1837_8) & (s_1837_9));
        // D s_1837_11: cmp-eq s_1837_10 s_1837_9
        let s_1837_11: bool = ((s_1837_10) == (s_1837_9));
        // D s_1837_12: lsl s_1837_8 s_1837_6
        let s_1837_12: u64 = s_1837_8 << s_1837_6;
        // D s_1837_13: or s_1837_7 s_1837_12
        let s_1837_13: u64 = ((s_1837_7) | (s_1837_12));
        // D s_1837_14: cmpl s_1837_12
        let s_1837_14: u64 = !s_1837_12;
        // D s_1837_15: and s_1837_7 s_1837_14
        let s_1837_15: u64 = ((s_1837_7) & (s_1837_14));
        // D s_1837_16: select s_1837_11 s_1837_13 s_1837_15
        let s_1837_16: u64 = if s_1837_11 { s_1837_13 } else { s_1837_15 };
        // D s_1837_17: cast trunc s_1837_16 -> u8
        let s_1837_17: bool = ((s_1837_16) != 0);
        // D s_1837_18: cast zx s_1837_17 -> bv
        let s_1837_18: Bits = Bits::new(s_1837_17 as u128, 1u16);
        // C s_1837_19: const #1u : u8
        let s_1837_19: bool = true;
        // C s_1837_20: cast zx s_1837_19 -> bv
        let s_1837_20: Bits = Bits::new(s_1837_19 as u128, 1u16);
        // D s_1837_21: cmp-ne s_1837_18 s_1837_20
        let s_1837_21: bool = ((s_1837_18) != (s_1837_20));
        // D s_1837_22: write-var gs#408223 <= s_1837_21
        fn_state.gs_408223 = s_1837_21;
        // N s_1837_23: jump b1838
        return block_1838(state, tracer, fn_state);
    }
    fn block_1838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1838_0: read-var gs#408223:u8
        let s_1838_0: bool = fn_state.gs_408223;
        // N s_1838_1: branch s_1838_0 b1843 b1839
        if s_1838_0 {
            return block_1843(state, tracer, fn_state);
        } else {
            return block_1839(state, tracer, fn_state);
        };
    }
    fn block_1839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1839_0: const #9s : i
        let s_1839_0: i128 = 9;
        // D s_1839_1: read-var u#33229:u32
        let s_1839_1: u32 = fn_state.u_33229;
        // D s_1839_2: cast zx s_1839_1 -> bv
        let s_1839_2: Bits = Bits::new(s_1839_1 as u128, 32u16);
        // C s_1839_3: const #1u : u64
        let s_1839_3: u64 = 1;
        // D s_1839_4: bit-extract s_1839_2 s_1839_0 s_1839_3
        let s_1839_4: Bits = (Bits::new(
            ((s_1839_2) >> (s_1839_0)).value(),
            u16::try_from(s_1839_3).unwrap(),
        ));
        // D s_1839_5: cast reint s_1839_4 -> u8
        let s_1839_5: bool = ((s_1839_4.value()) != 0);
        // C s_1839_6: const #0s : i
        let s_1839_6: i128 = 0;
        // C s_1839_7: const #0u : u64
        let s_1839_7: u64 = 0;
        // D s_1839_8: cast zx s_1839_5 -> u64
        let s_1839_8: u64 = (s_1839_5 as u64);
        // C s_1839_9: const #1u : u64
        let s_1839_9: u64 = 1;
        // D s_1839_10: and s_1839_8 s_1839_9
        let s_1839_10: u64 = ((s_1839_8) & (s_1839_9));
        // D s_1839_11: cmp-eq s_1839_10 s_1839_9
        let s_1839_11: bool = ((s_1839_10) == (s_1839_9));
        // D s_1839_12: lsl s_1839_8 s_1839_6
        let s_1839_12: u64 = s_1839_8 << s_1839_6;
        // D s_1839_13: or s_1839_7 s_1839_12
        let s_1839_13: u64 = ((s_1839_7) | (s_1839_12));
        // D s_1839_14: cmpl s_1839_12
        let s_1839_14: u64 = !s_1839_12;
        // D s_1839_15: and s_1839_7 s_1839_14
        let s_1839_15: u64 = ((s_1839_7) & (s_1839_14));
        // D s_1839_16: select s_1839_11 s_1839_13 s_1839_15
        let s_1839_16: u64 = if s_1839_11 { s_1839_13 } else { s_1839_15 };
        // D s_1839_17: cast trunc s_1839_16 -> u8
        let s_1839_17: bool = ((s_1839_16) != 0);
        // D s_1839_18: cast zx s_1839_17 -> bv
        let s_1839_18: Bits = Bits::new(s_1839_17 as u128, 1u16);
        // C s_1839_19: const #1u : u8
        let s_1839_19: bool = true;
        // C s_1839_20: cast zx s_1839_19 -> bv
        let s_1839_20: Bits = Bits::new(s_1839_19 as u128, 1u16);
        // D s_1839_21: cmp-ne s_1839_18 s_1839_20
        let s_1839_21: bool = ((s_1839_18) != (s_1839_20));
        // D s_1839_22: write-var gs#408226 <= s_1839_21
        fn_state.gs_408226 = s_1839_21;
        // N s_1839_23: jump b1840
        return block_1840(state, tracer, fn_state);
    }
    fn block_1840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1840_0: read-var gs#408226:u8
        let s_1840_0: bool = fn_state.gs_408226;
        // N s_1840_1: branch s_1840_0 b1842 b1841
        if s_1840_0 {
            return block_1842(state, tracer, fn_state);
        } else {
            return block_1841(state, tracer, fn_state);
        };
    }
    fn block_1841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1841_0: read-var u#33230:u8
        let s_1841_0: u8 = fn_state.u_33230;
        // D s_1841_1: read-var u#33231:u8
        let s_1841_1: u8 = fn_state.u_33231;
        // D s_1841_2: read-var u#33232:u8
        let s_1841_2: u8 = fn_state.u_33232;
        // D s_1841_3: call decode_aarch32_instrs_STL_A1enc_A_txt(s_1841_0, s_1841_1, s_1841_2)
        let s_1841_3: () = decode_aarch32_instrs_STL_A1enc_A_txt(
            state,
            tracer,
            s_1841_0,
            s_1841_1,
            s_1841_2,
        );
        // N s_1841_4: return
        return;
    }
    fn block_1842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1842_0: panic
        panic!("{:?}", ());
        // N s_1842_1: return
        return;
    }
    fn block_1843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1843_0: const #1u : u8
        let s_1843_0: bool = true;
        // D s_1843_1: write-var gs#408226 <= s_1843_0
        fn_state.gs_408226 = s_1843_0;
        // N s_1843_2: jump b1840
        return block_1840(state, tracer, fn_state);
    }
    fn block_1844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1844_0: const #1u : u8
        let s_1844_0: bool = true;
        // D s_1844_1: write-var gs#408223 <= s_1844_0
        fn_state.gs_408223 = s_1844_0;
        // N s_1844_2: jump b1838
        return block_1838(state, tracer, fn_state);
    }
    fn block_1845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1845_0: const #1u : u8
        let s_1845_0: bool = true;
        // D s_1845_1: write-var gs#408220 <= s_1845_0
        fn_state.gs_408220 = s_1845_0;
        // N s_1845_2: jump b1836
        return block_1836(state, tracer, fn_state);
    }
    fn block_1846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1846_0: const #1u : u8
        let s_1846_0: bool = true;
        // D s_1846_1: write-var gs#408217 <= s_1846_0
        fn_state.gs_408217 = s_1846_0;
        // N s_1846_2: jump b1834
        return block_1834(state, tracer, fn_state);
    }
    fn block_1847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1847_0: const #1u : u8
        let s_1847_0: bool = true;
        // D s_1847_1: write-var gs#408214 <= s_1847_0
        fn_state.gs_408214 = s_1847_0;
        // N s_1847_2: jump b1832
        return block_1832(state, tracer, fn_state);
    }
    fn block_1848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1848_0: read-var merge#var.1:struct
        let s_1848_0: u32 = fn_state.merge_var._1;
        // D s_1848_1: write-var u#33234 <= s_1848_0
        fn_state.u_33234 = s_1848_0;
        // C s_1848_2: const #20s : i
        let s_1848_2: i128 = 20;
        // D s_1848_3: read-var u#33234:u32
        let s_1848_3: u32 = fn_state.u_33234;
        // D s_1848_4: cast zx s_1848_3 -> bv
        let s_1848_4: Bits = Bits::new(s_1848_3 as u128, 32u16);
        // C s_1848_5: const #1s : i64
        let s_1848_5: i64 = 1;
        // C s_1848_6: cast zx s_1848_5 -> i
        let s_1848_6: i128 = (i128::try_from(s_1848_5).unwrap());
        // C s_1848_7: const #7s : i
        let s_1848_7: i128 = 7;
        // C s_1848_8: add s_1848_7 s_1848_6
        let s_1848_8: i128 = (s_1848_7 + s_1848_6);
        // D s_1848_9: bit-extract s_1848_4 s_1848_2 s_1848_8
        let s_1848_9: Bits = (Bits::new(
            ((s_1848_4) >> (s_1848_2)).value(),
            u16::try_from(s_1848_8).unwrap(),
        ));
        // D s_1848_10: cast reint s_1848_9 -> u8
        let s_1848_10: u8 = (s_1848_9.value() as u8);
        // D s_1848_11: cast zx s_1848_10 -> bv
        let s_1848_11: Bits = Bits::new(s_1848_10 as u128, 8u16);
        // C s_1848_12: const #28u : u8
        let s_1848_12: u8 = 28;
        // C s_1848_13: cast zx s_1848_12 -> bv
        let s_1848_13: Bits = Bits::new(s_1848_12 as u128, 8u16);
        // D s_1848_14: cmp-eq s_1848_11 s_1848_13
        let s_1848_14: bool = ((s_1848_11) == (s_1848_13));
        // N s_1848_15: branch s_1848_14 b2092 b1849
        if s_1848_14 {
            return block_2092(state, tracer, fn_state);
        } else {
            return block_1849(state, tracer, fn_state);
        };
    }
    fn block_1849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1849_0: const #0u : u8
        let s_1849_0: bool = false;
        // D s_1849_1: write-var gs#408232 <= s_1849_0
        fn_state.gs_408232 = s_1849_0;
        // N s_1849_2: jump b1850
        return block_1850(state, tracer, fn_state);
    }
    fn block_1850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1850_0: read-var gs#408232:u8
        let s_1850_0: bool = fn_state.gs_408232;
        // N s_1850_1: branch s_1850_0 b2088 b1851
        if s_1850_0 {
            return block_2088(state, tracer, fn_state);
        } else {
            return block_1851(state, tracer, fn_state);
        };
    }
    fn block_1851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1851_0: const #0u : u8
        let s_1851_0: bool = false;
        // D s_1851_1: write-var gs#408237 <= s_1851_0
        fn_state.gs_408237 = s_1851_0;
        // N s_1851_2: jump b1852
        return block_1852(state, tracer, fn_state);
    }
    fn block_1852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1852_0: read-var gs#408237:u8
        let s_1852_0: bool = fn_state.gs_408237;
        // D s_1852_1: not s_1852_0
        let s_1852_1: bool = !s_1852_0;
        // N s_1852_2: branch s_1852_1 b1871 b1853
        if s_1852_1 {
            return block_1871(state, tracer, fn_state);
        } else {
            return block_1853(state, tracer, fn_state);
        };
    }
    fn block_1853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1853_0: const #3854s : i
        let s_1853_0: i128 = 3854;
        // C s_1853_1: const #14696u : u32
        let s_1853_1: u32 = 14696;
        // N s_1853_2: write-reg s_1853_1 <= s_1853_0
        let s_1853_2: () = {
            state.write_register::<i128>(s_1853_1 as isize, s_1853_0);
            tracer.write_register(s_1853_1 as isize, s_1853_0);
        };
        // C s_1853_3: const #28s : i
        let s_1853_3: i128 = 28;
        // C s_1853_4: const #4s : i
        let s_1853_4: i128 = 4;
        // D s_1853_5: read-var u#33234:u32
        let s_1853_5: u32 = fn_state.u_33234;
        // D s_1853_6: cast zx s_1853_5 -> bv
        let s_1853_6: Bits = Bits::new(s_1853_5 as u128, 32u16);
        // D s_1853_7: bit-extract s_1853_6 s_1853_3 s_1853_4
        let s_1853_7: Bits = (Bits::new(
            ((s_1853_6) >> (s_1853_3)).value(),
            u16::try_from(s_1853_4).unwrap(),
        ));
        // D s_1853_8: cast reint s_1853_7 -> u8
        let s_1853_8: u8 = (s_1853_7.value() as u8);
        // D s_1853_9: write-var u#33235 <= s_1853_8
        fn_state.u_33235 = s_1853_8;
        // C s_1853_10: const #16s : i
        let s_1853_10: i128 = 16;
        // C s_1853_11: const #4s : i
        let s_1853_11: i128 = 4;
        // D s_1853_12: read-var u#33234:u32
        let s_1853_12: u32 = fn_state.u_33234;
        // D s_1853_13: cast zx s_1853_12 -> bv
        let s_1853_13: Bits = Bits::new(s_1853_12 as u128, 32u16);
        // D s_1853_14: bit-extract s_1853_13 s_1853_10 s_1853_11
        let s_1853_14: Bits = (Bits::new(
            ((s_1853_13) >> (s_1853_10)).value(),
            u16::try_from(s_1853_11).unwrap(),
        ));
        // D s_1853_15: cast reint s_1853_14 -> u8
        let s_1853_15: u8 = (s_1853_14.value() as u8);
        // D s_1853_16: write-var u#33236 <= s_1853_15
        fn_state.u_33236 = s_1853_15;
        // C s_1853_17: const #0s : i
        let s_1853_17: i128 = 0;
        // C s_1853_18: const #4s : i
        let s_1853_18: i128 = 4;
        // D s_1853_19: read-var u#33234:u32
        let s_1853_19: u32 = fn_state.u_33234;
        // D s_1853_20: cast zx s_1853_19 -> bv
        let s_1853_20: Bits = Bits::new(s_1853_19 as u128, 32u16);
        // D s_1853_21: bit-extract s_1853_20 s_1853_17 s_1853_18
        let s_1853_21: Bits = (Bits::new(
            ((s_1853_20) >> (s_1853_17)).value(),
            u16::try_from(s_1853_18).unwrap(),
        ));
        // D s_1853_22: cast reint s_1853_21 -> u8
        let s_1853_22: u8 = (s_1853_21.value() as u8);
        // D s_1853_23: write-var u#33237 <= s_1853_22
        fn_state.u_33237 = s_1853_22;
        // C s_1853_24: const #12s : i
        let s_1853_24: i128 = 12;
        // D s_1853_25: read-var u#33234:u32
        let s_1853_25: u32 = fn_state.u_33234;
        // D s_1853_26: cast zx s_1853_25 -> bv
        let s_1853_26: Bits = Bits::new(s_1853_25 as u128, 32u16);
        // C s_1853_27: const #1u : u64
        let s_1853_27: u64 = 1;
        // D s_1853_28: bit-extract s_1853_26 s_1853_24 s_1853_27
        let s_1853_28: Bits = (Bits::new(
            ((s_1853_26) >> (s_1853_24)).value(),
            u16::try_from(s_1853_27).unwrap(),
        ));
        // D s_1853_29: cast reint s_1853_28 -> u8
        let s_1853_29: bool = ((s_1853_28.value()) != 0);
        // C s_1853_30: const #0s : i
        let s_1853_30: i128 = 0;
        // C s_1853_31: const #0u : u64
        let s_1853_31: u64 = 0;
        // D s_1853_32: cast zx s_1853_29 -> u64
        let s_1853_32: u64 = (s_1853_29 as u64);
        // C s_1853_33: const #1u : u64
        let s_1853_33: u64 = 1;
        // D s_1853_34: and s_1853_32 s_1853_33
        let s_1853_34: u64 = ((s_1853_32) & (s_1853_33));
        // D s_1853_35: cmp-eq s_1853_34 s_1853_33
        let s_1853_35: bool = ((s_1853_34) == (s_1853_33));
        // D s_1853_36: lsl s_1853_32 s_1853_30
        let s_1853_36: u64 = s_1853_32 << s_1853_30;
        // D s_1853_37: or s_1853_31 s_1853_36
        let s_1853_37: u64 = ((s_1853_31) | (s_1853_36));
        // D s_1853_38: cmpl s_1853_36
        let s_1853_38: u64 = !s_1853_36;
        // D s_1853_39: and s_1853_31 s_1853_38
        let s_1853_39: u64 = ((s_1853_31) & (s_1853_38));
        // D s_1853_40: select s_1853_35 s_1853_37 s_1853_39
        let s_1853_40: u64 = if s_1853_35 { s_1853_37 } else { s_1853_39 };
        // D s_1853_41: cast trunc s_1853_40 -> u8
        let s_1853_41: bool = ((s_1853_40) != 0);
        // D s_1853_42: cast zx s_1853_41 -> bv
        let s_1853_42: Bits = Bits::new(s_1853_41 as u128, 1u16);
        // C s_1853_43: const #1u : u8
        let s_1853_43: bool = true;
        // C s_1853_44: cast zx s_1853_43 -> bv
        let s_1853_44: Bits = Bits::new(s_1853_43 as u128, 1u16);
        // D s_1853_45: cmp-ne s_1853_42 s_1853_44
        let s_1853_45: bool = ((s_1853_42) != (s_1853_44));
        // N s_1853_46: branch s_1853_45 b1870 b1854
        if s_1853_45 {
            return block_1870(state, tracer, fn_state);
        } else {
            return block_1854(state, tracer, fn_state);
        };
    }
    fn block_1854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1854_0: const #13s : i
        let s_1854_0: i128 = 13;
        // D s_1854_1: read-var u#33234:u32
        let s_1854_1: u32 = fn_state.u_33234;
        // D s_1854_2: cast zx s_1854_1 -> bv
        let s_1854_2: Bits = Bits::new(s_1854_1 as u128, 32u16);
        // C s_1854_3: const #1u : u64
        let s_1854_3: u64 = 1;
        // D s_1854_4: bit-extract s_1854_2 s_1854_0 s_1854_3
        let s_1854_4: Bits = (Bits::new(
            ((s_1854_2) >> (s_1854_0)).value(),
            u16::try_from(s_1854_3).unwrap(),
        ));
        // D s_1854_5: cast reint s_1854_4 -> u8
        let s_1854_5: bool = ((s_1854_4.value()) != 0);
        // C s_1854_6: const #0s : i
        let s_1854_6: i128 = 0;
        // C s_1854_7: const #0u : u64
        let s_1854_7: u64 = 0;
        // D s_1854_8: cast zx s_1854_5 -> u64
        let s_1854_8: u64 = (s_1854_5 as u64);
        // C s_1854_9: const #1u : u64
        let s_1854_9: u64 = 1;
        // D s_1854_10: and s_1854_8 s_1854_9
        let s_1854_10: u64 = ((s_1854_8) & (s_1854_9));
        // D s_1854_11: cmp-eq s_1854_10 s_1854_9
        let s_1854_11: bool = ((s_1854_10) == (s_1854_9));
        // D s_1854_12: lsl s_1854_8 s_1854_6
        let s_1854_12: u64 = s_1854_8 << s_1854_6;
        // D s_1854_13: or s_1854_7 s_1854_12
        let s_1854_13: u64 = ((s_1854_7) | (s_1854_12));
        // D s_1854_14: cmpl s_1854_12
        let s_1854_14: u64 = !s_1854_12;
        // D s_1854_15: and s_1854_7 s_1854_14
        let s_1854_15: u64 = ((s_1854_7) & (s_1854_14));
        // D s_1854_16: select s_1854_11 s_1854_13 s_1854_15
        let s_1854_16: u64 = if s_1854_11 { s_1854_13 } else { s_1854_15 };
        // D s_1854_17: cast trunc s_1854_16 -> u8
        let s_1854_17: bool = ((s_1854_16) != 0);
        // D s_1854_18: cast zx s_1854_17 -> bv
        let s_1854_18: Bits = Bits::new(s_1854_17 as u128, 1u16);
        // C s_1854_19: const #1u : u8
        let s_1854_19: bool = true;
        // C s_1854_20: cast zx s_1854_19 -> bv
        let s_1854_20: Bits = Bits::new(s_1854_19 as u128, 1u16);
        // D s_1854_21: cmp-ne s_1854_18 s_1854_20
        let s_1854_21: bool = ((s_1854_18) != (s_1854_20));
        // D s_1854_22: write-var gs#408250 <= s_1854_21
        fn_state.gs_408250 = s_1854_21;
        // N s_1854_23: jump b1855
        return block_1855(state, tracer, fn_state);
    }
    fn block_1855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1855_0: read-var gs#408250:u8
        let s_1855_0: bool = fn_state.gs_408250;
        // N s_1855_1: branch s_1855_0 b1869 b1856
        if s_1855_0 {
            return block_1869(state, tracer, fn_state);
        } else {
            return block_1856(state, tracer, fn_state);
        };
    }
    fn block_1856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1856_0: const #14s : i
        let s_1856_0: i128 = 14;
        // D s_1856_1: read-var u#33234:u32
        let s_1856_1: u32 = fn_state.u_33234;
        // D s_1856_2: cast zx s_1856_1 -> bv
        let s_1856_2: Bits = Bits::new(s_1856_1 as u128, 32u16);
        // C s_1856_3: const #1u : u64
        let s_1856_3: u64 = 1;
        // D s_1856_4: bit-extract s_1856_2 s_1856_0 s_1856_3
        let s_1856_4: Bits = (Bits::new(
            ((s_1856_2) >> (s_1856_0)).value(),
            u16::try_from(s_1856_3).unwrap(),
        ));
        // D s_1856_5: cast reint s_1856_4 -> u8
        let s_1856_5: bool = ((s_1856_4.value()) != 0);
        // C s_1856_6: const #0s : i
        let s_1856_6: i128 = 0;
        // C s_1856_7: const #0u : u64
        let s_1856_7: u64 = 0;
        // D s_1856_8: cast zx s_1856_5 -> u64
        let s_1856_8: u64 = (s_1856_5 as u64);
        // C s_1856_9: const #1u : u64
        let s_1856_9: u64 = 1;
        // D s_1856_10: and s_1856_8 s_1856_9
        let s_1856_10: u64 = ((s_1856_8) & (s_1856_9));
        // D s_1856_11: cmp-eq s_1856_10 s_1856_9
        let s_1856_11: bool = ((s_1856_10) == (s_1856_9));
        // D s_1856_12: lsl s_1856_8 s_1856_6
        let s_1856_12: u64 = s_1856_8 << s_1856_6;
        // D s_1856_13: or s_1856_7 s_1856_12
        let s_1856_13: u64 = ((s_1856_7) | (s_1856_12));
        // D s_1856_14: cmpl s_1856_12
        let s_1856_14: u64 = !s_1856_12;
        // D s_1856_15: and s_1856_7 s_1856_14
        let s_1856_15: u64 = ((s_1856_7) & (s_1856_14));
        // D s_1856_16: select s_1856_11 s_1856_13 s_1856_15
        let s_1856_16: u64 = if s_1856_11 { s_1856_13 } else { s_1856_15 };
        // D s_1856_17: cast trunc s_1856_16 -> u8
        let s_1856_17: bool = ((s_1856_16) != 0);
        // D s_1856_18: cast zx s_1856_17 -> bv
        let s_1856_18: Bits = Bits::new(s_1856_17 as u128, 1u16);
        // C s_1856_19: const #1u : u8
        let s_1856_19: bool = true;
        // C s_1856_20: cast zx s_1856_19 -> bv
        let s_1856_20: Bits = Bits::new(s_1856_19 as u128, 1u16);
        // D s_1856_21: cmp-ne s_1856_18 s_1856_20
        let s_1856_21: bool = ((s_1856_18) != (s_1856_20));
        // D s_1856_22: write-var gs#408253 <= s_1856_21
        fn_state.gs_408253 = s_1856_21;
        // N s_1856_23: jump b1857
        return block_1857(state, tracer, fn_state);
    }
    fn block_1857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1857_0: read-var gs#408253:u8
        let s_1857_0: bool = fn_state.gs_408253;
        // N s_1857_1: branch s_1857_0 b1868 b1858
        if s_1857_0 {
            return block_1868(state, tracer, fn_state);
        } else {
            return block_1858(state, tracer, fn_state);
        };
    }
    fn block_1858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1858_0: const #15s : i
        let s_1858_0: i128 = 15;
        // D s_1858_1: read-var u#33234:u32
        let s_1858_1: u32 = fn_state.u_33234;
        // D s_1858_2: cast zx s_1858_1 -> bv
        let s_1858_2: Bits = Bits::new(s_1858_1 as u128, 32u16);
        // C s_1858_3: const #1u : u64
        let s_1858_3: u64 = 1;
        // D s_1858_4: bit-extract s_1858_2 s_1858_0 s_1858_3
        let s_1858_4: Bits = (Bits::new(
            ((s_1858_2) >> (s_1858_0)).value(),
            u16::try_from(s_1858_3).unwrap(),
        ));
        // D s_1858_5: cast reint s_1858_4 -> u8
        let s_1858_5: bool = ((s_1858_4.value()) != 0);
        // C s_1858_6: const #0s : i
        let s_1858_6: i128 = 0;
        // C s_1858_7: const #0u : u64
        let s_1858_7: u64 = 0;
        // D s_1858_8: cast zx s_1858_5 -> u64
        let s_1858_8: u64 = (s_1858_5 as u64);
        // C s_1858_9: const #1u : u64
        let s_1858_9: u64 = 1;
        // D s_1858_10: and s_1858_8 s_1858_9
        let s_1858_10: u64 = ((s_1858_8) & (s_1858_9));
        // D s_1858_11: cmp-eq s_1858_10 s_1858_9
        let s_1858_11: bool = ((s_1858_10) == (s_1858_9));
        // D s_1858_12: lsl s_1858_8 s_1858_6
        let s_1858_12: u64 = s_1858_8 << s_1858_6;
        // D s_1858_13: or s_1858_7 s_1858_12
        let s_1858_13: u64 = ((s_1858_7) | (s_1858_12));
        // D s_1858_14: cmpl s_1858_12
        let s_1858_14: u64 = !s_1858_12;
        // D s_1858_15: and s_1858_7 s_1858_14
        let s_1858_15: u64 = ((s_1858_7) & (s_1858_14));
        // D s_1858_16: select s_1858_11 s_1858_13 s_1858_15
        let s_1858_16: u64 = if s_1858_11 { s_1858_13 } else { s_1858_15 };
        // D s_1858_17: cast trunc s_1858_16 -> u8
        let s_1858_17: bool = ((s_1858_16) != 0);
        // D s_1858_18: cast zx s_1858_17 -> bv
        let s_1858_18: Bits = Bits::new(s_1858_17 as u128, 1u16);
        // C s_1858_19: const #1u : u8
        let s_1858_19: bool = true;
        // C s_1858_20: cast zx s_1858_19 -> bv
        let s_1858_20: Bits = Bits::new(s_1858_19 as u128, 1u16);
        // D s_1858_21: cmp-ne s_1858_18 s_1858_20
        let s_1858_21: bool = ((s_1858_18) != (s_1858_20));
        // D s_1858_22: write-var gs#408256 <= s_1858_21
        fn_state.gs_408256 = s_1858_21;
        // N s_1858_23: jump b1859
        return block_1859(state, tracer, fn_state);
    }
    fn block_1859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1859_0: read-var gs#408256:u8
        let s_1859_0: bool = fn_state.gs_408256;
        // N s_1859_1: branch s_1859_0 b1867 b1860
        if s_1859_0 {
            return block_1867(state, tracer, fn_state);
        } else {
            return block_1860(state, tracer, fn_state);
        };
    }
    fn block_1860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1860_0: const #8s : i
        let s_1860_0: i128 = 8;
        // D s_1860_1: read-var u#33234:u32
        let s_1860_1: u32 = fn_state.u_33234;
        // D s_1860_2: cast zx s_1860_1 -> bv
        let s_1860_2: Bits = Bits::new(s_1860_1 as u128, 32u16);
        // C s_1860_3: const #1u : u64
        let s_1860_3: u64 = 1;
        // D s_1860_4: bit-extract s_1860_2 s_1860_0 s_1860_3
        let s_1860_4: Bits = (Bits::new(
            ((s_1860_2) >> (s_1860_0)).value(),
            u16::try_from(s_1860_3).unwrap(),
        ));
        // D s_1860_5: cast reint s_1860_4 -> u8
        let s_1860_5: bool = ((s_1860_4.value()) != 0);
        // C s_1860_6: const #0s : i
        let s_1860_6: i128 = 0;
        // C s_1860_7: const #0u : u64
        let s_1860_7: u64 = 0;
        // D s_1860_8: cast zx s_1860_5 -> u64
        let s_1860_8: u64 = (s_1860_5 as u64);
        // C s_1860_9: const #1u : u64
        let s_1860_9: u64 = 1;
        // D s_1860_10: and s_1860_8 s_1860_9
        let s_1860_10: u64 = ((s_1860_8) & (s_1860_9));
        // D s_1860_11: cmp-eq s_1860_10 s_1860_9
        let s_1860_11: bool = ((s_1860_10) == (s_1860_9));
        // D s_1860_12: lsl s_1860_8 s_1860_6
        let s_1860_12: u64 = s_1860_8 << s_1860_6;
        // D s_1860_13: or s_1860_7 s_1860_12
        let s_1860_13: u64 = ((s_1860_7) | (s_1860_12));
        // D s_1860_14: cmpl s_1860_12
        let s_1860_14: u64 = !s_1860_12;
        // D s_1860_15: and s_1860_7 s_1860_14
        let s_1860_15: u64 = ((s_1860_7) & (s_1860_14));
        // D s_1860_16: select s_1860_11 s_1860_13 s_1860_15
        let s_1860_16: u64 = if s_1860_11 { s_1860_13 } else { s_1860_15 };
        // D s_1860_17: cast trunc s_1860_16 -> u8
        let s_1860_17: bool = ((s_1860_16) != 0);
        // D s_1860_18: cast zx s_1860_17 -> bv
        let s_1860_18: Bits = Bits::new(s_1860_17 as u128, 1u16);
        // C s_1860_19: const #1u : u8
        let s_1860_19: bool = true;
        // C s_1860_20: cast zx s_1860_19 -> bv
        let s_1860_20: Bits = Bits::new(s_1860_19 as u128, 1u16);
        // D s_1860_21: cmp-ne s_1860_18 s_1860_20
        let s_1860_21: bool = ((s_1860_18) != (s_1860_20));
        // D s_1860_22: write-var gs#408259 <= s_1860_21
        fn_state.gs_408259 = s_1860_21;
        // N s_1860_23: jump b1861
        return block_1861(state, tracer, fn_state);
    }
    fn block_1861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1861_0: read-var gs#408259:u8
        let s_1861_0: bool = fn_state.gs_408259;
        // N s_1861_1: branch s_1861_0 b1866 b1862
        if s_1861_0 {
            return block_1866(state, tracer, fn_state);
        } else {
            return block_1862(state, tracer, fn_state);
        };
    }
    fn block_1862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1862_0: const #9s : i
        let s_1862_0: i128 = 9;
        // D s_1862_1: read-var u#33234:u32
        let s_1862_1: u32 = fn_state.u_33234;
        // D s_1862_2: cast zx s_1862_1 -> bv
        let s_1862_2: Bits = Bits::new(s_1862_1 as u128, 32u16);
        // C s_1862_3: const #1u : u64
        let s_1862_3: u64 = 1;
        // D s_1862_4: bit-extract s_1862_2 s_1862_0 s_1862_3
        let s_1862_4: Bits = (Bits::new(
            ((s_1862_2) >> (s_1862_0)).value(),
            u16::try_from(s_1862_3).unwrap(),
        ));
        // D s_1862_5: cast reint s_1862_4 -> u8
        let s_1862_5: bool = ((s_1862_4.value()) != 0);
        // C s_1862_6: const #0s : i
        let s_1862_6: i128 = 0;
        // C s_1862_7: const #0u : u64
        let s_1862_7: u64 = 0;
        // D s_1862_8: cast zx s_1862_5 -> u64
        let s_1862_8: u64 = (s_1862_5 as u64);
        // C s_1862_9: const #1u : u64
        let s_1862_9: u64 = 1;
        // D s_1862_10: and s_1862_8 s_1862_9
        let s_1862_10: u64 = ((s_1862_8) & (s_1862_9));
        // D s_1862_11: cmp-eq s_1862_10 s_1862_9
        let s_1862_11: bool = ((s_1862_10) == (s_1862_9));
        // D s_1862_12: lsl s_1862_8 s_1862_6
        let s_1862_12: u64 = s_1862_8 << s_1862_6;
        // D s_1862_13: or s_1862_7 s_1862_12
        let s_1862_13: u64 = ((s_1862_7) | (s_1862_12));
        // D s_1862_14: cmpl s_1862_12
        let s_1862_14: u64 = !s_1862_12;
        // D s_1862_15: and s_1862_7 s_1862_14
        let s_1862_15: u64 = ((s_1862_7) & (s_1862_14));
        // D s_1862_16: select s_1862_11 s_1862_13 s_1862_15
        let s_1862_16: u64 = if s_1862_11 { s_1862_13 } else { s_1862_15 };
        // D s_1862_17: cast trunc s_1862_16 -> u8
        let s_1862_17: bool = ((s_1862_16) != 0);
        // D s_1862_18: cast zx s_1862_17 -> bv
        let s_1862_18: Bits = Bits::new(s_1862_17 as u128, 1u16);
        // C s_1862_19: const #1u : u8
        let s_1862_19: bool = true;
        // C s_1862_20: cast zx s_1862_19 -> bv
        let s_1862_20: Bits = Bits::new(s_1862_19 as u128, 1u16);
        // D s_1862_21: cmp-ne s_1862_18 s_1862_20
        let s_1862_21: bool = ((s_1862_18) != (s_1862_20));
        // D s_1862_22: write-var gs#408262 <= s_1862_21
        fn_state.gs_408262 = s_1862_21;
        // N s_1862_23: jump b1863
        return block_1863(state, tracer, fn_state);
    }
    fn block_1863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1863_0: read-var gs#408262:u8
        let s_1863_0: bool = fn_state.gs_408262;
        // N s_1863_1: branch s_1863_0 b1865 b1864
        if s_1863_0 {
            return block_1865(state, tracer, fn_state);
        } else {
            return block_1864(state, tracer, fn_state);
        };
    }
    fn block_1864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1864_0: read-var u#33235:u8
        let s_1864_0: u8 = fn_state.u_33235;
        // D s_1864_1: read-var u#33236:u8
        let s_1864_1: u8 = fn_state.u_33236;
        // D s_1864_2: read-var u#33237:u8
        let s_1864_2: u8 = fn_state.u_33237;
        // D s_1864_3: call decode_aarch32_instrs_STLB_A1enc_A_txt(s_1864_0, s_1864_1, s_1864_2)
        let s_1864_3: () = decode_aarch32_instrs_STLB_A1enc_A_txt(
            state,
            tracer,
            s_1864_0,
            s_1864_1,
            s_1864_2,
        );
        // N s_1864_4: return
        return;
    }
    fn block_1865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1865_0: panic
        panic!("{:?}", ());
        // N s_1865_1: return
        return;
    }
    fn block_1866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1866_0: const #1u : u8
        let s_1866_0: bool = true;
        // D s_1866_1: write-var gs#408262 <= s_1866_0
        fn_state.gs_408262 = s_1866_0;
        // N s_1866_2: jump b1863
        return block_1863(state, tracer, fn_state);
    }
    fn block_1867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1867_0: const #1u : u8
        let s_1867_0: bool = true;
        // D s_1867_1: write-var gs#408259 <= s_1867_0
        fn_state.gs_408259 = s_1867_0;
        // N s_1867_2: jump b1861
        return block_1861(state, tracer, fn_state);
    }
    fn block_1868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1868_0: const #1u : u8
        let s_1868_0: bool = true;
        // D s_1868_1: write-var gs#408256 <= s_1868_0
        fn_state.gs_408256 = s_1868_0;
        // N s_1868_2: jump b1859
        return block_1859(state, tracer, fn_state);
    }
    fn block_1869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1869_0: const #1u : u8
        let s_1869_0: bool = true;
        // D s_1869_1: write-var gs#408253 <= s_1869_0
        fn_state.gs_408253 = s_1869_0;
        // N s_1869_2: jump b1857
        return block_1857(state, tracer, fn_state);
    }
    fn block_1870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1870_0: const #1u : u8
        let s_1870_0: bool = true;
        // D s_1870_1: write-var gs#408250 <= s_1870_0
        fn_state.gs_408250 = s_1870_0;
        // N s_1870_2: jump b1855
        return block_1855(state, tracer, fn_state);
    }
    fn block_1871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1871_0: read-var merge#var.1:struct
        let s_1871_0: u32 = fn_state.merge_var._1;
        // D s_1871_1: write-var u#33239 <= s_1871_0
        fn_state.u_33239 = s_1871_0;
        // C s_1871_2: const #20s : i
        let s_1871_2: i128 = 20;
        // D s_1871_3: read-var u#33239:u32
        let s_1871_3: u32 = fn_state.u_33239;
        // D s_1871_4: cast zx s_1871_3 -> bv
        let s_1871_4: Bits = Bits::new(s_1871_3 as u128, 32u16);
        // C s_1871_5: const #1s : i64
        let s_1871_5: i64 = 1;
        // C s_1871_6: cast zx s_1871_5 -> i
        let s_1871_6: i128 = (i128::try_from(s_1871_5).unwrap());
        // C s_1871_7: const #7s : i
        let s_1871_7: i128 = 7;
        // C s_1871_8: add s_1871_7 s_1871_6
        let s_1871_8: i128 = (s_1871_7 + s_1871_6);
        // D s_1871_9: bit-extract s_1871_4 s_1871_2 s_1871_8
        let s_1871_9: Bits = (Bits::new(
            ((s_1871_4) >> (s_1871_2)).value(),
            u16::try_from(s_1871_8).unwrap(),
        ));
        // D s_1871_10: cast reint s_1871_9 -> u8
        let s_1871_10: u8 = (s_1871_9.value() as u8);
        // D s_1871_11: cast zx s_1871_10 -> bv
        let s_1871_11: Bits = Bits::new(s_1871_10 as u128, 8u16);
        // C s_1871_12: const #24u : u8
        let s_1871_12: u8 = 24;
        // C s_1871_13: cast zx s_1871_12 -> bv
        let s_1871_13: Bits = Bits::new(s_1871_12 as u128, 8u16);
        // D s_1871_14: cmp-eq s_1871_11 s_1871_13
        let s_1871_14: bool = ((s_1871_11) == (s_1871_13));
        // N s_1871_15: branch s_1871_14 b2087 b1872
        if s_1871_14 {
            return block_2087(state, tracer, fn_state);
        } else {
            return block_1872(state, tracer, fn_state);
        };
    }
    fn block_1872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1872_0: const #0u : u8
        let s_1872_0: bool = false;
        // D s_1872_1: write-var gs#408268 <= s_1872_0
        fn_state.gs_408268 = s_1872_0;
        // N s_1872_2: jump b1873
        return block_1873(state, tracer, fn_state);
    }
    fn block_1873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1873_0: read-var gs#408268:u8
        let s_1873_0: bool = fn_state.gs_408268;
        // N s_1873_1: branch s_1873_0 b2083 b1874
        if s_1873_0 {
            return block_2083(state, tracer, fn_state);
        } else {
            return block_1874(state, tracer, fn_state);
        };
    }
    fn block_1874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1874_0: const #0u : u8
        let s_1874_0: bool = false;
        // D s_1874_1: write-var gs#408273 <= s_1874_0
        fn_state.gs_408273 = s_1874_0;
        // N s_1874_2: jump b1875
        return block_1875(state, tracer, fn_state);
    }
    fn block_1875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1875_0: read-var gs#408273:u8
        let s_1875_0: bool = fn_state.gs_408273;
        // D s_1875_1: not s_1875_0
        let s_1875_1: bool = !s_1875_0;
        // N s_1875_2: branch s_1875_1 b1882 b1876
        if s_1875_1 {
            return block_1882(state, tracer, fn_state);
        } else {
            return block_1876(state, tracer, fn_state);
        };
    }
    fn block_1876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1876_0: const #3856s : i
        let s_1876_0: i128 = 3856;
        // C s_1876_1: const #14696u : u32
        let s_1876_1: u32 = 14696;
        // N s_1876_2: write-reg s_1876_1 <= s_1876_0
        let s_1876_2: () = {
            state.write_register::<i128>(s_1876_1 as isize, s_1876_0);
            tracer.write_register(s_1876_1 as isize, s_1876_0);
        };
        // C s_1876_3: const #28s : i
        let s_1876_3: i128 = 28;
        // C s_1876_4: const #4s : i
        let s_1876_4: i128 = 4;
        // D s_1876_5: read-var u#33239:u32
        let s_1876_5: u32 = fn_state.u_33239;
        // D s_1876_6: cast zx s_1876_5 -> bv
        let s_1876_6: Bits = Bits::new(s_1876_5 as u128, 32u16);
        // D s_1876_7: bit-extract s_1876_6 s_1876_3 s_1876_4
        let s_1876_7: Bits = (Bits::new(
            ((s_1876_6) >> (s_1876_3)).value(),
            u16::try_from(s_1876_4).unwrap(),
        ));
        // D s_1876_8: cast reint s_1876_7 -> u8
        let s_1876_8: u8 = (s_1876_7.value() as u8);
        // D s_1876_9: write-var u#33240 <= s_1876_8
        fn_state.u_33240 = s_1876_8;
        // C s_1876_10: const #16s : i
        let s_1876_10: i128 = 16;
        // C s_1876_11: const #4s : i
        let s_1876_11: i128 = 4;
        // D s_1876_12: read-var u#33239:u32
        let s_1876_12: u32 = fn_state.u_33239;
        // D s_1876_13: cast zx s_1876_12 -> bv
        let s_1876_13: Bits = Bits::new(s_1876_12 as u128, 32u16);
        // D s_1876_14: bit-extract s_1876_13 s_1876_10 s_1876_11
        let s_1876_14: Bits = (Bits::new(
            ((s_1876_13) >> (s_1876_10)).value(),
            u16::try_from(s_1876_11).unwrap(),
        ));
        // D s_1876_15: cast reint s_1876_14 -> u8
        let s_1876_15: u8 = (s_1876_14.value() as u8);
        // D s_1876_16: write-var u#33241 <= s_1876_15
        fn_state.u_33241 = s_1876_15;
        // C s_1876_17: const #12s : i
        let s_1876_17: i128 = 12;
        // C s_1876_18: const #4s : i
        let s_1876_18: i128 = 4;
        // D s_1876_19: read-var u#33239:u32
        let s_1876_19: u32 = fn_state.u_33239;
        // D s_1876_20: cast zx s_1876_19 -> bv
        let s_1876_20: Bits = Bits::new(s_1876_19 as u128, 32u16);
        // D s_1876_21: bit-extract s_1876_20 s_1876_17 s_1876_18
        let s_1876_21: Bits = (Bits::new(
            ((s_1876_20) >> (s_1876_17)).value(),
            u16::try_from(s_1876_18).unwrap(),
        ));
        // D s_1876_22: cast reint s_1876_21 -> u8
        let s_1876_22: u8 = (s_1876_21.value() as u8);
        // D s_1876_23: write-var u#33242 <= s_1876_22
        fn_state.u_33242 = s_1876_22;
        // C s_1876_24: const #0s : i
        let s_1876_24: i128 = 0;
        // C s_1876_25: const #4s : i
        let s_1876_25: i128 = 4;
        // D s_1876_26: read-var u#33239:u32
        let s_1876_26: u32 = fn_state.u_33239;
        // D s_1876_27: cast zx s_1876_26 -> bv
        let s_1876_27: Bits = Bits::new(s_1876_26 as u128, 32u16);
        // D s_1876_28: bit-extract s_1876_27 s_1876_24 s_1876_25
        let s_1876_28: Bits = (Bits::new(
            ((s_1876_27) >> (s_1876_24)).value(),
            u16::try_from(s_1876_25).unwrap(),
        ));
        // D s_1876_29: cast reint s_1876_28 -> u8
        let s_1876_29: u8 = (s_1876_28.value() as u8);
        // D s_1876_30: write-var u#33243 <= s_1876_29
        fn_state.u_33243 = s_1876_29;
        // C s_1876_31: const #8s : i
        let s_1876_31: i128 = 8;
        // D s_1876_32: read-var u#33239:u32
        let s_1876_32: u32 = fn_state.u_33239;
        // D s_1876_33: cast zx s_1876_32 -> bv
        let s_1876_33: Bits = Bits::new(s_1876_32 as u128, 32u16);
        // C s_1876_34: const #1u : u64
        let s_1876_34: u64 = 1;
        // D s_1876_35: bit-extract s_1876_33 s_1876_31 s_1876_34
        let s_1876_35: Bits = (Bits::new(
            ((s_1876_33) >> (s_1876_31)).value(),
            u16::try_from(s_1876_34).unwrap(),
        ));
        // D s_1876_36: cast reint s_1876_35 -> u8
        let s_1876_36: bool = ((s_1876_35.value()) != 0);
        // C s_1876_37: const #0s : i
        let s_1876_37: i128 = 0;
        // C s_1876_38: const #0u : u64
        let s_1876_38: u64 = 0;
        // D s_1876_39: cast zx s_1876_36 -> u64
        let s_1876_39: u64 = (s_1876_36 as u64);
        // C s_1876_40: const #1u : u64
        let s_1876_40: u64 = 1;
        // D s_1876_41: and s_1876_39 s_1876_40
        let s_1876_41: u64 = ((s_1876_39) & (s_1876_40));
        // D s_1876_42: cmp-eq s_1876_41 s_1876_40
        let s_1876_42: bool = ((s_1876_41) == (s_1876_40));
        // D s_1876_43: lsl s_1876_39 s_1876_37
        let s_1876_43: u64 = s_1876_39 << s_1876_37;
        // D s_1876_44: or s_1876_38 s_1876_43
        let s_1876_44: u64 = ((s_1876_38) | (s_1876_43));
        // D s_1876_45: cmpl s_1876_43
        let s_1876_45: u64 = !s_1876_43;
        // D s_1876_46: and s_1876_38 s_1876_45
        let s_1876_46: u64 = ((s_1876_38) & (s_1876_45));
        // D s_1876_47: select s_1876_42 s_1876_44 s_1876_46
        let s_1876_47: u64 = if s_1876_42 { s_1876_44 } else { s_1876_46 };
        // D s_1876_48: cast trunc s_1876_47 -> u8
        let s_1876_48: bool = ((s_1876_47) != 0);
        // D s_1876_49: cast zx s_1876_48 -> bv
        let s_1876_49: Bits = Bits::new(s_1876_48 as u128, 1u16);
        // C s_1876_50: const #1u : u8
        let s_1876_50: bool = true;
        // C s_1876_51: cast zx s_1876_50 -> bv
        let s_1876_51: Bits = Bits::new(s_1876_50 as u128, 1u16);
        // D s_1876_52: cmp-ne s_1876_49 s_1876_51
        let s_1876_52: bool = ((s_1876_49) != (s_1876_51));
        // N s_1876_53: branch s_1876_52 b1881 b1877
        if s_1876_52 {
            return block_1881(state, tracer, fn_state);
        } else {
            return block_1877(state, tracer, fn_state);
        };
    }
    fn block_1877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1877_0: const #9s : i
        let s_1877_0: i128 = 9;
        // D s_1877_1: read-var u#33239:u32
        let s_1877_1: u32 = fn_state.u_33239;
        // D s_1877_2: cast zx s_1877_1 -> bv
        let s_1877_2: Bits = Bits::new(s_1877_1 as u128, 32u16);
        // C s_1877_3: const #1u : u64
        let s_1877_3: u64 = 1;
        // D s_1877_4: bit-extract s_1877_2 s_1877_0 s_1877_3
        let s_1877_4: Bits = (Bits::new(
            ((s_1877_2) >> (s_1877_0)).value(),
            u16::try_from(s_1877_3).unwrap(),
        ));
        // D s_1877_5: cast reint s_1877_4 -> u8
        let s_1877_5: bool = ((s_1877_4.value()) != 0);
        // C s_1877_6: const #0s : i
        let s_1877_6: i128 = 0;
        // C s_1877_7: const #0u : u64
        let s_1877_7: u64 = 0;
        // D s_1877_8: cast zx s_1877_5 -> u64
        let s_1877_8: u64 = (s_1877_5 as u64);
        // C s_1877_9: const #1u : u64
        let s_1877_9: u64 = 1;
        // D s_1877_10: and s_1877_8 s_1877_9
        let s_1877_10: u64 = ((s_1877_8) & (s_1877_9));
        // D s_1877_11: cmp-eq s_1877_10 s_1877_9
        let s_1877_11: bool = ((s_1877_10) == (s_1877_9));
        // D s_1877_12: lsl s_1877_8 s_1877_6
        let s_1877_12: u64 = s_1877_8 << s_1877_6;
        // D s_1877_13: or s_1877_7 s_1877_12
        let s_1877_13: u64 = ((s_1877_7) | (s_1877_12));
        // D s_1877_14: cmpl s_1877_12
        let s_1877_14: u64 = !s_1877_12;
        // D s_1877_15: and s_1877_7 s_1877_14
        let s_1877_15: u64 = ((s_1877_7) & (s_1877_14));
        // D s_1877_16: select s_1877_11 s_1877_13 s_1877_15
        let s_1877_16: u64 = if s_1877_11 { s_1877_13 } else { s_1877_15 };
        // D s_1877_17: cast trunc s_1877_16 -> u8
        let s_1877_17: bool = ((s_1877_16) != 0);
        // D s_1877_18: cast zx s_1877_17 -> bv
        let s_1877_18: Bits = Bits::new(s_1877_17 as u128, 1u16);
        // C s_1877_19: const #1u : u8
        let s_1877_19: bool = true;
        // C s_1877_20: cast zx s_1877_19 -> bv
        let s_1877_20: Bits = Bits::new(s_1877_19 as u128, 1u16);
        // D s_1877_21: cmp-ne s_1877_18 s_1877_20
        let s_1877_21: bool = ((s_1877_18) != (s_1877_20));
        // D s_1877_22: write-var gs#408288 <= s_1877_21
        fn_state.gs_408288 = s_1877_21;
        // N s_1877_23: jump b1878
        return block_1878(state, tracer, fn_state);
    }
    fn block_1878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1878_0: read-var gs#408288:u8
        let s_1878_0: bool = fn_state.gs_408288;
        // N s_1878_1: branch s_1878_0 b1880 b1879
        if s_1878_0 {
            return block_1880(state, tracer, fn_state);
        } else {
            return block_1879(state, tracer, fn_state);
        };
    }
    fn block_1879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1879_0: read-var u#33240:u8
        let s_1879_0: u8 = fn_state.u_33240;
        // D s_1879_1: read-var u#33241:u8
        let s_1879_1: u8 = fn_state.u_33241;
        // D s_1879_2: read-var u#33242:u8
        let s_1879_2: u8 = fn_state.u_33242;
        // D s_1879_3: read-var u#33243:u8
        let s_1879_3: u8 = fn_state.u_33243;
        // D s_1879_4: call decode_aarch32_instrs_STLEX_A1enc_A_txt(s_1879_0, s_1879_1, s_1879_2, s_1879_3)
        let s_1879_4: () = decode_aarch32_instrs_STLEX_A1enc_A_txt(
            state,
            tracer,
            s_1879_0,
            s_1879_1,
            s_1879_2,
            s_1879_3,
        );
        // N s_1879_5: return
        return;
    }
    fn block_1880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1880_0: panic
        panic!("{:?}", ());
        // N s_1880_1: return
        return;
    }
    fn block_1881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1881_0: const #1u : u8
        let s_1881_0: bool = true;
        // D s_1881_1: write-var gs#408288 <= s_1881_0
        fn_state.gs_408288 = s_1881_0;
        // N s_1881_2: jump b1878
        return block_1878(state, tracer, fn_state);
    }
    fn block_1882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1882_0: read-var merge#var.1:struct
        let s_1882_0: u32 = fn_state.merge_var._1;
        // D s_1882_1: write-var u#33245 <= s_1882_0
        fn_state.u_33245 = s_1882_0;
        // C s_1882_2: const #20s : i
        let s_1882_2: i128 = 20;
        // D s_1882_3: read-var u#33245:u32
        let s_1882_3: u32 = fn_state.u_33245;
        // D s_1882_4: cast zx s_1882_3 -> bv
        let s_1882_4: Bits = Bits::new(s_1882_3 as u128, 32u16);
        // C s_1882_5: const #1s : i64
        let s_1882_5: i64 = 1;
        // C s_1882_6: cast zx s_1882_5 -> i
        let s_1882_6: i128 = (i128::try_from(s_1882_5).unwrap());
        // C s_1882_7: const #7s : i
        let s_1882_7: i128 = 7;
        // C s_1882_8: add s_1882_7 s_1882_6
        let s_1882_8: i128 = (s_1882_7 + s_1882_6);
        // D s_1882_9: bit-extract s_1882_4 s_1882_2 s_1882_8
        let s_1882_9: Bits = (Bits::new(
            ((s_1882_4) >> (s_1882_2)).value(),
            u16::try_from(s_1882_8).unwrap(),
        ));
        // D s_1882_10: cast reint s_1882_9 -> u8
        let s_1882_10: u8 = (s_1882_9.value() as u8);
        // D s_1882_11: cast zx s_1882_10 -> bv
        let s_1882_11: Bits = Bits::new(s_1882_10 as u128, 8u16);
        // C s_1882_12: const #28u : u8
        let s_1882_12: u8 = 28;
        // C s_1882_13: cast zx s_1882_12 -> bv
        let s_1882_13: Bits = Bits::new(s_1882_12 as u128, 8u16);
        // D s_1882_14: cmp-eq s_1882_11 s_1882_13
        let s_1882_14: bool = ((s_1882_11) == (s_1882_13));
        // N s_1882_15: branch s_1882_14 b2082 b1883
        if s_1882_14 {
            return block_2082(state, tracer, fn_state);
        } else {
            return block_1883(state, tracer, fn_state);
        };
    }
    fn block_1883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1883_0: const #0u : u8
        let s_1883_0: bool = false;
        // D s_1883_1: write-var gs#408294 <= s_1883_0
        fn_state.gs_408294 = s_1883_0;
        // N s_1883_2: jump b1884
        return block_1884(state, tracer, fn_state);
    }
    fn block_1884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1884_0: read-var gs#408294:u8
        let s_1884_0: bool = fn_state.gs_408294;
        // N s_1884_1: branch s_1884_0 b2078 b1885
        if s_1884_0 {
            return block_2078(state, tracer, fn_state);
        } else {
            return block_1885(state, tracer, fn_state);
        };
    }
    fn block_1885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1885_0: const #0u : u8
        let s_1885_0: bool = false;
        // D s_1885_1: write-var gs#408299 <= s_1885_0
        fn_state.gs_408299 = s_1885_0;
        // N s_1885_2: jump b1886
        return block_1886(state, tracer, fn_state);
    }
    fn block_1886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1886_0: read-var gs#408299:u8
        let s_1886_0: bool = fn_state.gs_408299;
        // D s_1886_1: not s_1886_0
        let s_1886_1: bool = !s_1886_0;
        // N s_1886_2: branch s_1886_1 b1893 b1887
        if s_1886_1 {
            return block_1893(state, tracer, fn_state);
        } else {
            return block_1887(state, tracer, fn_state);
        };
    }
    fn block_1887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1887_0: const #3858s : i
        let s_1887_0: i128 = 3858;
        // C s_1887_1: const #14696u : u32
        let s_1887_1: u32 = 14696;
        // N s_1887_2: write-reg s_1887_1 <= s_1887_0
        let s_1887_2: () = {
            state.write_register::<i128>(s_1887_1 as isize, s_1887_0);
            tracer.write_register(s_1887_1 as isize, s_1887_0);
        };
        // C s_1887_3: const #28s : i
        let s_1887_3: i128 = 28;
        // C s_1887_4: const #4s : i
        let s_1887_4: i128 = 4;
        // D s_1887_5: read-var u#33245:u32
        let s_1887_5: u32 = fn_state.u_33245;
        // D s_1887_6: cast zx s_1887_5 -> bv
        let s_1887_6: Bits = Bits::new(s_1887_5 as u128, 32u16);
        // D s_1887_7: bit-extract s_1887_6 s_1887_3 s_1887_4
        let s_1887_7: Bits = (Bits::new(
            ((s_1887_6) >> (s_1887_3)).value(),
            u16::try_from(s_1887_4).unwrap(),
        ));
        // D s_1887_8: cast reint s_1887_7 -> u8
        let s_1887_8: u8 = (s_1887_7.value() as u8);
        // D s_1887_9: write-var u#33246 <= s_1887_8
        fn_state.u_33246 = s_1887_8;
        // C s_1887_10: const #16s : i
        let s_1887_10: i128 = 16;
        // C s_1887_11: const #4s : i
        let s_1887_11: i128 = 4;
        // D s_1887_12: read-var u#33245:u32
        let s_1887_12: u32 = fn_state.u_33245;
        // D s_1887_13: cast zx s_1887_12 -> bv
        let s_1887_13: Bits = Bits::new(s_1887_12 as u128, 32u16);
        // D s_1887_14: bit-extract s_1887_13 s_1887_10 s_1887_11
        let s_1887_14: Bits = (Bits::new(
            ((s_1887_13) >> (s_1887_10)).value(),
            u16::try_from(s_1887_11).unwrap(),
        ));
        // D s_1887_15: cast reint s_1887_14 -> u8
        let s_1887_15: u8 = (s_1887_14.value() as u8);
        // D s_1887_16: write-var u#33247 <= s_1887_15
        fn_state.u_33247 = s_1887_15;
        // C s_1887_17: const #12s : i
        let s_1887_17: i128 = 12;
        // C s_1887_18: const #4s : i
        let s_1887_18: i128 = 4;
        // D s_1887_19: read-var u#33245:u32
        let s_1887_19: u32 = fn_state.u_33245;
        // D s_1887_20: cast zx s_1887_19 -> bv
        let s_1887_20: Bits = Bits::new(s_1887_19 as u128, 32u16);
        // D s_1887_21: bit-extract s_1887_20 s_1887_17 s_1887_18
        let s_1887_21: Bits = (Bits::new(
            ((s_1887_20) >> (s_1887_17)).value(),
            u16::try_from(s_1887_18).unwrap(),
        ));
        // D s_1887_22: cast reint s_1887_21 -> u8
        let s_1887_22: u8 = (s_1887_21.value() as u8);
        // D s_1887_23: write-var u#33248 <= s_1887_22
        fn_state.u_33248 = s_1887_22;
        // C s_1887_24: const #0s : i
        let s_1887_24: i128 = 0;
        // C s_1887_25: const #4s : i
        let s_1887_25: i128 = 4;
        // D s_1887_26: read-var u#33245:u32
        let s_1887_26: u32 = fn_state.u_33245;
        // D s_1887_27: cast zx s_1887_26 -> bv
        let s_1887_27: Bits = Bits::new(s_1887_26 as u128, 32u16);
        // D s_1887_28: bit-extract s_1887_27 s_1887_24 s_1887_25
        let s_1887_28: Bits = (Bits::new(
            ((s_1887_27) >> (s_1887_24)).value(),
            u16::try_from(s_1887_25).unwrap(),
        ));
        // D s_1887_29: cast reint s_1887_28 -> u8
        let s_1887_29: u8 = (s_1887_28.value() as u8);
        // D s_1887_30: write-var u#33249 <= s_1887_29
        fn_state.u_33249 = s_1887_29;
        // C s_1887_31: const #8s : i
        let s_1887_31: i128 = 8;
        // D s_1887_32: read-var u#33245:u32
        let s_1887_32: u32 = fn_state.u_33245;
        // D s_1887_33: cast zx s_1887_32 -> bv
        let s_1887_33: Bits = Bits::new(s_1887_32 as u128, 32u16);
        // C s_1887_34: const #1u : u64
        let s_1887_34: u64 = 1;
        // D s_1887_35: bit-extract s_1887_33 s_1887_31 s_1887_34
        let s_1887_35: Bits = (Bits::new(
            ((s_1887_33) >> (s_1887_31)).value(),
            u16::try_from(s_1887_34).unwrap(),
        ));
        // D s_1887_36: cast reint s_1887_35 -> u8
        let s_1887_36: bool = ((s_1887_35.value()) != 0);
        // C s_1887_37: const #0s : i
        let s_1887_37: i128 = 0;
        // C s_1887_38: const #0u : u64
        let s_1887_38: u64 = 0;
        // D s_1887_39: cast zx s_1887_36 -> u64
        let s_1887_39: u64 = (s_1887_36 as u64);
        // C s_1887_40: const #1u : u64
        let s_1887_40: u64 = 1;
        // D s_1887_41: and s_1887_39 s_1887_40
        let s_1887_41: u64 = ((s_1887_39) & (s_1887_40));
        // D s_1887_42: cmp-eq s_1887_41 s_1887_40
        let s_1887_42: bool = ((s_1887_41) == (s_1887_40));
        // D s_1887_43: lsl s_1887_39 s_1887_37
        let s_1887_43: u64 = s_1887_39 << s_1887_37;
        // D s_1887_44: or s_1887_38 s_1887_43
        let s_1887_44: u64 = ((s_1887_38) | (s_1887_43));
        // D s_1887_45: cmpl s_1887_43
        let s_1887_45: u64 = !s_1887_43;
        // D s_1887_46: and s_1887_38 s_1887_45
        let s_1887_46: u64 = ((s_1887_38) & (s_1887_45));
        // D s_1887_47: select s_1887_42 s_1887_44 s_1887_46
        let s_1887_47: u64 = if s_1887_42 { s_1887_44 } else { s_1887_46 };
        // D s_1887_48: cast trunc s_1887_47 -> u8
        let s_1887_48: bool = ((s_1887_47) != 0);
        // D s_1887_49: cast zx s_1887_48 -> bv
        let s_1887_49: Bits = Bits::new(s_1887_48 as u128, 1u16);
        // C s_1887_50: const #1u : u8
        let s_1887_50: bool = true;
        // C s_1887_51: cast zx s_1887_50 -> bv
        let s_1887_51: Bits = Bits::new(s_1887_50 as u128, 1u16);
        // D s_1887_52: cmp-ne s_1887_49 s_1887_51
        let s_1887_52: bool = ((s_1887_49) != (s_1887_51));
        // N s_1887_53: branch s_1887_52 b1892 b1888
        if s_1887_52 {
            return block_1892(state, tracer, fn_state);
        } else {
            return block_1888(state, tracer, fn_state);
        };
    }
    fn block_1888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1888_0: const #9s : i
        let s_1888_0: i128 = 9;
        // D s_1888_1: read-var u#33245:u32
        let s_1888_1: u32 = fn_state.u_33245;
        // D s_1888_2: cast zx s_1888_1 -> bv
        let s_1888_2: Bits = Bits::new(s_1888_1 as u128, 32u16);
        // C s_1888_3: const #1u : u64
        let s_1888_3: u64 = 1;
        // D s_1888_4: bit-extract s_1888_2 s_1888_0 s_1888_3
        let s_1888_4: Bits = (Bits::new(
            ((s_1888_2) >> (s_1888_0)).value(),
            u16::try_from(s_1888_3).unwrap(),
        ));
        // D s_1888_5: cast reint s_1888_4 -> u8
        let s_1888_5: bool = ((s_1888_4.value()) != 0);
        // C s_1888_6: const #0s : i
        let s_1888_6: i128 = 0;
        // C s_1888_7: const #0u : u64
        let s_1888_7: u64 = 0;
        // D s_1888_8: cast zx s_1888_5 -> u64
        let s_1888_8: u64 = (s_1888_5 as u64);
        // C s_1888_9: const #1u : u64
        let s_1888_9: u64 = 1;
        // D s_1888_10: and s_1888_8 s_1888_9
        let s_1888_10: u64 = ((s_1888_8) & (s_1888_9));
        // D s_1888_11: cmp-eq s_1888_10 s_1888_9
        let s_1888_11: bool = ((s_1888_10) == (s_1888_9));
        // D s_1888_12: lsl s_1888_8 s_1888_6
        let s_1888_12: u64 = s_1888_8 << s_1888_6;
        // D s_1888_13: or s_1888_7 s_1888_12
        let s_1888_13: u64 = ((s_1888_7) | (s_1888_12));
        // D s_1888_14: cmpl s_1888_12
        let s_1888_14: u64 = !s_1888_12;
        // D s_1888_15: and s_1888_7 s_1888_14
        let s_1888_15: u64 = ((s_1888_7) & (s_1888_14));
        // D s_1888_16: select s_1888_11 s_1888_13 s_1888_15
        let s_1888_16: u64 = if s_1888_11 { s_1888_13 } else { s_1888_15 };
        // D s_1888_17: cast trunc s_1888_16 -> u8
        let s_1888_17: bool = ((s_1888_16) != 0);
        // D s_1888_18: cast zx s_1888_17 -> bv
        let s_1888_18: Bits = Bits::new(s_1888_17 as u128, 1u16);
        // C s_1888_19: const #1u : u8
        let s_1888_19: bool = true;
        // C s_1888_20: cast zx s_1888_19 -> bv
        let s_1888_20: Bits = Bits::new(s_1888_19 as u128, 1u16);
        // D s_1888_21: cmp-ne s_1888_18 s_1888_20
        let s_1888_21: bool = ((s_1888_18) != (s_1888_20));
        // D s_1888_22: write-var gs#408314 <= s_1888_21
        fn_state.gs_408314 = s_1888_21;
        // N s_1888_23: jump b1889
        return block_1889(state, tracer, fn_state);
    }
    fn block_1889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1889_0: read-var gs#408314:u8
        let s_1889_0: bool = fn_state.gs_408314;
        // N s_1889_1: branch s_1889_0 b1891 b1890
        if s_1889_0 {
            return block_1891(state, tracer, fn_state);
        } else {
            return block_1890(state, tracer, fn_state);
        };
    }
    fn block_1890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1890_0: read-var u#33246:u8
        let s_1890_0: u8 = fn_state.u_33246;
        // D s_1890_1: read-var u#33247:u8
        let s_1890_1: u8 = fn_state.u_33247;
        // D s_1890_2: read-var u#33248:u8
        let s_1890_2: u8 = fn_state.u_33248;
        // D s_1890_3: read-var u#33249:u8
        let s_1890_3: u8 = fn_state.u_33249;
        // D s_1890_4: call decode_aarch32_instrs_STLEXB_A1enc_A_txt(s_1890_0, s_1890_1, s_1890_2, s_1890_3)
        let s_1890_4: () = decode_aarch32_instrs_STLEXB_A1enc_A_txt(
            state,
            tracer,
            s_1890_0,
            s_1890_1,
            s_1890_2,
            s_1890_3,
        );
        // N s_1890_5: return
        return;
    }
    fn block_1891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1891_0: panic
        panic!("{:?}", ());
        // N s_1891_1: return
        return;
    }
    fn block_1892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1892_0: const #1u : u8
        let s_1892_0: bool = true;
        // D s_1892_1: write-var gs#408314 <= s_1892_0
        fn_state.gs_408314 = s_1892_0;
        // N s_1892_2: jump b1889
        return block_1889(state, tracer, fn_state);
    }
    fn block_1893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1893_0: read-var merge#var.1:struct
        let s_1893_0: u32 = fn_state.merge_var._1;
        // D s_1893_1: write-var u#33251 <= s_1893_0
        fn_state.u_33251 = s_1893_0;
        // C s_1893_2: const #20s : i
        let s_1893_2: i128 = 20;
        // D s_1893_3: read-var u#33251:u32
        let s_1893_3: u32 = fn_state.u_33251;
        // D s_1893_4: cast zx s_1893_3 -> bv
        let s_1893_4: Bits = Bits::new(s_1893_3 as u128, 32u16);
        // C s_1893_5: const #1s : i64
        let s_1893_5: i64 = 1;
        // C s_1893_6: cast zx s_1893_5 -> i
        let s_1893_6: i128 = (i128::try_from(s_1893_5).unwrap());
        // C s_1893_7: const #7s : i
        let s_1893_7: i128 = 7;
        // C s_1893_8: add s_1893_7 s_1893_6
        let s_1893_8: i128 = (s_1893_7 + s_1893_6);
        // D s_1893_9: bit-extract s_1893_4 s_1893_2 s_1893_8
        let s_1893_9: Bits = (Bits::new(
            ((s_1893_4) >> (s_1893_2)).value(),
            u16::try_from(s_1893_8).unwrap(),
        ));
        // D s_1893_10: cast reint s_1893_9 -> u8
        let s_1893_10: u8 = (s_1893_9.value() as u8);
        // D s_1893_11: cast zx s_1893_10 -> bv
        let s_1893_11: Bits = Bits::new(s_1893_10 as u128, 8u16);
        // C s_1893_12: const #26u : u8
        let s_1893_12: u8 = 26;
        // C s_1893_13: cast zx s_1893_12 -> bv
        let s_1893_13: Bits = Bits::new(s_1893_12 as u128, 8u16);
        // D s_1893_14: cmp-eq s_1893_11 s_1893_13
        let s_1893_14: bool = ((s_1893_11) == (s_1893_13));
        // N s_1893_15: branch s_1893_14 b2077 b1894
        if s_1893_14 {
            return block_2077(state, tracer, fn_state);
        } else {
            return block_1894(state, tracer, fn_state);
        };
    }
    fn block_1894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1894_0: const #0u : u8
        let s_1894_0: bool = false;
        // D s_1894_1: write-var gs#408320 <= s_1894_0
        fn_state.gs_408320 = s_1894_0;
        // N s_1894_2: jump b1895
        return block_1895(state, tracer, fn_state);
    }
    fn block_1895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1895_0: read-var gs#408320:u8
        let s_1895_0: bool = fn_state.gs_408320;
        // N s_1895_1: branch s_1895_0 b2073 b1896
        if s_1895_0 {
            return block_2073(state, tracer, fn_state);
        } else {
            return block_1896(state, tracer, fn_state);
        };
    }
    fn block_1896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1896_0: const #0u : u8
        let s_1896_0: bool = false;
        // D s_1896_1: write-var gs#408325 <= s_1896_0
        fn_state.gs_408325 = s_1896_0;
        // N s_1896_2: jump b1897
        return block_1897(state, tracer, fn_state);
    }
    fn block_1897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1897_0: read-var gs#408325:u8
        let s_1897_0: bool = fn_state.gs_408325;
        // D s_1897_1: not s_1897_0
        let s_1897_1: bool = !s_1897_0;
        // N s_1897_2: branch s_1897_1 b1904 b1898
        if s_1897_1 {
            return block_1904(state, tracer, fn_state);
        } else {
            return block_1898(state, tracer, fn_state);
        };
    }
    fn block_1898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1898_0: const #3860s : i
        let s_1898_0: i128 = 3860;
        // C s_1898_1: const #14696u : u32
        let s_1898_1: u32 = 14696;
        // N s_1898_2: write-reg s_1898_1 <= s_1898_0
        let s_1898_2: () = {
            state.write_register::<i128>(s_1898_1 as isize, s_1898_0);
            tracer.write_register(s_1898_1 as isize, s_1898_0);
        };
        // C s_1898_3: const #28s : i
        let s_1898_3: i128 = 28;
        // C s_1898_4: const #4s : i
        let s_1898_4: i128 = 4;
        // D s_1898_5: read-var u#33251:u32
        let s_1898_5: u32 = fn_state.u_33251;
        // D s_1898_6: cast zx s_1898_5 -> bv
        let s_1898_6: Bits = Bits::new(s_1898_5 as u128, 32u16);
        // D s_1898_7: bit-extract s_1898_6 s_1898_3 s_1898_4
        let s_1898_7: Bits = (Bits::new(
            ((s_1898_6) >> (s_1898_3)).value(),
            u16::try_from(s_1898_4).unwrap(),
        ));
        // D s_1898_8: cast reint s_1898_7 -> u8
        let s_1898_8: u8 = (s_1898_7.value() as u8);
        // D s_1898_9: write-var u#33252 <= s_1898_8
        fn_state.u_33252 = s_1898_8;
        // C s_1898_10: const #16s : i
        let s_1898_10: i128 = 16;
        // C s_1898_11: const #4s : i
        let s_1898_11: i128 = 4;
        // D s_1898_12: read-var u#33251:u32
        let s_1898_12: u32 = fn_state.u_33251;
        // D s_1898_13: cast zx s_1898_12 -> bv
        let s_1898_13: Bits = Bits::new(s_1898_12 as u128, 32u16);
        // D s_1898_14: bit-extract s_1898_13 s_1898_10 s_1898_11
        let s_1898_14: Bits = (Bits::new(
            ((s_1898_13) >> (s_1898_10)).value(),
            u16::try_from(s_1898_11).unwrap(),
        ));
        // D s_1898_15: cast reint s_1898_14 -> u8
        let s_1898_15: u8 = (s_1898_14.value() as u8);
        // D s_1898_16: write-var u#33253 <= s_1898_15
        fn_state.u_33253 = s_1898_15;
        // C s_1898_17: const #12s : i
        let s_1898_17: i128 = 12;
        // C s_1898_18: const #4s : i
        let s_1898_18: i128 = 4;
        // D s_1898_19: read-var u#33251:u32
        let s_1898_19: u32 = fn_state.u_33251;
        // D s_1898_20: cast zx s_1898_19 -> bv
        let s_1898_20: Bits = Bits::new(s_1898_19 as u128, 32u16);
        // D s_1898_21: bit-extract s_1898_20 s_1898_17 s_1898_18
        let s_1898_21: Bits = (Bits::new(
            ((s_1898_20) >> (s_1898_17)).value(),
            u16::try_from(s_1898_18).unwrap(),
        ));
        // D s_1898_22: cast reint s_1898_21 -> u8
        let s_1898_22: u8 = (s_1898_21.value() as u8);
        // D s_1898_23: write-var u#33254 <= s_1898_22
        fn_state.u_33254 = s_1898_22;
        // C s_1898_24: const #0s : i
        let s_1898_24: i128 = 0;
        // C s_1898_25: const #4s : i
        let s_1898_25: i128 = 4;
        // D s_1898_26: read-var u#33251:u32
        let s_1898_26: u32 = fn_state.u_33251;
        // D s_1898_27: cast zx s_1898_26 -> bv
        let s_1898_27: Bits = Bits::new(s_1898_26 as u128, 32u16);
        // D s_1898_28: bit-extract s_1898_27 s_1898_24 s_1898_25
        let s_1898_28: Bits = (Bits::new(
            ((s_1898_27) >> (s_1898_24)).value(),
            u16::try_from(s_1898_25).unwrap(),
        ));
        // D s_1898_29: cast reint s_1898_28 -> u8
        let s_1898_29: u8 = (s_1898_28.value() as u8);
        // D s_1898_30: write-var u#33255 <= s_1898_29
        fn_state.u_33255 = s_1898_29;
        // C s_1898_31: const #8s : i
        let s_1898_31: i128 = 8;
        // D s_1898_32: read-var u#33251:u32
        let s_1898_32: u32 = fn_state.u_33251;
        // D s_1898_33: cast zx s_1898_32 -> bv
        let s_1898_33: Bits = Bits::new(s_1898_32 as u128, 32u16);
        // C s_1898_34: const #1u : u64
        let s_1898_34: u64 = 1;
        // D s_1898_35: bit-extract s_1898_33 s_1898_31 s_1898_34
        let s_1898_35: Bits = (Bits::new(
            ((s_1898_33) >> (s_1898_31)).value(),
            u16::try_from(s_1898_34).unwrap(),
        ));
        // D s_1898_36: cast reint s_1898_35 -> u8
        let s_1898_36: bool = ((s_1898_35.value()) != 0);
        // C s_1898_37: const #0s : i
        let s_1898_37: i128 = 0;
        // C s_1898_38: const #0u : u64
        let s_1898_38: u64 = 0;
        // D s_1898_39: cast zx s_1898_36 -> u64
        let s_1898_39: u64 = (s_1898_36 as u64);
        // C s_1898_40: const #1u : u64
        let s_1898_40: u64 = 1;
        // D s_1898_41: and s_1898_39 s_1898_40
        let s_1898_41: u64 = ((s_1898_39) & (s_1898_40));
        // D s_1898_42: cmp-eq s_1898_41 s_1898_40
        let s_1898_42: bool = ((s_1898_41) == (s_1898_40));
        // D s_1898_43: lsl s_1898_39 s_1898_37
        let s_1898_43: u64 = s_1898_39 << s_1898_37;
        // D s_1898_44: or s_1898_38 s_1898_43
        let s_1898_44: u64 = ((s_1898_38) | (s_1898_43));
        // D s_1898_45: cmpl s_1898_43
        let s_1898_45: u64 = !s_1898_43;
        // D s_1898_46: and s_1898_38 s_1898_45
        let s_1898_46: u64 = ((s_1898_38) & (s_1898_45));
        // D s_1898_47: select s_1898_42 s_1898_44 s_1898_46
        let s_1898_47: u64 = if s_1898_42 { s_1898_44 } else { s_1898_46 };
        // D s_1898_48: cast trunc s_1898_47 -> u8
        let s_1898_48: bool = ((s_1898_47) != 0);
        // D s_1898_49: cast zx s_1898_48 -> bv
        let s_1898_49: Bits = Bits::new(s_1898_48 as u128, 1u16);
        // C s_1898_50: const #1u : u8
        let s_1898_50: bool = true;
        // C s_1898_51: cast zx s_1898_50 -> bv
        let s_1898_51: Bits = Bits::new(s_1898_50 as u128, 1u16);
        // D s_1898_52: cmp-ne s_1898_49 s_1898_51
        let s_1898_52: bool = ((s_1898_49) != (s_1898_51));
        // N s_1898_53: branch s_1898_52 b1903 b1899
        if s_1898_52 {
            return block_1903(state, tracer, fn_state);
        } else {
            return block_1899(state, tracer, fn_state);
        };
    }
    fn block_1899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1899_0: const #9s : i
        let s_1899_0: i128 = 9;
        // D s_1899_1: read-var u#33251:u32
        let s_1899_1: u32 = fn_state.u_33251;
        // D s_1899_2: cast zx s_1899_1 -> bv
        let s_1899_2: Bits = Bits::new(s_1899_1 as u128, 32u16);
        // C s_1899_3: const #1u : u64
        let s_1899_3: u64 = 1;
        // D s_1899_4: bit-extract s_1899_2 s_1899_0 s_1899_3
        let s_1899_4: Bits = (Bits::new(
            ((s_1899_2) >> (s_1899_0)).value(),
            u16::try_from(s_1899_3).unwrap(),
        ));
        // D s_1899_5: cast reint s_1899_4 -> u8
        let s_1899_5: bool = ((s_1899_4.value()) != 0);
        // C s_1899_6: const #0s : i
        let s_1899_6: i128 = 0;
        // C s_1899_7: const #0u : u64
        let s_1899_7: u64 = 0;
        // D s_1899_8: cast zx s_1899_5 -> u64
        let s_1899_8: u64 = (s_1899_5 as u64);
        // C s_1899_9: const #1u : u64
        let s_1899_9: u64 = 1;
        // D s_1899_10: and s_1899_8 s_1899_9
        let s_1899_10: u64 = ((s_1899_8) & (s_1899_9));
        // D s_1899_11: cmp-eq s_1899_10 s_1899_9
        let s_1899_11: bool = ((s_1899_10) == (s_1899_9));
        // D s_1899_12: lsl s_1899_8 s_1899_6
        let s_1899_12: u64 = s_1899_8 << s_1899_6;
        // D s_1899_13: or s_1899_7 s_1899_12
        let s_1899_13: u64 = ((s_1899_7) | (s_1899_12));
        // D s_1899_14: cmpl s_1899_12
        let s_1899_14: u64 = !s_1899_12;
        // D s_1899_15: and s_1899_7 s_1899_14
        let s_1899_15: u64 = ((s_1899_7) & (s_1899_14));
        // D s_1899_16: select s_1899_11 s_1899_13 s_1899_15
        let s_1899_16: u64 = if s_1899_11 { s_1899_13 } else { s_1899_15 };
        // D s_1899_17: cast trunc s_1899_16 -> u8
        let s_1899_17: bool = ((s_1899_16) != 0);
        // D s_1899_18: cast zx s_1899_17 -> bv
        let s_1899_18: Bits = Bits::new(s_1899_17 as u128, 1u16);
        // C s_1899_19: const #1u : u8
        let s_1899_19: bool = true;
        // C s_1899_20: cast zx s_1899_19 -> bv
        let s_1899_20: Bits = Bits::new(s_1899_19 as u128, 1u16);
        // D s_1899_21: cmp-ne s_1899_18 s_1899_20
        let s_1899_21: bool = ((s_1899_18) != (s_1899_20));
        // D s_1899_22: write-var gs#408340 <= s_1899_21
        fn_state.gs_408340 = s_1899_21;
        // N s_1899_23: jump b1900
        return block_1900(state, tracer, fn_state);
    }
    fn block_1900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1900_0: read-var gs#408340:u8
        let s_1900_0: bool = fn_state.gs_408340;
        // N s_1900_1: branch s_1900_0 b1902 b1901
        if s_1900_0 {
            return block_1902(state, tracer, fn_state);
        } else {
            return block_1901(state, tracer, fn_state);
        };
    }
    fn block_1901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1901_0: read-var u#33252:u8
        let s_1901_0: u8 = fn_state.u_33252;
        // D s_1901_1: read-var u#33253:u8
        let s_1901_1: u8 = fn_state.u_33253;
        // D s_1901_2: read-var u#33254:u8
        let s_1901_2: u8 = fn_state.u_33254;
        // D s_1901_3: read-var u#33255:u8
        let s_1901_3: u8 = fn_state.u_33255;
        // D s_1901_4: call decode_aarch32_instrs_STLEXD_A1enc_A_txt(s_1901_0, s_1901_1, s_1901_2, s_1901_3)
        let s_1901_4: () = decode_aarch32_instrs_STLEXD_A1enc_A_txt(
            state,
            tracer,
            s_1901_0,
            s_1901_1,
            s_1901_2,
            s_1901_3,
        );
        // N s_1901_5: return
        return;
    }
    fn block_1902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1902_0: panic
        panic!("{:?}", ());
        // N s_1902_1: return
        return;
    }
    fn block_1903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1903_0: const #1u : u8
        let s_1903_0: bool = true;
        // D s_1903_1: write-var gs#408340 <= s_1903_0
        fn_state.gs_408340 = s_1903_0;
        // N s_1903_2: jump b1900
        return block_1900(state, tracer, fn_state);
    }
    fn block_1904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1904_0: read-var merge#var.1:struct
        let s_1904_0: u32 = fn_state.merge_var._1;
        // D s_1904_1: write-var u#33257 <= s_1904_0
        fn_state.u_33257 = s_1904_0;
        // C s_1904_2: const #20s : i
        let s_1904_2: i128 = 20;
        // D s_1904_3: read-var u#33257:u32
        let s_1904_3: u32 = fn_state.u_33257;
        // D s_1904_4: cast zx s_1904_3 -> bv
        let s_1904_4: Bits = Bits::new(s_1904_3 as u128, 32u16);
        // C s_1904_5: const #1s : i64
        let s_1904_5: i64 = 1;
        // C s_1904_6: cast zx s_1904_5 -> i
        let s_1904_6: i128 = (i128::try_from(s_1904_5).unwrap());
        // C s_1904_7: const #7s : i
        let s_1904_7: i128 = 7;
        // C s_1904_8: add s_1904_7 s_1904_6
        let s_1904_8: i128 = (s_1904_7 + s_1904_6);
        // D s_1904_9: bit-extract s_1904_4 s_1904_2 s_1904_8
        let s_1904_9: Bits = (Bits::new(
            ((s_1904_4) >> (s_1904_2)).value(),
            u16::try_from(s_1904_8).unwrap(),
        ));
        // D s_1904_10: cast reint s_1904_9 -> u8
        let s_1904_10: u8 = (s_1904_9.value() as u8);
        // D s_1904_11: cast zx s_1904_10 -> bv
        let s_1904_11: Bits = Bits::new(s_1904_10 as u128, 8u16);
        // C s_1904_12: const #30u : u8
        let s_1904_12: u8 = 30;
        // C s_1904_13: cast zx s_1904_12 -> bv
        let s_1904_13: Bits = Bits::new(s_1904_12 as u128, 8u16);
        // D s_1904_14: cmp-eq s_1904_11 s_1904_13
        let s_1904_14: bool = ((s_1904_11) == (s_1904_13));
        // N s_1904_15: branch s_1904_14 b2072 b1905
        if s_1904_14 {
            return block_2072(state, tracer, fn_state);
        } else {
            return block_1905(state, tracer, fn_state);
        };
    }
    fn block_1905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1905_0: const #0u : u8
        let s_1905_0: bool = false;
        // D s_1905_1: write-var gs#408346 <= s_1905_0
        fn_state.gs_408346 = s_1905_0;
        // N s_1905_2: jump b1906
        return block_1906(state, tracer, fn_state);
    }
    fn block_1906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1906_0: read-var gs#408346:u8
        let s_1906_0: bool = fn_state.gs_408346;
        // N s_1906_1: branch s_1906_0 b2068 b1907
        if s_1906_0 {
            return block_2068(state, tracer, fn_state);
        } else {
            return block_1907(state, tracer, fn_state);
        };
    }
    fn block_1907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1907_0: const #0u : u8
        let s_1907_0: bool = false;
        // D s_1907_1: write-var gs#408351 <= s_1907_0
        fn_state.gs_408351 = s_1907_0;
        // N s_1907_2: jump b1908
        return block_1908(state, tracer, fn_state);
    }
    fn block_1908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1908_0: read-var gs#408351:u8
        let s_1908_0: bool = fn_state.gs_408351;
        // D s_1908_1: not s_1908_0
        let s_1908_1: bool = !s_1908_0;
        // N s_1908_2: branch s_1908_1 b1915 b1909
        if s_1908_1 {
            return block_1915(state, tracer, fn_state);
        } else {
            return block_1909(state, tracer, fn_state);
        };
    }
    fn block_1909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1909_0: const #3862s : i
        let s_1909_0: i128 = 3862;
        // C s_1909_1: const #14696u : u32
        let s_1909_1: u32 = 14696;
        // N s_1909_2: write-reg s_1909_1 <= s_1909_0
        let s_1909_2: () = {
            state.write_register::<i128>(s_1909_1 as isize, s_1909_0);
            tracer.write_register(s_1909_1 as isize, s_1909_0);
        };
        // C s_1909_3: const #28s : i
        let s_1909_3: i128 = 28;
        // C s_1909_4: const #4s : i
        let s_1909_4: i128 = 4;
        // D s_1909_5: read-var u#33257:u32
        let s_1909_5: u32 = fn_state.u_33257;
        // D s_1909_6: cast zx s_1909_5 -> bv
        let s_1909_6: Bits = Bits::new(s_1909_5 as u128, 32u16);
        // D s_1909_7: bit-extract s_1909_6 s_1909_3 s_1909_4
        let s_1909_7: Bits = (Bits::new(
            ((s_1909_6) >> (s_1909_3)).value(),
            u16::try_from(s_1909_4).unwrap(),
        ));
        // D s_1909_8: cast reint s_1909_7 -> u8
        let s_1909_8: u8 = (s_1909_7.value() as u8);
        // D s_1909_9: write-var u#33258 <= s_1909_8
        fn_state.u_33258 = s_1909_8;
        // C s_1909_10: const #16s : i
        let s_1909_10: i128 = 16;
        // C s_1909_11: const #4s : i
        let s_1909_11: i128 = 4;
        // D s_1909_12: read-var u#33257:u32
        let s_1909_12: u32 = fn_state.u_33257;
        // D s_1909_13: cast zx s_1909_12 -> bv
        let s_1909_13: Bits = Bits::new(s_1909_12 as u128, 32u16);
        // D s_1909_14: bit-extract s_1909_13 s_1909_10 s_1909_11
        let s_1909_14: Bits = (Bits::new(
            ((s_1909_13) >> (s_1909_10)).value(),
            u16::try_from(s_1909_11).unwrap(),
        ));
        // D s_1909_15: cast reint s_1909_14 -> u8
        let s_1909_15: u8 = (s_1909_14.value() as u8);
        // D s_1909_16: write-var u#33259 <= s_1909_15
        fn_state.u_33259 = s_1909_15;
        // C s_1909_17: const #12s : i
        let s_1909_17: i128 = 12;
        // C s_1909_18: const #4s : i
        let s_1909_18: i128 = 4;
        // D s_1909_19: read-var u#33257:u32
        let s_1909_19: u32 = fn_state.u_33257;
        // D s_1909_20: cast zx s_1909_19 -> bv
        let s_1909_20: Bits = Bits::new(s_1909_19 as u128, 32u16);
        // D s_1909_21: bit-extract s_1909_20 s_1909_17 s_1909_18
        let s_1909_21: Bits = (Bits::new(
            ((s_1909_20) >> (s_1909_17)).value(),
            u16::try_from(s_1909_18).unwrap(),
        ));
        // D s_1909_22: cast reint s_1909_21 -> u8
        let s_1909_22: u8 = (s_1909_21.value() as u8);
        // D s_1909_23: write-var u#33260 <= s_1909_22
        fn_state.u_33260 = s_1909_22;
        // C s_1909_24: const #0s : i
        let s_1909_24: i128 = 0;
        // C s_1909_25: const #4s : i
        let s_1909_25: i128 = 4;
        // D s_1909_26: read-var u#33257:u32
        let s_1909_26: u32 = fn_state.u_33257;
        // D s_1909_27: cast zx s_1909_26 -> bv
        let s_1909_27: Bits = Bits::new(s_1909_26 as u128, 32u16);
        // D s_1909_28: bit-extract s_1909_27 s_1909_24 s_1909_25
        let s_1909_28: Bits = (Bits::new(
            ((s_1909_27) >> (s_1909_24)).value(),
            u16::try_from(s_1909_25).unwrap(),
        ));
        // D s_1909_29: cast reint s_1909_28 -> u8
        let s_1909_29: u8 = (s_1909_28.value() as u8);
        // D s_1909_30: write-var u#33261 <= s_1909_29
        fn_state.u_33261 = s_1909_29;
        // C s_1909_31: const #8s : i
        let s_1909_31: i128 = 8;
        // D s_1909_32: read-var u#33257:u32
        let s_1909_32: u32 = fn_state.u_33257;
        // D s_1909_33: cast zx s_1909_32 -> bv
        let s_1909_33: Bits = Bits::new(s_1909_32 as u128, 32u16);
        // C s_1909_34: const #1u : u64
        let s_1909_34: u64 = 1;
        // D s_1909_35: bit-extract s_1909_33 s_1909_31 s_1909_34
        let s_1909_35: Bits = (Bits::new(
            ((s_1909_33) >> (s_1909_31)).value(),
            u16::try_from(s_1909_34).unwrap(),
        ));
        // D s_1909_36: cast reint s_1909_35 -> u8
        let s_1909_36: bool = ((s_1909_35.value()) != 0);
        // C s_1909_37: const #0s : i
        let s_1909_37: i128 = 0;
        // C s_1909_38: const #0u : u64
        let s_1909_38: u64 = 0;
        // D s_1909_39: cast zx s_1909_36 -> u64
        let s_1909_39: u64 = (s_1909_36 as u64);
        // C s_1909_40: const #1u : u64
        let s_1909_40: u64 = 1;
        // D s_1909_41: and s_1909_39 s_1909_40
        let s_1909_41: u64 = ((s_1909_39) & (s_1909_40));
        // D s_1909_42: cmp-eq s_1909_41 s_1909_40
        let s_1909_42: bool = ((s_1909_41) == (s_1909_40));
        // D s_1909_43: lsl s_1909_39 s_1909_37
        let s_1909_43: u64 = s_1909_39 << s_1909_37;
        // D s_1909_44: or s_1909_38 s_1909_43
        let s_1909_44: u64 = ((s_1909_38) | (s_1909_43));
        // D s_1909_45: cmpl s_1909_43
        let s_1909_45: u64 = !s_1909_43;
        // D s_1909_46: and s_1909_38 s_1909_45
        let s_1909_46: u64 = ((s_1909_38) & (s_1909_45));
        // D s_1909_47: select s_1909_42 s_1909_44 s_1909_46
        let s_1909_47: u64 = if s_1909_42 { s_1909_44 } else { s_1909_46 };
        // D s_1909_48: cast trunc s_1909_47 -> u8
        let s_1909_48: bool = ((s_1909_47) != 0);
        // D s_1909_49: cast zx s_1909_48 -> bv
        let s_1909_49: Bits = Bits::new(s_1909_48 as u128, 1u16);
        // C s_1909_50: const #1u : u8
        let s_1909_50: bool = true;
        // C s_1909_51: cast zx s_1909_50 -> bv
        let s_1909_51: Bits = Bits::new(s_1909_50 as u128, 1u16);
        // D s_1909_52: cmp-ne s_1909_49 s_1909_51
        let s_1909_52: bool = ((s_1909_49) != (s_1909_51));
        // N s_1909_53: branch s_1909_52 b1914 b1910
        if s_1909_52 {
            return block_1914(state, tracer, fn_state);
        } else {
            return block_1910(state, tracer, fn_state);
        };
    }
    fn block_1910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1910_0: const #9s : i
        let s_1910_0: i128 = 9;
        // D s_1910_1: read-var u#33257:u32
        let s_1910_1: u32 = fn_state.u_33257;
        // D s_1910_2: cast zx s_1910_1 -> bv
        let s_1910_2: Bits = Bits::new(s_1910_1 as u128, 32u16);
        // C s_1910_3: const #1u : u64
        let s_1910_3: u64 = 1;
        // D s_1910_4: bit-extract s_1910_2 s_1910_0 s_1910_3
        let s_1910_4: Bits = (Bits::new(
            ((s_1910_2) >> (s_1910_0)).value(),
            u16::try_from(s_1910_3).unwrap(),
        ));
        // D s_1910_5: cast reint s_1910_4 -> u8
        let s_1910_5: bool = ((s_1910_4.value()) != 0);
        // C s_1910_6: const #0s : i
        let s_1910_6: i128 = 0;
        // C s_1910_7: const #0u : u64
        let s_1910_7: u64 = 0;
        // D s_1910_8: cast zx s_1910_5 -> u64
        let s_1910_8: u64 = (s_1910_5 as u64);
        // C s_1910_9: const #1u : u64
        let s_1910_9: u64 = 1;
        // D s_1910_10: and s_1910_8 s_1910_9
        let s_1910_10: u64 = ((s_1910_8) & (s_1910_9));
        // D s_1910_11: cmp-eq s_1910_10 s_1910_9
        let s_1910_11: bool = ((s_1910_10) == (s_1910_9));
        // D s_1910_12: lsl s_1910_8 s_1910_6
        let s_1910_12: u64 = s_1910_8 << s_1910_6;
        // D s_1910_13: or s_1910_7 s_1910_12
        let s_1910_13: u64 = ((s_1910_7) | (s_1910_12));
        // D s_1910_14: cmpl s_1910_12
        let s_1910_14: u64 = !s_1910_12;
        // D s_1910_15: and s_1910_7 s_1910_14
        let s_1910_15: u64 = ((s_1910_7) & (s_1910_14));
        // D s_1910_16: select s_1910_11 s_1910_13 s_1910_15
        let s_1910_16: u64 = if s_1910_11 { s_1910_13 } else { s_1910_15 };
        // D s_1910_17: cast trunc s_1910_16 -> u8
        let s_1910_17: bool = ((s_1910_16) != 0);
        // D s_1910_18: cast zx s_1910_17 -> bv
        let s_1910_18: Bits = Bits::new(s_1910_17 as u128, 1u16);
        // C s_1910_19: const #1u : u8
        let s_1910_19: bool = true;
        // C s_1910_20: cast zx s_1910_19 -> bv
        let s_1910_20: Bits = Bits::new(s_1910_19 as u128, 1u16);
        // D s_1910_21: cmp-ne s_1910_18 s_1910_20
        let s_1910_21: bool = ((s_1910_18) != (s_1910_20));
        // D s_1910_22: write-var gs#408366 <= s_1910_21
        fn_state.gs_408366 = s_1910_21;
        // N s_1910_23: jump b1911
        return block_1911(state, tracer, fn_state);
    }
    fn block_1911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1911_0: read-var gs#408366:u8
        let s_1911_0: bool = fn_state.gs_408366;
        // N s_1911_1: branch s_1911_0 b1913 b1912
        if s_1911_0 {
            return block_1913(state, tracer, fn_state);
        } else {
            return block_1912(state, tracer, fn_state);
        };
    }
    fn block_1912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1912_0: read-var u#33258:u8
        let s_1912_0: u8 = fn_state.u_33258;
        // D s_1912_1: read-var u#33259:u8
        let s_1912_1: u8 = fn_state.u_33259;
        // D s_1912_2: read-var u#33260:u8
        let s_1912_2: u8 = fn_state.u_33260;
        // D s_1912_3: read-var u#33261:u8
        let s_1912_3: u8 = fn_state.u_33261;
        // D s_1912_4: call decode_aarch32_instrs_STLEXH_A1enc_A_txt(s_1912_0, s_1912_1, s_1912_2, s_1912_3)
        let s_1912_4: () = decode_aarch32_instrs_STLEXH_A1enc_A_txt(
            state,
            tracer,
            s_1912_0,
            s_1912_1,
            s_1912_2,
            s_1912_3,
        );
        // N s_1912_5: return
        return;
    }
    fn block_1913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1913_0: panic
        panic!("{:?}", ());
        // N s_1913_1: return
        return;
    }
    fn block_1914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1914_0: const #1u : u8
        let s_1914_0: bool = true;
        // D s_1914_1: write-var gs#408366 <= s_1914_0
        fn_state.gs_408366 = s_1914_0;
        // N s_1914_2: jump b1911
        return block_1911(state, tracer, fn_state);
    }
    fn block_1915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1915_0: read-var merge#var.1:struct
        let s_1915_0: u32 = fn_state.merge_var._1;
        // D s_1915_1: write-var u#33263 <= s_1915_0
        fn_state.u_33263 = s_1915_0;
        // C s_1915_2: const #20s : i
        let s_1915_2: i128 = 20;
        // D s_1915_3: read-var u#33263:u32
        let s_1915_3: u32 = fn_state.u_33263;
        // D s_1915_4: cast zx s_1915_3 -> bv
        let s_1915_4: Bits = Bits::new(s_1915_3 as u128, 32u16);
        // C s_1915_5: const #1s : i64
        let s_1915_5: i64 = 1;
        // C s_1915_6: cast zx s_1915_5 -> i
        let s_1915_6: i128 = (i128::try_from(s_1915_5).unwrap());
        // C s_1915_7: const #7s : i
        let s_1915_7: i128 = 7;
        // C s_1915_8: add s_1915_7 s_1915_6
        let s_1915_8: i128 = (s_1915_7 + s_1915_6);
        // D s_1915_9: bit-extract s_1915_4 s_1915_2 s_1915_8
        let s_1915_9: Bits = (Bits::new(
            ((s_1915_4) >> (s_1915_2)).value(),
            u16::try_from(s_1915_8).unwrap(),
        ));
        // D s_1915_10: cast reint s_1915_9 -> u8
        let s_1915_10: u8 = (s_1915_9.value() as u8);
        // D s_1915_11: cast zx s_1915_10 -> bv
        let s_1915_11: Bits = Bits::new(s_1915_10 as u128, 8u16);
        // C s_1915_12: const #30u : u8
        let s_1915_12: u8 = 30;
        // C s_1915_13: cast zx s_1915_12 -> bv
        let s_1915_13: Bits = Bits::new(s_1915_12 as u128, 8u16);
        // D s_1915_14: cmp-eq s_1915_11 s_1915_13
        let s_1915_14: bool = ((s_1915_11) == (s_1915_13));
        // N s_1915_15: branch s_1915_14 b2067 b1916
        if s_1915_14 {
            return block_2067(state, tracer, fn_state);
        } else {
            return block_1916(state, tracer, fn_state);
        };
    }
    fn block_1916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1916_0: const #0u : u8
        let s_1916_0: bool = false;
        // D s_1916_1: write-var gs#408372 <= s_1916_0
        fn_state.gs_408372 = s_1916_0;
        // N s_1916_2: jump b1917
        return block_1917(state, tracer, fn_state);
    }
    fn block_1917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1917_0: read-var gs#408372:u8
        let s_1917_0: bool = fn_state.gs_408372;
        // N s_1917_1: branch s_1917_0 b2063 b1918
        if s_1917_0 {
            return block_2063(state, tracer, fn_state);
        } else {
            return block_1918(state, tracer, fn_state);
        };
    }
    fn block_1918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1918_0: const #0u : u8
        let s_1918_0: bool = false;
        // D s_1918_1: write-var gs#408377 <= s_1918_0
        fn_state.gs_408377 = s_1918_0;
        // N s_1918_2: jump b1919
        return block_1919(state, tracer, fn_state);
    }
    fn block_1919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1919_0: read-var gs#408377:u8
        let s_1919_0: bool = fn_state.gs_408377;
        // D s_1919_1: not s_1919_0
        let s_1919_1: bool = !s_1919_0;
        // N s_1919_2: branch s_1919_1 b1938 b1920
        if s_1919_1 {
            return block_1938(state, tracer, fn_state);
        } else {
            return block_1920(state, tracer, fn_state);
        };
    }
    fn block_1920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1920_0: const #3864s : i
        let s_1920_0: i128 = 3864;
        // C s_1920_1: const #14696u : u32
        let s_1920_1: u32 = 14696;
        // N s_1920_2: write-reg s_1920_1 <= s_1920_0
        let s_1920_2: () = {
            state.write_register::<i128>(s_1920_1 as isize, s_1920_0);
            tracer.write_register(s_1920_1 as isize, s_1920_0);
        };
        // C s_1920_3: const #28s : i
        let s_1920_3: i128 = 28;
        // C s_1920_4: const #4s : i
        let s_1920_4: i128 = 4;
        // D s_1920_5: read-var u#33263:u32
        let s_1920_5: u32 = fn_state.u_33263;
        // D s_1920_6: cast zx s_1920_5 -> bv
        let s_1920_6: Bits = Bits::new(s_1920_5 as u128, 32u16);
        // D s_1920_7: bit-extract s_1920_6 s_1920_3 s_1920_4
        let s_1920_7: Bits = (Bits::new(
            ((s_1920_6) >> (s_1920_3)).value(),
            u16::try_from(s_1920_4).unwrap(),
        ));
        // D s_1920_8: cast reint s_1920_7 -> u8
        let s_1920_8: u8 = (s_1920_7.value() as u8);
        // D s_1920_9: write-var u#33264 <= s_1920_8
        fn_state.u_33264 = s_1920_8;
        // C s_1920_10: const #16s : i
        let s_1920_10: i128 = 16;
        // C s_1920_11: const #4s : i
        let s_1920_11: i128 = 4;
        // D s_1920_12: read-var u#33263:u32
        let s_1920_12: u32 = fn_state.u_33263;
        // D s_1920_13: cast zx s_1920_12 -> bv
        let s_1920_13: Bits = Bits::new(s_1920_12 as u128, 32u16);
        // D s_1920_14: bit-extract s_1920_13 s_1920_10 s_1920_11
        let s_1920_14: Bits = (Bits::new(
            ((s_1920_13) >> (s_1920_10)).value(),
            u16::try_from(s_1920_11).unwrap(),
        ));
        // D s_1920_15: cast reint s_1920_14 -> u8
        let s_1920_15: u8 = (s_1920_14.value() as u8);
        // D s_1920_16: write-var u#33265 <= s_1920_15
        fn_state.u_33265 = s_1920_15;
        // C s_1920_17: const #0s : i
        let s_1920_17: i128 = 0;
        // C s_1920_18: const #4s : i
        let s_1920_18: i128 = 4;
        // D s_1920_19: read-var u#33263:u32
        let s_1920_19: u32 = fn_state.u_33263;
        // D s_1920_20: cast zx s_1920_19 -> bv
        let s_1920_20: Bits = Bits::new(s_1920_19 as u128, 32u16);
        // D s_1920_21: bit-extract s_1920_20 s_1920_17 s_1920_18
        let s_1920_21: Bits = (Bits::new(
            ((s_1920_20) >> (s_1920_17)).value(),
            u16::try_from(s_1920_18).unwrap(),
        ));
        // D s_1920_22: cast reint s_1920_21 -> u8
        let s_1920_22: u8 = (s_1920_21.value() as u8);
        // D s_1920_23: write-var u#33266 <= s_1920_22
        fn_state.u_33266 = s_1920_22;
        // C s_1920_24: const #12s : i
        let s_1920_24: i128 = 12;
        // D s_1920_25: read-var u#33263:u32
        let s_1920_25: u32 = fn_state.u_33263;
        // D s_1920_26: cast zx s_1920_25 -> bv
        let s_1920_26: Bits = Bits::new(s_1920_25 as u128, 32u16);
        // C s_1920_27: const #1u : u64
        let s_1920_27: u64 = 1;
        // D s_1920_28: bit-extract s_1920_26 s_1920_24 s_1920_27
        let s_1920_28: Bits = (Bits::new(
            ((s_1920_26) >> (s_1920_24)).value(),
            u16::try_from(s_1920_27).unwrap(),
        ));
        // D s_1920_29: cast reint s_1920_28 -> u8
        let s_1920_29: bool = ((s_1920_28.value()) != 0);
        // C s_1920_30: const #0s : i
        let s_1920_30: i128 = 0;
        // C s_1920_31: const #0u : u64
        let s_1920_31: u64 = 0;
        // D s_1920_32: cast zx s_1920_29 -> u64
        let s_1920_32: u64 = (s_1920_29 as u64);
        // C s_1920_33: const #1u : u64
        let s_1920_33: u64 = 1;
        // D s_1920_34: and s_1920_32 s_1920_33
        let s_1920_34: u64 = ((s_1920_32) & (s_1920_33));
        // D s_1920_35: cmp-eq s_1920_34 s_1920_33
        let s_1920_35: bool = ((s_1920_34) == (s_1920_33));
        // D s_1920_36: lsl s_1920_32 s_1920_30
        let s_1920_36: u64 = s_1920_32 << s_1920_30;
        // D s_1920_37: or s_1920_31 s_1920_36
        let s_1920_37: u64 = ((s_1920_31) | (s_1920_36));
        // D s_1920_38: cmpl s_1920_36
        let s_1920_38: u64 = !s_1920_36;
        // D s_1920_39: and s_1920_31 s_1920_38
        let s_1920_39: u64 = ((s_1920_31) & (s_1920_38));
        // D s_1920_40: select s_1920_35 s_1920_37 s_1920_39
        let s_1920_40: u64 = if s_1920_35 { s_1920_37 } else { s_1920_39 };
        // D s_1920_41: cast trunc s_1920_40 -> u8
        let s_1920_41: bool = ((s_1920_40) != 0);
        // D s_1920_42: cast zx s_1920_41 -> bv
        let s_1920_42: Bits = Bits::new(s_1920_41 as u128, 1u16);
        // C s_1920_43: const #1u : u8
        let s_1920_43: bool = true;
        // C s_1920_44: cast zx s_1920_43 -> bv
        let s_1920_44: Bits = Bits::new(s_1920_43 as u128, 1u16);
        // D s_1920_45: cmp-ne s_1920_42 s_1920_44
        let s_1920_45: bool = ((s_1920_42) != (s_1920_44));
        // N s_1920_46: branch s_1920_45 b1937 b1921
        if s_1920_45 {
            return block_1937(state, tracer, fn_state);
        } else {
            return block_1921(state, tracer, fn_state);
        };
    }
    fn block_1921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1921_0: const #13s : i
        let s_1921_0: i128 = 13;
        // D s_1921_1: read-var u#33263:u32
        let s_1921_1: u32 = fn_state.u_33263;
        // D s_1921_2: cast zx s_1921_1 -> bv
        let s_1921_2: Bits = Bits::new(s_1921_1 as u128, 32u16);
        // C s_1921_3: const #1u : u64
        let s_1921_3: u64 = 1;
        // D s_1921_4: bit-extract s_1921_2 s_1921_0 s_1921_3
        let s_1921_4: Bits = (Bits::new(
            ((s_1921_2) >> (s_1921_0)).value(),
            u16::try_from(s_1921_3).unwrap(),
        ));
        // D s_1921_5: cast reint s_1921_4 -> u8
        let s_1921_5: bool = ((s_1921_4.value()) != 0);
        // C s_1921_6: const #0s : i
        let s_1921_6: i128 = 0;
        // C s_1921_7: const #0u : u64
        let s_1921_7: u64 = 0;
        // D s_1921_8: cast zx s_1921_5 -> u64
        let s_1921_8: u64 = (s_1921_5 as u64);
        // C s_1921_9: const #1u : u64
        let s_1921_9: u64 = 1;
        // D s_1921_10: and s_1921_8 s_1921_9
        let s_1921_10: u64 = ((s_1921_8) & (s_1921_9));
        // D s_1921_11: cmp-eq s_1921_10 s_1921_9
        let s_1921_11: bool = ((s_1921_10) == (s_1921_9));
        // D s_1921_12: lsl s_1921_8 s_1921_6
        let s_1921_12: u64 = s_1921_8 << s_1921_6;
        // D s_1921_13: or s_1921_7 s_1921_12
        let s_1921_13: u64 = ((s_1921_7) | (s_1921_12));
        // D s_1921_14: cmpl s_1921_12
        let s_1921_14: u64 = !s_1921_12;
        // D s_1921_15: and s_1921_7 s_1921_14
        let s_1921_15: u64 = ((s_1921_7) & (s_1921_14));
        // D s_1921_16: select s_1921_11 s_1921_13 s_1921_15
        let s_1921_16: u64 = if s_1921_11 { s_1921_13 } else { s_1921_15 };
        // D s_1921_17: cast trunc s_1921_16 -> u8
        let s_1921_17: bool = ((s_1921_16) != 0);
        // D s_1921_18: cast zx s_1921_17 -> bv
        let s_1921_18: Bits = Bits::new(s_1921_17 as u128, 1u16);
        // C s_1921_19: const #1u : u8
        let s_1921_19: bool = true;
        // C s_1921_20: cast zx s_1921_19 -> bv
        let s_1921_20: Bits = Bits::new(s_1921_19 as u128, 1u16);
        // D s_1921_21: cmp-ne s_1921_18 s_1921_20
        let s_1921_21: bool = ((s_1921_18) != (s_1921_20));
        // D s_1921_22: write-var gs#408390 <= s_1921_21
        fn_state.gs_408390 = s_1921_21;
        // N s_1921_23: jump b1922
        return block_1922(state, tracer, fn_state);
    }
    fn block_1922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1922_0: read-var gs#408390:u8
        let s_1922_0: bool = fn_state.gs_408390;
        // N s_1922_1: branch s_1922_0 b1936 b1923
        if s_1922_0 {
            return block_1936(state, tracer, fn_state);
        } else {
            return block_1923(state, tracer, fn_state);
        };
    }
    fn block_1923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1923_0: const #14s : i
        let s_1923_0: i128 = 14;
        // D s_1923_1: read-var u#33263:u32
        let s_1923_1: u32 = fn_state.u_33263;
        // D s_1923_2: cast zx s_1923_1 -> bv
        let s_1923_2: Bits = Bits::new(s_1923_1 as u128, 32u16);
        // C s_1923_3: const #1u : u64
        let s_1923_3: u64 = 1;
        // D s_1923_4: bit-extract s_1923_2 s_1923_0 s_1923_3
        let s_1923_4: Bits = (Bits::new(
            ((s_1923_2) >> (s_1923_0)).value(),
            u16::try_from(s_1923_3).unwrap(),
        ));
        // D s_1923_5: cast reint s_1923_4 -> u8
        let s_1923_5: bool = ((s_1923_4.value()) != 0);
        // C s_1923_6: const #0s : i
        let s_1923_6: i128 = 0;
        // C s_1923_7: const #0u : u64
        let s_1923_7: u64 = 0;
        // D s_1923_8: cast zx s_1923_5 -> u64
        let s_1923_8: u64 = (s_1923_5 as u64);
        // C s_1923_9: const #1u : u64
        let s_1923_9: u64 = 1;
        // D s_1923_10: and s_1923_8 s_1923_9
        let s_1923_10: u64 = ((s_1923_8) & (s_1923_9));
        // D s_1923_11: cmp-eq s_1923_10 s_1923_9
        let s_1923_11: bool = ((s_1923_10) == (s_1923_9));
        // D s_1923_12: lsl s_1923_8 s_1923_6
        let s_1923_12: u64 = s_1923_8 << s_1923_6;
        // D s_1923_13: or s_1923_7 s_1923_12
        let s_1923_13: u64 = ((s_1923_7) | (s_1923_12));
        // D s_1923_14: cmpl s_1923_12
        let s_1923_14: u64 = !s_1923_12;
        // D s_1923_15: and s_1923_7 s_1923_14
        let s_1923_15: u64 = ((s_1923_7) & (s_1923_14));
        // D s_1923_16: select s_1923_11 s_1923_13 s_1923_15
        let s_1923_16: u64 = if s_1923_11 { s_1923_13 } else { s_1923_15 };
        // D s_1923_17: cast trunc s_1923_16 -> u8
        let s_1923_17: bool = ((s_1923_16) != 0);
        // D s_1923_18: cast zx s_1923_17 -> bv
        let s_1923_18: Bits = Bits::new(s_1923_17 as u128, 1u16);
        // C s_1923_19: const #1u : u8
        let s_1923_19: bool = true;
        // C s_1923_20: cast zx s_1923_19 -> bv
        let s_1923_20: Bits = Bits::new(s_1923_19 as u128, 1u16);
        // D s_1923_21: cmp-ne s_1923_18 s_1923_20
        let s_1923_21: bool = ((s_1923_18) != (s_1923_20));
        // D s_1923_22: write-var gs#408393 <= s_1923_21
        fn_state.gs_408393 = s_1923_21;
        // N s_1923_23: jump b1924
        return block_1924(state, tracer, fn_state);
    }
    fn block_1924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1924_0: read-var gs#408393:u8
        let s_1924_0: bool = fn_state.gs_408393;
        // N s_1924_1: branch s_1924_0 b1935 b1925
        if s_1924_0 {
            return block_1935(state, tracer, fn_state);
        } else {
            return block_1925(state, tracer, fn_state);
        };
    }
    fn block_1925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1925_0: const #15s : i
        let s_1925_0: i128 = 15;
        // D s_1925_1: read-var u#33263:u32
        let s_1925_1: u32 = fn_state.u_33263;
        // D s_1925_2: cast zx s_1925_1 -> bv
        let s_1925_2: Bits = Bits::new(s_1925_1 as u128, 32u16);
        // C s_1925_3: const #1u : u64
        let s_1925_3: u64 = 1;
        // D s_1925_4: bit-extract s_1925_2 s_1925_0 s_1925_3
        let s_1925_4: Bits = (Bits::new(
            ((s_1925_2) >> (s_1925_0)).value(),
            u16::try_from(s_1925_3).unwrap(),
        ));
        // D s_1925_5: cast reint s_1925_4 -> u8
        let s_1925_5: bool = ((s_1925_4.value()) != 0);
        // C s_1925_6: const #0s : i
        let s_1925_6: i128 = 0;
        // C s_1925_7: const #0u : u64
        let s_1925_7: u64 = 0;
        // D s_1925_8: cast zx s_1925_5 -> u64
        let s_1925_8: u64 = (s_1925_5 as u64);
        // C s_1925_9: const #1u : u64
        let s_1925_9: u64 = 1;
        // D s_1925_10: and s_1925_8 s_1925_9
        let s_1925_10: u64 = ((s_1925_8) & (s_1925_9));
        // D s_1925_11: cmp-eq s_1925_10 s_1925_9
        let s_1925_11: bool = ((s_1925_10) == (s_1925_9));
        // D s_1925_12: lsl s_1925_8 s_1925_6
        let s_1925_12: u64 = s_1925_8 << s_1925_6;
        // D s_1925_13: or s_1925_7 s_1925_12
        let s_1925_13: u64 = ((s_1925_7) | (s_1925_12));
        // D s_1925_14: cmpl s_1925_12
        let s_1925_14: u64 = !s_1925_12;
        // D s_1925_15: and s_1925_7 s_1925_14
        let s_1925_15: u64 = ((s_1925_7) & (s_1925_14));
        // D s_1925_16: select s_1925_11 s_1925_13 s_1925_15
        let s_1925_16: u64 = if s_1925_11 { s_1925_13 } else { s_1925_15 };
        // D s_1925_17: cast trunc s_1925_16 -> u8
        let s_1925_17: bool = ((s_1925_16) != 0);
        // D s_1925_18: cast zx s_1925_17 -> bv
        let s_1925_18: Bits = Bits::new(s_1925_17 as u128, 1u16);
        // C s_1925_19: const #1u : u8
        let s_1925_19: bool = true;
        // C s_1925_20: cast zx s_1925_19 -> bv
        let s_1925_20: Bits = Bits::new(s_1925_19 as u128, 1u16);
        // D s_1925_21: cmp-ne s_1925_18 s_1925_20
        let s_1925_21: bool = ((s_1925_18) != (s_1925_20));
        // D s_1925_22: write-var gs#408396 <= s_1925_21
        fn_state.gs_408396 = s_1925_21;
        // N s_1925_23: jump b1926
        return block_1926(state, tracer, fn_state);
    }
    fn block_1926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1926_0: read-var gs#408396:u8
        let s_1926_0: bool = fn_state.gs_408396;
        // N s_1926_1: branch s_1926_0 b1934 b1927
        if s_1926_0 {
            return block_1934(state, tracer, fn_state);
        } else {
            return block_1927(state, tracer, fn_state);
        };
    }
    fn block_1927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1927_0: const #8s : i
        let s_1927_0: i128 = 8;
        // D s_1927_1: read-var u#33263:u32
        let s_1927_1: u32 = fn_state.u_33263;
        // D s_1927_2: cast zx s_1927_1 -> bv
        let s_1927_2: Bits = Bits::new(s_1927_1 as u128, 32u16);
        // C s_1927_3: const #1u : u64
        let s_1927_3: u64 = 1;
        // D s_1927_4: bit-extract s_1927_2 s_1927_0 s_1927_3
        let s_1927_4: Bits = (Bits::new(
            ((s_1927_2) >> (s_1927_0)).value(),
            u16::try_from(s_1927_3).unwrap(),
        ));
        // D s_1927_5: cast reint s_1927_4 -> u8
        let s_1927_5: bool = ((s_1927_4.value()) != 0);
        // C s_1927_6: const #0s : i
        let s_1927_6: i128 = 0;
        // C s_1927_7: const #0u : u64
        let s_1927_7: u64 = 0;
        // D s_1927_8: cast zx s_1927_5 -> u64
        let s_1927_8: u64 = (s_1927_5 as u64);
        // C s_1927_9: const #1u : u64
        let s_1927_9: u64 = 1;
        // D s_1927_10: and s_1927_8 s_1927_9
        let s_1927_10: u64 = ((s_1927_8) & (s_1927_9));
        // D s_1927_11: cmp-eq s_1927_10 s_1927_9
        let s_1927_11: bool = ((s_1927_10) == (s_1927_9));
        // D s_1927_12: lsl s_1927_8 s_1927_6
        let s_1927_12: u64 = s_1927_8 << s_1927_6;
        // D s_1927_13: or s_1927_7 s_1927_12
        let s_1927_13: u64 = ((s_1927_7) | (s_1927_12));
        // D s_1927_14: cmpl s_1927_12
        let s_1927_14: u64 = !s_1927_12;
        // D s_1927_15: and s_1927_7 s_1927_14
        let s_1927_15: u64 = ((s_1927_7) & (s_1927_14));
        // D s_1927_16: select s_1927_11 s_1927_13 s_1927_15
        let s_1927_16: u64 = if s_1927_11 { s_1927_13 } else { s_1927_15 };
        // D s_1927_17: cast trunc s_1927_16 -> u8
        let s_1927_17: bool = ((s_1927_16) != 0);
        // D s_1927_18: cast zx s_1927_17 -> bv
        let s_1927_18: Bits = Bits::new(s_1927_17 as u128, 1u16);
        // C s_1927_19: const #1u : u8
        let s_1927_19: bool = true;
        // C s_1927_20: cast zx s_1927_19 -> bv
        let s_1927_20: Bits = Bits::new(s_1927_19 as u128, 1u16);
        // D s_1927_21: cmp-ne s_1927_18 s_1927_20
        let s_1927_21: bool = ((s_1927_18) != (s_1927_20));
        // D s_1927_22: write-var gs#408399 <= s_1927_21
        fn_state.gs_408399 = s_1927_21;
        // N s_1927_23: jump b1928
        return block_1928(state, tracer, fn_state);
    }
    fn block_1928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1928_0: read-var gs#408399:u8
        let s_1928_0: bool = fn_state.gs_408399;
        // N s_1928_1: branch s_1928_0 b1933 b1929
        if s_1928_0 {
            return block_1933(state, tracer, fn_state);
        } else {
            return block_1929(state, tracer, fn_state);
        };
    }
    fn block_1929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1929_0: const #9s : i
        let s_1929_0: i128 = 9;
        // D s_1929_1: read-var u#33263:u32
        let s_1929_1: u32 = fn_state.u_33263;
        // D s_1929_2: cast zx s_1929_1 -> bv
        let s_1929_2: Bits = Bits::new(s_1929_1 as u128, 32u16);
        // C s_1929_3: const #1u : u64
        let s_1929_3: u64 = 1;
        // D s_1929_4: bit-extract s_1929_2 s_1929_0 s_1929_3
        let s_1929_4: Bits = (Bits::new(
            ((s_1929_2) >> (s_1929_0)).value(),
            u16::try_from(s_1929_3).unwrap(),
        ));
        // D s_1929_5: cast reint s_1929_4 -> u8
        let s_1929_5: bool = ((s_1929_4.value()) != 0);
        // C s_1929_6: const #0s : i
        let s_1929_6: i128 = 0;
        // C s_1929_7: const #0u : u64
        let s_1929_7: u64 = 0;
        // D s_1929_8: cast zx s_1929_5 -> u64
        let s_1929_8: u64 = (s_1929_5 as u64);
        // C s_1929_9: const #1u : u64
        let s_1929_9: u64 = 1;
        // D s_1929_10: and s_1929_8 s_1929_9
        let s_1929_10: u64 = ((s_1929_8) & (s_1929_9));
        // D s_1929_11: cmp-eq s_1929_10 s_1929_9
        let s_1929_11: bool = ((s_1929_10) == (s_1929_9));
        // D s_1929_12: lsl s_1929_8 s_1929_6
        let s_1929_12: u64 = s_1929_8 << s_1929_6;
        // D s_1929_13: or s_1929_7 s_1929_12
        let s_1929_13: u64 = ((s_1929_7) | (s_1929_12));
        // D s_1929_14: cmpl s_1929_12
        let s_1929_14: u64 = !s_1929_12;
        // D s_1929_15: and s_1929_7 s_1929_14
        let s_1929_15: u64 = ((s_1929_7) & (s_1929_14));
        // D s_1929_16: select s_1929_11 s_1929_13 s_1929_15
        let s_1929_16: u64 = if s_1929_11 { s_1929_13 } else { s_1929_15 };
        // D s_1929_17: cast trunc s_1929_16 -> u8
        let s_1929_17: bool = ((s_1929_16) != 0);
        // D s_1929_18: cast zx s_1929_17 -> bv
        let s_1929_18: Bits = Bits::new(s_1929_17 as u128, 1u16);
        // C s_1929_19: const #1u : u8
        let s_1929_19: bool = true;
        // C s_1929_20: cast zx s_1929_19 -> bv
        let s_1929_20: Bits = Bits::new(s_1929_19 as u128, 1u16);
        // D s_1929_21: cmp-ne s_1929_18 s_1929_20
        let s_1929_21: bool = ((s_1929_18) != (s_1929_20));
        // D s_1929_22: write-var gs#408402 <= s_1929_21
        fn_state.gs_408402 = s_1929_21;
        // N s_1929_23: jump b1930
        return block_1930(state, tracer, fn_state);
    }
    fn block_1930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1930_0: read-var gs#408402:u8
        let s_1930_0: bool = fn_state.gs_408402;
        // N s_1930_1: branch s_1930_0 b1932 b1931
        if s_1930_0 {
            return block_1932(state, tracer, fn_state);
        } else {
            return block_1931(state, tracer, fn_state);
        };
    }
    fn block_1931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1931_0: read-var u#33264:u8
        let s_1931_0: u8 = fn_state.u_33264;
        // D s_1931_1: read-var u#33265:u8
        let s_1931_1: u8 = fn_state.u_33265;
        // D s_1931_2: read-var u#33266:u8
        let s_1931_2: u8 = fn_state.u_33266;
        // D s_1931_3: call decode_aarch32_instrs_STLH_A1enc_A_txt(s_1931_0, s_1931_1, s_1931_2)
        let s_1931_3: () = decode_aarch32_instrs_STLH_A1enc_A_txt(
            state,
            tracer,
            s_1931_0,
            s_1931_1,
            s_1931_2,
        );
        // N s_1931_4: return
        return;
    }
    fn block_1932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1932_0: panic
        panic!("{:?}", ());
        // N s_1932_1: return
        return;
    }
    fn block_1933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1933_0: const #1u : u8
        let s_1933_0: bool = true;
        // D s_1933_1: write-var gs#408402 <= s_1933_0
        fn_state.gs_408402 = s_1933_0;
        // N s_1933_2: jump b1930
        return block_1930(state, tracer, fn_state);
    }
    fn block_1934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1934_0: const #1u : u8
        let s_1934_0: bool = true;
        // D s_1934_1: write-var gs#408399 <= s_1934_0
        fn_state.gs_408399 = s_1934_0;
        // N s_1934_2: jump b1928
        return block_1928(state, tracer, fn_state);
    }
    fn block_1935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1935_0: const #1u : u8
        let s_1935_0: bool = true;
        // D s_1935_1: write-var gs#408396 <= s_1935_0
        fn_state.gs_408396 = s_1935_0;
        // N s_1935_2: jump b1926
        return block_1926(state, tracer, fn_state);
    }
    fn block_1936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1936_0: const #1u : u8
        let s_1936_0: bool = true;
        // D s_1936_1: write-var gs#408393 <= s_1936_0
        fn_state.gs_408393 = s_1936_0;
        // N s_1936_2: jump b1924
        return block_1924(state, tracer, fn_state);
    }
    fn block_1937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1937_0: const #1u : u8
        let s_1937_0: bool = true;
        // D s_1937_1: write-var gs#408390 <= s_1937_0
        fn_state.gs_408390 = s_1937_0;
        // N s_1937_2: jump b1922
        return block_1922(state, tracer, fn_state);
    }
    fn block_1938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1938_0: read-var merge#var.1:struct
        let s_1938_0: u32 = fn_state.merge_var._1;
        // D s_1938_1: write-var u#33268 <= s_1938_0
        fn_state.u_33268 = s_1938_0;
        // C s_1938_2: const #0s : i
        let s_1938_2: i128 = 0;
        // D s_1938_3: read-var u#33268:u32
        let s_1938_3: u32 = fn_state.u_33268;
        // D s_1938_4: cast zx s_1938_3 -> bv
        let s_1938_4: Bits = Bits::new(s_1938_3 as u128, 32u16);
        // C s_1938_5: const #1s : i64
        let s_1938_5: i64 = 1;
        // C s_1938_6: cast zx s_1938_5 -> i
        let s_1938_6: i128 = (i128::try_from(s_1938_5).unwrap());
        // C s_1938_7: const #27s : i
        let s_1938_7: i128 = 27;
        // C s_1938_8: add s_1938_7 s_1938_6
        let s_1938_8: i128 = (s_1938_7 + s_1938_6);
        // D s_1938_9: bit-extract s_1938_4 s_1938_2 s_1938_8
        let s_1938_9: Bits = (Bits::new(
            ((s_1938_4) >> (s_1938_2)).value(),
            u16::try_from(s_1938_8).unwrap(),
        ));
        // D s_1938_10: cast reint s_1938_9 -> u28
        let s_1938_10: u32 = (s_1938_9.value() as u32);
        // D s_1938_11: cast zx s_1938_10 -> bv
        let s_1938_11: Bits = Bits::new(s_1938_10 as u128, 28u16);
        // C s_1938_12: const #52490256u : u28
        let s_1938_12: u32 = 52490256;
        // C s_1938_13: cast zx s_1938_12 -> bv
        let s_1938_13: Bits = Bits::new(s_1938_12 as u128, 28u16);
        // D s_1938_14: cmp-eq s_1938_11 s_1938_13
        let s_1938_14: bool = ((s_1938_11) == (s_1938_13));
        // N s_1938_15: branch s_1938_14 b2059 b1939
        if s_1938_14 {
            return block_2059(state, tracer, fn_state);
        } else {
            return block_1939(state, tracer, fn_state);
        };
    }
    fn block_1939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1939_0: const #0u : u8
        let s_1939_0: bool = false;
        // D s_1939_1: write-var gs#408410 <= s_1939_0
        fn_state.gs_408410 = s_1939_0;
        // N s_1939_2: jump b1940
        return block_1940(state, tracer, fn_state);
    }
    fn block_1940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1940_0: read-var gs#408410:u8
        let s_1940_0: bool = fn_state.gs_408410;
        // D s_1940_1: not s_1940_0
        let s_1940_1: bool = !s_1940_0;
        // N s_1940_2: branch s_1940_1 b1965 b1941
        if s_1940_1 {
            return block_1965(state, tracer, fn_state);
        } else {
            return block_1941(state, tracer, fn_state);
        };
    }
    fn block_1941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1941_0: const #3890s : i
        let s_1941_0: i128 = 3890;
        // C s_1941_1: const #14696u : u32
        let s_1941_1: u32 = 14696;
        // N s_1941_2: write-reg s_1941_1 <= s_1941_0
        let s_1941_2: () = {
            state.write_register::<i128>(s_1941_1 as isize, s_1941_0);
            tracer.write_register(s_1941_1 as isize, s_1941_0);
        };
        // C s_1941_3: const #28s : i
        let s_1941_3: i128 = 28;
        // C s_1941_4: const #4s : i
        let s_1941_4: i128 = 4;
        // D s_1941_5: read-var u#33268:u32
        let s_1941_5: u32 = fn_state.u_33268;
        // D s_1941_6: cast zx s_1941_5 -> bv
        let s_1941_6: Bits = Bits::new(s_1941_5 as u128, 32u16);
        // D s_1941_7: bit-extract s_1941_6 s_1941_3 s_1941_4
        let s_1941_7: Bits = (Bits::new(
            ((s_1941_6) >> (s_1941_3)).value(),
            u16::try_from(s_1941_4).unwrap(),
        ));
        // D s_1941_8: cast reint s_1941_7 -> u8
        let s_1941_8: u8 = (s_1941_7.value() as u8);
        // D s_1941_9: write-var u#33269 <= s_1941_8
        fn_state.u_33269 = s_1941_8;
        // C s_1941_10: const #8s : i
        let s_1941_10: i128 = 8;
        // D s_1941_11: read-var u#33268:u32
        let s_1941_11: u32 = fn_state.u_33268;
        // D s_1941_12: cast zx s_1941_11 -> bv
        let s_1941_12: Bits = Bits::new(s_1941_11 as u128, 32u16);
        // C s_1941_13: const #1u : u64
        let s_1941_13: u64 = 1;
        // D s_1941_14: bit-extract s_1941_12 s_1941_10 s_1941_13
        let s_1941_14: Bits = (Bits::new(
            ((s_1941_12) >> (s_1941_10)).value(),
            u16::try_from(s_1941_13).unwrap(),
        ));
        // D s_1941_15: cast reint s_1941_14 -> u8
        let s_1941_15: bool = ((s_1941_14.value()) != 0);
        // C s_1941_16: const #0s : i
        let s_1941_16: i128 = 0;
        // C s_1941_17: const #0u : u64
        let s_1941_17: u64 = 0;
        // D s_1941_18: cast zx s_1941_15 -> u64
        let s_1941_18: u64 = (s_1941_15 as u64);
        // C s_1941_19: const #1u : u64
        let s_1941_19: u64 = 1;
        // D s_1941_20: and s_1941_18 s_1941_19
        let s_1941_20: u64 = ((s_1941_18) & (s_1941_19));
        // D s_1941_21: cmp-eq s_1941_20 s_1941_19
        let s_1941_21: bool = ((s_1941_20) == (s_1941_19));
        // D s_1941_22: lsl s_1941_18 s_1941_16
        let s_1941_22: u64 = s_1941_18 << s_1941_16;
        // D s_1941_23: or s_1941_17 s_1941_22
        let s_1941_23: u64 = ((s_1941_17) | (s_1941_22));
        // D s_1941_24: cmpl s_1941_22
        let s_1941_24: u64 = !s_1941_22;
        // D s_1941_25: and s_1941_17 s_1941_24
        let s_1941_25: u64 = ((s_1941_17) & (s_1941_24));
        // D s_1941_26: select s_1941_21 s_1941_23 s_1941_25
        let s_1941_26: u64 = if s_1941_21 { s_1941_23 } else { s_1941_25 };
        // D s_1941_27: cast trunc s_1941_26 -> u8
        let s_1941_27: bool = ((s_1941_26) != 0);
        // D s_1941_28: cast zx s_1941_27 -> bv
        let s_1941_28: Bits = Bits::new(s_1941_27 as u128, 1u16);
        // C s_1941_29: const #1u : u8
        let s_1941_29: bool = true;
        // C s_1941_30: cast zx s_1941_29 -> bv
        let s_1941_30: Bits = Bits::new(s_1941_29 as u128, 1u16);
        // D s_1941_31: cmp-ne s_1941_28 s_1941_30
        let s_1941_31: bool = ((s_1941_28) != (s_1941_30));
        // N s_1941_32: branch s_1941_31 b1964 b1942
        if s_1941_31 {
            return block_1964(state, tracer, fn_state);
        } else {
            return block_1942(state, tracer, fn_state);
        };
    }
    fn block_1942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1942_0: const #9s : i
        let s_1942_0: i128 = 9;
        // D s_1942_1: read-var u#33268:u32
        let s_1942_1: u32 = fn_state.u_33268;
        // D s_1942_2: cast zx s_1942_1 -> bv
        let s_1942_2: Bits = Bits::new(s_1942_1 as u128, 32u16);
        // C s_1942_3: const #1u : u64
        let s_1942_3: u64 = 1;
        // D s_1942_4: bit-extract s_1942_2 s_1942_0 s_1942_3
        let s_1942_4: Bits = (Bits::new(
            ((s_1942_2) >> (s_1942_0)).value(),
            u16::try_from(s_1942_3).unwrap(),
        ));
        // D s_1942_5: cast reint s_1942_4 -> u8
        let s_1942_5: bool = ((s_1942_4.value()) != 0);
        // C s_1942_6: const #0s : i
        let s_1942_6: i128 = 0;
        // C s_1942_7: const #0u : u64
        let s_1942_7: u64 = 0;
        // D s_1942_8: cast zx s_1942_5 -> u64
        let s_1942_8: u64 = (s_1942_5 as u64);
        // C s_1942_9: const #1u : u64
        let s_1942_9: u64 = 1;
        // D s_1942_10: and s_1942_8 s_1942_9
        let s_1942_10: u64 = ((s_1942_8) & (s_1942_9));
        // D s_1942_11: cmp-eq s_1942_10 s_1942_9
        let s_1942_11: bool = ((s_1942_10) == (s_1942_9));
        // D s_1942_12: lsl s_1942_8 s_1942_6
        let s_1942_12: u64 = s_1942_8 << s_1942_6;
        // D s_1942_13: or s_1942_7 s_1942_12
        let s_1942_13: u64 = ((s_1942_7) | (s_1942_12));
        // D s_1942_14: cmpl s_1942_12
        let s_1942_14: u64 = !s_1942_12;
        // D s_1942_15: and s_1942_7 s_1942_14
        let s_1942_15: u64 = ((s_1942_7) & (s_1942_14));
        // D s_1942_16: select s_1942_11 s_1942_13 s_1942_15
        let s_1942_16: u64 = if s_1942_11 { s_1942_13 } else { s_1942_15 };
        // D s_1942_17: cast trunc s_1942_16 -> u8
        let s_1942_17: bool = ((s_1942_16) != 0);
        // D s_1942_18: cast zx s_1942_17 -> bv
        let s_1942_18: Bits = Bits::new(s_1942_17 as u128, 1u16);
        // C s_1942_19: const #1u : u8
        let s_1942_19: bool = true;
        // C s_1942_20: cast zx s_1942_19 -> bv
        let s_1942_20: Bits = Bits::new(s_1942_19 as u128, 1u16);
        // D s_1942_21: cmp-ne s_1942_18 s_1942_20
        let s_1942_21: bool = ((s_1942_18) != (s_1942_20));
        // D s_1942_22: write-var gs#408419 <= s_1942_21
        fn_state.gs_408419 = s_1942_21;
        // N s_1942_23: jump b1943
        return block_1943(state, tracer, fn_state);
    }
    fn block_1943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1943_0: read-var gs#408419:u8
        let s_1943_0: bool = fn_state.gs_408419;
        // N s_1943_1: branch s_1943_0 b1963 b1944
        if s_1943_0 {
            return block_1963(state, tracer, fn_state);
        } else {
            return block_1944(state, tracer, fn_state);
        };
    }
    fn block_1944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1944_0: const #10s : i
        let s_1944_0: i128 = 10;
        // D s_1944_1: read-var u#33268:u32
        let s_1944_1: u32 = fn_state.u_33268;
        // D s_1944_2: cast zx s_1944_1 -> bv
        let s_1944_2: Bits = Bits::new(s_1944_1 as u128, 32u16);
        // C s_1944_3: const #1u : u64
        let s_1944_3: u64 = 1;
        // D s_1944_4: bit-extract s_1944_2 s_1944_0 s_1944_3
        let s_1944_4: Bits = (Bits::new(
            ((s_1944_2) >> (s_1944_0)).value(),
            u16::try_from(s_1944_3).unwrap(),
        ));
        // D s_1944_5: cast reint s_1944_4 -> u8
        let s_1944_5: bool = ((s_1944_4.value()) != 0);
        // C s_1944_6: const #0s : i
        let s_1944_6: i128 = 0;
        // C s_1944_7: const #0u : u64
        let s_1944_7: u64 = 0;
        // D s_1944_8: cast zx s_1944_5 -> u64
        let s_1944_8: u64 = (s_1944_5 as u64);
        // C s_1944_9: const #1u : u64
        let s_1944_9: u64 = 1;
        // D s_1944_10: and s_1944_8 s_1944_9
        let s_1944_10: u64 = ((s_1944_8) & (s_1944_9));
        // D s_1944_11: cmp-eq s_1944_10 s_1944_9
        let s_1944_11: bool = ((s_1944_10) == (s_1944_9));
        // D s_1944_12: lsl s_1944_8 s_1944_6
        let s_1944_12: u64 = s_1944_8 << s_1944_6;
        // D s_1944_13: or s_1944_7 s_1944_12
        let s_1944_13: u64 = ((s_1944_7) | (s_1944_12));
        // D s_1944_14: cmpl s_1944_12
        let s_1944_14: u64 = !s_1944_12;
        // D s_1944_15: and s_1944_7 s_1944_14
        let s_1944_15: u64 = ((s_1944_7) & (s_1944_14));
        // D s_1944_16: select s_1944_11 s_1944_13 s_1944_15
        let s_1944_16: u64 = if s_1944_11 { s_1944_13 } else { s_1944_15 };
        // D s_1944_17: cast trunc s_1944_16 -> u8
        let s_1944_17: bool = ((s_1944_16) != 0);
        // D s_1944_18: cast zx s_1944_17 -> bv
        let s_1944_18: Bits = Bits::new(s_1944_17 as u128, 1u16);
        // C s_1944_19: const #1u : u8
        let s_1944_19: bool = true;
        // C s_1944_20: cast zx s_1944_19 -> bv
        let s_1944_20: Bits = Bits::new(s_1944_19 as u128, 1u16);
        // D s_1944_21: cmp-ne s_1944_18 s_1944_20
        let s_1944_21: bool = ((s_1944_18) != (s_1944_20));
        // D s_1944_22: write-var gs#408422 <= s_1944_21
        fn_state.gs_408422 = s_1944_21;
        // N s_1944_23: jump b1945
        return block_1945(state, tracer, fn_state);
    }
    fn block_1945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1945_0: read-var gs#408422:u8
        let s_1945_0: bool = fn_state.gs_408422;
        // N s_1945_1: branch s_1945_0 b1962 b1946
        if s_1945_0 {
            return block_1962(state, tracer, fn_state);
        } else {
            return block_1946(state, tracer, fn_state);
        };
    }
    fn block_1946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1946_0: const #11s : i
        let s_1946_0: i128 = 11;
        // D s_1946_1: read-var u#33268:u32
        let s_1946_1: u32 = fn_state.u_33268;
        // D s_1946_2: cast zx s_1946_1 -> bv
        let s_1946_2: Bits = Bits::new(s_1946_1 as u128, 32u16);
        // C s_1946_3: const #1u : u64
        let s_1946_3: u64 = 1;
        // D s_1946_4: bit-extract s_1946_2 s_1946_0 s_1946_3
        let s_1946_4: Bits = (Bits::new(
            ((s_1946_2) >> (s_1946_0)).value(),
            u16::try_from(s_1946_3).unwrap(),
        ));
        // D s_1946_5: cast reint s_1946_4 -> u8
        let s_1946_5: bool = ((s_1946_4.value()) != 0);
        // C s_1946_6: const #0s : i
        let s_1946_6: i128 = 0;
        // C s_1946_7: const #0u : u64
        let s_1946_7: u64 = 0;
        // D s_1946_8: cast zx s_1946_5 -> u64
        let s_1946_8: u64 = (s_1946_5 as u64);
        // C s_1946_9: const #1u : u64
        let s_1946_9: u64 = 1;
        // D s_1946_10: and s_1946_8 s_1946_9
        let s_1946_10: u64 = ((s_1946_8) & (s_1946_9));
        // D s_1946_11: cmp-eq s_1946_10 s_1946_9
        let s_1946_11: bool = ((s_1946_10) == (s_1946_9));
        // D s_1946_12: lsl s_1946_8 s_1946_6
        let s_1946_12: u64 = s_1946_8 << s_1946_6;
        // D s_1946_13: or s_1946_7 s_1946_12
        let s_1946_13: u64 = ((s_1946_7) | (s_1946_12));
        // D s_1946_14: cmpl s_1946_12
        let s_1946_14: u64 = !s_1946_12;
        // D s_1946_15: and s_1946_7 s_1946_14
        let s_1946_15: u64 = ((s_1946_7) & (s_1946_14));
        // D s_1946_16: select s_1946_11 s_1946_13 s_1946_15
        let s_1946_16: u64 = if s_1946_11 { s_1946_13 } else { s_1946_15 };
        // D s_1946_17: cast trunc s_1946_16 -> u8
        let s_1946_17: bool = ((s_1946_16) != 0);
        // D s_1946_18: cast zx s_1946_17 -> bv
        let s_1946_18: Bits = Bits::new(s_1946_17 as u128, 1u16);
        // C s_1946_19: const #1u : u8
        let s_1946_19: bool = true;
        // C s_1946_20: cast zx s_1946_19 -> bv
        let s_1946_20: Bits = Bits::new(s_1946_19 as u128, 1u16);
        // D s_1946_21: cmp-ne s_1946_18 s_1946_20
        let s_1946_21: bool = ((s_1946_18) != (s_1946_20));
        // D s_1946_22: write-var gs#408425 <= s_1946_21
        fn_state.gs_408425 = s_1946_21;
        // N s_1946_23: jump b1947
        return block_1947(state, tracer, fn_state);
    }
    fn block_1947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1947_0: read-var gs#408425:u8
        let s_1947_0: bool = fn_state.gs_408425;
        // N s_1947_1: branch s_1947_0 b1961 b1948
        if s_1947_0 {
            return block_1961(state, tracer, fn_state);
        } else {
            return block_1948(state, tracer, fn_state);
        };
    }
    fn block_1948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1948_0: const #12s : i
        let s_1948_0: i128 = 12;
        // D s_1948_1: read-var u#33268:u32
        let s_1948_1: u32 = fn_state.u_33268;
        // D s_1948_2: cast zx s_1948_1 -> bv
        let s_1948_2: Bits = Bits::new(s_1948_1 as u128, 32u16);
        // C s_1948_3: const #1u : u64
        let s_1948_3: u64 = 1;
        // D s_1948_4: bit-extract s_1948_2 s_1948_0 s_1948_3
        let s_1948_4: Bits = (Bits::new(
            ((s_1948_2) >> (s_1948_0)).value(),
            u16::try_from(s_1948_3).unwrap(),
        ));
        // D s_1948_5: cast reint s_1948_4 -> u8
        let s_1948_5: bool = ((s_1948_4.value()) != 0);
        // C s_1948_6: const #0s : i
        let s_1948_6: i128 = 0;
        // C s_1948_7: const #0u : u64
        let s_1948_7: u64 = 0;
        // D s_1948_8: cast zx s_1948_5 -> u64
        let s_1948_8: u64 = (s_1948_5 as u64);
        // C s_1948_9: const #1u : u64
        let s_1948_9: u64 = 1;
        // D s_1948_10: and s_1948_8 s_1948_9
        let s_1948_10: u64 = ((s_1948_8) & (s_1948_9));
        // D s_1948_11: cmp-eq s_1948_10 s_1948_9
        let s_1948_11: bool = ((s_1948_10) == (s_1948_9));
        // D s_1948_12: lsl s_1948_8 s_1948_6
        let s_1948_12: u64 = s_1948_8 << s_1948_6;
        // D s_1948_13: or s_1948_7 s_1948_12
        let s_1948_13: u64 = ((s_1948_7) | (s_1948_12));
        // D s_1948_14: cmpl s_1948_12
        let s_1948_14: u64 = !s_1948_12;
        // D s_1948_15: and s_1948_7 s_1948_14
        let s_1948_15: u64 = ((s_1948_7) & (s_1948_14));
        // D s_1948_16: select s_1948_11 s_1948_13 s_1948_15
        let s_1948_16: u64 = if s_1948_11 { s_1948_13 } else { s_1948_15 };
        // D s_1948_17: cast trunc s_1948_16 -> u8
        let s_1948_17: bool = ((s_1948_16) != 0);
        // D s_1948_18: cast zx s_1948_17 -> bv
        let s_1948_18: Bits = Bits::new(s_1948_17 as u128, 1u16);
        // C s_1948_19: const #0u : u8
        let s_1948_19: bool = false;
        // C s_1948_20: cast zx s_1948_19 -> bv
        let s_1948_20: Bits = Bits::new(s_1948_19 as u128, 1u16);
        // D s_1948_21: cmp-ne s_1948_18 s_1948_20
        let s_1948_21: bool = ((s_1948_18) != (s_1948_20));
        // D s_1948_22: write-var gs#408428 <= s_1948_21
        fn_state.gs_408428 = s_1948_21;
        // N s_1948_23: jump b1949
        return block_1949(state, tracer, fn_state);
    }
    fn block_1949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1949_0: read-var gs#408428:u8
        let s_1949_0: bool = fn_state.gs_408428;
        // N s_1949_1: branch s_1949_0 b1960 b1950
        if s_1949_0 {
            return block_1960(state, tracer, fn_state);
        } else {
            return block_1950(state, tracer, fn_state);
        };
    }
    fn block_1950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1950_0: const #13s : i
        let s_1950_0: i128 = 13;
        // D s_1950_1: read-var u#33268:u32
        let s_1950_1: u32 = fn_state.u_33268;
        // D s_1950_2: cast zx s_1950_1 -> bv
        let s_1950_2: Bits = Bits::new(s_1950_1 as u128, 32u16);
        // C s_1950_3: const #1u : u64
        let s_1950_3: u64 = 1;
        // D s_1950_4: bit-extract s_1950_2 s_1950_0 s_1950_3
        let s_1950_4: Bits = (Bits::new(
            ((s_1950_2) >> (s_1950_0)).value(),
            u16::try_from(s_1950_3).unwrap(),
        ));
        // D s_1950_5: cast reint s_1950_4 -> u8
        let s_1950_5: bool = ((s_1950_4.value()) != 0);
        // C s_1950_6: const #0s : i
        let s_1950_6: i128 = 0;
        // C s_1950_7: const #0u : u64
        let s_1950_7: u64 = 0;
        // D s_1950_8: cast zx s_1950_5 -> u64
        let s_1950_8: u64 = (s_1950_5 as u64);
        // C s_1950_9: const #1u : u64
        let s_1950_9: u64 = 1;
        // D s_1950_10: and s_1950_8 s_1950_9
        let s_1950_10: u64 = ((s_1950_8) & (s_1950_9));
        // D s_1950_11: cmp-eq s_1950_10 s_1950_9
        let s_1950_11: bool = ((s_1950_10) == (s_1950_9));
        // D s_1950_12: lsl s_1950_8 s_1950_6
        let s_1950_12: u64 = s_1950_8 << s_1950_6;
        // D s_1950_13: or s_1950_7 s_1950_12
        let s_1950_13: u64 = ((s_1950_7) | (s_1950_12));
        // D s_1950_14: cmpl s_1950_12
        let s_1950_14: u64 = !s_1950_12;
        // D s_1950_15: and s_1950_7 s_1950_14
        let s_1950_15: u64 = ((s_1950_7) & (s_1950_14));
        // D s_1950_16: select s_1950_11 s_1950_13 s_1950_15
        let s_1950_16: u64 = if s_1950_11 { s_1950_13 } else { s_1950_15 };
        // D s_1950_17: cast trunc s_1950_16 -> u8
        let s_1950_17: bool = ((s_1950_16) != 0);
        // D s_1950_18: cast zx s_1950_17 -> bv
        let s_1950_18: Bits = Bits::new(s_1950_17 as u128, 1u16);
        // C s_1950_19: const #0u : u8
        let s_1950_19: bool = false;
        // C s_1950_20: cast zx s_1950_19 -> bv
        let s_1950_20: Bits = Bits::new(s_1950_19 as u128, 1u16);
        // D s_1950_21: cmp-ne s_1950_18 s_1950_20
        let s_1950_21: bool = ((s_1950_18) != (s_1950_20));
        // D s_1950_22: write-var gs#408431 <= s_1950_21
        fn_state.gs_408431 = s_1950_21;
        // N s_1950_23: jump b1951
        return block_1951(state, tracer, fn_state);
    }
    fn block_1951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1951_0: read-var gs#408431:u8
        let s_1951_0: bool = fn_state.gs_408431;
        // N s_1951_1: branch s_1951_0 b1959 b1952
        if s_1951_0 {
            return block_1959(state, tracer, fn_state);
        } else {
            return block_1952(state, tracer, fn_state);
        };
    }
    fn block_1952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1952_0: const #14s : i
        let s_1952_0: i128 = 14;
        // D s_1952_1: read-var u#33268:u32
        let s_1952_1: u32 = fn_state.u_33268;
        // D s_1952_2: cast zx s_1952_1 -> bv
        let s_1952_2: Bits = Bits::new(s_1952_1 as u128, 32u16);
        // C s_1952_3: const #1u : u64
        let s_1952_3: u64 = 1;
        // D s_1952_4: bit-extract s_1952_2 s_1952_0 s_1952_3
        let s_1952_4: Bits = (Bits::new(
            ((s_1952_2) >> (s_1952_0)).value(),
            u16::try_from(s_1952_3).unwrap(),
        ));
        // D s_1952_5: cast reint s_1952_4 -> u8
        let s_1952_5: bool = ((s_1952_4.value()) != 0);
        // C s_1952_6: const #0s : i
        let s_1952_6: i128 = 0;
        // C s_1952_7: const #0u : u64
        let s_1952_7: u64 = 0;
        // D s_1952_8: cast zx s_1952_5 -> u64
        let s_1952_8: u64 = (s_1952_5 as u64);
        // C s_1952_9: const #1u : u64
        let s_1952_9: u64 = 1;
        // D s_1952_10: and s_1952_8 s_1952_9
        let s_1952_10: u64 = ((s_1952_8) & (s_1952_9));
        // D s_1952_11: cmp-eq s_1952_10 s_1952_9
        let s_1952_11: bool = ((s_1952_10) == (s_1952_9));
        // D s_1952_12: lsl s_1952_8 s_1952_6
        let s_1952_12: u64 = s_1952_8 << s_1952_6;
        // D s_1952_13: or s_1952_7 s_1952_12
        let s_1952_13: u64 = ((s_1952_7) | (s_1952_12));
        // D s_1952_14: cmpl s_1952_12
        let s_1952_14: u64 = !s_1952_12;
        // D s_1952_15: and s_1952_7 s_1952_14
        let s_1952_15: u64 = ((s_1952_7) & (s_1952_14));
        // D s_1952_16: select s_1952_11 s_1952_13 s_1952_15
        let s_1952_16: u64 = if s_1952_11 { s_1952_13 } else { s_1952_15 };
        // D s_1952_17: cast trunc s_1952_16 -> u8
        let s_1952_17: bool = ((s_1952_16) != 0);
        // D s_1952_18: cast zx s_1952_17 -> bv
        let s_1952_18: Bits = Bits::new(s_1952_17 as u128, 1u16);
        // C s_1952_19: const #0u : u8
        let s_1952_19: bool = false;
        // C s_1952_20: cast zx s_1952_19 -> bv
        let s_1952_20: Bits = Bits::new(s_1952_19 as u128, 1u16);
        // D s_1952_21: cmp-ne s_1952_18 s_1952_20
        let s_1952_21: bool = ((s_1952_18) != (s_1952_20));
        // D s_1952_22: write-var gs#408434 <= s_1952_21
        fn_state.gs_408434 = s_1952_21;
        // N s_1952_23: jump b1953
        return block_1953(state, tracer, fn_state);
    }
    fn block_1953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1953_0: read-var gs#408434:u8
        let s_1953_0: bool = fn_state.gs_408434;
        // N s_1953_1: branch s_1953_0 b1958 b1954
        if s_1953_0 {
            return block_1958(state, tracer, fn_state);
        } else {
            return block_1954(state, tracer, fn_state);
        };
    }
    fn block_1954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1954_0: const #15s : i
        let s_1954_0: i128 = 15;
        // D s_1954_1: read-var u#33268:u32
        let s_1954_1: u32 = fn_state.u_33268;
        // D s_1954_2: cast zx s_1954_1 -> bv
        let s_1954_2: Bits = Bits::new(s_1954_1 as u128, 32u16);
        // C s_1954_3: const #1u : u64
        let s_1954_3: u64 = 1;
        // D s_1954_4: bit-extract s_1954_2 s_1954_0 s_1954_3
        let s_1954_4: Bits = (Bits::new(
            ((s_1954_2) >> (s_1954_0)).value(),
            u16::try_from(s_1954_3).unwrap(),
        ));
        // D s_1954_5: cast reint s_1954_4 -> u8
        let s_1954_5: bool = ((s_1954_4.value()) != 0);
        // C s_1954_6: const #0s : i
        let s_1954_6: i128 = 0;
        // C s_1954_7: const #0u : u64
        let s_1954_7: u64 = 0;
        // D s_1954_8: cast zx s_1954_5 -> u64
        let s_1954_8: u64 = (s_1954_5 as u64);
        // C s_1954_9: const #1u : u64
        let s_1954_9: u64 = 1;
        // D s_1954_10: and s_1954_8 s_1954_9
        let s_1954_10: u64 = ((s_1954_8) & (s_1954_9));
        // D s_1954_11: cmp-eq s_1954_10 s_1954_9
        let s_1954_11: bool = ((s_1954_10) == (s_1954_9));
        // D s_1954_12: lsl s_1954_8 s_1954_6
        let s_1954_12: u64 = s_1954_8 << s_1954_6;
        // D s_1954_13: or s_1954_7 s_1954_12
        let s_1954_13: u64 = ((s_1954_7) | (s_1954_12));
        // D s_1954_14: cmpl s_1954_12
        let s_1954_14: u64 = !s_1954_12;
        // D s_1954_15: and s_1954_7 s_1954_14
        let s_1954_15: u64 = ((s_1954_7) & (s_1954_14));
        // D s_1954_16: select s_1954_11 s_1954_13 s_1954_15
        let s_1954_16: u64 = if s_1954_11 { s_1954_13 } else { s_1954_15 };
        // D s_1954_17: cast trunc s_1954_16 -> u8
        let s_1954_17: bool = ((s_1954_16) != 0);
        // D s_1954_18: cast zx s_1954_17 -> bv
        let s_1954_18: Bits = Bits::new(s_1954_17 as u128, 1u16);
        // C s_1954_19: const #0u : u8
        let s_1954_19: bool = false;
        // C s_1954_20: cast zx s_1954_19 -> bv
        let s_1954_20: Bits = Bits::new(s_1954_19 as u128, 1u16);
        // D s_1954_21: cmp-ne s_1954_18 s_1954_20
        let s_1954_21: bool = ((s_1954_18) != (s_1954_20));
        // D s_1954_22: write-var gs#408437 <= s_1954_21
        fn_state.gs_408437 = s_1954_21;
        // N s_1954_23: jump b1955
        return block_1955(state, tracer, fn_state);
    }
    fn block_1955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1955_0: read-var gs#408437:u8
        let s_1955_0: bool = fn_state.gs_408437;
        // N s_1955_1: branch s_1955_0 b1957 b1956
        if s_1955_0 {
            return block_1957(state, tracer, fn_state);
        } else {
            return block_1956(state, tracer, fn_state);
        };
    }
    fn block_1956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1956_0: read-var u#33269:u8
        let s_1956_0: u8 = fn_state.u_33269;
        // D s_1956_1: call decode_aarch32_instrs_ESB_A1enc_A_txt(s_1956_0)
        let s_1956_1: () = decode_aarch32_instrs_ESB_A1enc_A_txt(
            state,
            tracer,
            s_1956_0,
        );
        // N s_1956_2: return
        return;
    }
    fn block_1957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1957_0: panic
        panic!("{:?}", ());
        // N s_1957_1: return
        return;
    }
    fn block_1958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1958_0: const #1u : u8
        let s_1958_0: bool = true;
        // D s_1958_1: write-var gs#408437 <= s_1958_0
        fn_state.gs_408437 = s_1958_0;
        // N s_1958_2: jump b1955
        return block_1955(state, tracer, fn_state);
    }
    fn block_1959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1959_0: const #1u : u8
        let s_1959_0: bool = true;
        // D s_1959_1: write-var gs#408434 <= s_1959_0
        fn_state.gs_408434 = s_1959_0;
        // N s_1959_2: jump b1953
        return block_1953(state, tracer, fn_state);
    }
    fn block_1960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1960_0: const #1u : u8
        let s_1960_0: bool = true;
        // D s_1960_1: write-var gs#408431 <= s_1960_0
        fn_state.gs_408431 = s_1960_0;
        // N s_1960_2: jump b1951
        return block_1951(state, tracer, fn_state);
    }
    fn block_1961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1961_0: const #1u : u8
        let s_1961_0: bool = true;
        // D s_1961_1: write-var gs#408428 <= s_1961_0
        fn_state.gs_408428 = s_1961_0;
        // N s_1961_2: jump b1949
        return block_1949(state, tracer, fn_state);
    }
    fn block_1962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1962_0: const #1u : u8
        let s_1962_0: bool = true;
        // D s_1962_1: write-var gs#408425 <= s_1962_0
        fn_state.gs_408425 = s_1962_0;
        // N s_1962_2: jump b1947
        return block_1947(state, tracer, fn_state);
    }
    fn block_1963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1963_0: const #1u : u8
        let s_1963_0: bool = true;
        // D s_1963_1: write-var gs#408422 <= s_1963_0
        fn_state.gs_408422 = s_1963_0;
        // N s_1963_2: jump b1945
        return block_1945(state, tracer, fn_state);
    }
    fn block_1964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1964_0: const #1u : u8
        let s_1964_0: bool = true;
        // D s_1964_1: write-var gs#408419 <= s_1964_0
        fn_state.gs_408419 = s_1964_0;
        // N s_1964_2: jump b1943
        return block_1943(state, tracer, fn_state);
    }
    fn block_1965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1965_0: read-var merge#var.1:struct
        let s_1965_0: u32 = fn_state.merge_var._1;
        // D s_1965_1: write-var u#33271 <= s_1965_0
        fn_state.u_33271 = s_1965_0;
        // C s_1965_2: const #0s : i
        let s_1965_2: i128 = 0;
        // D s_1965_3: read-var u#33271:u32
        let s_1965_3: u32 = fn_state.u_33271;
        // D s_1965_4: cast zx s_1965_3 -> bv
        let s_1965_4: Bits = Bits::new(s_1965_3 as u128, 32u16);
        // C s_1965_5: const #1s : i64
        let s_1965_5: i64 = 1;
        // C s_1965_6: cast zx s_1965_5 -> i
        let s_1965_6: i128 = (i128::try_from(s_1965_5).unwrap());
        // C s_1965_7: const #27s : i
        let s_1965_7: i128 = 27;
        // C s_1965_8: add s_1965_7 s_1965_6
        let s_1965_8: i128 = (s_1965_7 + s_1965_6);
        // D s_1965_9: bit-extract s_1965_4 s_1965_2 s_1965_8
        let s_1965_9: Bits = (Bits::new(
            ((s_1965_4) >> (s_1965_2)).value(),
            u16::try_from(s_1965_8).unwrap(),
        ));
        // D s_1965_10: cast reint s_1965_9 -> u28
        let s_1965_10: u32 = (s_1965_9.value() as u32);
        // D s_1965_11: cast zx s_1965_10 -> bv
        let s_1965_11: Bits = Bits::new(s_1965_10 as u128, 28u16);
        // C s_1965_12: const #52490258u : u28
        let s_1965_12: u32 = 52490258;
        // C s_1965_13: cast zx s_1965_12 -> bv
        let s_1965_13: Bits = Bits::new(s_1965_12 as u128, 28u16);
        // D s_1965_14: cmp-eq s_1965_11 s_1965_13
        let s_1965_14: bool = ((s_1965_11) == (s_1965_13));
        // N s_1965_15: branch s_1965_14 b2055 b1966
        if s_1965_14 {
            return block_2055(state, tracer, fn_state);
        } else {
            return block_1966(state, tracer, fn_state);
        };
    }
    fn block_1966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1966_0: const #0u : u8
        let s_1966_0: bool = false;
        // D s_1966_1: write-var gs#408445 <= s_1966_0
        fn_state.gs_408445 = s_1966_0;
        // N s_1966_2: jump b1967
        return block_1967(state, tracer, fn_state);
    }
    fn block_1967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1967_0: read-var gs#408445:u8
        let s_1967_0: bool = fn_state.gs_408445;
        // D s_1967_1: not s_1967_0
        let s_1967_1: bool = !s_1967_0;
        // N s_1967_2: branch s_1967_1 b1992 b1968
        if s_1967_1 {
            return block_1992(state, tracer, fn_state);
        } else {
            return block_1968(state, tracer, fn_state);
        };
    }
    fn block_1968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1968_0: const #3892s : i
        let s_1968_0: i128 = 3892;
        // C s_1968_1: const #14696u : u32
        let s_1968_1: u32 = 14696;
        // N s_1968_2: write-reg s_1968_1 <= s_1968_0
        let s_1968_2: () = {
            state.write_register::<i128>(s_1968_1 as isize, s_1968_0);
            tracer.write_register(s_1968_1 as isize, s_1968_0);
        };
        // C s_1968_3: const #28s : i
        let s_1968_3: i128 = 28;
        // C s_1968_4: const #4s : i
        let s_1968_4: i128 = 4;
        // D s_1968_5: read-var u#33271:u32
        let s_1968_5: u32 = fn_state.u_33271;
        // D s_1968_6: cast zx s_1968_5 -> bv
        let s_1968_6: Bits = Bits::new(s_1968_5 as u128, 32u16);
        // D s_1968_7: bit-extract s_1968_6 s_1968_3 s_1968_4
        let s_1968_7: Bits = (Bits::new(
            ((s_1968_6) >> (s_1968_3)).value(),
            u16::try_from(s_1968_4).unwrap(),
        ));
        // D s_1968_8: cast reint s_1968_7 -> u8
        let s_1968_8: u8 = (s_1968_7.value() as u8);
        // D s_1968_9: write-var u#33272 <= s_1968_8
        fn_state.u_33272 = s_1968_8;
        // C s_1968_10: const #8s : i
        let s_1968_10: i128 = 8;
        // D s_1968_11: read-var u#33271:u32
        let s_1968_11: u32 = fn_state.u_33271;
        // D s_1968_12: cast zx s_1968_11 -> bv
        let s_1968_12: Bits = Bits::new(s_1968_11 as u128, 32u16);
        // C s_1968_13: const #1u : u64
        let s_1968_13: u64 = 1;
        // D s_1968_14: bit-extract s_1968_12 s_1968_10 s_1968_13
        let s_1968_14: Bits = (Bits::new(
            ((s_1968_12) >> (s_1968_10)).value(),
            u16::try_from(s_1968_13).unwrap(),
        ));
        // D s_1968_15: cast reint s_1968_14 -> u8
        let s_1968_15: bool = ((s_1968_14.value()) != 0);
        // C s_1968_16: const #0s : i
        let s_1968_16: i128 = 0;
        // C s_1968_17: const #0u : u64
        let s_1968_17: u64 = 0;
        // D s_1968_18: cast zx s_1968_15 -> u64
        let s_1968_18: u64 = (s_1968_15 as u64);
        // C s_1968_19: const #1u : u64
        let s_1968_19: u64 = 1;
        // D s_1968_20: and s_1968_18 s_1968_19
        let s_1968_20: u64 = ((s_1968_18) & (s_1968_19));
        // D s_1968_21: cmp-eq s_1968_20 s_1968_19
        let s_1968_21: bool = ((s_1968_20) == (s_1968_19));
        // D s_1968_22: lsl s_1968_18 s_1968_16
        let s_1968_22: u64 = s_1968_18 << s_1968_16;
        // D s_1968_23: or s_1968_17 s_1968_22
        let s_1968_23: u64 = ((s_1968_17) | (s_1968_22));
        // D s_1968_24: cmpl s_1968_22
        let s_1968_24: u64 = !s_1968_22;
        // D s_1968_25: and s_1968_17 s_1968_24
        let s_1968_25: u64 = ((s_1968_17) & (s_1968_24));
        // D s_1968_26: select s_1968_21 s_1968_23 s_1968_25
        let s_1968_26: u64 = if s_1968_21 { s_1968_23 } else { s_1968_25 };
        // D s_1968_27: cast trunc s_1968_26 -> u8
        let s_1968_27: bool = ((s_1968_26) != 0);
        // D s_1968_28: cast zx s_1968_27 -> bv
        let s_1968_28: Bits = Bits::new(s_1968_27 as u128, 1u16);
        // C s_1968_29: const #1u : u8
        let s_1968_29: bool = true;
        // C s_1968_30: cast zx s_1968_29 -> bv
        let s_1968_30: Bits = Bits::new(s_1968_29 as u128, 1u16);
        // D s_1968_31: cmp-ne s_1968_28 s_1968_30
        let s_1968_31: bool = ((s_1968_28) != (s_1968_30));
        // N s_1968_32: branch s_1968_31 b1991 b1969
        if s_1968_31 {
            return block_1991(state, tracer, fn_state);
        } else {
            return block_1969(state, tracer, fn_state);
        };
    }
    fn block_1969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1969_0: const #9s : i
        let s_1969_0: i128 = 9;
        // D s_1969_1: read-var u#33271:u32
        let s_1969_1: u32 = fn_state.u_33271;
        // D s_1969_2: cast zx s_1969_1 -> bv
        let s_1969_2: Bits = Bits::new(s_1969_1 as u128, 32u16);
        // C s_1969_3: const #1u : u64
        let s_1969_3: u64 = 1;
        // D s_1969_4: bit-extract s_1969_2 s_1969_0 s_1969_3
        let s_1969_4: Bits = (Bits::new(
            ((s_1969_2) >> (s_1969_0)).value(),
            u16::try_from(s_1969_3).unwrap(),
        ));
        // D s_1969_5: cast reint s_1969_4 -> u8
        let s_1969_5: bool = ((s_1969_4.value()) != 0);
        // C s_1969_6: const #0s : i
        let s_1969_6: i128 = 0;
        // C s_1969_7: const #0u : u64
        let s_1969_7: u64 = 0;
        // D s_1969_8: cast zx s_1969_5 -> u64
        let s_1969_8: u64 = (s_1969_5 as u64);
        // C s_1969_9: const #1u : u64
        let s_1969_9: u64 = 1;
        // D s_1969_10: and s_1969_8 s_1969_9
        let s_1969_10: u64 = ((s_1969_8) & (s_1969_9));
        // D s_1969_11: cmp-eq s_1969_10 s_1969_9
        let s_1969_11: bool = ((s_1969_10) == (s_1969_9));
        // D s_1969_12: lsl s_1969_8 s_1969_6
        let s_1969_12: u64 = s_1969_8 << s_1969_6;
        // D s_1969_13: or s_1969_7 s_1969_12
        let s_1969_13: u64 = ((s_1969_7) | (s_1969_12));
        // D s_1969_14: cmpl s_1969_12
        let s_1969_14: u64 = !s_1969_12;
        // D s_1969_15: and s_1969_7 s_1969_14
        let s_1969_15: u64 = ((s_1969_7) & (s_1969_14));
        // D s_1969_16: select s_1969_11 s_1969_13 s_1969_15
        let s_1969_16: u64 = if s_1969_11 { s_1969_13 } else { s_1969_15 };
        // D s_1969_17: cast trunc s_1969_16 -> u8
        let s_1969_17: bool = ((s_1969_16) != 0);
        // D s_1969_18: cast zx s_1969_17 -> bv
        let s_1969_18: Bits = Bits::new(s_1969_17 as u128, 1u16);
        // C s_1969_19: const #1u : u8
        let s_1969_19: bool = true;
        // C s_1969_20: cast zx s_1969_19 -> bv
        let s_1969_20: Bits = Bits::new(s_1969_19 as u128, 1u16);
        // D s_1969_21: cmp-ne s_1969_18 s_1969_20
        let s_1969_21: bool = ((s_1969_18) != (s_1969_20));
        // D s_1969_22: write-var gs#408454 <= s_1969_21
        fn_state.gs_408454 = s_1969_21;
        // N s_1969_23: jump b1970
        return block_1970(state, tracer, fn_state);
    }
    fn block_1970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1970_0: read-var gs#408454:u8
        let s_1970_0: bool = fn_state.gs_408454;
        // N s_1970_1: branch s_1970_0 b1990 b1971
        if s_1970_0 {
            return block_1990(state, tracer, fn_state);
        } else {
            return block_1971(state, tracer, fn_state);
        };
    }
    fn block_1971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1971_0: const #10s : i
        let s_1971_0: i128 = 10;
        // D s_1971_1: read-var u#33271:u32
        let s_1971_1: u32 = fn_state.u_33271;
        // D s_1971_2: cast zx s_1971_1 -> bv
        let s_1971_2: Bits = Bits::new(s_1971_1 as u128, 32u16);
        // C s_1971_3: const #1u : u64
        let s_1971_3: u64 = 1;
        // D s_1971_4: bit-extract s_1971_2 s_1971_0 s_1971_3
        let s_1971_4: Bits = (Bits::new(
            ((s_1971_2) >> (s_1971_0)).value(),
            u16::try_from(s_1971_3).unwrap(),
        ));
        // D s_1971_5: cast reint s_1971_4 -> u8
        let s_1971_5: bool = ((s_1971_4.value()) != 0);
        // C s_1971_6: const #0s : i
        let s_1971_6: i128 = 0;
        // C s_1971_7: const #0u : u64
        let s_1971_7: u64 = 0;
        // D s_1971_8: cast zx s_1971_5 -> u64
        let s_1971_8: u64 = (s_1971_5 as u64);
        // C s_1971_9: const #1u : u64
        let s_1971_9: u64 = 1;
        // D s_1971_10: and s_1971_8 s_1971_9
        let s_1971_10: u64 = ((s_1971_8) & (s_1971_9));
        // D s_1971_11: cmp-eq s_1971_10 s_1971_9
        let s_1971_11: bool = ((s_1971_10) == (s_1971_9));
        // D s_1971_12: lsl s_1971_8 s_1971_6
        let s_1971_12: u64 = s_1971_8 << s_1971_6;
        // D s_1971_13: or s_1971_7 s_1971_12
        let s_1971_13: u64 = ((s_1971_7) | (s_1971_12));
        // D s_1971_14: cmpl s_1971_12
        let s_1971_14: u64 = !s_1971_12;
        // D s_1971_15: and s_1971_7 s_1971_14
        let s_1971_15: u64 = ((s_1971_7) & (s_1971_14));
        // D s_1971_16: select s_1971_11 s_1971_13 s_1971_15
        let s_1971_16: u64 = if s_1971_11 { s_1971_13 } else { s_1971_15 };
        // D s_1971_17: cast trunc s_1971_16 -> u8
        let s_1971_17: bool = ((s_1971_16) != 0);
        // D s_1971_18: cast zx s_1971_17 -> bv
        let s_1971_18: Bits = Bits::new(s_1971_17 as u128, 1u16);
        // C s_1971_19: const #1u : u8
        let s_1971_19: bool = true;
        // C s_1971_20: cast zx s_1971_19 -> bv
        let s_1971_20: Bits = Bits::new(s_1971_19 as u128, 1u16);
        // D s_1971_21: cmp-ne s_1971_18 s_1971_20
        let s_1971_21: bool = ((s_1971_18) != (s_1971_20));
        // D s_1971_22: write-var gs#408457 <= s_1971_21
        fn_state.gs_408457 = s_1971_21;
        // N s_1971_23: jump b1972
        return block_1972(state, tracer, fn_state);
    }
    fn block_1972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1972_0: read-var gs#408457:u8
        let s_1972_0: bool = fn_state.gs_408457;
        // N s_1972_1: branch s_1972_0 b1989 b1973
        if s_1972_0 {
            return block_1989(state, tracer, fn_state);
        } else {
            return block_1973(state, tracer, fn_state);
        };
    }
    fn block_1973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1973_0: const #11s : i
        let s_1973_0: i128 = 11;
        // D s_1973_1: read-var u#33271:u32
        let s_1973_1: u32 = fn_state.u_33271;
        // D s_1973_2: cast zx s_1973_1 -> bv
        let s_1973_2: Bits = Bits::new(s_1973_1 as u128, 32u16);
        // C s_1973_3: const #1u : u64
        let s_1973_3: u64 = 1;
        // D s_1973_4: bit-extract s_1973_2 s_1973_0 s_1973_3
        let s_1973_4: Bits = (Bits::new(
            ((s_1973_2) >> (s_1973_0)).value(),
            u16::try_from(s_1973_3).unwrap(),
        ));
        // D s_1973_5: cast reint s_1973_4 -> u8
        let s_1973_5: bool = ((s_1973_4.value()) != 0);
        // C s_1973_6: const #0s : i
        let s_1973_6: i128 = 0;
        // C s_1973_7: const #0u : u64
        let s_1973_7: u64 = 0;
        // D s_1973_8: cast zx s_1973_5 -> u64
        let s_1973_8: u64 = (s_1973_5 as u64);
        // C s_1973_9: const #1u : u64
        let s_1973_9: u64 = 1;
        // D s_1973_10: and s_1973_8 s_1973_9
        let s_1973_10: u64 = ((s_1973_8) & (s_1973_9));
        // D s_1973_11: cmp-eq s_1973_10 s_1973_9
        let s_1973_11: bool = ((s_1973_10) == (s_1973_9));
        // D s_1973_12: lsl s_1973_8 s_1973_6
        let s_1973_12: u64 = s_1973_8 << s_1973_6;
        // D s_1973_13: or s_1973_7 s_1973_12
        let s_1973_13: u64 = ((s_1973_7) | (s_1973_12));
        // D s_1973_14: cmpl s_1973_12
        let s_1973_14: u64 = !s_1973_12;
        // D s_1973_15: and s_1973_7 s_1973_14
        let s_1973_15: u64 = ((s_1973_7) & (s_1973_14));
        // D s_1973_16: select s_1973_11 s_1973_13 s_1973_15
        let s_1973_16: u64 = if s_1973_11 { s_1973_13 } else { s_1973_15 };
        // D s_1973_17: cast trunc s_1973_16 -> u8
        let s_1973_17: bool = ((s_1973_16) != 0);
        // D s_1973_18: cast zx s_1973_17 -> bv
        let s_1973_18: Bits = Bits::new(s_1973_17 as u128, 1u16);
        // C s_1973_19: const #1u : u8
        let s_1973_19: bool = true;
        // C s_1973_20: cast zx s_1973_19 -> bv
        let s_1973_20: Bits = Bits::new(s_1973_19 as u128, 1u16);
        // D s_1973_21: cmp-ne s_1973_18 s_1973_20
        let s_1973_21: bool = ((s_1973_18) != (s_1973_20));
        // D s_1973_22: write-var gs#408460 <= s_1973_21
        fn_state.gs_408460 = s_1973_21;
        // N s_1973_23: jump b1974
        return block_1974(state, tracer, fn_state);
    }
    fn block_1974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1974_0: read-var gs#408460:u8
        let s_1974_0: bool = fn_state.gs_408460;
        // N s_1974_1: branch s_1974_0 b1988 b1975
        if s_1974_0 {
            return block_1988(state, tracer, fn_state);
        } else {
            return block_1975(state, tracer, fn_state);
        };
    }
    fn block_1975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1975_0: const #12s : i
        let s_1975_0: i128 = 12;
        // D s_1975_1: read-var u#33271:u32
        let s_1975_1: u32 = fn_state.u_33271;
        // D s_1975_2: cast zx s_1975_1 -> bv
        let s_1975_2: Bits = Bits::new(s_1975_1 as u128, 32u16);
        // C s_1975_3: const #1u : u64
        let s_1975_3: u64 = 1;
        // D s_1975_4: bit-extract s_1975_2 s_1975_0 s_1975_3
        let s_1975_4: Bits = (Bits::new(
            ((s_1975_2) >> (s_1975_0)).value(),
            u16::try_from(s_1975_3).unwrap(),
        ));
        // D s_1975_5: cast reint s_1975_4 -> u8
        let s_1975_5: bool = ((s_1975_4.value()) != 0);
        // C s_1975_6: const #0s : i
        let s_1975_6: i128 = 0;
        // C s_1975_7: const #0u : u64
        let s_1975_7: u64 = 0;
        // D s_1975_8: cast zx s_1975_5 -> u64
        let s_1975_8: u64 = (s_1975_5 as u64);
        // C s_1975_9: const #1u : u64
        let s_1975_9: u64 = 1;
        // D s_1975_10: and s_1975_8 s_1975_9
        let s_1975_10: u64 = ((s_1975_8) & (s_1975_9));
        // D s_1975_11: cmp-eq s_1975_10 s_1975_9
        let s_1975_11: bool = ((s_1975_10) == (s_1975_9));
        // D s_1975_12: lsl s_1975_8 s_1975_6
        let s_1975_12: u64 = s_1975_8 << s_1975_6;
        // D s_1975_13: or s_1975_7 s_1975_12
        let s_1975_13: u64 = ((s_1975_7) | (s_1975_12));
        // D s_1975_14: cmpl s_1975_12
        let s_1975_14: u64 = !s_1975_12;
        // D s_1975_15: and s_1975_7 s_1975_14
        let s_1975_15: u64 = ((s_1975_7) & (s_1975_14));
        // D s_1975_16: select s_1975_11 s_1975_13 s_1975_15
        let s_1975_16: u64 = if s_1975_11 { s_1975_13 } else { s_1975_15 };
        // D s_1975_17: cast trunc s_1975_16 -> u8
        let s_1975_17: bool = ((s_1975_16) != 0);
        // D s_1975_18: cast zx s_1975_17 -> bv
        let s_1975_18: Bits = Bits::new(s_1975_17 as u128, 1u16);
        // C s_1975_19: const #0u : u8
        let s_1975_19: bool = false;
        // C s_1975_20: cast zx s_1975_19 -> bv
        let s_1975_20: Bits = Bits::new(s_1975_19 as u128, 1u16);
        // D s_1975_21: cmp-ne s_1975_18 s_1975_20
        let s_1975_21: bool = ((s_1975_18) != (s_1975_20));
        // D s_1975_22: write-var gs#408463 <= s_1975_21
        fn_state.gs_408463 = s_1975_21;
        // N s_1975_23: jump b1976
        return block_1976(state, tracer, fn_state);
    }
    fn block_1976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1976_0: read-var gs#408463:u8
        let s_1976_0: bool = fn_state.gs_408463;
        // N s_1976_1: branch s_1976_0 b1987 b1977
        if s_1976_0 {
            return block_1987(state, tracer, fn_state);
        } else {
            return block_1977(state, tracer, fn_state);
        };
    }
    fn block_1977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1977_0: const #13s : i
        let s_1977_0: i128 = 13;
        // D s_1977_1: read-var u#33271:u32
        let s_1977_1: u32 = fn_state.u_33271;
        // D s_1977_2: cast zx s_1977_1 -> bv
        let s_1977_2: Bits = Bits::new(s_1977_1 as u128, 32u16);
        // C s_1977_3: const #1u : u64
        let s_1977_3: u64 = 1;
        // D s_1977_4: bit-extract s_1977_2 s_1977_0 s_1977_3
        let s_1977_4: Bits = (Bits::new(
            ((s_1977_2) >> (s_1977_0)).value(),
            u16::try_from(s_1977_3).unwrap(),
        ));
        // D s_1977_5: cast reint s_1977_4 -> u8
        let s_1977_5: bool = ((s_1977_4.value()) != 0);
        // C s_1977_6: const #0s : i
        let s_1977_6: i128 = 0;
        // C s_1977_7: const #0u : u64
        let s_1977_7: u64 = 0;
        // D s_1977_8: cast zx s_1977_5 -> u64
        let s_1977_8: u64 = (s_1977_5 as u64);
        // C s_1977_9: const #1u : u64
        let s_1977_9: u64 = 1;
        // D s_1977_10: and s_1977_8 s_1977_9
        let s_1977_10: u64 = ((s_1977_8) & (s_1977_9));
        // D s_1977_11: cmp-eq s_1977_10 s_1977_9
        let s_1977_11: bool = ((s_1977_10) == (s_1977_9));
        // D s_1977_12: lsl s_1977_8 s_1977_6
        let s_1977_12: u64 = s_1977_8 << s_1977_6;
        // D s_1977_13: or s_1977_7 s_1977_12
        let s_1977_13: u64 = ((s_1977_7) | (s_1977_12));
        // D s_1977_14: cmpl s_1977_12
        let s_1977_14: u64 = !s_1977_12;
        // D s_1977_15: and s_1977_7 s_1977_14
        let s_1977_15: u64 = ((s_1977_7) & (s_1977_14));
        // D s_1977_16: select s_1977_11 s_1977_13 s_1977_15
        let s_1977_16: u64 = if s_1977_11 { s_1977_13 } else { s_1977_15 };
        // D s_1977_17: cast trunc s_1977_16 -> u8
        let s_1977_17: bool = ((s_1977_16) != 0);
        // D s_1977_18: cast zx s_1977_17 -> bv
        let s_1977_18: Bits = Bits::new(s_1977_17 as u128, 1u16);
        // C s_1977_19: const #0u : u8
        let s_1977_19: bool = false;
        // C s_1977_20: cast zx s_1977_19 -> bv
        let s_1977_20: Bits = Bits::new(s_1977_19 as u128, 1u16);
        // D s_1977_21: cmp-ne s_1977_18 s_1977_20
        let s_1977_21: bool = ((s_1977_18) != (s_1977_20));
        // D s_1977_22: write-var gs#408466 <= s_1977_21
        fn_state.gs_408466 = s_1977_21;
        // N s_1977_23: jump b1978
        return block_1978(state, tracer, fn_state);
    }
    fn block_1978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1978_0: read-var gs#408466:u8
        let s_1978_0: bool = fn_state.gs_408466;
        // N s_1978_1: branch s_1978_0 b1986 b1979
        if s_1978_0 {
            return block_1986(state, tracer, fn_state);
        } else {
            return block_1979(state, tracer, fn_state);
        };
    }
    fn block_1979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1979_0: const #14s : i
        let s_1979_0: i128 = 14;
        // D s_1979_1: read-var u#33271:u32
        let s_1979_1: u32 = fn_state.u_33271;
        // D s_1979_2: cast zx s_1979_1 -> bv
        let s_1979_2: Bits = Bits::new(s_1979_1 as u128, 32u16);
        // C s_1979_3: const #1u : u64
        let s_1979_3: u64 = 1;
        // D s_1979_4: bit-extract s_1979_2 s_1979_0 s_1979_3
        let s_1979_4: Bits = (Bits::new(
            ((s_1979_2) >> (s_1979_0)).value(),
            u16::try_from(s_1979_3).unwrap(),
        ));
        // D s_1979_5: cast reint s_1979_4 -> u8
        let s_1979_5: bool = ((s_1979_4.value()) != 0);
        // C s_1979_6: const #0s : i
        let s_1979_6: i128 = 0;
        // C s_1979_7: const #0u : u64
        let s_1979_7: u64 = 0;
        // D s_1979_8: cast zx s_1979_5 -> u64
        let s_1979_8: u64 = (s_1979_5 as u64);
        // C s_1979_9: const #1u : u64
        let s_1979_9: u64 = 1;
        // D s_1979_10: and s_1979_8 s_1979_9
        let s_1979_10: u64 = ((s_1979_8) & (s_1979_9));
        // D s_1979_11: cmp-eq s_1979_10 s_1979_9
        let s_1979_11: bool = ((s_1979_10) == (s_1979_9));
        // D s_1979_12: lsl s_1979_8 s_1979_6
        let s_1979_12: u64 = s_1979_8 << s_1979_6;
        // D s_1979_13: or s_1979_7 s_1979_12
        let s_1979_13: u64 = ((s_1979_7) | (s_1979_12));
        // D s_1979_14: cmpl s_1979_12
        let s_1979_14: u64 = !s_1979_12;
        // D s_1979_15: and s_1979_7 s_1979_14
        let s_1979_15: u64 = ((s_1979_7) & (s_1979_14));
        // D s_1979_16: select s_1979_11 s_1979_13 s_1979_15
        let s_1979_16: u64 = if s_1979_11 { s_1979_13 } else { s_1979_15 };
        // D s_1979_17: cast trunc s_1979_16 -> u8
        let s_1979_17: bool = ((s_1979_16) != 0);
        // D s_1979_18: cast zx s_1979_17 -> bv
        let s_1979_18: Bits = Bits::new(s_1979_17 as u128, 1u16);
        // C s_1979_19: const #0u : u8
        let s_1979_19: bool = false;
        // C s_1979_20: cast zx s_1979_19 -> bv
        let s_1979_20: Bits = Bits::new(s_1979_19 as u128, 1u16);
        // D s_1979_21: cmp-ne s_1979_18 s_1979_20
        let s_1979_21: bool = ((s_1979_18) != (s_1979_20));
        // D s_1979_22: write-var gs#408469 <= s_1979_21
        fn_state.gs_408469 = s_1979_21;
        // N s_1979_23: jump b1980
        return block_1980(state, tracer, fn_state);
    }
    fn block_1980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1980_0: read-var gs#408469:u8
        let s_1980_0: bool = fn_state.gs_408469;
        // N s_1980_1: branch s_1980_0 b1985 b1981
        if s_1980_0 {
            return block_1985(state, tracer, fn_state);
        } else {
            return block_1981(state, tracer, fn_state);
        };
    }
    fn block_1981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1981_0: const #15s : i
        let s_1981_0: i128 = 15;
        // D s_1981_1: read-var u#33271:u32
        let s_1981_1: u32 = fn_state.u_33271;
        // D s_1981_2: cast zx s_1981_1 -> bv
        let s_1981_2: Bits = Bits::new(s_1981_1 as u128, 32u16);
        // C s_1981_3: const #1u : u64
        let s_1981_3: u64 = 1;
        // D s_1981_4: bit-extract s_1981_2 s_1981_0 s_1981_3
        let s_1981_4: Bits = (Bits::new(
            ((s_1981_2) >> (s_1981_0)).value(),
            u16::try_from(s_1981_3).unwrap(),
        ));
        // D s_1981_5: cast reint s_1981_4 -> u8
        let s_1981_5: bool = ((s_1981_4.value()) != 0);
        // C s_1981_6: const #0s : i
        let s_1981_6: i128 = 0;
        // C s_1981_7: const #0u : u64
        let s_1981_7: u64 = 0;
        // D s_1981_8: cast zx s_1981_5 -> u64
        let s_1981_8: u64 = (s_1981_5 as u64);
        // C s_1981_9: const #1u : u64
        let s_1981_9: u64 = 1;
        // D s_1981_10: and s_1981_8 s_1981_9
        let s_1981_10: u64 = ((s_1981_8) & (s_1981_9));
        // D s_1981_11: cmp-eq s_1981_10 s_1981_9
        let s_1981_11: bool = ((s_1981_10) == (s_1981_9));
        // D s_1981_12: lsl s_1981_8 s_1981_6
        let s_1981_12: u64 = s_1981_8 << s_1981_6;
        // D s_1981_13: or s_1981_7 s_1981_12
        let s_1981_13: u64 = ((s_1981_7) | (s_1981_12));
        // D s_1981_14: cmpl s_1981_12
        let s_1981_14: u64 = !s_1981_12;
        // D s_1981_15: and s_1981_7 s_1981_14
        let s_1981_15: u64 = ((s_1981_7) & (s_1981_14));
        // D s_1981_16: select s_1981_11 s_1981_13 s_1981_15
        let s_1981_16: u64 = if s_1981_11 { s_1981_13 } else { s_1981_15 };
        // D s_1981_17: cast trunc s_1981_16 -> u8
        let s_1981_17: bool = ((s_1981_16) != 0);
        // D s_1981_18: cast zx s_1981_17 -> bv
        let s_1981_18: Bits = Bits::new(s_1981_17 as u128, 1u16);
        // C s_1981_19: const #0u : u8
        let s_1981_19: bool = false;
        // C s_1981_20: cast zx s_1981_19 -> bv
        let s_1981_20: Bits = Bits::new(s_1981_19 as u128, 1u16);
        // D s_1981_21: cmp-ne s_1981_18 s_1981_20
        let s_1981_21: bool = ((s_1981_18) != (s_1981_20));
        // D s_1981_22: write-var gs#408472 <= s_1981_21
        fn_state.gs_408472 = s_1981_21;
        // N s_1981_23: jump b1982
        return block_1982(state, tracer, fn_state);
    }
    fn block_1982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1982_0: read-var gs#408472:u8
        let s_1982_0: bool = fn_state.gs_408472;
        // N s_1982_1: branch s_1982_0 b1984 b1983
        if s_1982_0 {
            return block_1984(state, tracer, fn_state);
        } else {
            return block_1983(state, tracer, fn_state);
        };
    }
    fn block_1983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1983_0: read-var u#33272:u8
        let s_1983_0: u8 = fn_state.u_33272;
        // D s_1983_1: call decode_aarch32_instrs_TSB_A1enc_A_txt(s_1983_0)
        let s_1983_1: () = decode_aarch32_instrs_TSB_A1enc_A_txt(
            state,
            tracer,
            s_1983_0,
        );
        // N s_1983_2: return
        return;
    }
    fn block_1984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_1984_0: panic
        panic!("{:?}", ());
        // N s_1984_1: return
        return;
    }
    fn block_1985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1985_0: const #1u : u8
        let s_1985_0: bool = true;
        // D s_1985_1: write-var gs#408472 <= s_1985_0
        fn_state.gs_408472 = s_1985_0;
        // N s_1985_2: jump b1982
        return block_1982(state, tracer, fn_state);
    }
    fn block_1986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1986_0: const #1u : u8
        let s_1986_0: bool = true;
        // D s_1986_1: write-var gs#408469 <= s_1986_0
        fn_state.gs_408469 = s_1986_0;
        // N s_1986_2: jump b1980
        return block_1980(state, tracer, fn_state);
    }
    fn block_1987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1987_0: const #1u : u8
        let s_1987_0: bool = true;
        // D s_1987_1: write-var gs#408466 <= s_1987_0
        fn_state.gs_408466 = s_1987_0;
        // N s_1987_2: jump b1978
        return block_1978(state, tracer, fn_state);
    }
    fn block_1988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1988_0: const #1u : u8
        let s_1988_0: bool = true;
        // D s_1988_1: write-var gs#408463 <= s_1988_0
        fn_state.gs_408463 = s_1988_0;
        // N s_1988_2: jump b1976
        return block_1976(state, tracer, fn_state);
    }
    fn block_1989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1989_0: const #1u : u8
        let s_1989_0: bool = true;
        // D s_1989_1: write-var gs#408460 <= s_1989_0
        fn_state.gs_408460 = s_1989_0;
        // N s_1989_2: jump b1974
        return block_1974(state, tracer, fn_state);
    }
    fn block_1990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1990_0: const #1u : u8
        let s_1990_0: bool = true;
        // D s_1990_1: write-var gs#408457 <= s_1990_0
        fn_state.gs_408457 = s_1990_0;
        // N s_1990_2: jump b1972
        return block_1972(state, tracer, fn_state);
    }
    fn block_1991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1991_0: const #1u : u8
        let s_1991_0: bool = true;
        // D s_1991_1: write-var gs#408454 <= s_1991_0
        fn_state.gs_408454 = s_1991_0;
        // N s_1991_2: jump b1970
        return block_1970(state, tracer, fn_state);
    }
    fn block_1992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1992_0: read-var merge#var.1:struct
        let s_1992_0: u32 = fn_state.merge_var._1;
        // D s_1992_1: write-var u#33274 <= s_1992_0
        fn_state.u_33274 = s_1992_0;
        // C s_1992_2: const #0s : i
        let s_1992_2: i128 = 0;
        // D s_1992_3: read-var u#33274:u32
        let s_1992_3: u32 = fn_state.u_33274;
        // D s_1992_4: cast zx s_1992_3 -> bv
        let s_1992_4: Bits = Bits::new(s_1992_3 as u128, 32u16);
        // C s_1992_5: const #1s : i64
        let s_1992_5: i64 = 1;
        // C s_1992_6: cast zx s_1992_5 -> i
        let s_1992_6: i128 = (i128::try_from(s_1992_5).unwrap());
        // C s_1992_7: const #27s : i
        let s_1992_7: i128 = 27;
        // C s_1992_8: add s_1992_7 s_1992_6
        let s_1992_8: i128 = (s_1992_7 + s_1992_6);
        // D s_1992_9: bit-extract s_1992_4 s_1992_2 s_1992_8
        let s_1992_9: Bits = (Bits::new(
            ((s_1992_4) >> (s_1992_2)).value(),
            u16::try_from(s_1992_8).unwrap(),
        ));
        // D s_1992_10: cast reint s_1992_9 -> u28
        let s_1992_10: u32 = (s_1992_9.value() as u32);
        // D s_1992_11: cast zx s_1992_10 -> bv
        let s_1992_11: Bits = Bits::new(s_1992_10 as u128, 28u16);
        // C s_1992_12: const #52490260u : u28
        let s_1992_12: u32 = 52490260;
        // C s_1992_13: cast zx s_1992_12 -> bv
        let s_1992_13: Bits = Bits::new(s_1992_12 as u128, 28u16);
        // D s_1992_14: cmp-eq s_1992_11 s_1992_13
        let s_1992_14: bool = ((s_1992_11) == (s_1992_13));
        // N s_1992_15: branch s_1992_14 b2051 b1993
        if s_1992_14 {
            return block_2051(state, tracer, fn_state);
        } else {
            return block_1993(state, tracer, fn_state);
        };
    }
    fn block_1993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1993_0: const #0u : u8
        let s_1993_0: bool = false;
        // D s_1993_1: write-var gs#408480 <= s_1993_0
        fn_state.gs_408480 = s_1993_0;
        // N s_1993_2: jump b1994
        return block_1994(state, tracer, fn_state);
    }
    fn block_1994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1994_0: read-var gs#408480:u8
        let s_1994_0: bool = fn_state.gs_408480;
        // D s_1994_1: not s_1994_0
        let s_1994_1: bool = !s_1994_0;
        // N s_1994_2: branch s_1994_1 b2019 b1995
        if s_1994_1 {
            return block_2019(state, tracer, fn_state);
        } else {
            return block_1995(state, tracer, fn_state);
        };
    }
    fn block_1995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1995_0: const #3894s : i
        let s_1995_0: i128 = 3894;
        // C s_1995_1: const #14696u : u32
        let s_1995_1: u32 = 14696;
        // N s_1995_2: write-reg s_1995_1 <= s_1995_0
        let s_1995_2: () = {
            state.write_register::<i128>(s_1995_1 as isize, s_1995_0);
            tracer.write_register(s_1995_1 as isize, s_1995_0);
        };
        // C s_1995_3: const #28s : i
        let s_1995_3: i128 = 28;
        // C s_1995_4: const #4s : i
        let s_1995_4: i128 = 4;
        // D s_1995_5: read-var u#33274:u32
        let s_1995_5: u32 = fn_state.u_33274;
        // D s_1995_6: cast zx s_1995_5 -> bv
        let s_1995_6: Bits = Bits::new(s_1995_5 as u128, 32u16);
        // D s_1995_7: bit-extract s_1995_6 s_1995_3 s_1995_4
        let s_1995_7: Bits = (Bits::new(
            ((s_1995_6) >> (s_1995_3)).value(),
            u16::try_from(s_1995_4).unwrap(),
        ));
        // D s_1995_8: cast reint s_1995_7 -> u8
        let s_1995_8: u8 = (s_1995_7.value() as u8);
        // D s_1995_9: write-var u#33275 <= s_1995_8
        fn_state.u_33275 = s_1995_8;
        // C s_1995_10: const #8s : i
        let s_1995_10: i128 = 8;
        // D s_1995_11: read-var u#33274:u32
        let s_1995_11: u32 = fn_state.u_33274;
        // D s_1995_12: cast zx s_1995_11 -> bv
        let s_1995_12: Bits = Bits::new(s_1995_11 as u128, 32u16);
        // C s_1995_13: const #1u : u64
        let s_1995_13: u64 = 1;
        // D s_1995_14: bit-extract s_1995_12 s_1995_10 s_1995_13
        let s_1995_14: Bits = (Bits::new(
            ((s_1995_12) >> (s_1995_10)).value(),
            u16::try_from(s_1995_13).unwrap(),
        ));
        // D s_1995_15: cast reint s_1995_14 -> u8
        let s_1995_15: bool = ((s_1995_14.value()) != 0);
        // C s_1995_16: const #0s : i
        let s_1995_16: i128 = 0;
        // C s_1995_17: const #0u : u64
        let s_1995_17: u64 = 0;
        // D s_1995_18: cast zx s_1995_15 -> u64
        let s_1995_18: u64 = (s_1995_15 as u64);
        // C s_1995_19: const #1u : u64
        let s_1995_19: u64 = 1;
        // D s_1995_20: and s_1995_18 s_1995_19
        let s_1995_20: u64 = ((s_1995_18) & (s_1995_19));
        // D s_1995_21: cmp-eq s_1995_20 s_1995_19
        let s_1995_21: bool = ((s_1995_20) == (s_1995_19));
        // D s_1995_22: lsl s_1995_18 s_1995_16
        let s_1995_22: u64 = s_1995_18 << s_1995_16;
        // D s_1995_23: or s_1995_17 s_1995_22
        let s_1995_23: u64 = ((s_1995_17) | (s_1995_22));
        // D s_1995_24: cmpl s_1995_22
        let s_1995_24: u64 = !s_1995_22;
        // D s_1995_25: and s_1995_17 s_1995_24
        let s_1995_25: u64 = ((s_1995_17) & (s_1995_24));
        // D s_1995_26: select s_1995_21 s_1995_23 s_1995_25
        let s_1995_26: u64 = if s_1995_21 { s_1995_23 } else { s_1995_25 };
        // D s_1995_27: cast trunc s_1995_26 -> u8
        let s_1995_27: bool = ((s_1995_26) != 0);
        // D s_1995_28: cast zx s_1995_27 -> bv
        let s_1995_28: Bits = Bits::new(s_1995_27 as u128, 1u16);
        // C s_1995_29: const #1u : u8
        let s_1995_29: bool = true;
        // C s_1995_30: cast zx s_1995_29 -> bv
        let s_1995_30: Bits = Bits::new(s_1995_29 as u128, 1u16);
        // D s_1995_31: cmp-ne s_1995_28 s_1995_30
        let s_1995_31: bool = ((s_1995_28) != (s_1995_30));
        // N s_1995_32: branch s_1995_31 b2018 b1996
        if s_1995_31 {
            return block_2018(state, tracer, fn_state);
        } else {
            return block_1996(state, tracer, fn_state);
        };
    }
    fn block_1996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1996_0: const #9s : i
        let s_1996_0: i128 = 9;
        // D s_1996_1: read-var u#33274:u32
        let s_1996_1: u32 = fn_state.u_33274;
        // D s_1996_2: cast zx s_1996_1 -> bv
        let s_1996_2: Bits = Bits::new(s_1996_1 as u128, 32u16);
        // C s_1996_3: const #1u : u64
        let s_1996_3: u64 = 1;
        // D s_1996_4: bit-extract s_1996_2 s_1996_0 s_1996_3
        let s_1996_4: Bits = (Bits::new(
            ((s_1996_2) >> (s_1996_0)).value(),
            u16::try_from(s_1996_3).unwrap(),
        ));
        // D s_1996_5: cast reint s_1996_4 -> u8
        let s_1996_5: bool = ((s_1996_4.value()) != 0);
        // C s_1996_6: const #0s : i
        let s_1996_6: i128 = 0;
        // C s_1996_7: const #0u : u64
        let s_1996_7: u64 = 0;
        // D s_1996_8: cast zx s_1996_5 -> u64
        let s_1996_8: u64 = (s_1996_5 as u64);
        // C s_1996_9: const #1u : u64
        let s_1996_9: u64 = 1;
        // D s_1996_10: and s_1996_8 s_1996_9
        let s_1996_10: u64 = ((s_1996_8) & (s_1996_9));
        // D s_1996_11: cmp-eq s_1996_10 s_1996_9
        let s_1996_11: bool = ((s_1996_10) == (s_1996_9));
        // D s_1996_12: lsl s_1996_8 s_1996_6
        let s_1996_12: u64 = s_1996_8 << s_1996_6;
        // D s_1996_13: or s_1996_7 s_1996_12
        let s_1996_13: u64 = ((s_1996_7) | (s_1996_12));
        // D s_1996_14: cmpl s_1996_12
        let s_1996_14: u64 = !s_1996_12;
        // D s_1996_15: and s_1996_7 s_1996_14
        let s_1996_15: u64 = ((s_1996_7) & (s_1996_14));
        // D s_1996_16: select s_1996_11 s_1996_13 s_1996_15
        let s_1996_16: u64 = if s_1996_11 { s_1996_13 } else { s_1996_15 };
        // D s_1996_17: cast trunc s_1996_16 -> u8
        let s_1996_17: bool = ((s_1996_16) != 0);
        // D s_1996_18: cast zx s_1996_17 -> bv
        let s_1996_18: Bits = Bits::new(s_1996_17 as u128, 1u16);
        // C s_1996_19: const #1u : u8
        let s_1996_19: bool = true;
        // C s_1996_20: cast zx s_1996_19 -> bv
        let s_1996_20: Bits = Bits::new(s_1996_19 as u128, 1u16);
        // D s_1996_21: cmp-ne s_1996_18 s_1996_20
        let s_1996_21: bool = ((s_1996_18) != (s_1996_20));
        // D s_1996_22: write-var gs#408489 <= s_1996_21
        fn_state.gs_408489 = s_1996_21;
        // N s_1996_23: jump b1997
        return block_1997(state, tracer, fn_state);
    }
    fn block_1997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1997_0: read-var gs#408489:u8
        let s_1997_0: bool = fn_state.gs_408489;
        // N s_1997_1: branch s_1997_0 b2017 b1998
        if s_1997_0 {
            return block_2017(state, tracer, fn_state);
        } else {
            return block_1998(state, tracer, fn_state);
        };
    }
    fn block_1998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_1998_0: const #10s : i
        let s_1998_0: i128 = 10;
        // D s_1998_1: read-var u#33274:u32
        let s_1998_1: u32 = fn_state.u_33274;
        // D s_1998_2: cast zx s_1998_1 -> bv
        let s_1998_2: Bits = Bits::new(s_1998_1 as u128, 32u16);
        // C s_1998_3: const #1u : u64
        let s_1998_3: u64 = 1;
        // D s_1998_4: bit-extract s_1998_2 s_1998_0 s_1998_3
        let s_1998_4: Bits = (Bits::new(
            ((s_1998_2) >> (s_1998_0)).value(),
            u16::try_from(s_1998_3).unwrap(),
        ));
        // D s_1998_5: cast reint s_1998_4 -> u8
        let s_1998_5: bool = ((s_1998_4.value()) != 0);
        // C s_1998_6: const #0s : i
        let s_1998_6: i128 = 0;
        // C s_1998_7: const #0u : u64
        let s_1998_7: u64 = 0;
        // D s_1998_8: cast zx s_1998_5 -> u64
        let s_1998_8: u64 = (s_1998_5 as u64);
        // C s_1998_9: const #1u : u64
        let s_1998_9: u64 = 1;
        // D s_1998_10: and s_1998_8 s_1998_9
        let s_1998_10: u64 = ((s_1998_8) & (s_1998_9));
        // D s_1998_11: cmp-eq s_1998_10 s_1998_9
        let s_1998_11: bool = ((s_1998_10) == (s_1998_9));
        // D s_1998_12: lsl s_1998_8 s_1998_6
        let s_1998_12: u64 = s_1998_8 << s_1998_6;
        // D s_1998_13: or s_1998_7 s_1998_12
        let s_1998_13: u64 = ((s_1998_7) | (s_1998_12));
        // D s_1998_14: cmpl s_1998_12
        let s_1998_14: u64 = !s_1998_12;
        // D s_1998_15: and s_1998_7 s_1998_14
        let s_1998_15: u64 = ((s_1998_7) & (s_1998_14));
        // D s_1998_16: select s_1998_11 s_1998_13 s_1998_15
        let s_1998_16: u64 = if s_1998_11 { s_1998_13 } else { s_1998_15 };
        // D s_1998_17: cast trunc s_1998_16 -> u8
        let s_1998_17: bool = ((s_1998_16) != 0);
        // D s_1998_18: cast zx s_1998_17 -> bv
        let s_1998_18: Bits = Bits::new(s_1998_17 as u128, 1u16);
        // C s_1998_19: const #1u : u8
        let s_1998_19: bool = true;
        // C s_1998_20: cast zx s_1998_19 -> bv
        let s_1998_20: Bits = Bits::new(s_1998_19 as u128, 1u16);
        // D s_1998_21: cmp-ne s_1998_18 s_1998_20
        let s_1998_21: bool = ((s_1998_18) != (s_1998_20));
        // D s_1998_22: write-var gs#408492 <= s_1998_21
        fn_state.gs_408492 = s_1998_21;
        // N s_1998_23: jump b1999
        return block_1999(state, tracer, fn_state);
    }
    fn block_1999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_1999_0: read-var gs#408492:u8
        let s_1999_0: bool = fn_state.gs_408492;
        // N s_1999_1: branch s_1999_0 b2016 b2000
        if s_1999_0 {
            return block_2016(state, tracer, fn_state);
        } else {
            return block_2000(state, tracer, fn_state);
        };
    }
    fn block_2000<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2000_0: const #11s : i
        let s_2000_0: i128 = 11;
        // D s_2000_1: read-var u#33274:u32
        let s_2000_1: u32 = fn_state.u_33274;
        // D s_2000_2: cast zx s_2000_1 -> bv
        let s_2000_2: Bits = Bits::new(s_2000_1 as u128, 32u16);
        // C s_2000_3: const #1u : u64
        let s_2000_3: u64 = 1;
        // D s_2000_4: bit-extract s_2000_2 s_2000_0 s_2000_3
        let s_2000_4: Bits = (Bits::new(
            ((s_2000_2) >> (s_2000_0)).value(),
            u16::try_from(s_2000_3).unwrap(),
        ));
        // D s_2000_5: cast reint s_2000_4 -> u8
        let s_2000_5: bool = ((s_2000_4.value()) != 0);
        // C s_2000_6: const #0s : i
        let s_2000_6: i128 = 0;
        // C s_2000_7: const #0u : u64
        let s_2000_7: u64 = 0;
        // D s_2000_8: cast zx s_2000_5 -> u64
        let s_2000_8: u64 = (s_2000_5 as u64);
        // C s_2000_9: const #1u : u64
        let s_2000_9: u64 = 1;
        // D s_2000_10: and s_2000_8 s_2000_9
        let s_2000_10: u64 = ((s_2000_8) & (s_2000_9));
        // D s_2000_11: cmp-eq s_2000_10 s_2000_9
        let s_2000_11: bool = ((s_2000_10) == (s_2000_9));
        // D s_2000_12: lsl s_2000_8 s_2000_6
        let s_2000_12: u64 = s_2000_8 << s_2000_6;
        // D s_2000_13: or s_2000_7 s_2000_12
        let s_2000_13: u64 = ((s_2000_7) | (s_2000_12));
        // D s_2000_14: cmpl s_2000_12
        let s_2000_14: u64 = !s_2000_12;
        // D s_2000_15: and s_2000_7 s_2000_14
        let s_2000_15: u64 = ((s_2000_7) & (s_2000_14));
        // D s_2000_16: select s_2000_11 s_2000_13 s_2000_15
        let s_2000_16: u64 = if s_2000_11 { s_2000_13 } else { s_2000_15 };
        // D s_2000_17: cast trunc s_2000_16 -> u8
        let s_2000_17: bool = ((s_2000_16) != 0);
        // D s_2000_18: cast zx s_2000_17 -> bv
        let s_2000_18: Bits = Bits::new(s_2000_17 as u128, 1u16);
        // C s_2000_19: const #1u : u8
        let s_2000_19: bool = true;
        // C s_2000_20: cast zx s_2000_19 -> bv
        let s_2000_20: Bits = Bits::new(s_2000_19 as u128, 1u16);
        // D s_2000_21: cmp-ne s_2000_18 s_2000_20
        let s_2000_21: bool = ((s_2000_18) != (s_2000_20));
        // D s_2000_22: write-var gs#408495 <= s_2000_21
        fn_state.gs_408495 = s_2000_21;
        // N s_2000_23: jump b2001
        return block_2001(state, tracer, fn_state);
    }
    fn block_2001<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2001_0: read-var gs#408495:u8
        let s_2001_0: bool = fn_state.gs_408495;
        // N s_2001_1: branch s_2001_0 b2015 b2002
        if s_2001_0 {
            return block_2015(state, tracer, fn_state);
        } else {
            return block_2002(state, tracer, fn_state);
        };
    }
    fn block_2002<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2002_0: const #12s : i
        let s_2002_0: i128 = 12;
        // D s_2002_1: read-var u#33274:u32
        let s_2002_1: u32 = fn_state.u_33274;
        // D s_2002_2: cast zx s_2002_1 -> bv
        let s_2002_2: Bits = Bits::new(s_2002_1 as u128, 32u16);
        // C s_2002_3: const #1u : u64
        let s_2002_3: u64 = 1;
        // D s_2002_4: bit-extract s_2002_2 s_2002_0 s_2002_3
        let s_2002_4: Bits = (Bits::new(
            ((s_2002_2) >> (s_2002_0)).value(),
            u16::try_from(s_2002_3).unwrap(),
        ));
        // D s_2002_5: cast reint s_2002_4 -> u8
        let s_2002_5: bool = ((s_2002_4.value()) != 0);
        // C s_2002_6: const #0s : i
        let s_2002_6: i128 = 0;
        // C s_2002_7: const #0u : u64
        let s_2002_7: u64 = 0;
        // D s_2002_8: cast zx s_2002_5 -> u64
        let s_2002_8: u64 = (s_2002_5 as u64);
        // C s_2002_9: const #1u : u64
        let s_2002_9: u64 = 1;
        // D s_2002_10: and s_2002_8 s_2002_9
        let s_2002_10: u64 = ((s_2002_8) & (s_2002_9));
        // D s_2002_11: cmp-eq s_2002_10 s_2002_9
        let s_2002_11: bool = ((s_2002_10) == (s_2002_9));
        // D s_2002_12: lsl s_2002_8 s_2002_6
        let s_2002_12: u64 = s_2002_8 << s_2002_6;
        // D s_2002_13: or s_2002_7 s_2002_12
        let s_2002_13: u64 = ((s_2002_7) | (s_2002_12));
        // D s_2002_14: cmpl s_2002_12
        let s_2002_14: u64 = !s_2002_12;
        // D s_2002_15: and s_2002_7 s_2002_14
        let s_2002_15: u64 = ((s_2002_7) & (s_2002_14));
        // D s_2002_16: select s_2002_11 s_2002_13 s_2002_15
        let s_2002_16: u64 = if s_2002_11 { s_2002_13 } else { s_2002_15 };
        // D s_2002_17: cast trunc s_2002_16 -> u8
        let s_2002_17: bool = ((s_2002_16) != 0);
        // D s_2002_18: cast zx s_2002_17 -> bv
        let s_2002_18: Bits = Bits::new(s_2002_17 as u128, 1u16);
        // C s_2002_19: const #0u : u8
        let s_2002_19: bool = false;
        // C s_2002_20: cast zx s_2002_19 -> bv
        let s_2002_20: Bits = Bits::new(s_2002_19 as u128, 1u16);
        // D s_2002_21: cmp-ne s_2002_18 s_2002_20
        let s_2002_21: bool = ((s_2002_18) != (s_2002_20));
        // D s_2002_22: write-var gs#408498 <= s_2002_21
        fn_state.gs_408498 = s_2002_21;
        // N s_2002_23: jump b2003
        return block_2003(state, tracer, fn_state);
    }
    fn block_2003<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2003_0: read-var gs#408498:u8
        let s_2003_0: bool = fn_state.gs_408498;
        // N s_2003_1: branch s_2003_0 b2014 b2004
        if s_2003_0 {
            return block_2014(state, tracer, fn_state);
        } else {
            return block_2004(state, tracer, fn_state);
        };
    }
    fn block_2004<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2004_0: const #13s : i
        let s_2004_0: i128 = 13;
        // D s_2004_1: read-var u#33274:u32
        let s_2004_1: u32 = fn_state.u_33274;
        // D s_2004_2: cast zx s_2004_1 -> bv
        let s_2004_2: Bits = Bits::new(s_2004_1 as u128, 32u16);
        // C s_2004_3: const #1u : u64
        let s_2004_3: u64 = 1;
        // D s_2004_4: bit-extract s_2004_2 s_2004_0 s_2004_3
        let s_2004_4: Bits = (Bits::new(
            ((s_2004_2) >> (s_2004_0)).value(),
            u16::try_from(s_2004_3).unwrap(),
        ));
        // D s_2004_5: cast reint s_2004_4 -> u8
        let s_2004_5: bool = ((s_2004_4.value()) != 0);
        // C s_2004_6: const #0s : i
        let s_2004_6: i128 = 0;
        // C s_2004_7: const #0u : u64
        let s_2004_7: u64 = 0;
        // D s_2004_8: cast zx s_2004_5 -> u64
        let s_2004_8: u64 = (s_2004_5 as u64);
        // C s_2004_9: const #1u : u64
        let s_2004_9: u64 = 1;
        // D s_2004_10: and s_2004_8 s_2004_9
        let s_2004_10: u64 = ((s_2004_8) & (s_2004_9));
        // D s_2004_11: cmp-eq s_2004_10 s_2004_9
        let s_2004_11: bool = ((s_2004_10) == (s_2004_9));
        // D s_2004_12: lsl s_2004_8 s_2004_6
        let s_2004_12: u64 = s_2004_8 << s_2004_6;
        // D s_2004_13: or s_2004_7 s_2004_12
        let s_2004_13: u64 = ((s_2004_7) | (s_2004_12));
        // D s_2004_14: cmpl s_2004_12
        let s_2004_14: u64 = !s_2004_12;
        // D s_2004_15: and s_2004_7 s_2004_14
        let s_2004_15: u64 = ((s_2004_7) & (s_2004_14));
        // D s_2004_16: select s_2004_11 s_2004_13 s_2004_15
        let s_2004_16: u64 = if s_2004_11 { s_2004_13 } else { s_2004_15 };
        // D s_2004_17: cast trunc s_2004_16 -> u8
        let s_2004_17: bool = ((s_2004_16) != 0);
        // D s_2004_18: cast zx s_2004_17 -> bv
        let s_2004_18: Bits = Bits::new(s_2004_17 as u128, 1u16);
        // C s_2004_19: const #0u : u8
        let s_2004_19: bool = false;
        // C s_2004_20: cast zx s_2004_19 -> bv
        let s_2004_20: Bits = Bits::new(s_2004_19 as u128, 1u16);
        // D s_2004_21: cmp-ne s_2004_18 s_2004_20
        let s_2004_21: bool = ((s_2004_18) != (s_2004_20));
        // D s_2004_22: write-var gs#408501 <= s_2004_21
        fn_state.gs_408501 = s_2004_21;
        // N s_2004_23: jump b2005
        return block_2005(state, tracer, fn_state);
    }
    fn block_2005<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2005_0: read-var gs#408501:u8
        let s_2005_0: bool = fn_state.gs_408501;
        // N s_2005_1: branch s_2005_0 b2013 b2006
        if s_2005_0 {
            return block_2013(state, tracer, fn_state);
        } else {
            return block_2006(state, tracer, fn_state);
        };
    }
    fn block_2006<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2006_0: const #14s : i
        let s_2006_0: i128 = 14;
        // D s_2006_1: read-var u#33274:u32
        let s_2006_1: u32 = fn_state.u_33274;
        // D s_2006_2: cast zx s_2006_1 -> bv
        let s_2006_2: Bits = Bits::new(s_2006_1 as u128, 32u16);
        // C s_2006_3: const #1u : u64
        let s_2006_3: u64 = 1;
        // D s_2006_4: bit-extract s_2006_2 s_2006_0 s_2006_3
        let s_2006_4: Bits = (Bits::new(
            ((s_2006_2) >> (s_2006_0)).value(),
            u16::try_from(s_2006_3).unwrap(),
        ));
        // D s_2006_5: cast reint s_2006_4 -> u8
        let s_2006_5: bool = ((s_2006_4.value()) != 0);
        // C s_2006_6: const #0s : i
        let s_2006_6: i128 = 0;
        // C s_2006_7: const #0u : u64
        let s_2006_7: u64 = 0;
        // D s_2006_8: cast zx s_2006_5 -> u64
        let s_2006_8: u64 = (s_2006_5 as u64);
        // C s_2006_9: const #1u : u64
        let s_2006_9: u64 = 1;
        // D s_2006_10: and s_2006_8 s_2006_9
        let s_2006_10: u64 = ((s_2006_8) & (s_2006_9));
        // D s_2006_11: cmp-eq s_2006_10 s_2006_9
        let s_2006_11: bool = ((s_2006_10) == (s_2006_9));
        // D s_2006_12: lsl s_2006_8 s_2006_6
        let s_2006_12: u64 = s_2006_8 << s_2006_6;
        // D s_2006_13: or s_2006_7 s_2006_12
        let s_2006_13: u64 = ((s_2006_7) | (s_2006_12));
        // D s_2006_14: cmpl s_2006_12
        let s_2006_14: u64 = !s_2006_12;
        // D s_2006_15: and s_2006_7 s_2006_14
        let s_2006_15: u64 = ((s_2006_7) & (s_2006_14));
        // D s_2006_16: select s_2006_11 s_2006_13 s_2006_15
        let s_2006_16: u64 = if s_2006_11 { s_2006_13 } else { s_2006_15 };
        // D s_2006_17: cast trunc s_2006_16 -> u8
        let s_2006_17: bool = ((s_2006_16) != 0);
        // D s_2006_18: cast zx s_2006_17 -> bv
        let s_2006_18: Bits = Bits::new(s_2006_17 as u128, 1u16);
        // C s_2006_19: const #0u : u8
        let s_2006_19: bool = false;
        // C s_2006_20: cast zx s_2006_19 -> bv
        let s_2006_20: Bits = Bits::new(s_2006_19 as u128, 1u16);
        // D s_2006_21: cmp-ne s_2006_18 s_2006_20
        let s_2006_21: bool = ((s_2006_18) != (s_2006_20));
        // D s_2006_22: write-var gs#408504 <= s_2006_21
        fn_state.gs_408504 = s_2006_21;
        // N s_2006_23: jump b2007
        return block_2007(state, tracer, fn_state);
    }
    fn block_2007<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2007_0: read-var gs#408504:u8
        let s_2007_0: bool = fn_state.gs_408504;
        // N s_2007_1: branch s_2007_0 b2012 b2008
        if s_2007_0 {
            return block_2012(state, tracer, fn_state);
        } else {
            return block_2008(state, tracer, fn_state);
        };
    }
    fn block_2008<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2008_0: const #15s : i
        let s_2008_0: i128 = 15;
        // D s_2008_1: read-var u#33274:u32
        let s_2008_1: u32 = fn_state.u_33274;
        // D s_2008_2: cast zx s_2008_1 -> bv
        let s_2008_2: Bits = Bits::new(s_2008_1 as u128, 32u16);
        // C s_2008_3: const #1u : u64
        let s_2008_3: u64 = 1;
        // D s_2008_4: bit-extract s_2008_2 s_2008_0 s_2008_3
        let s_2008_4: Bits = (Bits::new(
            ((s_2008_2) >> (s_2008_0)).value(),
            u16::try_from(s_2008_3).unwrap(),
        ));
        // D s_2008_5: cast reint s_2008_4 -> u8
        let s_2008_5: bool = ((s_2008_4.value()) != 0);
        // C s_2008_6: const #0s : i
        let s_2008_6: i128 = 0;
        // C s_2008_7: const #0u : u64
        let s_2008_7: u64 = 0;
        // D s_2008_8: cast zx s_2008_5 -> u64
        let s_2008_8: u64 = (s_2008_5 as u64);
        // C s_2008_9: const #1u : u64
        let s_2008_9: u64 = 1;
        // D s_2008_10: and s_2008_8 s_2008_9
        let s_2008_10: u64 = ((s_2008_8) & (s_2008_9));
        // D s_2008_11: cmp-eq s_2008_10 s_2008_9
        let s_2008_11: bool = ((s_2008_10) == (s_2008_9));
        // D s_2008_12: lsl s_2008_8 s_2008_6
        let s_2008_12: u64 = s_2008_8 << s_2008_6;
        // D s_2008_13: or s_2008_7 s_2008_12
        let s_2008_13: u64 = ((s_2008_7) | (s_2008_12));
        // D s_2008_14: cmpl s_2008_12
        let s_2008_14: u64 = !s_2008_12;
        // D s_2008_15: and s_2008_7 s_2008_14
        let s_2008_15: u64 = ((s_2008_7) & (s_2008_14));
        // D s_2008_16: select s_2008_11 s_2008_13 s_2008_15
        let s_2008_16: u64 = if s_2008_11 { s_2008_13 } else { s_2008_15 };
        // D s_2008_17: cast trunc s_2008_16 -> u8
        let s_2008_17: bool = ((s_2008_16) != 0);
        // D s_2008_18: cast zx s_2008_17 -> bv
        let s_2008_18: Bits = Bits::new(s_2008_17 as u128, 1u16);
        // C s_2008_19: const #0u : u8
        let s_2008_19: bool = false;
        // C s_2008_20: cast zx s_2008_19 -> bv
        let s_2008_20: Bits = Bits::new(s_2008_19 as u128, 1u16);
        // D s_2008_21: cmp-ne s_2008_18 s_2008_20
        let s_2008_21: bool = ((s_2008_18) != (s_2008_20));
        // D s_2008_22: write-var gs#408507 <= s_2008_21
        fn_state.gs_408507 = s_2008_21;
        // N s_2008_23: jump b2009
        return block_2009(state, tracer, fn_state);
    }
    fn block_2009<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2009_0: read-var gs#408507:u8
        let s_2009_0: bool = fn_state.gs_408507;
        // N s_2009_1: branch s_2009_0 b2011 b2010
        if s_2009_0 {
            return block_2011(state, tracer, fn_state);
        } else {
            return block_2010(state, tracer, fn_state);
        };
    }
    fn block_2010<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2010_0: read-var u#33275:u8
        let s_2010_0: u8 = fn_state.u_33275;
        // D s_2010_1: call decode_aarch32_instrs_CSDB_A1enc_A_txt(s_2010_0)
        let s_2010_1: () = decode_aarch32_instrs_CSDB_A1enc_A_txt(
            state,
            tracer,
            s_2010_0,
        );
        // N s_2010_2: return
        return;
    }
    fn block_2011<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_2011_0: panic
        panic!("{:?}", ());
        // N s_2011_1: return
        return;
    }
    fn block_2012<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2012_0: const #1u : u8
        let s_2012_0: bool = true;
        // D s_2012_1: write-var gs#408507 <= s_2012_0
        fn_state.gs_408507 = s_2012_0;
        // N s_2012_2: jump b2009
        return block_2009(state, tracer, fn_state);
    }
    fn block_2013<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2013_0: const #1u : u8
        let s_2013_0: bool = true;
        // D s_2013_1: write-var gs#408504 <= s_2013_0
        fn_state.gs_408504 = s_2013_0;
        // N s_2013_2: jump b2007
        return block_2007(state, tracer, fn_state);
    }
    fn block_2014<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2014_0: const #1u : u8
        let s_2014_0: bool = true;
        // D s_2014_1: write-var gs#408501 <= s_2014_0
        fn_state.gs_408501 = s_2014_0;
        // N s_2014_2: jump b2005
        return block_2005(state, tracer, fn_state);
    }
    fn block_2015<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2015_0: const #1u : u8
        let s_2015_0: bool = true;
        // D s_2015_1: write-var gs#408498 <= s_2015_0
        fn_state.gs_408498 = s_2015_0;
        // N s_2015_2: jump b2003
        return block_2003(state, tracer, fn_state);
    }
    fn block_2016<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2016_0: const #1u : u8
        let s_2016_0: bool = true;
        // D s_2016_1: write-var gs#408495 <= s_2016_0
        fn_state.gs_408495 = s_2016_0;
        // N s_2016_2: jump b2001
        return block_2001(state, tracer, fn_state);
    }
    fn block_2017<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2017_0: const #1u : u8
        let s_2017_0: bool = true;
        // D s_2017_1: write-var gs#408492 <= s_2017_0
        fn_state.gs_408492 = s_2017_0;
        // N s_2017_2: jump b1999
        return block_1999(state, tracer, fn_state);
    }
    fn block_2018<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2018_0: const #1u : u8
        let s_2018_0: bool = true;
        // D s_2018_1: write-var gs#408489 <= s_2018_0
        fn_state.gs_408489 = s_2018_0;
        // N s_2018_2: jump b1997
        return block_1997(state, tracer, fn_state);
    }
    fn block_2019<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2019_0: read-var merge#var.1:struct
        let s_2019_0: u32 = fn_state.merge_var._1;
        // D s_2019_1: write-var u#33277 <= s_2019_0
        fn_state.u_33277 = s_2019_0;
        // C s_2019_2: const #0s : i
        let s_2019_2: i128 = 0;
        // D s_2019_3: read-var u#33277:u32
        let s_2019_3: u32 = fn_state.u_33277;
        // D s_2019_4: cast zx s_2019_3 -> bv
        let s_2019_4: Bits = Bits::new(s_2019_3 as u128, 32u16);
        // C s_2019_5: const #1s : i64
        let s_2019_5: i64 = 1;
        // C s_2019_6: cast zx s_2019_5 -> i
        let s_2019_6: i128 = (i128::try_from(s_2019_5).unwrap());
        // C s_2019_7: const #27s : i
        let s_2019_7: i128 = 27;
        // C s_2019_8: add s_2019_7 s_2019_6
        let s_2019_8: i128 = (s_2019_7 + s_2019_6);
        // D s_2019_9: bit-extract s_2019_4 s_2019_2 s_2019_8
        let s_2019_9: Bits = (Bits::new(
            ((s_2019_4) >> (s_2019_2)).value(),
            u16::try_from(s_2019_8).unwrap(),
        ));
        // D s_2019_10: cast reint s_2019_9 -> u28
        let s_2019_10: u32 = (s_2019_9.value() as u32);
        // D s_2019_11: cast zx s_2019_10 -> bv
        let s_2019_11: Bits = Bits::new(s_2019_10 as u128, 28u16);
        // C s_2019_12: const #52490262u : u28
        let s_2019_12: u32 = 52490262;
        // C s_2019_13: cast zx s_2019_12 -> bv
        let s_2019_13: Bits = Bits::new(s_2019_12 as u128, 28u16);
        // D s_2019_14: cmp-eq s_2019_11 s_2019_13
        let s_2019_14: bool = ((s_2019_11) == (s_2019_13));
        // N s_2019_15: branch s_2019_14 b2047 b2020
        if s_2019_14 {
            return block_2047(state, tracer, fn_state);
        } else {
            return block_2020(state, tracer, fn_state);
        };
    }
    fn block_2020<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2020_0: const #0u : u8
        let s_2020_0: bool = false;
        // D s_2020_1: write-var gs#408515 <= s_2020_0
        fn_state.gs_408515 = s_2020_0;
        // N s_2020_2: jump b2021
        return block_2021(state, tracer, fn_state);
    }
    fn block_2021<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2021_0: read-var gs#408515:u8
        let s_2021_0: bool = fn_state.gs_408515;
        // D s_2021_1: not s_2021_0
        let s_2021_1: bool = !s_2021_0;
        // N s_2021_2: branch s_2021_1 b2046 b2022
        if s_2021_1 {
            return block_2046(state, tracer, fn_state);
        } else {
            return block_2022(state, tracer, fn_state);
        };
    }
    fn block_2022<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2022_0: const #3938s : i
        let s_2022_0: i128 = 3938;
        // C s_2022_1: const #14696u : u32
        let s_2022_1: u32 = 14696;
        // N s_2022_2: write-reg s_2022_1 <= s_2022_0
        let s_2022_2: () = {
            state.write_register::<i128>(s_2022_1 as isize, s_2022_0);
            tracer.write_register(s_2022_1 as isize, s_2022_0);
        };
        // C s_2022_3: const #28s : i
        let s_2022_3: i128 = 28;
        // C s_2022_4: const #4s : i
        let s_2022_4: i128 = 4;
        // D s_2022_5: read-var u#33277:u32
        let s_2022_5: u32 = fn_state.u_33277;
        // D s_2022_6: cast zx s_2022_5 -> bv
        let s_2022_6: Bits = Bits::new(s_2022_5 as u128, 32u16);
        // D s_2022_7: bit-extract s_2022_6 s_2022_3 s_2022_4
        let s_2022_7: Bits = (Bits::new(
            ((s_2022_6) >> (s_2022_3)).value(),
            u16::try_from(s_2022_4).unwrap(),
        ));
        // D s_2022_8: cast reint s_2022_7 -> u8
        let s_2022_8: u8 = (s_2022_7.value() as u8);
        // D s_2022_9: write-var u#33278 <= s_2022_8
        fn_state.u_33278 = s_2022_8;
        // C s_2022_10: const #12s : i
        let s_2022_10: i128 = 12;
        // D s_2022_11: read-var u#33277:u32
        let s_2022_11: u32 = fn_state.u_33277;
        // D s_2022_12: cast zx s_2022_11 -> bv
        let s_2022_12: Bits = Bits::new(s_2022_11 as u128, 32u16);
        // C s_2022_13: const #1u : u64
        let s_2022_13: u64 = 1;
        // D s_2022_14: bit-extract s_2022_12 s_2022_10 s_2022_13
        let s_2022_14: Bits = (Bits::new(
            ((s_2022_12) >> (s_2022_10)).value(),
            u16::try_from(s_2022_13).unwrap(),
        ));
        // D s_2022_15: cast reint s_2022_14 -> u8
        let s_2022_15: bool = ((s_2022_14.value()) != 0);
        // C s_2022_16: const #0s : i
        let s_2022_16: i128 = 0;
        // C s_2022_17: const #0u : u64
        let s_2022_17: u64 = 0;
        // D s_2022_18: cast zx s_2022_15 -> u64
        let s_2022_18: u64 = (s_2022_15 as u64);
        // C s_2022_19: const #1u : u64
        let s_2022_19: u64 = 1;
        // D s_2022_20: and s_2022_18 s_2022_19
        let s_2022_20: u64 = ((s_2022_18) & (s_2022_19));
        // D s_2022_21: cmp-eq s_2022_20 s_2022_19
        let s_2022_21: bool = ((s_2022_20) == (s_2022_19));
        // D s_2022_22: lsl s_2022_18 s_2022_16
        let s_2022_22: u64 = s_2022_18 << s_2022_16;
        // D s_2022_23: or s_2022_17 s_2022_22
        let s_2022_23: u64 = ((s_2022_17) | (s_2022_22));
        // D s_2022_24: cmpl s_2022_22
        let s_2022_24: u64 = !s_2022_22;
        // D s_2022_25: and s_2022_17 s_2022_24
        let s_2022_25: u64 = ((s_2022_17) & (s_2022_24));
        // D s_2022_26: select s_2022_21 s_2022_23 s_2022_25
        let s_2022_26: u64 = if s_2022_21 { s_2022_23 } else { s_2022_25 };
        // D s_2022_27: cast trunc s_2022_26 -> u8
        let s_2022_27: bool = ((s_2022_26) != 0);
        // D s_2022_28: cast zx s_2022_27 -> bv
        let s_2022_28: Bits = Bits::new(s_2022_27 as u128, 1u16);
        // C s_2022_29: const #1u : u8
        let s_2022_29: bool = true;
        // C s_2022_30: cast zx s_2022_29 -> bv
        let s_2022_30: Bits = Bits::new(s_2022_29 as u128, 1u16);
        // D s_2022_31: cmp-ne s_2022_28 s_2022_30
        let s_2022_31: bool = ((s_2022_28) != (s_2022_30));
        // N s_2022_32: branch s_2022_31 b2045 b2023
        if s_2022_31 {
            return block_2045(state, tracer, fn_state);
        } else {
            return block_2023(state, tracer, fn_state);
        };
    }
    fn block_2023<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2023_0: const #13s : i
        let s_2023_0: i128 = 13;
        // D s_2023_1: read-var u#33277:u32
        let s_2023_1: u32 = fn_state.u_33277;
        // D s_2023_2: cast zx s_2023_1 -> bv
        let s_2023_2: Bits = Bits::new(s_2023_1 as u128, 32u16);
        // C s_2023_3: const #1u : u64
        let s_2023_3: u64 = 1;
        // D s_2023_4: bit-extract s_2023_2 s_2023_0 s_2023_3
        let s_2023_4: Bits = (Bits::new(
            ((s_2023_2) >> (s_2023_0)).value(),
            u16::try_from(s_2023_3).unwrap(),
        ));
        // D s_2023_5: cast reint s_2023_4 -> u8
        let s_2023_5: bool = ((s_2023_4.value()) != 0);
        // C s_2023_6: const #0s : i
        let s_2023_6: i128 = 0;
        // C s_2023_7: const #0u : u64
        let s_2023_7: u64 = 0;
        // D s_2023_8: cast zx s_2023_5 -> u64
        let s_2023_8: u64 = (s_2023_5 as u64);
        // C s_2023_9: const #1u : u64
        let s_2023_9: u64 = 1;
        // D s_2023_10: and s_2023_8 s_2023_9
        let s_2023_10: u64 = ((s_2023_8) & (s_2023_9));
        // D s_2023_11: cmp-eq s_2023_10 s_2023_9
        let s_2023_11: bool = ((s_2023_10) == (s_2023_9));
        // D s_2023_12: lsl s_2023_8 s_2023_6
        let s_2023_12: u64 = s_2023_8 << s_2023_6;
        // D s_2023_13: or s_2023_7 s_2023_12
        let s_2023_13: u64 = ((s_2023_7) | (s_2023_12));
        // D s_2023_14: cmpl s_2023_12
        let s_2023_14: u64 = !s_2023_12;
        // D s_2023_15: and s_2023_7 s_2023_14
        let s_2023_15: u64 = ((s_2023_7) & (s_2023_14));
        // D s_2023_16: select s_2023_11 s_2023_13 s_2023_15
        let s_2023_16: u64 = if s_2023_11 { s_2023_13 } else { s_2023_15 };
        // D s_2023_17: cast trunc s_2023_16 -> u8
        let s_2023_17: bool = ((s_2023_16) != 0);
        // D s_2023_18: cast zx s_2023_17 -> bv
        let s_2023_18: Bits = Bits::new(s_2023_17 as u128, 1u16);
        // C s_2023_19: const #1u : u8
        let s_2023_19: bool = true;
        // C s_2023_20: cast zx s_2023_19 -> bv
        let s_2023_20: Bits = Bits::new(s_2023_19 as u128, 1u16);
        // D s_2023_21: cmp-ne s_2023_18 s_2023_20
        let s_2023_21: bool = ((s_2023_18) != (s_2023_20));
        // D s_2023_22: write-var gs#408524 <= s_2023_21
        fn_state.gs_408524 = s_2023_21;
        // N s_2023_23: jump b2024
        return block_2024(state, tracer, fn_state);
    }
    fn block_2024<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2024_0: read-var gs#408524:u8
        let s_2024_0: bool = fn_state.gs_408524;
        // N s_2024_1: branch s_2024_0 b2044 b2025
        if s_2024_0 {
            return block_2044(state, tracer, fn_state);
        } else {
            return block_2025(state, tracer, fn_state);
        };
    }
    fn block_2025<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2025_0: const #14s : i
        let s_2025_0: i128 = 14;
        // D s_2025_1: read-var u#33277:u32
        let s_2025_1: u32 = fn_state.u_33277;
        // D s_2025_2: cast zx s_2025_1 -> bv
        let s_2025_2: Bits = Bits::new(s_2025_1 as u128, 32u16);
        // C s_2025_3: const #1u : u64
        let s_2025_3: u64 = 1;
        // D s_2025_4: bit-extract s_2025_2 s_2025_0 s_2025_3
        let s_2025_4: Bits = (Bits::new(
            ((s_2025_2) >> (s_2025_0)).value(),
            u16::try_from(s_2025_3).unwrap(),
        ));
        // D s_2025_5: cast reint s_2025_4 -> u8
        let s_2025_5: bool = ((s_2025_4.value()) != 0);
        // C s_2025_6: const #0s : i
        let s_2025_6: i128 = 0;
        // C s_2025_7: const #0u : u64
        let s_2025_7: u64 = 0;
        // D s_2025_8: cast zx s_2025_5 -> u64
        let s_2025_8: u64 = (s_2025_5 as u64);
        // C s_2025_9: const #1u : u64
        let s_2025_9: u64 = 1;
        // D s_2025_10: and s_2025_8 s_2025_9
        let s_2025_10: u64 = ((s_2025_8) & (s_2025_9));
        // D s_2025_11: cmp-eq s_2025_10 s_2025_9
        let s_2025_11: bool = ((s_2025_10) == (s_2025_9));
        // D s_2025_12: lsl s_2025_8 s_2025_6
        let s_2025_12: u64 = s_2025_8 << s_2025_6;
        // D s_2025_13: or s_2025_7 s_2025_12
        let s_2025_13: u64 = ((s_2025_7) | (s_2025_12));
        // D s_2025_14: cmpl s_2025_12
        let s_2025_14: u64 = !s_2025_12;
        // D s_2025_15: and s_2025_7 s_2025_14
        let s_2025_15: u64 = ((s_2025_7) & (s_2025_14));
        // D s_2025_16: select s_2025_11 s_2025_13 s_2025_15
        let s_2025_16: u64 = if s_2025_11 { s_2025_13 } else { s_2025_15 };
        // D s_2025_17: cast trunc s_2025_16 -> u8
        let s_2025_17: bool = ((s_2025_16) != 0);
        // D s_2025_18: cast zx s_2025_17 -> bv
        let s_2025_18: Bits = Bits::new(s_2025_17 as u128, 1u16);
        // C s_2025_19: const #1u : u8
        let s_2025_19: bool = true;
        // C s_2025_20: cast zx s_2025_19 -> bv
        let s_2025_20: Bits = Bits::new(s_2025_19 as u128, 1u16);
        // D s_2025_21: cmp-ne s_2025_18 s_2025_20
        let s_2025_21: bool = ((s_2025_18) != (s_2025_20));
        // D s_2025_22: write-var gs#408527 <= s_2025_21
        fn_state.gs_408527 = s_2025_21;
        // N s_2025_23: jump b2026
        return block_2026(state, tracer, fn_state);
    }
    fn block_2026<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2026_0: read-var gs#408527:u8
        let s_2026_0: bool = fn_state.gs_408527;
        // N s_2026_1: branch s_2026_0 b2043 b2027
        if s_2026_0 {
            return block_2043(state, tracer, fn_state);
        } else {
            return block_2027(state, tracer, fn_state);
        };
    }
    fn block_2027<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2027_0: const #15s : i
        let s_2027_0: i128 = 15;
        // D s_2027_1: read-var u#33277:u32
        let s_2027_1: u32 = fn_state.u_33277;
        // D s_2027_2: cast zx s_2027_1 -> bv
        let s_2027_2: Bits = Bits::new(s_2027_1 as u128, 32u16);
        // C s_2027_3: const #1u : u64
        let s_2027_3: u64 = 1;
        // D s_2027_4: bit-extract s_2027_2 s_2027_0 s_2027_3
        let s_2027_4: Bits = (Bits::new(
            ((s_2027_2) >> (s_2027_0)).value(),
            u16::try_from(s_2027_3).unwrap(),
        ));
        // D s_2027_5: cast reint s_2027_4 -> u8
        let s_2027_5: bool = ((s_2027_4.value()) != 0);
        // C s_2027_6: const #0s : i
        let s_2027_6: i128 = 0;
        // C s_2027_7: const #0u : u64
        let s_2027_7: u64 = 0;
        // D s_2027_8: cast zx s_2027_5 -> u64
        let s_2027_8: u64 = (s_2027_5 as u64);
        // C s_2027_9: const #1u : u64
        let s_2027_9: u64 = 1;
        // D s_2027_10: and s_2027_8 s_2027_9
        let s_2027_10: u64 = ((s_2027_8) & (s_2027_9));
        // D s_2027_11: cmp-eq s_2027_10 s_2027_9
        let s_2027_11: bool = ((s_2027_10) == (s_2027_9));
        // D s_2027_12: lsl s_2027_8 s_2027_6
        let s_2027_12: u64 = s_2027_8 << s_2027_6;
        // D s_2027_13: or s_2027_7 s_2027_12
        let s_2027_13: u64 = ((s_2027_7) | (s_2027_12));
        // D s_2027_14: cmpl s_2027_12
        let s_2027_14: u64 = !s_2027_12;
        // D s_2027_15: and s_2027_7 s_2027_14
        let s_2027_15: u64 = ((s_2027_7) & (s_2027_14));
        // D s_2027_16: select s_2027_11 s_2027_13 s_2027_15
        let s_2027_16: u64 = if s_2027_11 { s_2027_13 } else { s_2027_15 };
        // D s_2027_17: cast trunc s_2027_16 -> u8
        let s_2027_17: bool = ((s_2027_16) != 0);
        // D s_2027_18: cast zx s_2027_17 -> bv
        let s_2027_18: Bits = Bits::new(s_2027_17 as u128, 1u16);
        // C s_2027_19: const #1u : u8
        let s_2027_19: bool = true;
        // C s_2027_20: cast zx s_2027_19 -> bv
        let s_2027_20: Bits = Bits::new(s_2027_19 as u128, 1u16);
        // D s_2027_21: cmp-ne s_2027_18 s_2027_20
        let s_2027_21: bool = ((s_2027_18) != (s_2027_20));
        // D s_2027_22: write-var gs#408530 <= s_2027_21
        fn_state.gs_408530 = s_2027_21;
        // N s_2027_23: jump b2028
        return block_2028(state, tracer, fn_state);
    }
    fn block_2028<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2028_0: read-var gs#408530:u8
        let s_2028_0: bool = fn_state.gs_408530;
        // N s_2028_1: branch s_2028_0 b2042 b2029
        if s_2028_0 {
            return block_2042(state, tracer, fn_state);
        } else {
            return block_2029(state, tracer, fn_state);
        };
    }
    fn block_2029<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2029_0: const #8s : i
        let s_2029_0: i128 = 8;
        // D s_2029_1: read-var u#33277:u32
        let s_2029_1: u32 = fn_state.u_33277;
        // D s_2029_2: cast zx s_2029_1 -> bv
        let s_2029_2: Bits = Bits::new(s_2029_1 as u128, 32u16);
        // C s_2029_3: const #1u : u64
        let s_2029_3: u64 = 1;
        // D s_2029_4: bit-extract s_2029_2 s_2029_0 s_2029_3
        let s_2029_4: Bits = (Bits::new(
            ((s_2029_2) >> (s_2029_0)).value(),
            u16::try_from(s_2029_3).unwrap(),
        ));
        // D s_2029_5: cast reint s_2029_4 -> u8
        let s_2029_5: bool = ((s_2029_4.value()) != 0);
        // C s_2029_6: const #0s : i
        let s_2029_6: i128 = 0;
        // C s_2029_7: const #0u : u64
        let s_2029_7: u64 = 0;
        // D s_2029_8: cast zx s_2029_5 -> u64
        let s_2029_8: u64 = (s_2029_5 as u64);
        // C s_2029_9: const #1u : u64
        let s_2029_9: u64 = 1;
        // D s_2029_10: and s_2029_8 s_2029_9
        let s_2029_10: u64 = ((s_2029_8) & (s_2029_9));
        // D s_2029_11: cmp-eq s_2029_10 s_2029_9
        let s_2029_11: bool = ((s_2029_10) == (s_2029_9));
        // D s_2029_12: lsl s_2029_8 s_2029_6
        let s_2029_12: u64 = s_2029_8 << s_2029_6;
        // D s_2029_13: or s_2029_7 s_2029_12
        let s_2029_13: u64 = ((s_2029_7) | (s_2029_12));
        // D s_2029_14: cmpl s_2029_12
        let s_2029_14: u64 = !s_2029_12;
        // D s_2029_15: and s_2029_7 s_2029_14
        let s_2029_15: u64 = ((s_2029_7) & (s_2029_14));
        // D s_2029_16: select s_2029_11 s_2029_13 s_2029_15
        let s_2029_16: u64 = if s_2029_11 { s_2029_13 } else { s_2029_15 };
        // D s_2029_17: cast trunc s_2029_16 -> u8
        let s_2029_17: bool = ((s_2029_16) != 0);
        // D s_2029_18: cast zx s_2029_17 -> bv
        let s_2029_18: Bits = Bits::new(s_2029_17 as u128, 1u16);
        // C s_2029_19: const #0u : u8
        let s_2029_19: bool = false;
        // C s_2029_20: cast zx s_2029_19 -> bv
        let s_2029_20: Bits = Bits::new(s_2029_19 as u128, 1u16);
        // D s_2029_21: cmp-ne s_2029_18 s_2029_20
        let s_2029_21: bool = ((s_2029_18) != (s_2029_20));
        // D s_2029_22: write-var gs#408533 <= s_2029_21
        fn_state.gs_408533 = s_2029_21;
        // N s_2029_23: jump b2030
        return block_2030(state, tracer, fn_state);
    }
    fn block_2030<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2030_0: read-var gs#408533:u8
        let s_2030_0: bool = fn_state.gs_408533;
        // N s_2030_1: branch s_2030_0 b2041 b2031
        if s_2030_0 {
            return block_2041(state, tracer, fn_state);
        } else {
            return block_2031(state, tracer, fn_state);
        };
    }
    fn block_2031<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2031_0: const #9s : i
        let s_2031_0: i128 = 9;
        // D s_2031_1: read-var u#33277:u32
        let s_2031_1: u32 = fn_state.u_33277;
        // D s_2031_2: cast zx s_2031_1 -> bv
        let s_2031_2: Bits = Bits::new(s_2031_1 as u128, 32u16);
        // C s_2031_3: const #1u : u64
        let s_2031_3: u64 = 1;
        // D s_2031_4: bit-extract s_2031_2 s_2031_0 s_2031_3
        let s_2031_4: Bits = (Bits::new(
            ((s_2031_2) >> (s_2031_0)).value(),
            u16::try_from(s_2031_3).unwrap(),
        ));
        // D s_2031_5: cast reint s_2031_4 -> u8
        let s_2031_5: bool = ((s_2031_4.value()) != 0);
        // C s_2031_6: const #0s : i
        let s_2031_6: i128 = 0;
        // C s_2031_7: const #0u : u64
        let s_2031_7: u64 = 0;
        // D s_2031_8: cast zx s_2031_5 -> u64
        let s_2031_8: u64 = (s_2031_5 as u64);
        // C s_2031_9: const #1u : u64
        let s_2031_9: u64 = 1;
        // D s_2031_10: and s_2031_8 s_2031_9
        let s_2031_10: u64 = ((s_2031_8) & (s_2031_9));
        // D s_2031_11: cmp-eq s_2031_10 s_2031_9
        let s_2031_11: bool = ((s_2031_10) == (s_2031_9));
        // D s_2031_12: lsl s_2031_8 s_2031_6
        let s_2031_12: u64 = s_2031_8 << s_2031_6;
        // D s_2031_13: or s_2031_7 s_2031_12
        let s_2031_13: u64 = ((s_2031_7) | (s_2031_12));
        // D s_2031_14: cmpl s_2031_12
        let s_2031_14: u64 = !s_2031_12;
        // D s_2031_15: and s_2031_7 s_2031_14
        let s_2031_15: u64 = ((s_2031_7) & (s_2031_14));
        // D s_2031_16: select s_2031_11 s_2031_13 s_2031_15
        let s_2031_16: u64 = if s_2031_11 { s_2031_13 } else { s_2031_15 };
        // D s_2031_17: cast trunc s_2031_16 -> u8
        let s_2031_17: bool = ((s_2031_16) != 0);
        // D s_2031_18: cast zx s_2031_17 -> bv
        let s_2031_18: Bits = Bits::new(s_2031_17 as u128, 1u16);
        // C s_2031_19: const #0u : u8
        let s_2031_19: bool = false;
        // C s_2031_20: cast zx s_2031_19 -> bv
        let s_2031_20: Bits = Bits::new(s_2031_19 as u128, 1u16);
        // D s_2031_21: cmp-ne s_2031_18 s_2031_20
        let s_2031_21: bool = ((s_2031_18) != (s_2031_20));
        // D s_2031_22: write-var gs#408536 <= s_2031_21
        fn_state.gs_408536 = s_2031_21;
        // N s_2031_23: jump b2032
        return block_2032(state, tracer, fn_state);
    }
    fn block_2032<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2032_0: read-var gs#408536:u8
        let s_2032_0: bool = fn_state.gs_408536;
        // N s_2032_1: branch s_2032_0 b2040 b2033
        if s_2032_0 {
            return block_2040(state, tracer, fn_state);
        } else {
            return block_2033(state, tracer, fn_state);
        };
    }
    fn block_2033<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2033_0: const #10s : i
        let s_2033_0: i128 = 10;
        // D s_2033_1: read-var u#33277:u32
        let s_2033_1: u32 = fn_state.u_33277;
        // D s_2033_2: cast zx s_2033_1 -> bv
        let s_2033_2: Bits = Bits::new(s_2033_1 as u128, 32u16);
        // C s_2033_3: const #1u : u64
        let s_2033_3: u64 = 1;
        // D s_2033_4: bit-extract s_2033_2 s_2033_0 s_2033_3
        let s_2033_4: Bits = (Bits::new(
            ((s_2033_2) >> (s_2033_0)).value(),
            u16::try_from(s_2033_3).unwrap(),
        ));
        // D s_2033_5: cast reint s_2033_4 -> u8
        let s_2033_5: bool = ((s_2033_4.value()) != 0);
        // C s_2033_6: const #0s : i
        let s_2033_6: i128 = 0;
        // C s_2033_7: const #0u : u64
        let s_2033_7: u64 = 0;
        // D s_2033_8: cast zx s_2033_5 -> u64
        let s_2033_8: u64 = (s_2033_5 as u64);
        // C s_2033_9: const #1u : u64
        let s_2033_9: u64 = 1;
        // D s_2033_10: and s_2033_8 s_2033_9
        let s_2033_10: u64 = ((s_2033_8) & (s_2033_9));
        // D s_2033_11: cmp-eq s_2033_10 s_2033_9
        let s_2033_11: bool = ((s_2033_10) == (s_2033_9));
        // D s_2033_12: lsl s_2033_8 s_2033_6
        let s_2033_12: u64 = s_2033_8 << s_2033_6;
        // D s_2033_13: or s_2033_7 s_2033_12
        let s_2033_13: u64 = ((s_2033_7) | (s_2033_12));
        // D s_2033_14: cmpl s_2033_12
        let s_2033_14: u64 = !s_2033_12;
        // D s_2033_15: and s_2033_7 s_2033_14
        let s_2033_15: u64 = ((s_2033_7) & (s_2033_14));
        // D s_2033_16: select s_2033_11 s_2033_13 s_2033_15
        let s_2033_16: u64 = if s_2033_11 { s_2033_13 } else { s_2033_15 };
        // D s_2033_17: cast trunc s_2033_16 -> u8
        let s_2033_17: bool = ((s_2033_16) != 0);
        // D s_2033_18: cast zx s_2033_17 -> bv
        let s_2033_18: Bits = Bits::new(s_2033_17 as u128, 1u16);
        // C s_2033_19: const #0u : u8
        let s_2033_19: bool = false;
        // C s_2033_20: cast zx s_2033_19 -> bv
        let s_2033_20: Bits = Bits::new(s_2033_19 as u128, 1u16);
        // D s_2033_21: cmp-ne s_2033_18 s_2033_20
        let s_2033_21: bool = ((s_2033_18) != (s_2033_20));
        // D s_2033_22: write-var gs#408539 <= s_2033_21
        fn_state.gs_408539 = s_2033_21;
        // N s_2033_23: jump b2034
        return block_2034(state, tracer, fn_state);
    }
    fn block_2034<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2034_0: read-var gs#408539:u8
        let s_2034_0: bool = fn_state.gs_408539;
        // N s_2034_1: branch s_2034_0 b2039 b2035
        if s_2034_0 {
            return block_2039(state, tracer, fn_state);
        } else {
            return block_2035(state, tracer, fn_state);
        };
    }
    fn block_2035<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2035_0: const #11s : i
        let s_2035_0: i128 = 11;
        // D s_2035_1: read-var u#33277:u32
        let s_2035_1: u32 = fn_state.u_33277;
        // D s_2035_2: cast zx s_2035_1 -> bv
        let s_2035_2: Bits = Bits::new(s_2035_1 as u128, 32u16);
        // C s_2035_3: const #1u : u64
        let s_2035_3: u64 = 1;
        // D s_2035_4: bit-extract s_2035_2 s_2035_0 s_2035_3
        let s_2035_4: Bits = (Bits::new(
            ((s_2035_2) >> (s_2035_0)).value(),
            u16::try_from(s_2035_3).unwrap(),
        ));
        // D s_2035_5: cast reint s_2035_4 -> u8
        let s_2035_5: bool = ((s_2035_4.value()) != 0);
        // C s_2035_6: const #0s : i
        let s_2035_6: i128 = 0;
        // C s_2035_7: const #0u : u64
        let s_2035_7: u64 = 0;
        // D s_2035_8: cast zx s_2035_5 -> u64
        let s_2035_8: u64 = (s_2035_5 as u64);
        // C s_2035_9: const #1u : u64
        let s_2035_9: u64 = 1;
        // D s_2035_10: and s_2035_8 s_2035_9
        let s_2035_10: u64 = ((s_2035_8) & (s_2035_9));
        // D s_2035_11: cmp-eq s_2035_10 s_2035_9
        let s_2035_11: bool = ((s_2035_10) == (s_2035_9));
        // D s_2035_12: lsl s_2035_8 s_2035_6
        let s_2035_12: u64 = s_2035_8 << s_2035_6;
        // D s_2035_13: or s_2035_7 s_2035_12
        let s_2035_13: u64 = ((s_2035_7) | (s_2035_12));
        // D s_2035_14: cmpl s_2035_12
        let s_2035_14: u64 = !s_2035_12;
        // D s_2035_15: and s_2035_7 s_2035_14
        let s_2035_15: u64 = ((s_2035_7) & (s_2035_14));
        // D s_2035_16: select s_2035_11 s_2035_13 s_2035_15
        let s_2035_16: u64 = if s_2035_11 { s_2035_13 } else { s_2035_15 };
        // D s_2035_17: cast trunc s_2035_16 -> u8
        let s_2035_17: bool = ((s_2035_16) != 0);
        // D s_2035_18: cast zx s_2035_17 -> bv
        let s_2035_18: Bits = Bits::new(s_2035_17 as u128, 1u16);
        // C s_2035_19: const #0u : u8
        let s_2035_19: bool = false;
        // C s_2035_20: cast zx s_2035_19 -> bv
        let s_2035_20: Bits = Bits::new(s_2035_19 as u128, 1u16);
        // D s_2035_21: cmp-ne s_2035_18 s_2035_20
        let s_2035_21: bool = ((s_2035_18) != (s_2035_20));
        // D s_2035_22: write-var gs#408542 <= s_2035_21
        fn_state.gs_408542 = s_2035_21;
        // N s_2035_23: jump b2036
        return block_2036(state, tracer, fn_state);
    }
    fn block_2036<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2036_0: read-var gs#408542:u8
        let s_2036_0: bool = fn_state.gs_408542;
        // N s_2036_1: branch s_2036_0 b2038 b2037
        if s_2036_0 {
            return block_2038(state, tracer, fn_state);
        } else {
            return block_2037(state, tracer, fn_state);
        };
    }
    fn block_2037<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2037_0: read-var u#33278:u8
        let s_2037_0: u8 = fn_state.u_33278;
        // D s_2037_1: call decode_aarch32_instrs_CLRBHB_A1enc_A_txt(s_2037_0)
        let s_2037_1: () = decode_aarch32_instrs_CLRBHB_A1enc_A_txt(
            state,
            tracer,
            s_2037_0,
        );
        // N s_2037_2: return
        return;
    }
    fn block_2038<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_2038_0: panic
        panic!("{:?}", ());
        // N s_2038_1: return
        return;
    }
    fn block_2039<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2039_0: const #1u : u8
        let s_2039_0: bool = true;
        // D s_2039_1: write-var gs#408542 <= s_2039_0
        fn_state.gs_408542 = s_2039_0;
        // N s_2039_2: jump b2036
        return block_2036(state, tracer, fn_state);
    }
    fn block_2040<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2040_0: const #1u : u8
        let s_2040_0: bool = true;
        // D s_2040_1: write-var gs#408539 <= s_2040_0
        fn_state.gs_408539 = s_2040_0;
        // N s_2040_2: jump b2034
        return block_2034(state, tracer, fn_state);
    }
    fn block_2041<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2041_0: const #1u : u8
        let s_2041_0: bool = true;
        // D s_2041_1: write-var gs#408536 <= s_2041_0
        fn_state.gs_408536 = s_2041_0;
        // N s_2041_2: jump b2032
        return block_2032(state, tracer, fn_state);
    }
    fn block_2042<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2042_0: const #1u : u8
        let s_2042_0: bool = true;
        // D s_2042_1: write-var gs#408533 <= s_2042_0
        fn_state.gs_408533 = s_2042_0;
        // N s_2042_2: jump b2030
        return block_2030(state, tracer, fn_state);
    }
    fn block_2043<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2043_0: const #1u : u8
        let s_2043_0: bool = true;
        // D s_2043_1: write-var gs#408530 <= s_2043_0
        fn_state.gs_408530 = s_2043_0;
        // N s_2043_2: jump b2028
        return block_2028(state, tracer, fn_state);
    }
    fn block_2044<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2044_0: const #1u : u8
        let s_2044_0: bool = true;
        // D s_2044_1: write-var gs#408527 <= s_2044_0
        fn_state.gs_408527 = s_2044_0;
        // N s_2044_2: jump b2026
        return block_2026(state, tracer, fn_state);
    }
    fn block_2045<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2045_0: const #1u : u8
        let s_2045_0: bool = true;
        // D s_2045_1: write-var gs#408524 <= s_2045_0
        fn_state.gs_408524 = s_2045_0;
        // N s_2045_2: jump b2024
        return block_2024(state, tracer, fn_state);
    }
    fn block_2046<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // N s_2046_0: panic
        panic!("{:?}", ());
        // N s_2046_1: return
        return;
    }
    fn block_2047<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2047_0: const #28s : i
        let s_2047_0: i128 = 28;
        // C s_2047_1: const #4s : i
        let s_2047_1: i128 = 4;
        // D s_2047_2: read-var u#33277:u32
        let s_2047_2: u32 = fn_state.u_33277;
        // D s_2047_3: cast zx s_2047_2 -> bv
        let s_2047_3: Bits = Bits::new(s_2047_2 as u128, 32u16);
        // D s_2047_4: bit-extract s_2047_3 s_2047_0 s_2047_1
        let s_2047_4: Bits = (Bits::new(
            ((s_2047_3) >> (s_2047_0)).value(),
            u16::try_from(s_2047_1).unwrap(),
        ));
        // D s_2047_5: cast reint s_2047_4 -> u8
        let s_2047_5: u8 = (s_2047_4.value() as u8);
        // D s_2047_6: cast zx s_2047_5 -> bv
        let s_2047_6: Bits = Bits::new(s_2047_5 as u128, 4u16);
        // C s_2047_7: const #15u : u8
        let s_2047_7: u8 = 15;
        // C s_2047_8: cast zx s_2047_7 -> bv
        let s_2047_8: Bits = Bits::new(s_2047_7 as u128, 4u16);
        // D s_2047_9: cmp-ne s_2047_6 s_2047_8
        let s_2047_9: bool = ((s_2047_6) != (s_2047_8));
        // N s_2047_10: branch s_2047_9 b2050 b2048
        if s_2047_9 {
            return block_2050(state, tracer, fn_state);
        } else {
            return block_2048(state, tracer, fn_state);
        };
    }
    fn block_2048<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2048_0: const #0u : u8
        let s_2048_0: bool = false;
        // D s_2048_1: write-var gs#408514 <= s_2048_0
        fn_state.gs_408514 = s_2048_0;
        // N s_2048_2: jump b2049
        return block_2049(state, tracer, fn_state);
    }
    fn block_2049<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2049_0: read-var gs#408514:u8
        let s_2049_0: bool = fn_state.gs_408514;
        // D s_2049_1: write-var gs#408515 <= s_2049_0
        fn_state.gs_408515 = s_2049_0;
        // N s_2049_2: jump b2021
        return block_2021(state, tracer, fn_state);
    }
    fn block_2050<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2050_0: const #3938s : i
        let s_2050_0: i128 = 3938;
        // C s_2050_1: const #14696u : u32
        let s_2050_1: u32 = 14696;
        // D s_2050_2: read-reg s_2050_1:i
        let s_2050_2: i128 = {
            let value = state.read_register::<i128>(s_2050_1 as isize);
            tracer.read_register(s_2050_1 as isize, value);
            value
        };
        // D s_2050_3: cmp-lt s_2050_2 s_2050_0
        let s_2050_3: bool = ((s_2050_2) < (s_2050_0));
        // D s_2050_4: write-var gs#408514 <= s_2050_3
        fn_state.gs_408514 = s_2050_3;
        // N s_2050_5: jump b2049
        return block_2049(state, tracer, fn_state);
    }
    fn block_2051<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2051_0: const #28s : i
        let s_2051_0: i128 = 28;
        // C s_2051_1: const #4s : i
        let s_2051_1: i128 = 4;
        // D s_2051_2: read-var u#33274:u32
        let s_2051_2: u32 = fn_state.u_33274;
        // D s_2051_3: cast zx s_2051_2 -> bv
        let s_2051_3: Bits = Bits::new(s_2051_2 as u128, 32u16);
        // D s_2051_4: bit-extract s_2051_3 s_2051_0 s_2051_1
        let s_2051_4: Bits = (Bits::new(
            ((s_2051_3) >> (s_2051_0)).value(),
            u16::try_from(s_2051_1).unwrap(),
        ));
        // D s_2051_5: cast reint s_2051_4 -> u8
        let s_2051_5: u8 = (s_2051_4.value() as u8);
        // D s_2051_6: cast zx s_2051_5 -> bv
        let s_2051_6: Bits = Bits::new(s_2051_5 as u128, 4u16);
        // C s_2051_7: const #15u : u8
        let s_2051_7: u8 = 15;
        // C s_2051_8: cast zx s_2051_7 -> bv
        let s_2051_8: Bits = Bits::new(s_2051_7 as u128, 4u16);
        // D s_2051_9: cmp-ne s_2051_6 s_2051_8
        let s_2051_9: bool = ((s_2051_6) != (s_2051_8));
        // N s_2051_10: branch s_2051_9 b2054 b2052
        if s_2051_9 {
            return block_2054(state, tracer, fn_state);
        } else {
            return block_2052(state, tracer, fn_state);
        };
    }
    fn block_2052<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2052_0: const #0u : u8
        let s_2052_0: bool = false;
        // D s_2052_1: write-var gs#408479 <= s_2052_0
        fn_state.gs_408479 = s_2052_0;
        // N s_2052_2: jump b2053
        return block_2053(state, tracer, fn_state);
    }
    fn block_2053<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2053_0: read-var gs#408479:u8
        let s_2053_0: bool = fn_state.gs_408479;
        // D s_2053_1: write-var gs#408480 <= s_2053_0
        fn_state.gs_408480 = s_2053_0;
        // N s_2053_2: jump b1994
        return block_1994(state, tracer, fn_state);
    }
    fn block_2054<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2054_0: const #3894s : i
        let s_2054_0: i128 = 3894;
        // C s_2054_1: const #14696u : u32
        let s_2054_1: u32 = 14696;
        // D s_2054_2: read-reg s_2054_1:i
        let s_2054_2: i128 = {
            let value = state.read_register::<i128>(s_2054_1 as isize);
            tracer.read_register(s_2054_1 as isize, value);
            value
        };
        // D s_2054_3: cmp-lt s_2054_2 s_2054_0
        let s_2054_3: bool = ((s_2054_2) < (s_2054_0));
        // D s_2054_4: write-var gs#408479 <= s_2054_3
        fn_state.gs_408479 = s_2054_3;
        // N s_2054_5: jump b2053
        return block_2053(state, tracer, fn_state);
    }
    fn block_2055<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2055_0: const #28s : i
        let s_2055_0: i128 = 28;
        // C s_2055_1: const #4s : i
        let s_2055_1: i128 = 4;
        // D s_2055_2: read-var u#33271:u32
        let s_2055_2: u32 = fn_state.u_33271;
        // D s_2055_3: cast zx s_2055_2 -> bv
        let s_2055_3: Bits = Bits::new(s_2055_2 as u128, 32u16);
        // D s_2055_4: bit-extract s_2055_3 s_2055_0 s_2055_1
        let s_2055_4: Bits = (Bits::new(
            ((s_2055_3) >> (s_2055_0)).value(),
            u16::try_from(s_2055_1).unwrap(),
        ));
        // D s_2055_5: cast reint s_2055_4 -> u8
        let s_2055_5: u8 = (s_2055_4.value() as u8);
        // D s_2055_6: cast zx s_2055_5 -> bv
        let s_2055_6: Bits = Bits::new(s_2055_5 as u128, 4u16);
        // C s_2055_7: const #15u : u8
        let s_2055_7: u8 = 15;
        // C s_2055_8: cast zx s_2055_7 -> bv
        let s_2055_8: Bits = Bits::new(s_2055_7 as u128, 4u16);
        // D s_2055_9: cmp-ne s_2055_6 s_2055_8
        let s_2055_9: bool = ((s_2055_6) != (s_2055_8));
        // N s_2055_10: branch s_2055_9 b2058 b2056
        if s_2055_9 {
            return block_2058(state, tracer, fn_state);
        } else {
            return block_2056(state, tracer, fn_state);
        };
    }
    fn block_2056<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2056_0: const #0u : u8
        let s_2056_0: bool = false;
        // D s_2056_1: write-var gs#408444 <= s_2056_0
        fn_state.gs_408444 = s_2056_0;
        // N s_2056_2: jump b2057
        return block_2057(state, tracer, fn_state);
    }
    fn block_2057<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2057_0: read-var gs#408444:u8
        let s_2057_0: bool = fn_state.gs_408444;
        // D s_2057_1: write-var gs#408445 <= s_2057_0
        fn_state.gs_408445 = s_2057_0;
        // N s_2057_2: jump b1967
        return block_1967(state, tracer, fn_state);
    }
    fn block_2058<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2058_0: const #3892s : i
        let s_2058_0: i128 = 3892;
        // C s_2058_1: const #14696u : u32
        let s_2058_1: u32 = 14696;
        // D s_2058_2: read-reg s_2058_1:i
        let s_2058_2: i128 = {
            let value = state.read_register::<i128>(s_2058_1 as isize);
            tracer.read_register(s_2058_1 as isize, value);
            value
        };
        // D s_2058_3: cmp-lt s_2058_2 s_2058_0
        let s_2058_3: bool = ((s_2058_2) < (s_2058_0));
        // D s_2058_4: write-var gs#408444 <= s_2058_3
        fn_state.gs_408444 = s_2058_3;
        // N s_2058_5: jump b2057
        return block_2057(state, tracer, fn_state);
    }
    fn block_2059<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2059_0: const #28s : i
        let s_2059_0: i128 = 28;
        // C s_2059_1: const #4s : i
        let s_2059_1: i128 = 4;
        // D s_2059_2: read-var u#33268:u32
        let s_2059_2: u32 = fn_state.u_33268;
        // D s_2059_3: cast zx s_2059_2 -> bv
        let s_2059_3: Bits = Bits::new(s_2059_2 as u128, 32u16);
        // D s_2059_4: bit-extract s_2059_3 s_2059_0 s_2059_1
        let s_2059_4: Bits = (Bits::new(
            ((s_2059_3) >> (s_2059_0)).value(),
            u16::try_from(s_2059_1).unwrap(),
        ));
        // D s_2059_5: cast reint s_2059_4 -> u8
        let s_2059_5: u8 = (s_2059_4.value() as u8);
        // D s_2059_6: cast zx s_2059_5 -> bv
        let s_2059_6: Bits = Bits::new(s_2059_5 as u128, 4u16);
        // C s_2059_7: const #15u : u8
        let s_2059_7: u8 = 15;
        // C s_2059_8: cast zx s_2059_7 -> bv
        let s_2059_8: Bits = Bits::new(s_2059_7 as u128, 4u16);
        // D s_2059_9: cmp-ne s_2059_6 s_2059_8
        let s_2059_9: bool = ((s_2059_6) != (s_2059_8));
        // N s_2059_10: branch s_2059_9 b2062 b2060
        if s_2059_9 {
            return block_2062(state, tracer, fn_state);
        } else {
            return block_2060(state, tracer, fn_state);
        };
    }
    fn block_2060<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2060_0: const #0u : u8
        let s_2060_0: bool = false;
        // D s_2060_1: write-var gs#408409 <= s_2060_0
        fn_state.gs_408409 = s_2060_0;
        // N s_2060_2: jump b2061
        return block_2061(state, tracer, fn_state);
    }
    fn block_2061<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2061_0: read-var gs#408409:u8
        let s_2061_0: bool = fn_state.gs_408409;
        // D s_2061_1: write-var gs#408410 <= s_2061_0
        fn_state.gs_408410 = s_2061_0;
        // N s_2061_2: jump b1940
        return block_1940(state, tracer, fn_state);
    }
    fn block_2062<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2062_0: const #3890s : i
        let s_2062_0: i128 = 3890;
        // C s_2062_1: const #14696u : u32
        let s_2062_1: u32 = 14696;
        // D s_2062_2: read-reg s_2062_1:i
        let s_2062_2: i128 = {
            let value = state.read_register::<i128>(s_2062_1 as isize);
            tracer.read_register(s_2062_1 as isize, value);
            value
        };
        // D s_2062_3: cmp-lt s_2062_2 s_2062_0
        let s_2062_3: bool = ((s_2062_2) < (s_2062_0));
        // D s_2062_4: write-var gs#408409 <= s_2062_3
        fn_state.gs_408409 = s_2062_3;
        // N s_2062_5: jump b2061
        return block_2061(state, tracer, fn_state);
    }
    fn block_2063<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2063_0: const #28s : i
        let s_2063_0: i128 = 28;
        // C s_2063_1: const #4s : i
        let s_2063_1: i128 = 4;
        // D s_2063_2: read-var u#33263:u32
        let s_2063_2: u32 = fn_state.u_33263;
        // D s_2063_3: cast zx s_2063_2 -> bv
        let s_2063_3: Bits = Bits::new(s_2063_2 as u128, 32u16);
        // D s_2063_4: bit-extract s_2063_3 s_2063_0 s_2063_1
        let s_2063_4: Bits = (Bits::new(
            ((s_2063_3) >> (s_2063_0)).value(),
            u16::try_from(s_2063_1).unwrap(),
        ));
        // D s_2063_5: cast reint s_2063_4 -> u8
        let s_2063_5: u8 = (s_2063_4.value() as u8);
        // D s_2063_6: cast zx s_2063_5 -> bv
        let s_2063_6: Bits = Bits::new(s_2063_5 as u128, 4u16);
        // C s_2063_7: const #15u : u8
        let s_2063_7: u8 = 15;
        // C s_2063_8: cast zx s_2063_7 -> bv
        let s_2063_8: Bits = Bits::new(s_2063_7 as u128, 4u16);
        // D s_2063_9: cmp-ne s_2063_6 s_2063_8
        let s_2063_9: bool = ((s_2063_6) != (s_2063_8));
        // N s_2063_10: branch s_2063_9 b2066 b2064
        if s_2063_9 {
            return block_2066(state, tracer, fn_state);
        } else {
            return block_2064(state, tracer, fn_state);
        };
    }
    fn block_2064<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2064_0: const #0u : u8
        let s_2064_0: bool = false;
        // D s_2064_1: write-var gs#408376 <= s_2064_0
        fn_state.gs_408376 = s_2064_0;
        // N s_2064_2: jump b2065
        return block_2065(state, tracer, fn_state);
    }
    fn block_2065<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2065_0: read-var gs#408376:u8
        let s_2065_0: bool = fn_state.gs_408376;
        // D s_2065_1: write-var gs#408377 <= s_2065_0
        fn_state.gs_408377 = s_2065_0;
        // N s_2065_2: jump b1919
        return block_1919(state, tracer, fn_state);
    }
    fn block_2066<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2066_0: const #3864s : i
        let s_2066_0: i128 = 3864;
        // C s_2066_1: const #14696u : u32
        let s_2066_1: u32 = 14696;
        // D s_2066_2: read-reg s_2066_1:i
        let s_2066_2: i128 = {
            let value = state.read_register::<i128>(s_2066_1 as isize);
            tracer.read_register(s_2066_1 as isize, value);
            value
        };
        // D s_2066_3: cmp-lt s_2066_2 s_2066_0
        let s_2066_3: bool = ((s_2066_2) < (s_2066_0));
        // D s_2066_4: write-var gs#408376 <= s_2066_3
        fn_state.gs_408376 = s_2066_3;
        // N s_2066_5: jump b2065
        return block_2065(state, tracer, fn_state);
    }
    fn block_2067<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2067_0: const #4s : i
        let s_2067_0: i128 = 4;
        // D s_2067_1: read-var u#33263:u32
        let s_2067_1: u32 = fn_state.u_33263;
        // D s_2067_2: cast zx s_2067_1 -> bv
        let s_2067_2: Bits = Bits::new(s_2067_1 as u128, 32u16);
        // C s_2067_3: const #1s : i64
        let s_2067_3: i64 = 1;
        // C s_2067_4: cast zx s_2067_3 -> i
        let s_2067_4: i128 = (i128::try_from(s_2067_3).unwrap());
        // C s_2067_5: const #11s : i
        let s_2067_5: i128 = 11;
        // C s_2067_6: add s_2067_5 s_2067_4
        let s_2067_6: i128 = (s_2067_5 + s_2067_4);
        // D s_2067_7: bit-extract s_2067_2 s_2067_0 s_2067_6
        let s_2067_7: Bits = (Bits::new(
            ((s_2067_2) >> (s_2067_0)).value(),
            u16::try_from(s_2067_6).unwrap(),
        ));
        // D s_2067_8: cast reint s_2067_7 -> u12
        let s_2067_8: u16 = (s_2067_7.value() as u16);
        // D s_2067_9: cast zx s_2067_8 -> bv
        let s_2067_9: Bits = Bits::new(s_2067_8 as u128, 12u16);
        // C s_2067_10: const #4041u : u12
        let s_2067_10: u16 = 4041;
        // C s_2067_11: cast zx s_2067_10 -> bv
        let s_2067_11: Bits = Bits::new(s_2067_10 as u128, 12u16);
        // D s_2067_12: cmp-eq s_2067_9 s_2067_11
        let s_2067_12: bool = ((s_2067_9) == (s_2067_11));
        // D s_2067_13: write-var gs#408372 <= s_2067_12
        fn_state.gs_408372 = s_2067_12;
        // N s_2067_14: jump b1917
        return block_1917(state, tracer, fn_state);
    }
    fn block_2068<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2068_0: const #28s : i
        let s_2068_0: i128 = 28;
        // C s_2068_1: const #4s : i
        let s_2068_1: i128 = 4;
        // D s_2068_2: read-var u#33257:u32
        let s_2068_2: u32 = fn_state.u_33257;
        // D s_2068_3: cast zx s_2068_2 -> bv
        let s_2068_3: Bits = Bits::new(s_2068_2 as u128, 32u16);
        // D s_2068_4: bit-extract s_2068_3 s_2068_0 s_2068_1
        let s_2068_4: Bits = (Bits::new(
            ((s_2068_3) >> (s_2068_0)).value(),
            u16::try_from(s_2068_1).unwrap(),
        ));
        // D s_2068_5: cast reint s_2068_4 -> u8
        let s_2068_5: u8 = (s_2068_4.value() as u8);
        // D s_2068_6: cast zx s_2068_5 -> bv
        let s_2068_6: Bits = Bits::new(s_2068_5 as u128, 4u16);
        // C s_2068_7: const #15u : u8
        let s_2068_7: u8 = 15;
        // C s_2068_8: cast zx s_2068_7 -> bv
        let s_2068_8: Bits = Bits::new(s_2068_7 as u128, 4u16);
        // D s_2068_9: cmp-ne s_2068_6 s_2068_8
        let s_2068_9: bool = ((s_2068_6) != (s_2068_8));
        // N s_2068_10: branch s_2068_9 b2071 b2069
        if s_2068_9 {
            return block_2071(state, tracer, fn_state);
        } else {
            return block_2069(state, tracer, fn_state);
        };
    }
    fn block_2069<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2069_0: const #0u : u8
        let s_2069_0: bool = false;
        // D s_2069_1: write-var gs#408350 <= s_2069_0
        fn_state.gs_408350 = s_2069_0;
        // N s_2069_2: jump b2070
        return block_2070(state, tracer, fn_state);
    }
    fn block_2070<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2070_0: read-var gs#408350:u8
        let s_2070_0: bool = fn_state.gs_408350;
        // D s_2070_1: write-var gs#408351 <= s_2070_0
        fn_state.gs_408351 = s_2070_0;
        // N s_2070_2: jump b1908
        return block_1908(state, tracer, fn_state);
    }
    fn block_2071<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2071_0: const #3862s : i
        let s_2071_0: i128 = 3862;
        // C s_2071_1: const #14696u : u32
        let s_2071_1: u32 = 14696;
        // D s_2071_2: read-reg s_2071_1:i
        let s_2071_2: i128 = {
            let value = state.read_register::<i128>(s_2071_1 as isize);
            tracer.read_register(s_2071_1 as isize, value);
            value
        };
        // D s_2071_3: cmp-lt s_2071_2 s_2071_0
        let s_2071_3: bool = ((s_2071_2) < (s_2071_0));
        // D s_2071_4: write-var gs#408350 <= s_2071_3
        fn_state.gs_408350 = s_2071_3;
        // N s_2071_5: jump b2070
        return block_2070(state, tracer, fn_state);
    }
    fn block_2072<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2072_0: const #4s : i
        let s_2072_0: i128 = 4;
        // D s_2072_1: read-var u#33257:u32
        let s_2072_1: u32 = fn_state.u_33257;
        // D s_2072_2: cast zx s_2072_1 -> bv
        let s_2072_2: Bits = Bits::new(s_2072_1 as u128, 32u16);
        // C s_2072_3: const #1s : i64
        let s_2072_3: i64 = 1;
        // C s_2072_4: cast zx s_2072_3 -> i
        let s_2072_4: i128 = (i128::try_from(s_2072_3).unwrap());
        // C s_2072_5: const #7s : i
        let s_2072_5: i128 = 7;
        // C s_2072_6: add s_2072_5 s_2072_4
        let s_2072_6: i128 = (s_2072_5 + s_2072_4);
        // D s_2072_7: bit-extract s_2072_2 s_2072_0 s_2072_6
        let s_2072_7: Bits = (Bits::new(
            ((s_2072_2) >> (s_2072_0)).value(),
            u16::try_from(s_2072_6).unwrap(),
        ));
        // D s_2072_8: cast reint s_2072_7 -> u8
        let s_2072_8: u8 = (s_2072_7.value() as u8);
        // D s_2072_9: cast zx s_2072_8 -> bv
        let s_2072_9: Bits = Bits::new(s_2072_8 as u128, 8u16);
        // C s_2072_10: const #233u : u8
        let s_2072_10: u8 = 233;
        // C s_2072_11: cast zx s_2072_10 -> bv
        let s_2072_11: Bits = Bits::new(s_2072_10 as u128, 8u16);
        // D s_2072_12: cmp-eq s_2072_9 s_2072_11
        let s_2072_12: bool = ((s_2072_9) == (s_2072_11));
        // D s_2072_13: write-var gs#408346 <= s_2072_12
        fn_state.gs_408346 = s_2072_12;
        // N s_2072_14: jump b1906
        return block_1906(state, tracer, fn_state);
    }
    fn block_2073<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2073_0: const #28s : i
        let s_2073_0: i128 = 28;
        // C s_2073_1: const #4s : i
        let s_2073_1: i128 = 4;
        // D s_2073_2: read-var u#33251:u32
        let s_2073_2: u32 = fn_state.u_33251;
        // D s_2073_3: cast zx s_2073_2 -> bv
        let s_2073_3: Bits = Bits::new(s_2073_2 as u128, 32u16);
        // D s_2073_4: bit-extract s_2073_3 s_2073_0 s_2073_1
        let s_2073_4: Bits = (Bits::new(
            ((s_2073_3) >> (s_2073_0)).value(),
            u16::try_from(s_2073_1).unwrap(),
        ));
        // D s_2073_5: cast reint s_2073_4 -> u8
        let s_2073_5: u8 = (s_2073_4.value() as u8);
        // D s_2073_6: cast zx s_2073_5 -> bv
        let s_2073_6: Bits = Bits::new(s_2073_5 as u128, 4u16);
        // C s_2073_7: const #15u : u8
        let s_2073_7: u8 = 15;
        // C s_2073_8: cast zx s_2073_7 -> bv
        let s_2073_8: Bits = Bits::new(s_2073_7 as u128, 4u16);
        // D s_2073_9: cmp-ne s_2073_6 s_2073_8
        let s_2073_9: bool = ((s_2073_6) != (s_2073_8));
        // N s_2073_10: branch s_2073_9 b2076 b2074
        if s_2073_9 {
            return block_2076(state, tracer, fn_state);
        } else {
            return block_2074(state, tracer, fn_state);
        };
    }
    fn block_2074<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2074_0: const #0u : u8
        let s_2074_0: bool = false;
        // D s_2074_1: write-var gs#408324 <= s_2074_0
        fn_state.gs_408324 = s_2074_0;
        // N s_2074_2: jump b2075
        return block_2075(state, tracer, fn_state);
    }
    fn block_2075<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2075_0: read-var gs#408324:u8
        let s_2075_0: bool = fn_state.gs_408324;
        // D s_2075_1: write-var gs#408325 <= s_2075_0
        fn_state.gs_408325 = s_2075_0;
        // N s_2075_2: jump b1897
        return block_1897(state, tracer, fn_state);
    }
    fn block_2076<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2076_0: const #3860s : i
        let s_2076_0: i128 = 3860;
        // C s_2076_1: const #14696u : u32
        let s_2076_1: u32 = 14696;
        // D s_2076_2: read-reg s_2076_1:i
        let s_2076_2: i128 = {
            let value = state.read_register::<i128>(s_2076_1 as isize);
            tracer.read_register(s_2076_1 as isize, value);
            value
        };
        // D s_2076_3: cmp-lt s_2076_2 s_2076_0
        let s_2076_3: bool = ((s_2076_2) < (s_2076_0));
        // D s_2076_4: write-var gs#408324 <= s_2076_3
        fn_state.gs_408324 = s_2076_3;
        // N s_2076_5: jump b2075
        return block_2075(state, tracer, fn_state);
    }
    fn block_2077<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2077_0: const #4s : i
        let s_2077_0: i128 = 4;
        // D s_2077_1: read-var u#33251:u32
        let s_2077_1: u32 = fn_state.u_33251;
        // D s_2077_2: cast zx s_2077_1 -> bv
        let s_2077_2: Bits = Bits::new(s_2077_1 as u128, 32u16);
        // C s_2077_3: const #1s : i64
        let s_2077_3: i64 = 1;
        // C s_2077_4: cast zx s_2077_3 -> i
        let s_2077_4: i128 = (i128::try_from(s_2077_3).unwrap());
        // C s_2077_5: const #7s : i
        let s_2077_5: i128 = 7;
        // C s_2077_6: add s_2077_5 s_2077_4
        let s_2077_6: i128 = (s_2077_5 + s_2077_4);
        // D s_2077_7: bit-extract s_2077_2 s_2077_0 s_2077_6
        let s_2077_7: Bits = (Bits::new(
            ((s_2077_2) >> (s_2077_0)).value(),
            u16::try_from(s_2077_6).unwrap(),
        ));
        // D s_2077_8: cast reint s_2077_7 -> u8
        let s_2077_8: u8 = (s_2077_7.value() as u8);
        // D s_2077_9: cast zx s_2077_8 -> bv
        let s_2077_9: Bits = Bits::new(s_2077_8 as u128, 8u16);
        // C s_2077_10: const #233u : u8
        let s_2077_10: u8 = 233;
        // C s_2077_11: cast zx s_2077_10 -> bv
        let s_2077_11: Bits = Bits::new(s_2077_10 as u128, 8u16);
        // D s_2077_12: cmp-eq s_2077_9 s_2077_11
        let s_2077_12: bool = ((s_2077_9) == (s_2077_11));
        // D s_2077_13: write-var gs#408320 <= s_2077_12
        fn_state.gs_408320 = s_2077_12;
        // N s_2077_14: jump b1895
        return block_1895(state, tracer, fn_state);
    }
    fn block_2078<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2078_0: const #28s : i
        let s_2078_0: i128 = 28;
        // C s_2078_1: const #4s : i
        let s_2078_1: i128 = 4;
        // D s_2078_2: read-var u#33245:u32
        let s_2078_2: u32 = fn_state.u_33245;
        // D s_2078_3: cast zx s_2078_2 -> bv
        let s_2078_3: Bits = Bits::new(s_2078_2 as u128, 32u16);
        // D s_2078_4: bit-extract s_2078_3 s_2078_0 s_2078_1
        let s_2078_4: Bits = (Bits::new(
            ((s_2078_3) >> (s_2078_0)).value(),
            u16::try_from(s_2078_1).unwrap(),
        ));
        // D s_2078_5: cast reint s_2078_4 -> u8
        let s_2078_5: u8 = (s_2078_4.value() as u8);
        // D s_2078_6: cast zx s_2078_5 -> bv
        let s_2078_6: Bits = Bits::new(s_2078_5 as u128, 4u16);
        // C s_2078_7: const #15u : u8
        let s_2078_7: u8 = 15;
        // C s_2078_8: cast zx s_2078_7 -> bv
        let s_2078_8: Bits = Bits::new(s_2078_7 as u128, 4u16);
        // D s_2078_9: cmp-ne s_2078_6 s_2078_8
        let s_2078_9: bool = ((s_2078_6) != (s_2078_8));
        // N s_2078_10: branch s_2078_9 b2081 b2079
        if s_2078_9 {
            return block_2081(state, tracer, fn_state);
        } else {
            return block_2079(state, tracer, fn_state);
        };
    }
    fn block_2079<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2079_0: const #0u : u8
        let s_2079_0: bool = false;
        // D s_2079_1: write-var gs#408298 <= s_2079_0
        fn_state.gs_408298 = s_2079_0;
        // N s_2079_2: jump b2080
        return block_2080(state, tracer, fn_state);
    }
    fn block_2080<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2080_0: read-var gs#408298:u8
        let s_2080_0: bool = fn_state.gs_408298;
        // D s_2080_1: write-var gs#408299 <= s_2080_0
        fn_state.gs_408299 = s_2080_0;
        // N s_2080_2: jump b1886
        return block_1886(state, tracer, fn_state);
    }
    fn block_2081<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2081_0: const #3858s : i
        let s_2081_0: i128 = 3858;
        // C s_2081_1: const #14696u : u32
        let s_2081_1: u32 = 14696;
        // D s_2081_2: read-reg s_2081_1:i
        let s_2081_2: i128 = {
            let value = state.read_register::<i128>(s_2081_1 as isize);
            tracer.read_register(s_2081_1 as isize, value);
            value
        };
        // D s_2081_3: cmp-lt s_2081_2 s_2081_0
        let s_2081_3: bool = ((s_2081_2) < (s_2081_0));
        // D s_2081_4: write-var gs#408298 <= s_2081_3
        fn_state.gs_408298 = s_2081_3;
        // N s_2081_5: jump b2080
        return block_2080(state, tracer, fn_state);
    }
    fn block_2082<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2082_0: const #4s : i
        let s_2082_0: i128 = 4;
        // D s_2082_1: read-var u#33245:u32
        let s_2082_1: u32 = fn_state.u_33245;
        // D s_2082_2: cast zx s_2082_1 -> bv
        let s_2082_2: Bits = Bits::new(s_2082_1 as u128, 32u16);
        // C s_2082_3: const #1s : i64
        let s_2082_3: i64 = 1;
        // C s_2082_4: cast zx s_2082_3 -> i
        let s_2082_4: i128 = (i128::try_from(s_2082_3).unwrap());
        // C s_2082_5: const #7s : i
        let s_2082_5: i128 = 7;
        // C s_2082_6: add s_2082_5 s_2082_4
        let s_2082_6: i128 = (s_2082_5 + s_2082_4);
        // D s_2082_7: bit-extract s_2082_2 s_2082_0 s_2082_6
        let s_2082_7: Bits = (Bits::new(
            ((s_2082_2) >> (s_2082_0)).value(),
            u16::try_from(s_2082_6).unwrap(),
        ));
        // D s_2082_8: cast reint s_2082_7 -> u8
        let s_2082_8: u8 = (s_2082_7.value() as u8);
        // D s_2082_9: cast zx s_2082_8 -> bv
        let s_2082_9: Bits = Bits::new(s_2082_8 as u128, 8u16);
        // C s_2082_10: const #233u : u8
        let s_2082_10: u8 = 233;
        // C s_2082_11: cast zx s_2082_10 -> bv
        let s_2082_11: Bits = Bits::new(s_2082_10 as u128, 8u16);
        // D s_2082_12: cmp-eq s_2082_9 s_2082_11
        let s_2082_12: bool = ((s_2082_9) == (s_2082_11));
        // D s_2082_13: write-var gs#408294 <= s_2082_12
        fn_state.gs_408294 = s_2082_12;
        // N s_2082_14: jump b1884
        return block_1884(state, tracer, fn_state);
    }
    fn block_2083<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2083_0: const #28s : i
        let s_2083_0: i128 = 28;
        // C s_2083_1: const #4s : i
        let s_2083_1: i128 = 4;
        // D s_2083_2: read-var u#33239:u32
        let s_2083_2: u32 = fn_state.u_33239;
        // D s_2083_3: cast zx s_2083_2 -> bv
        let s_2083_3: Bits = Bits::new(s_2083_2 as u128, 32u16);
        // D s_2083_4: bit-extract s_2083_3 s_2083_0 s_2083_1
        let s_2083_4: Bits = (Bits::new(
            ((s_2083_3) >> (s_2083_0)).value(),
            u16::try_from(s_2083_1).unwrap(),
        ));
        // D s_2083_5: cast reint s_2083_4 -> u8
        let s_2083_5: u8 = (s_2083_4.value() as u8);
        // D s_2083_6: cast zx s_2083_5 -> bv
        let s_2083_6: Bits = Bits::new(s_2083_5 as u128, 4u16);
        // C s_2083_7: const #15u : u8
        let s_2083_7: u8 = 15;
        // C s_2083_8: cast zx s_2083_7 -> bv
        let s_2083_8: Bits = Bits::new(s_2083_7 as u128, 4u16);
        // D s_2083_9: cmp-ne s_2083_6 s_2083_8
        let s_2083_9: bool = ((s_2083_6) != (s_2083_8));
        // N s_2083_10: branch s_2083_9 b2086 b2084
        if s_2083_9 {
            return block_2086(state, tracer, fn_state);
        } else {
            return block_2084(state, tracer, fn_state);
        };
    }
    fn block_2084<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2084_0: const #0u : u8
        let s_2084_0: bool = false;
        // D s_2084_1: write-var gs#408272 <= s_2084_0
        fn_state.gs_408272 = s_2084_0;
        // N s_2084_2: jump b2085
        return block_2085(state, tracer, fn_state);
    }
    fn block_2085<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2085_0: read-var gs#408272:u8
        let s_2085_0: bool = fn_state.gs_408272;
        // D s_2085_1: write-var gs#408273 <= s_2085_0
        fn_state.gs_408273 = s_2085_0;
        // N s_2085_2: jump b1875
        return block_1875(state, tracer, fn_state);
    }
    fn block_2086<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2086_0: const #3856s : i
        let s_2086_0: i128 = 3856;
        // C s_2086_1: const #14696u : u32
        let s_2086_1: u32 = 14696;
        // D s_2086_2: read-reg s_2086_1:i
        let s_2086_2: i128 = {
            let value = state.read_register::<i128>(s_2086_1 as isize);
            tracer.read_register(s_2086_1 as isize, value);
            value
        };
        // D s_2086_3: cmp-lt s_2086_2 s_2086_0
        let s_2086_3: bool = ((s_2086_2) < (s_2086_0));
        // D s_2086_4: write-var gs#408272 <= s_2086_3
        fn_state.gs_408272 = s_2086_3;
        // N s_2086_5: jump b2085
        return block_2085(state, tracer, fn_state);
    }
    fn block_2087<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2087_0: const #4s : i
        let s_2087_0: i128 = 4;
        // D s_2087_1: read-var u#33239:u32
        let s_2087_1: u32 = fn_state.u_33239;
        // D s_2087_2: cast zx s_2087_1 -> bv
        let s_2087_2: Bits = Bits::new(s_2087_1 as u128, 32u16);
        // C s_2087_3: const #1s : i64
        let s_2087_3: i64 = 1;
        // C s_2087_4: cast zx s_2087_3 -> i
        let s_2087_4: i128 = (i128::try_from(s_2087_3).unwrap());
        // C s_2087_5: const #7s : i
        let s_2087_5: i128 = 7;
        // C s_2087_6: add s_2087_5 s_2087_4
        let s_2087_6: i128 = (s_2087_5 + s_2087_4);
        // D s_2087_7: bit-extract s_2087_2 s_2087_0 s_2087_6
        let s_2087_7: Bits = (Bits::new(
            ((s_2087_2) >> (s_2087_0)).value(),
            u16::try_from(s_2087_6).unwrap(),
        ));
        // D s_2087_8: cast reint s_2087_7 -> u8
        let s_2087_8: u8 = (s_2087_7.value() as u8);
        // D s_2087_9: cast zx s_2087_8 -> bv
        let s_2087_9: Bits = Bits::new(s_2087_8 as u128, 8u16);
        // C s_2087_10: const #233u : u8
        let s_2087_10: u8 = 233;
        // C s_2087_11: cast zx s_2087_10 -> bv
        let s_2087_11: Bits = Bits::new(s_2087_10 as u128, 8u16);
        // D s_2087_12: cmp-eq s_2087_9 s_2087_11
        let s_2087_12: bool = ((s_2087_9) == (s_2087_11));
        // D s_2087_13: write-var gs#408268 <= s_2087_12
        fn_state.gs_408268 = s_2087_12;
        // N s_2087_14: jump b1873
        return block_1873(state, tracer, fn_state);
    }
    fn block_2088<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2088_0: const #28s : i
        let s_2088_0: i128 = 28;
        // C s_2088_1: const #4s : i
        let s_2088_1: i128 = 4;
        // D s_2088_2: read-var u#33234:u32
        let s_2088_2: u32 = fn_state.u_33234;
        // D s_2088_3: cast zx s_2088_2 -> bv
        let s_2088_3: Bits = Bits::new(s_2088_2 as u128, 32u16);
        // D s_2088_4: bit-extract s_2088_3 s_2088_0 s_2088_1
        let s_2088_4: Bits = (Bits::new(
            ((s_2088_3) >> (s_2088_0)).value(),
            u16::try_from(s_2088_1).unwrap(),
        ));
        // D s_2088_5: cast reint s_2088_4 -> u8
        let s_2088_5: u8 = (s_2088_4.value() as u8);
        // D s_2088_6: cast zx s_2088_5 -> bv
        let s_2088_6: Bits = Bits::new(s_2088_5 as u128, 4u16);
        // C s_2088_7: const #15u : u8
        let s_2088_7: u8 = 15;
        // C s_2088_8: cast zx s_2088_7 -> bv
        let s_2088_8: Bits = Bits::new(s_2088_7 as u128, 4u16);
        // D s_2088_9: cmp-ne s_2088_6 s_2088_8
        let s_2088_9: bool = ((s_2088_6) != (s_2088_8));
        // N s_2088_10: branch s_2088_9 b2091 b2089
        if s_2088_9 {
            return block_2091(state, tracer, fn_state);
        } else {
            return block_2089(state, tracer, fn_state);
        };
    }
    fn block_2089<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2089_0: const #0u : u8
        let s_2089_0: bool = false;
        // D s_2089_1: write-var gs#408236 <= s_2089_0
        fn_state.gs_408236 = s_2089_0;
        // N s_2089_2: jump b2090
        return block_2090(state, tracer, fn_state);
    }
    fn block_2090<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2090_0: read-var gs#408236:u8
        let s_2090_0: bool = fn_state.gs_408236;
        // D s_2090_1: write-var gs#408237 <= s_2090_0
        fn_state.gs_408237 = s_2090_0;
        // N s_2090_2: jump b1852
        return block_1852(state, tracer, fn_state);
    }
    fn block_2091<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2091_0: const #3854s : i
        let s_2091_0: i128 = 3854;
        // C s_2091_1: const #14696u : u32
        let s_2091_1: u32 = 14696;
        // D s_2091_2: read-reg s_2091_1:i
        let s_2091_2: i128 = {
            let value = state.read_register::<i128>(s_2091_1 as isize);
            tracer.read_register(s_2091_1 as isize, value);
            value
        };
        // D s_2091_3: cmp-lt s_2091_2 s_2091_0
        let s_2091_3: bool = ((s_2091_2) < (s_2091_0));
        // D s_2091_4: write-var gs#408236 <= s_2091_3
        fn_state.gs_408236 = s_2091_3;
        // N s_2091_5: jump b2090
        return block_2090(state, tracer, fn_state);
    }
    fn block_2092<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2092_0: const #4s : i
        let s_2092_0: i128 = 4;
        // D s_2092_1: read-var u#33234:u32
        let s_2092_1: u32 = fn_state.u_33234;
        // D s_2092_2: cast zx s_2092_1 -> bv
        let s_2092_2: Bits = Bits::new(s_2092_1 as u128, 32u16);
        // C s_2092_3: const #1s : i64
        let s_2092_3: i64 = 1;
        // C s_2092_4: cast zx s_2092_3 -> i
        let s_2092_4: i128 = (i128::try_from(s_2092_3).unwrap());
        // C s_2092_5: const #11s : i
        let s_2092_5: i128 = 11;
        // C s_2092_6: add s_2092_5 s_2092_4
        let s_2092_6: i128 = (s_2092_5 + s_2092_4);
        // D s_2092_7: bit-extract s_2092_2 s_2092_0 s_2092_6
        let s_2092_7: Bits = (Bits::new(
            ((s_2092_2) >> (s_2092_0)).value(),
            u16::try_from(s_2092_6).unwrap(),
        ));
        // D s_2092_8: cast reint s_2092_7 -> u12
        let s_2092_8: u16 = (s_2092_7.value() as u16);
        // D s_2092_9: cast zx s_2092_8 -> bv
        let s_2092_9: Bits = Bits::new(s_2092_8 as u128, 12u16);
        // C s_2092_10: const #4041u : u12
        let s_2092_10: u16 = 4041;
        // C s_2092_11: cast zx s_2092_10 -> bv
        let s_2092_11: Bits = Bits::new(s_2092_10 as u128, 12u16);
        // D s_2092_12: cmp-eq s_2092_9 s_2092_11
        let s_2092_12: bool = ((s_2092_9) == (s_2092_11));
        // D s_2092_13: write-var gs#408232 <= s_2092_12
        fn_state.gs_408232 = s_2092_12;
        // N s_2092_14: jump b1850
        return block_1850(state, tracer, fn_state);
    }
    fn block_2093<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2093_0: const #28s : i
        let s_2093_0: i128 = 28;
        // C s_2093_1: const #4s : i
        let s_2093_1: i128 = 4;
        // D s_2093_2: read-var u#33229:u32
        let s_2093_2: u32 = fn_state.u_33229;
        // D s_2093_3: cast zx s_2093_2 -> bv
        let s_2093_3: Bits = Bits::new(s_2093_2 as u128, 32u16);
        // D s_2093_4: bit-extract s_2093_3 s_2093_0 s_2093_1
        let s_2093_4: Bits = (Bits::new(
            ((s_2093_3) >> (s_2093_0)).value(),
            u16::try_from(s_2093_1).unwrap(),
        ));
        // D s_2093_5: cast reint s_2093_4 -> u8
        let s_2093_5: u8 = (s_2093_4.value() as u8);
        // D s_2093_6: cast zx s_2093_5 -> bv
        let s_2093_6: Bits = Bits::new(s_2093_5 as u128, 4u16);
        // C s_2093_7: const #15u : u8
        let s_2093_7: u8 = 15;
        // C s_2093_8: cast zx s_2093_7 -> bv
        let s_2093_8: Bits = Bits::new(s_2093_7 as u128, 4u16);
        // D s_2093_9: cmp-ne s_2093_6 s_2093_8
        let s_2093_9: bool = ((s_2093_6) != (s_2093_8));
        // N s_2093_10: branch s_2093_9 b2096 b2094
        if s_2093_9 {
            return block_2096(state, tracer, fn_state);
        } else {
            return block_2094(state, tracer, fn_state);
        };
    }
    fn block_2094<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2094_0: const #0u : u8
        let s_2094_0: bool = false;
        // D s_2094_1: write-var gs#408200 <= s_2094_0
        fn_state.gs_408200 = s_2094_0;
        // N s_2094_2: jump b2095
        return block_2095(state, tracer, fn_state);
    }
    fn block_2095<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2095_0: read-var gs#408200:u8
        let s_2095_0: bool = fn_state.gs_408200;
        // D s_2095_1: write-var gs#408201 <= s_2095_0
        fn_state.gs_408201 = s_2095_0;
        // N s_2095_2: jump b1829
        return block_1829(state, tracer, fn_state);
    }
    fn block_2096<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2096_0: const #3852s : i
        let s_2096_0: i128 = 3852;
        // C s_2096_1: const #14696u : u32
        let s_2096_1: u32 = 14696;
        // D s_2096_2: read-reg s_2096_1:i
        let s_2096_2: i128 = {
            let value = state.read_register::<i128>(s_2096_1 as isize);
            tracer.read_register(s_2096_1 as isize, value);
            value
        };
        // D s_2096_3: cmp-lt s_2096_2 s_2096_0
        let s_2096_3: bool = ((s_2096_2) < (s_2096_0));
        // D s_2096_4: write-var gs#408200 <= s_2096_3
        fn_state.gs_408200 = s_2096_3;
        // N s_2096_5: jump b2095
        return block_2095(state, tracer, fn_state);
    }
    fn block_2097<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2097_0: const #4s : i
        let s_2097_0: i128 = 4;
        // D s_2097_1: read-var u#33229:u32
        let s_2097_1: u32 = fn_state.u_33229;
        // D s_2097_2: cast zx s_2097_1 -> bv
        let s_2097_2: Bits = Bits::new(s_2097_1 as u128, 32u16);
        // C s_2097_3: const #1s : i64
        let s_2097_3: i64 = 1;
        // C s_2097_4: cast zx s_2097_3 -> i
        let s_2097_4: i128 = (i128::try_from(s_2097_3).unwrap());
        // C s_2097_5: const #11s : i
        let s_2097_5: i128 = 11;
        // C s_2097_6: add s_2097_5 s_2097_4
        let s_2097_6: i128 = (s_2097_5 + s_2097_4);
        // D s_2097_7: bit-extract s_2097_2 s_2097_0 s_2097_6
        let s_2097_7: Bits = (Bits::new(
            ((s_2097_2) >> (s_2097_0)).value(),
            u16::try_from(s_2097_6).unwrap(),
        ));
        // D s_2097_8: cast reint s_2097_7 -> u12
        let s_2097_8: u16 = (s_2097_7.value() as u16);
        // D s_2097_9: cast zx s_2097_8 -> bv
        let s_2097_9: Bits = Bits::new(s_2097_8 as u128, 12u16);
        // C s_2097_10: const #4041u : u12
        let s_2097_10: u16 = 4041;
        // C s_2097_11: cast zx s_2097_10 -> bv
        let s_2097_11: Bits = Bits::new(s_2097_10 as u128, 12u16);
        // D s_2097_12: cmp-eq s_2097_9 s_2097_11
        let s_2097_12: bool = ((s_2097_9) == (s_2097_11));
        // D s_2097_13: write-var gs#408196 <= s_2097_12
        fn_state.gs_408196 = s_2097_12;
        // N s_2097_14: jump b1827
        return block_1827(state, tracer, fn_state);
    }
    fn block_2098<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2098_0: const #28s : i
        let s_2098_0: i128 = 28;
        // C s_2098_1: const #4s : i
        let s_2098_1: i128 = 4;
        // D s_2098_2: read-var u#33226:u32
        let s_2098_2: u32 = fn_state.u_33226;
        // D s_2098_3: cast zx s_2098_2 -> bv
        let s_2098_3: Bits = Bits::new(s_2098_2 as u128, 32u16);
        // D s_2098_4: bit-extract s_2098_3 s_2098_0 s_2098_1
        let s_2098_4: Bits = (Bits::new(
            ((s_2098_3) >> (s_2098_0)).value(),
            u16::try_from(s_2098_1).unwrap(),
        ));
        // D s_2098_5: cast reint s_2098_4 -> u8
        let s_2098_5: u8 = (s_2098_4.value() as u8);
        // D s_2098_6: cast zx s_2098_5 -> bv
        let s_2098_6: Bits = Bits::new(s_2098_5 as u128, 4u16);
        // C s_2098_7: const #15u : u8
        let s_2098_7: u8 = 15;
        // C s_2098_8: cast zx s_2098_7 -> bv
        let s_2098_8: Bits = Bits::new(s_2098_7 as u128, 4u16);
        // D s_2098_9: cmp-ne s_2098_6 s_2098_8
        let s_2098_9: bool = ((s_2098_6) != (s_2098_8));
        // N s_2098_10: branch s_2098_9 b2101 b2099
        if s_2098_9 {
            return block_2101(state, tracer, fn_state);
        } else {
            return block_2099(state, tracer, fn_state);
        };
    }
    fn block_2099<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2099_0: const #0u : u8
        let s_2099_0: bool = false;
        // D s_2099_1: write-var gs#408162 <= s_2099_0
        fn_state.gs_408162 = s_2099_0;
        // N s_2099_2: jump b2100
        return block_2100(state, tracer, fn_state);
    }
    fn block_2100<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2100_0: read-var gs#408162:u8
        let s_2100_0: bool = fn_state.gs_408162;
        // D s_2100_1: write-var gs#408163 <= s_2100_0
        fn_state.gs_408163 = s_2100_0;
        // N s_2100_2: jump b1800
        return block_1800(state, tracer, fn_state);
    }
    fn block_2101<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2101_0: const #3829s : i
        let s_2101_0: i128 = 3829;
        // C s_2101_1: const #14696u : u32
        let s_2101_1: u32 = 14696;
        // D s_2101_2: read-reg s_2101_1:i
        let s_2101_2: i128 = {
            let value = state.read_register::<i128>(s_2101_1 as isize);
            tracer.read_register(s_2101_1 as isize, value);
            value
        };
        // D s_2101_3: cmp-lt s_2101_2 s_2101_0
        let s_2101_3: bool = ((s_2101_2) < (s_2101_0));
        // D s_2101_4: write-var gs#408162 <= s_2101_3
        fn_state.gs_408162 = s_2101_3;
        // N s_2101_5: jump b2100
        return block_2100(state, tracer, fn_state);
    }
    fn block_2102<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2102_0: const #28s : i
        let s_2102_0: i128 = 28;
        // C s_2102_1: const #4s : i
        let s_2102_1: i128 = 4;
        // D s_2102_2: read-var u#33221:u32
        let s_2102_2: u32 = fn_state.u_33221;
        // D s_2102_3: cast zx s_2102_2 -> bv
        let s_2102_3: Bits = Bits::new(s_2102_2 as u128, 32u16);
        // D s_2102_4: bit-extract s_2102_3 s_2102_0 s_2102_1
        let s_2102_4: Bits = (Bits::new(
            ((s_2102_3) >> (s_2102_0)).value(),
            u16::try_from(s_2102_1).unwrap(),
        ));
        // D s_2102_5: cast reint s_2102_4 -> u8
        let s_2102_5: u8 = (s_2102_4.value() as u8);
        // D s_2102_6: cast zx s_2102_5 -> bv
        let s_2102_6: Bits = Bits::new(s_2102_5 as u128, 4u16);
        // C s_2102_7: const #15u : u8
        let s_2102_7: u8 = 15;
        // C s_2102_8: cast zx s_2102_7 -> bv
        let s_2102_8: Bits = Bits::new(s_2102_7 as u128, 4u16);
        // D s_2102_9: cmp-ne s_2102_6 s_2102_8
        let s_2102_9: bool = ((s_2102_6) != (s_2102_8));
        // N s_2102_10: branch s_2102_9 b2105 b2103
        if s_2102_9 {
            return block_2105(state, tracer, fn_state);
        } else {
            return block_2103(state, tracer, fn_state);
        };
    }
    fn block_2103<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2103_0: const #0u : u8
        let s_2103_0: bool = false;
        // D s_2103_1: write-var gs#408129 <= s_2103_0
        fn_state.gs_408129 = s_2103_0;
        // N s_2103_2: jump b2104
        return block_2104(state, tracer, fn_state);
    }
    fn block_2104<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2104_0: read-var gs#408129:u8
        let s_2104_0: bool = fn_state.gs_408129;
        // D s_2104_1: write-var gs#408130 <= s_2104_0
        fn_state.gs_408130 = s_2104_0;
        // N s_2104_2: jump b1779
        return block_1779(state, tracer, fn_state);
    }
    fn block_2105<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2105_0: const #3827s : i
        let s_2105_0: i128 = 3827;
        // C s_2105_1: const #14696u : u32
        let s_2105_1: u32 = 14696;
        // D s_2105_2: read-reg s_2105_1:i
        let s_2105_2: i128 = {
            let value = state.read_register::<i128>(s_2105_1 as isize);
            tracer.read_register(s_2105_1 as isize, value);
            value
        };
        // D s_2105_3: cmp-lt s_2105_2 s_2105_0
        let s_2105_3: bool = ((s_2105_2) < (s_2105_0));
        // D s_2105_4: write-var gs#408129 <= s_2105_3
        fn_state.gs_408129 = s_2105_3;
        // N s_2105_5: jump b2104
        return block_2104(state, tracer, fn_state);
    }
    fn block_2106<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2106_0: const #0s : i
        let s_2106_0: i128 = 0;
        // D s_2106_1: read-var u#33221:u32
        let s_2106_1: u32 = fn_state.u_33221;
        // D s_2106_2: cast zx s_2106_1 -> bv
        let s_2106_2: Bits = Bits::new(s_2106_1 as u128, 32u16);
        // C s_2106_3: const #1s : i64
        let s_2106_3: i64 = 1;
        // C s_2106_4: cast zx s_2106_3 -> i
        let s_2106_4: i128 = (i128::try_from(s_2106_3).unwrap());
        // C s_2106_5: const #11s : i
        let s_2106_5: i128 = 11;
        // C s_2106_6: add s_2106_5 s_2106_4
        let s_2106_6: i128 = (s_2106_5 + s_2106_4);
        // D s_2106_7: bit-extract s_2106_2 s_2106_0 s_2106_6
        let s_2106_7: Bits = (Bits::new(
            ((s_2106_2) >> (s_2106_0)).value(),
            u16::try_from(s_2106_6).unwrap(),
        ));
        // D s_2106_8: cast reint s_2106_7 -> u12
        let s_2106_8: u16 = (s_2106_7.value() as u16);
        // D s_2106_9: cast zx s_2106_8 -> bv
        let s_2106_9: Bits = Bits::new(s_2106_8 as u128, 12u16);
        // C s_2106_10: const #3231u : u12
        let s_2106_10: u16 = 3231;
        // C s_2106_11: cast zx s_2106_10 -> bv
        let s_2106_11: Bits = Bits::new(s_2106_10 as u128, 12u16);
        // D s_2106_12: cmp-eq s_2106_9 s_2106_11
        let s_2106_12: bool = ((s_2106_9) == (s_2106_11));
        // D s_2106_13: write-var gs#408125 <= s_2106_12
        fn_state.gs_408125 = s_2106_12;
        // N s_2106_14: jump b1777
        return block_1777(state, tracer, fn_state);
    }
    fn block_2107<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2107_0: const #28s : i
        let s_2107_0: i128 = 28;
        // C s_2107_1: const #4s : i
        let s_2107_1: i128 = 4;
        // D s_2107_2: read-var u#33216:u32
        let s_2107_2: u32 = fn_state.u_33216;
        // D s_2107_3: cast zx s_2107_2 -> bv
        let s_2107_3: Bits = Bits::new(s_2107_2 as u128, 32u16);
        // D s_2107_4: bit-extract s_2107_3 s_2107_0 s_2107_1
        let s_2107_4: Bits = (Bits::new(
            ((s_2107_3) >> (s_2107_0)).value(),
            u16::try_from(s_2107_1).unwrap(),
        ));
        // D s_2107_5: cast reint s_2107_4 -> u8
        let s_2107_5: u8 = (s_2107_4.value() as u8);
        // D s_2107_6: cast zx s_2107_5 -> bv
        let s_2107_6: Bits = Bits::new(s_2107_5 as u128, 4u16);
        // C s_2107_7: const #15u : u8
        let s_2107_7: u8 = 15;
        // C s_2107_8: cast zx s_2107_7 -> bv
        let s_2107_8: Bits = Bits::new(s_2107_7 as u128, 4u16);
        // D s_2107_9: cmp-ne s_2107_6 s_2107_8
        let s_2107_9: bool = ((s_2107_6) != (s_2107_8));
        // N s_2107_10: branch s_2107_9 b2110 b2108
        if s_2107_9 {
            return block_2110(state, tracer, fn_state);
        } else {
            return block_2108(state, tracer, fn_state);
        };
    }
    fn block_2108<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2108_0: const #0u : u8
        let s_2108_0: bool = false;
        // D s_2108_1: write-var gs#408093 <= s_2108_0
        fn_state.gs_408093 = s_2108_0;
        // N s_2108_2: jump b2109
        return block_2109(state, tracer, fn_state);
    }
    fn block_2109<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2109_0: read-var gs#408093:u8
        let s_2109_0: bool = fn_state.gs_408093;
        // D s_2109_1: write-var gs#408094 <= s_2109_0
        fn_state.gs_408094 = s_2109_0;
        // N s_2109_2: jump b1756
        return block_1756(state, tracer, fn_state);
    }
    fn block_2110<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2110_0: const #3825s : i
        let s_2110_0: i128 = 3825;
        // C s_2110_1: const #14696u : u32
        let s_2110_1: u32 = 14696;
        // D s_2110_2: read-reg s_2110_1:i
        let s_2110_2: i128 = {
            let value = state.read_register::<i128>(s_2110_1 as isize);
            tracer.read_register(s_2110_1 as isize, value);
            value
        };
        // D s_2110_3: cmp-lt s_2110_2 s_2110_0
        let s_2110_3: bool = ((s_2110_2) < (s_2110_0));
        // D s_2110_4: write-var gs#408093 <= s_2110_3
        fn_state.gs_408093 = s_2110_3;
        // N s_2110_5: jump b2109
        return block_2109(state, tracer, fn_state);
    }
    fn block_2111<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2111_0: const #0s : i
        let s_2111_0: i128 = 0;
        // D s_2111_1: read-var u#33216:u32
        let s_2111_1: u32 = fn_state.u_33216;
        // D s_2111_2: cast zx s_2111_1 -> bv
        let s_2111_2: Bits = Bits::new(s_2111_1 as u128, 32u16);
        // C s_2111_3: const #1s : i64
        let s_2111_3: i64 = 1;
        // C s_2111_4: cast zx s_2111_3 -> i
        let s_2111_4: i128 = (i128::try_from(s_2111_3).unwrap());
        // C s_2111_5: const #11s : i
        let s_2111_5: i128 = 11;
        // C s_2111_6: add s_2111_5 s_2111_4
        let s_2111_6: i128 = (s_2111_5 + s_2111_4);
        // D s_2111_7: bit-extract s_2111_2 s_2111_0 s_2111_6
        let s_2111_7: Bits = (Bits::new(
            ((s_2111_2) >> (s_2111_0)).value(),
            u16::try_from(s_2111_6).unwrap(),
        ));
        // D s_2111_8: cast reint s_2111_7 -> u12
        let s_2111_8: u16 = (s_2111_7.value() as u16);
        // D s_2111_9: cast zx s_2111_8 -> bv
        let s_2111_9: Bits = Bits::new(s_2111_8 as u128, 12u16);
        // C s_2111_10: const #3743u : u12
        let s_2111_10: u16 = 3743;
        // C s_2111_11: cast zx s_2111_10 -> bv
        let s_2111_11: Bits = Bits::new(s_2111_10 as u128, 12u16);
        // D s_2111_12: cmp-eq s_2111_9 s_2111_11
        let s_2111_12: bool = ((s_2111_9) == (s_2111_11));
        // D s_2111_13: write-var gs#408089 <= s_2111_12
        fn_state.gs_408089 = s_2111_12;
        // N s_2111_14: jump b1754
        return block_1754(state, tracer, fn_state);
    }
    fn block_2112<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2112_0: const #28s : i
        let s_2112_0: i128 = 28;
        // C s_2112_1: const #4s : i
        let s_2112_1: i128 = 4;
        // D s_2112_2: read-var u#33211:u32
        let s_2112_2: u32 = fn_state.u_33211;
        // D s_2112_3: cast zx s_2112_2 -> bv
        let s_2112_3: Bits = Bits::new(s_2112_2 as u128, 32u16);
        // D s_2112_4: bit-extract s_2112_3 s_2112_0 s_2112_1
        let s_2112_4: Bits = (Bits::new(
            ((s_2112_3) >> (s_2112_0)).value(),
            u16::try_from(s_2112_1).unwrap(),
        ));
        // D s_2112_5: cast reint s_2112_4 -> u8
        let s_2112_5: u8 = (s_2112_4.value() as u8);
        // D s_2112_6: cast zx s_2112_5 -> bv
        let s_2112_6: Bits = Bits::new(s_2112_5 as u128, 4u16);
        // C s_2112_7: const #15u : u8
        let s_2112_7: u8 = 15;
        // C s_2112_8: cast zx s_2112_7 -> bv
        let s_2112_8: Bits = Bits::new(s_2112_7 as u128, 4u16);
        // D s_2112_9: cmp-ne s_2112_6 s_2112_8
        let s_2112_9: bool = ((s_2112_6) != (s_2112_8));
        // N s_2112_10: branch s_2112_9 b2115 b2113
        if s_2112_9 {
            return block_2115(state, tracer, fn_state);
        } else {
            return block_2113(state, tracer, fn_state);
        };
    }
    fn block_2113<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2113_0: const #0u : u8
        let s_2113_0: bool = false;
        // D s_2113_1: write-var gs#408057 <= s_2113_0
        fn_state.gs_408057 = s_2113_0;
        // N s_2113_2: jump b2114
        return block_2114(state, tracer, fn_state);
    }
    fn block_2114<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2114_0: read-var gs#408057:u8
        let s_2114_0: bool = fn_state.gs_408057;
        // D s_2114_1: write-var gs#408058 <= s_2114_0
        fn_state.gs_408058 = s_2114_0;
        // N s_2114_2: jump b1733
        return block_1733(state, tracer, fn_state);
    }
    fn block_2115<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2115_0: const #3823s : i
        let s_2115_0: i128 = 3823;
        // C s_2115_1: const #14696u : u32
        let s_2115_1: u32 = 14696;
        // D s_2115_2: read-reg s_2115_1:i
        let s_2115_2: i128 = {
            let value = state.read_register::<i128>(s_2115_1 as isize);
            tracer.read_register(s_2115_1 as isize, value);
            value
        };
        // D s_2115_3: cmp-lt s_2115_2 s_2115_0
        let s_2115_3: bool = ((s_2115_2) < (s_2115_0));
        // D s_2115_4: write-var gs#408057 <= s_2115_3
        fn_state.gs_408057 = s_2115_3;
        // N s_2115_5: jump b2114
        return block_2114(state, tracer, fn_state);
    }
    fn block_2116<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2116_0: const #0s : i
        let s_2116_0: i128 = 0;
        // D s_2116_1: read-var u#33211:u32
        let s_2116_1: u32 = fn_state.u_33211;
        // D s_2116_2: cast zx s_2116_1 -> bv
        let s_2116_2: Bits = Bits::new(s_2116_1 as u128, 32u16);
        // C s_2116_3: const #1s : i64
        let s_2116_3: i64 = 1;
        // C s_2116_4: cast zx s_2116_3 -> i
        let s_2116_4: i128 = (i128::try_from(s_2116_3).unwrap());
        // C s_2116_5: const #11s : i
        let s_2116_5: i128 = 11;
        // C s_2116_6: add s_2116_5 s_2116_4
        let s_2116_6: i128 = (s_2116_5 + s_2116_4);
        // D s_2116_7: bit-extract s_2116_2 s_2116_0 s_2116_6
        let s_2116_7: Bits = (Bits::new(
            ((s_2116_2) >> (s_2116_0)).value(),
            u16::try_from(s_2116_6).unwrap(),
        ));
        // D s_2116_8: cast reint s_2116_7 -> u12
        let s_2116_8: u16 = (s_2116_7.value() as u16);
        // D s_2116_9: cast zx s_2116_8 -> bv
        let s_2116_9: Bits = Bits::new(s_2116_8 as u128, 12u16);
        // C s_2116_10: const #3743u : u12
        let s_2116_10: u16 = 3743;
        // C s_2116_11: cast zx s_2116_10 -> bv
        let s_2116_11: Bits = Bits::new(s_2116_10 as u128, 12u16);
        // D s_2116_12: cmp-eq s_2116_9 s_2116_11
        let s_2116_12: bool = ((s_2116_9) == (s_2116_11));
        // D s_2116_13: write-var gs#408053 <= s_2116_12
        fn_state.gs_408053 = s_2116_12;
        // N s_2116_14: jump b1731
        return block_1731(state, tracer, fn_state);
    }
    fn block_2117<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2117_0: const #28s : i
        let s_2117_0: i128 = 28;
        // C s_2117_1: const #4s : i
        let s_2117_1: i128 = 4;
        // D s_2117_2: read-var u#33206:u32
        let s_2117_2: u32 = fn_state.u_33206;
        // D s_2117_3: cast zx s_2117_2 -> bv
        let s_2117_3: Bits = Bits::new(s_2117_2 as u128, 32u16);
        // D s_2117_4: bit-extract s_2117_3 s_2117_0 s_2117_1
        let s_2117_4: Bits = (Bits::new(
            ((s_2117_3) >> (s_2117_0)).value(),
            u16::try_from(s_2117_1).unwrap(),
        ));
        // D s_2117_5: cast reint s_2117_4 -> u8
        let s_2117_5: u8 = (s_2117_4.value() as u8);
        // D s_2117_6: cast zx s_2117_5 -> bv
        let s_2117_6: Bits = Bits::new(s_2117_5 as u128, 4u16);
        // C s_2117_7: const #15u : u8
        let s_2117_7: u8 = 15;
        // C s_2117_8: cast zx s_2117_7 -> bv
        let s_2117_8: Bits = Bits::new(s_2117_7 as u128, 4u16);
        // D s_2117_9: cmp-ne s_2117_6 s_2117_8
        let s_2117_9: bool = ((s_2117_6) != (s_2117_8));
        // N s_2117_10: branch s_2117_9 b2120 b2118
        if s_2117_9 {
            return block_2120(state, tracer, fn_state);
        } else {
            return block_2118(state, tracer, fn_state);
        };
    }
    fn block_2118<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2118_0: const #0u : u8
        let s_2118_0: bool = false;
        // D s_2118_1: write-var gs#408021 <= s_2118_0
        fn_state.gs_408021 = s_2118_0;
        // N s_2118_2: jump b2119
        return block_2119(state, tracer, fn_state);
    }
    fn block_2119<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2119_0: read-var gs#408021:u8
        let s_2119_0: bool = fn_state.gs_408021;
        // D s_2119_1: write-var gs#408022 <= s_2119_0
        fn_state.gs_408022 = s_2119_0;
        // N s_2119_2: jump b1710
        return block_1710(state, tracer, fn_state);
    }
    fn block_2120<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2120_0: const #3821s : i
        let s_2120_0: i128 = 3821;
        // C s_2120_1: const #14696u : u32
        let s_2120_1: u32 = 14696;
        // D s_2120_2: read-reg s_2120_1:i
        let s_2120_2: i128 = {
            let value = state.read_register::<i128>(s_2120_1 as isize);
            tracer.read_register(s_2120_1 as isize, value);
            value
        };
        // D s_2120_3: cmp-lt s_2120_2 s_2120_0
        let s_2120_3: bool = ((s_2120_2) < (s_2120_0));
        // D s_2120_4: write-var gs#408021 <= s_2120_3
        fn_state.gs_408021 = s_2120_3;
        // N s_2120_5: jump b2119
        return block_2119(state, tracer, fn_state);
    }
    fn block_2121<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2121_0: const #0s : i
        let s_2121_0: i128 = 0;
        // D s_2121_1: read-var u#33206:u32
        let s_2121_1: u32 = fn_state.u_33206;
        // D s_2121_2: cast zx s_2121_1 -> bv
        let s_2121_2: Bits = Bits::new(s_2121_1 as u128, 32u16);
        // C s_2121_3: const #1s : i64
        let s_2121_3: i64 = 1;
        // C s_2121_4: cast zx s_2121_3 -> i
        let s_2121_4: i128 = (i128::try_from(s_2121_3).unwrap());
        // C s_2121_5: const #11s : i
        let s_2121_5: i128 = 11;
        // C s_2121_6: add s_2121_5 s_2121_4
        let s_2121_6: i128 = (s_2121_5 + s_2121_4);
        // D s_2121_7: bit-extract s_2121_2 s_2121_0 s_2121_6
        let s_2121_7: Bits = (Bits::new(
            ((s_2121_2) >> (s_2121_0)).value(),
            u16::try_from(s_2121_6).unwrap(),
        ));
        // D s_2121_8: cast reint s_2121_7 -> u12
        let s_2121_8: u16 = (s_2121_7.value() as u16);
        // D s_2121_9: cast zx s_2121_8 -> bv
        let s_2121_9: Bits = Bits::new(s_2121_8 as u128, 12u16);
        // C s_2121_10: const #3743u : u12
        let s_2121_10: u16 = 3743;
        // C s_2121_11: cast zx s_2121_10 -> bv
        let s_2121_11: Bits = Bits::new(s_2121_10 as u128, 12u16);
        // D s_2121_12: cmp-eq s_2121_9 s_2121_11
        let s_2121_12: bool = ((s_2121_9) == (s_2121_11));
        // D s_2121_13: write-var gs#408017 <= s_2121_12
        fn_state.gs_408017 = s_2121_12;
        // N s_2121_14: jump b1708
        return block_1708(state, tracer, fn_state);
    }
    fn block_2122<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2122_0: const #28s : i
        let s_2122_0: i128 = 28;
        // C s_2122_1: const #4s : i
        let s_2122_1: i128 = 4;
        // D s_2122_2: read-var u#33201:u32
        let s_2122_2: u32 = fn_state.u_33201;
        // D s_2122_3: cast zx s_2122_2 -> bv
        let s_2122_3: Bits = Bits::new(s_2122_2 as u128, 32u16);
        // D s_2122_4: bit-extract s_2122_3 s_2122_0 s_2122_1
        let s_2122_4: Bits = (Bits::new(
            ((s_2122_3) >> (s_2122_0)).value(),
            u16::try_from(s_2122_1).unwrap(),
        ));
        // D s_2122_5: cast reint s_2122_4 -> u8
        let s_2122_5: u8 = (s_2122_4.value() as u8);
        // D s_2122_6: cast zx s_2122_5 -> bv
        let s_2122_6: Bits = Bits::new(s_2122_5 as u128, 4u16);
        // C s_2122_7: const #15u : u8
        let s_2122_7: u8 = 15;
        // C s_2122_8: cast zx s_2122_7 -> bv
        let s_2122_8: Bits = Bits::new(s_2122_7 as u128, 4u16);
        // D s_2122_9: cmp-ne s_2122_6 s_2122_8
        let s_2122_9: bool = ((s_2122_6) != (s_2122_8));
        // N s_2122_10: branch s_2122_9 b2125 b2123
        if s_2122_9 {
            return block_2125(state, tracer, fn_state);
        } else {
            return block_2123(state, tracer, fn_state);
        };
    }
    fn block_2123<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2123_0: const #0u : u8
        let s_2123_0: bool = false;
        // D s_2123_1: write-var gs#407985 <= s_2123_0
        fn_state.gs_407985 = s_2123_0;
        // N s_2123_2: jump b2124
        return block_2124(state, tracer, fn_state);
    }
    fn block_2124<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2124_0: read-var gs#407985:u8
        let s_2124_0: bool = fn_state.gs_407985;
        // D s_2124_1: write-var gs#407986 <= s_2124_0
        fn_state.gs_407986 = s_2124_0;
        // N s_2124_2: jump b1687
        return block_1687(state, tracer, fn_state);
    }
    fn block_2125<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2125_0: const #3819s : i
        let s_2125_0: i128 = 3819;
        // C s_2125_1: const #14696u : u32
        let s_2125_1: u32 = 14696;
        // D s_2125_2: read-reg s_2125_1:i
        let s_2125_2: i128 = {
            let value = state.read_register::<i128>(s_2125_1 as isize);
            tracer.read_register(s_2125_1 as isize, value);
            value
        };
        // D s_2125_3: cmp-lt s_2125_2 s_2125_0
        let s_2125_3: bool = ((s_2125_2) < (s_2125_0));
        // D s_2125_4: write-var gs#407985 <= s_2125_3
        fn_state.gs_407985 = s_2125_3;
        // N s_2125_5: jump b2124
        return block_2124(state, tracer, fn_state);
    }
    fn block_2126<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2126_0: const #0s : i
        let s_2126_0: i128 = 0;
        // D s_2126_1: read-var u#33201:u32
        let s_2126_1: u32 = fn_state.u_33201;
        // D s_2126_2: cast zx s_2126_1 -> bv
        let s_2126_2: Bits = Bits::new(s_2126_1 as u128, 32u16);
        // C s_2126_3: const #1s : i64
        let s_2126_3: i64 = 1;
        // C s_2126_4: cast zx s_2126_3 -> i
        let s_2126_4: i128 = (i128::try_from(s_2126_3).unwrap());
        // C s_2126_5: const #11s : i
        let s_2126_5: i128 = 11;
        // C s_2126_6: add s_2126_5 s_2126_4
        let s_2126_6: i128 = (s_2126_5 + s_2126_4);
        // D s_2126_7: bit-extract s_2126_2 s_2126_0 s_2126_6
        let s_2126_7: Bits = (Bits::new(
            ((s_2126_2) >> (s_2126_0)).value(),
            u16::try_from(s_2126_6).unwrap(),
        ));
        // D s_2126_8: cast reint s_2126_7 -> u12
        let s_2126_8: u16 = (s_2126_7.value() as u16);
        // D s_2126_9: cast zx s_2126_8 -> bv
        let s_2126_9: Bits = Bits::new(s_2126_8 as u128, 12u16);
        // C s_2126_10: const #3743u : u12
        let s_2126_10: u16 = 3743;
        // C s_2126_11: cast zx s_2126_10 -> bv
        let s_2126_11: Bits = Bits::new(s_2126_10 as u128, 12u16);
        // D s_2126_12: cmp-eq s_2126_9 s_2126_11
        let s_2126_12: bool = ((s_2126_9) == (s_2126_11));
        // D s_2126_13: write-var gs#407981 <= s_2126_12
        fn_state.gs_407981 = s_2126_12;
        // N s_2126_14: jump b1685
        return block_1685(state, tracer, fn_state);
    }
    fn block_2127<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2127_0: const #28s : i
        let s_2127_0: i128 = 28;
        // C s_2127_1: const #4s : i
        let s_2127_1: i128 = 4;
        // D s_2127_2: read-var u#33196:u32
        let s_2127_2: u32 = fn_state.u_33196;
        // D s_2127_3: cast zx s_2127_2 -> bv
        let s_2127_3: Bits = Bits::new(s_2127_2 as u128, 32u16);
        // D s_2127_4: bit-extract s_2127_3 s_2127_0 s_2127_1
        let s_2127_4: Bits = (Bits::new(
            ((s_2127_3) >> (s_2127_0)).value(),
            u16::try_from(s_2127_1).unwrap(),
        ));
        // D s_2127_5: cast reint s_2127_4 -> u8
        let s_2127_5: u8 = (s_2127_4.value() as u8);
        // D s_2127_6: cast zx s_2127_5 -> bv
        let s_2127_6: Bits = Bits::new(s_2127_5 as u128, 4u16);
        // C s_2127_7: const #15u : u8
        let s_2127_7: u8 = 15;
        // C s_2127_8: cast zx s_2127_7 -> bv
        let s_2127_8: Bits = Bits::new(s_2127_7 as u128, 4u16);
        // D s_2127_9: cmp-ne s_2127_6 s_2127_8
        let s_2127_9: bool = ((s_2127_6) != (s_2127_8));
        // N s_2127_10: branch s_2127_9 b2130 b2128
        if s_2127_9 {
            return block_2130(state, tracer, fn_state);
        } else {
            return block_2128(state, tracer, fn_state);
        };
    }
    fn block_2128<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2128_0: const #0u : u8
        let s_2128_0: bool = false;
        // D s_2128_1: write-var gs#407949 <= s_2128_0
        fn_state.gs_407949 = s_2128_0;
        // N s_2128_2: jump b2129
        return block_2129(state, tracer, fn_state);
    }
    fn block_2129<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2129_0: read-var gs#407949:u8
        let s_2129_0: bool = fn_state.gs_407949;
        // D s_2129_1: write-var gs#407950 <= s_2129_0
        fn_state.gs_407950 = s_2129_0;
        // N s_2129_2: jump b1664
        return block_1664(state, tracer, fn_state);
    }
    fn block_2130<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2130_0: const #3817s : i
        let s_2130_0: i128 = 3817;
        // C s_2130_1: const #14696u : u32
        let s_2130_1: u32 = 14696;
        // D s_2130_2: read-reg s_2130_1:i
        let s_2130_2: i128 = {
            let value = state.read_register::<i128>(s_2130_1 as isize);
            tracer.read_register(s_2130_1 as isize, value);
            value
        };
        // D s_2130_3: cmp-lt s_2130_2 s_2130_0
        let s_2130_3: bool = ((s_2130_2) < (s_2130_0));
        // D s_2130_4: write-var gs#407949 <= s_2130_3
        fn_state.gs_407949 = s_2130_3;
        // N s_2130_5: jump b2129
        return block_2129(state, tracer, fn_state);
    }
    fn block_2131<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2131_0: const #0s : i
        let s_2131_0: i128 = 0;
        // D s_2131_1: read-var u#33196:u32
        let s_2131_1: u32 = fn_state.u_33196;
        // D s_2131_2: cast zx s_2131_1 -> bv
        let s_2131_2: Bits = Bits::new(s_2131_1 as u128, 32u16);
        // C s_2131_3: const #1s : i64
        let s_2131_3: i64 = 1;
        // C s_2131_4: cast zx s_2131_3 -> i
        let s_2131_4: i128 = (i128::try_from(s_2131_3).unwrap());
        // C s_2131_5: const #11s : i
        let s_2131_5: i128 = 11;
        // C s_2131_6: add s_2131_5 s_2131_4
        let s_2131_6: i128 = (s_2131_5 + s_2131_4);
        // D s_2131_7: bit-extract s_2131_2 s_2131_0 s_2131_6
        let s_2131_7: Bits = (Bits::new(
            ((s_2131_2) >> (s_2131_0)).value(),
            u16::try_from(s_2131_6).unwrap(),
        ));
        // D s_2131_8: cast reint s_2131_7 -> u12
        let s_2131_8: u16 = (s_2131_7.value() as u16);
        // D s_2131_9: cast zx s_2131_8 -> bv
        let s_2131_9: Bits = Bits::new(s_2131_8 as u128, 12u16);
        // C s_2131_10: const #3231u : u12
        let s_2131_10: u16 = 3231;
        // C s_2131_11: cast zx s_2131_10 -> bv
        let s_2131_11: Bits = Bits::new(s_2131_10 as u128, 12u16);
        // D s_2131_12: cmp-eq s_2131_9 s_2131_11
        let s_2131_12: bool = ((s_2131_9) == (s_2131_11));
        // D s_2131_13: write-var gs#407945 <= s_2131_12
        fn_state.gs_407945 = s_2131_12;
        // N s_2131_14: jump b1662
        return block_1662(state, tracer, fn_state);
    }
    fn block_2132<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2132_0: const #28s : i
        let s_2132_0: i128 = 28;
        // C s_2132_1: const #4s : i
        let s_2132_1: i128 = 4;
        // D s_2132_2: read-var u#33191:u32
        let s_2132_2: u32 = fn_state.u_33191;
        // D s_2132_3: cast zx s_2132_2 -> bv
        let s_2132_3: Bits = Bits::new(s_2132_2 as u128, 32u16);
        // D s_2132_4: bit-extract s_2132_3 s_2132_0 s_2132_1
        let s_2132_4: Bits = (Bits::new(
            ((s_2132_3) >> (s_2132_0)).value(),
            u16::try_from(s_2132_1).unwrap(),
        ));
        // D s_2132_5: cast reint s_2132_4 -> u8
        let s_2132_5: u8 = (s_2132_4.value() as u8);
        // D s_2132_6: cast zx s_2132_5 -> bv
        let s_2132_6: Bits = Bits::new(s_2132_5 as u128, 4u16);
        // C s_2132_7: const #15u : u8
        let s_2132_7: u8 = 15;
        // C s_2132_8: cast zx s_2132_7 -> bv
        let s_2132_8: Bits = Bits::new(s_2132_7 as u128, 4u16);
        // D s_2132_9: cmp-ne s_2132_6 s_2132_8
        let s_2132_9: bool = ((s_2132_6) != (s_2132_8));
        // N s_2132_10: branch s_2132_9 b2135 b2133
        if s_2132_9 {
            return block_2135(state, tracer, fn_state);
        } else {
            return block_2133(state, tracer, fn_state);
        };
    }
    fn block_2133<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2133_0: const #0u : u8
        let s_2133_0: bool = false;
        // D s_2133_1: write-var gs#407913 <= s_2133_0
        fn_state.gs_407913 = s_2133_0;
        // N s_2133_2: jump b2134
        return block_2134(state, tracer, fn_state);
    }
    fn block_2134<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2134_0: read-var gs#407913:u8
        let s_2134_0: bool = fn_state.gs_407913;
        // D s_2134_1: write-var gs#407914 <= s_2134_0
        fn_state.gs_407914 = s_2134_0;
        // N s_2134_2: jump b1641
        return block_1641(state, tracer, fn_state);
    }
    fn block_2135<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2135_0: const #3815s : i
        let s_2135_0: i128 = 3815;
        // C s_2135_1: const #14696u : u32
        let s_2135_1: u32 = 14696;
        // D s_2135_2: read-reg s_2135_1:i
        let s_2135_2: i128 = {
            let value = state.read_register::<i128>(s_2135_1 as isize);
            tracer.read_register(s_2135_1 as isize, value);
            value
        };
        // D s_2135_3: cmp-lt s_2135_2 s_2135_0
        let s_2135_3: bool = ((s_2135_2) < (s_2135_0));
        // D s_2135_4: write-var gs#407913 <= s_2135_3
        fn_state.gs_407913 = s_2135_3;
        // N s_2135_5: jump b2134
        return block_2134(state, tracer, fn_state);
    }
    fn block_2136<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2136_0: const #0s : i
        let s_2136_0: i128 = 0;
        // D s_2136_1: read-var u#33191:u32
        let s_2136_1: u32 = fn_state.u_33191;
        // D s_2136_2: cast zx s_2136_1 -> bv
        let s_2136_2: Bits = Bits::new(s_2136_1 as u128, 32u16);
        // C s_2136_3: const #1s : i64
        let s_2136_3: i64 = 1;
        // C s_2136_4: cast zx s_2136_3 -> i
        let s_2136_4: i128 = (i128::try_from(s_2136_3).unwrap());
        // C s_2136_5: const #11s : i
        let s_2136_5: i128 = 11;
        // C s_2136_6: add s_2136_5 s_2136_4
        let s_2136_6: i128 = (s_2136_5 + s_2136_4);
        // D s_2136_7: bit-extract s_2136_2 s_2136_0 s_2136_6
        let s_2136_7: Bits = (Bits::new(
            ((s_2136_2) >> (s_2136_0)).value(),
            u16::try_from(s_2136_6).unwrap(),
        ));
        // D s_2136_8: cast reint s_2136_7 -> u12
        let s_2136_8: u16 = (s_2136_7.value() as u16);
        // D s_2136_9: cast zx s_2136_8 -> bv
        let s_2136_9: Bits = Bits::new(s_2136_8 as u128, 12u16);
        // C s_2136_10: const #3231u : u12
        let s_2136_10: u16 = 3231;
        // C s_2136_11: cast zx s_2136_10 -> bv
        let s_2136_11: Bits = Bits::new(s_2136_10 as u128, 12u16);
        // D s_2136_12: cmp-eq s_2136_9 s_2136_11
        let s_2136_12: bool = ((s_2136_9) == (s_2136_11));
        // D s_2136_13: write-var gs#407909 <= s_2136_12
        fn_state.gs_407909 = s_2136_12;
        // N s_2136_14: jump b1639
        return block_1639(state, tracer, fn_state);
    }
    fn block_2137<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2137_0: const #28s : i
        let s_2137_0: i128 = 28;
        // C s_2137_1: const #4s : i
        let s_2137_1: i128 = 4;
        // D s_2137_2: read-var u#33186:u32
        let s_2137_2: u32 = fn_state.u_33186;
        // D s_2137_3: cast zx s_2137_2 -> bv
        let s_2137_3: Bits = Bits::new(s_2137_2 as u128, 32u16);
        // D s_2137_4: bit-extract s_2137_3 s_2137_0 s_2137_1
        let s_2137_4: Bits = (Bits::new(
            ((s_2137_3) >> (s_2137_0)).value(),
            u16::try_from(s_2137_1).unwrap(),
        ));
        // D s_2137_5: cast reint s_2137_4 -> u8
        let s_2137_5: u8 = (s_2137_4.value() as u8);
        // D s_2137_6: cast zx s_2137_5 -> bv
        let s_2137_6: Bits = Bits::new(s_2137_5 as u128, 4u16);
        // C s_2137_7: const #15u : u8
        let s_2137_7: u8 = 15;
        // C s_2137_8: cast zx s_2137_7 -> bv
        let s_2137_8: Bits = Bits::new(s_2137_7 as u128, 4u16);
        // D s_2137_9: cmp-ne s_2137_6 s_2137_8
        let s_2137_9: bool = ((s_2137_6) != (s_2137_8));
        // N s_2137_10: branch s_2137_9 b2140 b2138
        if s_2137_9 {
            return block_2140(state, tracer, fn_state);
        } else {
            return block_2138(state, tracer, fn_state);
        };
    }
    fn block_2138<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2138_0: const #0u : u8
        let s_2138_0: bool = false;
        // D s_2138_1: write-var gs#407894 <= s_2138_0
        fn_state.gs_407894 = s_2138_0;
        // N s_2138_2: jump b2139
        return block_2139(state, tracer, fn_state);
    }
    fn block_2139<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2139_0: read-var gs#407894:u8
        let s_2139_0: bool = fn_state.gs_407894;
        // D s_2139_1: write-var gs#407895 <= s_2139_0
        fn_state.gs_407895 = s_2139_0;
        // N s_2139_2: jump b1635
        return block_1635(state, tracer, fn_state);
    }
    fn block_2140<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2140_0: const #3813s : i
        let s_2140_0: i128 = 3813;
        // C s_2140_1: const #14696u : u32
        let s_2140_1: u32 = 14696;
        // D s_2140_2: read-reg s_2140_1:i
        let s_2140_2: i128 = {
            let value = state.read_register::<i128>(s_2140_1 as isize);
            tracer.read_register(s_2140_1 as isize, value);
            value
        };
        // D s_2140_3: cmp-lt s_2140_2 s_2140_0
        let s_2140_3: bool = ((s_2140_2) < (s_2140_0));
        // D s_2140_4: write-var gs#407894 <= s_2140_3
        fn_state.gs_407894 = s_2140_3;
        // N s_2140_5: jump b2139
        return block_2139(state, tracer, fn_state);
    }
    fn block_2141<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2141_0: const #4s : i
        let s_2141_0: i128 = 4;
        // D s_2141_1: read-var u#33186:u32
        let s_2141_1: u32 = fn_state.u_33186;
        // D s_2141_2: cast zx s_2141_1 -> bv
        let s_2141_2: Bits = Bits::new(s_2141_1 as u128, 32u16);
        // C s_2141_3: const #1s : i64
        let s_2141_3: i64 = 1;
        // C s_2141_4: cast zx s_2141_3 -> i
        let s_2141_4: i128 = (i128::try_from(s_2141_3).unwrap());
        // C s_2141_5: const #3s : i
        let s_2141_5: i128 = 3;
        // C s_2141_6: add s_2141_5 s_2141_4
        let s_2141_6: i128 = (s_2141_5 + s_2141_4);
        // D s_2141_7: bit-extract s_2141_2 s_2141_0 s_2141_6
        let s_2141_7: Bits = (Bits::new(
            ((s_2141_2) >> (s_2141_0)).value(),
            u16::try_from(s_2141_6).unwrap(),
        ));
        // D s_2141_8: cast reint s_2141_7 -> u8
        let s_2141_8: u8 = (s_2141_7.value() as u8);
        // D s_2141_9: cast zx s_2141_8 -> bv
        let s_2141_9: Bits = Bits::new(s_2141_8 as u128, 4u16);
        // C s_2141_10: const #7u : u8
        let s_2141_10: u8 = 7;
        // C s_2141_11: cast zx s_2141_10 -> bv
        let s_2141_11: Bits = Bits::new(s_2141_10 as u128, 4u16);
        // D s_2141_12: cmp-eq s_2141_9 s_2141_11
        let s_2141_12: bool = ((s_2141_9) == (s_2141_11));
        // D s_2141_13: write-var gs#407890 <= s_2141_12
        fn_state.gs_407890 = s_2141_12;
        // N s_2141_14: jump b1633
        return block_1633(state, tracer, fn_state);
    }
    fn block_2142<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2142_0: const #28s : i
        let s_2142_0: i128 = 28;
        // C s_2142_1: const #4s : i
        let s_2142_1: i128 = 4;
        // D s_2142_2: read-var u#33180:u32
        let s_2142_2: u32 = fn_state.u_33180;
        // D s_2142_3: cast zx s_2142_2 -> bv
        let s_2142_3: Bits = Bits::new(s_2142_2 as u128, 32u16);
        // D s_2142_4: bit-extract s_2142_3 s_2142_0 s_2142_1
        let s_2142_4: Bits = (Bits::new(
            ((s_2142_3) >> (s_2142_0)).value(),
            u16::try_from(s_2142_1).unwrap(),
        ));
        // D s_2142_5: cast reint s_2142_4 -> u8
        let s_2142_5: u8 = (s_2142_4.value() as u8);
        // D s_2142_6: cast zx s_2142_5 -> bv
        let s_2142_6: Bits = Bits::new(s_2142_5 as u128, 4u16);
        // C s_2142_7: const #15u : u8
        let s_2142_7: u8 = 15;
        // C s_2142_8: cast zx s_2142_7 -> bv
        let s_2142_8: Bits = Bits::new(s_2142_7 as u128, 4u16);
        // D s_2142_9: cmp-ne s_2142_6 s_2142_8
        let s_2142_9: bool = ((s_2142_6) != (s_2142_8));
        // N s_2142_10: branch s_2142_9 b2145 b2143
        if s_2142_9 {
            return block_2145(state, tracer, fn_state);
        } else {
            return block_2143(state, tracer, fn_state);
        };
    }
    fn block_2143<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2143_0: const #0u : u8
        let s_2143_0: bool = false;
        // D s_2143_1: write-var gs#407861 <= s_2143_0
        fn_state.gs_407861 = s_2143_0;
        // N s_2143_2: jump b2144
        return block_2144(state, tracer, fn_state);
    }
    fn block_2144<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2144_0: read-var gs#407861:u8
        let s_2144_0: bool = fn_state.gs_407861;
        // D s_2144_1: write-var gs#407862 <= s_2144_0
        fn_state.gs_407862 = s_2144_0;
        // N s_2144_2: jump b1621
        return block_1621(state, tracer, fn_state);
    }
    fn block_2145<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2145_0: const #3808s : i
        let s_2145_0: i128 = 3808;
        // C s_2145_1: const #14696u : u32
        let s_2145_1: u32 = 14696;
        // D s_2145_2: read-reg s_2145_1:i
        let s_2145_2: i128 = {
            let value = state.read_register::<i128>(s_2145_1 as isize);
            tracer.read_register(s_2145_1 as isize, value);
            value
        };
        // D s_2145_3: cmp-lt s_2145_2 s_2145_0
        let s_2145_3: bool = ((s_2145_2) < (s_2145_0));
        // D s_2145_4: write-var gs#407861 <= s_2145_3
        fn_state.gs_407861 = s_2145_3;
        // N s_2145_5: jump b2144
        return block_2144(state, tracer, fn_state);
    }
    fn block_2146<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2146_0: const #20s : i
        let s_2146_0: i128 = 20;
        // D s_2146_1: read-var u#33180:u32
        let s_2146_1: u32 = fn_state.u_33180;
        // D s_2146_2: cast zx s_2146_1 -> bv
        let s_2146_2: Bits = Bits::new(s_2146_1 as u128, 32u16);
        // C s_2146_3: const #1s : i64
        let s_2146_3: i64 = 1;
        // C s_2146_4: cast zx s_2146_3 -> i
        let s_2146_4: i128 = (i128::try_from(s_2146_3).unwrap());
        // C s_2146_5: const #0s : i
        let s_2146_5: i128 = 0;
        // C s_2146_6: add s_2146_5 s_2146_4
        let s_2146_6: i128 = (s_2146_5 + s_2146_4);
        // D s_2146_7: bit-extract s_2146_2 s_2146_0 s_2146_6
        let s_2146_7: Bits = (Bits::new(
            ((s_2146_2) >> (s_2146_0)).value(),
            u16::try_from(s_2146_6).unwrap(),
        ));
        // D s_2146_8: cast reint s_2146_7 -> u8
        let s_2146_8: bool = ((s_2146_7.value()) != 0);
        // D s_2146_9: cast zx s_2146_8 -> bv
        let s_2146_9: Bits = Bits::new(s_2146_8 as u128, 1u16);
        // C s_2146_10: const #0u : u8
        let s_2146_10: bool = false;
        // C s_2146_11: cast zx s_2146_10 -> bv
        let s_2146_11: Bits = Bits::new(s_2146_10 as u128, 1u16);
        // D s_2146_12: cmp-eq s_2146_9 s_2146_11
        let s_2146_12: bool = ((s_2146_9) == (s_2146_11));
        // N s_2146_13: branch s_2146_12 b2149 b2147
        if s_2146_12 {
            return block_2149(state, tracer, fn_state);
        } else {
            return block_2147(state, tracer, fn_state);
        };
    }
    fn block_2147<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2147_0: const #0u : u8
        let s_2147_0: bool = false;
        // D s_2147_1: write-var gs#407856 <= s_2147_0
        fn_state.gs_407856 = s_2147_0;
        // N s_2147_2: jump b2148
        return block_2148(state, tracer, fn_state);
    }
    fn block_2148<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2148_0: read-var gs#407856:u8
        let s_2148_0: bool = fn_state.gs_407856;
        // D s_2148_1: write-var gs#407857 <= s_2148_0
        fn_state.gs_407857 = s_2148_0;
        // N s_2148_2: jump b1619
        return block_1619(state, tracer, fn_state);
    }
    fn block_2149<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2149_0: const #10s : i
        let s_2149_0: i128 = 10;
        // D s_2149_1: read-var u#33180:u32
        let s_2149_1: u32 = fn_state.u_33180;
        // D s_2149_2: cast zx s_2149_1 -> bv
        let s_2149_2: Bits = Bits::new(s_2149_1 as u128, 32u16);
        // C s_2149_3: const #1s : i64
        let s_2149_3: i64 = 1;
        // C s_2149_4: cast zx s_2149_3 -> i
        let s_2149_4: i128 = (i128::try_from(s_2149_3).unwrap());
        // C s_2149_5: const #1s : i
        let s_2149_5: i128 = 1;
        // C s_2149_6: add s_2149_5 s_2149_4
        let s_2149_6: i128 = (s_2149_5 + s_2149_4);
        // D s_2149_7: bit-extract s_2149_2 s_2149_0 s_2149_6
        let s_2149_7: Bits = (Bits::new(
            ((s_2149_2) >> (s_2149_0)).value(),
            u16::try_from(s_2149_6).unwrap(),
        ));
        // D s_2149_8: cast reint s_2149_7 -> u8
        let s_2149_8: u8 = (s_2149_7.value() as u8);
        // D s_2149_9: cast zx s_2149_8 -> bv
        let s_2149_9: Bits = Bits::new(s_2149_8 as u128, 2u16);
        // C s_2149_10: const #0u : u8
        let s_2149_10: u8 = 0;
        // C s_2149_11: cast zx s_2149_10 -> bv
        let s_2149_11: Bits = Bits::new(s_2149_10 as u128, 2u16);
        // D s_2149_12: cmp-eq s_2149_9 s_2149_11
        let s_2149_12: bool = ((s_2149_9) == (s_2149_11));
        // N s_2149_13: branch s_2149_12 b2152 b2150
        if s_2149_12 {
            return block_2152(state, tracer, fn_state);
        } else {
            return block_2150(state, tracer, fn_state);
        };
    }
    fn block_2150<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2150_0: const #0u : u8
        let s_2150_0: bool = false;
        // D s_2150_1: write-var gs#407855 <= s_2150_0
        fn_state.gs_407855 = s_2150_0;
        // N s_2150_2: jump b2151
        return block_2151(state, tracer, fn_state);
    }
    fn block_2151<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2151_0: read-var gs#407855:u8
        let s_2151_0: bool = fn_state.gs_407855;
        // D s_2151_1: write-var gs#407856 <= s_2151_0
        fn_state.gs_407856 = s_2151_0;
        // N s_2151_2: jump b2148
        return block_2148(state, tracer, fn_state);
    }
    fn block_2152<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2152_0: const #4s : i
        let s_2152_0: i128 = 4;
        // D s_2152_1: read-var u#33180:u32
        let s_2152_1: u32 = fn_state.u_33180;
        // D s_2152_2: cast zx s_2152_1 -> bv
        let s_2152_2: Bits = Bits::new(s_2152_1 as u128, 32u16);
        // C s_2152_3: const #1s : i64
        let s_2152_3: i64 = 1;
        // C s_2152_4: cast zx s_2152_3 -> i
        let s_2152_4: i128 = (i128::try_from(s_2152_3).unwrap());
        // C s_2152_5: const #4s : i
        let s_2152_5: i128 = 4;
        // C s_2152_6: add s_2152_5 s_2152_4
        let s_2152_6: i128 = (s_2152_5 + s_2152_4);
        // D s_2152_7: bit-extract s_2152_2 s_2152_0 s_2152_6
        let s_2152_7: Bits = (Bits::new(
            ((s_2152_2) >> (s_2152_0)).value(),
            u16::try_from(s_2152_6).unwrap(),
        ));
        // D s_2152_8: cast reint s_2152_7 -> u8
        let s_2152_8: u8 = (s_2152_7.value() as u8);
        // D s_2152_9: cast zx s_2152_8 -> bv
        let s_2152_9: Bits = Bits::new(s_2152_8 as u128, 5u16);
        // C s_2152_10: const #4u : u8
        let s_2152_10: u8 = 4;
        // C s_2152_11: cast zx s_2152_10 -> bv
        let s_2152_11: Bits = Bits::new(s_2152_10 as u128, 5u16);
        // D s_2152_12: cmp-eq s_2152_9 s_2152_11
        let s_2152_12: bool = ((s_2152_9) == (s_2152_11));
        // D s_2152_13: write-var gs#407855 <= s_2152_12
        fn_state.gs_407855 = s_2152_12;
        // N s_2152_14: jump b2151
        return block_2151(state, tracer, fn_state);
    }
    fn block_2153<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2153_0: const #28s : i
        let s_2153_0: i128 = 28;
        // C s_2153_1: const #4s : i
        let s_2153_1: i128 = 4;
        // D s_2153_2: read-var u#33176:u32
        let s_2153_2: u32 = fn_state.u_33176;
        // D s_2153_3: cast zx s_2153_2 -> bv
        let s_2153_3: Bits = Bits::new(s_2153_2 as u128, 32u16);
        // D s_2153_4: bit-extract s_2153_3 s_2153_0 s_2153_1
        let s_2153_4: Bits = (Bits::new(
            ((s_2153_3) >> (s_2153_0)).value(),
            u16::try_from(s_2153_1).unwrap(),
        ));
        // D s_2153_5: cast reint s_2153_4 -> u8
        let s_2153_5: u8 = (s_2153_4.value() as u8);
        // D s_2153_6: cast zx s_2153_5 -> bv
        let s_2153_6: Bits = Bits::new(s_2153_5 as u128, 4u16);
        // C s_2153_7: const #15u : u8
        let s_2153_7: u8 = 15;
        // C s_2153_8: cast zx s_2153_7 -> bv
        let s_2153_8: Bits = Bits::new(s_2153_7 as u128, 4u16);
        // D s_2153_9: cmp-ne s_2153_6 s_2153_8
        let s_2153_9: bool = ((s_2153_6) != (s_2153_8));
        // N s_2153_10: branch s_2153_9 b2156 b2154
        if s_2153_9 {
            return block_2156(state, tracer, fn_state);
        } else {
            return block_2154(state, tracer, fn_state);
        };
    }
    fn block_2154<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2154_0: const #0u : u8
        let s_2154_0: bool = false;
        // D s_2154_1: write-var gs#407803 <= s_2154_0
        fn_state.gs_407803 = s_2154_0;
        // N s_2154_2: jump b2155
        return block_2155(state, tracer, fn_state);
    }
    fn block_2155<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2155_0: read-var gs#407803:u8
        let s_2155_0: bool = fn_state.gs_407803;
        // D s_2155_1: write-var gs#407804 <= s_2155_0
        fn_state.gs_407804 = s_2155_0;
        // N s_2155_2: jump b1580
        return block_1580(state, tracer, fn_state);
    }
    fn block_2156<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2156_0: const #3790s : i
        let s_2156_0: i128 = 3790;
        // C s_2156_1: const #14696u : u32
        let s_2156_1: u32 = 14696;
        // D s_2156_2: read-reg s_2156_1:i
        let s_2156_2: i128 = {
            let value = state.read_register::<i128>(s_2156_1 as isize);
            tracer.read_register(s_2156_1 as isize, value);
            value
        };
        // D s_2156_3: cmp-lt s_2156_2 s_2156_0
        let s_2156_3: bool = ((s_2156_2) < (s_2156_0));
        // D s_2156_4: write-var gs#407803 <= s_2156_3
        fn_state.gs_407803 = s_2156_3;
        // N s_2156_5: jump b2155
        return block_2155(state, tracer, fn_state);
    }
    fn block_2157<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2157_0: const #28s : i
        let s_2157_0: i128 = 28;
        // C s_2157_1: const #4s : i
        let s_2157_1: i128 = 4;
        // D s_2157_2: read-var u#33170:u32
        let s_2157_2: u32 = fn_state.u_33170;
        // D s_2157_3: cast zx s_2157_2 -> bv
        let s_2157_3: Bits = Bits::new(s_2157_2 as u128, 32u16);
        // D s_2157_4: bit-extract s_2157_3 s_2157_0 s_2157_1
        let s_2157_4: Bits = (Bits::new(
            ((s_2157_3) >> (s_2157_0)).value(),
            u16::try_from(s_2157_1).unwrap(),
        ));
        // D s_2157_5: cast reint s_2157_4 -> u8
        let s_2157_5: u8 = (s_2157_4.value() as u8);
        // D s_2157_6: cast zx s_2157_5 -> bv
        let s_2157_6: Bits = Bits::new(s_2157_5 as u128, 4u16);
        // C s_2157_7: const #15u : u8
        let s_2157_7: u8 = 15;
        // C s_2157_8: cast zx s_2157_7 -> bv
        let s_2157_8: Bits = Bits::new(s_2157_7 as u128, 4u16);
        // D s_2157_9: cmp-ne s_2157_6 s_2157_8
        let s_2157_9: bool = ((s_2157_6) != (s_2157_8));
        // N s_2157_10: branch s_2157_9 b2160 b2158
        if s_2157_9 {
            return block_2160(state, tracer, fn_state);
        } else {
            return block_2158(state, tracer, fn_state);
        };
    }
    fn block_2158<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2158_0: const #0u : u8
        let s_2158_0: bool = false;
        // D s_2158_1: write-var gs#407765 <= s_2158_0
        fn_state.gs_407765 = s_2158_0;
        // N s_2158_2: jump b2159
        return block_2159(state, tracer, fn_state);
    }
    fn block_2159<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2159_0: read-var gs#407765:u8
        let s_2159_0: bool = fn_state.gs_407765;
        // D s_2159_1: write-var gs#407766 <= s_2159_0
        fn_state.gs_407766 = s_2159_0;
        // N s_2159_2: jump b1556
        return block_1556(state, tracer, fn_state);
    }
    fn block_2160<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2160_0: const #3785s : i
        let s_2160_0: i128 = 3785;
        // C s_2160_1: const #14696u : u32
        let s_2160_1: u32 = 14696;
        // D s_2160_2: read-reg s_2160_1:i
        let s_2160_2: i128 = {
            let value = state.read_register::<i128>(s_2160_1 as isize);
            tracer.read_register(s_2160_1 as isize, value);
            value
        };
        // D s_2160_3: cmp-lt s_2160_2 s_2160_0
        let s_2160_3: bool = ((s_2160_2) < (s_2160_0));
        // D s_2160_4: write-var gs#407765 <= s_2160_3
        fn_state.gs_407765 = s_2160_3;
        // N s_2160_5: jump b2159
        return block_2159(state, tracer, fn_state);
    }
    fn block_2161<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2161_0: const #20s : i
        let s_2161_0: i128 = 20;
        // D s_2161_1: read-var u#33170:u32
        let s_2161_1: u32 = fn_state.u_33170;
        // D s_2161_2: cast zx s_2161_1 -> bv
        let s_2161_2: Bits = Bits::new(s_2161_1 as u128, 32u16);
        // C s_2161_3: const #1s : i64
        let s_2161_3: i64 = 1;
        // C s_2161_4: cast zx s_2161_3 -> i
        let s_2161_4: i128 = (i128::try_from(s_2161_3).unwrap());
        // C s_2161_5: const #1s : i
        let s_2161_5: i128 = 1;
        // C s_2161_6: add s_2161_5 s_2161_4
        let s_2161_6: i128 = (s_2161_5 + s_2161_4);
        // D s_2161_7: bit-extract s_2161_2 s_2161_0 s_2161_6
        let s_2161_7: Bits = (Bits::new(
            ((s_2161_2) >> (s_2161_0)).value(),
            u16::try_from(s_2161_6).unwrap(),
        ));
        // D s_2161_8: cast reint s_2161_7 -> u8
        let s_2161_8: u8 = (s_2161_7.value() as u8);
        // D s_2161_9: cast zx s_2161_8 -> bv
        let s_2161_9: Bits = Bits::new(s_2161_8 as u128, 2u16);
        // C s_2161_10: const #2u : u8
        let s_2161_10: u8 = 2;
        // C s_2161_11: cast zx s_2161_10 -> bv
        let s_2161_11: Bits = Bits::new(s_2161_10 as u128, 2u16);
        // D s_2161_12: cmp-eq s_2161_9 s_2161_11
        let s_2161_12: bool = ((s_2161_9) == (s_2161_11));
        // N s_2161_13: branch s_2161_12 b2164 b2162
        if s_2161_12 {
            return block_2164(state, tracer, fn_state);
        } else {
            return block_2162(state, tracer, fn_state);
        };
    }
    fn block_2162<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2162_0: const #0u : u8
        let s_2162_0: bool = false;
        // D s_2162_1: write-var gs#407760 <= s_2162_0
        fn_state.gs_407760 = s_2162_0;
        // N s_2162_2: jump b2163
        return block_2163(state, tracer, fn_state);
    }
    fn block_2163<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2163_0: read-var gs#407760:u8
        let s_2163_0: bool = fn_state.gs_407760;
        // D s_2163_1: write-var gs#407761 <= s_2163_0
        fn_state.gs_407761 = s_2163_0;
        // N s_2163_2: jump b1554
        return block_1554(state, tracer, fn_state);
    }
    fn block_2164<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2164_0: const #4s : i
        let s_2164_0: i128 = 4;
        // D s_2164_1: read-var u#33170:u32
        let s_2164_1: u32 = fn_state.u_33170;
        // D s_2164_2: cast zx s_2164_1 -> bv
        let s_2164_2: Bits = Bits::new(s_2164_1 as u128, 32u16);
        // C s_2164_3: const #1s : i64
        let s_2164_3: i64 = 1;
        // C s_2164_4: cast zx s_2164_3 -> i
        let s_2164_4: i128 = (i128::try_from(s_2164_3).unwrap());
        // C s_2164_5: const #11s : i
        let s_2164_5: i128 = 11;
        // C s_2164_6: add s_2164_5 s_2164_4
        let s_2164_6: i128 = (s_2164_5 + s_2164_4);
        // D s_2164_7: bit-extract s_2164_2 s_2164_0 s_2164_6
        let s_2164_7: Bits = (Bits::new(
            ((s_2164_2) >> (s_2164_0)).value(),
            u16::try_from(s_2164_6).unwrap(),
        ));
        // D s_2164_8: cast reint s_2164_7 -> u12
        let s_2164_8: u16 = (s_2164_7.value() as u16);
        // D s_2164_9: cast zx s_2164_8 -> bv
        let s_2164_9: Bits = Bits::new(s_2164_8 as u128, 12u16);
        // C s_2164_10: const #3840u : u12
        let s_2164_10: u16 = 3840;
        // C s_2164_11: cast zx s_2164_10 -> bv
        let s_2164_11: Bits = Bits::new(s_2164_10 as u128, 12u16);
        // D s_2164_12: cmp-eq s_2164_9 s_2164_11
        let s_2164_12: bool = ((s_2164_9) == (s_2164_11));
        // D s_2164_13: write-var gs#407760 <= s_2164_12
        fn_state.gs_407760 = s_2164_12;
        // N s_2164_14: jump b2163
        return block_2163(state, tracer, fn_state);
    }
    fn block_2165<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2165_0: const #28s : i
        let s_2165_0: i128 = 28;
        // C s_2165_1: const #4s : i
        let s_2165_1: i128 = 4;
        // D s_2165_2: read-var u#33165:u32
        let s_2165_2: u32 = fn_state.u_33165;
        // D s_2165_3: cast zx s_2165_2 -> bv
        let s_2165_3: Bits = Bits::new(s_2165_2 as u128, 32u16);
        // D s_2165_4: bit-extract s_2165_3 s_2165_0 s_2165_1
        let s_2165_4: Bits = (Bits::new(
            ((s_2165_3) >> (s_2165_0)).value(),
            u16::try_from(s_2165_1).unwrap(),
        ));
        // D s_2165_5: cast reint s_2165_4 -> u8
        let s_2165_5: u8 = (s_2165_4.value() as u8);
        // D s_2165_6: cast zx s_2165_5 -> bv
        let s_2165_6: Bits = Bits::new(s_2165_5 as u128, 4u16);
        // C s_2165_7: const #15u : u8
        let s_2165_7: u8 = 15;
        // C s_2165_8: cast zx s_2165_7 -> bv
        let s_2165_8: Bits = Bits::new(s_2165_7 as u128, 4u16);
        // D s_2165_9: cmp-ne s_2165_6 s_2165_8
        let s_2165_9: bool = ((s_2165_6) != (s_2165_8));
        // N s_2165_10: branch s_2165_9 b2168 b2166
        if s_2165_9 {
            return block_2168(state, tracer, fn_state);
        } else {
            return block_2166(state, tracer, fn_state);
        };
    }
    fn block_2166<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2166_0: const #0u : u8
        let s_2166_0: bool = false;
        // D s_2166_1: write-var gs#407730 <= s_2166_0
        fn_state.gs_407730 = s_2166_0;
        // N s_2166_2: jump b2167
        return block_2167(state, tracer, fn_state);
    }
    fn block_2167<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2167_0: read-var gs#407730:u8
        let s_2167_0: bool = fn_state.gs_407730;
        // D s_2167_1: write-var gs#407731 <= s_2167_0
        fn_state.gs_407731 = s_2167_0;
        // N s_2167_2: jump b1539
        return block_1539(state, tracer, fn_state);
    }
    fn block_2168<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2168_0: const #3784s : i
        let s_2168_0: i128 = 3784;
        // C s_2168_1: const #14696u : u32
        let s_2168_1: u32 = 14696;
        // D s_2168_2: read-reg s_2168_1:i
        let s_2168_2: i128 = {
            let value = state.read_register::<i128>(s_2168_1 as isize);
            tracer.read_register(s_2168_1 as isize, value);
            value
        };
        // D s_2168_3: cmp-lt s_2168_2 s_2168_0
        let s_2168_3: bool = ((s_2168_2) < (s_2168_0));
        // D s_2168_4: write-var gs#407730 <= s_2168_3
        fn_state.gs_407730 = s_2168_3;
        // N s_2168_5: jump b2167
        return block_2167(state, tracer, fn_state);
    }
    fn block_2169<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2169_0: const #20s : i
        let s_2169_0: i128 = 20;
        // D s_2169_1: read-var u#33165:u32
        let s_2169_1: u32 = fn_state.u_33165;
        // D s_2169_2: cast zx s_2169_1 -> bv
        let s_2169_2: Bits = Bits::new(s_2169_1 as u128, 32u16);
        // C s_2169_3: const #1s : i64
        let s_2169_3: i64 = 1;
        // C s_2169_4: cast zx s_2169_3 -> i
        let s_2169_4: i128 = (i128::try_from(s_2169_3).unwrap());
        // C s_2169_5: const #1s : i
        let s_2169_5: i128 = 1;
        // C s_2169_6: add s_2169_5 s_2169_4
        let s_2169_6: i128 = (s_2169_5 + s_2169_4);
        // D s_2169_7: bit-extract s_2169_2 s_2169_0 s_2169_6
        let s_2169_7: Bits = (Bits::new(
            ((s_2169_2) >> (s_2169_0)).value(),
            u16::try_from(s_2169_6).unwrap(),
        ));
        // D s_2169_8: cast reint s_2169_7 -> u8
        let s_2169_8: u8 = (s_2169_7.value() as u8);
        // D s_2169_9: cast zx s_2169_8 -> bv
        let s_2169_9: Bits = Bits::new(s_2169_8 as u128, 2u16);
        // C s_2169_10: const #2u : u8
        let s_2169_10: u8 = 2;
        // C s_2169_11: cast zx s_2169_10 -> bv
        let s_2169_11: Bits = Bits::new(s_2169_10 as u128, 2u16);
        // D s_2169_12: cmp-eq s_2169_9 s_2169_11
        let s_2169_12: bool = ((s_2169_9) == (s_2169_11));
        // N s_2169_13: branch s_2169_12 b2172 b2170
        if s_2169_12 {
            return block_2172(state, tracer, fn_state);
        } else {
            return block_2170(state, tracer, fn_state);
        };
    }
    fn block_2170<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2170_0: const #0u : u8
        let s_2170_0: bool = false;
        // D s_2170_1: write-var gs#407725 <= s_2170_0
        fn_state.gs_407725 = s_2170_0;
        // N s_2170_2: jump b2171
        return block_2171(state, tracer, fn_state);
    }
    fn block_2171<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2171_0: read-var gs#407725:u8
        let s_2171_0: bool = fn_state.gs_407725;
        // D s_2171_1: write-var gs#407726 <= s_2171_0
        fn_state.gs_407726 = s_2171_0;
        // N s_2171_2: jump b1537
        return block_1537(state, tracer, fn_state);
    }
    fn block_2172<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2172_0: const #12s : i
        let s_2172_0: i128 = 12;
        // D s_2172_1: read-var u#33165:u32
        let s_2172_1: u32 = fn_state.u_33165;
        // D s_2172_2: cast zx s_2172_1 -> bv
        let s_2172_2: Bits = Bits::new(s_2172_1 as u128, 32u16);
        // C s_2172_3: const #1s : i64
        let s_2172_3: i64 = 1;
        // C s_2172_4: cast zx s_2172_3 -> i
        let s_2172_4: i128 = (i128::try_from(s_2172_3).unwrap());
        // C s_2172_5: const #3s : i
        let s_2172_5: i128 = 3;
        // C s_2172_6: add s_2172_5 s_2172_4
        let s_2172_6: i128 = (s_2172_5 + s_2172_4);
        // D s_2172_7: bit-extract s_2172_2 s_2172_0 s_2172_6
        let s_2172_7: Bits = (Bits::new(
            ((s_2172_2) >> (s_2172_0)).value(),
            u16::try_from(s_2172_6).unwrap(),
        ));
        // D s_2172_8: cast reint s_2172_7 -> u8
        let s_2172_8: u8 = (s_2172_7.value() as u8);
        // D s_2172_9: cast zx s_2172_8 -> bv
        let s_2172_9: Bits = Bits::new(s_2172_8 as u128, 4u16);
        // C s_2172_10: const #15u : u8
        let s_2172_10: u8 = 15;
        // C s_2172_11: cast zx s_2172_10 -> bv
        let s_2172_11: Bits = Bits::new(s_2172_10 as u128, 4u16);
        // D s_2172_12: cmp-eq s_2172_9 s_2172_11
        let s_2172_12: bool = ((s_2172_9) == (s_2172_11));
        // D s_2172_13: write-var gs#407725 <= s_2172_12
        fn_state.gs_407725 = s_2172_12;
        // N s_2172_14: jump b2171
        return block_2171(state, tracer, fn_state);
    }
    fn block_2173<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2173_0: const #28s : i
        let s_2173_0: i128 = 28;
        // C s_2173_1: const #4s : i
        let s_2173_1: i128 = 4;
        // D s_2173_2: read-var u#33158:u32
        let s_2173_2: u32 = fn_state.u_33158;
        // D s_2173_3: cast zx s_2173_2 -> bv
        let s_2173_3: Bits = Bits::new(s_2173_2 as u128, 32u16);
        // D s_2173_4: bit-extract s_2173_3 s_2173_0 s_2173_1
        let s_2173_4: Bits = (Bits::new(
            ((s_2173_3) >> (s_2173_0)).value(),
            u16::try_from(s_2173_1).unwrap(),
        ));
        // D s_2173_5: cast reint s_2173_4 -> u8
        let s_2173_5: u8 = (s_2173_4.value() as u8);
        // D s_2173_6: cast zx s_2173_5 -> bv
        let s_2173_6: Bits = Bits::new(s_2173_5 as u128, 4u16);
        // C s_2173_7: const #15u : u8
        let s_2173_7: u8 = 15;
        // C s_2173_8: cast zx s_2173_7 -> bv
        let s_2173_8: Bits = Bits::new(s_2173_7 as u128, 4u16);
        // D s_2173_9: cmp-ne s_2173_6 s_2173_8
        let s_2173_9: bool = ((s_2173_6) != (s_2173_8));
        // N s_2173_10: branch s_2173_9 b2176 b2174
        if s_2173_9 {
            return block_2176(state, tracer, fn_state);
        } else {
            return block_2174(state, tracer, fn_state);
        };
    }
    fn block_2174<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2174_0: const #0u : u8
        let s_2174_0: bool = false;
        // D s_2174_1: write-var gs#407687 <= s_2174_0
        fn_state.gs_407687 = s_2174_0;
        // N s_2174_2: jump b2175
        return block_2175(state, tracer, fn_state);
    }
    fn block_2175<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2175_0: read-var gs#407687:u8
        let s_2175_0: bool = fn_state.gs_407687;
        // D s_2175_1: write-var gs#407688 <= s_2175_0
        fn_state.gs_407688 = s_2175_0;
        // N s_2175_2: jump b1516
        return block_1516(state, tracer, fn_state);
    }
    fn block_2176<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2176_0: const #3782s : i
        let s_2176_0: i128 = 3782;
        // C s_2176_1: const #14696u : u32
        let s_2176_1: u32 = 14696;
        // D s_2176_2: read-reg s_2176_1:i
        let s_2176_2: i128 = {
            let value = state.read_register::<i128>(s_2176_1 as isize);
            tracer.read_register(s_2176_1 as isize, value);
            value
        };
        // D s_2176_3: cmp-lt s_2176_2 s_2176_0
        let s_2176_3: bool = ((s_2176_2) < (s_2176_0));
        // D s_2176_4: write-var gs#407687 <= s_2176_3
        fn_state.gs_407687 = s_2176_3;
        // N s_2176_5: jump b2175
        return block_2175(state, tracer, fn_state);
    }
    fn block_2177<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2177_0: const #20s : i
        let s_2177_0: i128 = 20;
        // D s_2177_1: read-var u#33158:u32
        let s_2177_1: u32 = fn_state.u_33158;
        // D s_2177_2: cast zx s_2177_1 -> bv
        let s_2177_2: Bits = Bits::new(s_2177_1 as u128, 32u16);
        // C s_2177_3: const #1s : i64
        let s_2177_3: i64 = 1;
        // C s_2177_4: cast zx s_2177_3 -> i
        let s_2177_4: i128 = (i128::try_from(s_2177_3).unwrap());
        // C s_2177_5: const #1s : i
        let s_2177_5: i128 = 1;
        // C s_2177_6: add s_2177_5 s_2177_4
        let s_2177_6: i128 = (s_2177_5 + s_2177_4);
        // D s_2177_7: bit-extract s_2177_2 s_2177_0 s_2177_6
        let s_2177_7: Bits = (Bits::new(
            ((s_2177_2) >> (s_2177_0)).value(),
            u16::try_from(s_2177_6).unwrap(),
        ));
        // D s_2177_8: cast reint s_2177_7 -> u8
        let s_2177_8: u8 = (s_2177_7.value() as u8);
        // D s_2177_9: cast zx s_2177_8 -> bv
        let s_2177_9: Bits = Bits::new(s_2177_8 as u128, 2u16);
        // C s_2177_10: const #2u : u8
        let s_2177_10: u8 = 2;
        // C s_2177_11: cast zx s_2177_10 -> bv
        let s_2177_11: Bits = Bits::new(s_2177_10 as u128, 2u16);
        // D s_2177_12: cmp-eq s_2177_9 s_2177_11
        let s_2177_12: bool = ((s_2177_9) == (s_2177_11));
        // N s_2177_13: branch s_2177_12 b2180 b2178
        if s_2177_12 {
            return block_2180(state, tracer, fn_state);
        } else {
            return block_2178(state, tracer, fn_state);
        };
    }
    fn block_2178<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2178_0: const #0u : u8
        let s_2178_0: bool = false;
        // D s_2178_1: write-var gs#407682 <= s_2178_0
        fn_state.gs_407682 = s_2178_0;
        // N s_2178_2: jump b2179
        return block_2179(state, tracer, fn_state);
    }
    fn block_2179<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2179_0: read-var gs#407682:u8
        let s_2179_0: bool = fn_state.gs_407682;
        // D s_2179_1: write-var gs#407683 <= s_2179_0
        fn_state.gs_407683 = s_2179_0;
        // N s_2179_2: jump b1514
        return block_1514(state, tracer, fn_state);
    }
    fn block_2180<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2180_0: const #9s : i
        let s_2180_0: i128 = 9;
        // D s_2180_1: read-var u#33158:u32
        let s_2180_1: u32 = fn_state.u_33158;
        // D s_2180_2: cast zx s_2180_1 -> bv
        let s_2180_2: Bits = Bits::new(s_2180_1 as u128, 32u16);
        // C s_2180_3: const #1s : i64
        let s_2180_3: i64 = 1;
        // C s_2180_4: cast zx s_2180_3 -> i
        let s_2180_4: i128 = (i128::try_from(s_2180_3).unwrap());
        // C s_2180_5: const #6s : i
        let s_2180_5: i128 = 6;
        // C s_2180_6: add s_2180_5 s_2180_4
        let s_2180_6: i128 = (s_2180_5 + s_2180_4);
        // D s_2180_7: bit-extract s_2180_2 s_2180_0 s_2180_6
        let s_2180_7: Bits = (Bits::new(
            ((s_2180_2) >> (s_2180_0)).value(),
            u16::try_from(s_2180_6).unwrap(),
        ));
        // D s_2180_8: cast reint s_2180_7 -> u8
        let s_2180_8: u8 = (s_2180_7.value() as u8);
        // D s_2180_9: cast zx s_2180_8 -> bv
        let s_2180_9: Bits = Bits::new(s_2180_8 as u128, 7u16);
        // C s_2180_10: const #121u : u8
        let s_2180_10: u8 = 121;
        // C s_2180_11: cast zx s_2180_10 -> bv
        let s_2180_11: Bits = Bits::new(s_2180_10 as u128, 7u16);
        // D s_2180_12: cmp-eq s_2180_9 s_2180_11
        let s_2180_12: bool = ((s_2180_9) == (s_2180_11));
        // N s_2180_13: branch s_2180_12 b2183 b2181
        if s_2180_12 {
            return block_2183(state, tracer, fn_state);
        } else {
            return block_2181(state, tracer, fn_state);
        };
    }
    fn block_2181<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2181_0: const #0u : u8
        let s_2181_0: bool = false;
        // D s_2181_1: write-var gs#407681 <= s_2181_0
        fn_state.gs_407681 = s_2181_0;
        // N s_2181_2: jump b2182
        return block_2182(state, tracer, fn_state);
    }
    fn block_2182<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2182_0: read-var gs#407681:u8
        let s_2182_0: bool = fn_state.gs_407681;
        // D s_2182_1: write-var gs#407682 <= s_2182_0
        fn_state.gs_407682 = s_2182_0;
        // N s_2182_2: jump b2179
        return block_2179(state, tracer, fn_state);
    }
    fn block_2183<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2183_0: const #4s : i
        let s_2183_0: i128 = 4;
        // D s_2183_1: read-var u#33158:u32
        let s_2183_1: u32 = fn_state.u_33158;
        // D s_2183_2: cast zx s_2183_1 -> bv
        let s_2183_2: Bits = Bits::new(s_2183_1 as u128, 32u16);
        // C s_2183_3: const #1s : i64
        let s_2183_3: i64 = 1;
        // C s_2183_4: cast zx s_2183_3 -> i
        let s_2183_4: i128 = (i128::try_from(s_2183_3).unwrap());
        // C s_2183_5: const #3s : i
        let s_2183_5: i128 = 3;
        // C s_2183_6: add s_2183_5 s_2183_4
        let s_2183_6: i128 = (s_2183_5 + s_2183_4);
        // D s_2183_7: bit-extract s_2183_2 s_2183_0 s_2183_6
        let s_2183_7: Bits = (Bits::new(
            ((s_2183_2) >> (s_2183_0)).value(),
            u16::try_from(s_2183_6).unwrap(),
        ));
        // D s_2183_8: cast reint s_2183_7 -> u8
        let s_2183_8: u8 = (s_2183_7.value() as u8);
        // D s_2183_9: cast zx s_2183_8 -> bv
        let s_2183_9: Bits = Bits::new(s_2183_8 as u128, 4u16);
        // C s_2183_10: const #0u : u8
        let s_2183_10: u8 = 0;
        // C s_2183_11: cast zx s_2183_10 -> bv
        let s_2183_11: Bits = Bits::new(s_2183_10 as u128, 4u16);
        // D s_2183_12: cmp-eq s_2183_9 s_2183_11
        let s_2183_12: bool = ((s_2183_9) == (s_2183_11));
        // D s_2183_13: write-var gs#407681 <= s_2183_12
        fn_state.gs_407681 = s_2183_12;
        // N s_2183_14: jump b2182
        return block_2182(state, tracer, fn_state);
    }
    fn block_2184<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2184_0: const #28s : i
        let s_2184_0: i128 = 28;
        // C s_2184_1: const #4s : i
        let s_2184_1: i128 = 4;
        // D s_2184_2: read-var u#33152:u32
        let s_2184_2: u32 = fn_state.u_33152;
        // D s_2184_3: cast zx s_2184_2 -> bv
        let s_2184_3: Bits = Bits::new(s_2184_2 as u128, 32u16);
        // D s_2184_4: bit-extract s_2184_3 s_2184_0 s_2184_1
        let s_2184_4: Bits = (Bits::new(
            ((s_2184_3) >> (s_2184_0)).value(),
            u16::try_from(s_2184_1).unwrap(),
        ));
        // D s_2184_5: cast reint s_2184_4 -> u8
        let s_2184_5: u8 = (s_2184_4.value() as u8);
        // D s_2184_6: cast zx s_2184_5 -> bv
        let s_2184_6: Bits = Bits::new(s_2184_5 as u128, 4u16);
        // C s_2184_7: const #15u : u8
        let s_2184_7: u8 = 15;
        // C s_2184_8: cast zx s_2184_7 -> bv
        let s_2184_8: Bits = Bits::new(s_2184_7 as u128, 4u16);
        // D s_2184_9: cmp-ne s_2184_6 s_2184_8
        let s_2184_9: bool = ((s_2184_6) != (s_2184_8));
        // N s_2184_10: branch s_2184_9 b2187 b2185
        if s_2184_9 {
            return block_2187(state, tracer, fn_state);
        } else {
            return block_2185(state, tracer, fn_state);
        };
    }
    fn block_2185<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2185_0: const #0u : u8
        let s_2185_0: bool = false;
        // D s_2185_1: write-var gs#407641 <= s_2185_0
        fn_state.gs_407641 = s_2185_0;
        // N s_2185_2: jump b2186
        return block_2186(state, tracer, fn_state);
    }
    fn block_2186<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2186_0: read-var gs#407641:u8
        let s_2186_0: bool = fn_state.gs_407641;
        // D s_2186_1: write-var gs#407642 <= s_2186_0
        fn_state.gs_407642 = s_2186_0;
        // N s_2186_2: jump b1493
        return block_1493(state, tracer, fn_state);
    }
    fn block_2187<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2187_0: const #3780s : i
        let s_2187_0: i128 = 3780;
        // C s_2187_1: const #14696u : u32
        let s_2187_1: u32 = 14696;
        // D s_2187_2: read-reg s_2187_1:i
        let s_2187_2: i128 = {
            let value = state.read_register::<i128>(s_2187_1 as isize);
            tracer.read_register(s_2187_1 as isize, value);
            value
        };
        // D s_2187_3: cmp-lt s_2187_2 s_2187_0
        let s_2187_3: bool = ((s_2187_2) < (s_2187_0));
        // D s_2187_4: write-var gs#407641 <= s_2187_3
        fn_state.gs_407641 = s_2187_3;
        // N s_2187_5: jump b2186
        return block_2186(state, tracer, fn_state);
    }
    fn block_2188<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2188_0: const #20s : i
        let s_2188_0: i128 = 20;
        // D s_2188_1: read-var u#33152:u32
        let s_2188_1: u32 = fn_state.u_33152;
        // D s_2188_2: cast zx s_2188_1 -> bv
        let s_2188_2: Bits = Bits::new(s_2188_1 as u128, 32u16);
        // C s_2188_3: const #1s : i64
        let s_2188_3: i64 = 1;
        // C s_2188_4: cast zx s_2188_3 -> i
        let s_2188_4: i128 = (i128::try_from(s_2188_3).unwrap());
        // C s_2188_5: const #1s : i
        let s_2188_5: i128 = 1;
        // C s_2188_6: add s_2188_5 s_2188_4
        let s_2188_6: i128 = (s_2188_5 + s_2188_4);
        // D s_2188_7: bit-extract s_2188_2 s_2188_0 s_2188_6
        let s_2188_7: Bits = (Bits::new(
            ((s_2188_2) >> (s_2188_0)).value(),
            u16::try_from(s_2188_6).unwrap(),
        ));
        // D s_2188_8: cast reint s_2188_7 -> u8
        let s_2188_8: u8 = (s_2188_7.value() as u8);
        // D s_2188_9: cast zx s_2188_8 -> bv
        let s_2188_9: Bits = Bits::new(s_2188_8 as u128, 2u16);
        // C s_2188_10: const #0u : u8
        let s_2188_10: u8 = 0;
        // C s_2188_11: cast zx s_2188_10 -> bv
        let s_2188_11: Bits = Bits::new(s_2188_10 as u128, 2u16);
        // D s_2188_12: cmp-eq s_2188_9 s_2188_11
        let s_2188_12: bool = ((s_2188_9) == (s_2188_11));
        // N s_2188_13: branch s_2188_12 b2191 b2189
        if s_2188_12 {
            return block_2191(state, tracer, fn_state);
        } else {
            return block_2189(state, tracer, fn_state);
        };
    }
    fn block_2189<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2189_0: const #0u : u8
        let s_2189_0: bool = false;
        // D s_2189_1: write-var gs#407636 <= s_2189_0
        fn_state.gs_407636 = s_2189_0;
        // N s_2189_2: jump b2190
        return block_2190(state, tracer, fn_state);
    }
    fn block_2190<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2190_0: read-var gs#407636:u8
        let s_2190_0: bool = fn_state.gs_407636;
        // D s_2190_1: write-var gs#407637 <= s_2190_0
        fn_state.gs_407637 = s_2190_0;
        // N s_2190_2: jump b1491
        return block_1491(state, tracer, fn_state);
    }
    fn block_2191<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2191_0: const #9s : i
        let s_2191_0: i128 = 9;
        // D s_2191_1: read-var u#33152:u32
        let s_2191_1: u32 = fn_state.u_33152;
        // D s_2191_2: cast zx s_2191_1 -> bv
        let s_2191_2: Bits = Bits::new(s_2191_1 as u128, 32u16);
        // C s_2191_3: const #1s : i64
        let s_2191_3: i64 = 1;
        // C s_2191_4: cast zx s_2191_3 -> i
        let s_2191_4: i128 = (i128::try_from(s_2191_3).unwrap());
        // C s_2191_5: const #2s : i
        let s_2191_5: i128 = 2;
        // C s_2191_6: add s_2191_5 s_2191_4
        let s_2191_6: i128 = (s_2191_5 + s_2191_4);
        // D s_2191_7: bit-extract s_2191_2 s_2191_0 s_2191_6
        let s_2191_7: Bits = (Bits::new(
            ((s_2191_2) >> (s_2191_0)).value(),
            u16::try_from(s_2191_6).unwrap(),
        ));
        // D s_2191_8: cast reint s_2191_7 -> u8
        let s_2191_8: u8 = (s_2191_7.value() as u8);
        // D s_2191_9: cast zx s_2191_8 -> bv
        let s_2191_9: Bits = Bits::new(s_2191_8 as u128, 3u16);
        // C s_2191_10: const #1u : u8
        let s_2191_10: u8 = 1;
        // C s_2191_11: cast zx s_2191_10 -> bv
        let s_2191_11: Bits = Bits::new(s_2191_10 as u128, 3u16);
        // D s_2191_12: cmp-eq s_2191_9 s_2191_11
        let s_2191_12: bool = ((s_2191_9) == (s_2191_11));
        // N s_2191_13: branch s_2191_12 b2194 b2192
        if s_2191_12 {
            return block_2194(state, tracer, fn_state);
        } else {
            return block_2192(state, tracer, fn_state);
        };
    }
    fn block_2192<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2192_0: const #0u : u8
        let s_2192_0: bool = false;
        // D s_2192_1: write-var gs#407635 <= s_2192_0
        fn_state.gs_407635 = s_2192_0;
        // N s_2192_2: jump b2193
        return block_2193(state, tracer, fn_state);
    }
    fn block_2193<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2193_0: read-var gs#407635:u8
        let s_2193_0: bool = fn_state.gs_407635;
        // D s_2193_1: write-var gs#407636 <= s_2193_0
        fn_state.gs_407636 = s_2193_0;
        // N s_2193_2: jump b2190
        return block_2190(state, tracer, fn_state);
    }
    fn block_2194<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2194_0: const #0s : i
        let s_2194_0: i128 = 0;
        // D s_2194_1: read-var u#33152:u32
        let s_2194_1: u32 = fn_state.u_33152;
        // D s_2194_2: cast zx s_2194_1 -> bv
        let s_2194_2: Bits = Bits::new(s_2194_1 as u128, 32u16);
        // C s_2194_3: const #1s : i64
        let s_2194_3: i64 = 1;
        // C s_2194_4: cast zx s_2194_3 -> i
        let s_2194_4: i128 = (i128::try_from(s_2194_3).unwrap());
        // C s_2194_5: const #7s : i
        let s_2194_5: i128 = 7;
        // C s_2194_6: add s_2194_5 s_2194_4
        let s_2194_6: i128 = (s_2194_5 + s_2194_4);
        // D s_2194_7: bit-extract s_2194_2 s_2194_0 s_2194_6
        let s_2194_7: Bits = (Bits::new(
            ((s_2194_2) >> (s_2194_0)).value(),
            u16::try_from(s_2194_6).unwrap(),
        ));
        // D s_2194_8: cast reint s_2194_7 -> u8
        let s_2194_8: u8 = (s_2194_7.value() as u8);
        // D s_2194_9: cast zx s_2194_8 -> bv
        let s_2194_9: Bits = Bits::new(s_2194_8 as u128, 8u16);
        // C s_2194_10: const #0u : u8
        let s_2194_10: u8 = 0;
        // C s_2194_11: cast zx s_2194_10 -> bv
        let s_2194_11: Bits = Bits::new(s_2194_10 as u128, 8u16);
        // D s_2194_12: cmp-eq s_2194_9 s_2194_11
        let s_2194_12: bool = ((s_2194_9) == (s_2194_11));
        // D s_2194_13: write-var gs#407635 <= s_2194_12
        fn_state.gs_407635 = s_2194_12;
        // N s_2194_14: jump b2193
        return block_2193(state, tracer, fn_state);
    }
    fn block_2195<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2195_0: const #28s : i
        let s_2195_0: i128 = 28;
        // C s_2195_1: const #4s : i
        let s_2195_1: i128 = 4;
        // D s_2195_2: read-var u#33148:u32
        let s_2195_2: u32 = fn_state.u_33148;
        // D s_2195_3: cast zx s_2195_2 -> bv
        let s_2195_3: Bits = Bits::new(s_2195_2 as u128, 32u16);
        // D s_2195_4: bit-extract s_2195_3 s_2195_0 s_2195_1
        let s_2195_4: Bits = (Bits::new(
            ((s_2195_3) >> (s_2195_0)).value(),
            u16::try_from(s_2195_1).unwrap(),
        ));
        // D s_2195_5: cast reint s_2195_4 -> u8
        let s_2195_5: u8 = (s_2195_4.value() as u8);
        // D s_2195_6: cast zx s_2195_5 -> bv
        let s_2195_6: Bits = Bits::new(s_2195_5 as u128, 4u16);
        // C s_2195_7: const #15u : u8
        let s_2195_7: u8 = 15;
        // C s_2195_8: cast zx s_2195_7 -> bv
        let s_2195_8: Bits = Bits::new(s_2195_7 as u128, 4u16);
        // D s_2195_9: cmp-ne s_2195_6 s_2195_8
        let s_2195_9: bool = ((s_2195_6) != (s_2195_8));
        // N s_2195_10: branch s_2195_9 b2198 b2196
        if s_2195_9 {
            return block_2198(state, tracer, fn_state);
        } else {
            return block_2196(state, tracer, fn_state);
        };
    }
    fn block_2196<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2196_0: const #0u : u8
        let s_2196_0: bool = false;
        // D s_2196_1: write-var gs#407584 <= s_2196_0
        fn_state.gs_407584 = s_2196_0;
        // N s_2196_2: jump b2197
        return block_2197(state, tracer, fn_state);
    }
    fn block_2197<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2197_0: read-var gs#407584:u8
        let s_2197_0: bool = fn_state.gs_407584;
        // D s_2197_1: write-var gs#407585 <= s_2197_0
        fn_state.gs_407585 = s_2197_0;
        // N s_2197_2: jump b1455
        return block_1455(state, tracer, fn_state);
    }
    fn block_2198<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2198_0: const #3778s : i
        let s_2198_0: i128 = 3778;
        // C s_2198_1: const #14696u : u32
        let s_2198_1: u32 = 14696;
        // D s_2198_2: read-reg s_2198_1:i
        let s_2198_2: i128 = {
            let value = state.read_register::<i128>(s_2198_1 as isize);
            tracer.read_register(s_2198_1 as isize, value);
            value
        };
        // D s_2198_3: cmp-lt s_2198_2 s_2198_0
        let s_2198_3: bool = ((s_2198_2) < (s_2198_0));
        // D s_2198_4: write-var gs#407584 <= s_2198_3
        fn_state.gs_407584 = s_2198_3;
        // N s_2198_5: jump b2197
        return block_2197(state, tracer, fn_state);
    }
    fn block_2199<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2199_0: const #16s : i
        let s_2199_0: i128 = 16;
        // D s_2199_1: read-var u#33148:u32
        let s_2199_1: u32 = fn_state.u_33148;
        // D s_2199_2: cast zx s_2199_1 -> bv
        let s_2199_2: Bits = Bits::new(s_2199_1 as u128, 32u16);
        // C s_2199_3: const #1s : i64
        let s_2199_3: i64 = 1;
        // C s_2199_4: cast zx s_2199_3 -> i
        let s_2199_4: i128 = (i128::try_from(s_2199_3).unwrap());
        // C s_2199_5: const #5s : i
        let s_2199_5: i128 = 5;
        // C s_2199_6: add s_2199_5 s_2199_4
        let s_2199_6: i128 = (s_2199_5 + s_2199_4);
        // D s_2199_7: bit-extract s_2199_2 s_2199_0 s_2199_6
        let s_2199_7: Bits = (Bits::new(
            ((s_2199_2) >> (s_2199_0)).value(),
            u16::try_from(s_2199_6).unwrap(),
        ));
        // D s_2199_8: cast reint s_2199_7 -> u8
        let s_2199_8: u8 = (s_2199_7.value() as u8);
        // D s_2199_9: cast zx s_2199_8 -> bv
        let s_2199_9: Bits = Bits::new(s_2199_8 as u128, 6u16);
        // C s_2199_10: const #15u : u8
        let s_2199_10: u8 = 15;
        // C s_2199_11: cast zx s_2199_10 -> bv
        let s_2199_11: Bits = Bits::new(s_2199_10 as u128, 6u16);
        // D s_2199_12: cmp-eq s_2199_9 s_2199_11
        let s_2199_12: bool = ((s_2199_9) == (s_2199_11));
        // N s_2199_13: branch s_2199_12 b2202 b2200
        if s_2199_12 {
            return block_2202(state, tracer, fn_state);
        } else {
            return block_2200(state, tracer, fn_state);
        };
    }
    fn block_2200<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2200_0: const #0u : u8
        let s_2200_0: bool = false;
        // D s_2200_1: write-var gs#407579 <= s_2200_0
        fn_state.gs_407579 = s_2200_0;
        // N s_2200_2: jump b2201
        return block_2201(state, tracer, fn_state);
    }
    fn block_2201<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2201_0: read-var gs#407579:u8
        let s_2201_0: bool = fn_state.gs_407579;
        // D s_2201_1: write-var gs#407580 <= s_2201_0
        fn_state.gs_407580 = s_2201_0;
        // N s_2201_2: jump b1453
        return block_1453(state, tracer, fn_state);
    }
    fn block_2202<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2202_0: const #0s : i
        let s_2202_0: i128 = 0;
        // D s_2202_1: read-var u#33148:u32
        let s_2202_1: u32 = fn_state.u_33148;
        // D s_2202_2: cast zx s_2202_1 -> bv
        let s_2202_2: Bits = Bits::new(s_2202_1 as u128, 32u16);
        // C s_2202_3: const #1s : i64
        let s_2202_3: i64 = 1;
        // C s_2202_4: cast zx s_2202_3 -> i
        let s_2202_4: i128 = (i128::try_from(s_2202_3).unwrap());
        // C s_2202_5: const #11s : i
        let s_2202_5: i128 = 11;
        // C s_2202_6: add s_2202_5 s_2202_4
        let s_2202_6: i128 = (s_2202_5 + s_2202_4);
        // D s_2202_7: bit-extract s_2202_2 s_2202_0 s_2202_6
        let s_2202_7: Bits = (Bits::new(
            ((s_2202_2) >> (s_2202_0)).value(),
            u16::try_from(s_2202_6).unwrap(),
        ));
        // D s_2202_8: cast reint s_2202_7 -> u12
        let s_2202_8: u16 = (s_2202_7.value() as u16);
        // D s_2202_9: cast zx s_2202_8 -> bv
        let s_2202_9: Bits = Bits::new(s_2202_8 as u128, 12u16);
        // C s_2202_10: const #0u : u12
        let s_2202_10: u16 = 0;
        // C s_2202_11: cast zx s_2202_10 -> bv
        let s_2202_11: Bits = Bits::new(s_2202_10 as u128, 12u16);
        // D s_2202_12: cmp-eq s_2202_9 s_2202_11
        let s_2202_12: bool = ((s_2202_9) == (s_2202_11));
        // D s_2202_13: write-var gs#407579 <= s_2202_12
        fn_state.gs_407579 = s_2202_12;
        // N s_2202_14: jump b2201
        return block_2201(state, tracer, fn_state);
    }
    fn block_2203<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2203_0: const #28s : i
        let s_2203_0: i128 = 28;
        // C s_2203_1: const #4s : i
        let s_2203_1: i128 = 4;
        // D s_2203_2: read-var u#33143:u32
        let s_2203_2: u32 = fn_state.u_33143;
        // D s_2203_3: cast zx s_2203_2 -> bv
        let s_2203_3: Bits = Bits::new(s_2203_2 as u128, 32u16);
        // D s_2203_4: bit-extract s_2203_3 s_2203_0 s_2203_1
        let s_2203_4: Bits = (Bits::new(
            ((s_2203_3) >> (s_2203_0)).value(),
            u16::try_from(s_2203_1).unwrap(),
        ));
        // D s_2203_5: cast reint s_2203_4 -> u8
        let s_2203_5: u8 = (s_2203_4.value() as u8);
        // D s_2203_6: cast zx s_2203_5 -> bv
        let s_2203_6: Bits = Bits::new(s_2203_5 as u128, 4u16);
        // C s_2203_7: const #15u : u8
        let s_2203_7: u8 = 15;
        // C s_2203_8: cast zx s_2203_7 -> bv
        let s_2203_8: Bits = Bits::new(s_2203_7 as u128, 4u16);
        // D s_2203_9: cmp-ne s_2203_6 s_2203_8
        let s_2203_9: bool = ((s_2203_6) != (s_2203_8));
        // N s_2203_10: branch s_2203_9 b2206 b2204
        if s_2203_9 {
            return block_2206(state, tracer, fn_state);
        } else {
            return block_2204(state, tracer, fn_state);
        };
    }
    fn block_2204<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2204_0: const #0u : u8
        let s_2204_0: bool = false;
        // D s_2204_1: write-var gs#407562 <= s_2204_0
        fn_state.gs_407562 = s_2204_0;
        // N s_2204_2: jump b2205
        return block_2205(state, tracer, fn_state);
    }
    fn block_2205<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2205_0: read-var gs#407562:u8
        let s_2205_0: bool = fn_state.gs_407562;
        // D s_2205_1: write-var gs#407563 <= s_2205_0
        fn_state.gs_407563 = s_2205_0;
        // N s_2205_2: jump b1449
        return block_1449(state, tracer, fn_state);
    }
    fn block_2206<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2206_0: const #3774s : i
        let s_2206_0: i128 = 3774;
        // C s_2206_1: const #14696u : u32
        let s_2206_1: u32 = 14696;
        // D s_2206_2: read-reg s_2206_1:i
        let s_2206_2: i128 = {
            let value = state.read_register::<i128>(s_2206_1 as isize);
            tracer.read_register(s_2206_1 as isize, value);
            value
        };
        // D s_2206_3: cmp-lt s_2206_2 s_2206_0
        let s_2206_3: bool = ((s_2206_2) < (s_2206_0));
        // D s_2206_4: write-var gs#407562 <= s_2206_3
        fn_state.gs_407562 = s_2206_3;
        // N s_2206_5: jump b2205
        return block_2205(state, tracer, fn_state);
    }
    fn block_2207<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2207_0: const #4s : i
        let s_2207_0: i128 = 4;
        // D s_2207_1: read-var u#33143:u32
        let s_2207_1: u32 = fn_state.u_33143;
        // D s_2207_2: cast zx s_2207_1 -> bv
        let s_2207_2: Bits = Bits::new(s_2207_1 as u128, 32u16);
        // C s_2207_3: const #1s : i64
        let s_2207_3: i64 = 1;
        // C s_2207_4: cast zx s_2207_3 -> i
        let s_2207_4: i128 = (i128::try_from(s_2207_3).unwrap());
        // C s_2207_5: const #3s : i
        let s_2207_5: i128 = 3;
        // C s_2207_6: add s_2207_5 s_2207_4
        let s_2207_6: i128 = (s_2207_5 + s_2207_4);
        // D s_2207_7: bit-extract s_2207_2 s_2207_0 s_2207_6
        let s_2207_7: Bits = (Bits::new(
            ((s_2207_2) >> (s_2207_0)).value(),
            u16::try_from(s_2207_6).unwrap(),
        ));
        // D s_2207_8: cast reint s_2207_7 -> u8
        let s_2207_8: u8 = (s_2207_7.value() as u8);
        // D s_2207_9: cast zx s_2207_8 -> bv
        let s_2207_9: Bits = Bits::new(s_2207_8 as u128, 4u16);
        // C s_2207_10: const #7u : u8
        let s_2207_10: u8 = 7;
        // C s_2207_11: cast zx s_2207_10 -> bv
        let s_2207_11: Bits = Bits::new(s_2207_10 as u128, 4u16);
        // D s_2207_12: cmp-eq s_2207_9 s_2207_11
        let s_2207_12: bool = ((s_2207_9) == (s_2207_11));
        // D s_2207_13: write-var gs#407558 <= s_2207_12
        fn_state.gs_407558 = s_2207_12;
        // N s_2207_14: jump b1447
        return block_1447(state, tracer, fn_state);
    }
    fn block_2208<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2208_0: const #28s : i
        let s_2208_0: i128 = 28;
        // C s_2208_1: const #4s : i
        let s_2208_1: i128 = 4;
        // D s_2208_2: read-var u#33140:u32
        let s_2208_2: u32 = fn_state.u_33140;
        // D s_2208_3: cast zx s_2208_2 -> bv
        let s_2208_3: Bits = Bits::new(s_2208_2 as u128, 32u16);
        // D s_2208_4: bit-extract s_2208_3 s_2208_0 s_2208_1
        let s_2208_4: Bits = (Bits::new(
            ((s_2208_3) >> (s_2208_0)).value(),
            u16::try_from(s_2208_1).unwrap(),
        ));
        // D s_2208_5: cast reint s_2208_4 -> u8
        let s_2208_5: u8 = (s_2208_4.value() as u8);
        // D s_2208_6: cast zx s_2208_5 -> bv
        let s_2208_6: Bits = Bits::new(s_2208_5 as u128, 4u16);
        // C s_2208_7: const #15u : u8
        let s_2208_7: u8 = 15;
        // C s_2208_8: cast zx s_2208_7 -> bv
        let s_2208_8: Bits = Bits::new(s_2208_7 as u128, 4u16);
        // D s_2208_9: cmp-ne s_2208_6 s_2208_8
        let s_2208_9: bool = ((s_2208_6) != (s_2208_8));
        // N s_2208_10: branch s_2208_9 b2211 b2209
        if s_2208_9 {
            return block_2211(state, tracer, fn_state);
        } else {
            return block_2209(state, tracer, fn_state);
        };
    }
    fn block_2209<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2209_0: const #0u : u8
        let s_2209_0: bool = false;
        // D s_2209_1: write-var gs#407500 <= s_2209_0
        fn_state.gs_407500 = s_2209_0;
        // N s_2209_2: jump b2210
        return block_2210(state, tracer, fn_state);
    }
    fn block_2210<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2210_0: read-var gs#407500:u8
        let s_2210_0: bool = fn_state.gs_407500;
        // D s_2210_1: write-var gs#407501 <= s_2210_0
        fn_state.gs_407501 = s_2210_0;
        // N s_2210_2: jump b1396
        return block_1396(state, tracer, fn_state);
    }
    fn block_2211<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2211_0: const #3772s : i
        let s_2211_0: i128 = 3772;
        // C s_2211_1: const #14696u : u32
        let s_2211_1: u32 = 14696;
        // D s_2211_2: read-reg s_2211_1:i
        let s_2211_2: i128 = {
            let value = state.read_register::<i128>(s_2211_1 as isize);
            tracer.read_register(s_2211_1 as isize, value);
            value
        };
        // D s_2211_3: cmp-lt s_2211_2 s_2211_0
        let s_2211_3: bool = ((s_2211_2) < (s_2211_0));
        // D s_2211_4: write-var gs#407500 <= s_2211_3
        fn_state.gs_407500 = s_2211_3;
        // N s_2211_5: jump b2210
        return block_2210(state, tracer, fn_state);
    }
    fn block_2212<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2212_0: const #28s : i
        let s_2212_0: i128 = 28;
        // C s_2212_1: const #4s : i
        let s_2212_1: i128 = 4;
        // D s_2212_2: read-var u#33137:u32
        let s_2212_2: u32 = fn_state.u_33137;
        // D s_2212_3: cast zx s_2212_2 -> bv
        let s_2212_3: Bits = Bits::new(s_2212_2 as u128, 32u16);
        // D s_2212_4: bit-extract s_2212_3 s_2212_0 s_2212_1
        let s_2212_4: Bits = (Bits::new(
            ((s_2212_3) >> (s_2212_0)).value(),
            u16::try_from(s_2212_1).unwrap(),
        ));
        // D s_2212_5: cast reint s_2212_4 -> u8
        let s_2212_5: u8 = (s_2212_4.value() as u8);
        // D s_2212_6: cast zx s_2212_5 -> bv
        let s_2212_6: Bits = Bits::new(s_2212_5 as u128, 4u16);
        // C s_2212_7: const #15u : u8
        let s_2212_7: u8 = 15;
        // C s_2212_8: cast zx s_2212_7 -> bv
        let s_2212_8: Bits = Bits::new(s_2212_7 as u128, 4u16);
        // D s_2212_9: cmp-ne s_2212_6 s_2212_8
        let s_2212_9: bool = ((s_2212_6) != (s_2212_8));
        // N s_2212_10: branch s_2212_9 b2215 b2213
        if s_2212_9 {
            return block_2215(state, tracer, fn_state);
        } else {
            return block_2213(state, tracer, fn_state);
        };
    }
    fn block_2213<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2213_0: const #0u : u8
        let s_2213_0: bool = false;
        // D s_2213_1: write-var gs#407465 <= s_2213_0
        fn_state.gs_407465 = s_2213_0;
        // N s_2213_2: jump b2214
        return block_2214(state, tracer, fn_state);
    }
    fn block_2214<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2214_0: read-var gs#407465:u8
        let s_2214_0: bool = fn_state.gs_407465;
        // D s_2214_1: write-var gs#407466 <= s_2214_0
        fn_state.gs_407466 = s_2214_0;
        // N s_2214_2: jump b1369
        return block_1369(state, tracer, fn_state);
    }
    fn block_2215<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2215_0: const #3766s : i
        let s_2215_0: i128 = 3766;
        // C s_2215_1: const #14696u : u32
        let s_2215_1: u32 = 14696;
        // D s_2215_2: read-reg s_2215_1:i
        let s_2215_2: i128 = {
            let value = state.read_register::<i128>(s_2215_1 as isize);
            tracer.read_register(s_2215_1 as isize, value);
            value
        };
        // D s_2215_3: cmp-lt s_2215_2 s_2215_0
        let s_2215_3: bool = ((s_2215_2) < (s_2215_0));
        // D s_2215_4: write-var gs#407465 <= s_2215_3
        fn_state.gs_407465 = s_2215_3;
        // N s_2215_5: jump b2214
        return block_2214(state, tracer, fn_state);
    }
    fn block_2216<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2216_0: const #28s : i
        let s_2216_0: i128 = 28;
        // C s_2216_1: const #4s : i
        let s_2216_1: i128 = 4;
        // D s_2216_2: read-var u#33134:u32
        let s_2216_2: u32 = fn_state.u_33134;
        // D s_2216_3: cast zx s_2216_2 -> bv
        let s_2216_3: Bits = Bits::new(s_2216_2 as u128, 32u16);
        // D s_2216_4: bit-extract s_2216_3 s_2216_0 s_2216_1
        let s_2216_4: Bits = (Bits::new(
            ((s_2216_3) >> (s_2216_0)).value(),
            u16::try_from(s_2216_1).unwrap(),
        ));
        // D s_2216_5: cast reint s_2216_4 -> u8
        let s_2216_5: u8 = (s_2216_4.value() as u8);
        // D s_2216_6: cast zx s_2216_5 -> bv
        let s_2216_6: Bits = Bits::new(s_2216_5 as u128, 4u16);
        // C s_2216_7: const #15u : u8
        let s_2216_7: u8 = 15;
        // C s_2216_8: cast zx s_2216_7 -> bv
        let s_2216_8: Bits = Bits::new(s_2216_7 as u128, 4u16);
        // D s_2216_9: cmp-ne s_2216_6 s_2216_8
        let s_2216_9: bool = ((s_2216_6) != (s_2216_8));
        // N s_2216_10: branch s_2216_9 b2219 b2217
        if s_2216_9 {
            return block_2219(state, tracer, fn_state);
        } else {
            return block_2217(state, tracer, fn_state);
        };
    }
    fn block_2217<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2217_0: const #0u : u8
        let s_2217_0: bool = false;
        // D s_2217_1: write-var gs#407430 <= s_2217_0
        fn_state.gs_407430 = s_2217_0;
        // N s_2217_2: jump b2218
        return block_2218(state, tracer, fn_state);
    }
    fn block_2218<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2218_0: read-var gs#407430:u8
        let s_2218_0: bool = fn_state.gs_407430;
        // D s_2218_1: write-var gs#407431 <= s_2218_0
        fn_state.gs_407431 = s_2218_0;
        // N s_2218_2: jump b1342
        return block_1342(state, tracer, fn_state);
    }
    fn block_2219<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2219_0: const #3763s : i
        let s_2219_0: i128 = 3763;
        // C s_2219_1: const #14696u : u32
        let s_2219_1: u32 = 14696;
        // D s_2219_2: read-reg s_2219_1:i
        let s_2219_2: i128 = {
            let value = state.read_register::<i128>(s_2219_1 as isize);
            tracer.read_register(s_2219_1 as isize, value);
            value
        };
        // D s_2219_3: cmp-lt s_2219_2 s_2219_0
        let s_2219_3: bool = ((s_2219_2) < (s_2219_0));
        // D s_2219_4: write-var gs#407430 <= s_2219_3
        fn_state.gs_407430 = s_2219_3;
        // N s_2219_5: jump b2218
        return block_2218(state, tracer, fn_state);
    }
    fn block_2220<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2220_0: const #28s : i
        let s_2220_0: i128 = 28;
        // C s_2220_1: const #4s : i
        let s_2220_1: i128 = 4;
        // D s_2220_2: read-var u#33131:u32
        let s_2220_2: u32 = fn_state.u_33131;
        // D s_2220_3: cast zx s_2220_2 -> bv
        let s_2220_3: Bits = Bits::new(s_2220_2 as u128, 32u16);
        // D s_2220_4: bit-extract s_2220_3 s_2220_0 s_2220_1
        let s_2220_4: Bits = (Bits::new(
            ((s_2220_3) >> (s_2220_0)).value(),
            u16::try_from(s_2220_1).unwrap(),
        ));
        // D s_2220_5: cast reint s_2220_4 -> u8
        let s_2220_5: u8 = (s_2220_4.value() as u8);
        // D s_2220_6: cast zx s_2220_5 -> bv
        let s_2220_6: Bits = Bits::new(s_2220_5 as u128, 4u16);
        // C s_2220_7: const #15u : u8
        let s_2220_7: u8 = 15;
        // C s_2220_8: cast zx s_2220_7 -> bv
        let s_2220_8: Bits = Bits::new(s_2220_7 as u128, 4u16);
        // D s_2220_9: cmp-ne s_2220_6 s_2220_8
        let s_2220_9: bool = ((s_2220_6) != (s_2220_8));
        // N s_2220_10: branch s_2220_9 b2223 b2221
        if s_2220_9 {
            return block_2223(state, tracer, fn_state);
        } else {
            return block_2221(state, tracer, fn_state);
        };
    }
    fn block_2221<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2221_0: const #0u : u8
        let s_2221_0: bool = false;
        // D s_2221_1: write-var gs#407395 <= s_2221_0
        fn_state.gs_407395 = s_2221_0;
        // N s_2221_2: jump b2222
        return block_2222(state, tracer, fn_state);
    }
    fn block_2222<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2222_0: read-var gs#407395:u8
        let s_2222_0: bool = fn_state.gs_407395;
        // D s_2222_1: write-var gs#407396 <= s_2222_0
        fn_state.gs_407396 = s_2222_0;
        // N s_2222_2: jump b1315
        return block_1315(state, tracer, fn_state);
    }
    fn block_2223<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2223_0: const #3760s : i
        let s_2223_0: i128 = 3760;
        // C s_2223_1: const #14696u : u32
        let s_2223_1: u32 = 14696;
        // D s_2223_2: read-reg s_2223_1:i
        let s_2223_2: i128 = {
            let value = state.read_register::<i128>(s_2223_1 as isize);
            tracer.read_register(s_2223_1 as isize, value);
            value
        };
        // D s_2223_3: cmp-lt s_2223_2 s_2223_0
        let s_2223_3: bool = ((s_2223_2) < (s_2223_0));
        // D s_2223_4: write-var gs#407395 <= s_2223_3
        fn_state.gs_407395 = s_2223_3;
        // N s_2223_5: jump b2222
        return block_2222(state, tracer, fn_state);
    }
    fn block_2224<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2224_0: const #28s : i
        let s_2224_0: i128 = 28;
        // C s_2224_1: const #4s : i
        let s_2224_1: i128 = 4;
        // D s_2224_2: read-var u#33123:u32
        let s_2224_2: u32 = fn_state.u_33123;
        // D s_2224_3: cast zx s_2224_2 -> bv
        let s_2224_3: Bits = Bits::new(s_2224_2 as u128, 32u16);
        // D s_2224_4: bit-extract s_2224_3 s_2224_0 s_2224_1
        let s_2224_4: Bits = (Bits::new(
            ((s_2224_3) >> (s_2224_0)).value(),
            u16::try_from(s_2224_1).unwrap(),
        ));
        // D s_2224_5: cast reint s_2224_4 -> u8
        let s_2224_5: u8 = (s_2224_4.value() as u8);
        // D s_2224_6: cast zx s_2224_5 -> bv
        let s_2224_6: Bits = Bits::new(s_2224_5 as u128, 4u16);
        // C s_2224_7: const #15u : u8
        let s_2224_7: u8 = 15;
        // C s_2224_8: cast zx s_2224_7 -> bv
        let s_2224_8: Bits = Bits::new(s_2224_7 as u128, 4u16);
        // D s_2224_9: cmp-ne s_2224_6 s_2224_8
        let s_2224_9: bool = ((s_2224_6) != (s_2224_8));
        // N s_2224_10: branch s_2224_9 b2227 b2225
        if s_2224_9 {
            return block_2227(state, tracer, fn_state);
        } else {
            return block_2225(state, tracer, fn_state);
        };
    }
    fn block_2225<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2225_0: const #0u : u8
        let s_2225_0: bool = false;
        // D s_2225_1: write-var gs#407373 <= s_2225_0
        fn_state.gs_407373 = s_2225_0;
        // N s_2225_2: jump b2226
        return block_2226(state, tracer, fn_state);
    }
    fn block_2226<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2226_0: read-var gs#407373:u8
        let s_2226_0: bool = fn_state.gs_407373;
        // D s_2226_1: write-var gs#407374 <= s_2226_0
        fn_state.gs_407374 = s_2226_0;
        // N s_2226_2: jump b1311
        return block_1311(state, tracer, fn_state);
    }
    fn block_2227<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2227_0: const #3308s : i
        let s_2227_0: i128 = 3308;
        // C s_2227_1: const #14696u : u32
        let s_2227_1: u32 = 14696;
        // D s_2227_2: read-reg s_2227_1:i
        let s_2227_2: i128 = {
            let value = state.read_register::<i128>(s_2227_1 as isize);
            tracer.read_register(s_2227_1 as isize, value);
            value
        };
        // D s_2227_3: cmp-lt s_2227_2 s_2227_0
        let s_2227_3: bool = ((s_2227_2) < (s_2227_0));
        // D s_2227_4: write-var gs#407373 <= s_2227_3
        fn_state.gs_407373 = s_2227_3;
        // N s_2227_5: jump b2226
        return block_2226(state, tracer, fn_state);
    }
    fn block_2228<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2228_0: const #4s : i
        let s_2228_0: i128 = 4;
        // D s_2228_1: read-var u#33123:u32
        let s_2228_1: u32 = fn_state.u_33123;
        // D s_2228_2: cast zx s_2228_1 -> bv
        let s_2228_2: Bits = Bits::new(s_2228_1 as u128, 32u16);
        // C s_2228_3: const #1s : i64
        let s_2228_3: i64 = 1;
        // C s_2228_4: cast zx s_2228_3 -> i
        let s_2228_4: i128 = (i128::try_from(s_2228_3).unwrap());
        // C s_2228_5: const #3s : i
        let s_2228_5: i128 = 3;
        // C s_2228_6: add s_2228_5 s_2228_4
        let s_2228_6: i128 = (s_2228_5 + s_2228_4);
        // D s_2228_7: bit-extract s_2228_2 s_2228_0 s_2228_6
        let s_2228_7: Bits = (Bits::new(
            ((s_2228_2) >> (s_2228_0)).value(),
            u16::try_from(s_2228_6).unwrap(),
        ));
        // D s_2228_8: cast reint s_2228_7 -> u8
        let s_2228_8: u8 = (s_2228_7.value() as u8);
        // D s_2228_9: cast zx s_2228_8 -> bv
        let s_2228_9: Bits = Bits::new(s_2228_8 as u128, 4u16);
        // C s_2228_10: const #9u : u8
        let s_2228_10: u8 = 9;
        // C s_2228_11: cast zx s_2228_10 -> bv
        let s_2228_11: Bits = Bits::new(s_2228_10 as u128, 4u16);
        // D s_2228_12: cmp-eq s_2228_9 s_2228_11
        let s_2228_12: bool = ((s_2228_9) == (s_2228_11));
        // D s_2228_13: write-var gs#407369 <= s_2228_12
        fn_state.gs_407369 = s_2228_12;
        // N s_2228_14: jump b1309
        return block_1309(state, tracer, fn_state);
    }
    fn block_2229<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2229_0: const #28s : i
        let s_2229_0: i128 = 28;
        // C s_2229_1: const #4s : i
        let s_2229_1: i128 = 4;
        // D s_2229_2: read-var u#33115:u32
        let s_2229_2: u32 = fn_state.u_33115;
        // D s_2229_3: cast zx s_2229_2 -> bv
        let s_2229_3: Bits = Bits::new(s_2229_2 as u128, 32u16);
        // D s_2229_4: bit-extract s_2229_3 s_2229_0 s_2229_1
        let s_2229_4: Bits = (Bits::new(
            ((s_2229_3) >> (s_2229_0)).value(),
            u16::try_from(s_2229_1).unwrap(),
        ));
        // D s_2229_5: cast reint s_2229_4 -> u8
        let s_2229_5: u8 = (s_2229_4.value() as u8);
        // D s_2229_6: cast zx s_2229_5 -> bv
        let s_2229_6: Bits = Bits::new(s_2229_5 as u128, 4u16);
        // C s_2229_7: const #15u : u8
        let s_2229_7: u8 = 15;
        // C s_2229_8: cast zx s_2229_7 -> bv
        let s_2229_8: Bits = Bits::new(s_2229_7 as u128, 4u16);
        // D s_2229_9: cmp-ne s_2229_6 s_2229_8
        let s_2229_9: bool = ((s_2229_6) != (s_2229_8));
        // N s_2229_10: branch s_2229_9 b2232 b2230
        if s_2229_9 {
            return block_2232(state, tracer, fn_state);
        } else {
            return block_2230(state, tracer, fn_state);
        };
    }
    fn block_2230<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2230_0: const #0u : u8
        let s_2230_0: bool = false;
        // D s_2230_1: write-var gs#407348 <= s_2230_0
        fn_state.gs_407348 = s_2230_0;
        // N s_2230_2: jump b2231
        return block_2231(state, tracer, fn_state);
    }
    fn block_2231<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2231_0: read-var gs#407348:u8
        let s_2231_0: bool = fn_state.gs_407348;
        // D s_2231_1: write-var gs#407349 <= s_2231_0
        fn_state.gs_407349 = s_2231_0;
        // N s_2231_2: jump b1305
        return block_1305(state, tracer, fn_state);
    }
    fn block_2232<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2232_0: const #3306s : i
        let s_2232_0: i128 = 3306;
        // C s_2232_1: const #14696u : u32
        let s_2232_1: u32 = 14696;
        // D s_2232_2: read-reg s_2232_1:i
        let s_2232_2: i128 = {
            let value = state.read_register::<i128>(s_2232_1 as isize);
            tracer.read_register(s_2232_1 as isize, value);
            value
        };
        // D s_2232_3: cmp-lt s_2232_2 s_2232_0
        let s_2232_3: bool = ((s_2232_2) < (s_2232_0));
        // D s_2232_4: write-var gs#407348 <= s_2232_3
        fn_state.gs_407348 = s_2232_3;
        // N s_2232_5: jump b2231
        return block_2231(state, tracer, fn_state);
    }
    fn block_2233<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2233_0: const #4s : i
        let s_2233_0: i128 = 4;
        // D s_2233_1: read-var u#33115:u32
        let s_2233_1: u32 = fn_state.u_33115;
        // D s_2233_2: cast zx s_2233_1 -> bv
        let s_2233_2: Bits = Bits::new(s_2233_1 as u128, 32u16);
        // C s_2233_3: const #1s : i64
        let s_2233_3: i64 = 1;
        // C s_2233_4: cast zx s_2233_3 -> i
        let s_2233_4: i128 = (i128::try_from(s_2233_3).unwrap());
        // C s_2233_5: const #3s : i
        let s_2233_5: i128 = 3;
        // C s_2233_6: add s_2233_5 s_2233_4
        let s_2233_6: i128 = (s_2233_5 + s_2233_4);
        // D s_2233_7: bit-extract s_2233_2 s_2233_0 s_2233_6
        let s_2233_7: Bits = (Bits::new(
            ((s_2233_2) >> (s_2233_0)).value(),
            u16::try_from(s_2233_6).unwrap(),
        ));
        // D s_2233_8: cast reint s_2233_7 -> u8
        let s_2233_8: u8 = (s_2233_7.value() as u8);
        // D s_2233_9: cast zx s_2233_8 -> bv
        let s_2233_9: Bits = Bits::new(s_2233_8 as u128, 4u16);
        // C s_2233_10: const #9u : u8
        let s_2233_10: u8 = 9;
        // C s_2233_11: cast zx s_2233_10 -> bv
        let s_2233_11: Bits = Bits::new(s_2233_10 as u128, 4u16);
        // D s_2233_12: cmp-eq s_2233_9 s_2233_11
        let s_2233_12: bool = ((s_2233_9) == (s_2233_11));
        // D s_2233_13: write-var gs#407344 <= s_2233_12
        fn_state.gs_407344 = s_2233_12;
        // N s_2233_14: jump b1303
        return block_1303(state, tracer, fn_state);
    }
    fn block_2234<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2234_0: const #28s : i
        let s_2234_0: i128 = 28;
        // C s_2234_1: const #4s : i
        let s_2234_1: i128 = 4;
        // D s_2234_2: read-var u#33108:u32
        let s_2234_2: u32 = fn_state.u_33108;
        // D s_2234_3: cast zx s_2234_2 -> bv
        let s_2234_3: Bits = Bits::new(s_2234_2 as u128, 32u16);
        // D s_2234_4: bit-extract s_2234_3 s_2234_0 s_2234_1
        let s_2234_4: Bits = (Bits::new(
            ((s_2234_3) >> (s_2234_0)).value(),
            u16::try_from(s_2234_1).unwrap(),
        ));
        // D s_2234_5: cast reint s_2234_4 -> u8
        let s_2234_5: u8 = (s_2234_4.value() as u8);
        // D s_2234_6: cast zx s_2234_5 -> bv
        let s_2234_6: Bits = Bits::new(s_2234_5 as u128, 4u16);
        // C s_2234_7: const #15u : u8
        let s_2234_7: u8 = 15;
        // C s_2234_8: cast zx s_2234_7 -> bv
        let s_2234_8: Bits = Bits::new(s_2234_7 as u128, 4u16);
        // D s_2234_9: cmp-ne s_2234_6 s_2234_8
        let s_2234_9: bool = ((s_2234_6) != (s_2234_8));
        // N s_2234_10: branch s_2234_9 b2237 b2235
        if s_2234_9 {
            return block_2237(state, tracer, fn_state);
        } else {
            return block_2235(state, tracer, fn_state);
        };
    }
    fn block_2235<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2235_0: const #0u : u8
        let s_2235_0: bool = false;
        // D s_2235_1: write-var gs#407325 <= s_2235_0
        fn_state.gs_407325 = s_2235_0;
        // N s_2235_2: jump b2236
        return block_2236(state, tracer, fn_state);
    }
    fn block_2236<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2236_0: read-var gs#407325:u8
        let s_2236_0: bool = fn_state.gs_407325;
        // D s_2236_1: write-var gs#407326 <= s_2236_0
        fn_state.gs_407326 = s_2236_0;
        // N s_2236_2: jump b1299
        return block_1299(state, tracer, fn_state);
    }
    fn block_2237<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2237_0: const #3304s : i
        let s_2237_0: i128 = 3304;
        // C s_2237_1: const #14696u : u32
        let s_2237_1: u32 = 14696;
        // D s_2237_2: read-reg s_2237_1:i
        let s_2237_2: i128 = {
            let value = state.read_register::<i128>(s_2237_1 as isize);
            tracer.read_register(s_2237_1 as isize, value);
            value
        };
        // D s_2237_3: cmp-lt s_2237_2 s_2237_0
        let s_2237_3: bool = ((s_2237_2) < (s_2237_0));
        // D s_2237_4: write-var gs#407325 <= s_2237_3
        fn_state.gs_407325 = s_2237_3;
        // N s_2237_5: jump b2236
        return block_2236(state, tracer, fn_state);
    }
    fn block_2238<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2238_0: const #4s : i
        let s_2238_0: i128 = 4;
        // D s_2238_1: read-var u#33108:u32
        let s_2238_1: u32 = fn_state.u_33108;
        // D s_2238_2: cast zx s_2238_1 -> bv
        let s_2238_2: Bits = Bits::new(s_2238_1 as u128, 32u16);
        // C s_2238_3: const #1s : i64
        let s_2238_3: i64 = 1;
        // C s_2238_4: cast zx s_2238_3 -> i
        let s_2238_4: i128 = (i128::try_from(s_2238_3).unwrap());
        // C s_2238_5: const #3s : i
        let s_2238_5: i128 = 3;
        // C s_2238_6: add s_2238_5 s_2238_4
        let s_2238_6: i128 = (s_2238_5 + s_2238_4);
        // D s_2238_7: bit-extract s_2238_2 s_2238_0 s_2238_6
        let s_2238_7: Bits = (Bits::new(
            ((s_2238_2) >> (s_2238_0)).value(),
            u16::try_from(s_2238_6).unwrap(),
        ));
        // D s_2238_8: cast reint s_2238_7 -> u8
        let s_2238_8: u8 = (s_2238_7.value() as u8);
        // D s_2238_9: cast zx s_2238_8 -> bv
        let s_2238_9: Bits = Bits::new(s_2238_8 as u128, 4u16);
        // C s_2238_10: const #9u : u8
        let s_2238_10: u8 = 9;
        // C s_2238_11: cast zx s_2238_10 -> bv
        let s_2238_11: Bits = Bits::new(s_2238_10 as u128, 4u16);
        // D s_2238_12: cmp-eq s_2238_9 s_2238_11
        let s_2238_12: bool = ((s_2238_9) == (s_2238_11));
        // D s_2238_13: write-var gs#407321 <= s_2238_12
        fn_state.gs_407321 = s_2238_12;
        // N s_2238_14: jump b1297
        return block_1297(state, tracer, fn_state);
    }
    fn block_2239<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2239_0: const #28s : i
        let s_2239_0: i128 = 28;
        // C s_2239_1: const #4s : i
        let s_2239_1: i128 = 4;
        // D s_2239_2: read-var u#33101:u32
        let s_2239_2: u32 = fn_state.u_33101;
        // D s_2239_3: cast zx s_2239_2 -> bv
        let s_2239_3: Bits = Bits::new(s_2239_2 as u128, 32u16);
        // D s_2239_4: bit-extract s_2239_3 s_2239_0 s_2239_1
        let s_2239_4: Bits = (Bits::new(
            ((s_2239_3) >> (s_2239_0)).value(),
            u16::try_from(s_2239_1).unwrap(),
        ));
        // D s_2239_5: cast reint s_2239_4 -> u8
        let s_2239_5: u8 = (s_2239_4.value() as u8);
        // D s_2239_6: cast zx s_2239_5 -> bv
        let s_2239_6: Bits = Bits::new(s_2239_5 as u128, 4u16);
        // C s_2239_7: const #15u : u8
        let s_2239_7: u8 = 15;
        // C s_2239_8: cast zx s_2239_7 -> bv
        let s_2239_8: Bits = Bits::new(s_2239_7 as u128, 4u16);
        // D s_2239_9: cmp-ne s_2239_6 s_2239_8
        let s_2239_9: bool = ((s_2239_6) != (s_2239_8));
        // N s_2239_10: branch s_2239_9 b2242 b2240
        if s_2239_9 {
            return block_2242(state, tracer, fn_state);
        } else {
            return block_2240(state, tracer, fn_state);
        };
    }
    fn block_2240<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2240_0: const #0u : u8
        let s_2240_0: bool = false;
        // D s_2240_1: write-var gs#407291 <= s_2240_0
        fn_state.gs_407291 = s_2240_0;
        // N s_2240_2: jump b2241
        return block_2241(state, tracer, fn_state);
    }
    fn block_2241<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2241_0: read-var gs#407291:u8
        let s_2241_0: bool = fn_state.gs_407291;
        // D s_2241_1: write-var gs#407292 <= s_2241_0
        fn_state.gs_407292 = s_2241_0;
        // N s_2241_2: jump b1282
        return block_1282(state, tracer, fn_state);
    }
    fn block_2242<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2242_0: const #3278s : i
        let s_2242_0: i128 = 3278;
        // C s_2242_1: const #14696u : u32
        let s_2242_1: u32 = 14696;
        // D s_2242_2: read-reg s_2242_1:i
        let s_2242_2: i128 = {
            let value = state.read_register::<i128>(s_2242_1 as isize);
            tracer.read_register(s_2242_1 as isize, value);
            value
        };
        // D s_2242_3: cmp-lt s_2242_2 s_2242_0
        let s_2242_3: bool = ((s_2242_2) < (s_2242_0));
        // D s_2242_4: write-var gs#407291 <= s_2242_3
        fn_state.gs_407291 = s_2242_3;
        // N s_2242_5: jump b2241
        return block_2241(state, tracer, fn_state);
    }
    fn block_2243<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2243_0: const #12s : i
        let s_2243_0: i128 = 12;
        // D s_2243_1: read-var u#33101:u32
        let s_2243_1: u32 = fn_state.u_33101;
        // D s_2243_2: cast zx s_2243_1 -> bv
        let s_2243_2: Bits = Bits::new(s_2243_1 as u128, 32u16);
        // C s_2243_3: const #1s : i64
        let s_2243_3: i64 = 1;
        // C s_2243_4: cast zx s_2243_3 -> i
        let s_2243_4: i128 = (i128::try_from(s_2243_3).unwrap());
        // C s_2243_5: const #3s : i
        let s_2243_5: i128 = 3;
        // C s_2243_6: add s_2243_5 s_2243_4
        let s_2243_6: i128 = (s_2243_5 + s_2243_4);
        // D s_2243_7: bit-extract s_2243_2 s_2243_0 s_2243_6
        let s_2243_7: Bits = (Bits::new(
            ((s_2243_2) >> (s_2243_0)).value(),
            u16::try_from(s_2243_6).unwrap(),
        ));
        // D s_2243_8: cast reint s_2243_7 -> u8
        let s_2243_8: u8 = (s_2243_7.value() as u8);
        // D s_2243_9: cast zx s_2243_8 -> bv
        let s_2243_9: Bits = Bits::new(s_2243_8 as u128, 4u16);
        // C s_2243_10: const #0u : u8
        let s_2243_10: u8 = 0;
        // C s_2243_11: cast zx s_2243_10 -> bv
        let s_2243_11: Bits = Bits::new(s_2243_10 as u128, 4u16);
        // D s_2243_12: cmp-eq s_2243_9 s_2243_11
        let s_2243_12: bool = ((s_2243_9) == (s_2243_11));
        // N s_2243_13: branch s_2243_12 b2246 b2244
        if s_2243_12 {
            return block_2246(state, tracer, fn_state);
        } else {
            return block_2244(state, tracer, fn_state);
        };
    }
    fn block_2244<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2244_0: const #0u : u8
        let s_2244_0: bool = false;
        // D s_2244_1: write-var gs#407286 <= s_2244_0
        fn_state.gs_407286 = s_2244_0;
        // N s_2244_2: jump b2245
        return block_2245(state, tracer, fn_state);
    }
    fn block_2245<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2245_0: read-var gs#407286:u8
        let s_2245_0: bool = fn_state.gs_407286;
        // D s_2245_1: write-var gs#407287 <= s_2245_0
        fn_state.gs_407287 = s_2245_0;
        // N s_2245_2: jump b1280
        return block_1280(state, tracer, fn_state);
    }
    fn block_2246<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2246_0: const #7s : i
        let s_2246_0: i128 = 7;
        // D s_2246_1: read-var u#33101:u32
        let s_2246_1: u32 = fn_state.u_33101;
        // D s_2246_2: cast zx s_2246_1 -> bv
        let s_2246_2: Bits = Bits::new(s_2246_1 as u128, 32u16);
        // C s_2246_3: const #1s : i64
        let s_2246_3: i64 = 1;
        // C s_2246_4: cast zx s_2246_3 -> i
        let s_2246_4: i128 = (i128::try_from(s_2246_3).unwrap());
        // C s_2246_5: const #0s : i
        let s_2246_5: i128 = 0;
        // C s_2246_6: add s_2246_5 s_2246_4
        let s_2246_6: i128 = (s_2246_5 + s_2246_4);
        // D s_2246_7: bit-extract s_2246_2 s_2246_0 s_2246_6
        let s_2246_7: Bits = (Bits::new(
            ((s_2246_2) >> (s_2246_0)).value(),
            u16::try_from(s_2246_6).unwrap(),
        ));
        // D s_2246_8: cast reint s_2246_7 -> u8
        let s_2246_8: bool = ((s_2246_7.value()) != 0);
        // D s_2246_9: cast zx s_2246_8 -> bv
        let s_2246_9: Bits = Bits::new(s_2246_8 as u128, 1u16);
        // C s_2246_10: const #0u : u8
        let s_2246_10: bool = false;
        // C s_2246_11: cast zx s_2246_10 -> bv
        let s_2246_11: Bits = Bits::new(s_2246_10 as u128, 1u16);
        // D s_2246_12: cmp-eq s_2246_9 s_2246_11
        let s_2246_12: bool = ((s_2246_9) == (s_2246_11));
        // N s_2246_13: branch s_2246_12 b2249 b2247
        if s_2246_12 {
            return block_2249(state, tracer, fn_state);
        } else {
            return block_2247(state, tracer, fn_state);
        };
    }
    fn block_2247<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2247_0: const #0u : u8
        let s_2247_0: bool = false;
        // D s_2247_1: write-var gs#407285 <= s_2247_0
        fn_state.gs_407285 = s_2247_0;
        // N s_2247_2: jump b2248
        return block_2248(state, tracer, fn_state);
    }
    fn block_2248<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2248_0: read-var gs#407285:u8
        let s_2248_0: bool = fn_state.gs_407285;
        // D s_2248_1: write-var gs#407286 <= s_2248_0
        fn_state.gs_407286 = s_2248_0;
        // N s_2248_2: jump b2245
        return block_2245(state, tracer, fn_state);
    }
    fn block_2249<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2249_0: const #4s : i
        let s_2249_0: i128 = 4;
        // D s_2249_1: read-var u#33101:u32
        let s_2249_1: u32 = fn_state.u_33101;
        // D s_2249_2: cast zx s_2249_1 -> bv
        let s_2249_2: Bits = Bits::new(s_2249_1 as u128, 32u16);
        // C s_2249_3: const #1s : i64
        let s_2249_3: i64 = 1;
        // C s_2249_4: cast zx s_2249_3 -> i
        let s_2249_4: i128 = (i128::try_from(s_2249_3).unwrap());
        // C s_2249_5: const #0s : i
        let s_2249_5: i128 = 0;
        // C s_2249_6: add s_2249_5 s_2249_4
        let s_2249_6: i128 = (s_2249_5 + s_2249_4);
        // D s_2249_7: bit-extract s_2249_2 s_2249_0 s_2249_6
        let s_2249_7: Bits = (Bits::new(
            ((s_2249_2) >> (s_2249_0)).value(),
            u16::try_from(s_2249_6).unwrap(),
        ));
        // D s_2249_8: cast reint s_2249_7 -> u8
        let s_2249_8: bool = ((s_2249_7.value()) != 0);
        // D s_2249_9: cast zx s_2249_8 -> bv
        let s_2249_9: Bits = Bits::new(s_2249_8 as u128, 1u16);
        // C s_2249_10: const #1u : u8
        let s_2249_10: bool = true;
        // C s_2249_11: cast zx s_2249_10 -> bv
        let s_2249_11: Bits = Bits::new(s_2249_10 as u128, 1u16);
        // D s_2249_12: cmp-eq s_2249_9 s_2249_11
        let s_2249_12: bool = ((s_2249_9) == (s_2249_11));
        // D s_2249_13: write-var gs#407285 <= s_2249_12
        fn_state.gs_407285 = s_2249_12;
        // N s_2249_14: jump b2248
        return block_2248(state, tracer, fn_state);
    }
    fn block_2250<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2250_0: const #28s : i
        let s_2250_0: i128 = 28;
        // C s_2250_1: const #4s : i
        let s_2250_1: i128 = 4;
        // D s_2250_2: read-var u#33094:u32
        let s_2250_2: u32 = fn_state.u_33094;
        // D s_2250_3: cast zx s_2250_2 -> bv
        let s_2250_3: Bits = Bits::new(s_2250_2 as u128, 32u16);
        // D s_2250_4: bit-extract s_2250_3 s_2250_0 s_2250_1
        let s_2250_4: Bits = (Bits::new(
            ((s_2250_3) >> (s_2250_0)).value(),
            u16::try_from(s_2250_1).unwrap(),
        ));
        // D s_2250_5: cast reint s_2250_4 -> u8
        let s_2250_5: u8 = (s_2250_4.value() as u8);
        // D s_2250_6: cast zx s_2250_5 -> bv
        let s_2250_6: Bits = Bits::new(s_2250_5 as u128, 4u16);
        // C s_2250_7: const #15u : u8
        let s_2250_7: u8 = 15;
        // C s_2250_8: cast zx s_2250_7 -> bv
        let s_2250_8: Bits = Bits::new(s_2250_7 as u128, 4u16);
        // D s_2250_9: cmp-ne s_2250_6 s_2250_8
        let s_2250_9: bool = ((s_2250_6) != (s_2250_8));
        // N s_2250_10: branch s_2250_9 b2253 b2251
        if s_2250_9 {
            return block_2253(state, tracer, fn_state);
        } else {
            return block_2251(state, tracer, fn_state);
        };
    }
    fn block_2251<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2251_0: const #0u : u8
        let s_2251_0: bool = false;
        // D s_2251_1: write-var gs#407251 <= s_2251_0
        fn_state.gs_407251 = s_2251_0;
        // N s_2251_2: jump b2252
        return block_2252(state, tracer, fn_state);
    }
    fn block_2252<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2252_0: read-var gs#407251:u8
        let s_2252_0: bool = fn_state.gs_407251;
        // D s_2252_1: write-var gs#407252 <= s_2252_0
        fn_state.gs_407252 = s_2252_0;
        // N s_2252_2: jump b1265
        return block_1265(state, tracer, fn_state);
    }
    fn block_2253<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2253_0: const #3275s : i
        let s_2253_0: i128 = 3275;
        // C s_2253_1: const #14696u : u32
        let s_2253_1: u32 = 14696;
        // D s_2253_2: read-reg s_2253_1:i
        let s_2253_2: i128 = {
            let value = state.read_register::<i128>(s_2253_1 as isize);
            tracer.read_register(s_2253_1 as isize, value);
            value
        };
        // D s_2253_3: cmp-lt s_2253_2 s_2253_0
        let s_2253_3: bool = ((s_2253_2) < (s_2253_0));
        // D s_2253_4: write-var gs#407251 <= s_2253_3
        fn_state.gs_407251 = s_2253_3;
        // N s_2253_5: jump b2252
        return block_2252(state, tracer, fn_state);
    }
    fn block_2254<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2254_0: const #12s : i
        let s_2254_0: i128 = 12;
        // D s_2254_1: read-var u#33094:u32
        let s_2254_1: u32 = fn_state.u_33094;
        // D s_2254_2: cast zx s_2254_1 -> bv
        let s_2254_2: Bits = Bits::new(s_2254_1 as u128, 32u16);
        // C s_2254_3: const #1s : i64
        let s_2254_3: i64 = 1;
        // C s_2254_4: cast zx s_2254_3 -> i
        let s_2254_4: i128 = (i128::try_from(s_2254_3).unwrap());
        // C s_2254_5: const #3s : i
        let s_2254_5: i128 = 3;
        // C s_2254_6: add s_2254_5 s_2254_4
        let s_2254_6: i128 = (s_2254_5 + s_2254_4);
        // D s_2254_7: bit-extract s_2254_2 s_2254_0 s_2254_6
        let s_2254_7: Bits = (Bits::new(
            ((s_2254_2) >> (s_2254_0)).value(),
            u16::try_from(s_2254_6).unwrap(),
        ));
        // D s_2254_8: cast reint s_2254_7 -> u8
        let s_2254_8: u8 = (s_2254_7.value() as u8);
        // D s_2254_9: cast zx s_2254_8 -> bv
        let s_2254_9: Bits = Bits::new(s_2254_8 as u128, 4u16);
        // C s_2254_10: const #0u : u8
        let s_2254_10: u8 = 0;
        // C s_2254_11: cast zx s_2254_10 -> bv
        let s_2254_11: Bits = Bits::new(s_2254_10 as u128, 4u16);
        // D s_2254_12: cmp-eq s_2254_9 s_2254_11
        let s_2254_12: bool = ((s_2254_9) == (s_2254_11));
        // N s_2254_13: branch s_2254_12 b2257 b2255
        if s_2254_12 {
            return block_2257(state, tracer, fn_state);
        } else {
            return block_2255(state, tracer, fn_state);
        };
    }
    fn block_2255<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2255_0: const #0u : u8
        let s_2255_0: bool = false;
        // D s_2255_1: write-var gs#407246 <= s_2255_0
        fn_state.gs_407246 = s_2255_0;
        // N s_2255_2: jump b2256
        return block_2256(state, tracer, fn_state);
    }
    fn block_2256<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2256_0: read-var gs#407246:u8
        let s_2256_0: bool = fn_state.gs_407246;
        // D s_2256_1: write-var gs#407247 <= s_2256_0
        fn_state.gs_407247 = s_2256_0;
        // N s_2256_2: jump b1263
        return block_1263(state, tracer, fn_state);
    }
    fn block_2257<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2257_0: const #4s : i
        let s_2257_0: i128 = 4;
        // D s_2257_1: read-var u#33094:u32
        let s_2257_1: u32 = fn_state.u_33094;
        // D s_2257_2: cast zx s_2257_1 -> bv
        let s_2257_2: Bits = Bits::new(s_2257_1 as u128, 32u16);
        // C s_2257_3: const #1s : i64
        let s_2257_3: i64 = 1;
        // C s_2257_4: cast zx s_2257_3 -> i
        let s_2257_4: i128 = (i128::try_from(s_2257_3).unwrap());
        // C s_2257_5: const #0s : i
        let s_2257_5: i128 = 0;
        // C s_2257_6: add s_2257_5 s_2257_4
        let s_2257_6: i128 = (s_2257_5 + s_2257_4);
        // D s_2257_7: bit-extract s_2257_2 s_2257_0 s_2257_6
        let s_2257_7: Bits = (Bits::new(
            ((s_2257_2) >> (s_2257_0)).value(),
            u16::try_from(s_2257_6).unwrap(),
        ));
        // D s_2257_8: cast reint s_2257_7 -> u8
        let s_2257_8: bool = ((s_2257_7.value()) != 0);
        // D s_2257_9: cast zx s_2257_8 -> bv
        let s_2257_9: Bits = Bits::new(s_2257_8 as u128, 1u16);
        // C s_2257_10: const #0u : u8
        let s_2257_10: bool = false;
        // C s_2257_11: cast zx s_2257_10 -> bv
        let s_2257_11: Bits = Bits::new(s_2257_10 as u128, 1u16);
        // D s_2257_12: cmp-eq s_2257_9 s_2257_11
        let s_2257_12: bool = ((s_2257_9) == (s_2257_11));
        // D s_2257_13: write-var gs#407246 <= s_2257_12
        fn_state.gs_407246 = s_2257_12;
        // N s_2257_14: jump b2256
        return block_2256(state, tracer, fn_state);
    }
    fn block_2258<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2258_0: const #28s : i
        let s_2258_0: i128 = 28;
        // C s_2258_1: const #4s : i
        let s_2258_1: i128 = 4;
        // D s_2258_2: read-var u#33089:u32
        let s_2258_2: u32 = fn_state.u_33089;
        // D s_2258_3: cast zx s_2258_2 -> bv
        let s_2258_3: Bits = Bits::new(s_2258_2 as u128, 32u16);
        // D s_2258_4: bit-extract s_2258_3 s_2258_0 s_2258_1
        let s_2258_4: Bits = (Bits::new(
            ((s_2258_3) >> (s_2258_0)).value(),
            u16::try_from(s_2258_1).unwrap(),
        ));
        // D s_2258_5: cast reint s_2258_4 -> u8
        let s_2258_5: u8 = (s_2258_4.value() as u8);
        // D s_2258_6: cast zx s_2258_5 -> bv
        let s_2258_6: Bits = Bits::new(s_2258_5 as u128, 4u16);
        // C s_2258_7: const #15u : u8
        let s_2258_7: u8 = 15;
        // C s_2258_8: cast zx s_2258_7 -> bv
        let s_2258_8: Bits = Bits::new(s_2258_7 as u128, 4u16);
        // D s_2258_9: cmp-ne s_2258_6 s_2258_8
        let s_2258_9: bool = ((s_2258_6) != (s_2258_8));
        // N s_2258_10: branch s_2258_9 b2261 b2259
        if s_2258_9 {
            return block_2261(state, tracer, fn_state);
        } else {
            return block_2259(state, tracer, fn_state);
        };
    }
    fn block_2259<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2259_0: const #0u : u8
        let s_2259_0: bool = false;
        // D s_2259_1: write-var gs#407218 <= s_2259_0
        fn_state.gs_407218 = s_2259_0;
        // N s_2259_2: jump b2260
        return block_2260(state, tracer, fn_state);
    }
    fn block_2260<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2260_0: read-var gs#407218:u8
        let s_2260_0: bool = fn_state.gs_407218;
        // D s_2260_1: write-var gs#407219 <= s_2260_0
        fn_state.gs_407219 = s_2260_0;
        // N s_2260_2: jump b1248
        return block_1248(state, tracer, fn_state);
    }
    fn block_2261<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2261_0: const #3273s : i
        let s_2261_0: i128 = 3273;
        // C s_2261_1: const #14696u : u32
        let s_2261_1: u32 = 14696;
        // D s_2261_2: read-reg s_2261_1:i
        let s_2261_2: i128 = {
            let value = state.read_register::<i128>(s_2261_1 as isize);
            tracer.read_register(s_2261_1 as isize, value);
            value
        };
        // D s_2261_3: cmp-lt s_2261_2 s_2261_0
        let s_2261_3: bool = ((s_2261_2) < (s_2261_0));
        // D s_2261_4: write-var gs#407218 <= s_2261_3
        fn_state.gs_407218 = s_2261_3;
        // N s_2261_5: jump b2260
        return block_2260(state, tracer, fn_state);
    }
    fn block_2262<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2262_0: const #12s : i
        let s_2262_0: i128 = 12;
        // D s_2262_1: read-var u#33089:u32
        let s_2262_1: u32 = fn_state.u_33089;
        // D s_2262_2: cast zx s_2262_1 -> bv
        let s_2262_2: Bits = Bits::new(s_2262_1 as u128, 32u16);
        // C s_2262_3: const #1s : i64
        let s_2262_3: i64 = 1;
        // C s_2262_4: cast zx s_2262_3 -> i
        let s_2262_4: i128 = (i128::try_from(s_2262_3).unwrap());
        // C s_2262_5: const #3s : i
        let s_2262_5: i128 = 3;
        // C s_2262_6: add s_2262_5 s_2262_4
        let s_2262_6: i128 = (s_2262_5 + s_2262_4);
        // D s_2262_7: bit-extract s_2262_2 s_2262_0 s_2262_6
        let s_2262_7: Bits = (Bits::new(
            ((s_2262_2) >> (s_2262_0)).value(),
            u16::try_from(s_2262_6).unwrap(),
        ));
        // D s_2262_8: cast reint s_2262_7 -> u8
        let s_2262_8: u8 = (s_2262_7.value() as u8);
        // D s_2262_9: cast zx s_2262_8 -> bv
        let s_2262_9: Bits = Bits::new(s_2262_8 as u128, 4u16);
        // C s_2262_10: const #0u : u8
        let s_2262_10: u8 = 0;
        // C s_2262_11: cast zx s_2262_10 -> bv
        let s_2262_11: Bits = Bits::new(s_2262_10 as u128, 4u16);
        // D s_2262_12: cmp-eq s_2262_9 s_2262_11
        let s_2262_12: bool = ((s_2262_9) == (s_2262_11));
        // D s_2262_13: write-var gs#407214 <= s_2262_12
        fn_state.gs_407214 = s_2262_12;
        // N s_2262_14: jump b1246
        return block_1246(state, tracer, fn_state);
    }
    fn block_2263<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2263_0: const #28s : i
        let s_2263_0: i128 = 28;
        // C s_2263_1: const #4s : i
        let s_2263_1: i128 = 4;
        // D s_2263_2: read-var u#33082:u32
        let s_2263_2: u32 = fn_state.u_33082;
        // D s_2263_3: cast zx s_2263_2 -> bv
        let s_2263_3: Bits = Bits::new(s_2263_2 as u128, 32u16);
        // D s_2263_4: bit-extract s_2263_3 s_2263_0 s_2263_1
        let s_2263_4: Bits = (Bits::new(
            ((s_2263_3) >> (s_2263_0)).value(),
            u16::try_from(s_2263_1).unwrap(),
        ));
        // D s_2263_5: cast reint s_2263_4 -> u8
        let s_2263_5: u8 = (s_2263_4.value() as u8);
        // D s_2263_6: cast zx s_2263_5 -> bv
        let s_2263_6: Bits = Bits::new(s_2263_5 as u128, 4u16);
        // C s_2263_7: const #15u : u8
        let s_2263_7: u8 = 15;
        // C s_2263_8: cast zx s_2263_7 -> bv
        let s_2263_8: Bits = Bits::new(s_2263_7 as u128, 4u16);
        // D s_2263_9: cmp-ne s_2263_6 s_2263_8
        let s_2263_9: bool = ((s_2263_6) != (s_2263_8));
        // N s_2263_10: branch s_2263_9 b2266 b2264
        if s_2263_9 {
            return block_2266(state, tracer, fn_state);
        } else {
            return block_2264(state, tracer, fn_state);
        };
    }
    fn block_2264<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2264_0: const #0u : u8
        let s_2264_0: bool = false;
        // D s_2264_1: write-var gs#407184 <= s_2264_0
        fn_state.gs_407184 = s_2264_0;
        // N s_2264_2: jump b2265
        return block_2265(state, tracer, fn_state);
    }
    fn block_2265<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2265_0: read-var gs#407184:u8
        let s_2265_0: bool = fn_state.gs_407184;
        // D s_2265_1: write-var gs#407185 <= s_2265_0
        fn_state.gs_407185 = s_2265_0;
        // N s_2265_2: jump b1231
        return block_1231(state, tracer, fn_state);
    }
    fn block_2266<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2266_0: const #3272s : i
        let s_2266_0: i128 = 3272;
        // C s_2266_1: const #14696u : u32
        let s_2266_1: u32 = 14696;
        // D s_2266_2: read-reg s_2266_1:i
        let s_2266_2: i128 = {
            let value = state.read_register::<i128>(s_2266_1 as isize);
            tracer.read_register(s_2266_1 as isize, value);
            value
        };
        // D s_2266_3: cmp-lt s_2266_2 s_2266_0
        let s_2266_3: bool = ((s_2266_2) < (s_2266_0));
        // D s_2266_4: write-var gs#407184 <= s_2266_3
        fn_state.gs_407184 = s_2266_3;
        // N s_2266_5: jump b2265
        return block_2265(state, tracer, fn_state);
    }
    fn block_2267<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2267_0: const #12s : i
        let s_2267_0: i128 = 12;
        // D s_2267_1: read-var u#33082:u32
        let s_2267_1: u32 = fn_state.u_33082;
        // D s_2267_2: cast zx s_2267_1 -> bv
        let s_2267_2: Bits = Bits::new(s_2267_1 as u128, 32u16);
        // C s_2267_3: const #1s : i64
        let s_2267_3: i64 = 1;
        // C s_2267_4: cast zx s_2267_3 -> i
        let s_2267_4: i128 = (i128::try_from(s_2267_3).unwrap());
        // C s_2267_5: const #3s : i
        let s_2267_5: i128 = 3;
        // C s_2267_6: add s_2267_5 s_2267_4
        let s_2267_6: i128 = (s_2267_5 + s_2267_4);
        // D s_2267_7: bit-extract s_2267_2 s_2267_0 s_2267_6
        let s_2267_7: Bits = (Bits::new(
            ((s_2267_2) >> (s_2267_0)).value(),
            u16::try_from(s_2267_6).unwrap(),
        ));
        // D s_2267_8: cast reint s_2267_7 -> u8
        let s_2267_8: u8 = (s_2267_7.value() as u8);
        // D s_2267_9: cast zx s_2267_8 -> bv
        let s_2267_9: Bits = Bits::new(s_2267_8 as u128, 4u16);
        // C s_2267_10: const #0u : u8
        let s_2267_10: u8 = 0;
        // C s_2267_11: cast zx s_2267_10 -> bv
        let s_2267_11: Bits = Bits::new(s_2267_10 as u128, 4u16);
        // D s_2267_12: cmp-eq s_2267_9 s_2267_11
        let s_2267_12: bool = ((s_2267_9) == (s_2267_11));
        // N s_2267_13: branch s_2267_12 b2270 b2268
        if s_2267_12 {
            return block_2270(state, tracer, fn_state);
        } else {
            return block_2268(state, tracer, fn_state);
        };
    }
    fn block_2268<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2268_0: const #0u : u8
        let s_2268_0: bool = false;
        // D s_2268_1: write-var gs#407179 <= s_2268_0
        fn_state.gs_407179 = s_2268_0;
        // N s_2268_2: jump b2269
        return block_2269(state, tracer, fn_state);
    }
    fn block_2269<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2269_0: read-var gs#407179:u8
        let s_2269_0: bool = fn_state.gs_407179;
        // D s_2269_1: write-var gs#407180 <= s_2269_0
        fn_state.gs_407180 = s_2269_0;
        // N s_2269_2: jump b1229
        return block_1229(state, tracer, fn_state);
    }
    fn block_2270<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2270_0: const #7s : i
        let s_2270_0: i128 = 7;
        // D s_2270_1: read-var u#33082:u32
        let s_2270_1: u32 = fn_state.u_33082;
        // D s_2270_2: cast zx s_2270_1 -> bv
        let s_2270_2: Bits = Bits::new(s_2270_1 as u128, 32u16);
        // C s_2270_3: const #1s : i64
        let s_2270_3: i64 = 1;
        // C s_2270_4: cast zx s_2270_3 -> i
        let s_2270_4: i128 = (i128::try_from(s_2270_3).unwrap());
        // C s_2270_5: const #0s : i
        let s_2270_5: i128 = 0;
        // C s_2270_6: add s_2270_5 s_2270_4
        let s_2270_6: i128 = (s_2270_5 + s_2270_4);
        // D s_2270_7: bit-extract s_2270_2 s_2270_0 s_2270_6
        let s_2270_7: Bits = (Bits::new(
            ((s_2270_2) >> (s_2270_0)).value(),
            u16::try_from(s_2270_6).unwrap(),
        ));
        // D s_2270_8: cast reint s_2270_7 -> u8
        let s_2270_8: bool = ((s_2270_7.value()) != 0);
        // D s_2270_9: cast zx s_2270_8 -> bv
        let s_2270_9: Bits = Bits::new(s_2270_8 as u128, 1u16);
        // C s_2270_10: const #0u : u8
        let s_2270_10: bool = false;
        // C s_2270_11: cast zx s_2270_10 -> bv
        let s_2270_11: Bits = Bits::new(s_2270_10 as u128, 1u16);
        // D s_2270_12: cmp-eq s_2270_9 s_2270_11
        let s_2270_12: bool = ((s_2270_9) == (s_2270_11));
        // N s_2270_13: branch s_2270_12 b2273 b2271
        if s_2270_12 {
            return block_2273(state, tracer, fn_state);
        } else {
            return block_2271(state, tracer, fn_state);
        };
    }
    fn block_2271<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2271_0: const #0u : u8
        let s_2271_0: bool = false;
        // D s_2271_1: write-var gs#407178 <= s_2271_0
        fn_state.gs_407178 = s_2271_0;
        // N s_2271_2: jump b2272
        return block_2272(state, tracer, fn_state);
    }
    fn block_2272<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2272_0: read-var gs#407178:u8
        let s_2272_0: bool = fn_state.gs_407178;
        // D s_2272_1: write-var gs#407179 <= s_2272_0
        fn_state.gs_407179 = s_2272_0;
        // N s_2272_2: jump b2269
        return block_2269(state, tracer, fn_state);
    }
    fn block_2273<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2273_0: const #4s : i
        let s_2273_0: i128 = 4;
        // D s_2273_1: read-var u#33082:u32
        let s_2273_1: u32 = fn_state.u_33082;
        // D s_2273_2: cast zx s_2273_1 -> bv
        let s_2273_2: Bits = Bits::new(s_2273_1 as u128, 32u16);
        // C s_2273_3: const #1s : i64
        let s_2273_3: i64 = 1;
        // C s_2273_4: cast zx s_2273_3 -> i
        let s_2273_4: i128 = (i128::try_from(s_2273_3).unwrap());
        // C s_2273_5: const #0s : i
        let s_2273_5: i128 = 0;
        // C s_2273_6: add s_2273_5 s_2273_4
        let s_2273_6: i128 = (s_2273_5 + s_2273_4);
        // D s_2273_7: bit-extract s_2273_2 s_2273_0 s_2273_6
        let s_2273_7: Bits = (Bits::new(
            ((s_2273_2) >> (s_2273_0)).value(),
            u16::try_from(s_2273_6).unwrap(),
        ));
        // D s_2273_8: cast reint s_2273_7 -> u8
        let s_2273_8: bool = ((s_2273_7.value()) != 0);
        // D s_2273_9: cast zx s_2273_8 -> bv
        let s_2273_9: Bits = Bits::new(s_2273_8 as u128, 1u16);
        // C s_2273_10: const #1u : u8
        let s_2273_10: bool = true;
        // C s_2273_11: cast zx s_2273_10 -> bv
        let s_2273_11: Bits = Bits::new(s_2273_10 as u128, 1u16);
        // D s_2273_12: cmp-eq s_2273_9 s_2273_11
        let s_2273_12: bool = ((s_2273_9) == (s_2273_11));
        // D s_2273_13: write-var gs#407178 <= s_2273_12
        fn_state.gs_407178 = s_2273_12;
        // N s_2273_14: jump b2272
        return block_2272(state, tracer, fn_state);
    }
    fn block_2274<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2274_0: const #28s : i
        let s_2274_0: i128 = 28;
        // C s_2274_1: const #4s : i
        let s_2274_1: i128 = 4;
        // D s_2274_2: read-var u#33075:u32
        let s_2274_2: u32 = fn_state.u_33075;
        // D s_2274_3: cast zx s_2274_2 -> bv
        let s_2274_3: Bits = Bits::new(s_2274_2 as u128, 32u16);
        // D s_2274_4: bit-extract s_2274_3 s_2274_0 s_2274_1
        let s_2274_4: Bits = (Bits::new(
            ((s_2274_3) >> (s_2274_0)).value(),
            u16::try_from(s_2274_1).unwrap(),
        ));
        // D s_2274_5: cast reint s_2274_4 -> u8
        let s_2274_5: u8 = (s_2274_4.value() as u8);
        // D s_2274_6: cast zx s_2274_5 -> bv
        let s_2274_6: Bits = Bits::new(s_2274_5 as u128, 4u16);
        // C s_2274_7: const #15u : u8
        let s_2274_7: u8 = 15;
        // C s_2274_8: cast zx s_2274_7 -> bv
        let s_2274_8: Bits = Bits::new(s_2274_7 as u128, 4u16);
        // D s_2274_9: cmp-ne s_2274_6 s_2274_8
        let s_2274_9: bool = ((s_2274_6) != (s_2274_8));
        // N s_2274_10: branch s_2274_9 b2277 b2275
        if s_2274_9 {
            return block_2277(state, tracer, fn_state);
        } else {
            return block_2275(state, tracer, fn_state);
        };
    }
    fn block_2275<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2275_0: const #0u : u8
        let s_2275_0: bool = false;
        // D s_2275_1: write-var gs#407144 <= s_2275_0
        fn_state.gs_407144 = s_2275_0;
        // N s_2275_2: jump b2276
        return block_2276(state, tracer, fn_state);
    }
    fn block_2276<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2276_0: read-var gs#407144:u8
        let s_2276_0: bool = fn_state.gs_407144;
        // D s_2276_1: write-var gs#407145 <= s_2276_0
        fn_state.gs_407145 = s_2276_0;
        // N s_2276_2: jump b1214
        return block_1214(state, tracer, fn_state);
    }
    fn block_2277<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2277_0: const #3270s : i
        let s_2277_0: i128 = 3270;
        // C s_2277_1: const #14696u : u32
        let s_2277_1: u32 = 14696;
        // D s_2277_2: read-reg s_2277_1:i
        let s_2277_2: i128 = {
            let value = state.read_register::<i128>(s_2277_1 as isize);
            tracer.read_register(s_2277_1 as isize, value);
            value
        };
        // D s_2277_3: cmp-lt s_2277_2 s_2277_0
        let s_2277_3: bool = ((s_2277_2) < (s_2277_0));
        // D s_2277_4: write-var gs#407144 <= s_2277_3
        fn_state.gs_407144 = s_2277_3;
        // N s_2277_5: jump b2276
        return block_2276(state, tracer, fn_state);
    }
    fn block_2278<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2278_0: const #12s : i
        let s_2278_0: i128 = 12;
        // D s_2278_1: read-var u#33075:u32
        let s_2278_1: u32 = fn_state.u_33075;
        // D s_2278_2: cast zx s_2278_1 -> bv
        let s_2278_2: Bits = Bits::new(s_2278_1 as u128, 32u16);
        // C s_2278_3: const #1s : i64
        let s_2278_3: i64 = 1;
        // C s_2278_4: cast zx s_2278_3 -> i
        let s_2278_4: i128 = (i128::try_from(s_2278_3).unwrap());
        // C s_2278_5: const #3s : i
        let s_2278_5: i128 = 3;
        // C s_2278_6: add s_2278_5 s_2278_4
        let s_2278_6: i128 = (s_2278_5 + s_2278_4);
        // D s_2278_7: bit-extract s_2278_2 s_2278_0 s_2278_6
        let s_2278_7: Bits = (Bits::new(
            ((s_2278_2) >> (s_2278_0)).value(),
            u16::try_from(s_2278_6).unwrap(),
        ));
        // D s_2278_8: cast reint s_2278_7 -> u8
        let s_2278_8: u8 = (s_2278_7.value() as u8);
        // D s_2278_9: cast zx s_2278_8 -> bv
        let s_2278_9: Bits = Bits::new(s_2278_8 as u128, 4u16);
        // C s_2278_10: const #0u : u8
        let s_2278_10: u8 = 0;
        // C s_2278_11: cast zx s_2278_10 -> bv
        let s_2278_11: Bits = Bits::new(s_2278_10 as u128, 4u16);
        // D s_2278_12: cmp-eq s_2278_9 s_2278_11
        let s_2278_12: bool = ((s_2278_9) == (s_2278_11));
        // N s_2278_13: branch s_2278_12 b2281 b2279
        if s_2278_12 {
            return block_2281(state, tracer, fn_state);
        } else {
            return block_2279(state, tracer, fn_state);
        };
    }
    fn block_2279<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2279_0: const #0u : u8
        let s_2279_0: bool = false;
        // D s_2279_1: write-var gs#407139 <= s_2279_0
        fn_state.gs_407139 = s_2279_0;
        // N s_2279_2: jump b2280
        return block_2280(state, tracer, fn_state);
    }
    fn block_2280<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2280_0: read-var gs#407139:u8
        let s_2280_0: bool = fn_state.gs_407139;
        // D s_2280_1: write-var gs#407140 <= s_2280_0
        fn_state.gs_407140 = s_2280_0;
        // N s_2280_2: jump b1212
        return block_1212(state, tracer, fn_state);
    }
    fn block_2281<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2281_0: const #4s : i
        let s_2281_0: i128 = 4;
        // D s_2281_1: read-var u#33075:u32
        let s_2281_1: u32 = fn_state.u_33075;
        // D s_2281_2: cast zx s_2281_1 -> bv
        let s_2281_2: Bits = Bits::new(s_2281_1 as u128, 32u16);
        // C s_2281_3: const #1s : i64
        let s_2281_3: i64 = 1;
        // C s_2281_4: cast zx s_2281_3 -> i
        let s_2281_4: i128 = (i128::try_from(s_2281_3).unwrap());
        // C s_2281_5: const #0s : i
        let s_2281_5: i128 = 0;
        // C s_2281_6: add s_2281_5 s_2281_4
        let s_2281_6: i128 = (s_2281_5 + s_2281_4);
        // D s_2281_7: bit-extract s_2281_2 s_2281_0 s_2281_6
        let s_2281_7: Bits = (Bits::new(
            ((s_2281_2) >> (s_2281_0)).value(),
            u16::try_from(s_2281_6).unwrap(),
        ));
        // D s_2281_8: cast reint s_2281_7 -> u8
        let s_2281_8: bool = ((s_2281_7.value()) != 0);
        // D s_2281_9: cast zx s_2281_8 -> bv
        let s_2281_9: Bits = Bits::new(s_2281_8 as u128, 1u16);
        // C s_2281_10: const #0u : u8
        let s_2281_10: bool = false;
        // C s_2281_11: cast zx s_2281_10 -> bv
        let s_2281_11: Bits = Bits::new(s_2281_10 as u128, 1u16);
        // D s_2281_12: cmp-eq s_2281_9 s_2281_11
        let s_2281_12: bool = ((s_2281_9) == (s_2281_11));
        // D s_2281_13: write-var gs#407139 <= s_2281_12
        fn_state.gs_407139 = s_2281_12;
        // N s_2281_14: jump b2280
        return block_2280(state, tracer, fn_state);
    }
    fn block_2282<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2282_0: const #28s : i
        let s_2282_0: i128 = 28;
        // C s_2282_1: const #4s : i
        let s_2282_1: i128 = 4;
        // D s_2282_2: read-var u#33070:u32
        let s_2282_2: u32 = fn_state.u_33070;
        // D s_2282_3: cast zx s_2282_2 -> bv
        let s_2282_3: Bits = Bits::new(s_2282_2 as u128, 32u16);
        // D s_2282_4: bit-extract s_2282_3 s_2282_0 s_2282_1
        let s_2282_4: Bits = (Bits::new(
            ((s_2282_3) >> (s_2282_0)).value(),
            u16::try_from(s_2282_1).unwrap(),
        ));
        // D s_2282_5: cast reint s_2282_4 -> u8
        let s_2282_5: u8 = (s_2282_4.value() as u8);
        // D s_2282_6: cast zx s_2282_5 -> bv
        let s_2282_6: Bits = Bits::new(s_2282_5 as u128, 4u16);
        // C s_2282_7: const #15u : u8
        let s_2282_7: u8 = 15;
        // C s_2282_8: cast zx s_2282_7 -> bv
        let s_2282_8: Bits = Bits::new(s_2282_7 as u128, 4u16);
        // D s_2282_9: cmp-ne s_2282_6 s_2282_8
        let s_2282_9: bool = ((s_2282_6) != (s_2282_8));
        // N s_2282_10: branch s_2282_9 b2285 b2283
        if s_2282_9 {
            return block_2285(state, tracer, fn_state);
        } else {
            return block_2283(state, tracer, fn_state);
        };
    }
    fn block_2283<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2283_0: const #0u : u8
        let s_2283_0: bool = false;
        // D s_2283_1: write-var gs#407111 <= s_2283_0
        fn_state.gs_407111 = s_2283_0;
        // N s_2283_2: jump b2284
        return block_2284(state, tracer, fn_state);
    }
    fn block_2284<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2284_0: read-var gs#407111:u8
        let s_2284_0: bool = fn_state.gs_407111;
        // D s_2284_1: write-var gs#407112 <= s_2284_0
        fn_state.gs_407112 = s_2284_0;
        // N s_2284_2: jump b1197
        return block_1197(state, tracer, fn_state);
    }
    fn block_2285<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2285_0: const #3268s : i
        let s_2285_0: i128 = 3268;
        // C s_2285_1: const #14696u : u32
        let s_2285_1: u32 = 14696;
        // D s_2285_2: read-reg s_2285_1:i
        let s_2285_2: i128 = {
            let value = state.read_register::<i128>(s_2285_1 as isize);
            tracer.read_register(s_2285_1 as isize, value);
            value
        };
        // D s_2285_3: cmp-lt s_2285_2 s_2285_0
        let s_2285_3: bool = ((s_2285_2) < (s_2285_0));
        // D s_2285_4: write-var gs#407111 <= s_2285_3
        fn_state.gs_407111 = s_2285_3;
        // N s_2285_5: jump b2284
        return block_2284(state, tracer, fn_state);
    }
    fn block_2286<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2286_0: const #12s : i
        let s_2286_0: i128 = 12;
        // D s_2286_1: read-var u#33070:u32
        let s_2286_1: u32 = fn_state.u_33070;
        // D s_2286_2: cast zx s_2286_1 -> bv
        let s_2286_2: Bits = Bits::new(s_2286_1 as u128, 32u16);
        // C s_2286_3: const #1s : i64
        let s_2286_3: i64 = 1;
        // C s_2286_4: cast zx s_2286_3 -> i
        let s_2286_4: i128 = (i128::try_from(s_2286_3).unwrap());
        // C s_2286_5: const #3s : i
        let s_2286_5: i128 = 3;
        // C s_2286_6: add s_2286_5 s_2286_4
        let s_2286_6: i128 = (s_2286_5 + s_2286_4);
        // D s_2286_7: bit-extract s_2286_2 s_2286_0 s_2286_6
        let s_2286_7: Bits = (Bits::new(
            ((s_2286_2) >> (s_2286_0)).value(),
            u16::try_from(s_2286_6).unwrap(),
        ));
        // D s_2286_8: cast reint s_2286_7 -> u8
        let s_2286_8: u8 = (s_2286_7.value() as u8);
        // D s_2286_9: cast zx s_2286_8 -> bv
        let s_2286_9: Bits = Bits::new(s_2286_8 as u128, 4u16);
        // C s_2286_10: const #0u : u8
        let s_2286_10: u8 = 0;
        // C s_2286_11: cast zx s_2286_10 -> bv
        let s_2286_11: Bits = Bits::new(s_2286_10 as u128, 4u16);
        // D s_2286_12: cmp-eq s_2286_9 s_2286_11
        let s_2286_12: bool = ((s_2286_9) == (s_2286_11));
        // D s_2286_13: write-var gs#407107 <= s_2286_12
        fn_state.gs_407107 = s_2286_12;
        // N s_2286_14: jump b1195
        return block_1195(state, tracer, fn_state);
    }
    fn block_2287<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2287_0: const #28s : i
        let s_2287_0: i128 = 28;
        // C s_2287_1: const #4s : i
        let s_2287_1: i128 = 4;
        // D s_2287_2: read-var u#33062:u32
        let s_2287_2: u32 = fn_state.u_33062;
        // D s_2287_3: cast zx s_2287_2 -> bv
        let s_2287_3: Bits = Bits::new(s_2287_2 as u128, 32u16);
        // D s_2287_4: bit-extract s_2287_3 s_2287_0 s_2287_1
        let s_2287_4: Bits = (Bits::new(
            ((s_2287_3) >> (s_2287_0)).value(),
            u16::try_from(s_2287_1).unwrap(),
        ));
        // D s_2287_5: cast reint s_2287_4 -> u8
        let s_2287_5: u8 = (s_2287_4.value() as u8);
        // D s_2287_6: cast zx s_2287_5 -> bv
        let s_2287_6: Bits = Bits::new(s_2287_5 as u128, 4u16);
        // C s_2287_7: const #15u : u8
        let s_2287_7: u8 = 15;
        // C s_2287_8: cast zx s_2287_7 -> bv
        let s_2287_8: Bits = Bits::new(s_2287_7 as u128, 4u16);
        // D s_2287_9: cmp-ne s_2287_6 s_2287_8
        let s_2287_9: bool = ((s_2287_6) != (s_2287_8));
        // N s_2287_10: branch s_2287_9 b2290 b2288
        if s_2287_9 {
            return block_2290(state, tracer, fn_state);
        } else {
            return block_2288(state, tracer, fn_state);
        };
    }
    fn block_2288<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2288_0: const #0u : u8
        let s_2288_0: bool = false;
        // D s_2288_1: write-var gs#407086 <= s_2288_0
        fn_state.gs_407086 = s_2288_0;
        // N s_2288_2: jump b2289
        return block_2289(state, tracer, fn_state);
    }
    fn block_2289<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2289_0: read-var gs#407086:u8
        let s_2289_0: bool = fn_state.gs_407086;
        // D s_2289_1: write-var gs#407087 <= s_2289_0
        fn_state.gs_407087 = s_2289_0;
        // N s_2289_2: jump b1191
        return block_1191(state, tracer, fn_state);
    }
    fn block_2290<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2290_0: const #3249s : i
        let s_2290_0: i128 = 3249;
        // C s_2290_1: const #14696u : u32
        let s_2290_1: u32 = 14696;
        // D s_2290_2: read-reg s_2290_1:i
        let s_2290_2: i128 = {
            let value = state.read_register::<i128>(s_2290_1 as isize);
            tracer.read_register(s_2290_1 as isize, value);
            value
        };
        // D s_2290_3: cmp-lt s_2290_2 s_2290_0
        let s_2290_3: bool = ((s_2290_2) < (s_2290_0));
        // D s_2290_4: write-var gs#407086 <= s_2290_3
        fn_state.gs_407086 = s_2290_3;
        // N s_2290_5: jump b2289
        return block_2289(state, tracer, fn_state);
    }
    fn block_2291<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2291_0: const #16s : i
        let s_2291_0: i128 = 16;
        // D s_2291_1: read-var u#33062:u32
        let s_2291_1: u32 = fn_state.u_33062;
        // D s_2291_2: cast zx s_2291_1 -> bv
        let s_2291_2: Bits = Bits::new(s_2291_1 as u128, 32u16);
        // C s_2291_3: const #1s : i64
        let s_2291_3: i64 = 1;
        // C s_2291_4: cast zx s_2291_3 -> i
        let s_2291_4: i128 = (i128::try_from(s_2291_3).unwrap());
        // C s_2291_5: const #3s : i
        let s_2291_5: i128 = 3;
        // C s_2291_6: add s_2291_5 s_2291_4
        let s_2291_6: i128 = (s_2291_5 + s_2291_4);
        // D s_2291_7: bit-extract s_2291_2 s_2291_0 s_2291_6
        let s_2291_7: Bits = (Bits::new(
            ((s_2291_2) >> (s_2291_0)).value(),
            u16::try_from(s_2291_6).unwrap(),
        ));
        // D s_2291_8: cast reint s_2291_7 -> u8
        let s_2291_8: u8 = (s_2291_7.value() as u8);
        // D s_2291_9: cast zx s_2291_8 -> bv
        let s_2291_9: Bits = Bits::new(s_2291_8 as u128, 4u16);
        // C s_2291_10: const #13u : u8
        let s_2291_10: u8 = 13;
        // C s_2291_11: cast zx s_2291_10 -> bv
        let s_2291_11: Bits = Bits::new(s_2291_10 as u128, 4u16);
        // D s_2291_12: cmp-eq s_2291_9 s_2291_11
        let s_2291_12: bool = ((s_2291_9) == (s_2291_11));
        // N s_2291_13: branch s_2291_12 b2294 b2292
        if s_2291_12 {
            return block_2294(state, tracer, fn_state);
        } else {
            return block_2292(state, tracer, fn_state);
        };
    }
    fn block_2292<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2292_0: const #0u : u8
        let s_2292_0: bool = false;
        // D s_2292_1: write-var gs#407081 <= s_2292_0
        fn_state.gs_407081 = s_2292_0;
        // N s_2292_2: jump b2293
        return block_2293(state, tracer, fn_state);
    }
    fn block_2293<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2293_0: read-var gs#407081:u8
        let s_2293_0: bool = fn_state.gs_407081;
        // D s_2293_1: write-var gs#407082 <= s_2293_0
        fn_state.gs_407082 = s_2293_0;
        // N s_2293_2: jump b1189
        return block_1189(state, tracer, fn_state);
    }
    fn block_2294<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2294_0: const #4s : i
        let s_2294_0: i128 = 4;
        // D s_2294_1: read-var u#33062:u32
        let s_2294_1: u32 = fn_state.u_33062;
        // D s_2294_2: cast zx s_2294_1 -> bv
        let s_2294_2: Bits = Bits::new(s_2294_1 as u128, 32u16);
        // C s_2294_3: const #1s : i64
        let s_2294_3: i64 = 1;
        // C s_2294_4: cast zx s_2294_3 -> i
        let s_2294_4: i128 = (i128::try_from(s_2294_3).unwrap());
        // C s_2294_5: const #0s : i
        let s_2294_5: i128 = 0;
        // C s_2294_6: add s_2294_5 s_2294_4
        let s_2294_6: i128 = (s_2294_5 + s_2294_4);
        // D s_2294_7: bit-extract s_2294_2 s_2294_0 s_2294_6
        let s_2294_7: Bits = (Bits::new(
            ((s_2294_2) >> (s_2294_0)).value(),
            u16::try_from(s_2294_6).unwrap(),
        ));
        // D s_2294_8: cast reint s_2294_7 -> u8
        let s_2294_8: bool = ((s_2294_7.value()) != 0);
        // D s_2294_9: cast zx s_2294_8 -> bv
        let s_2294_9: Bits = Bits::new(s_2294_8 as u128, 1u16);
        // C s_2294_10: const #0u : u8
        let s_2294_10: bool = false;
        // C s_2294_11: cast zx s_2294_10 -> bv
        let s_2294_11: Bits = Bits::new(s_2294_10 as u128, 1u16);
        // D s_2294_12: cmp-eq s_2294_9 s_2294_11
        let s_2294_12: bool = ((s_2294_9) == (s_2294_11));
        // D s_2294_13: write-var gs#407081 <= s_2294_12
        fn_state.gs_407081 = s_2294_12;
        // N s_2294_14: jump b2293
        return block_2293(state, tracer, fn_state);
    }
    fn block_2295<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2295_0: const #28s : i
        let s_2295_0: i128 = 28;
        // C s_2295_1: const #4s : i
        let s_2295_1: i128 = 4;
        // D s_2295_2: read-var u#33056:u32
        let s_2295_2: u32 = fn_state.u_33056;
        // D s_2295_3: cast zx s_2295_2 -> bv
        let s_2295_3: Bits = Bits::new(s_2295_2 as u128, 32u16);
        // D s_2295_4: bit-extract s_2295_3 s_2295_0 s_2295_1
        let s_2295_4: Bits = (Bits::new(
            ((s_2295_3) >> (s_2295_0)).value(),
            u16::try_from(s_2295_1).unwrap(),
        ));
        // D s_2295_5: cast reint s_2295_4 -> u8
        let s_2295_5: u8 = (s_2295_4.value() as u8);
        // D s_2295_6: cast zx s_2295_5 -> bv
        let s_2295_6: Bits = Bits::new(s_2295_5 as u128, 4u16);
        // C s_2295_7: const #15u : u8
        let s_2295_7: u8 = 15;
        // C s_2295_8: cast zx s_2295_7 -> bv
        let s_2295_8: Bits = Bits::new(s_2295_7 as u128, 4u16);
        // D s_2295_9: cmp-ne s_2295_6 s_2295_8
        let s_2295_9: bool = ((s_2295_6) != (s_2295_8));
        // N s_2295_10: branch s_2295_9 b2298 b2296
        if s_2295_9 {
            return block_2298(state, tracer, fn_state);
        } else {
            return block_2296(state, tracer, fn_state);
        };
    }
    fn block_2296<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2296_0: const #0u : u8
        let s_2296_0: bool = false;
        // D s_2296_1: write-var gs#407062 <= s_2296_0
        fn_state.gs_407062 = s_2296_0;
        // N s_2296_2: jump b2297
        return block_2297(state, tracer, fn_state);
    }
    fn block_2297<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2297_0: read-var gs#407062:u8
        let s_2297_0: bool = fn_state.gs_407062;
        // D s_2297_1: write-var gs#407063 <= s_2297_0
        fn_state.gs_407063 = s_2297_0;
        // N s_2297_2: jump b1185
        return block_1185(state, tracer, fn_state);
    }
    fn block_2298<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2298_0: const #3245s : i
        let s_2298_0: i128 = 3245;
        // C s_2298_1: const #14696u : u32
        let s_2298_1: u32 = 14696;
        // D s_2298_2: read-reg s_2298_1:i
        let s_2298_2: i128 = {
            let value = state.read_register::<i128>(s_2298_1 as isize);
            tracer.read_register(s_2298_1 as isize, value);
            value
        };
        // D s_2298_3: cmp-lt s_2298_2 s_2298_0
        let s_2298_3: bool = ((s_2298_2) < (s_2298_0));
        // D s_2298_4: write-var gs#407062 <= s_2298_3
        fn_state.gs_407062 = s_2298_3;
        // N s_2298_5: jump b2297
        return block_2297(state, tracer, fn_state);
    }
    fn block_2299<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2299_0: const #16s : i
        let s_2299_0: i128 = 16;
        // D s_2299_1: read-var u#33056:u32
        let s_2299_1: u32 = fn_state.u_33056;
        // D s_2299_2: cast zx s_2299_1 -> bv
        let s_2299_2: Bits = Bits::new(s_2299_1 as u128, 32u16);
        // C s_2299_3: const #1s : i64
        let s_2299_3: i64 = 1;
        // C s_2299_4: cast zx s_2299_3 -> i
        let s_2299_4: i128 = (i128::try_from(s_2299_3).unwrap());
        // C s_2299_5: const #3s : i
        let s_2299_5: i128 = 3;
        // C s_2299_6: add s_2299_5 s_2299_4
        let s_2299_6: i128 = (s_2299_5 + s_2299_4);
        // D s_2299_7: bit-extract s_2299_2 s_2299_0 s_2299_6
        let s_2299_7: Bits = (Bits::new(
            ((s_2299_2) >> (s_2299_0)).value(),
            u16::try_from(s_2299_6).unwrap(),
        ));
        // D s_2299_8: cast reint s_2299_7 -> u8
        let s_2299_8: u8 = (s_2299_7.value() as u8);
        // D s_2299_9: cast zx s_2299_8 -> bv
        let s_2299_9: Bits = Bits::new(s_2299_8 as u128, 4u16);
        // C s_2299_10: const #13u : u8
        let s_2299_10: u8 = 13;
        // C s_2299_11: cast zx s_2299_10 -> bv
        let s_2299_11: Bits = Bits::new(s_2299_10 as u128, 4u16);
        // D s_2299_12: cmp-eq s_2299_9 s_2299_11
        let s_2299_12: bool = ((s_2299_9) == (s_2299_11));
        // D s_2299_13: write-var gs#407058 <= s_2299_12
        fn_state.gs_407058 = s_2299_12;
        // N s_2299_14: jump b1183
        return block_1183(state, tracer, fn_state);
    }
    fn block_2300<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2300_0: const #28s : i
        let s_2300_0: i128 = 28;
        // C s_2300_1: const #4s : i
        let s_2300_1: i128 = 4;
        // D s_2300_2: read-var u#33047:u32
        let s_2300_2: u32 = fn_state.u_33047;
        // D s_2300_3: cast zx s_2300_2 -> bv
        let s_2300_3: Bits = Bits::new(s_2300_2 as u128, 32u16);
        // D s_2300_4: bit-extract s_2300_3 s_2300_0 s_2300_1
        let s_2300_4: Bits = (Bits::new(
            ((s_2300_3) >> (s_2300_0)).value(),
            u16::try_from(s_2300_1).unwrap(),
        ));
        // D s_2300_5: cast reint s_2300_4 -> u8
        let s_2300_5: u8 = (s_2300_4.value() as u8);
        // D s_2300_6: cast zx s_2300_5 -> bv
        let s_2300_6: Bits = Bits::new(s_2300_5 as u128, 4u16);
        // C s_2300_7: const #15u : u8
        let s_2300_7: u8 = 15;
        // C s_2300_8: cast zx s_2300_7 -> bv
        let s_2300_8: Bits = Bits::new(s_2300_7 as u128, 4u16);
        // D s_2300_9: cmp-ne s_2300_6 s_2300_8
        let s_2300_9: bool = ((s_2300_6) != (s_2300_8));
        // N s_2300_10: branch s_2300_9 b2303 b2301
        if s_2300_9 {
            return block_2303(state, tracer, fn_state);
        } else {
            return block_2301(state, tracer, fn_state);
        };
    }
    fn block_2301<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2301_0: const #0u : u8
        let s_2301_0: bool = false;
        // D s_2301_1: write-var gs#407035 <= s_2301_0
        fn_state.gs_407035 = s_2301_0;
        // N s_2301_2: jump b2302
        return block_2302(state, tracer, fn_state);
    }
    fn block_2302<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2302_0: read-var gs#407035:u8
        let s_2302_0: bool = fn_state.gs_407035;
        // D s_2302_1: write-var gs#407036 <= s_2302_0
        fn_state.gs_407036 = s_2302_0;
        // N s_2302_2: jump b1179
        return block_1179(state, tracer, fn_state);
    }
    fn block_2303<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2303_0: const #3244s : i
        let s_2303_0: i128 = 3244;
        // C s_2303_1: const #14696u : u32
        let s_2303_1: u32 = 14696;
        // D s_2303_2: read-reg s_2303_1:i
        let s_2303_2: i128 = {
            let value = state.read_register::<i128>(s_2303_1 as isize);
            tracer.read_register(s_2303_1 as isize, value);
            value
        };
        // D s_2303_3: cmp-lt s_2303_2 s_2303_0
        let s_2303_3: bool = ((s_2303_2) < (s_2303_0));
        // D s_2303_4: write-var gs#407035 <= s_2303_3
        fn_state.gs_407035 = s_2303_3;
        // N s_2303_5: jump b2302
        return block_2302(state, tracer, fn_state);
    }
    fn block_2304<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2304_0: const #7s : i
        let s_2304_0: i128 = 7;
        // D s_2304_1: read-var u#33047:u32
        let s_2304_1: u32 = fn_state.u_33047;
        // D s_2304_2: cast zx s_2304_1 -> bv
        let s_2304_2: Bits = Bits::new(s_2304_1 as u128, 32u16);
        // C s_2304_3: const #1s : i64
        let s_2304_3: i64 = 1;
        // C s_2304_4: cast zx s_2304_3 -> i
        let s_2304_4: i128 = (i128::try_from(s_2304_3).unwrap());
        // C s_2304_5: const #0s : i
        let s_2304_5: i128 = 0;
        // C s_2304_6: add s_2304_5 s_2304_4
        let s_2304_6: i128 = (s_2304_5 + s_2304_4);
        // D s_2304_7: bit-extract s_2304_2 s_2304_0 s_2304_6
        let s_2304_7: Bits = (Bits::new(
            ((s_2304_2) >> (s_2304_0)).value(),
            u16::try_from(s_2304_6).unwrap(),
        ));
        // D s_2304_8: cast reint s_2304_7 -> u8
        let s_2304_8: bool = ((s_2304_7.value()) != 0);
        // D s_2304_9: cast zx s_2304_8 -> bv
        let s_2304_9: Bits = Bits::new(s_2304_8 as u128, 1u16);
        // C s_2304_10: const #0u : u8
        let s_2304_10: bool = false;
        // C s_2304_11: cast zx s_2304_10 -> bv
        let s_2304_11: Bits = Bits::new(s_2304_10 as u128, 1u16);
        // D s_2304_12: cmp-eq s_2304_9 s_2304_11
        let s_2304_12: bool = ((s_2304_9) == (s_2304_11));
        // N s_2304_13: branch s_2304_12 b2307 b2305
        if s_2304_12 {
            return block_2307(state, tracer, fn_state);
        } else {
            return block_2305(state, tracer, fn_state);
        };
    }
    fn block_2305<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2305_0: const #0u : u8
        let s_2305_0: bool = false;
        // D s_2305_1: write-var gs#407030 <= s_2305_0
        fn_state.gs_407030 = s_2305_0;
        // N s_2305_2: jump b2306
        return block_2306(state, tracer, fn_state);
    }
    fn block_2306<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2306_0: read-var gs#407030:u8
        let s_2306_0: bool = fn_state.gs_407030;
        // D s_2306_1: write-var gs#407031 <= s_2306_0
        fn_state.gs_407031 = s_2306_0;
        // N s_2306_2: jump b1177
        return block_1177(state, tracer, fn_state);
    }
    fn block_2307<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2307_0: const #4s : i
        let s_2307_0: i128 = 4;
        // D s_2307_1: read-var u#33047:u32
        let s_2307_1: u32 = fn_state.u_33047;
        // D s_2307_2: cast zx s_2307_1 -> bv
        let s_2307_2: Bits = Bits::new(s_2307_1 as u128, 32u16);
        // C s_2307_3: const #1s : i64
        let s_2307_3: i64 = 1;
        // C s_2307_4: cast zx s_2307_3 -> i
        let s_2307_4: i128 = (i128::try_from(s_2307_3).unwrap());
        // C s_2307_5: const #0s : i
        let s_2307_5: i128 = 0;
        // C s_2307_6: add s_2307_5 s_2307_4
        let s_2307_6: i128 = (s_2307_5 + s_2307_4);
        // D s_2307_7: bit-extract s_2307_2 s_2307_0 s_2307_6
        let s_2307_7: Bits = (Bits::new(
            ((s_2307_2) >> (s_2307_0)).value(),
            u16::try_from(s_2307_6).unwrap(),
        ));
        // D s_2307_8: cast reint s_2307_7 -> u8
        let s_2307_8: bool = ((s_2307_7.value()) != 0);
        // D s_2307_9: cast zx s_2307_8 -> bv
        let s_2307_9: Bits = Bits::new(s_2307_8 as u128, 1u16);
        // C s_2307_10: const #1u : u8
        let s_2307_10: bool = true;
        // C s_2307_11: cast zx s_2307_10 -> bv
        let s_2307_11: Bits = Bits::new(s_2307_10 as u128, 1u16);
        // D s_2307_12: cmp-eq s_2307_9 s_2307_11
        let s_2307_12: bool = ((s_2307_9) == (s_2307_11));
        // D s_2307_13: write-var gs#407030 <= s_2307_12
        fn_state.gs_407030 = s_2307_12;
        // N s_2307_14: jump b2306
        return block_2306(state, tracer, fn_state);
    }
    fn block_2308<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2308_0: const #28s : i
        let s_2308_0: i128 = 28;
        // C s_2308_1: const #4s : i
        let s_2308_1: i128 = 4;
        // D s_2308_2: read-var u#33038:u32
        let s_2308_2: u32 = fn_state.u_33038;
        // D s_2308_3: cast zx s_2308_2 -> bv
        let s_2308_3: Bits = Bits::new(s_2308_2 as u128, 32u16);
        // D s_2308_4: bit-extract s_2308_3 s_2308_0 s_2308_1
        let s_2308_4: Bits = (Bits::new(
            ((s_2308_3) >> (s_2308_0)).value(),
            u16::try_from(s_2308_1).unwrap(),
        ));
        // D s_2308_5: cast reint s_2308_4 -> u8
        let s_2308_5: u8 = (s_2308_4.value() as u8);
        // D s_2308_6: cast zx s_2308_5 -> bv
        let s_2308_6: Bits = Bits::new(s_2308_5 as u128, 4u16);
        // C s_2308_7: const #15u : u8
        let s_2308_7: u8 = 15;
        // C s_2308_8: cast zx s_2308_7 -> bv
        let s_2308_8: Bits = Bits::new(s_2308_7 as u128, 4u16);
        // D s_2308_9: cmp-ne s_2308_6 s_2308_8
        let s_2308_9: bool = ((s_2308_6) != (s_2308_8));
        // N s_2308_10: branch s_2308_9 b2311 b2309
        if s_2308_9 {
            return block_2311(state, tracer, fn_state);
        } else {
            return block_2309(state, tracer, fn_state);
        };
    }
    fn block_2309<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2309_0: const #0u : u8
        let s_2309_0: bool = false;
        // D s_2309_1: write-var gs#407005 <= s_2309_0
        fn_state.gs_407005 = s_2309_0;
        // N s_2309_2: jump b2310
        return block_2310(state, tracer, fn_state);
    }
    fn block_2310<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2310_0: read-var gs#407005:u8
        let s_2310_0: bool = fn_state.gs_407005;
        // D s_2310_1: write-var gs#407006 <= s_2310_0
        fn_state.gs_407006 = s_2310_0;
        // N s_2310_2: jump b1173
        return block_1173(state, tracer, fn_state);
    }
    fn block_2311<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2311_0: const #3241s : i
        let s_2311_0: i128 = 3241;
        // C s_2311_1: const #14696u : u32
        let s_2311_1: u32 = 14696;
        // D s_2311_2: read-reg s_2311_1:i
        let s_2311_2: i128 = {
            let value = state.read_register::<i128>(s_2311_1 as isize);
            tracer.read_register(s_2311_1 as isize, value);
            value
        };
        // D s_2311_3: cmp-lt s_2311_2 s_2311_0
        let s_2311_3: bool = ((s_2311_2) < (s_2311_0));
        // D s_2311_4: write-var gs#407005 <= s_2311_3
        fn_state.gs_407005 = s_2311_3;
        // N s_2311_5: jump b2310
        return block_2310(state, tracer, fn_state);
    }
    fn block_2312<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2312_0: const #4s : i
        let s_2312_0: i128 = 4;
        // D s_2312_1: read-var u#33038:u32
        let s_2312_1: u32 = fn_state.u_33038;
        // D s_2312_2: cast zx s_2312_1 -> bv
        let s_2312_2: Bits = Bits::new(s_2312_1 as u128, 32u16);
        // C s_2312_3: const #1s : i64
        let s_2312_3: i64 = 1;
        // C s_2312_4: cast zx s_2312_3 -> i
        let s_2312_4: i128 = (i128::try_from(s_2312_3).unwrap());
        // C s_2312_5: const #0s : i
        let s_2312_5: i128 = 0;
        // C s_2312_6: add s_2312_5 s_2312_4
        let s_2312_6: i128 = (s_2312_5 + s_2312_4);
        // D s_2312_7: bit-extract s_2312_2 s_2312_0 s_2312_6
        let s_2312_7: Bits = (Bits::new(
            ((s_2312_2) >> (s_2312_0)).value(),
            u16::try_from(s_2312_6).unwrap(),
        ));
        // D s_2312_8: cast reint s_2312_7 -> u8
        let s_2312_8: bool = ((s_2312_7.value()) != 0);
        // D s_2312_9: cast zx s_2312_8 -> bv
        let s_2312_9: Bits = Bits::new(s_2312_8 as u128, 1u16);
        // C s_2312_10: const #0u : u8
        let s_2312_10: bool = false;
        // C s_2312_11: cast zx s_2312_10 -> bv
        let s_2312_11: Bits = Bits::new(s_2312_10 as u128, 1u16);
        // D s_2312_12: cmp-eq s_2312_9 s_2312_11
        let s_2312_12: bool = ((s_2312_9) == (s_2312_11));
        // D s_2312_13: write-var gs#407001 <= s_2312_12
        fn_state.gs_407001 = s_2312_12;
        // N s_2312_14: jump b1171
        return block_1171(state, tracer, fn_state);
    }
    fn block_2313<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2313_0: const #28s : i
        let s_2313_0: i128 = 28;
        // C s_2313_1: const #4s : i
        let s_2313_1: i128 = 4;
        // D s_2313_2: read-var u#33031:u32
        let s_2313_2: u32 = fn_state.u_33031;
        // D s_2313_3: cast zx s_2313_2 -> bv
        let s_2313_3: Bits = Bits::new(s_2313_2 as u128, 32u16);
        // D s_2313_4: bit-extract s_2313_3 s_2313_0 s_2313_1
        let s_2313_4: Bits = (Bits::new(
            ((s_2313_3) >> (s_2313_0)).value(),
            u16::try_from(s_2313_1).unwrap(),
        ));
        // D s_2313_5: cast reint s_2313_4 -> u8
        let s_2313_5: u8 = (s_2313_4.value() as u8);
        // D s_2313_6: cast zx s_2313_5 -> bv
        let s_2313_6: Bits = Bits::new(s_2313_5 as u128, 4u16);
        // C s_2313_7: const #15u : u8
        let s_2313_7: u8 = 15;
        // C s_2313_8: cast zx s_2313_7 -> bv
        let s_2313_8: Bits = Bits::new(s_2313_7 as u128, 4u16);
        // D s_2313_9: cmp-ne s_2313_6 s_2313_8
        let s_2313_9: bool = ((s_2313_6) != (s_2313_8));
        // N s_2313_10: branch s_2313_9 b2316 b2314
        if s_2313_9 {
            return block_2316(state, tracer, fn_state);
        } else {
            return block_2314(state, tracer, fn_state);
        };
    }
    fn block_2314<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2314_0: const #0u : u8
        let s_2314_0: bool = false;
        // D s_2314_1: write-var gs#406982 <= s_2314_0
        fn_state.gs_406982 = s_2314_0;
        // N s_2314_2: jump b2315
        return block_2315(state, tracer, fn_state);
    }
    fn block_2315<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2315_0: read-var gs#406982:u8
        let s_2315_0: bool = fn_state.gs_406982;
        // D s_2315_1: write-var gs#406983 <= s_2315_0
        fn_state.gs_406983 = s_2315_0;
        // N s_2315_2: jump b1167
        return block_1167(state, tracer, fn_state);
    }
    fn block_2316<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2316_0: const #3235s : i
        let s_2316_0: i128 = 3235;
        // C s_2316_1: const #14696u : u32
        let s_2316_1: u32 = 14696;
        // D s_2316_2: read-reg s_2316_1:i
        let s_2316_2: i128 = {
            let value = state.read_register::<i128>(s_2316_1 as isize);
            tracer.read_register(s_2316_1 as isize, value);
            value
        };
        // D s_2316_3: cmp-lt s_2316_2 s_2316_0
        let s_2316_3: bool = ((s_2316_2) < (s_2316_0));
        // D s_2316_4: write-var gs#406982 <= s_2316_3
        fn_state.gs_406982 = s_2316_3;
        // N s_2316_5: jump b2315
        return block_2315(state, tracer, fn_state);
    }
    fn block_2317<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2317_0: const #28s : i
        let s_2317_0: i128 = 28;
        // C s_2317_1: const #4s : i
        let s_2317_1: i128 = 4;
        // D s_2317_2: read-var u#33024:u32
        let s_2317_2: u32 = fn_state.u_33024;
        // D s_2317_3: cast zx s_2317_2 -> bv
        let s_2317_3: Bits = Bits::new(s_2317_2 as u128, 32u16);
        // D s_2317_4: bit-extract s_2317_3 s_2317_0 s_2317_1
        let s_2317_4: Bits = (Bits::new(
            ((s_2317_3) >> (s_2317_0)).value(),
            u16::try_from(s_2317_1).unwrap(),
        ));
        // D s_2317_5: cast reint s_2317_4 -> u8
        let s_2317_5: u8 = (s_2317_4.value() as u8);
        // D s_2317_6: cast zx s_2317_5 -> bv
        let s_2317_6: Bits = Bits::new(s_2317_5 as u128, 4u16);
        // C s_2317_7: const #15u : u8
        let s_2317_7: u8 = 15;
        // C s_2317_8: cast zx s_2317_7 -> bv
        let s_2317_8: Bits = Bits::new(s_2317_7 as u128, 4u16);
        // D s_2317_9: cmp-ne s_2317_6 s_2317_8
        let s_2317_9: bool = ((s_2317_6) != (s_2317_8));
        // N s_2317_10: branch s_2317_9 b2320 b2318
        if s_2317_9 {
            return block_2320(state, tracer, fn_state);
        } else {
            return block_2318(state, tracer, fn_state);
        };
    }
    fn block_2318<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2318_0: const #0u : u8
        let s_2318_0: bool = false;
        // D s_2318_1: write-var gs#406951 <= s_2318_0
        fn_state.gs_406951 = s_2318_0;
        // N s_2318_2: jump b2319
        return block_2319(state, tracer, fn_state);
    }
    fn block_2319<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2319_0: read-var gs#406951:u8
        let s_2319_0: bool = fn_state.gs_406951;
        // D s_2319_1: write-var gs#406952 <= s_2319_0
        fn_state.gs_406952 = s_2319_0;
        // N s_2319_2: jump b1152
        return block_1152(state, tracer, fn_state);
    }
    fn block_2320<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2320_0: const #3222s : i
        let s_2320_0: i128 = 3222;
        // C s_2320_1: const #14696u : u32
        let s_2320_1: u32 = 14696;
        // D s_2320_2: read-reg s_2320_1:i
        let s_2320_2: i128 = {
            let value = state.read_register::<i128>(s_2320_1 as isize);
            tracer.read_register(s_2320_1 as isize, value);
            value
        };
        // D s_2320_3: cmp-lt s_2320_2 s_2320_0
        let s_2320_3: bool = ((s_2320_2) < (s_2320_0));
        // D s_2320_4: write-var gs#406951 <= s_2320_3
        fn_state.gs_406951 = s_2320_3;
        // N s_2320_5: jump b2319
        return block_2319(state, tracer, fn_state);
    }
    fn block_2321<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2321_0: const #20s : i
        let s_2321_0: i128 = 20;
        // D s_2321_1: read-var u#33024:u32
        let s_2321_1: u32 = fn_state.u_33024;
        // D s_2321_2: cast zx s_2321_1 -> bv
        let s_2321_2: Bits = Bits::new(s_2321_1 as u128, 32u16);
        // C s_2321_3: const #1s : i64
        let s_2321_3: i64 = 1;
        // C s_2321_4: cast zx s_2321_3 -> i
        let s_2321_4: i128 = (i128::try_from(s_2321_3).unwrap());
        // C s_2321_5: const #2s : i
        let s_2321_5: i128 = 2;
        // C s_2321_6: add s_2321_5 s_2321_4
        let s_2321_6: i128 = (s_2321_5 + s_2321_4);
        // D s_2321_7: bit-extract s_2321_2 s_2321_0 s_2321_6
        let s_2321_7: Bits = (Bits::new(
            ((s_2321_2) >> (s_2321_0)).value(),
            u16::try_from(s_2321_6).unwrap(),
        ));
        // D s_2321_8: cast reint s_2321_7 -> u8
        let s_2321_8: u8 = (s_2321_7.value() as u8);
        // D s_2321_9: cast zx s_2321_8 -> bv
        let s_2321_9: Bits = Bits::new(s_2321_8 as u128, 3u16);
        // C s_2321_10: const #2u : u8
        let s_2321_10: u8 = 2;
        // C s_2321_11: cast zx s_2321_10 -> bv
        let s_2321_11: Bits = Bits::new(s_2321_10 as u128, 3u16);
        // D s_2321_12: cmp-eq s_2321_9 s_2321_11
        let s_2321_12: bool = ((s_2321_9) == (s_2321_11));
        // N s_2321_13: branch s_2321_12 b2324 b2322
        if s_2321_12 {
            return block_2324(state, tracer, fn_state);
        } else {
            return block_2322(state, tracer, fn_state);
        };
    }
    fn block_2322<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2322_0: const #0u : u8
        let s_2322_0: bool = false;
        // D s_2322_1: write-var gs#406946 <= s_2322_0
        fn_state.gs_406946 = s_2322_0;
        // N s_2322_2: jump b2323
        return block_2323(state, tracer, fn_state);
    }
    fn block_2323<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2323_0: read-var gs#406946:u8
        let s_2323_0: bool = fn_state.gs_406946;
        // D s_2323_1: write-var gs#406947 <= s_2323_0
        fn_state.gs_406947 = s_2323_0;
        // N s_2323_2: jump b1150
        return block_1150(state, tracer, fn_state);
    }
    fn block_2324<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2324_0: const #4s : i
        let s_2324_0: i128 = 4;
        // D s_2324_1: read-var u#33024:u32
        let s_2324_1: u32 = fn_state.u_33024;
        // D s_2324_2: cast zx s_2324_1 -> bv
        let s_2324_2: Bits = Bits::new(s_2324_1 as u128, 32u16);
        // C s_2324_3: const #1s : i64
        let s_2324_3: i64 = 1;
        // C s_2324_4: cast zx s_2324_3 -> i
        let s_2324_4: i128 = (i128::try_from(s_2324_3).unwrap());
        // C s_2324_5: const #7s : i
        let s_2324_5: i128 = 7;
        // C s_2324_6: add s_2324_5 s_2324_4
        let s_2324_6: i128 = (s_2324_5 + s_2324_4);
        // D s_2324_7: bit-extract s_2324_2 s_2324_0 s_2324_6
        let s_2324_7: Bits = (Bits::new(
            ((s_2324_2) >> (s_2324_0)).value(),
            u16::try_from(s_2324_6).unwrap(),
        ));
        // D s_2324_8: cast reint s_2324_7 -> u8
        let s_2324_8: u8 = (s_2324_7.value() as u8);
        // D s_2324_9: cast zx s_2324_8 -> bv
        let s_2324_9: Bits = Bits::new(s_2324_8 as u128, 8u16);
        // C s_2324_10: const #11u : u8
        let s_2324_10: u8 = 11;
        // C s_2324_11: cast zx s_2324_10 -> bv
        let s_2324_11: Bits = Bits::new(s_2324_10 as u128, 8u16);
        // D s_2324_12: cmp-eq s_2324_9 s_2324_11
        let s_2324_12: bool = ((s_2324_9) == (s_2324_11));
        // D s_2324_13: write-var gs#406946 <= s_2324_12
        fn_state.gs_406946 = s_2324_12;
        // N s_2324_14: jump b2323
        return block_2323(state, tracer, fn_state);
    }
    fn block_2325<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2325_0: const #28s : i
        let s_2325_0: i128 = 28;
        // C s_2325_1: const #4s : i
        let s_2325_1: i128 = 4;
        // D s_2325_2: read-var u#33016:u32
        let s_2325_2: u32 = fn_state.u_33016;
        // D s_2325_3: cast zx s_2325_2 -> bv
        let s_2325_3: Bits = Bits::new(s_2325_2 as u128, 32u16);
        // D s_2325_4: bit-extract s_2325_3 s_2325_0 s_2325_1
        let s_2325_4: Bits = (Bits::new(
            ((s_2325_3) >> (s_2325_0)).value(),
            u16::try_from(s_2325_1).unwrap(),
        ));
        // D s_2325_5: cast reint s_2325_4 -> u8
        let s_2325_5: u8 = (s_2325_4.value() as u8);
        // D s_2325_6: cast zx s_2325_5 -> bv
        let s_2325_6: Bits = Bits::new(s_2325_5 as u128, 4u16);
        // C s_2325_7: const #15u : u8
        let s_2325_7: u8 = 15;
        // C s_2325_8: cast zx s_2325_7 -> bv
        let s_2325_8: Bits = Bits::new(s_2325_7 as u128, 4u16);
        // D s_2325_9: cmp-ne s_2325_6 s_2325_8
        let s_2325_9: bool = ((s_2325_6) != (s_2325_8));
        // N s_2325_10: branch s_2325_9 b2328 b2326
        if s_2325_9 {
            return block_2328(state, tracer, fn_state);
        } else {
            return block_2326(state, tracer, fn_state);
        };
    }
    fn block_2326<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2326_0: const #0u : u8
        let s_2326_0: bool = false;
        // D s_2326_1: write-var gs#406923 <= s_2326_0
        fn_state.gs_406923 = s_2326_0;
        // N s_2326_2: jump b2327
        return block_2327(state, tracer, fn_state);
    }
    fn block_2327<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2327_0: read-var gs#406923:u8
        let s_2327_0: bool = fn_state.gs_406923;
        // D s_2327_1: write-var gs#406924 <= s_2327_0
        fn_state.gs_406924 = s_2327_0;
        // N s_2327_2: jump b1146
        return block_1146(state, tracer, fn_state);
    }
    fn block_2328<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2328_0: const #3221s : i
        let s_2328_0: i128 = 3221;
        // C s_2328_1: const #14696u : u32
        let s_2328_1: u32 = 14696;
        // D s_2328_2: read-reg s_2328_1:i
        let s_2328_2: i128 = {
            let value = state.read_register::<i128>(s_2328_1 as isize);
            tracer.read_register(s_2328_1 as isize, value);
            value
        };
        // D s_2328_3: cmp-lt s_2328_2 s_2328_0
        let s_2328_3: bool = ((s_2328_2) < (s_2328_0));
        // D s_2328_4: write-var gs#406923 <= s_2328_3
        fn_state.gs_406923 = s_2328_3;
        // N s_2328_5: jump b2327
        return block_2327(state, tracer, fn_state);
    }
    fn block_2329<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2329_0: const #20s : i
        let s_2329_0: i128 = 20;
        // D s_2329_1: read-var u#33016:u32
        let s_2329_1: u32 = fn_state.u_33016;
        // D s_2329_2: cast zx s_2329_1 -> bv
        let s_2329_2: Bits = Bits::new(s_2329_1 as u128, 32u16);
        // C s_2329_3: const #1s : i64
        let s_2329_3: i64 = 1;
        // C s_2329_4: cast zx s_2329_3 -> i
        let s_2329_4: i128 = (i128::try_from(s_2329_3).unwrap());
        // C s_2329_5: const #2s : i
        let s_2329_5: i128 = 2;
        // C s_2329_6: add s_2329_5 s_2329_4
        let s_2329_6: i128 = (s_2329_5 + s_2329_4);
        // D s_2329_7: bit-extract s_2329_2 s_2329_0 s_2329_6
        let s_2329_7: Bits = (Bits::new(
            ((s_2329_2) >> (s_2329_0)).value(),
            u16::try_from(s_2329_6).unwrap(),
        ));
        // D s_2329_8: cast reint s_2329_7 -> u8
        let s_2329_8: u8 = (s_2329_7.value() as u8);
        // D s_2329_9: cast zx s_2329_8 -> bv
        let s_2329_9: Bits = Bits::new(s_2329_8 as u128, 3u16);
        // C s_2329_10: const #6u : u8
        let s_2329_10: u8 = 6;
        // C s_2329_11: cast zx s_2329_10 -> bv
        let s_2329_11: Bits = Bits::new(s_2329_10 as u128, 3u16);
        // D s_2329_12: cmp-eq s_2329_9 s_2329_11
        let s_2329_12: bool = ((s_2329_9) == (s_2329_11));
        // N s_2329_13: branch s_2329_12 b2332 b2330
        if s_2329_12 {
            return block_2332(state, tracer, fn_state);
        } else {
            return block_2330(state, tracer, fn_state);
        };
    }
    fn block_2330<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2330_0: const #0u : u8
        let s_2330_0: bool = false;
        // D s_2330_1: write-var gs#406918 <= s_2330_0
        fn_state.gs_406918 = s_2330_0;
        // N s_2330_2: jump b2331
        return block_2331(state, tracer, fn_state);
    }
    fn block_2331<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2331_0: read-var gs#406918:u8
        let s_2331_0: bool = fn_state.gs_406918;
        // D s_2331_1: write-var gs#406919 <= s_2331_0
        fn_state.gs_406919 = s_2331_0;
        // N s_2331_2: jump b1144
        return block_1144(state, tracer, fn_state);
    }
    fn block_2332<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2332_0: const #4s : i
        let s_2332_0: i128 = 4;
        // D s_2332_1: read-var u#33016:u32
        let s_2332_1: u32 = fn_state.u_33016;
        // D s_2332_2: cast zx s_2332_1 -> bv
        let s_2332_2: Bits = Bits::new(s_2332_1 as u128, 32u16);
        // C s_2332_3: const #1s : i64
        let s_2332_3: i64 = 1;
        // C s_2332_4: cast zx s_2332_3 -> i
        let s_2332_4: i128 = (i128::try_from(s_2332_3).unwrap());
        // C s_2332_5: const #3s : i
        let s_2332_5: i128 = 3;
        // C s_2332_6: add s_2332_5 s_2332_4
        let s_2332_6: i128 = (s_2332_5 + s_2332_4);
        // D s_2332_7: bit-extract s_2332_2 s_2332_0 s_2332_6
        let s_2332_7: Bits = (Bits::new(
            ((s_2332_2) >> (s_2332_0)).value(),
            u16::try_from(s_2332_6).unwrap(),
        ));
        // D s_2332_8: cast reint s_2332_7 -> u8
        let s_2332_8: u8 = (s_2332_7.value() as u8);
        // D s_2332_9: cast zx s_2332_8 -> bv
        let s_2332_9: Bits = Bits::new(s_2332_8 as u128, 4u16);
        // C s_2332_10: const #11u : u8
        let s_2332_10: u8 = 11;
        // C s_2332_11: cast zx s_2332_10 -> bv
        let s_2332_11: Bits = Bits::new(s_2332_10 as u128, 4u16);
        // D s_2332_12: cmp-eq s_2332_9 s_2332_11
        let s_2332_12: bool = ((s_2332_9) == (s_2332_11));
        // D s_2332_13: write-var gs#406918 <= s_2332_12
        fn_state.gs_406918 = s_2332_12;
        // N s_2332_14: jump b2331
        return block_2331(state, tracer, fn_state);
    }
    fn block_2333<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2333_0: const #28s : i
        let s_2333_0: i128 = 28;
        // C s_2333_1: const #4s : i
        let s_2333_1: i128 = 4;
        // D s_2333_2: read-var u#33007:u32
        let s_2333_2: u32 = fn_state.u_33007;
        // D s_2333_3: cast zx s_2333_2 -> bv
        let s_2333_3: Bits = Bits::new(s_2333_2 as u128, 32u16);
        // D s_2333_4: bit-extract s_2333_3 s_2333_0 s_2333_1
        let s_2333_4: Bits = (Bits::new(
            ((s_2333_3) >> (s_2333_0)).value(),
            u16::try_from(s_2333_1).unwrap(),
        ));
        // D s_2333_5: cast reint s_2333_4 -> u8
        let s_2333_5: u8 = (s_2333_4.value() as u8);
        // D s_2333_6: cast zx s_2333_5 -> bv
        let s_2333_6: Bits = Bits::new(s_2333_5 as u128, 4u16);
        // C s_2333_7: const #15u : u8
        let s_2333_7: u8 = 15;
        // C s_2333_8: cast zx s_2333_7 -> bv
        let s_2333_8: Bits = Bits::new(s_2333_7 as u128, 4u16);
        // D s_2333_9: cmp-ne s_2333_6 s_2333_8
        let s_2333_9: bool = ((s_2333_6) != (s_2333_8));
        // N s_2333_10: branch s_2333_9 b2336 b2334
        if s_2333_9 {
            return block_2336(state, tracer, fn_state);
        } else {
            return block_2334(state, tracer, fn_state);
        };
    }
    fn block_2334<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2334_0: const #0u : u8
        let s_2334_0: bool = false;
        // D s_2334_1: write-var gs#406882 <= s_2334_0
        fn_state.gs_406882 = s_2334_0;
        // N s_2334_2: jump b2335
        return block_2335(state, tracer, fn_state);
    }
    fn block_2335<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2335_0: read-var gs#406882:u8
        let s_2335_0: bool = fn_state.gs_406882;
        // D s_2335_1: write-var gs#406883 <= s_2335_0
        fn_state.gs_406883 = s_2335_0;
        // N s_2335_2: jump b1129
        return block_1129(state, tracer, fn_state);
    }
    fn block_2336<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2336_0: const #3218s : i
        let s_2336_0: i128 = 3218;
        // C s_2336_1: const #14696u : u32
        let s_2336_1: u32 = 14696;
        // D s_2336_2: read-reg s_2336_1:i
        let s_2336_2: i128 = {
            let value = state.read_register::<i128>(s_2336_1 as isize);
            tracer.read_register(s_2336_1 as isize, value);
            value
        };
        // D s_2336_3: cmp-lt s_2336_2 s_2336_0
        let s_2336_3: bool = ((s_2336_2) < (s_2336_0));
        // D s_2336_4: write-var gs#406882 <= s_2336_3
        fn_state.gs_406882 = s_2336_3;
        // N s_2336_5: jump b2335
        return block_2335(state, tracer, fn_state);
    }
    fn block_2337<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2337_0: const #22s : i
        let s_2337_0: i128 = 22;
        // D s_2337_1: read-var u#33007:u32
        let s_2337_1: u32 = fn_state.u_33007;
        // D s_2337_2: cast zx s_2337_1 -> bv
        let s_2337_2: Bits = Bits::new(s_2337_1 as u128, 32u16);
        // C s_2337_3: const #1s : i64
        let s_2337_3: i64 = 1;
        // C s_2337_4: cast zx s_2337_3 -> i
        let s_2337_4: i128 = (i128::try_from(s_2337_3).unwrap());
        // C s_2337_5: const #0s : i
        let s_2337_5: i128 = 0;
        // C s_2337_6: add s_2337_5 s_2337_4
        let s_2337_6: i128 = (s_2337_5 + s_2337_4);
        // D s_2337_7: bit-extract s_2337_2 s_2337_0 s_2337_6
        let s_2337_7: Bits = (Bits::new(
            ((s_2337_2) >> (s_2337_0)).value(),
            u16::try_from(s_2337_6).unwrap(),
        ));
        // D s_2337_8: cast reint s_2337_7 -> u8
        let s_2337_8: bool = ((s_2337_7.value()) != 0);
        // D s_2337_9: cast zx s_2337_8 -> bv
        let s_2337_9: Bits = Bits::new(s_2337_8 as u128, 1u16);
        // C s_2337_10: const #0u : u8
        let s_2337_10: bool = false;
        // C s_2337_11: cast zx s_2337_10 -> bv
        let s_2337_11: Bits = Bits::new(s_2337_10 as u128, 1u16);
        // D s_2337_12: cmp-eq s_2337_9 s_2337_11
        let s_2337_12: bool = ((s_2337_9) == (s_2337_11));
        // N s_2337_13: branch s_2337_12 b2340 b2338
        if s_2337_12 {
            return block_2340(state, tracer, fn_state);
        } else {
            return block_2338(state, tracer, fn_state);
        };
    }
    fn block_2338<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2338_0: const #0u : u8
        let s_2338_0: bool = false;
        // D s_2338_1: write-var gs#406877 <= s_2338_0
        fn_state.gs_406877 = s_2338_0;
        // N s_2338_2: jump b2339
        return block_2339(state, tracer, fn_state);
    }
    fn block_2339<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2339_0: read-var gs#406877:u8
        let s_2339_0: bool = fn_state.gs_406877;
        // D s_2339_1: write-var gs#406878 <= s_2339_0
        fn_state.gs_406878 = s_2339_0;
        // N s_2339_2: jump b1127
        return block_1127(state, tracer, fn_state);
    }
    fn block_2340<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2340_0: const #20s : i
        let s_2340_0: i128 = 20;
        // D s_2340_1: read-var u#33007:u32
        let s_2340_1: u32 = fn_state.u_33007;
        // D s_2340_2: cast zx s_2340_1 -> bv
        let s_2340_2: Bits = Bits::new(s_2340_1 as u128, 32u16);
        // C s_2340_3: const #1s : i64
        let s_2340_3: i64 = 1;
        // C s_2340_4: cast zx s_2340_3 -> i
        let s_2340_4: i128 = (i128::try_from(s_2340_3).unwrap());
        // C s_2340_5: const #0s : i
        let s_2340_5: i128 = 0;
        // C s_2340_6: add s_2340_5 s_2340_4
        let s_2340_6: i128 = (s_2340_5 + s_2340_4);
        // D s_2340_7: bit-extract s_2340_2 s_2340_0 s_2340_6
        let s_2340_7: Bits = (Bits::new(
            ((s_2340_2) >> (s_2340_0)).value(),
            u16::try_from(s_2340_6).unwrap(),
        ));
        // D s_2340_8: cast reint s_2340_7 -> u8
        let s_2340_8: bool = ((s_2340_7.value()) != 0);
        // D s_2340_9: cast zx s_2340_8 -> bv
        let s_2340_9: Bits = Bits::new(s_2340_8 as u128, 1u16);
        // C s_2340_10: const #0u : u8
        let s_2340_10: bool = false;
        // C s_2340_11: cast zx s_2340_10 -> bv
        let s_2340_11: Bits = Bits::new(s_2340_10 as u128, 1u16);
        // D s_2340_12: cmp-eq s_2340_9 s_2340_11
        let s_2340_12: bool = ((s_2340_9) == (s_2340_11));
        // N s_2340_13: branch s_2340_12 b2343 b2341
        if s_2340_12 {
            return block_2343(state, tracer, fn_state);
        } else {
            return block_2341(state, tracer, fn_state);
        };
    }
    fn block_2341<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2341_0: const #0u : u8
        let s_2341_0: bool = false;
        // D s_2341_1: write-var gs#406876 <= s_2341_0
        fn_state.gs_406876 = s_2341_0;
        // N s_2341_2: jump b2342
        return block_2342(state, tracer, fn_state);
    }
    fn block_2342<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2342_0: read-var gs#406876:u8
        let s_2342_0: bool = fn_state.gs_406876;
        // D s_2342_1: write-var gs#406877 <= s_2342_0
        fn_state.gs_406877 = s_2342_0;
        // N s_2342_2: jump b2339
        return block_2339(state, tracer, fn_state);
    }
    fn block_2343<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2343_0: const #4s : i
        let s_2343_0: i128 = 4;
        // D s_2343_1: read-var u#33007:u32
        let s_2343_1: u32 = fn_state.u_33007;
        // D s_2343_2: cast zx s_2343_1 -> bv
        let s_2343_2: Bits = Bits::new(s_2343_1 as u128, 32u16);
        // C s_2343_3: const #1s : i64
        let s_2343_3: i64 = 1;
        // C s_2343_4: cast zx s_2343_3 -> i
        let s_2343_4: i128 = (i128::try_from(s_2343_3).unwrap());
        // C s_2343_5: const #7s : i
        let s_2343_5: i128 = 7;
        // C s_2343_6: add s_2343_5 s_2343_4
        let s_2343_6: i128 = (s_2343_5 + s_2343_4);
        // D s_2343_7: bit-extract s_2343_2 s_2343_0 s_2343_6
        let s_2343_7: Bits = (Bits::new(
            ((s_2343_2) >> (s_2343_0)).value(),
            u16::try_from(s_2343_6).unwrap(),
        ));
        // D s_2343_8: cast reint s_2343_7 -> u8
        let s_2343_8: u8 = (s_2343_7.value() as u8);
        // D s_2343_9: cast zx s_2343_8 -> bv
        let s_2343_9: Bits = Bits::new(s_2343_8 as u128, 8u16);
        // C s_2343_10: const #11u : u8
        let s_2343_10: u8 = 11;
        // C s_2343_11: cast zx s_2343_10 -> bv
        let s_2343_11: Bits = Bits::new(s_2343_10 as u128, 8u16);
        // D s_2343_12: cmp-eq s_2343_9 s_2343_11
        let s_2343_12: bool = ((s_2343_9) == (s_2343_11));
        // D s_2343_13: write-var gs#406876 <= s_2343_12
        fn_state.gs_406876 = s_2343_12;
        // N s_2343_14: jump b2342
        return block_2342(state, tracer, fn_state);
    }
    fn block_2344<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2344_0: const #28s : i
        let s_2344_0: i128 = 28;
        // C s_2344_1: const #4s : i
        let s_2344_1: i128 = 4;
        // D s_2344_2: read-var u#32997:u32
        let s_2344_2: u32 = fn_state.u_32997;
        // D s_2344_3: cast zx s_2344_2 -> bv
        let s_2344_3: Bits = Bits::new(s_2344_2 as u128, 32u16);
        // D s_2344_4: bit-extract s_2344_3 s_2344_0 s_2344_1
        let s_2344_4: Bits = (Bits::new(
            ((s_2344_3) >> (s_2344_0)).value(),
            u16::try_from(s_2344_1).unwrap(),
        ));
        // D s_2344_5: cast reint s_2344_4 -> u8
        let s_2344_5: u8 = (s_2344_4.value() as u8);
        // D s_2344_6: cast zx s_2344_5 -> bv
        let s_2344_6: Bits = Bits::new(s_2344_5 as u128, 4u16);
        // C s_2344_7: const #15u : u8
        let s_2344_7: u8 = 15;
        // C s_2344_8: cast zx s_2344_7 -> bv
        let s_2344_8: Bits = Bits::new(s_2344_7 as u128, 4u16);
        // D s_2344_9: cmp-ne s_2344_6 s_2344_8
        let s_2344_9: bool = ((s_2344_6) != (s_2344_8));
        // N s_2344_10: branch s_2344_9 b2347 b2345
        if s_2344_9 {
            return block_2347(state, tracer, fn_state);
        } else {
            return block_2345(state, tracer, fn_state);
        };
    }
    fn block_2345<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2345_0: const #0u : u8
        let s_2345_0: bool = false;
        // D s_2345_1: write-var gs#406847 <= s_2345_0
        fn_state.gs_406847 = s_2345_0;
        // N s_2345_2: jump b2346
        return block_2346(state, tracer, fn_state);
    }
    fn block_2346<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2346_0: read-var gs#406847:u8
        let s_2346_0: bool = fn_state.gs_406847;
        // D s_2346_1: write-var gs#406848 <= s_2346_0
        fn_state.gs_406848 = s_2346_0;
        // N s_2346_2: jump b1123
        return block_1123(state, tracer, fn_state);
    }
    fn block_2347<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2347_0: const #3214s : i
        let s_2347_0: i128 = 3214;
        // C s_2347_1: const #14696u : u32
        let s_2347_1: u32 = 14696;
        // D s_2347_2: read-reg s_2347_1:i
        let s_2347_2: i128 = {
            let value = state.read_register::<i128>(s_2347_1 as isize);
            tracer.read_register(s_2347_1 as isize, value);
            value
        };
        // D s_2347_3: cmp-lt s_2347_2 s_2347_0
        let s_2347_3: bool = ((s_2347_2) < (s_2347_0));
        // D s_2347_4: write-var gs#406847 <= s_2347_3
        fn_state.gs_406847 = s_2347_3;
        // N s_2347_5: jump b2346
        return block_2346(state, tracer, fn_state);
    }
    fn block_2348<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2348_0: const #22s : i
        let s_2348_0: i128 = 22;
        // D s_2348_1: read-var u#32997:u32
        let s_2348_1: u32 = fn_state.u_32997;
        // D s_2348_2: cast zx s_2348_1 -> bv
        let s_2348_2: Bits = Bits::new(s_2348_1 as u128, 32u16);
        // C s_2348_3: const #1s : i64
        let s_2348_3: i64 = 1;
        // C s_2348_4: cast zx s_2348_3 -> i
        let s_2348_4: i128 = (i128::try_from(s_2348_3).unwrap());
        // C s_2348_5: const #0s : i
        let s_2348_5: i128 = 0;
        // C s_2348_6: add s_2348_5 s_2348_4
        let s_2348_6: i128 = (s_2348_5 + s_2348_4);
        // D s_2348_7: bit-extract s_2348_2 s_2348_0 s_2348_6
        let s_2348_7: Bits = (Bits::new(
            ((s_2348_2) >> (s_2348_0)).value(),
            u16::try_from(s_2348_6).unwrap(),
        ));
        // D s_2348_8: cast reint s_2348_7 -> u8
        let s_2348_8: bool = ((s_2348_7.value()) != 0);
        // D s_2348_9: cast zx s_2348_8 -> bv
        let s_2348_9: Bits = Bits::new(s_2348_8 as u128, 1u16);
        // C s_2348_10: const #1u : u8
        let s_2348_10: bool = true;
        // C s_2348_11: cast zx s_2348_10 -> bv
        let s_2348_11: Bits = Bits::new(s_2348_10 as u128, 1u16);
        // D s_2348_12: cmp-eq s_2348_9 s_2348_11
        let s_2348_12: bool = ((s_2348_9) == (s_2348_11));
        // N s_2348_13: branch s_2348_12 b2351 b2349
        if s_2348_12 {
            return block_2351(state, tracer, fn_state);
        } else {
            return block_2349(state, tracer, fn_state);
        };
    }
    fn block_2349<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2349_0: const #0u : u8
        let s_2349_0: bool = false;
        // D s_2349_1: write-var gs#406842 <= s_2349_0
        fn_state.gs_406842 = s_2349_0;
        // N s_2349_2: jump b2350
        return block_2350(state, tracer, fn_state);
    }
    fn block_2350<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2350_0: read-var gs#406842:u8
        let s_2350_0: bool = fn_state.gs_406842;
        // D s_2350_1: write-var gs#406843 <= s_2350_0
        fn_state.gs_406843 = s_2350_0;
        // N s_2350_2: jump b1121
        return block_1121(state, tracer, fn_state);
    }
    fn block_2351<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2351_0: const #20s : i
        let s_2351_0: i128 = 20;
        // D s_2351_1: read-var u#32997:u32
        let s_2351_1: u32 = fn_state.u_32997;
        // D s_2351_2: cast zx s_2351_1 -> bv
        let s_2351_2: Bits = Bits::new(s_2351_1 as u128, 32u16);
        // C s_2351_3: const #1s : i64
        let s_2351_3: i64 = 1;
        // C s_2351_4: cast zx s_2351_3 -> i
        let s_2351_4: i128 = (i128::try_from(s_2351_3).unwrap());
        // C s_2351_5: const #0s : i
        let s_2351_5: i128 = 0;
        // C s_2351_6: add s_2351_5 s_2351_4
        let s_2351_6: i128 = (s_2351_5 + s_2351_4);
        // D s_2351_7: bit-extract s_2351_2 s_2351_0 s_2351_6
        let s_2351_7: Bits = (Bits::new(
            ((s_2351_2) >> (s_2351_0)).value(),
            u16::try_from(s_2351_6).unwrap(),
        ));
        // D s_2351_8: cast reint s_2351_7 -> u8
        let s_2351_8: bool = ((s_2351_7.value()) != 0);
        // D s_2351_9: cast zx s_2351_8 -> bv
        let s_2351_9: Bits = Bits::new(s_2351_8 as u128, 1u16);
        // C s_2351_10: const #0u : u8
        let s_2351_10: bool = false;
        // C s_2351_11: cast zx s_2351_10 -> bv
        let s_2351_11: Bits = Bits::new(s_2351_10 as u128, 1u16);
        // D s_2351_12: cmp-eq s_2351_9 s_2351_11
        let s_2351_12: bool = ((s_2351_9) == (s_2351_11));
        // N s_2351_13: branch s_2351_12 b2354 b2352
        if s_2351_12 {
            return block_2354(state, tracer, fn_state);
        } else {
            return block_2352(state, tracer, fn_state);
        };
    }
    fn block_2352<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2352_0: const #0u : u8
        let s_2352_0: bool = false;
        // D s_2352_1: write-var gs#406841 <= s_2352_0
        fn_state.gs_406841 = s_2352_0;
        // N s_2352_2: jump b2353
        return block_2353(state, tracer, fn_state);
    }
    fn block_2353<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2353_0: read-var gs#406841:u8
        let s_2353_0: bool = fn_state.gs_406841;
        // D s_2353_1: write-var gs#406842 <= s_2353_0
        fn_state.gs_406842 = s_2353_0;
        // N s_2353_2: jump b2350
        return block_2350(state, tracer, fn_state);
    }
    fn block_2354<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2354_0: const #4s : i
        let s_2354_0: i128 = 4;
        // D s_2354_1: read-var u#32997:u32
        let s_2354_1: u32 = fn_state.u_32997;
        // D s_2354_2: cast zx s_2354_1 -> bv
        let s_2354_2: Bits = Bits::new(s_2354_1 as u128, 32u16);
        // C s_2354_3: const #1s : i64
        let s_2354_3: i64 = 1;
        // C s_2354_4: cast zx s_2354_3 -> i
        let s_2354_4: i128 = (i128::try_from(s_2354_3).unwrap());
        // C s_2354_5: const #3s : i
        let s_2354_5: i128 = 3;
        // C s_2354_6: add s_2354_5 s_2354_4
        let s_2354_6: i128 = (s_2354_5 + s_2354_4);
        // D s_2354_7: bit-extract s_2354_2 s_2354_0 s_2354_6
        let s_2354_7: Bits = (Bits::new(
            ((s_2354_2) >> (s_2354_0)).value(),
            u16::try_from(s_2354_6).unwrap(),
        ));
        // D s_2354_8: cast reint s_2354_7 -> u8
        let s_2354_8: u8 = (s_2354_7.value() as u8);
        // D s_2354_9: cast zx s_2354_8 -> bv
        let s_2354_9: Bits = Bits::new(s_2354_8 as u128, 4u16);
        // C s_2354_10: const #11u : u8
        let s_2354_10: u8 = 11;
        // C s_2354_11: cast zx s_2354_10 -> bv
        let s_2354_11: Bits = Bits::new(s_2354_10 as u128, 4u16);
        // D s_2354_12: cmp-eq s_2354_9 s_2354_11
        let s_2354_12: bool = ((s_2354_9) == (s_2354_11));
        // D s_2354_13: write-var gs#406841 <= s_2354_12
        fn_state.gs_406841 = s_2354_12;
        // N s_2354_14: jump b2353
        return block_2353(state, tracer, fn_state);
    }
    fn block_2355<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2355_0: const #28s : i
        let s_2355_0: i128 = 28;
        // C s_2355_1: const #4s : i
        let s_2355_1: i128 = 4;
        // D s_2355_2: read-var u#32991:u32
        let s_2355_2: u32 = fn_state.u_32991;
        // D s_2355_3: cast zx s_2355_2 -> bv
        let s_2355_3: Bits = Bits::new(s_2355_2 as u128, 32u16);
        // D s_2355_4: bit-extract s_2355_3 s_2355_0 s_2355_1
        let s_2355_4: Bits = (Bits::new(
            ((s_2355_3) >> (s_2355_0)).value(),
            u16::try_from(s_2355_1).unwrap(),
        ));
        // D s_2355_5: cast reint s_2355_4 -> u8
        let s_2355_5: u8 = (s_2355_4.value() as u8);
        // D s_2355_6: cast zx s_2355_5 -> bv
        let s_2355_6: Bits = Bits::new(s_2355_5 as u128, 4u16);
        // C s_2355_7: const #15u : u8
        let s_2355_7: u8 = 15;
        // C s_2355_8: cast zx s_2355_7 -> bv
        let s_2355_8: Bits = Bits::new(s_2355_7 as u128, 4u16);
        // D s_2355_9: cmp-ne s_2355_6 s_2355_8
        let s_2355_9: bool = ((s_2355_6) != (s_2355_8));
        // N s_2355_10: branch s_2355_9 b2358 b2356
        if s_2355_9 {
            return block_2358(state, tracer, fn_state);
        } else {
            return block_2356(state, tracer, fn_state);
        };
    }
    fn block_2356<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2356_0: const #0u : u8
        let s_2356_0: bool = false;
        // D s_2356_1: write-var gs#406815 <= s_2356_0
        fn_state.gs_406815 = s_2356_0;
        // N s_2356_2: jump b2357
        return block_2357(state, tracer, fn_state);
    }
    fn block_2357<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2357_0: read-var gs#406815:u8
        let s_2357_0: bool = fn_state.gs_406815;
        // D s_2357_1: write-var gs#406816 <= s_2357_0
        fn_state.gs_406816 = s_2357_0;
        // N s_2357_2: jump b1112
        return block_1112(state, tracer, fn_state);
    }
    fn block_2358<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2358_0: const #3212s : i
        let s_2358_0: i128 = 3212;
        // C s_2358_1: const #14696u : u32
        let s_2358_1: u32 = 14696;
        // D s_2358_2: read-reg s_2358_1:i
        let s_2358_2: i128 = {
            let value = state.read_register::<i128>(s_2358_1 as isize);
            tracer.read_register(s_2358_1 as isize, value);
            value
        };
        // D s_2358_3: cmp-lt s_2358_2 s_2358_0
        let s_2358_3: bool = ((s_2358_2) < (s_2358_0));
        // D s_2358_4: write-var gs#406815 <= s_2358_3
        fn_state.gs_406815 = s_2358_3;
        // N s_2358_5: jump b2357
        return block_2357(state, tracer, fn_state);
    }
    fn block_2359<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2359_0: const #4s : i
        let s_2359_0: i128 = 4;
        // D s_2359_1: read-var u#32991:u32
        let s_2359_1: u32 = fn_state.u_32991;
        // D s_2359_2: cast zx s_2359_1 -> bv
        let s_2359_2: Bits = Bits::new(s_2359_1 as u128, 32u16);
        // C s_2359_3: const #1s : i64
        let s_2359_3: i64 = 1;
        // C s_2359_4: cast zx s_2359_3 -> i
        let s_2359_4: i128 = (i128::try_from(s_2359_3).unwrap());
        // C s_2359_5: const #7s : i
        let s_2359_5: i128 = 7;
        // C s_2359_6: add s_2359_5 s_2359_4
        let s_2359_6: i128 = (s_2359_5 + s_2359_4);
        // D s_2359_7: bit-extract s_2359_2 s_2359_0 s_2359_6
        let s_2359_7: Bits = (Bits::new(
            ((s_2359_2) >> (s_2359_0)).value(),
            u16::try_from(s_2359_6).unwrap(),
        ));
        // D s_2359_8: cast reint s_2359_7 -> u8
        let s_2359_8: u8 = (s_2359_7.value() as u8);
        // D s_2359_9: cast zx s_2359_8 -> bv
        let s_2359_9: Bits = Bits::new(s_2359_8 as u128, 8u16);
        // C s_2359_10: const #249u : u8
        let s_2359_10: u8 = 249;
        // C s_2359_11: cast zx s_2359_10 -> bv
        let s_2359_11: Bits = Bits::new(s_2359_10 as u128, 8u16);
        // D s_2359_12: cmp-eq s_2359_9 s_2359_11
        let s_2359_12: bool = ((s_2359_9) == (s_2359_11));
        // D s_2359_13: write-var gs#406811 <= s_2359_12
        fn_state.gs_406811 = s_2359_12;
        // N s_2359_14: jump b1110
        return block_1110(state, tracer, fn_state);
    }
    fn block_2360<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2360_0: const #28s : i
        let s_2360_0: i128 = 28;
        // C s_2360_1: const #4s : i
        let s_2360_1: i128 = 4;
        // D s_2360_2: read-var u#32985:u32
        let s_2360_2: u32 = fn_state.u_32985;
        // D s_2360_3: cast zx s_2360_2 -> bv
        let s_2360_3: Bits = Bits::new(s_2360_2 as u128, 32u16);
        // D s_2360_4: bit-extract s_2360_3 s_2360_0 s_2360_1
        let s_2360_4: Bits = (Bits::new(
            ((s_2360_3) >> (s_2360_0)).value(),
            u16::try_from(s_2360_1).unwrap(),
        ));
        // D s_2360_5: cast reint s_2360_4 -> u8
        let s_2360_5: u8 = (s_2360_4.value() as u8);
        // D s_2360_6: cast zx s_2360_5 -> bv
        let s_2360_6: Bits = Bits::new(s_2360_5 as u128, 4u16);
        // C s_2360_7: const #15u : u8
        let s_2360_7: u8 = 15;
        // C s_2360_8: cast zx s_2360_7 -> bv
        let s_2360_8: Bits = Bits::new(s_2360_7 as u128, 4u16);
        // D s_2360_9: cmp-ne s_2360_6 s_2360_8
        let s_2360_9: bool = ((s_2360_6) != (s_2360_8));
        // N s_2360_10: branch s_2360_9 b2363 b2361
        if s_2360_9 {
            return block_2363(state, tracer, fn_state);
        } else {
            return block_2361(state, tracer, fn_state);
        };
    }
    fn block_2361<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2361_0: const #0u : u8
        let s_2361_0: bool = false;
        // D s_2361_1: write-var gs#406789 <= s_2361_0
        fn_state.gs_406789 = s_2361_0;
        // N s_2361_2: jump b2362
        return block_2362(state, tracer, fn_state);
    }
    fn block_2362<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2362_0: read-var gs#406789:u8
        let s_2362_0: bool = fn_state.gs_406789;
        // D s_2362_1: write-var gs#406790 <= s_2362_0
        fn_state.gs_406790 = s_2362_0;
        // N s_2362_2: jump b1101
        return block_1101(state, tracer, fn_state);
    }
    fn block_2363<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2363_0: const #3210s : i
        let s_2363_0: i128 = 3210;
        // C s_2363_1: const #14696u : u32
        let s_2363_1: u32 = 14696;
        // D s_2363_2: read-reg s_2363_1:i
        let s_2363_2: i128 = {
            let value = state.read_register::<i128>(s_2363_1 as isize);
            tracer.read_register(s_2363_1 as isize, value);
            value
        };
        // D s_2363_3: cmp-lt s_2363_2 s_2363_0
        let s_2363_3: bool = ((s_2363_2) < (s_2363_0));
        // D s_2363_4: write-var gs#406789 <= s_2363_3
        fn_state.gs_406789 = s_2363_3;
        // N s_2363_5: jump b2362
        return block_2362(state, tracer, fn_state);
    }
    fn block_2364<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2364_0: const #4s : i
        let s_2364_0: i128 = 4;
        // D s_2364_1: read-var u#32985:u32
        let s_2364_1: u32 = fn_state.u_32985;
        // D s_2364_2: cast zx s_2364_1 -> bv
        let s_2364_2: Bits = Bits::new(s_2364_1 as u128, 32u16);
        // C s_2364_3: const #1s : i64
        let s_2364_3: i64 = 1;
        // C s_2364_4: cast zx s_2364_3 -> i
        let s_2364_4: i128 = (i128::try_from(s_2364_3).unwrap());
        // C s_2364_5: const #7s : i
        let s_2364_5: i128 = 7;
        // C s_2364_6: add s_2364_5 s_2364_4
        let s_2364_6: i128 = (s_2364_5 + s_2364_4);
        // D s_2364_7: bit-extract s_2364_2 s_2364_0 s_2364_6
        let s_2364_7: Bits = (Bits::new(
            ((s_2364_2) >> (s_2364_0)).value(),
            u16::try_from(s_2364_6).unwrap(),
        ));
        // D s_2364_8: cast reint s_2364_7 -> u8
        let s_2364_8: u8 = (s_2364_7.value() as u8);
        // D s_2364_9: cast zx s_2364_8 -> bv
        let s_2364_9: Bits = Bits::new(s_2364_8 as u128, 8u16);
        // C s_2364_10: const #249u : u8
        let s_2364_10: u8 = 249;
        // C s_2364_11: cast zx s_2364_10 -> bv
        let s_2364_11: Bits = Bits::new(s_2364_10 as u128, 8u16);
        // D s_2364_12: cmp-eq s_2364_9 s_2364_11
        let s_2364_12: bool = ((s_2364_9) == (s_2364_11));
        // D s_2364_13: write-var gs#406785 <= s_2364_12
        fn_state.gs_406785 = s_2364_12;
        // N s_2364_14: jump b1099
        return block_1099(state, tracer, fn_state);
    }
    fn block_2365<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2365_0: const #28s : i
        let s_2365_0: i128 = 28;
        // C s_2365_1: const #4s : i
        let s_2365_1: i128 = 4;
        // D s_2365_2: read-var u#32979:u32
        let s_2365_2: u32 = fn_state.u_32979;
        // D s_2365_3: cast zx s_2365_2 -> bv
        let s_2365_3: Bits = Bits::new(s_2365_2 as u128, 32u16);
        // D s_2365_4: bit-extract s_2365_3 s_2365_0 s_2365_1
        let s_2365_4: Bits = (Bits::new(
            ((s_2365_3) >> (s_2365_0)).value(),
            u16::try_from(s_2365_1).unwrap(),
        ));
        // D s_2365_5: cast reint s_2365_4 -> u8
        let s_2365_5: u8 = (s_2365_4.value() as u8);
        // D s_2365_6: cast zx s_2365_5 -> bv
        let s_2365_6: Bits = Bits::new(s_2365_5 as u128, 4u16);
        // C s_2365_7: const #15u : u8
        let s_2365_7: u8 = 15;
        // C s_2365_8: cast zx s_2365_7 -> bv
        let s_2365_8: Bits = Bits::new(s_2365_7 as u128, 4u16);
        // D s_2365_9: cmp-ne s_2365_6 s_2365_8
        let s_2365_9: bool = ((s_2365_6) != (s_2365_8));
        // N s_2365_10: branch s_2365_9 b2368 b2366
        if s_2365_9 {
            return block_2368(state, tracer, fn_state);
        } else {
            return block_2366(state, tracer, fn_state);
        };
    }
    fn block_2366<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2366_0: const #0u : u8
        let s_2366_0: bool = false;
        // D s_2366_1: write-var gs#406763 <= s_2366_0
        fn_state.gs_406763 = s_2366_0;
        // N s_2366_2: jump b2367
        return block_2367(state, tracer, fn_state);
    }
    fn block_2367<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2367_0: read-var gs#406763:u8
        let s_2367_0: bool = fn_state.gs_406763;
        // D s_2367_1: write-var gs#406764 <= s_2367_0
        fn_state.gs_406764 = s_2367_0;
        // N s_2367_2: jump b1090
        return block_1090(state, tracer, fn_state);
    }
    fn block_2368<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2368_0: const #3208s : i
        let s_2368_0: i128 = 3208;
        // C s_2368_1: const #14696u : u32
        let s_2368_1: u32 = 14696;
        // D s_2368_2: read-reg s_2368_1:i
        let s_2368_2: i128 = {
            let value = state.read_register::<i128>(s_2368_1 as isize);
            tracer.read_register(s_2368_1 as isize, value);
            value
        };
        // D s_2368_3: cmp-lt s_2368_2 s_2368_0
        let s_2368_3: bool = ((s_2368_2) < (s_2368_0));
        // D s_2368_4: write-var gs#406763 <= s_2368_3
        fn_state.gs_406763 = s_2368_3;
        // N s_2368_5: jump b2367
        return block_2367(state, tracer, fn_state);
    }
    fn block_2369<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2369_0: const #4s : i
        let s_2369_0: i128 = 4;
        // D s_2369_1: read-var u#32979:u32
        let s_2369_1: u32 = fn_state.u_32979;
        // D s_2369_2: cast zx s_2369_1 -> bv
        let s_2369_2: Bits = Bits::new(s_2369_1 as u128, 32u16);
        // C s_2369_3: const #1s : i64
        let s_2369_3: i64 = 1;
        // C s_2369_4: cast zx s_2369_3 -> i
        let s_2369_4: i128 = (i128::try_from(s_2369_3).unwrap());
        // C s_2369_5: const #7s : i
        let s_2369_5: i128 = 7;
        // C s_2369_6: add s_2369_5 s_2369_4
        let s_2369_6: i128 = (s_2369_5 + s_2369_4);
        // D s_2369_7: bit-extract s_2369_2 s_2369_0 s_2369_6
        let s_2369_7: Bits = (Bits::new(
            ((s_2369_2) >> (s_2369_0)).value(),
            u16::try_from(s_2369_6).unwrap(),
        ));
        // D s_2369_8: cast reint s_2369_7 -> u8
        let s_2369_8: u8 = (s_2369_7.value() as u8);
        // D s_2369_9: cast zx s_2369_8 -> bv
        let s_2369_9: Bits = Bits::new(s_2369_8 as u128, 8u16);
        // C s_2369_10: const #249u : u8
        let s_2369_10: u8 = 249;
        // C s_2369_11: cast zx s_2369_10 -> bv
        let s_2369_11: Bits = Bits::new(s_2369_10 as u128, 8u16);
        // D s_2369_12: cmp-eq s_2369_9 s_2369_11
        let s_2369_12: bool = ((s_2369_9) == (s_2369_11));
        // D s_2369_13: write-var gs#406759 <= s_2369_12
        fn_state.gs_406759 = s_2369_12;
        // N s_2369_14: jump b1088
        return block_1088(state, tracer, fn_state);
    }
    fn block_2370<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2370_0: const #28s : i
        let s_2370_0: i128 = 28;
        // C s_2370_1: const #4s : i
        let s_2370_1: i128 = 4;
        // D s_2370_2: read-var u#32973:u32
        let s_2370_2: u32 = fn_state.u_32973;
        // D s_2370_3: cast zx s_2370_2 -> bv
        let s_2370_3: Bits = Bits::new(s_2370_2 as u128, 32u16);
        // D s_2370_4: bit-extract s_2370_3 s_2370_0 s_2370_1
        let s_2370_4: Bits = (Bits::new(
            ((s_2370_3) >> (s_2370_0)).value(),
            u16::try_from(s_2370_1).unwrap(),
        ));
        // D s_2370_5: cast reint s_2370_4 -> u8
        let s_2370_5: u8 = (s_2370_4.value() as u8);
        // D s_2370_6: cast zx s_2370_5 -> bv
        let s_2370_6: Bits = Bits::new(s_2370_5 as u128, 4u16);
        // C s_2370_7: const #15u : u8
        let s_2370_7: u8 = 15;
        // C s_2370_8: cast zx s_2370_7 -> bv
        let s_2370_8: Bits = Bits::new(s_2370_7 as u128, 4u16);
        // D s_2370_9: cmp-ne s_2370_6 s_2370_8
        let s_2370_9: bool = ((s_2370_6) != (s_2370_8));
        // N s_2370_10: branch s_2370_9 b2373 b2371
        if s_2370_9 {
            return block_2373(state, tracer, fn_state);
        } else {
            return block_2371(state, tracer, fn_state);
        };
    }
    fn block_2371<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2371_0: const #0u : u8
        let s_2371_0: bool = false;
        // D s_2371_1: write-var gs#406737 <= s_2371_0
        fn_state.gs_406737 = s_2371_0;
        // N s_2371_2: jump b2372
        return block_2372(state, tracer, fn_state);
    }
    fn block_2372<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2372_0: read-var gs#406737:u8
        let s_2372_0: bool = fn_state.gs_406737;
        // D s_2372_1: write-var gs#406738 <= s_2372_0
        fn_state.gs_406738 = s_2372_0;
        // N s_2372_2: jump b1079
        return block_1079(state, tracer, fn_state);
    }
    fn block_2373<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2373_0: const #3206s : i
        let s_2373_0: i128 = 3206;
        // C s_2373_1: const #14696u : u32
        let s_2373_1: u32 = 14696;
        // D s_2373_2: read-reg s_2373_1:i
        let s_2373_2: i128 = {
            let value = state.read_register::<i128>(s_2373_1 as isize);
            tracer.read_register(s_2373_1 as isize, value);
            value
        };
        // D s_2373_3: cmp-lt s_2373_2 s_2373_0
        let s_2373_3: bool = ((s_2373_2) < (s_2373_0));
        // D s_2373_4: write-var gs#406737 <= s_2373_3
        fn_state.gs_406737 = s_2373_3;
        // N s_2373_5: jump b2372
        return block_2372(state, tracer, fn_state);
    }
    fn block_2374<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2374_0: const #4s : i
        let s_2374_0: i128 = 4;
        // D s_2374_1: read-var u#32973:u32
        let s_2374_1: u32 = fn_state.u_32973;
        // D s_2374_2: cast zx s_2374_1 -> bv
        let s_2374_2: Bits = Bits::new(s_2374_1 as u128, 32u16);
        // C s_2374_3: const #1s : i64
        let s_2374_3: i64 = 1;
        // C s_2374_4: cast zx s_2374_3 -> i
        let s_2374_4: i128 = (i128::try_from(s_2374_3).unwrap());
        // C s_2374_5: const #7s : i
        let s_2374_5: i128 = 7;
        // C s_2374_6: add s_2374_5 s_2374_4
        let s_2374_6: i128 = (s_2374_5 + s_2374_4);
        // D s_2374_7: bit-extract s_2374_2 s_2374_0 s_2374_6
        let s_2374_7: Bits = (Bits::new(
            ((s_2374_2) >> (s_2374_0)).value(),
            u16::try_from(s_2374_6).unwrap(),
        ));
        // D s_2374_8: cast reint s_2374_7 -> u8
        let s_2374_8: u8 = (s_2374_7.value() as u8);
        // D s_2374_9: cast zx s_2374_8 -> bv
        let s_2374_9: Bits = Bits::new(s_2374_8 as u128, 8u16);
        // C s_2374_10: const #249u : u8
        let s_2374_10: u8 = 249;
        // C s_2374_11: cast zx s_2374_10 -> bv
        let s_2374_11: Bits = Bits::new(s_2374_10 as u128, 8u16);
        // D s_2374_12: cmp-eq s_2374_9 s_2374_11
        let s_2374_12: bool = ((s_2374_9) == (s_2374_11));
        // D s_2374_13: write-var gs#406733 <= s_2374_12
        fn_state.gs_406733 = s_2374_12;
        // N s_2374_14: jump b1077
        return block_1077(state, tracer, fn_state);
    }
    fn block_2375<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2375_0: const #28s : i
        let s_2375_0: i128 = 28;
        // C s_2375_1: const #4s : i
        let s_2375_1: i128 = 4;
        // D s_2375_2: read-var u#32964:u32
        let s_2375_2: u32 = fn_state.u_32964;
        // D s_2375_3: cast zx s_2375_2 -> bv
        let s_2375_3: Bits = Bits::new(s_2375_2 as u128, 32u16);
        // D s_2375_4: bit-extract s_2375_3 s_2375_0 s_2375_1
        let s_2375_4: Bits = (Bits::new(
            ((s_2375_3) >> (s_2375_0)).value(),
            u16::try_from(s_2375_1).unwrap(),
        ));
        // D s_2375_5: cast reint s_2375_4 -> u8
        let s_2375_5: u8 = (s_2375_4.value() as u8);
        // D s_2375_6: cast zx s_2375_5 -> bv
        let s_2375_6: Bits = Bits::new(s_2375_5 as u128, 4u16);
        // C s_2375_7: const #15u : u8
        let s_2375_7: u8 = 15;
        // C s_2375_8: cast zx s_2375_7 -> bv
        let s_2375_8: Bits = Bits::new(s_2375_7 as u128, 4u16);
        // D s_2375_9: cmp-ne s_2375_6 s_2375_8
        let s_2375_9: bool = ((s_2375_6) != (s_2375_8));
        // N s_2375_10: branch s_2375_9 b2378 b2376
        if s_2375_9 {
            return block_2378(state, tracer, fn_state);
        } else {
            return block_2376(state, tracer, fn_state);
        };
    }
    fn block_2376<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2376_0: const #0u : u8
        let s_2376_0: bool = false;
        // D s_2376_1: write-var gs#406699 <= s_2376_0
        fn_state.gs_406699 = s_2376_0;
        // N s_2376_2: jump b2377
        return block_2377(state, tracer, fn_state);
    }
    fn block_2377<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2377_0: read-var gs#406699:u8
        let s_2377_0: bool = fn_state.gs_406699;
        // D s_2377_1: write-var gs#406700 <= s_2377_0
        fn_state.gs_406700 = s_2377_0;
        // N s_2377_2: jump b1062
        return block_1062(state, tracer, fn_state);
    }
    fn block_2378<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2378_0: const #3205s : i
        let s_2378_0: i128 = 3205;
        // C s_2378_1: const #14696u : u32
        let s_2378_1: u32 = 14696;
        // D s_2378_2: read-reg s_2378_1:i
        let s_2378_2: i128 = {
            let value = state.read_register::<i128>(s_2378_1 as isize);
            tracer.read_register(s_2378_1 as isize, value);
            value
        };
        // D s_2378_3: cmp-lt s_2378_2 s_2378_0
        let s_2378_3: bool = ((s_2378_2) < (s_2378_0));
        // D s_2378_4: write-var gs#406699 <= s_2378_3
        fn_state.gs_406699 = s_2378_3;
        // N s_2378_5: jump b2377
        return block_2377(state, tracer, fn_state);
    }
    fn block_2379<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2379_0: const #22s : i
        let s_2379_0: i128 = 22;
        // D s_2379_1: read-var u#32964:u32
        let s_2379_1: u32 = fn_state.u_32964;
        // D s_2379_2: cast zx s_2379_1 -> bv
        let s_2379_2: Bits = Bits::new(s_2379_1 as u128, 32u16);
        // C s_2379_3: const #1s : i64
        let s_2379_3: i64 = 1;
        // C s_2379_4: cast zx s_2379_3 -> i
        let s_2379_4: i128 = (i128::try_from(s_2379_3).unwrap());
        // C s_2379_5: const #0s : i
        let s_2379_5: i128 = 0;
        // C s_2379_6: add s_2379_5 s_2379_4
        let s_2379_6: i128 = (s_2379_5 + s_2379_4);
        // D s_2379_7: bit-extract s_2379_2 s_2379_0 s_2379_6
        let s_2379_7: Bits = (Bits::new(
            ((s_2379_2) >> (s_2379_0)).value(),
            u16::try_from(s_2379_6).unwrap(),
        ));
        // D s_2379_8: cast reint s_2379_7 -> u8
        let s_2379_8: bool = ((s_2379_7.value()) != 0);
        // D s_2379_9: cast zx s_2379_8 -> bv
        let s_2379_9: Bits = Bits::new(s_2379_8 as u128, 1u16);
        // C s_2379_10: const #0u : u8
        let s_2379_10: bool = false;
        // C s_2379_11: cast zx s_2379_10 -> bv
        let s_2379_11: Bits = Bits::new(s_2379_10 as u128, 1u16);
        // D s_2379_12: cmp-eq s_2379_9 s_2379_11
        let s_2379_12: bool = ((s_2379_9) == (s_2379_11));
        // N s_2379_13: branch s_2379_12 b2382 b2380
        if s_2379_12 {
            return block_2382(state, tracer, fn_state);
        } else {
            return block_2380(state, tracer, fn_state);
        };
    }
    fn block_2380<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2380_0: const #0u : u8
        let s_2380_0: bool = false;
        // D s_2380_1: write-var gs#406694 <= s_2380_0
        fn_state.gs_406694 = s_2380_0;
        // N s_2380_2: jump b2381
        return block_2381(state, tracer, fn_state);
    }
    fn block_2381<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2381_0: read-var gs#406694:u8
        let s_2381_0: bool = fn_state.gs_406694;
        // D s_2381_1: write-var gs#406695 <= s_2381_0
        fn_state.gs_406695 = s_2381_0;
        // N s_2381_2: jump b1060
        return block_1060(state, tracer, fn_state);
    }
    fn block_2382<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2382_0: const #20s : i
        let s_2382_0: i128 = 20;
        // D s_2382_1: read-var u#32964:u32
        let s_2382_1: u32 = fn_state.u_32964;
        // D s_2382_2: cast zx s_2382_1 -> bv
        let s_2382_2: Bits = Bits::new(s_2382_1 as u128, 32u16);
        // C s_2382_3: const #1s : i64
        let s_2382_3: i64 = 1;
        // C s_2382_4: cast zx s_2382_3 -> i
        let s_2382_4: i128 = (i128::try_from(s_2382_3).unwrap());
        // C s_2382_5: const #0s : i
        let s_2382_5: i128 = 0;
        // C s_2382_6: add s_2382_5 s_2382_4
        let s_2382_6: i128 = (s_2382_5 + s_2382_4);
        // D s_2382_7: bit-extract s_2382_2 s_2382_0 s_2382_6
        let s_2382_7: Bits = (Bits::new(
            ((s_2382_2) >> (s_2382_0)).value(),
            u16::try_from(s_2382_6).unwrap(),
        ));
        // D s_2382_8: cast reint s_2382_7 -> u8
        let s_2382_8: bool = ((s_2382_7.value()) != 0);
        // D s_2382_9: cast zx s_2382_8 -> bv
        let s_2382_9: Bits = Bits::new(s_2382_8 as u128, 1u16);
        // C s_2382_10: const #0u : u8
        let s_2382_10: bool = false;
        // C s_2382_11: cast zx s_2382_10 -> bv
        let s_2382_11: Bits = Bits::new(s_2382_10 as u128, 1u16);
        // D s_2382_12: cmp-eq s_2382_9 s_2382_11
        let s_2382_12: bool = ((s_2382_9) == (s_2382_11));
        // N s_2382_13: branch s_2382_12 b2385 b2383
        if s_2382_12 {
            return block_2385(state, tracer, fn_state);
        } else {
            return block_2383(state, tracer, fn_state);
        };
    }
    fn block_2383<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2383_0: const #0u : u8
        let s_2383_0: bool = false;
        // D s_2383_1: write-var gs#406693 <= s_2383_0
        fn_state.gs_406693 = s_2383_0;
        // N s_2383_2: jump b2384
        return block_2384(state, tracer, fn_state);
    }
    fn block_2384<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2384_0: read-var gs#406693:u8
        let s_2384_0: bool = fn_state.gs_406693;
        // D s_2384_1: write-var gs#406694 <= s_2384_0
        fn_state.gs_406694 = s_2384_0;
        // N s_2384_2: jump b2381
        return block_2381(state, tracer, fn_state);
    }
    fn block_2385<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2385_0: const #4s : i
        let s_2385_0: i128 = 4;
        // D s_2385_1: read-var u#32964:u32
        let s_2385_1: u32 = fn_state.u_32964;
        // D s_2385_2: cast zx s_2385_1 -> bv
        let s_2385_2: Bits = Bits::new(s_2385_1 as u128, 32u16);
        // C s_2385_3: const #1s : i64
        let s_2385_3: i64 = 1;
        // C s_2385_4: cast zx s_2385_3 -> i
        let s_2385_4: i128 = (i128::try_from(s_2385_3).unwrap());
        // C s_2385_5: const #7s : i
        let s_2385_5: i128 = 7;
        // C s_2385_6: add s_2385_5 s_2385_4
        let s_2385_6: i128 = (s_2385_5 + s_2385_4);
        // D s_2385_7: bit-extract s_2385_2 s_2385_0 s_2385_6
        let s_2385_7: Bits = (Bits::new(
            ((s_2385_2) >> (s_2385_0)).value(),
            u16::try_from(s_2385_6).unwrap(),
        ));
        // D s_2385_8: cast reint s_2385_7 -> u8
        let s_2385_8: u8 = (s_2385_7.value() as u8);
        // D s_2385_9: cast zx s_2385_8 -> bv
        let s_2385_9: Bits = Bits::new(s_2385_8 as u128, 8u16);
        // C s_2385_10: const #15u : u8
        let s_2385_10: u8 = 15;
        // C s_2385_11: cast zx s_2385_10 -> bv
        let s_2385_11: Bits = Bits::new(s_2385_10 as u128, 8u16);
        // D s_2385_12: cmp-eq s_2385_9 s_2385_11
        let s_2385_12: bool = ((s_2385_9) == (s_2385_11));
        // D s_2385_13: write-var gs#406693 <= s_2385_12
        fn_state.gs_406693 = s_2385_12;
        // N s_2385_14: jump b2384
        return block_2384(state, tracer, fn_state);
    }
    fn block_2386<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2386_0: const #28s : i
        let s_2386_0: i128 = 28;
        // C s_2386_1: const #4s : i
        let s_2386_1: i128 = 4;
        // D s_2386_2: read-var u#32954:u32
        let s_2386_2: u32 = fn_state.u_32954;
        // D s_2386_3: cast zx s_2386_2 -> bv
        let s_2386_3: Bits = Bits::new(s_2386_2 as u128, 32u16);
        // D s_2386_4: bit-extract s_2386_3 s_2386_0 s_2386_1
        let s_2386_4: Bits = (Bits::new(
            ((s_2386_3) >> (s_2386_0)).value(),
            u16::try_from(s_2386_1).unwrap(),
        ));
        // D s_2386_5: cast reint s_2386_4 -> u8
        let s_2386_5: u8 = (s_2386_4.value() as u8);
        // D s_2386_6: cast zx s_2386_5 -> bv
        let s_2386_6: Bits = Bits::new(s_2386_5 as u128, 4u16);
        // C s_2386_7: const #15u : u8
        let s_2386_7: u8 = 15;
        // C s_2386_8: cast zx s_2386_7 -> bv
        let s_2386_8: Bits = Bits::new(s_2386_7 as u128, 4u16);
        // D s_2386_9: cmp-ne s_2386_6 s_2386_8
        let s_2386_9: bool = ((s_2386_6) != (s_2386_8));
        // N s_2386_10: branch s_2386_9 b2389 b2387
        if s_2386_9 {
            return block_2389(state, tracer, fn_state);
        } else {
            return block_2387(state, tracer, fn_state);
        };
    }
    fn block_2387<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2387_0: const #0u : u8
        let s_2387_0: bool = false;
        // D s_2387_1: write-var gs#406664 <= s_2387_0
        fn_state.gs_406664 = s_2387_0;
        // N s_2387_2: jump b2388
        return block_2388(state, tracer, fn_state);
    }
    fn block_2388<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2388_0: read-var gs#406664:u8
        let s_2388_0: bool = fn_state.gs_406664;
        // D s_2388_1: write-var gs#406665 <= s_2388_0
        fn_state.gs_406665 = s_2388_0;
        // N s_2388_2: jump b1056
        return block_1056(state, tracer, fn_state);
    }
    fn block_2389<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2389_0: const #3203s : i
        let s_2389_0: i128 = 3203;
        // C s_2389_1: const #14696u : u32
        let s_2389_1: u32 = 14696;
        // D s_2389_2: read-reg s_2389_1:i
        let s_2389_2: i128 = {
            let value = state.read_register::<i128>(s_2389_1 as isize);
            tracer.read_register(s_2389_1 as isize, value);
            value
        };
        // D s_2389_3: cmp-lt s_2389_2 s_2389_0
        let s_2389_3: bool = ((s_2389_2) < (s_2389_0));
        // D s_2389_4: write-var gs#406664 <= s_2389_3
        fn_state.gs_406664 = s_2389_3;
        // N s_2389_5: jump b2388
        return block_2388(state, tracer, fn_state);
    }
    fn block_2390<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2390_0: const #22s : i
        let s_2390_0: i128 = 22;
        // D s_2390_1: read-var u#32954:u32
        let s_2390_1: u32 = fn_state.u_32954;
        // D s_2390_2: cast zx s_2390_1 -> bv
        let s_2390_2: Bits = Bits::new(s_2390_1 as u128, 32u16);
        // C s_2390_3: const #1s : i64
        let s_2390_3: i64 = 1;
        // C s_2390_4: cast zx s_2390_3 -> i
        let s_2390_4: i128 = (i128::try_from(s_2390_3).unwrap());
        // C s_2390_5: const #0s : i
        let s_2390_5: i128 = 0;
        // C s_2390_6: add s_2390_5 s_2390_4
        let s_2390_6: i128 = (s_2390_5 + s_2390_4);
        // D s_2390_7: bit-extract s_2390_2 s_2390_0 s_2390_6
        let s_2390_7: Bits = (Bits::new(
            ((s_2390_2) >> (s_2390_0)).value(),
            u16::try_from(s_2390_6).unwrap(),
        ));
        // D s_2390_8: cast reint s_2390_7 -> u8
        let s_2390_8: bool = ((s_2390_7.value()) != 0);
        // D s_2390_9: cast zx s_2390_8 -> bv
        let s_2390_9: Bits = Bits::new(s_2390_8 as u128, 1u16);
        // C s_2390_10: const #1u : u8
        let s_2390_10: bool = true;
        // C s_2390_11: cast zx s_2390_10 -> bv
        let s_2390_11: Bits = Bits::new(s_2390_10 as u128, 1u16);
        // D s_2390_12: cmp-eq s_2390_9 s_2390_11
        let s_2390_12: bool = ((s_2390_9) == (s_2390_11));
        // N s_2390_13: branch s_2390_12 b2393 b2391
        if s_2390_12 {
            return block_2393(state, tracer, fn_state);
        } else {
            return block_2391(state, tracer, fn_state);
        };
    }
    fn block_2391<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2391_0: const #0u : u8
        let s_2391_0: bool = false;
        // D s_2391_1: write-var gs#406659 <= s_2391_0
        fn_state.gs_406659 = s_2391_0;
        // N s_2391_2: jump b2392
        return block_2392(state, tracer, fn_state);
    }
    fn block_2392<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2392_0: read-var gs#406659:u8
        let s_2392_0: bool = fn_state.gs_406659;
        // D s_2392_1: write-var gs#406660 <= s_2392_0
        fn_state.gs_406660 = s_2392_0;
        // N s_2392_2: jump b1054
        return block_1054(state, tracer, fn_state);
    }
    fn block_2393<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2393_0: const #20s : i
        let s_2393_0: i128 = 20;
        // D s_2393_1: read-var u#32954:u32
        let s_2393_1: u32 = fn_state.u_32954;
        // D s_2393_2: cast zx s_2393_1 -> bv
        let s_2393_2: Bits = Bits::new(s_2393_1 as u128, 32u16);
        // C s_2393_3: const #1s : i64
        let s_2393_3: i64 = 1;
        // C s_2393_4: cast zx s_2393_3 -> i
        let s_2393_4: i128 = (i128::try_from(s_2393_3).unwrap());
        // C s_2393_5: const #0s : i
        let s_2393_5: i128 = 0;
        // C s_2393_6: add s_2393_5 s_2393_4
        let s_2393_6: i128 = (s_2393_5 + s_2393_4);
        // D s_2393_7: bit-extract s_2393_2 s_2393_0 s_2393_6
        let s_2393_7: Bits = (Bits::new(
            ((s_2393_2) >> (s_2393_0)).value(),
            u16::try_from(s_2393_6).unwrap(),
        ));
        // D s_2393_8: cast reint s_2393_7 -> u8
        let s_2393_8: bool = ((s_2393_7.value()) != 0);
        // D s_2393_9: cast zx s_2393_8 -> bv
        let s_2393_9: Bits = Bits::new(s_2393_8 as u128, 1u16);
        // C s_2393_10: const #0u : u8
        let s_2393_10: bool = false;
        // C s_2393_11: cast zx s_2393_10 -> bv
        let s_2393_11: Bits = Bits::new(s_2393_10 as u128, 1u16);
        // D s_2393_12: cmp-eq s_2393_9 s_2393_11
        let s_2393_12: bool = ((s_2393_9) == (s_2393_11));
        // N s_2393_13: branch s_2393_12 b2396 b2394
        if s_2393_12 {
            return block_2396(state, tracer, fn_state);
        } else {
            return block_2394(state, tracer, fn_state);
        };
    }
    fn block_2394<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2394_0: const #0u : u8
        let s_2394_0: bool = false;
        // D s_2394_1: write-var gs#406658 <= s_2394_0
        fn_state.gs_406658 = s_2394_0;
        // N s_2394_2: jump b2395
        return block_2395(state, tracer, fn_state);
    }
    fn block_2395<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2395_0: read-var gs#406658:u8
        let s_2395_0: bool = fn_state.gs_406658;
        // D s_2395_1: write-var gs#406659 <= s_2395_0
        fn_state.gs_406659 = s_2395_0;
        // N s_2395_2: jump b2392
        return block_2392(state, tracer, fn_state);
    }
    fn block_2396<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2396_0: const #4s : i
        let s_2396_0: i128 = 4;
        // D s_2396_1: read-var u#32954:u32
        let s_2396_1: u32 = fn_state.u_32954;
        // D s_2396_2: cast zx s_2396_1 -> bv
        let s_2396_2: Bits = Bits::new(s_2396_1 as u128, 32u16);
        // C s_2396_3: const #1s : i64
        let s_2396_3: i64 = 1;
        // C s_2396_4: cast zx s_2396_3 -> i
        let s_2396_4: i128 = (i128::try_from(s_2396_3).unwrap());
        // C s_2396_5: const #3s : i
        let s_2396_5: i128 = 3;
        // C s_2396_6: add s_2396_5 s_2396_4
        let s_2396_6: i128 = (s_2396_5 + s_2396_4);
        // D s_2396_7: bit-extract s_2396_2 s_2396_0 s_2396_6
        let s_2396_7: Bits = (Bits::new(
            ((s_2396_2) >> (s_2396_0)).value(),
            u16::try_from(s_2396_6).unwrap(),
        ));
        // D s_2396_8: cast reint s_2396_7 -> u8
        let s_2396_8: u8 = (s_2396_7.value() as u8);
        // D s_2396_9: cast zx s_2396_8 -> bv
        let s_2396_9: Bits = Bits::new(s_2396_8 as u128, 4u16);
        // C s_2396_10: const #15u : u8
        let s_2396_10: u8 = 15;
        // C s_2396_11: cast zx s_2396_10 -> bv
        let s_2396_11: Bits = Bits::new(s_2396_10 as u128, 4u16);
        // D s_2396_12: cmp-eq s_2396_9 s_2396_11
        let s_2396_12: bool = ((s_2396_9) == (s_2396_11));
        // D s_2396_13: write-var gs#406658 <= s_2396_12
        fn_state.gs_406658 = s_2396_12;
        // N s_2396_14: jump b2395
        return block_2395(state, tracer, fn_state);
    }
    fn block_2397<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2397_0: const #28s : i
        let s_2397_0: i128 = 28;
        // C s_2397_1: const #4s : i
        let s_2397_1: i128 = 4;
        // D s_2397_2: read-var u#32947:u32
        let s_2397_2: u32 = fn_state.u_32947;
        // D s_2397_3: cast zx s_2397_2 -> bv
        let s_2397_3: Bits = Bits::new(s_2397_2 as u128, 32u16);
        // D s_2397_4: bit-extract s_2397_3 s_2397_0 s_2397_1
        let s_2397_4: Bits = (Bits::new(
            ((s_2397_3) >> (s_2397_0)).value(),
            u16::try_from(s_2397_1).unwrap(),
        ));
        // D s_2397_5: cast reint s_2397_4 -> u8
        let s_2397_5: u8 = (s_2397_4.value() as u8);
        // D s_2397_6: cast zx s_2397_5 -> bv
        let s_2397_6: Bits = Bits::new(s_2397_5 as u128, 4u16);
        // C s_2397_7: const #15u : u8
        let s_2397_7: u8 = 15;
        // C s_2397_8: cast zx s_2397_7 -> bv
        let s_2397_8: Bits = Bits::new(s_2397_7 as u128, 4u16);
        // D s_2397_9: cmp-ne s_2397_6 s_2397_8
        let s_2397_9: bool = ((s_2397_6) != (s_2397_8));
        // N s_2397_10: branch s_2397_9 b2400 b2398
        if s_2397_9 {
            return block_2400(state, tracer, fn_state);
        } else {
            return block_2398(state, tracer, fn_state);
        };
    }
    fn block_2398<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2398_0: const #0u : u8
        let s_2398_0: bool = false;
        // D s_2398_1: write-var gs#406624 <= s_2398_0
        fn_state.gs_406624 = s_2398_0;
        // N s_2398_2: jump b2399
        return block_2399(state, tracer, fn_state);
    }
    fn block_2399<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2399_0: read-var gs#406624:u8
        let s_2399_0: bool = fn_state.gs_406624;
        // D s_2399_1: write-var gs#406625 <= s_2399_0
        fn_state.gs_406625 = s_2399_0;
        // N s_2399_2: jump b1039
        return block_1039(state, tracer, fn_state);
    }
    fn block_2400<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2400_0: const #3170s : i
        let s_2400_0: i128 = 3170;
        // C s_2400_1: const #14696u : u32
        let s_2400_1: u32 = 14696;
        // D s_2400_2: read-reg s_2400_1:i
        let s_2400_2: i128 = {
            let value = state.read_register::<i128>(s_2400_1 as isize);
            tracer.read_register(s_2400_1 as isize, value);
            value
        };
        // D s_2400_3: cmp-lt s_2400_2 s_2400_0
        let s_2400_3: bool = ((s_2400_2) < (s_2400_0));
        // D s_2400_4: write-var gs#406624 <= s_2400_3
        fn_state.gs_406624 = s_2400_3;
        // N s_2400_5: jump b2399
        return block_2399(state, tracer, fn_state);
    }
    fn block_2401<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2401_0: const #12s : i
        let s_2401_0: i128 = 12;
        // D s_2401_1: read-var u#32947:u32
        let s_2401_1: u32 = fn_state.u_32947;
        // D s_2401_2: cast zx s_2401_1 -> bv
        let s_2401_2: Bits = Bits::new(s_2401_1 as u128, 32u16);
        // C s_2401_3: const #1s : i64
        let s_2401_3: i64 = 1;
        // C s_2401_4: cast zx s_2401_3 -> i
        let s_2401_4: i128 = (i128::try_from(s_2401_3).unwrap());
        // C s_2401_5: const #3s : i
        let s_2401_5: i128 = 3;
        // C s_2401_6: add s_2401_5 s_2401_4
        let s_2401_6: i128 = (s_2401_5 + s_2401_4);
        // D s_2401_7: bit-extract s_2401_2 s_2401_0 s_2401_6
        let s_2401_7: Bits = (Bits::new(
            ((s_2401_2) >> (s_2401_0)).value(),
            u16::try_from(s_2401_6).unwrap(),
        ));
        // D s_2401_8: cast reint s_2401_7 -> u8
        let s_2401_8: u8 = (s_2401_7.value() as u8);
        // D s_2401_9: cast zx s_2401_8 -> bv
        let s_2401_9: Bits = Bits::new(s_2401_8 as u128, 4u16);
        // C s_2401_10: const #0u : u8
        let s_2401_10: u8 = 0;
        // C s_2401_11: cast zx s_2401_10 -> bv
        let s_2401_11: Bits = Bits::new(s_2401_10 as u128, 4u16);
        // D s_2401_12: cmp-eq s_2401_9 s_2401_11
        let s_2401_12: bool = ((s_2401_9) == (s_2401_11));
        // N s_2401_13: branch s_2401_12 b2404 b2402
        if s_2401_12 {
            return block_2404(state, tracer, fn_state);
        } else {
            return block_2402(state, tracer, fn_state);
        };
    }
    fn block_2402<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2402_0: const #0u : u8
        let s_2402_0: bool = false;
        // D s_2402_1: write-var gs#406619 <= s_2402_0
        fn_state.gs_406619 = s_2402_0;
        // N s_2402_2: jump b2403
        return block_2403(state, tracer, fn_state);
    }
    fn block_2403<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2403_0: read-var gs#406619:u8
        let s_2403_0: bool = fn_state.gs_406619;
        // D s_2403_1: write-var gs#406620 <= s_2403_0
        fn_state.gs_406620 = s_2403_0;
        // N s_2403_2: jump b1037
        return block_1037(state, tracer, fn_state);
    }
    fn block_2404<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2404_0: const #7s : i
        let s_2404_0: i128 = 7;
        // D s_2404_1: read-var u#32947:u32
        let s_2404_1: u32 = fn_state.u_32947;
        // D s_2404_2: cast zx s_2404_1 -> bv
        let s_2404_2: Bits = Bits::new(s_2404_1 as u128, 32u16);
        // C s_2404_3: const #1s : i64
        let s_2404_3: i64 = 1;
        // C s_2404_4: cast zx s_2404_3 -> i
        let s_2404_4: i128 = (i128::try_from(s_2404_3).unwrap());
        // C s_2404_5: const #0s : i
        let s_2404_5: i128 = 0;
        // C s_2404_6: add s_2404_5 s_2404_4
        let s_2404_6: i128 = (s_2404_5 + s_2404_4);
        // D s_2404_7: bit-extract s_2404_2 s_2404_0 s_2404_6
        let s_2404_7: Bits = (Bits::new(
            ((s_2404_2) >> (s_2404_0)).value(),
            u16::try_from(s_2404_6).unwrap(),
        ));
        // D s_2404_8: cast reint s_2404_7 -> u8
        let s_2404_8: bool = ((s_2404_7.value()) != 0);
        // D s_2404_9: cast zx s_2404_8 -> bv
        let s_2404_9: Bits = Bits::new(s_2404_8 as u128, 1u16);
        // C s_2404_10: const #1u : u8
        let s_2404_10: bool = true;
        // C s_2404_11: cast zx s_2404_10 -> bv
        let s_2404_11: Bits = Bits::new(s_2404_10 as u128, 1u16);
        // D s_2404_12: cmp-eq s_2404_9 s_2404_11
        let s_2404_12: bool = ((s_2404_9) == (s_2404_11));
        // N s_2404_13: branch s_2404_12 b2407 b2405
        if s_2404_12 {
            return block_2407(state, tracer, fn_state);
        } else {
            return block_2405(state, tracer, fn_state);
        };
    }
    fn block_2405<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2405_0: const #0u : u8
        let s_2405_0: bool = false;
        // D s_2405_1: write-var gs#406618 <= s_2405_0
        fn_state.gs_406618 = s_2405_0;
        // N s_2405_2: jump b2406
        return block_2406(state, tracer, fn_state);
    }
    fn block_2406<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2406_0: read-var gs#406618:u8
        let s_2406_0: bool = fn_state.gs_406618;
        // D s_2406_1: write-var gs#406619 <= s_2406_0
        fn_state.gs_406619 = s_2406_0;
        // N s_2406_2: jump b2403
        return block_2403(state, tracer, fn_state);
    }
    fn block_2407<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2407_0: const #4s : i
        let s_2407_0: i128 = 4;
        // D s_2407_1: read-var u#32947:u32
        let s_2407_1: u32 = fn_state.u_32947;
        // D s_2407_2: cast zx s_2407_1 -> bv
        let s_2407_2: Bits = Bits::new(s_2407_1 as u128, 32u16);
        // C s_2407_3: const #1s : i64
        let s_2407_3: i64 = 1;
        // C s_2407_4: cast zx s_2407_3 -> i
        let s_2407_4: i128 = (i128::try_from(s_2407_3).unwrap());
        // C s_2407_5: const #1s : i
        let s_2407_5: i128 = 1;
        // C s_2407_6: add s_2407_5 s_2407_4
        let s_2407_6: i128 = (s_2407_5 + s_2407_4);
        // D s_2407_7: bit-extract s_2407_2 s_2407_0 s_2407_6
        let s_2407_7: Bits = (Bits::new(
            ((s_2407_2) >> (s_2407_0)).value(),
            u16::try_from(s_2407_6).unwrap(),
        ));
        // D s_2407_8: cast reint s_2407_7 -> u8
        let s_2407_8: u8 = (s_2407_7.value() as u8);
        // D s_2407_9: cast zx s_2407_8 -> bv
        let s_2407_9: Bits = Bits::new(s_2407_8 as u128, 2u16);
        // C s_2407_10: const #2u : u8
        let s_2407_10: u8 = 2;
        // C s_2407_11: cast zx s_2407_10 -> bv
        let s_2407_11: Bits = Bits::new(s_2407_10 as u128, 2u16);
        // D s_2407_12: cmp-eq s_2407_9 s_2407_11
        let s_2407_12: bool = ((s_2407_9) == (s_2407_11));
        // D s_2407_13: write-var gs#406618 <= s_2407_12
        fn_state.gs_406618 = s_2407_12;
        // N s_2407_14: jump b2406
        return block_2406(state, tracer, fn_state);
    }
    fn block_2408<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2408_0: const #28s : i
        let s_2408_0: i128 = 28;
        // C s_2408_1: const #4s : i
        let s_2408_1: i128 = 4;
        // D s_2408_2: read-var u#32939:u32
        let s_2408_2: u32 = fn_state.u_32939;
        // D s_2408_3: cast zx s_2408_2 -> bv
        let s_2408_3: Bits = Bits::new(s_2408_2 as u128, 32u16);
        // D s_2408_4: bit-extract s_2408_3 s_2408_0 s_2408_1
        let s_2408_4: Bits = (Bits::new(
            ((s_2408_3) >> (s_2408_0)).value(),
            u16::try_from(s_2408_1).unwrap(),
        ));
        // D s_2408_5: cast reint s_2408_4 -> u8
        let s_2408_5: u8 = (s_2408_4.value() as u8);
        // D s_2408_6: cast zx s_2408_5 -> bv
        let s_2408_6: Bits = Bits::new(s_2408_5 as u128, 4u16);
        // C s_2408_7: const #15u : u8
        let s_2408_7: u8 = 15;
        // C s_2408_8: cast zx s_2408_7 -> bv
        let s_2408_8: Bits = Bits::new(s_2408_7 as u128, 4u16);
        // D s_2408_9: cmp-ne s_2408_6 s_2408_8
        let s_2408_9: bool = ((s_2408_6) != (s_2408_8));
        // N s_2408_10: branch s_2408_9 b2411 b2409
        if s_2408_9 {
            return block_2411(state, tracer, fn_state);
        } else {
            return block_2409(state, tracer, fn_state);
        };
    }
    fn block_2409<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2409_0: const #0u : u8
        let s_2409_0: bool = false;
        // D s_2409_1: write-var gs#406593 <= s_2409_0
        fn_state.gs_406593 = s_2409_0;
        // N s_2409_2: jump b2410
        return block_2410(state, tracer, fn_state);
    }
    fn block_2410<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2410_0: read-var gs#406593:u8
        let s_2410_0: bool = fn_state.gs_406593;
        // D s_2410_1: write-var gs#406594 <= s_2410_0
        fn_state.gs_406594 = s_2410_0;
        // N s_2410_2: jump b1033
        return block_1033(state, tracer, fn_state);
    }
    fn block_2411<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2411_0: const #3168s : i
        let s_2411_0: i128 = 3168;
        // C s_2411_1: const #14696u : u32
        let s_2411_1: u32 = 14696;
        // D s_2411_2: read-reg s_2411_1:i
        let s_2411_2: i128 = {
            let value = state.read_register::<i128>(s_2411_1 as isize);
            tracer.read_register(s_2411_1 as isize, value);
            value
        };
        // D s_2411_3: cmp-lt s_2411_2 s_2411_0
        let s_2411_3: bool = ((s_2411_2) < (s_2411_0));
        // D s_2411_4: write-var gs#406593 <= s_2411_3
        fn_state.gs_406593 = s_2411_3;
        // N s_2411_5: jump b2410
        return block_2410(state, tracer, fn_state);
    }
    fn block_2412<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2412_0: const #4s : i
        let s_2412_0: i128 = 4;
        // D s_2412_1: read-var u#32939:u32
        let s_2412_1: u32 = fn_state.u_32939;
        // D s_2412_2: cast zx s_2412_1 -> bv
        let s_2412_2: Bits = Bits::new(s_2412_1 as u128, 32u16);
        // C s_2412_3: const #1s : i64
        let s_2412_3: i64 = 1;
        // C s_2412_4: cast zx s_2412_3 -> i
        let s_2412_4: i128 = (i128::try_from(s_2412_3).unwrap());
        // C s_2412_5: const #3s : i
        let s_2412_5: i128 = 3;
        // C s_2412_6: add s_2412_5 s_2412_4
        let s_2412_6: i128 = (s_2412_5 + s_2412_4);
        // D s_2412_7: bit-extract s_2412_2 s_2412_0 s_2412_6
        let s_2412_7: Bits = (Bits::new(
            ((s_2412_2) >> (s_2412_0)).value(),
            u16::try_from(s_2412_6).unwrap(),
        ));
        // D s_2412_8: cast reint s_2412_7 -> u8
        let s_2412_8: u8 = (s_2412_7.value() as u8);
        // D s_2412_9: cast zx s_2412_8 -> bv
        let s_2412_9: Bits = Bits::new(s_2412_8 as u128, 4u16);
        // C s_2412_10: const #9u : u8
        let s_2412_10: u8 = 9;
        // C s_2412_11: cast zx s_2412_10 -> bv
        let s_2412_11: Bits = Bits::new(s_2412_10 as u128, 4u16);
        // D s_2412_12: cmp-eq s_2412_9 s_2412_11
        let s_2412_12: bool = ((s_2412_9) == (s_2412_11));
        // D s_2412_13: write-var gs#406589 <= s_2412_12
        fn_state.gs_406589 = s_2412_12;
        // N s_2412_14: jump b1031
        return block_1031(state, tracer, fn_state);
    }
    fn block_2413<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2413_0: const #28s : i
        let s_2413_0: i128 = 28;
        // C s_2413_1: const #4s : i
        let s_2413_1: i128 = 4;
        // D s_2413_2: read-var u#32931:u32
        let s_2413_2: u32 = fn_state.u_32931;
        // D s_2413_3: cast zx s_2413_2 -> bv
        let s_2413_3: Bits = Bits::new(s_2413_2 as u128, 32u16);
        // D s_2413_4: bit-extract s_2413_3 s_2413_0 s_2413_1
        let s_2413_4: Bits = (Bits::new(
            ((s_2413_3) >> (s_2413_0)).value(),
            u16::try_from(s_2413_1).unwrap(),
        ));
        // D s_2413_5: cast reint s_2413_4 -> u8
        let s_2413_5: u8 = (s_2413_4.value() as u8);
        // D s_2413_6: cast zx s_2413_5 -> bv
        let s_2413_6: Bits = Bits::new(s_2413_5 as u128, 4u16);
        // C s_2413_7: const #15u : u8
        let s_2413_7: u8 = 15;
        // C s_2413_8: cast zx s_2413_7 -> bv
        let s_2413_8: Bits = Bits::new(s_2413_7 as u128, 4u16);
        // D s_2413_9: cmp-ne s_2413_6 s_2413_8
        let s_2413_9: bool = ((s_2413_6) != (s_2413_8));
        // N s_2413_10: branch s_2413_9 b2416 b2414
        if s_2413_9 {
            return block_2416(state, tracer, fn_state);
        } else {
            return block_2414(state, tracer, fn_state);
        };
    }
    fn block_2414<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2414_0: const #0u : u8
        let s_2414_0: bool = false;
        // D s_2414_1: write-var gs#406557 <= s_2414_0
        fn_state.gs_406557 = s_2414_0;
        // N s_2414_2: jump b2415
        return block_2415(state, tracer, fn_state);
    }
    fn block_2415<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2415_0: read-var gs#406557:u8
        let s_2415_0: bool = fn_state.gs_406557;
        // D s_2415_1: write-var gs#406558 <= s_2415_0
        fn_state.gs_406558 = s_2415_0;
        // N s_2415_2: jump b1016
        return block_1016(state, tracer, fn_state);
    }
    fn block_2416<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2416_0: const #3166s : i
        let s_2416_0: i128 = 3166;
        // C s_2416_1: const #14696u : u32
        let s_2416_1: u32 = 14696;
        // D s_2416_2: read-reg s_2416_1:i
        let s_2416_2: i128 = {
            let value = state.read_register::<i128>(s_2416_1 as isize);
            tracer.read_register(s_2416_1 as isize, value);
            value
        };
        // D s_2416_3: cmp-lt s_2416_2 s_2416_0
        let s_2416_3: bool = ((s_2416_2) < (s_2416_0));
        // D s_2416_4: write-var gs#406557 <= s_2416_3
        fn_state.gs_406557 = s_2416_3;
        // N s_2416_5: jump b2415
        return block_2415(state, tracer, fn_state);
    }
    fn block_2417<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2417_0: const #12s : i
        let s_2417_0: i128 = 12;
        // D s_2417_1: read-var u#32931:u32
        let s_2417_1: u32 = fn_state.u_32931;
        // D s_2417_2: cast zx s_2417_1 -> bv
        let s_2417_2: Bits = Bits::new(s_2417_1 as u128, 32u16);
        // C s_2417_3: const #1s : i64
        let s_2417_3: i64 = 1;
        // C s_2417_4: cast zx s_2417_3 -> i
        let s_2417_4: i128 = (i128::try_from(s_2417_3).unwrap());
        // C s_2417_5: const #3s : i
        let s_2417_5: i128 = 3;
        // C s_2417_6: add s_2417_5 s_2417_4
        let s_2417_6: i128 = (s_2417_5 + s_2417_4);
        // D s_2417_7: bit-extract s_2417_2 s_2417_0 s_2417_6
        let s_2417_7: Bits = (Bits::new(
            ((s_2417_2) >> (s_2417_0)).value(),
            u16::try_from(s_2417_6).unwrap(),
        ));
        // D s_2417_8: cast reint s_2417_7 -> u8
        let s_2417_8: u8 = (s_2417_7.value() as u8);
        // D s_2417_9: cast zx s_2417_8 -> bv
        let s_2417_9: Bits = Bits::new(s_2417_8 as u128, 4u16);
        // C s_2417_10: const #0u : u8
        let s_2417_10: u8 = 0;
        // C s_2417_11: cast zx s_2417_10 -> bv
        let s_2417_11: Bits = Bits::new(s_2417_10 as u128, 4u16);
        // D s_2417_12: cmp-eq s_2417_9 s_2417_11
        let s_2417_12: bool = ((s_2417_9) == (s_2417_11));
        // N s_2417_13: branch s_2417_12 b2420 b2418
        if s_2417_12 {
            return block_2420(state, tracer, fn_state);
        } else {
            return block_2418(state, tracer, fn_state);
        };
    }
    fn block_2418<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2418_0: const #0u : u8
        let s_2418_0: bool = false;
        // D s_2418_1: write-var gs#406552 <= s_2418_0
        fn_state.gs_406552 = s_2418_0;
        // N s_2418_2: jump b2419
        return block_2419(state, tracer, fn_state);
    }
    fn block_2419<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2419_0: read-var gs#406552:u8
        let s_2419_0: bool = fn_state.gs_406552;
        // D s_2419_1: write-var gs#406553 <= s_2419_0
        fn_state.gs_406553 = s_2419_0;
        // N s_2419_2: jump b1014
        return block_1014(state, tracer, fn_state);
    }
    fn block_2420<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2420_0: const #7s : i
        let s_2420_0: i128 = 7;
        // D s_2420_1: read-var u#32931:u32
        let s_2420_1: u32 = fn_state.u_32931;
        // D s_2420_2: cast zx s_2420_1 -> bv
        let s_2420_2: Bits = Bits::new(s_2420_1 as u128, 32u16);
        // C s_2420_3: const #1s : i64
        let s_2420_3: i64 = 1;
        // C s_2420_4: cast zx s_2420_3 -> i
        let s_2420_4: i128 = (i128::try_from(s_2420_3).unwrap());
        // C s_2420_5: const #0s : i
        let s_2420_5: i128 = 0;
        // C s_2420_6: add s_2420_5 s_2420_4
        let s_2420_6: i128 = (s_2420_5 + s_2420_4);
        // D s_2420_7: bit-extract s_2420_2 s_2420_0 s_2420_6
        let s_2420_7: Bits = (Bits::new(
            ((s_2420_2) >> (s_2420_0)).value(),
            u16::try_from(s_2420_6).unwrap(),
        ));
        // D s_2420_8: cast reint s_2420_7 -> u8
        let s_2420_8: bool = ((s_2420_7.value()) != 0);
        // D s_2420_9: cast zx s_2420_8 -> bv
        let s_2420_9: Bits = Bits::new(s_2420_8 as u128, 1u16);
        // C s_2420_10: const #1u : u8
        let s_2420_10: bool = true;
        // C s_2420_11: cast zx s_2420_10 -> bv
        let s_2420_11: Bits = Bits::new(s_2420_10 as u128, 1u16);
        // D s_2420_12: cmp-eq s_2420_9 s_2420_11
        let s_2420_12: bool = ((s_2420_9) == (s_2420_11));
        // N s_2420_13: branch s_2420_12 b2423 b2421
        if s_2420_12 {
            return block_2423(state, tracer, fn_state);
        } else {
            return block_2421(state, tracer, fn_state);
        };
    }
    fn block_2421<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2421_0: const #0u : u8
        let s_2421_0: bool = false;
        // D s_2421_1: write-var gs#406551 <= s_2421_0
        fn_state.gs_406551 = s_2421_0;
        // N s_2421_2: jump b2422
        return block_2422(state, tracer, fn_state);
    }
    fn block_2422<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2422_0: read-var gs#406551:u8
        let s_2422_0: bool = fn_state.gs_406551;
        // D s_2422_1: write-var gs#406552 <= s_2422_0
        fn_state.gs_406552 = s_2422_0;
        // N s_2422_2: jump b2419
        return block_2419(state, tracer, fn_state);
    }
    fn block_2423<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2423_0: const #4s : i
        let s_2423_0: i128 = 4;
        // D s_2423_1: read-var u#32931:u32
        let s_2423_1: u32 = fn_state.u_32931;
        // D s_2423_2: cast zx s_2423_1 -> bv
        let s_2423_2: Bits = Bits::new(s_2423_1 as u128, 32u16);
        // C s_2423_3: const #1s : i64
        let s_2423_3: i64 = 1;
        // C s_2423_4: cast zx s_2423_3 -> i
        let s_2423_4: i128 = (i128::try_from(s_2423_3).unwrap());
        // C s_2423_5: const #0s : i
        let s_2423_5: i128 = 0;
        // C s_2423_6: add s_2423_5 s_2423_4
        let s_2423_6: i128 = (s_2423_5 + s_2423_4);
        // D s_2423_7: bit-extract s_2423_2 s_2423_0 s_2423_6
        let s_2423_7: Bits = (Bits::new(
            ((s_2423_2) >> (s_2423_0)).value(),
            u16::try_from(s_2423_6).unwrap(),
        ));
        // D s_2423_8: cast reint s_2423_7 -> u8
        let s_2423_8: bool = ((s_2423_7.value()) != 0);
        // D s_2423_9: cast zx s_2423_8 -> bv
        let s_2423_9: Bits = Bits::new(s_2423_8 as u128, 1u16);
        // C s_2423_10: const #0u : u8
        let s_2423_10: bool = false;
        // C s_2423_11: cast zx s_2423_10 -> bv
        let s_2423_11: Bits = Bits::new(s_2423_10 as u128, 1u16);
        // D s_2423_12: cmp-eq s_2423_9 s_2423_11
        let s_2423_12: bool = ((s_2423_9) == (s_2423_11));
        // D s_2423_13: write-var gs#406551 <= s_2423_12
        fn_state.gs_406551 = s_2423_12;
        // N s_2423_14: jump b2422
        return block_2422(state, tracer, fn_state);
    }
    fn block_2424<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2424_0: const #28s : i
        let s_2424_0: i128 = 28;
        // C s_2424_1: const #4s : i
        let s_2424_1: i128 = 4;
        // D s_2424_2: read-var u#32923:u32
        let s_2424_2: u32 = fn_state.u_32923;
        // D s_2424_3: cast zx s_2424_2 -> bv
        let s_2424_3: Bits = Bits::new(s_2424_2 as u128, 32u16);
        // D s_2424_4: bit-extract s_2424_3 s_2424_0 s_2424_1
        let s_2424_4: Bits = (Bits::new(
            ((s_2424_3) >> (s_2424_0)).value(),
            u16::try_from(s_2424_1).unwrap(),
        ));
        // D s_2424_5: cast reint s_2424_4 -> u8
        let s_2424_5: u8 = (s_2424_4.value() as u8);
        // D s_2424_6: cast zx s_2424_5 -> bv
        let s_2424_6: Bits = Bits::new(s_2424_5 as u128, 4u16);
        // C s_2424_7: const #15u : u8
        let s_2424_7: u8 = 15;
        // C s_2424_8: cast zx s_2424_7 -> bv
        let s_2424_8: Bits = Bits::new(s_2424_7 as u128, 4u16);
        // D s_2424_9: cmp-ne s_2424_6 s_2424_8
        let s_2424_9: bool = ((s_2424_6) != (s_2424_8));
        // N s_2424_10: branch s_2424_9 b2427 b2425
        if s_2424_9 {
            return block_2427(state, tracer, fn_state);
        } else {
            return block_2425(state, tracer, fn_state);
        };
    }
    fn block_2425<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2425_0: const #0u : u8
        let s_2425_0: bool = false;
        // D s_2425_1: write-var gs#406526 <= s_2425_0
        fn_state.gs_406526 = s_2425_0;
        // N s_2425_2: jump b2426
        return block_2426(state, tracer, fn_state);
    }
    fn block_2426<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2426_0: read-var gs#406526:u8
        let s_2426_0: bool = fn_state.gs_406526;
        // D s_2426_1: write-var gs#406527 <= s_2426_0
        fn_state.gs_406527 = s_2426_0;
        // N s_2426_2: jump b1010
        return block_1010(state, tracer, fn_state);
    }
    fn block_2427<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2427_0: const #3152s : i
        let s_2427_0: i128 = 3152;
        // C s_2427_1: const #14696u : u32
        let s_2427_1: u32 = 14696;
        // D s_2427_2: read-reg s_2427_1:i
        let s_2427_2: i128 = {
            let value = state.read_register::<i128>(s_2427_1 as isize);
            tracer.read_register(s_2427_1 as isize, value);
            value
        };
        // D s_2427_3: cmp-lt s_2427_2 s_2427_0
        let s_2427_3: bool = ((s_2427_2) < (s_2427_0));
        // D s_2427_4: write-var gs#406526 <= s_2427_3
        fn_state.gs_406526 = s_2427_3;
        // N s_2427_5: jump b2426
        return block_2426(state, tracer, fn_state);
    }
    fn block_2428<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2428_0: const #7s : i
        let s_2428_0: i128 = 7;
        // D s_2428_1: read-var u#32923:u32
        let s_2428_1: u32 = fn_state.u_32923;
        // D s_2428_2: cast zx s_2428_1 -> bv
        let s_2428_2: Bits = Bits::new(s_2428_1 as u128, 32u16);
        // C s_2428_3: const #1s : i64
        let s_2428_3: i64 = 1;
        // C s_2428_4: cast zx s_2428_3 -> i
        let s_2428_4: i128 = (i128::try_from(s_2428_3).unwrap());
        // C s_2428_5: const #0s : i
        let s_2428_5: i128 = 0;
        // C s_2428_6: add s_2428_5 s_2428_4
        let s_2428_6: i128 = (s_2428_5 + s_2428_4);
        // D s_2428_7: bit-extract s_2428_2 s_2428_0 s_2428_6
        let s_2428_7: Bits = (Bits::new(
            ((s_2428_2) >> (s_2428_0)).value(),
            u16::try_from(s_2428_6).unwrap(),
        ));
        // D s_2428_8: cast reint s_2428_7 -> u8
        let s_2428_8: bool = ((s_2428_7.value()) != 0);
        // D s_2428_9: cast zx s_2428_8 -> bv
        let s_2428_9: Bits = Bits::new(s_2428_8 as u128, 1u16);
        // C s_2428_10: const #1u : u8
        let s_2428_10: bool = true;
        // C s_2428_11: cast zx s_2428_10 -> bv
        let s_2428_11: Bits = Bits::new(s_2428_10 as u128, 1u16);
        // D s_2428_12: cmp-eq s_2428_9 s_2428_11
        let s_2428_12: bool = ((s_2428_9) == (s_2428_11));
        // N s_2428_13: branch s_2428_12 b2431 b2429
        if s_2428_12 {
            return block_2431(state, tracer, fn_state);
        } else {
            return block_2429(state, tracer, fn_state);
        };
    }
    fn block_2429<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2429_0: const #0u : u8
        let s_2429_0: bool = false;
        // D s_2429_1: write-var gs#406521 <= s_2429_0
        fn_state.gs_406521 = s_2429_0;
        // N s_2429_2: jump b2430
        return block_2430(state, tracer, fn_state);
    }
    fn block_2430<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2430_0: read-var gs#406521:u8
        let s_2430_0: bool = fn_state.gs_406521;
        // D s_2430_1: write-var gs#406522 <= s_2430_0
        fn_state.gs_406522 = s_2430_0;
        // N s_2430_2: jump b1008
        return block_1008(state, tracer, fn_state);
    }
    fn block_2431<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2431_0: const #4s : i
        let s_2431_0: i128 = 4;
        // D s_2431_1: read-var u#32923:u32
        let s_2431_1: u32 = fn_state.u_32923;
        // D s_2431_2: cast zx s_2431_1 -> bv
        let s_2431_2: Bits = Bits::new(s_2431_1 as u128, 32u16);
        // C s_2431_3: const #1s : i64
        let s_2431_3: i64 = 1;
        // C s_2431_4: cast zx s_2431_3 -> i
        let s_2431_4: i128 = (i128::try_from(s_2431_3).unwrap());
        // C s_2431_5: const #1s : i
        let s_2431_5: i128 = 1;
        // C s_2431_6: add s_2431_5 s_2431_4
        let s_2431_6: i128 = (s_2431_5 + s_2431_4);
        // D s_2431_7: bit-extract s_2431_2 s_2431_0 s_2431_6
        let s_2431_7: Bits = (Bits::new(
            ((s_2431_2) >> (s_2431_0)).value(),
            u16::try_from(s_2431_6).unwrap(),
        ));
        // D s_2431_8: cast reint s_2431_7 -> u8
        let s_2431_8: u8 = (s_2431_7.value() as u8);
        // D s_2431_9: cast zx s_2431_8 -> bv
        let s_2431_9: Bits = Bits::new(s_2431_8 as u128, 2u16);
        // C s_2431_10: const #0u : u8
        let s_2431_10: u8 = 0;
        // C s_2431_11: cast zx s_2431_10 -> bv
        let s_2431_11: Bits = Bits::new(s_2431_10 as u128, 2u16);
        // D s_2431_12: cmp-eq s_2431_9 s_2431_11
        let s_2431_12: bool = ((s_2431_9) == (s_2431_11));
        // D s_2431_13: write-var gs#406521 <= s_2431_12
        fn_state.gs_406521 = s_2431_12;
        // N s_2431_14: jump b2430
        return block_2430(state, tracer, fn_state);
    }
    fn block_2432<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2432_0: const #28s : i
        let s_2432_0: i128 = 28;
        // C s_2432_1: const #4s : i
        let s_2432_1: i128 = 4;
        // D s_2432_2: read-var u#32914:u32
        let s_2432_2: u32 = fn_state.u_32914;
        // D s_2432_3: cast zx s_2432_2 -> bv
        let s_2432_3: Bits = Bits::new(s_2432_2 as u128, 32u16);
        // D s_2432_4: bit-extract s_2432_3 s_2432_0 s_2432_1
        let s_2432_4: Bits = (Bits::new(
            ((s_2432_3) >> (s_2432_0)).value(),
            u16::try_from(s_2432_1).unwrap(),
        ));
        // D s_2432_5: cast reint s_2432_4 -> u8
        let s_2432_5: u8 = (s_2432_4.value() as u8);
        // D s_2432_6: cast zx s_2432_5 -> bv
        let s_2432_6: Bits = Bits::new(s_2432_5 as u128, 4u16);
        // C s_2432_7: const #15u : u8
        let s_2432_7: u8 = 15;
        // C s_2432_8: cast zx s_2432_7 -> bv
        let s_2432_8: Bits = Bits::new(s_2432_7 as u128, 4u16);
        // D s_2432_9: cmp-ne s_2432_6 s_2432_8
        let s_2432_9: bool = ((s_2432_6) != (s_2432_8));
        // N s_2432_10: branch s_2432_9 b2435 b2433
        if s_2432_9 {
            return block_2435(state, tracer, fn_state);
        } else {
            return block_2433(state, tracer, fn_state);
        };
    }
    fn block_2433<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2433_0: const #0u : u8
        let s_2433_0: bool = false;
        // D s_2433_1: write-var gs#406496 <= s_2433_0
        fn_state.gs_406496 = s_2433_0;
        // N s_2433_2: jump b2434
        return block_2434(state, tracer, fn_state);
    }
    fn block_2434<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2434_0: read-var gs#406496:u8
        let s_2434_0: bool = fn_state.gs_406496;
        // D s_2434_1: write-var gs#406497 <= s_2434_0
        fn_state.gs_406497 = s_2434_0;
        // N s_2434_2: jump b1004
        return block_1004(state, tracer, fn_state);
    }
    fn block_2435<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2435_0: const #3148s : i
        let s_2435_0: i128 = 3148;
        // C s_2435_1: const #14696u : u32
        let s_2435_1: u32 = 14696;
        // D s_2435_2: read-reg s_2435_1:i
        let s_2435_2: i128 = {
            let value = state.read_register::<i128>(s_2435_1 as isize);
            tracer.read_register(s_2435_1 as isize, value);
            value
        };
        // D s_2435_3: cmp-lt s_2435_2 s_2435_0
        let s_2435_3: bool = ((s_2435_2) < (s_2435_0));
        // D s_2435_4: write-var gs#406496 <= s_2435_3
        fn_state.gs_406496 = s_2435_3;
        // N s_2435_5: jump b2434
        return block_2434(state, tracer, fn_state);
    }
    fn block_2436<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2436_0: const #7s : i
        let s_2436_0: i128 = 7;
        // D s_2436_1: read-var u#32914:u32
        let s_2436_1: u32 = fn_state.u_32914;
        // D s_2436_2: cast zx s_2436_1 -> bv
        let s_2436_2: Bits = Bits::new(s_2436_1 as u128, 32u16);
        // C s_2436_3: const #1s : i64
        let s_2436_3: i64 = 1;
        // C s_2436_4: cast zx s_2436_3 -> i
        let s_2436_4: i128 = (i128::try_from(s_2436_3).unwrap());
        // C s_2436_5: const #0s : i
        let s_2436_5: i128 = 0;
        // C s_2436_6: add s_2436_5 s_2436_4
        let s_2436_6: i128 = (s_2436_5 + s_2436_4);
        // D s_2436_7: bit-extract s_2436_2 s_2436_0 s_2436_6
        let s_2436_7: Bits = (Bits::new(
            ((s_2436_2) >> (s_2436_0)).value(),
            u16::try_from(s_2436_6).unwrap(),
        ));
        // D s_2436_8: cast reint s_2436_7 -> u8
        let s_2436_8: bool = ((s_2436_7.value()) != 0);
        // D s_2436_9: cast zx s_2436_8 -> bv
        let s_2436_9: Bits = Bits::new(s_2436_8 as u128, 1u16);
        // C s_2436_10: const #1u : u8
        let s_2436_10: bool = true;
        // C s_2436_11: cast zx s_2436_10 -> bv
        let s_2436_11: Bits = Bits::new(s_2436_10 as u128, 1u16);
        // D s_2436_12: cmp-eq s_2436_9 s_2436_11
        let s_2436_12: bool = ((s_2436_9) == (s_2436_11));
        // N s_2436_13: branch s_2436_12 b2439 b2437
        if s_2436_12 {
            return block_2439(state, tracer, fn_state);
        } else {
            return block_2437(state, tracer, fn_state);
        };
    }
    fn block_2437<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2437_0: const #0u : u8
        let s_2437_0: bool = false;
        // D s_2437_1: write-var gs#406491 <= s_2437_0
        fn_state.gs_406491 = s_2437_0;
        // N s_2437_2: jump b2438
        return block_2438(state, tracer, fn_state);
    }
    fn block_2438<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2438_0: read-var gs#406491:u8
        let s_2438_0: bool = fn_state.gs_406491;
        // D s_2438_1: write-var gs#406492 <= s_2438_0
        fn_state.gs_406492 = s_2438_0;
        // N s_2438_2: jump b1002
        return block_1002(state, tracer, fn_state);
    }
    fn block_2439<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2439_0: const #4s : i
        let s_2439_0: i128 = 4;
        // D s_2439_1: read-var u#32914:u32
        let s_2439_1: u32 = fn_state.u_32914;
        // D s_2439_2: cast zx s_2439_1 -> bv
        let s_2439_2: Bits = Bits::new(s_2439_1 as u128, 32u16);
        // C s_2439_3: const #1s : i64
        let s_2439_3: i64 = 1;
        // C s_2439_4: cast zx s_2439_3 -> i
        let s_2439_4: i128 = (i128::try_from(s_2439_3).unwrap());
        // C s_2439_5: const #0s : i
        let s_2439_5: i128 = 0;
        // C s_2439_6: add s_2439_5 s_2439_4
        let s_2439_6: i128 = (s_2439_5 + s_2439_4);
        // D s_2439_7: bit-extract s_2439_2 s_2439_0 s_2439_6
        let s_2439_7: Bits = (Bits::new(
            ((s_2439_2) >> (s_2439_0)).value(),
            u16::try_from(s_2439_6).unwrap(),
        ));
        // D s_2439_8: cast reint s_2439_7 -> u8
        let s_2439_8: bool = ((s_2439_7.value()) != 0);
        // D s_2439_9: cast zx s_2439_8 -> bv
        let s_2439_9: Bits = Bits::new(s_2439_8 as u128, 1u16);
        // C s_2439_10: const #0u : u8
        let s_2439_10: bool = false;
        // C s_2439_11: cast zx s_2439_10 -> bv
        let s_2439_11: Bits = Bits::new(s_2439_10 as u128, 1u16);
        // D s_2439_12: cmp-eq s_2439_9 s_2439_11
        let s_2439_12: bool = ((s_2439_9) == (s_2439_11));
        // D s_2439_13: write-var gs#406491 <= s_2439_12
        fn_state.gs_406491 = s_2439_12;
        // N s_2439_14: jump b2438
        return block_2438(state, tracer, fn_state);
    }
    fn block_2440<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2440_0: const #28s : i
        let s_2440_0: i128 = 28;
        // C s_2440_1: const #4s : i
        let s_2440_1: i128 = 4;
        // D s_2440_2: read-var u#32908:u32
        let s_2440_2: u32 = fn_state.u_32908;
        // D s_2440_3: cast zx s_2440_2 -> bv
        let s_2440_3: Bits = Bits::new(s_2440_2 as u128, 32u16);
        // D s_2440_4: bit-extract s_2440_3 s_2440_0 s_2440_1
        let s_2440_4: Bits = (Bits::new(
            ((s_2440_3) >> (s_2440_0)).value(),
            u16::try_from(s_2440_1).unwrap(),
        ));
        // D s_2440_5: cast reint s_2440_4 -> u8
        let s_2440_5: u8 = (s_2440_4.value() as u8);
        // D s_2440_6: cast zx s_2440_5 -> bv
        let s_2440_6: Bits = Bits::new(s_2440_5 as u128, 4u16);
        // C s_2440_7: const #15u : u8
        let s_2440_7: u8 = 15;
        // C s_2440_8: cast zx s_2440_7 -> bv
        let s_2440_8: Bits = Bits::new(s_2440_7 as u128, 4u16);
        // D s_2440_9: cmp-ne s_2440_6 s_2440_8
        let s_2440_9: bool = ((s_2440_6) != (s_2440_8));
        // N s_2440_10: branch s_2440_9 b2443 b2441
        if s_2440_9 {
            return block_2443(state, tracer, fn_state);
        } else {
            return block_2441(state, tracer, fn_state);
        };
    }
    fn block_2441<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2441_0: const #0u : u8
        let s_2441_0: bool = false;
        // D s_2441_1: write-var gs#406468 <= s_2441_0
        fn_state.gs_406468 = s_2441_0;
        // N s_2441_2: jump b2442
        return block_2442(state, tracer, fn_state);
    }
    fn block_2442<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2442_0: read-var gs#406468:u8
        let s_2442_0: bool = fn_state.gs_406468;
        // D s_2442_1: write-var gs#406469 <= s_2442_0
        fn_state.gs_406469 = s_2442_0;
        // N s_2442_2: jump b998
        return block_998(state, tracer, fn_state);
    }
    fn block_2443<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2443_0: const #3146s : i
        let s_2443_0: i128 = 3146;
        // C s_2443_1: const #14696u : u32
        let s_2443_1: u32 = 14696;
        // D s_2443_2: read-reg s_2443_1:i
        let s_2443_2: i128 = {
            let value = state.read_register::<i128>(s_2443_1 as isize);
            tracer.read_register(s_2443_1 as isize, value);
            value
        };
        // D s_2443_3: cmp-lt s_2443_2 s_2443_0
        let s_2443_3: bool = ((s_2443_2) < (s_2443_0));
        // D s_2443_4: write-var gs#406468 <= s_2443_3
        fn_state.gs_406468 = s_2443_3;
        // N s_2443_5: jump b2442
        return block_2442(state, tracer, fn_state);
    }
    fn block_2444<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2444_0: const #4s : i
        let s_2444_0: i128 = 4;
        // D s_2444_1: read-var u#32908:u32
        let s_2444_1: u32 = fn_state.u_32908;
        // D s_2444_2: cast zx s_2444_1 -> bv
        let s_2444_2: Bits = Bits::new(s_2444_1 as u128, 32u16);
        // C s_2444_3: const #1s : i64
        let s_2444_3: i64 = 1;
        // C s_2444_4: cast zx s_2444_3 -> i
        let s_2444_4: i128 = (i128::try_from(s_2444_3).unwrap());
        // C s_2444_5: const #3s : i
        let s_2444_5: i128 = 3;
        // C s_2444_6: add s_2444_5 s_2444_4
        let s_2444_6: i128 = (s_2444_5 + s_2444_4);
        // D s_2444_7: bit-extract s_2444_2 s_2444_0 s_2444_6
        let s_2444_7: Bits = (Bits::new(
            ((s_2444_2) >> (s_2444_0)).value(),
            u16::try_from(s_2444_6).unwrap(),
        ));
        // D s_2444_8: cast reint s_2444_7 -> u8
        let s_2444_8: u8 = (s_2444_7.value() as u8);
        // D s_2444_9: cast zx s_2444_8 -> bv
        let s_2444_9: Bits = Bits::new(s_2444_8 as u128, 4u16);
        // C s_2444_10: const #9u : u8
        let s_2444_10: u8 = 9;
        // C s_2444_11: cast zx s_2444_10 -> bv
        let s_2444_11: Bits = Bits::new(s_2444_10 as u128, 4u16);
        // D s_2444_12: cmp-eq s_2444_9 s_2444_11
        let s_2444_12: bool = ((s_2444_9) == (s_2444_11));
        // D s_2444_13: write-var gs#406464 <= s_2444_12
        fn_state.gs_406464 = s_2444_12;
        // N s_2444_14: jump b996
        return block_996(state, tracer, fn_state);
    }
    fn block_2445<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2445_0: const #28s : i
        let s_2445_0: i128 = 28;
        // C s_2445_1: const #4s : i
        let s_2445_1: i128 = 4;
        // D s_2445_2: read-var u#32901:u32
        let s_2445_2: u32 = fn_state.u_32901;
        // D s_2445_3: cast zx s_2445_2 -> bv
        let s_2445_3: Bits = Bits::new(s_2445_2 as u128, 32u16);
        // D s_2445_4: bit-extract s_2445_3 s_2445_0 s_2445_1
        let s_2445_4: Bits = (Bits::new(
            ((s_2445_3) >> (s_2445_0)).value(),
            u16::try_from(s_2445_1).unwrap(),
        ));
        // D s_2445_5: cast reint s_2445_4 -> u8
        let s_2445_5: u8 = (s_2445_4.value() as u8);
        // D s_2445_6: cast zx s_2445_5 -> bv
        let s_2445_6: Bits = Bits::new(s_2445_5 as u128, 4u16);
        // C s_2445_7: const #15u : u8
        let s_2445_7: u8 = 15;
        // C s_2445_8: cast zx s_2445_7 -> bv
        let s_2445_8: Bits = Bits::new(s_2445_7 as u128, 4u16);
        // D s_2445_9: cmp-ne s_2445_6 s_2445_8
        let s_2445_9: bool = ((s_2445_6) != (s_2445_8));
        // N s_2445_10: branch s_2445_9 b2448 b2446
        if s_2445_9 {
            return block_2448(state, tracer, fn_state);
        } else {
            return block_2446(state, tracer, fn_state);
        };
    }
    fn block_2446<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2446_0: const #0u : u8
        let s_2446_0: bool = false;
        // D s_2446_1: write-var gs#406441 <= s_2446_0
        fn_state.gs_406441 = s_2446_0;
        // N s_2446_2: jump b2447
        return block_2447(state, tracer, fn_state);
    }
    fn block_2447<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2447_0: read-var gs#406441:u8
        let s_2447_0: bool = fn_state.gs_406441;
        // D s_2447_1: write-var gs#406442 <= s_2447_0
        fn_state.gs_406442 = s_2447_0;
        // N s_2447_2: jump b992
        return block_992(state, tracer, fn_state);
    }
    fn block_2448<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2448_0: const #3142s : i
        let s_2448_0: i128 = 3142;
        // C s_2448_1: const #14696u : u32
        let s_2448_1: u32 = 14696;
        // D s_2448_2: read-reg s_2448_1:i
        let s_2448_2: i128 = {
            let value = state.read_register::<i128>(s_2448_1 as isize);
            tracer.read_register(s_2448_1 as isize, value);
            value
        };
        // D s_2448_3: cmp-lt s_2448_2 s_2448_0
        let s_2448_3: bool = ((s_2448_2) < (s_2448_0));
        // D s_2448_4: write-var gs#406441 <= s_2448_3
        fn_state.gs_406441 = s_2448_3;
        // N s_2448_5: jump b2447
        return block_2447(state, tracer, fn_state);
    }
    fn block_2449<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2449_0: const #7s : i
        let s_2449_0: i128 = 7;
        // D s_2449_1: read-var u#32901:u32
        let s_2449_1: u32 = fn_state.u_32901;
        // D s_2449_2: cast zx s_2449_1 -> bv
        let s_2449_2: Bits = Bits::new(s_2449_1 as u128, 32u16);
        // C s_2449_3: const #1s : i64
        let s_2449_3: i64 = 1;
        // C s_2449_4: cast zx s_2449_3 -> i
        let s_2449_4: i128 = (i128::try_from(s_2449_3).unwrap());
        // C s_2449_5: const #0s : i
        let s_2449_5: i128 = 0;
        // C s_2449_6: add s_2449_5 s_2449_4
        let s_2449_6: i128 = (s_2449_5 + s_2449_4);
        // D s_2449_7: bit-extract s_2449_2 s_2449_0 s_2449_6
        let s_2449_7: Bits = (Bits::new(
            ((s_2449_2) >> (s_2449_0)).value(),
            u16::try_from(s_2449_6).unwrap(),
        ));
        // D s_2449_8: cast reint s_2449_7 -> u8
        let s_2449_8: bool = ((s_2449_7.value()) != 0);
        // D s_2449_9: cast zx s_2449_8 -> bv
        let s_2449_9: Bits = Bits::new(s_2449_8 as u128, 1u16);
        // C s_2449_10: const #1u : u8
        let s_2449_10: bool = true;
        // C s_2449_11: cast zx s_2449_10 -> bv
        let s_2449_11: Bits = Bits::new(s_2449_10 as u128, 1u16);
        // D s_2449_12: cmp-eq s_2449_9 s_2449_11
        let s_2449_12: bool = ((s_2449_9) == (s_2449_11));
        // N s_2449_13: branch s_2449_12 b2452 b2450
        if s_2449_12 {
            return block_2452(state, tracer, fn_state);
        } else {
            return block_2450(state, tracer, fn_state);
        };
    }
    fn block_2450<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2450_0: const #0u : u8
        let s_2450_0: bool = false;
        // D s_2450_1: write-var gs#406436 <= s_2450_0
        fn_state.gs_406436 = s_2450_0;
        // N s_2450_2: jump b2451
        return block_2451(state, tracer, fn_state);
    }
    fn block_2451<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2451_0: read-var gs#406436:u8
        let s_2451_0: bool = fn_state.gs_406436;
        // D s_2451_1: write-var gs#406437 <= s_2451_0
        fn_state.gs_406437 = s_2451_0;
        // N s_2451_2: jump b990
        return block_990(state, tracer, fn_state);
    }
    fn block_2452<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2452_0: const #4s : i
        let s_2452_0: i128 = 4;
        // D s_2452_1: read-var u#32901:u32
        let s_2452_1: u32 = fn_state.u_32901;
        // D s_2452_2: cast zx s_2452_1 -> bv
        let s_2452_2: Bits = Bits::new(s_2452_1 as u128, 32u16);
        // C s_2452_3: const #1s : i64
        let s_2452_3: i64 = 1;
        // C s_2452_4: cast zx s_2452_3 -> i
        let s_2452_4: i128 = (i128::try_from(s_2452_3).unwrap());
        // C s_2452_5: const #0s : i
        let s_2452_5: i128 = 0;
        // C s_2452_6: add s_2452_5 s_2452_4
        let s_2452_6: i128 = (s_2452_5 + s_2452_4);
        // D s_2452_7: bit-extract s_2452_2 s_2452_0 s_2452_6
        let s_2452_7: Bits = (Bits::new(
            ((s_2452_2) >> (s_2452_0)).value(),
            u16::try_from(s_2452_6).unwrap(),
        ));
        // D s_2452_8: cast reint s_2452_7 -> u8
        let s_2452_8: bool = ((s_2452_7.value()) != 0);
        // D s_2452_9: cast zx s_2452_8 -> bv
        let s_2452_9: Bits = Bits::new(s_2452_8 as u128, 1u16);
        // C s_2452_10: const #0u : u8
        let s_2452_10: bool = false;
        // C s_2452_11: cast zx s_2452_10 -> bv
        let s_2452_11: Bits = Bits::new(s_2452_10 as u128, 1u16);
        // D s_2452_12: cmp-eq s_2452_9 s_2452_11
        let s_2452_12: bool = ((s_2452_9) == (s_2452_11));
        // D s_2452_13: write-var gs#406436 <= s_2452_12
        fn_state.gs_406436 = s_2452_12;
        // N s_2452_14: jump b2451
        return block_2451(state, tracer, fn_state);
    }
    fn block_2453<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2453_0: const #28s : i
        let s_2453_0: i128 = 28;
        // C s_2453_1: const #4s : i
        let s_2453_1: i128 = 4;
        // D s_2453_2: read-var u#32898:u32
        let s_2453_2: u32 = fn_state.u_32898;
        // D s_2453_3: cast zx s_2453_2 -> bv
        let s_2453_3: Bits = Bits::new(s_2453_2 as u128, 32u16);
        // D s_2453_4: bit-extract s_2453_3 s_2453_0 s_2453_1
        let s_2453_4: Bits = (Bits::new(
            ((s_2453_3) >> (s_2453_0)).value(),
            u16::try_from(s_2453_1).unwrap(),
        ));
        // D s_2453_5: cast reint s_2453_4 -> u8
        let s_2453_5: u8 = (s_2453_4.value() as u8);
        // D s_2453_6: cast zx s_2453_5 -> bv
        let s_2453_6: Bits = Bits::new(s_2453_5 as u128, 4u16);
        // C s_2453_7: const #15u : u8
        let s_2453_7: u8 = 15;
        // C s_2453_8: cast zx s_2453_7 -> bv
        let s_2453_8: Bits = Bits::new(s_2453_7 as u128, 4u16);
        // D s_2453_9: cmp-ne s_2453_6 s_2453_8
        let s_2453_9: bool = ((s_2453_6) != (s_2453_8));
        // N s_2453_10: branch s_2453_9 b2456 b2454
        if s_2453_9 {
            return block_2456(state, tracer, fn_state);
        } else {
            return block_2454(state, tracer, fn_state);
        };
    }
    fn block_2454<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2454_0: const #0u : u8
        let s_2454_0: bool = false;
        // D s_2454_1: write-var gs#406400 <= s_2454_0
        fn_state.gs_406400 = s_2454_0;
        // N s_2454_2: jump b2455
        return block_2455(state, tracer, fn_state);
    }
    fn block_2455<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2455_0: read-var gs#406400:u8
        let s_2455_0: bool = fn_state.gs_406400;
        // D s_2455_1: write-var gs#406401 <= s_2455_0
        fn_state.gs_406401 = s_2455_0;
        // N s_2455_2: jump b963
        return block_963(state, tracer, fn_state);
    }
    fn block_2456<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2456_0: const #3127s : i
        let s_2456_0: i128 = 3127;
        // C s_2456_1: const #14696u : u32
        let s_2456_1: u32 = 14696;
        // D s_2456_2: read-reg s_2456_1:i
        let s_2456_2: i128 = {
            let value = state.read_register::<i128>(s_2456_1 as isize);
            tracer.read_register(s_2456_1 as isize, value);
            value
        };
        // D s_2456_3: cmp-lt s_2456_2 s_2456_0
        let s_2456_3: bool = ((s_2456_2) < (s_2456_0));
        // D s_2456_4: write-var gs#406400 <= s_2456_3
        fn_state.gs_406400 = s_2456_3;
        // N s_2456_5: jump b2455
        return block_2455(state, tracer, fn_state);
    }
    fn block_2457<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2457_0: const #28s : i
        let s_2457_0: i128 = 28;
        // C s_2457_1: const #4s : i
        let s_2457_1: i128 = 4;
        // D s_2457_2: read-var u#32889:u32
        let s_2457_2: u32 = fn_state.u_32889;
        // D s_2457_3: cast zx s_2457_2 -> bv
        let s_2457_3: Bits = Bits::new(s_2457_2 as u128, 32u16);
        // D s_2457_4: bit-extract s_2457_3 s_2457_0 s_2457_1
        let s_2457_4: Bits = (Bits::new(
            ((s_2457_3) >> (s_2457_0)).value(),
            u16::try_from(s_2457_1).unwrap(),
        ));
        // D s_2457_5: cast reint s_2457_4 -> u8
        let s_2457_5: u8 = (s_2457_4.value() as u8);
        // D s_2457_6: cast zx s_2457_5 -> bv
        let s_2457_6: Bits = Bits::new(s_2457_5 as u128, 4u16);
        // C s_2457_7: const #15u : u8
        let s_2457_7: u8 = 15;
        // C s_2457_8: cast zx s_2457_7 -> bv
        let s_2457_8: Bits = Bits::new(s_2457_7 as u128, 4u16);
        // D s_2457_9: cmp-ne s_2457_6 s_2457_8
        let s_2457_9: bool = ((s_2457_6) != (s_2457_8));
        // N s_2457_10: branch s_2457_9 b2460 b2458
        if s_2457_9 {
            return block_2460(state, tracer, fn_state);
        } else {
            return block_2458(state, tracer, fn_state);
        };
    }
    fn block_2458<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2458_0: const #0u : u8
        let s_2458_0: bool = false;
        // D s_2458_1: write-var gs#406376 <= s_2458_0
        fn_state.gs_406376 = s_2458_0;
        // N s_2458_2: jump b2459
        return block_2459(state, tracer, fn_state);
    }
    fn block_2459<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2459_0: read-var gs#406376:u8
        let s_2459_0: bool = fn_state.gs_406376;
        // D s_2459_1: write-var gs#406377 <= s_2459_0
        fn_state.gs_406377 = s_2459_0;
        // N s_2459_2: jump b959
        return block_959(state, tracer, fn_state);
    }
    fn block_2460<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2460_0: const #3118s : i
        let s_2460_0: i128 = 3118;
        // C s_2460_1: const #14696u : u32
        let s_2460_1: u32 = 14696;
        // D s_2460_2: read-reg s_2460_1:i
        let s_2460_2: i128 = {
            let value = state.read_register::<i128>(s_2460_1 as isize);
            tracer.read_register(s_2460_1 as isize, value);
            value
        };
        // D s_2460_3: cmp-lt s_2460_2 s_2460_0
        let s_2460_3: bool = ((s_2460_2) < (s_2460_0));
        // D s_2460_4: write-var gs#406376 <= s_2460_3
        fn_state.gs_406376 = s_2460_3;
        // N s_2460_5: jump b2459
        return block_2459(state, tracer, fn_state);
    }
    fn block_2461<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2461_0: const #7s : i
        let s_2461_0: i128 = 7;
        // D s_2461_1: read-var u#32889:u32
        let s_2461_1: u32 = fn_state.u_32889;
        // D s_2461_2: cast zx s_2461_1 -> bv
        let s_2461_2: Bits = Bits::new(s_2461_1 as u128, 32u16);
        // C s_2461_3: const #1s : i64
        let s_2461_3: i64 = 1;
        // C s_2461_4: cast zx s_2461_3 -> i
        let s_2461_4: i128 = (i128::try_from(s_2461_3).unwrap());
        // C s_2461_5: const #0s : i
        let s_2461_5: i128 = 0;
        // C s_2461_6: add s_2461_5 s_2461_4
        let s_2461_6: i128 = (s_2461_5 + s_2461_4);
        // D s_2461_7: bit-extract s_2461_2 s_2461_0 s_2461_6
        let s_2461_7: Bits = (Bits::new(
            ((s_2461_2) >> (s_2461_0)).value(),
            u16::try_from(s_2461_6).unwrap(),
        ));
        // D s_2461_8: cast reint s_2461_7 -> u8
        let s_2461_8: bool = ((s_2461_7.value()) != 0);
        // D s_2461_9: cast zx s_2461_8 -> bv
        let s_2461_9: Bits = Bits::new(s_2461_8 as u128, 1u16);
        // C s_2461_10: const #0u : u8
        let s_2461_10: bool = false;
        // C s_2461_11: cast zx s_2461_10 -> bv
        let s_2461_11: Bits = Bits::new(s_2461_10 as u128, 1u16);
        // D s_2461_12: cmp-eq s_2461_9 s_2461_11
        let s_2461_12: bool = ((s_2461_9) == (s_2461_11));
        // N s_2461_13: branch s_2461_12 b2464 b2462
        if s_2461_12 {
            return block_2464(state, tracer, fn_state);
        } else {
            return block_2462(state, tracer, fn_state);
        };
    }
    fn block_2462<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2462_0: const #0u : u8
        let s_2462_0: bool = false;
        // D s_2462_1: write-var gs#406371 <= s_2462_0
        fn_state.gs_406371 = s_2462_0;
        // N s_2462_2: jump b2463
        return block_2463(state, tracer, fn_state);
    }
    fn block_2463<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2463_0: read-var gs#406371:u8
        let s_2463_0: bool = fn_state.gs_406371;
        // D s_2463_1: write-var gs#406372 <= s_2463_0
        fn_state.gs_406372 = s_2463_0;
        // N s_2463_2: jump b957
        return block_957(state, tracer, fn_state);
    }
    fn block_2464<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2464_0: const #4s : i
        let s_2464_0: i128 = 4;
        // D s_2464_1: read-var u#32889:u32
        let s_2464_1: u32 = fn_state.u_32889;
        // D s_2464_2: cast zx s_2464_1 -> bv
        let s_2464_2: Bits = Bits::new(s_2464_1 as u128, 32u16);
        // C s_2464_3: const #1s : i64
        let s_2464_3: i64 = 1;
        // C s_2464_4: cast zx s_2464_3 -> i
        let s_2464_4: i128 = (i128::try_from(s_2464_3).unwrap());
        // C s_2464_5: const #0s : i
        let s_2464_5: i128 = 0;
        // C s_2464_6: add s_2464_5 s_2464_4
        let s_2464_6: i128 = (s_2464_5 + s_2464_4);
        // D s_2464_7: bit-extract s_2464_2 s_2464_0 s_2464_6
        let s_2464_7: Bits = (Bits::new(
            ((s_2464_2) >> (s_2464_0)).value(),
            u16::try_from(s_2464_6).unwrap(),
        ));
        // D s_2464_8: cast reint s_2464_7 -> u8
        let s_2464_8: bool = ((s_2464_7.value()) != 0);
        // D s_2464_9: cast zx s_2464_8 -> bv
        let s_2464_9: Bits = Bits::new(s_2464_8 as u128, 1u16);
        // C s_2464_10: const #1u : u8
        let s_2464_10: bool = true;
        // C s_2464_11: cast zx s_2464_10 -> bv
        let s_2464_11: Bits = Bits::new(s_2464_10 as u128, 1u16);
        // D s_2464_12: cmp-eq s_2464_9 s_2464_11
        let s_2464_12: bool = ((s_2464_9) == (s_2464_11));
        // D s_2464_13: write-var gs#406371 <= s_2464_12
        fn_state.gs_406371 = s_2464_12;
        // N s_2464_14: jump b2463
        return block_2463(state, tracer, fn_state);
    }
    fn block_2465<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2465_0: const #28s : i
        let s_2465_0: i128 = 28;
        // C s_2465_1: const #4s : i
        let s_2465_1: i128 = 4;
        // D s_2465_2: read-var u#32880:u32
        let s_2465_2: u32 = fn_state.u_32880;
        // D s_2465_3: cast zx s_2465_2 -> bv
        let s_2465_3: Bits = Bits::new(s_2465_2 as u128, 32u16);
        // D s_2465_4: bit-extract s_2465_3 s_2465_0 s_2465_1
        let s_2465_4: Bits = (Bits::new(
            ((s_2465_3) >> (s_2465_0)).value(),
            u16::try_from(s_2465_1).unwrap(),
        ));
        // D s_2465_5: cast reint s_2465_4 -> u8
        let s_2465_5: u8 = (s_2465_4.value() as u8);
        // D s_2465_6: cast zx s_2465_5 -> bv
        let s_2465_6: Bits = Bits::new(s_2465_5 as u128, 4u16);
        // C s_2465_7: const #15u : u8
        let s_2465_7: u8 = 15;
        // C s_2465_8: cast zx s_2465_7 -> bv
        let s_2465_8: Bits = Bits::new(s_2465_7 as u128, 4u16);
        // D s_2465_9: cmp-ne s_2465_6 s_2465_8
        let s_2465_9: bool = ((s_2465_6) != (s_2465_8));
        // N s_2465_10: branch s_2465_9 b2468 b2466
        if s_2465_9 {
            return block_2468(state, tracer, fn_state);
        } else {
            return block_2466(state, tracer, fn_state);
        };
    }
    fn block_2466<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2466_0: const #0u : u8
        let s_2466_0: bool = false;
        // D s_2466_1: write-var gs#406346 <= s_2466_0
        fn_state.gs_406346 = s_2466_0;
        // N s_2466_2: jump b2467
        return block_2467(state, tracer, fn_state);
    }
    fn block_2467<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2467_0: read-var gs#406346:u8
        let s_2467_0: bool = fn_state.gs_406346;
        // D s_2467_1: write-var gs#406347 <= s_2467_0
        fn_state.gs_406347 = s_2467_0;
        // N s_2467_2: jump b953
        return block_953(state, tracer, fn_state);
    }
    fn block_2468<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2468_0: const #3115s : i
        let s_2468_0: i128 = 3115;
        // C s_2468_1: const #14696u : u32
        let s_2468_1: u32 = 14696;
        // D s_2468_2: read-reg s_2468_1:i
        let s_2468_2: i128 = {
            let value = state.read_register::<i128>(s_2468_1 as isize);
            tracer.read_register(s_2468_1 as isize, value);
            value
        };
        // D s_2468_3: cmp-lt s_2468_2 s_2468_0
        let s_2468_3: bool = ((s_2468_2) < (s_2468_0));
        // D s_2468_4: write-var gs#406346 <= s_2468_3
        fn_state.gs_406346 = s_2468_3;
        // N s_2468_5: jump b2467
        return block_2467(state, tracer, fn_state);
    }
    fn block_2469<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2469_0: const #4s : i
        let s_2469_0: i128 = 4;
        // D s_2469_1: read-var u#32880:u32
        let s_2469_1: u32 = fn_state.u_32880;
        // D s_2469_2: cast zx s_2469_1 -> bv
        let s_2469_2: Bits = Bits::new(s_2469_1 as u128, 32u16);
        // C s_2469_3: const #1s : i64
        let s_2469_3: i64 = 1;
        // C s_2469_4: cast zx s_2469_3 -> i
        let s_2469_4: i128 = (i128::try_from(s_2469_3).unwrap());
        // C s_2469_5: const #0s : i
        let s_2469_5: i128 = 0;
        // C s_2469_6: add s_2469_5 s_2469_4
        let s_2469_6: i128 = (s_2469_5 + s_2469_4);
        // D s_2469_7: bit-extract s_2469_2 s_2469_0 s_2469_6
        let s_2469_7: Bits = (Bits::new(
            ((s_2469_2) >> (s_2469_0)).value(),
            u16::try_from(s_2469_6).unwrap(),
        ));
        // D s_2469_8: cast reint s_2469_7 -> u8
        let s_2469_8: bool = ((s_2469_7.value()) != 0);
        // D s_2469_9: cast zx s_2469_8 -> bv
        let s_2469_9: Bits = Bits::new(s_2469_8 as u128, 1u16);
        // C s_2469_10: const #0u : u8
        let s_2469_10: bool = false;
        // C s_2469_11: cast zx s_2469_10 -> bv
        let s_2469_11: Bits = Bits::new(s_2469_10 as u128, 1u16);
        // D s_2469_12: cmp-eq s_2469_9 s_2469_11
        let s_2469_12: bool = ((s_2469_9) == (s_2469_11));
        // D s_2469_13: write-var gs#406342 <= s_2469_12
        fn_state.gs_406342 = s_2469_12;
        // N s_2469_14: jump b951
        return block_951(state, tracer, fn_state);
    }
    fn block_2470<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2470_0: const #28s : i
        let s_2470_0: i128 = 28;
        // C s_2470_1: const #4s : i
        let s_2470_1: i128 = 4;
        // D s_2470_2: read-var u#32873:u32
        let s_2470_2: u32 = fn_state.u_32873;
        // D s_2470_3: cast zx s_2470_2 -> bv
        let s_2470_3: Bits = Bits::new(s_2470_2 as u128, 32u16);
        // D s_2470_4: bit-extract s_2470_3 s_2470_0 s_2470_1
        let s_2470_4: Bits = (Bits::new(
            ((s_2470_3) >> (s_2470_0)).value(),
            u16::try_from(s_2470_1).unwrap(),
        ));
        // D s_2470_5: cast reint s_2470_4 -> u8
        let s_2470_5: u8 = (s_2470_4.value() as u8);
        // D s_2470_6: cast zx s_2470_5 -> bv
        let s_2470_6: Bits = Bits::new(s_2470_5 as u128, 4u16);
        // C s_2470_7: const #15u : u8
        let s_2470_7: u8 = 15;
        // C s_2470_8: cast zx s_2470_7 -> bv
        let s_2470_8: Bits = Bits::new(s_2470_7 as u128, 4u16);
        // D s_2470_9: cmp-ne s_2470_6 s_2470_8
        let s_2470_9: bool = ((s_2470_6) != (s_2470_8));
        // N s_2470_10: branch s_2470_9 b2473 b2471
        if s_2470_9 {
            return block_2473(state, tracer, fn_state);
        } else {
            return block_2471(state, tracer, fn_state);
        };
    }
    fn block_2471<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2471_0: const #0u : u8
        let s_2471_0: bool = false;
        // D s_2471_1: write-var gs#406323 <= s_2471_0
        fn_state.gs_406323 = s_2471_0;
        // N s_2471_2: jump b2472
        return block_2472(state, tracer, fn_state);
    }
    fn block_2472<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2472_0: read-var gs#406323:u8
        let s_2472_0: bool = fn_state.gs_406323;
        // D s_2472_1: write-var gs#406324 <= s_2472_0
        fn_state.gs_406324 = s_2472_0;
        // N s_2472_2: jump b947
        return block_947(state, tracer, fn_state);
    }
    fn block_2473<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2473_0: const #3113s : i
        let s_2473_0: i128 = 3113;
        // C s_2473_1: const #14696u : u32
        let s_2473_1: u32 = 14696;
        // D s_2473_2: read-reg s_2473_1:i
        let s_2473_2: i128 = {
            let value = state.read_register::<i128>(s_2473_1 as isize);
            tracer.read_register(s_2473_1 as isize, value);
            value
        };
        // D s_2473_3: cmp-lt s_2473_2 s_2473_0
        let s_2473_3: bool = ((s_2473_2) < (s_2473_0));
        // D s_2473_4: write-var gs#406323 <= s_2473_3
        fn_state.gs_406323 = s_2473_3;
        // N s_2473_5: jump b2472
        return block_2472(state, tracer, fn_state);
    }
    fn block_2474<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2474_0: const #28s : i
        let s_2474_0: i128 = 28;
        // C s_2474_1: const #4s : i
        let s_2474_1: i128 = 4;
        // D s_2474_2: read-var u#32864:u32
        let s_2474_2: u32 = fn_state.u_32864;
        // D s_2474_3: cast zx s_2474_2 -> bv
        let s_2474_3: Bits = Bits::new(s_2474_2 as u128, 32u16);
        // D s_2474_4: bit-extract s_2474_3 s_2474_0 s_2474_1
        let s_2474_4: Bits = (Bits::new(
            ((s_2474_3) >> (s_2474_0)).value(),
            u16::try_from(s_2474_1).unwrap(),
        ));
        // D s_2474_5: cast reint s_2474_4 -> u8
        let s_2474_5: u8 = (s_2474_4.value() as u8);
        // D s_2474_6: cast zx s_2474_5 -> bv
        let s_2474_6: Bits = Bits::new(s_2474_5 as u128, 4u16);
        // C s_2474_7: const #15u : u8
        let s_2474_7: u8 = 15;
        // C s_2474_8: cast zx s_2474_7 -> bv
        let s_2474_8: Bits = Bits::new(s_2474_7 as u128, 4u16);
        // D s_2474_9: cmp-ne s_2474_6 s_2474_8
        let s_2474_9: bool = ((s_2474_6) != (s_2474_8));
        // N s_2474_10: branch s_2474_9 b2477 b2475
        if s_2474_9 {
            return block_2477(state, tracer, fn_state);
        } else {
            return block_2475(state, tracer, fn_state);
        };
    }
    fn block_2475<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2475_0: const #0u : u8
        let s_2475_0: bool = false;
        // D s_2475_1: write-var gs#406299 <= s_2475_0
        fn_state.gs_406299 = s_2475_0;
        // N s_2475_2: jump b2476
        return block_2476(state, tracer, fn_state);
    }
    fn block_2476<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2476_0: read-var gs#406299:u8
        let s_2476_0: bool = fn_state.gs_406299;
        // D s_2476_1: write-var gs#406300 <= s_2476_0
        fn_state.gs_406300 = s_2476_0;
        // N s_2476_2: jump b943
        return block_943(state, tracer, fn_state);
    }
    fn block_2477<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2477_0: const #3104s : i
        let s_2477_0: i128 = 3104;
        // C s_2477_1: const #14696u : u32
        let s_2477_1: u32 = 14696;
        // D s_2477_2: read-reg s_2477_1:i
        let s_2477_2: i128 = {
            let value = state.read_register::<i128>(s_2477_1 as isize);
            tracer.read_register(s_2477_1 as isize, value);
            value
        };
        // D s_2477_3: cmp-lt s_2477_2 s_2477_0
        let s_2477_3: bool = ((s_2477_2) < (s_2477_0));
        // D s_2477_4: write-var gs#406299 <= s_2477_3
        fn_state.gs_406299 = s_2477_3;
        // N s_2477_5: jump b2476
        return block_2476(state, tracer, fn_state);
    }
    fn block_2478<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2478_0: const #7s : i
        let s_2478_0: i128 = 7;
        // D s_2478_1: read-var u#32864:u32
        let s_2478_1: u32 = fn_state.u_32864;
        // D s_2478_2: cast zx s_2478_1 -> bv
        let s_2478_2: Bits = Bits::new(s_2478_1 as u128, 32u16);
        // C s_2478_3: const #1s : i64
        let s_2478_3: i64 = 1;
        // C s_2478_4: cast zx s_2478_3 -> i
        let s_2478_4: i128 = (i128::try_from(s_2478_3).unwrap());
        // C s_2478_5: const #0s : i
        let s_2478_5: i128 = 0;
        // C s_2478_6: add s_2478_5 s_2478_4
        let s_2478_6: i128 = (s_2478_5 + s_2478_4);
        // D s_2478_7: bit-extract s_2478_2 s_2478_0 s_2478_6
        let s_2478_7: Bits = (Bits::new(
            ((s_2478_2) >> (s_2478_0)).value(),
            u16::try_from(s_2478_6).unwrap(),
        ));
        // D s_2478_8: cast reint s_2478_7 -> u8
        let s_2478_8: bool = ((s_2478_7.value()) != 0);
        // D s_2478_9: cast zx s_2478_8 -> bv
        let s_2478_9: Bits = Bits::new(s_2478_8 as u128, 1u16);
        // C s_2478_10: const #0u : u8
        let s_2478_10: bool = false;
        // C s_2478_11: cast zx s_2478_10 -> bv
        let s_2478_11: Bits = Bits::new(s_2478_10 as u128, 1u16);
        // D s_2478_12: cmp-eq s_2478_9 s_2478_11
        let s_2478_12: bool = ((s_2478_9) == (s_2478_11));
        // N s_2478_13: branch s_2478_12 b2481 b2479
        if s_2478_12 {
            return block_2481(state, tracer, fn_state);
        } else {
            return block_2479(state, tracer, fn_state);
        };
    }
    fn block_2479<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2479_0: const #0u : u8
        let s_2479_0: bool = false;
        // D s_2479_1: write-var gs#406294 <= s_2479_0
        fn_state.gs_406294 = s_2479_0;
        // N s_2479_2: jump b2480
        return block_2480(state, tracer, fn_state);
    }
    fn block_2480<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2480_0: read-var gs#406294:u8
        let s_2480_0: bool = fn_state.gs_406294;
        // D s_2480_1: write-var gs#406295 <= s_2480_0
        fn_state.gs_406295 = s_2480_0;
        // N s_2480_2: jump b941
        return block_941(state, tracer, fn_state);
    }
    fn block_2481<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2481_0: const #4s : i
        let s_2481_0: i128 = 4;
        // D s_2481_1: read-var u#32864:u32
        let s_2481_1: u32 = fn_state.u_32864;
        // D s_2481_2: cast zx s_2481_1 -> bv
        let s_2481_2: Bits = Bits::new(s_2481_1 as u128, 32u16);
        // C s_2481_3: const #1s : i64
        let s_2481_3: i64 = 1;
        // C s_2481_4: cast zx s_2481_3 -> i
        let s_2481_4: i128 = (i128::try_from(s_2481_3).unwrap());
        // C s_2481_5: const #0s : i
        let s_2481_5: i128 = 0;
        // C s_2481_6: add s_2481_5 s_2481_4
        let s_2481_6: i128 = (s_2481_5 + s_2481_4);
        // D s_2481_7: bit-extract s_2481_2 s_2481_0 s_2481_6
        let s_2481_7: Bits = (Bits::new(
            ((s_2481_2) >> (s_2481_0)).value(),
            u16::try_from(s_2481_6).unwrap(),
        ));
        // D s_2481_8: cast reint s_2481_7 -> u8
        let s_2481_8: bool = ((s_2481_7.value()) != 0);
        // D s_2481_9: cast zx s_2481_8 -> bv
        let s_2481_9: Bits = Bits::new(s_2481_8 as u128, 1u16);
        // C s_2481_10: const #1u : u8
        let s_2481_10: bool = true;
        // C s_2481_11: cast zx s_2481_10 -> bv
        let s_2481_11: Bits = Bits::new(s_2481_10 as u128, 1u16);
        // D s_2481_12: cmp-eq s_2481_9 s_2481_11
        let s_2481_12: bool = ((s_2481_9) == (s_2481_11));
        // D s_2481_13: write-var gs#406294 <= s_2481_12
        fn_state.gs_406294 = s_2481_12;
        // N s_2481_14: jump b2480
        return block_2480(state, tracer, fn_state);
    }
    fn block_2482<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2482_0: const #28s : i
        let s_2482_0: i128 = 28;
        // C s_2482_1: const #4s : i
        let s_2482_1: i128 = 4;
        // D s_2482_2: read-var u#32855:u32
        let s_2482_2: u32 = fn_state.u_32855;
        // D s_2482_3: cast zx s_2482_2 -> bv
        let s_2482_3: Bits = Bits::new(s_2482_2 as u128, 32u16);
        // D s_2482_4: bit-extract s_2482_3 s_2482_0 s_2482_1
        let s_2482_4: Bits = (Bits::new(
            ((s_2482_3) >> (s_2482_0)).value(),
            u16::try_from(s_2482_1).unwrap(),
        ));
        // D s_2482_5: cast reint s_2482_4 -> u8
        let s_2482_5: u8 = (s_2482_4.value() as u8);
        // D s_2482_6: cast zx s_2482_5 -> bv
        let s_2482_6: Bits = Bits::new(s_2482_5 as u128, 4u16);
        // C s_2482_7: const #15u : u8
        let s_2482_7: u8 = 15;
        // C s_2482_8: cast zx s_2482_7 -> bv
        let s_2482_8: Bits = Bits::new(s_2482_7 as u128, 4u16);
        // D s_2482_9: cmp-ne s_2482_6 s_2482_8
        let s_2482_9: bool = ((s_2482_6) != (s_2482_8));
        // N s_2482_10: branch s_2482_9 b2485 b2483
        if s_2482_9 {
            return block_2485(state, tracer, fn_state);
        } else {
            return block_2483(state, tracer, fn_state);
        };
    }
    fn block_2483<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2483_0: const #0u : u8
        let s_2483_0: bool = false;
        // D s_2483_1: write-var gs#406269 <= s_2483_0
        fn_state.gs_406269 = s_2483_0;
        // N s_2483_2: jump b2484
        return block_2484(state, tracer, fn_state);
    }
    fn block_2484<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2484_0: read-var gs#406269:u8
        let s_2484_0: bool = fn_state.gs_406269;
        // D s_2484_1: write-var gs#406270 <= s_2484_0
        fn_state.gs_406270 = s_2484_0;
        // N s_2484_2: jump b937
        return block_937(state, tracer, fn_state);
    }
    fn block_2485<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2485_0: const #3103s : i
        let s_2485_0: i128 = 3103;
        // C s_2485_1: const #14696u : u32
        let s_2485_1: u32 = 14696;
        // D s_2485_2: read-reg s_2485_1:i
        let s_2485_2: i128 = {
            let value = state.read_register::<i128>(s_2485_1 as isize);
            tracer.read_register(s_2485_1 as isize, value);
            value
        };
        // D s_2485_3: cmp-lt s_2485_2 s_2485_0
        let s_2485_3: bool = ((s_2485_2) < (s_2485_0));
        // D s_2485_4: write-var gs#406269 <= s_2485_3
        fn_state.gs_406269 = s_2485_3;
        // N s_2485_5: jump b2484
        return block_2484(state, tracer, fn_state);
    }
    fn block_2486<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2486_0: const #4s : i
        let s_2486_0: i128 = 4;
        // D s_2486_1: read-var u#32855:u32
        let s_2486_1: u32 = fn_state.u_32855;
        // D s_2486_2: cast zx s_2486_1 -> bv
        let s_2486_2: Bits = Bits::new(s_2486_1 as u128, 32u16);
        // C s_2486_3: const #1s : i64
        let s_2486_3: i64 = 1;
        // C s_2486_4: cast zx s_2486_3 -> i
        let s_2486_4: i128 = (i128::try_from(s_2486_3).unwrap());
        // C s_2486_5: const #0s : i
        let s_2486_5: i128 = 0;
        // C s_2486_6: add s_2486_5 s_2486_4
        let s_2486_6: i128 = (s_2486_5 + s_2486_4);
        // D s_2486_7: bit-extract s_2486_2 s_2486_0 s_2486_6
        let s_2486_7: Bits = (Bits::new(
            ((s_2486_2) >> (s_2486_0)).value(),
            u16::try_from(s_2486_6).unwrap(),
        ));
        // D s_2486_8: cast reint s_2486_7 -> u8
        let s_2486_8: bool = ((s_2486_7.value()) != 0);
        // D s_2486_9: cast zx s_2486_8 -> bv
        let s_2486_9: Bits = Bits::new(s_2486_8 as u128, 1u16);
        // C s_2486_10: const #0u : u8
        let s_2486_10: bool = false;
        // C s_2486_11: cast zx s_2486_10 -> bv
        let s_2486_11: Bits = Bits::new(s_2486_10 as u128, 1u16);
        // D s_2486_12: cmp-eq s_2486_9 s_2486_11
        let s_2486_12: bool = ((s_2486_9) == (s_2486_11));
        // D s_2486_13: write-var gs#406265 <= s_2486_12
        fn_state.gs_406265 = s_2486_12;
        // N s_2486_14: jump b935
        return block_935(state, tracer, fn_state);
    }
    fn block_2487<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2487_0: const #28s : i
        let s_2487_0: i128 = 28;
        // C s_2487_1: const #4s : i
        let s_2487_1: i128 = 4;
        // D s_2487_2: read-var u#32848:u32
        let s_2487_2: u32 = fn_state.u_32848;
        // D s_2487_3: cast zx s_2487_2 -> bv
        let s_2487_3: Bits = Bits::new(s_2487_2 as u128, 32u16);
        // D s_2487_4: bit-extract s_2487_3 s_2487_0 s_2487_1
        let s_2487_4: Bits = (Bits::new(
            ((s_2487_3) >> (s_2487_0)).value(),
            u16::try_from(s_2487_1).unwrap(),
        ));
        // D s_2487_5: cast reint s_2487_4 -> u8
        let s_2487_5: u8 = (s_2487_4.value() as u8);
        // D s_2487_6: cast zx s_2487_5 -> bv
        let s_2487_6: Bits = Bits::new(s_2487_5 as u128, 4u16);
        // C s_2487_7: const #15u : u8
        let s_2487_7: u8 = 15;
        // C s_2487_8: cast zx s_2487_7 -> bv
        let s_2487_8: Bits = Bits::new(s_2487_7 as u128, 4u16);
        // D s_2487_9: cmp-ne s_2487_6 s_2487_8
        let s_2487_9: bool = ((s_2487_6) != (s_2487_8));
        // N s_2487_10: branch s_2487_9 b2490 b2488
        if s_2487_9 {
            return block_2490(state, tracer, fn_state);
        } else {
            return block_2488(state, tracer, fn_state);
        };
    }
    fn block_2488<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2488_0: const #0u : u8
        let s_2488_0: bool = false;
        // D s_2488_1: write-var gs#406246 <= s_2488_0
        fn_state.gs_406246 = s_2488_0;
        // N s_2488_2: jump b2489
        return block_2489(state, tracer, fn_state);
    }
    fn block_2489<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2489_0: read-var gs#406246:u8
        let s_2489_0: bool = fn_state.gs_406246;
        // D s_2489_1: write-var gs#406247 <= s_2489_0
        fn_state.gs_406247 = s_2489_0;
        // N s_2489_2: jump b931
        return block_931(state, tracer, fn_state);
    }
    fn block_2490<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2490_0: const #3102s : i
        let s_2490_0: i128 = 3102;
        // C s_2490_1: const #14696u : u32
        let s_2490_1: u32 = 14696;
        // D s_2490_2: read-reg s_2490_1:i
        let s_2490_2: i128 = {
            let value = state.read_register::<i128>(s_2490_1 as isize);
            tracer.read_register(s_2490_1 as isize, value);
            value
        };
        // D s_2490_3: cmp-lt s_2490_2 s_2490_0
        let s_2490_3: bool = ((s_2490_2) < (s_2490_0));
        // D s_2490_4: write-var gs#406246 <= s_2490_3
        fn_state.gs_406246 = s_2490_3;
        // N s_2490_5: jump b2489
        return block_2489(state, tracer, fn_state);
    }
    fn block_2491<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2491_0: const #28s : i
        let s_2491_0: i128 = 28;
        // C s_2491_1: const #4s : i
        let s_2491_1: i128 = 4;
        // D s_2491_2: read-var u#32839:u32
        let s_2491_2: u32 = fn_state.u_32839;
        // D s_2491_3: cast zx s_2491_2 -> bv
        let s_2491_3: Bits = Bits::new(s_2491_2 as u128, 32u16);
        // D s_2491_4: bit-extract s_2491_3 s_2491_0 s_2491_1
        let s_2491_4: Bits = (Bits::new(
            ((s_2491_3) >> (s_2491_0)).value(),
            u16::try_from(s_2491_1).unwrap(),
        ));
        // D s_2491_5: cast reint s_2491_4 -> u8
        let s_2491_5: u8 = (s_2491_4.value() as u8);
        // D s_2491_6: cast zx s_2491_5 -> bv
        let s_2491_6: Bits = Bits::new(s_2491_5 as u128, 4u16);
        // C s_2491_7: const #15u : u8
        let s_2491_7: u8 = 15;
        // C s_2491_8: cast zx s_2491_7 -> bv
        let s_2491_8: Bits = Bits::new(s_2491_7 as u128, 4u16);
        // D s_2491_9: cmp-ne s_2491_6 s_2491_8
        let s_2491_9: bool = ((s_2491_6) != (s_2491_8));
        // N s_2491_10: branch s_2491_9 b2494 b2492
        if s_2491_9 {
            return block_2494(state, tracer, fn_state);
        } else {
            return block_2492(state, tracer, fn_state);
        };
    }
    fn block_2492<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2492_0: const #0u : u8
        let s_2492_0: bool = false;
        // D s_2492_1: write-var gs#406222 <= s_2492_0
        fn_state.gs_406222 = s_2492_0;
        // N s_2492_2: jump b2493
        return block_2493(state, tracer, fn_state);
    }
    fn block_2493<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2493_0: read-var gs#406222:u8
        let s_2493_0: bool = fn_state.gs_406222;
        // D s_2493_1: write-var gs#406223 <= s_2493_0
        fn_state.gs_406223 = s_2493_0;
        // N s_2493_2: jump b927
        return block_927(state, tracer, fn_state);
    }
    fn block_2494<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2494_0: const #3101s : i
        let s_2494_0: i128 = 3101;
        // C s_2494_1: const #14696u : u32
        let s_2494_1: u32 = 14696;
        // D s_2494_2: read-reg s_2494_1:i
        let s_2494_2: i128 = {
            let value = state.read_register::<i128>(s_2494_1 as isize);
            tracer.read_register(s_2494_1 as isize, value);
            value
        };
        // D s_2494_3: cmp-lt s_2494_2 s_2494_0
        let s_2494_3: bool = ((s_2494_2) < (s_2494_0));
        // D s_2494_4: write-var gs#406222 <= s_2494_3
        fn_state.gs_406222 = s_2494_3;
        // N s_2494_5: jump b2493
        return block_2493(state, tracer, fn_state);
    }
    fn block_2495<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2495_0: const #7s : i
        let s_2495_0: i128 = 7;
        // D s_2495_1: read-var u#32839:u32
        let s_2495_1: u32 = fn_state.u_32839;
        // D s_2495_2: cast zx s_2495_1 -> bv
        let s_2495_2: Bits = Bits::new(s_2495_1 as u128, 32u16);
        // C s_2495_3: const #1s : i64
        let s_2495_3: i64 = 1;
        // C s_2495_4: cast zx s_2495_3 -> i
        let s_2495_4: i128 = (i128::try_from(s_2495_3).unwrap());
        // C s_2495_5: const #0s : i
        let s_2495_5: i128 = 0;
        // C s_2495_6: add s_2495_5 s_2495_4
        let s_2495_6: i128 = (s_2495_5 + s_2495_4);
        // D s_2495_7: bit-extract s_2495_2 s_2495_0 s_2495_6
        let s_2495_7: Bits = (Bits::new(
            ((s_2495_2) >> (s_2495_0)).value(),
            u16::try_from(s_2495_6).unwrap(),
        ));
        // D s_2495_8: cast reint s_2495_7 -> u8
        let s_2495_8: bool = ((s_2495_7.value()) != 0);
        // D s_2495_9: cast zx s_2495_8 -> bv
        let s_2495_9: Bits = Bits::new(s_2495_8 as u128, 1u16);
        // C s_2495_10: const #0u : u8
        let s_2495_10: bool = false;
        // C s_2495_11: cast zx s_2495_10 -> bv
        let s_2495_11: Bits = Bits::new(s_2495_10 as u128, 1u16);
        // D s_2495_12: cmp-eq s_2495_9 s_2495_11
        let s_2495_12: bool = ((s_2495_9) == (s_2495_11));
        // N s_2495_13: branch s_2495_12 b2498 b2496
        if s_2495_12 {
            return block_2498(state, tracer, fn_state);
        } else {
            return block_2496(state, tracer, fn_state);
        };
    }
    fn block_2496<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2496_0: const #0u : u8
        let s_2496_0: bool = false;
        // D s_2496_1: write-var gs#406217 <= s_2496_0
        fn_state.gs_406217 = s_2496_0;
        // N s_2496_2: jump b2497
        return block_2497(state, tracer, fn_state);
    }
    fn block_2497<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2497_0: read-var gs#406217:u8
        let s_2497_0: bool = fn_state.gs_406217;
        // D s_2497_1: write-var gs#406218 <= s_2497_0
        fn_state.gs_406218 = s_2497_0;
        // N s_2497_2: jump b925
        return block_925(state, tracer, fn_state);
    }
    fn block_2498<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2498_0: const #4s : i
        let s_2498_0: i128 = 4;
        // D s_2498_1: read-var u#32839:u32
        let s_2498_1: u32 = fn_state.u_32839;
        // D s_2498_2: cast zx s_2498_1 -> bv
        let s_2498_2: Bits = Bits::new(s_2498_1 as u128, 32u16);
        // C s_2498_3: const #1s : i64
        let s_2498_3: i64 = 1;
        // C s_2498_4: cast zx s_2498_3 -> i
        let s_2498_4: i128 = (i128::try_from(s_2498_3).unwrap());
        // C s_2498_5: const #0s : i
        let s_2498_5: i128 = 0;
        // C s_2498_6: add s_2498_5 s_2498_4
        let s_2498_6: i128 = (s_2498_5 + s_2498_4);
        // D s_2498_7: bit-extract s_2498_2 s_2498_0 s_2498_6
        let s_2498_7: Bits = (Bits::new(
            ((s_2498_2) >> (s_2498_0)).value(),
            u16::try_from(s_2498_6).unwrap(),
        ));
        // D s_2498_8: cast reint s_2498_7 -> u8
        let s_2498_8: bool = ((s_2498_7.value()) != 0);
        // D s_2498_9: cast zx s_2498_8 -> bv
        let s_2498_9: Bits = Bits::new(s_2498_8 as u128, 1u16);
        // C s_2498_10: const #1u : u8
        let s_2498_10: bool = true;
        // C s_2498_11: cast zx s_2498_10 -> bv
        let s_2498_11: Bits = Bits::new(s_2498_10 as u128, 1u16);
        // D s_2498_12: cmp-eq s_2498_9 s_2498_11
        let s_2498_12: bool = ((s_2498_9) == (s_2498_11));
        // D s_2498_13: write-var gs#406217 <= s_2498_12
        fn_state.gs_406217 = s_2498_12;
        // N s_2498_14: jump b2497
        return block_2497(state, tracer, fn_state);
    }
    fn block_2499<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2499_0: const #28s : i
        let s_2499_0: i128 = 28;
        // C s_2499_1: const #4s : i
        let s_2499_1: i128 = 4;
        // D s_2499_2: read-var u#32830:u32
        let s_2499_2: u32 = fn_state.u_32830;
        // D s_2499_3: cast zx s_2499_2 -> bv
        let s_2499_3: Bits = Bits::new(s_2499_2 as u128, 32u16);
        // D s_2499_4: bit-extract s_2499_3 s_2499_0 s_2499_1
        let s_2499_4: Bits = (Bits::new(
            ((s_2499_3) >> (s_2499_0)).value(),
            u16::try_from(s_2499_1).unwrap(),
        ));
        // D s_2499_5: cast reint s_2499_4 -> u8
        let s_2499_5: u8 = (s_2499_4.value() as u8);
        // D s_2499_6: cast zx s_2499_5 -> bv
        let s_2499_6: Bits = Bits::new(s_2499_5 as u128, 4u16);
        // C s_2499_7: const #15u : u8
        let s_2499_7: u8 = 15;
        // C s_2499_8: cast zx s_2499_7 -> bv
        let s_2499_8: Bits = Bits::new(s_2499_7 as u128, 4u16);
        // D s_2499_9: cmp-ne s_2499_6 s_2499_8
        let s_2499_9: bool = ((s_2499_6) != (s_2499_8));
        // N s_2499_10: branch s_2499_9 b2502 b2500
        if s_2499_9 {
            return block_2502(state, tracer, fn_state);
        } else {
            return block_2500(state, tracer, fn_state);
        };
    }
    fn block_2500<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2500_0: const #0u : u8
        let s_2500_0: bool = false;
        // D s_2500_1: write-var gs#406192 <= s_2500_0
        fn_state.gs_406192 = s_2500_0;
        // N s_2500_2: jump b2501
        return block_2501(state, tracer, fn_state);
    }
    fn block_2501<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2501_0: read-var gs#406192:u8
        let s_2501_0: bool = fn_state.gs_406192;
        // D s_2501_1: write-var gs#406193 <= s_2501_0
        fn_state.gs_406193 = s_2501_0;
        // N s_2501_2: jump b921
        return block_921(state, tracer, fn_state);
    }
    fn block_2502<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2502_0: const #3099s : i
        let s_2502_0: i128 = 3099;
        // C s_2502_1: const #14696u : u32
        let s_2502_1: u32 = 14696;
        // D s_2502_2: read-reg s_2502_1:i
        let s_2502_2: i128 = {
            let value = state.read_register::<i128>(s_2502_1 as isize);
            tracer.read_register(s_2502_1 as isize, value);
            value
        };
        // D s_2502_3: cmp-lt s_2502_2 s_2502_0
        let s_2502_3: bool = ((s_2502_2) < (s_2502_0));
        // D s_2502_4: write-var gs#406192 <= s_2502_3
        fn_state.gs_406192 = s_2502_3;
        // N s_2502_5: jump b2501
        return block_2501(state, tracer, fn_state);
    }
    fn block_2503<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2503_0: const #4s : i
        let s_2503_0: i128 = 4;
        // D s_2503_1: read-var u#32830:u32
        let s_2503_1: u32 = fn_state.u_32830;
        // D s_2503_2: cast zx s_2503_1 -> bv
        let s_2503_2: Bits = Bits::new(s_2503_1 as u128, 32u16);
        // C s_2503_3: const #1s : i64
        let s_2503_3: i64 = 1;
        // C s_2503_4: cast zx s_2503_3 -> i
        let s_2503_4: i128 = (i128::try_from(s_2503_3).unwrap());
        // C s_2503_5: const #0s : i
        let s_2503_5: i128 = 0;
        // C s_2503_6: add s_2503_5 s_2503_4
        let s_2503_6: i128 = (s_2503_5 + s_2503_4);
        // D s_2503_7: bit-extract s_2503_2 s_2503_0 s_2503_6
        let s_2503_7: Bits = (Bits::new(
            ((s_2503_2) >> (s_2503_0)).value(),
            u16::try_from(s_2503_6).unwrap(),
        ));
        // D s_2503_8: cast reint s_2503_7 -> u8
        let s_2503_8: bool = ((s_2503_7.value()) != 0);
        // D s_2503_9: cast zx s_2503_8 -> bv
        let s_2503_9: Bits = Bits::new(s_2503_8 as u128, 1u16);
        // C s_2503_10: const #0u : u8
        let s_2503_10: bool = false;
        // C s_2503_11: cast zx s_2503_10 -> bv
        let s_2503_11: Bits = Bits::new(s_2503_10 as u128, 1u16);
        // D s_2503_12: cmp-eq s_2503_9 s_2503_11
        let s_2503_12: bool = ((s_2503_9) == (s_2503_11));
        // D s_2503_13: write-var gs#406188 <= s_2503_12
        fn_state.gs_406188 = s_2503_12;
        // N s_2503_14: jump b919
        return block_919(state, tracer, fn_state);
    }
    fn block_2504<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2504_0: const #28s : i
        let s_2504_0: i128 = 28;
        // C s_2504_1: const #4s : i
        let s_2504_1: i128 = 4;
        // D s_2504_2: read-var u#32823:u32
        let s_2504_2: u32 = fn_state.u_32823;
        // D s_2504_3: cast zx s_2504_2 -> bv
        let s_2504_3: Bits = Bits::new(s_2504_2 as u128, 32u16);
        // D s_2504_4: bit-extract s_2504_3 s_2504_0 s_2504_1
        let s_2504_4: Bits = (Bits::new(
            ((s_2504_3) >> (s_2504_0)).value(),
            u16::try_from(s_2504_1).unwrap(),
        ));
        // D s_2504_5: cast reint s_2504_4 -> u8
        let s_2504_5: u8 = (s_2504_4.value() as u8);
        // D s_2504_6: cast zx s_2504_5 -> bv
        let s_2504_6: Bits = Bits::new(s_2504_5 as u128, 4u16);
        // C s_2504_7: const #15u : u8
        let s_2504_7: u8 = 15;
        // C s_2504_8: cast zx s_2504_7 -> bv
        let s_2504_8: Bits = Bits::new(s_2504_7 as u128, 4u16);
        // D s_2504_9: cmp-ne s_2504_6 s_2504_8
        let s_2504_9: bool = ((s_2504_6) != (s_2504_8));
        // N s_2504_10: branch s_2504_9 b2507 b2505
        if s_2504_9 {
            return block_2507(state, tracer, fn_state);
        } else {
            return block_2505(state, tracer, fn_state);
        };
    }
    fn block_2505<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2505_0: const #0u : u8
        let s_2505_0: bool = false;
        // D s_2505_1: write-var gs#406169 <= s_2505_0
        fn_state.gs_406169 = s_2505_0;
        // N s_2505_2: jump b2506
        return block_2506(state, tracer, fn_state);
    }
    fn block_2506<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2506_0: read-var gs#406169:u8
        let s_2506_0: bool = fn_state.gs_406169;
        // D s_2506_1: write-var gs#406170 <= s_2506_0
        fn_state.gs_406170 = s_2506_0;
        // N s_2506_2: jump b915
        return block_915(state, tracer, fn_state);
    }
    fn block_2507<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2507_0: const #3096s : i
        let s_2507_0: i128 = 3096;
        // C s_2507_1: const #14696u : u32
        let s_2507_1: u32 = 14696;
        // D s_2507_2: read-reg s_2507_1:i
        let s_2507_2: i128 = {
            let value = state.read_register::<i128>(s_2507_1 as isize);
            tracer.read_register(s_2507_1 as isize, value);
            value
        };
        // D s_2507_3: cmp-lt s_2507_2 s_2507_0
        let s_2507_3: bool = ((s_2507_2) < (s_2507_0));
        // D s_2507_4: write-var gs#406169 <= s_2507_3
        fn_state.gs_406169 = s_2507_3;
        // N s_2507_5: jump b2506
        return block_2506(state, tracer, fn_state);
    }
    fn block_2508<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2508_0: const #28s : i
        let s_2508_0: i128 = 28;
        // C s_2508_1: const #4s : i
        let s_2508_1: i128 = 4;
        // D s_2508_2: read-var u#32817:u32
        let s_2508_2: u32 = fn_state.u_32817;
        // D s_2508_3: cast zx s_2508_2 -> bv
        let s_2508_3: Bits = Bits::new(s_2508_2 as u128, 32u16);
        // D s_2508_4: bit-extract s_2508_3 s_2508_0 s_2508_1
        let s_2508_4: Bits = (Bits::new(
            ((s_2508_3) >> (s_2508_0)).value(),
            u16::try_from(s_2508_1).unwrap(),
        ));
        // D s_2508_5: cast reint s_2508_4 -> u8
        let s_2508_5: u8 = (s_2508_4.value() as u8);
        // D s_2508_6: cast zx s_2508_5 -> bv
        let s_2508_6: Bits = Bits::new(s_2508_5 as u128, 4u16);
        // C s_2508_7: const #15u : u8
        let s_2508_7: u8 = 15;
        // C s_2508_8: cast zx s_2508_7 -> bv
        let s_2508_8: Bits = Bits::new(s_2508_7 as u128, 4u16);
        // D s_2508_9: cmp-ne s_2508_6 s_2508_8
        let s_2508_9: bool = ((s_2508_6) != (s_2508_8));
        // N s_2508_10: branch s_2508_9 b2511 b2509
        if s_2508_9 {
            return block_2511(state, tracer, fn_state);
        } else {
            return block_2509(state, tracer, fn_state);
        };
    }
    fn block_2509<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2509_0: const #0u : u8
        let s_2509_0: bool = false;
        // D s_2509_1: write-var gs#406140 <= s_2509_0
        fn_state.gs_406140 = s_2509_0;
        // N s_2509_2: jump b2510
        return block_2510(state, tracer, fn_state);
    }
    fn block_2510<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2510_0: read-var gs#406140:u8
        let s_2510_0: bool = fn_state.gs_406140;
        // D s_2510_1: write-var gs#406141 <= s_2510_0
        fn_state.gs_406141 = s_2510_0;
        // N s_2510_2: jump b900
        return block_900(state, tracer, fn_state);
    }
    fn block_2511<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2511_0: const #3082s : i
        let s_2511_0: i128 = 3082;
        // C s_2511_1: const #14696u : u32
        let s_2511_1: u32 = 14696;
        // D s_2511_2: read-reg s_2511_1:i
        let s_2511_2: i128 = {
            let value = state.read_register::<i128>(s_2511_1 as isize);
            tracer.read_register(s_2511_1 as isize, value);
            value
        };
        // D s_2511_3: cmp-lt s_2511_2 s_2511_0
        let s_2511_3: bool = ((s_2511_2) < (s_2511_0));
        // D s_2511_4: write-var gs#406140 <= s_2511_3
        fn_state.gs_406140 = s_2511_3;
        // N s_2511_5: jump b2510
        return block_2510(state, tracer, fn_state);
    }
    fn block_2512<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2512_0: const #4s : i
        let s_2512_0: i128 = 4;
        // D s_2512_1: read-var u#32817:u32
        let s_2512_1: u32 = fn_state.u_32817;
        // D s_2512_2: cast zx s_2512_1 -> bv
        let s_2512_2: Bits = Bits::new(s_2512_1 as u128, 32u16);
        // C s_2512_3: const #1s : i64
        let s_2512_3: i64 = 1;
        // C s_2512_4: cast zx s_2512_3 -> i
        let s_2512_4: i128 = (i128::try_from(s_2512_3).unwrap());
        // C s_2512_5: const #7s : i
        let s_2512_5: i128 = 7;
        // C s_2512_6: add s_2512_5 s_2512_4
        let s_2512_6: i128 = (s_2512_5 + s_2512_4);
        // D s_2512_7: bit-extract s_2512_2 s_2512_0 s_2512_6
        let s_2512_7: Bits = (Bits::new(
            ((s_2512_2) >> (s_2512_0)).value(),
            u16::try_from(s_2512_6).unwrap(),
        ));
        // D s_2512_8: cast reint s_2512_7 -> u8
        let s_2512_8: u8 = (s_2512_7.value() as u8);
        // D s_2512_9: cast zx s_2512_8 -> bv
        let s_2512_9: Bits = Bits::new(s_2512_8 as u128, 8u16);
        // C s_2512_10: const #5u : u8
        let s_2512_10: u8 = 5;
        // C s_2512_11: cast zx s_2512_10 -> bv
        let s_2512_11: Bits = Bits::new(s_2512_10 as u128, 8u16);
        // D s_2512_12: cmp-eq s_2512_9 s_2512_11
        let s_2512_12: bool = ((s_2512_9) == (s_2512_11));
        // D s_2512_13: write-var gs#406136 <= s_2512_12
        fn_state.gs_406136 = s_2512_12;
        // N s_2512_14: jump b898
        return block_898(state, tracer, fn_state);
    }
    fn block_2513<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2513_0: const #28s : i
        let s_2513_0: i128 = 28;
        // C s_2513_1: const #4s : i
        let s_2513_1: i128 = 4;
        // D s_2513_2: read-var u#32811:u32
        let s_2513_2: u32 = fn_state.u_32811;
        // D s_2513_3: cast zx s_2513_2 -> bv
        let s_2513_3: Bits = Bits::new(s_2513_2 as u128, 32u16);
        // D s_2513_4: bit-extract s_2513_3 s_2513_0 s_2513_1
        let s_2513_4: Bits = (Bits::new(
            ((s_2513_3) >> (s_2513_0)).value(),
            u16::try_from(s_2513_1).unwrap(),
        ));
        // D s_2513_5: cast reint s_2513_4 -> u8
        let s_2513_5: u8 = (s_2513_4.value() as u8);
        // D s_2513_6: cast zx s_2513_5 -> bv
        let s_2513_6: Bits = Bits::new(s_2513_5 as u128, 4u16);
        // C s_2513_7: const #15u : u8
        let s_2513_7: u8 = 15;
        // C s_2513_8: cast zx s_2513_7 -> bv
        let s_2513_8: Bits = Bits::new(s_2513_7 as u128, 4u16);
        // D s_2513_9: cmp-ne s_2513_6 s_2513_8
        let s_2513_9: bool = ((s_2513_6) != (s_2513_8));
        // N s_2513_10: branch s_2513_9 b2516 b2514
        if s_2513_9 {
            return block_2516(state, tracer, fn_state);
        } else {
            return block_2514(state, tracer, fn_state);
        };
    }
    fn block_2514<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2514_0: const #0u : u8
        let s_2514_0: bool = false;
        // D s_2514_1: write-var gs#406108 <= s_2514_0
        fn_state.gs_406108 = s_2514_0;
        // N s_2514_2: jump b2515
        return block_2515(state, tracer, fn_state);
    }
    fn block_2515<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2515_0: read-var gs#406108:u8
        let s_2515_0: bool = fn_state.gs_406108;
        // D s_2515_1: write-var gs#406109 <= s_2515_0
        fn_state.gs_406109 = s_2515_0;
        // N s_2515_2: jump b883
        return block_883(state, tracer, fn_state);
    }
    fn block_2516<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2516_0: const #3074s : i
        let s_2516_0: i128 = 3074;
        // C s_2516_1: const #14696u : u32
        let s_2516_1: u32 = 14696;
        // D s_2516_2: read-reg s_2516_1:i
        let s_2516_2: i128 = {
            let value = state.read_register::<i128>(s_2516_1 as isize);
            tracer.read_register(s_2516_1 as isize, value);
            value
        };
        // D s_2516_3: cmp-lt s_2516_2 s_2516_0
        let s_2516_3: bool = ((s_2516_2) < (s_2516_0));
        // D s_2516_4: write-var gs#406108 <= s_2516_3
        fn_state.gs_406108 = s_2516_3;
        // N s_2516_5: jump b2515
        return block_2515(state, tracer, fn_state);
    }
    fn block_2517<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2517_0: const #4s : i
        let s_2517_0: i128 = 4;
        // D s_2517_1: read-var u#32811:u32
        let s_2517_1: u32 = fn_state.u_32811;
        // D s_2517_2: cast zx s_2517_1 -> bv
        let s_2517_2: Bits = Bits::new(s_2517_1 as u128, 32u16);
        // C s_2517_3: const #1s : i64
        let s_2517_3: i64 = 1;
        // C s_2517_4: cast zx s_2517_3 -> i
        let s_2517_4: i128 = (i128::try_from(s_2517_3).unwrap());
        // C s_2517_5: const #7s : i
        let s_2517_5: i128 = 7;
        // C s_2517_6: add s_2517_5 s_2517_4
        let s_2517_6: i128 = (s_2517_5 + s_2517_4);
        // D s_2517_7: bit-extract s_2517_2 s_2517_0 s_2517_6
        let s_2517_7: Bits = (Bits::new(
            ((s_2517_2) >> (s_2517_0)).value(),
            u16::try_from(s_2517_6).unwrap(),
        ));
        // D s_2517_8: cast reint s_2517_7 -> u8
        let s_2517_8: u8 = (s_2517_7.value() as u8);
        // D s_2517_9: cast zx s_2517_8 -> bv
        let s_2517_9: Bits = Bits::new(s_2517_8 as u128, 8u16);
        // C s_2517_10: const #5u : u8
        let s_2517_10: u8 = 5;
        // C s_2517_11: cast zx s_2517_10 -> bv
        let s_2517_11: Bits = Bits::new(s_2517_10 as u128, 8u16);
        // D s_2517_12: cmp-eq s_2517_9 s_2517_11
        let s_2517_12: bool = ((s_2517_9) == (s_2517_11));
        // D s_2517_13: write-var gs#406104 <= s_2517_12
        fn_state.gs_406104 = s_2517_12;
        // N s_2517_14: jump b881
        return block_881(state, tracer, fn_state);
    }
    fn block_2518<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2518_0: const #28s : i
        let s_2518_0: i128 = 28;
        // C s_2518_1: const #4s : i
        let s_2518_1: i128 = 4;
        // D s_2518_2: read-var u#32805:u32
        let s_2518_2: u32 = fn_state.u_32805;
        // D s_2518_3: cast zx s_2518_2 -> bv
        let s_2518_3: Bits = Bits::new(s_2518_2 as u128, 32u16);
        // D s_2518_4: bit-extract s_2518_3 s_2518_0 s_2518_1
        let s_2518_4: Bits = (Bits::new(
            ((s_2518_3) >> (s_2518_0)).value(),
            u16::try_from(s_2518_1).unwrap(),
        ));
        // D s_2518_5: cast reint s_2518_4 -> u8
        let s_2518_5: u8 = (s_2518_4.value() as u8);
        // D s_2518_6: cast zx s_2518_5 -> bv
        let s_2518_6: Bits = Bits::new(s_2518_5 as u128, 4u16);
        // C s_2518_7: const #15u : u8
        let s_2518_7: u8 = 15;
        // C s_2518_8: cast zx s_2518_7 -> bv
        let s_2518_8: Bits = Bits::new(s_2518_7 as u128, 4u16);
        // D s_2518_9: cmp-ne s_2518_6 s_2518_8
        let s_2518_9: bool = ((s_2518_6) != (s_2518_8));
        // N s_2518_10: branch s_2518_9 b2521 b2519
        if s_2518_9 {
            return block_2521(state, tracer, fn_state);
        } else {
            return block_2519(state, tracer, fn_state);
        };
    }
    fn block_2519<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2519_0: const #0u : u8
        let s_2519_0: bool = false;
        // D s_2519_1: write-var gs#406076 <= s_2519_0
        fn_state.gs_406076 = s_2519_0;
        // N s_2519_2: jump b2520
        return block_2520(state, tracer, fn_state);
    }
    fn block_2520<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2520_0: read-var gs#406076:u8
        let s_2520_0: bool = fn_state.gs_406076;
        // D s_2520_1: write-var gs#406077 <= s_2520_0
        fn_state.gs_406077 = s_2520_0;
        // N s_2520_2: jump b866
        return block_866(state, tracer, fn_state);
    }
    fn block_2521<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2521_0: const #3072s : i
        let s_2521_0: i128 = 3072;
        // C s_2521_1: const #14696u : u32
        let s_2521_1: u32 = 14696;
        // D s_2521_2: read-reg s_2521_1:i
        let s_2521_2: i128 = {
            let value = state.read_register::<i128>(s_2521_1 as isize);
            tracer.read_register(s_2521_1 as isize, value);
            value
        };
        // D s_2521_3: cmp-lt s_2521_2 s_2521_0
        let s_2521_3: bool = ((s_2521_2) < (s_2521_0));
        // D s_2521_4: write-var gs#406076 <= s_2521_3
        fn_state.gs_406076 = s_2521_3;
        // N s_2521_5: jump b2520
        return block_2520(state, tracer, fn_state);
    }
    fn block_2522<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2522_0: const #4s : i
        let s_2522_0: i128 = 4;
        // D s_2522_1: read-var u#32805:u32
        let s_2522_1: u32 = fn_state.u_32805;
        // D s_2522_2: cast zx s_2522_1 -> bv
        let s_2522_2: Bits = Bits::new(s_2522_1 as u128, 32u16);
        // C s_2522_3: const #1s : i64
        let s_2522_3: i64 = 1;
        // C s_2522_4: cast zx s_2522_3 -> i
        let s_2522_4: i128 = (i128::try_from(s_2522_3).unwrap());
        // C s_2522_5: const #7s : i
        let s_2522_5: i128 = 7;
        // C s_2522_6: add s_2522_5 s_2522_4
        let s_2522_6: i128 = (s_2522_5 + s_2522_4);
        // D s_2522_7: bit-extract s_2522_2 s_2522_0 s_2522_6
        let s_2522_7: Bits = (Bits::new(
            ((s_2522_2) >> (s_2522_0)).value(),
            u16::try_from(s_2522_6).unwrap(),
        ));
        // D s_2522_8: cast reint s_2522_7 -> u8
        let s_2522_8: u8 = (s_2522_7.value() as u8);
        // D s_2522_9: cast zx s_2522_8 -> bv
        let s_2522_9: Bits = Bits::new(s_2522_8 as u128, 8u16);
        // C s_2522_10: const #5u : u8
        let s_2522_10: u8 = 5;
        // C s_2522_11: cast zx s_2522_10 -> bv
        let s_2522_11: Bits = Bits::new(s_2522_10 as u128, 8u16);
        // D s_2522_12: cmp-eq s_2522_9 s_2522_11
        let s_2522_12: bool = ((s_2522_9) == (s_2522_11));
        // D s_2522_13: write-var gs#406072 <= s_2522_12
        fn_state.gs_406072 = s_2522_12;
        // N s_2522_14: jump b864
        return block_864(state, tracer, fn_state);
    }
    fn block_2523<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2523_0: const #28s : i
        let s_2523_0: i128 = 28;
        // C s_2523_1: const #4s : i
        let s_2523_1: i128 = 4;
        // D s_2523_2: read-var u#32799:u32
        let s_2523_2: u32 = fn_state.u_32799;
        // D s_2523_3: cast zx s_2523_2 -> bv
        let s_2523_3: Bits = Bits::new(s_2523_2 as u128, 32u16);
        // D s_2523_4: bit-extract s_2523_3 s_2523_0 s_2523_1
        let s_2523_4: Bits = (Bits::new(
            ((s_2523_3) >> (s_2523_0)).value(),
            u16::try_from(s_2523_1).unwrap(),
        ));
        // D s_2523_5: cast reint s_2523_4 -> u8
        let s_2523_5: u8 = (s_2523_4.value() as u8);
        // D s_2523_6: cast zx s_2523_5 -> bv
        let s_2523_6: Bits = Bits::new(s_2523_5 as u128, 4u16);
        // C s_2523_7: const #15u : u8
        let s_2523_7: u8 = 15;
        // C s_2523_8: cast zx s_2523_7 -> bv
        let s_2523_8: Bits = Bits::new(s_2523_7 as u128, 4u16);
        // D s_2523_9: cmp-ne s_2523_6 s_2523_8
        let s_2523_9: bool = ((s_2523_6) != (s_2523_8));
        // N s_2523_10: branch s_2523_9 b2526 b2524
        if s_2523_9 {
            return block_2526(state, tracer, fn_state);
        } else {
            return block_2524(state, tracer, fn_state);
        };
    }
    fn block_2524<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2524_0: const #0u : u8
        let s_2524_0: bool = false;
        // D s_2524_1: write-var gs#406044 <= s_2524_0
        fn_state.gs_406044 = s_2524_0;
        // N s_2524_2: jump b2525
        return block_2525(state, tracer, fn_state);
    }
    fn block_2525<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2525_0: read-var gs#406044:u8
        let s_2525_0: bool = fn_state.gs_406044;
        // D s_2525_1: write-var gs#406045 <= s_2525_0
        fn_state.gs_406045 = s_2525_0;
        // N s_2525_2: jump b849
        return block_849(state, tracer, fn_state);
    }
    fn block_2526<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2526_0: const #3068s : i
        let s_2526_0: i128 = 3068;
        // C s_2526_1: const #14696u : u32
        let s_2526_1: u32 = 14696;
        // D s_2526_2: read-reg s_2526_1:i
        let s_2526_2: i128 = {
            let value = state.read_register::<i128>(s_2526_1 as isize);
            tracer.read_register(s_2526_1 as isize, value);
            value
        };
        // D s_2526_3: cmp-lt s_2526_2 s_2526_0
        let s_2526_3: bool = ((s_2526_2) < (s_2526_0));
        // D s_2526_4: write-var gs#406044 <= s_2526_3
        fn_state.gs_406044 = s_2526_3;
        // N s_2526_5: jump b2525
        return block_2525(state, tracer, fn_state);
    }
    fn block_2527<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2527_0: const #4s : i
        let s_2527_0: i128 = 4;
        // D s_2527_1: read-var u#32799:u32
        let s_2527_1: u32 = fn_state.u_32799;
        // D s_2527_2: cast zx s_2527_1 -> bv
        let s_2527_2: Bits = Bits::new(s_2527_1 as u128, 32u16);
        // C s_2527_3: const #1s : i64
        let s_2527_3: i64 = 1;
        // C s_2527_4: cast zx s_2527_3 -> i
        let s_2527_4: i128 = (i128::try_from(s_2527_3).unwrap());
        // C s_2527_5: const #7s : i
        let s_2527_5: i128 = 7;
        // C s_2527_6: add s_2527_5 s_2527_4
        let s_2527_6: i128 = (s_2527_5 + s_2527_4);
        // D s_2527_7: bit-extract s_2527_2 s_2527_0 s_2527_6
        let s_2527_7: Bits = (Bits::new(
            ((s_2527_2) >> (s_2527_0)).value(),
            u16::try_from(s_2527_6).unwrap(),
        ));
        // D s_2527_8: cast reint s_2527_7 -> u8
        let s_2527_8: u8 = (s_2527_7.value() as u8);
        // D s_2527_9: cast zx s_2527_8 -> bv
        let s_2527_9: Bits = Bits::new(s_2527_8 as u128, 8u16);
        // C s_2527_10: const #5u : u8
        let s_2527_10: u8 = 5;
        // C s_2527_11: cast zx s_2527_10 -> bv
        let s_2527_11: Bits = Bits::new(s_2527_10 as u128, 8u16);
        // D s_2527_12: cmp-eq s_2527_9 s_2527_11
        let s_2527_12: bool = ((s_2527_9) == (s_2527_11));
        // D s_2527_13: write-var gs#406040 <= s_2527_12
        fn_state.gs_406040 = s_2527_12;
        // N s_2527_14: jump b847
        return block_847(state, tracer, fn_state);
    }
    fn block_2528<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2528_0: const #28s : i
        let s_2528_0: i128 = 28;
        // C s_2528_1: const #4s : i
        let s_2528_1: i128 = 4;
        // D s_2528_2: read-var u#32790:u32
        let s_2528_2: u32 = fn_state.u_32790;
        // D s_2528_3: cast zx s_2528_2 -> bv
        let s_2528_3: Bits = Bits::new(s_2528_2 as u128, 32u16);
        // D s_2528_4: bit-extract s_2528_3 s_2528_0 s_2528_1
        let s_2528_4: Bits = (Bits::new(
            ((s_2528_3) >> (s_2528_0)).value(),
            u16::try_from(s_2528_1).unwrap(),
        ));
        // D s_2528_5: cast reint s_2528_4 -> u8
        let s_2528_5: u8 = (s_2528_4.value() as u8);
        // D s_2528_6: cast zx s_2528_5 -> bv
        let s_2528_6: Bits = Bits::new(s_2528_5 as u128, 4u16);
        // C s_2528_7: const #15u : u8
        let s_2528_7: u8 = 15;
        // C s_2528_8: cast zx s_2528_7 -> bv
        let s_2528_8: Bits = Bits::new(s_2528_7 as u128, 4u16);
        // D s_2528_9: cmp-ne s_2528_6 s_2528_8
        let s_2528_9: bool = ((s_2528_6) != (s_2528_8));
        // N s_2528_10: branch s_2528_9 b2531 b2529
        if s_2528_9 {
            return block_2531(state, tracer, fn_state);
        } else {
            return block_2529(state, tracer, fn_state);
        };
    }
    fn block_2529<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2529_0: const #0u : u8
        let s_2529_0: bool = false;
        // D s_2529_1: write-var gs#406017 <= s_2529_0
        fn_state.gs_406017 = s_2529_0;
        // N s_2529_2: jump b2530
        return block_2530(state, tracer, fn_state);
    }
    fn block_2530<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2530_0: read-var gs#406017:u8
        let s_2530_0: bool = fn_state.gs_406017;
        // D s_2530_1: write-var gs#406018 <= s_2530_0
        fn_state.gs_406018 = s_2530_0;
        // N s_2530_2: jump b843
        return block_843(state, tracer, fn_state);
    }
    fn block_2531<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2531_0: const #3046s : i
        let s_2531_0: i128 = 3046;
        // C s_2531_1: const #14696u : u32
        let s_2531_1: u32 = 14696;
        // D s_2531_2: read-reg s_2531_1:i
        let s_2531_2: i128 = {
            let value = state.read_register::<i128>(s_2531_1 as isize);
            tracer.read_register(s_2531_1 as isize, value);
            value
        };
        // D s_2531_3: cmp-lt s_2531_2 s_2531_0
        let s_2531_3: bool = ((s_2531_2) < (s_2531_0));
        // D s_2531_4: write-var gs#406017 <= s_2531_3
        fn_state.gs_406017 = s_2531_3;
        // N s_2531_5: jump b2530
        return block_2530(state, tracer, fn_state);
    }
    fn block_2532<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2532_0: const #7s : i
        let s_2532_0: i128 = 7;
        // D s_2532_1: read-var u#32790:u32
        let s_2532_1: u32 = fn_state.u_32790;
        // D s_2532_2: cast zx s_2532_1 -> bv
        let s_2532_2: Bits = Bits::new(s_2532_1 as u128, 32u16);
        // C s_2532_3: const #1s : i64
        let s_2532_3: i64 = 1;
        // C s_2532_4: cast zx s_2532_3 -> i
        let s_2532_4: i128 = (i128::try_from(s_2532_3).unwrap());
        // C s_2532_5: const #0s : i
        let s_2532_5: i128 = 0;
        // C s_2532_6: add s_2532_5 s_2532_4
        let s_2532_6: i128 = (s_2532_5 + s_2532_4);
        // D s_2532_7: bit-extract s_2532_2 s_2532_0 s_2532_6
        let s_2532_7: Bits = (Bits::new(
            ((s_2532_2) >> (s_2532_0)).value(),
            u16::try_from(s_2532_6).unwrap(),
        ));
        // D s_2532_8: cast reint s_2532_7 -> u8
        let s_2532_8: bool = ((s_2532_7.value()) != 0);
        // D s_2532_9: cast zx s_2532_8 -> bv
        let s_2532_9: Bits = Bits::new(s_2532_8 as u128, 1u16);
        // C s_2532_10: const #0u : u8
        let s_2532_10: bool = false;
        // C s_2532_11: cast zx s_2532_10 -> bv
        let s_2532_11: Bits = Bits::new(s_2532_10 as u128, 1u16);
        // D s_2532_12: cmp-eq s_2532_9 s_2532_11
        let s_2532_12: bool = ((s_2532_9) == (s_2532_11));
        // N s_2532_13: branch s_2532_12 b2535 b2533
        if s_2532_12 {
            return block_2535(state, tracer, fn_state);
        } else {
            return block_2533(state, tracer, fn_state);
        };
    }
    fn block_2533<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2533_0: const #0u : u8
        let s_2533_0: bool = false;
        // D s_2533_1: write-var gs#406012 <= s_2533_0
        fn_state.gs_406012 = s_2533_0;
        // N s_2533_2: jump b2534
        return block_2534(state, tracer, fn_state);
    }
    fn block_2534<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2534_0: read-var gs#406012:u8
        let s_2534_0: bool = fn_state.gs_406012;
        // D s_2534_1: write-var gs#406013 <= s_2534_0
        fn_state.gs_406013 = s_2534_0;
        // N s_2534_2: jump b841
        return block_841(state, tracer, fn_state);
    }
    fn block_2535<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2535_0: const #4s : i
        let s_2535_0: i128 = 4;
        // D s_2535_1: read-var u#32790:u32
        let s_2535_1: u32 = fn_state.u_32790;
        // D s_2535_2: cast zx s_2535_1 -> bv
        let s_2535_2: Bits = Bits::new(s_2535_1 as u128, 32u16);
        // C s_2535_3: const #1s : i64
        let s_2535_3: i64 = 1;
        // C s_2535_4: cast zx s_2535_3 -> i
        let s_2535_4: i128 = (i128::try_from(s_2535_3).unwrap());
        // C s_2535_5: const #0s : i
        let s_2535_5: i128 = 0;
        // C s_2535_6: add s_2535_5 s_2535_4
        let s_2535_6: i128 = (s_2535_5 + s_2535_4);
        // D s_2535_7: bit-extract s_2535_2 s_2535_0 s_2535_6
        let s_2535_7: Bits = (Bits::new(
            ((s_2535_2) >> (s_2535_0)).value(),
            u16::try_from(s_2535_6).unwrap(),
        ));
        // D s_2535_8: cast reint s_2535_7 -> u8
        let s_2535_8: bool = ((s_2535_7.value()) != 0);
        // D s_2535_9: cast zx s_2535_8 -> bv
        let s_2535_9: Bits = Bits::new(s_2535_8 as u128, 1u16);
        // C s_2535_10: const #1u : u8
        let s_2535_10: bool = true;
        // C s_2535_11: cast zx s_2535_10 -> bv
        let s_2535_11: Bits = Bits::new(s_2535_10 as u128, 1u16);
        // D s_2535_12: cmp-eq s_2535_9 s_2535_11
        let s_2535_12: bool = ((s_2535_9) == (s_2535_11));
        // D s_2535_13: write-var gs#406012 <= s_2535_12
        fn_state.gs_406012 = s_2535_12;
        // N s_2535_14: jump b2534
        return block_2534(state, tracer, fn_state);
    }
    fn block_2536<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2536_0: const #28s : i
        let s_2536_0: i128 = 28;
        // C s_2536_1: const #4s : i
        let s_2536_1: i128 = 4;
        // D s_2536_2: read-var u#32781:u32
        let s_2536_2: u32 = fn_state.u_32781;
        // D s_2536_3: cast zx s_2536_2 -> bv
        let s_2536_3: Bits = Bits::new(s_2536_2 as u128, 32u16);
        // D s_2536_4: bit-extract s_2536_3 s_2536_0 s_2536_1
        let s_2536_4: Bits = (Bits::new(
            ((s_2536_3) >> (s_2536_0)).value(),
            u16::try_from(s_2536_1).unwrap(),
        ));
        // D s_2536_5: cast reint s_2536_4 -> u8
        let s_2536_5: u8 = (s_2536_4.value() as u8);
        // D s_2536_6: cast zx s_2536_5 -> bv
        let s_2536_6: Bits = Bits::new(s_2536_5 as u128, 4u16);
        // C s_2536_7: const #15u : u8
        let s_2536_7: u8 = 15;
        // C s_2536_8: cast zx s_2536_7 -> bv
        let s_2536_8: Bits = Bits::new(s_2536_7 as u128, 4u16);
        // D s_2536_9: cmp-ne s_2536_6 s_2536_8
        let s_2536_9: bool = ((s_2536_6) != (s_2536_8));
        // N s_2536_10: branch s_2536_9 b2539 b2537
        if s_2536_9 {
            return block_2539(state, tracer, fn_state);
        } else {
            return block_2537(state, tracer, fn_state);
        };
    }
    fn block_2537<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2537_0: const #0u : u8
        let s_2537_0: bool = false;
        // D s_2537_1: write-var gs#405987 <= s_2537_0
        fn_state.gs_405987 = s_2537_0;
        // N s_2537_2: jump b2538
        return block_2538(state, tracer, fn_state);
    }
    fn block_2538<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2538_0: read-var gs#405987:u8
        let s_2538_0: bool = fn_state.gs_405987;
        // D s_2538_1: write-var gs#405988 <= s_2538_0
        fn_state.gs_405988 = s_2538_0;
        // N s_2538_2: jump b837
        return block_837(state, tracer, fn_state);
    }
    fn block_2539<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2539_0: const #3043s : i
        let s_2539_0: i128 = 3043;
        // C s_2539_1: const #14696u : u32
        let s_2539_1: u32 = 14696;
        // D s_2539_2: read-reg s_2539_1:i
        let s_2539_2: i128 = {
            let value = state.read_register::<i128>(s_2539_1 as isize);
            tracer.read_register(s_2539_1 as isize, value);
            value
        };
        // D s_2539_3: cmp-lt s_2539_2 s_2539_0
        let s_2539_3: bool = ((s_2539_2) < (s_2539_0));
        // D s_2539_4: write-var gs#405987 <= s_2539_3
        fn_state.gs_405987 = s_2539_3;
        // N s_2539_5: jump b2538
        return block_2538(state, tracer, fn_state);
    }
    fn block_2540<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2540_0: const #4s : i
        let s_2540_0: i128 = 4;
        // D s_2540_1: read-var u#32781:u32
        let s_2540_1: u32 = fn_state.u_32781;
        // D s_2540_2: cast zx s_2540_1 -> bv
        let s_2540_2: Bits = Bits::new(s_2540_1 as u128, 32u16);
        // C s_2540_3: const #1s : i64
        let s_2540_3: i64 = 1;
        // C s_2540_4: cast zx s_2540_3 -> i
        let s_2540_4: i128 = (i128::try_from(s_2540_3).unwrap());
        // C s_2540_5: const #0s : i
        let s_2540_5: i128 = 0;
        // C s_2540_6: add s_2540_5 s_2540_4
        let s_2540_6: i128 = (s_2540_5 + s_2540_4);
        // D s_2540_7: bit-extract s_2540_2 s_2540_0 s_2540_6
        let s_2540_7: Bits = (Bits::new(
            ((s_2540_2) >> (s_2540_0)).value(),
            u16::try_from(s_2540_6).unwrap(),
        ));
        // D s_2540_8: cast reint s_2540_7 -> u8
        let s_2540_8: bool = ((s_2540_7.value()) != 0);
        // D s_2540_9: cast zx s_2540_8 -> bv
        let s_2540_9: Bits = Bits::new(s_2540_8 as u128, 1u16);
        // C s_2540_10: const #0u : u8
        let s_2540_10: bool = false;
        // C s_2540_11: cast zx s_2540_10 -> bv
        let s_2540_11: Bits = Bits::new(s_2540_10 as u128, 1u16);
        // D s_2540_12: cmp-eq s_2540_9 s_2540_11
        let s_2540_12: bool = ((s_2540_9) == (s_2540_11));
        // D s_2540_13: write-var gs#405983 <= s_2540_12
        fn_state.gs_405983 = s_2540_12;
        // N s_2540_14: jump b835
        return block_835(state, tracer, fn_state);
    }
    fn block_2541<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2541_0: const #28s : i
        let s_2541_0: i128 = 28;
        // C s_2541_1: const #4s : i
        let s_2541_1: i128 = 4;
        // D s_2541_2: read-var u#32774:u32
        let s_2541_2: u32 = fn_state.u_32774;
        // D s_2541_3: cast zx s_2541_2 -> bv
        let s_2541_3: Bits = Bits::new(s_2541_2 as u128, 32u16);
        // D s_2541_4: bit-extract s_2541_3 s_2541_0 s_2541_1
        let s_2541_4: Bits = (Bits::new(
            ((s_2541_3) >> (s_2541_0)).value(),
            u16::try_from(s_2541_1).unwrap(),
        ));
        // D s_2541_5: cast reint s_2541_4 -> u8
        let s_2541_5: u8 = (s_2541_4.value() as u8);
        // D s_2541_6: cast zx s_2541_5 -> bv
        let s_2541_6: Bits = Bits::new(s_2541_5 as u128, 4u16);
        // C s_2541_7: const #15u : u8
        let s_2541_7: u8 = 15;
        // C s_2541_8: cast zx s_2541_7 -> bv
        let s_2541_8: Bits = Bits::new(s_2541_7 as u128, 4u16);
        // D s_2541_9: cmp-ne s_2541_6 s_2541_8
        let s_2541_9: bool = ((s_2541_6) != (s_2541_8));
        // N s_2541_10: branch s_2541_9 b2544 b2542
        if s_2541_9 {
            return block_2544(state, tracer, fn_state);
        } else {
            return block_2542(state, tracer, fn_state);
        };
    }
    fn block_2542<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2542_0: const #0u : u8
        let s_2542_0: bool = false;
        // D s_2542_1: write-var gs#405964 <= s_2542_0
        fn_state.gs_405964 = s_2542_0;
        // N s_2542_2: jump b2543
        return block_2543(state, tracer, fn_state);
    }
    fn block_2543<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2543_0: read-var gs#405964:u8
        let s_2543_0: bool = fn_state.gs_405964;
        // D s_2543_1: write-var gs#405965 <= s_2543_0
        fn_state.gs_405965 = s_2543_0;
        // N s_2543_2: jump b831
        return block_831(state, tracer, fn_state);
    }
    fn block_2544<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2544_0: const #3041s : i
        let s_2544_0: i128 = 3041;
        // C s_2544_1: const #14696u : u32
        let s_2544_1: u32 = 14696;
        // D s_2544_2: read-reg s_2544_1:i
        let s_2544_2: i128 = {
            let value = state.read_register::<i128>(s_2544_1 as isize);
            tracer.read_register(s_2544_1 as isize, value);
            value
        };
        // D s_2544_3: cmp-lt s_2544_2 s_2544_0
        let s_2544_3: bool = ((s_2544_2) < (s_2544_0));
        // D s_2544_4: write-var gs#405964 <= s_2544_3
        fn_state.gs_405964 = s_2544_3;
        // N s_2544_5: jump b2543
        return block_2543(state, tracer, fn_state);
    }
    fn block_2545<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2545_0: const #28s : i
        let s_2545_0: i128 = 28;
        // C s_2545_1: const #4s : i
        let s_2545_1: i128 = 4;
        // D s_2545_2: read-var u#32771:u32
        let s_2545_2: u32 = fn_state.u_32771;
        // D s_2545_3: cast zx s_2545_2 -> bv
        let s_2545_3: Bits = Bits::new(s_2545_2 as u128, 32u16);
        // D s_2545_4: bit-extract s_2545_3 s_2545_0 s_2545_1
        let s_2545_4: Bits = (Bits::new(
            ((s_2545_3) >> (s_2545_0)).value(),
            u16::try_from(s_2545_1).unwrap(),
        ));
        // D s_2545_5: cast reint s_2545_4 -> u8
        let s_2545_5: u8 = (s_2545_4.value() as u8);
        // D s_2545_6: cast zx s_2545_5 -> bv
        let s_2545_6: Bits = Bits::new(s_2545_5 as u128, 4u16);
        // C s_2545_7: const #15u : u8
        let s_2545_7: u8 = 15;
        // C s_2545_8: cast zx s_2545_7 -> bv
        let s_2545_8: Bits = Bits::new(s_2545_7 as u128, 4u16);
        // D s_2545_9: cmp-ne s_2545_6 s_2545_8
        let s_2545_9: bool = ((s_2545_6) != (s_2545_8));
        // N s_2545_10: branch s_2545_9 b2548 b2546
        if s_2545_9 {
            return block_2548(state, tracer, fn_state);
        } else {
            return block_2546(state, tracer, fn_state);
        };
    }
    fn block_2546<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2546_0: const #0u : u8
        let s_2546_0: bool = false;
        // D s_2546_1: write-var gs#405929 <= s_2546_0
        fn_state.gs_405929 = s_2546_0;
        // N s_2546_2: jump b2547
        return block_2547(state, tracer, fn_state);
    }
    fn block_2547<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2547_0: read-var gs#405929:u8
        let s_2547_0: bool = fn_state.gs_405929;
        // D s_2547_1: write-var gs#405930 <= s_2547_0
        fn_state.gs_405930 = s_2547_0;
        // N s_2547_2: jump b804
        return block_804(state, tracer, fn_state);
    }
    fn block_2548<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2548_0: const #3036s : i
        let s_2548_0: i128 = 3036;
        // C s_2548_1: const #14696u : u32
        let s_2548_1: u32 = 14696;
        // D s_2548_2: read-reg s_2548_1:i
        let s_2548_2: i128 = {
            let value = state.read_register::<i128>(s_2548_1 as isize);
            tracer.read_register(s_2548_1 as isize, value);
            value
        };
        // D s_2548_3: cmp-lt s_2548_2 s_2548_0
        let s_2548_3: bool = ((s_2548_2) < (s_2548_0));
        // D s_2548_4: write-var gs#405929 <= s_2548_3
        fn_state.gs_405929 = s_2548_3;
        // N s_2548_5: jump b2547
        return block_2547(state, tracer, fn_state);
    }
    fn block_2549<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2549_0: const #28s : i
        let s_2549_0: i128 = 28;
        // C s_2549_1: const #4s : i
        let s_2549_1: i128 = 4;
        // D s_2549_2: read-var u#32763:u32
        let s_2549_2: u32 = fn_state.u_32763;
        // D s_2549_3: cast zx s_2549_2 -> bv
        let s_2549_3: Bits = Bits::new(s_2549_2 as u128, 32u16);
        // D s_2549_4: bit-extract s_2549_3 s_2549_0 s_2549_1
        let s_2549_4: Bits = (Bits::new(
            ((s_2549_3) >> (s_2549_0)).value(),
            u16::try_from(s_2549_1).unwrap(),
        ));
        // D s_2549_5: cast reint s_2549_4 -> u8
        let s_2549_5: u8 = (s_2549_4.value() as u8);
        // D s_2549_6: cast zx s_2549_5 -> bv
        let s_2549_6: Bits = Bits::new(s_2549_5 as u128, 4u16);
        // C s_2549_7: const #15u : u8
        let s_2549_7: u8 = 15;
        // C s_2549_8: cast zx s_2549_7 -> bv
        let s_2549_8: Bits = Bits::new(s_2549_7 as u128, 4u16);
        // D s_2549_9: cmp-ne s_2549_6 s_2549_8
        let s_2549_9: bool = ((s_2549_6) != (s_2549_8));
        // N s_2549_10: branch s_2549_9 b2552 b2550
        if s_2549_9 {
            return block_2552(state, tracer, fn_state);
        } else {
            return block_2550(state, tracer, fn_state);
        };
    }
    fn block_2550<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2550_0: const #0u : u8
        let s_2550_0: bool = false;
        // D s_2550_1: write-var gs#405896 <= s_2550_0
        fn_state.gs_405896 = s_2550_0;
        // N s_2550_2: jump b2551
        return block_2551(state, tracer, fn_state);
    }
    fn block_2551<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2551_0: read-var gs#405896:u8
        let s_2551_0: bool = fn_state.gs_405896;
        // D s_2551_1: write-var gs#405897 <= s_2551_0
        fn_state.gs_405897 = s_2551_0;
        // N s_2551_2: jump b789
        return block_789(state, tracer, fn_state);
    }
    fn block_2552<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2552_0: const #3035s : i
        let s_2552_0: i128 = 3035;
        // C s_2552_1: const #14696u : u32
        let s_2552_1: u32 = 14696;
        // D s_2552_2: read-reg s_2552_1:i
        let s_2552_2: i128 = {
            let value = state.read_register::<i128>(s_2552_1 as isize);
            tracer.read_register(s_2552_1 as isize, value);
            value
        };
        // D s_2552_3: cmp-lt s_2552_2 s_2552_0
        let s_2552_3: bool = ((s_2552_2) < (s_2552_0));
        // D s_2552_4: write-var gs#405896 <= s_2552_3
        fn_state.gs_405896 = s_2552_3;
        // N s_2552_5: jump b2551
        return block_2551(state, tracer, fn_state);
    }
    fn block_2553<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2553_0: const #16s : i
        let s_2553_0: i128 = 16;
        // D s_2553_1: read-var u#32763:u32
        let s_2553_1: u32 = fn_state.u_32763;
        // D s_2553_2: cast zx s_2553_1 -> bv
        let s_2553_2: Bits = Bits::new(s_2553_1 as u128, 32u16);
        // C s_2553_3: const #1s : i64
        let s_2553_3: i64 = 1;
        // C s_2553_4: cast zx s_2553_3 -> i
        let s_2553_4: i128 = (i128::try_from(s_2553_3).unwrap());
        // C s_2553_5: const #3s : i
        let s_2553_5: i128 = 3;
        // C s_2553_6: add s_2553_5 s_2553_4
        let s_2553_6: i128 = (s_2553_5 + s_2553_4);
        // D s_2553_7: bit-extract s_2553_2 s_2553_0 s_2553_6
        let s_2553_7: Bits = (Bits::new(
            ((s_2553_2) >> (s_2553_0)).value(),
            u16::try_from(s_2553_6).unwrap(),
        ));
        // D s_2553_8: cast reint s_2553_7 -> u8
        let s_2553_8: u8 = (s_2553_7.value() as u8);
        // D s_2553_9: cast zx s_2553_8 -> bv
        let s_2553_9: Bits = Bits::new(s_2553_8 as u128, 4u16);
        // C s_2553_10: const #0u : u8
        let s_2553_10: u8 = 0;
        // C s_2553_11: cast zx s_2553_10 -> bv
        let s_2553_11: Bits = Bits::new(s_2553_10 as u128, 4u16);
        // D s_2553_12: cmp-eq s_2553_9 s_2553_11
        let s_2553_12: bool = ((s_2553_9) == (s_2553_11));
        // N s_2553_13: branch s_2553_12 b2556 b2554
        if s_2553_12 {
            return block_2556(state, tracer, fn_state);
        } else {
            return block_2554(state, tracer, fn_state);
        };
    }
    fn block_2554<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2554_0: const #0u : u8
        let s_2554_0: bool = false;
        // D s_2554_1: write-var gs#405891 <= s_2554_0
        fn_state.gs_405891 = s_2554_0;
        // N s_2554_2: jump b2555
        return block_2555(state, tracer, fn_state);
    }
    fn block_2555<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2555_0: read-var gs#405891:u8
        let s_2555_0: bool = fn_state.gs_405891;
        // D s_2555_1: write-var gs#405892 <= s_2555_0
        fn_state.gs_405892 = s_2555_0;
        // N s_2555_2: jump b787
        return block_787(state, tracer, fn_state);
    }
    fn block_2556<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2556_0: const #7s : i
        let s_2556_0: i128 = 7;
        // D s_2556_1: read-var u#32763:u32
        let s_2556_1: u32 = fn_state.u_32763;
        // D s_2556_2: cast zx s_2556_1 -> bv
        let s_2556_2: Bits = Bits::new(s_2556_1 as u128, 32u16);
        // C s_2556_3: const #1s : i64
        let s_2556_3: i64 = 1;
        // C s_2556_4: cast zx s_2556_3 -> i
        let s_2556_4: i128 = (i128::try_from(s_2556_3).unwrap());
        // C s_2556_5: const #0s : i
        let s_2556_5: i128 = 0;
        // C s_2556_6: add s_2556_5 s_2556_4
        let s_2556_6: i128 = (s_2556_5 + s_2556_4);
        // D s_2556_7: bit-extract s_2556_2 s_2556_0 s_2556_6
        let s_2556_7: Bits = (Bits::new(
            ((s_2556_2) >> (s_2556_0)).value(),
            u16::try_from(s_2556_6).unwrap(),
        ));
        // D s_2556_8: cast reint s_2556_7 -> u8
        let s_2556_8: bool = ((s_2556_7.value()) != 0);
        // D s_2556_9: cast zx s_2556_8 -> bv
        let s_2556_9: Bits = Bits::new(s_2556_8 as u128, 1u16);
        // C s_2556_10: const #0u : u8
        let s_2556_10: bool = false;
        // C s_2556_11: cast zx s_2556_10 -> bv
        let s_2556_11: Bits = Bits::new(s_2556_10 as u128, 1u16);
        // D s_2556_12: cmp-eq s_2556_9 s_2556_11
        let s_2556_12: bool = ((s_2556_9) == (s_2556_11));
        // N s_2556_13: branch s_2556_12 b2559 b2557
        if s_2556_12 {
            return block_2559(state, tracer, fn_state);
        } else {
            return block_2557(state, tracer, fn_state);
        };
    }
    fn block_2557<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2557_0: const #0u : u8
        let s_2557_0: bool = false;
        // D s_2557_1: write-var gs#405890 <= s_2557_0
        fn_state.gs_405890 = s_2557_0;
        // N s_2557_2: jump b2558
        return block_2558(state, tracer, fn_state);
    }
    fn block_2558<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2558_0: read-var gs#405890:u8
        let s_2558_0: bool = fn_state.gs_405890;
        // D s_2558_1: write-var gs#405891 <= s_2558_0
        fn_state.gs_405891 = s_2558_0;
        // N s_2558_2: jump b2555
        return block_2555(state, tracer, fn_state);
    }
    fn block_2559<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2559_0: const #4s : i
        let s_2559_0: i128 = 4;
        // D s_2559_1: read-var u#32763:u32
        let s_2559_1: u32 = fn_state.u_32763;
        // D s_2559_2: cast zx s_2559_1 -> bv
        let s_2559_2: Bits = Bits::new(s_2559_1 as u128, 32u16);
        // C s_2559_3: const #1s : i64
        let s_2559_3: i64 = 1;
        // C s_2559_4: cast zx s_2559_3 -> i
        let s_2559_4: i128 = (i128::try_from(s_2559_3).unwrap());
        // C s_2559_5: const #0s : i
        let s_2559_5: i128 = 0;
        // C s_2559_6: add s_2559_5 s_2559_4
        let s_2559_6: i128 = (s_2559_5 + s_2559_4);
        // D s_2559_7: bit-extract s_2559_2 s_2559_0 s_2559_6
        let s_2559_7: Bits = (Bits::new(
            ((s_2559_2) >> (s_2559_0)).value(),
            u16::try_from(s_2559_6).unwrap(),
        ));
        // D s_2559_8: cast reint s_2559_7 -> u8
        let s_2559_8: bool = ((s_2559_7.value()) != 0);
        // D s_2559_9: cast zx s_2559_8 -> bv
        let s_2559_9: Bits = Bits::new(s_2559_8 as u128, 1u16);
        // C s_2559_10: const #1u : u8
        let s_2559_10: bool = true;
        // C s_2559_11: cast zx s_2559_10 -> bv
        let s_2559_11: Bits = Bits::new(s_2559_10 as u128, 1u16);
        // D s_2559_12: cmp-eq s_2559_9 s_2559_11
        let s_2559_12: bool = ((s_2559_9) == (s_2559_11));
        // D s_2559_13: write-var gs#405890 <= s_2559_12
        fn_state.gs_405890 = s_2559_12;
        // N s_2559_14: jump b2558
        return block_2558(state, tracer, fn_state);
    }
    fn block_2560<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2560_0: const #28s : i
        let s_2560_0: i128 = 28;
        // C s_2560_1: const #4s : i
        let s_2560_1: i128 = 4;
        // D s_2560_2: read-var u#32755:u32
        let s_2560_2: u32 = fn_state.u_32755;
        // D s_2560_3: cast zx s_2560_2 -> bv
        let s_2560_3: Bits = Bits::new(s_2560_2 as u128, 32u16);
        // D s_2560_4: bit-extract s_2560_3 s_2560_0 s_2560_1
        let s_2560_4: Bits = (Bits::new(
            ((s_2560_3) >> (s_2560_0)).value(),
            u16::try_from(s_2560_1).unwrap(),
        ));
        // D s_2560_5: cast reint s_2560_4 -> u8
        let s_2560_5: u8 = (s_2560_4.value() as u8);
        // D s_2560_6: cast zx s_2560_5 -> bv
        let s_2560_6: Bits = Bits::new(s_2560_5 as u128, 4u16);
        // C s_2560_7: const #15u : u8
        let s_2560_7: u8 = 15;
        // C s_2560_8: cast zx s_2560_7 -> bv
        let s_2560_8: Bits = Bits::new(s_2560_7 as u128, 4u16);
        // D s_2560_9: cmp-ne s_2560_6 s_2560_8
        let s_2560_9: bool = ((s_2560_6) != (s_2560_8));
        // N s_2560_10: branch s_2560_9 b2563 b2561
        if s_2560_9 {
            return block_2563(state, tracer, fn_state);
        } else {
            return block_2561(state, tracer, fn_state);
        };
    }
    fn block_2561<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2561_0: const #0u : u8
        let s_2561_0: bool = false;
        // D s_2561_1: write-var gs#405854 <= s_2561_0
        fn_state.gs_405854 = s_2561_0;
        // N s_2561_2: jump b2562
        return block_2562(state, tracer, fn_state);
    }
    fn block_2562<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2562_0: read-var gs#405854:u8
        let s_2562_0: bool = fn_state.gs_405854;
        // D s_2562_1: write-var gs#405855 <= s_2562_0
        fn_state.gs_405855 = s_2562_0;
        // N s_2562_2: jump b772
        return block_772(state, tracer, fn_state);
    }
    fn block_2563<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2563_0: const #3032s : i
        let s_2563_0: i128 = 3032;
        // C s_2563_1: const #14696u : u32
        let s_2563_1: u32 = 14696;
        // D s_2563_2: read-reg s_2563_1:i
        let s_2563_2: i128 = {
            let value = state.read_register::<i128>(s_2563_1 as isize);
            tracer.read_register(s_2563_1 as isize, value);
            value
        };
        // D s_2563_3: cmp-lt s_2563_2 s_2563_0
        let s_2563_3: bool = ((s_2563_2) < (s_2563_0));
        // D s_2563_4: write-var gs#405854 <= s_2563_3
        fn_state.gs_405854 = s_2563_3;
        // N s_2563_5: jump b2562
        return block_2562(state, tracer, fn_state);
    }
    fn block_2564<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2564_0: const #16s : i
        let s_2564_0: i128 = 16;
        // D s_2564_1: read-var u#32755:u32
        let s_2564_1: u32 = fn_state.u_32755;
        // D s_2564_2: cast zx s_2564_1 -> bv
        let s_2564_2: Bits = Bits::new(s_2564_1 as u128, 32u16);
        // C s_2564_3: const #1s : i64
        let s_2564_3: i64 = 1;
        // C s_2564_4: cast zx s_2564_3 -> i
        let s_2564_4: i128 = (i128::try_from(s_2564_3).unwrap());
        // C s_2564_5: const #3s : i
        let s_2564_5: i128 = 3;
        // C s_2564_6: add s_2564_5 s_2564_4
        let s_2564_6: i128 = (s_2564_5 + s_2564_4);
        // D s_2564_7: bit-extract s_2564_2 s_2564_0 s_2564_6
        let s_2564_7: Bits = (Bits::new(
            ((s_2564_2) >> (s_2564_0)).value(),
            u16::try_from(s_2564_6).unwrap(),
        ));
        // D s_2564_8: cast reint s_2564_7 -> u8
        let s_2564_8: u8 = (s_2564_7.value() as u8);
        // D s_2564_9: cast zx s_2564_8 -> bv
        let s_2564_9: Bits = Bits::new(s_2564_8 as u128, 4u16);
        // C s_2564_10: const #0u : u8
        let s_2564_10: u8 = 0;
        // C s_2564_11: cast zx s_2564_10 -> bv
        let s_2564_11: Bits = Bits::new(s_2564_10 as u128, 4u16);
        // D s_2564_12: cmp-eq s_2564_9 s_2564_11
        let s_2564_12: bool = ((s_2564_9) == (s_2564_11));
        // N s_2564_13: branch s_2564_12 b2567 b2565
        if s_2564_12 {
            return block_2567(state, tracer, fn_state);
        } else {
            return block_2565(state, tracer, fn_state);
        };
    }
    fn block_2565<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2565_0: const #0u : u8
        let s_2565_0: bool = false;
        // D s_2565_1: write-var gs#405849 <= s_2565_0
        fn_state.gs_405849 = s_2565_0;
        // N s_2565_2: jump b2566
        return block_2566(state, tracer, fn_state);
    }
    fn block_2566<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2566_0: read-var gs#405849:u8
        let s_2566_0: bool = fn_state.gs_405849;
        // D s_2566_1: write-var gs#405850 <= s_2566_0
        fn_state.gs_405850 = s_2566_0;
        // N s_2566_2: jump b770
        return block_770(state, tracer, fn_state);
    }
    fn block_2567<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2567_0: const #4s : i
        let s_2567_0: i128 = 4;
        // D s_2567_1: read-var u#32755:u32
        let s_2567_1: u32 = fn_state.u_32755;
        // D s_2567_2: cast zx s_2567_1 -> bv
        let s_2567_2: Bits = Bits::new(s_2567_1 as u128, 32u16);
        // C s_2567_3: const #1s : i64
        let s_2567_3: i64 = 1;
        // C s_2567_4: cast zx s_2567_3 -> i
        let s_2567_4: i128 = (i128::try_from(s_2567_3).unwrap());
        // C s_2567_5: const #0s : i
        let s_2567_5: i128 = 0;
        // C s_2567_6: add s_2567_5 s_2567_4
        let s_2567_6: i128 = (s_2567_5 + s_2567_4);
        // D s_2567_7: bit-extract s_2567_2 s_2567_0 s_2567_6
        let s_2567_7: Bits = (Bits::new(
            ((s_2567_2) >> (s_2567_0)).value(),
            u16::try_from(s_2567_6).unwrap(),
        ));
        // D s_2567_8: cast reint s_2567_7 -> u8
        let s_2567_8: bool = ((s_2567_7.value()) != 0);
        // D s_2567_9: cast zx s_2567_8 -> bv
        let s_2567_9: Bits = Bits::new(s_2567_8 as u128, 1u16);
        // C s_2567_10: const #0u : u8
        let s_2567_10: bool = false;
        // C s_2567_11: cast zx s_2567_10 -> bv
        let s_2567_11: Bits = Bits::new(s_2567_10 as u128, 1u16);
        // D s_2567_12: cmp-eq s_2567_9 s_2567_11
        let s_2567_12: bool = ((s_2567_9) == (s_2567_11));
        // D s_2567_13: write-var gs#405849 <= s_2567_12
        fn_state.gs_405849 = s_2567_12;
        // N s_2567_14: jump b2566
        return block_2566(state, tracer, fn_state);
    }
    fn block_2568<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2568_0: const #28s : i
        let s_2568_0: i128 = 28;
        // C s_2568_1: const #4s : i
        let s_2568_1: i128 = 4;
        // D s_2568_2: read-var u#32749:u32
        let s_2568_2: u32 = fn_state.u_32749;
        // D s_2568_3: cast zx s_2568_2 -> bv
        let s_2568_3: Bits = Bits::new(s_2568_2 as u128, 32u16);
        // D s_2568_4: bit-extract s_2568_3 s_2568_0 s_2568_1
        let s_2568_4: Bits = (Bits::new(
            ((s_2568_3) >> (s_2568_0)).value(),
            u16::try_from(s_2568_1).unwrap(),
        ));
        // D s_2568_5: cast reint s_2568_4 -> u8
        let s_2568_5: u8 = (s_2568_4.value() as u8);
        // D s_2568_6: cast zx s_2568_5 -> bv
        let s_2568_6: Bits = Bits::new(s_2568_5 as u128, 4u16);
        // C s_2568_7: const #15u : u8
        let s_2568_7: u8 = 15;
        // C s_2568_8: cast zx s_2568_7 -> bv
        let s_2568_8: Bits = Bits::new(s_2568_7 as u128, 4u16);
        // D s_2568_9: cmp-ne s_2568_6 s_2568_8
        let s_2568_9: bool = ((s_2568_6) != (s_2568_8));
        // N s_2568_10: branch s_2568_9 b2571 b2569
        if s_2568_9 {
            return block_2571(state, tracer, fn_state);
        } else {
            return block_2569(state, tracer, fn_state);
        };
    }
    fn block_2569<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2569_0: const #0u : u8
        let s_2569_0: bool = false;
        // D s_2569_1: write-var gs#405819 <= s_2569_0
        fn_state.gs_405819 = s_2569_0;
        // N s_2569_2: jump b2570
        return block_2570(state, tracer, fn_state);
    }
    fn block_2570<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2570_0: read-var gs#405819:u8
        let s_2570_0: bool = fn_state.gs_405819;
        // D s_2570_1: write-var gs#405820 <= s_2570_0
        fn_state.gs_405820 = s_2570_0;
        // N s_2570_2: jump b755
        return block_755(state, tracer, fn_state);
    }
    fn block_2571<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2571_0: const #3030s : i
        let s_2571_0: i128 = 3030;
        // C s_2571_1: const #14696u : u32
        let s_2571_1: u32 = 14696;
        // D s_2571_2: read-reg s_2571_1:i
        let s_2571_2: i128 = {
            let value = state.read_register::<i128>(s_2571_1 as isize);
            tracer.read_register(s_2571_1 as isize, value);
            value
        };
        // D s_2571_3: cmp-lt s_2571_2 s_2571_0
        let s_2571_3: bool = ((s_2571_2) < (s_2571_0));
        // D s_2571_4: write-var gs#405819 <= s_2571_3
        fn_state.gs_405819 = s_2571_3;
        // N s_2571_5: jump b2570
        return block_2570(state, tracer, fn_state);
    }
    fn block_2572<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2572_0: const #16s : i
        let s_2572_0: i128 = 16;
        // D s_2572_1: read-var u#32749:u32
        let s_2572_1: u32 = fn_state.u_32749;
        // D s_2572_2: cast zx s_2572_1 -> bv
        let s_2572_2: Bits = Bits::new(s_2572_1 as u128, 32u16);
        // C s_2572_3: const #1s : i64
        let s_2572_3: i64 = 1;
        // C s_2572_4: cast zx s_2572_3 -> i
        let s_2572_4: i128 = (i128::try_from(s_2572_3).unwrap());
        // C s_2572_5: const #3s : i
        let s_2572_5: i128 = 3;
        // C s_2572_6: add s_2572_5 s_2572_4
        let s_2572_6: i128 = (s_2572_5 + s_2572_4);
        // D s_2572_7: bit-extract s_2572_2 s_2572_0 s_2572_6
        let s_2572_7: Bits = (Bits::new(
            ((s_2572_2) >> (s_2572_0)).value(),
            u16::try_from(s_2572_6).unwrap(),
        ));
        // D s_2572_8: cast reint s_2572_7 -> u8
        let s_2572_8: u8 = (s_2572_7.value() as u8);
        // D s_2572_9: cast zx s_2572_8 -> bv
        let s_2572_9: Bits = Bits::new(s_2572_8 as u128, 4u16);
        // C s_2572_10: const #0u : u8
        let s_2572_10: u8 = 0;
        // C s_2572_11: cast zx s_2572_10 -> bv
        let s_2572_11: Bits = Bits::new(s_2572_10 as u128, 4u16);
        // D s_2572_12: cmp-eq s_2572_9 s_2572_11
        let s_2572_12: bool = ((s_2572_9) == (s_2572_11));
        // D s_2572_13: write-var gs#405815 <= s_2572_12
        fn_state.gs_405815 = s_2572_12;
        // N s_2572_14: jump b753
        return block_753(state, tracer, fn_state);
    }
    fn block_2573<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2573_0: const #28s : i
        let s_2573_0: i128 = 28;
        // C s_2573_1: const #4s : i
        let s_2573_1: i128 = 4;
        // D s_2573_2: read-var u#32742:u32
        let s_2573_2: u32 = fn_state.u_32742;
        // D s_2573_3: cast zx s_2573_2 -> bv
        let s_2573_3: Bits = Bits::new(s_2573_2 as u128, 32u16);
        // D s_2573_4: bit-extract s_2573_3 s_2573_0 s_2573_1
        let s_2573_4: Bits = (Bits::new(
            ((s_2573_3) >> (s_2573_0)).value(),
            u16::try_from(s_2573_1).unwrap(),
        ));
        // D s_2573_5: cast reint s_2573_4 -> u8
        let s_2573_5: u8 = (s_2573_4.value() as u8);
        // D s_2573_6: cast zx s_2573_5 -> bv
        let s_2573_6: Bits = Bits::new(s_2573_5 as u128, 4u16);
        // C s_2573_7: const #15u : u8
        let s_2573_7: u8 = 15;
        // C s_2573_8: cast zx s_2573_7 -> bv
        let s_2573_8: Bits = Bits::new(s_2573_7 as u128, 4u16);
        // D s_2573_9: cmp-ne s_2573_6 s_2573_8
        let s_2573_9: bool = ((s_2573_6) != (s_2573_8));
        // N s_2573_10: branch s_2573_9 b2576 b2574
        if s_2573_9 {
            return block_2576(state, tracer, fn_state);
        } else {
            return block_2574(state, tracer, fn_state);
        };
    }
    fn block_2574<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2574_0: const #0u : u8
        let s_2574_0: bool = false;
        // D s_2574_1: write-var gs#405785 <= s_2574_0
        fn_state.gs_405785 = s_2574_0;
        // N s_2574_2: jump b2575
        return block_2575(state, tracer, fn_state);
    }
    fn block_2575<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2575_0: read-var gs#405785:u8
        let s_2575_0: bool = fn_state.gs_405785;
        // D s_2575_1: write-var gs#405786 <= s_2575_0
        fn_state.gs_405786 = s_2575_0;
        // N s_2575_2: jump b738
        return block_738(state, tracer, fn_state);
    }
    fn block_2576<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2576_0: const #3027s : i
        let s_2576_0: i128 = 3027;
        // C s_2576_1: const #14696u : u32
        let s_2576_1: u32 = 14696;
        // D s_2576_2: read-reg s_2576_1:i
        let s_2576_2: i128 = {
            let value = state.read_register::<i128>(s_2576_1 as isize);
            tracer.read_register(s_2576_1 as isize, value);
            value
        };
        // D s_2576_3: cmp-lt s_2576_2 s_2576_0
        let s_2576_3: bool = ((s_2576_2) < (s_2576_0));
        // D s_2576_4: write-var gs#405785 <= s_2576_3
        fn_state.gs_405785 = s_2576_3;
        // N s_2576_5: jump b2575
        return block_2575(state, tracer, fn_state);
    }
    fn block_2577<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2577_0: const #12s : i
        let s_2577_0: i128 = 12;
        // D s_2577_1: read-var u#32742:u32
        let s_2577_1: u32 = fn_state.u_32742;
        // D s_2577_2: cast zx s_2577_1 -> bv
        let s_2577_2: Bits = Bits::new(s_2577_1 as u128, 32u16);
        // C s_2577_3: const #1s : i64
        let s_2577_3: i64 = 1;
        // C s_2577_4: cast zx s_2577_3 -> i
        let s_2577_4: i128 = (i128::try_from(s_2577_3).unwrap());
        // C s_2577_5: const #3s : i
        let s_2577_5: i128 = 3;
        // C s_2577_6: add s_2577_5 s_2577_4
        let s_2577_6: i128 = (s_2577_5 + s_2577_4);
        // D s_2577_7: bit-extract s_2577_2 s_2577_0 s_2577_6
        let s_2577_7: Bits = (Bits::new(
            ((s_2577_2) >> (s_2577_0)).value(),
            u16::try_from(s_2577_6).unwrap(),
        ));
        // D s_2577_8: cast reint s_2577_7 -> u8
        let s_2577_8: u8 = (s_2577_7.value() as u8);
        // D s_2577_9: cast zx s_2577_8 -> bv
        let s_2577_9: Bits = Bits::new(s_2577_8 as u128, 4u16);
        // C s_2577_10: const #0u : u8
        let s_2577_10: u8 = 0;
        // C s_2577_11: cast zx s_2577_10 -> bv
        let s_2577_11: Bits = Bits::new(s_2577_10 as u128, 4u16);
        // D s_2577_12: cmp-eq s_2577_9 s_2577_11
        let s_2577_12: bool = ((s_2577_9) == (s_2577_11));
        // N s_2577_13: branch s_2577_12 b2580 b2578
        if s_2577_12 {
            return block_2580(state, tracer, fn_state);
        } else {
            return block_2578(state, tracer, fn_state);
        };
    }
    fn block_2578<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2578_0: const #0u : u8
        let s_2578_0: bool = false;
        // D s_2578_1: write-var gs#405780 <= s_2578_0
        fn_state.gs_405780 = s_2578_0;
        // N s_2578_2: jump b2579
        return block_2579(state, tracer, fn_state);
    }
    fn block_2579<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2579_0: read-var gs#405780:u8
        let s_2579_0: bool = fn_state.gs_405780;
        // D s_2579_1: write-var gs#405781 <= s_2579_0
        fn_state.gs_405781 = s_2579_0;
        // N s_2579_2: jump b736
        return block_736(state, tracer, fn_state);
    }
    fn block_2580<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2580_0: const #4s : i
        let s_2580_0: i128 = 4;
        // D s_2580_1: read-var u#32742:u32
        let s_2580_1: u32 = fn_state.u_32742;
        // D s_2580_2: cast zx s_2580_1 -> bv
        let s_2580_2: Bits = Bits::new(s_2580_1 as u128, 32u16);
        // C s_2580_3: const #1s : i64
        let s_2580_3: i64 = 1;
        // C s_2580_4: cast zx s_2580_3 -> i
        let s_2580_4: i128 = (i128::try_from(s_2580_3).unwrap());
        // C s_2580_5: const #3s : i
        let s_2580_5: i128 = 3;
        // C s_2580_6: add s_2580_5 s_2580_4
        let s_2580_6: i128 = (s_2580_5 + s_2580_4);
        // D s_2580_7: bit-extract s_2580_2 s_2580_0 s_2580_6
        let s_2580_7: Bits = (Bits::new(
            ((s_2580_2) >> (s_2580_0)).value(),
            u16::try_from(s_2580_6).unwrap(),
        ));
        // D s_2580_8: cast reint s_2580_7 -> u8
        let s_2580_8: u8 = (s_2580_7.value() as u8);
        // D s_2580_9: cast zx s_2580_8 -> bv
        let s_2580_9: Bits = Bits::new(s_2580_8 as u128, 4u16);
        // C s_2580_10: const #9u : u8
        let s_2580_10: u8 = 9;
        // C s_2580_11: cast zx s_2580_10 -> bv
        let s_2580_11: Bits = Bits::new(s_2580_10 as u128, 4u16);
        // D s_2580_12: cmp-eq s_2580_9 s_2580_11
        let s_2580_12: bool = ((s_2580_9) == (s_2580_11));
        // D s_2580_13: write-var gs#405780 <= s_2580_12
        fn_state.gs_405780 = s_2580_12;
        // N s_2580_14: jump b2579
        return block_2579(state, tracer, fn_state);
    }
    fn block_2581<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2581_0: const #28s : i
        let s_2581_0: i128 = 28;
        // C s_2581_1: const #4s : i
        let s_2581_1: i128 = 4;
        // D s_2581_2: read-var u#32736:u32
        let s_2581_2: u32 = fn_state.u_32736;
        // D s_2581_3: cast zx s_2581_2 -> bv
        let s_2581_3: Bits = Bits::new(s_2581_2 as u128, 32u16);
        // D s_2581_4: bit-extract s_2581_3 s_2581_0 s_2581_1
        let s_2581_4: Bits = (Bits::new(
            ((s_2581_3) >> (s_2581_0)).value(),
            u16::try_from(s_2581_1).unwrap(),
        ));
        // D s_2581_5: cast reint s_2581_4 -> u8
        let s_2581_5: u8 = (s_2581_4.value() as u8);
        // D s_2581_6: cast zx s_2581_5 -> bv
        let s_2581_6: Bits = Bits::new(s_2581_5 as u128, 4u16);
        // C s_2581_7: const #15u : u8
        let s_2581_7: u8 = 15;
        // C s_2581_8: cast zx s_2581_7 -> bv
        let s_2581_8: Bits = Bits::new(s_2581_7 as u128, 4u16);
        // D s_2581_9: cmp-ne s_2581_6 s_2581_8
        let s_2581_9: bool = ((s_2581_6) != (s_2581_8));
        // N s_2581_10: branch s_2581_9 b2584 b2582
        if s_2581_9 {
            return block_2584(state, tracer, fn_state);
        } else {
            return block_2582(state, tracer, fn_state);
        };
    }
    fn block_2582<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2582_0: const #0u : u8
        let s_2582_0: bool = false;
        // D s_2582_1: write-var gs#405761 <= s_2582_0
        fn_state.gs_405761 = s_2582_0;
        // N s_2582_2: jump b2583
        return block_2583(state, tracer, fn_state);
    }
    fn block_2583<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2583_0: read-var gs#405761:u8
        let s_2583_0: bool = fn_state.gs_405761;
        // D s_2583_1: write-var gs#405762 <= s_2583_0
        fn_state.gs_405762 = s_2583_0;
        // N s_2583_2: jump b732
        return block_732(state, tracer, fn_state);
    }
    fn block_2584<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2584_0: const #3021s : i
        let s_2584_0: i128 = 3021;
        // C s_2584_1: const #14696u : u32
        let s_2584_1: u32 = 14696;
        // D s_2584_2: read-reg s_2584_1:i
        let s_2584_2: i128 = {
            let value = state.read_register::<i128>(s_2584_1 as isize);
            tracer.read_register(s_2584_1 as isize, value);
            value
        };
        // D s_2584_3: cmp-lt s_2584_2 s_2584_0
        let s_2584_3: bool = ((s_2584_2) < (s_2584_0));
        // D s_2584_4: write-var gs#405761 <= s_2584_3
        fn_state.gs_405761 = s_2584_3;
        // N s_2584_5: jump b2583
        return block_2583(state, tracer, fn_state);
    }
    fn block_2585<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2585_0: const #28s : i
        let s_2585_0: i128 = 28;
        // C s_2585_1: const #4s : i
        let s_2585_1: i128 = 4;
        // D s_2585_2: read-var u#32728:u32
        let s_2585_2: u32 = fn_state.u_32728;
        // D s_2585_3: cast zx s_2585_2 -> bv
        let s_2585_3: Bits = Bits::new(s_2585_2 as u128, 32u16);
        // D s_2585_4: bit-extract s_2585_3 s_2585_0 s_2585_1
        let s_2585_4: Bits = (Bits::new(
            ((s_2585_3) >> (s_2585_0)).value(),
            u16::try_from(s_2585_1).unwrap(),
        ));
        // D s_2585_5: cast reint s_2585_4 -> u8
        let s_2585_5: u8 = (s_2585_4.value() as u8);
        // D s_2585_6: cast zx s_2585_5 -> bv
        let s_2585_6: Bits = Bits::new(s_2585_5 as u128, 4u16);
        // C s_2585_7: const #15u : u8
        let s_2585_7: u8 = 15;
        // C s_2585_8: cast zx s_2585_7 -> bv
        let s_2585_8: Bits = Bits::new(s_2585_7 as u128, 4u16);
        // D s_2585_9: cmp-ne s_2585_6 s_2585_8
        let s_2585_9: bool = ((s_2585_6) != (s_2585_8));
        // N s_2585_10: branch s_2585_9 b2588 b2586
        if s_2585_9 {
            return block_2588(state, tracer, fn_state);
        } else {
            return block_2586(state, tracer, fn_state);
        };
    }
    fn block_2586<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2586_0: const #0u : u8
        let s_2586_0: bool = false;
        // D s_2586_1: write-var gs#405728 <= s_2586_0
        fn_state.gs_405728 = s_2586_0;
        // N s_2586_2: jump b2587
        return block_2587(state, tracer, fn_state);
    }
    fn block_2587<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2587_0: read-var gs#405728:u8
        let s_2587_0: bool = fn_state.gs_405728;
        // D s_2587_1: write-var gs#405729 <= s_2587_0
        fn_state.gs_405729 = s_2587_0;
        // N s_2587_2: jump b717
        return block_717(state, tracer, fn_state);
    }
    fn block_2588<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2588_0: const #3018s : i
        let s_2588_0: i128 = 3018;
        // C s_2588_1: const #14696u : u32
        let s_2588_1: u32 = 14696;
        // D s_2588_2: read-reg s_2588_1:i
        let s_2588_2: i128 = {
            let value = state.read_register::<i128>(s_2588_1 as isize);
            tracer.read_register(s_2588_1 as isize, value);
            value
        };
        // D s_2588_3: cmp-lt s_2588_2 s_2588_0
        let s_2588_3: bool = ((s_2588_2) < (s_2588_0));
        // D s_2588_4: write-var gs#405728 <= s_2588_3
        fn_state.gs_405728 = s_2588_3;
        // N s_2588_5: jump b2587
        return block_2587(state, tracer, fn_state);
    }
    fn block_2589<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2589_0: const #16s : i
        let s_2589_0: i128 = 16;
        // D s_2589_1: read-var u#32728:u32
        let s_2589_1: u32 = fn_state.u_32728;
        // D s_2589_2: cast zx s_2589_1 -> bv
        let s_2589_2: Bits = Bits::new(s_2589_1 as u128, 32u16);
        // C s_2589_3: const #1s : i64
        let s_2589_3: i64 = 1;
        // C s_2589_4: cast zx s_2589_3 -> i
        let s_2589_4: i128 = (i128::try_from(s_2589_3).unwrap());
        // C s_2589_5: const #3s : i
        let s_2589_5: i128 = 3;
        // C s_2589_6: add s_2589_5 s_2589_4
        let s_2589_6: i128 = (s_2589_5 + s_2589_4);
        // D s_2589_7: bit-extract s_2589_2 s_2589_0 s_2589_6
        let s_2589_7: Bits = (Bits::new(
            ((s_2589_2) >> (s_2589_0)).value(),
            u16::try_from(s_2589_6).unwrap(),
        ));
        // D s_2589_8: cast reint s_2589_7 -> u8
        let s_2589_8: u8 = (s_2589_7.value() as u8);
        // D s_2589_9: cast zx s_2589_8 -> bv
        let s_2589_9: Bits = Bits::new(s_2589_8 as u128, 4u16);
        // C s_2589_10: const #0u : u8
        let s_2589_10: u8 = 0;
        // C s_2589_11: cast zx s_2589_10 -> bv
        let s_2589_11: Bits = Bits::new(s_2589_10 as u128, 4u16);
        // D s_2589_12: cmp-eq s_2589_9 s_2589_11
        let s_2589_12: bool = ((s_2589_9) == (s_2589_11));
        // N s_2589_13: branch s_2589_12 b2592 b2590
        if s_2589_12 {
            return block_2592(state, tracer, fn_state);
        } else {
            return block_2590(state, tracer, fn_state);
        };
    }
    fn block_2590<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2590_0: const #0u : u8
        let s_2590_0: bool = false;
        // D s_2590_1: write-var gs#405723 <= s_2590_0
        fn_state.gs_405723 = s_2590_0;
        // N s_2590_2: jump b2591
        return block_2591(state, tracer, fn_state);
    }
    fn block_2591<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2591_0: read-var gs#405723:u8
        let s_2591_0: bool = fn_state.gs_405723;
        // D s_2591_1: write-var gs#405724 <= s_2591_0
        fn_state.gs_405724 = s_2591_0;
        // N s_2591_2: jump b715
        return block_715(state, tracer, fn_state);
    }
    fn block_2592<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2592_0: const #7s : i
        let s_2592_0: i128 = 7;
        // D s_2592_1: read-var u#32728:u32
        let s_2592_1: u32 = fn_state.u_32728;
        // D s_2592_2: cast zx s_2592_1 -> bv
        let s_2592_2: Bits = Bits::new(s_2592_1 as u128, 32u16);
        // C s_2592_3: const #1s : i64
        let s_2592_3: i64 = 1;
        // C s_2592_4: cast zx s_2592_3 -> i
        let s_2592_4: i128 = (i128::try_from(s_2592_3).unwrap());
        // C s_2592_5: const #0s : i
        let s_2592_5: i128 = 0;
        // C s_2592_6: add s_2592_5 s_2592_4
        let s_2592_6: i128 = (s_2592_5 + s_2592_4);
        // D s_2592_7: bit-extract s_2592_2 s_2592_0 s_2592_6
        let s_2592_7: Bits = (Bits::new(
            ((s_2592_2) >> (s_2592_0)).value(),
            u16::try_from(s_2592_6).unwrap(),
        ));
        // D s_2592_8: cast reint s_2592_7 -> u8
        let s_2592_8: bool = ((s_2592_7.value()) != 0);
        // D s_2592_9: cast zx s_2592_8 -> bv
        let s_2592_9: Bits = Bits::new(s_2592_8 as u128, 1u16);
        // C s_2592_10: const #0u : u8
        let s_2592_10: bool = false;
        // C s_2592_11: cast zx s_2592_10 -> bv
        let s_2592_11: Bits = Bits::new(s_2592_10 as u128, 1u16);
        // D s_2592_12: cmp-eq s_2592_9 s_2592_11
        let s_2592_12: bool = ((s_2592_9) == (s_2592_11));
        // N s_2592_13: branch s_2592_12 b2595 b2593
        if s_2592_12 {
            return block_2595(state, tracer, fn_state);
        } else {
            return block_2593(state, tracer, fn_state);
        };
    }
    fn block_2593<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2593_0: const #0u : u8
        let s_2593_0: bool = false;
        // D s_2593_1: write-var gs#405722 <= s_2593_0
        fn_state.gs_405722 = s_2593_0;
        // N s_2593_2: jump b2594
        return block_2594(state, tracer, fn_state);
    }
    fn block_2594<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2594_0: read-var gs#405722:u8
        let s_2594_0: bool = fn_state.gs_405722;
        // D s_2594_1: write-var gs#405723 <= s_2594_0
        fn_state.gs_405723 = s_2594_0;
        // N s_2594_2: jump b2591
        return block_2591(state, tracer, fn_state);
    }
    fn block_2595<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2595_0: const #4s : i
        let s_2595_0: i128 = 4;
        // D s_2595_1: read-var u#32728:u32
        let s_2595_1: u32 = fn_state.u_32728;
        // D s_2595_2: cast zx s_2595_1 -> bv
        let s_2595_2: Bits = Bits::new(s_2595_1 as u128, 32u16);
        // C s_2595_3: const #1s : i64
        let s_2595_3: i64 = 1;
        // C s_2595_4: cast zx s_2595_3 -> i
        let s_2595_4: i128 = (i128::try_from(s_2595_3).unwrap());
        // C s_2595_5: const #0s : i
        let s_2595_5: i128 = 0;
        // C s_2595_6: add s_2595_5 s_2595_4
        let s_2595_6: i128 = (s_2595_5 + s_2595_4);
        // D s_2595_7: bit-extract s_2595_2 s_2595_0 s_2595_6
        let s_2595_7: Bits = (Bits::new(
            ((s_2595_2) >> (s_2595_0)).value(),
            u16::try_from(s_2595_6).unwrap(),
        ));
        // D s_2595_8: cast reint s_2595_7 -> u8
        let s_2595_8: bool = ((s_2595_7.value()) != 0);
        // D s_2595_9: cast zx s_2595_8 -> bv
        let s_2595_9: Bits = Bits::new(s_2595_8 as u128, 1u16);
        // C s_2595_10: const #1u : u8
        let s_2595_10: bool = true;
        // C s_2595_11: cast zx s_2595_10 -> bv
        let s_2595_11: Bits = Bits::new(s_2595_10 as u128, 1u16);
        // D s_2595_12: cmp-eq s_2595_9 s_2595_11
        let s_2595_12: bool = ((s_2595_9) == (s_2595_11));
        // D s_2595_13: write-var gs#405722 <= s_2595_12
        fn_state.gs_405722 = s_2595_12;
        // N s_2595_14: jump b2594
        return block_2594(state, tracer, fn_state);
    }
    fn block_2596<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2596_0: const #28s : i
        let s_2596_0: i128 = 28;
        // C s_2596_1: const #4s : i
        let s_2596_1: i128 = 4;
        // D s_2596_2: read-var u#32720:u32
        let s_2596_2: u32 = fn_state.u_32720;
        // D s_2596_3: cast zx s_2596_2 -> bv
        let s_2596_3: Bits = Bits::new(s_2596_2 as u128, 32u16);
        // D s_2596_4: bit-extract s_2596_3 s_2596_0 s_2596_1
        let s_2596_4: Bits = (Bits::new(
            ((s_2596_3) >> (s_2596_0)).value(),
            u16::try_from(s_2596_1).unwrap(),
        ));
        // D s_2596_5: cast reint s_2596_4 -> u8
        let s_2596_5: u8 = (s_2596_4.value() as u8);
        // D s_2596_6: cast zx s_2596_5 -> bv
        let s_2596_6: Bits = Bits::new(s_2596_5 as u128, 4u16);
        // C s_2596_7: const #15u : u8
        let s_2596_7: u8 = 15;
        // C s_2596_8: cast zx s_2596_7 -> bv
        let s_2596_8: Bits = Bits::new(s_2596_7 as u128, 4u16);
        // D s_2596_9: cmp-ne s_2596_6 s_2596_8
        let s_2596_9: bool = ((s_2596_6) != (s_2596_8));
        // N s_2596_10: branch s_2596_9 b2599 b2597
        if s_2596_9 {
            return block_2599(state, tracer, fn_state);
        } else {
            return block_2597(state, tracer, fn_state);
        };
    }
    fn block_2597<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2597_0: const #0u : u8
        let s_2597_0: bool = false;
        // D s_2597_1: write-var gs#405686 <= s_2597_0
        fn_state.gs_405686 = s_2597_0;
        // N s_2597_2: jump b2598
        return block_2598(state, tracer, fn_state);
    }
    fn block_2598<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2598_0: read-var gs#405686:u8
        let s_2598_0: bool = fn_state.gs_405686;
        // D s_2598_1: write-var gs#405687 <= s_2598_0
        fn_state.gs_405687 = s_2598_0;
        // N s_2598_2: jump b700
        return block_700(state, tracer, fn_state);
    }
    fn block_2599<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2599_0: const #3014s : i
        let s_2599_0: i128 = 3014;
        // C s_2599_1: const #14696u : u32
        let s_2599_1: u32 = 14696;
        // D s_2599_2: read-reg s_2599_1:i
        let s_2599_2: i128 = {
            let value = state.read_register::<i128>(s_2599_1 as isize);
            tracer.read_register(s_2599_1 as isize, value);
            value
        };
        // D s_2599_3: cmp-lt s_2599_2 s_2599_0
        let s_2599_3: bool = ((s_2599_2) < (s_2599_0));
        // D s_2599_4: write-var gs#405686 <= s_2599_3
        fn_state.gs_405686 = s_2599_3;
        // N s_2599_5: jump b2598
        return block_2598(state, tracer, fn_state);
    }
    fn block_2600<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2600_0: const #16s : i
        let s_2600_0: i128 = 16;
        // D s_2600_1: read-var u#32720:u32
        let s_2600_1: u32 = fn_state.u_32720;
        // D s_2600_2: cast zx s_2600_1 -> bv
        let s_2600_2: Bits = Bits::new(s_2600_1 as u128, 32u16);
        // C s_2600_3: const #1s : i64
        let s_2600_3: i64 = 1;
        // C s_2600_4: cast zx s_2600_3 -> i
        let s_2600_4: i128 = (i128::try_from(s_2600_3).unwrap());
        // C s_2600_5: const #3s : i
        let s_2600_5: i128 = 3;
        // C s_2600_6: add s_2600_5 s_2600_4
        let s_2600_6: i128 = (s_2600_5 + s_2600_4);
        // D s_2600_7: bit-extract s_2600_2 s_2600_0 s_2600_6
        let s_2600_7: Bits = (Bits::new(
            ((s_2600_2) >> (s_2600_0)).value(),
            u16::try_from(s_2600_6).unwrap(),
        ));
        // D s_2600_8: cast reint s_2600_7 -> u8
        let s_2600_8: u8 = (s_2600_7.value() as u8);
        // D s_2600_9: cast zx s_2600_8 -> bv
        let s_2600_9: Bits = Bits::new(s_2600_8 as u128, 4u16);
        // C s_2600_10: const #0u : u8
        let s_2600_10: u8 = 0;
        // C s_2600_11: cast zx s_2600_10 -> bv
        let s_2600_11: Bits = Bits::new(s_2600_10 as u128, 4u16);
        // D s_2600_12: cmp-eq s_2600_9 s_2600_11
        let s_2600_12: bool = ((s_2600_9) == (s_2600_11));
        // N s_2600_13: branch s_2600_12 b2603 b2601
        if s_2600_12 {
            return block_2603(state, tracer, fn_state);
        } else {
            return block_2601(state, tracer, fn_state);
        };
    }
    fn block_2601<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2601_0: const #0u : u8
        let s_2601_0: bool = false;
        // D s_2601_1: write-var gs#405681 <= s_2601_0
        fn_state.gs_405681 = s_2601_0;
        // N s_2601_2: jump b2602
        return block_2602(state, tracer, fn_state);
    }
    fn block_2602<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2602_0: read-var gs#405681:u8
        let s_2602_0: bool = fn_state.gs_405681;
        // D s_2602_1: write-var gs#405682 <= s_2602_0
        fn_state.gs_405682 = s_2602_0;
        // N s_2602_2: jump b698
        return block_698(state, tracer, fn_state);
    }
    fn block_2603<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2603_0: const #4s : i
        let s_2603_0: i128 = 4;
        // D s_2603_1: read-var u#32720:u32
        let s_2603_1: u32 = fn_state.u_32720;
        // D s_2603_2: cast zx s_2603_1 -> bv
        let s_2603_2: Bits = Bits::new(s_2603_1 as u128, 32u16);
        // C s_2603_3: const #1s : i64
        let s_2603_3: i64 = 1;
        // C s_2603_4: cast zx s_2603_3 -> i
        let s_2603_4: i128 = (i128::try_from(s_2603_3).unwrap());
        // C s_2603_5: const #0s : i
        let s_2603_5: i128 = 0;
        // C s_2603_6: add s_2603_5 s_2603_4
        let s_2603_6: i128 = (s_2603_5 + s_2603_4);
        // D s_2603_7: bit-extract s_2603_2 s_2603_0 s_2603_6
        let s_2603_7: Bits = (Bits::new(
            ((s_2603_2) >> (s_2603_0)).value(),
            u16::try_from(s_2603_6).unwrap(),
        ));
        // D s_2603_8: cast reint s_2603_7 -> u8
        let s_2603_8: bool = ((s_2603_7.value()) != 0);
        // D s_2603_9: cast zx s_2603_8 -> bv
        let s_2603_9: Bits = Bits::new(s_2603_8 as u128, 1u16);
        // C s_2603_10: const #0u : u8
        let s_2603_10: bool = false;
        // C s_2603_11: cast zx s_2603_10 -> bv
        let s_2603_11: Bits = Bits::new(s_2603_10 as u128, 1u16);
        // D s_2603_12: cmp-eq s_2603_9 s_2603_11
        let s_2603_12: bool = ((s_2603_9) == (s_2603_11));
        // D s_2603_13: write-var gs#405681 <= s_2603_12
        fn_state.gs_405681 = s_2603_12;
        // N s_2603_14: jump b2602
        return block_2602(state, tracer, fn_state);
    }
    fn block_2604<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2604_0: const #28s : i
        let s_2604_0: i128 = 28;
        // C s_2604_1: const #4s : i
        let s_2604_1: i128 = 4;
        // D s_2604_2: read-var u#32714:u32
        let s_2604_2: u32 = fn_state.u_32714;
        // D s_2604_3: cast zx s_2604_2 -> bv
        let s_2604_3: Bits = Bits::new(s_2604_2 as u128, 32u16);
        // D s_2604_4: bit-extract s_2604_3 s_2604_0 s_2604_1
        let s_2604_4: Bits = (Bits::new(
            ((s_2604_3) >> (s_2604_0)).value(),
            u16::try_from(s_2604_1).unwrap(),
        ));
        // D s_2604_5: cast reint s_2604_4 -> u8
        let s_2604_5: u8 = (s_2604_4.value() as u8);
        // D s_2604_6: cast zx s_2604_5 -> bv
        let s_2604_6: Bits = Bits::new(s_2604_5 as u128, 4u16);
        // C s_2604_7: const #15u : u8
        let s_2604_7: u8 = 15;
        // C s_2604_8: cast zx s_2604_7 -> bv
        let s_2604_8: Bits = Bits::new(s_2604_7 as u128, 4u16);
        // D s_2604_9: cmp-ne s_2604_6 s_2604_8
        let s_2604_9: bool = ((s_2604_6) != (s_2604_8));
        // N s_2604_10: branch s_2604_9 b2607 b2605
        if s_2604_9 {
            return block_2607(state, tracer, fn_state);
        } else {
            return block_2605(state, tracer, fn_state);
        };
    }
    fn block_2605<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2605_0: const #0u : u8
        let s_2605_0: bool = false;
        // D s_2605_1: write-var gs#405662 <= s_2605_0
        fn_state.gs_405662 = s_2605_0;
        // N s_2605_2: jump b2606
        return block_2606(state, tracer, fn_state);
    }
    fn block_2606<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2606_0: read-var gs#405662:u8
        let s_2606_0: bool = fn_state.gs_405662;
        // D s_2606_1: write-var gs#405663 <= s_2606_0
        fn_state.gs_405663 = s_2606_0;
        // N s_2606_2: jump b694
        return block_694(state, tracer, fn_state);
    }
    fn block_2607<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2607_0: const #3010s : i
        let s_2607_0: i128 = 3010;
        // C s_2607_1: const #14696u : u32
        let s_2607_1: u32 = 14696;
        // D s_2607_2: read-reg s_2607_1:i
        let s_2607_2: i128 = {
            let value = state.read_register::<i128>(s_2607_1 as isize);
            tracer.read_register(s_2607_1 as isize, value);
            value
        };
        // D s_2607_3: cmp-lt s_2607_2 s_2607_0
        let s_2607_3: bool = ((s_2607_2) < (s_2607_0));
        // D s_2607_4: write-var gs#405662 <= s_2607_3
        fn_state.gs_405662 = s_2607_3;
        // N s_2607_5: jump b2606
        return block_2606(state, tracer, fn_state);
    }
    fn block_2608<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2608_0: const #28s : i
        let s_2608_0: i128 = 28;
        // C s_2608_1: const #4s : i
        let s_2608_1: i128 = 4;
        // D s_2608_2: read-var u#32708:u32
        let s_2608_2: u32 = fn_state.u_32708;
        // D s_2608_3: cast zx s_2608_2 -> bv
        let s_2608_3: Bits = Bits::new(s_2608_2 as u128, 32u16);
        // D s_2608_4: bit-extract s_2608_3 s_2608_0 s_2608_1
        let s_2608_4: Bits = (Bits::new(
            ((s_2608_3) >> (s_2608_0)).value(),
            u16::try_from(s_2608_1).unwrap(),
        ));
        // D s_2608_5: cast reint s_2608_4 -> u8
        let s_2608_5: u8 = (s_2608_4.value() as u8);
        // D s_2608_6: cast zx s_2608_5 -> bv
        let s_2608_6: Bits = Bits::new(s_2608_5 as u128, 4u16);
        // C s_2608_7: const #15u : u8
        let s_2608_7: u8 = 15;
        // C s_2608_8: cast zx s_2608_7 -> bv
        let s_2608_8: Bits = Bits::new(s_2608_7 as u128, 4u16);
        // D s_2608_9: cmp-ne s_2608_6 s_2608_8
        let s_2608_9: bool = ((s_2608_6) != (s_2608_8));
        // N s_2608_10: branch s_2608_9 b2611 b2609
        if s_2608_9 {
            return block_2611(state, tracer, fn_state);
        } else {
            return block_2609(state, tracer, fn_state);
        };
    }
    fn block_2609<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2609_0: const #0u : u8
        let s_2609_0: bool = false;
        // D s_2609_1: write-var gs#405633 <= s_2609_0
        fn_state.gs_405633 = s_2609_0;
        // N s_2609_2: jump b2610
        return block_2610(state, tracer, fn_state);
    }
    fn block_2610<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2610_0: read-var gs#405633:u8
        let s_2610_0: bool = fn_state.gs_405633;
        // D s_2610_1: write-var gs#405634 <= s_2610_0
        fn_state.gs_405634 = s_2610_0;
        // N s_2610_2: jump b679
        return block_679(state, tracer, fn_state);
    }
    fn block_2611<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2611_0: const #3009s : i
        let s_2611_0: i128 = 3009;
        // C s_2611_1: const #14696u : u32
        let s_2611_1: u32 = 14696;
        // D s_2611_2: read-reg s_2611_1:i
        let s_2611_2: i128 = {
            let value = state.read_register::<i128>(s_2611_1 as isize);
            tracer.read_register(s_2611_1 as isize, value);
            value
        };
        // D s_2611_3: cmp-lt s_2611_2 s_2611_0
        let s_2611_3: bool = ((s_2611_2) < (s_2611_0));
        // D s_2611_4: write-var gs#405633 <= s_2611_3
        fn_state.gs_405633 = s_2611_3;
        // N s_2611_5: jump b2610
        return block_2610(state, tracer, fn_state);
    }
    fn block_2612<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2612_0: const #16s : i
        let s_2612_0: i128 = 16;
        // D s_2612_1: read-var u#32708:u32
        let s_2612_1: u32 = fn_state.u_32708;
        // D s_2612_2: cast zx s_2612_1 -> bv
        let s_2612_2: Bits = Bits::new(s_2612_1 as u128, 32u16);
        // C s_2612_3: const #1s : i64
        let s_2612_3: i64 = 1;
        // C s_2612_4: cast zx s_2612_3 -> i
        let s_2612_4: i128 = (i128::try_from(s_2612_3).unwrap());
        // C s_2612_5: const #3s : i
        let s_2612_5: i128 = 3;
        // C s_2612_6: add s_2612_5 s_2612_4
        let s_2612_6: i128 = (s_2612_5 + s_2612_4);
        // D s_2612_7: bit-extract s_2612_2 s_2612_0 s_2612_6
        let s_2612_7: Bits = (Bits::new(
            ((s_2612_2) >> (s_2612_0)).value(),
            u16::try_from(s_2612_6).unwrap(),
        ));
        // D s_2612_8: cast reint s_2612_7 -> u8
        let s_2612_8: u8 = (s_2612_7.value() as u8);
        // D s_2612_9: cast zx s_2612_8 -> bv
        let s_2612_9: Bits = Bits::new(s_2612_8 as u128, 4u16);
        // C s_2612_10: const #0u : u8
        let s_2612_10: u8 = 0;
        // C s_2612_11: cast zx s_2612_10 -> bv
        let s_2612_11: Bits = Bits::new(s_2612_10 as u128, 4u16);
        // D s_2612_12: cmp-eq s_2612_9 s_2612_11
        let s_2612_12: bool = ((s_2612_9) == (s_2612_11));
        // D s_2612_13: write-var gs#405629 <= s_2612_12
        fn_state.gs_405629 = s_2612_12;
        // N s_2612_14: jump b677
        return block_677(state, tracer, fn_state);
    }
    fn block_2613<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2613_0: const #28s : i
        let s_2613_0: i128 = 28;
        // C s_2613_1: const #4s : i
        let s_2613_1: i128 = 4;
        // D s_2613_2: read-var u#32701:u32
        let s_2613_2: u32 = fn_state.u_32701;
        // D s_2613_3: cast zx s_2613_2 -> bv
        let s_2613_3: Bits = Bits::new(s_2613_2 as u128, 32u16);
        // D s_2613_4: bit-extract s_2613_3 s_2613_0 s_2613_1
        let s_2613_4: Bits = (Bits::new(
            ((s_2613_3) >> (s_2613_0)).value(),
            u16::try_from(s_2613_1).unwrap(),
        ));
        // D s_2613_5: cast reint s_2613_4 -> u8
        let s_2613_5: u8 = (s_2613_4.value() as u8);
        // D s_2613_6: cast zx s_2613_5 -> bv
        let s_2613_6: Bits = Bits::new(s_2613_5 as u128, 4u16);
        // C s_2613_7: const #15u : u8
        let s_2613_7: u8 = 15;
        // C s_2613_8: cast zx s_2613_7 -> bv
        let s_2613_8: Bits = Bits::new(s_2613_7 as u128, 4u16);
        // D s_2613_9: cmp-ne s_2613_6 s_2613_8
        let s_2613_9: bool = ((s_2613_6) != (s_2613_8));
        // N s_2613_10: branch s_2613_9 b2616 b2614
        if s_2613_9 {
            return block_2616(state, tracer, fn_state);
        } else {
            return block_2614(state, tracer, fn_state);
        };
    }
    fn block_2614<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2614_0: const #0u : u8
        let s_2614_0: bool = false;
        // D s_2614_1: write-var gs#405610 <= s_2614_0
        fn_state.gs_405610 = s_2614_0;
        // N s_2614_2: jump b2615
        return block_2615(state, tracer, fn_state);
    }
    fn block_2615<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2615_0: read-var gs#405610:u8
        let s_2615_0: bool = fn_state.gs_405610;
        // D s_2615_1: write-var gs#405611 <= s_2615_0
        fn_state.gs_405611 = s_2615_0;
        // N s_2615_2: jump b673
        return block_673(state, tracer, fn_state);
    }
    fn block_2616<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2616_0: const #3007s : i
        let s_2616_0: i128 = 3007;
        // C s_2616_1: const #14696u : u32
        let s_2616_1: u32 = 14696;
        // D s_2616_2: read-reg s_2616_1:i
        let s_2616_2: i128 = {
            let value = state.read_register::<i128>(s_2616_1 as isize);
            tracer.read_register(s_2616_1 as isize, value);
            value
        };
        // D s_2616_3: cmp-lt s_2616_2 s_2616_0
        let s_2616_3: bool = ((s_2616_2) < (s_2616_0));
        // D s_2616_4: write-var gs#405610 <= s_2616_3
        fn_state.gs_405610 = s_2616_3;
        // N s_2616_5: jump b2615
        return block_2615(state, tracer, fn_state);
    }
    fn block_2617<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2617_0: const #4s : i
        let s_2617_0: i128 = 4;
        // D s_2617_1: read-var u#32701:u32
        let s_2617_1: u32 = fn_state.u_32701;
        // D s_2617_2: cast zx s_2617_1 -> bv
        let s_2617_2: Bits = Bits::new(s_2617_1 as u128, 32u16);
        // C s_2617_3: const #1s : i64
        let s_2617_3: i64 = 1;
        // C s_2617_4: cast zx s_2617_3 -> i
        let s_2617_4: i128 = (i128::try_from(s_2617_3).unwrap());
        // C s_2617_5: const #3s : i
        let s_2617_5: i128 = 3;
        // C s_2617_6: add s_2617_5 s_2617_4
        let s_2617_6: i128 = (s_2617_5 + s_2617_4);
        // D s_2617_7: bit-extract s_2617_2 s_2617_0 s_2617_6
        let s_2617_7: Bits = (Bits::new(
            ((s_2617_2) >> (s_2617_0)).value(),
            u16::try_from(s_2617_6).unwrap(),
        ));
        // D s_2617_8: cast reint s_2617_7 -> u8
        let s_2617_8: u8 = (s_2617_7.value() as u8);
        // D s_2617_9: cast zx s_2617_8 -> bv
        let s_2617_9: Bits = Bits::new(s_2617_8 as u128, 4u16);
        // C s_2617_10: const #9u : u8
        let s_2617_10: u8 = 9;
        // C s_2617_11: cast zx s_2617_10 -> bv
        let s_2617_11: Bits = Bits::new(s_2617_10 as u128, 4u16);
        // D s_2617_12: cmp-eq s_2617_9 s_2617_11
        let s_2617_12: bool = ((s_2617_9) == (s_2617_11));
        // D s_2617_13: write-var gs#405606 <= s_2617_12
        fn_state.gs_405606 = s_2617_12;
        // N s_2617_14: jump b671
        return block_671(state, tracer, fn_state);
    }
    fn block_2618<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2618_0: const #28s : i
        let s_2618_0: i128 = 28;
        // C s_2618_1: const #4s : i
        let s_2618_1: i128 = 4;
        // D s_2618_2: read-var u#32694:u32
        let s_2618_2: u32 = fn_state.u_32694;
        // D s_2618_3: cast zx s_2618_2 -> bv
        let s_2618_3: Bits = Bits::new(s_2618_2 as u128, 32u16);
        // D s_2618_4: bit-extract s_2618_3 s_2618_0 s_2618_1
        let s_2618_4: Bits = (Bits::new(
            ((s_2618_3) >> (s_2618_0)).value(),
            u16::try_from(s_2618_1).unwrap(),
        ));
        // D s_2618_5: cast reint s_2618_4 -> u8
        let s_2618_5: u8 = (s_2618_4.value() as u8);
        // D s_2618_6: cast zx s_2618_5 -> bv
        let s_2618_6: Bits = Bits::new(s_2618_5 as u128, 4u16);
        // C s_2618_7: const #15u : u8
        let s_2618_7: u8 = 15;
        // C s_2618_8: cast zx s_2618_7 -> bv
        let s_2618_8: Bits = Bits::new(s_2618_7 as u128, 4u16);
        // D s_2618_9: cmp-ne s_2618_6 s_2618_8
        let s_2618_9: bool = ((s_2618_6) != (s_2618_8));
        // N s_2618_10: branch s_2618_9 b2621 b2619
        if s_2618_9 {
            return block_2621(state, tracer, fn_state);
        } else {
            return block_2619(state, tracer, fn_state);
        };
    }
    fn block_2619<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2619_0: const #0u : u8
        let s_2619_0: bool = false;
        // D s_2619_1: write-var gs#405585 <= s_2619_0
        fn_state.gs_405585 = s_2619_0;
        // N s_2619_2: jump b2620
        return block_2620(state, tracer, fn_state);
    }
    fn block_2620<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2620_0: read-var gs#405585:u8
        let s_2620_0: bool = fn_state.gs_405585;
        // D s_2620_1: write-var gs#405586 <= s_2620_0
        fn_state.gs_405586 = s_2620_0;
        // N s_2620_2: jump b667
        return block_667(state, tracer, fn_state);
    }
    fn block_2621<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2621_0: const #3005s : i
        let s_2621_0: i128 = 3005;
        // C s_2621_1: const #14696u : u32
        let s_2621_1: u32 = 14696;
        // D s_2621_2: read-reg s_2621_1:i
        let s_2621_2: i128 = {
            let value = state.read_register::<i128>(s_2621_1 as isize);
            tracer.read_register(s_2621_1 as isize, value);
            value
        };
        // D s_2621_3: cmp-lt s_2621_2 s_2621_0
        let s_2621_3: bool = ((s_2621_2) < (s_2621_0));
        // D s_2621_4: write-var gs#405585 <= s_2621_3
        fn_state.gs_405585 = s_2621_3;
        // N s_2621_5: jump b2620
        return block_2620(state, tracer, fn_state);
    }
    fn block_2622<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2622_0: const #4s : i
        let s_2622_0: i128 = 4;
        // D s_2622_1: read-var u#32694:u32
        let s_2622_1: u32 = fn_state.u_32694;
        // D s_2622_2: cast zx s_2622_1 -> bv
        let s_2622_2: Bits = Bits::new(s_2622_1 as u128, 32u16);
        // C s_2622_3: const #1s : i64
        let s_2622_3: i64 = 1;
        // C s_2622_4: cast zx s_2622_3 -> i
        let s_2622_4: i128 = (i128::try_from(s_2622_3).unwrap());
        // C s_2622_5: const #3s : i
        let s_2622_5: i128 = 3;
        // C s_2622_6: add s_2622_5 s_2622_4
        let s_2622_6: i128 = (s_2622_5 + s_2622_4);
        // D s_2622_7: bit-extract s_2622_2 s_2622_0 s_2622_6
        let s_2622_7: Bits = (Bits::new(
            ((s_2622_2) >> (s_2622_0)).value(),
            u16::try_from(s_2622_6).unwrap(),
        ));
        // D s_2622_8: cast reint s_2622_7 -> u8
        let s_2622_8: u8 = (s_2622_7.value() as u8);
        // D s_2622_9: cast zx s_2622_8 -> bv
        let s_2622_9: Bits = Bits::new(s_2622_8 as u128, 4u16);
        // C s_2622_10: const #9u : u8
        let s_2622_10: u8 = 9;
        // C s_2622_11: cast zx s_2622_10 -> bv
        let s_2622_11: Bits = Bits::new(s_2622_10 as u128, 4u16);
        // D s_2622_12: cmp-eq s_2622_9 s_2622_11
        let s_2622_12: bool = ((s_2622_9) == (s_2622_11));
        // D s_2622_13: write-var gs#405581 <= s_2622_12
        fn_state.gs_405581 = s_2622_12;
        // N s_2622_14: jump b665
        return block_665(state, tracer, fn_state);
    }
    fn block_2623<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2623_0: const #28s : i
        let s_2623_0: i128 = 28;
        // C s_2623_1: const #4s : i
        let s_2623_1: i128 = 4;
        // D s_2623_2: read-var u#32687:u32
        let s_2623_2: u32 = fn_state.u_32687;
        // D s_2623_3: cast zx s_2623_2 -> bv
        let s_2623_3: Bits = Bits::new(s_2623_2 as u128, 32u16);
        // D s_2623_4: bit-extract s_2623_3 s_2623_0 s_2623_1
        let s_2623_4: Bits = (Bits::new(
            ((s_2623_3) >> (s_2623_0)).value(),
            u16::try_from(s_2623_1).unwrap(),
        ));
        // D s_2623_5: cast reint s_2623_4 -> u8
        let s_2623_5: u8 = (s_2623_4.value() as u8);
        // D s_2623_6: cast zx s_2623_5 -> bv
        let s_2623_6: Bits = Bits::new(s_2623_5 as u128, 4u16);
        // C s_2623_7: const #15u : u8
        let s_2623_7: u8 = 15;
        // C s_2623_8: cast zx s_2623_7 -> bv
        let s_2623_8: Bits = Bits::new(s_2623_7 as u128, 4u16);
        // D s_2623_9: cmp-ne s_2623_6 s_2623_8
        let s_2623_9: bool = ((s_2623_6) != (s_2623_8));
        // N s_2623_10: branch s_2623_9 b2626 b2624
        if s_2623_9 {
            return block_2626(state, tracer, fn_state);
        } else {
            return block_2624(state, tracer, fn_state);
        };
    }
    fn block_2624<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2624_0: const #0u : u8
        let s_2624_0: bool = false;
        // D s_2624_1: write-var gs#405551 <= s_2624_0
        fn_state.gs_405551 = s_2624_0;
        // N s_2624_2: jump b2625
        return block_2625(state, tracer, fn_state);
    }
    fn block_2625<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2625_0: read-var gs#405551:u8
        let s_2625_0: bool = fn_state.gs_405551;
        // D s_2625_1: write-var gs#405552 <= s_2625_0
        fn_state.gs_405552 = s_2625_0;
        // N s_2625_2: jump b650
        return block_650(state, tracer, fn_state);
    }
    fn block_2626<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2626_0: const #2991s : i
        let s_2626_0: i128 = 2991;
        // C s_2626_1: const #14696u : u32
        let s_2626_1: u32 = 14696;
        // D s_2626_2: read-reg s_2626_1:i
        let s_2626_2: i128 = {
            let value = state.read_register::<i128>(s_2626_1 as isize);
            tracer.read_register(s_2626_1 as isize, value);
            value
        };
        // D s_2626_3: cmp-lt s_2626_2 s_2626_0
        let s_2626_3: bool = ((s_2626_2) < (s_2626_0));
        // D s_2626_4: write-var gs#405551 <= s_2626_3
        fn_state.gs_405551 = s_2626_3;
        // N s_2626_5: jump b2625
        return block_2625(state, tracer, fn_state);
    }
    fn block_2627<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2627_0: const #20s : i
        let s_2627_0: i128 = 20;
        // D s_2627_1: read-var u#32687:u32
        let s_2627_1: u32 = fn_state.u_32687;
        // D s_2627_2: cast zx s_2627_1 -> bv
        let s_2627_2: Bits = Bits::new(s_2627_1 as u128, 32u16);
        // C s_2627_3: const #1s : i64
        let s_2627_3: i64 = 1;
        // C s_2627_4: cast zx s_2627_3 -> i
        let s_2627_4: i128 = (i128::try_from(s_2627_3).unwrap());
        // C s_2627_5: const #2s : i
        let s_2627_5: i128 = 2;
        // C s_2627_6: add s_2627_5 s_2627_4
        let s_2627_6: i128 = (s_2627_5 + s_2627_4);
        // D s_2627_7: bit-extract s_2627_2 s_2627_0 s_2627_6
        let s_2627_7: Bits = (Bits::new(
            ((s_2627_2) >> (s_2627_0)).value(),
            u16::try_from(s_2627_6).unwrap(),
        ));
        // D s_2627_8: cast reint s_2627_7 -> u8
        let s_2627_8: u8 = (s_2627_7.value() as u8);
        // D s_2627_9: cast zx s_2627_8 -> bv
        let s_2627_9: Bits = Bits::new(s_2627_8 as u128, 3u16);
        // C s_2627_10: const #3u : u8
        let s_2627_10: u8 = 3;
        // C s_2627_11: cast zx s_2627_10 -> bv
        let s_2627_11: Bits = Bits::new(s_2627_10 as u128, 3u16);
        // D s_2627_12: cmp-eq s_2627_9 s_2627_11
        let s_2627_12: bool = ((s_2627_9) == (s_2627_11));
        // N s_2627_13: branch s_2627_12 b2630 b2628
        if s_2627_12 {
            return block_2630(state, tracer, fn_state);
        } else {
            return block_2628(state, tracer, fn_state);
        };
    }
    fn block_2628<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2628_0: const #0u : u8
        let s_2628_0: bool = false;
        // D s_2628_1: write-var gs#405546 <= s_2628_0
        fn_state.gs_405546 = s_2628_0;
        // N s_2628_2: jump b2629
        return block_2629(state, tracer, fn_state);
    }
    fn block_2629<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2629_0: read-var gs#405546:u8
        let s_2629_0: bool = fn_state.gs_405546;
        // D s_2629_1: write-var gs#405547 <= s_2629_0
        fn_state.gs_405547 = s_2629_0;
        // N s_2629_2: jump b648
        return block_648(state, tracer, fn_state);
    }
    fn block_2630<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2630_0: const #4s : i
        let s_2630_0: i128 = 4;
        // D s_2630_1: read-var u#32687:u32
        let s_2630_1: u32 = fn_state.u_32687;
        // D s_2630_2: cast zx s_2630_1 -> bv
        let s_2630_2: Bits = Bits::new(s_2630_1 as u128, 32u16);
        // C s_2630_3: const #1s : i64
        let s_2630_3: i64 = 1;
        // C s_2630_4: cast zx s_2630_3 -> i
        let s_2630_4: i128 = (i128::try_from(s_2630_3).unwrap());
        // C s_2630_5: const #7s : i
        let s_2630_5: i128 = 7;
        // C s_2630_6: add s_2630_5 s_2630_4
        let s_2630_6: i128 = (s_2630_5 + s_2630_4);
        // D s_2630_7: bit-extract s_2630_2 s_2630_0 s_2630_6
        let s_2630_7: Bits = (Bits::new(
            ((s_2630_2) >> (s_2630_0)).value(),
            u16::try_from(s_2630_6).unwrap(),
        ));
        // D s_2630_8: cast reint s_2630_7 -> u8
        let s_2630_8: u8 = (s_2630_7.value() as u8);
        // D s_2630_9: cast zx s_2630_8 -> bv
        let s_2630_9: Bits = Bits::new(s_2630_8 as u128, 8u16);
        // C s_2630_10: const #15u : u8
        let s_2630_10: u8 = 15;
        // C s_2630_11: cast zx s_2630_10 -> bv
        let s_2630_11: Bits = Bits::new(s_2630_10 as u128, 8u16);
        // D s_2630_12: cmp-eq s_2630_9 s_2630_11
        let s_2630_12: bool = ((s_2630_9) == (s_2630_11));
        // D s_2630_13: write-var gs#405546 <= s_2630_12
        fn_state.gs_405546 = s_2630_12;
        // N s_2630_14: jump b2629
        return block_2629(state, tracer, fn_state);
    }
    fn block_2631<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2631_0: const #28s : i
        let s_2631_0: i128 = 28;
        // C s_2631_1: const #4s : i
        let s_2631_1: i128 = 4;
        // D s_2631_2: read-var u#32679:u32
        let s_2631_2: u32 = fn_state.u_32679;
        // D s_2631_3: cast zx s_2631_2 -> bv
        let s_2631_3: Bits = Bits::new(s_2631_2 as u128, 32u16);
        // D s_2631_4: bit-extract s_2631_3 s_2631_0 s_2631_1
        let s_2631_4: Bits = (Bits::new(
            ((s_2631_3) >> (s_2631_0)).value(),
            u16::try_from(s_2631_1).unwrap(),
        ));
        // D s_2631_5: cast reint s_2631_4 -> u8
        let s_2631_5: u8 = (s_2631_4.value() as u8);
        // D s_2631_6: cast zx s_2631_5 -> bv
        let s_2631_6: Bits = Bits::new(s_2631_5 as u128, 4u16);
        // C s_2631_7: const #15u : u8
        let s_2631_7: u8 = 15;
        // C s_2631_8: cast zx s_2631_7 -> bv
        let s_2631_8: Bits = Bits::new(s_2631_7 as u128, 4u16);
        // D s_2631_9: cmp-ne s_2631_6 s_2631_8
        let s_2631_9: bool = ((s_2631_6) != (s_2631_8));
        // N s_2631_10: branch s_2631_9 b2634 b2632
        if s_2631_9 {
            return block_2634(state, tracer, fn_state);
        } else {
            return block_2632(state, tracer, fn_state);
        };
    }
    fn block_2632<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2632_0: const #0u : u8
        let s_2632_0: bool = false;
        // D s_2632_1: write-var gs#405523 <= s_2632_0
        fn_state.gs_405523 = s_2632_0;
        // N s_2632_2: jump b2633
        return block_2633(state, tracer, fn_state);
    }
    fn block_2633<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2633_0: read-var gs#405523:u8
        let s_2633_0: bool = fn_state.gs_405523;
        // D s_2633_1: write-var gs#405524 <= s_2633_0
        fn_state.gs_405524 = s_2633_0;
        // N s_2633_2: jump b644
        return block_644(state, tracer, fn_state);
    }
    fn block_2634<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2634_0: const #2990s : i
        let s_2634_0: i128 = 2990;
        // C s_2634_1: const #14696u : u32
        let s_2634_1: u32 = 14696;
        // D s_2634_2: read-reg s_2634_1:i
        let s_2634_2: i128 = {
            let value = state.read_register::<i128>(s_2634_1 as isize);
            tracer.read_register(s_2634_1 as isize, value);
            value
        };
        // D s_2634_3: cmp-lt s_2634_2 s_2634_0
        let s_2634_3: bool = ((s_2634_2) < (s_2634_0));
        // D s_2634_4: write-var gs#405523 <= s_2634_3
        fn_state.gs_405523 = s_2634_3;
        // N s_2634_5: jump b2633
        return block_2633(state, tracer, fn_state);
    }
    fn block_2635<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2635_0: const #20s : i
        let s_2635_0: i128 = 20;
        // D s_2635_1: read-var u#32679:u32
        let s_2635_1: u32 = fn_state.u_32679;
        // D s_2635_2: cast zx s_2635_1 -> bv
        let s_2635_2: Bits = Bits::new(s_2635_1 as u128, 32u16);
        // C s_2635_3: const #1s : i64
        let s_2635_3: i64 = 1;
        // C s_2635_4: cast zx s_2635_3 -> i
        let s_2635_4: i128 = (i128::try_from(s_2635_3).unwrap());
        // C s_2635_5: const #2s : i
        let s_2635_5: i128 = 2;
        // C s_2635_6: add s_2635_5 s_2635_4
        let s_2635_6: i128 = (s_2635_5 + s_2635_4);
        // D s_2635_7: bit-extract s_2635_2 s_2635_0 s_2635_6
        let s_2635_7: Bits = (Bits::new(
            ((s_2635_2) >> (s_2635_0)).value(),
            u16::try_from(s_2635_6).unwrap(),
        ));
        // D s_2635_8: cast reint s_2635_7 -> u8
        let s_2635_8: u8 = (s_2635_7.value() as u8);
        // D s_2635_9: cast zx s_2635_8 -> bv
        let s_2635_9: Bits = Bits::new(s_2635_8 as u128, 3u16);
        // C s_2635_10: const #7u : u8
        let s_2635_10: u8 = 7;
        // C s_2635_11: cast zx s_2635_10 -> bv
        let s_2635_11: Bits = Bits::new(s_2635_10 as u128, 3u16);
        // D s_2635_12: cmp-eq s_2635_9 s_2635_11
        let s_2635_12: bool = ((s_2635_9) == (s_2635_11));
        // N s_2635_13: branch s_2635_12 b2638 b2636
        if s_2635_12 {
            return block_2638(state, tracer, fn_state);
        } else {
            return block_2636(state, tracer, fn_state);
        };
    }
    fn block_2636<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2636_0: const #0u : u8
        let s_2636_0: bool = false;
        // D s_2636_1: write-var gs#405518 <= s_2636_0
        fn_state.gs_405518 = s_2636_0;
        // N s_2636_2: jump b2637
        return block_2637(state, tracer, fn_state);
    }
    fn block_2637<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2637_0: read-var gs#405518:u8
        let s_2637_0: bool = fn_state.gs_405518;
        // D s_2637_1: write-var gs#405519 <= s_2637_0
        fn_state.gs_405519 = s_2637_0;
        // N s_2637_2: jump b642
        return block_642(state, tracer, fn_state);
    }
    fn block_2638<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2638_0: const #4s : i
        let s_2638_0: i128 = 4;
        // D s_2638_1: read-var u#32679:u32
        let s_2638_1: u32 = fn_state.u_32679;
        // D s_2638_2: cast zx s_2638_1 -> bv
        let s_2638_2: Bits = Bits::new(s_2638_1 as u128, 32u16);
        // C s_2638_3: const #1s : i64
        let s_2638_3: i64 = 1;
        // C s_2638_4: cast zx s_2638_3 -> i
        let s_2638_4: i128 = (i128::try_from(s_2638_3).unwrap());
        // C s_2638_5: const #3s : i
        let s_2638_5: i128 = 3;
        // C s_2638_6: add s_2638_5 s_2638_4
        let s_2638_6: i128 = (s_2638_5 + s_2638_4);
        // D s_2638_7: bit-extract s_2638_2 s_2638_0 s_2638_6
        let s_2638_7: Bits = (Bits::new(
            ((s_2638_2) >> (s_2638_0)).value(),
            u16::try_from(s_2638_6).unwrap(),
        ));
        // D s_2638_8: cast reint s_2638_7 -> u8
        let s_2638_8: u8 = (s_2638_7.value() as u8);
        // D s_2638_9: cast zx s_2638_8 -> bv
        let s_2638_9: Bits = Bits::new(s_2638_8 as u128, 4u16);
        // C s_2638_10: const #15u : u8
        let s_2638_10: u8 = 15;
        // C s_2638_11: cast zx s_2638_10 -> bv
        let s_2638_11: Bits = Bits::new(s_2638_10 as u128, 4u16);
        // D s_2638_12: cmp-eq s_2638_9 s_2638_11
        let s_2638_12: bool = ((s_2638_9) == (s_2638_11));
        // D s_2638_13: write-var gs#405518 <= s_2638_12
        fn_state.gs_405518 = s_2638_12;
        // N s_2638_14: jump b2637
        return block_2637(state, tracer, fn_state);
    }
    fn block_2639<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2639_0: const #28s : i
        let s_2639_0: i128 = 28;
        // C s_2639_1: const #4s : i
        let s_2639_1: i128 = 4;
        // D s_2639_2: read-var u#32670:u32
        let s_2639_2: u32 = fn_state.u_32670;
        // D s_2639_3: cast zx s_2639_2 -> bv
        let s_2639_3: Bits = Bits::new(s_2639_2 as u128, 32u16);
        // D s_2639_4: bit-extract s_2639_3 s_2639_0 s_2639_1
        let s_2639_4: Bits = (Bits::new(
            ((s_2639_3) >> (s_2639_0)).value(),
            u16::try_from(s_2639_1).unwrap(),
        ));
        // D s_2639_5: cast reint s_2639_4 -> u8
        let s_2639_5: u8 = (s_2639_4.value() as u8);
        // D s_2639_6: cast zx s_2639_5 -> bv
        let s_2639_6: Bits = Bits::new(s_2639_5 as u128, 4u16);
        // C s_2639_7: const #15u : u8
        let s_2639_7: u8 = 15;
        // C s_2639_8: cast zx s_2639_7 -> bv
        let s_2639_8: Bits = Bits::new(s_2639_7 as u128, 4u16);
        // D s_2639_9: cmp-ne s_2639_6 s_2639_8
        let s_2639_9: bool = ((s_2639_6) != (s_2639_8));
        // N s_2639_10: branch s_2639_9 b2642 b2640
        if s_2639_9 {
            return block_2642(state, tracer, fn_state);
        } else {
            return block_2640(state, tracer, fn_state);
        };
    }
    fn block_2640<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2640_0: const #0u : u8
        let s_2640_0: bool = false;
        // D s_2640_1: write-var gs#405482 <= s_2640_0
        fn_state.gs_405482 = s_2640_0;
        // N s_2640_2: jump b2641
        return block_2641(state, tracer, fn_state);
    }
    fn block_2641<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2641_0: read-var gs#405482:u8
        let s_2641_0: bool = fn_state.gs_405482;
        // D s_2641_1: write-var gs#405483 <= s_2641_0
        fn_state.gs_405483 = s_2641_0;
        // N s_2641_2: jump b627
        return block_627(state, tracer, fn_state);
    }
    fn block_2642<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2642_0: const #2987s : i
        let s_2642_0: i128 = 2987;
        // C s_2642_1: const #14696u : u32
        let s_2642_1: u32 = 14696;
        // D s_2642_2: read-reg s_2642_1:i
        let s_2642_2: i128 = {
            let value = state.read_register::<i128>(s_2642_1 as isize);
            tracer.read_register(s_2642_1 as isize, value);
            value
        };
        // D s_2642_3: cmp-lt s_2642_2 s_2642_0
        let s_2642_3: bool = ((s_2642_2) < (s_2642_0));
        // D s_2642_4: write-var gs#405482 <= s_2642_3
        fn_state.gs_405482 = s_2642_3;
        // N s_2642_5: jump b2641
        return block_2641(state, tracer, fn_state);
    }
    fn block_2643<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2643_0: const #22s : i
        let s_2643_0: i128 = 22;
        // D s_2643_1: read-var u#32670:u32
        let s_2643_1: u32 = fn_state.u_32670;
        // D s_2643_2: cast zx s_2643_1 -> bv
        let s_2643_2: Bits = Bits::new(s_2643_1 as u128, 32u16);
        // C s_2643_3: const #1s : i64
        let s_2643_3: i64 = 1;
        // C s_2643_4: cast zx s_2643_3 -> i
        let s_2643_4: i128 = (i128::try_from(s_2643_3).unwrap());
        // C s_2643_5: const #0s : i
        let s_2643_5: i128 = 0;
        // C s_2643_6: add s_2643_5 s_2643_4
        let s_2643_6: i128 = (s_2643_5 + s_2643_4);
        // D s_2643_7: bit-extract s_2643_2 s_2643_0 s_2643_6
        let s_2643_7: Bits = (Bits::new(
            ((s_2643_2) >> (s_2643_0)).value(),
            u16::try_from(s_2643_6).unwrap(),
        ));
        // D s_2643_8: cast reint s_2643_7 -> u8
        let s_2643_8: bool = ((s_2643_7.value()) != 0);
        // D s_2643_9: cast zx s_2643_8 -> bv
        let s_2643_9: Bits = Bits::new(s_2643_8 as u128, 1u16);
        // C s_2643_10: const #0u : u8
        let s_2643_10: bool = false;
        // C s_2643_11: cast zx s_2643_10 -> bv
        let s_2643_11: Bits = Bits::new(s_2643_10 as u128, 1u16);
        // D s_2643_12: cmp-eq s_2643_9 s_2643_11
        let s_2643_12: bool = ((s_2643_9) == (s_2643_11));
        // N s_2643_13: branch s_2643_12 b2646 b2644
        if s_2643_12 {
            return block_2646(state, tracer, fn_state);
        } else {
            return block_2644(state, tracer, fn_state);
        };
    }
    fn block_2644<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2644_0: const #0u : u8
        let s_2644_0: bool = false;
        // D s_2644_1: write-var gs#405477 <= s_2644_0
        fn_state.gs_405477 = s_2644_0;
        // N s_2644_2: jump b2645
        return block_2645(state, tracer, fn_state);
    }
    fn block_2645<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2645_0: read-var gs#405477:u8
        let s_2645_0: bool = fn_state.gs_405477;
        // D s_2645_1: write-var gs#405478 <= s_2645_0
        fn_state.gs_405478 = s_2645_0;
        // N s_2645_2: jump b625
        return block_625(state, tracer, fn_state);
    }
    fn block_2646<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2646_0: const #20s : i
        let s_2646_0: i128 = 20;
        // D s_2646_1: read-var u#32670:u32
        let s_2646_1: u32 = fn_state.u_32670;
        // D s_2646_2: cast zx s_2646_1 -> bv
        let s_2646_2: Bits = Bits::new(s_2646_1 as u128, 32u16);
        // C s_2646_3: const #1s : i64
        let s_2646_3: i64 = 1;
        // C s_2646_4: cast zx s_2646_3 -> i
        let s_2646_4: i128 = (i128::try_from(s_2646_3).unwrap());
        // C s_2646_5: const #0s : i
        let s_2646_5: i128 = 0;
        // C s_2646_6: add s_2646_5 s_2646_4
        let s_2646_6: i128 = (s_2646_5 + s_2646_4);
        // D s_2646_7: bit-extract s_2646_2 s_2646_0 s_2646_6
        let s_2646_7: Bits = (Bits::new(
            ((s_2646_2) >> (s_2646_0)).value(),
            u16::try_from(s_2646_6).unwrap(),
        ));
        // D s_2646_8: cast reint s_2646_7 -> u8
        let s_2646_8: bool = ((s_2646_7.value()) != 0);
        // D s_2646_9: cast zx s_2646_8 -> bv
        let s_2646_9: Bits = Bits::new(s_2646_8 as u128, 1u16);
        // C s_2646_10: const #1u : u8
        let s_2646_10: bool = true;
        // C s_2646_11: cast zx s_2646_10 -> bv
        let s_2646_11: Bits = Bits::new(s_2646_10 as u128, 1u16);
        // D s_2646_12: cmp-eq s_2646_9 s_2646_11
        let s_2646_12: bool = ((s_2646_9) == (s_2646_11));
        // N s_2646_13: branch s_2646_12 b2649 b2647
        if s_2646_12 {
            return block_2649(state, tracer, fn_state);
        } else {
            return block_2647(state, tracer, fn_state);
        };
    }
    fn block_2647<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2647_0: const #0u : u8
        let s_2647_0: bool = false;
        // D s_2647_1: write-var gs#405476 <= s_2647_0
        fn_state.gs_405476 = s_2647_0;
        // N s_2647_2: jump b2648
        return block_2648(state, tracer, fn_state);
    }
    fn block_2648<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2648_0: read-var gs#405476:u8
        let s_2648_0: bool = fn_state.gs_405476;
        // D s_2648_1: write-var gs#405477 <= s_2648_0
        fn_state.gs_405477 = s_2648_0;
        // N s_2648_2: jump b2645
        return block_2645(state, tracer, fn_state);
    }
    fn block_2649<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2649_0: const #4s : i
        let s_2649_0: i128 = 4;
        // D s_2649_1: read-var u#32670:u32
        let s_2649_1: u32 = fn_state.u_32670;
        // D s_2649_2: cast zx s_2649_1 -> bv
        let s_2649_2: Bits = Bits::new(s_2649_1 as u128, 32u16);
        // C s_2649_3: const #1s : i64
        let s_2649_3: i64 = 1;
        // C s_2649_4: cast zx s_2649_3 -> i
        let s_2649_4: i128 = (i128::try_from(s_2649_3).unwrap());
        // C s_2649_5: const #7s : i
        let s_2649_5: i128 = 7;
        // C s_2649_6: add s_2649_5 s_2649_4
        let s_2649_6: i128 = (s_2649_5 + s_2649_4);
        // D s_2649_7: bit-extract s_2649_2 s_2649_0 s_2649_6
        let s_2649_7: Bits = (Bits::new(
            ((s_2649_2) >> (s_2649_0)).value(),
            u16::try_from(s_2649_6).unwrap(),
        ));
        // D s_2649_8: cast reint s_2649_7 -> u8
        let s_2649_8: u8 = (s_2649_7.value() as u8);
        // D s_2649_9: cast zx s_2649_8 -> bv
        let s_2649_9: Bits = Bits::new(s_2649_8 as u128, 8u16);
        // C s_2649_10: const #15u : u8
        let s_2649_10: u8 = 15;
        // C s_2649_11: cast zx s_2649_10 -> bv
        let s_2649_11: Bits = Bits::new(s_2649_10 as u128, 8u16);
        // D s_2649_12: cmp-eq s_2649_9 s_2649_11
        let s_2649_12: bool = ((s_2649_9) == (s_2649_11));
        // D s_2649_13: write-var gs#405476 <= s_2649_12
        fn_state.gs_405476 = s_2649_12;
        // N s_2649_14: jump b2648
        return block_2648(state, tracer, fn_state);
    }
    fn block_2650<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2650_0: const #28s : i
        let s_2650_0: i128 = 28;
        // C s_2650_1: const #4s : i
        let s_2650_1: i128 = 4;
        // D s_2650_2: read-var u#32661:u32
        let s_2650_2: u32 = fn_state.u_32661;
        // D s_2650_3: cast zx s_2650_2 -> bv
        let s_2650_3: Bits = Bits::new(s_2650_2 as u128, 32u16);
        // D s_2650_4: bit-extract s_2650_3 s_2650_0 s_2650_1
        let s_2650_4: Bits = (Bits::new(
            ((s_2650_3) >> (s_2650_0)).value(),
            u16::try_from(s_2650_1).unwrap(),
        ));
        // D s_2650_5: cast reint s_2650_4 -> u8
        let s_2650_5: u8 = (s_2650_4.value() as u8);
        // D s_2650_6: cast zx s_2650_5 -> bv
        let s_2650_6: Bits = Bits::new(s_2650_5 as u128, 4u16);
        // C s_2650_7: const #15u : u8
        let s_2650_7: u8 = 15;
        // C s_2650_8: cast zx s_2650_7 -> bv
        let s_2650_8: Bits = Bits::new(s_2650_7 as u128, 4u16);
        // D s_2650_9: cmp-ne s_2650_6 s_2650_8
        let s_2650_9: bool = ((s_2650_6) != (s_2650_8));
        // N s_2650_10: branch s_2650_9 b2653 b2651
        if s_2650_9 {
            return block_2653(state, tracer, fn_state);
        } else {
            return block_2651(state, tracer, fn_state);
        };
    }
    fn block_2651<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2651_0: const #0u : u8
        let s_2651_0: bool = false;
        // D s_2651_1: write-var gs#405449 <= s_2651_0
        fn_state.gs_405449 = s_2651_0;
        // N s_2651_2: jump b2652
        return block_2652(state, tracer, fn_state);
    }
    fn block_2652<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2652_0: read-var gs#405449:u8
        let s_2652_0: bool = fn_state.gs_405449;
        // D s_2652_1: write-var gs#405450 <= s_2652_0
        fn_state.gs_405450 = s_2652_0;
        // N s_2652_2: jump b621
        return block_621(state, tracer, fn_state);
    }
    fn block_2653<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2653_0: const #2985s : i
        let s_2653_0: i128 = 2985;
        // C s_2653_1: const #14696u : u32
        let s_2653_1: u32 = 14696;
        // D s_2653_2: read-reg s_2653_1:i
        let s_2653_2: i128 = {
            let value = state.read_register::<i128>(s_2653_1 as isize);
            tracer.read_register(s_2653_1 as isize, value);
            value
        };
        // D s_2653_3: cmp-lt s_2653_2 s_2653_0
        let s_2653_3: bool = ((s_2653_2) < (s_2653_0));
        // D s_2653_4: write-var gs#405449 <= s_2653_3
        fn_state.gs_405449 = s_2653_3;
        // N s_2653_5: jump b2652
        return block_2652(state, tracer, fn_state);
    }
    fn block_2654<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2654_0: const #22s : i
        let s_2654_0: i128 = 22;
        // D s_2654_1: read-var u#32661:u32
        let s_2654_1: u32 = fn_state.u_32661;
        // D s_2654_2: cast zx s_2654_1 -> bv
        let s_2654_2: Bits = Bits::new(s_2654_1 as u128, 32u16);
        // C s_2654_3: const #1s : i64
        let s_2654_3: i64 = 1;
        // C s_2654_4: cast zx s_2654_3 -> i
        let s_2654_4: i128 = (i128::try_from(s_2654_3).unwrap());
        // C s_2654_5: const #0s : i
        let s_2654_5: i128 = 0;
        // C s_2654_6: add s_2654_5 s_2654_4
        let s_2654_6: i128 = (s_2654_5 + s_2654_4);
        // D s_2654_7: bit-extract s_2654_2 s_2654_0 s_2654_6
        let s_2654_7: Bits = (Bits::new(
            ((s_2654_2) >> (s_2654_0)).value(),
            u16::try_from(s_2654_6).unwrap(),
        ));
        // D s_2654_8: cast reint s_2654_7 -> u8
        let s_2654_8: bool = ((s_2654_7.value()) != 0);
        // D s_2654_9: cast zx s_2654_8 -> bv
        let s_2654_9: Bits = Bits::new(s_2654_8 as u128, 1u16);
        // C s_2654_10: const #1u : u8
        let s_2654_10: bool = true;
        // C s_2654_11: cast zx s_2654_10 -> bv
        let s_2654_11: Bits = Bits::new(s_2654_10 as u128, 1u16);
        // D s_2654_12: cmp-eq s_2654_9 s_2654_11
        let s_2654_12: bool = ((s_2654_9) == (s_2654_11));
        // N s_2654_13: branch s_2654_12 b2657 b2655
        if s_2654_12 {
            return block_2657(state, tracer, fn_state);
        } else {
            return block_2655(state, tracer, fn_state);
        };
    }
    fn block_2655<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2655_0: const #0u : u8
        let s_2655_0: bool = false;
        // D s_2655_1: write-var gs#405444 <= s_2655_0
        fn_state.gs_405444 = s_2655_0;
        // N s_2655_2: jump b2656
        return block_2656(state, tracer, fn_state);
    }
    fn block_2656<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2656_0: read-var gs#405444:u8
        let s_2656_0: bool = fn_state.gs_405444;
        // D s_2656_1: write-var gs#405445 <= s_2656_0
        fn_state.gs_405445 = s_2656_0;
        // N s_2656_2: jump b619
        return block_619(state, tracer, fn_state);
    }
    fn block_2657<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2657_0: const #16s : i
        let s_2657_0: i128 = 16;
        // D s_2657_1: read-var u#32661:u32
        let s_2657_1: u32 = fn_state.u_32661;
        // D s_2657_2: cast zx s_2657_1 -> bv
        let s_2657_2: Bits = Bits::new(s_2657_1 as u128, 32u16);
        // C s_2657_3: const #1s : i64
        let s_2657_3: i64 = 1;
        // C s_2657_4: cast zx s_2657_3 -> i
        let s_2657_4: i128 = (i128::try_from(s_2657_3).unwrap());
        // C s_2657_5: const #4s : i
        let s_2657_5: i128 = 4;
        // C s_2657_6: add s_2657_5 s_2657_4
        let s_2657_6: i128 = (s_2657_5 + s_2657_4);
        // D s_2657_7: bit-extract s_2657_2 s_2657_0 s_2657_6
        let s_2657_7: Bits = (Bits::new(
            ((s_2657_2) >> (s_2657_0)).value(),
            u16::try_from(s_2657_6).unwrap(),
        ));
        // D s_2657_8: cast reint s_2657_7 -> u8
        let s_2657_8: u8 = (s_2657_7.value() as u8);
        // D s_2657_9: cast zx s_2657_8 -> bv
        let s_2657_9: Bits = Bits::new(s_2657_8 as u128, 5u16);
        // C s_2657_10: const #31u : u8
        let s_2657_10: u8 = 31;
        // C s_2657_11: cast zx s_2657_10 -> bv
        let s_2657_11: Bits = Bits::new(s_2657_10 as u128, 5u16);
        // D s_2657_12: cmp-eq s_2657_9 s_2657_11
        let s_2657_12: bool = ((s_2657_9) == (s_2657_11));
        // N s_2657_13: branch s_2657_12 b2660 b2658
        if s_2657_12 {
            return block_2660(state, tracer, fn_state);
        } else {
            return block_2658(state, tracer, fn_state);
        };
    }
    fn block_2658<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2658_0: const #0u : u8
        let s_2658_0: bool = false;
        // D s_2658_1: write-var gs#405443 <= s_2658_0
        fn_state.gs_405443 = s_2658_0;
        // N s_2658_2: jump b2659
        return block_2659(state, tracer, fn_state);
    }
    fn block_2659<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2659_0: read-var gs#405443:u8
        let s_2659_0: bool = fn_state.gs_405443;
        // D s_2659_1: write-var gs#405444 <= s_2659_0
        fn_state.gs_405444 = s_2659_0;
        // N s_2659_2: jump b2656
        return block_2656(state, tracer, fn_state);
    }
    fn block_2660<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2660_0: const #4s : i
        let s_2660_0: i128 = 4;
        // D s_2660_1: read-var u#32661:u32
        let s_2660_1: u32 = fn_state.u_32661;
        // D s_2660_2: cast zx s_2660_1 -> bv
        let s_2660_2: Bits = Bits::new(s_2660_1 as u128, 32u16);
        // C s_2660_3: const #1s : i64
        let s_2660_3: i64 = 1;
        // C s_2660_4: cast zx s_2660_3 -> i
        let s_2660_4: i128 = (i128::try_from(s_2660_3).unwrap());
        // C s_2660_5: const #3s : i
        let s_2660_5: i128 = 3;
        // C s_2660_6: add s_2660_5 s_2660_4
        let s_2660_6: i128 = (s_2660_5 + s_2660_4);
        // D s_2660_7: bit-extract s_2660_2 s_2660_0 s_2660_6
        let s_2660_7: Bits = (Bits::new(
            ((s_2660_2) >> (s_2660_0)).value(),
            u16::try_from(s_2660_6).unwrap(),
        ));
        // D s_2660_8: cast reint s_2660_7 -> u8
        let s_2660_8: u8 = (s_2660_7.value() as u8);
        // D s_2660_9: cast zx s_2660_8 -> bv
        let s_2660_9: Bits = Bits::new(s_2660_8 as u128, 4u16);
        // C s_2660_10: const #15u : u8
        let s_2660_10: u8 = 15;
        // C s_2660_11: cast zx s_2660_10 -> bv
        let s_2660_11: Bits = Bits::new(s_2660_10 as u128, 4u16);
        // D s_2660_12: cmp-eq s_2660_9 s_2660_11
        let s_2660_12: bool = ((s_2660_9) == (s_2660_11));
        // D s_2660_13: write-var gs#405443 <= s_2660_12
        fn_state.gs_405443 = s_2660_12;
        // N s_2660_14: jump b2659
        return block_2659(state, tracer, fn_state);
    }
    fn block_2661<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2661_0: const #28s : i
        let s_2661_0: i128 = 28;
        // C s_2661_1: const #4s : i
        let s_2661_1: i128 = 4;
        // D s_2661_2: read-var u#32651:u32
        let s_2661_2: u32 = fn_state.u_32651;
        // D s_2661_3: cast zx s_2661_2 -> bv
        let s_2661_3: Bits = Bits::new(s_2661_2 as u128, 32u16);
        // D s_2661_4: bit-extract s_2661_3 s_2661_0 s_2661_1
        let s_2661_4: Bits = (Bits::new(
            ((s_2661_3) >> (s_2661_0)).value(),
            u16::try_from(s_2661_1).unwrap(),
        ));
        // D s_2661_5: cast reint s_2661_4 -> u8
        let s_2661_5: u8 = (s_2661_4.value() as u8);
        // D s_2661_6: cast zx s_2661_5 -> bv
        let s_2661_6: Bits = Bits::new(s_2661_5 as u128, 4u16);
        // C s_2661_7: const #15u : u8
        let s_2661_7: u8 = 15;
        // C s_2661_8: cast zx s_2661_7 -> bv
        let s_2661_8: Bits = Bits::new(s_2661_7 as u128, 4u16);
        // D s_2661_9: cmp-ne s_2661_6 s_2661_8
        let s_2661_9: bool = ((s_2661_6) != (s_2661_8));
        // N s_2661_10: branch s_2661_9 b2664 b2662
        if s_2661_9 {
            return block_2664(state, tracer, fn_state);
        } else {
            return block_2662(state, tracer, fn_state);
        };
    }
    fn block_2662<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2662_0: const #0u : u8
        let s_2662_0: bool = false;
        // D s_2662_1: write-var gs#405414 <= s_2662_0
        fn_state.gs_405414 = s_2662_0;
        // N s_2662_2: jump b2663
        return block_2663(state, tracer, fn_state);
    }
    fn block_2663<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2663_0: read-var gs#405414:u8
        let s_2663_0: bool = fn_state.gs_405414;
        // D s_2663_1: write-var gs#405415 <= s_2663_0
        fn_state.gs_405415 = s_2663_0;
        // N s_2663_2: jump b615
        return block_615(state, tracer, fn_state);
    }
    fn block_2664<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2664_0: const #2982s : i
        let s_2664_0: i128 = 2982;
        // C s_2664_1: const #14696u : u32
        let s_2664_1: u32 = 14696;
        // D s_2664_2: read-reg s_2664_1:i
        let s_2664_2: i128 = {
            let value = state.read_register::<i128>(s_2664_1 as isize);
            tracer.read_register(s_2664_1 as isize, value);
            value
        };
        // D s_2664_3: cmp-lt s_2664_2 s_2664_0
        let s_2664_3: bool = ((s_2664_2) < (s_2664_0));
        // D s_2664_4: write-var gs#405414 <= s_2664_3
        fn_state.gs_405414 = s_2664_3;
        // N s_2664_5: jump b2663
        return block_2663(state, tracer, fn_state);
    }
    fn block_2665<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2665_0: const #22s : i
        let s_2665_0: i128 = 22;
        // D s_2665_1: read-var u#32651:u32
        let s_2665_1: u32 = fn_state.u_32651;
        // D s_2665_2: cast zx s_2665_1 -> bv
        let s_2665_2: Bits = Bits::new(s_2665_1 as u128, 32u16);
        // C s_2665_3: const #1s : i64
        let s_2665_3: i64 = 1;
        // C s_2665_4: cast zx s_2665_3 -> i
        let s_2665_4: i128 = (i128::try_from(s_2665_3).unwrap());
        // C s_2665_5: const #0s : i
        let s_2665_5: i128 = 0;
        // C s_2665_6: add s_2665_5 s_2665_4
        let s_2665_6: i128 = (s_2665_5 + s_2665_4);
        // D s_2665_7: bit-extract s_2665_2 s_2665_0 s_2665_6
        let s_2665_7: Bits = (Bits::new(
            ((s_2665_2) >> (s_2665_0)).value(),
            u16::try_from(s_2665_6).unwrap(),
        ));
        // D s_2665_8: cast reint s_2665_7 -> u8
        let s_2665_8: bool = ((s_2665_7.value()) != 0);
        // D s_2665_9: cast zx s_2665_8 -> bv
        let s_2665_9: Bits = Bits::new(s_2665_8 as u128, 1u16);
        // C s_2665_10: const #1u : u8
        let s_2665_10: bool = true;
        // C s_2665_11: cast zx s_2665_10 -> bv
        let s_2665_11: Bits = Bits::new(s_2665_10 as u128, 1u16);
        // D s_2665_12: cmp-eq s_2665_9 s_2665_11
        let s_2665_12: bool = ((s_2665_9) == (s_2665_11));
        // N s_2665_13: branch s_2665_12 b2668 b2666
        if s_2665_12 {
            return block_2668(state, tracer, fn_state);
        } else {
            return block_2666(state, tracer, fn_state);
        };
    }
    fn block_2666<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2666_0: const #0u : u8
        let s_2666_0: bool = false;
        // D s_2666_1: write-var gs#405409 <= s_2666_0
        fn_state.gs_405409 = s_2666_0;
        // N s_2666_2: jump b2667
        return block_2667(state, tracer, fn_state);
    }
    fn block_2667<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2667_0: read-var gs#405409:u8
        let s_2667_0: bool = fn_state.gs_405409;
        // D s_2667_1: write-var gs#405410 <= s_2667_0
        fn_state.gs_405410 = s_2667_0;
        // N s_2667_2: jump b613
        return block_613(state, tracer, fn_state);
    }
    fn block_2668<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2668_0: const #20s : i
        let s_2668_0: i128 = 20;
        // D s_2668_1: read-var u#32651:u32
        let s_2668_1: u32 = fn_state.u_32651;
        // D s_2668_2: cast zx s_2668_1 -> bv
        let s_2668_2: Bits = Bits::new(s_2668_1 as u128, 32u16);
        // C s_2668_3: const #1s : i64
        let s_2668_3: i64 = 1;
        // C s_2668_4: cast zx s_2668_3 -> i
        let s_2668_4: i128 = (i128::try_from(s_2668_3).unwrap());
        // C s_2668_5: const #0s : i
        let s_2668_5: i128 = 0;
        // C s_2668_6: add s_2668_5 s_2668_4
        let s_2668_6: i128 = (s_2668_5 + s_2668_4);
        // D s_2668_7: bit-extract s_2668_2 s_2668_0 s_2668_6
        let s_2668_7: Bits = (Bits::new(
            ((s_2668_2) >> (s_2668_0)).value(),
            u16::try_from(s_2668_6).unwrap(),
        ));
        // D s_2668_8: cast reint s_2668_7 -> u8
        let s_2668_8: bool = ((s_2668_7.value()) != 0);
        // D s_2668_9: cast zx s_2668_8 -> bv
        let s_2668_9: Bits = Bits::new(s_2668_8 as u128, 1u16);
        // C s_2668_10: const #1u : u8
        let s_2668_10: bool = true;
        // C s_2668_11: cast zx s_2668_10 -> bv
        let s_2668_11: Bits = Bits::new(s_2668_10 as u128, 1u16);
        // D s_2668_12: cmp-eq s_2668_9 s_2668_11
        let s_2668_12: bool = ((s_2668_9) == (s_2668_11));
        // N s_2668_13: branch s_2668_12 b2671 b2669
        if s_2668_12 {
            return block_2671(state, tracer, fn_state);
        } else {
            return block_2669(state, tracer, fn_state);
        };
    }
    fn block_2669<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2669_0: const #0u : u8
        let s_2669_0: bool = false;
        // D s_2669_1: write-var gs#405408 <= s_2669_0
        fn_state.gs_405408 = s_2669_0;
        // N s_2669_2: jump b2670
        return block_2670(state, tracer, fn_state);
    }
    fn block_2670<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2670_0: read-var gs#405408:u8
        let s_2670_0: bool = fn_state.gs_405408;
        // D s_2670_1: write-var gs#405409 <= s_2670_0
        fn_state.gs_405409 = s_2670_0;
        // N s_2670_2: jump b2667
        return block_2667(state, tracer, fn_state);
    }
    fn block_2671<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2671_0: const #4s : i
        let s_2671_0: i128 = 4;
        // D s_2671_1: read-var u#32651:u32
        let s_2671_1: u32 = fn_state.u_32651;
        // D s_2671_2: cast zx s_2671_1 -> bv
        let s_2671_2: Bits = Bits::new(s_2671_1 as u128, 32u16);
        // C s_2671_3: const #1s : i64
        let s_2671_3: i64 = 1;
        // C s_2671_4: cast zx s_2671_3 -> i
        let s_2671_4: i128 = (i128::try_from(s_2671_3).unwrap());
        // C s_2671_5: const #3s : i
        let s_2671_5: i128 = 3;
        // C s_2671_6: add s_2671_5 s_2671_4
        let s_2671_6: i128 = (s_2671_5 + s_2671_4);
        // D s_2671_7: bit-extract s_2671_2 s_2671_0 s_2671_6
        let s_2671_7: Bits = (Bits::new(
            ((s_2671_2) >> (s_2671_0)).value(),
            u16::try_from(s_2671_6).unwrap(),
        ));
        // D s_2671_8: cast reint s_2671_7 -> u8
        let s_2671_8: u8 = (s_2671_7.value() as u8);
        // D s_2671_9: cast zx s_2671_8 -> bv
        let s_2671_9: Bits = Bits::new(s_2671_8 as u128, 4u16);
        // C s_2671_10: const #15u : u8
        let s_2671_10: u8 = 15;
        // C s_2671_11: cast zx s_2671_10 -> bv
        let s_2671_11: Bits = Bits::new(s_2671_10 as u128, 4u16);
        // D s_2671_12: cmp-eq s_2671_9 s_2671_11
        let s_2671_12: bool = ((s_2671_9) == (s_2671_11));
        // D s_2671_13: write-var gs#405408 <= s_2671_12
        fn_state.gs_405408 = s_2671_12;
        // N s_2671_14: jump b2670
        return block_2670(state, tracer, fn_state);
    }
    fn block_2672<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2672_0: const #28s : i
        let s_2672_0: i128 = 28;
        // C s_2672_1: const #4s : i
        let s_2672_1: i128 = 4;
        // D s_2672_2: read-var u#32644:u32
        let s_2672_2: u32 = fn_state.u_32644;
        // D s_2672_3: cast zx s_2672_2 -> bv
        let s_2672_3: Bits = Bits::new(s_2672_2 as u128, 32u16);
        // D s_2672_4: bit-extract s_2672_3 s_2672_0 s_2672_1
        let s_2672_4: Bits = (Bits::new(
            ((s_2672_3) >> (s_2672_0)).value(),
            u16::try_from(s_2672_1).unwrap(),
        ));
        // D s_2672_5: cast reint s_2672_4 -> u8
        let s_2672_5: u8 = (s_2672_4.value() as u8);
        // D s_2672_6: cast zx s_2672_5 -> bv
        let s_2672_6: Bits = Bits::new(s_2672_5 as u128, 4u16);
        // C s_2672_7: const #15u : u8
        let s_2672_7: u8 = 15;
        // C s_2672_8: cast zx s_2672_7 -> bv
        let s_2672_8: Bits = Bits::new(s_2672_7 as u128, 4u16);
        // D s_2672_9: cmp-ne s_2672_6 s_2672_8
        let s_2672_9: bool = ((s_2672_6) != (s_2672_8));
        // N s_2672_10: branch s_2672_9 b2675 b2673
        if s_2672_9 {
            return block_2675(state, tracer, fn_state);
        } else {
            return block_2673(state, tracer, fn_state);
        };
    }
    fn block_2673<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2673_0: const #0u : u8
        let s_2673_0: bool = false;
        // D s_2673_1: write-var gs#405374 <= s_2673_0
        fn_state.gs_405374 = s_2673_0;
        // N s_2673_2: jump b2674
        return block_2674(state, tracer, fn_state);
    }
    fn block_2674<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2674_0: read-var gs#405374:u8
        let s_2674_0: bool = fn_state.gs_405374;
        // D s_2674_1: write-var gs#405375 <= s_2674_0
        fn_state.gs_405375 = s_2674_0;
        // N s_2674_2: jump b598
        return block_598(state, tracer, fn_state);
    }
    fn block_2675<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2675_0: const #2980s : i
        let s_2675_0: i128 = 2980;
        // C s_2675_1: const #14696u : u32
        let s_2675_1: u32 = 14696;
        // D s_2675_2: read-reg s_2675_1:i
        let s_2675_2: i128 = {
            let value = state.read_register::<i128>(s_2675_1 as isize);
            tracer.read_register(s_2675_1 as isize, value);
            value
        };
        // D s_2675_3: cmp-lt s_2675_2 s_2675_0
        let s_2675_3: bool = ((s_2675_2) < (s_2675_0));
        // D s_2675_4: write-var gs#405374 <= s_2675_3
        fn_state.gs_405374 = s_2675_3;
        // N s_2675_5: jump b2674
        return block_2674(state, tracer, fn_state);
    }
    fn block_2676<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2676_0: const #20s : i
        let s_2676_0: i128 = 20;
        // D s_2676_1: read-var u#32644:u32
        let s_2676_1: u32 = fn_state.u_32644;
        // D s_2676_2: cast zx s_2676_1 -> bv
        let s_2676_2: Bits = Bits::new(s_2676_1 as u128, 32u16);
        // C s_2676_3: const #1s : i64
        let s_2676_3: i64 = 1;
        // C s_2676_4: cast zx s_2676_3 -> i
        let s_2676_4: i128 = (i128::try_from(s_2676_3).unwrap());
        // C s_2676_5: const #2s : i
        let s_2676_5: i128 = 2;
        // C s_2676_6: add s_2676_5 s_2676_4
        let s_2676_6: i128 = (s_2676_5 + s_2676_4);
        // D s_2676_7: bit-extract s_2676_2 s_2676_0 s_2676_6
        let s_2676_7: Bits = (Bits::new(
            ((s_2676_2) >> (s_2676_0)).value(),
            u16::try_from(s_2676_6).unwrap(),
        ));
        // D s_2676_8: cast reint s_2676_7 -> u8
        let s_2676_8: u8 = (s_2676_7.value() as u8);
        // D s_2676_9: cast zx s_2676_8 -> bv
        let s_2676_9: Bits = Bits::new(s_2676_8 as u128, 3u16);
        // C s_2676_10: const #3u : u8
        let s_2676_10: u8 = 3;
        // C s_2676_11: cast zx s_2676_10 -> bv
        let s_2676_11: Bits = Bits::new(s_2676_10 as u128, 3u16);
        // D s_2676_12: cmp-eq s_2676_9 s_2676_11
        let s_2676_12: bool = ((s_2676_9) == (s_2676_11));
        // N s_2676_13: branch s_2676_12 b2679 b2677
        if s_2676_12 {
            return block_2679(state, tracer, fn_state);
        } else {
            return block_2677(state, tracer, fn_state);
        };
    }
    fn block_2677<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2677_0: const #0u : u8
        let s_2677_0: bool = false;
        // D s_2677_1: write-var gs#405369 <= s_2677_0
        fn_state.gs_405369 = s_2677_0;
        // N s_2677_2: jump b2678
        return block_2678(state, tracer, fn_state);
    }
    fn block_2678<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2678_0: read-var gs#405369:u8
        let s_2678_0: bool = fn_state.gs_405369;
        // D s_2678_1: write-var gs#405370 <= s_2678_0
        fn_state.gs_405370 = s_2678_0;
        // N s_2678_2: jump b596
        return block_596(state, tracer, fn_state);
    }
    fn block_2679<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2679_0: const #4s : i
        let s_2679_0: i128 = 4;
        // D s_2679_1: read-var u#32644:u32
        let s_2679_1: u32 = fn_state.u_32644;
        // D s_2679_2: cast zx s_2679_1 -> bv
        let s_2679_2: Bits = Bits::new(s_2679_1 as u128, 32u16);
        // C s_2679_3: const #1s : i64
        let s_2679_3: i64 = 1;
        // C s_2679_4: cast zx s_2679_3 -> i
        let s_2679_4: i128 = (i128::try_from(s_2679_3).unwrap());
        // C s_2679_5: const #7s : i
        let s_2679_5: i128 = 7;
        // C s_2679_6: add s_2679_5 s_2679_4
        let s_2679_6: i128 = (s_2679_5 + s_2679_4);
        // D s_2679_7: bit-extract s_2679_2 s_2679_0 s_2679_6
        let s_2679_7: Bits = (Bits::new(
            ((s_2679_2) >> (s_2679_0)).value(),
            u16::try_from(s_2679_6).unwrap(),
        ));
        // D s_2679_8: cast reint s_2679_7 -> u8
        let s_2679_8: u8 = (s_2679_7.value() as u8);
        // D s_2679_9: cast zx s_2679_8 -> bv
        let s_2679_9: Bits = Bits::new(s_2679_8 as u128, 8u16);
        // C s_2679_10: const #13u : u8
        let s_2679_10: u8 = 13;
        // C s_2679_11: cast zx s_2679_10 -> bv
        let s_2679_11: Bits = Bits::new(s_2679_10 as u128, 8u16);
        // D s_2679_12: cmp-eq s_2679_9 s_2679_11
        let s_2679_12: bool = ((s_2679_9) == (s_2679_11));
        // D s_2679_13: write-var gs#405369 <= s_2679_12
        fn_state.gs_405369 = s_2679_12;
        // N s_2679_14: jump b2678
        return block_2678(state, tracer, fn_state);
    }
    fn block_2680<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2680_0: const #28s : i
        let s_2680_0: i128 = 28;
        // C s_2680_1: const #4s : i
        let s_2680_1: i128 = 4;
        // D s_2680_2: read-var u#32636:u32
        let s_2680_2: u32 = fn_state.u_32636;
        // D s_2680_3: cast zx s_2680_2 -> bv
        let s_2680_3: Bits = Bits::new(s_2680_2 as u128, 32u16);
        // D s_2680_4: bit-extract s_2680_3 s_2680_0 s_2680_1
        let s_2680_4: Bits = (Bits::new(
            ((s_2680_3) >> (s_2680_0)).value(),
            u16::try_from(s_2680_1).unwrap(),
        ));
        // D s_2680_5: cast reint s_2680_4 -> u8
        let s_2680_5: u8 = (s_2680_4.value() as u8);
        // D s_2680_6: cast zx s_2680_5 -> bv
        let s_2680_6: Bits = Bits::new(s_2680_5 as u128, 4u16);
        // C s_2680_7: const #15u : u8
        let s_2680_7: u8 = 15;
        // C s_2680_8: cast zx s_2680_7 -> bv
        let s_2680_8: Bits = Bits::new(s_2680_7 as u128, 4u16);
        // D s_2680_9: cmp-ne s_2680_6 s_2680_8
        let s_2680_9: bool = ((s_2680_6) != (s_2680_8));
        // N s_2680_10: branch s_2680_9 b2683 b2681
        if s_2680_9 {
            return block_2683(state, tracer, fn_state);
        } else {
            return block_2681(state, tracer, fn_state);
        };
    }
    fn block_2681<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2681_0: const #0u : u8
        let s_2681_0: bool = false;
        // D s_2681_1: write-var gs#405346 <= s_2681_0
        fn_state.gs_405346 = s_2681_0;
        // N s_2681_2: jump b2682
        return block_2682(state, tracer, fn_state);
    }
    fn block_2682<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2682_0: read-var gs#405346:u8
        let s_2682_0: bool = fn_state.gs_405346;
        // D s_2682_1: write-var gs#405347 <= s_2682_0
        fn_state.gs_405347 = s_2682_0;
        // N s_2682_2: jump b592
        return block_592(state, tracer, fn_state);
    }
    fn block_2683<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2683_0: const #2979s : i
        let s_2683_0: i128 = 2979;
        // C s_2683_1: const #14696u : u32
        let s_2683_1: u32 = 14696;
        // D s_2683_2: read-reg s_2683_1:i
        let s_2683_2: i128 = {
            let value = state.read_register::<i128>(s_2683_1 as isize);
            tracer.read_register(s_2683_1 as isize, value);
            value
        };
        // D s_2683_3: cmp-lt s_2683_2 s_2683_0
        let s_2683_3: bool = ((s_2683_2) < (s_2683_0));
        // D s_2683_4: write-var gs#405346 <= s_2683_3
        fn_state.gs_405346 = s_2683_3;
        // N s_2683_5: jump b2682
        return block_2682(state, tracer, fn_state);
    }
    fn block_2684<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2684_0: const #20s : i
        let s_2684_0: i128 = 20;
        // D s_2684_1: read-var u#32636:u32
        let s_2684_1: u32 = fn_state.u_32636;
        // D s_2684_2: cast zx s_2684_1 -> bv
        let s_2684_2: Bits = Bits::new(s_2684_1 as u128, 32u16);
        // C s_2684_3: const #1s : i64
        let s_2684_3: i64 = 1;
        // C s_2684_4: cast zx s_2684_3 -> i
        let s_2684_4: i128 = (i128::try_from(s_2684_3).unwrap());
        // C s_2684_5: const #2s : i
        let s_2684_5: i128 = 2;
        // C s_2684_6: add s_2684_5 s_2684_4
        let s_2684_6: i128 = (s_2684_5 + s_2684_4);
        // D s_2684_7: bit-extract s_2684_2 s_2684_0 s_2684_6
        let s_2684_7: Bits = (Bits::new(
            ((s_2684_2) >> (s_2684_0)).value(),
            u16::try_from(s_2684_6).unwrap(),
        ));
        // D s_2684_8: cast reint s_2684_7 -> u8
        let s_2684_8: u8 = (s_2684_7.value() as u8);
        // D s_2684_9: cast zx s_2684_8 -> bv
        let s_2684_9: Bits = Bits::new(s_2684_8 as u128, 3u16);
        // C s_2684_10: const #7u : u8
        let s_2684_10: u8 = 7;
        // C s_2684_11: cast zx s_2684_10 -> bv
        let s_2684_11: Bits = Bits::new(s_2684_10 as u128, 3u16);
        // D s_2684_12: cmp-eq s_2684_9 s_2684_11
        let s_2684_12: bool = ((s_2684_9) == (s_2684_11));
        // N s_2684_13: branch s_2684_12 b2687 b2685
        if s_2684_12 {
            return block_2687(state, tracer, fn_state);
        } else {
            return block_2685(state, tracer, fn_state);
        };
    }
    fn block_2685<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2685_0: const #0u : u8
        let s_2685_0: bool = false;
        // D s_2685_1: write-var gs#405341 <= s_2685_0
        fn_state.gs_405341 = s_2685_0;
        // N s_2685_2: jump b2686
        return block_2686(state, tracer, fn_state);
    }
    fn block_2686<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2686_0: read-var gs#405341:u8
        let s_2686_0: bool = fn_state.gs_405341;
        // D s_2686_1: write-var gs#405342 <= s_2686_0
        fn_state.gs_405342 = s_2686_0;
        // N s_2686_2: jump b590
        return block_590(state, tracer, fn_state);
    }
    fn block_2687<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2687_0: const #4s : i
        let s_2687_0: i128 = 4;
        // D s_2687_1: read-var u#32636:u32
        let s_2687_1: u32 = fn_state.u_32636;
        // D s_2687_2: cast zx s_2687_1 -> bv
        let s_2687_2: Bits = Bits::new(s_2687_1 as u128, 32u16);
        // C s_2687_3: const #1s : i64
        let s_2687_3: i64 = 1;
        // C s_2687_4: cast zx s_2687_3 -> i
        let s_2687_4: i128 = (i128::try_from(s_2687_3).unwrap());
        // C s_2687_5: const #3s : i
        let s_2687_5: i128 = 3;
        // C s_2687_6: add s_2687_5 s_2687_4
        let s_2687_6: i128 = (s_2687_5 + s_2687_4);
        // D s_2687_7: bit-extract s_2687_2 s_2687_0 s_2687_6
        let s_2687_7: Bits = (Bits::new(
            ((s_2687_2) >> (s_2687_0)).value(),
            u16::try_from(s_2687_6).unwrap(),
        ));
        // D s_2687_8: cast reint s_2687_7 -> u8
        let s_2687_8: u8 = (s_2687_7.value() as u8);
        // D s_2687_9: cast zx s_2687_8 -> bv
        let s_2687_9: Bits = Bits::new(s_2687_8 as u128, 4u16);
        // C s_2687_10: const #13u : u8
        let s_2687_10: u8 = 13;
        // C s_2687_11: cast zx s_2687_10 -> bv
        let s_2687_11: Bits = Bits::new(s_2687_10 as u128, 4u16);
        // D s_2687_12: cmp-eq s_2687_9 s_2687_11
        let s_2687_12: bool = ((s_2687_9) == (s_2687_11));
        // D s_2687_13: write-var gs#405341 <= s_2687_12
        fn_state.gs_405341 = s_2687_12;
        // N s_2687_14: jump b2686
        return block_2686(state, tracer, fn_state);
    }
    fn block_2688<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2688_0: const #28s : i
        let s_2688_0: i128 = 28;
        // C s_2688_1: const #4s : i
        let s_2688_1: i128 = 4;
        // D s_2688_2: read-var u#32627:u32
        let s_2688_2: u32 = fn_state.u_32627;
        // D s_2688_3: cast zx s_2688_2 -> bv
        let s_2688_3: Bits = Bits::new(s_2688_2 as u128, 32u16);
        // D s_2688_4: bit-extract s_2688_3 s_2688_0 s_2688_1
        let s_2688_4: Bits = (Bits::new(
            ((s_2688_3) >> (s_2688_0)).value(),
            u16::try_from(s_2688_1).unwrap(),
        ));
        // D s_2688_5: cast reint s_2688_4 -> u8
        let s_2688_5: u8 = (s_2688_4.value() as u8);
        // D s_2688_6: cast zx s_2688_5 -> bv
        let s_2688_6: Bits = Bits::new(s_2688_5 as u128, 4u16);
        // C s_2688_7: const #15u : u8
        let s_2688_7: u8 = 15;
        // C s_2688_8: cast zx s_2688_7 -> bv
        let s_2688_8: Bits = Bits::new(s_2688_7 as u128, 4u16);
        // D s_2688_9: cmp-ne s_2688_6 s_2688_8
        let s_2688_9: bool = ((s_2688_6) != (s_2688_8));
        // N s_2688_10: branch s_2688_9 b2691 b2689
        if s_2688_9 {
            return block_2691(state, tracer, fn_state);
        } else {
            return block_2689(state, tracer, fn_state);
        };
    }
    fn block_2689<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2689_0: const #0u : u8
        let s_2689_0: bool = false;
        // D s_2689_1: write-var gs#405305 <= s_2689_0
        fn_state.gs_405305 = s_2689_0;
        // N s_2689_2: jump b2690
        return block_2690(state, tracer, fn_state);
    }
    fn block_2690<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2690_0: read-var gs#405305:u8
        let s_2690_0: bool = fn_state.gs_405305;
        // D s_2690_1: write-var gs#405306 <= s_2690_0
        fn_state.gs_405306 = s_2690_0;
        // N s_2690_2: jump b575
        return block_575(state, tracer, fn_state);
    }
    fn block_2691<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2691_0: const #2976s : i
        let s_2691_0: i128 = 2976;
        // C s_2691_1: const #14696u : u32
        let s_2691_1: u32 = 14696;
        // D s_2691_2: read-reg s_2691_1:i
        let s_2691_2: i128 = {
            let value = state.read_register::<i128>(s_2691_1 as isize);
            tracer.read_register(s_2691_1 as isize, value);
            value
        };
        // D s_2691_3: cmp-lt s_2691_2 s_2691_0
        let s_2691_3: bool = ((s_2691_2) < (s_2691_0));
        // D s_2691_4: write-var gs#405305 <= s_2691_3
        fn_state.gs_405305 = s_2691_3;
        // N s_2691_5: jump b2690
        return block_2690(state, tracer, fn_state);
    }
    fn block_2692<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2692_0: const #22s : i
        let s_2692_0: i128 = 22;
        // D s_2692_1: read-var u#32627:u32
        let s_2692_1: u32 = fn_state.u_32627;
        // D s_2692_2: cast zx s_2692_1 -> bv
        let s_2692_2: Bits = Bits::new(s_2692_1 as u128, 32u16);
        // C s_2692_3: const #1s : i64
        let s_2692_3: i64 = 1;
        // C s_2692_4: cast zx s_2692_3 -> i
        let s_2692_4: i128 = (i128::try_from(s_2692_3).unwrap());
        // C s_2692_5: const #0s : i
        let s_2692_5: i128 = 0;
        // C s_2692_6: add s_2692_5 s_2692_4
        let s_2692_6: i128 = (s_2692_5 + s_2692_4);
        // D s_2692_7: bit-extract s_2692_2 s_2692_0 s_2692_6
        let s_2692_7: Bits = (Bits::new(
            ((s_2692_2) >> (s_2692_0)).value(),
            u16::try_from(s_2692_6).unwrap(),
        ));
        // D s_2692_8: cast reint s_2692_7 -> u8
        let s_2692_8: bool = ((s_2692_7.value()) != 0);
        // D s_2692_9: cast zx s_2692_8 -> bv
        let s_2692_9: Bits = Bits::new(s_2692_8 as u128, 1u16);
        // C s_2692_10: const #0u : u8
        let s_2692_10: bool = false;
        // C s_2692_11: cast zx s_2692_10 -> bv
        let s_2692_11: Bits = Bits::new(s_2692_10 as u128, 1u16);
        // D s_2692_12: cmp-eq s_2692_9 s_2692_11
        let s_2692_12: bool = ((s_2692_9) == (s_2692_11));
        // N s_2692_13: branch s_2692_12 b2695 b2693
        if s_2692_12 {
            return block_2695(state, tracer, fn_state);
        } else {
            return block_2693(state, tracer, fn_state);
        };
    }
    fn block_2693<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2693_0: const #0u : u8
        let s_2693_0: bool = false;
        // D s_2693_1: write-var gs#405300 <= s_2693_0
        fn_state.gs_405300 = s_2693_0;
        // N s_2693_2: jump b2694
        return block_2694(state, tracer, fn_state);
    }
    fn block_2694<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2694_0: read-var gs#405300:u8
        let s_2694_0: bool = fn_state.gs_405300;
        // D s_2694_1: write-var gs#405301 <= s_2694_0
        fn_state.gs_405301 = s_2694_0;
        // N s_2694_2: jump b573
        return block_573(state, tracer, fn_state);
    }
    fn block_2695<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2695_0: const #20s : i
        let s_2695_0: i128 = 20;
        // D s_2695_1: read-var u#32627:u32
        let s_2695_1: u32 = fn_state.u_32627;
        // D s_2695_2: cast zx s_2695_1 -> bv
        let s_2695_2: Bits = Bits::new(s_2695_1 as u128, 32u16);
        // C s_2695_3: const #1s : i64
        let s_2695_3: i64 = 1;
        // C s_2695_4: cast zx s_2695_3 -> i
        let s_2695_4: i128 = (i128::try_from(s_2695_3).unwrap());
        // C s_2695_5: const #0s : i
        let s_2695_5: i128 = 0;
        // C s_2695_6: add s_2695_5 s_2695_4
        let s_2695_6: i128 = (s_2695_5 + s_2695_4);
        // D s_2695_7: bit-extract s_2695_2 s_2695_0 s_2695_6
        let s_2695_7: Bits = (Bits::new(
            ((s_2695_2) >> (s_2695_0)).value(),
            u16::try_from(s_2695_6).unwrap(),
        ));
        // D s_2695_8: cast reint s_2695_7 -> u8
        let s_2695_8: bool = ((s_2695_7.value()) != 0);
        // D s_2695_9: cast zx s_2695_8 -> bv
        let s_2695_9: Bits = Bits::new(s_2695_8 as u128, 1u16);
        // C s_2695_10: const #1u : u8
        let s_2695_10: bool = true;
        // C s_2695_11: cast zx s_2695_10 -> bv
        let s_2695_11: Bits = Bits::new(s_2695_10 as u128, 1u16);
        // D s_2695_12: cmp-eq s_2695_9 s_2695_11
        let s_2695_12: bool = ((s_2695_9) == (s_2695_11));
        // N s_2695_13: branch s_2695_12 b2698 b2696
        if s_2695_12 {
            return block_2698(state, tracer, fn_state);
        } else {
            return block_2696(state, tracer, fn_state);
        };
    }
    fn block_2696<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2696_0: const #0u : u8
        let s_2696_0: bool = false;
        // D s_2696_1: write-var gs#405299 <= s_2696_0
        fn_state.gs_405299 = s_2696_0;
        // N s_2696_2: jump b2697
        return block_2697(state, tracer, fn_state);
    }
    fn block_2697<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2697_0: read-var gs#405299:u8
        let s_2697_0: bool = fn_state.gs_405299;
        // D s_2697_1: write-var gs#405300 <= s_2697_0
        fn_state.gs_405300 = s_2697_0;
        // N s_2697_2: jump b2694
        return block_2694(state, tracer, fn_state);
    }
    fn block_2698<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2698_0: const #4s : i
        let s_2698_0: i128 = 4;
        // D s_2698_1: read-var u#32627:u32
        let s_2698_1: u32 = fn_state.u_32627;
        // D s_2698_2: cast zx s_2698_1 -> bv
        let s_2698_2: Bits = Bits::new(s_2698_1 as u128, 32u16);
        // C s_2698_3: const #1s : i64
        let s_2698_3: i64 = 1;
        // C s_2698_4: cast zx s_2698_3 -> i
        let s_2698_4: i128 = (i128::try_from(s_2698_3).unwrap());
        // C s_2698_5: const #7s : i
        let s_2698_5: i128 = 7;
        // C s_2698_6: add s_2698_5 s_2698_4
        let s_2698_6: i128 = (s_2698_5 + s_2698_4);
        // D s_2698_7: bit-extract s_2698_2 s_2698_0 s_2698_6
        let s_2698_7: Bits = (Bits::new(
            ((s_2698_2) >> (s_2698_0)).value(),
            u16::try_from(s_2698_6).unwrap(),
        ));
        // D s_2698_8: cast reint s_2698_7 -> u8
        let s_2698_8: u8 = (s_2698_7.value() as u8);
        // D s_2698_9: cast zx s_2698_8 -> bv
        let s_2698_9: Bits = Bits::new(s_2698_8 as u128, 8u16);
        // C s_2698_10: const #13u : u8
        let s_2698_10: u8 = 13;
        // C s_2698_11: cast zx s_2698_10 -> bv
        let s_2698_11: Bits = Bits::new(s_2698_10 as u128, 8u16);
        // D s_2698_12: cmp-eq s_2698_9 s_2698_11
        let s_2698_12: bool = ((s_2698_9) == (s_2698_11));
        // D s_2698_13: write-var gs#405299 <= s_2698_12
        fn_state.gs_405299 = s_2698_12;
        // N s_2698_14: jump b2697
        return block_2697(state, tracer, fn_state);
    }
    fn block_2699<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2699_0: const #28s : i
        let s_2699_0: i128 = 28;
        // C s_2699_1: const #4s : i
        let s_2699_1: i128 = 4;
        // D s_2699_2: read-var u#32618:u32
        let s_2699_2: u32 = fn_state.u_32618;
        // D s_2699_3: cast zx s_2699_2 -> bv
        let s_2699_3: Bits = Bits::new(s_2699_2 as u128, 32u16);
        // D s_2699_4: bit-extract s_2699_3 s_2699_0 s_2699_1
        let s_2699_4: Bits = (Bits::new(
            ((s_2699_3) >> (s_2699_0)).value(),
            u16::try_from(s_2699_1).unwrap(),
        ));
        // D s_2699_5: cast reint s_2699_4 -> u8
        let s_2699_5: u8 = (s_2699_4.value() as u8);
        // D s_2699_6: cast zx s_2699_5 -> bv
        let s_2699_6: Bits = Bits::new(s_2699_5 as u128, 4u16);
        // C s_2699_7: const #15u : u8
        let s_2699_7: u8 = 15;
        // C s_2699_8: cast zx s_2699_7 -> bv
        let s_2699_8: Bits = Bits::new(s_2699_7 as u128, 4u16);
        // D s_2699_9: cmp-ne s_2699_6 s_2699_8
        let s_2699_9: bool = ((s_2699_6) != (s_2699_8));
        // N s_2699_10: branch s_2699_9 b2702 b2700
        if s_2699_9 {
            return block_2702(state, tracer, fn_state);
        } else {
            return block_2700(state, tracer, fn_state);
        };
    }
    fn block_2700<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2700_0: const #0u : u8
        let s_2700_0: bool = false;
        // D s_2700_1: write-var gs#405272 <= s_2700_0
        fn_state.gs_405272 = s_2700_0;
        // N s_2700_2: jump b2701
        return block_2701(state, tracer, fn_state);
    }
    fn block_2701<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2701_0: read-var gs#405272:u8
        let s_2701_0: bool = fn_state.gs_405272;
        // D s_2701_1: write-var gs#405273 <= s_2701_0
        fn_state.gs_405273 = s_2701_0;
        // N s_2701_2: jump b569
        return block_569(state, tracer, fn_state);
    }
    fn block_2702<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2702_0: const #2974s : i
        let s_2702_0: i128 = 2974;
        // C s_2702_1: const #14696u : u32
        let s_2702_1: u32 = 14696;
        // D s_2702_2: read-reg s_2702_1:i
        let s_2702_2: i128 = {
            let value = state.read_register::<i128>(s_2702_1 as isize);
            tracer.read_register(s_2702_1 as isize, value);
            value
        };
        // D s_2702_3: cmp-lt s_2702_2 s_2702_0
        let s_2702_3: bool = ((s_2702_2) < (s_2702_0));
        // D s_2702_4: write-var gs#405272 <= s_2702_3
        fn_state.gs_405272 = s_2702_3;
        // N s_2702_5: jump b2701
        return block_2701(state, tracer, fn_state);
    }
    fn block_2703<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2703_0: const #22s : i
        let s_2703_0: i128 = 22;
        // D s_2703_1: read-var u#32618:u32
        let s_2703_1: u32 = fn_state.u_32618;
        // D s_2703_2: cast zx s_2703_1 -> bv
        let s_2703_2: Bits = Bits::new(s_2703_1 as u128, 32u16);
        // C s_2703_3: const #1s : i64
        let s_2703_3: i64 = 1;
        // C s_2703_4: cast zx s_2703_3 -> i
        let s_2703_4: i128 = (i128::try_from(s_2703_3).unwrap());
        // C s_2703_5: const #0s : i
        let s_2703_5: i128 = 0;
        // C s_2703_6: add s_2703_5 s_2703_4
        let s_2703_6: i128 = (s_2703_5 + s_2703_4);
        // D s_2703_7: bit-extract s_2703_2 s_2703_0 s_2703_6
        let s_2703_7: Bits = (Bits::new(
            ((s_2703_2) >> (s_2703_0)).value(),
            u16::try_from(s_2703_6).unwrap(),
        ));
        // D s_2703_8: cast reint s_2703_7 -> u8
        let s_2703_8: bool = ((s_2703_7.value()) != 0);
        // D s_2703_9: cast zx s_2703_8 -> bv
        let s_2703_9: Bits = Bits::new(s_2703_8 as u128, 1u16);
        // C s_2703_10: const #1u : u8
        let s_2703_10: bool = true;
        // C s_2703_11: cast zx s_2703_10 -> bv
        let s_2703_11: Bits = Bits::new(s_2703_10 as u128, 1u16);
        // D s_2703_12: cmp-eq s_2703_9 s_2703_11
        let s_2703_12: bool = ((s_2703_9) == (s_2703_11));
        // N s_2703_13: branch s_2703_12 b2706 b2704
        if s_2703_12 {
            return block_2706(state, tracer, fn_state);
        } else {
            return block_2704(state, tracer, fn_state);
        };
    }
    fn block_2704<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2704_0: const #0u : u8
        let s_2704_0: bool = false;
        // D s_2704_1: write-var gs#405267 <= s_2704_0
        fn_state.gs_405267 = s_2704_0;
        // N s_2704_2: jump b2705
        return block_2705(state, tracer, fn_state);
    }
    fn block_2705<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2705_0: read-var gs#405267:u8
        let s_2705_0: bool = fn_state.gs_405267;
        // D s_2705_1: write-var gs#405268 <= s_2705_0
        fn_state.gs_405268 = s_2705_0;
        // N s_2705_2: jump b567
        return block_567(state, tracer, fn_state);
    }
    fn block_2706<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2706_0: const #16s : i
        let s_2706_0: i128 = 16;
        // D s_2706_1: read-var u#32618:u32
        let s_2706_1: u32 = fn_state.u_32618;
        // D s_2706_2: cast zx s_2706_1 -> bv
        let s_2706_2: Bits = Bits::new(s_2706_1 as u128, 32u16);
        // C s_2706_3: const #1s : i64
        let s_2706_3: i64 = 1;
        // C s_2706_4: cast zx s_2706_3 -> i
        let s_2706_4: i128 = (i128::try_from(s_2706_3).unwrap());
        // C s_2706_5: const #4s : i
        let s_2706_5: i128 = 4;
        // C s_2706_6: add s_2706_5 s_2706_4
        let s_2706_6: i128 = (s_2706_5 + s_2706_4);
        // D s_2706_7: bit-extract s_2706_2 s_2706_0 s_2706_6
        let s_2706_7: Bits = (Bits::new(
            ((s_2706_2) >> (s_2706_0)).value(),
            u16::try_from(s_2706_6).unwrap(),
        ));
        // D s_2706_8: cast reint s_2706_7 -> u8
        let s_2706_8: u8 = (s_2706_7.value() as u8);
        // D s_2706_9: cast zx s_2706_8 -> bv
        let s_2706_9: Bits = Bits::new(s_2706_8 as u128, 5u16);
        // C s_2706_10: const #31u : u8
        let s_2706_10: u8 = 31;
        // C s_2706_11: cast zx s_2706_10 -> bv
        let s_2706_11: Bits = Bits::new(s_2706_10 as u128, 5u16);
        // D s_2706_12: cmp-eq s_2706_9 s_2706_11
        let s_2706_12: bool = ((s_2706_9) == (s_2706_11));
        // N s_2706_13: branch s_2706_12 b2709 b2707
        if s_2706_12 {
            return block_2709(state, tracer, fn_state);
        } else {
            return block_2707(state, tracer, fn_state);
        };
    }
    fn block_2707<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2707_0: const #0u : u8
        let s_2707_0: bool = false;
        // D s_2707_1: write-var gs#405266 <= s_2707_0
        fn_state.gs_405266 = s_2707_0;
        // N s_2707_2: jump b2708
        return block_2708(state, tracer, fn_state);
    }
    fn block_2708<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2708_0: read-var gs#405266:u8
        let s_2708_0: bool = fn_state.gs_405266;
        // D s_2708_1: write-var gs#405267 <= s_2708_0
        fn_state.gs_405267 = s_2708_0;
        // N s_2708_2: jump b2705
        return block_2705(state, tracer, fn_state);
    }
    fn block_2709<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2709_0: const #4s : i
        let s_2709_0: i128 = 4;
        // D s_2709_1: read-var u#32618:u32
        let s_2709_1: u32 = fn_state.u_32618;
        // D s_2709_2: cast zx s_2709_1 -> bv
        let s_2709_2: Bits = Bits::new(s_2709_1 as u128, 32u16);
        // C s_2709_3: const #1s : i64
        let s_2709_3: i64 = 1;
        // C s_2709_4: cast zx s_2709_3 -> i
        let s_2709_4: i128 = (i128::try_from(s_2709_3).unwrap());
        // C s_2709_5: const #3s : i
        let s_2709_5: i128 = 3;
        // C s_2709_6: add s_2709_5 s_2709_4
        let s_2709_6: i128 = (s_2709_5 + s_2709_4);
        // D s_2709_7: bit-extract s_2709_2 s_2709_0 s_2709_6
        let s_2709_7: Bits = (Bits::new(
            ((s_2709_2) >> (s_2709_0)).value(),
            u16::try_from(s_2709_6).unwrap(),
        ));
        // D s_2709_8: cast reint s_2709_7 -> u8
        let s_2709_8: u8 = (s_2709_7.value() as u8);
        // D s_2709_9: cast zx s_2709_8 -> bv
        let s_2709_9: Bits = Bits::new(s_2709_8 as u128, 4u16);
        // C s_2709_10: const #13u : u8
        let s_2709_10: u8 = 13;
        // C s_2709_11: cast zx s_2709_10 -> bv
        let s_2709_11: Bits = Bits::new(s_2709_10 as u128, 4u16);
        // D s_2709_12: cmp-eq s_2709_9 s_2709_11
        let s_2709_12: bool = ((s_2709_9) == (s_2709_11));
        // D s_2709_13: write-var gs#405266 <= s_2709_12
        fn_state.gs_405266 = s_2709_12;
        // N s_2709_14: jump b2708
        return block_2708(state, tracer, fn_state);
    }
    fn block_2710<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2710_0: const #28s : i
        let s_2710_0: i128 = 28;
        // C s_2710_1: const #4s : i
        let s_2710_1: i128 = 4;
        // D s_2710_2: read-var u#32608:u32
        let s_2710_2: u32 = fn_state.u_32608;
        // D s_2710_3: cast zx s_2710_2 -> bv
        let s_2710_3: Bits = Bits::new(s_2710_2 as u128, 32u16);
        // D s_2710_4: bit-extract s_2710_3 s_2710_0 s_2710_1
        let s_2710_4: Bits = (Bits::new(
            ((s_2710_3) >> (s_2710_0)).value(),
            u16::try_from(s_2710_1).unwrap(),
        ));
        // D s_2710_5: cast reint s_2710_4 -> u8
        let s_2710_5: u8 = (s_2710_4.value() as u8);
        // D s_2710_6: cast zx s_2710_5 -> bv
        let s_2710_6: Bits = Bits::new(s_2710_5 as u128, 4u16);
        // C s_2710_7: const #15u : u8
        let s_2710_7: u8 = 15;
        // C s_2710_8: cast zx s_2710_7 -> bv
        let s_2710_8: Bits = Bits::new(s_2710_7 as u128, 4u16);
        // D s_2710_9: cmp-ne s_2710_6 s_2710_8
        let s_2710_9: bool = ((s_2710_6) != (s_2710_8));
        // N s_2710_10: branch s_2710_9 b2713 b2711
        if s_2710_9 {
            return block_2713(state, tracer, fn_state);
        } else {
            return block_2711(state, tracer, fn_state);
        };
    }
    fn block_2711<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2711_0: const #0u : u8
        let s_2711_0: bool = false;
        // D s_2711_1: write-var gs#405237 <= s_2711_0
        fn_state.gs_405237 = s_2711_0;
        // N s_2711_2: jump b2712
        return block_2712(state, tracer, fn_state);
    }
    fn block_2712<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2712_0: read-var gs#405237:u8
        let s_2712_0: bool = fn_state.gs_405237;
        // D s_2712_1: write-var gs#405238 <= s_2712_0
        fn_state.gs_405238 = s_2712_0;
        // N s_2712_2: jump b563
        return block_563(state, tracer, fn_state);
    }
    fn block_2713<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2713_0: const #2971s : i
        let s_2713_0: i128 = 2971;
        // C s_2713_1: const #14696u : u32
        let s_2713_1: u32 = 14696;
        // D s_2713_2: read-reg s_2713_1:i
        let s_2713_2: i128 = {
            let value = state.read_register::<i128>(s_2713_1 as isize);
            tracer.read_register(s_2713_1 as isize, value);
            value
        };
        // D s_2713_3: cmp-lt s_2713_2 s_2713_0
        let s_2713_3: bool = ((s_2713_2) < (s_2713_0));
        // D s_2713_4: write-var gs#405237 <= s_2713_3
        fn_state.gs_405237 = s_2713_3;
        // N s_2713_5: jump b2712
        return block_2712(state, tracer, fn_state);
    }
    fn block_2714<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2714_0: const #22s : i
        let s_2714_0: i128 = 22;
        // D s_2714_1: read-var u#32608:u32
        let s_2714_1: u32 = fn_state.u_32608;
        // D s_2714_2: cast zx s_2714_1 -> bv
        let s_2714_2: Bits = Bits::new(s_2714_1 as u128, 32u16);
        // C s_2714_3: const #1s : i64
        let s_2714_3: i64 = 1;
        // C s_2714_4: cast zx s_2714_3 -> i
        let s_2714_4: i128 = (i128::try_from(s_2714_3).unwrap());
        // C s_2714_5: const #0s : i
        let s_2714_5: i128 = 0;
        // C s_2714_6: add s_2714_5 s_2714_4
        let s_2714_6: i128 = (s_2714_5 + s_2714_4);
        // D s_2714_7: bit-extract s_2714_2 s_2714_0 s_2714_6
        let s_2714_7: Bits = (Bits::new(
            ((s_2714_2) >> (s_2714_0)).value(),
            u16::try_from(s_2714_6).unwrap(),
        ));
        // D s_2714_8: cast reint s_2714_7 -> u8
        let s_2714_8: bool = ((s_2714_7.value()) != 0);
        // D s_2714_9: cast zx s_2714_8 -> bv
        let s_2714_9: Bits = Bits::new(s_2714_8 as u128, 1u16);
        // C s_2714_10: const #1u : u8
        let s_2714_10: bool = true;
        // C s_2714_11: cast zx s_2714_10 -> bv
        let s_2714_11: Bits = Bits::new(s_2714_10 as u128, 1u16);
        // D s_2714_12: cmp-eq s_2714_9 s_2714_11
        let s_2714_12: bool = ((s_2714_9) == (s_2714_11));
        // N s_2714_13: branch s_2714_12 b2717 b2715
        if s_2714_12 {
            return block_2717(state, tracer, fn_state);
        } else {
            return block_2715(state, tracer, fn_state);
        };
    }
    fn block_2715<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2715_0: const #0u : u8
        let s_2715_0: bool = false;
        // D s_2715_1: write-var gs#405232 <= s_2715_0
        fn_state.gs_405232 = s_2715_0;
        // N s_2715_2: jump b2716
        return block_2716(state, tracer, fn_state);
    }
    fn block_2716<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2716_0: read-var gs#405232:u8
        let s_2716_0: bool = fn_state.gs_405232;
        // D s_2716_1: write-var gs#405233 <= s_2716_0
        fn_state.gs_405233 = s_2716_0;
        // N s_2716_2: jump b561
        return block_561(state, tracer, fn_state);
    }
    fn block_2717<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2717_0: const #20s : i
        let s_2717_0: i128 = 20;
        // D s_2717_1: read-var u#32608:u32
        let s_2717_1: u32 = fn_state.u_32608;
        // D s_2717_2: cast zx s_2717_1 -> bv
        let s_2717_2: Bits = Bits::new(s_2717_1 as u128, 32u16);
        // C s_2717_3: const #1s : i64
        let s_2717_3: i64 = 1;
        // C s_2717_4: cast zx s_2717_3 -> i
        let s_2717_4: i128 = (i128::try_from(s_2717_3).unwrap());
        // C s_2717_5: const #0s : i
        let s_2717_5: i128 = 0;
        // C s_2717_6: add s_2717_5 s_2717_4
        let s_2717_6: i128 = (s_2717_5 + s_2717_4);
        // D s_2717_7: bit-extract s_2717_2 s_2717_0 s_2717_6
        let s_2717_7: Bits = (Bits::new(
            ((s_2717_2) >> (s_2717_0)).value(),
            u16::try_from(s_2717_6).unwrap(),
        ));
        // D s_2717_8: cast reint s_2717_7 -> u8
        let s_2717_8: bool = ((s_2717_7.value()) != 0);
        // D s_2717_9: cast zx s_2717_8 -> bv
        let s_2717_9: Bits = Bits::new(s_2717_8 as u128, 1u16);
        // C s_2717_10: const #1u : u8
        let s_2717_10: bool = true;
        // C s_2717_11: cast zx s_2717_10 -> bv
        let s_2717_11: Bits = Bits::new(s_2717_10 as u128, 1u16);
        // D s_2717_12: cmp-eq s_2717_9 s_2717_11
        let s_2717_12: bool = ((s_2717_9) == (s_2717_11));
        // N s_2717_13: branch s_2717_12 b2720 b2718
        if s_2717_12 {
            return block_2720(state, tracer, fn_state);
        } else {
            return block_2718(state, tracer, fn_state);
        };
    }
    fn block_2718<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2718_0: const #0u : u8
        let s_2718_0: bool = false;
        // D s_2718_1: write-var gs#405231 <= s_2718_0
        fn_state.gs_405231 = s_2718_0;
        // N s_2718_2: jump b2719
        return block_2719(state, tracer, fn_state);
    }
    fn block_2719<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2719_0: read-var gs#405231:u8
        let s_2719_0: bool = fn_state.gs_405231;
        // D s_2719_1: write-var gs#405232 <= s_2719_0
        fn_state.gs_405232 = s_2719_0;
        // N s_2719_2: jump b2716
        return block_2716(state, tracer, fn_state);
    }
    fn block_2720<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2720_0: const #4s : i
        let s_2720_0: i128 = 4;
        // D s_2720_1: read-var u#32608:u32
        let s_2720_1: u32 = fn_state.u_32608;
        // D s_2720_2: cast zx s_2720_1 -> bv
        let s_2720_2: Bits = Bits::new(s_2720_1 as u128, 32u16);
        // C s_2720_3: const #1s : i64
        let s_2720_3: i64 = 1;
        // C s_2720_4: cast zx s_2720_3 -> i
        let s_2720_4: i128 = (i128::try_from(s_2720_3).unwrap());
        // C s_2720_5: const #3s : i
        let s_2720_5: i128 = 3;
        // C s_2720_6: add s_2720_5 s_2720_4
        let s_2720_6: i128 = (s_2720_5 + s_2720_4);
        // D s_2720_7: bit-extract s_2720_2 s_2720_0 s_2720_6
        let s_2720_7: Bits = (Bits::new(
            ((s_2720_2) >> (s_2720_0)).value(),
            u16::try_from(s_2720_6).unwrap(),
        ));
        // D s_2720_8: cast reint s_2720_7 -> u8
        let s_2720_8: u8 = (s_2720_7.value() as u8);
        // D s_2720_9: cast zx s_2720_8 -> bv
        let s_2720_9: Bits = Bits::new(s_2720_8 as u128, 4u16);
        // C s_2720_10: const #13u : u8
        let s_2720_10: u8 = 13;
        // C s_2720_11: cast zx s_2720_10 -> bv
        let s_2720_11: Bits = Bits::new(s_2720_10 as u128, 4u16);
        // D s_2720_12: cmp-eq s_2720_9 s_2720_11
        let s_2720_12: bool = ((s_2720_9) == (s_2720_11));
        // D s_2720_13: write-var gs#405231 <= s_2720_12
        fn_state.gs_405231 = s_2720_12;
        // N s_2720_14: jump b2719
        return block_2719(state, tracer, fn_state);
    }
    fn block_2721<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2721_0: const #28s : i
        let s_2721_0: i128 = 28;
        // C s_2721_1: const #4s : i
        let s_2721_1: i128 = 4;
        // D s_2721_2: read-var u#32601:u32
        let s_2721_2: u32 = fn_state.u_32601;
        // D s_2721_3: cast zx s_2721_2 -> bv
        let s_2721_3: Bits = Bits::new(s_2721_2 as u128, 32u16);
        // D s_2721_4: bit-extract s_2721_3 s_2721_0 s_2721_1
        let s_2721_4: Bits = (Bits::new(
            ((s_2721_3) >> (s_2721_0)).value(),
            u16::try_from(s_2721_1).unwrap(),
        ));
        // D s_2721_5: cast reint s_2721_4 -> u8
        let s_2721_5: u8 = (s_2721_4.value() as u8);
        // D s_2721_6: cast zx s_2721_5 -> bv
        let s_2721_6: Bits = Bits::new(s_2721_5 as u128, 4u16);
        // C s_2721_7: const #15u : u8
        let s_2721_7: u8 = 15;
        // C s_2721_8: cast zx s_2721_7 -> bv
        let s_2721_8: Bits = Bits::new(s_2721_7 as u128, 4u16);
        // D s_2721_9: cmp-ne s_2721_6 s_2721_8
        let s_2721_9: bool = ((s_2721_6) != (s_2721_8));
        // N s_2721_10: branch s_2721_9 b2724 b2722
        if s_2721_9 {
            return block_2724(state, tracer, fn_state);
        } else {
            return block_2722(state, tracer, fn_state);
        };
    }
    fn block_2722<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2722_0: const #0u : u8
        let s_2722_0: bool = false;
        // D s_2722_1: write-var gs#405197 <= s_2722_0
        fn_state.gs_405197 = s_2722_0;
        // N s_2722_2: jump b2723
        return block_2723(state, tracer, fn_state);
    }
    fn block_2723<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2723_0: read-var gs#405197:u8
        let s_2723_0: bool = fn_state.gs_405197;
        // D s_2723_1: write-var gs#405198 <= s_2723_0
        fn_state.gs_405198 = s_2723_0;
        // N s_2723_2: jump b546
        return block_546(state, tracer, fn_state);
    }
    fn block_2724<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2724_0: const #2958s : i
        let s_2724_0: i128 = 2958;
        // C s_2724_1: const #14696u : u32
        let s_2724_1: u32 = 14696;
        // D s_2724_2: read-reg s_2724_1:i
        let s_2724_2: i128 = {
            let value = state.read_register::<i128>(s_2724_1 as isize);
            tracer.read_register(s_2724_1 as isize, value);
            value
        };
        // D s_2724_3: cmp-lt s_2724_2 s_2724_0
        let s_2724_3: bool = ((s_2724_2) < (s_2724_0));
        // D s_2724_4: write-var gs#405197 <= s_2724_3
        fn_state.gs_405197 = s_2724_3;
        // N s_2724_5: jump b2723
        return block_2723(state, tracer, fn_state);
    }
    fn block_2725<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2725_0: const #20s : i
        let s_2725_0: i128 = 20;
        // D s_2725_1: read-var u#32601:u32
        let s_2725_1: u32 = fn_state.u_32601;
        // D s_2725_2: cast zx s_2725_1 -> bv
        let s_2725_2: Bits = Bits::new(s_2725_1 as u128, 32u16);
        // C s_2725_3: const #1s : i64
        let s_2725_3: i64 = 1;
        // C s_2725_4: cast zx s_2725_3 -> i
        let s_2725_4: i128 = (i128::try_from(s_2725_3).unwrap());
        // C s_2725_5: const #2s : i
        let s_2725_5: i128 = 2;
        // C s_2725_6: add s_2725_5 s_2725_4
        let s_2725_6: i128 = (s_2725_5 + s_2725_4);
        // D s_2725_7: bit-extract s_2725_2 s_2725_0 s_2725_6
        let s_2725_7: Bits = (Bits::new(
            ((s_2725_2) >> (s_2725_0)).value(),
            u16::try_from(s_2725_6).unwrap(),
        ));
        // D s_2725_8: cast reint s_2725_7 -> u8
        let s_2725_8: u8 = (s_2725_7.value() as u8);
        // D s_2725_9: cast zx s_2725_8 -> bv
        let s_2725_9: Bits = Bits::new(s_2725_8 as u128, 3u16);
        // C s_2725_10: const #3u : u8
        let s_2725_10: u8 = 3;
        // C s_2725_11: cast zx s_2725_10 -> bv
        let s_2725_11: Bits = Bits::new(s_2725_10 as u128, 3u16);
        // D s_2725_12: cmp-eq s_2725_9 s_2725_11
        let s_2725_12: bool = ((s_2725_9) == (s_2725_11));
        // N s_2725_13: branch s_2725_12 b2728 b2726
        if s_2725_12 {
            return block_2728(state, tracer, fn_state);
        } else {
            return block_2726(state, tracer, fn_state);
        };
    }
    fn block_2726<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2726_0: const #0u : u8
        let s_2726_0: bool = false;
        // D s_2726_1: write-var gs#405192 <= s_2726_0
        fn_state.gs_405192 = s_2726_0;
        // N s_2726_2: jump b2727
        return block_2727(state, tracer, fn_state);
    }
    fn block_2727<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2727_0: read-var gs#405192:u8
        let s_2727_0: bool = fn_state.gs_405192;
        // D s_2727_1: write-var gs#405193 <= s_2727_0
        fn_state.gs_405193 = s_2727_0;
        // N s_2727_2: jump b544
        return block_544(state, tracer, fn_state);
    }
    fn block_2728<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2728_0: const #4s : i
        let s_2728_0: i128 = 4;
        // D s_2728_1: read-var u#32601:u32
        let s_2728_1: u32 = fn_state.u_32601;
        // D s_2728_2: cast zx s_2728_1 -> bv
        let s_2728_2: Bits = Bits::new(s_2728_1 as u128, 32u16);
        // C s_2728_3: const #1s : i64
        let s_2728_3: i64 = 1;
        // C s_2728_4: cast zx s_2728_3 -> i
        let s_2728_4: i128 = (i128::try_from(s_2728_3).unwrap());
        // C s_2728_5: const #7s : i
        let s_2728_5: i128 = 7;
        // C s_2728_6: add s_2728_5 s_2728_4
        let s_2728_6: i128 = (s_2728_5 + s_2728_4);
        // D s_2728_7: bit-extract s_2728_2 s_2728_0 s_2728_6
        let s_2728_7: Bits = (Bits::new(
            ((s_2728_2) >> (s_2728_0)).value(),
            u16::try_from(s_2728_6).unwrap(),
        ));
        // D s_2728_8: cast reint s_2728_7 -> u8
        let s_2728_8: u8 = (s_2728_7.value() as u8);
        // D s_2728_9: cast zx s_2728_8 -> bv
        let s_2728_9: Bits = Bits::new(s_2728_8 as u128, 8u16);
        // C s_2728_10: const #11u : u8
        let s_2728_10: u8 = 11;
        // C s_2728_11: cast zx s_2728_10 -> bv
        let s_2728_11: Bits = Bits::new(s_2728_10 as u128, 8u16);
        // D s_2728_12: cmp-eq s_2728_9 s_2728_11
        let s_2728_12: bool = ((s_2728_9) == (s_2728_11));
        // D s_2728_13: write-var gs#405192 <= s_2728_12
        fn_state.gs_405192 = s_2728_12;
        // N s_2728_14: jump b2727
        return block_2727(state, tracer, fn_state);
    }
    fn block_2729<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2729_0: const #28s : i
        let s_2729_0: i128 = 28;
        // C s_2729_1: const #4s : i
        let s_2729_1: i128 = 4;
        // D s_2729_2: read-var u#32593:u32
        let s_2729_2: u32 = fn_state.u_32593;
        // D s_2729_3: cast zx s_2729_2 -> bv
        let s_2729_3: Bits = Bits::new(s_2729_2 as u128, 32u16);
        // D s_2729_4: bit-extract s_2729_3 s_2729_0 s_2729_1
        let s_2729_4: Bits = (Bits::new(
            ((s_2729_3) >> (s_2729_0)).value(),
            u16::try_from(s_2729_1).unwrap(),
        ));
        // D s_2729_5: cast reint s_2729_4 -> u8
        let s_2729_5: u8 = (s_2729_4.value() as u8);
        // D s_2729_6: cast zx s_2729_5 -> bv
        let s_2729_6: Bits = Bits::new(s_2729_5 as u128, 4u16);
        // C s_2729_7: const #15u : u8
        let s_2729_7: u8 = 15;
        // C s_2729_8: cast zx s_2729_7 -> bv
        let s_2729_8: Bits = Bits::new(s_2729_7 as u128, 4u16);
        // D s_2729_9: cmp-ne s_2729_6 s_2729_8
        let s_2729_9: bool = ((s_2729_6) != (s_2729_8));
        // N s_2729_10: branch s_2729_9 b2732 b2730
        if s_2729_9 {
            return block_2732(state, tracer, fn_state);
        } else {
            return block_2730(state, tracer, fn_state);
        };
    }
    fn block_2730<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2730_0: const #0u : u8
        let s_2730_0: bool = false;
        // D s_2730_1: write-var gs#405169 <= s_2730_0
        fn_state.gs_405169 = s_2730_0;
        // N s_2730_2: jump b2731
        return block_2731(state, tracer, fn_state);
    }
    fn block_2731<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2731_0: read-var gs#405169:u8
        let s_2731_0: bool = fn_state.gs_405169;
        // D s_2731_1: write-var gs#405170 <= s_2731_0
        fn_state.gs_405170 = s_2731_0;
        // N s_2731_2: jump b540
        return block_540(state, tracer, fn_state);
    }
    fn block_2732<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2732_0: const #2957s : i
        let s_2732_0: i128 = 2957;
        // C s_2732_1: const #14696u : u32
        let s_2732_1: u32 = 14696;
        // D s_2732_2: read-reg s_2732_1:i
        let s_2732_2: i128 = {
            let value = state.read_register::<i128>(s_2732_1 as isize);
            tracer.read_register(s_2732_1 as isize, value);
            value
        };
        // D s_2732_3: cmp-lt s_2732_2 s_2732_0
        let s_2732_3: bool = ((s_2732_2) < (s_2732_0));
        // D s_2732_4: write-var gs#405169 <= s_2732_3
        fn_state.gs_405169 = s_2732_3;
        // N s_2732_5: jump b2731
        return block_2731(state, tracer, fn_state);
    }
    fn block_2733<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2733_0: const #20s : i
        let s_2733_0: i128 = 20;
        // D s_2733_1: read-var u#32593:u32
        let s_2733_1: u32 = fn_state.u_32593;
        // D s_2733_2: cast zx s_2733_1 -> bv
        let s_2733_2: Bits = Bits::new(s_2733_1 as u128, 32u16);
        // C s_2733_3: const #1s : i64
        let s_2733_3: i64 = 1;
        // C s_2733_4: cast zx s_2733_3 -> i
        let s_2733_4: i128 = (i128::try_from(s_2733_3).unwrap());
        // C s_2733_5: const #2s : i
        let s_2733_5: i128 = 2;
        // C s_2733_6: add s_2733_5 s_2733_4
        let s_2733_6: i128 = (s_2733_5 + s_2733_4);
        // D s_2733_7: bit-extract s_2733_2 s_2733_0 s_2733_6
        let s_2733_7: Bits = (Bits::new(
            ((s_2733_2) >> (s_2733_0)).value(),
            u16::try_from(s_2733_6).unwrap(),
        ));
        // D s_2733_8: cast reint s_2733_7 -> u8
        let s_2733_8: u8 = (s_2733_7.value() as u8);
        // D s_2733_9: cast zx s_2733_8 -> bv
        let s_2733_9: Bits = Bits::new(s_2733_8 as u128, 3u16);
        // C s_2733_10: const #7u : u8
        let s_2733_10: u8 = 7;
        // C s_2733_11: cast zx s_2733_10 -> bv
        let s_2733_11: Bits = Bits::new(s_2733_10 as u128, 3u16);
        // D s_2733_12: cmp-eq s_2733_9 s_2733_11
        let s_2733_12: bool = ((s_2733_9) == (s_2733_11));
        // N s_2733_13: branch s_2733_12 b2736 b2734
        if s_2733_12 {
            return block_2736(state, tracer, fn_state);
        } else {
            return block_2734(state, tracer, fn_state);
        };
    }
    fn block_2734<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2734_0: const #0u : u8
        let s_2734_0: bool = false;
        // D s_2734_1: write-var gs#405164 <= s_2734_0
        fn_state.gs_405164 = s_2734_0;
        // N s_2734_2: jump b2735
        return block_2735(state, tracer, fn_state);
    }
    fn block_2735<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2735_0: read-var gs#405164:u8
        let s_2735_0: bool = fn_state.gs_405164;
        // D s_2735_1: write-var gs#405165 <= s_2735_0
        fn_state.gs_405165 = s_2735_0;
        // N s_2735_2: jump b538
        return block_538(state, tracer, fn_state);
    }
    fn block_2736<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2736_0: const #4s : i
        let s_2736_0: i128 = 4;
        // D s_2736_1: read-var u#32593:u32
        let s_2736_1: u32 = fn_state.u_32593;
        // D s_2736_2: cast zx s_2736_1 -> bv
        let s_2736_2: Bits = Bits::new(s_2736_1 as u128, 32u16);
        // C s_2736_3: const #1s : i64
        let s_2736_3: i64 = 1;
        // C s_2736_4: cast zx s_2736_3 -> i
        let s_2736_4: i128 = (i128::try_from(s_2736_3).unwrap());
        // C s_2736_5: const #3s : i
        let s_2736_5: i128 = 3;
        // C s_2736_6: add s_2736_5 s_2736_4
        let s_2736_6: i128 = (s_2736_5 + s_2736_4);
        // D s_2736_7: bit-extract s_2736_2 s_2736_0 s_2736_6
        let s_2736_7: Bits = (Bits::new(
            ((s_2736_2) >> (s_2736_0)).value(),
            u16::try_from(s_2736_6).unwrap(),
        ));
        // D s_2736_8: cast reint s_2736_7 -> u8
        let s_2736_8: u8 = (s_2736_7.value() as u8);
        // D s_2736_9: cast zx s_2736_8 -> bv
        let s_2736_9: Bits = Bits::new(s_2736_8 as u128, 4u16);
        // C s_2736_10: const #11u : u8
        let s_2736_10: u8 = 11;
        // C s_2736_11: cast zx s_2736_10 -> bv
        let s_2736_11: Bits = Bits::new(s_2736_10 as u128, 4u16);
        // D s_2736_12: cmp-eq s_2736_9 s_2736_11
        let s_2736_12: bool = ((s_2736_9) == (s_2736_11));
        // D s_2736_13: write-var gs#405164 <= s_2736_12
        fn_state.gs_405164 = s_2736_12;
        // N s_2736_14: jump b2735
        return block_2735(state, tracer, fn_state);
    }
    fn block_2737<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2737_0: const #28s : i
        let s_2737_0: i128 = 28;
        // C s_2737_1: const #4s : i
        let s_2737_1: i128 = 4;
        // D s_2737_2: read-var u#32584:u32
        let s_2737_2: u32 = fn_state.u_32584;
        // D s_2737_3: cast zx s_2737_2 -> bv
        let s_2737_3: Bits = Bits::new(s_2737_2 as u128, 32u16);
        // D s_2737_4: bit-extract s_2737_3 s_2737_0 s_2737_1
        let s_2737_4: Bits = (Bits::new(
            ((s_2737_3) >> (s_2737_0)).value(),
            u16::try_from(s_2737_1).unwrap(),
        ));
        // D s_2737_5: cast reint s_2737_4 -> u8
        let s_2737_5: u8 = (s_2737_4.value() as u8);
        // D s_2737_6: cast zx s_2737_5 -> bv
        let s_2737_6: Bits = Bits::new(s_2737_5 as u128, 4u16);
        // C s_2737_7: const #15u : u8
        let s_2737_7: u8 = 15;
        // C s_2737_8: cast zx s_2737_7 -> bv
        let s_2737_8: Bits = Bits::new(s_2737_7 as u128, 4u16);
        // D s_2737_9: cmp-ne s_2737_6 s_2737_8
        let s_2737_9: bool = ((s_2737_6) != (s_2737_8));
        // N s_2737_10: branch s_2737_9 b2740 b2738
        if s_2737_9 {
            return block_2740(state, tracer, fn_state);
        } else {
            return block_2738(state, tracer, fn_state);
        };
    }
    fn block_2738<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2738_0: const #0u : u8
        let s_2738_0: bool = false;
        // D s_2738_1: write-var gs#405128 <= s_2738_0
        fn_state.gs_405128 = s_2738_0;
        // N s_2738_2: jump b2739
        return block_2739(state, tracer, fn_state);
    }
    fn block_2739<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2739_0: read-var gs#405128:u8
        let s_2739_0: bool = fn_state.gs_405128;
        // D s_2739_1: write-var gs#405129 <= s_2739_0
        fn_state.gs_405129 = s_2739_0;
        // N s_2739_2: jump b523
        return block_523(state, tracer, fn_state);
    }
    fn block_2740<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2740_0: const #2954s : i
        let s_2740_0: i128 = 2954;
        // C s_2740_1: const #14696u : u32
        let s_2740_1: u32 = 14696;
        // D s_2740_2: read-reg s_2740_1:i
        let s_2740_2: i128 = {
            let value = state.read_register::<i128>(s_2740_1 as isize);
            tracer.read_register(s_2740_1 as isize, value);
            value
        };
        // D s_2740_3: cmp-lt s_2740_2 s_2740_0
        let s_2740_3: bool = ((s_2740_2) < (s_2740_0));
        // D s_2740_4: write-var gs#405128 <= s_2740_3
        fn_state.gs_405128 = s_2740_3;
        // N s_2740_5: jump b2739
        return block_2739(state, tracer, fn_state);
    }
    fn block_2741<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2741_0: const #22s : i
        let s_2741_0: i128 = 22;
        // D s_2741_1: read-var u#32584:u32
        let s_2741_1: u32 = fn_state.u_32584;
        // D s_2741_2: cast zx s_2741_1 -> bv
        let s_2741_2: Bits = Bits::new(s_2741_1 as u128, 32u16);
        // C s_2741_3: const #1s : i64
        let s_2741_3: i64 = 1;
        // C s_2741_4: cast zx s_2741_3 -> i
        let s_2741_4: i128 = (i128::try_from(s_2741_3).unwrap());
        // C s_2741_5: const #0s : i
        let s_2741_5: i128 = 0;
        // C s_2741_6: add s_2741_5 s_2741_4
        let s_2741_6: i128 = (s_2741_5 + s_2741_4);
        // D s_2741_7: bit-extract s_2741_2 s_2741_0 s_2741_6
        let s_2741_7: Bits = (Bits::new(
            ((s_2741_2) >> (s_2741_0)).value(),
            u16::try_from(s_2741_6).unwrap(),
        ));
        // D s_2741_8: cast reint s_2741_7 -> u8
        let s_2741_8: bool = ((s_2741_7.value()) != 0);
        // D s_2741_9: cast zx s_2741_8 -> bv
        let s_2741_9: Bits = Bits::new(s_2741_8 as u128, 1u16);
        // C s_2741_10: const #0u : u8
        let s_2741_10: bool = false;
        // C s_2741_11: cast zx s_2741_10 -> bv
        let s_2741_11: Bits = Bits::new(s_2741_10 as u128, 1u16);
        // D s_2741_12: cmp-eq s_2741_9 s_2741_11
        let s_2741_12: bool = ((s_2741_9) == (s_2741_11));
        // N s_2741_13: branch s_2741_12 b2744 b2742
        if s_2741_12 {
            return block_2744(state, tracer, fn_state);
        } else {
            return block_2742(state, tracer, fn_state);
        };
    }
    fn block_2742<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2742_0: const #0u : u8
        let s_2742_0: bool = false;
        // D s_2742_1: write-var gs#405123 <= s_2742_0
        fn_state.gs_405123 = s_2742_0;
        // N s_2742_2: jump b2743
        return block_2743(state, tracer, fn_state);
    }
    fn block_2743<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2743_0: read-var gs#405123:u8
        let s_2743_0: bool = fn_state.gs_405123;
        // D s_2743_1: write-var gs#405124 <= s_2743_0
        fn_state.gs_405124 = s_2743_0;
        // N s_2743_2: jump b521
        return block_521(state, tracer, fn_state);
    }
    fn block_2744<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2744_0: const #20s : i
        let s_2744_0: i128 = 20;
        // D s_2744_1: read-var u#32584:u32
        let s_2744_1: u32 = fn_state.u_32584;
        // D s_2744_2: cast zx s_2744_1 -> bv
        let s_2744_2: Bits = Bits::new(s_2744_1 as u128, 32u16);
        // C s_2744_3: const #1s : i64
        let s_2744_3: i64 = 1;
        // C s_2744_4: cast zx s_2744_3 -> i
        let s_2744_4: i128 = (i128::try_from(s_2744_3).unwrap());
        // C s_2744_5: const #0s : i
        let s_2744_5: i128 = 0;
        // C s_2744_6: add s_2744_5 s_2744_4
        let s_2744_6: i128 = (s_2744_5 + s_2744_4);
        // D s_2744_7: bit-extract s_2744_2 s_2744_0 s_2744_6
        let s_2744_7: Bits = (Bits::new(
            ((s_2744_2) >> (s_2744_0)).value(),
            u16::try_from(s_2744_6).unwrap(),
        ));
        // D s_2744_8: cast reint s_2744_7 -> u8
        let s_2744_8: bool = ((s_2744_7.value()) != 0);
        // D s_2744_9: cast zx s_2744_8 -> bv
        let s_2744_9: Bits = Bits::new(s_2744_8 as u128, 1u16);
        // C s_2744_10: const #1u : u8
        let s_2744_10: bool = true;
        // C s_2744_11: cast zx s_2744_10 -> bv
        let s_2744_11: Bits = Bits::new(s_2744_10 as u128, 1u16);
        // D s_2744_12: cmp-eq s_2744_9 s_2744_11
        let s_2744_12: bool = ((s_2744_9) == (s_2744_11));
        // N s_2744_13: branch s_2744_12 b2747 b2745
        if s_2744_12 {
            return block_2747(state, tracer, fn_state);
        } else {
            return block_2745(state, tracer, fn_state);
        };
    }
    fn block_2745<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2745_0: const #0u : u8
        let s_2745_0: bool = false;
        // D s_2745_1: write-var gs#405122 <= s_2745_0
        fn_state.gs_405122 = s_2745_0;
        // N s_2745_2: jump b2746
        return block_2746(state, tracer, fn_state);
    }
    fn block_2746<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2746_0: read-var gs#405122:u8
        let s_2746_0: bool = fn_state.gs_405122;
        // D s_2746_1: write-var gs#405123 <= s_2746_0
        fn_state.gs_405123 = s_2746_0;
        // N s_2746_2: jump b2743
        return block_2743(state, tracer, fn_state);
    }
    fn block_2747<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2747_0: const #4s : i
        let s_2747_0: i128 = 4;
        // D s_2747_1: read-var u#32584:u32
        let s_2747_1: u32 = fn_state.u_32584;
        // D s_2747_2: cast zx s_2747_1 -> bv
        let s_2747_2: Bits = Bits::new(s_2747_1 as u128, 32u16);
        // C s_2747_3: const #1s : i64
        let s_2747_3: i64 = 1;
        // C s_2747_4: cast zx s_2747_3 -> i
        let s_2747_4: i128 = (i128::try_from(s_2747_3).unwrap());
        // C s_2747_5: const #7s : i
        let s_2747_5: i128 = 7;
        // C s_2747_6: add s_2747_5 s_2747_4
        let s_2747_6: i128 = (s_2747_5 + s_2747_4);
        // D s_2747_7: bit-extract s_2747_2 s_2747_0 s_2747_6
        let s_2747_7: Bits = (Bits::new(
            ((s_2747_2) >> (s_2747_0)).value(),
            u16::try_from(s_2747_6).unwrap(),
        ));
        // D s_2747_8: cast reint s_2747_7 -> u8
        let s_2747_8: u8 = (s_2747_7.value() as u8);
        // D s_2747_9: cast zx s_2747_8 -> bv
        let s_2747_9: Bits = Bits::new(s_2747_8 as u128, 8u16);
        // C s_2747_10: const #11u : u8
        let s_2747_10: u8 = 11;
        // C s_2747_11: cast zx s_2747_10 -> bv
        let s_2747_11: Bits = Bits::new(s_2747_10 as u128, 8u16);
        // D s_2747_12: cmp-eq s_2747_9 s_2747_11
        let s_2747_12: bool = ((s_2747_9) == (s_2747_11));
        // D s_2747_13: write-var gs#405122 <= s_2747_12
        fn_state.gs_405122 = s_2747_12;
        // N s_2747_14: jump b2746
        return block_2746(state, tracer, fn_state);
    }
    fn block_2748<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2748_0: const #28s : i
        let s_2748_0: i128 = 28;
        // C s_2748_1: const #4s : i
        let s_2748_1: i128 = 4;
        // D s_2748_2: read-var u#32575:u32
        let s_2748_2: u32 = fn_state.u_32575;
        // D s_2748_3: cast zx s_2748_2 -> bv
        let s_2748_3: Bits = Bits::new(s_2748_2 as u128, 32u16);
        // D s_2748_4: bit-extract s_2748_3 s_2748_0 s_2748_1
        let s_2748_4: Bits = (Bits::new(
            ((s_2748_3) >> (s_2748_0)).value(),
            u16::try_from(s_2748_1).unwrap(),
        ));
        // D s_2748_5: cast reint s_2748_4 -> u8
        let s_2748_5: u8 = (s_2748_4.value() as u8);
        // D s_2748_6: cast zx s_2748_5 -> bv
        let s_2748_6: Bits = Bits::new(s_2748_5 as u128, 4u16);
        // C s_2748_7: const #15u : u8
        let s_2748_7: u8 = 15;
        // C s_2748_8: cast zx s_2748_7 -> bv
        let s_2748_8: Bits = Bits::new(s_2748_7 as u128, 4u16);
        // D s_2748_9: cmp-ne s_2748_6 s_2748_8
        let s_2748_9: bool = ((s_2748_6) != (s_2748_8));
        // N s_2748_10: branch s_2748_9 b2751 b2749
        if s_2748_9 {
            return block_2751(state, tracer, fn_state);
        } else {
            return block_2749(state, tracer, fn_state);
        };
    }
    fn block_2749<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2749_0: const #0u : u8
        let s_2749_0: bool = false;
        // D s_2749_1: write-var gs#405095 <= s_2749_0
        fn_state.gs_405095 = s_2749_0;
        // N s_2749_2: jump b2750
        return block_2750(state, tracer, fn_state);
    }
    fn block_2750<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2750_0: read-var gs#405095:u8
        let s_2750_0: bool = fn_state.gs_405095;
        // D s_2750_1: write-var gs#405096 <= s_2750_0
        fn_state.gs_405096 = s_2750_0;
        // N s_2750_2: jump b517
        return block_517(state, tracer, fn_state);
    }
    fn block_2751<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2751_0: const #2952s : i
        let s_2751_0: i128 = 2952;
        // C s_2751_1: const #14696u : u32
        let s_2751_1: u32 = 14696;
        // D s_2751_2: read-reg s_2751_1:i
        let s_2751_2: i128 = {
            let value = state.read_register::<i128>(s_2751_1 as isize);
            tracer.read_register(s_2751_1 as isize, value);
            value
        };
        // D s_2751_3: cmp-lt s_2751_2 s_2751_0
        let s_2751_3: bool = ((s_2751_2) < (s_2751_0));
        // D s_2751_4: write-var gs#405095 <= s_2751_3
        fn_state.gs_405095 = s_2751_3;
        // N s_2751_5: jump b2750
        return block_2750(state, tracer, fn_state);
    }
    fn block_2752<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2752_0: const #22s : i
        let s_2752_0: i128 = 22;
        // D s_2752_1: read-var u#32575:u32
        let s_2752_1: u32 = fn_state.u_32575;
        // D s_2752_2: cast zx s_2752_1 -> bv
        let s_2752_2: Bits = Bits::new(s_2752_1 as u128, 32u16);
        // C s_2752_3: const #1s : i64
        let s_2752_3: i64 = 1;
        // C s_2752_4: cast zx s_2752_3 -> i
        let s_2752_4: i128 = (i128::try_from(s_2752_3).unwrap());
        // C s_2752_5: const #0s : i
        let s_2752_5: i128 = 0;
        // C s_2752_6: add s_2752_5 s_2752_4
        let s_2752_6: i128 = (s_2752_5 + s_2752_4);
        // D s_2752_7: bit-extract s_2752_2 s_2752_0 s_2752_6
        let s_2752_7: Bits = (Bits::new(
            ((s_2752_2) >> (s_2752_0)).value(),
            u16::try_from(s_2752_6).unwrap(),
        ));
        // D s_2752_8: cast reint s_2752_7 -> u8
        let s_2752_8: bool = ((s_2752_7.value()) != 0);
        // D s_2752_9: cast zx s_2752_8 -> bv
        let s_2752_9: Bits = Bits::new(s_2752_8 as u128, 1u16);
        // C s_2752_10: const #1u : u8
        let s_2752_10: bool = true;
        // C s_2752_11: cast zx s_2752_10 -> bv
        let s_2752_11: Bits = Bits::new(s_2752_10 as u128, 1u16);
        // D s_2752_12: cmp-eq s_2752_9 s_2752_11
        let s_2752_12: bool = ((s_2752_9) == (s_2752_11));
        // N s_2752_13: branch s_2752_12 b2755 b2753
        if s_2752_12 {
            return block_2755(state, tracer, fn_state);
        } else {
            return block_2753(state, tracer, fn_state);
        };
    }
    fn block_2753<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2753_0: const #0u : u8
        let s_2753_0: bool = false;
        // D s_2753_1: write-var gs#405090 <= s_2753_0
        fn_state.gs_405090 = s_2753_0;
        // N s_2753_2: jump b2754
        return block_2754(state, tracer, fn_state);
    }
    fn block_2754<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2754_0: read-var gs#405090:u8
        let s_2754_0: bool = fn_state.gs_405090;
        // D s_2754_1: write-var gs#405091 <= s_2754_0
        fn_state.gs_405091 = s_2754_0;
        // N s_2754_2: jump b515
        return block_515(state, tracer, fn_state);
    }
    fn block_2755<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2755_0: const #16s : i
        let s_2755_0: i128 = 16;
        // D s_2755_1: read-var u#32575:u32
        let s_2755_1: u32 = fn_state.u_32575;
        // D s_2755_2: cast zx s_2755_1 -> bv
        let s_2755_2: Bits = Bits::new(s_2755_1 as u128, 32u16);
        // C s_2755_3: const #1s : i64
        let s_2755_3: i64 = 1;
        // C s_2755_4: cast zx s_2755_3 -> i
        let s_2755_4: i128 = (i128::try_from(s_2755_3).unwrap());
        // C s_2755_5: const #4s : i
        let s_2755_5: i128 = 4;
        // C s_2755_6: add s_2755_5 s_2755_4
        let s_2755_6: i128 = (s_2755_5 + s_2755_4);
        // D s_2755_7: bit-extract s_2755_2 s_2755_0 s_2755_6
        let s_2755_7: Bits = (Bits::new(
            ((s_2755_2) >> (s_2755_0)).value(),
            u16::try_from(s_2755_6).unwrap(),
        ));
        // D s_2755_8: cast reint s_2755_7 -> u8
        let s_2755_8: u8 = (s_2755_7.value() as u8);
        // D s_2755_9: cast zx s_2755_8 -> bv
        let s_2755_9: Bits = Bits::new(s_2755_8 as u128, 5u16);
        // C s_2755_10: const #31u : u8
        let s_2755_10: u8 = 31;
        // C s_2755_11: cast zx s_2755_10 -> bv
        let s_2755_11: Bits = Bits::new(s_2755_10 as u128, 5u16);
        // D s_2755_12: cmp-eq s_2755_9 s_2755_11
        let s_2755_12: bool = ((s_2755_9) == (s_2755_11));
        // N s_2755_13: branch s_2755_12 b2758 b2756
        if s_2755_12 {
            return block_2758(state, tracer, fn_state);
        } else {
            return block_2756(state, tracer, fn_state);
        };
    }
    fn block_2756<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2756_0: const #0u : u8
        let s_2756_0: bool = false;
        // D s_2756_1: write-var gs#405089 <= s_2756_0
        fn_state.gs_405089 = s_2756_0;
        // N s_2756_2: jump b2757
        return block_2757(state, tracer, fn_state);
    }
    fn block_2757<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2757_0: read-var gs#405089:u8
        let s_2757_0: bool = fn_state.gs_405089;
        // D s_2757_1: write-var gs#405090 <= s_2757_0
        fn_state.gs_405090 = s_2757_0;
        // N s_2757_2: jump b2754
        return block_2754(state, tracer, fn_state);
    }
    fn block_2758<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2758_0: const #4s : i
        let s_2758_0: i128 = 4;
        // D s_2758_1: read-var u#32575:u32
        let s_2758_1: u32 = fn_state.u_32575;
        // D s_2758_2: cast zx s_2758_1 -> bv
        let s_2758_2: Bits = Bits::new(s_2758_1 as u128, 32u16);
        // C s_2758_3: const #1s : i64
        let s_2758_3: i64 = 1;
        // C s_2758_4: cast zx s_2758_3 -> i
        let s_2758_4: i128 = (i128::try_from(s_2758_3).unwrap());
        // C s_2758_5: const #3s : i
        let s_2758_5: i128 = 3;
        // C s_2758_6: add s_2758_5 s_2758_4
        let s_2758_6: i128 = (s_2758_5 + s_2758_4);
        // D s_2758_7: bit-extract s_2758_2 s_2758_0 s_2758_6
        let s_2758_7: Bits = (Bits::new(
            ((s_2758_2) >> (s_2758_0)).value(),
            u16::try_from(s_2758_6).unwrap(),
        ));
        // D s_2758_8: cast reint s_2758_7 -> u8
        let s_2758_8: u8 = (s_2758_7.value() as u8);
        // D s_2758_9: cast zx s_2758_8 -> bv
        let s_2758_9: Bits = Bits::new(s_2758_8 as u128, 4u16);
        // C s_2758_10: const #11u : u8
        let s_2758_10: u8 = 11;
        // C s_2758_11: cast zx s_2758_10 -> bv
        let s_2758_11: Bits = Bits::new(s_2758_10 as u128, 4u16);
        // D s_2758_12: cmp-eq s_2758_9 s_2758_11
        let s_2758_12: bool = ((s_2758_9) == (s_2758_11));
        // D s_2758_13: write-var gs#405089 <= s_2758_12
        fn_state.gs_405089 = s_2758_12;
        // N s_2758_14: jump b2757
        return block_2757(state, tracer, fn_state);
    }
    fn block_2759<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2759_0: const #28s : i
        let s_2759_0: i128 = 28;
        // C s_2759_1: const #4s : i
        let s_2759_1: i128 = 4;
        // D s_2759_2: read-var u#32565:u32
        let s_2759_2: u32 = fn_state.u_32565;
        // D s_2759_3: cast zx s_2759_2 -> bv
        let s_2759_3: Bits = Bits::new(s_2759_2 as u128, 32u16);
        // D s_2759_4: bit-extract s_2759_3 s_2759_0 s_2759_1
        let s_2759_4: Bits = (Bits::new(
            ((s_2759_3) >> (s_2759_0)).value(),
            u16::try_from(s_2759_1).unwrap(),
        ));
        // D s_2759_5: cast reint s_2759_4 -> u8
        let s_2759_5: u8 = (s_2759_4.value() as u8);
        // D s_2759_6: cast zx s_2759_5 -> bv
        let s_2759_6: Bits = Bits::new(s_2759_5 as u128, 4u16);
        // C s_2759_7: const #15u : u8
        let s_2759_7: u8 = 15;
        // C s_2759_8: cast zx s_2759_7 -> bv
        let s_2759_8: Bits = Bits::new(s_2759_7 as u128, 4u16);
        // D s_2759_9: cmp-ne s_2759_6 s_2759_8
        let s_2759_9: bool = ((s_2759_6) != (s_2759_8));
        // N s_2759_10: branch s_2759_9 b2762 b2760
        if s_2759_9 {
            return block_2762(state, tracer, fn_state);
        } else {
            return block_2760(state, tracer, fn_state);
        };
    }
    fn block_2760<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2760_0: const #0u : u8
        let s_2760_0: bool = false;
        // D s_2760_1: write-var gs#405060 <= s_2760_0
        fn_state.gs_405060 = s_2760_0;
        // N s_2760_2: jump b2761
        return block_2761(state, tracer, fn_state);
    }
    fn block_2761<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2761_0: read-var gs#405060:u8
        let s_2761_0: bool = fn_state.gs_405060;
        // D s_2761_1: write-var gs#405061 <= s_2761_0
        fn_state.gs_405061 = s_2761_0;
        // N s_2761_2: jump b511
        return block_511(state, tracer, fn_state);
    }
    fn block_2762<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2762_0: const #2948s : i
        let s_2762_0: i128 = 2948;
        // C s_2762_1: const #14696u : u32
        let s_2762_1: u32 = 14696;
        // D s_2762_2: read-reg s_2762_1:i
        let s_2762_2: i128 = {
            let value = state.read_register::<i128>(s_2762_1 as isize);
            tracer.read_register(s_2762_1 as isize, value);
            value
        };
        // D s_2762_3: cmp-lt s_2762_2 s_2762_0
        let s_2762_3: bool = ((s_2762_2) < (s_2762_0));
        // D s_2762_4: write-var gs#405060 <= s_2762_3
        fn_state.gs_405060 = s_2762_3;
        // N s_2762_5: jump b2761
        return block_2761(state, tracer, fn_state);
    }
    fn block_2763<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2763_0: const #22s : i
        let s_2763_0: i128 = 22;
        // D s_2763_1: read-var u#32565:u32
        let s_2763_1: u32 = fn_state.u_32565;
        // D s_2763_2: cast zx s_2763_1 -> bv
        let s_2763_2: Bits = Bits::new(s_2763_1 as u128, 32u16);
        // C s_2763_3: const #1s : i64
        let s_2763_3: i64 = 1;
        // C s_2763_4: cast zx s_2763_3 -> i
        let s_2763_4: i128 = (i128::try_from(s_2763_3).unwrap());
        // C s_2763_5: const #0s : i
        let s_2763_5: i128 = 0;
        // C s_2763_6: add s_2763_5 s_2763_4
        let s_2763_6: i128 = (s_2763_5 + s_2763_4);
        // D s_2763_7: bit-extract s_2763_2 s_2763_0 s_2763_6
        let s_2763_7: Bits = (Bits::new(
            ((s_2763_2) >> (s_2763_0)).value(),
            u16::try_from(s_2763_6).unwrap(),
        ));
        // D s_2763_8: cast reint s_2763_7 -> u8
        let s_2763_8: bool = ((s_2763_7.value()) != 0);
        // D s_2763_9: cast zx s_2763_8 -> bv
        let s_2763_9: Bits = Bits::new(s_2763_8 as u128, 1u16);
        // C s_2763_10: const #1u : u8
        let s_2763_10: bool = true;
        // C s_2763_11: cast zx s_2763_10 -> bv
        let s_2763_11: Bits = Bits::new(s_2763_10 as u128, 1u16);
        // D s_2763_12: cmp-eq s_2763_9 s_2763_11
        let s_2763_12: bool = ((s_2763_9) == (s_2763_11));
        // N s_2763_13: branch s_2763_12 b2766 b2764
        if s_2763_12 {
            return block_2766(state, tracer, fn_state);
        } else {
            return block_2764(state, tracer, fn_state);
        };
    }
    fn block_2764<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2764_0: const #0u : u8
        let s_2764_0: bool = false;
        // D s_2764_1: write-var gs#405055 <= s_2764_0
        fn_state.gs_405055 = s_2764_0;
        // N s_2764_2: jump b2765
        return block_2765(state, tracer, fn_state);
    }
    fn block_2765<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2765_0: read-var gs#405055:u8
        let s_2765_0: bool = fn_state.gs_405055;
        // D s_2765_1: write-var gs#405056 <= s_2765_0
        fn_state.gs_405056 = s_2765_0;
        // N s_2765_2: jump b509
        return block_509(state, tracer, fn_state);
    }
    fn block_2766<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2766_0: const #20s : i
        let s_2766_0: i128 = 20;
        // D s_2766_1: read-var u#32565:u32
        let s_2766_1: u32 = fn_state.u_32565;
        // D s_2766_2: cast zx s_2766_1 -> bv
        let s_2766_2: Bits = Bits::new(s_2766_1 as u128, 32u16);
        // C s_2766_3: const #1s : i64
        let s_2766_3: i64 = 1;
        // C s_2766_4: cast zx s_2766_3 -> i
        let s_2766_4: i128 = (i128::try_from(s_2766_3).unwrap());
        // C s_2766_5: const #0s : i
        let s_2766_5: i128 = 0;
        // C s_2766_6: add s_2766_5 s_2766_4
        let s_2766_6: i128 = (s_2766_5 + s_2766_4);
        // D s_2766_7: bit-extract s_2766_2 s_2766_0 s_2766_6
        let s_2766_7: Bits = (Bits::new(
            ((s_2766_2) >> (s_2766_0)).value(),
            u16::try_from(s_2766_6).unwrap(),
        ));
        // D s_2766_8: cast reint s_2766_7 -> u8
        let s_2766_8: bool = ((s_2766_7.value()) != 0);
        // D s_2766_9: cast zx s_2766_8 -> bv
        let s_2766_9: Bits = Bits::new(s_2766_8 as u128, 1u16);
        // C s_2766_10: const #1u : u8
        let s_2766_10: bool = true;
        // C s_2766_11: cast zx s_2766_10 -> bv
        let s_2766_11: Bits = Bits::new(s_2766_10 as u128, 1u16);
        // D s_2766_12: cmp-eq s_2766_9 s_2766_11
        let s_2766_12: bool = ((s_2766_9) == (s_2766_11));
        // N s_2766_13: branch s_2766_12 b2769 b2767
        if s_2766_12 {
            return block_2769(state, tracer, fn_state);
        } else {
            return block_2767(state, tracer, fn_state);
        };
    }
    fn block_2767<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2767_0: const #0u : u8
        let s_2767_0: bool = false;
        // D s_2767_1: write-var gs#405054 <= s_2767_0
        fn_state.gs_405054 = s_2767_0;
        // N s_2767_2: jump b2768
        return block_2768(state, tracer, fn_state);
    }
    fn block_2768<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2768_0: read-var gs#405054:u8
        let s_2768_0: bool = fn_state.gs_405054;
        // D s_2768_1: write-var gs#405055 <= s_2768_0
        fn_state.gs_405055 = s_2768_0;
        // N s_2768_2: jump b2765
        return block_2765(state, tracer, fn_state);
    }
    fn block_2769<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2769_0: const #4s : i
        let s_2769_0: i128 = 4;
        // D s_2769_1: read-var u#32565:u32
        let s_2769_1: u32 = fn_state.u_32565;
        // D s_2769_2: cast zx s_2769_1 -> bv
        let s_2769_2: Bits = Bits::new(s_2769_1 as u128, 32u16);
        // C s_2769_3: const #1s : i64
        let s_2769_3: i64 = 1;
        // C s_2769_4: cast zx s_2769_3 -> i
        let s_2769_4: i128 = (i128::try_from(s_2769_3).unwrap());
        // C s_2769_5: const #3s : i
        let s_2769_5: i128 = 3;
        // C s_2769_6: add s_2769_5 s_2769_4
        let s_2769_6: i128 = (s_2769_5 + s_2769_4);
        // D s_2769_7: bit-extract s_2769_2 s_2769_0 s_2769_6
        let s_2769_7: Bits = (Bits::new(
            ((s_2769_2) >> (s_2769_0)).value(),
            u16::try_from(s_2769_6).unwrap(),
        ));
        // D s_2769_8: cast reint s_2769_7 -> u8
        let s_2769_8: u8 = (s_2769_7.value() as u8);
        // D s_2769_9: cast zx s_2769_8 -> bv
        let s_2769_9: Bits = Bits::new(s_2769_8 as u128, 4u16);
        // C s_2769_10: const #11u : u8
        let s_2769_10: u8 = 11;
        // C s_2769_11: cast zx s_2769_10 -> bv
        let s_2769_11: Bits = Bits::new(s_2769_10 as u128, 4u16);
        // D s_2769_12: cmp-eq s_2769_9 s_2769_11
        let s_2769_12: bool = ((s_2769_9) == (s_2769_11));
        // D s_2769_13: write-var gs#405054 <= s_2769_12
        fn_state.gs_405054 = s_2769_12;
        // N s_2769_14: jump b2768
        return block_2768(state, tracer, fn_state);
    }
    fn block_2770<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2770_0: const #28s : i
        let s_2770_0: i128 = 28;
        // C s_2770_1: const #4s : i
        let s_2770_1: i128 = 4;
        // D s_2770_2: read-var u#32560:u32
        let s_2770_2: u32 = fn_state.u_32560;
        // D s_2770_3: cast zx s_2770_2 -> bv
        let s_2770_3: Bits = Bits::new(s_2770_2 as u128, 32u16);
        // D s_2770_4: bit-extract s_2770_3 s_2770_0 s_2770_1
        let s_2770_4: Bits = (Bits::new(
            ((s_2770_3) >> (s_2770_0)).value(),
            u16::try_from(s_2770_1).unwrap(),
        ));
        // D s_2770_5: cast reint s_2770_4 -> u8
        let s_2770_5: u8 = (s_2770_4.value() as u8);
        // D s_2770_6: cast zx s_2770_5 -> bv
        let s_2770_6: Bits = Bits::new(s_2770_5 as u128, 4u16);
        // C s_2770_7: const #15u : u8
        let s_2770_7: u8 = 15;
        // C s_2770_8: cast zx s_2770_7 -> bv
        let s_2770_8: Bits = Bits::new(s_2770_7 as u128, 4u16);
        // D s_2770_9: cmp-ne s_2770_6 s_2770_8
        let s_2770_9: bool = ((s_2770_6) != (s_2770_8));
        // N s_2770_10: branch s_2770_9 b2773 b2771
        if s_2770_9 {
            return block_2773(state, tracer, fn_state);
        } else {
            return block_2771(state, tracer, fn_state);
        };
    }
    fn block_2771<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2771_0: const #0u : u8
        let s_2771_0: bool = false;
        // D s_2771_1: write-var gs#405018 <= s_2771_0
        fn_state.gs_405018 = s_2771_0;
        // N s_2771_2: jump b2772
        return block_2772(state, tracer, fn_state);
    }
    fn block_2772<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2772_0: read-var gs#405018:u8
        let s_2772_0: bool = fn_state.gs_405018;
        // D s_2772_1: write-var gs#405019 <= s_2772_0
        fn_state.gs_405019 = s_2772_0;
        // N s_2772_2: jump b488
        return block_488(state, tracer, fn_state);
    }
    fn block_2773<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2773_0: const #2946s : i
        let s_2773_0: i128 = 2946;
        // C s_2773_1: const #14696u : u32
        let s_2773_1: u32 = 14696;
        // D s_2773_2: read-reg s_2773_1:i
        let s_2773_2: i128 = {
            let value = state.read_register::<i128>(s_2773_1 as isize);
            tracer.read_register(s_2773_1 as isize, value);
            value
        };
        // D s_2773_3: cmp-lt s_2773_2 s_2773_0
        let s_2773_3: bool = ((s_2773_2) < (s_2773_0));
        // D s_2773_4: write-var gs#405018 <= s_2773_3
        fn_state.gs_405018 = s_2773_3;
        // N s_2773_5: jump b2772
        return block_2772(state, tracer, fn_state);
    }
    fn block_2774<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2774_0: const #0s : i
        let s_2774_0: i128 = 0;
        // D s_2774_1: read-var u#32560:u32
        let s_2774_1: u32 = fn_state.u_32560;
        // D s_2774_2: cast zx s_2774_1 -> bv
        let s_2774_2: Bits = Bits::new(s_2774_1 as u128, 32u16);
        // C s_2774_3: const #1s : i64
        let s_2774_3: i64 = 1;
        // C s_2774_4: cast zx s_2774_3 -> i
        let s_2774_4: i128 = (i128::try_from(s_2774_3).unwrap());
        // C s_2774_5: const #11s : i
        let s_2774_5: i128 = 11;
        // C s_2774_6: add s_2774_5 s_2774_4
        let s_2774_6: i128 = (s_2774_5 + s_2774_4);
        // D s_2774_7: bit-extract s_2774_2 s_2774_0 s_2774_6
        let s_2774_7: Bits = (Bits::new(
            ((s_2774_2) >> (s_2774_0)).value(),
            u16::try_from(s_2774_6).unwrap(),
        ));
        // D s_2774_8: cast reint s_2774_7 -> u12
        let s_2774_8: u16 = (s_2774_7.value() as u16);
        // D s_2774_9: cast zx s_2774_8 -> bv
        let s_2774_9: Bits = Bits::new(s_2774_8 as u128, 12u16);
        // C s_2774_10: const #3999u : u12
        let s_2774_10: u16 = 3999;
        // C s_2774_11: cast zx s_2774_10 -> bv
        let s_2774_11: Bits = Bits::new(s_2774_10 as u128, 12u16);
        // D s_2774_12: cmp-eq s_2774_9 s_2774_11
        let s_2774_12: bool = ((s_2774_9) == (s_2774_11));
        // D s_2774_13: write-var gs#405014 <= s_2774_12
        fn_state.gs_405014 = s_2774_12;
        // N s_2774_14: jump b486
        return block_486(state, tracer, fn_state);
    }
    fn block_2775<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2775_0: const #28s : i
        let s_2775_0: i128 = 28;
        // C s_2775_1: const #4s : i
        let s_2775_1: i128 = 4;
        // D s_2775_2: read-var u#32555:u32
        let s_2775_2: u32 = fn_state.u_32555;
        // D s_2775_3: cast zx s_2775_2 -> bv
        let s_2775_3: Bits = Bits::new(s_2775_2 as u128, 32u16);
        // D s_2775_4: bit-extract s_2775_3 s_2775_0 s_2775_1
        let s_2775_4: Bits = (Bits::new(
            ((s_2775_3) >> (s_2775_0)).value(),
            u16::try_from(s_2775_1).unwrap(),
        ));
        // D s_2775_5: cast reint s_2775_4 -> u8
        let s_2775_5: u8 = (s_2775_4.value() as u8);
        // D s_2775_6: cast zx s_2775_5 -> bv
        let s_2775_6: Bits = Bits::new(s_2775_5 as u128, 4u16);
        // C s_2775_7: const #15u : u8
        let s_2775_7: u8 = 15;
        // C s_2775_8: cast zx s_2775_7 -> bv
        let s_2775_8: Bits = Bits::new(s_2775_7 as u128, 4u16);
        // D s_2775_9: cmp-ne s_2775_6 s_2775_8
        let s_2775_9: bool = ((s_2775_6) != (s_2775_8));
        // N s_2775_10: branch s_2775_9 b2778 b2776
        if s_2775_9 {
            return block_2778(state, tracer, fn_state);
        } else {
            return block_2776(state, tracer, fn_state);
        };
    }
    fn block_2776<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2776_0: const #0u : u8
        let s_2776_0: bool = false;
        // D s_2776_1: write-var gs#404982 <= s_2776_0
        fn_state.gs_404982 = s_2776_0;
        // N s_2776_2: jump b2777
        return block_2777(state, tracer, fn_state);
    }
    fn block_2777<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2777_0: read-var gs#404982:u8
        let s_2777_0: bool = fn_state.gs_404982;
        // D s_2777_1: write-var gs#404983 <= s_2777_0
        fn_state.gs_404983 = s_2777_0;
        // N s_2777_2: jump b465
        return block_465(state, tracer, fn_state);
    }
    fn block_2778<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2778_0: const #2944s : i
        let s_2778_0: i128 = 2944;
        // C s_2778_1: const #14696u : u32
        let s_2778_1: u32 = 14696;
        // D s_2778_2: read-reg s_2778_1:i
        let s_2778_2: i128 = {
            let value = state.read_register::<i128>(s_2778_1 as isize);
            tracer.read_register(s_2778_1 as isize, value);
            value
        };
        // D s_2778_3: cmp-lt s_2778_2 s_2778_0
        let s_2778_3: bool = ((s_2778_2) < (s_2778_0));
        // D s_2778_4: write-var gs#404982 <= s_2778_3
        fn_state.gs_404982 = s_2778_3;
        // N s_2778_5: jump b2777
        return block_2777(state, tracer, fn_state);
    }
    fn block_2779<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2779_0: const #0s : i
        let s_2779_0: i128 = 0;
        // D s_2779_1: read-var u#32555:u32
        let s_2779_1: u32 = fn_state.u_32555;
        // D s_2779_2: cast zx s_2779_1 -> bv
        let s_2779_2: Bits = Bits::new(s_2779_1 as u128, 32u16);
        // C s_2779_3: const #1s : i64
        let s_2779_3: i64 = 1;
        // C s_2779_4: cast zx s_2779_3 -> i
        let s_2779_4: i128 = (i128::try_from(s_2779_3).unwrap());
        // C s_2779_5: const #11s : i
        let s_2779_5: i128 = 11;
        // C s_2779_6: add s_2779_5 s_2779_4
        let s_2779_6: i128 = (s_2779_5 + s_2779_4);
        // D s_2779_7: bit-extract s_2779_2 s_2779_0 s_2779_6
        let s_2779_7: Bits = (Bits::new(
            ((s_2779_2) >> (s_2779_0)).value(),
            u16::try_from(s_2779_6).unwrap(),
        ));
        // D s_2779_8: cast reint s_2779_7 -> u12
        let s_2779_8: u16 = (s_2779_7.value() as u16);
        // D s_2779_9: cast zx s_2779_8 -> bv
        let s_2779_9: Bits = Bits::new(s_2779_8 as u128, 12u16);
        // C s_2779_10: const #3999u : u12
        let s_2779_10: u16 = 3999;
        // C s_2779_11: cast zx s_2779_10 -> bv
        let s_2779_11: Bits = Bits::new(s_2779_10 as u128, 12u16);
        // D s_2779_12: cmp-eq s_2779_9 s_2779_11
        let s_2779_12: bool = ((s_2779_9) == (s_2779_11));
        // D s_2779_13: write-var gs#404978 <= s_2779_12
        fn_state.gs_404978 = s_2779_12;
        // N s_2779_14: jump b463
        return block_463(state, tracer, fn_state);
    }
    fn block_2780<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2780_0: const #28s : i
        let s_2780_0: i128 = 28;
        // C s_2780_1: const #4s : i
        let s_2780_1: i128 = 4;
        // D s_2780_2: read-var u#32550:u32
        let s_2780_2: u32 = fn_state.u_32550;
        // D s_2780_3: cast zx s_2780_2 -> bv
        let s_2780_3: Bits = Bits::new(s_2780_2 as u128, 32u16);
        // D s_2780_4: bit-extract s_2780_3 s_2780_0 s_2780_1
        let s_2780_4: Bits = (Bits::new(
            ((s_2780_3) >> (s_2780_0)).value(),
            u16::try_from(s_2780_1).unwrap(),
        ));
        // D s_2780_5: cast reint s_2780_4 -> u8
        let s_2780_5: u8 = (s_2780_4.value() as u8);
        // D s_2780_6: cast zx s_2780_5 -> bv
        let s_2780_6: Bits = Bits::new(s_2780_5 as u128, 4u16);
        // C s_2780_7: const #15u : u8
        let s_2780_7: u8 = 15;
        // C s_2780_8: cast zx s_2780_7 -> bv
        let s_2780_8: Bits = Bits::new(s_2780_7 as u128, 4u16);
        // D s_2780_9: cmp-ne s_2780_6 s_2780_8
        let s_2780_9: bool = ((s_2780_6) != (s_2780_8));
        // N s_2780_10: branch s_2780_9 b2783 b2781
        if s_2780_9 {
            return block_2783(state, tracer, fn_state);
        } else {
            return block_2781(state, tracer, fn_state);
        };
    }
    fn block_2781<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2781_0: const #0u : u8
        let s_2781_0: bool = false;
        // D s_2781_1: write-var gs#404946 <= s_2781_0
        fn_state.gs_404946 = s_2781_0;
        // N s_2781_2: jump b2782
        return block_2782(state, tracer, fn_state);
    }
    fn block_2782<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2782_0: read-var gs#404946:u8
        let s_2782_0: bool = fn_state.gs_404946;
        // D s_2782_1: write-var gs#404947 <= s_2782_0
        fn_state.gs_404947 = s_2782_0;
        // N s_2782_2: jump b442
        return block_442(state, tracer, fn_state);
    }
    fn block_2783<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2783_0: const #2942s : i
        let s_2783_0: i128 = 2942;
        // C s_2783_1: const #14696u : u32
        let s_2783_1: u32 = 14696;
        // D s_2783_2: read-reg s_2783_1:i
        let s_2783_2: i128 = {
            let value = state.read_register::<i128>(s_2783_1 as isize);
            tracer.read_register(s_2783_1 as isize, value);
            value
        };
        // D s_2783_3: cmp-lt s_2783_2 s_2783_0
        let s_2783_3: bool = ((s_2783_2) < (s_2783_0));
        // D s_2783_4: write-var gs#404946 <= s_2783_3
        fn_state.gs_404946 = s_2783_3;
        // N s_2783_5: jump b2782
        return block_2782(state, tracer, fn_state);
    }
    fn block_2784<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2784_0: const #0s : i
        let s_2784_0: i128 = 0;
        // D s_2784_1: read-var u#32550:u32
        let s_2784_1: u32 = fn_state.u_32550;
        // D s_2784_2: cast zx s_2784_1 -> bv
        let s_2784_2: Bits = Bits::new(s_2784_1 as u128, 32u16);
        // C s_2784_3: const #1s : i64
        let s_2784_3: i64 = 1;
        // C s_2784_4: cast zx s_2784_3 -> i
        let s_2784_4: i128 = (i128::try_from(s_2784_3).unwrap());
        // C s_2784_5: const #11s : i
        let s_2784_5: i128 = 11;
        // C s_2784_6: add s_2784_5 s_2784_4
        let s_2784_6: i128 = (s_2784_5 + s_2784_4);
        // D s_2784_7: bit-extract s_2784_2 s_2784_0 s_2784_6
        let s_2784_7: Bits = (Bits::new(
            ((s_2784_2) >> (s_2784_0)).value(),
            u16::try_from(s_2784_6).unwrap(),
        ));
        // D s_2784_8: cast reint s_2784_7 -> u12
        let s_2784_8: u16 = (s_2784_7.value() as u16);
        // D s_2784_9: cast zx s_2784_8 -> bv
        let s_2784_9: Bits = Bits::new(s_2784_8 as u128, 12u16);
        // C s_2784_10: const #3999u : u12
        let s_2784_10: u16 = 3999;
        // C s_2784_11: cast zx s_2784_10 -> bv
        let s_2784_11: Bits = Bits::new(s_2784_10 as u128, 12u16);
        // D s_2784_12: cmp-eq s_2784_9 s_2784_11
        let s_2784_12: bool = ((s_2784_9) == (s_2784_11));
        // D s_2784_13: write-var gs#404942 <= s_2784_12
        fn_state.gs_404942 = s_2784_12;
        // N s_2784_14: jump b440
        return block_440(state, tracer, fn_state);
    }
    fn block_2785<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2785_0: const #28s : i
        let s_2785_0: i128 = 28;
        // C s_2785_1: const #4s : i
        let s_2785_1: i128 = 4;
        // D s_2785_2: read-var u#32545:u32
        let s_2785_2: u32 = fn_state.u_32545;
        // D s_2785_3: cast zx s_2785_2 -> bv
        let s_2785_3: Bits = Bits::new(s_2785_2 as u128, 32u16);
        // D s_2785_4: bit-extract s_2785_3 s_2785_0 s_2785_1
        let s_2785_4: Bits = (Bits::new(
            ((s_2785_3) >> (s_2785_0)).value(),
            u16::try_from(s_2785_1).unwrap(),
        ));
        // D s_2785_5: cast reint s_2785_4 -> u8
        let s_2785_5: u8 = (s_2785_4.value() as u8);
        // D s_2785_6: cast zx s_2785_5 -> bv
        let s_2785_6: Bits = Bits::new(s_2785_5 as u128, 4u16);
        // C s_2785_7: const #15u : u8
        let s_2785_7: u8 = 15;
        // C s_2785_8: cast zx s_2785_7 -> bv
        let s_2785_8: Bits = Bits::new(s_2785_7 as u128, 4u16);
        // D s_2785_9: cmp-ne s_2785_6 s_2785_8
        let s_2785_9: bool = ((s_2785_6) != (s_2785_8));
        // N s_2785_10: branch s_2785_9 b2788 b2786
        if s_2785_9 {
            return block_2788(state, tracer, fn_state);
        } else {
            return block_2786(state, tracer, fn_state);
        };
    }
    fn block_2786<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2786_0: const #0u : u8
        let s_2786_0: bool = false;
        // D s_2786_1: write-var gs#404910 <= s_2786_0
        fn_state.gs_404910 = s_2786_0;
        // N s_2786_2: jump b2787
        return block_2787(state, tracer, fn_state);
    }
    fn block_2787<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2787_0: read-var gs#404910:u8
        let s_2787_0: bool = fn_state.gs_404910;
        // D s_2787_1: write-var gs#404911 <= s_2787_0
        fn_state.gs_404911 = s_2787_0;
        // N s_2787_2: jump b419
        return block_419(state, tracer, fn_state);
    }
    fn block_2788<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2788_0: const #2940s : i
        let s_2788_0: i128 = 2940;
        // C s_2788_1: const #14696u : u32
        let s_2788_1: u32 = 14696;
        // D s_2788_2: read-reg s_2788_1:i
        let s_2788_2: i128 = {
            let value = state.read_register::<i128>(s_2788_1 as isize);
            tracer.read_register(s_2788_1 as isize, value);
            value
        };
        // D s_2788_3: cmp-lt s_2788_2 s_2788_0
        let s_2788_3: bool = ((s_2788_2) < (s_2788_0));
        // D s_2788_4: write-var gs#404910 <= s_2788_3
        fn_state.gs_404910 = s_2788_3;
        // N s_2788_5: jump b2787
        return block_2787(state, tracer, fn_state);
    }
    fn block_2789<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2789_0: const #0s : i
        let s_2789_0: i128 = 0;
        // D s_2789_1: read-var u#32545:u32
        let s_2789_1: u32 = fn_state.u_32545;
        // D s_2789_2: cast zx s_2789_1 -> bv
        let s_2789_2: Bits = Bits::new(s_2789_1 as u128, 32u16);
        // C s_2789_3: const #1s : i64
        let s_2789_3: i64 = 1;
        // C s_2789_4: cast zx s_2789_3 -> i
        let s_2789_4: i128 = (i128::try_from(s_2789_3).unwrap());
        // C s_2789_5: const #11s : i
        let s_2789_5: i128 = 11;
        // C s_2789_6: add s_2789_5 s_2789_4
        let s_2789_6: i128 = (s_2789_5 + s_2789_4);
        // D s_2789_7: bit-extract s_2789_2 s_2789_0 s_2789_6
        let s_2789_7: Bits = (Bits::new(
            ((s_2789_2) >> (s_2789_0)).value(),
            u16::try_from(s_2789_6).unwrap(),
        ));
        // D s_2789_8: cast reint s_2789_7 -> u12
        let s_2789_8: u16 = (s_2789_7.value() as u16);
        // D s_2789_9: cast zx s_2789_8 -> bv
        let s_2789_9: Bits = Bits::new(s_2789_8 as u128, 12u16);
        // C s_2789_10: const #3999u : u12
        let s_2789_10: u16 = 3999;
        // C s_2789_11: cast zx s_2789_10 -> bv
        let s_2789_11: Bits = Bits::new(s_2789_10 as u128, 12u16);
        // D s_2789_12: cmp-eq s_2789_9 s_2789_11
        let s_2789_12: bool = ((s_2789_9) == (s_2789_11));
        // D s_2789_13: write-var gs#404906 <= s_2789_12
        fn_state.gs_404906 = s_2789_12;
        // N s_2789_14: jump b417
        return block_417(state, tracer, fn_state);
    }
    fn block_2790<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2790_0: const #28s : i
        let s_2790_0: i128 = 28;
        // C s_2790_1: const #4s : i
        let s_2790_1: i128 = 4;
        // D s_2790_2: read-var u#32536:u32
        let s_2790_2: u32 = fn_state.u_32536;
        // D s_2790_3: cast zx s_2790_2 -> bv
        let s_2790_3: Bits = Bits::new(s_2790_2 as u128, 32u16);
        // D s_2790_4: bit-extract s_2790_3 s_2790_0 s_2790_1
        let s_2790_4: Bits = (Bits::new(
            ((s_2790_3) >> (s_2790_0)).value(),
            u16::try_from(s_2790_1).unwrap(),
        ));
        // D s_2790_5: cast reint s_2790_4 -> u8
        let s_2790_5: u8 = (s_2790_4.value() as u8);
        // D s_2790_6: cast zx s_2790_5 -> bv
        let s_2790_6: Bits = Bits::new(s_2790_5 as u128, 4u16);
        // C s_2790_7: const #15u : u8
        let s_2790_7: u8 = 15;
        // C s_2790_8: cast zx s_2790_7 -> bv
        let s_2790_8: Bits = Bits::new(s_2790_7 as u128, 4u16);
        // D s_2790_9: cmp-ne s_2790_6 s_2790_8
        let s_2790_9: bool = ((s_2790_6) != (s_2790_8));
        // N s_2790_10: branch s_2790_9 b2793 b2791
        if s_2790_9 {
            return block_2793(state, tracer, fn_state);
        } else {
            return block_2791(state, tracer, fn_state);
        };
    }
    fn block_2791<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2791_0: const #0u : u8
        let s_2791_0: bool = false;
        // D s_2791_1: write-var gs#404872 <= s_2791_0
        fn_state.gs_404872 = s_2791_0;
        // N s_2791_2: jump b2792
        return block_2792(state, tracer, fn_state);
    }
    fn block_2792<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2792_0: read-var gs#404872:u8
        let s_2792_0: bool = fn_state.gs_404872;
        // D s_2792_1: write-var gs#404873 <= s_2792_0
        fn_state.gs_404873 = s_2792_0;
        // N s_2792_2: jump b402
        return block_402(state, tracer, fn_state);
    }
    fn block_2793<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2793_0: const #2939s : i
        let s_2793_0: i128 = 2939;
        // C s_2793_1: const #14696u : u32
        let s_2793_1: u32 = 14696;
        // D s_2793_2: read-reg s_2793_1:i
        let s_2793_2: i128 = {
            let value = state.read_register::<i128>(s_2793_1 as isize);
            tracer.read_register(s_2793_1 as isize, value);
            value
        };
        // D s_2793_3: cmp-lt s_2793_2 s_2793_0
        let s_2793_3: bool = ((s_2793_2) < (s_2793_0));
        // D s_2793_4: write-var gs#404872 <= s_2793_3
        fn_state.gs_404872 = s_2793_3;
        // N s_2793_5: jump b2792
        return block_2792(state, tracer, fn_state);
    }
    fn block_2794<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2794_0: const #22s : i
        let s_2794_0: i128 = 22;
        // D s_2794_1: read-var u#32536:u32
        let s_2794_1: u32 = fn_state.u_32536;
        // D s_2794_2: cast zx s_2794_1 -> bv
        let s_2794_2: Bits = Bits::new(s_2794_1 as u128, 32u16);
        // C s_2794_3: const #1s : i64
        let s_2794_3: i64 = 1;
        // C s_2794_4: cast zx s_2794_3 -> i
        let s_2794_4: i128 = (i128::try_from(s_2794_3).unwrap());
        // C s_2794_5: const #0s : i
        let s_2794_5: i128 = 0;
        // C s_2794_6: add s_2794_5 s_2794_4
        let s_2794_6: i128 = (s_2794_5 + s_2794_4);
        // D s_2794_7: bit-extract s_2794_2 s_2794_0 s_2794_6
        let s_2794_7: Bits = (Bits::new(
            ((s_2794_2) >> (s_2794_0)).value(),
            u16::try_from(s_2794_6).unwrap(),
        ));
        // D s_2794_8: cast reint s_2794_7 -> u8
        let s_2794_8: bool = ((s_2794_7.value()) != 0);
        // D s_2794_9: cast zx s_2794_8 -> bv
        let s_2794_9: Bits = Bits::new(s_2794_8 as u128, 1u16);
        // C s_2794_10: const #0u : u8
        let s_2794_10: bool = false;
        // C s_2794_11: cast zx s_2794_10 -> bv
        let s_2794_11: Bits = Bits::new(s_2794_10 as u128, 1u16);
        // D s_2794_12: cmp-eq s_2794_9 s_2794_11
        let s_2794_12: bool = ((s_2794_9) == (s_2794_11));
        // N s_2794_13: branch s_2794_12 b2797 b2795
        if s_2794_12 {
            return block_2797(state, tracer, fn_state);
        } else {
            return block_2795(state, tracer, fn_state);
        };
    }
    fn block_2795<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2795_0: const #0u : u8
        let s_2795_0: bool = false;
        // D s_2795_1: write-var gs#404867 <= s_2795_0
        fn_state.gs_404867 = s_2795_0;
        // N s_2795_2: jump b2796
        return block_2796(state, tracer, fn_state);
    }
    fn block_2796<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2796_0: read-var gs#404867:u8
        let s_2796_0: bool = fn_state.gs_404867;
        // D s_2796_1: write-var gs#404868 <= s_2796_0
        fn_state.gs_404868 = s_2796_0;
        // N s_2796_2: jump b400
        return block_400(state, tracer, fn_state);
    }
    fn block_2797<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2797_0: const #20s : i
        let s_2797_0: i128 = 20;
        // D s_2797_1: read-var u#32536:u32
        let s_2797_1: u32 = fn_state.u_32536;
        // D s_2797_2: cast zx s_2797_1 -> bv
        let s_2797_2: Bits = Bits::new(s_2797_1 as u128, 32u16);
        // C s_2797_3: const #1s : i64
        let s_2797_3: i64 = 1;
        // C s_2797_4: cast zx s_2797_3 -> i
        let s_2797_4: i128 = (i128::try_from(s_2797_3).unwrap());
        // C s_2797_5: const #0s : i
        let s_2797_5: i128 = 0;
        // C s_2797_6: add s_2797_5 s_2797_4
        let s_2797_6: i128 = (s_2797_5 + s_2797_4);
        // D s_2797_7: bit-extract s_2797_2 s_2797_0 s_2797_6
        let s_2797_7: Bits = (Bits::new(
            ((s_2797_2) >> (s_2797_0)).value(),
            u16::try_from(s_2797_6).unwrap(),
        ));
        // D s_2797_8: cast reint s_2797_7 -> u8
        let s_2797_8: bool = ((s_2797_7.value()) != 0);
        // D s_2797_9: cast zx s_2797_8 -> bv
        let s_2797_9: Bits = Bits::new(s_2797_8 as u128, 1u16);
        // C s_2797_10: const #0u : u8
        let s_2797_10: bool = false;
        // C s_2797_11: cast zx s_2797_10 -> bv
        let s_2797_11: Bits = Bits::new(s_2797_10 as u128, 1u16);
        // D s_2797_12: cmp-eq s_2797_9 s_2797_11
        let s_2797_12: bool = ((s_2797_9) == (s_2797_11));
        // N s_2797_13: branch s_2797_12 b2800 b2798
        if s_2797_12 {
            return block_2800(state, tracer, fn_state);
        } else {
            return block_2798(state, tracer, fn_state);
        };
    }
    fn block_2798<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2798_0: const #0u : u8
        let s_2798_0: bool = false;
        // D s_2798_1: write-var gs#404866 <= s_2798_0
        fn_state.gs_404866 = s_2798_0;
        // N s_2798_2: jump b2799
        return block_2799(state, tracer, fn_state);
    }
    fn block_2799<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2799_0: read-var gs#404866:u8
        let s_2799_0: bool = fn_state.gs_404866;
        // D s_2799_1: write-var gs#404867 <= s_2799_0
        fn_state.gs_404867 = s_2799_0;
        // N s_2799_2: jump b2796
        return block_2796(state, tracer, fn_state);
    }
    fn block_2800<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2800_0: const #4s : i
        let s_2800_0: i128 = 4;
        // D s_2800_1: read-var u#32536:u32
        let s_2800_1: u32 = fn_state.u_32536;
        // D s_2800_2: cast zx s_2800_1 -> bv
        let s_2800_2: Bits = Bits::new(s_2800_1 as u128, 32u16);
        // C s_2800_3: const #1s : i64
        let s_2800_3: i64 = 1;
        // C s_2800_4: cast zx s_2800_3 -> i
        let s_2800_4: i128 = (i128::try_from(s_2800_3).unwrap());
        // C s_2800_5: const #7s : i
        let s_2800_5: i128 = 7;
        // C s_2800_6: add s_2800_5 s_2800_4
        let s_2800_6: i128 = (s_2800_5 + s_2800_4);
        // D s_2800_7: bit-extract s_2800_2 s_2800_0 s_2800_6
        let s_2800_7: Bits = (Bits::new(
            ((s_2800_2) >> (s_2800_0)).value(),
            u16::try_from(s_2800_6).unwrap(),
        ));
        // D s_2800_8: cast reint s_2800_7 -> u8
        let s_2800_8: u8 = (s_2800_7.value() as u8);
        // D s_2800_9: cast zx s_2800_8 -> bv
        let s_2800_9: Bits = Bits::new(s_2800_8 as u128, 8u16);
        // C s_2800_10: const #13u : u8
        let s_2800_10: u8 = 13;
        // C s_2800_11: cast zx s_2800_10 -> bv
        let s_2800_11: Bits = Bits::new(s_2800_10 as u128, 8u16);
        // D s_2800_12: cmp-eq s_2800_9 s_2800_11
        let s_2800_12: bool = ((s_2800_9) == (s_2800_11));
        // D s_2800_13: write-var gs#404866 <= s_2800_12
        fn_state.gs_404866 = s_2800_12;
        // N s_2800_14: jump b2799
        return block_2799(state, tracer, fn_state);
    }
    fn block_2801<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2801_0: const #28s : i
        let s_2801_0: i128 = 28;
        // C s_2801_1: const #4s : i
        let s_2801_1: i128 = 4;
        // D s_2801_2: read-var u#32529:u32
        let s_2801_2: u32 = fn_state.u_32529;
        // D s_2801_3: cast zx s_2801_2 -> bv
        let s_2801_3: Bits = Bits::new(s_2801_2 as u128, 32u16);
        // D s_2801_4: bit-extract s_2801_3 s_2801_0 s_2801_1
        let s_2801_4: Bits = (Bits::new(
            ((s_2801_3) >> (s_2801_0)).value(),
            u16::try_from(s_2801_1).unwrap(),
        ));
        // D s_2801_5: cast reint s_2801_4 -> u8
        let s_2801_5: u8 = (s_2801_4.value() as u8);
        // D s_2801_6: cast zx s_2801_5 -> bv
        let s_2801_6: Bits = Bits::new(s_2801_5 as u128, 4u16);
        // C s_2801_7: const #15u : u8
        let s_2801_7: u8 = 15;
        // C s_2801_8: cast zx s_2801_7 -> bv
        let s_2801_8: Bits = Bits::new(s_2801_7 as u128, 4u16);
        // D s_2801_9: cmp-ne s_2801_6 s_2801_8
        let s_2801_9: bool = ((s_2801_6) != (s_2801_8));
        // N s_2801_10: branch s_2801_9 b2804 b2802
        if s_2801_9 {
            return block_2804(state, tracer, fn_state);
        } else {
            return block_2802(state, tracer, fn_state);
        };
    }
    fn block_2802<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2802_0: const #0u : u8
        let s_2802_0: bool = false;
        // D s_2802_1: write-var gs#404838 <= s_2802_0
        fn_state.gs_404838 = s_2802_0;
        // N s_2802_2: jump b2803
        return block_2803(state, tracer, fn_state);
    }
    fn block_2803<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2803_0: read-var gs#404838:u8
        let s_2803_0: bool = fn_state.gs_404838;
        // D s_2803_1: write-var gs#404839 <= s_2803_0
        fn_state.gs_404839 = s_2803_0;
        // N s_2803_2: jump b391
        return block_391(state, tracer, fn_state);
    }
    fn block_2804<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2804_0: const #2937s : i
        let s_2804_0: i128 = 2937;
        // C s_2804_1: const #14696u : u32
        let s_2804_1: u32 = 14696;
        // D s_2804_2: read-reg s_2804_1:i
        let s_2804_2: i128 = {
            let value = state.read_register::<i128>(s_2804_1 as isize);
            tracer.read_register(s_2804_1 as isize, value);
            value
        };
        // D s_2804_3: cmp-lt s_2804_2 s_2804_0
        let s_2804_3: bool = ((s_2804_2) < (s_2804_0));
        // D s_2804_4: write-var gs#404838 <= s_2804_3
        fn_state.gs_404838 = s_2804_3;
        // N s_2804_5: jump b2803
        return block_2803(state, tracer, fn_state);
    }
    fn block_2805<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2805_0: const #16s : i
        let s_2805_0: i128 = 16;
        // D s_2805_1: read-var u#32529:u32
        let s_2805_1: u32 = fn_state.u_32529;
        // D s_2805_2: cast zx s_2805_1 -> bv
        let s_2805_2: Bits = Bits::new(s_2805_1 as u128, 32u16);
        // C s_2805_3: const #1s : i64
        let s_2805_3: i64 = 1;
        // C s_2805_4: cast zx s_2805_3 -> i
        let s_2805_4: i128 = (i128::try_from(s_2805_3).unwrap());
        // C s_2805_5: const #6s : i
        let s_2805_5: i128 = 6;
        // C s_2805_6: add s_2805_5 s_2805_4
        let s_2805_6: i128 = (s_2805_5 + s_2805_4);
        // D s_2805_7: bit-extract s_2805_2 s_2805_0 s_2805_6
        let s_2805_7: Bits = (Bits::new(
            ((s_2805_2) >> (s_2805_0)).value(),
            u16::try_from(s_2805_6).unwrap(),
        ));
        // D s_2805_8: cast reint s_2805_7 -> u8
        let s_2805_8: u8 = (s_2805_7.value() as u8);
        // D s_2805_9: cast zx s_2805_8 -> bv
        let s_2805_9: Bits = Bits::new(s_2805_8 as u128, 7u16);
        // C s_2805_10: const #79u : u8
        let s_2805_10: u8 = 79;
        // C s_2805_11: cast zx s_2805_10 -> bv
        let s_2805_11: Bits = Bits::new(s_2805_10 as u128, 7u16);
        // D s_2805_12: cmp-eq s_2805_9 s_2805_11
        let s_2805_12: bool = ((s_2805_9) == (s_2805_11));
        // N s_2805_13: branch s_2805_12 b2808 b2806
        if s_2805_12 {
            return block_2808(state, tracer, fn_state);
        } else {
            return block_2806(state, tracer, fn_state);
        };
    }
    fn block_2806<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2806_0: const #0u : u8
        let s_2806_0: bool = false;
        // D s_2806_1: write-var gs#404833 <= s_2806_0
        fn_state.gs_404833 = s_2806_0;
        // N s_2806_2: jump b2807
        return block_2807(state, tracer, fn_state);
    }
    fn block_2807<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2807_0: read-var gs#404833:u8
        let s_2807_0: bool = fn_state.gs_404833;
        // D s_2807_1: write-var gs#404834 <= s_2807_0
        fn_state.gs_404834 = s_2807_0;
        // N s_2807_2: jump b389
        return block_389(state, tracer, fn_state);
    }
    fn block_2808<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2808_0: const #4s : i
        let s_2808_0: i128 = 4;
        // D s_2808_1: read-var u#32529:u32
        let s_2808_1: u32 = fn_state.u_32529;
        // D s_2808_2: cast zx s_2808_1 -> bv
        let s_2808_2: Bits = Bits::new(s_2808_1 as u128, 32u16);
        // C s_2808_3: const #1s : i64
        let s_2808_3: i64 = 1;
        // C s_2808_4: cast zx s_2808_3 -> i
        let s_2808_4: i128 = (i128::try_from(s_2808_3).unwrap());
        // C s_2808_5: const #3s : i
        let s_2808_5: i128 = 3;
        // C s_2808_6: add s_2808_5 s_2808_4
        let s_2808_6: i128 = (s_2808_5 + s_2808_4);
        // D s_2808_7: bit-extract s_2808_2 s_2808_0 s_2808_6
        let s_2808_7: Bits = (Bits::new(
            ((s_2808_2) >> (s_2808_0)).value(),
            u16::try_from(s_2808_6).unwrap(),
        ));
        // D s_2808_8: cast reint s_2808_7 -> u8
        let s_2808_8: u8 = (s_2808_7.value() as u8);
        // D s_2808_9: cast zx s_2808_8 -> bv
        let s_2808_9: Bits = Bits::new(s_2808_8 as u128, 4u16);
        // C s_2808_10: const #13u : u8
        let s_2808_10: u8 = 13;
        // C s_2808_11: cast zx s_2808_10 -> bv
        let s_2808_11: Bits = Bits::new(s_2808_10 as u128, 4u16);
        // D s_2808_12: cmp-eq s_2808_9 s_2808_11
        let s_2808_12: bool = ((s_2808_9) == (s_2808_11));
        // D s_2808_13: write-var gs#404833 <= s_2808_12
        fn_state.gs_404833 = s_2808_12;
        // N s_2808_14: jump b2807
        return block_2807(state, tracer, fn_state);
    }
    fn block_2809<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2809_0: const #28s : i
        let s_2809_0: i128 = 28;
        // C s_2809_1: const #4s : i
        let s_2809_1: i128 = 4;
        // D s_2809_2: read-var u#32525:u32
        let s_2809_2: u32 = fn_state.u_32525;
        // D s_2809_3: cast zx s_2809_2 -> bv
        let s_2809_3: Bits = Bits::new(s_2809_2 as u128, 32u16);
        // D s_2809_4: bit-extract s_2809_3 s_2809_0 s_2809_1
        let s_2809_4: Bits = (Bits::new(
            ((s_2809_3) >> (s_2809_0)).value(),
            u16::try_from(s_2809_1).unwrap(),
        ));
        // D s_2809_5: cast reint s_2809_4 -> u8
        let s_2809_5: u8 = (s_2809_4.value() as u8);
        // D s_2809_6: cast zx s_2809_5 -> bv
        let s_2809_6: Bits = Bits::new(s_2809_5 as u128, 4u16);
        // C s_2809_7: const #15u : u8
        let s_2809_7: u8 = 15;
        // C s_2809_8: cast zx s_2809_7 -> bv
        let s_2809_8: Bits = Bits::new(s_2809_7 as u128, 4u16);
        // D s_2809_9: cmp-ne s_2809_6 s_2809_8
        let s_2809_9: bool = ((s_2809_6) != (s_2809_8));
        // N s_2809_10: branch s_2809_9 b2812 b2810
        if s_2809_9 {
            return block_2812(state, tracer, fn_state);
        } else {
            return block_2810(state, tracer, fn_state);
        };
    }
    fn block_2810<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2810_0: const #0u : u8
        let s_2810_0: bool = false;
        // D s_2810_1: write-var gs#404806 <= s_2810_0
        fn_state.gs_404806 = s_2810_0;
        // N s_2810_2: jump b2811
        return block_2811(state, tracer, fn_state);
    }
    fn block_2811<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2811_0: read-var gs#404806:u8
        let s_2811_0: bool = fn_state.gs_404806;
        // D s_2811_1: write-var gs#404807 <= s_2811_0
        fn_state.gs_404807 = s_2811_0;
        // N s_2811_2: jump b385
        return block_385(state, tracer, fn_state);
    }
    fn block_2812<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2812_0: const #2935s : i
        let s_2812_0: i128 = 2935;
        // C s_2812_1: const #14696u : u32
        let s_2812_1: u32 = 14696;
        // D s_2812_2: read-reg s_2812_1:i
        let s_2812_2: i128 = {
            let value = state.read_register::<i128>(s_2812_1 as isize);
            tracer.read_register(s_2812_1 as isize, value);
            value
        };
        // D s_2812_3: cmp-lt s_2812_2 s_2812_0
        let s_2812_3: bool = ((s_2812_2) < (s_2812_0));
        // D s_2812_4: write-var gs#404806 <= s_2812_3
        fn_state.gs_404806 = s_2812_3;
        // N s_2812_5: jump b2811
        return block_2811(state, tracer, fn_state);
    }
    fn block_2813<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2813_0: const #22s : i
        let s_2813_0: i128 = 22;
        // D s_2813_1: read-var u#32525:u32
        let s_2813_1: u32 = fn_state.u_32525;
        // D s_2813_2: cast zx s_2813_1 -> bv
        let s_2813_2: Bits = Bits::new(s_2813_1 as u128, 32u16);
        // C s_2813_3: const #1s : i64
        let s_2813_3: i64 = 1;
        // C s_2813_4: cast zx s_2813_3 -> i
        let s_2813_4: i128 = (i128::try_from(s_2813_3).unwrap());
        // C s_2813_5: const #0s : i
        let s_2813_5: i128 = 0;
        // C s_2813_6: add s_2813_5 s_2813_4
        let s_2813_6: i128 = (s_2813_5 + s_2813_4);
        // D s_2813_7: bit-extract s_2813_2 s_2813_0 s_2813_6
        let s_2813_7: Bits = (Bits::new(
            ((s_2813_2) >> (s_2813_0)).value(),
            u16::try_from(s_2813_6).unwrap(),
        ));
        // D s_2813_8: cast reint s_2813_7 -> u8
        let s_2813_8: bool = ((s_2813_7.value()) != 0);
        // D s_2813_9: cast zx s_2813_8 -> bv
        let s_2813_9: Bits = Bits::new(s_2813_8 as u128, 1u16);
        // C s_2813_10: const #1u : u8
        let s_2813_10: bool = true;
        // C s_2813_11: cast zx s_2813_10 -> bv
        let s_2813_11: Bits = Bits::new(s_2813_10 as u128, 1u16);
        // D s_2813_12: cmp-eq s_2813_9 s_2813_11
        let s_2813_12: bool = ((s_2813_9) == (s_2813_11));
        // N s_2813_13: branch s_2813_12 b2816 b2814
        if s_2813_12 {
            return block_2816(state, tracer, fn_state);
        } else {
            return block_2814(state, tracer, fn_state);
        };
    }
    fn block_2814<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2814_0: const #0u : u8
        let s_2814_0: bool = false;
        // D s_2814_1: write-var gs#404801 <= s_2814_0
        fn_state.gs_404801 = s_2814_0;
        // N s_2814_2: jump b2815
        return block_2815(state, tracer, fn_state);
    }
    fn block_2815<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2815_0: read-var gs#404801:u8
        let s_2815_0: bool = fn_state.gs_404801;
        // D s_2815_1: write-var gs#404802 <= s_2815_0
        fn_state.gs_404802 = s_2815_0;
        // N s_2815_2: jump b383
        return block_383(state, tracer, fn_state);
    }
    fn block_2816<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2816_0: const #20s : i
        let s_2816_0: i128 = 20;
        // D s_2816_1: read-var u#32525:u32
        let s_2816_1: u32 = fn_state.u_32525;
        // D s_2816_2: cast zx s_2816_1 -> bv
        let s_2816_2: Bits = Bits::new(s_2816_1 as u128, 32u16);
        // C s_2816_3: const #1s : i64
        let s_2816_3: i64 = 1;
        // C s_2816_4: cast zx s_2816_3 -> i
        let s_2816_4: i128 = (i128::try_from(s_2816_3).unwrap());
        // C s_2816_5: const #0s : i
        let s_2816_5: i128 = 0;
        // C s_2816_6: add s_2816_5 s_2816_4
        let s_2816_6: i128 = (s_2816_5 + s_2816_4);
        // D s_2816_7: bit-extract s_2816_2 s_2816_0 s_2816_6
        let s_2816_7: Bits = (Bits::new(
            ((s_2816_2) >> (s_2816_0)).value(),
            u16::try_from(s_2816_6).unwrap(),
        ));
        // D s_2816_8: cast reint s_2816_7 -> u8
        let s_2816_8: bool = ((s_2816_7.value()) != 0);
        // D s_2816_9: cast zx s_2816_8 -> bv
        let s_2816_9: Bits = Bits::new(s_2816_8 as u128, 1u16);
        // C s_2816_10: const #0u : u8
        let s_2816_10: bool = false;
        // C s_2816_11: cast zx s_2816_10 -> bv
        let s_2816_11: Bits = Bits::new(s_2816_10 as u128, 1u16);
        // D s_2816_12: cmp-eq s_2816_9 s_2816_11
        let s_2816_12: bool = ((s_2816_9) == (s_2816_11));
        // N s_2816_13: branch s_2816_12 b2819 b2817
        if s_2816_12 {
            return block_2819(state, tracer, fn_state);
        } else {
            return block_2817(state, tracer, fn_state);
        };
    }
    fn block_2817<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2817_0: const #0u : u8
        let s_2817_0: bool = false;
        // D s_2817_1: write-var gs#404800 <= s_2817_0
        fn_state.gs_404800 = s_2817_0;
        // N s_2817_2: jump b2818
        return block_2818(state, tracer, fn_state);
    }
    fn block_2818<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2818_0: read-var gs#404800:u8
        let s_2818_0: bool = fn_state.gs_404800;
        // D s_2818_1: write-var gs#404801 <= s_2818_0
        fn_state.gs_404801 = s_2818_0;
        // N s_2818_2: jump b2815
        return block_2815(state, tracer, fn_state);
    }
    fn block_2819<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2819_0: const #4s : i
        let s_2819_0: i128 = 4;
        // D s_2819_1: read-var u#32525:u32
        let s_2819_1: u32 = fn_state.u_32525;
        // D s_2819_2: cast zx s_2819_1 -> bv
        let s_2819_2: Bits = Bits::new(s_2819_1 as u128, 32u16);
        // C s_2819_3: const #1s : i64
        let s_2819_3: i64 = 1;
        // C s_2819_4: cast zx s_2819_3 -> i
        let s_2819_4: i128 = (i128::try_from(s_2819_3).unwrap());
        // C s_2819_5: const #3s : i
        let s_2819_5: i128 = 3;
        // C s_2819_6: add s_2819_5 s_2819_4
        let s_2819_6: i128 = (s_2819_5 + s_2819_4);
        // D s_2819_7: bit-extract s_2819_2 s_2819_0 s_2819_6
        let s_2819_7: Bits = (Bits::new(
            ((s_2819_2) >> (s_2819_0)).value(),
            u16::try_from(s_2819_6).unwrap(),
        ));
        // D s_2819_8: cast reint s_2819_7 -> u8
        let s_2819_8: u8 = (s_2819_7.value() as u8);
        // D s_2819_9: cast zx s_2819_8 -> bv
        let s_2819_9: Bits = Bits::new(s_2819_8 as u128, 4u16);
        // C s_2819_10: const #13u : u8
        let s_2819_10: u8 = 13;
        // C s_2819_11: cast zx s_2819_10 -> bv
        let s_2819_11: Bits = Bits::new(s_2819_10 as u128, 4u16);
        // D s_2819_12: cmp-eq s_2819_9 s_2819_11
        let s_2819_12: bool = ((s_2819_9) == (s_2819_11));
        // D s_2819_13: write-var gs#404800 <= s_2819_12
        fn_state.gs_404800 = s_2819_12;
        // N s_2819_14: jump b2818
        return block_2818(state, tracer, fn_state);
    }
    fn block_2820<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2820_0: const #28s : i
        let s_2820_0: i128 = 28;
        // C s_2820_1: const #4s : i
        let s_2820_1: i128 = 4;
        // D s_2820_2: read-var u#32516:u32
        let s_2820_2: u32 = fn_state.u_32516;
        // D s_2820_3: cast zx s_2820_2 -> bv
        let s_2820_3: Bits = Bits::new(s_2820_2 as u128, 32u16);
        // D s_2820_4: bit-extract s_2820_3 s_2820_0 s_2820_1
        let s_2820_4: Bits = (Bits::new(
            ((s_2820_3) >> (s_2820_0)).value(),
            u16::try_from(s_2820_1).unwrap(),
        ));
        // D s_2820_5: cast reint s_2820_4 -> u8
        let s_2820_5: u8 = (s_2820_4.value() as u8);
        // D s_2820_6: cast zx s_2820_5 -> bv
        let s_2820_6: Bits = Bits::new(s_2820_5 as u128, 4u16);
        // C s_2820_7: const #15u : u8
        let s_2820_7: u8 = 15;
        // C s_2820_8: cast zx s_2820_7 -> bv
        let s_2820_8: Bits = Bits::new(s_2820_7 as u128, 4u16);
        // D s_2820_9: cmp-ne s_2820_6 s_2820_8
        let s_2820_9: bool = ((s_2820_6) != (s_2820_8));
        // N s_2820_10: branch s_2820_9 b2823 b2821
        if s_2820_9 {
            return block_2823(state, tracer, fn_state);
        } else {
            return block_2821(state, tracer, fn_state);
        };
    }
    fn block_2821<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2821_0: const #0u : u8
        let s_2821_0: bool = false;
        // D s_2821_1: write-var gs#404773 <= s_2821_0
        fn_state.gs_404773 = s_2821_0;
        // N s_2821_2: jump b2822
        return block_2822(state, tracer, fn_state);
    }
    fn block_2822<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2822_0: read-var gs#404773:u8
        let s_2822_0: bool = fn_state.gs_404773;
        // D s_2822_1: write-var gs#404774 <= s_2822_0
        fn_state.gs_404774 = s_2822_0;
        // N s_2822_2: jump b379
        return block_379(state, tracer, fn_state);
    }
    fn block_2823<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2823_0: const #2908s : i
        let s_2823_0: i128 = 2908;
        // C s_2823_1: const #14696u : u32
        let s_2823_1: u32 = 14696;
        // D s_2823_2: read-reg s_2823_1:i
        let s_2823_2: i128 = {
            let value = state.read_register::<i128>(s_2823_1 as isize);
            tracer.read_register(s_2823_1 as isize, value);
            value
        };
        // D s_2823_3: cmp-lt s_2823_2 s_2823_0
        let s_2823_3: bool = ((s_2823_2) < (s_2823_0));
        // D s_2823_4: write-var gs#404773 <= s_2823_3
        fn_state.gs_404773 = s_2823_3;
        // N s_2823_5: jump b2822
        return block_2822(state, tracer, fn_state);
    }
    fn block_2824<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2824_0: const #7s : i
        let s_2824_0: i128 = 7;
        // D s_2824_1: read-var u#32516:u32
        let s_2824_1: u32 = fn_state.u_32516;
        // D s_2824_2: cast zx s_2824_1 -> bv
        let s_2824_2: Bits = Bits::new(s_2824_1 as u128, 32u16);
        // C s_2824_3: const #1s : i64
        let s_2824_3: i64 = 1;
        // C s_2824_4: cast zx s_2824_3 -> i
        let s_2824_4: i128 = (i128::try_from(s_2824_3).unwrap());
        // C s_2824_5: const #0s : i
        let s_2824_5: i128 = 0;
        // C s_2824_6: add s_2824_5 s_2824_4
        let s_2824_6: i128 = (s_2824_5 + s_2824_4);
        // D s_2824_7: bit-extract s_2824_2 s_2824_0 s_2824_6
        let s_2824_7: Bits = (Bits::new(
            ((s_2824_2) >> (s_2824_0)).value(),
            u16::try_from(s_2824_6).unwrap(),
        ));
        // D s_2824_8: cast reint s_2824_7 -> u8
        let s_2824_8: bool = ((s_2824_7.value()) != 0);
        // D s_2824_9: cast zx s_2824_8 -> bv
        let s_2824_9: Bits = Bits::new(s_2824_8 as u128, 1u16);
        // C s_2824_10: const #0u : u8
        let s_2824_10: bool = false;
        // C s_2824_11: cast zx s_2824_10 -> bv
        let s_2824_11: Bits = Bits::new(s_2824_10 as u128, 1u16);
        // D s_2824_12: cmp-eq s_2824_9 s_2824_11
        let s_2824_12: bool = ((s_2824_9) == (s_2824_11));
        // N s_2824_13: branch s_2824_12 b2827 b2825
        if s_2824_12 {
            return block_2827(state, tracer, fn_state);
        } else {
            return block_2825(state, tracer, fn_state);
        };
    }
    fn block_2825<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2825_0: const #0u : u8
        let s_2825_0: bool = false;
        // D s_2825_1: write-var gs#404768 <= s_2825_0
        fn_state.gs_404768 = s_2825_0;
        // N s_2825_2: jump b2826
        return block_2826(state, tracer, fn_state);
    }
    fn block_2826<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2826_0: read-var gs#404768:u8
        let s_2826_0: bool = fn_state.gs_404768;
        // D s_2826_1: write-var gs#404769 <= s_2826_0
        fn_state.gs_404769 = s_2826_0;
        // N s_2826_2: jump b377
        return block_377(state, tracer, fn_state);
    }
    fn block_2827<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2827_0: const #4s : i
        let s_2827_0: i128 = 4;
        // D s_2827_1: read-var u#32516:u32
        let s_2827_1: u32 = fn_state.u_32516;
        // D s_2827_2: cast zx s_2827_1 -> bv
        let s_2827_2: Bits = Bits::new(s_2827_1 as u128, 32u16);
        // C s_2827_3: const #1s : i64
        let s_2827_3: i64 = 1;
        // C s_2827_4: cast zx s_2827_3 -> i
        let s_2827_4: i128 = (i128::try_from(s_2827_3).unwrap());
        // C s_2827_5: const #0s : i
        let s_2827_5: i128 = 0;
        // C s_2827_6: add s_2827_5 s_2827_4
        let s_2827_6: i128 = (s_2827_5 + s_2827_4);
        // D s_2827_7: bit-extract s_2827_2 s_2827_0 s_2827_6
        let s_2827_7: Bits = (Bits::new(
            ((s_2827_2) >> (s_2827_0)).value(),
            u16::try_from(s_2827_6).unwrap(),
        ));
        // D s_2827_8: cast reint s_2827_7 -> u8
        let s_2827_8: bool = ((s_2827_7.value()) != 0);
        // D s_2827_9: cast zx s_2827_8 -> bv
        let s_2827_9: Bits = Bits::new(s_2827_8 as u128, 1u16);
        // C s_2827_10: const #1u : u8
        let s_2827_10: bool = true;
        // C s_2827_11: cast zx s_2827_10 -> bv
        let s_2827_11: Bits = Bits::new(s_2827_10 as u128, 1u16);
        // D s_2827_12: cmp-eq s_2827_9 s_2827_11
        let s_2827_12: bool = ((s_2827_9) == (s_2827_11));
        // D s_2827_13: write-var gs#404768 <= s_2827_12
        fn_state.gs_404768 = s_2827_12;
        // N s_2827_14: jump b2826
        return block_2826(state, tracer, fn_state);
    }
    fn block_2828<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2828_0: const #28s : i
        let s_2828_0: i128 = 28;
        // C s_2828_1: const #4s : i
        let s_2828_1: i128 = 4;
        // D s_2828_2: read-var u#32507:u32
        let s_2828_2: u32 = fn_state.u_32507;
        // D s_2828_3: cast zx s_2828_2 -> bv
        let s_2828_3: Bits = Bits::new(s_2828_2 as u128, 32u16);
        // D s_2828_4: bit-extract s_2828_3 s_2828_0 s_2828_1
        let s_2828_4: Bits = (Bits::new(
            ((s_2828_3) >> (s_2828_0)).value(),
            u16::try_from(s_2828_1).unwrap(),
        ));
        // D s_2828_5: cast reint s_2828_4 -> u8
        let s_2828_5: u8 = (s_2828_4.value() as u8);
        // D s_2828_6: cast zx s_2828_5 -> bv
        let s_2828_6: Bits = Bits::new(s_2828_5 as u128, 4u16);
        // C s_2828_7: const #15u : u8
        let s_2828_7: u8 = 15;
        // C s_2828_8: cast zx s_2828_7 -> bv
        let s_2828_8: Bits = Bits::new(s_2828_7 as u128, 4u16);
        // D s_2828_9: cmp-ne s_2828_6 s_2828_8
        let s_2828_9: bool = ((s_2828_6) != (s_2828_8));
        // N s_2828_10: branch s_2828_9 b2831 b2829
        if s_2828_9 {
            return block_2831(state, tracer, fn_state);
        } else {
            return block_2829(state, tracer, fn_state);
        };
    }
    fn block_2829<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2829_0: const #0u : u8
        let s_2829_0: bool = false;
        // D s_2829_1: write-var gs#404743 <= s_2829_0
        fn_state.gs_404743 = s_2829_0;
        // N s_2829_2: jump b2830
        return block_2830(state, tracer, fn_state);
    }
    fn block_2830<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2830_0: read-var gs#404743:u8
        let s_2830_0: bool = fn_state.gs_404743;
        // D s_2830_1: write-var gs#404744 <= s_2830_0
        fn_state.gs_404744 = s_2830_0;
        // N s_2830_2: jump b373
        return block_373(state, tracer, fn_state);
    }
    fn block_2831<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2831_0: const #2905s : i
        let s_2831_0: i128 = 2905;
        // C s_2831_1: const #14696u : u32
        let s_2831_1: u32 = 14696;
        // D s_2831_2: read-reg s_2831_1:i
        let s_2831_2: i128 = {
            let value = state.read_register::<i128>(s_2831_1 as isize);
            tracer.read_register(s_2831_1 as isize, value);
            value
        };
        // D s_2831_3: cmp-lt s_2831_2 s_2831_0
        let s_2831_3: bool = ((s_2831_2) < (s_2831_0));
        // D s_2831_4: write-var gs#404743 <= s_2831_3
        fn_state.gs_404743 = s_2831_3;
        // N s_2831_5: jump b2830
        return block_2830(state, tracer, fn_state);
    }
    fn block_2832<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2832_0: const #4s : i
        let s_2832_0: i128 = 4;
        // D s_2832_1: read-var u#32507:u32
        let s_2832_1: u32 = fn_state.u_32507;
        // D s_2832_2: cast zx s_2832_1 -> bv
        let s_2832_2: Bits = Bits::new(s_2832_1 as u128, 32u16);
        // C s_2832_3: const #1s : i64
        let s_2832_3: i64 = 1;
        // C s_2832_4: cast zx s_2832_3 -> i
        let s_2832_4: i128 = (i128::try_from(s_2832_3).unwrap());
        // C s_2832_5: const #0s : i
        let s_2832_5: i128 = 0;
        // C s_2832_6: add s_2832_5 s_2832_4
        let s_2832_6: i128 = (s_2832_5 + s_2832_4);
        // D s_2832_7: bit-extract s_2832_2 s_2832_0 s_2832_6
        let s_2832_7: Bits = (Bits::new(
            ((s_2832_2) >> (s_2832_0)).value(),
            u16::try_from(s_2832_6).unwrap(),
        ));
        // D s_2832_8: cast reint s_2832_7 -> u8
        let s_2832_8: bool = ((s_2832_7.value()) != 0);
        // D s_2832_9: cast zx s_2832_8 -> bv
        let s_2832_9: Bits = Bits::new(s_2832_8 as u128, 1u16);
        // C s_2832_10: const #0u : u8
        let s_2832_10: bool = false;
        // C s_2832_11: cast zx s_2832_10 -> bv
        let s_2832_11: Bits = Bits::new(s_2832_10 as u128, 1u16);
        // D s_2832_12: cmp-eq s_2832_9 s_2832_11
        let s_2832_12: bool = ((s_2832_9) == (s_2832_11));
        // D s_2832_13: write-var gs#404739 <= s_2832_12
        fn_state.gs_404739 = s_2832_12;
        // N s_2832_14: jump b371
        return block_371(state, tracer, fn_state);
    }
    fn block_2833<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2833_0: const #28s : i
        let s_2833_0: i128 = 28;
        // C s_2833_1: const #4s : i
        let s_2833_1: i128 = 4;
        // D s_2833_2: read-var u#32500:u32
        let s_2833_2: u32 = fn_state.u_32500;
        // D s_2833_3: cast zx s_2833_2 -> bv
        let s_2833_3: Bits = Bits::new(s_2833_2 as u128, 32u16);
        // D s_2833_4: bit-extract s_2833_3 s_2833_0 s_2833_1
        let s_2833_4: Bits = (Bits::new(
            ((s_2833_3) >> (s_2833_0)).value(),
            u16::try_from(s_2833_1).unwrap(),
        ));
        // D s_2833_5: cast reint s_2833_4 -> u8
        let s_2833_5: u8 = (s_2833_4.value() as u8);
        // D s_2833_6: cast zx s_2833_5 -> bv
        let s_2833_6: Bits = Bits::new(s_2833_5 as u128, 4u16);
        // C s_2833_7: const #15u : u8
        let s_2833_7: u8 = 15;
        // C s_2833_8: cast zx s_2833_7 -> bv
        let s_2833_8: Bits = Bits::new(s_2833_7 as u128, 4u16);
        // D s_2833_9: cmp-ne s_2833_6 s_2833_8
        let s_2833_9: bool = ((s_2833_6) != (s_2833_8));
        // N s_2833_10: branch s_2833_9 b2836 b2834
        if s_2833_9 {
            return block_2836(state, tracer, fn_state);
        } else {
            return block_2834(state, tracer, fn_state);
        };
    }
    fn block_2834<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2834_0: const #0u : u8
        let s_2834_0: bool = false;
        // D s_2834_1: write-var gs#404720 <= s_2834_0
        fn_state.gs_404720 = s_2834_0;
        // N s_2834_2: jump b2835
        return block_2835(state, tracer, fn_state);
    }
    fn block_2835<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2835_0: read-var gs#404720:u8
        let s_2835_0: bool = fn_state.gs_404720;
        // D s_2835_1: write-var gs#404721 <= s_2835_0
        fn_state.gs_404721 = s_2835_0;
        // N s_2835_2: jump b367
        return block_367(state, tracer, fn_state);
    }
    fn block_2836<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2836_0: const #2903s : i
        let s_2836_0: i128 = 2903;
        // C s_2836_1: const #14696u : u32
        let s_2836_1: u32 = 14696;
        // D s_2836_2: read-reg s_2836_1:i
        let s_2836_2: i128 = {
            let value = state.read_register::<i128>(s_2836_1 as isize);
            tracer.read_register(s_2836_1 as isize, value);
            value
        };
        // D s_2836_3: cmp-lt s_2836_2 s_2836_0
        let s_2836_3: bool = ((s_2836_2) < (s_2836_0));
        // D s_2836_4: write-var gs#404720 <= s_2836_3
        fn_state.gs_404720 = s_2836_3;
        // N s_2836_5: jump b2835
        return block_2835(state, tracer, fn_state);
    }
    fn block_2837<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2837_0: const #28s : i
        let s_2837_0: i128 = 28;
        // C s_2837_1: const #4s : i
        let s_2837_1: i128 = 4;
        // D s_2837_2: read-var u#32497:u32
        let s_2837_2: u32 = fn_state.u_32497;
        // D s_2837_3: cast zx s_2837_2 -> bv
        let s_2837_3: Bits = Bits::new(s_2837_2 as u128, 32u16);
        // D s_2837_4: bit-extract s_2837_3 s_2837_0 s_2837_1
        let s_2837_4: Bits = (Bits::new(
            ((s_2837_3) >> (s_2837_0)).value(),
            u16::try_from(s_2837_1).unwrap(),
        ));
        // D s_2837_5: cast reint s_2837_4 -> u8
        let s_2837_5: u8 = (s_2837_4.value() as u8);
        // D s_2837_6: cast zx s_2837_5 -> bv
        let s_2837_6: Bits = Bits::new(s_2837_5 as u128, 4u16);
        // C s_2837_7: const #15u : u8
        let s_2837_7: u8 = 15;
        // C s_2837_8: cast zx s_2837_7 -> bv
        let s_2837_8: Bits = Bits::new(s_2837_7 as u128, 4u16);
        // D s_2837_9: cmp-ne s_2837_6 s_2837_8
        let s_2837_9: bool = ((s_2837_6) != (s_2837_8));
        // N s_2837_10: branch s_2837_9 b2840 b2838
        if s_2837_9 {
            return block_2840(state, tracer, fn_state);
        } else {
            return block_2838(state, tracer, fn_state);
        };
    }
    fn block_2838<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2838_0: const #0u : u8
        let s_2838_0: bool = false;
        // D s_2838_1: write-var gs#404683 <= s_2838_0
        fn_state.gs_404683 = s_2838_0;
        // N s_2838_2: jump b2839
        return block_2839(state, tracer, fn_state);
    }
    fn block_2839<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2839_0: read-var gs#404683:u8
        let s_2839_0: bool = fn_state.gs_404683;
        // D s_2839_1: write-var gs#404684 <= s_2839_0
        fn_state.gs_404684 = s_2839_0;
        // N s_2839_2: jump b340
        return block_340(state, tracer, fn_state);
    }
    fn block_2840<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2840_0: const #2897s : i
        let s_2840_0: i128 = 2897;
        // C s_2840_1: const #14696u : u32
        let s_2840_1: u32 = 14696;
        // D s_2840_2: read-reg s_2840_1:i
        let s_2840_2: i128 = {
            let value = state.read_register::<i128>(s_2840_1 as isize);
            tracer.read_register(s_2840_1 as isize, value);
            value
        };
        // D s_2840_3: cmp-lt s_2840_2 s_2840_0
        let s_2840_3: bool = ((s_2840_2) < (s_2840_0));
        // D s_2840_4: write-var gs#404683 <= s_2840_3
        fn_state.gs_404683 = s_2840_3;
        // N s_2840_5: jump b2839
        return block_2839(state, tracer, fn_state);
    }
    fn block_2841<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2841_0: const #28s : i
        let s_2841_0: i128 = 28;
        // C s_2841_1: const #4s : i
        let s_2841_1: i128 = 4;
        // D s_2841_2: read-var u#32490:u32
        let s_2841_2: u32 = fn_state.u_32490;
        // D s_2841_3: cast zx s_2841_2 -> bv
        let s_2841_3: Bits = Bits::new(s_2841_2 as u128, 32u16);
        // D s_2841_4: bit-extract s_2841_3 s_2841_0 s_2841_1
        let s_2841_4: Bits = (Bits::new(
            ((s_2841_3) >> (s_2841_0)).value(),
            u16::try_from(s_2841_1).unwrap(),
        ));
        // D s_2841_5: cast reint s_2841_4 -> u8
        let s_2841_5: u8 = (s_2841_4.value() as u8);
        // D s_2841_6: cast zx s_2841_5 -> bv
        let s_2841_6: Bits = Bits::new(s_2841_5 as u128, 4u16);
        // C s_2841_7: const #15u : u8
        let s_2841_7: u8 = 15;
        // C s_2841_8: cast zx s_2841_7 -> bv
        let s_2841_8: Bits = Bits::new(s_2841_7 as u128, 4u16);
        // D s_2841_9: cmp-ne s_2841_6 s_2841_8
        let s_2841_9: bool = ((s_2841_6) != (s_2841_8));
        // N s_2841_10: branch s_2841_9 b2844 b2842
        if s_2841_9 {
            return block_2844(state, tracer, fn_state);
        } else {
            return block_2842(state, tracer, fn_state);
        };
    }
    fn block_2842<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2842_0: const #0u : u8
        let s_2842_0: bool = false;
        // D s_2842_1: write-var gs#404652 <= s_2842_0
        fn_state.gs_404652 = s_2842_0;
        // N s_2842_2: jump b2843
        return block_2843(state, tracer, fn_state);
    }
    fn block_2843<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2843_0: read-var gs#404652:u8
        let s_2843_0: bool = fn_state.gs_404652;
        // D s_2843_1: write-var gs#404653 <= s_2843_0
        fn_state.gs_404653 = s_2843_0;
        // N s_2843_2: jump b325
        return block_325(state, tracer, fn_state);
    }
    fn block_2844<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2844_0: const #2896s : i
        let s_2844_0: i128 = 2896;
        // C s_2844_1: const #14696u : u32
        let s_2844_1: u32 = 14696;
        // D s_2844_2: read-reg s_2844_1:i
        let s_2844_2: i128 = {
            let value = state.read_register::<i128>(s_2844_1 as isize);
            tracer.read_register(s_2844_1 as isize, value);
            value
        };
        // D s_2844_3: cmp-lt s_2844_2 s_2844_0
        let s_2844_3: bool = ((s_2844_2) < (s_2844_0));
        // D s_2844_4: write-var gs#404652 <= s_2844_3
        fn_state.gs_404652 = s_2844_3;
        // N s_2844_5: jump b2843
        return block_2843(state, tracer, fn_state);
    }
    fn block_2845<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2845_0: const #12s : i
        let s_2845_0: i128 = 12;
        // D s_2845_1: read-var u#32490:u32
        let s_2845_1: u32 = fn_state.u_32490;
        // D s_2845_2: cast zx s_2845_1 -> bv
        let s_2845_2: Bits = Bits::new(s_2845_1 as u128, 32u16);
        // C s_2845_3: const #1s : i64
        let s_2845_3: i64 = 1;
        // C s_2845_4: cast zx s_2845_3 -> i
        let s_2845_4: i128 = (i128::try_from(s_2845_3).unwrap());
        // C s_2845_5: const #3s : i
        let s_2845_5: i128 = 3;
        // C s_2845_6: add s_2845_5 s_2845_4
        let s_2845_6: i128 = (s_2845_5 + s_2845_4);
        // D s_2845_7: bit-extract s_2845_2 s_2845_0 s_2845_6
        let s_2845_7: Bits = (Bits::new(
            ((s_2845_2) >> (s_2845_0)).value(),
            u16::try_from(s_2845_6).unwrap(),
        ));
        // D s_2845_8: cast reint s_2845_7 -> u8
        let s_2845_8: u8 = (s_2845_7.value() as u8);
        // D s_2845_9: cast zx s_2845_8 -> bv
        let s_2845_9: Bits = Bits::new(s_2845_8 as u128, 4u16);
        // C s_2845_10: const #0u : u8
        let s_2845_10: u8 = 0;
        // C s_2845_11: cast zx s_2845_10 -> bv
        let s_2845_11: Bits = Bits::new(s_2845_10 as u128, 4u16);
        // D s_2845_12: cmp-eq s_2845_9 s_2845_11
        let s_2845_12: bool = ((s_2845_9) == (s_2845_11));
        // N s_2845_13: branch s_2845_12 b2848 b2846
        if s_2845_12 {
            return block_2848(state, tracer, fn_state);
        } else {
            return block_2846(state, tracer, fn_state);
        };
    }
    fn block_2846<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2846_0: const #0u : u8
        let s_2846_0: bool = false;
        // D s_2846_1: write-var gs#404647 <= s_2846_0
        fn_state.gs_404647 = s_2846_0;
        // N s_2846_2: jump b2847
        return block_2847(state, tracer, fn_state);
    }
    fn block_2847<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2847_0: read-var gs#404647:u8
        let s_2847_0: bool = fn_state.gs_404647;
        // D s_2847_1: write-var gs#404648 <= s_2847_0
        fn_state.gs_404648 = s_2847_0;
        // N s_2847_2: jump b323
        return block_323(state, tracer, fn_state);
    }
    fn block_2848<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2848_0: const #7s : i
        let s_2848_0: i128 = 7;
        // D s_2848_1: read-var u#32490:u32
        let s_2848_1: u32 = fn_state.u_32490;
        // D s_2848_2: cast zx s_2848_1 -> bv
        let s_2848_2: Bits = Bits::new(s_2848_1 as u128, 32u16);
        // C s_2848_3: const #1s : i64
        let s_2848_3: i64 = 1;
        // C s_2848_4: cast zx s_2848_3 -> i
        let s_2848_4: i128 = (i128::try_from(s_2848_3).unwrap());
        // C s_2848_5: const #0s : i
        let s_2848_5: i128 = 0;
        // C s_2848_6: add s_2848_5 s_2848_4
        let s_2848_6: i128 = (s_2848_5 + s_2848_4);
        // D s_2848_7: bit-extract s_2848_2 s_2848_0 s_2848_6
        let s_2848_7: Bits = (Bits::new(
            ((s_2848_2) >> (s_2848_0)).value(),
            u16::try_from(s_2848_6).unwrap(),
        ));
        // D s_2848_8: cast reint s_2848_7 -> u8
        let s_2848_8: bool = ((s_2848_7.value()) != 0);
        // D s_2848_9: cast zx s_2848_8 -> bv
        let s_2848_9: Bits = Bits::new(s_2848_8 as u128, 1u16);
        // C s_2848_10: const #0u : u8
        let s_2848_10: bool = false;
        // C s_2848_11: cast zx s_2848_10 -> bv
        let s_2848_11: Bits = Bits::new(s_2848_10 as u128, 1u16);
        // D s_2848_12: cmp-eq s_2848_9 s_2848_11
        let s_2848_12: bool = ((s_2848_9) == (s_2848_11));
        // N s_2848_13: branch s_2848_12 b2851 b2849
        if s_2848_12 {
            return block_2851(state, tracer, fn_state);
        } else {
            return block_2849(state, tracer, fn_state);
        };
    }
    fn block_2849<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2849_0: const #0u : u8
        let s_2849_0: bool = false;
        // D s_2849_1: write-var gs#404646 <= s_2849_0
        fn_state.gs_404646 = s_2849_0;
        // N s_2849_2: jump b2850
        return block_2850(state, tracer, fn_state);
    }
    fn block_2850<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2850_0: read-var gs#404646:u8
        let s_2850_0: bool = fn_state.gs_404646;
        // D s_2850_1: write-var gs#404647 <= s_2850_0
        fn_state.gs_404647 = s_2850_0;
        // N s_2850_2: jump b2847
        return block_2847(state, tracer, fn_state);
    }
    fn block_2851<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2851_0: const #4s : i
        let s_2851_0: i128 = 4;
        // D s_2851_1: read-var u#32490:u32
        let s_2851_1: u32 = fn_state.u_32490;
        // D s_2851_2: cast zx s_2851_1 -> bv
        let s_2851_2: Bits = Bits::new(s_2851_1 as u128, 32u16);
        // C s_2851_3: const #1s : i64
        let s_2851_3: i64 = 1;
        // C s_2851_4: cast zx s_2851_3 -> i
        let s_2851_4: i128 = (i128::try_from(s_2851_3).unwrap());
        // C s_2851_5: const #0s : i
        let s_2851_5: i128 = 0;
        // C s_2851_6: add s_2851_5 s_2851_4
        let s_2851_6: i128 = (s_2851_5 + s_2851_4);
        // D s_2851_7: bit-extract s_2851_2 s_2851_0 s_2851_6
        let s_2851_7: Bits = (Bits::new(
            ((s_2851_2) >> (s_2851_0)).value(),
            u16::try_from(s_2851_6).unwrap(),
        ));
        // D s_2851_8: cast reint s_2851_7 -> u8
        let s_2851_8: bool = ((s_2851_7.value()) != 0);
        // D s_2851_9: cast zx s_2851_8 -> bv
        let s_2851_9: Bits = Bits::new(s_2851_8 as u128, 1u16);
        // C s_2851_10: const #1u : u8
        let s_2851_10: bool = true;
        // C s_2851_11: cast zx s_2851_10 -> bv
        let s_2851_11: Bits = Bits::new(s_2851_10 as u128, 1u16);
        // D s_2851_12: cmp-eq s_2851_9 s_2851_11
        let s_2851_12: bool = ((s_2851_9) == (s_2851_11));
        // D s_2851_13: write-var gs#404646 <= s_2851_12
        fn_state.gs_404646 = s_2851_12;
        // N s_2851_14: jump b2850
        return block_2850(state, tracer, fn_state);
    }
    fn block_2852<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2852_0: const #28s : i
        let s_2852_0: i128 = 28;
        // C s_2852_1: const #4s : i
        let s_2852_1: i128 = 4;
        // D s_2852_2: read-var u#32483:u32
        let s_2852_2: u32 = fn_state.u_32483;
        // D s_2852_3: cast zx s_2852_2 -> bv
        let s_2852_3: Bits = Bits::new(s_2852_2 as u128, 32u16);
        // D s_2852_4: bit-extract s_2852_3 s_2852_0 s_2852_1
        let s_2852_4: Bits = (Bits::new(
            ((s_2852_3) >> (s_2852_0)).value(),
            u16::try_from(s_2852_1).unwrap(),
        ));
        // D s_2852_5: cast reint s_2852_4 -> u8
        let s_2852_5: u8 = (s_2852_4.value() as u8);
        // D s_2852_6: cast zx s_2852_5 -> bv
        let s_2852_6: Bits = Bits::new(s_2852_5 as u128, 4u16);
        // C s_2852_7: const #15u : u8
        let s_2852_7: u8 = 15;
        // C s_2852_8: cast zx s_2852_7 -> bv
        let s_2852_8: Bits = Bits::new(s_2852_7 as u128, 4u16);
        // D s_2852_9: cmp-ne s_2852_6 s_2852_8
        let s_2852_9: bool = ((s_2852_6) != (s_2852_8));
        // N s_2852_10: branch s_2852_9 b2855 b2853
        if s_2852_9 {
            return block_2855(state, tracer, fn_state);
        } else {
            return block_2853(state, tracer, fn_state);
        };
    }
    fn block_2853<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2853_0: const #0u : u8
        let s_2853_0: bool = false;
        // D s_2853_1: write-var gs#404612 <= s_2853_0
        fn_state.gs_404612 = s_2853_0;
        // N s_2853_2: jump b2854
        return block_2854(state, tracer, fn_state);
    }
    fn block_2854<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2854_0: read-var gs#404612:u8
        let s_2854_0: bool = fn_state.gs_404612;
        // D s_2854_1: write-var gs#404613 <= s_2854_0
        fn_state.gs_404613 = s_2854_0;
        // N s_2854_2: jump b308
        return block_308(state, tracer, fn_state);
    }
    fn block_2855<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2855_0: const #2892s : i
        let s_2855_0: i128 = 2892;
        // C s_2855_1: const #14696u : u32
        let s_2855_1: u32 = 14696;
        // D s_2855_2: read-reg s_2855_1:i
        let s_2855_2: i128 = {
            let value = state.read_register::<i128>(s_2855_1 as isize);
            tracer.read_register(s_2855_1 as isize, value);
            value
        };
        // D s_2855_3: cmp-lt s_2855_2 s_2855_0
        let s_2855_3: bool = ((s_2855_2) < (s_2855_0));
        // D s_2855_4: write-var gs#404612 <= s_2855_3
        fn_state.gs_404612 = s_2855_3;
        // N s_2855_5: jump b2854
        return block_2854(state, tracer, fn_state);
    }
    fn block_2856<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2856_0: const #12s : i
        let s_2856_0: i128 = 12;
        // D s_2856_1: read-var u#32483:u32
        let s_2856_1: u32 = fn_state.u_32483;
        // D s_2856_2: cast zx s_2856_1 -> bv
        let s_2856_2: Bits = Bits::new(s_2856_1 as u128, 32u16);
        // C s_2856_3: const #1s : i64
        let s_2856_3: i64 = 1;
        // C s_2856_4: cast zx s_2856_3 -> i
        let s_2856_4: i128 = (i128::try_from(s_2856_3).unwrap());
        // C s_2856_5: const #3s : i
        let s_2856_5: i128 = 3;
        // C s_2856_6: add s_2856_5 s_2856_4
        let s_2856_6: i128 = (s_2856_5 + s_2856_4);
        // D s_2856_7: bit-extract s_2856_2 s_2856_0 s_2856_6
        let s_2856_7: Bits = (Bits::new(
            ((s_2856_2) >> (s_2856_0)).value(),
            u16::try_from(s_2856_6).unwrap(),
        ));
        // D s_2856_8: cast reint s_2856_7 -> u8
        let s_2856_8: u8 = (s_2856_7.value() as u8);
        // D s_2856_9: cast zx s_2856_8 -> bv
        let s_2856_9: Bits = Bits::new(s_2856_8 as u128, 4u16);
        // C s_2856_10: const #0u : u8
        let s_2856_10: u8 = 0;
        // C s_2856_11: cast zx s_2856_10 -> bv
        let s_2856_11: Bits = Bits::new(s_2856_10 as u128, 4u16);
        // D s_2856_12: cmp-eq s_2856_9 s_2856_11
        let s_2856_12: bool = ((s_2856_9) == (s_2856_11));
        // N s_2856_13: branch s_2856_12 b2859 b2857
        if s_2856_12 {
            return block_2859(state, tracer, fn_state);
        } else {
            return block_2857(state, tracer, fn_state);
        };
    }
    fn block_2857<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2857_0: const #0u : u8
        let s_2857_0: bool = false;
        // D s_2857_1: write-var gs#404607 <= s_2857_0
        fn_state.gs_404607 = s_2857_0;
        // N s_2857_2: jump b2858
        return block_2858(state, tracer, fn_state);
    }
    fn block_2858<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2858_0: read-var gs#404607:u8
        let s_2858_0: bool = fn_state.gs_404607;
        // D s_2858_1: write-var gs#404608 <= s_2858_0
        fn_state.gs_404608 = s_2858_0;
        // N s_2858_2: jump b306
        return block_306(state, tracer, fn_state);
    }
    fn block_2859<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2859_0: const #4s : i
        let s_2859_0: i128 = 4;
        // D s_2859_1: read-var u#32483:u32
        let s_2859_1: u32 = fn_state.u_32483;
        // D s_2859_2: cast zx s_2859_1 -> bv
        let s_2859_2: Bits = Bits::new(s_2859_1 as u128, 32u16);
        // C s_2859_3: const #1s : i64
        let s_2859_3: i64 = 1;
        // C s_2859_4: cast zx s_2859_3 -> i
        let s_2859_4: i128 = (i128::try_from(s_2859_3).unwrap());
        // C s_2859_5: const #0s : i
        let s_2859_5: i128 = 0;
        // C s_2859_6: add s_2859_5 s_2859_4
        let s_2859_6: i128 = (s_2859_5 + s_2859_4);
        // D s_2859_7: bit-extract s_2859_2 s_2859_0 s_2859_6
        let s_2859_7: Bits = (Bits::new(
            ((s_2859_2) >> (s_2859_0)).value(),
            u16::try_from(s_2859_6).unwrap(),
        ));
        // D s_2859_8: cast reint s_2859_7 -> u8
        let s_2859_8: bool = ((s_2859_7.value()) != 0);
        // D s_2859_9: cast zx s_2859_8 -> bv
        let s_2859_9: Bits = Bits::new(s_2859_8 as u128, 1u16);
        // C s_2859_10: const #0u : u8
        let s_2859_10: bool = false;
        // C s_2859_11: cast zx s_2859_10 -> bv
        let s_2859_11: Bits = Bits::new(s_2859_10 as u128, 1u16);
        // D s_2859_12: cmp-eq s_2859_9 s_2859_11
        let s_2859_12: bool = ((s_2859_9) == (s_2859_11));
        // D s_2859_13: write-var gs#404607 <= s_2859_12
        fn_state.gs_404607 = s_2859_12;
        // N s_2859_14: jump b2858
        return block_2858(state, tracer, fn_state);
    }
    fn block_2860<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2860_0: const #28s : i
        let s_2860_0: i128 = 28;
        // C s_2860_1: const #4s : i
        let s_2860_1: i128 = 4;
        // D s_2860_2: read-var u#32478:u32
        let s_2860_2: u32 = fn_state.u_32478;
        // D s_2860_3: cast zx s_2860_2 -> bv
        let s_2860_3: Bits = Bits::new(s_2860_2 as u128, 32u16);
        // D s_2860_4: bit-extract s_2860_3 s_2860_0 s_2860_1
        let s_2860_4: Bits = (Bits::new(
            ((s_2860_3) >> (s_2860_0)).value(),
            u16::try_from(s_2860_1).unwrap(),
        ));
        // D s_2860_5: cast reint s_2860_4 -> u8
        let s_2860_5: u8 = (s_2860_4.value() as u8);
        // D s_2860_6: cast zx s_2860_5 -> bv
        let s_2860_6: Bits = Bits::new(s_2860_5 as u128, 4u16);
        // C s_2860_7: const #15u : u8
        let s_2860_7: u8 = 15;
        // C s_2860_8: cast zx s_2860_7 -> bv
        let s_2860_8: Bits = Bits::new(s_2860_7 as u128, 4u16);
        // D s_2860_9: cmp-ne s_2860_6 s_2860_8
        let s_2860_9: bool = ((s_2860_6) != (s_2860_8));
        // N s_2860_10: branch s_2860_9 b2863 b2861
        if s_2860_9 {
            return block_2863(state, tracer, fn_state);
        } else {
            return block_2861(state, tracer, fn_state);
        };
    }
    fn block_2861<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2861_0: const #0u : u8
        let s_2861_0: bool = false;
        // D s_2861_1: write-var gs#404579 <= s_2861_0
        fn_state.gs_404579 = s_2861_0;
        // N s_2861_2: jump b2862
        return block_2862(state, tracer, fn_state);
    }
    fn block_2862<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2862_0: read-var gs#404579:u8
        let s_2862_0: bool = fn_state.gs_404579;
        // D s_2862_1: write-var gs#404580 <= s_2862_0
        fn_state.gs_404580 = s_2862_0;
        // N s_2862_2: jump b291
        return block_291(state, tracer, fn_state);
    }
    fn block_2863<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2863_0: const #2889s : i
        let s_2863_0: i128 = 2889;
        // C s_2863_1: const #14696u : u32
        let s_2863_1: u32 = 14696;
        // D s_2863_2: read-reg s_2863_1:i
        let s_2863_2: i128 = {
            let value = state.read_register::<i128>(s_2863_1 as isize);
            tracer.read_register(s_2863_1 as isize, value);
            value
        };
        // D s_2863_3: cmp-lt s_2863_2 s_2863_0
        let s_2863_3: bool = ((s_2863_2) < (s_2863_0));
        // D s_2863_4: write-var gs#404579 <= s_2863_3
        fn_state.gs_404579 = s_2863_3;
        // N s_2863_5: jump b2862
        return block_2862(state, tracer, fn_state);
    }
    fn block_2864<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2864_0: const #12s : i
        let s_2864_0: i128 = 12;
        // D s_2864_1: read-var u#32478:u32
        let s_2864_1: u32 = fn_state.u_32478;
        // D s_2864_2: cast zx s_2864_1 -> bv
        let s_2864_2: Bits = Bits::new(s_2864_1 as u128, 32u16);
        // C s_2864_3: const #1s : i64
        let s_2864_3: i64 = 1;
        // C s_2864_4: cast zx s_2864_3 -> i
        let s_2864_4: i128 = (i128::try_from(s_2864_3).unwrap());
        // C s_2864_5: const #3s : i
        let s_2864_5: i128 = 3;
        // C s_2864_6: add s_2864_5 s_2864_4
        let s_2864_6: i128 = (s_2864_5 + s_2864_4);
        // D s_2864_7: bit-extract s_2864_2 s_2864_0 s_2864_6
        let s_2864_7: Bits = (Bits::new(
            ((s_2864_2) >> (s_2864_0)).value(),
            u16::try_from(s_2864_6).unwrap(),
        ));
        // D s_2864_8: cast reint s_2864_7 -> u8
        let s_2864_8: u8 = (s_2864_7.value() as u8);
        // D s_2864_9: cast zx s_2864_8 -> bv
        let s_2864_9: Bits = Bits::new(s_2864_8 as u128, 4u16);
        // C s_2864_10: const #0u : u8
        let s_2864_10: u8 = 0;
        // C s_2864_11: cast zx s_2864_10 -> bv
        let s_2864_11: Bits = Bits::new(s_2864_10 as u128, 4u16);
        // D s_2864_12: cmp-eq s_2864_9 s_2864_11
        let s_2864_12: bool = ((s_2864_9) == (s_2864_11));
        // D s_2864_13: write-var gs#404575 <= s_2864_12
        fn_state.gs_404575 = s_2864_12;
        // N s_2864_14: jump b289
        return block_289(state, tracer, fn_state);
    }
    fn block_2865<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2865_0: const #28s : i
        let s_2865_0: i128 = 28;
        // C s_2865_1: const #4s : i
        let s_2865_1: i128 = 4;
        // D s_2865_2: read-var u#32471:u32
        let s_2865_2: u32 = fn_state.u_32471;
        // D s_2865_3: cast zx s_2865_2 -> bv
        let s_2865_3: Bits = Bits::new(s_2865_2 as u128, 32u16);
        // D s_2865_4: bit-extract s_2865_3 s_2865_0 s_2865_1
        let s_2865_4: Bits = (Bits::new(
            ((s_2865_3) >> (s_2865_0)).value(),
            u16::try_from(s_2865_1).unwrap(),
        ));
        // D s_2865_5: cast reint s_2865_4 -> u8
        let s_2865_5: u8 = (s_2865_4.value() as u8);
        // D s_2865_6: cast zx s_2865_5 -> bv
        let s_2865_6: Bits = Bits::new(s_2865_5 as u128, 4u16);
        // C s_2865_7: const #15u : u8
        let s_2865_7: u8 = 15;
        // C s_2865_8: cast zx s_2865_7 -> bv
        let s_2865_8: Bits = Bits::new(s_2865_7 as u128, 4u16);
        // D s_2865_9: cmp-ne s_2865_6 s_2865_8
        let s_2865_9: bool = ((s_2865_6) != (s_2865_8));
        // N s_2865_10: branch s_2865_9 b2868 b2866
        if s_2865_9 {
            return block_2868(state, tracer, fn_state);
        } else {
            return block_2866(state, tracer, fn_state);
        };
    }
    fn block_2866<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2866_0: const #0u : u8
        let s_2866_0: bool = false;
        // D s_2866_1: write-var gs#404545 <= s_2866_0
        fn_state.gs_404545 = s_2866_0;
        // N s_2866_2: jump b2867
        return block_2867(state, tracer, fn_state);
    }
    fn block_2867<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2867_0: read-var gs#404545:u8
        let s_2867_0: bool = fn_state.gs_404545;
        // D s_2867_1: write-var gs#404546 <= s_2867_0
        fn_state.gs_404546 = s_2867_0;
        // N s_2867_2: jump b274
        return block_274(state, tracer, fn_state);
    }
    fn block_2868<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2868_0: const #2888s : i
        let s_2868_0: i128 = 2888;
        // C s_2868_1: const #14696u : u32
        let s_2868_1: u32 = 14696;
        // D s_2868_2: read-reg s_2868_1:i
        let s_2868_2: i128 = {
            let value = state.read_register::<i128>(s_2868_1 as isize);
            tracer.read_register(s_2868_1 as isize, value);
            value
        };
        // D s_2868_3: cmp-lt s_2868_2 s_2868_0
        let s_2868_3: bool = ((s_2868_2) < (s_2868_0));
        // D s_2868_4: write-var gs#404545 <= s_2868_3
        fn_state.gs_404545 = s_2868_3;
        // N s_2868_5: jump b2867
        return block_2867(state, tracer, fn_state);
    }
    fn block_2869<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2869_0: const #12s : i
        let s_2869_0: i128 = 12;
        // D s_2869_1: read-var u#32471:u32
        let s_2869_1: u32 = fn_state.u_32471;
        // D s_2869_2: cast zx s_2869_1 -> bv
        let s_2869_2: Bits = Bits::new(s_2869_1 as u128, 32u16);
        // C s_2869_3: const #1s : i64
        let s_2869_3: i64 = 1;
        // C s_2869_4: cast zx s_2869_3 -> i
        let s_2869_4: i128 = (i128::try_from(s_2869_3).unwrap());
        // C s_2869_5: const #3s : i
        let s_2869_5: i128 = 3;
        // C s_2869_6: add s_2869_5 s_2869_4
        let s_2869_6: i128 = (s_2869_5 + s_2869_4);
        // D s_2869_7: bit-extract s_2869_2 s_2869_0 s_2869_6
        let s_2869_7: Bits = (Bits::new(
            ((s_2869_2) >> (s_2869_0)).value(),
            u16::try_from(s_2869_6).unwrap(),
        ));
        // D s_2869_8: cast reint s_2869_7 -> u8
        let s_2869_8: u8 = (s_2869_7.value() as u8);
        // D s_2869_9: cast zx s_2869_8 -> bv
        let s_2869_9: Bits = Bits::new(s_2869_8 as u128, 4u16);
        // C s_2869_10: const #0u : u8
        let s_2869_10: u8 = 0;
        // C s_2869_11: cast zx s_2869_10 -> bv
        let s_2869_11: Bits = Bits::new(s_2869_10 as u128, 4u16);
        // D s_2869_12: cmp-eq s_2869_9 s_2869_11
        let s_2869_12: bool = ((s_2869_9) == (s_2869_11));
        // N s_2869_13: branch s_2869_12 b2872 b2870
        if s_2869_12 {
            return block_2872(state, tracer, fn_state);
        } else {
            return block_2870(state, tracer, fn_state);
        };
    }
    fn block_2870<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2870_0: const #0u : u8
        let s_2870_0: bool = false;
        // D s_2870_1: write-var gs#404540 <= s_2870_0
        fn_state.gs_404540 = s_2870_0;
        // N s_2870_2: jump b2871
        return block_2871(state, tracer, fn_state);
    }
    fn block_2871<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2871_0: read-var gs#404540:u8
        let s_2871_0: bool = fn_state.gs_404540;
        // D s_2871_1: write-var gs#404541 <= s_2871_0
        fn_state.gs_404541 = s_2871_0;
        // N s_2871_2: jump b272
        return block_272(state, tracer, fn_state);
    }
    fn block_2872<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2872_0: const #7s : i
        let s_2872_0: i128 = 7;
        // D s_2872_1: read-var u#32471:u32
        let s_2872_1: u32 = fn_state.u_32471;
        // D s_2872_2: cast zx s_2872_1 -> bv
        let s_2872_2: Bits = Bits::new(s_2872_1 as u128, 32u16);
        // C s_2872_3: const #1s : i64
        let s_2872_3: i64 = 1;
        // C s_2872_4: cast zx s_2872_3 -> i
        let s_2872_4: i128 = (i128::try_from(s_2872_3).unwrap());
        // C s_2872_5: const #0s : i
        let s_2872_5: i128 = 0;
        // C s_2872_6: add s_2872_5 s_2872_4
        let s_2872_6: i128 = (s_2872_5 + s_2872_4);
        // D s_2872_7: bit-extract s_2872_2 s_2872_0 s_2872_6
        let s_2872_7: Bits = (Bits::new(
            ((s_2872_2) >> (s_2872_0)).value(),
            u16::try_from(s_2872_6).unwrap(),
        ));
        // D s_2872_8: cast reint s_2872_7 -> u8
        let s_2872_8: bool = ((s_2872_7.value()) != 0);
        // D s_2872_9: cast zx s_2872_8 -> bv
        let s_2872_9: Bits = Bits::new(s_2872_8 as u128, 1u16);
        // C s_2872_10: const #0u : u8
        let s_2872_10: bool = false;
        // C s_2872_11: cast zx s_2872_10 -> bv
        let s_2872_11: Bits = Bits::new(s_2872_10 as u128, 1u16);
        // D s_2872_12: cmp-eq s_2872_9 s_2872_11
        let s_2872_12: bool = ((s_2872_9) == (s_2872_11));
        // N s_2872_13: branch s_2872_12 b2875 b2873
        if s_2872_12 {
            return block_2875(state, tracer, fn_state);
        } else {
            return block_2873(state, tracer, fn_state);
        };
    }
    fn block_2873<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2873_0: const #0u : u8
        let s_2873_0: bool = false;
        // D s_2873_1: write-var gs#404539 <= s_2873_0
        fn_state.gs_404539 = s_2873_0;
        // N s_2873_2: jump b2874
        return block_2874(state, tracer, fn_state);
    }
    fn block_2874<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2874_0: read-var gs#404539:u8
        let s_2874_0: bool = fn_state.gs_404539;
        // D s_2874_1: write-var gs#404540 <= s_2874_0
        fn_state.gs_404540 = s_2874_0;
        // N s_2874_2: jump b2871
        return block_2871(state, tracer, fn_state);
    }
    fn block_2875<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2875_0: const #4s : i
        let s_2875_0: i128 = 4;
        // D s_2875_1: read-var u#32471:u32
        let s_2875_1: u32 = fn_state.u_32471;
        // D s_2875_2: cast zx s_2875_1 -> bv
        let s_2875_2: Bits = Bits::new(s_2875_1 as u128, 32u16);
        // C s_2875_3: const #1s : i64
        let s_2875_3: i64 = 1;
        // C s_2875_4: cast zx s_2875_3 -> i
        let s_2875_4: i128 = (i128::try_from(s_2875_3).unwrap());
        // C s_2875_5: const #0s : i
        let s_2875_5: i128 = 0;
        // C s_2875_6: add s_2875_5 s_2875_4
        let s_2875_6: i128 = (s_2875_5 + s_2875_4);
        // D s_2875_7: bit-extract s_2875_2 s_2875_0 s_2875_6
        let s_2875_7: Bits = (Bits::new(
            ((s_2875_2) >> (s_2875_0)).value(),
            u16::try_from(s_2875_6).unwrap(),
        ));
        // D s_2875_8: cast reint s_2875_7 -> u8
        let s_2875_8: bool = ((s_2875_7.value()) != 0);
        // D s_2875_9: cast zx s_2875_8 -> bv
        let s_2875_9: Bits = Bits::new(s_2875_8 as u128, 1u16);
        // C s_2875_10: const #1u : u8
        let s_2875_10: bool = true;
        // C s_2875_11: cast zx s_2875_10 -> bv
        let s_2875_11: Bits = Bits::new(s_2875_10 as u128, 1u16);
        // D s_2875_12: cmp-eq s_2875_9 s_2875_11
        let s_2875_12: bool = ((s_2875_9) == (s_2875_11));
        // D s_2875_13: write-var gs#404539 <= s_2875_12
        fn_state.gs_404539 = s_2875_12;
        // N s_2875_14: jump b2874
        return block_2874(state, tracer, fn_state);
    }
    fn block_2876<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2876_0: const #28s : i
        let s_2876_0: i128 = 28;
        // C s_2876_1: const #4s : i
        let s_2876_1: i128 = 4;
        // D s_2876_2: read-var u#32464:u32
        let s_2876_2: u32 = fn_state.u_32464;
        // D s_2876_3: cast zx s_2876_2 -> bv
        let s_2876_3: Bits = Bits::new(s_2876_2 as u128, 32u16);
        // D s_2876_4: bit-extract s_2876_3 s_2876_0 s_2876_1
        let s_2876_4: Bits = (Bits::new(
            ((s_2876_3) >> (s_2876_0)).value(),
            u16::try_from(s_2876_1).unwrap(),
        ));
        // D s_2876_5: cast reint s_2876_4 -> u8
        let s_2876_5: u8 = (s_2876_4.value() as u8);
        // D s_2876_6: cast zx s_2876_5 -> bv
        let s_2876_6: Bits = Bits::new(s_2876_5 as u128, 4u16);
        // C s_2876_7: const #15u : u8
        let s_2876_7: u8 = 15;
        // C s_2876_8: cast zx s_2876_7 -> bv
        let s_2876_8: Bits = Bits::new(s_2876_7 as u128, 4u16);
        // D s_2876_9: cmp-ne s_2876_6 s_2876_8
        let s_2876_9: bool = ((s_2876_6) != (s_2876_8));
        // N s_2876_10: branch s_2876_9 b2879 b2877
        if s_2876_9 {
            return block_2879(state, tracer, fn_state);
        } else {
            return block_2877(state, tracer, fn_state);
        };
    }
    fn block_2877<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2877_0: const #0u : u8
        let s_2877_0: bool = false;
        // D s_2877_1: write-var gs#404505 <= s_2877_0
        fn_state.gs_404505 = s_2877_0;
        // N s_2877_2: jump b2878
        return block_2878(state, tracer, fn_state);
    }
    fn block_2878<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2878_0: read-var gs#404505:u8
        let s_2878_0: bool = fn_state.gs_404505;
        // D s_2878_1: write-var gs#404506 <= s_2878_0
        fn_state.gs_404506 = s_2878_0;
        // N s_2878_2: jump b257
        return block_257(state, tracer, fn_state);
    }
    fn block_2879<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2879_0: const #2885s : i
        let s_2879_0: i128 = 2885;
        // C s_2879_1: const #14696u : u32
        let s_2879_1: u32 = 14696;
        // D s_2879_2: read-reg s_2879_1:i
        let s_2879_2: i128 = {
            let value = state.read_register::<i128>(s_2879_1 as isize);
            tracer.read_register(s_2879_1 as isize, value);
            value
        };
        // D s_2879_3: cmp-lt s_2879_2 s_2879_0
        let s_2879_3: bool = ((s_2879_2) < (s_2879_0));
        // D s_2879_4: write-var gs#404505 <= s_2879_3
        fn_state.gs_404505 = s_2879_3;
        // N s_2879_5: jump b2878
        return block_2878(state, tracer, fn_state);
    }
    fn block_2880<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2880_0: const #12s : i
        let s_2880_0: i128 = 12;
        // D s_2880_1: read-var u#32464:u32
        let s_2880_1: u32 = fn_state.u_32464;
        // D s_2880_2: cast zx s_2880_1 -> bv
        let s_2880_2: Bits = Bits::new(s_2880_1 as u128, 32u16);
        // C s_2880_3: const #1s : i64
        let s_2880_3: i64 = 1;
        // C s_2880_4: cast zx s_2880_3 -> i
        let s_2880_4: i128 = (i128::try_from(s_2880_3).unwrap());
        // C s_2880_5: const #3s : i
        let s_2880_5: i128 = 3;
        // C s_2880_6: add s_2880_5 s_2880_4
        let s_2880_6: i128 = (s_2880_5 + s_2880_4);
        // D s_2880_7: bit-extract s_2880_2 s_2880_0 s_2880_6
        let s_2880_7: Bits = (Bits::new(
            ((s_2880_2) >> (s_2880_0)).value(),
            u16::try_from(s_2880_6).unwrap(),
        ));
        // D s_2880_8: cast reint s_2880_7 -> u8
        let s_2880_8: u8 = (s_2880_7.value() as u8);
        // D s_2880_9: cast zx s_2880_8 -> bv
        let s_2880_9: Bits = Bits::new(s_2880_8 as u128, 4u16);
        // C s_2880_10: const #0u : u8
        let s_2880_10: u8 = 0;
        // C s_2880_11: cast zx s_2880_10 -> bv
        let s_2880_11: Bits = Bits::new(s_2880_10 as u128, 4u16);
        // D s_2880_12: cmp-eq s_2880_9 s_2880_11
        let s_2880_12: bool = ((s_2880_9) == (s_2880_11));
        // N s_2880_13: branch s_2880_12 b2883 b2881
        if s_2880_12 {
            return block_2883(state, tracer, fn_state);
        } else {
            return block_2881(state, tracer, fn_state);
        };
    }
    fn block_2881<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2881_0: const #0u : u8
        let s_2881_0: bool = false;
        // D s_2881_1: write-var gs#404500 <= s_2881_0
        fn_state.gs_404500 = s_2881_0;
        // N s_2881_2: jump b2882
        return block_2882(state, tracer, fn_state);
    }
    fn block_2882<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2882_0: read-var gs#404500:u8
        let s_2882_0: bool = fn_state.gs_404500;
        // D s_2882_1: write-var gs#404501 <= s_2882_0
        fn_state.gs_404501 = s_2882_0;
        // N s_2882_2: jump b255
        return block_255(state, tracer, fn_state);
    }
    fn block_2883<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2883_0: const #4s : i
        let s_2883_0: i128 = 4;
        // D s_2883_1: read-var u#32464:u32
        let s_2883_1: u32 = fn_state.u_32464;
        // D s_2883_2: cast zx s_2883_1 -> bv
        let s_2883_2: Bits = Bits::new(s_2883_1 as u128, 32u16);
        // C s_2883_3: const #1s : i64
        let s_2883_3: i64 = 1;
        // C s_2883_4: cast zx s_2883_3 -> i
        let s_2883_4: i128 = (i128::try_from(s_2883_3).unwrap());
        // C s_2883_5: const #0s : i
        let s_2883_5: i128 = 0;
        // C s_2883_6: add s_2883_5 s_2883_4
        let s_2883_6: i128 = (s_2883_5 + s_2883_4);
        // D s_2883_7: bit-extract s_2883_2 s_2883_0 s_2883_6
        let s_2883_7: Bits = (Bits::new(
            ((s_2883_2) >> (s_2883_0)).value(),
            u16::try_from(s_2883_6).unwrap(),
        ));
        // D s_2883_8: cast reint s_2883_7 -> u8
        let s_2883_8: bool = ((s_2883_7.value()) != 0);
        // D s_2883_9: cast zx s_2883_8 -> bv
        let s_2883_9: Bits = Bits::new(s_2883_8 as u128, 1u16);
        // C s_2883_10: const #0u : u8
        let s_2883_10: bool = false;
        // C s_2883_11: cast zx s_2883_10 -> bv
        let s_2883_11: Bits = Bits::new(s_2883_10 as u128, 1u16);
        // D s_2883_12: cmp-eq s_2883_9 s_2883_11
        let s_2883_12: bool = ((s_2883_9) == (s_2883_11));
        // D s_2883_13: write-var gs#404500 <= s_2883_12
        fn_state.gs_404500 = s_2883_12;
        // N s_2883_14: jump b2882
        return block_2882(state, tracer, fn_state);
    }
    fn block_2884<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2884_0: const #28s : i
        let s_2884_0: i128 = 28;
        // C s_2884_1: const #4s : i
        let s_2884_1: i128 = 4;
        // D s_2884_2: read-var u#32459:u32
        let s_2884_2: u32 = fn_state.u_32459;
        // D s_2884_3: cast zx s_2884_2 -> bv
        let s_2884_3: Bits = Bits::new(s_2884_2 as u128, 32u16);
        // D s_2884_4: bit-extract s_2884_3 s_2884_0 s_2884_1
        let s_2884_4: Bits = (Bits::new(
            ((s_2884_3) >> (s_2884_0)).value(),
            u16::try_from(s_2884_1).unwrap(),
        ));
        // D s_2884_5: cast reint s_2884_4 -> u8
        let s_2884_5: u8 = (s_2884_4.value() as u8);
        // D s_2884_6: cast zx s_2884_5 -> bv
        let s_2884_6: Bits = Bits::new(s_2884_5 as u128, 4u16);
        // C s_2884_7: const #15u : u8
        let s_2884_7: u8 = 15;
        // C s_2884_8: cast zx s_2884_7 -> bv
        let s_2884_8: Bits = Bits::new(s_2884_7 as u128, 4u16);
        // D s_2884_9: cmp-ne s_2884_6 s_2884_8
        let s_2884_9: bool = ((s_2884_6) != (s_2884_8));
        // N s_2884_10: branch s_2884_9 b2887 b2885
        if s_2884_9 {
            return block_2887(state, tracer, fn_state);
        } else {
            return block_2885(state, tracer, fn_state);
        };
    }
    fn block_2885<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2885_0: const #0u : u8
        let s_2885_0: bool = false;
        // D s_2885_1: write-var gs#404472 <= s_2885_0
        fn_state.gs_404472 = s_2885_0;
        // N s_2885_2: jump b2886
        return block_2886(state, tracer, fn_state);
    }
    fn block_2886<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2886_0: read-var gs#404472:u8
        let s_2886_0: bool = fn_state.gs_404472;
        // D s_2886_1: write-var gs#404473 <= s_2886_0
        fn_state.gs_404473 = s_2886_0;
        // N s_2886_2: jump b240
        return block_240(state, tracer, fn_state);
    }
    fn block_2887<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2887_0: const #2883s : i
        let s_2887_0: i128 = 2883;
        // C s_2887_1: const #14696u : u32
        let s_2887_1: u32 = 14696;
        // D s_2887_2: read-reg s_2887_1:i
        let s_2887_2: i128 = {
            let value = state.read_register::<i128>(s_2887_1 as isize);
            tracer.read_register(s_2887_1 as isize, value);
            value
        };
        // D s_2887_3: cmp-lt s_2887_2 s_2887_0
        let s_2887_3: bool = ((s_2887_2) < (s_2887_0));
        // D s_2887_4: write-var gs#404472 <= s_2887_3
        fn_state.gs_404472 = s_2887_3;
        // N s_2887_5: jump b2886
        return block_2886(state, tracer, fn_state);
    }
    fn block_2888<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2888_0: const #12s : i
        let s_2888_0: i128 = 12;
        // D s_2888_1: read-var u#32459:u32
        let s_2888_1: u32 = fn_state.u_32459;
        // D s_2888_2: cast zx s_2888_1 -> bv
        let s_2888_2: Bits = Bits::new(s_2888_1 as u128, 32u16);
        // C s_2888_3: const #1s : i64
        let s_2888_3: i64 = 1;
        // C s_2888_4: cast zx s_2888_3 -> i
        let s_2888_4: i128 = (i128::try_from(s_2888_3).unwrap());
        // C s_2888_5: const #3s : i
        let s_2888_5: i128 = 3;
        // C s_2888_6: add s_2888_5 s_2888_4
        let s_2888_6: i128 = (s_2888_5 + s_2888_4);
        // D s_2888_7: bit-extract s_2888_2 s_2888_0 s_2888_6
        let s_2888_7: Bits = (Bits::new(
            ((s_2888_2) >> (s_2888_0)).value(),
            u16::try_from(s_2888_6).unwrap(),
        ));
        // D s_2888_8: cast reint s_2888_7 -> u8
        let s_2888_8: u8 = (s_2888_7.value() as u8);
        // D s_2888_9: cast zx s_2888_8 -> bv
        let s_2888_9: Bits = Bits::new(s_2888_8 as u128, 4u16);
        // C s_2888_10: const #0u : u8
        let s_2888_10: u8 = 0;
        // C s_2888_11: cast zx s_2888_10 -> bv
        let s_2888_11: Bits = Bits::new(s_2888_10 as u128, 4u16);
        // D s_2888_12: cmp-eq s_2888_9 s_2888_11
        let s_2888_12: bool = ((s_2888_9) == (s_2888_11));
        // D s_2888_13: write-var gs#404468 <= s_2888_12
        fn_state.gs_404468 = s_2888_12;
        // N s_2888_14: jump b238
        return block_238(state, tracer, fn_state);
    }
    fn block_2889<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2889_0: const #28s : i
        let s_2889_0: i128 = 28;
        // C s_2889_1: const #4s : i
        let s_2889_1: i128 = 4;
        // D s_2889_2: read-var u#32454:u32
        let s_2889_2: u32 = fn_state.u_32454;
        // D s_2889_3: cast zx s_2889_2 -> bv
        let s_2889_3: Bits = Bits::new(s_2889_2 as u128, 32u16);
        // D s_2889_4: bit-extract s_2889_3 s_2889_0 s_2889_1
        let s_2889_4: Bits = (Bits::new(
            ((s_2889_3) >> (s_2889_0)).value(),
            u16::try_from(s_2889_1).unwrap(),
        ));
        // D s_2889_5: cast reint s_2889_4 -> u8
        let s_2889_5: u8 = (s_2889_4.value() as u8);
        // D s_2889_6: cast zx s_2889_5 -> bv
        let s_2889_6: Bits = Bits::new(s_2889_5 as u128, 4u16);
        // C s_2889_7: const #15u : u8
        let s_2889_7: u8 = 15;
        // C s_2889_8: cast zx s_2889_7 -> bv
        let s_2889_8: Bits = Bits::new(s_2889_7 as u128, 4u16);
        // D s_2889_9: cmp-ne s_2889_6 s_2889_8
        let s_2889_9: bool = ((s_2889_6) != (s_2889_8));
        // N s_2889_10: branch s_2889_9 b2892 b2890
        if s_2889_9 {
            return block_2892(state, tracer, fn_state);
        } else {
            return block_2890(state, tracer, fn_state);
        };
    }
    fn block_2890<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2890_0: const #0u : u8
        let s_2890_0: bool = false;
        // D s_2890_1: write-var gs#404430 <= s_2890_0
        fn_state.gs_404430 = s_2890_0;
        // N s_2890_2: jump b2891
        return block_2891(state, tracer, fn_state);
    }
    fn block_2891<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2891_0: read-var gs#404430:u8
        let s_2891_0: bool = fn_state.gs_404430;
        // D s_2891_1: write-var gs#404431 <= s_2891_0
        fn_state.gs_404431 = s_2891_0;
        // N s_2891_2: jump b211
        return block_211(state, tracer, fn_state);
    }
    fn block_2892<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2892_0: const #2881s : i
        let s_2892_0: i128 = 2881;
        // C s_2892_1: const #14696u : u32
        let s_2892_1: u32 = 14696;
        // D s_2892_2: read-reg s_2892_1:i
        let s_2892_2: i128 = {
            let value = state.read_register::<i128>(s_2892_1 as isize);
            tracer.read_register(s_2892_1 as isize, value);
            value
        };
        // D s_2892_3: cmp-lt s_2892_2 s_2892_0
        let s_2892_3: bool = ((s_2892_2) < (s_2892_0));
        // D s_2892_4: write-var gs#404430 <= s_2892_3
        fn_state.gs_404430 = s_2892_3;
        // N s_2892_5: jump b2891
        return block_2891(state, tracer, fn_state);
    }
    fn block_2893<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2893_0: const #4s : i
        let s_2893_0: i128 = 4;
        // D s_2893_1: read-var u#32454:u32
        let s_2893_1: u32 = fn_state.u_32454;
        // D s_2893_2: cast zx s_2893_1 -> bv
        let s_2893_2: Bits = Bits::new(s_2893_1 as u128, 32u16);
        // C s_2893_3: const #1s : i64
        let s_2893_3: i64 = 1;
        // C s_2893_4: cast zx s_2893_3 -> i
        let s_2893_4: i128 = (i128::try_from(s_2893_3).unwrap());
        // C s_2893_5: const #7s : i
        let s_2893_5: i128 = 7;
        // C s_2893_6: add s_2893_5 s_2893_4
        let s_2893_6: i128 = (s_2893_5 + s_2893_4);
        // D s_2893_7: bit-extract s_2893_2 s_2893_0 s_2893_6
        let s_2893_7: Bits = (Bits::new(
            ((s_2893_2) >> (s_2893_0)).value(),
            u16::try_from(s_2893_6).unwrap(),
        ));
        // D s_2893_8: cast reint s_2893_7 -> u8
        let s_2893_8: u8 = (s_2893_7.value() as u8);
        // D s_2893_9: cast zx s_2893_8 -> bv
        let s_2893_9: Bits = Bits::new(s_2893_8 as u128, 8u16);
        // C s_2893_10: const #241u : u8
        let s_2893_10: u8 = 241;
        // C s_2893_11: cast zx s_2893_10 -> bv
        let s_2893_11: Bits = Bits::new(s_2893_10 as u128, 8u16);
        // D s_2893_12: cmp-eq s_2893_9 s_2893_11
        let s_2893_12: bool = ((s_2893_9) == (s_2893_11));
        // D s_2893_13: write-var gs#404426 <= s_2893_12
        fn_state.gs_404426 = s_2893_12;
        // N s_2893_14: jump b209
        return block_209(state, tracer, fn_state);
    }
    fn block_2894<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2894_0: const #28s : i
        let s_2894_0: i128 = 28;
        // C s_2894_1: const #4s : i
        let s_2894_1: i128 = 4;
        // D s_2894_2: read-var u#32450:u32
        let s_2894_2: u32 = fn_state.u_32450;
        // D s_2894_3: cast zx s_2894_2 -> bv
        let s_2894_3: Bits = Bits::new(s_2894_2 as u128, 32u16);
        // D s_2894_4: bit-extract s_2894_3 s_2894_0 s_2894_1
        let s_2894_4: Bits = (Bits::new(
            ((s_2894_3) >> (s_2894_0)).value(),
            u16::try_from(s_2894_1).unwrap(),
        ));
        // D s_2894_5: cast reint s_2894_4 -> u8
        let s_2894_5: u8 = (s_2894_4.value() as u8);
        // D s_2894_6: cast zx s_2894_5 -> bv
        let s_2894_6: Bits = Bits::new(s_2894_5 as u128, 4u16);
        // C s_2894_7: const #15u : u8
        let s_2894_7: u8 = 15;
        // C s_2894_8: cast zx s_2894_7 -> bv
        let s_2894_8: Bits = Bits::new(s_2894_7 as u128, 4u16);
        // D s_2894_9: cmp-ne s_2894_6 s_2894_8
        let s_2894_9: bool = ((s_2894_6) != (s_2894_8));
        // N s_2894_10: branch s_2894_9 b2897 b2895
        if s_2894_9 {
            return block_2897(state, tracer, fn_state);
        } else {
            return block_2895(state, tracer, fn_state);
        };
    }
    fn block_2895<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2895_0: const #0u : u8
        let s_2895_0: bool = false;
        // D s_2895_1: write-var gs#404378 <= s_2895_0
        fn_state.gs_404378 = s_2895_0;
        // N s_2895_2: jump b2896
        return block_2896(state, tracer, fn_state);
    }
    fn block_2896<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2896_0: read-var gs#404378:u8
        let s_2896_0: bool = fn_state.gs_404378;
        // D s_2896_1: write-var gs#404379 <= s_2896_0
        fn_state.gs_404379 = s_2896_0;
        // N s_2896_2: jump b170
        return block_170(state, tracer, fn_state);
    }
    fn block_2897<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2897_0: const #2876s : i
        let s_2897_0: i128 = 2876;
        // C s_2897_1: const #14696u : u32
        let s_2897_1: u32 = 14696;
        // D s_2897_2: read-reg s_2897_1:i
        let s_2897_2: i128 = {
            let value = state.read_register::<i128>(s_2897_1 as isize);
            tracer.read_register(s_2897_1 as isize, value);
            value
        };
        // D s_2897_3: cmp-lt s_2897_2 s_2897_0
        let s_2897_3: bool = ((s_2897_2) < (s_2897_0));
        // D s_2897_4: write-var gs#404378 <= s_2897_3
        fn_state.gs_404378 = s_2897_3;
        // N s_2897_5: jump b2896
        return block_2896(state, tracer, fn_state);
    }
    fn block_2898<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2898_0: const #28s : i
        let s_2898_0: i128 = 28;
        // C s_2898_1: const #4s : i
        let s_2898_1: i128 = 4;
        // D s_2898_2: read-var u#32446:u32
        let s_2898_2: u32 = fn_state.u_32446;
        // D s_2898_3: cast zx s_2898_2 -> bv
        let s_2898_3: Bits = Bits::new(s_2898_2 as u128, 32u16);
        // D s_2898_4: bit-extract s_2898_3 s_2898_0 s_2898_1
        let s_2898_4: Bits = (Bits::new(
            ((s_2898_3) >> (s_2898_0)).value(),
            u16::try_from(s_2898_1).unwrap(),
        ));
        // D s_2898_5: cast reint s_2898_4 -> u8
        let s_2898_5: u8 = (s_2898_4.value() as u8);
        // D s_2898_6: cast zx s_2898_5 -> bv
        let s_2898_6: Bits = Bits::new(s_2898_5 as u128, 4u16);
        // C s_2898_7: const #15u : u8
        let s_2898_7: u8 = 15;
        // C s_2898_8: cast zx s_2898_7 -> bv
        let s_2898_8: Bits = Bits::new(s_2898_7 as u128, 4u16);
        // D s_2898_9: cmp-ne s_2898_6 s_2898_8
        let s_2898_9: bool = ((s_2898_6) != (s_2898_8));
        // N s_2898_10: branch s_2898_9 b2901 b2899
        if s_2898_9 {
            return block_2901(state, tracer, fn_state);
        } else {
            return block_2899(state, tracer, fn_state);
        };
    }
    fn block_2899<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2899_0: const #0u : u8
        let s_2899_0: bool = false;
        // D s_2899_1: write-var gs#404329 <= s_2899_0
        fn_state.gs_404329 = s_2899_0;
        // N s_2899_2: jump b2900
        return block_2900(state, tracer, fn_state);
    }
    fn block_2900<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2900_0: read-var gs#404329:u8
        let s_2900_0: bool = fn_state.gs_404329;
        // D s_2900_1: write-var gs#404330 <= s_2900_0
        fn_state.gs_404330 = s_2900_0;
        // N s_2900_2: jump b131
        return block_131(state, tracer, fn_state);
    }
    fn block_2901<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2901_0: const #2874s : i
        let s_2901_0: i128 = 2874;
        // C s_2901_1: const #14696u : u32
        let s_2901_1: u32 = 14696;
        // D s_2901_2: read-reg s_2901_1:i
        let s_2901_2: i128 = {
            let value = state.read_register::<i128>(s_2901_1 as isize);
            tracer.read_register(s_2901_1 as isize, value);
            value
        };
        // D s_2901_3: cmp-lt s_2901_2 s_2901_0
        let s_2901_3: bool = ((s_2901_2) < (s_2901_0));
        // D s_2901_4: write-var gs#404329 <= s_2901_3
        fn_state.gs_404329 = s_2901_3;
        // N s_2901_5: jump b2900
        return block_2900(state, tracer, fn_state);
    }
    fn block_2902<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2902_0: const #28s : i
        let s_2902_0: i128 = 28;
        // C s_2902_1: const #4s : i
        let s_2902_1: i128 = 4;
        // D s_2902_2: read-var u#32442:u32
        let s_2902_2: u32 = fn_state.u_32442;
        // D s_2902_3: cast zx s_2902_2 -> bv
        let s_2902_3: Bits = Bits::new(s_2902_2 as u128, 32u16);
        // D s_2902_4: bit-extract s_2902_3 s_2902_0 s_2902_1
        let s_2902_4: Bits = (Bits::new(
            ((s_2902_3) >> (s_2902_0)).value(),
            u16::try_from(s_2902_1).unwrap(),
        ));
        // D s_2902_5: cast reint s_2902_4 -> u8
        let s_2902_5: u8 = (s_2902_4.value() as u8);
        // D s_2902_6: cast zx s_2902_5 -> bv
        let s_2902_6: Bits = Bits::new(s_2902_5 as u128, 4u16);
        // C s_2902_7: const #15u : u8
        let s_2902_7: u8 = 15;
        // C s_2902_8: cast zx s_2902_7 -> bv
        let s_2902_8: Bits = Bits::new(s_2902_7 as u128, 4u16);
        // D s_2902_9: cmp-ne s_2902_6 s_2902_8
        let s_2902_9: bool = ((s_2902_6) != (s_2902_8));
        // N s_2902_10: branch s_2902_9 b2905 b2903
        if s_2902_9 {
            return block_2905(state, tracer, fn_state);
        } else {
            return block_2903(state, tracer, fn_state);
        };
    }
    fn block_2903<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2903_0: const #0u : u8
        let s_2903_0: bool = false;
        // D s_2903_1: write-var gs#404280 <= s_2903_0
        fn_state.gs_404280 = s_2903_0;
        // N s_2903_2: jump b2904
        return block_2904(state, tracer, fn_state);
    }
    fn block_2904<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2904_0: read-var gs#404280:u8
        let s_2904_0: bool = fn_state.gs_404280;
        // D s_2904_1: write-var gs#404281 <= s_2904_0
        fn_state.gs_404281 = s_2904_0;
        // N s_2904_2: jump b92
        return block_92(state, tracer, fn_state);
    }
    fn block_2905<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2905_0: const #2872s : i
        let s_2905_0: i128 = 2872;
        // C s_2905_1: const #14696u : u32
        let s_2905_1: u32 = 14696;
        // D s_2905_2: read-reg s_2905_1:i
        let s_2905_2: i128 = {
            let value = state.read_register::<i128>(s_2905_1 as isize);
            tracer.read_register(s_2905_1 as isize, value);
            value
        };
        // D s_2905_3: cmp-lt s_2905_2 s_2905_0
        let s_2905_3: bool = ((s_2905_2) < (s_2905_0));
        // D s_2905_4: write-var gs#404280 <= s_2905_3
        fn_state.gs_404280 = s_2905_3;
        // N s_2905_5: jump b2904
        return block_2904(state, tracer, fn_state);
    }
    fn block_2906<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2906_0: const #28s : i
        let s_2906_0: i128 = 28;
        // C s_2906_1: const #4s : i
        let s_2906_1: i128 = 4;
        // D s_2906_2: read-var u#32438:u32
        let s_2906_2: u32 = fn_state.u_32438;
        // D s_2906_3: cast zx s_2906_2 -> bv
        let s_2906_3: Bits = Bits::new(s_2906_2 as u128, 32u16);
        // D s_2906_4: bit-extract s_2906_3 s_2906_0 s_2906_1
        let s_2906_4: Bits = (Bits::new(
            ((s_2906_3) >> (s_2906_0)).value(),
            u16::try_from(s_2906_1).unwrap(),
        ));
        // D s_2906_5: cast reint s_2906_4 -> u8
        let s_2906_5: u8 = (s_2906_4.value() as u8);
        // D s_2906_6: cast zx s_2906_5 -> bv
        let s_2906_6: Bits = Bits::new(s_2906_5 as u128, 4u16);
        // C s_2906_7: const #15u : u8
        let s_2906_7: u8 = 15;
        // C s_2906_8: cast zx s_2906_7 -> bv
        let s_2906_8: Bits = Bits::new(s_2906_7 as u128, 4u16);
        // D s_2906_9: cmp-ne s_2906_6 s_2906_8
        let s_2906_9: bool = ((s_2906_6) != (s_2906_8));
        // N s_2906_10: branch s_2906_9 b2909 b2907
        if s_2906_9 {
            return block_2909(state, tracer, fn_state);
        } else {
            return block_2907(state, tracer, fn_state);
        };
    }
    fn block_2907<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2907_0: const #0u : u8
        let s_2907_0: bool = false;
        // D s_2907_1: write-var gs#404264 <= s_2907_0
        fn_state.gs_404264 = s_2907_0;
        // N s_2907_2: jump b2908
        return block_2908(state, tracer, fn_state);
    }
    fn block_2908<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2908_0: read-var gs#404264:u8
        let s_2908_0: bool = fn_state.gs_404264;
        // D s_2908_1: write-var gs#404265 <= s_2908_0
        fn_state.gs_404265 = s_2908_0;
        // N s_2908_2: jump b88
        return block_88(state, tracer, fn_state);
    }
    fn block_2909<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2909_0: const #2866s : i
        let s_2909_0: i128 = 2866;
        // C s_2909_1: const #14696u : u32
        let s_2909_1: u32 = 14696;
        // D s_2909_2: read-reg s_2909_1:i
        let s_2909_2: i128 = {
            let value = state.read_register::<i128>(s_2909_1 as isize);
            tracer.read_register(s_2909_1 as isize, value);
            value
        };
        // D s_2909_3: cmp-lt s_2909_2 s_2909_0
        let s_2909_3: bool = ((s_2909_2) < (s_2909_0));
        // D s_2909_4: write-var gs#404264 <= s_2909_3
        fn_state.gs_404264 = s_2909_3;
        // N s_2909_5: jump b2908
        return block_2908(state, tracer, fn_state);
    }
    fn block_2910<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2910_0: const #4s : i
        let s_2910_0: i128 = 4;
        // D s_2910_1: read-var u#32438:u32
        let s_2910_1: u32 = fn_state.u_32438;
        // D s_2910_2: cast zx s_2910_1 -> bv
        let s_2910_2: Bits = Bits::new(s_2910_1 as u128, 32u16);
        // C s_2910_3: const #1s : i64
        let s_2910_3: i64 = 1;
        // C s_2910_4: cast zx s_2910_3 -> i
        let s_2910_4: i128 = (i128::try_from(s_2910_3).unwrap());
        // C s_2910_5: const #3s : i
        let s_2910_5: i128 = 3;
        // C s_2910_6: add s_2910_5 s_2910_4
        let s_2910_6: i128 = (s_2910_5 + s_2910_4);
        // D s_2910_7: bit-extract s_2910_2 s_2910_0 s_2910_6
        let s_2910_7: Bits = (Bits::new(
            ((s_2910_2) >> (s_2910_0)).value(),
            u16::try_from(s_2910_6).unwrap(),
        ));
        // D s_2910_8: cast reint s_2910_7 -> u8
        let s_2910_8: u8 = (s_2910_7.value() as u8);
        // D s_2910_9: cast zx s_2910_8 -> bv
        let s_2910_9: Bits = Bits::new(s_2910_8 as u128, 4u16);
        // C s_2910_10: const #7u : u8
        let s_2910_10: u8 = 7;
        // C s_2910_11: cast zx s_2910_10 -> bv
        let s_2910_11: Bits = Bits::new(s_2910_10 as u128, 4u16);
        // D s_2910_12: cmp-eq s_2910_9 s_2910_11
        let s_2910_12: bool = ((s_2910_9) == (s_2910_11));
        // D s_2910_13: write-var gs#404260 <= s_2910_12
        fn_state.gs_404260 = s_2910_12;
        // N s_2910_14: jump b86
        return block_86(state, tracer, fn_state);
    }
    fn block_2911<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2911_0: const #28s : i
        let s_2911_0: i128 = 28;
        // C s_2911_1: const #4s : i
        let s_2911_1: i128 = 4;
        // D s_2911_2: read-var u#32429:u32
        let s_2911_2: u32 = fn_state.u_32429;
        // D s_2911_3: cast zx s_2911_2 -> bv
        let s_2911_3: Bits = Bits::new(s_2911_2 as u128, 32u16);
        // D s_2911_4: bit-extract s_2911_3 s_2911_0 s_2911_1
        let s_2911_4: Bits = (Bits::new(
            ((s_2911_3) >> (s_2911_0)).value(),
            u16::try_from(s_2911_1).unwrap(),
        ));
        // D s_2911_5: cast reint s_2911_4 -> u8
        let s_2911_5: u8 = (s_2911_4.value() as u8);
        // D s_2911_6: cast zx s_2911_5 -> bv
        let s_2911_6: Bits = Bits::new(s_2911_5 as u128, 4u16);
        // C s_2911_7: const #15u : u8
        let s_2911_7: u8 = 15;
        // C s_2911_8: cast zx s_2911_7 -> bv
        let s_2911_8: Bits = Bits::new(s_2911_7 as u128, 4u16);
        // D s_2911_9: cmp-ne s_2911_6 s_2911_8
        let s_2911_9: bool = ((s_2911_6) != (s_2911_8));
        // N s_2911_10: branch s_2911_9 b2914 b2912
        if s_2911_9 {
            return block_2914(state, tracer, fn_state);
        } else {
            return block_2912(state, tracer, fn_state);
        };
    }
    fn block_2912<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2912_0: const #0u : u8
        let s_2912_0: bool = false;
        // D s_2912_1: write-var gs#404237 <= s_2912_0
        fn_state.gs_404237 = s_2912_0;
        // N s_2912_2: jump b2913
        return block_2913(state, tracer, fn_state);
    }
    fn block_2913<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2913_0: read-var gs#404237:u8
        let s_2913_0: bool = fn_state.gs_404237;
        // D s_2913_1: write-var gs#404238 <= s_2913_0
        fn_state.gs_404238 = s_2913_0;
        // N s_2913_2: jump b82
        return block_82(state, tracer, fn_state);
    }
    fn block_2914<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2914_0: const #2865s : i
        let s_2914_0: i128 = 2865;
        // C s_2914_1: const #14696u : u32
        let s_2914_1: u32 = 14696;
        // D s_2914_2: read-reg s_2914_1:i
        let s_2914_2: i128 = {
            let value = state.read_register::<i128>(s_2914_1 as isize);
            tracer.read_register(s_2914_1 as isize, value);
            value
        };
        // D s_2914_3: cmp-lt s_2914_2 s_2914_0
        let s_2914_3: bool = ((s_2914_2) < (s_2914_0));
        // D s_2914_4: write-var gs#404237 <= s_2914_3
        fn_state.gs_404237 = s_2914_3;
        // N s_2914_5: jump b2913
        return block_2913(state, tracer, fn_state);
    }
    fn block_2915<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2915_0: const #7s : i
        let s_2915_0: i128 = 7;
        // D s_2915_1: read-var u#32429:u32
        let s_2915_1: u32 = fn_state.u_32429;
        // D s_2915_2: cast zx s_2915_1 -> bv
        let s_2915_2: Bits = Bits::new(s_2915_1 as u128, 32u16);
        // C s_2915_3: const #1s : i64
        let s_2915_3: i64 = 1;
        // C s_2915_4: cast zx s_2915_3 -> i
        let s_2915_4: i128 = (i128::try_from(s_2915_3).unwrap());
        // C s_2915_5: const #0s : i
        let s_2915_5: i128 = 0;
        // C s_2915_6: add s_2915_5 s_2915_4
        let s_2915_6: i128 = (s_2915_5 + s_2915_4);
        // D s_2915_7: bit-extract s_2915_2 s_2915_0 s_2915_6
        let s_2915_7: Bits = (Bits::new(
            ((s_2915_2) >> (s_2915_0)).value(),
            u16::try_from(s_2915_6).unwrap(),
        ));
        // D s_2915_8: cast reint s_2915_7 -> u8
        let s_2915_8: bool = ((s_2915_7.value()) != 0);
        // D s_2915_9: cast zx s_2915_8 -> bv
        let s_2915_9: Bits = Bits::new(s_2915_8 as u128, 1u16);
        // C s_2915_10: const #0u : u8
        let s_2915_10: bool = false;
        // C s_2915_11: cast zx s_2915_10 -> bv
        let s_2915_11: Bits = Bits::new(s_2915_10 as u128, 1u16);
        // D s_2915_12: cmp-eq s_2915_9 s_2915_11
        let s_2915_12: bool = ((s_2915_9) == (s_2915_11));
        // N s_2915_13: branch s_2915_12 b2918 b2916
        if s_2915_12 {
            return block_2918(state, tracer, fn_state);
        } else {
            return block_2916(state, tracer, fn_state);
        };
    }
    fn block_2916<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2916_0: const #0u : u8
        let s_2916_0: bool = false;
        // D s_2916_1: write-var gs#404232 <= s_2916_0
        fn_state.gs_404232 = s_2916_0;
        // N s_2916_2: jump b2917
        return block_2917(state, tracer, fn_state);
    }
    fn block_2917<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2917_0: read-var gs#404232:u8
        let s_2917_0: bool = fn_state.gs_404232;
        // D s_2917_1: write-var gs#404233 <= s_2917_0
        fn_state.gs_404233 = s_2917_0;
        // N s_2917_2: jump b80
        return block_80(state, tracer, fn_state);
    }
    fn block_2918<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2918_0: const #4s : i
        let s_2918_0: i128 = 4;
        // D s_2918_1: read-var u#32429:u32
        let s_2918_1: u32 = fn_state.u_32429;
        // D s_2918_2: cast zx s_2918_1 -> bv
        let s_2918_2: Bits = Bits::new(s_2918_1 as u128, 32u16);
        // C s_2918_3: const #1s : i64
        let s_2918_3: i64 = 1;
        // C s_2918_4: cast zx s_2918_3 -> i
        let s_2918_4: i128 = (i128::try_from(s_2918_3).unwrap());
        // C s_2918_5: const #0s : i
        let s_2918_5: i128 = 0;
        // C s_2918_6: add s_2918_5 s_2918_4
        let s_2918_6: i128 = (s_2918_5 + s_2918_4);
        // D s_2918_7: bit-extract s_2918_2 s_2918_0 s_2918_6
        let s_2918_7: Bits = (Bits::new(
            ((s_2918_2) >> (s_2918_0)).value(),
            u16::try_from(s_2918_6).unwrap(),
        ));
        // D s_2918_8: cast reint s_2918_7 -> u8
        let s_2918_8: bool = ((s_2918_7.value()) != 0);
        // D s_2918_9: cast zx s_2918_8 -> bv
        let s_2918_9: Bits = Bits::new(s_2918_8 as u128, 1u16);
        // C s_2918_10: const #1u : u8
        let s_2918_10: bool = true;
        // C s_2918_11: cast zx s_2918_10 -> bv
        let s_2918_11: Bits = Bits::new(s_2918_10 as u128, 1u16);
        // D s_2918_12: cmp-eq s_2918_9 s_2918_11
        let s_2918_12: bool = ((s_2918_9) == (s_2918_11));
        // D s_2918_13: write-var gs#404232 <= s_2918_12
        fn_state.gs_404232 = s_2918_12;
        // N s_2918_14: jump b2917
        return block_2917(state, tracer, fn_state);
    }
    fn block_2919<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2919_0: const #28s : i
        let s_2919_0: i128 = 28;
        // C s_2919_1: const #4s : i
        let s_2919_1: i128 = 4;
        // D s_2919_2: read-var u#32420:u32
        let s_2919_2: u32 = fn_state.u_32420;
        // D s_2919_3: cast zx s_2919_2 -> bv
        let s_2919_3: Bits = Bits::new(s_2919_2 as u128, 32u16);
        // D s_2919_4: bit-extract s_2919_3 s_2919_0 s_2919_1
        let s_2919_4: Bits = (Bits::new(
            ((s_2919_3) >> (s_2919_0)).value(),
            u16::try_from(s_2919_1).unwrap(),
        ));
        // D s_2919_5: cast reint s_2919_4 -> u8
        let s_2919_5: u8 = (s_2919_4.value() as u8);
        // D s_2919_6: cast zx s_2919_5 -> bv
        let s_2919_6: Bits = Bits::new(s_2919_5 as u128, 4u16);
        // C s_2919_7: const #15u : u8
        let s_2919_7: u8 = 15;
        // C s_2919_8: cast zx s_2919_7 -> bv
        let s_2919_8: Bits = Bits::new(s_2919_7 as u128, 4u16);
        // D s_2919_9: cmp-ne s_2919_6 s_2919_8
        let s_2919_9: bool = ((s_2919_6) != (s_2919_8));
        // N s_2919_10: branch s_2919_9 b2922 b2920
        if s_2919_9 {
            return block_2922(state, tracer, fn_state);
        } else {
            return block_2920(state, tracer, fn_state);
        };
    }
    fn block_2920<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2920_0: const #0u : u8
        let s_2920_0: bool = false;
        // D s_2920_1: write-var gs#404207 <= s_2920_0
        fn_state.gs_404207 = s_2920_0;
        // N s_2920_2: jump b2921
        return block_2921(state, tracer, fn_state);
    }
    fn block_2921<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2921_0: read-var gs#404207:u8
        let s_2921_0: bool = fn_state.gs_404207;
        // D s_2921_1: write-var gs#404208 <= s_2921_0
        fn_state.gs_404208 = s_2921_0;
        // N s_2921_2: jump b76
        return block_76(state, tracer, fn_state);
    }
    fn block_2922<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2922_0: const #2862s : i
        let s_2922_0: i128 = 2862;
        // C s_2922_1: const #14696u : u32
        let s_2922_1: u32 = 14696;
        // D s_2922_2: read-reg s_2922_1:i
        let s_2922_2: i128 = {
            let value = state.read_register::<i128>(s_2922_1 as isize);
            tracer.read_register(s_2922_1 as isize, value);
            value
        };
        // D s_2922_3: cmp-lt s_2922_2 s_2922_0
        let s_2922_3: bool = ((s_2922_2) < (s_2922_0));
        // D s_2922_4: write-var gs#404207 <= s_2922_3
        fn_state.gs_404207 = s_2922_3;
        // N s_2922_5: jump b2921
        return block_2921(state, tracer, fn_state);
    }
    fn block_2923<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2923_0: const #4s : i
        let s_2923_0: i128 = 4;
        // D s_2923_1: read-var u#32420:u32
        let s_2923_1: u32 = fn_state.u_32420;
        // D s_2923_2: cast zx s_2923_1 -> bv
        let s_2923_2: Bits = Bits::new(s_2923_1 as u128, 32u16);
        // C s_2923_3: const #1s : i64
        let s_2923_3: i64 = 1;
        // C s_2923_4: cast zx s_2923_3 -> i
        let s_2923_4: i128 = (i128::try_from(s_2923_3).unwrap());
        // C s_2923_5: const #0s : i
        let s_2923_5: i128 = 0;
        // C s_2923_6: add s_2923_5 s_2923_4
        let s_2923_6: i128 = (s_2923_5 + s_2923_4);
        // D s_2923_7: bit-extract s_2923_2 s_2923_0 s_2923_6
        let s_2923_7: Bits = (Bits::new(
            ((s_2923_2) >> (s_2923_0)).value(),
            u16::try_from(s_2923_6).unwrap(),
        ));
        // D s_2923_8: cast reint s_2923_7 -> u8
        let s_2923_8: bool = ((s_2923_7.value()) != 0);
        // D s_2923_9: cast zx s_2923_8 -> bv
        let s_2923_9: Bits = Bits::new(s_2923_8 as u128, 1u16);
        // C s_2923_10: const #0u : u8
        let s_2923_10: bool = false;
        // C s_2923_11: cast zx s_2923_10 -> bv
        let s_2923_11: Bits = Bits::new(s_2923_10 as u128, 1u16);
        // D s_2923_12: cmp-eq s_2923_9 s_2923_11
        let s_2923_12: bool = ((s_2923_9) == (s_2923_11));
        // D s_2923_13: write-var gs#404203 <= s_2923_12
        fn_state.gs_404203 = s_2923_12;
        // N s_2923_14: jump b74
        return block_74(state, tracer, fn_state);
    }
    fn block_2924<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2924_0: const #28s : i
        let s_2924_0: i128 = 28;
        // C s_2924_1: const #4s : i
        let s_2924_1: i128 = 4;
        // D s_2924_2: read-var u#32413:u32
        let s_2924_2: u32 = fn_state.u_32413;
        // D s_2924_3: cast zx s_2924_2 -> bv
        let s_2924_3: Bits = Bits::new(s_2924_2 as u128, 32u16);
        // D s_2924_4: bit-extract s_2924_3 s_2924_0 s_2924_1
        let s_2924_4: Bits = (Bits::new(
            ((s_2924_3) >> (s_2924_0)).value(),
            u16::try_from(s_2924_1).unwrap(),
        ));
        // D s_2924_5: cast reint s_2924_4 -> u8
        let s_2924_5: u8 = (s_2924_4.value() as u8);
        // D s_2924_6: cast zx s_2924_5 -> bv
        let s_2924_6: Bits = Bits::new(s_2924_5 as u128, 4u16);
        // C s_2924_7: const #15u : u8
        let s_2924_7: u8 = 15;
        // C s_2924_8: cast zx s_2924_7 -> bv
        let s_2924_8: Bits = Bits::new(s_2924_7 as u128, 4u16);
        // D s_2924_9: cmp-ne s_2924_6 s_2924_8
        let s_2924_9: bool = ((s_2924_6) != (s_2924_8));
        // N s_2924_10: branch s_2924_9 b2927 b2925
        if s_2924_9 {
            return block_2927(state, tracer, fn_state);
        } else {
            return block_2925(state, tracer, fn_state);
        };
    }
    fn block_2925<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2925_0: const #0u : u8
        let s_2925_0: bool = false;
        // D s_2925_1: write-var gs#404184 <= s_2925_0
        fn_state.gs_404184 = s_2925_0;
        // N s_2925_2: jump b2926
        return block_2926(state, tracer, fn_state);
    }
    fn block_2926<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2926_0: read-var gs#404184:u8
        let s_2926_0: bool = fn_state.gs_404184;
        // D s_2926_1: write-var gs#404185 <= s_2926_0
        fn_state.gs_404185 = s_2926_0;
        // N s_2926_2: jump b70
        return block_70(state, tracer, fn_state);
    }
    fn block_2927<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2927_0: const #2860s : i
        let s_2927_0: i128 = 2860;
        // C s_2927_1: const #14696u : u32
        let s_2927_1: u32 = 14696;
        // D s_2927_2: read-reg s_2927_1:i
        let s_2927_2: i128 = {
            let value = state.read_register::<i128>(s_2927_1 as isize);
            tracer.read_register(s_2927_1 as isize, value);
            value
        };
        // D s_2927_3: cmp-lt s_2927_2 s_2927_0
        let s_2927_3: bool = ((s_2927_2) < (s_2927_0));
        // D s_2927_4: write-var gs#404184 <= s_2927_3
        fn_state.gs_404184 = s_2927_3;
        // N s_2927_5: jump b2926
        return block_2926(state, tracer, fn_state);
    }
    fn block_2928<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2928_0: const #28s : i
        let s_2928_0: i128 = 28;
        // C s_2928_1: const #4s : i
        let s_2928_1: i128 = 4;
        // D s_2928_2: read-var u#32404:u32
        let s_2928_2: u32 = fn_state.u_32404;
        // D s_2928_3: cast zx s_2928_2 -> bv
        let s_2928_3: Bits = Bits::new(s_2928_2 as u128, 32u16);
        // D s_2928_4: bit-extract s_2928_3 s_2928_0 s_2928_1
        let s_2928_4: Bits = (Bits::new(
            ((s_2928_3) >> (s_2928_0)).value(),
            u16::try_from(s_2928_1).unwrap(),
        ));
        // D s_2928_5: cast reint s_2928_4 -> u8
        let s_2928_5: u8 = (s_2928_4.value() as u8);
        // D s_2928_6: cast zx s_2928_5 -> bv
        let s_2928_6: Bits = Bits::new(s_2928_5 as u128, 4u16);
        // C s_2928_7: const #15u : u8
        let s_2928_7: u8 = 15;
        // C s_2928_8: cast zx s_2928_7 -> bv
        let s_2928_8: Bits = Bits::new(s_2928_7 as u128, 4u16);
        // D s_2928_9: cmp-ne s_2928_6 s_2928_8
        let s_2928_9: bool = ((s_2928_6) != (s_2928_8));
        // N s_2928_10: branch s_2928_9 b2931 b2929
        if s_2928_9 {
            return block_2931(state, tracer, fn_state);
        } else {
            return block_2929(state, tracer, fn_state);
        };
    }
    fn block_2929<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2929_0: const #0u : u8
        let s_2929_0: bool = false;
        // D s_2929_1: write-var gs#404160 <= s_2929_0
        fn_state.gs_404160 = s_2929_0;
        // N s_2929_2: jump b2930
        return block_2930(state, tracer, fn_state);
    }
    fn block_2930<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2930_0: read-var gs#404160:u8
        let s_2930_0: bool = fn_state.gs_404160;
        // D s_2930_1: write-var gs#404161 <= s_2930_0
        fn_state.gs_404161 = s_2930_0;
        // N s_2930_2: jump b66
        return block_66(state, tracer, fn_state);
    }
    fn block_2931<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2931_0: const #2848s : i
        let s_2931_0: i128 = 2848;
        // C s_2931_1: const #14696u : u32
        let s_2931_1: u32 = 14696;
        // D s_2931_2: read-reg s_2931_1:i
        let s_2931_2: i128 = {
            let value = state.read_register::<i128>(s_2931_1 as isize);
            tracer.read_register(s_2931_1 as isize, value);
            value
        };
        // D s_2931_3: cmp-lt s_2931_2 s_2931_0
        let s_2931_3: bool = ((s_2931_2) < (s_2931_0));
        // D s_2931_4: write-var gs#404160 <= s_2931_3
        fn_state.gs_404160 = s_2931_3;
        // N s_2931_5: jump b2930
        return block_2930(state, tracer, fn_state);
    }
    fn block_2932<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2932_0: const #7s : i
        let s_2932_0: i128 = 7;
        // D s_2932_1: read-var u#32404:u32
        let s_2932_1: u32 = fn_state.u_32404;
        // D s_2932_2: cast zx s_2932_1 -> bv
        let s_2932_2: Bits = Bits::new(s_2932_1 as u128, 32u16);
        // C s_2932_3: const #1s : i64
        let s_2932_3: i64 = 1;
        // C s_2932_4: cast zx s_2932_3 -> i
        let s_2932_4: i128 = (i128::try_from(s_2932_3).unwrap());
        // C s_2932_5: const #0s : i
        let s_2932_5: i128 = 0;
        // C s_2932_6: add s_2932_5 s_2932_4
        let s_2932_6: i128 = (s_2932_5 + s_2932_4);
        // D s_2932_7: bit-extract s_2932_2 s_2932_0 s_2932_6
        let s_2932_7: Bits = (Bits::new(
            ((s_2932_2) >> (s_2932_0)).value(),
            u16::try_from(s_2932_6).unwrap(),
        ));
        // D s_2932_8: cast reint s_2932_7 -> u8
        let s_2932_8: bool = ((s_2932_7.value()) != 0);
        // D s_2932_9: cast zx s_2932_8 -> bv
        let s_2932_9: Bits = Bits::new(s_2932_8 as u128, 1u16);
        // C s_2932_10: const #0u : u8
        let s_2932_10: bool = false;
        // C s_2932_11: cast zx s_2932_10 -> bv
        let s_2932_11: Bits = Bits::new(s_2932_10 as u128, 1u16);
        // D s_2932_12: cmp-eq s_2932_9 s_2932_11
        let s_2932_12: bool = ((s_2932_9) == (s_2932_11));
        // N s_2932_13: branch s_2932_12 b2935 b2933
        if s_2932_12 {
            return block_2935(state, tracer, fn_state);
        } else {
            return block_2933(state, tracer, fn_state);
        };
    }
    fn block_2933<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2933_0: const #0u : u8
        let s_2933_0: bool = false;
        // D s_2933_1: write-var gs#404155 <= s_2933_0
        fn_state.gs_404155 = s_2933_0;
        // N s_2933_2: jump b2934
        return block_2934(state, tracer, fn_state);
    }
    fn block_2934<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2934_0: read-var gs#404155:u8
        let s_2934_0: bool = fn_state.gs_404155;
        // D s_2934_1: write-var gs#404156 <= s_2934_0
        fn_state.gs_404156 = s_2934_0;
        // N s_2934_2: jump b64
        return block_64(state, tracer, fn_state);
    }
    fn block_2935<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2935_0: const #4s : i
        let s_2935_0: i128 = 4;
        // D s_2935_1: read-var u#32404:u32
        let s_2935_1: u32 = fn_state.u_32404;
        // D s_2935_2: cast zx s_2935_1 -> bv
        let s_2935_2: Bits = Bits::new(s_2935_1 as u128, 32u16);
        // C s_2935_3: const #1s : i64
        let s_2935_3: i64 = 1;
        // C s_2935_4: cast zx s_2935_3 -> i
        let s_2935_4: i128 = (i128::try_from(s_2935_3).unwrap());
        // C s_2935_5: const #0s : i
        let s_2935_5: i128 = 0;
        // C s_2935_6: add s_2935_5 s_2935_4
        let s_2935_6: i128 = (s_2935_5 + s_2935_4);
        // D s_2935_7: bit-extract s_2935_2 s_2935_0 s_2935_6
        let s_2935_7: Bits = (Bits::new(
            ((s_2935_2) >> (s_2935_0)).value(),
            u16::try_from(s_2935_6).unwrap(),
        ));
        // D s_2935_8: cast reint s_2935_7 -> u8
        let s_2935_8: bool = ((s_2935_7.value()) != 0);
        // D s_2935_9: cast zx s_2935_8 -> bv
        let s_2935_9: Bits = Bits::new(s_2935_8 as u128, 1u16);
        // C s_2935_10: const #1u : u8
        let s_2935_10: bool = true;
        // C s_2935_11: cast zx s_2935_10 -> bv
        let s_2935_11: Bits = Bits::new(s_2935_10 as u128, 1u16);
        // D s_2935_12: cmp-eq s_2935_9 s_2935_11
        let s_2935_12: bool = ((s_2935_9) == (s_2935_11));
        // D s_2935_13: write-var gs#404155 <= s_2935_12
        fn_state.gs_404155 = s_2935_12;
        // N s_2935_14: jump b2934
        return block_2934(state, tracer, fn_state);
    }
    fn block_2936<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2936_0: const #28s : i
        let s_2936_0: i128 = 28;
        // C s_2936_1: const #4s : i
        let s_2936_1: i128 = 4;
        // D s_2936_2: read-var u#32395:u32
        let s_2936_2: u32 = fn_state.u_32395;
        // D s_2936_3: cast zx s_2936_2 -> bv
        let s_2936_3: Bits = Bits::new(s_2936_2 as u128, 32u16);
        // D s_2936_4: bit-extract s_2936_3 s_2936_0 s_2936_1
        let s_2936_4: Bits = (Bits::new(
            ((s_2936_3) >> (s_2936_0)).value(),
            u16::try_from(s_2936_1).unwrap(),
        ));
        // D s_2936_5: cast reint s_2936_4 -> u8
        let s_2936_5: u8 = (s_2936_4.value() as u8);
        // D s_2936_6: cast zx s_2936_5 -> bv
        let s_2936_6: Bits = Bits::new(s_2936_5 as u128, 4u16);
        // C s_2936_7: const #15u : u8
        let s_2936_7: u8 = 15;
        // C s_2936_8: cast zx s_2936_7 -> bv
        let s_2936_8: Bits = Bits::new(s_2936_7 as u128, 4u16);
        // D s_2936_9: cmp-ne s_2936_6 s_2936_8
        let s_2936_9: bool = ((s_2936_6) != (s_2936_8));
        // N s_2936_10: branch s_2936_9 b2939 b2937
        if s_2936_9 {
            return block_2939(state, tracer, fn_state);
        } else {
            return block_2937(state, tracer, fn_state);
        };
    }
    fn block_2937<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2937_0: const #0u : u8
        let s_2937_0: bool = false;
        // D s_2937_1: write-var gs#404130 <= s_2937_0
        fn_state.gs_404130 = s_2937_0;
        // N s_2937_2: jump b2938
        return block_2938(state, tracer, fn_state);
    }
    fn block_2938<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2938_0: read-var gs#404130:u8
        let s_2938_0: bool = fn_state.gs_404130;
        // D s_2938_1: write-var gs#404131 <= s_2938_0
        fn_state.gs_404131 = s_2938_0;
        // N s_2938_2: jump b60
        return block_60(state, tracer, fn_state);
    }
    fn block_2939<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2939_0: const #2845s : i
        let s_2939_0: i128 = 2845;
        // C s_2939_1: const #14696u : u32
        let s_2939_1: u32 = 14696;
        // D s_2939_2: read-reg s_2939_1:i
        let s_2939_2: i128 = {
            let value = state.read_register::<i128>(s_2939_1 as isize);
            tracer.read_register(s_2939_1 as isize, value);
            value
        };
        // D s_2939_3: cmp-lt s_2939_2 s_2939_0
        let s_2939_3: bool = ((s_2939_2) < (s_2939_0));
        // D s_2939_4: write-var gs#404130 <= s_2939_3
        fn_state.gs_404130 = s_2939_3;
        // N s_2939_5: jump b2938
        return block_2938(state, tracer, fn_state);
    }
    fn block_2940<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2940_0: const #4s : i
        let s_2940_0: i128 = 4;
        // D s_2940_1: read-var u#32395:u32
        let s_2940_1: u32 = fn_state.u_32395;
        // D s_2940_2: cast zx s_2940_1 -> bv
        let s_2940_2: Bits = Bits::new(s_2940_1 as u128, 32u16);
        // C s_2940_3: const #1s : i64
        let s_2940_3: i64 = 1;
        // C s_2940_4: cast zx s_2940_3 -> i
        let s_2940_4: i128 = (i128::try_from(s_2940_3).unwrap());
        // C s_2940_5: const #0s : i
        let s_2940_5: i128 = 0;
        // C s_2940_6: add s_2940_5 s_2940_4
        let s_2940_6: i128 = (s_2940_5 + s_2940_4);
        // D s_2940_7: bit-extract s_2940_2 s_2940_0 s_2940_6
        let s_2940_7: Bits = (Bits::new(
            ((s_2940_2) >> (s_2940_0)).value(),
            u16::try_from(s_2940_6).unwrap(),
        ));
        // D s_2940_8: cast reint s_2940_7 -> u8
        let s_2940_8: bool = ((s_2940_7.value()) != 0);
        // D s_2940_9: cast zx s_2940_8 -> bv
        let s_2940_9: Bits = Bits::new(s_2940_8 as u128, 1u16);
        // C s_2940_10: const #0u : u8
        let s_2940_10: bool = false;
        // C s_2940_11: cast zx s_2940_10 -> bv
        let s_2940_11: Bits = Bits::new(s_2940_10 as u128, 1u16);
        // D s_2940_12: cmp-eq s_2940_9 s_2940_11
        let s_2940_12: bool = ((s_2940_9) == (s_2940_11));
        // D s_2940_13: write-var gs#404126 <= s_2940_12
        fn_state.gs_404126 = s_2940_12;
        // N s_2940_14: jump b58
        return block_58(state, tracer, fn_state);
    }
    fn block_2941<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2941_0: const #28s : i
        let s_2941_0: i128 = 28;
        // C s_2941_1: const #4s : i
        let s_2941_1: i128 = 4;
        // D s_2941_2: read-var u#32388:u32
        let s_2941_2: u32 = fn_state.u_32388;
        // D s_2941_3: cast zx s_2941_2 -> bv
        let s_2941_3: Bits = Bits::new(s_2941_2 as u128, 32u16);
        // D s_2941_4: bit-extract s_2941_3 s_2941_0 s_2941_1
        let s_2941_4: Bits = (Bits::new(
            ((s_2941_3) >> (s_2941_0)).value(),
            u16::try_from(s_2941_1).unwrap(),
        ));
        // D s_2941_5: cast reint s_2941_4 -> u8
        let s_2941_5: u8 = (s_2941_4.value() as u8);
        // D s_2941_6: cast zx s_2941_5 -> bv
        let s_2941_6: Bits = Bits::new(s_2941_5 as u128, 4u16);
        // C s_2941_7: const #15u : u8
        let s_2941_7: u8 = 15;
        // C s_2941_8: cast zx s_2941_7 -> bv
        let s_2941_8: Bits = Bits::new(s_2941_7 as u128, 4u16);
        // D s_2941_9: cmp-ne s_2941_6 s_2941_8
        let s_2941_9: bool = ((s_2941_6) != (s_2941_8));
        // N s_2941_10: branch s_2941_9 b2944 b2942
        if s_2941_9 {
            return block_2944(state, tracer, fn_state);
        } else {
            return block_2942(state, tracer, fn_state);
        };
    }
    fn block_2942<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2942_0: const #0u : u8
        let s_2942_0: bool = false;
        // D s_2942_1: write-var gs#404107 <= s_2942_0
        fn_state.gs_404107 = s_2942_0;
        // N s_2942_2: jump b2943
        return block_2943(state, tracer, fn_state);
    }
    fn block_2943<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2943_0: read-var gs#404107:u8
        let s_2943_0: bool = fn_state.gs_404107;
        // D s_2943_1: write-var gs#404108 <= s_2943_0
        fn_state.gs_404108 = s_2943_0;
        // N s_2943_2: jump b54
        return block_54(state, tracer, fn_state);
    }
    fn block_2944<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2944_0: const #2843s : i
        let s_2944_0: i128 = 2843;
        // C s_2944_1: const #14696u : u32
        let s_2944_1: u32 = 14696;
        // D s_2944_2: read-reg s_2944_1:i
        let s_2944_2: i128 = {
            let value = state.read_register::<i128>(s_2944_1 as isize);
            tracer.read_register(s_2944_1 as isize, value);
            value
        };
        // D s_2944_3: cmp-lt s_2944_2 s_2944_0
        let s_2944_3: bool = ((s_2944_2) < (s_2944_0));
        // D s_2944_4: write-var gs#404107 <= s_2944_3
        fn_state.gs_404107 = s_2944_3;
        // N s_2944_5: jump b2943
        return block_2943(state, tracer, fn_state);
    }
    fn block_2945<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2945_0: const #28s : i
        let s_2945_0: i128 = 28;
        // C s_2945_1: const #4s : i
        let s_2945_1: i128 = 4;
        // D s_2945_2: read-var u#32383:u32
        let s_2945_2: u32 = fn_state.u_32383;
        // D s_2945_3: cast zx s_2945_2 -> bv
        let s_2945_3: Bits = Bits::new(s_2945_2 as u128, 32u16);
        // D s_2945_4: bit-extract s_2945_3 s_2945_0 s_2945_1
        let s_2945_4: Bits = (Bits::new(
            ((s_2945_3) >> (s_2945_0)).value(),
            u16::try_from(s_2945_1).unwrap(),
        ));
        // D s_2945_5: cast reint s_2945_4 -> u8
        let s_2945_5: u8 = (s_2945_4.value() as u8);
        // D s_2945_6: cast zx s_2945_5 -> bv
        let s_2945_6: Bits = Bits::new(s_2945_5 as u128, 4u16);
        // C s_2945_7: const #15u : u8
        let s_2945_7: u8 = 15;
        // C s_2945_8: cast zx s_2945_7 -> bv
        let s_2945_8: Bits = Bits::new(s_2945_7 as u128, 4u16);
        // D s_2945_9: cmp-ne s_2945_6 s_2945_8
        let s_2945_9: bool = ((s_2945_6) != (s_2945_8));
        // N s_2945_10: branch s_2945_9 b2948 b2946
        if s_2945_9 {
            return block_2948(state, tracer, fn_state);
        } else {
            return block_2946(state, tracer, fn_state);
        };
    }
    fn block_2946<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2946_0: const #0u : u8
        let s_2946_0: bool = false;
        // D s_2946_1: write-var gs#404091 <= s_2946_0
        fn_state.gs_404091 = s_2946_0;
        // N s_2946_2: jump b2947
        return block_2947(state, tracer, fn_state);
    }
    fn block_2947<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2947_0: read-var gs#404091:u8
        let s_2947_0: bool = fn_state.gs_404091;
        // D s_2947_1: write-var gs#404092 <= s_2947_0
        fn_state.gs_404092 = s_2947_0;
        // N s_2947_2: jump b50
        return block_50(state, tracer, fn_state);
    }
    fn block_2948<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2948_0: const #2839s : i
        let s_2948_0: i128 = 2839;
        // C s_2948_1: const #14696u : u32
        let s_2948_1: u32 = 14696;
        // D s_2948_2: read-reg s_2948_1:i
        let s_2948_2: i128 = {
            let value = state.read_register::<i128>(s_2948_1 as isize);
            tracer.read_register(s_2948_1 as isize, value);
            value
        };
        // D s_2948_3: cmp-lt s_2948_2 s_2948_0
        let s_2948_3: bool = ((s_2948_2) < (s_2948_0));
        // D s_2948_4: write-var gs#404091 <= s_2948_3
        fn_state.gs_404091 = s_2948_3;
        // N s_2948_5: jump b2947
        return block_2947(state, tracer, fn_state);
    }
    fn block_2949<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2949_0: const #28s : i
        let s_2949_0: i128 = 28;
        // C s_2949_1: const #4s : i
        let s_2949_1: i128 = 4;
        // D s_2949_2: read-var u#32378:u32
        let s_2949_2: u32 = fn_state.u_32378;
        // D s_2949_3: cast zx s_2949_2 -> bv
        let s_2949_3: Bits = Bits::new(s_2949_2 as u128, 32u16);
        // D s_2949_4: bit-extract s_2949_3 s_2949_0 s_2949_1
        let s_2949_4: Bits = (Bits::new(
            ((s_2949_3) >> (s_2949_0)).value(),
            u16::try_from(s_2949_1).unwrap(),
        ));
        // D s_2949_5: cast reint s_2949_4 -> u8
        let s_2949_5: u8 = (s_2949_4.value() as u8);
        // D s_2949_6: cast zx s_2949_5 -> bv
        let s_2949_6: Bits = Bits::new(s_2949_5 as u128, 4u16);
        // C s_2949_7: const #15u : u8
        let s_2949_7: u8 = 15;
        // C s_2949_8: cast zx s_2949_7 -> bv
        let s_2949_8: Bits = Bits::new(s_2949_7 as u128, 4u16);
        // D s_2949_9: cmp-ne s_2949_6 s_2949_8
        let s_2949_9: bool = ((s_2949_6) != (s_2949_8));
        // N s_2949_10: branch s_2949_9 b2952 b2950
        if s_2949_9 {
            return block_2952(state, tracer, fn_state);
        } else {
            return block_2950(state, tracer, fn_state);
        };
    }
    fn block_2950<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2950_0: const #0u : u8
        let s_2950_0: bool = false;
        // D s_2950_1: write-var gs#404075 <= s_2950_0
        fn_state.gs_404075 = s_2950_0;
        // N s_2950_2: jump b2951
        return block_2951(state, tracer, fn_state);
    }
    fn block_2951<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2951_0: read-var gs#404075:u8
        let s_2951_0: bool = fn_state.gs_404075;
        // D s_2951_1: write-var gs#404076 <= s_2951_0
        fn_state.gs_404076 = s_2951_0;
        // N s_2951_2: jump b46
        return block_46(state, tracer, fn_state);
    }
    fn block_2952<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2952_0: const #2838s : i
        let s_2952_0: i128 = 2838;
        // C s_2952_1: const #14696u : u32
        let s_2952_1: u32 = 14696;
        // D s_2952_2: read-reg s_2952_1:i
        let s_2952_2: i128 = {
            let value = state.read_register::<i128>(s_2952_1 as isize);
            tracer.read_register(s_2952_1 as isize, value);
            value
        };
        // D s_2952_3: cmp-lt s_2952_2 s_2952_0
        let s_2952_3: bool = ((s_2952_2) < (s_2952_0));
        // D s_2952_4: write-var gs#404075 <= s_2952_3
        fn_state.gs_404075 = s_2952_3;
        // N s_2952_5: jump b2951
        return block_2951(state, tracer, fn_state);
    }
    fn block_2953<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2953_0: const #28s : i
        let s_2953_0: i128 = 28;
        // C s_2953_1: const #4s : i
        let s_2953_1: i128 = 4;
        // D s_2953_2: read-var u#32370:u32
        let s_2953_2: u32 = fn_state.u_32370;
        // D s_2953_3: cast zx s_2953_2 -> bv
        let s_2953_3: Bits = Bits::new(s_2953_2 as u128, 32u16);
        // D s_2953_4: bit-extract s_2953_3 s_2953_0 s_2953_1
        let s_2953_4: Bits = (Bits::new(
            ((s_2953_3) >> (s_2953_0)).value(),
            u16::try_from(s_2953_1).unwrap(),
        ));
        // D s_2953_5: cast reint s_2953_4 -> u8
        let s_2953_5: u8 = (s_2953_4.value() as u8);
        // D s_2953_6: cast zx s_2953_5 -> bv
        let s_2953_6: Bits = Bits::new(s_2953_5 as u128, 4u16);
        // C s_2953_7: const #15u : u8
        let s_2953_7: u8 = 15;
        // C s_2953_8: cast zx s_2953_7 -> bv
        let s_2953_8: Bits = Bits::new(s_2953_7 as u128, 4u16);
        // D s_2953_9: cmp-ne s_2953_6 s_2953_8
        let s_2953_9: bool = ((s_2953_6) != (s_2953_8));
        // N s_2953_10: branch s_2953_9 b2956 b2954
        if s_2953_9 {
            return block_2956(state, tracer, fn_state);
        } else {
            return block_2954(state, tracer, fn_state);
        };
    }
    fn block_2954<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2954_0: const #0u : u8
        let s_2954_0: bool = false;
        // D s_2954_1: write-var gs#404053 <= s_2954_0
        fn_state.gs_404053 = s_2954_0;
        // N s_2954_2: jump b2955
        return block_2955(state, tracer, fn_state);
    }
    fn block_2955<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2955_0: read-var gs#404053:u8
        let s_2955_0: bool = fn_state.gs_404053;
        // D s_2955_1: write-var gs#404054 <= s_2955_0
        fn_state.gs_404054 = s_2955_0;
        // N s_2955_2: jump b42
        return block_42(state, tracer, fn_state);
    }
    fn block_2956<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2956_0: const #2834s : i
        let s_2956_0: i128 = 2834;
        // C s_2956_1: const #14696u : u32
        let s_2956_1: u32 = 14696;
        // D s_2956_2: read-reg s_2956_1:i
        let s_2956_2: i128 = {
            let value = state.read_register::<i128>(s_2956_1 as isize);
            tracer.read_register(s_2956_1 as isize, value);
            value
        };
        // D s_2956_3: cmp-lt s_2956_2 s_2956_0
        let s_2956_3: bool = ((s_2956_2) < (s_2956_0));
        // D s_2956_4: write-var gs#404053 <= s_2956_3
        fn_state.gs_404053 = s_2956_3;
        // N s_2956_5: jump b2955
        return block_2955(state, tracer, fn_state);
    }
    fn block_2957<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2957_0: const #16s : i
        let s_2957_0: i128 = 16;
        // D s_2957_1: read-var u#32370:u32
        let s_2957_1: u32 = fn_state.u_32370;
        // D s_2957_2: cast zx s_2957_1 -> bv
        let s_2957_2: Bits = Bits::new(s_2957_1 as u128, 32u16);
        // C s_2957_3: const #1s : i64
        let s_2957_3: i64 = 1;
        // C s_2957_4: cast zx s_2957_3 -> i
        let s_2957_4: i128 = (i128::try_from(s_2957_3).unwrap());
        // C s_2957_5: const #3s : i
        let s_2957_5: i128 = 3;
        // C s_2957_6: add s_2957_5 s_2957_4
        let s_2957_6: i128 = (s_2957_5 + s_2957_4);
        // D s_2957_7: bit-extract s_2957_2 s_2957_0 s_2957_6
        let s_2957_7: Bits = (Bits::new(
            ((s_2957_2) >> (s_2957_0)).value(),
            u16::try_from(s_2957_6).unwrap(),
        ));
        // D s_2957_8: cast reint s_2957_7 -> u8
        let s_2957_8: u8 = (s_2957_7.value() as u8);
        // D s_2957_9: cast zx s_2957_8 -> bv
        let s_2957_9: Bits = Bits::new(s_2957_8 as u128, 4u16);
        // C s_2957_10: const #13u : u8
        let s_2957_10: u8 = 13;
        // C s_2957_11: cast zx s_2957_10 -> bv
        let s_2957_11: Bits = Bits::new(s_2957_10 as u128, 4u16);
        // D s_2957_12: cmp-eq s_2957_9 s_2957_11
        let s_2957_12: bool = ((s_2957_9) == (s_2957_11));
        // N s_2957_13: branch s_2957_12 b2960 b2958
        if s_2957_12 {
            return block_2960(state, tracer, fn_state);
        } else {
            return block_2958(state, tracer, fn_state);
        };
    }
    fn block_2958<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2958_0: const #0u : u8
        let s_2958_0: bool = false;
        // D s_2958_1: write-var gs#404048 <= s_2958_0
        fn_state.gs_404048 = s_2958_0;
        // N s_2958_2: jump b2959
        return block_2959(state, tracer, fn_state);
    }
    fn block_2959<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2959_0: read-var gs#404048:u8
        let s_2959_0: bool = fn_state.gs_404048;
        // D s_2959_1: write-var gs#404049 <= s_2959_0
        fn_state.gs_404049 = s_2959_0;
        // N s_2959_2: jump b40
        return block_40(state, tracer, fn_state);
    }
    fn block_2960<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2960_0: const #4s : i
        let s_2960_0: i128 = 4;
        // D s_2960_1: read-var u#32370:u32
        let s_2960_1: u32 = fn_state.u_32370;
        // D s_2960_2: cast zx s_2960_1 -> bv
        let s_2960_2: Bits = Bits::new(s_2960_1 as u128, 32u16);
        // C s_2960_3: const #1s : i64
        let s_2960_3: i64 = 1;
        // C s_2960_4: cast zx s_2960_3 -> i
        let s_2960_4: i128 = (i128::try_from(s_2960_3).unwrap());
        // C s_2960_5: const #0s : i
        let s_2960_5: i128 = 0;
        // C s_2960_6: add s_2960_5 s_2960_4
        let s_2960_6: i128 = (s_2960_5 + s_2960_4);
        // D s_2960_7: bit-extract s_2960_2 s_2960_0 s_2960_6
        let s_2960_7: Bits = (Bits::new(
            ((s_2960_2) >> (s_2960_0)).value(),
            u16::try_from(s_2960_6).unwrap(),
        ));
        // D s_2960_8: cast reint s_2960_7 -> u8
        let s_2960_8: bool = ((s_2960_7.value()) != 0);
        // D s_2960_9: cast zx s_2960_8 -> bv
        let s_2960_9: Bits = Bits::new(s_2960_8 as u128, 1u16);
        // C s_2960_10: const #0u : u8
        let s_2960_10: bool = false;
        // C s_2960_11: cast zx s_2960_10 -> bv
        let s_2960_11: Bits = Bits::new(s_2960_10 as u128, 1u16);
        // D s_2960_12: cmp-eq s_2960_9 s_2960_11
        let s_2960_12: bool = ((s_2960_9) == (s_2960_11));
        // D s_2960_13: write-var gs#404048 <= s_2960_12
        fn_state.gs_404048 = s_2960_12;
        // N s_2960_14: jump b2959
        return block_2959(state, tracer, fn_state);
    }
    fn block_2961<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2961_0: const #28s : i
        let s_2961_0: i128 = 28;
        // C s_2961_1: const #4s : i
        let s_2961_1: i128 = 4;
        // D s_2961_2: read-var u#32364:u32
        let s_2961_2: u32 = fn_state.u_32364;
        // D s_2961_3: cast zx s_2961_2 -> bv
        let s_2961_3: Bits = Bits::new(s_2961_2 as u128, 32u16);
        // D s_2961_4: bit-extract s_2961_3 s_2961_0 s_2961_1
        let s_2961_4: Bits = (Bits::new(
            ((s_2961_3) >> (s_2961_0)).value(),
            u16::try_from(s_2961_1).unwrap(),
        ));
        // D s_2961_5: cast reint s_2961_4 -> u8
        let s_2961_5: u8 = (s_2961_4.value() as u8);
        // D s_2961_6: cast zx s_2961_5 -> bv
        let s_2961_6: Bits = Bits::new(s_2961_5 as u128, 4u16);
        // C s_2961_7: const #15u : u8
        let s_2961_7: u8 = 15;
        // C s_2961_8: cast zx s_2961_7 -> bv
        let s_2961_8: Bits = Bits::new(s_2961_7 as u128, 4u16);
        // D s_2961_9: cmp-ne s_2961_6 s_2961_8
        let s_2961_9: bool = ((s_2961_6) != (s_2961_8));
        // N s_2961_10: branch s_2961_9 b2964 b2962
        if s_2961_9 {
            return block_2964(state, tracer, fn_state);
        } else {
            return block_2962(state, tracer, fn_state);
        };
    }
    fn block_2962<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2962_0: const #0u : u8
        let s_2962_0: bool = false;
        // D s_2962_1: write-var gs#404029 <= s_2962_0
        fn_state.gs_404029 = s_2962_0;
        // N s_2962_2: jump b2963
        return block_2963(state, tracer, fn_state);
    }
    fn block_2963<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2963_0: read-var gs#404029:u8
        let s_2963_0: bool = fn_state.gs_404029;
        // D s_2963_1: write-var gs#404030 <= s_2963_0
        fn_state.gs_404030 = s_2963_0;
        // N s_2963_2: jump b36
        return block_36(state, tracer, fn_state);
    }
    fn block_2964<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2964_0: const #2829s : i
        let s_2964_0: i128 = 2829;
        // C s_2964_1: const #14696u : u32
        let s_2964_1: u32 = 14696;
        // D s_2964_2: read-reg s_2964_1:i
        let s_2964_2: i128 = {
            let value = state.read_register::<i128>(s_2964_1 as isize);
            tracer.read_register(s_2964_1 as isize, value);
            value
        };
        // D s_2964_3: cmp-lt s_2964_2 s_2964_0
        let s_2964_3: bool = ((s_2964_2) < (s_2964_0));
        // D s_2964_4: write-var gs#404029 <= s_2964_3
        fn_state.gs_404029 = s_2964_3;
        // N s_2964_5: jump b2963
        return block_2963(state, tracer, fn_state);
    }
    fn block_2965<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2965_0: const #16s : i
        let s_2965_0: i128 = 16;
        // D s_2965_1: read-var u#32364:u32
        let s_2965_1: u32 = fn_state.u_32364;
        // D s_2965_2: cast zx s_2965_1 -> bv
        let s_2965_2: Bits = Bits::new(s_2965_1 as u128, 32u16);
        // C s_2965_3: const #1s : i64
        let s_2965_3: i64 = 1;
        // C s_2965_4: cast zx s_2965_3 -> i
        let s_2965_4: i128 = (i128::try_from(s_2965_3).unwrap());
        // C s_2965_5: const #3s : i
        let s_2965_5: i128 = 3;
        // C s_2965_6: add s_2965_5 s_2965_4
        let s_2965_6: i128 = (s_2965_5 + s_2965_4);
        // D s_2965_7: bit-extract s_2965_2 s_2965_0 s_2965_6
        let s_2965_7: Bits = (Bits::new(
            ((s_2965_2) >> (s_2965_0)).value(),
            u16::try_from(s_2965_6).unwrap(),
        ));
        // D s_2965_8: cast reint s_2965_7 -> u8
        let s_2965_8: u8 = (s_2965_7.value() as u8);
        // D s_2965_9: cast zx s_2965_8 -> bv
        let s_2965_9: Bits = Bits::new(s_2965_8 as u128, 4u16);
        // C s_2965_10: const #13u : u8
        let s_2965_10: u8 = 13;
        // C s_2965_11: cast zx s_2965_10 -> bv
        let s_2965_11: Bits = Bits::new(s_2965_10 as u128, 4u16);
        // D s_2965_12: cmp-eq s_2965_9 s_2965_11
        let s_2965_12: bool = ((s_2965_9) == (s_2965_11));
        // D s_2965_13: write-var gs#404025 <= s_2965_12
        fn_state.gs_404025 = s_2965_12;
        // N s_2965_14: jump b34
        return block_34(state, tracer, fn_state);
    }
    fn block_2966<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2966_0: const #28s : i
        let s_2966_0: i128 = 28;
        // C s_2966_1: const #4s : i
        let s_2966_1: i128 = 4;
        // D s_2966_2: read-var u#32355:u32
        let s_2966_2: u32 = fn_state.u_32355;
        // D s_2966_3: cast zx s_2966_2 -> bv
        let s_2966_3: Bits = Bits::new(s_2966_2 as u128, 32u16);
        // D s_2966_4: bit-extract s_2966_3 s_2966_0 s_2966_1
        let s_2966_4: Bits = (Bits::new(
            ((s_2966_3) >> (s_2966_0)).value(),
            u16::try_from(s_2966_1).unwrap(),
        ));
        // D s_2966_5: cast reint s_2966_4 -> u8
        let s_2966_5: u8 = (s_2966_4.value() as u8);
        // D s_2966_6: cast zx s_2966_5 -> bv
        let s_2966_6: Bits = Bits::new(s_2966_5 as u128, 4u16);
        // C s_2966_7: const #15u : u8
        let s_2966_7: u8 = 15;
        // C s_2966_8: cast zx s_2966_7 -> bv
        let s_2966_8: Bits = Bits::new(s_2966_7 as u128, 4u16);
        // D s_2966_9: cmp-ne s_2966_6 s_2966_8
        let s_2966_9: bool = ((s_2966_6) != (s_2966_8));
        // N s_2966_10: branch s_2966_9 b2969 b2967
        if s_2966_9 {
            return block_2969(state, tracer, fn_state);
        } else {
            return block_2967(state, tracer, fn_state);
        };
    }
    fn block_2967<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2967_0: const #0u : u8
        let s_2967_0: bool = false;
        // D s_2967_1: write-var gs#404002 <= s_2967_0
        fn_state.gs_404002 = s_2967_0;
        // N s_2967_2: jump b2968
        return block_2968(state, tracer, fn_state);
    }
    fn block_2968<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2968_0: read-var gs#404002:u8
        let s_2968_0: bool = fn_state.gs_404002;
        // D s_2968_1: write-var gs#404003 <= s_2968_0
        fn_state.gs_404003 = s_2968_0;
        // N s_2968_2: jump b30
        return block_30(state, tracer, fn_state);
    }
    fn block_2969<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2969_0: const #2828s : i
        let s_2969_0: i128 = 2828;
        // C s_2969_1: const #14696u : u32
        let s_2969_1: u32 = 14696;
        // D s_2969_2: read-reg s_2969_1:i
        let s_2969_2: i128 = {
            let value = state.read_register::<i128>(s_2969_1 as isize);
            tracer.read_register(s_2969_1 as isize, value);
            value
        };
        // D s_2969_3: cmp-lt s_2969_2 s_2969_0
        let s_2969_3: bool = ((s_2969_2) < (s_2969_0));
        // D s_2969_4: write-var gs#404002 <= s_2969_3
        fn_state.gs_404002 = s_2969_3;
        // N s_2969_5: jump b2968
        return block_2968(state, tracer, fn_state);
    }
    fn block_2970<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2970_0: const #7s : i
        let s_2970_0: i128 = 7;
        // D s_2970_1: read-var u#32355:u32
        let s_2970_1: u32 = fn_state.u_32355;
        // D s_2970_2: cast zx s_2970_1 -> bv
        let s_2970_2: Bits = Bits::new(s_2970_1 as u128, 32u16);
        // C s_2970_3: const #1s : i64
        let s_2970_3: i64 = 1;
        // C s_2970_4: cast zx s_2970_3 -> i
        let s_2970_4: i128 = (i128::try_from(s_2970_3).unwrap());
        // C s_2970_5: const #0s : i
        let s_2970_5: i128 = 0;
        // C s_2970_6: add s_2970_5 s_2970_4
        let s_2970_6: i128 = (s_2970_5 + s_2970_4);
        // D s_2970_7: bit-extract s_2970_2 s_2970_0 s_2970_6
        let s_2970_7: Bits = (Bits::new(
            ((s_2970_2) >> (s_2970_0)).value(),
            u16::try_from(s_2970_6).unwrap(),
        ));
        // D s_2970_8: cast reint s_2970_7 -> u8
        let s_2970_8: bool = ((s_2970_7.value()) != 0);
        // D s_2970_9: cast zx s_2970_8 -> bv
        let s_2970_9: Bits = Bits::new(s_2970_8 as u128, 1u16);
        // C s_2970_10: const #0u : u8
        let s_2970_10: bool = false;
        // C s_2970_11: cast zx s_2970_10 -> bv
        let s_2970_11: Bits = Bits::new(s_2970_10 as u128, 1u16);
        // D s_2970_12: cmp-eq s_2970_9 s_2970_11
        let s_2970_12: bool = ((s_2970_9) == (s_2970_11));
        // N s_2970_13: branch s_2970_12 b2973 b2971
        if s_2970_12 {
            return block_2973(state, tracer, fn_state);
        } else {
            return block_2971(state, tracer, fn_state);
        };
    }
    fn block_2971<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2971_0: const #0u : u8
        let s_2971_0: bool = false;
        // D s_2971_1: write-var gs#403997 <= s_2971_0
        fn_state.gs_403997 = s_2971_0;
        // N s_2971_2: jump b2972
        return block_2972(state, tracer, fn_state);
    }
    fn block_2972<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2972_0: read-var gs#403997:u8
        let s_2972_0: bool = fn_state.gs_403997;
        // D s_2972_1: write-var gs#403998 <= s_2972_0
        fn_state.gs_403998 = s_2972_0;
        // N s_2972_2: jump b28
        return block_28(state, tracer, fn_state);
    }
    fn block_2973<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2973_0: const #4s : i
        let s_2973_0: i128 = 4;
        // D s_2973_1: read-var u#32355:u32
        let s_2973_1: u32 = fn_state.u_32355;
        // D s_2973_2: cast zx s_2973_1 -> bv
        let s_2973_2: Bits = Bits::new(s_2973_1 as u128, 32u16);
        // C s_2973_3: const #1s : i64
        let s_2973_3: i64 = 1;
        // C s_2973_4: cast zx s_2973_3 -> i
        let s_2973_4: i128 = (i128::try_from(s_2973_3).unwrap());
        // C s_2973_5: const #0s : i
        let s_2973_5: i128 = 0;
        // C s_2973_6: add s_2973_5 s_2973_4
        let s_2973_6: i128 = (s_2973_5 + s_2973_4);
        // D s_2973_7: bit-extract s_2973_2 s_2973_0 s_2973_6
        let s_2973_7: Bits = (Bits::new(
            ((s_2973_2) >> (s_2973_0)).value(),
            u16::try_from(s_2973_6).unwrap(),
        ));
        // D s_2973_8: cast reint s_2973_7 -> u8
        let s_2973_8: bool = ((s_2973_7.value()) != 0);
        // D s_2973_9: cast zx s_2973_8 -> bv
        let s_2973_9: Bits = Bits::new(s_2973_8 as u128, 1u16);
        // C s_2973_10: const #1u : u8
        let s_2973_10: bool = true;
        // C s_2973_11: cast zx s_2973_10 -> bv
        let s_2973_11: Bits = Bits::new(s_2973_10 as u128, 1u16);
        // D s_2973_12: cmp-eq s_2973_9 s_2973_11
        let s_2973_12: bool = ((s_2973_9) == (s_2973_11));
        // D s_2973_13: write-var gs#403997 <= s_2973_12
        fn_state.gs_403997 = s_2973_12;
        // N s_2973_14: jump b2972
        return block_2972(state, tracer, fn_state);
    }
    fn block_2974<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2974_0: const #28s : i
        let s_2974_0: i128 = 28;
        // C s_2974_1: const #4s : i
        let s_2974_1: i128 = 4;
        // D s_2974_2: read-var u#32346:u32
        let s_2974_2: u32 = fn_state.u_32346;
        // D s_2974_3: cast zx s_2974_2 -> bv
        let s_2974_3: Bits = Bits::new(s_2974_2 as u128, 32u16);
        // D s_2974_4: bit-extract s_2974_3 s_2974_0 s_2974_1
        let s_2974_4: Bits = (Bits::new(
            ((s_2974_3) >> (s_2974_0)).value(),
            u16::try_from(s_2974_1).unwrap(),
        ));
        // D s_2974_5: cast reint s_2974_4 -> u8
        let s_2974_5: u8 = (s_2974_4.value() as u8);
        // D s_2974_6: cast zx s_2974_5 -> bv
        let s_2974_6: Bits = Bits::new(s_2974_5 as u128, 4u16);
        // C s_2974_7: const #15u : u8
        let s_2974_7: u8 = 15;
        // C s_2974_8: cast zx s_2974_7 -> bv
        let s_2974_8: Bits = Bits::new(s_2974_7 as u128, 4u16);
        // D s_2974_9: cmp-ne s_2974_6 s_2974_8
        let s_2974_9: bool = ((s_2974_6) != (s_2974_8));
        // N s_2974_10: branch s_2974_9 b2977 b2975
        if s_2974_9 {
            return block_2977(state, tracer, fn_state);
        } else {
            return block_2975(state, tracer, fn_state);
        };
    }
    fn block_2975<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2975_0: const #0u : u8
        let s_2975_0: bool = false;
        // D s_2975_1: write-var gs#403972 <= s_2975_0
        fn_state.gs_403972 = s_2975_0;
        // N s_2975_2: jump b2976
        return block_2976(state, tracer, fn_state);
    }
    fn block_2976<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2976_0: read-var gs#403972:u8
        let s_2976_0: bool = fn_state.gs_403972;
        // D s_2976_1: write-var gs#403973 <= s_2976_0
        fn_state.gs_403973 = s_2976_0;
        // N s_2976_2: jump b24
        return block_24(state, tracer, fn_state);
    }
    fn block_2977<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2977_0: const #2824s : i
        let s_2977_0: i128 = 2824;
        // C s_2977_1: const #14696u : u32
        let s_2977_1: u32 = 14696;
        // D s_2977_2: read-reg s_2977_1:i
        let s_2977_2: i128 = {
            let value = state.read_register::<i128>(s_2977_1 as isize);
            tracer.read_register(s_2977_1 as isize, value);
            value
        };
        // D s_2977_3: cmp-lt s_2977_2 s_2977_0
        let s_2977_3: bool = ((s_2977_2) < (s_2977_0));
        // D s_2977_4: write-var gs#403972 <= s_2977_3
        fn_state.gs_403972 = s_2977_3;
        // N s_2977_5: jump b2976
        return block_2976(state, tracer, fn_state);
    }
    fn block_2978<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2978_0: const #4s : i
        let s_2978_0: i128 = 4;
        // D s_2978_1: read-var u#32346:u32
        let s_2978_1: u32 = fn_state.u_32346;
        // D s_2978_2: cast zx s_2978_1 -> bv
        let s_2978_2: Bits = Bits::new(s_2978_1 as u128, 32u16);
        // C s_2978_3: const #1s : i64
        let s_2978_3: i64 = 1;
        // C s_2978_4: cast zx s_2978_3 -> i
        let s_2978_4: i128 = (i128::try_from(s_2978_3).unwrap());
        // C s_2978_5: const #0s : i
        let s_2978_5: i128 = 0;
        // C s_2978_6: add s_2978_5 s_2978_4
        let s_2978_6: i128 = (s_2978_5 + s_2978_4);
        // D s_2978_7: bit-extract s_2978_2 s_2978_0 s_2978_6
        let s_2978_7: Bits = (Bits::new(
            ((s_2978_2) >> (s_2978_0)).value(),
            u16::try_from(s_2978_6).unwrap(),
        ));
        // D s_2978_8: cast reint s_2978_7 -> u8
        let s_2978_8: bool = ((s_2978_7.value()) != 0);
        // D s_2978_9: cast zx s_2978_8 -> bv
        let s_2978_9: Bits = Bits::new(s_2978_8 as u128, 1u16);
        // C s_2978_10: const #0u : u8
        let s_2978_10: bool = false;
        // C s_2978_11: cast zx s_2978_10 -> bv
        let s_2978_11: Bits = Bits::new(s_2978_10 as u128, 1u16);
        // D s_2978_12: cmp-eq s_2978_9 s_2978_11
        let s_2978_12: bool = ((s_2978_9) == (s_2978_11));
        // D s_2978_13: write-var gs#403968 <= s_2978_12
        fn_state.gs_403968 = s_2978_12;
        // N s_2978_14: jump b22
        return block_22(state, tracer, fn_state);
    }
    fn block_2979<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2979_0: const #28s : i
        let s_2979_0: i128 = 28;
        // C s_2979_1: const #4s : i
        let s_2979_1: i128 = 4;
        // D s_2979_2: read-var u#32339:u32
        let s_2979_2: u32 = fn_state.u_32339;
        // D s_2979_3: cast zx s_2979_2 -> bv
        let s_2979_3: Bits = Bits::new(s_2979_2 as u128, 32u16);
        // D s_2979_4: bit-extract s_2979_3 s_2979_0 s_2979_1
        let s_2979_4: Bits = (Bits::new(
            ((s_2979_3) >> (s_2979_0)).value(),
            u16::try_from(s_2979_1).unwrap(),
        ));
        // D s_2979_5: cast reint s_2979_4 -> u8
        let s_2979_5: u8 = (s_2979_4.value() as u8);
        // D s_2979_6: cast zx s_2979_5 -> bv
        let s_2979_6: Bits = Bits::new(s_2979_5 as u128, 4u16);
        // C s_2979_7: const #15u : u8
        let s_2979_7: u8 = 15;
        // C s_2979_8: cast zx s_2979_7 -> bv
        let s_2979_8: Bits = Bits::new(s_2979_7 as u128, 4u16);
        // D s_2979_9: cmp-ne s_2979_6 s_2979_8
        let s_2979_9: bool = ((s_2979_6) != (s_2979_8));
        // N s_2979_10: branch s_2979_9 b2982 b2980
        if s_2979_9 {
            return block_2982(state, tracer, fn_state);
        } else {
            return block_2980(state, tracer, fn_state);
        };
    }
    fn block_2980<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2980_0: const #0u : u8
        let s_2980_0: bool = false;
        // D s_2980_1: write-var gs#403949 <= s_2980_0
        fn_state.gs_403949 = s_2980_0;
        // N s_2980_2: jump b2981
        return block_2981(state, tracer, fn_state);
    }
    fn block_2981<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2981_0: read-var gs#403949:u8
        let s_2981_0: bool = fn_state.gs_403949;
        // D s_2981_1: write-var gs#403950 <= s_2981_0
        fn_state.gs_403950 = s_2981_0;
        // N s_2981_2: jump b18
        return block_18(state, tracer, fn_state);
    }
    fn block_2982<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2982_0: const #2819s : i
        let s_2982_0: i128 = 2819;
        // C s_2982_1: const #14696u : u32
        let s_2982_1: u32 = 14696;
        // D s_2982_2: read-reg s_2982_1:i
        let s_2982_2: i128 = {
            let value = state.read_register::<i128>(s_2982_1 as isize);
            tracer.read_register(s_2982_1 as isize, value);
            value
        };
        // D s_2982_3: cmp-lt s_2982_2 s_2982_0
        let s_2982_3: bool = ((s_2982_2) < (s_2982_0));
        // D s_2982_4: write-var gs#403949 <= s_2982_3
        fn_state.gs_403949 = s_2982_3;
        // N s_2982_5: jump b2981
        return block_2981(state, tracer, fn_state);
    }
    fn block_2983<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2983_0: const #28s : i
        let s_2983_0: i128 = 28;
        // C s_2983_1: const #4s : i
        let s_2983_1: i128 = 4;
        // D s_2983_2: read-var u#32331:u32
        let s_2983_2: u32 = fn_state.u_32331;
        // D s_2983_3: cast zx s_2983_2 -> bv
        let s_2983_3: Bits = Bits::new(s_2983_2 as u128, 32u16);
        // D s_2983_4: bit-extract s_2983_3 s_2983_0 s_2983_1
        let s_2983_4: Bits = (Bits::new(
            ((s_2983_3) >> (s_2983_0)).value(),
            u16::try_from(s_2983_1).unwrap(),
        ));
        // D s_2983_5: cast reint s_2983_4 -> u8
        let s_2983_5: u8 = (s_2983_4.value() as u8);
        // D s_2983_6: cast zx s_2983_5 -> bv
        let s_2983_6: Bits = Bits::new(s_2983_5 as u128, 4u16);
        // C s_2983_7: const #15u : u8
        let s_2983_7: u8 = 15;
        // C s_2983_8: cast zx s_2983_7 -> bv
        let s_2983_8: Bits = Bits::new(s_2983_7 as u128, 4u16);
        // D s_2983_9: cmp-ne s_2983_6 s_2983_8
        let s_2983_9: bool = ((s_2983_6) != (s_2983_8));
        // N s_2983_10: branch s_2983_9 b2986 b2984
        if s_2983_9 {
            return block_2986(state, tracer, fn_state);
        } else {
            return block_2984(state, tracer, fn_state);
        };
    }
    fn block_2984<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2984_0: const #0u : u8
        let s_2984_0: bool = false;
        // D s_2984_1: write-var gs#403925 <= s_2984_0
        fn_state.gs_403925 = s_2984_0;
        // N s_2984_2: jump b2985
        return block_2985(state, tracer, fn_state);
    }
    fn block_2985<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2985_0: read-var gs#403925:u8
        let s_2985_0: bool = fn_state.gs_403925;
        // D s_2985_1: write-var gs#403926 <= s_2985_0
        fn_state.gs_403926 = s_2985_0;
        // N s_2985_2: jump b14
        return block_14(state, tracer, fn_state);
    }
    fn block_2986<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2986_0: const #2818s : i
        let s_2986_0: i128 = 2818;
        // C s_2986_1: const #14696u : u32
        let s_2986_1: u32 = 14696;
        // D s_2986_2: read-reg s_2986_1:i
        let s_2986_2: i128 = {
            let value = state.read_register::<i128>(s_2986_1 as isize);
            tracer.read_register(s_2986_1 as isize, value);
            value
        };
        // D s_2986_3: cmp-lt s_2986_2 s_2986_0
        let s_2986_3: bool = ((s_2986_2) < (s_2986_0));
        // D s_2986_4: write-var gs#403925 <= s_2986_3
        fn_state.gs_403925 = s_2986_3;
        // N s_2986_5: jump b2985
        return block_2985(state, tracer, fn_state);
    }
    fn block_2987<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2987_0: const #7s : i
        let s_2987_0: i128 = 7;
        // D s_2987_1: read-var u#32331:u32
        let s_2987_1: u32 = fn_state.u_32331;
        // D s_2987_2: cast zx s_2987_1 -> bv
        let s_2987_2: Bits = Bits::new(s_2987_1 as u128, 32u16);
        // C s_2987_3: const #1s : i64
        let s_2987_3: i64 = 1;
        // C s_2987_4: cast zx s_2987_3 -> i
        let s_2987_4: i128 = (i128::try_from(s_2987_3).unwrap());
        // C s_2987_5: const #0s : i
        let s_2987_5: i128 = 0;
        // C s_2987_6: add s_2987_5 s_2987_4
        let s_2987_6: i128 = (s_2987_5 + s_2987_4);
        // D s_2987_7: bit-extract s_2987_2 s_2987_0 s_2987_6
        let s_2987_7: Bits = (Bits::new(
            ((s_2987_2) >> (s_2987_0)).value(),
            u16::try_from(s_2987_6).unwrap(),
        ));
        // D s_2987_8: cast reint s_2987_7 -> u8
        let s_2987_8: bool = ((s_2987_7.value()) != 0);
        // D s_2987_9: cast zx s_2987_8 -> bv
        let s_2987_9: Bits = Bits::new(s_2987_8 as u128, 1u16);
        // C s_2987_10: const #0u : u8
        let s_2987_10: bool = false;
        // C s_2987_11: cast zx s_2987_10 -> bv
        let s_2987_11: Bits = Bits::new(s_2987_10 as u128, 1u16);
        // D s_2987_12: cmp-eq s_2987_9 s_2987_11
        let s_2987_12: bool = ((s_2987_9) == (s_2987_11));
        // N s_2987_13: branch s_2987_12 b2990 b2988
        if s_2987_12 {
            return block_2990(state, tracer, fn_state);
        } else {
            return block_2988(state, tracer, fn_state);
        };
    }
    fn block_2988<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2988_0: const #0u : u8
        let s_2988_0: bool = false;
        // D s_2988_1: write-var gs#403920 <= s_2988_0
        fn_state.gs_403920 = s_2988_0;
        // N s_2988_2: jump b2989
        return block_2989(state, tracer, fn_state);
    }
    fn block_2989<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2989_0: read-var gs#403920:u8
        let s_2989_0: bool = fn_state.gs_403920;
        // D s_2989_1: write-var gs#403921 <= s_2989_0
        fn_state.gs_403921 = s_2989_0;
        // N s_2989_2: jump b12
        return block_12(state, tracer, fn_state);
    }
    fn block_2990<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2990_0: const #4s : i
        let s_2990_0: i128 = 4;
        // D s_2990_1: read-var u#32331:u32
        let s_2990_1: u32 = fn_state.u_32331;
        // D s_2990_2: cast zx s_2990_1 -> bv
        let s_2990_2: Bits = Bits::new(s_2990_1 as u128, 32u16);
        // C s_2990_3: const #1s : i64
        let s_2990_3: i64 = 1;
        // C s_2990_4: cast zx s_2990_3 -> i
        let s_2990_4: i128 = (i128::try_from(s_2990_3).unwrap());
        // C s_2990_5: const #0s : i
        let s_2990_5: i128 = 0;
        // C s_2990_6: add s_2990_5 s_2990_4
        let s_2990_6: i128 = (s_2990_5 + s_2990_4);
        // D s_2990_7: bit-extract s_2990_2 s_2990_0 s_2990_6
        let s_2990_7: Bits = (Bits::new(
            ((s_2990_2) >> (s_2990_0)).value(),
            u16::try_from(s_2990_6).unwrap(),
        ));
        // D s_2990_8: cast reint s_2990_7 -> u8
        let s_2990_8: bool = ((s_2990_7.value()) != 0);
        // D s_2990_9: cast zx s_2990_8 -> bv
        let s_2990_9: Bits = Bits::new(s_2990_8 as u128, 1u16);
        // C s_2990_10: const #1u : u8
        let s_2990_10: bool = true;
        // C s_2990_11: cast zx s_2990_10 -> bv
        let s_2990_11: Bits = Bits::new(s_2990_10 as u128, 1u16);
        // D s_2990_12: cmp-eq s_2990_9 s_2990_11
        let s_2990_12: bool = ((s_2990_9) == (s_2990_11));
        // D s_2990_13: write-var gs#403920 <= s_2990_12
        fn_state.gs_403920 = s_2990_12;
        // N s_2990_14: jump b2989
        return block_2989(state, tracer, fn_state);
    }
    fn block_2991<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2991_0: const #28s : i
        let s_2991_0: i128 = 28;
        // C s_2991_1: const #4s : i
        let s_2991_1: i128 = 4;
        // D s_2991_2: read-var u#32325:u32
        let s_2991_2: u32 = fn_state.u_32325;
        // D s_2991_3: cast zx s_2991_2 -> bv
        let s_2991_3: Bits = Bits::new(s_2991_2 as u128, 32u16);
        // D s_2991_4: bit-extract s_2991_3 s_2991_0 s_2991_1
        let s_2991_4: Bits = (Bits::new(
            ((s_2991_3) >> (s_2991_0)).value(),
            u16::try_from(s_2991_1).unwrap(),
        ));
        // D s_2991_5: cast reint s_2991_4 -> u8
        let s_2991_5: u8 = (s_2991_4.value() as u8);
        // D s_2991_6: cast zx s_2991_5 -> bv
        let s_2991_6: Bits = Bits::new(s_2991_5 as u128, 4u16);
        // C s_2991_7: const #15u : u8
        let s_2991_7: u8 = 15;
        // C s_2991_8: cast zx s_2991_7 -> bv
        let s_2991_8: Bits = Bits::new(s_2991_7 as u128, 4u16);
        // D s_2991_9: cmp-ne s_2991_6 s_2991_8
        let s_2991_9: bool = ((s_2991_6) != (s_2991_8));
        // N s_2991_10: branch s_2991_9 b2994 b2992
        if s_2991_9 {
            return block_2994(state, tracer, fn_state);
        } else {
            return block_2992(state, tracer, fn_state);
        };
    }
    fn block_2992<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2992_0: const #0u : u8
        let s_2992_0: bool = false;
        // D s_2992_1: write-var gs#403895 <= s_2992_0
        fn_state.gs_403895 = s_2992_0;
        // N s_2992_2: jump b2993
        return block_2993(state, tracer, fn_state);
    }
    fn block_2993<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2993_0: read-var gs#403895:u8
        let s_2993_0: bool = fn_state.gs_403895;
        // D s_2993_1: write-var gs#403896 <= s_2993_0
        fn_state.gs_403896 = s_2993_0;
        // N s_2993_2: jump b8
        return block_8(state, tracer, fn_state);
    }
    fn block_2994<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2994_0: const #2815s : i
        let s_2994_0: i128 = 2815;
        // C s_2994_1: const #14696u : u32
        let s_2994_1: u32 = 14696;
        // D s_2994_2: read-reg s_2994_1:i
        let s_2994_2: i128 = {
            let value = state.read_register::<i128>(s_2994_1 as isize);
            tracer.read_register(s_2994_1 as isize, value);
            value
        };
        // D s_2994_3: cmp-lt s_2994_2 s_2994_0
        let s_2994_3: bool = ((s_2994_2) < (s_2994_0));
        // D s_2994_4: write-var gs#403895 <= s_2994_3
        fn_state.gs_403895 = s_2994_3;
        // N s_2994_5: jump b2993
        return block_2993(state, tracer, fn_state);
    }
    fn block_2995<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2995_0: const #4s : i
        let s_2995_0: i128 = 4;
        // D s_2995_1: read-var u#32325:u32
        let s_2995_1: u32 = fn_state.u_32325;
        // D s_2995_2: cast zx s_2995_1 -> bv
        let s_2995_2: Bits = Bits::new(s_2995_1 as u128, 32u16);
        // C s_2995_3: const #1s : i64
        let s_2995_3: i64 = 1;
        // C s_2995_4: cast zx s_2995_3 -> i
        let s_2995_4: i128 = (i128::try_from(s_2995_3).unwrap());
        // C s_2995_5: const #0s : i
        let s_2995_5: i128 = 0;
        // C s_2995_6: add s_2995_5 s_2995_4
        let s_2995_6: i128 = (s_2995_5 + s_2995_4);
        // D s_2995_7: bit-extract s_2995_2 s_2995_0 s_2995_6
        let s_2995_7: Bits = (Bits::new(
            ((s_2995_2) >> (s_2995_0)).value(),
            u16::try_from(s_2995_6).unwrap(),
        ));
        // D s_2995_8: cast reint s_2995_7 -> u8
        let s_2995_8: bool = ((s_2995_7.value()) != 0);
        // D s_2995_9: cast zx s_2995_8 -> bv
        let s_2995_9: Bits = Bits::new(s_2995_8 as u128, 1u16);
        // C s_2995_10: const #0u : u8
        let s_2995_10: bool = false;
        // C s_2995_11: cast zx s_2995_10 -> bv
        let s_2995_11: Bits = Bits::new(s_2995_10 as u128, 1u16);
        // D s_2995_12: cmp-eq s_2995_9 s_2995_11
        let s_2995_12: bool = ((s_2995_9) == (s_2995_11));
        // D s_2995_13: write-var gs#403891 <= s_2995_12
        fn_state.gs_403891 = s_2995_12;
        // N s_2995_14: jump b6
        return block_6(state, tracer, fn_state);
    }
    fn block_2996<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2996_0: const #28s : i
        let s_2996_0: i128 = 28;
        // C s_2996_1: const #4s : i
        let s_2996_1: i128 = 4;
        // D s_2996_2: read-var __opcode:u32
        let s_2996_2: u32 = fn_state.u__opcode;
        // D s_2996_3: cast zx s_2996_2 -> bv
        let s_2996_3: Bits = Bits::new(s_2996_2 as u128, 32u16);
        // D s_2996_4: bit-extract s_2996_3 s_2996_0 s_2996_1
        let s_2996_4: Bits = (Bits::new(
            ((s_2996_3) >> (s_2996_0)).value(),
            u16::try_from(s_2996_1).unwrap(),
        ));
        // D s_2996_5: cast reint s_2996_4 -> u8
        let s_2996_5: u8 = (s_2996_4.value() as u8);
        // D s_2996_6: cast zx s_2996_5 -> bv
        let s_2996_6: Bits = Bits::new(s_2996_5 as u128, 4u16);
        // C s_2996_7: const #15u : u8
        let s_2996_7: u8 = 15;
        // C s_2996_8: cast zx s_2996_7 -> bv
        let s_2996_8: Bits = Bits::new(s_2996_7 as u128, 4u16);
        // D s_2996_9: cmp-ne s_2996_6 s_2996_8
        let s_2996_9: bool = ((s_2996_6) != (s_2996_8));
        // N s_2996_10: branch s_2996_9 b2999 b2997
        if s_2996_9 {
            return block_2999(state, tracer, fn_state);
        } else {
            return block_2997(state, tracer, fn_state);
        };
    }
    fn block_2997<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2997_0: const #0u : u8
        let s_2997_0: bool = false;
        // D s_2997_1: write-var gs#403872 <= s_2997_0
        fn_state.gs_403872 = s_2997_0;
        // N s_2997_2: jump b2998
        return block_2998(state, tracer, fn_state);
    }
    fn block_2998<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // D s_2998_0: read-var gs#403872:u8
        let s_2998_0: bool = fn_state.gs_403872;
        // D s_2998_1: write-var gs#403873 <= s_2998_0
        fn_state.gs_403873 = s_2998_0;
        // N s_2998_2: jump b2
        return block_2(state, tracer, fn_state);
    }
    fn block_2999<T: Tracer>(
        state: &mut State,
        tracer: &T,
        mut fn_state: FunctionState,
    ) -> () {
        // C s_2999_0: const #2813s : i
        let s_2999_0: i128 = 2813;
        // C s_2999_1: const #14696u : u32
        let s_2999_1: u32 = 14696;
        // D s_2999_2: read-reg s_2999_1:i
        let s_2999_2: i128 = {
            let value = state.read_register::<i128>(s_2999_1 as isize);
            tracer.read_register(s_2999_1 as isize, value);
            value
        };
        // D s_2999_3: cmp-lt s_2999_2 s_2999_0
        let s_2999_3: bool = ((s_2999_2) < (s_2999_0));
        // D s_2999_4: write-var gs#403872 <= s_2999_3
        fn_state.gs_403872 = s_2999_3;
        // N s_2999_5: jump b2998
        return block_2998(state, tracer, fn_state);
    }
}
